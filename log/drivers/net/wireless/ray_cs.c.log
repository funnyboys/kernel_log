commit 1f15d7c8f3fcdf8c89e3c13731b2271e3647bbc4
Author: Jason Yan <yanaijie@huawei.com>
Date:   Sun Apr 26 18:37:09 2020 +0800

    ray_cs: use true,false for bool variable
    
    Fix the following coccicheck warning:
    
    drivers/net/wireless/ray_cs.c:2797:5-14: WARNING: Comparison of 0/1 to
    bool variable
    drivers/net/wireless/ray_cs.c:2798:2-11: WARNING: Assignment of 0/1 to
    bool variable
    
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
    Link: https://lore.kernel.org/r/20200426103709.6730-1-yanaijie@huawei.com

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index c1d542bfa530..bf3fbd14eda3 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2794,8 +2794,7 @@ static int __init init_ray_cs(void)
 	proc_create_data("driver/ray_cs/translate", 0200, NULL, &int_proc_ops,
 			 &translate);
 #endif
-	if (translate != 0)
-		translate = 1;
+	translate = !!translate;
 	return 0;
 } /* init_ray_cs */
 

commit 97a32539b9568bb653683349e5a76d02ff3c3e2c
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Feb 3 17:37:17 2020 -0800

    proc: convert everything to "struct proc_ops"
    
    The most notable change is DEFINE_SHOW_ATTRIBUTE macro split in
    seq_file.h.
    
    Conversion rule is:
    
            llseek          => proc_lseek
            unlocked_ioctl  => proc_ioctl
    
            xxx             => proc_xxx
    
            delete ".owner = THIS_MODULE" line
    
    [akpm@linux-foundation.org: fix drivers/isdn/capi/kcapi_proc.c]
    [sfr@canb.auug.org.au: fix kernel/sched/psi.c]
      Link: http://lkml.kernel.org/r/20200122180545.36222f50@canb.auug.org.au
    Link: http://lkml.kernel.org/r/20191225172546.GB13378@avx2
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index cf372684b681..c1d542bfa530 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2717,10 +2717,9 @@ static ssize_t ray_cs_essid_proc_write(struct file *file,
 	return count;
 }
 
-static const struct file_operations ray_cs_essid_proc_fops = {
-	.owner		= THIS_MODULE,
-	.write		= ray_cs_essid_proc_write,
-	.llseek		= noop_llseek,
+static const struct proc_ops ray_cs_essid_proc_ops = {
+	.proc_write	= ray_cs_essid_proc_write,
+	.proc_lseek	= noop_llseek,
 };
 
 static ssize_t int_proc_write(struct file *file, const char __user *buffer,
@@ -2751,10 +2750,9 @@ static ssize_t int_proc_write(struct file *file, const char __user *buffer,
 	return count;
 }
 
-static const struct file_operations int_proc_fops = {
-	.owner		= THIS_MODULE,
-	.write		= int_proc_write,
-	.llseek		= noop_llseek,
+static const struct proc_ops int_proc_ops = {
+	.proc_write	= int_proc_write,
+	.proc_lseek	= noop_llseek,
 };
 #endif
 
@@ -2790,10 +2788,10 @@ static int __init init_ray_cs(void)
 	proc_mkdir("driver/ray_cs", NULL);
 
 	proc_create_single("driver/ray_cs/ray_cs", 0, NULL, ray_cs_proc_show);
-	proc_create("driver/ray_cs/essid", 0200, NULL, &ray_cs_essid_proc_fops);
-	proc_create_data("driver/ray_cs/net_type", 0200, NULL, &int_proc_fops,
+	proc_create("driver/ray_cs/essid", 0200, NULL, &ray_cs_essid_proc_ops);
+	proc_create_data("driver/ray_cs/net_type", 0200, NULL, &int_proc_ops,
 			 &net_type);
-	proc_create_data("driver/ray_cs/translate", 0200, NULL, &int_proc_fops,
+	proc_create_data("driver/ray_cs/translate", 0200, NULL, &int_proc_ops,
 			 &translate);
 #endif
 	if (translate != 0)

commit 808cb5dc7be7033a8d8aa1f972bb73aeac58c284
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:31 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 416
    
    Based on 1 normalized pattern(s):
    
      this driver is free software you can redistribute it and or modify
      it under the terms of version 2 only of the gnu general public
      license as published by the free software foundation it is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 1 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190113.237458590@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index ee4d8106bba5..cf372684b681 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -1,24 +1,12 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*=============================================================================
  *
  * A  PCMCIA client driver for the Raylink wireless LAN card.
  * The starting point for this module was the skeleton.c in the
  * PCMCIA 2.9.12 package written by David Hinds, dahinds@users.sourceforge.net
  *
- *
  * Copyright (c) 1998  Corey Thomas (corey@world.std.com)
  *
- * This driver is free software; you can redistribute it and/or modify
- * it under the terms of version 2 only of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * It is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- *
  * Changes:
  * Arnaldo Carvalho de Melo <acme@conectiva.com.br> - 08/08/2000
  * - reorganize kmallocs in ray_attach, checking all for failure

commit 3b6edcb3fffeb9af00a7e0d21636ba2d95ef9987
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Wed Mar 6 19:48:12 2019 +0800

    ray_cs: use remove_proc_subtree to simplify procfs code
    
    Use remove_proc_subtree to remove the whole subtree
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index d5616592fc19..ee4d8106bba5 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2820,11 +2820,7 @@ static void __exit exit_ray_cs(void)
 	pr_debug("ray_cs: cleanup_module\n");
 
 #ifdef CONFIG_PROC_FS
-	remove_proc_entry("driver/ray_cs/ray_cs", NULL);
-	remove_proc_entry("driver/ray_cs/essid", NULL);
-	remove_proc_entry("driver/ray_cs/net_type", NULL);
-	remove_proc_entry("driver/ray_cs/translate", NULL);
-	remove_proc_entry("driver/ray_cs", NULL);
+	remove_proc_subtree("driver/ray_cs", NULL);
 #endif
 
 	pcmcia_unregister_driver(&ray_driver);

commit 444efbde32816a950c1749582f2e9241e3d5ee80
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Wed Mar 6 19:46:14 2019 +0800

    ray_cs: Check return value of pcmcia_register_driver
    
    init_ray_cs does not check value of pcmcia_register_driver,
    if it fails, there maybe cause a NULL pointer dereference in
    exit_ray_cs.
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 44a943d18b84..d5616592fc19 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2795,6 +2795,8 @@ static int __init init_ray_cs(void)
 	rc = pcmcia_register_driver(&ray_driver);
 	pr_debug("raylink init_module register_pcmcia_driver returns 0x%x\n",
 	      rc);
+	if (rc)
+		return rc;
 
 #ifdef CONFIG_PROC_FS
 	proc_mkdir("driver/ray_cs", NULL);

commit 999eb686aa909c4609ae336979327bcf3d876462
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Fri Jan 18 11:32:15 2019 +0800

    wireless: remove unneeded semicolon
    
    remove unneeded semicolon
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Acked-by: Ping-Ke Shih <pkshih@realtek.com>
    Acked-by: Steve deRosier <derosier@cal-sierra.com>
    Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 8b2741c8edf2..44a943d18b84 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2211,7 +2211,7 @@ static void rx_data(struct net_device *dev, struct rcs __iomem *prcs,
 			untranslate(local, skb, total_len);
 		}
 	} else { /* sniffer mode, so just pass whole packet */
-	};
+	}
 
 /************************/
 	/* Now pick up the rest of the fragments if any */

commit 72255c807156adeb167444c4206c9e5eece22287
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Dec 20 14:05:50 2018 +0000

    ray_cs: fix array out-of-bounds access
    
    Currently array element org[3] is being accessed, however the array is
    only 3 elements in size, so this looks like an off-by-one out-of-bounds
    error. Fix this by using org[2], which I believe was the original
    intent.
    
    This issue has existed in the driver back in the pre-git days, so no
    idea when it was introduced.
    
    Detected by CoverityScan, CID#711344 ("Out-of-bounds read")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 33ad87528d9a..8b2741c8edf2 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -959,7 +959,7 @@ static int translate_frame(ray_dev_t *local, struct tx_msg __iomem *ptx,
 		if (proto == htons(ETH_P_AARP) || proto == htons(ETH_P_IPX)) {
 			/* This is the selective translation table, only 2 entries */
 			writeb(0xf8,
-			       &((struct snaphdr_t __iomem *)ptx->var)->org[3]);
+			       &((struct snaphdr_t __iomem *)ptx->var)->org[2]);
 		}
 		/* Copy body of ethernet packet without ethernet header */
 		memcpy_toio((void __iomem *)&ptx->var +

commit d22d2492a35d507ec8edc0797418341bb716d8ff
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Mon Oct 22 22:47:20 2018 +0200

    ray_cs: mark expected switch fall-throughs
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    Addresses-Coverity-ID: 114948 ("Missing break in switch")
    Addresses-Coverity-ID: 114949 ("Missing break in switch")
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 08c607c031bc..33ad87528d9a 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -889,8 +889,10 @@ static int ray_hw_xmit(unsigned char *data, int len, struct net_device *dev,
 	switch (ccsindex = get_free_tx_ccs(local)) {
 	case ECCSBUSY:
 		pr_debug("ray_hw_xmit tx_ccs table busy\n");
+		/* fall through */
 	case ECCSFULL:
 		pr_debug("ray_hw_xmit No free tx ccs\n");
+		/* fall through */
 	case ECARDGONE:
 		netif_stop_queue(dev);
 		return XMIT_NO_CCS;

commit f21bcefcf91cc4549966e67debd082a2cb14bf73
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Jul 20 19:07:40 2018 +0100

    ray_cs: remove redundant pointer 'p'
    
    Pointer 'p' is being assigned but is never used hence it is
    redundant and can be removed. Also re-work if statement to remove
    redundant assignment of p.
    
    Cleans up clang warning:
    warning: variable 'p' set but not used [-Wunused-but-set-variable]
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index a7e0a17aa7e8..08c607c031bc 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -470,7 +470,6 @@ static inline struct rcs __iomem *rcs_base(ray_dev_t *dev)
 static int ray_init(struct net_device *dev)
 {
 	int i;
-	UCHAR *p;
 	struct ccs __iomem *pccs;
 	ray_dev_t *local = netdev_priv(dev);
 	struct pcmcia_device *link = local->finder;
@@ -513,12 +512,9 @@ static int ray_init(struct net_device *dev)
 	init_startup_params(local);
 
 	/* copy mac address to startup parameters */
-	if (parse_addr(phy_addr, local->sparm.b4.a_mac_addr)) {
-		p = local->sparm.b4.a_mac_addr;
-	} else {
+	if (!parse_addr(phy_addr, local->sparm.b4.a_mac_addr)) {
 		memcpy(&local->sparm.b4.a_mac_addr,
 		       &local->startup_res.station_addr, ADDRLEN);
-		p = local->sparm.b4.a_mac_addr;
 	}
 
 	clear_interrupt(local);	/* Clear any interrupt from the card */

commit 3f3942aca6da351a12543aa776467791b63b3a78
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue May 15 15:57:23 2018 +0200

    proc: introduce proc_create_single{,_data}
    
    Variants of proc_create{,_data} that directly take a seq_file show
    callback and drastically reduces the boilerplate code in the callers.
    
    All trivial callers converted over.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 7f9b16b97ea3..a7e0a17aa7e8 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2663,19 +2663,6 @@ static int ray_cs_proc_show(struct seq_file *m, void *v)
 	}
 	return 0;
 }
-
-static int ray_cs_proc_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, ray_cs_proc_show, NULL);
-}
-
-static const struct file_operations ray_cs_proc_fops = {
-	.owner = THIS_MODULE,
-	.open = ray_cs_proc_open,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
 #endif
 /*===========================================================================*/
 static int build_auth_frame(ray_dev_t *local, UCHAR *dest, int auth_type)
@@ -2814,7 +2801,7 @@ static int __init init_ray_cs(void)
 #ifdef CONFIG_PROC_FS
 	proc_mkdir("driver/ray_cs", NULL);
 
-	proc_create("driver/ray_cs/ray_cs", 0, NULL, &ray_cs_proc_fops);
+	proc_create_single("driver/ray_cs/ray_cs", 0, NULL, ray_cs_proc_show);
 	proc_create("driver/ray_cs/essid", 0200, NULL, &ray_cs_essid_proc_fops);
 	proc_create_data("driver/ray_cs/net_type", 0200, NULL, &int_proc_fops,
 			 &net_type);

commit 2ef00c53049b6a8758d118188992da01d75f3628
Author: Joe Perches <joe@perches.com>
Date:   Fri Mar 23 15:54:37 2018 -0700

    wireless: Use octal not symbolic permissions
    
    Prefer the direct use of octal for permissions.
    
    Done with checkpatch -f --types=SYMBOLIC_PERMS --fix-inplace
    and some typing.
    
    Miscellanea:
    
    o Whitespace neatening around these conversions.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 0133fcd4601b..7f9b16b97ea3 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2815,9 +2815,11 @@ static int __init init_ray_cs(void)
 	proc_mkdir("driver/ray_cs", NULL);
 
 	proc_create("driver/ray_cs/ray_cs", 0, NULL, &ray_cs_proc_fops);
-	proc_create("driver/ray_cs/essid", S_IWUSR, NULL, &ray_cs_essid_proc_fops);
-	proc_create_data("driver/ray_cs/net_type", S_IWUSR, NULL, &int_proc_fops, &net_type);
-	proc_create_data("driver/ray_cs/translate", S_IWUSR, NULL, &int_proc_fops, &translate);
+	proc_create("driver/ray_cs/essid", 0200, NULL, &ray_cs_essid_proc_fops);
+	proc_create_data("driver/ray_cs/net_type", 0200, NULL, &int_proc_fops,
+			 &net_type);
+	proc_create_data("driver/ray_cs/translate", 0200, NULL, &int_proc_fops,
+			 &translate);
 #endif
 	if (translate != 0)
 		translate = 1;

commit 841b86f3289dbe858daeceec36423d4ea286fac2
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 23 09:40:42 2017 +0200

    treewide: Remove TIMER_FUNC_TYPE and TIMER_DATA_TYPE casts
    
    With all callbacks converted, and the timer callback prototype
    switched over, the TIMER_FUNC_TYPE cast is no longer needed,
    so remove it. Conversion was done with the following scripts:
    
        perl -pi -e 's|\(TIMER_FUNC_TYPE\)||g' \
            $(git grep TIMER_FUNC_TYPE | cut -d: -f1 | sort -u)
    
        perl -pi -e 's|\(TIMER_DATA_TYPE\)||g' \
            $(git grep TIMER_DATA_TYPE | cut -d: -f1 | sort -u)
    
    The now unused macros are also dropped from include/linux/timer.h.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index d8afcdfca1ed..0133fcd4601b 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -569,7 +569,7 @@ static int dl_startup_params(struct net_device *dev)
 	local->card_status = CARD_DL_PARAM;
 	/* Start kernel timer to wait for dl startup to complete. */
 	local->timer.expires = jiffies + HZ / 2;
-	local->timer.function = (TIMER_FUNC_TYPE)verify_dl_startup;
+	local->timer.function = verify_dl_startup;
 	add_timer(&local->timer);
 	dev_dbg(&link->dev,
 	      "ray_cs dl_startup_params started timer for verify_dl_startup\n");
@@ -1947,12 +1947,12 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 					dev_dbg(&link->dev,
 					      "ray_cs interrupt network \"%s\" start failed\n",
 					      memtmp);
-					local->timer.function = (TIMER_FUNC_TYPE)start_net;
+					local->timer.function = start_net;
 				} else {
 					dev_dbg(&link->dev,
 					      "ray_cs interrupt network \"%s\" join failed\n",
 					      memtmp);
-					local->timer.function = (TIMER_FUNC_TYPE)join_net;
+					local->timer.function = join_net;
 				}
 				add_timer(&local->timer);
 			}
@@ -2417,9 +2417,9 @@ static void authenticate(ray_dev_t *local)
 
 	del_timer(&local->timer);
 	if (build_auth_frame(local, local->bss_id, OPEN_AUTH_REQUEST)) {
-		local->timer.function = (TIMER_FUNC_TYPE)join_net;
+		local->timer.function = join_net;
 	} else {
-		local->timer.function = (TIMER_FUNC_TYPE)authenticate_timeout;
+		local->timer.function = authenticate_timeout;
 	}
 	local->timer.expires = jiffies + HZ * 2;
 	add_timer(&local->timer);
@@ -2502,7 +2502,7 @@ static void associate(ray_dev_t *local)
 
 		del_timer(&local->timer);
 		local->timer.expires = jiffies + HZ * 2;
-		local->timer.function = (TIMER_FUNC_TYPE)join_net;
+		local->timer.function = join_net;
 		add_timer(&local->timer);
 		local->card_status = CARD_ASSOC_FAILED;
 		return;

commit d8eb7e262d0d438b23e69d836175b9cec3e4bb90
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 17:28:52 2017 -0700

    net/wireless/ray_cs: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Kalle Valo <kvalo@codeaurora.org>
    Cc: linux-wireless@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 170cd504e8ff..d8afcdfca1ed 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -92,7 +92,7 @@ static const struct iw_handler_def ray_handler_def;
 /***** Prototypes for raylink functions **************************************/
 static void authenticate(ray_dev_t *local);
 static int build_auth_frame(ray_dev_t *local, UCHAR *dest, int auth_type);
-static void authenticate_timeout(u_long);
+static void authenticate_timeout(struct timer_list *t);
 static int get_free_ccs(ray_dev_t *local);
 static int get_free_tx_ccs(ray_dev_t *local);
 static void init_startup_params(ray_dev_t *local);
@@ -102,7 +102,7 @@ static int ray_init(struct net_device *dev);
 static int interrupt_ecf(ray_dev_t *local, int ccs);
 static void ray_reset(struct net_device *dev);
 static void ray_update_parm(struct net_device *dev, UCHAR objid, UCHAR *value, int len);
-static void verify_dl_startup(u_long);
+static void verify_dl_startup(struct timer_list *t);
 
 /* Prototypes for interrpt time functions **********************************/
 static irqreturn_t ray_interrupt(int reg, void *dev_id);
@@ -120,9 +120,8 @@ static void associate(ray_dev_t *local);
 
 /* Card command functions */
 static int dl_startup_params(struct net_device *dev);
-static void join_net(u_long local);
-static void start_net(u_long local);
-/* void start_net(ray_dev_t *local); */
+static void join_net(struct timer_list *t);
+static void start_net(struct timer_list *t);
 
 /*===========================================================================*/
 /* Parameters that can be set with 'insmod' */
@@ -323,7 +322,7 @@ static int ray_probe(struct pcmcia_device *p_dev)
 	dev_dbg(&p_dev->dev, "ray_cs ray_attach calling ether_setup.)\n");
 	netif_stop_queue(dev);
 
-	init_timer(&local->timer);
+	timer_setup(&local->timer, NULL, 0);
 
 	this_device = p_dev;
 	return ray_config(p_dev);
@@ -570,8 +569,7 @@ static int dl_startup_params(struct net_device *dev)
 	local->card_status = CARD_DL_PARAM;
 	/* Start kernel timer to wait for dl startup to complete. */
 	local->timer.expires = jiffies + HZ / 2;
-	local->timer.data = (long)local;
-	local->timer.function = verify_dl_startup;
+	local->timer.function = (TIMER_FUNC_TYPE)verify_dl_startup;
 	add_timer(&local->timer);
 	dev_dbg(&link->dev,
 	      "ray_cs dl_startup_params started timer for verify_dl_startup\n");
@@ -641,9 +639,9 @@ static void init_startup_params(ray_dev_t *local)
 } /* init_startup_params */
 
 /*===========================================================================*/
-static void verify_dl_startup(u_long data)
+static void verify_dl_startup(struct timer_list *t)
 {
-	ray_dev_t *local = (ray_dev_t *) data;
+	ray_dev_t *local = from_timer(local, t, timer);
 	struct ccs __iomem *pccs = ccs_base(local) + local->dl_param_ccs;
 	UCHAR status;
 	struct pcmcia_device *link = local->finder;
@@ -676,16 +674,16 @@ static void verify_dl_startup(u_long data)
 		return;
 	}
 	if (local->sparm.b4.a_network_type == ADHOC)
-		start_net((u_long) local);
+		start_net(&local->timer);
 	else
-		join_net((u_long) local);
+		join_net(&local->timer);
 } /* end verify_dl_startup */
 
 /*===========================================================================*/
 /* Command card to start a network */
-static void start_net(u_long data)
+static void start_net(struct timer_list *t)
 {
-	ray_dev_t *local = (ray_dev_t *) data;
+	ray_dev_t *local = from_timer(local, t, timer);
 	struct ccs __iomem *pccs;
 	int ccsindex;
 	struct pcmcia_device *link = local->finder;
@@ -710,9 +708,9 @@ static void start_net(u_long data)
 
 /*===========================================================================*/
 /* Command card to join a network */
-static void join_net(u_long data)
+static void join_net(struct timer_list *t)
 {
-	ray_dev_t *local = (ray_dev_t *) data;
+	ray_dev_t *local = from_timer(local, t, timer);
 
 	struct ccs __iomem *pccs;
 	int ccsindex;
@@ -1639,13 +1637,13 @@ static int get_free_ccs(ray_dev_t *local)
 } /* get_free_ccs */
 
 /*===========================================================================*/
-static void authenticate_timeout(u_long data)
+static void authenticate_timeout(struct timer_list *t)
 {
-	ray_dev_t *local = (ray_dev_t *) data;
+	ray_dev_t *local = from_timer(local, t, timer);
 	del_timer(&local->timer);
 	printk(KERN_INFO "ray_cs Authentication with access point failed"
 	       " - timeout\n");
-	join_net((u_long) local);
+	join_net(&local->timer);
 }
 
 /*===========================================================================*/
@@ -1945,17 +1943,16 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 
 				del_timer(&local->timer);
 				local->timer.expires = jiffies + HZ * 5;
-				local->timer.data = (long)local;
 				if (status == CCS_START_NETWORK) {
 					dev_dbg(&link->dev,
 					      "ray_cs interrupt network \"%s\" start failed\n",
 					      memtmp);
-					local->timer.function = start_net;
+					local->timer.function = (TIMER_FUNC_TYPE)start_net;
 				} else {
 					dev_dbg(&link->dev,
 					      "ray_cs interrupt network \"%s\" join failed\n",
 					      memtmp);
-					local->timer.function = join_net;
+					local->timer.function = (TIMER_FUNC_TYPE)join_net;
 				}
 				add_timer(&local->timer);
 			}
@@ -1967,7 +1964,7 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 			} else {
 				dev_dbg(&link->dev, "ray_cs association failed,\n");
 				local->card_status = CARD_ASSOC_FAILED;
-				join_net((u_long) local);
+				join_net(&local->timer);
 			}
 			break;
 		case CCS_TX_REQUEST:
@@ -2420,12 +2417,11 @@ static void authenticate(ray_dev_t *local)
 
 	del_timer(&local->timer);
 	if (build_auth_frame(local, local->bss_id, OPEN_AUTH_REQUEST)) {
-		local->timer.function = join_net;
+		local->timer.function = (TIMER_FUNC_TYPE)join_net;
 	} else {
-		local->timer.function = authenticate_timeout;
+		local->timer.function = (TIMER_FUNC_TYPE)authenticate_timeout;
 	}
 	local->timer.expires = jiffies + HZ * 2;
-	local->timer.data = (long)local;
 	add_timer(&local->timer);
 	local->authentication_state = AWAITING_RESPONSE;
 } /* end authenticate */
@@ -2468,7 +2464,7 @@ static void rx_authenticate(ray_dev_t *local, struct rcs __iomem *prcs,
 				} else {
 					pr_debug("Authentication refused\n");
 					local->card_status = CARD_AUTH_REFUSED;
-					join_net((u_long) local);
+					join_net(&local->timer);
 					local->authentication_state =
 					    UNAUTHENTICATED;
 				}
@@ -2506,8 +2502,7 @@ static void associate(ray_dev_t *local)
 
 		del_timer(&local->timer);
 		local->timer.expires = jiffies + HZ * 2;
-		local->timer.data = (long)local;
-		local->timer.function = join_net;
+		local->timer.function = (TIMER_FUNC_TYPE)join_net;
 		add_timer(&local->timer);
 		local->card_status = CARD_ASSOC_FAILED;
 		return;

commit e48d661eb13f2f83861428f001c567fdb3f317e8
Author: Kees Cook <keescook@chromium.org>
Date:   Fri May 5 15:38:41 2017 -0700

    ray_cs: Avoid reading past end of buffer
    
    Using memcpy() from a buffer that is shorter than the length copied means
    the destination buffer is being filled with arbitrary data from the kernel
    rodata segment. In this case, the source was made longer, since it did not
    match the destination structure size. Additionally removes a needless cast.
    
    This was found with the future CONFIG_FORTIFY_SOURCE feature.
    
    Cc: Daniel Micay <danielmicay@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index b94479441b0c..170cd504e8ff 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -247,7 +247,10 @@ static const UCHAR b4_default_startup_parms[] = {
 	0x04, 0x08,		/* Noise gain, limit offset */
 	0x28, 0x28,		/* det rssi, med busy offsets */
 	7,			/* det sync thresh */
-	0, 2, 2			/* test mode, min, max */
+	0, 2, 2,		/* test mode, min, max */
+	0,			/* rx/tx delay */
+	0, 0, 0, 0, 0, 0,	/* current BSS id */
+	0			/* hop set */
 };
 
 /*===========================================================================*/
@@ -597,7 +600,7 @@ static void init_startup_params(ray_dev_t *local)
 	 *    a_beacon_period = hops    a_beacon_period = KuS
 	 *//* 64ms = 010000 */
 	if (local->fw_ver == 0x55) {
-		memcpy((UCHAR *) &local->sparm.b4, b4_default_startup_parms,
+		memcpy(&local->sparm.b4, b4_default_startup_parms,
 		       sizeof(struct b4_startup_params));
 		/* Translate sane kus input values to old build 4/5 format */
 		/* i = hop time in uS truncated to 3 bytes */

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 4fdc7223c894..b94479441b0c 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -53,7 +53,7 @@
 
 #include <asm/io.h>
 #include <asm/byteorder.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 /* Warning : these stuff will slow down the driver... */
 #define WIRELESS_SPY		/* Enable spying addresses */

commit a52ad514fdf3b8a57ca4322c92d2d8d5c6182485
Author: Jarod Wilson <jarod@redhat.com>
Date:   Fri Oct 7 22:04:34 2016 -0400

    net: deprecate eth_change_mtu, remove usage
    
    With centralized MTU checking, there's nothing productive done by
    eth_change_mtu that isn't already done in dev_set_mtu, so mark it as
    deprecated and remove all usage of it in the kernel. All callers have been
    audited for calls to alloc_etherdev* or ether_setup directly, which means
    they all have a valid dev->min_mtu and dev->max_mtu. Now eth_change_mtu
    prints out a netdev_warn about being deprecated, for the benefit of
    out-of-tree drivers that might be utilizing it.
    
    Of note, dvb_net.c actually had dev->mtu = 4096, while using
    eth_change_mtu, meaning that if you ever tried changing it's mtu, you
    couldn't set it above 1500 anymore. It's now getting dev->max_mtu also set
    to 4096 to remedy that.
    
    v2: fix up lantiq_etop, missed breakage due to drive not compiling on x86
    
    CC: netdev@vger.kernel.org
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 0881ba8535f4..4fdc7223c894 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -272,7 +272,6 @@ static const struct net_device_ops ray_netdev_ops = {
 	.ndo_set_config		= ray_dev_config,
 	.ndo_get_stats		= ray_get_stats,
 	.ndo_set_rx_mode	= set_multicast_list,
-	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_set_mac_address 	= eth_mac_addr,
 	.ndo_validate_addr	= eth_validate_addr,
 };

commit fa2ab6971844141add8d98a73a0a9679f9067bb5
Author: Shailendra Verma <shailendra.capricorn@gmail.com>
Date:   Wed May 27 06:25:57 2015 +0530

    ray_cs: Change 1 to true for bool type variable.
    
    The variable translate is bool type. So assigning true instead of 1.
    
    Signed-off-by: Shailendra Verma <shailendra.capricorn@gmail.com>
    Signed-off-by: Kalle Valo <kvalo@codeaurora.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 477f86354dc5..0881ba8535f4 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -143,7 +143,7 @@ static int psm;
 static char *essid;
 
 /* Default to encapsulation unless translation requested */
-static bool translate = 1;
+static bool translate = true;
 
 static int country = USA;
 

commit 93803b3385c653bc6fd391c0de00ef811b3dadc0
Author: Joe Perches <joe@perches.com>
Date:   Mon Mar 2 19:54:49 2015 -0800

    wireless: Use eth_<foo>_addr instead of memset
    
    Use the built-in function instead of memset.
    
    Miscellanea:
    
    Add #include <linux/etherdevice.h> where appropriate
    Use ETH_ALEN instead of 6
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 8330fa33e50b..477f86354dc5 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -808,7 +808,7 @@ static int ray_dev_init(struct net_device *dev)
 
 	/* copy mac and broadcast addresses to linux device */
 	memcpy(dev->dev_addr, &local->sparm.b4.a_mac_addr, ADDRLEN);
-	memset(dev->broadcast, 0xff, ETH_ALEN);
+	eth_broadcast_addr(dev->broadcast);
 
 	dev_dbg(&link->dev, "ray_dev_init ending\n");
 	return 0;

commit 360298c11eb7f698857046bd9c52ca072f48cf1c
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Tue Apr 1 15:49:18 2014 +0200

    ray_cs: replace del_timer by del_timer_sync
    
    Use del_timer_sync to ensure that the timer is stopped on all CPUs before
    the driver exits.
    
    This change was suggested by Thomas Gleixner.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r@
    identifier i,t,ex;
    @@
    struct t i = { .remove = ex, };
    
    @@
    identifier r.ex;
    @@
    ex(...) {
      <...
    - del_timer
    + del_timer_sync
        (...)
      ...>
    }
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index cbf0a589d32a..8330fa33e50b 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -343,7 +343,7 @@ static void ray_detach(struct pcmcia_device *link)
 	ray_release(link);
 
 	local = netdev_priv(dev);
-	del_timer(&local->timer);
+	del_timer_sync(&local->timer);
 
 	if (link->priv) {
 		unregister_netdev(dev);

commit 36769159a99063ba4d3cb0a20ed0b3095a334c8c
Author: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Date:   Fri Dec 6 03:32:13 2013 -0800

    drivers/net/wireless: Fix FSF address in file headers
    
    Several files refer to an old address for the Free Software Foundation
    in the file header comment.  Resolve by replacing the address with
    the URL <http://www.gnu.org/licenses/> so that we do not have to keep
    updating the header comments anytime the address changes.
    
    CC: linux-wireless@vger.kernel.org
    CC: Simon Kelley <simon@thekelleys.org.uk>
    CC: Christian Lamparter <chunkeey@googlemail.com>
    CC: Jussi Kivilinna <jussi.kivilinna@iki.fi>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 9b557a1bb7f8..cbf0a589d32a 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -17,8 +17,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
  *
  * Changes:
  * Arnaldo Carvalho de Melo <acme@conectiva.com.br> - 08/08/2000

commit 20b4fb485227404329e41ad15588afad3df23050
Merge: b9394d8a657c ac3e3c5b1164
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 1 17:51:54 2013 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull VFS updates from Al Viro,
    
    Misc cleanups all over the place, mainly wrt /proc interfaces (switch
    create_proc_entry to proc_create(), get rid of the deprecated
    create_proc_read_entry() in favor of using proc_create_data() and
    seq_file etc).
    
    7kloc removed.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (204 commits)
      don't bother with deferred freeing of fdtables
      proc: Move non-public stuff from linux/proc_fs.h to fs/proc/internal.h
      proc: Make the PROC_I() and PDE() macros internal to procfs
      proc: Supply a function to remove a proc entry by PDE
      take cgroup_open() and cpuset_open() to fs/proc/base.c
      ppc: Clean up scanlog
      ppc: Clean up rtas_flash driver somewhat
      hostap: proc: Use remove_proc_subtree()
      drm: proc: Use remove_proc_subtree()
      drm: proc: Use minor->index to label things, not PDE->name
      drm: Constify drm_proc_list[]
      zoran: Don't print proc_dir_entry data in debug
      reiserfs: Don't access the proc_dir_entry in r_open(), r_start() r_show()
      proc: Supply an accessor for getting the data from a PDE's parent
      airo: Use remove_proc_subtree()
      rtl8192u: Don't need to save device proc dir PDE
      rtl8187se: Use a dir under /proc/net/r8180/
      proc: Add proc_mkdir_data()
      proc: Move some bits from linux/proc_fs.h to linux/{of.h,signal.h,tty.h}
      proc: Move PDE_NET() to fs/proc/proc_net.c
      ...

commit d9dda78bad879595d8c4220a067fc029d6484a16
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 31 18:16:14 2013 -0400

    procfs: new helper - PDE_DATA(inode)
    
    The only part of proc_dir_entry the code outside of fs/proc
    really cares about is PDE(inode)->data.  Provide a helper
    for that; static inline for now, eventually will be moved
    to fs/proc, along with the knowledge of struct proc_dir_entry
    layout.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 3109c0db66e1..a6f660c01902 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2778,7 +2778,7 @@ static ssize_t int_proc_write(struct file *file, const char __user *buffer,
 		nr = nr * 10 + c;
 		p++;
 	} while (--len);
-	*(int *)PDE(file_inode(file))->data = nr;
+	*(int *)PDE_DATA(file_inode(file)) = nr;
 	return count;
 }
 

commit e5c5d22e8dcf7c2d430336cbf8e180bd38e8daf1
Author: Simon Horman <horms@verge.net.au>
Date:   Thu Mar 28 13:38:25 2013 +0900

    net: add ETH_P_802_3_MIN
    
    Add a new constant ETH_P_802_3_MIN, the minimum ethernet type for
    an 802.3 frame. Frames with a lower value in the ethernet type field
    are Ethernet II.
    
    Also update all the users of this value that David Miller and
    I could find to use the new constant.
    
    Also correct a bug in util.c. The comparison with ETH_P_802_3_MIN
    should be >= not >.
    
    As suggested by Jesse Gross.
    
    Compile tested only.
    
    Cc: David Miller <davem@davemloft.net>
    Cc: Jesse Gross <jesse@nicira.com>
    Cc: Karsten Keil <isdn@linux-pingi.de>
    Cc: John W. Linville <linville@tuxdriver.com>
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: Bart De Schuymer <bart.de.schuymer@pandora.be>
    Cc: Stephen Hemminger <stephen@networkplumber.org>
    Cc: Patrick McHardy <kaber@trash.net>
    Cc: Marcel Holtmann <marcel@holtmann.org>
    Cc: Gustavo Padovan <gustavo@padovan.org>
    Cc: Johan Hedberg <johan.hedberg@gmail.com>
    Cc: linux-bluetooth@vger.kernel.org
    Cc: netfilter-devel@vger.kernel.org
    Cc: bridge@lists.linux-foundation.org
    Cc: linux-wireless@vger.kernel.org
    Cc: linux1394-devel@lists.sourceforge.net
    Cc: linux-media@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Cc: dev@openvswitch.org
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Acked-by: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Signed-off-by: Simon Horman <horms@verge.net.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 4775b5d172d5..ebada812b3a5 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -953,7 +953,7 @@ static int translate_frame(ray_dev_t *local, struct tx_msg __iomem *ptx,
 			   unsigned char *data, int len)
 {
 	__be16 proto = ((struct ethhdr *)data)->h_proto;
-	if (ntohs(proto) >= 1536) { /* DIX II ethernet frame */
+	if (ntohs(proto) >= ETH_P_802_3_MIN) { /* DIX II ethernet frame */
 		pr_debug("ray_cs translate_frame DIX II\n");
 		/* Copy LLC header to card buffer */
 		memcpy_toio(&ptx->var, eth2_llc, sizeof(eth2_llc));

commit 2dcc26e37c55b9db2f3a0ea6e4b931e37ca286d2
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Feb 26 13:04:51 2013 +0300

    ray_cs: read past the end of the array
    
    "translate" should either be set or disabled.  We also use it an
    offset into the framing[] array when we're generating the proc
    file.  Framing looks like this:
    
    static const char *framing[] = { "Encapsulation", "Translation" }
    
    So when we're setting translate we need to restrict the values to
    either 1 or 0 or it can an out of bounds read.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 3109c0db66e1..4775b5d172d5 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -144,7 +144,7 @@ static int psm;
 static char *essid;
 
 /* Default to encapsulation unless translation requested */
-static int translate = 1;
+static bool translate = 1;
 
 static int country = USA;
 
@@ -178,7 +178,7 @@ module_param(hop_dwell, int, 0);
 module_param(beacon_period, int, 0);
 module_param(psm, int, 0);
 module_param(essid, charp, 0);
-module_param(translate, int, 0);
+module_param(translate, bool, 0);
 module_param(country, int, 0);
 module_param(sniffer, int, 0);
 module_param(bc, int, 0);
@@ -1353,7 +1353,7 @@ static int ray_get_range(struct net_device *dev, struct iw_request_info *info,
 static int ray_set_framing(struct net_device *dev, struct iw_request_info *info,
 			   union iwreq_data *wrqu, char *extra)
 {
-	translate = *(extra);	/* Set framing mode */
+	translate = !!*(extra);	/* Set framing mode */
 
 	return 0;
 }

commit d895cb1af15c04c522a25c79cc429076987c089b
Merge: 9626357371b5 d3d009cb965e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 26 20:16:07 2013 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs pile (part one) from Al Viro:
     "Assorted stuff - cleaning namei.c up a bit, fixing ->d_name/->d_parent
      locking violations, etc.
    
      The most visible changes here are death of FS_REVAL_DOT (replaced with
      "has ->d_weak_revalidate()") and a new helper getting from struct file
      to inode.  Some bits of preparation to xattr method interface changes.
    
      Misc patches by various people sent this cycle *and* ocfs2 fixes from
      several cycles ago that should've been upstream right then.
    
      PS: the next vfs pile will be xattr stuff."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (46 commits)
      saner proc_get_inode() calling conventions
      proc: avoid extra pde_put() in proc_fill_super()
      fs: change return values from -EACCES to -EPERM
      fs/exec.c: make bprm_mm_init() static
      ocfs2/dlm: use GFP_ATOMIC inside a spin_lock
      ocfs2: fix possible use-after-free with AIO
      ocfs2: Fix oops in ocfs2_fast_symlink_readpage() code path
      get_empty_filp()/alloc_file() leave both ->f_pos and ->f_version zero
      target: writev() on single-element vector is pointless
      export kernel_write(), convert open-coded instances
      fs: encode_fh: return FILEID_INVALID if invalid fid_type
      kill f_vfsmnt
      vfs: kill FS_REVAL_DOT by adding a d_weak_revalidate dentry op
      nfsd: handle vfs_getattr errors in acl protocol
      switch vfs_getattr() to struct path
      default SET_PERSONALITY() in linux/elf.h
      ceph: prepopulate inodes only when request is aborted
      d_hash_and_lookup(): export, switch open-coded instances
      9p: switch v9fs_set_create_acl() to inode+fid, do it before d_instantiate()
      9p: split dropping the acls from v9fs_set_create_acl()
      ...

commit 496ad9aa8ef448058e36ca7a787c61f2e63f0f54
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jan 23 17:07:38 2013 -0500

    new helper: file_inode(file)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 598ca1cafb95..5311ba1dcd2c 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2769,7 +2769,7 @@ static ssize_t int_proc_write(struct file *file, const char __user *buffer,
 		nr = nr * 10 + c;
 		p++;
 	} while (--len);
-	*(int *)PDE(file->f_path.dentry->d_inode)->data = nr;
+	*(int *)PDE(file_inode(file))->data = nr;
 	return count;
 }
 

commit 708d019fd1d2d1bf184e797ebe934c90a6527d50
Author: Chen Gang <gang.chen@asianux.com>
Date:   Tue Jan 8 13:33:03 2013 +0800

    drivers/net/wireless: need consider the not '\0' terminated string.
    
      in ray_cs.c:
        the a_current_ess_id is "Null terminated unless ESSID_SIZE long"
        so we need buffer it with '\0' firstly, before using strlen or %s.
    
      additional information:
        in drivers/net/wireless/rayctl.h:
          "NULL terminated unless 32 long" is a comment at line 616, 664
          ESSID_SIZE is 32, at line 190
        in include/uapi/linux/wireless.h:
          IW_ESSID_MAX_SIZE is also 32
        in drivers/net/wireless/ray_cs.c:
          use strncpy for it, without '\0' terminated, at line 639
          use memcpy for it, assume not '\0' terminated in line 1092..1097
          buffer it with '\0' firstly, before using %s, in line 2576, 2598..2600
    
    Signed-off-by: Chen Gang <gang.chen@asianux.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 598ca1cafb95..e7cf37f550d1 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -1107,12 +1107,15 @@ static int ray_get_essid(struct net_device *dev, struct iw_request_info *info,
 			 union iwreq_data *wrqu, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
+	UCHAR tmp[IW_ESSID_MAX_SIZE + 1];
 
 	/* Get the essid that was set */
 	memcpy(extra, local->sparm.b5.a_current_ess_id, IW_ESSID_MAX_SIZE);
+	memcpy(tmp, local->sparm.b5.a_current_ess_id, IW_ESSID_MAX_SIZE);
+	tmp[IW_ESSID_MAX_SIZE] = '\0';
 
 	/* Push it out ! */
-	wrqu->essid.length = strlen(extra);
+	wrqu->essid.length = strlen(tmp);
 	wrqu->essid.flags = 1;	/* active */
 
 	return 0;
@@ -1842,6 +1845,8 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 	UCHAR tmp;
 	UCHAR cmd;
 	UCHAR status;
+	UCHAR memtmp[ESSID_SIZE + 1];
+
 
 	if (dev == NULL)	/* Note that we want interrupts with dev->start == 0 */
 		return IRQ_NONE;
@@ -1901,17 +1906,21 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 			break;
 		case CCS_START_NETWORK:
 		case CCS_JOIN_NETWORK:
+			memcpy(memtmp, local->sparm.b4.a_current_ess_id,
+								ESSID_SIZE);
+			memtmp[ESSID_SIZE] = '\0';
+
 			if (status == CCS_COMMAND_COMPLETE) {
 				if (readb
 				    (&pccs->var.start_network.net_initiated) ==
 				    1) {
 					dev_dbg(&link->dev,
 					      "ray_cs interrupt network \"%s\" started\n",
-					      local->sparm.b4.a_current_ess_id);
+					      memtmp);
 				} else {
 					dev_dbg(&link->dev,
 					      "ray_cs interrupt network \"%s\" joined\n",
-					      local->sparm.b4.a_current_ess_id);
+					      memtmp);
 				}
 				memcpy_fromio(&local->bss_id,
 					      pccs->var.start_network.bssid,
@@ -1939,12 +1948,12 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 				if (status == CCS_START_NETWORK) {
 					dev_dbg(&link->dev,
 					      "ray_cs interrupt network \"%s\" start failed\n",
-					      local->sparm.b4.a_current_ess_id);
+					      memtmp);
 					local->timer.function = start_net;
 				} else {
 					dev_dbg(&link->dev,
 					      "ray_cs interrupt network \"%s\" join failed\n",
-					      local->sparm.b4.a_current_ess_id);
+					      memtmp);
 					local->timer.function = join_net;
 				}
 				add_timer(&local->timer);

commit 2c208890c6d4e16076c6664137703ec813e8fa6c
Author: Joe Perches <joe@perches.com>
Date:   Mon Jun 4 12:44:17 2012 +0000

    wireless: Remove casts to same type
    
    Adding casts of objects to the same type is unnecessary
    and confusing for a human reader.
    
    For example, this cast:
    
            int y;
            int *p = (int *)&y;
    
    I used the coccinelle script below to find and remove these
    unnecessary casts.  I manually removed the conversions this
    script produces of casts with __force, __iomem and __user.
    
    @@
    type T;
    T *p;
    @@
    
    -       (T *)p
    +       p
    
    Neatened the mwifiex_deauthenticate_infra function which
    was doing odd things with array pointers and not using
    is_zero_ether_addr.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 86a738bf591c..598ca1cafb95 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -1849,7 +1849,7 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 	pr_debug("ray_cs: interrupt for *dev=%p\n", dev);
 
 	local = netdev_priv(dev);
-	link = (struct pcmcia_device *)local->finder;
+	link = local->finder;
 	if (!pcmcia_dev_present(link)) {
 		pr_debug(
 			"ray_cs interrupt from device not present or suspended.\n");

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 04fec1fa6e0b..86a738bf591c 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -53,7 +53,6 @@
 #include <net/iw_handler.h>
 
 #include <asm/io.h>
-#include <asm/system.h>
 #include <asm/byteorder.h>
 #include <asm/uaccess.h>
 

commit b4c0e72e80e2e04b462ea05cc5a001807d7feed6
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Nov 26 15:41:29 2011 -0500

    ray_cs: Fix array bounds warnings.
    
    rx_msg is defined to have a 1 entry array at the end, so gcc warns:
    
    drivers/net/wireless/ray_cs.c: In function rx_authenticate:
    drivers/net/wireless/ray_cs.c:2436:3: warning: array subscript is above array bounds [-Warray-bounds]
    drivers/net/wireless/ray_cs.c:2436:3: warning: array subscript is above array bounds [-Warray-bounds]
    drivers/net/wireless/ray_cs.c:2436:3: warning: array subscript is above array bounds [-Warray-bounds]
    drivers/net/wireless/ray_cs.c:2436:3: warning: array subscript is above array bounds [-Warray-bounds]
    drivers/net/wireless/ray_cs.c:2436:3: warning: array subscript is above array bounds [-Warray-bounds]
    drivers/net/wireless/ray_cs.c:2439:15: warning: array subscript is above array bounds [-Warray-bounds]
    drivers/net/wireless/ray_cs.c:2452:16: warning: array subscript is above array bounds [-Warray-bounds]
    drivers/net/wireless/ray_cs.c:2453:18: warning: array subscript is above array bounds [-Warray-bounds]
    drivers/net/wireless/ray_cs.c:2453:32: warning: array subscript is above array bounds [-Warray-bounds]
    
    Use a zero length array and rename to "ray_rx_msg" to make sure we hit all
    of the necessary cases.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 0021e4948512..04fec1fa6e0b 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2426,7 +2426,7 @@ static void rx_authenticate(ray_dev_t *local, struct rcs __iomem *prcs,
 			    unsigned int pkt_addr, int rx_len)
 {
 	UCHAR buff[256];
-	struct rx_msg *msg = (struct rx_msg *)buff;
+	struct ray_rx_msg *msg = (struct ray_rx_msg *) buff;
 
 	del_timer(&local->timer);
 
@@ -2513,7 +2513,7 @@ static void rx_deauthenticate(ray_dev_t *local, struct rcs __iomem *prcs,
 			      unsigned int pkt_addr, int rx_len)
 {
 /*  UCHAR buff[256];
-    struct rx_msg *msg = (struct rx_msg *)buff;
+    struct ray_rx_msg *msg = (struct ray_rx_msg *) buff;
 */
 	pr_debug("Deauthentication frame received\n");
 	local->authentication_state = UNAUTHENTICATED;

commit afc4b13df143122f99a0eb10bfefb216c2806de0
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Tue Aug 16 06:29:01 2011 +0000

    net: remove use of ndo_set_multicast_list in drivers
    
    replace it by ndo_set_rx_mode
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 2a06ebcd67c5..0021e4948512 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -273,7 +273,7 @@ static const struct net_device_ops ray_netdev_ops = {
 	.ndo_start_xmit		= ray_dev_start_xmit,
 	.ndo_set_config		= ray_dev_config,
 	.ndo_get_stats		= ray_get_stats,
-	.ndo_set_multicast_list = set_multicast_list,
+	.ndo_set_rx_mode	= set_multicast_list,
 	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_set_mac_address 	= eth_mac_addr,
 	.ndo_validate_addr	= eth_validate_addr,

commit 25f8f54f6e178acfd503a95441b0ea05c525f751
Author: Joe Perches <joe@perches.com>
Date:   Tue May 3 19:29:01 2011 -0700

    pcmcia: Convert pcmcia_device_id declarations to const
    
    Saves about 50KB of data.
    
    Old/new size of all objects:
       text    data     bss     dec     hex filename
     563015   80096  130684  773795   bcea3 (TOTALS)
     610916   32256  130632  773804   bceac (TOTALS)
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Kurt Van Dijck <kurt.van.dijck@eia.be> (for drivers/net/can/softing/softing_cs.c)
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 0764d1a30d13..2a06ebcd67c5 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2781,7 +2781,7 @@ static const struct file_operations int_proc_fops = {
 };
 #endif
 
-static struct pcmcia_device_id ray_ids[] = {
+static const struct pcmcia_device_id ray_ids[] = {
 	PCMCIA_DEVICE_MANF_CARD(0x01a6, 0x0000),
 	PCMCIA_DEVICE_NULL,
 };

commit 78b8595691c34478a51d1c2bcbbb0f6ec8a28247
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Thu Dec 2 14:45:07 2010 +0200

    wireless: ray_cs: use '%pm' format option to print MAC
    
    Signed-off-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: "John W. Linville" <linville@tuxdriver.com>
    Cc: linux-wireless@vger.kernel.org
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 2b1cbba90a84..0764d1a30d13 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -1776,11 +1776,8 @@ static void ray_update_multi_list(struct net_device *dev, int all)
 		/* Copy the kernel's list of MC addresses to card */
 		netdev_for_each_mc_addr(ha, dev) {
 			memcpy_toio(p, ha->addr, ETH_ALEN);
-			dev_dbg(&link->dev,
-			      "ray_update_multi add addr %02x%02x%02x%02x%02x%02x\n",
-			      ha->addr[0], ha->addr[1],
-			      ha->addr[2], ha->addr[3],
-			      ha->addr[4], ha->addr[5]);
+			dev_dbg(&link->dev, "ray_update_multi add addr %pm\n",
+				ha->addr);
 			p += ETH_ALEN;
 			i++;
 		}
@@ -2015,11 +2012,8 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 				memcpy_fromio(&local->bss_id,
 					      prcs->var.rejoin_net_complete.
 					      bssid, ADDRLEN);
-				dev_dbg(&link->dev,
-				      "ray_cs new BSSID = %02x%02x%02x%02x%02x%02x\n",
-				      local->bss_id[0], local->bss_id[1],
-				      local->bss_id[2], local->bss_id[3],
-				      local->bss_id[4], local->bss_id[5]);
+				dev_dbg(&link->dev, "ray_cs new BSSID = %pm\n",
+					local->bss_id);
 				if (!sniffer)
 					authenticate(local);
 			}

commit ff273b91ff04e6f232234b70c45101074a0daa27
Author: Joe Perches <joe@perches.com>
Date:   Sat Nov 20 18:38:59 2010 -0800

    ray_cs: Use static const
    
    Using static const generally increases object text and decreases data size.
    It also generally decreases overall object size.
    
       text    data     bss     dec     hex filename
      42607    3581    8536   54724    d5c4 drivers/net/wireless/ray_cs.o.new
      42603    3585    8536   54724    d5c4 drivers/net/wireless/ray_cs.o.old
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 97007d9e2c1f..2b1cbba90a84 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2286,8 +2286,8 @@ static void untranslate(ray_dev_t *local, struct sk_buff *skb, int len)
 	struct ethhdr *peth;
 	UCHAR srcaddr[ADDRLEN];
 	UCHAR destaddr[ADDRLEN];
-	static UCHAR org_bridge[3] = { 0, 0, 0xf8 };
-	static UCHAR org_1042[3] = { 0, 0, 0 };
+	static const UCHAR org_bridge[3] = { 0, 0, 0xf8 };
+	static const UCHAR org_1042[3] = { 0, 0, 0 };
 
 	memcpy(destaddr, ieee80211_get_DA(pmac), ADDRLEN);
 	memcpy(srcaddr, ieee80211_get_SA(pmac), ADDRLEN);

commit 5f05647dd81c11a6a165ccc8f0c1370b16f3bcb0
Merge: 02f36038c568 ec37a48d1d16
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 23 11:47:02 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6: (1699 commits)
      bnx2/bnx2x: Unsupported Ethtool operations should return -EINVAL.
      vlan: Calling vlan_hwaccel_do_receive() is always valid.
      tproxy: use the interface primary IP address as a default value for --on-ip
      tproxy: added IPv6 support to the socket match
      cxgb3: function namespace cleanup
      tproxy: added IPv6 support to the TPROXY target
      tproxy: added IPv6 socket lookup function to nf_tproxy_core
      be2net: Changes to use only priority codes allowed by f/w
      tproxy: allow non-local binds of IPv6 sockets if IP_TRANSPARENT is enabled
      tproxy: added tproxy sockopt interface in the IPV6 layer
      tproxy: added udp6_lib_lookup function
      tproxy: added const specifiers to udp lookup functions
      tproxy: split off ipv6 defragmentation to a separate module
      l2tp: small cleanup
      nf_nat: restrict ICMP translation for embedded header
      can: mcp251x: fix generation of error frames
      can: mcp251x: fix endless loop in interrupt handler if CANINTF_MERRF is set
      can-raw: add msg_flags to distinguish local traffic
      9p: client code cleanup
      rds: make local functions/variables static
      ...
    
    Fix up conflicts in net/core/dev.c, drivers/net/pcmcia/smc91c92_cs.c and
    drivers/net/wireless/ath/ath9k/debug.c as per David

commit 092e0e7e520a1fca03e13c9f2d157432a8657ff2
Merge: 79f14b7c56d3 776c163b1b93
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 22 10:52:56 2010 -0700

    Merge branch 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl
    
    * 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl:
      vfs: make no_llseek the default
      vfs: don't use BKL in default_llseek
      llseek: automatically add .llseek fop
      libfs: use generic_file_llseek for simple_attr
      mac80211: disallow seeks in minstrel debug code
      lirc: make chardev nonseekable
      viotape: use noop_llseek
      raw: use explicit llseek file operations
      ibmasmfs: use generic_file_llseek
      spufs: use llseek in all file operations
      arm/omap: use generic_file_llseek in iommu_debug
      lkdtm: use generic_file_llseek in debugfs
      net/wireless: use generic_file_llseek in debugfs
      drm: use noop_llseek

commit 6038f373a3dc1f1c26496e60b6c40b164716f07e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Aug 15 18:52:59 2010 +0200

    llseek: automatically add .llseek fop
    
    All file_operations should get a .llseek operation so we can make
    nonseekable_open the default for future file operations without a
    .llseek pointer.
    
    The three cases that we can automatically detect are no_llseek, seq_lseek
    and default_llseek. For cases where we can we can automatically prove that
    the file offset is always ignored, we use noop_llseek, which maintains
    the current behavior of not returning an error from a seek.
    
    New drivers should normally not use noop_llseek but instead use no_llseek
    and call nonseekable_open at open time.  Existing drivers can be converted
    to do the same when the maintainer knows for certain that no user code
    relies on calling seek on the device file.
    
    The generated code is often incorrectly indented and right now contains
    comments that clarify for each added line why a specific variant was
    chosen. In the version that gets submitted upstream, the comments will
    be gone and I will manually fix the indentation, because there does not
    seem to be a way to do that using coccinelle.
    
    Some amount of new code is currently sitting in linux-next that should get
    the same modifications, which I will do at the end of the merge window.
    
    Many thanks to Julia Lawall for helping me learn to write a semantic
    patch that does all this.
    
    ===== begin semantic patch =====
    // This adds an llseek= method to all file operations,
    // as a preparation for making no_llseek the default.
    //
    // The rules are
    // - use no_llseek explicitly if we do nonseekable_open
    // - use seq_lseek for sequential files
    // - use default_llseek if we know we access f_pos
    // - use noop_llseek if we know we don't access f_pos,
    //   but we still want to allow users to call lseek
    //
    @ open1 exists @
    identifier nested_open;
    @@
    nested_open(...)
    {
    <+...
    nonseekable_open(...)
    ...+>
    }
    
    @ open exists@
    identifier open_f;
    identifier i, f;
    identifier open1.nested_open;
    @@
    int open_f(struct inode *i, struct file *f)
    {
    <+...
    (
    nonseekable_open(...)
    |
    nested_open(...)
    )
    ...+>
    }
    
    @ read disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    <+...
    (
       *off = E
    |
       *off += E
    |
       func(..., off, ...)
    |
       E = *off
    )
    ...+>
    }
    
    @ read_no_fpos disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ write @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    <+...
    (
      *off = E
    |
      *off += E
    |
      func(..., off, ...)
    |
      E = *off
    )
    ...+>
    }
    
    @ write_no_fpos @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ fops0 @
    identifier fops;
    @@
    struct file_operations fops = {
     ...
    };
    
    @ has_llseek depends on fops0 @
    identifier fops0.fops;
    identifier llseek_f;
    @@
    struct file_operations fops = {
    ...
     .llseek = llseek_f,
    ...
    };
    
    @ has_read depends on fops0 @
    identifier fops0.fops;
    identifier read_f;
    @@
    struct file_operations fops = {
    ...
     .read = read_f,
    ...
    };
    
    @ has_write depends on fops0 @
    identifier fops0.fops;
    identifier write_f;
    @@
    struct file_operations fops = {
    ...
     .write = write_f,
    ...
    };
    
    @ has_open depends on fops0 @
    identifier fops0.fops;
    identifier open_f;
    @@
    struct file_operations fops = {
    ...
     .open = open_f,
    ...
    };
    
    // use no_llseek if we call nonseekable_open
    ////////////////////////////////////////////
    @ nonseekable1 depends on !has_llseek && has_open @
    identifier fops0.fops;
    identifier nso ~= "nonseekable_open";
    @@
    struct file_operations fops = {
    ...  .open = nso, ...
    +.llseek = no_llseek, /* nonseekable */
    };
    
    @ nonseekable2 depends on !has_llseek @
    identifier fops0.fops;
    identifier open.open_f;
    @@
    struct file_operations fops = {
    ...  .open = open_f, ...
    +.llseek = no_llseek, /* open uses nonseekable */
    };
    
    // use seq_lseek for sequential files
    /////////////////////////////////////
    @ seq depends on !has_llseek @
    identifier fops0.fops;
    identifier sr ~= "seq_read";
    @@
    struct file_operations fops = {
    ...  .read = sr, ...
    +.llseek = seq_lseek, /* we have seq_read */
    };
    
    // use default_llseek if there is a readdir
    ///////////////////////////////////////////
    @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier readdir_e;
    @@
    // any other fop is used that changes pos
    struct file_operations fops = {
    ... .readdir = readdir_e, ...
    +.llseek = default_llseek, /* readdir is present */
    };
    
    // use default_llseek if at least one of read/write touches f_pos
    /////////////////////////////////////////////////////////////////
    @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read.read_f;
    @@
    // read fops use offset
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = default_llseek, /* read accesses f_pos */
    };
    
    @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ... .write = write_f, ...
    +       .llseek = default_llseek, /* write accesses f_pos */
    };
    
    // Use noop_llseek if neither read nor write accesses f_pos
    ///////////////////////////////////////////////////////////
    
    @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    identifier write_no_fpos.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ...
     .write = write_f,
     .read = read_f,
    ...
    +.llseek = noop_llseek, /* read and write both use no f_pos */
    };
    
    @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write_no_fpos.write_f;
    @@
    struct file_operations fops = {
    ... .write = write_f, ...
    +.llseek = noop_llseek, /* write uses no f_pos */
    };
    
    @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    @@
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = noop_llseek, /* read uses no f_pos */
    };
    
    @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    @@
    struct file_operations fops = {
    ...
    +.llseek = noop_llseek, /* no read or write fn */
    };
    ===== End semantic patch =====
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 88560d0ae50a..dab30a8c7470 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2802,6 +2802,7 @@ static ssize_t ray_cs_essid_proc_write(struct file *file,
 static const struct file_operations ray_cs_essid_proc_fops = {
 	.owner		= THIS_MODULE,
 	.write		= ray_cs_essid_proc_write,
+	.llseek		= noop_llseek,
 };
 
 static ssize_t int_proc_write(struct file *file, const char __user *buffer,
@@ -2835,6 +2836,7 @@ static ssize_t int_proc_write(struct file *file, const char __user *buffer,
 static const struct file_operations int_proc_fops = {
 	.owner		= THIS_MODULE,
 	.write		= int_proc_write,
+	.llseek		= noop_llseek,
 };
 #endif
 

commit 2262054e74b4b26ed56a8535c1259f6c6c2862a4
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Aug 15 08:38:38 2010 +0200

    pcmcia: remove obsolete and wrong comments
    
    What's worse than no comment? A wrong comment.
    
    Several PCMCIA device drivers contained the same comments, which
    were based on how the PCMCIA subsystem worked in the old days of 2.4.,
    and which were originally part of a "dummy_cs" driver. These comments
    no longer matched at all what is happening now, and therefore should
    be removed.
    
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index b5a2c9e31de2..af5b17ce5a15 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -168,13 +168,6 @@ static int bc;
  */
 static char *phy_addr = NULL;
 
-
-/* A struct pcmcia_device structure has fields for most things that are needed
-   to keep track of a socket, but there will usually be some device
-   specific information that also needs to be kept track of.  The
-   'priv' pointer in a struct pcmcia_device structure can be used to point to
-   a device-specific private data structure, like this.
-*/
 static unsigned int ray_mem_speed = 500;
 
 /* WARNING: THIS DRIVER IS NOT CAPABLE OF HANDLING MULTIPLE DEVICES! */
@@ -289,14 +282,6 @@ static const struct net_device_ops ray_netdev_ops = {
 	.ndo_validate_addr	= eth_validate_addr,
 };
 
-/*=============================================================================
-    ray_attach() creates an "instance" of the driver, allocating
-    local data structures for one device.  The device is registered
-    with Card Services.
-    The dev_link structure is initialized, but we don't actually
-    configure the card at this point -- we wait until we receive a
-    card insertion event.
-=============================================================================*/
 static int ray_probe(struct pcmcia_device *p_dev)
 {
 	ray_dev_t *local;
@@ -351,12 +336,6 @@ static int ray_probe(struct pcmcia_device *p_dev)
 	return -ENOMEM;
 } /* ray_attach */
 
-/*=============================================================================
-    This deletes a driver "instance".  The device is de-registered
-    with Card Services.  If it has been released, all local data
-    structures are freed.  Otherwise, the structures will be freed
-    when the device is released.
-=============================================================================*/
 static void ray_detach(struct pcmcia_device *link)
 {
 	struct net_device *dev;
@@ -379,11 +358,6 @@ static void ray_detach(struct pcmcia_device *link)
 	dev_dbg(&link->dev, "ray_cs ray_detach ending\n");
 } /* ray_detach */
 
-/*=============================================================================
-    ray_config() is run after a CARD_INSERTION event
-    is received, to configure the PCMCIA socket, and to make the
-    ethernet device available to the system.
-=============================================================================*/
 #define MAX_TUPLE_SIZE 128
 static int ray_config(struct pcmcia_device *link)
 {
@@ -409,9 +383,6 @@ static int ray_config(struct pcmcia_device *link)
 		goto failed;
 	dev->irq = link->irq;
 
-	/* This actually configures the PCMCIA socket -- setting up
-	   the I/O windows and the interrupt mapping.
-	 */
 	ret = pcmcia_enable_device(link);
 	if (ret)
 		goto failed;
@@ -771,11 +742,7 @@ static void join_net(u_long data)
 	local->card_status = CARD_DOING_ACQ;
 }
 
-/*============================================================================
-    After a card is removed, ray_release() will unregister the net
-    device, and release the PCMCIA configuration.  If the device is
-    still open, this will be postponed until it is closed.
-=============================================================================*/
+
 static void ray_release(struct pcmcia_device *link)
 {
 	struct net_device *dev = link->priv;

commit 2e9b981a7c63ee8278df6823f8389d69dad1a499
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Aug 8 11:36:26 2010 +0200

    pcmcia: move driver name to struct pcmcia_driver
    
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 1457f34efa9a..b5a2c9e31de2 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2843,9 +2843,7 @@ MODULE_DEVICE_TABLE(pcmcia, ray_ids);
 
 static struct pcmcia_driver ray_driver = {
 	.owner = THIS_MODULE,
-	.drv = {
-		.name = "ray_cs",
-		},
+	.name = "ray_cs",
 	.probe = ray_probe,
 	.remove = ray_detach,
 	.id_table = ray_ids,

commit 1ac71e5a35eebee60cdcf15b3980bd94498f037b
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Jul 29 19:27:09 2010 +0200

    pcmcia: convert pcmcia_request_configuration to pcmcia_enable_device
    
    pcmcia_enable_device() now replaces pcmcia_request_configuration().
    Instead of config_req_t, all necessary flags are either passed as
    a parameter to pcmcia_enable_device(), or (in rare circumstances)
    set in struct pcmcia_device -> flags.
    
    With the last remaining user of include/pcmcia/cs.h gone, remove
    all references.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: linux-scsi@vger.kernel.org
    Acked-by: Gustavo F. Padovan <padovan@profusion.mobi> (for drivers/bluetooth)
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 7fb66cc1e9fd..1457f34efa9a 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -46,7 +46,6 @@
 #include <linux/ethtool.h>
 #include <linux/ieee80211.h>
 
-#include <pcmcia/cs.h>
 #include <pcmcia/cistpl.h>
 #include <pcmcia/cisreg.h>
 #include <pcmcia/ds.h>
@@ -318,7 +317,7 @@ static int ray_probe(struct pcmcia_device *p_dev)
 	p_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;
 
 	/* General socket configuration */
-	p_dev->conf.Attributes = CONF_ENABLE_IRQ;
+	p_dev->config_flags |= CONF_ENABLE_IRQ;
 	p_dev->config_index = 1;
 
 	p_dev->priv = dev;
@@ -413,7 +412,7 @@ static int ray_config(struct pcmcia_device *link)
 	/* This actually configures the PCMCIA socket -- setting up
 	   the I/O windows and the interrupt mapping.
 	 */
-	ret = pcmcia_request_configuration(link, &link->conf);
+	ret = pcmcia_enable_device(link);
 	if (ret)
 		goto failed;
 

commit 7feabb6412ea23edd298c0fa90e5aa6733eb4a42
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Jul 29 18:35:47 2010 +0200

    pcmcia: move config_{base,index,regs} to struct pcmcia_device
    
    Several drivers prefer to explicitly set config_{base,index,regs},
    formerly known as ConfigBase, ConfigIndex and Present. Instead of
    passing these values inside config_req_t, store it in struct
    pcmcia_device.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: linux-scsi@vger.kernel.org
    Acked-by: Gustavo F. Padovan <padovan@profusion.mobi> (for drivers/bluetooth)
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 30cfd8890e34..7fb66cc1e9fd 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -319,7 +319,7 @@ static int ray_probe(struct pcmcia_device *p_dev)
 
 	/* General socket configuration */
 	p_dev->conf.Attributes = CONF_ENABLE_IRQ;
-	p_dev->conf.ConfigIndex = 1;
+	p_dev->config_index = 1;
 
 	p_dev->priv = dev;
 

commit 37979e1546a790c44adbc7f27a85569944480ebc
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Jul 29 16:33:23 2010 +0200

    pcmcia: simplify IntType
    
    IntType was only set to INT_MEMORY (driver pcmciamtd) or INT_MEMORY_AND_IO
    (all other drivers). As this flags seems to relate to ioport access, make
    it conditional to the driver having requested IO port access. There are two
    drivers which do not request IO ports, but did set INT_MEMORY_AND_IO:
    ray_cs and b43. For those, we consistently only set INT_MEMORY in future.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: linux-scsi@vger.kernel.org
    Acked-by: Gustavo F. Padovan <padovan@profusion.mobi> (for drivers/bluetooth)
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index ab34cb8c56c7..30cfd8890e34 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -319,7 +319,6 @@ static int ray_probe(struct pcmcia_device *p_dev)
 
 	/* General socket configuration */
 	p_dev->conf.Attributes = CONF_ENABLE_IRQ;
-	p_dev->conf.IntType = INT_MEMORY_AND_IO;
 	p_dev->conf.ConfigIndex = 1;
 
 	p_dev->priv = dev;

commit cdb138080b78146d1cdadba9f5dadbeb97445b91
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Jul 28 10:59:06 2010 +0200

    pcmcia: do not use win_req_t when calling pcmcia_request_window()
    
    Instead of win_req_t, drivers are now requested to fill out
    struct pcmcia_device *p_dev->resource[2,3,4,5] for up to four iomem
    ranges. After a call to pcmcia_request_window(), the windows found there
    are reserved and may be used until pcmcia_release_window() is called.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-mtd@lists.infradead.org
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: linux-scsi@vger.kernel.org
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 88560d0ae50a..ab34cb8c56c7 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -391,7 +391,6 @@ static int ray_config(struct pcmcia_device *link)
 {
 	int ret = 0;
 	int i;
-	win_req_t req;
 	struct net_device *dev = (struct net_device *)link->priv;
 	ray_dev_t *local = netdev_priv(dev);
 
@@ -420,46 +419,45 @@ static int ray_config(struct pcmcia_device *link)
 		goto failed;
 
 /*** Set up 32k window for shared memory (transmit and control) ************/
-	req.Attributes =
-	    WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_CM | WIN_ENABLE | WIN_USE_WAIT;
-	req.Base = 0;
-	req.Size = 0x8000;
-	req.AccessSpeed = ray_mem_speed;
-	ret = pcmcia_request_window(link, &req, &link->win);
+	link->resource[2]->flags |= WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_CM | WIN_ENABLE | WIN_USE_WAIT;
+	link->resource[2]->start = 0;
+	link->resource[2]->end = 0x8000;
+	ret = pcmcia_request_window(link, link->resource[2], ray_mem_speed);
 	if (ret)
 		goto failed;
-	ret = pcmcia_map_mem_page(link, link->win, 0);
+	ret = pcmcia_map_mem_page(link, link->resource[2], 0);
 	if (ret)
 		goto failed;
-	local->sram = ioremap(req.Base, req.Size);
+	local->sram = ioremap(link->resource[2]->start,
+			resource_size(link->resource[2]));
 
 /*** Set up 16k window for shared memory (receive buffer) ***************/
-	req.Attributes =
+	link->resource[3]->flags |=
 	    WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_CM | WIN_ENABLE | WIN_USE_WAIT;
-	req.Base = 0;
-	req.Size = 0x4000;
-	req.AccessSpeed = ray_mem_speed;
-	ret = pcmcia_request_window(link, &req, &local->rmem_handle);
+	link->resource[3]->start = 0;
+	link->resource[3]->end = 0x4000;
+	ret = pcmcia_request_window(link, link->resource[3], ray_mem_speed);
 	if (ret)
 		goto failed;
-	ret = pcmcia_map_mem_page(link, local->rmem_handle, 0x8000);
+	ret = pcmcia_map_mem_page(link, link->resource[3], 0x8000);
 	if (ret)
 		goto failed;
-	local->rmem = ioremap(req.Base, req.Size);
+	local->rmem = ioremap(link->resource[3]->start,
+			resource_size(link->resource[3]));
 
 /*** Set up window for attribute memory ***********************************/
-	req.Attributes =
+	link->resource[4]->flags |=
 	    WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_AM | WIN_ENABLE | WIN_USE_WAIT;
-	req.Base = 0;
-	req.Size = 0x1000;
-	req.AccessSpeed = ray_mem_speed;
-	ret = pcmcia_request_window(link, &req, &local->amem_handle);
+	link->resource[4]->start = 0;
+	link->resource[4]->end = 0x1000;
+	ret = pcmcia_request_window(link, link->resource[4], ray_mem_speed);
 	if (ret)
 		goto failed;
-	ret = pcmcia_map_mem_page(link, local->amem_handle, 0);
+	ret = pcmcia_map_mem_page(link, link->resource[4], 0);
 	if (ret)
 		goto failed;
-	local->amem = ioremap(req.Base, req.Size);
+	local->amem = ioremap(link->resource[4]->start,
+			resource_size(link->resource[4]));
 
 	dev_dbg(&link->dev, "ray_config sram=%p\n", local->sram);
 	dev_dbg(&link->dev, "ray_config rmem=%p\n", local->rmem);

commit b618f6f885579a6237e5bf4582fa6167972ddef4
Merge: 462fb2af9788 6e5c2b4e8add
Author: John W. Linville <linville@tuxdriver.com>
Date:   Tue Sep 21 15:49:14 2010 -0400

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-next-2.6 into for-davem
    
    Conflicts:
            arch/arm/mach-omap2/board-omap3pandora.c
            drivers/net/wireless/ath/ath5k/base.c

commit b6f45c2c03c1d858233cb0c35471dcb6cb213cdf
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Wed Sep 1 18:16:22 2010 -0700

    ray_cs: make data const
    
    Make the startup and other data parameters that are read/only
    const. Compile tested only.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 9c38fc331dca..390ccf6e08a3 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -198,7 +198,7 @@ module_param(bc, int, 0);
 module_param(phy_addr, charp, 0);
 module_param(ray_mem_speed, int, 0);
 
-static UCHAR b5_default_startup_parms[] = {
+static const UCHAR b5_default_startup_parms[] = {
 	0, 0,			/* Adhoc station */
 	'L', 'I', 'N', 'U', 'X', 0, 0, 0,	/* 32 char ESSID */
 	0, 0, 0, 0, 0, 0, 0, 0,
@@ -233,7 +233,7 @@ static UCHAR b5_default_startup_parms[] = {
 	2, 0, 0, 0, 0, 0, 0, 0	/* basic rate set */
 };
 
-static UCHAR b4_default_startup_parms[] = {
+static const UCHAR b4_default_startup_parms[] = {
 	0, 0,			/* Adhoc station */
 	'L', 'I', 'N', 'U', 'X', 0, 0, 0,	/* 32 char ESSID */
 	0, 0, 0, 0, 0, 0, 0, 0,
@@ -265,9 +265,9 @@ static UCHAR b4_default_startup_parms[] = {
 };
 
 /*===========================================================================*/
-static unsigned char eth2_llc[] = { 0xaa, 0xaa, 3, 0, 0, 0 };
+static const u8 eth2_llc[] = { 0xaa, 0xaa, 3, 0, 0, 0 };
 
-static char hop_pattern_length[] = { 1,
+static const char hop_pattern_length[] = { 1,
 	USA_HOP_MOD, EUROPE_HOP_MOD,
 	JAPAN_HOP_MOD, KOREA_HOP_MOD,
 	SPAIN_HOP_MOD, FRANCE_HOP_MOD,
@@ -275,7 +275,7 @@ static char hop_pattern_length[] = { 1,
 	JAPAN_TEST_HOP_MOD
 };
 
-static char rcsid[] =
+static const char rcsid[] =
     "Raylink/WebGear wireless LAN - Corey <Thomas corey@world.std.com>";
 
 static const struct net_device_ops ray_netdev_ops = {
@@ -2608,7 +2608,7 @@ static void clear_interrupt(ray_dev_t *local)
 #ifdef CONFIG_PROC_FS
 #define MAXDATA (PAGE_SIZE - 80)
 
-static char *card_status[] = {
+static const char *card_status[] = {
 	"Card inserted - uninitialized",	/* 0 */
 	"Card not downloaded",			/* 1 */
 	"Waiting for download parameters",	/* 2 */
@@ -2625,8 +2625,8 @@ static char *card_status[] = {
 	"Association failed"			/* 16 */
 };
 
-static char *nettype[] = { "Adhoc", "Infra " };
-static char *framing[] = { "Encapsulation", "Translation" }
+static const char *nettype[] = { "Adhoc", "Infra " };
+static const char *framing[] = { "Encapsulation", "Translation" }
 
 ;
 /*===========================================================================*/

commit c061b18df0f1fe3f50fe451dbbdc9ede3c19701a
Author: Joe Perches <joe@perches.com>
Date:   Mon Aug 23 18:20:03 2010 +0000

    drivers/net: Remove address use from assignments of function pointers
    
    "foo = &function" is more commonly written "foo = function"
    
    Done with coccinelle script:
    
    // <smpl>
    @r@
    identifier f;
    @@
    
    f(...) { ... }
    
    @@
    identifier r.f;
    @@
    
    - &f
    + f
    // </smpl>
    
    drivers/net/tehuti.c used a function and struct with the
    same name, the function was renamed.
    
    Compile tested x86 only.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 3bd9cf76517d..d91a831a7700 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -604,7 +604,7 @@ static int dl_startup_params(struct net_device *dev)
 	/* Start kernel timer to wait for dl startup to complete. */
 	local->timer.expires = jiffies + HZ / 2;
 	local->timer.data = (long)local;
-	local->timer.function = &verify_dl_startup;
+	local->timer.function = verify_dl_startup;
 	add_timer(&local->timer);
 	dev_dbg(&link->dev,
 	      "ray_cs dl_startup_params started timer for verify_dl_startup\n");
@@ -1981,12 +1981,12 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 					dev_dbg(&link->dev,
 					      "ray_cs interrupt network \"%s\" start failed\n",
 					      local->sparm.b4.a_current_ess_id);
-					local->timer.function = &start_net;
+					local->timer.function = start_net;
 				} else {
 					dev_dbg(&link->dev,
 					      "ray_cs interrupt network \"%s\" join failed\n",
 					      local->sparm.b4.a_current_ess_id);
-					local->timer.function = &join_net;
+					local->timer.function = join_net;
 				}
 				add_timer(&local->timer);
 			}
@@ -2454,9 +2454,9 @@ static void authenticate(ray_dev_t *local)
 
 	del_timer(&local->timer);
 	if (build_auth_frame(local, local->bss_id, OPEN_AUTH_REQUEST)) {
-		local->timer.function = &join_net;
+		local->timer.function = join_net;
 	} else {
-		local->timer.function = &authenticate_timeout;
+		local->timer.function = authenticate_timeout;
 	}
 	local->timer.expires = jiffies + HZ * 2;
 	local->timer.data = (long)local;
@@ -2541,7 +2541,7 @@ static void associate(ray_dev_t *local)
 		del_timer(&local->timer);
 		local->timer.expires = jiffies + HZ * 2;
 		local->timer.data = (long)local;
-		local->timer.function = &join_net;
+		local->timer.function = join_net;
 		add_timer(&local->timer);
 		local->card_status = CARD_ASSOC_FAILED;
 		return;

commit 01414802054c382072b6cb9a1bdc6e243c74b2d5
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Tue Aug 17 02:31:15 2010 -0700

    ethtool: Provide a default implementation of ethtool_ops::get_drvinfo
    
    The driver name and bus address for a net_device can normally be found
    through the driver model now.  Instead of requiring drivers to provide
    this information redundantly through the ethtool_ops::get_drvinfo
    operation, use the driver model to do so if the driver does not define
    the operation.  Since ETHTOOL_GDRVINFO no longer requires the driver
    to implement any operations, do not require net_device::ethtool_ops to
    be set either.
    
    Remove implementations of get_drvinfo and ethtool_ops that provide
    only this information.
    
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 88560d0ae50a..3bd9cf76517d 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -43,7 +43,6 @@
 #include <linux/if_arp.h>
 #include <linux/ioport.h>
 #include <linux/skbuff.h>
-#include <linux/ethtool.h>
 #include <linux/ieee80211.h>
 
 #include <pcmcia/cs.h>
@@ -80,8 +79,6 @@ static int ray_dev_config(struct net_device *dev, struct ifmap *map);
 static struct net_device_stats *ray_get_stats(struct net_device *dev);
 static int ray_dev_init(struct net_device *dev);
 
-static const struct ethtool_ops netdev_ethtool_ops;
-
 static int ray_open(struct net_device *dev);
 static netdev_tx_t ray_dev_start_xmit(struct sk_buff *skb,
 					    struct net_device *dev);
@@ -333,7 +330,6 @@ static int ray_probe(struct pcmcia_device *p_dev)
 
 	/* Raylink entries in the device structure */
 	dev->netdev_ops = &ray_netdev_ops;
-	SET_ETHTOOL_OPS(dev, &netdev_ethtool_ops);
 	dev->wireless_handlers = &ray_handler_def;
 #ifdef WIRELESS_SPY
 	local->wireless_data.spy_data = &local->spy_data;
@@ -1062,18 +1058,6 @@ AP to AP	1	1	dest AP		src AP		dest	source
 	}
 } /* end encapsulate_frame */
 
-/*===========================================================================*/
-
-static void netdev_get_drvinfo(struct net_device *dev,
-			       struct ethtool_drvinfo *info)
-{
-	strcpy(info->driver, "ray_cs");
-}
-
-static const struct ethtool_ops netdev_ethtool_ops = {
-	.get_drvinfo = netdev_get_drvinfo,
-};
-
 /*====================================================================*/
 
 /*------------------------------------------------------------------*/

commit 1685e633b396b0f3dabbc9fa5d65dfefe6435250
Merge: 1cfd2bda8c48 127c03cdbad9
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 6 12:25:06 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/brodo/pcmcia-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/brodo/pcmcia-2.6:
      pcmcia: avoid buffer overflow in pcmcia_setup_isa_irq
      pcmcia: do not request windows if you don't need to
      pcmcia: insert PCMCIA device resources into resource tree
      pcmcia: export resource information to sysfs
      pcmcia: use struct resource for PCMCIA devices, part 2
      pcmcia: remove memreq_t
      pcmcia: move local definitions out of include/pcmcia/cs.h
      pcmcia: do not use io_req_t when calling pcmcia_request_io()
      pcmcia: do not use io_req_t after call to pcmcia_request_io()
      pcmcia: use struct resource for PCMCIA devices
      pcmcia: clean up cs.h
      pcmcia: use pcmica_{read,write}_config_byte
      pcmcia: remove cs_types.h
      pcmcia: remove unused flag, simplify headers
      pcmcia: remove obsolete CS_EVENT_ definitions
      pcmcia: split up central event handler
      pcmcia: simplify event callback
      pcmcia: remove obsolete ioctl
    
    Conflicts in:
     - drivers/staging/comedi/drivers/*
     - drivers/staging/wlags49_h2/wl_cs.c
    due to dev_info_t and whitespace changes

commit 0ca724d37af370dbf2d55dc4d6359ead558e5756
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Jul 24 19:03:02 2010 +0200

    pcmcia: use struct resource for PCMCIA devices, part 2
    
    Use struct resource * also for iomem resources.
    
    CC: linux-mtd@lists.infradead.org
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 7eb339af351b..a860bce6849b 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -785,7 +785,6 @@ static void ray_release(struct pcmcia_device *link)
 {
 	struct net_device *dev = link->priv;
 	ray_dev_t *local = netdev_priv(dev);
-	int i;
 
 	dev_dbg(&link->dev, "ray_release\n");
 
@@ -794,13 +793,6 @@ static void ray_release(struct pcmcia_device *link)
 	iounmap(local->sram);
 	iounmap(local->rmem);
 	iounmap(local->amem);
-	/* Do bother checking to see if these succeed or not */
-	i = pcmcia_release_window(link, local->amem_handle);
-	if (i != 0)
-		dev_dbg(&link->dev, "ReleaseWindow(local->amem) ret = %x\n", i);
-	i = pcmcia_release_window(link, local->rmem_handle);
-	if (i != 0)
-		dev_dbg(&link->dev, "ReleaseWindow(local->rmem) ret = %x\n", i);
 	pcmcia_disable_device(link);
 
 	dev_dbg(&link->dev, "ray_release ending\n");

commit b5cb259e7fac5536c4ddf350af6a3d6cc950e47e
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Jul 24 18:46:42 2010 +0200

    pcmcia: remove memreq_t
    
    Page already had to be set to 0; Offset can easily be passed as
    parameter to pcmcia_map_mem_page.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: linux-bluetooth@vger.kernel.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Michael Buesch <mb@bu3sch.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index b83d5ef1dffe..7eb339af351b 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -393,7 +393,6 @@ static int ray_config(struct pcmcia_device *link)
 	int ret = 0;
 	int i;
 	win_req_t req;
-	memreq_t mem;
 	struct net_device *dev = (struct net_device *)link->priv;
 	ray_dev_t *local = netdev_priv(dev);
 
@@ -430,9 +429,7 @@ static int ray_config(struct pcmcia_device *link)
 	ret = pcmcia_request_window(link, &req, &link->win);
 	if (ret)
 		goto failed;
-	mem.CardOffset = 0x0000;
-	mem.Page = 0;
-	ret = pcmcia_map_mem_page(link, link->win, &mem);
+	ret = pcmcia_map_mem_page(link, link->win, 0);
 	if (ret)
 		goto failed;
 	local->sram = ioremap(req.Base, req.Size);
@@ -446,9 +443,7 @@ static int ray_config(struct pcmcia_device *link)
 	ret = pcmcia_request_window(link, &req, &local->rmem_handle);
 	if (ret)
 		goto failed;
-	mem.CardOffset = 0x8000;
-	mem.Page = 0;
-	ret = pcmcia_map_mem_page(link, local->rmem_handle, &mem);
+	ret = pcmcia_map_mem_page(link, local->rmem_handle, 0x8000);
 	if (ret)
 		goto failed;
 	local->rmem = ioremap(req.Base, req.Size);
@@ -462,9 +457,7 @@ static int ray_config(struct pcmcia_device *link)
 	ret = pcmcia_request_window(link, &req, &local->amem_handle);
 	if (ret)
 		goto failed;
-	mem.CardOffset = 0x0000;
-	mem.Page = 0;
-	ret = pcmcia_map_mem_page(link, local->amem_handle, &mem);
+	ret = pcmcia_map_mem_page(link, local->amem_handle, 0);
 	if (ret)
 		goto failed;
 	local->amem = ioremap(req.Base, req.Size);

commit 90abdc3b973229bae98dd96649d9f7106cc177a4
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Jul 24 17:23:51 2010 +0200

    pcmcia: do not use io_req_t when calling pcmcia_request_io()
    
    Instead of io_req_t, drivers are now requested to fill out
    struct pcmcia_device *p_dev->resource[0,1] for up to two ioport
    ranges. After a call to pcmcia_request_io(), the ports found there
    are reserved, after calling pcmcia_request_configuration(), they may
    be used.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Michael Buesch <mb@bu3sch.de>
    Acked-by: Marcel Holtmann <marcel@holtmann.org> (for drivers/bluetooth/)
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 165beb6af849..b83d5ef1dffe 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -315,9 +315,8 @@ static int ray_probe(struct pcmcia_device *p_dev)
 	local->finder = p_dev;
 
 	/* The io structure describes IO port mapping. None used here */
-	p_dev->io.NumPorts1 = 0;
-	p_dev->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
-	p_dev->io.IOAddrLines = 5;
+	p_dev->resource[0]->end = 0;
+	p_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;
 
 	/* General socket configuration */
 	p_dev->conf.Attributes = CONF_ENABLE_IRQ;

commit ac8b422838046ffc26be4874a3cbae0d313f4209
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Jul 21 22:38:13 2010 +0200

    pcmcia: remove cs_types.h
    
    Remove cs_types.h which is no longer needed: Most definitions aren't
    used at all, a few can be made away with, and two remaining definitions
    (typedefs, unfortunatley) may be moved to more specific places.
    
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    Acked-by: Marcel Holtmann <marcel@holtmann.org> (for drivers/bluetooth/)
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index abff8934db13..165beb6af849 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -46,7 +46,6 @@
 #include <linux/ethtool.h>
 #include <linux/ieee80211.h>
 
-#include <pcmcia/cs_types.h>
 #include <pcmcia/cs.h>
 #include <pcmcia/cistpl.h>
 #include <pcmcia/cisreg.h>

commit 882d829a23756dd827d8ed30000f73f1b035ad29
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Fri Jul 23 03:18:09 2010 +0000

    wireless: use newly introduced hex_to_bin()
    
    Signed-off-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Corey Thomas <coreythomas@charter.net>
    Cc: "John W. Linville" <linville@tuxdriver.com>
    Cc: linux-wireless@vger.kernel.org
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index abff8934db13..9c38fc331dca 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -97,7 +97,6 @@ static iw_stats *ray_get_wireless_stats(struct net_device *dev);
 static const struct iw_handler_def ray_handler_def;
 
 /***** Prototypes for raylink functions **************************************/
-static int asc_to_int(char a);
 static void authenticate(ray_dev_t *local);
 static int build_auth_frame(ray_dev_t *local, UCHAR *dest, int auth_type);
 static void authenticate_timeout(u_long);
@@ -1716,24 +1715,6 @@ static void authenticate_timeout(u_long data)
 	join_net((u_long) local);
 }
 
-/*===========================================================================*/
-static int asc_to_int(char a)
-{
-	if (a < '0')
-		return -1;
-	if (a <= '9')
-		return (a - '0');
-	if (a < 'A')
-		return -1;
-	if (a <= 'F')
-		return (10 + a - 'A');
-	if (a < 'a')
-		return -1;
-	if (a <= 'f')
-		return (10 + a - 'a');
-	return -1;
-}
-
 /*===========================================================================*/
 static int parse_addr(char *in_str, UCHAR *out)
 {
@@ -1754,14 +1735,14 @@ static int parse_addr(char *in_str, UCHAR *out)
 	i = 5;
 
 	while (j > 0) {
-		if ((k = asc_to_int(in_str[j--])) != -1)
+		if ((k = hex_to_bin(in_str[j--])) != -1)
 			out[i] = k;
 		else
 			return 0;
 
 		if (j == 0)
 			break;
-		if ((k = asc_to_int(in_str[j--])) != -1)
+		if ((k = hex_to_bin(in_str[j--])) != -1)
 			out[i] += k << 4;
 		else
 			return 0;

commit f8965467f366fd18f01feafb5db10512d7b4422c
Merge: a26272e52007 2ec8c6bb5d8f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 20 21:04:44 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6: (1674 commits)
      qlcnic: adding co maintainer
      ixgbe: add support for active DA cables
      ixgbe: dcb, do not tag tc_prio_control frames
      ixgbe: fix ixgbe_tx_is_paused logic
      ixgbe: always enable vlan strip/insert when DCB is enabled
      ixgbe: remove some redundant code in setting FCoE FIP filter
      ixgbe: fix wrong offset to fc_frame_header in ixgbe_fcoe_ddp
      ixgbe: fix header len when unsplit packet overflows to data buffer
      ipv6: Never schedule DAD timer on dead address
      ipv6: Use POSTDAD state
      ipv6: Use state_lock to protect ifa state
      ipv6: Replace inet6_ifaddr->dead with state
      cxgb4: notify upper drivers if the device is already up when they load
      cxgb4: keep interrupts available when the ports are brought down
      cxgb4: fix initial addition of MAC address
      cnic: Return SPQ credit to bnx2x after ring setup and shutdown.
      cnic: Convert cnic_local_flags to atomic ops.
      can: Fix SJA1000 command register writes on SMP systems
      bridge: fix build for CONFIG_SYSFS disabled
      ARCNET: Limit com20020 PCI ID matches for SOHARD cards
      ...
    
    Fix up various conflicts with pcmcia tree drivers/net/
    {pcmcia/3c589_cs.c, wireless/orinoco/orinoco_cs.c and
    wireless/orinoco/spectrum_cs.c} and feature removal
    (Documentation/feature-removal-schedule.txt).
    
    Also fix a non-content conflict due to pm_qos_requirement getting
    renamed in the PM tree (now pm_qos_request) in net/mac80211/scan.c

commit a4b770972b8f819e408d7cc3ae9637e15bff62f6
Author: Joe Perches <joe@perches.com>
Date:   Fri May 14 00:19:28 2010 -0700

    drivers/net: Remove unnecessary returns from void function()s
    
    This patch removes from drivers/net/ all the unnecessary
    return; statements that precede the last closing brace of
    void functions.
    
    It does not remove the returns that are immediately
    preceded by a label as gcc doesn't like that.
    
    It also does not remove null void functions with return.
    
    Done via:
    $ grep -rP --include=*.[ch] -l "return;\n}" net/ | \
      xargs perl -i -e 'local $/ ; while (<>) { s/\n[ \t\n]+return;\n}/\n}/g; print; }'
    
    with some cleanups by hand.
    
    Compile tested x86 allmodconfig only.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 73972ee76540..3886b21becd9 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -735,8 +735,6 @@ static void verify_dl_startup(u_long data)
 		start_net((u_long) local);
 	else
 		join_net((u_long) local);
-
-	return;
 } /* end verify_dl_startup */
 
 /*===========================================================================*/
@@ -764,7 +762,6 @@ static void start_net(u_long data)
 		return;
 	}
 	local->card_status = CARD_DOING_ACQ;
-	return;
 } /* end start_net */
 
 /*===========================================================================*/
@@ -795,7 +792,6 @@ static void join_net(u_long data)
 		return;
 	}
 	local->card_status = CARD_DOING_ACQ;
-	return;
 }
 
 /*============================================================================
@@ -1626,7 +1622,6 @@ static int ray_dev_close(struct net_device *dev)
 static void ray_reset(struct net_device *dev)
 {
 	pr_debug("ray_reset entered\n");
-	return;
 }
 
 /*===========================================================================*/

commit 1ae5dc342ac78d7a42965fd1f323815f6f5ef2c1
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Mon May 10 05:01:31 2010 -0700

    net: trans_start cleanups
    
    Now that core network takes care of trans_start updates, dont do it
    in drivers themselves, if possible. Drivers can avoid one cache miss
    (on dev->trans_start) in their start_xmit() handler.
    
    Exceptions are NETIF_F_LLTX drivers
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index d9c45bfcee61..73972ee76540 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -941,7 +941,6 @@ static netdev_tx_t ray_dev_start_xmit(struct sk_buff *skb,
 	case XMIT_MSG_BAD:
 	case XMIT_OK:
 	default:
-		dev->trans_start = jiffies;
 		dev_kfree_skb(skb);
 	}
 

commit 4b49291aca7ea60a3da645c8f9fa8b2d6efee120
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Mar 20 14:06:24 2010 +0100

    pcmcia: remove unused mem_op.h
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 18a93f1adcc4..f7d2a34ca531 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -51,7 +51,6 @@
 #include <pcmcia/cistpl.h>
 #include <pcmcia/cisreg.h>
 #include <pcmcia/ds.h>
-#include <pcmcia/mem_op.h>
 
 #include <linux/wireless.h>
 #include <net/iw_handler.h>

commit c7c2fa079073ab92b0736a161b4cf1051a3e631f
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Mar 20 19:39:26 2010 +0100

    pcmcia: dev_node removal (drivers with unregister_netdev check)
    
    As a third step, remove any usage of dev_node_t from drivers which
    only wrote to this typedef/struct, except to determine whether
    register_netdev() succeeded previously. However, the function calling
    unregister_netdev() was only ever called by the PCMCIA core if
    register_netdev() succeeded previously. The lonely exception was
    easily fixed.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index fe4642a49bfb..18a93f1adcc4 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -379,8 +379,7 @@ static void ray_detach(struct pcmcia_device *link)
 	del_timer(&local->timer);
 
 	if (link->priv) {
-		if (link->dev_node)
-			unregister_netdev(dev);
+		unregister_netdev(dev);
 		free_netdev(dev);
 	}
 	dev_dbg(&link->dev, "ray_cs ray_detach ending\n");
@@ -489,9 +488,6 @@ static int ray_config(struct pcmcia_device *link)
 		return i;
 	}
 
-	strcpy(local->node.dev_name, dev->name);
-	link->dev_node = &local->node;
-
 	printk(KERN_INFO "%s: RayLink, irq %d, hw_addr %pM\n",
 	       dev->name, dev->irq, dev->dev_addr);
 

commit eb14120f743d29744d9475bffec56ff4ad43a749
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 7 12:21:16 2010 +0100

    pcmcia: re-work pcmcia_request_irq()
    
    Instead of the old pcmcia_request_irq() interface, drivers may now
    choose between:
    
    - calling request_irq/free_irq directly. Use the IRQ from *p_dev->irq.
    
    - use pcmcia_request_irq(p_dev, handler_t); the PCMCIA core will
      clean up automatically on calls to pcmcia_disable_device() or
      device ejection.
    
    - drivers still not capable of IRQF_SHARED (or not telling us so) may
      use the deprecated pcmcia_request_exclusive_irq() for the time
      being; they might receive a shared IRQ nonetheless.
    
    CC: linux-bluetooth@vger.kernel.org
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-serial@vger.kernel.org
    CC: alsa-devel@alsa-project.org
    CC: linux-usb@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 11865ea21875..fe4642a49bfb 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -321,10 +321,6 @@ static int ray_probe(struct pcmcia_device *p_dev)
 	p_dev->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
 	p_dev->io.IOAddrLines = 5;
 
-	/* Interrupt setup. For PCMCIA, driver takes what's given */
-	p_dev->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING;
-	p_dev->irq.Handler = &ray_interrupt;
-
 	/* General socket configuration */
 	p_dev->conf.Attributes = CONF_ENABLE_IRQ;
 	p_dev->conf.IntType = INT_MEMORY_AND_IO;
@@ -417,10 +413,10 @@ static int ray_config(struct pcmcia_device *link)
 	/* Now allocate an interrupt line.  Note that this does not
 	   actually assign a handler to the interrupt.
 	 */
-	ret = pcmcia_request_irq(link, &link->irq);
+	ret = pcmcia_request_irq(link, ray_interrupt);
 	if (ret)
 		goto failed;
-	dev->irq = link->irq.AssignedIRQ;
+	dev->irq = link->irq;
 
 	/* This actually configures the PCMCIA socket -- setting up
 	   the I/O windows and the interrupt mapping.

commit 5c01d5669356e13f0fb468944c1dd4c6a7e978ad
Merge: fea069152614 a5e944f1d955
Author: John W. Linville <linville@tuxdriver.com>
Date:   Thu Apr 15 16:21:34 2010 -0400

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless-next-2.6 into for-davem
    
    Conflicts:
            Documentation/feature-removal-schedule.txt
            drivers/net/wireless/ath/ath5k/phy.c
            drivers/net/wireless/wl12xx/wl1271_main.c

commit 871039f02f8ec4ab2e5e9010718caa8e085786f1
Merge: e4077e018b5e 4a1032faac94
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Apr 11 14:53:53 2010 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
            drivers/net/stmmac/stmmac_main.c
            drivers/net/wireless/wl12xx/wl1271_cmd.c
            drivers/net/wireless/wl12xx/wl1271_main.c
            drivers/net/wireless/wl12xx/wl1271_spi.c
            net/core/ethtool.c
            net/mac80211/scan.c

commit 22bedad3ce112d5ca1eaf043d4990fa2ed698c87
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Thu Apr 1 21:22:57 2010 +0000

    net: convert multicast list to list_head
    
    Converts the list and the core manipulating with it to be the same as uc_list.
    
    +uses two functions for adding/removing mc address (normal and "global"
     variant) instead of a function parameter.
    +removes dev_mcast.c completely.
    +exposes netdev_hw_addr_list_* macros along with __hw_addr_* functions for
     manipulation with lists on a sandbox (used in bonding and 80211 drivers)
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 4f5bdb528ef7..54680a3a5acb 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -1875,17 +1875,17 @@ static void ray_update_multi_list(struct net_device *dev, int all)
 		writeb(0xff, &pccs->var);
 		local->num_multi = 0xff;
 	} else {
-		struct dev_mc_list *dmi;
+		struct netdev_hw_addr *ha;
 		int i = 0;
 
 		/* Copy the kernel's list of MC addresses to card */
-		netdev_for_each_mc_addr(dmi, dev) {
-			memcpy_toio(p, dmi->dmi_addr, ETH_ALEN);
+		netdev_for_each_mc_addr(ha, dev) {
+			memcpy_toio(p, ha->addr, ETH_ALEN);
 			dev_dbg(&link->dev,
 			      "ray_update_multi add addr %02x%02x%02x%02x%02x%02x\n",
-			      dmi->dmi_addr[0], dmi->dmi_addr[1],
-			      dmi->dmi_addr[2], dmi->dmi_addr[3],
-			      dmi->dmi_addr[4], dmi->dmi_addr[5]);
+			      ha->addr[0], ha->addr[1],
+			      ha->addr[2], ha->addr[3],
+			      ha->addr[4], ha->addr[5]);
 			p += ETH_ALEN;
 			i++;
 		}

commit cb01b09c6914ab04dc836941dc92a1dd42714e19
Author: Frans Pop <elendil@planet.nl>
Date:   Wed Mar 24 19:46:34 2010 +0100

    wireless/raylink: remove trailing space in messages
    
    Signed-off-by: Frans Pop <elendil@planet.nl>
    Cc: Corey Thomas <coreythomas@charter.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 4f5bdb528ef7..f1e916a31668 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -556,7 +556,7 @@ static int ray_init(struct net_device *dev)
 	local->fw_ver = local->startup_res.firmware_version[0];
 	local->fw_bld = local->startup_res.firmware_version[1];
 	local->fw_var = local->startup_res.firmware_version[2];
-	dev_dbg(&link->dev, "ray_init firmware version %d.%d \n", local->fw_ver,
+	dev_dbg(&link->dev, "ray_init firmware version %d.%d\n", local->fw_ver,
 	      local->fw_bld);
 
 	local->tib_length = 0x20;
@@ -2234,7 +2234,7 @@ static void rx_data(struct net_device *dev, struct rcs __iomem *prcs,
 			    (dev->mtu + RX_MAC_HEADER_LENGTH + ETH_HLEN +
 			     FCS_LEN)) {
 				pr_debug(
-				      "ray_cs invalid packet length %d received \n",
+				      "ray_cs invalid packet length %d received\n",
 				      rx_len);
 				return;
 			}
@@ -2245,7 +2245,7 @@ static void rx_data(struct net_device *dev, struct rcs __iomem *prcs,
 			    (dev->mtu + RX_MAC_HEADER_LENGTH + ETH_HLEN +
 			     FCS_LEN)) {
 				pr_debug(
-				      "ray_cs invalid packet length %d received \n",
+				      "ray_cs invalid packet length %d received\n",
 				      rx_len);
 				return;
 			}
@@ -2753,11 +2753,11 @@ static int ray_cs_proc_show(struct seq_file *m, void *v)
 			seq_printf(m, "Hop dwell            = %d Kus\n",
 				   pfh->dwell_time[0] +
 				   256 * pfh->dwell_time[1]);
-			seq_printf(m, "Hop set              = %d \n",
+			seq_printf(m, "Hop set              = %d\n",
 				   pfh->hop_set);
-			seq_printf(m, "Hop pattern          = %d \n",
+			seq_printf(m, "Hop pattern          = %d\n",
 				   pfh->hop_pattern);
-			seq_printf(m, "Hop index            = %d \n",
+			seq_printf(m, "Hop index            = %d\n",
 				   pfh->hop_index);
 			p += p[1] + 2;
 		} else {

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 84c530aa52f9..11865ea21875 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -35,7 +35,6 @@
 #include <linux/proc_fs.h>
 #include <linux/ptrace.h>
 #include <linux/seq_file.h>
-#include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/timer.h>
 #include <linux/init.h>

commit 43ead78ac48b75aaf47de96fcf10cbf5962f32a6
Author: Joe Perches <joe@perches.com>
Date:   Thu Mar 18 18:29:40 2010 -0700

    drivers/net/wireless/ray_cs.c: Use iw_handler function prototypes
    
    Change local functions that are cast to iw_handler to
    the more standard use with "union iwreq_data *wrqu"
    so the iw_handler array no longer needs the casts.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index a42ee01e7b14..4f5bdb528ef7 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -1113,10 +1113,10 @@ static const struct ethtool_ops netdev_ethtool_ops = {
 /*
  * Wireless Handler : get protocol name
  */
-static int ray_get_name(struct net_device *dev,
-			struct iw_request_info *info, char *cwrq, char *extra)
+static int ray_get_name(struct net_device *dev, struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra)
 {
-	strcpy(cwrq, "IEEE 802.11-FH");
+	strcpy(wrqu->name, "IEEE 802.11-FH");
 	return 0;
 }
 
@@ -1124,9 +1124,8 @@ static int ray_get_name(struct net_device *dev,
 /*
  * Wireless Handler : set frequency
  */
-static int ray_set_freq(struct net_device *dev,
-			struct iw_request_info *info,
-			struct iw_freq *fwrq, char *extra)
+static int ray_set_freq(struct net_device *dev, struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 	int err = -EINPROGRESS;	/* Call commit handler */
@@ -1136,10 +1135,10 @@ static int ray_set_freq(struct net_device *dev,
 		return -EBUSY;
 
 	/* Setting by channel number */
-	if ((fwrq->m > USA_HOP_MOD) || (fwrq->e > 0))
+	if ((wrqu->freq.m > USA_HOP_MOD) || (wrqu->freq.e > 0))
 		err = -EOPNOTSUPP;
 	else
-		local->sparm.b5.a_hop_pattern = fwrq->m;
+		local->sparm.b5.a_hop_pattern = wrqu->freq.m;
 
 	return err;
 }
@@ -1148,14 +1147,13 @@ static int ray_set_freq(struct net_device *dev,
 /*
  * Wireless Handler : get frequency
  */
-static int ray_get_freq(struct net_device *dev,
-			struct iw_request_info *info,
-			struct iw_freq *fwrq, char *extra)
+static int ray_get_freq(struct net_device *dev, struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 
-	fwrq->m = local->sparm.b5.a_hop_pattern;
-	fwrq->e = 0;
+	wrqu->freq.m = local->sparm.b5.a_hop_pattern;
+	wrqu->freq.e = 0;
 	return 0;
 }
 
@@ -1163,9 +1161,8 @@ static int ray_get_freq(struct net_device *dev,
 /*
  * Wireless Handler : set ESSID
  */
-static int ray_set_essid(struct net_device *dev,
-			 struct iw_request_info *info,
-			 struct iw_point *dwrq, char *extra)
+static int ray_set_essid(struct net_device *dev, struct iw_request_info *info,
+			 union iwreq_data *wrqu, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 
@@ -1174,19 +1171,17 @@ static int ray_set_essid(struct net_device *dev,
 		return -EBUSY;
 
 	/* Check if we asked for `any' */
-	if (dwrq->flags == 0) {
+	if (wrqu->essid.flags == 0)
 		/* Corey : can you do that ? */
 		return -EOPNOTSUPP;
-	} else {
-		/* Check the size of the string */
-		if (dwrq->length > IW_ESSID_MAX_SIZE) {
-			return -E2BIG;
-		}
 
-		/* Set the ESSID in the card */
-		memset(local->sparm.b5.a_current_ess_id, 0, IW_ESSID_MAX_SIZE);
-		memcpy(local->sparm.b5.a_current_ess_id, extra, dwrq->length);
-	}
+	/* Check the size of the string */
+	if (wrqu->essid.length > IW_ESSID_MAX_SIZE)
+		return -E2BIG;
+
+	/* Set the ESSID in the card */
+	memset(local->sparm.b5.a_current_ess_id, 0, IW_ESSID_MAX_SIZE);
+	memcpy(local->sparm.b5.a_current_ess_id, extra, wrqu->essid.length);
 
 	return -EINPROGRESS;	/* Call commit handler */
 }
@@ -1195,9 +1190,8 @@ static int ray_set_essid(struct net_device *dev,
 /*
  * Wireless Handler : get ESSID
  */
-static int ray_get_essid(struct net_device *dev,
-			 struct iw_request_info *info,
-			 struct iw_point *dwrq, char *extra)
+static int ray_get_essid(struct net_device *dev, struct iw_request_info *info,
+			 union iwreq_data *wrqu, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 
@@ -1205,8 +1199,8 @@ static int ray_get_essid(struct net_device *dev,
 	memcpy(extra, local->sparm.b5.a_current_ess_id, IW_ESSID_MAX_SIZE);
 
 	/* Push it out ! */
-	dwrq->length = strlen(extra);
-	dwrq->flags = 1;	/* active */
+	wrqu->essid.length = strlen(extra);
+	wrqu->essid.flags = 1;	/* active */
 
 	return 0;
 }
@@ -1215,14 +1209,13 @@ static int ray_get_essid(struct net_device *dev,
 /*
  * Wireless Handler : get AP address
  */
-static int ray_get_wap(struct net_device *dev,
-		       struct iw_request_info *info,
-		       struct sockaddr *awrq, char *extra)
+static int ray_get_wap(struct net_device *dev, struct iw_request_info *info,
+		       union iwreq_data *wrqu, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 
-	memcpy(awrq->sa_data, local->bss_id, ETH_ALEN);
-	awrq->sa_family = ARPHRD_ETHER;
+	memcpy(wrqu->ap_addr.sa_data, local->bss_id, ETH_ALEN);
+	wrqu->ap_addr.sa_family = ARPHRD_ETHER;
 
 	return 0;
 }
@@ -1231,9 +1224,8 @@ static int ray_get_wap(struct net_device *dev,
 /*
  * Wireless Handler : set Bit-Rate
  */
-static int ray_set_rate(struct net_device *dev,
-			struct iw_request_info *info,
-			struct iw_param *vwrq, char *extra)
+static int ray_set_rate(struct net_device *dev, struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 
@@ -1242,15 +1234,15 @@ static int ray_set_rate(struct net_device *dev,
 		return -EBUSY;
 
 	/* Check if rate is in range */
-	if ((vwrq->value != 1000000) && (vwrq->value != 2000000))
+	if ((wrqu->bitrate.value != 1000000) && (wrqu->bitrate.value != 2000000))
 		return -EINVAL;
 
 	/* Hack for 1.5 Mb/s instead of 2 Mb/s */
 	if ((local->fw_ver == 0x55) &&	/* Please check */
-	    (vwrq->value == 2000000))
+	    (wrqu->bitrate.value == 2000000))
 		local->net_default_tx_rate = 3;
 	else
-		local->net_default_tx_rate = vwrq->value / 500000;
+		local->net_default_tx_rate = wrqu->bitrate.value / 500000;
 
 	return 0;
 }
@@ -1259,17 +1251,16 @@ static int ray_set_rate(struct net_device *dev,
 /*
  * Wireless Handler : get Bit-Rate
  */
-static int ray_get_rate(struct net_device *dev,
-			struct iw_request_info *info,
-			struct iw_param *vwrq, char *extra)
+static int ray_get_rate(struct net_device *dev, struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 
 	if (local->net_default_tx_rate == 3)
-		vwrq->value = 2000000;	/* Hum... */
+		wrqu->bitrate.value = 2000000;	/* Hum... */
 	else
-		vwrq->value = local->net_default_tx_rate * 500000;
-	vwrq->fixed = 0;	/* We are in auto mode */
+		wrqu->bitrate.value = local->net_default_tx_rate * 500000;
+	wrqu->bitrate.fixed = 0;	/* We are in auto mode */
 
 	return 0;
 }
@@ -1278,19 +1269,18 @@ static int ray_get_rate(struct net_device *dev,
 /*
  * Wireless Handler : set RTS threshold
  */
-static int ray_set_rts(struct net_device *dev,
-		       struct iw_request_info *info,
-		       struct iw_param *vwrq, char *extra)
+static int ray_set_rts(struct net_device *dev, struct iw_request_info *info,
+		       union iwreq_data *wrqu, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
-	int rthr = vwrq->value;
+	int rthr = wrqu->rts.value;
 
 	/* Reject if card is already initialised */
 	if (local->card_status != CARD_AWAITING_PARAM)
 		return -EBUSY;
 
 	/* if(wrq->u.rts.fixed == 0) we should complain */
-	if (vwrq->disabled)
+	if (wrqu->rts.disabled)
 		rthr = 32767;
 	else {
 		if ((rthr < 0) || (rthr > 2347))   /* What's the max packet size ??? */
@@ -1306,16 +1296,15 @@ static int ray_set_rts(struct net_device *dev,
 /*
  * Wireless Handler : get RTS threshold
  */
-static int ray_get_rts(struct net_device *dev,
-		       struct iw_request_info *info,
-		       struct iw_param *vwrq, char *extra)
+static int ray_get_rts(struct net_device *dev, struct iw_request_info *info,
+		       union iwreq_data *wrqu, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 
-	vwrq->value = (local->sparm.b5.a_rts_threshold[0] << 8)
+	wrqu->rts.value = (local->sparm.b5.a_rts_threshold[0] << 8)
 	    + local->sparm.b5.a_rts_threshold[1];
-	vwrq->disabled = (vwrq->value == 32767);
-	vwrq->fixed = 1;
+	wrqu->rts.disabled = (wrqu->rts.value == 32767);
+	wrqu->rts.fixed = 1;
 
 	return 0;
 }
@@ -1324,19 +1313,18 @@ static int ray_get_rts(struct net_device *dev,
 /*
  * Wireless Handler : set Fragmentation threshold
  */
-static int ray_set_frag(struct net_device *dev,
-			struct iw_request_info *info,
-			struct iw_param *vwrq, char *extra)
+static int ray_set_frag(struct net_device *dev, struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
-	int fthr = vwrq->value;
+	int fthr = wrqu->frag.value;
 
 	/* Reject if card is already initialised */
 	if (local->card_status != CARD_AWAITING_PARAM)
 		return -EBUSY;
 
 	/* if(wrq->u.frag.fixed == 0) should complain */
-	if (vwrq->disabled)
+	if (wrqu->frag.disabled)
 		fthr = 32767;
 	else {
 		if ((fthr < 256) || (fthr > 2347))	/* To check out ! */
@@ -1352,16 +1340,15 @@ static int ray_set_frag(struct net_device *dev,
 /*
  * Wireless Handler : get Fragmentation threshold
  */
-static int ray_get_frag(struct net_device *dev,
-			struct iw_request_info *info,
-			struct iw_param *vwrq, char *extra)
+static int ray_get_frag(struct net_device *dev, struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 
-	vwrq->value = (local->sparm.b5.a_frag_threshold[0] << 8)
+	wrqu->frag.value = (local->sparm.b5.a_frag_threshold[0] << 8)
 	    + local->sparm.b5.a_frag_threshold[1];
-	vwrq->disabled = (vwrq->value == 32767);
-	vwrq->fixed = 1;
+	wrqu->frag.disabled = (wrqu->frag.value == 32767);
+	wrqu->frag.fixed = 1;
 
 	return 0;
 }
@@ -1370,8 +1357,8 @@ static int ray_get_frag(struct net_device *dev,
 /*
  * Wireless Handler : set Mode of Operation
  */
-static int ray_set_mode(struct net_device *dev,
-			struct iw_request_info *info, __u32 *uwrq, char *extra)
+static int ray_set_mode(struct net_device *dev, struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 	int err = -EINPROGRESS;	/* Call commit handler */
@@ -1381,7 +1368,7 @@ static int ray_set_mode(struct net_device *dev,
 	if (local->card_status != CARD_AWAITING_PARAM)
 		return -EBUSY;
 
-	switch (*uwrq) {
+	switch (wrqu->mode) {
 	case IW_MODE_ADHOC:
 		card_mode = 0;
 		/* Fall through */
@@ -1399,15 +1386,15 @@ static int ray_set_mode(struct net_device *dev,
 /*
  * Wireless Handler : get Mode of Operation
  */
-static int ray_get_mode(struct net_device *dev,
-			struct iw_request_info *info, __u32 *uwrq, char *extra)
+static int ray_get_mode(struct net_device *dev, struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 
 	if (local->sparm.b5.a_network_type)
-		*uwrq = IW_MODE_INFRA;
+		wrqu->mode = IW_MODE_INFRA;
 	else
-		*uwrq = IW_MODE_ADHOC;
+		wrqu->mode = IW_MODE_ADHOC;
 
 	return 0;
 }
@@ -1416,16 +1403,15 @@ static int ray_get_mode(struct net_device *dev,
 /*
  * Wireless Handler : get range info
  */
-static int ray_get_range(struct net_device *dev,
-			 struct iw_request_info *info,
-			 struct iw_point *dwrq, char *extra)
+static int ray_get_range(struct net_device *dev, struct iw_request_info *info,
+			 union iwreq_data *wrqu, char *extra)
 {
 	struct iw_range *range = (struct iw_range *)extra;
 
-	memset((char *)range, 0, sizeof(struct iw_range));
+	memset(range, 0, sizeof(struct iw_range));
 
 	/* Set the length (very important for backward compatibility) */
-	dwrq->length = sizeof(struct iw_range);
+	wrqu->data.length = sizeof(struct iw_range);
 
 	/* Set the Wireless Extension versions */
 	range->we_version_compiled = WIRELESS_EXT;
@@ -1448,8 +1434,7 @@ static int ray_get_range(struct net_device *dev,
 /*
  * Wireless Private Handler : set framing mode
  */
-static int ray_set_framing(struct net_device *dev,
-			   struct iw_request_info *info,
+static int ray_set_framing(struct net_device *dev, struct iw_request_info *info,
 			   union iwreq_data *wrqu, char *extra)
 {
 	translate = *(extra);	/* Set framing mode */
@@ -1461,8 +1446,7 @@ static int ray_set_framing(struct net_device *dev,
 /*
  * Wireless Private Handler : get framing mode
  */
-static int ray_get_framing(struct net_device *dev,
-			   struct iw_request_info *info,
+static int ray_get_framing(struct net_device *dev, struct iw_request_info *info,
 			   union iwreq_data *wrqu, char *extra)
 {
 	*(extra) = translate;
@@ -1474,8 +1458,7 @@ static int ray_get_framing(struct net_device *dev,
 /*
  * Wireless Private Handler : get country
  */
-static int ray_get_country(struct net_device *dev,
-			   struct iw_request_info *info,
+static int ray_get_country(struct net_device *dev, struct iw_request_info *info,
 			   union iwreq_data *wrqu, char *extra)
 {
 	*(extra) = country;
@@ -1487,10 +1470,9 @@ static int ray_get_country(struct net_device *dev,
 /*
  * Commit handler : called after a bunch of SET operations
  */
-static int ray_commit(struct net_device *dev, struct iw_request_info *info,	/* NULL */
-		      void *zwrq,	/* NULL */
-		      char *extra)
-{ /* NULL */
+static int ray_commit(struct net_device *dev, struct iw_request_info *info,
+		      union iwreq_data *wrqu, char *extra)
+{
 	return 0;
 }
 
@@ -1531,28 +1513,28 @@ static iw_stats *ray_get_wireless_stats(struct net_device *dev)
  */
 
 static const iw_handler ray_handler[] = {
-	IW_HANDLER(SIOCSIWCOMMIT, (iw_handler)ray_commit),
-	IW_HANDLER(SIOCGIWNAME, (iw_handler)ray_get_name),
-	IW_HANDLER(SIOCSIWFREQ, (iw_handler)ray_set_freq),
-	IW_HANDLER(SIOCGIWFREQ, (iw_handler)ray_get_freq),
-	IW_HANDLER(SIOCSIWMODE, (iw_handler)ray_set_mode),
-	IW_HANDLER(SIOCGIWMODE, (iw_handler)ray_get_mode),
-	IW_HANDLER(SIOCGIWRANGE, (iw_handler)ray_get_range),
+	IW_HANDLER(SIOCSIWCOMMIT, ray_commit),
+	IW_HANDLER(SIOCGIWNAME, ray_get_name),
+	IW_HANDLER(SIOCSIWFREQ, ray_set_freq),
+	IW_HANDLER(SIOCGIWFREQ, ray_get_freq),
+	IW_HANDLER(SIOCSIWMODE, ray_set_mode),
+	IW_HANDLER(SIOCGIWMODE, ray_get_mode),
+	IW_HANDLER(SIOCGIWRANGE, ray_get_range),
 #ifdef WIRELESS_SPY
 	IW_HANDLER(SIOCSIWSPY, iw_handler_set_spy),
 	IW_HANDLER(SIOCGIWSPY, iw_handler_get_spy),
 	IW_HANDLER(SIOCSIWTHRSPY, iw_handler_set_thrspy),
 	IW_HANDLER(SIOCGIWTHRSPY, iw_handler_get_thrspy),
 #endif /* WIRELESS_SPY */
-	IW_HANDLER(SIOCGIWAP, (iw_handler)ray_get_wap),
-	IW_HANDLER(SIOCSIWESSID, (iw_handler)ray_set_essid),
-	IW_HANDLER(SIOCGIWESSID, (iw_handler)ray_get_essid),
-	IW_HANDLER(SIOCSIWRATE, (iw_handler)ray_set_rate),
-	IW_HANDLER(SIOCGIWRATE, (iw_handler)ray_get_rate),
-	IW_HANDLER(SIOCSIWRTS, (iw_handler)ray_set_rts),
-	IW_HANDLER(SIOCGIWRTS, (iw_handler)ray_get_rts),
-	IW_HANDLER(SIOCSIWFRAG, (iw_handler)ray_set_frag),
-	IW_HANDLER(SIOCGIWFRAG, (iw_handler)ray_get_frag),
+	IW_HANDLER(SIOCGIWAP, ray_get_wap),
+	IW_HANDLER(SIOCSIWESSID, ray_set_essid),
+	IW_HANDLER(SIOCGIWESSID, ray_get_essid),
+	IW_HANDLER(SIOCSIWRATE, ray_set_rate),
+	IW_HANDLER(SIOCGIWRATE, ray_get_rate),
+	IW_HANDLER(SIOCSIWRTS, ray_set_rts),
+	IW_HANDLER(SIOCGIWRTS, ray_get_rts),
+	IW_HANDLER(SIOCSIWFRAG, ray_set_frag),
+	IW_HANDLER(SIOCGIWFRAG, ray_get_frag),
 };
 
 #define SIOCSIPFRAMING	SIOCIWFIRSTPRIV	/* Set framing mode */
@@ -1560,9 +1542,9 @@ static const iw_handler ray_handler[] = {
 #define SIOCGIPCOUNTRY	SIOCIWFIRSTPRIV + 3	/* Get country code */
 
 static const iw_handler ray_private_handler[] = {
-	[0] = (iw_handler) ray_set_framing,
-	[1] = (iw_handler) ray_get_framing,
-	[3] = (iw_handler) ray_get_country,
+	[0] = ray_set_framing,
+	[1] = ray_get_framing,
+	[3] = ray_get_country,
 };
 
 static const struct iw_priv_args ray_private_args[] = {

commit 270020e85ec88a832d663fff4489523169641c2b
Author: Joe Perches <joe@perches.com>
Date:   Thu Mar 18 18:29:37 2010 -0700

    drivers/net/wireless: Use IW_HANDLER macro
    
    Convert direct uses of [ (foo - SIOCIWFIRST) , fn)
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 84c530aa52f9..a42ee01e7b14 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -1531,28 +1531,28 @@ static iw_stats *ray_get_wireless_stats(struct net_device *dev)
  */
 
 static const iw_handler ray_handler[] = {
-	[SIOCSIWCOMMIT - SIOCIWFIRST] = (iw_handler) ray_commit,
-	[SIOCGIWNAME - SIOCIWFIRST] = (iw_handler) ray_get_name,
-	[SIOCSIWFREQ - SIOCIWFIRST] = (iw_handler) ray_set_freq,
-	[SIOCGIWFREQ - SIOCIWFIRST] = (iw_handler) ray_get_freq,
-	[SIOCSIWMODE - SIOCIWFIRST] = (iw_handler) ray_set_mode,
-	[SIOCGIWMODE - SIOCIWFIRST] = (iw_handler) ray_get_mode,
-	[SIOCGIWRANGE - SIOCIWFIRST] = (iw_handler) ray_get_range,
+	IW_HANDLER(SIOCSIWCOMMIT, (iw_handler)ray_commit),
+	IW_HANDLER(SIOCGIWNAME, (iw_handler)ray_get_name),
+	IW_HANDLER(SIOCSIWFREQ, (iw_handler)ray_set_freq),
+	IW_HANDLER(SIOCGIWFREQ, (iw_handler)ray_get_freq),
+	IW_HANDLER(SIOCSIWMODE, (iw_handler)ray_set_mode),
+	IW_HANDLER(SIOCGIWMODE, (iw_handler)ray_get_mode),
+	IW_HANDLER(SIOCGIWRANGE, (iw_handler)ray_get_range),
 #ifdef WIRELESS_SPY
-	[SIOCSIWSPY - SIOCIWFIRST] = (iw_handler) iw_handler_set_spy,
-	[SIOCGIWSPY - SIOCIWFIRST] = (iw_handler) iw_handler_get_spy,
-	[SIOCSIWTHRSPY - SIOCIWFIRST] = (iw_handler) iw_handler_set_thrspy,
-	[SIOCGIWTHRSPY - SIOCIWFIRST] = (iw_handler) iw_handler_get_thrspy,
+	IW_HANDLER(SIOCSIWSPY, iw_handler_set_spy),
+	IW_HANDLER(SIOCGIWSPY, iw_handler_get_spy),
+	IW_HANDLER(SIOCSIWTHRSPY, iw_handler_set_thrspy),
+	IW_HANDLER(SIOCGIWTHRSPY, iw_handler_get_thrspy),
 #endif /* WIRELESS_SPY */
-	[SIOCGIWAP - SIOCIWFIRST] = (iw_handler) ray_get_wap,
-	[SIOCSIWESSID - SIOCIWFIRST] = (iw_handler) ray_set_essid,
-	[SIOCGIWESSID - SIOCIWFIRST] = (iw_handler) ray_get_essid,
-	[SIOCSIWRATE - SIOCIWFIRST] = (iw_handler) ray_set_rate,
-	[SIOCGIWRATE - SIOCIWFIRST] = (iw_handler) ray_get_rate,
-	[SIOCSIWRTS - SIOCIWFIRST] = (iw_handler) ray_set_rts,
-	[SIOCGIWRTS - SIOCIWFIRST] = (iw_handler) ray_get_rts,
-	[SIOCSIWFRAG - SIOCIWFIRST] = (iw_handler) ray_set_frag,
-	[SIOCGIWFRAG - SIOCIWFIRST] = (iw_handler) ray_get_frag,
+	IW_HANDLER(SIOCGIWAP, (iw_handler)ray_get_wap),
+	IW_HANDLER(SIOCSIWESSID, (iw_handler)ray_set_essid),
+	IW_HANDLER(SIOCGIWESSID, (iw_handler)ray_get_essid),
+	IW_HANDLER(SIOCSIWRATE, (iw_handler)ray_set_rate),
+	IW_HANDLER(SIOCGIWRATE, (iw_handler)ray_get_rate),
+	IW_HANDLER(SIOCSIWRTS, (iw_handler)ray_set_rts),
+	IW_HANDLER(SIOCGIWRTS, (iw_handler)ray_get_rts),
+	IW_HANDLER(SIOCSIWFRAG, (iw_handler)ray_set_frag),
+	IW_HANDLER(SIOCGIWFRAG, (iw_handler)ray_get_frag),
 };
 
 #define SIOCSIPFRAMING	SIOCIWFIRSTPRIV	/* Set framing mode */

commit 655ffee284dfcf9a24ac0343f3e5ee6db85b85c5
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Sat Feb 27 07:35:45 2010 +0000

    wireless: convert to use netdev_for_each_mc_addr
    
    also added missed locking in rndis_wlan.c
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 85905cab4f16..84c530aa52f9 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -1871,10 +1871,8 @@ static void ray_update_parm(struct net_device *dev, UCHAR objid, UCHAR *value,
 /*===========================================================================*/
 static void ray_update_multi_list(struct net_device *dev, int all)
 {
-	struct dev_mc_list *dmi, **dmip;
 	int ccsindex;
 	struct ccs __iomem *pccs;
-	int i = 0;
 	ray_dev_t *local = netdev_priv(dev);
 	struct pcmcia_device *link = local->finder;
 	void __iomem *p = local->sram + HOST_TO_ECF_BASE;
@@ -1895,9 +1893,11 @@ static void ray_update_multi_list(struct net_device *dev, int all)
 		writeb(0xff, &pccs->var);
 		local->num_multi = 0xff;
 	} else {
+		struct dev_mc_list *dmi;
+		int i = 0;
+
 		/* Copy the kernel's list of MC addresses to card */
-		for (dmip = &dev->mc_list; (dmi = *dmip) != NULL;
-		     dmip = &dmi->next) {
+		netdev_for_each_mc_addr(dmi, dev) {
 			memcpy_toio(p, dmi->dmi_addr, ETH_ALEN);
 			dev_dbg(&link->dev,
 			      "ray_update_multi add addr %02x%02x%02x%02x%02x%02x\n",

commit 4cd24eaf0c6ee7f0242e34ee77ec899f255e66b5
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Mon Feb 8 04:30:35 2010 +0000

    net: use netdev_mc_count and netdev_mc_empty when appropriate
    
    This patch replaces dev->mc_count in all drivers (hopefully I didn't miss
    anything). Used spatch and did small tweaks and conding style changes when
    it was suitable.
    
    Jirka
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 88e1e4e32b22..85905cab4f16 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -1950,7 +1950,7 @@ static void set_multicast_list(struct net_device *dev)
 	if (dev->flags & IFF_ALLMULTI)
 		ray_update_multi_list(dev, 1);
 	else {
-		if (local->num_multi != dev->mc_count)
+		if (local->num_multi != netdev_mc_count(dev))
 			ray_update_multi_list(dev, 0);
 	}
 } /* end set_multicast_list */

commit 28b4d5cc17c20786848cdc07b7ea237a309776bb
Merge: d29cecda036f 96fa2b508d2d
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Dec 5 15:22:26 2009 -0800

    Merge branch 'master' of /home/davem/src/GIT/linux-2.6/
    
    Conflicts:
            drivers/net/pcmcia/fmvj18x_cs.c
            drivers/net/pcmcia/nmclan_cs.c
            drivers/net/pcmcia/xirc2ps_cs.c
            drivers/net/wireless/ray_cs.c

commit d9b2c4d0b03c721808c0d259e43a27f1e80205bc
Merge: 27d16d08717f 5fa9167a1bf5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 5 09:42:59 2009 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/brodo/pcmcia-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/brodo/pcmcia-2.6: (50 commits)
      pcmcia: rework the irq_req_t typedef
      pcmcia: remove deprecated handle_to_dev() macro
      pcmcia: pcmcia_request_window() doesn't need a pointer to a pointer
      pcmcia: remove unused "window_t" typedef
      pcmcia: move some window-related code to pcmcia_ioctl.c
      pcmcia: Change window_handle_t logic to unsigned long
      pcmcia: Pass struct pcmcia_socket to pcmcia_get_mem_page()
      pcmcia: Pass struct pcmcia_device to pcmcia_map_mem_page()
      pcmcia: Pass struct pcmcia_device to pcmcia_release_window()
      drivers/pcmcia: remove unnecessary kzalloc
      pcmcia: correct handling for Zoomed Video registers in topic.h
      pcmcia: fix printk formats
      pcmcia: autoload module pcmcia
      pcmcia/staging: update comedi drivers
      PCMCIA: stop duplicating pci_irq in soc_pcmcia_socket
      PCMCIA: ss: allow PCI IRQs > 255
      PCMCIA: soc_common: remove 'dev' member from soc_pcmcia_socket
      PCMCIA: soc_common: constify soc_pcmcia_socket ops member
      PCMCIA: sa1111: remove duplicated initializers
      PCMCIA: sa1111: wrap soc_pcmcia_socket to contain sa1111 specific data
      ...

commit 83daee06adeed7b294802c998d5e03ea7d856aa1
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Wed Nov 25 10:12:20 2009 +0300

    ray_cs: convert to proc_fops
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 5ee9d2a19360..0366f5aeb914 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2865,18 +2865,8 @@ static int build_auth_frame(ray_dev_t *local, UCHAR *dest, int auth_type)
 
 /*===========================================================================*/
 #ifdef CONFIG_PROC_FS
-static void raycs_write(const char *name, write_proc_t *w, void *data)
-{
-	struct proc_dir_entry *entry =
-	    create_proc_entry(name, S_IFREG | S_IWUSR, NULL);
-	if (entry) {
-		entry->write_proc = w;
-		entry->data = data;
-	}
-}
-
-static int write_essid(struct file *file, const char __user *buffer,
-		       unsigned long count, void *data)
+static ssize_t ray_cs_essid_proc_write(struct file *file,
+		const char __user *buffer, size_t count, loff_t *pos)
 {
 	static char proc_essid[33];
 	unsigned int len = count;
@@ -2890,8 +2880,13 @@ static int write_essid(struct file *file, const char __user *buffer,
 	return count;
 }
 
-static int write_int(struct file *file, const char __user *buffer,
-		     unsigned long count, void *data)
+static const struct file_operations ray_cs_essid_proc_fops = {
+	.owner		= THIS_MODULE,
+	.write		= ray_cs_essid_proc_write,
+};
+
+static ssize_t int_proc_write(struct file *file, const char __user *buffer,
+			      size_t count, loff_t *pos)
 {
 	static char proc_number[10];
 	char *p;
@@ -2914,9 +2909,14 @@ static int write_int(struct file *file, const char __user *buffer,
 		nr = nr * 10 + c;
 		p++;
 	} while (--len);
-	*(int *)data = nr;
+	*(int *)PDE(file->f_path.dentry->d_inode)->data = nr;
 	return count;
 }
+
+static const struct file_operations int_proc_fops = {
+	.owner		= THIS_MODULE,
+	.write		= int_proc_write,
+};
 #endif
 
 static struct pcmcia_device_id ray_ids[] = {
@@ -2951,9 +2951,9 @@ static int __init init_ray_cs(void)
 	proc_mkdir("driver/ray_cs", NULL);
 
 	proc_create("driver/ray_cs/ray_cs", 0, NULL, &ray_cs_proc_fops);
-	raycs_write("driver/ray_cs/essid", write_essid, NULL);
-	raycs_write("driver/ray_cs/net_type", write_int, &net_type);
-	raycs_write("driver/ray_cs/translate", write_int, &translate);
+	proc_create("driver/ray_cs/essid", S_IWUSR, NULL, &ray_cs_essid_proc_fops);
+	proc_create_data("driver/ray_cs/net_type", S_IWUSR, NULL, &int_proc_fops, &net_type);
+	proc_create_data("driver/ray_cs/translate", S_IWUSR, NULL, &int_proc_fops, &translate);
 #endif
 	if (translate != 0)
 		translate = 1;

commit 5fa9167a1bf5f5a4b7282f5e7ac56a4a5a1fa044
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Nov 8 17:24:46 2009 +0100

    pcmcia: rework the irq_req_t typedef
    
    Most of the irq_req_t typedef'd struct can be re-worked quite
    easily:
    
    (1) IRQInfo2 was unused in any case, so drop it.
    
    (2) IRQInfo1 was used write-only, so drop it.
    
    (3) Instance (private data to be passed to the IRQ handler):
            Most PCMCIA drivers using pcmcia_request_irq() to actually
            register an IRQ handler set the "dev_id" to the same pointer
            as the "priv" pointer in struct pcmcia_device. Modify the two
            exceptions (ipwireless, ibmtr_cs) to also work this waym and
            set the IRQ handler's "dev_id" to p_dev->priv unconditionally.
    
    (4) Handler is to be of type irq_handler_t.
    
    (5) Handler != NULL already tells whether an IRQ handler is present.
            Therefore, we do not need the IRQ_HANDLER_PRESENT flag in
            irq_req_t.Attributes.
    
    CC: netdev@vger.kernel.org
    CC: linux-bluetooth@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-scsi@vger.kernel.org
    CC: alsa-devel@alsa-project.org
    CC: Jaroslav Kysela <perex@perex.cz>
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: Karsten Keil <isdn@linux-pingi.de>
    for the Bluetooth parts: Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 5e0f4c3eac38..91213f9e2c4f 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -323,8 +323,7 @@ static int ray_probe(struct pcmcia_device *p_dev)
 	p_dev->io.IOAddrLines = 5;
 
 	/* Interrupt setup. For PCMCIA, driver takes what's given */
-	p_dev->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING | IRQ_HANDLE_PRESENT;
-	p_dev->irq.IRQInfo1 = IRQ_LEVEL_ID;
+	p_dev->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING;
 	p_dev->irq.Handler = &ray_interrupt;
 
 	/* General socket configuration */
@@ -333,7 +332,6 @@ static int ray_probe(struct pcmcia_device *p_dev)
 	p_dev->conf.ConfigIndex = 1;
 
 	p_dev->priv = dev;
-	p_dev->irq.Instance = dev;
 
 	local->finder = p_dev;
 	local->card_status = CARD_INSERTED;

commit dd2e5a156525f11754d9b1e0583f6bb49c253d62
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Nov 3 10:27:34 2009 +0100

    pcmcia: remove deprecated handle_to_dev() macro
    
    Update remaining users and remove deprecated handle_to_dev() macro
    
    CC: Harald Welte <laforge@gnumonks.org>
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-serial@vger.kernel.org
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 66e2d10cd754..5e0f4c3eac38 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -488,7 +488,7 @@ static int ray_config(struct pcmcia_device *link)
 		return -ENODEV;
 	}
 
-	SET_NETDEV_DEV(dev, &handle_to_dev(link));
+	SET_NETDEV_DEV(dev, &link->dev);
 	i = register_netdev(dev);
 	if (i != 0) {
 		printk("ray_config register_netdev() failed\n");

commit 6838b03fc6564ea07d0cd87ea6e198d90ab1fc3e
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Nov 3 01:31:52 2009 +0100

    pcmcia: pcmcia_request_window() doesn't need a pointer to a pointer
    
    pcmcia_request_window() only needs a pointer to struct pcmcia_device, not
    a pointer to a pointer.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-scsi@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    Acked-by: Karsten Keil <keil@b1-systems.de> (for ISDN)
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index f719ffcb3c74..66e2d10cd754 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -438,7 +438,7 @@ static int ray_config(struct pcmcia_device *link)
 	req.Base = 0;
 	req.Size = 0x8000;
 	req.AccessSpeed = ray_mem_speed;
-	ret = pcmcia_request_window(&link, &req, &link->win);
+	ret = pcmcia_request_window(link, &req, &link->win);
 	if (ret)
 		goto failed;
 	mem.CardOffset = 0x0000;
@@ -454,7 +454,7 @@ static int ray_config(struct pcmcia_device *link)
 	req.Base = 0;
 	req.Size = 0x4000;
 	req.AccessSpeed = ray_mem_speed;
-	ret = pcmcia_request_window(&link, &req, &local->rmem_handle);
+	ret = pcmcia_request_window(link, &req, &local->rmem_handle);
 	if (ret)
 		goto failed;
 	mem.CardOffset = 0x8000;
@@ -470,7 +470,7 @@ static int ray_config(struct pcmcia_device *link)
 	req.Base = 0;
 	req.Size = 0x1000;
 	req.AccessSpeed = ray_mem_speed;
-	ret = pcmcia_request_window(&link, &req, &local->amem_handle);
+	ret = pcmcia_request_window(link, &req, &local->amem_handle);
 	if (ret)
 		goto failed;
 	mem.CardOffset = 0x0000;

commit 868575d1e87ff2091800aea816972ddb46de60d5
Author: Magnus Damm <damm@opensource.se>
Date:   Wed Dec 13 19:46:43 2006 +0900

    pcmcia: Pass struct pcmcia_device to pcmcia_map_mem_page()
    
    No logic changes, just pass struct pcmcia_device to pcmcia_map_mem_page()
    
    [linux@dominikbrodowski.net: update to 2.6.31]
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-scsi@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    Acked-by: Karsten Keil <keil@b1-systems.de> (for ISDN)
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index ed328750de45..f719ffcb3c74 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -443,7 +443,7 @@ static int ray_config(struct pcmcia_device *link)
 		goto failed;
 	mem.CardOffset = 0x0000;
 	mem.Page = 0;
-	ret = pcmcia_map_mem_page(link->win, &mem);
+	ret = pcmcia_map_mem_page(link, link->win, &mem);
 	if (ret)
 		goto failed;
 	local->sram = ioremap(req.Base, req.Size);
@@ -459,7 +459,7 @@ static int ray_config(struct pcmcia_device *link)
 		goto failed;
 	mem.CardOffset = 0x8000;
 	mem.Page = 0;
-	ret = pcmcia_map_mem_page(local->rmem_handle, &mem);
+	ret = pcmcia_map_mem_page(link, local->rmem_handle, &mem);
 	if (ret)
 		goto failed;
 	local->rmem = ioremap(req.Base, req.Size);
@@ -475,7 +475,7 @@ static int ray_config(struct pcmcia_device *link)
 		goto failed;
 	mem.CardOffset = 0x0000;
 	mem.Page = 0;
-	ret = pcmcia_map_mem_page(local->amem_handle, &mem);
+	ret = pcmcia_map_mem_page(link, local->amem_handle, &mem);
 	if (ret)
 		goto failed;
 	local->amem = ioremap(req.Base, req.Size);

commit f5560da549ea2e32dd41e36548c0e7dee3d4aabb
Author: Magnus Damm <damm@opensource.se>
Date:   Wed Dec 13 19:46:38 2006 +0900

    pcmcia: Pass struct pcmcia_device to pcmcia_release_window()
    
    No logic changes, just pass struct pcmcia_device to pcmcia_release_window().
    
    [linux@dominikbrodowski.net: update to 2.6.31]
    CC: netdev@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 28db7914a5d1..ed328750de45 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -820,10 +820,10 @@ static void ray_release(struct pcmcia_device *link)
 	iounmap(local->rmem);
 	iounmap(local->amem);
 	/* Do bother checking to see if these succeed or not */
-	i = pcmcia_release_window(local->amem_handle);
+	i = pcmcia_release_window(link, local->amem_handle);
 	if (i != 0)
 		dev_dbg(&link->dev, "ReleaseWindow(local->amem) ret = %x\n", i);
-	i = pcmcia_release_window(local->rmem_handle);
+	i = pcmcia_release_window(link, local->rmem_handle);
 	if (i != 0)
 		dev_dbg(&link->dev, "ReleaseWindow(local->rmem) ret = %x\n", i);
 	pcmcia_disable_device(link);

commit 3505d1a9fd65e2d3e00827857b6795d9d8983658
Merge: dfef948ed2ba 66b00a7c93ec
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Nov 18 22:19:03 2009 -0800

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
            drivers/net/sfc/sfe4001.c
            drivers/net/wireless/libertas/cmd.c
            drivers/staging/Kconfig
            drivers/staging/Makefile
            drivers/staging/rtl8187se/Kconfig
            drivers/staging/rtl8192e/Kconfig

commit f9ef6028b2c1272a2f12299053efef90e8721f21
Author: Julia Lawall <julia@diku.dk>
Date:   Sun Nov 8 09:23:07 2009 +0100

    drivers/net/wireless: correct check on CCS_START_NETWORK
    
    CCS_START_NETWORK is declared in drivers/net/wireless/rayctl.h with the
    comment Values for cmd.  status is previously compared to
    CCS_COMMAND_COMPLETE, which is declared in the same file with the comment
    Values for buffer_status.  Finally, it is possible at this point that cmd
    is CCS_START_NETWORK, because it is compared to that value in an enclosing
    switch that has CCS_START_NETWORK as one of two case labels around this code.
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 88cd58eb3b9f..595e4414d770 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2074,7 +2074,7 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 				del_timer(&local->timer);
 				local->timer.expires = jiffies + HZ * 5;
 				local->timer.data = (long)local;
-				if (status == CCS_START_NETWORK) {
+				if (cmd == CCS_START_NETWORK) {
 					DEBUG(0,
 					      "ray_cs interrupt network \"%s\" start failed\n",
 					      local->sparm.b4.a_current_ess_id);

commit 624dd66957e53e15cf40e937b50597c4d41f0e99
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Oct 24 15:52:44 2009 +0200

    pcmcia: use dynamic debug infrastructure, deprecate CS_CHECK (ray-cs.c)
    
    Convert PCMCIA drivers to use the dynamic debug infrastructure, instead of
    requiring manual settings of PCMCIA_DEBUG.
    
    Also, remove all usages of the CS_CHECK macro and replace them with proper
    Linux style calling and return value checking. The extra error reporting may
    be dropped, as the PCMCIA core already complains about any (non-driver-author)
    errors.
    
    CC: linux-wireless@vger.kernel.org
    CC: netdev@vger.kernel.org
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 88cd58eb3b9f..28db7914a5d1 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -71,25 +71,7 @@ typedef u_char mac_addr[ETH_ALEN];	/* Hardware address */
 #include "rayctl.h"
 #include "ray_cs.h"
 
-/* All the PCMCIA modules use PCMCIA_DEBUG to control debugging.  If
-   you do not define PCMCIA_DEBUG at all, all the debug code will be
-   left out.  If you compile with PCMCIA_DEBUG=0, the debug code will
-   be present but disabled -- but it can then be enabled for specific
-   modules at load time with a 'pc_debug=#' option to insmod.
-*/
 
-#ifdef RAYLINK_DEBUG
-#define PCMCIA_DEBUG RAYLINK_DEBUG
-#endif
-#ifdef PCMCIA_DEBUG
-static int ray_debug;
-static int pc_debug = PCMCIA_DEBUG;
-module_param(pc_debug, int, 0);
-/* #define DEBUG(n, args...) if (pc_debug>(n)) printk(KERN_DEBUG args); */
-#define DEBUG(n, args...) if (pc_debug > (n)) printk(args);
-#else
-#define DEBUG(n, args...)
-#endif
 /** Prototypes based on PCMCIA skeleton driver *******************************/
 static int ray_config(struct pcmcia_device *link);
 static void ray_release(struct pcmcia_device *link);
@@ -325,7 +307,7 @@ static int ray_probe(struct pcmcia_device *p_dev)
 	ray_dev_t *local;
 	struct net_device *dev;
 
-	DEBUG(1, "ray_attach()\n");
+	dev_dbg(&p_dev->dev, "ray_attach()\n");
 
 	/* Allocate space for private device-specific data */
 	dev = alloc_etherdev(sizeof(ray_dev_t));
@@ -357,7 +339,7 @@ static int ray_probe(struct pcmcia_device *p_dev)
 	local->card_status = CARD_INSERTED;
 	local->authentication_state = UNAUTHENTICATED;
 	local->num_multi = 0;
-	DEBUG(2, "ray_attach p_dev = %p,  dev = %p,  local = %p, intr = %p\n",
+	dev_dbg(&p_dev->dev, "ray_attach p_dev = %p,  dev = %p,  local = %p, intr = %p\n",
 	      p_dev, dev, local, &ray_interrupt);
 
 	/* Raylink entries in the device structure */
@@ -370,7 +352,7 @@ static int ray_probe(struct pcmcia_device *p_dev)
 #endif /* WIRELESS_SPY */
 
 
-	DEBUG(2, "ray_cs ray_attach calling ether_setup.)\n");
+	dev_dbg(&p_dev->dev, "ray_cs ray_attach calling ether_setup.)\n");
 	netif_stop_queue(dev);
 
 	init_timer(&local->timer);
@@ -393,7 +375,7 @@ static void ray_detach(struct pcmcia_device *link)
 	struct net_device *dev;
 	ray_dev_t *local;
 
-	DEBUG(1, "ray_detach(0x%p)\n", link);
+	dev_dbg(&link->dev, "ray_detach\n");
 
 	this_device = NULL;
 	dev = link->priv;
@@ -408,7 +390,7 @@ static void ray_detach(struct pcmcia_device *link)
 			unregister_netdev(dev);
 		free_netdev(dev);
 	}
-	DEBUG(2, "ray_cs ray_detach ending\n");
+	dev_dbg(&link->dev, "ray_cs ray_detach ending\n");
 } /* ray_detach */
 
 /*=============================================================================
@@ -416,19 +398,17 @@ static void ray_detach(struct pcmcia_device *link)
     is received, to configure the PCMCIA socket, and to make the
     ethernet device available to the system.
 =============================================================================*/
-#define CS_CHECK(fn, ret) \
-do { last_fn = (fn); if ((last_ret = (ret)) != 0) goto cs_failed; } while (0)
 #define MAX_TUPLE_SIZE 128
 static int ray_config(struct pcmcia_device *link)
 {
-	int last_fn = 0, last_ret = 0;
+	int ret = 0;
 	int i;
 	win_req_t req;
 	memreq_t mem;
 	struct net_device *dev = (struct net_device *)link->priv;
 	ray_dev_t *local = netdev_priv(dev);
 
-	DEBUG(1, "ray_config(0x%p)\n", link);
+	dev_dbg(&link->dev, "ray_config\n");
 
 	/* Determine card type and firmware version */
 	printk(KERN_INFO "ray_cs Detected: %s%s%s%s\n",
@@ -440,14 +420,17 @@ static int ray_config(struct pcmcia_device *link)
 	/* Now allocate an interrupt line.  Note that this does not
 	   actually assign a handler to the interrupt.
 	 */
-	CS_CHECK(RequestIRQ, pcmcia_request_irq(link, &link->irq));
+	ret = pcmcia_request_irq(link, &link->irq);
+	if (ret)
+		goto failed;
 	dev->irq = link->irq.AssignedIRQ;
 
 	/* This actually configures the PCMCIA socket -- setting up
 	   the I/O windows and the interrupt mapping.
 	 */
-	CS_CHECK(RequestConfiguration,
-		 pcmcia_request_configuration(link, &link->conf));
+	ret = pcmcia_request_configuration(link, &link->conf);
+	if (ret)
+		goto failed;
 
 /*** Set up 32k window for shared memory (transmit and control) ************/
 	req.Attributes =
@@ -455,10 +438,14 @@ static int ray_config(struct pcmcia_device *link)
 	req.Base = 0;
 	req.Size = 0x8000;
 	req.AccessSpeed = ray_mem_speed;
-	CS_CHECK(RequestWindow, pcmcia_request_window(&link, &req, &link->win));
+	ret = pcmcia_request_window(&link, &req, &link->win);
+	if (ret)
+		goto failed;
 	mem.CardOffset = 0x0000;
 	mem.Page = 0;
-	CS_CHECK(MapMemPage, pcmcia_map_mem_page(link->win, &mem));
+	ret = pcmcia_map_mem_page(link->win, &mem);
+	if (ret)
+		goto failed;
 	local->sram = ioremap(req.Base, req.Size);
 
 /*** Set up 16k window for shared memory (receive buffer) ***************/
@@ -467,11 +454,14 @@ static int ray_config(struct pcmcia_device *link)
 	req.Base = 0;
 	req.Size = 0x4000;
 	req.AccessSpeed = ray_mem_speed;
-	CS_CHECK(RequestWindow,
-		 pcmcia_request_window(&link, &req, &local->rmem_handle));
+	ret = pcmcia_request_window(&link, &req, &local->rmem_handle);
+	if (ret)
+		goto failed;
 	mem.CardOffset = 0x8000;
 	mem.Page = 0;
-	CS_CHECK(MapMemPage, pcmcia_map_mem_page(local->rmem_handle, &mem));
+	ret = pcmcia_map_mem_page(local->rmem_handle, &mem);
+	if (ret)
+		goto failed;
 	local->rmem = ioremap(req.Base, req.Size);
 
 /*** Set up window for attribute memory ***********************************/
@@ -480,16 +470,19 @@ static int ray_config(struct pcmcia_device *link)
 	req.Base = 0;
 	req.Size = 0x1000;
 	req.AccessSpeed = ray_mem_speed;
-	CS_CHECK(RequestWindow,
-		 pcmcia_request_window(&link, &req, &local->amem_handle));
+	ret = pcmcia_request_window(&link, &req, &local->amem_handle);
+	if (ret)
+		goto failed;
 	mem.CardOffset = 0x0000;
 	mem.Page = 0;
-	CS_CHECK(MapMemPage, pcmcia_map_mem_page(local->amem_handle, &mem));
+	ret = pcmcia_map_mem_page(local->amem_handle, &mem);
+	if (ret)
+		goto failed;
 	local->amem = ioremap(req.Base, req.Size);
 
-	DEBUG(3, "ray_config sram=%p\n", local->sram);
-	DEBUG(3, "ray_config rmem=%p\n", local->rmem);
-	DEBUG(3, "ray_config amem=%p\n", local->amem);
+	dev_dbg(&link->dev, "ray_config sram=%p\n", local->sram);
+	dev_dbg(&link->dev, "ray_config rmem=%p\n", local->rmem);
+	dev_dbg(&link->dev, "ray_config amem=%p\n", local->amem);
 	if (ray_init(dev) < 0) {
 		ray_release(link);
 		return -ENODEV;
@@ -511,9 +504,7 @@ static int ray_config(struct pcmcia_device *link)
 
 	return 0;
 
-cs_failed:
-	cs_error(link, last_fn, last_ret);
-
+failed:
 	ray_release(link);
 	return -ENODEV;
 } /* ray_config */
@@ -543,9 +534,9 @@ static int ray_init(struct net_device *dev)
 	struct ccs __iomem *pccs;
 	ray_dev_t *local = netdev_priv(dev);
 	struct pcmcia_device *link = local->finder;
-	DEBUG(1, "ray_init(0x%p)\n", dev);
+	dev_dbg(&link->dev, "ray_init(0x%p)\n", dev);
 	if (!(pcmcia_dev_present(link))) {
-		DEBUG(0, "ray_init - device not present\n");
+		dev_dbg(&link->dev, "ray_init - device not present\n");
 		return -1;
 	}
 
@@ -567,13 +558,13 @@ static int ray_init(struct net_device *dev)
 	local->fw_ver = local->startup_res.firmware_version[0];
 	local->fw_bld = local->startup_res.firmware_version[1];
 	local->fw_var = local->startup_res.firmware_version[2];
-	DEBUG(1, "ray_init firmware version %d.%d \n", local->fw_ver,
+	dev_dbg(&link->dev, "ray_init firmware version %d.%d \n", local->fw_ver,
 	      local->fw_bld);
 
 	local->tib_length = 0x20;
 	if ((local->fw_ver == 5) && (local->fw_bld >= 30))
 		local->tib_length = local->startup_res.tib_length;
-	DEBUG(2, "ray_init tib_length = 0x%02x\n", local->tib_length);
+	dev_dbg(&link->dev, "ray_init tib_length = 0x%02x\n", local->tib_length);
 	/* Initialize CCS's to buffer free state */
 	pccs = ccs_base(local);
 	for (i = 0; i < NUMBER_OF_CCS; i++) {
@@ -592,7 +583,7 @@ static int ray_init(struct net_device *dev)
 
 	clear_interrupt(local);	/* Clear any interrupt from the card */
 	local->card_status = CARD_AWAITING_PARAM;
-	DEBUG(2, "ray_init ending\n");
+	dev_dbg(&link->dev, "ray_init ending\n");
 	return 0;
 } /* ray_init */
 
@@ -605,9 +596,9 @@ static int dl_startup_params(struct net_device *dev)
 	struct ccs __iomem *pccs;
 	struct pcmcia_device *link = local->finder;
 
-	DEBUG(1, "dl_startup_params entered\n");
+	dev_dbg(&link->dev, "dl_startup_params entered\n");
 	if (!(pcmcia_dev_present(link))) {
-		DEBUG(2, "ray_cs dl_startup_params - device not present\n");
+		dev_dbg(&link->dev, "ray_cs dl_startup_params - device not present\n");
 		return -1;
 	}
 
@@ -625,7 +616,7 @@ static int dl_startup_params(struct net_device *dev)
 	local->dl_param_ccs = ccsindex;
 	pccs = ccs_base(local) + ccsindex;
 	writeb(CCS_DOWNLOAD_STARTUP_PARAMS, &pccs->cmd);
-	DEBUG(2, "dl_startup_params start ccsindex = %d\n",
+	dev_dbg(&link->dev, "dl_startup_params start ccsindex = %d\n",
 	      local->dl_param_ccs);
 	/* Interrupt the firmware to process the command */
 	if (interrupt_ecf(local, ccsindex)) {
@@ -641,7 +632,7 @@ static int dl_startup_params(struct net_device *dev)
 	local->timer.data = (long)local;
 	local->timer.function = &verify_dl_startup;
 	add_timer(&local->timer);
-	DEBUG(2,
+	dev_dbg(&link->dev,
 	      "ray_cs dl_startup_params started timer for verify_dl_startup\n");
 	return 0;
 } /* dl_startup_params */
@@ -717,11 +708,11 @@ static void verify_dl_startup(u_long data)
 	struct pcmcia_device *link = local->finder;
 
 	if (!(pcmcia_dev_present(link))) {
-		DEBUG(2, "ray_cs verify_dl_startup - device not present\n");
+		dev_dbg(&link->dev, "ray_cs verify_dl_startup - device not present\n");
 		return;
 	}
-#ifdef PCMCIA_DEBUG
-	if (pc_debug > 2) {
+#if 0
+	{
 		int i;
 		printk(KERN_DEBUG
 		       "verify_dl_startup parameters sent via ccs %d:\n",
@@ -760,7 +751,7 @@ static void start_net(u_long data)
 	int ccsindex;
 	struct pcmcia_device *link = local->finder;
 	if (!(pcmcia_dev_present(link))) {
-		DEBUG(2, "ray_cs start_net - device not present\n");
+		dev_dbg(&link->dev, "ray_cs start_net - device not present\n");
 		return;
 	}
 	/* Fill in the CCS fields for the ECF */
@@ -771,7 +762,7 @@ static void start_net(u_long data)
 	writeb(0, &pccs->var.start_network.update_param);
 	/* Interrupt the firmware to process the command */
 	if (interrupt_ecf(local, ccsindex)) {
-		DEBUG(1, "ray start net failed - card not ready for intr\n");
+		dev_dbg(&link->dev, "ray start net failed - card not ready for intr\n");
 		writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
 		return;
 	}
@@ -790,7 +781,7 @@ static void join_net(u_long data)
 	struct pcmcia_device *link = local->finder;
 
 	if (!(pcmcia_dev_present(link))) {
-		DEBUG(2, "ray_cs join_net - device not present\n");
+		dev_dbg(&link->dev, "ray_cs join_net - device not present\n");
 		return;
 	}
 	/* Fill in the CCS fields for the ECF */
@@ -802,7 +793,7 @@ static void join_net(u_long data)
 	writeb(0, &pccs->var.join_network.net_initiated);
 	/* Interrupt the firmware to process the command */
 	if (interrupt_ecf(local, ccsindex)) {
-		DEBUG(1, "ray join net failed - card not ready for intr\n");
+		dev_dbg(&link->dev, "ray join net failed - card not ready for intr\n");
 		writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
 		return;
 	}
@@ -821,7 +812,7 @@ static void ray_release(struct pcmcia_device *link)
 	ray_dev_t *local = netdev_priv(dev);
 	int i;
 
-	DEBUG(1, "ray_release(0x%p)\n", link);
+	dev_dbg(&link->dev, "ray_release\n");
 
 	del_timer(&local->timer);
 
@@ -831,13 +822,13 @@ static void ray_release(struct pcmcia_device *link)
 	/* Do bother checking to see if these succeed or not */
 	i = pcmcia_release_window(local->amem_handle);
 	if (i != 0)
-		DEBUG(0, "ReleaseWindow(local->amem) ret = %x\n", i);
+		dev_dbg(&link->dev, "ReleaseWindow(local->amem) ret = %x\n", i);
 	i = pcmcia_release_window(local->rmem_handle);
 	if (i != 0)
-		DEBUG(0, "ReleaseWindow(local->rmem) ret = %x\n", i);
+		dev_dbg(&link->dev, "ReleaseWindow(local->rmem) ret = %x\n", i);
 	pcmcia_disable_device(link);
 
-	DEBUG(2, "ray_release ending\n");
+	dev_dbg(&link->dev, "ray_release ending\n");
 }
 
 static int ray_suspend(struct pcmcia_device *link)
@@ -871,9 +862,9 @@ static int ray_dev_init(struct net_device *dev)
 	ray_dev_t *local = netdev_priv(dev);
 	struct pcmcia_device *link = local->finder;
 
-	DEBUG(1, "ray_dev_init(dev=%p)\n", dev);
+	dev_dbg(&link->dev, "ray_dev_init(dev=%p)\n", dev);
 	if (!(pcmcia_dev_present(link))) {
-		DEBUG(2, "ray_dev_init - device not present\n");
+		dev_dbg(&link->dev, "ray_dev_init - device not present\n");
 		return -1;
 	}
 #ifdef RAY_IMMEDIATE_INIT
@@ -887,7 +878,7 @@ static int ray_dev_init(struct net_device *dev)
 	/* Postpone the card init so that we can still configure the card,
 	 * for example using the Wireless Extensions. The init will happen
 	 * in ray_open() - Jean II */
-	DEBUG(1,
+	dev_dbg(&link->dev,
 	      "ray_dev_init: postponing card init to ray_open() ; Status = %d\n",
 	      local->card_status);
 #endif /* RAY_IMMEDIATE_INIT */
@@ -896,7 +887,7 @@ static int ray_dev_init(struct net_device *dev)
 	memcpy(dev->dev_addr, &local->sparm.b4.a_mac_addr, ADDRLEN);
 	memset(dev->broadcast, 0xff, ETH_ALEN);
 
-	DEBUG(2, "ray_dev_init ending\n");
+	dev_dbg(&link->dev, "ray_dev_init ending\n");
 	return 0;
 }
 
@@ -906,9 +897,9 @@ static int ray_dev_config(struct net_device *dev, struct ifmap *map)
 	ray_dev_t *local = netdev_priv(dev);
 	struct pcmcia_device *link = local->finder;
 	/* Dummy routine to satisfy device structure */
-	DEBUG(1, "ray_dev_config(dev=%p,ifmap=%p)\n", dev, map);
+	dev_dbg(&link->dev, "ray_dev_config(dev=%p,ifmap=%p)\n", dev, map);
 	if (!(pcmcia_dev_present(link))) {
-		DEBUG(2, "ray_dev_config - device not present\n");
+		dev_dbg(&link->dev, "ray_dev_config - device not present\n");
 		return -1;
 	}
 
@@ -924,14 +915,14 @@ static netdev_tx_t ray_dev_start_xmit(struct sk_buff *skb,
 	short length = skb->len;
 
 	if (!pcmcia_dev_present(link)) {
-		DEBUG(2, "ray_dev_start_xmit - device not present\n");
+		dev_dbg(&link->dev, "ray_dev_start_xmit - device not present\n");
 		dev_kfree_skb(skb);
 		return NETDEV_TX_OK;
 	}
 
-	DEBUG(3, "ray_dev_start_xmit(skb=%p, dev=%p)\n", skb, dev);
+	dev_dbg(&link->dev, "ray_dev_start_xmit(skb=%p, dev=%p)\n", skb, dev);
 	if (local->authentication_state == NEED_TO_AUTH) {
-		DEBUG(0, "ray_cs Sending authentication request.\n");
+		dev_dbg(&link->dev, "ray_cs Sending authentication request.\n");
 		if (!build_auth_frame(local, local->auth_id, OPEN_AUTH_REQUEST)) {
 			local->authentication_state = AUTHENTICATED;
 			netif_stop_queue(dev);
@@ -971,7 +962,7 @@ static int ray_hw_xmit(unsigned char *data, int len, struct net_device *dev,
 	struct tx_msg __iomem *ptx;	/* Address of xmit buffer in PC space */
 	short int addr;		/* Address of xmit buffer in card space */
 
-	DEBUG(3, "ray_hw_xmit(data=%p, len=%d, dev=%p)\n", data, len, dev);
+	pr_debug("ray_hw_xmit(data=%p, len=%d, dev=%p)\n", data, len, dev);
 	if (len + TX_HEADER_LENGTH > TX_BUF_SIZE) {
 		printk(KERN_INFO "ray_hw_xmit packet too large: %d bytes\n",
 		       len);
@@ -979,9 +970,9 @@ static int ray_hw_xmit(unsigned char *data, int len, struct net_device *dev,
 	}
 	switch (ccsindex = get_free_tx_ccs(local)) {
 	case ECCSBUSY:
-		DEBUG(2, "ray_hw_xmit tx_ccs table busy\n");
+		pr_debug("ray_hw_xmit tx_ccs table busy\n");
 	case ECCSFULL:
-		DEBUG(2, "ray_hw_xmit No free tx ccs\n");
+		pr_debug("ray_hw_xmit No free tx ccs\n");
 	case ECARDGONE:
 		netif_stop_queue(dev);
 		return XMIT_NO_CCS;
@@ -1018,12 +1009,12 @@ static int ray_hw_xmit(unsigned char *data, int len, struct net_device *dev,
 	writeb(PSM_CAM, &pccs->var.tx_request.pow_sav_mode);
 	writeb(local->net_default_tx_rate, &pccs->var.tx_request.tx_rate);
 	writeb(0, &pccs->var.tx_request.antenna);
-	DEBUG(3, "ray_hw_xmit default_tx_rate = 0x%x\n",
+	pr_debug("ray_hw_xmit default_tx_rate = 0x%x\n",
 	      local->net_default_tx_rate);
 
 	/* Interrupt the firmware to process the command */
 	if (interrupt_ecf(local, ccsindex)) {
-		DEBUG(2, "ray_hw_xmit failed - ECF not ready for intr\n");
+		pr_debug("ray_hw_xmit failed - ECF not ready for intr\n");
 /* TBD very inefficient to copy packet to buffer, and then not
    send it, but the alternative is to queue the messages and that
    won't be done for a while.  Maybe set tbusy until a CCS is free?
@@ -1040,7 +1031,7 @@ static int translate_frame(ray_dev_t *local, struct tx_msg __iomem *ptx,
 {
 	__be16 proto = ((struct ethhdr *)data)->h_proto;
 	if (ntohs(proto) >= 1536) { /* DIX II ethernet frame */
-		DEBUG(3, "ray_cs translate_frame DIX II\n");
+		pr_debug("ray_cs translate_frame DIX II\n");
 		/* Copy LLC header to card buffer */
 		memcpy_toio(&ptx->var, eth2_llc, sizeof(eth2_llc));
 		memcpy_toio(((void __iomem *)&ptx->var) + sizeof(eth2_llc),
@@ -1056,9 +1047,9 @@ static int translate_frame(ray_dev_t *local, struct tx_msg __iomem *ptx,
 			    len - ETH_HLEN);
 		return (int)sizeof(struct snaphdr_t) - ETH_HLEN;
 	} else { /* already  802 type, and proto is length */
-		DEBUG(3, "ray_cs translate_frame 802\n");
+		pr_debug("ray_cs translate_frame 802\n");
 		if (proto == htons(0xffff)) { /* evil netware IPX 802.3 without LLC */
-			DEBUG(3, "ray_cs translate_frame evil IPX\n");
+			pr_debug("ray_cs translate_frame evil IPX\n");
 			memcpy_toio(&ptx->var, data + ETH_HLEN, len - ETH_HLEN);
 			return 0 - ETH_HLEN;
 		}
@@ -1603,7 +1594,7 @@ static int ray_open(struct net_device *dev)
 	struct pcmcia_device *link;
 	link = local->finder;
 
-	DEBUG(1, "ray_open('%s')\n", dev->name);
+	dev_dbg(&link->dev, "ray_open('%s')\n", dev->name);
 
 	if (link->open == 0)
 		local->num_multi = 0;
@@ -1613,7 +1604,7 @@ static int ray_open(struct net_device *dev)
 	if (local->card_status == CARD_AWAITING_PARAM) {
 		int i;
 
-		DEBUG(1, "ray_open: doing init now !\n");
+		dev_dbg(&link->dev, "ray_open: doing init now !\n");
 
 		/* Download startup parameters */
 		if ((i = dl_startup_params(dev)) < 0) {
@@ -1629,7 +1620,7 @@ static int ray_open(struct net_device *dev)
 	else
 		netif_start_queue(dev);
 
-	DEBUG(2, "ray_open ending\n");
+	dev_dbg(&link->dev, "ray_open ending\n");
 	return 0;
 } /* end ray_open */
 
@@ -1640,7 +1631,7 @@ static int ray_dev_close(struct net_device *dev)
 	struct pcmcia_device *link;
 	link = local->finder;
 
-	DEBUG(1, "ray_dev_close('%s')\n", dev->name);
+	dev_dbg(&link->dev, "ray_dev_close('%s')\n", dev->name);
 
 	link->open--;
 	netif_stop_queue(dev);
@@ -1656,7 +1647,7 @@ static int ray_dev_close(struct net_device *dev)
 /*===========================================================================*/
 static void ray_reset(struct net_device *dev)
 {
-	DEBUG(1, "ray_reset entered\n");
+	pr_debug("ray_reset entered\n");
 	return;
 }
 
@@ -1669,17 +1660,17 @@ static int interrupt_ecf(ray_dev_t *local, int ccs)
 	struct pcmcia_device *link = local->finder;
 
 	if (!(pcmcia_dev_present(link))) {
-		DEBUG(2, "ray_cs interrupt_ecf - device not present\n");
+		dev_dbg(&link->dev, "ray_cs interrupt_ecf - device not present\n");
 		return -1;
 	}
-	DEBUG(2, "interrupt_ecf(local=%p, ccs = 0x%x\n", local, ccs);
+	dev_dbg(&link->dev, "interrupt_ecf(local=%p, ccs = 0x%x\n", local, ccs);
 
 	while (i &&
 	       (readb(local->amem + CIS_OFFSET + ECF_INTR_OFFSET) &
 		ECF_INTR_SET))
 		i--;
 	if (i == 0) {
-		DEBUG(2, "ray_cs interrupt_ecf card not ready for interrupt\n");
+		dev_dbg(&link->dev, "ray_cs interrupt_ecf card not ready for interrupt\n");
 		return -1;
 	}
 	/* Fill the mailbox, then kick the card */
@@ -1698,12 +1689,12 @@ static int get_free_tx_ccs(ray_dev_t *local)
 	struct pcmcia_device *link = local->finder;
 
 	if (!(pcmcia_dev_present(link))) {
-		DEBUG(2, "ray_cs get_free_tx_ccs - device not present\n");
+		dev_dbg(&link->dev, "ray_cs get_free_tx_ccs - device not present\n");
 		return ECARDGONE;
 	}
 
 	if (test_and_set_bit(0, &local->tx_ccs_lock)) {
-		DEBUG(1, "ray_cs tx_ccs_lock busy\n");
+		dev_dbg(&link->dev, "ray_cs tx_ccs_lock busy\n");
 		return ECCSBUSY;
 	}
 
@@ -1716,7 +1707,7 @@ static int get_free_tx_ccs(ray_dev_t *local)
 		}
 	}
 	local->tx_ccs_lock = 0;
-	DEBUG(2, "ray_cs ERROR no free tx CCS for raylink card\n");
+	dev_dbg(&link->dev, "ray_cs ERROR no free tx CCS for raylink card\n");
 	return ECCSFULL;
 } /* get_free_tx_ccs */
 
@@ -1730,11 +1721,11 @@ static int get_free_ccs(ray_dev_t *local)
 	struct pcmcia_device *link = local->finder;
 
 	if (!(pcmcia_dev_present(link))) {
-		DEBUG(2, "ray_cs get_free_ccs - device not present\n");
+		dev_dbg(&link->dev, "ray_cs get_free_ccs - device not present\n");
 		return ECARDGONE;
 	}
 	if (test_and_set_bit(0, &local->ccs_lock)) {
-		DEBUG(1, "ray_cs ccs_lock busy\n");
+		dev_dbg(&link->dev, "ray_cs ccs_lock busy\n");
 		return ECCSBUSY;
 	}
 
@@ -1747,7 +1738,7 @@ static int get_free_ccs(ray_dev_t *local)
 		}
 	}
 	local->ccs_lock = 0;
-	DEBUG(1, "ray_cs ERROR no free CCS for raylink card\n");
+	dev_dbg(&link->dev, "ray_cs ERROR no free CCS for raylink card\n");
 	return ECCSFULL;
 } /* get_free_ccs */
 
@@ -1823,7 +1814,7 @@ static struct net_device_stats *ray_get_stats(struct net_device *dev)
 	struct pcmcia_device *link = local->finder;
 	struct status __iomem *p = local->sram + STATUS_BASE;
 	if (!(pcmcia_dev_present(link))) {
-		DEBUG(2, "ray_cs net_device_stats - device not present\n");
+		dev_dbg(&link->dev, "ray_cs net_device_stats - device not present\n");
 		return &local->stats;
 	}
 	if (readb(&p->mrx_overflow_for_host)) {
@@ -1856,12 +1847,12 @@ static void ray_update_parm(struct net_device *dev, UCHAR objid, UCHAR *value,
 	struct ccs __iomem *pccs;
 
 	if (!(pcmcia_dev_present(link))) {
-		DEBUG(2, "ray_update_parm - device not present\n");
+		dev_dbg(&link->dev, "ray_update_parm - device not present\n");
 		return;
 	}
 
 	if ((ccsindex = get_free_ccs(local)) < 0) {
-		DEBUG(0, "ray_update_parm - No free ccs\n");
+		dev_dbg(&link->dev, "ray_update_parm - No free ccs\n");
 		return;
 	}
 	pccs = ccs_base(local) + ccsindex;
@@ -1874,7 +1865,7 @@ static void ray_update_parm(struct net_device *dev, UCHAR objid, UCHAR *value,
 	}
 	/* Interrupt the firmware to process the command */
 	if (interrupt_ecf(local, ccsindex)) {
-		DEBUG(0, "ray_cs associate failed - ECF not ready for intr\n");
+		dev_dbg(&link->dev, "ray_cs associate failed - ECF not ready for intr\n");
 		writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
 	}
 }
@@ -1891,12 +1882,12 @@ static void ray_update_multi_list(struct net_device *dev, int all)
 	void __iomem *p = local->sram + HOST_TO_ECF_BASE;
 
 	if (!(pcmcia_dev_present(link))) {
-		DEBUG(2, "ray_update_multi_list - device not present\n");
+		dev_dbg(&link->dev, "ray_update_multi_list - device not present\n");
 		return;
 	} else
-		DEBUG(2, "ray_update_multi_list(%p)\n", dev);
+		dev_dbg(&link->dev, "ray_update_multi_list(%p)\n", dev);
 	if ((ccsindex = get_free_ccs(local)) < 0) {
-		DEBUG(1, "ray_update_multi - No free ccs\n");
+		dev_dbg(&link->dev, "ray_update_multi - No free ccs\n");
 		return;
 	}
 	pccs = ccs_base(local) + ccsindex;
@@ -1910,7 +1901,7 @@ static void ray_update_multi_list(struct net_device *dev, int all)
 		for (dmip = &dev->mc_list; (dmi = *dmip) != NULL;
 		     dmip = &dmi->next) {
 			memcpy_toio(p, dmi->dmi_addr, ETH_ALEN);
-			DEBUG(1,
+			dev_dbg(&link->dev,
 			      "ray_update_multi add addr %02x%02x%02x%02x%02x%02x\n",
 			      dmi->dmi_addr[0], dmi->dmi_addr[1],
 			      dmi->dmi_addr[2], dmi->dmi_addr[3],
@@ -1921,12 +1912,12 @@ static void ray_update_multi_list(struct net_device *dev, int all)
 		if (i > 256 / ADDRLEN)
 			i = 256 / ADDRLEN;
 		writeb((UCHAR) i, &pccs->var);
-		DEBUG(1, "ray_cs update_multi %d addresses in list\n", i);
+		dev_dbg(&link->dev, "ray_cs update_multi %d addresses in list\n", i);
 		/* Interrupt the firmware to process the command */
 		local->num_multi = i;
 	}
 	if (interrupt_ecf(local, ccsindex)) {
-		DEBUG(1,
+		dev_dbg(&link->dev,
 		      "ray_cs update_multi failed - ECF not ready for intr\n");
 		writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
 	}
@@ -1938,11 +1929,11 @@ static void set_multicast_list(struct net_device *dev)
 	ray_dev_t *local = netdev_priv(dev);
 	UCHAR promisc;
 
-	DEBUG(2, "ray_cs set_multicast_list(%p)\n", dev);
+	pr_debug("ray_cs set_multicast_list(%p)\n", dev);
 
 	if (dev->flags & IFF_PROMISC) {
 		if (local->sparm.b5.a_promiscuous_mode == 0) {
-			DEBUG(1, "ray_cs set_multicast_list promisc on\n");
+			pr_debug("ray_cs set_multicast_list promisc on\n");
 			local->sparm.b5.a_promiscuous_mode = 1;
 			promisc = 1;
 			ray_update_parm(dev, OBJID_promiscuous_mode,
@@ -1950,7 +1941,7 @@ static void set_multicast_list(struct net_device *dev)
 		}
 	} else {
 		if (local->sparm.b5.a_promiscuous_mode == 1) {
-			DEBUG(1, "ray_cs set_multicast_list promisc off\n");
+			pr_debug("ray_cs set_multicast_list promisc off\n");
 			local->sparm.b5.a_promiscuous_mode = 0;
 			promisc = 0;
 			ray_update_parm(dev, OBJID_promiscuous_mode,
@@ -1984,19 +1975,19 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 	if (dev == NULL)	/* Note that we want interrupts with dev->start == 0 */
 		return IRQ_NONE;
 
-	DEBUG(4, "ray_cs: interrupt for *dev=%p\n", dev);
+	pr_debug("ray_cs: interrupt for *dev=%p\n", dev);
 
 	local = netdev_priv(dev);
 	link = (struct pcmcia_device *)local->finder;
 	if (!pcmcia_dev_present(link)) {
-		DEBUG(2,
-		      "ray_cs interrupt from device not present or suspended.\n");
+		pr_debug(
+			"ray_cs interrupt from device not present or suspended.\n");
 		return IRQ_NONE;
 	}
 	rcsindex = readb(&((struct scb __iomem *)(local->sram))->rcs_index);
 
 	if (rcsindex >= (NUMBER_OF_CCS + NUMBER_OF_RCS)) {
-		DEBUG(1, "ray_cs interrupt bad rcsindex = 0x%x\n", rcsindex);
+		dev_dbg(&link->dev, "ray_cs interrupt bad rcsindex = 0x%x\n", rcsindex);
 		clear_interrupt(local);
 		return IRQ_HANDLED;
 	}
@@ -2008,33 +1999,33 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 		case CCS_DOWNLOAD_STARTUP_PARAMS:	/* Happens in firmware someday */
 			del_timer(&local->timer);
 			if (status == CCS_COMMAND_COMPLETE) {
-				DEBUG(1,
+				dev_dbg(&link->dev,
 				      "ray_cs interrupt download_startup_parameters OK\n");
 			} else {
-				DEBUG(1,
+				dev_dbg(&link->dev,
 				      "ray_cs interrupt download_startup_parameters fail\n");
 			}
 			break;
 		case CCS_UPDATE_PARAMS:
-			DEBUG(1, "ray_cs interrupt update params done\n");
+			dev_dbg(&link->dev, "ray_cs interrupt update params done\n");
 			if (status != CCS_COMMAND_COMPLETE) {
 				tmp =
 				    readb(&pccs->var.update_param.
 					  failure_cause);
-				DEBUG(0,
+				dev_dbg(&link->dev,
 				      "ray_cs interrupt update params failed - reason %d\n",
 				      tmp);
 			}
 			break;
 		case CCS_REPORT_PARAMS:
-			DEBUG(1, "ray_cs interrupt report params done\n");
+			dev_dbg(&link->dev, "ray_cs interrupt report params done\n");
 			break;
 		case CCS_UPDATE_MULTICAST_LIST:	/* Note that this CCS isn't returned */
-			DEBUG(1,
+			dev_dbg(&link->dev,
 			      "ray_cs interrupt CCS Update Multicast List done\n");
 			break;
 		case CCS_UPDATE_POWER_SAVINGS_MODE:
-			DEBUG(1,
+			dev_dbg(&link->dev,
 			      "ray_cs interrupt update power save mode done\n");
 			break;
 		case CCS_START_NETWORK:
@@ -2043,11 +2034,11 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 				if (readb
 				    (&pccs->var.start_network.net_initiated) ==
 				    1) {
-					DEBUG(0,
+					dev_dbg(&link->dev,
 					      "ray_cs interrupt network \"%s\" started\n",
 					      local->sparm.b4.a_current_ess_id);
 				} else {
-					DEBUG(0,
+					dev_dbg(&link->dev,
 					      "ray_cs interrupt network \"%s\" joined\n",
 					      local->sparm.b4.a_current_ess_id);
 				}
@@ -2075,12 +2066,12 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 				local->timer.expires = jiffies + HZ * 5;
 				local->timer.data = (long)local;
 				if (status == CCS_START_NETWORK) {
-					DEBUG(0,
+					dev_dbg(&link->dev,
 					      "ray_cs interrupt network \"%s\" start failed\n",
 					      local->sparm.b4.a_current_ess_id);
 					local->timer.function = &start_net;
 				} else {
-					DEBUG(0,
+					dev_dbg(&link->dev,
 					      "ray_cs interrupt network \"%s\" join failed\n",
 					      local->sparm.b4.a_current_ess_id);
 					local->timer.function = &join_net;
@@ -2091,19 +2082,19 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 		case CCS_START_ASSOCIATION:
 			if (status == CCS_COMMAND_COMPLETE) {
 				local->card_status = CARD_ASSOC_COMPLETE;
-				DEBUG(0, "ray_cs association successful\n");
+				dev_dbg(&link->dev, "ray_cs association successful\n");
 			} else {
-				DEBUG(0, "ray_cs association failed,\n");
+				dev_dbg(&link->dev, "ray_cs association failed,\n");
 				local->card_status = CARD_ASSOC_FAILED;
 				join_net((u_long) local);
 			}
 			break;
 		case CCS_TX_REQUEST:
 			if (status == CCS_COMMAND_COMPLETE) {
-				DEBUG(3,
+				dev_dbg(&link->dev,
 				      "ray_cs interrupt tx request complete\n");
 			} else {
-				DEBUG(1,
+				dev_dbg(&link->dev,
 				      "ray_cs interrupt tx request failed\n");
 			}
 			if (!sniffer)
@@ -2111,21 +2102,21 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 			netif_wake_queue(dev);
 			break;
 		case CCS_TEST_MEMORY:
-			DEBUG(1, "ray_cs interrupt mem test done\n");
+			dev_dbg(&link->dev, "ray_cs interrupt mem test done\n");
 			break;
 		case CCS_SHUTDOWN:
-			DEBUG(1,
+			dev_dbg(&link->dev,
 			      "ray_cs interrupt Unexpected CCS returned - Shutdown\n");
 			break;
 		case CCS_DUMP_MEMORY:
-			DEBUG(1, "ray_cs interrupt dump memory done\n");
+			dev_dbg(&link->dev, "ray_cs interrupt dump memory done\n");
 			break;
 		case CCS_START_TIMER:
-			DEBUG(2,
+			dev_dbg(&link->dev,
 			      "ray_cs interrupt DING - raylink timer expired\n");
 			break;
 		default:
-			DEBUG(1,
+			dev_dbg(&link->dev,
 			      "ray_cs interrupt Unexpected CCS 0x%x returned 0x%x\n",
 			      rcsindex, cmd);
 		}
@@ -2139,7 +2130,7 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 			ray_rx(dev, local, prcs);
 			break;
 		case REJOIN_NET_COMPLETE:
-			DEBUG(1, "ray_cs interrupt rejoin net complete\n");
+			dev_dbg(&link->dev, "ray_cs interrupt rejoin net complete\n");
 			local->card_status = CARD_ACQ_COMPLETE;
 			/* do we need to clear tx buffers CCS's? */
 			if (local->sparm.b4.a_network_type == ADHOC) {
@@ -2149,7 +2140,7 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 				memcpy_fromio(&local->bss_id,
 					      prcs->var.rejoin_net_complete.
 					      bssid, ADDRLEN);
-				DEBUG(1,
+				dev_dbg(&link->dev,
 				      "ray_cs new BSSID = %02x%02x%02x%02x%02x%02x\n",
 				      local->bss_id[0], local->bss_id[1],
 				      local->bss_id[2], local->bss_id[3],
@@ -2159,15 +2150,15 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 			}
 			break;
 		case ROAMING_INITIATED:
-			DEBUG(1, "ray_cs interrupt roaming initiated\n");
+			dev_dbg(&link->dev, "ray_cs interrupt roaming initiated\n");
 			netif_stop_queue(dev);
 			local->card_status = CARD_DOING_ACQ;
 			break;
 		case JAPAN_CALL_SIGN_RXD:
-			DEBUG(1, "ray_cs interrupt japan call sign rx\n");
+			dev_dbg(&link->dev, "ray_cs interrupt japan call sign rx\n");
 			break;
 		default:
-			DEBUG(1,
+			dev_dbg(&link->dev,
 			      "ray_cs Unexpected interrupt for RCS 0x%x cmd = 0x%x\n",
 			      rcsindex,
 			      (unsigned int)readb(&prcs->interrupt_id));
@@ -2186,7 +2177,7 @@ static void ray_rx(struct net_device *dev, ray_dev_t *local,
 	int rx_len;
 	unsigned int pkt_addr;
 	void __iomem *pmsg;
-	DEBUG(4, "ray_rx process rx packet\n");
+	pr_debug("ray_rx process rx packet\n");
 
 	/* Calculate address of packet within Rx buffer */
 	pkt_addr = ((readb(&prcs->var.rx_packet.rx_data_ptr[0]) << 8)
@@ -2199,28 +2190,28 @@ static void ray_rx(struct net_device *dev, ray_dev_t *local,
 	pmsg = local->rmem + pkt_addr;
 	switch (readb(pmsg)) {
 	case DATA_TYPE:
-		DEBUG(4, "ray_rx data type\n");
+		pr_debug("ray_rx data type\n");
 		rx_data(dev, prcs, pkt_addr, rx_len);
 		break;
 	case AUTHENTIC_TYPE:
-		DEBUG(4, "ray_rx authentic type\n");
+		pr_debug("ray_rx authentic type\n");
 		if (sniffer)
 			rx_data(dev, prcs, pkt_addr, rx_len);
 		else
 			rx_authenticate(local, prcs, pkt_addr, rx_len);
 		break;
 	case DEAUTHENTIC_TYPE:
-		DEBUG(4, "ray_rx deauth type\n");
+		pr_debug("ray_rx deauth type\n");
 		if (sniffer)
 			rx_data(dev, prcs, pkt_addr, rx_len);
 		else
 			rx_deauthenticate(local, prcs, pkt_addr, rx_len);
 		break;
 	case NULL_MSG_TYPE:
-		DEBUG(3, "ray_cs rx NULL msg\n");
+		pr_debug("ray_cs rx NULL msg\n");
 		break;
 	case BEACON_TYPE:
-		DEBUG(4, "ray_rx beacon type\n");
+		pr_debug("ray_rx beacon type\n");
 		if (sniffer)
 			rx_data(dev, prcs, pkt_addr, rx_len);
 
@@ -2233,7 +2224,7 @@ static void ray_rx(struct net_device *dev, ray_dev_t *local,
 		ray_get_stats(dev);
 		break;
 	default:
-		DEBUG(0, "ray_cs unknown pkt type %2x\n",
+		pr_debug("ray_cs unknown pkt type %2x\n",
 		      (unsigned int)readb(pmsg));
 		break;
 	}
@@ -2262,7 +2253,7 @@ static void rx_data(struct net_device *dev, struct rcs __iomem *prcs,
 			    rx_len >
 			    (dev->mtu + RX_MAC_HEADER_LENGTH + ETH_HLEN +
 			     FCS_LEN)) {
-				DEBUG(0,
+				pr_debug(
 				      "ray_cs invalid packet length %d received \n",
 				      rx_len);
 				return;
@@ -2273,17 +2264,17 @@ static void rx_data(struct net_device *dev, struct rcs __iomem *prcs,
 			    rx_len >
 			    (dev->mtu + RX_MAC_HEADER_LENGTH + ETH_HLEN +
 			     FCS_LEN)) {
-				DEBUG(0,
+				pr_debug(
 				      "ray_cs invalid packet length %d received \n",
 				      rx_len);
 				return;
 			}
 		}
 	}
-	DEBUG(4, "ray_cs rx_data packet\n");
+	pr_debug("ray_cs rx_data packet\n");
 	/* If fragmented packet, verify sizes of fragments add up */
 	if (readb(&prcs->var.rx_packet.next_frag_rcs_index) != 0xFF) {
-		DEBUG(1, "ray_cs rx'ed fragment\n");
+		pr_debug("ray_cs rx'ed fragment\n");
 		tmp = (readb(&prcs->var.rx_packet.totalpacketlength[0]) << 8)
 		    + readb(&prcs->var.rx_packet.totalpacketlength[1]);
 		total_len = tmp;
@@ -2301,7 +2292,7 @@ static void rx_data(struct net_device *dev, struct rcs __iomem *prcs,
 		} while (1);
 
 		if (tmp < 0) {
-			DEBUG(0,
+			pr_debug(
 			      "ray_cs rx_data fragment lengths don't add up\n");
 			local->stats.rx_dropped++;
 			release_frag_chain(local, prcs);
@@ -2313,7 +2304,7 @@ static void rx_data(struct net_device *dev, struct rcs __iomem *prcs,
 
 	skb = dev_alloc_skb(total_len + 5);
 	if (skb == NULL) {
-		DEBUG(0, "ray_cs rx_data could not allocate skb\n");
+		pr_debug("ray_cs rx_data could not allocate skb\n");
 		local->stats.rx_dropped++;
 		if (readb(&prcs->var.rx_packet.next_frag_rcs_index) != 0xFF)
 			release_frag_chain(local, prcs);
@@ -2321,7 +2312,7 @@ static void rx_data(struct net_device *dev, struct rcs __iomem *prcs,
 	}
 	skb_reserve(skb, 2);	/* Align IP on 16 byte (TBD check this) */
 
-	DEBUG(4, "ray_cs rx_data total_len = %x, rx_len = %x\n", total_len,
+	pr_debug("ray_cs rx_data total_len = %x, rx_len = %x\n", total_len,
 	      rx_len);
 
 /************************/
@@ -2354,7 +2345,7 @@ static void rx_data(struct net_device *dev, struct rcs __iomem *prcs,
 	tmp = 17;
 	if (readb(&prcs->var.rx_packet.next_frag_rcs_index) != 0xFF) {
 		prcslink = prcs;
-		DEBUG(1, "ray_cs rx_data in fragment loop\n");
+		pr_debug("ray_cs rx_data in fragment loop\n");
 		do {
 			prcslink = rcs_base(local)
 			    +
@@ -2426,8 +2417,8 @@ static void untranslate(ray_dev_t *local, struct sk_buff *skb, int len)
 	memcpy(destaddr, ieee80211_get_DA(pmac), ADDRLEN);
 	memcpy(srcaddr, ieee80211_get_SA(pmac), ADDRLEN);
 
-#ifdef PCMCIA_DEBUG
-	if (pc_debug > 3) {
+#if 0
+	if {
 		print_hex_dump(KERN_DEBUG, "skb->data before untranslate: ",
 			       DUMP_PREFIX_NONE, 16, 1,
 			       skb->data, 64, true);
@@ -2441,7 +2432,7 @@ static void untranslate(ray_dev_t *local, struct sk_buff *skb, int len)
 
 	if (psnap->dsap != 0xaa || psnap->ssap != 0xaa || psnap->ctrl != 3) {
 		/* not a snap type so leave it alone */
-		DEBUG(3, "ray_cs untranslate NOT SNAP %02x %02x %02x\n",
+		pr_debug("ray_cs untranslate NOT SNAP %02x %02x %02x\n",
 		      psnap->dsap, psnap->ssap, psnap->ctrl);
 
 		delta = RX_MAC_HEADER_LENGTH - ETH_HLEN;
@@ -2450,7 +2441,7 @@ static void untranslate(ray_dev_t *local, struct sk_buff *skb, int len)
 	} else { /* Its a SNAP */
 		if (memcmp(psnap->org, org_bridge, 3) == 0) {
 		/* EtherII and nuke the LLC */
-			DEBUG(3, "ray_cs untranslate Bridge encap\n");
+			pr_debug("ray_cs untranslate Bridge encap\n");
 			delta = RX_MAC_HEADER_LENGTH
 			    + sizeof(struct snaphdr_t) - ETH_HLEN;
 			peth = (struct ethhdr *)(skb->data + delta);
@@ -2459,14 +2450,14 @@ static void untranslate(ray_dev_t *local, struct sk_buff *skb, int len)
 			switch (ntohs(type)) {
 			case ETH_P_IPX:
 			case ETH_P_AARP:
-				DEBUG(3, "ray_cs untranslate RFC IPX/AARP\n");
+				pr_debug("ray_cs untranslate RFC IPX/AARP\n");
 				delta = RX_MAC_HEADER_LENGTH - ETH_HLEN;
 				peth = (struct ethhdr *)(skb->data + delta);
 				peth->h_proto =
 				    htons(len - RX_MAC_HEADER_LENGTH);
 				break;
 			default:
-				DEBUG(3, "ray_cs untranslate RFC default\n");
+				pr_debug("ray_cs untranslate RFC default\n");
 				delta = RX_MAC_HEADER_LENGTH +
 				    sizeof(struct snaphdr_t) - ETH_HLEN;
 				peth = (struct ethhdr *)(skb->data + delta);
@@ -2482,12 +2473,12 @@ static void untranslate(ray_dev_t *local, struct sk_buff *skb, int len)
 	}
 /* TBD reserve  skb_reserve(skb, delta); */
 	skb_pull(skb, delta);
-	DEBUG(3, "untranslate after skb_pull(%d), skb->data = %p\n", delta,
+	pr_debug("untranslate after skb_pull(%d), skb->data = %p\n", delta,
 	      skb->data);
 	memcpy(peth->h_dest, destaddr, ADDRLEN);
 	memcpy(peth->h_source, srcaddr, ADDRLEN);
-#ifdef PCMCIA_DEBUG
-	if (pc_debug > 3) {
+#if 0
+	{
 		int i;
 		printk(KERN_DEBUG "skb->data after untranslate:");
 		for (i = 0; i < 64; i++)
@@ -2529,7 +2520,7 @@ static void release_frag_chain(ray_dev_t *local, struct rcs __iomem *prcs)
 	while (tmp--) {
 		writeb(CCS_BUFFER_FREE, &prcslink->buffer_status);
 		if (rcsindex >= (NUMBER_OF_CCS + NUMBER_OF_RCS)) {
-			DEBUG(1, "ray_cs interrupt bad rcsindex = 0x%x\n",
+			pr_debug("ray_cs interrupt bad rcsindex = 0x%x\n",
 			      rcsindex);
 			break;
 		}
@@ -2543,9 +2534,9 @@ static void release_frag_chain(ray_dev_t *local, struct rcs __iomem *prcs)
 static void authenticate(ray_dev_t *local)
 {
 	struct pcmcia_device *link = local->finder;
-	DEBUG(0, "ray_cs Starting authentication.\n");
+	dev_dbg(&link->dev, "ray_cs Starting authentication.\n");
 	if (!(pcmcia_dev_present(link))) {
-		DEBUG(2, "ray_cs authenticate - device not present\n");
+		dev_dbg(&link->dev, "ray_cs authenticate - device not present\n");
 		return;
 	}
 
@@ -2573,11 +2564,11 @@ static void rx_authenticate(ray_dev_t *local, struct rcs __iomem *prcs,
 	copy_from_rx_buff(local, buff, pkt_addr, rx_len & 0xff);
 	/* if we are trying to get authenticated */
 	if (local->sparm.b4.a_network_type == ADHOC) {
-		DEBUG(1, "ray_cs rx_auth var= %02x %02x %02x %02x %02x %02x\n",
+		pr_debug("ray_cs rx_auth var= %02x %02x %02x %02x %02x %02x\n",
 		      msg->var[0], msg->var[1], msg->var[2], msg->var[3],
 		      msg->var[4], msg->var[5]);
 		if (msg->var[2] == 1) {
-			DEBUG(0, "ray_cs Sending authentication response.\n");
+			pr_debug("ray_cs Sending authentication response.\n");
 			if (!build_auth_frame
 			    (local, msg->mac.addr_2, OPEN_AUTH_RESPONSE)) {
 				local->authentication_state = NEED_TO_AUTH;
@@ -2591,13 +2582,13 @@ static void rx_authenticate(ray_dev_t *local, struct rcs __iomem *prcs,
 			/* Verify authentication sequence #2 and success */
 			if (msg->var[2] == 2) {
 				if ((msg->var[3] | msg->var[4]) == 0) {
-					DEBUG(1, "Authentication successful\n");
+					pr_debug("Authentication successful\n");
 					local->card_status = CARD_AUTH_COMPLETE;
 					associate(local);
 					local->authentication_state =
 					    AUTHENTICATED;
 				} else {
-					DEBUG(0, "Authentication refused\n");
+					pr_debug("Authentication refused\n");
 					local->card_status = CARD_AUTH_REFUSED;
 					join_net((u_long) local);
 					local->authentication_state =
@@ -2617,22 +2608,22 @@ static void associate(ray_dev_t *local)
 	struct net_device *dev = link->priv;
 	int ccsindex;
 	if (!(pcmcia_dev_present(link))) {
-		DEBUG(2, "ray_cs associate - device not present\n");
+		dev_dbg(&link->dev, "ray_cs associate - device not present\n");
 		return;
 	}
 	/* If no tx buffers available, return */
 	if ((ccsindex = get_free_ccs(local)) < 0) {
 /* TBD should never be here but... what if we are? */
-		DEBUG(1, "ray_cs associate - No free ccs\n");
+		dev_dbg(&link->dev, "ray_cs associate - No free ccs\n");
 		return;
 	}
-	DEBUG(1, "ray_cs Starting association with access point\n");
+	dev_dbg(&link->dev, "ray_cs Starting association with access point\n");
 	pccs = ccs_base(local) + ccsindex;
 	/* fill in the CCS */
 	writeb(CCS_START_ASSOCIATION, &pccs->cmd);
 	/* Interrupt the firmware to process the command */
 	if (interrupt_ecf(local, ccsindex)) {
-		DEBUG(1, "ray_cs associate failed - ECF not ready for intr\n");
+		dev_dbg(&link->dev, "ray_cs associate failed - ECF not ready for intr\n");
 		writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
 
 		del_timer(&local->timer);
@@ -2655,7 +2646,7 @@ static void rx_deauthenticate(ray_dev_t *local, struct rcs __iomem *prcs,
 /*  UCHAR buff[256];
     struct rx_msg *msg = (struct rx_msg *)buff;
 */
-	DEBUG(0, "Deauthentication frame received\n");
+	pr_debug("Deauthentication frame received\n");
 	local->authentication_state = UNAUTHENTICATED;
 	/* Need to reauthenticate or rejoin depending on reason code */
 /*  copy_from_rx_buff(local, buff, pkt_addr, rx_len & 0xff);
@@ -2823,7 +2814,7 @@ static int build_auth_frame(ray_dev_t *local, UCHAR *dest, int auth_type)
 
 	/* If no tx buffers available, return */
 	if ((ccsindex = get_free_tx_ccs(local)) < 0) {
-		DEBUG(1, "ray_cs send authenticate - No free tx ccs\n");
+		pr_debug("ray_cs send authenticate - No free tx ccs\n");
 		return -1;
 	}
 
@@ -2855,7 +2846,7 @@ static int build_auth_frame(ray_dev_t *local, UCHAR *dest, int auth_type)
 
 	/* Interrupt the firmware to process the command */
 	if (interrupt_ecf(local, ccsindex)) {
-		DEBUG(1,
+		pr_debug(
 		      "ray_cs send authentication request failed - ECF not ready for intr\n");
 		writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
 		return -1;
@@ -2942,9 +2933,9 @@ static int __init init_ray_cs(void)
 {
 	int rc;
 
-	DEBUG(1, "%s\n", rcsid);
+	pr_debug("%s\n", rcsid);
 	rc = pcmcia_register_driver(&ray_driver);
-	DEBUG(1, "raylink init_module register_pcmcia_driver returns 0x%x\n",
+	pr_debug("raylink init_module register_pcmcia_driver returns 0x%x\n",
 	      rc);
 
 #ifdef CONFIG_PROC_FS
@@ -2964,7 +2955,7 @@ static int __init init_ray_cs(void)
 
 static void __exit exit_ray_cs(void)
 {
-	DEBUG(0, "ray_cs: cleanup_module\n");
+	pr_debug("ray_cs: cleanup_module\n");
 
 #ifdef CONFIG_PROC_FS
 	remove_proc_entry("driver/ray_cs/ray_cs", NULL);

commit 575c9ed7798218dc923f319c0d78f0c25ca506b9
Author: Alan Cox <alan@linux.intel.com>
Date:   Tue Oct 27 15:35:55 2009 +0000

    ray_cs: Fix copy_from_user handling
    
    I've not touched the other stuff here but the word "locking" comes to mind.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Cc: stable@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 88cd58eb3b9f..1c88c2ea59aa 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2879,7 +2879,7 @@ static int write_essid(struct file *file, const char __user *buffer,
 		       unsigned long count, void *data)
 {
 	static char proc_essid[33];
-	int len = count;
+	unsigned int len = count;
 
 	if (len > 32)
 		len = 32;

commit d0cf9c0dadcdc89a755bcb301cfc9c796eb28ccf
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Mon Aug 31 19:50:57 2009 +0000

    wireless: convert drivers to netdev_tx_t
    
    Mostly just simple conversions:
      * ray_cs had bogus return of NET_TX_LOCKED but driver
        was not using NETIF_F_LLTX
      * hostap and ipw2x00 had some code that returned value
        from a called function that also had to change to return netdev_tx_t
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 325206969c97..88cd58eb3b9f 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -104,7 +104,8 @@ static int ray_dev_init(struct net_device *dev);
 static const struct ethtool_ops netdev_ethtool_ops;
 
 static int ray_open(struct net_device *dev);
-static int ray_dev_start_xmit(struct sk_buff *skb, struct net_device *dev);
+static netdev_tx_t ray_dev_start_xmit(struct sk_buff *skb,
+					    struct net_device *dev);
 static void set_multicast_list(struct net_device *dev);
 static void ray_update_multi_list(struct net_device *dev, int all);
 static int translate_frame(ray_dev_t *local, struct tx_msg __iomem *ptx,
@@ -915,16 +916,19 @@ static int ray_dev_config(struct net_device *dev, struct ifmap *map)
 }
 
 /*===========================================================================*/
-static int ray_dev_start_xmit(struct sk_buff *skb, struct net_device *dev)
+static netdev_tx_t ray_dev_start_xmit(struct sk_buff *skb,
+					    struct net_device *dev)
 {
 	ray_dev_t *local = netdev_priv(dev);
 	struct pcmcia_device *link = local->finder;
 	short length = skb->len;
 
-	if (!(pcmcia_dev_present(link))) {
+	if (!pcmcia_dev_present(link)) {
 		DEBUG(2, "ray_dev_start_xmit - device not present\n");
-		return NETDEV_TX_LOCKED;
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
 	}
+
 	DEBUG(3, "ray_dev_start_xmit(skb=%p, dev=%p)\n", skb, dev);
 	if (local->authentication_state == NEED_TO_AUTH) {
 		DEBUG(0, "ray_cs Sending authentication request.\n");
@@ -951,8 +955,8 @@ static int ray_dev_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	default:
 		dev->trans_start = jiffies;
 		dev_kfree_skb(skb);
-		return NETDEV_TX_OK;
 	}
+
 	return NETDEV_TX_OK;
 } /* ray_dev_start_xmit */
 

commit aa11d958d1a6572eda08214d7c6a735804fe48a5
Merge: 07f6642ee941 9799218ae369
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Aug 12 17:44:53 2009 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
            arch/microblaze/include/asm/socket.h

commit 11866efa9b5d6f321a2625b7f6837ba55c4c2e4b
Author: John W. Linville <linville@tuxdriver.com>
Date:   Mon Jul 27 10:56:41 2009 -0400

    ray_cs: remove bogus NULL check at head of ray_get_wireless_stats
    
    Reported-by: Johannes Berg <johannes@sipsolutions.net>
    Cc: Martin Ettl <ettl.martin@gmx.de>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 64e574c3655c..2be78201633f 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -1511,9 +1511,6 @@ static iw_stats *ray_get_wireless_stats(struct net_device *dev)
 	struct pcmcia_device *link = local->finder;
 	struct status __iomem *p = local->sram + STATUS_BASE;
 
-	if (local == (ray_dev_t *) NULL)
-		return (iw_stats *) NULL;
-
 	local->wstats.status = local->card_status;
 #ifdef WIRELESS_SPY
 	if ((local->spy_data.spy_number > 0)

commit ad361c9884e809340f6daca80d56a9e9c871690a
Author: Joe Perches <joe@perches.com>
Date:   Mon Jul 6 13:05:40 2009 -0700

    Remove multiple KERN_ prefixes from printk formats
    
    Commit 5fd29d6ccbc98884569d6f3105aeca70858b3e0f ("printk: clean up
    handling of log-levels and newlines") changed printk semantics.  printk
    lines with multiple KERN_<level> prefixes are no longer emitted as
    before the patch.
    
    <level> is now included in the output on each additional use.
    
    Remove all uses of multiple KERN_<level>s in formats.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index b10b0383dfa5..698b11b1cadb 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2427,11 +2427,10 @@ static void untranslate(ray_dev_t *local, struct sk_buff *skb, int len)
 
 #ifdef PCMCIA_DEBUG
 	if (pc_debug > 3) {
-		int i;
-		printk(KERN_DEBUG "skb->data before untranslate");
-		for (i = 0; i < 64; i++)
-			printk("%02x ", skb->data[i]);
-		printk("\n" KERN_DEBUG
+		print_hex_dump(KERN_DEBUG, "skb->data before untranslate: ",
+			       DUMP_PREFIX_NONE, 16, 1,
+			       skb->data, 64, true);
+		printk(KERN_DEBUG
 		       "type = %08x, xsap = %02x%02x%02x, org = %02x02x02x\n",
 		       ntohs(type), psnap->dsap, psnap->ssap, psnap->ctrl,
 		       psnap->org[0], psnap->org[1], psnap->org[2]);

commit 6ed106549d17474ca17a16057f4c0ed4eba5a7ca
Author: Patrick McHardy <kaber@trash.net>
Date:   Tue Jun 23 06:03:08 2009 +0000

    net: use NETDEV_TX_OK instead of 0 in ndo_start_xmit() functions
    
    This patch is the result of an automatic spatch transformation to convert
    all ndo_start_xmit() return values of 0 to NETDEV_TX_OK.
    
    Some occurences are missed by the automatic conversion, those will be
    handled in a seperate patch.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index b10b0383dfa5..64e574c3655c 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -937,7 +937,7 @@ static int ray_dev_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	if (length < ETH_ZLEN) {
 		if (skb_padto(skb, ETH_ZLEN))
-			return 0;
+			return NETDEV_TX_OK;
 		length = ETH_ZLEN;
 	}
 	switch (ray_hw_xmit(skb->data, length, dev, DATA_TYPE)) {
@@ -951,9 +951,9 @@ static int ray_dev_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	default:
 		dev->trans_start = jiffies;
 		dev_kfree_skb(skb);
-		return 0;
+		return NETDEV_TX_OK;
 	}
-	return 0;
+	return NETDEV_TX_OK;
 } /* ray_dev_start_xmit */
 
 /*===========================================================================*/

commit 5b548140225c6bbbbd560551dd1048b2c0ce58be
Author: Patrick McHardy <kaber@trash.net>
Date:   Fri Jun 12 06:22:29 2009 +0000

    net: use symbolic values for ndo_start_xmit() return codes
    
    Convert magic values 1 and -1 to NETDEV_TX_BUSY and NETDEV_TX_LOCKED respectively.
    
    0 (NETDEV_TX_OK) is not changed to keep the noise down, except in very few cases
    where its in direct proximity to one of the other values.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 22e71856aa24..b10b0383dfa5 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -923,7 +923,7 @@ static int ray_dev_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	if (!(pcmcia_dev_present(link))) {
 		DEBUG(2, "ray_dev_start_xmit - device not present\n");
-		return -1;
+		return NETDEV_TX_LOCKED;
 	}
 	DEBUG(3, "ray_dev_start_xmit(skb=%p, dev=%p)\n", skb, dev);
 	if (local->authentication_state == NEED_TO_AUTH) {
@@ -931,7 +931,7 @@ static int ray_dev_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		if (!build_auth_frame(local, local->auth_id, OPEN_AUTH_REQUEST)) {
 			local->authentication_state = AUTHENTICATED;
 			netif_stop_queue(dev);
-			return 1;
+			return NETDEV_TX_BUSY;
 		}
 	}
 
@@ -944,7 +944,7 @@ static int ray_dev_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	case XMIT_NO_CCS:
 	case XMIT_NEED_AUTH:
 		netif_stop_queue(dev);
-		return 1;
+		return NETDEV_TX_BUSY;
 	case XMIT_NO_INTR:
 	case XMIT_MSG_BAD:
 	case XMIT_OK:

commit 3a6d54c56326c29c5357655779cfe6cf36481b17
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Mon May 11 23:37:15 2009 +0000

    net: remove needless (now buggy) & from dev->dev_addr
    
    Patch fixes issues with dev->dev_addr changing from array to pointer.
    Hopefully there are no others.
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index fa90d1d8d82e..22e71856aa24 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -892,7 +892,7 @@ static int ray_dev_init(struct net_device *dev)
 #endif /* RAY_IMMEDIATE_INIT */
 
 	/* copy mac and broadcast addresses to linux device */
-	memcpy(&dev->dev_addr, &local->sparm.b4.a_mac_addr, ADDRLEN);
+	memcpy(dev->dev_addr, &local->sparm.b4.a_mac_addr, ADDRLEN);
 	memset(dev->broadcast, 0xff, ETH_ALEN);
 
 	DEBUG(2, "ray_dev_init ending\n");

commit 32f5a330090fdf7d4d663ff5bd979e186fe6aab6
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Fri Mar 20 19:36:28 2009 +0000

    raylan: convert to net_device_ops
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 7370edb4e0ce..fa90d1d8d82e 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -298,6 +298,19 @@ static char hop_pattern_length[] = { 1,
 static char rcsid[] =
     "Raylink/WebGear wireless LAN - Corey <Thomas corey@world.std.com>";
 
+static const struct net_device_ops ray_netdev_ops = {
+	.ndo_init 		= ray_dev_init,
+	.ndo_open 		= ray_open,
+	.ndo_stop 		= ray_dev_close,
+	.ndo_start_xmit		= ray_dev_start_xmit,
+	.ndo_set_config		= ray_dev_config,
+	.ndo_get_stats		= ray_get_stats,
+	.ndo_set_multicast_list = set_multicast_list,
+	.ndo_change_mtu		= eth_change_mtu,
+	.ndo_set_mac_address 	= eth_mac_addr,
+	.ndo_validate_addr	= eth_validate_addr,
+};
+
 /*=============================================================================
     ray_attach() creates an "instance" of the driver, allocating
     local data structures for one device.  The device is registered
@@ -347,9 +360,7 @@ static int ray_probe(struct pcmcia_device *p_dev)
 	      p_dev, dev, local, &ray_interrupt);
 
 	/* Raylink entries in the device structure */
-	dev->hard_start_xmit = &ray_dev_start_xmit;
-	dev->set_config = &ray_dev_config;
-	dev->get_stats = &ray_get_stats;
+	dev->netdev_ops = &ray_netdev_ops;
 	SET_ETHTOOL_OPS(dev, &netdev_ethtool_ops);
 	dev->wireless_handlers = &ray_handler_def;
 #ifdef WIRELESS_SPY
@@ -357,12 +368,8 @@ static int ray_probe(struct pcmcia_device *p_dev)
 	dev->wireless_data = &local->wireless_data;
 #endif /* WIRELESS_SPY */
 
-	dev->set_multicast_list = &set_multicast_list;
 
 	DEBUG(2, "ray_cs ray_attach calling ether_setup.)\n");
-	dev->init = &ray_dev_init;
-	dev->open = &ray_open;
-	dev->stop = &ray_dev_close;
 	netif_stop_queue(dev);
 
 	init_timer(&local->timer);

commit 141fa61f10c419cb9b47a042eed79df621db75c6
Author: John Daiker <daikerjohn@gmail.com>
Date:   Tue Mar 10 06:59:54 2009 -0700

    ray_cs: checkpatch.pl and Lindent cleanups
    
    Before: 1099 errors, 93 warnings, 2854 lines checked
    After:  19 errors, 47 warnings, 2976 lines checked
    
    The big bulk of this is code indent and over 80 character lines
    (Lindent did this part) Other changes are foo * bar spacing, and
    trailing whitespace.
    
    v2: Cleans up ill-indented comments.  Subsequently, this reduces the
    number of warnings, too.  Thanks to Joe Perches for pointing this out!
    
    v3: Ran the whole file through Lindent first... which does most of
    the work for me. :) Again, thanks to Joe Perches for this.
    
    This is my final answer!
    
    Signed-off-by: John Daiker <daikerjohn@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 99ec7d622518..7370edb4e0ce 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -8,7 +8,7 @@
  * Copyright (c) 1998  Corey Thomas (corey@world.std.com)
  *
  * This driver is free software; you can redistribute it and/or modify
- * it under the terms of version 2 only of the GNU General Public License as 
+ * it under the terms of version 2 only of the GNU General Public License as
  * published by the Free Software Foundation.
  *
  * It is distributed in the hope that it will be useful,
@@ -27,7 +27,7 @@
  *
  * Daniele Bellucci <bellucda@tiscali.it> - 07/10/2003
  * - Audit copy_to_user in ioctl(SIOCGIWESSID)
- * 
+ *
 =============================================================================*/
 
 #include <linux/module.h>
@@ -65,8 +65,8 @@
 /* Warning : these stuff will slow down the driver... */
 #define WIRELESS_SPY		/* Enable spying addresses */
 /* Definitions we need for spy */
-typedef struct iw_statistics	iw_stats;
-typedef u_char	mac_addr[ETH_ALEN];	/* Hardware address */
+typedef struct iw_statistics iw_stats;
+typedef u_char mac_addr[ETH_ALEN];	/* Hardware address */
 
 #include "rayctl.h"
 #include "ray_cs.h"
@@ -86,7 +86,7 @@ static int ray_debug;
 static int pc_debug = PCMCIA_DEBUG;
 module_param(pc_debug, int, 0);
 /* #define DEBUG(n, args...) if (pc_debug>(n)) printk(KERN_DEBUG args); */
-#define DEBUG(n, args...) if (pc_debug>(n)) printk(args);
+#define DEBUG(n, args...) if (pc_debug > (n)) printk(args);
 #else
 #define DEBUG(n, args...)
 #endif
@@ -108,12 +108,12 @@ static int ray_dev_start_xmit(struct sk_buff *skb, struct net_device *dev);
 static void set_multicast_list(struct net_device *dev);
 static void ray_update_multi_list(struct net_device *dev, int all);
 static int translate_frame(ray_dev_t *local, struct tx_msg __iomem *ptx,
-                unsigned char *data, int len);
-static void ray_build_header(ray_dev_t *local, struct tx_msg __iomem *ptx, UCHAR msg_type,
-                unsigned char *data);
+			   unsigned char *data, int len);
+static void ray_build_header(ray_dev_t *local, struct tx_msg __iomem *ptx,
+			     UCHAR msg_type, unsigned char *data);
 static void untranslate(ray_dev_t *local, struct sk_buff *skb, int len);
-static iw_stats * ray_get_wireless_stats(struct net_device *	dev);
-static const struct iw_handler_def	ray_handler_def;
+static iw_stats *ray_get_wireless_stats(struct net_device *dev);
+static const struct iw_handler_def ray_handler_def;
 
 /***** Prototypes for raylink functions **************************************/
 static int asc_to_int(char a);
@@ -124,7 +124,7 @@ static int get_free_ccs(ray_dev_t *local);
 static int get_free_tx_ccs(ray_dev_t *local);
 static void init_startup_params(ray_dev_t *local);
 static int parse_addr(char *in_str, UCHAR *out);
-static int ray_hw_xmit(unsigned char* data, int len, struct net_device* dev, UCHAR type);
+static int ray_hw_xmit(unsigned char *data, int len, struct net_device *dev, UCHAR type);
 static int ray_init(struct net_device *dev);
 static int interrupt_ecf(ray_dev_t *local, int ccs);
 static void ray_reset(struct net_device *dev);
@@ -132,17 +132,17 @@ static void ray_update_parm(struct net_device *dev, UCHAR objid, UCHAR *value, i
 static void verify_dl_startup(u_long);
 
 /* Prototypes for interrpt time functions **********************************/
-static irqreturn_t ray_interrupt (int reg, void *dev_id);
+static irqreturn_t ray_interrupt(int reg, void *dev_id);
 static void clear_interrupt(ray_dev_t *local);
-static void rx_deauthenticate(ray_dev_t *local, struct rcs __iomem *prcs, 
-                       unsigned int pkt_addr, int rx_len);
+static void rx_deauthenticate(ray_dev_t *local, struct rcs __iomem *prcs,
+			      unsigned int pkt_addr, int rx_len);
 static int copy_from_rx_buff(ray_dev_t *local, UCHAR *dest, int pkt_addr, int len);
 static void ray_rx(struct net_device *dev, ray_dev_t *local, struct rcs __iomem *prcs);
 static void release_frag_chain(ray_dev_t *local, struct rcs __iomem *prcs);
 static void rx_authenticate(ray_dev_t *local, struct rcs __iomem *prcs,
-                     unsigned int pkt_addr, int rx_len);
-static void rx_data(struct net_device *dev, struct rcs __iomem *prcs, unsigned int pkt_addr, 
-             int rx_len);
+			    unsigned int pkt_addr, int rx_len);
+static void rx_data(struct net_device *dev, struct rcs __iomem *prcs,
+		    unsigned int pkt_addr, int rx_len);
 static void associate(ray_dev_t *local);
 
 /* Card command functions */
@@ -219,82 +219,84 @@ module_param(phy_addr, charp, 0);
 module_param(ray_mem_speed, int, 0);
 
 static UCHAR b5_default_startup_parms[] = {
-    0,   0,                         /* Adhoc station */
-   'L','I','N','U','X', 0,  0,  0,  /* 32 char ESSID */
-    0,  0,  0,  0,  0,  0,  0,  0,
-    0,  0,  0,  0,  0,  0,  0,  0,
-    0,  0,  0,  0,  0,  0,  0,  0,
-    1,  0,                          /* Active scan, CA Mode */
-    0,  0,  0,  0,  0,  0,          /* No default MAC addr  */
-    0x7f, 0xff,                     /* Frag threshold */
-    0x00, 0x80,                     /* Hop time 128 Kus*/
-    0x01, 0x00,                     /* Beacon period 256 Kus */
-    0x01, 0x07, 0xa3,               /* DTIM, retries, ack timeout*/
-    0x1d, 0x82, 0x4e,               /* SIFS, DIFS, PIFS */
-    0x7f, 0xff,                     /* RTS threshold */
-    0x04, 0xe2, 0x38, 0xA4,         /* scan_dwell, max_scan_dwell */
-    0x05,                           /* assoc resp timeout thresh */
-    0x08, 0x02, 0x08,               /* adhoc, infra, super cycle max*/
-    0,                              /* Promiscuous mode */
-    0x0c, 0x0bd,                    /* Unique word */
-    0x32,                           /* Slot time */
-    0xff, 0xff,                     /* roam-low snr, low snr count */
-    0x05, 0xff,                     /* Infra, adhoc missed bcn thresh */
-    0x01, 0x0b, 0x4f,               /* USA, hop pattern, hop pat length */
+	0, 0,			/* Adhoc station */
+	'L', 'I', 'N', 'U', 'X', 0, 0, 0,	/* 32 char ESSID */
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	1, 0,			/* Active scan, CA Mode */
+	0, 0, 0, 0, 0, 0,	/* No default MAC addr  */
+	0x7f, 0xff,		/* Frag threshold */
+	0x00, 0x80,		/* Hop time 128 Kus */
+	0x01, 0x00,		/* Beacon period 256 Kus */
+	0x01, 0x07, 0xa3,	/* DTIM, retries, ack timeout */
+	0x1d, 0x82, 0x4e,	/* SIFS, DIFS, PIFS */
+	0x7f, 0xff,		/* RTS threshold */
+	0x04, 0xe2, 0x38, 0xA4,	/* scan_dwell, max_scan_dwell */
+	0x05,			/* assoc resp timeout thresh */
+	0x08, 0x02, 0x08,	/* adhoc, infra, super cycle max */
+	0,			/* Promiscuous mode */
+	0x0c, 0x0bd,		/* Unique word */
+	0x32,			/* Slot time */
+	0xff, 0xff,		/* roam-low snr, low snr count */
+	0x05, 0xff,		/* Infra, adhoc missed bcn thresh */
+	0x01, 0x0b, 0x4f,	/* USA, hop pattern, hop pat length */
 /* b4 - b5 differences start here */
-    0x00, 0x3f,                     /* CW max */
-    0x00, 0x0f,                     /* CW min */
-    0x04, 0x08,                     /* Noise gain, limit offset */
-    0x28, 0x28,                     /* det rssi, med busy offsets */
-    7,                              /* det sync thresh */
-    0, 2, 2,                        /* test mode, min, max */
-    0,                              /* allow broadcast SSID probe resp */
-    0, 0,                           /* privacy must start, can join */
-    2, 0, 0, 0, 0, 0, 0, 0          /* basic rate set */
+	0x00, 0x3f,		/* CW max */
+	0x00, 0x0f,		/* CW min */
+	0x04, 0x08,		/* Noise gain, limit offset */
+	0x28, 0x28,		/* det rssi, med busy offsets */
+	7,			/* det sync thresh */
+	0, 2, 2,		/* test mode, min, max */
+	0,			/* allow broadcast SSID probe resp */
+	0, 0,			/* privacy must start, can join */
+	2, 0, 0, 0, 0, 0, 0, 0	/* basic rate set */
 };
 
 static UCHAR b4_default_startup_parms[] = {
-    0,   0,                         /* Adhoc station */
-   'L','I','N','U','X', 0,  0,  0,  /* 32 char ESSID */
-    0,  0,  0,  0,  0,  0,  0,  0,
-    0,  0,  0,  0,  0,  0,  0,  0,
-    0,  0,  0,  0,  0,  0,  0,  0,
-    1,  0,                          /* Active scan, CA Mode */
-    0,  0,  0,  0,  0,  0,          /* No default MAC addr  */
-    0x7f, 0xff,                     /* Frag threshold */
-    0x02, 0x00,                     /* Hop time */
-    0x00, 0x01,                     /* Beacon period */
-    0x01, 0x07, 0xa3,               /* DTIM, retries, ack timeout*/
-    0x1d, 0x82, 0xce,               /* SIFS, DIFS, PIFS */
-    0x7f, 0xff,                     /* RTS threshold */
-    0xfb, 0x1e, 0xc7, 0x5c,         /* scan_dwell, max_scan_dwell */
-    0x05,                           /* assoc resp timeout thresh */
-    0x04, 0x02, 0x4,                /* adhoc, infra, super cycle max*/
-    0,                              /* Promiscuous mode */
-    0x0c, 0x0bd,                    /* Unique word */
-    0x4e,                           /* Slot time (TBD seems wrong)*/
-    0xff, 0xff,                     /* roam-low snr, low snr count */
-    0x05, 0xff,                     /* Infra, adhoc missed bcn thresh */
-    0x01, 0x0b, 0x4e,               /* USA, hop pattern, hop pat length */
+	0, 0,			/* Adhoc station */
+	'L', 'I', 'N', 'U', 'X', 0, 0, 0,	/* 32 char ESSID */
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	1, 0,			/* Active scan, CA Mode */
+	0, 0, 0, 0, 0, 0,	/* No default MAC addr  */
+	0x7f, 0xff,		/* Frag threshold */
+	0x02, 0x00,		/* Hop time */
+	0x00, 0x01,		/* Beacon period */
+	0x01, 0x07, 0xa3,	/* DTIM, retries, ack timeout */
+	0x1d, 0x82, 0xce,	/* SIFS, DIFS, PIFS */
+	0x7f, 0xff,		/* RTS threshold */
+	0xfb, 0x1e, 0xc7, 0x5c,	/* scan_dwell, max_scan_dwell */
+	0x05,			/* assoc resp timeout thresh */
+	0x04, 0x02, 0x4,	/* adhoc, infra, super cycle max */
+	0,			/* Promiscuous mode */
+	0x0c, 0x0bd,		/* Unique word */
+	0x4e,			/* Slot time (TBD seems wrong) */
+	0xff, 0xff,		/* roam-low snr, low snr count */
+	0x05, 0xff,		/* Infra, adhoc missed bcn thresh */
+	0x01, 0x0b, 0x4e,	/* USA, hop pattern, hop pat length */
 /* b4 - b5 differences start here */
-    0x3f, 0x0f,                     /* CW max, min */
-    0x04, 0x08,                     /* Noise gain, limit offset */
-    0x28, 0x28,                     /* det rssi, med busy offsets */
-    7,                              /* det sync thresh */
-    0, 2, 2                         /* test mode, min, max*/
+	0x3f, 0x0f,		/* CW max, min */
+	0x04, 0x08,		/* Noise gain, limit offset */
+	0x28, 0x28,		/* det rssi, med busy offsets */
+	7,			/* det sync thresh */
+	0, 2, 2			/* test mode, min, max */
 };
+
 /*===========================================================================*/
-static unsigned char eth2_llc[] = {0xaa, 0xaa, 3, 0, 0, 0};
+static unsigned char eth2_llc[] = { 0xaa, 0xaa, 3, 0, 0, 0 };
 
 static char hop_pattern_length[] = { 1,
-	     USA_HOP_MOD,             EUROPE_HOP_MOD,
-	     JAPAN_HOP_MOD,           KOREA_HOP_MOD,
-	     SPAIN_HOP_MOD,           FRANCE_HOP_MOD,
-	     ISRAEL_HOP_MOD,          AUSTRALIA_HOP_MOD,
-	     JAPAN_TEST_HOP_MOD
+	USA_HOP_MOD, EUROPE_HOP_MOD,
+	JAPAN_HOP_MOD, KOREA_HOP_MOD,
+	SPAIN_HOP_MOD, FRANCE_HOP_MOD,
+	ISRAEL_HOP_MOD, AUSTRALIA_HOP_MOD,
+	JAPAN_TEST_HOP_MOD
 };
 
-static char rcsid[] = "Raylink/WebGear wireless LAN - Corey <Thomas corey@world.std.com>";
+static char rcsid[] =
+    "Raylink/WebGear wireless LAN - Corey <Thomas corey@world.std.com>";
 
 /*=============================================================================
     ray_attach() creates an "instance" of the driver, allocating
@@ -306,71 +308,72 @@ static char rcsid[] = "Raylink/WebGear wireless LAN - Corey <Thomas corey@world.
 =============================================================================*/
 static int ray_probe(struct pcmcia_device *p_dev)
 {
-    ray_dev_t *local;
-    struct net_device *dev;
-
-    DEBUG(1, "ray_attach()\n");
-
-    /* Allocate space for private device-specific data */
-    dev = alloc_etherdev(sizeof(ray_dev_t));
-    if (!dev)
-	    goto fail_alloc_dev;
-
-    local = netdev_priv(dev);
-    local->finder = p_dev;
-
-    /* The io structure describes IO port mapping. None used here */
-    p_dev->io.NumPorts1 = 0;
-    p_dev->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
-    p_dev->io.IOAddrLines = 5;
-
-    /* Interrupt setup. For PCMCIA, driver takes what's given */
-    p_dev->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING | IRQ_HANDLE_PRESENT;
-    p_dev->irq.IRQInfo1 = IRQ_LEVEL_ID;
-    p_dev->irq.Handler = &ray_interrupt;
-
-    /* General socket configuration */
-    p_dev->conf.Attributes = CONF_ENABLE_IRQ;
-    p_dev->conf.IntType = INT_MEMORY_AND_IO;
-    p_dev->conf.ConfigIndex = 1;
-
-    p_dev->priv = dev;
-    p_dev->irq.Instance = dev;
-    
-    local->finder = p_dev;
-    local->card_status = CARD_INSERTED;
-    local->authentication_state = UNAUTHENTICATED;
-    local->num_multi = 0;
-    DEBUG(2,"ray_attach p_dev = %p,  dev = %p,  local = %p, intr = %p\n",
-          p_dev,dev,local,&ray_interrupt);
-
-    /* Raylink entries in the device structure */
-    dev->hard_start_xmit = &ray_dev_start_xmit;
-    dev->set_config = &ray_dev_config;
-    dev->get_stats  = &ray_get_stats;
-    SET_ETHTOOL_OPS(dev, &netdev_ethtool_ops);
-    dev->wireless_handlers = &ray_handler_def;
+	ray_dev_t *local;
+	struct net_device *dev;
+
+	DEBUG(1, "ray_attach()\n");
+
+	/* Allocate space for private device-specific data */
+	dev = alloc_etherdev(sizeof(ray_dev_t));
+	if (!dev)
+		goto fail_alloc_dev;
+
+	local = netdev_priv(dev);
+	local->finder = p_dev;
+
+	/* The io structure describes IO port mapping. None used here */
+	p_dev->io.NumPorts1 = 0;
+	p_dev->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
+	p_dev->io.IOAddrLines = 5;
+
+	/* Interrupt setup. For PCMCIA, driver takes what's given */
+	p_dev->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING | IRQ_HANDLE_PRESENT;
+	p_dev->irq.IRQInfo1 = IRQ_LEVEL_ID;
+	p_dev->irq.Handler = &ray_interrupt;
+
+	/* General socket configuration */
+	p_dev->conf.Attributes = CONF_ENABLE_IRQ;
+	p_dev->conf.IntType = INT_MEMORY_AND_IO;
+	p_dev->conf.ConfigIndex = 1;
+
+	p_dev->priv = dev;
+	p_dev->irq.Instance = dev;
+
+	local->finder = p_dev;
+	local->card_status = CARD_INSERTED;
+	local->authentication_state = UNAUTHENTICATED;
+	local->num_multi = 0;
+	DEBUG(2, "ray_attach p_dev = %p,  dev = %p,  local = %p, intr = %p\n",
+	      p_dev, dev, local, &ray_interrupt);
+
+	/* Raylink entries in the device structure */
+	dev->hard_start_xmit = &ray_dev_start_xmit;
+	dev->set_config = &ray_dev_config;
+	dev->get_stats = &ray_get_stats;
+	SET_ETHTOOL_OPS(dev, &netdev_ethtool_ops);
+	dev->wireless_handlers = &ray_handler_def;
 #ifdef WIRELESS_SPY
-    local->wireless_data.spy_data = &local->spy_data;
-    dev->wireless_data = &local->wireless_data;
-#endif	/* WIRELESS_SPY */
+	local->wireless_data.spy_data = &local->spy_data;
+	dev->wireless_data = &local->wireless_data;
+#endif /* WIRELESS_SPY */
 
-    dev->set_multicast_list = &set_multicast_list;
+	dev->set_multicast_list = &set_multicast_list;
 
-    DEBUG(2,"ray_cs ray_attach calling ether_setup.)\n");
-    dev->init = &ray_dev_init;
-    dev->open = &ray_open;
-    dev->stop = &ray_dev_close;
-    netif_stop_queue(dev);
+	DEBUG(2, "ray_cs ray_attach calling ether_setup.)\n");
+	dev->init = &ray_dev_init;
+	dev->open = &ray_open;
+	dev->stop = &ray_dev_close;
+	netif_stop_queue(dev);
 
-    init_timer(&local->timer);
+	init_timer(&local->timer);
 
-    this_device = p_dev;
-    return ray_config(p_dev);
+	this_device = p_dev;
+	return ray_config(p_dev);
 
 fail_alloc_dev:
-    return -ENOMEM;
+	return -ENOMEM;
 } /* ray_attach */
+
 /*=============================================================================
     This deletes a driver "instance".  The device is de-registered
     with Card Services.  If it has been released, all local data
@@ -379,25 +382,27 @@ static int ray_probe(struct pcmcia_device *p_dev)
 =============================================================================*/
 static void ray_detach(struct pcmcia_device *link)
 {
-    struct net_device *dev;
-    ray_dev_t *local;
+	struct net_device *dev;
+	ray_dev_t *local;
 
-    DEBUG(1, "ray_detach(0x%p)\n", link);
+	DEBUG(1, "ray_detach(0x%p)\n", link);
 
-    this_device = NULL;
-    dev = link->priv;
+	this_device = NULL;
+	dev = link->priv;
 
-    ray_release(link);
+	ray_release(link);
 
-    local = netdev_priv(dev);
-    del_timer(&local->timer);
+	local = netdev_priv(dev);
+	del_timer(&local->timer);
 
-    if (link->priv) {
-	if (link->dev_node) unregister_netdev(dev);
-        free_netdev(dev);
-    }
-    DEBUG(2,"ray_cs ray_detach ending\n");
+	if (link->priv) {
+		if (link->dev_node)
+			unregister_netdev(dev);
+		free_netdev(dev);
+	}
+	DEBUG(2, "ray_cs ray_detach ending\n");
 } /* ray_detach */
+
 /*=============================================================================
     ray_config() is run after a CARD_INSERTION event
     is received, to configure the PCMCIA socket, and to make the
@@ -408,92 +413,101 @@ do { last_fn = (fn); if ((last_ret = (ret)) != 0) goto cs_failed; } while (0)
 #define MAX_TUPLE_SIZE 128
 static int ray_config(struct pcmcia_device *link)
 {
-    int last_fn = 0, last_ret = 0;
-    int i;
-    win_req_t req;
-    memreq_t mem;
-    struct net_device *dev = (struct net_device *)link->priv;
-    ray_dev_t *local = netdev_priv(dev);
-
-    DEBUG(1, "ray_config(0x%p)\n", link);
-
-    /* Determine card type and firmware version */
-    printk(KERN_INFO "ray_cs Detected: %s%s%s%s\n",
-	   link->prod_id[0] ? link->prod_id[0] : " ",
-	   link->prod_id[1] ? link->prod_id[1] : " ",
-	   link->prod_id[2] ? link->prod_id[2] : " ",
-	   link->prod_id[3] ? link->prod_id[3] : " ");
-
-    /* Now allocate an interrupt line.  Note that this does not
-       actually assign a handler to the interrupt.
-    */
-    CS_CHECK(RequestIRQ, pcmcia_request_irq(link, &link->irq));
-    dev->irq = link->irq.AssignedIRQ;
-    
-    /* This actually configures the PCMCIA socket -- setting up
-       the I/O windows and the interrupt mapping.
-    */
-    CS_CHECK(RequestConfiguration, pcmcia_request_configuration(link, &link->conf));
+	int last_fn = 0, last_ret = 0;
+	int i;
+	win_req_t req;
+	memreq_t mem;
+	struct net_device *dev = (struct net_device *)link->priv;
+	ray_dev_t *local = netdev_priv(dev);
+
+	DEBUG(1, "ray_config(0x%p)\n", link);
+
+	/* Determine card type and firmware version */
+	printk(KERN_INFO "ray_cs Detected: %s%s%s%s\n",
+	       link->prod_id[0] ? link->prod_id[0] : " ",
+	       link->prod_id[1] ? link->prod_id[1] : " ",
+	       link->prod_id[2] ? link->prod_id[2] : " ",
+	       link->prod_id[3] ? link->prod_id[3] : " ");
+
+	/* Now allocate an interrupt line.  Note that this does not
+	   actually assign a handler to the interrupt.
+	 */
+	CS_CHECK(RequestIRQ, pcmcia_request_irq(link, &link->irq));
+	dev->irq = link->irq.AssignedIRQ;
+
+	/* This actually configures the PCMCIA socket -- setting up
+	   the I/O windows and the interrupt mapping.
+	 */
+	CS_CHECK(RequestConfiguration,
+		 pcmcia_request_configuration(link, &link->conf));
 
 /*** Set up 32k window for shared memory (transmit and control) ************/
-    req.Attributes = WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_CM | WIN_ENABLE | WIN_USE_WAIT;
-    req.Base = 0;
-    req.Size = 0x8000;
-    req.AccessSpeed = ray_mem_speed;
-    CS_CHECK(RequestWindow, pcmcia_request_window(&link, &req, &link->win));
-    mem.CardOffset = 0x0000; mem.Page = 0;
-    CS_CHECK(MapMemPage, pcmcia_map_mem_page(link->win, &mem));
-    local->sram = ioremap(req.Base,req.Size);
+	req.Attributes =
+	    WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_CM | WIN_ENABLE | WIN_USE_WAIT;
+	req.Base = 0;
+	req.Size = 0x8000;
+	req.AccessSpeed = ray_mem_speed;
+	CS_CHECK(RequestWindow, pcmcia_request_window(&link, &req, &link->win));
+	mem.CardOffset = 0x0000;
+	mem.Page = 0;
+	CS_CHECK(MapMemPage, pcmcia_map_mem_page(link->win, &mem));
+	local->sram = ioremap(req.Base, req.Size);
 
 /*** Set up 16k window for shared memory (receive buffer) ***************/
-    req.Attributes = WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_CM | WIN_ENABLE | WIN_USE_WAIT;
-    req.Base = 0;
-    req.Size = 0x4000;
-    req.AccessSpeed = ray_mem_speed;
-    CS_CHECK(RequestWindow, pcmcia_request_window(&link, &req, &local->rmem_handle));
-    mem.CardOffset = 0x8000; mem.Page = 0;
-    CS_CHECK(MapMemPage, pcmcia_map_mem_page(local->rmem_handle, &mem));
-    local->rmem = ioremap(req.Base,req.Size);
+	req.Attributes =
+	    WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_CM | WIN_ENABLE | WIN_USE_WAIT;
+	req.Base = 0;
+	req.Size = 0x4000;
+	req.AccessSpeed = ray_mem_speed;
+	CS_CHECK(RequestWindow,
+		 pcmcia_request_window(&link, &req, &local->rmem_handle));
+	mem.CardOffset = 0x8000;
+	mem.Page = 0;
+	CS_CHECK(MapMemPage, pcmcia_map_mem_page(local->rmem_handle, &mem));
+	local->rmem = ioremap(req.Base, req.Size);
 
 /*** Set up window for attribute memory ***********************************/
-    req.Attributes = WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_AM | WIN_ENABLE | WIN_USE_WAIT;
-    req.Base = 0;
-    req.Size = 0x1000;
-    req.AccessSpeed = ray_mem_speed;
-    CS_CHECK(RequestWindow, pcmcia_request_window(&link, &req, &local->amem_handle));
-    mem.CardOffset = 0x0000; mem.Page = 0;
-    CS_CHECK(MapMemPage, pcmcia_map_mem_page(local->amem_handle, &mem));
-    local->amem = ioremap(req.Base,req.Size);
-
-    DEBUG(3,"ray_config sram=%p\n",local->sram);
-    DEBUG(3,"ray_config rmem=%p\n",local->rmem);
-    DEBUG(3,"ray_config amem=%p\n",local->amem);
-    if (ray_init(dev) < 0) {
-        ray_release(link);
-        return -ENODEV;
-    }
-
-    SET_NETDEV_DEV(dev, &handle_to_dev(link));
-    i = register_netdev(dev);
-    if (i != 0) {
-        printk("ray_config register_netdev() failed\n");
-        ray_release(link);
-        return i;
-    }
-
-    strcpy(local->node.dev_name, dev->name);
-    link->dev_node = &local->node;
-
-    printk(KERN_INFO "%s: RayLink, irq %d, hw_addr %pM\n",
-       dev->name, dev->irq, dev->dev_addr);
-
-    return 0;
+	req.Attributes =
+	    WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_AM | WIN_ENABLE | WIN_USE_WAIT;
+	req.Base = 0;
+	req.Size = 0x1000;
+	req.AccessSpeed = ray_mem_speed;
+	CS_CHECK(RequestWindow,
+		 pcmcia_request_window(&link, &req, &local->amem_handle));
+	mem.CardOffset = 0x0000;
+	mem.Page = 0;
+	CS_CHECK(MapMemPage, pcmcia_map_mem_page(local->amem_handle, &mem));
+	local->amem = ioremap(req.Base, req.Size);
+
+	DEBUG(3, "ray_config sram=%p\n", local->sram);
+	DEBUG(3, "ray_config rmem=%p\n", local->rmem);
+	DEBUG(3, "ray_config amem=%p\n", local->amem);
+	if (ray_init(dev) < 0) {
+		ray_release(link);
+		return -ENODEV;
+	}
+
+	SET_NETDEV_DEV(dev, &handle_to_dev(link));
+	i = register_netdev(dev);
+	if (i != 0) {
+		printk("ray_config register_netdev() failed\n");
+		ray_release(link);
+		return i;
+	}
+
+	strcpy(local->node.dev_name, dev->name);
+	link->dev_node = &local->node;
+
+	printk(KERN_INFO "%s: RayLink, irq %d, hw_addr %pM\n",
+	       dev->name, dev->irq, dev->dev_addr);
+
+	return 0;
 
 cs_failed:
-    cs_error(link, last_fn, last_ret);
+	cs_error(link, last_fn, last_ret);
 
-    ray_release(link);
-    return -ENODEV;
+	ray_release(link);
+	return -ENODEV;
 } /* ray_config */
 
 static inline struct ccs __iomem *ccs_base(ray_dev_t *dev)
@@ -516,267 +530,278 @@ static inline struct rcs __iomem *rcs_base(ray_dev_t *dev)
 /*===========================================================================*/
 static int ray_init(struct net_device *dev)
 {
-    int i;
-    UCHAR *p;
-    struct ccs __iomem *pccs;
-    ray_dev_t *local = netdev_priv(dev);
-    struct pcmcia_device *link = local->finder;
-    DEBUG(1, "ray_init(0x%p)\n", dev);
-    if (!(pcmcia_dev_present(link))) {
-        DEBUG(0,"ray_init - device not present\n");
-        return -1;
-    }
-
-    local->net_type = net_type;
-    local->sta_type = TYPE_STA;
-
-    /* Copy the startup results to local memory */
-    memcpy_fromio(&local->startup_res, local->sram + ECF_TO_HOST_BASE,\
-           sizeof(struct startup_res_6));
-
-    /* Check Power up test status and get mac address from card */
-    if (local->startup_res.startup_word != 0x80) {
-    printk(KERN_INFO "ray_init ERROR card status = %2x\n",
-           local->startup_res.startup_word);
-        local->card_status = CARD_INIT_ERROR;
-        return -1;
-    }
-
-    local->fw_ver = local->startup_res.firmware_version[0];
-    local->fw_bld = local->startup_res.firmware_version[1];
-    local->fw_var = local->startup_res.firmware_version[2];
-    DEBUG(1,"ray_init firmware version %d.%d \n",local->fw_ver, local->fw_bld);
-
-    local->tib_length = 0x20;
-    if ((local->fw_ver == 5) && (local->fw_bld >= 30))
-        local->tib_length = local->startup_res.tib_length;
-    DEBUG(2,"ray_init tib_length = 0x%02x\n", local->tib_length);
-    /* Initialize CCS's to buffer free state */
-    pccs = ccs_base(local);
-    for (i=0;  i<NUMBER_OF_CCS;  i++) {
-        writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
-    }
-    init_startup_params(local);
-
-    /* copy mac address to startup parameters */
-    if (parse_addr(phy_addr, local->sparm.b4.a_mac_addr))
-    {
-        p = local->sparm.b4.a_mac_addr;
-    }
-    else
-    {
-        memcpy(&local->sparm.b4.a_mac_addr,
-               &local->startup_res.station_addr, ADDRLEN);
-        p = local->sparm.b4.a_mac_addr;
-    }
-
-    clear_interrupt(local); /* Clear any interrupt from the card */
-    local->card_status = CARD_AWAITING_PARAM;
-    DEBUG(2,"ray_init ending\n");
-    return 0;
+	int i;
+	UCHAR *p;
+	struct ccs __iomem *pccs;
+	ray_dev_t *local = netdev_priv(dev);
+	struct pcmcia_device *link = local->finder;
+	DEBUG(1, "ray_init(0x%p)\n", dev);
+	if (!(pcmcia_dev_present(link))) {
+		DEBUG(0, "ray_init - device not present\n");
+		return -1;
+	}
+
+	local->net_type = net_type;
+	local->sta_type = TYPE_STA;
+
+	/* Copy the startup results to local memory */
+	memcpy_fromio(&local->startup_res, local->sram + ECF_TO_HOST_BASE,
+		      sizeof(struct startup_res_6));
+
+	/* Check Power up test status and get mac address from card */
+	if (local->startup_res.startup_word != 0x80) {
+		printk(KERN_INFO "ray_init ERROR card status = %2x\n",
+		       local->startup_res.startup_word);
+		local->card_status = CARD_INIT_ERROR;
+		return -1;
+	}
+
+	local->fw_ver = local->startup_res.firmware_version[0];
+	local->fw_bld = local->startup_res.firmware_version[1];
+	local->fw_var = local->startup_res.firmware_version[2];
+	DEBUG(1, "ray_init firmware version %d.%d \n", local->fw_ver,
+	      local->fw_bld);
+
+	local->tib_length = 0x20;
+	if ((local->fw_ver == 5) && (local->fw_bld >= 30))
+		local->tib_length = local->startup_res.tib_length;
+	DEBUG(2, "ray_init tib_length = 0x%02x\n", local->tib_length);
+	/* Initialize CCS's to buffer free state */
+	pccs = ccs_base(local);
+	for (i = 0; i < NUMBER_OF_CCS; i++) {
+		writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
+	}
+	init_startup_params(local);
+
+	/* copy mac address to startup parameters */
+	if (parse_addr(phy_addr, local->sparm.b4.a_mac_addr)) {
+		p = local->sparm.b4.a_mac_addr;
+	} else {
+		memcpy(&local->sparm.b4.a_mac_addr,
+		       &local->startup_res.station_addr, ADDRLEN);
+		p = local->sparm.b4.a_mac_addr;
+	}
+
+	clear_interrupt(local);	/* Clear any interrupt from the card */
+	local->card_status = CARD_AWAITING_PARAM;
+	DEBUG(2, "ray_init ending\n");
+	return 0;
 } /* ray_init */
+
 /*===========================================================================*/
 /* Download startup parameters to the card and command it to read them       */
 static int dl_startup_params(struct net_device *dev)
 {
-    int ccsindex;
-    ray_dev_t *local = netdev_priv(dev);
-    struct ccs __iomem *pccs;
-    struct pcmcia_device *link = local->finder;
-
-    DEBUG(1,"dl_startup_params entered\n");
-    if (!(pcmcia_dev_present(link))) {
-        DEBUG(2,"ray_cs dl_startup_params - device not present\n");
-        return -1;
-    }
-    
-    /* Copy parameters to host to ECF area */
-    if (local->fw_ver == 0x55) 
-        memcpy_toio(local->sram + HOST_TO_ECF_BASE, &local->sparm.b4,
-               sizeof(struct b4_startup_params));
-    else
-        memcpy_toio(local->sram + HOST_TO_ECF_BASE, &local->sparm.b5,
-               sizeof(struct b5_startup_params));
-
-    
-    /* Fill in the CCS fields for the ECF */
-    if ((ccsindex = get_free_ccs(local)) < 0) return -1;
-    local->dl_param_ccs = ccsindex;
-    pccs = ccs_base(local) + ccsindex;
-    writeb(CCS_DOWNLOAD_STARTUP_PARAMS, &pccs->cmd);
-    DEBUG(2,"dl_startup_params start ccsindex = %d\n", local->dl_param_ccs);
-    /* Interrupt the firmware to process the command */
-    if (interrupt_ecf(local, ccsindex)) {
-        printk(KERN_INFO "ray dl_startup_params failed - "
-           "ECF not ready for intr\n");
-        local->card_status = CARD_DL_PARAM_ERROR;
-        writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
-        return -2;
-    }
-    local->card_status = CARD_DL_PARAM;
-    /* Start kernel timer to wait for dl startup to complete. */
-    local->timer.expires = jiffies + HZ/2;
-    local->timer.data = (long)local;
-    local->timer.function = &verify_dl_startup;
-    add_timer(&local->timer);
-    DEBUG(2,"ray_cs dl_startup_params started timer for verify_dl_startup\n");
-    return 0;
+	int ccsindex;
+	ray_dev_t *local = netdev_priv(dev);
+	struct ccs __iomem *pccs;
+	struct pcmcia_device *link = local->finder;
+
+	DEBUG(1, "dl_startup_params entered\n");
+	if (!(pcmcia_dev_present(link))) {
+		DEBUG(2, "ray_cs dl_startup_params - device not present\n");
+		return -1;
+	}
+
+	/* Copy parameters to host to ECF area */
+	if (local->fw_ver == 0x55)
+		memcpy_toio(local->sram + HOST_TO_ECF_BASE, &local->sparm.b4,
+			    sizeof(struct b4_startup_params));
+	else
+		memcpy_toio(local->sram + HOST_TO_ECF_BASE, &local->sparm.b5,
+			    sizeof(struct b5_startup_params));
+
+	/* Fill in the CCS fields for the ECF */
+	if ((ccsindex = get_free_ccs(local)) < 0)
+		return -1;
+	local->dl_param_ccs = ccsindex;
+	pccs = ccs_base(local) + ccsindex;
+	writeb(CCS_DOWNLOAD_STARTUP_PARAMS, &pccs->cmd);
+	DEBUG(2, "dl_startup_params start ccsindex = %d\n",
+	      local->dl_param_ccs);
+	/* Interrupt the firmware to process the command */
+	if (interrupt_ecf(local, ccsindex)) {
+		printk(KERN_INFO "ray dl_startup_params failed - "
+		       "ECF not ready for intr\n");
+		local->card_status = CARD_DL_PARAM_ERROR;
+		writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
+		return -2;
+	}
+	local->card_status = CARD_DL_PARAM;
+	/* Start kernel timer to wait for dl startup to complete. */
+	local->timer.expires = jiffies + HZ / 2;
+	local->timer.data = (long)local;
+	local->timer.function = &verify_dl_startup;
+	add_timer(&local->timer);
+	DEBUG(2,
+	      "ray_cs dl_startup_params started timer for verify_dl_startup\n");
+	return 0;
 } /* dl_startup_params */
+
 /*===========================================================================*/
 static void init_startup_params(ray_dev_t *local)
 {
-    int i; 
-
-    if (country > JAPAN_TEST) country = USA;
-    else
-        if (country < USA) country = USA;
-    /* structure for hop time and beacon period is defined here using 
-     * New 802.11D6.1 format.  Card firmware is still using old format
-     * until version 6.
-     *    Before                    After
-     *    a_hop_time ms byte        a_hop_time ms byte
-     *    a_hop_time 2s byte        a_hop_time ls byte
-     *    a_hop_time ls byte        a_beacon_period ms byte
-     *    a_beacon_period           a_beacon_period ls byte
-     *
-     *    a_hop_time = uS           a_hop_time = KuS
-     *    a_beacon_period = hops    a_beacon_period = KuS
-     */                             /* 64ms = 010000 */
-    if (local->fw_ver == 0x55)  {
-        memcpy((UCHAR *)&local->sparm.b4, b4_default_startup_parms, 
-               sizeof(struct b4_startup_params));
-        /* Translate sane kus input values to old build 4/5 format */
-        /* i = hop time in uS truncated to 3 bytes */
-        i = (hop_dwell * 1024) & 0xffffff;
-        local->sparm.b4.a_hop_time[0] = (i >> 16) & 0xff;
-        local->sparm.b4.a_hop_time[1] = (i >> 8) & 0xff;
-        local->sparm.b4.a_beacon_period[0] = 0;
-        local->sparm.b4.a_beacon_period[1] =
-            ((beacon_period/hop_dwell) - 1) & 0xff;
-        local->sparm.b4.a_curr_country_code = country;
-        local->sparm.b4.a_hop_pattern_length = 
-            hop_pattern_length[(int)country] - 1;
-        if (bc)
-        {
-            local->sparm.b4.a_ack_timeout = 0x50;
-            local->sparm.b4.a_sifs = 0x3f;
-        }
-    }
-    else {    /* Version 5 uses real kus values */
-        memcpy((UCHAR *)&local->sparm.b5, b5_default_startup_parms, 
-               sizeof(struct b5_startup_params));
-
-        local->sparm.b5.a_hop_time[0] = (hop_dwell >> 8) & 0xff;
-        local->sparm.b5.a_hop_time[1] = hop_dwell & 0xff;
-        local->sparm.b5.a_beacon_period[0] = (beacon_period >> 8) & 0xff;
-        local->sparm.b5.a_beacon_period[1] = beacon_period & 0xff;
-        if (psm)
-            local->sparm.b5.a_power_mgt_state = 1;
-        local->sparm.b5.a_curr_country_code = country;
-        local->sparm.b5.a_hop_pattern_length = 
-            hop_pattern_length[(int)country];
-    }
-    
-    local->sparm.b4.a_network_type = net_type & 0x01;
-    local->sparm.b4.a_acting_as_ap_status = TYPE_STA;
-
-    if (essid != NULL)
-        strncpy(local->sparm.b4.a_current_ess_id, essid, ESSID_SIZE);
-} /* init_startup_params */ 
+	int i;
+
+	if (country > JAPAN_TEST)
+		country = USA;
+	else if (country < USA)
+		country = USA;
+	/* structure for hop time and beacon period is defined here using
+	 * New 802.11D6.1 format.  Card firmware is still using old format
+	 * until version 6.
+	 *    Before                    After
+	 *    a_hop_time ms byte        a_hop_time ms byte
+	 *    a_hop_time 2s byte        a_hop_time ls byte
+	 *    a_hop_time ls byte        a_beacon_period ms byte
+	 *    a_beacon_period           a_beacon_period ls byte
+	 *
+	 *    a_hop_time = uS           a_hop_time = KuS
+	 *    a_beacon_period = hops    a_beacon_period = KuS
+	 *//* 64ms = 010000 */
+	if (local->fw_ver == 0x55) {
+		memcpy((UCHAR *) &local->sparm.b4, b4_default_startup_parms,
+		       sizeof(struct b4_startup_params));
+		/* Translate sane kus input values to old build 4/5 format */
+		/* i = hop time in uS truncated to 3 bytes */
+		i = (hop_dwell * 1024) & 0xffffff;
+		local->sparm.b4.a_hop_time[0] = (i >> 16) & 0xff;
+		local->sparm.b4.a_hop_time[1] = (i >> 8) & 0xff;
+		local->sparm.b4.a_beacon_period[0] = 0;
+		local->sparm.b4.a_beacon_period[1] =
+		    ((beacon_period / hop_dwell) - 1) & 0xff;
+		local->sparm.b4.a_curr_country_code = country;
+		local->sparm.b4.a_hop_pattern_length =
+		    hop_pattern_length[(int)country] - 1;
+		if (bc) {
+			local->sparm.b4.a_ack_timeout = 0x50;
+			local->sparm.b4.a_sifs = 0x3f;
+		}
+	} else { /* Version 5 uses real kus values */
+		memcpy((UCHAR *) &local->sparm.b5, b5_default_startup_parms,
+		       sizeof(struct b5_startup_params));
+
+		local->sparm.b5.a_hop_time[0] = (hop_dwell >> 8) & 0xff;
+		local->sparm.b5.a_hop_time[1] = hop_dwell & 0xff;
+		local->sparm.b5.a_beacon_period[0] =
+		    (beacon_period >> 8) & 0xff;
+		local->sparm.b5.a_beacon_period[1] = beacon_period & 0xff;
+		if (psm)
+			local->sparm.b5.a_power_mgt_state = 1;
+		local->sparm.b5.a_curr_country_code = country;
+		local->sparm.b5.a_hop_pattern_length =
+		    hop_pattern_length[(int)country];
+	}
+
+	local->sparm.b4.a_network_type = net_type & 0x01;
+	local->sparm.b4.a_acting_as_ap_status = TYPE_STA;
+
+	if (essid != NULL)
+		strncpy(local->sparm.b4.a_current_ess_id, essid, ESSID_SIZE);
+} /* init_startup_params */
+
 /*===========================================================================*/
 static void verify_dl_startup(u_long data)
 {
-    ray_dev_t *local = (ray_dev_t *)data;
-    struct ccs __iomem *pccs = ccs_base(local) + local->dl_param_ccs;
-    UCHAR status;
-    struct pcmcia_device *link = local->finder;
+	ray_dev_t *local = (ray_dev_t *) data;
+	struct ccs __iomem *pccs = ccs_base(local) + local->dl_param_ccs;
+	UCHAR status;
+	struct pcmcia_device *link = local->finder;
 
-    if (!(pcmcia_dev_present(link))) {
-        DEBUG(2,"ray_cs verify_dl_startup - device not present\n");
-        return;
-    }
+	if (!(pcmcia_dev_present(link))) {
+		DEBUG(2, "ray_cs verify_dl_startup - device not present\n");
+		return;
+	}
 #ifdef PCMCIA_DEBUG
-    if (pc_debug > 2) {
-    int i;
-    printk(KERN_DEBUG "verify_dl_startup parameters sent via ccs %d:\n",
-           local->dl_param_ccs);
-        for (i=0; i<sizeof(struct b5_startup_params); i++) {
-            printk(" %2x", (unsigned int) readb(local->sram + HOST_TO_ECF_BASE + i));
-        }
-    printk("\n");
-    }
+	if (pc_debug > 2) {
+		int i;
+		printk(KERN_DEBUG
+		       "verify_dl_startup parameters sent via ccs %d:\n",
+		       local->dl_param_ccs);
+		for (i = 0; i < sizeof(struct b5_startup_params); i++) {
+			printk(" %2x",
+			       (unsigned int)readb(local->sram +
+						   HOST_TO_ECF_BASE + i));
+		}
+		printk("\n");
+	}
 #endif
 
-    status = readb(&pccs->buffer_status);
-    if (status!= CCS_BUFFER_FREE)
-    {
-        printk(KERN_INFO "Download startup params failed.  Status = %d\n",
-           status);
-        local->card_status = CARD_DL_PARAM_ERROR;
-        return;
-    }
-    if (local->sparm.b4.a_network_type == ADHOC)
-        start_net((u_long)local);
-    else
-        join_net((u_long)local);
-
-    return;
+	status = readb(&pccs->buffer_status);
+	if (status != CCS_BUFFER_FREE) {
+		printk(KERN_INFO
+		       "Download startup params failed.  Status = %d\n",
+		       status);
+		local->card_status = CARD_DL_PARAM_ERROR;
+		return;
+	}
+	if (local->sparm.b4.a_network_type == ADHOC)
+		start_net((u_long) local);
+	else
+		join_net((u_long) local);
+
+	return;
 } /* end verify_dl_startup */
+
 /*===========================================================================*/
 /* Command card to start a network */
 static void start_net(u_long data)
 {
-    ray_dev_t *local = (ray_dev_t *)data;
-    struct ccs __iomem *pccs;
-    int ccsindex;
-    struct pcmcia_device *link = local->finder;
-    if (!(pcmcia_dev_present(link))) {
-        DEBUG(2,"ray_cs start_net - device not present\n");
-        return;
-    }
-    /* Fill in the CCS fields for the ECF */
-    if ((ccsindex = get_free_ccs(local)) < 0) return;
-    pccs = ccs_base(local) + ccsindex;
-    writeb(CCS_START_NETWORK, &pccs->cmd);
-    writeb(0, &pccs->var.start_network.update_param);
-    /* Interrupt the firmware to process the command */
-    if (interrupt_ecf(local, ccsindex)) {
-        DEBUG(1,"ray start net failed - card not ready for intr\n");
-        writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
-        return;
-    }
-    local->card_status = CARD_DOING_ACQ;
-    return;
+	ray_dev_t *local = (ray_dev_t *) data;
+	struct ccs __iomem *pccs;
+	int ccsindex;
+	struct pcmcia_device *link = local->finder;
+	if (!(pcmcia_dev_present(link))) {
+		DEBUG(2, "ray_cs start_net - device not present\n");
+		return;
+	}
+	/* Fill in the CCS fields for the ECF */
+	if ((ccsindex = get_free_ccs(local)) < 0)
+		return;
+	pccs = ccs_base(local) + ccsindex;
+	writeb(CCS_START_NETWORK, &pccs->cmd);
+	writeb(0, &pccs->var.start_network.update_param);
+	/* Interrupt the firmware to process the command */
+	if (interrupt_ecf(local, ccsindex)) {
+		DEBUG(1, "ray start net failed - card not ready for intr\n");
+		writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
+		return;
+	}
+	local->card_status = CARD_DOING_ACQ;
+	return;
 } /* end start_net */
+
 /*===========================================================================*/
 /* Command card to join a network */
 static void join_net(u_long data)
 {
-    ray_dev_t *local = (ray_dev_t *)data;
-
-    struct ccs __iomem *pccs;
-    int ccsindex;
-    struct pcmcia_device *link = local->finder;
-    
-    if (!(pcmcia_dev_present(link))) {
-        DEBUG(2,"ray_cs join_net - device not present\n");
-        return;
-    }
-    /* Fill in the CCS fields for the ECF */
-    if ((ccsindex = get_free_ccs(local)) < 0) return;
-    pccs = ccs_base(local) + ccsindex;
-    writeb(CCS_JOIN_NETWORK, &pccs->cmd);
-    writeb(0, &pccs->var.join_network.update_param);
-    writeb(0, &pccs->var.join_network.net_initiated);
-    /* Interrupt the firmware to process the command */
-    if (interrupt_ecf(local, ccsindex)) {
-        DEBUG(1,"ray join net failed - card not ready for intr\n");
-        writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
-        return;
-    }
-    local->card_status = CARD_DOING_ACQ;
-    return;
+	ray_dev_t *local = (ray_dev_t *) data;
+
+	struct ccs __iomem *pccs;
+	int ccsindex;
+	struct pcmcia_device *link = local->finder;
+
+	if (!(pcmcia_dev_present(link))) {
+		DEBUG(2, "ray_cs join_net - device not present\n");
+		return;
+	}
+	/* Fill in the CCS fields for the ECF */
+	if ((ccsindex = get_free_ccs(local)) < 0)
+		return;
+	pccs = ccs_base(local) + ccsindex;
+	writeb(CCS_JOIN_NETWORK, &pccs->cmd);
+	writeb(0, &pccs->var.join_network.update_param);
+	writeb(0, &pccs->var.join_network.net_initiated);
+	/* Interrupt the firmware to process the command */
+	if (interrupt_ecf(local, ccsindex)) {
+		DEBUG(1, "ray join net failed - card not ready for intr\n");
+		writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
+		return;
+	}
+	local->card_status = CARD_DOING_ACQ;
+	return;
 }
+
 /*============================================================================
     After a card is removed, ray_release() will unregister the net
     device, and release the PCMCIA configuration.  If the device is
@@ -784,25 +809,27 @@ static void join_net(u_long data)
 =============================================================================*/
 static void ray_release(struct pcmcia_device *link)
 {
-    struct net_device *dev = link->priv; 
-    ray_dev_t *local = netdev_priv(dev);
-    int i;
-    
-    DEBUG(1, "ray_release(0x%p)\n", link);
-
-    del_timer(&local->timer);
-
-    iounmap(local->sram);
-    iounmap(local->rmem);
-    iounmap(local->amem);
-    /* Do bother checking to see if these succeed or not */
-    i = pcmcia_release_window(local->amem_handle);
-    if ( i != 0 ) DEBUG(0,"ReleaseWindow(local->amem) ret = %x\n",i);
-    i = pcmcia_release_window(local->rmem_handle);
-    if ( i != 0 ) DEBUG(0,"ReleaseWindow(local->rmem) ret = %x\n",i);
-    pcmcia_disable_device(link);
-
-    DEBUG(2,"ray_release ending\n");
+	struct net_device *dev = link->priv;
+	ray_dev_t *local = netdev_priv(dev);
+	int i;
+
+	DEBUG(1, "ray_release(0x%p)\n", link);
+
+	del_timer(&local->timer);
+
+	iounmap(local->sram);
+	iounmap(local->rmem);
+	iounmap(local->amem);
+	/* Do bother checking to see if these succeed or not */
+	i = pcmcia_release_window(local->amem_handle);
+	if (i != 0)
+		DEBUG(0, "ReleaseWindow(local->amem) ret = %x\n", i);
+	i = pcmcia_release_window(local->rmem_handle);
+	if (i != 0)
+		DEBUG(0, "ReleaseWindow(local->rmem) ret = %x\n", i);
+	pcmcia_disable_device(link);
+
+	DEBUG(2, "ray_release ending\n");
 }
 
 static int ray_suspend(struct pcmcia_device *link)
@@ -831,237 +858,243 @@ static int ray_resume(struct pcmcia_device *link)
 static int ray_dev_init(struct net_device *dev)
 {
 #ifdef RAY_IMMEDIATE_INIT
-    int i;
-#endif	/* RAY_IMMEDIATE_INIT */
-    ray_dev_t *local = netdev_priv(dev);
-    struct pcmcia_device *link = local->finder;
-
-    DEBUG(1,"ray_dev_init(dev=%p)\n",dev);
-    if (!(pcmcia_dev_present(link))) {
-        DEBUG(2,"ray_dev_init - device not present\n");
-        return -1;
-    }
+	int i;
+#endif /* RAY_IMMEDIATE_INIT */
+	ray_dev_t *local = netdev_priv(dev);
+	struct pcmcia_device *link = local->finder;
+
+	DEBUG(1, "ray_dev_init(dev=%p)\n", dev);
+	if (!(pcmcia_dev_present(link))) {
+		DEBUG(2, "ray_dev_init - device not present\n");
+		return -1;
+	}
 #ifdef RAY_IMMEDIATE_INIT
-    /* Download startup parameters */
-    if ( (i = dl_startup_params(dev)) < 0)
-    {
-        printk(KERN_INFO "ray_dev_init dl_startup_params failed - "
-           "returns 0x%x\n",i);
-        return -1;
-    }
-#else	/* RAY_IMMEDIATE_INIT */
-    /* Postpone the card init so that we can still configure the card,
-     * for example using the Wireless Extensions. The init will happen
-     * in ray_open() - Jean II */
-    DEBUG(1,"ray_dev_init: postponing card init to ray_open() ; Status = %d\n",
-	  local->card_status);
-#endif	/* RAY_IMMEDIATE_INIT */
-
-    /* copy mac and broadcast addresses to linux device */
-    memcpy(&dev->dev_addr, &local->sparm.b4.a_mac_addr, ADDRLEN);
-    memset(dev->broadcast, 0xff, ETH_ALEN);
-
-    DEBUG(2,"ray_dev_init ending\n");
-    return 0;
+	/* Download startup parameters */
+	if ((i = dl_startup_params(dev)) < 0) {
+		printk(KERN_INFO "ray_dev_init dl_startup_params failed - "
+		       "returns 0x%x\n", i);
+		return -1;
+	}
+#else /* RAY_IMMEDIATE_INIT */
+	/* Postpone the card init so that we can still configure the card,
+	 * for example using the Wireless Extensions. The init will happen
+	 * in ray_open() - Jean II */
+	DEBUG(1,
+	      "ray_dev_init: postponing card init to ray_open() ; Status = %d\n",
+	      local->card_status);
+#endif /* RAY_IMMEDIATE_INIT */
+
+	/* copy mac and broadcast addresses to linux device */
+	memcpy(&dev->dev_addr, &local->sparm.b4.a_mac_addr, ADDRLEN);
+	memset(dev->broadcast, 0xff, ETH_ALEN);
+
+	DEBUG(2, "ray_dev_init ending\n");
+	return 0;
 }
+
 /*===========================================================================*/
 static int ray_dev_config(struct net_device *dev, struct ifmap *map)
 {
-    ray_dev_t *local = netdev_priv(dev);
-    struct pcmcia_device *link = local->finder;
-    /* Dummy routine to satisfy device structure */
-    DEBUG(1,"ray_dev_config(dev=%p,ifmap=%p)\n",dev,map);
-    if (!(pcmcia_dev_present(link))) {
-        DEBUG(2,"ray_dev_config - device not present\n");
-        return -1;
-    }
+	ray_dev_t *local = netdev_priv(dev);
+	struct pcmcia_device *link = local->finder;
+	/* Dummy routine to satisfy device structure */
+	DEBUG(1, "ray_dev_config(dev=%p,ifmap=%p)\n", dev, map);
+	if (!(pcmcia_dev_present(link))) {
+		DEBUG(2, "ray_dev_config - device not present\n");
+		return -1;
+	}
 
-    return 0;
+	return 0;
 }
+
 /*===========================================================================*/
 static int ray_dev_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-    ray_dev_t *local = netdev_priv(dev);
-    struct pcmcia_device *link = local->finder;
-    short length = skb->len;
-
-    if (!(pcmcia_dev_present(link))) {
-        DEBUG(2,"ray_dev_start_xmit - device not present\n");
-        return -1;
-    }
-    DEBUG(3,"ray_dev_start_xmit(skb=%p, dev=%p)\n",skb,dev);
-    if (local->authentication_state == NEED_TO_AUTH) {
-        DEBUG(0,"ray_cs Sending authentication request.\n");
-        if (!build_auth_frame (local, local->auth_id, OPEN_AUTH_REQUEST)) {
-            local->authentication_state = AUTHENTICATED;
-            netif_stop_queue(dev);
-            return 1;
-        }
-    }
-
-    if (length < ETH_ZLEN)
-    {
-    	if (skb_padto(skb, ETH_ZLEN))
-    		return 0;
-    	length = ETH_ZLEN;
-    }
-    switch (ray_hw_xmit( skb->data, length, dev, DATA_TYPE)) {
-        case XMIT_NO_CCS:
-        case XMIT_NEED_AUTH:
-	    netif_stop_queue(dev);
-            return 1;
-        case XMIT_NO_INTR:
-        case XMIT_MSG_BAD:
-        case XMIT_OK:
-        default:
-            dev->trans_start = jiffies;
-            dev_kfree_skb(skb);
-            return 0;
-    }
-    return 0;
+	ray_dev_t *local = netdev_priv(dev);
+	struct pcmcia_device *link = local->finder;
+	short length = skb->len;
+
+	if (!(pcmcia_dev_present(link))) {
+		DEBUG(2, "ray_dev_start_xmit - device not present\n");
+		return -1;
+	}
+	DEBUG(3, "ray_dev_start_xmit(skb=%p, dev=%p)\n", skb, dev);
+	if (local->authentication_state == NEED_TO_AUTH) {
+		DEBUG(0, "ray_cs Sending authentication request.\n");
+		if (!build_auth_frame(local, local->auth_id, OPEN_AUTH_REQUEST)) {
+			local->authentication_state = AUTHENTICATED;
+			netif_stop_queue(dev);
+			return 1;
+		}
+	}
+
+	if (length < ETH_ZLEN) {
+		if (skb_padto(skb, ETH_ZLEN))
+			return 0;
+		length = ETH_ZLEN;
+	}
+	switch (ray_hw_xmit(skb->data, length, dev, DATA_TYPE)) {
+	case XMIT_NO_CCS:
+	case XMIT_NEED_AUTH:
+		netif_stop_queue(dev);
+		return 1;
+	case XMIT_NO_INTR:
+	case XMIT_MSG_BAD:
+	case XMIT_OK:
+	default:
+		dev->trans_start = jiffies;
+		dev_kfree_skb(skb);
+		return 0;
+	}
+	return 0;
 } /* ray_dev_start_xmit */
+
 /*===========================================================================*/
-static int ray_hw_xmit(unsigned char* data, int len, struct net_device* dev, 
-                UCHAR msg_type)
-{
-    ray_dev_t *local = netdev_priv(dev);
-    struct ccs __iomem *pccs;
-    int ccsindex;
-    int offset;
-    struct tx_msg __iomem *ptx; /* Address of xmit buffer in PC space */
-    short int addr;     /* Address of xmit buffer in card space */
-    
-    DEBUG(3,"ray_hw_xmit(data=%p, len=%d, dev=%p)\n",data,len,dev);
-    if (len + TX_HEADER_LENGTH > TX_BUF_SIZE)
-    {
-        printk(KERN_INFO "ray_hw_xmit packet too large: %d bytes\n",len);
-        return XMIT_MSG_BAD;
-    }
+static int ray_hw_xmit(unsigned char *data, int len, struct net_device *dev,
+		       UCHAR msg_type)
+{
+	ray_dev_t *local = netdev_priv(dev);
+	struct ccs __iomem *pccs;
+	int ccsindex;
+	int offset;
+	struct tx_msg __iomem *ptx;	/* Address of xmit buffer in PC space */
+	short int addr;		/* Address of xmit buffer in card space */
+
+	DEBUG(3, "ray_hw_xmit(data=%p, len=%d, dev=%p)\n", data, len, dev);
+	if (len + TX_HEADER_LENGTH > TX_BUF_SIZE) {
+		printk(KERN_INFO "ray_hw_xmit packet too large: %d bytes\n",
+		       len);
+		return XMIT_MSG_BAD;
+	}
 	switch (ccsindex = get_free_tx_ccs(local)) {
 	case ECCSBUSY:
-		DEBUG(2,"ray_hw_xmit tx_ccs table busy\n");
+		DEBUG(2, "ray_hw_xmit tx_ccs table busy\n");
 	case ECCSFULL:
-        DEBUG(2,"ray_hw_xmit No free tx ccs\n");
+		DEBUG(2, "ray_hw_xmit No free tx ccs\n");
 	case ECARDGONE:
-	netif_stop_queue(dev);
-        return XMIT_NO_CCS;
+		netif_stop_queue(dev);
+		return XMIT_NO_CCS;
 	default:
 		break;
 	}
-    addr = TX_BUF_BASE + (ccsindex << 11);
-
-    if (msg_type == DATA_TYPE) {
-        local->stats.tx_bytes += len;
-        local->stats.tx_packets++;
-    }
-
-    ptx = local->sram + addr;
-
-    ray_build_header(local, ptx, msg_type, data);
-    if (translate) {
-        offset = translate_frame(local, ptx, data, len);
-    }
-    else { /* Encapsulate frame */
-        /* TBD TIB length will move address of ptx->var */
-        memcpy_toio(&ptx->var, data, len);
-        offset = 0;
-    }
-
-    /* fill in the CCS */
-    pccs = ccs_base(local) + ccsindex;
-    len += TX_HEADER_LENGTH + offset;
-    writeb(CCS_TX_REQUEST, &pccs->cmd);
-    writeb(addr >> 8, &pccs->var.tx_request.tx_data_ptr[0]);
-    writeb(local->tib_length, &pccs->var.tx_request.tx_data_ptr[1]);
-    writeb(len >> 8, &pccs->var.tx_request.tx_data_length[0]);
-    writeb(len & 0xff, &pccs->var.tx_request.tx_data_length[1]);
+	addr = TX_BUF_BASE + (ccsindex << 11);
+
+	if (msg_type == DATA_TYPE) {
+		local->stats.tx_bytes += len;
+		local->stats.tx_packets++;
+	}
+
+	ptx = local->sram + addr;
+
+	ray_build_header(local, ptx, msg_type, data);
+	if (translate) {
+		offset = translate_frame(local, ptx, data, len);
+	} else { /* Encapsulate frame */
+		/* TBD TIB length will move address of ptx->var */
+		memcpy_toio(&ptx->var, data, len);
+		offset = 0;
+	}
+
+	/* fill in the CCS */
+	pccs = ccs_base(local) + ccsindex;
+	len += TX_HEADER_LENGTH + offset;
+	writeb(CCS_TX_REQUEST, &pccs->cmd);
+	writeb(addr >> 8, &pccs->var.tx_request.tx_data_ptr[0]);
+	writeb(local->tib_length, &pccs->var.tx_request.tx_data_ptr[1]);
+	writeb(len >> 8, &pccs->var.tx_request.tx_data_length[0]);
+	writeb(len & 0xff, &pccs->var.tx_request.tx_data_length[1]);
 /* TBD still need psm_cam? */
-    writeb(PSM_CAM, &pccs->var.tx_request.pow_sav_mode);
-    writeb(local->net_default_tx_rate, &pccs->var.tx_request.tx_rate);
-    writeb(0, &pccs->var.tx_request.antenna);
-    DEBUG(3,"ray_hw_xmit default_tx_rate = 0x%x\n",\
-          local->net_default_tx_rate);
-
-    /* Interrupt the firmware to process the command */
-    if (interrupt_ecf(local, ccsindex)) {
-        DEBUG(2,"ray_hw_xmit failed - ECF not ready for intr\n");
+	writeb(PSM_CAM, &pccs->var.tx_request.pow_sav_mode);
+	writeb(local->net_default_tx_rate, &pccs->var.tx_request.tx_rate);
+	writeb(0, &pccs->var.tx_request.antenna);
+	DEBUG(3, "ray_hw_xmit default_tx_rate = 0x%x\n",
+	      local->net_default_tx_rate);
+
+	/* Interrupt the firmware to process the command */
+	if (interrupt_ecf(local, ccsindex)) {
+		DEBUG(2, "ray_hw_xmit failed - ECF not ready for intr\n");
 /* TBD very inefficient to copy packet to buffer, and then not
    send it, but the alternative is to queue the messages and that
    won't be done for a while.  Maybe set tbusy until a CCS is free?
 */
-        writeb(CCS_BUFFER_FREE, &pccs->buffer_status);
-        return XMIT_NO_INTR;
-    }
-    return XMIT_OK;
+		writeb(CCS_BUFFER_FREE, &pccs->buffer_status);
+		return XMIT_NO_INTR;
+	}
+	return XMIT_OK;
 } /* end ray_hw_xmit */
+
 /*===========================================================================*/
-static int translate_frame(ray_dev_t *local, struct tx_msg __iomem *ptx, unsigned char *data,
-                    int len)
-{
-    __be16 proto = ((struct ethhdr *)data)->h_proto;
-    if (ntohs(proto) >= 1536) { /* DIX II ethernet frame */
-        DEBUG(3,"ray_cs translate_frame DIX II\n");
-        /* Copy LLC header to card buffer */
-        memcpy_toio(&ptx->var, eth2_llc, sizeof(eth2_llc));
-        memcpy_toio( ((void __iomem *)&ptx->var) + sizeof(eth2_llc), (UCHAR *)&proto, 2);
-        if (proto == htons(ETH_P_AARP) || proto == htons(ETH_P_IPX)) {
-            /* This is the selective translation table, only 2 entries */
-            writeb(0xf8, &((struct snaphdr_t __iomem *)ptx->var)->org[3]);
-        }
-        /* Copy body of ethernet packet without ethernet header */
-        memcpy_toio((void __iomem *)&ptx->var + sizeof(struct snaphdr_t), \
-                    data + ETH_HLEN,  len - ETH_HLEN);
-        return (int) sizeof(struct snaphdr_t) - ETH_HLEN;
-    }
-    else { /* already  802 type, and proto is length */
-        DEBUG(3,"ray_cs translate_frame 802\n");
-        if (proto == htons(0xffff)) { /* evil netware IPX 802.3 without LLC */
-        DEBUG(3,"ray_cs translate_frame evil IPX\n");
-            memcpy_toio(&ptx->var, data + ETH_HLEN,  len - ETH_HLEN);
-            return 0 - ETH_HLEN;
-        }
-        memcpy_toio(&ptx->var, data + ETH_HLEN,  len - ETH_HLEN);
-        return 0 - ETH_HLEN;
-    }
-    /* TBD do other frame types */
+static int translate_frame(ray_dev_t *local, struct tx_msg __iomem *ptx,
+			   unsigned char *data, int len)
+{
+	__be16 proto = ((struct ethhdr *)data)->h_proto;
+	if (ntohs(proto) >= 1536) { /* DIX II ethernet frame */
+		DEBUG(3, "ray_cs translate_frame DIX II\n");
+		/* Copy LLC header to card buffer */
+		memcpy_toio(&ptx->var, eth2_llc, sizeof(eth2_llc));
+		memcpy_toio(((void __iomem *)&ptx->var) + sizeof(eth2_llc),
+			    (UCHAR *) &proto, 2);
+		if (proto == htons(ETH_P_AARP) || proto == htons(ETH_P_IPX)) {
+			/* This is the selective translation table, only 2 entries */
+			writeb(0xf8,
+			       &((struct snaphdr_t __iomem *)ptx->var)->org[3]);
+		}
+		/* Copy body of ethernet packet without ethernet header */
+		memcpy_toio((void __iomem *)&ptx->var +
+			    sizeof(struct snaphdr_t), data + ETH_HLEN,
+			    len - ETH_HLEN);
+		return (int)sizeof(struct snaphdr_t) - ETH_HLEN;
+	} else { /* already  802 type, and proto is length */
+		DEBUG(3, "ray_cs translate_frame 802\n");
+		if (proto == htons(0xffff)) { /* evil netware IPX 802.3 without LLC */
+			DEBUG(3, "ray_cs translate_frame evil IPX\n");
+			memcpy_toio(&ptx->var, data + ETH_HLEN, len - ETH_HLEN);
+			return 0 - ETH_HLEN;
+		}
+		memcpy_toio(&ptx->var, data + ETH_HLEN, len - ETH_HLEN);
+		return 0 - ETH_HLEN;
+	}
+	/* TBD do other frame types */
 } /* end translate_frame */
+
 /*===========================================================================*/
-static void ray_build_header(ray_dev_t *local, struct tx_msg __iomem *ptx, UCHAR msg_type,
-                unsigned char *data)
+static void ray_build_header(ray_dev_t *local, struct tx_msg __iomem *ptx,
+			     UCHAR msg_type, unsigned char *data)
 {
-    writeb(PROTOCOL_VER | msg_type, &ptx->mac.frame_ctl_1);
+	writeb(PROTOCOL_VER | msg_type, &ptx->mac.frame_ctl_1);
 /*** IEEE 802.11 Address field assignments *************
-                TODS FROMDS   addr_1     addr_2          addr_3   addr_4
-Adhoc           0    0        dest       src (terminal)  BSSID    N/A
-AP to Terminal  0    1        dest       AP(BSSID)       source   N/A
-Terminal to AP  1    0        AP(BSSID)  src (terminal)  dest     N/A
-AP to AP        1    1        dest AP    src AP          dest     source      
+		TODS	FROMDS	addr_1		addr_2		addr_3	addr_4
+Adhoc		0	0	dest		src (terminal)	BSSID	N/A
+AP to Terminal	0	1	dest		AP(BSSID)	source	N/A
+Terminal to AP	1	0	AP(BSSID)	src (terminal)	dest	N/A
+AP to AP	1	1	dest AP		src AP		dest	source
 *******************************************************/
-    if (local->net_type == ADHOC) {   
-        writeb(0, &ptx->mac.frame_ctl_2);
-        memcpy_toio(ptx->mac.addr_1, ((struct ethhdr *)data)->h_dest, 2 * ADDRLEN);
-        memcpy_toio(ptx->mac.addr_3, local->bss_id, ADDRLEN);
-    }
-    else /* infrastructure */
-    {
-        if (local->sparm.b4.a_acting_as_ap_status)
-        {
-            writeb(FC2_FROM_DS, &ptx->mac.frame_ctl_2);
-            memcpy_toio(ptx->mac.addr_1, ((struct ethhdr *)data)->h_dest, ADDRLEN);
-            memcpy_toio(ptx->mac.addr_2, local->bss_id, 6);
-            memcpy_toio(ptx->mac.addr_3, ((struct ethhdr *)data)->h_source, ADDRLEN);
-        }
-        else /* Terminal */
-        {
-            writeb(FC2_TO_DS, &ptx->mac.frame_ctl_2);
-            memcpy_toio(ptx->mac.addr_1, local->bss_id, ADDRLEN);
-            memcpy_toio(ptx->mac.addr_2, ((struct ethhdr *)data)->h_source, ADDRLEN);
-            memcpy_toio(ptx->mac.addr_3, ((struct ethhdr *)data)->h_dest, ADDRLEN);
-        }
-    }
+	if (local->net_type == ADHOC) {
+		writeb(0, &ptx->mac.frame_ctl_2);
+		memcpy_toio(ptx->mac.addr_1, ((struct ethhdr *)data)->h_dest,
+			    2 * ADDRLEN);
+		memcpy_toio(ptx->mac.addr_3, local->bss_id, ADDRLEN);
+	} else { /* infrastructure */
+
+		if (local->sparm.b4.a_acting_as_ap_status) {
+			writeb(FC2_FROM_DS, &ptx->mac.frame_ctl_2);
+			memcpy_toio(ptx->mac.addr_1,
+				    ((struct ethhdr *)data)->h_dest, ADDRLEN);
+			memcpy_toio(ptx->mac.addr_2, local->bss_id, 6);
+			memcpy_toio(ptx->mac.addr_3,
+				    ((struct ethhdr *)data)->h_source, ADDRLEN);
+		} else { /* Terminal */
+
+			writeb(FC2_TO_DS, &ptx->mac.frame_ctl_2);
+			memcpy_toio(ptx->mac.addr_1, local->bss_id, ADDRLEN);
+			memcpy_toio(ptx->mac.addr_2,
+				    ((struct ethhdr *)data)->h_source, ADDRLEN);
+			memcpy_toio(ptx->mac.addr_3,
+				    ((struct ethhdr *)data)->h_dest, ADDRLEN);
+		}
+	}
 } /* end encapsulate_frame */
 
-
 /*===========================================================================*/
 
 static void netdev_get_drvinfo(struct net_device *dev,
@@ -1071,7 +1104,7 @@ static void netdev_get_drvinfo(struct net_device *dev,
 }
 
 static const struct ethtool_ops netdev_ethtool_ops = {
-	.get_drvinfo		= netdev_get_drvinfo,
+	.get_drvinfo = netdev_get_drvinfo,
 };
 
 /*====================================================================*/
@@ -1081,9 +1114,7 @@ static const struct ethtool_ops netdev_ethtool_ops = {
  * Wireless Handler : get protocol name
  */
 static int ray_get_name(struct net_device *dev,
-			struct iw_request_info *info,
-			char *cwrq,
-			char *extra)
+			struct iw_request_info *info, char *cwrq, char *extra)
 {
 	strcpy(cwrq, "IEEE 802.11-FH");
 	return 0;
@@ -1095,14 +1126,13 @@ static int ray_get_name(struct net_device *dev,
  */
 static int ray_set_freq(struct net_device *dev,
 			struct iw_request_info *info,
-			struct iw_freq *fwrq,
-			char *extra)
+			struct iw_freq *fwrq, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
-	int err = -EINPROGRESS;		/* Call commit handler */
+	int err = -EINPROGRESS;	/* Call commit handler */
 
 	/* Reject if card is already initialised */
-	if(local->card_status != CARD_AWAITING_PARAM)
+	if (local->card_status != CARD_AWAITING_PARAM)
 		return -EBUSY;
 
 	/* Setting by channel number */
@@ -1113,15 +1143,14 @@ static int ray_set_freq(struct net_device *dev,
 
 	return err;
 }
- 
+
 /*------------------------------------------------------------------*/
 /*
  * Wireless Handler : get frequency
  */
 static int ray_get_freq(struct net_device *dev,
 			struct iw_request_info *info,
-			struct iw_freq *fwrq,
-			char *extra)
+			struct iw_freq *fwrq, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 
@@ -1136,22 +1165,21 @@ static int ray_get_freq(struct net_device *dev,
  */
 static int ray_set_essid(struct net_device *dev,
 			 struct iw_request_info *info,
-			 struct iw_point *dwrq,
-			 char *extra)
+			 struct iw_point *dwrq, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 
 	/* Reject if card is already initialised */
-	if(local->card_status != CARD_AWAITING_PARAM)
+	if (local->card_status != CARD_AWAITING_PARAM)
 		return -EBUSY;
 
 	/* Check if we asked for `any' */
-	if(dwrq->flags == 0) {
+	if (dwrq->flags == 0) {
 		/* Corey : can you do that ? */
 		return -EOPNOTSUPP;
 	} else {
 		/* Check the size of the string */
-		if(dwrq->length > IW_ESSID_MAX_SIZE) {
+		if (dwrq->length > IW_ESSID_MAX_SIZE) {
 			return -E2BIG;
 		}
 
@@ -1160,7 +1188,7 @@ static int ray_set_essid(struct net_device *dev,
 		memcpy(local->sparm.b5.a_current_ess_id, extra, dwrq->length);
 	}
 
-	return -EINPROGRESS;		/* Call commit handler */
+	return -EINPROGRESS;	/* Call commit handler */
 }
 
 /*------------------------------------------------------------------*/
@@ -1169,8 +1197,7 @@ static int ray_set_essid(struct net_device *dev,
  */
 static int ray_get_essid(struct net_device *dev,
 			 struct iw_request_info *info,
-			 struct iw_point *dwrq,
-			 char *extra)
+			 struct iw_point *dwrq, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 
@@ -1179,7 +1206,7 @@ static int ray_get_essid(struct net_device *dev,
 
 	/* Push it out ! */
 	dwrq->length = strlen(extra);
-	dwrq->flags = 1; /* active */
+	dwrq->flags = 1;	/* active */
 
 	return 0;
 }
@@ -1189,9 +1216,8 @@ static int ray_get_essid(struct net_device *dev,
  * Wireless Handler : get AP address
  */
 static int ray_get_wap(struct net_device *dev,
-			struct iw_request_info *info,
-			struct sockaddr *awrq,
-			char *extra)
+		       struct iw_request_info *info,
+		       struct sockaddr *awrq, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 
@@ -1207,25 +1233,24 @@ static int ray_get_wap(struct net_device *dev,
  */
 static int ray_set_rate(struct net_device *dev,
 			struct iw_request_info *info,
-			struct iw_param *vwrq,
-			char *extra)
+			struct iw_param *vwrq, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 
 	/* Reject if card is already initialised */
-	if(local->card_status != CARD_AWAITING_PARAM)
+	if (local->card_status != CARD_AWAITING_PARAM)
 		return -EBUSY;
 
 	/* Check if rate is in range */
-	if((vwrq->value != 1000000) && (vwrq->value != 2000000))
+	if ((vwrq->value != 1000000) && (vwrq->value != 2000000))
 		return -EINVAL;
 
 	/* Hack for 1.5 Mb/s instead of 2 Mb/s */
-	if((local->fw_ver == 0x55) &&		/* Please check */
-	   (vwrq->value == 2000000))
+	if ((local->fw_ver == 0x55) &&	/* Please check */
+	    (vwrq->value == 2000000))
 		local->net_default_tx_rate = 3;
 	else
-		local->net_default_tx_rate = vwrq->value/500000;
+		local->net_default_tx_rate = vwrq->value / 500000;
 
 	return 0;
 }
@@ -1236,16 +1261,15 @@ static int ray_set_rate(struct net_device *dev,
  */
 static int ray_get_rate(struct net_device *dev,
 			struct iw_request_info *info,
-			struct iw_param *vwrq,
-			char *extra)
+			struct iw_param *vwrq, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 
-	if(local->net_default_tx_rate == 3)
-		vwrq->value = 2000000;		/* Hum... */
+	if (local->net_default_tx_rate == 3)
+		vwrq->value = 2000000;	/* Hum... */
 	else
 		vwrq->value = local->net_default_tx_rate * 500000;
-	vwrq->fixed = 0;		/* We are in auto mode */
+	vwrq->fixed = 0;	/* We are in auto mode */
 
 	return 0;
 }
@@ -1256,43 +1280,40 @@ static int ray_get_rate(struct net_device *dev,
  */
 static int ray_set_rts(struct net_device *dev,
 		       struct iw_request_info *info,
-		       struct iw_param *vwrq,
-		       char *extra)
+		       struct iw_param *vwrq, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 	int rthr = vwrq->value;
 
 	/* Reject if card is already initialised */
-	if(local->card_status != CARD_AWAITING_PARAM)
+	if (local->card_status != CARD_AWAITING_PARAM)
 		return -EBUSY;
 
 	/* if(wrq->u.rts.fixed == 0) we should complain */
-	if(vwrq->disabled)
+	if (vwrq->disabled)
 		rthr = 32767;
 	else {
-		if((rthr < 0) || (rthr > 2347)) /* What's the max packet size ??? */
+		if ((rthr < 0) || (rthr > 2347))   /* What's the max packet size ??? */
 			return -EINVAL;
 	}
 	local->sparm.b5.a_rts_threshold[0] = (rthr >> 8) & 0xFF;
 	local->sparm.b5.a_rts_threshold[1] = rthr & 0xFF;
 
-	return -EINPROGRESS;		/* Call commit handler */
+	return -EINPROGRESS;	/* Call commit handler */
 }
 
-
 /*------------------------------------------------------------------*/
 /*
  * Wireless Handler : get RTS threshold
  */
 static int ray_get_rts(struct net_device *dev,
 		       struct iw_request_info *info,
-		       struct iw_param *vwrq,
-		       char *extra)
+		       struct iw_param *vwrq, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 
 	vwrq->value = (local->sparm.b5.a_rts_threshold[0] << 8)
-		+ local->sparm.b5.a_rts_threshold[1];
+	    + local->sparm.b5.a_rts_threshold[1];
 	vwrq->disabled = (vwrq->value == 32767);
 	vwrq->fixed = 1;
 
@@ -1305,27 +1326,26 @@ static int ray_get_rts(struct net_device *dev,
  */
 static int ray_set_frag(struct net_device *dev,
 			struct iw_request_info *info,
-			struct iw_param *vwrq,
-			char *extra)
+			struct iw_param *vwrq, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 	int fthr = vwrq->value;
 
 	/* Reject if card is already initialised */
-	if(local->card_status != CARD_AWAITING_PARAM)
+	if (local->card_status != CARD_AWAITING_PARAM)
 		return -EBUSY;
 
 	/* if(wrq->u.frag.fixed == 0) should complain */
-	if(vwrq->disabled)
+	if (vwrq->disabled)
 		fthr = 32767;
 	else {
-		if((fthr < 256) || (fthr > 2347)) /* To check out ! */
+		if ((fthr < 256) || (fthr > 2347))	/* To check out ! */
 			return -EINVAL;
 	}
 	local->sparm.b5.a_frag_threshold[0] = (fthr >> 8) & 0xFF;
 	local->sparm.b5.a_frag_threshold[1] = fthr & 0xFF;
 
-	return -EINPROGRESS;		/* Call commit handler */
+	return -EINPROGRESS;	/* Call commit handler */
 }
 
 /*------------------------------------------------------------------*/
@@ -1334,13 +1354,12 @@ static int ray_set_frag(struct net_device *dev,
  */
 static int ray_get_frag(struct net_device *dev,
 			struct iw_request_info *info,
-			struct iw_param *vwrq,
-			char *extra)
+			struct iw_param *vwrq, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 
 	vwrq->value = (local->sparm.b5.a_frag_threshold[0] << 8)
-		+ local->sparm.b5.a_frag_threshold[1];
+	    + local->sparm.b5.a_frag_threshold[1];
 	vwrq->disabled = (vwrq->value == 32767);
 	vwrq->fixed = 1;
 
@@ -1352,23 +1371,20 @@ static int ray_get_frag(struct net_device *dev,
  * Wireless Handler : set Mode of Operation
  */
 static int ray_set_mode(struct net_device *dev,
-			struct iw_request_info *info,
-			__u32 *uwrq,
-			char *extra)
+			struct iw_request_info *info, __u32 *uwrq, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
-	int err = -EINPROGRESS;		/* Call commit handler */
+	int err = -EINPROGRESS;	/* Call commit handler */
 	char card_mode = 1;
 
 	/* Reject if card is already initialised */
-	if(local->card_status != CARD_AWAITING_PARAM)
+	if (local->card_status != CARD_AWAITING_PARAM)
 		return -EBUSY;
 
-	switch (*uwrq)
-	{
+	switch (*uwrq) {
 	case IW_MODE_ADHOC:
 		card_mode = 0;
-		// Fall through
+		/* Fall through */
 	case IW_MODE_INFRA:
 		local->sparm.b5.a_network_type = card_mode;
 		break;
@@ -1384,13 +1400,11 @@ static int ray_set_mode(struct net_device *dev,
  * Wireless Handler : get Mode of Operation
  */
 static int ray_get_mode(struct net_device *dev,
-			struct iw_request_info *info,
-			__u32 *uwrq,
-			char *extra)
+			struct iw_request_info *info, __u32 *uwrq, char *extra)
 {
 	ray_dev_t *local = netdev_priv(dev);
 
-	if(local->sparm.b5.a_network_type)
+	if (local->sparm.b5.a_network_type)
 		*uwrq = IW_MODE_INFRA;
 	else
 		*uwrq = IW_MODE_ADHOC;
@@ -1404,12 +1418,11 @@ static int ray_get_mode(struct net_device *dev,
  */
 static int ray_get_range(struct net_device *dev,
 			 struct iw_request_info *info,
-			 struct iw_point *dwrq,
-			 char *extra)
+			 struct iw_point *dwrq, char *extra)
 {
-	struct iw_range *range = (struct iw_range *) extra;
+	struct iw_range *range = (struct iw_range *)extra;
 
-	memset((char *) range, 0, sizeof(struct iw_range));
+	memset((char *)range, 0, sizeof(struct iw_range));
 
 	/* Set the length (very important for backward compatibility) */
 	dwrq->length = sizeof(struct iw_range);
@@ -1420,7 +1433,7 @@ static int ray_get_range(struct net_device *dev,
 
 	/* Set information in the range struct */
 	range->throughput = 1.1 * 1000 * 1000;	/* Put the right number here */
-	range->num_channels = hop_pattern_length[(int)country]; 
+	range->num_channels = hop_pattern_length[(int)country];
 	range->num_frequency = 0;
 	range->max_qual.qual = 0;
 	range->max_qual.level = 255;	/* What's the correct value ? */
@@ -1437,8 +1450,7 @@ static int ray_get_range(struct net_device *dev,
  */
 static int ray_set_framing(struct net_device *dev,
 			   struct iw_request_info *info,
-			   union iwreq_data *wrqu,
-			   char *extra)
+			   union iwreq_data *wrqu, char *extra)
 {
 	translate = *(extra);	/* Set framing mode */
 
@@ -1451,8 +1463,7 @@ static int ray_set_framing(struct net_device *dev,
  */
 static int ray_get_framing(struct net_device *dev,
 			   struct iw_request_info *info,
-			   union iwreq_data *wrqu,
-			   char *extra)
+			   union iwreq_data *wrqu, char *extra)
 {
 	*(extra) = translate;
 
@@ -1465,8 +1476,7 @@ static int ray_get_framing(struct net_device *dev,
  */
 static int ray_get_country(struct net_device *dev,
 			   struct iw_request_info *info,
-			   union iwreq_data *wrqu,
-			   char *extra)
+			   union iwreq_data *wrqu, char *extra)
 {
 	*(extra) = country;
 
@@ -1477,11 +1487,10 @@ static int ray_get_country(struct net_device *dev,
 /*
  * Commit handler : called after a bunch of SET operations
  */
-static int ray_commit(struct net_device *dev,
-		      struct iw_request_info *info,	/* NULL */
-		      void *zwrq,			/* NULL */
-		      char *extra)			/* NULL */
-{
+static int ray_commit(struct net_device *dev, struct iw_request_info *info,	/* NULL */
+		      void *zwrq,	/* NULL */
+		      char *extra)
+{ /* NULL */
 	return 0;
 }
 
@@ -1489,33 +1498,34 @@ static int ray_commit(struct net_device *dev,
 /*
  * Stats handler : return Wireless Stats
  */
-static iw_stats * ray_get_wireless_stats(struct net_device *	dev)
+static iw_stats *ray_get_wireless_stats(struct net_device *dev)
 {
-  ray_dev_t *	local = netdev_priv(dev);
-  struct pcmcia_device *link = local->finder;
-  struct status __iomem *p = local->sram + STATUS_BASE;
+	ray_dev_t *local = netdev_priv(dev);
+	struct pcmcia_device *link = local->finder;
+	struct status __iomem *p = local->sram + STATUS_BASE;
 
-  if(local == (ray_dev_t *) NULL)
-    return (iw_stats *) NULL;
+	if (local == (ray_dev_t *) NULL)
+		return (iw_stats *) NULL;
 
-  local->wstats.status = local->card_status;
+	local->wstats.status = local->card_status;
 #ifdef WIRELESS_SPY
-  if((local->spy_data.spy_number > 0) && (local->sparm.b5.a_network_type == 0))
-    {
-      /* Get it from the first node in spy list */
-      local->wstats.qual.qual = local->spy_data.spy_stat[0].qual;
-      local->wstats.qual.level = local->spy_data.spy_stat[0].level;
-      local->wstats.qual.noise = local->spy_data.spy_stat[0].noise;
-      local->wstats.qual.updated = local->spy_data.spy_stat[0].updated;
-    }
+	if ((local->spy_data.spy_number > 0)
+	    && (local->sparm.b5.a_network_type == 0)) {
+		/* Get it from the first node in spy list */
+		local->wstats.qual.qual = local->spy_data.spy_stat[0].qual;
+		local->wstats.qual.level = local->spy_data.spy_stat[0].level;
+		local->wstats.qual.noise = local->spy_data.spy_stat[0].noise;
+		local->wstats.qual.updated =
+		    local->spy_data.spy_stat[0].updated;
+	}
 #endif /* WIRELESS_SPY */
 
-  if(pcmcia_dev_present(link)) {
-    local->wstats.qual.noise = readb(&p->rxnoise);
-    local->wstats.qual.updated |= 4;
-  }
+	if (pcmcia_dev_present(link)) {
+		local->wstats.qual.noise = readb(&p->rxnoise);
+		local->wstats.qual.updated |= 4;
+	}
 
-  return &local->wstats;
+	return &local->wstats;
 } /* end ray_get_wireless_stats */
 
 /*------------------------------------------------------------------*/
@@ -1523,1159 +1533,1264 @@ static iw_stats * ray_get_wireless_stats(struct net_device *	dev)
  * Structures to export the Wireless Handlers
  */
 
-static const iw_handler	ray_handler[] = {
-	[SIOCSIWCOMMIT-SIOCIWFIRST] = (iw_handler) ray_commit,
-	[SIOCGIWNAME  -SIOCIWFIRST] = (iw_handler) ray_get_name,
-	[SIOCSIWFREQ  -SIOCIWFIRST] = (iw_handler) ray_set_freq,
-	[SIOCGIWFREQ  -SIOCIWFIRST] = (iw_handler) ray_get_freq,
-	[SIOCSIWMODE  -SIOCIWFIRST] = (iw_handler) ray_set_mode,
-	[SIOCGIWMODE  -SIOCIWFIRST] = (iw_handler) ray_get_mode,
-	[SIOCGIWRANGE -SIOCIWFIRST] = (iw_handler) ray_get_range,
+static const iw_handler ray_handler[] = {
+	[SIOCSIWCOMMIT - SIOCIWFIRST] = (iw_handler) ray_commit,
+	[SIOCGIWNAME - SIOCIWFIRST] = (iw_handler) ray_get_name,
+	[SIOCSIWFREQ - SIOCIWFIRST] = (iw_handler) ray_set_freq,
+	[SIOCGIWFREQ - SIOCIWFIRST] = (iw_handler) ray_get_freq,
+	[SIOCSIWMODE - SIOCIWFIRST] = (iw_handler) ray_set_mode,
+	[SIOCGIWMODE - SIOCIWFIRST] = (iw_handler) ray_get_mode,
+	[SIOCGIWRANGE - SIOCIWFIRST] = (iw_handler) ray_get_range,
 #ifdef WIRELESS_SPY
- 	[SIOCSIWSPY   -SIOCIWFIRST] = (iw_handler) iw_handler_set_spy,
-	[SIOCGIWSPY   -SIOCIWFIRST] = (iw_handler) iw_handler_get_spy,
-	[SIOCSIWTHRSPY-SIOCIWFIRST] = (iw_handler) iw_handler_set_thrspy,
-	[SIOCGIWTHRSPY-SIOCIWFIRST] = (iw_handler) iw_handler_get_thrspy,
-#endif	/* WIRELESS_SPY */
-	[SIOCGIWAP    -SIOCIWFIRST] = (iw_handler) ray_get_wap,
-	[SIOCSIWESSID -SIOCIWFIRST] = (iw_handler) ray_set_essid,
-	[SIOCGIWESSID -SIOCIWFIRST] = (iw_handler) ray_get_essid,
-	[SIOCSIWRATE  -SIOCIWFIRST] = (iw_handler) ray_set_rate,
-	[SIOCGIWRATE  -SIOCIWFIRST] = (iw_handler) ray_get_rate,
-	[SIOCSIWRTS   -SIOCIWFIRST] = (iw_handler) ray_set_rts,
-	[SIOCGIWRTS   -SIOCIWFIRST] = (iw_handler) ray_get_rts,
-	[SIOCSIWFRAG  -SIOCIWFIRST] = (iw_handler) ray_set_frag,
-	[SIOCGIWFRAG  -SIOCIWFIRST] = (iw_handler) ray_get_frag,
+	[SIOCSIWSPY - SIOCIWFIRST] = (iw_handler) iw_handler_set_spy,
+	[SIOCGIWSPY - SIOCIWFIRST] = (iw_handler) iw_handler_get_spy,
+	[SIOCSIWTHRSPY - SIOCIWFIRST] = (iw_handler) iw_handler_set_thrspy,
+	[SIOCGIWTHRSPY - SIOCIWFIRST] = (iw_handler) iw_handler_get_thrspy,
+#endif /* WIRELESS_SPY */
+	[SIOCGIWAP - SIOCIWFIRST] = (iw_handler) ray_get_wap,
+	[SIOCSIWESSID - SIOCIWFIRST] = (iw_handler) ray_set_essid,
+	[SIOCGIWESSID - SIOCIWFIRST] = (iw_handler) ray_get_essid,
+	[SIOCSIWRATE - SIOCIWFIRST] = (iw_handler) ray_set_rate,
+	[SIOCGIWRATE - SIOCIWFIRST] = (iw_handler) ray_get_rate,
+	[SIOCSIWRTS - SIOCIWFIRST] = (iw_handler) ray_set_rts,
+	[SIOCGIWRTS - SIOCIWFIRST] = (iw_handler) ray_get_rts,
+	[SIOCSIWFRAG - SIOCIWFIRST] = (iw_handler) ray_set_frag,
+	[SIOCGIWFRAG - SIOCIWFIRST] = (iw_handler) ray_get_frag,
 };
 
-#define SIOCSIPFRAMING	SIOCIWFIRSTPRIV		/* Set framing mode */
+#define SIOCSIPFRAMING	SIOCIWFIRSTPRIV	/* Set framing mode */
 #define SIOCGIPFRAMING	SIOCIWFIRSTPRIV + 1	/* Get framing mode */
 #define SIOCGIPCOUNTRY	SIOCIWFIRSTPRIV + 3	/* Get country code */
 
-static const iw_handler	ray_private_handler[] = {
+static const iw_handler ray_private_handler[] = {
 	[0] = (iw_handler) ray_set_framing,
 	[1] = (iw_handler) ray_get_framing,
 	[3] = (iw_handler) ray_get_country,
 };
 
-static const struct iw_priv_args	ray_private_args[] = {
+static const struct iw_priv_args ray_private_args[] = {
 /* cmd,		set_args,	get_args,	name */
-{ SIOCSIPFRAMING, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1, 0, "set_framing" },
-{ SIOCGIPFRAMING, 0, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1, "get_framing" },
-{ SIOCGIPCOUNTRY, 0, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1, "get_country" },
+	{SIOCSIPFRAMING, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1, 0,
+	 "set_framing"},
+	{SIOCGIPFRAMING, 0, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1,
+	 "get_framing"},
+	{SIOCGIPCOUNTRY, 0, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1,
+	 "get_country"},
 };
 
-static const struct iw_handler_def	ray_handler_def =
-{
-	.num_standard	= ARRAY_SIZE(ray_handler),
-	.num_private	= ARRAY_SIZE(ray_private_handler),
+static const struct iw_handler_def ray_handler_def = {
+	.num_standard = ARRAY_SIZE(ray_handler),
+	.num_private = ARRAY_SIZE(ray_private_handler),
 	.num_private_args = ARRAY_SIZE(ray_private_args),
-	.standard	= ray_handler,
-	.private	= ray_private_handler,
-	.private_args	= ray_private_args,
+	.standard = ray_handler,
+	.private = ray_private_handler,
+	.private_args = ray_private_args,
 	.get_wireless_stats = ray_get_wireless_stats,
 };
 
 /*===========================================================================*/
 static int ray_open(struct net_device *dev)
 {
-    ray_dev_t *local = netdev_priv(dev);
-    struct pcmcia_device *link;
-    link = local->finder;
-    
-    DEBUG(1, "ray_open('%s')\n", dev->name);
+	ray_dev_t *local = netdev_priv(dev);
+	struct pcmcia_device *link;
+	link = local->finder;
 
-    if (link->open == 0)
-	    local->num_multi = 0;
-    link->open++;
+	DEBUG(1, "ray_open('%s')\n", dev->name);
 
-    /* If the card is not started, time to start it ! - Jean II */
-    if(local->card_status == CARD_AWAITING_PARAM) {
-	int i;
+	if (link->open == 0)
+		local->num_multi = 0;
+	link->open++;
 
-	DEBUG(1,"ray_open: doing init now !\n");
+	/* If the card is not started, time to start it ! - Jean II */
+	if (local->card_status == CARD_AWAITING_PARAM) {
+		int i;
 
-	/* Download startup parameters */
-	if ( (i = dl_startup_params(dev)) < 0)
-	  {
-	    printk(KERN_INFO "ray_dev_init dl_startup_params failed - "
-		   "returns 0x%x\n",i);
-	    return -1;
-	  }
-     }
-
-    if (sniffer) netif_stop_queue(dev);
-    else         netif_start_queue(dev);
-
-    DEBUG(2,"ray_open ending\n");
-    return 0;
+		DEBUG(1, "ray_open: doing init now !\n");
+
+		/* Download startup parameters */
+		if ((i = dl_startup_params(dev)) < 0) {
+			printk(KERN_INFO
+			       "ray_dev_init dl_startup_params failed - "
+			       "returns 0x%x\n", i);
+			return -1;
+		}
+	}
+
+	if (sniffer)
+		netif_stop_queue(dev);
+	else
+		netif_start_queue(dev);
+
+	DEBUG(2, "ray_open ending\n");
+	return 0;
 } /* end ray_open */
+
 /*===========================================================================*/
 static int ray_dev_close(struct net_device *dev)
 {
-    ray_dev_t *local = netdev_priv(dev);
-    struct pcmcia_device *link;
-    link = local->finder;
+	ray_dev_t *local = netdev_priv(dev);
+	struct pcmcia_device *link;
+	link = local->finder;
 
-    DEBUG(1, "ray_dev_close('%s')\n", dev->name);
+	DEBUG(1, "ray_dev_close('%s')\n", dev->name);
 
-    link->open--;
-    netif_stop_queue(dev);
+	link->open--;
+	netif_stop_queue(dev);
 
-    /* In here, we should stop the hardware (stop card from beeing active)
-     * and set local->card_status to CARD_AWAITING_PARAM, so that while the
-     * card is closed we can chage its configuration.
-     * Probably also need a COR reset to get sane state - Jean II */
+	/* In here, we should stop the hardware (stop card from beeing active)
+	 * and set local->card_status to CARD_AWAITING_PARAM, so that while the
+	 * card is closed we can chage its configuration.
+	 * Probably also need a COR reset to get sane state - Jean II */
 
-    return 0;
+	return 0;
 } /* end ray_dev_close */
+
 /*===========================================================================*/
-static void ray_reset(struct net_device *dev) {
-    DEBUG(1,"ray_reset entered\n");
-    return;
+static void ray_reset(struct net_device *dev)
+{
+	DEBUG(1, "ray_reset entered\n");
+	return;
 }
+
 /*===========================================================================*/
 /* Cause a firmware interrupt if it is ready for one                         */
 /* Return nonzero if not ready                                               */
 static int interrupt_ecf(ray_dev_t *local, int ccs)
 {
-    int i = 50;
-    struct pcmcia_device *link = local->finder;
-
-    if (!(pcmcia_dev_present(link))) {
-        DEBUG(2,"ray_cs interrupt_ecf - device not present\n");
-        return -1;
-    }
-    DEBUG(2,"interrupt_ecf(local=%p, ccs = 0x%x\n",local,ccs);
-
-    while ( i && 
-            (readb(local->amem + CIS_OFFSET + ECF_INTR_OFFSET) & ECF_INTR_SET))
-        i--;
-    if (i == 0) {
-        DEBUG(2,"ray_cs interrupt_ecf card not ready for interrupt\n");
-        return -1;
-    }
+	int i = 50;
+	struct pcmcia_device *link = local->finder;
+
+	if (!(pcmcia_dev_present(link))) {
+		DEBUG(2, "ray_cs interrupt_ecf - device not present\n");
+		return -1;
+	}
+	DEBUG(2, "interrupt_ecf(local=%p, ccs = 0x%x\n", local, ccs);
+
+	while (i &&
+	       (readb(local->amem + CIS_OFFSET + ECF_INTR_OFFSET) &
+		ECF_INTR_SET))
+		i--;
+	if (i == 0) {
+		DEBUG(2, "ray_cs interrupt_ecf card not ready for interrupt\n");
+		return -1;
+	}
 	/* Fill the mailbox, then kick the card */
-    writeb(ccs, local->sram + SCB_BASE);
-    writeb(ECF_INTR_SET, local->amem + CIS_OFFSET + ECF_INTR_OFFSET);
-    return 0;
+	writeb(ccs, local->sram + SCB_BASE);
+	writeb(ECF_INTR_SET, local->amem + CIS_OFFSET + ECF_INTR_OFFSET);
+	return 0;
 } /* interrupt_ecf */
+
 /*===========================================================================*/
 /* Get next free transmit CCS                                                */
 /* Return - index of current tx ccs                                          */
 static int get_free_tx_ccs(ray_dev_t *local)
 {
-    int i;
-    struct ccs __iomem *pccs = ccs_base(local);
-    struct pcmcia_device *link = local->finder;
+	int i;
+	struct ccs __iomem *pccs = ccs_base(local);
+	struct pcmcia_device *link = local->finder;
 
-    if (!(pcmcia_dev_present(link))) {
-        DEBUG(2,"ray_cs get_free_tx_ccs - device not present\n");
-        return ECARDGONE;
-    }
+	if (!(pcmcia_dev_present(link))) {
+		DEBUG(2, "ray_cs get_free_tx_ccs - device not present\n");
+		return ECARDGONE;
+	}
 
-    if (test_and_set_bit(0,&local->tx_ccs_lock)) {
-        DEBUG(1,"ray_cs tx_ccs_lock busy\n");
-        return ECCSBUSY;
-    } 
+	if (test_and_set_bit(0, &local->tx_ccs_lock)) {
+		DEBUG(1, "ray_cs tx_ccs_lock busy\n");
+		return ECCSBUSY;
+	}
 
-    for (i=0; i < NUMBER_OF_TX_CCS; i++) {
-        if (readb(&(pccs+i)->buffer_status) == CCS_BUFFER_FREE) {
-            writeb(CCS_BUFFER_BUSY, &(pccs+i)->buffer_status);
-            writeb(CCS_END_LIST, &(pccs+i)->link);
+	for (i = 0; i < NUMBER_OF_TX_CCS; i++) {
+		if (readb(&(pccs + i)->buffer_status) == CCS_BUFFER_FREE) {
+			writeb(CCS_BUFFER_BUSY, &(pccs + i)->buffer_status);
+			writeb(CCS_END_LIST, &(pccs + i)->link);
 			local->tx_ccs_lock = 0;
-            return i;
-        }
-    }
+			return i;
+		}
+	}
 	local->tx_ccs_lock = 0;
-    DEBUG(2,"ray_cs ERROR no free tx CCS for raylink card\n");
-    return ECCSFULL;
+	DEBUG(2, "ray_cs ERROR no free tx CCS for raylink card\n");
+	return ECCSFULL;
 } /* get_free_tx_ccs */
+
 /*===========================================================================*/
 /* Get next free CCS                                                         */
 /* Return - index of current ccs                                             */
 static int get_free_ccs(ray_dev_t *local)
 {
-    int i;
-    struct ccs __iomem *pccs = ccs_base(local);
-    struct pcmcia_device *link = local->finder;
-
-    if (!(pcmcia_dev_present(link))) {
-        DEBUG(2,"ray_cs get_free_ccs - device not present\n");
-        return ECARDGONE;
-    }
-    if (test_and_set_bit(0,&local->ccs_lock)) {
-        DEBUG(1,"ray_cs ccs_lock busy\n");
-        return ECCSBUSY;
-    } 
-
-    for (i = NUMBER_OF_TX_CCS; i < NUMBER_OF_CCS; i++) {
-        if (readb(&(pccs+i)->buffer_status) == CCS_BUFFER_FREE) {
-            writeb(CCS_BUFFER_BUSY, &(pccs+i)->buffer_status);
-            writeb(CCS_END_LIST, &(pccs+i)->link);
+	int i;
+	struct ccs __iomem *pccs = ccs_base(local);
+	struct pcmcia_device *link = local->finder;
+
+	if (!(pcmcia_dev_present(link))) {
+		DEBUG(2, "ray_cs get_free_ccs - device not present\n");
+		return ECARDGONE;
+	}
+	if (test_and_set_bit(0, &local->ccs_lock)) {
+		DEBUG(1, "ray_cs ccs_lock busy\n");
+		return ECCSBUSY;
+	}
+
+	for (i = NUMBER_OF_TX_CCS; i < NUMBER_OF_CCS; i++) {
+		if (readb(&(pccs + i)->buffer_status) == CCS_BUFFER_FREE) {
+			writeb(CCS_BUFFER_BUSY, &(pccs + i)->buffer_status);
+			writeb(CCS_END_LIST, &(pccs + i)->link);
 			local->ccs_lock = 0;
-            return i;
-        }
-    }
+			return i;
+		}
+	}
 	local->ccs_lock = 0;
-    DEBUG(1,"ray_cs ERROR no free CCS for raylink card\n");
-    return ECCSFULL;
+	DEBUG(1, "ray_cs ERROR no free CCS for raylink card\n");
+	return ECCSFULL;
 } /* get_free_ccs */
+
 /*===========================================================================*/
 static void authenticate_timeout(u_long data)
 {
-    ray_dev_t *local = (ray_dev_t *)data;
-    del_timer(&local->timer);
-    printk(KERN_INFO "ray_cs Authentication with access point failed"
-       " - timeout\n");
-    join_net((u_long)local);
+	ray_dev_t *local = (ray_dev_t *) data;
+	del_timer(&local->timer);
+	printk(KERN_INFO "ray_cs Authentication with access point failed"
+	       " - timeout\n");
+	join_net((u_long) local);
 }
+
 /*===========================================================================*/
 static int asc_to_int(char a)
 {
-    if (a < '0') return -1;
-    if (a <= '9') return (a - '0');
-    if (a < 'A') return -1;
-    if (a <= 'F') return (10 + a - 'A');
-    if (a < 'a') return -1;
-    if (a <= 'f') return (10 + a - 'a');
-    return -1;
+	if (a < '0')
+		return -1;
+	if (a <= '9')
+		return (a - '0');
+	if (a < 'A')
+		return -1;
+	if (a <= 'F')
+		return (10 + a - 'A');
+	if (a < 'a')
+		return -1;
+	if (a <= 'f')
+		return (10 + a - 'a');
+	return -1;
 }
+
 /*===========================================================================*/
 static int parse_addr(char *in_str, UCHAR *out)
 {
-    int len;
-    int i,j,k;
-    int status;
-    
-    if (in_str == NULL) return 0;
-    if ((len = strlen(in_str)) < 2) return 0;
-    memset(out, 0, ADDRLEN);
-
-    status = 1;
-    j = len - 1;
-    if (j > 12) j = 12;
-    i = 5;
-    
-    while (j > 0)
-    {
-        if ((k = asc_to_int(in_str[j--])) != -1) out[i] = k;
-        else return 0;
-
-        if (j == 0) break;
-        if ((k = asc_to_int(in_str[j--])) != -1) out[i] += k << 4;
-        else return 0;
-        if (!i--) break;
-    }
-    return status;
+	int len;
+	int i, j, k;
+	int status;
+
+	if (in_str == NULL)
+		return 0;
+	if ((len = strlen(in_str)) < 2)
+		return 0;
+	memset(out, 0, ADDRLEN);
+
+	status = 1;
+	j = len - 1;
+	if (j > 12)
+		j = 12;
+	i = 5;
+
+	while (j > 0) {
+		if ((k = asc_to_int(in_str[j--])) != -1)
+			out[i] = k;
+		else
+			return 0;
+
+		if (j == 0)
+			break;
+		if ((k = asc_to_int(in_str[j--])) != -1)
+			out[i] += k << 4;
+		else
+			return 0;
+		if (!i--)
+			break;
+	}
+	return status;
 }
+
 /*===========================================================================*/
 static struct net_device_stats *ray_get_stats(struct net_device *dev)
 {
-    ray_dev_t *local = netdev_priv(dev);
-    struct pcmcia_device *link = local->finder;
-    struct status __iomem *p = local->sram + STATUS_BASE;
-    if (!(pcmcia_dev_present(link))) {
-        DEBUG(2,"ray_cs net_device_stats - device not present\n");
-        return &local->stats;
-    }
-    if (readb(&p->mrx_overflow_for_host))
-    {
-        local->stats.rx_over_errors += swab16(readw(&p->mrx_overflow));
-        writeb(0,&p->mrx_overflow);
-        writeb(0,&p->mrx_overflow_for_host);
-    }
-    if (readb(&p->mrx_checksum_error_for_host))
-    {
-        local->stats.rx_crc_errors += swab16(readw(&p->mrx_checksum_error));
-        writeb(0,&p->mrx_checksum_error);
-        writeb(0,&p->mrx_checksum_error_for_host);
-    }
-    if (readb(&p->rx_hec_error_for_host))
-    {
-        local->stats.rx_frame_errors += swab16(readw(&p->rx_hec_error));
-        writeb(0,&p->rx_hec_error);
-        writeb(0,&p->rx_hec_error_for_host);
-    }
-    return &local->stats;
+	ray_dev_t *local = netdev_priv(dev);
+	struct pcmcia_device *link = local->finder;
+	struct status __iomem *p = local->sram + STATUS_BASE;
+	if (!(pcmcia_dev_present(link))) {
+		DEBUG(2, "ray_cs net_device_stats - device not present\n");
+		return &local->stats;
+	}
+	if (readb(&p->mrx_overflow_for_host)) {
+		local->stats.rx_over_errors += swab16(readw(&p->mrx_overflow));
+		writeb(0, &p->mrx_overflow);
+		writeb(0, &p->mrx_overflow_for_host);
+	}
+	if (readb(&p->mrx_checksum_error_for_host)) {
+		local->stats.rx_crc_errors +=
+		    swab16(readw(&p->mrx_checksum_error));
+		writeb(0, &p->mrx_checksum_error);
+		writeb(0, &p->mrx_checksum_error_for_host);
+	}
+	if (readb(&p->rx_hec_error_for_host)) {
+		local->stats.rx_frame_errors += swab16(readw(&p->rx_hec_error));
+		writeb(0, &p->rx_hec_error);
+		writeb(0, &p->rx_hec_error_for_host);
+	}
+	return &local->stats;
 }
+
 /*===========================================================================*/
-static void ray_update_parm(struct net_device *dev, UCHAR objid, UCHAR *value, int len)
-{
-    ray_dev_t *local = netdev_priv(dev);
-    struct pcmcia_device *link = local->finder;
-    int ccsindex;
-    int i;
-    struct ccs __iomem *pccs;
-
-    if (!(pcmcia_dev_present(link))) {
-        DEBUG(2,"ray_update_parm - device not present\n");
-        return;
-    }
-
-    if ((ccsindex = get_free_ccs(local)) < 0)
-    {
-        DEBUG(0,"ray_update_parm - No free ccs\n");
-        return;
-    }
-    pccs = ccs_base(local) + ccsindex;
-    writeb(CCS_UPDATE_PARAMS, &pccs->cmd);
-    writeb(objid, &pccs->var.update_param.object_id);
-    writeb(1, &pccs->var.update_param.number_objects);
-    writeb(0, &pccs->var.update_param.failure_cause);
-    for (i=0; i<len; i++) {
-        writeb(value[i], local->sram + HOST_TO_ECF_BASE);
-    }
-    /* Interrupt the firmware to process the command */
-    if (interrupt_ecf(local, ccsindex)) {
-        DEBUG(0,"ray_cs associate failed - ECF not ready for intr\n");
-        writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
-    }
+static void ray_update_parm(struct net_device *dev, UCHAR objid, UCHAR *value,
+			    int len)
+{
+	ray_dev_t *local = netdev_priv(dev);
+	struct pcmcia_device *link = local->finder;
+	int ccsindex;
+	int i;
+	struct ccs __iomem *pccs;
+
+	if (!(pcmcia_dev_present(link))) {
+		DEBUG(2, "ray_update_parm - device not present\n");
+		return;
+	}
+
+	if ((ccsindex = get_free_ccs(local)) < 0) {
+		DEBUG(0, "ray_update_parm - No free ccs\n");
+		return;
+	}
+	pccs = ccs_base(local) + ccsindex;
+	writeb(CCS_UPDATE_PARAMS, &pccs->cmd);
+	writeb(objid, &pccs->var.update_param.object_id);
+	writeb(1, &pccs->var.update_param.number_objects);
+	writeb(0, &pccs->var.update_param.failure_cause);
+	for (i = 0; i < len; i++) {
+		writeb(value[i], local->sram + HOST_TO_ECF_BASE);
+	}
+	/* Interrupt the firmware to process the command */
+	if (interrupt_ecf(local, ccsindex)) {
+		DEBUG(0, "ray_cs associate failed - ECF not ready for intr\n");
+		writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
+	}
 }
+
 /*===========================================================================*/
 static void ray_update_multi_list(struct net_device *dev, int all)
 {
-    struct dev_mc_list *dmi, **dmip;
-    int ccsindex;
-    struct ccs __iomem *pccs;
-    int i = 0;
-    ray_dev_t *local = netdev_priv(dev);
-    struct pcmcia_device *link = local->finder;
-    void __iomem *p = local->sram + HOST_TO_ECF_BASE;
-
-    if (!(pcmcia_dev_present(link))) {
-        DEBUG(2,"ray_update_multi_list - device not present\n");
-        return;
-    }
-    else 
-        DEBUG(2,"ray_update_multi_list(%p)\n",dev);
-    if ((ccsindex = get_free_ccs(local)) < 0)
-    {
-        DEBUG(1,"ray_update_multi - No free ccs\n");
-        return;
-    }
-    pccs = ccs_base(local) + ccsindex;
-    writeb(CCS_UPDATE_MULTICAST_LIST, &pccs->cmd);
-
-    if (all) {
-        writeb(0xff, &pccs->var);
-        local->num_multi = 0xff;
-    }
-    else {
-        /* Copy the kernel's list of MC addresses to card */
-        for (dmip=&dev->mc_list; (dmi=*dmip)!=NULL; dmip=&dmi->next) {
-            memcpy_toio(p, dmi->dmi_addr, ETH_ALEN);
-            DEBUG(1,"ray_update_multi add addr %02x%02x%02x%02x%02x%02x\n",dmi->dmi_addr[0],dmi->dmi_addr[1],dmi->dmi_addr[2],dmi->dmi_addr[3],dmi->dmi_addr[4],dmi->dmi_addr[5]);
-            p += ETH_ALEN;
-            i++;
-        }
-        if (i > 256/ADDRLEN) i = 256/ADDRLEN;
-        writeb((UCHAR)i, &pccs->var);
-        DEBUG(1,"ray_cs update_multi %d addresses in list\n", i);
-        /* Interrupt the firmware to process the command */
-        local->num_multi = i;
-    }
-    if (interrupt_ecf(local, ccsindex)) {
-        DEBUG(1,"ray_cs update_multi failed - ECF not ready for intr\n");
-        writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
-    }
+	struct dev_mc_list *dmi, **dmip;
+	int ccsindex;
+	struct ccs __iomem *pccs;
+	int i = 0;
+	ray_dev_t *local = netdev_priv(dev);
+	struct pcmcia_device *link = local->finder;
+	void __iomem *p = local->sram + HOST_TO_ECF_BASE;
+
+	if (!(pcmcia_dev_present(link))) {
+		DEBUG(2, "ray_update_multi_list - device not present\n");
+		return;
+	} else
+		DEBUG(2, "ray_update_multi_list(%p)\n", dev);
+	if ((ccsindex = get_free_ccs(local)) < 0) {
+		DEBUG(1, "ray_update_multi - No free ccs\n");
+		return;
+	}
+	pccs = ccs_base(local) + ccsindex;
+	writeb(CCS_UPDATE_MULTICAST_LIST, &pccs->cmd);
+
+	if (all) {
+		writeb(0xff, &pccs->var);
+		local->num_multi = 0xff;
+	} else {
+		/* Copy the kernel's list of MC addresses to card */
+		for (dmip = &dev->mc_list; (dmi = *dmip) != NULL;
+		     dmip = &dmi->next) {
+			memcpy_toio(p, dmi->dmi_addr, ETH_ALEN);
+			DEBUG(1,
+			      "ray_update_multi add addr %02x%02x%02x%02x%02x%02x\n",
+			      dmi->dmi_addr[0], dmi->dmi_addr[1],
+			      dmi->dmi_addr[2], dmi->dmi_addr[3],
+			      dmi->dmi_addr[4], dmi->dmi_addr[5]);
+			p += ETH_ALEN;
+			i++;
+		}
+		if (i > 256 / ADDRLEN)
+			i = 256 / ADDRLEN;
+		writeb((UCHAR) i, &pccs->var);
+		DEBUG(1, "ray_cs update_multi %d addresses in list\n", i);
+		/* Interrupt the firmware to process the command */
+		local->num_multi = i;
+	}
+	if (interrupt_ecf(local, ccsindex)) {
+		DEBUG(1,
+		      "ray_cs update_multi failed - ECF not ready for intr\n");
+		writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
+	}
 } /* end ray_update_multi_list */
+
 /*===========================================================================*/
 static void set_multicast_list(struct net_device *dev)
 {
-    ray_dev_t *local = netdev_priv(dev);
-    UCHAR promisc;
-
-    DEBUG(2,"ray_cs set_multicast_list(%p)\n",dev);
-
-    if (dev->flags & IFF_PROMISC)
-    {
-        if (local->sparm.b5.a_promiscuous_mode == 0) {
-            DEBUG(1,"ray_cs set_multicast_list promisc on\n");
-            local->sparm.b5.a_promiscuous_mode = 1;
-            promisc = 1;
-            ray_update_parm(dev,  OBJID_promiscuous_mode, \
-                            &promisc, sizeof(promisc));
-        }
-    }
-    else {
-        if (local->sparm.b5.a_promiscuous_mode == 1) {
-            DEBUG(1,"ray_cs set_multicast_list promisc off\n");
-            local->sparm.b5.a_promiscuous_mode = 0;
-            promisc = 0;
-            ray_update_parm(dev,  OBJID_promiscuous_mode, \
-                            &promisc, sizeof(promisc));
-        }
-    }
-
-    if (dev->flags & IFF_ALLMULTI) ray_update_multi_list(dev, 1);
-    else
-    {
-        if (local->num_multi != dev->mc_count) ray_update_multi_list(dev, 0);
-    }
+	ray_dev_t *local = netdev_priv(dev);
+	UCHAR promisc;
+
+	DEBUG(2, "ray_cs set_multicast_list(%p)\n", dev);
+
+	if (dev->flags & IFF_PROMISC) {
+		if (local->sparm.b5.a_promiscuous_mode == 0) {
+			DEBUG(1, "ray_cs set_multicast_list promisc on\n");
+			local->sparm.b5.a_promiscuous_mode = 1;
+			promisc = 1;
+			ray_update_parm(dev, OBJID_promiscuous_mode,
+					&promisc, sizeof(promisc));
+		}
+	} else {
+		if (local->sparm.b5.a_promiscuous_mode == 1) {
+			DEBUG(1, "ray_cs set_multicast_list promisc off\n");
+			local->sparm.b5.a_promiscuous_mode = 0;
+			promisc = 0;
+			ray_update_parm(dev, OBJID_promiscuous_mode,
+					&promisc, sizeof(promisc));
+		}
+	}
+
+	if (dev->flags & IFF_ALLMULTI)
+		ray_update_multi_list(dev, 1);
+	else {
+		if (local->num_multi != dev->mc_count)
+			ray_update_multi_list(dev, 0);
+	}
 } /* end set_multicast_list */
+
 /*=============================================================================
  * All routines below here are run at interrupt time.
 =============================================================================*/
 static irqreturn_t ray_interrupt(int irq, void *dev_id)
 {
-    struct net_device *dev = (struct net_device *)dev_id;
-    struct pcmcia_device *link;
-    ray_dev_t *local;
-    struct ccs __iomem *pccs;
-    struct rcs __iomem *prcs;
-    UCHAR rcsindex;
-    UCHAR tmp;
-    UCHAR cmd;
-    UCHAR status;
-
-    if (dev == NULL) /* Note that we want interrupts with dev->start == 0 */
-	return IRQ_NONE;
-
-    DEBUG(4,"ray_cs: interrupt for *dev=%p\n",dev);
-
-    local = netdev_priv(dev);
-    link = (struct pcmcia_device *)local->finder;
-    if (!pcmcia_dev_present(link)) {
-        DEBUG(2,"ray_cs interrupt from device not present or suspended.\n");
-        return IRQ_NONE;
-    }
-    rcsindex = readb(&((struct scb __iomem *)(local->sram))->rcs_index);
-
-    if (rcsindex >= (NUMBER_OF_CCS + NUMBER_OF_RCS))
-    {
-        DEBUG(1,"ray_cs interrupt bad rcsindex = 0x%x\n",rcsindex);
-        clear_interrupt(local);
-        return IRQ_HANDLED;
-    }
-    if (rcsindex < NUMBER_OF_CCS) /* If it's a returned CCS */
-    {
-        pccs = ccs_base(local) + rcsindex;
-        cmd = readb(&pccs->cmd);
-        status = readb(&pccs->buffer_status);
-        switch (cmd)
-        {
-        case CCS_DOWNLOAD_STARTUP_PARAMS: /* Happens in firmware someday */
-            del_timer(&local->timer);
-            if (status == CCS_COMMAND_COMPLETE) {
-                DEBUG(1,"ray_cs interrupt download_startup_parameters OK\n");
-            }
-            else {
-                DEBUG(1,"ray_cs interrupt download_startup_parameters fail\n");
-            }
-            break;
-        case CCS_UPDATE_PARAMS:
-            DEBUG(1,"ray_cs interrupt update params done\n");
-            if (status != CCS_COMMAND_COMPLETE) {
-                tmp = readb(&pccs->var.update_param.failure_cause);
-            DEBUG(0,"ray_cs interrupt update params failed - reason %d\n",tmp);
-            }
-            break;
-        case CCS_REPORT_PARAMS:
-            DEBUG(1,"ray_cs interrupt report params done\n");
-            break;
-        case CCS_UPDATE_MULTICAST_LIST: /* Note that this CCS isn't returned */
-            DEBUG(1,"ray_cs interrupt CCS Update Multicast List done\n");
-            break;
-        case CCS_UPDATE_POWER_SAVINGS_MODE:
-            DEBUG(1,"ray_cs interrupt update power save mode done\n");
-            break;
-        case CCS_START_NETWORK:
-        case CCS_JOIN_NETWORK:
-            if (status == CCS_COMMAND_COMPLETE) {
-                if (readb(&pccs->var.start_network.net_initiated) == 1) {
-                    DEBUG(0,"ray_cs interrupt network \"%s\" started\n",\
-                          local->sparm.b4.a_current_ess_id);
-                }
-                else {
-                    DEBUG(0,"ray_cs interrupt network \"%s\" joined\n",\
-                          local->sparm.b4.a_current_ess_id);
-                }
-                memcpy_fromio(&local->bss_id,pccs->var.start_network.bssid,ADDRLEN);
-
-                if (local->fw_ver == 0x55) local->net_default_tx_rate = 3;
-                else local->net_default_tx_rate = 
-                         readb(&pccs->var.start_network.net_default_tx_rate);
-                local->encryption = readb(&pccs->var.start_network.encryption);
-                if (!sniffer && (local->net_type == INFRA)
-                    && !(local->sparm.b4.a_acting_as_ap_status)) {
-                    authenticate(local);
-                }
-                local->card_status = CARD_ACQ_COMPLETE;
-            }
-            else {
-                local->card_status = CARD_ACQ_FAILED;
-
-                del_timer(&local->timer);
-                local->timer.expires = jiffies + HZ*5;
-                local->timer.data = (long)local;
-                if (status == CCS_START_NETWORK) {
-                    DEBUG(0,"ray_cs interrupt network \"%s\" start failed\n",\
-                          local->sparm.b4.a_current_ess_id);
-                    local->timer.function = &start_net;
-                }
-                else {
-                    DEBUG(0,"ray_cs interrupt network \"%s\" join failed\n",\
-                          local->sparm.b4.a_current_ess_id);
-                    local->timer.function = &join_net;
-                }
-                add_timer(&local->timer);
-            }
-            break;
-        case CCS_START_ASSOCIATION:
-            if (status == CCS_COMMAND_COMPLETE) {
-                local->card_status = CARD_ASSOC_COMPLETE;
-                DEBUG(0,"ray_cs association successful\n");
-            }
-            else
-            {
-                DEBUG(0,"ray_cs association failed,\n");
-                local->card_status = CARD_ASSOC_FAILED;
-                join_net((u_long)local);
-            }
-            break;
-        case CCS_TX_REQUEST:
-            if (status == CCS_COMMAND_COMPLETE) {
-                DEBUG(3,"ray_cs interrupt tx request complete\n");
-            }
-            else {
-                DEBUG(1,"ray_cs interrupt tx request failed\n");
-            }
-            if (!sniffer) netif_start_queue(dev);
-            netif_wake_queue(dev);
-            break;
-        case CCS_TEST_MEMORY:
-            DEBUG(1,"ray_cs interrupt mem test done\n");
-            break;
-        case CCS_SHUTDOWN:
-            DEBUG(1,"ray_cs interrupt Unexpected CCS returned - Shutdown\n");
-            break;
-        case CCS_DUMP_MEMORY:
-            DEBUG(1,"ray_cs interrupt dump memory done\n");
-            break;
-        case CCS_START_TIMER:
-            DEBUG(2,"ray_cs interrupt DING - raylink timer expired\n");
-            break;
-        default:
-            DEBUG(1,"ray_cs interrupt Unexpected CCS 0x%x returned 0x%x\n",\
-                  rcsindex, cmd);
-        }
-        writeb(CCS_BUFFER_FREE, &pccs->buffer_status);
-    }
-    else /* It's an RCS */
-    {
-        prcs = rcs_base(local) + rcsindex;
-    
-        switch (readb(&prcs->interrupt_id))
-        {
-        case PROCESS_RX_PACKET:
-            ray_rx(dev, local, prcs);
-            break;
-        case REJOIN_NET_COMPLETE:
-            DEBUG(1,"ray_cs interrupt rejoin net complete\n");
-            local->card_status = CARD_ACQ_COMPLETE;
-            /* do we need to clear tx buffers CCS's? */
-            if (local->sparm.b4.a_network_type == ADHOC) {
-                if (!sniffer) netif_start_queue(dev);
-            }
-            else {
-                memcpy_fromio(&local->bss_id, prcs->var.rejoin_net_complete.bssid, ADDRLEN);
-                DEBUG(1,"ray_cs new BSSID = %02x%02x%02x%02x%02x%02x\n",\
-                      local->bss_id[0], local->bss_id[1], local->bss_id[2],\
-                      local->bss_id[3], local->bss_id[4], local->bss_id[5]);
-                if (!sniffer) authenticate(local);
-            }
-            break;
-        case ROAMING_INITIATED:
-            DEBUG(1,"ray_cs interrupt roaming initiated\n"); 
-            netif_stop_queue(dev);
-            local->card_status = CARD_DOING_ACQ;
-            break;
-        case JAPAN_CALL_SIGN_RXD:
-            DEBUG(1,"ray_cs interrupt japan call sign rx\n");
-            break;
-        default:
-            DEBUG(1,"ray_cs Unexpected interrupt for RCS 0x%x cmd = 0x%x\n",\
-                  rcsindex, (unsigned int) readb(&prcs->interrupt_id));
-            break;
-        }
-        writeb(CCS_BUFFER_FREE, &prcs->buffer_status);
-    }
-    clear_interrupt(local);
-    return IRQ_HANDLED;
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct pcmcia_device *link;
+	ray_dev_t *local;
+	struct ccs __iomem *pccs;
+	struct rcs __iomem *prcs;
+	UCHAR rcsindex;
+	UCHAR tmp;
+	UCHAR cmd;
+	UCHAR status;
+
+	if (dev == NULL)	/* Note that we want interrupts with dev->start == 0 */
+		return IRQ_NONE;
+
+	DEBUG(4, "ray_cs: interrupt for *dev=%p\n", dev);
+
+	local = netdev_priv(dev);
+	link = (struct pcmcia_device *)local->finder;
+	if (!pcmcia_dev_present(link)) {
+		DEBUG(2,
+		      "ray_cs interrupt from device not present or suspended.\n");
+		return IRQ_NONE;
+	}
+	rcsindex = readb(&((struct scb __iomem *)(local->sram))->rcs_index);
+
+	if (rcsindex >= (NUMBER_OF_CCS + NUMBER_OF_RCS)) {
+		DEBUG(1, "ray_cs interrupt bad rcsindex = 0x%x\n", rcsindex);
+		clear_interrupt(local);
+		return IRQ_HANDLED;
+	}
+	if (rcsindex < NUMBER_OF_CCS) { /* If it's a returned CCS */
+		pccs = ccs_base(local) + rcsindex;
+		cmd = readb(&pccs->cmd);
+		status = readb(&pccs->buffer_status);
+		switch (cmd) {
+		case CCS_DOWNLOAD_STARTUP_PARAMS:	/* Happens in firmware someday */
+			del_timer(&local->timer);
+			if (status == CCS_COMMAND_COMPLETE) {
+				DEBUG(1,
+				      "ray_cs interrupt download_startup_parameters OK\n");
+			} else {
+				DEBUG(1,
+				      "ray_cs interrupt download_startup_parameters fail\n");
+			}
+			break;
+		case CCS_UPDATE_PARAMS:
+			DEBUG(1, "ray_cs interrupt update params done\n");
+			if (status != CCS_COMMAND_COMPLETE) {
+				tmp =
+				    readb(&pccs->var.update_param.
+					  failure_cause);
+				DEBUG(0,
+				      "ray_cs interrupt update params failed - reason %d\n",
+				      tmp);
+			}
+			break;
+		case CCS_REPORT_PARAMS:
+			DEBUG(1, "ray_cs interrupt report params done\n");
+			break;
+		case CCS_UPDATE_MULTICAST_LIST:	/* Note that this CCS isn't returned */
+			DEBUG(1,
+			      "ray_cs interrupt CCS Update Multicast List done\n");
+			break;
+		case CCS_UPDATE_POWER_SAVINGS_MODE:
+			DEBUG(1,
+			      "ray_cs interrupt update power save mode done\n");
+			break;
+		case CCS_START_NETWORK:
+		case CCS_JOIN_NETWORK:
+			if (status == CCS_COMMAND_COMPLETE) {
+				if (readb
+				    (&pccs->var.start_network.net_initiated) ==
+				    1) {
+					DEBUG(0,
+					      "ray_cs interrupt network \"%s\" started\n",
+					      local->sparm.b4.a_current_ess_id);
+				} else {
+					DEBUG(0,
+					      "ray_cs interrupt network \"%s\" joined\n",
+					      local->sparm.b4.a_current_ess_id);
+				}
+				memcpy_fromio(&local->bss_id,
+					      pccs->var.start_network.bssid,
+					      ADDRLEN);
+
+				if (local->fw_ver == 0x55)
+					local->net_default_tx_rate = 3;
+				else
+					local->net_default_tx_rate =
+					    readb(&pccs->var.start_network.
+						  net_default_tx_rate);
+				local->encryption =
+				    readb(&pccs->var.start_network.encryption);
+				if (!sniffer && (local->net_type == INFRA)
+				    && !(local->sparm.b4.a_acting_as_ap_status)) {
+					authenticate(local);
+				}
+				local->card_status = CARD_ACQ_COMPLETE;
+			} else {
+				local->card_status = CARD_ACQ_FAILED;
+
+				del_timer(&local->timer);
+				local->timer.expires = jiffies + HZ * 5;
+				local->timer.data = (long)local;
+				if (status == CCS_START_NETWORK) {
+					DEBUG(0,
+					      "ray_cs interrupt network \"%s\" start failed\n",
+					      local->sparm.b4.a_current_ess_id);
+					local->timer.function = &start_net;
+				} else {
+					DEBUG(0,
+					      "ray_cs interrupt network \"%s\" join failed\n",
+					      local->sparm.b4.a_current_ess_id);
+					local->timer.function = &join_net;
+				}
+				add_timer(&local->timer);
+			}
+			break;
+		case CCS_START_ASSOCIATION:
+			if (status == CCS_COMMAND_COMPLETE) {
+				local->card_status = CARD_ASSOC_COMPLETE;
+				DEBUG(0, "ray_cs association successful\n");
+			} else {
+				DEBUG(0, "ray_cs association failed,\n");
+				local->card_status = CARD_ASSOC_FAILED;
+				join_net((u_long) local);
+			}
+			break;
+		case CCS_TX_REQUEST:
+			if (status == CCS_COMMAND_COMPLETE) {
+				DEBUG(3,
+				      "ray_cs interrupt tx request complete\n");
+			} else {
+				DEBUG(1,
+				      "ray_cs interrupt tx request failed\n");
+			}
+			if (!sniffer)
+				netif_start_queue(dev);
+			netif_wake_queue(dev);
+			break;
+		case CCS_TEST_MEMORY:
+			DEBUG(1, "ray_cs interrupt mem test done\n");
+			break;
+		case CCS_SHUTDOWN:
+			DEBUG(1,
+			      "ray_cs interrupt Unexpected CCS returned - Shutdown\n");
+			break;
+		case CCS_DUMP_MEMORY:
+			DEBUG(1, "ray_cs interrupt dump memory done\n");
+			break;
+		case CCS_START_TIMER:
+			DEBUG(2,
+			      "ray_cs interrupt DING - raylink timer expired\n");
+			break;
+		default:
+			DEBUG(1,
+			      "ray_cs interrupt Unexpected CCS 0x%x returned 0x%x\n",
+			      rcsindex, cmd);
+		}
+		writeb(CCS_BUFFER_FREE, &pccs->buffer_status);
+	} else { /* It's an RCS */
+
+		prcs = rcs_base(local) + rcsindex;
+
+		switch (readb(&prcs->interrupt_id)) {
+		case PROCESS_RX_PACKET:
+			ray_rx(dev, local, prcs);
+			break;
+		case REJOIN_NET_COMPLETE:
+			DEBUG(1, "ray_cs interrupt rejoin net complete\n");
+			local->card_status = CARD_ACQ_COMPLETE;
+			/* do we need to clear tx buffers CCS's? */
+			if (local->sparm.b4.a_network_type == ADHOC) {
+				if (!sniffer)
+					netif_start_queue(dev);
+			} else {
+				memcpy_fromio(&local->bss_id,
+					      prcs->var.rejoin_net_complete.
+					      bssid, ADDRLEN);
+				DEBUG(1,
+				      "ray_cs new BSSID = %02x%02x%02x%02x%02x%02x\n",
+				      local->bss_id[0], local->bss_id[1],
+				      local->bss_id[2], local->bss_id[3],
+				      local->bss_id[4], local->bss_id[5]);
+				if (!sniffer)
+					authenticate(local);
+			}
+			break;
+		case ROAMING_INITIATED:
+			DEBUG(1, "ray_cs interrupt roaming initiated\n");
+			netif_stop_queue(dev);
+			local->card_status = CARD_DOING_ACQ;
+			break;
+		case JAPAN_CALL_SIGN_RXD:
+			DEBUG(1, "ray_cs interrupt japan call sign rx\n");
+			break;
+		default:
+			DEBUG(1,
+			      "ray_cs Unexpected interrupt for RCS 0x%x cmd = 0x%x\n",
+			      rcsindex,
+			      (unsigned int)readb(&prcs->interrupt_id));
+			break;
+		}
+		writeb(CCS_BUFFER_FREE, &prcs->buffer_status);
+	}
+	clear_interrupt(local);
+	return IRQ_HANDLED;
 } /* ray_interrupt */
+
 /*===========================================================================*/
-static void ray_rx(struct net_device *dev, ray_dev_t *local, struct rcs __iomem *prcs)
-{
-    int rx_len;
-    unsigned int pkt_addr;
-    void __iomem *pmsg;
-    DEBUG(4,"ray_rx process rx packet\n");
-
-    /* Calculate address of packet within Rx buffer */
-    pkt_addr = ((readb(&prcs->var.rx_packet.rx_data_ptr[0]) << 8)
-                + readb(&prcs->var.rx_packet.rx_data_ptr[1])) & RX_BUFF_END;
-    /* Length of first packet fragment */
-    rx_len = (readb(&prcs->var.rx_packet.rx_data_length[0]) << 8)
-        + readb(&prcs->var.rx_packet.rx_data_length[1]);
-
-    local->last_rsl = readb(&prcs->var.rx_packet.rx_sig_lev);
-    pmsg = local->rmem + pkt_addr;
-    switch(readb(pmsg))
-    {
-    case DATA_TYPE:
-        DEBUG(4,"ray_rx data type\n");
-        rx_data(dev, prcs, pkt_addr, rx_len);
-        break;
-    case AUTHENTIC_TYPE:
-        DEBUG(4,"ray_rx authentic type\n");
-        if (sniffer) rx_data(dev, prcs, pkt_addr, rx_len);
-        else rx_authenticate(local, prcs, pkt_addr, rx_len);
-        break;
-    case DEAUTHENTIC_TYPE:
-        DEBUG(4,"ray_rx deauth type\n");
-        if (sniffer) rx_data(dev, prcs, pkt_addr, rx_len);
-        else rx_deauthenticate(local, prcs, pkt_addr, rx_len);
-        break;
-    case NULL_MSG_TYPE:
-        DEBUG(3,"ray_cs rx NULL msg\n");
-        break;
-    case BEACON_TYPE:
-        DEBUG(4,"ray_rx beacon type\n");
-        if (sniffer) rx_data(dev, prcs, pkt_addr, rx_len);
-
-        copy_from_rx_buff(local, (UCHAR *)&local->last_bcn, pkt_addr, 
-                          rx_len < sizeof(struct beacon_rx) ? 
-                          rx_len : sizeof(struct beacon_rx));
-
-	local->beacon_rxed = 1;
-        /* Get the statistics so the card counters never overflow */
-        ray_get_stats(dev);
-            break;
-    default:
-        DEBUG(0,"ray_cs unknown pkt type %2x\n", (unsigned int) readb(pmsg));
-        break;
-    }
+static void ray_rx(struct net_device *dev, ray_dev_t *local,
+		   struct rcs __iomem *prcs)
+{
+	int rx_len;
+	unsigned int pkt_addr;
+	void __iomem *pmsg;
+	DEBUG(4, "ray_rx process rx packet\n");
+
+	/* Calculate address of packet within Rx buffer */
+	pkt_addr = ((readb(&prcs->var.rx_packet.rx_data_ptr[0]) << 8)
+		    + readb(&prcs->var.rx_packet.rx_data_ptr[1])) & RX_BUFF_END;
+	/* Length of first packet fragment */
+	rx_len = (readb(&prcs->var.rx_packet.rx_data_length[0]) << 8)
+	    + readb(&prcs->var.rx_packet.rx_data_length[1]);
+
+	local->last_rsl = readb(&prcs->var.rx_packet.rx_sig_lev);
+	pmsg = local->rmem + pkt_addr;
+	switch (readb(pmsg)) {
+	case DATA_TYPE:
+		DEBUG(4, "ray_rx data type\n");
+		rx_data(dev, prcs, pkt_addr, rx_len);
+		break;
+	case AUTHENTIC_TYPE:
+		DEBUG(4, "ray_rx authentic type\n");
+		if (sniffer)
+			rx_data(dev, prcs, pkt_addr, rx_len);
+		else
+			rx_authenticate(local, prcs, pkt_addr, rx_len);
+		break;
+	case DEAUTHENTIC_TYPE:
+		DEBUG(4, "ray_rx deauth type\n");
+		if (sniffer)
+			rx_data(dev, prcs, pkt_addr, rx_len);
+		else
+			rx_deauthenticate(local, prcs, pkt_addr, rx_len);
+		break;
+	case NULL_MSG_TYPE:
+		DEBUG(3, "ray_cs rx NULL msg\n");
+		break;
+	case BEACON_TYPE:
+		DEBUG(4, "ray_rx beacon type\n");
+		if (sniffer)
+			rx_data(dev, prcs, pkt_addr, rx_len);
+
+		copy_from_rx_buff(local, (UCHAR *) &local->last_bcn, pkt_addr,
+				  rx_len < sizeof(struct beacon_rx) ?
+				  rx_len : sizeof(struct beacon_rx));
+
+		local->beacon_rxed = 1;
+		/* Get the statistics so the card counters never overflow */
+		ray_get_stats(dev);
+		break;
+	default:
+		DEBUG(0, "ray_cs unknown pkt type %2x\n",
+		      (unsigned int)readb(pmsg));
+		break;
+	}
 
 } /* end ray_rx */
+
 /*===========================================================================*/
-static void rx_data(struct net_device *dev, struct rcs __iomem *prcs, unsigned int pkt_addr, 
-             int rx_len)
-{
-    struct sk_buff *skb = NULL;
-    struct rcs __iomem *prcslink = prcs;
-    ray_dev_t *local = netdev_priv(dev);
-    UCHAR *rx_ptr;
-    int total_len;
-    int tmp;
+static void rx_data(struct net_device *dev, struct rcs __iomem *prcs,
+		    unsigned int pkt_addr, int rx_len)
+{
+	struct sk_buff *skb = NULL;
+	struct rcs __iomem *prcslink = prcs;
+	ray_dev_t *local = netdev_priv(dev);
+	UCHAR *rx_ptr;
+	int total_len;
+	int tmp;
 #ifdef WIRELESS_SPY
-    int siglev = local->last_rsl;
-    u_char linksrcaddr[ETH_ALEN];	/* Other end of the wireless link */
+	int siglev = local->last_rsl;
+	u_char linksrcaddr[ETH_ALEN];	/* Other end of the wireless link */
 #endif
 
-    if (!sniffer) {
-        if (translate) {
+	if (!sniffer) {
+		if (translate) {
 /* TBD length needs fixing for translated header */
-            if (rx_len < (ETH_HLEN + RX_MAC_HEADER_LENGTH) ||
-                rx_len > (dev->mtu + RX_MAC_HEADER_LENGTH + ETH_HLEN + FCS_LEN)) 
-            {
-                DEBUG(0,"ray_cs invalid packet length %d received \n",rx_len);
-                return;
-            }
-        }
-        else /* encapsulated ethernet */ {
-            if (rx_len < (ETH_HLEN + RX_MAC_HEADER_LENGTH) ||
-                rx_len > (dev->mtu + RX_MAC_HEADER_LENGTH + ETH_HLEN + FCS_LEN))
-            {
-                DEBUG(0,"ray_cs invalid packet length %d received \n",rx_len);
-                return;
-            }
-        }
-    }
-    DEBUG(4,"ray_cs rx_data packet\n");
-    /* If fragmented packet, verify sizes of fragments add up */
-    if (readb(&prcs->var.rx_packet.next_frag_rcs_index) != 0xFF) {
-        DEBUG(1,"ray_cs rx'ed fragment\n");
-        tmp = (readb(&prcs->var.rx_packet.totalpacketlength[0]) << 8)
-            +  readb(&prcs->var.rx_packet.totalpacketlength[1]);
-        total_len = tmp;
-        prcslink = prcs;
-        do {
-            tmp -= (readb(&prcslink->var.rx_packet.rx_data_length[0]) << 8)
-                +   readb(&prcslink->var.rx_packet.rx_data_length[1]);
-            if (readb(&prcslink->var.rx_packet.next_frag_rcs_index) == 0xFF
-                || tmp < 0) break;
-            prcslink = rcs_base(local)
-                + readb(&prcslink->link_field);
-        } while (1);
-
-        if (tmp < 0)
-        {
-            DEBUG(0,"ray_cs rx_data fragment lengths don't add up\n");
-            local->stats.rx_dropped++; 
-            release_frag_chain(local, prcs);
-            return;
-        }
-    }
-    else { /* Single unfragmented packet */
-        total_len = rx_len;
-    }
-
-    skb = dev_alloc_skb( total_len+5 );
-    if (skb == NULL)
-    {
-        DEBUG(0,"ray_cs rx_data could not allocate skb\n");
-        local->stats.rx_dropped++; 
-        if (readb(&prcs->var.rx_packet.next_frag_rcs_index) != 0xFF)
-            release_frag_chain(local, prcs);
-        return;
-    }
-    skb_reserve( skb, 2);   /* Align IP on 16 byte (TBD check this)*/
-
-    DEBUG(4,"ray_cs rx_data total_len = %x, rx_len = %x\n",total_len,rx_len);
+			if (rx_len < (ETH_HLEN + RX_MAC_HEADER_LENGTH) ||
+			    rx_len >
+			    (dev->mtu + RX_MAC_HEADER_LENGTH + ETH_HLEN +
+			     FCS_LEN)) {
+				DEBUG(0,
+				      "ray_cs invalid packet length %d received \n",
+				      rx_len);
+				return;
+			}
+		} else { /* encapsulated ethernet */
+
+			if (rx_len < (ETH_HLEN + RX_MAC_HEADER_LENGTH) ||
+			    rx_len >
+			    (dev->mtu + RX_MAC_HEADER_LENGTH + ETH_HLEN +
+			     FCS_LEN)) {
+				DEBUG(0,
+				      "ray_cs invalid packet length %d received \n",
+				      rx_len);
+				return;
+			}
+		}
+	}
+	DEBUG(4, "ray_cs rx_data packet\n");
+	/* If fragmented packet, verify sizes of fragments add up */
+	if (readb(&prcs->var.rx_packet.next_frag_rcs_index) != 0xFF) {
+		DEBUG(1, "ray_cs rx'ed fragment\n");
+		tmp = (readb(&prcs->var.rx_packet.totalpacketlength[0]) << 8)
+		    + readb(&prcs->var.rx_packet.totalpacketlength[1]);
+		total_len = tmp;
+		prcslink = prcs;
+		do {
+			tmp -=
+			    (readb(&prcslink->var.rx_packet.rx_data_length[0])
+			     << 8)
+			    + readb(&prcslink->var.rx_packet.rx_data_length[1]);
+			if (readb(&prcslink->var.rx_packet.next_frag_rcs_index)
+			    == 0xFF || tmp < 0)
+				break;
+			prcslink = rcs_base(local)
+			    + readb(&prcslink->link_field);
+		} while (1);
+
+		if (tmp < 0) {
+			DEBUG(0,
+			      "ray_cs rx_data fragment lengths don't add up\n");
+			local->stats.rx_dropped++;
+			release_frag_chain(local, prcs);
+			return;
+		}
+	} else { /* Single unfragmented packet */
+		total_len = rx_len;
+	}
+
+	skb = dev_alloc_skb(total_len + 5);
+	if (skb == NULL) {
+		DEBUG(0, "ray_cs rx_data could not allocate skb\n");
+		local->stats.rx_dropped++;
+		if (readb(&prcs->var.rx_packet.next_frag_rcs_index) != 0xFF)
+			release_frag_chain(local, prcs);
+		return;
+	}
+	skb_reserve(skb, 2);	/* Align IP on 16 byte (TBD check this) */
+
+	DEBUG(4, "ray_cs rx_data total_len = %x, rx_len = %x\n", total_len,
+	      rx_len);
 
 /************************/
-    /* Reserve enough room for the whole damn packet. */
-    rx_ptr = skb_put( skb, total_len);
-    /* Copy the whole packet to sk_buff */
-    rx_ptr += copy_from_rx_buff(local, rx_ptr, pkt_addr & RX_BUFF_END, rx_len);
-    /* Get source address */
+	/* Reserve enough room for the whole damn packet. */
+	rx_ptr = skb_put(skb, total_len);
+	/* Copy the whole packet to sk_buff */
+	rx_ptr +=
+	    copy_from_rx_buff(local, rx_ptr, pkt_addr & RX_BUFF_END, rx_len);
+	/* Get source address */
 #ifdef WIRELESS_SPY
-    skb_copy_from_linear_data_offset(skb, offsetof(struct mac_header, addr_2),
-				     linksrcaddr, ETH_ALEN);
+	skb_copy_from_linear_data_offset(skb,
+					 offsetof(struct mac_header, addr_2),
+					 linksrcaddr, ETH_ALEN);
 #endif
-    /* Now, deal with encapsulation/translation/sniffer */
-    if (!sniffer) {
-        if (!translate) { 
-            /* Encapsulated ethernet, so just lop off 802.11 MAC header */
+	/* Now, deal with encapsulation/translation/sniffer */
+	if (!sniffer) {
+		if (!translate) {
+			/* Encapsulated ethernet, so just lop off 802.11 MAC header */
 /* TBD reserve            skb_reserve( skb, RX_MAC_HEADER_LENGTH); */
-            skb_pull( skb, RX_MAC_HEADER_LENGTH);
-        }
-        else {
-            /* Do translation */
-            untranslate(local, skb, total_len);
-        }
-    }
-    else 
-    {  /* sniffer mode, so just pass whole packet */  };
+			skb_pull(skb, RX_MAC_HEADER_LENGTH);
+		} else {
+			/* Do translation */
+			untranslate(local, skb, total_len);
+		}
+	} else { /* sniffer mode, so just pass whole packet */
+	};
 
 /************************/
-    /* Now pick up the rest of the fragments if any */
-    tmp = 17; 
-    if (readb(&prcs->var.rx_packet.next_frag_rcs_index) != 0xFF) {
-        prcslink = prcs;
-        DEBUG(1,"ray_cs rx_data in fragment loop\n");
-        do {
-            prcslink = rcs_base(local)
-                + readb(&prcslink->var.rx_packet.next_frag_rcs_index);
-            rx_len = (( readb(&prcslink->var.rx_packet.rx_data_length[0]) << 8)
-                      + readb(&prcslink->var.rx_packet.rx_data_length[1]))
-                & RX_BUFF_END;
-            pkt_addr = (( readb(&prcslink->var.rx_packet.rx_data_ptr[0]) << 8)
-                        + readb(&prcslink->var.rx_packet.rx_data_ptr[1]))
-                & RX_BUFF_END;
-
-            rx_ptr += copy_from_rx_buff(local, rx_ptr, pkt_addr, rx_len);
-
-        } while (tmp-- && 
-                 readb(&prcslink->var.rx_packet.next_frag_rcs_index) != 0xFF);
-        release_frag_chain(local, prcs);
-    }
-
-    skb->protocol = eth_type_trans(skb,dev);
-    netif_rx(skb);
-    local->stats.rx_packets++;
-    local->stats.rx_bytes += total_len;
-
-    /* Gather signal strength per address */
+	/* Now pick up the rest of the fragments if any */
+	tmp = 17;
+	if (readb(&prcs->var.rx_packet.next_frag_rcs_index) != 0xFF) {
+		prcslink = prcs;
+		DEBUG(1, "ray_cs rx_data in fragment loop\n");
+		do {
+			prcslink = rcs_base(local)
+			    +
+			    readb(&prcslink->var.rx_packet.next_frag_rcs_index);
+			rx_len =
+			    ((readb(&prcslink->var.rx_packet.rx_data_length[0])
+			      << 8)
+			     +
+			     readb(&prcslink->var.rx_packet.rx_data_length[1]))
+			    & RX_BUFF_END;
+			pkt_addr =
+			    ((readb(&prcslink->var.rx_packet.rx_data_ptr[0]) <<
+			      8)
+			     + readb(&prcslink->var.rx_packet.rx_data_ptr[1]))
+			    & RX_BUFF_END;
+
+			rx_ptr +=
+			    copy_from_rx_buff(local, rx_ptr, pkt_addr, rx_len);
+
+		} while (tmp-- &&
+			 readb(&prcslink->var.rx_packet.next_frag_rcs_index) !=
+			 0xFF);
+		release_frag_chain(local, prcs);
+	}
+
+	skb->protocol = eth_type_trans(skb, dev);
+	netif_rx(skb);
+	local->stats.rx_packets++;
+	local->stats.rx_bytes += total_len;
+
+	/* Gather signal strength per address */
 #ifdef WIRELESS_SPY
-    /* For the Access Point or the node having started the ad-hoc net
-     * note : ad-hoc work only in some specific configurations, but we
-     * kludge in ray_get_wireless_stats... */
-    if(!memcmp(linksrcaddr, local->bss_id, ETH_ALEN))
-      {
-	/* Update statistics */
-	/*local->wstats.qual.qual = none ? */
-	local->wstats.qual.level = siglev;
-	/*local->wstats.qual.noise = none ? */
-	local->wstats.qual.updated = 0x2;
-      }
-    /* Now, update the spy stuff */
-    {
-	struct iw_quality wstats;
-	wstats.level = siglev;
-	/* wstats.noise = none ? */
-	/* wstats.qual = none ? */
-	wstats.updated = 0x2;
-	/* Update spy records */
-	wireless_spy_update(dev, linksrcaddr, &wstats);
-    }
-#endif	/* WIRELESS_SPY */
+	/* For the Access Point or the node having started the ad-hoc net
+	 * note : ad-hoc work only in some specific configurations, but we
+	 * kludge in ray_get_wireless_stats... */
+	if (!memcmp(linksrcaddr, local->bss_id, ETH_ALEN)) {
+		/* Update statistics */
+		/*local->wstats.qual.qual = none ? */
+		local->wstats.qual.level = siglev;
+		/*local->wstats.qual.noise = none ? */
+		local->wstats.qual.updated = 0x2;
+	}
+	/* Now, update the spy stuff */
+	{
+		struct iw_quality wstats;
+		wstats.level = siglev;
+		/* wstats.noise = none ? */
+		/* wstats.qual = none ? */
+		wstats.updated = 0x2;
+		/* Update spy records */
+		wireless_spy_update(dev, linksrcaddr, &wstats);
+	}
+#endif /* WIRELESS_SPY */
 } /* end rx_data */
+
 /*===========================================================================*/
 static void untranslate(ray_dev_t *local, struct sk_buff *skb, int len)
 {
-    snaphdr_t *psnap = (snaphdr_t *)(skb->data + RX_MAC_HEADER_LENGTH);
-    struct ieee80211_hdr *pmac = (struct ieee80211_hdr *)skb->data;
-    __be16 type = *(__be16 *)psnap->ethertype;
-    int delta;
-    struct ethhdr *peth;
-    UCHAR srcaddr[ADDRLEN];
-    UCHAR destaddr[ADDRLEN];
-    static UCHAR org_bridge[3] = {0, 0, 0xf8};
-    static UCHAR org_1042[3] = {0, 0, 0};
+	snaphdr_t *psnap = (snaphdr_t *) (skb->data + RX_MAC_HEADER_LENGTH);
+	struct ieee80211_hdr *pmac = (struct ieee80211_hdr *)skb->data;
+	__be16 type = *(__be16 *) psnap->ethertype;
+	int delta;
+	struct ethhdr *peth;
+	UCHAR srcaddr[ADDRLEN];
+	UCHAR destaddr[ADDRLEN];
+	static UCHAR org_bridge[3] = { 0, 0, 0xf8 };
+	static UCHAR org_1042[3] = { 0, 0, 0 };
 
-    memcpy(destaddr, ieee80211_get_DA(pmac), ADDRLEN);
-    memcpy(srcaddr, ieee80211_get_SA(pmac), ADDRLEN);
+	memcpy(destaddr, ieee80211_get_DA(pmac), ADDRLEN);
+	memcpy(srcaddr, ieee80211_get_SA(pmac), ADDRLEN);
 
 #ifdef PCMCIA_DEBUG
-    if (pc_debug > 3) {
-    int i;
-    printk(KERN_DEBUG "skb->data before untranslate");
-    for (i=0;i<64;i++) 
-        printk("%02x ",skb->data[i]);
-    printk("\n" KERN_DEBUG "type = %08x, xsap = %02x%02x%02x, org = %02x02x02x\n",
-           ntohs(type),
-	   psnap->dsap, psnap->ssap, psnap->ctrl,
-	   psnap->org[0], psnap->org[1], psnap->org[2]);
-    printk(KERN_DEBUG "untranslate skb->data = %p\n",skb->data);
-    }
+	if (pc_debug > 3) {
+		int i;
+		printk(KERN_DEBUG "skb->data before untranslate");
+		for (i = 0; i < 64; i++)
+			printk("%02x ", skb->data[i]);
+		printk("\n" KERN_DEBUG
+		       "type = %08x, xsap = %02x%02x%02x, org = %02x02x02x\n",
+		       ntohs(type), psnap->dsap, psnap->ssap, psnap->ctrl,
+		       psnap->org[0], psnap->org[1], psnap->org[2]);
+		printk(KERN_DEBUG "untranslate skb->data = %p\n", skb->data);
+	}
 #endif
 
-    if (psnap->dsap != 0xaa || psnap->ssap != 0xaa || psnap->ctrl != 3) {
-        /* not a snap type so leave it alone */
-        DEBUG(3,"ray_cs untranslate NOT SNAP %02x %02x %02x\n",
-		psnap->dsap, psnap->ssap, psnap->ctrl);
-
-        delta = RX_MAC_HEADER_LENGTH - ETH_HLEN;
-        peth = (struct ethhdr *)(skb->data + delta);
-        peth->h_proto = htons(len - RX_MAC_HEADER_LENGTH);
-    }
-    else { /* Its a SNAP */
-        if (memcmp(psnap->org, org_bridge, 3) == 0) { /* EtherII and nuke the LLC  */
-        DEBUG(3,"ray_cs untranslate Bridge encap\n");
-            delta = RX_MAC_HEADER_LENGTH 
-                + sizeof(struct snaphdr_t) - ETH_HLEN;
-            peth = (struct ethhdr *)(skb->data + delta);
-            peth->h_proto = type;
-	} else if (memcmp(psnap->org, org_1042, 3) == 0) {
-                switch (ntohs(type)) {
-                case ETH_P_IPX:
-                case ETH_P_AARP:
-                    DEBUG(3,"ray_cs untranslate RFC IPX/AARP\n");
-                    delta = RX_MAC_HEADER_LENGTH - ETH_HLEN;
-                    peth = (struct ethhdr *)(skb->data + delta);
-                    peth->h_proto = htons(len - RX_MAC_HEADER_LENGTH);
-                    break;
-                default:
-                    DEBUG(3,"ray_cs untranslate RFC default\n");
-                    delta = RX_MAC_HEADER_LENGTH + 
-                        sizeof(struct snaphdr_t) - ETH_HLEN;
-                    peth = (struct ethhdr *)(skb->data + delta);
-                    peth->h_proto = type;
-                    break;
-                }
-	} else {
-                printk("ray_cs untranslate very confused by packet\n");
-                delta = RX_MAC_HEADER_LENGTH - ETH_HLEN;
-                peth = (struct ethhdr *)(skb->data + delta);
-                peth->h_proto = type;
+	if (psnap->dsap != 0xaa || psnap->ssap != 0xaa || psnap->ctrl != 3) {
+		/* not a snap type so leave it alone */
+		DEBUG(3, "ray_cs untranslate NOT SNAP %02x %02x %02x\n",
+		      psnap->dsap, psnap->ssap, psnap->ctrl);
+
+		delta = RX_MAC_HEADER_LENGTH - ETH_HLEN;
+		peth = (struct ethhdr *)(skb->data + delta);
+		peth->h_proto = htons(len - RX_MAC_HEADER_LENGTH);
+	} else { /* Its a SNAP */
+		if (memcmp(psnap->org, org_bridge, 3) == 0) {
+		/* EtherII and nuke the LLC */
+			DEBUG(3, "ray_cs untranslate Bridge encap\n");
+			delta = RX_MAC_HEADER_LENGTH
+			    + sizeof(struct snaphdr_t) - ETH_HLEN;
+			peth = (struct ethhdr *)(skb->data + delta);
+			peth->h_proto = type;
+		} else if (memcmp(psnap->org, org_1042, 3) == 0) {
+			switch (ntohs(type)) {
+			case ETH_P_IPX:
+			case ETH_P_AARP:
+				DEBUG(3, "ray_cs untranslate RFC IPX/AARP\n");
+				delta = RX_MAC_HEADER_LENGTH - ETH_HLEN;
+				peth = (struct ethhdr *)(skb->data + delta);
+				peth->h_proto =
+				    htons(len - RX_MAC_HEADER_LENGTH);
+				break;
+			default:
+				DEBUG(3, "ray_cs untranslate RFC default\n");
+				delta = RX_MAC_HEADER_LENGTH +
+				    sizeof(struct snaphdr_t) - ETH_HLEN;
+				peth = (struct ethhdr *)(skb->data + delta);
+				peth->h_proto = type;
+				break;
+			}
+		} else {
+			printk("ray_cs untranslate very confused by packet\n");
+			delta = RX_MAC_HEADER_LENGTH - ETH_HLEN;
+			peth = (struct ethhdr *)(skb->data + delta);
+			peth->h_proto = type;
+		}
 	}
-    }
 /* TBD reserve  skb_reserve(skb, delta); */
-    skb_pull(skb, delta);
-    DEBUG(3,"untranslate after skb_pull(%d), skb->data = %p\n",delta,skb->data);
-    memcpy(peth->h_dest, destaddr, ADDRLEN);
-    memcpy(peth->h_source, srcaddr, ADDRLEN);
+	skb_pull(skb, delta);
+	DEBUG(3, "untranslate after skb_pull(%d), skb->data = %p\n", delta,
+	      skb->data);
+	memcpy(peth->h_dest, destaddr, ADDRLEN);
+	memcpy(peth->h_source, srcaddr, ADDRLEN);
 #ifdef PCMCIA_DEBUG
-    if (pc_debug > 3) {
-    int i;
-    printk(KERN_DEBUG "skb->data after untranslate:");
-    for (i=0;i<64;i++)
-        printk("%02x ",skb->data[i]);
-    printk("\n");
-    }
+	if (pc_debug > 3) {
+		int i;
+		printk(KERN_DEBUG "skb->data after untranslate:");
+		for (i = 0; i < 64; i++)
+			printk("%02x ", skb->data[i]);
+		printk("\n");
+	}
 #endif
 } /* end untranslate */
+
 /*===========================================================================*/
 /* Copy data from circular receive buffer to PC memory.
  * dest     = destination address in PC memory
  * pkt_addr = source address in receive buffer
  * len      = length of packet to copy
  */
-static int copy_from_rx_buff(ray_dev_t *local, UCHAR *dest, int pkt_addr, int length)
-{
-    int wrap_bytes = (pkt_addr + length) - (RX_BUFF_END + 1);
-    if (wrap_bytes <= 0)
-    {
-        memcpy_fromio(dest,local->rmem + pkt_addr,length);
-    }
-    else /* Packet wrapped in circular buffer */
-    {
-        memcpy_fromio(dest,local->rmem+pkt_addr,length - wrap_bytes);
-        memcpy_fromio(dest + length - wrap_bytes, local->rmem, wrap_bytes);
-    }
-    return length;
+static int copy_from_rx_buff(ray_dev_t *local, UCHAR *dest, int pkt_addr,
+			     int length)
+{
+	int wrap_bytes = (pkt_addr + length) - (RX_BUFF_END + 1);
+	if (wrap_bytes <= 0) {
+		memcpy_fromio(dest, local->rmem + pkt_addr, length);
+	} else { /* Packet wrapped in circular buffer */
+
+		memcpy_fromio(dest, local->rmem + pkt_addr,
+			      length - wrap_bytes);
+		memcpy_fromio(dest + length - wrap_bytes, local->rmem,
+			      wrap_bytes);
+	}
+	return length;
 }
+
 /*===========================================================================*/
-static void release_frag_chain(ray_dev_t *local, struct rcs __iomem * prcs)
-{
-    struct rcs __iomem *prcslink = prcs;
-    int tmp = 17;
-    unsigned rcsindex = readb(&prcs->var.rx_packet.next_frag_rcs_index);
-
-    while (tmp--) {
-        writeb(CCS_BUFFER_FREE, &prcslink->buffer_status);
-        if (rcsindex >= (NUMBER_OF_CCS + NUMBER_OF_RCS)) {
-            DEBUG(1,"ray_cs interrupt bad rcsindex = 0x%x\n",rcsindex);
-            break;      
-        }   
-        prcslink = rcs_base(local) + rcsindex;
-        rcsindex = readb(&prcslink->var.rx_packet.next_frag_rcs_index);
-    }
-    writeb(CCS_BUFFER_FREE, &prcslink->buffer_status);
+static void release_frag_chain(ray_dev_t *local, struct rcs __iomem *prcs)
+{
+	struct rcs __iomem *prcslink = prcs;
+	int tmp = 17;
+	unsigned rcsindex = readb(&prcs->var.rx_packet.next_frag_rcs_index);
+
+	while (tmp--) {
+		writeb(CCS_BUFFER_FREE, &prcslink->buffer_status);
+		if (rcsindex >= (NUMBER_OF_CCS + NUMBER_OF_RCS)) {
+			DEBUG(1, "ray_cs interrupt bad rcsindex = 0x%x\n",
+			      rcsindex);
+			break;
+		}
+		prcslink = rcs_base(local) + rcsindex;
+		rcsindex = readb(&prcslink->var.rx_packet.next_frag_rcs_index);
+	}
+	writeb(CCS_BUFFER_FREE, &prcslink->buffer_status);
 }
+
 /*===========================================================================*/
 static void authenticate(ray_dev_t *local)
 {
-    struct pcmcia_device *link = local->finder;
-    DEBUG(0,"ray_cs Starting authentication.\n");
-    if (!(pcmcia_dev_present(link))) {
-        DEBUG(2,"ray_cs authenticate - device not present\n");
-        return;
-    }
-
-    del_timer(&local->timer);
-    if (build_auth_frame(local, local->bss_id, OPEN_AUTH_REQUEST)) {
-        local->timer.function = &join_net;
-    }
-    else {
-        local->timer.function = &authenticate_timeout;
-    }
-    local->timer.expires = jiffies + HZ*2;
-    local->timer.data = (long)local;
-    add_timer(&local->timer);
-    local->authentication_state = AWAITING_RESPONSE;
+	struct pcmcia_device *link = local->finder;
+	DEBUG(0, "ray_cs Starting authentication.\n");
+	if (!(pcmcia_dev_present(link))) {
+		DEBUG(2, "ray_cs authenticate - device not present\n");
+		return;
+	}
+
+	del_timer(&local->timer);
+	if (build_auth_frame(local, local->bss_id, OPEN_AUTH_REQUEST)) {
+		local->timer.function = &join_net;
+	} else {
+		local->timer.function = &authenticate_timeout;
+	}
+	local->timer.expires = jiffies + HZ * 2;
+	local->timer.data = (long)local;
+	add_timer(&local->timer);
+	local->authentication_state = AWAITING_RESPONSE;
 } /* end authenticate */
+
 /*===========================================================================*/
 static void rx_authenticate(ray_dev_t *local, struct rcs __iomem *prcs,
-                     unsigned int pkt_addr, int rx_len)
-{
-    UCHAR buff[256];
-    struct rx_msg *msg = (struct rx_msg *)buff;
-    
-    del_timer(&local->timer);
-
-    copy_from_rx_buff(local, buff, pkt_addr, rx_len & 0xff);
-    /* if we are trying to get authenticated */
-    if (local->sparm.b4.a_network_type == ADHOC) {
-        DEBUG(1,"ray_cs rx_auth var= %02x %02x %02x %02x %02x %02x\n", msg->var[0],msg->var[1],msg->var[2],msg->var[3],msg->var[4],msg->var[5]);
-        if (msg->var[2] == 1) {
-                    DEBUG(0,"ray_cs Sending authentication response.\n");
-                    if (!build_auth_frame (local, msg->mac.addr_2, OPEN_AUTH_RESPONSE)) {
-                        local->authentication_state = NEED_TO_AUTH;
-                        memcpy(local->auth_id, msg->mac.addr_2, ADDRLEN);
-                    }
-        }
-    }
-    else /* Infrastructure network */
-    {
-        if (local->authentication_state == AWAITING_RESPONSE) {
-            /* Verify authentication sequence #2 and success */
-            if (msg->var[2] == 2) {
-                if ((msg->var[3] | msg->var[4]) == 0) {
-                    DEBUG(1,"Authentication successful\n");
-                    local->card_status = CARD_AUTH_COMPLETE;
-                    associate(local);
-                    local->authentication_state = AUTHENTICATED;
-                }
-                else {
-                    DEBUG(0,"Authentication refused\n");
-                    local->card_status = CARD_AUTH_REFUSED;
-                    join_net((u_long)local);
-                    local->authentication_state = UNAUTHENTICATED;
-                }
-            }
-        }
-    }
+			    unsigned int pkt_addr, int rx_len)
+{
+	UCHAR buff[256];
+	struct rx_msg *msg = (struct rx_msg *)buff;
+
+	del_timer(&local->timer);
+
+	copy_from_rx_buff(local, buff, pkt_addr, rx_len & 0xff);
+	/* if we are trying to get authenticated */
+	if (local->sparm.b4.a_network_type == ADHOC) {
+		DEBUG(1, "ray_cs rx_auth var= %02x %02x %02x %02x %02x %02x\n",
+		      msg->var[0], msg->var[1], msg->var[2], msg->var[3],
+		      msg->var[4], msg->var[5]);
+		if (msg->var[2] == 1) {
+			DEBUG(0, "ray_cs Sending authentication response.\n");
+			if (!build_auth_frame
+			    (local, msg->mac.addr_2, OPEN_AUTH_RESPONSE)) {
+				local->authentication_state = NEED_TO_AUTH;
+				memcpy(local->auth_id, msg->mac.addr_2,
+				       ADDRLEN);
+			}
+		}
+	} else { /* Infrastructure network */
+
+		if (local->authentication_state == AWAITING_RESPONSE) {
+			/* Verify authentication sequence #2 and success */
+			if (msg->var[2] == 2) {
+				if ((msg->var[3] | msg->var[4]) == 0) {
+					DEBUG(1, "Authentication successful\n");
+					local->card_status = CARD_AUTH_COMPLETE;
+					associate(local);
+					local->authentication_state =
+					    AUTHENTICATED;
+				} else {
+					DEBUG(0, "Authentication refused\n");
+					local->card_status = CARD_AUTH_REFUSED;
+					join_net((u_long) local);
+					local->authentication_state =
+					    UNAUTHENTICATED;
+				}
+			}
+		}
+	}
 
 } /* end rx_authenticate */
+
 /*===========================================================================*/
 static void associate(ray_dev_t *local)
 {
-    struct ccs __iomem *pccs;
-    struct pcmcia_device *link = local->finder;
-    struct net_device *dev = link->priv;
-    int ccsindex;
-    if (!(pcmcia_dev_present(link))) {
-        DEBUG(2,"ray_cs associate - device not present\n");
-        return;
-    }
-    /* If no tx buffers available, return*/
-    if ((ccsindex = get_free_ccs(local)) < 0)
-    {
+	struct ccs __iomem *pccs;
+	struct pcmcia_device *link = local->finder;
+	struct net_device *dev = link->priv;
+	int ccsindex;
+	if (!(pcmcia_dev_present(link))) {
+		DEBUG(2, "ray_cs associate - device not present\n");
+		return;
+	}
+	/* If no tx buffers available, return */
+	if ((ccsindex = get_free_ccs(local)) < 0) {
 /* TBD should never be here but... what if we are? */
-        DEBUG(1,"ray_cs associate - No free ccs\n");
-        return;
-    }
-    DEBUG(1,"ray_cs Starting association with access point\n");
-    pccs = ccs_base(local) + ccsindex;
-    /* fill in the CCS */
-    writeb(CCS_START_ASSOCIATION, &pccs->cmd);
-    /* Interrupt the firmware to process the command */
-    if (interrupt_ecf(local, ccsindex)) {
-        DEBUG(1,"ray_cs associate failed - ECF not ready for intr\n");
-        writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
-
-        del_timer(&local->timer);
-        local->timer.expires = jiffies + HZ*2;
-        local->timer.data = (long)local;
-        local->timer.function = &join_net;
-        add_timer(&local->timer);
-        local->card_status = CARD_ASSOC_FAILED;
-        return;
-    }
-    if (!sniffer) netif_start_queue(dev);
+		DEBUG(1, "ray_cs associate - No free ccs\n");
+		return;
+	}
+	DEBUG(1, "ray_cs Starting association with access point\n");
+	pccs = ccs_base(local) + ccsindex;
+	/* fill in the CCS */
+	writeb(CCS_START_ASSOCIATION, &pccs->cmd);
+	/* Interrupt the firmware to process the command */
+	if (interrupt_ecf(local, ccsindex)) {
+		DEBUG(1, "ray_cs associate failed - ECF not ready for intr\n");
+		writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
+
+		del_timer(&local->timer);
+		local->timer.expires = jiffies + HZ * 2;
+		local->timer.data = (long)local;
+		local->timer.function = &join_net;
+		add_timer(&local->timer);
+		local->card_status = CARD_ASSOC_FAILED;
+		return;
+	}
+	if (!sniffer)
+		netif_start_queue(dev);
 
 } /* end associate */
+
 /*===========================================================================*/
-static void rx_deauthenticate(ray_dev_t *local, struct rcs __iomem *prcs, 
-                       unsigned int pkt_addr, int rx_len)
+static void rx_deauthenticate(ray_dev_t *local, struct rcs __iomem *prcs,
+			      unsigned int pkt_addr, int rx_len)
 {
 /*  UCHAR buff[256];
     struct rx_msg *msg = (struct rx_msg *)buff;
 */
-    DEBUG(0,"Deauthentication frame received\n");
-    local->authentication_state = UNAUTHENTICATED;
-    /* Need to reauthenticate or rejoin depending on reason code */
+	DEBUG(0, "Deauthentication frame received\n");
+	local->authentication_state = UNAUTHENTICATED;
+	/* Need to reauthenticate or rejoin depending on reason code */
 /*  copy_from_rx_buff(local, buff, pkt_addr, rx_len & 0xff);
  */
 }
+
 /*===========================================================================*/
 static void clear_interrupt(ray_dev_t *local)
 {
-    writeb(0, local->amem + CIS_OFFSET + HCS_INTR_OFFSET);
+	writeb(0, local->amem + CIS_OFFSET + HCS_INTR_OFFSET);
 }
+
 /*===========================================================================*/
 #ifdef CONFIG_PROC_FS
 #define MAXDATA (PAGE_SIZE - 80)
 
 static char *card_status[] = {
-    "Card inserted - uninitialized",     /* 0 */
-    "Card not downloaded",               /* 1 */
-    "Waiting for download parameters",   /* 2 */
-    "Card doing acquisition",            /* 3 */
-    "Acquisition complete",              /* 4 */
-    "Authentication complete",           /* 5 */
-    "Association complete",              /* 6 */
-    "???", "???", "???", "???",          /* 7 8 9 10 undefined */
-    "Card init error",                   /* 11 */
-    "Download parameters error",         /* 12 */
-    "???",                               /* 13 */
-    "Acquisition failed",                /* 14 */
-    "Authentication refused",            /* 15 */
-    "Association failed"                 /* 16 */
+	"Card inserted - uninitialized",	/* 0 */
+	"Card not downloaded",			/* 1 */
+	"Waiting for download parameters",	/* 2 */
+	"Card doing acquisition",		/* 3 */
+	"Acquisition complete",			/* 4 */
+	"Authentication complete",		/* 5 */
+	"Association complete",			/* 6 */
+	"???", "???", "???", "???",		/* 7 8 9 10 undefined */
+	"Card init error",			/* 11 */
+	"Download parameters error",		/* 12 */
+	"???",					/* 13 */
+	"Acquisition failed",			/* 14 */
+	"Authentication refused",		/* 15 */
+	"Association failed"			/* 16 */
 };
 
-static char *nettype[] = {"Adhoc", "Infra "};
-static char *framing[] = {"Encapsulation", "Translation"}
+static char *nettype[] = { "Adhoc", "Infra " };
+static char *framing[] = { "Encapsulation", "Translation" }
+
 ;
 /*===========================================================================*/
 static int ray_cs_proc_show(struct seq_file *m, void *v)
 {
 /* Print current values which are not available via other means
- * eg ifconfig 
+ * eg ifconfig
  */
-    int i;
-    struct pcmcia_device *link;
-    struct net_device *dev;
-    ray_dev_t *local;
-    UCHAR *p;
-    struct freq_hop_element *pfh;
-    UCHAR c[33];
-
-    link = this_device;
-    if (!link)
-    	return 0;
-    dev = (struct net_device *)link->priv;
-    if (!dev)
-    	return 0;
-    local = netdev_priv(dev);
-    if (!local)
-    	return 0;
-
-    seq_puts(m, "Raylink Wireless LAN driver status\n");
-    seq_printf(m, "%s\n", rcsid);
-    /* build 4 does not report version, and field is 0x55 after memtest */
-    seq_puts(m, "Firmware version     = ");
-    if (local->fw_ver == 0x55)
-        seq_puts(m, "4 - Use dump_cis for more details\n");
-    else
-        seq_printf(m, "%2d.%02d.%02d\n",
-                   local->fw_ver, local->fw_bld, local->fw_var);
-
-    for (i=0; i<32; i++) c[i] = local->sparm.b5.a_current_ess_id[i];
-    c[32] = 0;
-    seq_printf(m, "%s network ESSID = \"%s\"\n",
-                   nettype[local->sparm.b5.a_network_type], c);
-
-    p = local->bss_id;
-    seq_printf(m, "BSSID                = %pM\n", p);
-
-    seq_printf(m, "Country code         = %d\n",
-                   local->sparm.b5.a_curr_country_code);
-
-    i = local->card_status;
-    if (i < 0) i = 10;
-    if (i > 16) i = 10;
-    seq_printf(m, "Card status          = %s\n", card_status[i]);
-
-    seq_printf(m, "Framing mode         = %s\n",framing[translate]);
-
-    seq_printf(m, "Last pkt signal lvl  = %d\n", local->last_rsl);
-
-    if (local->beacon_rxed) {
-	/* Pull some fields out of last beacon received */
-	seq_printf(m, "Beacon Interval      = %d Kus\n",
-		       local->last_bcn.beacon_intvl[0]
-		       + 256 * local->last_bcn.beacon_intvl[1]);
-    
-    p = local->last_bcn.elements;
-    if (p[0] == C_ESSID_ELEMENT_ID) p += p[1] + 2;
-    else {
-        seq_printf(m, "Parse beacon failed at essid element id = %d\n",p[0]);
-        return 0;
-    }
-
-    if (p[0] == C_SUPPORTED_RATES_ELEMENT_ID) {
-        seq_puts(m, "Supported rate codes = ");
-        for (i=2; i<p[1] + 2; i++) 
-            seq_printf(m, "0x%02x ", p[i]);
-        seq_putc(m, '\n');
-        p += p[1] + 2;
-    }
-    else {
-        seq_puts(m, "Parse beacon failed at rates element\n");
-        return 0;
-    }
-
-	if (p[0] == C_FH_PARAM_SET_ELEMENT_ID) {
-	    pfh = (struct freq_hop_element *)p;
-	    seq_printf(m, "Hop dwell            = %d Kus\n",
-			   pfh->dwell_time[0] + 256 * pfh->dwell_time[1]);
-	    seq_printf(m, "Hop set              = %d \n", pfh->hop_set);
-	    seq_printf(m, "Hop pattern          = %d \n", pfh->hop_pattern);
-	    seq_printf(m, "Hop index            = %d \n", pfh->hop_index);
-	    p += p[1] + 2;
-	}
-	else {
-	    seq_puts(m, "Parse beacon failed at FH param element\n");
-	    return 0;
+	int i;
+	struct pcmcia_device *link;
+	struct net_device *dev;
+	ray_dev_t *local;
+	UCHAR *p;
+	struct freq_hop_element *pfh;
+	UCHAR c[33];
+
+	link = this_device;
+	if (!link)
+		return 0;
+	dev = (struct net_device *)link->priv;
+	if (!dev)
+		return 0;
+	local = netdev_priv(dev);
+	if (!local)
+		return 0;
+
+	seq_puts(m, "Raylink Wireless LAN driver status\n");
+	seq_printf(m, "%s\n", rcsid);
+	/* build 4 does not report version, and field is 0x55 after memtest */
+	seq_puts(m, "Firmware version     = ");
+	if (local->fw_ver == 0x55)
+		seq_puts(m, "4 - Use dump_cis for more details\n");
+	else
+		seq_printf(m, "%2d.%02d.%02d\n",
+			   local->fw_ver, local->fw_bld, local->fw_var);
+
+	for (i = 0; i < 32; i++)
+		c[i] = local->sparm.b5.a_current_ess_id[i];
+	c[32] = 0;
+	seq_printf(m, "%s network ESSID = \"%s\"\n",
+		   nettype[local->sparm.b5.a_network_type], c);
+
+	p = local->bss_id;
+	seq_printf(m, "BSSID                = %pM\n", p);
+
+	seq_printf(m, "Country code         = %d\n",
+		   local->sparm.b5.a_curr_country_code);
+
+	i = local->card_status;
+	if (i < 0)
+		i = 10;
+	if (i > 16)
+		i = 10;
+	seq_printf(m, "Card status          = %s\n", card_status[i]);
+
+	seq_printf(m, "Framing mode         = %s\n", framing[translate]);
+
+	seq_printf(m, "Last pkt signal lvl  = %d\n", local->last_rsl);
+
+	if (local->beacon_rxed) {
+		/* Pull some fields out of last beacon received */
+		seq_printf(m, "Beacon Interval      = %d Kus\n",
+			   local->last_bcn.beacon_intvl[0]
+			   + 256 * local->last_bcn.beacon_intvl[1]);
+
+		p = local->last_bcn.elements;
+		if (p[0] == C_ESSID_ELEMENT_ID)
+			p += p[1] + 2;
+		else {
+			seq_printf(m,
+				   "Parse beacon failed at essid element id = %d\n",
+				   p[0]);
+			return 0;
+		}
+
+		if (p[0] == C_SUPPORTED_RATES_ELEMENT_ID) {
+			seq_puts(m, "Supported rate codes = ");
+			for (i = 2; i < p[1] + 2; i++)
+				seq_printf(m, "0x%02x ", p[i]);
+			seq_putc(m, '\n');
+			p += p[1] + 2;
+		} else {
+			seq_puts(m, "Parse beacon failed at rates element\n");
+			return 0;
+		}
+
+		if (p[0] == C_FH_PARAM_SET_ELEMENT_ID) {
+			pfh = (struct freq_hop_element *)p;
+			seq_printf(m, "Hop dwell            = %d Kus\n",
+				   pfh->dwell_time[0] +
+				   256 * pfh->dwell_time[1]);
+			seq_printf(m, "Hop set              = %d \n",
+				   pfh->hop_set);
+			seq_printf(m, "Hop pattern          = %d \n",
+				   pfh->hop_pattern);
+			seq_printf(m, "Hop index            = %d \n",
+				   pfh->hop_index);
+			p += p[1] + 2;
+		} else {
+			seq_puts(m,
+				 "Parse beacon failed at FH param element\n");
+			return 0;
+		}
+	} else {
+		seq_puts(m, "No beacons received\n");
 	}
-    } else {
-	seq_puts(m, "No beacons received\n");
-    }
-    return 0;
+	return 0;
 }
 
 static int ray_cs_proc_open(struct inode *inode, struct file *file)
@@ -2684,74 +2799,77 @@ static int ray_cs_proc_open(struct inode *inode, struct file *file)
 }
 
 static const struct file_operations ray_cs_proc_fops = {
-	.owner		= THIS_MODULE,
-	.open		= ray_cs_proc_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
+	.owner = THIS_MODULE,
+	.open = ray_cs_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
 };
 #endif
 /*===========================================================================*/
 static int build_auth_frame(ray_dev_t *local, UCHAR *dest, int auth_type)
 {
-    int addr;
-    struct ccs __iomem *pccs;
-    struct tx_msg __iomem *ptx;
-    int ccsindex;
-
-    /* If no tx buffers available, return */
-    if ((ccsindex = get_free_tx_ccs(local)) < 0)
-    {
-        DEBUG(1,"ray_cs send authenticate - No free tx ccs\n");
-        return -1;
-    }
-
-    pccs = ccs_base(local) + ccsindex;
-
-    /* Address in card space */
-    addr = TX_BUF_BASE + (ccsindex << 11);
-    /* fill in the CCS */
-    writeb(CCS_TX_REQUEST, &pccs->cmd);
-    writeb(addr >> 8, pccs->var.tx_request.tx_data_ptr);
-    writeb(0x20, pccs->var.tx_request.tx_data_ptr + 1);
-    writeb(TX_AUTHENTICATE_LENGTH_MSB, pccs->var.tx_request.tx_data_length);
-    writeb(TX_AUTHENTICATE_LENGTH_LSB,pccs->var.tx_request.tx_data_length + 1);
-    writeb(0, &pccs->var.tx_request.pow_sav_mode);
-
-    ptx = local->sram + addr;
-    /* fill in the mac header */
-    writeb(PROTOCOL_VER | AUTHENTIC_TYPE, &ptx->mac.frame_ctl_1);
-    writeb(0, &ptx->mac.frame_ctl_2);
-
-    memcpy_toio(ptx->mac.addr_1, dest, ADDRLEN);
-    memcpy_toio(ptx->mac.addr_2, local->sparm.b4.a_mac_addr, ADDRLEN);
-    memcpy_toio(ptx->mac.addr_3, local->bss_id, ADDRLEN);
-
-    /* Fill in msg body with protocol 00 00, sequence 01 00 ,status 00 00 */
-    memset_io(ptx->var, 0, 6);
-    writeb(auth_type & 0xff, ptx->var + 2);
-
-    /* Interrupt the firmware to process the command */
-    if (interrupt_ecf(local, ccsindex)) {
-        DEBUG(1,"ray_cs send authentication request failed - ECF not ready for intr\n");
-        writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
-        return -1;
-    }
-    return 0;
+	int addr;
+	struct ccs __iomem *pccs;
+	struct tx_msg __iomem *ptx;
+	int ccsindex;
+
+	/* If no tx buffers available, return */
+	if ((ccsindex = get_free_tx_ccs(local)) < 0) {
+		DEBUG(1, "ray_cs send authenticate - No free tx ccs\n");
+		return -1;
+	}
+
+	pccs = ccs_base(local) + ccsindex;
+
+	/* Address in card space */
+	addr = TX_BUF_BASE + (ccsindex << 11);
+	/* fill in the CCS */
+	writeb(CCS_TX_REQUEST, &pccs->cmd);
+	writeb(addr >> 8, pccs->var.tx_request.tx_data_ptr);
+	writeb(0x20, pccs->var.tx_request.tx_data_ptr + 1);
+	writeb(TX_AUTHENTICATE_LENGTH_MSB, pccs->var.tx_request.tx_data_length);
+	writeb(TX_AUTHENTICATE_LENGTH_LSB,
+	       pccs->var.tx_request.tx_data_length + 1);
+	writeb(0, &pccs->var.tx_request.pow_sav_mode);
+
+	ptx = local->sram + addr;
+	/* fill in the mac header */
+	writeb(PROTOCOL_VER | AUTHENTIC_TYPE, &ptx->mac.frame_ctl_1);
+	writeb(0, &ptx->mac.frame_ctl_2);
+
+	memcpy_toio(ptx->mac.addr_1, dest, ADDRLEN);
+	memcpy_toio(ptx->mac.addr_2, local->sparm.b4.a_mac_addr, ADDRLEN);
+	memcpy_toio(ptx->mac.addr_3, local->bss_id, ADDRLEN);
+
+	/* Fill in msg body with protocol 00 00, sequence 01 00 ,status 00 00 */
+	memset_io(ptx->var, 0, 6);
+	writeb(auth_type & 0xff, ptx->var + 2);
+
+	/* Interrupt the firmware to process the command */
+	if (interrupt_ecf(local, ccsindex)) {
+		DEBUG(1,
+		      "ray_cs send authentication request failed - ECF not ready for intr\n");
+		writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
+		return -1;
+	}
+	return 0;
 } /* End build_auth_frame */
 
 /*===========================================================================*/
 #ifdef CONFIG_PROC_FS
 static void raycs_write(const char *name, write_proc_t *w, void *data)
 {
-	struct proc_dir_entry * entry = create_proc_entry(name, S_IFREG | S_IWUSR, NULL);
+	struct proc_dir_entry *entry =
+	    create_proc_entry(name, S_IFREG | S_IWUSR, NULL);
 	if (entry) {
 		entry->write_proc = w;
 		entry->data = data;
 	}
 }
 
-static int write_essid(struct file *file, const char __user *buffer, unsigned long count, void *data)
+static int write_essid(struct file *file, const char __user *buffer,
+		       unsigned long count, void *data)
 {
 	static char proc_essid[33];
 	int len = count;
@@ -2765,7 +2883,8 @@ static int write_essid(struct file *file, const char __user *buffer, unsigned lo
 	return count;
 }
 
-static int write_int(struct file *file, const char __user *buffer, unsigned long count, void *data)
+static int write_int(struct file *file, const char __user *buffer,
+		     unsigned long count, void *data)
 {
 	static char proc_number[10];
 	char *p;
@@ -2785,7 +2904,7 @@ static int write_int(struct file *file, const char __user *buffer, unsigned long
 		unsigned int c = *p - '0';
 		if (c > 9)
 			return -EINVAL;
-		nr = nr*10 + c;
+		nr = nr * 10 + c;
 		p++;
 	} while (--len);
 	*(int *)data = nr;
@@ -2797,55 +2916,58 @@ static struct pcmcia_device_id ray_ids[] = {
 	PCMCIA_DEVICE_MANF_CARD(0x01a6, 0x0000),
 	PCMCIA_DEVICE_NULL,
 };
+
 MODULE_DEVICE_TABLE(pcmcia, ray_ids);
 
 static struct pcmcia_driver ray_driver = {
-	.owner		= THIS_MODULE,
-	.drv		= {
-		.name	= "ray_cs",
-	},
-	.probe		= ray_probe,
-	.remove		= ray_detach,
-	.id_table       = ray_ids,
-	.suspend	= ray_suspend,
-	.resume		= ray_resume,
+	.owner = THIS_MODULE,
+	.drv = {
+		.name = "ray_cs",
+		},
+	.probe = ray_probe,
+	.remove = ray_detach,
+	.id_table = ray_ids,
+	.suspend = ray_suspend,
+	.resume = ray_resume,
 };
 
 static int __init init_ray_cs(void)
 {
-    int rc;
-    
-    DEBUG(1, "%s\n", rcsid);
-    rc = pcmcia_register_driver(&ray_driver);
-    DEBUG(1, "raylink init_module register_pcmcia_driver returns 0x%x\n",rc);
+	int rc;
+
+	DEBUG(1, "%s\n", rcsid);
+	rc = pcmcia_register_driver(&ray_driver);
+	DEBUG(1, "raylink init_module register_pcmcia_driver returns 0x%x\n",
+	      rc);
 
 #ifdef CONFIG_PROC_FS
-    proc_mkdir("driver/ray_cs", NULL);
+	proc_mkdir("driver/ray_cs", NULL);
 
-    proc_create("driver/ray_cs/ray_cs", 0, NULL, &ray_cs_proc_fops);
-    raycs_write("driver/ray_cs/essid", write_essid, NULL);
-    raycs_write("driver/ray_cs/net_type", write_int, &net_type);
-    raycs_write("driver/ray_cs/translate", write_int, &translate);
+	proc_create("driver/ray_cs/ray_cs", 0, NULL, &ray_cs_proc_fops);
+	raycs_write("driver/ray_cs/essid", write_essid, NULL);
+	raycs_write("driver/ray_cs/net_type", write_int, &net_type);
+	raycs_write("driver/ray_cs/translate", write_int, &translate);
 #endif
-    if (translate != 0) translate = 1;
-    return 0;
+	if (translate != 0)
+		translate = 1;
+	return 0;
 } /* init_ray_cs */
 
 /*===========================================================================*/
 
 static void __exit exit_ray_cs(void)
 {
-    DEBUG(0, "ray_cs: cleanup_module\n");
+	DEBUG(0, "ray_cs: cleanup_module\n");
 
 #ifdef CONFIG_PROC_FS
-    remove_proc_entry("driver/ray_cs/ray_cs", NULL);
-    remove_proc_entry("driver/ray_cs/essid", NULL);
-    remove_proc_entry("driver/ray_cs/net_type", NULL);
-    remove_proc_entry("driver/ray_cs/translate", NULL);
-    remove_proc_entry("driver/ray_cs", NULL);
+	remove_proc_entry("driver/ray_cs/ray_cs", NULL);
+	remove_proc_entry("driver/ray_cs/essid", NULL);
+	remove_proc_entry("driver/ray_cs/net_type", NULL);
+	remove_proc_entry("driver/ray_cs/translate", NULL);
+	remove_proc_entry("driver/ray_cs", NULL);
 #endif
 
-    pcmcia_unregister_driver(&ray_driver);
+	pcmcia_unregister_driver(&ray_driver);
 } /* exit_ray_cs */
 
 module_init(init_ray_cs);

commit 2ed5ba890e1e8dda89557e4ea233a26ab8bf3d58
Author: Hannes Eder <hannes@hanneseder.net>
Date:   Fri Dec 26 00:12:59 2008 -0800

    drivers/net/wireless: fix sparse warnings: make symbols static
    
    Fix this sparse warnings:
    
      drivers/net/wireless/airo.c:3610:6: warning: symbol 'mpi_receive_802_11' was not declared. Should it be static?
      drivers/net/wireless/atmel.c:3183:6: warning: symbol 'atmel_join_bss' was not declared. Should it be static?
      drivers/net/wireless/ray_cs.c:831:5: warning: symbol 'ray_dev_init' was not declared. Should it be static?
    
    Signed-off-by: Hannes Eder <hannes@hanneseder.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 81b71f07f5ad..99ec7d622518 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -828,7 +828,7 @@ static int ray_resume(struct pcmcia_device *link)
 }
 
 /*===========================================================================*/
-int ray_dev_init(struct net_device *dev)
+static int ray_dev_init(struct net_device *dev)
 {
 #ifdef RAY_IMMEDIATE_INIT
     int i;

commit babcda74e9d96bb58fd9c6c5112dbdbff169e695
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Nov 3 21:11:17 2008 -0800

    drivers/net: Kill now superfluous ->last_rx stores.
    
    The generic packet receive code takes care of setting
    netdev->last_rx when necessary, for the sake of the
    bonding ARP monitor.
    
    Drivers need not do it any more.
    
    Some cases had to be skipped over because the drivers
    were making use of the ->last_rx value themselves.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index bf0b9299b5df..81b71f07f5ad 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2284,7 +2284,6 @@ static void rx_data(struct net_device *dev, struct rcs __iomem *prcs, unsigned i
 
     skb->protocol = eth_type_trans(skb,dev);
     netif_rx(skb);
-    dev->last_rx = jiffies;
     local->stats.rx_packets++;
     local->stats.rx_bytes += total_len;
 

commit e174961ca1a0b28f7abf0be47973ad57cb74e5f0
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Oct 27 15:59:26 2008 -0700

    net: convert print_mac to %pM
    
    This converts pretty much everything to print_mac. There were
    a few things that had conflicts which I have just dropped for
    now, no harm done.
    
    I've built an allyesconfig with this and looked at the files
    that weren't built very carefully, but it's a huge patch.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 1404a5717520..bf0b9299b5df 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -414,7 +414,6 @@ static int ray_config(struct pcmcia_device *link)
     memreq_t mem;
     struct net_device *dev = (struct net_device *)link->priv;
     ray_dev_t *local = netdev_priv(dev);
-    DECLARE_MAC_BUF(mac);
 
     DEBUG(1, "ray_config(0x%p)\n", link);
 
@@ -485,8 +484,8 @@ static int ray_config(struct pcmcia_device *link)
     strcpy(local->node.dev_name, dev->name);
     link->dev_node = &local->node;
 
-    printk(KERN_INFO "%s: RayLink, irq %d, hw_addr %s\n",
-       dev->name, dev->irq, print_mac(mac, dev->dev_addr));
+    printk(KERN_INFO "%s: RayLink, irq %d, hw_addr %pM\n",
+       dev->name, dev->irq, dev->dev_addr);
 
     return 0;
 
@@ -2595,7 +2594,6 @@ static int ray_cs_proc_show(struct seq_file *m, void *v)
     UCHAR *p;
     struct freq_hop_element *pfh;
     UCHAR c[33];
-    DECLARE_MAC_BUF(mac);
 
     link = this_device;
     if (!link)
@@ -2623,8 +2621,7 @@ static int ray_cs_proc_show(struct seq_file *m, void *v)
                    nettype[local->sparm.b5.a_network_type], c);
 
     p = local->bss_id;
-    seq_printf(m, "BSSID                = %s\n",
-                   print_mac(mac, p));
+    seq_printf(m, "BSSID                = %pM\n", p);
 
     seq_printf(m, "Country code         = %d\n",
                    local->sparm.b5.a_curr_country_code);

commit 2be4ff2f084842839b041b793ed6237e8d1d315a
Merge: cf2fa66055d7 a45b3fb19ba1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 13 14:12:40 2008 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/brodo/pcmcia-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/brodo/pcmcia-2.6: (49 commits)
      pcmcia: ioctl-internal definitions
      pcmcia: cistpl header cleanup
      pcmcia: remove unused argument to pcmcia_parse_tuple()
      pcmcia: card services header cleanup
      pcmcia: device_id header cleanup
      pcmcia: encapsulate ioaddr_t
      pcmcia: cleanup device driver header file
      pcmcia: cleanup socket services header file
      pcmcia: merge ds_internal.h into cs_internal.h
      pcmcia: cleanup cs_internal.h
      pcmcia: cs_internal.h is internal
      pcmcia: use dev_printk for cs_error()
      pcmcia: remove CS_ error codes alltogether
      pcmcia: deprecate CS_BAD_TUPLE
      pcmcia: deprecate CS_BAD_ARGS
      pcmcia: deprecate CS_BAD_BASE, CS_BAD_IRQ, CS_BAD_OFFSET and CS_BAD_SIZE
      pcmcia: deprecate CS_BAD_ATTRIBUTE, CS_BAD_TYPE and CS_BAD_PAGE
      pcmcia: deprecate CS_NO_MORE_ITEMS
      pcmcia: deprecate CS_IN_USE
      pcmcia: deprecate CS_CONFIGURATION_LOCKED
      ...
    
    Fix trivial conflict in drivers/pcmcia/ds.c manually

commit 47cbb1107e4172f3632713d74dc8651a32ceb294
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue Sep 23 13:53:09 2008 +0100

    pcmcia: Fix up legacy driver IRQs
    
    The PCMCIA layer obsoleted asking for per device private IRQS some years
    ago and all the drivers by inspection correctly use dev_id and handle
    shared interrupts [they get em anyway in most PCI bridged PCMCIA/Cardbus]
    so can be adjusted.
    
    This gets rid of the various bugs reported where there is spewage about
    conflicting irq types and sometimes the driver won't load.
    
    (Note I don't have all of these devices to test each one beyond by inspection)
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 963960dc30f2..44da0d19b5c8 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -325,7 +325,7 @@ static int ray_probe(struct pcmcia_device *p_dev)
     p_dev->io.IOAddrLines = 5;
 
     /* Interrupt setup. For PCMCIA, driver takes what's given */
-    p_dev->irq.Attributes = IRQ_TYPE_EXCLUSIVE | IRQ_HANDLE_PRESENT;
+    p_dev->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING | IRQ_HANDLE_PRESENT;
     p_dev->irq.IRQInfo1 = IRQ_LEVEL_ID;
     p_dev->irq.Handler = &ray_interrupt;
 

commit 4c89e88bfde6a3c179790e21004f24e09a058290
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Aug 3 10:07:45 2008 +0200

    pcmcia: deprecate CS_SUCCESS
    
    Instead of using own error or success codes, the PCMCIA code should rely on
    the generic return values. Therefore, replace all occurrences of CS_SUCCESS
    with 0.
    
    CC: netdev@vger.kernel.org
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 963960dc30f2..99c7c8bc2573 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -798,9 +798,9 @@ static void ray_release(struct pcmcia_device *link)
     iounmap(local->amem);
     /* Do bother checking to see if these succeed or not */
     i = pcmcia_release_window(local->amem_handle);
-    if ( i != CS_SUCCESS ) DEBUG(0,"ReleaseWindow(local->amem) ret = %x\n",i);
+    if ( i != 0 ) DEBUG(0,"ReleaseWindow(local->amem) ret = %x\n",i);
     i = pcmcia_release_window(local->rmem_handle);
-    if ( i != CS_SUCCESS ) DEBUG(0,"ReleaseWindow(local->rmem) ret = %x\n",i);
+    if ( i != 0 ) DEBUG(0,"ReleaseWindow(local->rmem) ret = %x\n",i);
     pcmcia_disable_device(link);
 
     DEBUG(2,"ray_release ending\n");

commit 6b914c521687ae6cb8923c7235fd69b7bc027703
Author: Alexey Dobriyan <adobriyan@sw.ru>
Date:   Thu Apr 10 14:34:35 2008 -0700

    proc: switch /proc/driver/ray_cs/ray_cs to seq_file interface
    
    Signed-off-by: Alexey Dobriyan <adobriyan@sw.ru>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Jean Tourrilhes <jt@hpl.hp.com>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index f3858ee36f32..963960dc30f2 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -34,6 +34,7 @@
 #include <linux/kernel.h>
 #include <linux/proc_fs.h>
 #include <linux/ptrace.h>
+#include <linux/seq_file.h>
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/timer.h>
@@ -2582,7 +2583,7 @@ static char *nettype[] = {"Adhoc", "Infra "};
 static char *framing[] = {"Encapsulation", "Translation"}
 ;
 /*===========================================================================*/
-static int ray_cs_proc_read(char *buf, char **start, off_t offset, int len)
+static int ray_cs_proc_show(struct seq_file *m, void *v)
 {
 /* Print current values which are not available via other means
  * eg ifconfig 
@@ -2606,83 +2607,93 @@ static int ray_cs_proc_read(char *buf, char **start, off_t offset, int len)
     if (!local)
     	return 0;
 
-    len = 0;
-
-    len += sprintf(buf + len, "Raylink Wireless LAN driver status\n");
-    len += sprintf(buf + len, "%s\n", rcsid);
+    seq_puts(m, "Raylink Wireless LAN driver status\n");
+    seq_printf(m, "%s\n", rcsid);
     /* build 4 does not report version, and field is 0x55 after memtest */
-    len += sprintf(buf + len, "Firmware version     = ");
+    seq_puts(m, "Firmware version     = ");
     if (local->fw_ver == 0x55)
-        len += sprintf(buf + len, "4 - Use dump_cis for more details\n");
+        seq_puts(m, "4 - Use dump_cis for more details\n");
     else
-        len += sprintf(buf + len, "%2d.%02d.%02d\n",
+        seq_printf(m, "%2d.%02d.%02d\n",
                    local->fw_ver, local->fw_bld, local->fw_var);
 
     for (i=0; i<32; i++) c[i] = local->sparm.b5.a_current_ess_id[i];
     c[32] = 0;
-    len += sprintf(buf + len, "%s network ESSID = \"%s\"\n", 
+    seq_printf(m, "%s network ESSID = \"%s\"\n",
                    nettype[local->sparm.b5.a_network_type], c);
 
     p = local->bss_id;
-    len += sprintf(buf + len, "BSSID                = %s\n",
+    seq_printf(m, "BSSID                = %s\n",
                    print_mac(mac, p));
 
-    len += sprintf(buf + len, "Country code         = %d\n", 
+    seq_printf(m, "Country code         = %d\n",
                    local->sparm.b5.a_curr_country_code);
 
     i = local->card_status;
     if (i < 0) i = 10;
     if (i > 16) i = 10;
-    len += sprintf(buf + len, "Card status          = %s\n", card_status[i]);
+    seq_printf(m, "Card status          = %s\n", card_status[i]);
 
-    len += sprintf(buf + len, "Framing mode         = %s\n",framing[translate]);
+    seq_printf(m, "Framing mode         = %s\n",framing[translate]);
 
-    len += sprintf(buf + len, "Last pkt signal lvl  = %d\n", local->last_rsl);
+    seq_printf(m, "Last pkt signal lvl  = %d\n", local->last_rsl);
 
     if (local->beacon_rxed) {
 	/* Pull some fields out of last beacon received */
-	len += sprintf(buf + len, "Beacon Interval      = %d Kus\n", 
+	seq_printf(m, "Beacon Interval      = %d Kus\n",
 		       local->last_bcn.beacon_intvl[0]
 		       + 256 * local->last_bcn.beacon_intvl[1]);
     
     p = local->last_bcn.elements;
     if (p[0] == C_ESSID_ELEMENT_ID) p += p[1] + 2;
     else {
-        len += sprintf(buf + len, "Parse beacon failed at essid element id = %d\n",p[0]);
-        return len;
+        seq_printf(m, "Parse beacon failed at essid element id = %d\n",p[0]);
+        return 0;
     }
 
     if (p[0] == C_SUPPORTED_RATES_ELEMENT_ID) {
-        len += sprintf(buf + len, "Supported rate codes = ");
+        seq_puts(m, "Supported rate codes = ");
         for (i=2; i<p[1] + 2; i++) 
-            len += sprintf(buf + len, "0x%02x ", p[i]);
-        len += sprintf(buf + len, "\n");
+            seq_printf(m, "0x%02x ", p[i]);
+        seq_putc(m, '\n');
         p += p[1] + 2;
     }
     else {
-        len += sprintf(buf + len, "Parse beacon failed at rates element\n");
-        return len;
+        seq_puts(m, "Parse beacon failed at rates element\n");
+        return 0;
     }
 
 	if (p[0] == C_FH_PARAM_SET_ELEMENT_ID) {
 	    pfh = (struct freq_hop_element *)p;
-	    len += sprintf(buf + len, "Hop dwell            = %d Kus\n",
+	    seq_printf(m, "Hop dwell            = %d Kus\n",
 			   pfh->dwell_time[0] + 256 * pfh->dwell_time[1]);
-	    len += sprintf(buf + len, "Hop set              = %d \n", pfh->hop_set);
-	    len += sprintf(buf + len, "Hop pattern          = %d \n", pfh->hop_pattern);
-	    len += sprintf(buf + len, "Hop index            = %d \n", pfh->hop_index);
+	    seq_printf(m, "Hop set              = %d \n", pfh->hop_set);
+	    seq_printf(m, "Hop pattern          = %d \n", pfh->hop_pattern);
+	    seq_printf(m, "Hop index            = %d \n", pfh->hop_index);
 	    p += p[1] + 2;
 	}
 	else {
-	    len += sprintf(buf + len, "Parse beacon failed at FH param element\n");
-	    return len;
+	    seq_puts(m, "Parse beacon failed at FH param element\n");
+	    return 0;
 	}
     } else {
-	len += sprintf(buf + len, "No beacons received\n");
+	seq_puts(m, "No beacons received\n");
     }
-    return len;
+    return 0;
 }
 
+static int ray_cs_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ray_cs_proc_show, NULL);
+}
+
+static const struct file_operations ray_cs_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= ray_cs_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
 #endif
 /*===========================================================================*/
 static int build_auth_frame(ray_dev_t *local, UCHAR *dest, int auth_type)
@@ -2815,7 +2826,7 @@ static int __init init_ray_cs(void)
 #ifdef CONFIG_PROC_FS
     proc_mkdir("driver/ray_cs", NULL);
 
-    create_proc_info_entry("driver/ray_cs/ray_cs", 0, NULL, &ray_cs_proc_read);
+    proc_create("driver/ray_cs/ray_cs", 0, NULL, &ray_cs_proc_fops);
     raycs_write("driver/ray_cs/essid", write_essid, NULL);
     raycs_write("driver/ray_cs/net_type", write_int, &net_type);
     raycs_write("driver/ray_cs/translate", write_int, &translate);

commit 0e5ce1f33049a823f508f4a3f53ba186b12396b8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Dec 22 13:45:50 2007 -0500

    misc wireless annotations
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 8ba28a515d4a..f3858ee36f32 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -998,7 +998,7 @@ static int ray_hw_xmit(unsigned char* data, int len, struct net_device* dev,
 static int translate_frame(ray_dev_t *local, struct tx_msg __iomem *ptx, unsigned char *data,
                     int len)
 {
-    unsigned short int proto = ((struct ethhdr *)data)->h_proto;
+    __be16 proto = ((struct ethhdr *)data)->h_proto;
     if (ntohs(proto) >= 1536) { /* DIX II ethernet frame */
         DEBUG(3,"ray_cs translate_frame DIX II\n");
         /* Copy LLC header to card buffer */

commit 7698d6977a62bbc6ed3b9d0d0230f2213a3b2f9d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Dec 29 04:55:50 2007 -0500

    ray_cs fixes
    
    bugs galore:
            * 0xf380 instead of htons(ETH_P_AARP), etc.  Works only on l-e.
            * back in 2.3.20 driver got readb() and friends instead of
    direct dereferencing of iomem.  Somebody got too enthusiatic and replaced
            ntohs(p->mrx_overflow)
    with
            ntohs(read(&p->mrx_overflow)
    without noticing that (a) the sucker is 16bit and (b) that expression can't possibly
    be portable anyway (hell, on l-e it's always less than 256, on b-e it's always a
    multiple of 256).  Proper fix is
            swab16(readw(&p->mrx_overflow)
    taking into account the conversion done by readw() itself.  That crap happened
    in several places; the same fix applies.
            * untranslate() assumes little-endian almost everywhere, except for
    the code checking for IPX/AARP packets; there we forgot ntohs(), so that part
    only works on big-endian.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index f87fe10059ae..8ba28a515d4a 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -44,6 +44,7 @@
 #include <linux/ioport.h>
 #include <linux/skbuff.h>
 #include <linux/ethtool.h>
+#include <linux/ieee80211.h>
 
 #include <pcmcia/cs_types.h>
 #include <pcmcia/cs.h>
@@ -1003,7 +1004,7 @@ static int translate_frame(ray_dev_t *local, struct tx_msg __iomem *ptx, unsigne
         /* Copy LLC header to card buffer */
         memcpy_toio(&ptx->var, eth2_llc, sizeof(eth2_llc));
         memcpy_toio( ((void __iomem *)&ptx->var) + sizeof(eth2_llc), (UCHAR *)&proto, 2);
-        if ((proto == 0xf380) || (proto == 0x3781)) {
+        if (proto == htons(ETH_P_AARP) || proto == htons(ETH_P_IPX)) {
             /* This is the selective translation table, only 2 entries */
             writeb(0xf8, &((struct snaphdr_t __iomem *)ptx->var)->org[3]);
         }
@@ -1014,7 +1015,7 @@ static int translate_frame(ray_dev_t *local, struct tx_msg __iomem *ptx, unsigne
     }
     else { /* already  802 type, and proto is length */
         DEBUG(3,"ray_cs translate_frame 802\n");
-        if (proto == 0xffff) { /* evil netware IPX 802.3 without LLC */
+        if (proto == htons(0xffff)) { /* evil netware IPX 802.3 without LLC */
         DEBUG(3,"ray_cs translate_frame evil IPX\n");
             memcpy_toio(&ptx->var, data + ETH_HLEN,  len - ETH_HLEN);
             return 0 - ETH_HLEN;
@@ -1780,19 +1781,19 @@ static struct net_device_stats *ray_get_stats(struct net_device *dev)
     }
     if (readb(&p->mrx_overflow_for_host))
     {
-        local->stats.rx_over_errors += ntohs(readb(&p->mrx_overflow));
+        local->stats.rx_over_errors += swab16(readw(&p->mrx_overflow));
         writeb(0,&p->mrx_overflow);
         writeb(0,&p->mrx_overflow_for_host);
     }
     if (readb(&p->mrx_checksum_error_for_host))
     {
-        local->stats.rx_crc_errors += ntohs(readb(&p->mrx_checksum_error));
+        local->stats.rx_crc_errors += swab16(readw(&p->mrx_checksum_error));
         writeb(0,&p->mrx_checksum_error);
         writeb(0,&p->mrx_checksum_error_for_host);
     }
     if (readb(&p->rx_hec_error_for_host))
     {
-        local->stats.rx_frame_errors += ntohs(readb(&p->rx_hec_error));
+        local->stats.rx_frame_errors += swab16(readw(&p->rx_hec_error));
         writeb(0,&p->rx_hec_error);
         writeb(0,&p->rx_hec_error_for_host);
     }
@@ -2316,32 +2317,17 @@ static void rx_data(struct net_device *dev, struct rcs __iomem *prcs, unsigned i
 static void untranslate(ray_dev_t *local, struct sk_buff *skb, int len)
 {
     snaphdr_t *psnap = (snaphdr_t *)(skb->data + RX_MAC_HEADER_LENGTH);
-    struct mac_header *pmac = (struct mac_header *)skb->data;
-    unsigned short type = *(unsigned short *)psnap->ethertype;
-    unsigned int xsap = *(unsigned int *)psnap & 0x00ffffff;
-    unsigned int org = (*(unsigned int *)psnap->org) & 0x00ffffff;
+    struct ieee80211_hdr *pmac = (struct ieee80211_hdr *)skb->data;
+    __be16 type = *(__be16 *)psnap->ethertype;
     int delta;
     struct ethhdr *peth;
     UCHAR srcaddr[ADDRLEN];
     UCHAR destaddr[ADDRLEN];
+    static UCHAR org_bridge[3] = {0, 0, 0xf8};
+    static UCHAR org_1042[3] = {0, 0, 0};
 
-    if (pmac->frame_ctl_2 & FC2_FROM_DS) {
-	if (pmac->frame_ctl_2 & FC2_TO_DS) { /* AP to AP */
-	    memcpy(destaddr, pmac->addr_3, ADDRLEN);
-	    memcpy(srcaddr, ((unsigned char *)pmac->addr_3) + ADDRLEN, ADDRLEN);
-	} else { /* AP to terminal */
-	    memcpy(destaddr, pmac->addr_1, ADDRLEN);
-	    memcpy(srcaddr, pmac->addr_3, ADDRLEN); 
-	}
-    } else { /* Terminal to AP */
-	if (pmac->frame_ctl_2 & FC2_TO_DS) {
-	    memcpy(destaddr, pmac->addr_3, ADDRLEN);
-	    memcpy(srcaddr, pmac->addr_2, ADDRLEN); 
-	} else { /* Adhoc */
-	    memcpy(destaddr, pmac->addr_1, ADDRLEN);
-	    memcpy(srcaddr, pmac->addr_2, ADDRLEN); 
-	}
-    }
+    memcpy(destaddr, ieee80211_get_DA(pmac), ADDRLEN);
+    memcpy(srcaddr, ieee80211_get_SA(pmac), ADDRLEN);
 
 #ifdef PCMCIA_DEBUG
     if (pc_debug > 3) {
@@ -2349,33 +2335,34 @@ static void untranslate(ray_dev_t *local, struct sk_buff *skb, int len)
     printk(KERN_DEBUG "skb->data before untranslate");
     for (i=0;i<64;i++) 
         printk("%02x ",skb->data[i]);
-    printk("\n" KERN_DEBUG "type = %08x, xsap = %08x, org = %08x\n",
-           type,xsap,org);
+    printk("\n" KERN_DEBUG "type = %08x, xsap = %02x%02x%02x, org = %02x02x02x\n",
+           ntohs(type),
+	   psnap->dsap, psnap->ssap, psnap->ctrl,
+	   psnap->org[0], psnap->org[1], psnap->org[2]);
     printk(KERN_DEBUG "untranslate skb->data = %p\n",skb->data);
     }
 #endif
 
-    if ( xsap != SNAP_ID) {
+    if (psnap->dsap != 0xaa || psnap->ssap != 0xaa || psnap->ctrl != 3) {
         /* not a snap type so leave it alone */
-        DEBUG(3,"ray_cs untranslate NOT SNAP %x\n", *(unsigned int *)psnap & 0x00ffffff);
+        DEBUG(3,"ray_cs untranslate NOT SNAP %02x %02x %02x\n",
+		psnap->dsap, psnap->ssap, psnap->ctrl);
 
         delta = RX_MAC_HEADER_LENGTH - ETH_HLEN;
         peth = (struct ethhdr *)(skb->data + delta);
         peth->h_proto = htons(len - RX_MAC_HEADER_LENGTH);
     }
     else { /* Its a SNAP */
-        if (org == BRIDGE_ENCAP) { /* EtherII and nuke the LLC  */
+        if (memcmp(psnap->org, org_bridge, 3) == 0) { /* EtherII and nuke the LLC  */
         DEBUG(3,"ray_cs untranslate Bridge encap\n");
             delta = RX_MAC_HEADER_LENGTH 
                 + sizeof(struct snaphdr_t) - ETH_HLEN;
             peth = (struct ethhdr *)(skb->data + delta);
             peth->h_proto = type;
-        }
-        else {
-            if (org == RFC1042_ENCAP) {
-                switch (type) {
-                case RAY_IPX_TYPE:
-                case APPLEARP_TYPE:
+	} else if (memcmp(psnap->org, org_1042, 3) == 0) {
+                switch (ntohs(type)) {
+                case ETH_P_IPX:
+                case ETH_P_AARP:
                     DEBUG(3,"ray_cs untranslate RFC IPX/AARP\n");
                     delta = RX_MAC_HEADER_LENGTH - ETH_HLEN;
                     peth = (struct ethhdr *)(skb->data + delta);
@@ -2389,14 +2376,12 @@ static void untranslate(ray_dev_t *local, struct sk_buff *skb, int len)
                     peth->h_proto = type;
                     break;
                 }
-            }
-            else {
+	} else {
                 printk("ray_cs untranslate very confused by packet\n");
                 delta = RX_MAC_HEADER_LENGTH - ETH_HLEN;
                 peth = (struct ethhdr *)(skb->data + delta);
                 peth->h_proto = type;
-            }
-        }
+	}
     }
 /* TBD reserve  skb_reserve(skb, delta); */
     skb_pull(skb, delta);

commit 0795af5729b18218767fab27c44b1384f72dc9ad
Author: Joe Perches <joe@perches.com>
Date:   Wed Oct 3 17:59:30 2007 -0700

    [NET]: Introduce and use print_mac() and DECLARE_MAC_BUF()
    
    This is nicer than the MAC_FMT stuff.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 429bca8d0b5f..f87fe10059ae 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -412,6 +412,7 @@ static int ray_config(struct pcmcia_device *link)
     memreq_t mem;
     struct net_device *dev = (struct net_device *)link->priv;
     ray_dev_t *local = netdev_priv(dev);
+    DECLARE_MAC_BUF(mac);
 
     DEBUG(1, "ray_config(0x%p)\n", link);
 
@@ -482,10 +483,8 @@ static int ray_config(struct pcmcia_device *link)
     strcpy(local->node.dev_name, dev->name);
     link->dev_node = &local->node;
 
-    printk(KERN_INFO "%s: RayLink, irq %d, hw_addr ",
-       dev->name, dev->irq);
-    for (i = 0; i < 6; i++)
-    printk("%02X%s", dev->dev_addr[i], ((i<5) ? ":" : "\n"));
+    printk(KERN_INFO "%s: RayLink, irq %d, hw_addr %s\n",
+       dev->name, dev->irq, print_mac(mac, dev->dev_addr));
 
     return 0;
 
@@ -2610,6 +2609,7 @@ static int ray_cs_proc_read(char *buf, char **start, off_t offset, int len)
     UCHAR *p;
     struct freq_hop_element *pfh;
     UCHAR c[33];
+    DECLARE_MAC_BUF(mac);
 
     link = this_device;
     if (!link)
@@ -2639,9 +2639,8 @@ static int ray_cs_proc_read(char *buf, char **start, off_t offset, int len)
                    nettype[local->sparm.b5.a_network_type], c);
 
     p = local->bss_id;
-    len += sprintf(buf + len, 
-                   "BSSID                = %02x:%02x:%02x:%02x:%02x:%02x\n",
-                   p[0],p[1],p[2],p[3],p[4],p[5]);
+    len += sprintf(buf + len, "BSSID                = %s\n",
+                   print_mac(mac, p));
 
     len += sprintf(buf + len, "Country code         = %d\n", 
                    local->sparm.b5.a_curr_country_code);

commit ff8ac60948ba819b89e9c87083e8050fc2f89999
Author: Denis Cheng <crquan@gmail.com>
Date:   Sun Sep 2 18:30:18 2007 +0800

    drivers/net/: all drivers/net/ cleanup with ARRAY_SIZE
    
    Signed-off-by: Denis Cheng <crquan@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 1b0e9707049a..429bca8d0b5f 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -1567,9 +1567,9 @@ static const struct iw_priv_args	ray_private_args[] = {
 
 static const struct iw_handler_def	ray_handler_def =
 {
-	.num_standard	= sizeof(ray_handler)/sizeof(iw_handler),
-	.num_private	= sizeof(ray_private_handler)/sizeof(iw_handler),
-	.num_private_args = sizeof(ray_private_args)/sizeof(struct iw_priv_args),
+	.num_standard	= ARRAY_SIZE(ray_handler),
+	.num_private	= ARRAY_SIZE(ray_private_handler),
+	.num_private_args = ARRAY_SIZE(ray_private_args),
 	.standard	= ray_handler,
 	.private	= ray_private_handler,
 	.private_args	= ray_private_args,

commit 10d024c1b2fd58af8362670d7d6e5ae52fc33353
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Sep 17 13:11:17 2007 -0700

    [NET]: Nuke SET_MODULE_OWNER macro.
    
    It's been a useless no-op for long enough in 2.6 so I figured it's time to
    remove it.  The number of people that could object because they're
    maintaining unified 2.4 and 2.6 drivers is probably rather small.
    
    [ Handled drivers added by netdev tree and some missed IRDA cases... -DaveM ]
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 1d9dbf830015..1b0e9707049a 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -356,7 +356,6 @@ static int ray_probe(struct pcmcia_device *p_dev)
     dev->set_multicast_list = &set_multicast_list;
 
     DEBUG(2,"ray_cs ray_attach calling ether_setup.)\n");
-    SET_MODULE_OWNER(dev);
     dev->init = &ray_dev_init;
     dev->open = &ray_open;
     dev->stop = &ray_dev_close;

commit 6dbc9c89fb242873bd3e83890e59da3d6e462025
Author: Yoann Padioleau <padator@wanadoo.fr>
Date:   Fri Aug 3 19:37:16 2007 +0200

    [PATCH] dev->priv to netdev_priv(dev), for drivers/net/wireless
    
    Replacing accesses to dev->priv to netdev_priv(dev). The replacment
    is safe when netdev_priv is used to access a private structure that is
    right next to the net_device structure in memory. Cf
    http://groups.google.com/group/comp.os.linux.development.system/browse_thread/thread/de19321bcd94dbb8/0d74a4adcd6177bd
    This is the case when the net_device structure was allocated with
    a call to alloc_netdev or one of its derivative.
    
    Signed-off-by: Yoann Padioleau <padator@wanadoo.fr>
    Cc: mcgrof@gmail.com
    Cc: linux-wireless@vger.kernel.org
    Cc: akpm@linux-foundation.org
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 3be624295a1f..1d9dbf830015 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -314,7 +314,7 @@ static int ray_probe(struct pcmcia_device *p_dev)
     if (!dev)
 	    goto fail_alloc_dev;
 
-    local = dev->priv;
+    local = netdev_priv(dev);
     local->finder = p_dev;
 
     /* The io structure describes IO port mapping. None used here */
@@ -388,7 +388,7 @@ static void ray_detach(struct pcmcia_device *link)
 
     ray_release(link);
 
-    local = (ray_dev_t *)dev->priv;
+    local = netdev_priv(dev);
     del_timer(&local->timer);
 
     if (link->priv) {
@@ -412,7 +412,7 @@ static int ray_config(struct pcmcia_device *link)
     win_req_t req;
     memreq_t mem;
     struct net_device *dev = (struct net_device *)link->priv;
-    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    ray_dev_t *local = netdev_priv(dev);
 
     DEBUG(1, "ray_config(0x%p)\n", link);
 
@@ -520,7 +520,7 @@ static int ray_init(struct net_device *dev)
     int i;
     UCHAR *p;
     struct ccs __iomem *pccs;
-    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    ray_dev_t *local = netdev_priv(dev);
     struct pcmcia_device *link = local->finder;
     DEBUG(1, "ray_init(0x%p)\n", dev);
     if (!(pcmcia_dev_present(link))) {
@@ -581,7 +581,7 @@ static int ray_init(struct net_device *dev)
 static int dl_startup_params(struct net_device *dev)
 {
     int ccsindex;
-    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    ray_dev_t *local = netdev_priv(dev);
     struct ccs __iomem *pccs;
     struct pcmcia_device *link = local->finder;
 
@@ -786,7 +786,7 @@ static void join_net(u_long data)
 static void ray_release(struct pcmcia_device *link)
 {
     struct net_device *dev = link->priv; 
-    ray_dev_t *local = dev->priv;
+    ray_dev_t *local = netdev_priv(dev);
     int i;
     
     DEBUG(1, "ray_release(0x%p)\n", link);
@@ -834,7 +834,7 @@ int ray_dev_init(struct net_device *dev)
 #ifdef RAY_IMMEDIATE_INIT
     int i;
 #endif	/* RAY_IMMEDIATE_INIT */
-    ray_dev_t *local = dev->priv;
+    ray_dev_t *local = netdev_priv(dev);
     struct pcmcia_device *link = local->finder;
 
     DEBUG(1,"ray_dev_init(dev=%p)\n",dev);
@@ -868,7 +868,7 @@ int ray_dev_init(struct net_device *dev)
 /*===========================================================================*/
 static int ray_dev_config(struct net_device *dev, struct ifmap *map)
 {
-    ray_dev_t *local = dev->priv;
+    ray_dev_t *local = netdev_priv(dev);
     struct pcmcia_device *link = local->finder;
     /* Dummy routine to satisfy device structure */
     DEBUG(1,"ray_dev_config(dev=%p,ifmap=%p)\n",dev,map);
@@ -882,7 +882,7 @@ static int ray_dev_config(struct net_device *dev, struct ifmap *map)
 /*===========================================================================*/
 static int ray_dev_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-    ray_dev_t *local = dev->priv;
+    ray_dev_t *local = netdev_priv(dev);
     struct pcmcia_device *link = local->finder;
     short length = skb->len;
 
@@ -925,7 +925,7 @@ static int ray_dev_start_xmit(struct sk_buff *skb, struct net_device *dev)
 static int ray_hw_xmit(unsigned char* data, int len, struct net_device* dev, 
                 UCHAR msg_type)
 {
-    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    ray_dev_t *local = netdev_priv(dev);
     struct ccs __iomem *pccs;
     int ccsindex;
     int offset;
@@ -1099,7 +1099,7 @@ static int ray_set_freq(struct net_device *dev,
 			struct iw_freq *fwrq,
 			char *extra)
 {
-	ray_dev_t *local = (ray_dev_t *)dev->priv;
+	ray_dev_t *local = netdev_priv(dev);
 	int err = -EINPROGRESS;		/* Call commit handler */
 
 	/* Reject if card is already initialised */
@@ -1124,7 +1124,7 @@ static int ray_get_freq(struct net_device *dev,
 			struct iw_freq *fwrq,
 			char *extra)
 {
-	ray_dev_t *local = (ray_dev_t *)dev->priv;
+	ray_dev_t *local = netdev_priv(dev);
 
 	fwrq->m = local->sparm.b5.a_hop_pattern;
 	fwrq->e = 0;
@@ -1140,7 +1140,7 @@ static int ray_set_essid(struct net_device *dev,
 			 struct iw_point *dwrq,
 			 char *extra)
 {
-	ray_dev_t *local = (ray_dev_t *)dev->priv;
+	ray_dev_t *local = netdev_priv(dev);
 
 	/* Reject if card is already initialised */
 	if(local->card_status != CARD_AWAITING_PARAM)
@@ -1173,7 +1173,7 @@ static int ray_get_essid(struct net_device *dev,
 			 struct iw_point *dwrq,
 			 char *extra)
 {
-	ray_dev_t *local = (ray_dev_t *)dev->priv;
+	ray_dev_t *local = netdev_priv(dev);
 
 	/* Get the essid that was set */
 	memcpy(extra, local->sparm.b5.a_current_ess_id, IW_ESSID_MAX_SIZE);
@@ -1194,7 +1194,7 @@ static int ray_get_wap(struct net_device *dev,
 			struct sockaddr *awrq,
 			char *extra)
 {
-	ray_dev_t *local = (ray_dev_t *)dev->priv;
+	ray_dev_t *local = netdev_priv(dev);
 
 	memcpy(awrq->sa_data, local->bss_id, ETH_ALEN);
 	awrq->sa_family = ARPHRD_ETHER;
@@ -1211,7 +1211,7 @@ static int ray_set_rate(struct net_device *dev,
 			struct iw_param *vwrq,
 			char *extra)
 {
-	ray_dev_t *local = (ray_dev_t *)dev->priv;
+	ray_dev_t *local = netdev_priv(dev);
 
 	/* Reject if card is already initialised */
 	if(local->card_status != CARD_AWAITING_PARAM)
@@ -1240,7 +1240,7 @@ static int ray_get_rate(struct net_device *dev,
 			struct iw_param *vwrq,
 			char *extra)
 {
-	ray_dev_t *local = (ray_dev_t *)dev->priv;
+	ray_dev_t *local = netdev_priv(dev);
 
 	if(local->net_default_tx_rate == 3)
 		vwrq->value = 2000000;		/* Hum... */
@@ -1260,7 +1260,7 @@ static int ray_set_rts(struct net_device *dev,
 		       struct iw_param *vwrq,
 		       char *extra)
 {
-	ray_dev_t *local = (ray_dev_t *)dev->priv;
+	ray_dev_t *local = netdev_priv(dev);
 	int rthr = vwrq->value;
 
 	/* Reject if card is already initialised */
@@ -1290,7 +1290,7 @@ static int ray_get_rts(struct net_device *dev,
 		       struct iw_param *vwrq,
 		       char *extra)
 {
-	ray_dev_t *local = (ray_dev_t *)dev->priv;
+	ray_dev_t *local = netdev_priv(dev);
 
 	vwrq->value = (local->sparm.b5.a_rts_threshold[0] << 8)
 		+ local->sparm.b5.a_rts_threshold[1];
@@ -1309,7 +1309,7 @@ static int ray_set_frag(struct net_device *dev,
 			struct iw_param *vwrq,
 			char *extra)
 {
-	ray_dev_t *local = (ray_dev_t *)dev->priv;
+	ray_dev_t *local = netdev_priv(dev);
 	int fthr = vwrq->value;
 
 	/* Reject if card is already initialised */
@@ -1338,7 +1338,7 @@ static int ray_get_frag(struct net_device *dev,
 			struct iw_param *vwrq,
 			char *extra)
 {
-	ray_dev_t *local = (ray_dev_t *)dev->priv;
+	ray_dev_t *local = netdev_priv(dev);
 
 	vwrq->value = (local->sparm.b5.a_frag_threshold[0] << 8)
 		+ local->sparm.b5.a_frag_threshold[1];
@@ -1357,7 +1357,7 @@ static int ray_set_mode(struct net_device *dev,
 			__u32 *uwrq,
 			char *extra)
 {
-	ray_dev_t *local = (ray_dev_t *)dev->priv;
+	ray_dev_t *local = netdev_priv(dev);
 	int err = -EINPROGRESS;		/* Call commit handler */
 	char card_mode = 1;
 
@@ -1389,7 +1389,7 @@ static int ray_get_mode(struct net_device *dev,
 			__u32 *uwrq,
 			char *extra)
 {
-	ray_dev_t *local = (ray_dev_t *)dev->priv;
+	ray_dev_t *local = netdev_priv(dev);
 
 	if(local->sparm.b5.a_network_type)
 		*uwrq = IW_MODE_INFRA;
@@ -1492,7 +1492,7 @@ static int ray_commit(struct net_device *dev,
  */
 static iw_stats * ray_get_wireless_stats(struct net_device *	dev)
 {
-  ray_dev_t *	local = (ray_dev_t *) dev->priv;
+  ray_dev_t *	local = netdev_priv(dev);
   struct pcmcia_device *link = local->finder;
   struct status __iomem *p = local->sram + STATUS_BASE;
 
@@ -1580,7 +1580,7 @@ static const struct iw_handler_def	ray_handler_def =
 /*===========================================================================*/
 static int ray_open(struct net_device *dev)
 {
-    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    ray_dev_t *local = netdev_priv(dev);
     struct pcmcia_device *link;
     link = local->finder;
     
@@ -1614,7 +1614,7 @@ static int ray_open(struct net_device *dev)
 /*===========================================================================*/
 static int ray_dev_close(struct net_device *dev)
 {
-    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    ray_dev_t *local = netdev_priv(dev);
     struct pcmcia_device *link;
     link = local->finder;
 
@@ -1773,7 +1773,7 @@ static int parse_addr(char *in_str, UCHAR *out)
 /*===========================================================================*/
 static struct net_device_stats *ray_get_stats(struct net_device *dev)
 {
-    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    ray_dev_t *local = netdev_priv(dev);
     struct pcmcia_device *link = local->finder;
     struct status __iomem *p = local->sram + STATUS_BASE;
     if (!(pcmcia_dev_present(link))) {
@@ -1803,7 +1803,7 @@ static struct net_device_stats *ray_get_stats(struct net_device *dev)
 /*===========================================================================*/
 static void ray_update_parm(struct net_device *dev, UCHAR objid, UCHAR *value, int len)
 {
-    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    ray_dev_t *local = netdev_priv(dev);
     struct pcmcia_device *link = local->finder;
     int ccsindex;
     int i;
@@ -1840,7 +1840,7 @@ static void ray_update_multi_list(struct net_device *dev, int all)
     int ccsindex;
     struct ccs __iomem *pccs;
     int i = 0;
-    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    ray_dev_t *local = netdev_priv(dev);
     struct pcmcia_device *link = local->finder;
     void __iomem *p = local->sram + HOST_TO_ECF_BASE;
 
@@ -1884,7 +1884,7 @@ static void ray_update_multi_list(struct net_device *dev, int all)
 /*===========================================================================*/
 static void set_multicast_list(struct net_device *dev)
 {
-    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    ray_dev_t *local = netdev_priv(dev);
     UCHAR promisc;
 
     DEBUG(2,"ray_cs set_multicast_list(%p)\n",dev);
@@ -1935,7 +1935,7 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id)
 
     DEBUG(4,"ray_cs: interrupt for *dev=%p\n",dev);
 
-    local = (ray_dev_t *)dev->priv;
+    local = netdev_priv(dev);
     link = (struct pcmcia_device *)local->finder;
     if (!pcmcia_dev_present(link)) {
         DEBUG(2,"ray_cs interrupt from device not present or suspended.\n");
@@ -2165,7 +2165,7 @@ static void rx_data(struct net_device *dev, struct rcs __iomem *prcs, unsigned i
 {
     struct sk_buff *skb = NULL;
     struct rcs __iomem *prcslink = prcs;
-    ray_dev_t *local = dev->priv;
+    ray_dev_t *local = netdev_priv(dev);
     UCHAR *rx_ptr;
     int total_len;
     int tmp;
@@ -2618,7 +2618,7 @@ static int ray_cs_proc_read(char *buf, char **start, off_t offset, int len)
     dev = (struct net_device *)link->priv;
     if (!dev)
     	return 0;
-    local = (ray_dev_t *)dev->priv;
+    local = netdev_priv(dev);
     if (!local)
     	return 0;
 

commit d626f62b11e00c16e81e4308ab93d3f13551812a
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Mar 27 18:55:52 2007 -0300

    [SK_BUFF]: Introduce skb_copy_from_linear_data{_offset}
    
    To clearly state the intent of copying from linear sk_buffs, _offset being a
    overly long variant but interesting for the sake of saving some bytes.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 9633b0457f8c..3be624295a1f 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2242,7 +2242,8 @@ static void rx_data(struct net_device *dev, struct rcs __iomem *prcs, unsigned i
     rx_ptr += copy_from_rx_buff(local, rx_ptr, pkt_addr & RX_BUFF_END, rx_len);
     /* Get source address */
 #ifdef WIRELESS_SPY
-    memcpy(linksrcaddr, ((struct mac_header *)skb->data)->addr_2, ETH_ALEN);
+    skb_copy_from_linear_data_offset(skb, offsetof(struct mac_header, addr_2),
+				     linksrcaddr, ETH_ALEN);
 #endif
     /* Now, deal with encapsulation/translation/sniffer */
     if (!sniffer) {

commit 4c13eb6657fe9ef7b4dc8f1a405c902e9e5234e0
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Apr 25 17:40:23 2007 -0700

    [ETH]: Make eth_type_trans set skb->dev like the other *_type_trans
    
    One less thing for drivers writers to worry about.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 47b2ccb6a633..9633b0457f8c 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2232,7 +2232,6 @@ static void rx_data(struct net_device *dev, struct rcs __iomem *prcs, unsigned i
         return;
     }
     skb_reserve( skb, 2);   /* Align IP on 16 byte (TBD check this)*/
-    skb->dev = dev;
 
     DEBUG(4,"ray_cs rx_data total_len = %x, rx_len = %x\n",total_len,rx_len);
 

commit e176d397ad73ca76936e5638c2c81740dedb9d5d
Author: Daniel Ritz <daniel.ritz-ml@swissonline.ch>
Date:   Fri Dec 8 18:07:01 2006 +0100

    [PATCH] PCMCIA: fix drivers broken by recent cleanup
    
    Setting .ConfigBase and .Present is now done at the pcmcia core.
    
    The driver cleanup missed a few places where the driver did set .Present
    to PRESENT_OPTION and later to the values from the CIS.  Setting to
    PRESENT_OPTION now overrides the values from the CIS.  So just remove
    those lines.
    
    Signed-off-by: Daniel Ritz <daniel.ritz@gmx.ch>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 88e10c9bc4ac..47b2ccb6a633 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -331,7 +331,6 @@ static int ray_probe(struct pcmcia_device *p_dev)
     p_dev->conf.Attributes = CONF_ENABLE_IRQ;
     p_dev->conf.IntType = INT_MEMORY_AND_IO;
     p_dev->conf.ConfigIndex = 1;
-    p_dev->conf.Present = PRESENT_OPTION;
 
     p_dev->priv = dev;
     p_dev->irq.Instance = dev;

commit af2b3b503ad1b071b66e1531caae252b4b95c847
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Oct 25 21:49:27 2006 -0400

    [PATCH] pcmcia: conf.ConfigBase and conf.Present consolidation
    
    struct pcmcia_device *p_dev->conf.ConfigBase and .Present are set in almost
    all PCMICA driver right at the beginning, using the same calls but slightly
    different implementations. Unfiy this in the PCMCIA core.
    
    Includes a small bugfix ("drivers/net/pcmcia/xirc2ps_cs.c: remove unused
    label") from and Signed-off-by Adrian Bunk <bunk@stusta.de>
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 75cdc3e5852a..88e10c9bc4ac 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -408,11 +408,8 @@ do { last_fn = (fn); if ((last_ret = (ret)) != 0) goto cs_failed; } while (0)
 #define MAX_TUPLE_SIZE 128
 static int ray_config(struct pcmcia_device *link)
 {
-    tuple_t tuple;
-    cisparse_t parse;
     int last_fn = 0, last_ret = 0;
     int i;
-    u_char buf[MAX_TUPLE_SIZE];
     win_req_t req;
     memreq_t mem;
     struct net_device *dev = (struct net_device *)link->priv;
@@ -420,19 +417,7 @@ static int ray_config(struct pcmcia_device *link)
 
     DEBUG(1, "ray_config(0x%p)\n", link);
 
-    /* This reads the card's CONFIG tuple to find its configuration regs */
-    tuple.DesiredTuple = CISTPL_CONFIG;
-    CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(link, &tuple));
-    tuple.TupleData = buf;
-    tuple.TupleDataMax = MAX_TUPLE_SIZE;
-    tuple.TupleOffset = 0;
-    CS_CHECK(GetTupleData, pcmcia_get_tuple_data(link, &tuple));
-    CS_CHECK(ParseTuple, pcmcia_parse_tuple(link, &tuple, &parse));
-    link->conf.ConfigBase = parse.config.base;
-    link->conf.Present = parse.config.rmask[0];
-
     /* Determine card type and firmware version */
-    buf[0] = buf[MAX_TUPLE_SIZE - 1] = 0;
     printk(KERN_INFO "ray_cs Detected: %s%s%s%s\n",
 	   link->prod_id[0] ? link->prod_id[0] : " ",
 	   link->prod_id[1] ? link->prod_id[1] : " ",

commit a9606fd39083478bef313c0e3b77bc065e39e36e
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Jun 4 18:06:13 2006 +0200

    [PATCH] pcmcia: remove prod_id indirection
    
    As we read out the product information strings (VERS_1) from the PCMCIA device
    in the PCMCIA core, and device drivers can access those reliably in struct
    pcmcia_device's fields prod_id[], remove additional product information string
    detection logic from PCMCIA device drivers.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 7fbfc9e41d07..75cdc3e5852a 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -433,16 +433,11 @@ static int ray_config(struct pcmcia_device *link)
 
     /* Determine card type and firmware version */
     buf[0] = buf[MAX_TUPLE_SIZE - 1] = 0;
-    tuple.DesiredTuple = CISTPL_VERS_1;
-    CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(link, &tuple));
-    tuple.TupleData = buf;
-    tuple.TupleDataMax = MAX_TUPLE_SIZE;
-    tuple.TupleOffset = 2;
-    CS_CHECK(GetTupleData, pcmcia_get_tuple_data(link, &tuple));
-
-    for (i=0; i<tuple.TupleDataLen - 4; i++) 
-        if (buf[i] == 0) buf[i] = ' ';
-    printk(KERN_INFO "ray_cs Detected: %s\n",buf);
+    printk(KERN_INFO "ray_cs Detected: %s%s%s%s\n",
+	   link->prod_id[0] ? link->prod_id[0] : " ",
+	   link->prod_id[1] ? link->prod_id[1] : " ",
+	   link->prod_id[2] ? link->prod_id[2] : " ",
+	   link->prod_id[3] ? link->prod_id[3] : " ");
 
     /* Now allocate an interrupt line.  Note that this does not
        actually assign a handler to the interrupt.

commit 53077944f119808df3d1c6be07241f17a87e7c28
Author: Jean Tourrilhes <jt@hpl.hp.com>
Date:   Tue Oct 10 14:45:46 2006 -0700

    [PATCH] wireless: More WE-21 potential overflows...
    
    After the Orinoco issue, I did an audit of other drivers for the same
    issue.  Three drivers were NULL terminating the ESSID, which could cause an
    overflow in WE-21 when the ESSID has maximum size.
    
    Signed-off-by: Jean Tourrilhes <jt@hpl.hp.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 0b381d77015c..7fbfc9e41d07 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -1198,7 +1198,6 @@ static int ray_get_essid(struct net_device *dev,
 
 	/* Get the essid that was set */
 	memcpy(extra, local->sparm.b5.a_current_ess_id, IW_ESSID_MAX_SIZE);
-	extra[IW_ESSID_MAX_SIZE] = '\0';
 
 	/* Push it out ! */
 	dwrq->length = strlen(extra);

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index e82548ea609a..0b381d77015c 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -130,7 +130,7 @@ static void ray_update_parm(struct net_device *dev, UCHAR objid, UCHAR *value, i
 static void verify_dl_startup(u_long);
 
 /* Prototypes for interrpt time functions **********************************/
-static irqreturn_t ray_interrupt (int reg, void *dev_id, struct pt_regs *regs);
+static irqreturn_t ray_interrupt (int reg, void *dev_id);
 static void clear_interrupt(ray_dev_t *local);
 static void rx_deauthenticate(ray_dev_t *local, struct rcs __iomem *prcs, 
                        unsigned int pkt_addr, int rx_len);
@@ -1940,7 +1940,7 @@ static void set_multicast_list(struct net_device *dev)
 /*=============================================================================
  * All routines below here are run at interrupt time.
 =============================================================================*/
-static irqreturn_t ray_interrupt(int irq, void *dev_id, struct pt_regs * regs)
+static irqreturn_t ray_interrupt(int irq, void *dev_id)
 {
     struct net_device *dev = (struct net_device *)dev_id;
     struct pcmcia_device *link;

commit 4ced38ac48137e1928dd40de3cdc074ec31c059d
Author: Jean Tourrilhes <jt@hpl.hp.com>
Date:   Tue Aug 29 18:04:09 2006 -0700

    [PATCH] WE-21 for ray_cs
    
    Signed-off-by: Jean Tourrilhes <jt@hpl.hp.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 4574290f971f..e82548ea609a 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -1173,7 +1173,7 @@ static int ray_set_essid(struct net_device *dev,
 		return -EOPNOTSUPP;
 	} else {
 		/* Check the size of the string */
-		if(dwrq->length > IW_ESSID_MAX_SIZE + 1) {
+		if(dwrq->length > IW_ESSID_MAX_SIZE) {
 			return -E2BIG;
 		}
 

commit 7282d491ecaee9883233a0e27283c4c79486279a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Sep 13 14:30:00 2006 -0400

    drivers/net: const-ify ethtool_ops declarations
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 8e112d139e29..4574290f971f 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -99,7 +99,7 @@ static int ray_dev_config(struct net_device *dev, struct ifmap *map);
 static struct net_device_stats *ray_get_stats(struct net_device *dev);
 static int ray_dev_init(struct net_device *dev);
 
-static struct ethtool_ops netdev_ethtool_ops;
+static const struct ethtool_ops netdev_ethtool_ops;
 
 static int ray_open(struct net_device *dev);
 static int ray_dev_start_xmit(struct sk_buff *skb, struct net_device *dev);
@@ -1092,7 +1092,7 @@ static void netdev_get_drvinfo(struct net_device *dev,
 	strcpy(info->driver, "ray_cs");
 }
 
-static struct ethtool_ops netdev_ethtool_ops = {
+static const struct ethtool_ops netdev_ethtool_ops = {
 	.get_drvinfo		= netdev_get_drvinfo,
 };
 

commit 113b898e38cb20e80847c24154ce62273b948c6a
Author: Michael Wu <flamingice@sourmilk.net>
Date:   Sun Aug 13 23:27:17 2006 -0700

    [PATCH] ray_cs: Remove dependency on ieee80211
    
    This patch removes the dependency on ieee80211.h from
    the ray_cs driver. ray_cs only needs iw_handler.h.
    
    Signed-off-by: Michael Wu <flamingice@sourmilk.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 61b83a5e737a..8e112d139e29 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -52,8 +52,8 @@
 #include <pcmcia/ds.h>
 #include <pcmcia/mem_op.h>
 
-#include <net/ieee80211.h>
 #include <linux/wireless.h>
+#include <net/iw_handler.h>
 
 #include <asm/io.h>
 #include <asm/system.h>

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index a915fe6c6aa5..61b83a5e737a 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -30,7 +30,6 @@
  * 
 =============================================================================*/
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/proc_fs.h>

commit 5b057c6b1a25d57edf2b4d1e956e50936480a9ff
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Fri Jun 23 02:06:41 2006 -0700

    [NET]: Avoid allocating skb in skb_pad
    
    First of all it is unnecessary to allocate a new skb in skb_pad since
    the existing one is not shared.  More importantly, our hard_start_xmit
    interface does not allow a new skb to be allocated since that breaks
    requeueing.
    
    This patch uses pskb_expand_head to expand the existing skb and linearize
    it if needed.  Actually, someone should sift through every instance of
    skb_pad on a non-linear skb as they do not fit the reasons why this was
    originally created.
    
    Incidentally, this fixes a minor bug when the skb is cloned (tcpdump,
    TCP, etc.).  As it is skb_pad will simply write over a cloned skb.  Because
    of the position of the write it is unlikely to cause problems but still
    it's best if we don't do it.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 879eb427607c..a915fe6c6aa5 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -924,8 +924,7 @@ static int ray_dev_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
     if (length < ETH_ZLEN)
     {
-    	skb = skb_padto(skb, ETH_ZLEN);
-    	if (skb == NULL)
+    	if (skb_padto(skb, ETH_ZLEN))
     		return 0;
     	length = ETH_ZLEN;
     }

commit 9940ec3617fec1db13e589bbc3f37e37878c7683
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 5 11:04:33 2006 +0100

    [PATCH] pcmcia: convert DEV_OK to pcmcia_dev_present
    
    Instead of the DEV_OK macro, drivers should use pcmcia_dev_present().
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 85712ffb842a..879eb427607c 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -1961,7 +1961,7 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id, struct pt_regs * regs)
 
     local = (ray_dev_t *)dev->priv;
     link = (struct pcmcia_device *)local->finder;
-    if (!(pcmcia_dev_present(link))  || link->suspended ) {
+    if (!pcmcia_dev_present(link)) {
         DEBUG(2,"ray_cs interrupt from device not present or suspended.\n");
         return IRQ_NONE;
     }

commit e2d4096365e06b9a3799afbadc28b4519c0b3526
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Mar 2 00:09:29 2006 +0100

    [PATCH] pcmcia: use bitfield instead of p_state and state
    
    Instead of the two status values struct pcmcia_device->p_state and state,
    use descriptive bitfields. Most value-checking in drivers was invalid, as
    the core now only calls the ->remove() (a.k.a. detach) function in case the
    attachement _and_ configuration was successful.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index e3924339fabe..85712ffb842a 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -366,7 +366,6 @@ static int ray_probe(struct pcmcia_device *p_dev)
 
     init_timer(&local->timer);
 
-    p_dev->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
     this_device = p_dev;
     return ray_config(p_dev);
 
@@ -389,12 +388,10 @@ static void ray_detach(struct pcmcia_device *link)
     this_device = NULL;
     dev = link->priv;
 
-    if (link->state & DEV_CONFIG) {
-	    ray_release(link);
+    ray_release(link);
 
-	    local = (ray_dev_t *)dev->priv;
-            del_timer(&local->timer);
-    }
+    local = (ray_dev_t *)dev->priv;
+    del_timer(&local->timer);
 
     if (link->priv) {
 	if (link->dev_node) unregister_netdev(dev);
@@ -448,9 +445,6 @@ static int ray_config(struct pcmcia_device *link)
         if (buf[i] == 0) buf[i] = ' ';
     printk(KERN_INFO "ray_cs Detected: %s\n",buf);
 
-    /* Configure card */
-    link->state |= DEV_CONFIG;
-
     /* Now allocate an interrupt line.  Note that this does not
        actually assign a handler to the interrupt.
     */
@@ -511,7 +505,6 @@ static int ray_config(struct pcmcia_device *link)
     strcpy(local->node.dev_name, dev->name);
     link->dev_node = &local->node;
 
-    link->state &= ~DEV_CONFIG_PENDING;
     printk(KERN_INFO "%s: RayLink, irq %d, hw_addr ",
        dev->name, dev->irq);
     for (i = 0; i < 6; i++)
@@ -552,7 +545,7 @@ static int ray_init(struct net_device *dev)
     ray_dev_t *local = (ray_dev_t *)dev->priv;
     struct pcmcia_device *link = local->finder;
     DEBUG(1, "ray_init(0x%p)\n", dev);
-    if (!(link->state & DEV_PRESENT)) {
+    if (!(pcmcia_dev_present(link))) {
         DEBUG(0,"ray_init - device not present\n");
         return -1;
     }
@@ -615,7 +608,7 @@ static int dl_startup_params(struct net_device *dev)
     struct pcmcia_device *link = local->finder;
 
     DEBUG(1,"dl_startup_params entered\n");
-    if (!(link->state & DEV_PRESENT)) {
+    if (!(pcmcia_dev_present(link))) {
         DEBUG(2,"ray_cs dl_startup_params - device not present\n");
         return -1;
     }
@@ -721,7 +714,7 @@ static void verify_dl_startup(u_long data)
     UCHAR status;
     struct pcmcia_device *link = local->finder;
 
-    if (!(link->state & DEV_PRESENT)) {
+    if (!(pcmcia_dev_present(link))) {
         DEBUG(2,"ray_cs verify_dl_startup - device not present\n");
         return;
     }
@@ -760,7 +753,7 @@ static void start_net(u_long data)
     struct ccs __iomem *pccs;
     int ccsindex;
     struct pcmcia_device *link = local->finder;
-    if (!(link->state & DEV_PRESENT)) {
+    if (!(pcmcia_dev_present(link))) {
         DEBUG(2,"ray_cs start_net - device not present\n");
         return;
     }
@@ -788,7 +781,7 @@ static void join_net(u_long data)
     int ccsindex;
     struct pcmcia_device *link = local->finder;
     
-    if (!(link->state & DEV_PRESENT)) {
+    if (!(pcmcia_dev_present(link))) {
         DEBUG(2,"ray_cs join_net - device not present\n");
         return;
     }
@@ -839,7 +832,7 @@ static int ray_suspend(struct pcmcia_device *link)
 {
 	struct net_device *dev = link->priv;
 
-	if ((link->state & DEV_CONFIG) && (link->open))
+	if (link->open)
 		netif_device_detach(dev);
 
 	return 0;
@@ -849,7 +842,7 @@ static int ray_resume(struct pcmcia_device *link)
 {
 	struct net_device *dev = link->priv;
 
-	if ((link->state & DEV_CONFIG) && (link->open)) {
+	if (link->open) {
 		ray_reset(dev);
 		netif_device_attach(dev);
 	}
@@ -867,7 +860,7 @@ int ray_dev_init(struct net_device *dev)
     struct pcmcia_device *link = local->finder;
 
     DEBUG(1,"ray_dev_init(dev=%p)\n",dev);
-    if (!(link->state & DEV_PRESENT)) {
+    if (!(pcmcia_dev_present(link))) {
         DEBUG(2,"ray_dev_init - device not present\n");
         return -1;
     }
@@ -901,7 +894,7 @@ static int ray_dev_config(struct net_device *dev, struct ifmap *map)
     struct pcmcia_device *link = local->finder;
     /* Dummy routine to satisfy device structure */
     DEBUG(1,"ray_dev_config(dev=%p,ifmap=%p)\n",dev,map);
-    if (!(link->state & DEV_PRESENT)) {
+    if (!(pcmcia_dev_present(link))) {
         DEBUG(2,"ray_dev_config - device not present\n");
         return -1;
     }
@@ -915,7 +908,7 @@ static int ray_dev_start_xmit(struct sk_buff *skb, struct net_device *dev)
     struct pcmcia_device *link = local->finder;
     short length = skb->len;
 
-    if (!(link->state & DEV_PRESENT)) {
+    if (!(pcmcia_dev_present(link))) {
         DEBUG(2,"ray_dev_start_xmit - device not present\n");
         return -1;
     }
@@ -1542,7 +1535,7 @@ static iw_stats * ray_get_wireless_stats(struct net_device *	dev)
     }
 #endif /* WIRELESS_SPY */
 
-  if((link->state & DEV_PRESENT)) {
+  if(pcmcia_dev_present(link)) {
     local->wstats.qual.noise = readb(&p->rxnoise);
     local->wstats.qual.updated |= 4;
   }
@@ -1674,7 +1667,7 @@ static int interrupt_ecf(ray_dev_t *local, int ccs)
     int i = 50;
     struct pcmcia_device *link = local->finder;
 
-    if (!(link->state & DEV_PRESENT)) {
+    if (!(pcmcia_dev_present(link))) {
         DEBUG(2,"ray_cs interrupt_ecf - device not present\n");
         return -1;
     }
@@ -1701,7 +1694,7 @@ static int get_free_tx_ccs(ray_dev_t *local)
     struct ccs __iomem *pccs = ccs_base(local);
     struct pcmcia_device *link = local->finder;
 
-    if (!(link->state & DEV_PRESENT)) {
+    if (!(pcmcia_dev_present(link))) {
         DEBUG(2,"ray_cs get_free_tx_ccs - device not present\n");
         return ECARDGONE;
     }
@@ -1732,7 +1725,7 @@ static int get_free_ccs(ray_dev_t *local)
     struct ccs __iomem *pccs = ccs_base(local);
     struct pcmcia_device *link = local->finder;
 
-    if (!(link->state & DEV_PRESENT)) {
+    if (!(pcmcia_dev_present(link))) {
         DEBUG(2,"ray_cs get_free_ccs - device not present\n");
         return ECARDGONE;
     }
@@ -1807,7 +1800,7 @@ static struct net_device_stats *ray_get_stats(struct net_device *dev)
     ray_dev_t *local = (ray_dev_t *)dev->priv;
     struct pcmcia_device *link = local->finder;
     struct status __iomem *p = local->sram + STATUS_BASE;
-    if (!(link->state & DEV_PRESENT)) {
+    if (!(pcmcia_dev_present(link))) {
         DEBUG(2,"ray_cs net_device_stats - device not present\n");
         return &local->stats;
     }
@@ -1840,7 +1833,7 @@ static void ray_update_parm(struct net_device *dev, UCHAR objid, UCHAR *value, i
     int i;
     struct ccs __iomem *pccs;
 
-    if (!(link->state & DEV_PRESENT)) {
+    if (!(pcmcia_dev_present(link))) {
         DEBUG(2,"ray_update_parm - device not present\n");
         return;
     }
@@ -1875,7 +1868,7 @@ static void ray_update_multi_list(struct net_device *dev, int all)
     struct pcmcia_device *link = local->finder;
     void __iomem *p = local->sram + HOST_TO_ECF_BASE;
 
-    if (!(link->state & DEV_PRESENT)) {
+    if (!(pcmcia_dev_present(link))) {
         DEBUG(2,"ray_update_multi_list - device not present\n");
         return;
     }
@@ -1968,7 +1961,7 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id, struct pt_regs * regs)
 
     local = (ray_dev_t *)dev->priv;
     link = (struct pcmcia_device *)local->finder;
-    if ( ! (link->state & DEV_PRESENT) || link->suspended ) {
+    if (!(pcmcia_dev_present(link))  || link->suspended ) {
         DEBUG(2,"ray_cs interrupt from device not present or suspended.\n");
         return IRQ_NONE;
     }
@@ -2489,7 +2482,7 @@ static void authenticate(ray_dev_t *local)
 {
     struct pcmcia_device *link = local->finder;
     DEBUG(0,"ray_cs Starting authentication.\n");
-    if (!(link->state & DEV_PRESENT)) {
+    if (!(pcmcia_dev_present(link))) {
         DEBUG(2,"ray_cs authenticate - device not present\n");
         return;
     }
@@ -2556,7 +2549,7 @@ static void associate(ray_dev_t *local)
     struct pcmcia_device *link = local->finder;
     struct net_device *dev = link->priv;
     int ccsindex;
-    if (!(link->state & DEV_PRESENT)) {
+    if (!(pcmcia_dev_present(link))) {
         DEBUG(2,"ray_cs associate - device not present\n");
         return;
     }

commit f6fbe01ac976f3ec618cd5fb71ad9ce2cfa7ab2b
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Fri Jan 20 15:10:23 2006 +0100

    [PATCH] pcmcia: remove unused p_dev->state flags
    
    Remove the unused DEV_RELEASE_PENDING flag, and move the DEV_SUSPEND flag
    into the p_dev structure, and make use of it at the core level.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 8cfe9332a3c1..e3924339fabe 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -1968,7 +1968,7 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id, struct pt_regs * regs)
 
     local = (ray_dev_t *)dev->priv;
     link = (struct pcmcia_device *)local->finder;
-    if ( ! (link->state & DEV_PRESENT) || link->state & DEV_SUSPEND ) {
+    if ( ! (link->state & DEV_PRESENT) || link->suspended ) {
         DEBUG(2,"ray_cs interrupt from device not present or suspended.\n");
         return IRQ_NONE;
     }

commit 15b99ac1729503db9e6dc642a50b9b6cb3bf51f9
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Fri Mar 31 17:26:06 2006 +0200

    [PATCH] pcmcia: add return value to _config() functions
    
    Most of the driver initialization isn't done in the .probe function, but in
    the internal _config() functions. Make them return a value, so that .probe
    can properly report whether the probing of the device succeeded or not.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 415ae8be1e22..8cfe9332a3c1 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -90,7 +90,7 @@ module_param(pc_debug, int, 0);
 #define DEBUG(n, args...)
 #endif
 /** Prototypes based on PCMCIA skeleton driver *******************************/
-static void ray_config(struct pcmcia_device *link);
+static int ray_config(struct pcmcia_device *link);
 static void ray_release(struct pcmcia_device *link);
 static void ray_detach(struct pcmcia_device *p_dev);
 
@@ -303,7 +303,7 @@ static char rcsid[] = "Raylink/WebGear wireless LAN - Corey <Thomas corey@world.
     configure the card at this point -- we wait until we receive a
     card insertion event.
 =============================================================================*/
-static int ray_attach(struct pcmcia_device *p_dev)
+static int ray_probe(struct pcmcia_device *p_dev)
 {
     ray_dev_t *local;
     struct net_device *dev;
@@ -368,9 +368,7 @@ static int ray_attach(struct pcmcia_device *p_dev)
 
     p_dev->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
     this_device = p_dev;
-    ray_config(p_dev);
-
-    return 0;
+    return ray_config(p_dev);
 
 fail_alloc_dev:
     return -ENOMEM;
@@ -412,7 +410,7 @@ static void ray_detach(struct pcmcia_device *link)
 #define CS_CHECK(fn, ret) \
 do { last_fn = (fn); if ((last_ret = (ret)) != 0) goto cs_failed; } while (0)
 #define MAX_TUPLE_SIZE 128
-static void ray_config(struct pcmcia_device *link)
+static int ray_config(struct pcmcia_device *link)
 {
     tuple_t tuple;
     cisparse_t parse;
@@ -499,7 +497,7 @@ static void ray_config(struct pcmcia_device *link)
     DEBUG(3,"ray_config amem=%p\n",local->amem);
     if (ray_init(dev) < 0) {
         ray_release(link);
-        return;
+        return -ENODEV;
     }
 
     SET_NETDEV_DEV(dev, &handle_to_dev(link));
@@ -507,7 +505,7 @@ static void ray_config(struct pcmcia_device *link)
     if (i != 0) {
         printk("ray_config register_netdev() failed\n");
         ray_release(link);
-        return;
+        return i;
     }
 
     strcpy(local->node.dev_name, dev->name);
@@ -519,12 +517,13 @@ static void ray_config(struct pcmcia_device *link)
     for (i = 0; i < 6; i++)
     printk("%02X%s", dev->dev_addr[i], ((i<5) ? ":" : "\n"));
 
-    return;
+    return 0;
 
 cs_failed:
     cs_error(link, last_fn, last_ret);
 
     ray_release(link);
+    return -ENODEV;
 } /* ray_config */
 
 static inline struct ccs __iomem *ccs_base(ray_dev_t *dev)
@@ -2846,7 +2845,7 @@ static struct pcmcia_driver ray_driver = {
 	.drv		= {
 		.name	= "ray_cs",
 	},
-	.probe		= ray_attach,
+	.probe		= ray_probe,
 	.remove		= ray_detach,
 	.id_table       = ray_ids,
 	.suspend	= ray_suspend,

commit fba395eee7d3f342ca739c20f5b3ee635d0420a0
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Fri Mar 31 17:21:06 2006 +0200

    [PATCH] pcmcia: remove dev_link_t and client_handle_t indirection
    
    dev_link_t * and client_handle_t both mean struct pcmcai_device * by now.
    Therefore, remove all such indirections.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 60297460debd..415ae8be1e22 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -90,8 +90,8 @@ module_param(pc_debug, int, 0);
 #define DEBUG(n, args...)
 #endif
 /** Prototypes based on PCMCIA skeleton driver *******************************/
-static void ray_config(dev_link_t *link);
-static void ray_release(dev_link_t *link);
+static void ray_config(struct pcmcia_device *link);
+static void ray_release(struct pcmcia_device *link);
 static void ray_detach(struct pcmcia_device *p_dev);
 
 /***** Prototypes indicated by device structure ******************************/
@@ -190,10 +190,10 @@ static int bc;
 static char *phy_addr = NULL;
 
 
-/* A dev_link_t structure has fields for most things that are needed
+/* A struct pcmcia_device structure has fields for most things that are needed
    to keep track of a socket, but there will usually be some device
    specific information that also needs to be kept track of.  The
-   'priv' pointer in a dev_link_t structure can be used to point to
+   'priv' pointer in a struct pcmcia_device structure can be used to point to
    a device-specific private data structure, like this.
 */
 static unsigned int ray_mem_speed = 500;
@@ -381,9 +381,8 @@ static int ray_attach(struct pcmcia_device *p_dev)
     structures are freed.  Otherwise, the structures will be freed
     when the device is released.
 =============================================================================*/
-static void ray_detach(struct pcmcia_device *p_dev)
+static void ray_detach(struct pcmcia_device *link)
 {
-    dev_link_t *link = dev_to_instance(p_dev);
     struct net_device *dev;
     ray_dev_t *local;
 
@@ -413,9 +412,8 @@ static void ray_detach(struct pcmcia_device *p_dev)
 #define CS_CHECK(fn, ret) \
 do { last_fn = (fn); if ((last_ret = (ret)) != 0) goto cs_failed; } while (0)
 #define MAX_TUPLE_SIZE 128
-static void ray_config(dev_link_t *link)
+static void ray_config(struct pcmcia_device *link)
 {
-    client_handle_t handle = link->handle;
     tuple_t tuple;
     cisparse_t parse;
     int last_fn = 0, last_ret = 0;
@@ -430,23 +428,23 @@ static void ray_config(dev_link_t *link)
 
     /* This reads the card's CONFIG tuple to find its configuration regs */
     tuple.DesiredTuple = CISTPL_CONFIG;
-    CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(handle, &tuple));
+    CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(link, &tuple));
     tuple.TupleData = buf;
     tuple.TupleDataMax = MAX_TUPLE_SIZE;
     tuple.TupleOffset = 0;
-    CS_CHECK(GetTupleData, pcmcia_get_tuple_data(handle, &tuple));
-    CS_CHECK(ParseTuple, pcmcia_parse_tuple(handle, &tuple, &parse));
+    CS_CHECK(GetTupleData, pcmcia_get_tuple_data(link, &tuple));
+    CS_CHECK(ParseTuple, pcmcia_parse_tuple(link, &tuple, &parse));
     link->conf.ConfigBase = parse.config.base;
     link->conf.Present = parse.config.rmask[0];
 
     /* Determine card type and firmware version */
     buf[0] = buf[MAX_TUPLE_SIZE - 1] = 0;
     tuple.DesiredTuple = CISTPL_VERS_1;
-    CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(handle, &tuple));
+    CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(link, &tuple));
     tuple.TupleData = buf;
     tuple.TupleDataMax = MAX_TUPLE_SIZE;
     tuple.TupleOffset = 2;
-    CS_CHECK(GetTupleData, pcmcia_get_tuple_data(handle, &tuple));
+    CS_CHECK(GetTupleData, pcmcia_get_tuple_data(link, &tuple));
 
     for (i=0; i<tuple.TupleDataLen - 4; i++) 
         if (buf[i] == 0) buf[i] = ' ';
@@ -458,20 +456,20 @@ static void ray_config(dev_link_t *link)
     /* Now allocate an interrupt line.  Note that this does not
        actually assign a handler to the interrupt.
     */
-    CS_CHECK(RequestIRQ, pcmcia_request_irq(link->handle, &link->irq));
+    CS_CHECK(RequestIRQ, pcmcia_request_irq(link, &link->irq));
     dev->irq = link->irq.AssignedIRQ;
     
     /* This actually configures the PCMCIA socket -- setting up
        the I/O windows and the interrupt mapping.
     */
-    CS_CHECK(RequestConfiguration, pcmcia_request_configuration(link->handle, &link->conf));
+    CS_CHECK(RequestConfiguration, pcmcia_request_configuration(link, &link->conf));
 
 /*** Set up 32k window for shared memory (transmit and control) ************/
     req.Attributes = WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_CM | WIN_ENABLE | WIN_USE_WAIT;
     req.Base = 0;
     req.Size = 0x8000;
     req.AccessSpeed = ray_mem_speed;
-    CS_CHECK(RequestWindow, pcmcia_request_window(&link->handle, &req, &link->win));
+    CS_CHECK(RequestWindow, pcmcia_request_window(&link, &req, &link->win));
     mem.CardOffset = 0x0000; mem.Page = 0;
     CS_CHECK(MapMemPage, pcmcia_map_mem_page(link->win, &mem));
     local->sram = ioremap(req.Base,req.Size);
@@ -481,7 +479,7 @@ static void ray_config(dev_link_t *link)
     req.Base = 0;
     req.Size = 0x4000;
     req.AccessSpeed = ray_mem_speed;
-    CS_CHECK(RequestWindow, pcmcia_request_window(&link->handle, &req, &local->rmem_handle));
+    CS_CHECK(RequestWindow, pcmcia_request_window(&link, &req, &local->rmem_handle));
     mem.CardOffset = 0x8000; mem.Page = 0;
     CS_CHECK(MapMemPage, pcmcia_map_mem_page(local->rmem_handle, &mem));
     local->rmem = ioremap(req.Base,req.Size);
@@ -491,7 +489,7 @@ static void ray_config(dev_link_t *link)
     req.Base = 0;
     req.Size = 0x1000;
     req.AccessSpeed = ray_mem_speed;
-    CS_CHECK(RequestWindow, pcmcia_request_window(&link->handle, &req, &local->amem_handle));
+    CS_CHECK(RequestWindow, pcmcia_request_window(&link, &req, &local->amem_handle));
     mem.CardOffset = 0x0000; mem.Page = 0;
     CS_CHECK(MapMemPage, pcmcia_map_mem_page(local->amem_handle, &mem));
     local->amem = ioremap(req.Base,req.Size);
@@ -504,7 +502,7 @@ static void ray_config(dev_link_t *link)
         return;
     }
 
-    SET_NETDEV_DEV(dev, &handle_to_dev(handle));
+    SET_NETDEV_DEV(dev, &handle_to_dev(link));
     i = register_netdev(dev);
     if (i != 0) {
         printk("ray_config register_netdev() failed\n");
@@ -524,7 +522,7 @@ static void ray_config(dev_link_t *link)
     return;
 
 cs_failed:
-    cs_error(link->handle, last_fn, last_ret);
+    cs_error(link, last_fn, last_ret);
 
     ray_release(link);
 } /* ray_config */
@@ -553,7 +551,7 @@ static int ray_init(struct net_device *dev)
     UCHAR *p;
     struct ccs __iomem *pccs;
     ray_dev_t *local = (ray_dev_t *)dev->priv;
-    dev_link_t *link = local->finder;
+    struct pcmcia_device *link = local->finder;
     DEBUG(1, "ray_init(0x%p)\n", dev);
     if (!(link->state & DEV_PRESENT)) {
         DEBUG(0,"ray_init - device not present\n");
@@ -615,7 +613,7 @@ static int dl_startup_params(struct net_device *dev)
     int ccsindex;
     ray_dev_t *local = (ray_dev_t *)dev->priv;
     struct ccs __iomem *pccs;
-    dev_link_t *link = local->finder;
+    struct pcmcia_device *link = local->finder;
 
     DEBUG(1,"dl_startup_params entered\n");
     if (!(link->state & DEV_PRESENT)) {
@@ -722,7 +720,7 @@ static void verify_dl_startup(u_long data)
     ray_dev_t *local = (ray_dev_t *)data;
     struct ccs __iomem *pccs = ccs_base(local) + local->dl_param_ccs;
     UCHAR status;
-    dev_link_t *link = local->finder;
+    struct pcmcia_device *link = local->finder;
 
     if (!(link->state & DEV_PRESENT)) {
         DEBUG(2,"ray_cs verify_dl_startup - device not present\n");
@@ -762,7 +760,7 @@ static void start_net(u_long data)
     ray_dev_t *local = (ray_dev_t *)data;
     struct ccs __iomem *pccs;
     int ccsindex;
-    dev_link_t *link = local->finder;
+    struct pcmcia_device *link = local->finder;
     if (!(link->state & DEV_PRESENT)) {
         DEBUG(2,"ray_cs start_net - device not present\n");
         return;
@@ -789,7 +787,7 @@ static void join_net(u_long data)
 
     struct ccs __iomem *pccs;
     int ccsindex;
-    dev_link_t *link = local->finder;
+    struct pcmcia_device *link = local->finder;
     
     if (!(link->state & DEV_PRESENT)) {
         DEBUG(2,"ray_cs join_net - device not present\n");
@@ -815,7 +813,7 @@ static void join_net(u_long data)
     device, and release the PCMCIA configuration.  If the device is
     still open, this will be postponed until it is closed.
 =============================================================================*/
-static void ray_release(dev_link_t *link)
+static void ray_release(struct pcmcia_device *link)
 {
     struct net_device *dev = link->priv; 
     ray_dev_t *local = dev->priv;
@@ -833,14 +831,13 @@ static void ray_release(dev_link_t *link)
     if ( i != CS_SUCCESS ) DEBUG(0,"ReleaseWindow(local->amem) ret = %x\n",i);
     i = pcmcia_release_window(local->rmem_handle);
     if ( i != CS_SUCCESS ) DEBUG(0,"ReleaseWindow(local->rmem) ret = %x\n",i);
-    pcmcia_disable_device(link->handle);
+    pcmcia_disable_device(link);
 
     DEBUG(2,"ray_release ending\n");
 }
 
-static int ray_suspend(struct pcmcia_device *p_dev)
+static int ray_suspend(struct pcmcia_device *link)
 {
-	dev_link_t *link = dev_to_instance(p_dev);
 	struct net_device *dev = link->priv;
 
 	if ((link->state & DEV_CONFIG) && (link->open))
@@ -849,9 +846,8 @@ static int ray_suspend(struct pcmcia_device *p_dev)
 	return 0;
 }
 
-static int ray_resume(struct pcmcia_device *p_dev)
+static int ray_resume(struct pcmcia_device *link)
 {
-	dev_link_t *link = dev_to_instance(p_dev);
 	struct net_device *dev = link->priv;
 
 	if ((link->state & DEV_CONFIG) && (link->open)) {
@@ -869,7 +865,7 @@ int ray_dev_init(struct net_device *dev)
     int i;
 #endif	/* RAY_IMMEDIATE_INIT */
     ray_dev_t *local = dev->priv;
-    dev_link_t *link = local->finder;
+    struct pcmcia_device *link = local->finder;
 
     DEBUG(1,"ray_dev_init(dev=%p)\n",dev);
     if (!(link->state & DEV_PRESENT)) {
@@ -903,7 +899,7 @@ int ray_dev_init(struct net_device *dev)
 static int ray_dev_config(struct net_device *dev, struct ifmap *map)
 {
     ray_dev_t *local = dev->priv;
-    dev_link_t *link = local->finder;
+    struct pcmcia_device *link = local->finder;
     /* Dummy routine to satisfy device structure */
     DEBUG(1,"ray_dev_config(dev=%p,ifmap=%p)\n",dev,map);
     if (!(link->state & DEV_PRESENT)) {
@@ -917,7 +913,7 @@ static int ray_dev_config(struct net_device *dev, struct ifmap *map)
 static int ray_dev_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
     ray_dev_t *local = dev->priv;
-    dev_link_t *link = local->finder;
+    struct pcmcia_device *link = local->finder;
     short length = skb->len;
 
     if (!(link->state & DEV_PRESENT)) {
@@ -1529,7 +1525,7 @@ static int ray_commit(struct net_device *dev,
 static iw_stats * ray_get_wireless_stats(struct net_device *	dev)
 {
   ray_dev_t *	local = (ray_dev_t *) dev->priv;
-  dev_link_t *link = local->finder;
+  struct pcmcia_device *link = local->finder;
   struct status __iomem *p = local->sram + STATUS_BASE;
 
   if(local == (ray_dev_t *) NULL)
@@ -1617,7 +1613,7 @@ static const struct iw_handler_def	ray_handler_def =
 static int ray_open(struct net_device *dev)
 {
     ray_dev_t *local = (ray_dev_t *)dev->priv;
-    dev_link_t *link;
+    struct pcmcia_device *link;
     link = local->finder;
     
     DEBUG(1, "ray_open('%s')\n", dev->name);
@@ -1651,7 +1647,7 @@ static int ray_open(struct net_device *dev)
 static int ray_dev_close(struct net_device *dev)
 {
     ray_dev_t *local = (ray_dev_t *)dev->priv;
-    dev_link_t *link;
+    struct pcmcia_device *link;
     link = local->finder;
 
     DEBUG(1, "ray_dev_close('%s')\n", dev->name);
@@ -1677,7 +1673,7 @@ static void ray_reset(struct net_device *dev) {
 static int interrupt_ecf(ray_dev_t *local, int ccs)
 {
     int i = 50;
-    dev_link_t *link = local->finder;
+    struct pcmcia_device *link = local->finder;
 
     if (!(link->state & DEV_PRESENT)) {
         DEBUG(2,"ray_cs interrupt_ecf - device not present\n");
@@ -1704,7 +1700,7 @@ static int get_free_tx_ccs(ray_dev_t *local)
 {
     int i;
     struct ccs __iomem *pccs = ccs_base(local);
-    dev_link_t *link = local->finder;
+    struct pcmcia_device *link = local->finder;
 
     if (!(link->state & DEV_PRESENT)) {
         DEBUG(2,"ray_cs get_free_tx_ccs - device not present\n");
@@ -1735,7 +1731,7 @@ static int get_free_ccs(ray_dev_t *local)
 {
     int i;
     struct ccs __iomem *pccs = ccs_base(local);
-    dev_link_t *link = local->finder;
+    struct pcmcia_device *link = local->finder;
 
     if (!(link->state & DEV_PRESENT)) {
         DEBUG(2,"ray_cs get_free_ccs - device not present\n");
@@ -1810,7 +1806,7 @@ static int parse_addr(char *in_str, UCHAR *out)
 static struct net_device_stats *ray_get_stats(struct net_device *dev)
 {
     ray_dev_t *local = (ray_dev_t *)dev->priv;
-    dev_link_t *link = local->finder;
+    struct pcmcia_device *link = local->finder;
     struct status __iomem *p = local->sram + STATUS_BASE;
     if (!(link->state & DEV_PRESENT)) {
         DEBUG(2,"ray_cs net_device_stats - device not present\n");
@@ -1840,7 +1836,7 @@ static struct net_device_stats *ray_get_stats(struct net_device *dev)
 static void ray_update_parm(struct net_device *dev, UCHAR objid, UCHAR *value, int len)
 {
     ray_dev_t *local = (ray_dev_t *)dev->priv;
-    dev_link_t *link = local->finder;
+    struct pcmcia_device *link = local->finder;
     int ccsindex;
     int i;
     struct ccs __iomem *pccs;
@@ -1877,7 +1873,7 @@ static void ray_update_multi_list(struct net_device *dev, int all)
     struct ccs __iomem *pccs;
     int i = 0;
     ray_dev_t *local = (ray_dev_t *)dev->priv;
-    dev_link_t *link = local->finder;
+    struct pcmcia_device *link = local->finder;
     void __iomem *p = local->sram + HOST_TO_ECF_BASE;
 
     if (!(link->state & DEV_PRESENT)) {
@@ -1957,7 +1953,7 @@ static void set_multicast_list(struct net_device *dev)
 static irqreturn_t ray_interrupt(int irq, void *dev_id, struct pt_regs * regs)
 {
     struct net_device *dev = (struct net_device *)dev_id;
-    dev_link_t *link;
+    struct pcmcia_device *link;
     ray_dev_t *local;
     struct ccs __iomem *pccs;
     struct rcs __iomem *prcs;
@@ -1972,7 +1968,7 @@ static irqreturn_t ray_interrupt(int irq, void *dev_id, struct pt_regs * regs)
     DEBUG(4,"ray_cs: interrupt for *dev=%p\n",dev);
 
     local = (ray_dev_t *)dev->priv;
-    link = (dev_link_t *)local->finder;
+    link = (struct pcmcia_device *)local->finder;
     if ( ! (link->state & DEV_PRESENT) || link->state & DEV_SUSPEND ) {
         DEBUG(2,"ray_cs interrupt from device not present or suspended.\n");
         return IRQ_NONE;
@@ -2492,7 +2488,7 @@ static void release_frag_chain(ray_dev_t *local, struct rcs __iomem * prcs)
 /*===========================================================================*/
 static void authenticate(ray_dev_t *local)
 {
-    dev_link_t *link = local->finder;
+    struct pcmcia_device *link = local->finder;
     DEBUG(0,"ray_cs Starting authentication.\n");
     if (!(link->state & DEV_PRESENT)) {
         DEBUG(2,"ray_cs authenticate - device not present\n");
@@ -2558,7 +2554,7 @@ static void rx_authenticate(ray_dev_t *local, struct rcs __iomem *prcs,
 static void associate(ray_dev_t *local)
 {
     struct ccs __iomem *pccs;
-    dev_link_t *link = local->finder;
+    struct pcmcia_device *link = local->finder;
     struct net_device *dev = link->priv;
     int ccsindex;
     if (!(link->state & DEV_PRESENT)) {
@@ -2641,7 +2637,7 @@ static int ray_cs_proc_read(char *buf, char **start, off_t offset, int len)
  * eg ifconfig 
  */
     int i;
-    dev_link_t *link;
+    struct pcmcia_device *link;
     struct net_device *dev;
     ray_dev_t *local;
     UCHAR *p;

commit fd238232cd0ff4840ae6946bb338502154096d88
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Mar 5 10:45:09 2006 +0100

    [PATCH] pcmcia: embed dev_link_t into struct pcmcia_device
    
    Embed dev_link_t into struct pcmcia_device(), as they basically address the
    same entity. The actual contents of dev_link_t will be cleaned up step by step.
    This patch includes a bugfix from and signed-off-by Andrew Morton.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 7d95587d09db..60297460debd 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -190,12 +190,6 @@ static int bc;
 static char *phy_addr = NULL;
 
 
-/* A linked list of "instances" of the ray device.  Each actual
-   PCMCIA card corresponds to one device instance, and is described
-   by one dev_link_t structure (defined in ds.h).
-*/
-static dev_link_t *dev_list = NULL;
-
 /* A dev_link_t structure has fields for most things that are needed
    to keep track of a socket, but there will usually be some device
    specific information that also needs to be kept track of.  The
@@ -204,6 +198,9 @@ static dev_link_t *dev_list = NULL;
 */
 static unsigned int ray_mem_speed = 500;
 
+/* WARNING: THIS DRIVER IS NOT CAPABLE OF HANDLING MULTIPLE DEVICES! */
+static struct pcmcia_device *this_device = NULL;
+
 MODULE_AUTHOR("Corey Thomas <corey@world.std.com>");
 MODULE_DESCRIPTION("Raylink/WebGear wireless LAN driver");
 MODULE_LICENSE("GPL");
@@ -308,53 +305,44 @@ static char rcsid[] = "Raylink/WebGear wireless LAN - Corey <Thomas corey@world.
 =============================================================================*/
 static int ray_attach(struct pcmcia_device *p_dev)
 {
-    dev_link_t *link;
     ray_dev_t *local;
     struct net_device *dev;
-    
-    DEBUG(1, "ray_attach()\n");
-
-    /* Initialize the dev_link_t structure */
-    link = kmalloc(sizeof(struct dev_link_t), GFP_KERNEL);
 
-    if (!link)
-	    return -ENOMEM;
+    DEBUG(1, "ray_attach()\n");
 
     /* Allocate space for private device-specific data */
     dev = alloc_etherdev(sizeof(ray_dev_t));
-
     if (!dev)
 	    goto fail_alloc_dev;
 
     local = dev->priv;
-
-    memset(link, 0, sizeof(struct dev_link_t));
+    local->finder = p_dev;
 
     /* The io structure describes IO port mapping. None used here */
-    link->io.NumPorts1 = 0;
-    link->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
-    link->io.IOAddrLines = 5;
+    p_dev->io.NumPorts1 = 0;
+    p_dev->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
+    p_dev->io.IOAddrLines = 5;
 
     /* Interrupt setup. For PCMCIA, driver takes what's given */
-    link->irq.Attributes = IRQ_TYPE_EXCLUSIVE | IRQ_HANDLE_PRESENT;
-    link->irq.IRQInfo1 = IRQ_LEVEL_ID;
-    link->irq.Handler = &ray_interrupt;
+    p_dev->irq.Attributes = IRQ_TYPE_EXCLUSIVE | IRQ_HANDLE_PRESENT;
+    p_dev->irq.IRQInfo1 = IRQ_LEVEL_ID;
+    p_dev->irq.Handler = &ray_interrupt;
 
     /* General socket configuration */
-    link->conf.Attributes = CONF_ENABLE_IRQ;
-    link->conf.IntType = INT_MEMORY_AND_IO;
-    link->conf.ConfigIndex = 1;
-    link->conf.Present = PRESENT_OPTION;
+    p_dev->conf.Attributes = CONF_ENABLE_IRQ;
+    p_dev->conf.IntType = INT_MEMORY_AND_IO;
+    p_dev->conf.ConfigIndex = 1;
+    p_dev->conf.Present = PRESENT_OPTION;
 
-    link->priv = dev;
-    link->irq.Instance = dev;
+    p_dev->priv = dev;
+    p_dev->irq.Instance = dev;
     
-    local->finder = link;
+    local->finder = p_dev;
     local->card_status = CARD_INSERTED;
     local->authentication_state = UNAUTHENTICATED;
     local->num_multi = 0;
-    DEBUG(2,"ray_attach link = %p,  dev = %p,  local = %p, intr = %p\n",
-          link,dev,local,&ray_interrupt);
+    DEBUG(2,"ray_attach p_dev = %p,  dev = %p,  local = %p, intr = %p\n",
+          p_dev,dev,local,&ray_interrupt);
 
     /* Raylink entries in the device structure */
     dev->hard_start_xmit = &ray_dev_start_xmit;
@@ -378,16 +366,13 @@ static int ray_attach(struct pcmcia_device *p_dev)
 
     init_timer(&local->timer);
 
-    link->handle = p_dev;
-    p_dev->instance = link;
-
-    link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
-    ray_config(link);
+    p_dev->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
+    this_device = p_dev;
+    ray_config(p_dev);
 
     return 0;
 
 fail_alloc_dev:
-    kfree(link);
     return -ENOMEM;
 } /* ray_attach */
 /*=============================================================================
@@ -399,18 +384,12 @@ static int ray_attach(struct pcmcia_device *p_dev)
 static void ray_detach(struct pcmcia_device *p_dev)
 {
     dev_link_t *link = dev_to_instance(p_dev);
-    dev_link_t **linkp;
     struct net_device *dev;
     ray_dev_t *local;
 
     DEBUG(1, "ray_detach(0x%p)\n", link);
-    
-    /* Locate device structure */
-    for (linkp = &dev_list; *linkp; linkp = &(*linkp)->next)
-        if (*linkp == link) break;
-    if (*linkp == NULL)
-        return;
 
+    this_device = NULL;
     dev = link->priv;
 
     if (link->state & DEV_CONFIG) {
@@ -420,13 +399,10 @@ static void ray_detach(struct pcmcia_device *p_dev)
             del_timer(&local->timer);
     }
 
-    /* Unlink device structure, free pieces */
-    *linkp = link->next;
     if (link->priv) {
-	if (link->dev) unregister_netdev(dev);
+	if (link->dev_node) unregister_netdev(dev);
         free_netdev(dev);
     }
-    kfree(link);
     DEBUG(2,"ray_cs ray_detach ending\n");
 } /* ray_detach */
 /*=============================================================================
@@ -537,7 +513,7 @@ static void ray_config(dev_link_t *link)
     }
 
     strcpy(local->node.dev_name, dev->name);
-    link->dev = &local->node;
+    link->dev_node = &local->node;
 
     link->state &= ~DEV_CONFIG_PENDING;
     printk(KERN_INFO "%s: RayLink, irq %d, hw_addr ",
@@ -1640,18 +1616,14 @@ static const struct iw_handler_def	ray_handler_def =
 /*===========================================================================*/
 static int ray_open(struct net_device *dev)
 {
-    dev_link_t *link;
     ray_dev_t *local = (ray_dev_t *)dev->priv;
+    dev_link_t *link;
+    link = local->finder;
     
     DEBUG(1, "ray_open('%s')\n", dev->name);
 
-    for (link = dev_list; link; link = link->next)
-        if (link->priv == dev) break;
-    if (!DEV_OK(link)) {
-        return -ENODEV;
-    }
-
-    if (link->open == 0) local->num_multi = 0;
+    if (link->open == 0)
+	    local->num_multi = 0;
     link->open++;
 
     /* If the card is not started, time to start it ! - Jean II */
@@ -1678,15 +1650,12 @@ static int ray_open(struct net_device *dev)
 /*===========================================================================*/
 static int ray_dev_close(struct net_device *dev)
 {
+    ray_dev_t *local = (ray_dev_t *)dev->priv;
     dev_link_t *link;
+    link = local->finder;
 
     DEBUG(1, "ray_dev_close('%s')\n", dev->name);
 
-    for (link = dev_list; link; link = link->next)
-        if (link->priv == dev) break;
-    if (link == NULL)
-        return -ENODEV;
-
     link->open--;
     netif_stop_queue(dev);
 
@@ -2679,7 +2648,7 @@ static int ray_cs_proc_read(char *buf, char **start, off_t offset, int len)
     struct freq_hop_element *pfh;
     UCHAR c[33];
 
-    link = dev_list;
+    link = this_device;
     if (!link)
     	return 0;
     dev = (struct net_device *)link->priv;
@@ -2923,7 +2892,6 @@ static void __exit exit_ray_cs(void)
 #endif
 
     pcmcia_unregister_driver(&ray_driver);
-    BUG_ON(dev_list != NULL);
 } /* exit_ray_cs */
 
 module_init(init_ray_cs);

commit 70294b468302fd7a0a99dad935c7ba5322989345
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Jan 15 12:43:16 2006 +0100

    [PATCH] pcmcia: remove unneeded Vcc pseudo setting
    
    As we do not allow setting Vcc in the pcmcia core, and Vpp1 and
    Vpp2 can only be set to the same value, a lot of code can be
    streamlined.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index ed4bf5013f1a..7d95587d09db 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -342,7 +342,6 @@ static int ray_attach(struct pcmcia_device *p_dev)
 
     /* General socket configuration */
     link->conf.Attributes = CONF_ENABLE_IRQ;
-    link->conf.Vcc = 50;
     link->conf.IntType = INT_MEMORY_AND_IO;
     link->conf.ConfigIndex = 1;
     link->conf.Present = PRESENT_OPTION;

commit 8661bb5b4af1849c1f5a4e80c4e275fd13c155d6
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Mar 2 00:02:33 2006 +0100

    [PATCH] pcmcia: default suspend and resume handling
    
    In all but one case, the suspend and resume functions of PCMCIA drivers
    contain mostly of calls to pcmcia_release_configuration() and
    pcmcia_request_configuration(). Therefore, move this code out of the
    drivers and into the core.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index fc81ac67009d..ed4bf5013f1a 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -868,14 +868,8 @@ static int ray_suspend(struct pcmcia_device *p_dev)
 	dev_link_t *link = dev_to_instance(p_dev);
 	struct net_device *dev = link->priv;
 
-	link->state |= DEV_SUSPEND;
-        if (link->state & DEV_CONFIG) {
-		if (link->open)
-			netif_device_detach(dev);
-
-		pcmcia_release_configuration(link->handle);
-        }
-
+	if ((link->state & DEV_CONFIG) && (link->open))
+		netif_device_detach(dev);
 
 	return 0;
 }
@@ -885,14 +879,10 @@ static int ray_resume(struct pcmcia_device *p_dev)
 	dev_link_t *link = dev_to_instance(p_dev);
 	struct net_device *dev = link->priv;
 
-	link->state &= ~DEV_SUSPEND;
-        if (link->state & DEV_CONFIG) {
-		pcmcia_request_configuration(link->handle, &link->conf);
-		if (link->open) {
-			ray_reset(dev);
-			netif_device_attach(dev);
-		}
-        }
+	if ((link->state & DEV_CONFIG) && (link->open)) {
+		ray_reset(dev);
+		netif_device_attach(dev);
+	}
 
 	return 0;
 }

commit 50db3fdbbc98260fb538c1cc3f8cc597ba7bffe7
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Jan 15 10:05:19 2006 +0100

    [PATCH] pcmcia: convert remaining users of pcmcia_release_io and _irq
    
    Convert the remaining drivers which use pcmcia_release_io or
    pcmcia_release_irq, and remove the EXPORT of these symbols.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 7880d8c31aad..fc81ac67009d 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -849,22 +849,16 @@ static void ray_release(dev_link_t *link)
     DEBUG(1, "ray_release(0x%p)\n", link);
 
     del_timer(&local->timer);
-    link->state &= ~DEV_CONFIG;
 
     iounmap(local->sram);
     iounmap(local->rmem);
     iounmap(local->amem);
     /* Do bother checking to see if these succeed or not */
-    i = pcmcia_release_window(link->win);
-    if ( i != CS_SUCCESS ) DEBUG(0,"ReleaseWindow(link->win) ret = %x\n",i);
     i = pcmcia_release_window(local->amem_handle);
     if ( i != CS_SUCCESS ) DEBUG(0,"ReleaseWindow(local->amem) ret = %x\n",i);
     i = pcmcia_release_window(local->rmem_handle);
     if ( i != CS_SUCCESS ) DEBUG(0,"ReleaseWindow(local->rmem) ret = %x\n",i);
-    i = pcmcia_release_configuration(link->handle);
-    if ( i != CS_SUCCESS ) DEBUG(0,"ReleaseConfiguration ret = %x\n",i);
-    i = pcmcia_release_irq(link->handle, &link->irq);
-    if ( i != CS_SUCCESS ) DEBUG(0,"ReleaseIRQ ret = %x\n",i);
+    pcmcia_disable_device(link->handle);
 
     DEBUG(2,"ray_release ending\n");
 }

commit d6a13a24b76236ade7fd70081ba41a51e8215578
Author: Dan Williams <dcbw@redhat.com>
Date:   Thu Jan 12 15:00:58 2006 -0500

    [PATCH] drivers/net/wireless: correct reported ssid lengths
    
    ESSIDs can technically include NULL characters.  Drivers should not be
    adjusting the length of the ESSID before reporting it in their
    SIOCGIWESSID handlers.  Breaks stuff like wpa_supplicant.  Note that ipw
    drivers, which seem to currently be the "most correct", don't have this
    problem.
    
    Signed-off-by: Dan Williams <dcbw@redhat.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 319180ca7e71..7880d8c31aad 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -1256,7 +1256,7 @@ static int ray_get_essid(struct net_device *dev,
 	extra[IW_ESSID_MAX_SIZE] = '\0';
 
 	/* Push it out ! */
-	dwrq->length = strlen(extra) + 1;
+	dwrq->length = strlen(extra);
 	dwrq->flags = 1; /* active */
 
 	return 0;

commit f8cfa618dccbdc6dab5297f75779566a388a98fd
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Mon Nov 14 21:25:51 2005 +0100

    [PATCH] pcmcia: unify attach, EVENT_CARD_INSERTION handlers into one probe callback
    
    Unify the EVENT_CARD_INSERTION and "attach" callbacks to one unified
    probe() callback. As all in-kernel drivers are changed to this new
    callback, there will be no temporary backwards-compatibility. Inside a
    probe() function, each driver _must_ set struct pcmcia_device
    *p_dev->instance and instance->handle correctly.
    
    With these patches, the basic driver interface for 16-bit PCMCIA drivers
    now has the classic four callbacks known also from other buses:
    
            int (*probe)            (struct pcmcia_device *dev);
            void (*remove)          (struct pcmcia_device *dev);
    
            int (*suspend)          (struct pcmcia_device *dev);
            int (*resume)           (struct pcmcia_device *dev);
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 33a89e292126..319180ca7e71 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -92,8 +92,6 @@ module_param(pc_debug, int, 0);
 /** Prototypes based on PCMCIA skeleton driver *******************************/
 static void ray_config(dev_link_t *link);
 static void ray_release(dev_link_t *link);
-static int ray_event(event_t event, int priority, event_callback_args_t *args);
-static dev_link_t *ray_attach(void);
 static void ray_detach(struct pcmcia_device *p_dev);
 
 /***** Prototypes indicated by device structure ******************************/
@@ -192,12 +190,6 @@ static int bc;
 static char *phy_addr = NULL;
 
 
-/* The dev_info variable is the "key" that is used to match up this
-   device driver with appropriate cards, through the card configuration
-   database.
-*/
-static dev_info_t dev_info = "ray_cs";
-
 /* A linked list of "instances" of the ray device.  Each actual
    PCMCIA card corresponds to one device instance, and is described
    by one dev_link_t structure (defined in ds.h).
@@ -314,12 +306,10 @@ static char rcsid[] = "Raylink/WebGear wireless LAN - Corey <Thomas corey@world.
     configure the card at this point -- we wait until we receive a
     card insertion event.
 =============================================================================*/
-static dev_link_t *ray_attach(void)
+static int ray_attach(struct pcmcia_device *p_dev)
 {
-    client_reg_t client_reg;
     dev_link_t *link;
     ray_dev_t *local;
-    int ret;
     struct net_device *dev;
     
     DEBUG(1, "ray_attach()\n");
@@ -328,7 +318,7 @@ static dev_link_t *ray_attach(void)
     link = kmalloc(sizeof(struct dev_link_t), GFP_KERNEL);
 
     if (!link)
-	    return NULL;
+	    return -ENOMEM;
 
     /* Allocate space for private device-specific data */
     dev = alloc_etherdev(sizeof(ray_dev_t));
@@ -387,30 +377,19 @@ static dev_link_t *ray_attach(void)
     dev->stop = &ray_dev_close;
     netif_stop_queue(dev);
 
-    /* Register with Card Services */
-    link->next = dev_list;
-    dev_list = link;
-    client_reg.dev_info = &dev_info;
-    client_reg.Version = 0x0210;
-    client_reg.event_callback_args.client_data = link;
+    init_timer(&local->timer);
 
-    DEBUG(2,"ray_cs ray_attach calling pcmcia_register_client(...)\n");
+    link->handle = p_dev;
+    p_dev->instance = link;
 
-    init_timer(&local->timer);
+    link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
+    ray_config(link);
 
-    ret = pcmcia_register_client(&link->handle, &client_reg);
-    if (ret != 0) {
-        printk("ray_cs ray_attach RegisterClient unhappy - detaching\n");
-        cs_error(link->handle, RegisterClient, ret);
-        ray_detach(link->handle);
-        return NULL;
-    }
-    DEBUG(2,"ray_cs ray_attach ending\n");
-    return link;
+    return 0;
 
 fail_alloc_dev:
     kfree(link);
-    return NULL;
+    return -ENOMEM;
 } /* ray_attach */
 /*=============================================================================
     This deletes a driver "instance".  The device is de-registered
@@ -924,32 +903,6 @@ static int ray_resume(struct pcmcia_device *p_dev)
 	return 0;
 }
 
-/*=============================================================================
-    The card status event handler.  Mostly, this schedules other
-    stuff to run after an event is received.  A CARD_REMOVAL event
-    also sets some flags to discourage the net drivers from trying
-    to talk to the card any more.
-
-    When a CARD_REMOVAL event is received, we immediately set a flag
-    to block future accesses to this device.  All the functions that
-    actually access the device should check this flag to make sure
-    the card is still present.
-=============================================================================*/
-static int ray_event(event_t event, int priority,
-                     event_callback_args_t *args)
-{
-    dev_link_t *link = args->client_data;
-    DEBUG(1, "ray_event(0x%06x)\n", event);
-
-    switch (event) {
-    case CS_EVENT_CARD_INSERTION:
-        link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
-        ray_config(link);
-        break;
-    }
-    return 0;
-    DEBUG(2,"ray_event ending\n");
-} /* ray_event */
 /*===========================================================================*/
 int ray_dev_init(struct net_device *dev)
 {
@@ -2945,8 +2898,7 @@ static struct pcmcia_driver ray_driver = {
 	.drv		= {
 		.name	= "ray_cs",
 	},
-	.attach		= ray_attach,
-	.event		= ray_event,
+	.probe		= ray_attach,
 	.remove		= ray_detach,
 	.id_table       = ray_ids,
 	.suspend	= ray_suspend,

commit cc3b4866bee996c922e875b8c8efe9f0d8803aae
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Mon Nov 14 21:23:14 2005 +0100

    [PATCH] pcmcia: unify detach, REMOVAL_EVENT handlers into one remove callback
    
    Unify the "detach" and REMOVAL_EVENT handlers to one "remove" function.
    Old functionality is preserved, for the moment.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index c2cb6c8e6d7c..33a89e292126 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -94,7 +94,7 @@ static void ray_config(dev_link_t *link);
 static void ray_release(dev_link_t *link);
 static int ray_event(event_t event, int priority, event_callback_args_t *args);
 static dev_link_t *ray_attach(void);
-static void ray_detach(dev_link_t *);
+static void ray_detach(struct pcmcia_device *p_dev);
 
 /***** Prototypes indicated by device structure ******************************/
 static int ray_dev_close(struct net_device *dev);
@@ -402,7 +402,7 @@ static dev_link_t *ray_attach(void)
     if (ret != 0) {
         printk("ray_cs ray_attach RegisterClient unhappy - detaching\n");
         cs_error(link->handle, RegisterClient, ret);
-        ray_detach(link);
+        ray_detach(link->handle);
         return NULL;
     }
     DEBUG(2,"ray_cs ray_attach ending\n");
@@ -418,9 +418,12 @@ static dev_link_t *ray_attach(void)
     structures are freed.  Otherwise, the structures will be freed
     when the device is released.
 =============================================================================*/
-static void ray_detach(dev_link_t *link)
+static void ray_detach(struct pcmcia_device *p_dev)
 {
+    dev_link_t *link = dev_to_instance(p_dev);
     dev_link_t **linkp;
+    struct net_device *dev;
+    ray_dev_t *local;
 
     DEBUG(1, "ray_detach(0x%p)\n", link);
     
@@ -430,22 +433,18 @@ static void ray_detach(dev_link_t *link)
     if (*linkp == NULL)
         return;
 
-    /* If the device is currently configured and active, we won't
-      actually delete it yet.  Instead, it is marked so that when
-      the release() function is called, that will trigger a proper
-      detach().
-    */
-    if (link->state & DEV_CONFIG)
-        ray_release(link);
+    dev = link->priv;
+
+    if (link->state & DEV_CONFIG) {
+	    ray_release(link);
+
+	    local = (ray_dev_t *)dev->priv;
+            del_timer(&local->timer);
+    }
 
-    /* Break the link with Card Services */
-    if (link->handle)
-        pcmcia_deregister_client(link->handle);
-    
     /* Unlink device structure, free pieces */
     *linkp = link->next;
     if (link->priv) {
-        struct net_device *dev = link->priv;
 	if (link->dev) unregister_netdev(dev);
         free_netdev(dev);
     }
@@ -940,19 +939,9 @@ static int ray_event(event_t event, int priority,
                      event_callback_args_t *args)
 {
     dev_link_t *link = args->client_data;
-    struct net_device *dev = link->priv;
-    ray_dev_t *local = (ray_dev_t *)dev->priv;
     DEBUG(1, "ray_event(0x%06x)\n", event);
-    
+
     switch (event) {
-    case CS_EVENT_CARD_REMOVAL:
-        link->state &= ~DEV_PRESENT;
-        netif_device_detach(dev);
-        if (link->state & DEV_CONFIG) {
-	    ray_release(link);
-            del_timer(&local->timer);
-        }
-        break;
     case CS_EVENT_CARD_INSERTION:
         link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
         ray_config(link);
@@ -2958,7 +2947,7 @@ static struct pcmcia_driver ray_driver = {
 	},
 	.attach		= ray_attach,
 	.event		= ray_event,
-	.detach		= ray_detach,
+	.remove		= ray_detach,
 	.id_table       = ray_ids,
 	.suspend	= ray_suspend,
 	.resume		= ray_resume,

commit 98e4c28b7ec390c2dad6a4c69d69629c0f7e8b10
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Mon Nov 14 21:21:18 2005 +0100

    [PATCH] pcmcia: new suspend core
    
    Move the suspend and resume methods out of the event handler, and into
    special functions. Also use these functions for pre- and post-reset, as
    almost all drivers already do, and the remaining ones can easily be
    converted.
    
    Bugfix to include/pcmcia/ds.c
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 70fd6fd8feb9..c2cb6c8e6d7c 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -891,6 +891,40 @@ static void ray_release(dev_link_t *link)
     DEBUG(2,"ray_release ending\n");
 }
 
+static int ray_suspend(struct pcmcia_device *p_dev)
+{
+	dev_link_t *link = dev_to_instance(p_dev);
+	struct net_device *dev = link->priv;
+
+	link->state |= DEV_SUSPEND;
+        if (link->state & DEV_CONFIG) {
+		if (link->open)
+			netif_device_detach(dev);
+
+		pcmcia_release_configuration(link->handle);
+        }
+
+
+	return 0;
+}
+
+static int ray_resume(struct pcmcia_device *p_dev)
+{
+	dev_link_t *link = dev_to_instance(p_dev);
+	struct net_device *dev = link->priv;
+
+	link->state &= ~DEV_SUSPEND;
+        if (link->state & DEV_CONFIG) {
+		pcmcia_request_configuration(link->handle, &link->conf);
+		if (link->open) {
+			ray_reset(dev);
+			netif_device_attach(dev);
+		}
+        }
+
+	return 0;
+}
+
 /*=============================================================================
     The card status event handler.  Mostly, this schedules other
     stuff to run after an event is received.  A CARD_REMOVAL event
@@ -923,29 +957,6 @@ static int ray_event(event_t event, int priority,
         link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
         ray_config(link);
         break;
-    case CS_EVENT_PM_SUSPEND:
-        link->state |= DEV_SUSPEND;
-        /* Fall through... */
-    case CS_EVENT_RESET_PHYSICAL:
-        if (link->state & DEV_CONFIG) {
-            if (link->open)
-            	netif_device_detach(dev);
-
-            pcmcia_release_configuration(link->handle);
-        }
-        break;
-    case CS_EVENT_PM_RESUME:
-        link->state &= ~DEV_SUSPEND;
-        /* Fall through... */
-    case CS_EVENT_CARD_RESET:
-        if (link->state & DEV_CONFIG) {
-            pcmcia_request_configuration(link->handle, &link->conf);
-            if (link->open) {
-                ray_reset(dev);
-		netif_device_attach(dev);
-            }
-        }
-        break;
     }
     return 0;
     DEBUG(2,"ray_event ending\n");
@@ -2949,6 +2960,8 @@ static struct pcmcia_driver ray_driver = {
 	.event		= ray_event,
 	.detach		= ray_detach,
 	.id_table       = ray_ids,
+	.suspend	= ray_suspend,
+	.resume		= ray_resume,
 };
 
 static int __init init_ray_cs(void)

commit 7a700fafbed55eee2cc766fbe47cf68e229da281
Author: viro@ZenIV.linux.org.uk <viro@ZenIV.linux.org.uk>
Date:   Fri Sep 9 20:40:23 2005 +0100

    [PATCH] C99 initializers in ray_cs.c
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index e9c5ea0f5535..70fd6fd8feb9 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -1649,28 +1649,28 @@ static iw_stats * ray_get_wireless_stats(struct net_device *	dev)
  */
 
 static const iw_handler	ray_handler[] = {
-	[SIOCSIWCOMMIT-SIOCIWFIRST] (iw_handler) ray_commit,
-	[SIOCGIWNAME  -SIOCIWFIRST] (iw_handler) ray_get_name,
-	[SIOCSIWFREQ  -SIOCIWFIRST] (iw_handler) ray_set_freq,
-	[SIOCGIWFREQ  -SIOCIWFIRST] (iw_handler) ray_get_freq,
-	[SIOCSIWMODE  -SIOCIWFIRST] (iw_handler) ray_set_mode,
-	[SIOCGIWMODE  -SIOCIWFIRST] (iw_handler) ray_get_mode,
-	[SIOCGIWRANGE -SIOCIWFIRST] (iw_handler) ray_get_range,
+	[SIOCSIWCOMMIT-SIOCIWFIRST] = (iw_handler) ray_commit,
+	[SIOCGIWNAME  -SIOCIWFIRST] = (iw_handler) ray_get_name,
+	[SIOCSIWFREQ  -SIOCIWFIRST] = (iw_handler) ray_set_freq,
+	[SIOCGIWFREQ  -SIOCIWFIRST] = (iw_handler) ray_get_freq,
+	[SIOCSIWMODE  -SIOCIWFIRST] = (iw_handler) ray_set_mode,
+	[SIOCGIWMODE  -SIOCIWFIRST] = (iw_handler) ray_get_mode,
+	[SIOCGIWRANGE -SIOCIWFIRST] = (iw_handler) ray_get_range,
 #ifdef WIRELESS_SPY
- 	[SIOCSIWSPY   -SIOCIWFIRST] (iw_handler) iw_handler_set_spy,
-	[SIOCGIWSPY   -SIOCIWFIRST] (iw_handler) iw_handler_get_spy,
-	[SIOCSIWTHRSPY-SIOCIWFIRST] (iw_handler) iw_handler_set_thrspy,
-	[SIOCGIWTHRSPY-SIOCIWFIRST] (iw_handler) iw_handler_get_thrspy,
+ 	[SIOCSIWSPY   -SIOCIWFIRST] = (iw_handler) iw_handler_set_spy,
+	[SIOCGIWSPY   -SIOCIWFIRST] = (iw_handler) iw_handler_get_spy,
+	[SIOCSIWTHRSPY-SIOCIWFIRST] = (iw_handler) iw_handler_set_thrspy,
+	[SIOCGIWTHRSPY-SIOCIWFIRST] = (iw_handler) iw_handler_get_thrspy,
 #endif	/* WIRELESS_SPY */
-	[SIOCGIWAP    -SIOCIWFIRST] (iw_handler) ray_get_wap,
-	[SIOCSIWESSID -SIOCIWFIRST] (iw_handler) ray_set_essid,
-	[SIOCGIWESSID -SIOCIWFIRST] (iw_handler) ray_get_essid,
-	[SIOCSIWRATE  -SIOCIWFIRST] (iw_handler) ray_set_rate,
-	[SIOCGIWRATE  -SIOCIWFIRST] (iw_handler) ray_get_rate,
-	[SIOCSIWRTS   -SIOCIWFIRST] (iw_handler) ray_set_rts,
-	[SIOCGIWRTS   -SIOCIWFIRST] (iw_handler) ray_get_rts,
-	[SIOCSIWFRAG  -SIOCIWFIRST] (iw_handler) ray_set_frag,
-	[SIOCGIWFRAG  -SIOCIWFIRST] (iw_handler) ray_get_frag,
+	[SIOCGIWAP    -SIOCIWFIRST] = (iw_handler) ray_get_wap,
+	[SIOCSIWESSID -SIOCIWFIRST] = (iw_handler) ray_set_essid,
+	[SIOCGIWESSID -SIOCIWFIRST] = (iw_handler) ray_get_essid,
+	[SIOCSIWRATE  -SIOCIWFIRST] = (iw_handler) ray_set_rate,
+	[SIOCGIWRATE  -SIOCIWFIRST] = (iw_handler) ray_get_rate,
+	[SIOCSIWRTS   -SIOCIWFIRST] = (iw_handler) ray_set_rts,
+	[SIOCGIWRTS   -SIOCIWFIRST] = (iw_handler) ray_get_rts,
+	[SIOCSIWFRAG  -SIOCIWFIRST] = (iw_handler) ray_set_frag,
+	[SIOCGIWFRAG  -SIOCIWFIRST] = (iw_handler) ray_get_frag,
 };
 
 #define SIOCSIPFRAMING	SIOCIWFIRSTPRIV		/* Set framing mode */
@@ -1678,9 +1678,9 @@ static const iw_handler	ray_handler[] = {
 #define SIOCGIPCOUNTRY	SIOCIWFIRSTPRIV + 3	/* Get country code */
 
 static const iw_handler	ray_private_handler[] = {
-	[0] (iw_handler) ray_set_framing,
-	[1] (iw_handler) ray_get_framing,
-	[3] (iw_handler) ray_get_country,
+	[0] = (iw_handler) ray_set_framing,
+	[1] = (iw_handler) ray_get_framing,
+	[3] = (iw_handler) ray_get_country,
 };
 
 static const struct iw_priv_args	ray_private_args[] = {

commit bbeec90b98a3066f6f2b8d41c80561f5665e4631
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Wed Sep 7 00:27:54 2005 -0400

    [wireless] build fixes after merging WE-19

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 74d66eeddef2..e9c5ea0f5535 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -53,6 +53,7 @@
 #include <pcmcia/ds.h>
 #include <pcmcia/mem_op.h>
 
+#include <net/ieee80211.h>
 #include <linux/wireless.h>
 
 #include <asm/io.h>

commit 3d5d5ac085c467f05cce85d32985e78912db4a7e
Author: Jean Tourrilhes <jt@hpl.hp.com>
Date:   Fri Sep 2 11:40:39 2005 -0700

    [PATCH] ray_cs : WE-17 support
    
            This adds support for WE-17 to the ray_cs driver. Tested
    with 2.6.13 (with real HW).
    
    Signed-off-by: Jean Tourrilhes <jt@hpl.hp.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 0e0ba614259a..74d66eeddef2 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -64,7 +64,6 @@
 #define WIRELESS_SPY		/* Enable spying addresses */
 /* Definitions we need for spy */
 typedef struct iw_statistics	iw_stats;
-typedef struct iw_quality	iw_qual;
 typedef u_char	mac_addr[ETH_ALEN];	/* Hardware address */
 
 #include "rayctl.h"
@@ -101,7 +100,6 @@ static int ray_dev_close(struct net_device *dev);
 static int ray_dev_config(struct net_device *dev, struct ifmap *map);
 static struct net_device_stats *ray_get_stats(struct net_device *dev);
 static int ray_dev_init(struct net_device *dev);
-static int ray_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
 
 static struct ethtool_ops netdev_ethtool_ops;
 
@@ -114,9 +112,8 @@ static int translate_frame(ray_dev_t *local, struct tx_msg __iomem *ptx,
 static void ray_build_header(ray_dev_t *local, struct tx_msg __iomem *ptx, UCHAR msg_type,
                 unsigned char *data);
 static void untranslate(ray_dev_t *local, struct sk_buff *skb, int len);
-#if WIRELESS_EXT > 7	/* If wireless extension exist in the kernel */
 static iw_stats * ray_get_wireless_stats(struct net_device *	dev);
-#endif	/* WIRELESS_EXT > 7 */
+static const struct iw_handler_def	ray_handler_def;
 
 /***** Prototypes for raylink functions **************************************/
 static int asc_to_int(char a);
@@ -373,11 +370,12 @@ static dev_link_t *ray_attach(void)
     dev->hard_start_xmit = &ray_dev_start_xmit;
     dev->set_config = &ray_dev_config;
     dev->get_stats  = &ray_get_stats;
-    dev->do_ioctl = &ray_dev_ioctl;
     SET_ETHTOOL_OPS(dev, &netdev_ethtool_ops);
-#if WIRELESS_EXT > 7	/* If wireless extension exist in the kernel */
-    dev->get_wireless_stats = ray_get_wireless_stats;
-#endif
+    dev->wireless_handlers = &ray_handler_def;
+#ifdef WIRELESS_SPY
+    local->wireless_data.spy_data = &local->spy_data;
+    dev->wireless_data = &local->wireless_data;
+#endif	/* WIRELESS_SPY */
 
     dev->set_multicast_list = &set_multicast_list;
 
@@ -1201,436 +1199,420 @@ static struct ethtool_ops netdev_ethtool_ops = {
 
 /*====================================================================*/
 
-static int ray_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Handler : get protocol name
+ */
+static int ray_get_name(struct net_device *dev,
+			struct iw_request_info *info,
+			char *cwrq,
+			char *extra)
 {
-    ray_dev_t *local = (ray_dev_t *)dev->priv;
-    dev_link_t *link = local->finder;
-    int err = 0;
-#if WIRELESS_EXT > 7
-    struct iwreq *wrq = (struct iwreq *) ifr;
-#endif	/* WIRELESS_EXT > 7 */
-#ifdef WIRELESS_SPY
-    struct sockaddr	address[IW_MAX_SPY];
-#endif	/* WIRELESS_SPY */
+	strcpy(cwrq, "IEEE 802.11-FH");
+	return 0;
+}
 
-    if (!(link->state & DEV_PRESENT)) {
-        DEBUG(2,"ray_dev_ioctl - device not present\n");
-        return -1;
-    }
-    DEBUG(2,"ray_cs IOCTL dev=%p, ifr=%p, cmd = 0x%x\n",dev,ifr,cmd);
-    /* Validate the command */
-    switch (cmd)
-    {
-#if WIRELESS_EXT > 7
-      /* --------------- WIRELESS EXTENSIONS --------------- */
-      /* Get name */
-    case SIOCGIWNAME:
-      strcpy(wrq->u.name, "IEEE 802.11-FH");
-      break;
-
-      /* Get frequency/channel */
-    case SIOCGIWFREQ:
-      wrq->u.freq.m = local->sparm.b5.a_hop_pattern;
-      wrq->u.freq.e = 0;
-      break;
-
-      /* Set frequency/channel */
-    case SIOCSIWFREQ:
-      /* Reject if card is already initialised */
-      if(local->card_status != CARD_AWAITING_PARAM)
-	{
-	  err = -EBUSY;
-	  break;
-	}
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Handler : set frequency
+ */
+static int ray_set_freq(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_freq *fwrq,
+			char *extra)
+{
+	ray_dev_t *local = (ray_dev_t *)dev->priv;
+	int err = -EINPROGRESS;		/* Call commit handler */
 
-      /* Setting by channel number */
-      if ((wrq->u.freq.m > USA_HOP_MOD) || (wrq->u.freq.e > 0))
-	err = -EOPNOTSUPP;
-      else
-	  local->sparm.b5.a_hop_pattern = wrq->u.freq.m;
-      break;
+	/* Reject if card is already initialised */
+	if(local->card_status != CARD_AWAITING_PARAM)
+		return -EBUSY;
 
-      /* Get current network name (ESSID) */
-    case SIOCGIWESSID:
-      if (wrq->u.data.pointer)
-	{
-	  char essid[IW_ESSID_MAX_SIZE + 1];
-	  /* Get the essid that was set */
-	  memcpy(essid, local->sparm.b5.a_current_ess_id,
-		 IW_ESSID_MAX_SIZE);
-	  essid[IW_ESSID_MAX_SIZE] = '\0';
-
-	  /* Push it out ! */
-	  wrq->u.data.length = strlen(essid) + 1;
-	  wrq->u.data.flags = 1; /* active */
-	  if (copy_to_user(wrq->u.data.pointer, essid, sizeof(essid)))
-		  err = -EFAULT;
-	}
-      break;
+	/* Setting by channel number */
+	if ((fwrq->m > USA_HOP_MOD) || (fwrq->e > 0))
+		err = -EOPNOTSUPP;
+	else
+		local->sparm.b5.a_hop_pattern = fwrq->m;
 
-      /* Set desired network name (ESSID) */
-    case SIOCSIWESSID:
-      /* Reject if card is already initialised */
-      if(local->card_status != CARD_AWAITING_PARAM)
-	{
-	  err = -EBUSY;
-	  break;
-	}
+	return err;
+}
+ 
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Handler : get frequency
+ */
+static int ray_get_freq(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_freq *fwrq,
+			char *extra)
+{
+	ray_dev_t *local = (ray_dev_t *)dev->priv;
 
-	if (wrq->u.data.pointer)
-	{
-	    char	card_essid[IW_ESSID_MAX_SIZE + 1];
-	    
-	    /* Check if we asked for `any' */
-	    if(wrq->u.data.flags == 0)
-	    {
+	fwrq->m = local->sparm.b5.a_hop_pattern;
+	fwrq->e = 0;
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Handler : set ESSID
+ */
+static int ray_set_essid(struct net_device *dev,
+			 struct iw_request_info *info,
+			 struct iw_point *dwrq,
+			 char *extra)
+{
+	ray_dev_t *local = (ray_dev_t *)dev->priv;
+
+	/* Reject if card is already initialised */
+	if(local->card_status != CARD_AWAITING_PARAM)
+		return -EBUSY;
+
+	/* Check if we asked for `any' */
+	if(dwrq->flags == 0) {
 		/* Corey : can you do that ? */
-		err = -EOPNOTSUPP;
-	    }
-	    else
-	    {
+		return -EOPNOTSUPP;
+	} else {
 		/* Check the size of the string */
-		if(wrq->u.data.length >
-		   IW_ESSID_MAX_SIZE + 1)
-		{
-		    err = -E2BIG;
-		    break;
-		}
-		if (copy_from_user(card_essid,
-				   wrq->u.data.pointer,
-				   wrq->u.data.length)) {
-			err = -EFAULT;
-			break;
+		if(dwrq->length > IW_ESSID_MAX_SIZE + 1) {
+			return -E2BIG;
 		}
-		card_essid[IW_ESSID_MAX_SIZE] = '\0';
 
 		/* Set the ESSID in the card */
-		memcpy(local->sparm.b5.a_current_ess_id, card_essid,
-		       IW_ESSID_MAX_SIZE);
-	    }
+		memset(local->sparm.b5.a_current_ess_id, 0, IW_ESSID_MAX_SIZE);
+		memcpy(local->sparm.b5.a_current_ess_id, extra, dwrq->length);
 	}
-	break;
-
-      /* Get current Access Point (BSSID in our case) */
-    case SIOCGIWAP:
-      memcpy(wrq->u.ap_addr.sa_data, local->bss_id, ETH_ALEN);
-      wrq->u.ap_addr.sa_family = ARPHRD_ETHER;
-      break;
-
-      /* Get the current bit-rate */
-    case SIOCGIWRATE:
-      if(local->net_default_tx_rate == 3)
-	wrq->u.bitrate.value = 2000000;		/* Hum... */
-      else
-	wrq->u.bitrate.value = local->net_default_tx_rate * 500000;
-      wrq->u.bitrate.fixed = 0;		/* We are in auto mode */
-      break;
-
-      /* Set the desired bit-rate */
-    case SIOCSIWRATE:
-      /* Check if rate is in range */
-      if((wrq->u.bitrate.value != 1000000) &&
-	 (wrq->u.bitrate.value != 2000000))
-	{
-	  err = -EINVAL;
-	  break;
-	}
-      /* Hack for 1.5 Mb/s instead of 2 Mb/s */
-      if((local->fw_ver == 0x55) &&		/* Please check */
-	 (wrq->u.bitrate.value == 2000000))
-	local->net_default_tx_rate = 3;
-      else
-	local->net_default_tx_rate = wrq->u.bitrate.value/500000;
-      break;
-
-      /* Get the current RTS threshold */
-    case SIOCGIWRTS:
-      wrq->u.rts.value = (local->sparm.b5.a_rts_threshold[0] << 8)
-	+ local->sparm.b5.a_rts_threshold[1];
-#if WIRELESS_EXT > 8
-      wrq->u.rts.disabled = (wrq->u.rts.value == 32767);
-#endif /* WIRELESS_EXT > 8 */
-      wrq->u.rts.fixed = 1;
-      break;
-
-      /* Set the desired RTS threshold */
-    case SIOCSIWRTS:
-    {
-	int rthr = wrq->u.rts.value;
 
-      /* Reject if card is already initialised */
-      if(local->card_status != CARD_AWAITING_PARAM)
-	{
-	  err = -EBUSY;
-	  break;
-	}
+	return -EINPROGRESS;		/* Call commit handler */
+}
 
-	/* if(wrq->u.rts.fixed == 0) we should complain */
-#if WIRELESS_EXT > 8
-	if(wrq->u.rts.disabled)
-	    rthr = 32767;
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Handler : get ESSID
+ */
+static int ray_get_essid(struct net_device *dev,
+			 struct iw_request_info *info,
+			 struct iw_point *dwrq,
+			 char *extra)
+{
+	ray_dev_t *local = (ray_dev_t *)dev->priv;
+
+	/* Get the essid that was set */
+	memcpy(extra, local->sparm.b5.a_current_ess_id, IW_ESSID_MAX_SIZE);
+	extra[IW_ESSID_MAX_SIZE] = '\0';
+
+	/* Push it out ! */
+	dwrq->length = strlen(extra) + 1;
+	dwrq->flags = 1; /* active */
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Handler : get AP address
+ */
+static int ray_get_wap(struct net_device *dev,
+			struct iw_request_info *info,
+			struct sockaddr *awrq,
+			char *extra)
+{
+	ray_dev_t *local = (ray_dev_t *)dev->priv;
+
+	memcpy(awrq->sa_data, local->bss_id, ETH_ALEN);
+	awrq->sa_family = ARPHRD_ETHER;
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Handler : set Bit-Rate
+ */
+static int ray_set_rate(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_param *vwrq,
+			char *extra)
+{
+	ray_dev_t *local = (ray_dev_t *)dev->priv;
+
+	/* Reject if card is already initialised */
+	if(local->card_status != CARD_AWAITING_PARAM)
+		return -EBUSY;
+
+	/* Check if rate is in range */
+	if((vwrq->value != 1000000) && (vwrq->value != 2000000))
+		return -EINVAL;
+
+	/* Hack for 1.5 Mb/s instead of 2 Mb/s */
+	if((local->fw_ver == 0x55) &&		/* Please check */
+	   (vwrq->value == 2000000))
+		local->net_default_tx_rate = 3;
 	else
-#endif /* WIRELESS_EXT > 8 */
-	    if((rthr < 0) || (rthr > 2347)) /* What's the max packet size ??? */
-	    {
-		err = -EINVAL;
-		break;
-	    }
+		local->net_default_tx_rate = vwrq->value/500000;
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Handler : get Bit-Rate
+ */
+static int ray_get_rate(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_param *vwrq,
+			char *extra)
+{
+	ray_dev_t *local = (ray_dev_t *)dev->priv;
+
+	if(local->net_default_tx_rate == 3)
+		vwrq->value = 2000000;		/* Hum... */
+	else
+		vwrq->value = local->net_default_tx_rate * 500000;
+	vwrq->fixed = 0;		/* We are in auto mode */
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Handler : set RTS threshold
+ */
+static int ray_set_rts(struct net_device *dev,
+		       struct iw_request_info *info,
+		       struct iw_param *vwrq,
+		       char *extra)
+{
+	ray_dev_t *local = (ray_dev_t *)dev->priv;
+	int rthr = vwrq->value;
+
+	/* Reject if card is already initialised */
+	if(local->card_status != CARD_AWAITING_PARAM)
+		return -EBUSY;
+
+	/* if(wrq->u.rts.fixed == 0) we should complain */
+	if(vwrq->disabled)
+		rthr = 32767;
+	else {
+		if((rthr < 0) || (rthr > 2347)) /* What's the max packet size ??? */
+			return -EINVAL;
+	}
 	local->sparm.b5.a_rts_threshold[0] = (rthr >> 8) & 0xFF;
 	local->sparm.b5.a_rts_threshold[1] = rthr & 0xFF;
-    }
-    break;
 
-      /* Get the current fragmentation threshold */
-    case SIOCGIWFRAG:
-      wrq->u.frag.value = (local->sparm.b5.a_frag_threshold[0] << 8)
-	+ local->sparm.b5.a_frag_threshold[1];
-#if WIRELESS_EXT > 8
-      wrq->u.frag.disabled = (wrq->u.frag.value == 32767);
-#endif /* WIRELESS_EXT > 8 */
-      wrq->u.frag.fixed = 1;
-      break;
+	return -EINPROGRESS;		/* Call commit handler */
+}
 
-      /* Set the desired fragmentation threshold */
-    case SIOCSIWFRAG:
-    {
-	int fthr = wrq->u.frag.value;
 
-      /* Reject if card is already initialised */
-      if(local->card_status != CARD_AWAITING_PARAM)
-	{
-	  err = -EBUSY;
-	  break;
-	}
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Handler : get RTS threshold
+ */
+static int ray_get_rts(struct net_device *dev,
+		       struct iw_request_info *info,
+		       struct iw_param *vwrq,
+		       char *extra)
+{
+	ray_dev_t *local = (ray_dev_t *)dev->priv;
+
+	vwrq->value = (local->sparm.b5.a_rts_threshold[0] << 8)
+		+ local->sparm.b5.a_rts_threshold[1];
+	vwrq->disabled = (vwrq->value == 32767);
+	vwrq->fixed = 1;
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Handler : set Fragmentation threshold
+ */
+static int ray_set_frag(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_param *vwrq,
+			char *extra)
+{
+	ray_dev_t *local = (ray_dev_t *)dev->priv;
+	int fthr = vwrq->value;
+
+	/* Reject if card is already initialised */
+	if(local->card_status != CARD_AWAITING_PARAM)
+		return -EBUSY;
 
 	/* if(wrq->u.frag.fixed == 0) should complain */
-#if WIRELESS_EXT > 8
-	if(wrq->u.frag.disabled)
-	    fthr = 32767;
-	else
-#endif /* WIRELESS_EXT > 8 */
-	    if((fthr < 256) || (fthr > 2347)) /* To check out ! */
-	    {
-		err = -EINVAL;
-		break;
-	    }
+	if(vwrq->disabled)
+		fthr = 32767;
+	else {
+		if((fthr < 256) || (fthr > 2347)) /* To check out ! */
+			return -EINVAL;
+	}
 	local->sparm.b5.a_frag_threshold[0] = (fthr >> 8) & 0xFF;
 	local->sparm.b5.a_frag_threshold[1] = fthr & 0xFF;
-    }
-    break;
 
-#endif	/* WIRELESS_EXT > 7 */
-#if WIRELESS_EXT > 8
+	return -EINPROGRESS;		/* Call commit handler */
+}
 
-      /* Get the current mode of operation */
-    case SIOCGIWMODE:
-      if(local->sparm.b5.a_network_type)
-	wrq->u.mode = IW_MODE_INFRA;
-      else
-	wrq->u.mode = IW_MODE_ADHOC;
-      break;
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Handler : get Fragmentation threshold
+ */
+static int ray_get_frag(struct net_device *dev,
+			struct iw_request_info *info,
+			struct iw_param *vwrq,
+			char *extra)
+{
+	ray_dev_t *local = (ray_dev_t *)dev->priv;
 
-      /* Set the current mode of operation */
-    case SIOCSIWMODE:
-    {
+	vwrq->value = (local->sparm.b5.a_frag_threshold[0] << 8)
+		+ local->sparm.b5.a_frag_threshold[1];
+	vwrq->disabled = (vwrq->value == 32767);
+	vwrq->fixed = 1;
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Handler : set Mode of Operation
+ */
+static int ray_set_mode(struct net_device *dev,
+			struct iw_request_info *info,
+			__u32 *uwrq,
+			char *extra)
+{
+	ray_dev_t *local = (ray_dev_t *)dev->priv;
+	int err = -EINPROGRESS;		/* Call commit handler */
 	char card_mode = 1;
-	
-      /* Reject if card is already initialised */
-      if(local->card_status != CARD_AWAITING_PARAM)
-	{
-	  err = -EBUSY;
-	  break;
-	}
 
-	switch (wrq->u.mode)
+	/* Reject if card is already initialised */
+	if(local->card_status != CARD_AWAITING_PARAM)
+		return -EBUSY;
+
+	switch (*uwrq)
 	{
 	case IW_MODE_ADHOC:
-	    card_mode = 0;
-	    // Fall through
+		card_mode = 0;
+		// Fall through
 	case IW_MODE_INFRA:
-	    local->sparm.b5.a_network_type = card_mode;
-	    break;
+		local->sparm.b5.a_network_type = card_mode;
+		break;
 	default:
-	    err = -EINVAL;
+		err = -EINVAL;
 	}
-    }
-    break;
 
-#endif /* WIRELESS_EXT > 8 */
-#if WIRELESS_EXT > 7
-      /* ------------------ IWSPY SUPPORT ------------------ */
-      /* Define the range (variations) of above parameters */
-    case SIOCGIWRANGE:
-      /* Basic checking... */
-      if(wrq->u.data.pointer != (caddr_t) 0)
-	{
-	  struct iw_range	range;
-	  memset((char *) &range, 0, sizeof(struct iw_range));
-
-	  /* Set the length (very important for backward compatibility) */
-	  wrq->u.data.length = sizeof(struct iw_range);
-
-#if WIRELESS_EXT > 10
-	  /* Set the Wireless Extension versions */
-	  range.we_version_compiled = WIRELESS_EXT;
-	  range.we_version_source = 9;
-#endif /* WIRELESS_EXT > 10 */
-
-	  /* Set information in the range struct */
-	  range.throughput = 1.1 * 1000 * 1000;	/* Put the right number here */
-	  range.num_channels = hop_pattern_length[(int)country]; 
-	  range.num_frequency = 0;
-	  range.max_qual.qual = 0;
-	  range.max_qual.level = 255;	/* What's the correct value ? */
-	  range.max_qual.noise = 255;	/* Idem */
-	  range.num_bitrates = 2;
-	  range.bitrate[0] = 1000000;	/* 1 Mb/s */
-	  range.bitrate[1] = 2000000;	/* 2 Mb/s */
-
-	  /* Copy structure to the user buffer */
-	  if(copy_to_user(wrq->u.data.pointer, &range,
-			  sizeof(struct iw_range)))
-	    err = -EFAULT;
-	}
-      break;
+	return err;
+}
 
-#ifdef WIRELESS_SPY
-      /* Set addresses to spy */
-    case SIOCSIWSPY:
-      /* Check the number of addresses */
-      if(wrq->u.data.length > IW_MAX_SPY)
-	{
-	  err = -E2BIG;
-	  break;
-	}
-      local->spy_number = wrq->u.data.length;
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Handler : get Mode of Operation
+ */
+static int ray_get_mode(struct net_device *dev,
+			struct iw_request_info *info,
+			__u32 *uwrq,
+			char *extra)
+{
+	ray_dev_t *local = (ray_dev_t *)dev->priv;
 
-      /* If there is some addresses to copy */
-      if(local->spy_number > 0)
-	{
-	  int			i;
-
-	  /* Copy addresses to the driver */
-	  if(copy_from_user(address, wrq->u.data.pointer,
-			    sizeof(struct sockaddr) * local->spy_number))
-	    {
-	      err = -EFAULT;
-	      break;
-	    }
-
-	  /* Copy addresses to the lp structure */
-	  for(i = 0; i < local->spy_number; i++)
-	    memcpy(local->spy_address[i], address[i].sa_data, ETH_ALEN);
-
-	  /* Reset structure... */
-	  memset(local->spy_stat, 0x00, sizeof(iw_qual) * IW_MAX_SPY);
-
-#ifdef DEBUG_IOCTL_INFO
-	  printk(KERN_DEBUG "SetSpy - Set of new addresses is :\n");
-	  for(i = 0; i < local->spy_number; i++)
-	    printk(KERN_DEBUG "%02X:%02X:%02X:%02X:%02X:%02X\n",
-		   local->spy_address[i][0],
-		   local->spy_address[i][1],
-		   local->spy_address[i][2],
-		   local->spy_address[i][3],
-		   local->spy_address[i][4],
-		   local->spy_address[i][5]);
-#endif	/* DEBUG_IOCTL_INFO */
-	}
-      break;
+	if(local->sparm.b5.a_network_type)
+		*uwrq = IW_MODE_INFRA;
+	else
+		*uwrq = IW_MODE_ADHOC;
 
-      /* Get the spy list and spy stats */
-    case SIOCGIWSPY:
-      /* Set the number of addresses */
-      wrq->u.data.length = local->spy_number;
+	return 0;
+}
 
-      /* If the user want to have the addresses back... */
-      if((local->spy_number > 0) && (wrq->u.data.pointer != (caddr_t) 0))
-	{
-	  int			i;
-
-	  /* Copy addresses from the lp structure */
-	  for(i = 0; i < local->spy_number; i++)
-	    {
-	      memcpy(address[i].sa_data, local->spy_address[i], ETH_ALEN);
-	      address[i].sa_family = ARPHRD_ETHER;
-	    }
-
-	  /* Copy addresses to the user buffer */
-	  if(copy_to_user(wrq->u.data.pointer, address,
-		       sizeof(struct sockaddr) * local->spy_number))
-	    {
-	      err = -EFAULT;
-	      break;
-	    }
-
-	  /* Copy stats to the user buffer (just after) */
-	  if(copy_to_user(wrq->u.data.pointer +
-		       (sizeof(struct sockaddr) * local->spy_number),
-		       local->spy_stat, sizeof(iw_qual) * local->spy_number))
-	    {
-	      err = -EFAULT;
-	      break;
-	    }
-
-	  /* Reset updated flags */
-	  for(i = 0; i < local->spy_number; i++)
-	    local->spy_stat[i].updated = 0x0;
-	}	/* if(pointer != NULL) */
-
-      break;
-#endif	/* WIRELESS_SPY */
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Handler : get range info
+ */
+static int ray_get_range(struct net_device *dev,
+			 struct iw_request_info *info,
+			 struct iw_point *dwrq,
+			 char *extra)
+{
+	struct iw_range *range = (struct iw_range *) extra;
+
+	memset((char *) range, 0, sizeof(struct iw_range));
+
+	/* Set the length (very important for backward compatibility) */
+	dwrq->length = sizeof(struct iw_range);
+
+	/* Set the Wireless Extension versions */
+	range->we_version_compiled = WIRELESS_EXT;
+	range->we_version_source = 9;
+
+	/* Set information in the range struct */
+	range->throughput = 1.1 * 1000 * 1000;	/* Put the right number here */
+	range->num_channels = hop_pattern_length[(int)country]; 
+	range->num_frequency = 0;
+	range->max_qual.qual = 0;
+	range->max_qual.level = 255;	/* What's the correct value ? */
+	range->max_qual.noise = 255;	/* Idem */
+	range->num_bitrates = 2;
+	range->bitrate[0] = 1000000;	/* 1 Mb/s */
+	range->bitrate[1] = 2000000;	/* 2 Mb/s */
+	return 0;
+}
 
-      /* ------------------ PRIVATE IOCTL ------------------ */
-#ifndef SIOCIWFIRSTPRIV
-#define SIOCIWFIRSTPRIV	SIOCDEVPRIVATE
-#endif /* SIOCIWFIRSTPRIV */
-#define SIOCSIPFRAMING	SIOCIWFIRSTPRIV		/* Set framing mode */
-#define SIOCGIPFRAMING	SIOCIWFIRSTPRIV + 1	/* Get framing mode */
-#define SIOCGIPCOUNTRY	SIOCIWFIRSTPRIV + 3	/* Get country code */
-    case SIOCSIPFRAMING:
-      if(!capable(CAP_NET_ADMIN))	/* For private IOCTLs, we need to check permissions */
-	{
-	  err = -EPERM;
-	  break;
-	}
-      translate = *(wrq->u.name);	/* Set framing mode */
-      break;
-    case SIOCGIPFRAMING:
-      *(wrq->u.name) = translate;
-      break;
-    case SIOCGIPCOUNTRY:
-      *(wrq->u.name) = country;
-      break;
-    case SIOCGIWPRIV:
-      /* Export our "private" intercace */
-      if(wrq->u.data.pointer != (caddr_t) 0)
-	{
-	  struct iw_priv_args	priv[] =
-	  {	/* cmd,		set_args,	get_args,	name */
-	    { SIOCSIPFRAMING, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1, 0, "set_framing" },
-	    { SIOCGIPFRAMING, 0, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1, "get_framing" },
-	    { SIOCGIPCOUNTRY, 0, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1, "get_country" },
-	  };
-	  /* Set the number of ioctl available */
-	  wrq->u.data.length = 3;
-	  /* Copy structure to the user buffer */
-	  if(copy_to_user(wrq->u.data.pointer, (u_char *) priv,
-		       sizeof(priv)))
-	    err = -EFAULT;
-	}
-      break;
-#endif	/* WIRELESS_EXT > 7 */
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Private Handler : set framing mode
+ */
+static int ray_set_framing(struct net_device *dev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu,
+			   char *extra)
+{
+	translate = *(extra);	/* Set framing mode */
 
+	return 0;
+}
 
-        default:
-            DEBUG(0,"ray_dev_ioctl cmd = 0x%x\n", cmd);
-            err = -EOPNOTSUPP;
-    }
-    return err;
-} /* end ray_dev_ioctl */
-/*===========================================================================*/
-#if WIRELESS_EXT > 7	/* If wireless extension exist in the kernel */
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Private Handler : get framing mode
+ */
+static int ray_get_framing(struct net_device *dev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu,
+			   char *extra)
+{
+	*(extra) = translate;
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Private Handler : get country
+ */
+static int ray_get_country(struct net_device *dev,
+			   struct iw_request_info *info,
+			   union iwreq_data *wrqu,
+			   char *extra)
+{
+	*(extra) = country;
+
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Commit handler : called after a bunch of SET operations
+ */
+static int ray_commit(struct net_device *dev,
+		      struct iw_request_info *info,	/* NULL */
+		      void *zwrq,			/* NULL */
+		      char *extra)			/* NULL */
+{
+	return 0;
+}
+
+/*------------------------------------------------------------------*/
+/*
+ * Stats handler : return Wireless Stats
+ */
 static iw_stats * ray_get_wireless_stats(struct net_device *	dev)
 {
   ray_dev_t *	local = (ray_dev_t *) dev->priv;
@@ -1642,13 +1624,13 @@ static iw_stats * ray_get_wireless_stats(struct net_device *	dev)
 
   local->wstats.status = local->card_status;
 #ifdef WIRELESS_SPY
-  if((local->spy_number > 0) && (local->sparm.b5.a_network_type == 0))
+  if((local->spy_data.spy_number > 0) && (local->sparm.b5.a_network_type == 0))
     {
       /* Get it from the first node in spy list */
-      local->wstats.qual.qual = local->spy_stat[0].qual;
-      local->wstats.qual.level = local->spy_stat[0].level;
-      local->wstats.qual.noise = local->spy_stat[0].noise;
-      local->wstats.qual.updated = local->spy_stat[0].updated;
+      local->wstats.qual.qual = local->spy_data.spy_stat[0].qual;
+      local->wstats.qual.level = local->spy_data.spy_stat[0].level;
+      local->wstats.qual.noise = local->spy_data.spy_stat[0].noise;
+      local->wstats.qual.updated = local->spy_data.spy_stat[0].updated;
     }
 #endif /* WIRELESS_SPY */
 
@@ -1659,7 +1641,65 @@ static iw_stats * ray_get_wireless_stats(struct net_device *	dev)
 
   return &local->wstats;
 } /* end ray_get_wireless_stats */
-#endif	/* WIRELESS_EXT > 7 */
+
+/*------------------------------------------------------------------*/
+/*
+ * Structures to export the Wireless Handlers
+ */
+
+static const iw_handler	ray_handler[] = {
+	[SIOCSIWCOMMIT-SIOCIWFIRST] (iw_handler) ray_commit,
+	[SIOCGIWNAME  -SIOCIWFIRST] (iw_handler) ray_get_name,
+	[SIOCSIWFREQ  -SIOCIWFIRST] (iw_handler) ray_set_freq,
+	[SIOCGIWFREQ  -SIOCIWFIRST] (iw_handler) ray_get_freq,
+	[SIOCSIWMODE  -SIOCIWFIRST] (iw_handler) ray_set_mode,
+	[SIOCGIWMODE  -SIOCIWFIRST] (iw_handler) ray_get_mode,
+	[SIOCGIWRANGE -SIOCIWFIRST] (iw_handler) ray_get_range,
+#ifdef WIRELESS_SPY
+ 	[SIOCSIWSPY   -SIOCIWFIRST] (iw_handler) iw_handler_set_spy,
+	[SIOCGIWSPY   -SIOCIWFIRST] (iw_handler) iw_handler_get_spy,
+	[SIOCSIWTHRSPY-SIOCIWFIRST] (iw_handler) iw_handler_set_thrspy,
+	[SIOCGIWTHRSPY-SIOCIWFIRST] (iw_handler) iw_handler_get_thrspy,
+#endif	/* WIRELESS_SPY */
+	[SIOCGIWAP    -SIOCIWFIRST] (iw_handler) ray_get_wap,
+	[SIOCSIWESSID -SIOCIWFIRST] (iw_handler) ray_set_essid,
+	[SIOCGIWESSID -SIOCIWFIRST] (iw_handler) ray_get_essid,
+	[SIOCSIWRATE  -SIOCIWFIRST] (iw_handler) ray_set_rate,
+	[SIOCGIWRATE  -SIOCIWFIRST] (iw_handler) ray_get_rate,
+	[SIOCSIWRTS   -SIOCIWFIRST] (iw_handler) ray_set_rts,
+	[SIOCGIWRTS   -SIOCIWFIRST] (iw_handler) ray_get_rts,
+	[SIOCSIWFRAG  -SIOCIWFIRST] (iw_handler) ray_set_frag,
+	[SIOCGIWFRAG  -SIOCIWFIRST] (iw_handler) ray_get_frag,
+};
+
+#define SIOCSIPFRAMING	SIOCIWFIRSTPRIV		/* Set framing mode */
+#define SIOCGIPFRAMING	SIOCIWFIRSTPRIV + 1	/* Get framing mode */
+#define SIOCGIPCOUNTRY	SIOCIWFIRSTPRIV + 3	/* Get country code */
+
+static const iw_handler	ray_private_handler[] = {
+	[0] (iw_handler) ray_set_framing,
+	[1] (iw_handler) ray_get_framing,
+	[3] (iw_handler) ray_get_country,
+};
+
+static const struct iw_priv_args	ray_private_args[] = {
+/* cmd,		set_args,	get_args,	name */
+{ SIOCSIPFRAMING, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1, 0, "set_framing" },
+{ SIOCGIPFRAMING, 0, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1, "get_framing" },
+{ SIOCGIPCOUNTRY, 0, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1, "get_country" },
+};
+
+static const struct iw_handler_def	ray_handler_def =
+{
+	.num_standard	= sizeof(ray_handler)/sizeof(iw_handler),
+	.num_private	= sizeof(ray_private_handler)/sizeof(iw_handler),
+	.num_private_args = sizeof(ray_private_args)/sizeof(struct iw_priv_args),
+	.standard	= ray_handler,
+	.private	= ray_private_handler,
+	.private_args	= ray_private_args,
+	.get_wireless_stats = ray_get_wireless_stats,
+};
+
 /*===========================================================================*/
 static int ray_open(struct net_device *dev)
 {
@@ -2392,20 +2432,15 @@ static void rx_data(struct net_device *dev, struct rcs __iomem *prcs, unsigned i
 	/*local->wstats.qual.noise = none ? */
 	local->wstats.qual.updated = 0x2;
       }
-    /* Now, for the addresses in the spy list */
+    /* Now, update the spy stuff */
     {
-      int	i;
-      /* Look all addresses */
-      for(i = 0; i < local->spy_number; i++)
-	/* If match */
-	if(!memcmp(linksrcaddr, local->spy_address[i], ETH_ALEN))
-	  {
-	    /* Update statistics */
-	    /*local->spy_stat[i].qual = none ? */
-	    local->spy_stat[i].level = siglev;
-	    /*local->spy_stat[i].noise = none ? */
-	    local->spy_stat[i].updated = 0x2;
-	  }
+	struct iw_quality wstats;
+	wstats.level = siglev;
+	/* wstats.noise = none ? */
+	/* wstats.qual = none ? */
+	wstats.updated = 0x2;
+	/* Update spy records */
+	wireless_spy_update(dev, linksrcaddr, &wstats);
     }
 #endif	/* WIRELESS_SPY */
 } /* end rx_data */

commit 44670d2b50efd2443c3810239d6ea3fd02f8ef64
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Jul 7 17:59:05 2005 -0700

    [PATCH] pcmcia: remove references to pcmcia/version.h
    
    As a follow-up, remove the inclusion of pcmcia/version.h in many files.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 0643b1b94a39..0e0ba614259a 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -46,7 +46,6 @@
 #include <linux/skbuff.h>
 #include <linux/ethtool.h>
 
-#include <pcmcia/version.h>
 #include <pcmcia/cs_types.h>
 #include <pcmcia/cs.h>
 #include <pcmcia/cistpl.h>

commit 1e212f3645a6b355de8c43a23376bc0e2ac49a63
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Jul 7 17:59:00 2005 -0700

    [PATCH] pcmcia: move event handler
    
    Move the "event handler" to struct pcmcia_driver -- the unified event handler
    will disappear really soon, but switching it to struct pcmcia_driver in the
    meantime allows for better "step-by-step" patches.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 31652af52eac..0643b1b94a39 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -393,11 +393,6 @@ static dev_link_t *ray_attach(void)
     link->next = dev_list;
     dev_list = link;
     client_reg.dev_info = &dev_info;
-    client_reg.EventMask =
-        CS_EVENT_CARD_INSERTION | CS_EVENT_CARD_REMOVAL |
-        CS_EVENT_RESET_PHYSICAL | CS_EVENT_CARD_RESET |
-        CS_EVENT_PM_SUSPEND | CS_EVENT_PM_RESUME;
-    client_reg.event_handler = &ray_event;
     client_reg.Version = 0x0210;
     client_reg.event_callback_args.client_data = link;
 
@@ -2916,6 +2911,7 @@ static struct pcmcia_driver ray_driver = {
 		.name	= "ray_cs",
 	},
 	.attach		= ray_attach,
+	.event		= ray_event,
 	.detach		= ray_detach,
 	.id_table       = ray_ids,
 };

commit f57ea2a23245ba6db68f6a84ae903b3901965ade
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Mon Jun 27 16:28:24 2005 -0700

    [PATCH] pcmcia: id_table for ray_cs
    
    Add pcmcia_device_id table.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
index 6e5bda56b8f8..31652af52eac 100644
--- a/drivers/net/wireless/ray_cs.c
+++ b/drivers/net/wireless/ray_cs.c
@@ -2904,6 +2904,12 @@ static int write_int(struct file *file, const char __user *buffer, unsigned long
 }
 #endif
 
+static struct pcmcia_device_id ray_ids[] = {
+	PCMCIA_DEVICE_MANF_CARD(0x01a6, 0x0000),
+	PCMCIA_DEVICE_NULL,
+};
+MODULE_DEVICE_TABLE(pcmcia, ray_ids);
+
 static struct pcmcia_driver ray_driver = {
 	.owner		= THIS_MODULE,
 	.drv		= {
@@ -2911,6 +2917,7 @@ static struct pcmcia_driver ray_driver = {
 	},
 	.attach		= ray_attach,
 	.detach		= ray_detach,
+	.id_table       = ray_ids,
 };
 
 static int __init init_ray_cs(void)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c
new file mode 100644
index 000000000000..6e5bda56b8f8
--- /dev/null
+++ b/drivers/net/wireless/ray_cs.c
@@ -0,0 +1,2957 @@
+/*=============================================================================
+ *
+ * A  PCMCIA client driver for the Raylink wireless LAN card.
+ * The starting point for this module was the skeleton.c in the
+ * PCMCIA 2.9.12 package written by David Hinds, dahinds@users.sourceforge.net
+ *
+ *
+ * Copyright (c) 1998  Corey Thomas (corey@world.std.com)
+ *
+ * This driver is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 only of the GNU General Public License as 
+ * published by the Free Software Foundation.
+ *
+ * It is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Changes:
+ * Arnaldo Carvalho de Melo <acme@conectiva.com.br> - 08/08/2000
+ * - reorganize kmallocs in ray_attach, checking all for failure
+ *   and releasing the previous allocations if one fails
+ *
+ * Daniele Bellucci <bellucda@tiscali.it> - 07/10/2003
+ * - Audit copy_to_user in ioctl(SIOCGIWESSID)
+ * 
+=============================================================================*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/if_arp.h>
+#include <linux/ioport.h>
+#include <linux/skbuff.h>
+#include <linux/ethtool.h>
+
+#include <pcmcia/version.h>
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/cisreg.h>
+#include <pcmcia/ds.h>
+#include <pcmcia/mem_op.h>
+
+#include <linux/wireless.h>
+
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/byteorder.h>
+#include <asm/uaccess.h>
+
+/* Warning : these stuff will slow down the driver... */
+#define WIRELESS_SPY		/* Enable spying addresses */
+/* Definitions we need for spy */
+typedef struct iw_statistics	iw_stats;
+typedef struct iw_quality	iw_qual;
+typedef u_char	mac_addr[ETH_ALEN];	/* Hardware address */
+
+#include "rayctl.h"
+#include "ray_cs.h"
+
+/* All the PCMCIA modules use PCMCIA_DEBUG to control debugging.  If
+   you do not define PCMCIA_DEBUG at all, all the debug code will be
+   left out.  If you compile with PCMCIA_DEBUG=0, the debug code will
+   be present but disabled -- but it can then be enabled for specific
+   modules at load time with a 'pc_debug=#' option to insmod.
+*/
+
+#ifdef RAYLINK_DEBUG
+#define PCMCIA_DEBUG RAYLINK_DEBUG
+#endif
+#ifdef PCMCIA_DEBUG
+static int ray_debug;
+static int pc_debug = PCMCIA_DEBUG;
+module_param(pc_debug, int, 0);
+/* #define DEBUG(n, args...) if (pc_debug>(n)) printk(KERN_DEBUG args); */
+#define DEBUG(n, args...) if (pc_debug>(n)) printk(args);
+#else
+#define DEBUG(n, args...)
+#endif
+/** Prototypes based on PCMCIA skeleton driver *******************************/
+static void ray_config(dev_link_t *link);
+static void ray_release(dev_link_t *link);
+static int ray_event(event_t event, int priority, event_callback_args_t *args);
+static dev_link_t *ray_attach(void);
+static void ray_detach(dev_link_t *);
+
+/***** Prototypes indicated by device structure ******************************/
+static int ray_dev_close(struct net_device *dev);
+static int ray_dev_config(struct net_device *dev, struct ifmap *map);
+static struct net_device_stats *ray_get_stats(struct net_device *dev);
+static int ray_dev_init(struct net_device *dev);
+static int ray_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
+
+static struct ethtool_ops netdev_ethtool_ops;
+
+static int ray_open(struct net_device *dev);
+static int ray_dev_start_xmit(struct sk_buff *skb, struct net_device *dev);
+static void set_multicast_list(struct net_device *dev);
+static void ray_update_multi_list(struct net_device *dev, int all);
+static int translate_frame(ray_dev_t *local, struct tx_msg __iomem *ptx,
+                unsigned char *data, int len);
+static void ray_build_header(ray_dev_t *local, struct tx_msg __iomem *ptx, UCHAR msg_type,
+                unsigned char *data);
+static void untranslate(ray_dev_t *local, struct sk_buff *skb, int len);
+#if WIRELESS_EXT > 7	/* If wireless extension exist in the kernel */
+static iw_stats * ray_get_wireless_stats(struct net_device *	dev);
+#endif	/* WIRELESS_EXT > 7 */
+
+/***** Prototypes for raylink functions **************************************/
+static int asc_to_int(char a);
+static void authenticate(ray_dev_t *local);
+static int build_auth_frame(ray_dev_t *local, UCHAR *dest, int auth_type);
+static void authenticate_timeout(u_long);
+static int get_free_ccs(ray_dev_t *local);
+static int get_free_tx_ccs(ray_dev_t *local);
+static void init_startup_params(ray_dev_t *local);
+static int parse_addr(char *in_str, UCHAR *out);
+static int ray_hw_xmit(unsigned char* data, int len, struct net_device* dev, UCHAR type);
+static int ray_init(struct net_device *dev);
+static int interrupt_ecf(ray_dev_t *local, int ccs);
+static void ray_reset(struct net_device *dev);
+static void ray_update_parm(struct net_device *dev, UCHAR objid, UCHAR *value, int len);
+static void verify_dl_startup(u_long);
+
+/* Prototypes for interrpt time functions **********************************/
+static irqreturn_t ray_interrupt (int reg, void *dev_id, struct pt_regs *regs);
+static void clear_interrupt(ray_dev_t *local);
+static void rx_deauthenticate(ray_dev_t *local, struct rcs __iomem *prcs, 
+                       unsigned int pkt_addr, int rx_len);
+static int copy_from_rx_buff(ray_dev_t *local, UCHAR *dest, int pkt_addr, int len);
+static void ray_rx(struct net_device *dev, ray_dev_t *local, struct rcs __iomem *prcs);
+static void release_frag_chain(ray_dev_t *local, struct rcs __iomem *prcs);
+static void rx_authenticate(ray_dev_t *local, struct rcs __iomem *prcs,
+                     unsigned int pkt_addr, int rx_len);
+static void rx_data(struct net_device *dev, struct rcs __iomem *prcs, unsigned int pkt_addr, 
+             int rx_len);
+static void associate(ray_dev_t *local);
+
+/* Card command functions */
+static int dl_startup_params(struct net_device *dev);
+static void join_net(u_long local);
+static void start_net(u_long local);
+/* void start_net(ray_dev_t *local); */
+
+/*===========================================================================*/
+/* Parameters that can be set with 'insmod' */
+
+/* ADHOC=0, Infrastructure=1 */
+static int net_type = ADHOC;
+
+/* Hop dwell time in Kus (1024 us units defined by 802.11) */
+static int hop_dwell = 128;
+
+/* Beacon period in Kus */
+static int beacon_period = 256;
+
+/* power save mode (0 = off, 1 = save power) */
+static int psm;
+
+/* String for network's Extended Service Set ID. 32 Characters max */
+static char *essid;
+
+/* Default to encapsulation unless translation requested */
+static int translate = 1;
+
+static int country = USA;
+
+static int sniffer;
+
+static int bc;
+
+/* 48 bit physical card address if overriding card's real physical
+ * address is required.  Since IEEE 802.11 addresses are 48 bits
+ * like ethernet, an int can't be used, so a string is used. To
+ * allow use of addresses starting with a decimal digit, the first
+ * character must be a letter and will be ignored. This letter is
+ * followed by up to 12 hex digits which are the address.  If less
+ * than 12 digits are used, the address will be left filled with 0's.
+ * Note that bit 0 of the first byte is the broadcast bit, and evil
+ * things will happen if it is not 0 in a card address.
+ */
+static char *phy_addr = NULL;
+
+
+/* The dev_info variable is the "key" that is used to match up this
+   device driver with appropriate cards, through the card configuration
+   database.
+*/
+static dev_info_t dev_info = "ray_cs";
+
+/* A linked list of "instances" of the ray device.  Each actual
+   PCMCIA card corresponds to one device instance, and is described
+   by one dev_link_t structure (defined in ds.h).
+*/
+static dev_link_t *dev_list = NULL;
+
+/* A dev_link_t structure has fields for most things that are needed
+   to keep track of a socket, but there will usually be some device
+   specific information that also needs to be kept track of.  The
+   'priv' pointer in a dev_link_t structure can be used to point to
+   a device-specific private data structure, like this.
+*/
+static unsigned int ray_mem_speed = 500;
+
+MODULE_AUTHOR("Corey Thomas <corey@world.std.com>");
+MODULE_DESCRIPTION("Raylink/WebGear wireless LAN driver");
+MODULE_LICENSE("GPL");
+
+module_param(net_type, int, 0);
+module_param(hop_dwell, int, 0);
+module_param(beacon_period, int, 0);
+module_param(psm, int, 0);
+module_param(essid, charp, 0);
+module_param(translate, int, 0);
+module_param(country, int, 0);
+module_param(sniffer, int, 0);
+module_param(bc, int, 0);
+module_param(phy_addr, charp, 0);
+module_param(ray_mem_speed, int, 0);
+
+static UCHAR b5_default_startup_parms[] = {
+    0,   0,                         /* Adhoc station */
+   'L','I','N','U','X', 0,  0,  0,  /* 32 char ESSID */
+    0,  0,  0,  0,  0,  0,  0,  0,
+    0,  0,  0,  0,  0,  0,  0,  0,
+    0,  0,  0,  0,  0,  0,  0,  0,
+    1,  0,                          /* Active scan, CA Mode */
+    0,  0,  0,  0,  0,  0,          /* No default MAC addr  */
+    0x7f, 0xff,                     /* Frag threshold */
+    0x00, 0x80,                     /* Hop time 128 Kus*/
+    0x01, 0x00,                     /* Beacon period 256 Kus */
+    0x01, 0x07, 0xa3,               /* DTIM, retries, ack timeout*/
+    0x1d, 0x82, 0x4e,               /* SIFS, DIFS, PIFS */
+    0x7f, 0xff,                     /* RTS threshold */
+    0x04, 0xe2, 0x38, 0xA4,         /* scan_dwell, max_scan_dwell */
+    0x05,                           /* assoc resp timeout thresh */
+    0x08, 0x02, 0x08,               /* adhoc, infra, super cycle max*/
+    0,                              /* Promiscuous mode */
+    0x0c, 0x0bd,                    /* Unique word */
+    0x32,                           /* Slot time */
+    0xff, 0xff,                     /* roam-low snr, low snr count */
+    0x05, 0xff,                     /* Infra, adhoc missed bcn thresh */
+    0x01, 0x0b, 0x4f,               /* USA, hop pattern, hop pat length */
+/* b4 - b5 differences start here */
+    0x00, 0x3f,                     /* CW max */
+    0x00, 0x0f,                     /* CW min */
+    0x04, 0x08,                     /* Noise gain, limit offset */
+    0x28, 0x28,                     /* det rssi, med busy offsets */
+    7,                              /* det sync thresh */
+    0, 2, 2,                        /* test mode, min, max */
+    0,                              /* allow broadcast SSID probe resp */
+    0, 0,                           /* privacy must start, can join */
+    2, 0, 0, 0, 0, 0, 0, 0          /* basic rate set */
+};
+
+static UCHAR b4_default_startup_parms[] = {
+    0,   0,                         /* Adhoc station */
+   'L','I','N','U','X', 0,  0,  0,  /* 32 char ESSID */
+    0,  0,  0,  0,  0,  0,  0,  0,
+    0,  0,  0,  0,  0,  0,  0,  0,
+    0,  0,  0,  0,  0,  0,  0,  0,
+    1,  0,                          /* Active scan, CA Mode */
+    0,  0,  0,  0,  0,  0,          /* No default MAC addr  */
+    0x7f, 0xff,                     /* Frag threshold */
+    0x02, 0x00,                     /* Hop time */
+    0x00, 0x01,                     /* Beacon period */
+    0x01, 0x07, 0xa3,               /* DTIM, retries, ack timeout*/
+    0x1d, 0x82, 0xce,               /* SIFS, DIFS, PIFS */
+    0x7f, 0xff,                     /* RTS threshold */
+    0xfb, 0x1e, 0xc7, 0x5c,         /* scan_dwell, max_scan_dwell */
+    0x05,                           /* assoc resp timeout thresh */
+    0x04, 0x02, 0x4,                /* adhoc, infra, super cycle max*/
+    0,                              /* Promiscuous mode */
+    0x0c, 0x0bd,                    /* Unique word */
+    0x4e,                           /* Slot time (TBD seems wrong)*/
+    0xff, 0xff,                     /* roam-low snr, low snr count */
+    0x05, 0xff,                     /* Infra, adhoc missed bcn thresh */
+    0x01, 0x0b, 0x4e,               /* USA, hop pattern, hop pat length */
+/* b4 - b5 differences start here */
+    0x3f, 0x0f,                     /* CW max, min */
+    0x04, 0x08,                     /* Noise gain, limit offset */
+    0x28, 0x28,                     /* det rssi, med busy offsets */
+    7,                              /* det sync thresh */
+    0, 2, 2                         /* test mode, min, max*/
+};
+/*===========================================================================*/
+static unsigned char eth2_llc[] = {0xaa, 0xaa, 3, 0, 0, 0};
+
+static char hop_pattern_length[] = { 1,
+	     USA_HOP_MOD,             EUROPE_HOP_MOD,
+	     JAPAN_HOP_MOD,           KOREA_HOP_MOD,
+	     SPAIN_HOP_MOD,           FRANCE_HOP_MOD,
+	     ISRAEL_HOP_MOD,          AUSTRALIA_HOP_MOD,
+	     JAPAN_TEST_HOP_MOD
+};
+
+static char rcsid[] = "Raylink/WebGear wireless LAN - Corey <Thomas corey@world.std.com>";
+
+/*=============================================================================
+    ray_attach() creates an "instance" of the driver, allocating
+    local data structures for one device.  The device is registered
+    with Card Services.
+    The dev_link structure is initialized, but we don't actually
+    configure the card at this point -- we wait until we receive a
+    card insertion event.
+=============================================================================*/
+static dev_link_t *ray_attach(void)
+{
+    client_reg_t client_reg;
+    dev_link_t *link;
+    ray_dev_t *local;
+    int ret;
+    struct net_device *dev;
+    
+    DEBUG(1, "ray_attach()\n");
+
+    /* Initialize the dev_link_t structure */
+    link = kmalloc(sizeof(struct dev_link_t), GFP_KERNEL);
+
+    if (!link)
+	    return NULL;
+
+    /* Allocate space for private device-specific data */
+    dev = alloc_etherdev(sizeof(ray_dev_t));
+
+    if (!dev)
+	    goto fail_alloc_dev;
+
+    local = dev->priv;
+
+    memset(link, 0, sizeof(struct dev_link_t));
+
+    /* The io structure describes IO port mapping. None used here */
+    link->io.NumPorts1 = 0;
+    link->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
+    link->io.IOAddrLines = 5;
+
+    /* Interrupt setup. For PCMCIA, driver takes what's given */
+    link->irq.Attributes = IRQ_TYPE_EXCLUSIVE | IRQ_HANDLE_PRESENT;
+    link->irq.IRQInfo1 = IRQ_LEVEL_ID;
+    link->irq.Handler = &ray_interrupt;
+
+    /* General socket configuration */
+    link->conf.Attributes = CONF_ENABLE_IRQ;
+    link->conf.Vcc = 50;
+    link->conf.IntType = INT_MEMORY_AND_IO;
+    link->conf.ConfigIndex = 1;
+    link->conf.Present = PRESENT_OPTION;
+
+    link->priv = dev;
+    link->irq.Instance = dev;
+    
+    local->finder = link;
+    local->card_status = CARD_INSERTED;
+    local->authentication_state = UNAUTHENTICATED;
+    local->num_multi = 0;
+    DEBUG(2,"ray_attach link = %p,  dev = %p,  local = %p, intr = %p\n",
+          link,dev,local,&ray_interrupt);
+
+    /* Raylink entries in the device structure */
+    dev->hard_start_xmit = &ray_dev_start_xmit;
+    dev->set_config = &ray_dev_config;
+    dev->get_stats  = &ray_get_stats;
+    dev->do_ioctl = &ray_dev_ioctl;
+    SET_ETHTOOL_OPS(dev, &netdev_ethtool_ops);
+#if WIRELESS_EXT > 7	/* If wireless extension exist in the kernel */
+    dev->get_wireless_stats = ray_get_wireless_stats;
+#endif
+
+    dev->set_multicast_list = &set_multicast_list;
+
+    DEBUG(2,"ray_cs ray_attach calling ether_setup.)\n");
+    SET_MODULE_OWNER(dev);
+    dev->init = &ray_dev_init;
+    dev->open = &ray_open;
+    dev->stop = &ray_dev_close;
+    netif_stop_queue(dev);
+
+    /* Register with Card Services */
+    link->next = dev_list;
+    dev_list = link;
+    client_reg.dev_info = &dev_info;
+    client_reg.EventMask =
+        CS_EVENT_CARD_INSERTION | CS_EVENT_CARD_REMOVAL |
+        CS_EVENT_RESET_PHYSICAL | CS_EVENT_CARD_RESET |
+        CS_EVENT_PM_SUSPEND | CS_EVENT_PM_RESUME;
+    client_reg.event_handler = &ray_event;
+    client_reg.Version = 0x0210;
+    client_reg.event_callback_args.client_data = link;
+
+    DEBUG(2,"ray_cs ray_attach calling pcmcia_register_client(...)\n");
+
+    init_timer(&local->timer);
+
+    ret = pcmcia_register_client(&link->handle, &client_reg);
+    if (ret != 0) {
+        printk("ray_cs ray_attach RegisterClient unhappy - detaching\n");
+        cs_error(link->handle, RegisterClient, ret);
+        ray_detach(link);
+        return NULL;
+    }
+    DEBUG(2,"ray_cs ray_attach ending\n");
+    return link;
+
+fail_alloc_dev:
+    kfree(link);
+    return NULL;
+} /* ray_attach */
+/*=============================================================================
+    This deletes a driver "instance".  The device is de-registered
+    with Card Services.  If it has been released, all local data
+    structures are freed.  Otherwise, the structures will be freed
+    when the device is released.
+=============================================================================*/
+static void ray_detach(dev_link_t *link)
+{
+    dev_link_t **linkp;
+
+    DEBUG(1, "ray_detach(0x%p)\n", link);
+    
+    /* Locate device structure */
+    for (linkp = &dev_list; *linkp; linkp = &(*linkp)->next)
+        if (*linkp == link) break;
+    if (*linkp == NULL)
+        return;
+
+    /* If the device is currently configured and active, we won't
+      actually delete it yet.  Instead, it is marked so that when
+      the release() function is called, that will trigger a proper
+      detach().
+    */
+    if (link->state & DEV_CONFIG)
+        ray_release(link);
+
+    /* Break the link with Card Services */
+    if (link->handle)
+        pcmcia_deregister_client(link->handle);
+    
+    /* Unlink device structure, free pieces */
+    *linkp = link->next;
+    if (link->priv) {
+        struct net_device *dev = link->priv;
+	if (link->dev) unregister_netdev(dev);
+        free_netdev(dev);
+    }
+    kfree(link);
+    DEBUG(2,"ray_cs ray_detach ending\n");
+} /* ray_detach */
+/*=============================================================================
+    ray_config() is run after a CARD_INSERTION event
+    is received, to configure the PCMCIA socket, and to make the
+    ethernet device available to the system.
+=============================================================================*/
+#define CS_CHECK(fn, ret) \
+do { last_fn = (fn); if ((last_ret = (ret)) != 0) goto cs_failed; } while (0)
+#define MAX_TUPLE_SIZE 128
+static void ray_config(dev_link_t *link)
+{
+    client_handle_t handle = link->handle;
+    tuple_t tuple;
+    cisparse_t parse;
+    int last_fn = 0, last_ret = 0;
+    int i;
+    u_char buf[MAX_TUPLE_SIZE];
+    win_req_t req;
+    memreq_t mem;
+    struct net_device *dev = (struct net_device *)link->priv;
+    ray_dev_t *local = (ray_dev_t *)dev->priv;
+
+    DEBUG(1, "ray_config(0x%p)\n", link);
+
+    /* This reads the card's CONFIG tuple to find its configuration regs */
+    tuple.DesiredTuple = CISTPL_CONFIG;
+    CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(handle, &tuple));
+    tuple.TupleData = buf;
+    tuple.TupleDataMax = MAX_TUPLE_SIZE;
+    tuple.TupleOffset = 0;
+    CS_CHECK(GetTupleData, pcmcia_get_tuple_data(handle, &tuple));
+    CS_CHECK(ParseTuple, pcmcia_parse_tuple(handle, &tuple, &parse));
+    link->conf.ConfigBase = parse.config.base;
+    link->conf.Present = parse.config.rmask[0];
+
+    /* Determine card type and firmware version */
+    buf[0] = buf[MAX_TUPLE_SIZE - 1] = 0;
+    tuple.DesiredTuple = CISTPL_VERS_1;
+    CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(handle, &tuple));
+    tuple.TupleData = buf;
+    tuple.TupleDataMax = MAX_TUPLE_SIZE;
+    tuple.TupleOffset = 2;
+    CS_CHECK(GetTupleData, pcmcia_get_tuple_data(handle, &tuple));
+
+    for (i=0; i<tuple.TupleDataLen - 4; i++) 
+        if (buf[i] == 0) buf[i] = ' ';
+    printk(KERN_INFO "ray_cs Detected: %s\n",buf);
+
+    /* Configure card */
+    link->state |= DEV_CONFIG;
+
+    /* Now allocate an interrupt line.  Note that this does not
+       actually assign a handler to the interrupt.
+    */
+    CS_CHECK(RequestIRQ, pcmcia_request_irq(link->handle, &link->irq));
+    dev->irq = link->irq.AssignedIRQ;
+    
+    /* This actually configures the PCMCIA socket -- setting up
+       the I/O windows and the interrupt mapping.
+    */
+    CS_CHECK(RequestConfiguration, pcmcia_request_configuration(link->handle, &link->conf));
+
+/*** Set up 32k window for shared memory (transmit and control) ************/
+    req.Attributes = WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_CM | WIN_ENABLE | WIN_USE_WAIT;
+    req.Base = 0;
+    req.Size = 0x8000;
+    req.AccessSpeed = ray_mem_speed;
+    CS_CHECK(RequestWindow, pcmcia_request_window(&link->handle, &req, &link->win));
+    mem.CardOffset = 0x0000; mem.Page = 0;
+    CS_CHECK(MapMemPage, pcmcia_map_mem_page(link->win, &mem));
+    local->sram = ioremap(req.Base,req.Size);
+
+/*** Set up 16k window for shared memory (receive buffer) ***************/
+    req.Attributes = WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_CM | WIN_ENABLE | WIN_USE_WAIT;
+    req.Base = 0;
+    req.Size = 0x4000;
+    req.AccessSpeed = ray_mem_speed;
+    CS_CHECK(RequestWindow, pcmcia_request_window(&link->handle, &req, &local->rmem_handle));
+    mem.CardOffset = 0x8000; mem.Page = 0;
+    CS_CHECK(MapMemPage, pcmcia_map_mem_page(local->rmem_handle, &mem));
+    local->rmem = ioremap(req.Base,req.Size);
+
+/*** Set up window for attribute memory ***********************************/
+    req.Attributes = WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_AM | WIN_ENABLE | WIN_USE_WAIT;
+    req.Base = 0;
+    req.Size = 0x1000;
+    req.AccessSpeed = ray_mem_speed;
+    CS_CHECK(RequestWindow, pcmcia_request_window(&link->handle, &req, &local->amem_handle));
+    mem.CardOffset = 0x0000; mem.Page = 0;
+    CS_CHECK(MapMemPage, pcmcia_map_mem_page(local->amem_handle, &mem));
+    local->amem = ioremap(req.Base,req.Size);
+
+    DEBUG(3,"ray_config sram=%p\n",local->sram);
+    DEBUG(3,"ray_config rmem=%p\n",local->rmem);
+    DEBUG(3,"ray_config amem=%p\n",local->amem);
+    if (ray_init(dev) < 0) {
+        ray_release(link);
+        return;
+    }
+
+    SET_NETDEV_DEV(dev, &handle_to_dev(handle));
+    i = register_netdev(dev);
+    if (i != 0) {
+        printk("ray_config register_netdev() failed\n");
+        ray_release(link);
+        return;
+    }
+
+    strcpy(local->node.dev_name, dev->name);
+    link->dev = &local->node;
+
+    link->state &= ~DEV_CONFIG_PENDING;
+    printk(KERN_INFO "%s: RayLink, irq %d, hw_addr ",
+       dev->name, dev->irq);
+    for (i = 0; i < 6; i++)
+    printk("%02X%s", dev->dev_addr[i], ((i<5) ? ":" : "\n"));
+
+    return;
+
+cs_failed:
+    cs_error(link->handle, last_fn, last_ret);
+
+    ray_release(link);
+} /* ray_config */
+
+static inline struct ccs __iomem *ccs_base(ray_dev_t *dev)
+{
+	return dev->sram + CCS_BASE;
+}
+
+static inline struct rcs __iomem *rcs_base(ray_dev_t *dev)
+{
+	/*
+	 * This looks nonsensical, since there is a separate
+	 * RCS_BASE. But the difference between a "struct rcs"
+	 * and a "struct ccs" ends up being in the _index_ off
+	 * the base, so the base pointer is the same for both
+	 * ccs/rcs.
+	 */
+	return dev->sram + CCS_BASE;
+}
+
+/*===========================================================================*/
+static int ray_init(struct net_device *dev)
+{
+    int i;
+    UCHAR *p;
+    struct ccs __iomem *pccs;
+    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    dev_link_t *link = local->finder;
+    DEBUG(1, "ray_init(0x%p)\n", dev);
+    if (!(link->state & DEV_PRESENT)) {
+        DEBUG(0,"ray_init - device not present\n");
+        return -1;
+    }
+
+    local->net_type = net_type;
+    local->sta_type = TYPE_STA;
+
+    /* Copy the startup results to local memory */
+    memcpy_fromio(&local->startup_res, local->sram + ECF_TO_HOST_BASE,\
+           sizeof(struct startup_res_6));
+
+    /* Check Power up test status and get mac address from card */
+    if (local->startup_res.startup_word != 0x80) {
+    printk(KERN_INFO "ray_init ERROR card status = %2x\n",
+           local->startup_res.startup_word);
+        local->card_status = CARD_INIT_ERROR;
+        return -1;
+    }
+
+    local->fw_ver = local->startup_res.firmware_version[0];
+    local->fw_bld = local->startup_res.firmware_version[1];
+    local->fw_var = local->startup_res.firmware_version[2];
+    DEBUG(1,"ray_init firmware version %d.%d \n",local->fw_ver, local->fw_bld);
+
+    local->tib_length = 0x20;
+    if ((local->fw_ver == 5) && (local->fw_bld >= 30))
+        local->tib_length = local->startup_res.tib_length;
+    DEBUG(2,"ray_init tib_length = 0x%02x\n", local->tib_length);
+    /* Initialize CCS's to buffer free state */
+    pccs = ccs_base(local);
+    for (i=0;  i<NUMBER_OF_CCS;  i++) {
+        writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
+    }
+    init_startup_params(local);
+
+    /* copy mac address to startup parameters */
+    if (parse_addr(phy_addr, local->sparm.b4.a_mac_addr))
+    {
+        p = local->sparm.b4.a_mac_addr;
+    }
+    else
+    {
+        memcpy(&local->sparm.b4.a_mac_addr,
+               &local->startup_res.station_addr, ADDRLEN);
+        p = local->sparm.b4.a_mac_addr;
+    }
+
+    clear_interrupt(local); /* Clear any interrupt from the card */
+    local->card_status = CARD_AWAITING_PARAM;
+    DEBUG(2,"ray_init ending\n");
+    return 0;
+} /* ray_init */
+/*===========================================================================*/
+/* Download startup parameters to the card and command it to read them       */
+static int dl_startup_params(struct net_device *dev)
+{
+    int ccsindex;
+    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    struct ccs __iomem *pccs;
+    dev_link_t *link = local->finder;
+
+    DEBUG(1,"dl_startup_params entered\n");
+    if (!(link->state & DEV_PRESENT)) {
+        DEBUG(2,"ray_cs dl_startup_params - device not present\n");
+        return -1;
+    }
+    
+    /* Copy parameters to host to ECF area */
+    if (local->fw_ver == 0x55) 
+        memcpy_toio(local->sram + HOST_TO_ECF_BASE, &local->sparm.b4,
+               sizeof(struct b4_startup_params));
+    else
+        memcpy_toio(local->sram + HOST_TO_ECF_BASE, &local->sparm.b5,
+               sizeof(struct b5_startup_params));
+
+    
+    /* Fill in the CCS fields for the ECF */
+    if ((ccsindex = get_free_ccs(local)) < 0) return -1;
+    local->dl_param_ccs = ccsindex;
+    pccs = ccs_base(local) + ccsindex;
+    writeb(CCS_DOWNLOAD_STARTUP_PARAMS, &pccs->cmd);
+    DEBUG(2,"dl_startup_params start ccsindex = %d\n", local->dl_param_ccs);
+    /* Interrupt the firmware to process the command */
+    if (interrupt_ecf(local, ccsindex)) {
+        printk(KERN_INFO "ray dl_startup_params failed - "
+           "ECF not ready for intr\n");
+        local->card_status = CARD_DL_PARAM_ERROR;
+        writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
+        return -2;
+    }
+    local->card_status = CARD_DL_PARAM;
+    /* Start kernel timer to wait for dl startup to complete. */
+    local->timer.expires = jiffies + HZ/2;
+    local->timer.data = (long)local;
+    local->timer.function = &verify_dl_startup;
+    add_timer(&local->timer);
+    DEBUG(2,"ray_cs dl_startup_params started timer for verify_dl_startup\n");
+    return 0;
+} /* dl_startup_params */
+/*===========================================================================*/
+static void init_startup_params(ray_dev_t *local)
+{
+    int i; 
+
+    if (country > JAPAN_TEST) country = USA;
+    else
+        if (country < USA) country = USA;
+    /* structure for hop time and beacon period is defined here using 
+     * New 802.11D6.1 format.  Card firmware is still using old format
+     * until version 6.
+     *    Before                    After
+     *    a_hop_time ms byte        a_hop_time ms byte
+     *    a_hop_time 2s byte        a_hop_time ls byte
+     *    a_hop_time ls byte        a_beacon_period ms byte
+     *    a_beacon_period           a_beacon_period ls byte
+     *
+     *    a_hop_time = uS           a_hop_time = KuS
+     *    a_beacon_period = hops    a_beacon_period = KuS
+     */                             /* 64ms = 010000 */
+    if (local->fw_ver == 0x55)  {
+        memcpy((UCHAR *)&local->sparm.b4, b4_default_startup_parms, 
+               sizeof(struct b4_startup_params));
+        /* Translate sane kus input values to old build 4/5 format */
+        /* i = hop time in uS truncated to 3 bytes */
+        i = (hop_dwell * 1024) & 0xffffff;
+        local->sparm.b4.a_hop_time[0] = (i >> 16) & 0xff;
+        local->sparm.b4.a_hop_time[1] = (i >> 8) & 0xff;
+        local->sparm.b4.a_beacon_period[0] = 0;
+        local->sparm.b4.a_beacon_period[1] =
+            ((beacon_period/hop_dwell) - 1) & 0xff;
+        local->sparm.b4.a_curr_country_code = country;
+        local->sparm.b4.a_hop_pattern_length = 
+            hop_pattern_length[(int)country] - 1;
+        if (bc)
+        {
+            local->sparm.b4.a_ack_timeout = 0x50;
+            local->sparm.b4.a_sifs = 0x3f;
+        }
+    }
+    else {    /* Version 5 uses real kus values */
+        memcpy((UCHAR *)&local->sparm.b5, b5_default_startup_parms, 
+               sizeof(struct b5_startup_params));
+
+        local->sparm.b5.a_hop_time[0] = (hop_dwell >> 8) & 0xff;
+        local->sparm.b5.a_hop_time[1] = hop_dwell & 0xff;
+        local->sparm.b5.a_beacon_period[0] = (beacon_period >> 8) & 0xff;
+        local->sparm.b5.a_beacon_period[1] = beacon_period & 0xff;
+        if (psm)
+            local->sparm.b5.a_power_mgt_state = 1;
+        local->sparm.b5.a_curr_country_code = country;
+        local->sparm.b5.a_hop_pattern_length = 
+            hop_pattern_length[(int)country];
+    }
+    
+    local->sparm.b4.a_network_type = net_type & 0x01;
+    local->sparm.b4.a_acting_as_ap_status = TYPE_STA;
+
+    if (essid != NULL)
+        strncpy(local->sparm.b4.a_current_ess_id, essid, ESSID_SIZE);
+} /* init_startup_params */ 
+/*===========================================================================*/
+static void verify_dl_startup(u_long data)
+{
+    ray_dev_t *local = (ray_dev_t *)data;
+    struct ccs __iomem *pccs = ccs_base(local) + local->dl_param_ccs;
+    UCHAR status;
+    dev_link_t *link = local->finder;
+
+    if (!(link->state & DEV_PRESENT)) {
+        DEBUG(2,"ray_cs verify_dl_startup - device not present\n");
+        return;
+    }
+#ifdef PCMCIA_DEBUG
+    if (pc_debug > 2) {
+    int i;
+    printk(KERN_DEBUG "verify_dl_startup parameters sent via ccs %d:\n",
+           local->dl_param_ccs);
+        for (i=0; i<sizeof(struct b5_startup_params); i++) {
+            printk(" %2x", (unsigned int) readb(local->sram + HOST_TO_ECF_BASE + i));
+        }
+    printk("\n");
+    }
+#endif
+
+    status = readb(&pccs->buffer_status);
+    if (status!= CCS_BUFFER_FREE)
+    {
+        printk(KERN_INFO "Download startup params failed.  Status = %d\n",
+           status);
+        local->card_status = CARD_DL_PARAM_ERROR;
+        return;
+    }
+    if (local->sparm.b4.a_network_type == ADHOC)
+        start_net((u_long)local);
+    else
+        join_net((u_long)local);
+
+    return;
+} /* end verify_dl_startup */
+/*===========================================================================*/
+/* Command card to start a network */
+static void start_net(u_long data)
+{
+    ray_dev_t *local = (ray_dev_t *)data;
+    struct ccs __iomem *pccs;
+    int ccsindex;
+    dev_link_t *link = local->finder;
+    if (!(link->state & DEV_PRESENT)) {
+        DEBUG(2,"ray_cs start_net - device not present\n");
+        return;
+    }
+    /* Fill in the CCS fields for the ECF */
+    if ((ccsindex = get_free_ccs(local)) < 0) return;
+    pccs = ccs_base(local) + ccsindex;
+    writeb(CCS_START_NETWORK, &pccs->cmd);
+    writeb(0, &pccs->var.start_network.update_param);
+    /* Interrupt the firmware to process the command */
+    if (interrupt_ecf(local, ccsindex)) {
+        DEBUG(1,"ray start net failed - card not ready for intr\n");
+        writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
+        return;
+    }
+    local->card_status = CARD_DOING_ACQ;
+    return;
+} /* end start_net */
+/*===========================================================================*/
+/* Command card to join a network */
+static void join_net(u_long data)
+{
+    ray_dev_t *local = (ray_dev_t *)data;
+
+    struct ccs __iomem *pccs;
+    int ccsindex;
+    dev_link_t *link = local->finder;
+    
+    if (!(link->state & DEV_PRESENT)) {
+        DEBUG(2,"ray_cs join_net - device not present\n");
+        return;
+    }
+    /* Fill in the CCS fields for the ECF */
+    if ((ccsindex = get_free_ccs(local)) < 0) return;
+    pccs = ccs_base(local) + ccsindex;
+    writeb(CCS_JOIN_NETWORK, &pccs->cmd);
+    writeb(0, &pccs->var.join_network.update_param);
+    writeb(0, &pccs->var.join_network.net_initiated);
+    /* Interrupt the firmware to process the command */
+    if (interrupt_ecf(local, ccsindex)) {
+        DEBUG(1,"ray join net failed - card not ready for intr\n");
+        writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
+        return;
+    }
+    local->card_status = CARD_DOING_ACQ;
+    return;
+}
+/*============================================================================
+    After a card is removed, ray_release() will unregister the net
+    device, and release the PCMCIA configuration.  If the device is
+    still open, this will be postponed until it is closed.
+=============================================================================*/
+static void ray_release(dev_link_t *link)
+{
+    struct net_device *dev = link->priv; 
+    ray_dev_t *local = dev->priv;
+    int i;
+    
+    DEBUG(1, "ray_release(0x%p)\n", link);
+
+    del_timer(&local->timer);
+    link->state &= ~DEV_CONFIG;
+
+    iounmap(local->sram);
+    iounmap(local->rmem);
+    iounmap(local->amem);
+    /* Do bother checking to see if these succeed or not */
+    i = pcmcia_release_window(link->win);
+    if ( i != CS_SUCCESS ) DEBUG(0,"ReleaseWindow(link->win) ret = %x\n",i);
+    i = pcmcia_release_window(local->amem_handle);
+    if ( i != CS_SUCCESS ) DEBUG(0,"ReleaseWindow(local->amem) ret = %x\n",i);
+    i = pcmcia_release_window(local->rmem_handle);
+    if ( i != CS_SUCCESS ) DEBUG(0,"ReleaseWindow(local->rmem) ret = %x\n",i);
+    i = pcmcia_release_configuration(link->handle);
+    if ( i != CS_SUCCESS ) DEBUG(0,"ReleaseConfiguration ret = %x\n",i);
+    i = pcmcia_release_irq(link->handle, &link->irq);
+    if ( i != CS_SUCCESS ) DEBUG(0,"ReleaseIRQ ret = %x\n",i);
+
+    DEBUG(2,"ray_release ending\n");
+}
+
+/*=============================================================================
+    The card status event handler.  Mostly, this schedules other
+    stuff to run after an event is received.  A CARD_REMOVAL event
+    also sets some flags to discourage the net drivers from trying
+    to talk to the card any more.
+
+    When a CARD_REMOVAL event is received, we immediately set a flag
+    to block future accesses to this device.  All the functions that
+    actually access the device should check this flag to make sure
+    the card is still present.
+=============================================================================*/
+static int ray_event(event_t event, int priority,
+                     event_callback_args_t *args)
+{
+    dev_link_t *link = args->client_data;
+    struct net_device *dev = link->priv;
+    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    DEBUG(1, "ray_event(0x%06x)\n", event);
+    
+    switch (event) {
+    case CS_EVENT_CARD_REMOVAL:
+        link->state &= ~DEV_PRESENT;
+        netif_device_detach(dev);
+        if (link->state & DEV_CONFIG) {
+	    ray_release(link);
+            del_timer(&local->timer);
+        }
+        break;
+    case CS_EVENT_CARD_INSERTION:
+        link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
+        ray_config(link);
+        break;
+    case CS_EVENT_PM_SUSPEND:
+        link->state |= DEV_SUSPEND;
+        /* Fall through... */
+    case CS_EVENT_RESET_PHYSICAL:
+        if (link->state & DEV_CONFIG) {
+            if (link->open)
+            	netif_device_detach(dev);
+
+            pcmcia_release_configuration(link->handle);
+        }
+        break;
+    case CS_EVENT_PM_RESUME:
+        link->state &= ~DEV_SUSPEND;
+        /* Fall through... */
+    case CS_EVENT_CARD_RESET:
+        if (link->state & DEV_CONFIG) {
+            pcmcia_request_configuration(link->handle, &link->conf);
+            if (link->open) {
+                ray_reset(dev);
+		netif_device_attach(dev);
+            }
+        }
+        break;
+    }
+    return 0;
+    DEBUG(2,"ray_event ending\n");
+} /* ray_event */
+/*===========================================================================*/
+int ray_dev_init(struct net_device *dev)
+{
+#ifdef RAY_IMMEDIATE_INIT
+    int i;
+#endif	/* RAY_IMMEDIATE_INIT */
+    ray_dev_t *local = dev->priv;
+    dev_link_t *link = local->finder;
+
+    DEBUG(1,"ray_dev_init(dev=%p)\n",dev);
+    if (!(link->state & DEV_PRESENT)) {
+        DEBUG(2,"ray_dev_init - device not present\n");
+        return -1;
+    }
+#ifdef RAY_IMMEDIATE_INIT
+    /* Download startup parameters */
+    if ( (i = dl_startup_params(dev)) < 0)
+    {
+        printk(KERN_INFO "ray_dev_init dl_startup_params failed - "
+           "returns 0x%x\n",i);
+        return -1;
+    }
+#else	/* RAY_IMMEDIATE_INIT */
+    /* Postpone the card init so that we can still configure the card,
+     * for example using the Wireless Extensions. The init will happen
+     * in ray_open() - Jean II */
+    DEBUG(1,"ray_dev_init: postponing card init to ray_open() ; Status = %d\n",
+	  local->card_status);
+#endif	/* RAY_IMMEDIATE_INIT */
+
+    /* copy mac and broadcast addresses to linux device */
+    memcpy(&dev->dev_addr, &local->sparm.b4.a_mac_addr, ADDRLEN);
+    memset(dev->broadcast, 0xff, ETH_ALEN);
+
+    DEBUG(2,"ray_dev_init ending\n");
+    return 0;
+}
+/*===========================================================================*/
+static int ray_dev_config(struct net_device *dev, struct ifmap *map)
+{
+    ray_dev_t *local = dev->priv;
+    dev_link_t *link = local->finder;
+    /* Dummy routine to satisfy device structure */
+    DEBUG(1,"ray_dev_config(dev=%p,ifmap=%p)\n",dev,map);
+    if (!(link->state & DEV_PRESENT)) {
+        DEBUG(2,"ray_dev_config - device not present\n");
+        return -1;
+    }
+
+    return 0;
+}
+/*===========================================================================*/
+static int ray_dev_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+    ray_dev_t *local = dev->priv;
+    dev_link_t *link = local->finder;
+    short length = skb->len;
+
+    if (!(link->state & DEV_PRESENT)) {
+        DEBUG(2,"ray_dev_start_xmit - device not present\n");
+        return -1;
+    }
+    DEBUG(3,"ray_dev_start_xmit(skb=%p, dev=%p)\n",skb,dev);
+    if (local->authentication_state == NEED_TO_AUTH) {
+        DEBUG(0,"ray_cs Sending authentication request.\n");
+        if (!build_auth_frame (local, local->auth_id, OPEN_AUTH_REQUEST)) {
+            local->authentication_state = AUTHENTICATED;
+            netif_stop_queue(dev);
+            return 1;
+        }
+    }
+
+    if (length < ETH_ZLEN)
+    {
+    	skb = skb_padto(skb, ETH_ZLEN);
+    	if (skb == NULL)
+    		return 0;
+    	length = ETH_ZLEN;
+    }
+    switch (ray_hw_xmit( skb->data, length, dev, DATA_TYPE)) {
+        case XMIT_NO_CCS:
+        case XMIT_NEED_AUTH:
+	    netif_stop_queue(dev);
+            return 1;
+        case XMIT_NO_INTR:
+        case XMIT_MSG_BAD:
+        case XMIT_OK:
+        default:
+            dev->trans_start = jiffies;
+            dev_kfree_skb(skb);
+            return 0;
+    }
+    return 0;
+} /* ray_dev_start_xmit */
+/*===========================================================================*/
+static int ray_hw_xmit(unsigned char* data, int len, struct net_device* dev, 
+                UCHAR msg_type)
+{
+    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    struct ccs __iomem *pccs;
+    int ccsindex;
+    int offset;
+    struct tx_msg __iomem *ptx; /* Address of xmit buffer in PC space */
+    short int addr;     /* Address of xmit buffer in card space */
+    
+    DEBUG(3,"ray_hw_xmit(data=%p, len=%d, dev=%p)\n",data,len,dev);
+    if (len + TX_HEADER_LENGTH > TX_BUF_SIZE)
+    {
+        printk(KERN_INFO "ray_hw_xmit packet too large: %d bytes\n",len);
+        return XMIT_MSG_BAD;
+    }
+	switch (ccsindex = get_free_tx_ccs(local)) {
+	case ECCSBUSY:
+		DEBUG(2,"ray_hw_xmit tx_ccs table busy\n");
+	case ECCSFULL:
+        DEBUG(2,"ray_hw_xmit No free tx ccs\n");
+	case ECARDGONE:
+	netif_stop_queue(dev);
+        return XMIT_NO_CCS;
+	default:
+		break;
+	}
+    addr = TX_BUF_BASE + (ccsindex << 11);
+
+    if (msg_type == DATA_TYPE) {
+        local->stats.tx_bytes += len;
+        local->stats.tx_packets++;
+    }
+
+    ptx = local->sram + addr;
+
+    ray_build_header(local, ptx, msg_type, data);
+    if (translate) {
+        offset = translate_frame(local, ptx, data, len);
+    }
+    else { /* Encapsulate frame */
+        /* TBD TIB length will move address of ptx->var */
+        memcpy_toio(&ptx->var, data, len);
+        offset = 0;
+    }
+
+    /* fill in the CCS */
+    pccs = ccs_base(local) + ccsindex;
+    len += TX_HEADER_LENGTH + offset;
+    writeb(CCS_TX_REQUEST, &pccs->cmd);
+    writeb(addr >> 8, &pccs->var.tx_request.tx_data_ptr[0]);
+    writeb(local->tib_length, &pccs->var.tx_request.tx_data_ptr[1]);
+    writeb(len >> 8, &pccs->var.tx_request.tx_data_length[0]);
+    writeb(len & 0xff, &pccs->var.tx_request.tx_data_length[1]);
+/* TBD still need psm_cam? */
+    writeb(PSM_CAM, &pccs->var.tx_request.pow_sav_mode);
+    writeb(local->net_default_tx_rate, &pccs->var.tx_request.tx_rate);
+    writeb(0, &pccs->var.tx_request.antenna);
+    DEBUG(3,"ray_hw_xmit default_tx_rate = 0x%x\n",\
+          local->net_default_tx_rate);
+
+    /* Interrupt the firmware to process the command */
+    if (interrupt_ecf(local, ccsindex)) {
+        DEBUG(2,"ray_hw_xmit failed - ECF not ready for intr\n");
+/* TBD very inefficient to copy packet to buffer, and then not
+   send it, but the alternative is to queue the messages and that
+   won't be done for a while.  Maybe set tbusy until a CCS is free?
+*/
+        writeb(CCS_BUFFER_FREE, &pccs->buffer_status);
+        return XMIT_NO_INTR;
+    }
+    return XMIT_OK;
+} /* end ray_hw_xmit */
+/*===========================================================================*/
+static int translate_frame(ray_dev_t *local, struct tx_msg __iomem *ptx, unsigned char *data,
+                    int len)
+{
+    unsigned short int proto = ((struct ethhdr *)data)->h_proto;
+    if (ntohs(proto) >= 1536) { /* DIX II ethernet frame */
+        DEBUG(3,"ray_cs translate_frame DIX II\n");
+        /* Copy LLC header to card buffer */
+        memcpy_toio(&ptx->var, eth2_llc, sizeof(eth2_llc));
+        memcpy_toio( ((void __iomem *)&ptx->var) + sizeof(eth2_llc), (UCHAR *)&proto, 2);
+        if ((proto == 0xf380) || (proto == 0x3781)) {
+            /* This is the selective translation table, only 2 entries */
+            writeb(0xf8, &((struct snaphdr_t __iomem *)ptx->var)->org[3]);
+        }
+        /* Copy body of ethernet packet without ethernet header */
+        memcpy_toio((void __iomem *)&ptx->var + sizeof(struct snaphdr_t), \
+                    data + ETH_HLEN,  len - ETH_HLEN);
+        return (int) sizeof(struct snaphdr_t) - ETH_HLEN;
+    }
+    else { /* already  802 type, and proto is length */
+        DEBUG(3,"ray_cs translate_frame 802\n");
+        if (proto == 0xffff) { /* evil netware IPX 802.3 without LLC */
+        DEBUG(3,"ray_cs translate_frame evil IPX\n");
+            memcpy_toio(&ptx->var, data + ETH_HLEN,  len - ETH_HLEN);
+            return 0 - ETH_HLEN;
+        }
+        memcpy_toio(&ptx->var, data + ETH_HLEN,  len - ETH_HLEN);
+        return 0 - ETH_HLEN;
+    }
+    /* TBD do other frame types */
+} /* end translate_frame */
+/*===========================================================================*/
+static void ray_build_header(ray_dev_t *local, struct tx_msg __iomem *ptx, UCHAR msg_type,
+                unsigned char *data)
+{
+    writeb(PROTOCOL_VER | msg_type, &ptx->mac.frame_ctl_1);
+/*** IEEE 802.11 Address field assignments *************
+                TODS FROMDS   addr_1     addr_2          addr_3   addr_4
+Adhoc           0    0        dest       src (terminal)  BSSID    N/A
+AP to Terminal  0    1        dest       AP(BSSID)       source   N/A
+Terminal to AP  1    0        AP(BSSID)  src (terminal)  dest     N/A
+AP to AP        1    1        dest AP    src AP          dest     source      
+*******************************************************/
+    if (local->net_type == ADHOC) {   
+        writeb(0, &ptx->mac.frame_ctl_2);
+        memcpy_toio(ptx->mac.addr_1, ((struct ethhdr *)data)->h_dest, 2 * ADDRLEN);
+        memcpy_toio(ptx->mac.addr_3, local->bss_id, ADDRLEN);
+    }
+    else /* infrastructure */
+    {
+        if (local->sparm.b4.a_acting_as_ap_status)
+        {
+            writeb(FC2_FROM_DS, &ptx->mac.frame_ctl_2);
+            memcpy_toio(ptx->mac.addr_1, ((struct ethhdr *)data)->h_dest, ADDRLEN);
+            memcpy_toio(ptx->mac.addr_2, local->bss_id, 6);
+            memcpy_toio(ptx->mac.addr_3, ((struct ethhdr *)data)->h_source, ADDRLEN);
+        }
+        else /* Terminal */
+        {
+            writeb(FC2_TO_DS, &ptx->mac.frame_ctl_2);
+            memcpy_toio(ptx->mac.addr_1, local->bss_id, ADDRLEN);
+            memcpy_toio(ptx->mac.addr_2, ((struct ethhdr *)data)->h_source, ADDRLEN);
+            memcpy_toio(ptx->mac.addr_3, ((struct ethhdr *)data)->h_dest, ADDRLEN);
+        }
+    }
+} /* end encapsulate_frame */
+
+
+/*===========================================================================*/
+
+static void netdev_get_drvinfo(struct net_device *dev,
+			       struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, "ray_cs");
+}
+
+static struct ethtool_ops netdev_ethtool_ops = {
+	.get_drvinfo		= netdev_get_drvinfo,
+};
+
+/*====================================================================*/
+
+static int ray_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    dev_link_t *link = local->finder;
+    int err = 0;
+#if WIRELESS_EXT > 7
+    struct iwreq *wrq = (struct iwreq *) ifr;
+#endif	/* WIRELESS_EXT > 7 */
+#ifdef WIRELESS_SPY
+    struct sockaddr	address[IW_MAX_SPY];
+#endif	/* WIRELESS_SPY */
+
+    if (!(link->state & DEV_PRESENT)) {
+        DEBUG(2,"ray_dev_ioctl - device not present\n");
+        return -1;
+    }
+    DEBUG(2,"ray_cs IOCTL dev=%p, ifr=%p, cmd = 0x%x\n",dev,ifr,cmd);
+    /* Validate the command */
+    switch (cmd)
+    {
+#if WIRELESS_EXT > 7
+      /* --------------- WIRELESS EXTENSIONS --------------- */
+      /* Get name */
+    case SIOCGIWNAME:
+      strcpy(wrq->u.name, "IEEE 802.11-FH");
+      break;
+
+      /* Get frequency/channel */
+    case SIOCGIWFREQ:
+      wrq->u.freq.m = local->sparm.b5.a_hop_pattern;
+      wrq->u.freq.e = 0;
+      break;
+
+      /* Set frequency/channel */
+    case SIOCSIWFREQ:
+      /* Reject if card is already initialised */
+      if(local->card_status != CARD_AWAITING_PARAM)
+	{
+	  err = -EBUSY;
+	  break;
+	}
+
+      /* Setting by channel number */
+      if ((wrq->u.freq.m > USA_HOP_MOD) || (wrq->u.freq.e > 0))
+	err = -EOPNOTSUPP;
+      else
+	  local->sparm.b5.a_hop_pattern = wrq->u.freq.m;
+      break;
+
+      /* Get current network name (ESSID) */
+    case SIOCGIWESSID:
+      if (wrq->u.data.pointer)
+	{
+	  char essid[IW_ESSID_MAX_SIZE + 1];
+	  /* Get the essid that was set */
+	  memcpy(essid, local->sparm.b5.a_current_ess_id,
+		 IW_ESSID_MAX_SIZE);
+	  essid[IW_ESSID_MAX_SIZE] = '\0';
+
+	  /* Push it out ! */
+	  wrq->u.data.length = strlen(essid) + 1;
+	  wrq->u.data.flags = 1; /* active */
+	  if (copy_to_user(wrq->u.data.pointer, essid, sizeof(essid)))
+		  err = -EFAULT;
+	}
+      break;
+
+      /* Set desired network name (ESSID) */
+    case SIOCSIWESSID:
+      /* Reject if card is already initialised */
+      if(local->card_status != CARD_AWAITING_PARAM)
+	{
+	  err = -EBUSY;
+	  break;
+	}
+
+	if (wrq->u.data.pointer)
+	{
+	    char	card_essid[IW_ESSID_MAX_SIZE + 1];
+	    
+	    /* Check if we asked for `any' */
+	    if(wrq->u.data.flags == 0)
+	    {
+		/* Corey : can you do that ? */
+		err = -EOPNOTSUPP;
+	    }
+	    else
+	    {
+		/* Check the size of the string */
+		if(wrq->u.data.length >
+		   IW_ESSID_MAX_SIZE + 1)
+		{
+		    err = -E2BIG;
+		    break;
+		}
+		if (copy_from_user(card_essid,
+				   wrq->u.data.pointer,
+				   wrq->u.data.length)) {
+			err = -EFAULT;
+			break;
+		}
+		card_essid[IW_ESSID_MAX_SIZE] = '\0';
+
+		/* Set the ESSID in the card */
+		memcpy(local->sparm.b5.a_current_ess_id, card_essid,
+		       IW_ESSID_MAX_SIZE);
+	    }
+	}
+	break;
+
+      /* Get current Access Point (BSSID in our case) */
+    case SIOCGIWAP:
+      memcpy(wrq->u.ap_addr.sa_data, local->bss_id, ETH_ALEN);
+      wrq->u.ap_addr.sa_family = ARPHRD_ETHER;
+      break;
+
+      /* Get the current bit-rate */
+    case SIOCGIWRATE:
+      if(local->net_default_tx_rate == 3)
+	wrq->u.bitrate.value = 2000000;		/* Hum... */
+      else
+	wrq->u.bitrate.value = local->net_default_tx_rate * 500000;
+      wrq->u.bitrate.fixed = 0;		/* We are in auto mode */
+      break;
+
+      /* Set the desired bit-rate */
+    case SIOCSIWRATE:
+      /* Check if rate is in range */
+      if((wrq->u.bitrate.value != 1000000) &&
+	 (wrq->u.bitrate.value != 2000000))
+	{
+	  err = -EINVAL;
+	  break;
+	}
+      /* Hack for 1.5 Mb/s instead of 2 Mb/s */
+      if((local->fw_ver == 0x55) &&		/* Please check */
+	 (wrq->u.bitrate.value == 2000000))
+	local->net_default_tx_rate = 3;
+      else
+	local->net_default_tx_rate = wrq->u.bitrate.value/500000;
+      break;
+
+      /* Get the current RTS threshold */
+    case SIOCGIWRTS:
+      wrq->u.rts.value = (local->sparm.b5.a_rts_threshold[0] << 8)
+	+ local->sparm.b5.a_rts_threshold[1];
+#if WIRELESS_EXT > 8
+      wrq->u.rts.disabled = (wrq->u.rts.value == 32767);
+#endif /* WIRELESS_EXT > 8 */
+      wrq->u.rts.fixed = 1;
+      break;
+
+      /* Set the desired RTS threshold */
+    case SIOCSIWRTS:
+    {
+	int rthr = wrq->u.rts.value;
+
+      /* Reject if card is already initialised */
+      if(local->card_status != CARD_AWAITING_PARAM)
+	{
+	  err = -EBUSY;
+	  break;
+	}
+
+	/* if(wrq->u.rts.fixed == 0) we should complain */
+#if WIRELESS_EXT > 8
+	if(wrq->u.rts.disabled)
+	    rthr = 32767;
+	else
+#endif /* WIRELESS_EXT > 8 */
+	    if((rthr < 0) || (rthr > 2347)) /* What's the max packet size ??? */
+	    {
+		err = -EINVAL;
+		break;
+	    }
+	local->sparm.b5.a_rts_threshold[0] = (rthr >> 8) & 0xFF;
+	local->sparm.b5.a_rts_threshold[1] = rthr & 0xFF;
+    }
+    break;
+
+      /* Get the current fragmentation threshold */
+    case SIOCGIWFRAG:
+      wrq->u.frag.value = (local->sparm.b5.a_frag_threshold[0] << 8)
+	+ local->sparm.b5.a_frag_threshold[1];
+#if WIRELESS_EXT > 8
+      wrq->u.frag.disabled = (wrq->u.frag.value == 32767);
+#endif /* WIRELESS_EXT > 8 */
+      wrq->u.frag.fixed = 1;
+      break;
+
+      /* Set the desired fragmentation threshold */
+    case SIOCSIWFRAG:
+    {
+	int fthr = wrq->u.frag.value;
+
+      /* Reject if card is already initialised */
+      if(local->card_status != CARD_AWAITING_PARAM)
+	{
+	  err = -EBUSY;
+	  break;
+	}
+
+	/* if(wrq->u.frag.fixed == 0) should complain */
+#if WIRELESS_EXT > 8
+	if(wrq->u.frag.disabled)
+	    fthr = 32767;
+	else
+#endif /* WIRELESS_EXT > 8 */
+	    if((fthr < 256) || (fthr > 2347)) /* To check out ! */
+	    {
+		err = -EINVAL;
+		break;
+	    }
+	local->sparm.b5.a_frag_threshold[0] = (fthr >> 8) & 0xFF;
+	local->sparm.b5.a_frag_threshold[1] = fthr & 0xFF;
+    }
+    break;
+
+#endif	/* WIRELESS_EXT > 7 */
+#if WIRELESS_EXT > 8
+
+      /* Get the current mode of operation */
+    case SIOCGIWMODE:
+      if(local->sparm.b5.a_network_type)
+	wrq->u.mode = IW_MODE_INFRA;
+      else
+	wrq->u.mode = IW_MODE_ADHOC;
+      break;
+
+      /* Set the current mode of operation */
+    case SIOCSIWMODE:
+    {
+	char card_mode = 1;
+	
+      /* Reject if card is already initialised */
+      if(local->card_status != CARD_AWAITING_PARAM)
+	{
+	  err = -EBUSY;
+	  break;
+	}
+
+	switch (wrq->u.mode)
+	{
+	case IW_MODE_ADHOC:
+	    card_mode = 0;
+	    // Fall through
+	case IW_MODE_INFRA:
+	    local->sparm.b5.a_network_type = card_mode;
+	    break;
+	default:
+	    err = -EINVAL;
+	}
+    }
+    break;
+
+#endif /* WIRELESS_EXT > 8 */
+#if WIRELESS_EXT > 7
+      /* ------------------ IWSPY SUPPORT ------------------ */
+      /* Define the range (variations) of above parameters */
+    case SIOCGIWRANGE:
+      /* Basic checking... */
+      if(wrq->u.data.pointer != (caddr_t) 0)
+	{
+	  struct iw_range	range;
+	  memset((char *) &range, 0, sizeof(struct iw_range));
+
+	  /* Set the length (very important for backward compatibility) */
+	  wrq->u.data.length = sizeof(struct iw_range);
+
+#if WIRELESS_EXT > 10
+	  /* Set the Wireless Extension versions */
+	  range.we_version_compiled = WIRELESS_EXT;
+	  range.we_version_source = 9;
+#endif /* WIRELESS_EXT > 10 */
+
+	  /* Set information in the range struct */
+	  range.throughput = 1.1 * 1000 * 1000;	/* Put the right number here */
+	  range.num_channels = hop_pattern_length[(int)country]; 
+	  range.num_frequency = 0;
+	  range.max_qual.qual = 0;
+	  range.max_qual.level = 255;	/* What's the correct value ? */
+	  range.max_qual.noise = 255;	/* Idem */
+	  range.num_bitrates = 2;
+	  range.bitrate[0] = 1000000;	/* 1 Mb/s */
+	  range.bitrate[1] = 2000000;	/* 2 Mb/s */
+
+	  /* Copy structure to the user buffer */
+	  if(copy_to_user(wrq->u.data.pointer, &range,
+			  sizeof(struct iw_range)))
+	    err = -EFAULT;
+	}
+      break;
+
+#ifdef WIRELESS_SPY
+      /* Set addresses to spy */
+    case SIOCSIWSPY:
+      /* Check the number of addresses */
+      if(wrq->u.data.length > IW_MAX_SPY)
+	{
+	  err = -E2BIG;
+	  break;
+	}
+      local->spy_number = wrq->u.data.length;
+
+      /* If there is some addresses to copy */
+      if(local->spy_number > 0)
+	{
+	  int			i;
+
+	  /* Copy addresses to the driver */
+	  if(copy_from_user(address, wrq->u.data.pointer,
+			    sizeof(struct sockaddr) * local->spy_number))
+	    {
+	      err = -EFAULT;
+	      break;
+	    }
+
+	  /* Copy addresses to the lp structure */
+	  for(i = 0; i < local->spy_number; i++)
+	    memcpy(local->spy_address[i], address[i].sa_data, ETH_ALEN);
+
+	  /* Reset structure... */
+	  memset(local->spy_stat, 0x00, sizeof(iw_qual) * IW_MAX_SPY);
+
+#ifdef DEBUG_IOCTL_INFO
+	  printk(KERN_DEBUG "SetSpy - Set of new addresses is :\n");
+	  for(i = 0; i < local->spy_number; i++)
+	    printk(KERN_DEBUG "%02X:%02X:%02X:%02X:%02X:%02X\n",
+		   local->spy_address[i][0],
+		   local->spy_address[i][1],
+		   local->spy_address[i][2],
+		   local->spy_address[i][3],
+		   local->spy_address[i][4],
+		   local->spy_address[i][5]);
+#endif	/* DEBUG_IOCTL_INFO */
+	}
+      break;
+
+      /* Get the spy list and spy stats */
+    case SIOCGIWSPY:
+      /* Set the number of addresses */
+      wrq->u.data.length = local->spy_number;
+
+      /* If the user want to have the addresses back... */
+      if((local->spy_number > 0) && (wrq->u.data.pointer != (caddr_t) 0))
+	{
+	  int			i;
+
+	  /* Copy addresses from the lp structure */
+	  for(i = 0; i < local->spy_number; i++)
+	    {
+	      memcpy(address[i].sa_data, local->spy_address[i], ETH_ALEN);
+	      address[i].sa_family = ARPHRD_ETHER;
+	    }
+
+	  /* Copy addresses to the user buffer */
+	  if(copy_to_user(wrq->u.data.pointer, address,
+		       sizeof(struct sockaddr) * local->spy_number))
+	    {
+	      err = -EFAULT;
+	      break;
+	    }
+
+	  /* Copy stats to the user buffer (just after) */
+	  if(copy_to_user(wrq->u.data.pointer +
+		       (sizeof(struct sockaddr) * local->spy_number),
+		       local->spy_stat, sizeof(iw_qual) * local->spy_number))
+	    {
+	      err = -EFAULT;
+	      break;
+	    }
+
+	  /* Reset updated flags */
+	  for(i = 0; i < local->spy_number; i++)
+	    local->spy_stat[i].updated = 0x0;
+	}	/* if(pointer != NULL) */
+
+      break;
+#endif	/* WIRELESS_SPY */
+
+      /* ------------------ PRIVATE IOCTL ------------------ */
+#ifndef SIOCIWFIRSTPRIV
+#define SIOCIWFIRSTPRIV	SIOCDEVPRIVATE
+#endif /* SIOCIWFIRSTPRIV */
+#define SIOCSIPFRAMING	SIOCIWFIRSTPRIV		/* Set framing mode */
+#define SIOCGIPFRAMING	SIOCIWFIRSTPRIV + 1	/* Get framing mode */
+#define SIOCGIPCOUNTRY	SIOCIWFIRSTPRIV + 3	/* Get country code */
+    case SIOCSIPFRAMING:
+      if(!capable(CAP_NET_ADMIN))	/* For private IOCTLs, we need to check permissions */
+	{
+	  err = -EPERM;
+	  break;
+	}
+      translate = *(wrq->u.name);	/* Set framing mode */
+      break;
+    case SIOCGIPFRAMING:
+      *(wrq->u.name) = translate;
+      break;
+    case SIOCGIPCOUNTRY:
+      *(wrq->u.name) = country;
+      break;
+    case SIOCGIWPRIV:
+      /* Export our "private" intercace */
+      if(wrq->u.data.pointer != (caddr_t) 0)
+	{
+	  struct iw_priv_args	priv[] =
+	  {	/* cmd,		set_args,	get_args,	name */
+	    { SIOCSIPFRAMING, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1, 0, "set_framing" },
+	    { SIOCGIPFRAMING, 0, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1, "get_framing" },
+	    { SIOCGIPCOUNTRY, 0, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | 1, "get_country" },
+	  };
+	  /* Set the number of ioctl available */
+	  wrq->u.data.length = 3;
+	  /* Copy structure to the user buffer */
+	  if(copy_to_user(wrq->u.data.pointer, (u_char *) priv,
+		       sizeof(priv)))
+	    err = -EFAULT;
+	}
+      break;
+#endif	/* WIRELESS_EXT > 7 */
+
+
+        default:
+            DEBUG(0,"ray_dev_ioctl cmd = 0x%x\n", cmd);
+            err = -EOPNOTSUPP;
+    }
+    return err;
+} /* end ray_dev_ioctl */
+/*===========================================================================*/
+#if WIRELESS_EXT > 7	/* If wireless extension exist in the kernel */
+static iw_stats * ray_get_wireless_stats(struct net_device *	dev)
+{
+  ray_dev_t *	local = (ray_dev_t *) dev->priv;
+  dev_link_t *link = local->finder;
+  struct status __iomem *p = local->sram + STATUS_BASE;
+
+  if(local == (ray_dev_t *) NULL)
+    return (iw_stats *) NULL;
+
+  local->wstats.status = local->card_status;
+#ifdef WIRELESS_SPY
+  if((local->spy_number > 0) && (local->sparm.b5.a_network_type == 0))
+    {
+      /* Get it from the first node in spy list */
+      local->wstats.qual.qual = local->spy_stat[0].qual;
+      local->wstats.qual.level = local->spy_stat[0].level;
+      local->wstats.qual.noise = local->spy_stat[0].noise;
+      local->wstats.qual.updated = local->spy_stat[0].updated;
+    }
+#endif /* WIRELESS_SPY */
+
+  if((link->state & DEV_PRESENT)) {
+    local->wstats.qual.noise = readb(&p->rxnoise);
+    local->wstats.qual.updated |= 4;
+  }
+
+  return &local->wstats;
+} /* end ray_get_wireless_stats */
+#endif	/* WIRELESS_EXT > 7 */
+/*===========================================================================*/
+static int ray_open(struct net_device *dev)
+{
+    dev_link_t *link;
+    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    
+    DEBUG(1, "ray_open('%s')\n", dev->name);
+
+    for (link = dev_list; link; link = link->next)
+        if (link->priv == dev) break;
+    if (!DEV_OK(link)) {
+        return -ENODEV;
+    }
+
+    if (link->open == 0) local->num_multi = 0;
+    link->open++;
+
+    /* If the card is not started, time to start it ! - Jean II */
+    if(local->card_status == CARD_AWAITING_PARAM) {
+	int i;
+
+	DEBUG(1,"ray_open: doing init now !\n");
+
+	/* Download startup parameters */
+	if ( (i = dl_startup_params(dev)) < 0)
+	  {
+	    printk(KERN_INFO "ray_dev_init dl_startup_params failed - "
+		   "returns 0x%x\n",i);
+	    return -1;
+	  }
+     }
+
+    if (sniffer) netif_stop_queue(dev);
+    else         netif_start_queue(dev);
+
+    DEBUG(2,"ray_open ending\n");
+    return 0;
+} /* end ray_open */
+/*===========================================================================*/
+static int ray_dev_close(struct net_device *dev)
+{
+    dev_link_t *link;
+
+    DEBUG(1, "ray_dev_close('%s')\n", dev->name);
+
+    for (link = dev_list; link; link = link->next)
+        if (link->priv == dev) break;
+    if (link == NULL)
+        return -ENODEV;
+
+    link->open--;
+    netif_stop_queue(dev);
+
+    /* In here, we should stop the hardware (stop card from beeing active)
+     * and set local->card_status to CARD_AWAITING_PARAM, so that while the
+     * card is closed we can chage its configuration.
+     * Probably also need a COR reset to get sane state - Jean II */
+
+    return 0;
+} /* end ray_dev_close */
+/*===========================================================================*/
+static void ray_reset(struct net_device *dev) {
+    DEBUG(1,"ray_reset entered\n");
+    return;
+}
+/*===========================================================================*/
+/* Cause a firmware interrupt if it is ready for one                         */
+/* Return nonzero if not ready                                               */
+static int interrupt_ecf(ray_dev_t *local, int ccs)
+{
+    int i = 50;
+    dev_link_t *link = local->finder;
+
+    if (!(link->state & DEV_PRESENT)) {
+        DEBUG(2,"ray_cs interrupt_ecf - device not present\n");
+        return -1;
+    }
+    DEBUG(2,"interrupt_ecf(local=%p, ccs = 0x%x\n",local,ccs);
+
+    while ( i && 
+            (readb(local->amem + CIS_OFFSET + ECF_INTR_OFFSET) & ECF_INTR_SET))
+        i--;
+    if (i == 0) {
+        DEBUG(2,"ray_cs interrupt_ecf card not ready for interrupt\n");
+        return -1;
+    }
+	/* Fill the mailbox, then kick the card */
+    writeb(ccs, local->sram + SCB_BASE);
+    writeb(ECF_INTR_SET, local->amem + CIS_OFFSET + ECF_INTR_OFFSET);
+    return 0;
+} /* interrupt_ecf */
+/*===========================================================================*/
+/* Get next free transmit CCS                                                */
+/* Return - index of current tx ccs                                          */
+static int get_free_tx_ccs(ray_dev_t *local)
+{
+    int i;
+    struct ccs __iomem *pccs = ccs_base(local);
+    dev_link_t *link = local->finder;
+
+    if (!(link->state & DEV_PRESENT)) {
+        DEBUG(2,"ray_cs get_free_tx_ccs - device not present\n");
+        return ECARDGONE;
+    }
+
+    if (test_and_set_bit(0,&local->tx_ccs_lock)) {
+        DEBUG(1,"ray_cs tx_ccs_lock busy\n");
+        return ECCSBUSY;
+    } 
+
+    for (i=0; i < NUMBER_OF_TX_CCS; i++) {
+        if (readb(&(pccs+i)->buffer_status) == CCS_BUFFER_FREE) {
+            writeb(CCS_BUFFER_BUSY, &(pccs+i)->buffer_status);
+            writeb(CCS_END_LIST, &(pccs+i)->link);
+			local->tx_ccs_lock = 0;
+            return i;
+        }
+    }
+	local->tx_ccs_lock = 0;
+    DEBUG(2,"ray_cs ERROR no free tx CCS for raylink card\n");
+    return ECCSFULL;
+} /* get_free_tx_ccs */
+/*===========================================================================*/
+/* Get next free CCS                                                         */
+/* Return - index of current ccs                                             */
+static int get_free_ccs(ray_dev_t *local)
+{
+    int i;
+    struct ccs __iomem *pccs = ccs_base(local);
+    dev_link_t *link = local->finder;
+
+    if (!(link->state & DEV_PRESENT)) {
+        DEBUG(2,"ray_cs get_free_ccs - device not present\n");
+        return ECARDGONE;
+    }
+    if (test_and_set_bit(0,&local->ccs_lock)) {
+        DEBUG(1,"ray_cs ccs_lock busy\n");
+        return ECCSBUSY;
+    } 
+
+    for (i = NUMBER_OF_TX_CCS; i < NUMBER_OF_CCS; i++) {
+        if (readb(&(pccs+i)->buffer_status) == CCS_BUFFER_FREE) {
+            writeb(CCS_BUFFER_BUSY, &(pccs+i)->buffer_status);
+            writeb(CCS_END_LIST, &(pccs+i)->link);
+			local->ccs_lock = 0;
+            return i;
+        }
+    }
+	local->ccs_lock = 0;
+    DEBUG(1,"ray_cs ERROR no free CCS for raylink card\n");
+    return ECCSFULL;
+} /* get_free_ccs */
+/*===========================================================================*/
+static void authenticate_timeout(u_long data)
+{
+    ray_dev_t *local = (ray_dev_t *)data;
+    del_timer(&local->timer);
+    printk(KERN_INFO "ray_cs Authentication with access point failed"
+       " - timeout\n");
+    join_net((u_long)local);
+}
+/*===========================================================================*/
+static int asc_to_int(char a)
+{
+    if (a < '0') return -1;
+    if (a <= '9') return (a - '0');
+    if (a < 'A') return -1;
+    if (a <= 'F') return (10 + a - 'A');
+    if (a < 'a') return -1;
+    if (a <= 'f') return (10 + a - 'a');
+    return -1;
+}
+/*===========================================================================*/
+static int parse_addr(char *in_str, UCHAR *out)
+{
+    int len;
+    int i,j,k;
+    int status;
+    
+    if (in_str == NULL) return 0;
+    if ((len = strlen(in_str)) < 2) return 0;
+    memset(out, 0, ADDRLEN);
+
+    status = 1;
+    j = len - 1;
+    if (j > 12) j = 12;
+    i = 5;
+    
+    while (j > 0)
+    {
+        if ((k = asc_to_int(in_str[j--])) != -1) out[i] = k;
+        else return 0;
+
+        if (j == 0) break;
+        if ((k = asc_to_int(in_str[j--])) != -1) out[i] += k << 4;
+        else return 0;
+        if (!i--) break;
+    }
+    return status;
+}
+/*===========================================================================*/
+static struct net_device_stats *ray_get_stats(struct net_device *dev)
+{
+    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    dev_link_t *link = local->finder;
+    struct status __iomem *p = local->sram + STATUS_BASE;
+    if (!(link->state & DEV_PRESENT)) {
+        DEBUG(2,"ray_cs net_device_stats - device not present\n");
+        return &local->stats;
+    }
+    if (readb(&p->mrx_overflow_for_host))
+    {
+        local->stats.rx_over_errors += ntohs(readb(&p->mrx_overflow));
+        writeb(0,&p->mrx_overflow);
+        writeb(0,&p->mrx_overflow_for_host);
+    }
+    if (readb(&p->mrx_checksum_error_for_host))
+    {
+        local->stats.rx_crc_errors += ntohs(readb(&p->mrx_checksum_error));
+        writeb(0,&p->mrx_checksum_error);
+        writeb(0,&p->mrx_checksum_error_for_host);
+    }
+    if (readb(&p->rx_hec_error_for_host))
+    {
+        local->stats.rx_frame_errors += ntohs(readb(&p->rx_hec_error));
+        writeb(0,&p->rx_hec_error);
+        writeb(0,&p->rx_hec_error_for_host);
+    }
+    return &local->stats;
+}
+/*===========================================================================*/
+static void ray_update_parm(struct net_device *dev, UCHAR objid, UCHAR *value, int len)
+{
+    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    dev_link_t *link = local->finder;
+    int ccsindex;
+    int i;
+    struct ccs __iomem *pccs;
+
+    if (!(link->state & DEV_PRESENT)) {
+        DEBUG(2,"ray_update_parm - device not present\n");
+        return;
+    }
+
+    if ((ccsindex = get_free_ccs(local)) < 0)
+    {
+        DEBUG(0,"ray_update_parm - No free ccs\n");
+        return;
+    }
+    pccs = ccs_base(local) + ccsindex;
+    writeb(CCS_UPDATE_PARAMS, &pccs->cmd);
+    writeb(objid, &pccs->var.update_param.object_id);
+    writeb(1, &pccs->var.update_param.number_objects);
+    writeb(0, &pccs->var.update_param.failure_cause);
+    for (i=0; i<len; i++) {
+        writeb(value[i], local->sram + HOST_TO_ECF_BASE);
+    }
+    /* Interrupt the firmware to process the command */
+    if (interrupt_ecf(local, ccsindex)) {
+        DEBUG(0,"ray_cs associate failed - ECF not ready for intr\n");
+        writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
+    }
+}
+/*===========================================================================*/
+static void ray_update_multi_list(struct net_device *dev, int all)
+{
+    struct dev_mc_list *dmi, **dmip;
+    int ccsindex;
+    struct ccs __iomem *pccs;
+    int i = 0;
+    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    dev_link_t *link = local->finder;
+    void __iomem *p = local->sram + HOST_TO_ECF_BASE;
+
+    if (!(link->state & DEV_PRESENT)) {
+        DEBUG(2,"ray_update_multi_list - device not present\n");
+        return;
+    }
+    else 
+        DEBUG(2,"ray_update_multi_list(%p)\n",dev);
+    if ((ccsindex = get_free_ccs(local)) < 0)
+    {
+        DEBUG(1,"ray_update_multi - No free ccs\n");
+        return;
+    }
+    pccs = ccs_base(local) + ccsindex;
+    writeb(CCS_UPDATE_MULTICAST_LIST, &pccs->cmd);
+
+    if (all) {
+        writeb(0xff, &pccs->var);
+        local->num_multi = 0xff;
+    }
+    else {
+        /* Copy the kernel's list of MC addresses to card */
+        for (dmip=&dev->mc_list; (dmi=*dmip)!=NULL; dmip=&dmi->next) {
+            memcpy_toio(p, dmi->dmi_addr, ETH_ALEN);
+            DEBUG(1,"ray_update_multi add addr %02x%02x%02x%02x%02x%02x\n",dmi->dmi_addr[0],dmi->dmi_addr[1],dmi->dmi_addr[2],dmi->dmi_addr[3],dmi->dmi_addr[4],dmi->dmi_addr[5]);
+            p += ETH_ALEN;
+            i++;
+        }
+        if (i > 256/ADDRLEN) i = 256/ADDRLEN;
+        writeb((UCHAR)i, &pccs->var);
+        DEBUG(1,"ray_cs update_multi %d addresses in list\n", i);
+        /* Interrupt the firmware to process the command */
+        local->num_multi = i;
+    }
+    if (interrupt_ecf(local, ccsindex)) {
+        DEBUG(1,"ray_cs update_multi failed - ECF not ready for intr\n");
+        writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
+    }
+} /* end ray_update_multi_list */
+/*===========================================================================*/
+static void set_multicast_list(struct net_device *dev)
+{
+    ray_dev_t *local = (ray_dev_t *)dev->priv;
+    UCHAR promisc;
+
+    DEBUG(2,"ray_cs set_multicast_list(%p)\n",dev);
+
+    if (dev->flags & IFF_PROMISC)
+    {
+        if (local->sparm.b5.a_promiscuous_mode == 0) {
+            DEBUG(1,"ray_cs set_multicast_list promisc on\n");
+            local->sparm.b5.a_promiscuous_mode = 1;
+            promisc = 1;
+            ray_update_parm(dev,  OBJID_promiscuous_mode, \
+                            &promisc, sizeof(promisc));
+        }
+    }
+    else {
+        if (local->sparm.b5.a_promiscuous_mode == 1) {
+            DEBUG(1,"ray_cs set_multicast_list promisc off\n");
+            local->sparm.b5.a_promiscuous_mode = 0;
+            promisc = 0;
+            ray_update_parm(dev,  OBJID_promiscuous_mode, \
+                            &promisc, sizeof(promisc));
+        }
+    }
+
+    if (dev->flags & IFF_ALLMULTI) ray_update_multi_list(dev, 1);
+    else
+    {
+        if (local->num_multi != dev->mc_count) ray_update_multi_list(dev, 0);
+    }
+} /* end set_multicast_list */
+/*=============================================================================
+ * All routines below here are run at interrupt time.
+=============================================================================*/
+static irqreturn_t ray_interrupt(int irq, void *dev_id, struct pt_regs * regs)
+{
+    struct net_device *dev = (struct net_device *)dev_id;
+    dev_link_t *link;
+    ray_dev_t *local;
+    struct ccs __iomem *pccs;
+    struct rcs __iomem *prcs;
+    UCHAR rcsindex;
+    UCHAR tmp;
+    UCHAR cmd;
+    UCHAR status;
+
+    if (dev == NULL) /* Note that we want interrupts with dev->start == 0 */
+	return IRQ_NONE;
+
+    DEBUG(4,"ray_cs: interrupt for *dev=%p\n",dev);
+
+    local = (ray_dev_t *)dev->priv;
+    link = (dev_link_t *)local->finder;
+    if ( ! (link->state & DEV_PRESENT) || link->state & DEV_SUSPEND ) {
+        DEBUG(2,"ray_cs interrupt from device not present or suspended.\n");
+        return IRQ_NONE;
+    }
+    rcsindex = readb(&((struct scb __iomem *)(local->sram))->rcs_index);
+
+    if (rcsindex >= (NUMBER_OF_CCS + NUMBER_OF_RCS))
+    {
+        DEBUG(1,"ray_cs interrupt bad rcsindex = 0x%x\n",rcsindex);
+        clear_interrupt(local);
+        return IRQ_HANDLED;
+    }
+    if (rcsindex < NUMBER_OF_CCS) /* If it's a returned CCS */
+    {
+        pccs = ccs_base(local) + rcsindex;
+        cmd = readb(&pccs->cmd);
+        status = readb(&pccs->buffer_status);
+        switch (cmd)
+        {
+        case CCS_DOWNLOAD_STARTUP_PARAMS: /* Happens in firmware someday */
+            del_timer(&local->timer);
+            if (status == CCS_COMMAND_COMPLETE) {
+                DEBUG(1,"ray_cs interrupt download_startup_parameters OK\n");
+            }
+            else {
+                DEBUG(1,"ray_cs interrupt download_startup_parameters fail\n");
+            }
+            break;
+        case CCS_UPDATE_PARAMS:
+            DEBUG(1,"ray_cs interrupt update params done\n");
+            if (status != CCS_COMMAND_COMPLETE) {
+                tmp = readb(&pccs->var.update_param.failure_cause);
+            DEBUG(0,"ray_cs interrupt update params failed - reason %d\n",tmp);
+            }
+            break;
+        case CCS_REPORT_PARAMS:
+            DEBUG(1,"ray_cs interrupt report params done\n");
+            break;
+        case CCS_UPDATE_MULTICAST_LIST: /* Note that this CCS isn't returned */
+            DEBUG(1,"ray_cs interrupt CCS Update Multicast List done\n");
+            break;
+        case CCS_UPDATE_POWER_SAVINGS_MODE:
+            DEBUG(1,"ray_cs interrupt update power save mode done\n");
+            break;
+        case CCS_START_NETWORK:
+        case CCS_JOIN_NETWORK:
+            if (status == CCS_COMMAND_COMPLETE) {
+                if (readb(&pccs->var.start_network.net_initiated) == 1) {
+                    DEBUG(0,"ray_cs interrupt network \"%s\" started\n",\
+                          local->sparm.b4.a_current_ess_id);
+                }
+                else {
+                    DEBUG(0,"ray_cs interrupt network \"%s\" joined\n",\
+                          local->sparm.b4.a_current_ess_id);
+                }
+                memcpy_fromio(&local->bss_id,pccs->var.start_network.bssid,ADDRLEN);
+
+                if (local->fw_ver == 0x55) local->net_default_tx_rate = 3;
+                else local->net_default_tx_rate = 
+                         readb(&pccs->var.start_network.net_default_tx_rate);
+                local->encryption = readb(&pccs->var.start_network.encryption);
+                if (!sniffer && (local->net_type == INFRA)
+                    && !(local->sparm.b4.a_acting_as_ap_status)) {
+                    authenticate(local);
+                }
+                local->card_status = CARD_ACQ_COMPLETE;
+            }
+            else {
+                local->card_status = CARD_ACQ_FAILED;
+
+                del_timer(&local->timer);
+                local->timer.expires = jiffies + HZ*5;
+                local->timer.data = (long)local;
+                if (status == CCS_START_NETWORK) {
+                    DEBUG(0,"ray_cs interrupt network \"%s\" start failed\n",\
+                          local->sparm.b4.a_current_ess_id);
+                    local->timer.function = &start_net;
+                }
+                else {
+                    DEBUG(0,"ray_cs interrupt network \"%s\" join failed\n",\
+                          local->sparm.b4.a_current_ess_id);
+                    local->timer.function = &join_net;
+                }
+                add_timer(&local->timer);
+            }
+            break;
+        case CCS_START_ASSOCIATION:
+            if (status == CCS_COMMAND_COMPLETE) {
+                local->card_status = CARD_ASSOC_COMPLETE;
+                DEBUG(0,"ray_cs association successful\n");
+            }
+            else
+            {
+                DEBUG(0,"ray_cs association failed,\n");
+                local->card_status = CARD_ASSOC_FAILED;
+                join_net((u_long)local);
+            }
+            break;
+        case CCS_TX_REQUEST:
+            if (status == CCS_COMMAND_COMPLETE) {
+                DEBUG(3,"ray_cs interrupt tx request complete\n");
+            }
+            else {
+                DEBUG(1,"ray_cs interrupt tx request failed\n");
+            }
+            if (!sniffer) netif_start_queue(dev);
+            netif_wake_queue(dev);
+            break;
+        case CCS_TEST_MEMORY:
+            DEBUG(1,"ray_cs interrupt mem test done\n");
+            break;
+        case CCS_SHUTDOWN:
+            DEBUG(1,"ray_cs interrupt Unexpected CCS returned - Shutdown\n");
+            break;
+        case CCS_DUMP_MEMORY:
+            DEBUG(1,"ray_cs interrupt dump memory done\n");
+            break;
+        case CCS_START_TIMER:
+            DEBUG(2,"ray_cs interrupt DING - raylink timer expired\n");
+            break;
+        default:
+            DEBUG(1,"ray_cs interrupt Unexpected CCS 0x%x returned 0x%x\n",\
+                  rcsindex, cmd);
+        }
+        writeb(CCS_BUFFER_FREE, &pccs->buffer_status);
+    }
+    else /* It's an RCS */
+    {
+        prcs = rcs_base(local) + rcsindex;
+    
+        switch (readb(&prcs->interrupt_id))
+        {
+        case PROCESS_RX_PACKET:
+            ray_rx(dev, local, prcs);
+            break;
+        case REJOIN_NET_COMPLETE:
+            DEBUG(1,"ray_cs interrupt rejoin net complete\n");
+            local->card_status = CARD_ACQ_COMPLETE;
+            /* do we need to clear tx buffers CCS's? */
+            if (local->sparm.b4.a_network_type == ADHOC) {
+                if (!sniffer) netif_start_queue(dev);
+            }
+            else {
+                memcpy_fromio(&local->bss_id, prcs->var.rejoin_net_complete.bssid, ADDRLEN);
+                DEBUG(1,"ray_cs new BSSID = %02x%02x%02x%02x%02x%02x\n",\
+                      local->bss_id[0], local->bss_id[1], local->bss_id[2],\
+                      local->bss_id[3], local->bss_id[4], local->bss_id[5]);
+                if (!sniffer) authenticate(local);
+            }
+            break;
+        case ROAMING_INITIATED:
+            DEBUG(1,"ray_cs interrupt roaming initiated\n"); 
+            netif_stop_queue(dev);
+            local->card_status = CARD_DOING_ACQ;
+            break;
+        case JAPAN_CALL_SIGN_RXD:
+            DEBUG(1,"ray_cs interrupt japan call sign rx\n");
+            break;
+        default:
+            DEBUG(1,"ray_cs Unexpected interrupt for RCS 0x%x cmd = 0x%x\n",\
+                  rcsindex, (unsigned int) readb(&prcs->interrupt_id));
+            break;
+        }
+        writeb(CCS_BUFFER_FREE, &prcs->buffer_status);
+    }
+    clear_interrupt(local);
+    return IRQ_HANDLED;
+} /* ray_interrupt */
+/*===========================================================================*/
+static void ray_rx(struct net_device *dev, ray_dev_t *local, struct rcs __iomem *prcs)
+{
+    int rx_len;
+    unsigned int pkt_addr;
+    void __iomem *pmsg;
+    DEBUG(4,"ray_rx process rx packet\n");
+
+    /* Calculate address of packet within Rx buffer */
+    pkt_addr = ((readb(&prcs->var.rx_packet.rx_data_ptr[0]) << 8)
+                + readb(&prcs->var.rx_packet.rx_data_ptr[1])) & RX_BUFF_END;
+    /* Length of first packet fragment */
+    rx_len = (readb(&prcs->var.rx_packet.rx_data_length[0]) << 8)
+        + readb(&prcs->var.rx_packet.rx_data_length[1]);
+
+    local->last_rsl = readb(&prcs->var.rx_packet.rx_sig_lev);
+    pmsg = local->rmem + pkt_addr;
+    switch(readb(pmsg))
+    {
+    case DATA_TYPE:
+        DEBUG(4,"ray_rx data type\n");
+        rx_data(dev, prcs, pkt_addr, rx_len);
+        break;
+    case AUTHENTIC_TYPE:
+        DEBUG(4,"ray_rx authentic type\n");
+        if (sniffer) rx_data(dev, prcs, pkt_addr, rx_len);
+        else rx_authenticate(local, prcs, pkt_addr, rx_len);
+        break;
+    case DEAUTHENTIC_TYPE:
+        DEBUG(4,"ray_rx deauth type\n");
+        if (sniffer) rx_data(dev, prcs, pkt_addr, rx_len);
+        else rx_deauthenticate(local, prcs, pkt_addr, rx_len);
+        break;
+    case NULL_MSG_TYPE:
+        DEBUG(3,"ray_cs rx NULL msg\n");
+        break;
+    case BEACON_TYPE:
+        DEBUG(4,"ray_rx beacon type\n");
+        if (sniffer) rx_data(dev, prcs, pkt_addr, rx_len);
+
+        copy_from_rx_buff(local, (UCHAR *)&local->last_bcn, pkt_addr, 
+                          rx_len < sizeof(struct beacon_rx) ? 
+                          rx_len : sizeof(struct beacon_rx));
+
+	local->beacon_rxed = 1;
+        /* Get the statistics so the card counters never overflow */
+        ray_get_stats(dev);
+            break;
+    default:
+        DEBUG(0,"ray_cs unknown pkt type %2x\n", (unsigned int) readb(pmsg));
+        break;
+    }
+
+} /* end ray_rx */
+/*===========================================================================*/
+static void rx_data(struct net_device *dev, struct rcs __iomem *prcs, unsigned int pkt_addr, 
+             int rx_len)
+{
+    struct sk_buff *skb = NULL;
+    struct rcs __iomem *prcslink = prcs;
+    ray_dev_t *local = dev->priv;
+    UCHAR *rx_ptr;
+    int total_len;
+    int tmp;
+#ifdef WIRELESS_SPY
+    int siglev = local->last_rsl;
+    u_char linksrcaddr[ETH_ALEN];	/* Other end of the wireless link */
+#endif
+
+    if (!sniffer) {
+        if (translate) {
+/* TBD length needs fixing for translated header */
+            if (rx_len < (ETH_HLEN + RX_MAC_HEADER_LENGTH) ||
+                rx_len > (dev->mtu + RX_MAC_HEADER_LENGTH + ETH_HLEN + FCS_LEN)) 
+            {
+                DEBUG(0,"ray_cs invalid packet length %d received \n",rx_len);
+                return;
+            }
+        }
+        else /* encapsulated ethernet */ {
+            if (rx_len < (ETH_HLEN + RX_MAC_HEADER_LENGTH) ||
+                rx_len > (dev->mtu + RX_MAC_HEADER_LENGTH + ETH_HLEN + FCS_LEN))
+            {
+                DEBUG(0,"ray_cs invalid packet length %d received \n",rx_len);
+                return;
+            }
+        }
+    }
+    DEBUG(4,"ray_cs rx_data packet\n");
+    /* If fragmented packet, verify sizes of fragments add up */
+    if (readb(&prcs->var.rx_packet.next_frag_rcs_index) != 0xFF) {
+        DEBUG(1,"ray_cs rx'ed fragment\n");
+        tmp = (readb(&prcs->var.rx_packet.totalpacketlength[0]) << 8)
+            +  readb(&prcs->var.rx_packet.totalpacketlength[1]);
+        total_len = tmp;
+        prcslink = prcs;
+        do {
+            tmp -= (readb(&prcslink->var.rx_packet.rx_data_length[0]) << 8)
+                +   readb(&prcslink->var.rx_packet.rx_data_length[1]);
+            if (readb(&prcslink->var.rx_packet.next_frag_rcs_index) == 0xFF
+                || tmp < 0) break;
+            prcslink = rcs_base(local)
+                + readb(&prcslink->link_field);
+        } while (1);
+
+        if (tmp < 0)
+        {
+            DEBUG(0,"ray_cs rx_data fragment lengths don't add up\n");
+            local->stats.rx_dropped++; 
+            release_frag_chain(local, prcs);
+            return;
+        }
+    }
+    else { /* Single unfragmented packet */
+        total_len = rx_len;
+    }
+
+    skb = dev_alloc_skb( total_len+5 );
+    if (skb == NULL)
+    {
+        DEBUG(0,"ray_cs rx_data could not allocate skb\n");
+        local->stats.rx_dropped++; 
+        if (readb(&prcs->var.rx_packet.next_frag_rcs_index) != 0xFF)
+            release_frag_chain(local, prcs);
+        return;
+    }
+    skb_reserve( skb, 2);   /* Align IP on 16 byte (TBD check this)*/
+    skb->dev = dev;
+
+    DEBUG(4,"ray_cs rx_data total_len = %x, rx_len = %x\n",total_len,rx_len);
+
+/************************/
+    /* Reserve enough room for the whole damn packet. */
+    rx_ptr = skb_put( skb, total_len);
+    /* Copy the whole packet to sk_buff */
+    rx_ptr += copy_from_rx_buff(local, rx_ptr, pkt_addr & RX_BUFF_END, rx_len);
+    /* Get source address */
+#ifdef WIRELESS_SPY
+    memcpy(linksrcaddr, ((struct mac_header *)skb->data)->addr_2, ETH_ALEN);
+#endif
+    /* Now, deal with encapsulation/translation/sniffer */
+    if (!sniffer) {
+        if (!translate) { 
+            /* Encapsulated ethernet, so just lop off 802.11 MAC header */
+/* TBD reserve            skb_reserve( skb, RX_MAC_HEADER_LENGTH); */
+            skb_pull( skb, RX_MAC_HEADER_LENGTH);
+        }
+        else {
+            /* Do translation */
+            untranslate(local, skb, total_len);
+        }
+    }
+    else 
+    {  /* sniffer mode, so just pass whole packet */  };
+
+/************************/
+    /* Now pick up the rest of the fragments if any */
+    tmp = 17; 
+    if (readb(&prcs->var.rx_packet.next_frag_rcs_index) != 0xFF) {
+        prcslink = prcs;
+        DEBUG(1,"ray_cs rx_data in fragment loop\n");
+        do {
+            prcslink = rcs_base(local)
+                + readb(&prcslink->var.rx_packet.next_frag_rcs_index);
+            rx_len = (( readb(&prcslink->var.rx_packet.rx_data_length[0]) << 8)
+                      + readb(&prcslink->var.rx_packet.rx_data_length[1]))
+                & RX_BUFF_END;
+            pkt_addr = (( readb(&prcslink->var.rx_packet.rx_data_ptr[0]) << 8)
+                        + readb(&prcslink->var.rx_packet.rx_data_ptr[1]))
+                & RX_BUFF_END;
+
+            rx_ptr += copy_from_rx_buff(local, rx_ptr, pkt_addr, rx_len);
+
+        } while (tmp-- && 
+                 readb(&prcslink->var.rx_packet.next_frag_rcs_index) != 0xFF);
+        release_frag_chain(local, prcs);
+    }
+
+    skb->protocol = eth_type_trans(skb,dev);
+    netif_rx(skb);
+    dev->last_rx = jiffies;
+    local->stats.rx_packets++;
+    local->stats.rx_bytes += total_len;
+
+    /* Gather signal strength per address */
+#ifdef WIRELESS_SPY
+    /* For the Access Point or the node having started the ad-hoc net
+     * note : ad-hoc work only in some specific configurations, but we
+     * kludge in ray_get_wireless_stats... */
+    if(!memcmp(linksrcaddr, local->bss_id, ETH_ALEN))
+      {
+	/* Update statistics */
+	/*local->wstats.qual.qual = none ? */
+	local->wstats.qual.level = siglev;
+	/*local->wstats.qual.noise = none ? */
+	local->wstats.qual.updated = 0x2;
+      }
+    /* Now, for the addresses in the spy list */
+    {
+      int	i;
+      /* Look all addresses */
+      for(i = 0; i < local->spy_number; i++)
+	/* If match */
+	if(!memcmp(linksrcaddr, local->spy_address[i], ETH_ALEN))
+	  {
+	    /* Update statistics */
+	    /*local->spy_stat[i].qual = none ? */
+	    local->spy_stat[i].level = siglev;
+	    /*local->spy_stat[i].noise = none ? */
+	    local->spy_stat[i].updated = 0x2;
+	  }
+    }
+#endif	/* WIRELESS_SPY */
+} /* end rx_data */
+/*===========================================================================*/
+static void untranslate(ray_dev_t *local, struct sk_buff *skb, int len)
+{
+    snaphdr_t *psnap = (snaphdr_t *)(skb->data + RX_MAC_HEADER_LENGTH);
+    struct mac_header *pmac = (struct mac_header *)skb->data;
+    unsigned short type = *(unsigned short *)psnap->ethertype;
+    unsigned int xsap = *(unsigned int *)psnap & 0x00ffffff;
+    unsigned int org = (*(unsigned int *)psnap->org) & 0x00ffffff;
+    int delta;
+    struct ethhdr *peth;
+    UCHAR srcaddr[ADDRLEN];
+    UCHAR destaddr[ADDRLEN];
+
+    if (pmac->frame_ctl_2 & FC2_FROM_DS) {
+	if (pmac->frame_ctl_2 & FC2_TO_DS) { /* AP to AP */
+	    memcpy(destaddr, pmac->addr_3, ADDRLEN);
+	    memcpy(srcaddr, ((unsigned char *)pmac->addr_3) + ADDRLEN, ADDRLEN);
+	} else { /* AP to terminal */
+	    memcpy(destaddr, pmac->addr_1, ADDRLEN);
+	    memcpy(srcaddr, pmac->addr_3, ADDRLEN); 
+	}
+    } else { /* Terminal to AP */
+	if (pmac->frame_ctl_2 & FC2_TO_DS) {
+	    memcpy(destaddr, pmac->addr_3, ADDRLEN);
+	    memcpy(srcaddr, pmac->addr_2, ADDRLEN); 
+	} else { /* Adhoc */
+	    memcpy(destaddr, pmac->addr_1, ADDRLEN);
+	    memcpy(srcaddr, pmac->addr_2, ADDRLEN); 
+	}
+    }
+
+#ifdef PCMCIA_DEBUG
+    if (pc_debug > 3) {
+    int i;
+    printk(KERN_DEBUG "skb->data before untranslate");
+    for (i=0;i<64;i++) 
+        printk("%02x ",skb->data[i]);
+    printk("\n" KERN_DEBUG "type = %08x, xsap = %08x, org = %08x\n",
+           type,xsap,org);
+    printk(KERN_DEBUG "untranslate skb->data = %p\n",skb->data);
+    }
+#endif
+
+    if ( xsap != SNAP_ID) {
+        /* not a snap type so leave it alone */
+        DEBUG(3,"ray_cs untranslate NOT SNAP %x\n", *(unsigned int *)psnap & 0x00ffffff);
+
+        delta = RX_MAC_HEADER_LENGTH - ETH_HLEN;
+        peth = (struct ethhdr *)(skb->data + delta);
+        peth->h_proto = htons(len - RX_MAC_HEADER_LENGTH);
+    }
+    else { /* Its a SNAP */
+        if (org == BRIDGE_ENCAP) { /* EtherII and nuke the LLC  */
+        DEBUG(3,"ray_cs untranslate Bridge encap\n");
+            delta = RX_MAC_HEADER_LENGTH 
+                + sizeof(struct snaphdr_t) - ETH_HLEN;
+            peth = (struct ethhdr *)(skb->data + delta);
+            peth->h_proto = type;
+        }
+        else {
+            if (org == RFC1042_ENCAP) {
+                switch (type) {
+                case RAY_IPX_TYPE:
+                case APPLEARP_TYPE:
+                    DEBUG(3,"ray_cs untranslate RFC IPX/AARP\n");
+                    delta = RX_MAC_HEADER_LENGTH - ETH_HLEN;
+                    peth = (struct ethhdr *)(skb->data + delta);
+                    peth->h_proto = htons(len - RX_MAC_HEADER_LENGTH);
+                    break;
+                default:
+                    DEBUG(3,"ray_cs untranslate RFC default\n");
+                    delta = RX_MAC_HEADER_LENGTH + 
+                        sizeof(struct snaphdr_t) - ETH_HLEN;
+                    peth = (struct ethhdr *)(skb->data + delta);
+                    peth->h_proto = type;
+                    break;
+                }
+            }
+            else {
+                printk("ray_cs untranslate very confused by packet\n");
+                delta = RX_MAC_HEADER_LENGTH - ETH_HLEN;
+                peth = (struct ethhdr *)(skb->data + delta);
+                peth->h_proto = type;
+            }
+        }
+    }
+/* TBD reserve  skb_reserve(skb, delta); */
+    skb_pull(skb, delta);
+    DEBUG(3,"untranslate after skb_pull(%d), skb->data = %p\n",delta,skb->data);
+    memcpy(peth->h_dest, destaddr, ADDRLEN);
+    memcpy(peth->h_source, srcaddr, ADDRLEN);
+#ifdef PCMCIA_DEBUG
+    if (pc_debug > 3) {
+    int i;
+    printk(KERN_DEBUG "skb->data after untranslate:");
+    for (i=0;i<64;i++)
+        printk("%02x ",skb->data[i]);
+    printk("\n");
+    }
+#endif
+} /* end untranslate */
+/*===========================================================================*/
+/* Copy data from circular receive buffer to PC memory.
+ * dest     = destination address in PC memory
+ * pkt_addr = source address in receive buffer
+ * len      = length of packet to copy
+ */
+static int copy_from_rx_buff(ray_dev_t *local, UCHAR *dest, int pkt_addr, int length)
+{
+    int wrap_bytes = (pkt_addr + length) - (RX_BUFF_END + 1);
+    if (wrap_bytes <= 0)
+    {
+        memcpy_fromio(dest,local->rmem + pkt_addr,length);
+    }
+    else /* Packet wrapped in circular buffer */
+    {
+        memcpy_fromio(dest,local->rmem+pkt_addr,length - wrap_bytes);
+        memcpy_fromio(dest + length - wrap_bytes, local->rmem, wrap_bytes);
+    }
+    return length;
+}
+/*===========================================================================*/
+static void release_frag_chain(ray_dev_t *local, struct rcs __iomem * prcs)
+{
+    struct rcs __iomem *prcslink = prcs;
+    int tmp = 17;
+    unsigned rcsindex = readb(&prcs->var.rx_packet.next_frag_rcs_index);
+
+    while (tmp--) {
+        writeb(CCS_BUFFER_FREE, &prcslink->buffer_status);
+        if (rcsindex >= (NUMBER_OF_CCS + NUMBER_OF_RCS)) {
+            DEBUG(1,"ray_cs interrupt bad rcsindex = 0x%x\n",rcsindex);
+            break;      
+        }   
+        prcslink = rcs_base(local) + rcsindex;
+        rcsindex = readb(&prcslink->var.rx_packet.next_frag_rcs_index);
+    }
+    writeb(CCS_BUFFER_FREE, &prcslink->buffer_status);
+}
+/*===========================================================================*/
+static void authenticate(ray_dev_t *local)
+{
+    dev_link_t *link = local->finder;
+    DEBUG(0,"ray_cs Starting authentication.\n");
+    if (!(link->state & DEV_PRESENT)) {
+        DEBUG(2,"ray_cs authenticate - device not present\n");
+        return;
+    }
+
+    del_timer(&local->timer);
+    if (build_auth_frame(local, local->bss_id, OPEN_AUTH_REQUEST)) {
+        local->timer.function = &join_net;
+    }
+    else {
+        local->timer.function = &authenticate_timeout;
+    }
+    local->timer.expires = jiffies + HZ*2;
+    local->timer.data = (long)local;
+    add_timer(&local->timer);
+    local->authentication_state = AWAITING_RESPONSE;
+} /* end authenticate */
+/*===========================================================================*/
+static void rx_authenticate(ray_dev_t *local, struct rcs __iomem *prcs,
+                     unsigned int pkt_addr, int rx_len)
+{
+    UCHAR buff[256];
+    struct rx_msg *msg = (struct rx_msg *)buff;
+    
+    del_timer(&local->timer);
+
+    copy_from_rx_buff(local, buff, pkt_addr, rx_len & 0xff);
+    /* if we are trying to get authenticated */
+    if (local->sparm.b4.a_network_type == ADHOC) {
+        DEBUG(1,"ray_cs rx_auth var= %02x %02x %02x %02x %02x %02x\n", msg->var[0],msg->var[1],msg->var[2],msg->var[3],msg->var[4],msg->var[5]);
+        if (msg->var[2] == 1) {
+                    DEBUG(0,"ray_cs Sending authentication response.\n");
+                    if (!build_auth_frame (local, msg->mac.addr_2, OPEN_AUTH_RESPONSE)) {
+                        local->authentication_state = NEED_TO_AUTH;
+                        memcpy(local->auth_id, msg->mac.addr_2, ADDRLEN);
+                    }
+        }
+    }
+    else /* Infrastructure network */
+    {
+        if (local->authentication_state == AWAITING_RESPONSE) {
+            /* Verify authentication sequence #2 and success */
+            if (msg->var[2] == 2) {
+                if ((msg->var[3] | msg->var[4]) == 0) {
+                    DEBUG(1,"Authentication successful\n");
+                    local->card_status = CARD_AUTH_COMPLETE;
+                    associate(local);
+                    local->authentication_state = AUTHENTICATED;
+                }
+                else {
+                    DEBUG(0,"Authentication refused\n");
+                    local->card_status = CARD_AUTH_REFUSED;
+                    join_net((u_long)local);
+                    local->authentication_state = UNAUTHENTICATED;
+                }
+            }
+        }
+    }
+
+} /* end rx_authenticate */
+/*===========================================================================*/
+static void associate(ray_dev_t *local)
+{
+    struct ccs __iomem *pccs;
+    dev_link_t *link = local->finder;
+    struct net_device *dev = link->priv;
+    int ccsindex;
+    if (!(link->state & DEV_PRESENT)) {
+        DEBUG(2,"ray_cs associate - device not present\n");
+        return;
+    }
+    /* If no tx buffers available, return*/
+    if ((ccsindex = get_free_ccs(local)) < 0)
+    {
+/* TBD should never be here but... what if we are? */
+        DEBUG(1,"ray_cs associate - No free ccs\n");
+        return;
+    }
+    DEBUG(1,"ray_cs Starting association with access point\n");
+    pccs = ccs_base(local) + ccsindex;
+    /* fill in the CCS */
+    writeb(CCS_START_ASSOCIATION, &pccs->cmd);
+    /* Interrupt the firmware to process the command */
+    if (interrupt_ecf(local, ccsindex)) {
+        DEBUG(1,"ray_cs associate failed - ECF not ready for intr\n");
+        writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
+
+        del_timer(&local->timer);
+        local->timer.expires = jiffies + HZ*2;
+        local->timer.data = (long)local;
+        local->timer.function = &join_net;
+        add_timer(&local->timer);
+        local->card_status = CARD_ASSOC_FAILED;
+        return;
+    }
+    if (!sniffer) netif_start_queue(dev);
+
+} /* end associate */
+/*===========================================================================*/
+static void rx_deauthenticate(ray_dev_t *local, struct rcs __iomem *prcs, 
+                       unsigned int pkt_addr, int rx_len)
+{
+/*  UCHAR buff[256];
+    struct rx_msg *msg = (struct rx_msg *)buff;
+*/
+    DEBUG(0,"Deauthentication frame received\n");
+    local->authentication_state = UNAUTHENTICATED;
+    /* Need to reauthenticate or rejoin depending on reason code */
+/*  copy_from_rx_buff(local, buff, pkt_addr, rx_len & 0xff);
+ */
+}
+/*===========================================================================*/
+static void clear_interrupt(ray_dev_t *local)
+{
+    writeb(0, local->amem + CIS_OFFSET + HCS_INTR_OFFSET);
+}
+/*===========================================================================*/
+#ifdef CONFIG_PROC_FS
+#define MAXDATA (PAGE_SIZE - 80)
+
+static char *card_status[] = {
+    "Card inserted - uninitialized",     /* 0 */
+    "Card not downloaded",               /* 1 */
+    "Waiting for download parameters",   /* 2 */
+    "Card doing acquisition",            /* 3 */
+    "Acquisition complete",              /* 4 */
+    "Authentication complete",           /* 5 */
+    "Association complete",              /* 6 */
+    "???", "???", "???", "???",          /* 7 8 9 10 undefined */
+    "Card init error",                   /* 11 */
+    "Download parameters error",         /* 12 */
+    "???",                               /* 13 */
+    "Acquisition failed",                /* 14 */
+    "Authentication refused",            /* 15 */
+    "Association failed"                 /* 16 */
+};
+
+static char *nettype[] = {"Adhoc", "Infra "};
+static char *framing[] = {"Encapsulation", "Translation"}
+;
+/*===========================================================================*/
+static int ray_cs_proc_read(char *buf, char **start, off_t offset, int len)
+{
+/* Print current values which are not available via other means
+ * eg ifconfig 
+ */
+    int i;
+    dev_link_t *link;
+    struct net_device *dev;
+    ray_dev_t *local;
+    UCHAR *p;
+    struct freq_hop_element *pfh;
+    UCHAR c[33];
+
+    link = dev_list;
+    if (!link)
+    	return 0;
+    dev = (struct net_device *)link->priv;
+    if (!dev)
+    	return 0;
+    local = (ray_dev_t *)dev->priv;
+    if (!local)
+    	return 0;
+
+    len = 0;
+
+    len += sprintf(buf + len, "Raylink Wireless LAN driver status\n");
+    len += sprintf(buf + len, "%s\n", rcsid);
+    /* build 4 does not report version, and field is 0x55 after memtest */
+    len += sprintf(buf + len, "Firmware version     = ");
+    if (local->fw_ver == 0x55)
+        len += sprintf(buf + len, "4 - Use dump_cis for more details\n");
+    else
+        len += sprintf(buf + len, "%2d.%02d.%02d\n",
+                   local->fw_ver, local->fw_bld, local->fw_var);
+
+    for (i=0; i<32; i++) c[i] = local->sparm.b5.a_current_ess_id[i];
+    c[32] = 0;
+    len += sprintf(buf + len, "%s network ESSID = \"%s\"\n", 
+                   nettype[local->sparm.b5.a_network_type], c);
+
+    p = local->bss_id;
+    len += sprintf(buf + len, 
+                   "BSSID                = %02x:%02x:%02x:%02x:%02x:%02x\n",
+                   p[0],p[1],p[2],p[3],p[4],p[5]);
+
+    len += sprintf(buf + len, "Country code         = %d\n", 
+                   local->sparm.b5.a_curr_country_code);
+
+    i = local->card_status;
+    if (i < 0) i = 10;
+    if (i > 16) i = 10;
+    len += sprintf(buf + len, "Card status          = %s\n", card_status[i]);
+
+    len += sprintf(buf + len, "Framing mode         = %s\n",framing[translate]);
+
+    len += sprintf(buf + len, "Last pkt signal lvl  = %d\n", local->last_rsl);
+
+    if (local->beacon_rxed) {
+	/* Pull some fields out of last beacon received */
+	len += sprintf(buf + len, "Beacon Interval      = %d Kus\n", 
+		       local->last_bcn.beacon_intvl[0]
+		       + 256 * local->last_bcn.beacon_intvl[1]);
+    
+    p = local->last_bcn.elements;
+    if (p[0] == C_ESSID_ELEMENT_ID) p += p[1] + 2;
+    else {
+        len += sprintf(buf + len, "Parse beacon failed at essid element id = %d\n",p[0]);
+        return len;
+    }
+
+    if (p[0] == C_SUPPORTED_RATES_ELEMENT_ID) {
+        len += sprintf(buf + len, "Supported rate codes = ");
+        for (i=2; i<p[1] + 2; i++) 
+            len += sprintf(buf + len, "0x%02x ", p[i]);
+        len += sprintf(buf + len, "\n");
+        p += p[1] + 2;
+    }
+    else {
+        len += sprintf(buf + len, "Parse beacon failed at rates element\n");
+        return len;
+    }
+
+	if (p[0] == C_FH_PARAM_SET_ELEMENT_ID) {
+	    pfh = (struct freq_hop_element *)p;
+	    len += sprintf(buf + len, "Hop dwell            = %d Kus\n",
+			   pfh->dwell_time[0] + 256 * pfh->dwell_time[1]);
+	    len += sprintf(buf + len, "Hop set              = %d \n", pfh->hop_set);
+	    len += sprintf(buf + len, "Hop pattern          = %d \n", pfh->hop_pattern);
+	    len += sprintf(buf + len, "Hop index            = %d \n", pfh->hop_index);
+	    p += p[1] + 2;
+	}
+	else {
+	    len += sprintf(buf + len, "Parse beacon failed at FH param element\n");
+	    return len;
+	}
+    } else {
+	len += sprintf(buf + len, "No beacons received\n");
+    }
+    return len;
+}
+
+#endif
+/*===========================================================================*/
+static int build_auth_frame(ray_dev_t *local, UCHAR *dest, int auth_type)
+{
+    int addr;
+    struct ccs __iomem *pccs;
+    struct tx_msg __iomem *ptx;
+    int ccsindex;
+
+    /* If no tx buffers available, return */
+    if ((ccsindex = get_free_tx_ccs(local)) < 0)
+    {
+        DEBUG(1,"ray_cs send authenticate - No free tx ccs\n");
+        return -1;
+    }
+
+    pccs = ccs_base(local) + ccsindex;
+
+    /* Address in card space */
+    addr = TX_BUF_BASE + (ccsindex << 11);
+    /* fill in the CCS */
+    writeb(CCS_TX_REQUEST, &pccs->cmd);
+    writeb(addr >> 8, pccs->var.tx_request.tx_data_ptr);
+    writeb(0x20, pccs->var.tx_request.tx_data_ptr + 1);
+    writeb(TX_AUTHENTICATE_LENGTH_MSB, pccs->var.tx_request.tx_data_length);
+    writeb(TX_AUTHENTICATE_LENGTH_LSB,pccs->var.tx_request.tx_data_length + 1);
+    writeb(0, &pccs->var.tx_request.pow_sav_mode);
+
+    ptx = local->sram + addr;
+    /* fill in the mac header */
+    writeb(PROTOCOL_VER | AUTHENTIC_TYPE, &ptx->mac.frame_ctl_1);
+    writeb(0, &ptx->mac.frame_ctl_2);
+
+    memcpy_toio(ptx->mac.addr_1, dest, ADDRLEN);
+    memcpy_toio(ptx->mac.addr_2, local->sparm.b4.a_mac_addr, ADDRLEN);
+    memcpy_toio(ptx->mac.addr_3, local->bss_id, ADDRLEN);
+
+    /* Fill in msg body with protocol 00 00, sequence 01 00 ,status 00 00 */
+    memset_io(ptx->var, 0, 6);
+    writeb(auth_type & 0xff, ptx->var + 2);
+
+    /* Interrupt the firmware to process the command */
+    if (interrupt_ecf(local, ccsindex)) {
+        DEBUG(1,"ray_cs send authentication request failed - ECF not ready for intr\n");
+        writeb(CCS_BUFFER_FREE, &(pccs++)->buffer_status);
+        return -1;
+    }
+    return 0;
+} /* End build_auth_frame */
+
+/*===========================================================================*/
+#ifdef CONFIG_PROC_FS
+static void raycs_write(const char *name, write_proc_t *w, void *data)
+{
+	struct proc_dir_entry * entry = create_proc_entry(name, S_IFREG | S_IWUSR, NULL);
+	if (entry) {
+		entry->write_proc = w;
+		entry->data = data;
+	}
+}
+
+static int write_essid(struct file *file, const char __user *buffer, unsigned long count, void *data)
+{
+	static char proc_essid[33];
+	int len = count;
+
+	if (len > 32)
+		len = 32;
+	memset(proc_essid, 0, 33);
+	if (copy_from_user(proc_essid, buffer, len))
+		return -EFAULT;
+	essid = proc_essid;
+	return count;
+}
+
+static int write_int(struct file *file, const char __user *buffer, unsigned long count, void *data)
+{
+	static char proc_number[10];
+	char *p;
+	int nr, len;
+
+	if (!count)
+		return 0;
+
+	if (count > 9)
+		return -EINVAL;
+	if (copy_from_user(proc_number, buffer, count))
+		return -EFAULT;
+	p = proc_number;
+	nr = 0;
+	len = count;
+	do {
+		unsigned int c = *p - '0';
+		if (c > 9)
+			return -EINVAL;
+		nr = nr*10 + c;
+		p++;
+	} while (--len);
+	*(int *)data = nr;
+	return count;
+}
+#endif
+
+static struct pcmcia_driver ray_driver = {
+	.owner		= THIS_MODULE,
+	.drv		= {
+		.name	= "ray_cs",
+	},
+	.attach		= ray_attach,
+	.detach		= ray_detach,
+};
+
+static int __init init_ray_cs(void)
+{
+    int rc;
+    
+    DEBUG(1, "%s\n", rcsid);
+    rc = pcmcia_register_driver(&ray_driver);
+    DEBUG(1, "raylink init_module register_pcmcia_driver returns 0x%x\n",rc);
+
+#ifdef CONFIG_PROC_FS
+    proc_mkdir("driver/ray_cs", NULL);
+
+    create_proc_info_entry("driver/ray_cs/ray_cs", 0, NULL, &ray_cs_proc_read);
+    raycs_write("driver/ray_cs/essid", write_essid, NULL);
+    raycs_write("driver/ray_cs/net_type", write_int, &net_type);
+    raycs_write("driver/ray_cs/translate", write_int, &translate);
+#endif
+    if (translate != 0) translate = 1;
+    return 0;
+} /* init_ray_cs */
+
+/*===========================================================================*/
+
+static void __exit exit_ray_cs(void)
+{
+    DEBUG(0, "ray_cs: cleanup_module\n");
+
+#ifdef CONFIG_PROC_FS
+    remove_proc_entry("driver/ray_cs/ray_cs", NULL);
+    remove_proc_entry("driver/ray_cs/essid", NULL);
+    remove_proc_entry("driver/ray_cs/net_type", NULL);
+    remove_proc_entry("driver/ray_cs/translate", NULL);
+    remove_proc_entry("driver/ray_cs", NULL);
+#endif
+
+    pcmcia_unregister_driver(&ray_driver);
+    BUG_ON(dev_list != NULL);
+} /* exit_ray_cs */
+
+module_init(init_ray_cs);
+module_exit(exit_ray_cs);
+
+/*===========================================================================*/
