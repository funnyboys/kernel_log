commit 98749b7188affbf2900c2aab704a8853901d1139
Author: Wang Hai <wanghai38@huawei.com>
Date:   Thu Jun 4 20:18:51 2020 +0800

    yam: fix possible memory leak in yam_init_driver
    
    If register_netdev(dev) fails, free_netdev(dev) needs
    to be called, otherwise a memory leak will occur.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Wang Hai <wanghai38@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 71cdef9fb56b..5ab53e9942f3 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -1133,6 +1133,7 @@ static int __init yam_init_driver(void)
 		err = register_netdev(dev);
 		if (err) {
 			printk(KERN_WARNING "yam: cannot register net device %s\n", dev->name);
+			free_netdev(dev);
 			goto error;
 		}
 		yam_devs[i] = dev;

commit 3f5296f0e86d6acc92535e44b71945255c28ce5f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 09:19:10 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 69
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      675 mass ave cambridge ma 02139 usa please note that the gpl allows
      you to use the driver not the radio in order to use the radio you
      need a license from the communications authority of your country
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 7 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520071859.472520794@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index ba9df430fca6..71cdef9fb56b 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*****************************************************************************/
 
 /*
@@ -6,25 +7,10 @@
  *      Copyright (C) 1998 Frederic Rible F1OAT (frible@teaser.fr)
  *      Adapted from baycom.c driver written by Thomas Sailer (sailer@ife.ee.ethz.ch)
  *
- *      This program is free software; you can redistribute it and/or modify
- *      it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
- *
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
  *  Please note that the GPL allows you to use the driver, NOT the radio.
  *  In order to use the radio, you need a license from the communications
  *  authority of your country.
  *
- *
  *  History:
  *   0.0 F1OAT 06.06.98  Begin of work with baycom.c source code V 0.3
  *   0.1 F1OAT 07.06.98  Add timer polling routine for channel arbitration
@@ -37,7 +23,6 @@
  *   0.8 F6FBB 14.10.98  Fixed slottime/persistence timing bug
  *       OK1ZIA 2.09.01  Fixed "kfree_skb on hard IRQ" 
  *                       using dev_kfree_skb_any(). (important in 2.4 kernel)
- *   
  */
 
 /*****************************************************************************/

commit 0781168e23a2fc8dceb989f11fc5b39b3ccacc35
Author: Wenwen Wang <wang6495@umn.edu>
Date:   Fri Oct 5 10:59:36 2018 -0500

    yam: fix a missing-check bug
    
    In yam_ioctl(), the concrete ioctl command is firstly copied from the
    user-space buffer 'ifr->ifr_data' to 'ioctl_cmd' and checked through the
    following switch statement. If the command is not as expected, an error
    code EINVAL is returned. In the following execution the buffer
    'ifr->ifr_data' is copied again in the cases of the switch statement to
    specific data structures according to what kind of ioctl command is
    requested. However, after the second copy, no re-check is enforced on the
    newly-copied command. Given that the buffer 'ifr->ifr_data' is in the user
    space, a malicious user can race to change the command between the two
    copies. This way, the attacker can inject inconsistent data and cause
    undefined behavior.
    
    This patch adds a re-check in each case of the switch statement if there is
    a second copy in that case, to re-check whether the command obtained in the
    second copy is the same as the one in the first copy. If not, an error code
    EINVAL will be returned.
    
    Signed-off-by: Wenwen Wang <wang6495@umn.edu>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 16ec7af6ab7b..ba9df430fca6 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -966,6 +966,8 @@ static int yam_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 				 sizeof(struct yamdrv_ioctl_mcs));
 		if (IS_ERR(ym))
 			return PTR_ERR(ym);
+		if (ym->cmd != SIOCYAMSMCS)
+			return -EINVAL;
 		if (ym->bitrate > YAM_MAXBITRATE) {
 			kfree(ym);
 			return -EINVAL;
@@ -981,6 +983,8 @@ static int yam_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 		if (copy_from_user(&yi, ifr->ifr_data, sizeof(struct yamdrv_ioctl_cfg)))
 			 return -EFAULT;
 
+		if (yi.cmd != SIOCYAMSCFG)
+			return -EINVAL;
 		if ((yi.cfg.mask & YAM_IOBASE) && netif_running(dev))
 			return -EINVAL;		/* Cannot change this parameter when up */
 		if ((yi.cfg.mask & YAM_IRQ) && netif_running(dev))

commit fddda2b7b521185f3aa018f9559eb33b0aee53a9
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Apr 13 19:44:18 2018 +0200

    proc: introduce proc_create_seq{,_data}
    
    Variants of proc_create{,_data} that directly take a struct seq_operations
    argument and drastically reduces the boilerplate code in the callers.
    
    All trivial callers converted over.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 83034eb7ed4f..16ec7af6ab7b 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -841,20 +841,6 @@ static const struct seq_operations yam_seqops = {
 	.stop = yam_seq_stop,
 	.show = yam_seq_show,
 };
-
-static int yam_info_open(struct inode *inode, struct file *file)
-{
-	return seq_open(file, &yam_seqops);
-}
-
-static const struct file_operations yam_info_fops = {
-	.owner = THIS_MODULE,
-	.open = yam_info_open,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = seq_release,
-};
-
 #endif
 
 
@@ -1168,7 +1154,7 @@ static int __init yam_init_driver(void)
 	yam_timer.expires = jiffies + HZ / 100;
 	add_timer(&yam_timer);
 
-	proc_create("yam", 0444, init_net.proc_net, &yam_info_fops);
+	proc_create_seq("yam", 0444, init_net.proc_net, &yam_seqops);
 	return 0;
  error:
 	while (--i >= 0) {

commit d61e40385655fbba659fc3d81df9bdf1b848e263
Author: Joe Perches <joe@perches.com>
Date:   Fri Mar 23 15:54:39 2018 -0700

    drivers/net: Use octal not symbolic permissions
    
    Prefer the direct use of octal for permissions.
    
    Done with checkpatch -f --types=SYMBOLIC_PERMS --fix-inplace
    and some typing.
    
    Miscellanea:
    
    o Whitespace neatening around these conversions.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Reviewed-by: Wei Liu <wei.liu2@citrix.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 14c3632b8cde..83034eb7ed4f 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -1168,7 +1168,7 @@ static int __init yam_init_driver(void)
 	yam_timer.expires = jiffies + HZ / 100;
 	add_timer(&yam_timer);
 
-	proc_create("yam", S_IRUGO, init_net.proc_net, &yam_info_fops);
+	proc_create("yam", 0444, init_net.proc_net, &yam_info_fops);
 	return 0;
  error:
 	while (--i >= 0) {

commit 5bbcc0f595fadb4cac0eddc4401035ec0bd95b09
Merge: 892204e06cb9 50895b9de1d3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 15 11:56:19 2017 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next
    
    Pull networking updates from David Miller:
     "Highlights:
    
       1) Maintain the TCP retransmit queue using an rbtree, with 1GB
          windows at 100Gb this really has become necessary. From Eric
          Dumazet.
    
       2) Multi-program support for cgroup+bpf, from Alexei Starovoitov.
    
       3) Perform broadcast flooding in hardware in mv88e6xxx, from Andrew
          Lunn.
    
       4) Add meter action support to openvswitch, from Andy Zhou.
    
       5) Add a data meta pointer for BPF accessible packets, from Daniel
          Borkmann.
    
       6) Namespace-ify almost all TCP sysctl knobs, from Eric Dumazet.
    
       7) Turn on Broadcom Tags in b53 driver, from Florian Fainelli.
    
       8) More work to move the RTNL mutex down, from Florian Westphal.
    
       9) Add 'bpftool' utility, to help with bpf program introspection.
          From Jakub Kicinski.
    
      10) Add new 'cpumap' type for XDP_REDIRECT action, from Jesper
          Dangaard Brouer.
    
      11) Support 'blocks' of transformations in the packet scheduler which
          can span multiple network devices, from Jiri Pirko.
    
      12) TC flower offload support in cxgb4, from Kumar Sanghvi.
    
      13) Priority based stream scheduler for SCTP, from Marcelo Ricardo
          Leitner.
    
      14) Thunderbolt networking driver, from Amir Levy and Mika Westerberg.
    
      15) Add RED qdisc offloadability, and use it in mlxsw driver. From
          Nogah Frankel.
    
      16) eBPF based device controller for cgroup v2, from Roman Gushchin.
    
      17) Add some fundamental tracepoints for TCP, from Song Liu.
    
      18) Remove garbage collection from ipv6 route layer, this is a
          significant accomplishment. From Wei Wang.
    
      19) Add multicast route offload support to mlxsw, from Yotam Gigi"
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next: (2177 commits)
      tcp: highest_sack fix
      geneve: fix fill_info when link down
      bpf: fix lockdep splat
      net: cdc_ncm: GetNtbFormat endian fix
      openvswitch: meter: fix NULL pointer dereference in ovs_meter_cmd_reply_start
      netem: remove unnecessary 64 bit modulus
      netem: use 64 bit divide by rate
      tcp: Namespace-ify sysctl_tcp_default_congestion_control
      net: Protect iterations over net::fib_notifier_ops in fib_seq_sum()
      ipv6: set all.accept_dad to 0 by default
      uapi: fix linux/tls.h userspace compilation error
      usbnet: ipheth: prevent TX queue timeouts when device not ready
      vhost_net: conditionally enable tx polling
      uapi: fix linux/rxrpc.h userspace compilation errors
      net: stmmac: fix LPI transitioning for dwmac4
      atm: horizon: Fix irq release error
      net-sysfs: trigger netlink notification on ifalias change via sysfs
      openvswitch: Using kfree_rcu() to simplify the code
      openvswitch: Make local function ovs_nsh_key_attr_size() static
      openvswitch: Fix return value check in ovs_meter_cmd_features()
      ...

commit f6fd8918f04191a3e24a0717e97520b65a7d6c4e
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 25 03:51:20 2017 -0700

    drivers/net: hamradio/yam: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly. Initialization was entirely missing.
    
    Cc: Jean-Paul Roubelat <jpr@f6fbb.org>
    Cc: linux-hams@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 7a7c5224a336..b88c5cc00a63 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -647,7 +647,7 @@ static void yam_arbitrate(struct net_device *dev)
 	yam_start_tx(dev, yp);
 }
 
-static void yam_dotimer(unsigned long dummy)
+static void yam_dotimer(struct timer_list *unused)
 {
 	int i;
 
@@ -1164,7 +1164,7 @@ static int __init yam_init_driver(void)
 
 	}
 
-	yam_timer.function = yam_dotimer;
+	timer_setup(&yam_timer, yam_dotimer, 0);
 	yam_timer.expires = jiffies + HZ / 100;
 	add_timer(&yam_timer);
 

commit 1d27e3e2252ba9d949ca82fbdb73cde102cb2067
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 4 16:27:04 2017 -0700

    timer: Remove expires and data arguments from DEFINE_TIMER
    
    Drop the arguments from the macro and adjust all callers with the
    following script:
    
      perl -pi -e 's/DEFINE_TIMER\((.*), 0, 0\);/DEFINE_TIMER($1);/g;' \
        $(git grep DEFINE_TIMER | cut -d: -f1 | sort -u | grep -v timer.h)
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org> # for m68k parts
    Acked-by: Guenter Roeck <linux@roeck-us.net> # for watchdog parts
    Acked-by: David S. Miller <davem@davemloft.net> # for networking parts
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Kalle Valo <kvalo@codeaurora.org> # for wireless parts
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-mips@linux-mips.org
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Lai Jiangshan <jiangshanlai@gmail.com>
    Cc: Sebastian Reichel <sre@kernel.org>
    Cc: Kalle Valo <kvalo@qca.qualcomm.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: linux1394-devel@lists.sourceforge.net
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: linux-s390@vger.kernel.org
    Cc: linux-wireless@vger.kernel.org
    Cc: "James E.J. Bottomley" <jejb@linux.vnet.ibm.com>
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Ursula Braun <ubraun@linux.vnet.ibm.com>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Harish Patil <harish.patil@cavium.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Michael Reed <mdr@sgi.com>
    Cc: Manish Chopra <manish.chopra@cavium.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-pm@vger.kernel.org
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Julian Wiedmann <jwi@linux.vnet.ibm.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: linux-watchdog@vger.kernel.org
    Cc: linux-scsi@vger.kernel.org
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: netdev@vger.kernel.org
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lkml.kernel.org/r/1507159627-127660-11-git-send-email-keescook@chromium.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 7a7c5224a336..104f71fa9c5e 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -157,7 +157,7 @@ static struct net_device *yam_devs[NR_PORTS];
 
 static struct yam_mcs *yam_data;
 
-static DEFINE_TIMER(yam_timer, NULL, 0, 0);
+static DEFINE_TIMER(yam_timer, NULL);
 
 /* --------------------------------------------------------------------- */
 

commit 871ff2ebe0af0d7f1050bfc8bce62fddea2b12ec
Author: Geliang Tang <geliangtang@gmail.com>
Date:   Sat May 6 23:42:22 2017 +0800

    yam: use memdup_user
    
    Use memdup_user() helper instead of open-coding to simplify the code.
    
    Signed-off-by: Geliang Tang <geliangtang@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index b6891ada1d7b..7a7c5224a336 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -976,12 +976,10 @@ static int yam_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	case SIOCYAMSMCS:
 		if (netif_running(dev))
 			return -EINVAL;		/* Cannot change this parameter when up */
-		if ((ym = kmalloc(sizeof(struct yamdrv_ioctl_mcs), GFP_KERNEL)) == NULL)
-			return -ENOBUFS;
-		if (copy_from_user(ym, ifr->ifr_data, sizeof(struct yamdrv_ioctl_mcs))) {
-			kfree(ym);
-			return -EFAULT;
-		}
+		ym = memdup_user(ifr->ifr_data,
+				 sizeof(struct yamdrv_ioctl_mcs));
+		if (IS_ERR(ym))
+			return PTR_ERR(ym);
 		if (ym->bitrate > YAM_MAXBITRATE) {
 			kfree(ym);
 			return -EINVAL;

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index aaff07c10058..b6891ada1d7b 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -68,7 +68,7 @@
 #include <linux/seq_file.h>
 #include <net/net_namespace.h>
 
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <linux/init.h>
 
 #include <linux/yam.h>

commit 860e9538a9482bb84589f7d0718a7e6d0a944d58
Author: Florian Westphal <fw@strlen.de>
Date:   Tue May 3 16:33:13 2016 +0200

    treewide: replace dev->trans_start update with helper
    
    Replace all trans_start updates with netif_trans_update helper.
    change was done via spatch:
    
    struct net_device *d;
    @@
    - d->trans_start = jiffies
    + netif_trans_update(d)
    
    Compile tested only.
    
    Cc: user-mode-linux-devel@lists.sourceforge.net
    Cc: linux-xtensa@linux-xtensa.org
    Cc: linux1394-devel@lists.sourceforge.net
    Cc: linux-rdma@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Cc: MPT-FusionLinux.pdl@broadcom.com
    Cc: linux-scsi@vger.kernel.org
    Cc: linux-can@vger.kernel.org
    Cc: linux-parisc@vger.kernel.org
    Cc: linux-omap@vger.kernel.org
    Cc: linux-hams@vger.kernel.org
    Cc: linux-usb@vger.kernel.org
    Cc: linux-wireless@vger.kernel.org
    Cc: linux-s390@vger.kernel.org
    Cc: devel@driverdev.osuosl.org
    Cc: b.a.t.m.a.n@lists.open-mesh.org
    Cc: linux-bluetooth@vger.kernel.org
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Mugunthan V N <mugunthanvnm@ti.com>
    Acked-by: Antonio Quartulli <a@unstable.cc>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 1a4729c36aa4..aaff07c10058 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -601,7 +601,7 @@ static netdev_tx_t yam_send_packet(struct sk_buff *skb,
 		return ax25_ip_xmit(skb);
 
 	skb_queue_tail(&yp->send_queue, skb);
-	dev->trans_start = jiffies;
+	netif_trans_update(dev);
 	return NETDEV_TX_OK;
 }
 

commit 1d5da757da860a6916adbf68b09e868062b4b3b8
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Mar 3 09:41:47 2015 -0600

    ax25: Stop using magic neighbour cache operations.
    
    Before the ax25 stack calls dev_queue_xmit it always calls
    ax25_type_trans which sets skb->protocol to ETH_P_AX25.
    
    Which means that by looking at the protocol type it is possible to
    detect IP packets that have not been munged by the ax25 stack in
    ndo_start_xmit and call a function to munge them.
    
    Rename ax25_neigh_xmit to ax25_ip_xmit and tweak the return type and
    value to be appropriate for an ndo_start_xmit function.
    
    Update all of the ax25 devices to test the protocol type for ETH_P_IP
    and return ax25_ip_xmit as the first thing they do.  This preserves
    the existing semantics of IP packet processing, but the timing will be
    a little different as the IP packets now pass through the qdisc layer
    before reaching the ax25 ip packet processing.
    
    Remove the now unnecessary ax25 neighbour table operations.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 89d9da7a0c51..1a4729c36aa4 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -597,6 +597,9 @@ static netdev_tx_t yam_send_packet(struct sk_buff *skb,
 {
 	struct yam_port *yp = netdev_priv(dev);
 
+	if (skb->protocol == htons(ETH_P_IP))
+		return ax25_ip_xmit(skb);
+
 	skb_queue_tail(&yp->send_queue, skb);
 	dev->trans_start = jiffies;
 	return NETDEV_TX_OK;
@@ -1100,7 +1103,6 @@ static const struct net_device_ops yam_netdev_ops = {
 	.ndo_start_xmit      = yam_send_packet,
 	.ndo_do_ioctl 	     = yam_ioctl,
 	.ndo_set_mac_address = yam_set_mac_address,
-	.ndo_neigh_construct = ax25_neigh_construct,
 };
 
 static void yam_setup(struct net_device *dev)
@@ -1129,7 +1131,6 @@ static void yam_setup(struct net_device *dev)
 	dev->header_ops = &ax25_header_ops;
 
 	dev->type = ARPHRD_AX25;
-	dev->neigh_priv_len = sizeof(struct ax25_neigh_priv);
 	dev->hard_header_len = AX25_MAX_HEADER_LEN;
 	dev->mtu = AX25_MTU;
 	dev->addr_len = AX25_ADDR_LEN;

commit 3b6a94bed0029a6b48055d89b8dea0567abca0ac
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Mar 2 00:05:28 2015 -0600

    ax25: Refactor to use private neighbour operations.
    
    AX25 already has it's own private arp cache operations to isolate
    it's abuse of dev_rebuild_header to transmit packets.  Add a function
    ax25_neigh_construct that will allow all of the ax25 devices to
    force using these operations, so that the generic arp code does
    not need to.
    
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-hams@vger.kernel.org
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 717433cfb81d..89d9da7a0c51 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -1100,6 +1100,7 @@ static const struct net_device_ops yam_netdev_ops = {
 	.ndo_start_xmit      = yam_send_packet,
 	.ndo_do_ioctl 	     = yam_ioctl,
 	.ndo_set_mac_address = yam_set_mac_address,
+	.ndo_neigh_construct = ax25_neigh_construct,
 };
 
 static void yam_setup(struct net_device *dev)
@@ -1128,6 +1129,7 @@ static void yam_setup(struct net_device *dev)
 	dev->header_ops = &ax25_header_ops;
 
 	dev->type = ARPHRD_AX25;
+	dev->neigh_priv_len = sizeof(struct ax25_neigh_priv);
 	dev->hard_header_len = AX25_MAX_HEADER_LEN;
 	dev->mtu = AX25_MTU;
 	dev->addr_len = AX25_ADDR_LEN;

commit c835a677331495cf137a7f8a023463afd9f032f8
Author: Tom Gundersen <teg@jklm.no>
Date:   Mon Jul 14 16:37:24 2014 +0200

    net: set name_assign_type in alloc_netdev()
    
    Extend alloc_netdev{,_mq{,s}}() to take name_assign_type as argument, and convert
    all users to pass NET_NAME_UNKNOWN.
    
    Coccinelle patch:
    
    @@
    expression sizeof_priv, name, setup, txqs, rxqs, count;
    @@
    
    (
    -alloc_netdev_mqs(sizeof_priv, name, setup, txqs, rxqs)
    +alloc_netdev_mqs(sizeof_priv, name, NET_NAME_UNKNOWN, setup, txqs, rxqs)
    |
    -alloc_netdev_mq(sizeof_priv, name, setup, count)
    +alloc_netdev_mq(sizeof_priv, name, NET_NAME_UNKNOWN, setup, count)
    |
    -alloc_netdev(sizeof_priv, name, setup)
    +alloc_netdev(sizeof_priv, name, NET_NAME_UNKNOWN, setup)
    )
    
    v9: move comments here from the wrong commit
    
    Signed-off-by: Tom Gundersen <teg@jklm.no>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 81901659cc9e..717433cfb81d 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -1147,7 +1147,7 @@ static int __init yam_init_driver(void)
 		sprintf(name, "yam%d", i);
 		
 		dev = alloc_netdev(sizeof(struct yam_port), name,
-				   yam_setup);
+				   NET_NAME_UNKNOWN, yam_setup);
 		if (!dev) {
 			pr_err("yam: cannot allocate net device\n");
 			err = -ENOMEM;

commit d3be267d359f621782010cd4fe4e70c9ec1cd24d
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Wed Mar 26 22:33:45 2014 +0100

    yam: replace del_timer by del_timer_sync
    
    Use del_timer_sync to ensure that the timer is stopped on all CPUs before
    the driver exists.
    
    This change was suggested by Thomas Gleixner
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r@
    declarer name module_exit;
    identifier ex;
    @@
    
    module_exit(ex);
    
    @@
    identifier r.ex;
    @@
    
    ex(...) {
      <...
    - del_timer
    + del_timer_sync
        (...)
      ...>
    }
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 61dd2447e1bb..81901659cc9e 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -1184,7 +1184,7 @@ static void __exit yam_cleanup_driver(void)
 	struct yam_mcs *p;
 	int i;
 
-	del_timer(&yam_timer);
+	del_timer_sync(&yam_timer);
 	for (i = 0; i < NR_PORTS; i++) {
 		struct net_device *dev = yam_devs[i];
 		if (dev) {

commit 8e3fbf870481eb53b2d3a322d1fc395ad8b367ed
Author: Salva Peiró <speiro@ai2.upv.es>
Date:   Tue Dec 17 10:06:30 2013 +0100

    hamradio/yam: fix info leak in ioctl
    
    The yam_ioctl() code fails to initialise the cmd field
    of the struct yamdrv_ioctl_cfg. Add an explicit memset(0)
    before filling the structure to avoid the 4-byte info leak.
    
    Signed-off-by: Salva Peiró <speiro@ai2.upv.es>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 1971411574db..61dd2447e1bb 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -1057,6 +1057,7 @@ static int yam_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 		break;
 
 	case SIOCYAMGCFG:
+		memset(&yi, 0, sizeof(yi));
 		yi.cfg.mask = 0xffffffff;
 		yi.cfg.iobase = yp->iobase;
 		yi.cfg.irq = yp->irq;

commit c3fa32b9764dc45dcf8a2231b1c110abc4a63e0b
Merge: 34d92d5315b6 320437af954c
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Oct 23 16:28:39 2013 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            drivers/net/usb/qmi_wwan.c
            include/net/dst.h
    
    Trivial merge conflicts, both were overlapping changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 39bb93f88c5db54cbe1df0b0aa957b3a8f2227ed
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Oct 14 15:46:15 2013 +0300

    yam: remove a no-op in yam_ioctl()
    
    We overwrite the ->bitrate with the user supplied information on the
    next line.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 0721e72f9299..5af1c3e5032a 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -975,7 +975,6 @@ static int yam_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 			return -EINVAL;		/* Cannot change this parameter when up */
 		if ((ym = kmalloc(sizeof(struct yamdrv_ioctl_mcs), GFP_KERNEL)) == NULL)
 			return -ENOBUFS;
-		ym->bitrate = 9600;
 		if (copy_from_user(ym, ifr->ifr_data, sizeof(struct yamdrv_ioctl_mcs))) {
 			kfree(ym);
 			return -EFAULT;

commit bfdd56b27594160f93d09a79d822e17a904c6247
Author: Michael Opdenacker <michael.opdenacker@free-electrons.com>
Date:   Sat Oct 5 06:25:46 2013 +0200

    net: hamradio/yam: remove deprecated IRQF_DISABLED
    
    This patch proposes to remove the use of the IRQF_DISABLED flag
    
    It's a NOOP since 2.6.35 and it will be removed one day.
    
    Signed-off-by: Michael Opdenacker <michael.opdenacker@free-electrons.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 0721e72f9299..ff31ff0e0c43 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -888,7 +888,7 @@ static int yam_open(struct net_device *dev)
 		goto out_release_base;
 	}
 	outb(0, IER(dev->base_addr));
-	if (request_irq(dev->irq, yam_interrupt, IRQF_DISABLED | IRQF_SHARED, dev->name, dev)) {
+	if (request_irq(dev->irq, yam_interrupt, IRQF_SHARED, dev->name, dev)) {
 		printk(KERN_ERR "%s: irq %d busy\n", dev->name, dev->irq);
 		ret = -EBUSY;
 		goto out_release_base;

commit e00adf39134028d65023c327b427074728c18f7e
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Tue May 7 16:18:15 2013 -0700

    drivers/net: rename random32() to prandom_u32()
    
    Use preferable function name which implies using a pseudo-random number
    generator.
    
    [akpm@linux-foundation.org: convert team_mode_random.c]
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Acked-by: Thomas Sailer <t.sailer@alumni.ethz.ch>
    Acked-by: Bing Zhao <bzhao@marvell.com> [mwifiex]
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Michael Chan <mchan@broadcom.com>
    Cc: Thomas Sailer <t.sailer@alumni.ethz.ch>
    Cc: Jean-Paul Roubelat <jpr@f6fbb.org>
    Cc: Bing Zhao <bzhao@marvell.com>
    Cc: Brett Rudley <brudley@broadcom.com>
    Cc: Arend van Spriel <arend@broadcom.com>
    Cc: "Franky (Zhenhui) Lin" <frankyl@broadcom.com>
    Cc: Hante Meuleman <meuleman@broadcom.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index b2d863f2ea42..0721e72f9299 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -638,7 +638,7 @@ static void yam_arbitrate(struct net_device *dev)
 	yp->slotcnt = yp->slot / 10;
 
 	/* is random > persist ? */
-	if ((random32() % 256) > yp->pers)
+	if ((prandom_u32() % 256) > yp->pers)
 		return;
 
 	yam_start_tx(dev, yp);

commit 429a22ca39e531d9f8bacac1f81f7207909bcbd2
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Mar 27 18:25:04 2013 +0000

    yam: remove redundant null check on dev
    
    yam_open has a redundant null check on null,  it will
    never be called with dev == NULL. Remove this redundant check.
    This also cleans up a smatch warning:
    
    drivers/net/hamradio/yam.c:869 yam_open() warn: variable
      dereferenced before check 'dev' (see line 867)
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Ben Hutchings <bhutchings@solarflare.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 4cf8f1017aad..b2d863f2ea42 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -866,7 +866,7 @@ static int yam_open(struct net_device *dev)
 
 	printk(KERN_INFO "Trying %s at iobase 0x%lx irq %u\n", dev->name, dev->base_addr, dev->irq);
 
-	if (!dev || !yp->bitrate)
+	if (!yp->bitrate)
 		return -ENXIO;
 	if (!dev->base_addr || dev->base_addr > 0x1000 - YAM_EXTENT ||
 		dev->irq < 2 || dev->irq > 15) {

commit ece31ffd539e8e2b586b1ca5f50bc4f4591e3893
Author: Gao feng <gaofeng@cn.fujitsu.com>
Date:   Mon Feb 18 01:34:56 2013 +0000

    net: proc: change proc_net_remove to remove_proc_entry
    
    proc_net_remove is only used to remove proc entries
    that under /proc/net,it's not a general function for
    removing proc entries of netns. if we want to remove
    some proc entries which under /proc/net/stat/, we still
    need to call remove_proc_entry.
    
    this patch use remove_proc_entry to replace proc_net_remove.
    we can remove proc_net_remove after this patch.
    
    Signed-off-by: Gao feng <gaofeng@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 92847d27b2e8..4cf8f1017aad 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -1199,7 +1199,7 @@ static void __exit yam_cleanup_driver(void)
 		kfree(p);
 	}
 
-	proc_net_remove(&init_net, "yam");
+	remove_proc_entry("yam", init_net.proc_net);
 }
 
 /* --------------------------------------------------------------------- */

commit d4beaa66add8aebf83ab16d2fde4e4de8dac36df
Author: Gao feng <gaofeng@cn.fujitsu.com>
Date:   Mon Feb 18 01:34:54 2013 +0000

    net: proc: change proc_net_fops_create to proc_create
    
    Right now, some modules such as bonding use proc_create
    to create proc entries under /proc/net/, and other modules
    such as ipv4 use proc_net_fops_create.
    
    It looks a little chaos.this patch changes all of
    proc_net_fops_create to proc_create. we can remove
    proc_net_fops_create after this patch.
    
    Signed-off-by: Gao feng <gaofeng@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index c6645f1017af..92847d27b2e8 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -1167,7 +1167,7 @@ static int __init yam_init_driver(void)
 	yam_timer.expires = jiffies + HZ / 100;
 	add_timer(&yam_timer);
 
-	proc_net_fops_create(&init_net, "yam", S_IRUGO, &yam_info_fops);
+	proc_create("yam", S_IRUGO, init_net.proc_net, &yam_info_fops);
 	return 0;
  error:
 	while (--i >= 0) {

commit afa8c78b889262a1c809a1c1ed17619015ad0481
Author: Andi Kleen <ak@linux.intel.com>
Date:   Thu Oct 4 17:11:58 2012 -0700

    sections: fix section conflicts in drivers/net/hamradio
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Cc: David Miller <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 5a6412ecce73..c6645f1017af 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -76,7 +76,7 @@
 /* --------------------------------------------------------------------- */
 
 static const char yam_drvname[] = "yam";
-static const char yam_drvinfo[] __initdata = KERN_INFO \
+static const char yam_drvinfo[] __initconst = KERN_INFO \
 	"YAM driver version 0.8 by F1OAT/F6FBB\n";
 
 /* --------------------------------------------------------------------- */

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 696327773fbe..5a6412ecce73 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -52,7 +52,6 @@
 #include <linux/bitops.h>
 #include <linux/random.h>
 #include <asm/io.h>
-#include <asm/system.h>
 #include <linux/interrupt.h>
 #include <linux/ioport.h>
 #include <linux/firmware.h>

commit e404decb0fb017be80552adee894b35307b6c7b4
Author: Joe Perches <joe@perches.com>
Date:   Sun Jan 29 12:56:23 2012 +0000

    drivers/net: Remove unnecessary k.alloc/v.alloc OOM messages
    
    alloc failures use dump_stack so emitting an additional
    out-of-memory message is an unnecessary duplication.
    
    Remove the allocation failure messages.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 96a98d2ff151..696327773fbe 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -403,7 +403,6 @@ static unsigned char *add_mcs(unsigned char *bits, int bitrate,
 
 	/* Allocate a new mcs */
 	if ((p = kmalloc(sizeof(struct yam_mcs), GFP_KERNEL)) == NULL) {
-		printk(KERN_WARNING "YAM: no memory to allocate mcs\n");
 		release_firmware(fw);
 		return NULL;
 	}

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 7d9ced0738c5..96a98d2ff151 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -30,7 +30,7 @@
  *   0.1 F1OAT 07.06.98  Add timer polling routine for channel arbitration
  *   0.2 F6FBB 08.06.98  Added delay after FPGA programming
  *   0.3 F6FBB 29.07.98  Delayed PTT implementation for dupmode=2
- *   0.4 F6FBB 30.07.98  Added TxTail, Slottime and Persistance
+ *   0.4 F6FBB 30.07.98  Added TxTail, Slottime and Persistence
  *   0.5 F6FBB 01.08.98  Shared IRQs, /proc/net and network statistics
  *   0.6 F6FBB 25.08.98  Added 1200Bds format
  *   0.7 F6FBB 12.09.98  Added to the kernel configuration

commit 26877c794407855f65c056d7914b2e72ae9b93b8
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Thu Jan 6 10:50:29 2011 +0000

    hamradio: Resolve memory leak due to missing firmware release in add_mcs()
    
    Failure to release_firmware() in drivers/net/hamradio/yam.c::add_mcs()
    causes memory leak.
    This patch should fix it.
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 4e7d1d0a2340..7d9ced0738c5 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -396,7 +396,7 @@ static unsigned char *add_mcs(unsigned char *bits, int bitrate,
 	while (p) {
 		if (p->bitrate == bitrate) {
 			memcpy(p->bits, bits, YAM_FPGA_SIZE);
-			return p->bits;
+			goto out;
 		}
 		p = p->next;
 	}
@@ -411,7 +411,7 @@ static unsigned char *add_mcs(unsigned char *bits, int bitrate,
 	p->bitrate = bitrate;
 	p->next = yam_data;
 	yam_data = p;
-
+ out:
 	release_firmware(fw);
 	return p->bits;
 }

commit 89dc0be68f4aaa06dba1b5d6ea9ecfe8fa9b7bf0
Author: Julia Lawall <julia@diku.dk>
Date:   Thu May 27 16:29:05 2010 -0700

    drivers/net/hamradio: Eliminate a NULL pointer dereference
    
    At the point of the print, dev is NULL.
    
    A simplified version of the semantic match that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r exists@
    expression E,E1;
    identifier f;
    statement S1,S2,S3;
    @@
    
    if ((E == NULL && ...) || ...)
    {
      ... when != if (...) S1 else S2
          when != E = E1
    * E->f
      ... when any
      return ...;
    }
    else S3
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 694132e04af6..4e7d1d0a2340 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -1151,8 +1151,7 @@ static int __init yam_init_driver(void)
 		dev = alloc_netdev(sizeof(struct yam_port), name,
 				   yam_setup);
 		if (!dev) {
-			printk(KERN_ERR "yam: cannot allocate net device %s\n",
-			       dev->name);
+			pr_err("yam: cannot allocate net device\n");
 			err = -ENOMEM;
 			goto error;
 		}

commit 36e4d64a82d9a91a73a2b9b32117aedfe2211fb3
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Mon Aug 31 19:50:43 2009 +0000

    convert hamradio drivers to netdev_txreturnt_t
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index b85aa162314e..694132e04af6 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -594,7 +594,8 @@ static void ptt_off(struct net_device *dev)
 	outb(PTT_OFF, MCR(dev->base_addr));
 }
 
-static int yam_send_packet(struct sk_buff *skb, struct net_device *dev)
+static netdev_tx_t yam_send_packet(struct sk_buff *skb,
+					 struct net_device *dev)
 {
 	struct yam_port *yp = netdev_priv(dev);
 

commit 6ed106549d17474ca17a16057f4c0ed4eba5a7ca
Author: Patrick McHardy <kaber@trash.net>
Date:   Tue Jun 23 06:03:08 2009 +0000

    net: use NETDEV_TX_OK instead of 0 in ndo_start_xmit() functions
    
    This patch is the result of an automatic spatch transformation to convert
    all ndo_start_xmit() return values of 0 to NETDEV_TX_OK.
    
    Some occurences are missed by the automatic conversion, those will be
    handled in a seperate patch.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index b06691937ce9..b85aa162314e 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -600,7 +600,7 @@ static int yam_send_packet(struct sk_buff *skb, struct net_device *dev)
 
 	skb_queue_tail(&yp->send_queue, skb);
 	dev->trans_start = jiffies;
-	return 0;
+	return NETDEV_TX_OK;
 }
 
 static void yam_start_tx(struct net_device *dev, struct yam_port *yp)

commit a7a5eb9d4eb9908709df66e8f8f1724b5b108258
Author: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
Date:   Mon Mar 30 18:17:21 2009 +0530

    yam: use request_firmware
    
    Added predef variable in add_mcs() to support predefined mcs data
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 500a40b2afe7..b06691937ce9 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -55,6 +55,8 @@
 #include <asm/system.h>
 #include <linux/interrupt.h>
 #include <linux/ioport.h>
+#include <linux/firmware.h>
+#include <linux/platform_device.h>
 
 #include <linux/netdevice.h>
 #include <linux/if_arp.h>
@@ -71,8 +73,6 @@
 #include <linux/init.h>
 
 #include <linux/yam.h>
-#include "yam9600.h"
-#include "yam1200.h"
 
 /* --------------------------------------------------------------------- */
 
@@ -82,6 +82,9 @@ static const char yam_drvinfo[] __initdata = KERN_INFO \
 
 /* --------------------------------------------------------------------- */
 
+#define FIRMWARE_9600	"yam/9600.bin"
+#define FIRMWARE_1200	"yam/1200.bin"
+
 #define YAM_9600	1
 #define YAM_1200	2
 
@@ -342,9 +345,51 @@ static int fpga_write(int iobase, unsigned char wrd)
 	return 0;
 }
 
-static unsigned char *add_mcs(unsigned char *bits, int bitrate)
+/*
+ * predef should be 0 for loading user defined mcs
+ * predef should be YAM_1200 for loading predef 1200 mcs
+ * predef should be YAM_9600 for loading predef 9600 mcs
+ */
+static unsigned char *add_mcs(unsigned char *bits, int bitrate,
+			      unsigned int predef)
 {
+	const char *fw_name[2] = {FIRMWARE_9600, FIRMWARE_1200};
+	const struct firmware *fw;
+	struct platform_device *pdev;
 	struct yam_mcs *p;
+	int err;
+
+	switch (predef) {
+	case 0:
+		fw = NULL;
+		break;
+	case YAM_1200:
+	case YAM_9600:
+		predef--;
+		pdev = platform_device_register_simple("yam", 0, NULL, 0);
+		if (IS_ERR(pdev)) {
+			printk(KERN_ERR "yam: Failed to register firmware\n");
+			return NULL;
+		}
+		err = request_firmware(&fw, fw_name[predef], &pdev->dev);
+		platform_device_unregister(pdev);
+		if (err) {
+			printk(KERN_ERR "Failed to load firmware \"%s\"\n",
+			       fw_name[predef]);
+			return NULL;
+		}
+		if (fw->size != YAM_FPGA_SIZE) {
+			printk(KERN_ERR "Bogus length %zu in firmware \"%s\"\n",
+			       fw->size, fw_name[predef]);
+			release_firmware(fw);
+			return NULL;
+		}
+		bits = (unsigned char *)fw->data;
+		break;
+	default:
+		printk(KERN_ERR "yam: Invalid predef number %u\n", predef);
+		return NULL;
+	}
 
 	/* If it already exists, replace the bit data */
 	p = yam_data;
@@ -359,6 +404,7 @@ static unsigned char *add_mcs(unsigned char *bits, int bitrate)
 	/* Allocate a new mcs */
 	if ((p = kmalloc(sizeof(struct yam_mcs), GFP_KERNEL)) == NULL) {
 		printk(KERN_WARNING "YAM: no memory to allocate mcs\n");
+		release_firmware(fw);
 		return NULL;
 	}
 	memcpy(p->bits, bits, YAM_FPGA_SIZE);
@@ -366,6 +412,7 @@ static unsigned char *add_mcs(unsigned char *bits, int bitrate)
 	p->next = yam_data;
 	yam_data = p;
 
+	release_firmware(fw);
 	return p->bits;
 }
 
@@ -383,9 +430,11 @@ static unsigned char *get_mcs(int bitrate)
 	/* Load predefined mcs data */
 	switch (bitrate) {
 	case 1200:
-		return add_mcs(bits_1200, bitrate);
+		/* setting predef as YAM_1200 for loading predef 1200 mcs */
+		return add_mcs(NULL, bitrate, YAM_1200);
 	default:
-		return add_mcs(bits_9600, bitrate);
+		/* setting predef as YAM_9600 for loading predef 9600 mcs */
+		return add_mcs(NULL, bitrate, YAM_9600);
 	}
 }
 
@@ -936,7 +985,8 @@ static int yam_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 			kfree(ym);
 			return -EINVAL;
 		}
-		add_mcs(ym->bits, ym->bitrate);
+		/* setting predef as 0 for loading userdefined mcs data */
+		add_mcs(ym->bits, ym->bitrate, 0);
 		kfree(ym);
 		break;
 
@@ -1159,6 +1209,8 @@ static void __exit yam_cleanup_driver(void)
 MODULE_AUTHOR("Frederic Rible F1OAT frible@teaser.fr");
 MODULE_DESCRIPTION("Yam amateur radio modem driver");
 MODULE_LICENSE("GPL");
+MODULE_FIRMWARE(FIRMWARE_1200);
+MODULE_FIRMWARE(FIRMWARE_9600);
 
 module_init(yam_init_driver);
 module_exit(yam_cleanup_driver);

commit 9b329f18b943fb5648c10f79690918b9056dd5c5
Author: Hannes Eder <hannes@hanneseder.net>
Date:   Sat Feb 14 11:35:35 2009 +0000

    drivers/net/hamradio: fix sparse warning: symbol shadows an earlier one
    
    Impact: Rename inner scrope variable.
    
    Fix this sparse warning:
      drivers/net/hamradio/yam.c:856:35: warning: symbol 'dev' shadows an earlier one
    
    Signed-off-by: Hannes Eder <hannes@hanneseder.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index a54b865c2080..500a40b2afe7 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -854,10 +854,10 @@ static int yam_open(struct net_device *dev)
 
 	/* Reset overruns for all ports - FPGA programming makes overruns */
 	for (i = 0; i < NR_PORTS; i++) {
-		struct net_device *dev = yam_devs[i];
+		struct net_device *yam_dev = yam_devs[i];
 
-		inb(LSR(dev->base_addr));
-		dev->stats.rx_fifo_errors = 0;
+		inb(LSR(yam_dev->base_addr));
+		yam_dev->stats.rx_fifo_errors = 0;
 	}
 
 	printk(KERN_INFO "%s at iobase 0x%lx irq %u uart %s\n", dev->name, dev->base_addr, dev->irq,

commit eb33ae248682ecfdf44d693c72bc4f523f2fb6e3
Author: Hannes Eder <hannes@hanneseder.net>
Date:   Sat Feb 14 11:33:21 2009 +0000

    drivers/net/hamradio: fix warning: format not a string literal and no ...
    
    Impact: Use 'static const char[]' instead of 'static char[]' and while
    being at it fix an issue in 'mkiss_init_driver', where in case of an
    error the status code was not passed to printk.
    
    Fix this warnings:
      drivers/net/hamradio/6pack.c: In function 'sixpack_init_driver':
      drivers/net/hamradio/6pack.c:802: warning: format not a string literal and no format arguments
      drivers/net/hamradio/bpqether.c: In function 'bpq_init_driver':
      drivers/net/hamradio/bpqether.c:609: warning: format not a string literal and no format arguments
      drivers/net/hamradio/mkiss.c: In function 'mkiss_init_driver':
      drivers/net/hamradio/mkiss.c:988: warning: format not a string literal and no format arguments
      drivers/net/hamradio/mkiss.c:991: warning: format not a string literal and no format arguments
      drivers/net/hamradio/scc.c: In function 'scc_init_driver':
      drivers/net/hamradio/scc.c:2109: warning: format not a string literal and no format arguments
      drivers/net/hamradio/yam.c: In function 'yam_init_driver':
      drivers/net/hamradio/yam.c:1094: warning: format not a string literal and no format arguments
    
    Signed-off-by: Hannes Eder <hannes@hanneseder.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 82a8be7613d6..a54b865c2080 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -77,7 +77,8 @@
 /* --------------------------------------------------------------------- */
 
 static const char yam_drvname[] = "yam";
-static char yam_drvinfo[] __initdata = KERN_INFO "YAM driver version 0.8 by F1OAT/F6FBB\n";
+static const char yam_drvinfo[] __initdata = KERN_INFO \
+	"YAM driver version 0.8 by F1OAT/F6FBB\n";
 
 /* --------------------------------------------------------------------- */
 

commit 4101dec9ca64d40f0d673f0a40ba46ba2c60e117
Author: Jan Engelhardt <jengelh@medozas.de>
Date:   Wed Jan 14 13:52:18 2009 -0800

    net: constify VFTs
    
    Signed-off-by: Jan Engelhardt <jengelh@medozas.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index e2b0a19203ac..82a8be7613d6 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -783,7 +783,7 @@ static int yam_seq_show(struct seq_file *seq, void *v)
 	return 0;
 }
 
-static struct seq_operations yam_seqops = {
+static const struct seq_operations yam_seqops = {
 	.start = yam_seq_start,
 	.next = yam_seq_next,
 	.stop = yam_seq_stop,

commit 3f75f7482f7687b8ffe9e0ddad560797a9f9ad6e
Author: Stephen Hemminger <shemminger@linux-foundation.org>
Date:   Fri Jan 9 13:01:38 2009 +0000

    yam: convert to net_device_ops
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index be280871e9ac..e2b0a19203ac 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -1044,6 +1044,14 @@ static int yam_set_mac_address(struct net_device *dev, void *addr)
 
 /* --------------------------------------------------------------------- */
 
+static const struct net_device_ops yam_netdev_ops = {
+	.ndo_open	     = yam_open,
+	.ndo_stop	     = yam_close,
+	.ndo_start_xmit      = yam_send_packet,
+	.ndo_do_ioctl 	     = yam_ioctl,
+	.ndo_set_mac_address = yam_set_mac_address,
+};
+
 static void yam_setup(struct net_device *dev)
 {
 	struct yam_port *yp = netdev_priv(dev);
@@ -1064,18 +1072,11 @@ static void yam_setup(struct net_device *dev)
 	dev->base_addr = yp->iobase;
 	dev->irq = yp->irq;
 
-	dev->open = yam_open;
-	dev->stop = yam_close;
-	dev->do_ioctl = yam_ioctl;
-	dev->hard_start_xmit = yam_send_packet;
-	dev->get_stats = yam_get_stats;
-
 	skb_queue_head_init(&yp->send_queue);
 
+	dev->netdev_ops = &yam_netdev_ops;
 	dev->header_ops = &ax25_header_ops;
 
-	dev->set_mac_address = yam_set_mac_address;
-
 	dev->type = ARPHRD_AX25;
 	dev->hard_header_len = AX25_MAX_HEADER_LEN;
 	dev->mtu = AX25_MTU;

commit 3c94acb7ee343e49075c8f3c72c1920633fc230c
Author: Stephen Hemminger <shemminger@linux-foundation.org>
Date:   Fri Jan 9 13:01:37 2009 +0000

    yam: convert to internal net_device_stats
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 5407f7486c9c..be280871e9ac 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -115,10 +115,6 @@ struct yam_port {
 
 	struct net_device *dev;
 
-	/* Stats section */
-
-	struct net_device_stats stats;
-
 	int nb_rxint;
 	int nb_mdint;
 
@@ -507,7 +503,7 @@ static inline void yam_rx_flag(struct net_device *dev, struct yam_port *yp)
 		} else {
 			if (!(skb = dev_alloc_skb(pkt_len))) {
 				printk(KERN_WARNING "%s: memory squeeze, dropping packet\n", dev->name);
-				++yp->stats.rx_dropped;
+				++dev->stats.rx_dropped;
 			} else {
 				unsigned char *cp;
 				cp = skb_put(skb, pkt_len);
@@ -515,7 +511,7 @@ static inline void yam_rx_flag(struct net_device *dev, struct yam_port *yp)
 				memcpy(cp, yp->rx_buf, pkt_len - 1);
 				skb->protocol = ax25_type_trans(skb, dev);
 				netif_rx(skb);
-				++yp->stats.rx_packets;
+				++dev->stats.rx_packets;
 			}
 		}
 	}
@@ -677,7 +673,7 @@ static void yam_tx_byte(struct net_device *dev, struct yam_port *yp)
 			yp->tx_count = 1;
 			yp->tx_state = TX_HEAD;
 		}
-		++yp->stats.tx_packets;
+		++dev->stats.tx_packets;
 		break;
 	case TX_TAIL:
 		if (--yp->tx_count <= 0) {
@@ -716,7 +712,7 @@ static irqreturn_t yam_interrupt(int irq, void *dev_id)
 			handled = 1;
 
 			if (lsr & LSR_OE)
-				++yp->stats.rx_fifo_errors;
+				++dev->stats.rx_fifo_errors;
 
 			yp->dcd = (msr & RX_DCD) ? 1 : 0;
 
@@ -778,11 +774,11 @@ static int yam_seq_show(struct seq_file *seq, void *v)
 	seq_printf(seq, "  TxTail   %u\n", yp->txtail);
 	seq_printf(seq, "  SlotTime %u\n", yp->slot);
 	seq_printf(seq, "  Persist  %u\n", yp->pers);
-	seq_printf(seq, "  TxFrames %lu\n", yp->stats.tx_packets);
-	seq_printf(seq, "  RxFrames %lu\n", yp->stats.rx_packets);
+	seq_printf(seq, "  TxFrames %lu\n", dev->stats.tx_packets);
+	seq_printf(seq, "  RxFrames %lu\n", dev->stats.rx_packets);
 	seq_printf(seq, "  TxInt    %u\n", yp->nb_mdint);
 	seq_printf(seq, "  RxInt    %u\n", yp->nb_rxint);
-	seq_printf(seq, "  RxOver   %lu\n", yp->stats.rx_fifo_errors);
+	seq_printf(seq, "  RxOver   %lu\n", dev->stats.rx_fifo_errors);
 	seq_printf(seq, "\n");
 	return 0;
 }
@@ -810,26 +806,6 @@ static const struct file_operations yam_info_fops = {
 #endif
 
 
-/* --------------------------------------------------------------------- */
-
-static struct net_device_stats *yam_get_stats(struct net_device *dev)
-{
-	struct yam_port *yp;
-
-	if (!dev)
-		return NULL;
-
-	yp = netdev_priv(dev);
-	if (yp->magic != YAM_MAGIC)
-		return NULL;
-
-	/* 
-	 * Get the current statistics.  This may be called with the
-	 * card open or closed. 
-	 */
-	return &yp->stats;
-}
-
 /* --------------------------------------------------------------------- */
 
 static int yam_open(struct net_device *dev)
@@ -878,9 +854,9 @@ static int yam_open(struct net_device *dev)
 	/* Reset overruns for all ports - FPGA programming makes overruns */
 	for (i = 0; i < NR_PORTS; i++) {
 		struct net_device *dev = yam_devs[i];
-		struct yam_port *yp = netdev_priv(dev);
+
 		inb(LSR(dev->base_addr));
-		yp->stats.rx_fifo_errors = 0;
+		dev->stats.rx_fifo_errors = 0;
 	}
 
 	printk(KERN_INFO "%s at iobase 0x%lx irq %u uart %s\n", dev->name, dev->base_addr, dev->irq,

commit babcda74e9d96bb58fd9c6c5112dbdbff169e695
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Nov 3 21:11:17 2008 -0800

    drivers/net: Kill now superfluous ->last_rx stores.
    
    The generic packet receive code takes care of setting
    netdev->last_rx when necessary, for the sake of the
    bonding ARP monitor.
    
    Drivers need not do it any more.
    
    Some cases had to be skipped over because the drivers
    were making use of the ->last_rx value themselves.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 1c942862a3f4..5407f7486c9c 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -515,7 +515,6 @@ static inline void yam_rx_flag(struct net_device *dev, struct yam_port *yp)
 				memcpy(cp, yp->rx_buf, pkt_len - 1);
 				skb->protocol = ax25_type_trans(skb, dev);
 				netif_rx(skb);
-				dev->last_rx = jiffies;
 				++yp->stats.rx_packets;
 			}
 		}

commit 3b04ddde02cf1b6f14f2697da5c20eca5715017f
Author: Stephen Hemminger <shemminger@linux-foundation.org>
Date:   Tue Oct 9 01:40:57 2007 -0700

    [NET]: Move hardware header operations out of netdevice.
    
    Since hardware header operations are part of the protocol class
    not the device instance, make them into a separate object and
    save memory.
    
    Signed-off-by: Stephen Hemminger <shemminger@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 401724ddafcd..1c942862a3f4 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -1097,8 +1097,7 @@ static void yam_setup(struct net_device *dev)
 
 	skb_queue_head_init(&yp->send_queue);
 
-	dev->hard_header = ax25_hard_header;
-	dev->rebuild_header = ax25_rebuild_header;
+	dev->header_ops = &ax25_header_ops;
 
 	dev->set_mac_address = yam_set_mac_address;
 

commit 457c4cbc5a3dde259d2a1f15d5f9785290397267
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Sep 12 12:01:34 2007 +0200

    [NET]: Make /proc/net per network namespace
    
    This patch makes /proc/net per network namespace.  It modifies the global
    variables proc_net and proc_net_stat to be per network namespace.
    The proc_net file helpers are modified to take a network namespace argument,
    and all of their callers are fixed to pass &init_net for that argument.
    This ensures that all of the /proc/net files are only visible and
    usable in the initial network namespace until the code behind them
    has been updated to be handle multiple network namespaces.
    
    Making /proc/net per namespace is necessary as at least some files
    in /proc/net depend upon the set of network devices which is per
    network namespace, and even more files in /proc/net have contents
    that are relevant to a single network namespace.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 467559debfd6..401724ddafcd 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -65,6 +65,7 @@
 #include <linux/kernel.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
+#include <net/net_namespace.h>
 
 #include <asm/uaccess.h>
 #include <linux/init.h>
@@ -1142,7 +1143,7 @@ static int __init yam_init_driver(void)
 	yam_timer.expires = jiffies + HZ / 100;
 	add_timer(&yam_timer);
 
-	proc_net_fops_create("yam", S_IRUGO, &yam_info_fops);
+	proc_net_fops_create(&init_net, "yam", S_IRUGO, &yam_info_fops);
 	return 0;
  error:
 	while (--i >= 0) {
@@ -1174,7 +1175,7 @@ static void __exit yam_cleanup_driver(void)
 		kfree(p);
 	}
 
-	proc_net_remove("yam");
+	proc_net_remove(&init_net, "yam");
 }
 
 /* --------------------------------------------------------------------- */

commit 55404bca6c45595fee1a546f1a0cc616aeef0b00
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Thu Apr 26 00:55:53 2007 -0700

    [NET]: Fix yam.c
    
    drivers/net/hamradio/yam.c: In function `yam_tx_byte':
    drivers/net/hamradio/yam.c:643: warning: passing arg 1 of `skb_copy_from_linear_data_offset' from incompatible pointer type
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index ac2d6dd9dbe4..467559debfd6 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -638,7 +638,7 @@ static void yam_tx_byte(struct net_device *dev, struct yam_port *yp)
         			dev_kfree_skb_any(skb);
 				break;
 			}
-			skb_copy_from_linear_data_offset(skb->data, 1,
+			skb_copy_from_linear_data_offset(skb, 1,
 							 yp->tx_buf,
 							 yp->tx_len);
 			dev_kfree_skb_any(skb);

commit d626f62b11e00c16e81e4308ab93d3f13551812a
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Mar 27 18:55:52 2007 -0300

    [SK_BUFF]: Introduce skb_copy_from_linear_data{_offset}
    
    To clearly state the intent of copying from linear sk_buffs, _offset being a
    overly long variant but interesting for the sake of saving some bytes.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index ee3ea4fa729f..ac2d6dd9dbe4 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -638,7 +638,9 @@ static void yam_tx_byte(struct net_device *dev, struct yam_port *yp)
         			dev_kfree_skb_any(skb);
 				break;
 			}
-			memcpy(yp->tx_buf, skb->data + 1, yp->tx_len);
+			skb_copy_from_linear_data_offset(skb->data, 1,
+							 yp->tx_buf,
+							 yp->tx_len);
 			dev_kfree_skb_any(skb);
 			yp->tx_count = 0;
 			yp->tx_crcl = 0x21;

commit 8b5b46718113166b5f6bcdf40e67ea867461e209
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Feb 16 11:55:33 2007 +0000

    Replace local random function with random32()
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 08f27119a807..ee3ea4fa729f 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -50,6 +50,7 @@
 #include <linux/slab.h>
 #include <linux/errno.h>
 #include <linux/bitops.h>
+#include <linux/random.h>
 #include <asm/io.h>
 #include <asm/system.h>
 #include <linux/interrupt.h>
@@ -566,14 +567,6 @@ static void yam_start_tx(struct net_device *dev, struct yam_port *yp)
 	ptt_on(dev);
 }
 
-static unsigned short random_seed;
-
-static inline unsigned short random_num(void)
-{
-	random_seed = 28629 * random_seed + 157;
-	return random_seed;
-}
-
 static void yam_arbitrate(struct net_device *dev)
 {
 	struct yam_port *yp = netdev_priv(dev);
@@ -600,7 +593,7 @@ static void yam_arbitrate(struct net_device *dev)
 	yp->slotcnt = yp->slot / 10;
 
 	/* is random > persist ? */
-	if ((random_num() % 256) > yp->pers)
+	if ((random32() % 256) > yp->pers)
 		return;
 
 	yam_start_tx(dev, yp);

commit d54b1fdb1d9f82e375a299e22bd366aad52d4c34
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:34 2007 -0800

    [PATCH] mark struct file_operations const 5
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 6d74f08720d5..08f27119a807 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -804,7 +804,7 @@ static int yam_info_open(struct inode *inode, struct file *file)
 	return seq_open(file, &yam_seqops);
 }
 
-static struct file_operations yam_info_fops = {
+static const struct file_operations yam_info_fops = {
 	.owner = THIS_MODULE,
 	.open = yam_info_open,
 	.read = seq_read,

commit 15b1c0e822f578306332d4f4c449250db5c5dceb
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Dec 7 15:47:08 2006 -0800

    [AX.25]: Fix default address and broadcast address initialization.
    
    Only the callsign but not the SSID part of an AX.25 address is ASCII
    based but Linux by initializes the SSID which should be just a 4-bit
    number from ASCII anyway.
    
    Fix that and convert the code to use a shared constant for both default
    addresses.  While at it, use the same style for null_ax25_address also.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 3c4455bd466d..6d74f08720d5 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -156,11 +156,6 @@ static struct net_device *yam_devs[NR_PORTS];
 
 static struct yam_mcs *yam_data;
 
-static char ax25_bcast[7] =
-{'Q' << 1, 'S' << 1, 'T' << 1, ' ' << 1, ' ' << 1, ' ' << 1, '0' << 1};
-static char ax25_test[7] =
-{'L' << 1, 'I' << 1, 'N' << 1, 'U' << 1, 'X' << 1, ' ' << 1, '1' << 1};
-
 static DEFINE_TIMER(yam_timer, NULL, 0, 0);
 
 /* --------------------------------------------------------------------- */
@@ -1115,8 +1110,8 @@ static void yam_setup(struct net_device *dev)
 	dev->hard_header_len = AX25_MAX_HEADER_LEN;
 	dev->mtu = AX25_MTU;
 	dev->addr_len = AX25_ADDR_LEN;
-	memcpy(dev->broadcast, ax25_bcast, AX25_ADDR_LEN);
-	memcpy(dev->dev_addr, ax25_test, AX25_ADDR_LEN);
+	memcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);
+	memcpy(dev->dev_addr, &ax25_defaddr, AX25_ADDR_LEN);
 }
 
 static int __init yam_init_driver(void)

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index f98f5777dfbb..3c4455bd466d 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -702,7 +702,7 @@ static void yam_tx_byte(struct net_device *dev, struct yam_port *yp)
 * ISR routine
 ************************************************************************************/
 
-static irqreturn_t yam_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t yam_interrupt(int irq, void *dev_id)
 {
 	struct net_device *dev;
 	struct yam_port *yp;

commit 1fb9df5d3069064c037c81c0ab8bf783ffa5e373
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:39 2006 -0700

    [PATCH] irq-flags: drivers/net: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index dd2f11c98530..f98f5777dfbb 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -873,7 +873,7 @@ static int yam_open(struct net_device *dev)
 		goto out_release_base;
 	}
 	outb(0, IER(dev->base_addr));
-	if (request_irq(dev->irq, yam_interrupt, SA_INTERRUPT | SA_SHIRQ, dev->name, dev)) {
+	if (request_irq(dev->irq, yam_interrupt, IRQF_DISABLED | IRQF_SHARED, dev->name, dev)) {
 		printk(KERN_ERR "%s: irq %d busy\n", dev->name, dev->irq);
 		ret = -EBUSY;
 		goto out_release_base;

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index b49884048caa..dd2f11c98530 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -42,7 +42,6 @@
 
 /*****************************************************************************/
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/net.h>

commit 3ab33dcc82e014c69ebad3b524d0053378ef76c3
Author: Ralf Baechle DL5RB <ralf@linux-mips.org>
Date:   Wed May 3 23:24:35 2006 -0700

    [HAMRADIO]: Remove remaining SET_MODULE_OWNER calls from hamradio drivers.
    
    Signed-off-by: Ralf Baechle DL5RB <ralf@linux-mips.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index fe22479eb202..b49884048caa 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -1098,7 +1098,6 @@ static void yam_setup(struct net_device *dev)
 
 	dev->base_addr = yp->iobase;
 	dev->irq = yp->irq;
-	SET_MODULE_OWNER(dev);
 
 	dev->open = yam_open;
 	dev->stop = yam_close;

commit 6f74998e5c3b4610e6eba06babf16547369c512a
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Sep 12 14:21:01 2005 -0700

    [AX.25]: Rename ax25_encapsulate to ax25_hard_header
    
    Rename ax25_encapsulate to ax25_hard_header which these days more
    accurately describes what the function is supposed to do.
    
    Signed-off-by: Ralf Baechle DL5RB <ralf@linux-mips.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index bfcf2011522f..fe22479eb202 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -1108,7 +1108,7 @@ static void yam_setup(struct net_device *dev)
 
 	skb_queue_head_init(&yp->send_queue);
 
-	dev->hard_header = ax25_encapsulate;
+	dev->hard_header = ax25_hard_header;
 	dev->rebuild_header = ax25_rebuild_header;
 
 	dev->set_mac_address = yam_set_mac_address;

commit c4bc7ee2e474819d3932e8d726fdf7cb0bdc00c1
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Sep 12 14:19:26 2005 -0700

    [HAMRADIO]: driver cleanups
    
    Misc related cleanups in hamradio drivers:
    
     o Use symbolic constants instead of magic numbers
     o Don't try to handle the case where AX.25 isn't configured - the kernel
       configuration doesn't permit that.
     o Remove useless headers
    
    Signed-off-by: Ralf Baechle DL5RB <ralf@linux-mips.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index f52ee3162c51..bfcf2011522f 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -60,15 +60,7 @@
 #include <linux/if_arp.h>
 #include <linux/etherdevice.h>
 #include <linux/skbuff.h>
-#if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)
-/* prototypes for ax25_encapsulate and ax25_rebuild_header */
 #include <net/ax25.h>
-#endif	/* CONFIG_AX25 || CONFIG_AX25_MODULE */
-
-/* make genksyms happy */
-#include <linux/ip.h>
-#include <linux/udp.h>
-#include <linux/tcp.h>
 
 #include <linux/kernel.h>
 #include <linux/proc_fs.h>
@@ -1116,23 +1108,17 @@ static void yam_setup(struct net_device *dev)
 
 	skb_queue_head_init(&yp->send_queue);
 
-#if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)
 	dev->hard_header = ax25_encapsulate;
 	dev->rebuild_header = ax25_rebuild_header;
-#else							/* CONFIG_AX25 || CONFIG_AX25_MODULE */
-	dev->hard_header = NULL;
-	dev->rebuild_header = NULL;
-#endif							/* CONFIG_AX25 || CONFIG_AX25_MODULE */
 
 	dev->set_mac_address = yam_set_mac_address;
 
-	dev->type = ARPHRD_AX25;	/* AF_AX25 device */
-	dev->hard_header_len = 73;	/* We do digipeaters now */
-	dev->mtu = 256;				/* AX25 is the default */
-	dev->addr_len = 7;			/* sizeof an ax.25 address */
-	memcpy(dev->broadcast, ax25_bcast, 7);
-	memcpy(dev->dev_addr, ax25_test, 7);
-
+	dev->type = ARPHRD_AX25;
+	dev->hard_header_len = AX25_MAX_HEADER_LEN;
+	dev->mtu = AX25_MTU;
+	dev->addr_len = AX25_ADDR_LEN;
+	memcpy(dev->broadcast, ax25_bcast, AX25_ADDR_LEN);
+	memcpy(dev->dev_addr, ax25_test, AX25_ADDR_LEN);
 }
 
 static int __init yam_init_driver(void)

commit 8d06afab73a75f40ae2864e6c296356bab1ab473
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Sep 9 13:10:40 2005 -0700

    [PATCH] timer initialization cleanup: DEFINE_TIMER
    
    Clean up timer initialization by introducing DEFINE_TIMER a'la
    DEFINE_SPINLOCK.  Build and boot-tested on x86.  A similar patch has been
    been in the -RT tree for some time.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index 41213ef602dc..f52ee3162c51 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -170,7 +170,7 @@ static char ax25_bcast[7] =
 static char ax25_test[7] =
 {'L' << 1, 'I' << 1, 'N' << 1, 'U' << 1, 'X' << 1, ' ' << 1, '1' << 1};
 
-static struct timer_list yam_timer = TIMER_INITIALIZER(NULL, 0, 0);
+static DEFINE_TIMER(yam_timer, NULL, 0, 0);
 
 /* --------------------------------------------------------------------- */
 

commit 56cb515628e6a831bb76783f282a71f7285dad33
Author: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
Date:   Sun Apr 24 18:53:06 2005 -0700

    [AX25] Introduce ax25_type_trans
    
    Replacing the open coded equivalents and making ax25 look more like
    a linux network protocol, i.e. more similar to inet.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
index fd7b00fe38e5..41213ef602dc 100644
--- a/drivers/net/hamradio/yam.c
+++ b/drivers/net/hamradio/yam.c
@@ -522,12 +522,10 @@ static inline void yam_rx_flag(struct net_device *dev, struct yam_port *yp)
 				++yp->stats.rx_dropped;
 			} else {
 				unsigned char *cp;
-				skb->dev = dev;
 				cp = skb_put(skb, pkt_len);
 				*cp++ = 0;		/* KISS kludge */
 				memcpy(cp, yp->rx_buf, pkt_len - 1);
-				skb->protocol = htons(ETH_P_AX25);
-				skb->mac.raw = skb->data;
+				skb->protocol = ax25_type_trans(skb, dev);
 				netif_rx(skb);
 				dev->last_rx = jiffies;
 				++yp->stats.rx_packets;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/net/hamradio/yam.c b/drivers/net/hamradio/yam.c
new file mode 100644
index 000000000000..fd7b00fe38e5
--- /dev/null
+++ b/drivers/net/hamradio/yam.c
@@ -0,0 +1,1218 @@
+/*****************************************************************************/
+
+/*
+ *    yam.c  -- YAM radio modem driver.
+ *
+ *      Copyright (C) 1998 Frederic Rible F1OAT (frible@teaser.fr)
+ *      Adapted from baycom.c driver written by Thomas Sailer (sailer@ife.ee.ethz.ch)
+ *
+ *      This program is free software; you can redistribute it and/or modify
+ *      it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ *
+ *      This program is distributed in the hope that it will be useful,
+ *      but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *      GNU General Public License for more details.
+ *
+ *      You should have received a copy of the GNU General Public License
+ *      along with this program; if not, write to the Free Software
+ *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *  Please note that the GPL allows you to use the driver, NOT the radio.
+ *  In order to use the radio, you need a license from the communications
+ *  authority of your country.
+ *
+ *
+ *  History:
+ *   0.0 F1OAT 06.06.98  Begin of work with baycom.c source code V 0.3
+ *   0.1 F1OAT 07.06.98  Add timer polling routine for channel arbitration
+ *   0.2 F6FBB 08.06.98  Added delay after FPGA programming
+ *   0.3 F6FBB 29.07.98  Delayed PTT implementation for dupmode=2
+ *   0.4 F6FBB 30.07.98  Added TxTail, Slottime and Persistance
+ *   0.5 F6FBB 01.08.98  Shared IRQs, /proc/net and network statistics
+ *   0.6 F6FBB 25.08.98  Added 1200Bds format
+ *   0.7 F6FBB 12.09.98  Added to the kernel configuration
+ *   0.8 F6FBB 14.10.98  Fixed slottime/persistence timing bug
+ *       OK1ZIA 2.09.01  Fixed "kfree_skb on hard IRQ" 
+ *                       using dev_kfree_skb_any(). (important in 2.4 kernel)
+ *   
+ */
+
+/*****************************************************************************/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/net.h>
+#include <linux/in.h>
+#include <linux/if.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/bitops.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)
+/* prototypes for ax25_encapsulate and ax25_rebuild_header */
+#include <net/ax25.h>
+#endif	/* CONFIG_AX25 || CONFIG_AX25_MODULE */
+
+/* make genksyms happy */
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include <linux/tcp.h>
+
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+#include <asm/uaccess.h>
+#include <linux/init.h>
+
+#include <linux/yam.h>
+#include "yam9600.h"
+#include "yam1200.h"
+
+/* --------------------------------------------------------------------- */
+
+static const char yam_drvname[] = "yam";
+static char yam_drvinfo[] __initdata = KERN_INFO "YAM driver version 0.8 by F1OAT/F6FBB\n";
+
+/* --------------------------------------------------------------------- */
+
+#define YAM_9600	1
+#define YAM_1200	2
+
+#define NR_PORTS	4
+#define YAM_MAGIC	0xF10A7654
+
+/* Transmitter states */
+
+#define TX_OFF		0
+#define TX_HEAD		1
+#define TX_DATA		2
+#define TX_CRC1		3
+#define TX_CRC2		4
+#define TX_TAIL		5
+
+#define YAM_MAX_FRAME	1024
+
+#define DEFAULT_BITRATE	9600			/* bps */
+#define DEFAULT_HOLDD	10			/* sec */
+#define DEFAULT_TXD	300			/* ms */
+#define DEFAULT_TXTAIL	10			/* ms */
+#define DEFAULT_SLOT	100			/* ms */
+#define DEFAULT_PERS	64			/* 0->255 */
+
+struct yam_port {
+	int magic;
+	int bitrate;
+	int baudrate;
+	int iobase;
+	int irq;
+	int dupmode;
+
+	struct net_device *dev;
+
+	/* Stats section */
+
+	struct net_device_stats stats;
+
+	int nb_rxint;
+	int nb_mdint;
+
+	/* Parameters section */
+
+	int txd;				/* tx delay */
+	int holdd;				/* duplex ptt delay */
+	int txtail;				/* txtail delay */
+	int slot;				/* slottime */
+	int pers;				/* persistence */
+
+	/* Tx section */
+
+	int tx_state;
+	int tx_count;
+	int slotcnt;
+	unsigned char tx_buf[YAM_MAX_FRAME];
+	int tx_len;
+	int tx_crcl, tx_crch;
+	struct sk_buff_head send_queue;		/* Packets awaiting transmission */
+
+	/* Rx section */
+
+	int dcd;
+	unsigned char rx_buf[YAM_MAX_FRAME];
+	int rx_len;
+	int rx_crcl, rx_crch;
+};
+
+struct yam_mcs {
+	unsigned char bits[YAM_FPGA_SIZE];
+	int bitrate;
+	struct yam_mcs *next;
+};
+
+static struct net_device *yam_devs[NR_PORTS];
+
+static struct yam_mcs *yam_data;
+
+static char ax25_bcast[7] =
+{'Q' << 1, 'S' << 1, 'T' << 1, ' ' << 1, ' ' << 1, ' ' << 1, '0' << 1};
+static char ax25_test[7] =
+{'L' << 1, 'I' << 1, 'N' << 1, 'U' << 1, 'X' << 1, ' ' << 1, '1' << 1};
+
+static struct timer_list yam_timer = TIMER_INITIALIZER(NULL, 0, 0);
+
+/* --------------------------------------------------------------------- */
+
+#define RBR(iobase)	(iobase+0)
+#define THR(iobase)	(iobase+0)
+#define IER(iobase)	(iobase+1)
+#define IIR(iobase)	(iobase+2)
+#define FCR(iobase)	(iobase+2)
+#define LCR(iobase)	(iobase+3)
+#define MCR(iobase)	(iobase+4)
+#define LSR(iobase)	(iobase+5)
+#define MSR(iobase)	(iobase+6)
+#define SCR(iobase)	(iobase+7)
+#define DLL(iobase)	(iobase+0)
+#define DLM(iobase)	(iobase+1)
+
+#define YAM_EXTENT	8
+
+/* Interrupt Identification Register Bit Masks */
+#define IIR_NOPEND	1
+#define IIR_MSR		0
+#define IIR_TX		2
+#define IIR_RX		4
+#define IIR_LSR		6
+#define IIR_TIMEOUT	12			/* Fifo mode only */
+
+#define IIR_MASK	0x0F
+
+/* Interrupt Enable Register Bit Masks */
+#define IER_RX		1			/* enable rx interrupt */
+#define IER_TX		2			/* enable tx interrupt */
+#define IER_LSR		4			/* enable line status interrupts */
+#define IER_MSR		8			/* enable modem status interrupts */
+
+/* Modem Control Register Bit Masks */
+#define MCR_DTR		0x01			/* DTR output */
+#define MCR_RTS		0x02			/* RTS output */
+#define MCR_OUT1	0x04			/* OUT1 output (not accessible in RS232) */
+#define MCR_OUT2	0x08			/* Master Interrupt enable (must be set on PCs) */
+#define MCR_LOOP	0x10			/* Loopback enable */
+
+/* Modem Status Register Bit Masks */
+#define MSR_DCTS	0x01			/* Delta CTS input */
+#define MSR_DDSR	0x02			/* Delta DSR */
+#define MSR_DRIN	0x04			/* Delta RI */
+#define MSR_DDCD	0x08			/* Delta DCD */
+#define MSR_CTS		0x10			/* CTS input */
+#define MSR_DSR		0x20			/* DSR input */
+#define MSR_RING	0x40			/* RI  input */
+#define MSR_DCD		0x80			/* DCD input */
+
+/* line status register bit mask */
+#define LSR_RXC		0x01
+#define LSR_OE		0x02
+#define LSR_PE		0x04
+#define LSR_FE		0x08
+#define LSR_BREAK	0x10
+#define LSR_THRE	0x20
+#define LSR_TSRE	0x40
+
+/* Line Control Register Bit Masks */
+#define LCR_DLAB	0x80
+#define LCR_BREAK	0x40
+#define LCR_PZERO	0x28
+#define LCR_PEVEN	0x18
+#define LCR_PODD	0x08
+#define LCR_STOP1	0x00
+#define LCR_STOP2	0x04
+#define LCR_BIT5	0x00
+#define LCR_BIT6	0x02
+#define LCR_BIT7	0x01
+#define LCR_BIT8	0x03
+
+/* YAM Modem <-> UART Port mapping */
+
+#define TX_RDY		MSR_DCTS		/* transmitter ready to send */
+#define RX_DCD		MSR_DCD			/* carrier detect */
+#define RX_FLAG		MSR_RING		/* hdlc flag received */
+#define FPGA_DONE	MSR_DSR			/* FPGA is configured */
+#define PTT_ON		(MCR_RTS|MCR_OUT2)	/* activate PTT */
+#define PTT_OFF		(MCR_DTR|MCR_OUT2)	/* release PTT */
+
+#define ENABLE_RXINT	IER_RX			/* enable uart rx interrupt during rx */
+#define ENABLE_TXINT	IER_MSR			/* enable uart ms interrupt during tx */
+#define ENABLE_RTXINT	(IER_RX|IER_MSR)	/* full duplex operations */
+
+
+/*************************************************************************
+* CRC Tables
+************************************************************************/
+
+static const unsigned char chktabl[256] =
+{0x00, 0x89, 0x12, 0x9b, 0x24, 0xad, 0x36, 0xbf, 0x48, 0xc1, 0x5a, 0xd3, 0x6c, 0xe5, 0x7e,
+ 0xf7, 0x81, 0x08, 0x93, 0x1a, 0xa5, 0x2c, 0xb7, 0x3e, 0xc9, 0x40, 0xdb, 0x52, 0xed, 0x64,
+ 0xff, 0x76, 0x02, 0x8b, 0x10, 0x99, 0x26, 0xaf, 0x34, 0xbd, 0x4a, 0xc3, 0x58, 0xd1, 0x6e,
+ 0xe7, 0x7c, 0xf5, 0x83, 0x0a, 0x91, 0x18, 0xa7, 0x2e, 0xb5, 0x3c, 0xcb, 0x42, 0xd9, 0x50,
+ 0xef, 0x66, 0xfd, 0x74, 0x04, 0x8d, 0x16, 0x9f, 0x20, 0xa9, 0x32, 0xbb, 0x4c, 0xc5, 0x5e,
+ 0xd7, 0x68, 0xe1, 0x7a, 0xf3, 0x85, 0x0c, 0x97, 0x1e, 0xa1, 0x28, 0xb3, 0x3a, 0xcd, 0x44,
+ 0xdf, 0x56, 0xe9, 0x60, 0xfb, 0x72, 0x06, 0x8f, 0x14, 0x9d, 0x22, 0xab, 0x30, 0xb9, 0x4e,
+ 0xc7, 0x5c, 0xd5, 0x6a, 0xe3, 0x78, 0xf1, 0x87, 0x0e, 0x95, 0x1c, 0xa3, 0x2a, 0xb1, 0x38,
+ 0xcf, 0x46, 0xdd, 0x54, 0xeb, 0x62, 0xf9, 0x70, 0x08, 0x81, 0x1a, 0x93, 0x2c, 0xa5, 0x3e,
+ 0xb7, 0x40, 0xc9, 0x52, 0xdb, 0x64, 0xed, 0x76, 0xff, 0x89, 0x00, 0x9b, 0x12, 0xad, 0x24,
+ 0xbf, 0x36, 0xc1, 0x48, 0xd3, 0x5a, 0xe5, 0x6c, 0xf7, 0x7e, 0x0a, 0x83, 0x18, 0x91, 0x2e,
+ 0xa7, 0x3c, 0xb5, 0x42, 0xcb, 0x50, 0xd9, 0x66, 0xef, 0x74, 0xfd, 0x8b, 0x02, 0x99, 0x10,
+ 0xaf, 0x26, 0xbd, 0x34, 0xc3, 0x4a, 0xd1, 0x58, 0xe7, 0x6e, 0xf5, 0x7c, 0x0c, 0x85, 0x1e,
+ 0x97, 0x28, 0xa1, 0x3a, 0xb3, 0x44, 0xcd, 0x56, 0xdf, 0x60, 0xe9, 0x72, 0xfb, 0x8d, 0x04,
+ 0x9f, 0x16, 0xa9, 0x20, 0xbb, 0x32, 0xc5, 0x4c, 0xd7, 0x5e, 0xe1, 0x68, 0xf3, 0x7a, 0x0e,
+ 0x87, 0x1c, 0x95, 0x2a, 0xa3, 0x38, 0xb1, 0x46, 0xcf, 0x54, 0xdd, 0x62, 0xeb, 0x70, 0xf9,
+ 0x8f, 0x06, 0x9d, 0x14, 0xab, 0x22, 0xb9, 0x30, 0xc7, 0x4e, 0xd5, 0x5c, 0xe3, 0x6a, 0xf1,
+ 0x78};
+static const unsigned char chktabh[256] =
+{0x00, 0x11, 0x23, 0x32, 0x46, 0x57, 0x65, 0x74, 0x8c, 0x9d, 0xaf, 0xbe, 0xca, 0xdb, 0xe9,
+ 0xf8, 0x10, 0x01, 0x33, 0x22, 0x56, 0x47, 0x75, 0x64, 0x9c, 0x8d, 0xbf, 0xae, 0xda, 0xcb,
+ 0xf9, 0xe8, 0x21, 0x30, 0x02, 0x13, 0x67, 0x76, 0x44, 0x55, 0xad, 0xbc, 0x8e, 0x9f, 0xeb,
+ 0xfa, 0xc8, 0xd9, 0x31, 0x20, 0x12, 0x03, 0x77, 0x66, 0x54, 0x45, 0xbd, 0xac, 0x9e, 0x8f,
+ 0xfb, 0xea, 0xd8, 0xc9, 0x42, 0x53, 0x61, 0x70, 0x04, 0x15, 0x27, 0x36, 0xce, 0xdf, 0xed,
+ 0xfc, 0x88, 0x99, 0xab, 0xba, 0x52, 0x43, 0x71, 0x60, 0x14, 0x05, 0x37, 0x26, 0xde, 0xcf,
+ 0xfd, 0xec, 0x98, 0x89, 0xbb, 0xaa, 0x63, 0x72, 0x40, 0x51, 0x25, 0x34, 0x06, 0x17, 0xef,
+ 0xfe, 0xcc, 0xdd, 0xa9, 0xb8, 0x8a, 0x9b, 0x73, 0x62, 0x50, 0x41, 0x35, 0x24, 0x16, 0x07,
+ 0xff, 0xee, 0xdc, 0xcd, 0xb9, 0xa8, 0x9a, 0x8b, 0x84, 0x95, 0xa7, 0xb6, 0xc2, 0xd3, 0xe1,
+ 0xf0, 0x08, 0x19, 0x2b, 0x3a, 0x4e, 0x5f, 0x6d, 0x7c, 0x94, 0x85, 0xb7, 0xa6, 0xd2, 0xc3,
+ 0xf1, 0xe0, 0x18, 0x09, 0x3b, 0x2a, 0x5e, 0x4f, 0x7d, 0x6c, 0xa5, 0xb4, 0x86, 0x97, 0xe3,
+ 0xf2, 0xc0, 0xd1, 0x29, 0x38, 0x0a, 0x1b, 0x6f, 0x7e, 0x4c, 0x5d, 0xb5, 0xa4, 0x96, 0x87,
+ 0xf3, 0xe2, 0xd0, 0xc1, 0x39, 0x28, 0x1a, 0x0b, 0x7f, 0x6e, 0x5c, 0x4d, 0xc6, 0xd7, 0xe5,
+ 0xf4, 0x80, 0x91, 0xa3, 0xb2, 0x4a, 0x5b, 0x69, 0x78, 0x0c, 0x1d, 0x2f, 0x3e, 0xd6, 0xc7,
+ 0xf5, 0xe4, 0x90, 0x81, 0xb3, 0xa2, 0x5a, 0x4b, 0x79, 0x68, 0x1c, 0x0d, 0x3f, 0x2e, 0xe7,
+ 0xf6, 0xc4, 0xd5, 0xa1, 0xb0, 0x82, 0x93, 0x6b, 0x7a, 0x48, 0x59, 0x2d, 0x3c, 0x0e, 0x1f,
+ 0xf7, 0xe6, 0xd4, 0xc5, 0xb1, 0xa0, 0x92, 0x83, 0x7b, 0x6a, 0x58, 0x49, 0x3d, 0x2c, 0x1e,
+ 0x0f};
+
+/*************************************************************************
+* FPGA functions
+************************************************************************/
+
+static void delay(int ms)
+{
+	unsigned long timeout = jiffies + ((ms * HZ) / 1000);
+	while (time_before(jiffies, timeout))
+		cpu_relax();
+}
+
+/*
+ * reset FPGA
+ */
+
+static void fpga_reset(int iobase)
+{
+	outb(0, IER(iobase));
+	outb(LCR_DLAB | LCR_BIT5, LCR(iobase));
+	outb(1, DLL(iobase));
+	outb(0, DLM(iobase));
+
+	outb(LCR_BIT5, LCR(iobase));
+	inb(LSR(iobase));
+	inb(MSR(iobase));
+	/* turn off FPGA supply voltage */
+	outb(MCR_OUT1 | MCR_OUT2, MCR(iobase));
+	delay(100);
+	/* turn on FPGA supply voltage again */
+	outb(MCR_DTR | MCR_RTS | MCR_OUT1 | MCR_OUT2, MCR(iobase));
+	delay(100);
+}
+
+/*
+ * send one byte to FPGA
+ */
+
+static int fpga_write(int iobase, unsigned char wrd)
+{
+	unsigned char bit;
+	int k;
+	unsigned long timeout = jiffies + HZ / 10;
+
+	for (k = 0; k < 8; k++) {
+		bit = (wrd & 0x80) ? (MCR_RTS | MCR_DTR) : MCR_DTR;
+		outb(bit | MCR_OUT1 | MCR_OUT2, MCR(iobase));
+		wrd <<= 1;
+		outb(0xfc, THR(iobase));
+		while ((inb(LSR(iobase)) & LSR_TSRE) == 0)
+			if (time_after(jiffies, timeout))
+				return -1;
+	}
+
+	return 0;
+}
+
+static unsigned char *add_mcs(unsigned char *bits, int bitrate)
+{
+	struct yam_mcs *p;
+
+	/* If it already exists, replace the bit data */
+	p = yam_data;
+	while (p) {
+		if (p->bitrate == bitrate) {
+			memcpy(p->bits, bits, YAM_FPGA_SIZE);
+			return p->bits;
+		}
+		p = p->next;
+	}
+
+	/* Allocate a new mcs */
+	if ((p = kmalloc(sizeof(struct yam_mcs), GFP_KERNEL)) == NULL) {
+		printk(KERN_WARNING "YAM: no memory to allocate mcs\n");
+		return NULL;
+	}
+	memcpy(p->bits, bits, YAM_FPGA_SIZE);
+	p->bitrate = bitrate;
+	p->next = yam_data;
+	yam_data = p;
+
+	return p->bits;
+}
+
+static unsigned char *get_mcs(int bitrate)
+{
+	struct yam_mcs *p;
+
+	p = yam_data;
+	while (p) {
+		if (p->bitrate == bitrate)
+			return p->bits;
+		p = p->next;
+	}
+
+	/* Load predefined mcs data */
+	switch (bitrate) {
+	case 1200:
+		return add_mcs(bits_1200, bitrate);
+	default:
+		return add_mcs(bits_9600, bitrate);
+	}
+}
+
+/*
+ * download bitstream to FPGA
+ * data is contained in bits[] array in yam1200.h resp. yam9600.h
+ */
+
+static int fpga_download(int iobase, int bitrate)
+{
+	int i, rc;
+	unsigned char *pbits;
+
+	pbits = get_mcs(bitrate);
+	if (pbits == NULL)
+		return -1;
+
+	fpga_reset(iobase);
+	for (i = 0; i < YAM_FPGA_SIZE; i++) {
+		if (fpga_write(iobase, pbits[i])) {
+			printk(KERN_ERR "yam: error in write cycle\n");
+			return -1;			/* write... */
+		}
+	}
+
+	fpga_write(iobase, 0xFF);
+	rc = inb(MSR(iobase));		/* check DONE signal */
+
+	/* Needed for some hardwares */
+	delay(50);
+
+	return (rc & MSR_DSR) ? 0 : -1;
+}
+
+
+/************************************************************************
+* Serial port init 
+************************************************************************/
+
+static void yam_set_uart(struct net_device *dev)
+{
+	struct yam_port *yp = netdev_priv(dev);
+	int divisor = 115200 / yp->baudrate;
+
+	outb(0, IER(dev->base_addr));
+	outb(LCR_DLAB | LCR_BIT8, LCR(dev->base_addr));
+	outb(divisor, DLL(dev->base_addr));
+	outb(0, DLM(dev->base_addr));
+	outb(LCR_BIT8, LCR(dev->base_addr));
+	outb(PTT_OFF, MCR(dev->base_addr));
+	outb(0x00, FCR(dev->base_addr));
+
+	/* Flush pending irq */
+
+	inb(RBR(dev->base_addr));
+	inb(MSR(dev->base_addr));
+
+	/* Enable rx irq */
+
+	outb(ENABLE_RTXINT, IER(dev->base_addr));
+}
+
+
+/* --------------------------------------------------------------------- */
+
+enum uart {
+	c_uart_unknown, c_uart_8250,
+	c_uart_16450, c_uart_16550, c_uart_16550A
+};
+
+static const char *uart_str[] =
+{"unknown", "8250", "16450", "16550", "16550A"};
+
+static enum uart yam_check_uart(unsigned int iobase)
+{
+	unsigned char b1, b2, b3;
+	enum uart u;
+	enum uart uart_tab[] =
+	{c_uart_16450, c_uart_unknown, c_uart_16550, c_uart_16550A};
+
+	b1 = inb(MCR(iobase));
+	outb(b1 | 0x10, MCR(iobase));	/* loopback mode */
+	b2 = inb(MSR(iobase));
+	outb(0x1a, MCR(iobase));
+	b3 = inb(MSR(iobase)) & 0xf0;
+	outb(b1, MCR(iobase));		/* restore old values */
+	outb(b2, MSR(iobase));
+	if (b3 != 0x90)
+		return c_uart_unknown;
+	inb(RBR(iobase));
+	inb(RBR(iobase));
+	outb(0x01, FCR(iobase));	/* enable FIFOs */
+	u = uart_tab[(inb(IIR(iobase)) >> 6) & 3];
+	if (u == c_uart_16450) {
+		outb(0x5a, SCR(iobase));
+		b1 = inb(SCR(iobase));
+		outb(0xa5, SCR(iobase));
+		b2 = inb(SCR(iobase));
+		if ((b1 != 0x5a) || (b2 != 0xa5))
+			u = c_uart_8250;
+	}
+	return u;
+}
+
+/******************************************************************************
+* Rx Section
+******************************************************************************/
+static inline void yam_rx_flag(struct net_device *dev, struct yam_port *yp)
+{
+	if (yp->dcd && yp->rx_len >= 3 && yp->rx_len < YAM_MAX_FRAME) {
+		int pkt_len = yp->rx_len - 2 + 1;	/* -CRC + kiss */
+		struct sk_buff *skb;
+
+		if ((yp->rx_crch & yp->rx_crcl) != 0xFF) {
+			/* Bad crc */
+		} else {
+			if (!(skb = dev_alloc_skb(pkt_len))) {
+				printk(KERN_WARNING "%s: memory squeeze, dropping packet\n", dev->name);
+				++yp->stats.rx_dropped;
+			} else {
+				unsigned char *cp;
+				skb->dev = dev;
+				cp = skb_put(skb, pkt_len);
+				*cp++ = 0;		/* KISS kludge */
+				memcpy(cp, yp->rx_buf, pkt_len - 1);
+				skb->protocol = htons(ETH_P_AX25);
+				skb->mac.raw = skb->data;
+				netif_rx(skb);
+				dev->last_rx = jiffies;
+				++yp->stats.rx_packets;
+			}
+		}
+	}
+	yp->rx_len = 0;
+	yp->rx_crcl = 0x21;
+	yp->rx_crch = 0xf3;
+}
+
+static inline void yam_rx_byte(struct net_device *dev, struct yam_port *yp, unsigned char rxb)
+{
+	if (yp->rx_len < YAM_MAX_FRAME) {
+		unsigned char c = yp->rx_crcl;
+		yp->rx_crcl = (chktabl[c] ^ yp->rx_crch);
+		yp->rx_crch = (chktabh[c] ^ rxb);
+		yp->rx_buf[yp->rx_len++] = rxb;
+	}
+}
+
+/********************************************************************************
+* TX Section
+********************************************************************************/
+
+static void ptt_on(struct net_device *dev)
+{
+	outb(PTT_ON, MCR(dev->base_addr));
+}
+
+static void ptt_off(struct net_device *dev)
+{
+	outb(PTT_OFF, MCR(dev->base_addr));
+}
+
+static int yam_send_packet(struct sk_buff *skb, struct net_device *dev)
+{
+	struct yam_port *yp = netdev_priv(dev);
+
+	skb_queue_tail(&yp->send_queue, skb);
+	dev->trans_start = jiffies;
+	return 0;
+}
+
+static void yam_start_tx(struct net_device *dev, struct yam_port *yp)
+{
+	if ((yp->tx_state == TX_TAIL) || (yp->txd == 0))
+		yp->tx_count = 1;
+	else
+		yp->tx_count = (yp->bitrate * yp->txd) / 8000;
+	yp->tx_state = TX_HEAD;
+	ptt_on(dev);
+}
+
+static unsigned short random_seed;
+
+static inline unsigned short random_num(void)
+{
+	random_seed = 28629 * random_seed + 157;
+	return random_seed;
+}
+
+static void yam_arbitrate(struct net_device *dev)
+{
+	struct yam_port *yp = netdev_priv(dev);
+
+	if (yp->magic != YAM_MAGIC || yp->tx_state != TX_OFF ||
+	    skb_queue_empty(&yp->send_queue))
+		return;
+	/* tx_state is TX_OFF and there is data to send */
+
+	if (yp->dupmode) {
+		/* Full duplex mode, don't wait */
+		yam_start_tx(dev, yp);
+		return;
+	}
+	if (yp->dcd) {
+		/* DCD on, wait slotime ... */
+		yp->slotcnt = yp->slot / 10;
+		return;
+	}
+	/* Is slottime passed ? */
+	if ((--yp->slotcnt) > 0)
+		return;
+
+	yp->slotcnt = yp->slot / 10;
+
+	/* is random > persist ? */
+	if ((random_num() % 256) > yp->pers)
+		return;
+
+	yam_start_tx(dev, yp);
+}
+
+static void yam_dotimer(unsigned long dummy)
+{
+	int i;
+
+	for (i = 0; i < NR_PORTS; i++) {
+		struct net_device *dev = yam_devs[i];
+		if (dev && netif_running(dev))
+			yam_arbitrate(dev);
+	}
+	yam_timer.expires = jiffies + HZ / 100;
+	add_timer(&yam_timer);
+}
+
+static void yam_tx_byte(struct net_device *dev, struct yam_port *yp)
+{
+	struct sk_buff *skb;
+	unsigned char b, temp;
+
+	switch (yp->tx_state) {
+	case TX_OFF:
+		break;
+	case TX_HEAD:
+		if (--yp->tx_count <= 0) {
+			if (!(skb = skb_dequeue(&yp->send_queue))) {
+				ptt_off(dev);
+				yp->tx_state = TX_OFF;
+				break;
+			}
+			yp->tx_state = TX_DATA;
+			if (skb->data[0] != 0) {
+/*                              do_kiss_params(s, skb->data, skb->len); */
+				dev_kfree_skb_any(skb);
+				break;
+			}
+			yp->tx_len = skb->len - 1;	/* strip KISS byte */
+			if (yp->tx_len >= YAM_MAX_FRAME || yp->tx_len < 2) {
+        			dev_kfree_skb_any(skb);
+				break;
+			}
+			memcpy(yp->tx_buf, skb->data + 1, yp->tx_len);
+			dev_kfree_skb_any(skb);
+			yp->tx_count = 0;
+			yp->tx_crcl = 0x21;
+			yp->tx_crch = 0xf3;
+			yp->tx_state = TX_DATA;
+		}
+		break;
+	case TX_DATA:
+		b = yp->tx_buf[yp->tx_count++];
+		outb(b, THR(dev->base_addr));
+		temp = yp->tx_crcl;
+		yp->tx_crcl = chktabl[temp] ^ yp->tx_crch;
+		yp->tx_crch = chktabh[temp] ^ b;
+		if (yp->tx_count >= yp->tx_len) {
+			yp->tx_state = TX_CRC1;
+		}
+		break;
+	case TX_CRC1:
+		yp->tx_crch = chktabl[yp->tx_crcl] ^ yp->tx_crch;
+		yp->tx_crcl = chktabh[yp->tx_crcl] ^ chktabl[yp->tx_crch] ^ 0xff;
+		outb(yp->tx_crcl, THR(dev->base_addr));
+		yp->tx_state = TX_CRC2;
+		break;
+	case TX_CRC2:
+		outb(chktabh[yp->tx_crch] ^ 0xFF, THR(dev->base_addr));
+		if (skb_queue_empty(&yp->send_queue)) {
+			yp->tx_count = (yp->bitrate * yp->txtail) / 8000;
+			if (yp->dupmode == 2)
+				yp->tx_count += (yp->bitrate * yp->holdd) / 8;
+			if (yp->tx_count == 0)
+				yp->tx_count = 1;
+			yp->tx_state = TX_TAIL;
+		} else {
+			yp->tx_count = 1;
+			yp->tx_state = TX_HEAD;
+		}
+		++yp->stats.tx_packets;
+		break;
+	case TX_TAIL:
+		if (--yp->tx_count <= 0) {
+			yp->tx_state = TX_OFF;
+			ptt_off(dev);
+		}
+		break;
+	}
+}
+
+/***********************************************************************************
+* ISR routine
+************************************************************************************/
+
+static irqreturn_t yam_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct net_device *dev;
+	struct yam_port *yp;
+	unsigned char iir;
+	int counter = 100;
+	int i;
+	int handled = 0;
+
+	for (i = 0; i < NR_PORTS; i++) {
+		dev = yam_devs[i];
+		yp = netdev_priv(dev);
+
+		if (!netif_running(dev))
+			continue;
+
+		while ((iir = IIR_MASK & inb(IIR(dev->base_addr))) != IIR_NOPEND) {
+			unsigned char msr = inb(MSR(dev->base_addr));
+			unsigned char lsr = inb(LSR(dev->base_addr));
+			unsigned char rxb;
+
+			handled = 1;
+
+			if (lsr & LSR_OE)
+				++yp->stats.rx_fifo_errors;
+
+			yp->dcd = (msr & RX_DCD) ? 1 : 0;
+
+			if (--counter <= 0) {
+				printk(KERN_ERR "%s: too many irq iir=%d\n",
+						dev->name, iir);
+				goto out;
+			}
+			if (msr & TX_RDY) {
+				++yp->nb_mdint;
+				yam_tx_byte(dev, yp);
+			}
+			if (lsr & LSR_RXC) {
+				++yp->nb_rxint;
+				rxb = inb(RBR(dev->base_addr));
+				if (msr & RX_FLAG)
+					yam_rx_flag(dev, yp);
+				else
+					yam_rx_byte(dev, yp, rxb);
+			}
+		}
+	}
+out:
+	return IRQ_RETVAL(handled);
+}
+
+#ifdef CONFIG_PROC_FS
+
+static void *yam_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	return (*pos < NR_PORTS) ? yam_devs[*pos] : NULL;
+}
+
+static void *yam_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	++*pos;
+	return (*pos < NR_PORTS) ? yam_devs[*pos] : NULL;
+}
+
+static void yam_seq_stop(struct seq_file *seq, void *v)
+{
+}
+
+static int yam_seq_show(struct seq_file *seq, void *v)
+{
+	struct net_device *dev = v;
+	const struct yam_port *yp = netdev_priv(dev);
+
+	seq_printf(seq, "Device %s\n", dev->name);
+	seq_printf(seq, "  Up       %d\n", netif_running(dev));
+	seq_printf(seq, "  Speed    %u\n", yp->bitrate);
+	seq_printf(seq, "  IoBase   0x%x\n", yp->iobase);
+	seq_printf(seq, "  BaudRate %u\n", yp->baudrate);
+	seq_printf(seq, "  IRQ      %u\n", yp->irq);
+	seq_printf(seq, "  TxState  %u\n", yp->tx_state);
+	seq_printf(seq, "  Duplex   %u\n", yp->dupmode);
+	seq_printf(seq, "  HoldDly  %u\n", yp->holdd);
+	seq_printf(seq, "  TxDelay  %u\n", yp->txd);
+	seq_printf(seq, "  TxTail   %u\n", yp->txtail);
+	seq_printf(seq, "  SlotTime %u\n", yp->slot);
+	seq_printf(seq, "  Persist  %u\n", yp->pers);
+	seq_printf(seq, "  TxFrames %lu\n", yp->stats.tx_packets);
+	seq_printf(seq, "  RxFrames %lu\n", yp->stats.rx_packets);
+	seq_printf(seq, "  TxInt    %u\n", yp->nb_mdint);
+	seq_printf(seq, "  RxInt    %u\n", yp->nb_rxint);
+	seq_printf(seq, "  RxOver   %lu\n", yp->stats.rx_fifo_errors);
+	seq_printf(seq, "\n");
+	return 0;
+}
+
+static struct seq_operations yam_seqops = {
+	.start = yam_seq_start,
+	.next = yam_seq_next,
+	.stop = yam_seq_stop,
+	.show = yam_seq_show,
+};
+
+static int yam_info_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &yam_seqops);
+}
+
+static struct file_operations yam_info_fops = {
+	.owner = THIS_MODULE,
+	.open = yam_info_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
+#endif
+
+
+/* --------------------------------------------------------------------- */
+
+static struct net_device_stats *yam_get_stats(struct net_device *dev)
+{
+	struct yam_port *yp;
+
+	if (!dev)
+		return NULL;
+
+	yp = netdev_priv(dev);
+	if (yp->magic != YAM_MAGIC)
+		return NULL;
+
+	/* 
+	 * Get the current statistics.  This may be called with the
+	 * card open or closed. 
+	 */
+	return &yp->stats;
+}
+
+/* --------------------------------------------------------------------- */
+
+static int yam_open(struct net_device *dev)
+{
+	struct yam_port *yp = netdev_priv(dev);
+	enum uart u;
+	int i;
+	int ret=0;
+
+	printk(KERN_INFO "Trying %s at iobase 0x%lx irq %u\n", dev->name, dev->base_addr, dev->irq);
+
+	if (!dev || !yp->bitrate)
+		return -ENXIO;
+	if (!dev->base_addr || dev->base_addr > 0x1000 - YAM_EXTENT ||
+		dev->irq < 2 || dev->irq > 15) {
+		return -ENXIO;
+	}
+	if (!request_region(dev->base_addr, YAM_EXTENT, dev->name))
+	{
+		printk(KERN_ERR "%s: cannot 0x%lx busy\n", dev->name, dev->base_addr);
+		return -EACCES;
+	}
+	if ((u = yam_check_uart(dev->base_addr)) == c_uart_unknown) {
+		printk(KERN_ERR "%s: cannot find uart type\n", dev->name);
+		ret = -EIO;
+		goto out_release_base;
+	}
+	if (fpga_download(dev->base_addr, yp->bitrate)) {
+		printk(KERN_ERR "%s: cannot init FPGA\n", dev->name);
+		ret = -EIO;
+		goto out_release_base;
+	}
+	outb(0, IER(dev->base_addr));
+	if (request_irq(dev->irq, yam_interrupt, SA_INTERRUPT | SA_SHIRQ, dev->name, dev)) {
+		printk(KERN_ERR "%s: irq %d busy\n", dev->name, dev->irq);
+		ret = -EBUSY;
+		goto out_release_base;
+	}
+
+	yam_set_uart(dev);
+
+	netif_start_queue(dev);
+	
+	yp->slotcnt = yp->slot / 10;
+
+	/* Reset overruns for all ports - FPGA programming makes overruns */
+	for (i = 0; i < NR_PORTS; i++) {
+		struct net_device *dev = yam_devs[i];
+		struct yam_port *yp = netdev_priv(dev);
+		inb(LSR(dev->base_addr));
+		yp->stats.rx_fifo_errors = 0;
+	}
+
+	printk(KERN_INFO "%s at iobase 0x%lx irq %u uart %s\n", dev->name, dev->base_addr, dev->irq,
+		   uart_str[u]);
+	return 0;
+
+out_release_base:
+	release_region(dev->base_addr, YAM_EXTENT);
+	return ret;
+}
+
+/* --------------------------------------------------------------------- */
+
+static int yam_close(struct net_device *dev)
+{
+	struct sk_buff *skb;
+	struct yam_port *yp = netdev_priv(dev);
+
+	if (!dev)
+		return -EINVAL;
+
+	/*
+	 * disable interrupts
+	 */
+	outb(0, IER(dev->base_addr));
+	outb(1, MCR(dev->base_addr));
+	/* Remove IRQ handler if last */
+	free_irq(dev->irq,dev);
+	release_region(dev->base_addr, YAM_EXTENT);
+	netif_stop_queue(dev);
+	while ((skb = skb_dequeue(&yp->send_queue)))
+		dev_kfree_skb(skb);
+
+	printk(KERN_INFO "%s: close yam at iobase 0x%lx irq %u\n",
+		   yam_drvname, dev->base_addr, dev->irq);
+	return 0;
+}
+
+/* --------------------------------------------------------------------- */
+
+static int yam_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	struct yam_port *yp = netdev_priv(dev);
+	struct yamdrv_ioctl_cfg yi;
+	struct yamdrv_ioctl_mcs *ym;
+	int ioctl_cmd;
+
+	if (copy_from_user(&ioctl_cmd, ifr->ifr_data, sizeof(int)))
+		 return -EFAULT;
+
+	if (yp->magic != YAM_MAGIC)
+		return -EINVAL;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (cmd != SIOCDEVPRIVATE)
+		return -EINVAL;
+
+	switch (ioctl_cmd) {
+
+	case SIOCYAMRESERVED:
+		return -EINVAL;			/* unused */
+
+	case SIOCYAMSMCS:
+		if (netif_running(dev))
+			return -EINVAL;		/* Cannot change this parameter when up */
+		if ((ym = kmalloc(sizeof(struct yamdrv_ioctl_mcs), GFP_KERNEL)) == NULL)
+			return -ENOBUFS;
+		ym->bitrate = 9600;
+		if (copy_from_user(ym, ifr->ifr_data, sizeof(struct yamdrv_ioctl_mcs))) {
+			kfree(ym);
+			return -EFAULT;
+		}
+		if (ym->bitrate > YAM_MAXBITRATE) {
+			kfree(ym);
+			return -EINVAL;
+		}
+		add_mcs(ym->bits, ym->bitrate);
+		kfree(ym);
+		break;
+
+	case SIOCYAMSCFG:
+		if (!capable(CAP_SYS_RAWIO))
+			return -EPERM;
+		if (copy_from_user(&yi, ifr->ifr_data, sizeof(struct yamdrv_ioctl_cfg)))
+			 return -EFAULT;
+
+		if ((yi.cfg.mask & YAM_IOBASE) && netif_running(dev))
+			return -EINVAL;		/* Cannot change this parameter when up */
+		if ((yi.cfg.mask & YAM_IRQ) && netif_running(dev))
+			return -EINVAL;		/* Cannot change this parameter when up */
+		if ((yi.cfg.mask & YAM_BITRATE) && netif_running(dev))
+			return -EINVAL;		/* Cannot change this parameter when up */
+		if ((yi.cfg.mask & YAM_BAUDRATE) && netif_running(dev))
+			return -EINVAL;		/* Cannot change this parameter when up */
+
+		if (yi.cfg.mask & YAM_IOBASE) {
+			yp->iobase = yi.cfg.iobase;
+			dev->base_addr = yi.cfg.iobase;
+		}
+		if (yi.cfg.mask & YAM_IRQ) {
+			if (yi.cfg.irq > 15)
+				return -EINVAL;
+			yp->irq = yi.cfg.irq;
+			dev->irq = yi.cfg.irq;
+		}
+		if (yi.cfg.mask & YAM_BITRATE) {
+			if (yi.cfg.bitrate > YAM_MAXBITRATE)
+				return -EINVAL;
+			yp->bitrate = yi.cfg.bitrate;
+		}
+		if (yi.cfg.mask & YAM_BAUDRATE) {
+			if (yi.cfg.baudrate > YAM_MAXBAUDRATE)
+				return -EINVAL;
+			yp->baudrate = yi.cfg.baudrate;
+		}
+		if (yi.cfg.mask & YAM_MODE) {
+			if (yi.cfg.mode > YAM_MAXMODE)
+				return -EINVAL;
+			yp->dupmode = yi.cfg.mode;
+		}
+		if (yi.cfg.mask & YAM_HOLDDLY) {
+			if (yi.cfg.holddly > YAM_MAXHOLDDLY)
+				return -EINVAL;
+			yp->holdd = yi.cfg.holddly;
+		}
+		if (yi.cfg.mask & YAM_TXDELAY) {
+			if (yi.cfg.txdelay > YAM_MAXTXDELAY)
+				return -EINVAL;
+			yp->txd = yi.cfg.txdelay;
+		}
+		if (yi.cfg.mask & YAM_TXTAIL) {
+			if (yi.cfg.txtail > YAM_MAXTXTAIL)
+				return -EINVAL;
+			yp->txtail = yi.cfg.txtail;
+		}
+		if (yi.cfg.mask & YAM_PERSIST) {
+			if (yi.cfg.persist > YAM_MAXPERSIST)
+				return -EINVAL;
+			yp->pers = yi.cfg.persist;
+		}
+		if (yi.cfg.mask & YAM_SLOTTIME) {
+			if (yi.cfg.slottime > YAM_MAXSLOTTIME)
+				return -EINVAL;
+			yp->slot = yi.cfg.slottime;
+			yp->slotcnt = yp->slot / 10;
+		}
+		break;
+
+	case SIOCYAMGCFG:
+		yi.cfg.mask = 0xffffffff;
+		yi.cfg.iobase = yp->iobase;
+		yi.cfg.irq = yp->irq;
+		yi.cfg.bitrate = yp->bitrate;
+		yi.cfg.baudrate = yp->baudrate;
+		yi.cfg.mode = yp->dupmode;
+		yi.cfg.txdelay = yp->txd;
+		yi.cfg.holddly = yp->holdd;
+		yi.cfg.txtail = yp->txtail;
+		yi.cfg.persist = yp->pers;
+		yi.cfg.slottime = yp->slot;
+		if (copy_to_user(ifr->ifr_data, &yi, sizeof(struct yamdrv_ioctl_cfg)))
+			 return -EFAULT;
+		break;
+
+	default:
+		return -EINVAL;
+
+	}
+
+	return 0;
+}
+
+/* --------------------------------------------------------------------- */
+
+static int yam_set_mac_address(struct net_device *dev, void *addr)
+{
+	struct sockaddr *sa = (struct sockaddr *) addr;
+
+	/* addr is an AX.25 shifted ASCII mac address */
+	memcpy(dev->dev_addr, sa->sa_data, dev->addr_len);
+	return 0;
+}
+
+/* --------------------------------------------------------------------- */
+
+static void yam_setup(struct net_device *dev)
+{
+	struct yam_port *yp = netdev_priv(dev);
+
+	yp->magic = YAM_MAGIC;
+	yp->bitrate = DEFAULT_BITRATE;
+	yp->baudrate = DEFAULT_BITRATE * 2;
+	yp->iobase = 0;
+	yp->irq = 0;
+	yp->dupmode = 0;
+	yp->holdd = DEFAULT_HOLDD;
+	yp->txd = DEFAULT_TXD;
+	yp->txtail = DEFAULT_TXTAIL;
+	yp->slot = DEFAULT_SLOT;
+	yp->pers = DEFAULT_PERS;
+	yp->dev = dev;
+
+	dev->base_addr = yp->iobase;
+	dev->irq = yp->irq;
+	SET_MODULE_OWNER(dev);
+
+	dev->open = yam_open;
+	dev->stop = yam_close;
+	dev->do_ioctl = yam_ioctl;
+	dev->hard_start_xmit = yam_send_packet;
+	dev->get_stats = yam_get_stats;
+
+	skb_queue_head_init(&yp->send_queue);
+
+#if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)
+	dev->hard_header = ax25_encapsulate;
+	dev->rebuild_header = ax25_rebuild_header;
+#else							/* CONFIG_AX25 || CONFIG_AX25_MODULE */
+	dev->hard_header = NULL;
+	dev->rebuild_header = NULL;
+#endif							/* CONFIG_AX25 || CONFIG_AX25_MODULE */
+
+	dev->set_mac_address = yam_set_mac_address;
+
+	dev->type = ARPHRD_AX25;	/* AF_AX25 device */
+	dev->hard_header_len = 73;	/* We do digipeaters now */
+	dev->mtu = 256;				/* AX25 is the default */
+	dev->addr_len = 7;			/* sizeof an ax.25 address */
+	memcpy(dev->broadcast, ax25_bcast, 7);
+	memcpy(dev->dev_addr, ax25_test, 7);
+
+}
+
+static int __init yam_init_driver(void)
+{
+	struct net_device *dev;
+	int i, err;
+	char name[IFNAMSIZ];
+
+	printk(yam_drvinfo);
+
+	for (i = 0; i < NR_PORTS; i++) {
+		sprintf(name, "yam%d", i);
+		
+		dev = alloc_netdev(sizeof(struct yam_port), name,
+				   yam_setup);
+		if (!dev) {
+			printk(KERN_ERR "yam: cannot allocate net device %s\n",
+			       dev->name);
+			err = -ENOMEM;
+			goto error;
+		}
+		
+		err = register_netdev(dev);
+		if (err) {
+			printk(KERN_WARNING "yam: cannot register net device %s\n", dev->name);
+			goto error;
+		}
+		yam_devs[i] = dev;
+
+	}
+
+	yam_timer.function = yam_dotimer;
+	yam_timer.expires = jiffies + HZ / 100;
+	add_timer(&yam_timer);
+
+	proc_net_fops_create("yam", S_IRUGO, &yam_info_fops);
+	return 0;
+ error:
+	while (--i >= 0) {
+		unregister_netdev(yam_devs[i]);
+		free_netdev(yam_devs[i]);
+	}
+	return err;
+}
+
+/* --------------------------------------------------------------------- */
+
+static void __exit yam_cleanup_driver(void)
+{
+	struct yam_mcs *p;
+	int i;
+
+	del_timer(&yam_timer);
+	for (i = 0; i < NR_PORTS; i++) {
+		struct net_device *dev = yam_devs[i];
+		if (dev) {
+			unregister_netdev(dev);
+			free_netdev(dev);
+		}
+	}
+
+	while (yam_data) {
+		p = yam_data;
+		yam_data = yam_data->next;
+		kfree(p);
+	}
+
+	proc_net_remove("yam");
+}
+
+/* --------------------------------------------------------------------- */
+
+MODULE_AUTHOR("Frederic Rible F1OAT frible@teaser.fr");
+MODULE_DESCRIPTION("Yam amateur radio modem driver");
+MODULE_LICENSE("GPL");
+
+module_init(yam_init_driver);
+module_exit(yam_cleanup_driver);
+
+/* --------------------------------------------------------------------- */
+
