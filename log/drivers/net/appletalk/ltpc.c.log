commit 5f2585d4e570f2dffd148f6e57308fb431079175
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 17:29:24 2017 -0700

    drivers/net/appletalk: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly. Adds a static variable to hold the
    polled net_device.
    
    Cc: David Howells <dhowells@redhat.com>
    Cc: netdev@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index cc3dc9337eae..75a5a9b87c5a 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -694,6 +694,7 @@ static int do_read(struct net_device *dev, void *cbuf, int cbuflen,
 /* end of idle handlers -- what should be seen is do_read, do_write */
 
 static struct timer_list ltpc_timer;
+static struct net_device *ltpc_timer_dev;
 
 static netdev_tx_t ltpc_xmit(struct sk_buff *skb, struct net_device *dev);
 
@@ -867,10 +868,8 @@ static void set_multicast_list(struct net_device *dev)
 
 static int ltpc_poll_counter;
 
-static void ltpc_poll(unsigned long l)
+static void ltpc_poll(struct timer_list *unused)
 {
-	struct net_device *dev = (struct net_device *) l;
-
 	del_timer(&ltpc_timer);
 
 	if(debug & DEBUG_VERBOSE) {
@@ -882,7 +881,7 @@ static void ltpc_poll(unsigned long l)
 	}
 
 	/* poll 20 times per second */
-	idle(dev);
+	idle(ltpc_timer_dev);
 	ltpc_timer.expires = jiffies + HZ/20;
 	add_timer(&ltpc_timer);
 }
@@ -1161,7 +1160,8 @@ struct net_device * __init ltpc_probe(void)
 		dev->irq = 0;
 		/* polled mode -- 20 times per second */
 		/* this is really, really slow... should it poll more often? */
-		setup_timer(&ltpc_timer, ltpc_poll, (unsigned long)dev);
+		ltpc_timer_dev = dev;
+		timer_setup(&ltpc_timer, ltpc_poll, 0);
 
 		ltpc_timer.expires = jiffies + HZ/20;
 		add_timer(&ltpc_timer);

commit 9ba650a4ebdde5f5f59a62ed51563d7c4586e492
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 17:29:23 2017 -0700

    appletalk: Remove unneeded synchronization
    
    The use of del_timer_sync() will make sure a timer is not rescheduled.
    As such, there is no need to add external signals to kill timers. In
    preparation for switching the timer callback argument to the timer
    pointer, this drops the .data argument since it doesn't serve a meaningful
    purpose here.
    
    Cc: David Howells <dhowells@redhat.com>
    Cc: netdev@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index e4aa374caa4d..cc3dc9337eae 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -880,14 +880,10 @@ static void ltpc_poll(unsigned long l)
 		}
 		ltpc_poll_counter--;
 	}
-  
-	if (!dev)
-		return;  /* we've been downed */
 
 	/* poll 20 times per second */
 	idle(dev);
 	ltpc_timer.expires = jiffies + HZ/20;
-	
 	add_timer(&ltpc_timer);
 }
 
@@ -1252,8 +1248,6 @@ static void __exit ltpc_cleanup(void)
 	if(debug & DEBUG_VERBOSE) printk("unregister_netdev\n");
 	unregister_netdev(dev_ltpc);
 
-	ltpc_timer.data = 0;  /* signal the poll routine that we're done */
-
 	del_timer_sync(&ltpc_timer);
 
 	if(debug & DEBUG_VERBOSE) printk("freeing irq\n");

commit ba7400ed88adcd07af0dc004be1cf5ab2443cb44
Author: Allen Pais <allen.lkml@gmail.com>
Date:   Thu Sep 21 22:35:13 2017 +0530

    drivers: net: appletalk: use setup_timer() helper.
    
    Use setup_timer function instead of initializing timer with the
        function and data fields.
    
    Signed-off-by: Allen Pais <allen.lkml@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index ac755d2950a6..e4aa374caa4d 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -1165,9 +1165,7 @@ struct net_device * __init ltpc_probe(void)
 		dev->irq = 0;
 		/* polled mode -- 20 times per second */
 		/* this is really, really slow... should it poll more often? */
-		init_timer(&ltpc_timer);
-		ltpc_timer.function=ltpc_poll;
-		ltpc_timer.data = (unsigned long) dev;
+		setup_timer(&ltpc_timer, ltpc_poll, (unsigned long)dev);
 
 		ltpc_timer.expires = jiffies + HZ/20;
 		add_timer(&ltpc_timer);

commit 6621f85d79775f71de9623fdfc9135fc494d6863
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 4 16:54:25 2017 +0100

    Annotate hardware config module parameters in drivers/net/appletalk/
    
    When the kernel is running in secure boot mode, we lock down the kernel to
    prevent userspace from modifying the running kernel image.  Whilst this
    includes prohibiting access to things like /dev/mem, it must also prevent
    access by means of configuring driver modules in such a way as to cause a
    device to access or modify the kernel image.
    
    To this end, annotate module_param* statements that refer to hardware
    configuration and indicate for future reference what type of parameter they
    specify.  The parameter parser in the core sees this information and can
    skip such parameters with an error message if the kernel is locked down.
    The module initialisation then runs as normal, but just sees whatever the
    default values for those parameters is.
    
    Note that we do still need to do the module initialisation because some
    drivers have viable defaults set in case parameters aren't specified and
    some drivers support automatic configuration (e.g. PNP or PCI) in addition
    to manually coded parameters.
    
    This patch annotates drivers in drivers/net/appletalk/.
    
    Suggested-by: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Arnaldo Carvalho de Melo <acme@kernel.org>
    cc: netdev@vger.kernel.org

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index 01e2ac55c137..ac755d2950a6 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -1231,9 +1231,9 @@ static struct net_device *dev_ltpc;
 
 MODULE_LICENSE("GPL");
 module_param(debug, int, 0);
-module_param(io, int, 0);
-module_param(irq, int, 0);
-module_param(dma, int, 0);
+module_param_hw(io, int, ioport, 0);
+module_param_hw(irq, int, irq, 0);
+module_param_hw(dma, int, dma, 0);
 
 
 static int __init ltpc_module_init(void)

commit 8c6ffba0eddc8c110dbf444f51354ce42069abfc
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Mon Jul 15 11:20:32 2013 +0930

    PTR_RET is now PTR_ERR_OR_ZERO(): Replace most.
    
    Sweep of the simple cases.
    
    Cc: netdev@vger.kernel.org
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Acked-by: David S. Miller <davem@davemloft.net>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index b5782cdf0bca..01e2ac55c137 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -1243,7 +1243,7 @@ static int __init ltpc_module_init(void)
 		       "ltpc: Autoprobing is not recommended for modules\n");
 
 	dev_ltpc = ltpc_probe();
-	return PTR_RET(dev_ltpc);
+	return PTR_ERR_OR_ZERO(dev_ltpc);
 }
 module_init(ltpc_module_init);
 #endif

commit b5497eeb37d7d4a5a61b91f64efedc90d1ad6fa3
Author: Thomas Meyer <thomas@m3y3r.de>
Date:   Mon Aug 6 07:51:16 2012 +0000

    net: Use PTR_RET rather than if(IS_ERR(.. [1]
    
    The semantic patch that makes this change is available
    in scripts/coccinelle/api/ptr_ret.cocci.
    
    More information about semantic patching is available at
    http://coccinelle.lip6.fr/
    
    Signed-off-by: Thomas Meyer <thomas@m3y3r.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index 0910dce3996d..b5782cdf0bca 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -1243,9 +1243,7 @@ static int __init ltpc_module_init(void)
 		       "ltpc: Autoprobing is not recommended for modules\n");
 
 	dev_ltpc = ltpc_probe();
-	if (IS_ERR(dev_ltpc))
-		return PTR_ERR(dev_ltpc);
-	return 0;
+	return PTR_RET(dev_ltpc);
 }
 module_init(ltpc_module_init);
 #endif

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index 6057b30417a2..0910dce3996d 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -229,7 +229,6 @@ static int dma;
 #include <linux/bitops.h>
 #include <linux/gfp.h>
 
-#include <asm/system.h>
 #include <asm/dma.h>
 #include <asm/io.h>
 

commit afc4b13df143122f99a0eb10bfefb216c2806de0
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Tue Aug 16 06:29:01 2011 +0000

    net: remove use of ndo_set_multicast_list in drivers
    
    replace it by ndo_set_rx_mode
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index 34ffb5422628..6057b30417a2 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -1014,7 +1014,7 @@ static int __init ltpc_probe_dma(int base, int dma)
 static const struct net_device_ops ltpc_netdev = {
 	.ndo_start_xmit		= ltpc_xmit,
 	.ndo_do_ioctl		= ltpc_ioctl,
-	.ndo_set_multicast_list = set_multicast_list,
+	.ndo_set_rx_mode	= set_multicast_list,
 };
 
 struct net_device * __init ltpc_probe(void)

commit 43d620c82985b19008d87a437b4cf83f356264f7
Author: Joe Perches <joe@perches.com>
Date:   Thu Jun 16 19:08:06 2011 +0000

    drivers/net: Remove casts of void *
    
    Unnecessary casts of void * clutter the code.
    
    These are the remainder casts after several specific
    patches to remove netdev_priv and dev_priv.
    
    Done via coccinelle script (and a little editing):
    
    $ cat cast_void_pointer.cocci
    @@
    type T;
    T *pt;
    void *pv;
    @@
    
    - pt = (T *)pv;
    + pt = pv;
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Sjur Br√¶ndeland <sjur.brandeland@stericsson.com>
    Acked-By: Chris Snook <chris.snook@gmail.com>
    Acked-by: Jon Mason <jdmason@kudzu.us>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: David Dillow <dave@thedillows.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index e69eead12ec7..34ffb5422628 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -652,9 +652,9 @@ static int do_write(struct net_device *dev, void *cbuf, int cbuflen,
 	int ret;
 
 	if(i) {
-		qels[i].cbuf = (unsigned char *) cbuf;
+		qels[i].cbuf = cbuf;
 		qels[i].cbuflen = cbuflen;
-		qels[i].dbuf = (unsigned char *) dbuf;
+		qels[i].dbuf = dbuf;
 		qels[i].dbuflen = dbuflen;
 		qels[i].QWrite = 1;
 		qels[i].mailbox = i;  /* this should be initted rather */
@@ -676,9 +676,9 @@ static int do_read(struct net_device *dev, void *cbuf, int cbuflen,
 	int ret;
 
 	if(i) {
-		qels[i].cbuf = (unsigned char *) cbuf;
+		qels[i].cbuf = cbuf;
 		qels[i].cbuflen = cbuflen;
-		qels[i].dbuf = (unsigned char *) dbuf;
+		qels[i].dbuf = dbuf;
 		qels[i].dbuflen = dbuflen;
 		qels[i].QWrite = 0;
 		qels[i].mailbox = i;  /* this should be initted rather */

commit 807540baae406c84dcb9c1c8ef07a56d2d2ae84a
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Thu Sep 23 05:40:09 2010 +0000

    drivers/net: return operator cleanup
    
    Change "return (EXPR);" to "return EXPR;"
    
    return is not a function, parentheses are not required.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index adc07551739e..e69eead12ec7 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -727,7 +727,7 @@ static int sendup_buffer (struct net_device *dev)
 
 	if (ltc->command != LT_RCVLAP) {
 		printk("unknown command 0x%02x from ltpc card\n",ltc->command);
-		return(-1);
+		return -1;
 	}
 	dnode = ltc->dnode;
 	snode = ltc->snode;

commit a4b770972b8f819e408d7cc3ae9637e15bff62f6
Author: Joe Perches <joe@perches.com>
Date:   Fri May 14 00:19:28 2010 -0700

    drivers/net: Remove unnecessary returns from void function()s
    
    This patch removes from drivers/net/ all the unnecessary
    return; statements that precede the last closing brace of
    void functions.
    
    It does not remove the returns that are immediately
    preceded by a label as gcc doesn't like that.
    
    It also does not remove null void functions with return.
    
    Done via:
    $ grep -rP --include=*.[ch] -l "return;\n}" net/ | \
      xargs perl -i -e 'local $/ ; while (<>) { s/\n[ \t\n]+return;\n}/\n}/g; print; }'
    
    with some cleanups by hand.
    
    Compile tested x86 allmodconfig only.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index 6af65b656f31..adc07551739e 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -641,7 +641,6 @@ static void idle(struct net_device *dev)
 		inb_p(base+7);
 		inb_p(base+7);
 	}
-	return;
 }
 
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index 8ea4ec705bef..6af65b656f31 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -215,7 +215,6 @@ static int dma;
 #include <linux/ioport.h>
 #include <linux/spinlock.h>
 #include <linux/in.h>
-#include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/errno.h>
 #include <linux/init.h>
@@ -228,6 +227,7 @@ static int dma;
 #include <linux/timer.h>
 #include <linux/atalk.h>
 #include <linux/bitops.h>
+#include <linux/gfp.h>
 
 #include <asm/system.h>
 #include <asm/dma.h>

commit 0ddf477b8a9b02412a6cabd51c486998811c7dd1
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Sat Feb 20 00:13:58 2010 +0000

    net: convert multiple drivers to use netdev_for_each_mc_addr, part3
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index dbfbd3b7ff86..8ea4ec705bef 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -1125,7 +1125,6 @@ struct net_device * __init ltpc_probe(void)
 		printk(KERN_INFO "Apple/Farallon LocalTalk-PC card at %03x, DMA%d.  Using polled mode.\n",io,dma);
 
 	dev->netdev_ops = &ltpc_netdev;
-	dev->mc_list = NULL;
 	dev->base_addr = io;
 	dev->irq = irq;
 	dev->dma = dma;

commit a0607fd3a25ba1848a63a0d925e36d914735ab47
Author: Joe Perches <joe@perches.com>
Date:   Wed Nov 18 23:29:17 2009 -0800

    drivers/net: request_irq - Remove unnecessary leading & from second arg
    
    Not as fancy as coccinelle.  Checkpatch errors ignored.
    Compile tested allyesconfig x86, not all files compiled.
    
    grep -rPl --include=*.[ch] "\brequest_irq\s*\([^,\)]+,\s*\&" drivers/net | while read file ; do \
            perl -i -e 'local $/; while (<>) { s@(\brequest_irq\s*\([^,\)]+,\s*)\&@\1@g ; print ; }' $file ;\
    done
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index 08760baece7a..dbfbd3b7ff86 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -1158,7 +1158,7 @@ struct net_device * __init ltpc_probe(void)
 	}
 
 	/* grab it and don't let go :-) */
-	if (irq && request_irq( irq, &ltpc_interrupt, 0, "ltpc", dev) >= 0)
+	if (irq && request_irq( irq, ltpc_interrupt, 0, "ltpc", dev) >= 0)
 	{
 		(void) inb_p(io+7);  /* enable interrupts from board */
 		(void) inb_p(io+7);  /* and reset irq line */

commit 0fc480987e69f22b9212f087545b4d1ca6950807
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Mon Aug 31 19:50:56 2009 +0000

    appletalk: convert drivers to netdev_tx_t
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index c80fb9cf8ffa..08760baece7a 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -697,7 +697,7 @@ static int do_read(struct net_device *dev, void *cbuf, int cbuflen,
 
 static struct timer_list ltpc_timer;
 
-static int ltpc_xmit(struct sk_buff *skb, struct net_device *dev);
+static netdev_tx_t ltpc_xmit(struct sk_buff *skb, struct net_device *dev);
 
 static int read_30 ( struct net_device *dev)
 {
@@ -895,7 +895,7 @@ static void ltpc_poll(unsigned long l)
 
 /* DDP to LLAP translation */
 
-static int ltpc_xmit(struct sk_buff *skb, struct net_device *dev)
+static netdev_tx_t ltpc_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	/* in kernel 1.3.xx, on entry skb->data points to ddp header,
 	 * and skb->len is the length of the ddp data + ddp header

commit 6ed106549d17474ca17a16057f4c0ed4eba5a7ca
Author: Patrick McHardy <kaber@trash.net>
Date:   Tue Jun 23 06:03:08 2009 +0000

    net: use NETDEV_TX_OK instead of 0 in ndo_start_xmit() functions
    
    This patch is the result of an automatic spatch transformation to convert
    all ndo_start_xmit() return values of 0 to NETDEV_TX_OK.
    
    Some occurences are missed by the automatic conversion, those will be
    handled in a seperate patch.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index b642647170be..c80fb9cf8ffa 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -932,7 +932,7 @@ static int ltpc_xmit(struct sk_buff *skb, struct net_device *dev)
 	dev->stats.tx_bytes += skb->len;
 
 	dev_kfree_skb(skb);
-	return 0;
+	return NETDEV_TX_OK;
 }
 
 /* initialization stuff */

commit 98a1708de1bfa5fe1c490febba850d6043d3c7fa
Author: Martin Olsson <martin@minimum.se>
Date:   Wed Apr 22 18:21:29 2009 +0200

    trivial: fix typos s/paramter/parameter/ and s/excute/execute/ in documentation and source comments.
    
    Signed-off-by: Martin Olsson <martin@minimum.se>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index 78cc71469136..b642647170be 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -1220,7 +1220,7 @@ static int __init ltpc_setup(char *str)
 		if (ints[0] > 2) {
 			dma = ints[3];
 		}
-		/* ignore any other paramters */
+		/* ignore any other parameters */
 	}
 	return 1;
 }

commit 816b26f500e9d78ccd56e1c8ffac85f5d8765c00
Author: Stephen Hemminger <shemminger@linux-foundation.org>
Date:   Thu Mar 26 15:11:21 2009 +0000

    appletalk: convert LTPC to net_device_ops
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index 74d9787311e6..78cc71469136 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -1012,6 +1012,12 @@ static int __init ltpc_probe_dma(int base, int dma)
 	return (want & 2) ? 3 : 1;
 }
 
+static const struct net_device_ops ltpc_netdev = {
+	.ndo_start_xmit		= ltpc_xmit,
+	.ndo_do_ioctl		= ltpc_ioctl,
+	.ndo_set_multicast_list = set_multicast_list,
+};
+
 struct net_device * __init ltpc_probe(void)
 {
 	struct net_device *dev;
@@ -1118,13 +1124,7 @@ struct net_device * __init ltpc_probe(void)
 	else
 		printk(KERN_INFO "Apple/Farallon LocalTalk-PC card at %03x, DMA%d.  Using polled mode.\n",io,dma);
 
-	/* Fill in the fields of the device structure with ethernet-generic values. */
-	dev->hard_start_xmit = ltpc_xmit;
-
-	/* add the ltpc-specific things */
-	dev->do_ioctl = &ltpc_ioctl;
-
-	dev->set_multicast_list = &set_multicast_list;
+	dev->netdev_ops = &ltpc_netdev;
 	dev->mc_list = NULL;
 	dev->base_addr = io;
 	dev->irq = irq;

commit 4fafc12328a4e2d4afbc4541c46be014e22c5b66
Author: Stephen Hemminger <shemminger@linux-foundation.org>
Date:   Thu Mar 26 15:11:20 2009 +0000

    appletalk: convert LTPC to use internal net_device_stats
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index dc4d49605603..74d9787311e6 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -261,7 +261,6 @@ static unsigned char *ltdmacbuf;
 
 struct ltpc_private
 {
-	struct net_device_stats stats;
 	struct atalk_addr my_addr;
 };
 
@@ -699,7 +698,6 @@ static int do_read(struct net_device *dev, void *cbuf, int cbuflen,
 static struct timer_list ltpc_timer;
 
 static int ltpc_xmit(struct sk_buff *skb, struct net_device *dev);
-static struct net_device_stats *ltpc_get_stats(struct net_device *dev);
 
 static int read_30 ( struct net_device *dev)
 {
@@ -726,8 +724,6 @@ static int sendup_buffer (struct net_device *dev)
 	int dnode, snode, llaptype, len; 
 	int sklen;
 	struct sk_buff *skb;
-	struct ltpc_private *ltpc_priv = netdev_priv(dev);
-	struct net_device_stats *stats = &ltpc_priv->stats;
 	struct lt_rcvlap *ltc = (struct lt_rcvlap *) ltdmacbuf;
 
 	if (ltc->command != LT_RCVLAP) {
@@ -779,8 +775,8 @@ static int sendup_buffer (struct net_device *dev)
 
 	skb_reset_transport_header(skb);
 
-	stats->rx_packets++;
-	stats->rx_bytes+=skb->len;
+	dev->stats.rx_packets++;
+	dev->stats.rx_bytes += skb->len;
 
 	/* toss it onwards */
 	netif_rx(skb);
@@ -904,10 +900,6 @@ static int ltpc_xmit(struct sk_buff *skb, struct net_device *dev)
 	/* in kernel 1.3.xx, on entry skb->data points to ddp header,
 	 * and skb->len is the length of the ddp data + ddp header
 	 */
-
-	struct ltpc_private *ltpc_priv = netdev_priv(dev);
-	struct net_device_stats *stats = &ltpc_priv->stats;
-
 	int i;
 	struct lt_sendlap cbuf;
 	unsigned char *hdr;
@@ -936,20 +928,13 @@ static int ltpc_xmit(struct sk_buff *skb, struct net_device *dev)
 		printk("\n");
 	}
 
-	stats->tx_packets++;
-	stats->tx_bytes+=skb->len;
+	dev->stats.tx_packets++;
+	dev->stats.tx_bytes += skb->len;
 
 	dev_kfree_skb(skb);
 	return 0;
 }
 
-static struct net_device_stats *ltpc_get_stats(struct net_device *dev)
-{
-	struct ltpc_private *ltpc_priv = netdev_priv(dev);
-	struct net_device_stats *stats = &ltpc_priv->stats;
-	return stats;
-}
-
 /* initialization stuff */
   
 static int __init ltpc_probe_dma(int base, int dma)
@@ -1135,7 +1120,6 @@ struct net_device * __init ltpc_probe(void)
 
 	/* Fill in the fields of the device structure with ethernet-generic values. */
 	dev->hard_start_xmit = ltpc_xmit;
-	dev->get_stats = ltpc_get_stats;
 
 	/* add the ltpc-specific things */
 	dev->do_ioctl = &ltpc_ioctl;

commit 454d7c9b14e20fd1949e2686e9de4a2926e01476
Author: Wang Chen <wangchen@cn.fujitsu.com>
Date:   Wed Nov 12 23:37:49 2008 -0800

    netdevice: safe convert to netdev_priv() #part-1
    
    We have some reasons to kill netdev->priv:
    1. netdev->priv is equal to netdev_priv().
    2. netdev_priv() wraps the calculation of netdev->priv's offset, obviously
       netdev_priv() is more flexible than netdev->priv.
    But we cann't kill netdev->priv, because so many drivers reference to it
    directly.
    
    This patch is a safe convert for netdev->priv to netdev_priv(netdev).
    Since all of the netdev->priv is only for read.
    But it is too big to be sent in one mail.
    I split it to 4 parts and make every part smaller than 100,000 bytes,
    which is max size allowed by vger.
    
    Signed-off-by: Wang Chen <wangchen@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index 8d109a5f5571..dc4d49605603 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -726,7 +726,8 @@ static int sendup_buffer (struct net_device *dev)
 	int dnode, snode, llaptype, len; 
 	int sklen;
 	struct sk_buff *skb;
-	struct net_device_stats *stats = &((struct ltpc_private *)dev->priv)->stats;
+	struct ltpc_private *ltpc_priv = netdev_priv(dev);
+	struct net_device_stats *stats = &ltpc_priv->stats;
 	struct lt_rcvlap *ltc = (struct lt_rcvlap *) ltdmacbuf;
 
 	if (ltc->command != LT_RCVLAP) {
@@ -822,7 +823,8 @@ static int ltpc_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 {
 	struct sockaddr_at *sa = (struct sockaddr_at *) &ifr->ifr_addr;
 	/* we'll keep the localtalk node address in dev->pa_addr */
-	struct atalk_addr *aa = &((struct ltpc_private *)dev->priv)->my_addr;
+	struct ltpc_private *ltpc_priv = netdev_priv(dev);
+	struct atalk_addr *aa = &ltpc_priv->my_addr;
 	struct lt_init c;
 	int ltflags;
 
@@ -903,7 +905,8 @@ static int ltpc_xmit(struct sk_buff *skb, struct net_device *dev)
 	 * and skb->len is the length of the ddp data + ddp header
 	 */
 
-	struct net_device_stats *stats = &((struct ltpc_private *)dev->priv)->stats;
+	struct ltpc_private *ltpc_priv = netdev_priv(dev);
+	struct net_device_stats *stats = &ltpc_priv->stats;
 
 	int i;
 	struct lt_sendlap cbuf;
@@ -942,7 +945,8 @@ static int ltpc_xmit(struct sk_buff *skb, struct net_device *dev)
 
 static struct net_device_stats *ltpc_get_stats(struct net_device *dev)
 {
-	struct net_device_stats *stats = &((struct ltpc_private *) dev->priv)->stats;
+	struct ltpc_private *ltpc_priv = netdev_priv(dev);
+	struct net_device_stats *stats = &ltpc_priv->stats;
 	return stats;
 }
 

commit babcda74e9d96bb58fd9c6c5112dbdbff169e695
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Nov 3 21:11:17 2008 -0800

    drivers/net: Kill now superfluous ->last_rx stores.
    
    The generic packet receive code takes care of setting
    netdev->last_rx when necessary, for the sake of the
    bonding ARP monitor.
    
    Drivers need not do it any more.
    
    Some cases had to be skipped over because the drivers
    were making use of the ->last_rx value themselves.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index fef5560bc7a2..8d109a5f5571 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -783,7 +783,6 @@ static int sendup_buffer (struct net_device *dev)
 
 	/* toss it onwards */
 	netif_rx(skb);
-	dev->last_rx = jiffies;
 	return 0;
 }
 

commit 32c9874759651b69e496f89ec9e5e6702f67ffca
Author: Jon Schindler <jkschind@gmail.com>
Date:   Wed Mar 5 18:49:21 2008 -0800

    drivers/net/appletalk/ltpc.c: replace init_module&cleanup_module with module_init&module_exit
    
    Replaced init_module and cleanup_module with static functions and
    module_init/module_exit.
    
    Signed-off-by: Jon Schindler <jkschind@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index 6ab2c2d4d673..fef5560bc7a2 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -1252,7 +1252,7 @@ module_param(irq, int, 0);
 module_param(dma, int, 0);
 
 
-int __init init_module(void)
+static int __init ltpc_module_init(void)
 {
         if(io == 0)
 		printk(KERN_NOTICE
@@ -1263,6 +1263,7 @@ int __init init_module(void)
 		return PTR_ERR(dev_ltpc);
 	return 0;
 }
+module_init(ltpc_module_init);
 #endif
 
 static void __exit ltpc_cleanup(void)

commit 3b04ddde02cf1b6f14f2697da5c20eca5715017f
Author: Stephen Hemminger <shemminger@linux-foundation.org>
Date:   Tue Oct 9 01:40:57 2007 -0700

    [NET]: Move hardware header operations out of netdevice.
    
    Since hardware header operations are part of the protocol class
    not the device instance, make them into a separate object and
    save memory.
    
    Signed-off-by: Stephen Hemminger <shemminger@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index cb4744e56905..6ab2c2d4d673 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -870,15 +870,6 @@ static void set_multicast_list(struct net_device *dev)
 	/* Actually netatalk needs fixing! */
 }
 
-static int ltpc_hard_header (struct sk_buff *skb, struct net_device *dev, 
-	unsigned short type, void *daddr, void *saddr, unsigned len)
-{
-	if(debug & DEBUG_VERBOSE)
-		printk("ltpc_hard_header called for device %s\n",
-			dev->name);
-	return 0;
-}
-
 static int ltpc_poll_counter;
 
 static void ltpc_poll(unsigned long l)
@@ -1141,7 +1132,6 @@ struct net_device * __init ltpc_probe(void)
 
 	/* Fill in the fields of the device structure with ethernet-generic values. */
 	dev->hard_start_xmit = ltpc_xmit;
-	dev->hard_header = ltpc_hard_header;
 	dev->get_stats = ltpc_get_stats;
 
 	/* add the ltpc-specific things */

commit 10d024c1b2fd58af8362670d7d6e5ae52fc33353
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Sep 17 13:11:17 2007 -0700

    [NET]: Nuke SET_MODULE_OWNER macro.
    
    It's been a useless no-op for long enough in 2.6 so I figured it's time to
    remove it.  The number of people that could object because they're
    maintaining unified 2.4 and 2.6 drivers is probably rather small.
    
    [ Handled drivers added by netdev tree and some missed IRDA cases... -DaveM ]
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index 6a6cbd331a16..cb4744e56905 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -1046,8 +1046,6 @@ struct net_device * __init ltpc_probe(void)
 	if (!dev)
 		goto out;
 
-	SET_MODULE_OWNER(dev);
-
 	/* probe for the I/O port address */
 	
 	if (io != 0x240 && request_region(0x220,8,"ltpc")) {

commit 27d7ff46a3498d3debc6ba68fb8014c702b81170
Author: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
Date:   Sat Mar 31 11:55:19 2007 -0300

    [SK_BUFF]: Introduce skb_copy_to_linear_data{_offset}
    
    To clearly state the intent of copying to linear sk_buffs, _offset being a
    overly long variant but interesting for the sake of saving some bytes.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index 43c17c85c97b..6a6cbd331a16 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -774,7 +774,7 @@ static int sendup_buffer (struct net_device *dev)
 	skb_pull(skb,3);
 
 	/* copy ddp(s,e)hdr + contents */
-	memcpy(skb->data,(void*)ltdmabuf,len);
+	skb_copy_to_linear_data(skb, ltdmabuf, len);
 
 	skb_reset_transport_header(skb);
 

commit 9c70220b73908f64792422a2c39c593c4792f2c5
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Wed Apr 25 18:04:18 2007 -0700

    [SK_BUFF]: Introduce skb_transport_header(skb)
    
    For the places where we need a pointer to the transport header, it is
    still legal to touch skb->h.raw directly if just adding to,
    subtracting from or setting it to another layer header.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index dc3bce992dcf..43c17c85c97b 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -917,6 +917,7 @@ static int ltpc_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	int i;
 	struct lt_sendlap cbuf;
+	unsigned char *hdr;
 
 	cbuf.command = LT_SENDLAP;
 	cbuf.dnode = skb->data[0];
@@ -932,11 +933,13 @@ static int ltpc_xmit(struct sk_buff *skb, struct net_device *dev)
 		printk("\n");
 	}
 
-	do_write(dev,&cbuf,sizeof(cbuf),skb->h.raw,skb->len);
+	hdr = skb_transport_header(skb);
+	do_write(dev, &cbuf, sizeof(cbuf), hdr, skb->len);
 
 	if(debug & DEBUG_UPPER) {
 		printk("sent %d ddp bytes\n",skb->len);
-		for(i=0;i<skb->len;i++) printk("%02x ",skb->h.raw[i]);
+		for (i = 0; i < skb->len; i++)
+			printk("%02x ", hdr[i]);
 		printk("\n");
 	}
 

commit badff6d01a8589a1c828b0bf118903ca38627f4e
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Mar 13 13:06:52 2007 -0300

    [SK_BUFF]: Introduce skb_reset_transport_header(skb)
    
    For the common, open coded 'skb->h.raw = skb->data' operation, so that we can
    later turn skb->h.raw into a offset, reducing the size of struct sk_buff in
    64bit land while possibly keeping it as a pointer on 32bit.
    
    This one touches just the most simple cases:
    
    skb->h.raw = skb->data;
    skb->h.raw = {skb_push|[__]skb_pull}()
    
    The next ones will handle the slightly more "complex" cases.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index 12682439f8bd..dc3bce992dcf 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -776,7 +776,7 @@ static int sendup_buffer (struct net_device *dev)
 	/* copy ddp(s,e)hdr + contents */
 	memcpy(skb->data,(void*)ltdmabuf,len);
 
-	skb->h.raw = skb->data;
+	skb_reset_transport_header(skb);
 
 	stats->rx_packets++;
 	stats->rx_bytes+=skb->len;
@@ -923,7 +923,7 @@ static int ltpc_xmit(struct sk_buff *skb, struct net_device *dev)
 	cbuf.laptype = skb->data[2];
 	skb_pull(skb,3);	/* skip past LLAP header */
 	cbuf.length = skb->len;	/* this is host order */
-	skb->h.raw=skb->data;
+	skb_reset_transport_header(skb);
 
 	if(debug & DEBUG_UPPER) {
 		printk("command ");

commit 459a98ed881802dee55897441bc7f77af614368e
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Mon Mar 19 15:30:44 2007 -0700

    [SK_BUFF]: Introduce skb_reset_mac_header(skb)
    
    For the common, open coded 'skb->mac.raw = skb->data' operation, so that we can
    later turn skb->mac.raw into a offset, reducing the size of struct sk_buff in
    64bit land while possibly keeping it as a pointer on 32bit.
    
    This one touches just the most simple case, next will handle the slightly more
    "complex" cases.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index 2ea44ce49810..12682439f8bd 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -770,7 +770,7 @@ static int sendup_buffer (struct net_device *dev)
 	skb->data[0] = dnode;
 	skb->data[1] = snode;
 	skb->data[2] = llaptype;
-	skb->mac.raw = skb->data;	/* save pointer to llap header */
+	skb_reset_mac_header(skb);	/* save pointer to llap header */
 	skb_pull(skb,3);
 
 	/* copy ddp(s,e)hdr + contents */

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index d5666c37cb0d..2ea44ce49810 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -790,7 +790,7 @@ static int sendup_buffer (struct net_device *dev)
 /* the handler for the board interrupt */
  
 static irqreturn_t
-ltpc_interrupt(int irq, void *dev_id, struct pt_regs *reg_ptr)
+ltpc_interrupt(int irq, void *dev_id)
 {
 	struct net_device *dev = dev_id;
 

commit 2c4ee8f907fc4a3c69273a958f853bf4b358eb49
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Wed Jun 22 22:19:52 2005 -0700

    [LTPC]: Replace schedule_timeout() with ssleep()/msleep()
    
    Use ssleep() / msleep() [as appropriate]
    instead of schedule_timeout() to guarantee the task delays as expected.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Acked-by: Arnaldo Carvalho de Melo <acme@conectiva.com.br>
    Signed-off-by: Maximilian Attems <janitor@sternwelten.at>
    Signed-off-by: Domen Puncer <domen@coderock.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index db4f369637b6..d5666c37cb0d 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -1109,8 +1109,7 @@ struct net_device * __init ltpc_probe(void)
 	inb_p(io+1);
 	inb_p(io+3);
 
-	set_current_state(TASK_UNINTERRUPTIBLE);
-	schedule_timeout(2*HZ/100);
+	msleep(20);
 
 	inb_p(io+0);
 	inb_p(io+2);
@@ -1120,8 +1119,7 @@ struct net_device * __init ltpc_probe(void)
 	inb_p(io+5); /* enable dma */
 	inb_p(io+6); /* tri-state interrupt line */
 
-	set_current_state(TASK_UNINTERRUPTIBLE);
-	schedule_timeout(HZ);
+	ssleep(1);
 	
 	/* now, figure out which dma channel we're using, unless it's
 	   already been specified */

commit 3ef4e9a8db6c65de7c7f4bc013d62b0d73f50dce
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu May 5 14:25:59 2005 -0700

    [ATALK]: Add alloc_ltalkdev().
    
    this matches the API used by other link layer like ethernet or token
    ring.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
index ad8e943231a1..db4f369637b6 100644
--- a/drivers/net/appletalk/ltpc.c
+++ b/drivers/net/appletalk/ltpc.c
@@ -1039,7 +1039,7 @@ struct net_device * __init ltpc_probe(void)
 	unsigned long f;
 	unsigned long timeout;
 
-	dev = alloc_netdev(sizeof(struct ltpc_private), "lt%d", ltalk_setup);
+	dev = alloc_ltalkdev(sizeof(struct ltpc_private));
 	if (!dev)
 		goto out;
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c
new file mode 100644
index 000000000000..ad8e943231a1
--- /dev/null
+++ b/drivers/net/appletalk/ltpc.c
@@ -0,0 +1,1313 @@
+/***    ltpc.c -- a driver for the LocalTalk PC card.
+ *
+ *      Copyright (c) 1995,1996 Bradford W. Johnson <johns393@maroon.tc.umn.edu>
+ *
+ *      This software may be used and distributed according to the terms
+ *      of the GNU General Public License, incorporated herein by reference.
+ *
+ *      This is ALPHA code at best.  It may not work for you.  It may
+ *      damage your equipment.  It may damage your relations with other
+ *      users of your network.  Use it at your own risk!
+ *
+ *      Based in part on:
+ *      skeleton.c      by Donald Becker
+ *      dummy.c         by Nick Holloway and Alan Cox
+ *      loopback.c      by Ross Biro, Fred van Kampen, Donald Becker
+ *      the netatalk source code (UMICH)
+ *      lots of work on the card...
+ *
+ *      I do not have access to the (proprietary) SDK that goes with the card.
+ *      If you do, I don't want to know about it, and you can probably write
+ *      a better driver yourself anyway.  This does mean that the pieces that
+ *      talk to the card are guesswork on my part, so use at your own risk!
+ *
+ *      This is my first try at writing Linux networking code, and is also
+ *      guesswork.  Again, use at your own risk!  (Although on this part, I'd
+ *      welcome suggestions)
+ *
+ *      This is a loadable kernel module which seems to work at my site
+ *      consisting of a 1.2.13 linux box running netatalk 1.3.3, and with
+ *      the kernel support from 1.3.3b2 including patches routing.patch
+ *      and ddp.disappears.from.chooser.  In order to run it, you will need
+ *      to patch ddp.c and aarp.c in the kernel, but only a little...
+ *
+ *      I'm fairly confident that while this is arguably badly written, the
+ *      problems that people experience will be "higher level", that is, with
+ *      complications in the netatalk code.  The driver itself doesn't do
+ *      anything terribly complicated -- it pretends to be an ether device
+ *      as far as netatalk is concerned, strips the DDP data out of the ether
+ *      frame and builds a LLAP packet to send out the card.  In the other
+ *      direction, it receives LLAP frames from the card and builds a fake
+ *      ether packet that it then tosses up to the networking code.  You can
+ *      argue (correctly) that this is an ugly way to do things, but it
+ *      requires a minimal amount of fooling with the code in ddp.c and aarp.c.
+ *
+ *      The card will do a lot more than is used here -- I *think* it has the
+ *      layers up through ATP.  Even if you knew how that part works (which I
+ *      don't) it would be a big job to carve up the kernel ddp code to insert
+ *      things at a higher level, and probably a bad idea...
+ *
+ *      There are a number of other cards that do LocalTalk on the PC.  If
+ *      nobody finds any insurmountable (at the netatalk level) problems
+ *      here, this driver should encourage people to put some work into the
+ *      other cards (some of which I gather are still commercially available)
+ *      and also to put hooks for LocalTalk into the official ddp code.
+ *
+ *      I welcome comments and suggestions.  This is my first try at Linux
+ *      networking stuff, and there are probably lots of things that I did
+ *      suboptimally.  
+ *
+ ***/
+
+/***
+ *
+ * $Log: ltpc.c,v $
+ * Revision 1.1.2.1  2000/03/01 05:35:07  jgarzik
+ * at and tr cleanup
+ *
+ * Revision 1.8  1997/01/28 05:44:54  bradford
+ * Clean up for non-module a little.
+ * Hacked about a bit to clean things up - Alan Cox 
+ * Probably broken it from the origina 1.8
+ *
+
+ * 1998/11/09: David Huggins-Daines <dhd@debian.org>
+ * Cleaned up the initialization code to use the standard autoirq methods,
+   and to probe for things in the standard order of i/o, irq, dma.  This
+   removes the "reset the reset" hack, because I couldn't figure out an
+   easy way to get the card to trigger an interrupt after it.
+ * Added support for passing configuration parameters on the kernel command
+   line and through insmod
+ * Changed the device name from "ltalk0" to "lt0", both to conform with the
+   other localtalk driver, and to clear up the inconsistency between the
+   module and the non-module versions of the driver :-)
+ * Added a bunch of comments (I was going to make some enums for the state
+   codes and the register offsets, but I'm still not sure exactly what their
+   semantics are)
+ * Don't poll anymore in interrupt-driven mode
+ * It seems to work as a module now (as of 2.1.127), but I don't think
+   I'm responsible for that...
+
+ *
+ * Revision 1.7  1996/12/12 03:42:33  bradford
+ * DMA alloc cribbed from 3c505.c.
+ *
+ * Revision 1.6  1996/12/12 03:18:58  bradford
+ * Added virt_to_bus; works in 2.1.13.
+ *
+ * Revision 1.5  1996/12/12 03:13:22  root
+ * xmitQel initialization -- think through better though.
+ *
+ * Revision 1.4  1996/06/18 14:55:55  root
+ * Change names to ltpc. Tabs. Took a shot at dma alloc,
+ * although more needs to be done eventually.
+ *
+ * Revision 1.3  1996/05/22 14:59:39  root
+ * Change dev->open, dev->close to track dummy.c in 1.99.(around 7)
+ *
+ * Revision 1.2  1996/05/22 14:58:24  root
+ * Change tabs mostly.
+ *
+ * Revision 1.1  1996/04/23 04:45:09  root
+ * Initial revision
+ *
+ * Revision 0.16  1996/03/05 15:59:56  root
+ * Change ARPHRD_LOCALTLK definition to the "real" one.
+ *
+ * Revision 0.15  1996/03/05 06:28:30  root
+ * Changes for kernel 1.3.70.  Still need a few patches to kernel, but
+ * it's getting closer.
+ *
+ * Revision 0.14  1996/02/25 17:38:32  root
+ * More cleanups.  Removed query to card on get_stats.
+ *
+ * Revision 0.13  1996/02/21  16:27:40  root
+ * Refix debug_print_skb.  Fix mac.raw gotcha that appeared in 1.3.65.
+ * Clean up receive code a little.
+ *
+ * Revision 0.12  1996/02/19  16:34:53  root
+ * Fix debug_print_skb.  Kludge outgoing snet to 0 when using startup
+ * range.  Change debug to mask: 1 for verbose, 2 for higher level stuff
+ * including packet printing, 4 for lower level (card i/o) stuff.
+ *
+ * Revision 0.11  1996/02/12  15:53:38  root
+ * Added router sends (requires new aarp.c patch)
+ *
+ * Revision 0.10  1996/02/11  00:19:35  root
+ * Change source LTALK_LOGGING debug switch to insmod ... debug=2.
+ *
+ * Revision 0.9  1996/02/10  23:59:35  root
+ * Fixed those fixes for 1.2 -- DANGER!  The at.h that comes with netatalk
+ * has a *different* definition of struct sockaddr_at than the Linux kernel
+ * does.  This is an "insidious and invidious" bug...
+ * (Actually the preceding comment is false -- it's the atalk.h in the
+ * ancient atalk-0.06 that's the problem)
+ *
+ * Revision 0.8  1996/02/10 19:09:00  root
+ * Merge 1.3 changes.  Tested OK under 1.3.60.
+ *
+ * Revision 0.7  1996/02/10 17:56:56  root
+ * Added debug=1 parameter on insmod for debugging prints.  Tried
+ * to fix timer unload on rmmod, but I don't think that's the problem.
+ *
+ * Revision 0.6  1995/12/31  19:01:09  root
+ * Clean up rmmod, irq comments per feedback from Corin Anderson (Thanks Corey!)
+ * Clean up initial probing -- sometimes the card wakes up latched in reset.
+ *
+ * Revision 0.5  1995/12/22  06:03:44  root
+ * Added comments in front and cleaned up a bit.
+ * This version sent out to people.
+ *
+ * Revision 0.4  1995/12/18  03:46:44  root
+ * Return shortDDP to longDDP fake to 0/0.  Added command structs.
+ *
+ ***/
+
+/* ltpc jumpers are:
+*
+*	Interrupts -- set at most one.  If none are set, the driver uses
+*	polled mode.  Because the card was developed in the XT era, the
+*	original documentation refers to IRQ2.  Since you'll be running
+*	this on an AT (or later) class machine, that really means IRQ9.
+*
+*	SW1	IRQ 4
+*	SW2	IRQ 3
+*	SW3	IRQ 9 (2 in original card documentation only applies to XT)
+*
+*
+*	DMA -- choose DMA 1 or 3, and set both corresponding switches.
+*
+*	SW4	DMA 3
+*	SW5	DMA 1
+*	SW6	DMA 3
+*	SW7	DMA 1
+*
+*
+*	I/O address -- choose one.  
+*
+*	SW8	220 / 240
+*/
+
+/*	To have some stuff logged, do 
+*	insmod ltpc.o debug=1
+*
+*	For a whole bunch of stuff, use higher numbers.
+*
+*	The default is 0, i.e. no messages except for the probe results.
+*/
+
+/* insmod-tweakable variables */
+static int debug;
+#define DEBUG_VERBOSE 1
+#define DEBUG_UPPER 2
+#define DEBUG_LOWER 4
+
+static int io;
+static int irq;
+static int dma;
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/spinlock.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_arp.h>
+#include <linux/if_ltalk.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/atalk.h>
+#include <linux/bitops.h>
+
+#include <asm/system.h>
+#include <asm/dma.h>
+#include <asm/io.h>
+
+/* our stuff */
+#include "ltpc.h"
+
+static DEFINE_SPINLOCK(txqueue_lock);
+static DEFINE_SPINLOCK(mbox_lock);
+
+/* function prototypes */
+static int do_read(struct net_device *dev, void *cbuf, int cbuflen,
+	void *dbuf, int dbuflen);
+static int sendup_buffer (struct net_device *dev);
+
+/* Dma Memory related stuff, cribbed directly from 3c505.c */
+
+static unsigned long dma_mem_alloc(int size)
+{
+        int order = get_order(size);
+
+        return __get_dma_pages(GFP_KERNEL, order);
+}
+
+/* DMA data buffer, DMA command buffer */
+static unsigned char *ltdmabuf;
+static unsigned char *ltdmacbuf;
+
+/* private struct, holds our appletalk address */
+
+struct ltpc_private
+{
+	struct net_device_stats stats;
+	struct atalk_addr my_addr;
+};
+
+/* transmit queue element struct */
+
+struct xmitQel {
+	struct xmitQel *next;
+	/* command buffer */
+	unsigned char *cbuf;
+	short cbuflen;
+	/* data buffer */
+	unsigned char *dbuf;
+	short dbuflen;
+	unsigned char QWrite;	/* read or write data */
+	unsigned char mailbox;
+};
+
+/* the transmit queue itself */
+
+static struct xmitQel *xmQhd, *xmQtl;
+
+static void enQ(struct xmitQel *qel)
+{
+	unsigned long flags;
+	qel->next = NULL;
+	
+	spin_lock_irqsave(&txqueue_lock, flags);
+	if (xmQtl) {
+		xmQtl->next = qel;
+	} else {
+		xmQhd = qel;
+	}
+	xmQtl = qel;
+	spin_unlock_irqrestore(&txqueue_lock, flags);
+
+	if (debug & DEBUG_LOWER)
+		printk("enqueued a 0x%02x command\n",qel->cbuf[0]);
+}
+
+static struct xmitQel *deQ(void)
+{
+	unsigned long flags;
+	int i;
+	struct xmitQel *qel=NULL;
+	
+	spin_lock_irqsave(&txqueue_lock, flags);
+	if (xmQhd) {
+		qel = xmQhd;
+		xmQhd = qel->next;
+		if(!xmQhd) xmQtl = NULL;
+	}
+	spin_unlock_irqrestore(&txqueue_lock, flags);
+
+	if ((debug & DEBUG_LOWER) && qel) {
+		int n;
+		printk(KERN_DEBUG "ltpc: dequeued command ");
+		n = qel->cbuflen;
+		if (n>100) n=100;
+		for(i=0;i<n;i++) printk("%02x ",qel->cbuf[i]);
+		printk("\n");
+	}
+
+	return qel;
+}
+
+/* and... the queue elements we'll be using */
+static struct xmitQel qels[16];
+
+/* and their corresponding mailboxes */
+static unsigned char mailbox[16];
+static unsigned char mboxinuse[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+
+static int wait_timeout(struct net_device *dev, int c)
+{
+	/* returns true if it stayed c */
+	/* this uses base+6, but it's ok */
+	int i;
+
+	/* twenty second or so total */
+
+	for(i=0;i<200000;i++) {
+		if ( c != inb_p(dev->base_addr+6) ) return 0;
+		udelay(100);
+	}
+	return 1; /* timed out */
+}
+
+/* get the first free mailbox */
+
+static int getmbox(void)
+{
+	unsigned long flags;
+	int i;
+
+	spin_lock_irqsave(&mbox_lock, flags);
+	for(i=1;i<16;i++) if(!mboxinuse[i]) {
+		mboxinuse[i]=1;
+		spin_unlock_irqrestore(&mbox_lock, flags);
+		return i;
+	}
+	spin_unlock_irqrestore(&mbox_lock, flags);
+	return 0;
+}
+
+/* read a command from the card */
+static void handlefc(struct net_device *dev)
+{
+	/* called *only* from idle, non-reentrant */
+	int dma = dev->dma;
+	int base = dev->base_addr;
+	unsigned long flags;
+
+
+	flags=claim_dma_lock();
+	disable_dma(dma);
+	clear_dma_ff(dma);
+	set_dma_mode(dma,DMA_MODE_READ);
+	set_dma_addr(dma,virt_to_bus(ltdmacbuf));
+	set_dma_count(dma,50);
+	enable_dma(dma);
+	release_dma_lock(flags);
+
+	inb_p(base+3);
+	inb_p(base+2);
+
+	if ( wait_timeout(dev,0xfc) ) printk("timed out in handlefc\n");
+}
+
+/* read data from the card */
+static void handlefd(struct net_device *dev)
+{
+	int dma = dev->dma;
+	int base = dev->base_addr;
+	unsigned long flags;
+
+	flags=claim_dma_lock();
+	disable_dma(dma);
+	clear_dma_ff(dma);
+	set_dma_mode(dma,DMA_MODE_READ);
+	set_dma_addr(dma,virt_to_bus(ltdmabuf));
+	set_dma_count(dma,800);
+	enable_dma(dma);
+	release_dma_lock(flags);
+
+	inb_p(base+3);
+	inb_p(base+2);
+
+	if ( wait_timeout(dev,0xfd) ) printk("timed out in handlefd\n");
+	sendup_buffer(dev);
+} 
+
+static void handlewrite(struct net_device *dev)
+{
+	/* called *only* from idle, non-reentrant */
+	/* on entry, 0xfb and ltdmabuf holds data */
+	int dma = dev->dma;
+	int base = dev->base_addr;
+	unsigned long flags;
+	
+	flags=claim_dma_lock();
+	disable_dma(dma);
+	clear_dma_ff(dma);
+	set_dma_mode(dma,DMA_MODE_WRITE);
+	set_dma_addr(dma,virt_to_bus(ltdmabuf));
+	set_dma_count(dma,800);
+	enable_dma(dma);
+	release_dma_lock(flags);
+	
+	inb_p(base+3);
+	inb_p(base+2);
+
+	if ( wait_timeout(dev,0xfb) ) {
+		flags=claim_dma_lock();
+		printk("timed out in handlewrite, dma res %d\n",
+			get_dma_residue(dev->dma) );
+		release_dma_lock(flags);
+	}
+}
+
+static void handleread(struct net_device *dev)
+{
+	/* on entry, 0xfb */
+	/* on exit, ltdmabuf holds data */
+	int dma = dev->dma;
+	int base = dev->base_addr;
+	unsigned long flags;
+
+	
+	flags=claim_dma_lock();
+	disable_dma(dma);
+	clear_dma_ff(dma);
+	set_dma_mode(dma,DMA_MODE_READ);
+	set_dma_addr(dma,virt_to_bus(ltdmabuf));
+	set_dma_count(dma,800);
+	enable_dma(dma);
+	release_dma_lock(flags);
+
+	inb_p(base+3);
+	inb_p(base+2);
+	if ( wait_timeout(dev,0xfb) ) printk("timed out in handleread\n");
+}
+
+static void handlecommand(struct net_device *dev)
+{
+	/* on entry, 0xfa and ltdmacbuf holds command */
+	int dma = dev->dma;
+	int base = dev->base_addr;
+	unsigned long flags;
+
+	flags=claim_dma_lock();
+	disable_dma(dma);
+	clear_dma_ff(dma);
+	set_dma_mode(dma,DMA_MODE_WRITE);
+	set_dma_addr(dma,virt_to_bus(ltdmacbuf));
+	set_dma_count(dma,50);
+	enable_dma(dma);
+	release_dma_lock(flags);
+	inb_p(base+3);
+	inb_p(base+2);
+	if ( wait_timeout(dev,0xfa) ) printk("timed out in handlecommand\n");
+} 
+
+/* ready made command for getting the result from the card */
+static unsigned char rescbuf[2] = {LT_GETRESULT,0};
+static unsigned char resdbuf[2];
+
+static int QInIdle;
+
+/* idle expects to be called with the IRQ line high -- either because of
+ * an interrupt, or because the line is tri-stated
+ */
+
+static void idle(struct net_device *dev)
+{
+	unsigned long flags;
+	int state;
+	/* FIXME This is initialized to shut the warning up, but I need to
+	 * think this through again.
+	 */
+	struct xmitQel *q = NULL;
+	int oops;
+	int i;
+	int base = dev->base_addr;
+
+	spin_lock_irqsave(&txqueue_lock, flags);
+	if(QInIdle) {
+		spin_unlock_irqrestore(&txqueue_lock, flags);
+		return;
+	}
+	QInIdle = 1;
+	spin_unlock_irqrestore(&txqueue_lock, flags);
+
+	/* this tri-states the IRQ line */
+	(void) inb_p(base+6);
+
+	oops = 100;
+
+loop:
+	if (0>oops--) { 
+		printk("idle: looped too many times\n");
+		goto done;
+	}
+
+	state = inb_p(base+6);
+	if (state != inb_p(base+6)) goto loop;
+
+	switch(state) {
+		case 0xfc:
+			/* incoming command */
+			if (debug & DEBUG_LOWER) printk("idle: fc\n");
+			handlefc(dev); 
+			break;
+		case 0xfd:
+			/* incoming data */
+			if(debug & DEBUG_LOWER) printk("idle: fd\n");
+			handlefd(dev); 
+			break;
+		case 0xf9:
+			/* result ready */
+			if (debug & DEBUG_LOWER) printk("idle: f9\n");
+			if(!mboxinuse[0]) {
+				mboxinuse[0] = 1;
+				qels[0].cbuf = rescbuf;
+				qels[0].cbuflen = 2;
+				qels[0].dbuf = resdbuf;
+				qels[0].dbuflen = 2;
+				qels[0].QWrite = 0;
+				qels[0].mailbox = 0;
+				enQ(&qels[0]);
+			}
+			inb_p(dev->base_addr+1);
+			inb_p(dev->base_addr+0);
+			if( wait_timeout(dev,0xf9) )
+				printk("timed out idle f9\n");
+			break;
+		case 0xf8:
+			/* ?? */
+			if (xmQhd) {
+				inb_p(dev->base_addr+1);
+				inb_p(dev->base_addr+0);
+				if(wait_timeout(dev,0xf8) )
+					printk("timed out idle f8\n");
+			} else {
+				goto done;
+			}
+			break;
+		case 0xfa:
+			/* waiting for command */
+			if(debug & DEBUG_LOWER) printk("idle: fa\n");
+			if (xmQhd) {
+				q=deQ();
+				memcpy(ltdmacbuf,q->cbuf,q->cbuflen);
+				ltdmacbuf[1] = q->mailbox;
+				if (debug>1) { 
+					int n;
+					printk("ltpc: sent command     ");
+					n = q->cbuflen;
+					if (n>100) n=100;
+					for(i=0;i<n;i++)
+						printk("%02x ",ltdmacbuf[i]);
+					printk("\n");
+				}
+				handlecommand(dev);
+					if(0xfa==inb_p(base+6)) {
+						/* we timed out, so return */
+						goto done;
+					} 
+			} else {
+				/* we don't seem to have a command */
+				if (!mboxinuse[0]) {
+					mboxinuse[0] = 1;
+					qels[0].cbuf = rescbuf;
+					qels[0].cbuflen = 2;
+					qels[0].dbuf = resdbuf;
+					qels[0].dbuflen = 2;
+					qels[0].QWrite = 0;
+					qels[0].mailbox = 0;
+					enQ(&qels[0]);
+				} else {
+					printk("trouble: response command already queued\n");
+					goto done;
+				}
+			} 
+			break;
+		case 0Xfb:
+			/* data transfer ready */
+			if(debug & DEBUG_LOWER) printk("idle: fb\n");
+			if(q->QWrite) {
+				memcpy(ltdmabuf,q->dbuf,q->dbuflen);
+				handlewrite(dev);
+			} else {
+				handleread(dev);
+				/* non-zero mailbox numbers are for
+				   commmands, 0 is for GETRESULT
+				   requests */
+				if(q->mailbox) {
+					memcpy(q->dbuf,ltdmabuf,q->dbuflen);
+				} else { 
+					/* this was a result */
+					mailbox[ 0x0f & ltdmabuf[0] ] = ltdmabuf[1];
+					mboxinuse[0]=0;
+				}
+			}
+			break;
+	}
+	goto loop;
+
+done:
+	QInIdle=0;
+
+	/* now set the interrupts back as appropriate */
+	/* the first read takes it out of tri-state (but still high) */
+	/* the second resets it */
+	/* note that after this point, any read of base+6 will
+	   trigger an interrupt */
+
+	if (dev->irq) {
+		inb_p(base+7);
+		inb_p(base+7);
+	}
+	return;
+}
+
+
+static int do_write(struct net_device *dev, void *cbuf, int cbuflen,
+	void *dbuf, int dbuflen)
+{
+
+	int i = getmbox();
+	int ret;
+
+	if(i) {
+		qels[i].cbuf = (unsigned char *) cbuf;
+		qels[i].cbuflen = cbuflen;
+		qels[i].dbuf = (unsigned char *) dbuf;
+		qels[i].dbuflen = dbuflen;
+		qels[i].QWrite = 1;
+		qels[i].mailbox = i;  /* this should be initted rather */
+		enQ(&qels[i]);
+		idle(dev);
+		ret = mailbox[i];
+		mboxinuse[i]=0;
+		return ret;
+	}
+	printk("ltpc: could not allocate mbox\n");
+	return -1;
+}
+
+static int do_read(struct net_device *dev, void *cbuf, int cbuflen,
+	void *dbuf, int dbuflen)
+{
+
+	int i = getmbox();
+	int ret;
+
+	if(i) {
+		qels[i].cbuf = (unsigned char *) cbuf;
+		qels[i].cbuflen = cbuflen;
+		qels[i].dbuf = (unsigned char *) dbuf;
+		qels[i].dbuflen = dbuflen;
+		qels[i].QWrite = 0;
+		qels[i].mailbox = i;  /* this should be initted rather */
+		enQ(&qels[i]);
+		idle(dev);
+		ret = mailbox[i];
+		mboxinuse[i]=0;
+		return ret;
+	}
+	printk("ltpc: could not allocate mbox\n");
+	return -1;
+}
+
+/* end of idle handlers -- what should be seen is do_read, do_write */
+
+static struct timer_list ltpc_timer;
+
+static int ltpc_xmit(struct sk_buff *skb, struct net_device *dev);
+static struct net_device_stats *ltpc_get_stats(struct net_device *dev);
+
+static int read_30 ( struct net_device *dev)
+{
+	lt_command c;
+	c.getflags.command = LT_GETFLAGS;
+	return do_read(dev, &c, sizeof(c.getflags),&c,0);
+}
+
+static int set_30 (struct net_device *dev,int x)
+{
+	lt_command c;
+	c.setflags.command = LT_SETFLAGS;
+	c.setflags.flags = x;
+	return do_write(dev, &c, sizeof(c.setflags),&c,0);
+}
+
+/* LLAP to DDP translation */
+
+static int sendup_buffer (struct net_device *dev)
+{
+	/* on entry, command is in ltdmacbuf, data in ltdmabuf */
+	/* called from idle, non-reentrant */
+
+	int dnode, snode, llaptype, len; 
+	int sklen;
+	struct sk_buff *skb;
+	struct net_device_stats *stats = &((struct ltpc_private *)dev->priv)->stats;
+	struct lt_rcvlap *ltc = (struct lt_rcvlap *) ltdmacbuf;
+
+	if (ltc->command != LT_RCVLAP) {
+		printk("unknown command 0x%02x from ltpc card\n",ltc->command);
+		return(-1);
+	}
+	dnode = ltc->dnode;
+	snode = ltc->snode;
+	llaptype = ltc->laptype;
+	len = ltc->length; 
+
+	sklen = len;
+	if (llaptype == 1) 
+		sklen += 8;  /* correct for short ddp */
+	if(sklen > 800) {
+		printk(KERN_INFO "%s: nonsense length in ltpc command 0x14: 0x%08x\n",
+			dev->name,sklen);
+		return -1;
+	}
+
+	if ( (llaptype==0) || (llaptype>2) ) {
+		printk(KERN_INFO "%s: unknown LLAP type: %d\n",dev->name,llaptype);
+		return -1;
+	}
+
+
+	skb = dev_alloc_skb(3+sklen);
+	if (skb == NULL) 
+	{
+		printk("%s: dropping packet due to memory squeeze.\n",
+			dev->name);
+		return -1;
+	}
+	skb->dev = dev;
+
+	if (sklen > len)
+		skb_reserve(skb,8);
+	skb_put(skb,len+3);
+	skb->protocol = htons(ETH_P_LOCALTALK);
+	/* add LLAP header */
+	skb->data[0] = dnode;
+	skb->data[1] = snode;
+	skb->data[2] = llaptype;
+	skb->mac.raw = skb->data;	/* save pointer to llap header */
+	skb_pull(skb,3);
+
+	/* copy ddp(s,e)hdr + contents */
+	memcpy(skb->data,(void*)ltdmabuf,len);
+
+	skb->h.raw = skb->data;
+
+	stats->rx_packets++;
+	stats->rx_bytes+=skb->len;
+
+	/* toss it onwards */
+	netif_rx(skb);
+	dev->last_rx = jiffies;
+	return 0;
+}
+
+/* the handler for the board interrupt */
+ 
+static irqreturn_t
+ltpc_interrupt(int irq, void *dev_id, struct pt_regs *reg_ptr)
+{
+	struct net_device *dev = dev_id;
+
+	if (dev==NULL) {
+		printk("ltpc_interrupt: unknown device.\n");
+		return IRQ_NONE;
+	}
+
+	inb_p(dev->base_addr+6);  /* disable further interrupts from board */
+
+	idle(dev); /* handle whatever is coming in */
+ 
+	/* idle re-enables interrupts from board */ 
+
+	return IRQ_HANDLED;
+}
+
+/***
+ *
+ *    The ioctls that the driver responds to are:
+ *
+ *    SIOCSIFADDR -- do probe using the passed node hint.
+ *    SIOCGIFADDR -- return net, node.
+ *
+ *    some of this stuff should be done elsewhere.
+ *
+ ***/
+
+static int ltpc_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	struct sockaddr_at *sa = (struct sockaddr_at *) &ifr->ifr_addr;
+	/* we'll keep the localtalk node address in dev->pa_addr */
+	struct atalk_addr *aa = &((struct ltpc_private *)dev->priv)->my_addr;
+	struct lt_init c;
+	int ltflags;
+
+	if(debug & DEBUG_VERBOSE) printk("ltpc_ioctl called\n");
+
+	switch(cmd) {
+		case SIOCSIFADDR:
+
+			aa->s_net  = sa->sat_addr.s_net;
+      
+			/* this does the probe and returns the node addr */
+			c.command = LT_INIT;
+			c.hint = sa->sat_addr.s_node;
+
+			aa->s_node = do_read(dev,&c,sizeof(c),&c,0);
+
+			/* get all llap frames raw */
+			ltflags = read_30(dev);
+			ltflags |= LT_FLAG_ALLLAP;
+			set_30 (dev,ltflags);  
+
+			dev->broadcast[0] = 0xFF;
+			dev->dev_addr[0] = aa->s_node;
+
+			dev->addr_len=1;
+   
+			return 0;
+
+		case SIOCGIFADDR:
+
+			sa->sat_addr.s_net = aa->s_net;
+			sa->sat_addr.s_node = aa->s_node;
+
+			return 0;
+
+		default: 
+			return -EINVAL;
+	}
+}
+
+static void set_multicast_list(struct net_device *dev)
+{
+	/* This needs to be present to keep netatalk happy. */
+	/* Actually netatalk needs fixing! */
+}
+
+static int ltpc_hard_header (struct sk_buff *skb, struct net_device *dev, 
+	unsigned short type, void *daddr, void *saddr, unsigned len)
+{
+	if(debug & DEBUG_VERBOSE)
+		printk("ltpc_hard_header called for device %s\n",
+			dev->name);
+	return 0;
+}
+
+static int ltpc_poll_counter;
+
+static void ltpc_poll(unsigned long l)
+{
+	struct net_device *dev = (struct net_device *) l;
+
+	del_timer(&ltpc_timer);
+
+	if(debug & DEBUG_VERBOSE) {
+		if (!ltpc_poll_counter) {
+			ltpc_poll_counter = 50;
+			printk("ltpc poll is alive\n");
+		}
+		ltpc_poll_counter--;
+	}
+  
+	if (!dev)
+		return;  /* we've been downed */
+
+	/* poll 20 times per second */
+	idle(dev);
+	ltpc_timer.expires = jiffies + HZ/20;
+	
+	add_timer(&ltpc_timer);
+}
+
+/* DDP to LLAP translation */
+
+static int ltpc_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	/* in kernel 1.3.xx, on entry skb->data points to ddp header,
+	 * and skb->len is the length of the ddp data + ddp header
+	 */
+
+	struct net_device_stats *stats = &((struct ltpc_private *)dev->priv)->stats;
+
+	int i;
+	struct lt_sendlap cbuf;
+
+	cbuf.command = LT_SENDLAP;
+	cbuf.dnode = skb->data[0];
+	cbuf.laptype = skb->data[2];
+	skb_pull(skb,3);	/* skip past LLAP header */
+	cbuf.length = skb->len;	/* this is host order */
+	skb->h.raw=skb->data;
+
+	if(debug & DEBUG_UPPER) {
+		printk("command ");
+		for(i=0;i<6;i++)
+			printk("%02x ",((unsigned char *)&cbuf)[i]);
+		printk("\n");
+	}
+
+	do_write(dev,&cbuf,sizeof(cbuf),skb->h.raw,skb->len);
+
+	if(debug & DEBUG_UPPER) {
+		printk("sent %d ddp bytes\n",skb->len);
+		for(i=0;i<skb->len;i++) printk("%02x ",skb->h.raw[i]);
+		printk("\n");
+	}
+
+	stats->tx_packets++;
+	stats->tx_bytes+=skb->len;
+
+	dev_kfree_skb(skb);
+	return 0;
+}
+
+static struct net_device_stats *ltpc_get_stats(struct net_device *dev)
+{
+	struct net_device_stats *stats = &((struct ltpc_private *) dev->priv)->stats;
+	return stats;
+}
+
+/* initialization stuff */
+  
+static int __init ltpc_probe_dma(int base, int dma)
+{
+	int want = (dma == 3) ? 2 : (dma == 1) ? 1 : 3;
+  	unsigned long timeout;
+  	unsigned long f;
+  
+  	if (want & 1) {
+		if (request_dma(1,"ltpc")) {
+			want &= ~1;
+		} else {
+			f=claim_dma_lock();
+			disable_dma(1);
+			clear_dma_ff(1);
+			set_dma_mode(1,DMA_MODE_WRITE);
+			set_dma_addr(1,virt_to_bus(ltdmabuf));
+			set_dma_count(1,sizeof(struct lt_mem));
+			enable_dma(1);
+			release_dma_lock(f);
+		}
+	}
+	if (want & 2) {
+		if (request_dma(3,"ltpc")) {
+			want &= ~2;
+		} else {
+			f=claim_dma_lock();
+			disable_dma(3);
+			clear_dma_ff(3);
+			set_dma_mode(3,DMA_MODE_WRITE);
+			set_dma_addr(3,virt_to_bus(ltdmabuf));
+			set_dma_count(3,sizeof(struct lt_mem));
+			enable_dma(3);
+			release_dma_lock(f);
+		}
+	}
+	/* set up request */
+
+	/* FIXME -- do timings better! */
+
+	ltdmabuf[0] = LT_READMEM;
+	ltdmabuf[1] = 1;  /* mailbox */
+	ltdmabuf[2] = 0; ltdmabuf[3] = 0;  /* address */
+	ltdmabuf[4] = 0; ltdmabuf[5] = 1;  /* read 0x0100 bytes */
+	ltdmabuf[6] = 0; /* dunno if this is necessary */
+
+	inb_p(io+1);
+	inb_p(io+0);
+	timeout = jiffies+100*HZ/100;
+	while(time_before(jiffies, timeout)) {
+		if ( 0xfa == inb_p(io+6) ) break;
+	}
+
+	inb_p(io+3);
+	inb_p(io+2);
+	while(time_before(jiffies, timeout)) {
+		if ( 0xfb == inb_p(io+6) ) break;
+	}
+
+	/* release the other dma channel (if we opened both of them) */
+
+	if ((want & 2) && (get_dma_residue(3)==sizeof(struct lt_mem))) {
+		want &= ~2;
+		free_dma(3);
+	}
+
+	if ((want & 1) && (get_dma_residue(1)==sizeof(struct lt_mem))) {
+		want &= ~1;
+		free_dma(1);
+	}
+
+	if (!want)
+		return 0;
+
+	return (want & 2) ? 3 : 1;
+}
+
+struct net_device * __init ltpc_probe(void)
+{
+	struct net_device *dev;
+	int err = -ENOMEM;
+	int x=0,y=0;
+	int autoirq;
+	unsigned long f;
+	unsigned long timeout;
+
+	dev = alloc_netdev(sizeof(struct ltpc_private), "lt%d", ltalk_setup);
+	if (!dev)
+		goto out;
+
+	SET_MODULE_OWNER(dev);
+
+	/* probe for the I/O port address */
+	
+	if (io != 0x240 && request_region(0x220,8,"ltpc")) {
+		x = inb_p(0x220+6);
+		if ( (x!=0xff) && (x>=0xf0) ) {
+			io = 0x220;
+			goto got_port;
+		}
+		release_region(0x220,8);
+	}
+	if (io != 0x220 && request_region(0x240,8,"ltpc")) {
+		y = inb_p(0x240+6);
+		if ( (y!=0xff) && (y>=0xf0) ){ 
+			io = 0x240;
+			goto got_port;
+		}
+		release_region(0x240,8);
+	} 
+
+	/* give up in despair */
+	printk(KERN_ERR "LocalTalk card not found; 220 = %02x, 240 = %02x.\n", x,y);
+	err = -ENODEV;
+	goto out1;
+
+ got_port:
+	/* probe for the IRQ line */
+	if (irq < 2) {
+		unsigned long irq_mask;
+
+		irq_mask = probe_irq_on();
+		/* reset the interrupt line */
+		inb_p(io+7);
+		inb_p(io+7);
+		/* trigger an interrupt (I hope) */
+		inb_p(io+6);
+		mdelay(2);
+		autoirq = probe_irq_off(irq_mask);
+
+		if (autoirq == 0) {
+			printk(KERN_ERR "ltpc: probe at %#x failed to detect IRQ line.\n", io);
+		} else {
+			irq = autoirq;
+		}
+	}
+
+	/* allocate a DMA buffer */
+	ltdmabuf = (unsigned char *) dma_mem_alloc(1000);
+	if (!ltdmabuf) {
+		printk(KERN_ERR "ltpc: mem alloc failed\n");
+		err = -ENOMEM;
+		goto out2;
+	}
+
+	ltdmacbuf = &ltdmabuf[800];
+
+	if(debug & DEBUG_VERBOSE) {
+		printk("ltdmabuf pointer %08lx\n",(unsigned long) ltdmabuf);
+	}
+
+	/* reset the card */
+
+	inb_p(io+1);
+	inb_p(io+3);
+
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(2*HZ/100);
+
+	inb_p(io+0);
+	inb_p(io+2);
+	inb_p(io+7); /* clear reset */
+	inb_p(io+4); 
+	inb_p(io+5);
+	inb_p(io+5); /* enable dma */
+	inb_p(io+6); /* tri-state interrupt line */
+
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(HZ);
+	
+	/* now, figure out which dma channel we're using, unless it's
+	   already been specified */
+	/* well, 0 is a legal DMA channel, but the LTPC card doesn't
+	   use it... */
+	dma = ltpc_probe_dma(io, dma);
+	if (!dma) {  /* no dma channel */
+		printk(KERN_ERR "No DMA channel found on ltpc card.\n");
+		err = -ENODEV;
+		goto out3;
+	}
+
+	/* print out friendly message */
+	if(irq)
+		printk(KERN_INFO "Apple/Farallon LocalTalk-PC card at %03x, IR%d, DMA%d.\n",io,irq,dma);
+	else
+		printk(KERN_INFO "Apple/Farallon LocalTalk-PC card at %03x, DMA%d.  Using polled mode.\n",io,dma);
+
+	/* Fill in the fields of the device structure with ethernet-generic values. */
+	dev->hard_start_xmit = ltpc_xmit;
+	dev->hard_header = ltpc_hard_header;
+	dev->get_stats = ltpc_get_stats;
+
+	/* add the ltpc-specific things */
+	dev->do_ioctl = &ltpc_ioctl;
+
+	dev->set_multicast_list = &set_multicast_list;
+	dev->mc_list = NULL;
+	dev->base_addr = io;
+	dev->irq = irq;
+	dev->dma = dma;
+
+	/* the card will want to send a result at this point */
+	/* (I think... leaving out this part makes the kernel crash,
+           so I put it back in...) */
+
+	f=claim_dma_lock();
+	disable_dma(dma);
+	clear_dma_ff(dma);
+	set_dma_mode(dma,DMA_MODE_READ);
+	set_dma_addr(dma,virt_to_bus(ltdmabuf));
+	set_dma_count(dma,0x100);
+	enable_dma(dma);
+	release_dma_lock(f);
+
+	(void) inb_p(io+3);
+	(void) inb_p(io+2);
+	timeout = jiffies+100*HZ/100;
+
+	while(time_before(jiffies, timeout)) {
+		if( 0xf9 == inb_p(io+6))
+			break;
+		schedule();
+	}
+
+	if(debug & DEBUG_VERBOSE) {
+		printk("setting up timer and irq\n");
+	}
+
+	/* grab it and don't let go :-) */
+	if (irq && request_irq( irq, &ltpc_interrupt, 0, "ltpc", dev) >= 0)
+	{
+		(void) inb_p(io+7);  /* enable interrupts from board */
+		(void) inb_p(io+7);  /* and reset irq line */
+	} else {
+		if( irq )
+			printk(KERN_ERR "ltpc: IRQ already in use, using polled mode.\n");
+		dev->irq = 0;
+		/* polled mode -- 20 times per second */
+		/* this is really, really slow... should it poll more often? */
+		init_timer(&ltpc_timer);
+		ltpc_timer.function=ltpc_poll;
+		ltpc_timer.data = (unsigned long) dev;
+
+		ltpc_timer.expires = jiffies + HZ/20;
+		add_timer(&ltpc_timer);
+	}
+	err = register_netdev(dev);
+	if (err)
+		goto out4;
+
+	return NULL;
+out4:
+	del_timer_sync(&ltpc_timer);
+	if (dev->irq)
+		free_irq(dev->irq, dev);
+out3:
+	free_pages((unsigned long)ltdmabuf, get_order(1000));
+out2:
+	release_region(io, 8);
+out1:
+	free_netdev(dev);
+out:
+	return ERR_PTR(err);
+}
+
+#ifndef MODULE
+/* handles "ltpc=io,irq,dma" kernel command lines */
+static int __init ltpc_setup(char *str)
+{
+	int ints[5];
+
+	str = get_options(str, ARRAY_SIZE(ints), ints);
+
+	if (ints[0] == 0) {
+		if (str && !strncmp(str, "auto", 4)) {
+			/* do nothing :-) */
+		}
+		else {
+			/* usage message */
+			printk (KERN_ERR
+				"ltpc: usage: ltpc=auto|iobase[,irq[,dma]]\n");
+			return 0;
+		}
+	} else {
+		io = ints[1];
+		if (ints[0] > 1) {
+			irq = ints[2];
+		}
+		if (ints[0] > 2) {
+			dma = ints[3];
+		}
+		/* ignore any other paramters */
+	}
+	return 1;
+}
+
+__setup("ltpc=", ltpc_setup);
+#endif /* MODULE */
+
+static struct net_device *dev_ltpc;
+
+#ifdef MODULE
+
+MODULE_LICENSE("GPL");
+module_param(debug, int, 0);
+module_param(io, int, 0);
+module_param(irq, int, 0);
+module_param(dma, int, 0);
+
+
+int __init init_module(void)
+{
+        if(io == 0)
+		printk(KERN_NOTICE
+		       "ltpc: Autoprobing is not recommended for modules\n");
+
+	dev_ltpc = ltpc_probe();
+	if (IS_ERR(dev_ltpc))
+		return PTR_ERR(dev_ltpc);
+	return 0;
+}
+#endif
+
+static void __exit ltpc_cleanup(void)
+{
+
+	if(debug & DEBUG_VERBOSE) printk("unregister_netdev\n");
+	unregister_netdev(dev_ltpc);
+
+	ltpc_timer.data = 0;  /* signal the poll routine that we're done */
+
+	del_timer_sync(&ltpc_timer);
+
+	if(debug & DEBUG_VERBOSE) printk("freeing irq\n");
+
+	if (dev_ltpc->irq)
+		free_irq(dev_ltpc->irq, dev_ltpc);
+
+	if(debug & DEBUG_VERBOSE) printk("freeing dma\n");
+
+	if (dev_ltpc->dma)
+		free_dma(dev_ltpc->dma);
+
+	if(debug & DEBUG_VERBOSE) printk("freeing ioaddr\n");
+
+	if (dev_ltpc->base_addr)
+		release_region(dev_ltpc->base_addr,8);
+
+	free_netdev(dev_ltpc);
+
+	if(debug & DEBUG_VERBOSE) printk("free_pages\n");
+
+	free_pages( (unsigned long) ltdmabuf, get_order(1000));
+
+	if(debug & DEBUG_VERBOSE) printk("returning from cleanup_module\n");
+}
+
+module_exit(ltpc_cleanup);
