commit 53bd63afbd659017d20dfb7ac3a53ceb8cbb338a
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Sat May 30 13:29:52 2020 +0300

    net: dsa: sja1105: suppress -Wmissing-prototypes in sja1105_static_config.c
    
    Newer compilers complain with W=1 builds that there are non-static
    functions defined in sja1105_static_config.c that don't have a
    prototype, because their prototype is defined in sja1105.h which this
    translation unit does not include.
    
    I don't entirely understand what is the point of these warnings, since
    in principle there's nothing wrong with that. But let's move the
    prototypes to a header file that _is_ included by
    sja1105_static_config.c, since that will make these warnings go away.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index cb3c81a49fbc..29ed21687295 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -323,24 +323,6 @@ int sja1105pqrs_fdb_add(struct dsa_switch *ds, int port,
 int sja1105pqrs_fdb_del(struct dsa_switch *ds, int port,
 			const unsigned char *addr, u16 vid);
 
-/* Common implementations for the static and dynamic configs */
-size_t sja1105_l2_forwarding_entry_packing(void *buf, void *entry_ptr,
-					   enum packing_op op);
-size_t sja1105pqrs_l2_lookup_entry_packing(void *buf, void *entry_ptr,
-					   enum packing_op op);
-size_t sja1105et_l2_lookup_entry_packing(void *buf, void *entry_ptr,
-					 enum packing_op op);
-size_t sja1105_vlan_lookup_entry_packing(void *buf, void *entry_ptr,
-					 enum packing_op op);
-size_t sja1105_retagging_entry_packing(void *buf, void *entry_ptr,
-				       enum packing_op op);
-size_t sja1105pqrs_mac_config_entry_packing(void *buf, void *entry_ptr,
-					    enum packing_op op);
-size_t sja1105pqrs_avb_params_entry_packing(void *buf, void *entry_ptr,
-					    enum packing_op op);
-size_t sja1105_vl_lookup_entry_packing(void *buf, void *entry_ptr,
-				       enum packing_op op);
-
 /* From sja1105_flower.c */
 int sja1105_cls_flower_del(struct dsa_switch *ds, int port,
 			   struct flow_cls_offload *cls, bool ingress);

commit 4d7525085a9ba86b9d78561d379b2ff8c0b30468
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Thu May 28 03:27:58 2020 +0300

    net: dsa: sja1105: offload the Credit-Based Shaper qdisc
    
    SJA1105, being AVB/TSN switches, provide hardware assist for the
    Credit-Based Shaper as described in the IEEE 8021Q-2018 document.
    
    First generation has 10 shapers, freely assignable to any of the 4
    external ports and 8 traffic classes, and second generation has 16
    shapers.
    
    The Credit-Based Shaper tables are accessed through the dynamic
    reconfiguration interface, so we have to restore them manually after a
    switch reset. The tables are backed up by the static config only on
    P/Q/R/S, and we don't want to add custom code only for that family,
    since the procedure that is in place now works for both.
    
    Tested with the following commands:
    
    data_rate_kbps=67000
    port_transmit_rate_kbps=1000000
    idleslope=$data_rate_kbps
    sendslope=$(($idleslope - $port_transmit_rate_kbps))
    locredit=$((-0x80000000))
    hicredit=$((0x7fffffff))
    tc qdisc add dev swp2 root handle 1: mqprio hw 0 num_tc 8 \
            map 0 1 2 3 4 5 6 7 \
            queues 1@0 1@1 1@2 1@3 1@4 1@5 1@6 1@7
    tc qdisc replace dev swp2 parent 1:1 cbs \
            idleslope $idleslope \
            sendslope $sendslope \
            hicredit $hicredit \
            locredit $locredit \
            offload 1
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 198d2a7d7f95..cb3c81a49fbc 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -84,6 +84,7 @@ struct sja1105_info {
 	 * the egress timestamps.
 	 */
 	int ptpegr_ts_bytes;
+	int num_cbs_shapers;
 	const struct sja1105_dynamic_table_ops *dyn_ops;
 	const struct sja1105_table_ops *static_ops;
 	const struct sja1105_regs *regs;
@@ -218,6 +219,7 @@ struct sja1105_private {
 	struct mutex mgmt_lock;
 	bool expect_dsa_8021q;
 	enum sja1105_vlan_state vlan_state;
+	struct sja1105_cbs_entry *cbs;
 	struct sja1105_tagger_data tagger_data;
 	struct sja1105_ptp_data ptp_data;
 	struct sja1105_tas_data tas_data;

commit aaa270c638caa337ce34bb590b0a14ee09f1876d
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue May 12 20:20:37 2020 +0300

    net: dsa: sja1105: implement a common frame memory partitioning function
    
    There are 2 different features that require some reserved frame memory
    space: VLAN retagging and virtual links. Create a central function that
    modifies the static config and ensures frame memory is never
    overcommitted.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 1ecdfd6be4c2..198d2a7d7f95 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -244,6 +244,8 @@ enum sja1105_reset_reason {
 int sja1105_static_config_reload(struct sja1105_private *priv,
 				 enum sja1105_reset_reason reason);
 
+void sja1105_frame_memory_partitioning(struct sja1105_private *priv);
+
 /* From sja1105_spi.c */
 int sja1105_xfer_buf(const struct sja1105_private *priv,
 		     sja1105_spi_rw_mode_t rw, u64 reg_addr,

commit 88cac0fa534d22ee333c415099ba000d3882fbba
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue May 12 20:20:36 2020 +0300

    net: dsa: sja1105: add packing ops for the Retagging Table
    
    The Retagging Table is an optional feature that allows the switch to
    match frames against a {ingress port, egress port, vid} rule and change
    their VLAN ID. The retagged frames are by default clones of the original
    ones (since the hardware-foreseen use case was to mirror traffic for
    debugging purposes and to tag it with a special VLAN for this purpose),
    but we can force the original frames to be dropped by removing the
    pre-retagging VLAN from the port membership list of the egress port.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 1dcaecab0912..1ecdfd6be4c2 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -328,6 +328,8 @@ size_t sja1105et_l2_lookup_entry_packing(void *buf, void *entry_ptr,
 					 enum packing_op op);
 size_t sja1105_vlan_lookup_entry_packing(void *buf, void *entry_ptr,
 					 enum packing_op op);
+size_t sja1105_retagging_entry_packing(void *buf, void *entry_ptr,
+				       enum packing_op op);
 size_t sja1105pqrs_mac_config_entry_packing(void *buf, void *entry_ptr,
 					    enum packing_op op);
 size_t sja1105pqrs_avb_params_entry_packing(void *buf, void *entry_ptr,

commit 2cafa72e516f61b6d82c2416b4f5963fb48fd9ce
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue May 12 20:20:35 2020 +0300

    net: dsa: sja1105: add a new best_effort_vlan_filtering devlink parameter
    
    This devlink parameter enables the handling of DSA tags when enslaved to
    a bridge with vlan_filtering=1. There are very good reasons to want
    this, but there are also very good reasons for not enabling it by
    default. So a devlink param named best_effort_vlan_filtering, currently
    driver-specific and exported only by sja1105, is used to configure this.
    
    In practice, this is perhaps the way that most users are going to use
    the switch in. It assumes that no more than 7 VLANs are needed per port.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index a019ffae38f1..1dcaecab0912 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -194,6 +194,7 @@ struct sja1105_bridge_vlan {
 
 enum sja1105_vlan_state {
 	SJA1105_VLAN_UNAWARE,
+	SJA1105_VLAN_BEST_EFFORT,
 	SJA1105_VLAN_FILTERING_FULL,
 };
 
@@ -201,6 +202,7 @@ struct sja1105_private {
 	struct sja1105_static_config static_config;
 	bool rgmii_rx_delay[SJA1105_NUM_PORTS];
 	bool rgmii_tx_delay[SJA1105_NUM_PORTS];
+	bool best_effort_vlan_filtering;
 	const struct sja1105_info *info;
 	struct gpio_desc *reset_gpio;
 	struct spi_device *spidev;

commit 38b5beeae7a4cde87edabb0196fac1f55ae668ee
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue May 12 20:20:32 2020 +0300

    net: dsa: sja1105: prepare tagger for handling DSA tags and VLAN simultaneously
    
    In VLAN-unaware mode, sja1105 uses VLAN tags with a custom TPID of
    0xdadb. While in the yet-to-be introduced best_effort_vlan_filtering
    mode, it needs to work with normal VLAN TPID values.
    
    A complication arises when we must transmit a VLAN-tagged packet to the
    switch when it's in VLAN-aware mode. We need to construct a packet with
    2 VLAN tags, and the switch will use the outer header for routing and
    pop it on egress. But sadly, here the 2 hardware generations don't
    behave the same:
    
    - E/T switches won't pop an ETH_P_8021AD tag on egress, it seems
      (packets will remain double-tagged).
    - P/Q/R/S switches will drop a packet with 2 ETH_P_8021Q tags (it looks
      like it tries to prevent VLAN hopping).
    
    But looks like the reverse is also true:
    
    - E/T switches have no problem popping the outer tag from packets with
      2 ETH_P_8021Q tags.
    - P/Q/R/S will have no problem popping a single tag even if that is
      ETH_P_8021AD.
    
    So it is clear that if we want the hardware to work with dsa_8021q
    tagging in VLAN-aware mode, we need to send different TPIDs depending on
    revision. Keep that information in priv->info->qinq_tpid.
    
    The per-port tagger structure will hold an xmit_tpid value that depends
    not only upon the qinq_tpid, but also upon the VLAN awareness state
    itself (in case we must transmit using 0xdadb).
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index c80f1999c694..a019ffae38f1 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -87,6 +87,12 @@ struct sja1105_info {
 	const struct sja1105_dynamic_table_ops *dyn_ops;
 	const struct sja1105_table_ops *static_ops;
 	const struct sja1105_regs *regs;
+	/* Both E/T and P/Q/R/S have quirks when it comes to popping the S-Tag
+	 * from double-tagged frames. E/T will pop it only when it's equal to
+	 * TPID from the General Parameters Table, while P/Q/R/S will only
+	 * pop it when it's equal to TPID2.
+	 */
+	u16 qinq_tpid;
 	int (*reset_cmd)(struct dsa_switch *ds);
 	int (*setup_rgmii_delay)(const void *ctx, int port);
 	/* Prototypes from include/net/dsa.h */

commit ec5ae61076d07be986df19773662506220757c9f
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue May 12 20:20:29 2020 +0300

    net: dsa: sja1105: save/restore VLANs using a delta commit method
    
    Managing the VLAN table that is present in hardware will become very
    difficult once we add a third operating state
    (best_effort_vlan_filtering). That is because correct cleanup (not too
    little, not too much) becomes virtually impossible, when VLANs can be
    added from the bridge layer, from dsa_8021q for basic tagging, for
    cross-chip bridging, as well as retagging rules for sub-VLANs and
    cross-chip sub-VLANs. So we need to rethink VLAN interaction with the
    switch in a more scalable way.
    
    In preparation for that, use the priv->expect_dsa_8021q boolean to
    classify any VLAN request received through .port_vlan_add or
    .port_vlan_del towards either one of 2 internal lists: bridge VLANs and
    dsa_8021q VLANs.
    
    Then, implement a central sja1105_build_vlan_table method that creates a
    VLAN configuration from scratch based on the 2 lists of VLANs kept by
    the driver, and based on the VLAN awareness state. Currently, if we are
    VLAN-unaware, install the dsa_8021q VLANs, otherwise the bridge VLANs.
    
    Then, implement a delta commit procedure that identifies which VLANs
    from this new configuration are actually different from the config
    previously committed to hardware. We apply the delta through the dynamic
    configuration interface (we don't reset the switch). The result is that
    the hardware should see the exact sequence of operations as before this
    patch.
    
    This also helps remove the "br" argument passed to
    dsa_8021q_crosschip_bridge_join, which it was only using to figure out
    whether it should commit the configuration back to us or not, based on
    the VLAN awareness state of the bridge. We can simplify that, by always
    allowing those VLANs inside of our dsa_8021q_vlans list, and committing
    those to hardware when necessary.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 667056d0c819..c80f1999c694 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -178,6 +178,14 @@ struct sja1105_flow_block {
 	int num_virtual_links;
 };
 
+struct sja1105_bridge_vlan {
+	struct list_head list;
+	int port;
+	u16 vid;
+	bool pvid;
+	bool untagged;
+};
+
 enum sja1105_vlan_state {
 	SJA1105_VLAN_UNAWARE,
 	SJA1105_VLAN_FILTERING_FULL,
@@ -191,6 +199,8 @@ struct sja1105_private {
 	struct gpio_desc *reset_gpio;
 	struct spi_device *spidev;
 	struct dsa_switch *ds;
+	struct list_head dsa_8021q_vlans;
+	struct list_head bridge_vlans;
 	struct list_head crosschip_links;
 	struct sja1105_flow_block flow_block;
 	struct sja1105_port ports[SJA1105_NUM_PORTS];

commit 60b33aeb7e0e664865ace822c0a7aeeb5ebe521c
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue May 12 20:20:28 2020 +0300

    net: dsa: sja1105: deny alterations of dsa_8021q VLANs from the bridge
    
    At the moment, this can never happen. The 2 modes that we operate in do
    not permit that:
    
     - SJA1105_VLAN_UNAWARE: we are guarded from bridge VLANs added by the
       user by the DSA core. We will later lift this restriction by setting
       ds->vlan_bridge_vtu = true, and that is where we'll need it.
    
     - SJA1105_VLAN_FILTERING_FULL: in this mode, dsa_8021q configuration is
       disabled. So the user is free to add these VLANs in the 1024-3071
       range.
    
    The reason for the patch is that we'll introduce a third VLAN awareness
    state, where both dsa_8021q as well as the bridge are going to call our
    .port_vlan_add and .port_vlan_del methods.
    
    For that, we need a good way to discriminate between the 2. The easiest
    (and less intrusive way for upper layers) is to recognize the fact that
    dsa_8021q configurations are always driven by our driver - we _know_
    when a .port_vlan_add method will be called from dsa_8021q because _we_
    initiated it.
    
    So introduce an expect_dsa_8021q boolean which is only used, at the
    moment, for blacklisting VLANs in range 1024-3071 in the modes when
    dsa_8021q is active.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 5b2b275d01a7..667056d0c819 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -198,6 +198,7 @@ struct sja1105_private {
 	 * the switch doesn't confuse them with one another.
 	 */
 	struct mutex mgmt_lock;
+	bool expect_dsa_8021q;
 	enum sja1105_vlan_state vlan_state;
 	struct sja1105_tagger_data tagger_data;
 	struct sja1105_ptp_data ptp_data;

commit 7f14937facdca1e0da1bacfacd089bcf4271e75a
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue May 12 20:20:27 2020 +0300

    net: dsa: sja1105: keep the VLAN awareness state in a driver variable
    
    Soon we'll add a third operating mode to the driver. Introduce a
    vlan_state to make things more easy to manage, and use it where
    applicable.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index a64ace07b89f..5b2b275d01a7 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -178,6 +178,11 @@ struct sja1105_flow_block {
 	int num_virtual_links;
 };
 
+enum sja1105_vlan_state {
+	SJA1105_VLAN_UNAWARE,
+	SJA1105_VLAN_FILTERING_FULL,
+};
+
 struct sja1105_private {
 	struct sja1105_static_config static_config;
 	bool rgmii_rx_delay[SJA1105_NUM_PORTS];
@@ -193,6 +198,7 @@ struct sja1105_private {
 	 * the switch doesn't confuse them with one another.
 	 */
 	struct mutex mgmt_lock;
+	enum sja1105_vlan_state vlan_state;
 	struct sja1105_tagger_data tagger_data;
 	struct sja1105_ptp_data ptp_data;
 	struct sja1105_tas_data tas_data;

commit ac02a451a6148bb9c395b39783ce7299eddf4f31
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Sun May 10 19:37:43 2020 +0300

    net: dsa: sja1105: implement cross-chip bridging operations
    
    sja1105 uses dsa_8021q for DSA tagging, a format which is VLAN at heart
    and which is compatible with cascading. A complete description of this
    tagging format is in net/dsa/tag_8021q.c, but a quick summary is that
    each external-facing port tags incoming frames with a unique pvid, and
    this special VLAN is transmitted as tagged towards the inside of the
    system, and as untagged towards the exterior. The tag encodes the switch
    id and the source port index.
    
    This means that cross-chip bridging for dsa_8021q only entails adding
    the dsa_8021q pvids of one switch to the RX filter of the other
    switches. Everything else falls naturally into place, as long as the
    bottom-end of ports (the leaves in the tree) is comprised exclusively of
    dsa_8021q-compatible (i.e. sja1105 switches). Otherwise, there would be
    a chance that a front-panel switch transmits a packet tagged with a
    dsa_8021q header, header which it wouldn't be able to remove, and which
    would hence "leak" out.
    
    The only use case I tested (due to lack of board availability) was when
    the sja1105 switches are part of disjoint trees (however, this doesn't
    change the fact that multiple sja1105 switches still need unique switch
    identifiers in such a system). But in principle, even "true" single-tree
    setups (with DSA links) should work just as fine, except for a small
    change which I can't test: dsa_towards_port should be used instead of
    dsa_upstream_port (I made the assumption that the routing port that any
    sja1105 should use towards its neighbours is the CPU port. That might
    not hold true in other setups).
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 8df2a5c53b02..a64ace07b89f 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -8,6 +8,7 @@
 #include <linux/ptp_clock_kernel.h>
 #include <linux/timecounter.h>
 #include <linux/dsa/sja1105.h>
+#include <linux/dsa/8021q.h>
 #include <net/dsa.h>
 #include <linux/mutex.h>
 #include "sja1105_static_config.h"
@@ -185,6 +186,7 @@ struct sja1105_private {
 	struct gpio_desc *reset_gpio;
 	struct spi_device *spidev;
 	struct dsa_switch *ds;
+	struct list_head crosschip_links;
 	struct sja1105_flow_block flow_block;
 	struct sja1105_port ports[SJA1105_NUM_PORTS];
 	/* Serializes transmission of management frames so that

commit 834f8933d5ddd732274cb6050252bd1c7cc7349d
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue May 5 22:20:56 2020 +0300

    net: dsa: sja1105: implement tc-gate using time-triggered virtual links
    
    Restrict the TTEthernet hardware support on this switch to operate as
    closely as possible to IEEE 802.1Qci as possible. This means that it can
    perform PTP-time-based ingress admission control on streams identified
    by {DMAC, VID, PCP}, which is useful when trying to ensure the
    determinism of traffic scheduled via IEEE 802.1Qbv.
    
    The oddity comes from the fact that in hardware (and in TTEthernet at
    large), virtual links always need a full-blown action, including not
    only the type of policing, but also the list of destination ports. So in
    practice, a single tc-gate action will result in all packets getting
    dropped. Additional actions (either "trap" or "redirect") need to be
    specified in the same filter rule such that the conforming packets are
    actually forwarded somewhere.
    
    Apart from the VL Lookup, Policing and Forwarding tables which need to
    be programmed for each flow (virtual link), the Schedule engine also
    needs to be told to open/close the admission gates for each individual
    virtual link. A fairly accurate (and detailed) description of how that
    works is already present in sja1105_tas.c, since it is already used to
    trigger the egress gates for the tc-taprio offload (IEEE 802.1Qbv). Key
    point here, we remember that the schedule engine supports 8
    "subschedules" (execution threads that iterate through the global
    schedule in parallel, and that no 2 hardware threads must execute a
    schedule entry at the same time). For tc-taprio, each egress port used
    one of these 8 subschedules, leaving a total of 4 subschedules unused.
    In principle we could have allocated 1 subschedule for the tc-gate
    offload of each ingress port, but actually the schedules of all virtual
    links installed on each ingress port would have needed to be merged
    together, before they could have been programmed to hardware. So
    simplify our life and just merge the entire tc-gate configuration, for
    all virtual links on all ingress ports, into a single subschedule. Be
    sure to check that against the usual hardware scheduling conflicts, and
    program it to hardware alongside any tc-taprio subschedule that may be
    present.
    
    The following scenarios were tested:
    
    1. Quantitative testing:
    
       tc qdisc add dev swp2 clsact
       tc filter add dev swp2 ingress flower skip_sw \
               dst_mac 42:be:24:9b:76:20 \
               action gate index 1 base-time 0 \
               sched-entry OPEN 1200 -1 -1 \
               sched-entry CLOSE 1200 -1 -1 \
               action trap
    
       ping 192.168.1.2 -f
       PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.
       .............................
       --- 192.168.1.2 ping statistics ---
       948 packets transmitted, 467 received, 50.7384% packet loss, time 9671ms
    
    2. Qualitative testing (with a phase-aligned schedule - the clocks are
       synchronized by ptp4l, not shown here):
    
       Receiver (sja1105):
    
       tc qdisc add dev swp2 clsact
       now=$(phc_ctl /dev/ptp1 get | awk '/clock time is/ {print $5}') && \
               sec=$(echo $now | awk -F. '{print $1}') && \
               base_time="$(((sec + 2) * 1000000000))" && \
               echo "base time ${base_time}"
       tc filter add dev swp2 ingress flower skip_sw \
               dst_mac 42:be:24:9b:76:20 \
               action gate base-time ${base_time} \
               sched-entry OPEN  60000 -1 -1 \
               sched-entry CLOSE 40000 -1 -1 \
               action trap
    
       Sender (enetc):
       now=$(phc_ctl /dev/ptp0 get | awk '/clock time is/ {print $5}') && \
               sec=$(echo $now | awk -F. '{print $1}') && \
               base_time="$(((sec + 2) * 1000000000))" && \
               echo "base time ${base_time}"
       tc qdisc add dev eno0 parent root taprio \
               num_tc 8 \
               map 0 1 2 3 4 5 6 7 \
               queues 1@0 1@1 1@2 1@3 1@4 1@5 1@6 1@7 \
               base-time ${base_time} \
               sched-entry S 01  50000 \
               sched-entry S 00  50000 \
               flags 2
    
       ping -A 192.168.1.1
       PING 192.168.1.1 (192.168.1.1): 56 data bytes
       ...
       ^C
       --- 192.168.1.1 ping statistics ---
       1425 packets transmitted, 1424 packets received, 0% packet loss
       round-trip min/avg/max = 0.322/0.361/0.990 ms
    
       And just for comparison, with the tc-taprio schedule deleted:
    
       ping -A 192.168.1.1
       PING 192.168.1.1 (192.168.1.1): 56 data bytes
       ...
       ^C
       --- 192.168.1.1 ping statistics ---
       33 packets transmitted, 19 packets received, 42% packet loss
       round-trip min/avg/max = 0.336/0.464/0.597 ms
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 1756000f6936..8df2a5c53b02 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -36,6 +36,7 @@ struct sja1105_regs {
 	u64 status;
 	u64 port_control;
 	u64 rgu;
+	u64 vl_status;
 	u64 config;
 	u64 sgmii;
 	u64 rmii_pll1;
@@ -156,8 +157,16 @@ struct sja1105_rule {
 
 		/* SJA1105_RULE_VL */
 		struct {
-			unsigned long destports;
 			enum sja1105_vl_type type;
+			unsigned long destports;
+			int sharindx;
+			int maxlen;
+			int ipv;
+			u64 base_time;
+			u64 cycle_time;
+			int num_entries;
+			struct action_gate_entry *entries;
+			struct flow_stats stats;
 		} vl;
 	};
 };
@@ -304,6 +313,8 @@ int sja1105_cls_flower_del(struct dsa_switch *ds, int port,
 			   struct flow_cls_offload *cls, bool ingress);
 int sja1105_cls_flower_add(struct dsa_switch *ds, int port,
 			   struct flow_cls_offload *cls, bool ingress);
+int sja1105_cls_flower_stats(struct dsa_switch *ds, int port,
+			     struct flow_cls_offload *cls, bool ingress);
 void sja1105_flower_setup(struct dsa_switch *ds);
 void sja1105_flower_teardown(struct dsa_switch *ds);
 struct sja1105_rule *sja1105_rule_find(struct sja1105_private *priv,

commit dfacc5a23e227cabdff41b6202f510398e90d36b
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue May 5 22:20:55 2020 +0300

    net: dsa: sja1105: support flow-based redirection via virtual links
    
    Implement tc-flower offloads for redirect, trap and drop using
    non-critical virtual links.
    
    Commands which were tested to work are:
    
      # Send frames received on swp2 with a DA of 42:be:24:9b:76:20 to the
      # CPU and to swp3. This type of key (DA only) when the port's VLAN
      # awareness state is off.
      tc qdisc add dev swp2 clsact
      tc filter add dev swp2 ingress flower skip_sw dst_mac 42:be:24:9b:76:20 \
              action mirred egress redirect dev swp3 \
              action trap
    
      # Drop frames received on swp2 with a DA of 42:be:24:9b:76:20, a VID
      # of 100 and a PCP of 0.
      tc filter add dev swp2 ingress protocol 802.1Q flower skip_sw \
              dst_mac 42:be:24:9b:76:20 vlan_id 100 vlan_prio 0 action drop
    
    Under the hood, all rules match on DMAC, VID and PCP, but when VLAN
    filtering is disabled, those are set internally by the driver to the
    port-based defaults. Because we would be put in an awkward situation if
    the user were to change the VLAN filtering state while there are active
    rules (packets would no longer match on the specified keys), we simply
    deny changing vlan_filtering unless the list of flows offloaded via
    virtual links is empty. Then the user can re-add new rules.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 95633ad9bfb7..1756000f6936 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -126,6 +126,13 @@ struct sja1105_key {
 enum sja1105_rule_type {
 	SJA1105_RULE_BCAST_POLICER,
 	SJA1105_RULE_TC_POLICER,
+	SJA1105_RULE_VL,
+};
+
+enum sja1105_vl_type {
+	SJA1105_VL_NONCRITICAL,
+	SJA1105_VL_RATE_CONSTRAINED,
+	SJA1105_VL_TIME_TRIGGERED,
 };
 
 struct sja1105_rule {
@@ -135,6 +142,7 @@ struct sja1105_rule {
 	struct sja1105_key key;
 	enum sja1105_rule_type type;
 
+	/* Action */
 	union {
 		/* SJA1105_RULE_BCAST_POLICER */
 		struct {
@@ -145,12 +153,19 @@ struct sja1105_rule {
 		struct {
 			int sharindx;
 		} tc_pol;
+
+		/* SJA1105_RULE_VL */
+		struct {
+			unsigned long destports;
+			enum sja1105_vl_type type;
+		} vl;
 	};
 };
 
 struct sja1105_flow_block {
 	struct list_head rules;
 	bool l2_policer_used[SJA1105_NUM_L2_POLICERS];
+	int num_virtual_links;
 };
 
 struct sja1105_private {
@@ -187,6 +202,7 @@ enum sja1105_reset_reason {
 	SJA1105_AGEING_TIME,
 	SJA1105_SCHEDULING,
 	SJA1105_BEST_EFFORT_POLICING,
+	SJA1105_VIRTUAL_LINKS,
 };
 
 int sja1105_static_config_reload(struct sja1105_private *priv,
@@ -290,5 +306,7 @@ int sja1105_cls_flower_add(struct dsa_switch *ds, int port,
 			   struct flow_cls_offload *cls, bool ingress);
 void sja1105_flower_setup(struct dsa_switch *ds);
 void sja1105_flower_teardown(struct dsa_switch *ds);
+struct sja1105_rule *sja1105_rule_find(struct sja1105_private *priv,
+				       unsigned long cookie);
 
 #endif

commit b70bb8d4ab2c0a4992e4692f07e9b91056b30c88
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue May 5 22:20:54 2020 +0300

    net: dsa: sja1105: make room for virtual link parsing in flower offload
    
    Virtual links are a sja1105 hardware concept of executing various flow
    actions based on a key extracted from the frame's DMAC, VID and PCP.
    
    Currently the tc-flower offload code supports only parsing the DMAC if
    that is the broadcast MAC address, and the VLAN PCP. Extract the key
    parsing logic from the L2 policers functionality and move it into its
    own function, after adding extra logic for matching on any DMAC and VID.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 602aa30c832f..95633ad9bfb7 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -97,6 +97,32 @@ struct sja1105_info {
 	const char *name;
 };
 
+enum sja1105_key_type {
+	SJA1105_KEY_BCAST,
+	SJA1105_KEY_TC,
+	SJA1105_KEY_VLAN_UNAWARE_VL,
+	SJA1105_KEY_VLAN_AWARE_VL,
+};
+
+struct sja1105_key {
+	enum sja1105_key_type type;
+
+	union {
+		/* SJA1105_KEY_TC */
+		struct {
+			int pcp;
+		} tc;
+
+		/* SJA1105_KEY_VLAN_UNAWARE_VL */
+		/* SJA1105_KEY_VLAN_AWARE_VL */
+		struct {
+			u64 dmac;
+			u16 vid;
+			u16 pcp;
+		} vl;
+	};
+};
+
 enum sja1105_rule_type {
 	SJA1105_RULE_BCAST_POLICER,
 	SJA1105_RULE_TC_POLICER,
@@ -106,6 +132,7 @@ struct sja1105_rule {
 	struct list_head list;
 	unsigned long cookie;
 	unsigned long port_mask;
+	struct sja1105_key key;
 	enum sja1105_rule_type type;
 
 	union {
@@ -117,7 +144,6 @@ struct sja1105_rule {
 		/* SJA1105_RULE_TC_POLICER */
 		struct {
 			int sharindx;
-			int tc;
 		} tc_pol;
 	};
 };

commit 94f94d4acfb2a5e978f98d924be33c981e2f86c6
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue May 5 22:20:53 2020 +0300

    net: dsa: sja1105: add static tables for virtual links
    
    This patch adds the register definitions for the:
    - VL Lookup Table
    - VL Policing Table
    - VL Forwarding Table
    - VL Forwarding Parameters Table
    
    These are needed in order to perform TTEthernet operations: QoS
    classification, flow-based policing and/or frame redirecting with the
    switch.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 2f62942692ec..602aa30c832f 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -254,6 +254,8 @@ size_t sja1105pqrs_mac_config_entry_packing(void *buf, void *entry_ptr,
 					    enum packing_op op);
 size_t sja1105pqrs_avb_params_entry_packing(void *buf, void *entry_ptr,
 					    enum packing_op op);
+size_t sja1105_vl_lookup_entry_packing(void *buf, void *entry_ptr,
+				       enum packing_op op);
 
 /* From sja1105_flower.c */
 int sja1105_cls_flower_del(struct dsa_switch *ds, int port,

commit 135e30180ff4f654794960aba04785fe7eef2e90
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Fri Apr 17 22:50:52 2020 +0300

    net: dsa: sja1105: enable internal pull-down for RX_DV/CRS_DV/RX_CTL and RX_ER
    
    Some boards do not have the RX_ER MII signal connected. Normally in such
    situation, those pins would be grounded, but then again, some boards
    left it electrically floating.
    
    When sending traffic to those switch ports, one can see that the
    N_SOFERR statistics counter is incrementing once per each packet. The
    user manual states for this counter that it may count the number of
    frames "that have the MII error input being asserted prior to or
    up to the SOF delimiter byte". So the switch MAC is sampling an
    electrically floating signal, and preventing proper traffic reception
    because of that.
    
    As a workaround, enable the internal weak pull-downs on the input pads
    for the MII control signals. This way, a floating signal would be
    internally tied to ground.
    
    The logic levels of signals which _are_ externally driven should not be
    bothered by this 40-50 KOhm internal resistor. So it is not an issue to
    enable the internal pull-down unconditionally, irrespective of PHY
    interface type (MII, RMII, RGMII, SGMII) and of board layout.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 8b60dbd567f2..2f62942692ec 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -49,6 +49,7 @@ struct sja1105_regs {
 	u64 ptpschtm;
 	u64 ptpegr_ts[SJA1105_NUM_PORTS];
 	u64 pad_mii_tx[SJA1105_NUM_PORTS];
+	u64 pad_mii_rx[SJA1105_NUM_PORTS];
 	u64 pad_mii_id[SJA1105_NUM_PORTS];
 	u64 cgu_idiv[SJA1105_NUM_PORTS];
 	u64 mii_tx_clk[SJA1105_NUM_PORTS];

commit a6af77637adc92aa0725ac14f71ad915c6000609
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Sun Mar 29 14:52:02 2020 +0300

    net: dsa: sja1105: add broadcast and per-traffic class policers
    
    This patch adds complete support for manipulating the L2 Policing Tables
    from this switch. There are 45 table entries, one entry per each port
    and traffic class, and one dedicated entry for broadcast traffic for
    each ingress port.
    
    Policing entries are shareable, and we use this functionality to support
    shared block filters.
    
    We are modeling broadcast policers as simple tc-flower matches on
    dst_mac. As for the traffic class policers, the switch only deduces the
    traffic class from the VLAN PCP field, so it makes sense to model this
    as a tc-flower match on vlan_prio.
    
    How to limit broadcast traffic coming from all front-panel ports to a
    cumulated total of 10 Mbit/s:
    
    tc qdisc add dev sw0p0 ingress_block 1 clsact
    tc qdisc add dev sw0p1 ingress_block 1 clsact
    tc qdisc add dev sw0p2 ingress_block 1 clsact
    tc qdisc add dev sw0p3 ingress_block 1 clsact
    tc filter add block 1 flower skip_sw dst_mac ff:ff:ff:ff:ff:ff \
            action police rate 10mbit burst 64k
    
    How to limit traffic with VLAN PCP 0 (also includes untagged traffic) to
    100 Mbit/s on port 0 only:
    
    tc filter add dev sw0p0 ingress protocol 802.1Q flower skip_sw \
            vlan_prio 0 action police rate 100mbit burst 64k
    
    The broadcast, VLAN PCP and port policers are compatible with one
    another (can be installed at the same time on a port).
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index d97d4699104e..8b60dbd567f2 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -19,6 +19,7 @@
  * The passed parameter is in multiples of 1 ms.
  */
 #define SJA1105_AGEING_TIME_MS(ms)	((ms) / 10)
+#define SJA1105_NUM_L2_POLICERS		45
 
 typedef enum {
 	SPI_READ = 0,
@@ -95,6 +96,36 @@ struct sja1105_info {
 	const char *name;
 };
 
+enum sja1105_rule_type {
+	SJA1105_RULE_BCAST_POLICER,
+	SJA1105_RULE_TC_POLICER,
+};
+
+struct sja1105_rule {
+	struct list_head list;
+	unsigned long cookie;
+	unsigned long port_mask;
+	enum sja1105_rule_type type;
+
+	union {
+		/* SJA1105_RULE_BCAST_POLICER */
+		struct {
+			int sharindx;
+		} bcast_pol;
+
+		/* SJA1105_RULE_TC_POLICER */
+		struct {
+			int sharindx;
+			int tc;
+		} tc_pol;
+	};
+};
+
+struct sja1105_flow_block {
+	struct list_head rules;
+	bool l2_policer_used[SJA1105_NUM_L2_POLICERS];
+};
+
 struct sja1105_private {
 	struct sja1105_static_config static_config;
 	bool rgmii_rx_delay[SJA1105_NUM_PORTS];
@@ -103,6 +134,7 @@ struct sja1105_private {
 	struct gpio_desc *reset_gpio;
 	struct spi_device *spidev;
 	struct dsa_switch *ds;
+	struct sja1105_flow_block flow_block;
 	struct sja1105_port ports[SJA1105_NUM_PORTS];
 	/* Serializes transmission of management frames so that
 	 * the switch doesn't confuse them with one another.
@@ -222,4 +254,12 @@ size_t sja1105pqrs_mac_config_entry_packing(void *buf, void *entry_ptr,
 size_t sja1105pqrs_avb_params_entry_packing(void *buf, void *entry_ptr,
 					    enum packing_op op);
 
+/* From sja1105_flower.c */
+int sja1105_cls_flower_del(struct dsa_switch *ds, int port,
+			   struct flow_cls_offload *cls, bool ingress);
+int sja1105_cls_flower_add(struct dsa_switch *ds, int port,
+			   struct flow_cls_offload *cls, bool ingress);
+void sja1105_flower_setup(struct dsa_switch *ds);
+void sja1105_flower_teardown(struct dsa_switch *ds);
+
 #endif

commit 336aa67bd027f4771c3a7f3d8a3fd15d923f5df5
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Fri Mar 27 16:00:16 2020 +0200

    net: dsa: sja1105: show more ethtool statistics counters for P/Q/R/S
    
    It looks like the P/Q/R/S series supports some more counters,
    generically named "Ethernet statistics counter", which we were not
    printing. Add them.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 0e5b739b2fe8..d97d4699104e 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -60,6 +60,7 @@ struct sja1105_regs {
 	u64 mac[SJA1105_NUM_PORTS];
 	u64 mac_hl1[SJA1105_NUM_PORTS];
 	u64 mac_hl2[SJA1105_NUM_PORTS];
+	u64 ether_stats[SJA1105_NUM_PORTS];
 	u64 qlevel[SJA1105_NUM_PORTS];
 };
 

commit c279c7261a834470a7b9f005993bf149ee594d85
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Fri Mar 27 21:55:45 2020 +0200

    net: dsa: sja1105: implement the port MTU callbacks
    
    On this switch, the frame length enforcements are performed by the
    ingress policers. There are 2 types of those: regular L2 (also called
    best-effort) and Virtual Link policers (an ARINC664/AFDX concept for
    defining L2 streams with certain QoS abilities). To avoid future
    confusion, I prefer to call the reset reason "Best-effort policers",
    even though the VL policers are not yet supported.
    
    We also need to change the setup of the initial static config, such that
    DSA calls to .change_mtu (which are expensive) become no-ops and don't
    reset the switch 5 times.
    
    A driver-level decision is to unconditionally allow single VLAN-tagged
    traffic on all ports. The CPU port must accept an additional VLAN header
    for the DSA tag, which is again a driver-level decision.
    
    The policers actually count bytes not only from the SDU, but also from
    the Ethernet header and FCS, so those need to be accounted for as well.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index a358fc89a6db..0e5b739b2fe8 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -126,6 +126,7 @@ enum sja1105_reset_reason {
 	SJA1105_RX_HWTSTAMPING,
 	SJA1105_AGEING_TIME,
 	SJA1105_SCHEDULING,
+	SJA1105_BEST_EFFORT_POLICING,
 };
 
 int sja1105_static_config_reload(struct sja1105_private *priv,

commit 747e5eb31d59d047972a0dab03e5430fe4264332
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue Mar 24 00:59:24 2020 +0200

    net: dsa: sja1105: configure the PTP_CLK pin as EXT_TS or PER_OUT
    
    The SJA1105 switch family has a PTP_CLK pin which emits a signal with
    fixed 50% duty cycle, but variable frequency and programmable start time.
    
    On the second generation (P/Q/R/S) switches, this pin supports even more
    functionality. The use case described by the hardware documents talks
    about synchronization via oneshot pulses: given 2 sja1105 switches,
    arbitrarily designated as a master and a slave, the master emits a
    single pulse on PTP_CLK, while the slave is configured to timestamp this
    pulse received on its PTP_CLK pin (which must obviously be configured as
    input). The difference between the timestamps then exactly becomes the
    slave offset to the master.
    
    The only trouble with the above is that the hardware is very much tied
    into this use case only, and not very generic beyond that:
     - When emitting a oneshot pulse, instead of being told when to emit it,
       the switch just does it "now" and tells you later what time it was,
       via the PTPSYNCTS register. [ Incidentally, this is the same register
       that the slave uses to collect the ext_ts timestamp from, too. ]
     - On the sync slave, there is no interrupt mechanism on reception of a
       new extts, and no FIFO to buffer them, because in the foreseen use
       case, software is in control of both the master and the slave pins,
       so it "knows" when there's something to collect.
    
    These 2 problems mean that:
     - We don't support (at least yet) the quirky oneshot mode exposed by
       the hardware, just normal periodic output.
     - We abuse the hardware a little bit when we expose generic extts.
       Because there's no interrupt mechanism, we need to poll at double the
       frequency we expect to receive a pulse. Currently that means a
       non-configurable "twice a second".
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Acked-by: Richard Cochran <richardcochran@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 5bc40175ee0d..a358fc89a6db 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -38,10 +38,13 @@ struct sja1105_regs {
 	u64 config;
 	u64 sgmii;
 	u64 rmii_pll1;
+	u64 ptppinst;
+	u64 ptppindur;
 	u64 ptp_control;
 	u64 ptpclkval;
 	u64 ptpclkrate;
 	u64 ptpclkcorp;
+	u64 ptpsyncts;
 	u64 ptpschtm;
 	u64 ptpegr_ts[SJA1105_NUM_PORTS];
 	u64 pad_mii_tx[SJA1105_NUM_PORTS];

commit 0a7e984c92d6ea61e0a1f0b1796fccddf486f9bf
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Tue Mar 24 00:59:23 2020 +0200

    net: dsa: sja1105: make the AVB table dynamically reconfigurable
    
    The AVB table contains the CAS_MASTER field (to be added in the next
    patch) which decides the direction of the PTP_CLK pin.
    
    Reconfiguring this field dynamically is highly preferable to having to
    reset the switch and upload a new static configuration, so we add
    support for exactly that.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 4c40f2d51a54..5bc40175ee0d 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -214,5 +214,7 @@ size_t sja1105_vlan_lookup_entry_packing(void *buf, void *entry_ptr,
 					 enum packing_op op);
 size_t sja1105pqrs_mac_config_entry_packing(void *buf, void *entry_ptr,
 					    enum packing_op op);
+size_t sja1105pqrs_avb_params_entry_packing(void *buf, void *entry_ptr,
+					    enum packing_op op);
 
 #endif

commit ffe10e679cec9a99f19049459cb27c2fbb1e913a
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Fri Mar 20 13:29:37 2020 +0200

    net: dsa: sja1105: Add support for the SGMII port
    
    SJA1105 switches R and S have one SerDes port with an 802.3z
    quasi-compatible PCS, hardwired on port 4. The other ports are still
    MII/RMII/RGMII. The PCS performs rate adaptation to lower link speeds;
    the MAC on this port is hardwired at gigabit. Only full duplex is
    supported.
    
    The SGMII port can be configured as part of the static config tables, as
    well as through a dedicated SPI address region for its pseudo-clause-22
    registers. However it looks like the static configuration is not
    able to change some out-of-reset values (like the value of MII_BMCR), so
    at the end of the day, having code for it is utterly pointless. We are
    just going to use the pseudo-C22 interface.
    
    Because the PCS gets reset when the switch resets, we have to add even
    more restoration logic to sja1105_static_config_reload, otherwise the
    SGMII port breaks after operations such as enabling PTP timestamping
    which require a switch reset.
    
    >From PHYLINK perspective, the switch supports *only* SGMII (it doesn't
    support 1000Base-X). It also doesn't expose access to the raw config
    word for in-band AN in registers MII_ADV/MII_LPA.
    It is able to work in the following modes:
     - Forced speed
     - SGMII in-band AN slave (speed received from PHY)
     - SGMII in-band AN master (acting as a PHY)
    
    The latter mode is not supported by this patch. It is even unclear to me
    how that would be described. There is some code for it left in the
    patch, but 'an_master' is always passed as false.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index d801fc204d19..4c40f2d51a54 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -36,6 +36,7 @@ struct sja1105_regs {
 	u64 port_control;
 	u64 rgu;
 	u64 config;
+	u64 sgmii;
 	u64 rmii_pll1;
 	u64 ptp_control;
 	u64 ptpclkval;
@@ -159,6 +160,7 @@ typedef enum {
 	XMII_MODE_MII		= 0,
 	XMII_MODE_RMII		= 1,
 	XMII_MODE_RGMII		= 2,
+	XMII_MODE_SGMII		= 3,
 } sja1105_phy_interface_t;
 
 typedef enum {

commit abfb228ae64268991653a6e73eb203c759764075
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Wed Nov 13 00:16:41 2019 +0200

    net: dsa: sja1105: Simplify reset handling
    
    We don't really need 10k species of reset. Remove everything except cold
    reset which is what is actually used. Too bad the hardware designers
    couldn't agree to use the same bit field for rev 1 and rev 2, so the
    (*reset_cmd) function pointer is there to stay.
    
    However let's simplify the prototype and give it a struct dsa_switch (we
    want to avoid forward-declarations of structures, in this case struct
    sja1105_private, wherever we can).
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 29c7ed60cfdc..d801fc204d19 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -78,7 +78,7 @@ struct sja1105_info {
 	const struct sja1105_dynamic_table_ops *dyn_ops;
 	const struct sja1105_table_ops *static_ops;
 	const struct sja1105_regs *regs;
-	int (*reset_cmd)(const void *ctx, const void *data);
+	int (*reset_cmd)(struct dsa_switch *ds);
 	int (*setup_rgmii_delay)(const void *ctx, int port);
 	/* Prototypes from include/net/dsa.h */
 	int (*fdb_add_cmd)(struct dsa_switch *ds, int port,

commit 86db36a347b4ea030ee3e6c73ce04e35e4732999
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Tue Nov 12 02:11:54 2019 +0200

    net: dsa: sja1105: Implement state machine for TAS with PTP clock source
    
    Tested using the following bash script and the tc from iproute2-next:
    
            #!/bin/bash
    
            set -e -u -o pipefail
    
            NSEC_PER_SEC="1000000000"
    
            gatemask() {
                    local tc_list="$1"
                    local mask=0
    
                    for tc in ${tc_list}; do
                            mask=$((${mask} | (1 << ${tc})))
                    done
    
                    printf "%02x" ${mask}
            }
    
            if ! systemctl is-active --quiet ptp4l; then
                    echo "Please start the ptp4l service"
                    exit
            fi
    
            now=$(phc_ctl /dev/ptp1 get | gawk '/clock time is/ { print $5; }')
            # Phase-align the base time to the start of the next second.
            sec=$(echo "${now}" | gawk -F. '{ print $1; }')
            base_time="$(((${sec} + 1) * ${NSEC_PER_SEC}))"
    
            tc qdisc add dev swp5 parent root handle 100 taprio \
                    num_tc 8 \
                    map 0 1 2 3 5 6 7 \
                    queues 1@0 1@1 1@2 1@3 1@4 1@5 1@6 1@7 \
                    base-time ${base_time} \
                    sched-entry S $(gatemask 7) 100000 \
                    sched-entry S $(gatemask "0 1 2 3 4 5 6") 400000 \
                    clockid CLOCK_TAI flags 2
    
    The "state machine" is a workqueue invoked after each manipulation
    command on the PTP clock (reset, adjust time, set time, adjust
    frequency) which checks over the state of the time-aware scheduler.
    So it is not monitored periodically, only in reaction to a PTP command
    typically triggered from a userspace daemon (linuxptp). Otherwise there
    is no reason for things to go wrong.
    
    Now that the timecounter/cyclecounter has been replaced with hardware
    operations on the PTP clock, the TAS Kconfig now depends upon PTP and
    the standalone clocksource operating mode has been removed.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 38340b74249e..29c7ed60cfdc 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -40,6 +40,8 @@ struct sja1105_regs {
 	u64 ptp_control;
 	u64 ptpclkval;
 	u64 ptpclkrate;
+	u64 ptpclkcorp;
+	u64 ptpschtm;
 	u64 ptpegr_ts[SJA1105_NUM_PORTS];
 	u64 pad_mii_tx[SJA1105_NUM_PORTS];
 	u64 pad_mii_id[SJA1105_NUM_PORTS];

commit 41603d78b3626cf0da8aa562ecc2a276033db76c
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Tue Nov 12 02:11:53 2019 +0200

    net: dsa: sja1105: Make the PTP command read-write
    
    The PTPSTRTSCH and PTPSTOPSCH bits are actually readable and indicate
    whether the time-aware scheduler is running or not. We will be using
    that for monitoring the scheduler in the next patch, so refactor the PTP
    command API in order to allow that.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 1a3722971b61..38340b74249e 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -20,6 +20,11 @@
  */
 #define SJA1105_AGEING_TIME_MS(ms)	((ms) / 10)
 
+typedef enum {
+	SPI_READ = 0,
+	SPI_WRITE = 1,
+} sja1105_spi_rw_mode_t;
+
 #include "sja1105_tas.h"
 #include "sja1105_ptp.h"
 
@@ -71,8 +76,6 @@ struct sja1105_info {
 	const struct sja1105_dynamic_table_ops *dyn_ops;
 	const struct sja1105_table_ops *static_ops;
 	const struct sja1105_regs *regs;
-	int (*ptp_cmd)(const struct dsa_switch *ds,
-		       const struct sja1105_ptp_cmd *cmd);
 	int (*reset_cmd)(const void *ctx, const void *data);
 	int (*setup_rgmii_delay)(const void *ctx, int port);
 	/* Prototypes from include/net/dsa.h */
@@ -80,6 +83,8 @@ struct sja1105_info {
 			   const unsigned char *addr, u16 vid);
 	int (*fdb_del_cmd)(struct dsa_switch *ds, int port,
 			   const unsigned char *addr, u16 vid);
+	void (*ptp_cmd_packing)(u8 *buf, struct sja1105_ptp_cmd *cmd,
+				enum packing_op op);
 	const char *name;
 };
 
@@ -109,11 +114,6 @@ struct sja1105_spi_message {
 	u64 address;
 };
 
-typedef enum {
-	SPI_READ = 0,
-	SPI_WRITE = 1,
-} sja1105_spi_rw_mode_t;
-
 /* From sja1105_main.c */
 enum sja1105_reset_reason {
 	SJA1105_VLAN_FILTERING = 0,

commit 2eea1fa82f681b484acb8e5a0d213b64a5c5574c
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Tue Nov 12 23:22:00 2019 +0200

    net: dsa: sja1105: Print the reset reason
    
    Sometimes it can be quite opaque even for me why the driver decided to
    reset the switch. So instead of adding dump_stack() calls each time for
    debugging, just add a reset reason to sja1105_static_config_reload
    calls which gets printed to the console.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 64b3ee7b9771..1a3722971b61 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -115,7 +115,15 @@ typedef enum {
 } sja1105_spi_rw_mode_t;
 
 /* From sja1105_main.c */
-int sja1105_static_config_reload(struct sja1105_private *priv);
+enum sja1105_reset_reason {
+	SJA1105_VLAN_FILTERING = 0,
+	SJA1105_RX_HWTSTAMPING,
+	SJA1105_AGEING_TIME,
+	SJA1105_SCHEDULING,
+};
+
+int sja1105_static_config_reload(struct sja1105_private *priv,
+				 enum sja1105_reset_reason reason);
 
 /* From sja1105_spi.c */
 int sja1105_xfer_buf(const struct sja1105_private *priv,

commit 34d76e9fa846a87e7924ab974e4cb70394a4fcac
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Nov 9 13:32:22 2019 +0200

    net: dsa: sja1105: Implement the .gettimex64 system call for PTP
    
    Through the PTP_SYS_OFFSET_EXTENDED ioctl, it is possible for userspace
    applications (i.e. phc2sys) to compensate for the delays incurred while
    reading the PHC's time.
    
    The task itself of taking the software timestamp is delegated to the SPI
    subsystem, through the newly introduced API in struct spi_transfer. The
    goal is to cross-timestamp I/O operations on the switch's PTP clock with
    values in the local system clock (CLOCK_REALTIME). For that we need to
    understand a bit of the hardware internals.
    
    The 'read PTP time' message is a 12 byte structure, first 4 bytes of
    which represent the SPI header, and the last 8 bytes represent the
    64-bit PTP time. The switch itself starts processing the command
    immediately after receiving the last bit of the address, i.e. at the
    middle of byte 3 (last byte of header). The PTP time is shadowed to a
    buffer register in the switch, and retrieved atomically during the
    subsequent SPI frames.
    
    A similar thing goes on for the 'write PTP time' message, although in
    that case the switch waits until the 64-bit PTP time becomes fully
    available before taking any action. So the byte that needs to be
    software-timestamped is byte 11 (last) of the transfer.
    
    The patch creates a common (and local) sja1105_xfer implementation for
    the SPI I/O, and offers 3 front-ends:
    
    - sja1105_xfer_u32 and sja1105_xfer_u64: these are capable of optionally
      requesting a PTP timestamp
    
    - sja1105_xfer_buf: this is for large transfers (e.g. the static config
      buffer) and other misc data, and there is no point in giving
      timestamping capabilities to this.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 91063ed3ef1b..64b3ee7b9771 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -122,9 +122,11 @@ int sja1105_xfer_buf(const struct sja1105_private *priv,
 		     sja1105_spi_rw_mode_t rw, u64 reg_addr,
 		     u8 *buf, size_t len);
 int sja1105_xfer_u32(const struct sja1105_private *priv,
-		     sja1105_spi_rw_mode_t rw, u64 reg_addr, u32 *value);
+		     sja1105_spi_rw_mode_t rw, u64 reg_addr, u32 *value,
+		     struct ptp_system_timestamp *ptp_sts);
 int sja1105_xfer_u64(const struct sja1105_private *priv,
-		     sja1105_spi_rw_mode_t rw, u64 reg_addr, u64 *value);
+		     sja1105_spi_rw_mode_t rw, u64 reg_addr, u64 *value,
+		     struct ptp_system_timestamp *ptp_sts);
 int sja1105_static_config_upload(struct sja1105_private *priv);
 int sja1105_inhibit_tx(const struct sja1105_private *priv,
 		       unsigned long port_bitmap, bool tx_inhibited);

commit 2f184393e0c2d409c62262f57f2a57efdf9370b8
Merge: ebcd670d05d5 531e93d11470
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Oct 19 22:51:25 2019 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net
    
    Several cases of overlapping changes which were for the most
    part trivially resolvable.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 2fb079a28ae856145e8977d08b77403a3a5d6a70
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Wed Oct 16 21:41:02 2019 +0300

    net: dsa: sja1105: Switch to hardware operations for PTP
    
    Adjusting the hardware clock (PTPCLKVAL, PTPCLKADD, PTPCLKRATE) is a
    requirement for the auxiliary PTP functionality of the switch
    (TTEthernet, PPS input, PPS output).
    
    Therefore we need to switch to using these registers to keep a
    synchronized time in hardware, instead of the timecounter/cyclecounter
    implementation, which is reliant on the free-running PTPTSCLK.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 0ef97a916707..397a49da35e4 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -33,9 +33,8 @@ struct sja1105_regs {
 	u64 config;
 	u64 rmii_pll1;
 	u64 ptp_control;
-	u64 ptpclk;
+	u64 ptpclkval;
 	u64 ptpclkrate;
-	u64 ptptsclk;
 	u64 ptpegr_ts[SJA1105_NUM_PORTS];
 	u64 pad_mii_tx[SJA1105_NUM_PORTS];
 	u64 pad_mii_id[SJA1105_NUM_PORTS];

commit b790b5549bdf498ab0ecc5632610a9149532fa38
Author: Nishad Kamdar <nishadkamdar@gmail.com>
Date:   Mon Oct 14 21:51:20 2019 +0530

    net: dsa: sja1105: Use the correct style for SPDX License Identifier
    
    This patch corrects the SPDX License Identifier style
    in header files related to Distributed Switch Architecture
    drivers for NXP SJA1105 series Ethernet switch support.
    It uses an expilict block comment for the SPDX License
    Identifier.
    
    Changes made by using a script provided by Joe Perches here:
    https://lkml.org/lkml/2019/2/7/46.
    
    Suggested-by: Joe Perches <joe@perches.com>
    Signed-off-by: Nishad Kamdar <nishadkamdar@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index e53e494c22e0..fbb564c3beb8 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -1,5 +1,5 @@
-/* SPDX-License-Identifier: GPL-2.0
- * Copyright (c) 2018, Sensor-Technik Wiedemann GmbH
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2018, Sensor-Technik Wiedemann GmbH
  * Copyright (c) 2018-2019, Vladimir Oltean <olteanv@gmail.com>
  */
 #ifndef _SJA1105_H

commit 08839c06e96f1a88e7c30011708727430fd78c3d
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Oct 12 01:31:15 2019 +0300

    net: dsa: sja1105: Switch to scatter/gather API for SPI
    
    This reworks the SPI transfer implementation to make use of more of the
    SPI core features. The main benefit is to avoid the memcpy in
    sja1105_xfer_buf().
    
    The memcpy was only needed because the function was transferring a
    single buffer at a time. So it needed to copy the caller-provided buffer
    at buf + 4, to store the SPI message header in the "headroom" area.
    
    But the SPI core supports scatter-gather messages, comprised of multiple
    transfers. We can actually use those to break apart every SPI message
    into 2 transfers: one for the header and one for the actual payload.
    
    To keep the behavior the same regarding the chip select signal, it is
    necessary to tell the SPI core to de-assert the chip select after each
    chunk. This was not needed before, because each spi_message contained
    only 1 single transfer.
    
    The meaning of the per-transfer cs_change=1 is:
    
    - If the transfer is the last one of the message, keep CS asserted
    - Otherwise, deassert CS
    
    We need to deassert CS in the "otherwise" case, which was implicit
    before.
    
    Avoiding the memcpy creates yet another opportunity. The device can't
    process more than 256 bytes of SPI payload at a time, so the
    sja1105_xfer_long_buf() function used to exist, to split the larger
    caller buffer into chunks.
    
    But these chunks couldn't be used as scatter/gather buffers for
    spi_message until now, because of that memcpy (we would have needed more
    memory for each chunk). So we can now remove the sja1105_xfer_long_buf()
    function and have a single implementation for long and short buffers.
    
    Another benefit is lower usage of stack memory. Previously we had to
    store 2 SPI buffers for each chunk. Due to the elimination of the
    memcpy, we can now send pointers to the actual chunks from the
    caller-supplied buffer to the SPI core.
    
    Since the patch merges two functions into a rewritten implementation,
    the function prototype was also changed, mainly for cosmetic consistency
    with the structures used within it.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 657c492d39a0..0ef97a916707 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -121,7 +121,7 @@ int sja1105_static_config_reload(struct sja1105_private *priv);
 /* From sja1105_spi.c */
 int sja1105_xfer_buf(const struct sja1105_private *priv,
 		     sja1105_spi_rw_mode_t rw, u64 reg_addr,
-		     void *packed_buf, size_t size_bytes);
+		     u8 *buf, size_t len);
 int sja1105_xfer_u32(const struct sja1105_private *priv,
 		     sja1105_spi_rw_mode_t rw, u64 reg_addr, u32 *value);
 int sja1105_xfer_u64(const struct sja1105_private *priv,

commit 664277781c4cb312971c5a2e2df3290bd990ac14
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Oct 12 02:18:16 2019 +0300

    net: dsa: sja1105: Change the PTP command access pattern
    
    The PTP command register contains enable bits for:
    - Putting the 64-bit PTPCLKVAL register in add/subtract or write mode
    - Taking timestamps off of the corrected vs free-running clock
    - Starting/stopping the TTEthernet scheduling
    - Starting/stopping PPS output
    - Resetting the switch
    
    When a command needs to be issued (e.g. "change the PTPCLKVAL from write
    mode to add/subtract mode"), one cannot simply write to the command
    register setting the PTPCLKADD bit to 1, because that would zeroize the
    other settings. One also cannot do a read-modify-write (that would be
    too easy for this hardware) because not all bits of the command register
    are readable over SPI.
    
    So this leaves us with the only option of keeping the value of the PTP
    command register in the driver, and operating on that.
    
    Actually there are 2 types of PTP operations now:
    - Operations that modify the cached PTP command. These operate on
      ptp_data->cmd as a pointer.
    - Operations that apply all previously cached PTP settings, but don't
      otherwise cache what they did themselves. The sja1105_ptp_reset
      function is such an example. It copies the ptp_data->cmd on stack
      before modifying and writing it to SPI.
    
    This practically means that struct sja1105_ptp_cmd is no longer an
    implementation detail, since it needs to be stored in full into struct
    sja1105_ptp_data, and hence in struct sja1105_private. So the (*ptp_cmd)
    function prototype can change and take struct sja1105_ptp_cmd as second
    argument now.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 722a0f4d1c88..657c492d39a0 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -72,7 +72,8 @@ struct sja1105_info {
 	const struct sja1105_dynamic_table_ops *dyn_ops;
 	const struct sja1105_table_ops *static_ops;
 	const struct sja1105_regs *regs;
-	int (*ptp_cmd)(const struct dsa_switch *ds, const void *data);
+	int (*ptp_cmd)(const struct dsa_switch *ds,
+		       const struct sja1105_ptp_cmd *cmd);
 	int (*reset_cmd)(const void *ctx, const void *data);
 	int (*setup_rgmii_delay)(const void *ctx, int port);
 	/* Prototypes from include/net/dsa.h */

commit a9d6ed7a8bd0f3091b9fe6d0b9facc9392c1ec21
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Oct 12 02:18:15 2019 +0300

    net: dsa: sja1105: Move PTP data to its own private structure
    
    This is a non-functional change with 2 goals (both for the case when
    CONFIG_NET_DSA_SJA1105_PTP is not enabled):
    
    - Reduce the size of the sja1105_private structure.
    - Make the PTP code more self-contained.
    
    Leaving priv->ptp_data.lock to be initialized in sja1105_main.c is not a
    leftover: it will be used in a future patch "net: dsa: sja1105: Restore
    PTP time after switch reset".
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index c12e24fce575..722a0f4d1c88 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -21,6 +21,7 @@
 #define SJA1105_AGEING_TIME_MS(ms)	((ms) / 10)
 
 #include "sja1105_tas.h"
+#include "sja1105_ptp.h"
 
 /* Keeps the different addresses between E/T and P/Q/R/S */
 struct sja1105_regs {
@@ -91,26 +92,16 @@ struct sja1105_private {
 	struct spi_device *spidev;
 	struct dsa_switch *ds;
 	struct sja1105_port ports[SJA1105_NUM_PORTS];
-	struct ptp_clock_info ptp_caps;
-	struct ptp_clock *clock;
-	/* The cycle counter translates the PTP timestamps (based on
-	 * a free-running counter) into a software time domain.
-	 */
-	struct cyclecounter tstamp_cc;
-	struct timecounter tstamp_tc;
-	struct delayed_work refresh_work;
-	/* Serializes all operations on the cycle counter */
-	struct mutex ptp_lock;
 	/* Serializes transmission of management frames so that
 	 * the switch doesn't confuse them with one another.
 	 */
 	struct mutex mgmt_lock;
 	struct sja1105_tagger_data tagger_data;
+	struct sja1105_ptp_data ptp_data;
 	struct sja1105_tas_data tas_data;
 };
 
 #include "sja1105_dynamic_config.h"
-#include "sja1105_ptp.h"
 
 struct sja1105_spi_message {
 	u64 access;

commit 61c77126278eb950010d2ed944c3bc09d10e0eb4
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Oct 12 02:18:14 2019 +0300

    net: dsa: sja1105: Make all public PTP functions take dsa_switch as argument
    
    The new rule (as already started for sja1105_tas.h) is for functions of
    optional driver components (ones which may be disabled via Kconfig - PTP
    and TAS) to take struct dsa_switch *ds instead of struct sja1105_private
    *priv as first argument.
    
    This is so that forward-declarations of struct sja1105_private can be
    avoided.
    
    So make sja1105_ptp.h the second user of this rule.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 8681ff9d1a76..c12e24fce575 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -71,7 +71,7 @@ struct sja1105_info {
 	const struct sja1105_dynamic_table_ops *dyn_ops;
 	const struct sja1105_table_ops *static_ops;
 	const struct sja1105_regs *regs;
-	int (*ptp_cmd)(const void *ctx, const void *data);
+	int (*ptp_cmd)(const struct dsa_switch *ds, const void *data);
 	int (*reset_cmd)(const void *ctx, const void *data);
 	int (*setup_rgmii_delay)(const void *ctx, int port);
 	/* Prototypes from include/net/dsa.h */

commit 1bd448703895473e500c0ce4c6258aeac1f67c20
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Tue Oct 1 22:18:01 2019 +0300

    net: dsa: sja1105: Rename sja1105_spi_send_packed_buf to sja1105_xfer_buf
    
    The most commonly called function in the driver is long due for a
    rename. The "packed" word is redundant (it doesn't make sense to
    transfer an unpacked structure, since that is in CPU endianness yadda
    yadda), and the "spi" word is also redundant since argument 2 of the
    function is SPI_READ or SPI_WRITE.
    
    As for the sja1105_spi_send_long_packed_buf function, it is only being
    used from sja1105_spi.c, so remove its global prototype.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index cba0beb87d9c..8681ff9d1a76 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -127,16 +127,13 @@ typedef enum {
 int sja1105_static_config_reload(struct sja1105_private *priv);
 
 /* From sja1105_spi.c */
-int sja1105_spi_send_packed_buf(const struct sja1105_private *priv,
-				sja1105_spi_rw_mode_t rw, u64 reg_addr,
-				void *packed_buf, size_t size_bytes);
+int sja1105_xfer_buf(const struct sja1105_private *priv,
+		     sja1105_spi_rw_mode_t rw, u64 reg_addr,
+		     void *packed_buf, size_t size_bytes);
 int sja1105_xfer_u32(const struct sja1105_private *priv,
 		     sja1105_spi_rw_mode_t rw, u64 reg_addr, u32 *value);
 int sja1105_xfer_u64(const struct sja1105_private *priv,
 		     sja1105_spi_rw_mode_t rw, u64 reg_addr, u64 *value);
-int sja1105_spi_send_long_packed_buf(const struct sja1105_private *priv,
-				     sja1105_spi_rw_mode_t rw, u64 base_addr,
-				     void *packed_buf, u64 buf_len);
 int sja1105_static_config_upload(struct sja1105_private *priv);
 int sja1105_inhibit_tx(const struct sja1105_private *priv,
 		       unsigned long port_bitmap, bool tx_inhibited);

commit dff79620c3e8c3a1793e0e4751b8cd7bd15f1565
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Tue Oct 1 22:18:00 2019 +0300

    net: dsa: sja1105: Replace sja1105_spi_send_int with sja1105_xfer_{u32, u64}
    
    Having a function that takes a variable number of unpacked bytes which
    it generically calls an "int" is confusing and makes auditing patches
    next to impossible.
    
    We only use spi_send_int with the int sizes of 32 and 64 bits. So just
    make the spi_send_int function less generic and replace it with the
    appropriate two explicit functions, which can now type-check the int
    pointer type.
    
    Note that there is still a small weirdness in the u32 function, which
    has to convert it to a u64 temporary. This is because of how the packing
    API works at the moment, but the weirdness is at least hidden from
    callers of sja1105_xfer_u32 now.
    
    Suggested-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index e53e494c22e0..cba0beb87d9c 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -130,9 +130,10 @@ int sja1105_static_config_reload(struct sja1105_private *priv);
 int sja1105_spi_send_packed_buf(const struct sja1105_private *priv,
 				sja1105_spi_rw_mode_t rw, u64 reg_addr,
 				void *packed_buf, size_t size_bytes);
-int sja1105_spi_send_int(const struct sja1105_private *priv,
-			 sja1105_spi_rw_mode_t rw, u64 reg_addr,
-			 u64 *value, u64 size_bytes);
+int sja1105_xfer_u32(const struct sja1105_private *priv,
+		     sja1105_spi_rw_mode_t rw, u64 reg_addr, u32 *value);
+int sja1105_xfer_u64(const struct sja1105_private *priv,
+		     sja1105_spi_rw_mode_t rw, u64 reg_addr, u64 *value);
 int sja1105_spi_send_long_packed_buf(const struct sja1105_private *priv,
 				     sja1105_spi_rw_mode_t rw, u64 base_addr,
 				     void *packed_buf, u64 buf_len);

commit 317ab5b86c8e15015efa208ec697affb9bd0b3f2
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sun Sep 15 05:00:02 2019 +0300

    net: dsa: sja1105: Configure the Time-Aware Scheduler via tc-taprio offload
    
    This qdisc offload is the closest thing to what the SJA1105 supports in
    hardware for time-based egress shaping. The switch core really is built
    around SAE AS6802/TTEthernet (a TTTech standard) but can be made to
    operate similarly to IEEE 802.1Qbv with some constraints:
    
    - The gate control list is a global list for all ports. There are 8
      execution threads that iterate through this global list in parallel.
      I don't know why 8, there are only 4 front-panel ports.
    
    - Care must be taken by the user to make sure that two execution threads
      never get to execute a GCL entry simultaneously. I created a O(n^4)
      checker for this hardware limitation, prior to accepting a taprio
      offload configuration as valid.
    
    - The spec says that if a GCL entry's interval is shorter than the frame
      length, you shouldn't send it (and end up in head-of-line blocking).
      Well, this switch does anyway.
    
    - The switch has no concept of ADMIN and OPER configurations. Because
      it's so simple, the TAS settings are loaded through the static config
      tables interface, so there isn't even place for any discussion about
      'graceful switchover between ADMIN and OPER'. You just reset the
      switch and upload a new OPER config.
    
    - The switch accepts multiple time sources for the gate events. Right
      now I am using the standalone clock source as opposed to PTP. So the
      base time parameter doesn't really do much. Support for the PTP clock
      source will be added in a future series.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 78094db32622..e53e494c22e0 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -20,6 +20,8 @@
  */
 #define SJA1105_AGEING_TIME_MS(ms)	((ms) / 10)
 
+#include "sja1105_tas.h"
+
 /* Keeps the different addresses between E/T and P/Q/R/S */
 struct sja1105_regs {
 	u64 device_id;
@@ -104,6 +106,7 @@ struct sja1105_private {
 	 */
 	struct mutex mgmt_lock;
 	struct sja1105_tagger_data tagger_data;
+	struct sja1105_tas_data tas_data;
 };
 
 #include "sja1105_dynamic_config.h"
@@ -120,6 +123,9 @@ typedef enum {
 	SPI_WRITE = 1,
 } sja1105_spi_rw_mode_t;
 
+/* From sja1105_main.c */
+int sja1105_static_config_reload(struct sja1105_private *priv);
+
 /* From sja1105_spi.c */
 int sja1105_spi_send_packed_buf(const struct sja1105_private *priv,
 				sja1105_spi_rw_mode_t rw, u64 reg_addr,

commit c05ec3d4d7df57ff286917f7fb54aec6fa4691c5
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Jun 8 19:12:28 2019 +0300

    net: dsa: sja1105: Add RGMII delay support for P/Q/R/S chips
    
    As per the DT phy-mode specification, RGMII delays are applied by the
    MAC when there is no PHY present on the link.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 3e0f685a144c..78094db32622 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -161,6 +161,7 @@ typedef enum {
 	SJA1105_SPEED_AUTO	= 0,
 } sja1105_speed_t;
 
+int sja1105pqrs_setup_rgmii_delay(const void *ctx, int port);
 int sja1105_clocking_setup_port(struct sja1105_private *priv, int port);
 int sja1105_clocking_setup(struct sja1105_private *priv);
 

commit b5b0c7f41e73cdca59dcfc05d32c5a8be54e1546
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Jun 8 19:12:27 2019 +0300

    net: dsa: sja1105: Remove duplicate rgmii_pad_mii_tx from regs
    
    The pad_mii_tx registers point to the same memory region but were
    unused. So convert to using these for RGMII I/O cell configuration, as
    they bear a shorter name.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 8c7bc55ef119..3e0f685a144c 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -35,8 +35,8 @@ struct sja1105_regs {
 	u64 ptptsclk;
 	u64 ptpegr_ts[SJA1105_NUM_PORTS];
 	u64 pad_mii_tx[SJA1105_NUM_PORTS];
+	u64 pad_mii_id[SJA1105_NUM_PORTS];
 	u64 cgu_idiv[SJA1105_NUM_PORTS];
-	u64 rgmii_pad_mii_tx[SJA1105_NUM_PORTS];
 	u64 mii_tx_clk[SJA1105_NUM_PORTS];
 	u64 mii_rx_clk[SJA1105_NUM_PORTS];
 	u64 mii_ext_tx_clk[SJA1105_NUM_PORTS];

commit d114fb04163f32f6986ca8aa11bff06d5c58d27b
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Jun 8 16:03:43 2019 +0300

    net: dsa: sja1105: Export the sja1105_inhibit_tx function
    
    This will be used to stop egress traffic in .phylink_mac_link_up.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 0fc6fe9ada87..8c7bc55ef119 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -131,6 +131,8 @@ int sja1105_spi_send_long_packed_buf(const struct sja1105_private *priv,
 				     sja1105_spi_rw_mode_t rw, u64 base_addr,
 				     void *packed_buf, u64 buf_len);
 int sja1105_static_config_upload(struct sja1105_private *priv);
+int sja1105_inhibit_tx(const struct sja1105_private *priv,
+		       unsigned long port_bitmap, bool tx_inhibited);
 
 extern struct sja1105_info sja1105e_info;
 extern struct sja1105_info sja1105t_info;

commit 844d7edc6a34ae3a8236f1306e4f2615c8db1eac
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Jun 8 15:04:40 2019 +0300

    net: dsa: sja1105: Add a global sja1105_tagger_data structure
    
    This will be used to keep state for RX timestamping. It is global
    because the switch serializes timestampable and meta frames when
    trapping them towards the CPU port (lower port indices have higher
    priority) and therefore having one state machine per port would create
    unnecessary complications.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 5a4f83a3417b..0fc6fe9ada87 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -103,6 +103,7 @@ struct sja1105_private {
 	 * the switch doesn't confuse them with one another.
 	 */
 	struct mutex mgmt_lock;
+	struct sja1105_tagger_data tagger_data;
 };
 
 #include "sja1105_dynamic_config.h"

commit 47ed985e97f513b7746270e8c5d1f3a3f959b2da
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Jun 8 15:04:35 2019 +0300

    net: dsa: sja1105: Add logic for TX timestamping
    
    On TX, timestamping is performed synchronously from the
    port_deferred_xmit worker thread.
    In management routes, the switch is requested to take egress timestamps
    (again partial), which are reconstructed and appended to a clone of the
    skb that was just sent.  The cloning is done by DSA and we retrieve the
    pointer from the structure that DSA keeps in skb->cb.
    Then these clones are enqueued to the socket's error queue for
    application-level processing.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 3c6296203c21..5a4f83a3417b 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -33,6 +33,7 @@ struct sja1105_regs {
 	u64 ptpclk;
 	u64 ptpclkrate;
 	u64 ptptsclk;
+	u64 ptpegr_ts[SJA1105_NUM_PORTS];
 	u64 pad_mii_tx[SJA1105_NUM_PORTS];
 	u64 cgu_idiv[SJA1105_NUM_PORTS];
 	u64 rgmii_pad_mii_tx[SJA1105_NUM_PORTS];
@@ -56,6 +57,15 @@ struct sja1105_info {
 	 * switch core and device_id)
 	 */
 	u64 part_no;
+	/* E/T and P/Q/R/S have partial timestamps of different sizes.
+	 * They must be reconstructed on both families anyway to get the full
+	 * 64-bit values back.
+	 */
+	int ptp_ts_bits;
+	/* Also SPI commands are of different sizes to retrieve
+	 * the egress timestamps.
+	 */
+	int ptpegr_ts_bytes;
 	const struct sja1105_dynamic_table_ops *dyn_ops;
 	const struct sja1105_table_ops *static_ops;
 	const struct sja1105_regs *regs;

commit bb77f36ac21d226b8ae4311daceb983be764f746
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Jun 8 15:04:34 2019 +0300

    net: dsa: sja1105: Add support for the PTP clock
    
    The design of this PHC driver is influenced by the switch's behavior
    w.r.t. timestamping.  It exposes two PTP counters, one free-running
    (PTPTSCLK) and the other offset- and frequency-corrected in hardware
    through PTPCLKVAL, PTPCLKADD and PTPCLKRATE.  The MACs can sample either
    of these for frame timestamps.
    
    However, the user manual warns that taking timestamps based on the
    corrected clock is less than useful, as the switch can deliver corrupted
    timestamps in a variety of circumstances.
    
    Therefore, this PHC uses the free-running PTPTSCLK together with a
    timecounter/cyclecounter structure that translates it into a software
    time domain.  Thus, the settime/adjtime and adjfine callbacks are
    hardware no-ops.
    
    The timestamps (introduced in a further patch) will also be translated
    to the correct time domain before being handed over to the userspace PTP
    stack.
    
    The introduction of a second set of PHC operations that operate on the
    hardware PTPCLKVAL/PTPCLKADD/PTPCLKRATE in the future is somewhat
    unavoidable, as the TTEthernet core uses the corrected PTP time domain.
    However, the free-running counter + timecounter structure combination
    will suffice for now, as the resulting timestamps yield a sub-50 ns
    synchronization offset in steady state using linuxptp.
    
    For this patch, in absence of frame timestamping, the operations of the
    switch PHC were tested by syncing it to the system time as a local slave
    clock with:
    
    phc2sys -s CLOCK_REALTIME -c swp2 -O 0 -m -S 0.01
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 61d00682de60..3c6296203c21 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -5,6 +5,8 @@
 #ifndef _SJA1105_H
 #define _SJA1105_H
 
+#include <linux/ptp_clock_kernel.h>
+#include <linux/timecounter.h>
 #include <linux/dsa/sja1105.h>
 #include <net/dsa.h>
 #include <linux/mutex.h>
@@ -27,6 +29,10 @@ struct sja1105_regs {
 	u64 rgu;
 	u64 config;
 	u64 rmii_pll1;
+	u64 ptp_control;
+	u64 ptpclk;
+	u64 ptpclkrate;
+	u64 ptptsclk;
 	u64 pad_mii_tx[SJA1105_NUM_PORTS];
 	u64 cgu_idiv[SJA1105_NUM_PORTS];
 	u64 rgmii_pad_mii_tx[SJA1105_NUM_PORTS];
@@ -53,6 +59,7 @@ struct sja1105_info {
 	const struct sja1105_dynamic_table_ops *dyn_ops;
 	const struct sja1105_table_ops *static_ops;
 	const struct sja1105_regs *regs;
+	int (*ptp_cmd)(const void *ctx, const void *data);
 	int (*reset_cmd)(const void *ctx, const void *data);
 	int (*setup_rgmii_delay)(const void *ctx, int port);
 	/* Prototypes from include/net/dsa.h */
@@ -72,6 +79,16 @@ struct sja1105_private {
 	struct spi_device *spidev;
 	struct dsa_switch *ds;
 	struct sja1105_port ports[SJA1105_NUM_PORTS];
+	struct ptp_clock_info ptp_caps;
+	struct ptp_clock *clock;
+	/* The cycle counter translates the PTP timestamps (based on
+	 * a free-running counter) into a software time domain.
+	 */
+	struct cyclecounter tstamp_cc;
+	struct timecounter tstamp_tc;
+	struct delayed_work refresh_work;
+	/* Serializes all operations on the cycle counter */
+	struct mutex ptp_lock;
 	/* Serializes transmission of management frames so that
 	 * the switch doesn't confuse them with one another.
 	 */
@@ -79,6 +96,7 @@ struct sja1105_private {
 };
 
 #include "sja1105_dynamic_config.h"
+#include "sja1105_ptp.h"
 
 struct sja1105_spi_message {
 	u64 access;

commit 1da73821343c7d733de96de0a44d6d807bda98ce
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Mon Jun 3 00:15:45 2019 +0300

    net: dsa: sja1105: Add FDB operations for P/Q/R/S series
    
    This adds support for manipulating the L2 forwarding database (dump,
    add, delete) for the second generation of NXP SJA1105 switches.
    
    At the moment only FDB entries installed statically through 'bridge fdb'
    are visible in the dump callback - the dynamically learned ones are
    still under investigation.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index f55e95d1b731..61d00682de60 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -147,6 +147,11 @@ int sja1105_dynamic_config_write(struct sja1105_private *priv,
 				 enum sja1105_blk_idx blk_idx,
 				 int index, void *entry, bool keep);
 
+enum sja1105_iotag {
+	SJA1105_C_TAG = 0, /* Inner VLAN header */
+	SJA1105_S_TAG = 1, /* Outer VLAN header */
+};
+
 u8 sja1105et_fdb_hash(struct sja1105_private *priv, const u8 *addr, u16 vid);
 int sja1105et_fdb_add(struct dsa_switch *ds, int port,
 		      const unsigned char *addr, u16 vid);

commit 9dfa69118f12d6c67d34f90bfd9a825a908d5f60
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Mon Jun 3 00:11:57 2019 +0300

    net: dsa: sja1105: Make room for P/Q/R/S FDB operations
    
    The DSA callbacks were written with the E/T (first generation) in mind,
    which is quite different.
    
    For P/Q/R/S completely new implementations need to be provided, which
    are held as function pointers in the priv->info structure.  We are
    taking a slightly roundabout way for this (a function from
    sja1105_main.c reads a structure defined in sja1105_spi.c that
    points to a function defined in sja1105_main.c), but it is what it is.
    
    The FDB dump callback works for both families, hence no function pointer
    for that.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index b043bfc408f2..f55e95d1b731 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -55,6 +55,11 @@ struct sja1105_info {
 	const struct sja1105_regs *regs;
 	int (*reset_cmd)(const void *ctx, const void *data);
 	int (*setup_rgmii_delay)(const void *ctx, int port);
+	/* Prototypes from include/net/dsa.h */
+	int (*fdb_add_cmd)(struct dsa_switch *ds, int port,
+			   const unsigned char *addr, u16 vid);
+	int (*fdb_del_cmd)(struct dsa_switch *ds, int port,
+			   const unsigned char *addr, u16 vid);
 	const char *name;
 };
 
@@ -142,7 +147,15 @@ int sja1105_dynamic_config_write(struct sja1105_private *priv,
 				 enum sja1105_blk_idx blk_idx,
 				 int index, void *entry, bool keep);
 
-u8 sja1105_fdb_hash(struct sja1105_private *priv, const u8 *addr, u16 vid);
+u8 sja1105et_fdb_hash(struct sja1105_private *priv, const u8 *addr, u16 vid);
+int sja1105et_fdb_add(struct dsa_switch *ds, int port,
+		      const unsigned char *addr, u16 vid);
+int sja1105et_fdb_del(struct dsa_switch *ds, int port,
+		      const unsigned char *addr, u16 vid);
+int sja1105pqrs_fdb_add(struct dsa_switch *ds, int port,
+			const unsigned char *addr, u16 vid);
+int sja1105pqrs_fdb_del(struct dsa_switch *ds, int port,
+			const unsigned char *addr, u16 vid);
 
 /* Common implementations for the static and dynamic configs */
 size_t sja1105_l2_forwarding_entry_packing(void *buf, void *entry_ptr,

commit 227d07a07ef126272ea2eed97fd136cd7a803d81
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sun May 5 13:19:27 2019 +0300

    net: dsa: sja1105: Add support for traffic through standalone ports
    
    In order to support this, we are creating a make-shift switch tag out of
    a VLAN trunk configured on the CPU port. Termination of normal traffic
    on switch ports only works when not under a vlan_filtering bridge.
    Termination of management (PTP, BPDU) traffic works under all
    circumstances because it uses a different tagging mechanism
    (incl_srcpt). We are making use of the generic CONFIG_NET_DSA_TAG_8021Q
    code and leveraging it from our own CONFIG_NET_DSA_TAG_SJA1105.
    
    There are two types of traffic: regular and link-local.
    
    The link-local traffic received on the CPU port is trapped from the
    switch's regular forwarding decisions because it matched one of the two
    DMAC filters for management traffic.
    
    On transmission, the switch requires special massaging for these
    link-local frames. Due to a weird implementation of the switching IP, by
    default it drops link-local frames that originate on the CPU port.
    It needs to be told where to forward them to, through an SPI command
    ("management route") that is valid for only a single frame.
    So when we're sending link-local traffic, we are using the
    dsa_defer_xmit mechanism.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index b0a155b57e17..b043bfc408f2 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -7,6 +7,7 @@
 
 #include <linux/dsa/sja1105.h>
 #include <net/dsa.h>
+#include <linux/mutex.h>
 #include "sja1105_static_config.h"
 
 #define SJA1105_NUM_PORTS		5
@@ -65,6 +66,11 @@ struct sja1105_private {
 	struct gpio_desc *reset_gpio;
 	struct spi_device *spidev;
 	struct dsa_switch *ds;
+	struct sja1105_port ports[SJA1105_NUM_PORTS];
+	/* Serializes transmission of management frames so that
+	 * the switch doesn't confuse them with one another.
+	 */
+	struct mutex mgmt_lock;
 };
 
 #include "sja1105_dynamic_config.h"

commit 1a4c69406cc1c3c42bb7391c8eb544e93fe9b320
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Thu May 2 23:23:37 2019 +0300

    net: dsa: sja1105: Prevent PHY jabbering during switch reset
    
    Resetting the switch at runtime is currently done while changing the
    vlan_filtering setting (due to the required TPID change).
    
    But reset is asynchronous with packet egress, and the switch core will
    not wait for egress to finish before carrying on with the reset
    operation.
    
    As a result, a connected PHY such as the BCM5464 would see an
    unterminated Ethernet frame and start to jabber (repeat the last seen
    Ethernet symbols - jabber is by definition an oversized Ethernet frame
    with bad FCS). This behavior is strange in itself, but it also causes
    the MACs of some link partners (such as the FRDM-LS1012A) to completely
    lock up.
    
    So as a remedy for this situation, when switch reset is required, simply
    inhibit Tx on all ports, and wait for the necessary time for the
    eventual one frame left in the egress queue (not even the Tx inhibit
    command is instantaneous) to be flushed.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 0489d9adf957..b0a155b57e17 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -22,6 +22,7 @@ struct sja1105_regs {
 	u64 device_id;
 	u64 prod_id;
 	u64 status;
+	u64 port_control;
 	u64 rgu;
 	u64 config;
 	u64 rmii_pll1;

commit 8456721dd4ec777e6f914f2ae98ba9fe3c6681df
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Thu May 2 23:23:36 2019 +0300

    net: dsa: sja1105: Add support for configuring address ageing time
    
    If STP is active, this setting is applied on bridged ports each time an
    Ethernet link is established (topology changes).
    
    Since the setting is global to the switch and a reset is required to
    change it, resets are prevented if the new callback does not change the
    value that the hardware already is programmed for.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 38506bde83c6..0489d9adf957 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -12,6 +12,10 @@
 #define SJA1105_NUM_PORTS		5
 #define SJA1105_NUM_TC			8
 #define SJA1105ET_FDB_BIN_SIZE		4
+/* The hardware value is in multiples of 10 ms.
+ * The passed parameter is in multiples of 1 ms.
+ */
+#define SJA1105_AGEING_TIME_MS(ms)	((ms) / 10)
 
 /* Keeps the different addresses between E/T and P/Q/R/S */
 struct sja1105_regs {

commit 52c34e6e125c153097befbfe18b8d2918c68a41d
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Thu May 2 23:23:35 2019 +0300

    net: dsa: sja1105: Add support for ethtool port counters
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 87dee6794d98..38506bde83c6 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -117,8 +117,13 @@ typedef enum {
 int sja1105_clocking_setup_port(struct sja1105_private *priv, int port);
 int sja1105_clocking_setup(struct sja1105_private *priv);
 
-/* From sja1105_dynamic_config.c */
+/* From sja1105_ethtool.c */
+void sja1105_get_ethtool_stats(struct dsa_switch *ds, int port, u64 *data);
+void sja1105_get_strings(struct dsa_switch *ds, int port,
+			 u32 stringset, u8 *data);
+int sja1105_get_sset_count(struct dsa_switch *ds, int port, int sset);
 
+/* From sja1105_dynamic_config.c */
 int sja1105_dynamic_config_read(struct sja1105_private *priv,
 				enum sja1105_blk_idx blk_idx,
 				int index, void *entry);

commit f5b8631c293b9a88e38a152fa9a67f89e2d9b151
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Thu May 2 23:23:32 2019 +0300

    net: dsa: sja1105: Error out if RGMII delays are requested in DT
    
    Documentation/devicetree/bindings/net/ethernet.txt is confusing because
    it says what the MAC should not do, but not what it *should* do:
    
      * "rgmii-rxid" (RGMII with internal RX delay provided by the PHY, the MAC
         should not add an RX delay in this case)
    
    The gap in semantics is threefold:
    1. Is it illegal for the MAC to apply the Rx internal delay by itself,
       and simplify the phy_mode (mask off "rgmii-rxid" into "rgmii") before
       passing it to of_phy_connect? The documentation would suggest yes.
    1. For "rgmii-rxid", while the situation with the Rx clock skew is more
       or less clear (needs to be added by the PHY), what should the MAC
       driver do about the Tx delays? Is it an implicit wild card for the
       MAC to apply delays in the Tx direction if it can? What if those were
       already added as serpentine PCB traces, how could that be made more
       obvious through DT bindings so that the MAC doesn't attempt to add
       them twice and again potentially break the link?
    3. If the interface is a fixed-link and therefore the PHY object is
       fixed (a purely software entity that obviously cannot add clock
       skew), what is the meaning of the above property?
    
    So an interpretation of the RGMII bindings was chosen that hopefully
    does not contradict their intention but also makes them more applied.
    The SJA1105 driver understands to act upon "rgmii-*id" phy-mode bindings
    if the port is in the PHY role (either explicitly, or if it is a
    fixed-link). Otherwise it always passes the duty of setting up delays to
    the PHY driver.
    
    The error behavior that this patch adds is required on SJA1105E/T where
    the MAC really cannot apply internal delays. If the other end of the
    fixed-link cannot apply RGMII delays either (this would be specified
    through its own DT bindings), then the situation requires PCB delays.
    
    For SJA1105P/Q/R/S, this is however hardware supported and the error is
    thus only temporary. I created a stub function pointer for configuring
    delays per-port on RXC and TXC, and will implement it when I have access
    to a board with this hardware setup.
    
    Meanwhile do not allow the user to select an invalid configuration.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index 50ab9282c4f1..87dee6794d98 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -48,11 +48,14 @@ struct sja1105_info {
 	const struct sja1105_table_ops *static_ops;
 	const struct sja1105_regs *regs;
 	int (*reset_cmd)(const void *ctx, const void *data);
+	int (*setup_rgmii_delay)(const void *ctx, int port);
 	const char *name;
 };
 
 struct sja1105_private {
 	struct sja1105_static_config static_config;
+	bool rgmii_rx_delay[SJA1105_NUM_PORTS];
+	bool rgmii_tx_delay[SJA1105_NUM_PORTS];
 	const struct sja1105_info *info;
 	struct gpio_desc *reset_gpio;
 	struct spi_device *spidev;

commit 291d1e72b756424eac7b1ea2be326a59f004a580
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Thu May 2 23:23:31 2019 +0300

    net: dsa: sja1105: Add support for FDB and MDB management
    
    Currently only the (more difficult) first generation E/T series is
    supported. Here the TCAM is only 4-way associative, and to know where
    the hardware will search for a FDB entry, we need to perform the same
    hash algorithm in order to install the entry in the correct bin.
    
    On P/Q/R/S, the TCAM should be fully associative. However the SPI
    command interface is different, and because I don't have access to a
    new-generation device at the moment, support for it is TODO.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
index e01cb854cbcd..50ab9282c4f1 100644
--- a/drivers/net/dsa/sja1105/sja1105.h
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -123,6 +123,8 @@ int sja1105_dynamic_config_write(struct sja1105_private *priv,
 				 enum sja1105_blk_idx blk_idx,
 				 int index, void *entry, bool keep);
 
+u8 sja1105_fdb_hash(struct sja1105_private *priv, const u8 *addr, u16 vid);
+
 /* Common implementations for the static and dynamic configs */
 size_t sja1105_l2_forwarding_entry_packing(void *buf, void *entry_ptr,
 					   enum packing_op op);

commit 8aa9ebccae87621d997707e4f25e53fddd7e30e4
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Thu May 2 23:23:30 2019 +0300

    net: dsa: Introduce driver for NXP SJA1105 5-port L2 switch
    
    At this moment the following is supported:
    * Link state management through phylib
    * Autonomous L2 forwarding managed through iproute2 bridge commands.
    
    IP termination must be done currently through the master netdevice,
    since the switch is unmanaged at this point and using
    DSA_TAG_PROTO_NONE.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Signed-off-by: Georg Waibel <georg.waibel@sensor-technik.de>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/sja1105/sja1105.h b/drivers/net/dsa/sja1105/sja1105.h
new file mode 100644
index 000000000000..e01cb854cbcd
--- /dev/null
+++ b/drivers/net/dsa/sja1105/sja1105.h
@@ -0,0 +1,138 @@
+/* SPDX-License-Identifier: GPL-2.0
+ * Copyright (c) 2018, Sensor-Technik Wiedemann GmbH
+ * Copyright (c) 2018-2019, Vladimir Oltean <olteanv@gmail.com>
+ */
+#ifndef _SJA1105_H
+#define _SJA1105_H
+
+#include <linux/dsa/sja1105.h>
+#include <net/dsa.h>
+#include "sja1105_static_config.h"
+
+#define SJA1105_NUM_PORTS		5
+#define SJA1105_NUM_TC			8
+#define SJA1105ET_FDB_BIN_SIZE		4
+
+/* Keeps the different addresses between E/T and P/Q/R/S */
+struct sja1105_regs {
+	u64 device_id;
+	u64 prod_id;
+	u64 status;
+	u64 rgu;
+	u64 config;
+	u64 rmii_pll1;
+	u64 pad_mii_tx[SJA1105_NUM_PORTS];
+	u64 cgu_idiv[SJA1105_NUM_PORTS];
+	u64 rgmii_pad_mii_tx[SJA1105_NUM_PORTS];
+	u64 mii_tx_clk[SJA1105_NUM_PORTS];
+	u64 mii_rx_clk[SJA1105_NUM_PORTS];
+	u64 mii_ext_tx_clk[SJA1105_NUM_PORTS];
+	u64 mii_ext_rx_clk[SJA1105_NUM_PORTS];
+	u64 rgmii_tx_clk[SJA1105_NUM_PORTS];
+	u64 rmii_ref_clk[SJA1105_NUM_PORTS];
+	u64 rmii_ext_tx_clk[SJA1105_NUM_PORTS];
+	u64 mac[SJA1105_NUM_PORTS];
+	u64 mac_hl1[SJA1105_NUM_PORTS];
+	u64 mac_hl2[SJA1105_NUM_PORTS];
+	u64 qlevel[SJA1105_NUM_PORTS];
+};
+
+struct sja1105_info {
+	u64 device_id;
+	/* Needed for distinction between P and R, and between Q and S
+	 * (since the parts with/without SGMII share the same
+	 * switch core and device_id)
+	 */
+	u64 part_no;
+	const struct sja1105_dynamic_table_ops *dyn_ops;
+	const struct sja1105_table_ops *static_ops;
+	const struct sja1105_regs *regs;
+	int (*reset_cmd)(const void *ctx, const void *data);
+	const char *name;
+};
+
+struct sja1105_private {
+	struct sja1105_static_config static_config;
+	const struct sja1105_info *info;
+	struct gpio_desc *reset_gpio;
+	struct spi_device *spidev;
+	struct dsa_switch *ds;
+};
+
+#include "sja1105_dynamic_config.h"
+
+struct sja1105_spi_message {
+	u64 access;
+	u64 read_count;
+	u64 address;
+};
+
+typedef enum {
+	SPI_READ = 0,
+	SPI_WRITE = 1,
+} sja1105_spi_rw_mode_t;
+
+/* From sja1105_spi.c */
+int sja1105_spi_send_packed_buf(const struct sja1105_private *priv,
+				sja1105_spi_rw_mode_t rw, u64 reg_addr,
+				void *packed_buf, size_t size_bytes);
+int sja1105_spi_send_int(const struct sja1105_private *priv,
+			 sja1105_spi_rw_mode_t rw, u64 reg_addr,
+			 u64 *value, u64 size_bytes);
+int sja1105_spi_send_long_packed_buf(const struct sja1105_private *priv,
+				     sja1105_spi_rw_mode_t rw, u64 base_addr,
+				     void *packed_buf, u64 buf_len);
+int sja1105_static_config_upload(struct sja1105_private *priv);
+
+extern struct sja1105_info sja1105e_info;
+extern struct sja1105_info sja1105t_info;
+extern struct sja1105_info sja1105p_info;
+extern struct sja1105_info sja1105q_info;
+extern struct sja1105_info sja1105r_info;
+extern struct sja1105_info sja1105s_info;
+
+/* From sja1105_clocking.c */
+
+typedef enum {
+	XMII_MAC = 0,
+	XMII_PHY = 1,
+} sja1105_mii_role_t;
+
+typedef enum {
+	XMII_MODE_MII		= 0,
+	XMII_MODE_RMII		= 1,
+	XMII_MODE_RGMII		= 2,
+} sja1105_phy_interface_t;
+
+typedef enum {
+	SJA1105_SPEED_10MBPS	= 3,
+	SJA1105_SPEED_100MBPS	= 2,
+	SJA1105_SPEED_1000MBPS	= 1,
+	SJA1105_SPEED_AUTO	= 0,
+} sja1105_speed_t;
+
+int sja1105_clocking_setup_port(struct sja1105_private *priv, int port);
+int sja1105_clocking_setup(struct sja1105_private *priv);
+
+/* From sja1105_dynamic_config.c */
+
+int sja1105_dynamic_config_read(struct sja1105_private *priv,
+				enum sja1105_blk_idx blk_idx,
+				int index, void *entry);
+int sja1105_dynamic_config_write(struct sja1105_private *priv,
+				 enum sja1105_blk_idx blk_idx,
+				 int index, void *entry, bool keep);
+
+/* Common implementations for the static and dynamic configs */
+size_t sja1105_l2_forwarding_entry_packing(void *buf, void *entry_ptr,
+					   enum packing_op op);
+size_t sja1105pqrs_l2_lookup_entry_packing(void *buf, void *entry_ptr,
+					   enum packing_op op);
+size_t sja1105et_l2_lookup_entry_packing(void *buf, void *entry_ptr,
+					 enum packing_op op);
+size_t sja1105_vlan_lookup_entry_packing(void *buf, void *entry_ptr,
+					 enum packing_op op);
+size_t sja1105pqrs_mac_config_entry_packing(void *buf, void *entry_ptr,
+					    enum packing_op op);
+
+#endif
