commit eee87e4377a4b86dc2eea0ade162b0dc33f40576
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Nov 4 13:51:39 2019 -0800

    net: dsa: bcm_sf2: Add support for optional reset controller line
    
    Grab an optional and exclusive reset controller line for the switch and
    manage it during probe/remove functions accordingly. For 7278 devices we
    change bcm_sf2_sw_rst() to use the reset controller line since the
    WATCHDOG_CTRL register does not reset the switch contrary to stated
    documentation.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 1df30ccec42d..de386dd96d66 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -18,6 +18,7 @@
 #include <linux/types.h>
 #include <linux/bitops.h>
 #include <linux/if_vlan.h>
+#include <linux/reset.h>
 
 #include <net/dsa.h>
 
@@ -64,6 +65,8 @@ struct bcm_sf2_priv {
 	void __iomem			*fcb;
 	void __iomem			*acb;
 
+	struct reset_control		*rcdev;
+
 	/* Register offsets indirection tables */
 	u32 				type;
 	const u16			*reg_offsets;

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index eb3655bea467..1df30ccec42d 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -1,12 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Broadcom Starfighter2 private context
  *
  * Copyright (C) 2014, Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 
 #ifndef __BCM_SF2_H

commit f4ae9c0840b7e1f9bd2177189a45a21e6f11aa8d
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed Feb 6 12:45:59 2019 -0800

    net: dsa: bcm_sf2: Add support for CFP statistics
    
    Return CFP policer statistics (Green, Yellow or Red) as part of the
    standard ethtool statistics. This helps debug when CFP rules may not be
    hit (0 counter).
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 83e1d8001447..eb3655bea467 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -213,5 +213,10 @@ int bcm_sf2_set_rxnfc(struct dsa_switch *ds, int port,
 int bcm_sf2_cfp_rst(struct bcm_sf2_priv *priv);
 void bcm_sf2_cfp_exit(struct dsa_switch *ds);
 int bcm_sf2_cfp_resume(struct dsa_switch *ds);
+void bcm_sf2_cfp_get_strings(struct dsa_switch *ds, int port,
+			     u32 stringset, uint8_t *data);
+void bcm_sf2_cfp_get_ethtool_stats(struct dsa_switch *ds, int port,
+				   uint64_t *data);
+int bcm_sf2_cfp_get_sset_count(struct dsa_switch *ds, int port, int sset);
 
 #endif /* __BCM_SF2_H */

commit 1f03f2609f3d76622389ae5b60a7c692a47bcc1b
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed Feb 6 12:45:57 2019 -0800

    net: dsa: bcm_sf2: Remove stats mutex
    
    We no longer need a dedicated statistics mutex since we leverage
    b53_common for statistics now.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index faaef320ec48..83e1d8001447 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -87,9 +87,6 @@ struct bcm_sf2_priv {
 	/* Backing b53_device */
 	struct b53_device		*dev;
 
-	/* Mutex protecting access to the MIB counters */
-	struct mutex			stats_mutex;
-
 	struct bcm_sf2_hw_params	hw_params;
 
 	struct bcm_sf2_port_status	port_sts[DSA_MAX_PORTS];

commit 1c0130f0b5756b38b636e3cb7b3abc2b48bb9edc
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Nov 6 12:58:39 2018 -0800

    net: dsa: bcm_sf2: Restore CFP rules during system resume
    
    The hardware can lose its context during system suspend, and depending
    on the switch generation (7445 vs. 7278), while the rules are still
    there, they will have their valid bit cleared (because that's the
    fastest way for the HW to reset things). Just make sure we re-apply them
    coming back from resume. The 7445 switch is an older version of the core
    that has some quirky RAM technology requiring a delete then re-inser to
    guarantee the RAM entries are properly latched.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 03444982c25e..faaef320ec48 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -215,5 +215,6 @@ int bcm_sf2_set_rxnfc(struct dsa_switch *ds, int port,
 		      struct ethtool_rxnfc *nfc);
 int bcm_sf2_cfp_rst(struct bcm_sf2_priv *priv);
 void bcm_sf2_cfp_exit(struct dsa_switch *ds);
+int bcm_sf2_cfp_resume(struct dsa_switch *ds);
 
 #endif /* __BCM_SF2_H */

commit ae7a5aff783c79d5ca87867df84b08c43447159b
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Nov 6 12:58:37 2018 -0800

    net: dsa: bcm_sf2: Keep copy of inserted rules
    
    We tried hard to use the hardware as a storage area, which made things
    needlessly complex in that we had to both marshall and unmarshall the
    ethtool_rx_flow_spec into what the CFP hardware understands but it did
    not require any driver level allocations, so that was nice.
    
    Keep a copy of the ethtool_rx_flow_spec rule we want to insert, and also
    make sure we don't have a duplicate rule already. This greatly speeds up
    the deletion time since we only need to clear the slice's valid bit and
    not perform a full read.
    
    This is a preparatory step for being able to restore rules upon system
    resumption where the hardware loses its context partially or entirely.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index cc31e986e6e3..03444982c25e 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -56,6 +56,7 @@ struct bcm_sf2_cfp_priv {
 	DECLARE_BITMAP(used, CFP_NUM_RULES);
 	DECLARE_BITMAP(unique, CFP_NUM_RULES);
 	unsigned int rules_cnt;
+	struct list_head rules_list;
 };
 
 struct bcm_sf2_priv {
@@ -213,5 +214,6 @@ int bcm_sf2_get_rxnfc(struct dsa_switch *ds, int port,
 int bcm_sf2_set_rxnfc(struct dsa_switch *ds, int port,
 		      struct ethtool_rxnfc *nfc);
 int bcm_sf2_cfp_rst(struct bcm_sf2_priv *priv);
+void bcm_sf2_cfp_exit(struct dsa_switch *ds);
 
 #endif /* __BCM_SF2_H */

commit ba0696c22e7c5b7394283a0dbef1462252d1606f
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Oct 20 14:39:47 2017 -0700

    net: dsa: bcm_sf2: Add support for IPv6 CFP rules
    
    Inserting IPv6 CFP rules complicates the code a little bit in that we
    need to insert two rules side by side and chain them to match a full
    IPv6 tuple (src, dst IPv6 + port + protocol).
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 1922e027ff59..cc31e986e6e3 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -54,6 +54,7 @@ struct bcm_sf2_cfp_priv {
 	/* Mutex protecting concurrent accesses to the CFP registers */
 	struct mutex lock;
 	DECLARE_BITMAP(used, CFP_NUM_RULES);
+	DECLARE_BITMAP(unique, CFP_NUM_RULES);
 	unsigned int rules_cnt;
 };
 

commit 22256b0afb12333571ad11799fa68fd27e4f4e80
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Sep 19 10:46:50 2017 -0700

    net: dsa: b53: Move EEE functions to b53
    
    Move the bcm_sf2 EEE-related functions to the b53 driver because this is shared
    code amongst Gigabit capable switch, only 5325 and 5365 are too old to support
    that.
    
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 02c499f9c56b..1922e027ff59 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -48,8 +48,6 @@ struct bcm_sf2_hw_params {
 
 struct bcm_sf2_port_status {
 	unsigned int link;
-
-	struct ethtool_eee eee;
 };
 
 struct bcm_sf2_cfp_priv {

commit 6026e043d09012c6269f9a96a808d52d9c498224
Merge: 4cc5b44b29a9 138e4ad67afd
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Sep 1 17:42:05 2017 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Three cases of simple overlapping changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit df191632f814357ee4d646421662d866028b569d
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed Aug 30 12:39:33 2017 -0700

    net: dsa: bcm_sf2: Fix number of CFP entries for BCM7278
    
    BCM7278 has only 128 entries while BCM7445 has the full 256 entries set,
    fix that.
    
    Fixes: 7318166cacad ("net: dsa: bcm_sf2: Add support for ethtool::rxnfc")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 7d3030e04f11..7f9125eef3df 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -72,6 +72,7 @@ struct bcm_sf2_priv {
 	u32 				type;
 	const u16			*reg_offsets;
 	unsigned int			core_reg_align;
+	unsigned int			num_cfp_rules;
 
 	/* spinlock protecting access to the indirect registers */
 	spinlock_t			indir_lock;

commit fdb71a2d1adcaca0df2f73ced7851fe0c85312f8
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Aug 29 13:35:16 2017 -0700

    net: dsa: bcm_sf2: Use correct I/O accessors
    
    The Starfigther 2 driver currently uses __raw_{read,write}l which means
    native I/O endian. This works correctly for an ARM LE kernel (default)
    but fails miserably on an ARM BE (BE8) kernel where registers are kept
    little endian, so replace uses with {read,write}l_relaxed here which is
    what we want because this is all performance sensitive code.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 7d3030e04f11..d9c96b281fc0 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -130,12 +130,12 @@ static inline u32 bcm_sf2_mangle_addr(struct bcm_sf2_priv *priv, u32 off)
 #define SF2_IO_MACRO(name) \
 static inline u32 name##_readl(struct bcm_sf2_priv *priv, u32 off)	\
 {									\
-	return __raw_readl(priv->name + off);				\
+	return readl_relaxed(priv->name + off);				\
 }									\
 static inline void name##_writel(struct bcm_sf2_priv *priv,		\
 				  u32 val, u32 off)			\
 {									\
-	__raw_writel(val, priv->name + off);				\
+	writel_relaxed(val, priv->name + off);				\
 }									\
 
 /* Accesses to 64-bits register requires us to latch the hi/lo pairs
@@ -179,23 +179,23 @@ static inline void intrl2_##which##_mask_set(struct bcm_sf2_priv *priv, \
 static inline u32 core_readl(struct bcm_sf2_priv *priv, u32 off)
 {
 	u32 tmp = bcm_sf2_mangle_addr(priv, off);
-	return __raw_readl(priv->core + tmp);
+	return readl_relaxed(priv->core + tmp);
 }
 
 static inline void core_writel(struct bcm_sf2_priv *priv, u32 val, u32 off)
 {
 	u32 tmp = bcm_sf2_mangle_addr(priv, off);
-	__raw_writel(val, priv->core + tmp);
+	writel_relaxed(val, priv->core + tmp);
 }
 
 static inline u32 reg_readl(struct bcm_sf2_priv *priv, u16 off)
 {
-	return __raw_readl(priv->reg + priv->reg_offsets[off]);
+	return readl_relaxed(priv->reg + priv->reg_offsets[off]);
 }
 
 static inline void reg_writel(struct bcm_sf2_priv *priv, u32 val, u16 off)
 {
-	__raw_writel(val, priv->reg + priv->reg_offsets[off]);
+	writel_relaxed(val, priv->reg + priv->reg_offsets[off]);
 }
 
 SF2_IO64_MACRO(core);

commit 7318166cacad158b46240f66250d7cc5a481653b
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Jan 30 09:48:43 2017 -0800

    net: dsa: bcm_sf2: Add support for ethtool::rxnfc
    
    Add support for configuring classification rules using the
    ethtool::rxnfc API.  This is useful to program the switch's CFP/TCAM to
    redirect specific packets to specific ports/queues for instance. For
    now, we allow any kind of IPv4 5-tuple matching.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 6e1f74e4d471..7d3030e04f11 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -52,6 +52,13 @@ struct bcm_sf2_port_status {
 	struct ethtool_eee eee;
 };
 
+struct bcm_sf2_cfp_priv {
+	/* Mutex protecting concurrent accesses to the CFP registers */
+	struct mutex lock;
+	DECLARE_BITMAP(used, CFP_NUM_RULES);
+	unsigned int rules_cnt;
+};
+
 struct bcm_sf2_priv {
 	/* Base registers, keep those in order with BCM_SF2_REGS_NAME */
 	void __iomem			*core;
@@ -103,6 +110,9 @@ struct bcm_sf2_priv {
 
 	/* Bitmask of ports needing BRCM tags */
 	unsigned int			brcm_tag_mask;
+
+	/* CFP rules context */
+	struct bcm_sf2_cfp_priv		cfp;
 };
 
 static inline struct bcm_sf2_priv *bcm_sf2_to_priv(struct dsa_switch *ds)
@@ -197,4 +207,11 @@ SF2_IO_MACRO(acb);
 SWITCH_INTR_L2(0);
 SWITCH_INTR_L2(1);
 
+/* RXNFC */
+int bcm_sf2_get_rxnfc(struct dsa_switch *ds, int port,
+		      struct ethtool_rxnfc *nfc, u32 *rule_locs);
+int bcm_sf2_set_rxnfc(struct dsa_switch *ds, int port,
+		      struct ethtool_rxnfc *nfc);
+int bcm_sf2_cfp_rst(struct bcm_sf2_priv *priv);
+
 #endif /* __BCM_SF2_H */

commit 64ff2aef91afdff7f22eaef05a65b5bc3429ef21
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Jan 20 12:36:32 2017 -0800

    net: dsa: bcm_sf2: Allow non-IMP ports to have Broadcom tags enabled
    
    Parse the "brcm,use-bcm-hdr" boolean property during ports
    identification to fill a bitmask of ports that should have Broadcom tags
    enabled. This is needed in some configurations where per-packet metadata
    can be exchanged using Broadcom tags between the switch and an on-chip
    acceleration device.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index a1430866bd79..6e1f74e4d471 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -100,6 +100,9 @@ struct bcm_sf2_priv {
 	struct device_node		*master_mii_dn;
 	struct mii_bus			*slave_mii_bus;
 	struct mii_bus			*master_mii_bus;
+
+	/* Bitmask of ports needing BRCM tags */
+	unsigned int			brcm_tag_mask;
 };
 
 static inline struct bcm_sf2_priv *bcm_sf2_to_priv(struct dsa_switch *ds)

commit a78e86ed586dba0808f765a9498f1fcd803f6ac6
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Jan 20 12:36:29 2017 -0800

    net: dsa: bcm_sf2: Prepare for different register layouts
    
    In preparation for supporting a new device with a slightly different
    register layout, affecting the SWITCH_REG and SWITCH_CORE address
    spaces, perform a few preparatory steps:
    
    - allow matching the compatible string against a data description
    - convert the SWITCH_REG register accesses into an indirection table
    - prepare for supporting a SWITCH_CORE register alignment requirement
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 4531c2333e86..a1430866bd79 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -61,6 +61,11 @@ struct bcm_sf2_priv {
 	void __iomem			*fcb;
 	void __iomem			*acb;
 
+	/* Register offsets indirection tables */
+	u32 				type;
+	const u16			*reg_offsets;
+	unsigned int			core_reg_align;
+
 	/* spinlock protecting access to the indirect registers */
 	spinlock_t			indir_lock;
 
@@ -104,6 +109,11 @@ static inline struct bcm_sf2_priv *bcm_sf2_to_priv(struct dsa_switch *ds)
 	return dev->priv;
 }
 
+static inline u32 bcm_sf2_mangle_addr(struct bcm_sf2_priv *priv, u32 off)
+{
+	return off << priv->core_reg_align;
+}
+
 #define SF2_IO_MACRO(name) \
 static inline u32 name##_readl(struct bcm_sf2_priv *priv, u32 off)	\
 {									\
@@ -153,8 +163,28 @@ static inline void intrl2_##which##_mask_set(struct bcm_sf2_priv *priv, \
 	priv->irq##which##_mask |= (mask);				\
 }									\
 
-SF2_IO_MACRO(core);
-SF2_IO_MACRO(reg);
+static inline u32 core_readl(struct bcm_sf2_priv *priv, u32 off)
+{
+	u32 tmp = bcm_sf2_mangle_addr(priv, off);
+	return __raw_readl(priv->core + tmp);
+}
+
+static inline void core_writel(struct bcm_sf2_priv *priv, u32 val, u32 off)
+{
+	u32 tmp = bcm_sf2_mangle_addr(priv, off);
+	__raw_writel(val, priv->core + tmp);
+}
+
+static inline u32 reg_readl(struct bcm_sf2_priv *priv, u16 off)
+{
+	return __raw_readl(priv->reg + priv->reg_offsets[off]);
+}
+
+static inline void reg_writel(struct bcm_sf2_priv *priv, u32 val, u16 off)
+{
+	__raw_writel(val, priv->reg + priv->reg_offsets[off]);
+}
+
 SF2_IO64_MACRO(core);
 SF2_IO_MACRO(intrl2_0);
 SF2_IO_MACRO(intrl2_1);

commit 329b5c58f8b2833f330d64d5a2a1517a0c1e070e
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Jan 20 12:36:28 2017 -0800

    net: dsa: bcm_sf2: Make SF2_IO64_MACRO() utilize 32-bit macro
    
    There is no point inlining the 32-bit direct register read/write part,
    just infer it from the existing macro. This will make it easier to
    centralize the address rewriting that we are going to introduce later
    on.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 44692673e1d5..4531c2333e86 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -125,7 +125,7 @@ static inline u64 name##_readq(struct bcm_sf2_priv *priv, u32 off)	\
 {									\
 	u32 indir, dir;							\
 	spin_lock(&priv->indir_lock);					\
-	dir = __raw_readl(priv->name + off);				\
+	dir = name##_readl(priv, off);					\
 	indir = reg_readl(priv, REG_DIR_DATA_READ);			\
 	spin_unlock(&priv->indir_lock);					\
 	return (u64)indir << 32 | dir;					\
@@ -135,7 +135,7 @@ static inline void name##_writeq(struct bcm_sf2_priv *priv, u64 val,	\
 {									\
 	spin_lock(&priv->indir_lock);					\
 	reg_writel(priv, upper_32_bits(val), REG_DIR_DATA_WRITE);	\
-	__raw_writel(lower_32_bits(val), priv->name + off);		\
+	name##_writel(priv, lower_32_bits(val), off);			\
 	spin_unlock(&priv->indir_lock);					\
 }
 

commit 02154927c115c7599677df57203988e05b576346
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sat Sep 10 12:39:03 2016 -0700

    net: dsa: bcm_sf2: Get VLAN_PORT_MASK from b53_device
    
    While migrating the bcm_sf2 driver to use b53_common, we left a small
    piece untouched where we kept our local copy of the per-port
    port_vlan_ctl bitmask value. This value is now maintained by b53_device
    so we need to use it instead of our local (and now stale) copy of it.
    
    Fixes: f458995b9ad8 ("net: dsa: bcm_sf2: Utilize core B53 driver when possible")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 46c4ea796574..44692673e1d5 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -50,8 +50,6 @@ struct bcm_sf2_port_status {
 	unsigned int link;
 
 	struct ethtool_eee eee;
-
-	u16 vlan_ctl_mask;
 };
 
 struct bcm_sf2_priv {

commit 04bed1434df256b07e78fa5deae848bba18a90f3
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Wed Aug 31 18:06:13 2016 -0400

    net: dsa: remove ds_to_priv
    
    Access the priv member of the dsa_switch structure directly, instead of
    having an unnecessary helper.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index afe56686b3d7..46c4ea796574 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -101,7 +101,7 @@ struct bcm_sf2_priv {
 
 static inline struct bcm_sf2_priv *bcm_sf2_to_priv(struct dsa_switch *ds)
 {
-	struct b53_device *dev = ds_to_priv(ds);
+	struct b53_device *dev = ds->priv;
 
 	return dev->priv;
 }

commit 6abdd5f5935fff978f950561f3c5175eb34dad73
Merge: 0b498a527783 e4e98c460ad3
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Aug 30 00:54:02 2016 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    All three conflicts were cases of simple overlapping
    changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit de0b9d3bad0d410c4d8a58431ba3405aaf8f10b2
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Aug 26 12:18:34 2016 -0700

    net: dsa: bcm_sf2: Remove duplicate code
    
    Now that we are using b53_common for most VLAN, FDB and bridge
    operations, delete all the redundant code that we had in bcm_sf2.c to
    keep only the integration specific logic that we have to deal with:
    power management, link management and the external interfaces (RGMII,
    MDIO).
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 7e95fb7d5d2e..c4c12d9d6956 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -51,71 +51,9 @@ struct bcm_sf2_port_status {
 
 	struct ethtool_eee eee;
 
-	u32 vlan_ctl_mask;
-	u16 pvid;
-
-	struct net_device *bridge_dev;
-};
-
-struct bcm_sf2_arl_entry {
-	u8 port;
-	u8 mac[ETH_ALEN];
-	u16 vid;
-	u8 is_valid:1;
-	u8 is_age:1;
-	u8 is_static:1;
+	u16 vlan_ctl_mask;
 };
 
-struct bcm_sf2_vlan {
-	u16 members;
-	u16 untag;
-};
-
-static inline void bcm_sf2_mac_from_u64(u64 src, u8 *dst)
-{
-	unsigned int i;
-
-	for (i = 0; i < ETH_ALEN; i++)
-		dst[ETH_ALEN - 1 - i] = (src >> (8 * i)) & 0xff;
-}
-
-static inline u64 bcm_sf2_mac_to_u64(const u8 *src)
-{
-	unsigned int i;
-	u64 dst = 0;
-
-	for (i = 0; i < ETH_ALEN; i++)
-		dst |= (u64)src[ETH_ALEN - 1 - i] << (8 * i);
-
-	return dst;
-}
-
-static inline void bcm_sf2_arl_to_entry(struct bcm_sf2_arl_entry *ent,
-					u64 mac_vid, u32 fwd_entry)
-{
-	memset(ent, 0, sizeof(*ent));
-	ent->port = fwd_entry & PORTID_MASK;
-	ent->is_valid = !!(fwd_entry & ARL_VALID);
-	ent->is_age = !!(fwd_entry & ARL_AGE);
-	ent->is_static = !!(fwd_entry & ARL_STATIC);
-	bcm_sf2_mac_from_u64(mac_vid, ent->mac);
-	ent->vid = mac_vid >> VID_SHIFT;
-}
-
-static inline void bcm_sf2_arl_from_entry(u64 *mac_vid, u32 *fwd_entry,
-					  const struct bcm_sf2_arl_entry *ent)
-{
-	*mac_vid = bcm_sf2_mac_to_u64(ent->mac);
-	*mac_vid |= (u64)(ent->vid & VID_MASK) << VID_SHIFT;
-	*fwd_entry = ent->port & PORTID_MASK;
-	if (ent->is_valid)
-		*fwd_entry |= ARL_VALID;
-	if (ent->is_static)
-		*fwd_entry |= ARL_STATIC;
-	if (ent->is_age)
-		*fwd_entry |= ARL_AGE;
-}
-
 struct bcm_sf2_priv {
 	/* Base registers, keep those in order with BCM_SF2_REGS_NAME */
 	void __iomem			*core;
@@ -159,9 +97,6 @@ struct bcm_sf2_priv {
 	struct device_node		*master_mii_dn;
 	struct mii_bus			*slave_mii_bus;
 	struct mii_bus			*master_mii_bus;
-
-	/* Cache of programmed VLANs */
-	struct bcm_sf2_vlan		vlans[VLAN_N_VID];
 };
 
 static inline struct bcm_sf2_priv *bcm_sf2_to_priv(struct dsa_switch *ds)
@@ -171,12 +106,6 @@ static inline struct bcm_sf2_priv *bcm_sf2_to_priv(struct dsa_switch *ds)
 	return dev->priv;
 }
 
-struct bcm_sf2_hw_stats {
-	const char	*string;
-	u16		reg;
-	u8		sizeof_stat;
-};
-
 #define SF2_IO_MACRO(name) \
 static inline u32 name##_readl(struct bcm_sf2_priv *priv, u32 off)	\
 {									\

commit f458995b9ad831866ab9ffaa76ed0320315a91d9
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Aug 26 12:18:33 2016 -0700

    net: dsa: bcm_sf2: Utilize core B53 driver when possible
    
    The Broadcom Starfighter2 is almost entirely register compatible with
    B53, yet for historical reasons came up first in the tree and is now
    being updated to utilize b53_common.c to the fullest extent possible. A
    few things need to be adjusted to allow that:
    
    - the switch "core" registers currently operate on a 32-bit address,
      whereas b53 passes a page + reg pair to offset from, so we need to
      convert that, thankfully there is a generic formula to do that
    
    - the link managemenent is not self contained with the B53/CORE register
      set, but instead is in the SWITCH_REG block which is part of the
      integration glue logic, so we keep that entirely custom here because
      this really is part of the existing bcm_sf2 implementation
    
    - there are additional power management constraints on the port's
      memories that make us keep the port_enable/disable callbacks custom
      for now, also, we support tagging whereas b53_common does not support
      that yet
    
    All the VLAN and bridge code is entirely identical though so, avoid
    duplicating it. Other things will be migrated in the future like EEE and
    possibly Wake-on-LAN.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 463bed8cbe4c..7e95fb7d5d2e 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -26,6 +26,7 @@
 #include <net/dsa.h>
 
 #include "bcm_sf2_regs.h"
+#include "b53/b53_priv.h"
 
 struct bcm_sf2_hw_params {
 	u16	top_rev;
@@ -134,6 +135,9 @@ struct bcm_sf2_priv {
 	u32				irq1_stat;
 	u32				irq1_mask;
 
+	/* Backing b53_device */
+	struct b53_device		*dev;
+
 	/* Mutex protecting access to the MIB counters */
 	struct mutex			stats_mutex;
 
@@ -160,6 +164,13 @@ struct bcm_sf2_priv {
 	struct bcm_sf2_vlan		vlans[VLAN_N_VID];
 };
 
+static inline struct bcm_sf2_priv *bcm_sf2_to_priv(struct dsa_switch *ds)
+{
+	struct b53_device *dev = ds_to_priv(ds);
+
+	return dev->priv;
+}
+
 struct bcm_sf2_hw_stats {
 	const char	*string;
 	u16		reg;

commit 4f101c47791cdcb831b3ef1f831b1cc51e4fe03c
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed Aug 24 11:01:20 2016 -0700

    net: dsa: bcm_sf2: Fix race condition while unmasking interrupts
    
    We kept shadow copies of which interrupt sources we have enabled and
    disabled, but due to an order bug in how intrl2_mask_clear was defined,
    we could run into the following scenario:
    
    CPU0                                    CPU1
    intrl2_1_mask_clear(..)
    sets INTRL2_CPU_MASK_CLEAR
                                            bcm_sf2_switch_1_isr
                                            read INTRL2_CPU_STATUS and masks with stale
                                            irq1_mask value
    updates irq1_mask value
    
    Which would make us loop again and again trying to process and interrupt
    we are not clearing since our copy of whether it was enabled before
    still indicates it was not. Fix this by updating the shadow copy first,
    and then unasking at the HW level.
    
    Fixes: 246d7f773c13 ("net: dsa: add Broadcom SF2 switch driver")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 463bed8cbe4c..dd446e466699 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -205,8 +205,8 @@ static inline void name##_writeq(struct bcm_sf2_priv *priv, u64 val,	\
 static inline void intrl2_##which##_mask_clear(struct bcm_sf2_priv *priv, \
 						u32 mask)		\
 {									\
-	intrl2_##which##_writel(priv, mask, INTRL2_CPU_MASK_CLEAR);	\
 	priv->irq##which##_mask &= ~(mask);				\
+	intrl2_##which##_writel(priv, mask, INTRL2_CPU_MASK_CLEAR);	\
 }									\
 static inline void intrl2_##which##_mask_set(struct bcm_sf2_priv *priv, \
 						u32 mask)		\

commit 9c57a77182c89e1bf773008f904f4a2e9ea30bd5
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu Jun 9 17:42:08 2016 -0700

    net: dsa: bcm_sf2: Add VLAN support
    
    Add support for configuring VLANs on the Broadcom Starfigther2 switch.
    This is all done through the bridge vlan facility just like other DSA
    drivers.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index bde11ebb2742..463bed8cbe4c 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -21,6 +21,7 @@
 #include <linux/ethtool.h>
 #include <linux/types.h>
 #include <linux/bitops.h>
+#include <linux/if_vlan.h>
 
 #include <net/dsa.h>
 
@@ -50,6 +51,7 @@ struct bcm_sf2_port_status {
 	struct ethtool_eee eee;
 
 	u32 vlan_ctl_mask;
+	u16 pvid;
 
 	struct net_device *bridge_dev;
 };
@@ -63,6 +65,11 @@ struct bcm_sf2_arl_entry {
 	u8 is_static:1;
 };
 
+struct bcm_sf2_vlan {
+	u16 members;
+	u16 untag;
+};
+
 static inline void bcm_sf2_mac_from_u64(u64 src, u8 *dst)
 {
 	unsigned int i;
@@ -148,6 +155,9 @@ struct bcm_sf2_priv {
 	struct device_node		*master_mii_dn;
 	struct mii_bus			*slave_mii_bus;
 	struct mii_bus			*master_mii_bus;
+
+	/* Cache of programmed VLANs */
+	struct bcm_sf2_vlan		vlans[VLAN_N_VID];
 };
 
 struct bcm_sf2_hw_stats {

commit 461cd1b03e321e9c4ed1b831c80965c69a7b761b
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Jun 7 16:32:43 2016 -0700

    net: dsa: bcm_sf2: Register our slave MDIO bus
    
    Register a slave MDIO bus which allows us to divert problematic
    read/writes towards conflicting pseudo-PHY address (30). Do no longer
    rely on DSA's slave_mii_bus, but instead provide our own implementation
    which offers more flexibility as to what to do, and when to register it.
    
    We need to register it by the time we are able to get access to our
    memory mapped registers, which is not until drv->setup() time. In order
    to avoid forward declarations, we need to re-order the function bodies a
    bit.
    
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 200b1f5fdb56..bde11ebb2742 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -142,6 +142,12 @@ struct bcm_sf2_priv {
 
 	/* Bitmask of ports having an integrated PHY */
 	unsigned int			int_phy_mask;
+
+	/* Master and slave MDIO bus controller */
+	unsigned int			indir_phy_mask;
+	struct device_node		*master_mii_dn;
+	struct mii_bus			*slave_mii_bus;
+	struct mii_bus			*master_mii_bus;
 };
 
 struct bcm_sf2_hw_stats {

commit a6692754d61a6b3735803783f394880805675f99
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Feb 12 12:09:39 2016 -0500

    net: dsa: pass bridge down to drivers
    
    Some DSA drivers may or may not support multiple software bridges on top
    of an hardware switch.
    
    It is more convenient for them to access the bridge's net_device for
    finer configuration.
    
    Removing the need to craft and access a bitmask also simplifies the
    code.
    
    This patch changes the signature of bridge related functions, update DSA
    drivers, and removes dsa_slave_br_port_mask.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Tested-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 6bba1c98d764..200b1f5fdb56 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -50,6 +50,8 @@ struct bcm_sf2_port_status {
 	struct ethtool_eee eee;
 
 	u32 vlan_ctl_mask;
+
+	struct net_device *bridge_dev;
 };
 
 struct bcm_sf2_arl_entry {

commit 8b7c94e3478dbb0296293b43a974c3561d01e9fb
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Oct 23 12:11:08 2015 -0700

    net: dsa: bcm_sf2: Unhardcode port numbers
    
    While the current driver mostly supports BCM7445 which has a hardcoded
    location for its MoCA port on port 7 and port 0 for its internal PHY,
    this is not necessarily true for all other chips out there such as
    BCM3390 for instance.
    
    Walk the list of ports from Device Tree, get their port number ("reg"
    property), and then parse the "phy-mode" property and initialize two
    internal variables: moca_port and a bitmask of internal PHYs. Since we
    use interrupts for the MoCA port, we introduce two helper functions to
    enable/disable interrupts and do this at the appropriate bank (INTRL2_0
    or INTRL2_1).
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index cc98abc0aaf3..6bba1c98d764 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -134,6 +134,12 @@ struct bcm_sf2_priv {
 
 	/* Mask of ports enabled for Wake-on-LAN */
 	u32				wol_ports_mask;
+
+	/* MoCA port location */
+	int				moca_port;
+
+	/* Bitmask of ports having an integrated PHY */
+	unsigned int			int_phy_mask;
 };
 
 struct bcm_sf2_hw_stats {

commit 680060d3e02d175516832e9af058ffe96ecc4cdc
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Oct 23 11:38:07 2015 -0700

    net: dsa: bcm_sf2: Implement FDB operations
    
    Add support for the FDB add, delete, and dump operations. The add and
    delete operations are implemented using directed ARL operations using
    the specified MAC address and consist in a read operation, write and
    readback operation.
    
    The dump operation consists in using the ARL search and software
    filtering entries which are not for the desired port.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 789d7b7737da..cc98abc0aaf3 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -19,6 +19,8 @@
 #include <linux/mutex.h>
 #include <linux/mii.h>
 #include <linux/ethtool.h>
+#include <linux/types.h>
+#include <linux/bitops.h>
 
 #include <net/dsa.h>
 
@@ -50,6 +52,60 @@ struct bcm_sf2_port_status {
 	u32 vlan_ctl_mask;
 };
 
+struct bcm_sf2_arl_entry {
+	u8 port;
+	u8 mac[ETH_ALEN];
+	u16 vid;
+	u8 is_valid:1;
+	u8 is_age:1;
+	u8 is_static:1;
+};
+
+static inline void bcm_sf2_mac_from_u64(u64 src, u8 *dst)
+{
+	unsigned int i;
+
+	for (i = 0; i < ETH_ALEN; i++)
+		dst[ETH_ALEN - 1 - i] = (src >> (8 * i)) & 0xff;
+}
+
+static inline u64 bcm_sf2_mac_to_u64(const u8 *src)
+{
+	unsigned int i;
+	u64 dst = 0;
+
+	for (i = 0; i < ETH_ALEN; i++)
+		dst |= (u64)src[ETH_ALEN - 1 - i] << (8 * i);
+
+	return dst;
+}
+
+static inline void bcm_sf2_arl_to_entry(struct bcm_sf2_arl_entry *ent,
+					u64 mac_vid, u32 fwd_entry)
+{
+	memset(ent, 0, sizeof(*ent));
+	ent->port = fwd_entry & PORTID_MASK;
+	ent->is_valid = !!(fwd_entry & ARL_VALID);
+	ent->is_age = !!(fwd_entry & ARL_AGE);
+	ent->is_static = !!(fwd_entry & ARL_STATIC);
+	bcm_sf2_mac_from_u64(mac_vid, ent->mac);
+	ent->vid = mac_vid >> VID_SHIFT;
+}
+
+static inline void bcm_sf2_arl_from_entry(u64 *mac_vid, u32 *fwd_entry,
+					  const struct bcm_sf2_arl_entry *ent)
+{
+	*mac_vid = bcm_sf2_mac_to_u64(ent->mac);
+	*mac_vid |= (u64)(ent->vid & VID_MASK) << VID_SHIFT;
+	*fwd_entry = ent->port & PORTID_MASK;
+	if (ent->is_valid)
+		*fwd_entry |= ARL_VALID;
+	if (ent->is_static)
+		*fwd_entry |= ARL_STATIC;
+	if (ent->is_age)
+		*fwd_entry |= ARL_AGE;
+}
+
 struct bcm_sf2_priv {
 	/* Base registers, keep those in order with BCM_SF2_REGS_NAME */
 	void __iomem			*core;

commit 03679a14739a0d4c14b52ba65a69ff553bfba73b
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Sep 8 20:06:41 2015 -0700

    net: dsa: bcm_sf2: Fix 64-bits register writes
    
    The macro to write 64-bits quantities to the 32-bits register swapped
    the value and offsets arguments, we want to preserve the ordering of the
    arguments with respect to how writel() is implemented for instance:
    value first, offset/base second.
    
    Fixes: 246d7f773c13 ("net: dsa: add Broadcom SF2 switch driver")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 22e2ebf31333..789d7b7737da 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -112,8 +112,8 @@ static inline u64 name##_readq(struct bcm_sf2_priv *priv, u32 off)	\
 	spin_unlock(&priv->indir_lock);					\
 	return (u64)indir << 32 | dir;					\
 }									\
-static inline void name##_writeq(struct bcm_sf2_priv *priv, u32 off,	\
-							u64 val)	\
+static inline void name##_writeq(struct bcm_sf2_priv *priv, u64 val,	\
+							u32 off)	\
 {									\
 	spin_lock(&priv->indir_lock);					\
 	reg_writel(priv, upper_32_bits(val), REG_DIR_DATA_WRITE);	\

commit 71a83a6db6138b9d41d8a0b6b91cb59f6dc4742c
Merge: b97526f3ff95 a6c5170d1ede
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Mar 3 21:16:48 2015 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            drivers/net/ethernet/rocker/rocker.c
    
    The rocker commit was two overlapping changes, one to rename
    the ->vport member to ->pport, and another making the bitmask
    expression use '1ULL' instead of plain '1'.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 12f460f23423e81d6dd3efeb78906ae634ad8fc9
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Feb 24 13:15:34 2015 -0800

    net: dsa: bcm_sf2: add HW bridging support
    
    Implement the bridge join, leave and set_stp callbacks by making that
    we do the following:
    
    - when a port joins the bridge, all existing ports in the bridge get
      their VLAN control register updated with that joining port
    - the joining port is including all existing bridge ports in its own
      VLAN control register
    
    The leave operation is fairly similar, special care must be taken to
    make sure that port leaving the bridging is not removing itself from its
    own VLAN control register.
    
    Since the various BR_* states apply directly to our HW semantics, we
    just need to translate these constants into their corresponding HW
    settings, and voila!
    
    We make sure to trigger a fast-ageing process for ports that are
    joining/leaving the bridge and transition from incompatible states, this
    is equivalent to triggering an ARL flush for that port.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index ee9f650d5026..0f217e99904f 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -46,6 +46,8 @@ struct bcm_sf2_port_status {
 	unsigned int link;
 
 	struct ethtool_eee eee;
+
+	u32 vlan_ctl_mask;
 };
 
 struct bcm_sf2_priv {

commit ddede6d536d70c4ef2193ca14208db90740fcd22
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu Feb 19 11:09:27 2015 -0800

    net: dsa: bcm_sf2: fix 64-bits register reads
    
    Reading 64-bits register was not working because we inverted the steps
    between reading the lower 32-bits of the register and reading the upper
    32-bits. Swapping these operations is how the HW guarantees that 64-bits
    reads are latched correctly. We only have a handful of 64-bits registers
    for now, mostly MIB counters, so the imapct is low.
    
    Fixes: 246d7f773c13 ("net: dsa: add Broadcom SF2 switch driver")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index ee9f650d5026..7b7053d3c5fa 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -105,8 +105,8 @@ static inline u64 name##_readq(struct bcm_sf2_priv *priv, u32 off)	\
 {									\
 	u32 indir, dir;							\
 	spin_lock(&priv->indir_lock);					\
-	indir = reg_readl(priv, REG_DIR_DATA_READ);			\
 	dir = __raw_readl(priv->name + off);				\
+	indir = reg_readl(priv, REG_DIR_DATA_READ);			\
 	spin_unlock(&priv->indir_lock);					\
 	return (u64)indir << 32 | dir;					\
 }									\

commit 450b05c15f9c776996f9627c7b4f1d38b6e6f4a0
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed Sep 24 17:05:22 2014 -0700

    net: dsa: bcm_sf2: add support for controlling EEE
    
    When EEE is enabled, negotiate this feature with the PHY and make sure
    that the capability checking, local EEE advertisement, link partner EEE
    advertisement and auto-negotiation resolution returned by phy_init_eee()
    is positive, and enable EEE at the switch level.
    
    While querying the current EEE settings, verify the low-power indication
    and indicate its status.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 8fd6c1451a84..ee9f650d5026 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -18,6 +18,7 @@
 #include <linux/spinlock.h>
 #include <linux/mutex.h>
 #include <linux/mii.h>
+#include <linux/ethtool.h>
 
 #include <net/dsa.h>
 
@@ -43,6 +44,8 @@ struct bcm_sf2_hw_params {
 
 struct bcm_sf2_port_status {
 	unsigned int link;
+
+	struct ethtool_eee eee;
 };
 
 struct bcm_sf2_priv {

commit 96e65d7f3f88d6e117ff80f3003d13c65e85cb03
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu Sep 18 17:31:25 2014 -0700

    net: dsa: bcm_sf2: add support for Wake-on-LAN
    
    In order for Wake-on-LAN to work properly, we query the parent network
    device Wake-on-LAN features and advertise those. Similarly, when
    configuring Wake-on-LAN on a per-port network interface, we make sure
    that we do not accept something the master network devices does not
    support.
    
    Finally, we need to maintain a bitmask of the ports enabled for
    Wake-on-LAN to prevent the suspend() callback from disabling a port that
    is used for waking up the system.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index d3bd52dc40d2..8fd6c1451a84 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -70,6 +70,9 @@ struct bcm_sf2_priv {
 	struct bcm_sf2_hw_params	hw_params;
 
 	struct bcm_sf2_port_status	port_sts[DSA_MAX_PORTS];
+
+	/* Mask of ports enabled for Wake-on-LAN */
+	u32				wol_ports_mask;
 };
 
 struct bcm_sf2_hw_stats {

commit aa9aef77c76113725d9dbf124c4dab414326b0a3
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Sep 19 13:07:55 2014 -0700

    net: dsa: bcm_sf2: communicate integrated PHY revision to PHY driver
    
    The integrated BCM7xxx PHY contains no useful revision information
    in its MII_PHYSID2 bits 3:0, that information is instead contained in
    the SWITCH_REG_PHY_REVISION register.
    
    Read this register, store its value, and return it by implementing the
    dsa_switch::get_phy_flags() callback accordingly. The register layout is
    already matching what the BCM7xxx PHY driver is expecting to find.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
index 260bab313e58..d3bd52dc40d2 100644
--- a/drivers/net/dsa/bcm_sf2.h
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -26,6 +26,7 @@
 struct bcm_sf2_hw_params {
 	u16	top_rev;
 	u16	core_rev;
+	u16	gphy_rev;
 	u32	num_gphy;
 	u8	num_acb_queue;
 	u8	num_rgmii;

commit 246d7f773c13cac3e3ab1609fd4ffee520242c63
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed Aug 27 17:04:56 2014 -0700

    net: dsa: add Broadcom SF2 switch driver
    
    Add support for the Broadcom Starfigther 2 switch chip using a DSA
    driver. This switch driver supports the following features:
    
    - configuration of the external switch port interface: MII, RevMII,
      RGMII and RGMII_NO_ID are supported
    - support for the per-port MIB counters
    - support for link interrupts for special ports (e.g: MoCA)
    - powering up/down of switch memories to conserve power when ports are
      unused
    
    Finally, update the compatible property for the DSA core code to match
    our switch top-level compatible node.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h
new file mode 100644
index 000000000000..260bab313e58
--- /dev/null
+++ b/drivers/net/dsa/bcm_sf2.h
@@ -0,0 +1,140 @@
+/*
+ * Broadcom Starfighter2 private context
+ *
+ * Copyright (C) 2014, Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __BCM_SF2_H
+#define __BCM_SF2_H
+
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/spinlock.h>
+#include <linux/mutex.h>
+#include <linux/mii.h>
+
+#include <net/dsa.h>
+
+#include "bcm_sf2_regs.h"
+
+struct bcm_sf2_hw_params {
+	u16	top_rev;
+	u16	core_rev;
+	u32	num_gphy;
+	u8	num_acb_queue;
+	u8	num_rgmii;
+	u8	num_ports;
+	u8	fcb_pause_override:1;
+	u8	acb_packets_inflight:1;
+};
+
+#define BCM_SF2_REGS_NAME {\
+	"core", "reg", "intrl2_0", "intrl2_1", "fcb", "acb" \
+}
+
+#define BCM_SF2_REGS_NUM	6
+
+struct bcm_sf2_port_status {
+	unsigned int link;
+};
+
+struct bcm_sf2_priv {
+	/* Base registers, keep those in order with BCM_SF2_REGS_NAME */
+	void __iomem			*core;
+	void __iomem			*reg;
+	void __iomem			*intrl2_0;
+	void __iomem			*intrl2_1;
+	void __iomem			*fcb;
+	void __iomem			*acb;
+
+	/* spinlock protecting access to the indirect registers */
+	spinlock_t			indir_lock;
+
+	int				irq0;
+	int				irq1;
+	u32				irq0_stat;
+	u32				irq0_mask;
+	u32				irq1_stat;
+	u32				irq1_mask;
+
+	/* Mutex protecting access to the MIB counters */
+	struct mutex			stats_mutex;
+
+	struct bcm_sf2_hw_params	hw_params;
+
+	struct bcm_sf2_port_status	port_sts[DSA_MAX_PORTS];
+};
+
+struct bcm_sf2_hw_stats {
+	const char	*string;
+	u16		reg;
+	u8		sizeof_stat;
+};
+
+#define SF2_IO_MACRO(name) \
+static inline u32 name##_readl(struct bcm_sf2_priv *priv, u32 off)	\
+{									\
+	return __raw_readl(priv->name + off);				\
+}									\
+static inline void name##_writel(struct bcm_sf2_priv *priv,		\
+				  u32 val, u32 off)			\
+{									\
+	__raw_writel(val, priv->name + off);				\
+}									\
+
+/* Accesses to 64-bits register requires us to latch the hi/lo pairs
+ * using the REG_DIR_DATA_{READ,WRITE} ancillary registers. The 'indir_lock'
+ * spinlock is automatically grabbed and released to provide relative
+ * atomiticy with latched reads/writes.
+ */
+#define SF2_IO64_MACRO(name) \
+static inline u64 name##_readq(struct bcm_sf2_priv *priv, u32 off)	\
+{									\
+	u32 indir, dir;							\
+	spin_lock(&priv->indir_lock);					\
+	indir = reg_readl(priv, REG_DIR_DATA_READ);			\
+	dir = __raw_readl(priv->name + off);				\
+	spin_unlock(&priv->indir_lock);					\
+	return (u64)indir << 32 | dir;					\
+}									\
+static inline void name##_writeq(struct bcm_sf2_priv *priv, u32 off,	\
+							u64 val)	\
+{									\
+	spin_lock(&priv->indir_lock);					\
+	reg_writel(priv, upper_32_bits(val), REG_DIR_DATA_WRITE);	\
+	__raw_writel(lower_32_bits(val), priv->name + off);		\
+	spin_unlock(&priv->indir_lock);					\
+}
+
+#define SWITCH_INTR_L2(which)						\
+static inline void intrl2_##which##_mask_clear(struct bcm_sf2_priv *priv, \
+						u32 mask)		\
+{									\
+	intrl2_##which##_writel(priv, mask, INTRL2_CPU_MASK_CLEAR);	\
+	priv->irq##which##_mask &= ~(mask);				\
+}									\
+static inline void intrl2_##which##_mask_set(struct bcm_sf2_priv *priv, \
+						u32 mask)		\
+{									\
+	intrl2_## which##_writel(priv, mask, INTRL2_CPU_MASK_SET);	\
+	priv->irq##which##_mask |= (mask);				\
+}									\
+
+SF2_IO_MACRO(core);
+SF2_IO_MACRO(reg);
+SF2_IO64_MACRO(core);
+SF2_IO_MACRO(intrl2_0);
+SF2_IO_MACRO(intrl2_1);
+SF2_IO_MACRO(fcb);
+SF2_IO_MACRO(acb);
+
+SWITCH_INTR_L2(0);
+SWITCH_INTR_L2(1);
+
+#endif /* __BCM_SF2_H */
