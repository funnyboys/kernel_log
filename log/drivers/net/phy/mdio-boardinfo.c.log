commit a2443fd1a54d6ae787157794a2920dd61f50f7f1
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Mon Jan 21 19:05:50 2019 +0100

    net: phy: Convert some PHY and MDIO driver files to SPDX headers
    
    Where the license text and the MODULE_LICENSE() value agree, convert
    to using an SPDX header, removing the license text.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/phy/mdio-boardinfo.c b/drivers/net/phy/mdio-boardinfo.c
index 863496fa5d13..d9b54c67ef9f 100644
--- a/drivers/net/phy/mdio-boardinfo.c
+++ b/drivers/net/phy/mdio-boardinfo.c
@@ -1,10 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * mdio-boardinfo - Collect pre-declarations for MDIO devices
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
  */
 
 #include <linux/kernel.h>

commit 0263ea5cddedd84c111b55d33a8ec94740d1c8d3
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Thu Apr 19 02:00:47 2018 +0200

    net: phy: mdio-boardinfo: Allow recursive mdiobus_register()
    
    mdiobus_register will search for any mdiobus board info registered for
    the bus being registered. If found, it will probe devices on the bus.
    That device, if for example it is an ethernet switch, may then try to
    register an mdio bus. Thus we need to allow recursive calls to
    mdiobus_register.
    
    Holding the mdio_board_lock will cause a deadlock during this
    recursion. Release the lock and use list_for_each_entry_safe.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/phy/mdio-boardinfo.c b/drivers/net/phy/mdio-boardinfo.c
index 1861f387820d..863496fa5d13 100644
--- a/drivers/net/phy/mdio-boardinfo.c
+++ b/drivers/net/phy/mdio-boardinfo.c
@@ -30,17 +30,20 @@ void mdiobus_setup_mdiodev_from_board_info(struct mii_bus *bus,
 					    struct mdio_board_info *bi))
 {
 	struct mdio_board_entry *be;
+	struct mdio_board_entry *tmp;
 	struct mdio_board_info *bi;
 	int ret;
 
 	mutex_lock(&mdio_board_lock);
-	list_for_each_entry(be, &mdio_board_list, list) {
+	list_for_each_entry_safe(be, tmp, &mdio_board_list, list) {
 		bi = &be->board_info;
 
 		if (strcmp(bus->id, bi->bus_id))
 			continue;
 
+		mutex_unlock(&mdio_board_lock);
 		ret = cb(bus, bi);
+		mutex_lock(&mdio_board_lock);
 		if (ret)
 			continue;
 

commit d0281a56b00c63ad51ebb550fba0351807475c47
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Mar 28 12:57:09 2017 -0700

    net: phy: Allow building mdio-boardinfo into the kernel
    
    mdio-boardinfo contains code that is helpful for platforms to register
    specific MDIO bus devices independent of how CONFIG_MDIO_DEVICE or
    CONFIG_PHYLIB will be selected (modular or built-in). In order to make
    that possible, let's do the following:
    
    - descend into drivers/net/phy/ unconditionally
    
    - make mdiobus_setup_mdiodev_from_board_info() take a callback argument
      which allows us not to expose the internal MDIO board info list and
      mutex, yet maintain the logic within the same file
    
    - relocate the code that creates a MDIO device into
      drivers/net/phy/mdio_bus.c
    
    - build mdio-boardinfo.o into the kernel as soon as MDIO_DEVICE is
      defined (y or m)
    
    Fixes: 90eff9096c01 ("net: phy: Allow splitting MDIO bus/device support from PHYs")
    Fixes: 648ea0134069 ("net: phy: Allow pre-declaration of MDIO devices")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Tested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/phy/mdio-boardinfo.c b/drivers/net/phy/mdio-boardinfo.c
index 61941e29daae..1861f387820d 100644
--- a/drivers/net/phy/mdio-boardinfo.c
+++ b/drivers/net/phy/mdio-boardinfo.c
@@ -24,10 +24,12 @@ static DEFINE_MUTEX(mdio_board_lock);
  * @mdiodev: MDIO device pointer
  * Context: can sleep
  */
-void mdiobus_setup_mdiodev_from_board_info(struct mii_bus *bus)
+void mdiobus_setup_mdiodev_from_board_info(struct mii_bus *bus,
+					   int (*cb)
+					   (struct mii_bus *bus,
+					    struct mdio_board_info *bi))
 {
 	struct mdio_board_entry *be;
-	struct mdio_device *mdiodev;
 	struct mdio_board_info *bi;
 	int ret;
 
@@ -38,23 +40,14 @@ void mdiobus_setup_mdiodev_from_board_info(struct mii_bus *bus)
 		if (strcmp(bus->id, bi->bus_id))
 			continue;
 
-		mdiodev = mdio_device_create(bus, bi->mdio_addr);
-		if (IS_ERR(mdiodev))
+		ret = cb(bus, bi);
+		if (ret)
 			continue;
 
-		strncpy(mdiodev->modalias, bi->modalias,
-			sizeof(mdiodev->modalias));
-		mdiodev->bus_match = mdio_device_bus_match;
-		mdiodev->dev.platform_data = (void *)bi->platform_data;
-
-		ret = mdio_device_register(mdiodev);
-		if (ret) {
-			mdio_device_free(mdiodev);
-			continue;
-		}
 	}
 	mutex_unlock(&mdio_board_lock);
 }
+EXPORT_SYMBOL(mdiobus_setup_mdiodev_from_board_info);
 
 /**
  * mdio_register_board_info - register MDIO devices for a given board

commit 90eff9096c01ba90cdae504a6b95ee87fe2556a3
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu Mar 23 10:01:19 2017 -0700

    net: phy: Allow splitting MDIO bus/device support from PHYs
    
    Introduce a new configuration symbol: MDIO_DEVICE which allows building
    the MDIO devices and bus code, without pulling in the entire Ethernet
    PHY library and devices code.
    
    PHYLIB nows select MDIO_DEVICE and the relevant Makefile files are
    updated to reflect that.
    
    When MDIO_DEVICE (MDIO bus/device only) is selected, but not PHYLIB, we
    have mdio-bus.ko as a loadable module, and it does not have a
    module_exit() function because the safety of removing a bus class is
    unclear.
    
    When both MDIO_DEVICE and PHYLIB are enabled, we need to assemble
    everything into a common loadable module: libphy.ko because of nasty
    circular dependencies between phy.c, phy_device.c and mdio_bus.c which
    are really tough to untangle.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/phy/mdio-boardinfo.c b/drivers/net/phy/mdio-boardinfo.c
index 6b988f77da08..61941e29daae 100644
--- a/drivers/net/phy/mdio-boardinfo.c
+++ b/drivers/net/phy/mdio-boardinfo.c
@@ -84,3 +84,4 @@ int mdiobus_register_board_info(const struct mdio_board_info *info,
 
 	return 0;
 }
+EXPORT_SYMBOL(mdiobus_register_board_info);

commit 648ea0134069cda7d4940f397bcc6901fb88752a
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sat Feb 4 13:02:44 2017 -0800

    net: phy: Allow pre-declaration of MDIO devices
    
    Allow board support code to collect pre-declarations for MDIO devices by
    registering them with mdiobus_register_board_info(). SPI and I2C buses
    have a similar feature, we were missing this for MDIO devices, but this
    is particularly useful for e.g: MDIO-connected switches which need to
    provide their port layout (often board-specific) to a MDIO Ethernet
    switch driver.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/phy/mdio-boardinfo.c b/drivers/net/phy/mdio-boardinfo.c
new file mode 100644
index 000000000000..6b988f77da08
--- /dev/null
+++ b/drivers/net/phy/mdio-boardinfo.c
@@ -0,0 +1,86 @@
+/*
+ * mdio-boardinfo - Collect pre-declarations for MDIO devices
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/export.h>
+#include <linux/mutex.h>
+#include <linux/list.h>
+
+#include "mdio-boardinfo.h"
+
+static LIST_HEAD(mdio_board_list);
+static DEFINE_MUTEX(mdio_board_lock);
+
+/**
+ * mdiobus_setup_mdiodev_from_board_info - create and setup MDIO devices
+ * from pre-collected board specific MDIO information
+ * @mdiodev: MDIO device pointer
+ * Context: can sleep
+ */
+void mdiobus_setup_mdiodev_from_board_info(struct mii_bus *bus)
+{
+	struct mdio_board_entry *be;
+	struct mdio_device *mdiodev;
+	struct mdio_board_info *bi;
+	int ret;
+
+	mutex_lock(&mdio_board_lock);
+	list_for_each_entry(be, &mdio_board_list, list) {
+		bi = &be->board_info;
+
+		if (strcmp(bus->id, bi->bus_id))
+			continue;
+
+		mdiodev = mdio_device_create(bus, bi->mdio_addr);
+		if (IS_ERR(mdiodev))
+			continue;
+
+		strncpy(mdiodev->modalias, bi->modalias,
+			sizeof(mdiodev->modalias));
+		mdiodev->bus_match = mdio_device_bus_match;
+		mdiodev->dev.platform_data = (void *)bi->platform_data;
+
+		ret = mdio_device_register(mdiodev);
+		if (ret) {
+			mdio_device_free(mdiodev);
+			continue;
+		}
+	}
+	mutex_unlock(&mdio_board_lock);
+}
+
+/**
+ * mdio_register_board_info - register MDIO devices for a given board
+ * @info: array of devices descriptors
+ * @n: number of descriptors provided
+ * Context: can sleep
+ *
+ * The board info passed can be marked with __initdata but be pointers
+ * such as platform_data etc. are copied as-is
+ */
+int mdiobus_register_board_info(const struct mdio_board_info *info,
+				unsigned int n)
+{
+	struct mdio_board_entry *be;
+	unsigned int i;
+
+	be = kcalloc(n, sizeof(*be), GFP_KERNEL);
+	if (!be)
+		return -ENOMEM;
+
+	for (i = 0; i < n; i++, be++, info++) {
+		memcpy(&be->board_info, info, sizeof(*info));
+		mutex_lock(&mdio_board_lock);
+		list_add_tail(&be->list, &mdio_board_list);
+		mutex_unlock(&mdio_board_lock);
+	}
+
+	return 0;
+}
