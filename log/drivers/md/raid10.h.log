commit 358369f03ac94637c9fd9d8f94a2dfde86b9f25f
Author: Gustavo A. R. Silva <gustavoars@kernel.org>
Date:   Thu May 7 14:22:10 2020 -0500

    md/raid1: Replace zero-length array with flexible-array
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    sizeof(flexible-array-member) triggers a warning because flexible array
    members have incomplete type[1]. There are some instances of code in
    which the sizeof operator is being incorrectly/erroneously applied to
    zero-length arrays and the result is zero. Such instances may be hiding
    some bugs. So, this work (flexible-array member conversions) will also
    help to get completely rid of those sorts of issues.
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavoars@kernel.org>
    Signed-off-by: Song Liu <songliubraving@fb.com>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index d3eaaf3eb1bc..79cd2b7d3128 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -153,7 +153,7 @@ struct r10bio {
 		};
 		sector_t	addr;
 		int		devnum;
-	} devs[0];
+	} devs[];
 };
 
 /* bits for r10bio.state */

commit afeee514ce7f4cab605beedd03be71ebaf0c5fc8
Author: Kent Overstreet <kent.overstreet@gmail.com>
Date:   Sun May 20 18:25:52 2018 -0400

    md: convert to bioset_init()/mempool_init()
    
    Convert md to embedded bio sets.
    
    Signed-off-by: Kent Overstreet <kent.overstreet@gmail.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index e2e8840de9bf..d3eaaf3eb1bc 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -93,10 +93,10 @@ struct r10conf {
 						   */
 	wait_queue_head_t	wait_barrier;
 
-	mempool_t		*r10bio_pool;
-	mempool_t		*r10buf_pool;
+	mempool_t		r10bio_pool;
+	mempool_t		r10buf_pool;
 	struct page		*tmppage;
-	struct bio_set		*bio_split;
+	struct bio_set		bio_split;
 
 	/* When taking over an array from a different personality, we store
 	 * the new thread here until we fully activate the array.

commit f2785b527cda46314805123ddcbc871655b7c4c4
Author: NeilBrown <neilb@suse.com>
Date:   Sat Feb 3 09:19:30 2018 +1100

    md: document lifetime of internal rdev pointer.
    
    The rdev pointer kept in the local 'config' for each for
    raid1, raid10, raid4/5/6 has non-obvious lifetime rules.
    Sometimes RCU is needed, sometimes a lock, something nothing.
    
    Add documentation to explain this.
    
    Signed-off-by: NeilBrown <neilb@suse.com>
    Signed-off-by: Shaohua Li <sh.li@alibaba-inc.com>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index db2ac22ac1b4..e2e8840de9bf 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -2,6 +2,19 @@
 #ifndef _RAID10_H
 #define _RAID10_H
 
+/* Note: raid10_info.rdev can be set to NULL asynchronously by
+ * raid10_remove_disk.
+ * There are three safe ways to access raid10_info.rdev.
+ * 1/ when holding mddev->reconfig_mutex
+ * 2/ when resync/recovery/reshape is known to be happening - i.e. in code
+ *    that is called as part of performing resync/recovery/reshape.
+ * 3/ while holding rcu_read_lock(), use rcu_dereference to get the pointer
+ *    and if it is non-NULL, increment rdev->nr_pending before dropping the
+ *    RCU lock.
+ * When .rdev is set to NULL, the nr_pending count checked again and if it has
+ * been incremented, the pointer is put back in .rdev.
+ */
+
 struct raid10_info {
 	struct md_rdev	*rdev, *replacement;
 	sector_t	head_position;

commit 47f521ba18190e4bfbb65ead3977af5756884427
Merge: b91593fa8531 0868b99c214a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 14 16:07:26 2017 -0800

    Merge branch 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/shli/md
    
    Pull MD update from Shaohua Li:
     "This update mostly includes bug fixes:
    
       - md-cluster now supports raid10 from Guoqing
    
       - raid5 PPL fixes from Artur
    
       - badblock regression fix from Bo
    
       - suspend hang related fixes from Neil
    
       - raid5 reshape fixes from Neil
    
       - raid1 freeze deadlock fix from Nate
    
       - memleak fixes from Zdenek
    
       - bitmap related fixes from Me and Tao
    
       - other fixes and cleanups"
    
    * 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/shli/md: (33 commits)
      md: free unused memory after bitmap resize
      md: release allocated bitset sync_set
      md/bitmap: clear BITMAP_WRITE_ERROR bit before writing it to sb
      md: be cautious about using ->curr_resync_completed for ->recovery_offset
      badblocks: fix wrong return value in badblocks_set if badblocks are disabled
      md: don't check MD_SB_CHANGE_CLEAN in md_allow_write
      md-cluster: update document for raid10
      md: remove redundant variable q
      raid1: remove obsolete code in raid1_write_request
      md-cluster: Use a small window for raid10 resync
      md-cluster: Suspend writes in RAID10 if within range
      md-cluster/raid10: set "do_balance = 0" if area is resyncing
      md: use lockdep_assert_held
      raid1: prevent freeze_array/wait_all_barriers deadlock
      md: use TASK_IDLE instead of blocking signals
      md: remove special meaning of ->quiesce(.., 2)
      md: allow metadata update while suspending.
      md: use mddev_suspend/resume instead of ->quiesce()
      md: move suspend_hi/lo handling into core md code
      md: don't call bitmap_create() while array is quiesced.
      ...

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 735ce1a3d260..abceccab6671 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _RAID10_H
 #define _RAID10_H
 

commit 8db87912c9a8771c53b98845cd5516ea63b22e1e
Author: Guoqing Jiang <gqjiang@suse.com>
Date:   Tue Oct 24 15:11:52 2017 +0800

    md-cluster: Use a small window for raid10 resync
    
    Suspending the entire device for resync could take
    too long. Resync in small chunks.
    
    cluster's resync window is maintained in r10conf as
    cluster_sync_low and cluster_sync_high, and processed
    in raid10's sync_request(). If the current resync is
    outside the cluster resync window:
    
    1. Set the cluster_sync_low to curr_resync_completed.
    2. Set cluster_sync_high to cluster_sync_low + stripe
       size.
    3. Send a message to all nodes so they may add it in
       their suspension list.
    
    Note:
    We only support "near" raid10 so far, resync a far or
    offset raid10 array could have trouble. So raid10_run
    checks the layout of clustered raid10, it will refuse
    to run if the layout is not correct.
    
    With the "near" layout we process one stripe at a time
    progressing monotonically through the address space.
    So we can have a sliding window of whole-stripes which
    moves through the array suspending IO on other nodes,
    and both resync which uses array addresses and recovery
    which uses device addresses can stay within this window.
    
    Signed-off-by: Guoqing Jiang <gqjiang@suse.com>
    Signed-off-by: Shaohua Li <shli@fb.com>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 735ce1a3d260..2bef4e8789c8 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -88,6 +88,12 @@ struct r10conf {
 	 * the new thread here until we fully activate the array.
 	 */
 	struct md_thread	*thread;
+
+	/*
+	 * Keep track of cluster resync window to send to other nodes.
+	 */
+	sector_t		cluster_sync_low;
+	sector_t		cluster_sync_high;
 };
 
 /*

commit fc9977dd069e4f82fcacb262652117c488647319
Author: NeilBrown <neilb@suse.com>
Date:   Wed Apr 5 14:05:51 2017 +1000

    md/raid10: simplify the splitting of requests.
    
    raid10 splits requests in two different ways for two different
    reasons.
    
    First, bio_split() is used to ensure the bio fits with a chunk.
    Second, multiple r10bio structures are allocated to represent the
    different sections that need to go to different devices, to avoid
    known bad blocks.
    
    This can be simplified to just use bio_split() once, and not to use
    multiple r10bios.
    We delay the split until we know a maximum bio size that can
    be handled with a single r10bio, and then split the bio and queue
    the remainder for later handling.
    
    As with raid1, we allocate a new bio_set to help with the splitting.
    It is not correct to use fs_bio_set in a device driver.
    
    Signed-off-by: NeilBrown <neilb@suse.com>
    Signed-off-by: Shaohua Li <shli@fb.com>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 3162615e57bd..735ce1a3d260 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -82,6 +82,7 @@ struct r10conf {
 	mempool_t		*r10bio_pool;
 	mempool_t		*r10buf_pool;
 	struct page		*tmppage;
+	struct bio_set		*bio_split;
 
 	/* When taking over an array from a different personality, we store
 	 * the new thread here until we fully activate the array.

commit 8d3ca83dcf9ca3d58822eddd279918d46f41e9ff
Author: NeilBrown <neilb@suse.com>
Date:   Fri Nov 18 16:16:12 2016 +1100

    md/raid10: add failfast handling for reads.
    
    If a device is marked FailFast, and it is not the only
    device we can read from, we mark the bio as MD_FAILFAST.
    
    If this does fail-fast, we don't try read repair but just
    allow failure.
    
    If it was the last device, it doesn't get marked Faulty so
    the retry happens on the same device - this time without
    FAILFAST.  A subsequent failure will not retry but will just
    pass up the error.
    
    During resync we may use FAILFAST requests, and on a failure
    we will simply use the other device(s).
    
    During recovery we will only use FAILFAST in the unusual
    case were there are multiple places to read from - i.e. if
    there are > 2 devices.  If we get a failure we will fail the
    device and complete the resync/recovery with remaining
    devices.
    
    Signed-off-by: NeilBrown <neilb@suse.com>
    Signed-off-by: Shaohua Li <shli@fb.com>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 18ec1f7a98bf..3162615e57bd 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -156,5 +156,7 @@ enum r10bio_state {
  * flag is set
  */
 	R10BIO_Previous,
+/* failfast devices did receive failfast requests. */
+	R10BIO_FailFast,
 };
 #endif

commit 0e5313e2d4ef93bdf6c22dad647d28635b86472a
Author: Tomasz Majchrzak <tomasz.majchrzak@intel.com>
Date:   Fri Jun 24 14:20:16 2016 +0200

    raid10: improve random reads performance
    
    RAID10 random read performance is lower than expected due to excessive spinlock
    utilisation which is required mostly for rebuild/resync. Simplify allow_barrier
    as it's in IO path and encounters a lot of unnecessary congestion.
    
    As lower_barrier just takes a lock in order to decrement a counter, convert
    counter (nr_pending) into atomic variable and remove the spin lock. There is
    also a congestion for wake_up (it uses lock internally) so call it only when
    it's really needed. As wake_up is not called constantly anymore, ensure process
    waiting to raise a barrier is notified when there are no more waiting IOs.
    
    Signed-off-by: Tomasz Majchrzak <tomasz.majchrzak@intel.com>
    Signed-off-by: Shaohua Li <shli@fb.com>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 6fc2c75759bf..18ec1f7a98bf 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -64,10 +64,11 @@ struct r10conf {
 	int			pending_count;
 
 	spinlock_t		resync_lock;
-	int			nr_pending;
+	atomic_t		nr_pending;
 	int			nr_waiting;
 	int			nr_queued;
 	int			barrier;
+	int			array_freeze_pending;
 	sector_t		next_resync;
 	int			fullsync;  /* set to 1 if a full sync is needed,
 					    * (fresh device added).

commit 95af587e95aacb9cfda4a9641069a5244a540dc8
Author: NeilBrown <neilb@suse.com>
Date:   Fri Aug 14 11:26:17 2015 +1000

    md/raid10: ensure device failure recorded before write request returns.
    
    When a write to one of the legs of a RAID10 fails, the failure is
    recorded in the metadata of the other legs so that after a restart
    the data on the failed drive wont be trusted even if that drive seems
    to be working again (maybe a cable was unplugged).
    
    Currently there is no interlock between the write request completing
    and the metadata update.  So it is possible that the write will
    complete, the app will confirm success in some way, and then the
    machine will crash before the metadata update completes.
    
    This is an extremely small hole for a racy to fit in, but it is
    theoretically possible and so should be closed.
    
    So:
     - set MD_CHANGE_PENDING when requesting a metadata update for a
       failed device, so we can know with certainty when it completes
     - queue requests that experienced an error on a new queue which
       is only processed after the metadata update completes
     - call raid_end_bio_io() on bios in that queue when the time comes.
    
    Signed-off-by: NeilBrown <neilb@suse.com>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 5ee6473ddc2c..6fc2c75759bf 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -53,6 +53,12 @@ struct r10conf {
 	sector_t		offset_diff;
 
 	struct list_head	retry_list;
+	/* A separate list of r1bio which just need raid_end_bio_io called.
+	 * This mustn't happen for writes which had any errors if the superblock
+	 * needs to be written.
+	 */
+	struct list_head	bio_end_io_list;
+
 	/* queue pending writes and submit them on unplug */
 	struct bio_list		pending_bio_list;
 	int			pending_count;

commit 5c675f83c68fbdf9c0e103c1090b06be747fa62c
Author: NeilBrown <neilb@suse.de>
Date:   Mon Dec 15 12:56:56 2014 +1100

    md: make ->congested robust against personality changes.
    
    There is currently no locking around calls to the 'congested'
    bdi function.  If called at an awkward time while an array is
    being converted from one level (or personality) to another, there
    is a tiny chance of running code in an unreferenced module etc.
    
    So add a 'congested' function to the md_personality operations
    structure, and call it with appropriate locking from a central
    'mddev_congested'.
    
    When the array personality is changing the array will be 'suspended'
    so no IO is processed.
    If mddev_congested detects this, it simply reports that the
    array is congested, which is a safe guess.
    As mddev_suspend calls synchronize_rcu(), mddev_congested can
    avoid races by included the whole call inside an rcu_read_lock()
    region.
    This require that the congested functions for all subordinate devices
    can be run under rcu_lock.  Fortunately this is the case.
    
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 157d69e83ff4..5ee6473ddc2c 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -150,7 +150,4 @@ enum r10bio_state {
  */
 	R10BIO_Previous,
 };
-
-extern int md_raid10_congested(struct mddev *mddev, int bits);
-
 #endif

commit 475901aff15841fb0a81e7546517407779a9b061
Author: Jonathan Brassow <jbrassow@redhat.com>
Date:   Thu Feb 21 13:28:10 2013 +1100

    MD RAID10: Improve redundancy for 'far' and 'offset' algorithms (part 1)
    
    The MD RAID10 'far' and 'offset' algorithms make copies of entire stripe
    widths - copying them to a different location on the same devices after
    shifting the stripe.  An example layout of each follows below:
    
                    "far" algorithm
            dev1 dev2 dev3 dev4 dev5 dev6
            ==== ==== ==== ==== ==== ====
             A    B    C    D    E    F
             G    H    I    J    K    L
                        ...
             F    A    B    C    D    E  --> Copy of stripe0, but shifted by 1
             L    G    H    I    J    K
                        ...
    
                    "offset" algorithm
            dev1 dev2 dev3 dev4 dev5 dev6
            ==== ==== ==== ==== ==== ====
             A    B    C    D    E    F
             F    A    B    C    D    E  --> Copy of stripe0, but shifted by 1
             G    H    I    J    K    L
             L    G    H    I    J    K
                        ...
    
    Redundancy for these algorithms is gained by shifting the copied stripes
    one device to the right.  This patch proposes that array be divided into
    sets of adjacent devices and when the stripe copies are shifted, they wrap
    on set boundaries rather than the array size boundary.  That is, for the
    purposes of shifting, the copies are confined to their sets within the
    array.  The sets are 'near_copies * far_copies' in size.
    
    The above "far" algorithm example would change to:
                    "far" algorithm
            dev1 dev2 dev3 dev4 dev5 dev6
            ==== ==== ==== ==== ==== ====
             A    B    C    D    E    F
             G    H    I    J    K    L
                        ...
             B    A    D    C    F    E  --> Copy of stripe0, shifted 1, 2-dev sets
             H    G    J    I    L    K      Dev sets are 1-2, 3-4, 5-6
                        ...
    
    This has the affect of improving the redundancy of the array.  We can
    always sustain at least one failure, but sometimes more than one can
    be handled.  In the first examples, the pairs of devices that CANNOT fail
    together are:
            (1,2) (2,3) (3,4) (4,5) (5,6) (1, 6) [40% of possible pairs]
    In the example where the copies are confined to sets, the pairs of
    devices that cannot fail together are:
            (1,2) (3,4) (5,6)                    [20% of possible pairs]
    
    We cannot simply replace the old algorithms, so the 17th bit of the 'layout'
    variable is used to indicate whether we use the old or new method of computing
    the shift.  (This is similar to the way the 16th bit indicates whether the
    "far" algorithm or the "offset" algorithm is being used.)
    
    This patch only handles the cases where the number of total raid disks is
    a multiple of 'far_copies'.  A follow-on patch addresses the condition where
    this is not true.
    
    Signed-off-by: Jonathan Brassow <jbrassow@redhat.com>
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 1054cf602345..157d69e83ff4 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -33,6 +33,11 @@ struct r10conf {
 					       * far_offset, in which case it is
 					       * 1 stripe.
 					       */
+		int             far_set_size; /* The number of devices in a set,
+					       * where a 'set' are devices that
+					       * contain far/offset copies of
+					       * each other.
+					       */
 		int		chunk_shift; /* shift from chunks to sectors */
 		sector_t	chunk_mask;
 	} prev, geo;

commit e0ee778528bbaad28a5c69d2e219269a3a096607
Author: NeilBrown <neilb@suse.de>
Date:   Sat Aug 18 09:51:42 2012 +1000

    md/raid10: fix problem with on-stack allocation of r10bio structure.
    
    A 'struct r10bio' has an array of per-copy information at the end.
    This array is declared with size [0] and r10bio_pool_alloc allocates
    enough extra space to store the per-copy information depending on the
    number of copies needed.
    
    So declaring a 'struct r10bio on the stack isn't going to work.  It
    won't allocate enough space, and memory corruption will ensue.
    
    So in the two places where this is done, declare a sufficiently large
    structure and use that instead.
    
    The two call-sites of this bug were introduced in 3.4 and 3.5
    so this is suitable for both those kernels.  The patch will have to
    be modified for 3.4 as it only has one bug.
    
    Cc: stable@vger.kernel.org
    Reported-by: Ivan Vasilyev <ivan.vasilyev@gmail.com>
    Tested-by: Ivan Vasilyev <ivan.vasilyev@gmail.com>
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 007c2c68dd83..1054cf602345 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -110,7 +110,7 @@ struct r10bio {
 	 * We choose the number when they are allocated.
 	 * We sometimes need an extra bio to write to the replacement.
 	 */
-	struct {
+	struct r10dev {
 		struct bio	*bio;
 		union {
 			struct bio	*repl_bio; /* used for resync and

commit cc4d1efdd017083bbcbaf23feb4cdc717fa7dab8
Author: Jonathan Brassow <jbrassow@redhat.com>
Date:   Tue Jul 31 10:03:53 2012 +1000

    MD RAID10: Export md_raid10_congested
    
    md/raid10: Export is_congested test.
    
    In similar fashion to commits
            11d8a6e3719519fbc0e2c9d61b6fa931b84bf813
            1ed7242e591af7e233234d483f12d33818b189d9
    we export the RAID10 congestion checking function so that dm-raid.c can
    make use of it and make use of the personality.  The 'queue' and 'gendisk'
    structures will not be available to the MD code when device-mapper sets
    up the device, so we conditionalize access to these fields also.
    
    Signed-off-by: Jonathan Brassow <jbrassow@redhat.com>
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index b0a435869dca..007c2c68dd83 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -145,4 +145,7 @@ enum r10bio_state {
  */
 	R10BIO_Previous,
 };
+
+extern int md_raid10_congested(struct mddev *mddev, int bits);
+
 #endif

commit 473e87ce485ffcac041f7911b33f0b4cd4d6cf2b
Author: Jonathan Brassow <jbrassow@redhat.com>
Date:   Tue Jul 31 10:03:52 2012 +1000

    MD: Move macros from raid1*.h to raid1*.c
    
    MD RAID1/RAID10: Move some macros from .h file to .c file
    
    There are three macros (IO_BLOCKED,IO_MADE_GOOD,BIO_SPECIAL) which are defined
    in both raid1.h and raid10.h.  They are only used in there respective .c files.
    However, if we wish to make RAID10 accessible to the device-mapper RAID
    target (dm-raid.c), then we need to move these macros into the .c files where
    they are used so that they do not conflict with each other.
    
    The macros from the two files are identical and could be moved into md.h, but
    I chose to leave the duplication and have them remain in the personality
    files.
    
    Signed-off-by: Jonathan Brassow <jbrassow@redhat.com>
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index ecdb440b003a..b0a435869dca 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -123,20 +123,6 @@ struct r10bio {
 	} devs[0];
 };
 
-/* when we get a read error on a read-only array, we redirect to another
- * device without failing the first device, or trying to over-write to
- * correct the read error.  To keep track of bad blocks on a per-bio
- * level, we store IO_BLOCKED in the appropriate 'bios' pointer
- */
-#define IO_BLOCKED ((struct bio*)1)
-/* When we successfully write to a known bad-block, we need to remove the
- * bad-block marking which must be done from process context.  So we record
- * the success by setting devs[n].bio to IO_MADE_GOOD
- */
-#define IO_MADE_GOOD ((struct bio *)2)
-
-#define BIO_SPECIAL(bio) ((unsigned long)bio <= 2)
-
 /* bits for r10bio.state */
 enum r10bio_state {
 	R10BIO_Uptodate,

commit dc280d987f039ef35ac1e59c09b7154b61f385cf
Author: Jonathan Brassow <jbrassow@redhat.com>
Date:   Tue Jul 31 10:03:52 2012 +1000

    MD RAID10: rename mirror_info structure
    
    MD RAID10: Rename the structure 'mirror_info' to 'raid10_info'
    
    The same structure name ('mirror_info') is used by raid1.  Each of these
    structures are defined in there respective header files.  If dm-raid is
    to support both RAID1 and RAID10, the header files will be included and
    the structure names must not collide.
    
    Signed-off-by: Jonathan Brassow <jbrassow@redhat.com>
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 135b1b0a1554..ecdb440b003a 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -1,7 +1,7 @@
 #ifndef _RAID10_H
 #define _RAID10_H
 
-struct mirror_info {
+struct raid10_info {
 	struct md_rdev	*rdev, *replacement;
 	sector_t	head_position;
 	int		recovery_disabled;	/* matches
@@ -13,8 +13,8 @@ struct mirror_info {
 
 struct r10conf {
 	struct mddev		*mddev;
-	struct mirror_info	*mirrors;
-	struct mirror_info	*mirrors_new, *mirrors_old;
+	struct raid10_info	*mirrors;
+	struct raid10_info	*mirrors_new, *mirrors_old;
 	spinlock_t		device_lock;
 
 	/* geometry */

commit 3ea7daa5d7fde47cd41f4d56c2deb949114da9d6
Author: NeilBrown <neilb@suse.de>
Date:   Tue May 22 13:53:47 2012 +1000

    md/raid10: add reshape support
    
    A 'near' or 'offset' lay RAID10 array can be reshaped to a different
    'near' or 'offset' layout, a different chunk size, and a different
    number of devices.
    However the number of copies cannot change.
    
    Unlike RAID5/6, we do not support having user-space backup data that
    is being relocated during a 'critical section'.  Rather, the
    data_offset of each device must change so that when writing any block
    to a new location, it will not over-write any data that is still
    'live'.
    
    This means that RAID10 reshape is not supportable on v0.90 metadata.
    
    The different between the old data_offset and the new_offset must be
    at least the larger of the chunksize multiplied by offset copies of
    each of the old and new layout. (for 'near' mode, offset_copies == 1).
    
    A larger difference of around 64M seems useful for in-place reshapes
    as more data can be moved between metadata updates.
    Very large differences (e.g. 512M) seem to slow the process down due
    to lots of long seeks (on oldish consumer graded devices at least).
    
    Metadata needs to be updated whenever the place we are about to write
    to is considered - by the current metadata - to still contain data in
    the old layout.
    
    [unbalanced locking fix from Dan Carpenter <dan.carpenter@oracle.com>]
    
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 37509d7134aa..135b1b0a1554 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -14,6 +14,7 @@ struct mirror_info {
 struct r10conf {
 	struct mddev		*mddev;
 	struct mirror_info	*mirrors;
+	struct mirror_info	*mirrors_new, *mirrors_old;
 	spinlock_t		device_lock;
 
 	/* geometry */
@@ -42,6 +43,9 @@ struct r10conf {
 	sector_t		dev_sectors;  /* temp copy of
 					       * mddev->dev_sectors */
 	sector_t		reshape_progress;
+	sector_t		reshape_safe;
+	unsigned long		reshape_checkpoint;
+	sector_t		offset_diff;
 
 	struct list_head	retry_list;
 	/* queue pending writes and submit them on unplug */
@@ -138,6 +142,7 @@ enum r10bio_state {
 	R10BIO_Uptodate,
 	R10BIO_IsSync,
 	R10BIO_IsRecover,
+	R10BIO_IsReshape,
 	R10BIO_Degraded,
 /* Set ReadError on bios that experience a read error
  * so that raid10d knows what to do with them.

commit f8c9e74ff0832f2244d7991d2aea13851b20a622
Author: NeilBrown <neilb@suse.de>
Date:   Mon May 21 09:28:33 2012 +1000

    md/raid10: Introduce 'prev' geometry to support reshape.
    
    When RAID10 supports reshape it will need a 'previous' and a 'current'
    geometry, so introduce that here.
    Use the 'prev' geometry when before the reshape_position, and the
    current 'geo' when beyond it.  At other times, use both as
    appropriate.
    
    For now, both are identical (And reshape_position is never set).
    
    When we use the 'prev' geometry, we must use the old data_offset.
    When we use the current (And a reshape is happening) we must use
    the new_data_offset.
    
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 4c4942ac46fc..37509d7134aa 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -34,13 +34,14 @@ struct r10conf {
 					       */
 		int		chunk_shift; /* shift from chunks to sectors */
 		sector_t	chunk_mask;
-	} geo;
+	} prev, geo;
 	int			copies;	      /* near_copies * far_copies.
 					       * must be <= raid_disks
 					       */
 
 	sector_t		dev_sectors;  /* temp copy of
 					       * mddev->dev_sectors */
+	sector_t		reshape_progress;
 
 	struct list_head	retry_list;
 	/* queue pending writes and submit them on unplug */
@@ -147,5 +148,10 @@ enum r10bio_state {
  */
 	R10BIO_MadeGood,
 	R10BIO_WriteError,
+/* During a reshape we might be performing IO on the
+ * 'previous' part of the array, in which case this
+ * flag is set
+ */
+	R10BIO_Previous,
 };
 #endif

commit 5cf00fcd3c98d2eafb58ac7a649bbdb9dbc4902b
Author: NeilBrown <neilb@suse.de>
Date:   Mon May 21 09:28:20 2012 +1000

    md/raid10: collect some geometry fields into a dedicated structure.
    
    We will shortly be adding reshape support for RAID10 which will
    require it having 2 concurrent geometries (before and after).
    To make that easier, collect most geometry fields into 'struct geom'
    and access them from there.  Then we will more easily be able to add
    a second set of fields.
    
    Note that 'copies' is not in this struct and so cannot be changed.
    There is little need to change this number and doing so is a lot
    more difficult as it requires reallocating more things.
    So leave it out for now.
    
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 7c615613c381..4c4942ac46fc 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -14,33 +14,34 @@ struct mirror_info {
 struct r10conf {
 	struct mddev		*mddev;
 	struct mirror_info	*mirrors;
-	int			raid_disks;
 	spinlock_t		device_lock;
 
 	/* geometry */
-	int			near_copies;  /* number of copies laid out
+	struct geom {
+		int		raid_disks;
+		int		near_copies;  /* number of copies laid out
 					       * raid0 style */
-	int 			far_copies;   /* number of copies laid out
+		int		far_copies;   /* number of copies laid out
 					       * at large strides across drives
 					       */
-	int			far_offset;   /* far_copies are offset by 1
+		int		far_offset;   /* far_copies are offset by 1
 					       * stripe instead of many
 					       */
-	int			copies;	      /* near_copies * far_copies.
-					       * must be <= raid_disks
-					       */
-	sector_t		stride;	      /* distance between far copies.
+		sector_t	stride;	      /* distance between far copies.
 					       * This is size / far_copies unless
 					       * far_offset, in which case it is
 					       * 1 stripe.
 					       */
+		int		chunk_shift; /* shift from chunks to sectors */
+		sector_t	chunk_mask;
+	} geo;
+	int			copies;	      /* near_copies * far_copies.
+					       * must be <= raid_disks
+					       */
 
 	sector_t		dev_sectors;  /* temp copy of
 					       * mddev->dev_sectors */
 
-	int			chunk_shift; /* shift from chunks to sectors */
-	sector_t		chunk_mask;
-
 	struct list_head	retry_list;
 	/* queue pending writes and submit them on unplug */
 	struct bio_list		pending_bio_list;

commit 69335ef3bc5b766f34db2d688be1d35313138bca
Author: NeilBrown <neilb@suse.de>
Date:   Fri Dec 23 10:17:54 2011 +1100

    md/raid10: prepare data structures for handling replacement.
    
    Allow each slot in the RAID10 to have 2 devices, the want_replacement
    and the replacement.
    
    Also an r10bio to have 2 bios, and for resync/recovery allocate the
    second bio if there are any replacement devices.
    
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 7facfdf841f4..7c615613c381 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -2,7 +2,7 @@
 #define _RAID10_H
 
 struct mirror_info {
-	struct md_rdev	*rdev;
+	struct md_rdev	*rdev, *replacement;
 	sector_t	head_position;
 	int		recovery_disabled;	/* matches
 						 * mddev->recovery_disabled
@@ -18,12 +18,13 @@ struct r10conf {
 	spinlock_t		device_lock;
 
 	/* geometry */
-	int			near_copies;  /* number of copies laid out raid0 style */
+	int			near_copies;  /* number of copies laid out
+					       * raid0 style */
 	int 			far_copies;   /* number of copies laid out
 					       * at large strides across drives
 					       */
-	int			far_offset;   /* far_copies are offset by 1 stripe
-					       * instead of many
+	int			far_offset;   /* far_copies are offset by 1
+					       * stripe instead of many
 					       */
 	int			copies;	      /* near_copies * far_copies.
 					       * must be <= raid_disks
@@ -34,10 +35,11 @@ struct r10conf {
 					       * 1 stripe.
 					       */
 
-	sector_t		dev_sectors;  /* temp copy of mddev->dev_sectors */
+	sector_t		dev_sectors;  /* temp copy of
+					       * mddev->dev_sectors */
 
-	int chunk_shift; /* shift from chunks to sectors */
-	sector_t chunk_mask;
+	int			chunk_shift; /* shift from chunks to sectors */
+	sector_t		chunk_mask;
 
 	struct list_head	retry_list;
 	/* queue pending writes and submit them on unplug */
@@ -45,20 +47,22 @@ struct r10conf {
 	int			pending_count;
 
 	spinlock_t		resync_lock;
-	int nr_pending;
-	int nr_waiting;
-	int nr_queued;
-	int barrier;
+	int			nr_pending;
+	int			nr_waiting;
+	int			nr_queued;
+	int			barrier;
 	sector_t		next_resync;
 	int			fullsync;  /* set to 1 if a full sync is needed,
 					    * (fresh device added).
 					    * Cleared when a sync completes.
 					    */
-
+	int			have_replacement; /* There is at least one
+						   * replacement device.
+						   */
 	wait_queue_head_t	wait_barrier;
 
-	mempool_t *r10bio_pool;
-	mempool_t *r10buf_pool;
+	mempool_t		*r10bio_pool;
+	mempool_t		*r10buf_pool;
 	struct page		*tmppage;
 
 	/* When taking over an array from a different personality, we store
@@ -98,11 +102,18 @@ struct r10bio {
 	 * When resyncing we also use one for each copy.
 	 * When reconstructing, we use 2 bios, one for read, one for write.
 	 * We choose the number when they are allocated.
+	 * We sometimes need an extra bio to write to the replacement.
 	 */
 	struct {
-		struct bio		*bio;
-		sector_t addr;
-		int devnum;
+		struct bio	*bio;
+		union {
+			struct bio	*repl_bio; /* used for resync and
+						    * writes */
+			struct md_rdev	*rdev;	   /* used for reads
+						    * (read_slot >= 0) */
+		};
+		sector_t	addr;
+		int		devnum;
 	} devs[0];
 };
 
@@ -121,17 +132,19 @@ struct r10bio {
 #define BIO_SPECIAL(bio) ((unsigned long)bio <= 2)
 
 /* bits for r10bio.state */
-#define	R10BIO_Uptodate	0
-#define	R10BIO_IsSync	1
-#define	R10BIO_IsRecover 2
-#define	R10BIO_Degraded 3
+enum r10bio_state {
+	R10BIO_Uptodate,
+	R10BIO_IsSync,
+	R10BIO_IsRecover,
+	R10BIO_Degraded,
 /* Set ReadError on bios that experience a read error
  * so that raid10d knows what to do with them.
  */
-#define	R10BIO_ReadError 4
+	R10BIO_ReadError,
 /* If a write for this request means we can clear some
  * known-bad-block records, we set this flag.
  */
-#define	R10BIO_MadeGood 5
-#define	R10BIO_WriteError 6
+	R10BIO_MadeGood,
+	R10BIO_WriteError,
+};
 #endif

commit 34db0cd60f8a1f4ab73d118a8be3797c20388223
Author: NeilBrown <neilb@suse.de>
Date:   Tue Oct 11 16:50:01 2011 +1100

    md: add proper write-congestion reporting to RAID1 and RAID10.
    
    RAID1 and RAID10 handle write requests by queuing them for handling by
    a separate thread.  This is because when a write-intent-bitmap is
    active we might need to update the bitmap first, so it is good to
    queue a lot of writes, then do one big bitmap update for them all.
    
    However writeback request devices to appear to be congested after a
    while so it can make some guesstimate of throughput.  The infinite
    queue defeats that (note that RAID5 has already has a finite queue so
    it doesn't suffer from this problem).
    
    So impose a limit on the number of pending write requests.  By default
    it is 1024 which seems to be generally suitable.  Make it configurable
    via module option just in case someone finds a regression.
    
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 35489a569597..7facfdf841f4 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -42,7 +42,7 @@ struct r10conf {
 	struct list_head	retry_list;
 	/* queue pending writes and submit them on unplug */
 	struct bio_list		pending_bio_list;
-
+	int			pending_count;
 
 	spinlock_t		resync_lock;
 	int nr_pending;

commit e879a8793f915aa7933364d962d2435bd71de462
Author: NeilBrown <neilb@suse.de>
Date:   Tue Oct 11 16:49:02 2011 +1100

    md/raid10: typedef removal: conf_t -> struct r10conf
    
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 94f898a11be4..35489a569597 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -11,7 +11,7 @@ struct mirror_info {
 						 */
 };
 
-struct r10_private_data_s {
+struct r10conf {
 	struct mddev		*mddev;
 	struct mirror_info	*mirrors;
 	int			raid_disks;
@@ -67,8 +67,6 @@ struct r10_private_data_s {
 	struct md_thread	*thread;
 };
 
-typedef struct r10_private_data_s conf_t;
-
 /*
  * this is our 'private' RAID10 bio.
  *

commit 0f6d02d580ca77ee4be085c29c5fe5b879df24d9
Author: NeilBrown <neilb@suse.de>
Date:   Tue Oct 11 16:48:46 2011 +1100

    md: remove typedefs: mirror_info_t -> struct mirror_info
    
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index be7f8d9cfc63..94f898a11be4 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -1,8 +1,6 @@
 #ifndef _RAID10_H
 #define _RAID10_H
 
-typedef struct mirror_info mirror_info_t;
-
 struct mirror_info {
 	struct md_rdev	*rdev;
 	sector_t	head_position;
@@ -15,7 +13,7 @@ struct mirror_info {
 
 struct r10_private_data_s {
 	struct mddev		*mddev;
-	mirror_info_t		*mirrors;
+	struct mirror_info	*mirrors;
 	int			raid_disks;
 	spinlock_t		device_lock;
 

commit 9f2c9d12bcc53fcb3b787023723754e84d1aef8b
Author: NeilBrown <neilb@suse.de>
Date:   Tue Oct 11 16:48:43 2011 +1100

    md: remove typedefs: r10bio_t -> struct r10bio and r1bio_t -> struct r1bio
    
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index c7721365f7bd..be7f8d9cfc63 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -13,8 +13,6 @@ struct mirror_info {
 						 */
 };
 
-typedef struct r10bio_s r10bio_t;
-
 struct r10_private_data_s {
 	struct mddev		*mddev;
 	mirror_info_t		*mirrors;
@@ -80,7 +78,7 @@ typedef struct r10_private_data_s conf_t;
  * for this RAID10 operation, and about their status:
  */
 
-struct r10bio_s {
+struct r10bio {
 	atomic_t		remaining; /* 'have we finished' count,
 					    * used from IRQ handlers
 					    */

commit 2b8bf3451d1e3133ebc3998721d14013a6c27114
Author: NeilBrown <neilb@suse.de>
Date:   Tue Oct 11 16:48:23 2011 +1100

    md: remove typedefs: mdk_thread_t -> struct md_thread
    
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index ad2da69becbe..c7721365f7bd 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -68,7 +68,7 @@ struct r10_private_data_s {
 	/* When taking over an array from a different personality, we store
 	 * the new thread here until we fully activate the array.
 	 */
-	struct mdk_thread_s	*thread;
+	struct md_thread	*thread;
 };
 
 typedef struct r10_private_data_s conf_t;

commit fd01b88c75a718020ff77e7f560d33835e9b58de
Author: NeilBrown <neilb@suse.de>
Date:   Tue Oct 11 16:47:53 2011 +1100

    md: remove typedefs: mddev_t -> struct mddev
    
    Having mddev_t and 'struct mddev_s' is ugly and not preferred
    
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index d37260fe9c3f..ad2da69becbe 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -16,7 +16,7 @@ struct mirror_info {
 typedef struct r10bio_s r10bio_t;
 
 struct r10_private_data_s {
-	mddev_t			*mddev;
+	struct mddev		*mddev;
 	mirror_info_t		*mirrors;
 	int			raid_disks;
 	spinlock_t		device_lock;
@@ -87,7 +87,7 @@ struct r10bio_s {
 	sector_t		sector;	/* virtual sector number */
 	int			sectors;
 	unsigned long		state;
-	mddev_t			*mddev;
+	struct mddev		*mddev;
 	/*
 	 * original bio going to /dev/mdx
 	 */

commit 3cb03002000f133f9f97269edefd73611eafc873
Author: NeilBrown <neilb@suse.de>
Date:   Tue Oct 11 16:45:26 2011 +1100

    md: removing typedefs:  mdk_rdev_t -> struct md_rdev
    
    The typedefs are just annoying. 'mdk' probably refers to 'md_k.h'
    which used to be an include file that defined this thing.
    
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 79cb52a0d4a2..d37260fe9c3f 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -4,7 +4,7 @@
 typedef struct mirror_info mirror_info_t;
 
 struct mirror_info {
-	mdk_rdev_t	*rdev;
+	struct md_rdev	*rdev;
 	sector_t	head_position;
 	int		recovery_disabled;	/* matches
 						 * mddev->recovery_disabled

commit bd870a16c5946d86126f7203db3c73b71de0a1d8
Author: NeilBrown <neilb@suse.de>
Date:   Thu Jul 28 11:39:24 2011 +1000

    md/raid10:  Handle write errors by updating badblock log.
    
    When we get a write error (in the data area, not in metadata),
    update the badblock log rather than failing the whole device.
    
    As the write may well be many blocks, we trying writing each
    block individually and only log the ones which fail.
    
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index d8b7f9af92d5..79cb52a0d4a2 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -139,4 +139,5 @@ struct r10bio_s {
  * known-bad-block records, we set this flag.
  */
 #define	R10BIO_MadeGood 5
+#define	R10BIO_WriteError 6
 #endif

commit 749c55e942d91cb27045fe2eb313aa5afe68ae0b
Author: NeilBrown <neilb@suse.de>
Date:   Thu Jul 28 11:39:24 2011 +1000

    md/raid10: clear bad-block record when write succeeds.
    
    If we succeed in writing to a block that was recorded as
    being bad, we clear the bad-block record.
    
    This requires some delayed handling as the bad-block-list update has
    to happen in process-context.
    
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index c646152ba4e4..d8b7f9af92d5 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -118,6 +118,13 @@ struct r10bio_s {
  * level, we store IO_BLOCKED in the appropriate 'bios' pointer
  */
 #define IO_BLOCKED ((struct bio*)1)
+/* When we successfully write to a known bad-block, we need to remove the
+ * bad-block marking which must be done from process context.  So we record
+ * the success by setting devs[n].bio to IO_MADE_GOOD
+ */
+#define IO_MADE_GOOD ((struct bio *)2)
+
+#define BIO_SPECIAL(bio) ((unsigned long)bio <= 2)
 
 /* bits for r10bio.state */
 #define	R10BIO_Uptodate	0
@@ -128,4 +135,8 @@ struct r10bio_s {
  * so that raid10d knows what to do with them.
  */
 #define	R10BIO_ReadError 4
+/* If a write for this request means we can clear some
+ * known-bad-block records, we set this flag.
+ */
+#define	R10BIO_MadeGood 5
 #endif

commit 856e08e23762dfb92ffc68fd0a8d228f9e152160
Author: NeilBrown <neilb@suse.de>
Date:   Thu Jul 28 11:39:23 2011 +1000

    md/raid10: avoid reading from known bad blocks - part 1
    
    This patch just covers the basic read path:
     1/ read_balance needs to check for badblocks, and return not only
        the chosen slot, but also how many good blocks are available
        there.
     2/ read submission must be ready to issue multiple reads to
        different devices as different bad blocks on different devices
        could mean that a single large read cannot be served by any one
        device, but can still be served by the array.
        This requires keeping count of the number of outstanding requests
        per bio.  This count is stored in 'bi_phys_segments'
    
    On read error we currently just fail the request if another target
    cannot handle the whole request.  Next patch refines that a bit.
    
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index a485914c48c1..c646152ba4e4 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -124,4 +124,8 @@ struct r10bio_s {
 #define	R10BIO_IsSync	1
 #define	R10BIO_IsRecover 2
 #define	R10BIO_Degraded 3
+/* Set ReadError on bios that experience a read error
+ * so that raid10d knows what to do with them.
+ */
+#define	R10BIO_ReadError 4
 #endif

commit 2bb77736ae5dca0a189829fbb7379d43364a9dac
Author: NeilBrown <neilb@suse.de>
Date:   Wed Jul 27 11:00:36 2011 +1000

    md/raid10: Make use of new recovery_disabled handling
    
    When we get a read error during recovery, RAID10 previously
    arranged for the recovering device to appear to fail so that
    the recovery stops and doesn't restart.  This is misleading and wrong.
    
    Instead, make use of the new recovery_disabled handling and mark
    the target device and having recovery disabled.
    
    Add appropriate checks in add_disk and remove_disk so that devices
    are removed and not re-added when recovery is disabled.
    
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 944b1104d3b4..a485914c48c1 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -6,6 +6,11 @@ typedef struct mirror_info mirror_info_t;
 struct mirror_info {
 	mdk_rdev_t	*rdev;
 	sector_t	head_position;
+	int		recovery_disabled;	/* matches
+						 * mddev->recovery_disabled
+						 * when we shouldn't try
+						 * recovering this device.
+						 */
 };
 
 typedef struct r10bio_s r10bio_t;

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 2316ac2e8e21..944b1104d3b4 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -17,8 +17,8 @@ struct r10_private_data_s {
 	spinlock_t		device_lock;
 
 	/* geometry */
-	int			near_copies;  /* number of copies layed out raid0 style */
-	int 			far_copies;   /* number of copies layed out
+	int			near_copies;  /* number of copies laid out raid0 style */
+	int 			far_copies;   /* number of copies laid out
 					       * at large strides across drives
 					       */
 	int			far_offset;   /* far_copies are offset by 1 stripe

commit e93f68a1fc6244c05ad8fae28e75835ec74ab34e
Author: NeilBrown <neilb@suse.de>
Date:   Tue Jun 15 09:36:03 2010 +0100

    md: fix handling of array level takeover that re-arranges devices.
    
    Most array level changes leave the list of devices largely unchanged,
    possibly causing one at the end to become redundant.
    However conversions between RAID0 and RAID10 need to renumber
    all devices (except 0).
    
    This renumbering is currently being done in the ->run method when the
    new personality takes over.  However this is too late as the common
    code in md.c might already have invalidated some of the devices if
    they had a ->raid_disk number that appeared to high.
    
    Moving it into the ->takeover method is too early as the array is
    still active at that time and wrong ->raid_disk numbers could cause
    confusion.
    
    So add a ->new_raid_disk field to mdk_rdev_s and use it to communicate
    the new raid_disk number.
    Now the common code knows exactly which devices need to be renumbered,
    and which can be invalidated, and can do it all at a convenient time
    when the array is suspend.
    It can also update some symlinks in sysfs which previously were not be
    updated correctly.
    
    Reported-by: Maciej Trela <maciej.trela@intel.com>
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 3824a087e17c..2316ac2e8e21 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -38,11 +38,6 @@ struct r10_private_data_s {
 	int chunk_shift; /* shift from chunks to sectors */
 	sector_t chunk_mask;
 
-	int			scale_disks;  /* When starting array, multiply
-					       * each ->raid_disk by this.
-					       * Need for raid0->raid10 migration
-					       */
-
 	struct list_head	retry_list;
 	/* queue pending writes and submit them on unplug */
 	struct bio_list		pending_bio_list;

commit dab8b29248b3f14f456651a2a6ee9b8fd16d1b3c
Author: Trela, Maciej <Maciej.Trela@intel.com>
Date:   Mon Mar 8 16:02:45 2010 +1100

    md: Add support for Raid0->Raid10 takeover
    
    
    Signed-off-by: Maciej Trela <maciej.trela@intel.com>
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 59cd1efb8d30..3824a087e17c 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -33,9 +33,16 @@ struct r10_private_data_s {
 					       * 1 stripe.
 					       */
 
+	sector_t		dev_sectors;  /* temp copy of mddev->dev_sectors */
+
 	int chunk_shift; /* shift from chunks to sectors */
 	sector_t chunk_mask;
 
+	int			scale_disks;  /* When starting array, multiply
+					       * each ->raid_disk by this.
+					       * Need for raid0->raid10 migration
+					       */
+
 	struct list_head	retry_list;
 	/* queue pending writes and submit them on unplug */
 	struct bio_list		pending_bio_list;
@@ -57,6 +64,11 @@ struct r10_private_data_s {
 	mempool_t *r10bio_pool;
 	mempool_t *r10buf_pool;
 	struct page		*tmppage;
+
+	/* When taking over an array from a different personality, we store
+	 * the new thread here until we fully activate the array.
+	 */
+	struct mdk_thread_s	*thread;
 };
 
 typedef struct r10_private_data_s conf_t;

commit 070ec55d07157a3041f92654135c3c6e2eaaf901
Author: NeilBrown <neilb@suse.de>
Date:   Tue Jun 16 16:54:21 2009 +1000

    md: remove mddev_to_conf "helper" macro
    
    Having a macro just to cast a void* isn't really helpful.
    I would must rather see that we are simply de-referencing ->private,
    than have to know what the macro does.
    
    So open code the macro everywhere and remove the pointless cast.
    
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index 244dbe507a54..59cd1efb8d30 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -61,12 +61,6 @@ struct r10_private_data_s {
 
 typedef struct r10_private_data_s conf_t;
 
-/*
- * this is the only point in the RAID code where we violate
- * C type safety. mddev->private is an 'opaque' pointer.
- */
-#define mddev_to_conf(mddev) ((conf_t *) mddev->private)
-
 /*
  * this is our 'private' RAID10 bio.
  *

commit bff61975b3d6c18ee31457cc5b4d73042f44915f
Author: NeilBrown <neilb@suse.de>
Date:   Tue Mar 31 14:33:13 2009 +1100

    md: move lots of #include lines out of .h files and into .c
    
    This makes the includes more explicit, and is preparation for moving
    md_k.h to drivers/md/md.h
    
    Remove include/raid/md.h as its only remaining use was to #include
    other files.
    
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
index e9091cfeb286..244dbe507a54 100644
--- a/drivers/md/raid10.h
+++ b/drivers/md/raid10.h
@@ -1,8 +1,6 @@
 #ifndef _RAID10_H
 #define _RAID10_H
 
-#include <linux/raid/md.h>
-
 typedef struct mirror_info mirror_info_t;
 
 struct mirror_info {

commit ef740c372dfd80e706dbf955d4e4aedda6c0c148
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Mar 31 14:27:03 2009 +1100

    md: move headers out of include/linux/raid/
    
    Move the headers with the local structures for the disciplines and
    bitmap.h into drivers/md/ so that they are more easily grepable for
    hacking and not far away.  md.h is left where it is for now as there
    are some uses from the outside.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/raid10.h b/drivers/md/raid10.h
new file mode 100644
index 000000000000..e9091cfeb286
--- /dev/null
+++ b/drivers/md/raid10.h
@@ -0,0 +1,123 @@
+#ifndef _RAID10_H
+#define _RAID10_H
+
+#include <linux/raid/md.h>
+
+typedef struct mirror_info mirror_info_t;
+
+struct mirror_info {
+	mdk_rdev_t	*rdev;
+	sector_t	head_position;
+};
+
+typedef struct r10bio_s r10bio_t;
+
+struct r10_private_data_s {
+	mddev_t			*mddev;
+	mirror_info_t		*mirrors;
+	int			raid_disks;
+	spinlock_t		device_lock;
+
+	/* geometry */
+	int			near_copies;  /* number of copies layed out raid0 style */
+	int 			far_copies;   /* number of copies layed out
+					       * at large strides across drives
+					       */
+	int			far_offset;   /* far_copies are offset by 1 stripe
+					       * instead of many
+					       */
+	int			copies;	      /* near_copies * far_copies.
+					       * must be <= raid_disks
+					       */
+	sector_t		stride;	      /* distance between far copies.
+					       * This is size / far_copies unless
+					       * far_offset, in which case it is
+					       * 1 stripe.
+					       */
+
+	int chunk_shift; /* shift from chunks to sectors */
+	sector_t chunk_mask;
+
+	struct list_head	retry_list;
+	/* queue pending writes and submit them on unplug */
+	struct bio_list		pending_bio_list;
+
+
+	spinlock_t		resync_lock;
+	int nr_pending;
+	int nr_waiting;
+	int nr_queued;
+	int barrier;
+	sector_t		next_resync;
+	int			fullsync;  /* set to 1 if a full sync is needed,
+					    * (fresh device added).
+					    * Cleared when a sync completes.
+					    */
+
+	wait_queue_head_t	wait_barrier;
+
+	mempool_t *r10bio_pool;
+	mempool_t *r10buf_pool;
+	struct page		*tmppage;
+};
+
+typedef struct r10_private_data_s conf_t;
+
+/*
+ * this is the only point in the RAID code where we violate
+ * C type safety. mddev->private is an 'opaque' pointer.
+ */
+#define mddev_to_conf(mddev) ((conf_t *) mddev->private)
+
+/*
+ * this is our 'private' RAID10 bio.
+ *
+ * it contains information about what kind of IO operations were started
+ * for this RAID10 operation, and about their status:
+ */
+
+struct r10bio_s {
+	atomic_t		remaining; /* 'have we finished' count,
+					    * used from IRQ handlers
+					    */
+	sector_t		sector;	/* virtual sector number */
+	int			sectors;
+	unsigned long		state;
+	mddev_t			*mddev;
+	/*
+	 * original bio going to /dev/mdx
+	 */
+	struct bio		*master_bio;
+	/*
+	 * if the IO is in READ direction, then this is where we read
+	 */
+	int			read_slot;
+
+	struct list_head	retry_list;
+	/*
+	 * if the IO is in WRITE direction, then multiple bios are used,
+	 * one for each copy.
+	 * When resyncing we also use one for each copy.
+	 * When reconstructing, we use 2 bios, one for read, one for write.
+	 * We choose the number when they are allocated.
+	 */
+	struct {
+		struct bio		*bio;
+		sector_t addr;
+		int devnum;
+	} devs[0];
+};
+
+/* when we get a read error on a read-only array, we redirect to another
+ * device without failing the first device, or trying to over-write to
+ * correct the read error.  To keep track of bad blocks on a per-bio
+ * level, we store IO_BLOCKED in the appropriate 'bios' pointer
+ */
+#define IO_BLOCKED ((struct bio*)1)
+
+/* bits for r10bio.state */
+#define	R10BIO_Uptodate	0
+#define	R10BIO_IsSync	1
+#define	R10BIO_IsRecover 2
+#define	R10BIO_Degraded 3
+#endif
