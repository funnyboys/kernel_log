commit 5ebaf80bc8d5826edcc2d1cea26a7d5a4b8f01dd
Author: Guoqing Jiang <gqjiang@suse.com>
Date:   Thu Oct 18 16:37:43 2018 +0800

    md-cluster: introduce resync_info_get interface for sanity check
    
    Since the resync region from suspend_info means one node
    is reshaping this area, so the position of reshape_progress
    should be included in the area.
    
    Reviewed-by: NeilBrown <neilb@suse.com>
    Signed-off-by: Guoqing Jiang <gqjiang@suse.com>
    Signed-off-by: Shaohua Li <shli@fb.com>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
index 9bd753a6a94e..a78e3021775d 100644
--- a/drivers/md/md-cluster.h
+++ b/drivers/md/md-cluster.h
@@ -14,6 +14,7 @@ struct md_cluster_operations {
 	int (*leave)(struct mddev *mddev);
 	int (*slot_number)(struct mddev *mddev);
 	int (*resync_info_update)(struct mddev *mddev, sector_t lo, sector_t hi);
+	void (*resync_info_get)(struct mddev *mddev, sector_t *lo, sector_t *hi);
 	int (*metadata_update_start)(struct mddev *mddev);
 	int (*metadata_update_finish)(struct mddev *mddev);
 	void (*metadata_update_cancel)(struct mddev *mddev);

commit afd75628608337cf427a1f9ca0e46698a74f25d8
Author: Guoqing Jiang <gqjiang@suse.com>
Date:   Thu Oct 18 16:37:41 2018 +0800

    md-cluster/raid10: resize all the bitmaps before start reshape
    
    To support add disk under grow mode, we need to resize
    all the bitmaps of each node before reshape, so that we
    can ensure all nodes have the same view of the bitmap of
    the clustered raid.
    
    So after the master node resized the bitmap, it broadcast
    a message to other slave nodes, and it checks the size of
    each bitmap are same or not by compare pages. We can only
    continue the reshaping after all nodes update the bitmap
    to the same size (by checking the pages), otherwise revert
    bitmap size to previous value.
    
    The resize_bitmaps interface and BITMAP_RESIZE message are
    introduced in md-cluster.c for the purpose.
    
    Reviewed-by: NeilBrown <neilb@suse.com>
    Signed-off-by: Guoqing Jiang <gqjiang@suse.com>
    Signed-off-by: Shaohua Li <shli@fb.com>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
index c0240708f443..9bd753a6a94e 100644
--- a/drivers/md/md-cluster.h
+++ b/drivers/md/md-cluster.h
@@ -26,6 +26,7 @@ struct md_cluster_operations {
 	int (*remove_disk)(struct mddev *mddev, struct md_rdev *rdev);
 	void (*load_bitmaps)(struct mddev *mddev, int total_slots);
 	int (*gather_bitmaps)(struct md_rdev *rdev);
+	int (*resize_bitmaps)(struct mddev *mddev, sector_t newsize, sector_t oldsize);
 	int (*lock_all_bitmaps)(struct mddev *mddev);
 	void (*unlock_all_bitmaps)(struct mddev *mddev);
 	void (*update_size)(struct mddev *mddev, sector_t old_dev_sectors);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
index 274016177983..c0240708f443 100644
--- a/drivers/md/md-cluster.h
+++ b/drivers/md/md-cluster.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 
 
 #ifndef _MD_CLUSTER_H

commit 818da59f97d6764edb91fa9d1f63d333d54eb999
Author: Guoqing Jiang <gqjiang@suse.com>
Date:   Wed Mar 1 16:42:40 2017 +0800

    md-cluster: add the support for resize
    
    To update size for cluster raid, we need to make
    sure all nodes can perform the change successfully.
    However, it is possible that some of them can't do
    it due to failure (bitmap_resize could fail). So
    we need to consider the issue before we set the
    capacity unconditionally, and we use below steps
    to perform sanity check.
    
    1. A change the size, then broadcast METADATA_UPDATED
       msg.
    2. B and C receive METADATA_UPDATED change the size
       excepts call set_capacity, sync_size is not update
       if the change failed. Also call bitmap_update_sb
       to sync sb to disk.
    3. A checks other node's sync_size, if sync_size has
       been updated in all nodes, then send CHANGE_CAPACITY
       msg otherwise send msg to revert previous change.
    4. B and C call set_capacity if receive CHANGE_CAPACITY
       msg, otherwise pers->resize will be called to restore
       the old value.
    
    Reviewed-by: NeilBrown <neilb@suse.com>
    Signed-off-by: Guoqing Jiang <gqjiang@suse.com>
    Signed-off-by: Shaohua Li <shli@fb.com>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
index e765499ba591..274016177983 100644
--- a/drivers/md/md-cluster.h
+++ b/drivers/md/md-cluster.h
@@ -27,6 +27,7 @@ struct md_cluster_operations {
 	int (*gather_bitmaps)(struct md_rdev *rdev);
 	int (*lock_all_bitmaps)(struct mddev *mddev);
 	void (*unlock_all_bitmaps)(struct mddev *mddev);
+	void (*update_size)(struct mddev *mddev, sector_t old_dev_sectors);
 };
 
 #endif /* _MD_CLUSTER_H */

commit 51e453aecb267b6a99b1d2853bccd5bba7340236
Author: Guoqing Jiang <gqjiang@suse.com>
Date:   Wed May 4 02:17:09 2016 -0400

    md-cluster: gather resync infos and enable recv_thread after bitmap is ready
    
    The in-memory bitmap is not ready when node joins cluster,
    so it doesn't make sense to make gather_all_resync_info()
    called so earlier, we need to call it after the node's
    bitmap is setup. Also, recv_thread could be wake up after
    node joins cluster, but it could cause problem if node
    receives RESYNCING message without persionality since
    mddev->pers->quiesce is called in process_suspend_info.
    
    This commit introduces a new cluster interface load_bitmaps
    to fix above problems, load_bitmaps is called in bitmap_load
    where bitmap and persionality are ready, and load_bitmaps
    does the following tasks:
    
    1. call gather_all_resync_info to load all the node's
       bitmap info.
    2. set MD_CLUSTER_ALREADY_IN_CLUSTER bit to recv_thread
       could be wake up, and wake up recv_thread if there is
       pending recv event.
    
    Then ack_bast only wakes up recv_thread after IN_CLUSTER
    bit is ready otherwise MD_CLUSTER_PENDING_RESYNC_EVENT is
    set.
    
    Reviewed-by: NeilBrown <neilb@suse.com>
    Signed-off-by: Guoqing Jiang <gqjiang@suse.com>
    Signed-off-by: Shaohua Li <shli@fb.com>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
index 45ce6c97d8bd..e765499ba591 100644
--- a/drivers/md/md-cluster.h
+++ b/drivers/md/md-cluster.h
@@ -23,6 +23,7 @@ struct md_cluster_operations {
 	void (*add_new_disk_cancel)(struct mddev *mddev);
 	int (*new_disk_ack)(struct mddev *mddev, bool ack);
 	int (*remove_disk)(struct mddev *mddev, struct md_rdev *rdev);
+	void (*load_bitmaps)(struct mddev *mddev, int total_slots);
 	int (*gather_bitmaps)(struct md_rdev *rdev);
 	int (*lock_all_bitmaps)(struct mddev *mddev);
 	void (*unlock_all_bitmaps)(struct mddev *mddev);

commit f6a2dc64ee74477c966f5220b1f560ed6308d010
Author: Guoqing Jiang <gqjiang@suse.com>
Date:   Mon Dec 21 10:51:00 2015 +1100

    md-cluster: append some actions when change bitmap from clustered to none
    
    For clustered raid, we need to do extra actions when change
    bitmap to none.
    
    1. check if all the bitmap lock could be get or not, if yes then
       we can continue the change since cluster raid is only active
       in current node. Otherwise return fail and unlock the related
       bitmap locks
    2. set nodes to 0 and then leave cluster environment.
    3. release other nodes's bitmap lock.
    
    Signed-off-by: Guoqing Jiang <gqjiang@suse.com>
    Signed-off-by: NeilBrown <neilb@suse.com>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
index e75ea2613184..45ce6c97d8bd 100644
--- a/drivers/md/md-cluster.h
+++ b/drivers/md/md-cluster.h
@@ -24,6 +24,8 @@ struct md_cluster_operations {
 	int (*new_disk_ack)(struct mddev *mddev, bool ack);
 	int (*remove_disk)(struct mddev *mddev, struct md_rdev *rdev);
 	int (*gather_bitmaps)(struct md_rdev *rdev);
+	int (*lock_all_bitmaps)(struct mddev *mddev);
+	void (*unlock_all_bitmaps)(struct mddev *mddev);
 };
 
 #endif /* _MD_CLUSTER_H */

commit dbb64f8635f5d68192108b88759a34633a4bd558
Author: Goldwyn Rodrigues <rgoldwyn@suse.com>
Date:   Thu Oct 1 13:20:27 2015 -0500

    md-cluster: Fix adding of new disk with new reload code
    
    Adding the disk worked incorrectly with the new reload code. Fix it:
    
     - No operation should be performed on rdev marked as Candidate
     - After a metadata update operation, kick disk if role is 0xfffe
       else clear Candidate bit and continue with the regular change check.
     - Saving the mode of the lock resource to check if token lock is already
       locked, because it can be called twice while adding a disk. However,
       unlock_comm() must be called only once.
     - add_new_disk() is called by the node initiating the --add operation.
       If it needs to be canceled, call add_new_disk_cancel(). The operation
       is completed by md_update_sb() which will write and unlock the
       communication.
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
index c94172673599..e75ea2613184 100644
--- a/drivers/md/md-cluster.h
+++ b/drivers/md/md-cluster.h
@@ -15,12 +15,12 @@ struct md_cluster_operations {
 	int (*resync_info_update)(struct mddev *mddev, sector_t lo, sector_t hi);
 	int (*metadata_update_start)(struct mddev *mddev);
 	int (*metadata_update_finish)(struct mddev *mddev);
-	int (*metadata_update_cancel)(struct mddev *mddev);
+	void (*metadata_update_cancel)(struct mddev *mddev);
 	int (*resync_start)(struct mddev *mddev);
 	int (*resync_finish)(struct mddev *mddev);
 	int (*area_resyncing)(struct mddev *mddev, int direction, sector_t lo, sector_t hi);
-	int (*add_new_disk_start)(struct mddev *mddev, struct md_rdev *rdev);
-	int (*add_new_disk_finish)(struct mddev *mddev);
+	int (*add_new_disk)(struct mddev *mddev, struct md_rdev *rdev);
+	void (*add_new_disk_cancel)(struct mddev *mddev);
 	int (*new_disk_ack)(struct mddev *mddev, bool ack);
 	int (*remove_disk)(struct mddev *mddev, struct md_rdev *rdev);
 	int (*gather_bitmaps)(struct md_rdev *rdev);

commit c186b128cda5a246da25f474e4689cb2bfacfcac
Author: Goldwyn Rodrigues <rgoldwyn@suse.com>
Date:   Wed Sep 30 13:20:35 2015 -0500

    md-cluster: Perform resync/recovery under a DLM lock
    
    Resync or recovery must be performed by only one node at a time.
    A DLM lock resource, resync_lockres provides the mutual exclusion
    so that only one node performs the recovery/resync at a time.
    
    If a node is unable to get the resync_lockres, because recovery is
    being performed by another node, it set MD_RECOVER_NEEDED so as
    to schedule recovery in the future.
    
    Remove the debug message in resync_info_update()
    used during development.
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
index f5bdc0c86eaa..c94172673599 100644
--- a/drivers/md/md-cluster.h
+++ b/drivers/md/md-cluster.h
@@ -16,6 +16,8 @@ struct md_cluster_operations {
 	int (*metadata_update_start)(struct mddev *mddev);
 	int (*metadata_update_finish)(struct mddev *mddev);
 	int (*metadata_update_cancel)(struct mddev *mddev);
+	int (*resync_start)(struct mddev *mddev);
+	int (*resync_finish)(struct mddev *mddev);
 	int (*area_resyncing)(struct mddev *mddev, int direction, sector_t lo, sector_t hi);
 	int (*add_new_disk_start)(struct mddev *mddev, struct md_rdev *rdev);
 	int (*add_new_disk_finish)(struct mddev *mddev);

commit c40f341f1e7fd4eddcfc5881d94cfa8669071ee6
Author: Goldwyn Rodrigues <rgoldwyn@suse.com>
Date:   Wed Aug 19 08:14:42 2015 +1000

    md-cluster: Use a small window for resync
    
    Suspending the entire device for resync could take too long. Resync
    in small chunks.
    
    cluster's resync window (32M) is maintained in r1conf as
    cluster_sync_low and cluster_sync_high and processed in
    raid1's sync_request(). If the current resync is outside the cluster
    resync window:
    
    1. Set the cluster_sync_low to curr_resync_completed.
    2. Check if the sync will fit in the new window, if not issue a
       wait_barrier() and set cluster_sync_low to sector_nr.
    3. Set cluster_sync_high to cluster_sync_low + resync_window.
    4. Send a message to all nodes so they may add it in their suspension
       list.
    
    bitmap_cond_end_sync is modified to allow to force a sync inorder
    to get the curr_resync_completed uptodate with the sector passed.
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
index 00defe2badbc..f5bdc0c86eaa 100644
--- a/drivers/md/md-cluster.h
+++ b/drivers/md/md-cluster.h
@@ -12,9 +12,7 @@ struct md_cluster_operations {
 	int (*join)(struct mddev *mddev, int nodes);
 	int (*leave)(struct mddev *mddev);
 	int (*slot_number)(struct mddev *mddev);
-	void (*resync_info_update)(struct mddev *mddev, sector_t lo, sector_t hi);
-	int (*resync_start)(struct mddev *mddev, sector_t lo, sector_t hi);
-	void (*resync_finish)(struct mddev *mddev);
+	int (*resync_info_update)(struct mddev *mddev, sector_t lo, sector_t hi);
 	int (*metadata_update_start)(struct mddev *mddev);
 	int (*metadata_update_finish)(struct mddev *mddev);
 	int (*metadata_update_cancel)(struct mddev *mddev);

commit 90382ed9afeafd42ef193f0eadc6b2a252d6c24d
Author: Goldwyn Rodrigues <rgoldwyn@suse.com>
Date:   Wed Jun 24 09:30:32 2015 -0500

    Fix read-balancing during node failure
    
    During a node failure, We need to suspend read balancing so that the
    reads are directed to the first device and stale data is not read.
    Suspending writes is not required because these would be recorded and
    synced eventually.
    
    A new flag MD_CLUSTER_SUSPEND_READ_BALANCING is set in recover_prep().
    area_resyncing() will respond true for the entire devices if this
    flag is set and the request type is READ. The flag is cleared
    in recover_done().
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
    Reported-By: David Teigland <teigland@redhat.com>
    Signed-off-by: NeilBrown <neilb@suse.com>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
index 6817ee00e053..00defe2badbc 100644
--- a/drivers/md/md-cluster.h
+++ b/drivers/md/md-cluster.h
@@ -18,7 +18,7 @@ struct md_cluster_operations {
 	int (*metadata_update_start)(struct mddev *mddev);
 	int (*metadata_update_finish)(struct mddev *mddev);
 	int (*metadata_update_cancel)(struct mddev *mddev);
-	int (*area_resyncing)(struct mddev *mddev, sector_t lo, sector_t hi);
+	int (*area_resyncing)(struct mddev *mddev, int direction, sector_t lo, sector_t hi);
 	int (*add_new_disk_start)(struct mddev *mddev, struct md_rdev *rdev);
 	int (*add_new_disk_finish)(struct mddev *mddev);
 	int (*new_disk_ack)(struct mddev *mddev, bool ack);

commit 97f6cd39da227459cb46ed4088d37d5d8db51c50
Author: Goldwyn Rodrigues <rgoldwyn@suse.de>
Date:   Tue Apr 14 10:45:42 2015 -0500

    md-cluster: re-add capabilities
    
    When "re-add" is writted to /sys/block/mdXX/md/dev-YYY/state,
    the clustered md:
    
    1. Sends RE_ADD message with the desc_nr. Nodes receiving the message
       clear the Faulty bit in their respective rdev->flags.
    2. The node initiating re-add, gathers the bitmaps of all nodes
       and copies them into the local bitmap. It does not clear the bitmap
       from which it is copying.
    3. Initiating node schedules a md recovery to sync the devices.
    
    Signed-off-by: Guoqing Jiang <gqjiang@suse.com>
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
index 71e51432c1f4..6817ee00e053 100644
--- a/drivers/md/md-cluster.h
+++ b/drivers/md/md-cluster.h
@@ -23,6 +23,7 @@ struct md_cluster_operations {
 	int (*add_new_disk_finish)(struct mddev *mddev);
 	int (*new_disk_ack)(struct mddev *mddev, bool ack);
 	int (*remove_disk)(struct mddev *mddev, struct md_rdev *rdev);
+	int (*gather_bitmaps)(struct md_rdev *rdev);
 };
 
 #endif /* _MD_CLUSTER_H */

commit 88bcfef7be513e8bf5448e0025330fdd97c4c708
Author: Goldwyn Rodrigues <rgoldwyn@suse.de>
Date:   Tue Apr 14 10:44:44 2015 -0500

    md-cluster: remove capabilities
    
    This adds "remove" capabilities for the clustered environment.
    When a user initiates removal of a device from the array, a
    REMOVE message with disk number in the array is sent to all
    the nodes which kick the respective device in their own array.
    
    This facilitates the removal of failed devices.
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
index 7417133c4295..71e51432c1f4 100644
--- a/drivers/md/md-cluster.h
+++ b/drivers/md/md-cluster.h
@@ -22,6 +22,7 @@ struct md_cluster_operations {
 	int (*add_new_disk_start)(struct mddev *mddev, struct md_rdev *rdev);
 	int (*add_new_disk_finish)(struct mddev *mddev);
 	int (*new_disk_ack)(struct mddev *mddev, bool ack);
+	int (*remove_disk)(struct mddev *mddev, struct md_rdev *rdev);
 };
 
 #endif /* _MD_CLUSTER_H */

commit fa8259da0e10b189e41ee60907ec2a499bb66019
Author: Goldwyn Rodrigues <rgoldwyn@suse.de>
Date:   Mon Mar 2 10:55:49 2015 -0600

    md: Fix stray --cluster-confirm crash
    
    A --cluster-confirm without an --add (by another node) can
    crash the kernel.
    
    Fix it by guarding it using a state.
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
    Signed-off-by: NeilBrown <neilb@suse.de>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
index 60d7e58964f5..7417133c4295 100644
--- a/drivers/md/md-cluster.h
+++ b/drivers/md/md-cluster.h
@@ -21,7 +21,7 @@ struct md_cluster_operations {
 	int (*area_resyncing)(struct mddev *mddev, sector_t lo, sector_t hi);
 	int (*add_new_disk_start)(struct mddev *mddev, struct md_rdev *rdev);
 	int (*add_new_disk_finish)(struct mddev *mddev);
-	void (*new_disk_ack)(struct mddev *mddev, bool ack);
+	int (*new_disk_ack)(struct mddev *mddev, bool ack);
 };
 
 #endif /* _MD_CLUSTER_H */

commit 1aee41f637694d4bbf91c24195f2b63e3f6badd2
Author: Goldwyn Rodrigues <rgoldwyn@suse.com>
Date:   Wed Oct 29 18:51:31 2014 -0500

    Add new disk to clustered array
    
    Algorithm:
    1. Node 1 issues mdadm --manage /dev/mdX --add /dev/sdYY which issues
       ioctl(ADD_NEW_DISC with disc.state set to MD_DISK_CLUSTER_ADD)
    2. Node 1 sends NEWDISK with uuid and slot number
    3. Other nodes issue kobject_uevent_env with uuid and slot number
    (Steps 4,5 could be a udev rule)
    4. In userspace, the node searches for the disk, perhaps
       using blkid -t SUB_UUID=""
    5. Other nodes issue either of the following depending on whether the disk
       was found:
       ioctl(ADD_NEW_DISK with disc.state set to MD_DISK_CANDIDATE and
             disc.number set to slot number)
       ioctl(CLUSTERED_DISK_NACK)
    6. Other nodes drop lock on no-new-devs (CR) if device is found
    7. Node 1 attempts EX lock on no-new-devs
    8. If node 1 gets the lock, it sends METADATA_UPDATED after unmarking the disk
       as SpareLocal
    9. If not (get no-new-dev lock), it fails the operation and sends METADATA_UPDATED
    10. Other nodes understand if the device is added or not by reading the superblock again after receiving the METADATA_UPDATED message.
    
    Signed-off-by: Lidong Zhong <lzhong@suse.com>
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
index 03785402afaa..60d7e58964f5 100644
--- a/drivers/md/md-cluster.h
+++ b/drivers/md/md-cluster.h
@@ -6,6 +6,7 @@
 #include "md.h"
 
 struct mddev;
+struct md_rdev;
 
 struct md_cluster_operations {
 	int (*join)(struct mddev *mddev, int nodes);
@@ -18,6 +19,9 @@ struct md_cluster_operations {
 	int (*metadata_update_finish)(struct mddev *mddev);
 	int (*metadata_update_cancel)(struct mddev *mddev);
 	int (*area_resyncing)(struct mddev *mddev, sector_t lo, sector_t hi);
+	int (*add_new_disk_start)(struct mddev *mddev, struct md_rdev *rdev);
+	int (*add_new_disk_finish)(struct mddev *mddev);
+	void (*new_disk_ack)(struct mddev *mddev, bool ack);
 };
 
 #endif /* _MD_CLUSTER_H */

commit 589a1c491621ab81a1955d17d634636522c1b4c1
Author: Goldwyn Rodrigues <rgoldwyn@suse.com>
Date:   Sat Jun 7 02:39:37 2014 -0500

    Suspend writes in RAID1 if within range
    
    If there is a resync going on, all nodes must suspend writes to the
    range. This is recorded in the suspend_info/suspend_list.
    
    If there is an I/O within the ranges of any of the suspend_info,
    should_suspend will return 1.
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
index 054f9eafa065..03785402afaa 100644
--- a/drivers/md/md-cluster.h
+++ b/drivers/md/md-cluster.h
@@ -17,6 +17,7 @@ struct md_cluster_operations {
 	int (*metadata_update_start)(struct mddev *mddev);
 	int (*metadata_update_finish)(struct mddev *mddev);
 	int (*metadata_update_cancel)(struct mddev *mddev);
+	int (*area_resyncing)(struct mddev *mddev, sector_t lo, sector_t hi);
 };
 
 #endif /* _MD_CLUSTER_H */

commit 965400eb615dfb32d62cb3319a895bd94eb9f3b4
Author: Goldwyn Rodrigues <rgoldwyn@suse.com>
Date:   Sat Jun 7 02:16:58 2014 -0500

    Send RESYNCING while performing resync start/stop
    
    When a resync is initiated, RESYNCING message is sent to all active
    nodes with the range (lo,hi). When the resync is over, a RESYNCING
    message is sent with (0,0). A high sector value of zero indicates
    that the resync is over.
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
index 658982afcf9b..054f9eafa065 100644
--- a/drivers/md/md-cluster.h
+++ b/drivers/md/md-cluster.h
@@ -12,6 +12,8 @@ struct md_cluster_operations {
 	int (*leave)(struct mddev *mddev);
 	int (*slot_number)(struct mddev *mddev);
 	void (*resync_info_update)(struct mddev *mddev, sector_t lo, sector_t hi);
+	int (*resync_start)(struct mddev *mddev, sector_t lo, sector_t hi);
+	void (*resync_finish)(struct mddev *mddev);
 	int (*metadata_update_start)(struct mddev *mddev);
 	int (*metadata_update_finish)(struct mddev *mddev);
 	int (*metadata_update_cancel)(struct mddev *mddev);

commit 293467aa1f161cd50920ccf7fc1efa3946a4d50c
Author: Goldwyn Rodrigues <rgoldwyn@suse.com>
Date:   Sat Jun 7 01:44:51 2014 -0500

    metadata_update sends message to other nodes
    
       - request to send a message
       - make changes to superblock
       - send messages telling everyone that the superblock has changed
       - other nodes all read the superblock
       - other nodes all ack the messages
       - updating node release the "I'm sending a message" resource.
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
index 51a24df15b64..658982afcf9b 100644
--- a/drivers/md/md-cluster.h
+++ b/drivers/md/md-cluster.h
@@ -12,6 +12,9 @@ struct md_cluster_operations {
 	int (*leave)(struct mddev *mddev);
 	int (*slot_number)(struct mddev *mddev);
 	void (*resync_info_update)(struct mddev *mddev, sector_t lo, sector_t hi);
+	int (*metadata_update_start)(struct mddev *mddev);
+	int (*metadata_update_finish)(struct mddev *mddev);
+	int (*metadata_update_cancel)(struct mddev *mddev);
 };
 
 #endif /* _MD_CLUSTER_H */

commit 96ae923ab659e37dd5fc1e05ecbf654e2f94bcbe
Author: Goldwyn Rodrigues <rgoldwyn@suse.com>
Date:   Fri Jun 6 12:35:34 2014 -0500

    Gather on-going resync information of other nodes
    
    When a node joins, it does not know of other nodes performing resync.
    So, each node keeps the resync information in it's LVB. When a new
    node joins, it reads the LVB of each "online" bitmap.
    
    [TODO] The new node attempts to get the PW lock on other bitmap, if
    it is successful, it reads the bitmap and performs the resync (if
    required) on it's behalf.
    
    If the node does not get the PW, it requests CR and reads the LVB
    for the resync information.
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
index 52a21e0d6dbc..51a24df15b64 100644
--- a/drivers/md/md-cluster.h
+++ b/drivers/md/md-cluster.h
@@ -11,6 +11,7 @@ struct md_cluster_operations {
 	int (*join)(struct mddev *mddev, int nodes);
 	int (*leave)(struct mddev *mddev);
 	int (*slot_number)(struct mddev *mddev);
+	void (*resync_info_update)(struct mddev *mddev, sector_t lo, sector_t hi);
 };
 
 #endif /* _MD_CLUSTER_H */

commit cf921cc19cf7c1e99f730a2faa02d80817d684a2
Author: Goldwyn Rodrigues <rgoldwyn@suse.com>
Date:   Sun Mar 30 00:42:49 2014 -0500

    Add node recovery callbacks
    
    DLM offers callbacks when a node fails and the lock remastery
    is performed:
    
    1. recover_prep: called when DLM discovers a node is down
    2. recover_slot: called when DLM identifies the node and recovery
                    can start
    3. recover_done: called when all nodes have completed recover_slot
    
    recover_slot() and recover_done() are also called when the node joins
    initially in order to inform the node with its slot number. These slot
    numbers start from one, so we deduct one to make it start with zero
    which the cluster-md code uses.
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
index aa9f07bd6b96..52a21e0d6dbc 100644
--- a/drivers/md/md-cluster.h
+++ b/drivers/md/md-cluster.h
@@ -8,8 +8,9 @@
 struct mddev;
 
 struct md_cluster_operations {
-	int (*join)(struct mddev *mddev);
+	int (*join)(struct mddev *mddev, int nodes);
 	int (*leave)(struct mddev *mddev);
+	int (*slot_number)(struct mddev *mddev);
 };
 
 #endif /* _MD_CLUSTER_H */

commit edb39c9deda87da5aad9c090e2e8eaf8470c852c
Author: Goldwyn Rodrigues <rgoldwyn@suse.com>
Date:   Sat Mar 29 10:01:53 2014 -0500

    Introduce md_cluster_operations to handle cluster functions
    
    This allows dynamic registering of cluster hooks.
    
    Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>

diff --git a/drivers/md/md-cluster.h b/drivers/md/md-cluster.h
new file mode 100644
index 000000000000..aa9f07bd6b96
--- /dev/null
+++ b/drivers/md/md-cluster.h
@@ -0,0 +1,15 @@
+
+
+#ifndef _MD_CLUSTER_H
+#define _MD_CLUSTER_H
+
+#include "md.h"
+
+struct mddev;
+
+struct md_cluster_operations {
+	int (*join)(struct mddev *mddev);
+	int (*leave)(struct mddev *mddev);
+};
+
+#endif /* _MD_CLUSTER_H */
