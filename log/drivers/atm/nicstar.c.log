commit 8a171c5cc9de7fb0a485341b790aba736978ed73
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Thu Feb 27 18:09:44 2020 -0800

    atm: nicstar: fix if-statement empty body warning
    
    When debugging via PRINTK() is not enabled, make the PRINTK()
    macro be an empty do-while block.
    
    Thix fixes a gcc warning when -Wextra is set:
    ../drivers/atm/nicstar.c:1819:23: warning: suggest braces around empty body in an ‘else’ statement [-Wempty-body]
    
    I have verified that there is no object code change (with gcc 7.5.0).
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Cc: Chas Williams <3chas3@gmail.com>
    Cc: linux-atm-general@lists.sourceforge.net
    Cc: netdev@vger.kernel.org
    Cc: David S. Miller <davem@davemloft.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 8db8c0fb5e2d..7af74fb450a0 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -91,7 +91,7 @@
 #ifdef GENERAL_DEBUG
 #define PRINTK(args...) printk(args)
 #else
-#define PRINTK(args...)
+#define PRINTK(args...) do {} while (0)
 #endif /* GENERAL_DEBUG */
 
 #ifdef EXTRA_DEBUG

commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index ae4aa02e4dc6..8db8c0fb5e2d 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * nicstar.c
  *

commit 9a694c1de396e24565bfd05d0e36f72d10c3bce2
Author: Lance Roy <ldr709@gmail.com>
Date:   Thu Oct 4 00:46:57 2018 -0700

    atm: nicstar: Replace spin_is_locked() with spin_trylock()
    
    ns_poll() used spin_is_locked() + spin_lock() to get achieve the same
    thing as a spin_trylock(), so simplify it by using that instead. This is
    also a step towards possibly removing spin_is_locked().
    
    Signed-off-by: Lance Roy <ldr709@gmail.com>
    Cc: Chas Williams <3chas3@gmail.com>
    Cc: <linux-atm-general@lists.sourceforge.net>
    Cc: <netdev@vger.kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index cbec9adc01c7..ae4aa02e4dc6 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -2689,11 +2689,10 @@ static void ns_poll(struct timer_list *unused)
 	PRINTK("nicstar: Entering ns_poll().\n");
 	for (i = 0; i < num_cards; i++) {
 		card = cards[i];
-		if (spin_is_locked(&card->int_lock)) {
+		if (!spin_trylock_irqsave(&card->int_lock, flags)) {
 			/* Probably it isn't worth spinning */
 			continue;
 		}
-		spin_lock_irqsave(&card->int_lock, flags);
 
 		stat_w = 0;
 		stat_r = readl(card->membase + STAT);

commit e99e88a9d2b067465adaa9c111ada99a041bef9a
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 14:43:17 2017 -0700

    treewide: setup_timer() -> timer_setup()
    
    This converts all remaining cases of the old setup_timer() API into using
    timer_setup(), where the callback argument is the structure already
    holding the struct timer_list. These should have no behavioral changes,
    since they just change which pointer is passed into the callback with
    the same available pointers after conversion. It handles the following
    examples, in addition to some other variations.
    
    Casting from unsigned long:
    
        void my_callback(unsigned long data)
        {
            struct something *ptr = (struct something *)data;
        ...
        }
        ...
        setup_timer(&ptr->my_timer, my_callback, ptr);
    
    and forced object casts:
    
        void my_callback(struct something *ptr)
        {
        ...
        }
        ...
        setup_timer(&ptr->my_timer, my_callback, (unsigned long)ptr);
    
    become:
    
        void my_callback(struct timer_list *t)
        {
            struct something *ptr = from_timer(ptr, t, my_timer);
        ...
        }
        ...
        timer_setup(&ptr->my_timer, my_callback, 0);
    
    Direct function assignments:
    
        void my_callback(unsigned long data)
        {
            struct something *ptr = (struct something *)data;
        ...
        }
        ...
        ptr->my_timer.function = my_callback;
    
    have a temporary cast added, along with converting the args:
    
        void my_callback(struct timer_list *t)
        {
            struct something *ptr = from_timer(ptr, t, my_timer);
        ...
        }
        ...
        ptr->my_timer.function = (TIMER_FUNC_TYPE)my_callback;
    
    And finally, callbacks without a data assignment:
    
        void my_callback(unsigned long data)
        {
        ...
        }
        ...
        setup_timer(&ptr->my_timer, my_callback, 0);
    
    have their argument renamed to verify they're unused during conversion:
    
        void my_callback(struct timer_list *unused)
        {
        ...
        }
        ...
        timer_setup(&ptr->my_timer, my_callback, 0);
    
    The conversion is done with the following Coccinelle script:
    
    spatch --very-quiet --all-includes --include-headers \
            -I ./arch/x86/include -I ./arch/x86/include/generated \
            -I ./include -I ./arch/x86/include/uapi \
            -I ./arch/x86/include/generated/uapi -I ./include/uapi \
            -I ./include/generated/uapi --include ./include/linux/kconfig.h \
            --dir . \
            --cocci-file ~/src/data/timer_setup.cocci
    
    @fix_address_of@
    expression e;
    @@
    
     setup_timer(
    -&(e)
    +&e
     , ...)
    
    // Update any raw setup_timer() usages that have a NULL callback, but
    // would otherwise match change_timer_function_usage, since the latter
    // will update all function assignments done in the face of a NULL
    // function initialization in setup_timer().
    @change_timer_function_usage_NULL@
    expression _E;
    identifier _timer;
    type _cast_data;
    @@
    
    (
    -setup_timer(&_E->_timer, NULL, _E);
    +timer_setup(&_E->_timer, NULL, 0);
    |
    -setup_timer(&_E->_timer, NULL, (_cast_data)_E);
    +timer_setup(&_E->_timer, NULL, 0);
    |
    -setup_timer(&_E._timer, NULL, &_E);
    +timer_setup(&_E._timer, NULL, 0);
    |
    -setup_timer(&_E._timer, NULL, (_cast_data)&_E);
    +timer_setup(&_E._timer, NULL, 0);
    )
    
    @change_timer_function_usage@
    expression _E;
    identifier _timer;
    struct timer_list _stl;
    identifier _callback;
    type _cast_func, _cast_data;
    @@
    
    (
    -setup_timer(&_E->_timer, _callback, _E);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E->_timer, &_callback, _E);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E->_timer, _callback, (_cast_data)_E);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E->_timer, &_callback, (_cast_data)_E);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E->_timer, (_cast_func)_callback, _E);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E->_timer, (_cast_func)&_callback, _E);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E->_timer, (_cast_func)_callback, (_cast_data)_E);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E->_timer, (_cast_func)&_callback, (_cast_data)_E);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E._timer, _callback, (_cast_data)_E);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_E._timer, _callback, (_cast_data)&_E);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_E._timer, &_callback, (_cast_data)_E);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_E._timer, &_callback, (_cast_data)&_E);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_E._timer, (_cast_func)_callback, (_cast_data)_E);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_E._timer, (_cast_func)_callback, (_cast_data)&_E);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_E._timer, (_cast_func)&_callback, (_cast_data)_E);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_E._timer, (_cast_func)&_callback, (_cast_data)&_E);
    +timer_setup(&_E._timer, _callback, 0);
    |
     _E->_timer@_stl.function = _callback;
    |
     _E->_timer@_stl.function = &_callback;
    |
     _E->_timer@_stl.function = (_cast_func)_callback;
    |
     _E->_timer@_stl.function = (_cast_func)&_callback;
    |
     _E._timer@_stl.function = _callback;
    |
     _E._timer@_stl.function = &_callback;
    |
     _E._timer@_stl.function = (_cast_func)_callback;
    |
     _E._timer@_stl.function = (_cast_func)&_callback;
    )
    
    // callback(unsigned long arg)
    @change_callback_handle_cast
     depends on change_timer_function_usage@
    identifier change_timer_function_usage._callback;
    identifier change_timer_function_usage._timer;
    type _origtype;
    identifier _origarg;
    type _handletype;
    identifier _handle;
    @@
    
     void _callback(
    -_origtype _origarg
    +struct timer_list *t
     )
     {
    (
            ... when != _origarg
            _handletype *_handle =
    -(_handletype *)_origarg;
    +from_timer(_handle, t, _timer);
            ... when != _origarg
    |
            ... when != _origarg
            _handletype *_handle =
    -(void *)_origarg;
    +from_timer(_handle, t, _timer);
            ... when != _origarg
    |
            ... when != _origarg
            _handletype *_handle;
            ... when != _handle
            _handle =
    -(_handletype *)_origarg;
    +from_timer(_handle, t, _timer);
            ... when != _origarg
    |
            ... when != _origarg
            _handletype *_handle;
            ... when != _handle
            _handle =
    -(void *)_origarg;
    +from_timer(_handle, t, _timer);
            ... when != _origarg
    )
     }
    
    // callback(unsigned long arg) without existing variable
    @change_callback_handle_cast_no_arg
     depends on change_timer_function_usage &&
                         !change_callback_handle_cast@
    identifier change_timer_function_usage._callback;
    identifier change_timer_function_usage._timer;
    type _origtype;
    identifier _origarg;
    type _handletype;
    @@
    
     void _callback(
    -_origtype _origarg
    +struct timer_list *t
     )
     {
    +       _handletype *_origarg = from_timer(_origarg, t, _timer);
    +
            ... when != _origarg
    -       (_handletype *)_origarg
    +       _origarg
            ... when != _origarg
     }
    
    // Avoid already converted callbacks.
    @match_callback_converted
     depends on change_timer_function_usage &&
                !change_callback_handle_cast &&
                !change_callback_handle_cast_no_arg@
    identifier change_timer_function_usage._callback;
    identifier t;
    @@
    
     void _callback(struct timer_list *t)
     { ... }
    
    // callback(struct something *handle)
    @change_callback_handle_arg
     depends on change_timer_function_usage &&
                !match_callback_converted &&
                !change_callback_handle_cast &&
                !change_callback_handle_cast_no_arg@
    identifier change_timer_function_usage._callback;
    identifier change_timer_function_usage._timer;
    type _handletype;
    identifier _handle;
    @@
    
     void _callback(
    -_handletype *_handle
    +struct timer_list *t
     )
     {
    +       _handletype *_handle = from_timer(_handle, t, _timer);
            ...
     }
    
    // If change_callback_handle_arg ran on an empty function, remove
    // the added handler.
    @unchange_callback_handle_arg
     depends on change_timer_function_usage &&
                change_callback_handle_arg@
    identifier change_timer_function_usage._callback;
    identifier change_timer_function_usage._timer;
    type _handletype;
    identifier _handle;
    identifier t;
    @@
    
     void _callback(struct timer_list *t)
     {
    -       _handletype *_handle = from_timer(_handle, t, _timer);
     }
    
    // We only want to refactor the setup_timer() data argument if we've found
    // the matching callback. This undoes changes in change_timer_function_usage.
    @unchange_timer_function_usage
     depends on change_timer_function_usage &&
                !change_callback_handle_cast &&
                !change_callback_handle_cast_no_arg &&
                !change_callback_handle_arg@
    expression change_timer_function_usage._E;
    identifier change_timer_function_usage._timer;
    identifier change_timer_function_usage._callback;
    type change_timer_function_usage._cast_data;
    @@
    
    (
    -timer_setup(&_E->_timer, _callback, 0);
    +setup_timer(&_E->_timer, _callback, (_cast_data)_E);
    |
    -timer_setup(&_E._timer, _callback, 0);
    +setup_timer(&_E._timer, _callback, (_cast_data)&_E);
    )
    
    // If we fixed a callback from a .function assignment, fix the
    // assignment cast now.
    @change_timer_function_assignment
     depends on change_timer_function_usage &&
                (change_callback_handle_cast ||
                 change_callback_handle_cast_no_arg ||
                 change_callback_handle_arg)@
    expression change_timer_function_usage._E;
    identifier change_timer_function_usage._timer;
    identifier change_timer_function_usage._callback;
    type _cast_func;
    typedef TIMER_FUNC_TYPE;
    @@
    
    (
     _E->_timer.function =
    -_callback
    +(TIMER_FUNC_TYPE)_callback
     ;
    |
     _E->_timer.function =
    -&_callback
    +(TIMER_FUNC_TYPE)_callback
     ;
    |
     _E->_timer.function =
    -(_cast_func)_callback;
    +(TIMER_FUNC_TYPE)_callback
     ;
    |
     _E->_timer.function =
    -(_cast_func)&_callback
    +(TIMER_FUNC_TYPE)_callback
     ;
    |
     _E._timer.function =
    -_callback
    +(TIMER_FUNC_TYPE)_callback
     ;
    |
     _E._timer.function =
    -&_callback;
    +(TIMER_FUNC_TYPE)_callback
     ;
    |
     _E._timer.function =
    -(_cast_func)_callback
    +(TIMER_FUNC_TYPE)_callback
     ;
    |
     _E._timer.function =
    -(_cast_func)&_callback
    +(TIMER_FUNC_TYPE)_callback
     ;
    )
    
    // Sometimes timer functions are called directly. Replace matched args.
    @change_timer_function_calls
     depends on change_timer_function_usage &&
                (change_callback_handle_cast ||
                 change_callback_handle_cast_no_arg ||
                 change_callback_handle_arg)@
    expression _E;
    identifier change_timer_function_usage._timer;
    identifier change_timer_function_usage._callback;
    type _cast_data;
    @@
    
     _callback(
    (
    -(_cast_data)_E
    +&_E->_timer
    |
    -(_cast_data)&_E
    +&_E._timer
    |
    -_E
    +&_E->_timer
    )
     )
    
    // If a timer has been configured without a data argument, it can be
    // converted without regard to the callback argument, since it is unused.
    @match_timer_function_unused_data@
    expression _E;
    identifier _timer;
    identifier _callback;
    @@
    
    (
    -setup_timer(&_E->_timer, _callback, 0);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E->_timer, _callback, 0L);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E->_timer, _callback, 0UL);
    +timer_setup(&_E->_timer, _callback, 0);
    |
    -setup_timer(&_E._timer, _callback, 0);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_E._timer, _callback, 0L);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_E._timer, _callback, 0UL);
    +timer_setup(&_E._timer, _callback, 0);
    |
    -setup_timer(&_timer, _callback, 0);
    +timer_setup(&_timer, _callback, 0);
    |
    -setup_timer(&_timer, _callback, 0L);
    +timer_setup(&_timer, _callback, 0);
    |
    -setup_timer(&_timer, _callback, 0UL);
    +timer_setup(&_timer, _callback, 0);
    |
    -setup_timer(_timer, _callback, 0);
    +timer_setup(_timer, _callback, 0);
    |
    -setup_timer(_timer, _callback, 0L);
    +timer_setup(_timer, _callback, 0);
    |
    -setup_timer(_timer, _callback, 0UL);
    +timer_setup(_timer, _callback, 0);
    )
    
    @change_callback_unused_data
     depends on match_timer_function_unused_data@
    identifier match_timer_function_unused_data._callback;
    type _origtype;
    identifier _origarg;
    @@
    
     void _callback(
    -_origtype _origarg
    +struct timer_list *unused
     )
     {
            ... when != _origarg
     }
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 335447ed0ba4..cbec9adc01c7 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -145,7 +145,7 @@ static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user * arg);
 #ifdef EXTRA_DEBUG
 static void which_list(ns_dev * card, struct sk_buff *skb);
 #endif
-static void ns_poll(unsigned long arg);
+static void ns_poll(struct timer_list *unused);
 static void ns_phy_put(struct atm_dev *dev, unsigned char value,
 		       unsigned long addr);
 static unsigned char ns_phy_get(struct atm_dev *dev, unsigned long addr);
@@ -284,7 +284,7 @@ static int __init nicstar_init(void)
 	XPRINTK("nicstar: nicstar_init() returned.\n");
 
 	if (!error) {
-		setup_timer(&ns_timer, ns_poll, 0UL);
+		timer_setup(&ns_timer, ns_poll, 0);
 		ns_timer.expires = jiffies + NS_POLL_PERIOD;
 		add_timer(&ns_timer);
 	}
@@ -2679,7 +2679,7 @@ static void which_list(ns_dev * card, struct sk_buff *skb)
 }
 #endif /* EXTRA_DEBUG */
 
-static void ns_poll(unsigned long arg)
+static void ns_poll(struct timer_list *unused)
 {
 	int i;
 	ns_dev *card;

commit b9eaf18722221ef8b2bd6a67240ebe668622152a
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 13:15:39 2017 -0700

    treewide: init_timer() -> setup_timer()
    
    This mechanically converts all remaining cases of ancient open-coded timer
    setup with the old setup_timer() API, which is the first step in timer
    conversions. This has no behavioral changes, since it ultimately just
    changes the order of assignment to fields of struct timer_list when
    finding variations of:
    
        init_timer(&t);
        f.function = timer_callback;
        t.data = timer_callback_arg;
    
    to be converted into:
    
        setup_timer(&t, timer_callback, timer_callback_arg);
    
    The conversion is done with the following Coccinelle script, which
    is an improved version of scripts/cocci/api/setup_timer.cocci, in the
    following ways:
     - assignments-before-init_timer() cases
     - limit the .data case removal to the specific struct timer_list instance
     - handling calls by dereference (timer->field vs timer.field)
    
    spatch --very-quiet --all-includes --include-headers \
            -I ./arch/x86/include -I ./arch/x86/include/generated \
            -I ./include -I ./arch/x86/include/uapi \
            -I ./arch/x86/include/generated/uapi -I ./include/uapi \
            -I ./include/generated/uapi --include ./include/linux/kconfig.h \
            --dir . \
            --cocci-file ~/src/data/setup_timer.cocci
    
    @fix_address_of@
    expression e;
    @@
    
     init_timer(
    -&(e)
    +&e
     , ...)
    
    // Match the common cases first to avoid Coccinelle parsing loops with
    // "... when" clauses.
    
    @match_immediate_function_data_after_init_timer@
    expression e, func, da;
    @@
    
    -init_timer
    +setup_timer
     ( \(&e\|e\)
    +, func, da
     );
    (
    -\(e.function\|e->function\) = func;
    -\(e.data\|e->data\) = da;
    |
    -\(e.data\|e->data\) = da;
    -\(e.function\|e->function\) = func;
    )
    
    @match_immediate_function_data_before_init_timer@
    expression e, func, da;
    @@
    
    (
    -\(e.function\|e->function\) = func;
    -\(e.data\|e->data\) = da;
    |
    -\(e.data\|e->data\) = da;
    -\(e.function\|e->function\) = func;
    )
    -init_timer
    +setup_timer
     ( \(&e\|e\)
    +, func, da
     );
    
    @match_function_and_data_after_init_timer@
    expression e, e2, e3, e4, e5, func, da;
    @@
    
    -init_timer
    +setup_timer
     ( \(&e\|e\)
    +, func, da
     );
     ... when != func = e2
         when != da = e3
    (
    -e.function = func;
    ... when != da = e4
    -e.data = da;
    |
    -e->function = func;
    ... when != da = e4
    -e->data = da;
    |
    -e.data = da;
    ... when != func = e5
    -e.function = func;
    |
    -e->data = da;
    ... when != func = e5
    -e->function = func;
    )
    
    @match_function_and_data_before_init_timer@
    expression e, e2, e3, e4, e5, func, da;
    @@
    (
    -e.function = func;
    ... when != da = e4
    -e.data = da;
    |
    -e->function = func;
    ... when != da = e4
    -e->data = da;
    |
    -e.data = da;
    ... when != func = e5
    -e.function = func;
    |
    -e->data = da;
    ... when != func = e5
    -e->function = func;
    )
    ... when != func = e2
        when != da = e3
    -init_timer
    +setup_timer
     ( \(&e\|e\)
    +, func, da
     );
    
    @r1 exists@
    expression t;
    identifier f;
    position p;
    @@
    
    f(...) { ... when any
      init_timer@p(\(&t\|t\))
      ... when any
    }
    
    @r2 exists@
    expression r1.t;
    identifier g != r1.f;
    expression e8;
    @@
    
    g(...) { ... when any
      \(t.data\|t->data\) = e8
      ... when any
    }
    
    // It is dangerous to use setup_timer if data field is initialized
    // in another function.
    @script:python depends on r2@
    p << r1.p;
    @@
    
    cocci.include_match(False)
    
    @r3@
    expression r1.t, func, e7;
    position r1.p;
    @@
    
    (
    -init_timer@p(&t);
    +setup_timer(&t, func, 0UL);
    ... when != func = e7
    -t.function = func;
    |
    -t.function = func;
    ... when != func = e7
    -init_timer@p(&t);
    +setup_timer(&t, func, 0UL);
    |
    -init_timer@p(t);
    +setup_timer(t, func, 0UL);
    ... when != func = e7
    -t->function = func;
    |
    -t->function = func;
    ... when != func = e7
    -init_timer@p(t);
    +setup_timer(t, func, 0UL);
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index a9702836cbae..335447ed0ba4 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -284,10 +284,8 @@ static int __init nicstar_init(void)
 	XPRINTK("nicstar: nicstar_init() returned.\n");
 
 	if (!error) {
-		init_timer(&ns_timer);
+		setup_timer(&ns_timer, ns_poll, 0UL);
 		ns_timer.expires = jiffies + NS_POLL_PERIOD;
-		ns_timer.data = 0UL;
-		ns_timer.function = ns_poll;
 		add_timer(&ns_timer);
 	}
 

commit 46c4b7a5694ccfdc2659fc8beb8736d7fb1c9841
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Wed Aug 9 14:49:15 2017 +0530

    atm: make atmdev_ops const
    
    Make these structures const as they are either passed to the function
    atm_dev_register having the corresponding argument as const or stored in
    the ops field of a atm_dev structure, which is also const.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 9588d80f318e..a9702836cbae 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -154,7 +154,7 @@ static unsigned char ns_phy_get(struct atm_dev *dev, unsigned long addr);
 
 static struct ns_dev *cards[NS_MAX_CARDS];
 static unsigned num_cards;
-static struct atmdev_ops atm_ops = {
+static const struct atmdev_ops atm_ops = {
 	.open = ns_open,
 	.close = ns_close,
 	.ioctl = ns_ioctl,

commit 2f3e2604fb579e34f775c799eba2afdfcb97fd66
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Sun Jul 16 15:02:32 2017 +0530

    atm: nicstar: constify pci_device_id.
    
    pci_device_id are not supposed to change at runtime. All functions
    working with pci_device_id provided by <linux/pci.h> work with
    const pci_device_id. So mark the non-const structs as const.
    
    File size before:
       text    data     bss     dec     hex filename
      22781     464     128   23373    5b4d drivers/atm/nicstar.o
    
    File size After adding 'const':
       text    data     bss     dec     hex filename
      22845     400     128   23373    5b4d drivers/atm/nicstar.o
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index d879f3bca107..9588d80f318e 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -253,7 +253,7 @@ static void nicstar_remove_one(struct pci_dev *pcidev)
 	kfree(card);
 }
 
-static struct pci_device_id nicstar_pci_tbl[] = {
+static const struct pci_device_id nicstar_pci_tbl[] = {
 	{ PCI_VDEVICE(IDT, PCI_DEVICE_ID_IDT_IDT77201), 0 },
 	{0,}			/* terminate list */
 };

commit d3e709e63e97e5f3f129b639991cfe266da60bae
Author: Matthew Wilcox <mawilcox@microsoft.com>
Date:   Thu Dec 22 13:30:22 2016 -0500

    idr: Return the deleted entry from idr_remove
    
    It is a relatively common idiom (8 instances) to first look up an IDR
    entry, and then remove it from the tree if it is found, possibly doing
    further operations upon the entry afterwards.  If we change idr_remove()
    to return the removed object, all of these users can save themselves a
    walk of the IDR tree.
    
    Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index cb28579e8a94..d879f3bca107 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -1980,13 +1980,12 @@ static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 	card->lbfqc = ns_stat_lfbqc_get(stat);
 
 	id = le32_to_cpu(rsqe->buffer_handle);
-	skb = idr_find(&card->idr, id);
+	skb = idr_remove(&card->idr, id);
 	if (!skb) {
 		RXPRINTK(KERN_ERR
-			 "nicstar%d: idr_find() failed!\n", card->index);
+			 "nicstar%d: skb not found!\n", card->index);
 		return;
 	}
-	idr_remove(&card->idr, id);
 	dma_sync_single_for_cpu(&card->pcidev->dev,
 				NS_PRV_DMA(skb),
 				(NS_PRV_BUFTYPE(skb) == BUF_SM

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index c7296b583787..cb28579e8a94 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -50,7 +50,7 @@
 #include <linux/slab.h>
 #include <linux/idr.h>
 #include <asm/io.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <linux/atomic.h>
 #include <linux/etherdevice.h>
 #include "nicstar.h"

commit 0ba8abb770a8771ffb05cce2a5a7441530f06a55
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Sep 10 08:56:03 2016 +0200

    ATM-nicstar: Refactor a dev_alloc_skb() call in dequeue_rx()
    
    The script "checkpatch.pl" can point out that assignments should usually
    not be performed within condition checks.
    Thus move an assignment for a local variable to a separate statement
    in this function.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 04f5781dca30..c7296b583787 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -2023,7 +2023,8 @@ static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 
 		cell = skb->data;
 		for (i = ns_rsqe_cellcount(rsqe); i; i--) {
-			if ((sb = dev_alloc_skb(NS_SMSKBSIZE)) == NULL) {
+			sb = dev_alloc_skb(NS_SMSKBSIZE);
+			if (!sb) {
 				printk
 				    ("nicstar%d: Can't allocate buffers for aal0.\n",
 				     card->index);

commit 304f0a4edbbb2d273d7c6043df4126b623cd472c
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Sep 10 08:48:17 2016 +0200

    ATM-nicstar: Refactor a kmalloc() call in ns_init_card()
    
    * The script "checkpatch.pl" can point out that assignments should usually
      not be performed within condition checks.
      Thus move an assignment for a local variable to a separate statement
      in this function.
    
    * Replace the specification of a data structure by a pointer dereference
      as the parameter for the operator "sizeof" to make the corresponding size
      determination a bit safer according to the Linux coding style convention.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index ef977bf54a40..04f5781dca30 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -370,7 +370,8 @@ static int ns_init_card(int i, struct pci_dev *pcidev)
 		return error;
         }
 
-	if ((card = kmalloc(sizeof(ns_dev), GFP_KERNEL)) == NULL) {
+	card = kmalloc(sizeof(*card), GFP_KERNEL);
+	if (!card) {
 		printk
 		    ("nicstar%d: can't allocate memory for device structure.\n",
 		     i);

commit ee41f07c2f2c944465ade7c9591a6139a783be41
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Sep 10 08:30:09 2016 +0200

    ATM-nicstar: Improve another size determination in ns_init_card()
    
    Replace the specification of a data structure by a reference for a field
    in a local variable as the parameter for the operator "sizeof" to make
    the corresponding size determination a bit safer according to
    the Linux coding style convention.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 96062e10c8eb..ef977bf54a40 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -611,7 +611,7 @@ static int ns_init_card(int i, struct pci_dev *pcidev)
 	for (j = 0; j < card->rct_size; j++)
 		ns_write_sram(card, j * 4, u32d, 4);
 
-	memset(card->vcmap, 0, NS_MAX_RCTSIZE * sizeof(vc_map));
+	memset(card->vcmap, 0, sizeof(card->vcmap));
 
 	for (j = 0; j < NS_FRSCD_NUM; j++)
 		card->scd2vc[j] = NULL;

commit 24310fd565b16ec7c39e3db5b0240f0cdbbd0475
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Sep 10 08:18:10 2016 +0200

    ATM-nicstar: Improve another size determination in get_scq()
    
    Replace the specification of a data structure by a pointer dereference
    as the parameter for the operator "sizeof" to make the corresponding size
    determination a bit safer according to the Linux coding style convention.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 50dec1349e14..96062e10c8eb 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -862,7 +862,7 @@ static scq_info *get_scq(ns_dev *card, int size, u32 scd)
 	if (size != VBR_SCQSIZE && size != CBR_SCQSIZE)
 		return NULL;
 
-	scq = kmalloc(sizeof(scq_info), GFP_KERNEL);
+	scq = kmalloc(sizeof(*scq), GFP_KERNEL);
 	if (!scq)
 		return NULL;
         scq->org = dma_alloc_coherent(&card->pcidev->dev,

commit 78706121d59d0692534d087df6eefef5469fc5a1
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Sep 10 08:02:06 2016 +0200

    ATM-nicstar: Use kmalloc_array() in get_scq()
    
    * A multiplication for the size determination of a memory allocation
      indicated that an array data structure should be processed.
      Thus use the corresponding function "kmalloc_array".
    
      This issue was detected by using the Coccinelle software.
    
    * Replace the specification of a data type by a pointer dereference
      to make the corresponding size determination a bit safer according to
      the Linux coding style convention.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 700ed15c2362..50dec1349e14 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -871,8 +871,9 @@ static scq_info *get_scq(ns_dev *card, int size, u32 scd)
 		kfree(scq);
 		return NULL;
 	}
-	scq->skb = kmalloc(sizeof(struct sk_buff *) *
-			   (size / NS_SCQE_SIZE), GFP_KERNEL);
+	scq->skb = kmalloc_array(size / NS_SCQE_SIZE,
+				 sizeof(*scq->skb),
+				 GFP_KERNEL);
 	if (!scq->skb) {
 		dma_free_coherent(&card->pcidev->dev,
 				  2 * size, scq->org, scq->dma);

commit eab814661945656d35d4a0e5870e932cd7139977
Author: Christophe Jaillet <christophe.jaillet@wanadoo.fr>
Date:   Sun Jul 17 09:03:24 2016 +0200

    drivers: atm: nicstar: Use the correct function to free some resources
    
    In 'get_scq', 'dma_alloc_coherent' has been used to allocate some
    resources, so we need to free them using 'dma_free_coherent' instead
    of 'kfree'.
    
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index ddc4ceb85fc5..700ed15c2362 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -874,7 +874,8 @@ static scq_info *get_scq(ns_dev *card, int size, u32 scd)
 	scq->skb = kmalloc(sizeof(struct sk_buff *) *
 			   (size / NS_SCQE_SIZE), GFP_KERNEL);
 	if (!scq->skb) {
-		kfree(scq->org);
+		dma_free_coherent(&card->pcidev->dev,
+				  2 * size, scq->org, scq->dma);
 		kfree(scq);
 		return NULL;
 	}

commit 3855634deb051bbce155d149bca05b99a3528d5d
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Mar 10 04:56:53 2015 +0100

    drivers: atm: nicstar: remove ifdef'd out skb destructors
    
    remove dead code.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index b7e1cc0a97c8..ddc4ceb85fc5 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -73,9 +73,6 @@
 #undef GENERAL_DEBUG
 #undef EXTRA_DEBUG
 
-#undef NS_USE_DESTRUCTORS	/* For now keep this undefined unless you know
-				   you're going to use only raw ATM */
-
 /* Do not touch these */
 
 #ifdef TX_DEBUG
@@ -138,11 +135,6 @@ static void process_tsq(ns_dev * card);
 static void drain_scq(ns_dev * card, scq_info * scq, int pos);
 static void process_rsq(ns_dev * card);
 static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe);
-#ifdef NS_USE_DESTRUCTORS
-static void ns_sb_destructor(struct sk_buff *sb);
-static void ns_lb_destructor(struct sk_buff *lb);
-static void ns_hb_destructor(struct sk_buff *hb);
-#endif /* NS_USE_DESTRUCTORS */
 static void recycle_rx_buf(ns_dev * card, struct sk_buff *skb);
 static void recycle_iovec_rx_bufs(ns_dev * card, struct iovec *iov, int count);
 static void recycle_iov_buf(ns_dev * card, struct sk_buff *iovb);
@@ -2169,9 +2161,6 @@ static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 			} else {
 				skb_put(skb, len);
 				dequeue_sm_buf(card, skb);
-#ifdef NS_USE_DESTRUCTORS
-				skb->destructor = ns_sb_destructor;
-#endif /* NS_USE_DESTRUCTORS */
 				ATM_SKB(skb)->vcc = vcc;
 				__net_timestamp(skb);
 				vcc->push(vcc, skb);
@@ -2190,9 +2179,6 @@ static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 				} else {
 					skb_put(sb, len);
 					dequeue_sm_buf(card, sb);
-#ifdef NS_USE_DESTRUCTORS
-					sb->destructor = ns_sb_destructor;
-#endif /* NS_USE_DESTRUCTORS */
 					ATM_SKB(sb)->vcc = vcc;
 					__net_timestamp(sb);
 					vcc->push(vcc, sb);
@@ -2208,9 +2194,6 @@ static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 					atomic_inc(&vcc->stats->rx_drop);
 				} else {
 					dequeue_lg_buf(card, skb);
-#ifdef NS_USE_DESTRUCTORS
-					skb->destructor = ns_lb_destructor;
-#endif /* NS_USE_DESTRUCTORS */
 					skb_push(skb, NS_SMBUFSIZE);
 					skb_copy_from_linear_data(sb, skb->data,
 								  NS_SMBUFSIZE);
@@ -2322,9 +2305,6 @@ static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 					     card->index);
 #endif /* EXTRA_DEBUG */
 				ATM_SKB(hb)->vcc = vcc;
-#ifdef NS_USE_DESTRUCTORS
-				hb->destructor = ns_hb_destructor;
-#endif /* NS_USE_DESTRUCTORS */
 				__net_timestamp(hb);
 				vcc->push(vcc, hb);
 				atomic_inc(&vcc->stats->rx);
@@ -2337,68 +2317,6 @@ static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 
 }
 
-#ifdef NS_USE_DESTRUCTORS
-
-static void ns_sb_destructor(struct sk_buff *sb)
-{
-	ns_dev *card;
-	u32 stat;
-
-	card = (ns_dev *) ATM_SKB(sb)->vcc->dev->dev_data;
-	stat = readl(card->membase + STAT);
-	card->sbfqc = ns_stat_sfbqc_get(stat);
-	card->lbfqc = ns_stat_lfbqc_get(stat);
-
-	do {
-		sb = __dev_alloc_skb(NS_SMSKBSIZE, GFP_KERNEL);
-		if (sb == NULL)
-			break;
-		NS_PRV_BUFTYPE(sb) = BUF_SM;
-		skb_queue_tail(&card->sbpool.queue, sb);
-		skb_reserve(sb, NS_AAL0_HEADER);
-		push_rxbufs(card, sb);
-	} while (card->sbfqc < card->sbnr.min);
-}
-
-static void ns_lb_destructor(struct sk_buff *lb)
-{
-	ns_dev *card;
-	u32 stat;
-
-	card = (ns_dev *) ATM_SKB(lb)->vcc->dev->dev_data;
-	stat = readl(card->membase + STAT);
-	card->sbfqc = ns_stat_sfbqc_get(stat);
-	card->lbfqc = ns_stat_lfbqc_get(stat);
-
-	do {
-		lb = __dev_alloc_skb(NS_LGSKBSIZE, GFP_KERNEL);
-		if (lb == NULL)
-			break;
-		NS_PRV_BUFTYPE(lb) = BUF_LG;
-		skb_queue_tail(&card->lbpool.queue, lb);
-		skb_reserve(lb, NS_SMBUFSIZE);
-		push_rxbufs(card, lb);
-	} while (card->lbfqc < card->lbnr.min);
-}
-
-static void ns_hb_destructor(struct sk_buff *hb)
-{
-	ns_dev *card;
-
-	card = (ns_dev *) ATM_SKB(hb)->vcc->dev->dev_data;
-
-	while (card->hbpool.count < card->hbnr.init) {
-		hb = __dev_alloc_skb(NS_HBUFSIZE, GFP_KERNEL);
-		if (hb == NULL)
-			break;
-		NS_PRV_BUFTYPE(hb) = BUF_NONE;
-		skb_queue_tail(&card->hbpool.queue, hb);
-		card->hbpool.count++;
-	}
-}
-
-#endif /* NS_USE_DESTRUCTORS */
-
 static void recycle_rx_buf(ns_dev * card, struct sk_buff *skb)
 {
 	if (unlikely(NS_PRV_BUFTYPE(skb) == BUF_NONE)) {
@@ -2427,9 +2345,6 @@ static void recycle_iov_buf(ns_dev * card, struct sk_buff *iovb)
 static void dequeue_sm_buf(ns_dev * card, struct sk_buff *sb)
 {
 	skb_unlink(sb, &card->sbpool.queue);
-#ifdef NS_USE_DESTRUCTORS
-	if (card->sbfqc < card->sbnr.min)
-#else
 	if (card->sbfqc < card->sbnr.init) {
 		struct sk_buff *new_sb;
 		if ((new_sb = dev_alloc_skb(NS_SMSKBSIZE)) != NULL) {
@@ -2440,7 +2355,6 @@ static void dequeue_sm_buf(ns_dev * card, struct sk_buff *sb)
 		}
 	}
 	if (card->sbfqc < card->sbnr.init)
-#endif /* NS_USE_DESTRUCTORS */
 	{
 		struct sk_buff *new_sb;
 		if ((new_sb = dev_alloc_skb(NS_SMSKBSIZE)) != NULL) {
@@ -2455,9 +2369,6 @@ static void dequeue_sm_buf(ns_dev * card, struct sk_buff *sb)
 static void dequeue_lg_buf(ns_dev * card, struct sk_buff *lb)
 {
 	skb_unlink(lb, &card->lbpool.queue);
-#ifdef NS_USE_DESTRUCTORS
-	if (card->lbfqc < card->lbnr.min)
-#else
 	if (card->lbfqc < card->lbnr.init) {
 		struct sk_buff *new_lb;
 		if ((new_lb = dev_alloc_skb(NS_LGSKBSIZE)) != NULL) {
@@ -2468,7 +2379,6 @@ static void dequeue_lg_buf(ns_dev * card, struct sk_buff *lb)
 		}
 	}
 	if (card->lbfqc < card->lbnr.init)
-#endif /* NS_USE_DESTRUCTORS */
 	{
 		struct sk_buff *new_lb;
 		if ((new_lb = dev_alloc_skb(NS_LGSKBSIZE)) != NULL) {

commit ede58ef28e105de94475b2b69fa069c9a2ce6933
Author: chas williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
Date:   Fri Jan 16 08:57:21 2015 -0500

    atm: remove deprecated use of pci api
    
    Signed-off-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 9988ac98b6d8..b7e1cc0a97c8 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -252,10 +252,10 @@ static void nicstar_remove_one(struct pci_dev *pcidev)
 			free_scq(card, card->scd2vc[j]->scq, card->scd2vc[j]->tx_vcc);
 	}
 	idr_destroy(&card->idr);
-	pci_free_consistent(card->pcidev, NS_RSQSIZE + NS_RSQ_ALIGNMENT,
-			    card->rsq.org, card->rsq.dma);
-	pci_free_consistent(card->pcidev, NS_TSQSIZE + NS_TSQ_ALIGNMENT,
-			    card->tsq.org, card->tsq.dma);
+	dma_free_coherent(&card->pcidev->dev, NS_RSQSIZE + NS_RSQ_ALIGNMENT,
+			  card->rsq.org, card->rsq.dma);
+	dma_free_coherent(&card->pcidev->dev, NS_TSQSIZE + NS_TSQ_ALIGNMENT,
+			  card->tsq.org, card->tsq.dma);
 	free_irq(card->pcidev->irq, card);
 	iounmap(card->membase);
 	kfree(card);
@@ -370,8 +370,7 @@ static int ns_init_card(int i, struct pci_dev *pcidev)
 		ns_init_card_error(card, error);
 		return error;
 	}
-        if ((pci_set_dma_mask(pcidev, DMA_BIT_MASK(32)) != 0) ||
-	    (pci_set_consistent_dma_mask(pcidev, DMA_BIT_MASK(32)) != 0)) {
+        if (dma_set_mask_and_coherent(&pcidev->dev, DMA_BIT_MASK(32)) != 0) {
                 printk(KERN_WARNING
 		       "nicstar%d: No suitable DMA available.\n", i);
 		error = 2;
@@ -535,9 +534,9 @@ static int ns_init_card(int i, struct pci_dev *pcidev)
 	writel(0x00000000, card->membase + VPM);
 
 	/* Initialize TSQ */
-	card->tsq.org = pci_alloc_consistent(card->pcidev,
-					     NS_TSQSIZE + NS_TSQ_ALIGNMENT,
-					     &card->tsq.dma);
+	card->tsq.org = dma_alloc_coherent(&card->pcidev->dev,
+					   NS_TSQSIZE + NS_TSQ_ALIGNMENT,
+					   &card->tsq.dma, GFP_KERNEL);
 	if (card->tsq.org == NULL) {
 		printk("nicstar%d: can't allocate TSQ.\n", i);
 		error = 10;
@@ -554,9 +553,9 @@ static int ns_init_card(int i, struct pci_dev *pcidev)
 	PRINTK("nicstar%d: TSQ base at 0x%p.\n", i, card->tsq.base);
 
 	/* Initialize RSQ */
-	card->rsq.org = pci_alloc_consistent(card->pcidev,
-					     NS_RSQSIZE + NS_RSQ_ALIGNMENT,
-					     &card->rsq.dma);
+	card->rsq.org = dma_alloc_coherent(&card->pcidev->dev,
+					   NS_RSQSIZE + NS_RSQ_ALIGNMENT,
+					   &card->rsq.dma, GFP_KERNEL);
 	if (card->rsq.org == NULL) {
 		printk("nicstar%d: can't allocate RSQ.\n", i);
 		error = 11;
@@ -874,7 +873,8 @@ static scq_info *get_scq(ns_dev *card, int size, u32 scd)
 	scq = kmalloc(sizeof(scq_info), GFP_KERNEL);
 	if (!scq)
 		return NULL;
-        scq->org = pci_alloc_consistent(card->pcidev, 2 * size, &scq->dma);
+        scq->org = dma_alloc_coherent(&card->pcidev->dev,
+				      2 * size,  &scq->dma, GFP_KERNEL);
 	if (!scq->org) {
 		kfree(scq);
 		return NULL;
@@ -936,10 +936,10 @@ static void free_scq(ns_dev *card, scq_info *scq, struct atm_vcc *vcc)
 			}
 	}
 	kfree(scq->skb);
-	pci_free_consistent(card->pcidev,
-			    2 * (scq->num_entries == VBR_SCQ_NUM_ENTRIES ?
-				 VBR_SCQSIZE : CBR_SCQSIZE),
-			    scq->org, scq->dma);
+	dma_free_coherent(&card->pcidev->dev,
+			  2 * (scq->num_entries == VBR_SCQ_NUM_ENTRIES ?
+			       VBR_SCQSIZE : CBR_SCQSIZE),
+			  scq->org, scq->dma);
 	kfree(scq);
 }
 
@@ -957,11 +957,11 @@ static void push_rxbufs(ns_dev * card, struct sk_buff *skb)
 	handle2 = NULL;
 	addr2 = 0;
 	handle1 = skb;
-	addr1 = pci_map_single(card->pcidev,
+	addr1 = dma_map_single(&card->pcidev->dev,
 			       skb->data,
 			       (NS_PRV_BUFTYPE(skb) == BUF_SM
 				? NS_SMSKBSIZE : NS_LGSKBSIZE),
-			       PCI_DMA_TODEVICE);
+			       DMA_TO_DEVICE);
 	NS_PRV_DMA(skb) = addr1; /* save so we can unmap later */
 
 #ifdef GENERAL_DEBUG
@@ -1670,8 +1670,8 @@ static int ns_send(struct atm_vcc *vcc, struct sk_buff *skb)
 
 	ATM_SKB(skb)->vcc = vcc;
 
-	NS_PRV_DMA(skb) = pci_map_single(card->pcidev, skb->data,
-					 skb->len, PCI_DMA_TODEVICE);
+	NS_PRV_DMA(skb) = dma_map_single(&card->pcidev->dev, skb->data,
+					 skb->len, DMA_TO_DEVICE);
 
 	if (vcc->qos.aal == ATM_AAL5) {
 		buflen = (skb->len + 47 + 8) / 48 * 48;	/* Multiple of 48 */
@@ -1930,10 +1930,10 @@ static void drain_scq(ns_dev * card, scq_info * scq, int pos)
 		XPRINTK("nicstar%d: freeing skb at 0x%p (index %d).\n",
 			card->index, skb, i);
 		if (skb != NULL) {
-			pci_unmap_single(card->pcidev,
+			dma_unmap_single(&card->pcidev->dev,
 					 NS_PRV_DMA(skb),
 					 skb->len,
-					 PCI_DMA_TODEVICE);
+					 DMA_TO_DEVICE);
 			vcc = ATM_SKB(skb)->vcc;
 			if (vcc && vcc->pop != NULL) {
 				vcc->pop(vcc, skb);
@@ -1992,16 +1992,16 @@ static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 		return;
 	}
 	idr_remove(&card->idr, id);
-        pci_dma_sync_single_for_cpu(card->pcidev,
-				    NS_PRV_DMA(skb),
-				    (NS_PRV_BUFTYPE(skb) == BUF_SM
-				     ? NS_SMSKBSIZE : NS_LGSKBSIZE),
-				    PCI_DMA_FROMDEVICE);
-	pci_unmap_single(card->pcidev,
+	dma_sync_single_for_cpu(&card->pcidev->dev,
+				NS_PRV_DMA(skb),
+				(NS_PRV_BUFTYPE(skb) == BUF_SM
+				 ? NS_SMSKBSIZE : NS_LGSKBSIZE),
+				DMA_FROM_DEVICE);
+	dma_unmap_single(&card->pcidev->dev,
 			 NS_PRV_DMA(skb),
 			 (NS_PRV_BUFTYPE(skb) == BUF_SM
 			  ? NS_SMSKBSIZE : NS_LGSKBSIZE),
-			 PCI_DMA_FROMDEVICE);
+			 DMA_FROM_DEVICE);
 	vpi = ns_rsqe_vpi(rsqe);
 	vci = ns_rsqe_vci(rsqe);
 	if (vpi >= 1UL << card->vpibits || vci >= 1UL << card->vcibits) {

commit 118ce7ab9785846e1c673f6130bee526c127206c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Feb 27 19:51:54 2014 +0100

    atm: nicstar: remove interruptible_sleep_on_timeout
    
    We are trying to finally kill off interruptible_sleep_on_timeout.
    the two uses in the nicstar driver can be trivially replaced
    with wait_event_interruptible_lock_irq_timeout, which prevents the
    wake-up race and is able to check the buffer state with scq->lock
    held.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 13ed54cf2c31..9988ac98b6d8 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -1739,10 +1739,10 @@ static int push_scqe(ns_dev * card, vc_map * vc, scq_info * scq, ns_scqe * tbd,
 		}
 
 		scq->full = 1;
-		spin_unlock_irqrestore(&scq->lock, flags);
-		interruptible_sleep_on_timeout(&scq->scqfull_waitq,
-					       SCQFULL_TIMEOUT);
-		spin_lock_irqsave(&scq->lock, flags);
+		wait_event_interruptible_lock_irq_timeout(scq->scqfull_waitq,
+							  scq->tail != scq->next,
+							  scq->lock,
+							  SCQFULL_TIMEOUT);
 
 		if (scq->full) {
 			spin_unlock_irqrestore(&scq->lock, flags);
@@ -1789,10 +1789,10 @@ static int push_scqe(ns_dev * card, vc_map * vc, scq_info * scq, ns_scqe * tbd,
 			scq->full = 1;
 			if (has_run++)
 				break;
-			spin_unlock_irqrestore(&scq->lock, flags);
-			interruptible_sleep_on_timeout(&scq->scqfull_waitq,
-						       SCQFULL_TIMEOUT);
-			spin_lock_irqsave(&scq->lock, flags);
+			wait_event_interruptible_lock_irq_timeout(scq->scqfull_waitq,
+								  scq->tail != scq->next,
+								  scq->lock,
+								  SCQFULL_TIMEOUT);
 		}
 
 		if (!scq->full) {

commit c664d63818aee3167b7ffa4002d224c88cb7ba85
Author: Daeseok Youn <daeseok.youn@gmail.com>
Date:   Wed Feb 19 10:10:11 2014 +0900

    atm: nicstar: use NULL instead of 0 for pointer
    
    sparse says:
    
    drivers/atm/nicstar.c:642:27: warning:
     Using plain integer as NULL pointer
    drivers/atm/nicstar.c:644:27:
     warning: Using plain integer as NULL pointer
    drivers/atm/nicstar.c:982:51:
     warning: Using plain integer as NULL pointer
    drivers/atm/nicstar.c:996:51:
     warning: Using plain integer as NULL pointer
    
    Signed-off-by: Daeseok Youn <daeseok.youn@gmail.com>
    Acked-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 9587e959ce1a..13ed54cf2c31 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -639,9 +639,9 @@ static int ns_init_card(int i, struct pci_dev *pcidev)
 	card->hbnr.init = NUM_HB;
 	card->hbnr.max = MAX_HB;
 
-	card->sm_handle = 0x00000000;
+	card->sm_handle = NULL;
 	card->sm_addr = 0x00000000;
-	card->lg_handle = 0x00000000;
+	card->lg_handle = NULL;
 	card->lg_addr = 0x00000000;
 
 	card->efbie = 1;	/* To prevent push_rxbufs from enabling the interrupt */
@@ -979,7 +979,7 @@ static void push_rxbufs(ns_dev * card, struct sk_buff *skb)
 				addr2 = card->sm_addr;
 				handle2 = card->sm_handle;
 				card->sm_addr = 0x00000000;
-				card->sm_handle = 0x00000000;
+				card->sm_handle = NULL;
 			} else {	/* (!sm_addr) */
 
 				card->sm_addr = addr1;
@@ -993,7 +993,7 @@ static void push_rxbufs(ns_dev * card, struct sk_buff *skb)
 				addr2 = card->lg_addr;
 				handle2 = card->lg_handle;
 				card->lg_addr = 0x00000000;
-				card->lg_handle = 0x00000000;
+				card->lg_handle = NULL;
 			} else {	/* (!lg_addr) */
 
 				card->lg_addr = addr1;

commit 4c55a4623aa0ec6d8af5eec1e58c3015a7025f7b
Author: dingtianhong <dingtianhong@huawei.com>
Date:   Thu Dec 26 19:41:02 2013 +0800

    atm: slight optimization of addr compare
    
    Use possibly more efficient ether_addr_equal
    instead of memcmp.
    
    Cc: Chas Williams <chas@cmf.nrl.navy.mil>
    Cc: linux-atm-general@lists.sourceforge.net
    Cc: netdev@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Yang Yingliang <yangyingliang@huawei.com>
    Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 5aca5f4c5458..9587e959ce1a 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -52,6 +52,7 @@
 #include <asm/io.h>
 #include <asm/uaccess.h>
 #include <linux/atomic.h>
+#include <linux/etherdevice.h>
 #include "nicstar.h"
 #ifdef CONFIG_ATM_NICSTAR_USE_SUNI
 #include "suni.h"
@@ -781,8 +782,7 @@ static int ns_init_card(int i, struct pci_dev *pcidev)
 	if (mac[i] == NULL || !mac_pton(mac[i], card->atmdev->esi)) {
 		nicstar_read_eprom(card->membase, NICSTAR_EPROM_MAC_ADDR_OFFSET,
 				   card->atmdev->esi, 6);
-		if (memcmp(card->atmdev->esi, "\x00\x00\x00\x00\x00\x00", 6) ==
-		    0) {
+		if (ether_addr_equal(card->atmdev->esi, "\x00\x00\x00\x00\x00\x00")) {
 			nicstar_read_eprom(card->membase,
 					   NICSTAR_EPROM_MAC_ADDR_OFFSET_ALT,
 					   card->atmdev->esi, 6);

commit d2bb3905ab9bafebd0872ceef9466c32849429d7
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Sep 13 18:00:58 2013 +0300

    atm: nicstar: fix regression made by previous patch
    
    The commit 8390f814 "atm: nicstar: re-use native mac_pton() helper" did a
    usefull thing. However, mac_pton() returns 1 in the case of the successfully
    parsed input. This patch fixes a typo.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 409502a78e7e..5aca5f4c5458 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -778,7 +778,7 @@ static int ns_init_card(int i, struct pci_dev *pcidev)
 		return error;
 	}
 
-	if (mac[i] == NULL || mac_pton(mac[i], card->atmdev->esi)) {
+	if (mac[i] == NULL || !mac_pton(mac[i], card->atmdev->esi)) {
 		nicstar_read_eprom(card->membase, NICSTAR_EPROM_MAC_ADDR_OFFSET,
 				   card->atmdev->esi, 6);
 		if (memcmp(card->atmdev->esi, "\x00\x00\x00\x00\x00\x00", 6) ==

commit 8390f81482e3bbf756dce3a5121f164140fd0412
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Tue Sep 3 15:13:43 2013 +0300

    atm: nicstar: re-use native mac_pton() helper
    
    There is a nice helper to parse MAC. Let's use it and remove custom
    implementation.
    
    Signed-off-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 6587dc295eb0..409502a78e7e 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -153,7 +153,6 @@ static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user * arg);
 static void which_list(ns_dev * card, struct sk_buff *skb);
 #endif
 static void ns_poll(unsigned long arg);
-static int ns_parse_mac(char *mac, unsigned char *esi);
 static void ns_phy_put(struct atm_dev *dev, unsigned char value,
 		       unsigned long addr);
 static unsigned char ns_phy_get(struct atm_dev *dev, unsigned long addr);
@@ -779,7 +778,7 @@ static int ns_init_card(int i, struct pci_dev *pcidev)
 		return error;
 	}
 
-	if (ns_parse_mac(mac[i], card->atmdev->esi)) {
+	if (mac[i] == NULL || mac_pton(mac[i], card->atmdev->esi)) {
 		nicstar_read_eprom(card->membase, NICSTAR_EPROM_MAC_ADDR_OFFSET,
 				   card->atmdev->esi, 6);
 		if (memcmp(card->atmdev->esi, "\x00\x00\x00\x00\x00\x00", 6) ==
@@ -2802,29 +2801,6 @@ static void ns_poll(unsigned long arg)
 	PRINTK("nicstar: Leaving ns_poll().\n");
 }
 
-static int ns_parse_mac(char *mac, unsigned char *esi)
-{
-	int i, j;
-	short byte1, byte0;
-
-	if (mac == NULL || esi == NULL)
-		return -1;
-	j = 0;
-	for (i = 0; i < 6; i++) {
-		if ((byte1 = hex_to_bin(mac[j++])) < 0)
-			return -1;
-		if ((byte0 = hex_to_bin(mac[j++])) < 0)
-			return -1;
-		esi[i] = (unsigned char)(byte1 * 16 + byte0);
-		if (i < 5) {
-			if (mac[j++] != ':')
-				return -1;
-		}
-	}
-	return 0;
-}
-
-
 static void ns_phy_put(struct atm_dev *dev, unsigned char value,
 		       unsigned long addr)
 {

commit b051f6edc29c084a6440e9731bc85d95b6b95e14
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Feb 27 17:04:00 2013 -0800

    atm/nicstar: convert to idr_alloc()
    
    Convert to the much saner new idr interface.  The existing code looks
    buggy to me - ID 0 is treated as no-ID but allocation specifies 0 as
    lower limit and there's no error handling after partial success.  This
    conversion keeps the bugs unchanged.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 628787ed999c..6587dc295eb0 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -949,11 +949,10 @@ static void free_scq(ns_dev *card, scq_info *scq, struct atm_vcc *vcc)
 static void push_rxbufs(ns_dev * card, struct sk_buff *skb)
 {
 	struct sk_buff *handle1, *handle2;
-	u32 id1 = 0, id2 = 0;
+	int id1, id2;
 	u32 addr1, addr2;
 	u32 stat;
 	unsigned long flags;
-	int err;
 
 	/* *BARF* */
 	handle2 = NULL;
@@ -1026,23 +1025,12 @@ static void push_rxbufs(ns_dev * card, struct sk_buff *skb)
 				card->lbfqc += 2;
 		}
 
-		do {
-			if (!idr_pre_get(&card->idr, GFP_ATOMIC)) {
-				printk(KERN_ERR
-				       "nicstar%d: no free memory for idr\n",
-				       card->index);
-				goto out;
-			}
-
-			if (!id1)
-				err = idr_get_new_above(&card->idr, handle1, 0, &id1);
-
-			if (!id2 && err == 0)
-				err = idr_get_new_above(&card->idr, handle2, 0, &id2);
-
-		} while (err == -EAGAIN);
+		id1 = idr_alloc(&card->idr, handle1, 0, 0, GFP_ATOMIC);
+		if (id1 < 0)
+			goto out;
 
-		if (err)
+		id2 = idr_alloc(&card->idr, handle2, 0, 0, GFP_ATOMIC);
+		if (id2 < 0)
 			goto out;
 
 		spin_lock_irqsave(&card->res_lock, flags);

commit c767bf2ed3a3844a9d9341366cc388dab7c7ee05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Feb 27 17:03:36 2013 -0800

    atm/nicstar: don't use idr_remove_all()
    
    idr_destroy() can destroy idr by itself and idr_remove_all() is being
    deprecated.  Drop its usage.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Chas Williams <chas@cmf.nrl.navy.mil>
    Cc: David Miller <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index ed1d2b7f923b..628787ed999c 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -251,7 +251,6 @@ static void nicstar_remove_one(struct pci_dev *pcidev)
 		if (card->scd2vc[j] != NULL)
 			free_scq(card, card->scd2vc[j]->scq, card->scd2vc[j]->tx_vcc);
 	}
-	idr_remove_all(&card->idr);
 	idr_destroy(&card->idr);
 	pci_free_consistent(card->pcidev, NS_RSQSIZE + NS_RSQ_ALIGNMENT,
 			    card->rsq.org, card->rsq.dma);

commit 6c44512d06d3f6afcead304f051f4a06ed9be2cd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:25:04 2012 -0800

    Drivers: atm: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 1c70c45fa044..ed1d2b7f923b 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -121,8 +121,8 @@
 static u32 ns_read_sram(ns_dev * card, u32 sram_address);
 static void ns_write_sram(ns_dev * card, u32 sram_address, u32 * value,
 			  int count);
-static int __devinit ns_init_card(int i, struct pci_dev *pcidev);
-static void __devinit ns_init_card_error(ns_dev * card, int error);
+static int ns_init_card(int i, struct pci_dev *pcidev);
+static void ns_init_card_error(ns_dev * card, int error);
 static scq_info *get_scq(ns_dev *card, int size, u32 scd);
 static void free_scq(ns_dev *card, scq_info * scq, struct atm_vcc *vcc);
 static void push_rxbufs(ns_dev *, struct sk_buff *);
@@ -180,8 +180,8 @@ MODULE_LICENSE("GPL");
 
 /* Functions */
 
-static int __devinit nicstar_init_one(struct pci_dev *pcidev,
-				      const struct pci_device_id *ent)
+static int nicstar_init_one(struct pci_dev *pcidev,
+			    const struct pci_device_id *ent)
 {
 	static int index = -1;
 	unsigned int error;
@@ -200,7 +200,7 @@ static int __devinit nicstar_init_one(struct pci_dev *pcidev,
 	return -ENODEV;
 }
 
-static void __devexit nicstar_remove_one(struct pci_dev *pcidev)
+static void nicstar_remove_one(struct pci_dev *pcidev)
 {
 	int i, j;
 	ns_dev *card = pci_get_drvdata(pcidev);
@@ -262,7 +262,7 @@ static void __devexit nicstar_remove_one(struct pci_dev *pcidev)
 	kfree(card);
 }
 
-static struct pci_device_id nicstar_pci_tbl[] __devinitdata = {
+static struct pci_device_id nicstar_pci_tbl[] = {
 	{ PCI_VDEVICE(IDT, PCI_DEVICE_ID_IDT_IDT77201), 0 },
 	{0,}			/* terminate list */
 };
@@ -273,7 +273,7 @@ static struct pci_driver nicstar_driver = {
 	.name = "nicstar",
 	.id_table = nicstar_pci_tbl,
 	.probe = nicstar_init_one,
-	.remove = __devexit_p(nicstar_remove_one),
+	.remove = nicstar_remove_one,
 };
 
 static int __init nicstar_init(void)
@@ -351,7 +351,7 @@ static void ns_write_sram(ns_dev * card, u32 sram_address, u32 * value,
 	spin_unlock_irqrestore(&card->res_lock, flags);
 }
 
-static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
+static int ns_init_card(int i, struct pci_dev *pcidev)
 {
 	int j;
 	struct ns_dev *card = NULL;
@@ -821,7 +821,7 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
 	return error;
 }
 
-static void __devinit ns_init_card_error(ns_dev * card, int error)
+static void ns_init_card_error(ns_dev *card, int error)
 {
 	if (error >= 17) {
 		writel(0x00000000, card->membase + CFG);

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 6b313ee9231b..1c70c45fa044 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -51,7 +51,7 @@
 #include <linux/idr.h>
 #include <asm/io.h>
 #include <asm/uaccess.h>
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 #include "nicstar.h"
 #ifdef CONFIG_ATM_NICSTAR_USE_SUNI
 #include "suni.h"

commit d9ca676bcb26e1fdff9265a3e70f697cd381c889
Author: Dan Williams <dcbw@redhat.com>
Date:   Wed Dec 8 19:40:47 2010 +0000

    atm: correct sysfs 'device' link creation and parent relationships
    
    The ATM subsystem was incorrectly creating the 'device' link for ATM
    nodes in sysfs.  This led to incorrect device/parent relationships
    exposed by sysfs and udev.  Instead of rolling the 'device' link by hand
    in the generic ATM code, pass each ATM driver's bus device down to the
    sysfs code and let sysfs do this stuff correctly.
    
    Signed-off-by: Dan Williams <dcbw@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 2f3516b7f118..6b313ee9231b 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -771,7 +771,8 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
 	}
 
 	/* Register device */
-	card->atmdev = atm_dev_register("nicstar", &atm_ops, -1, NULL);
+	card->atmdev = atm_dev_register("nicstar", &card->pcidev->dev, &atm_ops,
+					-1, NULL);
 	if (card->atmdev == NULL) {
 		printk("nicstar%d: can't register device.\n", i);
 		error = 17;

commit 2b27822ff8f257f810761c3d23e8104d1404cf3b
Author: Andy Shevchenko <andy.shevchenko@gmail.com>
Date:   Fri Jul 23 03:18:06 2010 +0000

    drivers: atm: don't use private copy of hex_to_bin()
    
    Signed-off-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: Chas Williams <chas@cmf.nrl.navy.mil>
    Cc: linux-atm-general@lists.sourceforge.net
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 729a149b6b2b..2f3516b7f118 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -154,7 +154,6 @@ static void which_list(ns_dev * card, struct sk_buff *skb);
 #endif
 static void ns_poll(unsigned long arg);
 static int ns_parse_mac(char *mac, unsigned char *esi);
-static short ns_h2i(char c);
 static void ns_phy_put(struct atm_dev *dev, unsigned char value,
 		       unsigned long addr);
 static unsigned char ns_phy_get(struct atm_dev *dev, unsigned long addr);
@@ -2824,9 +2823,9 @@ static int ns_parse_mac(char *mac, unsigned char *esi)
 		return -1;
 	j = 0;
 	for (i = 0; i < 6; i++) {
-		if ((byte1 = ns_h2i(mac[j++])) < 0)
+		if ((byte1 = hex_to_bin(mac[j++])) < 0)
 			return -1;
-		if ((byte0 = ns_h2i(mac[j++])) < 0)
+		if ((byte0 = hex_to_bin(mac[j++])) < 0)
 			return -1;
 		esi[i] = (unsigned char)(byte1 * 16 + byte0);
 		if (i < 5) {
@@ -2837,16 +2836,6 @@ static int ns_parse_mac(char *mac, unsigned char *esi)
 	return 0;
 }
 
-static short ns_h2i(char c)
-{
-	if (c >= '0' && c <= '9')
-		return (short)(c - '0');
-	if (c >= 'A' && c <= 'F')
-		return (short)(c - 'A' + 10);
-	if (c >= 'a' && c <= 'f')
-		return (short)(c - 'a' + 10);
-	return -1;
-}
 
 static void ns_phy_put(struct atm_dev *dev, unsigned char value,
 		       unsigned long addr)

commit 6df7b80c64a3489782edfdee12c8828bb6a8a317
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Thu Jul 15 08:48:26 2010 +0000

    atm: Convert pci_table entries to PCI_VDEVICE (if PCI_ANY_ID is used)
    
    This patch converts pci_table entries, where .subvendor=PCI_ANY_ID and
    .subdevice=PCI_ANY_ID, .class=0 and .class_mask=0, to use the
    PCI_VDEVICE macro, and thus improves readability.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index cff337ef85fd..729a149b6b2b 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -264,8 +264,7 @@ static void __devexit nicstar_remove_one(struct pci_dev *pcidev)
 }
 
 static struct pci_device_id nicstar_pci_tbl[] __devinitdata = {
-	{PCI_VENDOR_ID_IDT, PCI_DEVICE_ID_IDT_IDT77201,
-	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{ PCI_VDEVICE(IDT, PCI_DEVICE_ID_IDT_IDT77201), 0 },
 	{0,}			/* terminate list */
 };
 

commit 06df277a670263a073362046855851aad278d988
Author: chas williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
Date:   Sat Jul 10 03:42:02 2010 +0000

    atm: remove IRQF_DISABLED in combination with IRQF_SHARED
    
    Signed-off-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 59876c66a92a..cff337ef85fd 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -765,8 +765,7 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
 
 	card->intcnt = 0;
 	if (request_irq
-	    (pcidev->irq, &ns_irq_handler, IRQF_DISABLED | IRQF_SHARED,
-	     "nicstar", card) != 0) {
+	    (pcidev->irq, &ns_irq_handler, IRQF_SHARED, "nicstar", card) != 0) {
 		printk("nicstar%d: can't allocate IRQ %d.\n", i, pcidev->irq);
 		error = 9;
 		ns_init_card_error(card, error);

commit 864a3ff635fa73dae15455524e048da5c89352ac
Author: chas williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
Date:   Sat May 29 09:04:25 2010 +0000

    atm: [nicstar] remove virt_to_bus() and support 64-bit platforms
    
    Signed-off-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index a07b6b7fc7d8..59876c66a92a 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -38,6 +38,7 @@
 #include <linux/atmdev.h>
 #include <linux/atm.h>
 #include <linux/pci.h>
+#include <linux/dma-mapping.h>
 #include <linux/types.h>
 #include <linux/string.h>
 #include <linux/delay.h>
@@ -47,6 +48,7 @@
 #include <linux/interrupt.h>
 #include <linux/bitops.h>
 #include <linux/slab.h>
+#include <linux/idr.h>
 #include <asm/io.h>
 #include <asm/uaccess.h>
 #include <asm/atomic.h>
@@ -58,10 +60,6 @@
 #include "idt77105.h"
 #endif /* CONFIG_ATM_NICSTAR_USE_IDT77105 */
 
-#if BITS_PER_LONG != 32
-# error FIXME: this driver requires a 32-bit platform
-#endif
-
 /* Additional code */
 
 #include "nicstarmac.c"
@@ -109,17 +107,15 @@
 
 #define NS_DELAY mdelay(1)
 
-#define ALIGN_BUS_ADDR(addr, alignment) \
-        ((((u32) (addr)) + (((u32) (alignment)) - 1)) & ~(((u32) (alignment)) - 1))
-#define ALIGN_ADDRESS(addr, alignment) \
-        bus_to_virt(ALIGN_BUS_ADDR(virt_to_bus(addr), alignment))
-
-#undef CEIL
+#define PTR_DIFF(a, b)	((u32)((unsigned long)(a) - (unsigned long)(b)))
 
 #ifndef ATM_SKB
 #define ATM_SKB(s) (&(s)->atm)
 #endif
 
+#define scq_virt_to_bus(scq, p) \
+		(scq->dma + ((unsigned long)(p) - (unsigned long)(scq)->org))
+
 /* Function declarations */
 
 static u32 ns_read_sram(ns_dev * card, u32 sram_address);
@@ -127,8 +123,8 @@ static void ns_write_sram(ns_dev * card, u32 sram_address, u32 * value,
 			  int count);
 static int __devinit ns_init_card(int i, struct pci_dev *pcidev);
 static void __devinit ns_init_card_error(ns_dev * card, int error);
-static scq_info *get_scq(int size, u32 scd);
-static void free_scq(scq_info * scq, struct atm_vcc *vcc);
+static scq_info *get_scq(ns_dev *card, int size, u32 scd);
+static void free_scq(ns_dev *card, scq_info * scq, struct atm_vcc *vcc);
 static void push_rxbufs(ns_dev *, struct sk_buff *);
 static irqreturn_t ns_irq_handler(int irq, void *dev_id);
 static int ns_open(struct atm_vcc *vcc);
@@ -153,7 +149,9 @@ static void dequeue_sm_buf(ns_dev * card, struct sk_buff *sb);
 static void dequeue_lg_buf(ns_dev * card, struct sk_buff *lb);
 static int ns_proc_read(struct atm_dev *dev, loff_t * pos, char *page);
 static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user * arg);
+#ifdef EXTRA_DEBUG
 static void which_list(ns_dev * card, struct sk_buff *skb);
+#endif
 static void ns_poll(unsigned long arg);
 static int ns_parse_mac(char *mac, unsigned char *esi);
 static short ns_h2i(char c);
@@ -249,13 +247,17 @@ static void __devexit nicstar_remove_one(struct pci_dev *pcidev)
 		dev_kfree_skb_any(lb);
 	while ((sb = skb_dequeue(&card->sbpool.queue)) != NULL)
 		dev_kfree_skb_any(sb);
-	free_scq(card->scq0, NULL);
+	free_scq(card, card->scq0, NULL);
 	for (j = 0; j < NS_FRSCD_NUM; j++) {
 		if (card->scd2vc[j] != NULL)
-			free_scq(card->scd2vc[j]->scq, card->scd2vc[j]->tx_vcc);
-	}
-	kfree(card->rsq.org);
-	kfree(card->tsq.org);
+			free_scq(card, card->scd2vc[j]->scq, card->scd2vc[j]->tx_vcc);
+	}
+	idr_remove_all(&card->idr);
+	idr_destroy(&card->idr);
+	pci_free_consistent(card->pcidev, NS_RSQSIZE + NS_RSQ_ALIGNMENT,
+			    card->rsq.org, card->rsq.dma);
+	pci_free_consistent(card->pcidev, NS_TSQSIZE + NS_TSQ_ALIGNMENT,
+			    card->tsq.org, card->tsq.dma);
 	free_irq(card->pcidev->irq, card);
 	iounmap(card->membase);
 	kfree(card);
@@ -371,6 +373,14 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
 		ns_init_card_error(card, error);
 		return error;
 	}
+        if ((pci_set_dma_mask(pcidev, DMA_BIT_MASK(32)) != 0) ||
+	    (pci_set_consistent_dma_mask(pcidev, DMA_BIT_MASK(32)) != 0)) {
+                printk(KERN_WARNING
+		       "nicstar%d: No suitable DMA available.\n", i);
+		error = 2;
+		ns_init_card_error(card, error);
+		return error;
+        }
 
 	if ((card = kmalloc(sizeof(ns_dev), GFP_KERNEL)) == NULL) {
 		printk
@@ -397,7 +407,7 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
 		ns_init_card_error(card, error);
 		return error;
 	}
-	PRINTK("nicstar%d: membase at 0x%x.\n", i, card->membase);
+	PRINTK("nicstar%d: membase at 0x%p.\n", i, card->membase);
 
 	pci_set_master(pcidev);
 
@@ -528,54 +538,54 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
 	writel(0x00000000, card->membase + VPM);
 
 	/* Initialize TSQ */
-	card->tsq.org = kmalloc(NS_TSQSIZE + NS_TSQ_ALIGNMENT, GFP_KERNEL);
+	card->tsq.org = pci_alloc_consistent(card->pcidev,
+					     NS_TSQSIZE + NS_TSQ_ALIGNMENT,
+					     &card->tsq.dma);
 	if (card->tsq.org == NULL) {
 		printk("nicstar%d: can't allocate TSQ.\n", i);
 		error = 10;
 		ns_init_card_error(card, error);
 		return error;
 	}
-	card->tsq.base =
-	    (ns_tsi *) ALIGN_ADDRESS(card->tsq.org, NS_TSQ_ALIGNMENT);
+	card->tsq.base = PTR_ALIGN(card->tsq.org, NS_TSQ_ALIGNMENT);
 	card->tsq.next = card->tsq.base;
 	card->tsq.last = card->tsq.base + (NS_TSQ_NUM_ENTRIES - 1);
 	for (j = 0; j < NS_TSQ_NUM_ENTRIES; j++)
 		ns_tsi_init(card->tsq.base + j);
 	writel(0x00000000, card->membase + TSQH);
-	writel((u32) virt_to_bus(card->tsq.base), card->membase + TSQB);
-	PRINTK("nicstar%d: TSQ base at 0x%x  0x%x  0x%x.\n", i,
-	       (u32) card->tsq.base, (u32) virt_to_bus(card->tsq.base),
-	       readl(card->membase + TSQB));
+	writel(ALIGN(card->tsq.dma, NS_TSQ_ALIGNMENT), card->membase + TSQB);
+	PRINTK("nicstar%d: TSQ base at 0x%p.\n", i, card->tsq.base);
 
 	/* Initialize RSQ */
-	card->rsq.org = kmalloc(NS_RSQSIZE + NS_RSQ_ALIGNMENT, GFP_KERNEL);
+	card->rsq.org = pci_alloc_consistent(card->pcidev,
+					     NS_RSQSIZE + NS_RSQ_ALIGNMENT,
+					     &card->rsq.dma);
 	if (card->rsq.org == NULL) {
 		printk("nicstar%d: can't allocate RSQ.\n", i);
 		error = 11;
 		ns_init_card_error(card, error);
 		return error;
 	}
-	card->rsq.base =
-	    (ns_rsqe *) ALIGN_ADDRESS(card->rsq.org, NS_RSQ_ALIGNMENT);
+	card->rsq.base = PTR_ALIGN(card->rsq.org, NS_RSQ_ALIGNMENT);
 	card->rsq.next = card->rsq.base;
 	card->rsq.last = card->rsq.base + (NS_RSQ_NUM_ENTRIES - 1);
 	for (j = 0; j < NS_RSQ_NUM_ENTRIES; j++)
 		ns_rsqe_init(card->rsq.base + j);
 	writel(0x00000000, card->membase + RSQH);
-	writel((u32) virt_to_bus(card->rsq.base), card->membase + RSQB);
-	PRINTK("nicstar%d: RSQ base at 0x%x.\n", i, (u32) card->rsq.base);
+	writel(ALIGN(card->rsq.dma, NS_RSQ_ALIGNMENT), card->membase + RSQB);
+	PRINTK("nicstar%d: RSQ base at 0x%p.\n", i, card->rsq.base);
 
 	/* Initialize SCQ0, the only VBR SCQ used */
 	card->scq1 = NULL;
 	card->scq2 = NULL;
-	card->scq0 = get_scq(VBR_SCQSIZE, NS_VRSCD0);
+	card->scq0 = get_scq(card, VBR_SCQSIZE, NS_VRSCD0);
 	if (card->scq0 == NULL) {
 		printk("nicstar%d: can't get SCQ0.\n", i);
 		error = 12;
 		ns_init_card_error(card, error);
 		return error;
 	}
-	u32d[0] = (u32) virt_to_bus(card->scq0->base);
+	u32d[0] = scq_virt_to_bus(card->scq0, card->scq0->base);
 	u32d[1] = (u32) 0x00000000;
 	u32d[2] = (u32) 0xffffffff;
 	u32d[3] = (u32) 0x00000000;
@@ -583,8 +593,7 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
 	ns_write_sram(card, NS_VRSCD1, u32d, 4);	/* These last two won't be used */
 	ns_write_sram(card, NS_VRSCD2, u32d, 4);	/* but are initialized, just in case... */
 	card->scq0->scd = NS_VRSCD0;
-	PRINTK("nicstar%d: VBR-SCQ0 base at 0x%x.\n", i,
-	       (u32) card->scq0->base);
+	PRINTK("nicstar%d: VBR-SCQ0 base at 0x%p.\n", i, card->scq0->base);
 
 	/* Initialize TSTs */
 	card->tst_addr = NS_TST0;
@@ -640,6 +649,8 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
 
 	card->efbie = 1;	/* To prevent push_rxbufs from enabling the interrupt */
 
+	idr_init(&card->idr);
+
 	/* Pre-allocate some huge buffers */
 	skb_queue_head_init(&card->hbpool.queue);
 	card->hbpool.count = 0;
@@ -654,7 +665,7 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
 			ns_init_card_error(card, error);
 			return error;
 		}
-		NS_SKB_CB(hb)->buf_type = BUF_NONE;
+		NS_PRV_BUFTYPE(hb) = BUF_NONE;
 		skb_queue_tail(&card->hbpool.queue, hb);
 		card->hbpool.count++;
 	}
@@ -673,14 +684,15 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
 			ns_init_card_error(card, error);
 			return error;
 		}
-		NS_SKB_CB(lb)->buf_type = BUF_LG;
+		NS_PRV_BUFTYPE(lb) = BUF_LG;
 		skb_queue_tail(&card->lbpool.queue, lb);
 		skb_reserve(lb, NS_SMBUFSIZE);
 		push_rxbufs(card, lb);
 		/* Due to the implementation of push_rxbufs() this is 1, not 0 */
 		if (j == 1) {
 			card->rcbuf = lb;
-			card->rawch = (u32) virt_to_bus(lb->data);
+			card->rawcell = (struct ns_rcqe *) lb->data;
+			card->rawch = NS_PRV_DMA(lb);
 		}
 	}
 	/* Test for strange behaviour which leads to crashes */
@@ -708,7 +720,7 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
 			ns_init_card_error(card, error);
 			return error;
 		}
-		NS_SKB_CB(sb)->buf_type = BUF_SM;
+		NS_PRV_BUFTYPE(sb) = BUF_SM;
 		skb_queue_tail(&card->sbpool.queue, sb);
 		skb_reserve(sb, NS_AAL0_HEADER);
 		push_rxbufs(card, sb);
@@ -738,7 +750,7 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
 			ns_init_card_error(card, error);
 			return error;
 		}
-		NS_SKB_CB(iovb)->buf_type = BUF_NONE;
+		NS_PRV_BUFTYPE(iovb) = BUF_NONE;
 		skb_queue_tail(&card->iovpool.queue, iovb);
 		card->iovpool.count++;
 	}
@@ -825,7 +837,7 @@ static void __devinit ns_init_card_error(ns_dev * card, int error)
 		struct sk_buff *sb;
 		while ((sb = skb_dequeue(&card->sbpool.queue)) != NULL)
 			dev_kfree_skb_any(sb);
-		free_scq(card->scq0, NULL);
+		free_scq(card, card->scq0, NULL);
 	}
 	if (error >= 14) {
 		struct sk_buff *lb;
@@ -855,7 +867,7 @@ static void __devinit ns_init_card_error(ns_dev * card, int error)
 	}
 }
 
-static scq_info *get_scq(int size, u32 scd)
+static scq_info *get_scq(ns_dev *card, int size, u32 scd)
 {
 	scq_info *scq;
 	int i;
@@ -864,22 +876,22 @@ static scq_info *get_scq(int size, u32 scd)
 		return NULL;
 
 	scq = kmalloc(sizeof(scq_info), GFP_KERNEL);
-	if (scq == NULL)
+	if (!scq)
 		return NULL;
-	scq->org = kmalloc(2 * size, GFP_KERNEL);
-	if (scq->org == NULL) {
+        scq->org = pci_alloc_consistent(card->pcidev, 2 * size, &scq->dma);
+	if (!scq->org) {
 		kfree(scq);
 		return NULL;
 	}
 	scq->skb = kmalloc(sizeof(struct sk_buff *) *
 			   (size / NS_SCQE_SIZE), GFP_KERNEL);
-	if (scq->skb == NULL) {
+	if (!scq->skb) {
 		kfree(scq->org);
 		kfree(scq);
 		return NULL;
 	}
 	scq->num_entries = size / NS_SCQE_SIZE;
-	scq->base = (ns_scqe *) ALIGN_ADDRESS(scq->org, size);
+	scq->base = PTR_ALIGN(scq->org, size);
 	scq->next = scq->base;
 	scq->last = scq->base + (scq->num_entries - 1);
 	scq->tail = scq->last;
@@ -897,7 +909,7 @@ static scq_info *get_scq(int size, u32 scd)
 }
 
 /* For variable rate SCQ vcc must be NULL */
-static void free_scq(scq_info * scq, struct atm_vcc *vcc)
+static void free_scq(ns_dev *card, scq_info *scq, struct atm_vcc *vcc)
 {
 	int i;
 
@@ -928,7 +940,10 @@ static void free_scq(scq_info * scq, struct atm_vcc *vcc)
 			}
 	}
 	kfree(scq->skb);
-	kfree(scq->org);
+	pci_free_consistent(card->pcidev,
+			    2 * (scq->num_entries == VBR_SCQ_NUM_ENTRIES ?
+				 VBR_SCQSIZE : CBR_SCQSIZE),
+			    scq->org, scq->dma);
 	kfree(scq);
 }
 
@@ -936,16 +951,23 @@ static void free_scq(scq_info * scq, struct atm_vcc *vcc)
    or large buffer(s) cast to u32. */
 static void push_rxbufs(ns_dev * card, struct sk_buff *skb)
 {
-	struct ns_skb_cb *cb = NS_SKB_CB(skb);
-	u32 handle1, addr1;
-	u32 handle2, addr2;
+	struct sk_buff *handle1, *handle2;
+	u32 id1 = 0, id2 = 0;
+	u32 addr1, addr2;
 	u32 stat;
 	unsigned long flags;
+	int err;
 
 	/* *BARF* */
-	handle2 = addr2 = 0;
-	handle1 = (u32) skb;
-	addr1 = (u32) virt_to_bus(skb->data);
+	handle2 = NULL;
+	addr2 = 0;
+	handle1 = skb;
+	addr1 = pci_map_single(card->pcidev,
+			       skb->data,
+			       (NS_PRV_BUFTYPE(skb) == BUF_SM
+				? NS_SMSKBSIZE : NS_LGSKBSIZE),
+			       PCI_DMA_TODEVICE);
+	NS_PRV_DMA(skb) = addr1; /* save so we can unmap later */
 
 #ifdef GENERAL_DEBUG
 	if (!addr1)
@@ -956,7 +978,7 @@ static void push_rxbufs(ns_dev * card, struct sk_buff *skb)
 	stat = readl(card->membase + STAT);
 	card->sbfqc = ns_stat_sfbqc_get(stat);
 	card->lbfqc = ns_stat_lfbqc_get(stat);
-	if (cb->buf_type == BUF_SM) {
+	if (NS_PRV_BUFTYPE(skb) == BUF_SM) {
 		if (!addr2) {
 			if (card->sm_addr) {
 				addr2 = card->sm_addr;
@@ -986,47 +1008,60 @@ static void push_rxbufs(ns_dev * card, struct sk_buff *skb)
 	}
 
 	if (addr2) {
-		if (cb->buf_type == BUF_SM) {
+		if (NS_PRV_BUFTYPE(skb) == BUF_SM) {
 			if (card->sbfqc >= card->sbnr.max) {
-				skb_unlink((struct sk_buff *)handle1,
-					   &card->sbpool.queue);
-				dev_kfree_skb_any((struct sk_buff *)handle1);
-				skb_unlink((struct sk_buff *)handle2,
-					   &card->sbpool.queue);
-				dev_kfree_skb_any((struct sk_buff *)handle2);
+				skb_unlink(handle1, &card->sbpool.queue);
+				dev_kfree_skb_any(handle1);
+				skb_unlink(handle2, &card->sbpool.queue);
+				dev_kfree_skb_any(handle2);
 				return;
 			} else
 				card->sbfqc += 2;
 		} else {	/* (buf_type == BUF_LG) */
 
 			if (card->lbfqc >= card->lbnr.max) {
-				skb_unlink((struct sk_buff *)handle1,
-					   &card->lbpool.queue);
-				dev_kfree_skb_any((struct sk_buff *)handle1);
-				skb_unlink((struct sk_buff *)handle2,
-					   &card->lbpool.queue);
-				dev_kfree_skb_any((struct sk_buff *)handle2);
+				skb_unlink(handle1, &card->lbpool.queue);
+				dev_kfree_skb_any(handle1);
+				skb_unlink(handle2, &card->lbpool.queue);
+				dev_kfree_skb_any(handle2);
 				return;
 			} else
 				card->lbfqc += 2;
 		}
 
-		spin_lock_irqsave(&card->res_lock, flags);
+		do {
+			if (!idr_pre_get(&card->idr, GFP_ATOMIC)) {
+				printk(KERN_ERR
+				       "nicstar%d: no free memory for idr\n",
+				       card->index);
+				goto out;
+			}
+
+			if (!id1)
+				err = idr_get_new_above(&card->idr, handle1, 0, &id1);
+
+			if (!id2 && err == 0)
+				err = idr_get_new_above(&card->idr, handle2, 0, &id2);
+
+		} while (err == -EAGAIN);
 
+		if (err)
+			goto out;
+
+		spin_lock_irqsave(&card->res_lock, flags);
 		while (CMD_BUSY(card)) ;
 		writel(addr2, card->membase + DR3);
-		writel(handle2, card->membase + DR2);
+		writel(id2, card->membase + DR2);
 		writel(addr1, card->membase + DR1);
-		writel(handle1, card->membase + DR0);
-		writel(NS_CMD_WRITE_FREEBUFQ | cb->buf_type,
+		writel(id1, card->membase + DR0);
+		writel(NS_CMD_WRITE_FREEBUFQ | NS_PRV_BUFTYPE(skb),
 		       card->membase + CMD);
-
 		spin_unlock_irqrestore(&card->res_lock, flags);
 
 		XPRINTK("nicstar%d: Pushing %s buffers at 0x%x and 0x%x.\n",
 			card->index,
-			(cb->buf_type == BUF_SM ? "small" : "large"), addr1,
-			addr2);
+			(NS_PRV_BUFTYPE(skb) == BUF_SM ? "small" : "large"),
+			addr1, addr2);
 	}
 
 	if (!card->efbie && card->sbfqc >= card->sbnr.min &&
@@ -1036,6 +1071,7 @@ static void push_rxbufs(ns_dev * card, struct sk_buff *skb)
 		       card->membase + CFG);
 	}
 
+out:
 	return;
 }
 
@@ -1131,21 +1167,21 @@ static irqreturn_t ns_irq_handler(int irq, void *dev_id)
 		   next interrupt. As this preliminary support is only meant to
 		   avoid buffer leakage, this is not an issue. */
 		while (readl(card->membase + RAWCT) != card->rawch) {
-			ns_rcqe *rawcell;
 
-			rawcell = (ns_rcqe *) bus_to_virt(card->rawch);
-			if (ns_rcqe_islast(rawcell)) {
+			if (ns_rcqe_islast(card->rawcell)) {
 				struct sk_buff *oldbuf;
 
 				oldbuf = card->rcbuf;
-				card->rcbuf =
-				    (struct sk_buff *)
-				    ns_rcqe_nextbufhandle(rawcell);
-				card->rawch =
-				    (u32) virt_to_bus(card->rcbuf->data);
+				card->rcbuf = idr_find(&card->idr,
+						       ns_rcqe_nextbufhandle(card->rawcell));
+				card->rawch = NS_PRV_DMA(card->rcbuf);
+				card->rawcell = (struct ns_rcqe *)
+						card->rcbuf->data;
 				recycle_rx_buf(card, oldbuf);
-			} else
+			} else {
 				card->rawch += NS_RCQE_SIZE;
+				card->rawcell++;
+			}
 		}
 	}
 
@@ -1165,7 +1201,7 @@ static irqreturn_t ns_irq_handler(int irq, void *dev_id)
 				card->efbie = 0;
 				break;
 			}
-			NS_SKB_CB(sb)->buf_type = BUF_SM;
+			NS_PRV_BUFTYPE(sb) = BUF_SM;
 			skb_queue_tail(&card->sbpool.queue, sb);
 			skb_reserve(sb, NS_AAL0_HEADER);
 			push_rxbufs(card, sb);
@@ -1190,7 +1226,7 @@ static irqreturn_t ns_irq_handler(int irq, void *dev_id)
 				card->efbie = 0;
 				break;
 			}
-			NS_SKB_CB(lb)->buf_type = BUF_LG;
+			NS_PRV_BUFTYPE(lb) = BUF_LG;
 			skb_queue_tail(&card->lbpool.queue, lb);
 			skb_reserve(lb, NS_SMBUFSIZE);
 			push_rxbufs(card, lb);
@@ -1338,7 +1374,7 @@ static int ns_open(struct atm_vcc *vcc)
 
 			vc->cbr_scd = NS_FRSCD + frscdi * NS_FRSCD_SIZE;
 
-			scq = get_scq(CBR_SCQSIZE, vc->cbr_scd);
+			scq = get_scq(card, CBR_SCQSIZE, vc->cbr_scd);
 			if (scq == NULL) {
 				PRINTK("nicstar%d: can't get fixed rate SCQ.\n",
 				       card->index);
@@ -1349,7 +1385,7 @@ static int ns_open(struct atm_vcc *vcc)
 				return -ENOMEM;
 			}
 			vc->scq = scq;
-			u32d[0] = (u32) virt_to_bus(scq->base);
+			u32d[0] = scq_virt_to_bus(scq, scq->base);
 			u32d[1] = (u32) 0x00000000;
 			u32d[2] = (u32) 0xffffffff;
 			u32d[3] = (u32) 0x00000000;
@@ -1434,9 +1470,8 @@ static void ns_close(struct atm_vcc *vcc)
 			     card->index);
 			iovb = vc->rx_iov;
 			recycle_iovec_rx_bufs(card, (struct iovec *)iovb->data,
-					      NS_SKB(iovb)->iovcnt);
-			NS_SKB(iovb)->iovcnt = 0;
-			NS_SKB(iovb)->vcc = NULL;
+					      NS_PRV_IOVCNT(iovb));
+			NS_PRV_IOVCNT(iovb) = 0;
 			spin_lock_irqsave(&card->int_lock, flags);
 			recycle_iov_buf(card, iovb);
 			spin_unlock_irqrestore(&card->int_lock, flags);
@@ -1487,7 +1522,7 @@ static void ns_close(struct atm_vcc *vcc)
 					scq->next = scq->base;
 				else
 					scq->next++;
-				data = (u32) virt_to_bus(scq->next);
+				data = scq_virt_to_bus(scq, scq->next);
 				ns_write_sram(card, scq->scd, &data, 1);
 			}
 			spin_unlock_irqrestore(&scq->lock, flags);
@@ -1506,7 +1541,7 @@ static void ns_close(struct atm_vcc *vcc)
 		}
 
 		card->scd2vc[(vc->cbr_scd - NS_FRSCD) / NS_FRSCD_SIZE] = NULL;
-		free_scq(vc->scq, vcc);
+		free_scq(card, vc->scq, vcc);
 	}
 
 	/* remove all references to vcc before deleting it */
@@ -1539,13 +1574,13 @@ static void ns_close(struct atm_vcc *vcc)
 		cfg = readl(card->membase + CFG);
 		printk("STAT = 0x%08X  CFG = 0x%08X  \n", stat, cfg);
 		printk
-		    ("TSQ: base = 0x%08X  next = 0x%08X  last = 0x%08X  TSQT = 0x%08X \n",
-		     (u32) card->tsq.base, (u32) card->tsq.next,
-		     (u32) card->tsq.last, readl(card->membase + TSQT));
+		    ("TSQ: base = 0x%p  next = 0x%p  last = 0x%p  TSQT = 0x%08X \n",
+		     card->tsq.base, card->tsq.next,
+		     card->tsq.last, readl(card->membase + TSQT));
 		printk
-		    ("RSQ: base = 0x%08X  next = 0x%08X  last = 0x%08X  RSQT = 0x%08X \n",
-		     (u32) card->rsq.base, (u32) card->rsq.next,
-		     (u32) card->rsq.last, readl(card->membase + RSQT));
+		    ("RSQ: base = 0x%p  next = 0x%p  last = 0x%p  RSQT = 0x%08X \n",
+		     card->rsq.base, card->rsq.next,
+		     card->rsq.last, readl(card->membase + RSQT));
 		printk("Empty free buffer queue interrupt %s \n",
 		       card->efbie ? "enabled" : "disabled");
 		printk("SBCNT = %d  count = %d   LBCNT = %d count = %d \n",
@@ -1651,11 +1686,14 @@ static int ns_send(struct atm_vcc *vcc, struct sk_buff *skb)
 
 	ATM_SKB(skb)->vcc = vcc;
 
+	NS_PRV_DMA(skb) = pci_map_single(card->pcidev, skb->data,
+					 skb->len, PCI_DMA_TODEVICE);
+
 	if (vcc->qos.aal == ATM_AAL5) {
 		buflen = (skb->len + 47 + 8) / 48 * 48;	/* Multiple of 48 */
 		flags = NS_TBD_AAL5;
-		scqe.word_2 = cpu_to_le32((u32) virt_to_bus(skb->data));
-		scqe.word_3 = cpu_to_le32((u32) skb->len);
+		scqe.word_2 = cpu_to_le32(NS_PRV_DMA(skb));
+		scqe.word_3 = cpu_to_le32(skb->len);
 		scqe.word_4 =
 		    ns_tbd_mkword_4(0, (u32) vcc->vpi, (u32) vcc->vci, 0,
 				    ATM_SKB(skb)->
@@ -1665,8 +1703,7 @@ static int ns_send(struct atm_vcc *vcc, struct sk_buff *skb)
 
 		buflen = ATM_CELL_PAYLOAD;	/* i.e., 48 bytes */
 		flags = NS_TBD_AAL0;
-		scqe.word_2 =
-		    cpu_to_le32((u32) virt_to_bus(skb->data) + NS_AAL0_HEADER);
+		scqe.word_2 = cpu_to_le32(NS_PRV_DMA(skb) + NS_AAL0_HEADER);
 		scqe.word_3 = cpu_to_le32(0x00000000);
 		if (*skb->data & 0x02)	/* Payload type 1 - end of pdu */
 			flags |= NS_TBD_EOPDU;
@@ -1733,12 +1770,12 @@ static int push_scqe(ns_dev * card, vc_map * vc, scq_info * scq, ns_scqe * tbd,
 	*scq->next = *tbd;
 	index = (int)(scq->next - scq->base);
 	scq->skb[index] = skb;
-	XPRINTK("nicstar%d: sending skb at 0x%x (pos %d).\n",
-		card->index, (u32) skb, index);
-	XPRINTK("nicstar%d: TBD written:\n0x%x\n0x%x\n0x%x\n0x%x\n at 0x%x.\n",
+	XPRINTK("nicstar%d: sending skb at 0x%p (pos %d).\n",
+		card->index, skb, index);
+	XPRINTK("nicstar%d: TBD written:\n0x%x\n0x%x\n0x%x\n0x%x\n at 0x%p.\n",
 		card->index, le32_to_cpu(tbd->word_1), le32_to_cpu(tbd->word_2),
 		le32_to_cpu(tbd->word_3), le32_to_cpu(tbd->word_4),
-		(u32) scq->next);
+		scq->next);
 	if (scq->next == scq->last)
 		scq->next = scq->base;
 	else
@@ -1757,7 +1794,7 @@ static int push_scqe(ns_dev * card, vc_map * vc, scq_info * scq, ns_scqe * tbd,
 
 		while (scq->tail == scq->next) {
 			if (in_interrupt()) {
-				data = (u32) virt_to_bus(scq->next);
+				data = scq_virt_to_bus(scq, scq->next);
 				ns_write_sram(card, scq->scd, &data, 1);
 				spin_unlock_irqrestore(&scq->lock, flags);
 				printk("nicstar%d: Error pushing TSR.\n",
@@ -1789,10 +1826,10 @@ static int push_scqe(ns_dev * card, vc_map * vc, scq_info * scq, ns_scqe * tbd,
 			index = (int)scqi;
 			scq->skb[index] = NULL;
 			XPRINTK
-			    ("nicstar%d: TSR written:\n0x%x\n0x%x\n0x%x\n0x%x\n at 0x%x.\n",
+			    ("nicstar%d: TSR written:\n0x%x\n0x%x\n0x%x\n0x%x\n at 0x%p.\n",
 			     card->index, le32_to_cpu(tsr.word_1),
 			     le32_to_cpu(tsr.word_2), le32_to_cpu(tsr.word_3),
-			     le32_to_cpu(tsr.word_4), (u32) scq->next);
+			     le32_to_cpu(tsr.word_4), scq->next);
 			if (scq->next == scq->last)
 				scq->next = scq->base;
 			else
@@ -1803,7 +1840,7 @@ static int push_scqe(ns_dev * card, vc_map * vc, scq_info * scq, ns_scqe * tbd,
 			PRINTK("nicstar%d: Timeout pushing TSR.\n",
 			       card->index);
 	}
-	data = (u32) virt_to_bus(scq->next);
+	data = scq_virt_to_bus(scq, scq->next);
 	ns_write_sram(card, scq->scd, &data, 1);
 
 	spin_unlock_irqrestore(&scq->lock, flags);
@@ -1881,10 +1918,9 @@ static void process_tsq(ns_dev * card)
 			two_ahead = one_ahead + 1;
 	}
 
-	if (serviced_entries) {
-		writel((((u32) previous) - ((u32) card->tsq.base)),
+	if (serviced_entries)
+		writel(PTR_DIFF(previous, card->tsq.base),
 		       card->membase + TSQH);
-	}
 }
 
 static void drain_scq(ns_dev * card, scq_info * scq, int pos)
@@ -1894,8 +1930,8 @@ static void drain_scq(ns_dev * card, scq_info * scq, int pos)
 	int i;
 	unsigned long flags;
 
-	XPRINTK("nicstar%d: drain_scq() called, scq at 0x%x, pos %d.\n",
-		card->index, (u32) scq, pos);
+	XPRINTK("nicstar%d: drain_scq() called, scq at 0x%p, pos %d.\n",
+		card->index, scq, pos);
 	if (pos >= scq->num_entries) {
 		printk("nicstar%d: Bad index on drain_scq().\n", card->index);
 		return;
@@ -1907,9 +1943,13 @@ static void drain_scq(ns_dev * card, scq_info * scq, int pos)
 		i = 0;
 	while (i != pos) {
 		skb = scq->skb[i];
-		XPRINTK("nicstar%d: freeing skb at 0x%x (index %d).\n",
-			card->index, (u32) skb, i);
+		XPRINTK("nicstar%d: freeing skb at 0x%p (index %d).\n",
+			card->index, skb, i);
 		if (skb != NULL) {
+			pci_unmap_single(card->pcidev,
+					 NS_PRV_DMA(skb),
+					 skb->len,
+					 PCI_DMA_TODEVICE);
 			vcc = ATM_SKB(skb)->vcc;
 			if (vcc && vcc->pop != NULL) {
 				vcc->pop(vcc, skb);
@@ -1940,8 +1980,7 @@ static void process_rsq(ns_dev * card)
 		else
 			card->rsq.next++;
 	} while (ns_rsqe_valid(card->rsq.next));
-	writel((((u32) previous) - ((u32) card->rsq.base)),
-	       card->membase + RSQH);
+	writel(PTR_DIFF(previous, card->rsq.base), card->membase + RSQH);
 }
 
 static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
@@ -1955,12 +1994,30 @@ static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 	unsigned short aal5_len;
 	int len;
 	u32 stat;
+	u32 id;
 
 	stat = readl(card->membase + STAT);
 	card->sbfqc = ns_stat_sfbqc_get(stat);
 	card->lbfqc = ns_stat_lfbqc_get(stat);
 
-	skb = (struct sk_buff *)le32_to_cpu(rsqe->buffer_handle);
+	id = le32_to_cpu(rsqe->buffer_handle);
+	skb = idr_find(&card->idr, id);
+	if (!skb) {
+		RXPRINTK(KERN_ERR
+			 "nicstar%d: idr_find() failed!\n", card->index);
+		return;
+	}
+	idr_remove(&card->idr, id);
+        pci_dma_sync_single_for_cpu(card->pcidev,
+				    NS_PRV_DMA(skb),
+				    (NS_PRV_BUFTYPE(skb) == BUF_SM
+				     ? NS_SMSKBSIZE : NS_LGSKBSIZE),
+				    PCI_DMA_FROMDEVICE);
+	pci_unmap_single(card->pcidev,
+			 NS_PRV_DMA(skb),
+			 (NS_PRV_BUFTYPE(skb) == BUF_SM
+			  ? NS_SMSKBSIZE : NS_LGSKBSIZE),
+			 PCI_DMA_FROMDEVICE);
 	vpi = ns_rsqe_vpi(rsqe);
 	vci = ns_rsqe_vci(rsqe);
 	if (vpi >= 1UL << card->vpibits || vci >= 1UL << card->vcibits) {
@@ -2034,43 +2091,42 @@ static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 				recycle_rx_buf(card, skb);
 				return;
 			}
-			NS_SKB_CB(iovb)->buf_type = BUF_NONE;
+			NS_PRV_BUFTYPE(iovb) = BUF_NONE;
 		} else if (--card->iovpool.count < card->iovnr.min) {
 			struct sk_buff *new_iovb;
 			if ((new_iovb =
 			     alloc_skb(NS_IOVBUFSIZE, GFP_ATOMIC)) != NULL) {
-				NS_SKB_CB(iovb)->buf_type = BUF_NONE;
+				NS_PRV_BUFTYPE(iovb) = BUF_NONE;
 				skb_queue_tail(&card->iovpool.queue, new_iovb);
 				card->iovpool.count++;
 			}
 		}
 		vc->rx_iov = iovb;
-		NS_SKB(iovb)->iovcnt = 0;
+		NS_PRV_IOVCNT(iovb) = 0;
 		iovb->len = 0;
 		iovb->data = iovb->head;
 		skb_reset_tail_pointer(iovb);
-		NS_SKB(iovb)->vcc = vcc;
 		/* IMPORTANT: a pointer to the sk_buff containing the small or large
 		   buffer is stored as iovec base, NOT a pointer to the
 		   small or large buffer itself. */
-	} else if (NS_SKB(iovb)->iovcnt >= NS_MAX_IOVECS) {
+	} else if (NS_PRV_IOVCNT(iovb) >= NS_MAX_IOVECS) {
 		printk("nicstar%d: received too big AAL5 SDU.\n", card->index);
 		atomic_inc(&vcc->stats->rx_err);
 		recycle_iovec_rx_bufs(card, (struct iovec *)iovb->data,
 				      NS_MAX_IOVECS);
-		NS_SKB(iovb)->iovcnt = 0;
+		NS_PRV_IOVCNT(iovb) = 0;
 		iovb->len = 0;
 		iovb->data = iovb->head;
 		skb_reset_tail_pointer(iovb);
-		NS_SKB(iovb)->vcc = vcc;
 	}
-	iov = &((struct iovec *)iovb->data)[NS_SKB(iovb)->iovcnt++];
+	iov = &((struct iovec *)iovb->data)[NS_PRV_IOVCNT(iovb)++];
 	iov->iov_base = (void *)skb;
 	iov->iov_len = ns_rsqe_cellcount(rsqe) * 48;
 	iovb->len += iov->iov_len;
 
-	if (NS_SKB(iovb)->iovcnt == 1) {
-		if (NS_SKB_CB(skb)->buf_type != BUF_SM) {
+#ifdef EXTRA_DEBUG
+	if (NS_PRV_IOVCNT(iovb) == 1) {
+		if (NS_PRV_BUFTYPE(skb) != BUF_SM) {
 			printk
 			    ("nicstar%d: Expected a small buffer, and this is not one.\n",
 			     card->index);
@@ -2081,26 +2137,27 @@ static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 			recycle_iov_buf(card, iovb);
 			return;
 		}
-	} else {		/* NS_SKB(iovb)->iovcnt >= 2 */
+	} else {		/* NS_PRV_IOVCNT(iovb) >= 2 */
 
-		if (NS_SKB_CB(skb)->buf_type != BUF_LG) {
+		if (NS_PRV_BUFTYPE(skb) != BUF_LG) {
 			printk
 			    ("nicstar%d: Expected a large buffer, and this is not one.\n",
 			     card->index);
 			which_list(card, skb);
 			atomic_inc(&vcc->stats->rx_err);
 			recycle_iovec_rx_bufs(card, (struct iovec *)iovb->data,
-					      NS_SKB(iovb)->iovcnt);
+					      NS_PRV_IOVCNT(iovb));
 			vc->rx_iov = NULL;
 			recycle_iov_buf(card, iovb);
 			return;
 		}
 	}
+#endif /* EXTRA_DEBUG */
 
 	if (ns_rsqe_eopdu(rsqe)) {
 		/* This works correctly regardless of the endianness of the host */
-		unsigned char *L1L2 = (unsigned char *)((u32) skb->data +
-							iov->iov_len - 6);
+		unsigned char *L1L2 = (unsigned char *)
+						(skb->data + iov->iov_len - 6);
 		aal5_len = L1L2[0] << 8 | L1L2[1];
 		len = (aal5_len == 0x0000) ? 0x10000 : aal5_len;
 		if (ns_rsqe_crcerr(rsqe) ||
@@ -2112,7 +2169,7 @@ static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 				printk(".\n");
 			atomic_inc(&vcc->stats->rx_err);
 			recycle_iovec_rx_bufs(card, (struct iovec *)iovb->data,
-					      NS_SKB(iovb)->iovcnt);
+					      NS_PRV_IOVCNT(iovb));
 			vc->rx_iov = NULL;
 			recycle_iov_buf(card, iovb);
 			return;
@@ -2120,7 +2177,7 @@ static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 
 		/* By this point we (hopefully) have a complete SDU without errors. */
 
-		if (NS_SKB(iovb)->iovcnt == 1) {	/* Just a small buffer */
+		if (NS_PRV_IOVCNT(iovb) == 1) {	/* Just a small buffer */
 			/* skb points to a small buffer */
 			if (!atm_charge(vcc, skb->truesize)) {
 				push_rxbufs(card, skb);
@@ -2136,7 +2193,7 @@ static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 				vcc->push(vcc, skb);
 				atomic_inc(&vcc->stats->rx);
 			}
-		} else if (NS_SKB(iovb)->iovcnt == 2) {	/* One small plus one large buffer */
+		} else if (NS_PRV_IOVCNT(iovb) == 2) {	/* One small plus one large buffer */
 			struct sk_buff *sb;
 
 			sb = (struct sk_buff *)(iov - 1)->iov_base;
@@ -2202,8 +2259,7 @@ static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 					recycle_iovec_rx_bufs(card,
 							      (struct iovec *)
 							      iovb->data,
-							      NS_SKB(iovb)->
-							      iovcnt);
+							      NS_PRV_IOVCNT(iovb));
 					vc->rx_iov = NULL;
 					recycle_iov_buf(card, iovb);
 					return;
@@ -2217,12 +2273,12 @@ static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 						card->hbpool.count++;
 					}
 				}
-				NS_SKB_CB(hb)->buf_type = BUF_NONE;
+				NS_PRV_BUFTYPE(hb) = BUF_NONE;
 			} else if (--card->hbpool.count < card->hbnr.min) {
 				struct sk_buff *new_hb;
 				if ((new_hb =
 				     dev_alloc_skb(NS_HBUFSIZE)) != NULL) {
-					NS_SKB_CB(new_hb)->buf_type = BUF_NONE;
+					NS_PRV_BUFTYPE(new_hb) = BUF_NONE;
 					skb_queue_tail(&card->hbpool.queue,
 						       new_hb);
 					card->hbpool.count++;
@@ -2231,7 +2287,7 @@ static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 					if ((new_hb =
 					     dev_alloc_skb(NS_HBUFSIZE)) !=
 					    NULL) {
-						NS_SKB_CB(new_hb)->buf_type =
+						NS_PRV_BUFTYPE(new_hb) =
 						    BUF_NONE;
 						skb_queue_tail(&card->hbpool.
 							       queue, new_hb);
@@ -2244,7 +2300,7 @@ static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 
 			if (!atm_charge(vcc, hb->truesize)) {
 				recycle_iovec_rx_bufs(card, iov,
-						      NS_SKB(iovb)->iovcnt);
+						      NS_PRV_IOVCNT(iovb));
 				if (card->hbpool.count < card->hbnr.max) {
 					skb_queue_tail(&card->hbpool.queue, hb);
 					card->hbpool.count++;
@@ -2263,7 +2319,7 @@ static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 				push_rxbufs(card, sb);
 
 				/* Copy all large buffers to the huge buffer and free them */
-				for (j = 1; j < NS_SKB(iovb)->iovcnt; j++) {
+				for (j = 1; j < NS_PRV_IOVCNT(iovb); j++) {
 					lb = (struct sk_buff *)iov->iov_base;
 					tocopy =
 					    min_t(int, remaining, iov->iov_len);
@@ -2313,7 +2369,7 @@ static void ns_sb_destructor(struct sk_buff *sb)
 		sb = __dev_alloc_skb(NS_SMSKBSIZE, GFP_KERNEL);
 		if (sb == NULL)
 			break;
-		NS_SKB_CB(sb)->buf_type = BUF_SM;
+		NS_PRV_BUFTYPE(sb) = BUF_SM;
 		skb_queue_tail(&card->sbpool.queue, sb);
 		skb_reserve(sb, NS_AAL0_HEADER);
 		push_rxbufs(card, sb);
@@ -2334,7 +2390,7 @@ static void ns_lb_destructor(struct sk_buff *lb)
 		lb = __dev_alloc_skb(NS_LGSKBSIZE, GFP_KERNEL);
 		if (lb == NULL)
 			break;
-		NS_SKB_CB(lb)->buf_type = BUF_LG;
+		NS_PRV_BUFTYPE(lb) = BUF_LG;
 		skb_queue_tail(&card->lbpool.queue, lb);
 		skb_reserve(lb, NS_SMBUFSIZE);
 		push_rxbufs(card, lb);
@@ -2351,7 +2407,7 @@ static void ns_hb_destructor(struct sk_buff *hb)
 		hb = __dev_alloc_skb(NS_HBUFSIZE, GFP_KERNEL);
 		if (hb == NULL)
 			break;
-		NS_SKB_CB(hb)->buf_type = BUF_NONE;
+		NS_PRV_BUFTYPE(hb) = BUF_NONE;
 		skb_queue_tail(&card->hbpool.queue, hb);
 		card->hbpool.count++;
 	}
@@ -2361,9 +2417,7 @@ static void ns_hb_destructor(struct sk_buff *hb)
 
 static void recycle_rx_buf(ns_dev * card, struct sk_buff *skb)
 {
-	struct ns_skb_cb *cb = NS_SKB_CB(skb);
-
-	if (unlikely(cb->buf_type == BUF_NONE)) {
+	if (unlikely(NS_PRV_BUFTYPE(skb) == BUF_NONE)) {
 		printk("nicstar%d: What kind of rx buffer is this?\n",
 		       card->index);
 		dev_kfree_skb_any(skb);
@@ -2395,7 +2449,7 @@ static void dequeue_sm_buf(ns_dev * card, struct sk_buff *sb)
 	if (card->sbfqc < card->sbnr.init) {
 		struct sk_buff *new_sb;
 		if ((new_sb = dev_alloc_skb(NS_SMSKBSIZE)) != NULL) {
-			NS_SKB_CB(new_sb)->buf_type = BUF_SM;
+			NS_PRV_BUFTYPE(new_sb) = BUF_SM;
 			skb_queue_tail(&card->sbpool.queue, new_sb);
 			skb_reserve(new_sb, NS_AAL0_HEADER);
 			push_rxbufs(card, new_sb);
@@ -2406,7 +2460,7 @@ static void dequeue_sm_buf(ns_dev * card, struct sk_buff *sb)
 	{
 		struct sk_buff *new_sb;
 		if ((new_sb = dev_alloc_skb(NS_SMSKBSIZE)) != NULL) {
-			NS_SKB_CB(new_sb)->buf_type = BUF_SM;
+			NS_PRV_BUFTYPE(new_sb) = BUF_SM;
 			skb_queue_tail(&card->sbpool.queue, new_sb);
 			skb_reserve(new_sb, NS_AAL0_HEADER);
 			push_rxbufs(card, new_sb);
@@ -2423,7 +2477,7 @@ static void dequeue_lg_buf(ns_dev * card, struct sk_buff *lb)
 	if (card->lbfqc < card->lbnr.init) {
 		struct sk_buff *new_lb;
 		if ((new_lb = dev_alloc_skb(NS_LGSKBSIZE)) != NULL) {
-			NS_SKB_CB(new_lb)->buf_type = BUF_LG;
+			NS_PRV_BUFTYPE(new_lb) = BUF_LG;
 			skb_queue_tail(&card->lbpool.queue, new_lb);
 			skb_reserve(new_lb, NS_SMBUFSIZE);
 			push_rxbufs(card, new_lb);
@@ -2434,7 +2488,7 @@ static void dequeue_lg_buf(ns_dev * card, struct sk_buff *lb)
 	{
 		struct sk_buff *new_lb;
 		if ((new_lb = dev_alloc_skb(NS_LGSKBSIZE)) != NULL) {
-			NS_SKB_CB(new_lb)->buf_type = BUF_LG;
+			NS_PRV_BUFTYPE(new_lb) = BUF_LG;
 			skb_queue_tail(&card->lbpool.queue, new_lb);
 			skb_reserve(new_lb, NS_SMBUFSIZE);
 			push_rxbufs(card, new_lb);
@@ -2625,7 +2679,7 @@ static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user * arg)
 				sb = __dev_alloc_skb(NS_SMSKBSIZE, GFP_KERNEL);
 				if (sb == NULL)
 					return -ENOMEM;
-				NS_SKB_CB(sb)->buf_type = BUF_SM;
+				NS_PRV_BUFTYPE(sb) = BUF_SM;
 				skb_queue_tail(&card->sbpool.queue, sb);
 				skb_reserve(sb, NS_AAL0_HEADER);
 				push_rxbufs(card, sb);
@@ -2639,7 +2693,7 @@ static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user * arg)
 				lb = __dev_alloc_skb(NS_LGSKBSIZE, GFP_KERNEL);
 				if (lb == NULL)
 					return -ENOMEM;
-				NS_SKB_CB(lb)->buf_type = BUF_LG;
+				NS_PRV_BUFTYPE(lb) = BUF_LG;
 				skb_queue_tail(&card->lbpool.queue, lb);
 				skb_reserve(lb, NS_SMBUFSIZE);
 				push_rxbufs(card, lb);
@@ -2668,7 +2722,7 @@ static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user * arg)
 				hb = __dev_alloc_skb(NS_HBUFSIZE, GFP_KERNEL);
 				if (hb == NULL)
 					return -ENOMEM;
-				NS_SKB_CB(hb)->buf_type = BUF_NONE;
+				NS_PRV_BUFTYPE(hb) = BUF_NONE;
 				spin_lock_irqsave(&card->int_lock, flags);
 				skb_queue_tail(&card->hbpool.queue, hb);
 				card->hbpool.count++;
@@ -2698,7 +2752,7 @@ static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user * arg)
 				iovb = alloc_skb(NS_IOVBUFSIZE, GFP_KERNEL);
 				if (iovb == NULL)
 					return -ENOMEM;
-				NS_SKB_CB(iovb)->buf_type = BUF_NONE;
+				NS_PRV_BUFTYPE(iovb) = BUF_NONE;
 				spin_lock_irqsave(&card->int_lock, flags);
 				skb_queue_tail(&card->iovpool.queue, iovb);
 				card->iovpool.count++;
@@ -2723,10 +2777,12 @@ static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user * arg)
 	}
 }
 
+#ifdef EXTRA_DEBUG
 static void which_list(ns_dev * card, struct sk_buff *skb)
 {
-	printk("skb buf_type: 0x%08x\n", NS_SKB_CB(skb)->buf_type);
+	printk("skb buf_type: 0x%08x\n", NS_PRV_BUFTYPE(skb));
 }
+#endif /* EXTRA_DEBUG */
 
 static void ns_poll(unsigned long arg)
 {
@@ -2803,7 +2859,7 @@ static void ns_phy_put(struct atm_dev *dev, unsigned char value,
 	card = dev->dev_data;
 	spin_lock_irqsave(&card->res_lock, flags);
 	while (CMD_BUSY(card)) ;
-	writel((unsigned long)value, card->membase + DR0);
+	writel((u32) value, card->membase + DR0);
 	writel(NS_CMD_WRITE_UTILITY | 0x00000200 | (addr & 0x000000FF),
 	       card->membase + CMD);
 	spin_unlock_irqrestore(&card->res_lock, flags);
@@ -2813,7 +2869,7 @@ static unsigned char ns_phy_get(struct atm_dev *dev, unsigned long addr)
 {
 	ns_dev *card;
 	unsigned long flags;
-	unsigned long data;
+	u32 data;
 
 	card = dev->dev_data;
 	spin_lock_irqsave(&card->res_lock, flags);

commit 098fde114bf6655f4b75d71dbea208d039fc1de3
Author: chas williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
Date:   Sat May 29 09:03:44 2010 +0000

    atm: [nicstar] reformatted with Lindent
    
    Signed-off-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index b7473a6110a7..a07b6b7fc7d8 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -1,5 +1,4 @@
-/******************************************************************************
- *
+/*
  * nicstar.c
  *
  * Device driver supporting CBR for IDT 77201/77211 "NICStAR" based cards.
@@ -16,12 +15,10 @@
  *
  *
  * (C) INESC 1999
- *
- *
- ******************************************************************************/
-
+ */
 
-/**** IMPORTANT INFORMATION ***************************************************
+/*
+ * IMPORTANT INFORMATION
  *
  * There are currently three types of spinlocks:
  *
@@ -31,9 +28,9 @@
  *
  * These must NEVER be grabbed in reverse order.
  *
- ******************************************************************************/
+ */
 
-/* Header files ***************************************************************/
+/* Header files */
 
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -62,15 +59,14 @@
 #endif /* CONFIG_ATM_NICSTAR_USE_IDT77105 */
 
 #if BITS_PER_LONG != 32
-#  error FIXME: this driver requires a 32-bit platform
+# error FIXME: this driver requires a 32-bit platform
 #endif
 
-/* Additional code ************************************************************/
+/* Additional code */
 
 #include "nicstarmac.c"
 
-
-/* Configurable parameters ****************************************************/
+/* Configurable parameters */
 
 #undef PHY_LOOPBACK
 #undef TX_DEBUG
@@ -78,11 +74,10 @@
 #undef GENERAL_DEBUG
 #undef EXTRA_DEBUG
 
-#undef NS_USE_DESTRUCTORS /* For now keep this undefined unless you know
-                             you're going to use only raw ATM */
-
+#undef NS_USE_DESTRUCTORS	/* For now keep this undefined unless you know
+				   you're going to use only raw ATM */
 
-/* Do not touch these *********************************************************/
+/* Do not touch these */
 
 #ifdef TX_DEBUG
 #define TXPRINTK(args...) printk(args)
@@ -108,8 +103,7 @@
 #define XPRINTK(args...)
 #endif /* EXTRA_DEBUG */
 
-
-/* Macros *********************************************************************/
+/* Macros */
 
 #define CMD_BUSY(card) (readl((card)->membase + STAT) & NS_STAT_CMDBZ)
 
@@ -126,2890 +120,2711 @@
 #define ATM_SKB(s) (&(s)->atm)
 #endif
 
+/* Function declarations */
 
-/* Function declarations ******************************************************/
-
-static u32 ns_read_sram(ns_dev *card, u32 sram_address);
-static void ns_write_sram(ns_dev *card, u32 sram_address, u32 *value, int count);
+static u32 ns_read_sram(ns_dev * card, u32 sram_address);
+static void ns_write_sram(ns_dev * card, u32 sram_address, u32 * value,
+			  int count);
 static int __devinit ns_init_card(int i, struct pci_dev *pcidev);
-static void __devinit ns_init_card_error(ns_dev *card, int error);
+static void __devinit ns_init_card_error(ns_dev * card, int error);
 static scq_info *get_scq(int size, u32 scd);
-static void free_scq(scq_info *scq, struct atm_vcc *vcc);
+static void free_scq(scq_info * scq, struct atm_vcc *vcc);
 static void push_rxbufs(ns_dev *, struct sk_buff *);
 static irqreturn_t ns_irq_handler(int irq, void *dev_id);
 static int ns_open(struct atm_vcc *vcc);
 static void ns_close(struct atm_vcc *vcc);
-static void fill_tst(ns_dev *card, int n, vc_map *vc);
+static void fill_tst(ns_dev * card, int n, vc_map * vc);
 static int ns_send(struct atm_vcc *vcc, struct sk_buff *skb);
-static int push_scqe(ns_dev *card, vc_map *vc, scq_info *scq, ns_scqe *tbd,
-                     struct sk_buff *skb);
-static void process_tsq(ns_dev *card);
-static void drain_scq(ns_dev *card, scq_info *scq, int pos);
-static void process_rsq(ns_dev *card);
-static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe);
+static int push_scqe(ns_dev * card, vc_map * vc, scq_info * scq, ns_scqe * tbd,
+		     struct sk_buff *skb);
+static void process_tsq(ns_dev * card);
+static void drain_scq(ns_dev * card, scq_info * scq, int pos);
+static void process_rsq(ns_dev * card);
+static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe);
 #ifdef NS_USE_DESTRUCTORS
 static void ns_sb_destructor(struct sk_buff *sb);
 static void ns_lb_destructor(struct sk_buff *lb);
 static void ns_hb_destructor(struct sk_buff *hb);
 #endif /* NS_USE_DESTRUCTORS */
-static void recycle_rx_buf(ns_dev *card, struct sk_buff *skb);
-static void recycle_iovec_rx_bufs(ns_dev *card, struct iovec *iov, int count);
-static void recycle_iov_buf(ns_dev *card, struct sk_buff *iovb);
-static void dequeue_sm_buf(ns_dev *card, struct sk_buff *sb);
-static void dequeue_lg_buf(ns_dev *card, struct sk_buff *lb);
-static int ns_proc_read(struct atm_dev *dev, loff_t *pos, char *page);
-static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg);
-static void which_list(ns_dev *card, struct sk_buff *skb);
+static void recycle_rx_buf(ns_dev * card, struct sk_buff *skb);
+static void recycle_iovec_rx_bufs(ns_dev * card, struct iovec *iov, int count);
+static void recycle_iov_buf(ns_dev * card, struct sk_buff *iovb);
+static void dequeue_sm_buf(ns_dev * card, struct sk_buff *sb);
+static void dequeue_lg_buf(ns_dev * card, struct sk_buff *lb);
+static int ns_proc_read(struct atm_dev *dev, loff_t * pos, char *page);
+static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user * arg);
+static void which_list(ns_dev * card, struct sk_buff *skb);
 static void ns_poll(unsigned long arg);
 static int ns_parse_mac(char *mac, unsigned char *esi);
 static short ns_h2i(char c);
 static void ns_phy_put(struct atm_dev *dev, unsigned char value,
-                       unsigned long addr);
+		       unsigned long addr);
 static unsigned char ns_phy_get(struct atm_dev *dev, unsigned long addr);
 
-
-
-/* Global variables ***********************************************************/
+/* Global variables */
 
 static struct ns_dev *cards[NS_MAX_CARDS];
 static unsigned num_cards;
-static struct atmdev_ops atm_ops =
-{
-   .open	= ns_open,
-   .close	= ns_close,
-   .ioctl	= ns_ioctl,
-   .send	= ns_send,
-   .phy_put	= ns_phy_put,
-   .phy_get	= ns_phy_get,
-   .proc_read	= ns_proc_read,
-   .owner	= THIS_MODULE,
+static struct atmdev_ops atm_ops = {
+	.open = ns_open,
+	.close = ns_close,
+	.ioctl = ns_ioctl,
+	.send = ns_send,
+	.phy_put = ns_phy_put,
+	.phy_get = ns_phy_get,
+	.proc_read = ns_proc_read,
+	.owner = THIS_MODULE,
 };
+
 static struct timer_list ns_timer;
 static char *mac[NS_MAX_CARDS];
 module_param_array(mac, charp, NULL, 0);
 MODULE_LICENSE("GPL");
 
-
-/* Functions*******************************************************************/
+/* Functions */
 
 static int __devinit nicstar_init_one(struct pci_dev *pcidev,
 				      const struct pci_device_id *ent)
 {
-   static int index = -1;
-   unsigned int error;
+	static int index = -1;
+	unsigned int error;
 
-   index++;
-   cards[index] = NULL;
+	index++;
+	cards[index] = NULL;
 
-   error = ns_init_card(index, pcidev);
-   if (error) {
-      cards[index--] = NULL;	/* don't increment index */
-      goto err_out;
-   }
+	error = ns_init_card(index, pcidev);
+	if (error) {
+		cards[index--] = NULL;	/* don't increment index */
+		goto err_out;
+	}
 
-   return 0;
+	return 0;
 err_out:
-   return -ENODEV;
+	return -ENODEV;
 }
 
-
-
 static void __devexit nicstar_remove_one(struct pci_dev *pcidev)
 {
-   int i, j;
-   ns_dev *card = pci_get_drvdata(pcidev);
-   struct sk_buff *hb;
-   struct sk_buff *iovb;
-   struct sk_buff *lb;
-   struct sk_buff *sb;
-   
-   i = card->index;
-
-   if (cards[i] == NULL)
-      return;
-
-   if (card->atmdev->phy && card->atmdev->phy->stop)
-      card->atmdev->phy->stop(card->atmdev);
-
-   /* Stop everything */
-   writel(0x00000000, card->membase + CFG);
-
-   /* De-register device */
-   atm_dev_deregister(card->atmdev);
-
-   /* Disable PCI device */
-   pci_disable_device(pcidev);
-   
-   /* Free up resources */
-   j = 0;
-   PRINTK("nicstar%d: freeing %d huge buffers.\n", i, card->hbpool.count);
-   while ((hb = skb_dequeue(&card->hbpool.queue)) != NULL)
-   {
-      dev_kfree_skb_any(hb);
-      j++;
-   }
-   PRINTK("nicstar%d: %d huge buffers freed.\n", i, j);
-   j = 0;
-   PRINTK("nicstar%d: freeing %d iovec buffers.\n", i, card->iovpool.count);
-   while ((iovb = skb_dequeue(&card->iovpool.queue)) != NULL)
-   {
-      dev_kfree_skb_any(iovb);
-      j++;
-   }
-   PRINTK("nicstar%d: %d iovec buffers freed.\n", i, j);
-   while ((lb = skb_dequeue(&card->lbpool.queue)) != NULL)
-      dev_kfree_skb_any(lb);
-   while ((sb = skb_dequeue(&card->sbpool.queue)) != NULL)
-      dev_kfree_skb_any(sb);
-   free_scq(card->scq0, NULL);
-   for (j = 0; j < NS_FRSCD_NUM; j++)
-   {
-      if (card->scd2vc[j] != NULL)
-         free_scq(card->scd2vc[j]->scq, card->scd2vc[j]->tx_vcc);
-   }
-   kfree(card->rsq.org);
-   kfree(card->tsq.org);
-   free_irq(card->pcidev->irq, card);
-   iounmap(card->membase);
-   kfree(card);
+	int i, j;
+	ns_dev *card = pci_get_drvdata(pcidev);
+	struct sk_buff *hb;
+	struct sk_buff *iovb;
+	struct sk_buff *lb;
+	struct sk_buff *sb;
+
+	i = card->index;
+
+	if (cards[i] == NULL)
+		return;
+
+	if (card->atmdev->phy && card->atmdev->phy->stop)
+		card->atmdev->phy->stop(card->atmdev);
+
+	/* Stop everything */
+	writel(0x00000000, card->membase + CFG);
+
+	/* De-register device */
+	atm_dev_deregister(card->atmdev);
+
+	/* Disable PCI device */
+	pci_disable_device(pcidev);
+
+	/* Free up resources */
+	j = 0;
+	PRINTK("nicstar%d: freeing %d huge buffers.\n", i, card->hbpool.count);
+	while ((hb = skb_dequeue(&card->hbpool.queue)) != NULL) {
+		dev_kfree_skb_any(hb);
+		j++;
+	}
+	PRINTK("nicstar%d: %d huge buffers freed.\n", i, j);
+	j = 0;
+	PRINTK("nicstar%d: freeing %d iovec buffers.\n", i,
+	       card->iovpool.count);
+	while ((iovb = skb_dequeue(&card->iovpool.queue)) != NULL) {
+		dev_kfree_skb_any(iovb);
+		j++;
+	}
+	PRINTK("nicstar%d: %d iovec buffers freed.\n", i, j);
+	while ((lb = skb_dequeue(&card->lbpool.queue)) != NULL)
+		dev_kfree_skb_any(lb);
+	while ((sb = skb_dequeue(&card->sbpool.queue)) != NULL)
+		dev_kfree_skb_any(sb);
+	free_scq(card->scq0, NULL);
+	for (j = 0; j < NS_FRSCD_NUM; j++) {
+		if (card->scd2vc[j] != NULL)
+			free_scq(card->scd2vc[j]->scq, card->scd2vc[j]->tx_vcc);
+	}
+	kfree(card->rsq.org);
+	kfree(card->tsq.org);
+	free_irq(card->pcidev->irq, card);
+	iounmap(card->membase);
+	kfree(card);
 }
 
-
-
-static struct pci_device_id nicstar_pci_tbl[] __devinitdata =
-{
+static struct pci_device_id nicstar_pci_tbl[] __devinitdata = {
 	{PCI_VENDOR_ID_IDT, PCI_DEVICE_ID_IDT_IDT77201,
 	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{0,}			/* terminate list */
 };
-MODULE_DEVICE_TABLE(pci, nicstar_pci_tbl);
-
 
+MODULE_DEVICE_TABLE(pci, nicstar_pci_tbl);
 
 static struct pci_driver nicstar_driver = {
-	.name		= "nicstar",
-	.id_table	= nicstar_pci_tbl,
-	.probe		= nicstar_init_one,
-	.remove		= __devexit_p(nicstar_remove_one),
+	.name = "nicstar",
+	.id_table = nicstar_pci_tbl,
+	.probe = nicstar_init_one,
+	.remove = __devexit_p(nicstar_remove_one),
 };
 
-
-
 static int __init nicstar_init(void)
 {
-   unsigned error = 0;	/* Initialized to remove compile warning */
+	unsigned error = 0;	/* Initialized to remove compile warning */
 
-   XPRINTK("nicstar: nicstar_init() called.\n");
+	XPRINTK("nicstar: nicstar_init() called.\n");
 
-   error = pci_register_driver(&nicstar_driver);
-   
-   TXPRINTK("nicstar: TX debug enabled.\n");
-   RXPRINTK("nicstar: RX debug enabled.\n");
-   PRINTK("nicstar: General debug enabled.\n");
+	error = pci_register_driver(&nicstar_driver);
+
+	TXPRINTK("nicstar: TX debug enabled.\n");
+	RXPRINTK("nicstar: RX debug enabled.\n");
+	PRINTK("nicstar: General debug enabled.\n");
 #ifdef PHY_LOOPBACK
-   printk("nicstar: using PHY loopback.\n");
+	printk("nicstar: using PHY loopback.\n");
 #endif /* PHY_LOOPBACK */
-   XPRINTK("nicstar: nicstar_init() returned.\n");
-
-   if (!error) {
-      init_timer(&ns_timer);
-      ns_timer.expires = jiffies + NS_POLL_PERIOD;
-      ns_timer.data = 0UL;
-      ns_timer.function = ns_poll;
-      add_timer(&ns_timer);
-   }
-   
-   return error;
-}
+	XPRINTK("nicstar: nicstar_init() returned.\n");
 
+	if (!error) {
+		init_timer(&ns_timer);
+		ns_timer.expires = jiffies + NS_POLL_PERIOD;
+		ns_timer.data = 0UL;
+		ns_timer.function = ns_poll;
+		add_timer(&ns_timer);
+	}
 
+	return error;
+}
 
 static void __exit nicstar_cleanup(void)
 {
-   XPRINTK("nicstar: nicstar_cleanup() called.\n");
+	XPRINTK("nicstar: nicstar_cleanup() called.\n");
 
-   del_timer(&ns_timer);
+	del_timer(&ns_timer);
 
-   pci_unregister_driver(&nicstar_driver);
+	pci_unregister_driver(&nicstar_driver);
 
-   XPRINTK("nicstar: nicstar_cleanup() returned.\n");
+	XPRINTK("nicstar: nicstar_cleanup() returned.\n");
 }
 
-
-
-static u32 ns_read_sram(ns_dev *card, u32 sram_address)
+static u32 ns_read_sram(ns_dev * card, u32 sram_address)
 {
-   unsigned long flags;
-   u32 data;
-   sram_address <<= 2;
-   sram_address &= 0x0007FFFC;	/* address must be dword aligned */
-   sram_address |= 0x50000000;	/* SRAM read command */
-   spin_lock_irqsave(&card->res_lock, flags);
-   while (CMD_BUSY(card));
-   writel(sram_address, card->membase + CMD);
-   while (CMD_BUSY(card));
-   data = readl(card->membase + DR0);
-   spin_unlock_irqrestore(&card->res_lock, flags);
-   return data;
+	unsigned long flags;
+	u32 data;
+	sram_address <<= 2;
+	sram_address &= 0x0007FFFC;	/* address must be dword aligned */
+	sram_address |= 0x50000000;	/* SRAM read command */
+	spin_lock_irqsave(&card->res_lock, flags);
+	while (CMD_BUSY(card)) ;
+	writel(sram_address, card->membase + CMD);
+	while (CMD_BUSY(card)) ;
+	data = readl(card->membase + DR0);
+	spin_unlock_irqrestore(&card->res_lock, flags);
+	return data;
 }
 
-
-   
-static void ns_write_sram(ns_dev *card, u32 sram_address, u32 *value, int count)
+static void ns_write_sram(ns_dev * card, u32 sram_address, u32 * value,
+			  int count)
 {
-   unsigned long flags;
-   int i, c;
-   count--;	/* count range now is 0..3 instead of 1..4 */
-   c = count;
-   c <<= 2;	/* to use increments of 4 */
-   spin_lock_irqsave(&card->res_lock, flags);
-   while (CMD_BUSY(card));
-   for (i = 0; i <= c; i += 4)
-      writel(*(value++), card->membase + i);
-   /* Note: DR# registers are the first 4 dwords in nicstar's memspace,
-            so card->membase + DR0 == card->membase */
-   sram_address <<= 2;
-   sram_address &= 0x0007FFFC;
-   sram_address |= (0x40000000 | count);
-   writel(sram_address, card->membase + CMD);
-   spin_unlock_irqrestore(&card->res_lock, flags);
+	unsigned long flags;
+	int i, c;
+	count--;		/* count range now is 0..3 instead of 1..4 */
+	c = count;
+	c <<= 2;		/* to use increments of 4 */
+	spin_lock_irqsave(&card->res_lock, flags);
+	while (CMD_BUSY(card)) ;
+	for (i = 0; i <= c; i += 4)
+		writel(*(value++), card->membase + i);
+	/* Note: DR# registers are the first 4 dwords in nicstar's memspace,
+	   so card->membase + DR0 == card->membase */
+	sram_address <<= 2;
+	sram_address &= 0x0007FFFC;
+	sram_address |= (0x40000000 | count);
+	writel(sram_address, card->membase + CMD);
+	spin_unlock_irqrestore(&card->res_lock, flags);
 }
 
-
 static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
 {
-   int j;
-   struct ns_dev *card = NULL;
-   unsigned char pci_latency;
-   unsigned error;
-   u32 data;
-   u32 u32d[4];
-   u32 ns_cfg_rctsize;
-   int bcount;
-   unsigned long membase;
-
-   error = 0;
-
-   if (pci_enable_device(pcidev))
-   {
-      printk("nicstar%d: can't enable PCI device\n", i);
-      error = 2;
-      ns_init_card_error(card, error);
-      return error;
-   }
-
-   if ((card = kmalloc(sizeof(ns_dev), GFP_KERNEL)) == NULL)
-   {
-      printk("nicstar%d: can't allocate memory for device structure.\n", i);
-      error = 2;
-      ns_init_card_error(card, error);
-      return error;
-   }
-   cards[i] = card;
-   spin_lock_init(&card->int_lock);
-   spin_lock_init(&card->res_lock);
-      
-   pci_set_drvdata(pcidev, card);
-   
-   card->index = i;
-   card->atmdev = NULL;
-   card->pcidev = pcidev;
-   membase = pci_resource_start(pcidev, 1);
-   card->membase = ioremap(membase, NS_IOREMAP_SIZE);
-   if (!card->membase)
-   {
-      printk("nicstar%d: can't ioremap() membase.\n",i);
-      error = 3;
-      ns_init_card_error(card, error);
-      return error;
-   }
-   PRINTK("nicstar%d: membase at 0x%x.\n", i, card->membase);
-
-   pci_set_master(pcidev);
-
-   if (pci_read_config_byte(pcidev, PCI_LATENCY_TIMER, &pci_latency) != 0)
-   {
-      printk("nicstar%d: can't read PCI latency timer.\n", i);
-      error = 6;
-      ns_init_card_error(card, error);
-      return error;
-   }
+	int j;
+	struct ns_dev *card = NULL;
+	unsigned char pci_latency;
+	unsigned error;
+	u32 data;
+	u32 u32d[4];
+	u32 ns_cfg_rctsize;
+	int bcount;
+	unsigned long membase;
+
+	error = 0;
+
+	if (pci_enable_device(pcidev)) {
+		printk("nicstar%d: can't enable PCI device\n", i);
+		error = 2;
+		ns_init_card_error(card, error);
+		return error;
+	}
+
+	if ((card = kmalloc(sizeof(ns_dev), GFP_KERNEL)) == NULL) {
+		printk
+		    ("nicstar%d: can't allocate memory for device structure.\n",
+		     i);
+		error = 2;
+		ns_init_card_error(card, error);
+		return error;
+	}
+	cards[i] = card;
+	spin_lock_init(&card->int_lock);
+	spin_lock_init(&card->res_lock);
+
+	pci_set_drvdata(pcidev, card);
+
+	card->index = i;
+	card->atmdev = NULL;
+	card->pcidev = pcidev;
+	membase = pci_resource_start(pcidev, 1);
+	card->membase = ioremap(membase, NS_IOREMAP_SIZE);
+	if (!card->membase) {
+		printk("nicstar%d: can't ioremap() membase.\n", i);
+		error = 3;
+		ns_init_card_error(card, error);
+		return error;
+	}
+	PRINTK("nicstar%d: membase at 0x%x.\n", i, card->membase);
+
+	pci_set_master(pcidev);
+
+	if (pci_read_config_byte(pcidev, PCI_LATENCY_TIMER, &pci_latency) != 0) {
+		printk("nicstar%d: can't read PCI latency timer.\n", i);
+		error = 6;
+		ns_init_card_error(card, error);
+		return error;
+	}
 #ifdef NS_PCI_LATENCY
-   if (pci_latency < NS_PCI_LATENCY)
-   {
-      PRINTK("nicstar%d: setting PCI latency timer to %d.\n", i, NS_PCI_LATENCY);
-      for (j = 1; j < 4; j++)
-      {
-         if (pci_write_config_byte(pcidev, PCI_LATENCY_TIMER, NS_PCI_LATENCY) != 0)
-	    break;
-      }
-      if (j == 4)
-      {
-         printk("nicstar%d: can't set PCI latency timer to %d.\n", i, NS_PCI_LATENCY);
-         error = 7;
-         ns_init_card_error(card, error);
-	 return error;
-      }
-   }
+	if (pci_latency < NS_PCI_LATENCY) {
+		PRINTK("nicstar%d: setting PCI latency timer to %d.\n", i,
+		       NS_PCI_LATENCY);
+		for (j = 1; j < 4; j++) {
+			if (pci_write_config_byte
+			    (pcidev, PCI_LATENCY_TIMER, NS_PCI_LATENCY) != 0)
+				break;
+		}
+		if (j == 4) {
+			printk
+			    ("nicstar%d: can't set PCI latency timer to %d.\n",
+			     i, NS_PCI_LATENCY);
+			error = 7;
+			ns_init_card_error(card, error);
+			return error;
+		}
+	}
 #endif /* NS_PCI_LATENCY */
-      
-   /* Clear timer overflow */
-   data = readl(card->membase + STAT);
-   if (data & NS_STAT_TMROF)
-      writel(NS_STAT_TMROF, card->membase + STAT);
-
-   /* Software reset */
-   writel(NS_CFG_SWRST, card->membase + CFG);
-   NS_DELAY;
-   writel(0x00000000, card->membase + CFG);
-
-   /* PHY reset */
-   writel(0x00000008, card->membase + GP);
-   NS_DELAY;
-   writel(0x00000001, card->membase + GP);
-   NS_DELAY;
-   while (CMD_BUSY(card));
-   writel(NS_CMD_WRITE_UTILITY | 0x00000100, card->membase + CMD);	/* Sync UTOPIA with SAR clock */
-   NS_DELAY;
-      
-   /* Detect PHY type */
-   while (CMD_BUSY(card));
-   writel(NS_CMD_READ_UTILITY | 0x00000200, card->membase + CMD);
-   while (CMD_BUSY(card));
-   data = readl(card->membase + DR0);
-   switch(data) {
-      case 0x00000009:
-         printk("nicstar%d: PHY seems to be 25 Mbps.\n", i);
-         card->max_pcr = ATM_25_PCR;
-         while(CMD_BUSY(card));
-         writel(0x00000008, card->membase + DR0);
-         writel(NS_CMD_WRITE_UTILITY | 0x00000200, card->membase + CMD);
-         /* Clear an eventual pending interrupt */
-         writel(NS_STAT_SFBQF, card->membase + STAT);
+
+	/* Clear timer overflow */
+	data = readl(card->membase + STAT);
+	if (data & NS_STAT_TMROF)
+		writel(NS_STAT_TMROF, card->membase + STAT);
+
+	/* Software reset */
+	writel(NS_CFG_SWRST, card->membase + CFG);
+	NS_DELAY;
+	writel(0x00000000, card->membase + CFG);
+
+	/* PHY reset */
+	writel(0x00000008, card->membase + GP);
+	NS_DELAY;
+	writel(0x00000001, card->membase + GP);
+	NS_DELAY;
+	while (CMD_BUSY(card)) ;
+	writel(NS_CMD_WRITE_UTILITY | 0x00000100, card->membase + CMD);	/* Sync UTOPIA with SAR clock */
+	NS_DELAY;
+
+	/* Detect PHY type */
+	while (CMD_BUSY(card)) ;
+	writel(NS_CMD_READ_UTILITY | 0x00000200, card->membase + CMD);
+	while (CMD_BUSY(card)) ;
+	data = readl(card->membase + DR0);
+	switch (data) {
+	case 0x00000009:
+		printk("nicstar%d: PHY seems to be 25 Mbps.\n", i);
+		card->max_pcr = ATM_25_PCR;
+		while (CMD_BUSY(card)) ;
+		writel(0x00000008, card->membase + DR0);
+		writel(NS_CMD_WRITE_UTILITY | 0x00000200, card->membase + CMD);
+		/* Clear an eventual pending interrupt */
+		writel(NS_STAT_SFBQF, card->membase + STAT);
 #ifdef PHY_LOOPBACK
-         while(CMD_BUSY(card));
-         writel(0x00000022, card->membase + DR0);
-         writel(NS_CMD_WRITE_UTILITY | 0x00000202, card->membase + CMD);
+		while (CMD_BUSY(card)) ;
+		writel(0x00000022, card->membase + DR0);
+		writel(NS_CMD_WRITE_UTILITY | 0x00000202, card->membase + CMD);
 #endif /* PHY_LOOPBACK */
-	 break;
-      case 0x00000030:
-      case 0x00000031:
-         printk("nicstar%d: PHY seems to be 155 Mbps.\n", i);
-         card->max_pcr = ATM_OC3_PCR;
+		break;
+	case 0x00000030:
+	case 0x00000031:
+		printk("nicstar%d: PHY seems to be 155 Mbps.\n", i);
+		card->max_pcr = ATM_OC3_PCR;
 #ifdef PHY_LOOPBACK
-         while(CMD_BUSY(card));
-         writel(0x00000002, card->membase + DR0);
-         writel(NS_CMD_WRITE_UTILITY | 0x00000205, card->membase + CMD);
+		while (CMD_BUSY(card)) ;
+		writel(0x00000002, card->membase + DR0);
+		writel(NS_CMD_WRITE_UTILITY | 0x00000205, card->membase + CMD);
 #endif /* PHY_LOOPBACK */
-	 break;
-      default:
-         printk("nicstar%d: unknown PHY type (0x%08X).\n", i, data);
-         error = 8;
-         ns_init_card_error(card, error);
-         return error;
-   }
-   writel(0x00000000, card->membase + GP);
-
-   /* Determine SRAM size */
-   data = 0x76543210;
-   ns_write_sram(card, 0x1C003, &data, 1);
-   data = 0x89ABCDEF;
-   ns_write_sram(card, 0x14003, &data, 1);
-   if (ns_read_sram(card, 0x14003) == 0x89ABCDEF &&
-       ns_read_sram(card, 0x1C003) == 0x76543210)
-       card->sram_size = 128;
-   else
-      card->sram_size = 32;
-   PRINTK("nicstar%d: %dK x 32bit SRAM size.\n", i, card->sram_size);
-
-   card->rct_size = NS_MAX_RCTSIZE;
+		break;
+	default:
+		printk("nicstar%d: unknown PHY type (0x%08X).\n", i, data);
+		error = 8;
+		ns_init_card_error(card, error);
+		return error;
+	}
+	writel(0x00000000, card->membase + GP);
+
+	/* Determine SRAM size */
+	data = 0x76543210;
+	ns_write_sram(card, 0x1C003, &data, 1);
+	data = 0x89ABCDEF;
+	ns_write_sram(card, 0x14003, &data, 1);
+	if (ns_read_sram(card, 0x14003) == 0x89ABCDEF &&
+	    ns_read_sram(card, 0x1C003) == 0x76543210)
+		card->sram_size = 128;
+	else
+		card->sram_size = 32;
+	PRINTK("nicstar%d: %dK x 32bit SRAM size.\n", i, card->sram_size);
+
+	card->rct_size = NS_MAX_RCTSIZE;
 
 #if (NS_MAX_RCTSIZE == 4096)
-   if (card->sram_size == 128)
-      printk("nicstar%d: limiting maximum VCI. See NS_MAX_RCTSIZE in nicstar.h\n", i);
+	if (card->sram_size == 128)
+		printk
+		    ("nicstar%d: limiting maximum VCI. See NS_MAX_RCTSIZE in nicstar.h\n",
+		     i);
 #elif (NS_MAX_RCTSIZE == 16384)
-   if (card->sram_size == 32)
-   {
-      printk("nicstar%d: wasting memory. See NS_MAX_RCTSIZE in nicstar.h\n", i);
-      card->rct_size = 4096;
-   }
+	if (card->sram_size == 32) {
+		printk
+		    ("nicstar%d: wasting memory. See NS_MAX_RCTSIZE in nicstar.h\n",
+		     i);
+		card->rct_size = 4096;
+	}
 #else
 #error NS_MAX_RCTSIZE must be either 4096 or 16384 in nicstar.c
 #endif
 
-   card->vpibits = NS_VPIBITS;
-   if (card->rct_size == 4096)
-      card->vcibits = 12 - NS_VPIBITS;
-   else /* card->rct_size == 16384 */
-      card->vcibits = 14 - NS_VPIBITS;
-
-   /* Initialize the nicstar eeprom/eprom stuff, for the MAC addr */
-   if (mac[i] == NULL)
-      nicstar_init_eprom(card->membase);
-
-   /* Set the VPI/VCI MSb mask to zero so we can receive OAM cells */
-   writel(0x00000000, card->membase + VPM);
-      
-   /* Initialize TSQ */
-   card->tsq.org = kmalloc(NS_TSQSIZE + NS_TSQ_ALIGNMENT, GFP_KERNEL);
-   if (card->tsq.org == NULL)
-   {
-      printk("nicstar%d: can't allocate TSQ.\n", i);
-      error = 10;
-      ns_init_card_error(card, error);
-      return error;
-   }
-   card->tsq.base = (ns_tsi *) ALIGN_ADDRESS(card->tsq.org, NS_TSQ_ALIGNMENT);
-   card->tsq.next = card->tsq.base;
-   card->tsq.last = card->tsq.base + (NS_TSQ_NUM_ENTRIES - 1);
-   for (j = 0; j < NS_TSQ_NUM_ENTRIES; j++)
-      ns_tsi_init(card->tsq.base + j);
-   writel(0x00000000, card->membase + TSQH);
-   writel((u32) virt_to_bus(card->tsq.base), card->membase + TSQB);
-   PRINTK("nicstar%d: TSQ base at 0x%x  0x%x  0x%x.\n", i, (u32) card->tsq.base,
-          (u32) virt_to_bus(card->tsq.base), readl(card->membase + TSQB));
-      
-   /* Initialize RSQ */
-   card->rsq.org = kmalloc(NS_RSQSIZE + NS_RSQ_ALIGNMENT, GFP_KERNEL);
-   if (card->rsq.org == NULL)
-   {
-      printk("nicstar%d: can't allocate RSQ.\n", i);
-      error = 11;
-      ns_init_card_error(card, error);
-      return error;
-   }
-   card->rsq.base = (ns_rsqe *) ALIGN_ADDRESS(card->rsq.org, NS_RSQ_ALIGNMENT);
-   card->rsq.next = card->rsq.base;
-   card->rsq.last = card->rsq.base + (NS_RSQ_NUM_ENTRIES - 1);
-   for (j = 0; j < NS_RSQ_NUM_ENTRIES; j++)
-      ns_rsqe_init(card->rsq.base + j);
-   writel(0x00000000, card->membase + RSQH);
-   writel((u32) virt_to_bus(card->rsq.base), card->membase + RSQB);
-   PRINTK("nicstar%d: RSQ base at 0x%x.\n", i, (u32) card->rsq.base);
-      
-   /* Initialize SCQ0, the only VBR SCQ used */
-   card->scq1 = NULL;
-   card->scq2 = NULL;
-   card->scq0 = get_scq(VBR_SCQSIZE, NS_VRSCD0);
-   if (card->scq0 == NULL)
-   {
-      printk("nicstar%d: can't get SCQ0.\n", i);
-      error = 12;
-      ns_init_card_error(card, error);
-      return error;
-   }
-   u32d[0] = (u32) virt_to_bus(card->scq0->base);
-   u32d[1] = (u32) 0x00000000;
-   u32d[2] = (u32) 0xffffffff;
-   u32d[3] = (u32) 0x00000000;
-   ns_write_sram(card, NS_VRSCD0, u32d, 4);
-   ns_write_sram(card, NS_VRSCD1, u32d, 4);	/* These last two won't be used */
-   ns_write_sram(card, NS_VRSCD2, u32d, 4);	/* but are initialized, just in case... */
-   card->scq0->scd = NS_VRSCD0;
-   PRINTK("nicstar%d: VBR-SCQ0 base at 0x%x.\n", i, (u32) card->scq0->base);
-
-   /* Initialize TSTs */
-   card->tst_addr = NS_TST0;
-   card->tst_free_entries = NS_TST_NUM_ENTRIES;
-   data = NS_TST_OPCODE_VARIABLE;
-   for (j = 0; j < NS_TST_NUM_ENTRIES; j++)
-      ns_write_sram(card, NS_TST0 + j, &data, 1);
-   data = ns_tste_make(NS_TST_OPCODE_END, NS_TST0);
-   ns_write_sram(card, NS_TST0 + NS_TST_NUM_ENTRIES, &data, 1);
-   for (j = 0; j < NS_TST_NUM_ENTRIES; j++)
-      ns_write_sram(card, NS_TST1 + j, &data, 1);
-   data = ns_tste_make(NS_TST_OPCODE_END, NS_TST1);
-   ns_write_sram(card, NS_TST1 + NS_TST_NUM_ENTRIES, &data, 1);
-   for (j = 0; j < NS_TST_NUM_ENTRIES; j++)
-      card->tste2vc[j] = NULL;
-   writel(NS_TST0 << 2, card->membase + TSTB);
-
-
-   /* Initialize RCT. AAL type is set on opening the VC. */
+	card->vpibits = NS_VPIBITS;
+	if (card->rct_size == 4096)
+		card->vcibits = 12 - NS_VPIBITS;
+	else			/* card->rct_size == 16384 */
+		card->vcibits = 14 - NS_VPIBITS;
+
+	/* Initialize the nicstar eeprom/eprom stuff, for the MAC addr */
+	if (mac[i] == NULL)
+		nicstar_init_eprom(card->membase);
+
+	/* Set the VPI/VCI MSb mask to zero so we can receive OAM cells */
+	writel(0x00000000, card->membase + VPM);
+
+	/* Initialize TSQ */
+	card->tsq.org = kmalloc(NS_TSQSIZE + NS_TSQ_ALIGNMENT, GFP_KERNEL);
+	if (card->tsq.org == NULL) {
+		printk("nicstar%d: can't allocate TSQ.\n", i);
+		error = 10;
+		ns_init_card_error(card, error);
+		return error;
+	}
+	card->tsq.base =
+	    (ns_tsi *) ALIGN_ADDRESS(card->tsq.org, NS_TSQ_ALIGNMENT);
+	card->tsq.next = card->tsq.base;
+	card->tsq.last = card->tsq.base + (NS_TSQ_NUM_ENTRIES - 1);
+	for (j = 0; j < NS_TSQ_NUM_ENTRIES; j++)
+		ns_tsi_init(card->tsq.base + j);
+	writel(0x00000000, card->membase + TSQH);
+	writel((u32) virt_to_bus(card->tsq.base), card->membase + TSQB);
+	PRINTK("nicstar%d: TSQ base at 0x%x  0x%x  0x%x.\n", i,
+	       (u32) card->tsq.base, (u32) virt_to_bus(card->tsq.base),
+	       readl(card->membase + TSQB));
+
+	/* Initialize RSQ */
+	card->rsq.org = kmalloc(NS_RSQSIZE + NS_RSQ_ALIGNMENT, GFP_KERNEL);
+	if (card->rsq.org == NULL) {
+		printk("nicstar%d: can't allocate RSQ.\n", i);
+		error = 11;
+		ns_init_card_error(card, error);
+		return error;
+	}
+	card->rsq.base =
+	    (ns_rsqe *) ALIGN_ADDRESS(card->rsq.org, NS_RSQ_ALIGNMENT);
+	card->rsq.next = card->rsq.base;
+	card->rsq.last = card->rsq.base + (NS_RSQ_NUM_ENTRIES - 1);
+	for (j = 0; j < NS_RSQ_NUM_ENTRIES; j++)
+		ns_rsqe_init(card->rsq.base + j);
+	writel(0x00000000, card->membase + RSQH);
+	writel((u32) virt_to_bus(card->rsq.base), card->membase + RSQB);
+	PRINTK("nicstar%d: RSQ base at 0x%x.\n", i, (u32) card->rsq.base);
+
+	/* Initialize SCQ0, the only VBR SCQ used */
+	card->scq1 = NULL;
+	card->scq2 = NULL;
+	card->scq0 = get_scq(VBR_SCQSIZE, NS_VRSCD0);
+	if (card->scq0 == NULL) {
+		printk("nicstar%d: can't get SCQ0.\n", i);
+		error = 12;
+		ns_init_card_error(card, error);
+		return error;
+	}
+	u32d[0] = (u32) virt_to_bus(card->scq0->base);
+	u32d[1] = (u32) 0x00000000;
+	u32d[2] = (u32) 0xffffffff;
+	u32d[3] = (u32) 0x00000000;
+	ns_write_sram(card, NS_VRSCD0, u32d, 4);
+	ns_write_sram(card, NS_VRSCD1, u32d, 4);	/* These last two won't be used */
+	ns_write_sram(card, NS_VRSCD2, u32d, 4);	/* but are initialized, just in case... */
+	card->scq0->scd = NS_VRSCD0;
+	PRINTK("nicstar%d: VBR-SCQ0 base at 0x%x.\n", i,
+	       (u32) card->scq0->base);
+
+	/* Initialize TSTs */
+	card->tst_addr = NS_TST0;
+	card->tst_free_entries = NS_TST_NUM_ENTRIES;
+	data = NS_TST_OPCODE_VARIABLE;
+	for (j = 0; j < NS_TST_NUM_ENTRIES; j++)
+		ns_write_sram(card, NS_TST0 + j, &data, 1);
+	data = ns_tste_make(NS_TST_OPCODE_END, NS_TST0);
+	ns_write_sram(card, NS_TST0 + NS_TST_NUM_ENTRIES, &data, 1);
+	for (j = 0; j < NS_TST_NUM_ENTRIES; j++)
+		ns_write_sram(card, NS_TST1 + j, &data, 1);
+	data = ns_tste_make(NS_TST_OPCODE_END, NS_TST1);
+	ns_write_sram(card, NS_TST1 + NS_TST_NUM_ENTRIES, &data, 1);
+	for (j = 0; j < NS_TST_NUM_ENTRIES; j++)
+		card->tste2vc[j] = NULL;
+	writel(NS_TST0 << 2, card->membase + TSTB);
+
+	/* Initialize RCT. AAL type is set on opening the VC. */
 #ifdef RCQ_SUPPORT
-   u32d[0] = NS_RCTE_RAWCELLINTEN;
+	u32d[0] = NS_RCTE_RAWCELLINTEN;
 #else
-   u32d[0] = 0x00000000;
+	u32d[0] = 0x00000000;
 #endif /* RCQ_SUPPORT */
-   u32d[1] = 0x00000000;
-   u32d[2] = 0x00000000;
-   u32d[3] = 0xFFFFFFFF;
-   for (j = 0; j < card->rct_size; j++)
-      ns_write_sram(card, j * 4, u32d, 4);      
-      
-   memset(card->vcmap, 0, NS_MAX_RCTSIZE * sizeof(vc_map));
-      
-   for (j = 0; j < NS_FRSCD_NUM; j++)
-      card->scd2vc[j] = NULL;
-
-   /* Initialize buffer levels */
-   card->sbnr.min = MIN_SB;
-   card->sbnr.init = NUM_SB;
-   card->sbnr.max = MAX_SB;
-   card->lbnr.min = MIN_LB;
-   card->lbnr.init = NUM_LB;
-   card->lbnr.max = MAX_LB;
-   card->iovnr.min = MIN_IOVB;
-   card->iovnr.init = NUM_IOVB;
-   card->iovnr.max = MAX_IOVB;
-   card->hbnr.min = MIN_HB;
-   card->hbnr.init = NUM_HB;
-   card->hbnr.max = MAX_HB;
-   
-   card->sm_handle = 0x00000000;
-   card->sm_addr = 0x00000000;
-   card->lg_handle = 0x00000000;
-   card->lg_addr = 0x00000000;
-   
-   card->efbie = 1;	/* To prevent push_rxbufs from enabling the interrupt */
-
-   /* Pre-allocate some huge buffers */
-   skb_queue_head_init(&card->hbpool.queue);
-   card->hbpool.count = 0;
-   for (j = 0; j < NUM_HB; j++)
-   {
-      struct sk_buff *hb;
-      hb = __dev_alloc_skb(NS_HBUFSIZE, GFP_KERNEL);
-      if (hb == NULL)
-      {
-         printk("nicstar%d: can't allocate %dth of %d huge buffers.\n",
-                i, j, NUM_HB);
-         error = 13;
-         ns_init_card_error(card, error);
-	 return error;
-      }
-      NS_SKB_CB(hb)->buf_type = BUF_NONE;
-      skb_queue_tail(&card->hbpool.queue, hb);
-      card->hbpool.count++;
-   }
-
-
-   /* Allocate large buffers */
-   skb_queue_head_init(&card->lbpool.queue);
-   card->lbpool.count = 0;			/* Not used */
-   for (j = 0; j < NUM_LB; j++)
-   {
-      struct sk_buff *lb;
-      lb = __dev_alloc_skb(NS_LGSKBSIZE, GFP_KERNEL);
-      if (lb == NULL)
-      {
-         printk("nicstar%d: can't allocate %dth of %d large buffers.\n",
-                i, j, NUM_LB);
-         error = 14;
-         ns_init_card_error(card, error);
-	 return error;
-      }
-      NS_SKB_CB(lb)->buf_type = BUF_LG;
-      skb_queue_tail(&card->lbpool.queue, lb);
-      skb_reserve(lb, NS_SMBUFSIZE);
-      push_rxbufs(card, lb);
-      /* Due to the implementation of push_rxbufs() this is 1, not 0 */
-      if (j == 1)
-      {
-         card->rcbuf = lb;
-         card->rawch = (u32) virt_to_bus(lb->data);
-      }
-   }
-   /* Test for strange behaviour which leads to crashes */
-   if ((bcount = ns_stat_lfbqc_get(readl(card->membase + STAT))) < card->lbnr.min)
-   {
-      printk("nicstar%d: Strange... Just allocated %d large buffers and lfbqc = %d.\n",
-             i, j, bcount);
-      error = 14;
-      ns_init_card_error(card, error);
-      return error;
-   }
-      
-
-   /* Allocate small buffers */
-   skb_queue_head_init(&card->sbpool.queue);
-   card->sbpool.count = 0;			/* Not used */
-   for (j = 0; j < NUM_SB; j++)
-   {
-      struct sk_buff *sb;
-      sb = __dev_alloc_skb(NS_SMSKBSIZE, GFP_KERNEL);
-      if (sb == NULL)
-      {
-         printk("nicstar%d: can't allocate %dth of %d small buffers.\n",
-                i, j, NUM_SB);
-         error = 15;
-         ns_init_card_error(card, error);
-	 return error;
-      }
-      NS_SKB_CB(sb)->buf_type = BUF_SM;
-      skb_queue_tail(&card->sbpool.queue, sb);
-      skb_reserve(sb, NS_AAL0_HEADER);
-      push_rxbufs(card, sb);
-   }
-   /* Test for strange behaviour which leads to crashes */
-   if ((bcount = ns_stat_sfbqc_get(readl(card->membase + STAT))) < card->sbnr.min)
-   {
-      printk("nicstar%d: Strange... Just allocated %d small buffers and sfbqc = %d.\n",
-             i, j, bcount);
-      error = 15;
-      ns_init_card_error(card, error);
-      return error;
-   }
-      
-
-   /* Allocate iovec buffers */
-   skb_queue_head_init(&card->iovpool.queue);
-   card->iovpool.count = 0;
-   for (j = 0; j < NUM_IOVB; j++)
-   {
-      struct sk_buff *iovb;
-      iovb = alloc_skb(NS_IOVBUFSIZE, GFP_KERNEL);
-      if (iovb == NULL)
-      {
-         printk("nicstar%d: can't allocate %dth of %d iovec buffers.\n",
-                i, j, NUM_IOVB);
-         error = 16;
-         ns_init_card_error(card, error);
-	 return error;
-      }
-      NS_SKB_CB(iovb)->buf_type = BUF_NONE;
-      skb_queue_tail(&card->iovpool.queue, iovb);
-      card->iovpool.count++;
-   }
-
-   /* Configure NICStAR */
-   if (card->rct_size == 4096)
-      ns_cfg_rctsize = NS_CFG_RCTSIZE_4096_ENTRIES;
-   else /* (card->rct_size == 16384) */
-      ns_cfg_rctsize = NS_CFG_RCTSIZE_16384_ENTRIES;
-
-   card->efbie = 1;
-
-   card->intcnt = 0;
-   if (request_irq(pcidev->irq, &ns_irq_handler, IRQF_DISABLED | IRQF_SHARED, "nicstar", card) != 0)
-   {
-      printk("nicstar%d: can't allocate IRQ %d.\n", i, pcidev->irq);
-      error = 9;
-      ns_init_card_error(card, error);
-      return error;
-   }
-
-   /* Register device */
-   card->atmdev = atm_dev_register("nicstar", &atm_ops, -1, NULL);
-   if (card->atmdev == NULL)
-   {
-      printk("nicstar%d: can't register device.\n", i);
-      error = 17;
-      ns_init_card_error(card, error);
-      return error;
-   }
-      
-   if (ns_parse_mac(mac[i], card->atmdev->esi)) {
-      nicstar_read_eprom(card->membase, NICSTAR_EPROM_MAC_ADDR_OFFSET,
-                         card->atmdev->esi, 6);
-      if (memcmp(card->atmdev->esi, "\x00\x00\x00\x00\x00\x00", 6) == 0) {
-         nicstar_read_eprom(card->membase, NICSTAR_EPROM_MAC_ADDR_OFFSET_ALT,
-                         card->atmdev->esi, 6);
-      }
-   }
-
-   printk("nicstar%d: MAC address %pM\n", i, card->atmdev->esi);
-
-   card->atmdev->dev_data = card;
-   card->atmdev->ci_range.vpi_bits = card->vpibits;
-   card->atmdev->ci_range.vci_bits = card->vcibits;
-   card->atmdev->link_rate = card->max_pcr;
-   card->atmdev->phy = NULL;
+	u32d[1] = 0x00000000;
+	u32d[2] = 0x00000000;
+	u32d[3] = 0xFFFFFFFF;
+	for (j = 0; j < card->rct_size; j++)
+		ns_write_sram(card, j * 4, u32d, 4);
+
+	memset(card->vcmap, 0, NS_MAX_RCTSIZE * sizeof(vc_map));
+
+	for (j = 0; j < NS_FRSCD_NUM; j++)
+		card->scd2vc[j] = NULL;
+
+	/* Initialize buffer levels */
+	card->sbnr.min = MIN_SB;
+	card->sbnr.init = NUM_SB;
+	card->sbnr.max = MAX_SB;
+	card->lbnr.min = MIN_LB;
+	card->lbnr.init = NUM_LB;
+	card->lbnr.max = MAX_LB;
+	card->iovnr.min = MIN_IOVB;
+	card->iovnr.init = NUM_IOVB;
+	card->iovnr.max = MAX_IOVB;
+	card->hbnr.min = MIN_HB;
+	card->hbnr.init = NUM_HB;
+	card->hbnr.max = MAX_HB;
+
+	card->sm_handle = 0x00000000;
+	card->sm_addr = 0x00000000;
+	card->lg_handle = 0x00000000;
+	card->lg_addr = 0x00000000;
+
+	card->efbie = 1;	/* To prevent push_rxbufs from enabling the interrupt */
+
+	/* Pre-allocate some huge buffers */
+	skb_queue_head_init(&card->hbpool.queue);
+	card->hbpool.count = 0;
+	for (j = 0; j < NUM_HB; j++) {
+		struct sk_buff *hb;
+		hb = __dev_alloc_skb(NS_HBUFSIZE, GFP_KERNEL);
+		if (hb == NULL) {
+			printk
+			    ("nicstar%d: can't allocate %dth of %d huge buffers.\n",
+			     i, j, NUM_HB);
+			error = 13;
+			ns_init_card_error(card, error);
+			return error;
+		}
+		NS_SKB_CB(hb)->buf_type = BUF_NONE;
+		skb_queue_tail(&card->hbpool.queue, hb);
+		card->hbpool.count++;
+	}
+
+	/* Allocate large buffers */
+	skb_queue_head_init(&card->lbpool.queue);
+	card->lbpool.count = 0;	/* Not used */
+	for (j = 0; j < NUM_LB; j++) {
+		struct sk_buff *lb;
+		lb = __dev_alloc_skb(NS_LGSKBSIZE, GFP_KERNEL);
+		if (lb == NULL) {
+			printk
+			    ("nicstar%d: can't allocate %dth of %d large buffers.\n",
+			     i, j, NUM_LB);
+			error = 14;
+			ns_init_card_error(card, error);
+			return error;
+		}
+		NS_SKB_CB(lb)->buf_type = BUF_LG;
+		skb_queue_tail(&card->lbpool.queue, lb);
+		skb_reserve(lb, NS_SMBUFSIZE);
+		push_rxbufs(card, lb);
+		/* Due to the implementation of push_rxbufs() this is 1, not 0 */
+		if (j == 1) {
+			card->rcbuf = lb;
+			card->rawch = (u32) virt_to_bus(lb->data);
+		}
+	}
+	/* Test for strange behaviour which leads to crashes */
+	if ((bcount =
+	     ns_stat_lfbqc_get(readl(card->membase + STAT))) < card->lbnr.min) {
+		printk
+		    ("nicstar%d: Strange... Just allocated %d large buffers and lfbqc = %d.\n",
+		     i, j, bcount);
+		error = 14;
+		ns_init_card_error(card, error);
+		return error;
+	}
+
+	/* Allocate small buffers */
+	skb_queue_head_init(&card->sbpool.queue);
+	card->sbpool.count = 0;	/* Not used */
+	for (j = 0; j < NUM_SB; j++) {
+		struct sk_buff *sb;
+		sb = __dev_alloc_skb(NS_SMSKBSIZE, GFP_KERNEL);
+		if (sb == NULL) {
+			printk
+			    ("nicstar%d: can't allocate %dth of %d small buffers.\n",
+			     i, j, NUM_SB);
+			error = 15;
+			ns_init_card_error(card, error);
+			return error;
+		}
+		NS_SKB_CB(sb)->buf_type = BUF_SM;
+		skb_queue_tail(&card->sbpool.queue, sb);
+		skb_reserve(sb, NS_AAL0_HEADER);
+		push_rxbufs(card, sb);
+	}
+	/* Test for strange behaviour which leads to crashes */
+	if ((bcount =
+	     ns_stat_sfbqc_get(readl(card->membase + STAT))) < card->sbnr.min) {
+		printk
+		    ("nicstar%d: Strange... Just allocated %d small buffers and sfbqc = %d.\n",
+		     i, j, bcount);
+		error = 15;
+		ns_init_card_error(card, error);
+		return error;
+	}
+
+	/* Allocate iovec buffers */
+	skb_queue_head_init(&card->iovpool.queue);
+	card->iovpool.count = 0;
+	for (j = 0; j < NUM_IOVB; j++) {
+		struct sk_buff *iovb;
+		iovb = alloc_skb(NS_IOVBUFSIZE, GFP_KERNEL);
+		if (iovb == NULL) {
+			printk
+			    ("nicstar%d: can't allocate %dth of %d iovec buffers.\n",
+			     i, j, NUM_IOVB);
+			error = 16;
+			ns_init_card_error(card, error);
+			return error;
+		}
+		NS_SKB_CB(iovb)->buf_type = BUF_NONE;
+		skb_queue_tail(&card->iovpool.queue, iovb);
+		card->iovpool.count++;
+	}
+
+	/* Configure NICStAR */
+	if (card->rct_size == 4096)
+		ns_cfg_rctsize = NS_CFG_RCTSIZE_4096_ENTRIES;
+	else			/* (card->rct_size == 16384) */
+		ns_cfg_rctsize = NS_CFG_RCTSIZE_16384_ENTRIES;
+
+	card->efbie = 1;
+
+	card->intcnt = 0;
+	if (request_irq
+	    (pcidev->irq, &ns_irq_handler, IRQF_DISABLED | IRQF_SHARED,
+	     "nicstar", card) != 0) {
+		printk("nicstar%d: can't allocate IRQ %d.\n", i, pcidev->irq);
+		error = 9;
+		ns_init_card_error(card, error);
+		return error;
+	}
+
+	/* Register device */
+	card->atmdev = atm_dev_register("nicstar", &atm_ops, -1, NULL);
+	if (card->atmdev == NULL) {
+		printk("nicstar%d: can't register device.\n", i);
+		error = 17;
+		ns_init_card_error(card, error);
+		return error;
+	}
+
+	if (ns_parse_mac(mac[i], card->atmdev->esi)) {
+		nicstar_read_eprom(card->membase, NICSTAR_EPROM_MAC_ADDR_OFFSET,
+				   card->atmdev->esi, 6);
+		if (memcmp(card->atmdev->esi, "\x00\x00\x00\x00\x00\x00", 6) ==
+		    0) {
+			nicstar_read_eprom(card->membase,
+					   NICSTAR_EPROM_MAC_ADDR_OFFSET_ALT,
+					   card->atmdev->esi, 6);
+		}
+	}
+
+	printk("nicstar%d: MAC address %pM\n", i, card->atmdev->esi);
+
+	card->atmdev->dev_data = card;
+	card->atmdev->ci_range.vpi_bits = card->vpibits;
+	card->atmdev->ci_range.vci_bits = card->vcibits;
+	card->atmdev->link_rate = card->max_pcr;
+	card->atmdev->phy = NULL;
 
 #ifdef CONFIG_ATM_NICSTAR_USE_SUNI
-   if (card->max_pcr == ATM_OC3_PCR)
-      suni_init(card->atmdev);
+	if (card->max_pcr == ATM_OC3_PCR)
+		suni_init(card->atmdev);
 #endif /* CONFIG_ATM_NICSTAR_USE_SUNI */
 
 #ifdef CONFIG_ATM_NICSTAR_USE_IDT77105
-   if (card->max_pcr == ATM_25_PCR)
-      idt77105_init(card->atmdev);
+	if (card->max_pcr == ATM_25_PCR)
+		idt77105_init(card->atmdev);
 #endif /* CONFIG_ATM_NICSTAR_USE_IDT77105 */
 
-   if (card->atmdev->phy && card->atmdev->phy->start)
-      card->atmdev->phy->start(card->atmdev);
-
-   writel(NS_CFG_RXPATH |
-          NS_CFG_SMBUFSIZE |
-          NS_CFG_LGBUFSIZE |
-          NS_CFG_EFBIE |
-          NS_CFG_RSQSIZE |
-          NS_CFG_VPIBITS |
-          ns_cfg_rctsize |
-          NS_CFG_RXINT_NODELAY |
-          NS_CFG_RAWIE |		/* Only enabled if RCQ_SUPPORT */
-          NS_CFG_RSQAFIE |
-          NS_CFG_TXEN |
-          NS_CFG_TXIE |
-          NS_CFG_TSQFIE_OPT |		/* Only enabled if ENABLE_TSQFIE */ 
-          NS_CFG_PHYIE,
-          card->membase + CFG);
-
-   num_cards++;
-
-   return error;
-}
+	if (card->atmdev->phy && card->atmdev->phy->start)
+		card->atmdev->phy->start(card->atmdev);
 
+	writel(NS_CFG_RXPATH | NS_CFG_SMBUFSIZE | NS_CFG_LGBUFSIZE | NS_CFG_EFBIE | NS_CFG_RSQSIZE | NS_CFG_VPIBITS | ns_cfg_rctsize | NS_CFG_RXINT_NODELAY | NS_CFG_RAWIE |	/* Only enabled if RCQ_SUPPORT */
+	       NS_CFG_RSQAFIE | NS_CFG_TXEN | NS_CFG_TXIE | NS_CFG_TSQFIE_OPT |	/* Only enabled if ENABLE_TSQFIE */
+	       NS_CFG_PHYIE, card->membase + CFG);
 
+	num_cards++;
 
-static void __devinit ns_init_card_error(ns_dev *card, int error)
-{
-   if (error >= 17)
-   {
-      writel(0x00000000, card->membase + CFG);
-   }
-   if (error >= 16)
-   {
-      struct sk_buff *iovb;
-      while ((iovb = skb_dequeue(&card->iovpool.queue)) != NULL)
-         dev_kfree_skb_any(iovb);
-   }
-   if (error >= 15)
-   {
-      struct sk_buff *sb;
-      while ((sb = skb_dequeue(&card->sbpool.queue)) != NULL)
-         dev_kfree_skb_any(sb);
-      free_scq(card->scq0, NULL);
-   }
-   if (error >= 14)
-   {
-      struct sk_buff *lb;
-      while ((lb = skb_dequeue(&card->lbpool.queue)) != NULL)
-         dev_kfree_skb_any(lb);
-   }
-   if (error >= 13)
-   {
-      struct sk_buff *hb;
-      while ((hb = skb_dequeue(&card->hbpool.queue)) != NULL)
-         dev_kfree_skb_any(hb);
-   }
-   if (error >= 12)
-   {
-      kfree(card->rsq.org);
-   }
-   if (error >= 11)
-   {
-      kfree(card->tsq.org);
-   }
-   if (error >= 10)
-   {
-      free_irq(card->pcidev->irq, card);
-   }
-   if (error >= 4)
-   {
-      iounmap(card->membase);
-   }
-   if (error >= 3)
-   {
-      pci_disable_device(card->pcidev);
-      kfree(card);
-   }
+	return error;
 }
 
-
+static void __devinit ns_init_card_error(ns_dev * card, int error)
+{
+	if (error >= 17) {
+		writel(0x00000000, card->membase + CFG);
+	}
+	if (error >= 16) {
+		struct sk_buff *iovb;
+		while ((iovb = skb_dequeue(&card->iovpool.queue)) != NULL)
+			dev_kfree_skb_any(iovb);
+	}
+	if (error >= 15) {
+		struct sk_buff *sb;
+		while ((sb = skb_dequeue(&card->sbpool.queue)) != NULL)
+			dev_kfree_skb_any(sb);
+		free_scq(card->scq0, NULL);
+	}
+	if (error >= 14) {
+		struct sk_buff *lb;
+		while ((lb = skb_dequeue(&card->lbpool.queue)) != NULL)
+			dev_kfree_skb_any(lb);
+	}
+	if (error >= 13) {
+		struct sk_buff *hb;
+		while ((hb = skb_dequeue(&card->hbpool.queue)) != NULL)
+			dev_kfree_skb_any(hb);
+	}
+	if (error >= 12) {
+		kfree(card->rsq.org);
+	}
+	if (error >= 11) {
+		kfree(card->tsq.org);
+	}
+	if (error >= 10) {
+		free_irq(card->pcidev->irq, card);
+	}
+	if (error >= 4) {
+		iounmap(card->membase);
+	}
+	if (error >= 3) {
+		pci_disable_device(card->pcidev);
+		kfree(card);
+	}
+}
 
 static scq_info *get_scq(int size, u32 scd)
 {
-   scq_info *scq;
-   int i;
-
-   if (size != VBR_SCQSIZE && size != CBR_SCQSIZE)
-      return NULL;
-
-   scq = kmalloc(sizeof(scq_info), GFP_KERNEL);
-   if (scq == NULL)
-      return NULL;
-   scq->org = kmalloc(2 * size, GFP_KERNEL);
-   if (scq->org == NULL)
-   {
-      kfree(scq);
-      return NULL;
-   }
-   scq->skb = kmalloc(sizeof(struct sk_buff *) *
-                                          (size / NS_SCQE_SIZE), GFP_KERNEL);
-   if (scq->skb == NULL)
-   {
-      kfree(scq->org);
-      kfree(scq);
-      return NULL;
-   }
-   scq->num_entries = size / NS_SCQE_SIZE;
-   scq->base = (ns_scqe *) ALIGN_ADDRESS(scq->org, size);
-   scq->next = scq->base;
-   scq->last = scq->base + (scq->num_entries - 1);
-   scq->tail = scq->last;
-   scq->scd = scd;
-   scq->num_entries = size / NS_SCQE_SIZE;
-   scq->tbd_count = 0;
-   init_waitqueue_head(&scq->scqfull_waitq);
-   scq->full = 0;
-   spin_lock_init(&scq->lock);
-
-   for (i = 0; i < scq->num_entries; i++)
-      scq->skb[i] = NULL;
-
-   return scq;
+	scq_info *scq;
+	int i;
+
+	if (size != VBR_SCQSIZE && size != CBR_SCQSIZE)
+		return NULL;
+
+	scq = kmalloc(sizeof(scq_info), GFP_KERNEL);
+	if (scq == NULL)
+		return NULL;
+	scq->org = kmalloc(2 * size, GFP_KERNEL);
+	if (scq->org == NULL) {
+		kfree(scq);
+		return NULL;
+	}
+	scq->skb = kmalloc(sizeof(struct sk_buff *) *
+			   (size / NS_SCQE_SIZE), GFP_KERNEL);
+	if (scq->skb == NULL) {
+		kfree(scq->org);
+		kfree(scq);
+		return NULL;
+	}
+	scq->num_entries = size / NS_SCQE_SIZE;
+	scq->base = (ns_scqe *) ALIGN_ADDRESS(scq->org, size);
+	scq->next = scq->base;
+	scq->last = scq->base + (scq->num_entries - 1);
+	scq->tail = scq->last;
+	scq->scd = scd;
+	scq->num_entries = size / NS_SCQE_SIZE;
+	scq->tbd_count = 0;
+	init_waitqueue_head(&scq->scqfull_waitq);
+	scq->full = 0;
+	spin_lock_init(&scq->lock);
+
+	for (i = 0; i < scq->num_entries; i++)
+		scq->skb[i] = NULL;
+
+	return scq;
 }
 
-
-
 /* For variable rate SCQ vcc must be NULL */
-static void free_scq(scq_info *scq, struct atm_vcc *vcc)
+static void free_scq(scq_info * scq, struct atm_vcc *vcc)
 {
-   int i;
-
-   if (scq->num_entries == VBR_SCQ_NUM_ENTRIES)
-      for (i = 0; i < scq->num_entries; i++)
-      {
-         if (scq->skb[i] != NULL)
-	 {
-            vcc = ATM_SKB(scq->skb[i])->vcc;
-            if (vcc->pop != NULL)
-	       vcc->pop(vcc, scq->skb[i]);
-	    else
-               dev_kfree_skb_any(scq->skb[i]);
-         }
-      }
-   else /* vcc must be != NULL */
-   {
-      if (vcc == NULL)
-      {
-         printk("nicstar: free_scq() called with vcc == NULL for fixed rate scq.");
-         for (i = 0; i < scq->num_entries; i++)
-            dev_kfree_skb_any(scq->skb[i]);
-      }
-      else
-         for (i = 0; i < scq->num_entries; i++)
-         {
-            if (scq->skb[i] != NULL)
-            {
-               if (vcc->pop != NULL)
-                  vcc->pop(vcc, scq->skb[i]);
-               else
-                  dev_kfree_skb_any(scq->skb[i]);
-            }
-         }
-   }
-   kfree(scq->skb);
-   kfree(scq->org);
-   kfree(scq);
+	int i;
+
+	if (scq->num_entries == VBR_SCQ_NUM_ENTRIES)
+		for (i = 0; i < scq->num_entries; i++) {
+			if (scq->skb[i] != NULL) {
+				vcc = ATM_SKB(scq->skb[i])->vcc;
+				if (vcc->pop != NULL)
+					vcc->pop(vcc, scq->skb[i]);
+				else
+					dev_kfree_skb_any(scq->skb[i]);
+			}
+	} else {		/* vcc must be != NULL */
+
+		if (vcc == NULL) {
+			printk
+			    ("nicstar: free_scq() called with vcc == NULL for fixed rate scq.");
+			for (i = 0; i < scq->num_entries; i++)
+				dev_kfree_skb_any(scq->skb[i]);
+		} else
+			for (i = 0; i < scq->num_entries; i++) {
+				if (scq->skb[i] != NULL) {
+					if (vcc->pop != NULL)
+						vcc->pop(vcc, scq->skb[i]);
+					else
+						dev_kfree_skb_any(scq->skb[i]);
+				}
+			}
+	}
+	kfree(scq->skb);
+	kfree(scq->org);
+	kfree(scq);
 }
 
-
-
 /* The handles passed must be pointers to the sk_buff containing the small
    or large buffer(s) cast to u32. */
-static void push_rxbufs(ns_dev *card, struct sk_buff *skb)
+static void push_rxbufs(ns_dev * card, struct sk_buff *skb)
 {
-   struct ns_skb_cb *cb = NS_SKB_CB(skb);
-   u32 handle1, addr1;
-   u32 handle2, addr2;
-   u32 stat;
-   unsigned long flags;
-   
-   /* *BARF* */
-   handle2 = addr2 = 0;
-   handle1 = (u32)skb;
-   addr1 = (u32)virt_to_bus(skb->data);
+	struct ns_skb_cb *cb = NS_SKB_CB(skb);
+	u32 handle1, addr1;
+	u32 handle2, addr2;
+	u32 stat;
+	unsigned long flags;
+
+	/* *BARF* */
+	handle2 = addr2 = 0;
+	handle1 = (u32) skb;
+	addr1 = (u32) virt_to_bus(skb->data);
 
 #ifdef GENERAL_DEBUG
-   if (!addr1)
-      printk("nicstar%d: push_rxbufs called with addr1 = 0.\n", card->index);
+	if (!addr1)
+		printk("nicstar%d: push_rxbufs called with addr1 = 0.\n",
+		       card->index);
 #endif /* GENERAL_DEBUG */
 
-   stat = readl(card->membase + STAT);
-   card->sbfqc = ns_stat_sfbqc_get(stat);
-   card->lbfqc = ns_stat_lfbqc_get(stat);
-   if (cb->buf_type == BUF_SM)
-   {
-      if (!addr2)
-      {
-         if (card->sm_addr)
-	 {
-	    addr2 = card->sm_addr;
-	    handle2 = card->sm_handle;
-	    card->sm_addr = 0x00000000;
-	    card->sm_handle = 0x00000000;
-	 }
-	 else /* (!sm_addr) */
-	 {
-	    card->sm_addr = addr1;
-	    card->sm_handle = handle1;
-	 }
-      }      
-   }
-   else /* buf_type == BUF_LG */
-   {
-      if (!addr2)
-      {
-         if (card->lg_addr)
-	 {
-	    addr2 = card->lg_addr;
-	    handle2 = card->lg_handle;
-	    card->lg_addr = 0x00000000;
-	    card->lg_handle = 0x00000000;
-	 }
-	 else /* (!lg_addr) */
-	 {
-	    card->lg_addr = addr1;
-	    card->lg_handle = handle1;
-	 }
-      }      
-   }
-
-   if (addr2)
-   {
-      if (cb->buf_type == BUF_SM)
-      {
-         if (card->sbfqc >= card->sbnr.max)
-         {
-            skb_unlink((struct sk_buff *) handle1, &card->sbpool.queue);
-            dev_kfree_skb_any((struct sk_buff *) handle1);
-            skb_unlink((struct sk_buff *) handle2, &card->sbpool.queue);
-            dev_kfree_skb_any((struct sk_buff *) handle2);
-            return;
-         }
-	 else
-            card->sbfqc += 2;
-      }
-      else /* (buf_type == BUF_LG) */
-      {
-         if (card->lbfqc >= card->lbnr.max)
-         {
-            skb_unlink((struct sk_buff *) handle1, &card->lbpool.queue);
-            dev_kfree_skb_any((struct sk_buff *) handle1);
-            skb_unlink((struct sk_buff *) handle2, &card->lbpool.queue);
-            dev_kfree_skb_any((struct sk_buff *) handle2);
-            return;
-         }
-         else
-            card->lbfqc += 2;
-      }
-
-      spin_lock_irqsave(&card->res_lock, flags);
-
-      while (CMD_BUSY(card));
-      writel(addr2, card->membase + DR3);
-      writel(handle2, card->membase + DR2);
-      writel(addr1, card->membase + DR1);
-      writel(handle1, card->membase + DR0);
-      writel(NS_CMD_WRITE_FREEBUFQ | cb->buf_type, card->membase + CMD);
- 
-      spin_unlock_irqrestore(&card->res_lock, flags);
-
-      XPRINTK("nicstar%d: Pushing %s buffers at 0x%x and 0x%x.\n", card->index,
-              (cb->buf_type == BUF_SM ? "small" : "large"), addr1, addr2);
-   }
-
-   if (!card->efbie && card->sbfqc >= card->sbnr.min &&
-       card->lbfqc >= card->lbnr.min)
-   {
-      card->efbie = 1;
-      writel((readl(card->membase + CFG) | NS_CFG_EFBIE), card->membase + CFG);
-   }
-
-   return;
+	stat = readl(card->membase + STAT);
+	card->sbfqc = ns_stat_sfbqc_get(stat);
+	card->lbfqc = ns_stat_lfbqc_get(stat);
+	if (cb->buf_type == BUF_SM) {
+		if (!addr2) {
+			if (card->sm_addr) {
+				addr2 = card->sm_addr;
+				handle2 = card->sm_handle;
+				card->sm_addr = 0x00000000;
+				card->sm_handle = 0x00000000;
+			} else {	/* (!sm_addr) */
+
+				card->sm_addr = addr1;
+				card->sm_handle = handle1;
+			}
+		}
+	} else {		/* buf_type == BUF_LG */
+
+		if (!addr2) {
+			if (card->lg_addr) {
+				addr2 = card->lg_addr;
+				handle2 = card->lg_handle;
+				card->lg_addr = 0x00000000;
+				card->lg_handle = 0x00000000;
+			} else {	/* (!lg_addr) */
+
+				card->lg_addr = addr1;
+				card->lg_handle = handle1;
+			}
+		}
+	}
+
+	if (addr2) {
+		if (cb->buf_type == BUF_SM) {
+			if (card->sbfqc >= card->sbnr.max) {
+				skb_unlink((struct sk_buff *)handle1,
+					   &card->sbpool.queue);
+				dev_kfree_skb_any((struct sk_buff *)handle1);
+				skb_unlink((struct sk_buff *)handle2,
+					   &card->sbpool.queue);
+				dev_kfree_skb_any((struct sk_buff *)handle2);
+				return;
+			} else
+				card->sbfqc += 2;
+		} else {	/* (buf_type == BUF_LG) */
+
+			if (card->lbfqc >= card->lbnr.max) {
+				skb_unlink((struct sk_buff *)handle1,
+					   &card->lbpool.queue);
+				dev_kfree_skb_any((struct sk_buff *)handle1);
+				skb_unlink((struct sk_buff *)handle2,
+					   &card->lbpool.queue);
+				dev_kfree_skb_any((struct sk_buff *)handle2);
+				return;
+			} else
+				card->lbfqc += 2;
+		}
+
+		spin_lock_irqsave(&card->res_lock, flags);
+
+		while (CMD_BUSY(card)) ;
+		writel(addr2, card->membase + DR3);
+		writel(handle2, card->membase + DR2);
+		writel(addr1, card->membase + DR1);
+		writel(handle1, card->membase + DR0);
+		writel(NS_CMD_WRITE_FREEBUFQ | cb->buf_type,
+		       card->membase + CMD);
+
+		spin_unlock_irqrestore(&card->res_lock, flags);
+
+		XPRINTK("nicstar%d: Pushing %s buffers at 0x%x and 0x%x.\n",
+			card->index,
+			(cb->buf_type == BUF_SM ? "small" : "large"), addr1,
+			addr2);
+	}
+
+	if (!card->efbie && card->sbfqc >= card->sbnr.min &&
+	    card->lbfqc >= card->lbnr.min) {
+		card->efbie = 1;
+		writel((readl(card->membase + CFG) | NS_CFG_EFBIE),
+		       card->membase + CFG);
+	}
+
+	return;
 }
 
-
-
 static irqreturn_t ns_irq_handler(int irq, void *dev_id)
 {
-   u32 stat_r;
-   ns_dev *card;
-   struct atm_dev *dev;
-   unsigned long flags;
-
-   card = (ns_dev *) dev_id;
-   dev = card->atmdev;
-   card->intcnt++;
-
-   PRINTK("nicstar%d: NICStAR generated an interrupt\n", card->index);
-
-   spin_lock_irqsave(&card->int_lock, flags);
-   
-   stat_r = readl(card->membase + STAT);
-
-   /* Transmit Status Indicator has been written to T. S. Queue */
-   if (stat_r & NS_STAT_TSIF)
-   {
-      TXPRINTK("nicstar%d: TSI interrupt\n", card->index);
-      process_tsq(card);
-      writel(NS_STAT_TSIF, card->membase + STAT);
-   }
-   
-   /* Incomplete CS-PDU has been transmitted */
-   if (stat_r & NS_STAT_TXICP)
-   {
-      writel(NS_STAT_TXICP, card->membase + STAT);
-      TXPRINTK("nicstar%d: Incomplete CS-PDU transmitted.\n",
-               card->index);
-   }
-   
-   /* Transmit Status Queue 7/8 full */
-   if (stat_r & NS_STAT_TSQF)
-   {
-      writel(NS_STAT_TSQF, card->membase + STAT);
-      PRINTK("nicstar%d: TSQ full.\n", card->index);
-      process_tsq(card);
-   }
-   
-   /* Timer overflow */
-   if (stat_r & NS_STAT_TMROF)
-   {
-      writel(NS_STAT_TMROF, card->membase + STAT);
-      PRINTK("nicstar%d: Timer overflow.\n", card->index);
-   }
-   
-   /* PHY device interrupt signal active */
-   if (stat_r & NS_STAT_PHYI)
-   {
-      writel(NS_STAT_PHYI, card->membase + STAT);
-      PRINTK("nicstar%d: PHY interrupt.\n", card->index);
-      if (dev->phy && dev->phy->interrupt) {
-         dev->phy->interrupt(dev);
-      }
-   }
-
-   /* Small Buffer Queue is full */
-   if (stat_r & NS_STAT_SFBQF)
-   {
-      writel(NS_STAT_SFBQF, card->membase + STAT);
-      printk("nicstar%d: Small free buffer queue is full.\n", card->index);
-   }
-   
-   /* Large Buffer Queue is full */
-   if (stat_r & NS_STAT_LFBQF)
-   {
-      writel(NS_STAT_LFBQF, card->membase + STAT);
-      printk("nicstar%d: Large free buffer queue is full.\n", card->index);
-   }
-
-   /* Receive Status Queue is full */
-   if (stat_r & NS_STAT_RSQF)
-   {
-      writel(NS_STAT_RSQF, card->membase + STAT);
-      printk("nicstar%d: RSQ full.\n", card->index);
-      process_rsq(card);
-   }
-
-   /* Complete CS-PDU received */
-   if (stat_r & NS_STAT_EOPDU)
-   {
-      RXPRINTK("nicstar%d: End of CS-PDU received.\n", card->index);
-      process_rsq(card);
-      writel(NS_STAT_EOPDU, card->membase + STAT);
-   }
-
-   /* Raw cell received */
-   if (stat_r & NS_STAT_RAWCF)
-   {
-      writel(NS_STAT_RAWCF, card->membase + STAT);
+	u32 stat_r;
+	ns_dev *card;
+	struct atm_dev *dev;
+	unsigned long flags;
+
+	card = (ns_dev *) dev_id;
+	dev = card->atmdev;
+	card->intcnt++;
+
+	PRINTK("nicstar%d: NICStAR generated an interrupt\n", card->index);
+
+	spin_lock_irqsave(&card->int_lock, flags);
+
+	stat_r = readl(card->membase + STAT);
+
+	/* Transmit Status Indicator has been written to T. S. Queue */
+	if (stat_r & NS_STAT_TSIF) {
+		TXPRINTK("nicstar%d: TSI interrupt\n", card->index);
+		process_tsq(card);
+		writel(NS_STAT_TSIF, card->membase + STAT);
+	}
+
+	/* Incomplete CS-PDU has been transmitted */
+	if (stat_r & NS_STAT_TXICP) {
+		writel(NS_STAT_TXICP, card->membase + STAT);
+		TXPRINTK("nicstar%d: Incomplete CS-PDU transmitted.\n",
+			 card->index);
+	}
+
+	/* Transmit Status Queue 7/8 full */
+	if (stat_r & NS_STAT_TSQF) {
+		writel(NS_STAT_TSQF, card->membase + STAT);
+		PRINTK("nicstar%d: TSQ full.\n", card->index);
+		process_tsq(card);
+	}
+
+	/* Timer overflow */
+	if (stat_r & NS_STAT_TMROF) {
+		writel(NS_STAT_TMROF, card->membase + STAT);
+		PRINTK("nicstar%d: Timer overflow.\n", card->index);
+	}
+
+	/* PHY device interrupt signal active */
+	if (stat_r & NS_STAT_PHYI) {
+		writel(NS_STAT_PHYI, card->membase + STAT);
+		PRINTK("nicstar%d: PHY interrupt.\n", card->index);
+		if (dev->phy && dev->phy->interrupt) {
+			dev->phy->interrupt(dev);
+		}
+	}
+
+	/* Small Buffer Queue is full */
+	if (stat_r & NS_STAT_SFBQF) {
+		writel(NS_STAT_SFBQF, card->membase + STAT);
+		printk("nicstar%d: Small free buffer queue is full.\n",
+		       card->index);
+	}
+
+	/* Large Buffer Queue is full */
+	if (stat_r & NS_STAT_LFBQF) {
+		writel(NS_STAT_LFBQF, card->membase + STAT);
+		printk("nicstar%d: Large free buffer queue is full.\n",
+		       card->index);
+	}
+
+	/* Receive Status Queue is full */
+	if (stat_r & NS_STAT_RSQF) {
+		writel(NS_STAT_RSQF, card->membase + STAT);
+		printk("nicstar%d: RSQ full.\n", card->index);
+		process_rsq(card);
+	}
+
+	/* Complete CS-PDU received */
+	if (stat_r & NS_STAT_EOPDU) {
+		RXPRINTK("nicstar%d: End of CS-PDU received.\n", card->index);
+		process_rsq(card);
+		writel(NS_STAT_EOPDU, card->membase + STAT);
+	}
+
+	/* Raw cell received */
+	if (stat_r & NS_STAT_RAWCF) {
+		writel(NS_STAT_RAWCF, card->membase + STAT);
 #ifndef RCQ_SUPPORT
-      printk("nicstar%d: Raw cell received and no support yet...\n",
-             card->index);
+		printk("nicstar%d: Raw cell received and no support yet...\n",
+		       card->index);
 #endif /* RCQ_SUPPORT */
-      /* NOTE: the following procedure may keep a raw cell pending until the
-               next interrupt. As this preliminary support is only meant to
-               avoid buffer leakage, this is not an issue. */
-      while (readl(card->membase + RAWCT) != card->rawch)
-      {
-         ns_rcqe *rawcell;
-
-         rawcell = (ns_rcqe *) bus_to_virt(card->rawch);
-         if (ns_rcqe_islast(rawcell))
-         {
-            struct sk_buff *oldbuf;
-
-            oldbuf = card->rcbuf;
-            card->rcbuf = (struct sk_buff *) ns_rcqe_nextbufhandle(rawcell);
-            card->rawch = (u32) virt_to_bus(card->rcbuf->data);
-            recycle_rx_buf(card, oldbuf);
-         }
-         else
-            card->rawch += NS_RCQE_SIZE;
-      }
-   }
-
-   /* Small buffer queue is empty */
-   if (stat_r & NS_STAT_SFBQE)
-   {
-      int i;
-      struct sk_buff *sb;
-
-      writel(NS_STAT_SFBQE, card->membase + STAT);
-      printk("nicstar%d: Small free buffer queue empty.\n",
-             card->index);
-      for (i = 0; i < card->sbnr.min; i++)
-      {
-         sb = dev_alloc_skb(NS_SMSKBSIZE);
-         if (sb == NULL)
-         {
-            writel(readl(card->membase + CFG) & ~NS_CFG_EFBIE, card->membase + CFG);
-            card->efbie = 0;
-            break;
-         }
-         NS_SKB_CB(sb)->buf_type = BUF_SM;
-         skb_queue_tail(&card->sbpool.queue, sb);
-         skb_reserve(sb, NS_AAL0_HEADER);
-         push_rxbufs(card, sb);
-      }
-      card->sbfqc = i;
-      process_rsq(card);
-   }
-
-   /* Large buffer queue empty */
-   if (stat_r & NS_STAT_LFBQE)
-   {
-      int i;
-      struct sk_buff *lb;
-
-      writel(NS_STAT_LFBQE, card->membase + STAT);
-      printk("nicstar%d: Large free buffer queue empty.\n",
-             card->index);
-      for (i = 0; i < card->lbnr.min; i++)
-      {
-         lb = dev_alloc_skb(NS_LGSKBSIZE);
-         if (lb == NULL)
-         {
-            writel(readl(card->membase + CFG) & ~NS_CFG_EFBIE, card->membase + CFG);
-            card->efbie = 0;
-            break;
-         }
-         NS_SKB_CB(lb)->buf_type = BUF_LG;
-         skb_queue_tail(&card->lbpool.queue, lb);
-         skb_reserve(lb, NS_SMBUFSIZE);
-         push_rxbufs(card, lb);
-      }
-      card->lbfqc = i;
-      process_rsq(card);
-   }
-
-   /* Receive Status Queue is 7/8 full */
-   if (stat_r & NS_STAT_RSQAF)
-   {
-      writel(NS_STAT_RSQAF, card->membase + STAT);
-      RXPRINTK("nicstar%d: RSQ almost full.\n", card->index);
-      process_rsq(card);
-   }
-   
-   spin_unlock_irqrestore(&card->int_lock, flags);
-   PRINTK("nicstar%d: end of interrupt service\n", card->index);
-   return IRQ_HANDLED;
+		/* NOTE: the following procedure may keep a raw cell pending until the
+		   next interrupt. As this preliminary support is only meant to
+		   avoid buffer leakage, this is not an issue. */
+		while (readl(card->membase + RAWCT) != card->rawch) {
+			ns_rcqe *rawcell;
+
+			rawcell = (ns_rcqe *) bus_to_virt(card->rawch);
+			if (ns_rcqe_islast(rawcell)) {
+				struct sk_buff *oldbuf;
+
+				oldbuf = card->rcbuf;
+				card->rcbuf =
+				    (struct sk_buff *)
+				    ns_rcqe_nextbufhandle(rawcell);
+				card->rawch =
+				    (u32) virt_to_bus(card->rcbuf->data);
+				recycle_rx_buf(card, oldbuf);
+			} else
+				card->rawch += NS_RCQE_SIZE;
+		}
+	}
+
+	/* Small buffer queue is empty */
+	if (stat_r & NS_STAT_SFBQE) {
+		int i;
+		struct sk_buff *sb;
+
+		writel(NS_STAT_SFBQE, card->membase + STAT);
+		printk("nicstar%d: Small free buffer queue empty.\n",
+		       card->index);
+		for (i = 0; i < card->sbnr.min; i++) {
+			sb = dev_alloc_skb(NS_SMSKBSIZE);
+			if (sb == NULL) {
+				writel(readl(card->membase + CFG) &
+				       ~NS_CFG_EFBIE, card->membase + CFG);
+				card->efbie = 0;
+				break;
+			}
+			NS_SKB_CB(sb)->buf_type = BUF_SM;
+			skb_queue_tail(&card->sbpool.queue, sb);
+			skb_reserve(sb, NS_AAL0_HEADER);
+			push_rxbufs(card, sb);
+		}
+		card->sbfqc = i;
+		process_rsq(card);
+	}
+
+	/* Large buffer queue empty */
+	if (stat_r & NS_STAT_LFBQE) {
+		int i;
+		struct sk_buff *lb;
+
+		writel(NS_STAT_LFBQE, card->membase + STAT);
+		printk("nicstar%d: Large free buffer queue empty.\n",
+		       card->index);
+		for (i = 0; i < card->lbnr.min; i++) {
+			lb = dev_alloc_skb(NS_LGSKBSIZE);
+			if (lb == NULL) {
+				writel(readl(card->membase + CFG) &
+				       ~NS_CFG_EFBIE, card->membase + CFG);
+				card->efbie = 0;
+				break;
+			}
+			NS_SKB_CB(lb)->buf_type = BUF_LG;
+			skb_queue_tail(&card->lbpool.queue, lb);
+			skb_reserve(lb, NS_SMBUFSIZE);
+			push_rxbufs(card, lb);
+		}
+		card->lbfqc = i;
+		process_rsq(card);
+	}
+
+	/* Receive Status Queue is 7/8 full */
+	if (stat_r & NS_STAT_RSQAF) {
+		writel(NS_STAT_RSQAF, card->membase + STAT);
+		RXPRINTK("nicstar%d: RSQ almost full.\n", card->index);
+		process_rsq(card);
+	}
+
+	spin_unlock_irqrestore(&card->int_lock, flags);
+	PRINTK("nicstar%d: end of interrupt service\n", card->index);
+	return IRQ_HANDLED;
 }
 
-
-
 static int ns_open(struct atm_vcc *vcc)
 {
-   ns_dev *card;
-   vc_map *vc;
-   unsigned long tmpl, modl;
-   int tcr, tcra;	/* target cell rate, and absolute value */
-   int n = 0;		/* Number of entries in the TST. Initialized to remove
-                           the compiler warning. */
-   u32 u32d[4];
-   int frscdi = 0;	/* Index of the SCD. Initialized to remove the compiler
-                           warning. How I wish compilers were clever enough to
-			   tell which variables can truly be used
-			   uninitialized... */
-   int inuse;		/* tx or rx vc already in use by another vcc */
-   short vpi = vcc->vpi;
-   int vci = vcc->vci;
-
-   card = (ns_dev *) vcc->dev->dev_data;
-   PRINTK("nicstar%d: opening vpi.vci %d.%d \n", card->index, (int) vpi, vci);
-   if (vcc->qos.aal != ATM_AAL5 && vcc->qos.aal != ATM_AAL0)
-   {
-      PRINTK("nicstar%d: unsupported AAL.\n", card->index);
-      return -EINVAL;
-   }
-
-   vc = &(card->vcmap[vpi << card->vcibits | vci]);
-   vcc->dev_data = vc;
-
-   inuse = 0;
-   if (vcc->qos.txtp.traffic_class != ATM_NONE && vc->tx)
-      inuse = 1;
-   if (vcc->qos.rxtp.traffic_class != ATM_NONE && vc->rx)
-      inuse += 2;
-   if (inuse)
-   {
-      printk("nicstar%d: %s vci already in use.\n", card->index,
-             inuse == 1 ? "tx" : inuse == 2 ? "rx" : "tx and rx");
-      return -EINVAL;
-   }
-
-   set_bit(ATM_VF_ADDR,&vcc->flags);
-
-   /* NOTE: You are not allowed to modify an open connection's QOS. To change
-      that, remove the ATM_VF_PARTIAL flag checking. There may be other changes
-      needed to do that. */
-   if (!test_bit(ATM_VF_PARTIAL,&vcc->flags))
-   {
-      scq_info *scq;
-      
-      set_bit(ATM_VF_PARTIAL,&vcc->flags);
-      if (vcc->qos.txtp.traffic_class == ATM_CBR)
-      {
-         /* Check requested cell rate and availability of SCD */
-         if (vcc->qos.txtp.max_pcr == 0 && vcc->qos.txtp.pcr == 0 &&
-             vcc->qos.txtp.min_pcr == 0)
-         {
-            PRINTK("nicstar%d: trying to open a CBR vc with cell rate = 0 \n",
-	           card->index);
-	    clear_bit(ATM_VF_PARTIAL,&vcc->flags);
-	    clear_bit(ATM_VF_ADDR,&vcc->flags);
-            return -EINVAL;
-         }
-
-         tcr = atm_pcr_goal(&(vcc->qos.txtp));
-         tcra = tcr >= 0 ? tcr : -tcr;
-      
-         PRINTK("nicstar%d: target cell rate = %d.\n", card->index,
-                vcc->qos.txtp.max_pcr);
-
-         tmpl = (unsigned long)tcra * (unsigned long)NS_TST_NUM_ENTRIES;
-         modl = tmpl % card->max_pcr;
-
-         n = (int)(tmpl / card->max_pcr);
-         if (tcr > 0)
-         {
-            if (modl > 0) n++;
-         }
-         else if (tcr == 0)
-         {
-            if ((n = (card->tst_free_entries - NS_TST_RESERVED)) <= 0)
-	    {
-               PRINTK("nicstar%d: no CBR bandwidth free.\n", card->index);
-	       clear_bit(ATM_VF_PARTIAL,&vcc->flags);
-	       clear_bit(ATM_VF_ADDR,&vcc->flags);
-               return -EINVAL;
-            }
-         }
-
-         if (n == 0)
-         {
-            printk("nicstar%d: selected bandwidth < granularity.\n", card->index);
-	    clear_bit(ATM_VF_PARTIAL,&vcc->flags);
-	    clear_bit(ATM_VF_ADDR,&vcc->flags);
-            return -EINVAL;
-         }
-
-         if (n > (card->tst_free_entries - NS_TST_RESERVED))
-         {
-            PRINTK("nicstar%d: not enough free CBR bandwidth.\n", card->index);
-	    clear_bit(ATM_VF_PARTIAL,&vcc->flags);
-	    clear_bit(ATM_VF_ADDR,&vcc->flags);
-            return -EINVAL;
-         }
-         else
-            card->tst_free_entries -= n;
-
-         XPRINTK("nicstar%d: writing %d tst entries.\n", card->index, n);
-         for (frscdi = 0; frscdi < NS_FRSCD_NUM; frscdi++)
-         {
-            if (card->scd2vc[frscdi] == NULL)
-            {
-               card->scd2vc[frscdi] = vc;
-               break;
-	    }
-         }
-         if (frscdi == NS_FRSCD_NUM)
-         {
-            PRINTK("nicstar%d: no SCD available for CBR channel.\n", card->index);
-            card->tst_free_entries += n;
-	    clear_bit(ATM_VF_PARTIAL,&vcc->flags);
-	    clear_bit(ATM_VF_ADDR,&vcc->flags);
-	    return -EBUSY;
-         }
-
-         vc->cbr_scd = NS_FRSCD + frscdi * NS_FRSCD_SIZE;
-
-         scq = get_scq(CBR_SCQSIZE, vc->cbr_scd);
-         if (scq == NULL)
-         {
-            PRINTK("nicstar%d: can't get fixed rate SCQ.\n", card->index);
-            card->scd2vc[frscdi] = NULL;
-            card->tst_free_entries += n;
-	    clear_bit(ATM_VF_PARTIAL,&vcc->flags);
-	    clear_bit(ATM_VF_ADDR,&vcc->flags);
-            return -ENOMEM;
-         }
-	 vc->scq = scq;
-         u32d[0] = (u32) virt_to_bus(scq->base);
-         u32d[1] = (u32) 0x00000000;
-         u32d[2] = (u32) 0xffffffff;
-         u32d[3] = (u32) 0x00000000;
-         ns_write_sram(card, vc->cbr_scd, u32d, 4);
-         
-	 fill_tst(card, n, vc);
-      }
-      else if (vcc->qos.txtp.traffic_class == ATM_UBR)
-      {
-         vc->cbr_scd = 0x00000000;
-	 vc->scq = card->scq0;
-      }
-      
-      if (vcc->qos.txtp.traffic_class != ATM_NONE)
-      {
-         vc->tx = 1;
-	 vc->tx_vcc = vcc;
-	 vc->tbd_count = 0;
-      }
-      if (vcc->qos.rxtp.traffic_class != ATM_NONE)
-      {
-         u32 status;
-      
-         vc->rx = 1;
-         vc->rx_vcc = vcc;
-         vc->rx_iov = NULL;
-
-	 /* Open the connection in hardware */
-	 if (vcc->qos.aal == ATM_AAL5)
-	    status = NS_RCTE_AAL5 | NS_RCTE_CONNECTOPEN;
-	 else /* vcc->qos.aal == ATM_AAL0 */
-	    status = NS_RCTE_AAL0 | NS_RCTE_CONNECTOPEN;
+	ns_dev *card;
+	vc_map *vc;
+	unsigned long tmpl, modl;
+	int tcr, tcra;		/* target cell rate, and absolute value */
+	int n = 0;		/* Number of entries in the TST. Initialized to remove
+				   the compiler warning. */
+	u32 u32d[4];
+	int frscdi = 0;		/* Index of the SCD. Initialized to remove the compiler
+				   warning. How I wish compilers were clever enough to
+				   tell which variables can truly be used
+				   uninitialized... */
+	int inuse;		/* tx or rx vc already in use by another vcc */
+	short vpi = vcc->vpi;
+	int vci = vcc->vci;
+
+	card = (ns_dev *) vcc->dev->dev_data;
+	PRINTK("nicstar%d: opening vpi.vci %d.%d \n", card->index, (int)vpi,
+	       vci);
+	if (vcc->qos.aal != ATM_AAL5 && vcc->qos.aal != ATM_AAL0) {
+		PRINTK("nicstar%d: unsupported AAL.\n", card->index);
+		return -EINVAL;
+	}
+
+	vc = &(card->vcmap[vpi << card->vcibits | vci]);
+	vcc->dev_data = vc;
+
+	inuse = 0;
+	if (vcc->qos.txtp.traffic_class != ATM_NONE && vc->tx)
+		inuse = 1;
+	if (vcc->qos.rxtp.traffic_class != ATM_NONE && vc->rx)
+		inuse += 2;
+	if (inuse) {
+		printk("nicstar%d: %s vci already in use.\n", card->index,
+		       inuse == 1 ? "tx" : inuse == 2 ? "rx" : "tx and rx");
+		return -EINVAL;
+	}
+
+	set_bit(ATM_VF_ADDR, &vcc->flags);
+
+	/* NOTE: You are not allowed to modify an open connection's QOS. To change
+	   that, remove the ATM_VF_PARTIAL flag checking. There may be other changes
+	   needed to do that. */
+	if (!test_bit(ATM_VF_PARTIAL, &vcc->flags)) {
+		scq_info *scq;
+
+		set_bit(ATM_VF_PARTIAL, &vcc->flags);
+		if (vcc->qos.txtp.traffic_class == ATM_CBR) {
+			/* Check requested cell rate and availability of SCD */
+			if (vcc->qos.txtp.max_pcr == 0 && vcc->qos.txtp.pcr == 0
+			    && vcc->qos.txtp.min_pcr == 0) {
+				PRINTK
+				    ("nicstar%d: trying to open a CBR vc with cell rate = 0 \n",
+				     card->index);
+				clear_bit(ATM_VF_PARTIAL, &vcc->flags);
+				clear_bit(ATM_VF_ADDR, &vcc->flags);
+				return -EINVAL;
+			}
+
+			tcr = atm_pcr_goal(&(vcc->qos.txtp));
+			tcra = tcr >= 0 ? tcr : -tcr;
+
+			PRINTK("nicstar%d: target cell rate = %d.\n",
+			       card->index, vcc->qos.txtp.max_pcr);
+
+			tmpl =
+			    (unsigned long)tcra *(unsigned long)
+			    NS_TST_NUM_ENTRIES;
+			modl = tmpl % card->max_pcr;
+
+			n = (int)(tmpl / card->max_pcr);
+			if (tcr > 0) {
+				if (modl > 0)
+					n++;
+			} else if (tcr == 0) {
+				if ((n =
+				     (card->tst_free_entries -
+				      NS_TST_RESERVED)) <= 0) {
+					PRINTK
+					    ("nicstar%d: no CBR bandwidth free.\n",
+					     card->index);
+					clear_bit(ATM_VF_PARTIAL, &vcc->flags);
+					clear_bit(ATM_VF_ADDR, &vcc->flags);
+					return -EINVAL;
+				}
+			}
+
+			if (n == 0) {
+				printk
+				    ("nicstar%d: selected bandwidth < granularity.\n",
+				     card->index);
+				clear_bit(ATM_VF_PARTIAL, &vcc->flags);
+				clear_bit(ATM_VF_ADDR, &vcc->flags);
+				return -EINVAL;
+			}
+
+			if (n > (card->tst_free_entries - NS_TST_RESERVED)) {
+				PRINTK
+				    ("nicstar%d: not enough free CBR bandwidth.\n",
+				     card->index);
+				clear_bit(ATM_VF_PARTIAL, &vcc->flags);
+				clear_bit(ATM_VF_ADDR, &vcc->flags);
+				return -EINVAL;
+			} else
+				card->tst_free_entries -= n;
+
+			XPRINTK("nicstar%d: writing %d tst entries.\n",
+				card->index, n);
+			for (frscdi = 0; frscdi < NS_FRSCD_NUM; frscdi++) {
+				if (card->scd2vc[frscdi] == NULL) {
+					card->scd2vc[frscdi] = vc;
+					break;
+				}
+			}
+			if (frscdi == NS_FRSCD_NUM) {
+				PRINTK
+				    ("nicstar%d: no SCD available for CBR channel.\n",
+				     card->index);
+				card->tst_free_entries += n;
+				clear_bit(ATM_VF_PARTIAL, &vcc->flags);
+				clear_bit(ATM_VF_ADDR, &vcc->flags);
+				return -EBUSY;
+			}
+
+			vc->cbr_scd = NS_FRSCD + frscdi * NS_FRSCD_SIZE;
+
+			scq = get_scq(CBR_SCQSIZE, vc->cbr_scd);
+			if (scq == NULL) {
+				PRINTK("nicstar%d: can't get fixed rate SCQ.\n",
+				       card->index);
+				card->scd2vc[frscdi] = NULL;
+				card->tst_free_entries += n;
+				clear_bit(ATM_VF_PARTIAL, &vcc->flags);
+				clear_bit(ATM_VF_ADDR, &vcc->flags);
+				return -ENOMEM;
+			}
+			vc->scq = scq;
+			u32d[0] = (u32) virt_to_bus(scq->base);
+			u32d[1] = (u32) 0x00000000;
+			u32d[2] = (u32) 0xffffffff;
+			u32d[3] = (u32) 0x00000000;
+			ns_write_sram(card, vc->cbr_scd, u32d, 4);
+
+			fill_tst(card, n, vc);
+		} else if (vcc->qos.txtp.traffic_class == ATM_UBR) {
+			vc->cbr_scd = 0x00000000;
+			vc->scq = card->scq0;
+		}
+
+		if (vcc->qos.txtp.traffic_class != ATM_NONE) {
+			vc->tx = 1;
+			vc->tx_vcc = vcc;
+			vc->tbd_count = 0;
+		}
+		if (vcc->qos.rxtp.traffic_class != ATM_NONE) {
+			u32 status;
+
+			vc->rx = 1;
+			vc->rx_vcc = vcc;
+			vc->rx_iov = NULL;
+
+			/* Open the connection in hardware */
+			if (vcc->qos.aal == ATM_AAL5)
+				status = NS_RCTE_AAL5 | NS_RCTE_CONNECTOPEN;
+			else	/* vcc->qos.aal == ATM_AAL0 */
+				status = NS_RCTE_AAL0 | NS_RCTE_CONNECTOPEN;
 #ifdef RCQ_SUPPORT
-         status |= NS_RCTE_RAWCELLINTEN;
+			status |= NS_RCTE_RAWCELLINTEN;
 #endif /* RCQ_SUPPORT */
-         ns_write_sram(card, NS_RCT + (vpi << card->vcibits | vci) *
-	               NS_RCT_ENTRY_SIZE, &status, 1);
-      }
-      
-   }
-   
-   set_bit(ATM_VF_READY,&vcc->flags);
-   return 0;
-}
+			ns_write_sram(card,
+				      NS_RCT +
+				      (vpi << card->vcibits | vci) *
+				      NS_RCT_ENTRY_SIZE, &status, 1);
+		}
 
+	}
 
+	set_bit(ATM_VF_READY, &vcc->flags);
+	return 0;
+}
 
 static void ns_close(struct atm_vcc *vcc)
 {
-   vc_map *vc;
-   ns_dev *card;
-   u32 data;
-   int i;
-   
-   vc = vcc->dev_data;
-   card = vcc->dev->dev_data;
-   PRINTK("nicstar%d: closing vpi.vci %d.%d \n", card->index,
-          (int) vcc->vpi, vcc->vci);
-
-   clear_bit(ATM_VF_READY,&vcc->flags);
-   
-   if (vcc->qos.rxtp.traffic_class != ATM_NONE)
-   {
-      u32 addr;
-      unsigned long flags;
-      
-      addr = NS_RCT + (vcc->vpi << card->vcibits | vcc->vci) * NS_RCT_ENTRY_SIZE;
-      spin_lock_irqsave(&card->res_lock, flags);
-      while(CMD_BUSY(card));
-      writel(NS_CMD_CLOSE_CONNECTION | addr << 2, card->membase + CMD);
-      spin_unlock_irqrestore(&card->res_lock, flags);
-      
-      vc->rx = 0;
-      if (vc->rx_iov != NULL)
-      {
-	 struct sk_buff *iovb;
-	 u32 stat;
-   
-         stat = readl(card->membase + STAT);
-         card->sbfqc = ns_stat_sfbqc_get(stat);   
-         card->lbfqc = ns_stat_lfbqc_get(stat);
-
-         PRINTK("nicstar%d: closing a VC with pending rx buffers.\n",
-	        card->index);
-         iovb = vc->rx_iov;
-         recycle_iovec_rx_bufs(card, (struct iovec *) iovb->data,
-	                       NS_SKB(iovb)->iovcnt);
-         NS_SKB(iovb)->iovcnt = 0;
-         NS_SKB(iovb)->vcc = NULL;
-         spin_lock_irqsave(&card->int_lock, flags);
-         recycle_iov_buf(card, iovb);
-         spin_unlock_irqrestore(&card->int_lock, flags);
-         vc->rx_iov = NULL;
-      }
-   }
-
-   if (vcc->qos.txtp.traffic_class != ATM_NONE)
-   {
-      vc->tx = 0;
-   }
-
-   if (vcc->qos.txtp.traffic_class == ATM_CBR)
-   {
-      unsigned long flags;
-      ns_scqe *scqep;
-      scq_info *scq;
-
-      scq = vc->scq;
-
-      for (;;)
-      {
-         spin_lock_irqsave(&scq->lock, flags);
-         scqep = scq->next;
-         if (scqep == scq->base)
-            scqep = scq->last;
-         else
-            scqep--;
-         if (scqep == scq->tail)
-         {
-            spin_unlock_irqrestore(&scq->lock, flags);
-            break;
-         }
-         /* If the last entry is not a TSR, place one in the SCQ in order to
-            be able to completely drain it and then close. */
-         if (!ns_scqe_is_tsr(scqep) && scq->tail != scq->next)
-         {
-            ns_scqe tsr;
-            u32 scdi, scqi;
-            u32 data;
-            int index;
-
-            tsr.word_1 = ns_tsr_mkword_1(NS_TSR_INTENABLE);
-            scdi = (vc->cbr_scd - NS_FRSCD) / NS_FRSCD_SIZE;
-            scqi = scq->next - scq->base;
-            tsr.word_2 = ns_tsr_mkword_2(scdi, scqi);
-            tsr.word_3 = 0x00000000;
-            tsr.word_4 = 0x00000000;
-            *scq->next = tsr;
-            index = (int) scqi;
-            scq->skb[index] = NULL;
-            if (scq->next == scq->last)
-               scq->next = scq->base;
-            else
-               scq->next++;
-            data = (u32) virt_to_bus(scq->next);
-            ns_write_sram(card, scq->scd, &data, 1);
-         }
-         spin_unlock_irqrestore(&scq->lock, flags);
-         schedule();
-      }
-
-      /* Free all TST entries */
-      data = NS_TST_OPCODE_VARIABLE;
-      for (i = 0; i < NS_TST_NUM_ENTRIES; i++)
-      {
-         if (card->tste2vc[i] == vc)
-	 {
-            ns_write_sram(card, card->tst_addr + i, &data, 1);
-            card->tste2vc[i] = NULL;
-            card->tst_free_entries++;
-	 }
-      }
-      
-      card->scd2vc[(vc->cbr_scd - NS_FRSCD) / NS_FRSCD_SIZE] = NULL;
-      free_scq(vc->scq, vcc);
-   }
-
-   /* remove all references to vcc before deleting it */
-   if (vcc->qos.txtp.traffic_class != ATM_NONE)
-   {
-     unsigned long flags;
-     scq_info *scq = card->scq0;
-
-     spin_lock_irqsave(&scq->lock, flags);
-
-     for(i = 0; i < scq->num_entries; i++) {
-       if(scq->skb[i] && ATM_SKB(scq->skb[i])->vcc == vcc) {
-        ATM_SKB(scq->skb[i])->vcc = NULL;
-	atm_return(vcc, scq->skb[i]->truesize);
-        PRINTK("nicstar: deleted pending vcc mapping\n");
-       }
-     }
-
-     spin_unlock_irqrestore(&scq->lock, flags);
-   }
-
-   vcc->dev_data = NULL;
-   clear_bit(ATM_VF_PARTIAL,&vcc->flags);
-   clear_bit(ATM_VF_ADDR,&vcc->flags);
+	vc_map *vc;
+	ns_dev *card;
+	u32 data;
+	int i;
+
+	vc = vcc->dev_data;
+	card = vcc->dev->dev_data;
+	PRINTK("nicstar%d: closing vpi.vci %d.%d \n", card->index,
+	       (int)vcc->vpi, vcc->vci);
+
+	clear_bit(ATM_VF_READY, &vcc->flags);
+
+	if (vcc->qos.rxtp.traffic_class != ATM_NONE) {
+		u32 addr;
+		unsigned long flags;
+
+		addr =
+		    NS_RCT +
+		    (vcc->vpi << card->vcibits | vcc->vci) * NS_RCT_ENTRY_SIZE;
+		spin_lock_irqsave(&card->res_lock, flags);
+		while (CMD_BUSY(card)) ;
+		writel(NS_CMD_CLOSE_CONNECTION | addr << 2,
+		       card->membase + CMD);
+		spin_unlock_irqrestore(&card->res_lock, flags);
+
+		vc->rx = 0;
+		if (vc->rx_iov != NULL) {
+			struct sk_buff *iovb;
+			u32 stat;
+
+			stat = readl(card->membase + STAT);
+			card->sbfqc = ns_stat_sfbqc_get(stat);
+			card->lbfqc = ns_stat_lfbqc_get(stat);
+
+			PRINTK
+			    ("nicstar%d: closing a VC with pending rx buffers.\n",
+			     card->index);
+			iovb = vc->rx_iov;
+			recycle_iovec_rx_bufs(card, (struct iovec *)iovb->data,
+					      NS_SKB(iovb)->iovcnt);
+			NS_SKB(iovb)->iovcnt = 0;
+			NS_SKB(iovb)->vcc = NULL;
+			spin_lock_irqsave(&card->int_lock, flags);
+			recycle_iov_buf(card, iovb);
+			spin_unlock_irqrestore(&card->int_lock, flags);
+			vc->rx_iov = NULL;
+		}
+	}
+
+	if (vcc->qos.txtp.traffic_class != ATM_NONE) {
+		vc->tx = 0;
+	}
+
+	if (vcc->qos.txtp.traffic_class == ATM_CBR) {
+		unsigned long flags;
+		ns_scqe *scqep;
+		scq_info *scq;
+
+		scq = vc->scq;
+
+		for (;;) {
+			spin_lock_irqsave(&scq->lock, flags);
+			scqep = scq->next;
+			if (scqep == scq->base)
+				scqep = scq->last;
+			else
+				scqep--;
+			if (scqep == scq->tail) {
+				spin_unlock_irqrestore(&scq->lock, flags);
+				break;
+			}
+			/* If the last entry is not a TSR, place one in the SCQ in order to
+			   be able to completely drain it and then close. */
+			if (!ns_scqe_is_tsr(scqep) && scq->tail != scq->next) {
+				ns_scqe tsr;
+				u32 scdi, scqi;
+				u32 data;
+				int index;
+
+				tsr.word_1 = ns_tsr_mkword_1(NS_TSR_INTENABLE);
+				scdi = (vc->cbr_scd - NS_FRSCD) / NS_FRSCD_SIZE;
+				scqi = scq->next - scq->base;
+				tsr.word_2 = ns_tsr_mkword_2(scdi, scqi);
+				tsr.word_3 = 0x00000000;
+				tsr.word_4 = 0x00000000;
+				*scq->next = tsr;
+				index = (int)scqi;
+				scq->skb[index] = NULL;
+				if (scq->next == scq->last)
+					scq->next = scq->base;
+				else
+					scq->next++;
+				data = (u32) virt_to_bus(scq->next);
+				ns_write_sram(card, scq->scd, &data, 1);
+			}
+			spin_unlock_irqrestore(&scq->lock, flags);
+			schedule();
+		}
+
+		/* Free all TST entries */
+		data = NS_TST_OPCODE_VARIABLE;
+		for (i = 0; i < NS_TST_NUM_ENTRIES; i++) {
+			if (card->tste2vc[i] == vc) {
+				ns_write_sram(card, card->tst_addr + i, &data,
+					      1);
+				card->tste2vc[i] = NULL;
+				card->tst_free_entries++;
+			}
+		}
+
+		card->scd2vc[(vc->cbr_scd - NS_FRSCD) / NS_FRSCD_SIZE] = NULL;
+		free_scq(vc->scq, vcc);
+	}
+
+	/* remove all references to vcc before deleting it */
+	if (vcc->qos.txtp.traffic_class != ATM_NONE) {
+		unsigned long flags;
+		scq_info *scq = card->scq0;
+
+		spin_lock_irqsave(&scq->lock, flags);
+
+		for (i = 0; i < scq->num_entries; i++) {
+			if (scq->skb[i] && ATM_SKB(scq->skb[i])->vcc == vcc) {
+				ATM_SKB(scq->skb[i])->vcc = NULL;
+				atm_return(vcc, scq->skb[i]->truesize);
+				PRINTK
+				    ("nicstar: deleted pending vcc mapping\n");
+			}
+		}
+
+		spin_unlock_irqrestore(&scq->lock, flags);
+	}
+
+	vcc->dev_data = NULL;
+	clear_bit(ATM_VF_PARTIAL, &vcc->flags);
+	clear_bit(ATM_VF_ADDR, &vcc->flags);
 
 #ifdef RX_DEBUG
-   {
-      u32 stat, cfg;
-      stat = readl(card->membase + STAT);
-      cfg = readl(card->membase + CFG);
-      printk("STAT = 0x%08X  CFG = 0x%08X  \n", stat, cfg);
-      printk("TSQ: base = 0x%08X  next = 0x%08X  last = 0x%08X  TSQT = 0x%08X \n",
-             (u32) card->tsq.base, (u32) card->tsq.next,(u32) card->tsq.last,
-	     readl(card->membase + TSQT));
-      printk("RSQ: base = 0x%08X  next = 0x%08X  last = 0x%08X  RSQT = 0x%08X \n",
-             (u32) card->rsq.base, (u32) card->rsq.next,(u32) card->rsq.last,
-	     readl(card->membase + RSQT));
-      printk("Empty free buffer queue interrupt %s \n",
-             card->efbie ? "enabled" : "disabled");
-      printk("SBCNT = %d  count = %d   LBCNT = %d count = %d \n",
-             ns_stat_sfbqc_get(stat), card->sbpool.count,
-	     ns_stat_lfbqc_get(stat), card->lbpool.count);
-      printk("hbpool.count = %d  iovpool.count = %d \n",
-             card->hbpool.count, card->iovpool.count);
-   }
+	{
+		u32 stat, cfg;
+		stat = readl(card->membase + STAT);
+		cfg = readl(card->membase + CFG);
+		printk("STAT = 0x%08X  CFG = 0x%08X  \n", stat, cfg);
+		printk
+		    ("TSQ: base = 0x%08X  next = 0x%08X  last = 0x%08X  TSQT = 0x%08X \n",
+		     (u32) card->tsq.base, (u32) card->tsq.next,
+		     (u32) card->tsq.last, readl(card->membase + TSQT));
+		printk
+		    ("RSQ: base = 0x%08X  next = 0x%08X  last = 0x%08X  RSQT = 0x%08X \n",
+		     (u32) card->rsq.base, (u32) card->rsq.next,
+		     (u32) card->rsq.last, readl(card->membase + RSQT));
+		printk("Empty free buffer queue interrupt %s \n",
+		       card->efbie ? "enabled" : "disabled");
+		printk("SBCNT = %d  count = %d   LBCNT = %d count = %d \n",
+		       ns_stat_sfbqc_get(stat), card->sbpool.count,
+		       ns_stat_lfbqc_get(stat), card->lbpool.count);
+		printk("hbpool.count = %d  iovpool.count = %d \n",
+		       card->hbpool.count, card->iovpool.count);
+	}
 #endif /* RX_DEBUG */
 }
 
-
-
-static void fill_tst(ns_dev *card, int n, vc_map *vc)
+static void fill_tst(ns_dev * card, int n, vc_map * vc)
 {
-   u32 new_tst;
-   unsigned long cl;
-   int e, r;
-   u32 data;
-      
-   /* It would be very complicated to keep the two TSTs synchronized while
-      assuring that writes are only made to the inactive TST. So, for now I
-      will use only one TST. If problems occur, I will change this again */
-   
-   new_tst = card->tst_addr;
-
-   /* Fill procedure */
-
-   for (e = 0; e < NS_TST_NUM_ENTRIES; e++)
-   {
-      if (card->tste2vc[e] == NULL)
-         break;
-   }
-   if (e == NS_TST_NUM_ENTRIES) {
-      printk("nicstar%d: No free TST entries found. \n", card->index);
-      return;
-   }
-
-   r = n;
-   cl = NS_TST_NUM_ENTRIES;
-   data = ns_tste_make(NS_TST_OPCODE_FIXED, vc->cbr_scd);
-      
-   while (r > 0)
-   {
-      if (cl >= NS_TST_NUM_ENTRIES && card->tste2vc[e] == NULL)
-      {
-         card->tste2vc[e] = vc;
-         ns_write_sram(card, new_tst + e, &data, 1);
-         cl -= NS_TST_NUM_ENTRIES;
-         r--;
-      }
-
-      if (++e == NS_TST_NUM_ENTRIES) {
-         e = 0;
-      }
-      cl += n;
-   }
-   
-   /* End of fill procedure */
-   
-   data = ns_tste_make(NS_TST_OPCODE_END, new_tst);
-   ns_write_sram(card, new_tst + NS_TST_NUM_ENTRIES, &data, 1);
-   ns_write_sram(card, card->tst_addr + NS_TST_NUM_ENTRIES, &data, 1);
-   card->tst_addr = new_tst;
+	u32 new_tst;
+	unsigned long cl;
+	int e, r;
+	u32 data;
+
+	/* It would be very complicated to keep the two TSTs synchronized while
+	   assuring that writes are only made to the inactive TST. So, for now I
+	   will use only one TST. If problems occur, I will change this again */
+
+	new_tst = card->tst_addr;
+
+	/* Fill procedure */
+
+	for (e = 0; e < NS_TST_NUM_ENTRIES; e++) {
+		if (card->tste2vc[e] == NULL)
+			break;
+	}
+	if (e == NS_TST_NUM_ENTRIES) {
+		printk("nicstar%d: No free TST entries found. \n", card->index);
+		return;
+	}
+
+	r = n;
+	cl = NS_TST_NUM_ENTRIES;
+	data = ns_tste_make(NS_TST_OPCODE_FIXED, vc->cbr_scd);
+
+	while (r > 0) {
+		if (cl >= NS_TST_NUM_ENTRIES && card->tste2vc[e] == NULL) {
+			card->tste2vc[e] = vc;
+			ns_write_sram(card, new_tst + e, &data, 1);
+			cl -= NS_TST_NUM_ENTRIES;
+			r--;
+		}
+
+		if (++e == NS_TST_NUM_ENTRIES) {
+			e = 0;
+		}
+		cl += n;
+	}
+
+	/* End of fill procedure */
+
+	data = ns_tste_make(NS_TST_OPCODE_END, new_tst);
+	ns_write_sram(card, new_tst + NS_TST_NUM_ENTRIES, &data, 1);
+	ns_write_sram(card, card->tst_addr + NS_TST_NUM_ENTRIES, &data, 1);
+	card->tst_addr = new_tst;
 }
 
-
-
 static int ns_send(struct atm_vcc *vcc, struct sk_buff *skb)
 {
-   ns_dev *card;
-   vc_map *vc;
-   scq_info *scq;
-   unsigned long buflen;
-   ns_scqe scqe;
-   u32 flags;		/* TBD flags, not CPU flags */
-   
-   card = vcc->dev->dev_data;
-   TXPRINTK("nicstar%d: ns_send() called.\n", card->index);
-   if ((vc = (vc_map *) vcc->dev_data) == NULL)
-   {
-      printk("nicstar%d: vcc->dev_data == NULL on ns_send().\n", card->index);
-      atomic_inc(&vcc->stats->tx_err);
-      dev_kfree_skb_any(skb);
-      return -EINVAL;
-   }
-   
-   if (!vc->tx)
-   {
-      printk("nicstar%d: Trying to transmit on a non-tx VC.\n", card->index);
-      atomic_inc(&vcc->stats->tx_err);
-      dev_kfree_skb_any(skb);
-      return -EINVAL;
-   }
-   
-   if (vcc->qos.aal != ATM_AAL5 && vcc->qos.aal != ATM_AAL0)
-   {
-      printk("nicstar%d: Only AAL0 and AAL5 are supported.\n", card->index);
-      atomic_inc(&vcc->stats->tx_err);
-      dev_kfree_skb_any(skb);
-      return -EINVAL;
-   }
-   
-   if (skb_shinfo(skb)->nr_frags != 0)
-   {
-      printk("nicstar%d: No scatter-gather yet.\n", card->index);
-      atomic_inc(&vcc->stats->tx_err);
-      dev_kfree_skb_any(skb);
-      return -EINVAL;
-   }
-   
-   ATM_SKB(skb)->vcc = vcc;
-
-   if (vcc->qos.aal == ATM_AAL5)
-   {
-      buflen = (skb->len + 47 + 8) / 48 * 48;	/* Multiple of 48 */
-      flags = NS_TBD_AAL5;
-      scqe.word_2 = cpu_to_le32((u32) virt_to_bus(skb->data));
-      scqe.word_3 = cpu_to_le32((u32) skb->len);
-      scqe.word_4 = ns_tbd_mkword_4(0, (u32) vcc->vpi, (u32) vcc->vci, 0,
-                           ATM_SKB(skb)->atm_options & ATM_ATMOPT_CLP ? 1 : 0);
-      flags |= NS_TBD_EOPDU;
-   }
-   else /* (vcc->qos.aal == ATM_AAL0) */
-   {
-      buflen = ATM_CELL_PAYLOAD;	/* i.e., 48 bytes */
-      flags = NS_TBD_AAL0;
-      scqe.word_2 = cpu_to_le32((u32) virt_to_bus(skb->data) + NS_AAL0_HEADER);
-      scqe.word_3 = cpu_to_le32(0x00000000);
-      if (*skb->data & 0x02)	/* Payload type 1 - end of pdu */
-         flags |= NS_TBD_EOPDU;
-      scqe.word_4 = cpu_to_le32(*((u32 *) skb->data) & ~NS_TBD_VC_MASK);
-      /* Force the VPI/VCI to be the same as in VCC struct */
-      scqe.word_4 |= cpu_to_le32((((u32) vcc->vpi) << NS_TBD_VPI_SHIFT |
-                                 ((u32) vcc->vci) << NS_TBD_VCI_SHIFT) &
-                                 NS_TBD_VC_MASK);
-   }
-
-   if (vcc->qos.txtp.traffic_class == ATM_CBR)
-   {
-      scqe.word_1 = ns_tbd_mkword_1_novbr(flags, (u32) buflen);
-      scq = ((vc_map *) vcc->dev_data)->scq;
-   }
-   else
-   {
-      scqe.word_1 = ns_tbd_mkword_1(flags, (u32) 1, (u32) 1, (u32) buflen);
-      scq = card->scq0;
-   }
-
-   if (push_scqe(card, vc, scq, &scqe, skb) != 0)
-   {
-      atomic_inc(&vcc->stats->tx_err);
-      dev_kfree_skb_any(skb);
-      return -EIO;
-   }
-   atomic_inc(&vcc->stats->tx);
-
-   return 0;
-}
-
+	ns_dev *card;
+	vc_map *vc;
+	scq_info *scq;
+	unsigned long buflen;
+	ns_scqe scqe;
+	u32 flags;		/* TBD flags, not CPU flags */
+
+	card = vcc->dev->dev_data;
+	TXPRINTK("nicstar%d: ns_send() called.\n", card->index);
+	if ((vc = (vc_map *) vcc->dev_data) == NULL) {
+		printk("nicstar%d: vcc->dev_data == NULL on ns_send().\n",
+		       card->index);
+		atomic_inc(&vcc->stats->tx_err);
+		dev_kfree_skb_any(skb);
+		return -EINVAL;
+	}
 
+	if (!vc->tx) {
+		printk("nicstar%d: Trying to transmit on a non-tx VC.\n",
+		       card->index);
+		atomic_inc(&vcc->stats->tx_err);
+		dev_kfree_skb_any(skb);
+		return -EINVAL;
+	}
 
-static int push_scqe(ns_dev *card, vc_map *vc, scq_info *scq, ns_scqe *tbd,
-                     struct sk_buff *skb)
-{
-   unsigned long flags;
-   ns_scqe tsr;
-   u32 scdi, scqi;
-   int scq_is_vbr;
-   u32 data;
-   int index;
-   
-   spin_lock_irqsave(&scq->lock, flags);
-   while (scq->tail == scq->next)
-   {
-      if (in_interrupt()) {
-         spin_unlock_irqrestore(&scq->lock, flags);
-         printk("nicstar%d: Error pushing TBD.\n", card->index);
-         return 1;
-      }
-
-      scq->full = 1;
-      spin_unlock_irqrestore(&scq->lock, flags);
-      interruptible_sleep_on_timeout(&scq->scqfull_waitq, SCQFULL_TIMEOUT);
-      spin_lock_irqsave(&scq->lock, flags);
-
-      if (scq->full) {
-         spin_unlock_irqrestore(&scq->lock, flags);
-         printk("nicstar%d: Timeout pushing TBD.\n", card->index);
-         return 1;
-      }
-   }
-   *scq->next = *tbd;
-   index = (int) (scq->next - scq->base);
-   scq->skb[index] = skb;
-   XPRINTK("nicstar%d: sending skb at 0x%x (pos %d).\n",
-           card->index, (u32) skb, index);
-   XPRINTK("nicstar%d: TBD written:\n0x%x\n0x%x\n0x%x\n0x%x\n at 0x%x.\n",
-           card->index, le32_to_cpu(tbd->word_1), le32_to_cpu(tbd->word_2),
-           le32_to_cpu(tbd->word_3), le32_to_cpu(tbd->word_4),
-           (u32) scq->next);
-   if (scq->next == scq->last)
-      scq->next = scq->base;
-   else
-      scq->next++;
-
-   vc->tbd_count++;
-   if (scq->num_entries == VBR_SCQ_NUM_ENTRIES)
-   {
-      scq->tbd_count++;
-      scq_is_vbr = 1;
-   }
-   else
-      scq_is_vbr = 0;
-
-   if (vc->tbd_count >= MAX_TBD_PER_VC || scq->tbd_count >= MAX_TBD_PER_SCQ)
-   {
-      int has_run = 0;
-
-      while (scq->tail == scq->next)
-      {
-         if (in_interrupt()) {
-            data = (u32) virt_to_bus(scq->next);
-            ns_write_sram(card, scq->scd, &data, 1);
-            spin_unlock_irqrestore(&scq->lock, flags);
-            printk("nicstar%d: Error pushing TSR.\n", card->index);
-            return 0;
-         }
-
-         scq->full = 1;
-         if (has_run++) break;
-         spin_unlock_irqrestore(&scq->lock, flags);
-         interruptible_sleep_on_timeout(&scq->scqfull_waitq, SCQFULL_TIMEOUT);
-         spin_lock_irqsave(&scq->lock, flags);
-      }
-
-      if (!scq->full)
-      {
-         tsr.word_1 = ns_tsr_mkword_1(NS_TSR_INTENABLE);
-         if (scq_is_vbr)
-            scdi = NS_TSR_SCDISVBR;
-         else
-            scdi = (vc->cbr_scd - NS_FRSCD) / NS_FRSCD_SIZE;
-         scqi = scq->next - scq->base;
-         tsr.word_2 = ns_tsr_mkword_2(scdi, scqi);
-         tsr.word_3 = 0x00000000;
-         tsr.word_4 = 0x00000000;
-
-         *scq->next = tsr;
-         index = (int) scqi;
-         scq->skb[index] = NULL;
-         XPRINTK("nicstar%d: TSR written:\n0x%x\n0x%x\n0x%x\n0x%x\n at 0x%x.\n",
-                 card->index, le32_to_cpu(tsr.word_1), le32_to_cpu(tsr.word_2),
-                 le32_to_cpu(tsr.word_3), le32_to_cpu(tsr.word_4),
-		 (u32) scq->next);
-         if (scq->next == scq->last)
-            scq->next = scq->base;
-         else
-            scq->next++;
-         vc->tbd_count = 0;
-         scq->tbd_count = 0;
-      }
-      else
-         PRINTK("nicstar%d: Timeout pushing TSR.\n", card->index);
-   }
-   data = (u32) virt_to_bus(scq->next);
-   ns_write_sram(card, scq->scd, &data, 1);
-   
-   spin_unlock_irqrestore(&scq->lock, flags);
-   
-   return 0;
-}
+	if (vcc->qos.aal != ATM_AAL5 && vcc->qos.aal != ATM_AAL0) {
+		printk("nicstar%d: Only AAL0 and AAL5 are supported.\n",
+		       card->index);
+		atomic_inc(&vcc->stats->tx_err);
+		dev_kfree_skb_any(skb);
+		return -EINVAL;
+	}
 
+	if (skb_shinfo(skb)->nr_frags != 0) {
+		printk("nicstar%d: No scatter-gather yet.\n", card->index);
+		atomic_inc(&vcc->stats->tx_err);
+		dev_kfree_skb_any(skb);
+		return -EINVAL;
+	}
+
+	ATM_SKB(skb)->vcc = vcc;
+
+	if (vcc->qos.aal == ATM_AAL5) {
+		buflen = (skb->len + 47 + 8) / 48 * 48;	/* Multiple of 48 */
+		flags = NS_TBD_AAL5;
+		scqe.word_2 = cpu_to_le32((u32) virt_to_bus(skb->data));
+		scqe.word_3 = cpu_to_le32((u32) skb->len);
+		scqe.word_4 =
+		    ns_tbd_mkword_4(0, (u32) vcc->vpi, (u32) vcc->vci, 0,
+				    ATM_SKB(skb)->
+				    atm_options & ATM_ATMOPT_CLP ? 1 : 0);
+		flags |= NS_TBD_EOPDU;
+	} else {		/* (vcc->qos.aal == ATM_AAL0) */
+
+		buflen = ATM_CELL_PAYLOAD;	/* i.e., 48 bytes */
+		flags = NS_TBD_AAL0;
+		scqe.word_2 =
+		    cpu_to_le32((u32) virt_to_bus(skb->data) + NS_AAL0_HEADER);
+		scqe.word_3 = cpu_to_le32(0x00000000);
+		if (*skb->data & 0x02)	/* Payload type 1 - end of pdu */
+			flags |= NS_TBD_EOPDU;
+		scqe.word_4 =
+		    cpu_to_le32(*((u32 *) skb->data) & ~NS_TBD_VC_MASK);
+		/* Force the VPI/VCI to be the same as in VCC struct */
+		scqe.word_4 |=
+		    cpu_to_le32((((u32) vcc->
+				  vpi) << NS_TBD_VPI_SHIFT | ((u32) vcc->
+							      vci) <<
+				 NS_TBD_VCI_SHIFT) & NS_TBD_VC_MASK);
+	}
+
+	if (vcc->qos.txtp.traffic_class == ATM_CBR) {
+		scqe.word_1 = ns_tbd_mkword_1_novbr(flags, (u32) buflen);
+		scq = ((vc_map *) vcc->dev_data)->scq;
+	} else {
+		scqe.word_1 =
+		    ns_tbd_mkword_1(flags, (u32) 1, (u32) 1, (u32) buflen);
+		scq = card->scq0;
+	}
+
+	if (push_scqe(card, vc, scq, &scqe, skb) != 0) {
+		atomic_inc(&vcc->stats->tx_err);
+		dev_kfree_skb_any(skb);
+		return -EIO;
+	}
+	atomic_inc(&vcc->stats->tx);
 
+	return 0;
+}
 
-static void process_tsq(ns_dev *card)
+static int push_scqe(ns_dev * card, vc_map * vc, scq_info * scq, ns_scqe * tbd,
+		     struct sk_buff *skb)
 {
-   u32 scdi;
-   scq_info *scq;
-   ns_tsi *previous = NULL, *one_ahead, *two_ahead;
-   int serviced_entries;   /* flag indicating at least on entry was serviced */
-   
-   serviced_entries = 0;
-   
-   if (card->tsq.next == card->tsq.last)
-      one_ahead = card->tsq.base;
-   else
-      one_ahead = card->tsq.next + 1;
-
-   if (one_ahead == card->tsq.last)
-      two_ahead = card->tsq.base;
-   else
-      two_ahead = one_ahead + 1;
-   
-   while (!ns_tsi_isempty(card->tsq.next) || !ns_tsi_isempty(one_ahead) ||
-          !ns_tsi_isempty(two_ahead))
-          /* At most two empty, as stated in the 77201 errata */
-   {
-      serviced_entries = 1;
-    
-      /* Skip the one or two possible empty entries */
-      while (ns_tsi_isempty(card->tsq.next)) {
-         if (card->tsq.next == card->tsq.last)
-            card->tsq.next = card->tsq.base;
-         else
-            card->tsq.next++;
-      }
-    
-      if (!ns_tsi_tmrof(card->tsq.next))
-      {
-         scdi = ns_tsi_getscdindex(card->tsq.next);
-	 if (scdi == NS_TSI_SCDISVBR)
-	    scq = card->scq0;
-	 else
-	 {
-	    if (card->scd2vc[scdi] == NULL)
-	    {
-	       printk("nicstar%d: could not find VC from SCD index.\n",
-	              card->index);
-               ns_tsi_init(card->tsq.next);
-               return;
-            }
-            scq = card->scd2vc[scdi]->scq;
-         }
-         drain_scq(card, scq, ns_tsi_getscqpos(card->tsq.next));
-         scq->full = 0;
-         wake_up_interruptible(&(scq->scqfull_waitq));
-      }
-
-      ns_tsi_init(card->tsq.next);
-      previous = card->tsq.next;
-      if (card->tsq.next == card->tsq.last)
-         card->tsq.next = card->tsq.base;
-      else
-         card->tsq.next++;
-
-      if (card->tsq.next == card->tsq.last)
-         one_ahead = card->tsq.base;
-      else
-         one_ahead = card->tsq.next + 1;
-
-      if (one_ahead == card->tsq.last)
-         two_ahead = card->tsq.base;
-      else
-         two_ahead = one_ahead + 1;
-   }
-
-   if (serviced_entries) {
-      writel((((u32) previous) - ((u32) card->tsq.base)),
-             card->membase + TSQH);
-   }
+	unsigned long flags;
+	ns_scqe tsr;
+	u32 scdi, scqi;
+	int scq_is_vbr;
+	u32 data;
+	int index;
+
+	spin_lock_irqsave(&scq->lock, flags);
+	while (scq->tail == scq->next) {
+		if (in_interrupt()) {
+			spin_unlock_irqrestore(&scq->lock, flags);
+			printk("nicstar%d: Error pushing TBD.\n", card->index);
+			return 1;
+		}
+
+		scq->full = 1;
+		spin_unlock_irqrestore(&scq->lock, flags);
+		interruptible_sleep_on_timeout(&scq->scqfull_waitq,
+					       SCQFULL_TIMEOUT);
+		spin_lock_irqsave(&scq->lock, flags);
+
+		if (scq->full) {
+			spin_unlock_irqrestore(&scq->lock, flags);
+			printk("nicstar%d: Timeout pushing TBD.\n",
+			       card->index);
+			return 1;
+		}
+	}
+	*scq->next = *tbd;
+	index = (int)(scq->next - scq->base);
+	scq->skb[index] = skb;
+	XPRINTK("nicstar%d: sending skb at 0x%x (pos %d).\n",
+		card->index, (u32) skb, index);
+	XPRINTK("nicstar%d: TBD written:\n0x%x\n0x%x\n0x%x\n0x%x\n at 0x%x.\n",
+		card->index, le32_to_cpu(tbd->word_1), le32_to_cpu(tbd->word_2),
+		le32_to_cpu(tbd->word_3), le32_to_cpu(tbd->word_4),
+		(u32) scq->next);
+	if (scq->next == scq->last)
+		scq->next = scq->base;
+	else
+		scq->next++;
+
+	vc->tbd_count++;
+	if (scq->num_entries == VBR_SCQ_NUM_ENTRIES) {
+		scq->tbd_count++;
+		scq_is_vbr = 1;
+	} else
+		scq_is_vbr = 0;
+
+	if (vc->tbd_count >= MAX_TBD_PER_VC
+	    || scq->tbd_count >= MAX_TBD_PER_SCQ) {
+		int has_run = 0;
+
+		while (scq->tail == scq->next) {
+			if (in_interrupt()) {
+				data = (u32) virt_to_bus(scq->next);
+				ns_write_sram(card, scq->scd, &data, 1);
+				spin_unlock_irqrestore(&scq->lock, flags);
+				printk("nicstar%d: Error pushing TSR.\n",
+				       card->index);
+				return 0;
+			}
+
+			scq->full = 1;
+			if (has_run++)
+				break;
+			spin_unlock_irqrestore(&scq->lock, flags);
+			interruptible_sleep_on_timeout(&scq->scqfull_waitq,
+						       SCQFULL_TIMEOUT);
+			spin_lock_irqsave(&scq->lock, flags);
+		}
+
+		if (!scq->full) {
+			tsr.word_1 = ns_tsr_mkword_1(NS_TSR_INTENABLE);
+			if (scq_is_vbr)
+				scdi = NS_TSR_SCDISVBR;
+			else
+				scdi = (vc->cbr_scd - NS_FRSCD) / NS_FRSCD_SIZE;
+			scqi = scq->next - scq->base;
+			tsr.word_2 = ns_tsr_mkword_2(scdi, scqi);
+			tsr.word_3 = 0x00000000;
+			tsr.word_4 = 0x00000000;
+
+			*scq->next = tsr;
+			index = (int)scqi;
+			scq->skb[index] = NULL;
+			XPRINTK
+			    ("nicstar%d: TSR written:\n0x%x\n0x%x\n0x%x\n0x%x\n at 0x%x.\n",
+			     card->index, le32_to_cpu(tsr.word_1),
+			     le32_to_cpu(tsr.word_2), le32_to_cpu(tsr.word_3),
+			     le32_to_cpu(tsr.word_4), (u32) scq->next);
+			if (scq->next == scq->last)
+				scq->next = scq->base;
+			else
+				scq->next++;
+			vc->tbd_count = 0;
+			scq->tbd_count = 0;
+		} else
+			PRINTK("nicstar%d: Timeout pushing TSR.\n",
+			       card->index);
+	}
+	data = (u32) virt_to_bus(scq->next);
+	ns_write_sram(card, scq->scd, &data, 1);
+
+	spin_unlock_irqrestore(&scq->lock, flags);
+
+	return 0;
 }
 
-
-
-static void drain_scq(ns_dev *card, scq_info *scq, int pos)
+static void process_tsq(ns_dev * card)
 {
-   struct atm_vcc *vcc;
-   struct sk_buff *skb;
-   int i;
-   unsigned long flags;
-   
-   XPRINTK("nicstar%d: drain_scq() called, scq at 0x%x, pos %d.\n",
-           card->index, (u32) scq, pos);
-   if (pos >= scq->num_entries)
-   {
-      printk("nicstar%d: Bad index on drain_scq().\n", card->index);
-      return;
-   }
-
-   spin_lock_irqsave(&scq->lock, flags);
-   i = (int) (scq->tail - scq->base);
-   if (++i == scq->num_entries)
-      i = 0;
-   while (i != pos)
-   {
-      skb = scq->skb[i];
-      XPRINTK("nicstar%d: freeing skb at 0x%x (index %d).\n",
-              card->index, (u32) skb, i);
-      if (skb != NULL)
-      {
-         vcc = ATM_SKB(skb)->vcc;
-	 if (vcc && vcc->pop != NULL) {
-	    vcc->pop(vcc, skb);
-	 } else {
-	    dev_kfree_skb_irq(skb);
-         }
-	 scq->skb[i] = NULL;
-      }
-      if (++i == scq->num_entries)
-         i = 0;
-   }
-   scq->tail = scq->base + pos;
-   spin_unlock_irqrestore(&scq->lock, flags);
+	u32 scdi;
+	scq_info *scq;
+	ns_tsi *previous = NULL, *one_ahead, *two_ahead;
+	int serviced_entries;	/* flag indicating at least on entry was serviced */
+
+	serviced_entries = 0;
+
+	if (card->tsq.next == card->tsq.last)
+		one_ahead = card->tsq.base;
+	else
+		one_ahead = card->tsq.next + 1;
+
+	if (one_ahead == card->tsq.last)
+		two_ahead = card->tsq.base;
+	else
+		two_ahead = one_ahead + 1;
+
+	while (!ns_tsi_isempty(card->tsq.next) || !ns_tsi_isempty(one_ahead) ||
+	       !ns_tsi_isempty(two_ahead))
+		/* At most two empty, as stated in the 77201 errata */
+	{
+		serviced_entries = 1;
+
+		/* Skip the one or two possible empty entries */
+		while (ns_tsi_isempty(card->tsq.next)) {
+			if (card->tsq.next == card->tsq.last)
+				card->tsq.next = card->tsq.base;
+			else
+				card->tsq.next++;
+		}
+
+		if (!ns_tsi_tmrof(card->tsq.next)) {
+			scdi = ns_tsi_getscdindex(card->tsq.next);
+			if (scdi == NS_TSI_SCDISVBR)
+				scq = card->scq0;
+			else {
+				if (card->scd2vc[scdi] == NULL) {
+					printk
+					    ("nicstar%d: could not find VC from SCD index.\n",
+					     card->index);
+					ns_tsi_init(card->tsq.next);
+					return;
+				}
+				scq = card->scd2vc[scdi]->scq;
+			}
+			drain_scq(card, scq, ns_tsi_getscqpos(card->tsq.next));
+			scq->full = 0;
+			wake_up_interruptible(&(scq->scqfull_waitq));
+		}
+
+		ns_tsi_init(card->tsq.next);
+		previous = card->tsq.next;
+		if (card->tsq.next == card->tsq.last)
+			card->tsq.next = card->tsq.base;
+		else
+			card->tsq.next++;
+
+		if (card->tsq.next == card->tsq.last)
+			one_ahead = card->tsq.base;
+		else
+			one_ahead = card->tsq.next + 1;
+
+		if (one_ahead == card->tsq.last)
+			two_ahead = card->tsq.base;
+		else
+			two_ahead = one_ahead + 1;
+	}
+
+	if (serviced_entries) {
+		writel((((u32) previous) - ((u32) card->tsq.base)),
+		       card->membase + TSQH);
+	}
 }
 
-
-
-static void process_rsq(ns_dev *card)
+static void drain_scq(ns_dev * card, scq_info * scq, int pos)
 {
-   ns_rsqe *previous;
-
-   if (!ns_rsqe_valid(card->rsq.next))
-      return;
-   do {
-      dequeue_rx(card, card->rsq.next);
-      ns_rsqe_init(card->rsq.next);
-      previous = card->rsq.next;
-      if (card->rsq.next == card->rsq.last)
-         card->rsq.next = card->rsq.base;
-      else
-         card->rsq.next++;
-   } while (ns_rsqe_valid(card->rsq.next));
-   writel((((u32) previous) - ((u32) card->rsq.base)),
-          card->membase + RSQH);
+	struct atm_vcc *vcc;
+	struct sk_buff *skb;
+	int i;
+	unsigned long flags;
+
+	XPRINTK("nicstar%d: drain_scq() called, scq at 0x%x, pos %d.\n",
+		card->index, (u32) scq, pos);
+	if (pos >= scq->num_entries) {
+		printk("nicstar%d: Bad index on drain_scq().\n", card->index);
+		return;
+	}
+
+	spin_lock_irqsave(&scq->lock, flags);
+	i = (int)(scq->tail - scq->base);
+	if (++i == scq->num_entries)
+		i = 0;
+	while (i != pos) {
+		skb = scq->skb[i];
+		XPRINTK("nicstar%d: freeing skb at 0x%x (index %d).\n",
+			card->index, (u32) skb, i);
+		if (skb != NULL) {
+			vcc = ATM_SKB(skb)->vcc;
+			if (vcc && vcc->pop != NULL) {
+				vcc->pop(vcc, skb);
+			} else {
+				dev_kfree_skb_irq(skb);
+			}
+			scq->skb[i] = NULL;
+		}
+		if (++i == scq->num_entries)
+			i = 0;
+	}
+	scq->tail = scq->base + pos;
+	spin_unlock_irqrestore(&scq->lock, flags);
 }
 
+static void process_rsq(ns_dev * card)
+{
+	ns_rsqe *previous;
+
+	if (!ns_rsqe_valid(card->rsq.next))
+		return;
+	do {
+		dequeue_rx(card, card->rsq.next);
+		ns_rsqe_init(card->rsq.next);
+		previous = card->rsq.next;
+		if (card->rsq.next == card->rsq.last)
+			card->rsq.next = card->rsq.base;
+		else
+			card->rsq.next++;
+	} while (ns_rsqe_valid(card->rsq.next));
+	writel((((u32) previous) - ((u32) card->rsq.base)),
+	       card->membase + RSQH);
+}
 
-
-static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
+static void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)
 {
-   u32 vpi, vci;
-   vc_map *vc;
-   struct sk_buff *iovb;
-   struct iovec *iov;
-   struct atm_vcc *vcc;
-   struct sk_buff *skb;
-   unsigned short aal5_len;
-   int len;
-   u32 stat;
-
-   stat = readl(card->membase + STAT);
-   card->sbfqc = ns_stat_sfbqc_get(stat);   
-   card->lbfqc = ns_stat_lfbqc_get(stat);
-
-   skb = (struct sk_buff *) le32_to_cpu(rsqe->buffer_handle);
-   vpi = ns_rsqe_vpi(rsqe);
-   vci = ns_rsqe_vci(rsqe);
-   if (vpi >= 1UL << card->vpibits || vci >= 1UL << card->vcibits)
-   {
-      printk("nicstar%d: SDU received for out-of-range vc %d.%d.\n",
-             card->index, vpi, vci);
-      recycle_rx_buf(card, skb);
-      return;
-   }
-   
-   vc = &(card->vcmap[vpi << card->vcibits | vci]);
-   if (!vc->rx)
-   {
-      RXPRINTK("nicstar%d: SDU received on non-rx vc %d.%d.\n",
-             card->index, vpi, vci);
-      recycle_rx_buf(card, skb);
-      return;
-   }
-
-   vcc = vc->rx_vcc;
-
-   if (vcc->qos.aal == ATM_AAL0)
-   {
-      struct sk_buff *sb;
-      unsigned char *cell;
-      int i;
-
-      cell = skb->data;
-      for (i = ns_rsqe_cellcount(rsqe); i; i--)
-      {
-         if ((sb = dev_alloc_skb(NS_SMSKBSIZE)) == NULL)
-         {
-            printk("nicstar%d: Can't allocate buffers for aal0.\n",
-                   card->index);
-            atomic_add(i,&vcc->stats->rx_drop);
-            break;
-         }
-         if (!atm_charge(vcc, sb->truesize))
-         {
-            RXPRINTK("nicstar%d: atm_charge() dropped aal0 packets.\n",
-                     card->index);
-            atomic_add(i-1,&vcc->stats->rx_drop); /* already increased by 1 */
-            dev_kfree_skb_any(sb);
-            break;
-         }
-         /* Rebuild the header */
-         *((u32 *) sb->data) = le32_to_cpu(rsqe->word_1) << 4 |
-                               (ns_rsqe_clp(rsqe) ? 0x00000001 : 0x00000000);
-         if (i == 1 && ns_rsqe_eopdu(rsqe))
-            *((u32 *) sb->data) |= 0x00000002;
-         skb_put(sb, NS_AAL0_HEADER);
-         memcpy(skb_tail_pointer(sb), cell, ATM_CELL_PAYLOAD);
-         skb_put(sb, ATM_CELL_PAYLOAD);
-         ATM_SKB(sb)->vcc = vcc;
-	 __net_timestamp(sb);
-         vcc->push(vcc, sb);
-         atomic_inc(&vcc->stats->rx);
-         cell += ATM_CELL_PAYLOAD;
-      }
-
-      recycle_rx_buf(card, skb);
-      return;
-   }
-
-   /* To reach this point, the AAL layer can only be AAL5 */
-
-   if ((iovb = vc->rx_iov) == NULL)
-   {
-      iovb = skb_dequeue(&(card->iovpool.queue));
-      if (iovb == NULL)		/* No buffers in the queue */
-      {
-         iovb = alloc_skb(NS_IOVBUFSIZE, GFP_ATOMIC);
-	 if (iovb == NULL)
-	 {
-	    printk("nicstar%d: Out of iovec buffers.\n", card->index);
-            atomic_inc(&vcc->stats->rx_drop);
-            recycle_rx_buf(card, skb);
-            return;
-	 }
-         NS_SKB_CB(iovb)->buf_type = BUF_NONE;
-      }
-      else
-         if (--card->iovpool.count < card->iovnr.min)
-	 {
-	    struct sk_buff *new_iovb;
-	    if ((new_iovb = alloc_skb(NS_IOVBUFSIZE, GFP_ATOMIC)) != NULL)
-	    {
-               NS_SKB_CB(iovb)->buf_type = BUF_NONE;
-               skb_queue_tail(&card->iovpool.queue, new_iovb);
-               card->iovpool.count++;
-	    }
-	 }
-      vc->rx_iov = iovb;
-      NS_SKB(iovb)->iovcnt = 0;
-      iovb->len = 0;
-      iovb->data = iovb->head;
-      skb_reset_tail_pointer(iovb);
-      NS_SKB(iovb)->vcc = vcc;
-      /* IMPORTANT: a pointer to the sk_buff containing the small or large
-                    buffer is stored as iovec base, NOT a pointer to the 
-	            small or large buffer itself. */
-   }
-   else if (NS_SKB(iovb)->iovcnt >= NS_MAX_IOVECS)
-   {
-      printk("nicstar%d: received too big AAL5 SDU.\n", card->index);
-      atomic_inc(&vcc->stats->rx_err);
-      recycle_iovec_rx_bufs(card, (struct iovec *) iovb->data, NS_MAX_IOVECS);
-      NS_SKB(iovb)->iovcnt = 0;
-      iovb->len = 0;
-      iovb->data = iovb->head;
-      skb_reset_tail_pointer(iovb);
-      NS_SKB(iovb)->vcc = vcc;
-   }
-   iov = &((struct iovec *) iovb->data)[NS_SKB(iovb)->iovcnt++];
-   iov->iov_base = (void *) skb;
-   iov->iov_len = ns_rsqe_cellcount(rsqe) * 48;
-   iovb->len += iov->iov_len;
-
-   if (NS_SKB(iovb)->iovcnt == 1)
-   {
-      if (NS_SKB_CB(skb)->buf_type != BUF_SM)
-      {
-         printk("nicstar%d: Expected a small buffer, and this is not one.\n",
-	        card->index);
-         which_list(card, skb);
-         atomic_inc(&vcc->stats->rx_err);
-         recycle_rx_buf(card, skb);
-         vc->rx_iov = NULL;
-         recycle_iov_buf(card, iovb);
-         return;
-      }
-   }
-   else /* NS_SKB(iovb)->iovcnt >= 2 */
-   {
-      if (NS_SKB_CB(skb)->buf_type != BUF_LG)
-      {
-         printk("nicstar%d: Expected a large buffer, and this is not one.\n",
-	        card->index);
-         which_list(card, skb);
-         atomic_inc(&vcc->stats->rx_err);
-         recycle_iovec_rx_bufs(card, (struct iovec *) iovb->data,
-	                       NS_SKB(iovb)->iovcnt);
-         vc->rx_iov = NULL;
-         recycle_iov_buf(card, iovb);
-	 return;
-      }
-   }
-
-   if (ns_rsqe_eopdu(rsqe))
-   {
-      /* This works correctly regardless of the endianness of the host */
-      unsigned char *L1L2 = (unsigned char *)((u32)skb->data +
-                                              iov->iov_len - 6);
-      aal5_len = L1L2[0] << 8 | L1L2[1];
-      len = (aal5_len == 0x0000) ? 0x10000 : aal5_len;
-      if (ns_rsqe_crcerr(rsqe) ||
-          len + 8 > iovb->len || len + (47 + 8) < iovb->len)
-      {
-         printk("nicstar%d: AAL5 CRC error", card->index);
-         if (len + 8 > iovb->len || len + (47 + 8) < iovb->len)
-            printk(" - PDU size mismatch.\n");
-         else
-            printk(".\n");
-         atomic_inc(&vcc->stats->rx_err);
-         recycle_iovec_rx_bufs(card, (struct iovec *) iovb->data,
-	   NS_SKB(iovb)->iovcnt);
-	 vc->rx_iov = NULL;
-         recycle_iov_buf(card, iovb);
-	 return;
-      }
-
-      /* By this point we (hopefully) have a complete SDU without errors. */
-
-      if (NS_SKB(iovb)->iovcnt == 1)	/* Just a small buffer */
-      {
-         /* skb points to a small buffer */
-         if (!atm_charge(vcc, skb->truesize))
-         {
-            push_rxbufs(card, skb);
-            atomic_inc(&vcc->stats->rx_drop);
-         }
-         else
-	 {
-            skb_put(skb, len);
-            dequeue_sm_buf(card, skb);
+	u32 vpi, vci;
+	vc_map *vc;
+	struct sk_buff *iovb;
+	struct iovec *iov;
+	struct atm_vcc *vcc;
+	struct sk_buff *skb;
+	unsigned short aal5_len;
+	int len;
+	u32 stat;
+
+	stat = readl(card->membase + STAT);
+	card->sbfqc = ns_stat_sfbqc_get(stat);
+	card->lbfqc = ns_stat_lfbqc_get(stat);
+
+	skb = (struct sk_buff *)le32_to_cpu(rsqe->buffer_handle);
+	vpi = ns_rsqe_vpi(rsqe);
+	vci = ns_rsqe_vci(rsqe);
+	if (vpi >= 1UL << card->vpibits || vci >= 1UL << card->vcibits) {
+		printk("nicstar%d: SDU received for out-of-range vc %d.%d.\n",
+		       card->index, vpi, vci);
+		recycle_rx_buf(card, skb);
+		return;
+	}
+
+	vc = &(card->vcmap[vpi << card->vcibits | vci]);
+	if (!vc->rx) {
+		RXPRINTK("nicstar%d: SDU received on non-rx vc %d.%d.\n",
+			 card->index, vpi, vci);
+		recycle_rx_buf(card, skb);
+		return;
+	}
+
+	vcc = vc->rx_vcc;
+
+	if (vcc->qos.aal == ATM_AAL0) {
+		struct sk_buff *sb;
+		unsigned char *cell;
+		int i;
+
+		cell = skb->data;
+		for (i = ns_rsqe_cellcount(rsqe); i; i--) {
+			if ((sb = dev_alloc_skb(NS_SMSKBSIZE)) == NULL) {
+				printk
+				    ("nicstar%d: Can't allocate buffers for aal0.\n",
+				     card->index);
+				atomic_add(i, &vcc->stats->rx_drop);
+				break;
+			}
+			if (!atm_charge(vcc, sb->truesize)) {
+				RXPRINTK
+				    ("nicstar%d: atm_charge() dropped aal0 packets.\n",
+				     card->index);
+				atomic_add(i - 1, &vcc->stats->rx_drop);	/* already increased by 1 */
+				dev_kfree_skb_any(sb);
+				break;
+			}
+			/* Rebuild the header */
+			*((u32 *) sb->data) = le32_to_cpu(rsqe->word_1) << 4 |
+			    (ns_rsqe_clp(rsqe) ? 0x00000001 : 0x00000000);
+			if (i == 1 && ns_rsqe_eopdu(rsqe))
+				*((u32 *) sb->data) |= 0x00000002;
+			skb_put(sb, NS_AAL0_HEADER);
+			memcpy(skb_tail_pointer(sb), cell, ATM_CELL_PAYLOAD);
+			skb_put(sb, ATM_CELL_PAYLOAD);
+			ATM_SKB(sb)->vcc = vcc;
+			__net_timestamp(sb);
+			vcc->push(vcc, sb);
+			atomic_inc(&vcc->stats->rx);
+			cell += ATM_CELL_PAYLOAD;
+		}
+
+		recycle_rx_buf(card, skb);
+		return;
+	}
+
+	/* To reach this point, the AAL layer can only be AAL5 */
+
+	if ((iovb = vc->rx_iov) == NULL) {
+		iovb = skb_dequeue(&(card->iovpool.queue));
+		if (iovb == NULL) {	/* No buffers in the queue */
+			iovb = alloc_skb(NS_IOVBUFSIZE, GFP_ATOMIC);
+			if (iovb == NULL) {
+				printk("nicstar%d: Out of iovec buffers.\n",
+				       card->index);
+				atomic_inc(&vcc->stats->rx_drop);
+				recycle_rx_buf(card, skb);
+				return;
+			}
+			NS_SKB_CB(iovb)->buf_type = BUF_NONE;
+		} else if (--card->iovpool.count < card->iovnr.min) {
+			struct sk_buff *new_iovb;
+			if ((new_iovb =
+			     alloc_skb(NS_IOVBUFSIZE, GFP_ATOMIC)) != NULL) {
+				NS_SKB_CB(iovb)->buf_type = BUF_NONE;
+				skb_queue_tail(&card->iovpool.queue, new_iovb);
+				card->iovpool.count++;
+			}
+		}
+		vc->rx_iov = iovb;
+		NS_SKB(iovb)->iovcnt = 0;
+		iovb->len = 0;
+		iovb->data = iovb->head;
+		skb_reset_tail_pointer(iovb);
+		NS_SKB(iovb)->vcc = vcc;
+		/* IMPORTANT: a pointer to the sk_buff containing the small or large
+		   buffer is stored as iovec base, NOT a pointer to the
+		   small or large buffer itself. */
+	} else if (NS_SKB(iovb)->iovcnt >= NS_MAX_IOVECS) {
+		printk("nicstar%d: received too big AAL5 SDU.\n", card->index);
+		atomic_inc(&vcc->stats->rx_err);
+		recycle_iovec_rx_bufs(card, (struct iovec *)iovb->data,
+				      NS_MAX_IOVECS);
+		NS_SKB(iovb)->iovcnt = 0;
+		iovb->len = 0;
+		iovb->data = iovb->head;
+		skb_reset_tail_pointer(iovb);
+		NS_SKB(iovb)->vcc = vcc;
+	}
+	iov = &((struct iovec *)iovb->data)[NS_SKB(iovb)->iovcnt++];
+	iov->iov_base = (void *)skb;
+	iov->iov_len = ns_rsqe_cellcount(rsqe) * 48;
+	iovb->len += iov->iov_len;
+
+	if (NS_SKB(iovb)->iovcnt == 1) {
+		if (NS_SKB_CB(skb)->buf_type != BUF_SM) {
+			printk
+			    ("nicstar%d: Expected a small buffer, and this is not one.\n",
+			     card->index);
+			which_list(card, skb);
+			atomic_inc(&vcc->stats->rx_err);
+			recycle_rx_buf(card, skb);
+			vc->rx_iov = NULL;
+			recycle_iov_buf(card, iovb);
+			return;
+		}
+	} else {		/* NS_SKB(iovb)->iovcnt >= 2 */
+
+		if (NS_SKB_CB(skb)->buf_type != BUF_LG) {
+			printk
+			    ("nicstar%d: Expected a large buffer, and this is not one.\n",
+			     card->index);
+			which_list(card, skb);
+			atomic_inc(&vcc->stats->rx_err);
+			recycle_iovec_rx_bufs(card, (struct iovec *)iovb->data,
+					      NS_SKB(iovb)->iovcnt);
+			vc->rx_iov = NULL;
+			recycle_iov_buf(card, iovb);
+			return;
+		}
+	}
+
+	if (ns_rsqe_eopdu(rsqe)) {
+		/* This works correctly regardless of the endianness of the host */
+		unsigned char *L1L2 = (unsigned char *)((u32) skb->data +
+							iov->iov_len - 6);
+		aal5_len = L1L2[0] << 8 | L1L2[1];
+		len = (aal5_len == 0x0000) ? 0x10000 : aal5_len;
+		if (ns_rsqe_crcerr(rsqe) ||
+		    len + 8 > iovb->len || len + (47 + 8) < iovb->len) {
+			printk("nicstar%d: AAL5 CRC error", card->index);
+			if (len + 8 > iovb->len || len + (47 + 8) < iovb->len)
+				printk(" - PDU size mismatch.\n");
+			else
+				printk(".\n");
+			atomic_inc(&vcc->stats->rx_err);
+			recycle_iovec_rx_bufs(card, (struct iovec *)iovb->data,
+					      NS_SKB(iovb)->iovcnt);
+			vc->rx_iov = NULL;
+			recycle_iov_buf(card, iovb);
+			return;
+		}
+
+		/* By this point we (hopefully) have a complete SDU without errors. */
+
+		if (NS_SKB(iovb)->iovcnt == 1) {	/* Just a small buffer */
+			/* skb points to a small buffer */
+			if (!atm_charge(vcc, skb->truesize)) {
+				push_rxbufs(card, skb);
+				atomic_inc(&vcc->stats->rx_drop);
+			} else {
+				skb_put(skb, len);
+				dequeue_sm_buf(card, skb);
 #ifdef NS_USE_DESTRUCTORS
-            skb->destructor = ns_sb_destructor;
+				skb->destructor = ns_sb_destructor;
 #endif /* NS_USE_DESTRUCTORS */
-            ATM_SKB(skb)->vcc = vcc;
-	    __net_timestamp(skb);
-            vcc->push(vcc, skb);
-            atomic_inc(&vcc->stats->rx);
-         }
-      }
-      else if (NS_SKB(iovb)->iovcnt == 2)	/* One small plus one large buffer */
-      {
-         struct sk_buff *sb;
-
-         sb = (struct sk_buff *) (iov - 1)->iov_base;
-         /* skb points to a large buffer */
-
-         if (len <= NS_SMBUFSIZE)
-	 {
-            if (!atm_charge(vcc, sb->truesize))
-            {
-               push_rxbufs(card, sb);
-               atomic_inc(&vcc->stats->rx_drop);
-            }
-            else
-	    {
-               skb_put(sb, len);
-               dequeue_sm_buf(card, sb);
+				ATM_SKB(skb)->vcc = vcc;
+				__net_timestamp(skb);
+				vcc->push(vcc, skb);
+				atomic_inc(&vcc->stats->rx);
+			}
+		} else if (NS_SKB(iovb)->iovcnt == 2) {	/* One small plus one large buffer */
+			struct sk_buff *sb;
+
+			sb = (struct sk_buff *)(iov - 1)->iov_base;
+			/* skb points to a large buffer */
+
+			if (len <= NS_SMBUFSIZE) {
+				if (!atm_charge(vcc, sb->truesize)) {
+					push_rxbufs(card, sb);
+					atomic_inc(&vcc->stats->rx_drop);
+				} else {
+					skb_put(sb, len);
+					dequeue_sm_buf(card, sb);
 #ifdef NS_USE_DESTRUCTORS
-               sb->destructor = ns_sb_destructor;
+					sb->destructor = ns_sb_destructor;
 #endif /* NS_USE_DESTRUCTORS */
-               ATM_SKB(sb)->vcc = vcc;
-	       __net_timestamp(sb);
-               vcc->push(vcc, sb);
-               atomic_inc(&vcc->stats->rx);
-            }
-
-            push_rxbufs(card, skb);
-
-	 }
-	 else			/* len > NS_SMBUFSIZE, the usual case */
-	 {
-            if (!atm_charge(vcc, skb->truesize))
-            {
-               push_rxbufs(card, skb);
-               atomic_inc(&vcc->stats->rx_drop);
-            }
-            else
-            {
-               dequeue_lg_buf(card, skb);
+					ATM_SKB(sb)->vcc = vcc;
+					__net_timestamp(sb);
+					vcc->push(vcc, sb);
+					atomic_inc(&vcc->stats->rx);
+				}
+
+				push_rxbufs(card, skb);
+
+			} else {	/* len > NS_SMBUFSIZE, the usual case */
+
+				if (!atm_charge(vcc, skb->truesize)) {
+					push_rxbufs(card, skb);
+					atomic_inc(&vcc->stats->rx_drop);
+				} else {
+					dequeue_lg_buf(card, skb);
 #ifdef NS_USE_DESTRUCTORS
-               skb->destructor = ns_lb_destructor;
+					skb->destructor = ns_lb_destructor;
 #endif /* NS_USE_DESTRUCTORS */
-               skb_push(skb, NS_SMBUFSIZE);
-               skb_copy_from_linear_data(sb, skb->data, NS_SMBUFSIZE);
-               skb_put(skb, len - NS_SMBUFSIZE);
-               ATM_SKB(skb)->vcc = vcc;
-	       __net_timestamp(skb);
-               vcc->push(vcc, skb);
-               atomic_inc(&vcc->stats->rx);
-            }
-
-            push_rxbufs(card, sb);
-
-         }
-	 
-      }
-      else				/* Must push a huge buffer */
-      {
-         struct sk_buff *hb, *sb, *lb;
-	 int remaining, tocopy;
-         int j;
-
-         hb = skb_dequeue(&(card->hbpool.queue));
-         if (hb == NULL)		/* No buffers in the queue */
-         {
-
-            hb = dev_alloc_skb(NS_HBUFSIZE);
-            if (hb == NULL)
-            {
-               printk("nicstar%d: Out of huge buffers.\n", card->index);
-               atomic_inc(&vcc->stats->rx_drop);
-               recycle_iovec_rx_bufs(card, (struct iovec *) iovb->data,
-	                             NS_SKB(iovb)->iovcnt);
-               vc->rx_iov = NULL;
-               recycle_iov_buf(card, iovb);
-               return;
-            }
-            else if (card->hbpool.count < card->hbnr.min)
-	    {
-               struct sk_buff *new_hb;
-               if ((new_hb = dev_alloc_skb(NS_HBUFSIZE)) != NULL)
-               {
-                  skb_queue_tail(&card->hbpool.queue, new_hb);
-                  card->hbpool.count++;
-               }
-            }
-            NS_SKB_CB(hb)->buf_type = BUF_NONE;
-	 }
-	 else
-         if (--card->hbpool.count < card->hbnr.min)
-         {
-            struct sk_buff *new_hb;
-            if ((new_hb = dev_alloc_skb(NS_HBUFSIZE)) != NULL)
-            {
-               NS_SKB_CB(new_hb)->buf_type = BUF_NONE;
-               skb_queue_tail(&card->hbpool.queue, new_hb);
-               card->hbpool.count++;
-            }
-            if (card->hbpool.count < card->hbnr.min)
-	    {
-               if ((new_hb = dev_alloc_skb(NS_HBUFSIZE)) != NULL)
-               {
-                  NS_SKB_CB(new_hb)->buf_type = BUF_NONE;
-                  skb_queue_tail(&card->hbpool.queue, new_hb);
-                  card->hbpool.count++;
-               }
-            }
-         }
-
-         iov = (struct iovec *) iovb->data;
-
-         if (!atm_charge(vcc, hb->truesize))
-	 {
-            recycle_iovec_rx_bufs(card, iov, NS_SKB(iovb)->iovcnt);
-            if (card->hbpool.count < card->hbnr.max)
-            {
-               skb_queue_tail(&card->hbpool.queue, hb);
-               card->hbpool.count++;
-            }
-	    else
-	       dev_kfree_skb_any(hb);
-	    atomic_inc(&vcc->stats->rx_drop);
-         }
-         else
-	 {
-            /* Copy the small buffer to the huge buffer */
-            sb = (struct sk_buff *) iov->iov_base;
-            skb_copy_from_linear_data(sb, hb->data, iov->iov_len);
-            skb_put(hb, iov->iov_len);
-            remaining = len - iov->iov_len;
-            iov++;
-            /* Free the small buffer */
-            push_rxbufs(card, sb);
-
-            /* Copy all large buffers to the huge buffer and free them */
-            for (j = 1; j < NS_SKB(iovb)->iovcnt; j++)
-            {
-               lb = (struct sk_buff *) iov->iov_base;
-               tocopy = min_t(int, remaining, iov->iov_len);
-               skb_copy_from_linear_data(lb, skb_tail_pointer(hb), tocopy);
-               skb_put(hb, tocopy);
-               iov++;
-               remaining -= tocopy;
-               push_rxbufs(card, lb);
-            }
+					skb_push(skb, NS_SMBUFSIZE);
+					skb_copy_from_linear_data(sb, skb->data,
+								  NS_SMBUFSIZE);
+					skb_put(skb, len - NS_SMBUFSIZE);
+					ATM_SKB(skb)->vcc = vcc;
+					__net_timestamp(skb);
+					vcc->push(vcc, skb);
+					atomic_inc(&vcc->stats->rx);
+				}
+
+				push_rxbufs(card, sb);
+
+			}
+
+		} else {	/* Must push a huge buffer */
+
+			struct sk_buff *hb, *sb, *lb;
+			int remaining, tocopy;
+			int j;
+
+			hb = skb_dequeue(&(card->hbpool.queue));
+			if (hb == NULL) {	/* No buffers in the queue */
+
+				hb = dev_alloc_skb(NS_HBUFSIZE);
+				if (hb == NULL) {
+					printk
+					    ("nicstar%d: Out of huge buffers.\n",
+					     card->index);
+					atomic_inc(&vcc->stats->rx_drop);
+					recycle_iovec_rx_bufs(card,
+							      (struct iovec *)
+							      iovb->data,
+							      NS_SKB(iovb)->
+							      iovcnt);
+					vc->rx_iov = NULL;
+					recycle_iov_buf(card, iovb);
+					return;
+				} else if (card->hbpool.count < card->hbnr.min) {
+					struct sk_buff *new_hb;
+					if ((new_hb =
+					     dev_alloc_skb(NS_HBUFSIZE)) !=
+					    NULL) {
+						skb_queue_tail(&card->hbpool.
+							       queue, new_hb);
+						card->hbpool.count++;
+					}
+				}
+				NS_SKB_CB(hb)->buf_type = BUF_NONE;
+			} else if (--card->hbpool.count < card->hbnr.min) {
+				struct sk_buff *new_hb;
+				if ((new_hb =
+				     dev_alloc_skb(NS_HBUFSIZE)) != NULL) {
+					NS_SKB_CB(new_hb)->buf_type = BUF_NONE;
+					skb_queue_tail(&card->hbpool.queue,
+						       new_hb);
+					card->hbpool.count++;
+				}
+				if (card->hbpool.count < card->hbnr.min) {
+					if ((new_hb =
+					     dev_alloc_skb(NS_HBUFSIZE)) !=
+					    NULL) {
+						NS_SKB_CB(new_hb)->buf_type =
+						    BUF_NONE;
+						skb_queue_tail(&card->hbpool.
+							       queue, new_hb);
+						card->hbpool.count++;
+					}
+				}
+			}
+
+			iov = (struct iovec *)iovb->data;
+
+			if (!atm_charge(vcc, hb->truesize)) {
+				recycle_iovec_rx_bufs(card, iov,
+						      NS_SKB(iovb)->iovcnt);
+				if (card->hbpool.count < card->hbnr.max) {
+					skb_queue_tail(&card->hbpool.queue, hb);
+					card->hbpool.count++;
+				} else
+					dev_kfree_skb_any(hb);
+				atomic_inc(&vcc->stats->rx_drop);
+			} else {
+				/* Copy the small buffer to the huge buffer */
+				sb = (struct sk_buff *)iov->iov_base;
+				skb_copy_from_linear_data(sb, hb->data,
+							  iov->iov_len);
+				skb_put(hb, iov->iov_len);
+				remaining = len - iov->iov_len;
+				iov++;
+				/* Free the small buffer */
+				push_rxbufs(card, sb);
+
+				/* Copy all large buffers to the huge buffer and free them */
+				for (j = 1; j < NS_SKB(iovb)->iovcnt; j++) {
+					lb = (struct sk_buff *)iov->iov_base;
+					tocopy =
+					    min_t(int, remaining, iov->iov_len);
+					skb_copy_from_linear_data(lb,
+								  skb_tail_pointer
+								  (hb), tocopy);
+					skb_put(hb, tocopy);
+					iov++;
+					remaining -= tocopy;
+					push_rxbufs(card, lb);
+				}
 #ifdef EXTRA_DEBUG
-            if (remaining != 0 || hb->len != len)
-               printk("nicstar%d: Huge buffer len mismatch.\n", card->index);
+				if (remaining != 0 || hb->len != len)
+					printk
+					    ("nicstar%d: Huge buffer len mismatch.\n",
+					     card->index);
 #endif /* EXTRA_DEBUG */
-            ATM_SKB(hb)->vcc = vcc;
+				ATM_SKB(hb)->vcc = vcc;
 #ifdef NS_USE_DESTRUCTORS
-            hb->destructor = ns_hb_destructor;
+				hb->destructor = ns_hb_destructor;
 #endif /* NS_USE_DESTRUCTORS */
-	    __net_timestamp(hb);
-            vcc->push(vcc, hb);
-            atomic_inc(&vcc->stats->rx);
-         }
-      }
+				__net_timestamp(hb);
+				vcc->push(vcc, hb);
+				atomic_inc(&vcc->stats->rx);
+			}
+		}
 
-      vc->rx_iov = NULL;
-      recycle_iov_buf(card, iovb);
-   }
+		vc->rx_iov = NULL;
+		recycle_iov_buf(card, iovb);
+	}
 
 }
 
-
-
 #ifdef NS_USE_DESTRUCTORS
 
 static void ns_sb_destructor(struct sk_buff *sb)
 {
-   ns_dev *card;
-   u32 stat;
-
-   card = (ns_dev *) ATM_SKB(sb)->vcc->dev->dev_data;
-   stat = readl(card->membase + STAT);
-   card->sbfqc = ns_stat_sfbqc_get(stat);   
-   card->lbfqc = ns_stat_lfbqc_get(stat);
-
-   do
-   {
-      sb = __dev_alloc_skb(NS_SMSKBSIZE, GFP_KERNEL);
-      if (sb == NULL)
-         break;
-      NS_SKB_CB(sb)->buf_type = BUF_SM;
-      skb_queue_tail(&card->sbpool.queue, sb);
-      skb_reserve(sb, NS_AAL0_HEADER);
-      push_rxbufs(card, sb);
-   } while (card->sbfqc < card->sbnr.min);
+	ns_dev *card;
+	u32 stat;
+
+	card = (ns_dev *) ATM_SKB(sb)->vcc->dev->dev_data;
+	stat = readl(card->membase + STAT);
+	card->sbfqc = ns_stat_sfbqc_get(stat);
+	card->lbfqc = ns_stat_lfbqc_get(stat);
+
+	do {
+		sb = __dev_alloc_skb(NS_SMSKBSIZE, GFP_KERNEL);
+		if (sb == NULL)
+			break;
+		NS_SKB_CB(sb)->buf_type = BUF_SM;
+		skb_queue_tail(&card->sbpool.queue, sb);
+		skb_reserve(sb, NS_AAL0_HEADER);
+		push_rxbufs(card, sb);
+	} while (card->sbfqc < card->sbnr.min);
 }
 
-
-
 static void ns_lb_destructor(struct sk_buff *lb)
 {
-   ns_dev *card;
-   u32 stat;
-
-   card = (ns_dev *) ATM_SKB(lb)->vcc->dev->dev_data;
-   stat = readl(card->membase + STAT);
-   card->sbfqc = ns_stat_sfbqc_get(stat);   
-   card->lbfqc = ns_stat_lfbqc_get(stat);
-
-   do
-   {
-      lb = __dev_alloc_skb(NS_LGSKBSIZE, GFP_KERNEL);
-      if (lb == NULL)
-         break;
-      NS_SKB_CB(lb)->buf_type = BUF_LG;
-      skb_queue_tail(&card->lbpool.queue, lb);
-      skb_reserve(lb, NS_SMBUFSIZE);
-      push_rxbufs(card, lb);
-   } while (card->lbfqc < card->lbnr.min);
+	ns_dev *card;
+	u32 stat;
+
+	card = (ns_dev *) ATM_SKB(lb)->vcc->dev->dev_data;
+	stat = readl(card->membase + STAT);
+	card->sbfqc = ns_stat_sfbqc_get(stat);
+	card->lbfqc = ns_stat_lfbqc_get(stat);
+
+	do {
+		lb = __dev_alloc_skb(NS_LGSKBSIZE, GFP_KERNEL);
+		if (lb == NULL)
+			break;
+		NS_SKB_CB(lb)->buf_type = BUF_LG;
+		skb_queue_tail(&card->lbpool.queue, lb);
+		skb_reserve(lb, NS_SMBUFSIZE);
+		push_rxbufs(card, lb);
+	} while (card->lbfqc < card->lbnr.min);
 }
 
-
-
 static void ns_hb_destructor(struct sk_buff *hb)
 {
-   ns_dev *card;
-
-   card = (ns_dev *) ATM_SKB(hb)->vcc->dev->dev_data;
-
-   while (card->hbpool.count < card->hbnr.init)
-   {
-      hb = __dev_alloc_skb(NS_HBUFSIZE, GFP_KERNEL);
-      if (hb == NULL)
-         break;
-      NS_SKB_CB(hb)->buf_type = BUF_NONE;
-      skb_queue_tail(&card->hbpool.queue, hb);
-      card->hbpool.count++;
-   }
+	ns_dev *card;
+
+	card = (ns_dev *) ATM_SKB(hb)->vcc->dev->dev_data;
+
+	while (card->hbpool.count < card->hbnr.init) {
+		hb = __dev_alloc_skb(NS_HBUFSIZE, GFP_KERNEL);
+		if (hb == NULL)
+			break;
+		NS_SKB_CB(hb)->buf_type = BUF_NONE;
+		skb_queue_tail(&card->hbpool.queue, hb);
+		card->hbpool.count++;
+	}
 }
 
 #endif /* NS_USE_DESTRUCTORS */
 
-
-static void recycle_rx_buf(ns_dev *card, struct sk_buff *skb)
+static void recycle_rx_buf(ns_dev * card, struct sk_buff *skb)
 {
 	struct ns_skb_cb *cb = NS_SKB_CB(skb);
 
 	if (unlikely(cb->buf_type == BUF_NONE)) {
-		printk("nicstar%d: What kind of rx buffer is this?\n", card->index);
+		printk("nicstar%d: What kind of rx buffer is this?\n",
+		       card->index);
 		dev_kfree_skb_any(skb);
 	} else
 		push_rxbufs(card, skb);
 }
 
-
-static void recycle_iovec_rx_bufs(ns_dev *card, struct iovec *iov, int count)
+static void recycle_iovec_rx_bufs(ns_dev * card, struct iovec *iov, int count)
 {
 	while (count-- > 0)
-		recycle_rx_buf(card, (struct sk_buff *) (iov++)->iov_base);
+		recycle_rx_buf(card, (struct sk_buff *)(iov++)->iov_base);
 }
 
-
-static void recycle_iov_buf(ns_dev *card, struct sk_buff *iovb)
+static void recycle_iov_buf(ns_dev * card, struct sk_buff *iovb)
 {
-   if (card->iovpool.count < card->iovnr.max)
-   {
-      skb_queue_tail(&card->iovpool.queue, iovb);
-      card->iovpool.count++;
-   }
-   else
-      dev_kfree_skb_any(iovb);
+	if (card->iovpool.count < card->iovnr.max) {
+		skb_queue_tail(&card->iovpool.queue, iovb);
+		card->iovpool.count++;
+	} else
+		dev_kfree_skb_any(iovb);
 }
 
-
-
-static void dequeue_sm_buf(ns_dev *card, struct sk_buff *sb)
+static void dequeue_sm_buf(ns_dev * card, struct sk_buff *sb)
 {
-   skb_unlink(sb, &card->sbpool.queue);
+	skb_unlink(sb, &card->sbpool.queue);
 #ifdef NS_USE_DESTRUCTORS
-   if (card->sbfqc < card->sbnr.min)
+	if (card->sbfqc < card->sbnr.min)
 #else
-   if (card->sbfqc < card->sbnr.init)
-   {
-      struct sk_buff *new_sb;
-      if ((new_sb = dev_alloc_skb(NS_SMSKBSIZE)) != NULL)
-      {
-         NS_SKB_CB(new_sb)->buf_type = BUF_SM;
-         skb_queue_tail(&card->sbpool.queue, new_sb);
-         skb_reserve(new_sb, NS_AAL0_HEADER);
-         push_rxbufs(card, new_sb);
-      }
-   }
-   if (card->sbfqc < card->sbnr.init)
+	if (card->sbfqc < card->sbnr.init) {
+		struct sk_buff *new_sb;
+		if ((new_sb = dev_alloc_skb(NS_SMSKBSIZE)) != NULL) {
+			NS_SKB_CB(new_sb)->buf_type = BUF_SM;
+			skb_queue_tail(&card->sbpool.queue, new_sb);
+			skb_reserve(new_sb, NS_AAL0_HEADER);
+			push_rxbufs(card, new_sb);
+		}
+	}
+	if (card->sbfqc < card->sbnr.init)
 #endif /* NS_USE_DESTRUCTORS */
-   {
-      struct sk_buff *new_sb;
-      if ((new_sb = dev_alloc_skb(NS_SMSKBSIZE)) != NULL)
-      {
-         NS_SKB_CB(new_sb)->buf_type = BUF_SM;
-         skb_queue_tail(&card->sbpool.queue, new_sb);
-         skb_reserve(new_sb, NS_AAL0_HEADER);
-         push_rxbufs(card, new_sb);
-      }
-   }
+	{
+		struct sk_buff *new_sb;
+		if ((new_sb = dev_alloc_skb(NS_SMSKBSIZE)) != NULL) {
+			NS_SKB_CB(new_sb)->buf_type = BUF_SM;
+			skb_queue_tail(&card->sbpool.queue, new_sb);
+			skb_reserve(new_sb, NS_AAL0_HEADER);
+			push_rxbufs(card, new_sb);
+		}
+	}
 }
 
-
-
-static void dequeue_lg_buf(ns_dev *card, struct sk_buff *lb)
+static void dequeue_lg_buf(ns_dev * card, struct sk_buff *lb)
 {
-   skb_unlink(lb, &card->lbpool.queue);
+	skb_unlink(lb, &card->lbpool.queue);
 #ifdef NS_USE_DESTRUCTORS
-   if (card->lbfqc < card->lbnr.min)
+	if (card->lbfqc < card->lbnr.min)
 #else
-   if (card->lbfqc < card->lbnr.init)
-   {
-      struct sk_buff *new_lb;
-      if ((new_lb = dev_alloc_skb(NS_LGSKBSIZE)) != NULL)
-      {
-         NS_SKB_CB(new_lb)->buf_type = BUF_LG;
-         skb_queue_tail(&card->lbpool.queue, new_lb);
-         skb_reserve(new_lb, NS_SMBUFSIZE);
-         push_rxbufs(card, new_lb);
-      }
-   }
-   if (card->lbfqc < card->lbnr.init)
+	if (card->lbfqc < card->lbnr.init) {
+		struct sk_buff *new_lb;
+		if ((new_lb = dev_alloc_skb(NS_LGSKBSIZE)) != NULL) {
+			NS_SKB_CB(new_lb)->buf_type = BUF_LG;
+			skb_queue_tail(&card->lbpool.queue, new_lb);
+			skb_reserve(new_lb, NS_SMBUFSIZE);
+			push_rxbufs(card, new_lb);
+		}
+	}
+	if (card->lbfqc < card->lbnr.init)
 #endif /* NS_USE_DESTRUCTORS */
-   {
-      struct sk_buff *new_lb;
-      if ((new_lb = dev_alloc_skb(NS_LGSKBSIZE)) != NULL)
-      {
-         NS_SKB_CB(new_lb)->buf_type = BUF_LG;
-         skb_queue_tail(&card->lbpool.queue, new_lb);
-         skb_reserve(new_lb, NS_SMBUFSIZE);
-         push_rxbufs(card, new_lb);
-      }
-   }
+	{
+		struct sk_buff *new_lb;
+		if ((new_lb = dev_alloc_skb(NS_LGSKBSIZE)) != NULL) {
+			NS_SKB_CB(new_lb)->buf_type = BUF_LG;
+			skb_queue_tail(&card->lbpool.queue, new_lb);
+			skb_reserve(new_lb, NS_SMBUFSIZE);
+			push_rxbufs(card, new_lb);
+		}
+	}
 }
 
-
-
-static int ns_proc_read(struct atm_dev *dev, loff_t *pos, char *page)
+static int ns_proc_read(struct atm_dev *dev, loff_t * pos, char *page)
 {
-   u32 stat;
-   ns_dev *card;
-   int left;
-
-   left = (int) *pos;
-   card = (ns_dev *) dev->dev_data;
-   stat = readl(card->membase + STAT);
-   if (!left--)
-      return sprintf(page, "Pool   count    min   init    max \n");
-   if (!left--)
-      return sprintf(page, "Small  %5d  %5d  %5d  %5d \n",
-                     ns_stat_sfbqc_get(stat), card->sbnr.min, card->sbnr.init,
-		     card->sbnr.max);
-   if (!left--)
-      return sprintf(page, "Large  %5d  %5d  %5d  %5d \n",
-                     ns_stat_lfbqc_get(stat), card->lbnr.min, card->lbnr.init,
-		     card->lbnr.max);
-   if (!left--)
-      return sprintf(page, "Huge   %5d  %5d  %5d  %5d \n", card->hbpool.count,
-                     card->hbnr.min, card->hbnr.init, card->hbnr.max);
-   if (!left--)
-      return sprintf(page, "Iovec  %5d  %5d  %5d  %5d \n", card->iovpool.count,
-                     card->iovnr.min, card->iovnr.init, card->iovnr.max);
-   if (!left--)
-   {
-      int retval;
-      retval = sprintf(page, "Interrupt counter: %u \n", card->intcnt);
-      card->intcnt = 0;
-      return retval;
-   }
+	u32 stat;
+	ns_dev *card;
+	int left;
+
+	left = (int)*pos;
+	card = (ns_dev *) dev->dev_data;
+	stat = readl(card->membase + STAT);
+	if (!left--)
+		return sprintf(page, "Pool   count    min   init    max \n");
+	if (!left--)
+		return sprintf(page, "Small  %5d  %5d  %5d  %5d \n",
+			       ns_stat_sfbqc_get(stat), card->sbnr.min,
+			       card->sbnr.init, card->sbnr.max);
+	if (!left--)
+		return sprintf(page, "Large  %5d  %5d  %5d  %5d \n",
+			       ns_stat_lfbqc_get(stat), card->lbnr.min,
+			       card->lbnr.init, card->lbnr.max);
+	if (!left--)
+		return sprintf(page, "Huge   %5d  %5d  %5d  %5d \n",
+			       card->hbpool.count, card->hbnr.min,
+			       card->hbnr.init, card->hbnr.max);
+	if (!left--)
+		return sprintf(page, "Iovec  %5d  %5d  %5d  %5d \n",
+			       card->iovpool.count, card->iovnr.min,
+			       card->iovnr.init, card->iovnr.max);
+	if (!left--) {
+		int retval;
+		retval =
+		    sprintf(page, "Interrupt counter: %u \n", card->intcnt);
+		card->intcnt = 0;
+		return retval;
+	}
 #if 0
-   /* Dump 25.6 Mbps PHY registers */
-   /* Now there's a 25.6 Mbps PHY driver this code isn't needed. I left it
-      here just in case it's needed for debugging. */
-   if (card->max_pcr == ATM_25_PCR && !left--)
-   {
-      u32 phy_regs[4];
-      u32 i;
-
-      for (i = 0; i < 4; i++)
-      {
-         while (CMD_BUSY(card));
-         writel(NS_CMD_READ_UTILITY | 0x00000200 | i, card->membase + CMD);
-         while (CMD_BUSY(card));
-         phy_regs[i] = readl(card->membase + DR0) & 0x000000FF;
-      }
-
-      return sprintf(page, "PHY regs: 0x%02X 0x%02X 0x%02X 0x%02X \n",
-                     phy_regs[0], phy_regs[1], phy_regs[2], phy_regs[3]);
-   }
+	/* Dump 25.6 Mbps PHY registers */
+	/* Now there's a 25.6 Mbps PHY driver this code isn't needed. I left it
+	   here just in case it's needed for debugging. */
+	if (card->max_pcr == ATM_25_PCR && !left--) {
+		u32 phy_regs[4];
+		u32 i;
+
+		for (i = 0; i < 4; i++) {
+			while (CMD_BUSY(card)) ;
+			writel(NS_CMD_READ_UTILITY | 0x00000200 | i,
+			       card->membase + CMD);
+			while (CMD_BUSY(card)) ;
+			phy_regs[i] = readl(card->membase + DR0) & 0x000000FF;
+		}
+
+		return sprintf(page, "PHY regs: 0x%02X 0x%02X 0x%02X 0x%02X \n",
+			       phy_regs[0], phy_regs[1], phy_regs[2],
+			       phy_regs[3]);
+	}
 #endif /* 0 - Dump 25.6 Mbps PHY registers */
 #if 0
-   /* Dump TST */
-   if (left-- < NS_TST_NUM_ENTRIES)
-   {
-      if (card->tste2vc[left + 1] == NULL)
-         return sprintf(page, "%5d - VBR/UBR \n", left + 1);
-      else
-         return sprintf(page, "%5d - %d %d \n", left + 1,
-                        card->tste2vc[left + 1]->tx_vcc->vpi,
-                        card->tste2vc[left + 1]->tx_vcc->vci);
-   }
+	/* Dump TST */
+	if (left-- < NS_TST_NUM_ENTRIES) {
+		if (card->tste2vc[left + 1] == NULL)
+			return sprintf(page, "%5d - VBR/UBR \n", left + 1);
+		else
+			return sprintf(page, "%5d - %d %d \n", left + 1,
+				       card->tste2vc[left + 1]->tx_vcc->vpi,
+				       card->tste2vc[left + 1]->tx_vcc->vci);
+	}
 #endif /* 0 */
-   return 0;
+	return 0;
 }
 
-
-
-static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)
+static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user * arg)
 {
-   ns_dev *card;
-   pool_levels pl;
-   long btype;
-   unsigned long flags;
-
-   card = dev->dev_data;
-   switch (cmd)
-   {
-      case NS_GETPSTAT:
-         if (get_user(pl.buftype, &((pool_levels __user *) arg)->buftype))
-	    return -EFAULT;
-         switch (pl.buftype)
-	 {
-	    case NS_BUFTYPE_SMALL:
-	       pl.count = ns_stat_sfbqc_get(readl(card->membase + STAT));
-	       pl.level.min = card->sbnr.min;
-	       pl.level.init = card->sbnr.init;
-	       pl.level.max = card->sbnr.max;
-	       break;
-
-	    case NS_BUFTYPE_LARGE:
-	       pl.count = ns_stat_lfbqc_get(readl(card->membase + STAT));
-	       pl.level.min = card->lbnr.min;
-	       pl.level.init = card->lbnr.init;
-	       pl.level.max = card->lbnr.max;
-	       break;
-
-	    case NS_BUFTYPE_HUGE:
-	       pl.count = card->hbpool.count;
-	       pl.level.min = card->hbnr.min;
-	       pl.level.init = card->hbnr.init;
-	       pl.level.max = card->hbnr.max;
-	       break;
-
-	    case NS_BUFTYPE_IOVEC:
-	       pl.count = card->iovpool.count;
-	       pl.level.min = card->iovnr.min;
-	       pl.level.init = card->iovnr.init;
-	       pl.level.max = card->iovnr.max;
-	       break;
-
-            default:
-	       return -ENOIOCTLCMD;
-
-	 }
-         if (!copy_to_user((pool_levels __user *) arg, &pl, sizeof(pl)))
-	    return (sizeof(pl));
-	 else
-	    return -EFAULT;
-
-      case NS_SETBUFLEV:
-         if (!capable(CAP_NET_ADMIN))
-	    return -EPERM;
-         if (copy_from_user(&pl, (pool_levels __user *) arg, sizeof(pl)))
-	    return -EFAULT;
-	 if (pl.level.min >= pl.level.init || pl.level.init >= pl.level.max)
-	    return -EINVAL;
-	 if (pl.level.min == 0)
-	    return -EINVAL;
-         switch (pl.buftype)
-	 {
-	    case NS_BUFTYPE_SMALL:
-               if (pl.level.max > TOP_SB)
-	          return -EINVAL;
-	       card->sbnr.min = pl.level.min;
-	       card->sbnr.init = pl.level.init;
-	       card->sbnr.max = pl.level.max;
-	       break;
-
-	    case NS_BUFTYPE_LARGE:
-               if (pl.level.max > TOP_LB)
-	          return -EINVAL;
-	       card->lbnr.min = pl.level.min;
-	       card->lbnr.init = pl.level.init;
-	       card->lbnr.max = pl.level.max;
-	       break;
-
-	    case NS_BUFTYPE_HUGE:
-               if (pl.level.max > TOP_HB)
-	          return -EINVAL;
-	       card->hbnr.min = pl.level.min;
-	       card->hbnr.init = pl.level.init;
-	       card->hbnr.max = pl.level.max;
-	       break;
-
-	    case NS_BUFTYPE_IOVEC:
-               if (pl.level.max > TOP_IOVB)
-	          return -EINVAL;
-	       card->iovnr.min = pl.level.min;
-	       card->iovnr.init = pl.level.init;
-	       card->iovnr.max = pl.level.max;
-	       break;
-
-            default:
-	       return -EINVAL;
-
-         }	 
-         return 0;
-
-      case NS_ADJBUFLEV:
-         if (!capable(CAP_NET_ADMIN))
-	    return -EPERM;
-         btype = (long) arg;	/* a long is the same size as a pointer or bigger */
-         switch (btype)
-	 {
-	    case NS_BUFTYPE_SMALL:
-	       while (card->sbfqc < card->sbnr.init)
-	       {
-                  struct sk_buff *sb;
-
-                  sb = __dev_alloc_skb(NS_SMSKBSIZE, GFP_KERNEL);
-                  if (sb == NULL)
-                     return -ENOMEM;
-                  NS_SKB_CB(sb)->buf_type = BUF_SM;
-                  skb_queue_tail(&card->sbpool.queue, sb);
-                  skb_reserve(sb, NS_AAL0_HEADER);
-                  push_rxbufs(card, sb);
-	       }
-	       break;
-
-            case NS_BUFTYPE_LARGE:
-	       while (card->lbfqc < card->lbnr.init)
-	       {
-                  struct sk_buff *lb;
-
-                  lb = __dev_alloc_skb(NS_LGSKBSIZE, GFP_KERNEL);
-                  if (lb == NULL)
-                     return -ENOMEM;
-                  NS_SKB_CB(lb)->buf_type = BUF_LG;
-                  skb_queue_tail(&card->lbpool.queue, lb);
-                  skb_reserve(lb, NS_SMBUFSIZE);
-                  push_rxbufs(card, lb);
-	       }
-	       break;
-
-            case NS_BUFTYPE_HUGE:
-               while (card->hbpool.count > card->hbnr.init)
-	       {
-                  struct sk_buff *hb;
-
-                  spin_lock_irqsave(&card->int_lock, flags);
-		  hb = skb_dequeue(&card->hbpool.queue);
-		  card->hbpool.count--;
-                  spin_unlock_irqrestore(&card->int_lock, flags);
-                  if (hb == NULL)
-		     printk("nicstar%d: huge buffer count inconsistent.\n",
-		            card->index);
-                  else
-		     dev_kfree_skb_any(hb);
-		  
-	       }
-               while (card->hbpool.count < card->hbnr.init)
-               {
-                  struct sk_buff *hb;
-
-                  hb = __dev_alloc_skb(NS_HBUFSIZE, GFP_KERNEL);
-                  if (hb == NULL)
-                     return -ENOMEM;
-                  NS_SKB_CB(hb)->buf_type = BUF_NONE;
-                  spin_lock_irqsave(&card->int_lock, flags);
-                  skb_queue_tail(&card->hbpool.queue, hb);
-                  card->hbpool.count++;
-                  spin_unlock_irqrestore(&card->int_lock, flags);
-               }
-	       break;
-
-            case NS_BUFTYPE_IOVEC:
-	       while (card->iovpool.count > card->iovnr.init)
-	       {
-	          struct sk_buff *iovb;
-
-                  spin_lock_irqsave(&card->int_lock, flags);
-		  iovb = skb_dequeue(&card->iovpool.queue);
-		  card->iovpool.count--;
-                  spin_unlock_irqrestore(&card->int_lock, flags);
-                  if (iovb == NULL)
-		     printk("nicstar%d: iovec buffer count inconsistent.\n",
-		            card->index);
-                  else
-		     dev_kfree_skb_any(iovb);
-
-	       }
-               while (card->iovpool.count < card->iovnr.init)
-	       {
-	          struct sk_buff *iovb;
-
-                  iovb = alloc_skb(NS_IOVBUFSIZE, GFP_KERNEL);
-                  if (iovb == NULL)
-                     return -ENOMEM;
-                  NS_SKB_CB(iovb)->buf_type = BUF_NONE;
-                  spin_lock_irqsave(&card->int_lock, flags);
-                  skb_queue_tail(&card->iovpool.queue, iovb);
-                  card->iovpool.count++;
-                  spin_unlock_irqrestore(&card->int_lock, flags);
-	       }
-	       break;
-
-            default:
-	       return -EINVAL;
-
-	 }
-         return 0;
-
-      default:
-         if (dev->phy && dev->phy->ioctl) {
-            return dev->phy->ioctl(dev, cmd, arg);
-         }
-         else {
-            printk("nicstar%d: %s == NULL \n", card->index,
-                   dev->phy ? "dev->phy->ioctl" : "dev->phy");
-            return -ENOIOCTLCMD;
-         }
-   }
+	ns_dev *card;
+	pool_levels pl;
+	long btype;
+	unsigned long flags;
+
+	card = dev->dev_data;
+	switch (cmd) {
+	case NS_GETPSTAT:
+		if (get_user
+		    (pl.buftype, &((pool_levels __user *) arg)->buftype))
+			return -EFAULT;
+		switch (pl.buftype) {
+		case NS_BUFTYPE_SMALL:
+			pl.count =
+			    ns_stat_sfbqc_get(readl(card->membase + STAT));
+			pl.level.min = card->sbnr.min;
+			pl.level.init = card->sbnr.init;
+			pl.level.max = card->sbnr.max;
+			break;
+
+		case NS_BUFTYPE_LARGE:
+			pl.count =
+			    ns_stat_lfbqc_get(readl(card->membase + STAT));
+			pl.level.min = card->lbnr.min;
+			pl.level.init = card->lbnr.init;
+			pl.level.max = card->lbnr.max;
+			break;
+
+		case NS_BUFTYPE_HUGE:
+			pl.count = card->hbpool.count;
+			pl.level.min = card->hbnr.min;
+			pl.level.init = card->hbnr.init;
+			pl.level.max = card->hbnr.max;
+			break;
+
+		case NS_BUFTYPE_IOVEC:
+			pl.count = card->iovpool.count;
+			pl.level.min = card->iovnr.min;
+			pl.level.init = card->iovnr.init;
+			pl.level.max = card->iovnr.max;
+			break;
+
+		default:
+			return -ENOIOCTLCMD;
+
+		}
+		if (!copy_to_user((pool_levels __user *) arg, &pl, sizeof(pl)))
+			return (sizeof(pl));
+		else
+			return -EFAULT;
+
+	case NS_SETBUFLEV:
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+		if (copy_from_user(&pl, (pool_levels __user *) arg, sizeof(pl)))
+			return -EFAULT;
+		if (pl.level.min >= pl.level.init
+		    || pl.level.init >= pl.level.max)
+			return -EINVAL;
+		if (pl.level.min == 0)
+			return -EINVAL;
+		switch (pl.buftype) {
+		case NS_BUFTYPE_SMALL:
+			if (pl.level.max > TOP_SB)
+				return -EINVAL;
+			card->sbnr.min = pl.level.min;
+			card->sbnr.init = pl.level.init;
+			card->sbnr.max = pl.level.max;
+			break;
+
+		case NS_BUFTYPE_LARGE:
+			if (pl.level.max > TOP_LB)
+				return -EINVAL;
+			card->lbnr.min = pl.level.min;
+			card->lbnr.init = pl.level.init;
+			card->lbnr.max = pl.level.max;
+			break;
+
+		case NS_BUFTYPE_HUGE:
+			if (pl.level.max > TOP_HB)
+				return -EINVAL;
+			card->hbnr.min = pl.level.min;
+			card->hbnr.init = pl.level.init;
+			card->hbnr.max = pl.level.max;
+			break;
+
+		case NS_BUFTYPE_IOVEC:
+			if (pl.level.max > TOP_IOVB)
+				return -EINVAL;
+			card->iovnr.min = pl.level.min;
+			card->iovnr.init = pl.level.init;
+			card->iovnr.max = pl.level.max;
+			break;
+
+		default:
+			return -EINVAL;
+
+		}
+		return 0;
+
+	case NS_ADJBUFLEV:
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+		btype = (long)arg;	/* a long is the same size as a pointer or bigger */
+		switch (btype) {
+		case NS_BUFTYPE_SMALL:
+			while (card->sbfqc < card->sbnr.init) {
+				struct sk_buff *sb;
+
+				sb = __dev_alloc_skb(NS_SMSKBSIZE, GFP_KERNEL);
+				if (sb == NULL)
+					return -ENOMEM;
+				NS_SKB_CB(sb)->buf_type = BUF_SM;
+				skb_queue_tail(&card->sbpool.queue, sb);
+				skb_reserve(sb, NS_AAL0_HEADER);
+				push_rxbufs(card, sb);
+			}
+			break;
+
+		case NS_BUFTYPE_LARGE:
+			while (card->lbfqc < card->lbnr.init) {
+				struct sk_buff *lb;
+
+				lb = __dev_alloc_skb(NS_LGSKBSIZE, GFP_KERNEL);
+				if (lb == NULL)
+					return -ENOMEM;
+				NS_SKB_CB(lb)->buf_type = BUF_LG;
+				skb_queue_tail(&card->lbpool.queue, lb);
+				skb_reserve(lb, NS_SMBUFSIZE);
+				push_rxbufs(card, lb);
+			}
+			break;
+
+		case NS_BUFTYPE_HUGE:
+			while (card->hbpool.count > card->hbnr.init) {
+				struct sk_buff *hb;
+
+				spin_lock_irqsave(&card->int_lock, flags);
+				hb = skb_dequeue(&card->hbpool.queue);
+				card->hbpool.count--;
+				spin_unlock_irqrestore(&card->int_lock, flags);
+				if (hb == NULL)
+					printk
+					    ("nicstar%d: huge buffer count inconsistent.\n",
+					     card->index);
+				else
+					dev_kfree_skb_any(hb);
+
+			}
+			while (card->hbpool.count < card->hbnr.init) {
+				struct sk_buff *hb;
+
+				hb = __dev_alloc_skb(NS_HBUFSIZE, GFP_KERNEL);
+				if (hb == NULL)
+					return -ENOMEM;
+				NS_SKB_CB(hb)->buf_type = BUF_NONE;
+				spin_lock_irqsave(&card->int_lock, flags);
+				skb_queue_tail(&card->hbpool.queue, hb);
+				card->hbpool.count++;
+				spin_unlock_irqrestore(&card->int_lock, flags);
+			}
+			break;
+
+		case NS_BUFTYPE_IOVEC:
+			while (card->iovpool.count > card->iovnr.init) {
+				struct sk_buff *iovb;
+
+				spin_lock_irqsave(&card->int_lock, flags);
+				iovb = skb_dequeue(&card->iovpool.queue);
+				card->iovpool.count--;
+				spin_unlock_irqrestore(&card->int_lock, flags);
+				if (iovb == NULL)
+					printk
+					    ("nicstar%d: iovec buffer count inconsistent.\n",
+					     card->index);
+				else
+					dev_kfree_skb_any(iovb);
+
+			}
+			while (card->iovpool.count < card->iovnr.init) {
+				struct sk_buff *iovb;
+
+				iovb = alloc_skb(NS_IOVBUFSIZE, GFP_KERNEL);
+				if (iovb == NULL)
+					return -ENOMEM;
+				NS_SKB_CB(iovb)->buf_type = BUF_NONE;
+				spin_lock_irqsave(&card->int_lock, flags);
+				skb_queue_tail(&card->iovpool.queue, iovb);
+				card->iovpool.count++;
+				spin_unlock_irqrestore(&card->int_lock, flags);
+			}
+			break;
+
+		default:
+			return -EINVAL;
+
+		}
+		return 0;
+
+	default:
+		if (dev->phy && dev->phy->ioctl) {
+			return dev->phy->ioctl(dev, cmd, arg);
+		} else {
+			printk("nicstar%d: %s == NULL \n", card->index,
+			       dev->phy ? "dev->phy->ioctl" : "dev->phy");
+			return -ENOIOCTLCMD;
+		}
+	}
 }
 
-
-static void which_list(ns_dev *card, struct sk_buff *skb)
+static void which_list(ns_dev * card, struct sk_buff *skb)
 {
 	printk("skb buf_type: 0x%08x\n", NS_SKB_CB(skb)->buf_type);
 }
 
-
 static void ns_poll(unsigned long arg)
 {
-   int i;
-   ns_dev *card;
-   unsigned long flags;
-   u32 stat_r, stat_w;
-
-   PRINTK("nicstar: Entering ns_poll().\n");
-   for (i = 0; i < num_cards; i++)
-   {
-      card = cards[i];
-      if (spin_is_locked(&card->int_lock)) {
-      /* Probably it isn't worth spinning */
-         continue;
-      }
-      spin_lock_irqsave(&card->int_lock, flags);
-
-      stat_w = 0;
-      stat_r = readl(card->membase + STAT);
-      if (stat_r & NS_STAT_TSIF)
-         stat_w |= NS_STAT_TSIF;
-      if (stat_r & NS_STAT_EOPDU)
-         stat_w |= NS_STAT_EOPDU;
-
-      process_tsq(card);
-      process_rsq(card);
-
-      writel(stat_w, card->membase + STAT);
-      spin_unlock_irqrestore(&card->int_lock, flags);
-   }
-   mod_timer(&ns_timer, jiffies + NS_POLL_PERIOD);
-   PRINTK("nicstar: Leaving ns_poll().\n");
+	int i;
+	ns_dev *card;
+	unsigned long flags;
+	u32 stat_r, stat_w;
+
+	PRINTK("nicstar: Entering ns_poll().\n");
+	for (i = 0; i < num_cards; i++) {
+		card = cards[i];
+		if (spin_is_locked(&card->int_lock)) {
+			/* Probably it isn't worth spinning */
+			continue;
+		}
+		spin_lock_irqsave(&card->int_lock, flags);
+
+		stat_w = 0;
+		stat_r = readl(card->membase + STAT);
+		if (stat_r & NS_STAT_TSIF)
+			stat_w |= NS_STAT_TSIF;
+		if (stat_r & NS_STAT_EOPDU)
+			stat_w |= NS_STAT_EOPDU;
+
+		process_tsq(card);
+		process_rsq(card);
+
+		writel(stat_w, card->membase + STAT);
+		spin_unlock_irqrestore(&card->int_lock, flags);
+	}
+	mod_timer(&ns_timer, jiffies + NS_POLL_PERIOD);
+	PRINTK("nicstar: Leaving ns_poll().\n");
 }
 
-
-
 static int ns_parse_mac(char *mac, unsigned char *esi)
 {
-   int i, j;
-   short byte1, byte0;
-
-   if (mac == NULL || esi == NULL)
-      return -1;
-   j = 0;
-   for (i = 0; i < 6; i++)
-   {
-      if ((byte1 = ns_h2i(mac[j++])) < 0)
-         return -1;
-      if ((byte0 = ns_h2i(mac[j++])) < 0)
-         return -1;
-      esi[i] = (unsigned char) (byte1 * 16 + byte0);
-      if (i < 5)
-      {
-         if (mac[j++] != ':')
-            return -1;
-      }
-   }
-   return 0;
+	int i, j;
+	short byte1, byte0;
+
+	if (mac == NULL || esi == NULL)
+		return -1;
+	j = 0;
+	for (i = 0; i < 6; i++) {
+		if ((byte1 = ns_h2i(mac[j++])) < 0)
+			return -1;
+		if ((byte0 = ns_h2i(mac[j++])) < 0)
+			return -1;
+		esi[i] = (unsigned char)(byte1 * 16 + byte0);
+		if (i < 5) {
+			if (mac[j++] != ':')
+				return -1;
+		}
+	}
+	return 0;
 }
 
-
-
 static short ns_h2i(char c)
 {
-   if (c >= '0' && c <= '9')
-      return (short) (c - '0');
-   if (c >= 'A' && c <= 'F')
-      return (short) (c - 'A' + 10);
-   if (c >= 'a' && c <= 'f')
-      return (short) (c - 'a' + 10);
-   return -1;
+	if (c >= '0' && c <= '9')
+		return (short)(c - '0');
+	if (c >= 'A' && c <= 'F')
+		return (short)(c - 'A' + 10);
+	if (c >= 'a' && c <= 'f')
+		return (short)(c - 'a' + 10);
+	return -1;
 }
 
-
-
 static void ns_phy_put(struct atm_dev *dev, unsigned char value,
-                    unsigned long addr)
+		       unsigned long addr)
 {
-   ns_dev *card;
-   unsigned long flags;
-
-   card = dev->dev_data;
-   spin_lock_irqsave(&card->res_lock, flags);
-   while(CMD_BUSY(card));
-   writel((unsigned long) value, card->membase + DR0);
-   writel(NS_CMD_WRITE_UTILITY | 0x00000200 | (addr & 0x000000FF),
-          card->membase + CMD);
-   spin_unlock_irqrestore(&card->res_lock, flags);
+	ns_dev *card;
+	unsigned long flags;
+
+	card = dev->dev_data;
+	spin_lock_irqsave(&card->res_lock, flags);
+	while (CMD_BUSY(card)) ;
+	writel((unsigned long)value, card->membase + DR0);
+	writel(NS_CMD_WRITE_UTILITY | 0x00000200 | (addr & 0x000000FF),
+	       card->membase + CMD);
+	spin_unlock_irqrestore(&card->res_lock, flags);
 }
 
-
-
 static unsigned char ns_phy_get(struct atm_dev *dev, unsigned long addr)
 {
-   ns_dev *card;
-   unsigned long flags;
-   unsigned long data;
-
-   card = dev->dev_data;
-   spin_lock_irqsave(&card->res_lock, flags);
-   while(CMD_BUSY(card));
-   writel(NS_CMD_READ_UTILITY | 0x00000200 | (addr & 0x000000FF),
-          card->membase + CMD);
-   while(CMD_BUSY(card));
-   data = readl(card->membase + DR0) & 0x000000FF;
-   spin_unlock_irqrestore(&card->res_lock, flags);
-   return (unsigned char) data;
+	ns_dev *card;
+	unsigned long flags;
+	unsigned long data;
+
+	card = dev->dev_data;
+	spin_lock_irqsave(&card->res_lock, flags);
+	while (CMD_BUSY(card)) ;
+	writel(NS_CMD_READ_UTILITY | 0x00000200 | (addr & 0x000000FF),
+	       card->membase + CMD);
+	while (CMD_BUSY(card)) ;
+	data = readl(card->membase + DR0) & 0x000000FF;
+	spin_unlock_irqrestore(&card->res_lock, flags);
+	return (unsigned char)data;
 }
 
-
-
 module_init(nicstar_init);
 module_exit(nicstar_cleanup);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 50838407b117..b7473a6110a7 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -49,6 +49,7 @@
 #include <linux/timer.h>
 #include <linux/interrupt.h>
 #include <linux/bitops.h>
+#include <linux/slab.h>
 #include <asm/io.h>
 #include <asm/uaccess.h>
 #include <asm/atomic.h>

commit 1154b299e7924f2ae8bb3ca479a6942e1edd78fc
Author: hartleys <hartleys@visionengravers.com>
Date:   Tue Jan 5 06:28:08 2010 +0000

    drivers/atm/nicstar.c: use %pM to show MAC address
    
    Use the %pM kernel extension to display the MAC address.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Cc: David S. Miller <davem@davemloft.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 3da804b1627d..50838407b117 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -807,9 +807,7 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
       }
    }
 
-   printk("nicstar%d: MAC address %02X:%02X:%02X:%02X:%02X:%02X\n", i,
-          card->atmdev->esi[0], card->atmdev->esi[1], card->atmdev->esi[2],
-          card->atmdev->esi[3], card->atmdev->esi[4], card->atmdev->esi[5]);
+   printk("nicstar%d: MAC address %pM\n", i, card->atmdev->esi);
 
    card->atmdev->dev_data = card;
    card->atmdev->ci_range.vpi_bits = card->vpibits;

commit 8da56309f04d76a474791fd27b33ddd52062bcd6
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Apr 28 14:13:20 2008 -0700

    drivers: atm, char fix integer as NULL pointer warnings
    
    drivers/atm/nicstar.c:418:25: warning: Using plain integer as NULL pointer
    drivers/char/drm/r128_cce.c:820:25: warning: Using plain integer as NULL pointer
    drivers/char/tty_io.c:1183:10: warning: Using plain integer as NULL pointer
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 38c769f8d2b7..3da804b1627d 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -415,7 +415,7 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
    card->pcidev = pcidev;
    membase = pci_resource_start(pcidev, 1);
    card->membase = ioremap(membase, NS_IOREMAP_SIZE);
-   if (card->membase == 0)
+   if (!card->membase)
    {
       printk("nicstar%d: can't ioremap() membase.\n",i);
       error = 3;

commit 36ef408061da9e012375547d69b27cc1f537b044
Author: Mark Asselstine <mark.asselstine@windriver.com>
Date:   Sat Apr 19 18:10:46 2008 -0700

    atm nicstar: Removal of debug code containing deprecated calls to cli()/sti()
    
    Code within NS_DEBUG_SPINLOCKS contained deprecated cli()/sti()
    function calls.  NS_DEBUG_SPINLOCKS and the associated code seems to
    be of little use these days so the strategy of removing this code
    rather then updating it to use spinlocks has been taken.
    
    Signed-off-by: Mark Asselstine <mark.asselstine@windriver.com>
    Reviewed-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 0c205b000e8b..38c769f8d2b7 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -125,85 +125,6 @@
 #define ATM_SKB(s) (&(s)->atm)
 #endif
 
-   /* Spinlock debugging stuff */
-#ifdef NS_DEBUG_SPINLOCKS /* See nicstar.h */
-#define ns_grab_int_lock(card,flags) \
- do { \
-    unsigned long nsdsf, nsdsf2; \
-    local_irq_save(flags); \
-    save_flags(nsdsf); cli();\
-    if (nsdsf & (1<<9)) printk ("nicstar.c: ints %sabled -> enabled.\n", \
-                                (flags)&(1<<9)?"en":"dis"); \
-    if (spin_is_locked(&(card)->int_lock) && \
-        (card)->cpu_int == smp_processor_id()) { \
-       printk("nicstar.c: line %d (cpu %d) int_lock already locked at line %d (cpu %d)\n", \
-              __LINE__, smp_processor_id(), (card)->has_int_lock, \
-              (card)->cpu_int); \
-       printk("nicstar.c: ints were %sabled.\n", ((flags)&(1<<9)?"en":"dis")); \
-    } \
-    if (spin_is_locked(&(card)->res_lock) && \
-        (card)->cpu_res == smp_processor_id()) { \
-       printk("nicstar.c: line %d (cpu %d) res_lock locked at line %d (cpu %d)(trying int)\n", \
-              __LINE__, smp_processor_id(), (card)->has_res_lock, \
-              (card)->cpu_res); \
-       printk("nicstar.c: ints were %sabled.\n", ((flags)&(1<<9)?"en":"dis")); \
-    } \
-    spin_lock_irq(&(card)->int_lock); \
-    (card)->has_int_lock = __LINE__; \
-    (card)->cpu_int = smp_processor_id(); \
-    restore_flags(nsdsf); } while (0)
-#define ns_grab_res_lock(card,flags) \
- do { \
-    unsigned long nsdsf, nsdsf2; \
-    local_irq_save(flags); \
-    save_flags(nsdsf); cli();\
-    if (nsdsf & (1<<9)) printk ("nicstar.c: ints %sabled -> enabled.\n", \
-                                (flags)&(1<<9)?"en":"dis"); \
-    if (spin_is_locked(&(card)->res_lock) && \
-        (card)->cpu_res == smp_processor_id()) { \
-       printk("nicstar.c: line %d (cpu %d) res_lock already locked at line %d (cpu %d)\n", \
-              __LINE__, smp_processor_id(), (card)->has_res_lock, \
-              (card)->cpu_res); \
-       printk("nicstar.c: ints were %sabled.\n", ((flags)&(1<<9)?"en":"dis")); \
-    } \
-    spin_lock_irq(&(card)->res_lock); \
-    (card)->has_res_lock = __LINE__; \
-    (card)->cpu_res = smp_processor_id(); \
-    restore_flags(nsdsf); } while (0)
-#define ns_grab_scq_lock(card,scq,flags) \
- do { \
-    unsigned long nsdsf, nsdsf2; \
-    local_irq_save(flags); \
-    save_flags(nsdsf); cli();\
-    if (nsdsf & (1<<9)) printk ("nicstar.c: ints %sabled -> enabled.\n", \
-                                (flags)&(1<<9)?"en":"dis"); \
-    if (spin_is_locked(&(scq)->lock) && \
-        (scq)->cpu_lock == smp_processor_id()) { \
-       printk("nicstar.c: line %d (cpu %d) this scq_lock already locked at line %d (cpu %d)\n", \
-              __LINE__, smp_processor_id(), (scq)->has_lock, \
-              (scq)->cpu_lock); \
-       printk("nicstar.c: ints were %sabled.\n", ((flags)&(1<<9)?"en":"dis")); \
-    } \
-    if (spin_is_locked(&(card)->res_lock) && \
-        (card)->cpu_res == smp_processor_id()) { \
-       printk("nicstar.c: line %d (cpu %d) res_lock locked at line %d (cpu %d)(trying scq)\n", \
-              __LINE__, smp_processor_id(), (card)->has_res_lock, \
-              (card)->cpu_res); \
-       printk("nicstar.c: ints were %sabled.\n", ((flags)&(1<<9)?"en":"dis")); \
-    } \
-    spin_lock_irq(&(scq)->lock); \
-    (scq)->has_lock = __LINE__; \
-    (scq)->cpu_lock = smp_processor_id(); \
-    restore_flags(nsdsf); } while (0)
-#else /* !NS_DEBUG_SPINLOCKS */
-#define ns_grab_int_lock(card,flags) \
-        spin_lock_irqsave(&(card)->int_lock,(flags))
-#define ns_grab_res_lock(card,flags) \
-        spin_lock_irqsave(&(card)->res_lock,(flags))
-#define ns_grab_scq_lock(card,scq,flags) \
-        spin_lock_irqsave(&(scq)->lock,flags)
-#endif /* NS_DEBUG_SPINLOCKS */
-
 
 /* Function declarations ******************************************************/
 
@@ -422,7 +343,7 @@ static u32 ns_read_sram(ns_dev *card, u32 sram_address)
    sram_address <<= 2;
    sram_address &= 0x0007FFFC;	/* address must be dword aligned */
    sram_address |= 0x50000000;	/* SRAM read command */
-   ns_grab_res_lock(card, flags);
+   spin_lock_irqsave(&card->res_lock, flags);
    while (CMD_BUSY(card));
    writel(sram_address, card->membase + CMD);
    while (CMD_BUSY(card));
@@ -440,7 +361,7 @@ static void ns_write_sram(ns_dev *card, u32 sram_address, u32 *value, int count)
    count--;	/* count range now is 0..3 instead of 1..4 */
    c = count;
    c <<= 2;	/* to use increments of 4 */
-   ns_grab_res_lock(card, flags);
+   spin_lock_irqsave(&card->res_lock, flags);
    while (CMD_BUSY(card));
    for (i = 0; i <= c; i += 4)
       writel(*(value++), card->membase + i);
@@ -1166,7 +1087,7 @@ static void push_rxbufs(ns_dev *card, struct sk_buff *skb)
             card->lbfqc += 2;
       }
 
-      ns_grab_res_lock(card, flags);
+      spin_lock_irqsave(&card->res_lock, flags);
 
       while (CMD_BUSY(card));
       writel(addr2, card->membase + DR3);
@@ -1206,7 +1127,7 @@ static irqreturn_t ns_irq_handler(int irq, void *dev_id)
 
    PRINTK("nicstar%d: NICStAR generated an interrupt\n", card->index);
 
-   ns_grab_int_lock(card, flags);
+   spin_lock_irqsave(&card->int_lock, flags);
    
    stat_r = readl(card->membase + STAT);
 
@@ -1585,7 +1506,7 @@ static void ns_close(struct atm_vcc *vcc)
       unsigned long flags;
       
       addr = NS_RCT + (vcc->vpi << card->vcibits | vcc->vci) * NS_RCT_ENTRY_SIZE;
-      ns_grab_res_lock(card, flags);
+      spin_lock_irqsave(&card->res_lock, flags);
       while(CMD_BUSY(card));
       writel(NS_CMD_CLOSE_CONNECTION | addr << 2, card->membase + CMD);
       spin_unlock_irqrestore(&card->res_lock, flags);
@@ -1607,7 +1528,7 @@ static void ns_close(struct atm_vcc *vcc)
 	                       NS_SKB(iovb)->iovcnt);
          NS_SKB(iovb)->iovcnt = 0;
          NS_SKB(iovb)->vcc = NULL;
-         ns_grab_int_lock(card, flags);
+         spin_lock_irqsave(&card->int_lock, flags);
          recycle_iov_buf(card, iovb);
          spin_unlock_irqrestore(&card->int_lock, flags);
          vc->rx_iov = NULL;
@@ -1629,7 +1550,7 @@ static void ns_close(struct atm_vcc *vcc)
 
       for (;;)
       {
-         ns_grab_scq_lock(card, scq, flags);
+         spin_lock_irqsave(&scq->lock, flags);
          scqep = scq->next;
          if (scqep == scq->base)
             scqep = scq->last;
@@ -1691,7 +1612,7 @@ static void ns_close(struct atm_vcc *vcc)
      unsigned long flags;
      scq_info *scq = card->scq0;
 
-     ns_grab_scq_lock(card, scq, flags);
+     spin_lock_irqsave(&scq->lock, flags);
 
      for(i = 0; i < scq->num_entries; i++) {
        if(scq->skb[i] && ATM_SKB(scq->skb[i])->vcc == vcc) {
@@ -1892,7 +1813,7 @@ static int push_scqe(ns_dev *card, vc_map *vc, scq_info *scq, ns_scqe *tbd,
    u32 data;
    int index;
    
-   ns_grab_scq_lock(card, scq, flags);
+   spin_lock_irqsave(&scq->lock, flags);
    while (scq->tail == scq->next)
    {
       if (in_interrupt()) {
@@ -1904,7 +1825,7 @@ static int push_scqe(ns_dev *card, vc_map *vc, scq_info *scq, ns_scqe *tbd,
       scq->full = 1;
       spin_unlock_irqrestore(&scq->lock, flags);
       interruptible_sleep_on_timeout(&scq->scqfull_waitq, SCQFULL_TIMEOUT);
-      ns_grab_scq_lock(card, scq, flags);
+      spin_lock_irqsave(&scq->lock, flags);
 
       if (scq->full) {
          spin_unlock_irqrestore(&scq->lock, flags);
@@ -1953,7 +1874,7 @@ static int push_scqe(ns_dev *card, vc_map *vc, scq_info *scq, ns_scqe *tbd,
          if (has_run++) break;
          spin_unlock_irqrestore(&scq->lock, flags);
          interruptible_sleep_on_timeout(&scq->scqfull_waitq, SCQFULL_TIMEOUT);
-         ns_grab_scq_lock(card, scq, flags);
+         spin_lock_irqsave(&scq->lock, flags);
       }
 
       if (!scq->full)
@@ -2090,7 +2011,7 @@ static void drain_scq(ns_dev *card, scq_info *scq, int pos)
       return;
    }
 
-   ns_grab_scq_lock(card, scq, flags);
+   spin_lock_irqsave(&scq->lock, flags);
    i = (int) (scq->tail - scq->base);
    if (++i == scq->num_entries)
       i = 0;
@@ -2898,7 +2819,7 @@ static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)
 	       {
                   struct sk_buff *hb;
 
-                  ns_grab_int_lock(card, flags);
+                  spin_lock_irqsave(&card->int_lock, flags);
 		  hb = skb_dequeue(&card->hbpool.queue);
 		  card->hbpool.count--;
                   spin_unlock_irqrestore(&card->int_lock, flags);
@@ -2917,7 +2838,7 @@ static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)
                   if (hb == NULL)
                      return -ENOMEM;
                   NS_SKB_CB(hb)->buf_type = BUF_NONE;
-                  ns_grab_int_lock(card, flags);
+                  spin_lock_irqsave(&card->int_lock, flags);
                   skb_queue_tail(&card->hbpool.queue, hb);
                   card->hbpool.count++;
                   spin_unlock_irqrestore(&card->int_lock, flags);
@@ -2929,7 +2850,7 @@ static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)
 	       {
 	          struct sk_buff *iovb;
 
-                  ns_grab_int_lock(card, flags);
+                  spin_lock_irqsave(&card->int_lock, flags);
 		  iovb = skb_dequeue(&card->iovpool.queue);
 		  card->iovpool.count--;
                   spin_unlock_irqrestore(&card->int_lock, flags);
@@ -2948,7 +2869,7 @@ static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)
                   if (iovb == NULL)
                      return -ENOMEM;
                   NS_SKB_CB(iovb)->buf_type = BUF_NONE;
-                  ns_grab_int_lock(card, flags);
+                  spin_lock_irqsave(&card->int_lock, flags);
                   skb_queue_tail(&card->iovpool.queue, iovb);
                   card->iovpool.count++;
                   spin_unlock_irqrestore(&card->int_lock, flags);
@@ -2995,7 +2916,7 @@ static void ns_poll(unsigned long arg)
       /* Probably it isn't worth spinning */
          continue;
       }
-      ns_grab_int_lock(card, flags);
+      spin_lock_irqsave(&card->int_lock, flags);
 
       stat_w = 0;
       stat_r = readl(card->membase + STAT);
@@ -3062,7 +2983,7 @@ static void ns_phy_put(struct atm_dev *dev, unsigned char value,
    unsigned long flags;
 
    card = dev->dev_data;
-   ns_grab_res_lock(card, flags);
+   spin_lock_irqsave(&card->res_lock, flags);
    while(CMD_BUSY(card));
    writel((unsigned long) value, card->membase + DR0);
    writel(NS_CMD_WRITE_UTILITY | 0x00000200 | (addr & 0x000000FF),
@@ -3079,7 +3000,7 @@ static unsigned char ns_phy_get(struct atm_dev *dev, unsigned long addr)
    unsigned long data;
 
    card = dev->dev_data;
-   ns_grab_res_lock(card, flags);
+   spin_lock_irqsave(&card->res_lock, flags);
    while(CMD_BUSY(card));
    writel(NS_CMD_READ_UTILITY | 0x00000200 | (addr & 0x000000FF),
           card->membase + CMD);

commit 52961955aa180959158faeb9fd6b4f8a591450f5
Author: Chas Williams <chas@cmf.nrl.navy.mil>
Date:   Mon Jan 7 00:26:22 2008 -0800

    [ATM]: [nicstar] delay irq setup until card is configured
    
    Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 14ced85b3f54..0c205b000e8b 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -625,14 +625,6 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
    if (mac[i] == NULL)
       nicstar_init_eprom(card->membase);
 
-   if (request_irq(pcidev->irq, &ns_irq_handler, IRQF_DISABLED | IRQF_SHARED, "nicstar", card) != 0)
-   {
-      printk("nicstar%d: can't allocate IRQ %d.\n", i, pcidev->irq);
-      error = 9;
-      ns_init_card_error(card, error);
-      return error;
-   }
-
    /* Set the VPI/VCI MSb mask to zero so we can receive OAM cells */
    writel(0x00000000, card->membase + VPM);
       
@@ -858,8 +850,6 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
       card->iovpool.count++;
    }
 
-   card->intcnt = 0;
-
    /* Configure NICStAR */
    if (card->rct_size == 4096)
       ns_cfg_rctsize = NS_CFG_RCTSIZE_4096_ENTRIES;
@@ -868,6 +858,15 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
 
    card->efbie = 1;
 
+   card->intcnt = 0;
+   if (request_irq(pcidev->irq, &ns_irq_handler, IRQF_DISABLED | IRQF_SHARED, "nicstar", card) != 0)
+   {
+      printk("nicstar%d: can't allocate IRQ %d.\n", i, pcidev->irq);
+      error = 9;
+      ns_init_card_error(card, error);
+      return error;
+   }
+
    /* Register device */
    card->atmdev = atm_dev_register("nicstar", &atm_ops, -1, NULL);
    if (card->atmdev == NULL)

commit d626f62b11e00c16e81e4308ab93d3f13551812a
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Tue Mar 27 18:55:52 2007 -0300

    [SK_BUFF]: Introduce skb_copy_from_linear_data{_offset}
    
    To clearly state the intent of copying from linear sk_buffs, _offset being a
    overly long variant but interesting for the sake of saving some bytes.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 26f4b7033494..14ced85b3f54 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -2395,7 +2395,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
                skb->destructor = ns_lb_destructor;
 #endif /* NS_USE_DESTRUCTORS */
                skb_push(skb, NS_SMBUFSIZE);
-               memcpy(skb->data, sb->data, NS_SMBUFSIZE);
+               skb_copy_from_linear_data(sb, skb->data, NS_SMBUFSIZE);
                skb_put(skb, len - NS_SMBUFSIZE);
                ATM_SKB(skb)->vcc = vcc;
 	       __net_timestamp(skb);
@@ -2479,7 +2479,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
 	 {
             /* Copy the small buffer to the huge buffer */
             sb = (struct sk_buff *) iov->iov_base;
-            memcpy(hb->data, sb->data, iov->iov_len);
+            skb_copy_from_linear_data(sb, hb->data, iov->iov_len);
             skb_put(hb, iov->iov_len);
             remaining = len - iov->iov_len;
             iov++;
@@ -2491,7 +2491,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
             {
                lb = (struct sk_buff *) iov->iov_base;
                tocopy = min_t(int, remaining, iov->iov_len);
-               memcpy(skb_tail_pointer(hb), lb->data, tocopy);
+               skb_copy_from_linear_data(lb, skb_tail_pointer(hb), tocopy);
                skb_put(hb, tocopy);
                iov++;
                remaining -= tocopy;

commit 27a884dc3cb63b93c2b3b643f5b31eed5f8a4d26
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Thu Apr 19 20:29:13 2007 -0700

    [SK_BUFF]: Convert skb->tail to sk_buff_data_t
    
    So that it is also an offset from skb->head, reduces its size from 8 to 4 bytes
    on 64bit architectures, allowing us to combine the 4 bytes hole left by the
    layer headers conversion, reducing struct sk_buff size to 256 bytes, i.e. 4
    64byte cachelines, and since the sk_buff slab cache is SLAB_HWCACHE_ALIGN...
    :-)
    
    Many calculations that previously required that skb->{transport,network,
    mac}_header be first converted to a pointer now can be done directly, being
    meaningful as offsets or pointers.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index aab9b3733d52..26f4b7033494 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -2208,7 +2208,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
          if (i == 1 && ns_rsqe_eopdu(rsqe))
             *((u32 *) sb->data) |= 0x00000002;
          skb_put(sb, NS_AAL0_HEADER);
-         memcpy(sb->tail, cell, ATM_CELL_PAYLOAD);
+         memcpy(skb_tail_pointer(sb), cell, ATM_CELL_PAYLOAD);
          skb_put(sb, ATM_CELL_PAYLOAD);
          ATM_SKB(sb)->vcc = vcc;
 	 __net_timestamp(sb);
@@ -2252,7 +2252,8 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
       vc->rx_iov = iovb;
       NS_SKB(iovb)->iovcnt = 0;
       iovb->len = 0;
-      iovb->tail = iovb->data = iovb->head;
+      iovb->data = iovb->head;
+      skb_reset_tail_pointer(iovb);
       NS_SKB(iovb)->vcc = vcc;
       /* IMPORTANT: a pointer to the sk_buff containing the small or large
                     buffer is stored as iovec base, NOT a pointer to the 
@@ -2265,7 +2266,8 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
       recycle_iovec_rx_bufs(card, (struct iovec *) iovb->data, NS_MAX_IOVECS);
       NS_SKB(iovb)->iovcnt = 0;
       iovb->len = 0;
-      iovb->tail = iovb->data = iovb->head;
+      iovb->data = iovb->head;
+      skb_reset_tail_pointer(iovb);
       NS_SKB(iovb)->vcc = vcc;
    }
    iov = &((struct iovec *) iovb->data)[NS_SKB(iovb)->iovcnt++];
@@ -2489,7 +2491,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
             {
                lb = (struct sk_buff *) iov->iov_base;
                tocopy = min_t(int, remaining, iov->iov_len);
-               memcpy(hb->tail, lb->data, tocopy);
+               memcpy(skb_tail_pointer(hb), lb->data, tocopy);
                skb_put(hb, tocopy);
                iov++;
                remaining -= tocopy;

commit 5cbded585d129d0226cb48ac4202b253c781be26
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Wed Dec 13 00:35:56 2006 -0800

    [PATCH] getting rid of all casts of k[cmz]alloc() calls
    
    Run this:
    
            #!/bin/sh
            for f in $(grep -Erl "\([^\)]*\) *k[cmz]alloc" *) ; do
              echo "De-casting $f..."
              perl -pi -e "s/ ?= ?\([^\)]*\) *(k[cmz]alloc) *\(/ = \1\(/" $f
            done
    
    And then go through and reinstate those cases where code is casting pointers
    to non-pointers.
    
    And then drop a few hunks which conflicted with outstanding work.
    
    Cc: Russell King <rmk@arm.linux.org.uk>, Ian Molton <spyro@f2s.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Paul Fulghum <paulkf@microgate.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Karsten Keil <kkeil@suse.de>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Ian Kent <raven@themaw.net>
    Cc: Steven French <sfrench@us.ibm.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index bd0904594805..aab9b3733d52 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -997,7 +997,7 @@ static scq_info *get_scq(int size, u32 scd)
    if (size != VBR_SCQSIZE && size != CBR_SCQSIZE)
       return NULL;
 
-   scq = (scq_info *) kmalloc(sizeof(scq_info), GFP_KERNEL);
+   scq = kmalloc(sizeof(scq_info), GFP_KERNEL);
    if (scq == NULL)
       return NULL;
    scq->org = kmalloc(2 * size, GFP_KERNEL);
@@ -1006,7 +1006,7 @@ static scq_info *get_scq(int size, u32 scd)
       kfree(scq);
       return NULL;
    }
-   scq->skb = (struct sk_buff **) kmalloc(sizeof(struct sk_buff *) *
+   scq->skb = kmalloc(sizeof(struct sk_buff *) *
                                           (size / NS_SCQE_SIZE), GFP_KERNEL);
    if (scq->skb == NULL)
    {

commit 69c3014763966b0ae2bd190dac3654dd6cebdd45
Author: Alan Cox <alan@redhat.com>
Date:   Fri Oct 20 19:51:46 2006 -0700

    [ATM] nicstar: Fix a bogus casting warning
    
    Not enough to make Nicstar 64bit friendly but got squashed in passing so might
    as well be applied
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 632ede552761..bd0904594805 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -2759,7 +2759,7 @@ static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)
 {
    ns_dev *card;
    pool_levels pl;
-   int btype;
+   long btype;
    unsigned long flags;
 
    card = dev->dev_data;
@@ -2859,7 +2859,7 @@ static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)
       case NS_ADJBUFLEV:
          if (!capable(CAP_NET_ADMIN))
 	    return -EPERM;
-         btype = (int) arg;	/* an int is the same size as a pointer */
+         btype = (long) arg;	/* a long is the same size as a pointer or bigger */
          switch (btype)
 	 {
 	    case NS_BUFTYPE_SMALL:

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index b8036899e56f..632ede552761 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -214,7 +214,7 @@ static void __devinit ns_init_card_error(ns_dev *card, int error);
 static scq_info *get_scq(int size, u32 scd);
 static void free_scq(scq_info *scq, struct atm_vcc *vcc);
 static void push_rxbufs(ns_dev *, struct sk_buff *);
-static irqreturn_t ns_irq_handler(int irq, void *dev_id, struct pt_regs *regs);
+static irqreturn_t ns_irq_handler(int irq, void *dev_id);
 static int ns_open(struct atm_vcc *vcc);
 static void ns_close(struct atm_vcc *vcc);
 static void fill_tst(ns_dev *card, int n, vc_map *vc);
@@ -1194,7 +1194,7 @@ static void push_rxbufs(ns_dev *card, struct sk_buff *skb)
 
 
 
-static irqreturn_t ns_irq_handler(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t ns_irq_handler(int irq, void *dev_id)
 {
    u32 stat_r;
    ns_dev *card;

commit dace145374b8e39aeb920304c358ab5e220341ab
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:38 2006 -0700

    [PATCH] irq-flags: misc drivers: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index b78612d3fa46..b8036899e56f 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -625,7 +625,7 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
    if (mac[i] == NULL)
       nicstar_init_eprom(card->membase);
 
-   if (request_irq(pcidev->irq, &ns_irq_handler, SA_INTERRUPT | SA_SHIRQ, "nicstar", card) != 0)
+   if (request_irq(pcidev->irq, &ns_irq_handler, IRQF_DISABLED | IRQF_SHARED, "nicstar", card) != 0)
    {
       printk("nicstar%d: can't allocate IRQ %d.\n", i, pcidev->irq);
       error = 9;

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 074abc81ec3d..b78612d3fa46 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -36,7 +36,6 @@
 /* Header files ***************************************************************/
 
 #include <linux/module.h>
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/skbuff.h>
 #include <linux/atmdev.h>

commit 2087ff3ec56eba9bccd3b3a9d4d42670b1543f5d
Author: David Howells <dhowells@redhat.com>
Date:   Sun Jan 8 01:01:25 2006 -0800

    [PATCH] frv: fix uninitialised variable in atm nicstar driver
    
    Fix an uninitialised variable warning in the atm nicstar driver.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index c57e20dcb0f8..074abc81ec3d 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -2126,8 +2126,7 @@ static void process_rsq(ns_dev *card)
 
    if (!ns_rsqe_valid(card->rsq.next))
       return;
-   while (ns_rsqe_valid(card->rsq.next))
-   {
+   do {
       dequeue_rx(card, card->rsq.next);
       ns_rsqe_init(card->rsq.next);
       previous = card->rsq.next;
@@ -2135,7 +2134,7 @@ static void process_rsq(ns_dev *card)
          card->rsq.next = card->rsq.base;
       else
          card->rsq.next++;
-   }
+   } while (ns_rsqe_valid(card->rsq.next));
    writel((((u32) previous) - ((u32) card->rsq.base)),
           card->membase + RSQH);
 }

commit a61bbcf28a8cb0ba56f8193d512f7222e711a294
Author: Patrick McHardy <kaber@trash.net>
Date:   Sun Aug 14 17:24:31 2005 -0700

    [NET]: Store skb->timestamp as offset to a base timestamp
    
    Reduces skb size by 8 bytes on 64-bit.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index a0e3bd861f1c..c57e20dcb0f8 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -2213,7 +2213,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
          memcpy(sb->tail, cell, ATM_CELL_PAYLOAD);
          skb_put(sb, ATM_CELL_PAYLOAD);
          ATM_SKB(sb)->vcc = vcc;
-         do_gettimeofday(&sb->stamp);
+	 __net_timestamp(sb);
          vcc->push(vcc, sb);
          atomic_inc(&vcc->stats->rx);
          cell += ATM_CELL_PAYLOAD;
@@ -2346,7 +2346,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
             skb->destructor = ns_sb_destructor;
 #endif /* NS_USE_DESTRUCTORS */
             ATM_SKB(skb)->vcc = vcc;
-            do_gettimeofday(&skb->stamp);
+	    __net_timestamp(skb);
             vcc->push(vcc, skb);
             atomic_inc(&vcc->stats->rx);
          }
@@ -2373,7 +2373,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
                sb->destructor = ns_sb_destructor;
 #endif /* NS_USE_DESTRUCTORS */
                ATM_SKB(sb)->vcc = vcc;
-               do_gettimeofday(&sb->stamp);
+	       __net_timestamp(sb);
                vcc->push(vcc, sb);
                atomic_inc(&vcc->stats->rx);
             }
@@ -2398,7 +2398,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
                memcpy(skb->data, sb->data, NS_SMBUFSIZE);
                skb_put(skb, len - NS_SMBUFSIZE);
                ATM_SKB(skb)->vcc = vcc;
-               do_gettimeofday(&skb->stamp);
+	       __net_timestamp(skb);
                vcc->push(vcc, skb);
                atomic_inc(&vcc->stats->rx);
             }
@@ -2505,7 +2505,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
 #ifdef NS_USE_DESTRUCTORS
             hb->destructor = ns_hb_destructor;
 #endif /* NS_USE_DESTRUCTORS */
-            do_gettimeofday(&hb->stamp);
+	    __net_timestamp(hb);
             vcc->push(vcc, hb);
             atomic_inc(&vcc->stats->rx);
          }

commit 8728b834b226ffcf2c94a58530090e292af2a7bf
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Aug 9 19:25:21 2005 -0700

    [NET]: Kill skb->list
    
    Remove the "list" member of struct sk_buff, as it is entirely
    redundant.  All SKB list removal callers know which list the
    SKB is on, so storing this in sk_buff does nothing other than
    taking up some space.
    
    Two tricky bits were SCTP, which I took care of, and two ATM
    drivers which Francois Romieu <romieu@fr.zoreil.com> fixed
    up.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Francois Romieu <romieu@fr.zoreil.com>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index b2a7b754fd14..a0e3bd861f1c 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -214,8 +214,7 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev);
 static void __devinit ns_init_card_error(ns_dev *card, int error);
 static scq_info *get_scq(int size, u32 scd);
 static void free_scq(scq_info *scq, struct atm_vcc *vcc);
-static void push_rxbufs(ns_dev *card, u32 type, u32 handle1, u32 addr1,
-                       u32 handle2, u32 addr2);
+static void push_rxbufs(ns_dev *, struct sk_buff *);
 static irqreturn_t ns_irq_handler(int irq, void *dev_id, struct pt_regs *regs);
 static int ns_open(struct atm_vcc *vcc);
 static void ns_close(struct atm_vcc *vcc);
@@ -766,6 +765,7 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
          ns_init_card_error(card, error);
 	 return error;
       }
+      NS_SKB_CB(hb)->buf_type = BUF_NONE;
       skb_queue_tail(&card->hbpool.queue, hb);
       card->hbpool.count++;
    }
@@ -786,9 +786,10 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
          ns_init_card_error(card, error);
 	 return error;
       }
+      NS_SKB_CB(lb)->buf_type = BUF_LG;
       skb_queue_tail(&card->lbpool.queue, lb);
       skb_reserve(lb, NS_SMBUFSIZE);
-      push_rxbufs(card, BUF_LG, (u32) lb, (u32) virt_to_bus(lb->data), 0, 0);
+      push_rxbufs(card, lb);
       /* Due to the implementation of push_rxbufs() this is 1, not 0 */
       if (j == 1)
       {
@@ -822,9 +823,10 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
          ns_init_card_error(card, error);
 	 return error;
       }
+      NS_SKB_CB(sb)->buf_type = BUF_SM;
       skb_queue_tail(&card->sbpool.queue, sb);
       skb_reserve(sb, NS_AAL0_HEADER);
-      push_rxbufs(card, BUF_SM, (u32) sb, (u32) virt_to_bus(sb->data), 0, 0);
+      push_rxbufs(card, sb);
    }
    /* Test for strange behaviour which leads to crashes */
    if ((bcount = ns_stat_sfbqc_get(readl(card->membase + STAT))) < card->sbnr.min)
@@ -852,6 +854,7 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
          ns_init_card_error(card, error);
 	 return error;
       }
+      NS_SKB_CB(iovb)->buf_type = BUF_NONE;
       skb_queue_tail(&card->iovpool.queue, iovb);
       card->iovpool.count++;
    }
@@ -1078,12 +1081,18 @@ static void free_scq(scq_info *scq, struct atm_vcc *vcc)
 
 /* The handles passed must be pointers to the sk_buff containing the small
    or large buffer(s) cast to u32. */
-static void push_rxbufs(ns_dev *card, u32 type, u32 handle1, u32 addr1,
-                       u32 handle2, u32 addr2)
+static void push_rxbufs(ns_dev *card, struct sk_buff *skb)
 {
+   struct ns_skb_cb *cb = NS_SKB_CB(skb);
+   u32 handle1, addr1;
+   u32 handle2, addr2;
    u32 stat;
    unsigned long flags;
    
+   /* *BARF* */
+   handle2 = addr2 = 0;
+   handle1 = (u32)skb;
+   addr1 = (u32)virt_to_bus(skb->data);
 
 #ifdef GENERAL_DEBUG
    if (!addr1)
@@ -1093,7 +1102,7 @@ static void push_rxbufs(ns_dev *card, u32 type, u32 handle1, u32 addr1,
    stat = readl(card->membase + STAT);
    card->sbfqc = ns_stat_sfbqc_get(stat);
    card->lbfqc = ns_stat_lfbqc_get(stat);
-   if (type == BUF_SM)
+   if (cb->buf_type == BUF_SM)
    {
       if (!addr2)
       {
@@ -1111,7 +1120,7 @@ static void push_rxbufs(ns_dev *card, u32 type, u32 handle1, u32 addr1,
 	 }
       }      
    }
-   else /* type == BUF_LG */
+   else /* buf_type == BUF_LG */
    {
       if (!addr2)
       {
@@ -1132,26 +1141,26 @@ static void push_rxbufs(ns_dev *card, u32 type, u32 handle1, u32 addr1,
 
    if (addr2)
    {
-      if (type == BUF_SM)
+      if (cb->buf_type == BUF_SM)
       {
          if (card->sbfqc >= card->sbnr.max)
          {
-            skb_unlink((struct sk_buff *) handle1);
+            skb_unlink((struct sk_buff *) handle1, &card->sbpool.queue);
             dev_kfree_skb_any((struct sk_buff *) handle1);
-            skb_unlink((struct sk_buff *) handle2);
+            skb_unlink((struct sk_buff *) handle2, &card->sbpool.queue);
             dev_kfree_skb_any((struct sk_buff *) handle2);
             return;
          }
 	 else
             card->sbfqc += 2;
       }
-      else /* (type == BUF_LG) */
+      else /* (buf_type == BUF_LG) */
       {
          if (card->lbfqc >= card->lbnr.max)
          {
-            skb_unlink((struct sk_buff *) handle1);
+            skb_unlink((struct sk_buff *) handle1, &card->lbpool.queue);
             dev_kfree_skb_any((struct sk_buff *) handle1);
-            skb_unlink((struct sk_buff *) handle2);
+            skb_unlink((struct sk_buff *) handle2, &card->lbpool.queue);
             dev_kfree_skb_any((struct sk_buff *) handle2);
             return;
          }
@@ -1166,12 +1175,12 @@ static void push_rxbufs(ns_dev *card, u32 type, u32 handle1, u32 addr1,
       writel(handle2, card->membase + DR2);
       writel(addr1, card->membase + DR1);
       writel(handle1, card->membase + DR0);
-      writel(NS_CMD_WRITE_FREEBUFQ | (u32) type, card->membase + CMD);
+      writel(NS_CMD_WRITE_FREEBUFQ | cb->buf_type, card->membase + CMD);
  
       spin_unlock_irqrestore(&card->res_lock, flags);
 
       XPRINTK("nicstar%d: Pushing %s buffers at 0x%x and 0x%x.\n", card->index,
-              (type == BUF_SM ? "small" : "large"), addr1, addr2);
+              (cb->buf_type == BUF_SM ? "small" : "large"), addr1, addr2);
    }
 
    if (!card->efbie && card->sbfqc >= card->sbnr.min &&
@@ -1322,9 +1331,10 @@ static irqreturn_t ns_irq_handler(int irq, void *dev_id, struct pt_regs *regs)
             card->efbie = 0;
             break;
          }
+         NS_SKB_CB(sb)->buf_type = BUF_SM;
          skb_queue_tail(&card->sbpool.queue, sb);
          skb_reserve(sb, NS_AAL0_HEADER);
-         push_rxbufs(card, BUF_SM, (u32) sb, (u32) virt_to_bus(sb->data), 0, 0);
+         push_rxbufs(card, sb);
       }
       card->sbfqc = i;
       process_rsq(card);
@@ -1348,9 +1358,10 @@ static irqreturn_t ns_irq_handler(int irq, void *dev_id, struct pt_regs *regs)
             card->efbie = 0;
             break;
          }
+         NS_SKB_CB(lb)->buf_type = BUF_LG;
          skb_queue_tail(&card->lbpool.queue, lb);
          skb_reserve(lb, NS_SMBUFSIZE);
-         push_rxbufs(card, BUF_LG, (u32) lb, (u32) virt_to_bus(lb->data), 0, 0);
+         push_rxbufs(card, lb);
       }
       card->lbfqc = i;
       process_rsq(card);
@@ -2227,6 +2238,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
             recycle_rx_buf(card, skb);
             return;
 	 }
+         NS_SKB_CB(iovb)->buf_type = BUF_NONE;
       }
       else
          if (--card->iovpool.count < card->iovnr.min)
@@ -2234,6 +2246,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
 	    struct sk_buff *new_iovb;
 	    if ((new_iovb = alloc_skb(NS_IOVBUFSIZE, GFP_ATOMIC)) != NULL)
 	    {
+               NS_SKB_CB(iovb)->buf_type = BUF_NONE;
                skb_queue_tail(&card->iovpool.queue, new_iovb);
                card->iovpool.count++;
 	    }
@@ -2264,7 +2277,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
 
    if (NS_SKB(iovb)->iovcnt == 1)
    {
-      if (skb->list != &card->sbpool.queue)
+      if (NS_SKB_CB(skb)->buf_type != BUF_SM)
       {
          printk("nicstar%d: Expected a small buffer, and this is not one.\n",
 	        card->index);
@@ -2278,7 +2291,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
    }
    else /* NS_SKB(iovb)->iovcnt >= 2 */
    {
-      if (skb->list != &card->lbpool.queue)
+      if (NS_SKB_CB(skb)->buf_type != BUF_LG)
       {
          printk("nicstar%d: Expected a large buffer, and this is not one.\n",
 	        card->index);
@@ -2322,8 +2335,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
          /* skb points to a small buffer */
          if (!atm_charge(vcc, skb->truesize))
          {
-            push_rxbufs(card, BUF_SM, (u32) skb, (u32) virt_to_bus(skb->data),
-                        0, 0);
+            push_rxbufs(card, skb);
             atomic_inc(&vcc->stats->rx_drop);
          }
          else
@@ -2350,8 +2362,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
 	 {
             if (!atm_charge(vcc, sb->truesize))
             {
-               push_rxbufs(card, BUF_SM, (u32) sb, (u32) virt_to_bus(sb->data),
-                           0, 0);
+               push_rxbufs(card, sb);
                atomic_inc(&vcc->stats->rx_drop);
             }
             else
@@ -2367,16 +2378,14 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
                atomic_inc(&vcc->stats->rx);
             }
 
-            push_rxbufs(card, BUF_LG, (u32) skb,
-	                   (u32) virt_to_bus(skb->data), 0, 0);
+            push_rxbufs(card, skb);
 
 	 }
 	 else			/* len > NS_SMBUFSIZE, the usual case */
 	 {
             if (!atm_charge(vcc, skb->truesize))
             {
-               push_rxbufs(card, BUF_LG, (u32) skb,
-                           (u32) virt_to_bus(skb->data), 0, 0);
+               push_rxbufs(card, skb);
                atomic_inc(&vcc->stats->rx_drop);
             }
             else
@@ -2394,8 +2403,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
                atomic_inc(&vcc->stats->rx);
             }
 
-            push_rxbufs(card, BUF_SM, (u32) sb, (u32) virt_to_bus(sb->data),
-                        0, 0);
+            push_rxbufs(card, sb);
 
          }
 	 
@@ -2430,6 +2438,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
                   card->hbpool.count++;
                }
             }
+            NS_SKB_CB(hb)->buf_type = BUF_NONE;
 	 }
 	 else
          if (--card->hbpool.count < card->hbnr.min)
@@ -2437,6 +2446,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
             struct sk_buff *new_hb;
             if ((new_hb = dev_alloc_skb(NS_HBUFSIZE)) != NULL)
             {
+               NS_SKB_CB(new_hb)->buf_type = BUF_NONE;
                skb_queue_tail(&card->hbpool.queue, new_hb);
                card->hbpool.count++;
             }
@@ -2444,6 +2454,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
 	    {
                if ((new_hb = dev_alloc_skb(NS_HBUFSIZE)) != NULL)
                {
+                  NS_SKB_CB(new_hb)->buf_type = BUF_NONE;
                   skb_queue_tail(&card->hbpool.queue, new_hb);
                   card->hbpool.count++;
                }
@@ -2473,8 +2484,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
             remaining = len - iov->iov_len;
             iov++;
             /* Free the small buffer */
-            push_rxbufs(card, BUF_SM, (u32) sb, (u32) virt_to_bus(sb->data),
-                        0, 0);
+            push_rxbufs(card, sb);
 
             /* Copy all large buffers to the huge buffer and free them */
             for (j = 1; j < NS_SKB(iovb)->iovcnt; j++)
@@ -2485,8 +2495,7 @@ static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
                skb_put(hb, tocopy);
                iov++;
                remaining -= tocopy;
-               push_rxbufs(card, BUF_LG, (u32) lb,
-                           (u32) virt_to_bus(lb->data), 0, 0);
+               push_rxbufs(card, lb);
             }
 #ifdef EXTRA_DEBUG
             if (remaining != 0 || hb->len != len)
@@ -2527,9 +2536,10 @@ static void ns_sb_destructor(struct sk_buff *sb)
       sb = __dev_alloc_skb(NS_SMSKBSIZE, GFP_KERNEL);
       if (sb == NULL)
          break;
+      NS_SKB_CB(sb)->buf_type = BUF_SM;
       skb_queue_tail(&card->sbpool.queue, sb);
       skb_reserve(sb, NS_AAL0_HEADER);
-      push_rxbufs(card, BUF_SM, (u32) sb, (u32) virt_to_bus(sb->data), 0, 0);
+      push_rxbufs(card, sb);
    } while (card->sbfqc < card->sbnr.min);
 }
 
@@ -2550,9 +2560,10 @@ static void ns_lb_destructor(struct sk_buff *lb)
       lb = __dev_alloc_skb(NS_LGSKBSIZE, GFP_KERNEL);
       if (lb == NULL)
          break;
+      NS_SKB_CB(lb)->buf_type = BUF_LG;
       skb_queue_tail(&card->lbpool.queue, lb);
       skb_reserve(lb, NS_SMBUFSIZE);
-      push_rxbufs(card, BUF_LG, (u32) lb, (u32) virt_to_bus(lb->data), 0, 0);
+      push_rxbufs(card, lb);
    } while (card->lbfqc < card->lbnr.min);
 }
 
@@ -2569,6 +2580,7 @@ static void ns_hb_destructor(struct sk_buff *hb)
       hb = __dev_alloc_skb(NS_HBUFSIZE, GFP_KERNEL);
       if (hb == NULL)
          break;
+      NS_SKB_CB(hb)->buf_type = BUF_NONE;
       skb_queue_tail(&card->hbpool.queue, hb);
       card->hbpool.count++;
    }
@@ -2577,45 +2589,25 @@ static void ns_hb_destructor(struct sk_buff *hb)
 #endif /* NS_USE_DESTRUCTORS */
 
 
-
 static void recycle_rx_buf(ns_dev *card, struct sk_buff *skb)
 {
-   if (skb->list == &card->sbpool.queue)
-      push_rxbufs(card, BUF_SM, (u32) skb, (u32) virt_to_bus(skb->data), 0, 0);
-   else if (skb->list == &card->lbpool.queue)
-      push_rxbufs(card, BUF_LG, (u32) skb, (u32) virt_to_bus(skb->data), 0, 0);
-   else
-   {
-      printk("nicstar%d: What kind of rx buffer is this?\n", card->index);
-      dev_kfree_skb_any(skb);
-   }
-}
+	struct ns_skb_cb *cb = NS_SKB_CB(skb);
 
+	if (unlikely(cb->buf_type == BUF_NONE)) {
+		printk("nicstar%d: What kind of rx buffer is this?\n", card->index);
+		dev_kfree_skb_any(skb);
+	} else
+		push_rxbufs(card, skb);
+}
 
 
 static void recycle_iovec_rx_bufs(ns_dev *card, struct iovec *iov, int count)
 {
-   struct sk_buff *skb;
-
-   for (; count > 0; count--)
-   {
-      skb = (struct sk_buff *) (iov++)->iov_base;
-      if (skb->list == &card->sbpool.queue)
-         push_rxbufs(card, BUF_SM, (u32) skb, (u32) virt_to_bus(skb->data),
-	             0, 0);
-      else if (skb->list == &card->lbpool.queue)
-         push_rxbufs(card, BUF_LG, (u32) skb, (u32) virt_to_bus(skb->data),
-	             0, 0);
-      else
-      {
-         printk("nicstar%d: What kind of rx buffer is this?\n", card->index);
-         dev_kfree_skb_any(skb);
-      }
-   }
+	while (count-- > 0)
+		recycle_rx_buf(card, (struct sk_buff *) (iov++)->iov_base);
 }
 
 
-
 static void recycle_iov_buf(ns_dev *card, struct sk_buff *iovb)
 {
    if (card->iovpool.count < card->iovnr.max)
@@ -2631,7 +2623,7 @@ static void recycle_iov_buf(ns_dev *card, struct sk_buff *iovb)
 
 static void dequeue_sm_buf(ns_dev *card, struct sk_buff *sb)
 {
-   skb_unlink(sb);
+   skb_unlink(sb, &card->sbpool.queue);
 #ifdef NS_USE_DESTRUCTORS
    if (card->sbfqc < card->sbnr.min)
 #else
@@ -2640,10 +2632,10 @@ static void dequeue_sm_buf(ns_dev *card, struct sk_buff *sb)
       struct sk_buff *new_sb;
       if ((new_sb = dev_alloc_skb(NS_SMSKBSIZE)) != NULL)
       {
+         NS_SKB_CB(new_sb)->buf_type = BUF_SM;
          skb_queue_tail(&card->sbpool.queue, new_sb);
          skb_reserve(new_sb, NS_AAL0_HEADER);
-         push_rxbufs(card, BUF_SM, (u32) new_sb,
-                     (u32) virt_to_bus(new_sb->data), 0, 0);
+         push_rxbufs(card, new_sb);
       }
    }
    if (card->sbfqc < card->sbnr.init)
@@ -2652,10 +2644,10 @@ static void dequeue_sm_buf(ns_dev *card, struct sk_buff *sb)
       struct sk_buff *new_sb;
       if ((new_sb = dev_alloc_skb(NS_SMSKBSIZE)) != NULL)
       {
+         NS_SKB_CB(new_sb)->buf_type = BUF_SM;
          skb_queue_tail(&card->sbpool.queue, new_sb);
          skb_reserve(new_sb, NS_AAL0_HEADER);
-         push_rxbufs(card, BUF_SM, (u32) new_sb,
-                     (u32) virt_to_bus(new_sb->data), 0, 0);
+         push_rxbufs(card, new_sb);
       }
    }
 }
@@ -2664,7 +2656,7 @@ static void dequeue_sm_buf(ns_dev *card, struct sk_buff *sb)
 
 static void dequeue_lg_buf(ns_dev *card, struct sk_buff *lb)
 {
-   skb_unlink(lb);
+   skb_unlink(lb, &card->lbpool.queue);
 #ifdef NS_USE_DESTRUCTORS
    if (card->lbfqc < card->lbnr.min)
 #else
@@ -2673,10 +2665,10 @@ static void dequeue_lg_buf(ns_dev *card, struct sk_buff *lb)
       struct sk_buff *new_lb;
       if ((new_lb = dev_alloc_skb(NS_LGSKBSIZE)) != NULL)
       {
+         NS_SKB_CB(new_lb)->buf_type = BUF_LG;
          skb_queue_tail(&card->lbpool.queue, new_lb);
          skb_reserve(new_lb, NS_SMBUFSIZE);
-         push_rxbufs(card, BUF_LG, (u32) new_lb,
-                     (u32) virt_to_bus(new_lb->data), 0, 0);
+         push_rxbufs(card, new_lb);
       }
    }
    if (card->lbfqc < card->lbnr.init)
@@ -2685,10 +2677,10 @@ static void dequeue_lg_buf(ns_dev *card, struct sk_buff *lb)
       struct sk_buff *new_lb;
       if ((new_lb = dev_alloc_skb(NS_LGSKBSIZE)) != NULL)
       {
+         NS_SKB_CB(new_lb)->buf_type = BUF_LG;
          skb_queue_tail(&card->lbpool.queue, new_lb);
          skb_reserve(new_lb, NS_SMBUFSIZE);
-         push_rxbufs(card, BUF_LG, (u32) new_lb,
-                     (u32) virt_to_bus(new_lb->data), 0, 0);
+         push_rxbufs(card, new_lb);
       }
    }
 }
@@ -2880,9 +2872,10 @@ static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)
                   sb = __dev_alloc_skb(NS_SMSKBSIZE, GFP_KERNEL);
                   if (sb == NULL)
                      return -ENOMEM;
+                  NS_SKB_CB(sb)->buf_type = BUF_SM;
                   skb_queue_tail(&card->sbpool.queue, sb);
                   skb_reserve(sb, NS_AAL0_HEADER);
-                  push_rxbufs(card, BUF_SM, (u32) sb, (u32) virt_to_bus(sb->data), 0, 0);
+                  push_rxbufs(card, sb);
 	       }
 	       break;
 
@@ -2894,9 +2887,10 @@ static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)
                   lb = __dev_alloc_skb(NS_LGSKBSIZE, GFP_KERNEL);
                   if (lb == NULL)
                      return -ENOMEM;
+                  NS_SKB_CB(lb)->buf_type = BUF_LG;
                   skb_queue_tail(&card->lbpool.queue, lb);
                   skb_reserve(lb, NS_SMBUFSIZE);
-                  push_rxbufs(card, BUF_LG, (u32) lb, (u32) virt_to_bus(lb->data), 0, 0);
+                  push_rxbufs(card, lb);
 	       }
 	       break;
 
@@ -2923,6 +2917,7 @@ static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)
                   hb = __dev_alloc_skb(NS_HBUFSIZE, GFP_KERNEL);
                   if (hb == NULL)
                      return -ENOMEM;
+                  NS_SKB_CB(hb)->buf_type = BUF_NONE;
                   ns_grab_int_lock(card, flags);
                   skb_queue_tail(&card->hbpool.queue, hb);
                   card->hbpool.count++;
@@ -2953,6 +2948,7 @@ static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)
                   iovb = alloc_skb(NS_IOVBUFSIZE, GFP_KERNEL);
                   if (iovb == NULL)
                      return -ENOMEM;
+                  NS_SKB_CB(iovb)->buf_type = BUF_NONE;
                   ns_grab_int_lock(card, flags);
                   skb_queue_tail(&card->iovpool.queue, iovb);
                   card->iovpool.count++;
@@ -2979,17 +2975,12 @@ static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)
 }
 
 
-
 static void which_list(ns_dev *card, struct sk_buff *skb)
 {
-   printk("It's a %s buffer.\n", skb->list == &card->sbpool.queue ?
-          "small" : skb->list == &card->lbpool.queue ? "large" :
-	  skb->list == &card->hbpool.queue ? "huge" :
-	  skb->list == &card->iovpool.queue ? "iovec" : "unknown");
+	printk("skb buf_type: 0x%08x\n", NS_SKB_CB(skb)->buf_type);
 }
 
 
-
 static void ns_poll(unsigned long arg)
 {
    int i;

commit a2c1aa54746bace5d03cc66521fbf3bb6fb2f916
Author: Jesper Juhl <juhl-lkml@dif.dk>
Date:   Thu Jun 2 13:04:07 2005 -0700

    [ATM]: [drivers] kill pointless NULL checks and casts before kfree()
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
index 85bf5c8442b0..b2a7b754fd14 100644
--- a/drivers/atm/nicstar.c
+++ b/drivers/atm/nicstar.c
@@ -676,10 +676,10 @@ static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
    PRINTK("nicstar%d: RSQ base at 0x%x.\n", i, (u32) card->rsq.base);
       
    /* Initialize SCQ0, the only VBR SCQ used */
-   card->scq1 = (scq_info *) NULL;
-   card->scq2 = (scq_info *) NULL;
+   card->scq1 = NULL;
+   card->scq2 = NULL;
    card->scq0 = get_scq(VBR_SCQSIZE, NS_VRSCD0);
-   if (card->scq0 == (scq_info *) NULL)
+   if (card->scq0 == NULL)
    {
       printk("nicstar%d: can't get SCQ0.\n", i);
       error = 12;
@@ -993,24 +993,24 @@ static scq_info *get_scq(int size, u32 scd)
    int i;
 
    if (size != VBR_SCQSIZE && size != CBR_SCQSIZE)
-      return (scq_info *) NULL;
+      return NULL;
 
    scq = (scq_info *) kmalloc(sizeof(scq_info), GFP_KERNEL);
-   if (scq == (scq_info *) NULL)
-      return (scq_info *) NULL;
+   if (scq == NULL)
+      return NULL;
    scq->org = kmalloc(2 * size, GFP_KERNEL);
    if (scq->org == NULL)
    {
       kfree(scq);
-      return (scq_info *) NULL;
+      return NULL;
    }
    scq->skb = (struct sk_buff **) kmalloc(sizeof(struct sk_buff *) *
                                           (size / NS_SCQE_SIZE), GFP_KERNEL);
-   if (scq->skb == (struct sk_buff **) NULL)
+   if (scq->skb == NULL)
    {
       kfree(scq->org);
       kfree(scq);
-      return (scq_info *) NULL;
+      return NULL;
    }
    scq->num_entries = size / NS_SCQE_SIZE;
    scq->base = (ns_scqe *) ALIGN_ADDRESS(scq->org, size);
@@ -1498,7 +1498,7 @@ static int ns_open(struct atm_vcc *vcc)
          vc->cbr_scd = NS_FRSCD + frscdi * NS_FRSCD_SIZE;
 
          scq = get_scq(CBR_SCQSIZE, vc->cbr_scd);
-         if (scq == (scq_info *) NULL)
+         if (scq == NULL)
          {
             PRINTK("nicstar%d: can't get fixed rate SCQ.\n", card->index);
             card->scd2vc[frscdi] = NULL;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/atm/nicstar.c b/drivers/atm/nicstar.c
new file mode 100644
index 000000000000..85bf5c8442b0
--- /dev/null
+++ b/drivers/atm/nicstar.c
@@ -0,0 +1,3105 @@
+/******************************************************************************
+ *
+ * nicstar.c
+ *
+ * Device driver supporting CBR for IDT 77201/77211 "NICStAR" based cards.
+ *
+ * IMPORTANT: The included file nicstarmac.c was NOT WRITTEN BY ME.
+ *            It was taken from the frle-0.22 device driver.
+ *            As the file doesn't have a copyright notice, in the file
+ *            nicstarmac.copyright I put the copyright notice from the
+ *            frle-0.22 device driver.
+ *            Some code is based on the nicstar driver by M. Welsh.
+ *
+ * Author: Rui Prior (rprior@inescn.pt)
+ * PowerPC support by Jay Talbott (jay_talbott@mcg.mot.com) April 1999
+ *
+ *
+ * (C) INESC 1999
+ *
+ *
+ ******************************************************************************/
+
+
+/**** IMPORTANT INFORMATION ***************************************************
+ *
+ * There are currently three types of spinlocks:
+ *
+ * 1 - Per card interrupt spinlock (to protect structures and such)
+ * 2 - Per SCQ scq spinlock
+ * 3 - Per card resource spinlock (to access registers, etc.)
+ *
+ * These must NEVER be grabbed in reverse order.
+ *
+ ******************************************************************************/
+
+/* Header files ***************************************************************/
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/skbuff.h>
+#include <linux/atmdev.h>
+#include <linux/atm.h>
+#include <linux/pci.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/bitops.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/atomic.h>
+#include "nicstar.h"
+#ifdef CONFIG_ATM_NICSTAR_USE_SUNI
+#include "suni.h"
+#endif /* CONFIG_ATM_NICSTAR_USE_SUNI */
+#ifdef CONFIG_ATM_NICSTAR_USE_IDT77105
+#include "idt77105.h"
+#endif /* CONFIG_ATM_NICSTAR_USE_IDT77105 */
+
+#if BITS_PER_LONG != 32
+#  error FIXME: this driver requires a 32-bit platform
+#endif
+
+/* Additional code ************************************************************/
+
+#include "nicstarmac.c"
+
+
+/* Configurable parameters ****************************************************/
+
+#undef PHY_LOOPBACK
+#undef TX_DEBUG
+#undef RX_DEBUG
+#undef GENERAL_DEBUG
+#undef EXTRA_DEBUG
+
+#undef NS_USE_DESTRUCTORS /* For now keep this undefined unless you know
+                             you're going to use only raw ATM */
+
+
+/* Do not touch these *********************************************************/
+
+#ifdef TX_DEBUG
+#define TXPRINTK(args...) printk(args)
+#else
+#define TXPRINTK(args...)
+#endif /* TX_DEBUG */
+
+#ifdef RX_DEBUG
+#define RXPRINTK(args...) printk(args)
+#else
+#define RXPRINTK(args...)
+#endif /* RX_DEBUG */
+
+#ifdef GENERAL_DEBUG
+#define PRINTK(args...) printk(args)
+#else
+#define PRINTK(args...)
+#endif /* GENERAL_DEBUG */
+
+#ifdef EXTRA_DEBUG
+#define XPRINTK(args...) printk(args)
+#else
+#define XPRINTK(args...)
+#endif /* EXTRA_DEBUG */
+
+
+/* Macros *********************************************************************/
+
+#define CMD_BUSY(card) (readl((card)->membase + STAT) & NS_STAT_CMDBZ)
+
+#define NS_DELAY mdelay(1)
+
+#define ALIGN_BUS_ADDR(addr, alignment) \
+        ((((u32) (addr)) + (((u32) (alignment)) - 1)) & ~(((u32) (alignment)) - 1))
+#define ALIGN_ADDRESS(addr, alignment) \
+        bus_to_virt(ALIGN_BUS_ADDR(virt_to_bus(addr), alignment))
+
+#undef CEIL
+
+#ifndef ATM_SKB
+#define ATM_SKB(s) (&(s)->atm)
+#endif
+
+   /* Spinlock debugging stuff */
+#ifdef NS_DEBUG_SPINLOCKS /* See nicstar.h */
+#define ns_grab_int_lock(card,flags) \
+ do { \
+    unsigned long nsdsf, nsdsf2; \
+    local_irq_save(flags); \
+    save_flags(nsdsf); cli();\
+    if (nsdsf & (1<<9)) printk ("nicstar.c: ints %sabled -> enabled.\n", \
+                                (flags)&(1<<9)?"en":"dis"); \
+    if (spin_is_locked(&(card)->int_lock) && \
+        (card)->cpu_int == smp_processor_id()) { \
+       printk("nicstar.c: line %d (cpu %d) int_lock already locked at line %d (cpu %d)\n", \
+              __LINE__, smp_processor_id(), (card)->has_int_lock, \
+              (card)->cpu_int); \
+       printk("nicstar.c: ints were %sabled.\n", ((flags)&(1<<9)?"en":"dis")); \
+    } \
+    if (spin_is_locked(&(card)->res_lock) && \
+        (card)->cpu_res == smp_processor_id()) { \
+       printk("nicstar.c: line %d (cpu %d) res_lock locked at line %d (cpu %d)(trying int)\n", \
+              __LINE__, smp_processor_id(), (card)->has_res_lock, \
+              (card)->cpu_res); \
+       printk("nicstar.c: ints were %sabled.\n", ((flags)&(1<<9)?"en":"dis")); \
+    } \
+    spin_lock_irq(&(card)->int_lock); \
+    (card)->has_int_lock = __LINE__; \
+    (card)->cpu_int = smp_processor_id(); \
+    restore_flags(nsdsf); } while (0)
+#define ns_grab_res_lock(card,flags) \
+ do { \
+    unsigned long nsdsf, nsdsf2; \
+    local_irq_save(flags); \
+    save_flags(nsdsf); cli();\
+    if (nsdsf & (1<<9)) printk ("nicstar.c: ints %sabled -> enabled.\n", \
+                                (flags)&(1<<9)?"en":"dis"); \
+    if (spin_is_locked(&(card)->res_lock) && \
+        (card)->cpu_res == smp_processor_id()) { \
+       printk("nicstar.c: line %d (cpu %d) res_lock already locked at line %d (cpu %d)\n", \
+              __LINE__, smp_processor_id(), (card)->has_res_lock, \
+              (card)->cpu_res); \
+       printk("nicstar.c: ints were %sabled.\n", ((flags)&(1<<9)?"en":"dis")); \
+    } \
+    spin_lock_irq(&(card)->res_lock); \
+    (card)->has_res_lock = __LINE__; \
+    (card)->cpu_res = smp_processor_id(); \
+    restore_flags(nsdsf); } while (0)
+#define ns_grab_scq_lock(card,scq,flags) \
+ do { \
+    unsigned long nsdsf, nsdsf2; \
+    local_irq_save(flags); \
+    save_flags(nsdsf); cli();\
+    if (nsdsf & (1<<9)) printk ("nicstar.c: ints %sabled -> enabled.\n", \
+                                (flags)&(1<<9)?"en":"dis"); \
+    if (spin_is_locked(&(scq)->lock) && \
+        (scq)->cpu_lock == smp_processor_id()) { \
+       printk("nicstar.c: line %d (cpu %d) this scq_lock already locked at line %d (cpu %d)\n", \
+              __LINE__, smp_processor_id(), (scq)->has_lock, \
+              (scq)->cpu_lock); \
+       printk("nicstar.c: ints were %sabled.\n", ((flags)&(1<<9)?"en":"dis")); \
+    } \
+    if (spin_is_locked(&(card)->res_lock) && \
+        (card)->cpu_res == smp_processor_id()) { \
+       printk("nicstar.c: line %d (cpu %d) res_lock locked at line %d (cpu %d)(trying scq)\n", \
+              __LINE__, smp_processor_id(), (card)->has_res_lock, \
+              (card)->cpu_res); \
+       printk("nicstar.c: ints were %sabled.\n", ((flags)&(1<<9)?"en":"dis")); \
+    } \
+    spin_lock_irq(&(scq)->lock); \
+    (scq)->has_lock = __LINE__; \
+    (scq)->cpu_lock = smp_processor_id(); \
+    restore_flags(nsdsf); } while (0)
+#else /* !NS_DEBUG_SPINLOCKS */
+#define ns_grab_int_lock(card,flags) \
+        spin_lock_irqsave(&(card)->int_lock,(flags))
+#define ns_grab_res_lock(card,flags) \
+        spin_lock_irqsave(&(card)->res_lock,(flags))
+#define ns_grab_scq_lock(card,scq,flags) \
+        spin_lock_irqsave(&(scq)->lock,flags)
+#endif /* NS_DEBUG_SPINLOCKS */
+
+
+/* Function declarations ******************************************************/
+
+static u32 ns_read_sram(ns_dev *card, u32 sram_address);
+static void ns_write_sram(ns_dev *card, u32 sram_address, u32 *value, int count);
+static int __devinit ns_init_card(int i, struct pci_dev *pcidev);
+static void __devinit ns_init_card_error(ns_dev *card, int error);
+static scq_info *get_scq(int size, u32 scd);
+static void free_scq(scq_info *scq, struct atm_vcc *vcc);
+static void push_rxbufs(ns_dev *card, u32 type, u32 handle1, u32 addr1,
+                       u32 handle2, u32 addr2);
+static irqreturn_t ns_irq_handler(int irq, void *dev_id, struct pt_regs *regs);
+static int ns_open(struct atm_vcc *vcc);
+static void ns_close(struct atm_vcc *vcc);
+static void fill_tst(ns_dev *card, int n, vc_map *vc);
+static int ns_send(struct atm_vcc *vcc, struct sk_buff *skb);
+static int push_scqe(ns_dev *card, vc_map *vc, scq_info *scq, ns_scqe *tbd,
+                     struct sk_buff *skb);
+static void process_tsq(ns_dev *card);
+static void drain_scq(ns_dev *card, scq_info *scq, int pos);
+static void process_rsq(ns_dev *card);
+static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe);
+#ifdef NS_USE_DESTRUCTORS
+static void ns_sb_destructor(struct sk_buff *sb);
+static void ns_lb_destructor(struct sk_buff *lb);
+static void ns_hb_destructor(struct sk_buff *hb);
+#endif /* NS_USE_DESTRUCTORS */
+static void recycle_rx_buf(ns_dev *card, struct sk_buff *skb);
+static void recycle_iovec_rx_bufs(ns_dev *card, struct iovec *iov, int count);
+static void recycle_iov_buf(ns_dev *card, struct sk_buff *iovb);
+static void dequeue_sm_buf(ns_dev *card, struct sk_buff *sb);
+static void dequeue_lg_buf(ns_dev *card, struct sk_buff *lb);
+static int ns_proc_read(struct atm_dev *dev, loff_t *pos, char *page);
+static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg);
+static void which_list(ns_dev *card, struct sk_buff *skb);
+static void ns_poll(unsigned long arg);
+static int ns_parse_mac(char *mac, unsigned char *esi);
+static short ns_h2i(char c);
+static void ns_phy_put(struct atm_dev *dev, unsigned char value,
+                       unsigned long addr);
+static unsigned char ns_phy_get(struct atm_dev *dev, unsigned long addr);
+
+
+
+/* Global variables ***********************************************************/
+
+static struct ns_dev *cards[NS_MAX_CARDS];
+static unsigned num_cards;
+static struct atmdev_ops atm_ops =
+{
+   .open	= ns_open,
+   .close	= ns_close,
+   .ioctl	= ns_ioctl,
+   .send	= ns_send,
+   .phy_put	= ns_phy_put,
+   .phy_get	= ns_phy_get,
+   .proc_read	= ns_proc_read,
+   .owner	= THIS_MODULE,
+};
+static struct timer_list ns_timer;
+static char *mac[NS_MAX_CARDS];
+module_param_array(mac, charp, NULL, 0);
+MODULE_LICENSE("GPL");
+
+
+/* Functions*******************************************************************/
+
+static int __devinit nicstar_init_one(struct pci_dev *pcidev,
+				      const struct pci_device_id *ent)
+{
+   static int index = -1;
+   unsigned int error;
+
+   index++;
+   cards[index] = NULL;
+
+   error = ns_init_card(index, pcidev);
+   if (error) {
+      cards[index--] = NULL;	/* don't increment index */
+      goto err_out;
+   }
+
+   return 0;
+err_out:
+   return -ENODEV;
+}
+
+
+
+static void __devexit nicstar_remove_one(struct pci_dev *pcidev)
+{
+   int i, j;
+   ns_dev *card = pci_get_drvdata(pcidev);
+   struct sk_buff *hb;
+   struct sk_buff *iovb;
+   struct sk_buff *lb;
+   struct sk_buff *sb;
+   
+   i = card->index;
+
+   if (cards[i] == NULL)
+      return;
+
+   if (card->atmdev->phy && card->atmdev->phy->stop)
+      card->atmdev->phy->stop(card->atmdev);
+
+   /* Stop everything */
+   writel(0x00000000, card->membase + CFG);
+
+   /* De-register device */
+   atm_dev_deregister(card->atmdev);
+
+   /* Disable PCI device */
+   pci_disable_device(pcidev);
+   
+   /* Free up resources */
+   j = 0;
+   PRINTK("nicstar%d: freeing %d huge buffers.\n", i, card->hbpool.count);
+   while ((hb = skb_dequeue(&card->hbpool.queue)) != NULL)
+   {
+      dev_kfree_skb_any(hb);
+      j++;
+   }
+   PRINTK("nicstar%d: %d huge buffers freed.\n", i, j);
+   j = 0;
+   PRINTK("nicstar%d: freeing %d iovec buffers.\n", i, card->iovpool.count);
+   while ((iovb = skb_dequeue(&card->iovpool.queue)) != NULL)
+   {
+      dev_kfree_skb_any(iovb);
+      j++;
+   }
+   PRINTK("nicstar%d: %d iovec buffers freed.\n", i, j);
+   while ((lb = skb_dequeue(&card->lbpool.queue)) != NULL)
+      dev_kfree_skb_any(lb);
+   while ((sb = skb_dequeue(&card->sbpool.queue)) != NULL)
+      dev_kfree_skb_any(sb);
+   free_scq(card->scq0, NULL);
+   for (j = 0; j < NS_FRSCD_NUM; j++)
+   {
+      if (card->scd2vc[j] != NULL)
+         free_scq(card->scd2vc[j]->scq, card->scd2vc[j]->tx_vcc);
+   }
+   kfree(card->rsq.org);
+   kfree(card->tsq.org);
+   free_irq(card->pcidev->irq, card);
+   iounmap(card->membase);
+   kfree(card);
+}
+
+
+
+static struct pci_device_id nicstar_pci_tbl[] __devinitdata =
+{
+	{PCI_VENDOR_ID_IDT, PCI_DEVICE_ID_IDT_IDT77201,
+	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{0,}			/* terminate list */
+};
+MODULE_DEVICE_TABLE(pci, nicstar_pci_tbl);
+
+
+
+static struct pci_driver nicstar_driver = {
+	.name		= "nicstar",
+	.id_table	= nicstar_pci_tbl,
+	.probe		= nicstar_init_one,
+	.remove		= __devexit_p(nicstar_remove_one),
+};
+
+
+
+static int __init nicstar_init(void)
+{
+   unsigned error = 0;	/* Initialized to remove compile warning */
+
+   XPRINTK("nicstar: nicstar_init() called.\n");
+
+   error = pci_register_driver(&nicstar_driver);
+   
+   TXPRINTK("nicstar: TX debug enabled.\n");
+   RXPRINTK("nicstar: RX debug enabled.\n");
+   PRINTK("nicstar: General debug enabled.\n");
+#ifdef PHY_LOOPBACK
+   printk("nicstar: using PHY loopback.\n");
+#endif /* PHY_LOOPBACK */
+   XPRINTK("nicstar: nicstar_init() returned.\n");
+
+   if (!error) {
+      init_timer(&ns_timer);
+      ns_timer.expires = jiffies + NS_POLL_PERIOD;
+      ns_timer.data = 0UL;
+      ns_timer.function = ns_poll;
+      add_timer(&ns_timer);
+   }
+   
+   return error;
+}
+
+
+
+static void __exit nicstar_cleanup(void)
+{
+   XPRINTK("nicstar: nicstar_cleanup() called.\n");
+
+   del_timer(&ns_timer);
+
+   pci_unregister_driver(&nicstar_driver);
+
+   XPRINTK("nicstar: nicstar_cleanup() returned.\n");
+}
+
+
+
+static u32 ns_read_sram(ns_dev *card, u32 sram_address)
+{
+   unsigned long flags;
+   u32 data;
+   sram_address <<= 2;
+   sram_address &= 0x0007FFFC;	/* address must be dword aligned */
+   sram_address |= 0x50000000;	/* SRAM read command */
+   ns_grab_res_lock(card, flags);
+   while (CMD_BUSY(card));
+   writel(sram_address, card->membase + CMD);
+   while (CMD_BUSY(card));
+   data = readl(card->membase + DR0);
+   spin_unlock_irqrestore(&card->res_lock, flags);
+   return data;
+}
+
+
+   
+static void ns_write_sram(ns_dev *card, u32 sram_address, u32 *value, int count)
+{
+   unsigned long flags;
+   int i, c;
+   count--;	/* count range now is 0..3 instead of 1..4 */
+   c = count;
+   c <<= 2;	/* to use increments of 4 */
+   ns_grab_res_lock(card, flags);
+   while (CMD_BUSY(card));
+   for (i = 0; i <= c; i += 4)
+      writel(*(value++), card->membase + i);
+   /* Note: DR# registers are the first 4 dwords in nicstar's memspace,
+            so card->membase + DR0 == card->membase */
+   sram_address <<= 2;
+   sram_address &= 0x0007FFFC;
+   sram_address |= (0x40000000 | count);
+   writel(sram_address, card->membase + CMD);
+   spin_unlock_irqrestore(&card->res_lock, flags);
+}
+
+
+static int __devinit ns_init_card(int i, struct pci_dev *pcidev)
+{
+   int j;
+   struct ns_dev *card = NULL;
+   unsigned char pci_latency;
+   unsigned error;
+   u32 data;
+   u32 u32d[4];
+   u32 ns_cfg_rctsize;
+   int bcount;
+   unsigned long membase;
+
+   error = 0;
+
+   if (pci_enable_device(pcidev))
+   {
+      printk("nicstar%d: can't enable PCI device\n", i);
+      error = 2;
+      ns_init_card_error(card, error);
+      return error;
+   }
+
+   if ((card = kmalloc(sizeof(ns_dev), GFP_KERNEL)) == NULL)
+   {
+      printk("nicstar%d: can't allocate memory for device structure.\n", i);
+      error = 2;
+      ns_init_card_error(card, error);
+      return error;
+   }
+   cards[i] = card;
+   spin_lock_init(&card->int_lock);
+   spin_lock_init(&card->res_lock);
+      
+   pci_set_drvdata(pcidev, card);
+   
+   card->index = i;
+   card->atmdev = NULL;
+   card->pcidev = pcidev;
+   membase = pci_resource_start(pcidev, 1);
+   card->membase = ioremap(membase, NS_IOREMAP_SIZE);
+   if (card->membase == 0)
+   {
+      printk("nicstar%d: can't ioremap() membase.\n",i);
+      error = 3;
+      ns_init_card_error(card, error);
+      return error;
+   }
+   PRINTK("nicstar%d: membase at 0x%x.\n", i, card->membase);
+
+   pci_set_master(pcidev);
+
+   if (pci_read_config_byte(pcidev, PCI_LATENCY_TIMER, &pci_latency) != 0)
+   {
+      printk("nicstar%d: can't read PCI latency timer.\n", i);
+      error = 6;
+      ns_init_card_error(card, error);
+      return error;
+   }
+#ifdef NS_PCI_LATENCY
+   if (pci_latency < NS_PCI_LATENCY)
+   {
+      PRINTK("nicstar%d: setting PCI latency timer to %d.\n", i, NS_PCI_LATENCY);
+      for (j = 1; j < 4; j++)
+      {
+         if (pci_write_config_byte(pcidev, PCI_LATENCY_TIMER, NS_PCI_LATENCY) != 0)
+	    break;
+      }
+      if (j == 4)
+      {
+         printk("nicstar%d: can't set PCI latency timer to %d.\n", i, NS_PCI_LATENCY);
+         error = 7;
+         ns_init_card_error(card, error);
+	 return error;
+      }
+   }
+#endif /* NS_PCI_LATENCY */
+      
+   /* Clear timer overflow */
+   data = readl(card->membase + STAT);
+   if (data & NS_STAT_TMROF)
+      writel(NS_STAT_TMROF, card->membase + STAT);
+
+   /* Software reset */
+   writel(NS_CFG_SWRST, card->membase + CFG);
+   NS_DELAY;
+   writel(0x00000000, card->membase + CFG);
+
+   /* PHY reset */
+   writel(0x00000008, card->membase + GP);
+   NS_DELAY;
+   writel(0x00000001, card->membase + GP);
+   NS_DELAY;
+   while (CMD_BUSY(card));
+   writel(NS_CMD_WRITE_UTILITY | 0x00000100, card->membase + CMD);	/* Sync UTOPIA with SAR clock */
+   NS_DELAY;
+      
+   /* Detect PHY type */
+   while (CMD_BUSY(card));
+   writel(NS_CMD_READ_UTILITY | 0x00000200, card->membase + CMD);
+   while (CMD_BUSY(card));
+   data = readl(card->membase + DR0);
+   switch(data) {
+      case 0x00000009:
+         printk("nicstar%d: PHY seems to be 25 Mbps.\n", i);
+         card->max_pcr = ATM_25_PCR;
+         while(CMD_BUSY(card));
+         writel(0x00000008, card->membase + DR0);
+         writel(NS_CMD_WRITE_UTILITY | 0x00000200, card->membase + CMD);
+         /* Clear an eventual pending interrupt */
+         writel(NS_STAT_SFBQF, card->membase + STAT);
+#ifdef PHY_LOOPBACK
+         while(CMD_BUSY(card));
+         writel(0x00000022, card->membase + DR0);
+         writel(NS_CMD_WRITE_UTILITY | 0x00000202, card->membase + CMD);
+#endif /* PHY_LOOPBACK */
+	 break;
+      case 0x00000030:
+      case 0x00000031:
+         printk("nicstar%d: PHY seems to be 155 Mbps.\n", i);
+         card->max_pcr = ATM_OC3_PCR;
+#ifdef PHY_LOOPBACK
+         while(CMD_BUSY(card));
+         writel(0x00000002, card->membase + DR0);
+         writel(NS_CMD_WRITE_UTILITY | 0x00000205, card->membase + CMD);
+#endif /* PHY_LOOPBACK */
+	 break;
+      default:
+         printk("nicstar%d: unknown PHY type (0x%08X).\n", i, data);
+         error = 8;
+         ns_init_card_error(card, error);
+         return error;
+   }
+   writel(0x00000000, card->membase + GP);
+
+   /* Determine SRAM size */
+   data = 0x76543210;
+   ns_write_sram(card, 0x1C003, &data, 1);
+   data = 0x89ABCDEF;
+   ns_write_sram(card, 0x14003, &data, 1);
+   if (ns_read_sram(card, 0x14003) == 0x89ABCDEF &&
+       ns_read_sram(card, 0x1C003) == 0x76543210)
+       card->sram_size = 128;
+   else
+      card->sram_size = 32;
+   PRINTK("nicstar%d: %dK x 32bit SRAM size.\n", i, card->sram_size);
+
+   card->rct_size = NS_MAX_RCTSIZE;
+
+#if (NS_MAX_RCTSIZE == 4096)
+   if (card->sram_size == 128)
+      printk("nicstar%d: limiting maximum VCI. See NS_MAX_RCTSIZE in nicstar.h\n", i);
+#elif (NS_MAX_RCTSIZE == 16384)
+   if (card->sram_size == 32)
+   {
+      printk("nicstar%d: wasting memory. See NS_MAX_RCTSIZE in nicstar.h\n", i);
+      card->rct_size = 4096;
+   }
+#else
+#error NS_MAX_RCTSIZE must be either 4096 or 16384 in nicstar.c
+#endif
+
+   card->vpibits = NS_VPIBITS;
+   if (card->rct_size == 4096)
+      card->vcibits = 12 - NS_VPIBITS;
+   else /* card->rct_size == 16384 */
+      card->vcibits = 14 - NS_VPIBITS;
+
+   /* Initialize the nicstar eeprom/eprom stuff, for the MAC addr */
+   if (mac[i] == NULL)
+      nicstar_init_eprom(card->membase);
+
+   if (request_irq(pcidev->irq, &ns_irq_handler, SA_INTERRUPT | SA_SHIRQ, "nicstar", card) != 0)
+   {
+      printk("nicstar%d: can't allocate IRQ %d.\n", i, pcidev->irq);
+      error = 9;
+      ns_init_card_error(card, error);
+      return error;
+   }
+
+   /* Set the VPI/VCI MSb mask to zero so we can receive OAM cells */
+   writel(0x00000000, card->membase + VPM);
+      
+   /* Initialize TSQ */
+   card->tsq.org = kmalloc(NS_TSQSIZE + NS_TSQ_ALIGNMENT, GFP_KERNEL);
+   if (card->tsq.org == NULL)
+   {
+      printk("nicstar%d: can't allocate TSQ.\n", i);
+      error = 10;
+      ns_init_card_error(card, error);
+      return error;
+   }
+   card->tsq.base = (ns_tsi *) ALIGN_ADDRESS(card->tsq.org, NS_TSQ_ALIGNMENT);
+   card->tsq.next = card->tsq.base;
+   card->tsq.last = card->tsq.base + (NS_TSQ_NUM_ENTRIES - 1);
+   for (j = 0; j < NS_TSQ_NUM_ENTRIES; j++)
+      ns_tsi_init(card->tsq.base + j);
+   writel(0x00000000, card->membase + TSQH);
+   writel((u32) virt_to_bus(card->tsq.base), card->membase + TSQB);
+   PRINTK("nicstar%d: TSQ base at 0x%x  0x%x  0x%x.\n", i, (u32) card->tsq.base,
+          (u32) virt_to_bus(card->tsq.base), readl(card->membase + TSQB));
+      
+   /* Initialize RSQ */
+   card->rsq.org = kmalloc(NS_RSQSIZE + NS_RSQ_ALIGNMENT, GFP_KERNEL);
+   if (card->rsq.org == NULL)
+   {
+      printk("nicstar%d: can't allocate RSQ.\n", i);
+      error = 11;
+      ns_init_card_error(card, error);
+      return error;
+   }
+   card->rsq.base = (ns_rsqe *) ALIGN_ADDRESS(card->rsq.org, NS_RSQ_ALIGNMENT);
+   card->rsq.next = card->rsq.base;
+   card->rsq.last = card->rsq.base + (NS_RSQ_NUM_ENTRIES - 1);
+   for (j = 0; j < NS_RSQ_NUM_ENTRIES; j++)
+      ns_rsqe_init(card->rsq.base + j);
+   writel(0x00000000, card->membase + RSQH);
+   writel((u32) virt_to_bus(card->rsq.base), card->membase + RSQB);
+   PRINTK("nicstar%d: RSQ base at 0x%x.\n", i, (u32) card->rsq.base);
+      
+   /* Initialize SCQ0, the only VBR SCQ used */
+   card->scq1 = (scq_info *) NULL;
+   card->scq2 = (scq_info *) NULL;
+   card->scq0 = get_scq(VBR_SCQSIZE, NS_VRSCD0);
+   if (card->scq0 == (scq_info *) NULL)
+   {
+      printk("nicstar%d: can't get SCQ0.\n", i);
+      error = 12;
+      ns_init_card_error(card, error);
+      return error;
+   }
+   u32d[0] = (u32) virt_to_bus(card->scq0->base);
+   u32d[1] = (u32) 0x00000000;
+   u32d[2] = (u32) 0xffffffff;
+   u32d[3] = (u32) 0x00000000;
+   ns_write_sram(card, NS_VRSCD0, u32d, 4);
+   ns_write_sram(card, NS_VRSCD1, u32d, 4);	/* These last two won't be used */
+   ns_write_sram(card, NS_VRSCD2, u32d, 4);	/* but are initialized, just in case... */
+   card->scq0->scd = NS_VRSCD0;
+   PRINTK("nicstar%d: VBR-SCQ0 base at 0x%x.\n", i, (u32) card->scq0->base);
+
+   /* Initialize TSTs */
+   card->tst_addr = NS_TST0;
+   card->tst_free_entries = NS_TST_NUM_ENTRIES;
+   data = NS_TST_OPCODE_VARIABLE;
+   for (j = 0; j < NS_TST_NUM_ENTRIES; j++)
+      ns_write_sram(card, NS_TST0 + j, &data, 1);
+   data = ns_tste_make(NS_TST_OPCODE_END, NS_TST0);
+   ns_write_sram(card, NS_TST0 + NS_TST_NUM_ENTRIES, &data, 1);
+   for (j = 0; j < NS_TST_NUM_ENTRIES; j++)
+      ns_write_sram(card, NS_TST1 + j, &data, 1);
+   data = ns_tste_make(NS_TST_OPCODE_END, NS_TST1);
+   ns_write_sram(card, NS_TST1 + NS_TST_NUM_ENTRIES, &data, 1);
+   for (j = 0; j < NS_TST_NUM_ENTRIES; j++)
+      card->tste2vc[j] = NULL;
+   writel(NS_TST0 << 2, card->membase + TSTB);
+
+
+   /* Initialize RCT. AAL type is set on opening the VC. */
+#ifdef RCQ_SUPPORT
+   u32d[0] = NS_RCTE_RAWCELLINTEN;
+#else
+   u32d[0] = 0x00000000;
+#endif /* RCQ_SUPPORT */
+   u32d[1] = 0x00000000;
+   u32d[2] = 0x00000000;
+   u32d[3] = 0xFFFFFFFF;
+   for (j = 0; j < card->rct_size; j++)
+      ns_write_sram(card, j * 4, u32d, 4);      
+      
+   memset(card->vcmap, 0, NS_MAX_RCTSIZE * sizeof(vc_map));
+      
+   for (j = 0; j < NS_FRSCD_NUM; j++)
+      card->scd2vc[j] = NULL;
+
+   /* Initialize buffer levels */
+   card->sbnr.min = MIN_SB;
+   card->sbnr.init = NUM_SB;
+   card->sbnr.max = MAX_SB;
+   card->lbnr.min = MIN_LB;
+   card->lbnr.init = NUM_LB;
+   card->lbnr.max = MAX_LB;
+   card->iovnr.min = MIN_IOVB;
+   card->iovnr.init = NUM_IOVB;
+   card->iovnr.max = MAX_IOVB;
+   card->hbnr.min = MIN_HB;
+   card->hbnr.init = NUM_HB;
+   card->hbnr.max = MAX_HB;
+   
+   card->sm_handle = 0x00000000;
+   card->sm_addr = 0x00000000;
+   card->lg_handle = 0x00000000;
+   card->lg_addr = 0x00000000;
+   
+   card->efbie = 1;	/* To prevent push_rxbufs from enabling the interrupt */
+
+   /* Pre-allocate some huge buffers */
+   skb_queue_head_init(&card->hbpool.queue);
+   card->hbpool.count = 0;
+   for (j = 0; j < NUM_HB; j++)
+   {
+      struct sk_buff *hb;
+      hb = __dev_alloc_skb(NS_HBUFSIZE, GFP_KERNEL);
+      if (hb == NULL)
+      {
+         printk("nicstar%d: can't allocate %dth of %d huge buffers.\n",
+                i, j, NUM_HB);
+         error = 13;
+         ns_init_card_error(card, error);
+	 return error;
+      }
+      skb_queue_tail(&card->hbpool.queue, hb);
+      card->hbpool.count++;
+   }
+
+
+   /* Allocate large buffers */
+   skb_queue_head_init(&card->lbpool.queue);
+   card->lbpool.count = 0;			/* Not used */
+   for (j = 0; j < NUM_LB; j++)
+   {
+      struct sk_buff *lb;
+      lb = __dev_alloc_skb(NS_LGSKBSIZE, GFP_KERNEL);
+      if (lb == NULL)
+      {
+         printk("nicstar%d: can't allocate %dth of %d large buffers.\n",
+                i, j, NUM_LB);
+         error = 14;
+         ns_init_card_error(card, error);
+	 return error;
+      }
+      skb_queue_tail(&card->lbpool.queue, lb);
+      skb_reserve(lb, NS_SMBUFSIZE);
+      push_rxbufs(card, BUF_LG, (u32) lb, (u32) virt_to_bus(lb->data), 0, 0);
+      /* Due to the implementation of push_rxbufs() this is 1, not 0 */
+      if (j == 1)
+      {
+         card->rcbuf = lb;
+         card->rawch = (u32) virt_to_bus(lb->data);
+      }
+   }
+   /* Test for strange behaviour which leads to crashes */
+   if ((bcount = ns_stat_lfbqc_get(readl(card->membase + STAT))) < card->lbnr.min)
+   {
+      printk("nicstar%d: Strange... Just allocated %d large buffers and lfbqc = %d.\n",
+             i, j, bcount);
+      error = 14;
+      ns_init_card_error(card, error);
+      return error;
+   }
+      
+
+   /* Allocate small buffers */
+   skb_queue_head_init(&card->sbpool.queue);
+   card->sbpool.count = 0;			/* Not used */
+   for (j = 0; j < NUM_SB; j++)
+   {
+      struct sk_buff *sb;
+      sb = __dev_alloc_skb(NS_SMSKBSIZE, GFP_KERNEL);
+      if (sb == NULL)
+      {
+         printk("nicstar%d: can't allocate %dth of %d small buffers.\n",
+                i, j, NUM_SB);
+         error = 15;
+         ns_init_card_error(card, error);
+	 return error;
+      }
+      skb_queue_tail(&card->sbpool.queue, sb);
+      skb_reserve(sb, NS_AAL0_HEADER);
+      push_rxbufs(card, BUF_SM, (u32) sb, (u32) virt_to_bus(sb->data), 0, 0);
+   }
+   /* Test for strange behaviour which leads to crashes */
+   if ((bcount = ns_stat_sfbqc_get(readl(card->membase + STAT))) < card->sbnr.min)
+   {
+      printk("nicstar%d: Strange... Just allocated %d small buffers and sfbqc = %d.\n",
+             i, j, bcount);
+      error = 15;
+      ns_init_card_error(card, error);
+      return error;
+   }
+      
+
+   /* Allocate iovec buffers */
+   skb_queue_head_init(&card->iovpool.queue);
+   card->iovpool.count = 0;
+   for (j = 0; j < NUM_IOVB; j++)
+   {
+      struct sk_buff *iovb;
+      iovb = alloc_skb(NS_IOVBUFSIZE, GFP_KERNEL);
+      if (iovb == NULL)
+      {
+         printk("nicstar%d: can't allocate %dth of %d iovec buffers.\n",
+                i, j, NUM_IOVB);
+         error = 16;
+         ns_init_card_error(card, error);
+	 return error;
+      }
+      skb_queue_tail(&card->iovpool.queue, iovb);
+      card->iovpool.count++;
+   }
+
+   card->intcnt = 0;
+
+   /* Configure NICStAR */
+   if (card->rct_size == 4096)
+      ns_cfg_rctsize = NS_CFG_RCTSIZE_4096_ENTRIES;
+   else /* (card->rct_size == 16384) */
+      ns_cfg_rctsize = NS_CFG_RCTSIZE_16384_ENTRIES;
+
+   card->efbie = 1;
+
+   /* Register device */
+   card->atmdev = atm_dev_register("nicstar", &atm_ops, -1, NULL);
+   if (card->atmdev == NULL)
+   {
+      printk("nicstar%d: can't register device.\n", i);
+      error = 17;
+      ns_init_card_error(card, error);
+      return error;
+   }
+      
+   if (ns_parse_mac(mac[i], card->atmdev->esi)) {
+      nicstar_read_eprom(card->membase, NICSTAR_EPROM_MAC_ADDR_OFFSET,
+                         card->atmdev->esi, 6);
+      if (memcmp(card->atmdev->esi, "\x00\x00\x00\x00\x00\x00", 6) == 0) {
+         nicstar_read_eprom(card->membase, NICSTAR_EPROM_MAC_ADDR_OFFSET_ALT,
+                         card->atmdev->esi, 6);
+      }
+   }
+
+   printk("nicstar%d: MAC address %02X:%02X:%02X:%02X:%02X:%02X\n", i,
+          card->atmdev->esi[0], card->atmdev->esi[1], card->atmdev->esi[2],
+          card->atmdev->esi[3], card->atmdev->esi[4], card->atmdev->esi[5]);
+
+   card->atmdev->dev_data = card;
+   card->atmdev->ci_range.vpi_bits = card->vpibits;
+   card->atmdev->ci_range.vci_bits = card->vcibits;
+   card->atmdev->link_rate = card->max_pcr;
+   card->atmdev->phy = NULL;
+
+#ifdef CONFIG_ATM_NICSTAR_USE_SUNI
+   if (card->max_pcr == ATM_OC3_PCR)
+      suni_init(card->atmdev);
+#endif /* CONFIG_ATM_NICSTAR_USE_SUNI */
+
+#ifdef CONFIG_ATM_NICSTAR_USE_IDT77105
+   if (card->max_pcr == ATM_25_PCR)
+      idt77105_init(card->atmdev);
+#endif /* CONFIG_ATM_NICSTAR_USE_IDT77105 */
+
+   if (card->atmdev->phy && card->atmdev->phy->start)
+      card->atmdev->phy->start(card->atmdev);
+
+   writel(NS_CFG_RXPATH |
+          NS_CFG_SMBUFSIZE |
+          NS_CFG_LGBUFSIZE |
+          NS_CFG_EFBIE |
+          NS_CFG_RSQSIZE |
+          NS_CFG_VPIBITS |
+          ns_cfg_rctsize |
+          NS_CFG_RXINT_NODELAY |
+          NS_CFG_RAWIE |		/* Only enabled if RCQ_SUPPORT */
+          NS_CFG_RSQAFIE |
+          NS_CFG_TXEN |
+          NS_CFG_TXIE |
+          NS_CFG_TSQFIE_OPT |		/* Only enabled if ENABLE_TSQFIE */ 
+          NS_CFG_PHYIE,
+          card->membase + CFG);
+
+   num_cards++;
+
+   return error;
+}
+
+
+
+static void __devinit ns_init_card_error(ns_dev *card, int error)
+{
+   if (error >= 17)
+   {
+      writel(0x00000000, card->membase + CFG);
+   }
+   if (error >= 16)
+   {
+      struct sk_buff *iovb;
+      while ((iovb = skb_dequeue(&card->iovpool.queue)) != NULL)
+         dev_kfree_skb_any(iovb);
+   }
+   if (error >= 15)
+   {
+      struct sk_buff *sb;
+      while ((sb = skb_dequeue(&card->sbpool.queue)) != NULL)
+         dev_kfree_skb_any(sb);
+      free_scq(card->scq0, NULL);
+   }
+   if (error >= 14)
+   {
+      struct sk_buff *lb;
+      while ((lb = skb_dequeue(&card->lbpool.queue)) != NULL)
+         dev_kfree_skb_any(lb);
+   }
+   if (error >= 13)
+   {
+      struct sk_buff *hb;
+      while ((hb = skb_dequeue(&card->hbpool.queue)) != NULL)
+         dev_kfree_skb_any(hb);
+   }
+   if (error >= 12)
+   {
+      kfree(card->rsq.org);
+   }
+   if (error >= 11)
+   {
+      kfree(card->tsq.org);
+   }
+   if (error >= 10)
+   {
+      free_irq(card->pcidev->irq, card);
+   }
+   if (error >= 4)
+   {
+      iounmap(card->membase);
+   }
+   if (error >= 3)
+   {
+      pci_disable_device(card->pcidev);
+      kfree(card);
+   }
+}
+
+
+
+static scq_info *get_scq(int size, u32 scd)
+{
+   scq_info *scq;
+   int i;
+
+   if (size != VBR_SCQSIZE && size != CBR_SCQSIZE)
+      return (scq_info *) NULL;
+
+   scq = (scq_info *) kmalloc(sizeof(scq_info), GFP_KERNEL);
+   if (scq == (scq_info *) NULL)
+      return (scq_info *) NULL;
+   scq->org = kmalloc(2 * size, GFP_KERNEL);
+   if (scq->org == NULL)
+   {
+      kfree(scq);
+      return (scq_info *) NULL;
+   }
+   scq->skb = (struct sk_buff **) kmalloc(sizeof(struct sk_buff *) *
+                                          (size / NS_SCQE_SIZE), GFP_KERNEL);
+   if (scq->skb == (struct sk_buff **) NULL)
+   {
+      kfree(scq->org);
+      kfree(scq);
+      return (scq_info *) NULL;
+   }
+   scq->num_entries = size / NS_SCQE_SIZE;
+   scq->base = (ns_scqe *) ALIGN_ADDRESS(scq->org, size);
+   scq->next = scq->base;
+   scq->last = scq->base + (scq->num_entries - 1);
+   scq->tail = scq->last;
+   scq->scd = scd;
+   scq->num_entries = size / NS_SCQE_SIZE;
+   scq->tbd_count = 0;
+   init_waitqueue_head(&scq->scqfull_waitq);
+   scq->full = 0;
+   spin_lock_init(&scq->lock);
+
+   for (i = 0; i < scq->num_entries; i++)
+      scq->skb[i] = NULL;
+
+   return scq;
+}
+
+
+
+/* For variable rate SCQ vcc must be NULL */
+static void free_scq(scq_info *scq, struct atm_vcc *vcc)
+{
+   int i;
+
+   if (scq->num_entries == VBR_SCQ_NUM_ENTRIES)
+      for (i = 0; i < scq->num_entries; i++)
+      {
+         if (scq->skb[i] != NULL)
+	 {
+            vcc = ATM_SKB(scq->skb[i])->vcc;
+            if (vcc->pop != NULL)
+	       vcc->pop(vcc, scq->skb[i]);
+	    else
+               dev_kfree_skb_any(scq->skb[i]);
+         }
+      }
+   else /* vcc must be != NULL */
+   {
+      if (vcc == NULL)
+      {
+         printk("nicstar: free_scq() called with vcc == NULL for fixed rate scq.");
+         for (i = 0; i < scq->num_entries; i++)
+            dev_kfree_skb_any(scq->skb[i]);
+      }
+      else
+         for (i = 0; i < scq->num_entries; i++)
+         {
+            if (scq->skb[i] != NULL)
+            {
+               if (vcc->pop != NULL)
+                  vcc->pop(vcc, scq->skb[i]);
+               else
+                  dev_kfree_skb_any(scq->skb[i]);
+            }
+         }
+   }
+   kfree(scq->skb);
+   kfree(scq->org);
+   kfree(scq);
+}
+
+
+
+/* The handles passed must be pointers to the sk_buff containing the small
+   or large buffer(s) cast to u32. */
+static void push_rxbufs(ns_dev *card, u32 type, u32 handle1, u32 addr1,
+                       u32 handle2, u32 addr2)
+{
+   u32 stat;
+   unsigned long flags;
+   
+
+#ifdef GENERAL_DEBUG
+   if (!addr1)
+      printk("nicstar%d: push_rxbufs called with addr1 = 0.\n", card->index);
+#endif /* GENERAL_DEBUG */
+
+   stat = readl(card->membase + STAT);
+   card->sbfqc = ns_stat_sfbqc_get(stat);
+   card->lbfqc = ns_stat_lfbqc_get(stat);
+   if (type == BUF_SM)
+   {
+      if (!addr2)
+      {
+         if (card->sm_addr)
+	 {
+	    addr2 = card->sm_addr;
+	    handle2 = card->sm_handle;
+	    card->sm_addr = 0x00000000;
+	    card->sm_handle = 0x00000000;
+	 }
+	 else /* (!sm_addr) */
+	 {
+	    card->sm_addr = addr1;
+	    card->sm_handle = handle1;
+	 }
+      }      
+   }
+   else /* type == BUF_LG */
+   {
+      if (!addr2)
+      {
+         if (card->lg_addr)
+	 {
+	    addr2 = card->lg_addr;
+	    handle2 = card->lg_handle;
+	    card->lg_addr = 0x00000000;
+	    card->lg_handle = 0x00000000;
+	 }
+	 else /* (!lg_addr) */
+	 {
+	    card->lg_addr = addr1;
+	    card->lg_handle = handle1;
+	 }
+      }      
+   }
+
+   if (addr2)
+   {
+      if (type == BUF_SM)
+      {
+         if (card->sbfqc >= card->sbnr.max)
+         {
+            skb_unlink((struct sk_buff *) handle1);
+            dev_kfree_skb_any((struct sk_buff *) handle1);
+            skb_unlink((struct sk_buff *) handle2);
+            dev_kfree_skb_any((struct sk_buff *) handle2);
+            return;
+         }
+	 else
+            card->sbfqc += 2;
+      }
+      else /* (type == BUF_LG) */
+      {
+         if (card->lbfqc >= card->lbnr.max)
+         {
+            skb_unlink((struct sk_buff *) handle1);
+            dev_kfree_skb_any((struct sk_buff *) handle1);
+            skb_unlink((struct sk_buff *) handle2);
+            dev_kfree_skb_any((struct sk_buff *) handle2);
+            return;
+         }
+         else
+            card->lbfqc += 2;
+      }
+
+      ns_grab_res_lock(card, flags);
+
+      while (CMD_BUSY(card));
+      writel(addr2, card->membase + DR3);
+      writel(handle2, card->membase + DR2);
+      writel(addr1, card->membase + DR1);
+      writel(handle1, card->membase + DR0);
+      writel(NS_CMD_WRITE_FREEBUFQ | (u32) type, card->membase + CMD);
+ 
+      spin_unlock_irqrestore(&card->res_lock, flags);
+
+      XPRINTK("nicstar%d: Pushing %s buffers at 0x%x and 0x%x.\n", card->index,
+              (type == BUF_SM ? "small" : "large"), addr1, addr2);
+   }
+
+   if (!card->efbie && card->sbfqc >= card->sbnr.min &&
+       card->lbfqc >= card->lbnr.min)
+   {
+      card->efbie = 1;
+      writel((readl(card->membase + CFG) | NS_CFG_EFBIE), card->membase + CFG);
+   }
+
+   return;
+}
+
+
+
+static irqreturn_t ns_irq_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+   u32 stat_r;
+   ns_dev *card;
+   struct atm_dev *dev;
+   unsigned long flags;
+
+   card = (ns_dev *) dev_id;
+   dev = card->atmdev;
+   card->intcnt++;
+
+   PRINTK("nicstar%d: NICStAR generated an interrupt\n", card->index);
+
+   ns_grab_int_lock(card, flags);
+   
+   stat_r = readl(card->membase + STAT);
+
+   /* Transmit Status Indicator has been written to T. S. Queue */
+   if (stat_r & NS_STAT_TSIF)
+   {
+      TXPRINTK("nicstar%d: TSI interrupt\n", card->index);
+      process_tsq(card);
+      writel(NS_STAT_TSIF, card->membase + STAT);
+   }
+   
+   /* Incomplete CS-PDU has been transmitted */
+   if (stat_r & NS_STAT_TXICP)
+   {
+      writel(NS_STAT_TXICP, card->membase + STAT);
+      TXPRINTK("nicstar%d: Incomplete CS-PDU transmitted.\n",
+               card->index);
+   }
+   
+   /* Transmit Status Queue 7/8 full */
+   if (stat_r & NS_STAT_TSQF)
+   {
+      writel(NS_STAT_TSQF, card->membase + STAT);
+      PRINTK("nicstar%d: TSQ full.\n", card->index);
+      process_tsq(card);
+   }
+   
+   /* Timer overflow */
+   if (stat_r & NS_STAT_TMROF)
+   {
+      writel(NS_STAT_TMROF, card->membase + STAT);
+      PRINTK("nicstar%d: Timer overflow.\n", card->index);
+   }
+   
+   /* PHY device interrupt signal active */
+   if (stat_r & NS_STAT_PHYI)
+   {
+      writel(NS_STAT_PHYI, card->membase + STAT);
+      PRINTK("nicstar%d: PHY interrupt.\n", card->index);
+      if (dev->phy && dev->phy->interrupt) {
+         dev->phy->interrupt(dev);
+      }
+   }
+
+   /* Small Buffer Queue is full */
+   if (stat_r & NS_STAT_SFBQF)
+   {
+      writel(NS_STAT_SFBQF, card->membase + STAT);
+      printk("nicstar%d: Small free buffer queue is full.\n", card->index);
+   }
+   
+   /* Large Buffer Queue is full */
+   if (stat_r & NS_STAT_LFBQF)
+   {
+      writel(NS_STAT_LFBQF, card->membase + STAT);
+      printk("nicstar%d: Large free buffer queue is full.\n", card->index);
+   }
+
+   /* Receive Status Queue is full */
+   if (stat_r & NS_STAT_RSQF)
+   {
+      writel(NS_STAT_RSQF, card->membase + STAT);
+      printk("nicstar%d: RSQ full.\n", card->index);
+      process_rsq(card);
+   }
+
+   /* Complete CS-PDU received */
+   if (stat_r & NS_STAT_EOPDU)
+   {
+      RXPRINTK("nicstar%d: End of CS-PDU received.\n", card->index);
+      process_rsq(card);
+      writel(NS_STAT_EOPDU, card->membase + STAT);
+   }
+
+   /* Raw cell received */
+   if (stat_r & NS_STAT_RAWCF)
+   {
+      writel(NS_STAT_RAWCF, card->membase + STAT);
+#ifndef RCQ_SUPPORT
+      printk("nicstar%d: Raw cell received and no support yet...\n",
+             card->index);
+#endif /* RCQ_SUPPORT */
+      /* NOTE: the following procedure may keep a raw cell pending until the
+               next interrupt. As this preliminary support is only meant to
+               avoid buffer leakage, this is not an issue. */
+      while (readl(card->membase + RAWCT) != card->rawch)
+      {
+         ns_rcqe *rawcell;
+
+         rawcell = (ns_rcqe *) bus_to_virt(card->rawch);
+         if (ns_rcqe_islast(rawcell))
+         {
+            struct sk_buff *oldbuf;
+
+            oldbuf = card->rcbuf;
+            card->rcbuf = (struct sk_buff *) ns_rcqe_nextbufhandle(rawcell);
+            card->rawch = (u32) virt_to_bus(card->rcbuf->data);
+            recycle_rx_buf(card, oldbuf);
+         }
+         else
+            card->rawch += NS_RCQE_SIZE;
+      }
+   }
+
+   /* Small buffer queue is empty */
+   if (stat_r & NS_STAT_SFBQE)
+   {
+      int i;
+      struct sk_buff *sb;
+
+      writel(NS_STAT_SFBQE, card->membase + STAT);
+      printk("nicstar%d: Small free buffer queue empty.\n",
+             card->index);
+      for (i = 0; i < card->sbnr.min; i++)
+      {
+         sb = dev_alloc_skb(NS_SMSKBSIZE);
+         if (sb == NULL)
+         {
+            writel(readl(card->membase + CFG) & ~NS_CFG_EFBIE, card->membase + CFG);
+            card->efbie = 0;
+            break;
+         }
+         skb_queue_tail(&card->sbpool.queue, sb);
+         skb_reserve(sb, NS_AAL0_HEADER);
+         push_rxbufs(card, BUF_SM, (u32) sb, (u32) virt_to_bus(sb->data), 0, 0);
+      }
+      card->sbfqc = i;
+      process_rsq(card);
+   }
+
+   /* Large buffer queue empty */
+   if (stat_r & NS_STAT_LFBQE)
+   {
+      int i;
+      struct sk_buff *lb;
+
+      writel(NS_STAT_LFBQE, card->membase + STAT);
+      printk("nicstar%d: Large free buffer queue empty.\n",
+             card->index);
+      for (i = 0; i < card->lbnr.min; i++)
+      {
+         lb = dev_alloc_skb(NS_LGSKBSIZE);
+         if (lb == NULL)
+         {
+            writel(readl(card->membase + CFG) & ~NS_CFG_EFBIE, card->membase + CFG);
+            card->efbie = 0;
+            break;
+         }
+         skb_queue_tail(&card->lbpool.queue, lb);
+         skb_reserve(lb, NS_SMBUFSIZE);
+         push_rxbufs(card, BUF_LG, (u32) lb, (u32) virt_to_bus(lb->data), 0, 0);
+      }
+      card->lbfqc = i;
+      process_rsq(card);
+   }
+
+   /* Receive Status Queue is 7/8 full */
+   if (stat_r & NS_STAT_RSQAF)
+   {
+      writel(NS_STAT_RSQAF, card->membase + STAT);
+      RXPRINTK("nicstar%d: RSQ almost full.\n", card->index);
+      process_rsq(card);
+   }
+   
+   spin_unlock_irqrestore(&card->int_lock, flags);
+   PRINTK("nicstar%d: end of interrupt service\n", card->index);
+   return IRQ_HANDLED;
+}
+
+
+
+static int ns_open(struct atm_vcc *vcc)
+{
+   ns_dev *card;
+   vc_map *vc;
+   unsigned long tmpl, modl;
+   int tcr, tcra;	/* target cell rate, and absolute value */
+   int n = 0;		/* Number of entries in the TST. Initialized to remove
+                           the compiler warning. */
+   u32 u32d[4];
+   int frscdi = 0;	/* Index of the SCD. Initialized to remove the compiler
+                           warning. How I wish compilers were clever enough to
+			   tell which variables can truly be used
+			   uninitialized... */
+   int inuse;		/* tx or rx vc already in use by another vcc */
+   short vpi = vcc->vpi;
+   int vci = vcc->vci;
+
+   card = (ns_dev *) vcc->dev->dev_data;
+   PRINTK("nicstar%d: opening vpi.vci %d.%d \n", card->index, (int) vpi, vci);
+   if (vcc->qos.aal != ATM_AAL5 && vcc->qos.aal != ATM_AAL0)
+   {
+      PRINTK("nicstar%d: unsupported AAL.\n", card->index);
+      return -EINVAL;
+   }
+
+   vc = &(card->vcmap[vpi << card->vcibits | vci]);
+   vcc->dev_data = vc;
+
+   inuse = 0;
+   if (vcc->qos.txtp.traffic_class != ATM_NONE && vc->tx)
+      inuse = 1;
+   if (vcc->qos.rxtp.traffic_class != ATM_NONE && vc->rx)
+      inuse += 2;
+   if (inuse)
+   {
+      printk("nicstar%d: %s vci already in use.\n", card->index,
+             inuse == 1 ? "tx" : inuse == 2 ? "rx" : "tx and rx");
+      return -EINVAL;
+   }
+
+   set_bit(ATM_VF_ADDR,&vcc->flags);
+
+   /* NOTE: You are not allowed to modify an open connection's QOS. To change
+      that, remove the ATM_VF_PARTIAL flag checking. There may be other changes
+      needed to do that. */
+   if (!test_bit(ATM_VF_PARTIAL,&vcc->flags))
+   {
+      scq_info *scq;
+      
+      set_bit(ATM_VF_PARTIAL,&vcc->flags);
+      if (vcc->qos.txtp.traffic_class == ATM_CBR)
+      {
+         /* Check requested cell rate and availability of SCD */
+         if (vcc->qos.txtp.max_pcr == 0 && vcc->qos.txtp.pcr == 0 &&
+             vcc->qos.txtp.min_pcr == 0)
+         {
+            PRINTK("nicstar%d: trying to open a CBR vc with cell rate = 0 \n",
+	           card->index);
+	    clear_bit(ATM_VF_PARTIAL,&vcc->flags);
+	    clear_bit(ATM_VF_ADDR,&vcc->flags);
+            return -EINVAL;
+         }
+
+         tcr = atm_pcr_goal(&(vcc->qos.txtp));
+         tcra = tcr >= 0 ? tcr : -tcr;
+      
+         PRINTK("nicstar%d: target cell rate = %d.\n", card->index,
+                vcc->qos.txtp.max_pcr);
+
+         tmpl = (unsigned long)tcra * (unsigned long)NS_TST_NUM_ENTRIES;
+         modl = tmpl % card->max_pcr;
+
+         n = (int)(tmpl / card->max_pcr);
+         if (tcr > 0)
+         {
+            if (modl > 0) n++;
+         }
+         else if (tcr == 0)
+         {
+            if ((n = (card->tst_free_entries - NS_TST_RESERVED)) <= 0)
+	    {
+               PRINTK("nicstar%d: no CBR bandwidth free.\n", card->index);
+	       clear_bit(ATM_VF_PARTIAL,&vcc->flags);
+	       clear_bit(ATM_VF_ADDR,&vcc->flags);
+               return -EINVAL;
+            }
+         }
+
+         if (n == 0)
+         {
+            printk("nicstar%d: selected bandwidth < granularity.\n", card->index);
+	    clear_bit(ATM_VF_PARTIAL,&vcc->flags);
+	    clear_bit(ATM_VF_ADDR,&vcc->flags);
+            return -EINVAL;
+         }
+
+         if (n > (card->tst_free_entries - NS_TST_RESERVED))
+         {
+            PRINTK("nicstar%d: not enough free CBR bandwidth.\n", card->index);
+	    clear_bit(ATM_VF_PARTIAL,&vcc->flags);
+	    clear_bit(ATM_VF_ADDR,&vcc->flags);
+            return -EINVAL;
+         }
+         else
+            card->tst_free_entries -= n;
+
+         XPRINTK("nicstar%d: writing %d tst entries.\n", card->index, n);
+         for (frscdi = 0; frscdi < NS_FRSCD_NUM; frscdi++)
+         {
+            if (card->scd2vc[frscdi] == NULL)
+            {
+               card->scd2vc[frscdi] = vc;
+               break;
+	    }
+         }
+         if (frscdi == NS_FRSCD_NUM)
+         {
+            PRINTK("nicstar%d: no SCD available for CBR channel.\n", card->index);
+            card->tst_free_entries += n;
+	    clear_bit(ATM_VF_PARTIAL,&vcc->flags);
+	    clear_bit(ATM_VF_ADDR,&vcc->flags);
+	    return -EBUSY;
+         }
+
+         vc->cbr_scd = NS_FRSCD + frscdi * NS_FRSCD_SIZE;
+
+         scq = get_scq(CBR_SCQSIZE, vc->cbr_scd);
+         if (scq == (scq_info *) NULL)
+         {
+            PRINTK("nicstar%d: can't get fixed rate SCQ.\n", card->index);
+            card->scd2vc[frscdi] = NULL;
+            card->tst_free_entries += n;
+	    clear_bit(ATM_VF_PARTIAL,&vcc->flags);
+	    clear_bit(ATM_VF_ADDR,&vcc->flags);
+            return -ENOMEM;
+         }
+	 vc->scq = scq;
+         u32d[0] = (u32) virt_to_bus(scq->base);
+         u32d[1] = (u32) 0x00000000;
+         u32d[2] = (u32) 0xffffffff;
+         u32d[3] = (u32) 0x00000000;
+         ns_write_sram(card, vc->cbr_scd, u32d, 4);
+         
+	 fill_tst(card, n, vc);
+      }
+      else if (vcc->qos.txtp.traffic_class == ATM_UBR)
+      {
+         vc->cbr_scd = 0x00000000;
+	 vc->scq = card->scq0;
+      }
+      
+      if (vcc->qos.txtp.traffic_class != ATM_NONE)
+      {
+         vc->tx = 1;
+	 vc->tx_vcc = vcc;
+	 vc->tbd_count = 0;
+      }
+      if (vcc->qos.rxtp.traffic_class != ATM_NONE)
+      {
+         u32 status;
+      
+         vc->rx = 1;
+         vc->rx_vcc = vcc;
+         vc->rx_iov = NULL;
+
+	 /* Open the connection in hardware */
+	 if (vcc->qos.aal == ATM_AAL5)
+	    status = NS_RCTE_AAL5 | NS_RCTE_CONNECTOPEN;
+	 else /* vcc->qos.aal == ATM_AAL0 */
+	    status = NS_RCTE_AAL0 | NS_RCTE_CONNECTOPEN;
+#ifdef RCQ_SUPPORT
+         status |= NS_RCTE_RAWCELLINTEN;
+#endif /* RCQ_SUPPORT */
+         ns_write_sram(card, NS_RCT + (vpi << card->vcibits | vci) *
+	               NS_RCT_ENTRY_SIZE, &status, 1);
+      }
+      
+   }
+   
+   set_bit(ATM_VF_READY,&vcc->flags);
+   return 0;
+}
+
+
+
+static void ns_close(struct atm_vcc *vcc)
+{
+   vc_map *vc;
+   ns_dev *card;
+   u32 data;
+   int i;
+   
+   vc = vcc->dev_data;
+   card = vcc->dev->dev_data;
+   PRINTK("nicstar%d: closing vpi.vci %d.%d \n", card->index,
+          (int) vcc->vpi, vcc->vci);
+
+   clear_bit(ATM_VF_READY,&vcc->flags);
+   
+   if (vcc->qos.rxtp.traffic_class != ATM_NONE)
+   {
+      u32 addr;
+      unsigned long flags;
+      
+      addr = NS_RCT + (vcc->vpi << card->vcibits | vcc->vci) * NS_RCT_ENTRY_SIZE;
+      ns_grab_res_lock(card, flags);
+      while(CMD_BUSY(card));
+      writel(NS_CMD_CLOSE_CONNECTION | addr << 2, card->membase + CMD);
+      spin_unlock_irqrestore(&card->res_lock, flags);
+      
+      vc->rx = 0;
+      if (vc->rx_iov != NULL)
+      {
+	 struct sk_buff *iovb;
+	 u32 stat;
+   
+         stat = readl(card->membase + STAT);
+         card->sbfqc = ns_stat_sfbqc_get(stat);   
+         card->lbfqc = ns_stat_lfbqc_get(stat);
+
+         PRINTK("nicstar%d: closing a VC with pending rx buffers.\n",
+	        card->index);
+         iovb = vc->rx_iov;
+         recycle_iovec_rx_bufs(card, (struct iovec *) iovb->data,
+	                       NS_SKB(iovb)->iovcnt);
+         NS_SKB(iovb)->iovcnt = 0;
+         NS_SKB(iovb)->vcc = NULL;
+         ns_grab_int_lock(card, flags);
+         recycle_iov_buf(card, iovb);
+         spin_unlock_irqrestore(&card->int_lock, flags);
+         vc->rx_iov = NULL;
+      }
+   }
+
+   if (vcc->qos.txtp.traffic_class != ATM_NONE)
+   {
+      vc->tx = 0;
+   }
+
+   if (vcc->qos.txtp.traffic_class == ATM_CBR)
+   {
+      unsigned long flags;
+      ns_scqe *scqep;
+      scq_info *scq;
+
+      scq = vc->scq;
+
+      for (;;)
+      {
+         ns_grab_scq_lock(card, scq, flags);
+         scqep = scq->next;
+         if (scqep == scq->base)
+            scqep = scq->last;
+         else
+            scqep--;
+         if (scqep == scq->tail)
+         {
+            spin_unlock_irqrestore(&scq->lock, flags);
+            break;
+         }
+         /* If the last entry is not a TSR, place one in the SCQ in order to
+            be able to completely drain it and then close. */
+         if (!ns_scqe_is_tsr(scqep) && scq->tail != scq->next)
+         {
+            ns_scqe tsr;
+            u32 scdi, scqi;
+            u32 data;
+            int index;
+
+            tsr.word_1 = ns_tsr_mkword_1(NS_TSR_INTENABLE);
+            scdi = (vc->cbr_scd - NS_FRSCD) / NS_FRSCD_SIZE;
+            scqi = scq->next - scq->base;
+            tsr.word_2 = ns_tsr_mkword_2(scdi, scqi);
+            tsr.word_3 = 0x00000000;
+            tsr.word_4 = 0x00000000;
+            *scq->next = tsr;
+            index = (int) scqi;
+            scq->skb[index] = NULL;
+            if (scq->next == scq->last)
+               scq->next = scq->base;
+            else
+               scq->next++;
+            data = (u32) virt_to_bus(scq->next);
+            ns_write_sram(card, scq->scd, &data, 1);
+         }
+         spin_unlock_irqrestore(&scq->lock, flags);
+         schedule();
+      }
+
+      /* Free all TST entries */
+      data = NS_TST_OPCODE_VARIABLE;
+      for (i = 0; i < NS_TST_NUM_ENTRIES; i++)
+      {
+         if (card->tste2vc[i] == vc)
+	 {
+            ns_write_sram(card, card->tst_addr + i, &data, 1);
+            card->tste2vc[i] = NULL;
+            card->tst_free_entries++;
+	 }
+      }
+      
+      card->scd2vc[(vc->cbr_scd - NS_FRSCD) / NS_FRSCD_SIZE] = NULL;
+      free_scq(vc->scq, vcc);
+   }
+
+   /* remove all references to vcc before deleting it */
+   if (vcc->qos.txtp.traffic_class != ATM_NONE)
+   {
+     unsigned long flags;
+     scq_info *scq = card->scq0;
+
+     ns_grab_scq_lock(card, scq, flags);
+
+     for(i = 0; i < scq->num_entries; i++) {
+       if(scq->skb[i] && ATM_SKB(scq->skb[i])->vcc == vcc) {
+        ATM_SKB(scq->skb[i])->vcc = NULL;
+	atm_return(vcc, scq->skb[i]->truesize);
+        PRINTK("nicstar: deleted pending vcc mapping\n");
+       }
+     }
+
+     spin_unlock_irqrestore(&scq->lock, flags);
+   }
+
+   vcc->dev_data = NULL;
+   clear_bit(ATM_VF_PARTIAL,&vcc->flags);
+   clear_bit(ATM_VF_ADDR,&vcc->flags);
+
+#ifdef RX_DEBUG
+   {
+      u32 stat, cfg;
+      stat = readl(card->membase + STAT);
+      cfg = readl(card->membase + CFG);
+      printk("STAT = 0x%08X  CFG = 0x%08X  \n", stat, cfg);
+      printk("TSQ: base = 0x%08X  next = 0x%08X  last = 0x%08X  TSQT = 0x%08X \n",
+             (u32) card->tsq.base, (u32) card->tsq.next,(u32) card->tsq.last,
+	     readl(card->membase + TSQT));
+      printk("RSQ: base = 0x%08X  next = 0x%08X  last = 0x%08X  RSQT = 0x%08X \n",
+             (u32) card->rsq.base, (u32) card->rsq.next,(u32) card->rsq.last,
+	     readl(card->membase + RSQT));
+      printk("Empty free buffer queue interrupt %s \n",
+             card->efbie ? "enabled" : "disabled");
+      printk("SBCNT = %d  count = %d   LBCNT = %d count = %d \n",
+             ns_stat_sfbqc_get(stat), card->sbpool.count,
+	     ns_stat_lfbqc_get(stat), card->lbpool.count);
+      printk("hbpool.count = %d  iovpool.count = %d \n",
+             card->hbpool.count, card->iovpool.count);
+   }
+#endif /* RX_DEBUG */
+}
+
+
+
+static void fill_tst(ns_dev *card, int n, vc_map *vc)
+{
+   u32 new_tst;
+   unsigned long cl;
+   int e, r;
+   u32 data;
+      
+   /* It would be very complicated to keep the two TSTs synchronized while
+      assuring that writes are only made to the inactive TST. So, for now I
+      will use only one TST. If problems occur, I will change this again */
+   
+   new_tst = card->tst_addr;
+
+   /* Fill procedure */
+
+   for (e = 0; e < NS_TST_NUM_ENTRIES; e++)
+   {
+      if (card->tste2vc[e] == NULL)
+         break;
+   }
+   if (e == NS_TST_NUM_ENTRIES) {
+      printk("nicstar%d: No free TST entries found. \n", card->index);
+      return;
+   }
+
+   r = n;
+   cl = NS_TST_NUM_ENTRIES;
+   data = ns_tste_make(NS_TST_OPCODE_FIXED, vc->cbr_scd);
+      
+   while (r > 0)
+   {
+      if (cl >= NS_TST_NUM_ENTRIES && card->tste2vc[e] == NULL)
+      {
+         card->tste2vc[e] = vc;
+         ns_write_sram(card, new_tst + e, &data, 1);
+         cl -= NS_TST_NUM_ENTRIES;
+         r--;
+      }
+
+      if (++e == NS_TST_NUM_ENTRIES) {
+         e = 0;
+      }
+      cl += n;
+   }
+   
+   /* End of fill procedure */
+   
+   data = ns_tste_make(NS_TST_OPCODE_END, new_tst);
+   ns_write_sram(card, new_tst + NS_TST_NUM_ENTRIES, &data, 1);
+   ns_write_sram(card, card->tst_addr + NS_TST_NUM_ENTRIES, &data, 1);
+   card->tst_addr = new_tst;
+}
+
+
+
+static int ns_send(struct atm_vcc *vcc, struct sk_buff *skb)
+{
+   ns_dev *card;
+   vc_map *vc;
+   scq_info *scq;
+   unsigned long buflen;
+   ns_scqe scqe;
+   u32 flags;		/* TBD flags, not CPU flags */
+   
+   card = vcc->dev->dev_data;
+   TXPRINTK("nicstar%d: ns_send() called.\n", card->index);
+   if ((vc = (vc_map *) vcc->dev_data) == NULL)
+   {
+      printk("nicstar%d: vcc->dev_data == NULL on ns_send().\n", card->index);
+      atomic_inc(&vcc->stats->tx_err);
+      dev_kfree_skb_any(skb);
+      return -EINVAL;
+   }
+   
+   if (!vc->tx)
+   {
+      printk("nicstar%d: Trying to transmit on a non-tx VC.\n", card->index);
+      atomic_inc(&vcc->stats->tx_err);
+      dev_kfree_skb_any(skb);
+      return -EINVAL;
+   }
+   
+   if (vcc->qos.aal != ATM_AAL5 && vcc->qos.aal != ATM_AAL0)
+   {
+      printk("nicstar%d: Only AAL0 and AAL5 are supported.\n", card->index);
+      atomic_inc(&vcc->stats->tx_err);
+      dev_kfree_skb_any(skb);
+      return -EINVAL;
+   }
+   
+   if (skb_shinfo(skb)->nr_frags != 0)
+   {
+      printk("nicstar%d: No scatter-gather yet.\n", card->index);
+      atomic_inc(&vcc->stats->tx_err);
+      dev_kfree_skb_any(skb);
+      return -EINVAL;
+   }
+   
+   ATM_SKB(skb)->vcc = vcc;
+
+   if (vcc->qos.aal == ATM_AAL5)
+   {
+      buflen = (skb->len + 47 + 8) / 48 * 48;	/* Multiple of 48 */
+      flags = NS_TBD_AAL5;
+      scqe.word_2 = cpu_to_le32((u32) virt_to_bus(skb->data));
+      scqe.word_3 = cpu_to_le32((u32) skb->len);
+      scqe.word_4 = ns_tbd_mkword_4(0, (u32) vcc->vpi, (u32) vcc->vci, 0,
+                           ATM_SKB(skb)->atm_options & ATM_ATMOPT_CLP ? 1 : 0);
+      flags |= NS_TBD_EOPDU;
+   }
+   else /* (vcc->qos.aal == ATM_AAL0) */
+   {
+      buflen = ATM_CELL_PAYLOAD;	/* i.e., 48 bytes */
+      flags = NS_TBD_AAL0;
+      scqe.word_2 = cpu_to_le32((u32) virt_to_bus(skb->data) + NS_AAL0_HEADER);
+      scqe.word_3 = cpu_to_le32(0x00000000);
+      if (*skb->data & 0x02)	/* Payload type 1 - end of pdu */
+         flags |= NS_TBD_EOPDU;
+      scqe.word_4 = cpu_to_le32(*((u32 *) skb->data) & ~NS_TBD_VC_MASK);
+      /* Force the VPI/VCI to be the same as in VCC struct */
+      scqe.word_4 |= cpu_to_le32((((u32) vcc->vpi) << NS_TBD_VPI_SHIFT |
+                                 ((u32) vcc->vci) << NS_TBD_VCI_SHIFT) &
+                                 NS_TBD_VC_MASK);
+   }
+
+   if (vcc->qos.txtp.traffic_class == ATM_CBR)
+   {
+      scqe.word_1 = ns_tbd_mkword_1_novbr(flags, (u32) buflen);
+      scq = ((vc_map *) vcc->dev_data)->scq;
+   }
+   else
+   {
+      scqe.word_1 = ns_tbd_mkword_1(flags, (u32) 1, (u32) 1, (u32) buflen);
+      scq = card->scq0;
+   }
+
+   if (push_scqe(card, vc, scq, &scqe, skb) != 0)
+   {
+      atomic_inc(&vcc->stats->tx_err);
+      dev_kfree_skb_any(skb);
+      return -EIO;
+   }
+   atomic_inc(&vcc->stats->tx);
+
+   return 0;
+}
+
+
+
+static int push_scqe(ns_dev *card, vc_map *vc, scq_info *scq, ns_scqe *tbd,
+                     struct sk_buff *skb)
+{
+   unsigned long flags;
+   ns_scqe tsr;
+   u32 scdi, scqi;
+   int scq_is_vbr;
+   u32 data;
+   int index;
+   
+   ns_grab_scq_lock(card, scq, flags);
+   while (scq->tail == scq->next)
+   {
+      if (in_interrupt()) {
+         spin_unlock_irqrestore(&scq->lock, flags);
+         printk("nicstar%d: Error pushing TBD.\n", card->index);
+         return 1;
+      }
+
+      scq->full = 1;
+      spin_unlock_irqrestore(&scq->lock, flags);
+      interruptible_sleep_on_timeout(&scq->scqfull_waitq, SCQFULL_TIMEOUT);
+      ns_grab_scq_lock(card, scq, flags);
+
+      if (scq->full) {
+         spin_unlock_irqrestore(&scq->lock, flags);
+         printk("nicstar%d: Timeout pushing TBD.\n", card->index);
+         return 1;
+      }
+   }
+   *scq->next = *tbd;
+   index = (int) (scq->next - scq->base);
+   scq->skb[index] = skb;
+   XPRINTK("nicstar%d: sending skb at 0x%x (pos %d).\n",
+           card->index, (u32) skb, index);
+   XPRINTK("nicstar%d: TBD written:\n0x%x\n0x%x\n0x%x\n0x%x\n at 0x%x.\n",
+           card->index, le32_to_cpu(tbd->word_1), le32_to_cpu(tbd->word_2),
+           le32_to_cpu(tbd->word_3), le32_to_cpu(tbd->word_4),
+           (u32) scq->next);
+   if (scq->next == scq->last)
+      scq->next = scq->base;
+   else
+      scq->next++;
+
+   vc->tbd_count++;
+   if (scq->num_entries == VBR_SCQ_NUM_ENTRIES)
+   {
+      scq->tbd_count++;
+      scq_is_vbr = 1;
+   }
+   else
+      scq_is_vbr = 0;
+
+   if (vc->tbd_count >= MAX_TBD_PER_VC || scq->tbd_count >= MAX_TBD_PER_SCQ)
+   {
+      int has_run = 0;
+
+      while (scq->tail == scq->next)
+      {
+         if (in_interrupt()) {
+            data = (u32) virt_to_bus(scq->next);
+            ns_write_sram(card, scq->scd, &data, 1);
+            spin_unlock_irqrestore(&scq->lock, flags);
+            printk("nicstar%d: Error pushing TSR.\n", card->index);
+            return 0;
+         }
+
+         scq->full = 1;
+         if (has_run++) break;
+         spin_unlock_irqrestore(&scq->lock, flags);
+         interruptible_sleep_on_timeout(&scq->scqfull_waitq, SCQFULL_TIMEOUT);
+         ns_grab_scq_lock(card, scq, flags);
+      }
+
+      if (!scq->full)
+      {
+         tsr.word_1 = ns_tsr_mkword_1(NS_TSR_INTENABLE);
+         if (scq_is_vbr)
+            scdi = NS_TSR_SCDISVBR;
+         else
+            scdi = (vc->cbr_scd - NS_FRSCD) / NS_FRSCD_SIZE;
+         scqi = scq->next - scq->base;
+         tsr.word_2 = ns_tsr_mkword_2(scdi, scqi);
+         tsr.word_3 = 0x00000000;
+         tsr.word_4 = 0x00000000;
+
+         *scq->next = tsr;
+         index = (int) scqi;
+         scq->skb[index] = NULL;
+         XPRINTK("nicstar%d: TSR written:\n0x%x\n0x%x\n0x%x\n0x%x\n at 0x%x.\n",
+                 card->index, le32_to_cpu(tsr.word_1), le32_to_cpu(tsr.word_2),
+                 le32_to_cpu(tsr.word_3), le32_to_cpu(tsr.word_4),
+		 (u32) scq->next);
+         if (scq->next == scq->last)
+            scq->next = scq->base;
+         else
+            scq->next++;
+         vc->tbd_count = 0;
+         scq->tbd_count = 0;
+      }
+      else
+         PRINTK("nicstar%d: Timeout pushing TSR.\n", card->index);
+   }
+   data = (u32) virt_to_bus(scq->next);
+   ns_write_sram(card, scq->scd, &data, 1);
+   
+   spin_unlock_irqrestore(&scq->lock, flags);
+   
+   return 0;
+}
+
+
+
+static void process_tsq(ns_dev *card)
+{
+   u32 scdi;
+   scq_info *scq;
+   ns_tsi *previous = NULL, *one_ahead, *two_ahead;
+   int serviced_entries;   /* flag indicating at least on entry was serviced */
+   
+   serviced_entries = 0;
+   
+   if (card->tsq.next == card->tsq.last)
+      one_ahead = card->tsq.base;
+   else
+      one_ahead = card->tsq.next + 1;
+
+   if (one_ahead == card->tsq.last)
+      two_ahead = card->tsq.base;
+   else
+      two_ahead = one_ahead + 1;
+   
+   while (!ns_tsi_isempty(card->tsq.next) || !ns_tsi_isempty(one_ahead) ||
+          !ns_tsi_isempty(two_ahead))
+          /* At most two empty, as stated in the 77201 errata */
+   {
+      serviced_entries = 1;
+    
+      /* Skip the one or two possible empty entries */
+      while (ns_tsi_isempty(card->tsq.next)) {
+         if (card->tsq.next == card->tsq.last)
+            card->tsq.next = card->tsq.base;
+         else
+            card->tsq.next++;
+      }
+    
+      if (!ns_tsi_tmrof(card->tsq.next))
+      {
+         scdi = ns_tsi_getscdindex(card->tsq.next);
+	 if (scdi == NS_TSI_SCDISVBR)
+	    scq = card->scq0;
+	 else
+	 {
+	    if (card->scd2vc[scdi] == NULL)
+	    {
+	       printk("nicstar%d: could not find VC from SCD index.\n",
+	              card->index);
+               ns_tsi_init(card->tsq.next);
+               return;
+            }
+            scq = card->scd2vc[scdi]->scq;
+         }
+         drain_scq(card, scq, ns_tsi_getscqpos(card->tsq.next));
+         scq->full = 0;
+         wake_up_interruptible(&(scq->scqfull_waitq));
+      }
+
+      ns_tsi_init(card->tsq.next);
+      previous = card->tsq.next;
+      if (card->tsq.next == card->tsq.last)
+         card->tsq.next = card->tsq.base;
+      else
+         card->tsq.next++;
+
+      if (card->tsq.next == card->tsq.last)
+         one_ahead = card->tsq.base;
+      else
+         one_ahead = card->tsq.next + 1;
+
+      if (one_ahead == card->tsq.last)
+         two_ahead = card->tsq.base;
+      else
+         two_ahead = one_ahead + 1;
+   }
+
+   if (serviced_entries) {
+      writel((((u32) previous) - ((u32) card->tsq.base)),
+             card->membase + TSQH);
+   }
+}
+
+
+
+static void drain_scq(ns_dev *card, scq_info *scq, int pos)
+{
+   struct atm_vcc *vcc;
+   struct sk_buff *skb;
+   int i;
+   unsigned long flags;
+   
+   XPRINTK("nicstar%d: drain_scq() called, scq at 0x%x, pos %d.\n",
+           card->index, (u32) scq, pos);
+   if (pos >= scq->num_entries)
+   {
+      printk("nicstar%d: Bad index on drain_scq().\n", card->index);
+      return;
+   }
+
+   ns_grab_scq_lock(card, scq, flags);
+   i = (int) (scq->tail - scq->base);
+   if (++i == scq->num_entries)
+      i = 0;
+   while (i != pos)
+   {
+      skb = scq->skb[i];
+      XPRINTK("nicstar%d: freeing skb at 0x%x (index %d).\n",
+              card->index, (u32) skb, i);
+      if (skb != NULL)
+      {
+         vcc = ATM_SKB(skb)->vcc;
+	 if (vcc && vcc->pop != NULL) {
+	    vcc->pop(vcc, skb);
+	 } else {
+	    dev_kfree_skb_irq(skb);
+         }
+	 scq->skb[i] = NULL;
+      }
+      if (++i == scq->num_entries)
+         i = 0;
+   }
+   scq->tail = scq->base + pos;
+   spin_unlock_irqrestore(&scq->lock, flags);
+}
+
+
+
+static void process_rsq(ns_dev *card)
+{
+   ns_rsqe *previous;
+
+   if (!ns_rsqe_valid(card->rsq.next))
+      return;
+   while (ns_rsqe_valid(card->rsq.next))
+   {
+      dequeue_rx(card, card->rsq.next);
+      ns_rsqe_init(card->rsq.next);
+      previous = card->rsq.next;
+      if (card->rsq.next == card->rsq.last)
+         card->rsq.next = card->rsq.base;
+      else
+         card->rsq.next++;
+   }
+   writel((((u32) previous) - ((u32) card->rsq.base)),
+          card->membase + RSQH);
+}
+
+
+
+static void dequeue_rx(ns_dev *card, ns_rsqe *rsqe)
+{
+   u32 vpi, vci;
+   vc_map *vc;
+   struct sk_buff *iovb;
+   struct iovec *iov;
+   struct atm_vcc *vcc;
+   struct sk_buff *skb;
+   unsigned short aal5_len;
+   int len;
+   u32 stat;
+
+   stat = readl(card->membase + STAT);
+   card->sbfqc = ns_stat_sfbqc_get(stat);   
+   card->lbfqc = ns_stat_lfbqc_get(stat);
+
+   skb = (struct sk_buff *) le32_to_cpu(rsqe->buffer_handle);
+   vpi = ns_rsqe_vpi(rsqe);
+   vci = ns_rsqe_vci(rsqe);
+   if (vpi >= 1UL << card->vpibits || vci >= 1UL << card->vcibits)
+   {
+      printk("nicstar%d: SDU received for out-of-range vc %d.%d.\n",
+             card->index, vpi, vci);
+      recycle_rx_buf(card, skb);
+      return;
+   }
+   
+   vc = &(card->vcmap[vpi << card->vcibits | vci]);
+   if (!vc->rx)
+   {
+      RXPRINTK("nicstar%d: SDU received on non-rx vc %d.%d.\n",
+             card->index, vpi, vci);
+      recycle_rx_buf(card, skb);
+      return;
+   }
+
+   vcc = vc->rx_vcc;
+
+   if (vcc->qos.aal == ATM_AAL0)
+   {
+      struct sk_buff *sb;
+      unsigned char *cell;
+      int i;
+
+      cell = skb->data;
+      for (i = ns_rsqe_cellcount(rsqe); i; i--)
+      {
+         if ((sb = dev_alloc_skb(NS_SMSKBSIZE)) == NULL)
+         {
+            printk("nicstar%d: Can't allocate buffers for aal0.\n",
+                   card->index);
+            atomic_add(i,&vcc->stats->rx_drop);
+            break;
+         }
+         if (!atm_charge(vcc, sb->truesize))
+         {
+            RXPRINTK("nicstar%d: atm_charge() dropped aal0 packets.\n",
+                     card->index);
+            atomic_add(i-1,&vcc->stats->rx_drop); /* already increased by 1 */
+            dev_kfree_skb_any(sb);
+            break;
+         }
+         /* Rebuild the header */
+         *((u32 *) sb->data) = le32_to_cpu(rsqe->word_1) << 4 |
+                               (ns_rsqe_clp(rsqe) ? 0x00000001 : 0x00000000);
+         if (i == 1 && ns_rsqe_eopdu(rsqe))
+            *((u32 *) sb->data) |= 0x00000002;
+         skb_put(sb, NS_AAL0_HEADER);
+         memcpy(sb->tail, cell, ATM_CELL_PAYLOAD);
+         skb_put(sb, ATM_CELL_PAYLOAD);
+         ATM_SKB(sb)->vcc = vcc;
+         do_gettimeofday(&sb->stamp);
+         vcc->push(vcc, sb);
+         atomic_inc(&vcc->stats->rx);
+         cell += ATM_CELL_PAYLOAD;
+      }
+
+      recycle_rx_buf(card, skb);
+      return;
+   }
+
+   /* To reach this point, the AAL layer can only be AAL5 */
+
+   if ((iovb = vc->rx_iov) == NULL)
+   {
+      iovb = skb_dequeue(&(card->iovpool.queue));
+      if (iovb == NULL)		/* No buffers in the queue */
+      {
+         iovb = alloc_skb(NS_IOVBUFSIZE, GFP_ATOMIC);
+	 if (iovb == NULL)
+	 {
+	    printk("nicstar%d: Out of iovec buffers.\n", card->index);
+            atomic_inc(&vcc->stats->rx_drop);
+            recycle_rx_buf(card, skb);
+            return;
+	 }
+      }
+      else
+         if (--card->iovpool.count < card->iovnr.min)
+	 {
+	    struct sk_buff *new_iovb;
+	    if ((new_iovb = alloc_skb(NS_IOVBUFSIZE, GFP_ATOMIC)) != NULL)
+	    {
+               skb_queue_tail(&card->iovpool.queue, new_iovb);
+               card->iovpool.count++;
+	    }
+	 }
+      vc->rx_iov = iovb;
+      NS_SKB(iovb)->iovcnt = 0;
+      iovb->len = 0;
+      iovb->tail = iovb->data = iovb->head;
+      NS_SKB(iovb)->vcc = vcc;
+      /* IMPORTANT: a pointer to the sk_buff containing the small or large
+                    buffer is stored as iovec base, NOT a pointer to the 
+	            small or large buffer itself. */
+   }
+   else if (NS_SKB(iovb)->iovcnt >= NS_MAX_IOVECS)
+   {
+      printk("nicstar%d: received too big AAL5 SDU.\n", card->index);
+      atomic_inc(&vcc->stats->rx_err);
+      recycle_iovec_rx_bufs(card, (struct iovec *) iovb->data, NS_MAX_IOVECS);
+      NS_SKB(iovb)->iovcnt = 0;
+      iovb->len = 0;
+      iovb->tail = iovb->data = iovb->head;
+      NS_SKB(iovb)->vcc = vcc;
+   }
+   iov = &((struct iovec *) iovb->data)[NS_SKB(iovb)->iovcnt++];
+   iov->iov_base = (void *) skb;
+   iov->iov_len = ns_rsqe_cellcount(rsqe) * 48;
+   iovb->len += iov->iov_len;
+
+   if (NS_SKB(iovb)->iovcnt == 1)
+   {
+      if (skb->list != &card->sbpool.queue)
+      {
+         printk("nicstar%d: Expected a small buffer, and this is not one.\n",
+	        card->index);
+         which_list(card, skb);
+         atomic_inc(&vcc->stats->rx_err);
+         recycle_rx_buf(card, skb);
+         vc->rx_iov = NULL;
+         recycle_iov_buf(card, iovb);
+         return;
+      }
+   }
+   else /* NS_SKB(iovb)->iovcnt >= 2 */
+   {
+      if (skb->list != &card->lbpool.queue)
+      {
+         printk("nicstar%d: Expected a large buffer, and this is not one.\n",
+	        card->index);
+         which_list(card, skb);
+         atomic_inc(&vcc->stats->rx_err);
+         recycle_iovec_rx_bufs(card, (struct iovec *) iovb->data,
+	                       NS_SKB(iovb)->iovcnt);
+         vc->rx_iov = NULL;
+         recycle_iov_buf(card, iovb);
+	 return;
+      }
+   }
+
+   if (ns_rsqe_eopdu(rsqe))
+   {
+      /* This works correctly regardless of the endianness of the host */
+      unsigned char *L1L2 = (unsigned char *)((u32)skb->data +
+                                              iov->iov_len - 6);
+      aal5_len = L1L2[0] << 8 | L1L2[1];
+      len = (aal5_len == 0x0000) ? 0x10000 : aal5_len;
+      if (ns_rsqe_crcerr(rsqe) ||
+          len + 8 > iovb->len || len + (47 + 8) < iovb->len)
+      {
+         printk("nicstar%d: AAL5 CRC error", card->index);
+         if (len + 8 > iovb->len || len + (47 + 8) < iovb->len)
+            printk(" - PDU size mismatch.\n");
+         else
+            printk(".\n");
+         atomic_inc(&vcc->stats->rx_err);
+         recycle_iovec_rx_bufs(card, (struct iovec *) iovb->data,
+	   NS_SKB(iovb)->iovcnt);
+	 vc->rx_iov = NULL;
+         recycle_iov_buf(card, iovb);
+	 return;
+      }
+
+      /* By this point we (hopefully) have a complete SDU without errors. */
+
+      if (NS_SKB(iovb)->iovcnt == 1)	/* Just a small buffer */
+      {
+         /* skb points to a small buffer */
+         if (!atm_charge(vcc, skb->truesize))
+         {
+            push_rxbufs(card, BUF_SM, (u32) skb, (u32) virt_to_bus(skb->data),
+                        0, 0);
+            atomic_inc(&vcc->stats->rx_drop);
+         }
+         else
+	 {
+            skb_put(skb, len);
+            dequeue_sm_buf(card, skb);
+#ifdef NS_USE_DESTRUCTORS
+            skb->destructor = ns_sb_destructor;
+#endif /* NS_USE_DESTRUCTORS */
+            ATM_SKB(skb)->vcc = vcc;
+            do_gettimeofday(&skb->stamp);
+            vcc->push(vcc, skb);
+            atomic_inc(&vcc->stats->rx);
+         }
+      }
+      else if (NS_SKB(iovb)->iovcnt == 2)	/* One small plus one large buffer */
+      {
+         struct sk_buff *sb;
+
+         sb = (struct sk_buff *) (iov - 1)->iov_base;
+         /* skb points to a large buffer */
+
+         if (len <= NS_SMBUFSIZE)
+	 {
+            if (!atm_charge(vcc, sb->truesize))
+            {
+               push_rxbufs(card, BUF_SM, (u32) sb, (u32) virt_to_bus(sb->data),
+                           0, 0);
+               atomic_inc(&vcc->stats->rx_drop);
+            }
+            else
+	    {
+               skb_put(sb, len);
+               dequeue_sm_buf(card, sb);
+#ifdef NS_USE_DESTRUCTORS
+               sb->destructor = ns_sb_destructor;
+#endif /* NS_USE_DESTRUCTORS */
+               ATM_SKB(sb)->vcc = vcc;
+               do_gettimeofday(&sb->stamp);
+               vcc->push(vcc, sb);
+               atomic_inc(&vcc->stats->rx);
+            }
+
+            push_rxbufs(card, BUF_LG, (u32) skb,
+	                   (u32) virt_to_bus(skb->data), 0, 0);
+
+	 }
+	 else			/* len > NS_SMBUFSIZE, the usual case */
+	 {
+            if (!atm_charge(vcc, skb->truesize))
+            {
+               push_rxbufs(card, BUF_LG, (u32) skb,
+                           (u32) virt_to_bus(skb->data), 0, 0);
+               atomic_inc(&vcc->stats->rx_drop);
+            }
+            else
+            {
+               dequeue_lg_buf(card, skb);
+#ifdef NS_USE_DESTRUCTORS
+               skb->destructor = ns_lb_destructor;
+#endif /* NS_USE_DESTRUCTORS */
+               skb_push(skb, NS_SMBUFSIZE);
+               memcpy(skb->data, sb->data, NS_SMBUFSIZE);
+               skb_put(skb, len - NS_SMBUFSIZE);
+               ATM_SKB(skb)->vcc = vcc;
+               do_gettimeofday(&skb->stamp);
+               vcc->push(vcc, skb);
+               atomic_inc(&vcc->stats->rx);
+            }
+
+            push_rxbufs(card, BUF_SM, (u32) sb, (u32) virt_to_bus(sb->data),
+                        0, 0);
+
+         }
+	 
+      }
+      else				/* Must push a huge buffer */
+      {
+         struct sk_buff *hb, *sb, *lb;
+	 int remaining, tocopy;
+         int j;
+
+         hb = skb_dequeue(&(card->hbpool.queue));
+         if (hb == NULL)		/* No buffers in the queue */
+         {
+
+            hb = dev_alloc_skb(NS_HBUFSIZE);
+            if (hb == NULL)
+            {
+               printk("nicstar%d: Out of huge buffers.\n", card->index);
+               atomic_inc(&vcc->stats->rx_drop);
+               recycle_iovec_rx_bufs(card, (struct iovec *) iovb->data,
+	                             NS_SKB(iovb)->iovcnt);
+               vc->rx_iov = NULL;
+               recycle_iov_buf(card, iovb);
+               return;
+            }
+            else if (card->hbpool.count < card->hbnr.min)
+	    {
+               struct sk_buff *new_hb;
+               if ((new_hb = dev_alloc_skb(NS_HBUFSIZE)) != NULL)
+               {
+                  skb_queue_tail(&card->hbpool.queue, new_hb);
+                  card->hbpool.count++;
+               }
+            }
+	 }
+	 else
+         if (--card->hbpool.count < card->hbnr.min)
+         {
+            struct sk_buff *new_hb;
+            if ((new_hb = dev_alloc_skb(NS_HBUFSIZE)) != NULL)
+            {
+               skb_queue_tail(&card->hbpool.queue, new_hb);
+               card->hbpool.count++;
+            }
+            if (card->hbpool.count < card->hbnr.min)
+	    {
+               if ((new_hb = dev_alloc_skb(NS_HBUFSIZE)) != NULL)
+               {
+                  skb_queue_tail(&card->hbpool.queue, new_hb);
+                  card->hbpool.count++;
+               }
+            }
+         }
+
+         iov = (struct iovec *) iovb->data;
+
+         if (!atm_charge(vcc, hb->truesize))
+	 {
+            recycle_iovec_rx_bufs(card, iov, NS_SKB(iovb)->iovcnt);
+            if (card->hbpool.count < card->hbnr.max)
+            {
+               skb_queue_tail(&card->hbpool.queue, hb);
+               card->hbpool.count++;
+            }
+	    else
+	       dev_kfree_skb_any(hb);
+	    atomic_inc(&vcc->stats->rx_drop);
+         }
+         else
+	 {
+            /* Copy the small buffer to the huge buffer */
+            sb = (struct sk_buff *) iov->iov_base;
+            memcpy(hb->data, sb->data, iov->iov_len);
+            skb_put(hb, iov->iov_len);
+            remaining = len - iov->iov_len;
+            iov++;
+            /* Free the small buffer */
+            push_rxbufs(card, BUF_SM, (u32) sb, (u32) virt_to_bus(sb->data),
+                        0, 0);
+
+            /* Copy all large buffers to the huge buffer and free them */
+            for (j = 1; j < NS_SKB(iovb)->iovcnt; j++)
+            {
+               lb = (struct sk_buff *) iov->iov_base;
+               tocopy = min_t(int, remaining, iov->iov_len);
+               memcpy(hb->tail, lb->data, tocopy);
+               skb_put(hb, tocopy);
+               iov++;
+               remaining -= tocopy;
+               push_rxbufs(card, BUF_LG, (u32) lb,
+                           (u32) virt_to_bus(lb->data), 0, 0);
+            }
+#ifdef EXTRA_DEBUG
+            if (remaining != 0 || hb->len != len)
+               printk("nicstar%d: Huge buffer len mismatch.\n", card->index);
+#endif /* EXTRA_DEBUG */
+            ATM_SKB(hb)->vcc = vcc;
+#ifdef NS_USE_DESTRUCTORS
+            hb->destructor = ns_hb_destructor;
+#endif /* NS_USE_DESTRUCTORS */
+            do_gettimeofday(&hb->stamp);
+            vcc->push(vcc, hb);
+            atomic_inc(&vcc->stats->rx);
+         }
+      }
+
+      vc->rx_iov = NULL;
+      recycle_iov_buf(card, iovb);
+   }
+
+}
+
+
+
+#ifdef NS_USE_DESTRUCTORS
+
+static void ns_sb_destructor(struct sk_buff *sb)
+{
+   ns_dev *card;
+   u32 stat;
+
+   card = (ns_dev *) ATM_SKB(sb)->vcc->dev->dev_data;
+   stat = readl(card->membase + STAT);
+   card->sbfqc = ns_stat_sfbqc_get(stat);   
+   card->lbfqc = ns_stat_lfbqc_get(stat);
+
+   do
+   {
+      sb = __dev_alloc_skb(NS_SMSKBSIZE, GFP_KERNEL);
+      if (sb == NULL)
+         break;
+      skb_queue_tail(&card->sbpool.queue, sb);
+      skb_reserve(sb, NS_AAL0_HEADER);
+      push_rxbufs(card, BUF_SM, (u32) sb, (u32) virt_to_bus(sb->data), 0, 0);
+   } while (card->sbfqc < card->sbnr.min);
+}
+
+
+
+static void ns_lb_destructor(struct sk_buff *lb)
+{
+   ns_dev *card;
+   u32 stat;
+
+   card = (ns_dev *) ATM_SKB(lb)->vcc->dev->dev_data;
+   stat = readl(card->membase + STAT);
+   card->sbfqc = ns_stat_sfbqc_get(stat);   
+   card->lbfqc = ns_stat_lfbqc_get(stat);
+
+   do
+   {
+      lb = __dev_alloc_skb(NS_LGSKBSIZE, GFP_KERNEL);
+      if (lb == NULL)
+         break;
+      skb_queue_tail(&card->lbpool.queue, lb);
+      skb_reserve(lb, NS_SMBUFSIZE);
+      push_rxbufs(card, BUF_LG, (u32) lb, (u32) virt_to_bus(lb->data), 0, 0);
+   } while (card->lbfqc < card->lbnr.min);
+}
+
+
+
+static void ns_hb_destructor(struct sk_buff *hb)
+{
+   ns_dev *card;
+
+   card = (ns_dev *) ATM_SKB(hb)->vcc->dev->dev_data;
+
+   while (card->hbpool.count < card->hbnr.init)
+   {
+      hb = __dev_alloc_skb(NS_HBUFSIZE, GFP_KERNEL);
+      if (hb == NULL)
+         break;
+      skb_queue_tail(&card->hbpool.queue, hb);
+      card->hbpool.count++;
+   }
+}
+
+#endif /* NS_USE_DESTRUCTORS */
+
+
+
+static void recycle_rx_buf(ns_dev *card, struct sk_buff *skb)
+{
+   if (skb->list == &card->sbpool.queue)
+      push_rxbufs(card, BUF_SM, (u32) skb, (u32) virt_to_bus(skb->data), 0, 0);
+   else if (skb->list == &card->lbpool.queue)
+      push_rxbufs(card, BUF_LG, (u32) skb, (u32) virt_to_bus(skb->data), 0, 0);
+   else
+   {
+      printk("nicstar%d: What kind of rx buffer is this?\n", card->index);
+      dev_kfree_skb_any(skb);
+   }
+}
+
+
+
+static void recycle_iovec_rx_bufs(ns_dev *card, struct iovec *iov, int count)
+{
+   struct sk_buff *skb;
+
+   for (; count > 0; count--)
+   {
+      skb = (struct sk_buff *) (iov++)->iov_base;
+      if (skb->list == &card->sbpool.queue)
+         push_rxbufs(card, BUF_SM, (u32) skb, (u32) virt_to_bus(skb->data),
+	             0, 0);
+      else if (skb->list == &card->lbpool.queue)
+         push_rxbufs(card, BUF_LG, (u32) skb, (u32) virt_to_bus(skb->data),
+	             0, 0);
+      else
+      {
+         printk("nicstar%d: What kind of rx buffer is this?\n", card->index);
+         dev_kfree_skb_any(skb);
+      }
+   }
+}
+
+
+
+static void recycle_iov_buf(ns_dev *card, struct sk_buff *iovb)
+{
+   if (card->iovpool.count < card->iovnr.max)
+   {
+      skb_queue_tail(&card->iovpool.queue, iovb);
+      card->iovpool.count++;
+   }
+   else
+      dev_kfree_skb_any(iovb);
+}
+
+
+
+static void dequeue_sm_buf(ns_dev *card, struct sk_buff *sb)
+{
+   skb_unlink(sb);
+#ifdef NS_USE_DESTRUCTORS
+   if (card->sbfqc < card->sbnr.min)
+#else
+   if (card->sbfqc < card->sbnr.init)
+   {
+      struct sk_buff *new_sb;
+      if ((new_sb = dev_alloc_skb(NS_SMSKBSIZE)) != NULL)
+      {
+         skb_queue_tail(&card->sbpool.queue, new_sb);
+         skb_reserve(new_sb, NS_AAL0_HEADER);
+         push_rxbufs(card, BUF_SM, (u32) new_sb,
+                     (u32) virt_to_bus(new_sb->data), 0, 0);
+      }
+   }
+   if (card->sbfqc < card->sbnr.init)
+#endif /* NS_USE_DESTRUCTORS */
+   {
+      struct sk_buff *new_sb;
+      if ((new_sb = dev_alloc_skb(NS_SMSKBSIZE)) != NULL)
+      {
+         skb_queue_tail(&card->sbpool.queue, new_sb);
+         skb_reserve(new_sb, NS_AAL0_HEADER);
+         push_rxbufs(card, BUF_SM, (u32) new_sb,
+                     (u32) virt_to_bus(new_sb->data), 0, 0);
+      }
+   }
+}
+
+
+
+static void dequeue_lg_buf(ns_dev *card, struct sk_buff *lb)
+{
+   skb_unlink(lb);
+#ifdef NS_USE_DESTRUCTORS
+   if (card->lbfqc < card->lbnr.min)
+#else
+   if (card->lbfqc < card->lbnr.init)
+   {
+      struct sk_buff *new_lb;
+      if ((new_lb = dev_alloc_skb(NS_LGSKBSIZE)) != NULL)
+      {
+         skb_queue_tail(&card->lbpool.queue, new_lb);
+         skb_reserve(new_lb, NS_SMBUFSIZE);
+         push_rxbufs(card, BUF_LG, (u32) new_lb,
+                     (u32) virt_to_bus(new_lb->data), 0, 0);
+      }
+   }
+   if (card->lbfqc < card->lbnr.init)
+#endif /* NS_USE_DESTRUCTORS */
+   {
+      struct sk_buff *new_lb;
+      if ((new_lb = dev_alloc_skb(NS_LGSKBSIZE)) != NULL)
+      {
+         skb_queue_tail(&card->lbpool.queue, new_lb);
+         skb_reserve(new_lb, NS_SMBUFSIZE);
+         push_rxbufs(card, BUF_LG, (u32) new_lb,
+                     (u32) virt_to_bus(new_lb->data), 0, 0);
+      }
+   }
+}
+
+
+
+static int ns_proc_read(struct atm_dev *dev, loff_t *pos, char *page)
+{
+   u32 stat;
+   ns_dev *card;
+   int left;
+
+   left = (int) *pos;
+   card = (ns_dev *) dev->dev_data;
+   stat = readl(card->membase + STAT);
+   if (!left--)
+      return sprintf(page, "Pool   count    min   init    max \n");
+   if (!left--)
+      return sprintf(page, "Small  %5d  %5d  %5d  %5d \n",
+                     ns_stat_sfbqc_get(stat), card->sbnr.min, card->sbnr.init,
+		     card->sbnr.max);
+   if (!left--)
+      return sprintf(page, "Large  %5d  %5d  %5d  %5d \n",
+                     ns_stat_lfbqc_get(stat), card->lbnr.min, card->lbnr.init,
+		     card->lbnr.max);
+   if (!left--)
+      return sprintf(page, "Huge   %5d  %5d  %5d  %5d \n", card->hbpool.count,
+                     card->hbnr.min, card->hbnr.init, card->hbnr.max);
+   if (!left--)
+      return sprintf(page, "Iovec  %5d  %5d  %5d  %5d \n", card->iovpool.count,
+                     card->iovnr.min, card->iovnr.init, card->iovnr.max);
+   if (!left--)
+   {
+      int retval;
+      retval = sprintf(page, "Interrupt counter: %u \n", card->intcnt);
+      card->intcnt = 0;
+      return retval;
+   }
+#if 0
+   /* Dump 25.6 Mbps PHY registers */
+   /* Now there's a 25.6 Mbps PHY driver this code isn't needed. I left it
+      here just in case it's needed for debugging. */
+   if (card->max_pcr == ATM_25_PCR && !left--)
+   {
+      u32 phy_regs[4];
+      u32 i;
+
+      for (i = 0; i < 4; i++)
+      {
+         while (CMD_BUSY(card));
+         writel(NS_CMD_READ_UTILITY | 0x00000200 | i, card->membase + CMD);
+         while (CMD_BUSY(card));
+         phy_regs[i] = readl(card->membase + DR0) & 0x000000FF;
+      }
+
+      return sprintf(page, "PHY regs: 0x%02X 0x%02X 0x%02X 0x%02X \n",
+                     phy_regs[0], phy_regs[1], phy_regs[2], phy_regs[3]);
+   }
+#endif /* 0 - Dump 25.6 Mbps PHY registers */
+#if 0
+   /* Dump TST */
+   if (left-- < NS_TST_NUM_ENTRIES)
+   {
+      if (card->tste2vc[left + 1] == NULL)
+         return sprintf(page, "%5d - VBR/UBR \n", left + 1);
+      else
+         return sprintf(page, "%5d - %d %d \n", left + 1,
+                        card->tste2vc[left + 1]->tx_vcc->vpi,
+                        card->tste2vc[left + 1]->tx_vcc->vci);
+   }
+#endif /* 0 */
+   return 0;
+}
+
+
+
+static int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)
+{
+   ns_dev *card;
+   pool_levels pl;
+   int btype;
+   unsigned long flags;
+
+   card = dev->dev_data;
+   switch (cmd)
+   {
+      case NS_GETPSTAT:
+         if (get_user(pl.buftype, &((pool_levels __user *) arg)->buftype))
+	    return -EFAULT;
+         switch (pl.buftype)
+	 {
+	    case NS_BUFTYPE_SMALL:
+	       pl.count = ns_stat_sfbqc_get(readl(card->membase + STAT));
+	       pl.level.min = card->sbnr.min;
+	       pl.level.init = card->sbnr.init;
+	       pl.level.max = card->sbnr.max;
+	       break;
+
+	    case NS_BUFTYPE_LARGE:
+	       pl.count = ns_stat_lfbqc_get(readl(card->membase + STAT));
+	       pl.level.min = card->lbnr.min;
+	       pl.level.init = card->lbnr.init;
+	       pl.level.max = card->lbnr.max;
+	       break;
+
+	    case NS_BUFTYPE_HUGE:
+	       pl.count = card->hbpool.count;
+	       pl.level.min = card->hbnr.min;
+	       pl.level.init = card->hbnr.init;
+	       pl.level.max = card->hbnr.max;
+	       break;
+
+	    case NS_BUFTYPE_IOVEC:
+	       pl.count = card->iovpool.count;
+	       pl.level.min = card->iovnr.min;
+	       pl.level.init = card->iovnr.init;
+	       pl.level.max = card->iovnr.max;
+	       break;
+
+            default:
+	       return -ENOIOCTLCMD;
+
+	 }
+         if (!copy_to_user((pool_levels __user *) arg, &pl, sizeof(pl)))
+	    return (sizeof(pl));
+	 else
+	    return -EFAULT;
+
+      case NS_SETBUFLEV:
+         if (!capable(CAP_NET_ADMIN))
+	    return -EPERM;
+         if (copy_from_user(&pl, (pool_levels __user *) arg, sizeof(pl)))
+	    return -EFAULT;
+	 if (pl.level.min >= pl.level.init || pl.level.init >= pl.level.max)
+	    return -EINVAL;
+	 if (pl.level.min == 0)
+	    return -EINVAL;
+         switch (pl.buftype)
+	 {
+	    case NS_BUFTYPE_SMALL:
+               if (pl.level.max > TOP_SB)
+	          return -EINVAL;
+	       card->sbnr.min = pl.level.min;
+	       card->sbnr.init = pl.level.init;
+	       card->sbnr.max = pl.level.max;
+	       break;
+
+	    case NS_BUFTYPE_LARGE:
+               if (pl.level.max > TOP_LB)
+	          return -EINVAL;
+	       card->lbnr.min = pl.level.min;
+	       card->lbnr.init = pl.level.init;
+	       card->lbnr.max = pl.level.max;
+	       break;
+
+	    case NS_BUFTYPE_HUGE:
+               if (pl.level.max > TOP_HB)
+	          return -EINVAL;
+	       card->hbnr.min = pl.level.min;
+	       card->hbnr.init = pl.level.init;
+	       card->hbnr.max = pl.level.max;
+	       break;
+
+	    case NS_BUFTYPE_IOVEC:
+               if (pl.level.max > TOP_IOVB)
+	          return -EINVAL;
+	       card->iovnr.min = pl.level.min;
+	       card->iovnr.init = pl.level.init;
+	       card->iovnr.max = pl.level.max;
+	       break;
+
+            default:
+	       return -EINVAL;
+
+         }	 
+         return 0;
+
+      case NS_ADJBUFLEV:
+         if (!capable(CAP_NET_ADMIN))
+	    return -EPERM;
+         btype = (int) arg;	/* an int is the same size as a pointer */
+         switch (btype)
+	 {
+	    case NS_BUFTYPE_SMALL:
+	       while (card->sbfqc < card->sbnr.init)
+	       {
+                  struct sk_buff *sb;
+
+                  sb = __dev_alloc_skb(NS_SMSKBSIZE, GFP_KERNEL);
+                  if (sb == NULL)
+                     return -ENOMEM;
+                  skb_queue_tail(&card->sbpool.queue, sb);
+                  skb_reserve(sb, NS_AAL0_HEADER);
+                  push_rxbufs(card, BUF_SM, (u32) sb, (u32) virt_to_bus(sb->data), 0, 0);
+	       }
+	       break;
+
+            case NS_BUFTYPE_LARGE:
+	       while (card->lbfqc < card->lbnr.init)
+	       {
+                  struct sk_buff *lb;
+
+                  lb = __dev_alloc_skb(NS_LGSKBSIZE, GFP_KERNEL);
+                  if (lb == NULL)
+                     return -ENOMEM;
+                  skb_queue_tail(&card->lbpool.queue, lb);
+                  skb_reserve(lb, NS_SMBUFSIZE);
+                  push_rxbufs(card, BUF_LG, (u32) lb, (u32) virt_to_bus(lb->data), 0, 0);
+	       }
+	       break;
+
+            case NS_BUFTYPE_HUGE:
+               while (card->hbpool.count > card->hbnr.init)
+	       {
+                  struct sk_buff *hb;
+
+                  ns_grab_int_lock(card, flags);
+		  hb = skb_dequeue(&card->hbpool.queue);
+		  card->hbpool.count--;
+                  spin_unlock_irqrestore(&card->int_lock, flags);
+                  if (hb == NULL)
+		     printk("nicstar%d: huge buffer count inconsistent.\n",
+		            card->index);
+                  else
+		     dev_kfree_skb_any(hb);
+		  
+	       }
+               while (card->hbpool.count < card->hbnr.init)
+               {
+                  struct sk_buff *hb;
+
+                  hb = __dev_alloc_skb(NS_HBUFSIZE, GFP_KERNEL);
+                  if (hb == NULL)
+                     return -ENOMEM;
+                  ns_grab_int_lock(card, flags);
+                  skb_queue_tail(&card->hbpool.queue, hb);
+                  card->hbpool.count++;
+                  spin_unlock_irqrestore(&card->int_lock, flags);
+               }
+	       break;
+
+            case NS_BUFTYPE_IOVEC:
+	       while (card->iovpool.count > card->iovnr.init)
+	       {
+	          struct sk_buff *iovb;
+
+                  ns_grab_int_lock(card, flags);
+		  iovb = skb_dequeue(&card->iovpool.queue);
+		  card->iovpool.count--;
+                  spin_unlock_irqrestore(&card->int_lock, flags);
+                  if (iovb == NULL)
+		     printk("nicstar%d: iovec buffer count inconsistent.\n",
+		            card->index);
+                  else
+		     dev_kfree_skb_any(iovb);
+
+	       }
+               while (card->iovpool.count < card->iovnr.init)
+	       {
+	          struct sk_buff *iovb;
+
+                  iovb = alloc_skb(NS_IOVBUFSIZE, GFP_KERNEL);
+                  if (iovb == NULL)
+                     return -ENOMEM;
+                  ns_grab_int_lock(card, flags);
+                  skb_queue_tail(&card->iovpool.queue, iovb);
+                  card->iovpool.count++;
+                  spin_unlock_irqrestore(&card->int_lock, flags);
+	       }
+	       break;
+
+            default:
+	       return -EINVAL;
+
+	 }
+         return 0;
+
+      default:
+         if (dev->phy && dev->phy->ioctl) {
+            return dev->phy->ioctl(dev, cmd, arg);
+         }
+         else {
+            printk("nicstar%d: %s == NULL \n", card->index,
+                   dev->phy ? "dev->phy->ioctl" : "dev->phy");
+            return -ENOIOCTLCMD;
+         }
+   }
+}
+
+
+
+static void which_list(ns_dev *card, struct sk_buff *skb)
+{
+   printk("It's a %s buffer.\n", skb->list == &card->sbpool.queue ?
+          "small" : skb->list == &card->lbpool.queue ? "large" :
+	  skb->list == &card->hbpool.queue ? "huge" :
+	  skb->list == &card->iovpool.queue ? "iovec" : "unknown");
+}
+
+
+
+static void ns_poll(unsigned long arg)
+{
+   int i;
+   ns_dev *card;
+   unsigned long flags;
+   u32 stat_r, stat_w;
+
+   PRINTK("nicstar: Entering ns_poll().\n");
+   for (i = 0; i < num_cards; i++)
+   {
+      card = cards[i];
+      if (spin_is_locked(&card->int_lock)) {
+      /* Probably it isn't worth spinning */
+         continue;
+      }
+      ns_grab_int_lock(card, flags);
+
+      stat_w = 0;
+      stat_r = readl(card->membase + STAT);
+      if (stat_r & NS_STAT_TSIF)
+         stat_w |= NS_STAT_TSIF;
+      if (stat_r & NS_STAT_EOPDU)
+         stat_w |= NS_STAT_EOPDU;
+
+      process_tsq(card);
+      process_rsq(card);
+
+      writel(stat_w, card->membase + STAT);
+      spin_unlock_irqrestore(&card->int_lock, flags);
+   }
+   mod_timer(&ns_timer, jiffies + NS_POLL_PERIOD);
+   PRINTK("nicstar: Leaving ns_poll().\n");
+}
+
+
+
+static int ns_parse_mac(char *mac, unsigned char *esi)
+{
+   int i, j;
+   short byte1, byte0;
+
+   if (mac == NULL || esi == NULL)
+      return -1;
+   j = 0;
+   for (i = 0; i < 6; i++)
+   {
+      if ((byte1 = ns_h2i(mac[j++])) < 0)
+         return -1;
+      if ((byte0 = ns_h2i(mac[j++])) < 0)
+         return -1;
+      esi[i] = (unsigned char) (byte1 * 16 + byte0);
+      if (i < 5)
+      {
+         if (mac[j++] != ':')
+            return -1;
+      }
+   }
+   return 0;
+}
+
+
+
+static short ns_h2i(char c)
+{
+   if (c >= '0' && c <= '9')
+      return (short) (c - '0');
+   if (c >= 'A' && c <= 'F')
+      return (short) (c - 'A' + 10);
+   if (c >= 'a' && c <= 'f')
+      return (short) (c - 'a' + 10);
+   return -1;
+}
+
+
+
+static void ns_phy_put(struct atm_dev *dev, unsigned char value,
+                    unsigned long addr)
+{
+   ns_dev *card;
+   unsigned long flags;
+
+   card = dev->dev_data;
+   ns_grab_res_lock(card, flags);
+   while(CMD_BUSY(card));
+   writel((unsigned long) value, card->membase + DR0);
+   writel(NS_CMD_WRITE_UTILITY | 0x00000200 | (addr & 0x000000FF),
+          card->membase + CMD);
+   spin_unlock_irqrestore(&card->res_lock, flags);
+}
+
+
+
+static unsigned char ns_phy_get(struct atm_dev *dev, unsigned long addr)
+{
+   ns_dev *card;
+   unsigned long flags;
+   unsigned long data;
+
+   card = dev->dev_data;
+   ns_grab_res_lock(card, flags);
+   while(CMD_BUSY(card));
+   writel(NS_CMD_READ_UTILITY | 0x00000200 | (addr & 0x000000FF),
+          card->membase + CMD);
+   while(CMD_BUSY(card));
+   data = readl(card->membase + DR0) & 0x000000FF;
+   spin_unlock_irqrestore(&card->res_lock, flags);
+   return (unsigned char) data;
+}
+
+
+
+module_init(nicstar_init);
+module_exit(nicstar_cleanup);
