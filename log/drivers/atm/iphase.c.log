commit ea443e5e98b5b74e317ef3d26bcaea54931ccdee
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Tue Jul 30 22:21:41 2019 -0500

    atm: iphase: Fix Spectre v1 vulnerability
    
    board is controlled by user-space, hence leading to a potential
    exploitation of the Spectre variant 1 vulnerability.
    
    This issue was detected with the help of Smatch:
    
    drivers/atm/iphase.c:2765 ia_ioctl() warn: potential spectre issue 'ia_dev' [r] (local cap)
    drivers/atm/iphase.c:2774 ia_ioctl() warn: possible spectre second half.  'iadev'
    drivers/atm/iphase.c:2782 ia_ioctl() warn: possible spectre second half.  'iadev'
    drivers/atm/iphase.c:2816 ia_ioctl() warn: possible spectre second half.  'iadev'
    drivers/atm/iphase.c:2823 ia_ioctl() warn: possible spectre second half.  'iadev'
    drivers/atm/iphase.c:2830 ia_ioctl() warn: potential spectre issue '_ia_dev' [r] (local cap)
    drivers/atm/iphase.c:2845 ia_ioctl() warn: possible spectre second half.  'iadev'
    drivers/atm/iphase.c:2856 ia_ioctl() warn: possible spectre second half.  'iadev'
    
    Fix this by sanitizing board before using it to index ia_dev and _ia_dev
    
    Notice that given that speculation windows are large, the policy is
    to kill the speculation on the first load and not worry if it can be
    completed with a dependent load/store [1].
    
    [1] https://lore.kernel.org/lkml/20180423164740.GY17484@dhcp22.suse.cz/
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 302cf0ba1600..8c7a996d1f16 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -63,6 +63,7 @@
 #include <asm/byteorder.h>  
 #include <linux/vmalloc.h>
 #include <linux/jiffies.h>
+#include <linux/nospec.h>
 #include "iphase.h"		  
 #include "suni.h"		  
 #define swap_byte_order(x) (((x & 0xff) << 8) | ((x & 0xff00) >> 8))
@@ -2760,8 +2761,11 @@ static int ia_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)
    }
    if (copy_from_user(&ia_cmds, arg, sizeof ia_cmds)) return -EFAULT; 
    board = ia_cmds.status;
-   if ((board < 0) || (board > iadev_count))
-         board = 0;    
+
+	if ((board < 0) || (board > iadev_count))
+		board = 0;
+	board = array_index_nospec(board, iadev_count + 1);
+
    iadev = ia_dev[board];
    switch (ia_cmds.cmd) {
    case MEMDUMP:

commit 55c0dd8adda8f25a0bdc7b58a2dbe70b59a3dfbe
Author: Fuqian Huang <huangfq.daxian@gmail.com>
Date:   Wed May 15 08:42:48 2019 +0800

    atm: iphase: Avoid copying pointers to user space.
    
    Remove the MEMDUMP_DEV case in ia_ioctl to avoid copy
    pointers to user space.
    
    Signed-off-by: Fuqian Huang <huangfq.daxian@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 5278c57dce73..302cf0ba1600 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -2767,12 +2767,6 @@ static int ia_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)
    case MEMDUMP:
    {
 	switch (ia_cmds.sub_cmd) {
-       	  case MEMDUMP_DEV:     
-	     if (!capable(CAP_NET_ADMIN)) return -EPERM;
-	     if (copy_to_user(ia_cmds.buf, iadev, sizeof(IADEV)))
-                return -EFAULT;
-             ia_cmds.status = 0;
-             break;
           case MEMDUMP_SEGREG:
 	     if (!capable(CAP_NET_ADMIN)) return -EPERM;
              tmps = (u16 __user *)ia_cmds.buf;

commit 05453eadbf89c4f428ec0e6e962348f18e3a0caa
Author: Fuqian Huang <huangfq.daxian@gmail.com>
Date:   Sun Apr 21 19:46:54 2019 +0800

    atm: iphase: fix misuse of %x
    
    Pointers should be printed with %p or %px rather than
    cast to long type and printed with %x.
    Change %x to %p to print the pointers.
    
    Signed-off-by: Fuqian Huang <huangfq.daxian@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 82532c299bb5..5278c57dce73 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -2826,8 +2826,8 @@ static int ia_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)
          case 0x6:
          {  
              ia_cmds.status = 0; 
-             printk("skb = 0x%lx\n", (long)skb_peek(&iadev->tx_backlog));
-             printk("rtn_q: 0x%lx\n",(long)ia_deque_rtn_q(&iadev->tx_return_q));
+             printk("skb = 0x%p\n", skb_peek(&iadev->tx_backlog));
+             printk("rtn_q: 0x%p\n",ia_deque_rtn_q(&iadev->tx_return_q));
          }
              break;
          case 0x8:

commit 92291c95e71a7898109c1f95adfb48aa69e5ba7b
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Jun 28 12:24:42 2018 +0300

    atm: iphase: fix a 64 bit bug
    
    The code assumes that there is 4 bytes in a pointer and it doesn't
    allocate enough memory.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index ff81a576347e..82532c299bb5 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -1618,7 +1618,7 @@ static int rx_init(struct atm_dev *dev)
 	skb_queue_head_init(&iadev->rx_dma_q);  
 	iadev->rx_free_desc_qhead = NULL;   
 
-	iadev->rx_open = kcalloc(4, iadev->num_vc, GFP_KERNEL);
+	iadev->rx_open = kcalloc(iadev->num_vc, sizeof(void *), GFP_KERNEL);
 	if (!iadev->rx_open) {
 		printk(KERN_ERR DEV_LABEL "itf %d couldn't get free page\n",
 		dev->number);  

commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:03:40 2018 -0700

    treewide: kzalloc() -> kcalloc()
    
    The kzalloc() function has a 2-factor argument form, kcalloc(). This
    patch replaces cases of:
    
            kzalloc(a * b, gfp)
    
    with:
            kcalloc(a * b, gfp)
    
    as well as handling cases of:
    
            kzalloc(a * b * c, gfp)
    
    with:
    
            kzalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kzalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kzalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kzalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kzalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kzalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kzalloc
    + kcalloc
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kzalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(sizeof(THING) * C2, ...)
    |
      kzalloc(sizeof(TYPE) * C2, ...)
    |
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(C1 * C2, ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index be076606d30e..ff81a576347e 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -1618,7 +1618,7 @@ static int rx_init(struct atm_dev *dev)
 	skb_queue_head_init(&iadev->rx_dma_q);  
 	iadev->rx_free_desc_qhead = NULL;   
 
-	iadev->rx_open = kzalloc(4 * iadev->num_vc, GFP_KERNEL);
+	iadev->rx_open = kcalloc(4, iadev->num_vc, GFP_KERNEL);
 	if (!iadev->rx_open) {
 		printk(KERN_ERR DEV_LABEL "itf %d couldn't get free page\n",
 		dev->number);  

commit f3335545b34315fc42cc03a83165bdd26d956584
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Apr 18 16:55:05 2018 +0100

    atm: iphase: fix spelling mistake: "Tansmit" -> "Transmit"
    
    Trivial fix to spelling mistake in message text.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 44abb8a0a5e5..be076606d30e 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -671,7 +671,7 @@ static void ia_tx_poll (IADEV *iadev) {
           if ((vcc->pop) && (skb1->len != 0))
           {
              vcc->pop(vcc, skb1);
-             IF_EVENT(printk("Tansmit Done - skb 0x%lx return\n",
+             IF_EVENT(printk("Transmit Done - skb 0x%lx return\n",
                                                           (long)skb1);)
           }
           else 
@@ -1665,7 +1665,7 @@ static void tx_intr(struct atm_dev *dev)
 	status = readl(iadev->seg_reg+SEG_INTR_STATUS_REG);  
         if (status & TRANSMIT_DONE){
 
-           IF_EVENT(printk("Tansmit Done Intr logic run\n");)
+           IF_EVENT(printk("Transmit Done Intr logic run\n");)
            spin_lock_irqsave(&iadev->tx_lock, flags);
            ia_tx_poll(iadev);
            spin_unlock_irqrestore(&iadev->tx_lock, flags);

commit a9645b273e22662ebea563eae334eb3e4fc6614e
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Mar 29 00:18:53 2018 +0100

    atm: iphase: fix spelling mistake: "Receiverd" -> "Received"
    
    Trivial fix to spelling mistake in message text
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 98a3a43484c8..44abb8a0a5e5 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -3147,7 +3147,7 @@ static int ia_proc_read(struct atm_dev *dev,loff_t *pos,char *page)
                            "  Size of Tx Buffer  :  %u\n"
                            "  Number of Rx Buffer:  %u\n"
                            "  Size of Rx Buffer  :  %u\n"
-                           "  Packets Receiverd  :  %u\n"
+                           "  Packets Received   :  %u\n"
                            "  Packets Transmitted:  %u\n"
                            "  Cells Received     :  %u\n"
                            "  Cells Transmitted  :  %u\n"

commit 24ed960abf1d50cb7834e99a0cfc081bc0656712
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Aug 28 11:28:21 2017 -0700

    treewide: Switch DEFINE_TIMER callbacks to struct timer_list *
    
    This changes all DEFINE_TIMER() callbacks to use a struct timer_list
    pointer instead of unsigned long. Since the data argument has already been
    removed, none of these callbacks are using their argument currently, so
    this renames the argument to "unused".
    
    Done using the following semantic patch:
    
    @match_define_timer@
    declarer name DEFINE_TIMER;
    identifier _timer, _callback;
    @@
    
     DEFINE_TIMER(_timer, _callback);
    
    @change_callback depends on match_define_timer@
    identifier match_define_timer._callback;
    type _origtype;
    identifier _origarg;
    @@
    
     void
    -_callback(_origtype _origarg)
    +_callback(struct timer_list *unused)
     { ... }
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 12f646760b68..98a3a43484c8 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -75,7 +75,7 @@ static void desc_dbg(IADEV *iadev);
 static IADEV *ia_dev[8];
 static struct atm_dev *_ia_dev[8];
 static int iadev_count;
-static void ia_led_timer(unsigned long arg);
+static void ia_led_timer(struct timer_list *unused);
 static DEFINE_TIMER(ia_timer, ia_led_timer);
 static int IA_TX_BUF = DFL_TX_BUFFERS, IA_TX_BUF_SZ = DFL_TX_BUF_SZ;
 static int IA_RX_BUF = DFL_RX_BUFFERS, IA_RX_BUF_SZ = DFL_RX_BUF_SZ;
@@ -2432,7 +2432,7 @@ static void ia_update_stats(IADEV *iadev) {
     return;
 }
   
-static void ia_led_timer(unsigned long arg) {
+static void ia_led_timer(struct timer_list *unused) {
  	unsigned long flags;
   	static u_char blinking[8] = {0, 0, 0, 0, 0, 0, 0, 0};
         u_char i;

commit 5bbcc0f595fadb4cac0eddc4401035ec0bd95b09
Merge: 892204e06cb9 50895b9de1d3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 15 11:56:19 2017 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next
    
    Pull networking updates from David Miller:
     "Highlights:
    
       1) Maintain the TCP retransmit queue using an rbtree, with 1GB
          windows at 100Gb this really has become necessary. From Eric
          Dumazet.
    
       2) Multi-program support for cgroup+bpf, from Alexei Starovoitov.
    
       3) Perform broadcast flooding in hardware in mv88e6xxx, from Andrew
          Lunn.
    
       4) Add meter action support to openvswitch, from Andy Zhou.
    
       5) Add a data meta pointer for BPF accessible packets, from Daniel
          Borkmann.
    
       6) Namespace-ify almost all TCP sysctl knobs, from Eric Dumazet.
    
       7) Turn on Broadcom Tags in b53 driver, from Florian Fainelli.
    
       8) More work to move the RTNL mutex down, from Florian Westphal.
    
       9) Add 'bpftool' utility, to help with bpf program introspection.
          From Jakub Kicinski.
    
      10) Add new 'cpumap' type for XDP_REDIRECT action, from Jesper
          Dangaard Brouer.
    
      11) Support 'blocks' of transformations in the packet scheduler which
          can span multiple network devices, from Jiri Pirko.
    
      12) TC flower offload support in cxgb4, from Kumar Sanghvi.
    
      13) Priority based stream scheduler for SCTP, from Marcelo Ricardo
          Leitner.
    
      14) Thunderbolt networking driver, from Amir Levy and Mika Westerberg.
    
      15) Add RED qdisc offloadability, and use it in mlxsw driver. From
          Nogah Frankel.
    
      16) eBPF based device controller for cgroup v2, from Roman Gushchin.
    
      17) Add some fundamental tracepoints for TCP, from Song Liu.
    
      18) Remove garbage collection from ipv6 route layer, this is a
          significant accomplishment. From Wei Wang.
    
      19) Add multicast route offload support to mlxsw, from Yotam Gigi"
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next: (2177 commits)
      tcp: highest_sack fix
      geneve: fix fill_info when link down
      bpf: fix lockdep splat
      net: cdc_ncm: GetNtbFormat endian fix
      openvswitch: meter: fix NULL pointer dereference in ovs_meter_cmd_reply_start
      netem: remove unnecessary 64 bit modulus
      netem: use 64 bit divide by rate
      tcp: Namespace-ify sysctl_tcp_default_congestion_control
      net: Protect iterations over net::fib_notifier_ops in fib_seq_sum()
      ipv6: set all.accept_dad to 0 by default
      uapi: fix linux/tls.h userspace compilation error
      usbnet: ipheth: prevent TX queue timeouts when device not ready
      vhost_net: conditionally enable tx polling
      uapi: fix linux/rxrpc.h userspace compilation errors
      net: stmmac: fix LPI transitioning for dwmac4
      atm: horizon: Fix irq release error
      net-sysfs: trigger netlink notification on ifalias change via sysfs
      openvswitch: Using kfree_rcu() to simplify the code
      openvswitch: Make local function ovs_nsh_key_attr_size() static
      openvswitch: Fix return value check in ovs_meter_cmd_features()
      ...

commit 8caae31a8c2759fcdca7edc2bd41bba8d230a5cc
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Mon Oct 30 21:22:03 2017 +0530

    atm: iphase: Fix space before '[' error.
    
    Fix checkpatch.pl error:
    ERROR: space prohibited before open square bracket '['.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index fc72b763fdd7..a785c6e69757 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -880,7 +880,7 @@ static void ia_phy_write(struct iadev_priv *iadev,
 
 static void ia_suni_pm7345_init_ds3(struct iadev_priv *iadev)
 {
-	static const struct ia_reg suni_ds3_init [] = {
+	static const struct ia_reg suni_ds3_init[] = {
 		{ SUNI_DS3_FRM_INTR_ENBL,	0x17 },
 		{ SUNI_DS3_FRM_CFG,		0x01 },
 		{ SUNI_DS3_TRAN_CFG,		0x01 },
@@ -898,7 +898,7 @@ static void ia_suni_pm7345_init_ds3(struct iadev_priv *iadev)
 
 static void ia_suni_pm7345_init_e3(struct iadev_priv *iadev)
 {
-	static const struct ia_reg suni_e3_init [] = {
+	static const struct ia_reg suni_e3_init[] = {
 		{ SUNI_E3_FRM_FRAM_OPTIONS,		0x04 },
 		{ SUNI_E3_FRM_MAINT_OPTIONS,		0x20 },
 		{ SUNI_E3_FRM_FRAM_INTR_ENBL,		0x1d },
@@ -918,7 +918,7 @@ static void ia_suni_pm7345_init_e3(struct iadev_priv *iadev)
 
 static void ia_suni_pm7345_init(struct iadev_priv *iadev)
 {
-	static const struct ia_reg suni_init [] = {
+	static const struct ia_reg suni_init[] = {
 		/* Enable RSOP loss of signal interrupt. */
 		{ SUNI_INTR_ENBL,		0x28 },
 		/* Clear error counters. */

commit 1d27e3e2252ba9d949ca82fbdb73cde102cb2067
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 4 16:27:04 2017 -0700

    timer: Remove expires and data arguments from DEFINE_TIMER
    
    Drop the arguments from the macro and adjust all callers with the
    following script:
    
      perl -pi -e 's/DEFINE_TIMER\((.*), 0, 0\);/DEFINE_TIMER($1);/g;' \
        $(git grep DEFINE_TIMER | cut -d: -f1 | sort -u | grep -v timer.h)
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org> # for m68k parts
    Acked-by: Guenter Roeck <linux@roeck-us.net> # for watchdog parts
    Acked-by: David S. Miller <davem@davemloft.net> # for networking parts
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Kalle Valo <kvalo@codeaurora.org> # for wireless parts
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-mips@linux-mips.org
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Lai Jiangshan <jiangshanlai@gmail.com>
    Cc: Sebastian Reichel <sre@kernel.org>
    Cc: Kalle Valo <kvalo@qca.qualcomm.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: linux1394-devel@lists.sourceforge.net
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: linux-s390@vger.kernel.org
    Cc: linux-wireless@vger.kernel.org
    Cc: "James E.J. Bottomley" <jejb@linux.vnet.ibm.com>
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Ursula Braun <ubraun@linux.vnet.ibm.com>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Harish Patil <harish.patil@cavium.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Michael Reed <mdr@sgi.com>
    Cc: Manish Chopra <manish.chopra@cavium.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-pm@vger.kernel.org
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Julian Wiedmann <jwi@linux.vnet.ibm.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: linux-watchdog@vger.kernel.org
    Cc: linux-scsi@vger.kernel.org
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: netdev@vger.kernel.org
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lkml.kernel.org/r/1507159627-127660-11-git-send-email-keescook@chromium.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index fc72b763fdd7..ad6b582c268e 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -76,7 +76,7 @@ static IADEV *ia_dev[8];
 static struct atm_dev *_ia_dev[8];
 static int iadev_count;
 static void ia_led_timer(unsigned long arg);
-static DEFINE_TIMER(ia_timer, ia_led_timer, 0, 0);
+static DEFINE_TIMER(ia_timer, ia_led_timer);
 static int IA_TX_BUF = DFL_TX_BUFFERS, IA_TX_BUF_SZ = DFL_TX_BUF_SZ;
 static int IA_RX_BUF = DFL_RX_BUFFERS, IA_RX_BUF_SZ = DFL_RX_BUF_SZ;
 static uint IADebugFlag = /* IF_IADBG_ERR | IF_IADBG_CBR| IF_IADBG_INIT_ADAPTER

commit 10244bc2ae7d8543190f4c651cdfaf030c50a802
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Sun Jul 16 15:02:29 2017 +0530

    atm: iphase: constify pci_device_id.
    
    pci_device_id are not supposed to change at runtime. All functions
    working with pci_device_id provided by <linux/pci.h> work with
    const pci_device_id. So mark the non-const structs as const.
    
    File size before:
       text    data     bss     dec     hex filename
      23536     432     160   24128    5e40 drivers/atm/iphase.o
    
    File size After adding 'const':
       text    data     bss     dec     hex filename
      23632     336     160   24128    5e40 drivers/atm/iphase.o
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index a4fa6c82261e..fc72b763fdd7 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -3266,7 +3266,7 @@ static void ia_remove_one(struct pci_dev *pdev)
       	kfree(iadev);
 }
 
-static struct pci_device_id ia_pci_tbl[] = {
+static const struct pci_device_id ia_pci_tbl[] = {
 	{ PCI_VENDOR_ID_IPHASE, 0x0008, PCI_ANY_ID, PCI_ANY_ID, },
 	{ PCI_VENDOR_ID_IPHASE, 0x0009, PCI_ANY_ID, PCI_ANY_ID, },
 	{ 0,}

commit 4091fb95b5f8dea37568d1a94c8227244bade891
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Feb 27 14:29:56 2017 -0800

    scripts/spelling.txt: add "followings" pattern and fix typo instances
    
    Fix typos and add the following to the scripts/spelling.txt:
    
      followings||following
    
    While we are here, add a missing colon in the boilerplate in DT binding
    documents.  The "you SoC" in allwinner,sunxi-pinctrl.txt was fixed as
    well.
    
    I reworded "as the followings:" to "as follows:" for
    drivers/usb/gadget/udc/renesas_usb3.c.
    
    Link: http://lkml.kernel.org/r/1481573103-11329-32-git-send-email-yamada.masahiro@socionext.com
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 8640bafeb471..a4fa6c82261e 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -21,7 +21,7 @@
       supports a variety of varients of Interphase ATM PCI (i)Chip adapter 
       card family (See www.iphase.com/products/ClassSheet.cfm?ClassID=ATM) 
       in terms of PHY type, the size of control memory and the size of 
-      packet memory. The followings are the change log and history:
+      packet memory. The following are the change log and history:
      
           Bugfix the Mona's UBR driver.
           Modify the basic memory allocation and dma logic.

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index b2756765950e..8640bafeb471 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -58,7 +58,7 @@
 #include <linux/slab.h>
 #include <asm/io.h>  
 #include <linux/atomic.h>
-#include <asm/uaccess.h>  
+#include <linux/uaccess.h>  
 #include <asm/string.h>  
 #include <asm/byteorder.h>  
 #include <linux/vmalloc.h>

commit d560846e40fefd7b6e5c29d115f1d8f73db7f5e6
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Sep 12 13:01:50 2016 +0100

    atm: iphase: fix newline escape and minor tweak to source formatting
    
    The newline escape is incorrect and needs fixing. Also adjust source
    formatting / indentation and add { } to trailing else.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 9d8807e76639..b2756765950e 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -1885,9 +1885,9 @@ static int open_tx(struct atm_vcc *vcc)
                 if ((ret = ia_cbr_setup (iadev, vcc)) < 0) {     
                     return ret;
                 }
-       } 
-	else  
-           printk("iadev:  Non UBR, ABR and CBR traffic not supportedn"); 
+	} else {
+		printk("iadev:  Non UBR, ABR and CBR traffic not supported\n");
+	}
         
         iadev->testTable[vcc->vci]->vc_status |= VC_ACTIVE;
 	IF_EVENT(printk("ia open_tx returning \n");)  

commit e808bb6ed042020d3a15cb6e85ca646bc7c9eda8
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Fri Sep 9 20:40:16 2016 +0200

    ATM-iphase: Use kmalloc_array() in tx_init()
    
    * Multiplications for the size determination of memory allocations
      indicated that array data structures should be processed.
      Thus use the corresponding function "kmalloc_array".
    
      This issue was detected by using the Coccinelle software.
    
    * Replace the specification of data types by pointer dereferences
      to make the corresponding size determination a bit safer according to
      the Linux coding style convention.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 809dd1e02091..9d8807e76639 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -1975,7 +1975,9 @@ static int tx_init(struct atm_dev *dev)
 		buf_desc_ptr++;		  
 		tx_pkt_start += iadev->tx_buf_sz;  
 	}  
-        iadev->tx_buf = kmalloc(iadev->num_tx_desc*sizeof(struct cpcs_trailer_desc), GFP_KERNEL);
+	iadev->tx_buf = kmalloc_array(iadev->num_tx_desc,
+				      sizeof(*iadev->tx_buf),
+				      GFP_KERNEL);
         if (!iadev->tx_buf) {
             printk(KERN_ERR DEV_LABEL " couldn't get mem\n");
 	    goto err_free_dle;
@@ -1995,8 +1997,9 @@ static int tx_init(struct atm_dev *dev)
 						       sizeof(*cpcs),
 						       DMA_TO_DEVICE);
         }
-        iadev->desc_tbl = kmalloc(iadev->num_tx_desc *
-                                   sizeof(struct desc_tbl_t), GFP_KERNEL);
+	iadev->desc_tbl = kmalloc_array(iadev->num_tx_desc,
+					sizeof(*iadev->desc_tbl),
+					GFP_KERNEL);
 	if (!iadev->desc_tbl) {
 		printk(KERN_ERR DEV_LABEL " couldn't get mem\n");
 		goto err_free_all_tx_bufs;
@@ -2124,7 +2127,9 @@ static int tx_init(struct atm_dev *dev)
 	memset((caddr_t)(iadev->seg_ram+i),  0, iadev->num_vc*4);
 	vc = (struct main_vc *)iadev->MAIN_VC_TABLE_ADDR;  
 	evc = (struct ext_vc *)iadev->EXT_VC_TABLE_ADDR;  
-        iadev->testTable = kmalloc(sizeof(long)*iadev->num_vc, GFP_KERNEL); 
+	iadev->testTable = kmalloc_array(iadev->num_vc,
+					 sizeof(*iadev->testTable),
+					 GFP_KERNEL);
         if (!iadev->testTable) {
            printk("Get freepage  failed\n");
 	   goto err_free_desc_tbl;

commit f2633d2eaaab773ea8b29cea3785cf0f8a8872a5
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri May 27 13:34:35 2016 +0300

    atm: iphase: off by one in rx_pkt()
    
    The iadev->rx_open[] array holds "iadev->num_vc" pointers (this code
    assumes that pointers are 32 bits).  So the > here should be >= or else
    we could end up reading a garbage pointer from one element beyond the
    end of the array.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 7d00f2994738..809dd1e02091 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -1128,7 +1128,7 @@ static int rx_pkt(struct atm_dev *dev)
 	/* make the ptr point to the corresponding buffer desc entry */  
 	buf_desc_ptr += desc;	  
         if (!desc || (desc > iadev->num_rx_desc) || 
-                      ((buf_desc_ptr->vc_index & 0xffff) > iadev->num_vc)) { 
+                      ((buf_desc_ptr->vc_index & 0xffff) >= iadev->num_vc)) {
             free_desc(dev, desc);
             IF_ERR(printk("IA: bad descriptor desc = %d \n", desc);)
             return -1;

commit cbb41b91e68a302087762823136c9067138cff7c
Author: Tillmann Heidsieck <theidsieck@leenox.de>
Date:   Sat Oct 10 21:47:19 2015 +0200

    atm: iphase: fix misleading indention
    
    Fix a smatch warning:
    drivers/atm/iphase.c:1178 rx_pkt() warn: curly braces intended?
    
    The code is correct, the indention is misleading. In case the allocation
    of skb fails, we want to skip to the end.
    
    Signed-off-by: Tillmann Heidsieck <theidsieck@leenox.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index d5010d7a99c3..7d00f2994738 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -1176,7 +1176,7 @@ static int rx_pkt(struct atm_dev *dev)
         if (!(skb = atm_alloc_charge(vcc, len, GFP_ATOMIC))) {
            if (vcc->vci < 32)
               printk("Drop control packets\n");
-	      goto out_free_desc;
+	   goto out_free_desc;
         }
 	skb_put(skb,len);  
         // pwang_test

commit 21e26ff993dea9dceaf0f19cfec4bef58387b0f2
Author: Tillmann Heidsieck <theidsieck@leenox.de>
Date:   Sat Oct 10 21:47:18 2015 +0200

    atm: iphase: return -ENOMEM instead of -1 in case of failed kmalloc()
    
    Smatch complains about returning hard coded error codes, silence this
    warning.
    
    drivers/atm/iphase.c:115 ia_enque_rtn_q() warn: returning -1 instead of -ENOMEM is sloppy
    
    Signed-off-by: Tillmann Heidsieck <theidsieck@leenox.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 65e65903faa0..d5010d7a99c3 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -112,7 +112,8 @@ static void ia_enque_head_rtn_q (IARTN_Q *que, IARTN_Q * data)
 
 static int ia_enque_rtn_q (IARTN_Q *que, struct desc_tbl_t data) {
    IARTN_Q *entry = kmalloc(sizeof(*entry), GFP_ATOMIC);
-   if (!entry) return -1;
+   if (!entry)
+      return -ENOMEM;
    entry->data = data;
    entry->next = NULL;
    if (que->next == NULL) 

commit 684b4ac14f4306c877834a8daaf0f0665128eae4
Author: Nicholas Mc Guire <hofrat@osadl.org>
Date:   Mon Jun 8 21:16:28 2015 +0200

    atm: use msecs_to_jiffies for conversions
    
    API compliance scanning with coccinelle flagged:
    ./drivers/atm/iphase.c:2621:4-20:
            WARNING: timeout (50) seems HZ dependent
    
    Numeric constants passed to schedule_timeout() make the effective
    timeout HZ dependent which does not seem intended.
    Fixed up by converting the constant to jiffies with msecs_to_jiffies()
    As this driver was introduced in the early 2.3 series it is most
    likely assuming HZ=100 so the constant 50 is converted to 500ms.
    
    Signed-off-by: Nicholas Mc Guire <hofrat@osadl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 924f8e26789d..65e65903faa0 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -2618,7 +2618,7 @@ static void ia_close(struct atm_vcc *vcc)
         if (vcc->qos.txtp.traffic_class != ATM_NONE) {
            iadev->close_pending++;
 	   prepare_to_wait(&iadev->timeout_wait, &wait, TASK_UNINTERRUPTIBLE);
-	   schedule_timeout(50);
+	   schedule_timeout(msecs_to_jiffies(500));
 	   finish_wait(&iadev->timeout_wait, &wait);
            spin_lock_irqsave(&iadev->tx_lock, flags); 
            while((skb = skb_dequeue(&iadev->tx_backlog))) {

commit ede58ef28e105de94475b2b69fa069c9a2ce6933
Author: chas williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
Date:   Fri Jan 16 08:57:21 2015 -0500

    atm: remove deprecated use of pci api
    
    Signed-off-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 4217f29a85e0..924f8e26789d 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -1185,8 +1185,8 @@ static int rx_pkt(struct atm_dev *dev)
 
 	/* Build the DLE structure */  
 	wr_ptr = iadev->rx_dle_q.write;  
-	wr_ptr->sys_pkt_addr = pci_map_single(iadev->pci, skb->data,
-		len, PCI_DMA_FROMDEVICE);
+	wr_ptr->sys_pkt_addr = dma_map_single(&iadev->pci->dev, skb->data,
+					      len, DMA_FROM_DEVICE);
 	wr_ptr->local_pkt_addr = buf_addr;  
 	wr_ptr->bytes = len;	/* We don't know this do we ?? */  
 	wr_ptr->mode = DMA_INT_ENABLE;  
@@ -1306,8 +1306,8 @@ static void rx_dle_intr(struct atm_dev *dev)
           u_short length;
           struct ia_vcc *ia_vcc;
 
-	  pci_unmap_single(iadev->pci, iadev->rx_dle_q.write->sys_pkt_addr,
-	  	len, PCI_DMA_FROMDEVICE);
+	  dma_unmap_single(&iadev->pci->dev, iadev->rx_dle_q.write->sys_pkt_addr,
+			   len, DMA_FROM_DEVICE);
           /* no VCC related housekeeping done as yet. lets see */  
           vcc = ATM_SKB(skb)->vcc;
 	  if (!vcc) {
@@ -1430,8 +1430,8 @@ static int rx_init(struct atm_dev *dev)
   //    spin_lock_init(&iadev->rx_lock); 
   
 	/* Allocate 4k bytes - more aligned than needed (4k boundary) */
-	dle_addr = pci_alloc_consistent(iadev->pci, DLE_TOTAL_SIZE,
-					&iadev->rx_dle_dma);  
+	dle_addr = dma_alloc_coherent(&iadev->pci->dev, DLE_TOTAL_SIZE,
+				      &iadev->rx_dle_dma, GFP_KERNEL);
 	if (!dle_addr)  {  
 		printk(KERN_ERR DEV_LABEL "can't allocate DLEs\n");
 		goto err_out;
@@ -1631,8 +1631,8 @@ static int rx_init(struct atm_dev *dev)
 	return 0;  
 
 err_free_dle:
-	pci_free_consistent(iadev->pci, DLE_TOTAL_SIZE, iadev->rx_dle_q.start,
-			    iadev->rx_dle_dma);  
+	dma_free_coherent(&iadev->pci->dev, DLE_TOTAL_SIZE, iadev->rx_dle_q.start,
+			  iadev->rx_dle_dma);
 err_out:
 	return -ENOMEM;
 }  
@@ -1702,8 +1702,8 @@ static void tx_dle_intr(struct atm_dev *dev)
 
 	    /* Revenge of the 2 dle (skb + trailer) used in ia_pkt_tx() */
 	    if (!((dle - iadev->tx_dle_q.start)%(2*sizeof(struct dle)))) {
-		pci_unmap_single(iadev->pci, dle->sys_pkt_addr, skb->len,
-				 PCI_DMA_TODEVICE);
+		dma_unmap_single(&iadev->pci->dev, dle->sys_pkt_addr, skb->len,
+				 DMA_TO_DEVICE);
 	    }
             vcc = ATM_SKB(skb)->vcc;
             if (!vcc) {
@@ -1917,8 +1917,8 @@ static int tx_init(struct atm_dev *dev)
                                 readw(iadev->seg_reg+SEG_MASK_REG));)  
 
 	/* Allocate 4k (boundary aligned) bytes */
-	dle_addr = pci_alloc_consistent(iadev->pci, DLE_TOTAL_SIZE,
-					&iadev->tx_dle_dma);  
+	dle_addr = dma_alloc_coherent(&iadev->pci->dev, DLE_TOTAL_SIZE,
+				      &iadev->tx_dle_dma, GFP_KERNEL);
 	if (!dle_addr)  {
 		printk(KERN_ERR DEV_LABEL "can't allocate DLEs\n");
 		goto err_out;
@@ -1989,8 +1989,10 @@ static int tx_init(struct atm_dev *dev)
 		goto err_free_tx_bufs;
             }
 	    iadev->tx_buf[i].cpcs = cpcs;
-	    iadev->tx_buf[i].dma_addr = pci_map_single(iadev->pci,
-		cpcs, sizeof(*cpcs), PCI_DMA_TODEVICE);
+	    iadev->tx_buf[i].dma_addr = dma_map_single(&iadev->pci->dev,
+						       cpcs,
+						       sizeof(*cpcs),
+						       DMA_TO_DEVICE);
         }
         iadev->desc_tbl = kmalloc(iadev->num_tx_desc *
                                    sizeof(struct desc_tbl_t), GFP_KERNEL);
@@ -2198,14 +2200,14 @@ static int tx_init(struct atm_dev *dev)
 	while (--i >= 0) {
 		struct cpcs_trailer_desc *desc = iadev->tx_buf + i;
 
-		pci_unmap_single(iadev->pci, desc->dma_addr,
-			sizeof(*desc->cpcs), PCI_DMA_TODEVICE);
+		dma_unmap_single(&iadev->pci->dev, desc->dma_addr,
+				 sizeof(*desc->cpcs), DMA_TO_DEVICE);
 		kfree(desc->cpcs);
 	}
 	kfree(iadev->tx_buf);
 err_free_dle:
-	pci_free_consistent(iadev->pci, DLE_TOTAL_SIZE, iadev->tx_dle_q.start,
-			    iadev->tx_dle_dma);  
+	dma_free_coherent(&iadev->pci->dev, DLE_TOTAL_SIZE, iadev->tx_dle_q.start,
+			  iadev->tx_dle_dma);
 err_out:
 	return -ENOMEM;
 }   
@@ -2476,20 +2478,20 @@ static void ia_free_tx(IADEV *iadev)
 	for (i = 0; i < iadev->num_tx_desc; i++) {
 		struct cpcs_trailer_desc *desc = iadev->tx_buf + i;
 
-		pci_unmap_single(iadev->pci, desc->dma_addr,
-			sizeof(*desc->cpcs), PCI_DMA_TODEVICE);
+		dma_unmap_single(&iadev->pci->dev, desc->dma_addr,
+				 sizeof(*desc->cpcs), DMA_TO_DEVICE);
 		kfree(desc->cpcs);
 	}
 	kfree(iadev->tx_buf);
-	pci_free_consistent(iadev->pci, DLE_TOTAL_SIZE, iadev->tx_dle_q.start,
-			    iadev->tx_dle_dma);  
+	dma_free_coherent(&iadev->pci->dev, DLE_TOTAL_SIZE, iadev->tx_dle_q.start,
+			  iadev->tx_dle_dma);
 }
 
 static void ia_free_rx(IADEV *iadev)
 {
 	kfree(iadev->rx_open);
-	pci_free_consistent(iadev->pci, DLE_TOTAL_SIZE, iadev->rx_dle_q.start,
-			  iadev->rx_dle_dma);  
+	dma_free_coherent(&iadev->pci->dev, DLE_TOTAL_SIZE, iadev->rx_dle_q.start,
+			  iadev->rx_dle_dma);
 }
 
 static int ia_start(struct atm_dev *dev)
@@ -3009,8 +3011,8 @@ static int ia_pkt_tx (struct atm_vcc *vcc, struct sk_buff *skb) {
 	/* Build the DLE structure */  
 	wr_ptr = iadev->tx_dle_q.write;  
 	memset((caddr_t)wr_ptr, 0, sizeof(*wr_ptr));  
-	wr_ptr->sys_pkt_addr = pci_map_single(iadev->pci, skb->data,
-		skb->len, PCI_DMA_TODEVICE);
+	wr_ptr->sys_pkt_addr = dma_map_single(&iadev->pci->dev, skb->data,
+					      skb->len, DMA_TO_DEVICE);
 	wr_ptr->local_pkt_addr = (buf_desc_ptr->buf_start_hi << 16) | 
                                                   buf_desc_ptr->buf_start_lo;  
 	/* wr_ptr->bytes = swap_byte_order(total_len); didn't seem to affect?? */

commit 6c44512d06d3f6afcead304f051f4a06ed9be2cd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:25:04 2012 -0800

    Drivers: atm: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 96cce6d53195..4217f29a85e0 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -2299,7 +2299,7 @@ static int reset_sar(struct atm_dev *dev)
 }  
 	  
 	  
-static int __devinit ia_init(struct atm_dev *dev)
+static int ia_init(struct atm_dev *dev)
 {  
 	IADEV *iadev;  
 	unsigned long real_base;
@@ -2492,7 +2492,7 @@ static void ia_free_rx(IADEV *iadev)
 			  iadev->rx_dle_dma);  
 }
 
-static int __devinit ia_start(struct atm_dev *dev)
+static int ia_start(struct atm_dev *dev)
 {  
 	IADEV *iadev;  
 	int error;  
@@ -3168,8 +3168,7 @@ static const struct atmdev_ops ops = {
 	.owner		= THIS_MODULE,
 };  
 	  
-static int __devinit ia_init_one(struct pci_dev *pdev,
-				 const struct pci_device_id *ent)
+static int ia_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 {  
 	struct atm_dev *dev;  
 	IADEV *iadev;  
@@ -3229,7 +3228,7 @@ static int __devinit ia_init_one(struct pci_dev *pdev,
 	return ret;
 }
 
-static void __devexit ia_remove_one(struct pci_dev *pdev)
+static void ia_remove_one(struct pci_dev *pdev)
 {
 	struct atm_dev *dev = pci_get_drvdata(pdev);
 	IADEV *iadev = INPH_IA_DEV(dev);
@@ -3270,7 +3269,7 @@ static struct pci_driver ia_driver = {
 	.name =         DEV_LABEL,
 	.id_table =     ia_pci_tbl,
 	.probe =        ia_init_one,
-	.remove =       __devexit_p(ia_remove_one),
+	.remove =       ia_remove_one,
 };
 
 static int __init ia_module_init(void)

commit f716168b8aee528cf685246f0e7247aa0d08b79c
Author: Julia Lawall <julia@diku.dk>
Date:   Sat Aug 4 23:52:36 2012 +0000

    drivers/atm/iphase.c: fix error return code
    
    Convert a 0 error return code to a negative one, as returned elsewhere in the
    function.
    
    A simplified version of the semantic match that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    identifier ret;
    expression e,e1,e2,e3,e4,x;
    @@
    
    (
    if (\(ret != 0\|ret < 0\) || ...) { ... return ...; }
    |
    ret = 0
    )
    ... when != ret = e1
    *x = \(kmalloc\|kzalloc\|kcalloc\|devm_kzalloc\|ioremap\|ioremap_nocache\|devm_ioremap\|devm_ioremap_nocache\)(...);
    ... when != x = e2
        when != ret = e3
    *if (x == NULL || ...)
    {
      ... when != ret = e4
    *  return ret;
    }
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index d4386019af5d..96cce6d53195 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -2362,7 +2362,7 @@ static int __devinit ia_init(struct atm_dev *dev)
 	{  
 		printk(DEV_LABEL " (itf %d): can't set up page mapping\n",  
 			    dev->number);  
-		return error;  
+		return -ENOMEM;
 	}  
 	IF_INIT(printk(DEV_LABEL " (itf %d): rev.%d,base=%p,irq=%d\n",  
 			dev->number, iadev->pci->revision, base, iadev->irq);)

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 9e373ba20308..d4386019af5d 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -56,7 +56,6 @@
 #include <linux/interrupt.h>
 #include <linux/wait.h>
 #include <linux/slab.h>
-#include <asm/system.h>  
 #include <asm/io.h>  
 #include <linux/atomic.h>
 #include <asm/uaccess.h>  

commit 49f5ed4250c757cb19d953fcac2737a35ca14d76
Author: chas williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
Date:   Tue Nov 22 12:51:56 2011 +0000

    atm: eliminate atm_guess_pdu2truesize()
    
    Signed-off-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 3d0c2b0fed9c..9e373ba20308 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -1320,8 +1320,8 @@ static void rx_dle_intr(struct atm_dev *dev)
           if (ia_vcc == NULL)
           {
              atomic_inc(&vcc->stats->rx_err);
+             atm_return(vcc, skb->truesize);
              dev_kfree_skb_any(skb);
-             atm_return(vcc, atm_guess_pdu2truesize(len));
              goto INCR_DLE;
            }
           // get real pkt length  pwang_test
@@ -1334,8 +1334,8 @@ static void rx_dle_intr(struct atm_dev *dev)
              atomic_inc(&vcc->stats->rx_err);
              IF_ERR(printk("rx_dle_intr: Bad  AAL5 trailer %d (skb len %d)", 
                                                             length, skb->len);)
+             atm_return(vcc, skb->truesize);
              dev_kfree_skb_any(skb);
-             atm_return(vcc, atm_guess_pdu2truesize(len));
              goto INCR_DLE;
           }
           skb_trim(skb, length);

commit 26c5c44d63824f7c397d27b10c2c43a3bab4a2f0
Author: franois romieu <romieu@fr.zoreil.com>
Date:   Fri Sep 30 00:37:43 2011 +0000

    atm/iphase : removal of PCI space dereferences.
    
    Mostly PHY access and a few (ugly) debug statements for DMA control.
    
    Signed-off-by: Francois Romieu <romieu@fr.zoreil.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index cb90f7a3e074..3d0c2b0fed9c 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -818,127 +818,152 @@ static void ia_hw_type(IADEV *iadev) {
 
 }
 
-static void IaFrontEndIntr(IADEV *iadev) {
-  volatile IA_SUNI *suni;
-  volatile ia_mb25_t *mb25;
-  volatile suni_pm7345_t *suni_pm7345;
-
-  if(iadev->phy_type & FE_25MBIT_PHY) {
-     mb25 = (ia_mb25_t*)iadev->phy;
-     iadev->carrier_detect =  Boolean(mb25->mb25_intr_status & MB25_IS_GSB);
-  } else if (iadev->phy_type & FE_DS3_PHY) {
-     suni_pm7345 = (suni_pm7345_t *)iadev->phy;
-     /* clear FRMR interrupts */
-     (void) suni_pm7345->suni_ds3_frm_intr_stat; 
-     iadev->carrier_detect =  
-           Boolean(!(suni_pm7345->suni_ds3_frm_stat & SUNI_DS3_LOSV));
-  } else if (iadev->phy_type & FE_E3_PHY ) {
-     suni_pm7345 = (suni_pm7345_t *)iadev->phy;
-     (void) suni_pm7345->suni_e3_frm_maint_intr_ind;
-     iadev->carrier_detect =
-           Boolean(!(suni_pm7345->suni_e3_frm_fram_intr_ind_stat&SUNI_E3_LOS));
-  }
-  else { 
-     suni = (IA_SUNI *)iadev->phy;
-     (void) suni->suni_rsop_status;
-     iadev->carrier_detect = Boolean(!(suni->suni_rsop_status & SUNI_LOSV));
-  }
-  if (iadev->carrier_detect)
-    printk("IA: SUNI carrier detected\n");
-  else
-    printk("IA: SUNI carrier lost signal\n"); 
-  return;
+static u32 ia_phy_read32(struct iadev_priv *ia, unsigned int reg)
+{
+	return readl(ia->phy + (reg >> 2));
+}
+
+static void ia_phy_write32(struct iadev_priv *ia, unsigned int reg, u32 val)
+{
+	writel(val, ia->phy + (reg >> 2));
+}
+
+static void ia_frontend_intr(struct iadev_priv *iadev)
+{
+	u32 status;
+
+	if (iadev->phy_type & FE_25MBIT_PHY) {
+		status = ia_phy_read32(iadev, MB25_INTR_STATUS);
+		iadev->carrier_detect = (status & MB25_IS_GSB) ? 1 : 0;
+	} else if (iadev->phy_type & FE_DS3_PHY) {
+		ia_phy_read32(iadev, SUNI_DS3_FRM_INTR_STAT);
+		status = ia_phy_read32(iadev, SUNI_DS3_FRM_STAT);
+		iadev->carrier_detect = (status & SUNI_DS3_LOSV) ? 0 : 1;
+	} else if (iadev->phy_type & FE_E3_PHY) {
+		ia_phy_read32(iadev, SUNI_E3_FRM_MAINT_INTR_IND);
+		status = ia_phy_read32(iadev, SUNI_E3_FRM_FRAM_INTR_IND_STAT);
+		iadev->carrier_detect = (status & SUNI_E3_LOS) ? 0 : 1;
+	} else {
+		status = ia_phy_read32(iadev, SUNI_RSOP_STATUS);
+		iadev->carrier_detect = (status & SUNI_LOSV) ? 0 : 1;
+	}
+
+	printk(KERN_INFO "IA: SUNI carrier %s\n",
+		iadev->carrier_detect ? "detected" : "lost signal");
 }
 
-static void ia_mb25_init (IADEV *iadev)
+static void ia_mb25_init(struct iadev_priv *iadev)
 {
-   volatile ia_mb25_t  *mb25 = (ia_mb25_t*)iadev->phy;
 #if 0
    mb25->mb25_master_ctrl = MB25_MC_DRIC | MB25_MC_DREC | MB25_MC_ENABLED;
 #endif
-   mb25->mb25_master_ctrl = MB25_MC_DRIC | MB25_MC_DREC;
-   mb25->mb25_diag_control = 0;
-   /*
-    * Initialize carrier detect state
-    */
-   iadev->carrier_detect =  Boolean(mb25->mb25_intr_status & MB25_IS_GSB);
-   return;
-}                   
+	ia_phy_write32(iadev, MB25_MASTER_CTRL, MB25_MC_DRIC | MB25_MC_DREC);
+	ia_phy_write32(iadev, MB25_DIAG_CONTROL, 0);
+
+	iadev->carrier_detect =
+		(ia_phy_read32(iadev, MB25_INTR_STATUS) & MB25_IS_GSB) ? 1 : 0;
+}
 
-static void ia_suni_pm7345_init (IADEV *iadev)
+struct ia_reg {
+	u16 reg;
+	u16 val;
+};
+
+static void ia_phy_write(struct iadev_priv *iadev,
+			 const struct ia_reg *regs, int len)
 {
-   volatile suni_pm7345_t *suni_pm7345 = (suni_pm7345_t *)iadev->phy;
-   if (iadev->phy_type & FE_DS3_PHY)
-   {
-      iadev->carrier_detect = 
-          Boolean(!(suni_pm7345->suni_ds3_frm_stat & SUNI_DS3_LOSV)); 
-      suni_pm7345->suni_ds3_frm_intr_enbl = 0x17;
-      suni_pm7345->suni_ds3_frm_cfg = 1;
-      suni_pm7345->suni_ds3_tran_cfg = 1;
-      suni_pm7345->suni_config = 0;
-      suni_pm7345->suni_splr_cfg = 0;
-      suni_pm7345->suni_splt_cfg = 0;
-   }
-   else 
-   {
-      iadev->carrier_detect = 
-          Boolean(!(suni_pm7345->suni_e3_frm_fram_intr_ind_stat & SUNI_E3_LOS));
-      suni_pm7345->suni_e3_frm_fram_options = 0x4;
-      suni_pm7345->suni_e3_frm_maint_options = 0x20;
-      suni_pm7345->suni_e3_frm_fram_intr_enbl = 0x1d;
-      suni_pm7345->suni_e3_frm_maint_intr_enbl = 0x30;
-      suni_pm7345->suni_e3_tran_stat_diag_options = 0x0;
-      suni_pm7345->suni_e3_tran_fram_options = 0x1;
-      suni_pm7345->suni_config = SUNI_PM7345_E3ENBL;
-      suni_pm7345->suni_splr_cfg = 0x41;
-      suni_pm7345->suni_splt_cfg = 0x41;
-   } 
-   /*
-    * Enable RSOP loss of signal interrupt.
-    */
-   suni_pm7345->suni_intr_enbl = 0x28;
- 
-   /*
-    * Clear error counters
-    */
-   suni_pm7345->suni_id_reset = 0;
-
-   /*
-    * Clear "PMCTST" in master test register.
-    */
-   suni_pm7345->suni_master_test = 0;
-
-   suni_pm7345->suni_rxcp_ctrl = 0x2c;
-   suni_pm7345->suni_rxcp_fctrl = 0x81;
- 
-   suni_pm7345->suni_rxcp_idle_pat_h1 =
-   	suni_pm7345->suni_rxcp_idle_pat_h2 =
-   	suni_pm7345->suni_rxcp_idle_pat_h3 = 0;
-   suni_pm7345->suni_rxcp_idle_pat_h4 = 1;
- 
-   suni_pm7345->suni_rxcp_idle_mask_h1 = 0xff;
-   suni_pm7345->suni_rxcp_idle_mask_h2 = 0xff;
-   suni_pm7345->suni_rxcp_idle_mask_h3 = 0xff;
-   suni_pm7345->suni_rxcp_idle_mask_h4 = 0xfe;
- 
-   suni_pm7345->suni_rxcp_cell_pat_h1 =
-   	suni_pm7345->suni_rxcp_cell_pat_h2 =
-   	suni_pm7345->suni_rxcp_cell_pat_h3 = 0;
-   suni_pm7345->suni_rxcp_cell_pat_h4 = 1;
- 
-   suni_pm7345->suni_rxcp_cell_mask_h1 =
-   	suni_pm7345->suni_rxcp_cell_mask_h2 =
-   	suni_pm7345->suni_rxcp_cell_mask_h3 =
-   	suni_pm7345->suni_rxcp_cell_mask_h4 = 0xff;
- 
-   suni_pm7345->suni_txcp_ctrl = 0xa4;
-   suni_pm7345->suni_txcp_intr_en_sts = 0x10;
-   suni_pm7345->suni_txcp_idle_pat_h5 = 0x55;
- 
-   suni_pm7345->suni_config &= ~(SUNI_PM7345_LLB |
-                                 SUNI_PM7345_CLB |
-                                 SUNI_PM7345_DLB |
-                                  SUNI_PM7345_PLB);
+	while (len--) {
+		ia_phy_write32(iadev, regs->reg, regs->val);
+		regs++;
+	}
+}
+
+static void ia_suni_pm7345_init_ds3(struct iadev_priv *iadev)
+{
+	static const struct ia_reg suni_ds3_init [] = {
+		{ SUNI_DS3_FRM_INTR_ENBL,	0x17 },
+		{ SUNI_DS3_FRM_CFG,		0x01 },
+		{ SUNI_DS3_TRAN_CFG,		0x01 },
+		{ SUNI_CONFIG,			0 },
+		{ SUNI_SPLR_CFG,		0 },
+		{ SUNI_SPLT_CFG,		0 }
+	};
+	u32 status;
+
+	status = ia_phy_read32(iadev, SUNI_DS3_FRM_STAT);
+	iadev->carrier_detect = (status & SUNI_DS3_LOSV) ? 0 : 1;
+
+	ia_phy_write(iadev, suni_ds3_init, ARRAY_SIZE(suni_ds3_init));
+}
+
+static void ia_suni_pm7345_init_e3(struct iadev_priv *iadev)
+{
+	static const struct ia_reg suni_e3_init [] = {
+		{ SUNI_E3_FRM_FRAM_OPTIONS,		0x04 },
+		{ SUNI_E3_FRM_MAINT_OPTIONS,		0x20 },
+		{ SUNI_E3_FRM_FRAM_INTR_ENBL,		0x1d },
+		{ SUNI_E3_FRM_MAINT_INTR_ENBL,		0x30 },
+		{ SUNI_E3_TRAN_STAT_DIAG_OPTIONS,	0 },
+		{ SUNI_E3_TRAN_FRAM_OPTIONS,		0x01 },
+		{ SUNI_CONFIG,				SUNI_PM7345_E3ENBL },
+		{ SUNI_SPLR_CFG,			0x41 },
+		{ SUNI_SPLT_CFG,			0x41 }
+	};
+	u32 status;
+
+	status = ia_phy_read32(iadev, SUNI_E3_FRM_FRAM_INTR_IND_STAT);
+	iadev->carrier_detect = (status & SUNI_E3_LOS) ? 0 : 1;
+	ia_phy_write(iadev, suni_e3_init, ARRAY_SIZE(suni_e3_init));
+}
+
+static void ia_suni_pm7345_init(struct iadev_priv *iadev)
+{
+	static const struct ia_reg suni_init [] = {
+		/* Enable RSOP loss of signal interrupt. */
+		{ SUNI_INTR_ENBL,		0x28 },
+		/* Clear error counters. */
+		{ SUNI_ID_RESET,		0 },
+		/* Clear "PMCTST" in master test register. */
+		{ SUNI_MASTER_TEST,		0 },
+
+		{ SUNI_RXCP_CTRL,		0x2c },
+		{ SUNI_RXCP_FCTRL,		0x81 },
+
+		{ SUNI_RXCP_IDLE_PAT_H1,	0 },
+		{ SUNI_RXCP_IDLE_PAT_H2,	0 },
+		{ SUNI_RXCP_IDLE_PAT_H3,	0 },
+		{ SUNI_RXCP_IDLE_PAT_H4,	0x01 },
+
+		{ SUNI_RXCP_IDLE_MASK_H1,	0xff },
+		{ SUNI_RXCP_IDLE_MASK_H2,	0xff },
+		{ SUNI_RXCP_IDLE_MASK_H3,	0xff },
+		{ SUNI_RXCP_IDLE_MASK_H4,	0xfe },
+
+		{ SUNI_RXCP_CELL_PAT_H1,	0 },
+		{ SUNI_RXCP_CELL_PAT_H2,	0 },
+		{ SUNI_RXCP_CELL_PAT_H3,	0 },
+		{ SUNI_RXCP_CELL_PAT_H4,	0x01 },
+
+		{ SUNI_RXCP_CELL_MASK_H1,	0xff },
+		{ SUNI_RXCP_CELL_MASK_H2,	0xff },
+		{ SUNI_RXCP_CELL_MASK_H3,	0xff },
+		{ SUNI_RXCP_CELL_MASK_H4,	0xff },
+
+		{ SUNI_TXCP_CTRL,		0xa4 },
+		{ SUNI_TXCP_INTR_EN_STS,	0x10 },
+		{ SUNI_TXCP_IDLE_PAT_H5,	0x55 }
+	};
+
+	if (iadev->phy_type & FE_DS3_PHY)
+		ia_suni_pm7345_init_ds3(iadev);
+	else
+		ia_suni_pm7345_init_e3(iadev);
+
+	ia_phy_write(iadev, suni_init, ARRAY_SIZE(suni_init));
+
+	ia_phy_write32(iadev, SUNI_CONFIG, ia_phy_read32(iadev, SUNI_CONFIG) &
+		~(SUNI_PM7345_LLB | SUNI_PM7345_CLB |
+		  SUNI_PM7345_DLB | SUNI_PM7345_PLB));
 #ifdef __SNMP__
    suni_pm7345->suni_rxcp_intr_en_sts |= SUNI_OOCDE;
 #endif /* __SNMP__ */
@@ -1425,10 +1450,10 @@ static int rx_init(struct atm_dev *dev)
 	       iadev->dma + IPHASE5575_RX_LIST_ADDR);  
 	IF_INIT(printk("Tx Dle list addr: 0x%p value: 0x%0x\n",
                       iadev->dma+IPHASE5575_TX_LIST_ADDR,
-                      *(u32*)(iadev->dma+IPHASE5575_TX_LIST_ADDR));  
+                      readl(iadev->dma + IPHASE5575_TX_LIST_ADDR));
 	printk("Rx Dle list addr: 0x%p value: 0x%0x\n",
                       iadev->dma+IPHASE5575_RX_LIST_ADDR,
-                      *(u32*)(iadev->dma+IPHASE5575_RX_LIST_ADDR));)  
+                      readl(iadev->dma + IPHASE5575_RX_LIST_ADDR));)
   
 	writew(0xffff, iadev->reass_reg+REASS_MASK_REG);  
 	writew(0, iadev->reass_reg+MODE_REG);  
@@ -2208,7 +2233,7 @@ static irqreturn_t ia_int(int irq, void *dev_id)
 	if (status & STAT_DLERINT)  
 	{  
 	   /* Clear this bit by writing a 1 to it. */  
-	   *(u_int *)(iadev->reg+IPHASE5575_BUS_STATUS_REG) = STAT_DLERINT;
+	   writel(STAT_DLERINT, iadev->reg + IPHASE5575_BUS_STATUS_REG);
 	   rx_dle_intr(dev);  
 	}  
 	if (status & STAT_SEGINT)  
@@ -2219,13 +2244,13 @@ static irqreturn_t ia_int(int irq, void *dev_id)
 	}  
 	if (status & STAT_DLETINT)  
 	{  
-	   *(u_int *)(iadev->reg+IPHASE5575_BUS_STATUS_REG) = STAT_DLETINT;  
+	   writel(STAT_DLETINT, iadev->reg + IPHASE5575_BUS_STATUS_REG);
 	   tx_dle_intr(dev);  
 	}  
 	if (status & (STAT_FEINT | STAT_ERRINT | STAT_MARKINT))  
 	{  
            if (status & STAT_FEINT) 
-               IaFrontEndIntr(iadev);
+               ia_frontend_intr(iadev);
 	}  
    }
    return IRQ_RETVAL(handled);
@@ -2556,7 +2581,7 @@ static int __devinit ia_start(struct atm_dev *dev)
 				goto err_free_rx;
 		}
 		/* Get iadev->carrier_detect status */
-		IaFrontEndIntr(iadev);
+		ia_frontend_intr(iadev);
 	}
 	return 0;
 
@@ -2827,7 +2852,7 @@ static int ia_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)
 
          case 0xb:
 	    if (!capable(CAP_NET_ADMIN)) return -EPERM;
-            IaFrontEndIntr(iadev);
+            ia_frontend_intr(iadev);
             break;
          case 0xa:
 	    if (!capable(CAP_NET_ADMIN)) return -EPERM;

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 957106f636ea..cb90f7a3e074 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -58,7 +58,7 @@
 #include <linux/slab.h>
 #include <asm/system.h>  
 #include <asm/io.h>  
-#include <asm/atomic.h>  
+#include <linux/atomic.h>
 #include <asm/uaccess.h>  
 #include <asm/string.h>  
 #include <asm/byteorder.h>  

commit a6b7a407865aab9f849dd99a71072b7cd1175116
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Jun 6 10:43:46 2011 +0000

    net: remove interrupt.h inclusion from netdevice.h
    
    * remove interrupt.g inclusion from netdevice.h -- not needed
    * fixup fallout, add interrupt.h and hardirq.h back where needed.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index dee4f01a64d8..957106f636ea 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -53,6 +53,7 @@
 #include <linux/delay.h>  
 #include <linux/uio.h>  
 #include <linux/init.h>  
+#include <linux/interrupt.h>
 #include <linux/wait.h>
 #include <linux/slab.h>
 #include <asm/system.h>  

commit 24743537d3f784a8b3014e934fad0a9c45e4e789
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Apr 12 16:14:21 2011 -0700

    atm: iphase: Fix set-but-not-used warnings.
    
    The "iavcc" and "iadev" cases are obvious.
    
    The intr_status and frmr_intr cases are reading a register to clear
    the chip status.  This driver is pretty old and creaky, and uses
    volatile pointer dereferences to do register I/O when it should be
    using readl() and friends.  However that it outside of the scope of
    these changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 1c674a91f146..dee4f01a64d8 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -613,7 +613,6 @@ static int ia_que_tx (IADEV *iadev) {
    struct sk_buff *skb;
    int num_desc;
    struct atm_vcc *vcc;
-   struct ia_vcc *iavcc;
    num_desc = ia_avail_descs(iadev);
 
    while (num_desc && (skb = skb_dequeue(&iadev->tx_backlog))) {
@@ -627,7 +626,6 @@ static int ia_que_tx (IADEV *iadev) {
          printk("Free the SKB on closed vci %d \n", vcc->vci);
          break;
       }
-      iavcc = INPH_IA_VCC(vcc);
       if (ia_pkt_tx (vcc, skb)) {
          skb_queue_head(&iadev->tx_backlog, skb);
       }
@@ -823,8 +821,6 @@ static void IaFrontEndIntr(IADEV *iadev) {
   volatile IA_SUNI *suni;
   volatile ia_mb25_t *mb25;
   volatile suni_pm7345_t *suni_pm7345;
-  u32 intr_status;
-  u_int frmr_intr;
 
   if(iadev->phy_type & FE_25MBIT_PHY) {
      mb25 = (ia_mb25_t*)iadev->phy;
@@ -832,18 +828,18 @@ static void IaFrontEndIntr(IADEV *iadev) {
   } else if (iadev->phy_type & FE_DS3_PHY) {
      suni_pm7345 = (suni_pm7345_t *)iadev->phy;
      /* clear FRMR interrupts */
-     frmr_intr   = suni_pm7345->suni_ds3_frm_intr_stat; 
+     (void) suni_pm7345->suni_ds3_frm_intr_stat; 
      iadev->carrier_detect =  
            Boolean(!(suni_pm7345->suni_ds3_frm_stat & SUNI_DS3_LOSV));
   } else if (iadev->phy_type & FE_E3_PHY ) {
      suni_pm7345 = (suni_pm7345_t *)iadev->phy;
-     frmr_intr   = suni_pm7345->suni_e3_frm_maint_intr_ind;
+     (void) suni_pm7345->suni_e3_frm_maint_intr_ind;
      iadev->carrier_detect =
            Boolean(!(suni_pm7345->suni_e3_frm_fram_intr_ind_stat&SUNI_E3_LOS));
   }
   else { 
      suni = (IA_SUNI *)iadev->phy;
-     intr_status = suni->suni_rsop_status & 0xff;
+     (void) suni->suni_rsop_status;
      iadev->carrier_detect = Boolean(!(suni->suni_rsop_status & SUNI_LOSV));
   }
   if (iadev->carrier_detect)
@@ -2660,7 +2656,6 @@ static void ia_close(struct atm_vcc *vcc)
   
 static int ia_open(struct atm_vcc *vcc)
 {  
-	IADEV *iadev;  
 	struct ia_vcc *ia_vcc;  
 	int error;  
 	if (!test_bit(ATM_VF_PARTIAL,&vcc->flags))  
@@ -2668,7 +2663,6 @@ static int ia_open(struct atm_vcc *vcc)
 		IF_EVENT(printk("ia: not partially allocated resources\n");)  
 		vcc->dev_data = NULL;
 	}  
-	iadev = INPH_IA_DEV(vcc->dev);  
 	if (vcc->vci != ATM_VPI_UNSPEC && vcc->vpi != ATM_VCI_UNSPEC)  
 	{  
 		IF_EVENT(printk("iphase open: unspec part\n");)  
@@ -3052,11 +3046,9 @@ static int ia_pkt_tx (struct atm_vcc *vcc, struct sk_buff *skb) {
 static int ia_send(struct atm_vcc *vcc, struct sk_buff *skb)
 {
         IADEV *iadev; 
-        struct ia_vcc *iavcc;
         unsigned long flags;
 
         iadev = INPH_IA_DEV(vcc->dev);
-        iavcc = INPH_IA_VCC(vcc); 
         if ((!skb)||(skb->len>(iadev->tx_buf_sz-sizeof(struct cpcs_trailer))))
         {
             if (!skb)

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index d80d51b62a1a..1c674a91f146 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -1025,7 +1025,7 @@ static void desc_dbg(IADEV *iadev) {
 } 
   
   
-/*----------------------------- Recieving side stuff --------------------------*/  
+/*----------------------------- Receiving side stuff --------------------------*/  
  
 static void rx_excp_rcvd(struct atm_dev *dev)  
 {  
@@ -1195,7 +1195,7 @@ static void rx_intr(struct atm_dev *dev)
   if (status & RX_PKT_RCVD)  
   {  
 	/* do something */  
-	/* Basically recvd an interrupt for receving a packet.  
+	/* Basically recvd an interrupt for receiving a packet.  
 	A descriptor would have been written to the packet complete   
 	queue. Get all the descriptors and set up dma to move the   
 	packets till the packet complete queue is empty..  
@@ -1855,7 +1855,7 @@ static int open_tx(struct atm_vcc *vcc)
                     return -EINVAL; 
                 }
                 if (vcc->qos.txtp.max_pcr > iadev->LineRate) {
-                   IF_CBR(printk("PCR is not availble\n");)
+                   IF_CBR(printk("PCR is not available\n");)
                    return -1;
                 }
                 vc->type = CBR;

commit 4b7bd364700d9ac8372eff48832062b936d0793b
Merge: c0d8768af260 90a8a73c06cc
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Dec 22 18:57:02 2010 +0100

    Merge branch 'master' into for-next
    
    Conflicts:
            MAINTAINERS
            arch/arm/mach-omap2/pm24xx.c
            drivers/scsi/bfa/bfa_fcpim.c
    
    Needed to update to apply fixes for which the old branch was too
    outdated.

commit d9ca676bcb26e1fdff9265a3e70f697cd381c889
Author: Dan Williams <dcbw@redhat.com>
Date:   Wed Dec 8 19:40:47 2010 +0000

    atm: correct sysfs 'device' link creation and parent relationships
    
    The ATM subsystem was incorrectly creating the 'device' link for ATM
    nodes in sysfs.  This led to incorrect device/parent relationships
    exposed by sysfs and udev.  Instead of rolling the 'device' link by hand
    in the generic ATM code, pass each ATM driver's bus device down to the
    sysfs code and let sysfs do this stuff correctly.
    
    Signed-off-by: Dan Williams <dcbw@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 9309d4724e13..729254053758 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -3172,7 +3172,7 @@ static int __devinit ia_init_one(struct pci_dev *pdev,
 		ret = -ENODEV;
 		goto err_out_free_iadev;
 	}
-	dev = atm_dev_register(DEV_LABEL, &ops, -1, NULL);
+	dev = atm_dev_register(DEV_LABEL, &pdev->dev, &ops, -1, NULL);
 	if (!dev) {
 		ret = -ENOMEM;
 		goto err_out_disable_dev;

commit b595076a180a56d1bb170e6eceda6eb9d76f4cd3
Author: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
Date:   Mon Nov 1 15:38:34 2010 -0400

    tree-wide: fix comment/printk typos
    
    "gadget", "through", "command", "maintain", "maintain", "controller", "address",
    "between", "initiali[zs]e", "instead", "function", "select", "already",
    "equal", "access", "management", "hierarchy", "registration", "interest",
    "relative", "memory", "offset", "already",
    
    Signed-off-by: Uwe Kleine-Knig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 9309d4724e13..ad8e207784d4 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -2063,7 +2063,7 @@ static int tx_init(struct atm_dev *dev)
 		- UBR Table size is 4K  
 		- UBR wait queue is 4K  
 	   since the table and wait queues are contiguous, all the bytes   
-	   can be initialized by one memeset.  
+	   can be initialized by one memeset.
 	*/  
         
         vcsize_sel = 0;
@@ -2089,7 +2089,7 @@ static int tx_init(struct atm_dev *dev)
 		- ABR Table size is 2K  
 		- ABR wait queue is 2K  
 	   since the table and wait queues are contiguous, all the bytes   
-	   can be intialized by one memeset.  
+	   can be initialized by one memeset.
 	*/  
         i = ABR_SCHED_TABLE * iadev->memSize;
         writew((i >> 11) & 0xffff, iadev->seg_reg+ABR_SBPTR_BASE);

commit d122179a3c0fdc71b88cb9e3605f372b1651a9ff
Merge: 419c20465d63 b00916b189d1
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Oct 11 12:30:34 2010 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
            net/core/ethtool.c

commit ec622ab072e95cf96e78ab4d39d4eea874518c80
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Sun Oct 10 23:26:57 2010 +0000

    ATM: iphase, remove sleep-inside-atomic
    
    Stanse found that ia_init_one locks a spinlock and inside of that it
    calls ia_start which calls:
    * request_irq
    * tx_init which does kmalloc(GFP_KERNEL)
    
    Both of them can thus sleep and result in a deadlock. I don't see a
    reason to have a per-device spinlock there which is used only there
    and inited right before the lock location. So remove it completely.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index ee9ddeb53417..8cb0347dec28 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -3156,7 +3156,6 @@ static int __devinit ia_init_one(struct pci_dev *pdev,
 {  
 	struct atm_dev *dev;  
 	IADEV *iadev;  
-        unsigned long flags;
 	int ret;
 
 	iadev = kzalloc(sizeof(*iadev), GFP_KERNEL);
@@ -3188,19 +3187,14 @@ static int __devinit ia_init_one(struct pci_dev *pdev,
 	ia_dev[iadev_count] = iadev;
 	_ia_dev[iadev_count] = dev;
 	iadev_count++;
-	spin_lock_init(&iadev->misc_lock);
-	/* First fixes first. I don't want to think about this now. */
-	spin_lock_irqsave(&iadev->misc_lock, flags); 
 	if (ia_init(dev) || ia_start(dev)) {  
 		IF_INIT(printk("IA register failed!\n");)
 		iadev_count--;
 		ia_dev[iadev_count] = NULL;
 		_ia_dev[iadev_count] = NULL;
-		spin_unlock_irqrestore(&iadev->misc_lock, flags); 
 		ret = -EINVAL;
 		goto err_out_deregister_dev;
 	}
-	spin_unlock_irqrestore(&iadev->misc_lock, flags); 
 	IF_EVENT(printk("iadev_count = %d\n", iadev_count);)
 
 	iadev->next_board = ia_boards;  

commit 6f74dbbc29df6f53bc0deaa8e5a6ff81a4f91534
Author: Julia Lawall <julia@diku.dk>
Date:   Thu Aug 5 10:25:24 2010 +0000

    drivers/atm: Adjust confusing if indentation
    
    Indent the branch of an if.
    
    The semantic match that finds this problem is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r disable braces4@
    position p1,p2;
    statement S1,S2;
    @@
    
    (
    if (...) { ... }
    |
    if (...) S1@p1 S2@p2
    )
    
    @script:python@
    p1 << r.p1;
    p2 << r.p2;
    @@
    
    if (p1[0].column == p2[0].column):
      cocci.print_main("branch",p1)
      cocci.print_secs("after",p2)
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index ee9ddeb53417..8b358d7d958f 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -220,7 +220,7 @@ static u16 get_desc (IADEV *dev, struct ia_vcc *iavcc) {
   while (!desc_num || (dev->desc_tbl[desc_num -1]).timestamp) {
      dev->ffL.tcq_rd += 2;
      if (dev->ffL.tcq_rd > dev->ffL.tcq_ed) 
-     dev->ffL.tcq_rd = dev->ffL.tcq_st;
+	dev->ffL.tcq_rd = dev->ffL.tcq_st;
      if (dev->ffL.tcq_rd == dev->host_tcq_wr) 
         return 0xFFFF; 
      desc_num = *(u_short *)(dev->seg_ram + dev->ffL.tcq_rd);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 25a4c86f839b..ee9ddeb53417 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -54,6 +54,7 @@
 #include <linux/uio.h>  
 #include <linux/init.h>  
 #include <linux/wait.h>
+#include <linux/slab.h>
 #include <asm/system.h>  
 #include <asm/io.h>  
 #include <asm/atomic.h>  

commit 710708e82bfbdd392ebdef5743e68fef0fde91a6
Author: Julia Lawall <julia@diku.dk>
Date:   Sun Dec 13 01:40:55 2009 +0000

    drivers/atm: Correct code taking the size of a pointer
    
    sizeof(TstSchedTbl) is just the size of the pointer.  Change it to the size
    of the referenced data.
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    expression *x;
    expression f;
    type T;
    @@
    
    *f(...,(T)x,...)
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index f734b345ac71..25a4c86f839b 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -557,7 +557,7 @@ static int ia_cbr_setup (IADEV *dev, struct atm_vcc *vcc) {
           memcpy((caddr_t)&cbrVC,(caddr_t)TstSchedTbl,sizeof(cbrVC));
        } /* while */
        // Move this VCI number into this location of the CBR Sched table.
-       memcpy((caddr_t)TstSchedTbl, (caddr_t)&vcIndex,sizeof(TstSchedTbl));
+       memcpy((caddr_t)TstSchedTbl, (caddr_t)&vcIndex, sizeof(*TstSchedTbl));
        dev->CbrRemEntries--;
        toBeAssigned--;
    } /* while */ 

commit af901ca181d92aac3a7dc265144a9081a86d8f39
Author: Andr Goddard Rosa <andre.goddard@gmail.com>
Date:   Sat Nov 14 13:09:05 2009 -0200

    tree-wide: fix assorted typos all over the place
    
    That is "success", "unknown", "through", "performance", "[re|un]mapping"
    , "access", "default", "reasonable", "[con]currently", "temperature"
    , "channel", "[un]used", "application", "example","hierarchy", "therefore"
    , "[over|under]flow", "contiguous", "threshold", "enough" and others.
    
    Signed-off-by: Andr Goddard Rosa <andre.goddard@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index b2c1b37ab2e4..f734b345ac71 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -1132,7 +1132,7 @@ static int rx_pkt(struct atm_dev *dev)
                     IF_ERR(printk(" cause: packet time out\n");)
                 }
                 else {
-                    IF_ERR(printk(" cause: buffer over flow\n");)
+                    IF_ERR(printk(" cause: buffer overflow\n");)
                 }
 		goto out_free_desc;
 	}  

commit b7058842c940ad2c08dd829b21e5c92ebe3b8758
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Sep 30 16:12:20 2009 -0700

    net: Make setsockopt() optlen be unsigned.
    
    This provides safety against negative optlen at the type
    level instead of depending upon (sometimes non-trivial)
    checks against this sprinkled all over the the place, in
    each and every implementation.
    
    Based upon work done by Arjan van de Ven and feedback
    from Linus Torvalds.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 78c9736c3579..b2c1b37ab2e4 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -2862,7 +2862,7 @@ static int ia_getsockopt(struct atm_vcc *vcc, int level, int optname,
 }  
   
 static int ia_setsockopt(struct atm_vcc *vcc, int level, int optname,   
-	void __user *optval, int optlen)  
+	void __user *optval, unsigned int optlen)  
 {  
 	IF_EVENT(printk(">ia_setsockopt\n");)  
 	return -EINVAL;  

commit 32f3dde55ba1b28863c0f0611d2c9dcf2d728ec8
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Fri Mar 20 06:44:02 2009 +0000

    atm: fix non-const printk argument
    
    Change printk() argument to fix compiler warning.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index e1c7611e9144..78c9736c3579 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -977,9 +977,7 @@ static void xdump( u_char*  cp, int  length, char*  prefix )
             else
                 pBuf += sprintf( pBuf, "." );
                 }
-        sprintf( pBuf, "\n" );
-        // SPrint(prntBuf);
-        printk(prntBuf);
+        printk("%s\n", prntBuf);
         count += col;
         pBuf = prntBuf;
     }

commit b67445fc17489fff5c8052147184e366abdb3d80
Author: Wu Fengguang <fengguang.wu@intel.com>
Date:   Wed Jan 7 18:09:10 2009 -0800

    generic swap(): iphase: rename swap() to swap_byte_order()
    
    In preparation for the introduction of a generic swap() macro.
    
    Signed-off-by: Wu Fengguang <fengguang.wu@intel.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 088885ed51b9..e1c7611e9144 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -64,7 +64,7 @@
 #include <linux/jiffies.h>
 #include "iphase.h"		  
 #include "suni.h"		  
-#define swap(x) (((x & 0xff) << 8) | ((x & 0xff00) >> 8))  
+#define swap_byte_order(x) (((x & 0xff) << 8) | ((x & 0xff00) >> 8))
 
 #define PRIV(dev) ((struct suni_priv *) dev->phy_data)
 
@@ -1306,7 +1306,7 @@ static void rx_dle_intr(struct atm_dev *dev)
           // get real pkt length  pwang_test
           trailer = (struct cpcs_trailer*)((u_char *)skb->data +
                                  skb->len - sizeof(*trailer));
-          length =  swap(trailer->length);
+	  length = swap_byte_order(trailer->length);
           if ((length > iadev->rx_buf_sz) || (length > 
                               (skb->len - sizeof(struct cpcs_trailer))))
           {
@@ -2995,7 +2995,7 @@ static int ia_pkt_tx (struct atm_vcc *vcc, struct sk_buff *skb) {
 		skb->len, PCI_DMA_TODEVICE);
 	wr_ptr->local_pkt_addr = (buf_desc_ptr->buf_start_hi << 16) | 
                                                   buf_desc_ptr->buf_start_lo;  
-	/* wr_ptr->bytes = swap(total_len);	didn't seem to affect ?? */  
+	/* wr_ptr->bytes = swap_byte_order(total_len); didn't seem to affect?? */
 	wr_ptr->bytes = skb->len;  
 
         /* hw bug - DLEs of 0x2d, 0x2e, 0x2f cause DMA lockup */

commit 849e8caa477d72cf153e5c0b6ce0c00b89738abb
Author: David Howells <dhowells@redhat.com>
Date:   Wed Jul 30 16:33:05 2008 -0700

    atm: fix direct casts of pointers to u32 in the InterPhase driver
    
    Fix direct casts of pointers to u32 in the InterPhase ATM driver.  These are
    all arguments being passed to printk() calls.  So drop the cast and change the
    %x to a %p.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 24df73ad326d..088885ed51b9 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -156,8 +156,8 @@ static void ia_hack_tcq(IADEV *dev) {
         }
         iavcc_r->vc_desc_cnt--;
         dev->desc_tbl[desc1 -1].timestamp = 0;
-        IF_EVENT(printk("ia_hack: return_q skb = 0x%x desc = %d\n", 
-                                   (u32)dev->desc_tbl[desc1 -1].txskb, desc1);)
+        IF_EVENT(printk("ia_hack: return_q skb = 0x%p desc = %d\n",
+                                   dev->desc_tbl[desc1 -1].txskb, desc1);)
         if (iavcc_r->pcr < dev->rate_limit) {
            IA_SKB_STATE (dev->desc_tbl[desc1-1].txskb) |= IA_TX_DONE;
            if (ia_enque_rtn_q(&dev->tx_return_q, dev->desc_tbl[desc1 -1]) < 0)
@@ -527,8 +527,8 @@ static int ia_cbr_setup (IADEV *dev, struct atm_vcc *vcc) {
       inc = 0;
       testSlot = idealSlot;
       TstSchedTbl = (u16*)(SchedTbl+testSlot);  //set index and read in value
-      IF_CBR(printk("CBR Testslot 0x%x AT Location 0x%x, NumToAssign=%d\n",
-                                testSlot, (u32)TstSchedTbl,toBeAssigned);) 
+      IF_CBR(printk("CBR Testslot 0x%x AT Location 0x%p, NumToAssign=%d\n",
+                                testSlot, TstSchedTbl,toBeAssigned);)
       memcpy((caddr_t)&cbrVC,(caddr_t)TstSchedTbl,sizeof(cbrVC));
       while (cbrVC)  // If another VC at this location, we have to keep looking
       {
@@ -536,8 +536,8 @@ static int ia_cbr_setup (IADEV *dev, struct atm_vcc *vcc) {
           testSlot = idealSlot - inc;
           if (testSlot < 0) { // Wrap if necessary
              testSlot += dev->CbrTotEntries;
-             IF_CBR(printk("Testslot Wrap. STable Start=0x%x,Testslot=%d\n",
-                                                       (u32)SchedTbl,testSlot);)
+             IF_CBR(printk("Testslot Wrap. STable Start=0x%p,Testslot=%d\n",
+                                                       SchedTbl,testSlot);)
           }
           TstSchedTbl = (u16 *)(SchedTbl + testSlot);  // set table index
           memcpy((caddr_t)&cbrVC,(caddr_t)TstSchedTbl,sizeof(cbrVC)); 
@@ -552,8 +552,8 @@ static int ia_cbr_setup (IADEV *dev, struct atm_vcc *vcc) {
           } 
           // set table index and read in value
           TstSchedTbl = (u16*)(SchedTbl + testSlot);
-          IF_CBR(printk("Reading CBR Tbl from 0x%x, CbrVal=0x%x Iteration %d\n",
-                          (u32)TstSchedTbl,cbrVC,inc);) 
+          IF_CBR(printk("Reading CBR Tbl from 0x%p, CbrVal=0x%x Iteration %d\n",
+                          TstSchedTbl,cbrVC,inc);)
           memcpy((caddr_t)&cbrVC,(caddr_t)TstSchedTbl,sizeof(cbrVC));
        } /* while */
        // Move this VCI number into this location of the CBR Sched table.
@@ -1427,11 +1427,11 @@ static int rx_init(struct atm_dev *dev)
 	/* We know this is 32bit bus addressed so the following is safe */
 	writel(iadev->rx_dle_dma & 0xfffff000,
 	       iadev->dma + IPHASE5575_RX_LIST_ADDR);  
-	IF_INIT(printk("Tx Dle list addr: 0x%08x value: 0x%0x\n", 
-                      (u32)(iadev->dma+IPHASE5575_TX_LIST_ADDR), 
+	IF_INIT(printk("Tx Dle list addr: 0x%p value: 0x%0x\n",
+                      iadev->dma+IPHASE5575_TX_LIST_ADDR,
                       *(u32*)(iadev->dma+IPHASE5575_TX_LIST_ADDR));  
-	printk("Rx Dle list addr: 0x%08x value: 0x%0x\n", 
-                      (u32)(iadev->dma+IPHASE5575_RX_LIST_ADDR), 
+	printk("Rx Dle list addr: 0x%p value: 0x%0x\n",
+                      iadev->dma+IPHASE5575_RX_LIST_ADDR,
                       *(u32*)(iadev->dma+IPHASE5575_RX_LIST_ADDR));)  
   
 	writew(0xffff, iadev->reass_reg+REASS_MASK_REG);  
@@ -1470,7 +1470,7 @@ static int rx_init(struct atm_dev *dev)
 		buf_desc_ptr++;		  
 		rx_pkt_start += iadev->rx_buf_sz;  
 	}  
-	IF_INIT(printk("Rx Buffer desc ptr: 0x%0x\n", (u32)(buf_desc_ptr));)  
+	IF_INIT(printk("Rx Buffer desc ptr: 0x%p\n", buf_desc_ptr);)
         i = FREE_BUF_DESC_Q*iadev->memSize; 
 	writew(i >> 16,  iadev->reass_reg+REASS_QUEUE_BASE); 
         writew(i, iadev->reass_reg+FREEQ_ST_ADR);
@@ -1487,7 +1487,7 @@ static int rx_init(struct atm_dev *dev)
 		*freeq_start = (u_short)i;  
 		freeq_start++;  
 	}  
-	IF_INIT(printk("freeq_start: 0x%0x\n", (u32)freeq_start);)  
+	IF_INIT(printk("freeq_start: 0x%p\n", freeq_start);)
         /* Packet Complete Queue */
         i = (PKT_COMP_Q * iadev->memSize) & 0xffff;
         writew(i, iadev->reass_reg+PCQ_ST_ADR);
@@ -1713,7 +1713,7 @@ static void tx_dle_intr(struct atm_dev *dev)
                IA_SKB_STATE(skb) |= IA_DLED;
                skb_queue_tail(&iavcc->txing_skb, skb);
             }
-            IF_EVENT(printk("tx_dle_intr: enque skb = 0x%x \n", (u32)skb);)
+            IF_EVENT(printk("tx_dle_intr: enque skb = 0x%p \n", skb);)
             if (++dle == iadev->tx_dle_q.end)
                  dle = iadev->tx_dle_q.start;
         }
@@ -2044,8 +2044,8 @@ static int tx_init(struct atm_dev *dev)
         writew(tmp16, iadev->seg_reg+CBR_TAB_END+1); // CBR_PTR;
         tmp16 = (CBR_SCHED_TABLE*iadev->memSize + iadev->num_vc*6 - 2) >> 1;
         writew(tmp16, iadev->seg_reg+CBR_TAB_END);
-        IF_INIT(printk("iadev->seg_reg = 0x%x CBR_PTR_BASE = 0x%x\n",
-               (u32)iadev->seg_reg, readw(iadev->seg_reg+CBR_PTR_BASE));)
+        IF_INIT(printk("iadev->seg_reg = 0x%p CBR_PTR_BASE = 0x%x\n",
+               iadev->seg_reg, readw(iadev->seg_reg+CBR_PTR_BASE));)
         IF_INIT(printk("CBR_TAB_BEG = 0x%x, CBR_TAB_END = 0x%x, CBR_PTR = 0x%x\n",
           readw(iadev->seg_reg+CBR_TAB_BEG), readw(iadev->seg_reg+CBR_TAB_END),
           readw(iadev->seg_reg+CBR_TAB_END+1));)
@@ -2963,8 +2963,8 @@ static int ia_pkt_tx (struct atm_vcc *vcc, struct sk_buff *skb) {
  
 	/* Put the packet in a tx buffer */   
 	trailer = iadev->tx_buf[desc-1].cpcs;
-        IF_TX(printk("Sent: skb = 0x%x skb->data: 0x%x len: %d, desc: %d\n",
-                  (u32)skb, (u32)skb->data, skb->len, desc);)
+        IF_TX(printk("Sent: skb = 0x%p skb->data: 0x%p len: %d, desc: %d\n",
+                  skb, skb->data, skb->len, desc);)
 	trailer->control = 0; 
         /*big endian*/ 
 	trailer->length = ((skb->len & 0xff) << 8) | ((skb->len & 0xff00) >> 8);
@@ -3181,7 +3181,7 @@ static int __devinit ia_init_one(struct pci_dev *pdev,
 	}
 	dev->dev_data = iadev;
 	IF_INIT(printk(DEV_LABEL "registered at (itf :%d)\n", dev->number);)
-	IF_INIT(printk("dev_id = 0x%x iadev->LineRate = %d \n", (u32)dev,
+	IF_INIT(printk("dev_id = 0x%p iadev->LineRate = %d \n", dev,
 		iadev->LineRate);)
 
 	pci_set_drvdata(pdev, dev);

commit 97928f7021dc70f268037e9a7ea18a7345762fca
Author: Alan Cox <alan@redhat.com>
Date:   Tue Jun 17 16:21:18 2008 -0700

    atm: [iphase] 64-bit cleanup
    
    This fixes the most obvious 64-bit problems, but it is still very very
    broken in other aspects.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 14e4638759a6..24df73ad326d 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -89,10 +89,6 @@ module_param(IADebugFlag, uint, 0644);
 
 MODULE_LICENSE("GPL");
 
-#if BITS_PER_LONG != 32
-#  error FIXME: this driver only works on 32-bit platforms
-#endif
-
 /**************************** IA_LIB **********************************/
 
 static void ia_init_rtn_q (IARTN_Q *que) 
@@ -1406,7 +1402,6 @@ static int rx_init(struct atm_dev *dev)
 	struct abr_vc_table  *abr_vc_table; 
 	u16 *vc_table;  
 	u16 *reass_table;  
-        u16 *ptr16;
 	int i,j, vcsize_sel;  
 	u_short freeq_st_adr;  
 	u_short *freeq_start;  
@@ -1421,14 +1416,15 @@ static int rx_init(struct atm_dev *dev)
 		printk(KERN_ERR DEV_LABEL "can't allocate DLEs\n");
 		goto err_out;
 	}
-	iadev->rx_dle_q.start = (struct dle*)dle_addr;  
+	iadev->rx_dle_q.start = (struct dle *)dle_addr;
 	iadev->rx_dle_q.read = iadev->rx_dle_q.start;  
 	iadev->rx_dle_q.write = iadev->rx_dle_q.start;  
-	iadev->rx_dle_q.end = (struct dle*)((u32)dle_addr+sizeof(struct dle)*DLE_ENTRIES);  
+	iadev->rx_dle_q.end = (struct dle*)((unsigned long)dle_addr+sizeof(struct dle)*DLE_ENTRIES);
 	/* the end of the dle q points to the entry after the last  
 	DLE that can be used. */  
   
 	/* write the upper 20 bits of the start address to rx list address register */  
+	/* We know this is 32bit bus addressed so the following is safe */
 	writel(iadev->rx_dle_dma & 0xfffff000,
 	       iadev->dma + IPHASE5575_RX_LIST_ADDR);  
 	IF_INIT(printk("Tx Dle list addr: 0x%08x value: 0x%0x\n", 
@@ -1582,11 +1578,12 @@ static int rx_init(struct atm_dev *dev)
 	   Set Packet Aging Interval count register to overflow in about 4 us
  	*/  
         writew(0xF6F8, iadev->reass_reg+PKT_TM_CNT );
-        ptr16 = (u16*)j;
-        i = ((u32)ptr16 >> 6) & 0xff;
-	ptr16  += j - 1;
-	i |=(((u32)ptr16 << 2) & 0xff00);
+
+        i = (j >> 6) & 0xFF;
+        j += 2 * (j - 1);
+        i |= ((j << 2) & 0xFF00);
         writew(i, iadev->reass_reg+TMOUT_RANGE);
+
         /* initiate the desc_tble */
         for(i=0; i<iadev->num_tx_desc;i++)
             iadev->desc_tbl[i].timestamp = 0;
@@ -1909,7 +1906,7 @@ static int tx_init(struct atm_dev *dev)
 	iadev->tx_dle_q.start = (struct dle*)dle_addr;  
 	iadev->tx_dle_q.read = iadev->tx_dle_q.start;  
 	iadev->tx_dle_q.write = iadev->tx_dle_q.start;  
-	iadev->tx_dle_q.end = (struct dle*)((u32)dle_addr+sizeof(struct dle)*DLE_ENTRIES);  
+	iadev->tx_dle_q.end = (struct dle*)((unsigned long)dle_addr+sizeof(struct dle)*DLE_ENTRIES);
 
 	/* write the upper 20 bits of the start address to tx list address register */  
 	writel(iadev->tx_dle_dma & 0xfffff000,
@@ -2902,7 +2899,7 @@ static int ia_pkt_tx (struct atm_vcc *vcc, struct sk_buff *skb) {
                  dev_kfree_skb_any(skb);
           return 0;
         }
-        if ((u32)skb->data & 3) {
+        if ((unsigned long)skb->data & 3) {
            printk("Misaligned SKB\n");
            if (vcc->pop)
                  vcc->pop(vcc, skb);

commit 2be63b878f2a1e6d939b05f4f5cb733cb39bcd22
Author: Jorge Boncompte [DTI2] <jorge@dti2.net>
Date:   Tue Jun 17 16:18:49 2008 -0700

    atm: [iphase] move struct suni_priv to suni.h
    
    Signed-off-by: Jorge Boncompte [DTI2] <jorge@dti2.net>
    Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 139fce6968a6..14e4638759a6 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -65,12 +65,7 @@
 #include "iphase.h"		  
 #include "suni.h"		  
 #define swap(x) (((x & 0xff) << 8) | ((x & 0xff00) >> 8))  
-struct suni_priv {
-        struct k_sonet_stats sonet_stats; /* link diagnostics */
-        unsigned char loop_mode;        /* loopback mode */
-        struct atm_dev *dev;            /* device back-pointer */
-        struct suni_priv *next;         /* next SUNI */
-}; 
+
 #define PRIV(dev) ((struct suni_priv *) dev->phy_data)
 
 static unsigned char ia_phy_get(struct atm_dev *dev, unsigned long addr);

commit d6c1d704ab5d2e13bebb096e415156a9c54a3d32
Author: Jorge Boncompte [DTI2] <jorge@dti2.net>
Date:   Mon Jun 16 17:16:35 2008 -0700

    atm: [iphase] doesn't call phy->start due to a bogus #ifndef
    
    This causes the suni driver to oops if you try to use sonetdiag to get
    the statistics. Also add the corresponding phy->stop call to fix another
    oops if you try to remove the module.
    
    Signed-off-by: Jorge Boncompte [DTI2] <jorge@dti2.net>
    Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 800c09e128ee..139fce6968a6 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -2562,17 +2562,11 @@ static int __devinit ia_start(struct atm_dev *dev)
 		error = suni_init(dev);
 		if (error)
 			goto err_free_rx;
-		/* 
-		 * Enable interrupt on loss of signal
-		 * SUNI_RSOP_CIE - 0x10
-		 * SUNI_RSOP_CIE_LOSE - 0x04
-		 */
-		ia_phy_put(dev, ia_phy_get(dev, 0x10) | 0x04, 0x10);
-#ifndef MODULE
-		error = dev->phy->start(dev);
-		if (error)
-			goto err_free_rx;
-#endif
+		if (dev->phy->start) {
+			error = dev->phy->start(dev);
+			if (error)
+				goto err_free_rx;
+		}
 		/* Get iadev->carrier_detect status */
 		IaFrontEndIntr(iadev);
 	}
@@ -3238,9 +3232,14 @@ static void __devexit ia_remove_one(struct pci_dev *pdev)
 	struct atm_dev *dev = pci_get_drvdata(pdev);
 	IADEV *iadev = INPH_IA_DEV(dev);
 
-	ia_phy_put(dev, ia_phy_get(dev,0x10) & ~(0x4), 0x10); 
+	/* Disable phy interrupts */
+	ia_phy_put(dev, ia_phy_get(dev, SUNI_RSOP_CIE) & ~(SUNI_RSOP_CIE_LOSE),
+				   SUNI_RSOP_CIE);
 	udelay(1);
 
+	if (dev->phy && dev->phy->stop)
+		dev->phy->stop(dev);
+
 	/* De-register device */  
       	free_irq(iadev->irq, dev);
 	iadev_count--;

commit c0ed0b60f2c36acfebb53384a3b24d13b3a09309
Author: Jorge Boncompte [DTI2] <jorge@dti2.net>
Date:   Mon Jun 16 17:16:04 2008 -0700

    atm: [iphase] set drvdata before enabling interrupts
    
    Signed-off-by: Jorge Boncompte [DTI2] <jorge@dti2.net>
    Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 5c28ca7380ff..800c09e128ee 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -3198,6 +3198,8 @@ static int __devinit ia_init_one(struct pci_dev *pdev,
 	IF_INIT(printk("dev_id = 0x%x iadev->LineRate = %d \n", (u32)dev,
 		iadev->LineRate);)
 
+	pci_set_drvdata(pdev, dev);
+
 	ia_dev[iadev_count] = iadev;
 	_ia_dev[iadev_count] = dev;
 	iadev_count++;
@@ -3219,8 +3221,6 @@ static int __devinit ia_init_one(struct pci_dev *pdev,
 	iadev->next_board = ia_boards;  
 	ia_boards = dev;  
 
-	pci_set_drvdata(pdev, dev);
-
 	return 0;
 
 err_out_deregister_dev:

commit 420635f517cf1bb8929caf80ce5a30e827b9df42
Author: Julia Lawall <julia@diku.dk>
Date:   Sat Apr 19 18:14:50 2008 -0700

    drivers/atm: use time_before, time_before_eq, etc
    
    The functions time_before, time_before_eq, time_after, and time_after_eq
    are more robust for comparing jiffies against other values.
    
    A simplified version of the semantic patch making this change is as follows:
    (http://www.emn.fr/x-info/coccinelle/)
    
    // <smpl>
    @ change_compare_np @
    expression E;
    @@
    
    (
    - jiffies <= E
    + time_before_eq(jiffies,E)
    |
    - jiffies >= E
    + time_after_eq(jiffies,E)
    |
    - jiffies < E
    + time_before(jiffies,E)
    |
    - jiffies > E
    + time_after(jiffies,E)
    )
    
    @ include depends on change_compare_np @
    @@
    
    #include <linux/jiffies.h>
    
    @ no_include depends on !include && change_compare_np @
    @@
    
      #include <linux/...>
    + #include <linux/jiffies.h>
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 670c093ed25f..5c28ca7380ff 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -60,7 +60,8 @@
 #include <asm/uaccess.h>  
 #include <asm/string.h>  
 #include <asm/byteorder.h>  
-#include <linux/vmalloc.h>  
+#include <linux/vmalloc.h>
+#include <linux/jiffies.h>
 #include "iphase.h"		  
 #include "suni.h"		  
 #define swap(x) (((x & 0xff) << 8) | ((x & 0xff00) >> 8))  
@@ -189,7 +190,7 @@ static u16 get_desc (IADEV *dev, struct ia_vcc *iavcc) {
   int ltimeout;
 
   ia_hack_tcq (dev);
-  if(((jiffies - timer)>50)||((dev->ffL.tcq_rd==dev->host_tcq_wr))){      
+  if((time_after(jiffies,timer+50)) || ((dev->ffL.tcq_rd==dev->host_tcq_wr))) {
      timer = jiffies; 
      i=0;
      while (i < dev->num_tx_desc) {
@@ -1225,7 +1226,7 @@ static void rx_intr(struct atm_dev *dev)
         iadev->rx_tmp_jif = jiffies; 
         iadev->rxing = 0;
      } 
-     else if (((jiffies - iadev->rx_tmp_jif) > 50) && 
+     else if ((time_after(jiffies, iadev->rx_tmp_jif + 50)) &&
                ((iadev->rx_pkt_cnt - iadev->rx_tmp_cnt) == 0)) {
         for (i = 1; i <= iadev->num_rx_desc; i++)
                free_desc(dev, i);

commit a22eb6faae4ec64d59cc206671eb0bfe46c5ffd2
Author: Leonardo Potenza <lpotenza@inwind.it>
Date:   Wed Apr 2 00:03:00 2008 -0700

    [ATM] drivers/atm/iphase.c: compilation warning fix
    
    Removed the warning messages:
    drivers/atm/iphase.c:961: warning: 'tcnter' defined but not used
    drivers/atm/iphase.c:963: warning: 'xdump' defined but not used
    
    tcnter and xdump() are used only in debug build
    
    Signed-off-by: Leonardo Potenza <lpotenza@inwind.it>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index ef52452640e0..670c093ed25f 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -958,6 +958,7 @@ static void ia_suni_pm7345_init (IADEV *iadev)
 
 /***************************** IA_LIB END *****************************/
     
+#ifdef CONFIG_ATM_IA_DEBUG
 static int tcnter = 0;
 static void xdump( u_char*  cp, int  length, char*  prefix )
 {
@@ -992,6 +993,7 @@ static void xdump( u_char*  cp, int  length, char*  prefix )
     }
 
 }  /* close xdump(... */
+#endif /* CONFIG_ATM_IA_DEBUG */
 
   
 static struct atm_dev *ia_boards = NULL;  

commit f71417614d63932cf56ed98a0947568d6259d11e
Author: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date:   Fri Aug 10 15:26:18 2007 -0700

    [ATM] drivers/atm/iphase.c: mostly kmalloc + memset conversion to kzalloc
    
     drivers/atm/iphase.c | 111508 -> 111431 (-77 bytes)
     drivers/atm/iphase.o | 254740 -> 254260 (-480 bytes)
    
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index a3b605a0ca17..ef52452640e0 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -1601,14 +1601,14 @@ static int rx_init(struct atm_dev *dev)
   
 	skb_queue_head_init(&iadev->rx_dma_q);  
 	iadev->rx_free_desc_qhead = NULL;   
-	iadev->rx_open = kmalloc(4*iadev->num_vc,GFP_KERNEL);
-	if (!iadev->rx_open)  
-	{  
+
+	iadev->rx_open = kzalloc(4 * iadev->num_vc, GFP_KERNEL);
+	if (!iadev->rx_open) {
 		printk(KERN_ERR DEV_LABEL "itf %d couldn't get free page\n",
 		dev->number);  
 		goto err_free_dle;
 	}  
-	memset(iadev->rx_open, 0, 4*iadev->num_vc);  
+
         iadev->rxing = 1;
         iadev->rx_pkt_cnt = 0;
 	/* Mode Register */  
@@ -3171,12 +3171,12 @@ static int __devinit ia_init_one(struct pci_dev *pdev,
         unsigned long flags;
 	int ret;
 
-	iadev = kmalloc(sizeof(*iadev), GFP_KERNEL); 
+	iadev = kzalloc(sizeof(*iadev), GFP_KERNEL);
 	if (!iadev) {
 		ret = -ENOMEM;
 		goto err_out;
 	}
-	memset(iadev, 0, sizeof(*iadev));
+
 	iadev->pci = pdev;
 
 	IF_INIT(printk("ia detected at bus:%d dev: %d function:%d\n",

commit 44c10138fd4bbc4b6d6bff0873c24902f2a9da65
Author: Auke Kok <auke-jan.h.kok@intel.com>
Date:   Fri Jun 8 15:46:36 2007 -0700

    PCI: Change all drivers to use pci_device->revision
    
    Instead of all drivers reading pci config space to get the revision
    ID, they can now use the pci_device->revision member.
    
    This exposes some issues where drivers where reading a word or a dword
    for the revision number, and adding useless error-handling around the
    read. Some drivers even just read it for no purpose of all.
    
    In devices where the revision ID is being copied over and used in what
    appears to be the equivalent of hotpath, I have left the copy code
    and the cached copy as not to influence the driver's performance.
    
    Compile tested with make all{yes,mod}config on x86_64 and i386.
    
    Signed-off-by: Auke Kok <auke-jan.h.kok@intel.com>
    Acked-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index bb7ef570514c..a3b605a0ca17 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -2290,7 +2290,6 @@ static int __devinit ia_init(struct atm_dev *dev)
 	unsigned long real_base;
 	void __iomem *base;
 	unsigned short command;  
-	unsigned char revision;  
 	int error, i; 
 	  
 	/* The device has been identified and registered. Now we read   
@@ -2305,16 +2304,14 @@ static int __devinit ia_init(struct atm_dev *dev)
 	real_base = pci_resource_start (iadev->pci, 0);
 	iadev->irq = iadev->pci->irq;
 		  
-	if ((error = pci_read_config_word(iadev->pci, PCI_COMMAND,&command))   
-		    || (error = pci_read_config_byte(iadev->pci,   
-				PCI_REVISION_ID,&revision)))   
-	{  
+	error = pci_read_config_word(iadev->pci, PCI_COMMAND, &command);
+	if (error) {
 		printk(KERN_ERR DEV_LABEL "(itf %d): init error 0x%x\n",  
 				dev->number,error);  
 		return -EINVAL;  
 	}  
 	IF_INIT(printk(DEV_LABEL "(itf %d): rev.%d,realbase=0x%lx,irq=%d\n",  
-			dev->number, revision, real_base, iadev->irq);)  
+			dev->number, iadev->pci->revision, real_base, iadev->irq);)
 	  
 	/* find mapping size of board */  
 	  
@@ -2353,7 +2350,7 @@ static int __devinit ia_init(struct atm_dev *dev)
 		return error;  
 	}  
 	IF_INIT(printk(DEV_LABEL " (itf %d): rev.%d,base=%p,irq=%d\n",  
-			dev->number, revision, base, iadev->irq);)  
+			dev->number, iadev->pci->revision, base, iadev->irq);)
 	  
 	/* filling the iphase dev structure */  
 	iadev->mem = iadev->pci_map_size /2;  

commit 0779bf2d2ecc4d9b1e9437ae659f50e6776a7666
Author: Matt LaPlante <kernel1@cyberdogtech.com>
Date:   Thu Nov 30 05:24:39 2006 +0100

    Fix misc .c/.h comment typos
    
    Fix various .c/.h typos in comments (no code changes).
    
    Signed-off-by: Matt LaPlante <kernel1@cyberdogtech.com>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 9ed1c60048f0..bb7ef570514c 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -305,7 +305,7 @@ static void clear_lockup (struct atm_vcc *vcc, IADEV *dev) {
 **  |  R | NZ |  5-bit exponent  |        9-bit mantissa         |
 **  +----+----+------------------+-------------------------------+
 ** 
-**    R = reserverd (written as 0)
+**    R = reserved (written as 0)
 **    NZ = 0 if 0 cells/sec; 1 otherwise
 **
 **    if NZ = 1, rate = 1.mmmmmmmmm x 2^(eeeee) cells/sec

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index f20b0b2c06c6..9ed1c60048f0 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -2195,7 +2195,7 @@ static int tx_init(struct atm_dev *dev)
 	return -ENOMEM;
 }   
    
-static irqreturn_t ia_int(int irq, void *dev_id, struct pt_regs *regs)  
+static irqreturn_t ia_int(int irq, void *dev_id)  
 {  
    struct atm_dev *dev;  
    IADEV *iadev;  

commit dace145374b8e39aeb920304c358ab5e220341ab
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:38 2006 -0700

    [PATCH] irq-flags: misc drivers: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 333a7bc609d2..f20b0b2c06c6 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -2488,7 +2488,7 @@ static int __devinit ia_start(struct atm_dev *dev)
 	u32 ctrl_reg;  
 	IF_EVENT(printk(">ia_start\n");)  
 	iadev = INPH_IA_DEV(dev);  
-        if (request_irq(iadev->irq, &ia_int, SA_SHIRQ, DEV_LABEL, dev)) {  
+        if (request_irq(iadev->irq, &ia_int, IRQF_SHARED, DEV_LABEL, dev)) {
                 printk(KERN_ERR DEV_LABEL "(itf %d): IRQ%d is already in use\n",  
                     dev->number, iadev->irq);  
 		error = -EAGAIN;

commit 249c14b55c8576ad8c6ec23c7c1b3b2219b33e54
Author: Chas Williams <chas@cmf.nrl.navy.mil>
Date:   Thu Jun 29 12:35:32 2006 -0700

    [ATM]: [iphase] should be __devinit not __init
    
    Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 2e2e50e1167a..333a7bc609d2 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -2284,7 +2284,7 @@ static int reset_sar(struct atm_dev *dev)
 }  
 	  
 	  
-static int __init ia_init(struct atm_dev *dev)
+static int __devinit ia_init(struct atm_dev *dev)
 {  
 	IADEV *iadev;  
 	unsigned long real_base;
@@ -2480,7 +2480,7 @@ static void ia_free_rx(IADEV *iadev)
 			  iadev->rx_dle_dma);  
 }
 
-static int __init ia_start(struct atm_dev *dev)
+static int __devinit ia_start(struct atm_dev *dev)
 {  
 	IADEV *iadev;  
 	int error;  

commit 8d06afab73a75f40ae2864e6c296356bab1ab473
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Sep 9 13:10:40 2005 -0700

    [PATCH] timer initialization cleanup: DEFINE_TIMER
    
    Clean up timer initialization by introducing DEFINE_TIMER a'la
    DEFINE_SPINLOCK.  Build and boot-tested on x86.  A similar patch has been
    been in the -RT tree for some time.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index a43575acb2c1..2e2e50e1167a 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -79,7 +79,7 @@ static IADEV *ia_dev[8];
 static struct atm_dev *_ia_dev[8];
 static int iadev_count;
 static void ia_led_timer(unsigned long arg);
-static struct timer_list ia_timer = TIMER_INITIALIZER(ia_led_timer, 0, 0);
+static DEFINE_TIMER(ia_timer, ia_led_timer, 0, 0);
 static int IA_TX_BUF = DFL_TX_BUFFERS, IA_TX_BUF_SZ = DFL_TX_BUF_SZ;
 static int IA_RX_BUF = DFL_RX_BUFFERS, IA_RX_BUF_SZ = DFL_RX_BUF_SZ;
 static uint IADebugFlag = /* IF_IADBG_ERR | IF_IADBG_CBR| IF_IADBG_INIT_ADAPTER

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
new file mode 100644
index 000000000000..a43575acb2c1
--- /dev/null
+++ b/drivers/atm/iphase.c
@@ -0,0 +1,3296 @@
+/******************************************************************************
+         iphase.c: Device driver for Interphase ATM PCI adapter cards 
+                    Author: Peter Wang  <pwang@iphase.com>            
+		   Some fixes: Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+                   Interphase Corporation  <www.iphase.com>           
+                               Version: 1.0                           
+*******************************************************************************
+      
+      This software may be used and distributed according to the terms
+      of the GNU General Public License (GPL), incorporated herein by reference.
+      Drivers based on this skeleton fall under the GPL and must retain
+      the authorship (implicit copyright) notice.
+
+      This program is distributed in the hope that it will be useful, but
+      WITHOUT ANY WARRANTY; without even the implied warranty of
+      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+      General Public License for more details.
+      
+      Modified from an incomplete driver for Interphase 5575 1KVC 1M card which 
+      was originally written by Monalisa Agrawal at UNH. Now this driver 
+      supports a variety of varients of Interphase ATM PCI (i)Chip adapter 
+      card family (See www.iphase.com/products/ClassSheet.cfm?ClassID=ATM) 
+      in terms of PHY type, the size of control memory and the size of 
+      packet memory. The followings are the change log and history:
+     
+          Bugfix the Mona's UBR driver.
+          Modify the basic memory allocation and dma logic.
+          Port the driver to the latest kernel from 2.0.46.
+          Complete the ABR logic of the driver, and added the ABR work-
+              around for the hardware anormalies.
+          Add the CBR support.
+	  Add the flow control logic to the driver to allow rate-limit VC.
+          Add 4K VC support to the board with 512K control memory.
+          Add the support of all the variants of the Interphase ATM PCI 
+          (i)Chip adapter cards including x575 (155M OC3 and UTP155), x525
+          (25M UTP25) and x531 (DS3 and E3).
+          Add SMP support.
+
+      Support and updates available at: ftp://ftp.iphase.com/pub/atm
+
+*******************************************************************************/
+
+#include <linux/module.h>  
+#include <linux/kernel.h>  
+#include <linux/mm.h>  
+#include <linux/pci.h>  
+#include <linux/errno.h>  
+#include <linux/atm.h>  
+#include <linux/atmdev.h>  
+#include <linux/sonet.h>  
+#include <linux/skbuff.h>  
+#include <linux/time.h>  
+#include <linux/delay.h>  
+#include <linux/uio.h>  
+#include <linux/init.h>  
+#include <linux/wait.h>
+#include <asm/system.h>  
+#include <asm/io.h>  
+#include <asm/atomic.h>  
+#include <asm/uaccess.h>  
+#include <asm/string.h>  
+#include <asm/byteorder.h>  
+#include <linux/vmalloc.h>  
+#include "iphase.h"		  
+#include "suni.h"		  
+#define swap(x) (((x & 0xff) << 8) | ((x & 0xff00) >> 8))  
+struct suni_priv {
+        struct k_sonet_stats sonet_stats; /* link diagnostics */
+        unsigned char loop_mode;        /* loopback mode */
+        struct atm_dev *dev;            /* device back-pointer */
+        struct suni_priv *next;         /* next SUNI */
+}; 
+#define PRIV(dev) ((struct suni_priv *) dev->phy_data)
+
+static unsigned char ia_phy_get(struct atm_dev *dev, unsigned long addr);
+static void desc_dbg(IADEV *iadev);
+
+static IADEV *ia_dev[8];
+static struct atm_dev *_ia_dev[8];
+static int iadev_count;
+static void ia_led_timer(unsigned long arg);
+static struct timer_list ia_timer = TIMER_INITIALIZER(ia_led_timer, 0, 0);
+static int IA_TX_BUF = DFL_TX_BUFFERS, IA_TX_BUF_SZ = DFL_TX_BUF_SZ;
+static int IA_RX_BUF = DFL_RX_BUFFERS, IA_RX_BUF_SZ = DFL_RX_BUF_SZ;
+static uint IADebugFlag = /* IF_IADBG_ERR | IF_IADBG_CBR| IF_IADBG_INIT_ADAPTER
+            |IF_IADBG_ABR | IF_IADBG_EVENT*/ 0; 
+
+module_param(IA_TX_BUF, int, 0);
+module_param(IA_TX_BUF_SZ, int, 0);
+module_param(IA_RX_BUF, int, 0);
+module_param(IA_RX_BUF_SZ, int, 0);
+module_param(IADebugFlag, uint, 0644);
+
+MODULE_LICENSE("GPL");
+
+#if BITS_PER_LONG != 32
+#  error FIXME: this driver only works on 32-bit platforms
+#endif
+
+/**************************** IA_LIB **********************************/
+
+static void ia_init_rtn_q (IARTN_Q *que) 
+{ 
+   que->next = NULL; 
+   que->tail = NULL; 
+}
+
+static void ia_enque_head_rtn_q (IARTN_Q *que, IARTN_Q * data) 
+{
+   data->next = NULL;
+   if (que->next == NULL) 
+      que->next = que->tail = data;
+   else {
+      data->next = que->next;
+      que->next = data;
+   } 
+   return;
+}
+
+static int ia_enque_rtn_q (IARTN_Q *que, struct desc_tbl_t data) {
+   IARTN_Q *entry = kmalloc(sizeof(*entry), GFP_ATOMIC);
+   if (!entry) return -1;
+   entry->data = data;
+   entry->next = NULL;
+   if (que->next == NULL) 
+      que->next = que->tail = entry;
+   else {
+      que->tail->next = entry;
+      que->tail = que->tail->next;
+   }      
+   return 1;
+}
+
+static IARTN_Q * ia_deque_rtn_q (IARTN_Q *que) {
+   IARTN_Q *tmpdata;
+   if (que->next == NULL)
+      return NULL;
+   tmpdata = que->next;
+   if ( que->next == que->tail)  
+      que->next = que->tail = NULL;
+   else 
+      que->next = que->next->next;
+   return tmpdata;
+}
+
+static void ia_hack_tcq(IADEV *dev) {
+
+  u_short 		desc1;
+  u_short		tcq_wr;
+  struct ia_vcc         *iavcc_r = NULL; 
+
+  tcq_wr = readl(dev->seg_reg+TCQ_WR_PTR) & 0xffff;
+  while (dev->host_tcq_wr != tcq_wr) {
+     desc1 = *(u_short *)(dev->seg_ram + dev->host_tcq_wr);
+     if (!desc1) ;
+     else if (!dev->desc_tbl[desc1 -1].timestamp) {
+        IF_ABR(printk(" Desc %d is reset at %ld\n", desc1 -1, jiffies);)
+        *(u_short *) (dev->seg_ram + dev->host_tcq_wr) = 0;
+     }                                 
+     else if (dev->desc_tbl[desc1 -1].timestamp) {
+        if (!(iavcc_r = dev->desc_tbl[desc1 -1].iavcc)) { 
+           printk("IA: Fatal err in get_desc\n");
+           continue;
+        }
+        iavcc_r->vc_desc_cnt--;
+        dev->desc_tbl[desc1 -1].timestamp = 0;
+        IF_EVENT(printk("ia_hack: return_q skb = 0x%x desc = %d\n", 
+                                   (u32)dev->desc_tbl[desc1 -1].txskb, desc1);)
+        if (iavcc_r->pcr < dev->rate_limit) {
+           IA_SKB_STATE (dev->desc_tbl[desc1-1].txskb) |= IA_TX_DONE;
+           if (ia_enque_rtn_q(&dev->tx_return_q, dev->desc_tbl[desc1 -1]) < 0)
+              printk("ia_hack_tcq: No memory available\n");
+        } 
+        dev->desc_tbl[desc1 -1].iavcc = NULL;
+        dev->desc_tbl[desc1 -1].txskb = NULL;
+     }
+     dev->host_tcq_wr += 2;
+     if (dev->host_tcq_wr > dev->ffL.tcq_ed) 
+        dev->host_tcq_wr = dev->ffL.tcq_st;
+  }
+} /* ia_hack_tcq */
+
+static u16 get_desc (IADEV *dev, struct ia_vcc *iavcc) {
+  u_short 		desc_num, i;
+  struct sk_buff        *skb;
+  struct ia_vcc         *iavcc_r = NULL; 
+  unsigned long delta;
+  static unsigned long timer = 0;
+  int ltimeout;
+
+  ia_hack_tcq (dev);
+  if(((jiffies - timer)>50)||((dev->ffL.tcq_rd==dev->host_tcq_wr))){      
+     timer = jiffies; 
+     i=0;
+     while (i < dev->num_tx_desc) {
+        if (!dev->desc_tbl[i].timestamp) {
+           i++;
+           continue;
+        }
+        ltimeout = dev->desc_tbl[i].iavcc->ltimeout; 
+        delta = jiffies - dev->desc_tbl[i].timestamp;
+        if (delta >= ltimeout) {
+           IF_ABR(printk("RECOVER run!! desc_tbl %d = %d  delta = %ld, time = %ld\n", i,dev->desc_tbl[i].timestamp, delta, jiffies);)
+           if (dev->ffL.tcq_rd == dev->ffL.tcq_st) 
+              dev->ffL.tcq_rd =  dev->ffL.tcq_ed;
+           else 
+              dev->ffL.tcq_rd -= 2;
+           *(u_short *)(dev->seg_ram + dev->ffL.tcq_rd) = i+1;
+           if (!(skb = dev->desc_tbl[i].txskb) || 
+                          !(iavcc_r = dev->desc_tbl[i].iavcc))
+              printk("Fatal err, desc table vcc or skb is NULL\n");
+           else 
+              iavcc_r->vc_desc_cnt--;
+           dev->desc_tbl[i].timestamp = 0;
+           dev->desc_tbl[i].iavcc = NULL;
+           dev->desc_tbl[i].txskb = NULL;
+        }
+        i++;
+     } /* while */
+  }
+  if (dev->ffL.tcq_rd == dev->host_tcq_wr) 
+     return 0xFFFF;
+    
+  /* Get the next available descriptor number from TCQ */
+  desc_num = *(u_short *)(dev->seg_ram + dev->ffL.tcq_rd);
+
+  while (!desc_num || (dev->desc_tbl[desc_num -1]).timestamp) {
+     dev->ffL.tcq_rd += 2;
+     if (dev->ffL.tcq_rd > dev->ffL.tcq_ed) 
+     dev->ffL.tcq_rd = dev->ffL.tcq_st;
+     if (dev->ffL.tcq_rd == dev->host_tcq_wr) 
+        return 0xFFFF; 
+     desc_num = *(u_short *)(dev->seg_ram + dev->ffL.tcq_rd);
+  }
+
+  /* get system time */
+  dev->desc_tbl[desc_num -1].timestamp = jiffies;
+  return desc_num;
+}
+
+static void clear_lockup (struct atm_vcc *vcc, IADEV *dev) {
+  u_char          	foundLockUp;
+  vcstatus_t		*vcstatus;
+  u_short               *shd_tbl;
+  u_short               tempCellSlot, tempFract;
+  struct main_vc *abr_vc = (struct main_vc *)dev->MAIN_VC_TABLE_ADDR;
+  struct ext_vc *eabr_vc = (struct ext_vc *)dev->EXT_VC_TABLE_ADDR;
+  u_int  i;
+
+  if (vcc->qos.txtp.traffic_class == ATM_ABR) {
+     vcstatus = (vcstatus_t *) &(dev->testTable[vcc->vci]->vc_status);
+     vcstatus->cnt++;
+     foundLockUp = 0;
+     if( vcstatus->cnt == 0x05 ) {
+        abr_vc += vcc->vci;
+	eabr_vc += vcc->vci;
+	if( eabr_vc->last_desc ) {
+	   if( (abr_vc->status & 0x07) == ABR_STATE /* 0x2 */ ) {
+              /* Wait for 10 Micro sec */
+              udelay(10);
+	      if ((eabr_vc->last_desc)&&((abr_vc->status & 0x07)==ABR_STATE))
+		 foundLockUp = 1;
+           }
+	   else {
+	      tempCellSlot = abr_vc->last_cell_slot;
+              tempFract    = abr_vc->fraction;
+              if((tempCellSlot == dev->testTable[vcc->vci]->lastTime)
+                         && (tempFract == dev->testTable[vcc->vci]->fract))
+	         foundLockUp = 1; 		    
+              dev->testTable[vcc->vci]->lastTime = tempCellSlot;   
+              dev->testTable[vcc->vci]->fract = tempFract; 
+	   } 	    
+        } /* last descriptor */	 	   
+        vcstatus->cnt = 0;     	
+     } /* vcstatus->cnt */
+	
+     if (foundLockUp) {
+        IF_ABR(printk("LOCK UP found\n");) 
+	writew(0xFFFD, dev->seg_reg+MODE_REG_0);
+        /* Wait for 10 Micro sec */
+        udelay(10); 
+        abr_vc->status &= 0xFFF8;
+        abr_vc->status |= 0x0001;  /* state is idle */
+	shd_tbl = (u_short *)dev->ABR_SCHED_TABLE_ADDR;                
+	for( i = 0; ((i < dev->num_vc) && (shd_tbl[i])); i++ );
+	if (i < dev->num_vc)
+           shd_tbl[i] = vcc->vci;
+        else
+           IF_ERR(printk("ABR Seg. may not continue on VC %x\n",vcc->vci);)
+        writew(T_ONLINE, dev->seg_reg+MODE_REG_0);
+        writew(~(TRANSMIT_DONE|TCQ_NOT_EMPTY), dev->seg_reg+SEG_MASK_REG);
+        writew(TRANSMIT_DONE, dev->seg_reg+SEG_INTR_STATUS_REG);       
+	vcstatus->cnt = 0;
+     } /* foundLockUp */
+
+  } /* if an ABR VC */
+
+
+}
+ 
+/*
+** Conversion of 24-bit cellrate (cells/sec) to 16-bit floating point format.
+**
+**  +----+----+------------------+-------------------------------+
+**  |  R | NZ |  5-bit exponent  |        9-bit mantissa         |
+**  +----+----+------------------+-------------------------------+
+** 
+**    R = reserverd (written as 0)
+**    NZ = 0 if 0 cells/sec; 1 otherwise
+**
+**    if NZ = 1, rate = 1.mmmmmmmmm x 2^(eeeee) cells/sec
+*/
+static u16
+cellrate_to_float(u32 cr)
+{
+
+#define	NZ 		0x4000
+#define	M_BITS		9		/* Number of bits in mantissa */
+#define	E_BITS		5		/* Number of bits in exponent */
+#define	M_MASK		0x1ff		
+#define	E_MASK		0x1f
+  u16   flot;
+  u32	tmp = cr & 0x00ffffff;
+  int 	i   = 0;
+  if (cr == 0)
+     return 0;
+  while (tmp != 1) {
+     tmp >>= 1;
+     i++;
+  }
+  if (i == M_BITS)
+     flot = NZ | (i << M_BITS) | (cr & M_MASK);
+  else if (i < M_BITS)
+     flot = NZ | (i << M_BITS) | ((cr << (M_BITS - i)) & M_MASK);
+  else
+     flot = NZ | (i << M_BITS) | ((cr >> (i - M_BITS)) & M_MASK);
+  return flot;
+}
+
+#if 0
+/*
+** Conversion of 16-bit floating point format to 24-bit cellrate (cells/sec).
+*/
+static u32
+float_to_cellrate(u16 rate)
+{
+  u32   exp, mantissa, cps;
+  if ((rate & NZ) == 0)
+     return 0;
+  exp = (rate >> M_BITS) & E_MASK;
+  mantissa = rate & M_MASK;
+  if (exp == 0)
+     return 1;
+  cps = (1 << M_BITS) | mantissa;
+  if (exp == M_BITS)
+     cps = cps;
+  else if (exp > M_BITS)
+     cps <<= (exp - M_BITS);
+  else
+     cps >>= (M_BITS - exp);
+  return cps;
+}
+#endif 
+
+static void init_abr_vc (IADEV *dev, srv_cls_param_t *srv_p) {
+  srv_p->class_type = ATM_ABR;
+  srv_p->pcr        = dev->LineRate;
+  srv_p->mcr        = 0;
+  srv_p->icr        = 0x055cb7;
+  srv_p->tbe        = 0xffffff;
+  srv_p->frtt       = 0x3a;
+  srv_p->rif        = 0xf;
+  srv_p->rdf        = 0xb;
+  srv_p->nrm        = 0x4;
+  srv_p->trm        = 0x7;
+  srv_p->cdf        = 0x3;
+  srv_p->adtf       = 50;
+}
+
+static int
+ia_open_abr_vc(IADEV *dev, srv_cls_param_t *srv_p, 
+                                                struct atm_vcc *vcc, u8 flag)
+{
+  f_vc_abr_entry  *f_abr_vc;
+  r_vc_abr_entry  *r_abr_vc;
+  u32		icr;
+  u8		trm, nrm, crm;
+  u16		adtf, air, *ptr16;	
+  f_abr_vc =(f_vc_abr_entry *)dev->MAIN_VC_TABLE_ADDR;
+  f_abr_vc += vcc->vci;       
+  switch (flag) {
+     case 1: /* FFRED initialization */
+#if 0  /* sanity check */
+       if (srv_p->pcr == 0)
+          return INVALID_PCR;
+       if (srv_p->pcr > dev->LineRate)
+          srv_p->pcr = dev->LineRate;
+       if ((srv_p->mcr + dev->sum_mcr) > dev->LineRate)
+	  return MCR_UNAVAILABLE;
+       if (srv_p->mcr > srv_p->pcr)
+	  return INVALID_MCR;
+       if (!(srv_p->icr))
+	  srv_p->icr = srv_p->pcr;
+       if ((srv_p->icr < srv_p->mcr) || (srv_p->icr > srv_p->pcr))
+	  return INVALID_ICR;
+       if ((srv_p->tbe < MIN_TBE) || (srv_p->tbe > MAX_TBE))
+	  return INVALID_TBE;
+       if ((srv_p->frtt < MIN_FRTT) || (srv_p->frtt > MAX_FRTT))
+	  return INVALID_FRTT;
+       if (srv_p->nrm > MAX_NRM)
+	  return INVALID_NRM;
+       if (srv_p->trm > MAX_TRM)
+	  return INVALID_TRM;
+       if (srv_p->adtf > MAX_ADTF)
+          return INVALID_ADTF;
+       else if (srv_p->adtf == 0)
+	  srv_p->adtf = 1;
+       if (srv_p->cdf > MAX_CDF)
+	  return INVALID_CDF;
+       if (srv_p->rif > MAX_RIF)
+	  return INVALID_RIF;
+       if (srv_p->rdf > MAX_RDF)
+	  return INVALID_RDF;
+#endif
+       memset ((caddr_t)f_abr_vc, 0, sizeof(*f_abr_vc));
+       f_abr_vc->f_vc_type = ABR;
+       nrm = 2 << srv_p->nrm;     /* (2 ** (srv_p->nrm +1)) */
+			          /* i.e 2**n = 2 << (n-1) */
+       f_abr_vc->f_nrm = nrm << 8 | nrm;
+       trm = 100000/(2 << (16 - srv_p->trm));
+       if ( trm == 0) trm = 1;
+       f_abr_vc->f_nrmexp =(((srv_p->nrm +1) & 0x0f) << 12)|(MRM << 8) | trm;
+       crm = srv_p->tbe / nrm;
+       if (crm == 0) crm = 1;
+       f_abr_vc->f_crm = crm & 0xff;
+       f_abr_vc->f_pcr = cellrate_to_float(srv_p->pcr);
+       icr = min( srv_p->icr, (srv_p->tbe > srv_p->frtt) ?
+				((srv_p->tbe/srv_p->frtt)*1000000) :
+				(1000000/(srv_p->frtt/srv_p->tbe)));
+       f_abr_vc->f_icr = cellrate_to_float(icr);
+       adtf = (10000 * srv_p->adtf)/8192;
+       if (adtf == 0) adtf = 1; 
+       f_abr_vc->f_cdf = ((7 - srv_p->cdf) << 12 | adtf) & 0xfff;
+       f_abr_vc->f_mcr = cellrate_to_float(srv_p->mcr);
+       f_abr_vc->f_acr = f_abr_vc->f_icr;
+       f_abr_vc->f_status = 0x0042;
+       break;
+    case 0: /* RFRED initialization */	
+       ptr16 = (u_short *)(dev->reass_ram + REASS_TABLE*dev->memSize); 
+       *(ptr16 + vcc->vci) = NO_AAL5_PKT | REASS_ABR;
+       r_abr_vc = (r_vc_abr_entry*)(dev->reass_ram+ABR_VC_TABLE*dev->memSize);
+       r_abr_vc += vcc->vci;
+       r_abr_vc->r_status_rdf = (15 - srv_p->rdf) & 0x000f;
+       air = srv_p->pcr << (15 - srv_p->rif);
+       if (air == 0) air = 1;
+       r_abr_vc->r_air = cellrate_to_float(air);
+       dev->testTable[vcc->vci]->vc_status = VC_ACTIVE | VC_ABR;
+       dev->sum_mcr	   += srv_p->mcr;
+       dev->n_abr++;
+       break;
+    default:
+       break;
+  }
+  return	0;
+}
+static int ia_cbr_setup (IADEV *dev, struct atm_vcc *vcc) {
+   u32 rateLow=0, rateHigh, rate;
+   int entries;
+   struct ia_vcc *ia_vcc;
+
+   int   idealSlot =0, testSlot, toBeAssigned, inc;
+   u32   spacing;
+   u16  *SchedTbl, *TstSchedTbl;
+   u16  cbrVC, vcIndex;
+   u32   fracSlot    = 0;
+   u32   sp_mod      = 0;
+   u32   sp_mod2     = 0;
+
+   /* IpAdjustTrafficParams */
+   if (vcc->qos.txtp.max_pcr <= 0) {
+      IF_ERR(printk("PCR for CBR not defined\n");)
+      return -1;
+   }
+   rate = vcc->qos.txtp.max_pcr;
+   entries = rate / dev->Granularity;
+   IF_CBR(printk("CBR: CBR entries=0x%x for rate=0x%x & Gran=0x%x\n",
+                                entries, rate, dev->Granularity);)
+   if (entries < 1)
+      IF_CBR(printk("CBR: Bandwidth smaller than granularity of CBR table\n");) 
+   rateLow  =  entries * dev->Granularity;
+   rateHigh = (entries + 1) * dev->Granularity;
+   if (3*(rate - rateLow) > (rateHigh - rate))
+      entries++;
+   if (entries > dev->CbrRemEntries) {
+      IF_CBR(printk("CBR: Not enough bandwidth to support this PCR.\n");)
+      IF_CBR(printk("Entries = 0x%x, CbrRemEntries = 0x%x.\n",
+                                       entries, dev->CbrRemEntries);)
+      return -EBUSY;
+   }   
+
+   ia_vcc = INPH_IA_VCC(vcc);
+   ia_vcc->NumCbrEntry = entries; 
+   dev->sum_mcr += entries * dev->Granularity; 
+   /* IaFFrednInsertCbrSched */
+   // Starting at an arbitrary location, place the entries into the table
+   // as smoothly as possible
+   cbrVC   = 0;
+   spacing = dev->CbrTotEntries / entries;
+   sp_mod  = dev->CbrTotEntries % entries; // get modulo
+   toBeAssigned = entries;
+   fracSlot = 0;
+   vcIndex  = vcc->vci;
+   IF_CBR(printk("Vci=0x%x,Spacing=0x%x,Sp_mod=0x%x\n",vcIndex,spacing,sp_mod);)
+   while (toBeAssigned)
+   {
+      // If this is the first time, start the table loading for this connection
+      // as close to entryPoint as possible.
+      if (toBeAssigned == entries)
+      {
+         idealSlot = dev->CbrEntryPt;
+         dev->CbrEntryPt += 2;    // Adding 2 helps to prevent clumping
+         if (dev->CbrEntryPt >= dev->CbrTotEntries) 
+            dev->CbrEntryPt -= dev->CbrTotEntries;// Wrap if necessary
+      } else {
+         idealSlot += (u32)(spacing + fracSlot); // Point to the next location
+         // in the table that would be  smoothest
+         fracSlot = ((sp_mod + sp_mod2) / entries);  // get new integer part
+         sp_mod2  = ((sp_mod + sp_mod2) % entries);  // calc new fractional part
+      }
+      if (idealSlot >= (int)dev->CbrTotEntries) 
+         idealSlot -= dev->CbrTotEntries;  
+      // Continuously check around this ideal value until a null
+      // location is encountered.
+      SchedTbl = (u16*)(dev->seg_ram+CBR_SCHED_TABLE*dev->memSize); 
+      inc = 0;
+      testSlot = idealSlot;
+      TstSchedTbl = (u16*)(SchedTbl+testSlot);  //set index and read in value
+      IF_CBR(printk("CBR Testslot 0x%x AT Location 0x%x, NumToAssign=%d\n",
+                                testSlot, (u32)TstSchedTbl,toBeAssigned);) 
+      memcpy((caddr_t)&cbrVC,(caddr_t)TstSchedTbl,sizeof(cbrVC));
+      while (cbrVC)  // If another VC at this location, we have to keep looking
+      {
+          inc++;
+          testSlot = idealSlot - inc;
+          if (testSlot < 0) { // Wrap if necessary
+             testSlot += dev->CbrTotEntries;
+             IF_CBR(printk("Testslot Wrap. STable Start=0x%x,Testslot=%d\n",
+                                                       (u32)SchedTbl,testSlot);)
+          }
+          TstSchedTbl = (u16 *)(SchedTbl + testSlot);  // set table index
+          memcpy((caddr_t)&cbrVC,(caddr_t)TstSchedTbl,sizeof(cbrVC)); 
+          if (!cbrVC)
+             break;
+          testSlot = idealSlot + inc;
+          if (testSlot >= (int)dev->CbrTotEntries) { // Wrap if necessary
+             testSlot -= dev->CbrTotEntries;
+             IF_CBR(printk("TotCbrEntries=%d",dev->CbrTotEntries);)
+             IF_CBR(printk(" Testslot=0x%x ToBeAssgned=%d\n", 
+                                            testSlot, toBeAssigned);)
+          } 
+          // set table index and read in value
+          TstSchedTbl = (u16*)(SchedTbl + testSlot);
+          IF_CBR(printk("Reading CBR Tbl from 0x%x, CbrVal=0x%x Iteration %d\n",
+                          (u32)TstSchedTbl,cbrVC,inc);) 
+          memcpy((caddr_t)&cbrVC,(caddr_t)TstSchedTbl,sizeof(cbrVC));
+       } /* while */
+       // Move this VCI number into this location of the CBR Sched table.
+       memcpy((caddr_t)TstSchedTbl, (caddr_t)&vcIndex,sizeof(TstSchedTbl));
+       dev->CbrRemEntries--;
+       toBeAssigned--;
+   } /* while */ 
+
+   /* IaFFrednCbrEnable */
+   dev->NumEnabledCBR++;
+   if (dev->NumEnabledCBR == 1) {
+       writew((CBR_EN | UBR_EN | ABR_EN | (0x23 << 2)), dev->seg_reg+STPARMS);
+       IF_CBR(printk("CBR is enabled\n");)
+   }
+   return 0;
+}
+static void ia_cbrVc_close (struct atm_vcc *vcc) {
+   IADEV *iadev;
+   u16 *SchedTbl, NullVci = 0;
+   u32 i, NumFound;
+
+   iadev = INPH_IA_DEV(vcc->dev);
+   iadev->NumEnabledCBR--;
+   SchedTbl = (u16*)(iadev->seg_ram+CBR_SCHED_TABLE*iadev->memSize);
+   if (iadev->NumEnabledCBR == 0) {
+      writew((UBR_EN | ABR_EN | (0x23 << 2)), iadev->seg_reg+STPARMS);
+      IF_CBR (printk("CBR support disabled\n");)
+   }
+   NumFound = 0;
+   for (i=0; i < iadev->CbrTotEntries; i++)
+   {
+      if (*SchedTbl == vcc->vci) {
+         iadev->CbrRemEntries++;
+         *SchedTbl = NullVci;
+         IF_CBR(NumFound++;)
+      }
+      SchedTbl++;   
+   } 
+   IF_CBR(printk("Exit ia_cbrVc_close, NumRemoved=%d\n",NumFound);)
+}
+
+static int ia_avail_descs(IADEV *iadev) {
+   int tmp = 0;
+   ia_hack_tcq(iadev);
+   if (iadev->host_tcq_wr >= iadev->ffL.tcq_rd)
+      tmp = (iadev->host_tcq_wr - iadev->ffL.tcq_rd) / 2;
+   else
+      tmp = (iadev->ffL.tcq_ed - iadev->ffL.tcq_rd + 2 + iadev->host_tcq_wr -
+                   iadev->ffL.tcq_st) / 2;
+   return tmp;
+}    
+
+static int ia_pkt_tx (struct atm_vcc *vcc, struct sk_buff *skb);
+
+static int ia_que_tx (IADEV *iadev) { 
+   struct sk_buff *skb;
+   int num_desc;
+   struct atm_vcc *vcc;
+   struct ia_vcc *iavcc;
+   num_desc = ia_avail_descs(iadev);
+
+   while (num_desc && (skb = skb_dequeue(&iadev->tx_backlog))) {
+      if (!(vcc = ATM_SKB(skb)->vcc)) {
+         dev_kfree_skb_any(skb);
+         printk("ia_que_tx: Null vcc\n");
+         break;
+      }
+      if (!test_bit(ATM_VF_READY,&vcc->flags)) {
+         dev_kfree_skb_any(skb);
+         printk("Free the SKB on closed vci %d \n", vcc->vci);
+         break;
+      }
+      iavcc = INPH_IA_VCC(vcc);
+      if (ia_pkt_tx (vcc, skb)) {
+         skb_queue_head(&iadev->tx_backlog, skb);
+      }
+      num_desc--;
+   }
+   return 0;
+}
+
+static void ia_tx_poll (IADEV *iadev) {
+   struct atm_vcc *vcc = NULL;
+   struct sk_buff *skb = NULL, *skb1 = NULL;
+   struct ia_vcc *iavcc;
+   IARTN_Q *  rtne;
+
+   ia_hack_tcq(iadev);
+   while ( (rtne = ia_deque_rtn_q(&iadev->tx_return_q))) {
+       skb = rtne->data.txskb;
+       if (!skb) {
+           printk("ia_tx_poll: skb is null\n");
+           goto out;
+       }
+       vcc = ATM_SKB(skb)->vcc;
+       if (!vcc) {
+           printk("ia_tx_poll: vcc is null\n");
+           dev_kfree_skb_any(skb);
+	   goto out;
+       }
+
+       iavcc = INPH_IA_VCC(vcc);
+       if (!iavcc) {
+           printk("ia_tx_poll: iavcc is null\n");
+           dev_kfree_skb_any(skb);
+	   goto out;
+       }
+
+       skb1 = skb_dequeue(&iavcc->txing_skb);
+       while (skb1 && (skb1 != skb)) {
+          if (!(IA_SKB_STATE(skb1) & IA_TX_DONE)) {
+             printk("IA_tx_intr: Vci %d lost pkt!!!\n", vcc->vci);
+          }
+          IF_ERR(printk("Release the SKB not match\n");)
+          if ((vcc->pop) && (skb1->len != 0))
+          {
+             vcc->pop(vcc, skb1);
+             IF_EVENT(printk("Tansmit Done - skb 0x%lx return\n",
+                                                          (long)skb1);)
+          }
+          else 
+             dev_kfree_skb_any(skb1);
+          skb1 = skb_dequeue(&iavcc->txing_skb);
+       }                                                        
+       if (!skb1) {
+          IF_EVENT(printk("IA: Vci %d - skb not found requed\n",vcc->vci);)
+          ia_enque_head_rtn_q (&iadev->tx_return_q, rtne);
+          break;
+       }
+       if ((vcc->pop) && (skb->len != 0))
+       {
+          vcc->pop(vcc, skb);
+          IF_EVENT(printk("Tx Done - skb 0x%lx return\n",(long)skb);)
+       }
+       else 
+          dev_kfree_skb_any(skb);
+       kfree(rtne);
+    }
+    ia_que_tx(iadev);
+out:
+    return;
+}
+#if 0
+static void ia_eeprom_put (IADEV *iadev, u32 addr, u_short val)
+{
+        u32	t;
+	int	i;
+	/*
+	 * Issue a command to enable writes to the NOVRAM
+	 */
+	NVRAM_CMD (EXTEND + EWEN);
+	NVRAM_CLR_CE;
+	/*
+	 * issue the write command
+	 */
+	NVRAM_CMD(IAWRITE + addr);
+	/* 
+	 * Send the data, starting with D15, then D14, and so on for 16 bits
+	 */
+	for (i=15; i>=0; i--) {
+		NVRAM_CLKOUT (val & 0x8000);
+		val <<= 1;
+	}
+	NVRAM_CLR_CE;
+	CFG_OR(NVCE);
+	t = readl(iadev->reg+IPHASE5575_EEPROM_ACCESS); 
+	while (!(t & NVDO))
+		t = readl(iadev->reg+IPHASE5575_EEPROM_ACCESS); 
+
+	NVRAM_CLR_CE;
+	/*
+	 * disable writes again
+	 */
+	NVRAM_CMD(EXTEND + EWDS)
+	NVRAM_CLR_CE;
+	CFG_AND(~NVDI);
+}
+#endif
+
+static u16 ia_eeprom_get (IADEV *iadev, u32 addr)
+{
+	u_short	val;
+        u32	t;
+	int	i;
+	/*
+	 * Read the first bit that was clocked with the falling edge of the
+	 * the last command data clock
+	 */
+	NVRAM_CMD(IAREAD + addr);
+	/*
+	 * Now read the rest of the bits, the next bit read is D14, then D13,
+	 * and so on.
+	 */
+	val = 0;
+	for (i=15; i>=0; i--) {
+		NVRAM_CLKIN(t);
+		val |= (t << i);
+	}
+	NVRAM_CLR_CE;
+	CFG_AND(~NVDI);
+	return val;
+}
+
+static void ia_hw_type(IADEV *iadev) {
+   u_short memType = ia_eeprom_get(iadev, 25);   
+   iadev->memType = memType;
+   if ((memType & MEM_SIZE_MASK) == MEM_SIZE_1M) {
+      iadev->num_tx_desc = IA_TX_BUF;
+      iadev->tx_buf_sz = IA_TX_BUF_SZ;
+      iadev->num_rx_desc = IA_RX_BUF;
+      iadev->rx_buf_sz = IA_RX_BUF_SZ; 
+   } else if ((memType & MEM_SIZE_MASK) == MEM_SIZE_512K) {
+      if (IA_TX_BUF == DFL_TX_BUFFERS)
+        iadev->num_tx_desc = IA_TX_BUF / 2;
+      else 
+        iadev->num_tx_desc = IA_TX_BUF;
+      iadev->tx_buf_sz = IA_TX_BUF_SZ;
+      if (IA_RX_BUF == DFL_RX_BUFFERS)
+        iadev->num_rx_desc = IA_RX_BUF / 2;
+      else
+        iadev->num_rx_desc = IA_RX_BUF;
+      iadev->rx_buf_sz = IA_RX_BUF_SZ;
+   }
+   else {
+      if (IA_TX_BUF == DFL_TX_BUFFERS) 
+        iadev->num_tx_desc = IA_TX_BUF / 8;
+      else
+        iadev->num_tx_desc = IA_TX_BUF;
+      iadev->tx_buf_sz = IA_TX_BUF_SZ;
+      if (IA_RX_BUF == DFL_RX_BUFFERS)
+        iadev->num_rx_desc = IA_RX_BUF / 8;
+      else
+        iadev->num_rx_desc = IA_RX_BUF;
+      iadev->rx_buf_sz = IA_RX_BUF_SZ; 
+   } 
+   iadev->rx_pkt_ram = TX_PACKET_RAM + (iadev->num_tx_desc * iadev->tx_buf_sz); 
+   IF_INIT(printk("BUF: tx=%d,sz=%d rx=%d sz= %d rx_pkt_ram=%d\n",
+         iadev->num_tx_desc, iadev->tx_buf_sz, iadev->num_rx_desc,
+         iadev->rx_buf_sz, iadev->rx_pkt_ram);)
+
+#if 0
+   if ((memType & FE_MASK) == FE_SINGLE_MODE) {
+      iadev->phy_type = PHY_OC3C_S;
+   else if ((memType & FE_MASK) == FE_UTP_OPTION)
+      iadev->phy_type = PHY_UTP155;
+   else
+     iadev->phy_type = PHY_OC3C_M;
+#endif
+   
+   iadev->phy_type = memType & FE_MASK;
+   IF_INIT(printk("memType = 0x%x iadev->phy_type = 0x%x\n", 
+                                         memType,iadev->phy_type);)
+   if (iadev->phy_type == FE_25MBIT_PHY) 
+      iadev->LineRate = (u32)(((25600000/8)*26)/(27*53));
+   else if (iadev->phy_type == FE_DS3_PHY)
+      iadev->LineRate = (u32)(((44736000/8)*26)/(27*53));
+   else if (iadev->phy_type == FE_E3_PHY) 
+      iadev->LineRate = (u32)(((34368000/8)*26)/(27*53));
+   else
+       iadev->LineRate = (u32)(ATM_OC3_PCR);
+   IF_INIT(printk("iadev->LineRate = %d \n", iadev->LineRate);)
+
+}
+
+static void IaFrontEndIntr(IADEV *iadev) {
+  volatile IA_SUNI *suni;
+  volatile ia_mb25_t *mb25;
+  volatile suni_pm7345_t *suni_pm7345;
+  u32 intr_status;
+  u_int frmr_intr;
+
+  if(iadev->phy_type & FE_25MBIT_PHY) {
+     mb25 = (ia_mb25_t*)iadev->phy;
+     iadev->carrier_detect =  Boolean(mb25->mb25_intr_status & MB25_IS_GSB);
+  } else if (iadev->phy_type & FE_DS3_PHY) {
+     suni_pm7345 = (suni_pm7345_t *)iadev->phy;
+     /* clear FRMR interrupts */
+     frmr_intr   = suni_pm7345->suni_ds3_frm_intr_stat; 
+     iadev->carrier_detect =  
+           Boolean(!(suni_pm7345->suni_ds3_frm_stat & SUNI_DS3_LOSV));
+  } else if (iadev->phy_type & FE_E3_PHY ) {
+     suni_pm7345 = (suni_pm7345_t *)iadev->phy;
+     frmr_intr   = suni_pm7345->suni_e3_frm_maint_intr_ind;
+     iadev->carrier_detect =
+           Boolean(!(suni_pm7345->suni_e3_frm_fram_intr_ind_stat&SUNI_E3_LOS));
+  }
+  else { 
+     suni = (IA_SUNI *)iadev->phy;
+     intr_status = suni->suni_rsop_status & 0xff;
+     iadev->carrier_detect = Boolean(!(suni->suni_rsop_status & SUNI_LOSV));
+  }
+  if (iadev->carrier_detect)
+    printk("IA: SUNI carrier detected\n");
+  else
+    printk("IA: SUNI carrier lost signal\n"); 
+  return;
+}
+
+static void ia_mb25_init (IADEV *iadev)
+{
+   volatile ia_mb25_t  *mb25 = (ia_mb25_t*)iadev->phy;
+#if 0
+   mb25->mb25_master_ctrl = MB25_MC_DRIC | MB25_MC_DREC | MB25_MC_ENABLED;
+#endif
+   mb25->mb25_master_ctrl = MB25_MC_DRIC | MB25_MC_DREC;
+   mb25->mb25_diag_control = 0;
+   /*
+    * Initialize carrier detect state
+    */
+   iadev->carrier_detect =  Boolean(mb25->mb25_intr_status & MB25_IS_GSB);
+   return;
+}                   
+
+static void ia_suni_pm7345_init (IADEV *iadev)
+{
+   volatile suni_pm7345_t *suni_pm7345 = (suni_pm7345_t *)iadev->phy;
+   if (iadev->phy_type & FE_DS3_PHY)
+   {
+      iadev->carrier_detect = 
+          Boolean(!(suni_pm7345->suni_ds3_frm_stat & SUNI_DS3_LOSV)); 
+      suni_pm7345->suni_ds3_frm_intr_enbl = 0x17;
+      suni_pm7345->suni_ds3_frm_cfg = 1;
+      suni_pm7345->suni_ds3_tran_cfg = 1;
+      suni_pm7345->suni_config = 0;
+      suni_pm7345->suni_splr_cfg = 0;
+      suni_pm7345->suni_splt_cfg = 0;
+   }
+   else 
+   {
+      iadev->carrier_detect = 
+          Boolean(!(suni_pm7345->suni_e3_frm_fram_intr_ind_stat & SUNI_E3_LOS));
+      suni_pm7345->suni_e3_frm_fram_options = 0x4;
+      suni_pm7345->suni_e3_frm_maint_options = 0x20;
+      suni_pm7345->suni_e3_frm_fram_intr_enbl = 0x1d;
+      suni_pm7345->suni_e3_frm_maint_intr_enbl = 0x30;
+      suni_pm7345->suni_e3_tran_stat_diag_options = 0x0;
+      suni_pm7345->suni_e3_tran_fram_options = 0x1;
+      suni_pm7345->suni_config = SUNI_PM7345_E3ENBL;
+      suni_pm7345->suni_splr_cfg = 0x41;
+      suni_pm7345->suni_splt_cfg = 0x41;
+   } 
+   /*
+    * Enable RSOP loss of signal interrupt.
+    */
+   suni_pm7345->suni_intr_enbl = 0x28;
+ 
+   /*
+    * Clear error counters
+    */
+   suni_pm7345->suni_id_reset = 0;
+
+   /*
+    * Clear "PMCTST" in master test register.
+    */
+   suni_pm7345->suni_master_test = 0;
+
+   suni_pm7345->suni_rxcp_ctrl = 0x2c;
+   suni_pm7345->suni_rxcp_fctrl = 0x81;
+ 
+   suni_pm7345->suni_rxcp_idle_pat_h1 =
+   	suni_pm7345->suni_rxcp_idle_pat_h2 =
+   	suni_pm7345->suni_rxcp_idle_pat_h3 = 0;
+   suni_pm7345->suni_rxcp_idle_pat_h4 = 1;
+ 
+   suni_pm7345->suni_rxcp_idle_mask_h1 = 0xff;
+   suni_pm7345->suni_rxcp_idle_mask_h2 = 0xff;
+   suni_pm7345->suni_rxcp_idle_mask_h3 = 0xff;
+   suni_pm7345->suni_rxcp_idle_mask_h4 = 0xfe;
+ 
+   suni_pm7345->suni_rxcp_cell_pat_h1 =
+   	suni_pm7345->suni_rxcp_cell_pat_h2 =
+   	suni_pm7345->suni_rxcp_cell_pat_h3 = 0;
+   suni_pm7345->suni_rxcp_cell_pat_h4 = 1;
+ 
+   suni_pm7345->suni_rxcp_cell_mask_h1 =
+   	suni_pm7345->suni_rxcp_cell_mask_h2 =
+   	suni_pm7345->suni_rxcp_cell_mask_h3 =
+   	suni_pm7345->suni_rxcp_cell_mask_h4 = 0xff;
+ 
+   suni_pm7345->suni_txcp_ctrl = 0xa4;
+   suni_pm7345->suni_txcp_intr_en_sts = 0x10;
+   suni_pm7345->suni_txcp_idle_pat_h5 = 0x55;
+ 
+   suni_pm7345->suni_config &= ~(SUNI_PM7345_LLB |
+                                 SUNI_PM7345_CLB |
+                                 SUNI_PM7345_DLB |
+                                  SUNI_PM7345_PLB);
+#ifdef __SNMP__
+   suni_pm7345->suni_rxcp_intr_en_sts |= SUNI_OOCDE;
+#endif /* __SNMP__ */
+   return;
+}
+
+
+/***************************** IA_LIB END *****************************/
+    
+static int tcnter = 0;
+static void xdump( u_char*  cp, int  length, char*  prefix )
+{
+    int col, count;
+    u_char prntBuf[120];
+    u_char*  pBuf = prntBuf;
+    count = 0;
+    while(count < length){
+        pBuf += sprintf( pBuf, "%s", prefix );
+        for(col = 0;count + col < length && col < 16; col++){
+            if (col != 0 && (col % 4) == 0)
+                pBuf += sprintf( pBuf, " " );
+            pBuf += sprintf( pBuf, "%02X ", cp[count + col] );
+        }
+        while(col++ < 16){      /* pad end of buffer with blanks */
+            if ((col % 4) == 0)
+                sprintf( pBuf, " " );
+            pBuf += sprintf( pBuf, "   " );
+        }
+        pBuf += sprintf( pBuf, "  " );
+        for(col = 0;count + col < length && col < 16; col++){
+            if (isprint((int)cp[count + col]))
+                pBuf += sprintf( pBuf, "%c", cp[count + col] );
+            else
+                pBuf += sprintf( pBuf, "." );
+                }
+        sprintf( pBuf, "\n" );
+        // SPrint(prntBuf);
+        printk(prntBuf);
+        count += col;
+        pBuf = prntBuf;
+    }
+
+}  /* close xdump(... */
+
+  
+static struct atm_dev *ia_boards = NULL;  
+  
+#define ACTUAL_RAM_BASE \
+	RAM_BASE*((iadev->mem)/(128 * 1024))  
+#define ACTUAL_SEG_RAM_BASE \
+	IPHASE5575_FRAG_CONTROL_RAM_BASE*((iadev->mem)/(128 * 1024))  
+#define ACTUAL_REASS_RAM_BASE \
+	IPHASE5575_REASS_CONTROL_RAM_BASE*((iadev->mem)/(128 * 1024))  
+  
+  
+/*-- some utilities and memory allocation stuff will come here -------------*/  
+  
+static void desc_dbg(IADEV *iadev) {
+
+  u_short tcq_wr_ptr, tcq_st_ptr, tcq_ed_ptr;
+  u32 i;
+  void __iomem *tmp;
+  // regval = readl((u32)ia_cmds->maddr);
+  tcq_wr_ptr =  readw(iadev->seg_reg+TCQ_WR_PTR);
+  printk("B_tcq_wr = 0x%x desc = %d last desc = %d\n",
+                     tcq_wr_ptr, readw(iadev->seg_ram+tcq_wr_ptr),
+                     readw(iadev->seg_ram+tcq_wr_ptr-2));
+  printk(" host_tcq_wr = 0x%x  host_tcq_rd = 0x%x \n",  iadev->host_tcq_wr, 
+                   iadev->ffL.tcq_rd);
+  tcq_st_ptr =  readw(iadev->seg_reg+TCQ_ST_ADR);
+  tcq_ed_ptr =  readw(iadev->seg_reg+TCQ_ED_ADR);
+  printk("tcq_st_ptr = 0x%x    tcq_ed_ptr = 0x%x \n", tcq_st_ptr, tcq_ed_ptr);
+  i = 0;
+  while (tcq_st_ptr != tcq_ed_ptr) {
+      tmp = iadev->seg_ram+tcq_st_ptr;
+      printk("TCQ slot %d desc = %d  Addr = %p\n", i++, readw(tmp), tmp);
+      tcq_st_ptr += 2;
+  }
+  for(i=0; i <iadev->num_tx_desc; i++)
+      printk("Desc_tbl[%d] = %d \n", i, iadev->desc_tbl[i].timestamp);
+} 
+  
+  
+/*----------------------------- Recieving side stuff --------------------------*/  
+ 
+static void rx_excp_rcvd(struct atm_dev *dev)  
+{  
+#if 0 /* closing the receiving size will cause too many excp int */  
+  IADEV *iadev;  
+  u_short state;  
+  u_short excpq_rd_ptr;  
+  //u_short *ptr;  
+  int vci, error = 1;  
+  iadev = INPH_IA_DEV(dev);  
+  state = readl(iadev->reass_reg + STATE_REG) & 0xffff;  
+  while((state & EXCPQ_EMPTY) != EXCPQ_EMPTY)  
+  { printk("state = %x \n", state); 
+        excpq_rd_ptr = readw(iadev->reass_reg + EXCP_Q_RD_PTR) & 0xffff;  
+ printk("state = %x excpq_rd_ptr = %x \n", state, excpq_rd_ptr); 
+        if (excpq_rd_ptr == *(u16*)(iadev->reass_reg + EXCP_Q_WR_PTR))
+            IF_ERR(printk("excpq_rd_ptr is wrong!!!\n");)
+        // TODO: update exception stat
+	vci = readw(iadev->reass_ram+excpq_rd_ptr);  
+	error = readw(iadev->reass_ram+excpq_rd_ptr+2) & 0x0007;  
+        // pwang_test
+	excpq_rd_ptr += 4;  
+	if (excpq_rd_ptr > (readw(iadev->reass_reg + EXCP_Q_ED_ADR)& 0xffff))  
+ 	    excpq_rd_ptr = readw(iadev->reass_reg + EXCP_Q_ST_ADR)& 0xffff;
+	writew( excpq_rd_ptr, iadev->reass_reg + EXCP_Q_RD_PTR);  
+        state = readl(iadev->reass_reg + STATE_REG) & 0xffff;  
+  }  
+#endif
+}  
+  
+static void free_desc(struct atm_dev *dev, int desc)  
+{  
+	IADEV *iadev;  
+	iadev = INPH_IA_DEV(dev);  
+        writew(desc, iadev->reass_ram+iadev->rfL.fdq_wr); 
+	iadev->rfL.fdq_wr +=2;
+	if (iadev->rfL.fdq_wr > iadev->rfL.fdq_ed)
+		iadev->rfL.fdq_wr =  iadev->rfL.fdq_st;  
+	writew(iadev->rfL.fdq_wr, iadev->reass_reg+FREEQ_WR_PTR);  
+}  
+  
+  
+static int rx_pkt(struct atm_dev *dev)  
+{  
+	IADEV *iadev;  
+	struct atm_vcc *vcc;  
+	unsigned short status;  
+	struct rx_buf_desc __iomem *buf_desc_ptr;  
+	int desc;   
+	struct dle* wr_ptr;  
+	int len;  
+	struct sk_buff *skb;  
+	u_int buf_addr, dma_addr;  
+
+	iadev = INPH_IA_DEV(dev);  
+	if (iadev->rfL.pcq_rd == (readw(iadev->reass_reg+PCQ_WR_PTR)&0xffff)) 
+	{  
+   	    printk(KERN_ERR DEV_LABEL "(itf %d) Receive queue empty\n", dev->number);  
+	    return -EINVAL;  
+	}  
+	/* mask 1st 3 bits to get the actual descno. */  
+	desc = readw(iadev->reass_ram+iadev->rfL.pcq_rd) & 0x1fff;  
+        IF_RX(printk("reass_ram = %p iadev->rfL.pcq_rd = 0x%x desc = %d\n", 
+                                    iadev->reass_ram, iadev->rfL.pcq_rd, desc);
+              printk(" pcq_wr_ptr = 0x%x\n",
+                               readw(iadev->reass_reg+PCQ_WR_PTR)&0xffff);)
+	/* update the read pointer  - maybe we shud do this in the end*/  
+	if ( iadev->rfL.pcq_rd== iadev->rfL.pcq_ed) 
+		iadev->rfL.pcq_rd = iadev->rfL.pcq_st;  
+	else  
+		iadev->rfL.pcq_rd += 2;
+	writew(iadev->rfL.pcq_rd, iadev->reass_reg+PCQ_RD_PTR);  
+  
+	/* get the buffer desc entry.  
+		update stuff. - doesn't seem to be any update necessary  
+	*/  
+	buf_desc_ptr = iadev->RX_DESC_BASE_ADDR;
+	/* make the ptr point to the corresponding buffer desc entry */  
+	buf_desc_ptr += desc;	  
+        if (!desc || (desc > iadev->num_rx_desc) || 
+                      ((buf_desc_ptr->vc_index & 0xffff) > iadev->num_vc)) { 
+            free_desc(dev, desc);
+            IF_ERR(printk("IA: bad descriptor desc = %d \n", desc);)
+            return -1;
+        }
+	vcc = iadev->rx_open[buf_desc_ptr->vc_index & 0xffff];  
+	if (!vcc)  
+	{      
+                free_desc(dev, desc); 
+		printk("IA: null vcc, drop PDU\n");  
+		return -1;  
+	}  
+	  
+  
+	/* might want to check the status bits for errors */  
+	status = (u_short) (buf_desc_ptr->desc_mode);  
+	if (status & (RX_CER | RX_PTE | RX_OFL))  
+	{  
+                atomic_inc(&vcc->stats->rx_err);
+		IF_ERR(printk("IA: bad packet, dropping it");)  
+                if (status & RX_CER) { 
+                    IF_ERR(printk(" cause: packet CRC error\n");)
+                }
+                else if (status & RX_PTE) {
+                    IF_ERR(printk(" cause: packet time out\n");)
+                }
+                else {
+                    IF_ERR(printk(" cause: buffer over flow\n");)
+                }
+		goto out_free_desc;
+	}  
+  
+	/*  
+		build DLE.	  
+	*/  
+  
+	buf_addr = (buf_desc_ptr->buf_start_hi << 16) | buf_desc_ptr->buf_start_lo;  
+	dma_addr = (buf_desc_ptr->dma_start_hi << 16) | buf_desc_ptr->dma_start_lo;  
+	len = dma_addr - buf_addr;  
+        if (len > iadev->rx_buf_sz) {
+           printk("Over %d bytes sdu received, dropped!!!\n", iadev->rx_buf_sz);
+           atomic_inc(&vcc->stats->rx_err);
+	   goto out_free_desc;
+        }
+		  
+        if (!(skb = atm_alloc_charge(vcc, len, GFP_ATOMIC))) {
+           if (vcc->vci < 32)
+              printk("Drop control packets\n");
+	      goto out_free_desc;
+        }
+	skb_put(skb,len);  
+        // pwang_test
+        ATM_SKB(skb)->vcc = vcc;
+        ATM_DESC(skb) = desc;        
+	skb_queue_tail(&iadev->rx_dma_q, skb);  
+
+	/* Build the DLE structure */  
+	wr_ptr = iadev->rx_dle_q.write;  
+	wr_ptr->sys_pkt_addr = pci_map_single(iadev->pci, skb->data,
+		len, PCI_DMA_FROMDEVICE);
+	wr_ptr->local_pkt_addr = buf_addr;  
+	wr_ptr->bytes = len;	/* We don't know this do we ?? */  
+	wr_ptr->mode = DMA_INT_ENABLE;  
+  
+	/* shud take care of wrap around here too. */  
+        if(++wr_ptr == iadev->rx_dle_q.end)
+             wr_ptr = iadev->rx_dle_q.start;
+	iadev->rx_dle_q.write = wr_ptr;  
+	udelay(1);  
+	/* Increment transaction counter */  
+	writel(1, iadev->dma+IPHASE5575_RX_COUNTER);   
+out:	return 0;  
+out_free_desc:
+        free_desc(dev, desc);
+        goto out;
+}  
+  
+static void rx_intr(struct atm_dev *dev)  
+{  
+  IADEV *iadev;  
+  u_short status;  
+  u_short state, i;  
+  
+  iadev = INPH_IA_DEV(dev);  
+  status = readl(iadev->reass_reg+REASS_INTR_STATUS_REG) & 0xffff;  
+  IF_EVENT(printk("rx_intr: status = 0x%x\n", status);)
+  if (status & RX_PKT_RCVD)  
+  {  
+	/* do something */  
+	/* Basically recvd an interrupt for receving a packet.  
+	A descriptor would have been written to the packet complete   
+	queue. Get all the descriptors and set up dma to move the   
+	packets till the packet complete queue is empty..  
+	*/  
+	state = readl(iadev->reass_reg + STATE_REG) & 0xffff;  
+        IF_EVENT(printk("Rx intr status: RX_PKT_RCVD %08x\n", status);) 
+	while(!(state & PCQ_EMPTY))  
+	{  
+             rx_pkt(dev);  
+	     state = readl(iadev->reass_reg + STATE_REG) & 0xffff;  
+	}  
+        iadev->rxing = 1;
+  }  
+  if (status & RX_FREEQ_EMPT)  
+  {   
+     if (iadev->rxing) {
+        iadev->rx_tmp_cnt = iadev->rx_pkt_cnt;
+        iadev->rx_tmp_jif = jiffies; 
+        iadev->rxing = 0;
+     } 
+     else if (((jiffies - iadev->rx_tmp_jif) > 50) && 
+               ((iadev->rx_pkt_cnt - iadev->rx_tmp_cnt) == 0)) {
+        for (i = 1; i <= iadev->num_rx_desc; i++)
+               free_desc(dev, i);
+printk("Test logic RUN!!!!\n");
+        writew( ~(RX_FREEQ_EMPT|RX_EXCP_RCVD),iadev->reass_reg+REASS_MASK_REG);
+        iadev->rxing = 1;
+     }
+     IF_EVENT(printk("Rx intr status: RX_FREEQ_EMPT %08x\n", status);)  
+  }  
+
+  if (status & RX_EXCP_RCVD)  
+  {  
+	/* probably need to handle the exception queue also. */  
+	IF_EVENT(printk("Rx intr status: RX_EXCP_RCVD %08x\n", status);)  
+	rx_excp_rcvd(dev);  
+  }  
+
+
+  if (status & RX_RAW_RCVD)  
+  {  
+	/* need to handle the raw incoming cells. This deepnds on   
+	whether we have programmed to receive the raw cells or not.  
+	Else ignore. */  
+	IF_EVENT(printk("Rx intr status:  RX_RAW_RCVD %08x\n", status);)  
+  }  
+}  
+  
+  
+static void rx_dle_intr(struct atm_dev *dev)  
+{  
+  IADEV *iadev;  
+  struct atm_vcc *vcc;   
+  struct sk_buff *skb;  
+  int desc;  
+  u_short state;   
+  struct dle *dle, *cur_dle;  
+  u_int dle_lp;  
+  int len;
+  iadev = INPH_IA_DEV(dev);  
+ 
+  /* free all the dles done, that is just update our own dle read pointer   
+	- do we really need to do this. Think not. */  
+  /* DMA is done, just get all the recevie buffers from the rx dma queue  
+	and push them up to the higher layer protocol. Also free the desc  
+	associated with the buffer. */  
+  dle = iadev->rx_dle_q.read;  
+  dle_lp = readl(iadev->dma+IPHASE5575_RX_LIST_ADDR) & (sizeof(struct dle)*DLE_ENTRIES - 1);  
+  cur_dle = (struct dle*)(iadev->rx_dle_q.start + (dle_lp >> 4));  
+  while(dle != cur_dle)  
+  {  
+      /* free the DMAed skb */  
+      skb = skb_dequeue(&iadev->rx_dma_q);  
+      if (!skb)  
+         goto INCR_DLE;
+      desc = ATM_DESC(skb);
+      free_desc(dev, desc);  
+               
+      if (!(len = skb->len))
+      {  
+          printk("rx_dle_intr: skb len 0\n");  
+	  dev_kfree_skb_any(skb);  
+      }  
+      else  
+      {  
+          struct cpcs_trailer *trailer;
+          u_short length;
+          struct ia_vcc *ia_vcc;
+
+	  pci_unmap_single(iadev->pci, iadev->rx_dle_q.write->sys_pkt_addr,
+	  	len, PCI_DMA_FROMDEVICE);
+          /* no VCC related housekeeping done as yet. lets see */  
+          vcc = ATM_SKB(skb)->vcc;
+	  if (!vcc) {
+	      printk("IA: null vcc\n");  
+              dev_kfree_skb_any(skb);
+              goto INCR_DLE;
+          }
+          ia_vcc = INPH_IA_VCC(vcc);
+          if (ia_vcc == NULL)
+          {
+             atomic_inc(&vcc->stats->rx_err);
+             dev_kfree_skb_any(skb);
+             atm_return(vcc, atm_guess_pdu2truesize(len));
+             goto INCR_DLE;
+           }
+          // get real pkt length  pwang_test
+          trailer = (struct cpcs_trailer*)((u_char *)skb->data +
+                                 skb->len - sizeof(*trailer));
+          length =  swap(trailer->length);
+          if ((length > iadev->rx_buf_sz) || (length > 
+                              (skb->len - sizeof(struct cpcs_trailer))))
+          {
+             atomic_inc(&vcc->stats->rx_err);
+             IF_ERR(printk("rx_dle_intr: Bad  AAL5 trailer %d (skb len %d)", 
+                                                            length, skb->len);)
+             dev_kfree_skb_any(skb);
+             atm_return(vcc, atm_guess_pdu2truesize(len));
+             goto INCR_DLE;
+          }
+          skb_trim(skb, length);
+          
+	  /* Display the packet */  
+	  IF_RXPKT(printk("\nDmad Recvd data: len = %d \n", skb->len);  
+          xdump(skb->data, skb->len, "RX: ");
+          printk("\n");)
+
+	  IF_RX(printk("rx_dle_intr: skb push");)  
+	  vcc->push(vcc,skb);  
+	  atomic_inc(&vcc->stats->rx);
+          iadev->rx_pkt_cnt++;
+      }  
+INCR_DLE:
+      if (++dle == iadev->rx_dle_q.end)  
+    	  dle = iadev->rx_dle_q.start;  
+  }  
+  iadev->rx_dle_q.read = dle;  
+  
+  /* if the interrupts are masked because there were no free desc available,  
+		unmask them now. */ 
+  if (!iadev->rxing) {
+     state = readl(iadev->reass_reg + STATE_REG) & 0xffff;
+     if (!(state & FREEQ_EMPTY)) {
+        state = readl(iadev->reass_reg + REASS_MASK_REG) & 0xffff;
+        writel(state & ~(RX_FREEQ_EMPT |/* RX_EXCP_RCVD |*/ RX_PKT_RCVD),
+                                      iadev->reass_reg+REASS_MASK_REG);
+        iadev->rxing++; 
+     }
+  }
+}  
+  
+  
+static int open_rx(struct atm_vcc *vcc)  
+{  
+	IADEV *iadev;  
+	u_short __iomem *vc_table;  
+	u_short __iomem *reass_ptr;  
+	IF_EVENT(printk("iadev: open_rx %d.%d\n", vcc->vpi, vcc->vci);)
+
+	if (vcc->qos.rxtp.traffic_class == ATM_NONE) return 0;    
+	iadev = INPH_IA_DEV(vcc->dev);  
+        if (vcc->qos.rxtp.traffic_class == ATM_ABR) {  
+           if (iadev->phy_type & FE_25MBIT_PHY) {
+               printk("IA:  ABR not support\n");
+               return -EINVAL; 
+           }
+        }
+	/* Make only this VCI in the vc table valid and let all   
+		others be invalid entries */  
+	vc_table = iadev->reass_ram+RX_VC_TABLE*iadev->memSize;
+	vc_table += vcc->vci;
+	/* mask the last 6 bits and OR it with 3 for 1K VCs */  
+
+        *vc_table = vcc->vci << 6;
+	/* Also keep a list of open rx vcs so that we can attach them with  
+		incoming PDUs later. */  
+	if ((vcc->qos.rxtp.traffic_class == ATM_ABR) || 
+                                (vcc->qos.txtp.traffic_class == ATM_ABR))  
+	{  
+                srv_cls_param_t srv_p;
+                init_abr_vc(iadev, &srv_p);
+                ia_open_abr_vc(iadev, &srv_p, vcc, 0);
+	} 
+       	else {  /* for UBR  later may need to add CBR logic */
+        	reass_ptr = iadev->reass_ram+REASS_TABLE*iadev->memSize;
+           	reass_ptr += vcc->vci;
+           	*reass_ptr = NO_AAL5_PKT;
+       	}
+	
+	if (iadev->rx_open[vcc->vci])  
+		printk(KERN_CRIT DEV_LABEL "(itf %d): VCI %d already open\n",  
+			vcc->dev->number, vcc->vci);  
+	iadev->rx_open[vcc->vci] = vcc;  
+	return 0;  
+}  
+  
+static int rx_init(struct atm_dev *dev)  
+{  
+	IADEV *iadev;  
+	struct rx_buf_desc __iomem *buf_desc_ptr;  
+	unsigned long rx_pkt_start = 0;  
+	void *dle_addr;  
+	struct abr_vc_table  *abr_vc_table; 
+	u16 *vc_table;  
+	u16 *reass_table;  
+        u16 *ptr16;
+	int i,j, vcsize_sel;  
+	u_short freeq_st_adr;  
+	u_short *freeq_start;  
+  
+	iadev = INPH_IA_DEV(dev);  
+  //    spin_lock_init(&iadev->rx_lock); 
+  
+	/* Allocate 4k bytes - more aligned than needed (4k boundary) */
+	dle_addr = pci_alloc_consistent(iadev->pci, DLE_TOTAL_SIZE,
+					&iadev->rx_dle_dma);  
+	if (!dle_addr)  {  
+		printk(KERN_ERR DEV_LABEL "can't allocate DLEs\n");
+		goto err_out;
+	}
+	iadev->rx_dle_q.start = (struct dle*)dle_addr;  
+	iadev->rx_dle_q.read = iadev->rx_dle_q.start;  
+	iadev->rx_dle_q.write = iadev->rx_dle_q.start;  
+	iadev->rx_dle_q.end = (struct dle*)((u32)dle_addr+sizeof(struct dle)*DLE_ENTRIES);  
+	/* the end of the dle q points to the entry after the last  
+	DLE that can be used. */  
+  
+	/* write the upper 20 bits of the start address to rx list address register */  
+	writel(iadev->rx_dle_dma & 0xfffff000,
+	       iadev->dma + IPHASE5575_RX_LIST_ADDR);  
+	IF_INIT(printk("Tx Dle list addr: 0x%08x value: 0x%0x\n", 
+                      (u32)(iadev->dma+IPHASE5575_TX_LIST_ADDR), 
+                      *(u32*)(iadev->dma+IPHASE5575_TX_LIST_ADDR));  
+	printk("Rx Dle list addr: 0x%08x value: 0x%0x\n", 
+                      (u32)(iadev->dma+IPHASE5575_RX_LIST_ADDR), 
+                      *(u32*)(iadev->dma+IPHASE5575_RX_LIST_ADDR));)  
+  
+	writew(0xffff, iadev->reass_reg+REASS_MASK_REG);  
+	writew(0, iadev->reass_reg+MODE_REG);  
+	writew(RESET_REASS, iadev->reass_reg+REASS_COMMAND_REG);  
+  
+	/* Receive side control memory map  
+	   -------------------------------  
+  
+		Buffer descr	0x0000 (736 - 23K)  
+		VP Table	0x5c00 (256 - 512)  
+		Except q	0x5e00 (128 - 512)  
+		Free buffer q	0x6000 (1K - 2K)  
+		Packet comp q	0x6800 (1K - 2K)  
+		Reass Table	0x7000 (1K - 2K)  
+		VC Table	0x7800 (1K - 2K)  
+		ABR VC Table	0x8000 (1K - 32K)  
+	*/  
+	  
+	/* Base address for Buffer Descriptor Table */  
+	writew(RX_DESC_BASE >> 16, iadev->reass_reg+REASS_DESC_BASE);  
+	/* Set the buffer size register */  
+	writew(iadev->rx_buf_sz, iadev->reass_reg+BUF_SIZE);  
+  
+	/* Initialize each entry in the Buffer Descriptor Table */  
+        iadev->RX_DESC_BASE_ADDR = iadev->reass_ram+RX_DESC_BASE*iadev->memSize;
+	buf_desc_ptr = iadev->RX_DESC_BASE_ADDR;
+	memset_io(buf_desc_ptr, 0, sizeof(*buf_desc_ptr));
+	buf_desc_ptr++;  
+	rx_pkt_start = iadev->rx_pkt_ram;  
+	for(i=1; i<=iadev->num_rx_desc; i++)  
+	{  
+		memset_io(buf_desc_ptr, 0, sizeof(*buf_desc_ptr));  
+		buf_desc_ptr->buf_start_hi = rx_pkt_start >> 16;  
+		buf_desc_ptr->buf_start_lo = rx_pkt_start & 0x0000ffff;  
+		buf_desc_ptr++;		  
+		rx_pkt_start += iadev->rx_buf_sz;  
+	}  
+	IF_INIT(printk("Rx Buffer desc ptr: 0x%0x\n", (u32)(buf_desc_ptr));)  
+        i = FREE_BUF_DESC_Q*iadev->memSize; 
+	writew(i >> 16,  iadev->reass_reg+REASS_QUEUE_BASE); 
+        writew(i, iadev->reass_reg+FREEQ_ST_ADR);
+        writew(i+iadev->num_rx_desc*sizeof(u_short), 
+                                         iadev->reass_reg+FREEQ_ED_ADR);
+        writew(i, iadev->reass_reg+FREEQ_RD_PTR);
+        writew(i+iadev->num_rx_desc*sizeof(u_short), 
+                                        iadev->reass_reg+FREEQ_WR_PTR);    
+	/* Fill the FREEQ with all the free descriptors. */  
+	freeq_st_adr = readw(iadev->reass_reg+FREEQ_ST_ADR);  
+	freeq_start = (u_short *)(iadev->reass_ram+freeq_st_adr);  
+	for(i=1; i<=iadev->num_rx_desc; i++)  
+	{  
+		*freeq_start = (u_short)i;  
+		freeq_start++;  
+	}  
+	IF_INIT(printk("freeq_start: 0x%0x\n", (u32)freeq_start);)  
+        /* Packet Complete Queue */
+        i = (PKT_COMP_Q * iadev->memSize) & 0xffff;
+        writew(i, iadev->reass_reg+PCQ_ST_ADR);
+        writew(i+iadev->num_vc*sizeof(u_short), iadev->reass_reg+PCQ_ED_ADR);
+        writew(i, iadev->reass_reg+PCQ_RD_PTR);
+        writew(i, iadev->reass_reg+PCQ_WR_PTR);
+
+        /* Exception Queue */
+        i = (EXCEPTION_Q * iadev->memSize) & 0xffff;
+        writew(i, iadev->reass_reg+EXCP_Q_ST_ADR);
+        writew(i + NUM_RX_EXCP * sizeof(RX_ERROR_Q), 
+                                             iadev->reass_reg+EXCP_Q_ED_ADR);
+        writew(i, iadev->reass_reg+EXCP_Q_RD_PTR);
+        writew(i, iadev->reass_reg+EXCP_Q_WR_PTR); 
+ 
+    	/* Load local copy of FREEQ and PCQ ptrs */
+        iadev->rfL.fdq_st = readw(iadev->reass_reg+FREEQ_ST_ADR) & 0xffff;
+       	iadev->rfL.fdq_ed = readw(iadev->reass_reg+FREEQ_ED_ADR) & 0xffff ;
+	iadev->rfL.fdq_rd = readw(iadev->reass_reg+FREEQ_RD_PTR) & 0xffff;
+	iadev->rfL.fdq_wr = readw(iadev->reass_reg+FREEQ_WR_PTR) & 0xffff;
+        iadev->rfL.pcq_st = readw(iadev->reass_reg+PCQ_ST_ADR) & 0xffff;
+	iadev->rfL.pcq_ed = readw(iadev->reass_reg+PCQ_ED_ADR) & 0xffff;
+	iadev->rfL.pcq_rd = readw(iadev->reass_reg+PCQ_RD_PTR) & 0xffff;
+	iadev->rfL.pcq_wr = readw(iadev->reass_reg+PCQ_WR_PTR) & 0xffff;
+	
+        IF_INIT(printk("INIT:pcq_st:0x%x pcq_ed:0x%x pcq_rd:0x%x pcq_wr:0x%x", 
+              iadev->rfL.pcq_st, iadev->rfL.pcq_ed, iadev->rfL.pcq_rd, 
+              iadev->rfL.pcq_wr);)		  
+	/* just for check - no VP TBL */  
+	/* VP Table */  
+	/* writew(0x0b80, iadev->reass_reg+VP_LKUP_BASE); */  
+	/* initialize VP Table for invalid VPIs  
+		- I guess we can write all 1s or 0x000f in the entire memory  
+		  space or something similar.  
+	*/  
+  
+	/* This seems to work and looks right to me too !!! */  
+        i =  REASS_TABLE * iadev->memSize;
+	writew((i >> 3), iadev->reass_reg+REASS_TABLE_BASE);   
+ 	/* initialize Reassembly table to I don't know what ???? */  
+	reass_table = (u16 *)(iadev->reass_ram+i);  
+        j = REASS_TABLE_SZ * iadev->memSize;
+	for(i=0; i < j; i++)  
+		*reass_table++ = NO_AAL5_PKT;  
+       i = 8*1024;
+       vcsize_sel =  0;
+       while (i != iadev->num_vc) {
+          i /= 2;
+          vcsize_sel++;
+       }
+       i = RX_VC_TABLE * iadev->memSize;
+       writew(((i>>3) & 0xfff8) | vcsize_sel, iadev->reass_reg+VC_LKUP_BASE);
+       vc_table = (u16 *)(iadev->reass_ram+RX_VC_TABLE*iadev->memSize);  
+        j = RX_VC_TABLE_SZ * iadev->memSize;
+	for(i = 0; i < j; i++)  
+	{  
+		/* shift the reassembly pointer by 3 + lower 3 bits of   
+		vc_lkup_base register (=3 for 1K VCs) and the last byte   
+		is those low 3 bits.   
+		Shall program this later.  
+		*/  
+		*vc_table = (i << 6) | 15;	/* for invalid VCI */  
+		vc_table++;  
+	}  
+        /* ABR VC table */
+        i =  ABR_VC_TABLE * iadev->memSize;
+        writew(i >> 3, iadev->reass_reg+ABR_LKUP_BASE);
+                   
+        i = ABR_VC_TABLE * iadev->memSize;
+	abr_vc_table = (struct abr_vc_table *)(iadev->reass_ram+i);  
+        j = REASS_TABLE_SZ * iadev->memSize;
+        memset ((char*)abr_vc_table, 0, j * sizeof(*abr_vc_table));
+    	for(i = 0; i < j; i++) {   		
+		abr_vc_table->rdf = 0x0003;
+             	abr_vc_table->air = 0x5eb1;
+	       	abr_vc_table++;   	
+        }  
+
+	/* Initialize other registers */  
+  
+	/* VP Filter Register set for VC Reassembly only */  
+	writew(0xff00, iadev->reass_reg+VP_FILTER);  
+        writew(0, iadev->reass_reg+XTRA_RM_OFFSET);
+	writew(0x1,  iadev->reass_reg+PROTOCOL_ID);
+
+	/* Packet Timeout Count  related Registers : 
+	   Set packet timeout to occur in about 3 seconds
+	   Set Packet Aging Interval count register to overflow in about 4 us
+ 	*/  
+        writew(0xF6F8, iadev->reass_reg+PKT_TM_CNT );
+        ptr16 = (u16*)j;
+        i = ((u32)ptr16 >> 6) & 0xff;
+	ptr16  += j - 1;
+	i |=(((u32)ptr16 << 2) & 0xff00);
+        writew(i, iadev->reass_reg+TMOUT_RANGE);
+        /* initiate the desc_tble */
+        for(i=0; i<iadev->num_tx_desc;i++)
+            iadev->desc_tbl[i].timestamp = 0;
+
+	/* to clear the interrupt status register - read it */  
+	readw(iadev->reass_reg+REASS_INTR_STATUS_REG);   
+  
+	/* Mask Register - clear it */  
+	writew(~(RX_FREEQ_EMPT|RX_PKT_RCVD), iadev->reass_reg+REASS_MASK_REG);  
+  
+	skb_queue_head_init(&iadev->rx_dma_q);  
+	iadev->rx_free_desc_qhead = NULL;   
+	iadev->rx_open = kmalloc(4*iadev->num_vc,GFP_KERNEL);
+	if (!iadev->rx_open)  
+	{  
+		printk(KERN_ERR DEV_LABEL "itf %d couldn't get free page\n",
+		dev->number);  
+		goto err_free_dle;
+	}  
+	memset(iadev->rx_open, 0, 4*iadev->num_vc);  
+        iadev->rxing = 1;
+        iadev->rx_pkt_cnt = 0;
+	/* Mode Register */  
+	writew(R_ONLINE, iadev->reass_reg+MODE_REG);  
+	return 0;  
+
+err_free_dle:
+	pci_free_consistent(iadev->pci, DLE_TOTAL_SIZE, iadev->rx_dle_q.start,
+			    iadev->rx_dle_dma);  
+err_out:
+	return -ENOMEM;
+}  
+  
+
+/*  
+	The memory map suggested in appendix A and the coding for it.   
+	Keeping it around just in case we change our mind later.  
+  
+		Buffer descr	0x0000 (128 - 4K)  
+		UBR sched	0x1000 (1K - 4K)  
+		UBR Wait q	0x2000 (1K - 4K)  
+		Commn queues	0x3000 Packet Ready, Trasmit comp(0x3100)  
+					(128 - 256) each  
+		extended VC	0x4000 (1K - 8K)  
+		ABR sched	0x6000	and ABR wait queue (1K - 2K) each  
+		CBR sched	0x7000 (as needed)  
+		VC table	0x8000 (1K - 32K)  
+*/  
+  
+static void tx_intr(struct atm_dev *dev)  
+{  
+	IADEV *iadev;  
+	unsigned short status;  
+        unsigned long flags;
+
+	iadev = INPH_IA_DEV(dev);  
+  
+	status = readl(iadev->seg_reg+SEG_INTR_STATUS_REG);  
+        if (status & TRANSMIT_DONE){
+
+           IF_EVENT(printk("Tansmit Done Intr logic run\n");)
+           spin_lock_irqsave(&iadev->tx_lock, flags);
+           ia_tx_poll(iadev);
+           spin_unlock_irqrestore(&iadev->tx_lock, flags);
+           writew(TRANSMIT_DONE, iadev->seg_reg+SEG_INTR_STATUS_REG);
+           if (iadev->close_pending)  
+               wake_up(&iadev->close_wait);
+        }     	  
+	if (status & TCQ_NOT_EMPTY)  
+	{  
+	    IF_EVENT(printk("TCQ_NOT_EMPTY int received\n");)  
+	}  
+}  
+  
+static void tx_dle_intr(struct atm_dev *dev)
+{
+        IADEV *iadev;
+        struct dle *dle, *cur_dle; 
+        struct sk_buff *skb;
+        struct atm_vcc *vcc;
+        struct ia_vcc  *iavcc;
+        u_int dle_lp;
+        unsigned long flags;
+
+        iadev = INPH_IA_DEV(dev);
+        spin_lock_irqsave(&iadev->tx_lock, flags);   
+        dle = iadev->tx_dle_q.read;
+        dle_lp = readl(iadev->dma+IPHASE5575_TX_LIST_ADDR) & 
+                                        (sizeof(struct dle)*DLE_ENTRIES - 1);
+        cur_dle = (struct dle*)(iadev->tx_dle_q.start + (dle_lp >> 4));
+        while (dle != cur_dle)
+        {
+            /* free the DMAed skb */ 
+            skb = skb_dequeue(&iadev->tx_dma_q); 
+            if (!skb) break;
+
+	    /* Revenge of the 2 dle (skb + trailer) used in ia_pkt_tx() */
+	    if (!((dle - iadev->tx_dle_q.start)%(2*sizeof(struct dle)))) {
+		pci_unmap_single(iadev->pci, dle->sys_pkt_addr, skb->len,
+				 PCI_DMA_TODEVICE);
+	    }
+            vcc = ATM_SKB(skb)->vcc;
+            if (!vcc) {
+                  printk("tx_dle_intr: vcc is null\n");
+		  spin_unlock_irqrestore(&iadev->tx_lock, flags);
+                  dev_kfree_skb_any(skb);
+
+                  return;
+            }
+            iavcc = INPH_IA_VCC(vcc);
+            if (!iavcc) {
+                  printk("tx_dle_intr: iavcc is null\n");
+		  spin_unlock_irqrestore(&iadev->tx_lock, flags);
+                  dev_kfree_skb_any(skb);
+                  return;
+            }
+            if (vcc->qos.txtp.pcr >= iadev->rate_limit) {
+               if ((vcc->pop) && (skb->len != 0))
+               {     
+                 vcc->pop(vcc, skb);
+               } 
+               else {
+                 dev_kfree_skb_any(skb);
+               }
+            }
+            else { /* Hold the rate-limited skb for flow control */
+               IA_SKB_STATE(skb) |= IA_DLED;
+               skb_queue_tail(&iavcc->txing_skb, skb);
+            }
+            IF_EVENT(printk("tx_dle_intr: enque skb = 0x%x \n", (u32)skb);)
+            if (++dle == iadev->tx_dle_q.end)
+                 dle = iadev->tx_dle_q.start;
+        }
+        iadev->tx_dle_q.read = dle;
+        spin_unlock_irqrestore(&iadev->tx_lock, flags);
+}
+  
+static int open_tx(struct atm_vcc *vcc)  
+{  
+	struct ia_vcc *ia_vcc;  
+	IADEV *iadev;  
+	struct main_vc *vc;  
+	struct ext_vc *evc;  
+        int ret;
+	IF_EVENT(printk("iadev: open_tx entered vcc->vci = %d\n", vcc->vci);)  
+	if (vcc->qos.txtp.traffic_class == ATM_NONE) return 0;  
+	iadev = INPH_IA_DEV(vcc->dev);  
+        
+        if (iadev->phy_type & FE_25MBIT_PHY) {
+           if (vcc->qos.txtp.traffic_class == ATM_ABR) {
+               printk("IA:  ABR not support\n");
+               return -EINVAL; 
+           }
+	  if (vcc->qos.txtp.traffic_class == ATM_CBR) {
+               printk("IA:  CBR not support\n");
+               return -EINVAL; 
+          }
+        }
+        ia_vcc =  INPH_IA_VCC(vcc);
+        memset((caddr_t)ia_vcc, 0, sizeof(*ia_vcc));
+        if (vcc->qos.txtp.max_sdu > 
+                         (iadev->tx_buf_sz - sizeof(struct cpcs_trailer))){
+           printk("IA:  SDU size over (%d) the configured SDU size %d\n",
+		  vcc->qos.txtp.max_sdu,iadev->tx_buf_sz);
+	   vcc->dev_data = NULL;
+           kfree(ia_vcc);
+           return -EINVAL; 
+        }
+	ia_vcc->vc_desc_cnt = 0;
+        ia_vcc->txing = 1;
+
+        /* find pcr */
+        if (vcc->qos.txtp.max_pcr == ATM_MAX_PCR) 
+           vcc->qos.txtp.pcr = iadev->LineRate;
+        else if ((vcc->qos.txtp.max_pcr == 0)&&( vcc->qos.txtp.pcr <= 0))
+           vcc->qos.txtp.pcr = iadev->LineRate;
+        else if ((vcc->qos.txtp.max_pcr > vcc->qos.txtp.pcr) && (vcc->qos.txtp.max_pcr> 0)) 
+           vcc->qos.txtp.pcr = vcc->qos.txtp.max_pcr;
+        if (vcc->qos.txtp.pcr > iadev->LineRate)
+             vcc->qos.txtp.pcr = iadev->LineRate;
+        ia_vcc->pcr = vcc->qos.txtp.pcr;
+
+        if (ia_vcc->pcr > (iadev->LineRate / 6) ) ia_vcc->ltimeout = HZ / 10;
+        else if (ia_vcc->pcr > (iadev->LineRate / 130)) ia_vcc->ltimeout = HZ;
+        else if (ia_vcc->pcr <= 170) ia_vcc->ltimeout = 16 * HZ;
+        else ia_vcc->ltimeout = 2700 * HZ  / ia_vcc->pcr;
+        if (ia_vcc->pcr < iadev->rate_limit)
+           skb_queue_head_init (&ia_vcc->txing_skb);
+        if (ia_vcc->pcr < iadev->rate_limit) {
+	   struct sock *sk = sk_atm(vcc);
+
+	   if (vcc->qos.txtp.max_sdu != 0) {
+               if (ia_vcc->pcr > 60000)
+                  sk->sk_sndbuf = vcc->qos.txtp.max_sdu * 5;
+               else if (ia_vcc->pcr > 2000)
+                  sk->sk_sndbuf = vcc->qos.txtp.max_sdu * 4;
+               else
+                 sk->sk_sndbuf = vcc->qos.txtp.max_sdu * 3;
+           }
+           else
+             sk->sk_sndbuf = 24576;
+        }
+           
+	vc = (struct main_vc *)iadev->MAIN_VC_TABLE_ADDR;  
+	evc = (struct ext_vc *)iadev->EXT_VC_TABLE_ADDR;  
+	vc += vcc->vci;  
+	evc += vcc->vci;  
+	memset((caddr_t)vc, 0, sizeof(*vc));  
+	memset((caddr_t)evc, 0, sizeof(*evc));  
+	  
+	/* store the most significant 4 bits of vci as the last 4 bits   
+		of first part of atm header.  
+	   store the last 12 bits of vci as first 12 bits of the second  
+		part of the atm header.  
+	*/  
+	evc->atm_hdr1 = (vcc->vci >> 12) & 0x000f;  
+	evc->atm_hdr2 = (vcc->vci & 0x0fff) << 4;  
+ 
+	/* check the following for different traffic classes */  
+	if (vcc->qos.txtp.traffic_class == ATM_UBR)  
+	{  
+		vc->type = UBR;  
+                vc->status = CRC_APPEND;
+		vc->acr = cellrate_to_float(iadev->LineRate);  
+                if (vcc->qos.txtp.pcr > 0) 
+                   vc->acr = cellrate_to_float(vcc->qos.txtp.pcr);  
+                IF_UBR(printk("UBR: txtp.pcr = 0x%x f_rate = 0x%x\n", 
+                                             vcc->qos.txtp.max_pcr,vc->acr);)
+	}  
+	else if (vcc->qos.txtp.traffic_class == ATM_ABR)  
+	{       srv_cls_param_t srv_p;
+		IF_ABR(printk("Tx ABR VCC\n");)  
+                init_abr_vc(iadev, &srv_p);
+                if (vcc->qos.txtp.pcr > 0) 
+                   srv_p.pcr = vcc->qos.txtp.pcr;
+                if (vcc->qos.txtp.min_pcr > 0) {
+                   int tmpsum = iadev->sum_mcr+iadev->sum_cbr+vcc->qos.txtp.min_pcr;
+                   if (tmpsum > iadev->LineRate)
+                       return -EBUSY;
+                   srv_p.mcr = vcc->qos.txtp.min_pcr;
+                   iadev->sum_mcr += vcc->qos.txtp.min_pcr;
+                } 
+                else srv_p.mcr = 0;
+                if (vcc->qos.txtp.icr)
+                   srv_p.icr = vcc->qos.txtp.icr;
+                if (vcc->qos.txtp.tbe)
+                   srv_p.tbe = vcc->qos.txtp.tbe;
+                if (vcc->qos.txtp.frtt)
+                   srv_p.frtt = vcc->qos.txtp.frtt;
+                if (vcc->qos.txtp.rif)
+                   srv_p.rif = vcc->qos.txtp.rif;
+                if (vcc->qos.txtp.rdf)
+                   srv_p.rdf = vcc->qos.txtp.rdf;
+                if (vcc->qos.txtp.nrm_pres)
+                   srv_p.nrm = vcc->qos.txtp.nrm;
+                if (vcc->qos.txtp.trm_pres)
+                   srv_p.trm = vcc->qos.txtp.trm;
+                if (vcc->qos.txtp.adtf_pres)
+                   srv_p.adtf = vcc->qos.txtp.adtf;
+                if (vcc->qos.txtp.cdf_pres)
+                   srv_p.cdf = vcc->qos.txtp.cdf;    
+                if (srv_p.icr > srv_p.pcr)
+                   srv_p.icr = srv_p.pcr;    
+                IF_ABR(printk("ABR:vcc->qos.txtp.max_pcr = %d  mcr = %d\n", 
+                                                      srv_p.pcr, srv_p.mcr);)
+		ia_open_abr_vc(iadev, &srv_p, vcc, 1);
+	} else if (vcc->qos.txtp.traffic_class == ATM_CBR) {
+                if (iadev->phy_type & FE_25MBIT_PHY) {
+                    printk("IA:  CBR not support\n");
+                    return -EINVAL; 
+                }
+                if (vcc->qos.txtp.max_pcr > iadev->LineRate) {
+                   IF_CBR(printk("PCR is not availble\n");)
+                   return -1;
+                }
+                vc->type = CBR;
+                vc->status = CRC_APPEND;
+                if ((ret = ia_cbr_setup (iadev, vcc)) < 0) {     
+                    return ret;
+                }
+       } 
+	else  
+           printk("iadev:  Non UBR, ABR and CBR traffic not supportedn"); 
+        
+        iadev->testTable[vcc->vci]->vc_status |= VC_ACTIVE;
+	IF_EVENT(printk("ia open_tx returning \n");)  
+	return 0;  
+}  
+  
+  
+static int tx_init(struct atm_dev *dev)  
+{  
+	IADEV *iadev;  
+	struct tx_buf_desc *buf_desc_ptr;
+	unsigned int tx_pkt_start;  
+	void *dle_addr;  
+	int i;  
+	u_short tcq_st_adr;  
+	u_short *tcq_start;  
+	u_short prq_st_adr;  
+	u_short *prq_start;  
+	struct main_vc *vc;  
+	struct ext_vc *evc;   
+        u_short tmp16;
+        u32 vcsize_sel;
+ 
+	iadev = INPH_IA_DEV(dev);  
+        spin_lock_init(&iadev->tx_lock);
+ 
+	IF_INIT(printk("Tx MASK REG: 0x%0x\n", 
+                                readw(iadev->seg_reg+SEG_MASK_REG));)  
+
+	/* Allocate 4k (boundary aligned) bytes */
+	dle_addr = pci_alloc_consistent(iadev->pci, DLE_TOTAL_SIZE,
+					&iadev->tx_dle_dma);  
+	if (!dle_addr)  {
+		printk(KERN_ERR DEV_LABEL "can't allocate DLEs\n");
+		goto err_out;
+	}
+	iadev->tx_dle_q.start = (struct dle*)dle_addr;  
+	iadev->tx_dle_q.read = iadev->tx_dle_q.start;  
+	iadev->tx_dle_q.write = iadev->tx_dle_q.start;  
+	iadev->tx_dle_q.end = (struct dle*)((u32)dle_addr+sizeof(struct dle)*DLE_ENTRIES);  
+
+	/* write the upper 20 bits of the start address to tx list address register */  
+	writel(iadev->tx_dle_dma & 0xfffff000,
+	       iadev->dma + IPHASE5575_TX_LIST_ADDR);  
+	writew(0xffff, iadev->seg_reg+SEG_MASK_REG);  
+	writew(0, iadev->seg_reg+MODE_REG_0);  
+	writew(RESET_SEG, iadev->seg_reg+SEG_COMMAND_REG);  
+        iadev->MAIN_VC_TABLE_ADDR = iadev->seg_ram+MAIN_VC_TABLE*iadev->memSize;
+        iadev->EXT_VC_TABLE_ADDR = iadev->seg_ram+EXT_VC_TABLE*iadev->memSize;
+        iadev->ABR_SCHED_TABLE_ADDR=iadev->seg_ram+ABR_SCHED_TABLE*iadev->memSize;
+  
+	/*  
+	   Transmit side control memory map  
+	   --------------------------------    
+	 Buffer descr 	0x0000 (128 - 4K)  
+	 Commn queues	0x1000	Transmit comp, Packet ready(0x1400)   
+					(512 - 1K) each  
+					TCQ - 4K, PRQ - 5K  
+	 CBR Table 	0x1800 (as needed) - 6K  
+	 UBR Table	0x3000 (1K - 4K) - 12K  
+	 UBR Wait queue	0x4000 (1K - 4K) - 16K  
+	 ABR sched	0x5000	and ABR wait queue (1K - 2K) each  
+				ABR Tbl - 20K, ABR Wq - 22K   
+	 extended VC	0x6000 (1K - 8K) - 24K  
+	 VC Table	0x8000 (1K - 32K) - 32K  
+	  
+	Between 0x2000 (8K) and 0x3000 (12K) there is 4K space left for VBR Tbl  
+	and Wait q, which can be allotted later.  
+	*/  
+     
+	/* Buffer Descriptor Table Base address */  
+	writew(TX_DESC_BASE, iadev->seg_reg+SEG_DESC_BASE);  
+  
+	/* initialize each entry in the buffer descriptor table */  
+	buf_desc_ptr =(struct tx_buf_desc *)(iadev->seg_ram+TX_DESC_BASE);  
+	memset((caddr_t)buf_desc_ptr, 0, sizeof(*buf_desc_ptr));  
+	buf_desc_ptr++;  
+	tx_pkt_start = TX_PACKET_RAM;  
+	for(i=1; i<=iadev->num_tx_desc; i++)  
+	{  
+		memset((caddr_t)buf_desc_ptr, 0, sizeof(*buf_desc_ptr));  
+		buf_desc_ptr->desc_mode = AAL5;  
+		buf_desc_ptr->buf_start_hi = tx_pkt_start >> 16;  
+		buf_desc_ptr->buf_start_lo = tx_pkt_start & 0x0000ffff;  
+		buf_desc_ptr++;		  
+		tx_pkt_start += iadev->tx_buf_sz;  
+	}  
+        iadev->tx_buf = kmalloc(iadev->num_tx_desc*sizeof(struct cpcs_trailer_desc), GFP_KERNEL);
+        if (!iadev->tx_buf) {
+            printk(KERN_ERR DEV_LABEL " couldn't get mem\n");
+	    goto err_free_dle;
+        }
+       	for (i= 0; i< iadev->num_tx_desc; i++)
+       	{
+	    struct cpcs_trailer *cpcs;
+ 
+       	    cpcs = kmalloc(sizeof(*cpcs), GFP_KERNEL|GFP_DMA);
+            if(!cpcs) {                
+		printk(KERN_ERR DEV_LABEL " couldn't get freepage\n"); 
+		goto err_free_tx_bufs;
+            }
+	    iadev->tx_buf[i].cpcs = cpcs;
+	    iadev->tx_buf[i].dma_addr = pci_map_single(iadev->pci,
+		cpcs, sizeof(*cpcs), PCI_DMA_TODEVICE);
+        }
+        iadev->desc_tbl = kmalloc(iadev->num_tx_desc *
+                                   sizeof(struct desc_tbl_t), GFP_KERNEL);
+	if (!iadev->desc_tbl) {
+		printk(KERN_ERR DEV_LABEL " couldn't get mem\n");
+		goto err_free_all_tx_bufs;
+	}
+  
+	/* Communication Queues base address */  
+        i = TX_COMP_Q * iadev->memSize;
+	writew(i >> 16, iadev->seg_reg+SEG_QUEUE_BASE);  
+  
+	/* Transmit Complete Queue */  
+	writew(i, iadev->seg_reg+TCQ_ST_ADR);  
+	writew(i, iadev->seg_reg+TCQ_RD_PTR);  
+	writew(i+iadev->num_tx_desc*sizeof(u_short),iadev->seg_reg+TCQ_WR_PTR); 
+	iadev->host_tcq_wr = i + iadev->num_tx_desc*sizeof(u_short);
+        writew(i+2 * iadev->num_tx_desc * sizeof(u_short), 
+                                              iadev->seg_reg+TCQ_ED_ADR); 
+	/* Fill the TCQ with all the free descriptors. */  
+	tcq_st_adr = readw(iadev->seg_reg+TCQ_ST_ADR);  
+	tcq_start = (u_short *)(iadev->seg_ram+tcq_st_adr);  
+	for(i=1; i<=iadev->num_tx_desc; i++)  
+	{  
+		*tcq_start = (u_short)i;  
+		tcq_start++;  
+	}  
+  
+	/* Packet Ready Queue */  
+        i = PKT_RDY_Q * iadev->memSize; 
+	writew(i, iadev->seg_reg+PRQ_ST_ADR);  
+	writew(i+2 * iadev->num_tx_desc * sizeof(u_short), 
+                                              iadev->seg_reg+PRQ_ED_ADR);
+	writew(i, iadev->seg_reg+PRQ_RD_PTR);  
+	writew(i, iadev->seg_reg+PRQ_WR_PTR);  
+	 
+        /* Load local copy of PRQ and TCQ ptrs */
+        iadev->ffL.prq_st = readw(iadev->seg_reg+PRQ_ST_ADR) & 0xffff;
+	iadev->ffL.prq_ed = readw(iadev->seg_reg+PRQ_ED_ADR) & 0xffff;
+ 	iadev->ffL.prq_wr = readw(iadev->seg_reg+PRQ_WR_PTR) & 0xffff;
+
+	iadev->ffL.tcq_st = readw(iadev->seg_reg+TCQ_ST_ADR) & 0xffff;
+	iadev->ffL.tcq_ed = readw(iadev->seg_reg+TCQ_ED_ADR) & 0xffff;
+	iadev->ffL.tcq_rd = readw(iadev->seg_reg+TCQ_RD_PTR) & 0xffff;
+
+	/* Just for safety initializing the queue to have desc 1 always */  
+	/* Fill the PRQ with all the free descriptors. */  
+	prq_st_adr = readw(iadev->seg_reg+PRQ_ST_ADR);  
+	prq_start = (u_short *)(iadev->seg_ram+prq_st_adr);  
+	for(i=1; i<=iadev->num_tx_desc; i++)  
+	{  
+		*prq_start = (u_short)0;	/* desc 1 in all entries */  
+		prq_start++;  
+	}  
+	/* CBR Table */  
+        IF_INIT(printk("Start CBR Init\n");)
+#if 1  /* for 1K VC board, CBR_PTR_BASE is 0 */
+        writew(0,iadev->seg_reg+CBR_PTR_BASE);
+#else /* Charlie's logic is wrong ? */
+        tmp16 = (iadev->seg_ram+CBR_SCHED_TABLE*iadev->memSize)>>17;
+        IF_INIT(printk("cbr_ptr_base = 0x%x ", tmp16);)
+        writew(tmp16,iadev->seg_reg+CBR_PTR_BASE);
+#endif
+
+        IF_INIT(printk("value in register = 0x%x\n",
+                                   readw(iadev->seg_reg+CBR_PTR_BASE));)
+        tmp16 = (CBR_SCHED_TABLE*iadev->memSize) >> 1;
+        writew(tmp16, iadev->seg_reg+CBR_TAB_BEG);
+        IF_INIT(printk("cbr_tab_beg = 0x%x in reg = 0x%x \n", tmp16,
+                                        readw(iadev->seg_reg+CBR_TAB_BEG));)
+        writew(tmp16, iadev->seg_reg+CBR_TAB_END+1); // CBR_PTR;
+        tmp16 = (CBR_SCHED_TABLE*iadev->memSize + iadev->num_vc*6 - 2) >> 1;
+        writew(tmp16, iadev->seg_reg+CBR_TAB_END);
+        IF_INIT(printk("iadev->seg_reg = 0x%x CBR_PTR_BASE = 0x%x\n",
+               (u32)iadev->seg_reg, readw(iadev->seg_reg+CBR_PTR_BASE));)
+        IF_INIT(printk("CBR_TAB_BEG = 0x%x, CBR_TAB_END = 0x%x, CBR_PTR = 0x%x\n",
+          readw(iadev->seg_reg+CBR_TAB_BEG), readw(iadev->seg_reg+CBR_TAB_END),
+          readw(iadev->seg_reg+CBR_TAB_END+1));)
+
+        /* Initialize the CBR Schedualing Table */
+        memset_io(iadev->seg_ram+CBR_SCHED_TABLE*iadev->memSize, 
+                                                          0, iadev->num_vc*6); 
+        iadev->CbrRemEntries = iadev->CbrTotEntries = iadev->num_vc*3;
+        iadev->CbrEntryPt = 0;
+        iadev->Granularity = MAX_ATM_155 / iadev->CbrTotEntries;
+        iadev->NumEnabledCBR = 0;
+
+	/* UBR scheduling Table and wait queue */  
+	/* initialize all bytes of UBR scheduler table and wait queue to 0   
+		- SCHEDSZ is 1K (# of entries).  
+		- UBR Table size is 4K  
+		- UBR wait queue is 4K  
+	   since the table and wait queues are contiguous, all the bytes   
+	   can be initialized by one memeset.  
+	*/  
+        
+        vcsize_sel = 0;
+        i = 8*1024;
+        while (i != iadev->num_vc) {
+          i /= 2;
+          vcsize_sel++;
+        }
+ 
+        i = MAIN_VC_TABLE * iadev->memSize;
+        writew(vcsize_sel | ((i >> 8) & 0xfff8),iadev->seg_reg+VCT_BASE);
+        i =  EXT_VC_TABLE * iadev->memSize;
+        writew((i >> 8) & 0xfffe, iadev->seg_reg+VCTE_BASE);
+        i = UBR_SCHED_TABLE * iadev->memSize;
+        writew((i & 0xffff) >> 11,  iadev->seg_reg+UBR_SBPTR_BASE);
+        i = UBR_WAIT_Q * iadev->memSize; 
+        writew((i >> 7) & 0xffff,  iadev->seg_reg+UBRWQ_BASE);
+ 	memset((caddr_t)(iadev->seg_ram+UBR_SCHED_TABLE*iadev->memSize),
+                                                       0, iadev->num_vc*8);
+	/* ABR scheduling Table(0x5000-0x57ff) and wait queue(0x5800-0x5fff)*/  
+	/* initialize all bytes of ABR scheduler table and wait queue to 0   
+		- SCHEDSZ is 1K (# of entries).  
+		- ABR Table size is 2K  
+		- ABR wait queue is 2K  
+	   since the table and wait queues are contiguous, all the bytes   
+	   can be intialized by one memeset.  
+	*/  
+        i = ABR_SCHED_TABLE * iadev->memSize;
+        writew((i >> 11) & 0xffff, iadev->seg_reg+ABR_SBPTR_BASE);
+        i = ABR_WAIT_Q * iadev->memSize;
+        writew((i >> 7) & 0xffff, iadev->seg_reg+ABRWQ_BASE);
+ 
+        i = ABR_SCHED_TABLE*iadev->memSize;
+	memset((caddr_t)(iadev->seg_ram+i),  0, iadev->num_vc*4);
+	vc = (struct main_vc *)iadev->MAIN_VC_TABLE_ADDR;  
+	evc = (struct ext_vc *)iadev->EXT_VC_TABLE_ADDR;  
+        iadev->testTable = kmalloc(sizeof(long)*iadev->num_vc, GFP_KERNEL); 
+        if (!iadev->testTable) {
+           printk("Get freepage  failed\n");
+	   goto err_free_desc_tbl;
+        }
+	for(i=0; i<iadev->num_vc; i++)  
+	{  
+		memset((caddr_t)vc, 0, sizeof(*vc));  
+		memset((caddr_t)evc, 0, sizeof(*evc));  
+                iadev->testTable[i] = kmalloc(sizeof(struct testTable_t),
+						GFP_KERNEL);
+		if (!iadev->testTable[i])
+			goto err_free_test_tables;
+              	iadev->testTable[i]->lastTime = 0;
+ 		iadev->testTable[i]->fract = 0;
+                iadev->testTable[i]->vc_status = VC_UBR;
+		vc++;  
+		evc++;  
+	}  
+  
+	/* Other Initialization */  
+	  
+	/* Max Rate Register */  
+        if (iadev->phy_type & FE_25MBIT_PHY) {
+	   writew(RATE25, iadev->seg_reg+MAXRATE);  
+	   writew((UBR_EN | (0x23 << 2)), iadev->seg_reg+STPARMS);  
+        }
+        else {
+	   writew(cellrate_to_float(iadev->LineRate),iadev->seg_reg+MAXRATE);
+	   writew((UBR_EN | ABR_EN | (0x23 << 2)), iadev->seg_reg+STPARMS);  
+        }
+	/* Set Idle Header Reigisters to be sure */  
+	writew(0, iadev->seg_reg+IDLEHEADHI);  
+	writew(0, iadev->seg_reg+IDLEHEADLO);  
+  
+	/* Program ABR UBR Priority Register  as  PRI_ABR_UBR_EQUAL */
+        writew(0xaa00, iadev->seg_reg+ABRUBR_ARB); 
+
+        iadev->close_pending = 0;
+        init_waitqueue_head(&iadev->close_wait);
+        init_waitqueue_head(&iadev->timeout_wait);
+	skb_queue_head_init(&iadev->tx_dma_q);  
+	ia_init_rtn_q(&iadev->tx_return_q);  
+
+	/* RM Cell Protocol ID and Message Type */  
+	writew(RM_TYPE_4_0, iadev->seg_reg+RM_TYPE);  
+        skb_queue_head_init (&iadev->tx_backlog);
+  
+	/* Mode Register 1 */  
+	writew(MODE_REG_1_VAL, iadev->seg_reg+MODE_REG_1);  
+  
+	/* Mode Register 0 */  
+	writew(T_ONLINE, iadev->seg_reg+MODE_REG_0);  
+  
+	/* Interrupt Status Register - read to clear */  
+	readw(iadev->seg_reg+SEG_INTR_STATUS_REG);  
+  
+	/* Interrupt Mask Reg- don't mask TCQ_NOT_EMPTY interrupt generation */  
+        writew(~(TRANSMIT_DONE | TCQ_NOT_EMPTY), iadev->seg_reg+SEG_MASK_REG);
+        writew(TRANSMIT_DONE, iadev->seg_reg+SEG_INTR_STATUS_REG);  
+        iadev->tx_pkt_cnt = 0;
+        iadev->rate_limit = iadev->LineRate / 3;
+  
+	return 0;
+
+err_free_test_tables:
+	while (--i >= 0)
+		kfree(iadev->testTable[i]);
+	kfree(iadev->testTable);
+err_free_desc_tbl:
+	kfree(iadev->desc_tbl);
+err_free_all_tx_bufs:
+	i = iadev->num_tx_desc;
+err_free_tx_bufs:
+	while (--i >= 0) {
+		struct cpcs_trailer_desc *desc = iadev->tx_buf + i;
+
+		pci_unmap_single(iadev->pci, desc->dma_addr,
+			sizeof(*desc->cpcs), PCI_DMA_TODEVICE);
+		kfree(desc->cpcs);
+	}
+	kfree(iadev->tx_buf);
+err_free_dle:
+	pci_free_consistent(iadev->pci, DLE_TOTAL_SIZE, iadev->tx_dle_q.start,
+			    iadev->tx_dle_dma);  
+err_out:
+	return -ENOMEM;
+}   
+   
+static irqreturn_t ia_int(int irq, void *dev_id, struct pt_regs *regs)  
+{  
+   struct atm_dev *dev;  
+   IADEV *iadev;  
+   unsigned int status;  
+   int handled = 0;
+
+   dev = dev_id;  
+   iadev = INPH_IA_DEV(dev);  
+   while( (status = readl(iadev->reg+IPHASE5575_BUS_STATUS_REG) & 0x7f))  
+   { 
+	handled = 1;
+        IF_EVENT(printk("ia_int: status = 0x%x\n", status);) 
+	if (status & STAT_REASSINT)  
+	{  
+	   /* do something */  
+	   IF_EVENT(printk("REASSINT Bus status reg: %08x\n", status);) 
+	   rx_intr(dev);  
+	}  
+	if (status & STAT_DLERINT)  
+	{  
+	   /* Clear this bit by writing a 1 to it. */  
+	   *(u_int *)(iadev->reg+IPHASE5575_BUS_STATUS_REG) = STAT_DLERINT;
+	   rx_dle_intr(dev);  
+	}  
+	if (status & STAT_SEGINT)  
+	{  
+	   /* do something */ 
+           IF_EVENT(printk("IA: tx_intr \n");) 
+	   tx_intr(dev);  
+	}  
+	if (status & STAT_DLETINT)  
+	{  
+	   *(u_int *)(iadev->reg+IPHASE5575_BUS_STATUS_REG) = STAT_DLETINT;  
+	   tx_dle_intr(dev);  
+	}  
+	if (status & (STAT_FEINT | STAT_ERRINT | STAT_MARKINT))  
+	{  
+           if (status & STAT_FEINT) 
+               IaFrontEndIntr(iadev);
+	}  
+   }
+   return IRQ_RETVAL(handled);
+}  
+	  
+	  
+	  
+/*----------------------------- entries --------------------------------*/  
+static int get_esi(struct atm_dev *dev)  
+{  
+	IADEV *iadev;  
+	int i;  
+	u32 mac1;  
+	u16 mac2;  
+	  
+	iadev = INPH_IA_DEV(dev);  
+	mac1 = cpu_to_be32(le32_to_cpu(readl(  
+				iadev->reg+IPHASE5575_MAC1)));  
+	mac2 = cpu_to_be16(le16_to_cpu(readl(iadev->reg+IPHASE5575_MAC2)));  
+	IF_INIT(printk("ESI: 0x%08x%04x\n", mac1, mac2);)  
+	for (i=0; i<MAC1_LEN; i++)  
+		dev->esi[i] = mac1 >>(8*(MAC1_LEN-1-i));  
+	  
+	for (i=0; i<MAC2_LEN; i++)  
+		dev->esi[i+MAC1_LEN] = mac2 >>(8*(MAC2_LEN - 1 -i));  
+	return 0;  
+}  
+	  
+static int reset_sar(struct atm_dev *dev)  
+{  
+	IADEV *iadev;  
+	int i, error = 1;  
+	unsigned int pci[64];  
+	  
+	iadev = INPH_IA_DEV(dev);  
+	for(i=0; i<64; i++)  
+	  if ((error = pci_read_config_dword(iadev->pci,  
+				i*4, &pci[i])) != PCIBIOS_SUCCESSFUL)  
+  	      return error;  
+	writel(0, iadev->reg+IPHASE5575_EXT_RESET);  
+	for(i=0; i<64; i++)  
+	  if ((error = pci_write_config_dword(iadev->pci,  
+					i*4, pci[i])) != PCIBIOS_SUCCESSFUL)  
+	    return error;  
+	udelay(5);  
+	return 0;  
+}  
+	  
+	  
+static int __init ia_init(struct atm_dev *dev)
+{  
+	IADEV *iadev;  
+	unsigned long real_base;
+	void __iomem *base;
+	unsigned short command;  
+	unsigned char revision;  
+	int error, i; 
+	  
+	/* The device has been identified and registered. Now we read   
+	   necessary configuration info like memory base address,   
+	   interrupt number etc */  
+	  
+	IF_INIT(printk(">ia_init\n");)  
+	dev->ci_range.vpi_bits = 0;  
+	dev->ci_range.vci_bits = NR_VCI_LD;  
+
+	iadev = INPH_IA_DEV(dev);  
+	real_base = pci_resource_start (iadev->pci, 0);
+	iadev->irq = iadev->pci->irq;
+		  
+	if ((error = pci_read_config_word(iadev->pci, PCI_COMMAND,&command))   
+		    || (error = pci_read_config_byte(iadev->pci,   
+				PCI_REVISION_ID,&revision)))   
+	{  
+		printk(KERN_ERR DEV_LABEL "(itf %d): init error 0x%x\n",  
+				dev->number,error);  
+		return -EINVAL;  
+	}  
+	IF_INIT(printk(DEV_LABEL "(itf %d): rev.%d,realbase=0x%lx,irq=%d\n",  
+			dev->number, revision, real_base, iadev->irq);)  
+	  
+	/* find mapping size of board */  
+	  
+	iadev->pci_map_size = pci_resource_len(iadev->pci, 0);
+
+        if (iadev->pci_map_size == 0x100000){
+          iadev->num_vc = 4096;
+	  dev->ci_range.vci_bits = NR_VCI_4K_LD;  
+          iadev->memSize = 4;
+        }
+        else if (iadev->pci_map_size == 0x40000) {
+          iadev->num_vc = 1024;
+          iadev->memSize = 1;
+        }
+        else {
+           printk("Unknown pci_map_size = 0x%x\n", iadev->pci_map_size);
+           return -EINVAL;
+        }
+	IF_INIT(printk (DEV_LABEL "map size: %i\n", iadev->pci_map_size);)  
+	  
+	/* enable bus mastering */
+	pci_set_master(iadev->pci);
+
+	/*  
+	 * Delay at least 1us before doing any mem accesses (how 'bout 10?)  
+	 */  
+	udelay(10);  
+	  
+	/* mapping the physical address to a virtual address in address space */  
+	base = ioremap(real_base,iadev->pci_map_size);  /* ioremap is not resolved ??? */  
+	  
+	if (!base)  
+	{  
+		printk(DEV_LABEL " (itf %d): can't set up page mapping\n",  
+			    dev->number);  
+		return error;  
+	}  
+	IF_INIT(printk(DEV_LABEL " (itf %d): rev.%d,base=%p,irq=%d\n",  
+			dev->number, revision, base, iadev->irq);)  
+	  
+	/* filling the iphase dev structure */  
+	iadev->mem = iadev->pci_map_size /2;  
+	iadev->real_base = real_base;  
+	iadev->base = base;  
+		  
+	/* Bus Interface Control Registers */  
+	iadev->reg = base + REG_BASE;
+	/* Segmentation Control Registers */  
+	iadev->seg_reg = base + SEG_BASE;
+	/* Reassembly Control Registers */  
+	iadev->reass_reg = base + REASS_BASE;  
+	/* Front end/ DMA control registers */  
+	iadev->phy = base + PHY_BASE;  
+	iadev->dma = base + PHY_BASE;  
+	/* RAM - Segmentation RAm and Reassembly RAM */  
+	iadev->ram = base + ACTUAL_RAM_BASE;  
+	iadev->seg_ram = base + ACTUAL_SEG_RAM_BASE;  
+	iadev->reass_ram = base + ACTUAL_REASS_RAM_BASE;  
+  
+	/* lets print out the above */  
+	IF_INIT(printk("Base addrs: %p %p %p \n %p %p %p %p\n", 
+          iadev->reg,iadev->seg_reg,iadev->reass_reg, 
+          iadev->phy, iadev->ram, iadev->seg_ram, 
+          iadev->reass_ram);) 
+	  
+	/* lets try reading the MAC address */  
+	error = get_esi(dev);  
+	if (error) {
+	  iounmap(iadev->base);
+	  return error;  
+	}
+        printk("IA: ");
+	for (i=0; i < ESI_LEN; i++)  
+                printk("%s%02X",i ? "-" : "",dev->esi[i]);  
+        printk("\n");  
+  
+        /* reset SAR */  
+        if (reset_sar(dev)) {
+	   iounmap(iadev->base);
+           printk("IA: reset SAR fail, please try again\n");
+           return 1;
+        }
+	return 0;  
+}  
+
+static void ia_update_stats(IADEV *iadev) {
+    if (!iadev->carrier_detect)
+        return;
+    iadev->rx_cell_cnt += readw(iadev->reass_reg+CELL_CTR0)&0xffff;
+    iadev->rx_cell_cnt += (readw(iadev->reass_reg+CELL_CTR1) & 0xffff) << 16;
+    iadev->drop_rxpkt +=  readw(iadev->reass_reg + DRP_PKT_CNTR ) & 0xffff;
+    iadev->drop_rxcell += readw(iadev->reass_reg + ERR_CNTR) & 0xffff;
+    iadev->tx_cell_cnt += readw(iadev->seg_reg + CELL_CTR_LO_AUTO)&0xffff;
+    iadev->tx_cell_cnt += (readw(iadev->seg_reg+CELL_CTR_HIGH_AUTO)&0xffff)<<16;
+    return;
+}
+  
+static void ia_led_timer(unsigned long arg) {
+ 	unsigned long flags;
+  	static u_char blinking[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+        u_char i;
+        static u32 ctrl_reg; 
+        for (i = 0; i < iadev_count; i++) {
+           if (ia_dev[i]) {
+	      ctrl_reg = readl(ia_dev[i]->reg+IPHASE5575_BUS_CONTROL_REG);
+	      if (blinking[i] == 0) {
+		 blinking[i]++;
+                 ctrl_reg &= (~CTRL_LED);
+                 writel(ctrl_reg, ia_dev[i]->reg+IPHASE5575_BUS_CONTROL_REG);
+                 ia_update_stats(ia_dev[i]);
+              }
+              else {
+		 blinking[i] = 0;
+		 ctrl_reg |= CTRL_LED;
+                 writel(ctrl_reg, ia_dev[i]->reg+IPHASE5575_BUS_CONTROL_REG);
+                 spin_lock_irqsave(&ia_dev[i]->tx_lock, flags);
+                 if (ia_dev[i]->close_pending)  
+                    wake_up(&ia_dev[i]->close_wait);
+                 ia_tx_poll(ia_dev[i]);
+                 spin_unlock_irqrestore(&ia_dev[i]->tx_lock, flags);
+              }
+           }
+        }
+	mod_timer(&ia_timer, jiffies + HZ / 4);
+ 	return;
+}
+
+static void ia_phy_put(struct atm_dev *dev, unsigned char value,   
+	unsigned long addr)  
+{  
+	writel(value, INPH_IA_DEV(dev)->phy+addr);  
+}  
+  
+static unsigned char ia_phy_get(struct atm_dev *dev, unsigned long addr)  
+{  
+	return readl(INPH_IA_DEV(dev)->phy+addr);  
+}  
+
+static void ia_free_tx(IADEV *iadev)
+{
+	int i;
+
+	kfree(iadev->desc_tbl);
+	for (i = 0; i < iadev->num_vc; i++)
+		kfree(iadev->testTable[i]);
+	kfree(iadev->testTable);
+	for (i = 0; i < iadev->num_tx_desc; i++) {
+		struct cpcs_trailer_desc *desc = iadev->tx_buf + i;
+
+		pci_unmap_single(iadev->pci, desc->dma_addr,
+			sizeof(*desc->cpcs), PCI_DMA_TODEVICE);
+		kfree(desc->cpcs);
+	}
+	kfree(iadev->tx_buf);
+	pci_free_consistent(iadev->pci, DLE_TOTAL_SIZE, iadev->tx_dle_q.start,
+			    iadev->tx_dle_dma);  
+}
+
+static void ia_free_rx(IADEV *iadev)
+{
+	kfree(iadev->rx_open);
+	pci_free_consistent(iadev->pci, DLE_TOTAL_SIZE, iadev->rx_dle_q.start,
+			  iadev->rx_dle_dma);  
+}
+
+static int __init ia_start(struct atm_dev *dev)
+{  
+	IADEV *iadev;  
+	int error;  
+	unsigned char phy;  
+	u32 ctrl_reg;  
+	IF_EVENT(printk(">ia_start\n");)  
+	iadev = INPH_IA_DEV(dev);  
+        if (request_irq(iadev->irq, &ia_int, SA_SHIRQ, DEV_LABEL, dev)) {  
+                printk(KERN_ERR DEV_LABEL "(itf %d): IRQ%d is already in use\n",  
+                    dev->number, iadev->irq);  
+		error = -EAGAIN;
+		goto err_out;
+        }  
+        /* @@@ should release IRQ on error */  
+	/* enabling memory + master */  
+        if ((error = pci_write_config_word(iadev->pci,   
+				PCI_COMMAND,   
+				PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER )))   
+	{  
+                printk(KERN_ERR DEV_LABEL "(itf %d): can't enable memory+"  
+                    "master (0x%x)\n",dev->number, error);  
+		error = -EIO;  
+		goto err_free_irq;
+        }  
+	udelay(10);  
+  
+	/* Maybe we should reset the front end, initialize Bus Interface Control   
+		Registers and see. */  
+  
+	IF_INIT(printk("Bus ctrl reg: %08x\n", 
+                            readl(iadev->reg+IPHASE5575_BUS_CONTROL_REG));)  
+	ctrl_reg = readl(iadev->reg+IPHASE5575_BUS_CONTROL_REG);  
+	ctrl_reg = (ctrl_reg & (CTRL_LED | CTRL_FE_RST))  
+			| CTRL_B8  
+			| CTRL_B16  
+			| CTRL_B32  
+			| CTRL_B48  
+			| CTRL_B64  
+			| CTRL_B128  
+			| CTRL_ERRMASK  
+			| CTRL_DLETMASK		/* shud be removed l8r */  
+			| CTRL_DLERMASK  
+			| CTRL_SEGMASK  
+			| CTRL_REASSMASK 	  
+			| CTRL_FEMASK  
+			| CTRL_CSPREEMPT;  
+  
+       writel(ctrl_reg, iadev->reg+IPHASE5575_BUS_CONTROL_REG);   
+  
+	IF_INIT(printk("Bus ctrl reg after initializing: %08x\n", 
+                           readl(iadev->reg+IPHASE5575_BUS_CONTROL_REG));  
+	   printk("Bus status reg after init: %08x\n", 
+                            readl(iadev->reg+IPHASE5575_BUS_STATUS_REG));)  
+    
+        ia_hw_type(iadev); 
+	error = tx_init(dev);  
+	if (error)
+		goto err_free_irq;
+	error = rx_init(dev);  
+	if (error)
+		goto err_free_tx;
+  
+	ctrl_reg = readl(iadev->reg+IPHASE5575_BUS_CONTROL_REG);  
+       	writel(ctrl_reg | CTRL_FE_RST, iadev->reg+IPHASE5575_BUS_CONTROL_REG);   
+	IF_INIT(printk("Bus ctrl reg after initializing: %08x\n", 
+                               readl(iadev->reg+IPHASE5575_BUS_CONTROL_REG));)  
+        phy = 0; /* resolve compiler complaint */
+        IF_INIT ( 
+	if ((phy=ia_phy_get(dev,0)) == 0x30)  
+		printk("IA: pm5346,rev.%d\n",phy&0x0f);  
+	else  
+		printk("IA: utopia,rev.%0x\n",phy);) 
+
+	if (iadev->phy_type &  FE_25MBIT_PHY)
+           ia_mb25_init(iadev);
+	else if (iadev->phy_type & (FE_DS3_PHY | FE_E3_PHY))
+           ia_suni_pm7345_init(iadev);
+	else {
+		error = suni_init(dev);
+		if (error)
+			goto err_free_rx;
+		/* 
+		 * Enable interrupt on loss of signal
+		 * SUNI_RSOP_CIE - 0x10
+		 * SUNI_RSOP_CIE_LOSE - 0x04
+		 */
+		ia_phy_put(dev, ia_phy_get(dev, 0x10) | 0x04, 0x10);
+#ifndef MODULE
+		error = dev->phy->start(dev);
+		if (error)
+			goto err_free_rx;
+#endif
+		/* Get iadev->carrier_detect status */
+		IaFrontEndIntr(iadev);
+	}
+	return 0;
+
+err_free_rx:
+	ia_free_rx(iadev);
+err_free_tx:
+	ia_free_tx(iadev);
+err_free_irq:
+	free_irq(iadev->irq, dev);  
+err_out:
+	return error;
+}  
+  
+static void ia_close(struct atm_vcc *vcc)  
+{
+	DEFINE_WAIT(wait);
+        u16 *vc_table;
+        IADEV *iadev;
+        struct ia_vcc *ia_vcc;
+        struct sk_buff *skb = NULL;
+        struct sk_buff_head tmp_tx_backlog, tmp_vcc_backlog;
+        unsigned long closetime, flags;
+
+        iadev = INPH_IA_DEV(vcc->dev);
+        ia_vcc = INPH_IA_VCC(vcc);
+	if (!ia_vcc) return;  
+
+        IF_EVENT(printk("ia_close: ia_vcc->vc_desc_cnt = %d  vci = %d\n", 
+                                              ia_vcc->vc_desc_cnt,vcc->vci);)
+	clear_bit(ATM_VF_READY,&vcc->flags);
+        skb_queue_head_init (&tmp_tx_backlog);
+        skb_queue_head_init (&tmp_vcc_backlog); 
+        if (vcc->qos.txtp.traffic_class != ATM_NONE) {
+           iadev->close_pending++;
+	   prepare_to_wait(&iadev->timeout_wait, &wait, TASK_UNINTERRUPTIBLE);
+	   schedule_timeout(50);
+	   finish_wait(&iadev->timeout_wait, &wait);
+           spin_lock_irqsave(&iadev->tx_lock, flags); 
+           while((skb = skb_dequeue(&iadev->tx_backlog))) {
+              if (ATM_SKB(skb)->vcc == vcc){ 
+                 if (vcc->pop) vcc->pop(vcc, skb);
+                 else dev_kfree_skb_any(skb);
+              }
+              else 
+                 skb_queue_tail(&tmp_tx_backlog, skb);
+           } 
+           while((skb = skb_dequeue(&tmp_tx_backlog))) 
+             skb_queue_tail(&iadev->tx_backlog, skb);
+           IF_EVENT(printk("IA TX Done decs_cnt = %d\n", ia_vcc->vc_desc_cnt);) 
+           closetime = 300000 / ia_vcc->pcr;
+           if (closetime == 0)
+              closetime = 1;
+           spin_unlock_irqrestore(&iadev->tx_lock, flags);
+           wait_event_timeout(iadev->close_wait, (ia_vcc->vc_desc_cnt <= 0), closetime);
+           spin_lock_irqsave(&iadev->tx_lock, flags);
+           iadev->close_pending--;
+           iadev->testTable[vcc->vci]->lastTime = 0;
+           iadev->testTable[vcc->vci]->fract = 0; 
+           iadev->testTable[vcc->vci]->vc_status = VC_UBR; 
+           if (vcc->qos.txtp.traffic_class == ATM_ABR) {
+              if (vcc->qos.txtp.min_pcr > 0)
+                 iadev->sum_mcr -= vcc->qos.txtp.min_pcr;
+           }
+           if (vcc->qos.txtp.traffic_class == ATM_CBR) {
+              ia_vcc = INPH_IA_VCC(vcc); 
+              iadev->sum_mcr -= ia_vcc->NumCbrEntry*iadev->Granularity;
+              ia_cbrVc_close (vcc);
+           }
+           spin_unlock_irqrestore(&iadev->tx_lock, flags);
+        }
+        
+        if (vcc->qos.rxtp.traffic_class != ATM_NONE) {   
+           // reset reass table
+           vc_table = (u16 *)(iadev->reass_ram+REASS_TABLE*iadev->memSize);
+           vc_table += vcc->vci; 
+           *vc_table = NO_AAL5_PKT;
+           // reset vc table
+           vc_table = (u16 *)(iadev->reass_ram+RX_VC_TABLE*iadev->memSize);
+           vc_table += vcc->vci;
+           *vc_table = (vcc->vci << 6) | 15;
+           if (vcc->qos.rxtp.traffic_class == ATM_ABR) {
+              struct abr_vc_table __iomem *abr_vc_table = 
+                                (iadev->reass_ram+ABR_VC_TABLE*iadev->memSize);
+              abr_vc_table +=  vcc->vci;
+              abr_vc_table->rdf = 0x0003;
+              abr_vc_table->air = 0x5eb1;
+           }                                 
+           // Drain the packets
+           rx_dle_intr(vcc->dev); 
+           iadev->rx_open[vcc->vci] = NULL;
+        }
+	kfree(INPH_IA_VCC(vcc));  
+        ia_vcc = NULL;
+        vcc->dev_data = NULL;
+        clear_bit(ATM_VF_ADDR,&vcc->flags);
+        return;        
+}  
+  
+static int ia_open(struct atm_vcc *vcc)
+{  
+	IADEV *iadev;  
+	struct ia_vcc *ia_vcc;  
+	int error;  
+	if (!test_bit(ATM_VF_PARTIAL,&vcc->flags))  
+	{  
+		IF_EVENT(printk("ia: not partially allocated resources\n");)  
+		vcc->dev_data = NULL;
+	}  
+	iadev = INPH_IA_DEV(vcc->dev);  
+	if (vcc->vci != ATM_VPI_UNSPEC && vcc->vpi != ATM_VCI_UNSPEC)  
+	{  
+		IF_EVENT(printk("iphase open: unspec part\n");)  
+		set_bit(ATM_VF_ADDR,&vcc->flags);
+	}  
+	if (vcc->qos.aal != ATM_AAL5)  
+		return -EINVAL;  
+	IF_EVENT(printk(DEV_LABEL "(itf %d): open %d.%d\n", 
+                                 vcc->dev->number, vcc->vpi, vcc->vci);)  
+  
+	/* Device dependent initialization */  
+	ia_vcc = kmalloc(sizeof(*ia_vcc), GFP_KERNEL);  
+	if (!ia_vcc) return -ENOMEM;  
+	vcc->dev_data = ia_vcc;
+  
+	if ((error = open_rx(vcc)))  
+	{  
+		IF_EVENT(printk("iadev: error in open_rx, closing\n");)  
+		ia_close(vcc);  
+		return error;  
+	}  
+  
+	if ((error = open_tx(vcc)))  
+	{  
+		IF_EVENT(printk("iadev: error in open_tx, closing\n");)  
+		ia_close(vcc);  
+		return error;  
+	}  
+  
+	set_bit(ATM_VF_READY,&vcc->flags);
+
+#if 0
+        {
+           static u8 first = 1; 
+           if (first) {
+              ia_timer.expires = jiffies + 3*HZ;
+              add_timer(&ia_timer);
+              first = 0;
+           }           
+        }
+#endif
+	IF_EVENT(printk("ia open returning\n");)  
+	return 0;  
+}  
+  
+static int ia_change_qos(struct atm_vcc *vcc, struct atm_qos *qos, int flags)  
+{  
+	IF_EVENT(printk(">ia_change_qos\n");)  
+	return 0;  
+}  
+  
+static int ia_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)  
+{  
+   IA_CMDBUF ia_cmds;
+   IADEV *iadev;
+   int i, board;
+   u16 __user *tmps;
+   IF_EVENT(printk(">ia_ioctl\n");)  
+   if (cmd != IA_CMD) {
+      if (!dev->phy->ioctl) return -EINVAL;
+      return dev->phy->ioctl(dev,cmd,arg);
+   }
+   if (copy_from_user(&ia_cmds, arg, sizeof ia_cmds)) return -EFAULT; 
+   board = ia_cmds.status;
+   if ((board < 0) || (board > iadev_count))
+         board = 0;    
+   iadev = ia_dev[board];
+   switch (ia_cmds.cmd) {
+   case MEMDUMP:
+   {
+	switch (ia_cmds.sub_cmd) {
+       	  case MEMDUMP_DEV:     
+	     if (!capable(CAP_NET_ADMIN)) return -EPERM;
+	     if (copy_to_user(ia_cmds.buf, iadev, sizeof(IADEV)))
+                return -EFAULT;
+             ia_cmds.status = 0;
+             break;
+          case MEMDUMP_SEGREG:
+	     if (!capable(CAP_NET_ADMIN)) return -EPERM;
+             tmps = (u16 __user *)ia_cmds.buf;
+             for(i=0; i<0x80; i+=2, tmps++)
+                if(put_user((u16)(readl(iadev->seg_reg+i) & 0xffff), tmps)) return -EFAULT;
+             ia_cmds.status = 0;
+             ia_cmds.len = 0x80;
+             break;
+          case MEMDUMP_REASSREG:
+	     if (!capable(CAP_NET_ADMIN)) return -EPERM;
+             tmps = (u16 __user *)ia_cmds.buf;
+             for(i=0; i<0x80; i+=2, tmps++)
+                if(put_user((u16)(readl(iadev->reass_reg+i) & 0xffff), tmps)) return -EFAULT;
+             ia_cmds.status = 0;
+             ia_cmds.len = 0x80;
+             break;
+          case MEMDUMP_FFL:
+          {  
+             ia_regs_t       *regs_local;
+             ffredn_t        *ffL;
+             rfredn_t        *rfL;
+                     
+	     if (!capable(CAP_NET_ADMIN)) return -EPERM;
+	     regs_local = kmalloc(sizeof(*regs_local), GFP_KERNEL);
+	     if (!regs_local) return -ENOMEM;
+	     ffL = &regs_local->ffredn;
+	     rfL = &regs_local->rfredn;
+             /* Copy real rfred registers into the local copy */
+ 	     for (i=0; i<(sizeof (rfredn_t))/4; i++)
+                ((u_int *)rfL)[i] = readl(iadev->reass_reg + i) & 0xffff;
+             	/* Copy real ffred registers into the local copy */
+	     for (i=0; i<(sizeof (ffredn_t))/4; i++)
+                ((u_int *)ffL)[i] = readl(iadev->seg_reg + i) & 0xffff;
+
+             if (copy_to_user(ia_cmds.buf, regs_local,sizeof(ia_regs_t))) {
+                kfree(regs_local);
+                return -EFAULT;
+             }
+             kfree(regs_local);
+             printk("Board %d registers dumped\n", board);
+             ia_cmds.status = 0;                  
+	 }	
+    	     break;        
+         case READ_REG:
+         {  
+	     if (!capable(CAP_NET_ADMIN)) return -EPERM;
+             desc_dbg(iadev); 
+             ia_cmds.status = 0; 
+         }
+             break;
+         case 0x6:
+         {  
+             ia_cmds.status = 0; 
+             printk("skb = 0x%lx\n", (long)skb_peek(&iadev->tx_backlog));
+             printk("rtn_q: 0x%lx\n",(long)ia_deque_rtn_q(&iadev->tx_return_q));
+         }
+             break;
+         case 0x8:
+         {
+             struct k_sonet_stats *stats;
+             stats = &PRIV(_ia_dev[board])->sonet_stats;
+             printk("section_bip: %d\n", atomic_read(&stats->section_bip));
+             printk("line_bip   : %d\n", atomic_read(&stats->line_bip));
+             printk("path_bip   : %d\n", atomic_read(&stats->path_bip));
+             printk("line_febe  : %d\n", atomic_read(&stats->line_febe));
+             printk("path_febe  : %d\n", atomic_read(&stats->path_febe));
+             printk("corr_hcs   : %d\n", atomic_read(&stats->corr_hcs));
+             printk("uncorr_hcs : %d\n", atomic_read(&stats->uncorr_hcs));
+             printk("tx_cells   : %d\n", atomic_read(&stats->tx_cells));
+             printk("rx_cells   : %d\n", atomic_read(&stats->rx_cells));
+         }
+            ia_cmds.status = 0;
+            break;
+         case 0x9:
+	    if (!capable(CAP_NET_ADMIN)) return -EPERM;
+            for (i = 1; i <= iadev->num_rx_desc; i++)
+               free_desc(_ia_dev[board], i);
+            writew( ~(RX_FREEQ_EMPT | RX_EXCP_RCVD), 
+                                            iadev->reass_reg+REASS_MASK_REG);
+            iadev->rxing = 1;
+            
+            ia_cmds.status = 0;
+            break;
+
+         case 0xb:
+	    if (!capable(CAP_NET_ADMIN)) return -EPERM;
+            IaFrontEndIntr(iadev);
+            break;
+         case 0xa:
+	    if (!capable(CAP_NET_ADMIN)) return -EPERM;
+         {  
+             ia_cmds.status = 0; 
+             IADebugFlag = ia_cmds.maddr;
+             printk("New debug option loaded\n");
+         }
+             break;
+         default:
+             ia_cmds.status = 0;
+             break;
+      }	
+   }
+      break;
+   default:
+      break;
+
+   }	
+   return 0;  
+}  
+  
+static int ia_getsockopt(struct atm_vcc *vcc, int level, int optname,   
+	void __user *optval, int optlen)  
+{  
+	IF_EVENT(printk(">ia_getsockopt\n");)  
+	return -EINVAL;  
+}  
+  
+static int ia_setsockopt(struct atm_vcc *vcc, int level, int optname,   
+	void __user *optval, int optlen)  
+{  
+	IF_EVENT(printk(">ia_setsockopt\n");)  
+	return -EINVAL;  
+}  
+  
+static int ia_pkt_tx (struct atm_vcc *vcc, struct sk_buff *skb) {
+        IADEV *iadev;
+        struct dle *wr_ptr;
+        struct tx_buf_desc __iomem *buf_desc_ptr;
+        int desc;
+        int comp_code;
+        int total_len;
+        struct cpcs_trailer *trailer;
+        struct ia_vcc *iavcc;
+
+        iadev = INPH_IA_DEV(vcc->dev);  
+        iavcc = INPH_IA_VCC(vcc);
+        if (!iavcc->txing) {
+           printk("discard packet on closed VC\n");
+           if (vcc->pop)
+		vcc->pop(vcc, skb);
+           else
+		dev_kfree_skb_any(skb);
+	   return 0;
+        }
+
+        if (skb->len > iadev->tx_buf_sz - 8) {
+           printk("Transmit size over tx buffer size\n");
+           if (vcc->pop)
+                 vcc->pop(vcc, skb);
+           else
+                 dev_kfree_skb_any(skb);
+          return 0;
+        }
+        if ((u32)skb->data & 3) {
+           printk("Misaligned SKB\n");
+           if (vcc->pop)
+                 vcc->pop(vcc, skb);
+           else
+                 dev_kfree_skb_any(skb);
+           return 0;
+        }       
+	/* Get a descriptor number from our free descriptor queue  
+	   We get the descr number from the TCQ now, since I am using  
+	   the TCQ as a free buffer queue. Initially TCQ will be   
+	   initialized with all the descriptors and is hence, full.  
+	*/
+	desc = get_desc (iadev, iavcc);
+	if (desc == 0xffff) 
+	    return 1;
+	comp_code = desc >> 13;  
+	desc &= 0x1fff;  
+  
+	if ((desc == 0) || (desc > iadev->num_tx_desc))  
+	{  
+		IF_ERR(printk(DEV_LABEL "invalid desc for send: %d\n", desc);) 
+                atomic_inc(&vcc->stats->tx);
+		if (vcc->pop)   
+		    vcc->pop(vcc, skb);   
+		else  
+		    dev_kfree_skb_any(skb);
+		return 0;   /* return SUCCESS */
+	}  
+  
+	if (comp_code)  
+	{  
+	    IF_ERR(printk(DEV_LABEL "send desc:%d completion code %d error\n", 
+                                                            desc, comp_code);)  
+	}  
+       
+        /* remember the desc and vcc mapping */
+        iavcc->vc_desc_cnt++;
+        iadev->desc_tbl[desc-1].iavcc = iavcc;
+        iadev->desc_tbl[desc-1].txskb = skb;
+        IA_SKB_STATE(skb) = 0;
+
+        iadev->ffL.tcq_rd += 2;
+        if (iadev->ffL.tcq_rd > iadev->ffL.tcq_ed)
+	  	iadev->ffL.tcq_rd  = iadev->ffL.tcq_st;
+	writew(iadev->ffL.tcq_rd, iadev->seg_reg+TCQ_RD_PTR);
+  
+	/* Put the descriptor number in the packet ready queue  
+		and put the updated write pointer in the DLE field   
+	*/   
+	*(u16*)(iadev->seg_ram+iadev->ffL.prq_wr) = desc; 
+
+ 	iadev->ffL.prq_wr += 2;
+        if (iadev->ffL.prq_wr > iadev->ffL.prq_ed)
+                iadev->ffL.prq_wr = iadev->ffL.prq_st;
+	  
+	/* Figure out the exact length of the packet and padding required to 
+           make it  aligned on a 48 byte boundary.  */
+	total_len = skb->len + sizeof(struct cpcs_trailer);  
+	total_len = ((total_len + 47) / 48) * 48;
+	IF_TX(printk("ia packet len:%d padding:%d\n", total_len, total_len - skb->len);)  
+ 
+	/* Put the packet in a tx buffer */   
+	trailer = iadev->tx_buf[desc-1].cpcs;
+        IF_TX(printk("Sent: skb = 0x%x skb->data: 0x%x len: %d, desc: %d\n",
+                  (u32)skb, (u32)skb->data, skb->len, desc);)
+	trailer->control = 0; 
+        /*big endian*/ 
+	trailer->length = ((skb->len & 0xff) << 8) | ((skb->len & 0xff00) >> 8);
+	trailer->crc32 = 0;	/* not needed - dummy bytes */  
+
+	/* Display the packet */  
+	IF_TXPKT(printk("Sent data: len = %d MsgNum = %d\n", 
+                                                        skb->len, tcnter++);  
+        xdump(skb->data, skb->len, "TX: ");
+        printk("\n");)
+
+	/* Build the buffer descriptor */  
+	buf_desc_ptr = iadev->seg_ram+TX_DESC_BASE;
+	buf_desc_ptr += desc;	/* points to the corresponding entry */  
+	buf_desc_ptr->desc_mode = AAL5 | EOM_EN | APP_CRC32 | CMPL_INT;   
+	/* Huh ? p.115 of users guide describes this as a read-only register */
+        writew(TRANSMIT_DONE, iadev->seg_reg+SEG_INTR_STATUS_REG);
+	buf_desc_ptr->vc_index = vcc->vci;
+	buf_desc_ptr->bytes = total_len;  
+
+        if (vcc->qos.txtp.traffic_class == ATM_ABR)  
+	   clear_lockup (vcc, iadev);
+
+	/* Build the DLE structure */  
+	wr_ptr = iadev->tx_dle_q.write;  
+	memset((caddr_t)wr_ptr, 0, sizeof(*wr_ptr));  
+	wr_ptr->sys_pkt_addr = pci_map_single(iadev->pci, skb->data,
+		skb->len, PCI_DMA_TODEVICE);
+	wr_ptr->local_pkt_addr = (buf_desc_ptr->buf_start_hi << 16) | 
+                                                  buf_desc_ptr->buf_start_lo;  
+	/* wr_ptr->bytes = swap(total_len);	didn't seem to affect ?? */  
+	wr_ptr->bytes = skb->len;  
+
+        /* hw bug - DLEs of 0x2d, 0x2e, 0x2f cause DMA lockup */
+        if ((wr_ptr->bytes >> 2) == 0xb)
+           wr_ptr->bytes = 0x30;
+
+	wr_ptr->mode = TX_DLE_PSI; 
+	wr_ptr->prq_wr_ptr_data = 0;
+  
+	/* end is not to be used for the DLE q */  
+	if (++wr_ptr == iadev->tx_dle_q.end)  
+		wr_ptr = iadev->tx_dle_q.start;  
+        
+        /* Build trailer dle */
+        wr_ptr->sys_pkt_addr = iadev->tx_buf[desc-1].dma_addr;
+        wr_ptr->local_pkt_addr = ((buf_desc_ptr->buf_start_hi << 16) | 
+          buf_desc_ptr->buf_start_lo) + total_len - sizeof(struct cpcs_trailer);
+
+        wr_ptr->bytes = sizeof(struct cpcs_trailer);
+        wr_ptr->mode = DMA_INT_ENABLE; 
+        wr_ptr->prq_wr_ptr_data = iadev->ffL.prq_wr;
+        
+        /* end is not to be used for the DLE q */
+        if (++wr_ptr == iadev->tx_dle_q.end)  
+                wr_ptr = iadev->tx_dle_q.start;
+
+	iadev->tx_dle_q.write = wr_ptr;  
+        ATM_DESC(skb) = vcc->vci;
+        skb_queue_tail(&iadev->tx_dma_q, skb);
+
+        atomic_inc(&vcc->stats->tx);
+        iadev->tx_pkt_cnt++;
+	/* Increment transaction counter */  
+	writel(2, iadev->dma+IPHASE5575_TX_COUNTER);  
+        
+#if 0        
+        /* add flow control logic */ 
+        if (atomic_read(&vcc->stats->tx) % 20 == 0) {
+          if (iavcc->vc_desc_cnt > 10) {
+             vcc->tx_quota =  vcc->tx_quota * 3 / 4;
+            printk("Tx1:  vcc->tx_quota = %d \n", (u32)vcc->tx_quota );
+              iavcc->flow_inc = -1;
+              iavcc->saved_tx_quota = vcc->tx_quota;
+           } else if ((iavcc->flow_inc < 0) && (iavcc->vc_desc_cnt < 3)) {
+             // vcc->tx_quota = 3 * iavcc->saved_tx_quota / 4;
+             printk("Tx2:  vcc->tx_quota = %d \n", (u32)vcc->tx_quota ); 
+              iavcc->flow_inc = 0;
+           }
+        }
+#endif
+	IF_TX(printk("ia send done\n");)  
+	return 0;  
+}  
+
+static int ia_send(struct atm_vcc *vcc, struct sk_buff *skb)
+{
+        IADEV *iadev; 
+        struct ia_vcc *iavcc;
+        unsigned long flags;
+
+        iadev = INPH_IA_DEV(vcc->dev);
+        iavcc = INPH_IA_VCC(vcc); 
+        if ((!skb)||(skb->len>(iadev->tx_buf_sz-sizeof(struct cpcs_trailer))))
+        {
+            if (!skb)
+                printk(KERN_CRIT "null skb in ia_send\n");
+            else dev_kfree_skb_any(skb);
+            return -EINVAL;
+        }                         
+        spin_lock_irqsave(&iadev->tx_lock, flags); 
+        if (!test_bit(ATM_VF_READY,&vcc->flags)){ 
+            dev_kfree_skb_any(skb);
+            spin_unlock_irqrestore(&iadev->tx_lock, flags);
+            return -EINVAL; 
+        }
+        ATM_SKB(skb)->vcc = vcc;
+ 
+        if (skb_peek(&iadev->tx_backlog)) {
+           skb_queue_tail(&iadev->tx_backlog, skb);
+        }
+        else {
+           if (ia_pkt_tx (vcc, skb)) {
+              skb_queue_tail(&iadev->tx_backlog, skb);
+           }
+        }
+        spin_unlock_irqrestore(&iadev->tx_lock, flags);
+        return 0;
+
+}
+
+static int ia_proc_read(struct atm_dev *dev,loff_t *pos,char *page)
+{ 
+  int   left = *pos, n;   
+  char  *tmpPtr;
+  IADEV *iadev = INPH_IA_DEV(dev);
+  if(!left--) {
+     if (iadev->phy_type == FE_25MBIT_PHY) {
+       n = sprintf(page, "  Board Type         :  Iphase5525-1KVC-128K\n");
+       return n;
+     }
+     if (iadev->phy_type == FE_DS3_PHY)
+        n = sprintf(page, "  Board Type         :  Iphase-ATM-DS3");
+     else if (iadev->phy_type == FE_E3_PHY)
+        n = sprintf(page, "  Board Type         :  Iphase-ATM-E3");
+     else if (iadev->phy_type == FE_UTP_OPTION)
+         n = sprintf(page, "  Board Type         :  Iphase-ATM-UTP155"); 
+     else
+        n = sprintf(page, "  Board Type         :  Iphase-ATM-OC3");
+     tmpPtr = page + n;
+     if (iadev->pci_map_size == 0x40000)
+        n += sprintf(tmpPtr, "-1KVC-");
+     else
+        n += sprintf(tmpPtr, "-4KVC-");  
+     tmpPtr = page + n; 
+     if ((iadev->memType & MEM_SIZE_MASK) == MEM_SIZE_1M)
+        n += sprintf(tmpPtr, "1M  \n");
+     else if ((iadev->memType & MEM_SIZE_MASK) == MEM_SIZE_512K)
+        n += sprintf(tmpPtr, "512K\n");
+     else
+       n += sprintf(tmpPtr, "128K\n");
+     return n;
+  }
+  if (!left) {
+     return  sprintf(page, "  Number of Tx Buffer:  %u\n"
+                           "  Size of Tx Buffer  :  %u\n"
+                           "  Number of Rx Buffer:  %u\n"
+                           "  Size of Rx Buffer  :  %u\n"
+                           "  Packets Receiverd  :  %u\n"
+                           "  Packets Transmitted:  %u\n"
+                           "  Cells Received     :  %u\n"
+                           "  Cells Transmitted  :  %u\n"
+                           "  Board Dropped Cells:  %u\n"
+                           "  Board Dropped Pkts :  %u\n",
+                           iadev->num_tx_desc,  iadev->tx_buf_sz,
+                           iadev->num_rx_desc,  iadev->rx_buf_sz,
+                           iadev->rx_pkt_cnt,   iadev->tx_pkt_cnt,
+                           iadev->rx_cell_cnt, iadev->tx_cell_cnt,
+                           iadev->drop_rxcell, iadev->drop_rxpkt);                        
+  }
+  return 0;
+}
+  
+static const struct atmdev_ops ops = {  
+	.open		= ia_open,  
+	.close		= ia_close,  
+	.ioctl		= ia_ioctl,  
+	.getsockopt	= ia_getsockopt,  
+	.setsockopt	= ia_setsockopt,  
+	.send		= ia_send,  
+	.phy_put	= ia_phy_put,  
+	.phy_get	= ia_phy_get,  
+	.change_qos	= ia_change_qos,  
+	.proc_read	= ia_proc_read,
+	.owner		= THIS_MODULE,
+};  
+	  
+static int __devinit ia_init_one(struct pci_dev *pdev,
+				 const struct pci_device_id *ent)
+{  
+	struct atm_dev *dev;  
+	IADEV *iadev;  
+        unsigned long flags;
+	int ret;
+
+	iadev = kmalloc(sizeof(*iadev), GFP_KERNEL); 
+	if (!iadev) {
+		ret = -ENOMEM;
+		goto err_out;
+	}
+	memset(iadev, 0, sizeof(*iadev));
+	iadev->pci = pdev;
+
+	IF_INIT(printk("ia detected at bus:%d dev: %d function:%d\n",
+		pdev->bus->number, PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));)
+	if (pci_enable_device(pdev)) {
+		ret = -ENODEV;
+		goto err_out_free_iadev;
+	}
+	dev = atm_dev_register(DEV_LABEL, &ops, -1, NULL);
+	if (!dev) {
+		ret = -ENOMEM;
+		goto err_out_disable_dev;
+	}
+	dev->dev_data = iadev;
+	IF_INIT(printk(DEV_LABEL "registered at (itf :%d)\n", dev->number);)
+	IF_INIT(printk("dev_id = 0x%x iadev->LineRate = %d \n", (u32)dev,
+		iadev->LineRate);)
+
+	ia_dev[iadev_count] = iadev;
+	_ia_dev[iadev_count] = dev;
+	iadev_count++;
+	spin_lock_init(&iadev->misc_lock);
+	/* First fixes first. I don't want to think about this now. */
+	spin_lock_irqsave(&iadev->misc_lock, flags); 
+	if (ia_init(dev) || ia_start(dev)) {  
+		IF_INIT(printk("IA register failed!\n");)
+		iadev_count--;
+		ia_dev[iadev_count] = NULL;
+		_ia_dev[iadev_count] = NULL;
+		spin_unlock_irqrestore(&iadev->misc_lock, flags); 
+		ret = -EINVAL;
+		goto err_out_deregister_dev;
+	}
+	spin_unlock_irqrestore(&iadev->misc_lock, flags); 
+	IF_EVENT(printk("iadev_count = %d\n", iadev_count);)
+
+	iadev->next_board = ia_boards;  
+	ia_boards = dev;  
+
+	pci_set_drvdata(pdev, dev);
+
+	return 0;
+
+err_out_deregister_dev:
+	atm_dev_deregister(dev);  
+err_out_disable_dev:
+	pci_disable_device(pdev);
+err_out_free_iadev:
+	kfree(iadev);
+err_out:
+	return ret;
+}
+
+static void __devexit ia_remove_one(struct pci_dev *pdev)
+{
+	struct atm_dev *dev = pci_get_drvdata(pdev);
+	IADEV *iadev = INPH_IA_DEV(dev);
+
+	ia_phy_put(dev, ia_phy_get(dev,0x10) & ~(0x4), 0x10); 
+	udelay(1);
+
+	/* De-register device */  
+      	free_irq(iadev->irq, dev);
+	iadev_count--;
+	ia_dev[iadev_count] = NULL;
+	_ia_dev[iadev_count] = NULL;
+	IF_EVENT(printk("deregistering iav at (itf:%d)\n", dev->number);)
+	atm_dev_deregister(dev);
+
+      	iounmap(iadev->base);  
+	pci_disable_device(pdev);
+
+	ia_free_rx(iadev);
+	ia_free_tx(iadev);
+
+      	kfree(iadev);
+}
+
+static struct pci_device_id ia_pci_tbl[] = {
+	{ PCI_VENDOR_ID_IPHASE, 0x0008, PCI_ANY_ID, PCI_ANY_ID, },
+	{ PCI_VENDOR_ID_IPHASE, 0x0009, PCI_ANY_ID, PCI_ANY_ID, },
+	{ 0,}
+};
+MODULE_DEVICE_TABLE(pci, ia_pci_tbl);
+
+static struct pci_driver ia_driver = {
+	.name =         DEV_LABEL,
+	.id_table =     ia_pci_tbl,
+	.probe =        ia_init_one,
+	.remove =       __devexit_p(ia_remove_one),
+};
+
+static int __init ia_module_init(void)
+{
+	int ret;
+
+	ret = pci_register_driver(&ia_driver);
+	if (ret >= 0) {
+		ia_timer.expires = jiffies + 3*HZ;
+		add_timer(&ia_timer); 
+	} else
+		printk(KERN_ERR DEV_LABEL ": no adapter found\n");  
+	return ret;
+}
+
+static void __exit ia_module_exit(void)
+{
+	pci_unregister_driver(&ia_driver);
+
+        del_timer(&ia_timer);
+}
+
+module_init(ia_module_init);
+module_exit(ia_module_exit);
