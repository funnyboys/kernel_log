commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/atm/nicstar.h b/drivers/atm/nicstar.h
index 9bc27ea5088e..1b7f1dfc1735 100644
--- a/drivers/atm/nicstar.h
+++ b/drivers/atm/nicstar.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * nicstar.h
  *

commit 864a3ff635fa73dae15455524e048da5c89352ac
Author: chas williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
Date:   Sat May 29 09:04:25 2010 +0000

    atm: [nicstar] remove virt_to_bus() and support 64-bit platforms
    
    Signed-off-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.h b/drivers/atm/nicstar.h
index 43eb2db1fb88..9bc27ea5088e 100644
--- a/drivers/atm/nicstar.h
+++ b/drivers/atm/nicstar.h
@@ -16,6 +16,7 @@
 
 #include <linux/types.h>
 #include <linux/pci.h>
+#include <linux/idr.h>
 #include <linux/uio.h>
 #include <linux/skbuff.h>
 #include <linux/atmdev.h>
@@ -636,14 +637,22 @@ enum ns_regs {
 
 /* Device driver structures */
 
-struct ns_skb_cb {
+struct ns_skb_prv {
 	u32 buf_type;		/* BUF_SM/BUF_LG/BUF_NONE */
+	u32 dma;
+	int iovcnt;
 };
 
-#define NS_SKB_CB(skb)	((struct ns_skb_cb *)((skb)->cb))
+#define NS_PRV_BUFTYPE(skb)   \
+        (((struct ns_skb_prv *)(ATM_SKB(skb)+1))->buf_type)
+#define NS_PRV_DMA(skb) \
+        (((struct ns_skb_prv *)(ATM_SKB(skb)+1))->dma)
+#define NS_PRV_IOVCNT(skb) \
+        (((struct ns_skb_prv *)(ATM_SKB(skb)+1))->iovcnt)
 
 typedef struct tsq_info {
 	void *org;
+        dma_addr_t dma;
 	ns_tsi *base;
 	ns_tsi *next;
 	ns_tsi *last;
@@ -651,6 +660,7 @@ typedef struct tsq_info {
 
 typedef struct scq_info {
 	void *org;
+	dma_addr_t dma;
 	ns_scqe *base;
 	ns_scqe *last;
 	ns_scqe *next;
@@ -668,6 +678,7 @@ typedef struct scq_info {
 
 typedef struct rsq_info {
 	void *org;
+        dma_addr_t dma;
 	ns_rsqe *base;
 	ns_rsqe *next;
 	ns_rsqe *last;
@@ -693,13 +704,6 @@ typedef struct vc_map {
 	int tbd_count;
 } vc_map;
 
-struct ns_skb_data {
-	struct atm_vcc *vcc;
-	int iovcnt;
-};
-
-#define NS_SKB(skb) (((struct ns_skb_data *) (skb)->cb))
-
 typedef struct ns_dev {
 	int index;		/* Card ID to the device driver */
 	int sram_size;		/* In k x 32bit words. 32 or 128 */
@@ -709,6 +713,7 @@ typedef struct ns_dev {
 	int vpibits;
 	int vcibits;
 	struct pci_dev *pcidev;
+	struct idr idr;
 	struct atm_dev *atmdev;
 	tsq_info tsq;
 	rsq_info rsq;
@@ -729,11 +734,12 @@ typedef struct ns_dev {
 	buf_nr iovnr;
 	int sbfqc;
 	int lbfqc;
-	u32 sm_handle;
+	struct sk_buff *sm_handle;
 	u32 sm_addr;
-	u32 lg_handle;
+	struct sk_buff *lg_handle;
 	u32 lg_addr;
 	struct sk_buff *rcbuf;	/* Current raw cell buffer */
+        struct ns_rcqe *rawcell;
 	u32 rawch;		/* Raw cell queue head */
 	unsigned intcnt;	/* Interrupt counter */
 	spinlock_t int_lock;	/* Interrupt lock */

commit 098fde114bf6655f4b75d71dbea208d039fc1de3
Author: chas williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
Date:   Sat May 29 09:03:44 2010 +0000

    atm: [nicstar] reformatted with Lindent
    
    Signed-off-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.h b/drivers/atm/nicstar.h
index 6010e3daa6a2..43eb2db1fb88 100644
--- a/drivers/atm/nicstar.h
+++ b/drivers/atm/nicstar.h
@@ -1,5 +1,4 @@
-/******************************************************************************
- *
+/*
  * nicstar.h
  *
  * Header file for the nicstar device driver.
@@ -8,15 +7,12 @@
  * PowerPC support by Jay Talbott (jay_talbott@mcg.mot.com) April 1999
  *
  * (C) INESC 1998
- *
- ******************************************************************************/
-
+ */
 
 #ifndef _LINUX_NICSTAR_H_
 #define _LINUX_NICSTAR_H_
 
-
-/* Includes *******************************************************************/
+/* Includes */
 
 #include <linux/types.h>
 #include <linux/pci.h>
@@ -25,12 +21,11 @@
 #include <linux/atmdev.h>
 #include <linux/atm_nicstar.h>
 
-
-/* Options ********************************************************************/
+/* Options */
 
 #define NS_MAX_CARDS 4		/* Maximum number of NICStAR based cards
 				   controlled by the device driver. Must
-                                   be <= 5 */
+				   be <= 5 */
 
 #undef RCQ_SUPPORT		/* Do not define this for now */
 
@@ -43,7 +38,7 @@
 #define NS_VPIBITS 2		/* 0, 1, 2, or 8 */
 
 #define NS_MAX_RCTSIZE 4096	/* Number of entries. 4096 or 16384.
-                                   Define 4096 only if (all) your card(s)
+				   Define 4096 only if (all) your card(s)
 				   have 32K x 32bit SRAM, in which case
 				   setting this to 16384 will just waste a
 				   lot of memory.
@@ -51,33 +46,32 @@
 				   128K x 32bit SRAM will limit the maximum
 				   VCI. */
 
-/*#define NS_PCI_LATENCY 64*/	/* Must be a multiple of 32 */
+				/*#define NS_PCI_LATENCY 64*//* Must be a multiple of 32 */
 
 	/* Number of buffers initially allocated */
-#define NUM_SB 32	/* Must be even */
-#define NUM_LB 24	/* Must be even */
-#define NUM_HB 8	/* Pre-allocated huge buffers */
-#define NUM_IOVB 48	/* Iovec buffers */
+#define NUM_SB 32		/* Must be even */
+#define NUM_LB 24		/* Must be even */
+#define NUM_HB 8		/* Pre-allocated huge buffers */
+#define NUM_IOVB 48		/* Iovec buffers */
 
 	/* Lower level for count of buffers */
-#define MIN_SB 8	/* Must be even */
-#define MIN_LB 8	/* Must be even */
+#define MIN_SB 8		/* Must be even */
+#define MIN_LB 8		/* Must be even */
 #define MIN_HB 6
 #define MIN_IOVB 8
 
 	/* Upper level for count of buffers */
-#define MAX_SB 64	/* Must be even, <= 508 */
-#define MAX_LB 48	/* Must be even, <= 508 */
+#define MAX_SB 64		/* Must be even, <= 508 */
+#define MAX_LB 48		/* Must be even, <= 508 */
 #define MAX_HB 10
 #define MAX_IOVB 80
 
 	/* These are the absolute maximum allowed for the ioctl() */
-#define TOP_SB 256	/* Must be even, <= 508 */
-#define TOP_LB 128	/* Must be even, <= 508 */
+#define TOP_SB 256		/* Must be even, <= 508 */
+#define TOP_LB 128		/* Must be even, <= 508 */
 #define TOP_HB 64
 #define TOP_IOVB 256
 
-
 #define MAX_TBD_PER_VC 1	/* Number of TBDs before a TSR */
 #define MAX_TBD_PER_SCQ 10	/* Only meaningful for variable rate SCQs */
 
@@ -89,15 +83,12 @@
 
 #define PCR_TOLERANCE (1.0001)
 
-
-
-/* ESI stuff ******************************************************************/
+/* ESI stuff */
 
 #define NICSTAR_EPROM_MAC_ADDR_OFFSET 0x6C
 #define NICSTAR_EPROM_MAC_ADDR_OFFSET_ALT 0xF6
 
-
-/* #defines *******************************************************************/
+/* #defines */
 
 #define NS_IOREMAP_SIZE 4096
 
@@ -123,22 +114,19 @@
 #define NS_SMSKBSIZE (NS_SMBUFSIZE + NS_AAL0_HEADER)
 #define NS_LGSKBSIZE (NS_SMBUFSIZE + NS_LGBUFSIZE)
 
+/* NICStAR structures located in host memory */
 
-/* NICStAR structures located in host memory **********************************/
-
-
-
-/* RSQ - Receive Status Queue 
+/*
+ * RSQ - Receive Status Queue
  *
  * Written by the NICStAR, read by the device driver.
  */
 
-typedef struct ns_rsqe
-{
-   u32 word_1;
-   u32 buffer_handle;
-   u32 final_aal5_crc32;
-   u32 word_4;
+typedef struct ns_rsqe {
+	u32 word_1;
+	u32 buffer_handle;
+	u32 final_aal5_crc32;
+	u32 word_4;
 } ns_rsqe;
 
 #define ns_rsqe_vpi(ns_rsqep) \
@@ -175,30 +163,27 @@ typedef struct ns_rsqe
 #define ns_rsqe_cellcount(ns_rsqep) \
         (le32_to_cpu((ns_rsqep)->word_4) & 0x000001FF)
 #define ns_rsqe_init(ns_rsqep) \
-        ((ns_rsqep)->word_4 = cpu_to_le32(0x00000000)) 
+        ((ns_rsqep)->word_4 = cpu_to_le32(0x00000000))
 
 #define NS_RSQ_NUM_ENTRIES (NS_RSQSIZE / 16)
 #define NS_RSQ_ALIGNMENT NS_RSQSIZE
 
-
-
-/* RCQ - Raw Cell Queue
+/*
+ * RCQ - Raw Cell Queue
  *
  * Written by the NICStAR, read by the device driver.
  */
 
-typedef struct cell_payload
-{
-   u32 word[12];
+typedef struct cell_payload {
+	u32 word[12];
 } cell_payload;
 
-typedef struct ns_rcqe
-{
-   u32 word_1;
-   u32 word_2;
-   u32 word_3;
-   u32 word_4;
-   cell_payload payload;
+typedef struct ns_rcqe {
+	u32 word_1;
+	u32 word_2;
+	u32 word_3;
+	u32 word_4;
+	cell_payload payload;
 } ns_rcqe;
 
 #define NS_RCQE_SIZE 64		/* bytes */
@@ -210,28 +195,25 @@ typedef struct ns_rcqe
 #define ns_rcqe_nextbufhandle(ns_rcqep) \
         (le32_to_cpu((ns_rcqep)->word_2))
 
-
-
-/* SCQ - Segmentation Channel Queue 
+/*
+ * SCQ - Segmentation Channel Queue
  *
  * Written by the device driver, read by the NICStAR.
  */
 
-typedef struct ns_scqe
-{
-   u32 word_1;
-   u32 word_2;
-   u32 word_3;
-   u32 word_4;
+typedef struct ns_scqe {
+	u32 word_1;
+	u32 word_2;
+	u32 word_3;
+	u32 word_4;
 } ns_scqe;
 
    /* NOTE: SCQ entries can be either a TBD (Transmit Buffer Descriptors)
-            or TSR (Transmit Status Requests) */
+      or TSR (Transmit Status Requests) */
 
 #define NS_SCQE_TYPE_TBD 0x00000000
 #define NS_SCQE_TYPE_TSR 0x80000000
 
-
 #define NS_TBD_EOPDU 0x40000000
 #define NS_TBD_AAL0  0x00000000
 #define NS_TBD_AAL34 0x04000000
@@ -253,10 +235,9 @@ typedef struct ns_scqe
 #define ns_tbd_mkword_4(gfc, vpi, vci, pt, clp) \
       (cpu_to_le32((gfc) << 28 | (vpi) << 20 | (vci) << 4 | (pt) << 1 | (clp)))
 
-
 #define NS_TSR_INTENABLE 0x20000000
 
-#define NS_TSR_SCDISVBR 0xFFFF		/* Use as scdi for VBR SCD */
+#define NS_TSR_SCDISVBR 0xFFFF	/* Use as scdi for VBR SCD */
 
 #define ns_tsr_mkword_1(flags) \
         (cpu_to_le32(NS_SCQE_TYPE_TSR | (flags)))
@@ -273,22 +254,20 @@ typedef struct ns_scqe
 
 #define NS_SCQE_SIZE 16
 
-
-
-/* TSQ - Transmit Status Queue
+/*
+ * TSQ - Transmit Status Queue
  *
  * Written by the NICStAR, read by the device driver.
  */
 
-typedef struct ns_tsi
-{
-   u32 word_1;
-   u32 word_2;
+typedef struct ns_tsi {
+	u32 word_1;
+	u32 word_2;
 } ns_tsi;
 
    /* NOTE: The first word can be a status word copied from the TSR which
-            originated the TSI, or a timer overflow indicator. In this last
-	    case, the value of the first word is all zeroes. */
+      originated the TSI, or a timer overflow indicator. In this last
+      case, the value of the first word is all zeroes. */
 
 #define NS_TSI_EMPTY          0x80000000
 #define NS_TSI_TIMESTAMP_MASK 0x00FFFFFF
@@ -301,12 +280,10 @@ typedef struct ns_tsi
 #define ns_tsi_init(ns_tsip) \
         ((ns_tsip)->word_2 = cpu_to_le32(NS_TSI_EMPTY))
 
-
 #define NS_TSQSIZE 8192
 #define NS_TSQ_NUM_ENTRIES 1024
 #define NS_TSQ_ALIGNMENT 8192
 
-
 #define NS_TSI_SCDISVBR NS_TSR_SCDISVBR
 
 #define ns_tsi_tmrof(ns_tsip) \
@@ -316,26 +293,22 @@ typedef struct ns_tsi
 #define ns_tsi_getscqpos(ns_tsip) \
         (le32_to_cpu((ns_tsip)->word_1) & 0x00007FFF)
 
+/* NICStAR structures located in local SRAM */
 
-
-/* NICStAR structures located in local SRAM ***********************************/
-
-
-
-/* RCT - Receive Connection Table
+/*
+ * RCT - Receive Connection Table
  *
  * Written by both the NICStAR and the device driver.
  */
 
-typedef struct ns_rcte
-{
-   u32 word_1;
-   u32 buffer_handle;
-   u32 dma_address;
-   u32 aal5_crc32;
+typedef struct ns_rcte {
+	u32 word_1;
+	u32 buffer_handle;
+	u32 dma_address;
+	u32 aal5_crc32;
 } ns_rcte;
 
-#define NS_RCTE_BSFB            0x00200000  /* Rev. D only */
+#define NS_RCTE_BSFB            0x00200000	/* Rev. D only */
 #define NS_RCTE_NZGFC           0x00100000
 #define NS_RCTE_CONNECTOPEN     0x00080000
 #define NS_RCTE_AALMASK         0x00070000
@@ -358,25 +331,21 @@ typedef struct ns_rcte
 #define NS_RCT_ENTRY_SIZE 4	/* Number of dwords */
 
    /* NOTE: We could make macros to contruct the first word of the RCTE,
-            but that doesn't seem to make much sense... */
-
-
+      but that doesn't seem to make much sense... */
 
-/* FBD - Free Buffer Descriptor
+/*
+ * FBD - Free Buffer Descriptor
  *
  * Written by the device driver using via the command register.
  */
 
-typedef struct ns_fbd
-{
-   u32 buffer_handle;
-   u32 dma_address;
+typedef struct ns_fbd {
+	u32 buffer_handle;
+	u32 dma_address;
 } ns_fbd;
 
-
-
-
-/* TST - Transmit Schedule Table
+/*
+ * TST - Transmit Schedule Table
  *
  * Written by the device driver.
  */
@@ -385,40 +354,38 @@ typedef u32 ns_tste;
 
 #define NS_TST_OPCODE_MASK 0x60000000
 
-#define NS_TST_OPCODE_NULL     0x00000000 /* Insert null cell */
-#define NS_TST_OPCODE_FIXED    0x20000000 /* Cell from a fixed rate channel */
+#define NS_TST_OPCODE_NULL     0x00000000	/* Insert null cell */
+#define NS_TST_OPCODE_FIXED    0x20000000	/* Cell from a fixed rate channel */
 #define NS_TST_OPCODE_VARIABLE 0x40000000
-#define NS_TST_OPCODE_END      0x60000000 /* Jump */
+#define NS_TST_OPCODE_END      0x60000000	/* Jump */
 
 #define ns_tste_make(opcode, sramad) (opcode | sramad)
 
    /* NOTE:
 
       - When the opcode is FIXED, sramad specifies the SRAM address of the
-        SCD for that fixed rate channel.
+      SCD for that fixed rate channel.
       - When the opcode is END, sramad specifies the SRAM address of the
-        location of the next TST entry to read.
+      location of the next TST entry to read.
     */
 
-
-
-/* SCD - Segmentation Channel Descriptor
+/*
+ * SCD - Segmentation Channel Descriptor
  *
  * Written by both the device driver and the NICStAR
  */
 
-typedef struct ns_scd
-{
-   u32 word_1;
-   u32 word_2;
-   u32 partial_aal5_crc;
-   u32 reserved;
-   ns_scqe cache_a;
-   ns_scqe cache_b;
+typedef struct ns_scd {
+	u32 word_1;
+	u32 word_2;
+	u32 partial_aal5_crc;
+	u32 reserved;
+	ns_scqe cache_a;
+	ns_scqe cache_b;
 } ns_scd;
 
-#define NS_SCD_BASE_MASK_VAR 0xFFFFE000		/* Variable rate */
-#define NS_SCD_BASE_MASK_FIX 0xFFFFFC00		/* Fixed rate */
+#define NS_SCD_BASE_MASK_VAR 0xFFFFE000	/* Variable rate */
+#define NS_SCD_BASE_MASK_FIX 0xFFFFFC00	/* Fixed rate */
 #define NS_SCD_TAIL_MASK_VAR 0x00001FF0
 #define NS_SCD_TAIL_MASK_FIX 0x000003F0
 #define NS_SCD_HEAD_MASK_VAR 0x00001FF0
@@ -426,13 +393,9 @@ typedef struct ns_scd
 #define NS_SCD_XMITFOREVER   0x02000000
 
    /* NOTE: There are other fields in word 2 of the SCD, but as they should
-            not be needed in the device driver they are not defined here. */
-
-
-
-
-/* NICStAR local SRAM memory map **********************************************/
+      not be needed in the device driver they are not defined here. */
 
+/* NICStAR local SRAM memory map */
 
 #define NS_RCT           0x00000
 #define NS_RCT_32_END    0x03FFF
@@ -455,100 +418,93 @@ typedef struct ns_scd
 #define NS_LGFBQ         0x1FC00
 #define NS_LGFBQ_END     0x1FFFF
 
-
-
-/* NISCtAR operation registers ************************************************/
-
+/* NISCtAR operation registers */
 
 /* See Section 3.4 of `IDT77211 NICStAR User Manual' from www.idt.com */
 
-enum ns_regs
-{
-   DR0   = 0x00,      /* Data Register 0 R/W*/
-   DR1   = 0x04,      /* Data Register 1 W */
-   DR2   = 0x08,      /* Data Register 2 W */
-   DR3   = 0x0C,      /* Data Register 3 W */
-   CMD   = 0x10,      /* Command W */
-   CFG   = 0x14,      /* Configuration R/W */
-   STAT  = 0x18,      /* Status R/W */
-   RSQB  = 0x1C,      /* Receive Status Queue Base W */
-   RSQT  = 0x20,      /* Receive Status Queue Tail R */
-   RSQH  = 0x24,      /* Receive Status Queue Head W */
-   CDC   = 0x28,      /* Cell Drop Counter R/clear */
-   VPEC  = 0x2C,      /* VPI/VCI Lookup Error Count R/clear */
-   ICC   = 0x30,      /* Invalid Cell Count R/clear */
-   RAWCT = 0x34,      /* Raw Cell Tail R */
-   TMR   = 0x38,      /* Timer R */
-   TSTB  = 0x3C,      /* Transmit Schedule Table Base R/W */
-   TSQB  = 0x40,      /* Transmit Status Queue Base W */
-   TSQT  = 0x44,      /* Transmit Status Queue Tail R */
-   TSQH  = 0x48,      /* Transmit Status Queue Head W */
-   GP    = 0x4C,      /* General Purpose R/W */
-   VPM   = 0x50       /* VPI/VCI Mask W */
+enum ns_regs {
+	DR0 = 0x00,		/* Data Register 0 R/W */
+	DR1 = 0x04,		/* Data Register 1 W */
+	DR2 = 0x08,		/* Data Register 2 W */
+	DR3 = 0x0C,		/* Data Register 3 W */
+	CMD = 0x10,		/* Command W */
+	CFG = 0x14,		/* Configuration R/W */
+	STAT = 0x18,		/* Status R/W */
+	RSQB = 0x1C,		/* Receive Status Queue Base W */
+	RSQT = 0x20,		/* Receive Status Queue Tail R */
+	RSQH = 0x24,		/* Receive Status Queue Head W */
+	CDC = 0x28,		/* Cell Drop Counter R/clear */
+	VPEC = 0x2C,		/* VPI/VCI Lookup Error Count R/clear */
+	ICC = 0x30,		/* Invalid Cell Count R/clear */
+	RAWCT = 0x34,		/* Raw Cell Tail R */
+	TMR = 0x38,		/* Timer R */
+	TSTB = 0x3C,		/* Transmit Schedule Table Base R/W */
+	TSQB = 0x40,		/* Transmit Status Queue Base W */
+	TSQT = 0x44,		/* Transmit Status Queue Tail R */
+	TSQH = 0x48,		/* Transmit Status Queue Head W */
+	GP = 0x4C,		/* General Purpose R/W */
+	VPM = 0x50		/* VPI/VCI Mask W */
 };
 
-
-/* NICStAR commands issued to the CMD register ********************************/
-
+/* NICStAR commands issued to the CMD register */
 
 /* Top 4 bits are command opcode, lower 28 are parameters. */
 
 #define NS_CMD_NO_OPERATION         0x00000000
-        /* params always 0 */
+	/* params always 0 */
 
 #define NS_CMD_OPENCLOSE_CONNECTION 0x20000000
-        /* b19{1=open,0=close} b18-2{SRAM addr} */
+	/* b19{1=open,0=close} b18-2{SRAM addr} */
 
 #define NS_CMD_WRITE_SRAM           0x40000000
-        /* b18-2{SRAM addr} b1-0{burst size} */
+	/* b18-2{SRAM addr} b1-0{burst size} */
 
 #define NS_CMD_READ_SRAM            0x50000000
-        /* b18-2{SRAM addr} */
+	/* b18-2{SRAM addr} */
 
 #define NS_CMD_WRITE_FREEBUFQ       0x60000000
-        /* b0{large buf indicator} */
+	/* b0{large buf indicator} */
 
 #define NS_CMD_READ_UTILITY         0x80000000
-        /* b8{1=select UTL_CS1} b9{1=select UTL_CS0} b7-0{bus addr} */
+	/* b8{1=select UTL_CS1} b9{1=select UTL_CS0} b7-0{bus addr} */
 
 #define NS_CMD_WRITE_UTILITY        0x90000000
-        /* b8{1=select UTL_CS1} b9{1=select UTL_CS0} b7-0{bus addr} */
+	/* b8{1=select UTL_CS1} b9{1=select UTL_CS0} b7-0{bus addr} */
 
 #define NS_CMD_OPEN_CONNECTION (NS_CMD_OPENCLOSE_CONNECTION | 0x00080000)
 #define NS_CMD_CLOSE_CONNECTION NS_CMD_OPENCLOSE_CONNECTION
 
-
-/* NICStAR configuration bits *************************************************/
-
-#define NS_CFG_SWRST          0x80000000    /* Software Reset */
-#define NS_CFG_RXPATH         0x20000000    /* Receive Path Enable */
-#define NS_CFG_SMBUFSIZE_MASK 0x18000000    /* Small Receive Buffer Size */
-#define NS_CFG_LGBUFSIZE_MASK 0x06000000    /* Large Receive Buffer Size */
-#define NS_CFG_EFBIE          0x01000000    /* Empty Free Buffer Queue
-                                               Interrupt Enable */
-#define NS_CFG_RSQSIZE_MASK   0x00C00000    /* Receive Status Queue Size */
-#define NS_CFG_ICACCEPT       0x00200000    /* Invalid Cell Accept */
-#define NS_CFG_IGNOREGFC      0x00100000    /* Ignore General Flow Control */
-#define NS_CFG_VPIBITS_MASK   0x000C0000    /* VPI/VCI Bits Size Select */
-#define NS_CFG_RCTSIZE_MASK   0x00030000    /* Receive Connection Table Size */
-#define NS_CFG_VCERRACCEPT    0x00008000    /* VPI/VCI Error Cell Accept */
-#define NS_CFG_RXINT_MASK     0x00007000    /* End of Receive PDU Interrupt
-                                               Handling */
-#define NS_CFG_RAWIE          0x00000800    /* Raw Cell Qu' Interrupt Enable */
-#define NS_CFG_RSQAFIE        0x00000400    /* Receive Queue Almost Full
-                                               Interrupt Enable */
-#define NS_CFG_RXRM           0x00000200    /* Receive RM Cells */
-#define NS_CFG_TMRROIE        0x00000080    /* Timer Roll Over Interrupt
-                                               Enable */
-#define NS_CFG_TXEN           0x00000020    /* Transmit Operation Enable */
-#define NS_CFG_TXIE           0x00000010    /* Transmit Status Interrupt
-                                               Enable */
-#define NS_CFG_TXURIE         0x00000008    /* Transmit Under-run Interrupt
-                                               Enable */
-#define NS_CFG_UMODE          0x00000004    /* Utopia Mode (cell/byte) Select */
-#define NS_CFG_TSQFIE         0x00000002    /* Transmit Status Queue Full
-                                               Interrupt Enable */
-#define NS_CFG_PHYIE          0x00000001    /* PHY Interrupt Enable */
+/* NICStAR configuration bits */
+
+#define NS_CFG_SWRST          0x80000000	/* Software Reset */
+#define NS_CFG_RXPATH         0x20000000	/* Receive Path Enable */
+#define NS_CFG_SMBUFSIZE_MASK 0x18000000	/* Small Receive Buffer Size */
+#define NS_CFG_LGBUFSIZE_MASK 0x06000000	/* Large Receive Buffer Size */
+#define NS_CFG_EFBIE          0x01000000	/* Empty Free Buffer Queue
+						   Interrupt Enable */
+#define NS_CFG_RSQSIZE_MASK   0x00C00000	/* Receive Status Queue Size */
+#define NS_CFG_ICACCEPT       0x00200000	/* Invalid Cell Accept */
+#define NS_CFG_IGNOREGFC      0x00100000	/* Ignore General Flow Control */
+#define NS_CFG_VPIBITS_MASK   0x000C0000	/* VPI/VCI Bits Size Select */
+#define NS_CFG_RCTSIZE_MASK   0x00030000	/* Receive Connection Table Size */
+#define NS_CFG_VCERRACCEPT    0x00008000	/* VPI/VCI Error Cell Accept */
+#define NS_CFG_RXINT_MASK     0x00007000	/* End of Receive PDU Interrupt
+						   Handling */
+#define NS_CFG_RAWIE          0x00000800	/* Raw Cell Qu' Interrupt Enable */
+#define NS_CFG_RSQAFIE        0x00000400	/* Receive Queue Almost Full
+						   Interrupt Enable */
+#define NS_CFG_RXRM           0x00000200	/* Receive RM Cells */
+#define NS_CFG_TMRROIE        0x00000080	/* Timer Roll Over Interrupt
+						   Enable */
+#define NS_CFG_TXEN           0x00000020	/* Transmit Operation Enable */
+#define NS_CFG_TXIE           0x00000010	/* Transmit Status Interrupt
+						   Enable */
+#define NS_CFG_TXURIE         0x00000008	/* Transmit Under-run Interrupt
+						   Enable */
+#define NS_CFG_UMODE          0x00000004	/* Utopia Mode (cell/byte) Select */
+#define NS_CFG_TSQFIE         0x00000002	/* Transmit Status Queue Full
+						   Interrupt Enable */
+#define NS_CFG_PHYIE          0x00000001	/* PHY Interrupt Enable */
 
 #define NS_CFG_SMBUFSIZE_48    0x00000000
 #define NS_CFG_SMBUFSIZE_96    0x08000000
@@ -579,33 +535,29 @@ enum ns_regs
 #define NS_CFG_RXINT_624US   0x00003000
 #define NS_CFG_RXINT_899US   0x00004000
 
-
-/* NICStAR STATus bits ********************************************************/
-
-#define NS_STAT_SFBQC_MASK 0xFF000000   /* hi 8 bits Small Buffer Queue Count */
-#define NS_STAT_LFBQC_MASK 0x00FF0000   /* hi 8 bits Large Buffer Queue Count */
-#define NS_STAT_TSIF       0x00008000   /* Transmit Status Queue Indicator */
-#define NS_STAT_TXICP      0x00004000   /* Transmit Incomplete PDU */
-#define NS_STAT_TSQF       0x00001000   /* Transmit Status Queue Full */
-#define NS_STAT_TMROF      0x00000800   /* Timer Overflow */
-#define NS_STAT_PHYI       0x00000400   /* PHY Device Interrupt */
-#define NS_STAT_CMDBZ      0x00000200   /* Command Busy */
-#define NS_STAT_SFBQF      0x00000100   /* Small Buffer Queue Full */
-#define NS_STAT_LFBQF      0x00000080   /* Large Buffer Queue Full */
-#define NS_STAT_RSQF       0x00000040   /* Receive Status Queue Full */
-#define NS_STAT_EOPDU      0x00000020   /* End of PDU */
-#define NS_STAT_RAWCF      0x00000010   /* Raw Cell Flag */
-#define NS_STAT_SFBQE      0x00000008   /* Small Buffer Queue Empty */
-#define NS_STAT_LFBQE      0x00000004   /* Large Buffer Queue Empty */
-#define NS_STAT_RSQAF      0x00000002   /* Receive Status Queue Almost Full */
+/* NICStAR STATus bits */
+
+#define NS_STAT_SFBQC_MASK 0xFF000000	/* hi 8 bits Small Buffer Queue Count */
+#define NS_STAT_LFBQC_MASK 0x00FF0000	/* hi 8 bits Large Buffer Queue Count */
+#define NS_STAT_TSIF       0x00008000	/* Transmit Status Queue Indicator */
+#define NS_STAT_TXICP      0x00004000	/* Transmit Incomplete PDU */
+#define NS_STAT_TSQF       0x00001000	/* Transmit Status Queue Full */
+#define NS_STAT_TMROF      0x00000800	/* Timer Overflow */
+#define NS_STAT_PHYI       0x00000400	/* PHY Device Interrupt */
+#define NS_STAT_CMDBZ      0x00000200	/* Command Busy */
+#define NS_STAT_SFBQF      0x00000100	/* Small Buffer Queue Full */
+#define NS_STAT_LFBQF      0x00000080	/* Large Buffer Queue Full */
+#define NS_STAT_RSQF       0x00000040	/* Receive Status Queue Full */
+#define NS_STAT_EOPDU      0x00000020	/* End of PDU */
+#define NS_STAT_RAWCF      0x00000010	/* Raw Cell Flag */
+#define NS_STAT_SFBQE      0x00000008	/* Small Buffer Queue Empty */
+#define NS_STAT_LFBQE      0x00000004	/* Large Buffer Queue Empty */
+#define NS_STAT_RSQAF      0x00000002	/* Receive Status Queue Almost Full */
 
 #define ns_stat_sfbqc_get(stat) (((stat) & NS_STAT_SFBQC_MASK) >> 23)
 #define ns_stat_lfbqc_get(stat) (((stat) & NS_STAT_LFBQC_MASK) >> 15)
 
-
-
-/* #defines which depend on other #defines ************************************/
-
+/* #defines which depend on other #defines */
 
 #define NS_TST0 NS_TST_FRSCD
 #define NS_TST1 (NS_TST_FRSCD + NS_TST_NUM_ENTRIES + 1)
@@ -672,8 +624,7 @@ enum ns_regs
 #define NS_CFG_TSQFIE_OPT 0x00000000
 #endif /* ENABLE_TSQFIE */
 
-
-/* PCI stuff ******************************************************************/
+/* PCI stuff */
 
 #ifndef PCI_VENDOR_ID_IDT
 #define PCI_VENDOR_ID_IDT 0x111D
@@ -683,138 +634,119 @@ enum ns_regs
 #define PCI_DEVICE_ID_IDT_IDT77201 0x0001
 #endif /* PCI_DEVICE_ID_IDT_IDT77201 */
 
-
-
-/* Device driver structures ***************************************************/
-
+/* Device driver structures */
 
 struct ns_skb_cb {
-	u32 buf_type;			/* BUF_SM/BUF_LG/BUF_NONE */
+	u32 buf_type;		/* BUF_SM/BUF_LG/BUF_NONE */
 };
 
 #define NS_SKB_CB(skb)	((struct ns_skb_cb *)((skb)->cb))
 
-typedef struct tsq_info
-{
-   void *org;
-   ns_tsi *base;
-   ns_tsi *next;
-   ns_tsi *last;
+typedef struct tsq_info {
+	void *org;
+	ns_tsi *base;
+	ns_tsi *next;
+	ns_tsi *last;
 } tsq_info;
 
-
-typedef struct scq_info
-{
-   void *org;
-   ns_scqe *base;
-   ns_scqe *last;
-   ns_scqe *next;
-   volatile ns_scqe *tail;		/* Not related to the nicstar register */
-   unsigned num_entries;
-   struct sk_buff **skb;		/* Pointer to an array of pointers
-                                           to the sk_buffs used for tx */
-   u32 scd;				/* SRAM address of the corresponding
-                                           SCD */
-   int tbd_count;			/* Only meaningful on variable rate */
-   wait_queue_head_t scqfull_waitq;
-   volatile char full;			/* SCQ full indicator */
-   spinlock_t lock;			/* SCQ spinlock */
+typedef struct scq_info {
+	void *org;
+	ns_scqe *base;
+	ns_scqe *last;
+	ns_scqe *next;
+	volatile ns_scqe *tail;	/* Not related to the nicstar register */
+	unsigned num_entries;
+	struct sk_buff **skb;	/* Pointer to an array of pointers
+				   to the sk_buffs used for tx */
+	u32 scd;		/* SRAM address of the corresponding
+				   SCD */
+	int tbd_count;		/* Only meaningful on variable rate */
+	wait_queue_head_t scqfull_waitq;
+	volatile char full;	/* SCQ full indicator */
+	spinlock_t lock;	/* SCQ spinlock */
 } scq_info;
 
-
-
-typedef struct rsq_info
-{
-   void *org;
-   ns_rsqe *base;
-   ns_rsqe *next;
-   ns_rsqe *last;
+typedef struct rsq_info {
+	void *org;
+	ns_rsqe *base;
+	ns_rsqe *next;
+	ns_rsqe *last;
 } rsq_info;
 
-
-typedef struct skb_pool
-{
-   volatile int count;			/* number of buffers in the queue */
-   struct sk_buff_head queue;
+typedef struct skb_pool {
+	volatile int count;	/* number of buffers in the queue */
+	struct sk_buff_head queue;
 } skb_pool;
 
 /* NOTE: for small and large buffer pools, the count is not used, as the
          actual value used for buffer management is the one read from the
 	 card. */
 
-
-typedef struct vc_map
-{
-   volatile unsigned int tx:1;				/* TX vc? */
-   volatile unsigned int rx:1;				/* RX vc? */
-   struct atm_vcc *tx_vcc, *rx_vcc;
-   struct sk_buff *rx_iov;		/* RX iovector skb */
-   scq_info *scq;			/* To keep track of the SCQ */
-   u32 cbr_scd;				/* SRAM address of the corresponding
-               				   SCD. 0x00000000 for UBR/VBR/ABR */
-   int tbd_count;
+typedef struct vc_map {
+	volatile unsigned int tx:1;	/* TX vc? */
+	volatile unsigned int rx:1;	/* RX vc? */
+	struct atm_vcc *tx_vcc, *rx_vcc;
+	struct sk_buff *rx_iov;	/* RX iovector skb */
+	scq_info *scq;		/* To keep track of the SCQ */
+	u32 cbr_scd;		/* SRAM address of the corresponding
+				   SCD. 0x00000000 for UBR/VBR/ABR */
+	int tbd_count;
 } vc_map;
 
-
-struct ns_skb_data
-{
+struct ns_skb_data {
 	struct atm_vcc *vcc;
 	int iovcnt;
 };
 
 #define NS_SKB(skb) (((struct ns_skb_data *) (skb)->cb))
 
-
-typedef struct ns_dev
-{
-   int index;				/* Card ID to the device driver */
-   int sram_size;			/* In k x 32bit words. 32 or 128 */
-   void __iomem *membase;		/* Card's memory base address */
-   unsigned long max_pcr;
-   int rct_size;			/* Number of entries */
-   int vpibits;
-   int vcibits;
-   struct pci_dev *pcidev;
-   struct atm_dev *atmdev;
-   tsq_info tsq;
-   rsq_info rsq;
-   scq_info *scq0, *scq1, *scq2;	/* VBR SCQs */
-   skb_pool sbpool;			/* Small buffers */
-   skb_pool lbpool;			/* Large buffers */
-   skb_pool hbpool;			/* Pre-allocated huge buffers */
-   skb_pool iovpool;			/* iovector buffers */
-   volatile int efbie;			/* Empty free buf. queue int. enabled */
-   volatile u32 tst_addr;		/* SRAM address of the TST in use */
-   volatile int tst_free_entries;
-   vc_map vcmap[NS_MAX_RCTSIZE];
-   vc_map *tste2vc[NS_TST_NUM_ENTRIES];
-   vc_map *scd2vc[NS_FRSCD_NUM];
-   buf_nr sbnr;
-   buf_nr lbnr;
-   buf_nr hbnr;
-   buf_nr iovnr;
-   int sbfqc;
-   int lbfqc;
-   u32 sm_handle;
-   u32 sm_addr;
-   u32 lg_handle;
-   u32 lg_addr;
-   struct sk_buff *rcbuf;		/* Current raw cell buffer */
-   u32 rawch;				/* Raw cell queue head */
-   unsigned intcnt;			/* Interrupt counter */
-   spinlock_t int_lock;		/* Interrupt lock */
-   spinlock_t res_lock;		/* Card resource lock */
+typedef struct ns_dev {
+	int index;		/* Card ID to the device driver */
+	int sram_size;		/* In k x 32bit words. 32 or 128 */
+	void __iomem *membase;	/* Card's memory base address */
+	unsigned long max_pcr;
+	int rct_size;		/* Number of entries */
+	int vpibits;
+	int vcibits;
+	struct pci_dev *pcidev;
+	struct atm_dev *atmdev;
+	tsq_info tsq;
+	rsq_info rsq;
+	scq_info *scq0, *scq1, *scq2;	/* VBR SCQs */
+	skb_pool sbpool;	/* Small buffers */
+	skb_pool lbpool;	/* Large buffers */
+	skb_pool hbpool;	/* Pre-allocated huge buffers */
+	skb_pool iovpool;	/* iovector buffers */
+	volatile int efbie;	/* Empty free buf. queue int. enabled */
+	volatile u32 tst_addr;	/* SRAM address of the TST in use */
+	volatile int tst_free_entries;
+	vc_map vcmap[NS_MAX_RCTSIZE];
+	vc_map *tste2vc[NS_TST_NUM_ENTRIES];
+	vc_map *scd2vc[NS_FRSCD_NUM];
+	buf_nr sbnr;
+	buf_nr lbnr;
+	buf_nr hbnr;
+	buf_nr iovnr;
+	int sbfqc;
+	int lbfqc;
+	u32 sm_handle;
+	u32 sm_addr;
+	u32 lg_handle;
+	u32 lg_addr;
+	struct sk_buff *rcbuf;	/* Current raw cell buffer */
+	u32 rawch;		/* Raw cell queue head */
+	unsigned intcnt;	/* Interrupt counter */
+	spinlock_t int_lock;	/* Interrupt lock */
+	spinlock_t res_lock;	/* Card resource lock */
 } ns_dev;
 
-
    /* NOTE: Each tste2vc entry relates a given TST entry to the corresponding
-            CBR vc. If the entry is not allocated, it must be NULL.
-	    
-	    There are two TSTs so the driver can modify them on the fly
-	    without stopping the transmission.
-	    
-	    scd2vc allows us to find out unused fixed rate SCDs, because
-	    they must have a NULL pointer here. */
+      CBR vc. If the entry is not allocated, it must be NULL.
+
+      There are two TSTs so the driver can modify them on the fly
+      without stopping the transmission.
 
+      scd2vc allows us to find out unused fixed rate SCDs, because
+      they must have a NULL pointer here. */
 
 #endif /* _LINUX_NICSTAR_H_ */

commit 36ef408061da9e012375547d69b27cc1f537b044
Author: Mark Asselstine <mark.asselstine@windriver.com>
Date:   Sat Apr 19 18:10:46 2008 -0700

    atm nicstar: Removal of debug code containing deprecated calls to cli()/sti()
    
    Code within NS_DEBUG_SPINLOCKS contained deprecated cli()/sti()
    function calls.  NS_DEBUG_SPINLOCKS and the associated code seems to
    be of little use these days so the strategy of removing this code
    rather then updating it to use spinlocks has been taken.
    
    Signed-off-by: Mark Asselstine <mark.asselstine@windriver.com>
    Reviewed-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/nicstar.h b/drivers/atm/nicstar.h
index 5997bcb45b59..6010e3daa6a2 100644
--- a/drivers/atm/nicstar.h
+++ b/drivers/atm/nicstar.h
@@ -28,8 +28,6 @@
 
 /* Options ********************************************************************/
 
-#undef NS_DEBUG_SPINLOCKS
-
 #define NS_MAX_CARDS 4		/* Maximum number of NICStAR based cards
 				   controlled by the device driver. Must
                                    be <= 5 */
@@ -721,10 +719,6 @@ typedef struct scq_info
    wait_queue_head_t scqfull_waitq;
    volatile char full;			/* SCQ full indicator */
    spinlock_t lock;			/* SCQ spinlock */
-#ifdef NS_DEBUG_SPINLOCKS
-   volatile long has_lock;
-   volatile int cpu_lock;
-#endif /* NS_DEBUG_SPINLOCKS */
 } scq_info;
 
 
@@ -810,12 +804,6 @@ typedef struct ns_dev
    unsigned intcnt;			/* Interrupt counter */
    spinlock_t int_lock;		/* Interrupt lock */
    spinlock_t res_lock;		/* Card resource lock */
-#ifdef NS_DEBUG_SPINLOCKS
-   volatile long has_int_lock;
-   volatile int cpu_int;
-   volatile long has_res_lock;
-   volatile int cpu_res;
-#endif /* NS_DEBUG_SPINLOCKS */
 } ns_dev;
 
 

commit 8728b834b226ffcf2c94a58530090e292af2a7bf
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Aug 9 19:25:21 2005 -0700

    [NET]: Kill skb->list
    
    Remove the "list" member of struct sk_buff, as it is entirely
    redundant.  All SKB list removal callers know which list the
    SKB is on, so storing this in sk_buff does nothing other than
    taking up some space.
    
    Two tricky bits were SCTP, which I took care of, and two ATM
    drivers which Francois Romieu <romieu@fr.zoreil.com> fixed
    up.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Francois Romieu <romieu@fr.zoreil.com>

diff --git a/drivers/atm/nicstar.h b/drivers/atm/nicstar.h
index ea83c46c8ba5..5997bcb45b59 100644
--- a/drivers/atm/nicstar.h
+++ b/drivers/atm/nicstar.h
@@ -103,8 +103,14 @@
 
 #define NS_IOREMAP_SIZE 4096
 
-#define BUF_SM 0x00000000	/* These two are used for push_rxbufs() */
-#define BUF_LG 0x00000001       /* CMD, Write_FreeBufQ, LBUF bit */
+/*
+ * BUF_XX distinguish the Rx buffers depending on their (small/large) size.
+ * BUG_SM and BUG_LG are both used by the driver and the device.
+ * BUF_NONE is only used by the driver.
+ */
+#define BUF_SM		0x00000000	/* These two are used for push_rxbufs() */
+#define BUF_LG		0x00000001	/* CMD, Write_FreeBufQ, LBUF bit */
+#define BUF_NONE 	0xffffffff	/* Software only: */
 
 #define NS_HBUFSIZE 65568	/* Size of max. AAL5 PDU */
 #define NS_MAX_IOVECS (2 + (65568 - NS_SMBUFSIZE) / \
@@ -684,6 +690,12 @@ enum ns_regs
 /* Device driver structures ***************************************************/
 
 
+struct ns_skb_cb {
+	u32 buf_type;			/* BUF_SM/BUF_LG/BUF_NONE */
+};
+
+#define NS_SKB_CB(skb)	((struct ns_skb_cb *)((skb)->cb))
+
 typedef struct tsq_info
 {
    void *org;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/atm/nicstar.h b/drivers/atm/nicstar.h
new file mode 100644
index 000000000000..ea83c46c8ba5
--- /dev/null
+++ b/drivers/atm/nicstar.h
@@ -0,0 +1,820 @@
+/******************************************************************************
+ *
+ * nicstar.h
+ *
+ * Header file for the nicstar device driver.
+ *
+ * Author: Rui Prior (rprior@inescn.pt)
+ * PowerPC support by Jay Talbott (jay_talbott@mcg.mot.com) April 1999
+ *
+ * (C) INESC 1998
+ *
+ ******************************************************************************/
+
+
+#ifndef _LINUX_NICSTAR_H_
+#define _LINUX_NICSTAR_H_
+
+
+/* Includes *******************************************************************/
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/uio.h>
+#include <linux/skbuff.h>
+#include <linux/atmdev.h>
+#include <linux/atm_nicstar.h>
+
+
+/* Options ********************************************************************/
+
+#undef NS_DEBUG_SPINLOCKS
+
+#define NS_MAX_CARDS 4		/* Maximum number of NICStAR based cards
+				   controlled by the device driver. Must
+                                   be <= 5 */
+
+#undef RCQ_SUPPORT		/* Do not define this for now */
+
+#define NS_TST_NUM_ENTRIES 2340	/* + 1 for return */
+#define NS_TST_RESERVED 340	/* N. entries reserved for UBR/ABR/VBR */
+
+#define NS_SMBUFSIZE 48		/* 48, 96, 240 or 2048 */
+#define NS_LGBUFSIZE 16384	/* 2048, 4096, 8192 or 16384 */
+#define NS_RSQSIZE 8192		/* 2048, 4096 or 8192 */
+#define NS_VPIBITS 2		/* 0, 1, 2, or 8 */
+
+#define NS_MAX_RCTSIZE 4096	/* Number of entries. 4096 or 16384.
+                                   Define 4096 only if (all) your card(s)
+				   have 32K x 32bit SRAM, in which case
+				   setting this to 16384 will just waste a
+				   lot of memory.
+				   Setting this to 4096 for a card with
+				   128K x 32bit SRAM will limit the maximum
+				   VCI. */
+
+/*#define NS_PCI_LATENCY 64*/	/* Must be a multiple of 32 */
+
+	/* Number of buffers initially allocated */
+#define NUM_SB 32	/* Must be even */
+#define NUM_LB 24	/* Must be even */
+#define NUM_HB 8	/* Pre-allocated huge buffers */
+#define NUM_IOVB 48	/* Iovec buffers */
+
+	/* Lower level for count of buffers */
+#define MIN_SB 8	/* Must be even */
+#define MIN_LB 8	/* Must be even */
+#define MIN_HB 6
+#define MIN_IOVB 8
+
+	/* Upper level for count of buffers */
+#define MAX_SB 64	/* Must be even, <= 508 */
+#define MAX_LB 48	/* Must be even, <= 508 */
+#define MAX_HB 10
+#define MAX_IOVB 80
+
+	/* These are the absolute maximum allowed for the ioctl() */
+#define TOP_SB 256	/* Must be even, <= 508 */
+#define TOP_LB 128	/* Must be even, <= 508 */
+#define TOP_HB 64
+#define TOP_IOVB 256
+
+
+#define MAX_TBD_PER_VC 1	/* Number of TBDs before a TSR */
+#define MAX_TBD_PER_SCQ 10	/* Only meaningful for variable rate SCQs */
+
+#undef ENABLE_TSQFIE
+
+#define SCQFULL_TIMEOUT (5 * HZ)
+
+#define NS_POLL_PERIOD (HZ)
+
+#define PCR_TOLERANCE (1.0001)
+
+
+
+/* ESI stuff ******************************************************************/
+
+#define NICSTAR_EPROM_MAC_ADDR_OFFSET 0x6C
+#define NICSTAR_EPROM_MAC_ADDR_OFFSET_ALT 0xF6
+
+
+/* #defines *******************************************************************/
+
+#define NS_IOREMAP_SIZE 4096
+
+#define BUF_SM 0x00000000	/* These two are used for push_rxbufs() */
+#define BUF_LG 0x00000001       /* CMD, Write_FreeBufQ, LBUF bit */
+
+#define NS_HBUFSIZE 65568	/* Size of max. AAL5 PDU */
+#define NS_MAX_IOVECS (2 + (65568 - NS_SMBUFSIZE) / \
+                       (NS_LGBUFSIZE - (NS_LGBUFSIZE % 48)))
+#define NS_IOVBUFSIZE (NS_MAX_IOVECS * (sizeof(struct iovec)))
+
+#define NS_SMBUFSIZE_USABLE (NS_SMBUFSIZE - NS_SMBUFSIZE % 48)
+#define NS_LGBUFSIZE_USABLE (NS_LGBUFSIZE - NS_LGBUFSIZE % 48)
+
+#define NS_AAL0_HEADER (ATM_AAL0_SDU - ATM_CELL_PAYLOAD)	/* 4 bytes */
+
+#define NS_SMSKBSIZE (NS_SMBUFSIZE + NS_AAL0_HEADER)
+#define NS_LGSKBSIZE (NS_SMBUFSIZE + NS_LGBUFSIZE)
+
+
+/* NICStAR structures located in host memory **********************************/
+
+
+
+/* RSQ - Receive Status Queue 
+ *
+ * Written by the NICStAR, read by the device driver.
+ */
+
+typedef struct ns_rsqe
+{
+   u32 word_1;
+   u32 buffer_handle;
+   u32 final_aal5_crc32;
+   u32 word_4;
+} ns_rsqe;
+
+#define ns_rsqe_vpi(ns_rsqep) \
+        ((le32_to_cpu((ns_rsqep)->word_1) & 0x00FF0000) >> 16)
+#define ns_rsqe_vci(ns_rsqep) \
+        (le32_to_cpu((ns_rsqep)->word_1) & 0x0000FFFF)
+
+#define NS_RSQE_VALID      0x80000000
+#define NS_RSQE_NZGFC      0x00004000
+#define NS_RSQE_EOPDU      0x00002000
+#define NS_RSQE_BUFSIZE    0x00001000
+#define NS_RSQE_CONGESTION 0x00000800
+#define NS_RSQE_CLP        0x00000400
+#define NS_RSQE_CRCERR     0x00000200
+
+#define NS_RSQE_BUFSIZE_SM 0x00000000
+#define NS_RSQE_BUFSIZE_LG 0x00001000
+
+#define ns_rsqe_valid(ns_rsqep) \
+        (le32_to_cpu((ns_rsqep)->word_4) & NS_RSQE_VALID)
+#define ns_rsqe_nzgfc(ns_rsqep) \
+        (le32_to_cpu((ns_rsqep)->word_4) & NS_RSQE_NZGFC)
+#define ns_rsqe_eopdu(ns_rsqep) \
+        (le32_to_cpu((ns_rsqep)->word_4) & NS_RSQE_EOPDU)
+#define ns_rsqe_bufsize(ns_rsqep) \
+        (le32_to_cpu((ns_rsqep)->word_4) & NS_RSQE_BUFSIZE)
+#define ns_rsqe_congestion(ns_rsqep) \
+        (le32_to_cpu((ns_rsqep)->word_4) & NS_RSQE_CONGESTION)
+#define ns_rsqe_clp(ns_rsqep) \
+        (le32_to_cpu((ns_rsqep)->word_4) & NS_RSQE_CLP)
+#define ns_rsqe_crcerr(ns_rsqep) \
+        (le32_to_cpu((ns_rsqep)->word_4) & NS_RSQE_CRCERR)
+
+#define ns_rsqe_cellcount(ns_rsqep) \
+        (le32_to_cpu((ns_rsqep)->word_4) & 0x000001FF)
+#define ns_rsqe_init(ns_rsqep) \
+        ((ns_rsqep)->word_4 = cpu_to_le32(0x00000000)) 
+
+#define NS_RSQ_NUM_ENTRIES (NS_RSQSIZE / 16)
+#define NS_RSQ_ALIGNMENT NS_RSQSIZE
+
+
+
+/* RCQ - Raw Cell Queue
+ *
+ * Written by the NICStAR, read by the device driver.
+ */
+
+typedef struct cell_payload
+{
+   u32 word[12];
+} cell_payload;
+
+typedef struct ns_rcqe
+{
+   u32 word_1;
+   u32 word_2;
+   u32 word_3;
+   u32 word_4;
+   cell_payload payload;
+} ns_rcqe;
+
+#define NS_RCQE_SIZE 64		/* bytes */
+
+#define ns_rcqe_islast(ns_rcqep) \
+        (le32_to_cpu((ns_rcqep)->word_2) != 0x00000000)
+#define ns_rcqe_cellheader(ns_rcqep) \
+        (le32_to_cpu((ns_rcqep)->word_1))
+#define ns_rcqe_nextbufhandle(ns_rcqep) \
+        (le32_to_cpu((ns_rcqep)->word_2))
+
+
+
+/* SCQ - Segmentation Channel Queue 
+ *
+ * Written by the device driver, read by the NICStAR.
+ */
+
+typedef struct ns_scqe
+{
+   u32 word_1;
+   u32 word_2;
+   u32 word_3;
+   u32 word_4;
+} ns_scqe;
+
+   /* NOTE: SCQ entries can be either a TBD (Transmit Buffer Descriptors)
+            or TSR (Transmit Status Requests) */
+
+#define NS_SCQE_TYPE_TBD 0x00000000
+#define NS_SCQE_TYPE_TSR 0x80000000
+
+
+#define NS_TBD_EOPDU 0x40000000
+#define NS_TBD_AAL0  0x00000000
+#define NS_TBD_AAL34 0x04000000
+#define NS_TBD_AAL5  0x08000000
+
+#define NS_TBD_VPI_MASK 0x0FF00000
+#define NS_TBD_VCI_MASK 0x000FFFF0
+#define NS_TBD_VC_MASK (NS_TBD_VPI_MASK | NS_TBD_VCI_MASK)
+
+#define NS_TBD_VPI_SHIFT 20
+#define NS_TBD_VCI_SHIFT 4
+
+#define ns_tbd_mkword_1(flags, m, n, buflen) \
+      (cpu_to_le32((flags) | (m) << 23 | (n) << 16 | (buflen)))
+#define ns_tbd_mkword_1_novbr(flags, buflen) \
+      (cpu_to_le32((flags) | (buflen) | 0x00810000))
+#define ns_tbd_mkword_3(control, pdulen) \
+      (cpu_to_le32((control) << 16 | (pdulen)))
+#define ns_tbd_mkword_4(gfc, vpi, vci, pt, clp) \
+      (cpu_to_le32((gfc) << 28 | (vpi) << 20 | (vci) << 4 | (pt) << 1 | (clp)))
+
+
+#define NS_TSR_INTENABLE 0x20000000
+
+#define NS_TSR_SCDISVBR 0xFFFF		/* Use as scdi for VBR SCD */
+
+#define ns_tsr_mkword_1(flags) \
+        (cpu_to_le32(NS_SCQE_TYPE_TSR | (flags)))
+#define ns_tsr_mkword_2(scdi, scqi) \
+        (cpu_to_le32((scdi) << 16 | 0x00008000 | (scqi)))
+
+#define ns_scqe_is_tsr(ns_scqep) \
+        (le32_to_cpu((ns_scqep)->word_1) & NS_SCQE_TYPE_TSR)
+
+#define VBR_SCQ_NUM_ENTRIES 512
+#define VBR_SCQSIZE 8192
+#define CBR_SCQ_NUM_ENTRIES 64
+#define CBR_SCQSIZE 1024
+
+#define NS_SCQE_SIZE 16
+
+
+
+/* TSQ - Transmit Status Queue
+ *
+ * Written by the NICStAR, read by the device driver.
+ */
+
+typedef struct ns_tsi
+{
+   u32 word_1;
+   u32 word_2;
+} ns_tsi;
+
+   /* NOTE: The first word can be a status word copied from the TSR which
+            originated the TSI, or a timer overflow indicator. In this last
+	    case, the value of the first word is all zeroes. */
+
+#define NS_TSI_EMPTY          0x80000000
+#define NS_TSI_TIMESTAMP_MASK 0x00FFFFFF
+
+#define ns_tsi_isempty(ns_tsip) \
+        (le32_to_cpu((ns_tsip)->word_2) & NS_TSI_EMPTY)
+#define ns_tsi_gettimestamp(ns_tsip) \
+        (le32_to_cpu((ns_tsip)->word_2) & NS_TSI_TIMESTAMP_MASK)
+
+#define ns_tsi_init(ns_tsip) \
+        ((ns_tsip)->word_2 = cpu_to_le32(NS_TSI_EMPTY))
+
+
+#define NS_TSQSIZE 8192
+#define NS_TSQ_NUM_ENTRIES 1024
+#define NS_TSQ_ALIGNMENT 8192
+
+
+#define NS_TSI_SCDISVBR NS_TSR_SCDISVBR
+
+#define ns_tsi_tmrof(ns_tsip) \
+        (le32_to_cpu((ns_tsip)->word_1) == 0x00000000)
+#define ns_tsi_getscdindex(ns_tsip) \
+        ((le32_to_cpu((ns_tsip)->word_1) & 0xFFFF0000) >> 16)
+#define ns_tsi_getscqpos(ns_tsip) \
+        (le32_to_cpu((ns_tsip)->word_1) & 0x00007FFF)
+
+
+
+/* NICStAR structures located in local SRAM ***********************************/
+
+
+
+/* RCT - Receive Connection Table
+ *
+ * Written by both the NICStAR and the device driver.
+ */
+
+typedef struct ns_rcte
+{
+   u32 word_1;
+   u32 buffer_handle;
+   u32 dma_address;
+   u32 aal5_crc32;
+} ns_rcte;
+
+#define NS_RCTE_BSFB            0x00200000  /* Rev. D only */
+#define NS_RCTE_NZGFC           0x00100000
+#define NS_RCTE_CONNECTOPEN     0x00080000
+#define NS_RCTE_AALMASK         0x00070000
+#define NS_RCTE_AAL0            0x00000000
+#define NS_RCTE_AAL34           0x00010000
+#define NS_RCTE_AAL5            0x00020000
+#define NS_RCTE_RCQ             0x00030000
+#define NS_RCTE_RAWCELLINTEN    0x00008000
+#define NS_RCTE_RXCONSTCELLADDR 0x00004000
+#define NS_RCTE_BUFFVALID       0x00002000
+#define NS_RCTE_FBDSIZE         0x00001000
+#define NS_RCTE_EFCI            0x00000800
+#define NS_RCTE_CLP             0x00000400
+#define NS_RCTE_CRCERROR        0x00000200
+#define NS_RCTE_CELLCOUNT_MASK  0x000001FF
+
+#define NS_RCTE_FBDSIZE_SM 0x00000000
+#define NS_RCTE_FBDSIZE_LG 0x00001000
+
+#define NS_RCT_ENTRY_SIZE 4	/* Number of dwords */
+
+   /* NOTE: We could make macros to contruct the first word of the RCTE,
+            but that doesn't seem to make much sense... */
+
+
+
+/* FBD - Free Buffer Descriptor
+ *
+ * Written by the device driver using via the command register.
+ */
+
+typedef struct ns_fbd
+{
+   u32 buffer_handle;
+   u32 dma_address;
+} ns_fbd;
+
+
+
+
+/* TST - Transmit Schedule Table
+ *
+ * Written by the device driver.
+ */
+
+typedef u32 ns_tste;
+
+#define NS_TST_OPCODE_MASK 0x60000000
+
+#define NS_TST_OPCODE_NULL     0x00000000 /* Insert null cell */
+#define NS_TST_OPCODE_FIXED    0x20000000 /* Cell from a fixed rate channel */
+#define NS_TST_OPCODE_VARIABLE 0x40000000
+#define NS_TST_OPCODE_END      0x60000000 /* Jump */
+
+#define ns_tste_make(opcode, sramad) (opcode | sramad)
+
+   /* NOTE:
+
+      - When the opcode is FIXED, sramad specifies the SRAM address of the
+        SCD for that fixed rate channel.
+      - When the opcode is END, sramad specifies the SRAM address of the
+        location of the next TST entry to read.
+    */
+
+
+
+/* SCD - Segmentation Channel Descriptor
+ *
+ * Written by both the device driver and the NICStAR
+ */
+
+typedef struct ns_scd
+{
+   u32 word_1;
+   u32 word_2;
+   u32 partial_aal5_crc;
+   u32 reserved;
+   ns_scqe cache_a;
+   ns_scqe cache_b;
+} ns_scd;
+
+#define NS_SCD_BASE_MASK_VAR 0xFFFFE000		/* Variable rate */
+#define NS_SCD_BASE_MASK_FIX 0xFFFFFC00		/* Fixed rate */
+#define NS_SCD_TAIL_MASK_VAR 0x00001FF0
+#define NS_SCD_TAIL_MASK_FIX 0x000003F0
+#define NS_SCD_HEAD_MASK_VAR 0x00001FF0
+#define NS_SCD_HEAD_MASK_FIX 0x000003F0
+#define NS_SCD_XMITFOREVER   0x02000000
+
+   /* NOTE: There are other fields in word 2 of the SCD, but as they should
+            not be needed in the device driver they are not defined here. */
+
+
+
+
+/* NICStAR local SRAM memory map **********************************************/
+
+
+#define NS_RCT           0x00000
+#define NS_RCT_32_END    0x03FFF
+#define NS_RCT_128_END   0x0FFFF
+#define NS_UNUSED_32     0x04000
+#define NS_UNUSED_128    0x10000
+#define NS_UNUSED_END    0x1BFFF
+#define NS_TST_FRSCD     0x1C000
+#define NS_TST_FRSCD_END 0x1E7DB
+#define NS_VRSCD2        0x1E7DC
+#define NS_VRSCD2_END    0x1E7E7
+#define NS_VRSCD1        0x1E7E8
+#define NS_VRSCD1_END    0x1E7F3
+#define NS_VRSCD0        0x1E7F4
+#define NS_VRSCD0_END    0x1E7FF
+#define NS_RXFIFO        0x1E800
+#define NS_RXFIFO_END    0x1F7FF
+#define NS_SMFBQ         0x1F800
+#define NS_SMFBQ_END     0x1FBFF
+#define NS_LGFBQ         0x1FC00
+#define NS_LGFBQ_END     0x1FFFF
+
+
+
+/* NISCtAR operation registers ************************************************/
+
+
+/* See Section 3.4 of `IDT77211 NICStAR User Manual' from www.idt.com */
+
+enum ns_regs
+{
+   DR0   = 0x00,      /* Data Register 0 R/W*/
+   DR1   = 0x04,      /* Data Register 1 W */
+   DR2   = 0x08,      /* Data Register 2 W */
+   DR3   = 0x0C,      /* Data Register 3 W */
+   CMD   = 0x10,      /* Command W */
+   CFG   = 0x14,      /* Configuration R/W */
+   STAT  = 0x18,      /* Status R/W */
+   RSQB  = 0x1C,      /* Receive Status Queue Base W */
+   RSQT  = 0x20,      /* Receive Status Queue Tail R */
+   RSQH  = 0x24,      /* Receive Status Queue Head W */
+   CDC   = 0x28,      /* Cell Drop Counter R/clear */
+   VPEC  = 0x2C,      /* VPI/VCI Lookup Error Count R/clear */
+   ICC   = 0x30,      /* Invalid Cell Count R/clear */
+   RAWCT = 0x34,      /* Raw Cell Tail R */
+   TMR   = 0x38,      /* Timer R */
+   TSTB  = 0x3C,      /* Transmit Schedule Table Base R/W */
+   TSQB  = 0x40,      /* Transmit Status Queue Base W */
+   TSQT  = 0x44,      /* Transmit Status Queue Tail R */
+   TSQH  = 0x48,      /* Transmit Status Queue Head W */
+   GP    = 0x4C,      /* General Purpose R/W */
+   VPM   = 0x50       /* VPI/VCI Mask W */
+};
+
+
+/* NICStAR commands issued to the CMD register ********************************/
+
+
+/* Top 4 bits are command opcode, lower 28 are parameters. */
+
+#define NS_CMD_NO_OPERATION         0x00000000
+        /* params always 0 */
+
+#define NS_CMD_OPENCLOSE_CONNECTION 0x20000000
+        /* b19{1=open,0=close} b18-2{SRAM addr} */
+
+#define NS_CMD_WRITE_SRAM           0x40000000
+        /* b18-2{SRAM addr} b1-0{burst size} */
+
+#define NS_CMD_READ_SRAM            0x50000000
+        /* b18-2{SRAM addr} */
+
+#define NS_CMD_WRITE_FREEBUFQ       0x60000000
+        /* b0{large buf indicator} */
+
+#define NS_CMD_READ_UTILITY         0x80000000
+        /* b8{1=select UTL_CS1} b9{1=select UTL_CS0} b7-0{bus addr} */
+
+#define NS_CMD_WRITE_UTILITY        0x90000000
+        /* b8{1=select UTL_CS1} b9{1=select UTL_CS0} b7-0{bus addr} */
+
+#define NS_CMD_OPEN_CONNECTION (NS_CMD_OPENCLOSE_CONNECTION | 0x00080000)
+#define NS_CMD_CLOSE_CONNECTION NS_CMD_OPENCLOSE_CONNECTION
+
+
+/* NICStAR configuration bits *************************************************/
+
+#define NS_CFG_SWRST          0x80000000    /* Software Reset */
+#define NS_CFG_RXPATH         0x20000000    /* Receive Path Enable */
+#define NS_CFG_SMBUFSIZE_MASK 0x18000000    /* Small Receive Buffer Size */
+#define NS_CFG_LGBUFSIZE_MASK 0x06000000    /* Large Receive Buffer Size */
+#define NS_CFG_EFBIE          0x01000000    /* Empty Free Buffer Queue
+                                               Interrupt Enable */
+#define NS_CFG_RSQSIZE_MASK   0x00C00000    /* Receive Status Queue Size */
+#define NS_CFG_ICACCEPT       0x00200000    /* Invalid Cell Accept */
+#define NS_CFG_IGNOREGFC      0x00100000    /* Ignore General Flow Control */
+#define NS_CFG_VPIBITS_MASK   0x000C0000    /* VPI/VCI Bits Size Select */
+#define NS_CFG_RCTSIZE_MASK   0x00030000    /* Receive Connection Table Size */
+#define NS_CFG_VCERRACCEPT    0x00008000    /* VPI/VCI Error Cell Accept */
+#define NS_CFG_RXINT_MASK     0x00007000    /* End of Receive PDU Interrupt
+                                               Handling */
+#define NS_CFG_RAWIE          0x00000800    /* Raw Cell Qu' Interrupt Enable */
+#define NS_CFG_RSQAFIE        0x00000400    /* Receive Queue Almost Full
+                                               Interrupt Enable */
+#define NS_CFG_RXRM           0x00000200    /* Receive RM Cells */
+#define NS_CFG_TMRROIE        0x00000080    /* Timer Roll Over Interrupt
+                                               Enable */
+#define NS_CFG_TXEN           0x00000020    /* Transmit Operation Enable */
+#define NS_CFG_TXIE           0x00000010    /* Transmit Status Interrupt
+                                               Enable */
+#define NS_CFG_TXURIE         0x00000008    /* Transmit Under-run Interrupt
+                                               Enable */
+#define NS_CFG_UMODE          0x00000004    /* Utopia Mode (cell/byte) Select */
+#define NS_CFG_TSQFIE         0x00000002    /* Transmit Status Queue Full
+                                               Interrupt Enable */
+#define NS_CFG_PHYIE          0x00000001    /* PHY Interrupt Enable */
+
+#define NS_CFG_SMBUFSIZE_48    0x00000000
+#define NS_CFG_SMBUFSIZE_96    0x08000000
+#define NS_CFG_SMBUFSIZE_240   0x10000000
+#define NS_CFG_SMBUFSIZE_2048  0x18000000
+
+#define NS_CFG_LGBUFSIZE_2048  0x00000000
+#define NS_CFG_LGBUFSIZE_4096  0x02000000
+#define NS_CFG_LGBUFSIZE_8192  0x04000000
+#define NS_CFG_LGBUFSIZE_16384 0x06000000
+
+#define NS_CFG_RSQSIZE_2048 0x00000000
+#define NS_CFG_RSQSIZE_4096 0x00400000
+#define NS_CFG_RSQSIZE_8192 0x00800000
+
+#define NS_CFG_VPIBITS_0 0x00000000
+#define NS_CFG_VPIBITS_1 0x00040000
+#define NS_CFG_VPIBITS_2 0x00080000
+#define NS_CFG_VPIBITS_8 0x000C0000
+
+#define NS_CFG_RCTSIZE_4096_ENTRIES  0x00000000
+#define NS_CFG_RCTSIZE_8192_ENTRIES  0x00010000
+#define NS_CFG_RCTSIZE_16384_ENTRIES 0x00020000
+
+#define NS_CFG_RXINT_NOINT   0x00000000
+#define NS_CFG_RXINT_NODELAY 0x00001000
+#define NS_CFG_RXINT_314US   0x00002000
+#define NS_CFG_RXINT_624US   0x00003000
+#define NS_CFG_RXINT_899US   0x00004000
+
+
+/* NICStAR STATus bits ********************************************************/
+
+#define NS_STAT_SFBQC_MASK 0xFF000000   /* hi 8 bits Small Buffer Queue Count */
+#define NS_STAT_LFBQC_MASK 0x00FF0000   /* hi 8 bits Large Buffer Queue Count */
+#define NS_STAT_TSIF       0x00008000   /* Transmit Status Queue Indicator */
+#define NS_STAT_TXICP      0x00004000   /* Transmit Incomplete PDU */
+#define NS_STAT_TSQF       0x00001000   /* Transmit Status Queue Full */
+#define NS_STAT_TMROF      0x00000800   /* Timer Overflow */
+#define NS_STAT_PHYI       0x00000400   /* PHY Device Interrupt */
+#define NS_STAT_CMDBZ      0x00000200   /* Command Busy */
+#define NS_STAT_SFBQF      0x00000100   /* Small Buffer Queue Full */
+#define NS_STAT_LFBQF      0x00000080   /* Large Buffer Queue Full */
+#define NS_STAT_RSQF       0x00000040   /* Receive Status Queue Full */
+#define NS_STAT_EOPDU      0x00000020   /* End of PDU */
+#define NS_STAT_RAWCF      0x00000010   /* Raw Cell Flag */
+#define NS_STAT_SFBQE      0x00000008   /* Small Buffer Queue Empty */
+#define NS_STAT_LFBQE      0x00000004   /* Large Buffer Queue Empty */
+#define NS_STAT_RSQAF      0x00000002   /* Receive Status Queue Almost Full */
+
+#define ns_stat_sfbqc_get(stat) (((stat) & NS_STAT_SFBQC_MASK) >> 23)
+#define ns_stat_lfbqc_get(stat) (((stat) & NS_STAT_LFBQC_MASK) >> 15)
+
+
+
+/* #defines which depend on other #defines ************************************/
+
+
+#define NS_TST0 NS_TST_FRSCD
+#define NS_TST1 (NS_TST_FRSCD + NS_TST_NUM_ENTRIES + 1)
+
+#define NS_FRSCD (NS_TST1 + NS_TST_NUM_ENTRIES + 1)
+#define NS_FRSCD_SIZE 12	/* 12 dwords */
+#define NS_FRSCD_NUM ((NS_TST_FRSCD_END + 1 - NS_FRSCD) / NS_FRSCD_SIZE)
+
+#if (NS_SMBUFSIZE == 48)
+#define NS_CFG_SMBUFSIZE NS_CFG_SMBUFSIZE_48
+#elif (NS_SMBUFSIZE == 96)
+#define NS_CFG_SMBUFSIZE NS_CFG_SMBUFSIZE_96
+#elif (NS_SMBUFSIZE == 240)
+#define NS_CFG_SMBUFSIZE NS_CFG_SMBUFSIZE_240
+#elif (NS_SMBUFSIZE == 2048)
+#define NS_CFG_SMBUFSIZE NS_CFG_SMBUFSIZE_2048
+#else
+#error NS_SMBUFSIZE is incorrect in nicstar.h
+#endif /* NS_SMBUFSIZE */
+
+#if (NS_LGBUFSIZE == 2048)
+#define NS_CFG_LGBUFSIZE NS_CFG_LGBUFSIZE_2048
+#elif (NS_LGBUFSIZE == 4096)
+#define NS_CFG_LGBUFSIZE NS_CFG_LGBUFSIZE_4096
+#elif (NS_LGBUFSIZE == 8192)
+#define NS_CFG_LGBUFSIZE NS_CFG_LGBUFSIZE_8192
+#elif (NS_LGBUFSIZE == 16384)
+#define NS_CFG_LGBUFSIZE NS_CFG_LGBUFSIZE_16384
+#else
+#error NS_LGBUFSIZE is incorrect in nicstar.h
+#endif /* NS_LGBUFSIZE */
+
+#if (NS_RSQSIZE == 2048)
+#define NS_CFG_RSQSIZE NS_CFG_RSQSIZE_2048
+#elif (NS_RSQSIZE == 4096)
+#define NS_CFG_RSQSIZE NS_CFG_RSQSIZE_4096
+#elif (NS_RSQSIZE == 8192)
+#define NS_CFG_RSQSIZE NS_CFG_RSQSIZE_8192
+#else
+#error NS_RSQSIZE is incorrect in nicstar.h
+#endif /* NS_RSQSIZE */
+
+#if (NS_VPIBITS == 0)
+#define NS_CFG_VPIBITS NS_CFG_VPIBITS_0
+#elif (NS_VPIBITS == 1)
+#define NS_CFG_VPIBITS NS_CFG_VPIBITS_1
+#elif (NS_VPIBITS == 2)
+#define NS_CFG_VPIBITS NS_CFG_VPIBITS_2
+#elif (NS_VPIBITS == 8)
+#define NS_CFG_VPIBITS NS_CFG_VPIBITS_8
+#else
+#error NS_VPIBITS is incorrect in nicstar.h
+#endif /* NS_VPIBITS */
+
+#ifdef RCQ_SUPPORT
+#define NS_CFG_RAWIE_OPT NS_CFG_RAWIE
+#else
+#define NS_CFG_RAWIE_OPT 0x00000000
+#endif /* RCQ_SUPPORT */
+
+#ifdef ENABLE_TSQFIE
+#define NS_CFG_TSQFIE_OPT NS_CFG_TSQFIE
+#else
+#define NS_CFG_TSQFIE_OPT 0x00000000
+#endif /* ENABLE_TSQFIE */
+
+
+/* PCI stuff ******************************************************************/
+
+#ifndef PCI_VENDOR_ID_IDT
+#define PCI_VENDOR_ID_IDT 0x111D
+#endif /* PCI_VENDOR_ID_IDT */
+
+#ifndef PCI_DEVICE_ID_IDT_IDT77201
+#define PCI_DEVICE_ID_IDT_IDT77201 0x0001
+#endif /* PCI_DEVICE_ID_IDT_IDT77201 */
+
+
+
+/* Device driver structures ***************************************************/
+
+
+typedef struct tsq_info
+{
+   void *org;
+   ns_tsi *base;
+   ns_tsi *next;
+   ns_tsi *last;
+} tsq_info;
+
+
+typedef struct scq_info
+{
+   void *org;
+   ns_scqe *base;
+   ns_scqe *last;
+   ns_scqe *next;
+   volatile ns_scqe *tail;		/* Not related to the nicstar register */
+   unsigned num_entries;
+   struct sk_buff **skb;		/* Pointer to an array of pointers
+                                           to the sk_buffs used for tx */
+   u32 scd;				/* SRAM address of the corresponding
+                                           SCD */
+   int tbd_count;			/* Only meaningful on variable rate */
+   wait_queue_head_t scqfull_waitq;
+   volatile char full;			/* SCQ full indicator */
+   spinlock_t lock;			/* SCQ spinlock */
+#ifdef NS_DEBUG_SPINLOCKS
+   volatile long has_lock;
+   volatile int cpu_lock;
+#endif /* NS_DEBUG_SPINLOCKS */
+} scq_info;
+
+
+
+typedef struct rsq_info
+{
+   void *org;
+   ns_rsqe *base;
+   ns_rsqe *next;
+   ns_rsqe *last;
+} rsq_info;
+
+
+typedef struct skb_pool
+{
+   volatile int count;			/* number of buffers in the queue */
+   struct sk_buff_head queue;
+} skb_pool;
+
+/* NOTE: for small and large buffer pools, the count is not used, as the
+         actual value used for buffer management is the one read from the
+	 card. */
+
+
+typedef struct vc_map
+{
+   volatile unsigned int tx:1;				/* TX vc? */
+   volatile unsigned int rx:1;				/* RX vc? */
+   struct atm_vcc *tx_vcc, *rx_vcc;
+   struct sk_buff *rx_iov;		/* RX iovector skb */
+   scq_info *scq;			/* To keep track of the SCQ */
+   u32 cbr_scd;				/* SRAM address of the corresponding
+               				   SCD. 0x00000000 for UBR/VBR/ABR */
+   int tbd_count;
+} vc_map;
+
+
+struct ns_skb_data
+{
+	struct atm_vcc *vcc;
+	int iovcnt;
+};
+
+#define NS_SKB(skb) (((struct ns_skb_data *) (skb)->cb))
+
+
+typedef struct ns_dev
+{
+   int index;				/* Card ID to the device driver */
+   int sram_size;			/* In k x 32bit words. 32 or 128 */
+   void __iomem *membase;		/* Card's memory base address */
+   unsigned long max_pcr;
+   int rct_size;			/* Number of entries */
+   int vpibits;
+   int vcibits;
+   struct pci_dev *pcidev;
+   struct atm_dev *atmdev;
+   tsq_info tsq;
+   rsq_info rsq;
+   scq_info *scq0, *scq1, *scq2;	/* VBR SCQs */
+   skb_pool sbpool;			/* Small buffers */
+   skb_pool lbpool;			/* Large buffers */
+   skb_pool hbpool;			/* Pre-allocated huge buffers */
+   skb_pool iovpool;			/* iovector buffers */
+   volatile int efbie;			/* Empty free buf. queue int. enabled */
+   volatile u32 tst_addr;		/* SRAM address of the TST in use */
+   volatile int tst_free_entries;
+   vc_map vcmap[NS_MAX_RCTSIZE];
+   vc_map *tste2vc[NS_TST_NUM_ENTRIES];
+   vc_map *scd2vc[NS_FRSCD_NUM];
+   buf_nr sbnr;
+   buf_nr lbnr;
+   buf_nr hbnr;
+   buf_nr iovnr;
+   int sbfqc;
+   int lbfqc;
+   u32 sm_handle;
+   u32 sm_addr;
+   u32 lg_handle;
+   u32 lg_addr;
+   struct sk_buff *rcbuf;		/* Current raw cell buffer */
+   u32 rawch;				/* Raw cell queue head */
+   unsigned intcnt;			/* Interrupt counter */
+   spinlock_t int_lock;		/* Interrupt lock */
+   spinlock_t res_lock;		/* Card resource lock */
+#ifdef NS_DEBUG_SPINLOCKS
+   volatile long has_int_lock;
+   volatile int cpu_int;
+   volatile long has_res_lock;
+   volatile int cpu_res;
+#endif /* NS_DEBUG_SPINLOCKS */
+} ns_dev;
+
+
+   /* NOTE: Each tste2vc entry relates a given TST entry to the corresponding
+            CBR vc. If the entry is not allocated, it must be NULL.
+	    
+	    There are two TSTs so the driver can modify them on the fly
+	    without stopping the transmission.
+	    
+	    scd2vc allows us to find out unused fixed rate SCDs, because
+	    they must have a NULL pointer here. */
+
+
+#endif /* _LINUX_NICSTAR_H_ */
