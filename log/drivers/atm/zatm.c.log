commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index d5c76b50d357..57f97b95a453 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* drivers/atm/zatm.c - ZeitNet ZN122x device driver */
  
 /* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */

commit 64b9d16e2d02ca6e5dc8fcd30cfd52b0ecaaa8f4
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Wed Oct 17 11:04:19 2018 -0700

    atm: zatm: Fix empty body Clang warnings
    
    Clang warns:
    
    drivers/atm/zatm.c:513:7: error: while loop has empty body
    [-Werror,-Wempty-body]
            zwait;
                 ^
    drivers/atm/zatm.c:513:7: note: put the semicolon on a separate line to
    silence this warning
    
    Get rid of this warning by using an empty do-while loop. While we're at
    it, add parentheses to make it clear that this is a function-like macro.
    
    Link: https://github.com/ClangBuiltLinux/linux/issues/42
    Suggested-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index e89146ddede6..d5c76b50d357 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -126,7 +126,7 @@ static unsigned long dummy[2] = {0,0};
 #define zin_n(r) inl(zatm_dev->base+r*4)
 #define zin(r) inl(zatm_dev->base+uPD98401_##r*4)
 #define zout(v,r) outl(v,zatm_dev->base+uPD98401_##r*4)
-#define zwait while (zin(CMR) & uPD98401_BUSY)
+#define zwait() do {} while (zin(CMR) & uPD98401_BUSY)
 
 /* RX0, RX1, TX0, TX1 */
 static const int mbx_entries[NR_MBX] = { 1024,1024,1024,1024 };
@@ -140,7 +140,7 @@ static const int mbx_esize[NR_MBX] = { 16,16,4,4 }; /* entry size in bytes */
 
 static void zpokel(struct zatm_dev *zatm_dev,u32 value,u32 addr)
 {
-	zwait;
+	zwait();
 	zout(value,CER);
 	zout(uPD98401_IND_ACC | uPD98401_IA_BALL |
 	    (uPD98401_IA_TGT_CM << uPD98401_IA_TGT_SHIFT) | addr,CMR);
@@ -149,10 +149,10 @@ static void zpokel(struct zatm_dev *zatm_dev,u32 value,u32 addr)
 
 static u32 zpeekl(struct zatm_dev *zatm_dev,u32 addr)
 {
-	zwait;
+	zwait();
 	zout(uPD98401_IND_ACC | uPD98401_IA_BALL | uPD98401_IA_RW |
 	  (uPD98401_IA_TGT_CM << uPD98401_IA_TGT_SHIFT) | addr,CMR);
-	zwait;
+	zwait();
 	return zin(CER);
 }
 
@@ -241,7 +241,7 @@ static void refill_pool(struct atm_dev *dev,int pool)
 	}
 	if (first) {
 		spin_lock_irqsave(&zatm_dev->lock, flags);
-		zwait;
+		zwait();
 		zout(virt_to_bus(first),CER);
 		zout(uPD98401_ADD_BAT | (pool << uPD98401_POOL_SHIFT) | count,
 		    CMR);
@@ -508,9 +508,9 @@ static int open_rx_first(struct atm_vcc *vcc)
 	}
 	if (zatm_vcc->pool < 0) return -EMSGSIZE;
 	spin_lock_irqsave(&zatm_dev->lock, flags);
-	zwait;
+	zwait();
 	zout(uPD98401_OPEN_CHAN,CMR);
-	zwait;
+	zwait();
 	DPRINTK("0x%x 0x%x\n",zin(CMR),zin(CER));
 	chan = (zin(CMR) & uPD98401_CHAN_ADDR) >> uPD98401_CHAN_ADDR_SHIFT;
 	spin_unlock_irqrestore(&zatm_dev->lock, flags);
@@ -571,21 +571,21 @@ static void close_rx(struct atm_vcc *vcc)
 		pos = vcc->vci >> 1;
 		shift = (1-(vcc->vci & 1)) << 4;
 		zpokel(zatm_dev,zpeekl(zatm_dev,pos) & ~(0xffff << shift),pos);
-		zwait;
+		zwait();
 		zout(uPD98401_NOP,CMR);
-		zwait;
+		zwait();
 		zout(uPD98401_NOP,CMR);
 		spin_unlock_irqrestore(&zatm_dev->lock, flags);
 	}
 	spin_lock_irqsave(&zatm_dev->lock, flags);
-	zwait;
+	zwait();
 	zout(uPD98401_DEACT_CHAN | uPD98401_CHAN_RT | (zatm_vcc->rx_chan <<
 	    uPD98401_CHAN_ADDR_SHIFT),CMR);
-	zwait;
+	zwait();
 	udelay(10); /* why oh why ... ? */
 	zout(uPD98401_CLOSE_CHAN | uPD98401_CHAN_RT | (zatm_vcc->rx_chan <<
 	    uPD98401_CHAN_ADDR_SHIFT),CMR);
-	zwait;
+	zwait();
 	if (!(zin(CMR) & uPD98401_CHAN_ADDR))
 		printk(KERN_CRIT DEV_LABEL "(itf %d): can't close RX channel "
 		    "%d\n",vcc->dev->number,zatm_vcc->rx_chan);
@@ -699,7 +699,7 @@ printk("NONONONOO!!!!\n");
 	skb_queue_tail(&zatm_vcc->tx_queue,skb);
 	DPRINTK("QRP=0x%08lx\n",zpeekl(zatm_dev,zatm_vcc->tx_chan*VC_SIZE/4+
 	  uPD98401_TXVC_QRP));
-	zwait;
+	zwait();
 	zout(uPD98401_TX_READY | (zatm_vcc->tx_chan <<
 	    uPD98401_CHAN_ADDR_SHIFT),CMR);
 	spin_unlock_irqrestore(&zatm_dev->lock, flags);
@@ -891,12 +891,12 @@ static void close_tx(struct atm_vcc *vcc)
 	}
 	spin_lock_irqsave(&zatm_dev->lock, flags);
 #if 0
-	zwait;
+	zwait();
 	zout(uPD98401_DEACT_CHAN | (chan << uPD98401_CHAN_ADDR_SHIFT),CMR);
 #endif
-	zwait;
+	zwait();
 	zout(uPD98401_CLOSE_CHAN | (chan << uPD98401_CHAN_ADDR_SHIFT),CMR);
-	zwait;
+	zwait();
 	if (!(zin(CMR) & uPD98401_CHAN_ADDR))
 		printk(KERN_CRIT DEV_LABEL "(itf %d): can't close TX channel "
 		    "%d\n",vcc->dev->number,chan);
@@ -926,9 +926,9 @@ static int open_tx_first(struct atm_vcc *vcc)
 	zatm_vcc->tx_chan = 0;
 	if (vcc->qos.txtp.traffic_class == ATM_NONE) return 0;
 	spin_lock_irqsave(&zatm_dev->lock, flags);
-	zwait;
+	zwait();
 	zout(uPD98401_OPEN_CHAN,CMR);
-	zwait;
+	zwait();
 	DPRINTK("0x%x 0x%x\n",zin(CMR),zin(CER));
 	chan = (zin(CMR) & uPD98401_CHAN_ADDR) >> uPD98401_CHAN_ADDR_SHIFT;
 	spin_unlock_irqrestore(&zatm_dev->lock, flags);
@@ -1557,7 +1557,7 @@ static void zatm_phy_put(struct atm_dev *dev,unsigned char value,
 	struct zatm_dev *zatm_dev;
 
 	zatm_dev = ZATM_DEV(dev);
-	zwait;
+	zwait();
 	zout(value,CER);
 	zout(uPD98401_IND_ACC | uPD98401_IA_B0 |
 	    (uPD98401_IA_TGT_PHY << uPD98401_IA_TGT_SHIFT) | addr,CMR);
@@ -1569,10 +1569,10 @@ static unsigned char zatm_phy_get(struct atm_dev *dev,unsigned long addr)
 	struct zatm_dev *zatm_dev;
 
 	zatm_dev = ZATM_DEV(dev);
-	zwait;
+	zwait();
 	zout(uPD98401_IND_ACC | uPD98401_IA_B0 | uPD98401_IA_RW |
 	  (uPD98401_IA_TGT_PHY << uPD98401_IA_TGT_SHIFT) | addr,CMR);
-	zwait;
+	zwait();
 	return zin(CER) & 0xff;
 }
 

commit 5cd3da4ba2397ef07226ca2aa5094ed21ff8198f
Merge: f6779e4e53b6 d0fbad0aec1d
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jul 3 10:26:50 2018 +0900

    Merge ra.kernel.org:/pub/scm/linux/kernel/git/davem/net
    
    Simple overlapping changes in stmmac driver.
    
    Adjust skb_gro_flush_final_remcsum function signature to make GRO list
    changes in net-next, as per Stephen Rothwell's example merge
    resolution.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 50d4feb5e60e64a8c3053414483e7457be2f111d
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Jul 2 08:37:21 2018 +0100

    atm: zatm: remove redundant pointer zatm_dev
    
    Pointer zatm_dev is being assigned but is never used hence it is redundant
    and can be removed.
    
    Cleans up clang warning:
    warning: variable 'zatm_dev' set but not used [-Wunused-but-set-variable]
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index a8d2eb0ceb8d..1e41cfbb3708 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -1385,14 +1385,12 @@ static void zatm_close(struct atm_vcc *vcc)
 
 static int zatm_open(struct atm_vcc *vcc)
 {
-	struct zatm_dev *zatm_dev;
 	struct zatm_vcc *zatm_vcc;
 	short vpi = vcc->vpi;
 	int vci = vcc->vci;
 	int error;
 
 	DPRINTK(">zatm_open\n");
-	zatm_dev = ZATM_DEV(vcc->dev);
 	if (!test_bit(ATM_VF_PARTIAL,&vcc->flags))
 		vcc->dev_data = NULL;
 	if (vci != ATM_VPI_UNSPEC && vpi != ATM_VCI_UNSPEC)

commit ced9e191501e52b95e1b57b8e0db00943869eed0
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Fri Jun 29 13:28:07 2018 -0500

    atm: zatm: Fix potential Spectre v1
    
    pool can be indirectly controlled by user-space, hence leading to
    a potential exploitation of the Spectre variant 1 vulnerability.
    
    This issue was detected with the help of Smatch:
    
    drivers/atm/zatm.c:1491 zatm_ioctl() warn: potential spectre issue
    'zatm_dev->pool_info' (local cap)
    
    Fix this by sanitizing pool before using it to index
    zatm_dev->pool_info
    
    Notice that given that speculation windows are large, the policy is
    to kill the speculation on the first load and not worry if it can be
    completed with a dependent load/store [1].
    
    [1] https://marc.info/?l=linux-kernel&m=152449131114778&w=2
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index a8d2eb0ceb8d..2c288d1f42bb 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -1483,6 +1483,8 @@ static int zatm_ioctl(struct atm_dev *dev,unsigned int cmd,void __user *arg)
 					return -EFAULT;
 				if (pool < 0 || pool > ZATM_LAST_POOL)
 					return -EINVAL;
+				pool = array_index_nospec(pool,
+							  ZATM_LAST_POOL + 1);
 				if (copy_from_user(&info,
 				    &((struct zatm_pool_req __user *) arg)->info,
 				    sizeof(info))) return -EFAULT;

commit f9c6442a8f0b1dde9e755eb4ff6fa22bcce4eabc
Author: Ivan Bornyakov <brnkv.i1@gmail.com>
Date:   Fri May 25 20:49:52 2018 +0300

    atm: zatm: fix memcmp casting
    
    memcmp() returns int, but eprom_try_esi() cast it to unsigned char. One
    can lose significant bits and get 0 from non-0 value returned by the
    memcmp().
    
    Signed-off-by: Ivan Bornyakov <brnkv.i1@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 9c9a22958717..a8d2eb0ceb8d 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -1151,8 +1151,8 @@ static void eprom_get_byte(struct zatm_dev *zatm_dev, unsigned char *byte,
 }
 
 
-static unsigned char eprom_try_esi(struct atm_dev *dev, unsigned short cmd,
-				   int offset, int swap)
+static int eprom_try_esi(struct atm_dev *dev, unsigned short cmd, int offset,
+			 int swap)
 {
 	unsigned char buf[ZEPROM_SIZE];
 	struct zatm_dev *zatm_dev;

commit 2be147f7459db5bbf292e0a6f135037b55e20b39
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu May 3 13:17:12 2018 -0500

    atm: zatm: Fix potential Spectre v1
    
    pool can be indirectly controlled by user-space, hence leading to
    a potential exploitation of the Spectre variant 1 vulnerability.
    
    This issue was detected with the help of Smatch:
    
    drivers/atm/zatm.c:1462 zatm_ioctl() warn: potential spectre issue
    'zatm_dev->pool_info' (local cap)
    
    Fix this by sanitizing pool before using it to index
    zatm_dev->pool_info
    
    Notice that given that speculation windows are large, the policy is
    to kill the speculation on the first load and not worry if it can be
    completed with a dependent load/store [1].
    
    [1] https://marc.info/?l=linux-kernel&m=152449131114778&w=2
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 1ef67db03c8e..9c9a22958717 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -28,6 +28,7 @@
 #include <asm/io.h>
 #include <linux/atomic.h>
 #include <linux/uaccess.h>
+#include <linux/nospec.h>
 
 #include "uPD98401.h"
 #include "uPD98402.h"
@@ -1458,6 +1459,8 @@ static int zatm_ioctl(struct atm_dev *dev,unsigned int cmd,void __user *arg)
 					return -EFAULT;
 				if (pool < 0 || pool > ZATM_LAST_POOL)
 					return -EINVAL;
+				pool = array_index_nospec(pool,
+							  ZATM_LAST_POOL + 1);
 				spin_lock_irqsave(&zatm_dev->lock, flags);
 				info = zatm_dev->pool_info[pool];
 				if (cmd == ZATM_GETPOOLZ) {

commit 7a68ada6ec7d88c68057d3a4c2a517eb94289976
Merge: 760446f96767 96080f697786
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Jul 21 03:38:43 2017 +0100

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net

commit 799f917233f6ed242ee9416bf80b14819f0c97f3
Author: Christophe Jaillet <christophe.jaillet@wanadoo.fr>
Date:   Mon Jul 17 19:42:41 2017 +0200

    atm: zatm: Fix an error handling path in 'zatm_init_one()'
    
    If 'dma_set_mask_and_coherent()' fails, we must undo the previous
    'pci_request_regions()' call.
    Adjust corresponding 'goto' to jump at the right place of the error
    handling path.
    
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 292dec18ffb8..07bdd51b3b9a 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -1613,7 +1613,7 @@ static int zatm_init_one(struct pci_dev *pci_dev,
 
 	ret = dma_set_mask_and_coherent(&pci_dev->dev, DMA_BIT_MASK(32));
 	if (ret < 0)
-		goto out_disable;
+		goto out_release;
 
 	zatm_dev->pci_dev = pci_dev;
 	dev->dev_data = zatm_dev;

commit aea39c7f4a56dd2147270b925ed0f107f9403be9
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Sun Jul 16 15:02:37 2017 +0530

    atm: zatm: constify pci_device_id.
    
    pci_device_id are not supposed to change at runtime. All functions
    working with pci_device_id provided by <linux/pci.h> work with
    const pci_device_id. So mark the non-const structs as const.
    
    File size before:
       text    data     bss     dec     hex filename
      14350     352      40   14742    3996 drivers/atm/zatm.o
    
    File size After adding 'const':
       text    data     bss     dec     hex filename
      14446     256      40   14742    3996 drivers/atm/zatm.o
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 292dec18ffb8..d3aa7482d1f7 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -1642,7 +1642,7 @@ static int zatm_init_one(struct pci_dev *pci_dev,
 
 MODULE_LICENSE("GPL");
 
-static struct pci_device_id zatm_pci_tbl[] = {
+static const struct pci_device_id zatm_pci_tbl[] = {
 	{ PCI_VDEVICE(ZEITNET, PCI_DEVICE_ID_ZEITNET_1221), ZATM_COPPER },
 	{ PCI_VDEVICE(ZEITNET, PCI_DEVICE_ID_ZEITNET_1225), 0 },
 	{ 0, }

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index d3dc95484161..292dec18ffb8 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -27,7 +27,7 @@
 #include <asm/string.h>
 #include <asm/io.h>
 #include <linux/atomic.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 #include "uPD98401.h"
 #include "uPD98402.h"

commit cf9932a9414e241571008edd7412ab22f02b5704
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Sep 10 10:38:04 2016 +0200

    ATM-ZeitNet: Fix indentation for one DPRINTK() call in start_rx()
    
    Adjust the indentation for a call of the macro "DPRINTK" in this function.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 2cc9e2a63d3e..d3dc95484161 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -600,7 +600,7 @@ static int start_rx(struct atm_dev *dev)
 	struct zatm_dev *zatm_dev;
 	int i;
 
-DPRINTK("start_rx\n");
+	DPRINTK("start_rx\n");
 	zatm_dev = ZATM_DEV(dev);
 	zatm_dev->rx_map = kcalloc(zatm_dev->chans,
 				   sizeof(*zatm_dev->rx_map),

commit 0f0d0ed0870eca21e36dc520d7d9be292c103f80
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Sep 10 10:21:15 2016 +0200

    ATM-ZeitNet: Replace one kzalloc() call by kcalloc()
    
    * The script "checkpatch.pl" can point information out like the following.
    
      WARNING: Prefer kcalloc over kzalloc with multiply
    
      Thus fix the affected source code place.
    
    * Replace the specification of a data type by a pointer dereference
      to make the corresponding size determination a bit safer according to
      the Linux coding style convention.
    
    * Delete the local variable "size" which became unnecessary with
      this refactoring.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 218c6af60f21..2cc9e2a63d3e 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -598,12 +598,13 @@ static void close_rx(struct atm_vcc *vcc)
 static int start_rx(struct atm_dev *dev)
 {
 	struct zatm_dev *zatm_dev;
-	int size,i;
+	int i;
 
 DPRINTK("start_rx\n");
 	zatm_dev = ZATM_DEV(dev);
-	size = sizeof(struct atm_vcc *)*zatm_dev->chans;
-	zatm_dev->rx_map =  kzalloc(size,GFP_KERNEL);
+	zatm_dev->rx_map = kcalloc(zatm_dev->chans,
+				   sizeof(*zatm_dev->rx_map),
+				   GFP_KERNEL);
 	if (!zatm_dev->rx_map) return -ENOMEM;
 	/* set VPI/VCI split (use all VCIs and give what's left to VPIs) */
 	zpokel(zatm_dev,(1 << dev->ci_range.vci_bits)-1,uPD98401_VRR);

commit 5ad3ea3d3952dcbb8047f97fbfa49804ea53a53a
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Sep 10 10:07:38 2016 +0200

    ATM-ZeitNet: Improve a size determination in zatm_open()
    
    Replace the specification of a data structure by a pointer dereference
    as the parameter for the operator "sizeof" to make the corresponding size
    determination a bit safer according to the Linux coding style convention.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index d378ff2d3925..218c6af60f21 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -1399,7 +1399,7 @@ static int zatm_open(struct atm_vcc *vcc)
 	DPRINTK(DEV_LABEL "(itf %d): open %d.%d\n",vcc->dev->number,vcc->vpi,
 	    vcc->vci);
 	if (!test_bit(ATM_VF_PARTIAL,&vcc->flags)) {
-		zatm_vcc = kmalloc(sizeof(struct zatm_vcc),GFP_KERNEL);
+		zatm_vcc = kmalloc(sizeof(*zatm_vcc), GFP_KERNEL);
 		if (!zatm_vcc) {
 			clear_bit(ATM_VF_ADDR,&vcc->flags);
 			return -ENOMEM;

commit 32230ac1ccbd66f36bd6955eddc45fc06861c1b5
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Sep 10 09:55:53 2016 +0200

    ATM-ZeitNet: Use kmalloc_array() in start_tx()
    
    * A multiplication for the size determination of a memory allocation
      indicated that an array data structure should be processed.
      Thus use the corresponding function "kmalloc_array".
    
      This issue was detected by using the Coccinelle software.
    
    * Replace the specification of a data type by a pointer dereference
      to make the corresponding size determination a bit safer according to
      the Linux coding style convention.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index cecfb943762f..d378ff2d3925 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -998,8 +998,9 @@ static int start_tx(struct atm_dev *dev)
 
 	DPRINTK("start_tx\n");
 	zatm_dev = ZATM_DEV(dev);
-	zatm_dev->tx_map = kmalloc(sizeof(struct atm_vcc *)*
-	    zatm_dev->chans,GFP_KERNEL);
+	zatm_dev->tx_map = kmalloc_array(zatm_dev->chans,
+					 sizeof(*zatm_dev->tx_map),
+					 GFP_KERNEL);
 	if (!zatm_dev->tx_map) return -ENOMEM;
 	zatm_dev->tx_bw = ATM_OC3_PCR;
 	zatm_dev->free_shapers = (1 << NR_SHAPERS)-1;

commit ede58ef28e105de94475b2b69fa069c9a2ce6933
Author: chas williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
Date:   Fri Jan 16 08:57:21 2015 -0500

    atm: remove deprecated use of pci api
    
    Signed-off-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 969c3c29000c..cecfb943762f 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -1306,19 +1306,20 @@ static int zatm_start(struct atm_dev *dev)
 
 		if (!mbx_entries[i])
 			continue;
-		mbx = pci_alloc_consistent(pdev, 2*MBX_SIZE(i), &mbx_dma);
+		mbx = dma_alloc_coherent(&pdev->dev,
+					 2 * MBX_SIZE(i), &mbx_dma, GFP_KERNEL);
 		if (!mbx) {
 			error = -ENOMEM;
 			goto out;
 		}
 		/*
-		 * Alignment provided by pci_alloc_consistent() isn't enough
+		 * Alignment provided by dma_alloc_coherent() isn't enough
 		 * for this device.
 		 */
 		if (((unsigned long)mbx ^ mbx_dma) & 0xffff) {
 			printk(KERN_ERR DEV_LABEL "(itf %d): system "
 			       "bus incompatible with driver\n", dev->number);
-			pci_free_consistent(pdev, 2*MBX_SIZE(i), mbx, mbx_dma);
+			dma_free_coherent(&pdev->dev, 2*MBX_SIZE(i), mbx, mbx_dma);
 			error = -ENODEV;
 			goto out;
 		}
@@ -1354,9 +1355,9 @@ static int zatm_start(struct atm_dev *dev)
 	kfree(zatm_dev->tx_map);
 out:
 	while (i-- > 0) {
-		pci_free_consistent(pdev, 2*MBX_SIZE(i), 
-				    (void *)zatm_dev->mbx_start[i],
-				    zatm_dev->mbx_dma[i]);
+		dma_free_coherent(&pdev->dev, 2 * MBX_SIZE(i),
+				  (void *)zatm_dev->mbx_start[i],
+				  zatm_dev->mbx_dma[i]);
 	}
 	free_irq(zatm_dev->irq, dev);
 	goto done;
@@ -1608,6 +1609,10 @@ static int zatm_init_one(struct pci_dev *pci_dev,
 	if (ret < 0)
 		goto out_disable;
 
+	ret = dma_set_mask_and_coherent(&pci_dev->dev, DMA_BIT_MASK(32));
+	if (ret < 0)
+		goto out_disable;
+
 	zatm_dev->pci_dev = pci_dev;
 	dev->dev_data = zatm_dev;
 	zatm_dev->copper = (int)ent->driver_data;

commit 6c44512d06d3f6afcead304f051f4a06ed9be2cd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:25:04 2012 -0800

    Drivers: atm: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index abe4e20b0766..969c3c29000c 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -1094,8 +1094,8 @@ static irqreturn_t zatm_int(int irq,void *dev_id)
 /*----------------------------- (E)EPROM access -----------------------------*/
 
 
-static void __devinit eprom_set(struct zatm_dev *zatm_dev,unsigned long value,
-    unsigned short cmd)
+static void eprom_set(struct zatm_dev *zatm_dev, unsigned long value,
+		      unsigned short cmd)
 {
 	int error;
 
@@ -1105,8 +1105,7 @@ static void __devinit eprom_set(struct zatm_dev *zatm_dev,unsigned long value,
 }
 
 
-static unsigned long __devinit eprom_get(struct zatm_dev *zatm_dev,
-    unsigned short cmd)
+static unsigned long eprom_get(struct zatm_dev *zatm_dev, unsigned short cmd)
 {
 	unsigned int value;
 	int error;
@@ -1118,8 +1117,8 @@ static unsigned long __devinit eprom_get(struct zatm_dev *zatm_dev,
 }
 
 
-static void __devinit eprom_put_bits(struct zatm_dev *zatm_dev,
-    unsigned long data,int bits,unsigned short cmd)
+static void eprom_put_bits(struct zatm_dev *zatm_dev, unsigned long data,
+			   int bits, unsigned short cmd)
 {
 	unsigned long value;
 	int i;
@@ -1133,8 +1132,8 @@ static void __devinit eprom_put_bits(struct zatm_dev *zatm_dev,
 }
 
 
-static void __devinit eprom_get_byte(struct zatm_dev *zatm_dev,
-    unsigned char *byte,unsigned short cmd)
+static void eprom_get_byte(struct zatm_dev *zatm_dev, unsigned char *byte,
+			   unsigned short cmd)
 {
 	int i;
 
@@ -1149,8 +1148,8 @@ static void __devinit eprom_get_byte(struct zatm_dev *zatm_dev,
 }
 
 
-static unsigned char __devinit eprom_try_esi(struct atm_dev *dev,
-    unsigned short cmd,int offset,int swap)
+static unsigned char eprom_try_esi(struct atm_dev *dev, unsigned short cmd,
+				   int offset, int swap)
 {
 	unsigned char buf[ZEPROM_SIZE];
 	struct zatm_dev *zatm_dev;
@@ -1170,7 +1169,7 @@ static unsigned char __devinit eprom_try_esi(struct atm_dev *dev,
 }
 
 
-static void __devinit eprom_get_esi(struct atm_dev *dev)
+static void eprom_get_esi(struct atm_dev *dev)
 {
 	if (eprom_try_esi(dev,ZEPROM_V1_REG,ZEPROM_V1_ESI_OFF,1)) return;
 	(void) eprom_try_esi(dev,ZEPROM_V2_REG,ZEPROM_V2_ESI_OFF,0);
@@ -1180,7 +1179,7 @@ static void __devinit eprom_get_esi(struct atm_dev *dev)
 /*--------------------------------- entries ---------------------------------*/
 
 
-static int __devinit zatm_init(struct atm_dev *dev)
+static int zatm_init(struct atm_dev *dev)
 {
 	struct zatm_dev *zatm_dev;
 	struct pci_dev *pci_dev;
@@ -1257,7 +1256,7 @@ static int __devinit zatm_init(struct atm_dev *dev)
 }
 
 
-static int __devinit zatm_start(struct atm_dev *dev)
+static int zatm_start(struct atm_dev *dev)
 {
 	struct zatm_dev *zatm_dev = ZATM_DEV(dev);
 	struct pci_dev *pdev = zatm_dev->pci_dev;
@@ -1584,8 +1583,8 @@ static const struct atmdev_ops ops = {
 	.change_qos	= zatm_change_qos,
 };
 
-static int __devinit zatm_init_one(struct pci_dev *pci_dev,
-				   const struct pci_device_id *ent)
+static int zatm_init_one(struct pci_dev *pci_dev,
+			 const struct pci_device_id *ent)
 {
 	struct atm_dev *dev;
 	struct zatm_dev *zatm_dev;
@@ -1636,7 +1635,7 @@ static int __devinit zatm_init_one(struct pci_dev *pci_dev,
 
 MODULE_LICENSE("GPL");
 
-static struct pci_device_id zatm_pci_tbl[] __devinitdata = {
+static struct pci_device_id zatm_pci_tbl[] = {
 	{ PCI_VDEVICE(ZEITNET, PCI_DEVICE_ID_ZEITNET_1221), ZATM_COPPER },
 	{ PCI_VDEVICE(ZEITNET, PCI_DEVICE_ID_ZEITNET_1225), 0 },
 	{ 0, }

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index d889f56e8d8c..abe4e20b0766 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -24,7 +24,6 @@
 #include <linux/wait.h>
 #include <linux/slab.h>
 #include <asm/byteorder.h>
-#include <asm/system.h>
 #include <asm/string.h>
 #include <asm/io.h>
 #include <linux/atomic.h>

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 7f8c5132ff32..d889f56e8d8c 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -27,7 +27,7 @@
 #include <asm/system.h>
 #include <asm/string.h>
 #include <asm/io.h>
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 #include <asm/uaccess.h>
 
 #include "uPD98401.h"

commit a6b7a407865aab9f849dd99a71072b7cd1175116
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Jun 6 10:43:46 2011 +0000

    net: remove interrupt.h inclusion from netdevice.h
    
    * remove interrupt.g inclusion from netdevice.h -- not needed
    * fixup fallout, add interrupt.h and hardirq.h back where needed.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 624917902b65..7f8c5132ff32 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -16,6 +16,7 @@
 #include <linux/delay.h>
 #include <linux/uio.h>
 #include <linux/init.h>
+#include <linux/interrupt.h>
 #include <linux/dma-mapping.h>
 #include <linux/atm_zatm.h>
 #include <linux/capability.h>

commit d9ca676bcb26e1fdff9265a3e70f697cd381c889
Author: Dan Williams <dcbw@redhat.com>
Date:   Wed Dec 8 19:40:47 2010 +0000

    atm: correct sysfs 'device' link creation and parent relationships
    
    The ATM subsystem was incorrectly creating the 'device' link for ATM
    nodes in sysfs.  This led to incorrect device/parent relationships
    exposed by sysfs and udev.  Instead of rolling the 'device' link by hand
    in the generic ATM code, pass each ATM driver's bus device down to the
    sysfs code and let sysfs do this stuff correctly.
    
    Signed-off-by: Dan Williams <dcbw@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 4e885d2da49c..624917902b65 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -1597,7 +1597,7 @@ static int __devinit zatm_init_one(struct pci_dev *pci_dev,
 		goto out;
 	}
 
-	dev = atm_dev_register(DEV_LABEL, &ops, -1, NULL);
+	dev = atm_dev_register(DEV_LABEL, &pci_dev->dev, &ops, -1, NULL);
 	if (!dev)
 		goto out_free;
 

commit c9634ac1b79bf7b26ceabff16c1fd36943cf5511
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Thu Jul 15 08:49:32 2010 +0000

    atm: Convert pci_table entries to PCI_VDEVICE (if PCI_ANY_ID is used)
    
    This patch converts pci_table entries, where .subvendor=PCI_ANY_ID and
    .subdevice=PCI_ANY_ID, .class=0 and .class_mask=0, to use the
    PCI_VDEVICE macro, and thus improves readability.
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 702accec89e9..4e885d2da49c 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -1637,10 +1637,8 @@ static int __devinit zatm_init_one(struct pci_dev *pci_dev,
 MODULE_LICENSE("GPL");
 
 static struct pci_device_id zatm_pci_tbl[] __devinitdata = {
-	{ PCI_VENDOR_ID_ZEITNET, PCI_DEVICE_ID_ZEITNET_1221,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, ZATM_COPPER },
-	{ PCI_VENDOR_ID_ZEITNET, PCI_DEVICE_ID_ZEITNET_1225,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_VDEVICE(ZEITNET, PCI_DEVICE_ID_ZEITNET_1221), ZATM_COPPER },
+	{ PCI_VDEVICE(ZEITNET, PCI_DEVICE_ID_ZEITNET_1225), 0 },
 	{ 0, }
 };
 MODULE_DEVICE_TABLE(pci, zatm_pci_tbl);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 2e9635be048c..702accec89e9 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -21,6 +21,7 @@
 #include <linux/capability.h>
 #include <linux/bitops.h>
 #include <linux/wait.h>
+#include <linux/slab.h>
 #include <asm/byteorder.h>
 #include <asm/system.h>
 #include <asm/string.h>

commit b7058842c940ad2c08dd829b21e5c92ebe3b8758
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Sep 30 16:12:20 2009 -0700

    net: Make setsockopt() optlen be unsigned.
    
    This provides safety against negative optlen at the type
    level instead of depending upon (sometimes non-trivial)
    checks against this sprinkled all over the the place, in
    each and every implementation.
    
    Based upon work done by Arjan van de Ven and feedback
    from Linus Torvalds.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 752b1ba81f7e..2e9635be048c 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -1517,7 +1517,7 @@ static int zatm_getsockopt(struct atm_vcc *vcc,int level,int optname,
 
 
 static int zatm_setsockopt(struct atm_vcc *vcc,int level,int optname,
-    void __user *optval,int optlen)
+    void __user *optval,unsigned int optlen)
 {
 	return -EINVAL;
 }

commit 6a19309db0a02d821494f4df754046c85a230627
Author: Julia Lawall <julia@diku.dk>
Date:   Mon Sep 22 19:22:58 2008 -0700

    drivers/atm: Use DIV_ROUND_UP
    
    The kernel.h macro DIV_ROUND_UP performs the computation (((n) + (d) - 1) /
    (d)) but is perhaps more readable.
    
    In the case of the file drivers/atm/eni.c, I am a little bit suspicious of
    the -1 at the end of the affected expression.  Please check that that is
    what is wanted.
    
    An extract of the semantic patch that makes this change is as follows:
    (http://www.emn.fr/x-info/coccinelle/)
    
    // <smpl>
    @haskernel@
    @@
    
    #include <linux/kernel.h>
    
    @depends on haskernel@
    expression n,d;
    @@
    
    (
    - (n + d - 1) / d
    + DIV_ROUND_UP(n,d)
    |
    - (n + (d - 1)) / d
    + DIV_ROUND_UP(n,d)
    )
    
    @depends on haskernel@
    expression n,d;
    @@
    
    - DIV_ROUND_UP((n),d)
    + DIV_ROUND_UP(n,d)
    
    @depends on haskernel@
    expression n,d;
    @@
    
    - DIV_ROUND_UP(n,(d))
    + DIV_ROUND_UP(n,d)
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 58583c6ac5be..752b1ba81f7e 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -496,8 +496,8 @@ static int open_rx_first(struct atm_vcc *vcc)
 			vcc->qos.rxtp.max_sdu = 65464;
 			/* fix this - we may want to receive 64kB SDUs
 			   later */
-		cells = (vcc->qos.rxtp.max_sdu+ATM_AAL5_TRAILER+
-		    ATM_CELL_PAYLOAD-1)/ATM_CELL_PAYLOAD;
+		cells = DIV_ROUND_UP(vcc->qos.rxtp.max_sdu + ATM_AAL5_TRAILER,
+				ATM_CELL_PAYLOAD);
 		zatm_vcc->pool = pool_index(cells*ATM_CELL_PAYLOAD);
 	}
 	else {
@@ -820,7 +820,7 @@ static int alloc_shaper(struct atm_dev *dev,int *pcr,int min,int max,int ubr)
 			}
 			else {
 				i = 255;
-				m = (ATM_OC3_PCR*255+max-1)/max;
+				m = DIV_ROUND_UP(ATM_OC3_PCR*255, max);
 			}
 		}
 		if (i > m) {

commit a6343afb6e16b65b9f0b264f94f8207212e7e3ae
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Jul 17 05:39:58 2007 -0400

    drivers/*: mark variables with uninitialized_var()
    
    Mark variables in drivers/* with uninitialized_var() if such a warning
    appears, and analysis proves that the var is initialized properly on all
    paths it is used.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 020a87a476c8..58583c6ac5be 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -915,7 +915,7 @@ static int open_tx_first(struct atm_vcc *vcc)
 	unsigned long flags;
 	u32 *loop;
 	unsigned short chan;
-	int pcr,unlimited;
+	int unlimited;
 
 	DPRINTK("open_tx_first\n");
 	zatm_dev = ZATM_DEV(vcc->dev);
@@ -936,6 +936,8 @@ static int open_tx_first(struct atm_vcc *vcc)
 	    vcc->qos.txtp.max_pcr >= ATM_OC3_PCR);
 	if (unlimited && zatm_dev->ubr != -1) zatm_vcc->shaper = zatm_dev->ubr;
 	else {
+		int uninitialized_var(pcr);
+
 		if (unlimited) vcc->qos.txtp.max_sdu = ATM_MAX_AAL5_PDU;
 		if ((zatm_vcc->shaper = alloc_shaper(vcc->dev,&pcr,
 		    vcc->qos.txtp.min_pcr,vcc->qos.txtp.max_pcr,unlimited))

commit 44c10138fd4bbc4b6d6bff0873c24902f2a9da65
Author: Auke Kok <auke-jan.h.kok@intel.com>
Date:   Fri Jun 8 15:46:36 2007 -0700

    PCI: Change all drivers to use pci_device->revision
    
    Instead of all drivers reading pci config space to get the revision
    ID, they can now use the pci_device->revision member.
    
    This exposes some issues where drivers where reading a word or a dword
    for the revision number, and adding useless error-handling around the
    read. Some drivers even just read it for no purpose of all.
    
    In devices where the revision ID is being copied over and used in what
    appears to be the equivalent of hotpath, I have left the copy code
    and the cached copy as not to influence the driver's performance.
    
    Compile tested with make all{yes,mod}config on x86_64 and i386.
    
    Signed-off-by: Auke Kok <auke-jan.h.kok@intel.com>
    Acked-by: Dave Jones <davej@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 2ad2527cf5b3..020a87a476c8 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -1182,7 +1182,6 @@ static int __devinit zatm_init(struct atm_dev *dev)
 	struct zatm_dev *zatm_dev;
 	struct pci_dev *pci_dev;
 	unsigned short command;
-	unsigned char revision;
 	int error,i,last;
 	unsigned long t0,t1,t2;
 
@@ -1192,8 +1191,7 @@ static int __devinit zatm_init(struct atm_dev *dev)
 	pci_dev = zatm_dev->pci_dev;
 	zatm_dev->base = pci_resource_start(pci_dev, 0);
 	zatm_dev->irq = pci_dev->irq;
-	if ((error = pci_read_config_word(pci_dev,PCI_COMMAND,&command)) ||
-	    (error = pci_read_config_byte(pci_dev,PCI_REVISION_ID,&revision))) {
+	if ((error = pci_read_config_word(pci_dev,PCI_COMMAND,&command))) {
 		printk(KERN_ERR DEV_LABEL "(itf %d): init error 0x%02x\n",
 		    dev->number,error);
 		return -EINVAL;
@@ -1206,7 +1204,7 @@ static int __devinit zatm_init(struct atm_dev *dev)
 	}
 	eprom_get_esi(dev);
 	printk(KERN_NOTICE DEV_LABEL "(itf %d): rev.%d,base=0x%x,irq=%d,",
-	    dev->number,revision,zatm_dev->base,zatm_dev->irq);
+	    dev->number,pci_dev->revision,zatm_dev->base,zatm_dev->irq);
 	/* reset uPD98401 */
 	zout(0,SWR);
 	while (!(zin(GSR) & uPD98401_INT_IND));

commit ebf88a9e7bfd7251fa80888c29b60aa4c86e2941
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Wed Mar 14 09:05:01 2007 +0000

    [PATCH] zatm __init abuse
    
    zatm_init() and zatm_start() should be __devinit (the former is
    not module init, despite the name - it's a helper for PCI ->probe())
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 0d7091e2077f..2ad2527cf5b3 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -1177,7 +1177,7 @@ static void __devinit eprom_get_esi(struct atm_dev *dev)
 /*--------------------------------- entries ---------------------------------*/
 
 
-static int __init zatm_init(struct atm_dev *dev)
+static int __devinit zatm_init(struct atm_dev *dev)
 {
 	struct zatm_dev *zatm_dev;
 	struct pci_dev *pci_dev;
@@ -1256,7 +1256,7 @@ static int __init zatm_init(struct atm_dev *dev)
 }
 
 
-static int __init zatm_start(struct atm_dev *dev)
+static int __devinit zatm_start(struct atm_dev *dev)
 {
 	struct zatm_dev *zatm_dev = ZATM_DEV(dev);
 	struct pci_dev *pdev = zatm_dev->pci_dev;

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 756d4f760da3..0d7091e2077f 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -4,7 +4,6 @@
 
 
 #include <linux/module.h>
-#include <linux/sched.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/pci.h>

commit 5cbded585d129d0226cb48ac4202b253c781be26
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Wed Dec 13 00:35:56 2006 -0800

    [PATCH] getting rid of all casts of k[cmz]alloc() calls
    
    Run this:
    
            #!/bin/sh
            for f in $(grep -Erl "\([^\)]*\) *k[cmz]alloc" *) ; do
              echo "De-casting $f..."
              perl -pi -e "s/ ?= ?\([^\)]*\) *(k[cmz]alloc) *\(/ = \1\(/" $f
            done
    
    And then go through and reinstate those cases where code is casting pointers
    to non-pointers.
    
    And then drop a few hunks which conflicted with outstanding work.
    
    Cc: Russell King <rmk@arm.linux.org.uk>, Ian Molton <spyro@f2s.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Paul Fulghum <paulkf@microgate.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Karsten Keil <kkeil@suse.de>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Ian Kent <raven@themaw.net>
    Cc: Steven French <sfrench@us.ibm.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 7df0f373188e..756d4f760da3 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -996,7 +996,7 @@ static int start_tx(struct atm_dev *dev)
 
 	DPRINTK("start_tx\n");
 	zatm_dev = ZATM_DEV(dev);
-	zatm_dev->tx_map = (struct atm_vcc **) kmalloc(sizeof(struct atm_vcc *)*
+	zatm_dev->tx_map = kmalloc(sizeof(struct atm_vcc *)*
 	    zatm_dev->chans,GFP_KERNEL);
 	if (!zatm_dev->tx_map) return -ENOMEM;
 	zatm_dev->tx_bw = ATM_OC3_PCR;
@@ -1591,7 +1591,7 @@ static int __devinit zatm_init_one(struct pci_dev *pci_dev,
 	struct zatm_dev *zatm_dev;
 	int ret = -ENOMEM;
 
-	zatm_dev = (struct zatm_dev *) kmalloc(sizeof(*zatm_dev), GFP_KERNEL);
+	zatm_dev = kmalloc(sizeof(*zatm_dev), GFP_KERNEL);
 	if (!zatm_dev) {
 		printk(KERN_EMERG "%s: memory shortage\n", DEV_LABEL);
 		goto out;

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 083c5d3f2e18..7df0f373188e 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -1012,7 +1012,7 @@ static int start_tx(struct atm_dev *dev)
 /*------------------------------- interrupts --------------------------------*/
 
 
-static irqreturn_t zatm_int(int irq,void *dev_id,struct pt_regs *regs)
+static irqreturn_t zatm_int(int irq,void *dev_id)
 {
 	struct atm_dev *dev;
 	struct zatm_dev *zatm_dev;

commit 3e0c0ac84c01f41fb266bcdd2802708409901bed
Author: Chas Williams <chas@cmf.nrl.navy.mil>
Date:   Tue Oct 3 16:28:31 2006 -0700

    [ATM]: [zatm] always *pcr in alloc_shaper()
    
    Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index c491ec455cac..083c5d3f2e18 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -800,6 +800,7 @@ static int alloc_shaper(struct atm_dev *dev,int *pcr,int min,int max,int ubr)
 		i = m = 1;
 		zatm_dev->ubr_ref_cnt++;
 		zatm_dev->ubr = shaper;
+		*pcr = 0;
 	}
 	else {
 		if (min) {

commit 0c1cca1d8e0d58775dad43374f925e6cddf1bebc
Author: Om Narasimhan <om.turyx@gmail.com>
Date:   Tue Oct 3 16:27:18 2006 -0700

    [ATM]: kmalloc to kzalloc patches for drivers/atm
    
    Signed-off-by: Om Narasimhan <om.turyx@gmail.com>
    Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 2c65e82f0d6b..c491ec455cac 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -603,9 +603,8 @@ static int start_rx(struct atm_dev *dev)
 DPRINTK("start_rx\n");
 	zatm_dev = ZATM_DEV(dev);
 	size = sizeof(struct atm_vcc *)*zatm_dev->chans;
-	zatm_dev->rx_map = (struct atm_vcc **) kmalloc(size,GFP_KERNEL);
+	zatm_dev->rx_map =  kzalloc(size,GFP_KERNEL);
 	if (!zatm_dev->rx_map) return -ENOMEM;
-	memset(zatm_dev->rx_map,0,size);
 	/* set VPI/VCI split (use all VCIs and give what's left to VPIs) */
 	zpokel(zatm_dev,(1 << dev->ci_range.vci_bits)-1,uPD98401_VRR);
 	/* prepare free buffer pools */
@@ -951,9 +950,8 @@ static int open_tx_first(struct atm_vcc *vcc)
 	skb_queue_head_init(&zatm_vcc->tx_queue);
 	init_waitqueue_head(&zatm_vcc->tx_wait);
 	/* initialize ring */
-	zatm_vcc->ring = kmalloc(RING_SIZE,GFP_KERNEL);
+	zatm_vcc->ring = kzalloc(RING_SIZE,GFP_KERNEL);
 	if (!zatm_vcc->ring) return -ENOMEM;
-	memset(zatm_vcc->ring,0,RING_SIZE);
 	loop = zatm_vcc->ring+RING_ENTRIES*RING_WORDS;
 	loop[0] = uPD98401_TXPD_V;
 	loop[1] = loop[2] = 0;

commit dace145374b8e39aeb920304c358ab5e220341ab
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:38 2006 -0700

    [PATCH] irq-flags: misc drivers: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 1699c934bad0..2c65e82f0d6b 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -1270,7 +1270,7 @@ static int __init zatm_start(struct atm_dev *dev)
 	zatm_dev->rx_map = zatm_dev->tx_map = NULL;
  	for (i = 0; i < NR_MBX; i++)
  		zatm_dev->mbx_start[i] = 0;
- 	error = request_irq(zatm_dev->irq, zatm_int, SA_SHIRQ, DEV_LABEL, dev);
+ 	error = request_irq(zatm_dev->irq, zatm_int, IRQF_SHARED, DEV_LABEL, dev);
 	if (error < 0) {
  		printk(KERN_ERR DEV_LABEL "(itf %d): IRQ%d is already in use\n",
  		    dev->number,zatm_dev->irq);

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index f484747f255e..1699c934bad0 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -3,7 +3,6 @@
 /* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
 
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/kernel.h>

commit 79a34648e488a41be92369c72aa9784bd4d741f9
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Tue Jan 10 13:09:01 2006 -0800

    [ATM]: Remove unneeded kmalloc() return value casts + tiny whitespace cleanup
    
    Small cleanups for drivers/atm/zatm.c
     Get rid of unneeded cast of kmalloc() return value.
     Small whitespace/CodingStyle/formatting cleanup (since I was in there anyway).
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 55959e4d1cb7..f484747f255e 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -669,11 +669,13 @@ printk("NONONONOO!!!!\n");
 		u32 *put;
 		int i;
 
-		dsc = (u32 *) kmalloc(uPD98401_TXPD_SIZE*2+
-		    uPD98401_TXBD_SIZE*ATM_SKB(skb)->iovcnt,GFP_ATOMIC);
+		dsc = kmalloc(uPD98401_TXPD_SIZE * 2 +
+			uPD98401_TXBD_SIZE * ATM_SKB(skb)->iovcnt, GFP_ATOMIC);
 		if (!dsc) {
-			if (vcc->pop) vcc->pop(vcc,skb);
-			else dev_kfree_skb_irq(skb);
+			if (vcc->pop)
+				vcc->pop(vcc, skb);
+			else
+				dev_kfree_skb_irq(skb);
 			return -EAGAIN;
 		}
 		/* @@@ should check alignment */
@@ -683,7 +685,7 @@ printk("NONONONOO!!!!\n");
 		    (ATM_SKB(skb)->atm_options & ATM_ATMOPT_CLP ?
 		    uPD98401_CLPM_1 : uPD98401_CLPM_0));
 		dsc[1] = 0;
-		dsc[2] = ATM_SKB(skb)->iovcnt*uPD98401_TXBD_SIZE;
+		dsc[2] = ATM_SKB(skb)->iovcnt * uPD98401_TXBD_SIZE;
 		dsc[3] = virt_to_bus(put);
 		for (i = 0; i < ATM_SKB(skb)->iovcnt; i++) {
 			*put++ = ((struct iovec *) skb->data)[i].iov_len;

commit d70063c4634af060a5387337b7632f6334ca3458
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Sep 2 12:18:03 2005 -0700

    [ATM]: Fix dereference of uninitialized pointer in zatm
    
    Fixing breakage from [NET]: Kill skb->list - original was
            assign vcc
            do a bunch of stuff using ZATM_VCC(vcc)->pool as common subexpression
    Now we do
            int pos = ZATM_VCC(vcc)->pool;
            assign vcc
            do a bunch of stuff
    even though vcc is not even initialized when we enter that block...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index c4b75ecf9460..55959e4d1cb7 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -417,9 +417,9 @@ printk("dummy: 0x%08lx, 0x%08lx\n",dummy[0],dummy[1]);
 		chan = (here[3] & uPD98401_AAL5_CHAN) >>
 		    uPD98401_AAL5_CHAN_SHIFT;
 		if (chan < zatm_dev->chans && zatm_dev->rx_map[chan]) {
-			int pos = ZATM_VCC(vcc)->pool;
-
+			int pos;
 			vcc = zatm_dev->rx_map[chan];
+			pos = ZATM_VCC(vcc)->pool;
 			if (skb == zatm_dev->last_free[pos])
 				zatm_dev->last_free[pos] = NULL;
 			skb_unlink(skb, zatm_dev->pool + pos);

commit a61bbcf28a8cb0ba56f8193d512f7222e711a294
Author: Patrick McHardy <kaber@trash.net>
Date:   Sun Aug 14 17:24:31 2005 -0700

    [NET]: Store skb->timestamp as offset to a base timestamp
    
    Reduces skb size by 8 bytes on 64-bit.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 85fee9530fa9..c4b75ecf9460 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -400,7 +400,7 @@ unsigned long *x;
 EVENT("error code 0x%x/0x%x\n",(here[3] & uPD98401_AAL5_ES) >>
   uPD98401_AAL5_ES_SHIFT,error);
 		skb = ((struct rx_buffer_head *) bus_to_virt(here[2]))->skb;
-		do_gettimeofday(&skb->stamp);
+		__net_timestamp(skb);
 #if 0
 printk("[-3..0] 0x%08lx 0x%08lx 0x%08lx 0x%08lx\n",((unsigned *) skb->data)[-3],
   ((unsigned *) skb->data)[-2],((unsigned *) skb->data)[-1],

commit 8728b834b226ffcf2c94a58530090e292af2a7bf
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Aug 9 19:25:21 2005 -0700

    [NET]: Kill skb->list
    
    Remove the "list" member of struct sk_buff, as it is entirely
    redundant.  All SKB list removal callers know which list the
    SKB is on, so storing this in sk_buff does nothing other than
    taking up some space.
    
    Two tricky bits were SCTP, which I took care of, and two ATM
    drivers which Francois Romieu <romieu@fr.zoreil.com> fixed
    up.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Francois Romieu <romieu@fr.zoreil.com>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index a2b236a966e0..85fee9530fa9 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -417,10 +417,12 @@ printk("dummy: 0x%08lx, 0x%08lx\n",dummy[0],dummy[1]);
 		chan = (here[3] & uPD98401_AAL5_CHAN) >>
 		    uPD98401_AAL5_CHAN_SHIFT;
 		if (chan < zatm_dev->chans && zatm_dev->rx_map[chan]) {
+			int pos = ZATM_VCC(vcc)->pool;
+
 			vcc = zatm_dev->rx_map[chan];
-			if (skb == zatm_dev->last_free[ZATM_VCC(vcc)->pool])
-				zatm_dev->last_free[ZATM_VCC(vcc)->pool] = NULL;
-			skb_unlink(skb);
+			if (skb == zatm_dev->last_free[pos])
+				zatm_dev->last_free[pos] = NULL;
+			skb_unlink(skb, zatm_dev->pool + pos);
 		}
 		else {
 			printk(KERN_ERR DEV_LABEL "(itf %d): RX indication "

commit 4aa49d130df9209707a97786a55a3f584b7345e9
Author: Francois Romieu <romieu@fr.zoreil.com>
Date:   Wed Jul 20 12:01:46 2005 -0700

    [ATM]: zatm: mailbox converted to pci_alloc_consistent()
    
    mailbox converted to pci_alloc_consistent()
    
    - request_region() is not needed: zatm_init_one() issues
      pci_request_regions();
    - the warning related to kfree(zatm_dev->mbx_start) disappears;
    
    Compiled with i386 and sparc64 as target.
    
    Signed-off-by: Francois Romieu <romieu@fr.zoreil.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index afcf1ada5547..a2b236a966e0 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -16,9 +16,9 @@
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
 #include <linux/delay.h>
-#include <linux/ioport.h> /* for request_region */
 #include <linux/uio.h>
 #include <linux/init.h>
+#include <linux/dma-mapping.h>
 #include <linux/atm_zatm.h>
 #include <linux/capability.h>
 #include <linux/bitops.h>
@@ -1257,22 +1257,22 @@ static int __init zatm_init(struct atm_dev *dev)
 
 static int __init zatm_start(struct atm_dev *dev)
 {
-	struct zatm_dev *zatm_dev;
+	struct zatm_dev *zatm_dev = ZATM_DEV(dev);
+	struct pci_dev *pdev = zatm_dev->pci_dev;
 	unsigned long curr;
 	int pools,vccs,rx;
-	int error,i,ld;
+	int error, i, ld;
 
 	DPRINTK("zatm_start\n");
-	zatm_dev = ZATM_DEV(dev);
 	zatm_dev->rx_map = zatm_dev->tx_map = NULL;
-	for (i = 0; i < NR_MBX; i++)
-		zatm_dev->mbx_start[i] = 0;
-	if (request_irq(zatm_dev->irq,&zatm_int,SA_SHIRQ,DEV_LABEL,dev)) {
-		printk(KERN_ERR DEV_LABEL "(itf %d): IRQ%d is already in use\n",
-		    dev->number,zatm_dev->irq);
-		return -EAGAIN;
+ 	for (i = 0; i < NR_MBX; i++)
+ 		zatm_dev->mbx_start[i] = 0;
+ 	error = request_irq(zatm_dev->irq, zatm_int, SA_SHIRQ, DEV_LABEL, dev);
+	if (error < 0) {
+ 		printk(KERN_ERR DEV_LABEL "(itf %d): IRQ%d is already in use\n",
+ 		    dev->number,zatm_dev->irq);
+		goto done;
 	}
-	request_region(zatm_dev->base,uPD98401_PORTS,DEV_LABEL);
 	/* define memory regions */
 	pools = NR_POOLS;
 	if (NR_SHAPERS*SHAPER_SIZE > pools*POOL_SIZE)
@@ -1299,51 +1299,66 @@ static int __init zatm_start(struct atm_dev *dev)
 	    "%ld VCs\n",dev->number,NR_SHAPERS,pools,rx,
 	    (zatm_dev->mem-curr*4)/VC_SIZE);
 	/* create mailboxes */
-	for (i = 0; i < NR_MBX; i++)
-		if (mbx_entries[i]) {
-			unsigned long here;
-
-			here = (unsigned long) kmalloc(2*MBX_SIZE(i),
-			    GFP_KERNEL);
-			if (!here) {
-				error = -ENOMEM;
-				goto out;
-			}
-			if ((here^(here+MBX_SIZE(i))) & ~0xffffUL)/* paranoia */
-				here = (here & ~0xffffUL)+0x10000;
-			zatm_dev->mbx_start[i] = here;
-			if ((here^virt_to_bus((void *) here)) & 0xffff) {
-				printk(KERN_ERR DEV_LABEL "(itf %d): system "
-				    "bus incompatible with driver\n",
-				    dev->number);
-				error = -ENODEV;
-				goto out;
-			}
-			DPRINTK("mbx@0x%08lx-0x%08lx\n",here,here+MBX_SIZE(i));
-			zatm_dev->mbx_end[i] = (here+MBX_SIZE(i)) & 0xffff;
-			zout(virt_to_bus((void *) here) >> 16,MSH(i));
-			zout(virt_to_bus((void *) here),MSL(i));
-			zout((here+MBX_SIZE(i)) & 0xffff,MBA(i));
-			zout(here & 0xffff,MTA(i));
-			zout(here & 0xffff,MWA(i));
+	for (i = 0; i < NR_MBX; i++) {
+		void *mbx;
+		dma_addr_t mbx_dma;
+
+		if (!mbx_entries[i])
+			continue;
+		mbx = pci_alloc_consistent(pdev, 2*MBX_SIZE(i), &mbx_dma);
+		if (!mbx) {
+			error = -ENOMEM;
+			goto out;
 		}
+		/*
+		 * Alignment provided by pci_alloc_consistent() isn't enough
+		 * for this device.
+		 */
+		if (((unsigned long)mbx ^ mbx_dma) & 0xffff) {
+			printk(KERN_ERR DEV_LABEL "(itf %d): system "
+			       "bus incompatible with driver\n", dev->number);
+			pci_free_consistent(pdev, 2*MBX_SIZE(i), mbx, mbx_dma);
+			error = -ENODEV;
+			goto out;
+		}
+		DPRINTK("mbx@0x%08lx-0x%08lx\n", mbx, mbx + MBX_SIZE(i));
+		zatm_dev->mbx_start[i] = (unsigned long)mbx;
+		zatm_dev->mbx_dma[i] = mbx_dma;
+		zatm_dev->mbx_end[i] = (zatm_dev->mbx_start[i] + MBX_SIZE(i)) &
+					0xffff;
+		zout(mbx_dma >> 16, MSH(i));
+		zout(mbx_dma, MSL(i));
+		zout(zatm_dev->mbx_end[i], MBA(i));
+		zout((unsigned long)mbx & 0xffff, MTA(i));
+		zout((unsigned long)mbx & 0xffff, MWA(i));
+	}
 	error = start_tx(dev);
-	if (error) goto out;
+	if (error)
+		goto out;
 	error = start_rx(dev);
-	if (error) goto out;
+	if (error)
+		goto out_tx;
 	error = dev->phy->start(dev);
-	if (error) goto out;
+	if (error)
+		goto out_rx;
 	zout(0xffffffff,IMR); /* enable interrupts */
 	/* enable TX & RX */
 	zout(zin(GMR) | uPD98401_GMR_SE | uPD98401_GMR_RE,GMR);
-	return 0;
-    out:
-	for (i = 0; i < NR_MBX; i++)
-		kfree(&zatm_dev->mbx_start[i]);
+done:
+	return error;
+
+out_rx:
 	kfree(zatm_dev->rx_map);
+out_tx:
 	kfree(zatm_dev->tx_map);
+out:
+	while (i-- > 0) {
+		pci_free_consistent(pdev, 2*MBX_SIZE(i), 
+				    (void *)zatm_dev->mbx_start[i],
+				    zatm_dev->mbx_dma[i]);
+	}
 	free_irq(zatm_dev->irq, dev);
-	return error;
+	goto done;
 }
 
 

commit 43f51fce0a637e6cdf1285b0fa09b8398ff14834
Author: Chas Williams <chas@cmf.nrl.navy.mil>
Date:   Tue Jul 19 13:54:19 2005 -0700

    [ATM]: [zatm] eliminate kfree warning (from Tobias Hirning <sskyman@web.de>)
    
    Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 8d5e65cb9755..afcf1ada5547 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -1339,7 +1339,7 @@ static int __init zatm_start(struct atm_dev *dev)
 	return 0;
     out:
 	for (i = 0; i < NR_MBX; i++)
-		kfree(zatm_dev->mbx_start[i]);
+		kfree(&zatm_dev->mbx_start[i]);
 	kfree(zatm_dev->rx_map);
 	kfree(zatm_dev->tx_map);
 	free_irq(zatm_dev->irq, dev);

commit a2c1aa54746bace5d03cc66521fbf3bb6fb2f916
Author: Jesper Juhl <juhl-lkml@dif.dk>
Date:   Thu Jun 2 13:04:07 2005 -0700

    [ATM]: [drivers] kill pointless NULL checks and casts before kfree()
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Chas Williams <chas@cmf.nrl.navy.mil>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
index 47a800519ad0..8d5e65cb9755 100644
--- a/drivers/atm/zatm.c
+++ b/drivers/atm/zatm.c
@@ -902,7 +902,7 @@ static void close_tx(struct atm_vcc *vcc)
 		zatm_dev->tx_bw += vcc->qos.txtp.min_pcr;
 		dealloc_shaper(vcc->dev,zatm_vcc->shaper);
 	}
-	if (zatm_vcc->ring) kfree(zatm_vcc->ring);
+	kfree(zatm_vcc->ring);
 }
 
 
@@ -1339,12 +1339,9 @@ static int __init zatm_start(struct atm_dev *dev)
 	return 0;
     out:
 	for (i = 0; i < NR_MBX; i++)
-		if (zatm_dev->mbx_start[i] != 0)
-			kfree((void *) zatm_dev->mbx_start[i]);
-	if (zatm_dev->rx_map != NULL)
-		kfree(zatm_dev->rx_map);
-	if (zatm_dev->tx_map != NULL)
-		kfree(zatm_dev->tx_map);
+		kfree(zatm_dev->mbx_start[i]);
+	kfree(zatm_dev->rx_map);
+	kfree(zatm_dev->tx_map);
 	free_irq(zatm_dev->irq, dev);
 	return error;
 }

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/atm/zatm.c b/drivers/atm/zatm.c
new file mode 100644
index 000000000000..47a800519ad0
--- /dev/null
+++ b/drivers/atm/zatm.c
@@ -0,0 +1,1646 @@
+/* drivers/atm/zatm.c - ZeitNet ZN122x device driver */
+ 
+/* Written 1995-2000 by Werner Almesberger, EPFL LRC/ICA */
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/errno.h>
+#include <linux/atm.h>
+#include <linux/atmdev.h>
+#include <linux/sonet.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <linux/ioport.h> /* for request_region */
+#include <linux/uio.h>
+#include <linux/init.h>
+#include <linux/atm_zatm.h>
+#include <linux/capability.h>
+#include <linux/bitops.h>
+#include <linux/wait.h>
+#include <asm/byteorder.h>
+#include <asm/system.h>
+#include <asm/string.h>
+#include <asm/io.h>
+#include <asm/atomic.h>
+#include <asm/uaccess.h>
+
+#include "uPD98401.h"
+#include "uPD98402.h"
+#include "zeprom.h"
+#include "zatm.h"
+
+
+/*
+ * TODO:
+ *
+ * Minor features
+ *  - support 64 kB SDUs (will have to use multibuffer batches then :-( )
+ *  - proper use of CDV, credit = max(1,CDVT*PCR)
+ *  - AAL0
+ *  - better receive timestamps
+ *  - OAM
+ */
+
+#define ZATM_COPPER	1
+
+#if 0
+#define DPRINTK(format,args...) printk(KERN_DEBUG format,##args)
+#else
+#define DPRINTK(format,args...)
+#endif
+
+#ifndef CONFIG_ATM_ZATM_DEBUG
+
+
+#define NULLCHECK(x)
+
+#define EVENT(s,a,b)
+
+
+static void event_dump(void)
+{
+}
+
+
+#else
+
+
+/* 
+ * NULL pointer checking
+ */
+
+#define NULLCHECK(x) \
+  if ((unsigned long) (x) < 0x30) printk(KERN_CRIT #x "==0x%x\n", (int) (x))
+
+/*
+ * Very extensive activity logging. Greatly improves bug detection speed but
+ * costs a few Mbps if enabled.
+ */
+
+#define EV 64
+
+static const char *ev[EV];
+static unsigned long ev_a[EV],ev_b[EV];
+static int ec = 0;
+
+
+static void EVENT(const char *s,unsigned long a,unsigned long b)
+{
+	ev[ec] = s; 
+	ev_a[ec] = a;
+	ev_b[ec] = b;
+	ec = (ec+1) % EV;
+}
+
+
+static void event_dump(void)
+{
+	int n,i;
+
+	printk(KERN_NOTICE "----- event dump follows -----\n");
+	for (n = 0; n < EV; n++) {
+		i = (ec+n) % EV;
+		printk(KERN_NOTICE);
+		printk(ev[i] ? ev[i] : "(null)",ev_a[i],ev_b[i]);
+	}
+	printk(KERN_NOTICE "----- event dump ends here -----\n");
+}
+
+
+#endif /* CONFIG_ATM_ZATM_DEBUG */
+
+
+#define RING_BUSY	1	/* indication from do_tx that PDU has to be
+				   backlogged */
+
+static struct atm_dev *zatm_boards = NULL;
+static unsigned long dummy[2] = {0,0};
+
+
+#define zin_n(r) inl(zatm_dev->base+r*4)
+#define zin(r) inl(zatm_dev->base+uPD98401_##r*4)
+#define zout(v,r) outl(v,zatm_dev->base+uPD98401_##r*4)
+#define zwait while (zin(CMR) & uPD98401_BUSY)
+
+/* RX0, RX1, TX0, TX1 */
+static const int mbx_entries[NR_MBX] = { 1024,1024,1024,1024 };
+static const int mbx_esize[NR_MBX] = { 16,16,4,4 }; /* entry size in bytes */
+
+#define MBX_SIZE(i) (mbx_entries[i]*mbx_esize[i])
+
+
+/*-------------------------------- utilities --------------------------------*/
+
+
+static void zpokel(struct zatm_dev *zatm_dev,u32 value,u32 addr)
+{
+	zwait;
+	zout(value,CER);
+	zout(uPD98401_IND_ACC | uPD98401_IA_BALL |
+	    (uPD98401_IA_TGT_CM << uPD98401_IA_TGT_SHIFT) | addr,CMR);
+}
+
+
+static u32 zpeekl(struct zatm_dev *zatm_dev,u32 addr)
+{
+	zwait;
+	zout(uPD98401_IND_ACC | uPD98401_IA_BALL | uPD98401_IA_RW |
+	  (uPD98401_IA_TGT_CM << uPD98401_IA_TGT_SHIFT) | addr,CMR);
+	zwait;
+	return zin(CER);
+}
+
+
+/*------------------------------- free lists --------------------------------*/
+
+
+/*
+ * Free buffer head structure:
+ *   [0] pointer to buffer (for SAR)
+ *   [1] buffer descr link pointer (for SAR)
+ *   [2] back pointer to skb (for poll_rx)
+ *   [3] data
+ *   ...
+ */
+
+struct rx_buffer_head {
+	u32		buffer;	/* pointer to buffer (for SAR) */
+	u32		link;	/* buffer descriptor link pointer (for SAR) */
+	struct sk_buff	*skb;	/* back pointer to skb (for poll_rx) */
+};
+
+
+static void refill_pool(struct atm_dev *dev,int pool)
+{
+	struct zatm_dev *zatm_dev;
+	struct sk_buff *skb;
+	struct rx_buffer_head *first;
+	unsigned long flags;
+	int align,offset,free,count,size;
+
+	EVENT("refill_pool\n",0,0);
+	zatm_dev = ZATM_DEV(dev);
+	size = (64 << (pool <= ZATM_AAL5_POOL_BASE ? 0 :
+	    pool-ZATM_AAL5_POOL_BASE))+sizeof(struct rx_buffer_head);
+	if (size < PAGE_SIZE) {
+		align = 32; /* for 32 byte alignment */
+		offset = sizeof(struct rx_buffer_head);
+	}
+	else {
+		align = 4096;
+		offset = zatm_dev->pool_info[pool].offset+
+		    sizeof(struct rx_buffer_head);
+	}
+	size += align;
+	spin_lock_irqsave(&zatm_dev->lock, flags);
+	free = zpeekl(zatm_dev,zatm_dev->pool_base+2*pool) &
+	    uPD98401_RXFP_REMAIN;
+	spin_unlock_irqrestore(&zatm_dev->lock, flags);
+	if (free >= zatm_dev->pool_info[pool].low_water) return;
+	EVENT("starting ... POOL: 0x%x, 0x%x\n",
+	    zpeekl(zatm_dev,zatm_dev->pool_base+2*pool),
+	    zpeekl(zatm_dev,zatm_dev->pool_base+2*pool+1));
+	EVENT("dummy: 0x%08lx, 0x%08lx\n",dummy[0],dummy[1]);
+	count = 0;
+	first = NULL;
+	while (free < zatm_dev->pool_info[pool].high_water) {
+		struct rx_buffer_head *head;
+
+		skb = alloc_skb(size,GFP_ATOMIC);
+		if (!skb) {
+			printk(KERN_WARNING DEV_LABEL "(Itf %d): got no new "
+			    "skb (%d) with %d free\n",dev->number,size,free);
+			break;
+		}
+		skb_reserve(skb,(unsigned char *) ((((unsigned long) skb->data+
+		    align+offset-1) & ~(unsigned long) (align-1))-offset)-
+		    skb->data);
+		head = (struct rx_buffer_head *) skb->data;
+		skb_reserve(skb,sizeof(struct rx_buffer_head));
+		if (!first) first = head;
+		count++;
+		head->buffer = virt_to_bus(skb->data);
+		head->link = 0;
+		head->skb = skb;
+		EVENT("enq skb 0x%08lx/0x%08lx\n",(unsigned long) skb,
+		    (unsigned long) head);
+		spin_lock_irqsave(&zatm_dev->lock, flags);
+		if (zatm_dev->last_free[pool])
+			((struct rx_buffer_head *) (zatm_dev->last_free[pool]->
+			    data))[-1].link = virt_to_bus(head);
+		zatm_dev->last_free[pool] = skb;
+		skb_queue_tail(&zatm_dev->pool[pool],skb);
+		spin_unlock_irqrestore(&zatm_dev->lock, flags);
+		free++;
+	}
+	if (first) {
+		spin_lock_irqsave(&zatm_dev->lock, flags);
+		zwait;
+		zout(virt_to_bus(first),CER);
+		zout(uPD98401_ADD_BAT | (pool << uPD98401_POOL_SHIFT) | count,
+		    CMR);
+		spin_unlock_irqrestore(&zatm_dev->lock, flags);
+		EVENT ("POOL: 0x%x, 0x%x\n",
+		    zpeekl(zatm_dev,zatm_dev->pool_base+2*pool),
+		    zpeekl(zatm_dev,zatm_dev->pool_base+2*pool+1));
+		EVENT("dummy: 0x%08lx, 0x%08lx\n",dummy[0],dummy[1]);
+	}
+}
+
+
+static void drain_free(struct atm_dev *dev,int pool)
+{
+	skb_queue_purge(&ZATM_DEV(dev)->pool[pool]);
+}
+
+
+static int pool_index(int max_pdu)
+{
+	int i;
+
+	if (max_pdu % ATM_CELL_PAYLOAD)
+		printk(KERN_ERR DEV_LABEL ": driver error in pool_index: "
+		    "max_pdu is %d\n",max_pdu);
+	if (max_pdu > 65536) return -1;
+	for (i = 0; (64 << i) < max_pdu; i++);
+	return i+ZATM_AAL5_POOL_BASE;
+}
+
+
+/* use_pool isn't reentrant */
+
+
+static void use_pool(struct atm_dev *dev,int pool)
+{
+	struct zatm_dev *zatm_dev;
+	unsigned long flags;
+	int size;
+
+	zatm_dev = ZATM_DEV(dev);
+	if (!(zatm_dev->pool_info[pool].ref_count++)) {
+		skb_queue_head_init(&zatm_dev->pool[pool]);
+		size = pool-ZATM_AAL5_POOL_BASE;
+		if (size < 0) size = 0; /* 64B... */
+		else if (size > 10) size = 10; /* ... 64kB */
+		spin_lock_irqsave(&zatm_dev->lock, flags);
+		zpokel(zatm_dev,((zatm_dev->pool_info[pool].low_water/4) <<
+		    uPD98401_RXFP_ALERT_SHIFT) |
+		    (1 << uPD98401_RXFP_BTSZ_SHIFT) |
+		    (size << uPD98401_RXFP_BFSZ_SHIFT),
+		    zatm_dev->pool_base+pool*2);
+		zpokel(zatm_dev,(unsigned long) dummy,zatm_dev->pool_base+
+		    pool*2+1);
+		spin_unlock_irqrestore(&zatm_dev->lock, flags);
+		zatm_dev->last_free[pool] = NULL;
+		refill_pool(dev,pool);
+	}
+	DPRINTK("pool %d: %d\n",pool,zatm_dev->pool_info[pool].ref_count);
+}
+
+
+static void unuse_pool(struct atm_dev *dev,int pool)
+{
+	if (!(--ZATM_DEV(dev)->pool_info[pool].ref_count))
+		drain_free(dev,pool);
+}
+
+/*----------------------------------- RX ------------------------------------*/
+
+
+#if 0
+static void exception(struct atm_vcc *vcc)
+{
+   static int count = 0;
+   struct zatm_dev *zatm_dev = ZATM_DEV(vcc->dev);
+   struct zatm_vcc *zatm_vcc = ZATM_VCC(vcc);
+   unsigned long *qrp;
+   int i;
+
+   if (count++ > 2) return;
+   for (i = 0; i < 8; i++)
+	printk("TX%d: 0x%08lx\n",i,
+	  zpeekl(zatm_dev,zatm_vcc->tx_chan*VC_SIZE/4+i));
+   for (i = 0; i < 5; i++)
+	printk("SH%d: 0x%08lx\n",i,
+	  zpeekl(zatm_dev,uPD98401_IM(zatm_vcc->shaper)+16*i));
+   qrp = (unsigned long *) zpeekl(zatm_dev,zatm_vcc->tx_chan*VC_SIZE/4+
+     uPD98401_TXVC_QRP);
+   printk("qrp=0x%08lx\n",(unsigned long) qrp);
+   for (i = 0; i < 4; i++) printk("QRP[%d]: 0x%08lx",i,qrp[i]);
+}
+#endif
+
+
+static const char *err_txt[] = {
+	"No error",
+	"RX buf underflow",
+	"RX FIFO overrun",
+	"Maximum len violation",
+	"CRC error",
+	"User abort",
+	"Length violation",
+	"T1 error",
+	"Deactivated",
+	"???",
+	"???",
+	"???",
+	"???",
+	"???",
+	"???",
+	"???"
+};
+
+
+static void poll_rx(struct atm_dev *dev,int mbx)
+{
+	struct zatm_dev *zatm_dev;
+	unsigned long pos;
+	u32 x;
+	int error;
+
+	EVENT("poll_rx\n",0,0);
+	zatm_dev = ZATM_DEV(dev);
+	pos = (zatm_dev->mbx_start[mbx] & ~0xffffUL) | zin(MTA(mbx));
+	while (x = zin(MWA(mbx)), (pos & 0xffff) != x) {
+		u32 *here;
+		struct sk_buff *skb;
+		struct atm_vcc *vcc;
+		int cells,size,chan;
+
+		EVENT("MBX: host 0x%lx, nic 0x%x\n",pos,x);
+		here = (u32 *) pos;
+		if (((pos += 16) & 0xffff) == zatm_dev->mbx_end[mbx])
+			pos = zatm_dev->mbx_start[mbx];
+		cells = here[0] & uPD98401_AAL5_SIZE;
+#if 0
+printk("RX IND: 0x%x, 0x%x, 0x%x, 0x%x\n",here[0],here[1],here[2],here[3]);
+{
+unsigned long *x;
+		printk("POOL: 0x%08x, 0x%08x\n",zpeekl(zatm_dev,
+		      zatm_dev->pool_base),
+		      zpeekl(zatm_dev,zatm_dev->pool_base+1));
+		x = (unsigned long *) here[2];
+		printk("[0..3] = 0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx\n",
+		    x[0],x[1],x[2],x[3]);
+}
+#endif
+		error = 0;
+		if (here[3] & uPD98401_AAL5_ERR) {
+			error = (here[3] & uPD98401_AAL5_ES) >>
+			    uPD98401_AAL5_ES_SHIFT;
+			if (error == uPD98401_AAL5_ES_DEACT ||
+			    error == uPD98401_AAL5_ES_FREE) continue;
+		}
+EVENT("error code 0x%x/0x%x\n",(here[3] & uPD98401_AAL5_ES) >>
+  uPD98401_AAL5_ES_SHIFT,error);
+		skb = ((struct rx_buffer_head *) bus_to_virt(here[2]))->skb;
+		do_gettimeofday(&skb->stamp);
+#if 0
+printk("[-3..0] 0x%08lx 0x%08lx 0x%08lx 0x%08lx\n",((unsigned *) skb->data)[-3],
+  ((unsigned *) skb->data)[-2],((unsigned *) skb->data)[-1],
+  ((unsigned *) skb->data)[0]);
+#endif
+		EVENT("skb 0x%lx, here 0x%lx\n",(unsigned long) skb,
+		    (unsigned long) here);
+#if 0
+printk("dummy: 0x%08lx, 0x%08lx\n",dummy[0],dummy[1]);
+#endif
+		size = error ? 0 : ntohs(((__be16 *) skb->data)[cells*
+		    ATM_CELL_PAYLOAD/sizeof(u16)-3]);
+		EVENT("got skb 0x%lx, size %d\n",(unsigned long) skb,size);
+		chan = (here[3] & uPD98401_AAL5_CHAN) >>
+		    uPD98401_AAL5_CHAN_SHIFT;
+		if (chan < zatm_dev->chans && zatm_dev->rx_map[chan]) {
+			vcc = zatm_dev->rx_map[chan];
+			if (skb == zatm_dev->last_free[ZATM_VCC(vcc)->pool])
+				zatm_dev->last_free[ZATM_VCC(vcc)->pool] = NULL;
+			skb_unlink(skb);
+		}
+		else {
+			printk(KERN_ERR DEV_LABEL "(itf %d): RX indication "
+			    "for non-existing channel\n",dev->number);
+			size = 0;
+			vcc = NULL;
+			event_dump();
+		}
+		if (error) {
+			static unsigned long silence = 0;
+			static int last_error = 0;
+
+			if (error != last_error ||
+			    time_after(jiffies, silence)  || silence == 0){
+				printk(KERN_WARNING DEV_LABEL "(itf %d): "
+				    "chan %d error %s\n",dev->number,chan,
+				    err_txt[error]);
+				last_error = error;
+				silence = (jiffies+2*HZ)|1;
+			}
+			size = 0;
+		}
+		if (size && (size > cells*ATM_CELL_PAYLOAD-ATM_AAL5_TRAILER ||
+		    size <= (cells-1)*ATM_CELL_PAYLOAD-ATM_AAL5_TRAILER)) {
+			printk(KERN_ERR DEV_LABEL "(itf %d): size %d with %d "
+			    "cells\n",dev->number,size,cells);
+			size = 0;
+			event_dump();
+		}
+		if (size > ATM_MAX_AAL5_PDU) {
+			printk(KERN_ERR DEV_LABEL "(itf %d): size too big "
+			    "(%d)\n",dev->number,size);
+			size = 0;
+			event_dump();
+		}
+		if (!size) {
+			dev_kfree_skb_irq(skb);
+			if (vcc) atomic_inc(&vcc->stats->rx_err);
+			continue;
+		}
+		if (!atm_charge(vcc,skb->truesize)) {
+			dev_kfree_skb_irq(skb);
+			continue;
+		}
+		skb->len = size;
+		ATM_SKB(skb)->vcc = vcc;
+		vcc->push(vcc,skb);
+		atomic_inc(&vcc->stats->rx);
+	}
+	zout(pos & 0xffff,MTA(mbx));
+#if 0 /* probably a stupid idea */
+	refill_pool(dev,zatm_vcc->pool);
+		/* maybe this saves us a few interrupts */
+#endif
+}
+
+
+static int open_rx_first(struct atm_vcc *vcc)
+{
+	struct zatm_dev *zatm_dev;
+	struct zatm_vcc *zatm_vcc;
+	unsigned long flags;
+	unsigned short chan;
+	int cells;
+
+	DPRINTK("open_rx_first (0x%x)\n",inb_p(0xc053));
+	zatm_dev = ZATM_DEV(vcc->dev);
+	zatm_vcc = ZATM_VCC(vcc);
+	zatm_vcc->rx_chan = 0;
+	if (vcc->qos.rxtp.traffic_class == ATM_NONE) return 0;
+	if (vcc->qos.aal == ATM_AAL5) {
+		if (vcc->qos.rxtp.max_sdu > 65464)
+			vcc->qos.rxtp.max_sdu = 65464;
+			/* fix this - we may want to receive 64kB SDUs
+			   later */
+		cells = (vcc->qos.rxtp.max_sdu+ATM_AAL5_TRAILER+
+		    ATM_CELL_PAYLOAD-1)/ATM_CELL_PAYLOAD;
+		zatm_vcc->pool = pool_index(cells*ATM_CELL_PAYLOAD);
+	}
+	else {
+		cells = 1;
+		zatm_vcc->pool = ZATM_AAL0_POOL;
+	}
+	if (zatm_vcc->pool < 0) return -EMSGSIZE;
+	spin_lock_irqsave(&zatm_dev->lock, flags);
+	zwait;
+	zout(uPD98401_OPEN_CHAN,CMR);
+	zwait;
+	DPRINTK("0x%x 0x%x\n",zin(CMR),zin(CER));
+	chan = (zin(CMR) & uPD98401_CHAN_ADDR) >> uPD98401_CHAN_ADDR_SHIFT;
+	spin_unlock_irqrestore(&zatm_dev->lock, flags);
+	DPRINTK("chan is %d\n",chan);
+	if (!chan) return -EAGAIN;
+	use_pool(vcc->dev,zatm_vcc->pool);
+	DPRINTK("pool %d\n",zatm_vcc->pool);
+	/* set up VC descriptor */
+	spin_lock_irqsave(&zatm_dev->lock, flags);
+	zpokel(zatm_dev,zatm_vcc->pool << uPD98401_RXVC_POOL_SHIFT,
+	    chan*VC_SIZE/4);
+	zpokel(zatm_dev,uPD98401_RXVC_OD | (vcc->qos.aal == ATM_AAL5 ?
+	    uPD98401_RXVC_AR : 0) | cells,chan*VC_SIZE/4+1);
+	zpokel(zatm_dev,0,chan*VC_SIZE/4+2);
+	zatm_vcc->rx_chan = chan;
+	zatm_dev->rx_map[chan] = vcc;
+	spin_unlock_irqrestore(&zatm_dev->lock, flags);
+	return 0;
+}
+
+
+static int open_rx_second(struct atm_vcc *vcc)
+{
+	struct zatm_dev *zatm_dev;
+	struct zatm_vcc *zatm_vcc;
+	unsigned long flags;
+	int pos,shift;
+
+	DPRINTK("open_rx_second (0x%x)\n",inb_p(0xc053));
+	zatm_dev = ZATM_DEV(vcc->dev);
+	zatm_vcc = ZATM_VCC(vcc);
+	if (!zatm_vcc->rx_chan) return 0;
+	spin_lock_irqsave(&zatm_dev->lock, flags);
+	/* should also handle VPI @@@ */
+	pos = vcc->vci >> 1;
+	shift = (1-(vcc->vci & 1)) << 4;
+	zpokel(zatm_dev,(zpeekl(zatm_dev,pos) & ~(0xffff << shift)) |
+	    ((zatm_vcc->rx_chan | uPD98401_RXLT_ENBL) << shift),pos);
+	spin_unlock_irqrestore(&zatm_dev->lock, flags);
+	return 0;
+}
+
+
+static void close_rx(struct atm_vcc *vcc)
+{
+	struct zatm_dev *zatm_dev;
+	struct zatm_vcc *zatm_vcc;
+	unsigned long flags;
+	int pos,shift;
+
+	zatm_vcc = ZATM_VCC(vcc);
+	zatm_dev = ZATM_DEV(vcc->dev);
+	if (!zatm_vcc->rx_chan) return;
+	DPRINTK("close_rx\n");
+	/* disable receiver */
+	if (vcc->vpi != ATM_VPI_UNSPEC && vcc->vci != ATM_VCI_UNSPEC) {
+		spin_lock_irqsave(&zatm_dev->lock, flags);
+		pos = vcc->vci >> 1;
+		shift = (1-(vcc->vci & 1)) << 4;
+		zpokel(zatm_dev,zpeekl(zatm_dev,pos) & ~(0xffff << shift),pos);
+		zwait;
+		zout(uPD98401_NOP,CMR);
+		zwait;
+		zout(uPD98401_NOP,CMR);
+		spin_unlock_irqrestore(&zatm_dev->lock, flags);
+	}
+	spin_lock_irqsave(&zatm_dev->lock, flags);
+	zwait;
+	zout(uPD98401_DEACT_CHAN | uPD98401_CHAN_RT | (zatm_vcc->rx_chan <<
+	    uPD98401_CHAN_ADDR_SHIFT),CMR);
+	zwait;
+	udelay(10); /* why oh why ... ? */
+	zout(uPD98401_CLOSE_CHAN | uPD98401_CHAN_RT | (zatm_vcc->rx_chan <<
+	    uPD98401_CHAN_ADDR_SHIFT),CMR);
+	zwait;
+	if (!(zin(CMR) & uPD98401_CHAN_ADDR))
+		printk(KERN_CRIT DEV_LABEL "(itf %d): can't close RX channel "
+		    "%d\n",vcc->dev->number,zatm_vcc->rx_chan);
+	spin_unlock_irqrestore(&zatm_dev->lock, flags);
+	zatm_dev->rx_map[zatm_vcc->rx_chan] = NULL;
+	zatm_vcc->rx_chan = 0;
+	unuse_pool(vcc->dev,zatm_vcc->pool);
+}
+
+
+static int start_rx(struct atm_dev *dev)
+{
+	struct zatm_dev *zatm_dev;
+	int size,i;
+
+DPRINTK("start_rx\n");
+	zatm_dev = ZATM_DEV(dev);
+	size = sizeof(struct atm_vcc *)*zatm_dev->chans;
+	zatm_dev->rx_map = (struct atm_vcc **) kmalloc(size,GFP_KERNEL);
+	if (!zatm_dev->rx_map) return -ENOMEM;
+	memset(zatm_dev->rx_map,0,size);
+	/* set VPI/VCI split (use all VCIs and give what's left to VPIs) */
+	zpokel(zatm_dev,(1 << dev->ci_range.vci_bits)-1,uPD98401_VRR);
+	/* prepare free buffer pools */
+	for (i = 0; i <= ZATM_LAST_POOL; i++) {
+		zatm_dev->pool_info[i].ref_count = 0;
+		zatm_dev->pool_info[i].rqa_count = 0;
+		zatm_dev->pool_info[i].rqu_count = 0;
+		zatm_dev->pool_info[i].low_water = LOW_MARK;
+		zatm_dev->pool_info[i].high_water = HIGH_MARK;
+		zatm_dev->pool_info[i].offset = 0;
+		zatm_dev->pool_info[i].next_off = 0;
+		zatm_dev->pool_info[i].next_cnt = 0;
+		zatm_dev->pool_info[i].next_thres = OFF_CNG_THRES;
+	}
+	return 0;
+}
+
+
+/*----------------------------------- TX ------------------------------------*/
+
+
+static int do_tx(struct sk_buff *skb)
+{
+	struct atm_vcc *vcc;
+	struct zatm_dev *zatm_dev;
+	struct zatm_vcc *zatm_vcc;
+	u32 *dsc;
+	unsigned long flags;
+
+	EVENT("do_tx\n",0,0);
+	DPRINTK("sending skb %p\n",skb);
+	vcc = ATM_SKB(skb)->vcc;
+	zatm_dev = ZATM_DEV(vcc->dev);
+	zatm_vcc = ZATM_VCC(vcc);
+	EVENT("iovcnt=%d\n",skb_shinfo(skb)->nr_frags,0);
+	spin_lock_irqsave(&zatm_dev->lock, flags);
+	if (!skb_shinfo(skb)->nr_frags) {
+		if (zatm_vcc->txing == RING_ENTRIES-1) {
+			spin_unlock_irqrestore(&zatm_dev->lock, flags);
+			return RING_BUSY;
+		}
+		zatm_vcc->txing++;
+		dsc = zatm_vcc->ring+zatm_vcc->ring_curr;
+		zatm_vcc->ring_curr = (zatm_vcc->ring_curr+RING_WORDS) &
+		    (RING_ENTRIES*RING_WORDS-1);
+		dsc[1] = 0;
+		dsc[2] = skb->len;
+		dsc[3] = virt_to_bus(skb->data);
+		mb();
+		dsc[0] = uPD98401_TXPD_V | uPD98401_TXPD_DP | uPD98401_TXPD_SM
+		    | (vcc->qos.aal == ATM_AAL5 ? uPD98401_TXPD_AAL5 : 0 |
+		    (ATM_SKB(skb)->atm_options & ATM_ATMOPT_CLP ?
+		    uPD98401_CLPM_1 : uPD98401_CLPM_0));
+		EVENT("dsc (0x%lx)\n",(unsigned long) dsc,0);
+	}
+	else {
+printk("NONONONOO!!!!\n");
+		dsc = NULL;
+#if 0
+		u32 *put;
+		int i;
+
+		dsc = (u32 *) kmalloc(uPD98401_TXPD_SIZE*2+
+		    uPD98401_TXBD_SIZE*ATM_SKB(skb)->iovcnt,GFP_ATOMIC);
+		if (!dsc) {
+			if (vcc->pop) vcc->pop(vcc,skb);
+			else dev_kfree_skb_irq(skb);
+			return -EAGAIN;
+		}
+		/* @@@ should check alignment */
+		put = dsc+8;
+		dsc[0] = uPD98401_TXPD_V | uPD98401_TXPD_DP |
+		    (vcc->aal == ATM_AAL5 ? uPD98401_TXPD_AAL5 : 0 |
+		    (ATM_SKB(skb)->atm_options & ATM_ATMOPT_CLP ?
+		    uPD98401_CLPM_1 : uPD98401_CLPM_0));
+		dsc[1] = 0;
+		dsc[2] = ATM_SKB(skb)->iovcnt*uPD98401_TXBD_SIZE;
+		dsc[3] = virt_to_bus(put);
+		for (i = 0; i < ATM_SKB(skb)->iovcnt; i++) {
+			*put++ = ((struct iovec *) skb->data)[i].iov_len;
+			*put++ = virt_to_bus(((struct iovec *)
+			    skb->data)[i].iov_base);
+		}
+		put[-2] |= uPD98401_TXBD_LAST;
+#endif
+	}
+	ZATM_PRV_DSC(skb) = dsc;
+	skb_queue_tail(&zatm_vcc->tx_queue,skb);
+	DPRINTK("QRP=0x%08lx\n",zpeekl(zatm_dev,zatm_vcc->tx_chan*VC_SIZE/4+
+	  uPD98401_TXVC_QRP));
+	zwait;
+	zout(uPD98401_TX_READY | (zatm_vcc->tx_chan <<
+	    uPD98401_CHAN_ADDR_SHIFT),CMR);
+	spin_unlock_irqrestore(&zatm_dev->lock, flags);
+	EVENT("done\n",0,0);
+	return 0;
+}
+
+
+static inline void dequeue_tx(struct atm_vcc *vcc)
+{
+	struct zatm_vcc *zatm_vcc;
+	struct sk_buff *skb;
+
+	EVENT("dequeue_tx\n",0,0);
+	zatm_vcc = ZATM_VCC(vcc);
+	skb = skb_dequeue(&zatm_vcc->tx_queue);
+	if (!skb) {
+		printk(KERN_CRIT DEV_LABEL "(itf %d): dequeue_tx but not "
+		    "txing\n",vcc->dev->number);
+		return;
+	}
+#if 0 /* @@@ would fail on CLP */
+if (*ZATM_PRV_DSC(skb) != (uPD98401_TXPD_V | uPD98401_TXPD_DP |
+  uPD98401_TXPD_SM | uPD98401_TXPD_AAL5)) printk("@#*$!!!!  (%08x)\n",
+  *ZATM_PRV_DSC(skb));
+#endif
+	*ZATM_PRV_DSC(skb) = 0; /* mark as invalid */
+	zatm_vcc->txing--;
+	if (vcc->pop) vcc->pop(vcc,skb);
+	else dev_kfree_skb_irq(skb);
+	while ((skb = skb_dequeue(&zatm_vcc->backlog)))
+		if (do_tx(skb) == RING_BUSY) {
+			skb_queue_head(&zatm_vcc->backlog,skb);
+			break;
+		}
+	atomic_inc(&vcc->stats->tx);
+	wake_up(&zatm_vcc->tx_wait);
+}
+
+
+static void poll_tx(struct atm_dev *dev,int mbx)
+{
+	struct zatm_dev *zatm_dev;
+	unsigned long pos;
+	u32 x;
+
+	EVENT("poll_tx\n",0,0);
+	zatm_dev = ZATM_DEV(dev);
+	pos = (zatm_dev->mbx_start[mbx] & ~0xffffUL) | zin(MTA(mbx));
+	while (x = zin(MWA(mbx)), (pos & 0xffff) != x) {
+		int chan;
+
+#if 1
+		u32 data,*addr;
+
+		EVENT("MBX: host 0x%lx, nic 0x%x\n",pos,x);
+		addr = (u32 *) pos;
+		data = *addr;
+		chan = (data & uPD98401_TXI_CONN) >> uPD98401_TXI_CONN_SHIFT;
+		EVENT("addr = 0x%lx, data = 0x%08x,",(unsigned long) addr,
+		    data);
+		EVENT("chan = %d\n",chan,0);
+#else
+NO !
+		chan = (zatm_dev->mbx_start[mbx][pos >> 2] & uPD98401_TXI_CONN)
+		>> uPD98401_TXI_CONN_SHIFT;
+#endif
+		if (chan < zatm_dev->chans && zatm_dev->tx_map[chan])
+			dequeue_tx(zatm_dev->tx_map[chan]);
+		else {
+			printk(KERN_CRIT DEV_LABEL "(itf %d): TX indication "
+			    "for non-existing channel %d\n",dev->number,chan);
+			event_dump();
+		}
+		if (((pos += 4) & 0xffff) == zatm_dev->mbx_end[mbx])
+			pos = zatm_dev->mbx_start[mbx];
+	}
+	zout(pos & 0xffff,MTA(mbx));
+}
+
+
+/*
+ * BUG BUG BUG: Doesn't handle "new-style" rate specification yet.
+ */
+
+static int alloc_shaper(struct atm_dev *dev,int *pcr,int min,int max,int ubr)
+{
+	struct zatm_dev *zatm_dev;
+	unsigned long flags;
+	unsigned long i,m,c;
+	int shaper;
+
+	DPRINTK("alloc_shaper (min = %d, max = %d)\n",min,max);
+	zatm_dev = ZATM_DEV(dev);
+	if (!zatm_dev->free_shapers) return -EAGAIN;
+	for (shaper = 0; !((zatm_dev->free_shapers >> shaper) & 1); shaper++);
+	zatm_dev->free_shapers &= ~1 << shaper;
+	if (ubr) {
+		c = 5;
+		i = m = 1;
+		zatm_dev->ubr_ref_cnt++;
+		zatm_dev->ubr = shaper;
+	}
+	else {
+		if (min) {
+			if (min <= 255) {
+				i = min;
+				m = ATM_OC3_PCR;
+			}
+			else {
+				i = 255;
+				m = ATM_OC3_PCR*255/min;
+			}
+		}
+		else {
+			if (max > zatm_dev->tx_bw) max = zatm_dev->tx_bw;
+			if (max <= 255) {
+				i = max;
+				m = ATM_OC3_PCR;
+			}
+			else {
+				i = 255;
+				m = (ATM_OC3_PCR*255+max-1)/max;
+			}
+		}
+		if (i > m) {
+			printk(KERN_CRIT DEV_LABEL "shaper algorithm botched "
+			    "[%d,%d] -> i=%ld,m=%ld\n",min,max,i,m);
+			m = i;
+		}
+		*pcr = i*ATM_OC3_PCR/m;
+		c = 20; /* @@@ should use max_cdv ! */
+		if ((min && *pcr < min) || (max && *pcr > max)) return -EINVAL;
+		if (zatm_dev->tx_bw < *pcr) return -EAGAIN;
+		zatm_dev->tx_bw -= *pcr;
+	}
+	spin_lock_irqsave(&zatm_dev->lock, flags);
+	DPRINTK("i = %d, m = %d, PCR = %d\n",i,m,*pcr);
+	zpokel(zatm_dev,(i << uPD98401_IM_I_SHIFT) | m,uPD98401_IM(shaper));
+	zpokel(zatm_dev,c << uPD98401_PC_C_SHIFT,uPD98401_PC(shaper));
+	zpokel(zatm_dev,0,uPD98401_X(shaper));
+	zpokel(zatm_dev,0,uPD98401_Y(shaper));
+	zpokel(zatm_dev,uPD98401_PS_E,uPD98401_PS(shaper));
+	spin_unlock_irqrestore(&zatm_dev->lock, flags);
+	return shaper;
+}
+
+
+static void dealloc_shaper(struct atm_dev *dev,int shaper)
+{
+	struct zatm_dev *zatm_dev;
+	unsigned long flags;
+
+	zatm_dev = ZATM_DEV(dev);
+	if (shaper == zatm_dev->ubr) {
+		if (--zatm_dev->ubr_ref_cnt) return;
+		zatm_dev->ubr = -1;
+	}
+	spin_lock_irqsave(&zatm_dev->lock, flags);
+	zpokel(zatm_dev,zpeekl(zatm_dev,uPD98401_PS(shaper)) & ~uPD98401_PS_E,
+	    uPD98401_PS(shaper));
+	spin_unlock_irqrestore(&zatm_dev->lock, flags);
+	zatm_dev->free_shapers |= 1 << shaper;
+}
+
+
+static void close_tx(struct atm_vcc *vcc)
+{
+	struct zatm_dev *zatm_dev;
+	struct zatm_vcc *zatm_vcc;
+	unsigned long flags;
+	int chan;
+
+	zatm_vcc = ZATM_VCC(vcc);
+	zatm_dev = ZATM_DEV(vcc->dev);
+	chan = zatm_vcc->tx_chan;
+	if (!chan) return;
+	DPRINTK("close_tx\n");
+	if (skb_peek(&zatm_vcc->backlog)) {
+		printk("waiting for backlog to drain ...\n");
+		event_dump();
+		wait_event(zatm_vcc->tx_wait, !skb_peek(&zatm_vcc->backlog));
+	}
+	if (skb_peek(&zatm_vcc->tx_queue)) {
+		printk("waiting for TX queue to drain ...\n");
+		event_dump();
+		wait_event(zatm_vcc->tx_wait, !skb_peek(&zatm_vcc->tx_queue));
+	}
+	spin_lock_irqsave(&zatm_dev->lock, flags);
+#if 0
+	zwait;
+	zout(uPD98401_DEACT_CHAN | (chan << uPD98401_CHAN_ADDR_SHIFT),CMR);
+#endif
+	zwait;
+	zout(uPD98401_CLOSE_CHAN | (chan << uPD98401_CHAN_ADDR_SHIFT),CMR);
+	zwait;
+	if (!(zin(CMR) & uPD98401_CHAN_ADDR))
+		printk(KERN_CRIT DEV_LABEL "(itf %d): can't close TX channel "
+		    "%d\n",vcc->dev->number,chan);
+	spin_unlock_irqrestore(&zatm_dev->lock, flags);
+	zatm_vcc->tx_chan = 0;
+	zatm_dev->tx_map[chan] = NULL;
+	if (zatm_vcc->shaper != zatm_dev->ubr) {
+		zatm_dev->tx_bw += vcc->qos.txtp.min_pcr;
+		dealloc_shaper(vcc->dev,zatm_vcc->shaper);
+	}
+	if (zatm_vcc->ring) kfree(zatm_vcc->ring);
+}
+
+
+static int open_tx_first(struct atm_vcc *vcc)
+{
+	struct zatm_dev *zatm_dev;
+	struct zatm_vcc *zatm_vcc;
+	unsigned long flags;
+	u32 *loop;
+	unsigned short chan;
+	int pcr,unlimited;
+
+	DPRINTK("open_tx_first\n");
+	zatm_dev = ZATM_DEV(vcc->dev);
+	zatm_vcc = ZATM_VCC(vcc);
+	zatm_vcc->tx_chan = 0;
+	if (vcc->qos.txtp.traffic_class == ATM_NONE) return 0;
+	spin_lock_irqsave(&zatm_dev->lock, flags);
+	zwait;
+	zout(uPD98401_OPEN_CHAN,CMR);
+	zwait;
+	DPRINTK("0x%x 0x%x\n",zin(CMR),zin(CER));
+	chan = (zin(CMR) & uPD98401_CHAN_ADDR) >> uPD98401_CHAN_ADDR_SHIFT;
+	spin_unlock_irqrestore(&zatm_dev->lock, flags);
+	DPRINTK("chan is %d\n",chan);
+	if (!chan) return -EAGAIN;
+	unlimited = vcc->qos.txtp.traffic_class == ATM_UBR &&
+	    (!vcc->qos.txtp.max_pcr || vcc->qos.txtp.max_pcr == ATM_MAX_PCR ||
+	    vcc->qos.txtp.max_pcr >= ATM_OC3_PCR);
+	if (unlimited && zatm_dev->ubr != -1) zatm_vcc->shaper = zatm_dev->ubr;
+	else {
+		if (unlimited) vcc->qos.txtp.max_sdu = ATM_MAX_AAL5_PDU;
+		if ((zatm_vcc->shaper = alloc_shaper(vcc->dev,&pcr,
+		    vcc->qos.txtp.min_pcr,vcc->qos.txtp.max_pcr,unlimited))
+		    < 0) {
+			close_tx(vcc);
+			return zatm_vcc->shaper;
+		}
+		if (pcr > ATM_OC3_PCR) pcr = ATM_OC3_PCR;
+		vcc->qos.txtp.min_pcr = vcc->qos.txtp.max_pcr = pcr;
+	}
+	zatm_vcc->tx_chan = chan;
+	skb_queue_head_init(&zatm_vcc->tx_queue);
+	init_waitqueue_head(&zatm_vcc->tx_wait);
+	/* initialize ring */
+	zatm_vcc->ring = kmalloc(RING_SIZE,GFP_KERNEL);
+	if (!zatm_vcc->ring) return -ENOMEM;
+	memset(zatm_vcc->ring,0,RING_SIZE);
+	loop = zatm_vcc->ring+RING_ENTRIES*RING_WORDS;
+	loop[0] = uPD98401_TXPD_V;
+	loop[1] = loop[2] = 0;
+	loop[3] = virt_to_bus(zatm_vcc->ring);
+	zatm_vcc->ring_curr = 0;
+	zatm_vcc->txing = 0;
+	skb_queue_head_init(&zatm_vcc->backlog);
+	zpokel(zatm_dev,virt_to_bus(zatm_vcc->ring),
+	    chan*VC_SIZE/4+uPD98401_TXVC_QRP);
+	return 0;
+}
+
+
+static int open_tx_second(struct atm_vcc *vcc)
+{
+	struct zatm_dev *zatm_dev;
+	struct zatm_vcc *zatm_vcc;
+	unsigned long flags;
+
+	DPRINTK("open_tx_second\n");
+	zatm_dev = ZATM_DEV(vcc->dev);
+	zatm_vcc = ZATM_VCC(vcc);
+	if (!zatm_vcc->tx_chan) return 0;
+	/* set up VC descriptor */
+	spin_lock_irqsave(&zatm_dev->lock, flags);
+	zpokel(zatm_dev,0,zatm_vcc->tx_chan*VC_SIZE/4);
+	zpokel(zatm_dev,uPD98401_TXVC_L | (zatm_vcc->shaper <<
+	    uPD98401_TXVC_SHP_SHIFT) | (vcc->vpi << uPD98401_TXVC_VPI_SHIFT) |
+	    vcc->vci,zatm_vcc->tx_chan*VC_SIZE/4+1);
+	zpokel(zatm_dev,0,zatm_vcc->tx_chan*VC_SIZE/4+2);
+	spin_unlock_irqrestore(&zatm_dev->lock, flags);
+	zatm_dev->tx_map[zatm_vcc->tx_chan] = vcc;
+	return 0;
+}
+
+
+static int start_tx(struct atm_dev *dev)
+{
+	struct zatm_dev *zatm_dev;
+	int i;
+
+	DPRINTK("start_tx\n");
+	zatm_dev = ZATM_DEV(dev);
+	zatm_dev->tx_map = (struct atm_vcc **) kmalloc(sizeof(struct atm_vcc *)*
+	    zatm_dev->chans,GFP_KERNEL);
+	if (!zatm_dev->tx_map) return -ENOMEM;
+	zatm_dev->tx_bw = ATM_OC3_PCR;
+	zatm_dev->free_shapers = (1 << NR_SHAPERS)-1;
+	zatm_dev->ubr = -1;
+	zatm_dev->ubr_ref_cnt = 0;
+	/* initialize shapers */
+	for (i = 0; i < NR_SHAPERS; i++) zpokel(zatm_dev,0,uPD98401_PS(i));
+	return 0;
+}
+
+
+/*------------------------------- interrupts --------------------------------*/
+
+
+static irqreturn_t zatm_int(int irq,void *dev_id,struct pt_regs *regs)
+{
+	struct atm_dev *dev;
+	struct zatm_dev *zatm_dev;
+	u32 reason;
+	int handled = 0;
+
+	dev = dev_id;
+	zatm_dev = ZATM_DEV(dev);
+	while ((reason = zin(GSR))) {
+		handled = 1;
+		EVENT("reason 0x%x\n",reason,0);
+		if (reason & uPD98401_INT_PI) {
+			EVENT("PHY int\n",0,0);
+			dev->phy->interrupt(dev);
+		}
+		if (reason & uPD98401_INT_RQA) {
+			unsigned long pools;
+			int i;
+
+			pools = zin(RQA);
+			EVENT("RQA (0x%08x)\n",pools,0);
+			for (i = 0; pools; i++) {
+				if (pools & 1) {
+					refill_pool(dev,i);
+					zatm_dev->pool_info[i].rqa_count++;
+				}
+				pools >>= 1;
+			}
+		}
+		if (reason & uPD98401_INT_RQU) {
+			unsigned long pools;
+			int i;
+			pools = zin(RQU);
+			printk(KERN_WARNING DEV_LABEL "(itf %d): RQU 0x%08lx\n",
+			    dev->number,pools);
+			event_dump();
+			for (i = 0; pools; i++) {
+				if (pools & 1) {
+					refill_pool(dev,i);
+					zatm_dev->pool_info[i].rqu_count++;
+				}
+				pools >>= 1;
+			}
+		}
+		/* don't handle RD */
+		if (reason & uPD98401_INT_SPE)
+			printk(KERN_ALERT DEV_LABEL "(itf %d): system parity "
+			    "error at 0x%08x\n",dev->number,zin(ADDR));
+		if (reason & uPD98401_INT_CPE)
+			printk(KERN_ALERT DEV_LABEL "(itf %d): control memory "
+			    "parity error at 0x%08x\n",dev->number,zin(ADDR));
+		if (reason & uPD98401_INT_SBE) {
+			printk(KERN_ALERT DEV_LABEL "(itf %d): system bus "
+			    "error at 0x%08x\n",dev->number,zin(ADDR));
+			event_dump();
+		}
+		/* don't handle IND */
+		if (reason & uPD98401_INT_MF) {
+			printk(KERN_CRIT DEV_LABEL "(itf %d): mailbox full "
+			    "(0x%x)\n",dev->number,(reason & uPD98401_INT_MF)
+			    >> uPD98401_INT_MF_SHIFT);
+			event_dump();
+			    /* @@@ should try to recover */
+		}
+		if (reason & uPD98401_INT_MM) {
+			if (reason & 1) poll_rx(dev,0);
+			if (reason & 2) poll_rx(dev,1);
+			if (reason & 4) poll_tx(dev,2);
+			if (reason & 8) poll_tx(dev,3);
+		}
+		/* @@@ handle RCRn */
+	}
+	return IRQ_RETVAL(handled);
+}
+
+
+/*----------------------------- (E)EPROM access -----------------------------*/
+
+
+static void __devinit eprom_set(struct zatm_dev *zatm_dev,unsigned long value,
+    unsigned short cmd)
+{
+	int error;
+
+	if ((error = pci_write_config_dword(zatm_dev->pci_dev,cmd,value)))
+		printk(KERN_ERR DEV_LABEL ": PCI write failed (0x%02x)\n",
+		    error);
+}
+
+
+static unsigned long __devinit eprom_get(struct zatm_dev *zatm_dev,
+    unsigned short cmd)
+{
+	unsigned int value;
+	int error;
+
+	if ((error = pci_read_config_dword(zatm_dev->pci_dev,cmd,&value)))
+		printk(KERN_ERR DEV_LABEL ": PCI read failed (0x%02x)\n",
+		    error);
+	return value;
+}
+
+
+static void __devinit eprom_put_bits(struct zatm_dev *zatm_dev,
+    unsigned long data,int bits,unsigned short cmd)
+{
+	unsigned long value;
+	int i;
+
+	for (i = bits-1; i >= 0; i--) {
+		value = ZEPROM_CS | (((data >> i) & 1) ? ZEPROM_DI : 0);
+		eprom_set(zatm_dev,value,cmd);
+		eprom_set(zatm_dev,value | ZEPROM_SK,cmd);
+		eprom_set(zatm_dev,value,cmd);
+	}
+}
+
+
+static void __devinit eprom_get_byte(struct zatm_dev *zatm_dev,
+    unsigned char *byte,unsigned short cmd)
+{
+	int i;
+
+	*byte = 0;
+	for (i = 8; i; i--) {
+		eprom_set(zatm_dev,ZEPROM_CS,cmd);
+		eprom_set(zatm_dev,ZEPROM_CS | ZEPROM_SK,cmd);
+		*byte <<= 1;
+		if (eprom_get(zatm_dev,cmd) & ZEPROM_DO) *byte |= 1;
+		eprom_set(zatm_dev,ZEPROM_CS,cmd);
+	}
+}
+
+
+static unsigned char __devinit eprom_try_esi(struct atm_dev *dev,
+    unsigned short cmd,int offset,int swap)
+{
+	unsigned char buf[ZEPROM_SIZE];
+	struct zatm_dev *zatm_dev;
+	int i;
+
+	zatm_dev = ZATM_DEV(dev);
+	for (i = 0; i < ZEPROM_SIZE; i += 2) {
+		eprom_set(zatm_dev,ZEPROM_CS,cmd); /* select EPROM */
+		eprom_put_bits(zatm_dev,ZEPROM_CMD_READ,ZEPROM_CMD_LEN,cmd);
+		eprom_put_bits(zatm_dev,i >> 1,ZEPROM_ADDR_LEN,cmd);
+		eprom_get_byte(zatm_dev,buf+i+swap,cmd);
+		eprom_get_byte(zatm_dev,buf+i+1-swap,cmd);
+		eprom_set(zatm_dev,0,cmd); /* deselect EPROM */
+	}
+	memcpy(dev->esi,buf+offset,ESI_LEN);
+	return memcmp(dev->esi,"\0\0\0\0\0",ESI_LEN); /* assumes ESI_LEN == 6 */
+}
+
+
+static void __devinit eprom_get_esi(struct atm_dev *dev)
+{
+	if (eprom_try_esi(dev,ZEPROM_V1_REG,ZEPROM_V1_ESI_OFF,1)) return;
+	(void) eprom_try_esi(dev,ZEPROM_V2_REG,ZEPROM_V2_ESI_OFF,0);
+}
+
+
+/*--------------------------------- entries ---------------------------------*/
+
+
+static int __init zatm_init(struct atm_dev *dev)
+{
+	struct zatm_dev *zatm_dev;
+	struct pci_dev *pci_dev;
+	unsigned short command;
+	unsigned char revision;
+	int error,i,last;
+	unsigned long t0,t1,t2;
+
+	DPRINTK(">zatm_init\n");
+	zatm_dev = ZATM_DEV(dev);
+	spin_lock_init(&zatm_dev->lock);
+	pci_dev = zatm_dev->pci_dev;
+	zatm_dev->base = pci_resource_start(pci_dev, 0);
+	zatm_dev->irq = pci_dev->irq;
+	if ((error = pci_read_config_word(pci_dev,PCI_COMMAND,&command)) ||
+	    (error = pci_read_config_byte(pci_dev,PCI_REVISION_ID,&revision))) {
+		printk(KERN_ERR DEV_LABEL "(itf %d): init error 0x%02x\n",
+		    dev->number,error);
+		return -EINVAL;
+	}
+	if ((error = pci_write_config_word(pci_dev,PCI_COMMAND,
+	    command | PCI_COMMAND_IO | PCI_COMMAND_MASTER))) {
+		printk(KERN_ERR DEV_LABEL "(itf %d): can't enable IO (0x%02x)"
+		    "\n",dev->number,error);
+		return -EIO;
+	}
+	eprom_get_esi(dev);
+	printk(KERN_NOTICE DEV_LABEL "(itf %d): rev.%d,base=0x%x,irq=%d,",
+	    dev->number,revision,zatm_dev->base,zatm_dev->irq);
+	/* reset uPD98401 */
+	zout(0,SWR);
+	while (!(zin(GSR) & uPD98401_INT_IND));
+	zout(uPD98401_GMR_ONE /*uPD98401_BURST4*/,GMR);
+	last = MAX_CRAM_SIZE;
+	for (i = last-RAM_INCREMENT; i >= 0; i -= RAM_INCREMENT) {
+		zpokel(zatm_dev,0x55555555,i);
+		if (zpeekl(zatm_dev,i) != 0x55555555) last = i;
+		else {
+			zpokel(zatm_dev,0xAAAAAAAA,i);
+			if (zpeekl(zatm_dev,i) != 0xAAAAAAAA) last = i;
+			else zpokel(zatm_dev,i,i);
+		}
+	}
+	for (i = 0; i < last; i += RAM_INCREMENT)
+		if (zpeekl(zatm_dev,i) != i) break;
+	zatm_dev->mem = i << 2;
+	while (i) zpokel(zatm_dev,0,--i);
+	/* reset again to rebuild memory pointers */
+	zout(0,SWR);
+	while (!(zin(GSR) & uPD98401_INT_IND));
+	zout(uPD98401_GMR_ONE | uPD98401_BURST8 | uPD98401_BURST4 |
+	    uPD98401_BURST2 | uPD98401_GMR_PM | uPD98401_GMR_DR,GMR);
+	/* TODO: should shrink allocation now */
+	printk("mem=%dkB,%s (",zatm_dev->mem >> 10,zatm_dev->copper ? "UTP" :
+	    "MMF");
+	for (i = 0; i < ESI_LEN; i++)
+		printk("%02X%s",dev->esi[i],i == ESI_LEN-1 ? ")\n" : "-");
+	do {
+		unsigned long flags;
+
+		spin_lock_irqsave(&zatm_dev->lock, flags);
+		t0 = zpeekl(zatm_dev,uPD98401_TSR);
+		udelay(10);
+		t1 = zpeekl(zatm_dev,uPD98401_TSR);
+		udelay(1010);
+		t2 = zpeekl(zatm_dev,uPD98401_TSR);
+		spin_unlock_irqrestore(&zatm_dev->lock, flags);
+	}
+	while (t0 > t1 || t1 > t2); /* loop if wrapping ... */
+	zatm_dev->khz = t2-2*t1+t0;
+	printk(KERN_NOTICE DEV_LABEL "(itf %d): uPD98401 %d.%d at %d.%03d "
+	    "MHz\n",dev->number,
+	    (zin(VER) & uPD98401_MAJOR) >> uPD98401_MAJOR_SHIFT,
+            zin(VER) & uPD98401_MINOR,zatm_dev->khz/1000,zatm_dev->khz % 1000);
+	return uPD98402_init(dev);
+}
+
+
+static int __init zatm_start(struct atm_dev *dev)
+{
+	struct zatm_dev *zatm_dev;
+	unsigned long curr;
+	int pools,vccs,rx;
+	int error,i,ld;
+
+	DPRINTK("zatm_start\n");
+	zatm_dev = ZATM_DEV(dev);
+	zatm_dev->rx_map = zatm_dev->tx_map = NULL;
+	for (i = 0; i < NR_MBX; i++)
+		zatm_dev->mbx_start[i] = 0;
+	if (request_irq(zatm_dev->irq,&zatm_int,SA_SHIRQ,DEV_LABEL,dev)) {
+		printk(KERN_ERR DEV_LABEL "(itf %d): IRQ%d is already in use\n",
+		    dev->number,zatm_dev->irq);
+		return -EAGAIN;
+	}
+	request_region(zatm_dev->base,uPD98401_PORTS,DEV_LABEL);
+	/* define memory regions */
+	pools = NR_POOLS;
+	if (NR_SHAPERS*SHAPER_SIZE > pools*POOL_SIZE)
+		pools = NR_SHAPERS*SHAPER_SIZE/POOL_SIZE;
+	vccs = (zatm_dev->mem-NR_SHAPERS*SHAPER_SIZE-pools*POOL_SIZE)/
+	    (2*VC_SIZE+RX_SIZE);
+	ld = -1;
+	for (rx = 1; rx < vccs; rx <<= 1) ld++;
+	dev->ci_range.vpi_bits = 0; /* @@@ no VPI for now */
+	dev->ci_range.vci_bits = ld;
+	dev->link_rate = ATM_OC3_PCR;
+	zatm_dev->chans = vccs; /* ??? */
+	curr = rx*RX_SIZE/4;
+	DPRINTK("RX pool 0x%08lx\n",curr);
+	zpokel(zatm_dev,curr,uPD98401_PMA); /* receive pool */
+	zatm_dev->pool_base = curr;
+	curr += pools*POOL_SIZE/4;
+	DPRINTK("Shapers 0x%08lx\n",curr);
+	zpokel(zatm_dev,curr,uPD98401_SMA); /* shapers */
+	curr += NR_SHAPERS*SHAPER_SIZE/4;
+	DPRINTK("Free    0x%08lx\n",curr);
+	zpokel(zatm_dev,curr,uPD98401_TOS); /* free pool */
+	printk(KERN_INFO DEV_LABEL "(itf %d): %d shapers, %d pools, %d RX, "
+	    "%ld VCs\n",dev->number,NR_SHAPERS,pools,rx,
+	    (zatm_dev->mem-curr*4)/VC_SIZE);
+	/* create mailboxes */
+	for (i = 0; i < NR_MBX; i++)
+		if (mbx_entries[i]) {
+			unsigned long here;
+
+			here = (unsigned long) kmalloc(2*MBX_SIZE(i),
+			    GFP_KERNEL);
+			if (!here) {
+				error = -ENOMEM;
+				goto out;
+			}
+			if ((here^(here+MBX_SIZE(i))) & ~0xffffUL)/* paranoia */
+				here = (here & ~0xffffUL)+0x10000;
+			zatm_dev->mbx_start[i] = here;
+			if ((here^virt_to_bus((void *) here)) & 0xffff) {
+				printk(KERN_ERR DEV_LABEL "(itf %d): system "
+				    "bus incompatible with driver\n",
+				    dev->number);
+				error = -ENODEV;
+				goto out;
+			}
+			DPRINTK("mbx@0x%08lx-0x%08lx\n",here,here+MBX_SIZE(i));
+			zatm_dev->mbx_end[i] = (here+MBX_SIZE(i)) & 0xffff;
+			zout(virt_to_bus((void *) here) >> 16,MSH(i));
+			zout(virt_to_bus((void *) here),MSL(i));
+			zout((here+MBX_SIZE(i)) & 0xffff,MBA(i));
+			zout(here & 0xffff,MTA(i));
+			zout(here & 0xffff,MWA(i));
+		}
+	error = start_tx(dev);
+	if (error) goto out;
+	error = start_rx(dev);
+	if (error) goto out;
+	error = dev->phy->start(dev);
+	if (error) goto out;
+	zout(0xffffffff,IMR); /* enable interrupts */
+	/* enable TX & RX */
+	zout(zin(GMR) | uPD98401_GMR_SE | uPD98401_GMR_RE,GMR);
+	return 0;
+    out:
+	for (i = 0; i < NR_MBX; i++)
+		if (zatm_dev->mbx_start[i] != 0)
+			kfree((void *) zatm_dev->mbx_start[i]);
+	if (zatm_dev->rx_map != NULL)
+		kfree(zatm_dev->rx_map);
+	if (zatm_dev->tx_map != NULL)
+		kfree(zatm_dev->tx_map);
+	free_irq(zatm_dev->irq, dev);
+	return error;
+}
+
+
+static void zatm_close(struct atm_vcc *vcc)
+{
+        DPRINTK(">zatm_close\n");
+        if (!ZATM_VCC(vcc)) return;
+	clear_bit(ATM_VF_READY,&vcc->flags);
+        close_rx(vcc);
+	EVENT("close_tx\n",0,0);
+        close_tx(vcc);
+        DPRINTK("zatm_close: done waiting\n");
+        /* deallocate memory */
+        kfree(ZATM_VCC(vcc));
+	vcc->dev_data = NULL;
+	clear_bit(ATM_VF_ADDR,&vcc->flags);
+}
+
+
+static int zatm_open(struct atm_vcc *vcc)
+{
+	struct zatm_dev *zatm_dev;
+	struct zatm_vcc *zatm_vcc;
+	short vpi = vcc->vpi;
+	int vci = vcc->vci;
+	int error;
+
+	DPRINTK(">zatm_open\n");
+	zatm_dev = ZATM_DEV(vcc->dev);
+	if (!test_bit(ATM_VF_PARTIAL,&vcc->flags))
+		vcc->dev_data = NULL;
+	if (vci != ATM_VPI_UNSPEC && vpi != ATM_VCI_UNSPEC)
+		set_bit(ATM_VF_ADDR,&vcc->flags);
+	if (vcc->qos.aal != ATM_AAL5) return -EINVAL; /* @@@ AAL0 */
+	DPRINTK(DEV_LABEL "(itf %d): open %d.%d\n",vcc->dev->number,vcc->vpi,
+	    vcc->vci);
+	if (!test_bit(ATM_VF_PARTIAL,&vcc->flags)) {
+		zatm_vcc = kmalloc(sizeof(struct zatm_vcc),GFP_KERNEL);
+		if (!zatm_vcc) {
+			clear_bit(ATM_VF_ADDR,&vcc->flags);
+			return -ENOMEM;
+		}
+		vcc->dev_data = zatm_vcc;
+		ZATM_VCC(vcc)->tx_chan = 0; /* for zatm_close after open_rx */
+		if ((error = open_rx_first(vcc))) {
+	                zatm_close(vcc);
+	                return error;
+	        }
+		if ((error = open_tx_first(vcc))) {
+			zatm_close(vcc);
+			return error;
+	        }
+	}
+	if (vci == ATM_VPI_UNSPEC || vpi == ATM_VCI_UNSPEC) return 0;
+	if ((error = open_rx_second(vcc))) {
+		zatm_close(vcc);
+		return error;
+        }
+	if ((error = open_tx_second(vcc))) {
+		zatm_close(vcc);
+		return error;
+        }
+	set_bit(ATM_VF_READY,&vcc->flags);
+        return 0;
+}
+
+
+static int zatm_change_qos(struct atm_vcc *vcc,struct atm_qos *qos,int flags)
+{
+	printk("Not yet implemented\n");
+	return -ENOSYS;
+	/* @@@ */
+}
+
+
+static int zatm_ioctl(struct atm_dev *dev,unsigned int cmd,void __user *arg)
+{
+	struct zatm_dev *zatm_dev;
+	unsigned long flags;
+
+	zatm_dev = ZATM_DEV(dev);
+	switch (cmd) {
+		case ZATM_GETPOOLZ:
+			if (!capable(CAP_NET_ADMIN)) return -EPERM;
+			/* fall through */
+		case ZATM_GETPOOL:
+			{
+				struct zatm_pool_info info;
+				int pool;
+
+				if (get_user(pool,
+				    &((struct zatm_pool_req __user *) arg)->pool_num))
+					return -EFAULT;
+				if (pool < 0 || pool > ZATM_LAST_POOL)
+					return -EINVAL;
+				spin_lock_irqsave(&zatm_dev->lock, flags);
+				info = zatm_dev->pool_info[pool];
+				if (cmd == ZATM_GETPOOLZ) {
+					zatm_dev->pool_info[pool].rqa_count = 0;
+					zatm_dev->pool_info[pool].rqu_count = 0;
+				}
+				spin_unlock_irqrestore(&zatm_dev->lock, flags);
+				return copy_to_user(
+				    &((struct zatm_pool_req __user *) arg)->info,
+				    &info,sizeof(info)) ? -EFAULT : 0;
+			}
+		case ZATM_SETPOOL:
+			{
+				struct zatm_pool_info info;
+				int pool;
+
+				if (!capable(CAP_NET_ADMIN)) return -EPERM;
+				if (get_user(pool,
+				    &((struct zatm_pool_req __user *) arg)->pool_num))
+					return -EFAULT;
+				if (pool < 0 || pool > ZATM_LAST_POOL)
+					return -EINVAL;
+				if (copy_from_user(&info,
+				    &((struct zatm_pool_req __user *) arg)->info,
+				    sizeof(info))) return -EFAULT;
+				if (!info.low_water)
+					info.low_water = zatm_dev->
+					    pool_info[pool].low_water;
+				if (!info.high_water)
+					info.high_water = zatm_dev->
+					    pool_info[pool].high_water;
+				if (!info.next_thres)
+					info.next_thres = zatm_dev->
+					    pool_info[pool].next_thres;
+				if (info.low_water >= info.high_water ||
+				    info.low_water < 0)
+					return -EINVAL;
+				spin_lock_irqsave(&zatm_dev->lock, flags);
+				zatm_dev->pool_info[pool].low_water =
+				    info.low_water;
+				zatm_dev->pool_info[pool].high_water =
+				    info.high_water;
+				zatm_dev->pool_info[pool].next_thres =
+				    info.next_thres;
+				spin_unlock_irqrestore(&zatm_dev->lock, flags);
+				return 0;
+			}
+		default:
+        		if (!dev->phy->ioctl) return -ENOIOCTLCMD;
+		        return dev->phy->ioctl(dev,cmd,arg);
+	}
+}
+
+
+static int zatm_getsockopt(struct atm_vcc *vcc,int level,int optname,
+    void __user *optval,int optlen)
+{
+	return -EINVAL;
+}
+
+
+static int zatm_setsockopt(struct atm_vcc *vcc,int level,int optname,
+    void __user *optval,int optlen)
+{
+	return -EINVAL;
+}
+
+static int zatm_send(struct atm_vcc *vcc,struct sk_buff *skb)
+{
+	int error;
+
+	EVENT(">zatm_send 0x%lx\n",(unsigned long) skb,0);
+	if (!ZATM_VCC(vcc)->tx_chan || !test_bit(ATM_VF_READY,&vcc->flags)) {
+		if (vcc->pop) vcc->pop(vcc,skb);
+		else dev_kfree_skb(skb);
+		return -EINVAL;
+	}
+	if (!skb) {
+		printk(KERN_CRIT "!skb in zatm_send ?\n");
+		if (vcc->pop) vcc->pop(vcc,skb);
+		return -EINVAL;
+	}
+	ATM_SKB(skb)->vcc = vcc;
+	error = do_tx(skb);
+	if (error != RING_BUSY) return error;
+	skb_queue_tail(&ZATM_VCC(vcc)->backlog,skb);
+	return 0;
+}
+
+
+static void zatm_phy_put(struct atm_dev *dev,unsigned char value,
+    unsigned long addr)
+{
+	struct zatm_dev *zatm_dev;
+
+	zatm_dev = ZATM_DEV(dev);
+	zwait;
+	zout(value,CER);
+	zout(uPD98401_IND_ACC | uPD98401_IA_B0 |
+	    (uPD98401_IA_TGT_PHY << uPD98401_IA_TGT_SHIFT) | addr,CMR);
+}
+
+
+static unsigned char zatm_phy_get(struct atm_dev *dev,unsigned long addr)
+{
+	struct zatm_dev *zatm_dev;
+
+	zatm_dev = ZATM_DEV(dev);
+	zwait;
+	zout(uPD98401_IND_ACC | uPD98401_IA_B0 | uPD98401_IA_RW |
+	  (uPD98401_IA_TGT_PHY << uPD98401_IA_TGT_SHIFT) | addr,CMR);
+	zwait;
+	return zin(CER) & 0xff;
+}
+
+
+static const struct atmdev_ops ops = {
+	.open		= zatm_open,
+	.close		= zatm_close,
+	.ioctl		= zatm_ioctl,
+	.getsockopt	= zatm_getsockopt,
+	.setsockopt	= zatm_setsockopt,
+	.send		= zatm_send,
+	.phy_put	= zatm_phy_put,
+	.phy_get	= zatm_phy_get,
+	.change_qos	= zatm_change_qos,
+};
+
+static int __devinit zatm_init_one(struct pci_dev *pci_dev,
+				   const struct pci_device_id *ent)
+{
+	struct atm_dev *dev;
+	struct zatm_dev *zatm_dev;
+	int ret = -ENOMEM;
+
+	zatm_dev = (struct zatm_dev *) kmalloc(sizeof(*zatm_dev), GFP_KERNEL);
+	if (!zatm_dev) {
+		printk(KERN_EMERG "%s: memory shortage\n", DEV_LABEL);
+		goto out;
+	}
+
+	dev = atm_dev_register(DEV_LABEL, &ops, -1, NULL);
+	if (!dev)
+		goto out_free;
+
+	ret = pci_enable_device(pci_dev);
+	if (ret < 0)
+		goto out_deregister;
+
+	ret = pci_request_regions(pci_dev, DEV_LABEL);
+	if (ret < 0)
+		goto out_disable;
+
+	zatm_dev->pci_dev = pci_dev;
+	dev->dev_data = zatm_dev;
+	zatm_dev->copper = (int)ent->driver_data;
+	if ((ret = zatm_init(dev)) || (ret = zatm_start(dev)))
+		goto out_release;
+
+	pci_set_drvdata(pci_dev, dev);
+	zatm_dev->more = zatm_boards;
+	zatm_boards = dev;
+	ret = 0;
+out:
+	return ret;
+
+out_release:
+	pci_release_regions(pci_dev);
+out_disable:
+	pci_disable_device(pci_dev);
+out_deregister:
+	atm_dev_deregister(dev);
+out_free:
+	kfree(zatm_dev);
+	goto out;
+}
+
+
+MODULE_LICENSE("GPL");
+
+static struct pci_device_id zatm_pci_tbl[] __devinitdata = {
+	{ PCI_VENDOR_ID_ZEITNET, PCI_DEVICE_ID_ZEITNET_1221,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, ZATM_COPPER },
+	{ PCI_VENDOR_ID_ZEITNET, PCI_DEVICE_ID_ZEITNET_1225,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ 0, }
+};
+MODULE_DEVICE_TABLE(pci, zatm_pci_tbl);
+
+static struct pci_driver zatm_driver = {
+	.name =		DEV_LABEL,
+	.id_table =	zatm_pci_tbl,
+	.probe =	zatm_init_one,
+};
+
+static int __init zatm_init_module(void)
+{
+	return pci_register_driver(&zatm_driver);
+}
+
+module_init(zatm_init_module);
+/* module_exit not defined so not unloadable */
