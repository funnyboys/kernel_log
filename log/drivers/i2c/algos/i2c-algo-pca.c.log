commit cd217f2300793a106b49c7dfcbfb26e348bc7593
Author: Chris Packham <chris.packham@alliedtelesis.co.nz>
Date:   Thu Jul 2 10:39:11 2020 +1200

    i2c: algo-pca: Add 0x78 as SCL stuck low status for PCA9665
    
    The PCA9665 datasheet says that I2CSTA = 78h indicates that SCL is stuck
    low, this differs to the PCA9564 which uses 90h for this indication.
    Treat either 0x78 or 0x90 as an indication that the SCL line is stuck.
    
    Based on looking through the PCA9564 and PCA9665 datasheets this should
    be safe for both chips. The PCA9564 should not return 0x78 for any valid
    state and the PCA9665 should not return 0x90.
    
    Fixes: eff9ec95efaa ("i2c-algo-pca: Add PCA9665 support")
    Signed-off-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@kernel.org>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 7f10312d1b88..388978775be0 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -314,7 +314,8 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 			DEB2("BUS ERROR - SDA Stuck low\n");
 			pca_reset(adap);
 			goto out;
-		case 0x90: /* Bus error - SCL stuck low */
+		case 0x78: /* Bus error - SCL stuck low (PCA9665) */
+		case 0x90: /* Bus error - SCL stuck low (PCA9564) */
 			DEB2("BUS ERROR - SCL Stuck low\n");
 			pca_reset(adap);
 			goto out;

commit ab7cf7e53ccf1fecec6b72d1a3a13ff88193b490
Author: Wolfram Sang <wsa@kernel.org>
Date:   Sat May 2 16:26:49 2020 +0200

    i2c: algo-pca: update contact email
    
    The 'pengutronix' address is defunct for years. Use the proper contact
    address.
    
    Signed-off-by: Wolfram Sang <wsa@kernel.org>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index dff4e178c732..7f10312d1b88 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -542,7 +542,7 @@ int i2c_pca_add_numbered_bus(struct i2c_adapter *adap)
 EXPORT_SYMBOL(i2c_pca_add_numbered_bus);
 
 MODULE_AUTHOR("Ian Campbell <icampbell@arcom.com>, "
-	"Wolfram Sang <w.sang@pengutronix.de>");
+	"Wolfram Sang <kernel@pengutronix.de>");
 MODULE_DESCRIPTION("I2C-Bus PCA9564/PCA9665 algorithm");
 MODULE_LICENSE("GPL");
 

commit 7b8c4c0b2acbdf355f0b78557d6f7290955d726d
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Mar 24 14:32:15 2020 +0200

    i2c: algo: Use generic definitions for bus frequencies
    
    Since we have generic definitions for bus frequencies, let's use them.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 5ac93f41bfec..dff4e178c732 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -459,17 +459,17 @@ static int pca_init(struct i2c_adapter *adap)
 		/* To avoid integer overflow, use clock/100 for calculations */
 		clock = pca_clock(pca_data) / 100;
 
-		if (pca_data->i2c_clock > 1000000) {
+		if (pca_data->i2c_clock > I2C_MAX_FAST_MODE_PLUS_FREQ) {
 			mode = I2C_PCA_MODE_TURBO;
 			min_tlow = 14;
 			min_thi  = 5;
 			raise_fall_time = 22; /* Raise 11e-8s, Fall 11e-8s */
-		} else if (pca_data->i2c_clock > 400000) {
+		} else if (pca_data->i2c_clock > I2C_MAX_FAST_MODE_FREQ) {
 			mode = I2C_PCA_MODE_FASTP;
 			min_tlow = 17;
 			min_thi  = 9;
 			raise_fall_time = 22; /* Raise 11e-8s, Fall 11e-8s */
-		} else if (pca_data->i2c_clock > 100000) {
+		} else if (pca_data->i2c_clock > I2C_MAX_STANDARD_MODE_FREQ) {
 			mode = I2C_PCA_MODE_FAST;
 			min_tlow = 44;
 			min_thi  = 20;

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 883a290f6a4d..5ac93f41bfec 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -1,17 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  i2c-algo-pca.c i2c driver algorithms for PCA9564 adapters
  *    Copyright (C) 2004 Arcom Control Systems
  *    Copyright (C) 2008 Pengutronix
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
  */
 
 #include <linux/kernel.h>

commit ac6d5298f6af763b587495d62041fe57a2fb89e6
Author: Peter Rosin <peda@axentia.se>
Date:   Wed May 16 09:16:46 2018 +0200

    i2c: algos: make use of i2c_8bit_addr_from_msg
    
    Because it looks neater.
    
    Signed-off-by: Peter Rosin <peda@axentia.se>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index e370804ec8bc..883a290f6a4d 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -112,11 +112,8 @@ static int pca_address(struct i2c_algo_pca_data *adap,
 		       struct i2c_msg *msg)
 {
 	int sta = pca_get_con(adap);
-	int addr;
+	int addr = i2c_8bit_addr_from_msg(msg);
 
-	addr = ((0x7f & msg->addr) << 1);
-	if (msg->flags & I2C_M_RD)
-		addr |= 1;
 	DEB2("=== SLAVE ADDRESS %#04x+%c=%#04x\n",
 	     msg->addr, msg->flags & I2C_M_RD ? 'R' : 'W', addr);
 

commit 0e6dd6a232e1910b00776318ec8b82589769a64c
Author: Shailendra Verma <shailendra.capricorn@gmail.com>
Date:   Mon May 18 22:37:54 2015 +0530

    i2c: algo-pca: fix typo in comment
    
    Signed-off-by: Shailendra Verma <shailendra.capricorn@gmail.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 580dbf05c148..e370804ec8bc 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -521,7 +521,7 @@ static int pca_init(struct i2c_adapter *adap)
 
 		pca_set_con(pca_data, I2C_PCA_CON_ENSIO);
 	}
-	udelay(500); /* 500 us for oscilator to stabilise */
+	udelay(500); /* 500 us for oscillator to stabilise */
 
 	return 0;
 }

commit ca1f8da9ac5ce6e63d8f6933f83fabc1f3f961f4
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue Nov 4 23:46:27 2014 +0100

    i2c: remove FSF address
    
    We have a central copy of the GPL for that. Some addresses were already
    outdated.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 8b10f88b13d9..580dbf05c148 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -12,11 +12,6 @@
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- *  MA 02110-1301 USA.
  */
 
 #include <linux/kernel.h>

commit 21d0b7c0faf2f780afa2bef72cc921ace10a7356
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Jan 21 16:22:54 2014 -0500

    i2c: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Acked-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index f892a424009b..8b10f88b13d9 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -24,7 +24,6 @@
 #include <linux/moduleparam.h>
 #include <linux/delay.h>
 #include <linux/jiffies.h>
-#include <linux/init.h>
 #include <linux/errno.h>
 #include <linux/i2c.h>
 #include <linux/i2c-algo-pca.h>

commit 102084d3d3969646cc89ea159e50898aeafc6649
Merge: 6ccbe607132b 979570e02981
Author: Wolfram Sang <w.sang@pengutronix.de>
Date:   Mon Oct 8 12:46:32 2012 +0200

    Merge tag 'v3.6-rc7' into i2c-embedded/for-next
    
    Linux 3.6-rc7
    
    Needed to get updates from i2c-embedded/for-current into i2c-embedded/for-next

commit a76e7c6821b5dddf69db9d76ec282819545f5b73
Author: Thomas Kavanagh <tkavanagh@juniper.net>
Date:   Thu Sep 20 20:20:46 2012 -0700

    i2c: algo: pca: Fix chip reset function for PCA9665
    
    The parameter passed to pca9665_reset is adap->data (which is bus driver
    specific), not i2c_algp_pca_data *adap. pca9665_reset expects it to be
    i2c_algp_pca_data *adap. All other wrappers from the algo call back to
    the bus driver, which knows to handle its custom data. Only pca9665_reset
    resides inside the algorithm code and does not know how to handle a custom
    data structure. This can result in a kernel crash.
    
    Fix by re-factoring pca_reset() from a macro to a function handling chip
    specific code, and only call adap->reset_chip() if the chip is not PCA9665.
    
    Signed-off-by: Thomas Kavanagh <tkavanagh@juniper.net>
    Signed-off-by: Guenter Roeck <groeck@juniper.net>
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 73133b1063f0..07ccbef6cc14 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -46,14 +46,19 @@ static int i2c_debug;
 #define pca_set_con(adap, val) pca_outw(adap, I2C_PCA_CON, val)
 #define pca_get_con(adap) pca_inw(adap, I2C_PCA_CON)
 #define pca_wait(adap) adap->wait_for_completion(adap->data)
-#define pca_reset(adap) adap->reset_chip(adap->data)
 
-static void pca9665_reset(void *pd)
+static void pca_reset(struct i2c_algo_pca_data *adap)
 {
-	struct i2c_algo_pca_data *adap = pd;
-	pca_outw(adap, I2C_PCA_INDPTR, I2C_PCA_IPRESET);
-	pca_outw(adap, I2C_PCA_IND, 0xA5);
-	pca_outw(adap, I2C_PCA_IND, 0x5A);
+	if (adap->chip == I2C_PCA_CHIP_9665) {
+		/* Ignore the reset function from the module,
+		 * we can use the parallel bus reset.
+		 */
+		pca_outw(adap, I2C_PCA_INDPTR, I2C_PCA_IPRESET);
+		pca_outw(adap, I2C_PCA_IND, 0xA5);
+		pca_outw(adap, I2C_PCA_IND, 0x5A);
+	} else {
+		adap->reset_chip(adap->data);
+	}
 }
 
 /*
@@ -378,11 +383,12 @@ static unsigned int pca_probe_chip(struct i2c_adapter *adap)
 	pca_outw(pca_data, I2C_PCA_INDPTR, I2C_PCA_IADR);
 	if (pca_inw(pca_data, I2C_PCA_IND) == 0xAA) {
 		printk(KERN_INFO "%s: PCA9665 detected.\n", adap->name);
-		return I2C_PCA_CHIP_9665;
+		pca_data->chip = I2C_PCA_CHIP_9665;
 	} else {
 		printk(KERN_INFO "%s: PCA9564 detected.\n", adap->name);
-		return I2C_PCA_CHIP_9564;
+		pca_data->chip = I2C_PCA_CHIP_9564;
 	}
+	return pca_data->chip;
 }
 
 static int pca_init(struct i2c_adapter *adap)
@@ -456,11 +462,6 @@ static int pca_init(struct i2c_adapter *adap)
 		 */
 		int raise_fall_time;
 
-		/* Ignore the reset function from the module,
-		 * we can use the parallel bus reset
-		 */
-		pca_data->reset_chip = pca9665_reset;
-
 		if (pca_data->i2c_clock > 1265800) {
 			printk(KERN_WARNING "%s: I2C clock speed too high."
 				" Using 1265.8kHz.\n", adap->name);

commit 5f71a3ef3753ac2068009637eee619e163f44b30
Author: Thomas Kavanagh <tkavanagh@juniper.net>
Date:   Thu Sep 13 08:16:55 2012 -0700

    i2c: algo: pca: Fix mode selection for PCA9665
    
    The code currently always selects turbo mode for PCA9665, no matter which
    clock frequency is configured. This is because it compares the clock frequency
    against constants reflecting (boundary / 100). Compare against real boundary
    frequencies to fix the problem.
    
    Signed-off-by: Thomas Kavanagh <tkavanagh@juniper.net>
    Signed-off-by: Guenter Roeck <groeck@juniper.net>
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 73133b1063f0..6f5f98d69af7 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -476,17 +476,17 @@ static int pca_init(struct i2c_adapter *adap)
 		/* To avoid integer overflow, use clock/100 for calculations */
 		clock = pca_clock(pca_data) / 100;
 
-		if (pca_data->i2c_clock > 10000) {
+		if (pca_data->i2c_clock > 1000000) {
 			mode = I2C_PCA_MODE_TURBO;
 			min_tlow = 14;
 			min_thi  = 5;
 			raise_fall_time = 22; /* Raise 11e-8s, Fall 11e-8s */
-		} else if (pca_data->i2c_clock > 4000) {
+		} else if (pca_data->i2c_clock > 400000) {
 			mode = I2C_PCA_MODE_FASTP;
 			min_tlow = 17;
 			min_thi  = 9;
 			raise_fall_time = 22; /* Raise 11e-8s, Fall 11e-8s */
-		} else if (pca_data->i2c_clock > 1000) {
+		} else if (pca_data->i2c_clock > 100000) {
 			mode = I2C_PCA_MODE_FAST;
 			min_tlow = 44;
 			min_thi  = 20;

commit 5694f8a888f8f69a562e4cf939eed81ca7a5ecf2
Author: Jean Delvare <khali@linux-fr.org>
Date:   Mon Mar 26 21:47:19 2012 +0200

    i2c: Update the FSF address
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index beb9ffe2564b..73133b1063f0 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -15,7 +15,8 @@
  *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ *  MA 02110-1301 USA.
  */
 
 #include <linux/kernel.h>

commit 4403988afc0a92b8faf59b46f51d25fafaf0e63d
Author: Jean Delvare <khali@linux-fr.org>
Date:   Sun Oct 30 13:47:25 2011 +0100

    i2c-algo-pca: Return standard fault codes
    
    Adjust i2c-algo-pca to return fault codes compliant with
    Documentation/i2c/fault-codes, rather than the undocumented and
    vague -EREMOTEIO.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Cc: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 4ca9cf9cde73..beb9ffe2564b 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -196,7 +196,7 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 		} else {
 			dev_dbg(&i2c_adap->dev, "bus is not idle. status is "
 				"%#04x\n", state);
-			return -EAGAIN;
+			return -EBUSY;
 		}
 	}
 
@@ -224,7 +224,7 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 	}
 
 	curmsg = 0;
-	ret = -EREMOTEIO;
+	ret = -EIO;
 	while (curmsg < num) {
 		state = pca_status(adap);
 
@@ -259,6 +259,7 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 		case 0x20: /* SLA+W has been transmitted; NOT ACK has been received */
 			DEB2("NOT ACK received after SLA+W\n");
 			pca_stop(adap);
+			ret = -ENXIO;
 			goto out;
 
 		case 0x40: /* SLA+R has been transmitted; ACK has been received */
@@ -283,6 +284,7 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 		case 0x48: /* SLA+R has been transmitted; NOT ACK has been received */
 			DEB2("NOT ACK received after SLA+R\n");
 			pca_stop(adap);
+			ret = -ENXIO;
 			goto out;
 
 		case 0x30: /* Data byte in I2CDAT has been transmitted; NOT ACK has been received */

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 2b9a8f54bb2c..4ca9cf9cde73 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -343,7 +343,7 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 
 	ret = curmsg;
  out:
-	DEB1("}}} transfered %d/%d messages. "
+	DEB1("}}} transferred %d/%d messages. "
 	     "status is %#04x. control is %#04x\n",
 	     curmsg, num, pca_status(adap),
 	     pca_get_con(adap));

commit 2086ca482f89950410527425913ca48d948e9622
Author: Farid Hammane <farid.hammane@gmail.com>
Date:   Fri May 21 18:41:00 2010 +0200

    i2c-algo-pca: Fix coding style issues
    
    Fix up some coding style issues. i2c-algo-pca.c has been built
    successfully after applying this patch and the binary object is
    still exactly the same. Other issues found by checkpatch.pl were
    voluntarily not fixed, either to keep readability, or because of
    false positive errors.
    
    Signed-off-by: Farid Hammane <farid.hammane@gmail.com>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index dcdaf8e675bf..2b9a8f54bb2c 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -109,13 +109,13 @@ static void pca_stop(struct i2c_algo_pca_data *adap)
  * returns after the address has been sent
  */
 static int pca_address(struct i2c_algo_pca_data *adap,
-			struct i2c_msg *msg)
+		       struct i2c_msg *msg)
 {
 	int sta = pca_get_con(adap);
 	int addr;
 
-	addr = ( (0x7f & msg->addr) << 1 );
-	if (msg->flags & I2C_M_RD )
+	addr = ((0x7f & msg->addr) << 1);
+	if (msg->flags & I2C_M_RD)
 		addr |= 1;
 	DEB2("=== SLAVE ADDRESS %#04x+%c=%#04x\n",
 	     msg->addr, msg->flags & I2C_M_RD ? 'R' : 'W', addr);
@@ -134,7 +134,7 @@ static int pca_address(struct i2c_algo_pca_data *adap,
  * Returns after the byte has been transmitted
  */
 static int pca_tx_byte(struct i2c_algo_pca_data *adap,
-			__u8 b)
+		       __u8 b)
 {
 	int sta = pca_get_con(adap);
 	DEB2("=== WRITE %#04x\n", b);
@@ -164,13 +164,13 @@ static void pca_rx_byte(struct i2c_algo_pca_data *adap,
  * Returns after next byte has arrived.
  */
 static int pca_rx_ack(struct i2c_algo_pca_data *adap,
-		       int ack)
+		      int ack)
 {
 	int sta = pca_get_con(adap);
 
 	sta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_STA|I2C_PCA_CON_SI|I2C_PCA_CON_AA);
 
-	if ( ack )
+	if (ack)
 		sta |= I2C_PCA_CON_AA;
 
 	pca_set_con(adap, sta);
@@ -178,12 +178,12 @@ static int pca_rx_ack(struct i2c_algo_pca_data *adap,
 }
 
 static int pca_xfer(struct i2c_adapter *i2c_adap,
-                    struct i2c_msg *msgs,
-                    int num)
+		    struct i2c_msg *msgs,
+		    int num)
 {
-        struct i2c_algo_pca_data *adap = i2c_adap->algo_data;
-        struct i2c_msg *msg = NULL;
-        int curmsg;
+	struct i2c_algo_pca_data *adap = i2c_adap->algo_data;
+	struct i2c_msg *msg = NULL;
+	int curmsg;
 	int numbytes = 0;
 	int state;
 	int ret;
@@ -202,21 +202,21 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 
 	DEB1("{{{ XFER %d messages\n", num);
 
-	if (i2c_debug>=2) {
+	if (i2c_debug >= 2) {
 		for (curmsg = 0; curmsg < num; curmsg++) {
 			int addr, i;
 			msg = &msgs[curmsg];
 
 			addr = (0x7f & msg->addr) ;
 
-			if (msg->flags & I2C_M_RD )
+			if (msg->flags & I2C_M_RD)
 				printk(KERN_INFO "    [%02d] RD %d bytes from %#02x [%#02x, ...]\n",
-				       curmsg, msg->len, addr, (addr<<1) | 1);
+				       curmsg, msg->len, addr, (addr << 1) | 1);
 			else {
 				printk(KERN_INFO "    [%02d] WR %d bytes to %#02x [%#02x%s",
-				       curmsg, msg->len, addr, addr<<1,
+				       curmsg, msg->len, addr, addr << 1,
 				       msg->len == 0 ? "" : ", ");
-				for(i=0; i < msg->len; i++)
+				for (i = 0; i < msg->len; i++)
 					printk("%#04x%s", msg->buf[i], i == msg->len - 1 ? "" : ", ");
 				printk("]\n");
 			}
@@ -305,7 +305,7 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 			goto out;
 
 		case 0x58: /* Data byte has been received; NOT ACK has been returned */
-			if ( numbytes == msg->len - 1 ) {
+			if (numbytes == msg->len - 1) {
 				pca_rx_byte(adap, &msg->buf[numbytes], 0);
 				curmsg++; numbytes = 0;
 				if (curmsg == num)
@@ -352,7 +352,7 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 
 static u32 pca_func(struct i2c_adapter *adap)
 {
-        return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
 }
 
 static const struct i2c_algorithm pca_algo = {

commit eec74a257f0a695688ba44c0f6c1e92dc81459be
Author: Jean Delvare <khali@linux-fr.org>
Date:   Tue Mar 2 12:23:47 2010 +0100

    i2c-algo-pca: Drop duplicate variable
    
    Thanks to -Wshadow.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Reviewed-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 78d42aae0089..dcdaf8e675bf 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -453,8 +453,6 @@ static int pca_init(struct i2c_adapter *adap)
 		 */
 		int raise_fall_time;
 
-		struct i2c_algo_pca_data *pca_data = adap->algo_data;
-
 		/* Ignore the reset function from the module,
 		 * we can use the parallel bus reset
 		 */

commit 2196d1cf4afab93fb64c2e5b417096e49b661612
Author: Enrik Berkhan <Enrik.Berkhan@ge.com>
Date:   Tue May 5 08:39:25 2009 +0200

    i2c-algo-pca: Let PCA9564 recover from unacked data byte (state 0x30)
    
    Currently, the i2c-algo-pca driver does nothing if the chip enters state
    0x30 (Data byte in I2CDAT has been transmitted; NOT ACK has been
    received).  Thus, the i2c bus connected to the controller gets stuck
    afterwards.
    
    I have seen this kind of error on a custom board in certain load
    situations most probably caused by interference or noise.
    
    A possible reaction is to let the controller generate a STOP condition.
    This is documented in the PCA9564 data sheet (2006-09-01) and the same
    is done for other NACK states as well.
    
    Further, state 0x38 isn't handled completely, either. Try to do another
    START in this case like the data sheet says. As this couldn't be tested,
    I've added a comment to try to reset the chip if the START doesn't help
    as suggested by Wolfram Sang.
    
    Signed-off-by: Enrik Berkhan <Enrik.Berkhan@ge.com>
    Reviewed-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 6318f7ddc1d4..78d42aae0089 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -287,10 +287,21 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 
 		case 0x30: /* Data byte in I2CDAT has been transmitted; NOT ACK has been received */
 			DEB2("NOT ACK received after data byte\n");
+			pca_stop(adap);
 			goto out;
 
 		case 0x38: /* Arbitration lost during SLA+W, SLA+R or data bytes */
 			DEB2("Arbitration lost\n");
+			/*
+			 * The PCA9564 data sheet (2006-09-01) says "A
+			 * START condition will be transmitted when the
+			 * bus becomes free (STOP or SCL and SDA high)"
+			 * when the STA bit is set (p. 11).
+			 *
+			 * In case this won't work, try pca_reset()
+			 * instead.
+			 */
+			pca_start(adap);
 			goto out;
 
 		case 0x58: /* Data byte has been received; NOT ACK has been returned */

commit c454dee21d589476608957ca4f57feaabde62fab
Author: Jean Delvare <khali@linux-fr.org>
Date:   Mon Apr 13 17:02:13 2009 +0200

    i2c-algo-pca: Fix use of uninitialized variable in debug message
    
    A recent change broke debugging of pca_xfer(), fix it.
    
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index f68e5f8e23ee..6318f7ddc1d4 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -190,7 +190,7 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 	int completed = 1;
 	unsigned long timeout = jiffies + i2c_adap->timeout;
 
-	while (pca_status(adap) != 0xf8) {
+	while ((state = pca_status(adap)) != 0xf8) {
 		if (time_before(jiffies, timeout)) {
 			msleep(10);
 		} else {

commit 2378bc09b91b0702fac7823828a614fd8016a29f
Author: Wolfram Sang <w.sang@pengutronix.de>
Date:   Sat Mar 28 21:34:45 2009 +0100

    i2c-algo-pca: Use timeout for checking the state machine
    
    We now timeout also if the state machine does not change within the
    given time. For that, the driver-specific completion-functions are
    extended to return true or false depending on the timeout. This then
    gets checked in the algorithm.
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 9e134fad7bda..f68e5f8e23ee 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -60,14 +60,14 @@ static void pca9665_reset(void *pd)
  *
  * returns after the start condition has occurred
  */
-static void pca_start(struct i2c_algo_pca_data *adap)
+static int pca_start(struct i2c_algo_pca_data *adap)
 {
 	int sta = pca_get_con(adap);
 	DEB2("=== START\n");
 	sta |= I2C_PCA_CON_STA;
 	sta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_SI);
 	pca_set_con(adap, sta);
-	pca_wait(adap);
+	return pca_wait(adap);
 }
 
 /*
@@ -75,14 +75,14 @@ static void pca_start(struct i2c_algo_pca_data *adap)
  *
  * return after the repeated start condition has occurred
  */
-static void pca_repeated_start(struct i2c_algo_pca_data *adap)
+static int pca_repeated_start(struct i2c_algo_pca_data *adap)
 {
 	int sta = pca_get_con(adap);
 	DEB2("=== REPEATED START\n");
 	sta |= I2C_PCA_CON_STA;
 	sta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_SI);
 	pca_set_con(adap, sta);
-	pca_wait(adap);
+	return pca_wait(adap);
 }
 
 /*
@@ -108,7 +108,7 @@ static void pca_stop(struct i2c_algo_pca_data *adap)
  *
  * returns after the address has been sent
  */
-static void pca_address(struct i2c_algo_pca_data *adap,
+static int pca_address(struct i2c_algo_pca_data *adap,
 			struct i2c_msg *msg)
 {
 	int sta = pca_get_con(adap);
@@ -125,7 +125,7 @@ static void pca_address(struct i2c_algo_pca_data *adap,
 	sta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_STA|I2C_PCA_CON_SI);
 	pca_set_con(adap, sta);
 
-	pca_wait(adap);
+	return pca_wait(adap);
 }
 
 /*
@@ -133,7 +133,7 @@ static void pca_address(struct i2c_algo_pca_data *adap,
  *
  * Returns after the byte has been transmitted
  */
-static void pca_tx_byte(struct i2c_algo_pca_data *adap,
+static int pca_tx_byte(struct i2c_algo_pca_data *adap,
 			__u8 b)
 {
 	int sta = pca_get_con(adap);
@@ -143,7 +143,7 @@ static void pca_tx_byte(struct i2c_algo_pca_data *adap,
 	sta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_STA|I2C_PCA_CON_SI);
 	pca_set_con(adap, sta);
 
-	pca_wait(adap);
+	return pca_wait(adap);
 }
 
 /*
@@ -163,7 +163,7 @@ static void pca_rx_byte(struct i2c_algo_pca_data *adap,
  *
  * Returns after next byte has arrived.
  */
-static void pca_rx_ack(struct i2c_algo_pca_data *adap,
+static int pca_rx_ack(struct i2c_algo_pca_data *adap,
 		       int ack)
 {
 	int sta = pca_get_con(adap);
@@ -174,7 +174,7 @@ static void pca_rx_ack(struct i2c_algo_pca_data *adap,
 		sta |= I2C_PCA_CON_AA;
 
 	pca_set_con(adap, sta);
-	pca_wait(adap);
+	return pca_wait(adap);
 }
 
 static int pca_xfer(struct i2c_adapter *i2c_adap,
@@ -187,6 +187,7 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 	int numbytes = 0;
 	int state;
 	int ret;
+	int completed = 1;
 	unsigned long timeout = jiffies + i2c_adap->timeout;
 
 	while (pca_status(adap) != 0xf8) {
@@ -232,18 +233,19 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 
 		switch (state) {
 		case 0xf8: /* On reset or stop the bus is idle */
-			pca_start(adap);
+			completed = pca_start(adap);
 			break;
 
 		case 0x08: /* A START condition has been transmitted */
 		case 0x10: /* A repeated start condition has been transmitted */
-			pca_address(adap, msg);
+			completed = pca_address(adap, msg);
 			break;
 
 		case 0x18: /* SLA+W has been transmitted; ACK has been received */
 		case 0x28: /* Data byte in I2CDAT has been transmitted; ACK has been received */
 			if (numbytes < msg->len) {
-				pca_tx_byte(adap, msg->buf[numbytes]);
+				completed = pca_tx_byte(adap,
+							msg->buf[numbytes]);
 				numbytes++;
 				break;
 			}
@@ -251,7 +253,7 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 			if (curmsg == num)
 				pca_stop(adap);
 			else
-				pca_repeated_start(adap);
+				completed = pca_repeated_start(adap);
 			break;
 
 		case 0x20: /* SLA+W has been transmitted; NOT ACK has been received */
@@ -260,21 +262,22 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 			goto out;
 
 		case 0x40: /* SLA+R has been transmitted; ACK has been received */
-			pca_rx_ack(adap, msg->len > 1);
+			completed = pca_rx_ack(adap, msg->len > 1);
 			break;
 
 		case 0x50: /* Data bytes has been received; ACK has been returned */
 			if (numbytes < msg->len) {
 				pca_rx_byte(adap, &msg->buf[numbytes], 1);
 				numbytes++;
-				pca_rx_ack(adap, numbytes < msg->len - 1);
+				completed = pca_rx_ack(adap,
+						       numbytes < msg->len - 1);
 				break;
 			}
 			curmsg++; numbytes = 0;
 			if (curmsg == num)
 				pca_stop(adap);
 			else
-				pca_repeated_start(adap);
+				completed = pca_repeated_start(adap);
 			break;
 
 		case 0x48: /* SLA+R has been transmitted; NOT ACK has been received */
@@ -297,7 +300,7 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 				if (curmsg == num)
 					pca_stop(adap);
 				else
-					pca_repeated_start(adap);
+					completed = pca_repeated_start(adap);
 			} else {
 				DEB2("NOT ACK sent after data byte received. "
 				     "Not final byte. numbytes %d. len %d\n",
@@ -323,6 +326,8 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 			break;
 		}
 
+		if (!completed)
+			goto out;
 	}
 
 	ret = curmsg;

commit 8e99ada8deaa9033600cd2c7d0a9366b0e99ab68
Author: Wolfram Sang <w.sang@pengutronix.de>
Date:   Sat Mar 28 21:34:45 2009 +0100

    i2c-algo-pca: Rework waiting for a free bus
    
    Waiting for a free bus now accepts the timeout value in jiffies and does
    proper checking using time_before.
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index a8e51bd1a4f5..9e134fad7bda 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -22,6 +22,7 @@
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/delay.h>
+#include <linux/jiffies.h>
 #include <linux/init.h>
 #include <linux/errno.h>
 #include <linux/i2c.h>
@@ -186,14 +187,16 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 	int numbytes = 0;
 	int state;
 	int ret;
-	int timeout = i2c_adap->timeout;
+	unsigned long timeout = jiffies + i2c_adap->timeout;
 
-	while ((state = pca_status(adap)) != 0xf8 && timeout--) {
-		msleep(10);
-	}
-	if (state != 0xf8) {
-		dev_dbg(&i2c_adap->dev, "bus is not idle. status is %#04x\n", state);
-		return -EAGAIN;
+	while (pca_status(adap) != 0xf8) {
+		if (time_before(jiffies, timeout)) {
+			msleep(10);
+		} else {
+			dev_dbg(&i2c_adap->dev, "bus is not idle. status is "
+				"%#04x\n", state);
+			return -EAGAIN;
+		}
 	}
 
 	DEB1("{{{ XFER %d messages\n", num);

commit eff9ec95efaaf6b12d230f0ea7d3c295d3bc9d57
Author: Marco Aurelio da Costa <costa@gamic.com>
Date:   Sat Mar 28 21:34:44 2009 +0100

    i2c-algo-pca: Add PCA9665 support
    
    Add support for the PCA9665 I2C controller.
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 943d70ee5d59..a8e51bd1a4f5 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -46,6 +46,14 @@ static int i2c_debug;
 #define pca_wait(adap) adap->wait_for_completion(adap->data)
 #define pca_reset(adap) adap->reset_chip(adap->data)
 
+static void pca9665_reset(void *pd)
+{
+	struct i2c_algo_pca_data *adap = pd;
+	pca_outw(adap, I2C_PCA_INDPTR, I2C_PCA_IPRESET);
+	pca_outw(adap, I2C_PCA_IND, 0xA5);
+	pca_outw(adap, I2C_PCA_IND, 0x5A);
+}
+
 /*
  * Generate a start condition on the i2c bus.
  *
@@ -333,27 +341,171 @@ static const struct i2c_algorithm pca_algo = {
 	.functionality	= pca_func,
 };
 
-static int pca_init(struct i2c_adapter *adap)
+static unsigned int pca_probe_chip(struct i2c_adapter *adap)
 {
-	static int freqs[] = {330,288,217,146,88,59,44,36};
-	int clock;
 	struct i2c_algo_pca_data *pca_data = adap->algo_data;
-
-	if (pca_data->i2c_clock > 7) {
-		printk(KERN_WARNING "%s: Invalid I2C clock speed selected. Trying default.\n",
-			adap->name);
-		pca_data->i2c_clock = I2C_PCA_CON_59kHz;
+	/* The trick here is to check if there is an indirect register
+	 * available. If there is one, we will read the value we first
+	 * wrote on I2C_PCA_IADR. Otherwise, we will read the last value
+	 * we wrote on I2C_PCA_ADR
+	 */
+	pca_outw(pca_data, I2C_PCA_INDPTR, I2C_PCA_IADR);
+	pca_outw(pca_data, I2C_PCA_IND, 0xAA);
+	pca_outw(pca_data, I2C_PCA_INDPTR, I2C_PCA_ITO);
+	pca_outw(pca_data, I2C_PCA_IND, 0x00);
+	pca_outw(pca_data, I2C_PCA_INDPTR, I2C_PCA_IADR);
+	if (pca_inw(pca_data, I2C_PCA_IND) == 0xAA) {
+		printk(KERN_INFO "%s: PCA9665 detected.\n", adap->name);
+		return I2C_PCA_CHIP_9665;
+	} else {
+		printk(KERN_INFO "%s: PCA9564 detected.\n", adap->name);
+		return I2C_PCA_CHIP_9564;
 	}
+}
+
+static int pca_init(struct i2c_adapter *adap)
+{
+	struct i2c_algo_pca_data *pca_data = adap->algo_data;
 
 	adap->algo = &pca_algo;
 
-	pca_reset(pca_data);
+	if (pca_probe_chip(adap) == I2C_PCA_CHIP_9564) {
+		static int freqs[] = {330, 288, 217, 146, 88, 59, 44, 36};
+		int clock;
+
+		if (pca_data->i2c_clock > 7) {
+			switch (pca_data->i2c_clock) {
+			case 330000:
+				pca_data->i2c_clock = I2C_PCA_CON_330kHz;
+				break;
+			case 288000:
+				pca_data->i2c_clock = I2C_PCA_CON_288kHz;
+				break;
+			case 217000:
+				pca_data->i2c_clock = I2C_PCA_CON_217kHz;
+				break;
+			case 146000:
+				pca_data->i2c_clock = I2C_PCA_CON_146kHz;
+				break;
+			case 88000:
+				pca_data->i2c_clock = I2C_PCA_CON_88kHz;
+				break;
+			case 59000:
+				pca_data->i2c_clock = I2C_PCA_CON_59kHz;
+				break;
+			case 44000:
+				pca_data->i2c_clock = I2C_PCA_CON_44kHz;
+				break;
+			case 36000:
+				pca_data->i2c_clock = I2C_PCA_CON_36kHz;
+				break;
+			default:
+				printk(KERN_WARNING
+					"%s: Invalid I2C clock speed selected."
+					" Using default 59kHz.\n", adap->name);
+			pca_data->i2c_clock = I2C_PCA_CON_59kHz;
+			}
+		} else {
+			printk(KERN_WARNING "%s: "
+				"Choosing the clock frequency based on "
+				"index is deprecated."
+				" Use the nominal frequency.\n", adap->name);
+		}
+
+		pca_reset(pca_data);
+
+		clock = pca_clock(pca_data);
+		printk(KERN_INFO "%s: Clock frequency is %dkHz\n",
+		     adap->name, freqs[clock]);
+
+		pca_set_con(pca_data, I2C_PCA_CON_ENSIO | clock);
+	} else {
+		int clock;
+		int mode;
+		int tlow, thi;
+		/* Values can be found on PCA9665 datasheet section 7.3.2.6 */
+		int min_tlow, min_thi;
+		/* These values are the maximum raise and fall values allowed
+		 * by the I2C operation mode (Standard, Fast or Fast+)
+		 * They are used (added) below to calculate the clock dividers
+		 * of PCA9665. Note that they are slightly different of the
+		 * real maximum, to allow the change on mode exactly on the
+		 * maximum clock rate for each mode
+		 */
+		int raise_fall_time;
+
+		struct i2c_algo_pca_data *pca_data = adap->algo_data;
+
+		/* Ignore the reset function from the module,
+		 * we can use the parallel bus reset
+		 */
+		pca_data->reset_chip = pca9665_reset;
+
+		if (pca_data->i2c_clock > 1265800) {
+			printk(KERN_WARNING "%s: I2C clock speed too high."
+				" Using 1265.8kHz.\n", adap->name);
+			pca_data->i2c_clock = 1265800;
+		}
+
+		if (pca_data->i2c_clock < 60300) {
+			printk(KERN_WARNING "%s: I2C clock speed too low."
+				" Using 60.3kHz.\n", adap->name);
+			pca_data->i2c_clock = 60300;
+		}
+
+		/* To avoid integer overflow, use clock/100 for calculations */
+		clock = pca_clock(pca_data) / 100;
+
+		if (pca_data->i2c_clock > 10000) {
+			mode = I2C_PCA_MODE_TURBO;
+			min_tlow = 14;
+			min_thi  = 5;
+			raise_fall_time = 22; /* Raise 11e-8s, Fall 11e-8s */
+		} else if (pca_data->i2c_clock > 4000) {
+			mode = I2C_PCA_MODE_FASTP;
+			min_tlow = 17;
+			min_thi  = 9;
+			raise_fall_time = 22; /* Raise 11e-8s, Fall 11e-8s */
+		} else if (pca_data->i2c_clock > 1000) {
+			mode = I2C_PCA_MODE_FAST;
+			min_tlow = 44;
+			min_thi  = 20;
+			raise_fall_time = 58; /* Raise 29e-8s, Fall 29e-8s */
+		} else {
+			mode = I2C_PCA_MODE_STD;
+			min_tlow = 157;
+			min_thi  = 134;
+			raise_fall_time = 127; /* Raise 29e-8s, Fall 98e-8s */
+		}
+
+		/* The minimum clock that respects the thi/tlow = 134/157 is
+		 * 64800 Hz. Below that, we have to fix the tlow to 255 and
+		 * calculate the thi factor.
+		 */
+		if (clock < 648) {
+			tlow = 255;
+			thi = 1000000 - clock * raise_fall_time;
+			thi /= (I2C_PCA_OSC_PER * clock) - tlow;
+		} else {
+			tlow = (1000000 - clock * raise_fall_time) * min_tlow;
+			tlow /= I2C_PCA_OSC_PER * clock * (min_thi + min_tlow);
+			thi = tlow * min_thi / min_tlow;
+		}
+
+		pca_reset(pca_data);
 
-	clock = pca_clock(pca_data);
-	printk(KERN_INFO "%s: Clock frequency is %dkHz\n", adap->name,
-	       freqs[clock]);
+		printk(KERN_INFO
+		     "%s: Clock frequency is %dHz\n", adap->name, clock * 100);
 
-	pca_set_con(pca_data, I2C_PCA_CON_ENSIO | clock);
+		pca_outw(pca_data, I2C_PCA_INDPTR, I2C_PCA_IMODE);
+		pca_outw(pca_data, I2C_PCA_IND, mode);
+		pca_outw(pca_data, I2C_PCA_INDPTR, I2C_PCA_ISCLL);
+		pca_outw(pca_data, I2C_PCA_IND, tlow);
+		pca_outw(pca_data, I2C_PCA_INDPTR, I2C_PCA_ISCLH);
+		pca_outw(pca_data, I2C_PCA_IND, thi);
+
+		pca_set_con(pca_data, I2C_PCA_CON_ENSIO);
+	}
 	udelay(500); /* 500 us for oscilator to stabilise */
 
 	return 0;
@@ -388,7 +540,7 @@ EXPORT_SYMBOL(i2c_pca_add_numbered_bus);
 
 MODULE_AUTHOR("Ian Campbell <icampbell@arcom.com>, "
 	"Wolfram Sang <w.sang@pengutronix.de>");
-MODULE_DESCRIPTION("I2C-Bus PCA9564 algorithm");
+MODULE_DESCRIPTION("I2C-Bus PCA9564/PCA9665 algorithm");
 MODULE_LICENSE("GPL");
 
 module_param(i2c_debug, int, 0);

commit bac3e7c2aa2575a1c71f6fa643499676ca7c12c3
Author: Frank Seidel <frank@f-seidel.de>
Date:   Sat Mar 28 21:34:44 2009 +0100

    i2c: Adapt debug macros for KERN_* constants
    
    According to kerneljanitors todo list all printk calls (beginning
    a new line) should have an according KERN_* constant.
    Those are the changes to the debug macros in the i2c subsystem
    to meet this requirement. Also changing no-debug statements
    to raw printks again.
    
    Signed-off-by: Frank Seidel <frank@f-seidel.de>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index d50b329a3c94..943d70ee5d59 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -27,9 +27,12 @@
 #include <linux/i2c.h>
 #include <linux/i2c-algo-pca.h>
 
-#define DEB1(fmt, args...) do { if (i2c_debug>=1) printk(fmt, ## args); } while(0)
-#define DEB2(fmt, args...) do { if (i2c_debug>=2) printk(fmt, ## args); } while(0)
-#define DEB3(fmt, args...) do { if (i2c_debug>=3) printk(fmt, ## args); } while(0)
+#define DEB1(fmt, args...) do { if (i2c_debug >= 1)			\
+				 printk(KERN_DEBUG fmt, ## args); } while (0)
+#define DEB2(fmt, args...) do { if (i2c_debug >= 2)			\
+				 printk(KERN_DEBUG fmt, ## args); } while (0)
+#define DEB3(fmt, args...) do { if (i2c_debug >= 3)			\
+				 printk(KERN_DEBUG fmt, ## args); } while (0)
 
 static int i2c_debug;
 
@@ -313,7 +316,7 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 
 	ret = curmsg;
  out:
-	DEB1(KERN_CRIT "}}} transfered %d/%d messages. "
+	DEB1("}}} transfered %d/%d messages. "
 	     "status is %#04x. control is %#04x\n",
 	     curmsg, num, pca_status(adap),
 	     pca_get_con(adap));
@@ -347,7 +350,8 @@ static int pca_init(struct i2c_adapter *adap)
 	pca_reset(pca_data);
 
 	clock = pca_clock(pca_data);
-	DEB1(KERN_INFO "%s: Clock frequency is %dkHz\n", adap->name, freqs[clock]);
+	printk(KERN_INFO "%s: Clock frequency is %dkHz\n", adap->name,
+	       freqs[clock]);
 
 	pca_set_con(pca_data, I2C_PCA_CON_ENSIO | clock);
 	udelay(500); /* 500 us for oscilator to stabilise */

commit c80ebe7987931ec4e80abc33ebf8aa2dad0d3763
Author: Wolfram Sang <w.sang@pengutronix.de>
Date:   Mon Jul 14 22:38:26 2008 +0200

    i2c-pca-algo: Fix error code
    
    Give a more concrete error code, when the bus is not idle.
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index e954a20b97a6..d50b329a3c94 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -182,7 +182,7 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 	}
 	if (state != 0xf8) {
 		dev_dbg(&i2c_adap->dev, "bus is not idle. status is %#04x\n", state);
-		return -EIO;
+		return -EAGAIN;
 	}
 
 	DEB1("{{{ XFER %d messages\n", num);

commit c01b0831057381c7f6e0bfb3634bac8c5f7fb256
Author: Wolfram Sang <w.sang@pengutronix.de>
Date:   Tue Apr 22 22:16:46 2008 +0200

    i2c-algo-pca: Extend for future drivers
    
    The separation between algorithm and adapter was unsharp at places. This was
    partly hidden by the fact, that the ISA-driver allowed just one instance and
    had all private data in static variables. This patch makes neccessary
    preparations to add a platform driver on top of the algorithm, while still
    supporting ISA. Note: Due to lack of hardware, the ISA-driver could not be
    tested except that it builds.
    
    Concerning the core struct i2c_algo_pca_data:
    
    - A private data field was added, all hardware dependant data may go here.
      Similar to other algorithms, now a pointer to this data is passed to the
      adapter's functions. In order to make as less changes as possible to the
      ISA-driver, it leaves the private data empty and still only uses its static
      variables.
    
    - A "reset_chip" function pointer was added; such a functionality must come
      from the adapter, not the algorithm.
    
    - use a variable "i2c_clock" instead of a function pointer "get_clock",
      allowing for write access to a default in case a wrong value was supplied.
    
    In the algorithm-file:
    
    - move "i2c-pca-algo.h" into "linux/i2c-algo-pca.h"
    - now using per_instance timeout values (i2c_adap->timeout)
    - error messages specify the device, not only the driver name
    - restructure initialization to easily support "i2c_add_numbered_adapter"
    - drop "retries" and "own" (i2c address) as they were unused
    
    (The state-machine for I2C-communication was not touched.)
    
    In the ISA-driver:
    
    - adapt to new algorithm
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index ebec91d71e1e..e954a20b97a6 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -1,6 +1,7 @@
 /*
  *  i2c-algo-pca.c i2c driver algorithms for PCA9564 adapters
  *    Copyright (C) 2004 Arcom Control Systems
+ *    Copyright (C) 2008 Pengutronix
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -21,14 +22,10 @@
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/delay.h>
-#include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/errno.h>
 #include <linux/i2c.h>
 #include <linux/i2c-algo-pca.h>
-#include "i2c-algo-pca.h"
-
-#define DRIVER "i2c-algo-pca"
 
 #define DEB1(fmt, args...) do { if (i2c_debug>=1) printk(fmt, ## args); } while(0)
 #define DEB2(fmt, args...) do { if (i2c_debug>=2) printk(fmt, ## args); } while(0)
@@ -36,15 +33,15 @@
 
 static int i2c_debug;
 
-#define pca_outw(adap, reg, val) adap->write_byte(adap, reg, val)
-#define pca_inw(adap, reg) adap->read_byte(adap, reg)
+#define pca_outw(adap, reg, val) adap->write_byte(adap->data, reg, val)
+#define pca_inw(adap, reg) adap->read_byte(adap->data, reg)
 
 #define pca_status(adap) pca_inw(adap, I2C_PCA_STA)
-#define pca_clock(adap) adap->get_clock(adap)
-#define pca_own(adap) adap->get_own(adap)
+#define pca_clock(adap) adap->i2c_clock
 #define pca_set_con(adap, val) pca_outw(adap, I2C_PCA_CON, val)
 #define pca_get_con(adap) pca_inw(adap, I2C_PCA_CON)
-#define pca_wait(adap) adap->wait_for_interrupt(adap)
+#define pca_wait(adap) adap->wait_for_completion(adap->data)
+#define pca_reset(adap) adap->reset_chip(adap->data)
 
 /*
  * Generate a start condition on the i2c bus.
@@ -168,15 +165,6 @@ static void pca_rx_ack(struct i2c_algo_pca_data *adap,
 	pca_wait(adap);
 }
 
-/*
- * Reset the i2c bus / SIO
- */
-static void pca_reset(struct i2c_algo_pca_data *adap)
-{
-	/* apparently only an external reset will do it. not a lot can be done */
-	printk(KERN_ERR DRIVER ": Haven't figured out how to do a reset yet\n");
-}
-
 static int pca_xfer(struct i2c_adapter *i2c_adap,
                     struct i2c_msg *msgs,
                     int num)
@@ -187,7 +175,7 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 	int numbytes = 0;
 	int state;
 	int ret;
-	int timeout = 100;
+	int timeout = i2c_adap->timeout;
 
 	while ((state = pca_status(adap)) != 0xf8 && timeout--) {
 		msleep(10);
@@ -317,7 +305,7 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 			pca_reset(adap);
 			goto out;
 		default:
-			printk(KERN_ERR DRIVER ": unhandled SIO state 0x%02x\n", state);
+			dev_err(&i2c_adap->dev, "unhandled SIO state 0x%02x\n", state);
 			break;
 		}
 
@@ -337,53 +325,65 @@ static u32 pca_func(struct i2c_adapter *adap)
         return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
 }
 
-static int pca_init(struct i2c_algo_pca_data *adap)
+static const struct i2c_algorithm pca_algo = {
+	.master_xfer	= pca_xfer,
+	.functionality	= pca_func,
+};
+
+static int pca_init(struct i2c_adapter *adap)
 {
 	static int freqs[] = {330,288,217,146,88,59,44,36};
-	int own, clock;
+	int clock;
+	struct i2c_algo_pca_data *pca_data = adap->algo_data;
+
+	if (pca_data->i2c_clock > 7) {
+		printk(KERN_WARNING "%s: Invalid I2C clock speed selected. Trying default.\n",
+			adap->name);
+		pca_data->i2c_clock = I2C_PCA_CON_59kHz;
+	}
+
+	adap->algo = &pca_algo;
 
-	own = pca_own(adap);
-	clock = pca_clock(adap);
-	DEB1(KERN_INFO DRIVER ": own address is %#04x\n", own);
-	DEB1(KERN_INFO DRIVER ": clock freqeuncy is %dkHz\n", freqs[clock]);
+	pca_reset(pca_data);
 
-	pca_outw(adap, I2C_PCA_ADR, own << 1);
+	clock = pca_clock(pca_data);
+	DEB1(KERN_INFO "%s: Clock frequency is %dkHz\n", adap->name, freqs[clock]);
 
-	pca_set_con(adap, I2C_PCA_CON_ENSIO | clock);
+	pca_set_con(pca_data, I2C_PCA_CON_ENSIO | clock);
 	udelay(500); /* 500 us for oscilator to stabilise */
 
 	return 0;
 }
 
-static const struct i2c_algorithm pca_algo = {
-	.master_xfer	= pca_xfer,
-	.functionality	= pca_func,
-};
-
 /*
  * registering functions to load algorithms at runtime
  */
 int i2c_pca_add_bus(struct i2c_adapter *adap)
 {
-	struct i2c_algo_pca_data *pca_adap = adap->algo_data;
 	int rval;
 
-	/* register new adapter to i2c module... */
-	adap->algo = &pca_algo;
+	rval = pca_init(adap);
+	if (rval)
+		return rval;
 
-	adap->timeout = 100;		/* default values, should	*/
-	adap->retries = 3;		/* be replaced by defines	*/
+	return i2c_add_adapter(adap);
+}
+EXPORT_SYMBOL(i2c_pca_add_bus);
 
-	if ((rval = pca_init(pca_adap)))
-		return rval;
+int i2c_pca_add_numbered_bus(struct i2c_adapter *adap)
+{
+	int rval;
 
-	rval = i2c_add_adapter(adap);
+	rval = pca_init(adap);
+	if (rval)
+		return rval;
 
-	return rval;
+	return i2c_add_numbered_adapter(adap);
 }
-EXPORT_SYMBOL(i2c_pca_add_bus);
+EXPORT_SYMBOL(i2c_pca_add_numbered_bus);
 
-MODULE_AUTHOR("Ian Campbell <icampbell@arcom.com>");
+MODULE_AUTHOR("Ian Campbell <icampbell@arcom.com>, "
+	"Wolfram Sang <w.sang@pengutronix.de>");
 MODULE_DESCRIPTION("I2C-Bus PCA9564 algorithm");
 MODULE_LICENSE("GPL");
 

commit 3d4382913f9a86f0d9ff47740feb427415fe7234
Author: Wolfram Sang <w.sang@pengutronix.de>
Date:   Tue Apr 22 22:16:46 2008 +0200

    i2c-algo-pca: Remove trailing whitespaces and unnecessary UTF
    
    Remove trailing whitespaces to make further patches more readable.  Also remove
    an unnecessary UTF-char for simplicity ("us" for microseconds is fine enough).
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 2a16211f12e5..ebec91d71e1e 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -1,5 +1,5 @@
 /*
- *  i2c-algo-pca.c i2c driver algorithms for PCA9564 adapters                
+ *  i2c-algo-pca.c i2c driver algorithms for PCA9564 adapters
  *    Copyright (C) 2004 Arcom Control Systems
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -99,7 +99,7 @@ static void pca_stop(struct i2c_algo_pca_data *adap)
  *
  * returns after the address has been sent
  */
-static void pca_address(struct i2c_algo_pca_data *adap, 
+static void pca_address(struct i2c_algo_pca_data *adap,
 			struct i2c_msg *msg)
 {
 	int sta = pca_get_con(adap);
@@ -108,9 +108,9 @@ static void pca_address(struct i2c_algo_pca_data *adap,
 	addr = ( (0x7f & msg->addr) << 1 );
 	if (msg->flags & I2C_M_RD )
 		addr |= 1;
-	DEB2("=== SLAVE ADDRESS %#04x+%c=%#04x\n", 
+	DEB2("=== SLAVE ADDRESS %#04x+%c=%#04x\n",
 	     msg->addr, msg->flags & I2C_M_RD ? 'R' : 'W', addr);
-	
+
 	pca_outw(adap, I2C_PCA_DAT, addr);
 
 	sta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_STA|I2C_PCA_CON_SI);
@@ -124,7 +124,7 @@ static void pca_address(struct i2c_algo_pca_data *adap,
  *
  * Returns after the byte has been transmitted
  */
-static void pca_tx_byte(struct i2c_algo_pca_data *adap, 
+static void pca_tx_byte(struct i2c_algo_pca_data *adap,
 			__u8 b)
 {
 	int sta = pca_get_con(adap);
@@ -142,19 +142,19 @@ static void pca_tx_byte(struct i2c_algo_pca_data *adap,
  *
  * returns immediately.
  */
-static void pca_rx_byte(struct i2c_algo_pca_data *adap, 
+static void pca_rx_byte(struct i2c_algo_pca_data *adap,
 			__u8 *b, int ack)
 {
 	*b = pca_inw(adap, I2C_PCA_DAT);
 	DEB2("=== READ %#04x %s\n", *b, ack ? "ACK" : "NACK");
 }
 
-/* 
+/*
  * Setup ACK or NACK for next received byte and wait for it to arrive.
  *
  * Returns after next byte has arrived.
  */
-static void pca_rx_ack(struct i2c_algo_pca_data *adap, 
+static void pca_rx_ack(struct i2c_algo_pca_data *adap,
 		       int ack)
 {
 	int sta = pca_get_con(adap);
@@ -168,8 +168,8 @@ static void pca_rx_ack(struct i2c_algo_pca_data *adap,
 	pca_wait(adap);
 }
 
-/* 
- * Reset the i2c bus / SIO 
+/*
+ * Reset the i2c bus / SIO
  */
 static void pca_reset(struct i2c_algo_pca_data *adap)
 {
@@ -203,14 +203,14 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 		for (curmsg = 0; curmsg < num; curmsg++) {
 			int addr, i;
 			msg = &msgs[curmsg];
-			
+
 			addr = (0x7f & msg->addr) ;
-		
+
 			if (msg->flags & I2C_M_RD )
-				printk(KERN_INFO "    [%02d] RD %d bytes from %#02x [%#02x, ...]\n", 
+				printk(KERN_INFO "    [%02d] RD %d bytes from %#02x [%#02x, ...]\n",
 				       curmsg, msg->len, addr, (addr<<1) | 1);
 			else {
-				printk(KERN_INFO "    [%02d] WR %d bytes to %#02x [%#02x%s", 
+				printk(KERN_INFO "    [%02d] WR %d bytes to %#02x [%#02x%s",
 				       curmsg, msg->len, addr, addr<<1,
 				       msg->len == 0 ? "" : ", ");
 				for(i=0; i < msg->len; i++)
@@ -237,7 +237,7 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 		case 0x10: /* A repeated start condition has been transmitted */
 			pca_address(adap, msg);
 			break;
-			
+
 		case 0x18: /* SLA+W has been transmitted; ACK has been received */
 		case 0x28: /* Data byte in I2CDAT has been transmitted; ACK has been received */
 			if (numbytes < msg->len) {
@@ -287,7 +287,7 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 		case 0x38: /* Arbitration lost during SLA+W, SLA+R or data bytes */
 			DEB2("Arbitration lost\n");
 			goto out;
-			
+
 		case 0x58: /* Data byte has been received; NOT ACK has been returned */
 			if ( numbytes == msg->len - 1 ) {
 				pca_rx_byte(adap, &msg->buf[numbytes], 0);
@@ -320,13 +320,13 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 			printk(KERN_ERR DRIVER ": unhandled SIO state 0x%02x\n", state);
 			break;
 		}
-		
+
 	}
 
 	ret = curmsg;
  out:
 	DEB1(KERN_CRIT "}}} transfered %d/%d messages. "
-	     "status is %#04x. control is %#04x\n", 
+	     "status is %#04x. control is %#04x\n",
 	     curmsg, num, pca_status(adap),
 	     pca_get_con(adap));
 	return ret;
@@ -350,7 +350,7 @@ static int pca_init(struct i2c_algo_pca_data *adap)
 	pca_outw(adap, I2C_PCA_ADR, own << 1);
 
 	pca_set_con(adap, I2C_PCA_CON_ENSIO | clock);
-	udelay(500); /* 500 s for oscilator to stabilise */
+	udelay(500); /* 500 us for oscilator to stabilise */
 
 	return 0;
 }
@@ -360,8 +360,8 @@ static const struct i2c_algorithm pca_algo = {
 	.functionality	= pca_func,
 };
 
-/* 
- * registering functions to load algorithms at runtime 
+/*
+ * registering functions to load algorithms at runtime
  */
 int i2c_pca_add_bus(struct i2c_adapter *adap)
 {

commit 96de0e252cedffad61b3cb5e05662c591898e69a
Author: Jan Engelhardt <jengelh@gmx.de>
Date:   Fri Oct 19 23:21:04 2007 +0200

    Convert files to UTF-8 and some cleanups
    
    * Convert files to UTF-8.
    
      * Also correct some people's names
        (one example is Eifeldt, which was found in a source file.
        Given that the author used an  at all in a source file
        indicates that the real name has in fact a '' and not an 'ss',
        which is commonly used as a substitute for '' when limited to
        7bit.)
    
      * Correct town names (Goettingen -> Gttingen)
    
      * Update Eberhard Mnkeberg's address (http://lkml.org/lkml/2007/1/8/313)
    
    Signed-off-by: Jan Engelhardt <jengelh@gmx.de>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 36fdf971f080..2a16211f12e5 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -350,7 +350,7 @@ static int pca_init(struct i2c_algo_pca_data *adap)
 	pca_outw(adap, I2C_PCA_ADR, own << 1);
 
 	pca_set_con(adap, I2C_PCA_CON_ENSIO | clock);
-	udelay(500); /* 500 s for oscilator to stabilise */
+	udelay(500); /* 500 s for oscilator to stabilise */
 
 	return 0;
 }

commit 3269711b76ba27b78862c48398b0d313ccaa99c2
Author: Jean Delvare <khali@linux-fr.org>
Date:   Sun Dec 10 21:21:33 2006 +0100

    i2c: Discard the i2c algo del_bus wrappers
    
    They are all only calling i2c_del_adapter, so we may as well do
    it directly.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 9081c9fbcd29..36fdf971f080 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -381,14 +381,7 @@ int i2c_pca_add_bus(struct i2c_adapter *adap)
 
 	return rval;
 }
-
-int i2c_pca_del_bus(struct i2c_adapter *adap)
-{
-	return i2c_del_adapter(adap);
-}
-
 EXPORT_SYMBOL(i2c_pca_add_bus);
-EXPORT_SYMBOL(i2c_pca_del_bus);
 
 MODULE_AUTHOR("Ian Campbell <icampbell@arcom.com>");
 MODULE_DESCRIPTION("I2C-Bus PCA9564 algorithm");

commit 9e11a9fbfe48a2f65188aae64bf4f690e40ea2f4
Author: Jean Delvare <khali@linux-fr.org>
Date:   Sun Sep 3 22:38:52 2006 +0200

    i2c: Constify i2c_algorithm declarations, part 1
    
    i2c: Constify i2c_algorithm declarations, part 1
    
    Make struct i2c_algorithm declarations const in all i2c algorithm
    drivers.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index b88a6fcf7bd0..9081c9fbcd29 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -355,7 +355,7 @@ static int pca_init(struct i2c_algo_pca_data *adap)
 	return 0;
 }
 
-static struct i2c_algorithm pca_algo = {
+static const struct i2c_algorithm pca_algo = {
 	.master_xfer	= pca_xfer,
 	.functionality	= pca_func,
 };

commit b39ad0cf7c19fc14e8f823b1b36245f7a3711655
Author: Mark M. Hoffman <mhoffman@lightlink.com>
Date:   Sat Jul 1 17:16:06 2006 +0200

    [PATCH] i2c: Handle i2c_add_adapter failure in i2c algorithm drivers
    
    Content-Disposition: inline; filename=i2c-algo-error-handling-fix.patch
    
    It is possible for i2c_add_adapter() to fail.  Several I2C algorithm
    drivers ignore that fact.  This (compile-tested only) patch fixes them.
    
    Signed-off-by: Mark M. Hoffman <mhoffman@lightlink.com>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 82946acab4c7..b88a6fcf7bd0 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -374,10 +374,10 @@ int i2c_pca_add_bus(struct i2c_adapter *adap)
 	adap->timeout = 100;		/* default values, should	*/
 	adap->retries = 3;		/* be replaced by defines	*/
 
-	rval = pca_init(pca_adap);
+	if ((rval = pca_init(pca_adap)))
+		return rval;
 
-	if (!rval)
-		i2c_add_adapter(adap);
+	rval = i2c_add_adapter(adap);
 
 	return rval;
 }

commit 605070952f0b41caaa211c47b02eeac703529008
Author: Jean Delvare <khali@linux-fr.org>
Date:   Sun Sep 25 16:23:07 2005 +0200

    [PATCH] i2c: Discard explicit static initializations to 0
    
    Kill explicit static initializations to 0 in 10 i2c drivers.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    
     drivers/i2c/algos/i2c-algo-pca.c    |    2 +-
     drivers/i2c/algos/i2c-algo-sibyte.c |    2 +-
     drivers/i2c/busses/i2c-ali15x3.c    |    4 ++--
     drivers/i2c/busses/i2c-amd756.c     |    2 +-
     drivers/i2c/busses/i2c-iop3xx.c     |    2 +-
     drivers/i2c/busses/i2c-piix4.c      |    8 ++++----
     drivers/i2c/busses/i2c-sis5595.c    |    4 ++--
     drivers/i2c/busses/i2c-sis630.c     |    2 +-
     drivers/i2c/busses/i2c-sis96x.c     |    2 +-
     drivers/i2c/busses/i2c-via.c        |    2 +-
     10 files changed, 15 insertions(+), 15 deletions(-)

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index beb10edfe9c1..82946acab4c7 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -34,7 +34,7 @@
 #define DEB2(fmt, args...) do { if (i2c_debug>=2) printk(fmt, ## args); } while(0)
 #define DEB3(fmt, args...) do { if (i2c_debug>=3) printk(fmt, ## args); } while(0)
 
-static int i2c_debug=0;
+static int i2c_debug;
 
 #define pca_outw(adap, reg, val) adap->write_byte(adap, reg, val)
 #define pca_inw(adap, reg) adap->read_byte(adap, reg)

commit c7a46533ff7ef9e1c51bae6e54208527c5275b24
Author: Jean Delvare <khali@linux-fr.org>
Date:   Thu Aug 11 23:41:56 2005 +0200

    [PATCH] I2C: Kill i2c_algorithm.id (5/7)
    
    Merge the algorithm id part (16 upper bits) of the i2c adapters ids
    into the definition of the adapters ids directly. After that, we don't
    need to OR both ids together for each i2c_adapter structure.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index be2c8abc6682..beb10edfe9c1 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -369,8 +369,6 @@ int i2c_pca_add_bus(struct i2c_adapter *adap)
 	int rval;
 
 	/* register new adapter to i2c module... */
-
-	adap->id |= I2C_ALGO_PCA;
 	adap->algo = &pca_algo;
 
 	adap->timeout = 100;		/* default values, should	*/

commit 1d8b9e1bad35fa3ea829990b9056c2a257d8fe79
Author: Jean Delvare <khali@linux-fr.org>
Date:   Thu Aug 11 23:40:19 2005 +0200

    [PATCH] I2C: Kill i2c_algorithm.id (4/7)
    
    There are no more users of i2c_algorithm.id, so we can finally drop
    this structure member.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 79b3c2edcf08..be2c8abc6682 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -356,7 +356,6 @@ static int pca_init(struct i2c_algo_pca_data *adap)
 }
 
 static struct i2c_algorithm pca_algo = {
-	.id		= I2C_ALGO_PCA,
 	.master_xfer	= pca_xfer,
 	.functionality	= pca_func,
 };

commit 87c3d7a8bc0ff5c8d4481e509b407b6be1859925
Author: Jean Delvare <khali@linux-fr.org>
Date:   Thu Aug 11 23:38:52 2005 +0200

    [PATCH] I2C: Kill i2c_algorithm.id (3/7)
    
    Don't rely on i2c_algorithm.id to alter the i2c adapter's id, use the
    I2C_ALGO_* value directly instead, because i2c_algorithm will soon
    have no id member no more.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index 16157391cdf5..79b3c2edcf08 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -371,7 +371,7 @@ int i2c_pca_add_bus(struct i2c_adapter *adap)
 
 	/* register new adapter to i2c module... */
 
-	adap->id |= pca_algo.id;
+	adap->id |= I2C_ALGO_PCA;
 	adap->algo = &pca_algo;
 
 	adap->timeout = 100;		/* default values, should	*/

commit 975185880d55676b1352047e82a0cb84173c6c28
Author: Jean Delvare <khali@linux-fr.org>
Date:   Thu Aug 11 23:33:24 2005 +0200

    [PATCH] I2C: Kill i2c_algorithm.name (1/7)
    
    The name member of the i2c_algorithm is never used, although all
    drivers conscientiously fill it. We can drop it completely, this
    structure doesn't need to have a name.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index ff2db0da4417..16157391cdf5 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -356,7 +356,6 @@ static int pca_init(struct i2c_algo_pca_data *adap)
 }
 
 static struct i2c_algorithm pca_algo = {
-	.name		= "PCA9564 algorithm",
 	.id		= I2C_ALGO_PCA,
 	.master_xfer	= pca_xfer,
 	.functionality	= pca_func,

commit 48edcb65ddcd93b6421831ad133599aacea9724a
Author: Ian Campbell <icampbell@arcom.com>
Date:   Wed Aug 10 08:51:16 2005 +0100

    [PATCH] I2C: i2c-algo-pca -- gracefully handle a busy bus
    
    I've been running with this patch for a while now, and while I've never
    seen it trigger except with buggy hardware I think it is a cleaner way
    to handle a busy bus. I had -EBUSY until about 10 minutes ago but -EIO
    seems to be what most of the existing algo drivers will return in the
    same circumstances.
    
    Signed-off-by: Ian Campbell <icampbell@arcom.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index cc3a952401f2..ff2db0da4417 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -187,12 +187,14 @@ static int pca_xfer(struct i2c_adapter *i2c_adap,
 	int numbytes = 0;
 	int state;
 	int ret;
+	int timeout = 100;
 
-	state = pca_status(adap);
-	if ( state != 0xF8 ) {
-		dev_dbg(&i2c_adap->dev, "bus is not idle. status is %#04x\n", state );
-		/* FIXME: what to do. Force stop ? */
-		return -EREMOTEIO;
+	while ((state = pca_status(adap)) != 0xf8 && timeout--) {
+		msleep(10);
+	}
+	if (state != 0xf8) {
+		dev_dbg(&i2c_adap->dev, "bus is not idle. status is %#04x\n", state);
+		return -EIO;
 	}
 
 	DEB1("{{{ XFER %d messages\n", num);

commit 46b615f453202dbcf66452b500ab69c0e2148593
Author: Tobias Klauser <tklauser@nuerscht.ch>
Date:   Thu May 19 22:27:23 2005 +0200

    [PATCH] I2C: Spelling fixes for drivers/i2c/algos/i2c-algo-pca.c
    
    This patch fixes the some misspellings and a trailing whitespace in
    the comments.
    
    Signed-off-by: Tobias Klauser <tklauser@nuerscht.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index dfa77eb275b1..cc3a952401f2 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -62,7 +62,7 @@ static void pca_start(struct i2c_algo_pca_data *adap)
 }
 
 /*
- * Generate a repeated start condition on the i2c bus 
+ * Generate a repeated start condition on the i2c bus
  *
  * return after the repeated start condition has occurred
  */
@@ -82,7 +82,7 @@ static void pca_repeated_start(struct i2c_algo_pca_data *adap)
  * returns after the stop condition has been generated
  *
  * STOPs do not generate an interrupt or set the SI flag, since the
- * part returns the the idle state (0xf8). Hence we don't need to
+ * part returns the idle state (0xf8). Hence we don't need to
  * pca_wait here.
  */
 static void pca_stop(struct i2c_algo_pca_data *adap)

commit 44bbe87e9017efa050bb1b506c6822f1f3bb94d7
Author: Steven Cole <elenstev@mesatop.com>
Date:   Tue May 3 18:21:25 2005 -0600

    [PATCH] Spelling fixes for drivers/i2c.
    
     Here are some spelling corrections for drivers/i2c.
    
     occured -> occurred
     intialization -> initialization
     Everytime -> Every time
     transfering -> transferring
     relevent -> relevant
     continous -> continuous
     neccessary -> necessary
     explicitely -> explicitly
     Celcius -> Celsius
     differenciate -> differentiate
    
    Signed-off-by: Steven Cole <elenstev@mesatop.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
index c3d912cbbbc3..dfa77eb275b1 100644
--- a/drivers/i2c/algos/i2c-algo-pca.c
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -49,7 +49,7 @@ static int i2c_debug=0;
 /*
  * Generate a start condition on the i2c bus.
  *
- * returns after the start condition has occured
+ * returns after the start condition has occurred
  */
 static void pca_start(struct i2c_algo_pca_data *adap)
 {
@@ -64,7 +64,7 @@ static void pca_start(struct i2c_algo_pca_data *adap)
 /*
  * Generate a repeated start condition on the i2c bus 
  *
- * return after the repeated start condition has occured
+ * return after the repeated start condition has occurred
  */
 static void pca_repeated_start(struct i2c_algo_pca_data *adap)
 {

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/i2c/algos/i2c-algo-pca.c b/drivers/i2c/algos/i2c-algo-pca.c
new file mode 100644
index 000000000000..c3d912cbbbc3
--- /dev/null
+++ b/drivers/i2c/algos/i2c-algo-pca.c
@@ -0,0 +1,399 @@
+/*
+ *  i2c-algo-pca.c i2c driver algorithms for PCA9564 adapters                
+ *    Copyright (C) 2004 Arcom Control Systems
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-pca.h>
+#include "i2c-algo-pca.h"
+
+#define DRIVER "i2c-algo-pca"
+
+#define DEB1(fmt, args...) do { if (i2c_debug>=1) printk(fmt, ## args); } while(0)
+#define DEB2(fmt, args...) do { if (i2c_debug>=2) printk(fmt, ## args); } while(0)
+#define DEB3(fmt, args...) do { if (i2c_debug>=3) printk(fmt, ## args); } while(0)
+
+static int i2c_debug=0;
+
+#define pca_outw(adap, reg, val) adap->write_byte(adap, reg, val)
+#define pca_inw(adap, reg) adap->read_byte(adap, reg)
+
+#define pca_status(adap) pca_inw(adap, I2C_PCA_STA)
+#define pca_clock(adap) adap->get_clock(adap)
+#define pca_own(adap) adap->get_own(adap)
+#define pca_set_con(adap, val) pca_outw(adap, I2C_PCA_CON, val)
+#define pca_get_con(adap) pca_inw(adap, I2C_PCA_CON)
+#define pca_wait(adap) adap->wait_for_interrupt(adap)
+
+/*
+ * Generate a start condition on the i2c bus.
+ *
+ * returns after the start condition has occured
+ */
+static void pca_start(struct i2c_algo_pca_data *adap)
+{
+	int sta = pca_get_con(adap);
+	DEB2("=== START\n");
+	sta |= I2C_PCA_CON_STA;
+	sta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_SI);
+	pca_set_con(adap, sta);
+	pca_wait(adap);
+}
+
+/*
+ * Generate a repeated start condition on the i2c bus 
+ *
+ * return after the repeated start condition has occured
+ */
+static void pca_repeated_start(struct i2c_algo_pca_data *adap)
+{
+	int sta = pca_get_con(adap);
+	DEB2("=== REPEATED START\n");
+	sta |= I2C_PCA_CON_STA;
+	sta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_SI);
+	pca_set_con(adap, sta);
+	pca_wait(adap);
+}
+
+/*
+ * Generate a stop condition on the i2c bus
+ *
+ * returns after the stop condition has been generated
+ *
+ * STOPs do not generate an interrupt or set the SI flag, since the
+ * part returns the the idle state (0xf8). Hence we don't need to
+ * pca_wait here.
+ */
+static void pca_stop(struct i2c_algo_pca_data *adap)
+{
+	int sta = pca_get_con(adap);
+	DEB2("=== STOP\n");
+	sta |= I2C_PCA_CON_STO;
+	sta &= ~(I2C_PCA_CON_STA|I2C_PCA_CON_SI);
+	pca_set_con(adap, sta);
+}
+
+/*
+ * Send the slave address and R/W bit
+ *
+ * returns after the address has been sent
+ */
+static void pca_address(struct i2c_algo_pca_data *adap, 
+			struct i2c_msg *msg)
+{
+	int sta = pca_get_con(adap);
+	int addr;
+
+	addr = ( (0x7f & msg->addr) << 1 );
+	if (msg->flags & I2C_M_RD )
+		addr |= 1;
+	DEB2("=== SLAVE ADDRESS %#04x+%c=%#04x\n", 
+	     msg->addr, msg->flags & I2C_M_RD ? 'R' : 'W', addr);
+	
+	pca_outw(adap, I2C_PCA_DAT, addr);
+
+	sta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_STA|I2C_PCA_CON_SI);
+	pca_set_con(adap, sta);
+
+	pca_wait(adap);
+}
+
+/*
+ * Transmit a byte.
+ *
+ * Returns after the byte has been transmitted
+ */
+static void pca_tx_byte(struct i2c_algo_pca_data *adap, 
+			__u8 b)
+{
+	int sta = pca_get_con(adap);
+	DEB2("=== WRITE %#04x\n", b);
+	pca_outw(adap, I2C_PCA_DAT, b);
+
+	sta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_STA|I2C_PCA_CON_SI);
+	pca_set_con(adap, sta);
+
+	pca_wait(adap);
+}
+
+/*
+ * Receive a byte
+ *
+ * returns immediately.
+ */
+static void pca_rx_byte(struct i2c_algo_pca_data *adap, 
+			__u8 *b, int ack)
+{
+	*b = pca_inw(adap, I2C_PCA_DAT);
+	DEB2("=== READ %#04x %s\n", *b, ack ? "ACK" : "NACK");
+}
+
+/* 
+ * Setup ACK or NACK for next received byte and wait for it to arrive.
+ *
+ * Returns after next byte has arrived.
+ */
+static void pca_rx_ack(struct i2c_algo_pca_data *adap, 
+		       int ack)
+{
+	int sta = pca_get_con(adap);
+
+	sta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_STA|I2C_PCA_CON_SI|I2C_PCA_CON_AA);
+
+	if ( ack )
+		sta |= I2C_PCA_CON_AA;
+
+	pca_set_con(adap, sta);
+	pca_wait(adap);
+}
+
+/* 
+ * Reset the i2c bus / SIO 
+ */
+static void pca_reset(struct i2c_algo_pca_data *adap)
+{
+	/* apparently only an external reset will do it. not a lot can be done */
+	printk(KERN_ERR DRIVER ": Haven't figured out how to do a reset yet\n");
+}
+
+static int pca_xfer(struct i2c_adapter *i2c_adap,
+                    struct i2c_msg *msgs,
+                    int num)
+{
+        struct i2c_algo_pca_data *adap = i2c_adap->algo_data;
+        struct i2c_msg *msg = NULL;
+        int curmsg;
+	int numbytes = 0;
+	int state;
+	int ret;
+
+	state = pca_status(adap);
+	if ( state != 0xF8 ) {
+		dev_dbg(&i2c_adap->dev, "bus is not idle. status is %#04x\n", state );
+		/* FIXME: what to do. Force stop ? */
+		return -EREMOTEIO;
+	}
+
+	DEB1("{{{ XFER %d messages\n", num);
+
+	if (i2c_debug>=2) {
+		for (curmsg = 0; curmsg < num; curmsg++) {
+			int addr, i;
+			msg = &msgs[curmsg];
+			
+			addr = (0x7f & msg->addr) ;
+		
+			if (msg->flags & I2C_M_RD )
+				printk(KERN_INFO "    [%02d] RD %d bytes from %#02x [%#02x, ...]\n", 
+				       curmsg, msg->len, addr, (addr<<1) | 1);
+			else {
+				printk(KERN_INFO "    [%02d] WR %d bytes to %#02x [%#02x%s", 
+				       curmsg, msg->len, addr, addr<<1,
+				       msg->len == 0 ? "" : ", ");
+				for(i=0; i < msg->len; i++)
+					printk("%#04x%s", msg->buf[i], i == msg->len - 1 ? "" : ", ");
+				printk("]\n");
+			}
+		}
+	}
+
+	curmsg = 0;
+	ret = -EREMOTEIO;
+	while (curmsg < num) {
+		state = pca_status(adap);
+
+		DEB3("STATE is 0x%02x\n", state);
+		msg = &msgs[curmsg];
+
+		switch (state) {
+		case 0xf8: /* On reset or stop the bus is idle */
+			pca_start(adap);
+			break;
+
+		case 0x08: /* A START condition has been transmitted */
+		case 0x10: /* A repeated start condition has been transmitted */
+			pca_address(adap, msg);
+			break;
+			
+		case 0x18: /* SLA+W has been transmitted; ACK has been received */
+		case 0x28: /* Data byte in I2CDAT has been transmitted; ACK has been received */
+			if (numbytes < msg->len) {
+				pca_tx_byte(adap, msg->buf[numbytes]);
+				numbytes++;
+				break;
+			}
+			curmsg++; numbytes = 0;
+			if (curmsg == num)
+				pca_stop(adap);
+			else
+				pca_repeated_start(adap);
+			break;
+
+		case 0x20: /* SLA+W has been transmitted; NOT ACK has been received */
+			DEB2("NOT ACK received after SLA+W\n");
+			pca_stop(adap);
+			goto out;
+
+		case 0x40: /* SLA+R has been transmitted; ACK has been received */
+			pca_rx_ack(adap, msg->len > 1);
+			break;
+
+		case 0x50: /* Data bytes has been received; ACK has been returned */
+			if (numbytes < msg->len) {
+				pca_rx_byte(adap, &msg->buf[numbytes], 1);
+				numbytes++;
+				pca_rx_ack(adap, numbytes < msg->len - 1);
+				break;
+			}
+			curmsg++; numbytes = 0;
+			if (curmsg == num)
+				pca_stop(adap);
+			else
+				pca_repeated_start(adap);
+			break;
+
+		case 0x48: /* SLA+R has been transmitted; NOT ACK has been received */
+			DEB2("NOT ACK received after SLA+R\n");
+			pca_stop(adap);
+			goto out;
+
+		case 0x30: /* Data byte in I2CDAT has been transmitted; NOT ACK has been received */
+			DEB2("NOT ACK received after data byte\n");
+			goto out;
+
+		case 0x38: /* Arbitration lost during SLA+W, SLA+R or data bytes */
+			DEB2("Arbitration lost\n");
+			goto out;
+			
+		case 0x58: /* Data byte has been received; NOT ACK has been returned */
+			if ( numbytes == msg->len - 1 ) {
+				pca_rx_byte(adap, &msg->buf[numbytes], 0);
+				curmsg++; numbytes = 0;
+				if (curmsg == num)
+					pca_stop(adap);
+				else
+					pca_repeated_start(adap);
+			} else {
+				DEB2("NOT ACK sent after data byte received. "
+				     "Not final byte. numbytes %d. len %d\n",
+				     numbytes, msg->len);
+				pca_stop(adap);
+				goto out;
+			}
+			break;
+		case 0x70: /* Bus error - SDA stuck low */
+			DEB2("BUS ERROR - SDA Stuck low\n");
+			pca_reset(adap);
+			goto out;
+		case 0x90: /* Bus error - SCL stuck low */
+			DEB2("BUS ERROR - SCL Stuck low\n");
+			pca_reset(adap);
+			goto out;
+		case 0x00: /* Bus error during master or slave mode due to illegal START or STOP condition */
+			DEB2("BUS ERROR - Illegal START or STOP\n");
+			pca_reset(adap);
+			goto out;
+		default:
+			printk(KERN_ERR DRIVER ": unhandled SIO state 0x%02x\n", state);
+			break;
+		}
+		
+	}
+
+	ret = curmsg;
+ out:
+	DEB1(KERN_CRIT "}}} transfered %d/%d messages. "
+	     "status is %#04x. control is %#04x\n", 
+	     curmsg, num, pca_status(adap),
+	     pca_get_con(adap));
+	return ret;
+}
+
+static u32 pca_func(struct i2c_adapter *adap)
+{
+        return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+static int pca_init(struct i2c_algo_pca_data *adap)
+{
+	static int freqs[] = {330,288,217,146,88,59,44,36};
+	int own, clock;
+
+	own = pca_own(adap);
+	clock = pca_clock(adap);
+	DEB1(KERN_INFO DRIVER ": own address is %#04x\n", own);
+	DEB1(KERN_INFO DRIVER ": clock freqeuncy is %dkHz\n", freqs[clock]);
+
+	pca_outw(adap, I2C_PCA_ADR, own << 1);
+
+	pca_set_con(adap, I2C_PCA_CON_ENSIO | clock);
+	udelay(500); /* 500 s for oscilator to stabilise */
+
+	return 0;
+}
+
+static struct i2c_algorithm pca_algo = {
+	.name		= "PCA9564 algorithm",
+	.id		= I2C_ALGO_PCA,
+	.master_xfer	= pca_xfer,
+	.functionality	= pca_func,
+};
+
+/* 
+ * registering functions to load algorithms at runtime 
+ */
+int i2c_pca_add_bus(struct i2c_adapter *adap)
+{
+	struct i2c_algo_pca_data *pca_adap = adap->algo_data;
+	int rval;
+
+	/* register new adapter to i2c module... */
+
+	adap->id |= pca_algo.id;
+	adap->algo = &pca_algo;
+
+	adap->timeout = 100;		/* default values, should	*/
+	adap->retries = 3;		/* be replaced by defines	*/
+
+	rval = pca_init(pca_adap);
+
+	if (!rval)
+		i2c_add_adapter(adap);
+
+	return rval;
+}
+
+int i2c_pca_del_bus(struct i2c_adapter *adap)
+{
+	return i2c_del_adapter(adap);
+}
+
+EXPORT_SYMBOL(i2c_pca_add_bus);
+EXPORT_SYMBOL(i2c_pca_del_bus);
+
+MODULE_AUTHOR("Ian Campbell <icampbell@arcom.com>");
+MODULE_DESCRIPTION("I2C-Bus PCA9564 algorithm");
+MODULE_LICENSE("GPL");
+
+module_param(i2c_debug, int, 0);
