commit e42688ed5cf5936fb55c78cc365dbe0944af7c63
Author: Dejin Zheng <zhengdejin5@gmail.com>
Date:   Thu Apr 16 23:23:45 2020 +0800

    i2c: busses: remove duplicate dev_err()
    
    it will print an error message by itself when platform_get_irq()
    goes wrong. so don't need dev_err() in here again.
    
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Suggested-by: Markus Elfring <Markus.Elfring@web.de>
    Signed-off-by: Dejin Zheng <zhengdejin5@gmail.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index 2b258d54d68c..cb4666c54a23 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -529,10 +529,8 @@ static int uniphier_fi2c_probe(struct platform_device *pdev)
 		return PTR_ERR(priv->membase);
 
 	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		dev_err(dev, "failed to get IRQ number\n");
+	if (irq < 0)
 		return irq;
-	}
 
 	if (of_property_read_u32(dev->of_node, "clock-frequency", &bus_speed))
 		bus_speed = I2C_MAX_STANDARD_MODE_FREQ;

commit 90224e6468e15d5eb22a10ae1849cf8ca2e7360a
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Mar 24 14:32:16 2020 +0200

    i2c: drivers: Use generic definitions for bus frequencies
    
    Since we have generic definitions for bus frequencies, let's use them.
    
    Reviewed-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Acked-by: Robert Richter <rrichter@marvell.com>
    Reviewed-by: Thor Thayer <thor.thayer@linux.intel.com>
    Acked-by: Elie Morisse <syniurge@gmail.com>
    Acked-by: Nehal Shah <nehal-bakulchandra.shah@amd.com>
    Reviewed-by: Brendan Higgins <brendanhiggins@google.com>
    Acked-by: Scott Branden <scott.branden@broadcom.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Baruch Siach <baruch@tkos.co.il>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Oleksij Rempel <o.rempel@pengutronix.de>
    Acked-by: Vladimir Zapolskiy <vz@mleia.com>
    Acked-by: Gregory CLEMENT <gregory.clement@bootlin.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
    Reviewed-by: Chris Brandt <chris.brandt@renesas.com>
    Reviewed-by: Baolin Wang <baolin.wang7@gmail.com>
    Reviewed-by: Pierre-Yves MORDRET <pierre-yves.mordret@st.com>
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    Acked-by: Ard Biesheuvel <ardb@kernel.org>
    Reviewed-by: Dmitry Osipenko <digetx@gmail.com>
    Acked-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index 4241aac79e7e..2b258d54d68c 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -73,8 +73,6 @@
 #define UNIPHIER_FI2C_BYTE_WISE		BIT(3)
 #define UNIPHIER_FI2C_DEFER_STOP_COMP	BIT(4)
 
-#define UNIPHIER_FI2C_DEFAULT_SPEED	100000
-#define UNIPHIER_FI2C_MAX_SPEED		400000
 #define UNIPHIER_FI2C_FIFO_SIZE		8
 
 struct uniphier_fi2c_priv {
@@ -537,9 +535,9 @@ static int uniphier_fi2c_probe(struct platform_device *pdev)
 	}
 
 	if (of_property_read_u32(dev->of_node, "clock-frequency", &bus_speed))
-		bus_speed = UNIPHIER_FI2C_DEFAULT_SPEED;
+		bus_speed = I2C_MAX_STANDARD_MODE_FREQ;
 
-	if (!bus_speed || bus_speed > UNIPHIER_FI2C_MAX_SPEED) {
+	if (!bus_speed || bus_speed > I2C_MAX_FAST_MODE_FREQ) {
 		dev_err(dev, "invalid clock-frequency %d\n", bus_speed);
 		return -EINVAL;
 	}

commit 9ee7e72fbbb835ba92b2cbf4349997adf065eab0
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Sep 5 13:46:48 2019 +0900

    i2c: uniphier(-f): remove all dev_dbg()
    
    I have fixed various bugs, and these drivers are (I hope) pretty
    stable now. Remove all dev_dbg() for code clean-up.
    
    If I end up with debugging the drivers again, I will locally revert
    this commit. I no longer need the debug code in upstream.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index fc5354845ffa..4241aac79e7e 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -108,7 +108,6 @@ static void uniphier_fi2c_fill_txfifo(struct uniphier_fi2c_priv *priv,
 		if (fifo_space-- <= 0)
 			break;
 
-		dev_dbg(&priv->adap.dev, "write data: %02x\n", *priv->buf);
 		writel(*priv->buf++, priv->membase + UNIPHIER_FI2C_DTTX);
 		priv->len--;
 	}
@@ -124,7 +123,6 @@ static void uniphier_fi2c_drain_rxfifo(struct uniphier_fi2c_priv *priv)
 			break;
 
 		*priv->buf++ = readl(priv->membase + UNIPHIER_FI2C_DTRX);
-		dev_dbg(&priv->adap.dev, "read data: %02x\n", priv->buf[-1]);
 		priv->len--;
 	}
 }
@@ -142,8 +140,6 @@ static void uniphier_fi2c_clear_irqs(struct uniphier_fi2c_priv *priv,
 
 static void uniphier_fi2c_stop(struct uniphier_fi2c_priv *priv)
 {
-	dev_dbg(&priv->adap.dev, "stop condition\n");
-
 	priv->enabled_irqs |= UNIPHIER_FI2C_INT_STOP;
 	uniphier_fi2c_set_irqs(priv);
 	writel(UNIPHIER_FI2C_CR_MST | UNIPHIER_FI2C_CR_STO,
@@ -160,21 +156,15 @@ static irqreturn_t uniphier_fi2c_interrupt(int irq, void *dev_id)
 	irq_status = readl(priv->membase + UNIPHIER_FI2C_INT);
 	irq_status &= priv->enabled_irqs;
 
-	dev_dbg(&priv->adap.dev,
-		"interrupt: enabled_irqs=%04x, irq_status=%04x\n",
-		priv->enabled_irqs, irq_status);
-
 	if (irq_status & UNIPHIER_FI2C_INT_STOP)
 		goto complete;
 
 	if (unlikely(irq_status & UNIPHIER_FI2C_INT_AL)) {
-		dev_dbg(&priv->adap.dev, "arbitration lost\n");
 		priv->error = -EAGAIN;
 		goto complete;
 	}
 
 	if (unlikely(irq_status & UNIPHIER_FI2C_INT_NA)) {
-		dev_dbg(&priv->adap.dev, "could not get ACK\n");
 		priv->error = -ENXIO;
 		if (priv->flags & UNIPHIER_FI2C_RD) {
 			/*
@@ -215,18 +205,14 @@ static irqreturn_t uniphier_fi2c_interrupt(int irq, void *dev_id)
 		if (unlikely(priv->flags & UNIPHIER_FI2C_MANUAL_NACK)) {
 			if (priv->len <= UNIPHIER_FI2C_FIFO_SIZE &&
 			    !(priv->flags & UNIPHIER_FI2C_BYTE_WISE)) {
-				dev_dbg(&priv->adap.dev,
-					"enable read byte count IRQ\n");
 				priv->enabled_irqs |= UNIPHIER_FI2C_INT_RB;
 				uniphier_fi2c_set_irqs(priv);
 				priv->flags |= UNIPHIER_FI2C_BYTE_WISE;
 			}
-			if (priv->len <= 1) {
-				dev_dbg(&priv->adap.dev, "set NACK\n");
+			if (priv->len <= 1)
 				writel(UNIPHIER_FI2C_CR_MST |
 				       UNIPHIER_FI2C_CR_NACK,
 				       priv->membase + UNIPHIER_FI2C_CR);
-			}
 		}
 
 		goto handled;
@@ -334,10 +320,6 @@ static int uniphier_fi2c_master_xfer_one(struct i2c_adapter *adap,
 	bool is_read = msg->flags & I2C_M_RD;
 	unsigned long time_left, flags;
 
-	dev_dbg(&adap->dev, "%s: addr=0x%02x, len=%d, repeat=%d, stop=%d\n",
-		is_read ? "receive" : "transmit", msg->addr, msg->len,
-		repeat, stop);
-
 	priv->len = msg->len;
 	priv->buf = msg->buf;
 	priv->enabled_irqs = UNIPHIER_FI2C_INT_FAULTS;
@@ -359,7 +341,6 @@ static int uniphier_fi2c_master_xfer_one(struct i2c_adapter *adap,
 	else
 		uniphier_fi2c_tx_init(priv, msg->addr, repeat);
 
-	dev_dbg(&adap->dev, "start condition\n");
 	/*
 	 * For a repeated START condition, writing a slave address to the FIFO
 	 * kicks the controller. So, the UNIPHIER_FI2C_CR register should be
@@ -383,7 +364,6 @@ static int uniphier_fi2c_master_xfer_one(struct i2c_adapter *adap,
 		uniphier_fi2c_recover(priv);
 		return -ETIMEDOUT;
 	}
-	dev_dbg(&adap->dev, "complete\n");
 
 	if (unlikely(priv->flags & UNIPHIER_FI2C_DEFER_STOP_COMP)) {
 		u32 status;

commit 22ac74a6194798ce131c55ff0dfbb9697650e626
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Sep 5 12:45:32 2019 +0900

    i2c: uniphier(-f): use devm_platform_ioremap_resource()
    
    Replace the chain of platform_get_resource() and devm_ioremap_resource()
    with devm_platform_ioremap_resource().
    
    This allows to remove the local variable for (struct resource *), and
    have one function call less.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index 7acca2599f04..fc5354845ffa 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -538,7 +538,6 @@ static int uniphier_fi2c_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct uniphier_fi2c_priv *priv;
-	struct resource *regs;
 	u32 bus_speed;
 	unsigned long clk_rate;
 	int irq, ret;
@@ -547,8 +546,7 @@ static int uniphier_fi2c_probe(struct platform_device *pdev)
 	if (!priv)
 		return -ENOMEM;
 
-	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	priv->membase = devm_ioremap_resource(dev, regs);
+	priv->membase = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(priv->membase))
 		return PTR_ERR(priv->membase);
 

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index 03da4a539a2f..7acca2599f04 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -1,15 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (C) 2015 Masahiro Yamada <yamada.masahiro@socionext.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include <linux/clk.h>

commit ece27a337d42a3197935711997f2880f0957ed7e
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Dec 6 12:55:28 2018 +0900

    i2c: uniphier-f: fix violation of tLOW requirement for Fast-mode
    
    Currently, the clock duty is set as tLOW/tHIGH = 1/1. For Fast-mode,
    tLOW is set to 1.25 us while the I2C spec requires tLOW >= 1.3 us.
    
    tLOW/tHIGH = 5/4 would meet both Standard-mode and Fast-mode:
      Standard-mode: tLOW = 5.56 us, tHIGH = 4.44 us
      Fast-mode:     tLOW = 1.39 us, tHIGH = 1.11 us
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index d8a5db14da79..03da4a539a2f 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -518,9 +518,26 @@ static void uniphier_fi2c_hw_init(struct uniphier_fi2c_priv *priv)
 
 	uniphier_fi2c_reset(priv);
 
+	/*
+	 *  Standard-mode: tLOW + tHIGH = 10 us
+	 *  Fast-mode:     tLOW + tHIGH = 2.5 us
+	 */
 	writel(cyc, priv->membase + UNIPHIER_FI2C_CYC);
-	writel(cyc / 2, priv->membase + UNIPHIER_FI2C_LCTL);
+	/*
+	 *  Standard-mode: tLOW = 4.7 us, tHIGH = 4.0 us, tBUF = 4.7 us
+	 *  Fast-mode:     tLOW = 1.3 us, tHIGH = 0.6 us, tBUF = 1.3 us
+	 * "tLow/tHIGH = 5/4" meets both.
+	 */
+	writel(cyc * 5 / 9, priv->membase + UNIPHIER_FI2C_LCTL);
+	/*
+	 *  Standard-mode: tHD;STA = 4.0 us, tSU;STA = 4.7 us, tSU;STO = 4.0 us
+	 *  Fast-mode:     tHD;STA = 0.6 us, tSU;STA = 0.6 us, tSU;STO = 0.6 us
+	 */
 	writel(cyc / 2, priv->membase + UNIPHIER_FI2C_SSUT);
+	/*
+	 *  Standard-mode: tSU;DAT = 250 ns
+	 *  Fast-mode:     tSU;DAT = 100 ns
+	 */
 	writel(cyc / 16, priv->membase + UNIPHIER_FI2C_DSUT);
 
 	uniphier_fi2c_prepare_operation(priv);

commit cd8843f541cc0ef057e27f1afba46374bbb84219
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Dec 6 12:55:26 2018 +0900

    i2c: uniphier-f: fill TX-FIFO only in IRQ handler for repeated START
    
    - For a repeated START condition, this controller starts data transfer
       immediately after the slave address is written to the TX-FIFO.
    
     - Once the TX-FIFO empty interrupt is asserted, the controller makes
       a pause even if additional data are written to the TX-FIFO.
    
    Given those circumstances, the data after a repeated START may not be
    transferred if the interrupt is asserted while the TX-FIFO is being
    filled up. A more reliable way is to append TX data only in the
    interrupt handler.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index fad2b00a8c8c..d8a5db14da79 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -269,7 +269,8 @@ static irqreturn_t uniphier_fi2c_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static void uniphier_fi2c_tx_init(struct uniphier_fi2c_priv *priv, u16 addr)
+static void uniphier_fi2c_tx_init(struct uniphier_fi2c_priv *priv, u16 addr,
+				  bool repeat)
 {
 	priv->enabled_irqs |= UNIPHIER_FI2C_INT_TE;
 	uniphier_fi2c_set_irqs(priv);
@@ -279,8 +280,12 @@ static void uniphier_fi2c_tx_init(struct uniphier_fi2c_priv *priv, u16 addr)
 	/* set slave address */
 	writel(UNIPHIER_FI2C_DTTX_CMD | addr << 1,
 	       priv->membase + UNIPHIER_FI2C_DTTX);
-	/* first chunk of data */
-	uniphier_fi2c_fill_txfifo(priv, true);
+	/*
+	 * First chunk of data. For a repeated START condition, do not write
+	 * data to the TX fifo here to avoid the timing issue.
+	 */
+	if (!repeat)
+		uniphier_fi2c_fill_txfifo(priv, true);
 }
 
 static void uniphier_fi2c_rx_init(struct uniphier_fi2c_priv *priv, u16 addr)
@@ -361,7 +366,7 @@ static int uniphier_fi2c_master_xfer_one(struct i2c_adapter *adap,
 	if (is_read)
 		uniphier_fi2c_rx_init(priv, msg->addr);
 	else
-		uniphier_fi2c_tx_init(priv, msg->addr);
+		uniphier_fi2c_tx_init(priv, msg->addr, repeat);
 
 	dev_dbg(&adap->dev, "start condition\n");
 	/*

commit c2a653deaa81f5a750c0dfcbaf9f8e5195cbe4a5
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Dec 6 12:55:25 2018 +0900

    i2c: uniphier-f: fix timeout error after reading 8 bytes
    
    I was totally screwed up in commit eaba68785c2d ("i2c: uniphier-f:
    fix race condition when IRQ is cleared"). Since that commit, if the
    number of read bytes is multiple of the FIFO size (8, 16, 24... bytes),
    the STOP condition could be issued twice, depending on the timing.
    If this happens, the controller will go wrong, resulting in the timeout
    error.
    
    It was more than 3 years ago when I wrote this driver, so my memory
    about this hardware was vague. Please let me correct the description
    in the commit log of eaba68785c2d.
    
    Clearing the IRQ status on exiting the IRQ handler is absolutely
    fine. This controller makes a pause while any IRQ status is asserted.
    If the IRQ status is cleared first, the hardware may start the next
    transaction before the IRQ handler finishes what it supposed to do.
    
    This partially reverts the bad commit with clear comments so that I
    will never repeat this mistake.
    
    I also investigated what is happening at the last moment of the read
    mode. The UNIPHIER_FI2C_INT_RF interrupt is asserted a bit earlier
    (by half a period of the clock cycle) than UNIPHIER_FI2C_INT_RB.
    
    I consulted a hardware engineer, and I got the following information:
    
    UNIPHIER_FI2C_INT_RF
        asserted at the falling edge of SCL at the 8th bit.
    
    UNIPHIER_FI2C_INT_RB
        asserted at the rising edge of SCL at the 9th (ACK) bit.
    
    In order to avoid calling uniphier_fi2c_stop() twice, check the latter
    interrupt. I also commented this because it is obscure hardware internal.
    
    Fixes: eaba68785c2d ("i2c: uniphier-f: fix race condition when IRQ is cleared")
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index dd384743dbbd..fad2b00a8c8c 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -173,8 +173,6 @@ static irqreturn_t uniphier_fi2c_interrupt(int irq, void *dev_id)
 		"interrupt: enabled_irqs=%04x, irq_status=%04x\n",
 		priv->enabled_irqs, irq_status);
 
-	uniphier_fi2c_clear_irqs(priv, irq_status);
-
 	if (irq_status & UNIPHIER_FI2C_INT_STOP)
 		goto complete;
 
@@ -214,7 +212,13 @@ static irqreturn_t uniphier_fi2c_interrupt(int irq, void *dev_id)
 
 	if (irq_status & (UNIPHIER_FI2C_INT_RF | UNIPHIER_FI2C_INT_RB)) {
 		uniphier_fi2c_drain_rxfifo(priv);
-		if (!priv->len)
+		/*
+		 * If the number of bytes to read is multiple of the FIFO size
+		 * (msg->len == 8, 16, 24, ...), the INT_RF bit is set a little
+		 * earlier than INT_RB. We wait for INT_RB to confirm the
+		 * completion of the current message.
+		 */
+		if (!priv->len && (irq_status & UNIPHIER_FI2C_INT_RB))
 			goto data_done;
 
 		if (unlikely(priv->flags & UNIPHIER_FI2C_MANUAL_NACK)) {
@@ -253,6 +257,13 @@ static irqreturn_t uniphier_fi2c_interrupt(int irq, void *dev_id)
 	}
 
 handled:
+	/*
+	 * This controller makes a pause while any bit of the IRQ status is
+	 * asserted. Clear the asserted bit to kick the controller just before
+	 * exiting the handler.
+	 */
+	uniphier_fi2c_clear_irqs(priv, irq_status);
+
 	spin_unlock(&priv->lock);
 
 	return IRQ_HANDLED;

commit eaba68785c2d24ebf1f0d46c24e11b79cc2f94c7
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Oct 16 12:01:49 2018 +0900

    i2c: uniphier-f: fix race condition when IRQ is cleared
    
    The current IRQ handler clears all the IRQ status bits when it bails
    out. This is dangerous because it might clear away the status bits
    that have just been set while processing the current handler. If this
    happens, the IRQ event for the latest transfer is lost forever.
    
    The IRQ status bits must be cleared *before* the next transfer is
    kicked.
    
    Fixes: 6a62974b667f ("i2c: uniphier_f: add UniPhier FIFO-builtin I2C driver")
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index 067715305976..dd384743dbbd 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -143,9 +143,10 @@ static void uniphier_fi2c_set_irqs(struct uniphier_fi2c_priv *priv)
 	writel(priv->enabled_irqs, priv->membase + UNIPHIER_FI2C_IE);
 }
 
-static void uniphier_fi2c_clear_irqs(struct uniphier_fi2c_priv *priv)
+static void uniphier_fi2c_clear_irqs(struct uniphier_fi2c_priv *priv,
+				     u32 mask)
 {
-	writel(-1, priv->membase + UNIPHIER_FI2C_IC);
+	writel(mask, priv->membase + UNIPHIER_FI2C_IC);
 }
 
 static void uniphier_fi2c_stop(struct uniphier_fi2c_priv *priv)
@@ -172,6 +173,8 @@ static irqreturn_t uniphier_fi2c_interrupt(int irq, void *dev_id)
 		"interrupt: enabled_irqs=%04x, irq_status=%04x\n",
 		priv->enabled_irqs, irq_status);
 
+	uniphier_fi2c_clear_irqs(priv, irq_status);
+
 	if (irq_status & UNIPHIER_FI2C_INT_STOP)
 		goto complete;
 
@@ -250,8 +253,6 @@ static irqreturn_t uniphier_fi2c_interrupt(int irq, void *dev_id)
 	}
 
 handled:
-	uniphier_fi2c_clear_irqs(priv);
-
 	spin_unlock(&priv->lock);
 
 	return IRQ_HANDLED;
@@ -340,7 +341,7 @@ static int uniphier_fi2c_master_xfer_one(struct i2c_adapter *adap,
 		priv->flags |= UNIPHIER_FI2C_STOP;
 
 	reinit_completion(&priv->comp);
-	uniphier_fi2c_clear_irqs(priv);
+	uniphier_fi2c_clear_irqs(priv, U32_MAX);
 	writel(UNIPHIER_FI2C_RST_TBRST | UNIPHIER_FI2C_RST_RBRST,
 	       priv->membase + UNIPHIER_FI2C_RST);	/* reset TX/RX FIFO */
 

commit 39226aaa85f002d695e3cafade3309e12ffdaecd
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Oct 16 12:01:48 2018 +0900

    i2c: uniphier-f: fix occasional timeout error
    
    Currently, a timeout error could happen at a repeated START condition.
    
    For a (non-repeated) START condition, the controller starts sending
    data when the UNIPHIER_FI2C_CR_STA bit is set. However, for a repeated
    START condition, the hardware starts running when the slave address is
    written to the TX FIFO - the write to the UNIPHIER_FI2C_CR register is
    actually unneeded.
    
    Because the hardware is already running before the IRQ is enabled for
    a repeated START, the driver may miss the IRQ event. In most cases,
    this problem does not show up since modern CPUs are much faster than
    the I2C transfer. However, it is still possible that a context switch
    happens after the controller starts, but before the IRQ register is
    set up.
    
    To fix this,
    
     - Do not write UNIPHIER_FI2C_CR for repeated START conditions.
    
     - Enable IRQ *before* writing the slave address to the TX FIFO.
    
     - Disable IRQ for the current CPU while queuing up the TX FIFO;
       If the CPU is interrupted by some task, the interrupt handler
       might be invoked due to the empty TX FIFO before completing the
       setup.
    
    Fixes: 6a62974b667f ("i2c: uniphier_f: add UniPhier FIFO-builtin I2C driver")
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index 200dfd1771af..067715305976 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -260,6 +260,8 @@ static irqreturn_t uniphier_fi2c_interrupt(int irq, void *dev_id)
 static void uniphier_fi2c_tx_init(struct uniphier_fi2c_priv *priv, u16 addr)
 {
 	priv->enabled_irqs |= UNIPHIER_FI2C_INT_TE;
+	uniphier_fi2c_set_irqs(priv);
+
 	/* do not use TX byte counter */
 	writel(0, priv->membase + UNIPHIER_FI2C_TBC);
 	/* set slave address */
@@ -292,6 +294,8 @@ static void uniphier_fi2c_rx_init(struct uniphier_fi2c_priv *priv, u16 addr)
 		priv->enabled_irqs |= UNIPHIER_FI2C_INT_RF;
 	}
 
+	uniphier_fi2c_set_irqs(priv);
+
 	/* set slave address with RD bit */
 	writel(UNIPHIER_FI2C_DTTX_CMD | UNIPHIER_FI2C_DTTX_RD | addr << 1,
 	       priv->membase + UNIPHIER_FI2C_DTTX);
@@ -315,14 +319,16 @@ static void uniphier_fi2c_recover(struct uniphier_fi2c_priv *priv)
 }
 
 static int uniphier_fi2c_master_xfer_one(struct i2c_adapter *adap,
-					 struct i2c_msg *msg, bool stop)
+					 struct i2c_msg *msg, bool repeat,
+					 bool stop)
 {
 	struct uniphier_fi2c_priv *priv = i2c_get_adapdata(adap);
 	bool is_read = msg->flags & I2C_M_RD;
 	unsigned long time_left, flags;
 
-	dev_dbg(&adap->dev, "%s: addr=0x%02x, len=%d, stop=%d\n",
-		is_read ? "receive" : "transmit", msg->addr, msg->len, stop);
+	dev_dbg(&adap->dev, "%s: addr=0x%02x, len=%d, repeat=%d, stop=%d\n",
+		is_read ? "receive" : "transmit", msg->addr, msg->len,
+		repeat, stop);
 
 	priv->len = msg->len;
 	priv->buf = msg->buf;
@@ -338,16 +344,24 @@ static int uniphier_fi2c_master_xfer_one(struct i2c_adapter *adap,
 	writel(UNIPHIER_FI2C_RST_TBRST | UNIPHIER_FI2C_RST_RBRST,
 	       priv->membase + UNIPHIER_FI2C_RST);	/* reset TX/RX FIFO */
 
+	spin_lock_irqsave(&priv->lock, flags);
+
 	if (is_read)
 		uniphier_fi2c_rx_init(priv, msg->addr);
 	else
 		uniphier_fi2c_tx_init(priv, msg->addr);
 
-	uniphier_fi2c_set_irqs(priv);
-
 	dev_dbg(&adap->dev, "start condition\n");
-	writel(UNIPHIER_FI2C_CR_MST | UNIPHIER_FI2C_CR_STA,
-	       priv->membase + UNIPHIER_FI2C_CR);
+	/*
+	 * For a repeated START condition, writing a slave address to the FIFO
+	 * kicks the controller. So, the UNIPHIER_FI2C_CR register should be
+	 * written only for a non-repeated START condition.
+	 */
+	if (!repeat)
+		writel(UNIPHIER_FI2C_CR_MST | UNIPHIER_FI2C_CR_STA,
+		       priv->membase + UNIPHIER_FI2C_CR);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
 
 	time_left = wait_for_completion_timeout(&priv->comp, adap->timeout);
 
@@ -408,6 +422,7 @@ static int uniphier_fi2c_master_xfer(struct i2c_adapter *adap,
 				     struct i2c_msg *msgs, int num)
 {
 	struct i2c_msg *msg, *emsg = msgs + num;
+	bool repeat = false;
 	int ret;
 
 	ret = uniphier_fi2c_check_bus_busy(adap);
@@ -418,9 +433,11 @@ static int uniphier_fi2c_master_xfer(struct i2c_adapter *adap,
 		/* Emit STOP if it is the last message or I2C_M_STOP is set. */
 		bool stop = (msg + 1 == emsg) || (msg->flags & I2C_M_STOP);
 
-		ret = uniphier_fi2c_master_xfer_one(adap, msg, stop);
+		ret = uniphier_fi2c_master_xfer_one(adap, msg, repeat, stop);
 		if (ret)
 			return ret;
+
+		repeat = !stop;
 	}
 
 	return num;

commit f1fdcbbdf45d9609f3d4063b67e9ea941ba3a58f
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Oct 16 12:01:47 2018 +0900

    i2c: uniphier-f: make driver robust against concurrency
    
    This is unlikely to happen, but it is possible for a CPU to enter
    the interrupt handler just after wait_for_completion_timeout() has
    expired. If this happens, the hardware is accessed from multiple
    contexts concurrently.
    
    Disable the IRQ after wait_for_completion_timeout(), and do nothing
    from the handler when the IRQ is disabled.
    
    Fixes: 6a62974b667f ("i2c: uniphier_f: add UniPhier FIFO-builtin I2C driver")
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index a403e8579b65..200dfd1771af 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -98,6 +98,7 @@ struct uniphier_fi2c_priv {
 	unsigned int flags;
 	unsigned int busy_cnt;
 	unsigned int clk_cycle;
+	spinlock_t lock;	/* IRQ synchronization */
 };
 
 static void uniphier_fi2c_fill_txfifo(struct uniphier_fi2c_priv *priv,
@@ -162,7 +163,10 @@ static irqreturn_t uniphier_fi2c_interrupt(int irq, void *dev_id)
 	struct uniphier_fi2c_priv *priv = dev_id;
 	u32 irq_status;
 
+	spin_lock(&priv->lock);
+
 	irq_status = readl(priv->membase + UNIPHIER_FI2C_INT);
+	irq_status &= priv->enabled_irqs;
 
 	dev_dbg(&priv->adap.dev,
 		"interrupt: enabled_irqs=%04x, irq_status=%04x\n",
@@ -230,6 +234,8 @@ static irqreturn_t uniphier_fi2c_interrupt(int irq, void *dev_id)
 		goto handled;
 	}
 
+	spin_unlock(&priv->lock);
+
 	return IRQ_NONE;
 
 data_done:
@@ -246,6 +252,8 @@ static irqreturn_t uniphier_fi2c_interrupt(int irq, void *dev_id)
 handled:
 	uniphier_fi2c_clear_irqs(priv);
 
+	spin_unlock(&priv->lock);
+
 	return IRQ_HANDLED;
 }
 
@@ -311,7 +319,7 @@ static int uniphier_fi2c_master_xfer_one(struct i2c_adapter *adap,
 {
 	struct uniphier_fi2c_priv *priv = i2c_get_adapdata(adap);
 	bool is_read = msg->flags & I2C_M_RD;
-	unsigned long time_left;
+	unsigned long time_left, flags;
 
 	dev_dbg(&adap->dev, "%s: addr=0x%02x, len=%d, stop=%d\n",
 		is_read ? "receive" : "transmit", msg->addr, msg->len, stop);
@@ -342,6 +350,12 @@ static int uniphier_fi2c_master_xfer_one(struct i2c_adapter *adap,
 	       priv->membase + UNIPHIER_FI2C_CR);
 
 	time_left = wait_for_completion_timeout(&priv->comp, adap->timeout);
+
+	spin_lock_irqsave(&priv->lock, flags);
+	priv->enabled_irqs = 0;
+	uniphier_fi2c_set_irqs(priv);
+	spin_unlock_irqrestore(&priv->lock, flags);
+
 	if (!time_left) {
 		dev_err(&adap->dev, "transaction timeout.\n");
 		uniphier_fi2c_recover(priv);
@@ -529,6 +543,7 @@ static int uniphier_fi2c_probe(struct platform_device *pdev)
 
 	priv->clk_cycle = clk_rate / bus_speed;
 	init_completion(&priv->comp);
+	spin_lock_init(&priv->lock);
 	priv->adap.owner = THIS_MODULE;
 	priv->adap.algo = &uniphier_fi2c_algo;
 	priv->adap.dev.parent = dev;

commit 4c85609b08c4761eca0a40fd7beb06bc650f252d
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Aug 31 23:30:48 2018 +0900

    i2c: uniphier-f: issue STOP only for last message or I2C_M_STOP
    
    This driver currently emits a STOP if the next message is not
    I2C_MD_RD.  It should not do it because it disturbs the I2C_RDWR
    ioctl, where read/write transactions are combined without STOP
    between.
    
    Issue STOP only when the message is the last one _or_ flagged with
    I2C_M_STOP.
    
    Fixes: 6a62974b667f ("i2c: uniphier_f: add UniPhier FIFO-builtin I2C driver")
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index 9918bdd81619..a403e8579b65 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -401,11 +401,8 @@ static int uniphier_fi2c_master_xfer(struct i2c_adapter *adap,
 		return ret;
 
 	for (msg = msgs; msg < emsg; msg++) {
-		/* If next message is read, skip the stop condition */
-		bool stop = !(msg + 1 < emsg && msg[1].flags & I2C_M_RD);
-		/* but, force it if I2C_M_STOP is set */
-		if (msg->flags & I2C_M_STOP)
-			stop = true;
+		/* Emit STOP if it is the last message or I2C_M_STOP is set. */
+		bool stop = (msg + 1 == emsg) || (msg->flags & I2C_M_STOP);
 
 		ret = uniphier_fi2c_master_xfer_one(adap, msg, stop);
 		if (ret)

commit 822c8d45a170312e368271c3c8f43d49cac863a2
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Jul 31 14:53:07 2017 +0900

    i2c: uniphier-f: add suspend / resume support
    
    When resuming, set up registers that have been lost in the sleep state.
    Also, add clock handling in the resume / suspend hooks.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index beee31892295..9918bdd81619 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -97,6 +97,7 @@ struct uniphier_fi2c_priv {
 	int error;
 	unsigned int flags;
 	unsigned int busy_cnt;
+	unsigned int clk_cycle;
 };
 
 static void uniphier_fi2c_fill_txfifo(struct uniphier_fi2c_priv *priv,
@@ -461,9 +462,9 @@ static struct i2c_bus_recovery_info uniphier_fi2c_bus_recovery_info = {
 	.unprepare_recovery = uniphier_fi2c_unprepare_recovery,
 };
 
-static void uniphier_fi2c_hw_init(struct uniphier_fi2c_priv *priv,
-				  u32 bus_speed, unsigned long clk_rate)
+static void uniphier_fi2c_hw_init(struct uniphier_fi2c_priv *priv)
 {
+	unsigned int cyc = priv->clk_cycle;
 	u32 tmp;
 
 	tmp = readl(priv->membase + UNIPHIER_FI2C_CR);
@@ -472,12 +473,10 @@ static void uniphier_fi2c_hw_init(struct uniphier_fi2c_priv *priv,
 
 	uniphier_fi2c_reset(priv);
 
-	tmp = clk_rate / bus_speed;
-
-	writel(tmp, priv->membase + UNIPHIER_FI2C_CYC);
-	writel(tmp / 2, priv->membase + UNIPHIER_FI2C_LCTL);
-	writel(tmp / 2, priv->membase + UNIPHIER_FI2C_SSUT);
-	writel(tmp / 16, priv->membase + UNIPHIER_FI2C_DSUT);
+	writel(cyc, priv->membase + UNIPHIER_FI2C_CYC);
+	writel(cyc / 2, priv->membase + UNIPHIER_FI2C_LCTL);
+	writel(cyc / 2, priv->membase + UNIPHIER_FI2C_SSUT);
+	writel(cyc / 16, priv->membase + UNIPHIER_FI2C_DSUT);
 
 	uniphier_fi2c_prepare_operation(priv);
 }
@@ -531,6 +530,7 @@ static int uniphier_fi2c_probe(struct platform_device *pdev)
 		goto disable_clk;
 	}
 
+	priv->clk_cycle = clk_rate / bus_speed;
 	init_completion(&priv->comp);
 	priv->adap.owner = THIS_MODULE;
 	priv->adap.algo = &uniphier_fi2c_algo;
@@ -541,7 +541,7 @@ static int uniphier_fi2c_probe(struct platform_device *pdev)
 	i2c_set_adapdata(&priv->adap, priv);
 	platform_set_drvdata(pdev, priv);
 
-	uniphier_fi2c_hw_init(priv, bus_speed, clk_rate);
+	uniphier_fi2c_hw_init(priv);
 
 	ret = devm_request_irq(dev, irq, uniphier_fi2c_interrupt, 0,
 			       pdev->name, priv);
@@ -568,6 +568,33 @@ static int uniphier_fi2c_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static int __maybe_unused uniphier_fi2c_suspend(struct device *dev)
+{
+	struct uniphier_fi2c_priv *priv = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+
+static int __maybe_unused uniphier_fi2c_resume(struct device *dev)
+{
+	struct uniphier_fi2c_priv *priv = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(priv->clk);
+	if (ret)
+		return ret;
+
+	uniphier_fi2c_hw_init(priv);
+
+	return 0;
+}
+
+static const struct dev_pm_ops uniphier_fi2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(uniphier_fi2c_suspend, uniphier_fi2c_resume)
+};
+
 static const struct of_device_id uniphier_fi2c_match[] = {
 	{ .compatible = "socionext,uniphier-fi2c" },
 	{ /* sentinel */ }
@@ -580,6 +607,7 @@ static struct platform_driver uniphier_fi2c_drv = {
 	.driver = {
 		.name  = "uniphier-fi2c",
 		.of_match_table = uniphier_fi2c_match,
+		.pm = &uniphier_fi2c_pm_ops,
 	},
 };
 module_platform_driver(uniphier_fi2c_drv);

commit b92b7dbc714f3e604102ad0f056124fd5f8c00ce
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 4 19:49:21 2016 +0900

    i2c: uniphier-f: rename jump label to follow coding style guideline
    
    Documentation/CodingStyle recommends to use label names which say
    what the goto does or why the goto exists.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index db9105e52c79..beee31892295 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -528,7 +528,7 @@ static int uniphier_fi2c_probe(struct platform_device *pdev)
 	if (!clk_rate) {
 		dev_err(dev, "input clock rate should not be zero\n");
 		ret = -EINVAL;
-		goto err;
+		goto disable_clk;
 	}
 
 	init_completion(&priv->comp);
@@ -547,11 +547,11 @@ static int uniphier_fi2c_probe(struct platform_device *pdev)
 			       pdev->name, priv);
 	if (ret) {
 		dev_err(dev, "failed to request irq %d\n", irq);
-		goto err;
+		goto disable_clk;
 	}
 
 	ret = i2c_add_adapter(&priv->adap);
-err:
+disable_clk:
 	if (ret)
 		clk_disable_unprepare(priv->clk);
 

commit fcbd4bddb314346a35295701f385b9627bb3a137
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Sep 23 22:34:41 2016 +0900

    i2c: uniphier-f: fix misdetection of incomplete STOP condition
    
    Currently, the status register FI2C_SR is checked immediately after
    a STOP condition is issued in case of the deferred STOP condition.
    It takes typically 5-10 usec until the corresponding bits in the
    register are set, so the error check for "stop condition was not
    completed" is very likely to be false positive.
    
    Add wait code to relax the status register check.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index 829df91cc759..db9105e52c79 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -14,6 +14,7 @@
 
 #include <linux/clk.h>
 #include <linux/i2c.h>
+#include <linux/iopoll.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/module.h>
@@ -348,14 +349,19 @@ static int uniphier_fi2c_master_xfer_one(struct i2c_adapter *adap,
 	dev_dbg(&adap->dev, "complete\n");
 
 	if (unlikely(priv->flags & UNIPHIER_FI2C_DEFER_STOP_COMP)) {
-		u32 status = readl(priv->membase + UNIPHIER_FI2C_SR);
-
-		if (!(status & UNIPHIER_FI2C_SR_STS) ||
-		    status & UNIPHIER_FI2C_SR_BB) {
+		u32 status;
+		int ret;
+
+		ret = readl_poll_timeout(priv->membase + UNIPHIER_FI2C_SR,
+					 status,
+					 (status & UNIPHIER_FI2C_SR_STS) &&
+					 !(status & UNIPHIER_FI2C_SR_BB),
+					 1, 20);
+		if (ret) {
 			dev_err(&adap->dev,
 				"stop condition was not completed.\n");
 			uniphier_fi2c_recover(priv);
-			return -EBUSY;
+			return ret;
 		}
 	}
 

commit 0b1c7716fd871eaa6cb4a9a1df5396302411255a
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Sep 1 20:46:30 2016 +0900

    i2c: uniphier-f: set the adapter to master mode when probing
    
    Currently, the adapter is set to the master mode at the first use.
    Since then, it is kept in the slave mode, so unexpected glitch
    signals on the I2C lines may cause the adapter into insane state.
    Setting it to the master mode along with initialization solves the
    problem.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reported-by: Akio Noda <noda.akio@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index 28866854950e..829df91cc759 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -458,16 +458,20 @@ static struct i2c_bus_recovery_info uniphier_fi2c_bus_recovery_info = {
 static void uniphier_fi2c_hw_init(struct uniphier_fi2c_priv *priv,
 				  u32 bus_speed, unsigned long clk_rate)
 {
-	u32 clk_count;
+	u32 tmp;
+
+	tmp = readl(priv->membase + UNIPHIER_FI2C_CR);
+	tmp |= UNIPHIER_FI2C_CR_MST;
+	writel(tmp, priv->membase + UNIPHIER_FI2C_CR);
 
 	uniphier_fi2c_reset(priv);
 
-	clk_count = clk_rate / bus_speed;
+	tmp = clk_rate / bus_speed;
 
-	writel(clk_count, priv->membase + UNIPHIER_FI2C_CYC);
-	writel(clk_count / 2, priv->membase + UNIPHIER_FI2C_LCTL);
-	writel(clk_count / 2, priv->membase + UNIPHIER_FI2C_SSUT);
-	writel(clk_count / 16, priv->membase + UNIPHIER_FI2C_DSUT);
+	writel(tmp, priv->membase + UNIPHIER_FI2C_CYC);
+	writel(tmp / 2, priv->membase + UNIPHIER_FI2C_LCTL);
+	writel(tmp / 2, priv->membase + UNIPHIER_FI2C_SSUT);
+	writel(tmp / 16, priv->membase + UNIPHIER_FI2C_DSUT);
 
 	uniphier_fi2c_prepare_operation(priv);
 }

commit 405188e86a4acb732f94f6d7a00b7fbb89cf5309
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Sep 1 20:46:29 2016 +0900

    i2c: uniphier-f: avoid WARN_ON() of clk_disable() in failure path
    
    If clk_prepare_enable() fails, clk_disable_unprepare() is called in
    the failure path, where the enable_count is still zero, so it hits
    WARN_ON(core->enable_count == 0) in the clk_core_disable().
    
    To fix this, make the clock setting more linear in the probe function
    so that it can exploit "goto err" in case of error.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index 35608531fe07..28866854950e 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -455,41 +455,10 @@ static struct i2c_bus_recovery_info uniphier_fi2c_bus_recovery_info = {
 	.unprepare_recovery = uniphier_fi2c_unprepare_recovery,
 };
 
-static int uniphier_fi2c_clk_init(struct device *dev,
-				  struct uniphier_fi2c_priv *priv)
+static void uniphier_fi2c_hw_init(struct uniphier_fi2c_priv *priv,
+				  u32 bus_speed, unsigned long clk_rate)
 {
-	struct device_node *np = dev->of_node;
-	unsigned long clk_rate;
-	u32 bus_speed, clk_count;
-	int ret;
-
-	if (of_property_read_u32(np, "clock-frequency", &bus_speed))
-		bus_speed = UNIPHIER_FI2C_DEFAULT_SPEED;
-
-	if (!bus_speed) {
-		dev_err(dev, "clock-frequency should not be zero\n");
-		return -EINVAL;
-	}
-
-	if (bus_speed > UNIPHIER_FI2C_MAX_SPEED)
-		bus_speed = UNIPHIER_FI2C_MAX_SPEED;
-
-	/* Get input clk rate through clk driver */
-	priv->clk = devm_clk_get(dev, NULL);
-	if (IS_ERR(priv->clk)) {
-		dev_err(dev, "failed to get clock\n");
-		return PTR_ERR(priv->clk);
-	}
-
-	ret = clk_prepare_enable(priv->clk);
-	if (ret)
-		return ret;
-
-	clk_rate = clk_get_rate(priv->clk);
-	if (!clk_rate) {
-		dev_err(dev, "input clock rate should not be zero\n");
-		return -EINVAL;
-	}
+	u32 clk_count;
 
 	uniphier_fi2c_reset(priv);
 
@@ -501,8 +470,6 @@ static int uniphier_fi2c_clk_init(struct device *dev,
 	writel(clk_count / 16, priv->membase + UNIPHIER_FI2C_DSUT);
 
 	uniphier_fi2c_prepare_operation(priv);
-
-	return 0;
 }
 
 static int uniphier_fi2c_probe(struct platform_device *pdev)
@@ -510,8 +477,9 @@ static int uniphier_fi2c_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct uniphier_fi2c_priv *priv;
 	struct resource *regs;
-	int irq;
-	int ret;
+	u32 bus_speed;
+	unsigned long clk_rate;
+	int irq, ret;
 
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
@@ -528,6 +496,31 @@ static int uniphier_fi2c_probe(struct platform_device *pdev)
 		return irq;
 	}
 
+	if (of_property_read_u32(dev->of_node, "clock-frequency", &bus_speed))
+		bus_speed = UNIPHIER_FI2C_DEFAULT_SPEED;
+
+	if (!bus_speed || bus_speed > UNIPHIER_FI2C_MAX_SPEED) {
+		dev_err(dev, "invalid clock-frequency %d\n", bus_speed);
+		return -EINVAL;
+	}
+
+	priv->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev, "failed to get clock\n");
+		return PTR_ERR(priv->clk);
+	}
+
+	ret = clk_prepare_enable(priv->clk);
+	if (ret)
+		return ret;
+
+	clk_rate = clk_get_rate(priv->clk);
+	if (!clk_rate) {
+		dev_err(dev, "input clock rate should not be zero\n");
+		ret = -EINVAL;
+		goto err;
+	}
+
 	init_completion(&priv->comp);
 	priv->adap.owner = THIS_MODULE;
 	priv->adap.algo = &uniphier_fi2c_algo;
@@ -538,9 +531,7 @@ static int uniphier_fi2c_probe(struct platform_device *pdev)
 	i2c_set_adapdata(&priv->adap, priv);
 	platform_set_drvdata(pdev, priv);
 
-	ret = uniphier_fi2c_clk_init(dev, priv);
-	if (ret)
-		goto err;
+	uniphier_fi2c_hw_init(priv, bus_speed, clk_rate);
 
 	ret = devm_request_irq(dev, irq, uniphier_fi2c_interrupt, 0,
 			       pdev->name, priv);

commit 56025e7bc2079cda92643b43bf26991d3d09717d
Author: Wolfram Sang <wsa-dev@sang-engineering.com>
Date:   Tue Aug 9 22:11:40 2016 +0200

    i2c: uniphier{-f}: don't print error when adding adapter fails
    
    The core will do this for us now.
    
    Signed-off-by: Wolfram Sang <wsa-dev@sang-engineering.com>
    Acked-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index aeead0d27d10..35608531fe07 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -550,11 +550,6 @@ static int uniphier_fi2c_probe(struct platform_device *pdev)
 	}
 
 	ret = i2c_add_adapter(&priv->adap);
-	if (ret) {
-		dev_err(dev, "failed to add I2C adapter\n");
-		goto err;
-	}
-
 err:
 	if (ret)
 		clk_disable_unprepare(priv->clk);

commit 8a350183010a5557287a10c2a13b1a4cbaa7b130
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Apr 21 15:12:44 2016 +0900

    i2c: uniphier: add "\n" at the end of error log
    
    Just in case.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index 213ba55e17c3..aeead0d27d10 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -524,7 +524,7 @@ static int uniphier_fi2c_probe(struct platform_device *pdev)
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
-		dev_err(dev, "failed to get IRQ number");
+		dev_err(dev, "failed to get IRQ number\n");
 		return irq;
 	}
 

commit bca71ba0343d28d953d74149d9161ab65a520dd6
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Jan 26 18:09:21 2016 +0900

    i2c: uniphier: fix typos in error messages
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index f3e5ff8522f0..213ba55e17c3 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -467,7 +467,7 @@ static int uniphier_fi2c_clk_init(struct device *dev,
 		bus_speed = UNIPHIER_FI2C_DEFAULT_SPEED;
 
 	if (!bus_speed) {
-		dev_err(dev, "clock-freqyency should not be zero\n");
+		dev_err(dev, "clock-frequency should not be zero\n");
 		return -EINVAL;
 	}
 

commit 51549c087f2eb5788de48a7278c3eb169d66f554
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Nov 30 18:53:36 2015 +0900

    i2c: uniphier_f: error out if bus speed is zero
    
    There is code to divide by "bus_speed" some lines below.
    To eliminate the possibility of division by zero, bail out if
    "clock-frequency" is specified as zero.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index 67109e1d66c3..f3e5ff8522f0 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -466,6 +466,11 @@ static int uniphier_fi2c_clk_init(struct device *dev,
 	if (of_property_read_u32(np, "clock-frequency", &bus_speed))
 		bus_speed = UNIPHIER_FI2C_DEFAULT_SPEED;
 
+	if (!bus_speed) {
+		dev_err(dev, "clock-freqyency should not be zero\n");
+		return -EINVAL;
+	}
+
 	if (bus_speed > UNIPHIER_FI2C_MAX_SPEED)
 		bus_speed = UNIPHIER_FI2C_MAX_SPEED;
 

commit ac9b91f39d86f04eeacfccb6b6113b1ffa001ec1
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Nov 30 18:53:35 2015 +0900

    i2c: uniphier_f: error out if clock rate is zero
    
    This input clock is used to generate the sampling clock for I2C bus.
    If the clock rate is zero, there is something wrong with the clock
    driver.  Bail out with the appropriate error message in such a case.
    It would make it easier to find the root cause of failure.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index e8d03bcfe3e0..67109e1d66c3 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -481,6 +481,10 @@ static int uniphier_fi2c_clk_init(struct device *dev,
 		return ret;
 
 	clk_rate = clk_get_rate(priv->clk);
+	if (!clk_rate) {
+		dev_err(dev, "input clock rate should not be zero\n");
+		return -EINVAL;
+	}
 
 	uniphier_fi2c_reset(priv);
 
@@ -531,7 +535,7 @@ static int uniphier_fi2c_probe(struct platform_device *pdev)
 
 	ret = uniphier_fi2c_clk_init(dev, priv);
 	if (ret)
-		return ret;
+		goto err;
 
 	ret = devm_request_irq(dev, irq, uniphier_fi2c_interrupt, 0,
 			       pdev->name, priv);

commit 6a62974b667f3976ec44e255bed31746cca1ff51
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Oct 23 19:52:00 2015 +0900

    i2c: uniphier_f: add UniPhier FIFO-builtin I2C driver
    
    Add support for on-chip I2C controller used on newer UniPhier SoCs
    such as PH1-Pro4, PH1-Pro5, etc.  This adapter is equipped with
    8-depth TX/RX FIFOs.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
new file mode 100644
index 000000000000..e8d03bcfe3e0
--- /dev/null
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -0,0 +1,584 @@
+/*
+ * Copyright (C) 2015 Masahiro Yamada <yamada.masahiro@socionext.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#define UNIPHIER_FI2C_CR	0x00	/* control register */
+#define     UNIPHIER_FI2C_CR_MST	BIT(3)	/* master mode */
+#define     UNIPHIER_FI2C_CR_STA	BIT(2)	/* start condition */
+#define     UNIPHIER_FI2C_CR_STO	BIT(1)	/* stop condition */
+#define     UNIPHIER_FI2C_CR_NACK	BIT(0)	/* do not return ACK */
+#define UNIPHIER_FI2C_DTTX	0x04	/* TX FIFO */
+#define     UNIPHIER_FI2C_DTTX_CMD	BIT(8)	/* send command (slave addr) */
+#define     UNIPHIER_FI2C_DTTX_RD	BIT(0)	/* read transaction */
+#define UNIPHIER_FI2C_DTRX	0x04	/* RX FIFO */
+#define UNIPHIER_FI2C_SLAD	0x0c	/* slave address */
+#define UNIPHIER_FI2C_CYC	0x10	/* clock cycle control */
+#define UNIPHIER_FI2C_LCTL	0x14	/* clock low period control */
+#define UNIPHIER_FI2C_SSUT	0x18	/* restart/stop setup time control */
+#define UNIPHIER_FI2C_DSUT	0x1c	/* data setup time control */
+#define UNIPHIER_FI2C_INT	0x20	/* interrupt status */
+#define UNIPHIER_FI2C_IE	0x24	/* interrupt enable */
+#define UNIPHIER_FI2C_IC	0x28	/* interrupt clear */
+#define     UNIPHIER_FI2C_INT_TE	BIT(9)	/* TX FIFO empty */
+#define     UNIPHIER_FI2C_INT_RF	BIT(8)	/* RX FIFO full */
+#define     UNIPHIER_FI2C_INT_TC	BIT(7)	/* send complete (STOP) */
+#define     UNIPHIER_FI2C_INT_RC	BIT(6)	/* receive complete (STOP) */
+#define     UNIPHIER_FI2C_INT_TB	BIT(5)	/* sent specified bytes */
+#define     UNIPHIER_FI2C_INT_RB	BIT(4)	/* received specified bytes */
+#define     UNIPHIER_FI2C_INT_NA	BIT(2)	/* no ACK */
+#define     UNIPHIER_FI2C_INT_AL	BIT(1)	/* arbitration lost */
+#define UNIPHIER_FI2C_SR	0x2c	/* status register */
+#define     UNIPHIER_FI2C_SR_DB		BIT(12)	/* device busy */
+#define     UNIPHIER_FI2C_SR_STS	BIT(11)	/* stop condition detected */
+#define     UNIPHIER_FI2C_SR_BB		BIT(8)	/* bus busy */
+#define     UNIPHIER_FI2C_SR_RFF	BIT(3)	/* RX FIFO full */
+#define     UNIPHIER_FI2C_SR_RNE	BIT(2)	/* RX FIFO not empty */
+#define     UNIPHIER_FI2C_SR_TNF	BIT(1)	/* TX FIFO not full */
+#define     UNIPHIER_FI2C_SR_TFE	BIT(0)	/* TX FIFO empty */
+#define UNIPHIER_FI2C_RST	0x34	/* reset control */
+#define     UNIPHIER_FI2C_RST_TBRST	BIT(2)	/* clear TX FIFO */
+#define     UNIPHIER_FI2C_RST_RBRST	BIT(1)	/* clear RX FIFO */
+#define     UNIPHIER_FI2C_RST_RST	BIT(0)	/* forcible bus reset */
+#define UNIPHIER_FI2C_BM	0x38	/* bus monitor */
+#define     UNIPHIER_FI2C_BM_SDAO	BIT(3)	/* output for SDA line */
+#define     UNIPHIER_FI2C_BM_SDAS	BIT(2)	/* readback of SDA line */
+#define     UNIPHIER_FI2C_BM_SCLO	BIT(1)	/* output for SCL line */
+#define     UNIPHIER_FI2C_BM_SCLS	BIT(0)	/* readback of SCL line */
+#define UNIPHIER_FI2C_NOISE	0x3c	/* noise filter control */
+#define UNIPHIER_FI2C_TBC	0x40	/* TX byte count setting */
+#define UNIPHIER_FI2C_RBC	0x44	/* RX byte count setting */
+#define UNIPHIER_FI2C_TBCM	0x48	/* TX byte count monitor */
+#define UNIPHIER_FI2C_RBCM	0x4c	/* RX byte count monitor */
+#define UNIPHIER_FI2C_BRST	0x50	/* bus reset */
+#define     UNIPHIER_FI2C_BRST_FOEN	BIT(1)	/* normal operation */
+#define     UNIPHIER_FI2C_BRST_RSCL	BIT(0)	/* release SCL */
+
+#define UNIPHIER_FI2C_INT_FAULTS	\
+				(UNIPHIER_FI2C_INT_NA | UNIPHIER_FI2C_INT_AL)
+#define UNIPHIER_FI2C_INT_STOP		\
+				(UNIPHIER_FI2C_INT_TC | UNIPHIER_FI2C_INT_RC)
+
+#define UNIPHIER_FI2C_RD		BIT(0)
+#define UNIPHIER_FI2C_STOP		BIT(1)
+#define UNIPHIER_FI2C_MANUAL_NACK	BIT(2)
+#define UNIPHIER_FI2C_BYTE_WISE		BIT(3)
+#define UNIPHIER_FI2C_DEFER_STOP_COMP	BIT(4)
+
+#define UNIPHIER_FI2C_DEFAULT_SPEED	100000
+#define UNIPHIER_FI2C_MAX_SPEED		400000
+#define UNIPHIER_FI2C_FIFO_SIZE		8
+
+struct uniphier_fi2c_priv {
+	struct completion comp;
+	struct i2c_adapter adap;
+	void __iomem *membase;
+	struct clk *clk;
+	unsigned int len;
+	u8 *buf;
+	u32 enabled_irqs;
+	int error;
+	unsigned int flags;
+	unsigned int busy_cnt;
+};
+
+static void uniphier_fi2c_fill_txfifo(struct uniphier_fi2c_priv *priv,
+				      bool first)
+{
+	int fifo_space = UNIPHIER_FI2C_FIFO_SIZE;
+
+	/*
+	 * TX-FIFO stores slave address in it for the first access.
+	 * Decrement the counter.
+	 */
+	if (first)
+		fifo_space--;
+
+	while (priv->len) {
+		if (fifo_space-- <= 0)
+			break;
+
+		dev_dbg(&priv->adap.dev, "write data: %02x\n", *priv->buf);
+		writel(*priv->buf++, priv->membase + UNIPHIER_FI2C_DTTX);
+		priv->len--;
+	}
+}
+
+static void uniphier_fi2c_drain_rxfifo(struct uniphier_fi2c_priv *priv)
+{
+	int fifo_left = priv->flags & UNIPHIER_FI2C_BYTE_WISE ?
+						1 : UNIPHIER_FI2C_FIFO_SIZE;
+
+	while (priv->len) {
+		if (fifo_left-- <= 0)
+			break;
+
+		*priv->buf++ = readl(priv->membase + UNIPHIER_FI2C_DTRX);
+		dev_dbg(&priv->adap.dev, "read data: %02x\n", priv->buf[-1]);
+		priv->len--;
+	}
+}
+
+static void uniphier_fi2c_set_irqs(struct uniphier_fi2c_priv *priv)
+{
+	writel(priv->enabled_irqs, priv->membase + UNIPHIER_FI2C_IE);
+}
+
+static void uniphier_fi2c_clear_irqs(struct uniphier_fi2c_priv *priv)
+{
+	writel(-1, priv->membase + UNIPHIER_FI2C_IC);
+}
+
+static void uniphier_fi2c_stop(struct uniphier_fi2c_priv *priv)
+{
+	dev_dbg(&priv->adap.dev, "stop condition\n");
+
+	priv->enabled_irqs |= UNIPHIER_FI2C_INT_STOP;
+	uniphier_fi2c_set_irqs(priv);
+	writel(UNIPHIER_FI2C_CR_MST | UNIPHIER_FI2C_CR_STO,
+	       priv->membase + UNIPHIER_FI2C_CR);
+}
+
+static irqreturn_t uniphier_fi2c_interrupt(int irq, void *dev_id)
+{
+	struct uniphier_fi2c_priv *priv = dev_id;
+	u32 irq_status;
+
+	irq_status = readl(priv->membase + UNIPHIER_FI2C_INT);
+
+	dev_dbg(&priv->adap.dev,
+		"interrupt: enabled_irqs=%04x, irq_status=%04x\n",
+		priv->enabled_irqs, irq_status);
+
+	if (irq_status & UNIPHIER_FI2C_INT_STOP)
+		goto complete;
+
+	if (unlikely(irq_status & UNIPHIER_FI2C_INT_AL)) {
+		dev_dbg(&priv->adap.dev, "arbitration lost\n");
+		priv->error = -EAGAIN;
+		goto complete;
+	}
+
+	if (unlikely(irq_status & UNIPHIER_FI2C_INT_NA)) {
+		dev_dbg(&priv->adap.dev, "could not get ACK\n");
+		priv->error = -ENXIO;
+		if (priv->flags & UNIPHIER_FI2C_RD) {
+			/*
+			 * work around a hardware bug:
+			 * The receive-completed interrupt is never set even if
+			 * STOP condition is detected after the address phase
+			 * of read transaction fails to get ACK.
+			 * To avoid time-out error, we issue STOP here,
+			 * but do not wait for its completion.
+			 * It should be checked after exiting this handler.
+			 */
+			uniphier_fi2c_stop(priv);
+			priv->flags |= UNIPHIER_FI2C_DEFER_STOP_COMP;
+			goto complete;
+		}
+		goto stop;
+	}
+
+	if (irq_status & UNIPHIER_FI2C_INT_TE) {
+		if (!priv->len)
+			goto data_done;
+
+		uniphier_fi2c_fill_txfifo(priv, false);
+		goto handled;
+	}
+
+	if (irq_status & (UNIPHIER_FI2C_INT_RF | UNIPHIER_FI2C_INT_RB)) {
+		uniphier_fi2c_drain_rxfifo(priv);
+		if (!priv->len)
+			goto data_done;
+
+		if (unlikely(priv->flags & UNIPHIER_FI2C_MANUAL_NACK)) {
+			if (priv->len <= UNIPHIER_FI2C_FIFO_SIZE &&
+			    !(priv->flags & UNIPHIER_FI2C_BYTE_WISE)) {
+				dev_dbg(&priv->adap.dev,
+					"enable read byte count IRQ\n");
+				priv->enabled_irqs |= UNIPHIER_FI2C_INT_RB;
+				uniphier_fi2c_set_irqs(priv);
+				priv->flags |= UNIPHIER_FI2C_BYTE_WISE;
+			}
+			if (priv->len <= 1) {
+				dev_dbg(&priv->adap.dev, "set NACK\n");
+				writel(UNIPHIER_FI2C_CR_MST |
+				       UNIPHIER_FI2C_CR_NACK,
+				       priv->membase + UNIPHIER_FI2C_CR);
+			}
+		}
+
+		goto handled;
+	}
+
+	return IRQ_NONE;
+
+data_done:
+	if (priv->flags & UNIPHIER_FI2C_STOP) {
+stop:
+		uniphier_fi2c_stop(priv);
+	} else {
+complete:
+		priv->enabled_irqs = 0;
+		uniphier_fi2c_set_irqs(priv);
+		complete(&priv->comp);
+	}
+
+handled:
+	uniphier_fi2c_clear_irqs(priv);
+
+	return IRQ_HANDLED;
+}
+
+static void uniphier_fi2c_tx_init(struct uniphier_fi2c_priv *priv, u16 addr)
+{
+	priv->enabled_irqs |= UNIPHIER_FI2C_INT_TE;
+	/* do not use TX byte counter */
+	writel(0, priv->membase + UNIPHIER_FI2C_TBC);
+	/* set slave address */
+	writel(UNIPHIER_FI2C_DTTX_CMD | addr << 1,
+	       priv->membase + UNIPHIER_FI2C_DTTX);
+	/* first chunk of data */
+	uniphier_fi2c_fill_txfifo(priv, true);
+}
+
+static void uniphier_fi2c_rx_init(struct uniphier_fi2c_priv *priv, u16 addr)
+{
+	priv->flags |= UNIPHIER_FI2C_RD;
+
+	if (likely(priv->len < 256)) {
+		/*
+		 * If possible, use RX byte counter.
+		 * It can automatically handle NACK for the last byte.
+		 */
+		writel(priv->len, priv->membase + UNIPHIER_FI2C_RBC);
+		priv->enabled_irqs |= UNIPHIER_FI2C_INT_RF |
+				      UNIPHIER_FI2C_INT_RB;
+	} else {
+		/*
+		 * The byte counter can not count over 256.  In this case,
+		 * do not use it at all.  Drain data when FIFO gets full,
+		 * but treat the last portion as a special case.
+		 */
+		writel(0, priv->membase + UNIPHIER_FI2C_RBC);
+		priv->flags |= UNIPHIER_FI2C_MANUAL_NACK;
+		priv->enabled_irqs |= UNIPHIER_FI2C_INT_RF;
+	}
+
+	/* set slave address with RD bit */
+	writel(UNIPHIER_FI2C_DTTX_CMD | UNIPHIER_FI2C_DTTX_RD | addr << 1,
+	       priv->membase + UNIPHIER_FI2C_DTTX);
+}
+
+static void uniphier_fi2c_reset(struct uniphier_fi2c_priv *priv)
+{
+	writel(UNIPHIER_FI2C_RST_RST, priv->membase + UNIPHIER_FI2C_RST);
+}
+
+static void uniphier_fi2c_prepare_operation(struct uniphier_fi2c_priv *priv)
+{
+	writel(UNIPHIER_FI2C_BRST_FOEN | UNIPHIER_FI2C_BRST_RSCL,
+	       priv->membase + UNIPHIER_FI2C_BRST);
+}
+
+static void uniphier_fi2c_recover(struct uniphier_fi2c_priv *priv)
+{
+	uniphier_fi2c_reset(priv);
+	i2c_recover_bus(&priv->adap);
+}
+
+static int uniphier_fi2c_master_xfer_one(struct i2c_adapter *adap,
+					 struct i2c_msg *msg, bool stop)
+{
+	struct uniphier_fi2c_priv *priv = i2c_get_adapdata(adap);
+	bool is_read = msg->flags & I2C_M_RD;
+	unsigned long time_left;
+
+	dev_dbg(&adap->dev, "%s: addr=0x%02x, len=%d, stop=%d\n",
+		is_read ? "receive" : "transmit", msg->addr, msg->len, stop);
+
+	priv->len = msg->len;
+	priv->buf = msg->buf;
+	priv->enabled_irqs = UNIPHIER_FI2C_INT_FAULTS;
+	priv->error = 0;
+	priv->flags = 0;
+
+	if (stop)
+		priv->flags |= UNIPHIER_FI2C_STOP;
+
+	reinit_completion(&priv->comp);
+	uniphier_fi2c_clear_irqs(priv);
+	writel(UNIPHIER_FI2C_RST_TBRST | UNIPHIER_FI2C_RST_RBRST,
+	       priv->membase + UNIPHIER_FI2C_RST);	/* reset TX/RX FIFO */
+
+	if (is_read)
+		uniphier_fi2c_rx_init(priv, msg->addr);
+	else
+		uniphier_fi2c_tx_init(priv, msg->addr);
+
+	uniphier_fi2c_set_irqs(priv);
+
+	dev_dbg(&adap->dev, "start condition\n");
+	writel(UNIPHIER_FI2C_CR_MST | UNIPHIER_FI2C_CR_STA,
+	       priv->membase + UNIPHIER_FI2C_CR);
+
+	time_left = wait_for_completion_timeout(&priv->comp, adap->timeout);
+	if (!time_left) {
+		dev_err(&adap->dev, "transaction timeout.\n");
+		uniphier_fi2c_recover(priv);
+		return -ETIMEDOUT;
+	}
+	dev_dbg(&adap->dev, "complete\n");
+
+	if (unlikely(priv->flags & UNIPHIER_FI2C_DEFER_STOP_COMP)) {
+		u32 status = readl(priv->membase + UNIPHIER_FI2C_SR);
+
+		if (!(status & UNIPHIER_FI2C_SR_STS) ||
+		    status & UNIPHIER_FI2C_SR_BB) {
+			dev_err(&adap->dev,
+				"stop condition was not completed.\n");
+			uniphier_fi2c_recover(priv);
+			return -EBUSY;
+		}
+	}
+
+	return priv->error;
+}
+
+static int uniphier_fi2c_check_bus_busy(struct i2c_adapter *adap)
+{
+	struct uniphier_fi2c_priv *priv = i2c_get_adapdata(adap);
+
+	if (readl(priv->membase + UNIPHIER_FI2C_SR) & UNIPHIER_FI2C_SR_DB) {
+		if (priv->busy_cnt++ > 3) {
+			/*
+			 * If bus busy continues too long, it is probably
+			 * in a wrong state.  Try bus recovery.
+			 */
+			uniphier_fi2c_recover(priv);
+			priv->busy_cnt = 0;
+		}
+
+		return -EAGAIN;
+	}
+
+	priv->busy_cnt = 0;
+	return 0;
+}
+
+static int uniphier_fi2c_master_xfer(struct i2c_adapter *adap,
+				     struct i2c_msg *msgs, int num)
+{
+	struct i2c_msg *msg, *emsg = msgs + num;
+	int ret;
+
+	ret = uniphier_fi2c_check_bus_busy(adap);
+	if (ret)
+		return ret;
+
+	for (msg = msgs; msg < emsg; msg++) {
+		/* If next message is read, skip the stop condition */
+		bool stop = !(msg + 1 < emsg && msg[1].flags & I2C_M_RD);
+		/* but, force it if I2C_M_STOP is set */
+		if (msg->flags & I2C_M_STOP)
+			stop = true;
+
+		ret = uniphier_fi2c_master_xfer_one(adap, msg, stop);
+		if (ret)
+			return ret;
+	}
+
+	return num;
+}
+
+static u32 uniphier_fi2c_functionality(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+static const struct i2c_algorithm uniphier_fi2c_algo = {
+	.master_xfer = uniphier_fi2c_master_xfer,
+	.functionality = uniphier_fi2c_functionality,
+};
+
+static int uniphier_fi2c_get_scl(struct i2c_adapter *adap)
+{
+	struct uniphier_fi2c_priv *priv = i2c_get_adapdata(adap);
+
+	return !!(readl(priv->membase + UNIPHIER_FI2C_BM) &
+							UNIPHIER_FI2C_BM_SCLS);
+}
+
+static void uniphier_fi2c_set_scl(struct i2c_adapter *adap, int val)
+{
+	struct uniphier_fi2c_priv *priv = i2c_get_adapdata(adap);
+
+	writel(val ? UNIPHIER_FI2C_BRST_RSCL : 0,
+	       priv->membase + UNIPHIER_FI2C_BRST);
+}
+
+static int uniphier_fi2c_get_sda(struct i2c_adapter *adap)
+{
+	struct uniphier_fi2c_priv *priv = i2c_get_adapdata(adap);
+
+	return !!(readl(priv->membase + UNIPHIER_FI2C_BM) &
+							UNIPHIER_FI2C_BM_SDAS);
+}
+
+static void uniphier_fi2c_unprepare_recovery(struct i2c_adapter *adap)
+{
+	uniphier_fi2c_prepare_operation(i2c_get_adapdata(adap));
+}
+
+static struct i2c_bus_recovery_info uniphier_fi2c_bus_recovery_info = {
+	.recover_bus = i2c_generic_scl_recovery,
+	.get_scl = uniphier_fi2c_get_scl,
+	.set_scl = uniphier_fi2c_set_scl,
+	.get_sda = uniphier_fi2c_get_sda,
+	.unprepare_recovery = uniphier_fi2c_unprepare_recovery,
+};
+
+static int uniphier_fi2c_clk_init(struct device *dev,
+				  struct uniphier_fi2c_priv *priv)
+{
+	struct device_node *np = dev->of_node;
+	unsigned long clk_rate;
+	u32 bus_speed, clk_count;
+	int ret;
+
+	if (of_property_read_u32(np, "clock-frequency", &bus_speed))
+		bus_speed = UNIPHIER_FI2C_DEFAULT_SPEED;
+
+	if (bus_speed > UNIPHIER_FI2C_MAX_SPEED)
+		bus_speed = UNIPHIER_FI2C_MAX_SPEED;
+
+	/* Get input clk rate through clk driver */
+	priv->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev, "failed to get clock\n");
+		return PTR_ERR(priv->clk);
+	}
+
+	ret = clk_prepare_enable(priv->clk);
+	if (ret)
+		return ret;
+
+	clk_rate = clk_get_rate(priv->clk);
+
+	uniphier_fi2c_reset(priv);
+
+	clk_count = clk_rate / bus_speed;
+
+	writel(clk_count, priv->membase + UNIPHIER_FI2C_CYC);
+	writel(clk_count / 2, priv->membase + UNIPHIER_FI2C_LCTL);
+	writel(clk_count / 2, priv->membase + UNIPHIER_FI2C_SSUT);
+	writel(clk_count / 16, priv->membase + UNIPHIER_FI2C_DSUT);
+
+	uniphier_fi2c_prepare_operation(priv);
+
+	return 0;
+}
+
+static int uniphier_fi2c_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct uniphier_fi2c_priv *priv;
+	struct resource *regs;
+	int irq;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->membase = devm_ioremap_resource(dev, regs);
+	if (IS_ERR(priv->membase))
+		return PTR_ERR(priv->membase);
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(dev, "failed to get IRQ number");
+		return irq;
+	}
+
+	init_completion(&priv->comp);
+	priv->adap.owner = THIS_MODULE;
+	priv->adap.algo = &uniphier_fi2c_algo;
+	priv->adap.dev.parent = dev;
+	priv->adap.dev.of_node = dev->of_node;
+	strlcpy(priv->adap.name, "UniPhier FI2C", sizeof(priv->adap.name));
+	priv->adap.bus_recovery_info = &uniphier_fi2c_bus_recovery_info;
+	i2c_set_adapdata(&priv->adap, priv);
+	platform_set_drvdata(pdev, priv);
+
+	ret = uniphier_fi2c_clk_init(dev, priv);
+	if (ret)
+		return ret;
+
+	ret = devm_request_irq(dev, irq, uniphier_fi2c_interrupt, 0,
+			       pdev->name, priv);
+	if (ret) {
+		dev_err(dev, "failed to request irq %d\n", irq);
+		goto err;
+	}
+
+	ret = i2c_add_adapter(&priv->adap);
+	if (ret) {
+		dev_err(dev, "failed to add I2C adapter\n");
+		goto err;
+	}
+
+err:
+	if (ret)
+		clk_disable_unprepare(priv->clk);
+
+	return ret;
+}
+
+static int uniphier_fi2c_remove(struct platform_device *pdev)
+{
+	struct uniphier_fi2c_priv *priv = platform_get_drvdata(pdev);
+
+	i2c_del_adapter(&priv->adap);
+	clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+
+static const struct of_device_id uniphier_fi2c_match[] = {
+	{ .compatible = "socionext,uniphier-fi2c" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, uniphier_fi2c_match);
+
+static struct platform_driver uniphier_fi2c_drv = {
+	.probe  = uniphier_fi2c_probe,
+	.remove = uniphier_fi2c_remove,
+	.driver = {
+		.name  = "uniphier-fi2c",
+		.of_match_table = uniphier_fi2c_match,
+	},
+};
+module_platform_driver(uniphier_fi2c_drv);
+
+MODULE_AUTHOR("Masahiro Yamada <yamada.masahiro@socionext.com>");
+MODULE_DESCRIPTION("UniPhier FIFO-builtin I2C bus driver");
+MODULE_LICENSE("GPL");
