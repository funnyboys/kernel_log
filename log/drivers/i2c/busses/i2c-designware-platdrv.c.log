commit db2a8b6f1df93d5311970cca03052c01178de674
Author: Ricardo Ribalda <ribalda@kernel.org>
Date:   Thu Jul 2 12:33:21 2020 +0200

    i2c: designware: platdrv: Set class based on DMI
    
    Current AMD's zen-based APUs use this core for some of its i2c-buses.
    
    With this patch we re-enable autodetection of hwmon-alike devices, so
    lm-sensors will be able to work automatically.
    
    It does not affect the boot-time of embedded devices, as the class is
    set based on the DMI information.
    
    DMI is probed only on Qtechnology QT5222 Industrial Camera Platform.
    
    DocLink: https://qtec.com/camera-technology-camera-platforms/
    Fixes: 3eddad96c439 ("i2c: designware: reverts "i2c: designware: Add support for AMD I2C controller"")
    Signed-off-by: Ricardo Ribalda <ribalda@kernel.org>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@kernel.org>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index c2efaaaac252..a71bc58fc03c 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -12,6 +12,7 @@
 #include <linux/clk-provider.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
+#include <linux/dmi.h>
 #include <linux/err.h>
 #include <linux/errno.h>
 #include <linux/i2c.h>
@@ -191,6 +192,17 @@ static int dw_i2c_plat_request_regs(struct dw_i2c_dev *dev)
 	return ret;
 }
 
+static const struct dmi_system_id dw_i2c_hwmon_class_dmi[] = {
+	{
+		.ident = "Qtechnology QT5222",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Qtechnology"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "QT5222"),
+		},
+	},
+	{ } /* terminate list */
+};
+
 static int dw_i2c_plat_probe(struct platform_device *pdev)
 {
 	struct dw_i2c_platform_data *pdata = dev_get_platdata(&pdev->dev);
@@ -267,7 +279,8 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 
 	adap = &dev->adapter;
 	adap->owner = THIS_MODULE;
-	adap->class = I2C_CLASS_DEPRECATED;
+	adap->class = dmi_check_system(dw_i2c_hwmon_class_dmi) ?
+					I2C_CLASS_HWMON : I2C_CLASS_DEPRECATED;
 	ACPI_COMPANION_SET(&adap->dev, ACPI_COMPANION(&pdev->dev));
 	adap->dev.of_node = pdev->dev.of_node;
 	adap->nr = -1;

commit 852f71942ce71fd9a2bb25667bda53afeb97dcb6
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Jun 23 12:15:01 2020 +0300

    i2c: designware: Adjust bus speed independently of ACPI
    
    John Stultz reported that commit f9288fcc5c615 ("i2c: designware: Move
    ACPI parts into common module") caused a regression on the HiKey board
    where adv7511 HDMI bridge driver wasn't probing anymore due the I2C bus
    failed to start.
    
    It seems the change caused the bus speed being zero when CONFIG_ACPI
    not set and neither speed based on "clock-frequency" device property
    or default fast mode is set.
    
    Fix this by splitting i2c_dw_acpi_adjust_bus_speed() to
    i2c_dw_acpi_round_bus_speed() and i2c_dw_adjust_bus_speed(), where
    the latter one has the code that runs independently of ACPI.
    
    Fixes: f9288fcc5c615 ("i2c: designware: Move ACPI parts into common module")
    Reported-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Tested-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Wolfram Sang <wsa@kernel.org>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 0de4e302fc6a..c2efaaaac252 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -228,7 +228,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	else
 		i2c_parse_fw_timings(&pdev->dev, t, false);
 
-	i2c_dw_acpi_adjust_bus_speed(&pdev->dev);
+	i2c_dw_adjust_bus_speed(dev);
 
 	if (pdev->dev.of_node)
 		dw_i2c_of_configure(pdev);

commit 91fa58840ae22cbf6d7c505ce6564c4c48f29af3
Merge: ac911b316336 d790eeb3db6a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jun 13 13:12:38 2020 -0700

    Merge branch 'i2c/for-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux
    
    Pull i2c updates from Wolfram Sang:
     "I2C has quite some patches for you this time. I hope it is the move to
      per-driver-maintainers which is now showing results. We will see.
    
      The big news is two new drivers (Nuvoton NPCM and Qualcomm CCI),
      larger refactoring of the Designware, Tegra, and PXA drivers, the
      Cadence driver supports being a slave now, and there is support to
      instanciate SPD eeproms for well-known cases (which will be
      user-visible because the i801 driver supports it), and some
      devm_platform_ioremap_resource() conversions which blow up the
      diffstat.
    
      Note that I applied the Nuvoton driver quite late, so some minor fixup
      patches arrived during the merge window. I chose to apply them right
      away because they were trivial"
    
    * 'i2c/for-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux: (109 commits)
      i2c: Drop stray comma in MODULE_AUTHOR statements
      i2c: npcm7xx: npcm_i2caddr[] can be static
      MAINTAINERS: npcm7xx: Add maintainer for Nuvoton NPCM BMC
      i2c: npcm7xx: Fix a couple of error codes in probe
      i2c: icy: Fix build with CONFIG_AMIGA_PCMCIA=n
      i2c: npcm7xx: Remove unnecessary parentheses
      i2c: npcm7xx: Add support for slave mode for Nuvoton
      i2c: npcm7xx: Add Nuvoton NPCM I2C controller driver
      dt-bindings: i2c: npcm7xx: add NPCM I2C controller
      i2c: pxa: don't error out if there's no pinctrl
      i2c: add 'single-master' property to generic bindings
      i2c: designware: Add Baikal-T1 System I2C support
      i2c: designware: Move reg-space remapping into a dedicated function
      i2c: designware: Retrieve quirk flags as early as possible
      i2c: designware: Convert driver to using regmap API
      i2c: designware: Discard Cherry Trail model flag
      i2c: designware: Add Baytrail sem config DW I2C platform dependency
      i2c: designware: slave: Set DW I2C core module dependency
      i2c: designware: Use `-y` to build multi-object modules
      dt-bindings: i2c: dw: Add Baikal-T1 SoC I2C controller
      ...

commit fcb82a939df86018641f38124cb9a7811a5f8505
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Thu May 28 12:33:21 2020 +0300

    i2c: designware: Add Baikal-T1 System I2C support
    
    Baikal-T1 System Controller is equipped with a dedicated I2C Controller
    which functionality is based on the DW APB I2C IP-core, the only
    difference in a way it' registers are accessed. There are three access
    register provided in the System Controller registers map, which indirectly
    address the normal DW APB I2C registers space. So in order to have the
    Baikal-T1 System I2C Controller supported by the common DW APB I2C driver
    we created a dedicated Dw I2C controller model quirk, which retrieves the
    syscon regmap from the parental dt node and creates a new regmap based on
    it.
    
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@kernel.org>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 9d467fa0e163..b55c730f28cf 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -18,6 +18,7 @@
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/kernel.h>
+#include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/platform_data/i2c-designware.h>
@@ -25,6 +26,7 @@
 #include <linux/pm.h>
 #include <linux/pm_runtime.h>
 #include <linux/property.h>
+#include <linux/regmap.h>
 #include <linux/reset.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
@@ -58,6 +60,63 @@ MODULE_DEVICE_TABLE(acpi, dw_i2c_acpi_match);
 #endif
 
 #ifdef CONFIG_OF
+#define BT1_I2C_CTL			0x100
+#define BT1_I2C_CTL_ADDR_MASK		GENMASK(7, 0)
+#define BT1_I2C_CTL_WR			BIT(8)
+#define BT1_I2C_CTL_GO			BIT(31)
+#define BT1_I2C_DI			0x104
+#define BT1_I2C_DO			0x108
+
+static int bt1_i2c_read(void *context, unsigned int reg, unsigned int *val)
+{
+	struct dw_i2c_dev *dev = context;
+	int ret;
+
+	/*
+	 * Note these methods shouldn't ever fail because the system controller
+	 * registers are memory mapped. We check the return value just in case.
+	 */
+	ret = regmap_write(dev->sysmap, BT1_I2C_CTL,
+			   BT1_I2C_CTL_GO | (reg & BT1_I2C_CTL_ADDR_MASK));
+	if (ret)
+		return ret;
+
+	return regmap_read(dev->sysmap, BT1_I2C_DO, val);
+}
+
+static int bt1_i2c_write(void *context, unsigned int reg, unsigned int val)
+{
+	struct dw_i2c_dev *dev = context;
+	int ret;
+
+	ret = regmap_write(dev->sysmap, BT1_I2C_DI, val);
+	if (ret)
+		return ret;
+
+	return regmap_write(dev->sysmap, BT1_I2C_CTL,
+		BT1_I2C_CTL_GO | BT1_I2C_CTL_WR | (reg & BT1_I2C_CTL_ADDR_MASK));
+}
+
+static struct regmap_config bt1_i2c_cfg = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = 4,
+	.fast_io = true,
+	.reg_read = bt1_i2c_read,
+	.reg_write = bt1_i2c_write,
+	.max_register = DW_IC_COMP_TYPE,
+};
+
+static int bt1_i2c_request_regs(struct dw_i2c_dev *dev)
+{
+	dev->sysmap = syscon_node_to_regmap(dev->dev->of_node->parent);
+	if (IS_ERR(dev->sysmap))
+		return PTR_ERR(dev->sysmap);
+
+	dev->map = devm_regmap_init(dev->dev, NULL, dev, &bt1_i2c_cfg);
+	return PTR_ERR_OR_ZERO(dev->map);
+}
+
 #define MSCC_ICPU_CFG_TWI_DELAY		0x0
 #define MSCC_ICPU_CFG_TWI_DELAY_ENABLE	BIT(0)
 #define MSCC_ICPU_CFG_TWI_SPIKE_FILTER	0x4
@@ -90,10 +149,16 @@ static int dw_i2c_of_configure(struct platform_device *pdev)
 static const struct of_device_id dw_i2c_of_match[] = {
 	{ .compatible = "snps,designware-i2c", },
 	{ .compatible = "mscc,ocelot-i2c", .data = (void *)MODEL_MSCC_OCELOT },
+	{ .compatible = "baikal,bt1-sys-i2c", .data = (void *)MODEL_BAIKAL_BT1 },
 	{},
 };
 MODULE_DEVICE_TABLE(of, dw_i2c_of_match);
 #else
+static int bt1_i2c_request_regs(struct dw_i2c_dev *dev)
+{
+	return -ENODEV;
+}
+
 static inline int dw_i2c_of_configure(struct platform_device *pdev)
 {
 	return -ENODEV;
@@ -111,10 +176,19 @@ static void dw_i2c_plat_pm_cleanup(struct dw_i2c_dev *dev)
 static int dw_i2c_plat_request_regs(struct dw_i2c_dev *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev->dev);
+	int ret;
 
-	dev->base = devm_platform_ioremap_resource(pdev, 0);
+	switch (dev->flags & MODEL_MASK) {
+	case MODEL_BAIKAL_BT1:
+		ret = bt1_i2c_request_regs(dev);
+		break;
+	default:
+		dev->base = devm_platform_ioremap_resource(pdev, 0);
+		ret = PTR_ERR_OR_ZERO(dev->base);
+		break;
+	}
 
-	return PTR_ERR_OR_ZERO(dev->base);
+	return ret;
 }
 
 static int dw_i2c_plat_probe(struct platform_device *pdev)

commit b7c3d0777808cd7b5cee6078bd0ef51e82bd3db9
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Thu May 28 12:33:20 2020 +0300

    i2c: designware: Move reg-space remapping into a dedicated function
    
    This is a preparation patch before adding a quirk with custom registers
    map creation required for the Baikal-T1 System I2C support.
    
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@kernel.org>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 38657d821c72..9d467fa0e163 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -108,6 +108,15 @@ static void dw_i2c_plat_pm_cleanup(struct dw_i2c_dev *dev)
 		pm_runtime_put_noidle(dev->dev);
 }
 
+static int dw_i2c_plat_request_regs(struct dw_i2c_dev *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev->dev);
+
+	dev->base = devm_platform_ioremap_resource(pdev, 0);
+
+	return PTR_ERR_OR_ZERO(dev->base);
+}
+
 static int dw_i2c_plat_probe(struct platform_device *pdev)
 {
 	struct dw_i2c_platform_data *pdata = dev_get_platdata(&pdev->dev);
@@ -125,15 +134,14 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	dev->flags = (uintptr_t)device_get_match_data(&pdev->dev);
-
-	dev->base = devm_platform_ioremap_resource(pdev, 0);
-	if (IS_ERR(dev->base))
-		return PTR_ERR(dev->base);
-
 	dev->dev = &pdev->dev;
 	dev->irq = irq;
 	platform_set_drvdata(pdev, dev);
 
+	ret = dw_i2c_plat_request_regs(dev);
+	if (ret)
+		return ret;
+
 	dev->rst = devm_reset_control_get_optional_exclusive(&pdev->dev, NULL);
 	if (IS_ERR(dev->rst))
 		return PTR_ERR(dev->rst);

commit fac25d7aaa03c4b5e11c7b7c1e286f85d21e008a
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Thu May 28 12:33:19 2020 +0300

    i2c: designware: Retrieve quirk flags as early as possible
    
    Some platforms might need to activate the driver quirks at a very early
    probe stage. For instance, Baikal-T1 System I2C doesn't need to map the
    registers space as ones belong to the system controller. Instead it will
    request the syscon regmap from the parental DT node. In order to be able
    to do so let's retrieve the model flags right after the DW I2C private
    data is created. While at it replace the or-assignment with just
    assignment operator since or-ing is redundant at this stage.
    
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@kernel.org>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index ca057aa9eac4..38657d821c72 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -124,6 +124,8 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	if (!dev)
 		return -ENOMEM;
 
+	dev->flags = (uintptr_t)device_get_match_data(&pdev->dev);
+
 	dev->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(dev->base))
 		return PTR_ERR(dev->base);
@@ -146,8 +148,6 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 
 	i2c_dw_acpi_adjust_bus_speed(&pdev->dev);
 
-	dev->flags |= (uintptr_t)device_get_match_data(&pdev->dev);
-
 	if (pdev->dev.of_node)
 		dw_i2c_of_configure(pdev);
 

commit c615f5c65f622fb62df17d58485f46a544d6e07a
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Thu May 28 12:33:17 2020 +0300

    i2c: designware: Discard Cherry Trail model flag
    
    A PM workaround activated by the flag MODEL_CHERRYTRAIL has been removed
    since commit 9cbeeca05049 ("i2c: designware: Remove Cherry Trail PMIC I2C
    bus pm_disabled workaround"), but the flag most likely by mistake has been
    left in the Dw I2C drivers. Let's remove it. Since MODEL_MSCC_OCELOT is
    the only model-flag left, redefine it to be 0x100 so setting a very first
    bit in the MODEL_MASK bits range.
    
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@kernel.org>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index f6d2c96e35ce..ca057aa9eac4 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -44,7 +44,7 @@ static const struct acpi_device_id dw_i2c_acpi_match[] = {
 	{ "INT3432", 0 },
 	{ "INT3433", 0 },
 	{ "80860F41", ACCESS_NO_IRQ_SUSPEND },
-	{ "808622C1", ACCESS_NO_IRQ_SUSPEND | MODEL_CHERRYTRAIL },
+	{ "808622C1", ACCESS_NO_IRQ_SUSPEND },
 	{ "AMD0010", ACCESS_INTR_MASK },
 	{ "AMDI0010", ACCESS_INTR_MASK },
 	{ "AMDI0510", 0 },

commit f9288fcc5c6154959de4dd83be1b91abcf5e0c17
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue May 19 15:50:41 2020 +0300

    i2c: designware: Move ACPI parts into common module
    
    For possible code reuse in the future, move ACPI parts into common module.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@kernel.org>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index d6c03d7179c7..f6d2c96e35ce 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -12,7 +12,6 @@
 #include <linux/clk-provider.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
-#include <linux/dmi.h>
 #include <linux/err.h>
 #include <linux/errno.h>
 #include <linux/i2c.h>
@@ -39,84 +38,6 @@ static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
 }
 
 #ifdef CONFIG_ACPI
-/*
- * The HCNT/LCNT information coming from ACPI should be the most accurate
- * for given platform. However, some systems get it wrong. On such systems
- * we get better results by calculating those based on the input clock.
- */
-static const struct dmi_system_id dw_i2c_no_acpi_params[] = {
-	{
-		.ident = "Dell Inspiron 7348",
-		.matches = {
-			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
-			DMI_MATCH(DMI_PRODUCT_NAME, "Inspiron 7348"),
-		},
-	},
-	{ }
-};
-
-static void dw_i2c_acpi_params(struct platform_device *pdev, char method[],
-			       u16 *hcnt, u16 *lcnt, u32 *sda_hold)
-{
-	struct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };
-	acpi_handle handle = ACPI_HANDLE(&pdev->dev);
-	union acpi_object *obj;
-
-	if (dmi_check_system(dw_i2c_no_acpi_params))
-		return;
-
-	if (ACPI_FAILURE(acpi_evaluate_object(handle, method, NULL, &buf)))
-		return;
-
-	obj = (union acpi_object *)buf.pointer;
-	if (obj->type == ACPI_TYPE_PACKAGE && obj->package.count == 3) {
-		const union acpi_object *objs = obj->package.elements;
-
-		*hcnt = (u16)objs[0].integer.value;
-		*lcnt = (u16)objs[1].integer.value;
-		*sda_hold = (u32)objs[2].integer.value;
-	}
-
-	kfree(buf.pointer);
-}
-
-static int dw_i2c_acpi_configure(struct platform_device *pdev)
-{
-	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
-	struct i2c_timings *t = &dev->timings;
-	u32 ss_ht = 0, fp_ht = 0, hs_ht = 0, fs_ht = 0;
-
-	dev->tx_fifo_depth = 32;
-	dev->rx_fifo_depth = 32;
-
-	/*
-	 * Try to get SDA hold time and *CNT values from an ACPI method for
-	 * selected speed modes.
-	 */
-	dw_i2c_acpi_params(pdev, "SSCN", &dev->ss_hcnt, &dev->ss_lcnt, &ss_ht);
-	dw_i2c_acpi_params(pdev, "FPCN", &dev->fp_hcnt, &dev->fp_lcnt, &fp_ht);
-	dw_i2c_acpi_params(pdev, "HSCN", &dev->hs_hcnt, &dev->hs_lcnt, &hs_ht);
-	dw_i2c_acpi_params(pdev, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt, &fs_ht);
-
-	switch (t->bus_freq_hz) {
-	case I2C_MAX_STANDARD_MODE_FREQ:
-		dev->sda_hold_time = ss_ht;
-		break;
-	case I2C_MAX_FAST_MODE_PLUS_FREQ:
-		dev->sda_hold_time = fp_ht;
-		break;
-	case I2C_MAX_HIGH_SPEED_MODE_FREQ:
-		dev->sda_hold_time = hs_ht;
-		break;
-	case I2C_MAX_FAST_MODE_FREQ:
-	default:
-		dev->sda_hold_time = fs_ht;
-		break;
-	}
-
-	return 0;
-}
-
 static const struct acpi_device_id dw_i2c_acpi_match[] = {
 	{ "INT33C2", 0 },
 	{ "INT33C3", 0 },
@@ -134,11 +55,6 @@ static const struct acpi_device_id dw_i2c_acpi_match[] = {
 	{ }
 };
 MODULE_DEVICE_TABLE(acpi, dw_i2c_acpi_match);
-#else
-static inline int dw_i2c_acpi_configure(struct platform_device *pdev)
-{
-	return -ENODEV;
-}
 #endif
 
 #ifdef CONFIG_OF
@@ -198,8 +114,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	struct i2c_adapter *adap;
 	struct dw_i2c_dev *dev;
 	struct i2c_timings *t;
-	u32 acpi_speed;
-	int i, irq, ret;
+	int irq, ret;
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
@@ -229,27 +144,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	else
 		i2c_parse_fw_timings(&pdev->dev, t, false);
 
-	acpi_speed = i2c_acpi_find_bus_speed(&pdev->dev);
-	/*
-	 * Some DSTDs use a non standard speed, round down to the lowest
-	 * standard speed.
-	 */
-	for (i = 0; i < ARRAY_SIZE(i2c_dw_supported_speeds); i++) {
-		if (acpi_speed >= i2c_dw_supported_speeds[i])
-			break;
-	}
-	acpi_speed = i < ARRAY_SIZE(i2c_dw_supported_speeds) ? i2c_dw_supported_speeds[i] : 0;
-
-	/*
-	 * Find bus speed from the "clock-frequency" device property, ACPI
-	 * or by using fast mode if neither is set.
-	 */
-	if (acpi_speed && t->bus_freq_hz)
-		t->bus_freq_hz = min(t->bus_freq_hz, acpi_speed);
-	else if (acpi_speed || t->bus_freq_hz)
-		t->bus_freq_hz = max(t->bus_freq_hz, acpi_speed);
-	else
-		t->bus_freq_hz = I2C_MAX_FAST_MODE_FREQ;
+	i2c_dw_acpi_adjust_bus_speed(&pdev->dev);
 
 	dev->flags |= (uintptr_t)device_get_match_data(&pdev->dev);
 
@@ -257,7 +152,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 		dw_i2c_of_configure(pdev);
 
 	if (has_acpi_companion(&pdev->dev))
-		dw_i2c_acpi_configure(pdev);
+		i2c_dw_acpi_configure(&pdev->dev);
 
 	ret = i2c_dw_validate_speed(dev);
 	if (ret)

commit 20ee1d9020c9233129ba84094e7dd6fe4651cfad
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue May 19 15:50:39 2020 +0300

    i2c: designware: Move i2c_dw_validate_speed() helper to a common code
    
    In order to export array supported speed for wider use, move it
    to a header along with i2c_dw_validate_speed() helper moved to
    a common code.
    
    No functional changes intended.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@kernel.org>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 01db634461b6..d6c03d7179c7 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -192,13 +192,6 @@ static void dw_i2c_plat_pm_cleanup(struct dw_i2c_dev *dev)
 		pm_runtime_put_noidle(dev->dev);
 }
 
-static const u32 supported_speeds[] = {
-	I2C_MAX_HIGH_SPEED_MODE_FREQ,
-	I2C_MAX_FAST_MODE_PLUS_FREQ,
-	I2C_MAX_FAST_MODE_FREQ,
-	I2C_MAX_STANDARD_MODE_FREQ,
-};
-
 static int dw_i2c_plat_probe(struct platform_device *pdev)
 {
 	struct dw_i2c_platform_data *pdata = dev_get_platdata(&pdev->dev);
@@ -241,11 +234,11 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	 * Some DSTDs use a non standard speed, round down to the lowest
 	 * standard speed.
 	 */
-	for (i = 0; i < ARRAY_SIZE(supported_speeds); i++) {
-		if (acpi_speed >= supported_speeds[i])
+	for (i = 0; i < ARRAY_SIZE(i2c_dw_supported_speeds); i++) {
+		if (acpi_speed >= i2c_dw_supported_speeds[i])
 			break;
 	}
-	acpi_speed = i < ARRAY_SIZE(supported_speeds) ? supported_speeds[i] : 0;
+	acpi_speed = i < ARRAY_SIZE(i2c_dw_supported_speeds) ? i2c_dw_supported_speeds[i] : 0;
 
 	/*
 	 * Find bus speed from the "clock-frequency" device property, ACPI
@@ -266,21 +259,9 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	if (has_acpi_companion(&pdev->dev))
 		dw_i2c_acpi_configure(pdev);
 
-	/*
-	 * Only standard mode at 100kHz, fast mode at 400kHz,
-	 * fast mode plus at 1MHz and high speed mode at 3.4MHz are supported.
-	 */
-	for (i = 0; i < ARRAY_SIZE(supported_speeds); i++) {
-		if (t->bus_freq_hz == supported_speeds[i])
-			break;
-	}
-	if (i == ARRAY_SIZE(supported_speeds)) {
-		dev_err(&pdev->dev,
-			"%d Hz is unsupported, only 100kHz, 400kHz, 1MHz and 3.4MHz are supported\n",
-			t->bus_freq_hz);
-		ret = -EINVAL;
+	ret = i2c_dw_validate_speed(dev);
+	if (ret)
 		goto exit_reset;
-	}
 
 	ret = i2c_dw_probe_lock_support(dev);
 	if (ret)

commit f89c326dcaa0cb8c3af7764e75eeed4e3f3c879a
Merge: 6fe12cdbcfe3 efa7fb4c6c8e
Author: Wolfram Sang <wsa@kernel.org>
Date:   Wed May 20 15:27:45 2020 +0200

    Merge branch 'i2c/for-current-fixed' into i2c/for-5.8

commit bed20c84021eb6dfc9df1590d8e231895b0392aa
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Sat Apr 25 16:44:47 2020 +0300

    i2c: designware: Rename i2c_dw_probe() to i2c_dw_probe_master()
    
    As a preparatory patch to support slave mode for PCI enumerated devices rename
    i2c_dw_probe() to i2c_dw_probe_master() and split common i2c_dw_probe() as
    inline helper.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@kernel.org>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 8ca5d0f7672d..c6f04449036a 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -331,11 +331,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 
 	pm_runtime_enable(&pdev->dev);
 
-	if (dev->mode == DW_IC_SLAVE)
-		ret = i2c_dw_probe_slave(dev);
-	else
-		ret = i2c_dw_probe(dev);
-
+	ret = i2c_dw_probe(dev);
 	if (ret)
 		goto exit_probe;
 

commit 3ebe40ed1c39016eeae947acc9fd57d6b10d43b2
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Sat Apr 25 16:44:45 2020 +0300

    i2c: designware: Move configuration routines to respective modules
    
    Move configuration routines to respective modules, i.e. master and slave.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@kernel.org>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index f5d57b8865ef..8ca5d0f7672d 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -184,39 +184,6 @@ static inline int dw_i2c_of_configure(struct platform_device *pdev)
 }
 #endif
 
-static void i2c_dw_configure_master(struct dw_i2c_dev *dev)
-{
-	struct i2c_timings *t = &dev->timings;
-
-	dev->functionality = I2C_FUNC_10BIT_ADDR | DW_IC_DEFAULT_FUNCTIONALITY;
-
-	dev->master_cfg = DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
-			  DW_IC_CON_RESTART_EN;
-
-	dev->mode = DW_IC_MASTER;
-
-	switch (t->bus_freq_hz) {
-	case I2C_MAX_STANDARD_MODE_FREQ:
-		dev->master_cfg |= DW_IC_CON_SPEED_STD;
-		break;
-	case I2C_MAX_HIGH_SPEED_MODE_FREQ:
-		dev->master_cfg |= DW_IC_CON_SPEED_HIGH;
-		break;
-	default:
-		dev->master_cfg |= DW_IC_CON_SPEED_FAST;
-	}
-}
-
-static void i2c_dw_configure_slave(struct dw_i2c_dev *dev)
-{
-	dev->functionality = I2C_FUNC_SLAVE | DW_IC_DEFAULT_FUNCTIONALITY;
-
-	dev->slave_cfg = DW_IC_CON_RX_FIFO_FULL_HLD_CTRL |
-			 DW_IC_CON_RESTART_EN | DW_IC_CON_STOP_DET_IFADDRESSED;
-
-	dev->mode = DW_IC_SLAVE;
-}
-
 static void dw_i2c_plat_pm_cleanup(struct dw_i2c_dev *dev)
 {
 	pm_runtime_disable(dev->dev);
@@ -319,10 +286,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	if (ret)
 		goto exit_reset;
 
-	if (i2c_detect_slave_mode(&pdev->dev))
-		i2c_dw_configure_slave(dev);
-	else
-		i2c_dw_configure_master(dev);
+	i2c_dw_configure(dev);
 
 	/* Optional interface clock */
 	dev->pclk = devm_clk_get_optional(&pdev->dev, "pclk");

commit 188fe480cd65c53dca02a464d62be02ca3158290
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Sat Apr 25 16:44:44 2020 +0300

    i2c: designware: Use devm_platform_ioremap_resource() to simplify code
    
    Use devm_platform_ioremap_resource() instead of
    platform_get_resource() + devm_ioremap_resource().
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@kernel.org>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index c98befe2a92e..f5d57b8865ef 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -157,12 +157,10 @@ static int mscc_twi_set_sda_hold_time(struct dw_i2c_dev *dev)
 static int dw_i2c_of_configure(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
-	struct resource *mem;
 
 	switch (dev->flags & MODEL_MASK) {
 	case MODEL_MSCC_OCELOT:
-		mem = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-		dev->ext = devm_ioremap_resource(&pdev->dev, mem);
+		dev->ext = devm_platform_ioremap_resource(pdev, 1);
 		if (!IS_ERR(dev->ext))
 			dev->set_sda_hold_time = mscc_twi_set_sda_hold_time;
 		break;
@@ -241,7 +239,6 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	struct dw_i2c_dev *dev;
 	struct i2c_timings *t;
 	u32 acpi_speed;
-	struct resource *mem;
 	int i, irq, ret;
 
 	irq = platform_get_irq(pdev, 0);
@@ -252,8 +249,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	if (!dev)
 		return -ENOMEM;
 
-	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	dev->base = devm_ioremap_resource(&pdev->dev, mem);
+	dev->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(dev->base))
 		return PTR_ERR(dev->base);
 

commit 2a3f34750b8b07df42ab4b30b70e029d46e0d7f3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Apr 18 18:53:20 2020 +0200

    PM: sleep: core: Rename DPM_FLAG_LEAVE_SUSPENDED
    
    Rename DPM_FLAG_LEAVE_SUSPENDED to DPM_FLAG_MAY_SKIP_RESUME which
    matches its purpose more closely.
    
    No functional impact.
    
    Suggested-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Wolfram Sang <wsa@the-dreams.de> # for I2C
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 5536673060cc..c429d664f655 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -357,12 +357,12 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	if (dev->flags & ACCESS_NO_IRQ_SUSPEND) {
 		dev_pm_set_driver_flags(&pdev->dev,
 					DPM_FLAG_SMART_PREPARE |
-					DPM_FLAG_LEAVE_SUSPENDED);
+					DPM_FLAG_MAY_SKIP_RESUME);
 	} else {
 		dev_pm_set_driver_flags(&pdev->dev,
 					DPM_FLAG_SMART_PREPARE |
 					DPM_FLAG_SMART_SUSPEND |
-					DPM_FLAG_LEAVE_SUSPENDED);
+					DPM_FLAG_MAY_SKIP_RESUME);
 	}
 
 	/* The code below assumes runtime PM to be disabled. */

commit d79294d0de12ddd1420110813626d691f440b86f
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Apr 7 20:11:16 2020 +0200

    i2c: designware: platdrv: Remove DPM_FLAG_SMART_SUSPEND flag on BYT and CHT
    
    We already set DPM_FLAG_SMART_PREPARE, so we completely skip all
    callbacks (other then prepare) where possible, quoting from
    dw_i2c_plat_prepare():
    
            /*
             * If the ACPI companion device object is present for this device, it
             * may be accessed during suspend and resume of other devices via I2C
             * operation regions, so tell the PM core and middle layers to avoid
             * skipping system suspend/resume callbacks for it in that case.
             */
            return !has_acpi_companion(dev);
    
    Also setting the DPM_FLAG_SMART_SUSPEND will cause acpi_subsys_suspend()
    to leave the controller runtime-suspended even if dw_i2c_plat_prepare()
    returned 0.
    
    Leaving the controller runtime-suspended normally, when the I2C controller
    is suspended during the suspend_late phase, is not an issue because
    the pm_runtime_get_sync() done by i2c_dw_xfer() will (runtime-)resume it.
    
    But for dw I2C controllers on Bay- and Cherry-Trail devices acpi_lpss.c
    leaves the controller alive until the suspend_noirq phase, because it may
    be used by the _PS3 ACPI methods of PCI devices and PCI devices are left
    powered on until the suspend_noirq phase.
    
    Between the suspend_late and resume_early phases runtime-pm is disabled.
    So for any ACPI I2C OPRegion accesses done after the suspend_late phase,
    the pm_runtime_get_sync() done by i2c_dw_xfer() is a no-op and the
    controller is left runtime-suspended.
    
    i2c_dw_xfer() has a check to catch this condition (rather then waiting
    for the I2C transfer to timeout because the controller is suspended).
    acpi_subsys_suspend() leaving the controller runtime-suspended in
    combination with an ACPI I2C OPRegion access done after the suspend_late
    phase triggers this check, leading to the following error being logged
    on a Bay Trail based Lenovo Thinkpad 8 tablet:
    
    [   93.275882] i2c_designware 80860F41:00: Transfer while suspended
    [   93.275993] WARNING: CPU: 0 PID: 412 at drivers/i2c/busses/i2c-designware-master.c:429 i2c_dw_xfer+0x239/0x280
    ...
    [   93.276252] Workqueue: kacpi_notify acpi_os_execute_deferred
    [   93.276267] RIP: 0010:i2c_dw_xfer+0x239/0x280
    ...
    [   93.276340] Call Trace:
    [   93.276366]  __i2c_transfer+0x121/0x520
    [   93.276379]  i2c_transfer+0x4c/0x100
    [   93.276392]  i2c_acpi_space_handler+0x219/0x510
    [   93.276408]  ? up+0x40/0x60
    [   93.276419]  ? i2c_acpi_notify+0x130/0x130
    [   93.276433]  acpi_ev_address_space_dispatch+0x1e1/0x252
    ...
    
    So since on BYT and CHT platforms we want ACPI I2c OPRegion accesses
    to work until the suspend_noirq phase, we need the controller to be
    runtime-resumed during the suspend phase if it is runtime-suspended
    suspended at that time. This means that we must not set the
    DPM_FLAG_SMART_SUSPEND on these platforms.
    
    On BYT and CHT we already have a special ACCESS_NO_IRQ_SUSPEND flag
    to make sure the controller stays functional until the suspend_noirq
    phase. This commit makes the driver not set the DPM_FLAG_SMART_SUSPEND
    flag when that flag is set.
    
    Cc: stable@vger.kernel.org
    Fixes: b30f2f65568f ("i2c: designware: Set IRQF_NO_SUSPEND flag for all BYT and CHT controllers")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index c98befe2a92e..5536673060cc 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -354,10 +354,16 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	adap->dev.of_node = pdev->dev.of_node;
 	adap->nr = -1;
 
-	dev_pm_set_driver_flags(&pdev->dev,
-				DPM_FLAG_SMART_PREPARE |
-				DPM_FLAG_SMART_SUSPEND |
-				DPM_FLAG_LEAVE_SUSPENDED);
+	if (dev->flags & ACCESS_NO_IRQ_SUSPEND) {
+		dev_pm_set_driver_flags(&pdev->dev,
+					DPM_FLAG_SMART_PREPARE |
+					DPM_FLAG_LEAVE_SUSPENDED);
+	} else {
+		dev_pm_set_driver_flags(&pdev->dev,
+					DPM_FLAG_SMART_PREPARE |
+					DPM_FLAG_SMART_SUSPEND |
+					DPM_FLAG_LEAVE_SUSPENDED);
+	}
 
 	/* The code below assumes runtime PM to be disabled. */
 	WARN_ON(pm_runtime_enabled(&pdev->dev));

commit 90224e6468e15d5eb22a10ae1849cf8ca2e7360a
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Mar 24 14:32:16 2020 +0200

    i2c: drivers: Use generic definitions for bus frequencies
    
    Since we have generic definitions for bus frequencies, let's use them.
    
    Reviewed-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Acked-by: Robert Richter <rrichter@marvell.com>
    Reviewed-by: Thor Thayer <thor.thayer@linux.intel.com>
    Acked-by: Elie Morisse <syniurge@gmail.com>
    Acked-by: Nehal Shah <nehal-bakulchandra.shah@amd.com>
    Reviewed-by: Brendan Higgins <brendanhiggins@google.com>
    Acked-by: Scott Branden <scott.branden@broadcom.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Baruch Siach <baruch@tkos.co.il>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Oleksij Rempel <o.rempel@pengutronix.de>
    Acked-by: Vladimir Zapolskiy <vz@mleia.com>
    Acked-by: Gregory CLEMENT <gregory.clement@bootlin.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
    Reviewed-by: Chris Brandt <chris.brandt@renesas.com>
    Reviewed-by: Baolin Wang <baolin.wang7@gmail.com>
    Reviewed-by: Pierre-Yves MORDRET <pierre-yves.mordret@st.com>
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    Acked-by: Ard Biesheuvel <ardb@kernel.org>
    Reviewed-by: Dmitry Osipenko <digetx@gmail.com>
    Acked-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index cb494273bb60..c98befe2a92e 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -99,16 +99,16 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 	dw_i2c_acpi_params(pdev, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt, &fs_ht);
 
 	switch (t->bus_freq_hz) {
-	case 100000:
+	case I2C_MAX_STANDARD_MODE_FREQ:
 		dev->sda_hold_time = ss_ht;
 		break;
-	case 1000000:
+	case I2C_MAX_FAST_MODE_PLUS_FREQ:
 		dev->sda_hold_time = fp_ht;
 		break;
-	case 3400000:
+	case I2C_MAX_HIGH_SPEED_MODE_FREQ:
 		dev->sda_hold_time = hs_ht;
 		break;
-	case 400000:
+	case I2C_MAX_FAST_MODE_FREQ:
 	default:
 		dev->sda_hold_time = fs_ht;
 		break;
@@ -198,10 +198,10 @@ static void i2c_dw_configure_master(struct dw_i2c_dev *dev)
 	dev->mode = DW_IC_MASTER;
 
 	switch (t->bus_freq_hz) {
-	case 100000:
+	case I2C_MAX_STANDARD_MODE_FREQ:
 		dev->master_cfg |= DW_IC_CON_SPEED_STD;
 		break;
-	case 3400000:
+	case I2C_MAX_HIGH_SPEED_MODE_FREQ:
 		dev->master_cfg |= DW_IC_CON_SPEED_HIGH;
 		break;
 	default:
@@ -227,6 +227,13 @@ static void dw_i2c_plat_pm_cleanup(struct dw_i2c_dev *dev)
 		pm_runtime_put_noidle(dev->dev);
 }
 
+static const u32 supported_speeds[] = {
+	I2C_MAX_HIGH_SPEED_MODE_FREQ,
+	I2C_MAX_FAST_MODE_PLUS_FREQ,
+	I2C_MAX_FAST_MODE_FREQ,
+	I2C_MAX_STANDARD_MODE_FREQ,
+};
+
 static int dw_i2c_plat_probe(struct platform_device *pdev)
 {
 	struct dw_i2c_platform_data *pdata = dev_get_platdata(&pdev->dev);
@@ -236,9 +243,6 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	u32 acpi_speed;
 	struct resource *mem;
 	int i, irq, ret;
-	static const int supported_speeds[] = {
-		0, 100000, 400000, 1000000, 3400000
-	};
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
@@ -274,11 +278,11 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	 * Some DSTDs use a non standard speed, round down to the lowest
 	 * standard speed.
 	 */
-	for (i = 1; i < ARRAY_SIZE(supported_speeds); i++) {
-		if (acpi_speed < supported_speeds[i])
+	for (i = 0; i < ARRAY_SIZE(supported_speeds); i++) {
+		if (acpi_speed >= supported_speeds[i])
 			break;
 	}
-	acpi_speed = supported_speeds[i - 1];
+	acpi_speed = i < ARRAY_SIZE(supported_speeds) ? supported_speeds[i] : 0;
 
 	/*
 	 * Find bus speed from the "clock-frequency" device property, ACPI
@@ -289,7 +293,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	else if (acpi_speed || t->bus_freq_hz)
 		t->bus_freq_hz = max(t->bus_freq_hz, acpi_speed);
 	else
-		t->bus_freq_hz = 400000;
+		t->bus_freq_hz = I2C_MAX_FAST_MODE_FREQ;
 
 	dev->flags |= (uintptr_t)device_get_match_data(&pdev->dev);
 
@@ -303,8 +307,11 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	 * Only standard mode at 100kHz, fast mode at 400kHz,
 	 * fast mode plus at 1MHz and high speed mode at 3.4MHz are supported.
 	 */
-	if (t->bus_freq_hz != 100000 && t->bus_freq_hz != 400000 &&
-	    t->bus_freq_hz != 1000000 && t->bus_freq_hz != 3400000) {
+	for (i = 0; i < ARRAY_SIZE(supported_speeds); i++) {
+		if (t->bus_freq_hz == supported_speeds[i])
+			break;
+	}
+	if (i == ARRAY_SIZE(supported_speeds)) {
 		dev_err(&pdev->dev,
 			"%d Hz is unsupported, only 100kHz, 400kHz, 1MHz and 3.4MHz are supported\n",
 			t->bus_freq_hz);

commit 1f1a714658307a1a5ec65b0a23d87a87da64c86f
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Fri Mar 6 16:19:54 2020 +0300

    i2c: designware: Detect the FIFO size in the common code
    
    The problem with detecting the FIFO depth in the platform driver
    is that in order to implement this we have to access the controller
    IC_COMP_PARAM_1 register. Currently it's done before the
    i2c_dw_set_reg_access() method execution, which is errors prone since
    the method determines the registers endianness and access mode and we
    can't use dw_readl/dw_writel accessors before this information is
    retrieved. We also can't move the i2c_dw_set_reg_access() function
    invocation to after the master/slave probe functions call (when endianness
    and access mode are determined), since the FIFO depth information is used
    by them for initializations. So in order to fix the problem we have no
    choice but to move the FIFO size detection methods to the common code and
    call it at the probe stage.
    
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Signed-off-by: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 3b7d58c2fe85..cb494273bb60 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -219,28 +219,6 @@ static void i2c_dw_configure_slave(struct dw_i2c_dev *dev)
 	dev->mode = DW_IC_SLAVE;
 }
 
-static void dw_i2c_set_fifo_size(struct dw_i2c_dev *dev)
-{
-	u32 param, tx_fifo_depth, rx_fifo_depth;
-
-	/*
-	 * Try to detect the FIFO depth if not set by interface driver,
-	 * the depth could be from 2 to 256 from HW spec.
-	 */
-	param = i2c_dw_read_comp_param(dev);
-	tx_fifo_depth = ((param >> 16) & 0xff) + 1;
-	rx_fifo_depth = ((param >> 8)  & 0xff) + 1;
-	if (!dev->tx_fifo_depth) {
-		dev->tx_fifo_depth = tx_fifo_depth;
-		dev->rx_fifo_depth = rx_fifo_depth;
-	} else if (tx_fifo_depth >= 2) {
-		dev->tx_fifo_depth = min_t(u32, dev->tx_fifo_depth,
-				tx_fifo_depth);
-		dev->rx_fifo_depth = min_t(u32, dev->rx_fifo_depth,
-				rx_fifo_depth);
-	}
-}
-
 static void dw_i2c_plat_pm_cleanup(struct dw_i2c_dev *dev)
 {
 	pm_runtime_disable(dev->dev);
@@ -362,8 +340,6 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 				div_u64(clk_khz * t->sda_hold_ns + 500000, 1000000);
 	}
 
-	dw_i2c_set_fifo_size(dev);
-
 	adap = &dev->adapter;
 	adap->owner = THIS_MODULE;
 	adap->class = I2C_CLASS_DEPRECATED;

commit dec0a81a7814c8a876e663e0627468e6b1a7d2fb
Author: Hanjun Guo <guohanjun@huawei.com>
Date:   Mon Feb 3 09:36:07 2020 +0800

    i2c: designware: Add ACPI HID for Hisilicon Hip08-Lite I2C controller
    
    Add ACPI HID HISI02A3 for Hisilicon Hip08 Lite, which has different
    clock frequency from Hip08 for I2C controller.
    
    Tested-by: Sheng Feng <fengsheng5@huawei.com>
    Signed-off-by: Hanjun Guo <guohanjun@huawei.com>
    Acked-by: Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 16dd338877d0..3b7d58c2fe85 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -130,6 +130,7 @@ static const struct acpi_device_id dw_i2c_acpi_match[] = {
 	{ "APMC0D0F", 0 },
 	{ "HISI02A1", 0 },
 	{ "HISI02A2", 0 },
+	{ "HISI02A3", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(acpi, dw_i2c_acpi_match);

commit a6af48ec0712a0c98d8abe6b47c655b26026fceb
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Aug 19 13:31:30 2019 +0300

    i2c: designware: Fix optional reset error handling
    
    The commit bb475230b8e5 ("reset: make optional functions really optional")
    brought a missed part of the support for an optional reset handlers.
    
    Since that we don't need to have special error handling in the driver.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 4624ef8fbae8..16dd338877d0 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -279,12 +279,10 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, dev);
 
 	dev->rst = devm_reset_control_get_optional_exclusive(&pdev->dev, NULL);
-	if (IS_ERR(dev->rst)) {
-		if (PTR_ERR(dev->rst) == -EPROBE_DEFER)
-			return -EPROBE_DEFER;
-	} else {
-		reset_control_deassert(dev->rst);
-	}
+	if (IS_ERR(dev->rst))
+		return PTR_ERR(dev->rst);
+
+	reset_control_deassert(dev->rst);
 
 	t = &dev->timings;
 	if (pdata)
@@ -402,8 +400,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 exit_probe:
 	dw_i2c_plat_pm_cleanup(dev);
 exit_reset:
-	if (!IS_ERR_OR_NULL(dev->rst))
-		reset_control_assert(dev->rst);
+	reset_control_assert(dev->rst);
 	return ret;
 }
 
@@ -421,8 +418,7 @@ static int dw_i2c_plat_remove(struct platform_device *pdev)
 	pm_runtime_put_sync(&pdev->dev);
 	dw_i2c_plat_pm_cleanup(dev);
 
-	if (!IS_ERR_OR_NULL(dev->rst))
-		reset_control_assert(dev->rst);
+	reset_control_assert(dev->rst);
 
 	return 0;
 }

commit 71dc297ca9ab6311e7d39fc53811fd871d51854f
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Aug 19 13:24:23 2019 +0300

    i2c: designware: assert reset when error happen at ->probe()
    
    The commit c62ebb3d5f0d ("i2c: designware: Add support for an interface clock")
    introduced an optional clock while missed correct error handling.
    assert reset line back if error happen at ->probe().
    
    Fixes: c62ebb3d5f0d ("i2c: designware: Add support for an interface clock")
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index ddfb81872906..4624ef8fbae8 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -346,8 +346,10 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 
 	/* Optional interface clock */
 	dev->pclk = devm_clk_get_optional(&pdev->dev, "pclk");
-	if (IS_ERR(dev->pclk))
-		return PTR_ERR(dev->pclk);
+	if (IS_ERR(dev->pclk)) {
+		ret = PTR_ERR(dev->pclk);
+		goto exit_reset;
+	}
 
 	dev->clk = devm_clk_get(&pdev->dev, NULL);
 	if (!i2c_dw_prepare_clk(dev, true)) {

commit c62ebb3d5f0d0e9dafe990c9ce680ca9b46fd4c1
Author: Phil Edworthy <phil.edworthy@renesas.com>
Date:   Thu Feb 28 13:52:10 2019 +0000

    i2c: designware: Add support for an interface clock
    
    The Synopsys I2C Controller has an interface clock, but most SoCs hide
    this away. However, on some SoCs you need to explicitly enable the
    interface clock in order to access the registers. Therefore, add
    support for an optional interface clock.
    
    Signed-off-by: Phil Edworthy <phil.edworthy@renesas.com>
    Signed-off-by: Gareth Williams <gareth.williams.jx@renesas.com>
    Acked-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 416f89b8f881..ddfb81872906 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -344,6 +344,11 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	else
 		i2c_dw_configure_master(dev);
 
+	/* Optional interface clock */
+	dev->pclk = devm_clk_get_optional(&pdev->dev, "pclk");
+	if (IS_ERR(dev->pclk))
+		return PTR_ERR(dev->pclk);
+
 	dev->clk = devm_clk_get(&pdev->dev, NULL);
 	if (!i2c_dw_prepare_clk(dev, true)) {
 		u64 clk_khz;

commit cd86d1403bb4c80e443d736b2a692cbf68a9f471
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Mar 12 15:55:54 2019 +0100

    i2c: i2c-designware-platdrv: Always use a dynamic adapter number
    
    Before this commit the i2c-designware-platdrv assumes that if the pdev
    has an apci-companion it should use a dynamic adapter-nr and it sets
    adapter->nr to -1, otherwise it will use pdev->id as adapter->nr.
    
    There are 3 ways how platform_device-s to which i2c-designware-platdrv
    will bind can be instantiated:
    
    1) Through of / devicetree
    2) Through ACPI enumeration
    3) Explicitly instantiated through platform_device_create + add
    
    1) In case of devicetree-instantiation the drivers/of code always sets
    pdev->id to PLATFORM_DEVID_NONE, which is -1 so in this case both paths
    to set adapter->nr end up doing the same thing.
    
    2) In case of ACPI instantiation the device will always have an
    ACPI-companion, so we are already using dynamic adapter-nrs.
    
    3) There are 2 places manually instantiating a designware_i2c platform_dev:
    drivers/mfd/intel_quark_i2c_gpio.c
    drivers/mfd/intel-lpss.c
    
    In the intel_quark_i2c_gpio.c case pdev->id is always 0, so switching to
    dynamic adapter-nrs here could lead to the bus-number no longer being
    stable, but the quark X1000 only has 1 i2c-controller, which will also
    be assigned bus-number 0 when using dynamic adapter-nrs.
    
    In the intel-lpss.c case intel_lpss_probe() is called from either
    intel-lpss-acpi.c in which case there always is an ACPI-companion, or
    from intel-lpss-pci.c. In most cases devices handled by intel-lpss-pci.c
    also have an ACPI-companion, so we use a dynamic adapter-nr. But in some
    cases the ACPI-companion is missing and we would use pdev->id (allocated
    from intel_lpss_devid_ida). Devices which use the intel-lpss-pci.c code
    typically have many i2c busses, so using pdev->id in this case may lead
    to a bus-number conflict, triggering a WARN(id < 0, "couldn't get idr")
    in i2c-core-base.c causing an oops an the adapter registration to fail.
    So in this case using non dynamic adapter-nrs is actually undesirable.
    
    One machine on which this oops was triggering is the Apollo Lake based
    Acer TravelMate Spin B118.
    
    TL;DR: Switching to always using dynamic adapter-numbers does not make
    any difference in most cases and in the one case where it does make a
    difference the behavior change is desirable because the old behavior
    caused an oops.
    
    BugLink: https://bugzilla.redhat.com/show_bug.cgi?id=1687065
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 30529839cbd2..416f89b8f881 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -363,10 +363,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	adap->class = I2C_CLASS_DEPRECATED;
 	ACPI_COMPANION_SET(&adap->dev, ACPI_COMPANION(&pdev->dev));
 	adap->dev.of_node = pdev->dev.of_node;
-	if (has_acpi_companion(&pdev->dev))
-		adap->nr = -1;
-	else
-		adap->nr = pdev->id;
+	adap->nr = -1;
 
 	dev_pm_set_driver_flags(&pdev->dev,
 				DPM_FLAG_SMART_PREPARE |

commit 77f3381a83c2f66daeb6719a1191a87280d57f62
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Mar 12 15:55:53 2019 +0100

    i2c: i2c-designware-platdrv: Cleanup setting of the adapter number
    
    i2c-designware-platdrv assumes that if the pdev has an apci-companion
    it should use a dynamic adapter-nr and otherwise it will use pdev->id
    as adapter-nr.
    
    Before this commit the setting of the adapter.nr was somewhat convoluted,
    in the acpi_companion case it was set from dw_i2c_acpi_configure, in the
    non acpi_companion case it was set from dw_i2c_set_fifo_size based on
    tx_fifo_depth not being set yet indicating that dw_i2c_acpi_configure was
    not executed.
    
    This cleans this up, directly setting the adapter-nr from
    dw_i2c_plat_probe for both cases.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index ead5e7de3e4d..30529839cbd2 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -86,7 +86,6 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 	struct i2c_timings *t = &dev->timings;
 	u32 ss_ht = 0, fp_ht = 0, hs_ht = 0, fs_ht = 0;
 
-	dev->adapter.nr = -1;
 	dev->tx_fifo_depth = 32;
 	dev->rx_fifo_depth = 32;
 
@@ -219,7 +218,7 @@ static void i2c_dw_configure_slave(struct dw_i2c_dev *dev)
 	dev->mode = DW_IC_SLAVE;
 }
 
-static void dw_i2c_set_fifo_size(struct dw_i2c_dev *dev, int id)
+static void dw_i2c_set_fifo_size(struct dw_i2c_dev *dev)
 {
 	u32 param, tx_fifo_depth, rx_fifo_depth;
 
@@ -233,7 +232,6 @@ static void dw_i2c_set_fifo_size(struct dw_i2c_dev *dev, int id)
 	if (!dev->tx_fifo_depth) {
 		dev->tx_fifo_depth = tx_fifo_depth;
 		dev->rx_fifo_depth = rx_fifo_depth;
-		dev->adapter.nr = id;
 	} else if (tx_fifo_depth >= 2) {
 		dev->tx_fifo_depth = min_t(u32, dev->tx_fifo_depth,
 				tx_fifo_depth);
@@ -358,13 +356,17 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 				div_u64(clk_khz * t->sda_hold_ns + 500000, 1000000);
 	}
 
-	dw_i2c_set_fifo_size(dev, pdev->id);
+	dw_i2c_set_fifo_size(dev);
 
 	adap = &dev->adapter;
 	adap->owner = THIS_MODULE;
 	adap->class = I2C_CLASS_DEPRECATED;
 	ACPI_COMPANION_SET(&adap->dev, ACPI_COMPANION(&pdev->dev));
 	adap->dev.of_node = pdev->dev.of_node;
+	if (has_acpi_companion(&pdev->dev))
+		adap->nr = -1;
+	else
+		adap->nr = pdev->id;
 
 	dev_pm_set_driver_flags(&pdev->dev,
 				DPM_FLAG_SMART_PREPARE |

commit 2751541555382dfa7661bcfaac3ee0fac49f505d
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Feb 22 14:08:40 2019 +0100

    i2c: designware: Do not allow i2c_dw_xfer() calls while suspended
    
    On most Intel Bay- and Cherry-Trail systems the PMIC is connected over I2C
    and the PMIC is accessed through various means by the _PS0 and _PS3 ACPI
    methods (power on / off methods) of various devices.
    
    This leads to suspend/resume ordering problems where a device may be
    resumed and get its _PS0 method executed before the I2C controller is
    resumed. On Cherry Trail this leads to errors like these:
    
         i2c_designware 808622C1:06: controller timed out
         ACPI Error: AE_ERROR, Returned by Handler for [UserDefinedRegion]
         ACPI Error: Method parse/execution failed \_SB.P18W._ON, AE_ERROR
         video LNXVIDEO:00: Failed to change power state to D0
    
    But on Bay Trail this caused I2C reads to seem to succeed, but they end
    up returning wrong data, which ends up getting written back by the typical
    read-modify-write cycle done to turn on various power-resources.
    
    Debugging the problems caused by this silent data corruption is quite
    nasty. This commit adds a check which disallows i2c_dw_xfer() calls to
    happen until the controller's resume method has completed.
    
    Which turns the silent data corruption into getting these errors in
    dmesg instead:
    
        i2c_designware 80860F41:04: Error i2c_dw_xfer call while suspended
        ACPI Error: AE_ERROR, Returned by Handler for [UserDefinedRegion]
        ACPI Error: Method parse/execution failed \_SB.PCI0.GFX0._PS0, AE_ERROR
    
    Which is much better.
    
    Note the above errors are an example of issues which this patch will
    help to debug, the actual fix requires fixing the suspend order and
    this has been fixed by a different commit.
    
    Note the setting / clearing of the suspended flag in the suspend / resume
    methods is NOT protected by i2c_lock_bus(). This is intentional as these
    methods get called from i2c_dw_xfer() (through pm_runtime_get/put) a nd
    i2c_dw_xfer() is called with the i2c_bus_lock held, so otherwise we would
    deadlock. This means that there is a theoretical race between a non runtime
    suspend and the suspended check in i2c_dw_xfer(), this is not a problem
    since normally we should not hit the race and this check is primarily a
    debugging tool so hitting the check if there are suspend/resume ordering
    problems does not need to be 100% reliable.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 9eaac3be1f63..ead5e7de3e4d 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -454,6 +454,8 @@ static int dw_i2c_plat_suspend(struct device *dev)
 {
 	struct dw_i2c_dev *i_dev = dev_get_drvdata(dev);
 
+	i_dev->suspended = true;
+
 	if (i_dev->shared_with_punit)
 		return 0;
 
@@ -471,6 +473,7 @@ static int dw_i2c_plat_resume(struct device *dev)
 		i2c_dw_prepare_clk(i_dev, true);
 
 	i_dev->init(i_dev);
+	i_dev->suspended = false;
 
 	return 0;
 }

commit c2101d01826480755f2bd9f3dd5e36757be61e23
Merge: 6ef746769ef5 6a9b593d4b6f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 30 09:15:31 2018 -0700

    Merge tag 'acpi-4.20-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more ACPI updates from Rafael Wysocki:
     "Rework the handling of the P-unit semaphore on Intel Baytrail and
      Cherrytrail systems to avoid race conditions and excessive overhead
      related to it (Hans de Goede)"
    
    * tag 'acpi-4.20-rc1-2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      ACPI / PMIC: xpower: Add depends on IOSF_MBI to Kconfig entry
      i2c: designware: Cleanup bus lock handling
      ACPI / PMIC: xpower: Block P-Unit I2C access during read-modify-write
      x86: baytrail/cherrytrail: Rework and move P-Unit PMIC bus semaphore code

commit 8afb46804dfa88bb86d65e13f3209372f3d912e3
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Oct 11 16:29:11 2018 +0200

    i2c: designware: Cleanup bus lock handling
    
    Now that most of the special Bay- / Cherry-Trail bus lock handling has
    been moved to the iosf_mbi code we can simplify the remaining code a bit.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index b5750fd85125..a14fb5f933ac 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -388,8 +388,6 @@ static int dw_i2c_plat_remove(struct platform_device *pdev)
 	if (!IS_ERR_OR_NULL(dev->rst))
 		reset_control_assert(dev->rst);
 
-	i2c_dw_remove_lock_support(dev);
-
 	return 0;
 }
 

commit b30f2f65568f840e5ca522d98ba2ad73b8f59cde
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Oct 6 10:25:39 2018 +0200

    i2c: designware: Set IRQF_NO_SUSPEND flag for all BYT and CHT controllers
    
    On some Cherry Trail systems the GPU ACPI fwnode has power-resources which
    point to the PMIC, which is connected over a LPSS I2C controller. The GPU
    is a PCI device and PCI devices are powered-on at the resume_noirq resume
    phase.
    
    Since the GPU power-resources need the I2C controller, recent acpi_lpss.c
    changes now also power-up the LPSS I2C controllers on BYT and CHT devices
    in the resume_noirq resume phase. But during this phase the IRQ of the
    controller is disabled leading to these errors:
    
     i2c_designware 808622C1:06: controller timed out
     ACPI Error: AE_ERROR, Returned by Handler for [UserDefinedRegion]
     ACPI Error: Method parse/execution failed \_SB.P18W._ON, AE_ERROR
     video LNXVIDEO:00: Failed to change power state to D0
    
    This commit makes the i2c-designware controller set the IRQF_NO_SUSPEND
    flag when requesting the interrupt on BYT and CHT devices, so that the IRQ
    is left enabled during the noirq phase, fixing this.
    
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 51cb17287c47..997bbb3d925f 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -123,8 +123,8 @@ static const struct acpi_device_id dw_i2c_acpi_match[] = {
 	{ "INT33C3", 0 },
 	{ "INT3432", 0 },
 	{ "INT3433", 0 },
-	{ "80860F41", 0 },
-	{ "808622C1", MODEL_CHERRYTRAIL },
+	{ "80860F41", ACCESS_NO_IRQ_SUSPEND },
+	{ "808622C1", ACCESS_NO_IRQ_SUSPEND | MODEL_CHERRYTRAIL },
 	{ "AMD0010", ACCESS_INTR_MASK },
 	{ "AMDI0010", ACCESS_INTR_MASK },
 	{ "AMDI0510", 0 },

commit 9cbeeca05049b1109e7e445369898b8a88d5ea7b
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Sep 5 21:51:31 2018 +0200

    i2c: designware: Remove Cherry Trail PMIC I2C bus pm_disabled workaround
    
    Commit a3d411fb38c0 ("i2c: designware: Disable pm for PMIC i2c-bus even if
    there is no _SEM method"), always set the pm_disabled flag on the I2C7
    controller, even if its bus was not shared with the PUNIT.
    
    This was a workaround for various suspend/resume issues, after the
    following 2 commits this workaround is no longer necessary:
    
    Commit 541527728341 ("PM: i2c-designware-platdrv: Suspend/resume at the
                         late/early stages")
    Commit e6ce0ce34f65 ("ACPI / LPSS: Add device link for CHT SD card
                         dependency on I2C")
    
    Therefor this commit removes this workaround.
    
    After this commit the pm_disabled flag is only used to indicate that the
    bus is shared with the PUNIT and after other recent changes we no longer
    call dev_pm_syscore_device(dev, true), so we are no longer actually
    disabling (non-runtime) pm, so this commit also renames the flag to
    shared_with_punit to better reflect what it is for.
    
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index a56af235e9a6..51cb17287c47 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -85,9 +85,6 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
 	struct i2c_timings *t = &dev->timings;
 	u32 ss_ht = 0, fp_ht = 0, hs_ht = 0, fs_ht = 0;
-	acpi_handle handle = ACPI_HANDLE(&pdev->dev);
-	struct acpi_device *adev;
-	const char *uid;
 
 	dev->adapter.nr = -1;
 	dev->tx_fifo_depth = 32;
@@ -118,18 +115,6 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 		break;
 	}
 
-	if (acpi_bus_get_device(handle, &adev))
-		return -ENODEV;
-
-	/*
-	 * Cherrytrail I2C7 gets used for the PMIC which gets accessed
-	 * through ACPI opregions during late suspend / early resume
-	 * disable pm for it.
-	 */
-	uid = adev->pnp.unique_id;
-	if ((dev->flags & MODEL_CHERRYTRAIL) && !strcmp(uid, "7"))
-		dev->pm_disabled = true;
-
 	return 0;
 }
 
@@ -261,7 +246,7 @@ static void dw_i2c_plat_pm_cleanup(struct dw_i2c_dev *dev)
 {
 	pm_runtime_disable(dev->dev);
 
-	if (dev->pm_disabled)
+	if (dev->shared_with_punit)
 		pm_runtime_put_noidle(dev->dev);
 }
 
@@ -393,7 +378,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	pm_runtime_use_autosuspend(&pdev->dev);
 	pm_runtime_set_active(&pdev->dev);
 
-	if (dev->pm_disabled)
+	if (dev->shared_with_punit)
 		pm_runtime_get_noresume(&pdev->dev);
 
 	pm_runtime_enable(&pdev->dev);
@@ -471,7 +456,7 @@ static int dw_i2c_plat_suspend(struct device *dev)
 {
 	struct dw_i2c_dev *i_dev = dev_get_drvdata(dev);
 
-	if (i_dev->pm_disabled)
+	if (i_dev->shared_with_punit)
 		return 0;
 
 	i_dev->disable(i_dev);
@@ -484,7 +469,7 @@ static int dw_i2c_plat_resume(struct device *dev)
 {
 	struct dw_i2c_dev *i_dev = dev_get_drvdata(dev);
 
-	if (!i_dev->pm_disabled)
+	if (!i_dev->shared_with_punit)
 		i2c_dw_prepare_clk(i_dev, true);
 
 	i_dev->init(i_dev);

commit 1bb39959623b438d6b7705abfd0538e8ef4f5f0f
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Fri Aug 31 17:11:12 2018 +0200

    i2c: designware: add MSCC Ocelot support
    
    The Microsemi Ocelot I2C controller is a designware IP. It also has a
    second set of registers to allow tweaking SDA hold time and spike
    filtering.
    
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    [wsa: made one function static]
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 723892820e2b..a56af235e9a6 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -157,11 +157,48 @@ static inline int dw_i2c_acpi_configure(struct platform_device *pdev)
 #endif
 
 #ifdef CONFIG_OF
+#define MSCC_ICPU_CFG_TWI_DELAY		0x0
+#define MSCC_ICPU_CFG_TWI_DELAY_ENABLE	BIT(0)
+#define MSCC_ICPU_CFG_TWI_SPIKE_FILTER	0x4
+
+static int mscc_twi_set_sda_hold_time(struct dw_i2c_dev *dev)
+{
+	writel((dev->sda_hold_time << 1) | MSCC_ICPU_CFG_TWI_DELAY_ENABLE,
+	       dev->ext + MSCC_ICPU_CFG_TWI_DELAY);
+
+	return 0;
+}
+
+static int dw_i2c_of_configure(struct platform_device *pdev)
+{
+	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
+	struct resource *mem;
+
+	switch (dev->flags & MODEL_MASK) {
+	case MODEL_MSCC_OCELOT:
+		mem = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+		dev->ext = devm_ioremap_resource(&pdev->dev, mem);
+		if (!IS_ERR(dev->ext))
+			dev->set_sda_hold_time = mscc_twi_set_sda_hold_time;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
 static const struct of_device_id dw_i2c_of_match[] = {
 	{ .compatible = "snps,designware-i2c", },
+	{ .compatible = "mscc,ocelot-i2c", .data = (void *)MODEL_MSCC_OCELOT },
 	{},
 };
 MODULE_DEVICE_TABLE(of, dw_i2c_of_match);
+#else
+static inline int dw_i2c_of_configure(struct platform_device *pdev)
+{
+	return -ENODEV;
+}
 #endif
 
 static void i2c_dw_configure_master(struct dw_i2c_dev *dev)
@@ -296,6 +333,9 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 
 	dev->flags |= (uintptr_t)device_get_match_data(&pdev->dev);
 
+	if (pdev->dev.of_node)
+		dw_i2c_of_configure(pdev);
+
 	if (has_acpi_companion(&pdev->dev))
 		dw_i2c_acpi_configure(pdev);
 

commit 96742775a3c0649b88140803737ffa1915eb4509
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Fri Aug 31 17:11:09 2018 +0200

    i2c: designware: move #ifdef CONFIG_OF to the top
    
    Move the #ifdef CONFIG_OF section to the top of the file, after the ACPI
    section so functions defined there can be used in dw_i2c_plat_probe.
    
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 99012f23fe85..723892820e2b 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -156,6 +156,14 @@ static inline int dw_i2c_acpi_configure(struct platform_device *pdev)
 }
 #endif
 
+#ifdef CONFIG_OF
+static const struct of_device_id dw_i2c_of_match[] = {
+	{ .compatible = "snps,designware-i2c", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, dw_i2c_of_match);
+#endif
+
 static void i2c_dw_configure_master(struct dw_i2c_dev *dev)
 {
 	struct i2c_timings *t = &dev->timings;
@@ -390,14 +398,6 @@ static int dw_i2c_plat_remove(struct platform_device *pdev)
 	return 0;
 }
 
-#ifdef CONFIG_OF
-static const struct of_device_id dw_i2c_of_match[] = {
-	{ .compatible = "snps,designware-i2c", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, dw_i2c_of_match);
-#endif
-
 #ifdef CONFIG_PM_SLEEP
 static int dw_i2c_plat_prepare(struct device *dev)
 {

commit 1732c22abca8f4e2528a4927baf6ffb2e3be58b0
Author: Alexandre Belloni <alexandre.belloni@bootlin.com>
Date:   Fri Aug 31 17:11:08 2018 +0200

    i2c: designware: use generic table matching
    
    Switch to device_get_match_data in probe to match the device specific data
    instead of using the acpi specific function.
    
    Suggested-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index b5750fd85125..99012f23fe85 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -86,7 +86,6 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 	struct i2c_timings *t = &dev->timings;
 	u32 ss_ht = 0, fp_ht = 0, hs_ht = 0, fs_ht = 0;
 	acpi_handle handle = ACPI_HANDLE(&pdev->dev);
-	const struct acpi_device_id *id;
 	struct acpi_device *adev;
 	const char *uid;
 
@@ -119,10 +118,6 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 		break;
 	}
 
-	id = acpi_match_device(pdev->dev.driver->acpi_match_table, &pdev->dev);
-	if (id && id->driver_data)
-		dev->flags |= (u32)id->driver_data;
-
 	if (acpi_bus_get_device(handle, &adev))
 		return -ENODEV;
 
@@ -291,6 +286,8 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	else
 		t->bus_freq_hz = 400000;
 
+	dev->flags |= (uintptr_t)device_get_match_data(&pdev->dev);
+
 	if (has_acpi_companion(&pdev->dev))
 		dw_i2c_acpi_configure(pdev);
 

commit 9d9a152ebaa86a9dede4624919566483c955d0a7
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Wed Aug 29 15:06:31 2018 +0200

    i2c: designware: Re-init controllers with pm_disabled set on resume
    
    On Bay Trail and Cherry Trail devices we set the pm_disabled flag for I2C
    busses which the OS shares with the PUNIT as these need special handling.
    Until now we called dev_pm_syscore_device(dev, true) for I2C controllers
    with this flag set to keep these I2C controllers always on.
    
    After commit 12864ff8545f ("ACPI / LPSS: Avoid PM quirks on suspend and
    resume from hibernation"), this no longer works. This commit modifies
    lpss_iosf_exit_d3_state() to only run if lpss_iosf_enter_d3_state() has ran
    before it, so that it does not run on a resume from hibernate (or from S3).
    
    On these systems the conditions for lpss_iosf_enter_d3_state() to run
    never become true, so lpss_iosf_exit_d3_state() never gets called and
    the 2 LPSS DMA controllers never get forced into D0 mode, instead they
    are left in their default automatic power-on when needed mode.
    
    The not forcing of D0 mode for the DMA controllers enables these systems
    to properly enter S0ix modes, which is a good thing.
    
    But after entering S0ix modes the I2C controller connected to the PMIC
    no longer works, leading to e.g. broken battery monitoring.
    
    The _PS3 method for this I2C controller looks like this:
    
                Method (_PS3, 0, NotSerialized)  // _PS3: Power State 3
                {
                    If ((((PMID == 0x04) || (PMID == 0x05)) || (PMID == 0x06)))
                    {
                        Return (Zero)
                    }
    
                    PSAT |= 0x03
                    Local0 = PSAT /* \_SB_.I2C5.PSAT */
                }
    
    Where PMID = 0x05, so we enter the Return (Zero) path on these systems.
    
    So even if we were to not call dev_pm_syscore_device(dev, true) the
    I2C controller will be left in D0 rather then be switched to D3.
    
    Yet on other Bay and Cherry Trail devices S0ix is not entered unless *all*
    I2C controllers are in D3 mode. This combined with the I2C controller no
    longer working now that we reach S0ix states on these systems leads to me
    believing that the PUNIT itself puts the I2C controller in D3 when all
    other conditions for entering S0ix states are true.
    
    Since now the I2C controller is put in D3 over a suspend/resume we must
    re-initialize it afterwards and that does indeed fix it no longer working.
    
    This commit implements this fix by:
    
    1) Making the suspend_late callback a no-op if pm_disabled is set and
    making the resume_early callback skip the clock re-enable (since it now was
    not disabled) while still doing the necessary I2C controller re-init.
    
    2) Removing the dev_pm_syscore_device(dev, true) call, so that the suspend
    and resume callbacks are actually called. Normally this would cause the
    ACPI pm code to call _PS3 putting the I2C controller in D3, wreaking havoc
    since it is shared with the PUNIT, but in this special case the _PS3 method
    is a no-op so we can safely allow a "fake" suspend / resume.
    
    Fixes: 12864ff8545f ("ACPI / LPSS: Avoid PM quirks on suspend and resume ...")
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=200861
    Cc: 4.15+ <stable@vger.kernel.org> # 4.15+
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 1a8d2da5b000..b5750fd85125 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -434,6 +434,9 @@ static int dw_i2c_plat_suspend(struct device *dev)
 {
 	struct dw_i2c_dev *i_dev = dev_get_drvdata(dev);
 
+	if (i_dev->pm_disabled)
+		return 0;
+
 	i_dev->disable(i_dev);
 	i2c_dw_prepare_clk(i_dev, false);
 
@@ -444,7 +447,9 @@ static int dw_i2c_plat_resume(struct device *dev)
 {
 	struct dw_i2c_dev *i_dev = dev_get_drvdata(dev);
 
-	i2c_dw_prepare_clk(i_dev, true);
+	if (!i_dev->pm_disabled)
+		i2c_dw_prepare_clk(i_dev, true);
+
 	i_dev->init(i_dev);
 
 	return 0;

commit 15c566fcff9cc7b8fd64461d6ee6fd1bc665b444
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Aug 10 13:26:49 2018 +0300

    i2c: designware: Add SPDX license tag
    
    Replace short statement in comment with proper SPDX license tag.
    
    Note, for i2c-desingware-slave.c the identifier is chosen
    in accordance with MODULE_LICENSE() macro since it is visible to user.
    Another point to this choice is that the header seems to be copy'n'paste
    from the other file of this very driver.
    
    Acked-by: Luis Oliveira <Luis.Oliveira@synopsys.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index fc1462601b16..1a8d2da5b000 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Synopsys DesignWare I2C adapter driver.
  *
@@ -6,20 +7,6 @@
  * Copyright (C) 2006 Texas Instruments.
  * Copyright (C) 2007 MontaVista Software Inc.
  * Copyright (C) 2009 Provigent Ltd.
- *
- * ----------------------------------------------------------------------------
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * ----------------------------------------------------------------------------
- *
  */
 #include <linux/acpi.h>
 #include <linux/clk-provider.h>

commit e3ea52b578be221d9d5564d17005d01a8d390b92
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Jul 25 17:39:26 2018 +0300

    i2c: designware: Convert to use struct i2c_timings
    
    Instead of using custom variables and parser, convert the driver to use
    the ones provided by I2C core.
    
    No functional change intended.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Tested-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 5660daf6c92e..fc1462601b16 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -96,6 +96,7 @@ static void dw_i2c_acpi_params(struct platform_device *pdev, char method[],
 static int dw_i2c_acpi_configure(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
+	struct i2c_timings *t = &dev->timings;
 	u32 ss_ht = 0, fp_ht = 0, hs_ht = 0, fs_ht = 0;
 	acpi_handle handle = ACPI_HANDLE(&pdev->dev);
 	const struct acpi_device_id *id;
@@ -115,7 +116,7 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 	dw_i2c_acpi_params(pdev, "HSCN", &dev->hs_hcnt, &dev->hs_lcnt, &hs_ht);
 	dw_i2c_acpi_params(pdev, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt, &fs_ht);
 
-	switch (dev->clk_freq) {
+	switch (t->bus_freq_hz) {
 	case 100000:
 		dev->sda_hold_time = ss_ht;
 		break;
@@ -175,6 +176,8 @@ static inline int dw_i2c_acpi_configure(struct platform_device *pdev)
 
 static void i2c_dw_configure_master(struct dw_i2c_dev *dev)
 {
+	struct i2c_timings *t = &dev->timings;
+
 	dev->functionality = I2C_FUNC_10BIT_ADDR | DW_IC_DEFAULT_FUNCTIONALITY;
 
 	dev->master_cfg = DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
@@ -182,7 +185,7 @@ static void i2c_dw_configure_master(struct dw_i2c_dev *dev)
 
 	dev->mode = DW_IC_MASTER;
 
-	switch (dev->clk_freq) {
+	switch (t->bus_freq_hz) {
 	case 100000:
 		dev->master_cfg |= DW_IC_CON_SPEED_STD;
 		break;
@@ -240,7 +243,8 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	struct dw_i2c_platform_data *pdata = dev_get_platdata(&pdev->dev);
 	struct i2c_adapter *adap;
 	struct dw_i2c_dev *dev;
-	u32 acpi_speed, ht = 0;
+	struct i2c_timings *t;
+	u32 acpi_speed;
 	struct resource *mem;
 	int i, irq, ret;
 	static const int supported_speeds[] = {
@@ -272,18 +276,11 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 		reset_control_deassert(dev->rst);
 	}
 
-	if (pdata) {
-		dev->clk_freq = pdata->i2c_scl_freq;
-	} else {
-		device_property_read_u32(&pdev->dev, "i2c-sda-hold-time-ns",
-					 &ht);
-		device_property_read_u32(&pdev->dev, "i2c-sda-falling-time-ns",
-					 &dev->sda_falling_time);
-		device_property_read_u32(&pdev->dev, "i2c-scl-falling-time-ns",
-					 &dev->scl_falling_time);
-		device_property_read_u32(&pdev->dev, "clock-frequency",
-					 &dev->clk_freq);
-	}
+	t = &dev->timings;
+	if (pdata)
+		t->bus_freq_hz = pdata->i2c_scl_freq;
+	else
+		i2c_parse_fw_timings(&pdev->dev, t, false);
 
 	acpi_speed = i2c_acpi_find_bus_speed(&pdev->dev);
 	/*
@@ -300,12 +297,12 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	 * Find bus speed from the "clock-frequency" device property, ACPI
 	 * or by using fast mode if neither is set.
 	 */
-	if (acpi_speed && dev->clk_freq)
-		dev->clk_freq = min(dev->clk_freq, acpi_speed);
-	else if (acpi_speed || dev->clk_freq)
-		dev->clk_freq = max(dev->clk_freq, acpi_speed);
+	if (acpi_speed && t->bus_freq_hz)
+		t->bus_freq_hz = min(t->bus_freq_hz, acpi_speed);
+	else if (acpi_speed || t->bus_freq_hz)
+		t->bus_freq_hz = max(t->bus_freq_hz, acpi_speed);
 	else
-		dev->clk_freq = 400000;
+		t->bus_freq_hz = 400000;
 
 	if (has_acpi_companion(&pdev->dev))
 		dw_i2c_acpi_configure(pdev);
@@ -314,11 +311,11 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	 * Only standard mode at 100kHz, fast mode at 400kHz,
 	 * fast mode plus at 1MHz and high speed mode at 3.4MHz are supported.
 	 */
-	if (dev->clk_freq != 100000 && dev->clk_freq != 400000
-	    && dev->clk_freq != 1000000 && dev->clk_freq != 3400000) {
+	if (t->bus_freq_hz != 100000 && t->bus_freq_hz != 400000 &&
+	    t->bus_freq_hz != 1000000 && t->bus_freq_hz != 3400000) {
 		dev_err(&pdev->dev,
 			"%d Hz is unsupported, only 100kHz, 400kHz, 1MHz and 3.4MHz are supported\n",
-			dev->clk_freq);
+			t->bus_freq_hz);
 		ret = -EINVAL;
 		goto exit_reset;
 	}
@@ -334,12 +331,14 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 
 	dev->clk = devm_clk_get(&pdev->dev, NULL);
 	if (!i2c_dw_prepare_clk(dev, true)) {
+		u64 clk_khz;
+
 		dev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;
+		clk_khz = dev->get_clk_rate_khz(dev);
 
-		if (!dev->sda_hold_time && ht)
-			dev->sda_hold_time = div_u64(
-				(u64)dev->get_clk_rate_khz(dev) * ht + 500000,
-				1000000);
+		if (!dev->sda_hold_time && t->sda_hold_ns)
+			dev->sda_hold_time =
+				div_u64(clk_khz * t->sda_hold_ns + 500000, 1000000);
 	}
 
 	dw_i2c_set_fifo_size(dev, pdev->id);

commit 4141cf676b9e345d3ddeb1710dd3156a09c50244
Merge: 3462ac57033e e38c85644e11
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 4 10:57:43 2018 -0800

    Merge branch 'i2c/for-4.16' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux
    
    Pull i2c updates from Wolfram Sang:
     "I2C has the following changes for you:
    
       - new flag to mark DMA safe buffers in i2c_msg. Also, some
         infrastructure around it. And docs.
    
       - huge refactoring of the at24 driver led by the new maintainer
         Bartosz
    
       - update I2C bus recovery to send STOP after recovery
    
       - conversion from gpio to gpiod for I2C bus recovery
    
       - adding a fault-injector to the i2c-gpio driver
    
       - lots of small driver improvements, and bigger ones to
         i2c-sh_mobile"
    
    * 'i2c/for-4.16' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux: (99 commits)
      i2c: mv64xxx: Add myself as maintainer for this driver
      i2c: mv64xxx: Fix clock resource by adding an optional bus clock
      i2c: mv64xxx: Remove useless test before clk_disable_unprepare
      i2c: mxs: use true and false for boolean values
      i2c: meson: update doc description to fix build warnings
      i2c: meson: add configurable divider factors
      dt-bindings: i2c: update documentation for the Meson-AXG
      i2c: imx-lpi2c: add runtime pm support
      i2c: rcar: fix some trivial typos in comments
      i2c: davinci: fix the cpufreq transition
      i2c: rk3x: add proper kerneldoc header
      i2c: rk3x: account for const type of of_device_id.data
      i2c: acorn: remove outdated path from file header
      i2c: acorn: add MODULE_LICENSE tag
      i2c: rcar: implement bus recovery
      i2c: send STOP after successful bus recovery
      i2c: ensure SDA is released in recovery if SDA is controllable
      i2c: add 'set_sda' to bus_recovery_info
      i2c: add identifier in declarations for i2c_bus_recovery
      i2c: make kerneldoc about bus recovery more precise
      ...

commit 02e45646d53bdb38bfb47b83765778d3ecb4d3b3
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 3 01:37:34 2018 +0100

    PM: i2c-designware-platdrv: Optimize power management
    
    Optimize the power management in i2c-designware-platdrv by making it
    set the DPM_FLAG_SMART_SUSPEND and DPM_FLAG_LEAVE_SUSPENDED which
    allows some code to be dropped from its PM callbacks.
    
    First, setting DPM_FLAG_SMART_SUSPEND causes the intel-lpss driver
    to avoid resuming i2c-designware-platdrv devices in its ->prepare
    callback, so they can stay in runtime suspend after that point even
    if the direct-complete feature is not used for them.
    
    It also causes the ACPI PM domain and the PM core to avoid invoking
    "late" and "noirq" suspend callbacks for these devices if they are
    in runtime suspend at the beginning of the "late" phase of device
    suspend during system suspend.  That guarantees dw_i2c_plat_suspend()
    to be called for a device only if it is not in runtime suspend.
    
    Moreover, it causes the device's runtime PM status to be set to
    "active" after calling dw_i2c_plat_resume() for it, so the
    driver doesn't need internal flags to avoid invoking either
    dw_i2c_plat_suspend() or dw_i2c_plat_resume() twice in a row.
    
    Second, setting DPM_FLAG_LEAVE_SUSPENDED enables the optimization
    allowing the device to stay suspended after system resume under
    suitable conditions, so again the driver doesn't need to take
    care of that by itself.
    
    Accordingly, the internal "suspended" and "skip_resume" flags
    used by the driver are not necessary any more, so drop them and
    simplify the driver's PM callbacks.
    
    Additionally, notice that dw_i2c_plat_complete() only needs to
    schedule runtime PM resume for the device if platform firmware
    has been involved in resuming the system, so make it call
    pm_resume_via_firmware() to check that.  Also make it check the
    runtime PM status of the device instead of its direct_complete
    flag which also works if the device remained suspended due to
    the DPM_FLAG_LEAVE_SUSPENDED driver flag.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 4f90a6dc186f..153b947702c5 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -42,6 +42,7 @@
 #include <linux/reset.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
+#include <linux/suspend.h>
 
 #include "i2c-designware-core.h"
 
@@ -372,7 +373,10 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	ACPI_COMPANION_SET(&adap->dev, ACPI_COMPANION(&pdev->dev));
 	adap->dev.of_node = pdev->dev.of_node;
 
-	dev_pm_set_driver_flags(&pdev->dev, DPM_FLAG_SMART_PREPARE);
+	dev_pm_set_driver_flags(&pdev->dev,
+				DPM_FLAG_SMART_PREPARE |
+				DPM_FLAG_SMART_SUSPEND |
+				DPM_FLAG_LEAVE_SUSPENDED);
 
 	/* The code below assumes runtime PM to be disabled. */
 	WARN_ON(pm_runtime_enabled(&pdev->dev));
@@ -448,7 +452,13 @@ static int dw_i2c_plat_prepare(struct device *dev)
 
 static void dw_i2c_plat_complete(struct device *dev)
 {
-	if (dev->power.direct_complete)
+	/*
+	 * The device can only be in runtime suspend at this point if it has not
+	 * been resumed throughout the ending system suspend/resume cycle, so if
+	 * the platform firmware might mess up with it, request the runtime PM
+	 * framework to resume it.
+	 */
+	if (pm_runtime_suspended(dev) && pm_resume_via_firmware())
 		pm_request_resume(dev);
 }
 #else
@@ -461,16 +471,9 @@ static int dw_i2c_plat_suspend(struct device *dev)
 {
 	struct dw_i2c_dev *i_dev = dev_get_drvdata(dev);
 
-	if (i_dev->suspended) {
-		i_dev->skip_resume = true;
-		return 0;
-	}
-
 	i_dev->disable(i_dev);
 	i2c_dw_plat_prepare_clk(i_dev, false);
 
-	i_dev->suspended = true;
-
 	return 0;
 }
 
@@ -478,19 +481,9 @@ static int dw_i2c_plat_resume(struct device *dev)
 {
 	struct dw_i2c_dev *i_dev = dev_get_drvdata(dev);
 
-	if (!i_dev->suspended)
-		return 0;
-
-	if (i_dev->skip_resume) {
-		i_dev->skip_resume = false;
-		return 0;
-	}
-
 	i2c_dw_plat_prepare_clk(i_dev, true);
 	i_dev->init(i_dev);
 
-	i_dev->suspended = false;
-
 	return 0;
 }
 

commit 422cb781e0d0f81789a1cc0f2171611028450f09
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Jan 3 01:35:54 2018 +0100

    PM: i2c-designware-platdrv: Use DPM_FLAG_SMART_PREPARE
    
    Modify i2c-designware-platdrv to set DPM_FLAG_SMART_PREPARE for its
    devices and return 0 from the system suspend ->prepare callback
    if the device has an ACPI companion object in order to tell the PM
    core and middle layers to avoid skipping system suspend/resume
    callbacks for the device in that case (which may be problematic,
    because the device may be accessed during suspend and resume of
    other devices via I2C operation regions then).
    
    Also the pm_runtime_suspended() check in dw_i2c_plat_prepare()
    is not necessary any more, because the core does it when setting
    power.direct_complete for the device, so drop it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 58add69a441c..4f90a6dc186f 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -372,6 +372,8 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	ACPI_COMPANION_SET(&adap->dev, ACPI_COMPANION(&pdev->dev));
 	adap->dev.of_node = pdev->dev.of_node;
 
+	dev_pm_set_driver_flags(&pdev->dev, DPM_FLAG_SMART_PREPARE);
+
 	/* The code below assumes runtime PM to be disabled. */
 	WARN_ON(pm_runtime_enabled(&pdev->dev));
 
@@ -435,7 +437,13 @@ MODULE_DEVICE_TABLE(of, dw_i2c_of_match);
 #ifdef CONFIG_PM_SLEEP
 static int dw_i2c_plat_prepare(struct device *dev)
 {
-	return pm_runtime_suspended(dev);
+	/*
+	 * If the ACPI companion device object is present for this device, it
+	 * may be accessed during suspend and resume of other devices via I2C
+	 * operation regions, so tell the PM core and middle layers to avoid
+	 * skipping system suspend/resume callbacks for it in that case.
+	 */
+	return !has_acpi_companion(dev);
 }
 
 static void dw_i2c_plat_complete(struct device *dev)

commit 0326f9f801b2411811906361db870ccdada98b92
Author: Phil Reid <preid@electromag.com.au>
Date:   Thu Nov 2 10:40:26 2017 +0800

    i2c: designware: rename i2c_dw_plat_prepare_clk to i2c_dw_prepare_clk
    
    For consistency with the rest of the file rename function and parameter to
    be consistent with the reset of the common file.
    
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Phil Reid <preid@electromag.com.au>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 6a3fd8d7c273..6e0fd94faba1 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -332,7 +332,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 		i2c_dw_configure_master(dev);
 
 	dev->clk = devm_clk_get(&pdev->dev, NULL);
-	if (!i2c_dw_plat_prepare_clk(dev, true)) {
+	if (!i2c_dw_prepare_clk(dev, true)) {
 		dev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;
 
 		if (!dev->sda_hold_time && ht)
@@ -436,7 +436,7 @@ static int dw_i2c_plat_suspend(struct device *dev)
 	}
 
 	i_dev->disable(i_dev);
-	i2c_dw_plat_prepare_clk(i_dev, false);
+	i2c_dw_prepare_clk(i_dev, false);
 
 	i_dev->suspended = true;
 
@@ -455,7 +455,7 @@ static int dw_i2c_plat_resume(struct device *dev)
 		return 0;
 	}
 
-	i2c_dw_plat_prepare_clk(i_dev, true);
+	i2c_dw_prepare_clk(i_dev, true);
 	i_dev->init(i_dev);
 
 	i_dev->suspended = false;

commit a34a0b6da22540d19e578131bbb60994892473d3
Author: Phil Reid <preid@electromag.com.au>
Date:   Thu Nov 2 10:40:25 2017 +0800

    i2c: designware: move i2c_dw_plat_prepare_clk to common
    
    Move the i2c_dw_plat_prepare_clk funciton to common file in preparation
    for its use also by the master driver.
    
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Phil Reid <preid@electromag.com.au>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 293f586d78d2..6a3fd8d7c273 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -203,18 +203,6 @@ static void i2c_dw_configure_slave(struct dw_i2c_dev *dev)
 	dev->mode = DW_IC_SLAVE;
 }
 
-static int i2c_dw_plat_prepare_clk(struct dw_i2c_dev *i_dev, bool prepare)
-{
-	if (IS_ERR(i_dev->clk))
-		return PTR_ERR(i_dev->clk);
-
-	if (prepare)
-		return clk_prepare_enable(i_dev->clk);
-
-	clk_disable_unprepare(i_dev->clk);
-	return 0;
-}
-
 static void dw_i2c_set_fifo_size(struct dw_i2c_dev *dev, int id)
 {
 	u32 param, tx_fifo_depth, rx_fifo_depth;

commit 43df43e6ba139e6cd77ea31ca27efc67ea2df44b
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Wed Aug 23 16:46:12 2017 +0300

    i2c: designware: Don't set SCL timings and speed mode when in slave mode
    
    According to data sheet SCL timing parameters and DW_IC_CON SPEED mode
    bits are not used when operating in slave mode.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Tested-by: Luis Oliveira <lolivei@synopsys.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 58add69a441c..293f586d78d2 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -201,17 +201,6 @@ static void i2c_dw_configure_slave(struct dw_i2c_dev *dev)
 			 DW_IC_CON_RESTART_EN | DW_IC_CON_STOP_DET_IFADDRESSED;
 
 	dev->mode = DW_IC_SLAVE;
-
-	switch (dev->clk_freq) {
-	case 100000:
-		dev->slave_cfg |= DW_IC_CON_SPEED_STD;
-		break;
-	case 3400000:
-		dev->slave_cfg |= DW_IC_CON_SPEED_HIGH;
-		break;
-	default:
-		dev->slave_cfg |= DW_IC_CON_SPEED_FAST;
-	}
 }
 
 static int i2c_dw_plat_prepare_clk(struct dw_i2c_dev *i_dev, bool prepare)

commit 4ce8e88f6c25469b83a7d56914995fe892d1f9a8
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Sep 21 23:30:07 2017 +0100

    i2c: designware: make const array supported_speeds static to shink object code size
    
    Don't populate const array supported_speeds on the stack, instead
    make it static.  Makes the object code smaller by 150 bytes:
    
    Before:
       text    data     bss     dec     hex filename
       8474    1440       0    9914    26ba i2c-designware-platdrv.o
    
    After:
       text    data     bss     dec     hex filename
       8324    1440       0    9764    2624 i2c-designware-platdrv.o
    
    (gcc version 7.2.0 x86_64)
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 16c027b62a20..58add69a441c 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -265,7 +265,9 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	u32 acpi_speed, ht = 0;
 	struct resource *mem;
 	int i, irq, ret;
-	const int supported_speeds[] = { 0, 100000, 400000, 1000000, 3400000 };
+	static const int supported_speeds[] = {
+		0, 100000, 400000, 1000000, 3400000
+	};
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)

commit 541527728341b4bb9a5e3428b0eec450f1b3d8d5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Sep 25 01:30:51 2017 +0200

    PM: i2c-designware-platdrv: Suspend/resume at the late/early stages
    
    As reported by Rajat Jain, there are problems when ACPI operation
    region handlers or similar, called at the ->resume_early() time, for
    I2C client devices try to access an I2C controller that has already
    been suspended at that point.  To avoid that, move the suspend/resume
    of i2c-designware-platdrv to the late/early stages, respectively.
    
    While at it, avoid resuming the device from runtime suspend in the
    driver's ->suspend callback which isn't particularly nice.  [A better
    approach would be to make the driver track the PM state of the device
    so that it doesn't need to resume it in ->suspend, so implement it.]
    
    First, drop dw_i2c_plat_suspend() added by commit a23318feeff6 (i2c:
    designware: Fix system suspend) and rename dw_i2c_plat_runtime_suspend()
    back to dw_i2c_plat_suspend().
    
    Second, point the driver's ->late_suspend and ->early_resume
    callbacks, rather than its ->suspend and ->resume callbacks,
    to dw_i2c_plat_suspend() and dw_i2c_plat_resume(), respectively,
    so that they are not executed in parallel with each other, for
    example if runtime resume of the device takes place during system
    suspend.
    
    Finally, add "suspended" and "skip_resume" flags to struct dw_i2c_dev
    and make dw_i2c_plat_suspend() and dw_i2c_plat_resume() use them to
    avoid suspending or resuming the device twice in a row and to avoid
    resuming a previously runtime-suspended device during system resume.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Johannes Stezenbach <js@sig21.net>
    Tested-by: Rajat Jain <rajatja@google.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 532e5a6e8512..16c027b62a20 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -447,13 +447,20 @@ static void dw_i2c_plat_complete(struct device *dev)
 #endif
 
 #ifdef CONFIG_PM
-static int dw_i2c_plat_runtime_suspend(struct device *dev)
+static int dw_i2c_plat_suspend(struct device *dev)
 {
 	struct dw_i2c_dev *i_dev = dev_get_drvdata(dev);
 
+	if (i_dev->suspended) {
+		i_dev->skip_resume = true;
+		return 0;
+	}
+
 	i_dev->disable(i_dev);
 	i2c_dw_plat_prepare_clk(i_dev, false);
 
+	i_dev->suspended = true;
+
 	return 0;
 }
 
@@ -461,27 +468,27 @@ static int dw_i2c_plat_resume(struct device *dev)
 {
 	struct dw_i2c_dev *i_dev = dev_get_drvdata(dev);
 
+	if (!i_dev->suspended)
+		return 0;
+
+	if (i_dev->skip_resume) {
+		i_dev->skip_resume = false;
+		return 0;
+	}
+
 	i2c_dw_plat_prepare_clk(i_dev, true);
 	i_dev->init(i_dev);
 
-	return 0;
-}
+	i_dev->suspended = false;
 
-#ifdef CONFIG_PM_SLEEP
-static int dw_i2c_plat_suspend(struct device *dev)
-{
-	pm_runtime_resume(dev);
-	return dw_i2c_plat_runtime_suspend(dev);
+	return 0;
 }
-#endif
 
 static const struct dev_pm_ops dw_i2c_dev_pm_ops = {
 	.prepare = dw_i2c_plat_prepare,
 	.complete = dw_i2c_plat_complete,
-	SET_SYSTEM_SLEEP_PM_OPS(dw_i2c_plat_suspend, dw_i2c_plat_resume)
-	SET_RUNTIME_PM_OPS(dw_i2c_plat_runtime_suspend,
-			   dw_i2c_plat_resume,
-			   NULL)
+	SET_LATE_SYSTEM_SLEEP_PM_OPS(dw_i2c_plat_suspend, dw_i2c_plat_resume)
+	SET_RUNTIME_PM_OPS(dw_i2c_plat_suspend, dw_i2c_plat_resume, NULL)
 };
 
 #define DW_I2C_DEV_PMOPS (&dw_i2c_dev_pm_ops)

commit 126dbc6b49c8670ebe78174c159520d5993b4459
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Sep 25 23:10:06 2017 +0200

    PM: i2c-designware-platdrv: Clean up PM handling in probe
    
    The power management handling in dw_i2c_plat_probe() is somewhat
    messy and it is rather hard to figure out the code intention for
    the case when pm_disabled is set.  In that case, the driver doesn't
    enable runtime PM at all, but in addition to that it calls
    pm_runtime_forbid() as though it wasn't sure if runtime PM might
    be enabled for the device later by someone else.
    
    Although that concern doesn't seem to be actually valid, the
    device is clearly still expected to be PM-capable even in the
    pm_disabled set case, so a better approach would be to enable
    runtime PM for it unconditionally and prevent it from being
    runtime-suspended by using pm_runtime_get_noresume().
    
    Make the driver do that.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 0e65b97842b4..532e5a6e8512 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -249,6 +249,14 @@ static void dw_i2c_set_fifo_size(struct dw_i2c_dev *dev, int id)
 	}
 }
 
+static void dw_i2c_plat_pm_cleanup(struct dw_i2c_dev *dev)
+{
+	pm_runtime_disable(dev->dev);
+
+	if (dev->pm_disabled)
+		pm_runtime_put_noidle(dev->dev);
+}
+
 static int dw_i2c_plat_probe(struct platform_device *pdev)
 {
 	struct dw_i2c_platform_data *pdata = dev_get_platdata(&pdev->dev);
@@ -362,14 +370,17 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	ACPI_COMPANION_SET(&adap->dev, ACPI_COMPANION(&pdev->dev));
 	adap->dev.of_node = pdev->dev.of_node;
 
-	if (dev->pm_disabled) {
-		pm_runtime_forbid(&pdev->dev);
-	} else {
-		pm_runtime_set_autosuspend_delay(&pdev->dev, 1000);
-		pm_runtime_use_autosuspend(&pdev->dev);
-		pm_runtime_set_active(&pdev->dev);
-		pm_runtime_enable(&pdev->dev);
-	}
+	/* The code below assumes runtime PM to be disabled. */
+	WARN_ON(pm_runtime_enabled(&pdev->dev));
+
+	pm_runtime_set_autosuspend_delay(&pdev->dev, 1000);
+	pm_runtime_use_autosuspend(&pdev->dev);
+	pm_runtime_set_active(&pdev->dev);
+
+	if (dev->pm_disabled)
+		pm_runtime_get_noresume(&pdev->dev);
+
+	pm_runtime_enable(&pdev->dev);
 
 	if (dev->mode == DW_IC_SLAVE)
 		ret = i2c_dw_probe_slave(dev);
@@ -382,8 +393,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	return ret;
 
 exit_probe:
-	if (!dev->pm_disabled)
-		pm_runtime_disable(&pdev->dev);
+	dw_i2c_plat_pm_cleanup(dev);
 exit_reset:
 	if (!IS_ERR_OR_NULL(dev->rst))
 		reset_control_assert(dev->rst);
@@ -402,8 +412,8 @@ static int dw_i2c_plat_remove(struct platform_device *pdev)
 
 	pm_runtime_dont_use_autosuspend(&pdev->dev);
 	pm_runtime_put_sync(&pdev->dev);
-	if (!dev->pm_disabled)
-		pm_runtime_disable(&pdev->dev);
+	dw_i2c_plat_pm_cleanup(dev);
+
 	if (!IS_ERR_OR_NULL(dev->rst))
 		reset_control_assert(dev->rst);
 

commit d2d8f51e28fec278e9632cdd029facf813f579a3
Merge: ad9a19d00370 8ce906c13c32
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 9 14:18:40 2017 -0700

    Merge branch 'i2c/for-4.14' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux
    
    Pull i2c updates from Wolfram Sang:
    
     - new drivers for Spreadtrum I2C, Intel Cherry Trail Whiskey Cove SMBUS
    
     - quite some driver updates
    
     - cleanups for the i2c-mux subsystem
    
     - some subsystem-wide constification
    
     - further cleanup of include/linux/i2c
    
    * 'i2c/for-4.14' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux: (50 commits)
      i2c: sprd: Fix undefined reference errors
      i2c: nomadik: constify amba_id
      i2c: versatile: Make i2c_algo_bit_data const
      i2c: busses: make i2c_adapter_quirks const
      i2c: busses: make i2c_adapter const
      i2c: busses: make i2c_algorithm const
      i2c: Add Spreadtrum I2C controller driver
      dt-bindings: i2c: Add Spreadtrum I2C controller documentation
      i2c-cht-wc: make cht_wc_i2c_adap_driver static
      MAINTAINERS: Add entry for drivers/i2c/busses/i2c-cht-wc.c
      i2c: aspeed: Retain delay/setup/hold values when configuring bus frequency
      dt-bindings: i2c: eeprom: Document vendor to be used and deprecated ones
      i2c: i801: Restore the presence state of P2SB PCI device after reading BAR
      MAINTAINERS: drop entry for Blackfin I2C and Sonic's email
      blackfin: merge the two TWI header files
      i2c: davinci: Preserve return value of devm_clk_get
      i2c: mediatek: Add i2c compatible for MediaTek MT7622
      dt-bindings: i2c: Add MediaTek MT7622 i2c binding
      dt-bindings: i2c: modify information formats
      i2c: mux: i2c-arb-gpio-challenge: allow compiling w/o OF support
      ...

commit 231d069fcde22bd0582c2c9564f1b334d280c7d7
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Tue Aug 29 14:08:35 2017 +0200

    i2c: designware: Round down ACPI provided clk to nearest supported clk
    
    The Lenovo Miix2 8 DSDT contains an i2c clk / bus speed of 1700000 Hz
    for one if its devices, which is not supported.
    
    This is the second DSDT to show up with an unsupported clk in a short
    time, remove the hardcoded fix for DSDTs with a 1 MiHz clock and simply
    always round down the clk to the nearest supported value.
    
    Reported-by: russianneuromancer@ya.ru
    Fixes: 682c6c2188 ("i2c: designware: Some broken DSTDs use 1MiHz ...")
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 57248bccadbc..2b98a173136f 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -256,7 +256,8 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	struct dw_i2c_dev *dev;
 	u32 acpi_speed, ht = 0;
 	struct resource *mem;
-	int irq, ret;
+	int i, irq, ret;
+	const int supported_speeds[] = { 0, 100000, 400000, 1000000, 3400000 };
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
@@ -297,9 +298,16 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	}
 
 	acpi_speed = i2c_acpi_find_bus_speed(&pdev->dev);
-	/* Some broken DSTDs use 1MiHz instead of 1MHz */
-	if (acpi_speed == 1048576)
-		acpi_speed = 1000000;
+	/*
+	 * Some DSTDs use a non standard speed, round down to the lowest
+	 * standard speed.
+	 */
+	for (i = 1; i < ARRAY_SIZE(supported_speeds); i++) {
+		if (acpi_speed < supported_speeds[i])
+			break;
+	}
+	acpi_speed = supported_speeds[i - 1];
+
 	/*
 	 * Find bus speed from the "clock-frequency" device property, ACPI
 	 * or by using fast mode if neither is set.

commit 4e2d93de070ceaca5097f7ee5c311731b83208a0
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Wed Aug 9 15:24:44 2017 +0300

    i2c: designware: Fix standard mode speed when configuring the slave mode
    
    Code sets bit DW_IC_CON_SPEED_FAST (0x4) always when configuring the slave
    mode. This results incorrect register value DW_IC_CON_SPEED_HIGH (0x6)
    when OR'ed together with DW_IC_CON_SPEED_STD (0x2).
    
    Remove this and let the code set the speed mode bits according to clock
    frequency or default to fast mode.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 441afc715a90..57248bccadbc 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -198,8 +198,7 @@ static void i2c_dw_configure_slave(struct dw_i2c_dev *dev)
 	dev->functionality = I2C_FUNC_SLAVE | DW_IC_DEFAULT_FUNCTIONALITY;
 
 	dev->slave_cfg = DW_IC_CON_RX_FIFO_FULL_HLD_CTRL |
-			 DW_IC_CON_RESTART_EN | DW_IC_CON_STOP_DET_IFADDRESSED |
-			 DW_IC_CON_SPEED_FAST;
+			 DW_IC_CON_RESTART_EN | DW_IC_CON_STOP_DET_IFADDRESSED;
 
 	dev->mode = DW_IC_SLAVE;
 

commit a23318feeff662c8d25d21623daebdd2e55ec221
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Aug 9 15:28:22 2017 +0200

    i2c: designware: Fix system suspend
    
    The commit 8503ff166504 ("i2c: designware: Avoid unnecessary resuming
    during system suspend"), may suggest to the PM core to try out the so
    called direct_complete path for system sleep. In this path, the PM core
    treats a runtime suspended device as it's already in a proper low power
    state for system sleep, which makes it skip calling the system sleep
    callbacks for the device, except for the ->prepare() and the ->complete()
    callbacks.
    
    However, the PM core may unset the direct_complete flag for a parent
    device, in case its child device are being system suspended before. In this
    scenario, the PM core invokes the system sleep callbacks, no matter if the
    device is runtime suspended or not.
    
    Particularly in cases of an existing i2c slave device, the above path is
    triggered, which breaks the assumption that the i2c device is always
    runtime resumed whenever the dw_i2c_plat_suspend() is being called.
    
    More precisely, dw_i2c_plat_suspend() calls clk_core_disable() and
    clk_core_unprepare(), for an already disabled/unprepared clock, leading to
    a splat in the log about clocks calls being wrongly balanced and breaking
    system sleep.
    
    To still allow the direct_complete path in cases when it's possible, but
    also to keep the fix simple, let's runtime resume the i2c device in the
    ->suspend() callback, before continuing to put the device into low power
    state.
    
    Note, in cases when the i2c device is attached to the ACPI PM domain, this
    problem doesn't occur, because ACPI's ->suspend() callback, assigned to
    acpi_subsys_suspend(), already calls pm_runtime_resume() for the device.
    
    It should also be noted that this change does not fix commit 8503ff166504
    ("i2c: designware: Avoid unnecessary resuming during system suspend").
    Because for the non-ACPI case, the system sleep support was already broken
    prior that point.
    
    Cc: <stable@vger.kernel.org> # v4.4+
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Tested-by: John Stultz <john.stultz@linaro.org>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 143a8fd582b4..441afc715a90 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -430,7 +430,7 @@ static void dw_i2c_plat_complete(struct device *dev)
 #endif
 
 #ifdef CONFIG_PM
-static int dw_i2c_plat_suspend(struct device *dev)
+static int dw_i2c_plat_runtime_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);
@@ -452,11 +452,21 @@ static int dw_i2c_plat_resume(struct device *dev)
 	return 0;
 }
 
+#ifdef CONFIG_PM_SLEEP
+static int dw_i2c_plat_suspend(struct device *dev)
+{
+	pm_runtime_resume(dev);
+	return dw_i2c_plat_runtime_suspend(dev);
+}
+#endif
+
 static const struct dev_pm_ops dw_i2c_dev_pm_ops = {
 	.prepare = dw_i2c_plat_prepare,
 	.complete = dw_i2c_plat_complete,
 	SET_SYSTEM_SLEEP_PM_OPS(dw_i2c_plat_suspend, dw_i2c_plat_resume)
-	SET_RUNTIME_PM_OPS(dw_i2c_plat_suspend, dw_i2c_plat_resume, NULL)
+	SET_RUNTIME_PM_OPS(dw_i2c_plat_runtime_suspend,
+			   dw_i2c_plat_resume,
+			   NULL)
 };
 
 #define DW_I2C_DEV_PMOPS (&dw_i2c_dev_pm_ops)

commit 9242e72aaea05c0fce2003a8efa48f403d87a5bf
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Jul 28 01:16:24 2017 +0900

    i2c: use dev_get_drvdata() to get private data in suspend/resume hooks
    
    Several drivers call to_platform_device() to get platform_device
    and pass it to platform_get_drvdata().  In platform_get_drvdata(),
    the platform_device is converted back to struct device again.
    
    Use dev_get_drvdata() to avoid platform_device/device dance.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com> (for DesignWare only)
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 2ea6d0d25a01..abe1eca8d689 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -428,8 +428,7 @@ static void dw_i2c_plat_complete(struct device *dev)
 #ifdef CONFIG_PM
 static int dw_i2c_plat_suspend(struct device *dev)
 {
-	struct platform_device *pdev = to_platform_device(dev);
-	struct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);
+	struct dw_i2c_dev *i_dev = dev_get_drvdata(dev);
 
 	i_dev->disable(i_dev);
 	i2c_dw_plat_prepare_clk(i_dev, false);
@@ -439,8 +438,7 @@ static int dw_i2c_plat_suspend(struct device *dev)
 
 static int dw_i2c_plat_resume(struct device *dev)
 {
-	struct platform_device *pdev = to_platform_device(dev);
-	struct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);
+	struct dw_i2c_dev *i_dev = dev_get_drvdata(dev);
 
 	i2c_dw_plat_prepare_clk(i_dev, true);
 	i_dev->init(i_dev);

commit 682c6c2188f39d13548ccdc89c9888fbcb547889
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Jul 13 15:45:02 2017 +0200

    i2c: designware: Some broken DSTDs use 1MiHz instead of 1MHz
    
    At least the Acer Iconia Tab8 / aka W1-810 uses 1MiHz instead of
    1MHz for one of its busses, fix this up to 1MHz instead of failing
    the probe of that bus.
    
    This fixes the accelerometer on the Acer Iconia Tab8 not working.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index d139b156f9c9..143a8fd582b4 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -298,6 +298,9 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	}
 
 	acpi_speed = i2c_acpi_find_bus_speed(&pdev->dev);
+	/* Some broken DSTDs use 1MiHz instead of 1MHz */
+	if (acpi_speed == 1048576)
+		acpi_speed = 1000000;
 	/*
 	 * Find bus speed from the "clock-frequency" device property, ACPI
 	 * or by using fast mode if neither is set.

commit 22acc37b8681461707a3fc73505af808f9af8260
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Thu Jul 13 15:45:01 2017 +0200

    i2c: designware: Print clock freq on invalid clock freq error
    
    When we refuse to probe due to an invalid clock frequency, log
    the frequency which is causing this error.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 2ea6d0d25a01..d139b156f9c9 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -319,7 +319,8 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	if (dev->clk_freq != 100000 && dev->clk_freq != 400000
 	    && dev->clk_freq != 1000000 && dev->clk_freq != 3400000) {
 		dev_err(&pdev->dev,
-			"Only 100kHz, 400kHz, 1MHz and 3.4MHz supported");
+			"%d Hz is unsupported, only 100kHz, 400kHz, 1MHz and 3.4MHz are supported\n",
+			dev->clk_freq);
 		ret = -EINVAL;
 		goto exit_reset;
 	}

commit 5b6d721b266acaef411520e28066e4624c6619e7
Author: Luis Oliveira <Luis.Oliveira@synopsys.com>
Date:   Thu Jun 22 11:17:33 2017 +0100

    i2c: designware: enable SLAVE in platform module
    
    - Slave mode selected in platform module if the support is detected in
      the DT.
    
    Signed-off-by: Luis Oliveira <lolivei@synopsys.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 1f38c807be5f..2ea6d0d25a01 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -1,5 +1,5 @@
 /*
- * Synopsys DesignWare I2C adapter driver (master only).
+ * Synopsys DesignWare I2C adapter driver.
  *
  * Based on the TI DAVINCI I2C adapter driver.
  *
@@ -174,9 +174,13 @@ static inline int dw_i2c_acpi_configure(struct platform_device *pdev)
 
 static void i2c_dw_configure_master(struct dw_i2c_dev *dev)
 {
+	dev->functionality = I2C_FUNC_10BIT_ADDR | DW_IC_DEFAULT_FUNCTIONALITY;
+
 	dev->master_cfg = DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
 			  DW_IC_CON_RESTART_EN;
 
+	dev->mode = DW_IC_MASTER;
+
 	switch (dev->clk_freq) {
 	case 100000:
 		dev->master_cfg |= DW_IC_CON_SPEED_STD;
@@ -189,6 +193,28 @@ static void i2c_dw_configure_master(struct dw_i2c_dev *dev)
 	}
 }
 
+static void i2c_dw_configure_slave(struct dw_i2c_dev *dev)
+{
+	dev->functionality = I2C_FUNC_SLAVE | DW_IC_DEFAULT_FUNCTIONALITY;
+
+	dev->slave_cfg = DW_IC_CON_RX_FIFO_FULL_HLD_CTRL |
+			 DW_IC_CON_RESTART_EN | DW_IC_CON_STOP_DET_IFADDRESSED |
+			 DW_IC_CON_SPEED_FAST;
+
+	dev->mode = DW_IC_SLAVE;
+
+	switch (dev->clk_freq) {
+	case 100000:
+		dev->slave_cfg |= DW_IC_CON_SPEED_STD;
+		break;
+	case 3400000:
+		dev->slave_cfg |= DW_IC_CON_SPEED_HIGH;
+		break;
+	default:
+		dev->slave_cfg |= DW_IC_CON_SPEED_FAST;
+	}
+}
+
 static int i2c_dw_plat_prepare_clk(struct dw_i2c_dev *i_dev, bool prepare)
 {
 	if (IS_ERR(i_dev->clk))
@@ -302,9 +328,10 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	if (ret)
 		goto exit_reset;
 
-	dev->functionality = I2C_FUNC_10BIT_ADDR | DW_IC_DEFAULT_FUNCTIONALITY;
-
-	i2c_dw_configure_master(dev);
+	if (i2c_detect_slave_mode(&pdev->dev))
+		i2c_dw_configure_slave(dev);
+	else
+		i2c_dw_configure_master(dev);
 
 	dev->clk = devm_clk_get(&pdev->dev, NULL);
 	if (!i2c_dw_plat_prepare_clk(dev, true)) {
@@ -333,7 +360,11 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 		pm_runtime_enable(&pdev->dev);
 	}
 
-	ret = i2c_dw_probe(dev);
+	if (dev->mode == DW_IC_SLAVE)
+		ret = i2c_dw_probe_slave(dev);
+	else
+		ret = i2c_dw_probe(dev);
+
 	if (ret)
 		goto exit_probe;
 

commit 90312351fd1e47183662a6abf159cbf751ea62f1
Author: Luis Oliveira <Luis.Oliveira@synopsys.com>
Date:   Wed Jun 14 11:43:23 2017 +0100

    i2c: designware: MASTER mode as separated driver
    
    - The functions related to I2C master mode of operation were transformed
      in a single driver.
    - Common definitions were moved to i2c-designware-core.h
    - The i2c-designware-core is now only a library file, the functions
      associated are in a source file called i2c-designware-common and
      are used by both i2c-designware-master and i2c-designware-slave.
    - To decrease noise in namespace common i2c_dw_*() functions are
      now using ops to keep them private.
    - Designware PCI driver had to be changed to match the previous ops
      functions implementation.
    
    Almost all of the "core" source is now part of the "master" source. The
    difference is the functions used by both modes and they are in the
    "common" source file.
    
    Signed-off-by: Luis Oliveira <lolivei@synopsys.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index fd14b410369e..1f38c807be5f 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -356,7 +356,7 @@ static int dw_i2c_plat_remove(struct platform_device *pdev)
 
 	i2c_del_adapter(&dev->adapter);
 
-	i2c_dw_disable(dev);
+	dev->disable(dev);
 
 	pm_runtime_dont_use_autosuspend(&pdev->dev);
 	pm_runtime_put_sync(&pdev->dev);
@@ -400,7 +400,7 @@ static int dw_i2c_plat_suspend(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);
 
-	i2c_dw_disable(i_dev);
+	i_dev->disable(i_dev);
 	i2c_dw_plat_prepare_clk(i_dev, false);
 
 	return 0;
@@ -412,7 +412,7 @@ static int dw_i2c_plat_resume(struct device *dev)
 	struct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);
 
 	i2c_dw_plat_prepare_clk(i_dev, true);
-	i2c_dw_init(i_dev);
+	i_dev->init(i_dev);
 
 	return 0;
 }

commit 89a1e1bd7ba9a6711908bb79af0af6cbdf4a7e79
Author: Luis Oliveira <Luis.Oliveira@synopsys.com>
Date:   Wed Jun 14 11:43:22 2017 +0100

    i2c: designware: refactoring of the i2c-designware
    
    - Factor out all _master() part of code from i2c-designware-core
      and i2c-designware-platdrv to separate functions.
    - Standardize all code related with MASTER mode.
    - I have to take off DW_IC_INTR_TX_EMPTY from DW_IC_INTR_DEFAULT_MASK
      because it is master specific.
    
    The purpose of this is to prepare the controller to have is I2C MASTER
    flow in a separate driver. To do this first all the
    functions/definitions related to the MASTER flow were identified.
    
    Signed-off-by: Luis Oliveira <lolivei@synopsys.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 613dfb88307f..fd14b410369e 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -172,6 +172,23 @@ static inline int dw_i2c_acpi_configure(struct platform_device *pdev)
 }
 #endif
 
+static void i2c_dw_configure_master(struct dw_i2c_dev *dev)
+{
+	dev->master_cfg = DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
+			  DW_IC_CON_RESTART_EN;
+
+	switch (dev->clk_freq) {
+	case 100000:
+		dev->master_cfg |= DW_IC_CON_SPEED_STD;
+		break;
+	case 3400000:
+		dev->master_cfg |= DW_IC_CON_SPEED_HIGH;
+		break;
+	default:
+		dev->master_cfg |= DW_IC_CON_SPEED_FAST;
+	}
+}
+
 static int i2c_dw_plat_prepare_clk(struct dw_i2c_dev *i_dev, bool prepare)
 {
 	if (IS_ERR(i_dev->clk))
@@ -287,19 +304,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 
 	dev->functionality = I2C_FUNC_10BIT_ADDR | DW_IC_DEFAULT_FUNCTIONALITY;
 
-	dev->master_cfg = DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
-			  DW_IC_CON_RESTART_EN;
-
-	switch (dev->clk_freq) {
-	case 100000:
-		dev->master_cfg |= DW_IC_CON_SPEED_STD;
-		break;
-	case 3400000:
-		dev->master_cfg |= DW_IC_CON_SPEED_HIGH;
-		break;
-	default:
-		dev->master_cfg |= DW_IC_CON_SPEED_FAST;
-	}
+	i2c_dw_configure_master(dev);
 
 	dev->clk = devm_clk_get(&pdev->dev, NULL);
 	if (!i2c_dw_plat_prepare_clk(dev, true)) {

commit e393f674c5fedced24432138a8fc40c3d7a628b8
Author: Luis Oliveira <Luis.Oliveira@synopsys.com>
Date:   Wed Jun 14 11:43:21 2017 +0100

    i2c: designware: Cleaning and comment style fixes.
    
    The purpose of this commit is to fix some comments and styling in the
    existing code due to the need of reuse this code. What is being made
    here is:
    
    - Sorted the headers files
    - Corrected some comments style (capital letters, lowcase i2c)
    - Reverse tree in the variables declaration
    - Add/remove empty lines and tabs where needed
    - Fix of misspelled word "endianness" and "transferred"
    - Replaced the return variable "r" with the more standard "ret"
    
    The value of this, besides the rules of coding style, is because I
    will use this code after and it will make my future patch a lot bigger and
    complicated to review. The work here won't bring any additional work to
    backported fixes because is just style and reordering.
    
    Signed-off-by: Luis Oliveira <lolivei@synopsys.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index d1263b82d646..613dfb88307f 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -21,27 +21,28 @@
  * ----------------------------------------------------------------------------
  *
  */
-#include <linux/kernel.h>
-#include <linux/module.h>
+#include <linux/acpi.h>
+#include <linux/clk-provider.h>
+#include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/dmi.h>
-#include <linux/i2c.h>
-#include <linux/clk.h>
-#include <linux/clk-provider.h>
-#include <linux/errno.h>
-#include <linux/sched.h>
 #include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
 #include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/of.h>
+#include <linux/platform_data/i2c-designware.h>
 #include <linux/platform_device.h>
 #include <linux/pm.h>
 #include <linux/pm_runtime.h>
 #include <linux/property.h>
-#include <linux/io.h>
 #include <linux/reset.h>
+#include <linux/sched.h>
 #include <linux/slab.h>
-#include <linux/acpi.h>
-#include <linux/platform_data/i2c-designware.h>
+
 #include "i2c-designware-core.h"
 
 static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
@@ -209,11 +210,11 @@ static void dw_i2c_set_fifo_size(struct dw_i2c_dev *dev, int id)
 static int dw_i2c_plat_probe(struct platform_device *pdev)
 {
 	struct dw_i2c_platform_data *pdata = dev_get_platdata(&pdev->dev);
-	struct dw_i2c_dev *dev;
 	struct i2c_adapter *adap;
-	struct resource *mem;
-	int irq, r;
+	struct dw_i2c_dev *dev;
 	u32 acpi_speed, ht = 0;
+	struct resource *mem;
+	int irq, ret;
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
@@ -276,12 +277,12 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	    && dev->clk_freq != 1000000 && dev->clk_freq != 3400000) {
 		dev_err(&pdev->dev,
 			"Only 100kHz, 400kHz, 1MHz and 3.4MHz supported");
-		r = -EINVAL;
+		ret = -EINVAL;
 		goto exit_reset;
 	}
 
-	r = i2c_dw_probe_lock_support(dev);
-	if (r)
+	ret = i2c_dw_probe_lock_support(dev);
+	if (ret)
 		goto exit_reset;
 
 	dev->functionality = I2C_FUNC_10BIT_ADDR | DW_IC_DEFAULT_FUNCTIONALITY;
@@ -327,11 +328,11 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 		pm_runtime_enable(&pdev->dev);
 	}
 
-	r = i2c_dw_probe(dev);
-	if (r)
+	ret = i2c_dw_probe(dev);
+	if (ret)
 		goto exit_probe;
 
-	return r;
+	return ret;
 
 exit_probe:
 	if (!dev->pm_disabled)
@@ -339,7 +340,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 exit_reset:
 	if (!IS_ERR_OR_NULL(dev->rst))
 		reset_control_assert(dev->rst);
-	return r;
+	return ret;
 }
 
 static int dw_i2c_plat_remove(struct platform_device *pdev)
@@ -423,7 +424,7 @@ static const struct dev_pm_ops dw_i2c_dev_pm_ops = {
 #define DW_I2C_DEV_PMOPS NULL
 #endif
 
-/* work with hotplug and coldplug */
+/* Work with hotplug and coldplug */
 MODULE_ALIAS("platform:i2c_designware");
 
 static struct platform_driver dw_i2c_driver = {

commit ad258fb918dae8b1ec79a85b4c7f518e4f902869
Author: Jan Kiszka <jan.kiszka@siemens.com>
Date:   Mon May 22 07:46:55 2017 +0200

    i2c: designware: Fix bogus sda_hold_time due to uninitialized vars
    
    We need to initializes those variables to 0 for platforms that do not
    provide ACPI parameters. Otherwise, we set sda_hold_time to random
    values, breaking e.g. Galileo and IOT2000 boards.
    
    Reported-and-tested-by: Linus Torvalds <torvalds@linux-foundation.org>
    Reported-by: Tobias Klausmann <tobias.johannes.klausmann@mni.thm.de>
    Fixes: 9d6408433019 ("i2c: designware: don't infer timings described by ACPI from clock rate")
    Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
    Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 6283b99d2b17..d1263b82d646 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -94,9 +94,9 @@ static void dw_i2c_acpi_params(struct platform_device *pdev, char method[],
 static int dw_i2c_acpi_configure(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
+	u32 ss_ht = 0, fp_ht = 0, hs_ht = 0, fs_ht = 0;
 	acpi_handle handle = ACPI_HANDLE(&pdev->dev);
 	const struct acpi_device_id *id;
-	u32 ss_ht, fp_ht, hs_ht, fs_ht;
 	struct acpi_device *adev;
 	const char *uid;
 

commit 9d6408433019bfae15e2d0d5f4498c4ff70b86c0
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Fri May 19 09:56:40 2017 +0100

    i2c: designware: don't infer timings described by ACPI from clock rate
    
    Commit bd698d24b1b57 ("i2c: designware: Get selected speed mode
    sda-hold-time via ACPI") updated the logic that reads the timing
    parameters for various I2C bus rates from the DSDT, to only read
    the timing parameters for the currently selected mode.
    
    This causes a WARN_ON() splat on platforms that legally omit the clock
    frequency from the ACPI description, because in the new situation, the
    core I2C designware driver still accesses the fields in the driver
    struct that we no longer populate, and proceeds to calculate them from
    the clock frequency. Since the clock frequency is unspecified, the
    driver complains loudly using a WARN_ON().
    
    So revert back to the old situation, where the struct fields for all
    timings are populated, but retain the new logic which chooses the SDA
    hold time from the timing mode that is currently in use.
    
    Fixes: bd698d24b1b57 ("i2c: designware: Get selected speed mode ...")
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Reported-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index f2acd4b6bf01..6283b99d2b17 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -96,6 +96,7 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
 	acpi_handle handle = ACPI_HANDLE(&pdev->dev);
 	const struct acpi_device_id *id;
+	u32 ss_ht, fp_ht, hs_ht, fs_ht;
 	struct acpi_device *adev;
 	const char *uid;
 
@@ -107,23 +108,24 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 	 * Try to get SDA hold time and *CNT values from an ACPI method for
 	 * selected speed modes.
 	 */
+	dw_i2c_acpi_params(pdev, "SSCN", &dev->ss_hcnt, &dev->ss_lcnt, &ss_ht);
+	dw_i2c_acpi_params(pdev, "FPCN", &dev->fp_hcnt, &dev->fp_lcnt, &fp_ht);
+	dw_i2c_acpi_params(pdev, "HSCN", &dev->hs_hcnt, &dev->hs_lcnt, &hs_ht);
+	dw_i2c_acpi_params(pdev, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt, &fs_ht);
+
 	switch (dev->clk_freq) {
 	case 100000:
-		dw_i2c_acpi_params(pdev, "SSCN", &dev->ss_hcnt, &dev->ss_lcnt,
-				   &dev->sda_hold_time);
+		dev->sda_hold_time = ss_ht;
 		break;
 	case 1000000:
-		dw_i2c_acpi_params(pdev, "FPCN", &dev->fp_hcnt, &dev->fp_lcnt,
-				   &dev->sda_hold_time);
+		dev->sda_hold_time = fp_ht;
 		break;
 	case 3400000:
-		dw_i2c_acpi_params(pdev, "HSCN", &dev->hs_hcnt, &dev->hs_lcnt,
-				   &dev->sda_hold_time);
+		dev->sda_hold_time = hs_ht;
 		break;
 	case 400000:
 	default:
-		dw_i2c_acpi_params(pdev, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt,
-				   &dev->sda_hold_time);
+		dev->sda_hold_time = fs_ht;
 		break;
 	}
 

commit dc9edaab90de9441cc28ac570b23b0d2bdba7879
Merge: 2e4ab937ec49 46436eb2f9e6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed May 10 09:35:42 2017 -0700

    Merge tag 'acpi-extra-4.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more ACPI updates from Rafael Wysocki:
     "These update the ACPICA code in the kernel to upstream revision
      20170303 which adds a few minor fixes and improvements, update ACPI
      SoC drivers with new device IDs, platform-related information and
      similar, fix the register information in the xpower PMIC driver,
      introduce a concept of "always present" devices to the ACPI device
      enumeration code and use it to fix a problem with one platform, and
      fix a system resume issue related to power resources.
    
      Specifics:
    
       - Update the ACPICA code in the kernel to upstream revision 20170303
         which includes:
          * Minor fixes and improvements in the core code (Bob Moore,
            Seunghun Han).
          * Debugger fixes (Colin Ian King, Lv Zheng).
          * Compiler/disassembler improvements (Bob Moore, David Box, Lv
            Zheng).
          * Build-related update (Lv Zheng).
    
       - Add new device IDs and platform-related information to the ACPI
         drivers for Intel (LPSS) and AMD (APD) SoCs (Hanjun Guo, Hans de
         Goede).
    
       - Make it possible to quirk ACPI-enumerated devices as "always
         present" on platforms where they are incorrectly reported as not
         present by the AML and add the INT0002 device ID to the list of
         "always present" devices (Hans de Goede).
    
       - Fix the register information in the xpower PMIC driver and add
         comments to map the registers to symbols used by AML to it (Hans de
         Goede).
    
       - Move the code turning off unused ACPI power resources during system
         resume to a point after all devices have been resumed to avoid
         issues with power resources that do not behave as expected (Hans de
         Goede)"
    
    * tag 'acpi-extra-4.12-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (22 commits)
      ACPI / power: Delay turning off unused power resources after suspend
      ACPI / PMIC: xpower: Fix power_table addresses
      ACPI / LPSS: Call pwm_add_table() for Bay Trail PWM device
      ACPICA: Update version to 20170303
      ACPICA: iasl: add ASL conversion tool
      ACPICA: Local cache support: Allow small cache objects
      ACPICA: Disassembler: Do not unconditionally remove temporary names
      ACPICA: iasl: Fix IORT SMMU GSI disassembling
      ACPICA: Cleanup AML opcode definitions, no functional change
      ACPICA: Debugger: Add interpreter blocking mark for single-step mode
      ACPICA: debugger: fix memory leak on Pathname
      ACPICA: Update for automatic repair code for objects returned by evaluate_object
      ACPICA: Namespace: fix operand cache leak
      ACPICA: Fix several incorrect invocations of ACPICA return macro
      ACPICA: Fix a module for excessive debug output
      ACPICA: Update some function headers, no funtional change
      ACPICA: Disassembler: Enhance resource descriptor detection
      i2c: designware: Add ACPI HID for Hisilicon Hip07/08 I2C controller
      ACPI / APD: Add clock frequency for Hisilicon Hip07/08 I2C controller
      ACPI / bus: Add INT0002 to list of always-present devices
      ...

commit 58dd8abfad028633d36e2ba81109bd62f6e6e215
Author: Hanjun Guo <hanjun.guo@linaro.org>
Date:   Sat Apr 22 11:23:44 2017 +0800

    i2c: designware: Add ACPI HID for Hisilicon Hip07/08 I2C controller
    
    Add ACPI HID HISI02A1 and HISI02A2 for Hisilicon Hip07/08,
    which have different clock frequency.
    
    Signed-off-by: Hanjun Guo <hanjun.guo@linaro.org>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 79c4b4ea0539..90c7c101b7fd 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -129,6 +129,8 @@ static const struct acpi_device_id dw_i2c_acpi_match[] = {
 	{ "AMDI0010", ACCESS_INTR_MASK },
 	{ "AMDI0510", 0 },
 	{ "APMC0D0F", 0 },
+	{ "HISI02A1", 0 },
+	{ "HISI02A2", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(acpi, dw_i2c_acpi_match);

commit bd698d24b1b5790d0a22d44a0705dabd47235ad4
Author: chin.yew.tan@intel.com <chin.yew.tan@intel.com>
Date:   Tue Mar 28 16:48:02 2017 +0800

    i2c: designware: Get selected speed mode sda-hold-time via ACPI
    
    Sda-hold-time is an important parameter for tuning i2c to meet the
    electrical specification especially for high speed. I2C with incorrect
    sda-hold-time may cause lost arbitration error. Instead of loading all
    speed mode settings, only selected speed mode settings are loaded.
    
    Signed-off-by: Tan Chin Yew <chin.yew.tan@intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index a597ba32de7e..5a4eb6b6bd92 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -85,8 +85,7 @@ static void dw_i2c_acpi_params(struct platform_device *pdev, char method[],
 
 		*hcnt = (u16)objs[0].integer.value;
 		*lcnt = (u16)objs[1].integer.value;
-		if (sda_hold)
-			*sda_hold = (u32)objs[2].integer.value;
+		*sda_hold = (u32)objs[2].integer.value;
 	}
 
 	kfree(buf.pointer);
@@ -105,14 +104,28 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 	dev->rx_fifo_depth = 32;
 
 	/*
-	 * Try to get SDA hold time and *CNT values from an ACPI method if
-	 * it exists for both supported speed modes.
+	 * Try to get SDA hold time and *CNT values from an ACPI method for
+	 * selected speed modes.
 	 */
-	dw_i2c_acpi_params(pdev, "SSCN", &dev->ss_hcnt, &dev->ss_lcnt, NULL);
-	dw_i2c_acpi_params(pdev, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt,
-			   &dev->sda_hold_time);
-	dw_i2c_acpi_params(pdev, "FPCN", &dev->fp_hcnt, &dev->fp_lcnt, NULL);
-	dw_i2c_acpi_params(pdev, "HSCN", &dev->hs_hcnt, &dev->hs_lcnt, NULL);
+	switch (dev->clk_freq) {
+	case 100000:
+		dw_i2c_acpi_params(pdev, "SSCN", &dev->ss_hcnt, &dev->ss_lcnt,
+				   &dev->sda_hold_time);
+		break;
+	case 1000000:
+		dw_i2c_acpi_params(pdev, "FPCN", &dev->fp_hcnt, &dev->fp_lcnt,
+				   &dev->sda_hold_time);
+		break;
+	case 3400000:
+		dw_i2c_acpi_params(pdev, "HSCN", &dev->hs_hcnt, &dev->hs_lcnt,
+				   &dev->sda_hold_time);
+		break;
+	case 400000:
+	default:
+		dw_i2c_acpi_params(pdev, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt,
+				   &dev->sda_hold_time);
+		break;
+	}
 
 	id = acpi_match_device(pdev->dev.driver->acpi_match_table, &pdev->dev);
 	if (id && id->driver_data)

commit a3d411fb38c0472ce96aea58062db87cc9357780
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Mar 13 23:25:10 2017 +0100

    i2c: designware: Disable pm for PMIC i2c-bus even if there is no _SEM method
    
    Cherrytrail devices use the dw i2c-bus with uid 7 to access their PMIC.
    Even if the i2c-bus to the PMIC is not shared with the SoC's P-Unit
    and i2c-designware-baytrail.c thus does not set the pm_disabled flag,
    we still need to disable pm so that ACPI PMIC opregions can access the
    PMIC during late-suspend and early-resume.
    
    This fixes errors like these blocking suspend:
    
      i2c_designware 808622C1:06: timeout waiting for bus ready
      ACPI Exception: AE_ERROR, Returned by Handler for [UserDefinedRegion]
      acpi 80860F14:02: Failed to change power state to D3hot
      PM: late suspend of devices failed
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 0b6f6dc671a8..a597ba32de7e 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -95,7 +95,10 @@ static void dw_i2c_acpi_params(struct platform_device *pdev, char method[],
 static int dw_i2c_acpi_configure(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
+	acpi_handle handle = ACPI_HANDLE(&pdev->dev);
 	const struct acpi_device_id *id;
+	struct acpi_device *adev;
+	const char *uid;
 
 	dev->adapter.nr = -1;
 	dev->tx_fifo_depth = 32;
@@ -115,6 +118,18 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 	if (id && id->driver_data)
 		dev->flags |= (u32)id->driver_data;
 
+	if (acpi_bus_get_device(handle, &adev))
+		return -ENODEV;
+
+	/*
+	 * Cherrytrail I2C7 gets used for the PMIC which gets accessed
+	 * through ACPI opregions during late suspend / early resume
+	 * disable pm for it.
+	 */
+	uid = adev->pnp.unique_id;
+	if ((dev->flags & MODEL_CHERRYTRAIL) && !strcmp(uid, "7"))
+		dev->pm_disabled = true;
+
 	return 0;
 }
 

commit 41c80b8a63bccf9de96698b4eb0916e223fb6e72
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Mar 13 23:25:09 2017 +0100

    i2c: designware: Never suspend i2c-busses used for accessing the system PMIC
    
    Currently we are already setting a pm_runtime_disabled flag and disabling
    runtime-pm for i2c-busses used for accessing the system PMIC on x86.
    But this is not enough, there are ACPI opregions which may want to access
    the PMIC during late-suspend and early-resume, so we need to completely
    disable pm to be safe.
    
    This commit renames the flag from pm_runtime_disabled to pm_disabled and
    adds the following new behavior if the flag is set:
    
    1) Call dev_pm_syscore_device(dev, true) which disables normal suspend /
       resume and remove the pm_runtime_disabled check from dw_i2c_plat_resume
       since that will now never get called. This fixes suspend_late handlers
       which use ACPI PMIC opregions causing errors like these:
    
      PM: Suspending system (freeze)
      PM: suspend of devices complete after 1127.751 msecs
      i2c_designware 808622C1:06: timeout waiting for bus ready
      ACPI Exception: AE_ERROR, Returned by Handler for [UserDefinedRegion]
      acpi 80860F14:02: Failed to change power state to D3hot
      PM: late suspend of devices failed
    
    2) Set IRQF_NO_SUSPEND irq flag. This fixes resume_early handlers which
       handlers which use ACPI PMIC opregions causing errors like these:
    
      PM: resume from suspend-to-idle
      i2c_designware 808622C1:06: controller timed out
      ACPI Exception: AE_ERROR, Returned by Handler for [UserDefinedRegion]
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index d8665098dce9..0b6f6dc671a8 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -286,7 +286,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	ACPI_COMPANION_SET(&adap->dev, ACPI_COMPANION(&pdev->dev));
 	adap->dev.of_node = pdev->dev.of_node;
 
-	if (dev->pm_runtime_disabled) {
+	if (dev->pm_disabled) {
 		pm_runtime_forbid(&pdev->dev);
 	} else {
 		pm_runtime_set_autosuspend_delay(&pdev->dev, 1000);
@@ -302,7 +302,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	return r;
 
 exit_probe:
-	if (!dev->pm_runtime_disabled)
+	if (!dev->pm_disabled)
 		pm_runtime_disable(&pdev->dev);
 exit_reset:
 	if (!IS_ERR_OR_NULL(dev->rst))
@@ -322,7 +322,7 @@ static int dw_i2c_plat_remove(struct platform_device *pdev)
 
 	pm_runtime_dont_use_autosuspend(&pdev->dev);
 	pm_runtime_put_sync(&pdev->dev);
-	if (!dev->pm_runtime_disabled)
+	if (!dev->pm_disabled)
 		pm_runtime_disable(&pdev->dev);
 	if (!IS_ERR_OR_NULL(dev->rst))
 		reset_control_assert(dev->rst);
@@ -374,9 +374,7 @@ static int dw_i2c_plat_resume(struct device *dev)
 	struct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);
 
 	i2c_dw_plat_prepare_clk(i_dev, true);
-
-	if (!i_dev->pm_runtime_disabled)
-		i2c_dw_init(i_dev);
+	i2c_dw_init(i_dev);
 
 	return 0;
 }

commit a528fab6cc66acdccb48552a79300bc1fbda6b5b
Merge: 97da3854c526 264ec1a8221c
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Wed Mar 22 09:32:44 2017 +0100

    Merge tag 'topic/designware-baytrail-2017-03-02' of git://anongit.freedesktop.org/git/drm-intel into i2c/for-next
    
    Pull immutable branch as a common base for further development:
    
    "Baytrail PMIC vs. PMU race fixes from Hans de Goede
    
    This time the right version (v4), with the compile fix."

commit ab809fd81fde3d416f8656d8f814a0777fb9b65e
Author: Zhangfei Gao <zhangfei.gao@linaro.org>
Date:   Tue Dec 27 22:22:40 2016 +0800

    i2c: designware: add reset interface
    
    Some platforms like hi3660 need do reset first to allow accessing registers
    
    Signed-off-by: Zhangfei Gao <zhangfei.gao@linaro.org>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Tested-by: Ramiro Oliveira <ramiro.oliveira@synopsys.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 6ce431323125..79c4b4ea0539 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -38,6 +38,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/property.h>
 #include <linux/io.h>
+#include <linux/reset.h>
 #include <linux/slab.h>
 #include <linux/acpi.h>
 #include <linux/platform_data/i2c-designware.h>
@@ -199,6 +200,14 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	dev->irq = irq;
 	platform_set_drvdata(pdev, dev);
 
+	dev->rst = devm_reset_control_get_optional_exclusive(&pdev->dev, NULL);
+	if (IS_ERR(dev->rst)) {
+		if (PTR_ERR(dev->rst) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+	} else {
+		reset_control_deassert(dev->rst);
+	}
+
 	if (pdata) {
 		dev->clk_freq = pdata->i2c_scl_freq;
 	} else {
@@ -235,12 +244,13 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	    && dev->clk_freq != 1000000 && dev->clk_freq != 3400000) {
 		dev_err(&pdev->dev,
 			"Only 100kHz, 400kHz, 1MHz and 3.4MHz supported");
-		return -EINVAL;
+		r = -EINVAL;
+		goto exit_reset;
 	}
 
 	r = i2c_dw_eval_lock_support(dev);
 	if (r)
-		return r;
+		goto exit_reset;
 
 	dev->functionality = I2C_FUNC_10BIT_ADDR | DW_IC_DEFAULT_FUNCTIONALITY;
 
@@ -286,10 +296,18 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	}
 
 	r = i2c_dw_probe(dev);
-	if (r && !dev->pm_runtime_disabled)
-		pm_runtime_disable(&pdev->dev);
+	if (r)
+		goto exit_probe;
 
 	return r;
+
+exit_probe:
+	if (!dev->pm_runtime_disabled)
+		pm_runtime_disable(&pdev->dev);
+exit_reset:
+	if (!IS_ERR_OR_NULL(dev->rst))
+		reset_control_assert(dev->rst);
+	return r;
 }
 
 static int dw_i2c_plat_remove(struct platform_device *pdev)
@@ -306,6 +324,8 @@ static int dw_i2c_plat_remove(struct platform_device *pdev)
 	pm_runtime_put_sync(&pdev->dev);
 	if (!dev->pm_runtime_disabled)
 		pm_runtime_disable(&pdev->dev);
+	if (!IS_ERR_OR_NULL(dev->rst))
+		reset_control_assert(dev->rst);
 
 	return 0;
 }

commit fd476fa22a1f432658b799b023f351f291f2db8b
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Feb 10 11:27:58 2017 +0100

    i2c: designware-baytrail: Add support for cherrytrail
    
    The cherrytrail punit has the pmic i2c bus access semaphore at a
    different register address.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Takashi Iwai <tiwai@suse.de>
    Tested-by: Takashi Iwai <tiwai@suse.de>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170210102802.20898-9-hdegoede@redhat.com

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index d474db074b1a..df0ff7d82b49 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -123,7 +123,7 @@ static const struct acpi_device_id dw_i2c_acpi_match[] = {
 	{ "INT3432", 0 },
 	{ "INT3433", 0 },
 	{ "80860F41", 0 },
-	{ "808622C1", 0 },
+	{ "808622C1", MODEL_CHERRYTRAIL },
 	{ "AMD0010", ACCESS_INTR_MASK },
 	{ "AMDI0010", ACCESS_INTR_MASK },
 	{ "AMDI0510", 0 },

commit 086cb4afef45262806ee5bf26c34244e5867712c
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Feb 10 11:27:56 2017 +0100

    i2c: designware-baytrail: Disallow the CPU to enter C6 or C7 while holding the punit semaphore
    
    On my cherrytrail tablet with axp288 pmic, just doing a bunch of repeated
    reads from the pmic, e.g. "i2cdump -y 14 0x34" would lookup the tablet in
    1 - 3 runs guaranteed.
    
    This seems to be causes by the cpu trying to enter C6 or C7 while we hold
    the punit bus semaphore, at which point everything just hangs.
    
    Avoid this by disallowing the CPU to enter C6 or C7 before acquiring the
    punit bus semaphore.
    
    BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=109051
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Tested-by: Takashi Iwai <tiwai@suse.de>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170210102802.20898-7-hdegoede@redhat.com

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 3eede7b0904b..d474db074b1a 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -238,7 +238,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
-	r = i2c_dw_eval_lock_support(dev);
+	r = i2c_dw_probe_lock_support(dev);
 	if (r)
 		return r;
 
@@ -307,6 +307,8 @@ static int dw_i2c_plat_remove(struct platform_device *pdev)
 	if (!dev->pm_runtime_disabled)
 		pm_runtime_disable(&pdev->dev);
 
+	i2c_dw_remove_lock_support(dev);
+
 	return 0;
 }
 

commit 86524e54025f4ffb0a2e4966ad244424a080329f
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Fri Feb 10 11:27:53 2017 +0100

    i2c: designware: Rename accessor_flags to flags
    
    Rename accessor_flags to flags, so that we can use the field for
    other flags too. This is a preparation patch for adding cherrytrail
    support to the punit semaphore code.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Tested-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Link: http://patchwork.freedesktop.org/patch/msgid/20170210102802.20898-4-hdegoede@redhat.com

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 6ce431323125..3eede7b0904b 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -112,7 +112,7 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 
 	id = acpi_match_device(pdev->dev.driver->acpi_match_table, &pdev->dev);
 	if (id && id->driver_data)
-		dev->accessor_flags |= (u32)id->driver_data;
+		dev->flags |= (u32)id->driver_data;
 
 	return 0;
 }

commit 8e598769c55dd6c442a1c6cbd21e7abda2a52215
Author: Tin Huynh <tnhuynh@apm.com>
Date:   Wed Dec 14 16:23:58 2016 +0700

    i2c: designware: fix wrong Tx/Rx FIFO for ACPI
    
    ACPI always sets Tx/Rx FIFO to 32. This configuration will
    cause problem if the IP core supports a FIFO size of less than 32.
    The driver should read the FIFO size from the IP and select the smaller
    one of the two.
    
    Signed-off-by: Tin Huynh <tnhuynh@apm.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 08153ea4d848..6ce431323125 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -150,6 +150,29 @@ static int i2c_dw_plat_prepare_clk(struct dw_i2c_dev *i_dev, bool prepare)
 	return 0;
 }
 
+static void dw_i2c_set_fifo_size(struct dw_i2c_dev *dev, int id)
+{
+	u32 param, tx_fifo_depth, rx_fifo_depth;
+
+	/*
+	 * Try to detect the FIFO depth if not set by interface driver,
+	 * the depth could be from 2 to 256 from HW spec.
+	 */
+	param = i2c_dw_read_comp_param(dev);
+	tx_fifo_depth = ((param >> 16) & 0xff) + 1;
+	rx_fifo_depth = ((param >> 8)  & 0xff) + 1;
+	if (!dev->tx_fifo_depth) {
+		dev->tx_fifo_depth = tx_fifo_depth;
+		dev->rx_fifo_depth = rx_fifo_depth;
+		dev->adapter.nr = id;
+	} else if (tx_fifo_depth >= 2) {
+		dev->tx_fifo_depth = min_t(u32, dev->tx_fifo_depth,
+				tx_fifo_depth);
+		dev->rx_fifo_depth = min_t(u32, dev->rx_fifo_depth,
+				rx_fifo_depth);
+	}
+}
+
 static int dw_i2c_plat_probe(struct platform_device *pdev)
 {
 	struct dw_i2c_platform_data *pdata = dev_get_platdata(&pdev->dev);
@@ -245,13 +268,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 				1000000);
 	}
 
-	if (!dev->tx_fifo_depth) {
-		u32 param1 = i2c_dw_read_comp_param(dev);
-
-		dev->tx_fifo_depth = ((param1 >> 16) & 0xff) + 1;
-		dev->rx_fifo_depth = ((param1 >> 8)  & 0xff) + 1;
-		dev->adapter.nr = pdev->id;
-	}
+	dw_i2c_set_fifo_size(dev, pdev->id);
 
 	adap = &dev->adapter;
 	adap->owner = THIS_MODULE;

commit f06122f0bdd0d3c851c452f7c11a3a2198221fdd
Author: Alexander Stein <alexander.stein@systec-electronic.com>
Date:   Mon Nov 21 11:43:20 2016 +0100

    i2c: designware: Consolidate default functionality bits
    
    Use a common place for default functionality bits for both platform
    and pci driver.
    
    Signed-off-by: Alexander Stein <alexander.stein@systec-electronic.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 7429dfa39440..08153ea4d848 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -219,14 +219,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	if (r)
 		return r;
 
-	dev->functionality =
-		I2C_FUNC_I2C |
-		I2C_FUNC_10BIT_ADDR |
-		I2C_FUNC_SMBUS_BYTE |
-		I2C_FUNC_SMBUS_BYTE_DATA |
-		I2C_FUNC_SMBUS_WORD_DATA |
-		I2C_FUNC_SMBUS_BLOCK_DATA |
-		I2C_FUNC_SMBUS_I2C_BLOCK;
+	dev->functionality = I2C_FUNC_10BIT_ADDR | DW_IC_DEFAULT_FUNCTIONALITY;
 
 	dev->master_cfg = DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
 			  DW_IC_CON_RESTART_EN;

commit 973652db6f1406e556613b7bb252f1a005005f04
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Thu Nov 10 13:37:20 2016 +0200

    i2c: designware: Allow reduce bus speed by "clock-frequency" property
    
    Allow more flexibility to bus speed selection. Now if there are I2C
    slave connections defined in ACPI the speed of slowest device on the bus
    will define the bus speed. However if also "clock-frequency" device
    property is defined we should use the slowest of these two.
    
    This is targeted to maker boards where developer may want to connect
    slower I2C slave devices to the bus than defined in existing ACPI I2C
    slave connections.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 886fb622ca38..7429dfa39440 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -176,9 +176,6 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	dev->irq = irq;
 	platform_set_drvdata(pdev, dev);
 
-	/* fast mode by default because of legacy reasons */
-	dev->clk_freq = 400000;
-
 	if (pdata) {
 		dev->clk_freq = pdata->i2c_scl_freq;
 	} else {
@@ -193,8 +190,16 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	}
 
 	acpi_speed = i2c_acpi_find_bus_speed(&pdev->dev);
-	if (acpi_speed)
-		dev->clk_freq = acpi_speed;
+	/*
+	 * Find bus speed from the "clock-frequency" device property, ACPI
+	 * or by using fast mode if neither is set.
+	 */
+	if (acpi_speed && dev->clk_freq)
+		dev->clk_freq = min(dev->clk_freq, acpi_speed);
+	else if (acpi_speed || dev->clk_freq)
+		dev->clk_freq = max(dev->clk_freq, acpi_speed);
+	else
+		dev->clk_freq = 400000;
 
 	if (has_acpi_companion(&pdev->dev))
 		dw_i2c_acpi_configure(pdev);

commit c3ae106050b949d6c776c5434046c888a5a6298a
Author: Tin Huynh <tnhuynh@apm.com>
Date:   Thu Nov 10 09:56:33 2016 +0700

    i2c: designware: Implement support for SMBus block read and write
    
    Free and Open IPMI use SMBUS BLOCK Read/Write to support SSIF protocol.
    However, I2C Designware Core Driver doesn't handle the case at the moment.
    The below patch supports this feature.
    
    Signed-off-by: Tin Huynh <tnhuynh@apm.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 0b42a12171f3..886fb622ca38 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -220,6 +220,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 		I2C_FUNC_SMBUS_BYTE |
 		I2C_FUNC_SMBUS_BYTE_DATA |
 		I2C_FUNC_SMBUS_WORD_DATA |
+		I2C_FUNC_SMBUS_BLOCK_DATA |
 		I2C_FUNC_SMBUS_I2C_BLOCK;
 
 	dev->master_cfg = DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |

commit 10f8e7fb371c9e575e772bc6fcc385dc973f6e87
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri Aug 12 17:02:54 2016 +0300

    i2c: designware: Find bus speed from ACPI
    
    Fast mode is the default speed of i2c-designware which can be overridden
    by platform data or by "clock-frequency" device property. Even though
    the ACPI 5.1 can pass device properties via _DSD method, shipping systems
    define the connection speed between I2C host and each slave in their
    I2cSerialBus resources. Which means speed is not defined per bus but per
    slave.
    
    As there is now support in i2c-core to find the bus speed from ACPI use
    that to set up the bus speed prior registering the I2C adapter.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index cb846cb50512..0b42a12171f3 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -157,7 +157,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	struct i2c_adapter *adap;
 	struct resource *mem;
 	int irq, r;
-	u32 ht = 0;
+	u32 acpi_speed, ht = 0;
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
@@ -192,6 +192,10 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 					 &dev->clk_freq);
 	}
 
+	acpi_speed = i2c_acpi_find_bus_speed(&pdev->dev);
+	if (acpi_speed)
+		dev->clk_freq = acpi_speed;
+
 	if (has_acpi_companion(&pdev->dev))
 		dw_i2c_acpi_configure(pdev);
 

commit b6e67145f14903ca430e011db3b771d8de4c3d8a
Author: Weifeng Voon <weifeng.voon@intel.com>
Date:   Fri Aug 12 17:02:51 2016 +0300

    i2c: designware: Enable high speed mode
    
    This patch enabled high speed mode. High speed mode can be turn on by
    setting the clk_freq to 3400000. High speed HCNT and LCNT are needed
    as there is no default value provided.
    
    Signed-off-by: Weifeng Voon <weifeng.voon@intel.com>
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index d45481ee1b56..cb846cb50512 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -197,12 +197,12 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 
 	/*
 	 * Only standard mode at 100kHz, fast mode at 400kHz,
-	 * and fast mode plus at 1MHz are supported.
+	 * fast mode plus at 1MHz and high speed mode at 3.4MHz are supported.
 	 */
 	if (dev->clk_freq != 100000 && dev->clk_freq != 400000
-	    && dev->clk_freq != 1000000) {
+	    && dev->clk_freq != 1000000 && dev->clk_freq != 3400000) {
 		dev_err(&pdev->dev,
-			"Only 100kHz, 400kHz and 1MHz are supported");
+			"Only 100kHz, 400kHz, 1MHz and 3.4MHz supported");
 		return -EINVAL;
 	}
 
@@ -221,10 +221,16 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	dev->master_cfg = DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
 			  DW_IC_CON_RESTART_EN;
 
-	if (dev->clk_freq == 100000)
+	switch (dev->clk_freq) {
+	case 100000:
 		dev->master_cfg |= DW_IC_CON_SPEED_STD;
-	else
+		break;
+	case 3400000:
+		dev->master_cfg |= DW_IC_CON_SPEED_HIGH;
+		break;
+	default:
 		dev->master_cfg |= DW_IC_CON_SPEED_FAST;
+	}
 
 	dev->clk = devm_clk_get(&pdev->dev, NULL);
 	if (!i2c_dw_plat_prepare_clk(dev, true)) {

commit 548e6695d16d201f390f7554ae7d0b5bb8690166
Author: Weifeng Voon <weifeng.voon@intel.com>
Date:   Fri Aug 12 17:02:50 2016 +0300

    i2c: designware: set the common config before the if else
    
    DW_IC_CON_MASTER, DW_IC_CON_SLAVE_DISABLE and DW_IC_CON_RESTART_EN are
    common config that need to be set for i2c designware master. So, configure
    it first without having to repeat inside the if else.
    
    Signed-off-by: Weifeng Voon <weifeng.voon@intel.com>
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index ea92e9f3fba1..d45481ee1b56 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -217,12 +217,14 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 		I2C_FUNC_SMBUS_BYTE_DATA |
 		I2C_FUNC_SMBUS_WORD_DATA |
 		I2C_FUNC_SMBUS_I2C_BLOCK;
+
+	dev->master_cfg = DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
+			  DW_IC_CON_RESTART_EN;
+
 	if (dev->clk_freq == 100000)
-		dev->master_cfg =  DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
-			DW_IC_CON_RESTART_EN | DW_IC_CON_SPEED_STD;
+		dev->master_cfg |= DW_IC_CON_SPEED_STD;
 	else
-		dev->master_cfg =  DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
-			DW_IC_CON_RESTART_EN | DW_IC_CON_SPEED_FAST;
+		dev->master_cfg |= DW_IC_CON_SPEED_FAST;
 
 	dev->clk = devm_clk_get(&pdev->dev, NULL);
 	if (!i2c_dw_plat_prepare_clk(dev, true)) {

commit d608c3d9ac818fc0addc884144c7550e03b0fc6f
Author: Weifeng Voon <weifeng.voon@intel.com>
Date:   Fri Aug 12 17:02:49 2016 +0300

    i2c: designware: Enable fast mode plus
    
    This patch enabled fast mode plus. The fast mode plus and fast speed
    share the same HCNT and LCNT register. So, the fast mode plus will only
    run when the HCNT and LCNT value is provided. Else, it will run at fast
    speed as default.
    
    Signed-off-by: Weifeng Voon <weifeng.voon@intel.com>
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index cbe4fb31cb4b..ea92e9f3fba1 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -196,10 +196,13 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 		dw_i2c_acpi_configure(pdev);
 
 	/*
-	 * Only standard mode at 100kHz and fast mode at 400kHz are supported.
+	 * Only standard mode at 100kHz, fast mode at 400kHz,
+	 * and fast mode plus at 1MHz are supported.
 	 */
-	if (dev->clk_freq != 100000 && dev->clk_freq != 400000) {
-		dev_err(&pdev->dev, "Only 100kHz and 400kHz supported");
+	if (dev->clk_freq != 100000 && dev->clk_freq != 400000
+	    && dev->clk_freq != 1000000) {
+		dev_err(&pdev->dev,
+			"Only 100kHz, 400kHz and 1MHz are supported");
 		return -EINVAL;
 	}
 

commit a92ec1746f10e339220bf186c4f6cce531b8a7ee
Author: Weifeng Voon <weifeng.voon@intel.com>
Date:   Fri Aug 12 17:02:48 2016 +0300

    i2c: designware: get fast plus and high speed *CNT configuration
    
    I2C designware controller can run at fast mode plus and high speed. This
    patch adds the capability to get the HCNT, LCNT configuration via
    FPCN (fast plus) and HSCN (high speed) ACPI method.
    
    Signed-off-by: Weifeng Voon <weifeng.voon@intel.com>
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 1608cf4d3263..cbe4fb31cb4b 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -107,6 +107,8 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 	dw_i2c_acpi_params(pdev, "SSCN", &dev->ss_hcnt, &dev->ss_lcnt, NULL);
 	dw_i2c_acpi_params(pdev, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt,
 			   &dev->sda_hold_time);
+	dw_i2c_acpi_params(pdev, "FPCN", &dev->fp_hcnt, &dev->fp_lcnt, NULL);
+	dw_i2c_acpi_params(pdev, "HSCN", &dev->hs_hcnt, &dev->hs_lcnt, NULL);
 
 	id = acpi_match_device(pdev->dev.driver->acpi_match_table, &pdev->dev);
 	if (id && id->driver_data)

commit 19c0a5399fe46218c2b5a5c17a01cf60f91ff5ae
Author: Weifeng Voon <weifeng.voon@intel.com>
Date:   Fri Aug 12 17:02:47 2016 +0300

    i2c: designware: Move clk_freq into struct dw_i2c_dev
    
    I2c designware controller operate speed is configured in the register
    IC_CON. Previously the operate speed is determined by a local variable
    clk_freq. This patch will move the local variable clk_freq into struct
    dw_i2c_dev. This change will ease the set and get of the clk_freq.
    
    Signed-off-by: Weifeng Voon <weifeng.voon@intel.com>
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index d656657b805c..1608cf4d3263 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -155,7 +155,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	struct i2c_adapter *adap;
 	struct resource *mem;
 	int irq, r;
-	u32 clk_freq, ht = 0;
+	u32 ht = 0;
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
@@ -175,10 +175,10 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, dev);
 
 	/* fast mode by default because of legacy reasons */
-	clk_freq = 400000;
+	dev->clk_freq = 400000;
 
 	if (pdata) {
-		clk_freq = pdata->i2c_scl_freq;
+		dev->clk_freq = pdata->i2c_scl_freq;
 	} else {
 		device_property_read_u32(&pdev->dev, "i2c-sda-hold-time-ns",
 					 &ht);
@@ -187,7 +187,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 		device_property_read_u32(&pdev->dev, "i2c-scl-falling-time-ns",
 					 &dev->scl_falling_time);
 		device_property_read_u32(&pdev->dev, "clock-frequency",
-					 &clk_freq);
+					 &dev->clk_freq);
 	}
 
 	if (has_acpi_companion(&pdev->dev))
@@ -196,7 +196,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	/*
 	 * Only standard mode at 100kHz and fast mode at 400kHz are supported.
 	 */
-	if (clk_freq != 100000 && clk_freq != 400000) {
+	if (dev->clk_freq != 100000 && dev->clk_freq != 400000) {
 		dev_err(&pdev->dev, "Only 100kHz and 400kHz supported");
 		return -EINVAL;
 	}
@@ -212,7 +212,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 		I2C_FUNC_SMBUS_BYTE_DATA |
 		I2C_FUNC_SMBUS_WORD_DATA |
 		I2C_FUNC_SMBUS_I2C_BLOCK;
-	if (clk_freq == 100000)
+	if (dev->clk_freq == 100000)
 		dev->master_cfg =  DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
 			DW_IC_CON_RESTART_EN | DW_IC_CON_SPEED_STD;
 	else

commit e4e666ba74d4f6eff04d3c567b9f2d50a46837e4
Author: Xiangliang Yu <Xiangliang.Yu@amd.com>
Date:   Thu Mar 10 19:34:52 2016 +0800

    i2c: designware: Add device HID for future AMD I2C controller
    
    Add device HID AMDI0010 to match the AMD ACPI Vendor ID (AMDI) that
    was registered in http://www.uefi.org/acpi_id_list, and the I2C
    controller on future AMD paltform will use the HID instead of AMD0010.
    
    Signed-off-by: Xiangliang Yu <Xiangliang.Yu@amd.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 438f1b4964c0..d656657b805c 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -123,6 +123,7 @@ static const struct acpi_device_id dw_i2c_acpi_match[] = {
 	{ "80860F41", 0 },
 	{ "808622C1", 0 },
 	{ "AMD0010", ACCESS_INTR_MASK },
+	{ "AMDI0010", ACCESS_INTR_MASK },
 	{ "AMDI0510", 0 },
 	{ "APMC0D0F", 0 },
 	{ }

commit 32250e4a5fa0b618044afa59fba01093a4bcb14a
Merge: 5339f9d4c2ce c698d639f72b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 14 11:25:37 2016 -0800

    Merge branch 'i2c/for-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux
    
    Pull i2c updates from Wolfram Sang:
     "Quite some driver updates:
       - piix4 can now handle multiplexed adapters
       - brcmstb, xlr, eg20t, designware drivers support more SoCs
       - emev2 gained i2c slave support
       - img-scb and rcar got bigger refactoring to remove issues
       - lots of common driver updates
    
      i2c core changes:
       - new quirk flag when an adapter does not support clock stretching,
         so clients can be configured to avoid that if possible
       - added a helper function to retrieve timing parameters from firmware
         (with rcar being the first user)
       - "multi-master" DT binding added so drivers can adapt to this
         setting (like disabling PM to keep arbitration working)
       - RuntimePM for the logical adapter device is now always enabled by
         the core to ensure propagation from childs to the parent (the HW
         device)
       - new macro builtin_i2c_driver to reduce boilerplate"
    
    * 'i2c/for-4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux: (70 commits)
      i2c: create builtin_i2c_driver to avoid registration boilerplate
      i2c: imx: fix i2c resource leak with dma transfer
      dt-bindings: i2c: eeprom: add another EEPROM device
      dt-bindings: move I2C eeprom descriptions to the proper file
      i2c: designware: Do not require clock when SSCN and FFCN are provided
      DT: i2c: trivial-devices: Add Epson RX8010 and MPL3115
      i2c: s3c2410: remove superfluous runtime PM calls
      i2c: always enable RuntimePM for the adapter device
      i2c: designware: retry transfer on transient failure
      i2c: ibm_iic: rename i2c_timings struct due to clash with generic version
      i2c: designware: Add support for AMD Seattle I2C
      i2c: imx: Remove unneeded comments
      i2c: st: use to_platform_device()
      i2c: designware: use to_pci_dev()
      i2c: brcmstb: Adding support for CM and DSL SoCs
      i2c: mediatek: fix i2c multi transfer issue in high speed mode
      i2c: imx: improve code readability
      i2c: imx: Improve message log when DMA is not used
      i2c: imx: add runtime pm support to improve the performance
      i2c: imx: init bus recovery info before adding i2c adapter
      ...

commit 1e3f28a552c7acf6dd8acfe505beb4990e8cbd55
Merge: 989652871b06 d35818a9153e
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 12 01:08:47 2016 +0100

    Merge branch 'acpi-soc'
    
    * acpi-soc:
      PM / clk: don't leave clocks enabled when driver not bound
      i2c: dw: Add APM X-Gene ACPI I2C device support
      ACPI / APD: Add APM X-Gene ACPI I2C device support
      ACPI / LPSS: change 'does not have' to 'has' in comment
      Revert "dmaengine: dw: platform: provide platform data for Intel"
      dmaengine: dw: return immediately from IRQ when DMA isn't in use
      dmaengine: dw: platform: power on device on shutdown
      ACPI / LPSS: override power state for LPSS DMA device
      ACPI / LPSS: power on when probe() and otherwise when remove()
      ACPI / LPSS: do delay for all LPSS devices when D3->D0
      ACPI / LPSS: allow to use specific PM domain during ->probe()
      Revert "ACPI / LPSS: allow to use specific PM domain during ->probe()"
      device core: add BUS_NOTIFY_DRIVER_NOT_BOUND notification
      x86/platform/iosf_mbi: Remove duplicate definitions
    
    Conflicts:
            drivers/i2c/busses/i2c-designware-platdrv.c

commit 989652871b06f1fb173bc5e8e2ea03bec8f8eeeb
Merge: afd2ff9b7e1b f6740c1899d2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Jan 12 01:07:46 2016 +0100

    Merge branch 'device-properties'
    
    * device-properties:
      device property: avoid allocations of 0 length
      device property: the secondary fwnode needs to depend on the primary
      device property: add spaces to PROPERTY_ENTRY_STRING macro
      include/linux/property.h: fix build issues with gcc-4.4.4
      i2c: designware: Convert to use unified device property API
      mfd: intel-lpss: Pass HSUART configuration via properties
      mfd: intel-lpss: Pass SDA hold time to I2C host controller driver
      mfd: intel-lpss: Add support for passing device properties
      mfd: core: propagate device properties to sub devices drivers
      driver core: Do not overwrite secondary fwnode with NULL if it is set
      driver core: platform: Add support for built-in device properties
      device property: Take a copy of the property set
      device property: Fallback to secondary fwnode if primary misses the property
      device property: return -EINVAL when property isn't found in ACPI
      device property: improve readability of macros
      device property: helper macros for property entry creation
      device property: keep single value inplace
      device property: refactor built-in properties support
      device property: rename helper functions
      device property: always check for fwnode type

commit b33af11de236fd6e25f3716182f008039ec68e93
Author: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
Date:   Mon Jan 4 09:17:35 2016 -0600

    i2c: designware: Do not require clock when SSCN and FFCN are provided
    
    The current driver uses input clock source frequency to calculate
    values for [SS|FS]_[HC|LC] registers. However, when booting ACPI, we do not
    currently have a good way to provide the frequency information.
    Instead, we can leverage the SSCN and FFCN ACPI methods, which can be used
    to directly provide these values. So, the clock information should
    no longer be required during probing.
    
    However, since clk can be invalid, additional checks must be done where
    we are making use of it.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Tested-by: Loc Ho <lho@apm.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 8ffc36b8a6d3..965512c3b1cf 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -128,6 +128,18 @@ static inline int dw_i2c_acpi_configure(struct platform_device *pdev)
 }
 #endif
 
+static int i2c_dw_plat_prepare_clk(struct dw_i2c_dev *i_dev, bool prepare)
+{
+	if (IS_ERR(i_dev->clk))
+		return PTR_ERR(i_dev->clk);
+
+	if (prepare)
+		return clk_prepare_enable(i_dev->clk);
+
+	clk_disable_unprepare(i_dev->clk);
+	return 0;
+}
+
 static int dw_i2c_plat_probe(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev;
@@ -205,16 +217,13 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 			DW_IC_CON_RESTART_EN | DW_IC_CON_SPEED_FAST;
 
 	dev->clk = devm_clk_get(&pdev->dev, NULL);
-	dev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;
-	if (IS_ERR(dev->clk))
-		return PTR_ERR(dev->clk);
-	clk_prepare_enable(dev->clk);
+	if (!i2c_dw_plat_prepare_clk(dev, true)) {
+		dev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;
 
-	if (!dev->sda_hold_time && ht) {
-		u32 ic_clk = dev->get_clk_rate_khz(dev);
-
-		dev->sda_hold_time = div_u64((u64)ic_clk * ht + 500000,
-					     1000000);
+		if (!dev->sda_hold_time && ht)
+			dev->sda_hold_time = div_u64(
+				(u64)dev->get_clk_rate_khz(dev) * ht + 500000,
+				1000000);
 	}
 
 	if (!dev->tx_fifo_depth) {
@@ -297,7 +306,7 @@ static int dw_i2c_plat_suspend(struct device *dev)
 	struct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);
 
 	i2c_dw_disable(i_dev);
-	clk_disable_unprepare(i_dev->clk);
+	i2c_dw_plat_prepare_clk(i_dev, false);
 
 	return 0;
 }
@@ -307,7 +316,7 @@ static int dw_i2c_plat_resume(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);
 
-	clk_prepare_enable(i_dev->clk);
+	i2c_dw_plat_prepare_clk(i_dev, true);
 
 	if (!i_dev->pm_runtime_disabled)
 		i2c_dw_init(i_dev);

commit 04a407f6b129b6e35de3250c313976a3a154476e
Author: Loc Ho <lho@apm.com>
Date:   Thu Dec 10 14:19:17 2015 -0700

    i2c: dw: Add APM X-Gene ACPI I2C device support
    
    Enable APM X-Gene ACPI I2C device support by adding the
    corresponding ACPI ID. The platform ACPI APD corresponding
    change is required to provide the proper clock frequency input.
    
    Signed-off-by: Loc Ho <lho@apm.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 809579ecb5a4..423371d148d5 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -117,6 +117,7 @@ static const struct acpi_device_id dw_i2c_acpi_match[] = {
 	{ "80860F41", 0 },
 	{ "808622C1", 0 },
 	{ "AMD0010", 0 },
+	{ "APMC0D0F", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(acpi, dw_i2c_acpi_match);

commit 90708ce22b4849194d195bad128e94a110426434
Author: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
Date:   Tue Dec 15 15:55:53 2015 -0600

    i2c: designware: Add support for AMD Seattle I2C
    
    Add device HID AMDI0510 to match the I2C controlers on AMD Seattle platform
    
    Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 809579ecb5a4..8ffc36b8a6d3 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -117,6 +117,7 @@ static const struct acpi_device_id dw_i2c_acpi_match[] = {
 	{ "80860F41", 0 },
 	{ "808622C1", 0 },
 	{ "AMD0010", 0 },
+	{ "AMDI0510", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(acpi, dw_i2c_acpi_match);

commit e79e72c5a242fa21c971cfb40017f1039daf4d77
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Thu Dec 10 13:48:43 2015 +0200

    i2c: designware: Keep pm_runtime_enable/_disable calls in sync
    
    On an hardware shared I2C bus (certain Intel Baytrail SoC platforms) the
    runtime PM disable depth keeps increasing over repeated modprobe/rmmod
    cycle because pm_runtime_disable() is called without checking should it
    be disabled already because of bus sharing.
    
    This hasn't made any other harm than dev->power.disable_depth keeps
    increasing but keep it sync by calling pm_runtime_disable() only when
    runtime PM is not disabled.
    
    Reported-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index f03ea71d6519..6b00061c3746 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -245,12 +245,10 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	}
 
 	r = i2c_dw_probe(dev);
-	if (r) {
+	if (r && !dev->pm_runtime_disabled)
 		pm_runtime_disable(&pdev->dev);
-		return r;
-	}
 
-	return 0;
+	return r;
 }
 
 static int dw_i2c_plat_remove(struct platform_device *pdev)
@@ -265,7 +263,8 @@ static int dw_i2c_plat_remove(struct platform_device *pdev)
 
 	pm_runtime_dont_use_autosuspend(&pdev->dev);
 	pm_runtime_put_sync(&pdev->dev);
-	pm_runtime_disable(&pdev->dev);
+	if (!dev->pm_runtime_disabled)
+		pm_runtime_disable(&pdev->dev);
 
 	return 0;
 }

commit 2d244c81481fa5142a2ba6656ab7a8e40c849c27
Author: Xiangliang Yu <Xiangliang.Yu@amd.com>
Date:   Fri Dec 11 20:02:53 2015 +0800

    i2c: designware: fix IO timeout issue for AMD controller
    
    Because of some hardware limitation, AMD I2C controller can't
    trigger pending interrupt if interrupt status has been changed
    after clearing interrupt status bits. Then, I2C will lost
    interrupt and IO timeout.
    
    According to hardware design, this patch implements a workaround
    to disable i2c controller interrupt and re-enable i2c interrupt
    before exiting ISR.
    
    To reduce the performance impacts on other vendors, use unlikely
    function to check flag in ISR.
    
    Signed-off-by: Xiangliang Yu <Xiangliang.Yu@amd.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Cc: stable@kernel.org

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 809579ecb5a4..f03ea71d6519 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -93,6 +93,7 @@ static void dw_i2c_acpi_params(struct platform_device *pdev, char method[],
 static int dw_i2c_acpi_configure(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
+	const struct acpi_device_id *id;
 
 	dev->adapter.nr = -1;
 	dev->tx_fifo_depth = 32;
@@ -106,6 +107,10 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 	dw_i2c_acpi_params(pdev, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt,
 			   &dev->sda_hold_time);
 
+	id = acpi_match_device(pdev->dev.driver->acpi_match_table, &pdev->dev);
+	if (id && id->driver_data)
+		dev->accessor_flags |= (u32)id->driver_data;
+
 	return 0;
 }
 
@@ -116,7 +121,7 @@ static const struct acpi_device_id dw_i2c_acpi_match[] = {
 	{ "INT3433", 0 },
 	{ "80860F41", 0 },
 	{ "808622C1", 0 },
-	{ "AMD0010", 0 },
+	{ "AMD0010", ACCESS_INTR_MASK },
 	{ }
 };
 MODULE_DEVICE_TABLE(acpi, dw_i2c_acpi_match);

commit 4c5301abbf81f4351416cec1e8a02647d96e6fd1
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Nov 30 17:11:44 2015 +0200

    i2c: designware: Convert to use unified device property API
    
    With ACPI _DSD (introduced in ACPI v5.1) it is now possible to pass device
    configuration information from ACPI in addition to DT. In order to support
    this, convert the driver to use the unified device property accessors
    instead of DT specific.
    
    Change to ordering a bit so that we first try platform data and if that's
    not available look from device properties. ACPI *CNT methods are then used
    as last resort to override everything else.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 809579ecb5a4..06061b5a71b3 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -36,6 +36,7 @@
 #include <linux/platform_device.h>
 #include <linux/pm.h>
 #include <linux/pm_runtime.h>
+#include <linux/property.h>
 #include <linux/io.h>
 #include <linux/slab.h>
 #include <linux/acpi.h>
@@ -129,10 +130,10 @@ static inline int dw_i2c_acpi_configure(struct platform_device *pdev)
 
 static int dw_i2c_plat_probe(struct platform_device *pdev)
 {
+	struct dw_i2c_platform_data *pdata = dev_get_platdata(&pdev->dev);
 	struct dw_i2c_dev *dev;
 	struct i2c_adapter *adap;
 	struct resource *mem;
-	struct dw_i2c_platform_data *pdata;
 	int irq, r;
 	u32 clk_freq, ht = 0;
 
@@ -156,33 +157,28 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	/* fast mode by default because of legacy reasons */
 	clk_freq = 400000;
 
-	if (has_acpi_companion(&pdev->dev)) {
-		dw_i2c_acpi_configure(pdev);
-	} else if (pdev->dev.of_node) {
-		of_property_read_u32(pdev->dev.of_node,
-					"i2c-sda-hold-time-ns", &ht);
-
-		of_property_read_u32(pdev->dev.of_node,
-				     "i2c-sda-falling-time-ns",
-				     &dev->sda_falling_time);
-		of_property_read_u32(pdev->dev.of_node,
-				     "i2c-scl-falling-time-ns",
-				     &dev->scl_falling_time);
-
-		of_property_read_u32(pdev->dev.of_node, "clock-frequency",
-				     &clk_freq);
-
-		/* Only standard mode at 100kHz and fast mode at 400kHz
-		 * are supported.
-		 */
-		if (clk_freq != 100000 && clk_freq != 400000) {
-			dev_err(&pdev->dev, "Only 100kHz and 400kHz supported");
-			return -EINVAL;
-		}
+	if (pdata) {
+		clk_freq = pdata->i2c_scl_freq;
 	} else {
-		pdata = dev_get_platdata(&pdev->dev);
-		if (pdata)
-			clk_freq = pdata->i2c_scl_freq;
+		device_property_read_u32(&pdev->dev, "i2c-sda-hold-time-ns",
+					 &ht);
+		device_property_read_u32(&pdev->dev, "i2c-sda-falling-time-ns",
+					 &dev->sda_falling_time);
+		device_property_read_u32(&pdev->dev, "i2c-scl-falling-time-ns",
+					 &dev->scl_falling_time);
+		device_property_read_u32(&pdev->dev, "clock-frequency",
+					 &clk_freq);
+	}
+
+	if (has_acpi_companion(&pdev->dev))
+		dw_i2c_acpi_configure(pdev);
+
+	/*
+	 * Only standard mode at 100kHz and fast mode at 400kHz are supported.
+	 */
+	if (clk_freq != 100000 && clk_freq != 400000) {
+		dev_err(&pdev->dev, "Only 100kHz and 400kHz supported");
+		return -EINVAL;
 	}
 
 	r = i2c_dw_eval_lock_support(dev);

commit d55fc37856244c929965c190c8e9dcb49e2c07aa
Merge: 42d4ebb42a17 75ecc64ef5a1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 10 11:58:25 2015 -0800

    Merge branch 'i2c/for-4.4' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux
    
    Pull i2c updates from Wolfram Sang:
    
     - New drivers: UniPhier (with and without FIFO)
    
     - some drivers got some bigger rework: ismt, designware, img-scb (rcar
       had to be reverted because issues were showing up just lately)
    
     - ACPI: reworked the device scanning and added support for muxes
    
    ... and quite a lot of driver bugfixes and cleanups this time.  All
    files touched outside of the i2c realm have proper acks.
    
    * 'i2c/for-4.4' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux: (70 commits)
      i2c: rcar: Revert the latest refactoring series
      i2c: pnx: remove superfluous assignment
      MAINTAINERS: i2c: drop i2c-pnx maintainer
      MAINTAINERS: i2c: mark also subdirectories as maintained
      i2c: cadence: enable driver for ARM64
      i2c: i801: Document Intel DNV and Broxton
      i2c: at91: manage unexpected RXRDY flag when starting a transfer
      i2c: pnx: Use setup_timer instead of open coding it
      i2c: add ACPI support for I2C mux ports
      acpi: add acpi_preset_companion() stub
      i2c: pxa: Add support for pxa910/988 & new configuration features
      i2c: au1550: Convert to devm_kzalloc and devm_ioremap_resource
      i2c-dev: Fix I2C_SLAVE ioctl comment
      i2c-dev: Fix typo in ioctl name reference
      i2c: sirf: tune the divider to make i2c bus freq more accurate
      i2c: imx: Use -ENXIO as error in the NACK case
      i2c: i801: Add support for Intel Broxton
      i2c: i801: Add support for Intel DNV
      i2c: mediatek: add i2c resume support
      i2c: imx: implement bus recovery
      ...

commit 8eb5c87a92c065aaca39ac3e841b07906a4959a2
Author: Dustin Byford <dustin@cumulusnetworks.com>
Date:   Fri Oct 23 12:27:07 2015 -0700

    i2c: add ACPI support for I2C mux ports
    
    Although I2C mux devices are easily enumerated using ACPI (_HID/_CID or
    device property compatible string match), enumerating I2C client devices
    connected through an I2C mux needs a little extra work.
    
    This change implements a method for describing an I2C device hierarchy that
    includes mux devices by using an ACPI Device() for each mux channel along
    with an _ADR to set the channel number for the device.  See
    Documentation/acpi/i2c-muxes.txt for a simple example.
    
    To make this work the ismt, i801, and designware pci/platform devs now
    share an ACPI companion with their I2C adapter dev similar to how it's done
    in OF.  This is done on the assumption that power management functions will
    not be called directly on the I2C dev that is sharing the ACPI node.
    
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Dustin Byford <dustin@cumulusnetworks.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index f830da6bf25a..190a0d2b94e7 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -207,6 +207,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	adap = &dev->adapter;
 	adap->owner = THIS_MODULE;
 	adap->class = I2C_CLASS_DEPRECATED;
+	ACPI_COMPANION_SET(&adap->dev, ACPI_COMPANION(&pdev->dev));
 	adap->dev.of_node = pdev->dev.of_node;
 
 	r = i2c_dw_probe(dev);

commit 3eddad96c4395280d5f6f13c958b276c11d3f575
Author: Ken Xue <Ken.Xue@amd.com>
Date:   Fri Oct 23 13:28:47 2015 +0800

    i2c: designware: reverts "i2c: designware: Add support for AMD I2C controller"
    
    The patch reverts commit a445900c9060 (i2c: designware: Add support for
    AMD I2C controller). It never worked anyhow because it did not register
    a proper clkdev.
    
    Since kernel 4.1 starts to support APD, there is no need to get freq
    from id->driver_data for AMD0010. clkdev is supposed to be already
    registered in APD.
    
    So, revert old design and make AMD0010 looks like other ones.
    
    Signed-off-by: Ken Xue <Ken.Xue@amd.com>
    Signed-off-by: Xiangliang Yu <Xiangliang.Yu@amd.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index c8a11ef94f97..f830da6bf25a 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -73,7 +73,6 @@ static void dw_i2c_acpi_params(struct platform_device *pdev, char method[],
 static int dw_i2c_acpi_configure(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
-	const struct acpi_device_id *id;
 
 	dev->adapter.nr = -1;
 	dev->tx_fifo_depth = 32;
@@ -87,29 +86,9 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 	dw_i2c_acpi_params(pdev, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt,
 			   &dev->sda_hold_time);
 
-	/*
-	 * Provide a way for Designware I2C host controllers that are not
-	 * based on Intel LPSS to specify their input clock frequency via
-	 * id->driver_data.
-	 */
-	id = acpi_match_device(pdev->dev.driver->acpi_match_table, &pdev->dev);
-	if (id && id->driver_data)
-		clk_register_fixed_rate(&pdev->dev, dev_name(&pdev->dev), NULL,
-					CLK_IS_ROOT, id->driver_data);
-
 	return 0;
 }
 
-static void dw_i2c_acpi_unconfigure(struct platform_device *pdev)
-{
-	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
-	const struct acpi_device_id *id;
-
-	id = acpi_match_device(pdev->dev.driver->acpi_match_table, &pdev->dev);
-	if (id && id->driver_data)
-		clk_unregister(dev->clk);
-}
-
 static const struct acpi_device_id dw_i2c_acpi_match[] = {
 	{ "INT33C2", 0 },
 	{ "INT33C3", 0 },
@@ -117,7 +96,7 @@ static const struct acpi_device_id dw_i2c_acpi_match[] = {
 	{ "INT3433", 0 },
 	{ "80860F41", 0 },
 	{ "808622C1", 0 },
-	{ "AMD0010", 133 * 1000 * 1000 },
+	{ "AMD0010", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(acpi, dw_i2c_acpi_match);
@@ -126,7 +105,6 @@ static inline int dw_i2c_acpi_configure(struct platform_device *pdev)
 {
 	return -ENODEV;
 }
-static inline void dw_i2c_acpi_unconfigure(struct platform_device *pdev) { }
 #endif
 
 static int dw_i2c_plat_probe(struct platform_device *pdev)
@@ -261,9 +239,6 @@ static int dw_i2c_plat_remove(struct platform_device *pdev)
 	pm_runtime_put_sync(&pdev->dev);
 	pm_runtime_disable(&pdev->dev);
 
-	if (has_acpi_companion(&pdev->dev))
-		dw_i2c_acpi_unconfigure(pdev);
-
 	return 0;
 }
 

commit 319d7f05dfb148935de46f2c7544ecf1e6332161
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Wed Oct 21 10:09:17 2015 +0300

    i2c: designware: Fix build error when !CONFIG_PM_SLEEP
    
    Commit ("i2c: designware: Rename platform driver probe and PM
    functions") introduced "'dw_i2c_plat_prepare' undeclared here" and
    "'dw_i2c_plat_complete' undeclared here" build errors when
    CONFIG_PM_SLEEP is not set.
    
    Fix this by renaming NULL defined dw_i2c_prepare and dw_i2c_complete PM
    hooks to dw_i2c_plat_prepare and dw_i2c_plat_complete since this was
    obviously missing from the commit.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index adcf4c3a81f0..c8a11ef94f97 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -287,8 +287,8 @@ static void dw_i2c_plat_complete(struct device *dev)
 		pm_request_resume(dev);
 }
 #else
-#define dw_i2c_prepare	NULL
-#define dw_i2c_complete	NULL
+#define dw_i2c_plat_prepare	NULL
+#define dw_i2c_plat_complete	NULL
 #endif
 
 #ifdef CONFIG_PM

commit 56d4b8a24cef5d66f0d10ac778a520d3c2c68a48
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Sep 24 12:06:54 2015 +0300

    i2c: designware: Do not use parameters from ACPI on Dell Inspiron 7348
    
    ACPI SSCN/FMCN methods were originally added because then the platform can
    provide the most accurate HCNT/LCNT values to the driver. However, this
    seems not to be true for Dell Inspiron 7348 where using these causes the
    touchpad to fail in boot:
    
      i2c_hid i2c-DLL0675:00: failed to retrieve report from device.
      i2c_designware INT3433:00: i2c_dw_handle_tx_abort: lost arbitration
      i2c_hid i2c-DLL0675:00: failed to retrieve report from device.
      i2c_designware INT3433:00: controller timed out
    
    The values received from ACPI are (in fast mode):
    
      HCNT: 72
      LCNT: 160
    
    this translates to following timings (input clock is 100MHz on Broadwell):
    
      tHIGH: 720 ns (spec min 600 ns)
      tLOW: 1600 ns (spec min 1300 ns)
      Bus period: 2920 ns (assuming 300 ns tf and tr)
      Bus speed: 342.5 kHz
    
    Both tHIGH and tLOW are within the I2C specification.
    
    The calculated values when ACPI parameters are not used are (in fast mode):
    
      HCNT: 87
      LCNT: 159
    
    which translates to:
    
      tHIGH: 870 ns (spec min 600 ns)
      tLOW: 1590 ns (spec min 1300 ns)
      Bus period 3060 ns (assuming 300 ns tf and tr)
      Bus speed 326.8 kHz
    
    These values are also within the I2C specification.
    
    Since both ACPI and calculated values meet the I2C specification timing
    requirements it is hard to say why the touchpad does not function properly
    with the ACPI values except that the bus speed is higher in this case (but
    still well below the max 400kHz).
    
    Solve this by adding DMI quirk to the driver that disables using ACPI
    parameters on this particulare machine.
    
    Reported-by: Pavel Roskin <plroskin@gmail.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Pavel Roskin <plroskin@gmail.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Cc: stable@kernel.org

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 73d58415bbc1..472b88285c75 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -24,6 +24,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/delay.h>
+#include <linux/dmi.h>
 #include <linux/i2c.h>
 #include <linux/clk.h>
 #include <linux/clk-provider.h>
@@ -51,6 +52,22 @@ static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
 }
 
 #ifdef CONFIG_ACPI
+/*
+ * The HCNT/LCNT information coming from ACPI should be the most accurate
+ * for given platform. However, some systems get it wrong. On such systems
+ * we get better results by calculating those based on the input clock.
+ */
+static const struct dmi_system_id dw_i2c_no_acpi_params[] = {
+	{
+		.ident = "Dell Inspiron 7348",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Inspiron 7348"),
+		},
+	},
+	{ }
+};
+
 static void dw_i2c_acpi_params(struct platform_device *pdev, char method[],
 			       u16 *hcnt, u16 *lcnt, u32 *sda_hold)
 {
@@ -58,6 +75,9 @@ static void dw_i2c_acpi_params(struct platform_device *pdev, char method[],
 	acpi_handle handle = ACPI_HANDLE(&pdev->dev);
 	union acpi_object *obj;
 
+	if (dmi_check_system(dw_i2c_no_acpi_params))
+		return;
+
 	if (ACPI_FAILURE(acpi_evaluate_object(handle, method, NULL, &buf)))
 		return;
 

commit 36d48fb5766aee9717e429f772046696b215282d
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Fri Oct 9 10:39:24 2015 +0100

    i2c: designware-platdrv: enable RuntimePM before registering to the core
    
    The core may register clients attached to this master which may use
    funtionality from the master. So, RuntimePM must be enabled before, otherwise
    this will fail.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: stable@kernel.org

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 3dd2de31a2f8..73d58415bbc1 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -253,12 +253,6 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	adap->dev.parent = &pdev->dev;
 	adap->dev.of_node = pdev->dev.of_node;
 
-	r = i2c_add_numbered_adapter(adap);
-	if (r) {
-		dev_err(&pdev->dev, "failure adding adapter\n");
-		return r;
-	}
-
 	if (dev->pm_runtime_disabled) {
 		pm_runtime_forbid(&pdev->dev);
 	} else {
@@ -268,6 +262,13 @@ static int dw_i2c_probe(struct platform_device *pdev)
 		pm_runtime_enable(&pdev->dev);
 	}
 
+	r = i2c_add_numbered_adapter(adap);
+	if (r) {
+		dev_err(&pdev->dev, "failure adding adapter\n");
+		pm_runtime_disable(&pdev->dev);
+		return r;
+	}
+
 	return 0;
 }
 

commit d80d134182ba536ececab8d5fca50d779befc9a6
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Mon Oct 12 16:55:35 2015 +0300

    i2c: designware: Move common probe code into i2c_dw_probe()
    
    There is some code duplication in i2c-designware-platdrv and
    i2c-designware-pcidrv probe functions. What is even worse that duplication
    requires i2c_dw_xfer(), i2c_dw_func() and i2c_dw_isr() i2c-designware-core
    functions to be exported.
    
    Therefore move common code into new i2c_dw_probe() and make functions above
    local to i2c-designware-core.
    
    While merging the code patch does following functional changes:
    
    - I2C Adapter name will be "Synopsys DesignWare I2C adapter". Previously it
      was used for platform and ACPI devices but PCI device used
      "i2c-designware-pci".
    - Using device name for interrupt name. Previous it was platform device name,
      ACPI device name or "i2c-designware-pci".
    - Error code from devm_request_irq() and i2c_add_numbered_adapter() will be
      printed in case of error.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 17167cd4812d..adcf4c3a81f0 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -41,10 +41,6 @@
 #include <linux/platform_data/i2c-designware.h>
 #include "i2c-designware-core.h"
 
-static struct i2c_algorithm i2c_dw_algo = {
-	.master_xfer	= i2c_dw_xfer,
-	.functionality	= i2c_dw_func,
-};
 static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
 {
 	return clk_get_rate(dev->clk)/1000;
@@ -155,8 +151,6 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	if (IS_ERR(dev->base))
 		return PTR_ERR(dev->base);
 
-	init_completion(&dev->cmd_complete);
-	mutex_init(&dev->lock);
 	dev->dev = &pdev->dev;
 	dev->irq = irq;
 	platform_set_drvdata(pdev, dev);
@@ -231,33 +225,15 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 		dev->rx_fifo_depth = ((param1 >> 8)  & 0xff) + 1;
 		dev->adapter.nr = pdev->id;
 	}
-	r = i2c_dw_init(dev);
-	if (r)
-		return r;
-
-	i2c_dw_disable_int(dev);
-	r = devm_request_irq(&pdev->dev, dev->irq, i2c_dw_isr, IRQF_SHARED,
-			pdev->name, dev);
-	if (r) {
-		dev_err(&pdev->dev, "failure requesting irq %i\n", dev->irq);
-		return r;
-	}
 
 	adap = &dev->adapter;
-	i2c_set_adapdata(adap, dev);
 	adap->owner = THIS_MODULE;
 	adap->class = I2C_CLASS_DEPRECATED;
-	strlcpy(adap->name, "Synopsys DesignWare I2C adapter",
-			sizeof(adap->name));
-	adap->algo = &i2c_dw_algo;
-	adap->dev.parent = &pdev->dev;
 	adap->dev.of_node = pdev->dev.of_node;
 
-	r = i2c_add_numbered_adapter(adap);
-	if (r) {
-		dev_err(&pdev->dev, "failure adding adapter\n");
+	r = i2c_dw_probe(dev);
+	if (r)
 		return r;
-	}
 
 	if (dev->pm_runtime_disabled) {
 		pm_runtime_forbid(&pdev->dev);

commit 6ad6fde3970c98348e4201efc22c92be414c86a6
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Mon Aug 31 17:31:32 2015 +0300

    i2c: designware: Rename platform driver probe and PM functions
    
    Make it easier to distinguish between i2c-designware-platdrv and
    i2c-designware-core functions and to be consistent with
    i2c-designware-pcidrv.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 3dd2de31a2f8..17167cd4812d 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -133,7 +133,7 @@ static inline int dw_i2c_acpi_configure(struct platform_device *pdev)
 static inline void dw_i2c_acpi_unconfigure(struct platform_device *pdev) { }
 #endif
 
-static int dw_i2c_probe(struct platform_device *pdev)
+static int dw_i2c_plat_probe(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev;
 	struct i2c_adapter *adap;
@@ -271,7 +271,7 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int dw_i2c_remove(struct platform_device *pdev)
+static int dw_i2c_plat_remove(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
 
@@ -300,12 +300,12 @@ MODULE_DEVICE_TABLE(of, dw_i2c_of_match);
 #endif
 
 #ifdef CONFIG_PM_SLEEP
-static int dw_i2c_prepare(struct device *dev)
+static int dw_i2c_plat_prepare(struct device *dev)
 {
 	return pm_runtime_suspended(dev);
 }
 
-static void dw_i2c_complete(struct device *dev)
+static void dw_i2c_plat_complete(struct device *dev)
 {
 	if (dev->power.direct_complete)
 		pm_request_resume(dev);
@@ -316,7 +316,7 @@ static void dw_i2c_complete(struct device *dev)
 #endif
 
 #ifdef CONFIG_PM
-static int dw_i2c_suspend(struct device *dev)
+static int dw_i2c_plat_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);
@@ -327,7 +327,7 @@ static int dw_i2c_suspend(struct device *dev)
 	return 0;
 }
 
-static int dw_i2c_resume(struct device *dev)
+static int dw_i2c_plat_resume(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);
@@ -341,10 +341,10 @@ static int dw_i2c_resume(struct device *dev)
 }
 
 static const struct dev_pm_ops dw_i2c_dev_pm_ops = {
-	.prepare = dw_i2c_prepare,
-	.complete = dw_i2c_complete,
-	SET_SYSTEM_SLEEP_PM_OPS(dw_i2c_suspend, dw_i2c_resume)
-	SET_RUNTIME_PM_OPS(dw_i2c_suspend, dw_i2c_resume, NULL)
+	.prepare = dw_i2c_plat_prepare,
+	.complete = dw_i2c_plat_complete,
+	SET_SYSTEM_SLEEP_PM_OPS(dw_i2c_plat_suspend, dw_i2c_plat_resume)
+	SET_RUNTIME_PM_OPS(dw_i2c_plat_suspend, dw_i2c_plat_resume, NULL)
 };
 
 #define DW_I2C_DEV_PMOPS (&dw_i2c_dev_pm_ops)
@@ -356,8 +356,8 @@ static const struct dev_pm_ops dw_i2c_dev_pm_ops = {
 MODULE_ALIAS("platform:i2c_designware");
 
 static struct platform_driver dw_i2c_driver = {
-	.probe = dw_i2c_probe,
-	.remove = dw_i2c_remove,
+	.probe = dw_i2c_plat_probe,
+	.remove = dw_i2c_plat_remove,
 	.driver		= {
 		.name	= "i2c_designware",
 		.of_match_table = of_match_ptr(dw_i2c_of_match),

commit edfc39012364a6ea8e4c7067c2655c92c2d02df4
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Jun 17 12:08:38 2015 +0300

    i2c: designware: Make sure the device is suspended before disabling runtime PM
    
    The driver calls pm_runtime_put() right before pm_runtime_disable() in its
    ->remove() hook to make sure clock is gated etc. However, it turns out that
    pm_runtime_put() only calls ->idle() hook without actually suspending
    anything. The following pm_runtime_disable() will prevent the driver from
    suspending thus leaving it "active".
    
    It is better to suspend the device synchronously to make sure it is
    actually suspended before disabling runtime PM from it.
    
    While there, undo call to pm_runtime_use_autosuspend().
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 4794911a6165..3dd2de31a2f8 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -281,7 +281,8 @@ static int dw_i2c_remove(struct platform_device *pdev)
 
 	i2c_dw_disable(dev);
 
-	pm_runtime_put(&pdev->dev);
+	pm_runtime_dont_use_autosuspend(&pdev->dev);
+	pm_runtime_put_sync(&pdev->dev);
 	pm_runtime_disable(&pdev->dev);
 
 	if (has_acpi_companion(&pdev->dev))

commit 8503ff166504272577e8f4c77d658395e744a2bb
Author: Jisheng Zhang <jszhang@marvell.com>
Date:   Wed May 20 22:33:13 2015 +0800

    i2c: designware: Avoid unnecessary resuming during system suspend
    
    Commit 1fc2fe204cb9 ("i2c: designware: Add runtime PM hooks") adds
    runtime pm support using the same ops for system pm and runtime pm.
    When suspend to ram, the i2c host may have been runtime suspended, thus
    i2c_dw_disable() hangs.
    
    Previously, I fixed this issue by separating ops for system pm and
    runtime pm, then in the system suspend/resume path, runtime pm apis are
    used to ensure the device is at correct state.
    
    But as Mika Westerberg pointed out: it sounds a bit silly to resume the
    device just because you want to call i2c_dw_disable() for it before
    suspending again. He then suggested an elegant solution which keeps the
    device runtime suspended during system suspend with the help of
    'dev->power.direct_complete'. This patch adopted this solution, and in
    fact Mika provided the main code.
    
    Signed-off-by: Jisheng Zhang <jszhang@marvell.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 0a80e4aabaed..4794911a6165 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -298,6 +298,22 @@ static const struct of_device_id dw_i2c_of_match[] = {
 MODULE_DEVICE_TABLE(of, dw_i2c_of_match);
 #endif
 
+#ifdef CONFIG_PM_SLEEP
+static int dw_i2c_prepare(struct device *dev)
+{
+	return pm_runtime_suspended(dev);
+}
+
+static void dw_i2c_complete(struct device *dev)
+{
+	if (dev->power.direct_complete)
+		pm_request_resume(dev);
+}
+#else
+#define dw_i2c_prepare	NULL
+#define dw_i2c_complete	NULL
+#endif
+
 #ifdef CONFIG_PM
 static int dw_i2c_suspend(struct device *dev)
 {
@@ -322,10 +338,18 @@ static int dw_i2c_resume(struct device *dev)
 
 	return 0;
 }
-#endif
 
-static UNIVERSAL_DEV_PM_OPS(dw_i2c_dev_pm_ops, dw_i2c_suspend,
-			    dw_i2c_resume, NULL);
+static const struct dev_pm_ops dw_i2c_dev_pm_ops = {
+	.prepare = dw_i2c_prepare,
+	.complete = dw_i2c_complete,
+	SET_SYSTEM_SLEEP_PM_OPS(dw_i2c_suspend, dw_i2c_resume)
+	SET_RUNTIME_PM_OPS(dw_i2c_suspend, dw_i2c_resume, NULL)
+};
+
+#define DW_I2C_DEV_PMOPS (&dw_i2c_dev_pm_ops)
+#else
+#define DW_I2C_DEV_PMOPS NULL
+#endif
 
 /* work with hotplug and coldplug */
 MODULE_ALIAS("platform:i2c_designware");
@@ -337,7 +361,7 @@ static struct platform_driver dw_i2c_driver = {
 		.name	= "i2c_designware",
 		.of_match_table = of_match_ptr(dw_i2c_of_match),
 		.acpi_match_table = ACPI_PTR(dw_i2c_acpi_match),
-		.pm	= &dw_i2c_dev_pm_ops,
+		.pm	= DW_I2C_DEV_PMOPS,
 	},
 };
 

commit 2481bc75283ea10e75d5fb1a8b42af363fc4b45c
Merge: 8691c130fae1 518b4e272d99
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 14 20:21:54 2015 -0700

    Merge tag 'pm+acpi-4.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI updates from Rafael Wysocki:
     "These are mostly fixes and cleanups all over, although there are a few
      items that sort of fall into the new feature category.
    
      First off, we have new callbacks for PM domains that should help us to
      handle some issues related to device initialization in a better way.
    
      There also is some consolidation in the unified device properties API
      area allowing us to use that inferface for accessing data coming from
      platform initialization code in addition to firmware-provided data.
    
      We have some new device/CPU IDs in a few drivers, support for new
      chips and a new cpufreq driver too.
    
      Specifics:
    
       - Generic PM domains support update including new PM domain callbacks
         to handle device initialization better (Russell King, Rafael J
         Wysocki, Kevin Hilman)
    
       - Unified device properties API update including a new mechanism for
         accessing data provided by platform initialization code (Rafael J
         Wysocki, Adrian Hunter)
    
       - ARM cpuidle update including ARM32/ARM64 handling consolidation
         (Daniel Lezcano)
    
       - intel_idle update including support for the Silvermont Core in the
         Baytrail SOC and for the Airmont Core in the Cherrytrail and
         Braswell SOCs (Len Brown, Mathias Krause)
    
       - New cpufreq driver for Hisilicon ACPU (Leo Yan)
    
       - intel_pstate update including support for the Knights Landing chip
         (Dasaratharaman Chandramouli, Kristen Carlson Accardi)
    
       - QorIQ cpufreq driver update (Tang Yuantian, Arnd Bergmann)
    
       - powernv cpufreq driver update (Shilpasri G Bhat)
    
       - devfreq update including Tegra support changes (Tomeu Vizoso,
         MyungJoo Ham, Chanwoo Choi)
    
       - powercap RAPL (Running-Average Power Limit) driver update including
         support for Intel Broadwell server chips (Jacob Pan, Mathias Krause)
    
       - ACPI device enumeration update related to the handling of the
         special PRP0001 device ID allowing DT-style 'compatible' property
         to be used for ACPI device identification (Rafael J Wysocki)
    
       - ACPI EC driver update including limited _DEP support (Lan Tianyu,
         Lv Zheng)
    
       - ACPI backlight driver update including a new mechanism to allow
         native backlight handling to be forced on non-Windows 8 systems and
         a new quirk for Lenovo Ideapad Z570 (Aaron Lu, Hans de Goede)
    
       - New Windows Vista compatibility quirk for Sony VGN-SR19XN (Chen Yu)
    
       - Assorted ACPI fixes and cleanups (Aaron Lu, Martin Kepplinger,
         Masanari Iida, Mika Westerberg, Nan Li, Rafael J Wysocki)
    
       - Fixes related to suspend-to-idle for the iTCO watchdog driver and
         the ACPI core system suspend/resume code (Rafael J Wysocki, Chen Yu)
    
       - PM tracing support for the suspend phase of system suspend/resume
         transitions (Zhonghui Fu)
    
       - Configurable delay for the system suspend/resume testing facility
         (Brian Norris)
    
       - PNP subsystem cleanups (Peter Huewe, Rafael J Wysocki)"
    
    * tag 'pm+acpi-4.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (74 commits)
      ACPI / scan: Fix NULL pointer dereference in acpi_companion_match()
      ACPI / scan: Rework modalias creation when "compatible" is present
      intel_idle: mark cpu id array as __initconst
      powercap / RAPL: mark rapl_ids array as __initconst
      powercap / RAPL: add ID for Broadwell server
      intel_pstate: Knights Landing support
      intel_pstate: remove MSR test
      cpufreq: fix qoriq uniprocessor build
      ACPI / scan: Take the PRP0001 position in the list of IDs into account
      ACPI / scan: Simplify acpi_match_device()
      ACPI / scan: Generalize of_compatible matching
      device property: Introduce firmware node type for platform data
      device property: Make it possible to use secondary firmware nodes
      PM / watchdog: iTCO: stop watchdog during system suspend
      cpufreq: hisilicon: add acpu driver
      ACPI / EC: Call acpi_walk_dep_device_list() after installing EC opregion handler
      cpufreq: powernv: Report cpu frequency throttling
      intel_idle: Add support for the Airmont Core in the Cherrytrail and Braswell SOCs
      intel_idle: Update support for Silvermont Core in Baytrail SOC
      PM / devfreq: tegra: Register governor on module init
      ...

commit ca5b74d2675a44f54aacb919c1cf022463e2f738
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Mar 16 23:49:08 2015 +0100

    ACPI: Introduce has_acpi_companion()
    
    Now that the ACPI companions of devices are represented by pointers
    to struct fwnode_handle, it is not quite efficient to check whether
    or not an ACPI companion of a device is present by evaluating the
    ACPI_COMPANION() macro.
    
    For this reason, introduce a special static inline routine for that,
    has_acpi_companion(), and update the code to use it where applicable.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index c270f5f9a8f9..538d6910b550 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -166,7 +166,7 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	/* fast mode by default because of legacy reasons */
 	clk_freq = 400000;
 
-	if (ACPI_COMPANION(&pdev->dev)) {
+	if (has_acpi_companion(&pdev->dev)) {
 		dw_i2c_acpi_configure(pdev);
 	} else if (pdev->dev.of_node) {
 		of_property_read_u32(pdev->dev.of_node,
@@ -286,7 +286,7 @@ static int dw_i2c_remove(struct platform_device *pdev)
 	pm_runtime_put(&pdev->dev);
 	pm_runtime_disable(&pdev->dev);
 
-	if (ACPI_COMPANION(&pdev->dev))
+	if (has_acpi_companion(&pdev->dev))
 		dw_i2c_acpi_unconfigure(pdev);
 
 	return 0;

commit b20d386485e25934aef8aa24cbc8c2f51a2cb9cf
Author: Alexey Brodkin <Alexey.Brodkin@synopsys.com>
Date:   Mon Mar 9 12:03:12 2015 +0300

    i2c: designware: Suppress error message if platform_get_irq() < 0
    
    With -EPROBE_DEFER, this message is confusing and we hope for a
    centralized printout in the future anyhow.
    
    Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Christian Ruppert <christian.ruppert@alitech.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index c270f5f9a8f9..fa4e2b521f0d 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -143,10 +143,8 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	u32 clk_freq, ht = 0;
 
 	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		dev_err(&pdev->dev, "no irq resource?\n");
-		return irq; /* -ENXIO */
-	}
+	if (irq < 0)
+		return irq;
 
 	dev = devm_kzalloc(&pdev->dev, sizeof(struct dw_i2c_dev), GFP_KERNEL);
 	if (!dev)

commit 894acb2f823b13afacfe40b02efbd9146af58586
Author: David Box <david.e.box@linux.intel.com>
Date:   Thu Jan 15 01:12:17 2015 -0800

    i2c: designware: Add Intel Baytrail PMIC I2C bus support
    
    This patch implements an I2C bus sharing mechanism between the host and platform
    hardware on select Intel BayTrail SoC platforms using the X-Powers AXP288 PMIC.
    
    On these platforms access to the PMIC must be shared with platform hardware. The
    hardware unit assumes full control of the I2C bus and the host must request
    access through a special semaphore. Hardware control of the bus also makes it
    necessary to disable runtime pm to avoid interfering with hardware transactions.
    
    Signed-off-by: David E. Box <david.e.box@linux.intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 2b463c313e4e..c270f5f9a8f9 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -195,6 +195,10 @@ static int dw_i2c_probe(struct platform_device *pdev)
 			clk_freq = pdata->i2c_scl_freq;
 	}
 
+	r = i2c_dw_eval_lock_support(dev);
+	if (r)
+		return r;
+
 	dev->functionality =
 		I2C_FUNC_I2C |
 		I2C_FUNC_10BIT_ADDR |
@@ -257,10 +261,14 @@ static int dw_i2c_probe(struct platform_device *pdev)
 		return r;
 	}
 
-	pm_runtime_set_autosuspend_delay(&pdev->dev, 1000);
-	pm_runtime_use_autosuspend(&pdev->dev);
-	pm_runtime_set_active(&pdev->dev);
-	pm_runtime_enable(&pdev->dev);
+	if (dev->pm_runtime_disabled) {
+		pm_runtime_forbid(&pdev->dev);
+	} else {
+		pm_runtime_set_autosuspend_delay(&pdev->dev, 1000);
+		pm_runtime_use_autosuspend(&pdev->dev);
+		pm_runtime_set_active(&pdev->dev);
+		pm_runtime_enable(&pdev->dev);
+	}
 
 	return 0;
 }
@@ -310,7 +318,9 @@ static int dw_i2c_resume(struct device *dev)
 	struct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);
 
 	clk_prepare_enable(i_dev->clk);
-	i2c_dw_init(i_dev);
+
+	if (!i_dev->pm_runtime_disabled)
+		i2c_dw_init(i_dev);
 
 	return 0;
 }

commit e6b5be2be4e30037eb551e0ed09dd97bd00d85d3
Merge: 37da7bbbe84f f1c488a78d9f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 16:10:09 2014 -0800

    Merge tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core update from Greg KH:
     "Here's the set of driver core patches for 3.19-rc1.
    
      They are dominated by the removal of the .owner field in platform
      drivers.  They touch a lot of files, but they are "simple" changes,
      just removing a line in a structure.
    
      Other than that, a few minor driver core and debugfs changes.  There
      are some ath9k patches coming in through this tree that have been
      acked by the wireless maintainers as they relied on the debugfs
      changes.
    
      Everything has been in linux-next for a while"
    
    * tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (324 commits)
      Revert "ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries"
      fs: debugfs: add forward declaration for struct device type
      firmware class: Deletion of an unnecessary check before the function call "vunmap"
      firmware loader: fix hung task warning dump
      devcoredump: provide a one-way disable function
      device: Add dev_<level>_once variants
      ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries
      ath: use seq_file api for ath9k debugfs files
      debugfs: add helper function to create device related seq_file
      drivers/base: cacheinfo: remove noisy error boot message
      Revert "core: platform: add warning if driver has no owner"
      drivers: base: support cpu cache information interface to userspace via sysfs
      drivers: base: add cpu_device_create to support per-cpu devices
      topology: replace custom attribute macros with standard DEVICE_ATTR*
      cpumask: factor out show_cpumap into separate helper function
      driver core: Fix unbalanced device reference in drivers_probe
      driver core: fix race with userland in device_add()
      sysfs/kernfs: make read requests on pre-alloc files use the buffer.
      sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
      fs: sysfs: return EGBIG on write if offset is larger than file size
      ...

commit ca1f8da9ac5ce6e63d8f6933f83fabc1f3f961f4
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue Nov 4 23:46:27 2014 +0100

    i2c: remove FSF address
    
    We have a central copy of the GPL for that. Some addresses were already
    outdated.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index a7431150acf7..373dd4d47765 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -18,10 +18,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  * ----------------------------------------------------------------------------
  *
  */

commit 1ecc4335eba1a264ed8ac5b180a2ffde8113f3db
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:37 2014 +0200

    i2c: busses: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index a7431150acf7..cb0667ce1d40 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -331,7 +331,6 @@ static struct platform_driver dw_i2c_driver = {
 	.remove = dw_i2c_remove,
 	.driver		= {
 		.name	= "i2c_designware",
-		.owner	= THIS_MODULE,
 		.of_match_table = of_match_ptr(dw_i2c_of_match),
 		.acpi_match_table = ACPI_PTR(dw_i2c_acpi_match),
 		.pm	= &dw_i2c_dev_pm_ops,

commit a445900c906092f3b49ee40a7365d0d54acc568e
Author: Carl Peng <carlpeng008@gmail.com>
Date:   Tue Sep 30 13:04:55 2014 +0300

    i2c: designware: Add support for AMD I2C controller
    
    Add support for AMD version of the DW I2C host controller. The device is
    enumerated from ACPI namespace with ACPI ID AMD0010. Because the core
    driver needs an input source clock, and this is not an Intel LPSS device
    where clocks are provided through drivers/acpi/acpi_lpss.c, we register the
    clock ourselves if the clock rate is given in ->driver_data
    
    Signed-off-by: Carl Peng <carlpeng008@gmail.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index e59c63ae4d41..a7431150acf7 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -30,6 +30,7 @@
 #include <linux/delay.h>
 #include <linux/i2c.h>
 #include <linux/clk.h>
+#include <linux/clk-provider.h>
 #include <linux/errno.h>
 #include <linux/sched.h>
 #include <linux/err.h>
@@ -80,6 +81,7 @@ static void dw_i2c_acpi_params(struct platform_device *pdev, char method[],
 static int dw_i2c_acpi_configure(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
+	const struct acpi_device_id *id;
 
 	dev->adapter.nr = -1;
 	dev->tx_fifo_depth = 32;
@@ -93,9 +95,29 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 	dw_i2c_acpi_params(pdev, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt,
 			   &dev->sda_hold_time);
 
+	/*
+	 * Provide a way for Designware I2C host controllers that are not
+	 * based on Intel LPSS to specify their input clock frequency via
+	 * id->driver_data.
+	 */
+	id = acpi_match_device(pdev->dev.driver->acpi_match_table, &pdev->dev);
+	if (id && id->driver_data)
+		clk_register_fixed_rate(&pdev->dev, dev_name(&pdev->dev), NULL,
+					CLK_IS_ROOT, id->driver_data);
+
 	return 0;
 }
 
+static void dw_i2c_acpi_unconfigure(struct platform_device *pdev)
+{
+	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
+	const struct acpi_device_id *id;
+
+	id = acpi_match_device(pdev->dev.driver->acpi_match_table, &pdev->dev);
+	if (id && id->driver_data)
+		clk_unregister(dev->clk);
+}
+
 static const struct acpi_device_id dw_i2c_acpi_match[] = {
 	{ "INT33C2", 0 },
 	{ "INT33C3", 0 },
@@ -103,6 +125,7 @@ static const struct acpi_device_id dw_i2c_acpi_match[] = {
 	{ "INT3433", 0 },
 	{ "80860F41", 0 },
 	{ "808622C1", 0 },
+	{ "AMD0010", 133 * 1000 * 1000 },
 	{ }
 };
 MODULE_DEVICE_TABLE(acpi, dw_i2c_acpi_match);
@@ -111,6 +134,7 @@ static inline int dw_i2c_acpi_configure(struct platform_device *pdev)
 {
 	return -ENODEV;
 }
+static inline void dw_i2c_acpi_unconfigure(struct platform_device *pdev) { }
 #endif
 
 static int dw_i2c_probe(struct platform_device *pdev)
@@ -258,6 +282,9 @@ static int dw_i2c_remove(struct platform_device *pdev)
 	pm_runtime_put(&pdev->dev);
 	pm_runtime_disable(&pdev->dev);
 
+	if (ACPI_COMPANION(&pdev->dev))
+		dw_i2c_acpi_unconfigure(pdev);
+
 	return 0;
 }
 

commit 925ddb240d6c76e56dd3aa22493f5755c452ba61
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Sep 30 13:04:54 2014 +0300

    i2c: designware: Rework probe() to get clock a bit later
    
    In order to be able to create missing clock for AMD (and in future possibly
    others) we move getting clock for the device a bit later. Also make ACPI/DT
    configuration in the same place depending on from where the device was
    enumerated from.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 353adc4dc583..e59c63ae4d41 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -81,9 +81,6 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
 
-	if (!ACPI_HANDLE(&pdev->dev))
-		return -ENODEV;
-
 	dev->adapter.nr = -1;
 	dev->tx_fifo_depth = 32;
 	dev->rx_fifo_depth = 32;
@@ -123,7 +120,7 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	struct resource *mem;
 	struct dw_i2c_platform_data *pdata;
 	int irq, r;
-	u32 clk_freq;
+	u32 clk_freq, ht = 0;
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
@@ -146,24 +143,14 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	dev->irq = irq;
 	platform_set_drvdata(pdev, dev);
 
-	dev->clk = devm_clk_get(&pdev->dev, NULL);
-	dev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;
-
-	if (IS_ERR(dev->clk))
-		return PTR_ERR(dev->clk);
-	clk_prepare_enable(dev->clk);
-
 	/* fast mode by default because of legacy reasons */
 	clk_freq = 400000;
 
-	if (pdev->dev.of_node) {
-		u32 ht = 0;
-		u32 ic_clk = dev->get_clk_rate_khz(dev);
-
+	if (ACPI_COMPANION(&pdev->dev)) {
+		dw_i2c_acpi_configure(pdev);
+	} else if (pdev->dev.of_node) {
 		of_property_read_u32(pdev->dev.of_node,
 					"i2c-sda-hold-time-ns", &ht);
-		dev->sda_hold_time = div_u64((u64)ic_clk * ht + 500000,
-					     1000000);
 
 		of_property_read_u32(pdev->dev.of_node,
 				     "i2c-sda-falling-time-ns",
@@ -202,9 +189,20 @@ static int dw_i2c_probe(struct platform_device *pdev)
 		dev->master_cfg =  DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
 			DW_IC_CON_RESTART_EN | DW_IC_CON_SPEED_FAST;
 
-	/* Try first if we can configure the device from ACPI */
-	r = dw_i2c_acpi_configure(pdev);
-	if (r) {
+	dev->clk = devm_clk_get(&pdev->dev, NULL);
+	dev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;
+	if (IS_ERR(dev->clk))
+		return PTR_ERR(dev->clk);
+	clk_prepare_enable(dev->clk);
+
+	if (!dev->sda_hold_time && ht) {
+		u32 ic_clk = dev->get_clk_rate_khz(dev);
+
+		dev->sda_hold_time = div_u64((u64)ic_clk * ht + 500000,
+					     1000000);
+	}
+
+	if (!dev->tx_fifo_depth) {
 		u32 param1 = i2c_dw_read_comp_param(dev);
 
 		dev->tx_fifo_depth = ((param1 >> 16) & 0xff) + 1;

commit 0b26c845dfd554dd9030efbf0249d3830251e58b
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Sep 30 13:04:53 2014 +0300

    i2c: designware: Default to fast mode in case of ACPI
    
    There is no way in ACPI to tell in which speed the host controller is
    supposed to run, so we default to fast mode (400KHz). Since this has been
    the default all the time there should be no functional changes with this
    change.
    
    This is the first step required to refactor the driver probe so that we can
    supply source clock from ACPI part of the driver to the core.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 4d6a6b94e2fa..353adc4dc583 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -80,7 +80,6 @@ static void dw_i2c_acpi_params(struct platform_device *pdev, char method[],
 static int dw_i2c_acpi_configure(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
-	bool fs_mode = dev->master_cfg & DW_IC_CON_SPEED_FAST;
 
 	if (!ACPI_HANDLE(&pdev->dev))
 		return -ENODEV;
@@ -93,10 +92,9 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 	 * Try to get SDA hold time and *CNT values from an ACPI method if
 	 * it exists for both supported speed modes.
 	 */
-	dw_i2c_acpi_params(pdev, "SSCN", &dev->ss_hcnt, &dev->ss_lcnt,
-			   fs_mode ? NULL : &dev->sda_hold_time);
+	dw_i2c_acpi_params(pdev, "SSCN", &dev->ss_hcnt, &dev->ss_lcnt, NULL);
 	dw_i2c_acpi_params(pdev, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt,
-			   fs_mode ? &dev->sda_hold_time : NULL);
+			   &dev->sda_hold_time);
 
 	return 0;
 }

commit 4bcfda09936da647b0a3b49d5dcb3c6c6ebb0395
Author: Tan, Raymond <raymond.tan@intel.com>
Date:   Wed Sep 3 10:41:38 2014 +0800

    i2c: designware: add support of platform data to set I2C mode
    
    Use the platform data to set the clk_freq when there is no DT configuration
    available. The clk_freq in turn will determine the I2C speed mode.
    
    In Quark, there is currently no other configuration mechanism other than
    board files.
    
    Signed-off-by: Raymond Tan <raymond.tan@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Hock Leong Kweh <hock.leong.kweh@intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 8193e8eea764..4d6a6b94e2fa 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -41,6 +41,7 @@
 #include <linux/io.h>
 #include <linux/slab.h>
 #include <linux/acpi.h>
+#include <linux/platform_data/i2c-designware.h>
 #include "i2c-designware-core.h"
 
 static struct i2c_algorithm i2c_dw_algo = {
@@ -122,6 +123,7 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	struct dw_i2c_dev *dev;
 	struct i2c_adapter *adap;
 	struct resource *mem;
+	struct dw_i2c_platform_data *pdata;
 	int irq, r;
 	u32 clk_freq;
 
@@ -182,6 +184,10 @@ static int dw_i2c_probe(struct platform_device *pdev)
 			dev_err(&pdev->dev, "Only 100kHz and 400kHz supported");
 			return -EINVAL;
 		}
+	} else {
+		pdata = dev_get_platdata(&pdev->dev);
+		if (pdata)
+			clk_freq = pdata->i2c_scl_freq;
 	}
 
 	dev->functionality =

commit 8e5f6b2a289c4374456fb785900b0b7445b719e6
Author: Romain Baeriswyl <Romain.Baeriswyl@abilis.com>
Date:   Wed Aug 20 16:29:08 2014 +0200

    i2c: designware: add support of I2C standard mode
    
    Some legacy devices support ony I2C standard mode at 100kHz.
    This patch allows to select the standard mode through the DTS
    with the use of the existing clock-frequency parameter.
    
    When clock-frequency parameter is not set, the fast mode is selected.
    Only when the parameter is set at 100000, the standard mode is selected.
    
    Signed-off-by: Romain Baeriswyl <romainba@abilis.com>
    Reviewed-by: Christian Ruppert <christian.ruppert@abilis.com>
    Acked-by: Alan Tull <atull@opensource.altera.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index bc8773333155..8193e8eea764 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -123,6 +123,7 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	struct i2c_adapter *adap;
 	struct resource *mem;
 	int irq, r;
+	u32 clk_freq;
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
@@ -152,6 +153,9 @@ static int dw_i2c_probe(struct platform_device *pdev)
 		return PTR_ERR(dev->clk);
 	clk_prepare_enable(dev->clk);
 
+	/* fast mode by default because of legacy reasons */
+	clk_freq = 400000;
+
 	if (pdev->dev.of_node) {
 		u32 ht = 0;
 		u32 ic_clk = dev->get_clk_rate_khz(dev);
@@ -167,6 +171,17 @@ static int dw_i2c_probe(struct platform_device *pdev)
 		of_property_read_u32(pdev->dev.of_node,
 				     "i2c-scl-falling-time-ns",
 				     &dev->scl_falling_time);
+
+		of_property_read_u32(pdev->dev.of_node, "clock-frequency",
+				     &clk_freq);
+
+		/* Only standard mode at 100kHz and fast mode at 400kHz
+		 * are supported.
+		 */
+		if (clk_freq != 100000 && clk_freq != 400000) {
+			dev_err(&pdev->dev, "Only 100kHz and 400kHz supported");
+			return -EINVAL;
+		}
 	}
 
 	dev->functionality =
@@ -176,8 +191,12 @@ static int dw_i2c_probe(struct platform_device *pdev)
 		I2C_FUNC_SMBUS_BYTE_DATA |
 		I2C_FUNC_SMBUS_WORD_DATA |
 		I2C_FUNC_SMBUS_I2C_BLOCK;
-	dev->master_cfg =  DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
-		DW_IC_CON_RESTART_EN | DW_IC_CON_SPEED_FAST;
+	if (clk_freq == 100000)
+		dev->master_cfg =  DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
+			DW_IC_CON_RESTART_EN | DW_IC_CON_SPEED_STD;
+	else
+		dev->master_cfg =  DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
+			DW_IC_CON_RESTART_EN | DW_IC_CON_SPEED_FAST;
 
 	/* Try first if we can configure the device from ACPI */
 	r = dw_i2c_acpi_configure(pdev);

commit 0409516a2d29fcaca53ed4c90c22f11af9600199
Author: Alan Cox <alan@linux.intel.com>
Date:   Wed Jul 23 13:06:57 2014 +0100

    i2c: designware: add new bindings
    
    This may appear as PCI or ACPI depending upon the firmware so we
    have to list both. All share the same ACPI identifier but not
    the same PCI identifier.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index e4e1af959875..bc8773333155 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -106,6 +106,7 @@ static const struct acpi_device_id dw_i2c_acpi_match[] = {
 	{ "INT3432", 0 },
 	{ "INT3433", 0 },
 	{ "80860F41", 0 },
+	{ "808622C1", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(acpi, dw_i2c_acpi_match);

commit 70fba8302adecfa08a087c6f1dd39537a55f5bd3
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Thu Jul 10 13:46:26 2014 +0200

    i2c: i2c-designware-platdrv: Drop class based scanning to improve bootup time
    
    This driver has been flagged to drop class based instantiation. The removal
    improves boot-up time and is unneeded for embedded controllers. Users have been
    warned to switch for some time now, so we can actually do the removal. Keep the
    DEPRECATED flag, so the core can inform users that the behaviour finally
    changed now. After another transition period, this flag can go, too.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 402ec3970fed..e4e1af959875 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -202,7 +202,7 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	adap = &dev->adapter;
 	i2c_set_adapdata(adap, dev);
 	adap->owner = THIS_MODULE;
-	adap->class = I2C_CLASS_HWMON | I2C_CLASS_DEPRECATED;
+	adap->class = I2C_CLASS_DEPRECATED;
 	strlcpy(adap->name, "Synopsys DesignWare I2C adapter",
 			sizeof(adap->name));
 	adap->algo = &i2c_dw_algo;

commit 1fc2fe204cb9d8010e70716aa48b5c3db6379da3
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu May 15 17:37:23 2014 +0300

    i2c: designware: Add runtime PM hooks
    
    It is possible that after entering runtime PM suspend the controller
    context is lost due the fact that its power is removed. This happens for
    example on Asus T100, an Intel Baytrail based tablet/laptop.
    
    In order to get the controller back to functional state, we need to
    implement runtime PM hooks which will re-initialize the hardware during
    runtime PM resume. We can re-use the existing system suspend hooks as the
    steps to resume/suspend the controller are the same.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index f72102f389c5..402ec3970fed 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -247,7 +247,7 @@ static const struct of_device_id dw_i2c_of_match[] = {
 MODULE_DEVICE_TABLE(of, dw_i2c_of_match);
 #endif
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM
 static int dw_i2c_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
@@ -269,13 +269,11 @@ static int dw_i2c_resume(struct device *dev)
 
 	return 0;
 }
-
-static SIMPLE_DEV_PM_OPS(dw_i2c_dev_pm_ops, dw_i2c_suspend, dw_i2c_resume);
-#define DW_I2C_DEV_PM_OPS	(&dw_i2c_dev_pm_ops)
-#else
-#define DW_I2C_DEV_PM_OPS	NULL
 #endif
 
+static UNIVERSAL_DEV_PM_OPS(dw_i2c_dev_pm_ops, dw_i2c_suspend,
+			    dw_i2c_resume, NULL);
+
 /* work with hotplug and coldplug */
 MODULE_ALIAS("platform:i2c_designware");
 
@@ -287,7 +285,7 @@ static struct platform_driver dw_i2c_driver = {
 		.owner	= THIS_MODULE,
 		.of_match_table = of_match_ptr(dw_i2c_of_match),
 		.acpi_match_table = ACPI_PTR(dw_i2c_acpi_match),
-		.pm	= DW_I2C_DEV_PM_OPS,
+		.pm	= &dw_i2c_dev_pm_ops,
 	},
 };
 

commit f537295a58ddc4460b9857c6e4a6959685447f3b
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu May 15 17:37:22 2014 +0300

    i2c: designware: Disable device on system suspend
    
    Userspace can initiate system suspend on arbitrary times which means that
    device drivers must make sure that their device gets quiesced before system
    suspend is entered. Therefore disable the I2C host controller in the driver
    system suspend hook.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 9c7802614342..f72102f389c5 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -253,6 +253,7 @@ static int dw_i2c_suspend(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);
 
+	i2c_dw_disable(i_dev);
 	clk_disable_unprepare(i_dev->clk);
 
 	return 0;

commit 834f2d864a2d8513aac763a353c0ad7bde11af52
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Feb 10 11:04:02 2014 +0100

    i2c: i2c-designware-platdrv: deprecate class based instantiation
    
    Warn users that class based instantiation is going away soon in favour
    of more robust probing and faster bootup times.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index fc243992b4b4..9c7802614342 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -202,7 +202,7 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	adap = &dev->adapter;
 	i2c_set_adapdata(adap, dev);
 	adap->owner = THIS_MODULE;
-	adap->class = I2C_CLASS_HWMON;
+	adap->class = I2C_CLASS_HWMON | I2C_CLASS_DEPRECATED;
 	strlcpy(adap->name, "Synopsys DesignWare I2C adapter",
 			sizeof(adap->name));
 	adap->algo = &i2c_dw_algo;

commit 6468276b22069d4442aafcd8c59e5d8ccae23f5f
Author: Romain Baeriswyl <Romain.Baeriswyl@abilis.com>
Date:   Mon Jan 20 17:43:43 2014 +0100

    i2c: designware: make SCL and SDA falling time configurable
    
    This patch allows to set independantly SCL and SDA falling times.
    The tLOW period is computed by taking into account the SCL falling time.
    The tHIGH period is computed by taking into account the SDA falling time.
    
    For instance in case the margin on tLOW is considered too small, it can
    be increased by increasing the SCL falling time which is by default set
    at 300ns.
    
    The same applies for tHIGH period with the help of SDA falling time.
    
    Signed-off-by: Romain Baeriswyl <romainba@abilis.com>
    Reviewed-by: Christian Ruppert <christian.ruppert@abilis.com>
    Acked-by: Shinya Kuribayashi <skuribay@pobox.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index d0bdac0498ce..fc243992b4b4 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -159,6 +159,13 @@ static int dw_i2c_probe(struct platform_device *pdev)
 					"i2c-sda-hold-time-ns", &ht);
 		dev->sda_hold_time = div_u64((u64)ic_clk * ht + 500000,
 					     1000000);
+
+		of_property_read_u32(pdev->dev.of_node,
+				     "i2c-sda-falling-time-ns",
+				     &dev->sda_falling_time);
+		of_property_read_u32(pdev->dev.of_node,
+				     "i2c-scl-falling-time-ns",
+				     &dev->scl_falling_time);
 	}
 
 	dev->functionality =

commit 13509c3a9d20a9df93dc9b944e8bd20fe1b454a7
Merge: 1ea406c0e08c cfff1f4a9367
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 18 15:50:07 2013 -0800

    Merge branch 'i2c/for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux
    
    Pull i2c changes from Wolfram Sang:
     - new drivers for exynos5, bcm kona, and st micro
     - bigger overhauls for drivers mxs and rcar
     - typical driver bugfixes, cleanups, improvements
     - got rid of the superfluous 'driver' member in i2c_client struct This
       touches a few drivers in other subsystems.  All acked.
    
    * 'i2c/for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux: (38 commits)
      i2c: bcm-kona: fix error return code in bcm_kona_i2c_probe()
      i2c: i2c-eg20t: do not print error message in syslog if no ACK received
      i2c: bcm-kona: Introduce Broadcom I2C Driver
      i2c: cbus-gpio: Fix device tree binding
      i2c: wmt: add missing clk_disable_unprepare() on error
      i2c: designware: add new ACPI IDs
      i2c: i801: Add Device IDs for Intel Wildcat Point-LP PCH
      i2c: exynos5: Remove incorrect clk_disable_unprepare
      i2c: i2c-st: Add ST I2C controller
      i2c: exynos5: add High Speed I2C controller driver
      i2c: rcar: fixup rcar type naming
      i2c: scmi: remove some bogus NULL checks
      i2c: sh_mobile & rcar: Enable the driver on all ARM platforms
      i2c: sh_mobile: Convert to clk_prepare/unprepare
      i2c: mux: gpio: use reg value for i2c_add_mux_adapter
      i2c: mux: gpio: use gpio_set_value_cansleep()
      i2c: Include linux/of.h header
      i2c: mxs: Fix PIO mode on i.MX23
      i2c: mxs: Rework the PIO mode operation
      i2c: mxs: distinguish i.MX23 and i.MX28 based I2C controller
      ...

commit 25b3dfc87bff80317d67ddd2cd4cfb91e6fe7d79
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Tue Nov 12 11:57:30 2013 +0200

    i2c: designware: add new ACPI IDs
    
    Newer Intel PCHs with LPSS have the same Designware I2C controllers than
    Haswell but the ACPI IDs differ. Add these IDs to the driver list.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 4c1b60539a25..c4ca1aae98d4 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -103,6 +103,8 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 static const struct acpi_device_id dw_i2c_acpi_match[] = {
 	{ "INT33C2", 0 },
 	{ "INT33C3", 0 },
+	{ "INT3432", 0 },
+	{ "INT3433", 0 },
 	{ "80860F41", 0 },
 	{ }
 };

commit cccdcea14fc2de8707c52e537fa2b384ccfe7ec2
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Tue Oct 8 22:35:33 2013 +0200

    i2c: i2c-designware-platdrv: replace platform_driver_probe to support deferred probing
    
    Subsystems like pinctrl and gpio rightfully make use of deferred probing at
    core level. Now, deferred drivers won't be retried if they don't have a .probe
    function specified in the driver struct. Fix this driver to have that, so the
    devices it supports won't get lost in a deferred probe.
    
    Reported-by: Zhangfei Gao <zhangfei.gao@linaro.org>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 4c1b60539a25..0aa01136f8d9 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -270,7 +270,8 @@ static SIMPLE_DEV_PM_OPS(dw_i2c_dev_pm_ops, dw_i2c_suspend, dw_i2c_resume);
 MODULE_ALIAS("platform:i2c_designware");
 
 static struct platform_driver dw_i2c_driver = {
-	.remove		= dw_i2c_remove,
+	.probe = dw_i2c_probe,
+	.remove = dw_i2c_remove,
 	.driver		= {
 		.name	= "i2c_designware",
 		.owner	= THIS_MODULE,
@@ -282,7 +283,7 @@ static struct platform_driver dw_i2c_driver = {
 
 static int __init dw_i2c_init_driver(void)
 {
-	return platform_driver_probe(&dw_i2c_driver, dw_i2c_probe);
+	return platform_driver_register(&dw_i2c_driver);
 }
 subsys_initcall(dw_i2c_init_driver);
 

commit 57cd1e3029e5fb4d238ad11fd0d7ad917179fdf2
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Aug 19 15:07:54 2013 +0300

    i2c: designware: get SDA hold time, HCNT and LCNT configuration from ACPI
    
    Some Intel LPSS I2C devices make the SDA hold time and *CNT parameters
    available via SSCN (standard mode) and FMCN (fast mode) ACPI methods.
    
    Implement support for this so that we check whether an ACPI method exists
    and if it does, fill in the SDA hold time and *CNT values to the device
    private structure for core to use.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 6e99d9f56dee..4c1b60539a25 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -53,9 +53,33 @@ static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
 }
 
 #ifdef CONFIG_ACPI
+static void dw_i2c_acpi_params(struct platform_device *pdev, char method[],
+			       u16 *hcnt, u16 *lcnt, u32 *sda_hold)
+{
+	struct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };
+	acpi_handle handle = ACPI_HANDLE(&pdev->dev);
+	union acpi_object *obj;
+
+	if (ACPI_FAILURE(acpi_evaluate_object(handle, method, NULL, &buf)))
+		return;
+
+	obj = (union acpi_object *)buf.pointer;
+	if (obj->type == ACPI_TYPE_PACKAGE && obj->package.count == 3) {
+		const union acpi_object *objs = obj->package.elements;
+
+		*hcnt = (u16)objs[0].integer.value;
+		*lcnt = (u16)objs[1].integer.value;
+		if (sda_hold)
+			*sda_hold = (u32)objs[2].integer.value;
+	}
+
+	kfree(buf.pointer);
+}
+
 static int dw_i2c_acpi_configure(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
+	bool fs_mode = dev->master_cfg & DW_IC_CON_SPEED_FAST;
 
 	if (!ACPI_HANDLE(&pdev->dev))
 		return -ENODEV;
@@ -63,6 +87,16 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 	dev->adapter.nr = -1;
 	dev->tx_fifo_depth = 32;
 	dev->rx_fifo_depth = 32;
+
+	/*
+	 * Try to get SDA hold time and *CNT values from an ACPI method if
+	 * it exists for both supported speed modes.
+	 */
+	dw_i2c_acpi_params(pdev, "SSCN", &dev->ss_hcnt, &dev->ss_lcnt,
+			   fs_mode ? NULL : &dev->sda_hold_time);
+	dw_i2c_acpi_params(pdev, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt,
+			   fs_mode ? &dev->sda_hold_time : NULL);
+
 	return 0;
 }
 

commit 55e71edb81b2b45273e7b284cce13ff24bde846f
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Aug 21 17:28:23 2013 +0300

    i2c: move ACPI helpers into the core
    
    This follows what has already been done for the DeviceTree helpers. Move
    the ACPI helpers from drivers/acpi/acpi_i2c.c to the I2C core and update
    documentation accordingly.
    
    This also solves a problem reported by Jerry Snitselaar that we can't build
    the ACPI I2C helpers as a module.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index ded77c3bd59c..6e99d9f56dee 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -171,7 +171,6 @@ static int dw_i2c_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "failure adding adapter\n");
 		return r;
 	}
-	acpi_i2c_register_devices(adap);
 
 	pm_runtime_set_autosuspend_delay(&pdev->dev, 1000);
 	pm_runtime_use_autosuspend(&pdev->dev);

commit 687b81d083c082bc1e853032e3a2a54f8c251d27
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Thu Jul 11 12:56:15 2013 +0100

    i2c: move OF helpers into the core
    
    I2C of helpers used to live in of_i2c.c but experience (from SPI) shows
    that it is much cleaner to have this in the core. This also removes a
    circular dependency between the helpers and the core, and so we can
    finally register child nodes in the core instead of doing this manually
    in each driver. So, fix the drivers and documentation, too.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 64ffb908641c..ded77c3bd59c 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -35,7 +35,6 @@
 #include <linux/err.h>
 #include <linux/interrupt.h>
 #include <linux/of.h>
-#include <linux/of_i2c.h>
 #include <linux/platform_device.h>
 #include <linux/pm.h>
 #include <linux/pm_runtime.h>
@@ -172,7 +171,6 @@ static int dw_i2c_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "failure adding adapter\n");
 		return r;
 	}
-	of_i2c_register_devices(adap);
 	acpi_i2c_register_devices(adap);
 
 	pm_runtime_set_autosuspend_delay(&pdev->dev, 1000);

commit dfb03fb246dc893743a28d00966b1862ae836f2d
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Mon Jul 15 11:28:59 2013 +0900

    i2c: designware: add CONFIG_PM_SLEEP to suspend/resume functions
    
    Add CONFIG_PM_SLEEP to suspend/resume functions to fix the following
    build warning when CONFIG_PM_SLEEP is not selected. This is because
    sleep PM callbacks defined by SIMPLE_DEV_PM_OPS are only used when
    the CONFIG_PM_SLEEP is enabled.
    
    drivers/i2c/busses/i2c-designware-platdrv.c:211:12: warning: 'dw_i2c_suspend' defined but not used [-Wunused-function]
    drivers/i2c/busses/i2c-designware-platdrv.c:221:12: warning: 'dw_i2c_resume' defined but not used [-Wunused-function]
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 4c5fadabe49d..64ffb908641c 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -207,7 +207,7 @@ static const struct of_device_id dw_i2c_of_match[] = {
 MODULE_DEVICE_TABLE(of, dw_i2c_of_match);
 #endif
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 static int dw_i2c_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
@@ -228,9 +228,12 @@ static int dw_i2c_resume(struct device *dev)
 
 	return 0;
 }
-#endif
 
 static SIMPLE_DEV_PM_OPS(dw_i2c_dev_pm_ops, dw_i2c_suspend, dw_i2c_resume);
+#define DW_I2C_DEV_PM_OPS	(&dw_i2c_dev_pm_ops)
+#else
+#define DW_I2C_DEV_PM_OPS	NULL
+#endif
 
 /* work with hotplug and coldplug */
 MODULE_ALIAS("platform:i2c_designware");
@@ -242,7 +245,7 @@ static struct platform_driver dw_i2c_driver = {
 		.owner	= THIS_MODULE,
 		.of_match_table = of_match_ptr(dw_i2c_of_match),
 		.acpi_match_table = ACPI_PTR(dw_i2c_acpi_match),
-		.pm	= &dw_i2c_dev_pm_ops,
+		.pm	= DW_I2C_DEV_PM_OPS,
 	},
 };
 

commit 97191d734f6ac028e5e6dcd574378c1544a16c0b
Author: Vincent Stehl <vincent.stehle@freescale.com>
Date:   Tue Jul 2 11:46:54 2013 +0200

    i2c-designware: use div_u64 to fix link
    
    This fixes the following link error:
    
      drivers/built-in.o: In function `dw_i2c_probe':
      of_iommu.c:(.text+0x18c8f0): undefined reference to `__aeabi_uldivmod'
      make: *** [vmlinux] Error 1
    
    Signed-off-by: Vincent Stehl <vincent.stehle@freescale.com>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Reviewed-by: Christian Ruppert <christian.ruppert@abilis.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index def79b5fd4c8..4c5fadabe49d 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -122,7 +122,8 @@ static int dw_i2c_probe(struct platform_device *pdev)
 
 		of_property_read_u32(pdev->dev.of_node,
 					"i2c-sda-hold-time-ns", &ht);
-		dev->sda_hold_time = ((u64)ic_clk * ht + 500000) / 1000000;
+		dev->sda_hold_time = div_u64((u64)ic_clk * ht + 500000,
+					     1000000);
 	}
 
 	dev->functionality =

commit 9803f868944e879c4623c0d910e81f1ae89ccfb4
Author: Christian Ruppert <christian.ruppert@abilis.com>
Date:   Wed Jun 26 10:55:06 2013 +0200

    i2c-designware: make SDA hold time configurable
    
    This patch makes the SDA hold time configurable through device tree.
    
    Signed-off-by: Christian Ruppert <christian.ruppert@abilis.com>
    Signed-off-by: Pierrick Hascoet <pierrick.hascoet@abilis.com>
    Acked-by: Vineet Gupta <vgupta@synopsys.com> for arch/arc bits
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index ee46c92d7e3c..def79b5fd4c8 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -34,6 +34,7 @@
 #include <linux/sched.h>
 #include <linux/err.h>
 #include <linux/interrupt.h>
+#include <linux/of.h>
 #include <linux/of_i2c.h>
 #include <linux/platform_device.h>
 #include <linux/pm.h>
@@ -115,6 +116,15 @@ static int dw_i2c_probe(struct platform_device *pdev)
 		return PTR_ERR(dev->clk);
 	clk_prepare_enable(dev->clk);
 
+	if (pdev->dev.of_node) {
+		u32 ht = 0;
+		u32 ic_clk = dev->get_clk_rate_khz(dev);
+
+		of_property_read_u32(pdev->dev.of_node,
+					"i2c-sda-hold-time-ns", &ht);
+		dev->sda_hold_time = ((u64)ic_clk * ht + 500000) / 1000000;
+	}
+
 	dev->functionality =
 		I2C_FUNC_I2C |
 		I2C_FUNC_10BIT_ADDR |

commit 3cc2d009bc210516c61536273b304c4f6ccd797c
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Fri May 10 10:16:54 2013 +0200

    drivers/i2c/busses: don't check resource with devm_ioremap_resource
    
    devm_ioremap_resource does sanity checks on the given resource. No need to
    duplicate this in the driver.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 35b70a1edf57..ee46c92d7e3c 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -87,13 +87,6 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	struct resource *mem;
 	int irq, r;
 
-	/* NOTE: driver uses the static register mapping */
-	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!mem) {
-		dev_err(&pdev->dev, "no mem resource?\n");
-		return -EINVAL;
-	}
-
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
 		dev_err(&pdev->dev, "no irq resource?\n");
@@ -104,6 +97,7 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	if (!dev)
 		return -ENOMEM;
 
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	dev->base = devm_ioremap_resource(&pdev->dev, mem);
 	if (IS_ERR(dev->base))
 		return PTR_ERR(dev->base);

commit 5a7e6bd809ca2f06bd669bd477ad3d6b48a3dd9f
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon May 13 00:54:31 2013 +0000

    i2c: designware: add Intel BayTrail ACPI ID
    
    This is the same controller as on Intel Lynxpoint but the ACPI ID is
    different (8086F41). Add support for this.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 8ec91335d95a..35b70a1edf57 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -69,6 +69,7 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 static const struct acpi_device_id dw_i2c_acpi_match[] = {
 	{ "INT33C2", 0 },
 	{ "INT33C3", 0 },
+	{ "80860F41", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(acpi, dw_i2c_acpi_match);

commit 99bece775f988a4ee21ad3db9fd413caf1704ff6
Merge: 736a2dd2571a c39e8e4354ce
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 2 14:38:53 2013 -0700

    Merge branch 'i2c/for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux
    
    Pull i2c changes from Wolfram Sang:
    
     - an arbitration driver.  While the driver is quite simple, it caused
       discussion if we need additional arbitration on top of the one
       specified in the I2C standard.  Conclusion is that I accept a few
       generic mechanisms, but not very specific ones.
    
     - the core lost the detach_adapter() call.  It has no users anymore and
       was in the way for other cleanups.  attach_adapter() is sadly still
       there since there are users waiting to be converted.
    
     - the core gained a bus recovery infrastructure.  I2C defines a way to
       recover if the data line is stalled.  This mechanism is now in the
       core and drivers can now pass some data to make use of it.
    
     - bigger driver cleanups for designware, s3c2410
    
     - removing superfluous refcounting from drivers
    
     - removing Ben Dooks as second maintainer due to inactivity.  Thanks
       for all your work so far, Ben!
    
     - bugfixes, feature additions, devicetree fixups, simplifications...
    
    * 'i2c/for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux: (38 commits)
      i2c: xiic: must always write 16-bit words to TX_FIFO
      i2c: octeon: use HZ in timeout value
      i2c: octeon: Fix i2c fail problem when a process is terminated by a signal
      i2c: designware-pci: drop superfluous {get|put}_device
      i2c: designware-plat: drop superfluous {get|put}_device
      i2c: davinci: drop superfluous {get|put}_device
      MAINTAINERS: Ben Dooks is inactive regarding I2C
      i2c: mux: Add i2c-arb-gpio-challenge 'mux' driver
      i2c: at91: convert to dma_request_slave_channel_compat()
      i2c: mxs: do error checking and handling in PIO mode
      i2c: mxs: remove races in PIO code
      i2c-designware: switch to use runtime PM autosuspend
      i2c-designware: use usleep_range() in the busy-loop
      i2c-designware: enable/disable the controller properly
      i2c-designware: use dynamic adapter numbering on Lynxpoint
      i2c-designware-pci: use managed functions pcim_* and devm_*
      i2c-designware-pci: use dev_err() instead of printk()
      i2c-designware: move to managed functions (devm_*)
      i2c: remove CONFIG_HOTPLUG ifdefs
      i2c: s3c2410: Add SMBus emulation for block read
      ...

commit be7fbe6a8b4dd5b75db5a600bcd8de87f4761d85
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Thu Apr 18 15:43:07 2013 +0200

    i2c: designware-plat: drop superfluous {get|put}_device
    
    Driver core already takes care of refcounting, no need to do this on
    driver level again.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index dec939aca588..f7549b612ca5 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -170,9 +170,6 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	of_i2c_register_devices(adap);
 	acpi_i2c_register_devices(adap);
 
-	/* Increase reference counter */
-	get_device(&pdev->dev);
-
 	pm_runtime_set_autosuspend_delay(&pdev->dev, 1000);
 	pm_runtime_use_autosuspend(&pdev->dev);
 	pm_runtime_set_active(&pdev->dev);
@@ -188,7 +185,6 @@ static int dw_i2c_remove(struct platform_device *pdev)
 	pm_runtime_get_sync(&pdev->dev);
 
 	i2c_del_adapter(&dev->adapter);
-	put_device(&pdev->dev);
 
 	i2c_dw_disable(dev);
 

commit 43452335224bc0cbd605c6aee82b5c9c33e94cc6
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Apr 10 00:36:42 2013 +0000

    i2c-designware: switch to use runtime PM autosuspend
    
    Using autosuspend helps to reduce the resume latency in situations where
    another I2C message is going to be started soon. For example with HID over
    I2C touch panels we get several messages in a short period of time while
    the touch panel is in use.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 2a596dd1ec66..dec939aca588 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -173,9 +173,10 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	/* Increase reference counter */
 	get_device(&pdev->dev);
 
+	pm_runtime_set_autosuspend_delay(&pdev->dev, 1000);
+	pm_runtime_use_autosuspend(&pdev->dev);
 	pm_runtime_set_active(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
-	pm_runtime_put(&pdev->dev);
 
 	return 0;
 }

commit efe7d640ef486c4c0c305641dbcacc6918542b76
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Wed Apr 10 00:36:39 2013 +0000

    i2c-designware: use dynamic adapter numbering on Lynxpoint
    
    It is not good idea to mix static and dynamic I2C adapter numbering. In
    this particular case on Lynxpoint we had graphics I2C adapter which took
    the first numbers preventing the designware I2C driver from using the
    adapter numbers it preferred.
    
    Since Lynxpoint support was just introduced and there is no hardware available
    outside Intel we can fix this by switching to use dynamic adapter numbering
    instead of static.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index c53a3127f694..2a596dd1ec66 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -56,20 +56,11 @@ static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
 static int dw_i2c_acpi_configure(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
-	struct acpi_device *adev;
-	int busno, ret;
 
 	if (!ACPI_HANDLE(&pdev->dev))
 		return -ENODEV;
 
-	ret = acpi_bus_get_device(ACPI_HANDLE(&pdev->dev), &adev);
-	if (ret)
-		return -ENODEV;
-
 	dev->adapter.nr = -1;
-	if (adev->pnp.unique_id && !kstrtoint(adev->pnp.unique_id, 0, &busno))
-		dev->adapter.nr = busno;
-
 	dev->tx_fifo_depth = 32;
 	dev->rx_fifo_depth = 32;
 	return 0;

commit 1cb715ca46946b1ad32735d11830a84a433f2b1b
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Apr 10 00:36:36 2013 +0000

    i2c-designware: move to managed functions (devm_*)
    
    This makes the error handling much more simpler than open-coding everything
    and in addition makes the probe function smaller and tidier.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 0ceb6e1b0f65..c53a3127f694 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -92,7 +92,7 @@ static int dw_i2c_probe(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev;
 	struct i2c_adapter *adap;
-	struct resource *mem, *ioarea;
+	struct resource *mem;
 	int irq, r;
 
 	/* NOTE: driver uses the static register mapping */
@@ -108,32 +108,25 @@ static int dw_i2c_probe(struct platform_device *pdev)
 		return irq; /* -ENXIO */
 	}
 
-	ioarea = request_mem_region(mem->start, resource_size(mem),
-			pdev->name);
-	if (!ioarea) {
-		dev_err(&pdev->dev, "I2C region already claimed\n");
-		return -EBUSY;
-	}
+	dev = devm_kzalloc(&pdev->dev, sizeof(struct dw_i2c_dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
 
-	dev = kzalloc(sizeof(struct dw_i2c_dev), GFP_KERNEL);
-	if (!dev) {
-		r = -ENOMEM;
-		goto err_release_region;
-	}
+	dev->base = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(dev->base))
+		return PTR_ERR(dev->base);
 
 	init_completion(&dev->cmd_complete);
 	mutex_init(&dev->lock);
-	dev->dev = get_device(&pdev->dev);
+	dev->dev = &pdev->dev;
 	dev->irq = irq;
 	platform_set_drvdata(pdev, dev);
 
-	dev->clk = clk_get(&pdev->dev, NULL);
+	dev->clk = devm_clk_get(&pdev->dev, NULL);
 	dev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;
 
-	if (IS_ERR(dev->clk)) {
-		r = -ENODEV;
-		goto err_free_mem;
-	}
+	if (IS_ERR(dev->clk))
+		return PTR_ERR(dev->clk);
 	clk_prepare_enable(dev->clk);
 
 	dev->functionality =
@@ -146,13 +139,6 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	dev->master_cfg =  DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
 		DW_IC_CON_RESTART_EN | DW_IC_CON_SPEED_FAST;
 
-	dev->base = ioremap(mem->start, resource_size(mem));
-	if (dev->base == NULL) {
-		dev_err(&pdev->dev, "failure mapping io resources\n");
-		r = -EBUSY;
-		goto err_unuse_clocks;
-	}
-
 	/* Try first if we can configure the device from ACPI */
 	r = dw_i2c_acpi_configure(pdev);
 	if (r) {
@@ -164,13 +150,14 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	}
 	r = i2c_dw_init(dev);
 	if (r)
-		goto err_iounmap;
+		return r;
 
 	i2c_dw_disable_int(dev);
-	r = request_irq(dev->irq, i2c_dw_isr, IRQF_SHARED, pdev->name, dev);
+	r = devm_request_irq(&pdev->dev, dev->irq, i2c_dw_isr, IRQF_SHARED,
+			pdev->name, dev);
 	if (r) {
 		dev_err(&pdev->dev, "failure requesting irq %i\n", dev->irq);
-		goto err_iounmap;
+		return r;
 	}
 
 	adap = &dev->adapter;
@@ -187,57 +174,35 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	r = i2c_add_numbered_adapter(adap);
 	if (r) {
 		dev_err(&pdev->dev, "failure adding adapter\n");
-		goto err_free_irq;
+		return r;
 	}
 	of_i2c_register_devices(adap);
 	acpi_i2c_register_devices(adap);
 
+	/* Increase reference counter */
+	get_device(&pdev->dev);
+
 	pm_runtime_set_active(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
 	pm_runtime_put(&pdev->dev);
 
 	return 0;
-
-err_free_irq:
-	free_irq(dev->irq, dev);
-err_iounmap:
-	iounmap(dev->base);
-err_unuse_clocks:
-	clk_disable_unprepare(dev->clk);
-	clk_put(dev->clk);
-	dev->clk = NULL;
-err_free_mem:
-	put_device(&pdev->dev);
-	kfree(dev);
-err_release_region:
-	release_mem_region(mem->start, resource_size(mem));
-
-	return r;
 }
 
 static int dw_i2c_remove(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
-	struct resource *mem;
 
 	pm_runtime_get_sync(&pdev->dev);
 
 	i2c_del_adapter(&dev->adapter);
 	put_device(&pdev->dev);
 
-	clk_disable_unprepare(dev->clk);
-	clk_put(dev->clk);
-	dev->clk = NULL;
-
 	i2c_dw_disable(dev);
-	free_irq(dev->irq, dev);
-	kfree(dev);
 
 	pm_runtime_put(&pdev->dev);
 	pm_runtime_disable(&pdev->dev);
 
-	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	release_mem_region(mem->start, resource_size(mem));
 	return 0;
 }
 

commit b34bb1ee71158d5b0f9028fb98afd026202bcfe9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Apr 1 00:25:03 2013 +0000

    ACPI / I2C: Use parent's ACPI_HANDLE() in acpi_i2c_register_devices()
    
    The ACPI handle of struct i2c_adapter's dev member should not be
    set, because this causes that struct i2c_adapter to be associated
    with the ACPI device node corresponding to its parent as the
    second "physical_device", which is incorrect (this happens during
    the registration of struct i2c_adapter).  Consequently,
    acpi_i2c_register_devices() should use the ACPI handle of the
    parent of the struct i2c_adapter it is called for rather than the
    struct i2c_adapter's ACPI handle (which should be NULL).
    
    Make that happen and modify the i2c-designware-platdrv driver,
    which currently is the only driver for ACPI-enumerated I2C
    controller chips, not to set the ACPI handle for the
    struct i2c_adapter it creates.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 0ceb6e1b0f65..e3085c487ace 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -182,7 +182,6 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	adap->algo = &i2c_dw_algo;
 	adap->dev.parent = &pdev->dev;
 	adap->dev.of_node = pdev->dev.of_node;
-	ACPI_HANDLE_SET(&adap->dev, ACPI_HANDLE(&pdev->dev));
 
 	r = i2c_add_numbered_adapter(adap);
 	if (r) {

commit 55827f4aa6442ddd1d6a4e1e32f2f457eb113c22
Author: Doug Anderson <dianders@chromium.org>
Date:   Fri Feb 15 13:18:35 2013 +0000

    i2c: Remove unneeded xxx_set_drvdata(..., NULL) calls
    
    There is simply no reason to be manually setting the private driver
    data to NULL in the remove/fail to probe cases.  This is just extra
    cruft code that can be removed.
    
    A few notes:
    * Nothing relies on drvdata being set to NULL.
    * The __device_release_driver() function eventually calls
      dev_set_drvdata(dev, NULL) anyway, so there's no need to do it
      twice.
    * I verified that there were no cases where xxx_get_drvdata() was
      being called in these drivers and checking for / relying on the NULL
      return value.
    
    This could be cleaned up kernel-wide but for now just take the baby
    step and remove from the i2c subsystem.
    
    Reported-by: Wolfram Sang <wsa@the-dreams.de>
    Reported-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Doug Anderson <dianders@chromium.org>
    Reviewed-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Peter Korsgaard <jacmet@sunsite.dk>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Marek Vasut <marex@denx.de>
    Signed-off-by: Wolfram Sang <wolfram@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index d2a33e93f8ab..0ceb6e1b0f65 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -207,7 +207,6 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	clk_put(dev->clk);
 	dev->clk = NULL;
 err_free_mem:
-	platform_set_drvdata(pdev, NULL);
 	put_device(&pdev->dev);
 	kfree(dev);
 err_release_region:
@@ -221,7 +220,6 @@ static int dw_i2c_remove(struct platform_device *pdev)
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
 	struct resource *mem;
 
-	platform_set_drvdata(pdev, NULL);
 	pm_runtime_get_sync(&pdev->dev);
 
 	i2c_del_adapter(&dev->adapter);

commit b61b14154b19e1ef1da9c1e283f0cf93470e0c70
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Jan 17 12:31:07 2013 +0200

    i2c-designware: add support for Intel Lynxpoint
    
    Intel Lynxpoint has two I2C controllers. These controllers are enumerated
    from ACPI namespace with IDs INT33C2 and INT33C3. Add support for these to
    the I2C DesignWare platform driver.
    
    This is based on the work of Dirk Brandewie.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index d8afc85420be..d2a33e93f8ab 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -40,6 +40,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/io.h>
 #include <linux/slab.h>
+#include <linux/acpi.h>
 #include "i2c-designware-core.h"
 
 static struct i2c_algorithm i2c_dw_algo = {
@@ -51,6 +52,42 @@ static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
 	return clk_get_rate(dev->clk)/1000;
 }
 
+#ifdef CONFIG_ACPI
+static int dw_i2c_acpi_configure(struct platform_device *pdev)
+{
+	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
+	struct acpi_device *adev;
+	int busno, ret;
+
+	if (!ACPI_HANDLE(&pdev->dev))
+		return -ENODEV;
+
+	ret = acpi_bus_get_device(ACPI_HANDLE(&pdev->dev), &adev);
+	if (ret)
+		return -ENODEV;
+
+	dev->adapter.nr = -1;
+	if (adev->pnp.unique_id && !kstrtoint(adev->pnp.unique_id, 0, &busno))
+		dev->adapter.nr = busno;
+
+	dev->tx_fifo_depth = 32;
+	dev->rx_fifo_depth = 32;
+	return 0;
+}
+
+static const struct acpi_device_id dw_i2c_acpi_match[] = {
+	{ "INT33C2", 0 },
+	{ "INT33C3", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, dw_i2c_acpi_match);
+#else
+static inline int dw_i2c_acpi_configure(struct platform_device *pdev)
+{
+	return -ENODEV;
+}
+#endif
+
 static int dw_i2c_probe(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev;
@@ -115,18 +152,22 @@ static int dw_i2c_probe(struct platform_device *pdev)
 		r = -EBUSY;
 		goto err_unuse_clocks;
 	}
-	{
+
+	/* Try first if we can configure the device from ACPI */
+	r = dw_i2c_acpi_configure(pdev);
+	if (r) {
 		u32 param1 = i2c_dw_read_comp_param(dev);
 
 		dev->tx_fifo_depth = ((param1 >> 16) & 0xff) + 1;
 		dev->rx_fifo_depth = ((param1 >> 8)  & 0xff) + 1;
+		dev->adapter.nr = pdev->id;
 	}
 	r = i2c_dw_init(dev);
 	if (r)
 		goto err_iounmap;
 
 	i2c_dw_disable_int(dev);
-	r = request_irq(dev->irq, i2c_dw_isr, IRQF_DISABLED, pdev->name, dev);
+	r = request_irq(dev->irq, i2c_dw_isr, IRQF_SHARED, pdev->name, dev);
 	if (r) {
 		dev_err(&pdev->dev, "failure requesting irq %i\n", dev->irq);
 		goto err_iounmap;
@@ -141,14 +182,15 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	adap->algo = &i2c_dw_algo;
 	adap->dev.parent = &pdev->dev;
 	adap->dev.of_node = pdev->dev.of_node;
+	ACPI_HANDLE_SET(&adap->dev, ACPI_HANDLE(&pdev->dev));
 
-	adap->nr = pdev->id;
 	r = i2c_add_numbered_adapter(adap);
 	if (r) {
 		dev_err(&pdev->dev, "failure adding adapter\n");
 		goto err_free_irq;
 	}
 	of_i2c_register_devices(adap);
+	acpi_i2c_register_devices(adap);
 
 	pm_runtime_set_active(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
@@ -243,6 +285,7 @@ static struct platform_driver dw_i2c_driver = {
 		.name	= "i2c_designware",
 		.owner	= THIS_MODULE,
 		.of_match_table = of_match_ptr(dw_i2c_of_match),
+		.acpi_match_table = ACPI_PTR(dw_i2c_acpi_match),
 		.pm	= &dw_i2c_dev_pm_ops,
 	},
 };

commit 7272194ed391f9db8bb320c50d715e7e6bba8ff3
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Jan 17 12:31:06 2013 +0200

    i2c-designware: add minimal support for runtime PM
    
    In order to save power the device should be put to low power states
    whenever it is not being used. We implement this by enabling minimal
    runtime PM support.
    
    There isn't much to do for the device itself as it is disabled once the
    last transfer is completed but subsystem/domain runtime PM hooks can save
    more power by power gating the device etc.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 343357a2b5b4..d8afc85420be 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -37,6 +37,7 @@
 #include <linux/of_i2c.h>
 #include <linux/platform_device.h>
 #include <linux/pm.h>
+#include <linux/pm_runtime.h>
 #include <linux/io.h>
 #include <linux/slab.h>
 #include "i2c-designware-core.h"
@@ -149,6 +150,10 @@ static int dw_i2c_probe(struct platform_device *pdev)
 	}
 	of_i2c_register_devices(adap);
 
+	pm_runtime_set_active(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
+	pm_runtime_put(&pdev->dev);
+
 	return 0;
 
 err_free_irq:
@@ -175,6 +180,8 @@ static int dw_i2c_remove(struct platform_device *pdev)
 	struct resource *mem;
 
 	platform_set_drvdata(pdev, NULL);
+	pm_runtime_get_sync(&pdev->dev);
+
 	i2c_del_adapter(&dev->adapter);
 	put_device(&pdev->dev);
 
@@ -186,6 +193,9 @@ static int dw_i2c_remove(struct platform_device *pdev)
 	free_irq(dev->irq, dev);
 	kfree(dev);
 
+	pm_runtime_put(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	release_mem_region(mem->start, resource_size(mem));
 	return 0;

commit 0b255e927d47b550620dfd3475ee74b0f52e09c8
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Tue Nov 27 15:59:38 2012 -0500

    i2c: remove __dev* attributes from subsystem
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Acked-by: Peter Korsgaard <peter.korsgaard@barco.com> (for ocores and mux-gpio)
    Acked-by: Havard Skinnemoen <hskinnemoen@gmail.com> (for i2c-gpio)
    Acked-by: Guan Xuetao <gxt@mprc.pku.edu.cn> (for puf3)
    Acked-by: Barry Song <baohua.song@csr.com> (for sirf)
    Reviewed-by: Jean Delvare <khali@linux-fr.org>
    [wsa: Fixed "foo* bar" flaws while we are here]
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 0506fef8dc00..343357a2b5b4 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -50,7 +50,7 @@ static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
 	return clk_get_rate(dev->clk)/1000;
 }
 
-static int __devinit dw_i2c_probe(struct platform_device *pdev)
+static int dw_i2c_probe(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev;
 	struct i2c_adapter *adap;
@@ -169,7 +169,7 @@ static int __devinit dw_i2c_probe(struct platform_device *pdev)
 	return r;
 }
 
-static int __devexit dw_i2c_remove(struct platform_device *pdev)
+static int dw_i2c_remove(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
 	struct resource *mem;
@@ -228,7 +228,7 @@ static SIMPLE_DEV_PM_OPS(dw_i2c_dev_pm_ops, dw_i2c_suspend, dw_i2c_resume);
 MODULE_ALIAS("platform:i2c_designware");
 
 static struct platform_driver dw_i2c_driver = {
-	.remove		= __devexit_p(dw_i2c_remove),
+	.remove		= dw_i2c_remove,
 	.driver		= {
 		.name	= "i2c_designware",
 		.owner	= THIS_MODULE,

commit e1fac69f3b2c0430f56f47bf98eebac8b2da395c
Author: Viresh Kumar <viresh.kumar@st.com>
Date:   Tue Apr 17 17:04:31 2012 +0530

    i2c: designware: Add clk_{un}prepare() support
    
    clk_{un}prepare is mandatory for platforms using common clock framework. Since
    this driver is used by SPEAr platform, which supports common clock framework,
    add clk_{un}prepare() support for designware i2c.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@st.com>
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index f08d0248cf6b..0506fef8dc00 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -96,7 +96,7 @@ static int __devinit dw_i2c_probe(struct platform_device *pdev)
 		r = -ENODEV;
 		goto err_free_mem;
 	}
-	clk_enable(dev->clk);
+	clk_prepare_enable(dev->clk);
 
 	dev->functionality =
 		I2C_FUNC_I2C |
@@ -156,7 +156,7 @@ static int __devinit dw_i2c_probe(struct platform_device *pdev)
 err_iounmap:
 	iounmap(dev->base);
 err_unuse_clocks:
-	clk_disable(dev->clk);
+	clk_disable_unprepare(dev->clk);
 	clk_put(dev->clk);
 	dev->clk = NULL;
 err_free_mem:
@@ -178,7 +178,7 @@ static int __devexit dw_i2c_remove(struct platform_device *pdev)
 	i2c_del_adapter(&dev->adapter);
 	put_device(&pdev->dev);
 
-	clk_disable(dev->clk);
+	clk_disable_unprepare(dev->clk);
 	clk_put(dev->clk);
 	dev->clk = NULL;
 
@@ -205,7 +205,7 @@ static int dw_i2c_suspend(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);
 
-	clk_disable(i_dev->clk);
+	clk_disable_unprepare(i_dev->clk);
 
 	return 0;
 }
@@ -215,7 +215,7 @@ static int dw_i2c_resume(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);
 
-	clk_enable(i_dev->clk);
+	clk_prepare_enable(i_dev->clk);
 	i2c_dw_init(i_dev);
 
 	return 0;

commit 3bf3b289c233c28aaef16546168a994070aa24a0
Author: Deepak Sikri <deepak.sikri@st.com>
Date:   Fri Feb 24 17:01:15 2012 +0530

    i2c: designware: add PM support
    
    This patch adds in support for standby/S2R/hybernate for i2c-designware driver.
    
    Signed-off-by: Deepak Sikri <deepak.sikri@st.com>
    Signed-off-by: Rajeev Kumar <rajeev-dlh.kumar@st.com>
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 4ba589ab8614..f08d0248cf6b 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -36,6 +36,7 @@
 #include <linux/interrupt.h>
 #include <linux/of_i2c.h>
 #include <linux/platform_device.h>
+#include <linux/pm.h>
 #include <linux/io.h>
 #include <linux/slab.h>
 #include "i2c-designware-core.h"
@@ -198,6 +199,31 @@ static const struct of_device_id dw_i2c_of_match[] = {
 MODULE_DEVICE_TABLE(of, dw_i2c_of_match);
 #endif
 
+#ifdef CONFIG_PM
+static int dw_i2c_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);
+
+	clk_disable(i_dev->clk);
+
+	return 0;
+}
+
+static int dw_i2c_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);
+
+	clk_enable(i_dev->clk);
+	i2c_dw_init(i_dev);
+
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(dw_i2c_dev_pm_ops, dw_i2c_suspend, dw_i2c_resume);
+
 /* work with hotplug and coldplug */
 MODULE_ALIAS("platform:i2c_designware");
 
@@ -207,6 +233,7 @@ static struct platform_driver dw_i2c_driver = {
 		.name	= "i2c_designware",
 		.owner	= THIS_MODULE,
 		.of_match_table = of_match_ptr(dw_i2c_of_match),
+		.pm	= &dw_i2c_dev_pm_ops,
 	},
 };
 

commit 104522806a7d9d47c34f425dee2bcd7f1ee5613e
Author: Pratyush Anand <pratyush.anand@st.com>
Date:   Wed Feb 29 12:27:46 2012 +0530

    i2c: designware: dw_i2c_init_driver as subsys initcall
    
    There are few drivers which are available on i2c bus but have been initialized
    with subsys_initcall. Also as I2C is a bus driver, it should be available as
    early as possible.
    
    Signed-off-by: Pratyush Anand <pratyush.anand@st.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@st.com>
    
    [wsa: Slightly updated the commit message]
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 5244c4724df7..4ba589ab8614 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -214,7 +214,7 @@ static int __init dw_i2c_init_driver(void)
 {
 	return platform_driver_probe(&dw_i2c_driver, dw_i2c_probe);
 }
-module_init(dw_i2c_init_driver);
+subsys_initcall(dw_i2c_init_driver);
 
 static void __exit dw_i2c_exit_driver(void)
 {

commit af71100c7acf3ccaf95044cd5e9e866178e5f8a1
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Tue Nov 8 14:43:47 2011 -0600

    i2c-designware: add OF binding support
    
    Add of_match_table and DT style i2c registration to designware i2c
    driver.
    
    Refactored for pci/plat split by Dirk Brandewie.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Dirk Brandewie <dirk.brandewie@gmail.com>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 2d3657ab1258..5244c4724df7 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -34,6 +34,7 @@
 #include <linux/sched.h>
 #include <linux/err.h>
 #include <linux/interrupt.h>
+#include <linux/of_i2c.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
 #include <linux/slab.h>
@@ -137,6 +138,7 @@ static int __devinit dw_i2c_probe(struct platform_device *pdev)
 			sizeof(adap->name));
 	adap->algo = &i2c_dw_algo;
 	adap->dev.parent = &pdev->dev;
+	adap->dev.of_node = pdev->dev.of_node;
 
 	adap->nr = pdev->id;
 	r = i2c_add_numbered_adapter(adap);
@@ -144,6 +146,7 @@ static int __devinit dw_i2c_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "failure adding adapter\n");
 		goto err_free_irq;
 	}
+	of_i2c_register_devices(adap);
 
 	return 0;
 
@@ -187,6 +190,14 @@ static int __devexit dw_i2c_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#ifdef CONFIG_OF
+static const struct of_device_id dw_i2c_of_match[] = {
+	{ .compatible = "snps,designware-i2c", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, dw_i2c_of_match);
+#endif
+
 /* work with hotplug and coldplug */
 MODULE_ALIAS("platform:i2c_designware");
 
@@ -195,6 +206,7 @@ static struct platform_driver dw_i2c_driver = {
 	.driver		= {
 		.name	= "i2c_designware",
 		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(dw_i2c_of_match),
 	},
 };
 

commit f3fa9f3da5621154323775ff0efdba99dcebcee4
Author: Dirk Brandewie <dirk.brandewie@gmail.com>
Date:   Thu Oct 6 11:26:34 2011 -0700

    i2c-designware: Push all register reads/writes into the core code.
    
    Move all register manipulation code into the core, also move register
    offset definitions to i2c-designware-core.c since the bus specific
    portions of the driver no longer need/use them.
    
    Signed-off-by: Dirk Brandewie <dirk.brandewie@gmail.com>
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 1258cae3555d..2d3657ab1258 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -113,7 +113,7 @@ static int __devinit dw_i2c_probe(struct platform_device *pdev)
 		goto err_unuse_clocks;
 	}
 	{
-		u32 param1 = dw_readl(dev, DW_IC_COMP_PARAM_1);
+		u32 param1 = i2c_dw_read_comp_param(dev);
 
 		dev->tx_fifo_depth = ((param1 >> 16) & 0xff) + 1;
 		dev->rx_fifo_depth = ((param1 >> 8)  & 0xff) + 1;
@@ -122,7 +122,7 @@ static int __devinit dw_i2c_probe(struct platform_device *pdev)
 	if (r)
 		goto err_iounmap;
 
-	dw_writel(dev, 0, DW_IC_INTR_MASK); /* disable IRQ */
+	i2c_dw_disable_int(dev);
 	r = request_irq(dev->irq, i2c_dw_isr, IRQF_DISABLED, pdev->name, dev);
 	if (r) {
 		dev_err(&pdev->dev, "failure requesting irq %i\n", dev->irq);
@@ -178,7 +178,7 @@ static int __devexit dw_i2c_remove(struct platform_device *pdev)
 	clk_put(dev->clk);
 	dev->clk = NULL;
 
-	dw_writel(dev, 0, DW_IC_ENABLE);
+	i2c_dw_disable(dev);
 	free_irq(dev->irq, dev);
 	kfree(dev);
 

commit e18563fc560aba0d95a5a73145812a081fb38fac
Author: Dirk Brandewie <dirk.brandewie@gmail.com>
Date:   Thu Oct 6 11:26:32 2011 -0700

    i2c-designware: move controller config to bus specific portion of driver
    
    With multiple I2C adapters possible in the system each running at
    (possibly) different speeds we need to move the controller
    configuration bit field to the adapter.
    
    Signed-off-by: Dirk Brandewie <dirk.brandewie@gmail.com>
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 36db7a80cbb2..1258cae3555d 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -103,6 +103,8 @@ static int __devinit dw_i2c_probe(struct platform_device *pdev)
 		I2C_FUNC_SMBUS_BYTE_DATA |
 		I2C_FUNC_SMBUS_WORD_DATA |
 		I2C_FUNC_SMBUS_I2C_BLOCK;
+	dev->master_cfg =  DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
+		DW_IC_CON_RESTART_EN | DW_IC_CON_SPEED_FAST;
 
 	dev->base = ioremap(mem->start, resource_size(mem));
 	if (dev->base == NULL) {

commit 2fa8326b4b1e5fdc889b57b03b1313f3229cb438
Author: Dirk Brandewie <dirk.brandewie@gmail.com>
Date:   Thu Oct 6 11:26:31 2011 -0700

    i2c-designware: move i2c functionality bit field to be adapter specific
    
    The functionality of the adapter depends on the configuration of the
    IP block at silicon compile time and is adapter specific.
    
    Signed-off-by: Dirk Brandewie <dirk.brandewie@gmail.com>
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 08783a6ff1a2..36db7a80cbb2 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -96,6 +96,14 @@ static int __devinit dw_i2c_probe(struct platform_device *pdev)
 	}
 	clk_enable(dev->clk);
 
+	dev->functionality =
+		I2C_FUNC_I2C |
+		I2C_FUNC_10BIT_ADDR |
+		I2C_FUNC_SMBUS_BYTE |
+		I2C_FUNC_SMBUS_BYTE_DATA |
+		I2C_FUNC_SMBUS_WORD_DATA |
+		I2C_FUNC_SMBUS_I2C_BLOCK;
+
 	dev->base = ioremap(mem->start, resource_size(mem));
 	if (dev->base == NULL) {
 		dev_err(&pdev->dev, "failure mapping io resources\n");

commit 1d31b58f648c4f754b23fed4d57acc941080e5ee
Author: Dirk Brandewie <dirk.brandewie@gmail.com>
Date:   Thu Oct 6 11:26:30 2011 -0700

    i2c-designware: Move retriveving the clock speed out of core code.
    
    The clock frequecy supplied to the IP core is specific to a single
    instance of the driver.  This patch makes it possible to have multiple
    Designware I2C cores in the system possibly running at different core
    frequencies.
    
    Signed-off-by: Dirk Brandewie <dirk.brandewie@gmail.com>
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 9d10ae8c6957..08783a6ff1a2 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -43,6 +43,10 @@ static struct i2c_algorithm i2c_dw_algo = {
 	.master_xfer	= i2c_dw_xfer,
 	.functionality	= i2c_dw_func,
 };
+static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
+{
+	return clk_get_rate(dev->clk)/1000;
+}
 
 static int __devinit dw_i2c_probe(struct platform_device *pdev)
 {
@@ -84,6 +88,8 @@ static int __devinit dw_i2c_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, dev);
 
 	dev->clk = clk_get(&pdev->dev, NULL);
+	dev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;
+
 	if (IS_ERR(dev->clk)) {
 		r = -ENODEV;
 		goto err_free_mem;

commit 2373f6b9744d5373b886f3ce1a985193cca0a356
Author: Dirk Brandewie <dirk.brandewie@gmail.com>
Date:   Sat Oct 29 10:57:23 2011 +0100

    i2c-designware: split of i2c-designware.c into core and bus specific parts
    
    This patch splits i2c-designware.c into three pieces:
         i2c-designware-core.c, contains the code that interacts directly
         with the core.
    
         i2c-designware-platdrv.c, contains the code specific to the
         platform driver using the core.
    
         i2c-designware-core.h contains the definitions and declareations
         shared by i2c-designware-core.c and i2c-designware-platdrv.c.
    
    This patch is the first in a set to allow multiple instances of the
    designware I2C core in the system.
    
    Signed-off-by: Dirk Brandewie <dirk.brandewie@gmail.com>
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>

diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
new file mode 100644
index 000000000000..9d10ae8c6957
--- /dev/null
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -0,0 +1,199 @@
+/*
+ * Synopsys DesignWare I2C adapter driver (master only).
+ *
+ * Based on the TI DAVINCI I2C adapter driver.
+ *
+ * Copyright (C) 2006 Texas Instruments.
+ * Copyright (C) 2007 MontaVista Software Inc.
+ * Copyright (C) 2009 Provigent Ltd.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include "i2c-designware-core.h"
+
+static struct i2c_algorithm i2c_dw_algo = {
+	.master_xfer	= i2c_dw_xfer,
+	.functionality	= i2c_dw_func,
+};
+
+static int __devinit dw_i2c_probe(struct platform_device *pdev)
+{
+	struct dw_i2c_dev *dev;
+	struct i2c_adapter *adap;
+	struct resource *mem, *ioarea;
+	int irq, r;
+
+	/* NOTE: driver uses the static register mapping */
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem) {
+		dev_err(&pdev->dev, "no mem resource?\n");
+		return -EINVAL;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "no irq resource?\n");
+		return irq; /* -ENXIO */
+	}
+
+	ioarea = request_mem_region(mem->start, resource_size(mem),
+			pdev->name);
+	if (!ioarea) {
+		dev_err(&pdev->dev, "I2C region already claimed\n");
+		return -EBUSY;
+	}
+
+	dev = kzalloc(sizeof(struct dw_i2c_dev), GFP_KERNEL);
+	if (!dev) {
+		r = -ENOMEM;
+		goto err_release_region;
+	}
+
+	init_completion(&dev->cmd_complete);
+	mutex_init(&dev->lock);
+	dev->dev = get_device(&pdev->dev);
+	dev->irq = irq;
+	platform_set_drvdata(pdev, dev);
+
+	dev->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(dev->clk)) {
+		r = -ENODEV;
+		goto err_free_mem;
+	}
+	clk_enable(dev->clk);
+
+	dev->base = ioremap(mem->start, resource_size(mem));
+	if (dev->base == NULL) {
+		dev_err(&pdev->dev, "failure mapping io resources\n");
+		r = -EBUSY;
+		goto err_unuse_clocks;
+	}
+	{
+		u32 param1 = dw_readl(dev, DW_IC_COMP_PARAM_1);
+
+		dev->tx_fifo_depth = ((param1 >> 16) & 0xff) + 1;
+		dev->rx_fifo_depth = ((param1 >> 8)  & 0xff) + 1;
+	}
+	r = i2c_dw_init(dev);
+	if (r)
+		goto err_iounmap;
+
+	dw_writel(dev, 0, DW_IC_INTR_MASK); /* disable IRQ */
+	r = request_irq(dev->irq, i2c_dw_isr, IRQF_DISABLED, pdev->name, dev);
+	if (r) {
+		dev_err(&pdev->dev, "failure requesting irq %i\n", dev->irq);
+		goto err_iounmap;
+	}
+
+	adap = &dev->adapter;
+	i2c_set_adapdata(adap, dev);
+	adap->owner = THIS_MODULE;
+	adap->class = I2C_CLASS_HWMON;
+	strlcpy(adap->name, "Synopsys DesignWare I2C adapter",
+			sizeof(adap->name));
+	adap->algo = &i2c_dw_algo;
+	adap->dev.parent = &pdev->dev;
+
+	adap->nr = pdev->id;
+	r = i2c_add_numbered_adapter(adap);
+	if (r) {
+		dev_err(&pdev->dev, "failure adding adapter\n");
+		goto err_free_irq;
+	}
+
+	return 0;
+
+err_free_irq:
+	free_irq(dev->irq, dev);
+err_iounmap:
+	iounmap(dev->base);
+err_unuse_clocks:
+	clk_disable(dev->clk);
+	clk_put(dev->clk);
+	dev->clk = NULL;
+err_free_mem:
+	platform_set_drvdata(pdev, NULL);
+	put_device(&pdev->dev);
+	kfree(dev);
+err_release_region:
+	release_mem_region(mem->start, resource_size(mem));
+
+	return r;
+}
+
+static int __devexit dw_i2c_remove(struct platform_device *pdev)
+{
+	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
+	struct resource *mem;
+
+	platform_set_drvdata(pdev, NULL);
+	i2c_del_adapter(&dev->adapter);
+	put_device(&pdev->dev);
+
+	clk_disable(dev->clk);
+	clk_put(dev->clk);
+	dev->clk = NULL;
+
+	dw_writel(dev, 0, DW_IC_ENABLE);
+	free_irq(dev->irq, dev);
+	kfree(dev);
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(mem->start, resource_size(mem));
+	return 0;
+}
+
+/* work with hotplug and coldplug */
+MODULE_ALIAS("platform:i2c_designware");
+
+static struct platform_driver dw_i2c_driver = {
+	.remove		= __devexit_p(dw_i2c_remove),
+	.driver		= {
+		.name	= "i2c_designware",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init dw_i2c_init_driver(void)
+{
+	return platform_driver_probe(&dw_i2c_driver, dw_i2c_probe);
+}
+module_init(dw_i2c_init_driver);
+
+static void __exit dw_i2c_exit_driver(void)
+{
+	platform_driver_unregister(&dw_i2c_driver);
+}
+module_exit(dw_i2c_exit_driver);
+
+MODULE_AUTHOR("Baruch Siach <baruch@tkos.co.il>");
+MODULE_DESCRIPTION("Synopsys DesignWare I2C bus adapter");
+MODULE_LICENSE("GPL");
