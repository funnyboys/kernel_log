commit e42688ed5cf5936fb55c78cc365dbe0944af7c63
Author: Dejin Zheng <zhengdejin5@gmail.com>
Date:   Thu Apr 16 23:23:45 2020 +0800

    i2c: busses: remove duplicate dev_err()
    
    it will print an error message by itself when platform_get_irq()
    goes wrong. so don't need dev_err() in here again.
    
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Suggested-by: Markus Elfring <Markus.Elfring@web.de>
    Signed-off-by: Dejin Zheng <zhengdejin5@gmail.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier.c b/drivers/i2c/busses/i2c-uniphier.c
index 668b1fa2b0ef..ee00a44bf4c7 100644
--- a/drivers/i2c/busses/i2c-uniphier.c
+++ b/drivers/i2c/busses/i2c-uniphier.c
@@ -324,10 +324,8 @@ static int uniphier_i2c_probe(struct platform_device *pdev)
 		return PTR_ERR(priv->membase);
 
 	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		dev_err(dev, "failed to get IRQ number\n");
+	if (irq < 0)
 		return irq;
-	}
 
 	if (of_property_read_u32(dev->of_node, "clock-frequency", &bus_speed))
 		bus_speed = I2C_MAX_STANDARD_MODE_FREQ;

commit 90224e6468e15d5eb22a10ae1849cf8ca2e7360a
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Mar 24 14:32:16 2020 +0200

    i2c: drivers: Use generic definitions for bus frequencies
    
    Since we have generic definitions for bus frequencies, let's use them.
    
    Reviewed-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Acked-by: Robert Richter <rrichter@marvell.com>
    Reviewed-by: Thor Thayer <thor.thayer@linux.intel.com>
    Acked-by: Elie Morisse <syniurge@gmail.com>
    Acked-by: Nehal Shah <nehal-bakulchandra.shah@amd.com>
    Reviewed-by: Brendan Higgins <brendanhiggins@google.com>
    Acked-by: Scott Branden <scott.branden@broadcom.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Baruch Siach <baruch@tkos.co.il>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Oleksij Rempel <o.rempel@pengutronix.de>
    Acked-by: Vladimir Zapolskiy <vz@mleia.com>
    Acked-by: Gregory CLEMENT <gregory.clement@bootlin.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
    Reviewed-by: Chris Brandt <chris.brandt@renesas.com>
    Reviewed-by: Baolin Wang <baolin.wang7@gmail.com>
    Reviewed-by: Pierre-Yves MORDRET <pierre-yves.mordret@st.com>
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    Acked-by: Ard Biesheuvel <ardb@kernel.org>
    Reviewed-by: Dmitry Osipenko <digetx@gmail.com>
    Acked-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier.c b/drivers/i2c/busses/i2c-uniphier.c
index 0270090c0360..668b1fa2b0ef 100644
--- a/drivers/i2c/busses/i2c-uniphier.c
+++ b/drivers/i2c/busses/i2c-uniphier.c
@@ -35,9 +35,6 @@
 #define UNIPHIER_I2C_NOISE	0x1c	/* noise filter control */
 #define UNIPHIER_I2C_SETUP	0x20	/* setup time control */
 
-#define UNIPHIER_I2C_DEFAULT_SPEED	100000
-#define UNIPHIER_I2C_MAX_SPEED		400000
-
 struct uniphier_i2c_priv {
 	struct completion comp;
 	struct i2c_adapter adap;
@@ -333,9 +330,9 @@ static int uniphier_i2c_probe(struct platform_device *pdev)
 	}
 
 	if (of_property_read_u32(dev->of_node, "clock-frequency", &bus_speed))
-		bus_speed = UNIPHIER_I2C_DEFAULT_SPEED;
+		bus_speed = I2C_MAX_STANDARD_MODE_FREQ;
 
-	if (!bus_speed || bus_speed > UNIPHIER_I2C_MAX_SPEED) {
+	if (!bus_speed || bus_speed > I2C_MAX_FAST_MODE_FREQ) {
 		dev_err(dev, "invalid clock-frequency %d\n", bus_speed);
 		return -EINVAL;
 	}

commit 9ee7e72fbbb835ba92b2cbf4349997adf065eab0
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Sep 5 13:46:48 2019 +0900

    i2c: uniphier(-f): remove all dev_dbg()
    
    I have fixed various bugs, and these drivers are (I hope) pretty
    stable now. Remove all dev_dbg() for code clean-up.
    
    If I end up with debugging the drivers again, I will locally revert
    this commit. I no longer need the debug code in upstream.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier.c b/drivers/i2c/busses/i2c-uniphier.c
index a6d7a3709051..0270090c0360 100644
--- a/drivers/i2c/busses/i2c-uniphier.c
+++ b/drivers/i2c/busses/i2c-uniphier.c
@@ -71,7 +71,6 @@ static int uniphier_i2c_xfer_byte(struct i2c_adapter *adap, u32 txdata,
 	reinit_completion(&priv->comp);
 
 	txdata |= UNIPHIER_I2C_DTRM_IRQEN;
-	dev_dbg(&adap->dev, "write data: 0x%04x\n", txdata);
 	writel(txdata, priv->membase + UNIPHIER_I2C_DTRM);
 
 	time_left = wait_for_completion_timeout(&priv->comp, adap->timeout);
@@ -81,8 +80,6 @@ static int uniphier_i2c_xfer_byte(struct i2c_adapter *adap, u32 txdata,
 	}
 
 	rxdata = readl(priv->membase + UNIPHIER_I2C_DREC);
-	dev_dbg(&adap->dev, "read data: 0x%04x\n", rxdata);
-
 	if (rxdatap)
 		*rxdatap = rxdata;
 
@@ -98,14 +95,11 @@ static int uniphier_i2c_send_byte(struct i2c_adapter *adap, u32 txdata)
 	if (ret)
 		return ret;
 
-	if (unlikely(rxdata & UNIPHIER_I2C_DREC_LAB)) {
-		dev_dbg(&adap->dev, "arbitration lost\n");
+	if (unlikely(rxdata & UNIPHIER_I2C_DREC_LAB))
 		return -EAGAIN;
-	}
-	if (unlikely(rxdata & UNIPHIER_I2C_DREC_LRB)) {
-		dev_dbg(&adap->dev, "could not get ACK\n");
+
+	if (unlikely(rxdata & UNIPHIER_I2C_DREC_LRB))
 		return -ENXIO;
-	}
 
 	return 0;
 }
@@ -115,7 +109,6 @@ static int uniphier_i2c_tx(struct i2c_adapter *adap, u16 addr, u16 len,
 {
 	int ret;
 
-	dev_dbg(&adap->dev, "start condition\n");
 	ret = uniphier_i2c_send_byte(adap, addr << 1 |
 				     UNIPHIER_I2C_DTRM_STA |
 				     UNIPHIER_I2C_DTRM_NACK);
@@ -137,7 +130,6 @@ static int uniphier_i2c_rx(struct i2c_adapter *adap, u16 addr, u16 len,
 {
 	int ret;
 
-	dev_dbg(&adap->dev, "start condition\n");
 	ret = uniphier_i2c_send_byte(adap, addr << 1 |
 				     UNIPHIER_I2C_DTRM_STA |
 				     UNIPHIER_I2C_DTRM_NACK |
@@ -161,7 +153,6 @@ static int uniphier_i2c_rx(struct i2c_adapter *adap, u16 addr, u16 len,
 
 static int uniphier_i2c_stop(struct i2c_adapter *adap)
 {
-	dev_dbg(&adap->dev, "stop condition\n");
 	return uniphier_i2c_send_byte(adap, UNIPHIER_I2C_DTRM_STO |
 				      UNIPHIER_I2C_DTRM_NACK);
 }
@@ -173,9 +164,6 @@ static int uniphier_i2c_master_xfer_one(struct i2c_adapter *adap,
 	bool recovery = false;
 	int ret;
 
-	dev_dbg(&adap->dev, "%s: addr=0x%02x, len=%d, stop=%d\n",
-		is_read ? "receive" : "transmit", msg->addr, msg->len, stop);
-
 	if (is_read)
 		ret = uniphier_i2c_rx(adap, msg->addr, msg->len, msg->buf);
 	else

commit 22ac74a6194798ce131c55ff0dfbb9697650e626
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Sep 5 12:45:32 2019 +0900

    i2c: uniphier(-f): use devm_platform_ioremap_resource()
    
    Replace the chain of platform_get_resource() and devm_ioremap_resource()
    with devm_platform_ioremap_resource().
    
    This allows to remove the local variable for (struct resource *), and
    have one function call less.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier.c b/drivers/i2c/busses/i2c-uniphier.c
index 0173840c32af..a6d7a3709051 100644
--- a/drivers/i2c/busses/i2c-uniphier.c
+++ b/drivers/i2c/busses/i2c-uniphier.c
@@ -326,7 +326,6 @@ static int uniphier_i2c_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct uniphier_i2c_priv *priv;
-	struct resource *regs;
 	u32 bus_speed;
 	unsigned long clk_rate;
 	int irq, ret;
@@ -335,8 +334,7 @@ static int uniphier_i2c_probe(struct platform_device *pdev)
 	if (!priv)
 		return -ENOMEM;
 
-	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	priv->membase = devm_ioremap_resource(dev, regs);
+	priv->membase = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(priv->membase))
 		return PTR_ERR(priv->membase);
 

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/i2c/busses/i2c-uniphier.c b/drivers/i2c/busses/i2c-uniphier.c
index c488e558aef7..0173840c32af 100644
--- a/drivers/i2c/busses/i2c-uniphier.c
+++ b/drivers/i2c/busses/i2c-uniphier.c
@@ -1,15 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (C) 2015 Masahiro Yamada <yamada.masahiro@socionext.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include <linux/clk.h>

commit 8469636ab5d8c77645b953746c10fda6983a8830
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Dec 6 12:55:27 2018 +0900

    i2c: uniphier: fix violation of tLOW requirement for Fast-mode
    
    Currently, the clock duty is set as tLOW/tHIGH = 1/1. For Fast-mode,
    tLOW is set to 1.25 us while the I2C spec requires tLOW >= 1.3 us.
    
    tLOW/tHIGH = 5/4 would meet both Standard-mode and Fast-mode:
      Standard-mode: tLOW = 5.56 us, tHIGH = 4.44 us
      Fast-mode:     tLOW = 1.39 us, tHIGH = 1.11 us
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier.c b/drivers/i2c/busses/i2c-uniphier.c
index 454f914ae66d..c488e558aef7 100644
--- a/drivers/i2c/busses/i2c-uniphier.c
+++ b/drivers/i2c/busses/i2c-uniphier.c
@@ -320,7 +320,13 @@ static void uniphier_i2c_hw_init(struct uniphier_i2c_priv *priv)
 
 	uniphier_i2c_reset(priv, true);
 
-	writel((cyc / 2 << 16) | cyc, priv->membase + UNIPHIER_I2C_CLK);
+	/*
+	 * Bit30-16: clock cycles of tLOW.
+	 *  Standard-mode: tLOW = 4.7 us, tHIGH = 4.0 us
+	 *  Fast-mode:     tLOW = 1.3 us, tHIGH = 0.6 us
+	 * "tLow/tHIGH = 5/4" meets both.
+	 */
+	writel((cyc * 5 / 9 << 16) | cyc, priv->membase + UNIPHIER_I2C_CLK);
 
 	uniphier_i2c_reset(priv, false);
 }

commit 38f5d8d8cbb2ffa2b54315118185332329ec891c
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Aug 31 23:30:47 2018 +0900

    i2c: uniphier: issue STOP only for last message or I2C_M_STOP
    
    This driver currently emits a STOP if the next message is not
    I2C_MD_RD.  It should not do it because it disturbs the I2C_RDWR
    ioctl, where read/write transactions are combined without STOP
    between.
    
    Issue STOP only when the message is the last one _or_ flagged with
    I2C_M_STOP.
    
    Fixes: dd6fd4a32793 ("i2c: uniphier: add UniPhier FIFO-less I2C driver")
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier.c b/drivers/i2c/busses/i2c-uniphier.c
index bb181b088291..454f914ae66d 100644
--- a/drivers/i2c/busses/i2c-uniphier.c
+++ b/drivers/i2c/busses/i2c-uniphier.c
@@ -248,11 +248,8 @@ static int uniphier_i2c_master_xfer(struct i2c_adapter *adap,
 		return ret;
 
 	for (msg = msgs; msg < emsg; msg++) {
-		/* If next message is read, skip the stop condition */
-		bool stop = !(msg + 1 < emsg && msg[1].flags & I2C_M_RD);
-		/* but, force it if I2C_M_STOP is set */
-		if (msg->flags & I2C_M_STOP)
-			stop = true;
+		/* Emit STOP if it is the last message or I2C_M_STOP is set. */
+		bool stop = (msg + 1 == emsg) || (msg->flags & I2C_M_STOP);
 
 		ret = uniphier_i2c_master_xfer_one(adap, msg, stop);
 		if (ret)

commit 9f9d6a40108e93b8d913e82cd43eb081885fd9ca
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Jul 31 14:53:06 2017 +0900

    i2c: uniphier: add suspend / resume support
    
    When resuming, set up registers that have been lost in the sleep state.
    Also, add clock handling in the resume / suspend hooks.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier.c b/drivers/i2c/busses/i2c-uniphier.c
index 777c0fe93653..bb181b088291 100644
--- a/drivers/i2c/busses/i2c-uniphier.c
+++ b/drivers/i2c/busses/i2c-uniphier.c
@@ -53,6 +53,7 @@ struct uniphier_i2c_priv {
 	void __iomem *membase;
 	struct clk *clk;
 	unsigned int busy_cnt;
+	unsigned int clk_cycle;
 };
 
 static irqreturn_t uniphier_i2c_interrupt(int irq, void *dev_id)
@@ -316,13 +317,13 @@ static struct i2c_bus_recovery_info uniphier_i2c_bus_recovery_info = {
 	.unprepare_recovery = uniphier_i2c_unprepare_recovery,
 };
 
-static void uniphier_i2c_hw_init(struct uniphier_i2c_priv *priv,
-				 u32 bus_speed, unsigned long clk_rate)
+static void uniphier_i2c_hw_init(struct uniphier_i2c_priv *priv)
 {
+	unsigned int cyc = priv->clk_cycle;
+
 	uniphier_i2c_reset(priv, true);
 
-	writel((clk_rate / bus_speed / 2 << 16) | (clk_rate / bus_speed),
-	       priv->membase + UNIPHIER_I2C_CLK);
+	writel((cyc / 2 << 16) | cyc, priv->membase + UNIPHIER_I2C_CLK);
 
 	uniphier_i2c_reset(priv, false);
 }
@@ -376,6 +377,7 @@ static int uniphier_i2c_probe(struct platform_device *pdev)
 		goto disable_clk;
 	}
 
+	priv->clk_cycle = clk_rate / bus_speed;
 	init_completion(&priv->comp);
 	priv->adap.owner = THIS_MODULE;
 	priv->adap.algo = &uniphier_i2c_algo;
@@ -386,7 +388,7 @@ static int uniphier_i2c_probe(struct platform_device *pdev)
 	i2c_set_adapdata(&priv->adap, priv);
 	platform_set_drvdata(pdev, priv);
 
-	uniphier_i2c_hw_init(priv, bus_speed, clk_rate);
+	uniphier_i2c_hw_init(priv);
 
 	ret = devm_request_irq(dev, irq, uniphier_i2c_interrupt, 0, pdev->name,
 			       priv);
@@ -413,6 +415,33 @@ static int uniphier_i2c_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static int __maybe_unused uniphier_i2c_suspend(struct device *dev)
+{
+	struct uniphier_i2c_priv *priv = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+
+static int __maybe_unused uniphier_i2c_resume(struct device *dev)
+{
+	struct uniphier_i2c_priv *priv = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(priv->clk);
+	if (ret)
+		return ret;
+
+	uniphier_i2c_hw_init(priv);
+
+	return 0;
+}
+
+static const struct dev_pm_ops uniphier_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(uniphier_i2c_suspend, uniphier_i2c_resume)
+};
+
 static const struct of_device_id uniphier_i2c_match[] = {
 	{ .compatible = "socionext,uniphier-i2c" },
 	{ /* sentinel */ }
@@ -425,6 +454,7 @@ static struct platform_driver uniphier_i2c_drv = {
 	.driver = {
 		.name  = "uniphier-i2c",
 		.of_match_table = uniphier_i2c_match,
+		.pm = &uniphier_i2c_pm_ops,
 	},
 };
 module_platform_driver(uniphier_i2c_drv);

commit a837bad6f213669b967b56a4a6f81d8dfdf40428
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Nov 4 19:49:20 2016 +0900

    i2c: uniphier: rename jump label to follow coding style guideline
    
    Documentation/CodingStyle recommends to use label names which say
    what the goto does or why the goto exists.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier.c b/drivers/i2c/busses/i2c-uniphier.c
index 56e92af46ddc..777c0fe93653 100644
--- a/drivers/i2c/busses/i2c-uniphier.c
+++ b/drivers/i2c/busses/i2c-uniphier.c
@@ -373,7 +373,7 @@ static int uniphier_i2c_probe(struct platform_device *pdev)
 	if (!clk_rate) {
 		dev_err(dev, "input clock rate should not be zero\n");
 		ret = -EINVAL;
-		goto err;
+		goto disable_clk;
 	}
 
 	init_completion(&priv->comp);
@@ -392,11 +392,11 @@ static int uniphier_i2c_probe(struct platform_device *pdev)
 			       priv);
 	if (ret) {
 		dev_err(dev, "failed to request irq %d\n", irq);
-		goto err;
+		goto disable_clk;
 	}
 
 	ret = i2c_add_adapter(&priv->adap);
-err:
+disable_clk:
 	if (ret)
 		clk_disable_unprepare(priv->clk);
 

commit 4c91307ce9387519836e17482906ef0f698ea7d9
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Sep 1 20:46:28 2016 +0900

    i2c: uniphier: avoid WARN_ON() of clk_disable() in failure path
    
    If clk_prepare_enable() fails, clk_disable_unprepare() is called in
    the failure path, where the enable_count is still zero, so it hits
    WARN_ON(core->enable_count == 0) in the clk_core_disable().
    
    To fix this, make the clock setting more linear in the probe function
    so that it can exploit "goto err" in case of error.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier.c b/drivers/i2c/busses/i2c-uniphier.c
index d6e612a0e02a..56e92af46ddc 100644
--- a/drivers/i2c/busses/i2c-uniphier.c
+++ b/drivers/i2c/busses/i2c-uniphier.c
@@ -316,50 +316,15 @@ static struct i2c_bus_recovery_info uniphier_i2c_bus_recovery_info = {
 	.unprepare_recovery = uniphier_i2c_unprepare_recovery,
 };
 
-static int uniphier_i2c_clk_init(struct device *dev,
-				 struct uniphier_i2c_priv *priv)
+static void uniphier_i2c_hw_init(struct uniphier_i2c_priv *priv,
+				 u32 bus_speed, unsigned long clk_rate)
 {
-	struct device_node *np = dev->of_node;
-	unsigned long clk_rate;
-	u32 bus_speed;
-	int ret;
-
-	if (of_property_read_u32(np, "clock-frequency", &bus_speed))
-		bus_speed = UNIPHIER_I2C_DEFAULT_SPEED;
-
-	if (!bus_speed) {
-		dev_err(dev, "clock-frequency should not be zero\n");
-		return -EINVAL;
-	}
-
-	if (bus_speed > UNIPHIER_I2C_MAX_SPEED)
-		bus_speed = UNIPHIER_I2C_MAX_SPEED;
-
-	/* Get input clk rate through clk driver */
-	priv->clk = devm_clk_get(dev, NULL);
-	if (IS_ERR(priv->clk)) {
-		dev_err(dev, "failed to get clock\n");
-		return PTR_ERR(priv->clk);
-	}
-
-	ret = clk_prepare_enable(priv->clk);
-	if (ret)
-		return ret;
-
-	clk_rate = clk_get_rate(priv->clk);
-	if (!clk_rate) {
-		dev_err(dev, "input clock rate should not be zero\n");
-		return -EINVAL;
-	}
-
 	uniphier_i2c_reset(priv, true);
 
 	writel((clk_rate / bus_speed / 2 << 16) | (clk_rate / bus_speed),
 	       priv->membase + UNIPHIER_I2C_CLK);
 
 	uniphier_i2c_reset(priv, false);
-
-	return 0;
 }
 
 static int uniphier_i2c_probe(struct platform_device *pdev)
@@ -367,8 +332,9 @@ static int uniphier_i2c_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct uniphier_i2c_priv *priv;
 	struct resource *regs;
-	int irq;
-	int ret;
+	u32 bus_speed;
+	unsigned long clk_rate;
+	int irq, ret;
 
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
@@ -385,6 +351,31 @@ static int uniphier_i2c_probe(struct platform_device *pdev)
 		return irq;
 	}
 
+	if (of_property_read_u32(dev->of_node, "clock-frequency", &bus_speed))
+		bus_speed = UNIPHIER_I2C_DEFAULT_SPEED;
+
+	if (!bus_speed || bus_speed > UNIPHIER_I2C_MAX_SPEED) {
+		dev_err(dev, "invalid clock-frequency %d\n", bus_speed);
+		return -EINVAL;
+	}
+
+	priv->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev, "failed to get clock\n");
+		return PTR_ERR(priv->clk);
+	}
+
+	ret = clk_prepare_enable(priv->clk);
+	if (ret)
+		return ret;
+
+	clk_rate = clk_get_rate(priv->clk);
+	if (!clk_rate) {
+		dev_err(dev, "input clock rate should not be zero\n");
+		ret = -EINVAL;
+		goto err;
+	}
+
 	init_completion(&priv->comp);
 	priv->adap.owner = THIS_MODULE;
 	priv->adap.algo = &uniphier_i2c_algo;
@@ -395,9 +386,7 @@ static int uniphier_i2c_probe(struct platform_device *pdev)
 	i2c_set_adapdata(&priv->adap, priv);
 	platform_set_drvdata(pdev, priv);
 
-	ret = uniphier_i2c_clk_init(dev, priv);
-	if (ret)
-		goto err;
+	uniphier_i2c_hw_init(priv, bus_speed, clk_rate);
 
 	ret = devm_request_irq(dev, irq, uniphier_i2c_interrupt, 0, pdev->name,
 			       priv);

commit 56025e7bc2079cda92643b43bf26991d3d09717d
Author: Wolfram Sang <wsa-dev@sang-engineering.com>
Date:   Tue Aug 9 22:11:40 2016 +0200

    i2c: uniphier{-f}: don't print error when adding adapter fails
    
    The core will do this for us now.
    
    Signed-off-by: Wolfram Sang <wsa-dev@sang-engineering.com>
    Acked-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier.c b/drivers/i2c/busses/i2c-uniphier.c
index 475a5eb514e2..d6e612a0e02a 100644
--- a/drivers/i2c/busses/i2c-uniphier.c
+++ b/drivers/i2c/busses/i2c-uniphier.c
@@ -407,11 +407,6 @@ static int uniphier_i2c_probe(struct platform_device *pdev)
 	}
 
 	ret = i2c_add_adapter(&priv->adap);
-	if (ret) {
-		dev_err(dev, "failed to add I2C adapter\n");
-		goto err;
-	}
-
 err:
 	if (ret)
 		clk_disable_unprepare(priv->clk);

commit 8a350183010a5557287a10c2a13b1a4cbaa7b130
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Thu Apr 21 15:12:44 2016 +0900

    i2c: uniphier: add "\n" at the end of error log
    
    Just in case.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier.c b/drivers/i2c/busses/i2c-uniphier.c
index 89eaa8a7e1e0..475a5eb514e2 100644
--- a/drivers/i2c/busses/i2c-uniphier.c
+++ b/drivers/i2c/busses/i2c-uniphier.c
@@ -381,7 +381,7 @@ static int uniphier_i2c_probe(struct platform_device *pdev)
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
-		dev_err(dev, "failed to get IRQ number");
+		dev_err(dev, "failed to get IRQ number\n");
 		return irq;
 	}
 

commit bca71ba0343d28d953d74149d9161ab65a520dd6
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Jan 26 18:09:21 2016 +0900

    i2c: uniphier: fix typos in error messages
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier.c b/drivers/i2c/busses/i2c-uniphier.c
index 1f4f3f53819c..89eaa8a7e1e0 100644
--- a/drivers/i2c/busses/i2c-uniphier.c
+++ b/drivers/i2c/busses/i2c-uniphier.c
@@ -328,7 +328,7 @@ static int uniphier_i2c_clk_init(struct device *dev,
 		bus_speed = UNIPHIER_I2C_DEFAULT_SPEED;
 
 	if (!bus_speed) {
-		dev_err(dev, "clock-freqyency should not be zero\n");
+		dev_err(dev, "clock-frequency should not be zero\n");
 		return -EINVAL;
 	}
 

commit 2d5d23b96a4a660d0d04455150570c6257d4ce25
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Nov 30 18:53:34 2015 +0900

    i2c: uniphier: error out if bus speed is zero
    
    There is code to divide by "bus_speed" some lines below.
    To eliminate the possibility of division by zero, bail out if
    "clock-frequency" is specified as zero.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier.c b/drivers/i2c/busses/i2c-uniphier.c
index 2b2c20b3a57a..1f4f3f53819c 100644
--- a/drivers/i2c/busses/i2c-uniphier.c
+++ b/drivers/i2c/busses/i2c-uniphier.c
@@ -327,6 +327,11 @@ static int uniphier_i2c_clk_init(struct device *dev,
 	if (of_property_read_u32(np, "clock-frequency", &bus_speed))
 		bus_speed = UNIPHIER_I2C_DEFAULT_SPEED;
 
+	if (!bus_speed) {
+		dev_err(dev, "clock-freqyency should not be zero\n");
+		return -EINVAL;
+	}
+
 	if (bus_speed > UNIPHIER_I2C_MAX_SPEED)
 		bus_speed = UNIPHIER_I2C_MAX_SPEED;
 

commit 1ff49b34bfd1261277d2c97ec48efb067b87f5e5
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Nov 30 18:53:33 2015 +0900

    i2c: uniphier: error out if clock rate is zero
    
    This input clock is used to generate the sampling clock for I2C bus.
    If the clock rate is zero, there is something wrong with the clock
    driver.  Bail out with the appropriate error message in such a case.
    It would make it easier to find the root cause of failure.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier.c b/drivers/i2c/busses/i2c-uniphier.c
index e3c3861c3325..2b2c20b3a57a 100644
--- a/drivers/i2c/busses/i2c-uniphier.c
+++ b/drivers/i2c/busses/i2c-uniphier.c
@@ -342,6 +342,10 @@ static int uniphier_i2c_clk_init(struct device *dev,
 		return ret;
 
 	clk_rate = clk_get_rate(priv->clk);
+	if (!clk_rate) {
+		dev_err(dev, "input clock rate should not be zero\n");
+		return -EINVAL;
+	}
 
 	uniphier_i2c_reset(priv, true);
 
@@ -388,7 +392,7 @@ static int uniphier_i2c_probe(struct platform_device *pdev)
 
 	ret = uniphier_i2c_clk_init(dev, priv);
 	if (ret)
-		return ret;
+		goto err;
 
 	ret = devm_request_irq(dev, irq, uniphier_i2c_interrupt, 0, pdev->name,
 			       priv);

commit dd6fd4a3279310bac214867e31848f47e13caa6f
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Fri Oct 23 19:51:59 2015 +0900

    i2c: uniphier: add UniPhier FIFO-less I2C driver
    
    Add support for on-chip I2C controller used on old UniPhier SoCs
    such as PH1-LD4, PH1-sLD8, etc.  This adapter is so simple that
    it has no FIFO in it.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-uniphier.c b/drivers/i2c/busses/i2c-uniphier.c
new file mode 100644
index 000000000000..e3c3861c3325
--- /dev/null
+++ b/drivers/i2c/busses/i2c-uniphier.c
@@ -0,0 +1,441 @@
+/*
+ * Copyright (C) 2015 Masahiro Yamada <yamada.masahiro@socionext.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#define UNIPHIER_I2C_DTRM	0x00	/* TX register */
+#define     UNIPHIER_I2C_DTRM_IRQEN	BIT(11)	/* enable interrupt */
+#define     UNIPHIER_I2C_DTRM_STA	BIT(10)	/* start condition */
+#define     UNIPHIER_I2C_DTRM_STO	BIT(9)	/* stop condition */
+#define     UNIPHIER_I2C_DTRM_NACK	BIT(8)	/* do not return ACK */
+#define     UNIPHIER_I2C_DTRM_RD	BIT(0)	/* read transaction */
+#define UNIPHIER_I2C_DREC	0x04	/* RX register */
+#define     UNIPHIER_I2C_DREC_MST	BIT(14)	/* 1 = master, 0 = slave */
+#define     UNIPHIER_I2C_DREC_TX	BIT(13)	/* 1 = transmit, 0 = receive */
+#define     UNIPHIER_I2C_DREC_STS	BIT(12)	/* stop condition detected */
+#define     UNIPHIER_I2C_DREC_LRB	BIT(11)	/* no ACK */
+#define     UNIPHIER_I2C_DREC_LAB	BIT(9)	/* arbitration lost */
+#define     UNIPHIER_I2C_DREC_BBN	BIT(8)	/* bus not busy */
+#define UNIPHIER_I2C_MYAD	0x08	/* slave address */
+#define UNIPHIER_I2C_CLK	0x0c	/* clock frequency control */
+#define UNIPHIER_I2C_BRST	0x10	/* bus reset */
+#define     UNIPHIER_I2C_BRST_FOEN	BIT(1)	/* normal operation */
+#define     UNIPHIER_I2C_BRST_RSCL	BIT(0)	/* release SCL */
+#define UNIPHIER_I2C_HOLD	0x14	/* hold time control */
+#define UNIPHIER_I2C_BSTS	0x18	/* bus status monitor */
+#define     UNIPHIER_I2C_BSTS_SDA	BIT(1)	/* readback of SDA line */
+#define     UNIPHIER_I2C_BSTS_SCL	BIT(0)	/* readback of SCL line */
+#define UNIPHIER_I2C_NOISE	0x1c	/* noise filter control */
+#define UNIPHIER_I2C_SETUP	0x20	/* setup time control */
+
+#define UNIPHIER_I2C_DEFAULT_SPEED	100000
+#define UNIPHIER_I2C_MAX_SPEED		400000
+
+struct uniphier_i2c_priv {
+	struct completion comp;
+	struct i2c_adapter adap;
+	void __iomem *membase;
+	struct clk *clk;
+	unsigned int busy_cnt;
+};
+
+static irqreturn_t uniphier_i2c_interrupt(int irq, void *dev_id)
+{
+	struct uniphier_i2c_priv *priv = dev_id;
+
+	/*
+	 * This hardware uses edge triggered interrupt.  Do not touch the
+	 * hardware registers in this handler to make sure to catch the next
+	 * interrupt edge.  Just send a complete signal and return.
+	 */
+	complete(&priv->comp);
+
+	return IRQ_HANDLED;
+}
+
+static int uniphier_i2c_xfer_byte(struct i2c_adapter *adap, u32 txdata,
+				  u32 *rxdatap)
+{
+	struct uniphier_i2c_priv *priv = i2c_get_adapdata(adap);
+	unsigned long time_left;
+	u32 rxdata;
+
+	reinit_completion(&priv->comp);
+
+	txdata |= UNIPHIER_I2C_DTRM_IRQEN;
+	dev_dbg(&adap->dev, "write data: 0x%04x\n", txdata);
+	writel(txdata, priv->membase + UNIPHIER_I2C_DTRM);
+
+	time_left = wait_for_completion_timeout(&priv->comp, adap->timeout);
+	if (unlikely(!time_left)) {
+		dev_err(&adap->dev, "transaction timeout\n");
+		return -ETIMEDOUT;
+	}
+
+	rxdata = readl(priv->membase + UNIPHIER_I2C_DREC);
+	dev_dbg(&adap->dev, "read data: 0x%04x\n", rxdata);
+
+	if (rxdatap)
+		*rxdatap = rxdata;
+
+	return 0;
+}
+
+static int uniphier_i2c_send_byte(struct i2c_adapter *adap, u32 txdata)
+{
+	u32 rxdata;
+	int ret;
+
+	ret = uniphier_i2c_xfer_byte(adap, txdata, &rxdata);
+	if (ret)
+		return ret;
+
+	if (unlikely(rxdata & UNIPHIER_I2C_DREC_LAB)) {
+		dev_dbg(&adap->dev, "arbitration lost\n");
+		return -EAGAIN;
+	}
+	if (unlikely(rxdata & UNIPHIER_I2C_DREC_LRB)) {
+		dev_dbg(&adap->dev, "could not get ACK\n");
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+static int uniphier_i2c_tx(struct i2c_adapter *adap, u16 addr, u16 len,
+			   const u8 *buf)
+{
+	int ret;
+
+	dev_dbg(&adap->dev, "start condition\n");
+	ret = uniphier_i2c_send_byte(adap, addr << 1 |
+				     UNIPHIER_I2C_DTRM_STA |
+				     UNIPHIER_I2C_DTRM_NACK);
+	if (ret)
+		return ret;
+
+	while (len--) {
+		ret = uniphier_i2c_send_byte(adap,
+					     UNIPHIER_I2C_DTRM_NACK | *buf++);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int uniphier_i2c_rx(struct i2c_adapter *adap, u16 addr, u16 len,
+			   u8 *buf)
+{
+	int ret;
+
+	dev_dbg(&adap->dev, "start condition\n");
+	ret = uniphier_i2c_send_byte(adap, addr << 1 |
+				     UNIPHIER_I2C_DTRM_STA |
+				     UNIPHIER_I2C_DTRM_NACK |
+				     UNIPHIER_I2C_DTRM_RD);
+	if (ret)
+		return ret;
+
+	while (len--) {
+		u32 rxdata;
+
+		ret = uniphier_i2c_xfer_byte(adap,
+					     len ? 0 : UNIPHIER_I2C_DTRM_NACK,
+					     &rxdata);
+		if (ret)
+			return ret;
+		*buf++ = rxdata;
+	}
+
+	return 0;
+}
+
+static int uniphier_i2c_stop(struct i2c_adapter *adap)
+{
+	dev_dbg(&adap->dev, "stop condition\n");
+	return uniphier_i2c_send_byte(adap, UNIPHIER_I2C_DTRM_STO |
+				      UNIPHIER_I2C_DTRM_NACK);
+}
+
+static int uniphier_i2c_master_xfer_one(struct i2c_adapter *adap,
+					struct i2c_msg *msg, bool stop)
+{
+	bool is_read = msg->flags & I2C_M_RD;
+	bool recovery = false;
+	int ret;
+
+	dev_dbg(&adap->dev, "%s: addr=0x%02x, len=%d, stop=%d\n",
+		is_read ? "receive" : "transmit", msg->addr, msg->len, stop);
+
+	if (is_read)
+		ret = uniphier_i2c_rx(adap, msg->addr, msg->len, msg->buf);
+	else
+		ret = uniphier_i2c_tx(adap, msg->addr, msg->len, msg->buf);
+
+	if (ret == -EAGAIN) /* could not acquire bus. bail out without STOP */
+		return ret;
+
+	if (ret == -ETIMEDOUT) {
+		/* This error is fatal.  Needs recovery. */
+		stop = false;
+		recovery = true;
+	}
+
+	if (stop) {
+		int ret2 = uniphier_i2c_stop(adap);
+
+		if (ret2) {
+			/* Failed to issue STOP.  The bus needs recovery. */
+			recovery = true;
+			ret = ret ?: ret2;
+		}
+	}
+
+	if (recovery)
+		i2c_recover_bus(adap);
+
+	return ret;
+}
+
+static int uniphier_i2c_check_bus_busy(struct i2c_adapter *adap)
+{
+	struct uniphier_i2c_priv *priv = i2c_get_adapdata(adap);
+
+	if (!(readl(priv->membase + UNIPHIER_I2C_DREC) &
+						UNIPHIER_I2C_DREC_BBN)) {
+		if (priv->busy_cnt++ > 3) {
+			/*
+			 * If bus busy continues too long, it is probably
+			 * in a wrong state.  Try bus recovery.
+			 */
+			i2c_recover_bus(adap);
+			priv->busy_cnt = 0;
+		}
+
+		return -EAGAIN;
+	}
+
+	priv->busy_cnt = 0;
+	return 0;
+}
+
+static int uniphier_i2c_master_xfer(struct i2c_adapter *adap,
+				    struct i2c_msg *msgs, int num)
+{
+	struct i2c_msg *msg, *emsg = msgs + num;
+	int ret;
+
+	ret = uniphier_i2c_check_bus_busy(adap);
+	if (ret)
+		return ret;
+
+	for (msg = msgs; msg < emsg; msg++) {
+		/* If next message is read, skip the stop condition */
+		bool stop = !(msg + 1 < emsg && msg[1].flags & I2C_M_RD);
+		/* but, force it if I2C_M_STOP is set */
+		if (msg->flags & I2C_M_STOP)
+			stop = true;
+
+		ret = uniphier_i2c_master_xfer_one(adap, msg, stop);
+		if (ret)
+			return ret;
+	}
+
+	return num;
+}
+
+static u32 uniphier_i2c_functionality(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+static const struct i2c_algorithm uniphier_i2c_algo = {
+	.master_xfer = uniphier_i2c_master_xfer,
+	.functionality = uniphier_i2c_functionality,
+};
+
+static void uniphier_i2c_reset(struct uniphier_i2c_priv *priv, bool reset_on)
+{
+	u32 val = UNIPHIER_I2C_BRST_RSCL;
+
+	val |= reset_on ? 0 : UNIPHIER_I2C_BRST_FOEN;
+	writel(val, priv->membase + UNIPHIER_I2C_BRST);
+}
+
+static int uniphier_i2c_get_scl(struct i2c_adapter *adap)
+{
+	struct uniphier_i2c_priv *priv = i2c_get_adapdata(adap);
+
+	return !!(readl(priv->membase + UNIPHIER_I2C_BSTS) &
+							UNIPHIER_I2C_BSTS_SCL);
+}
+
+static void uniphier_i2c_set_scl(struct i2c_adapter *adap, int val)
+{
+	struct uniphier_i2c_priv *priv = i2c_get_adapdata(adap);
+
+	writel(val ? UNIPHIER_I2C_BRST_RSCL : 0,
+	       priv->membase + UNIPHIER_I2C_BRST);
+}
+
+static int uniphier_i2c_get_sda(struct i2c_adapter *adap)
+{
+	struct uniphier_i2c_priv *priv = i2c_get_adapdata(adap);
+
+	return !!(readl(priv->membase + UNIPHIER_I2C_BSTS) &
+							UNIPHIER_I2C_BSTS_SDA);
+}
+
+static void uniphier_i2c_unprepare_recovery(struct i2c_adapter *adap)
+{
+	uniphier_i2c_reset(i2c_get_adapdata(adap), false);
+}
+
+static struct i2c_bus_recovery_info uniphier_i2c_bus_recovery_info = {
+	.recover_bus = i2c_generic_scl_recovery,
+	.get_scl = uniphier_i2c_get_scl,
+	.set_scl = uniphier_i2c_set_scl,
+	.get_sda = uniphier_i2c_get_sda,
+	.unprepare_recovery = uniphier_i2c_unprepare_recovery,
+};
+
+static int uniphier_i2c_clk_init(struct device *dev,
+				 struct uniphier_i2c_priv *priv)
+{
+	struct device_node *np = dev->of_node;
+	unsigned long clk_rate;
+	u32 bus_speed;
+	int ret;
+
+	if (of_property_read_u32(np, "clock-frequency", &bus_speed))
+		bus_speed = UNIPHIER_I2C_DEFAULT_SPEED;
+
+	if (bus_speed > UNIPHIER_I2C_MAX_SPEED)
+		bus_speed = UNIPHIER_I2C_MAX_SPEED;
+
+	/* Get input clk rate through clk driver */
+	priv->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev, "failed to get clock\n");
+		return PTR_ERR(priv->clk);
+	}
+
+	ret = clk_prepare_enable(priv->clk);
+	if (ret)
+		return ret;
+
+	clk_rate = clk_get_rate(priv->clk);
+
+	uniphier_i2c_reset(priv, true);
+
+	writel((clk_rate / bus_speed / 2 << 16) | (clk_rate / bus_speed),
+	       priv->membase + UNIPHIER_I2C_CLK);
+
+	uniphier_i2c_reset(priv, false);
+
+	return 0;
+}
+
+static int uniphier_i2c_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct uniphier_i2c_priv *priv;
+	struct resource *regs;
+	int irq;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->membase = devm_ioremap_resource(dev, regs);
+	if (IS_ERR(priv->membase))
+		return PTR_ERR(priv->membase);
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(dev, "failed to get IRQ number");
+		return irq;
+	}
+
+	init_completion(&priv->comp);
+	priv->adap.owner = THIS_MODULE;
+	priv->adap.algo = &uniphier_i2c_algo;
+	priv->adap.dev.parent = dev;
+	priv->adap.dev.of_node = dev->of_node;
+	strlcpy(priv->adap.name, "UniPhier I2C", sizeof(priv->adap.name));
+	priv->adap.bus_recovery_info = &uniphier_i2c_bus_recovery_info;
+	i2c_set_adapdata(&priv->adap, priv);
+	platform_set_drvdata(pdev, priv);
+
+	ret = uniphier_i2c_clk_init(dev, priv);
+	if (ret)
+		return ret;
+
+	ret = devm_request_irq(dev, irq, uniphier_i2c_interrupt, 0, pdev->name,
+			       priv);
+	if (ret) {
+		dev_err(dev, "failed to request irq %d\n", irq);
+		goto err;
+	}
+
+	ret = i2c_add_adapter(&priv->adap);
+	if (ret) {
+		dev_err(dev, "failed to add I2C adapter\n");
+		goto err;
+	}
+
+err:
+	if (ret)
+		clk_disable_unprepare(priv->clk);
+
+	return ret;
+}
+
+static int uniphier_i2c_remove(struct platform_device *pdev)
+{
+	struct uniphier_i2c_priv *priv = platform_get_drvdata(pdev);
+
+	i2c_del_adapter(&priv->adap);
+	clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+
+static const struct of_device_id uniphier_i2c_match[] = {
+	{ .compatible = "socionext,uniphier-i2c" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, uniphier_i2c_match);
+
+static struct platform_driver uniphier_i2c_drv = {
+	.probe  = uniphier_i2c_probe,
+	.remove = uniphier_i2c_remove,
+	.driver = {
+		.name  = "uniphier-i2c",
+		.of_match_table = uniphier_i2c_match,
+	},
+};
+module_platform_driver(uniphier_i2c_drv);
+
+MODULE_AUTHOR("Masahiro Yamada <yamada.masahiro@socionext.com>");
+MODULE_DESCRIPTION("UniPhier I2C bus driver");
+MODULE_LICENSE("GPL");
