commit e0442d76213981ab48e8ea0874bb6c47e3af5a36
Author: Dejin Zheng <zhengdejin5@gmail.com>
Date:   Thu Apr 9 21:52:24 2020 +0800

    i2c: busses: convert to devm_platform_ioremap_resource
    
    use devm_platform_ioremap_resource() to simplify code, it
    contains platform_get_resource and devm_ioremap_resource.
    
    Reviewed-by: Barry Song <baohua@kernel.org>
    Acked-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Acked-by: Robert Richter <rrichter@marvell.com>
    Acked-by: Thor Thayer <thor.thayer@linux.intel.com>
    Acked-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
    Reviewed-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Dejin Zheng <zhengdejin5@gmail.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index ba6b60caa45e..64d739baf480 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -860,7 +860,6 @@ static int stu300_probe(struct platform_device *pdev)
 {
 	struct stu300_dev *dev;
 	struct i2c_adapter *adap;
-	struct resource *res;
 	int bus_nr;
 	int ret = 0;
 
@@ -876,8 +875,7 @@ static int stu300_probe(struct platform_device *pdev)
 	}
 
 	dev->pdev = pdev;
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	dev->virtbase = devm_ioremap_resource(&pdev->dev, res);
+	dev->virtbase = devm_platform_ioremap_resource(pdev, 0);
 	dev_dbg(&pdev->dev, "initialize bus device I2C%d on virtual "
 		"base %p\n", bus_nr, dev->virtbase);
 	if (IS_ERR(dev->virtbase))

commit 90224e6468e15d5eb22a10ae1849cf8ca2e7360a
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Mar 24 14:32:16 2020 +0200

    i2c: drivers: Use generic definitions for bus frequencies
    
    Since we have generic definitions for bus frequencies, let's use them.
    
    Reviewed-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Acked-by: Robert Richter <rrichter@marvell.com>
    Reviewed-by: Thor Thayer <thor.thayer@linux.intel.com>
    Acked-by: Elie Morisse <syniurge@gmail.com>
    Acked-by: Nehal Shah <nehal-bakulchandra.shah@amd.com>
    Reviewed-by: Brendan Higgins <brendanhiggins@google.com>
    Acked-by: Scott Branden <scott.branden@broadcom.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Baruch Siach <baruch@tkos.co.il>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Oleksij Rempel <o.rempel@pengutronix.de>
    Acked-by: Vladimir Zapolskiy <vz@mleia.com>
    Acked-by: Gregory CLEMENT <gregory.clement@bootlin.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
    Reviewed-by: Chris Brandt <chris.brandt@renesas.com>
    Reviewed-by: Baolin Wang <baolin.wang7@gmail.com>
    Reviewed-by: Pierre-Yves MORDRET <pierre-yves.mordret@st.com>
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    Acked-by: Ard Biesheuvel <ardb@kernel.org>
    Reviewed-by: Dmitry Osipenko <digetx@gmail.com>
    Acked-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 42e0a53e7fa4..ba6b60caa45e 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -132,7 +132,7 @@ enum stu300_error {
 #define NUM_ADDR_RESEND_ATTEMPTS 12
 
 /* I2C clock speed, in Hz 0-400kHz*/
-static unsigned int scl_frequency = 100000;
+static unsigned int scl_frequency = I2C_MAX_STANDARD_MODE_FREQ;
 module_param(scl_frequency, uint,  0644);
 
 /**
@@ -497,7 +497,7 @@ static int stu300_set_clk(struct stu300_dev *dev, unsigned long clkrate)
 	dev_dbg(&dev->pdev->dev, "Clock rate %lu Hz, I2C bus speed %d Hz "
 		"virtbase %p\n", clkrate, dev->speed, dev->virtbase);
 
-	if (dev->speed > 100000)
+	if (dev->speed > I2C_MAX_STANDARD_MODE_FREQ)
 		/* Fast Mode I2C */
 		val = ((clkrate/dev->speed) - 9)/3 + 1;
 	else
@@ -518,7 +518,7 @@ static int stu300_set_clk(struct stu300_dev *dev, unsigned long clkrate)
 		return -EINVAL;
 	}
 
-	if (dev->speed > 100000) {
+	if (dev->speed > I2C_MAX_STANDARD_MODE_FREQ) {
 		/* CC6..CC0 */
 		stu300_wr8((val & I2C_CCR_CC_MASK) | I2C_CCR_FMSM,
 			   dev->virtbase + I2C_CCR);

commit 49945ef0f90b5becef67db68338e8ce34ef70975
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Tue Jan 14 10:06:05 2020 +0100

    i2c: stu300: Use proper printk format for iomem pointer
    
    iomem pointers should be printed with pointer format to hide the
    actual value and fix warnings when compiling on 64-bit platform (e.g. with
    COMPILE_TEST):
    
        drivers/i2c/busses/i2c-stu300.c: In function ‘stu300_wait_while_busy’:
        drivers/i2c/busses/i2c-stu300.c:446:76: warning:
            cast from pointer to integer of different size [-Wpointer-to-int-cast]
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 8c3e2d409d63..42e0a53e7fa4 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -444,7 +444,7 @@ static int stu300_wait_while_busy(struct stu300_dev *dev)
 		       "Attempt: %d\n", i+1);
 
 		dev_err(&dev->pdev->dev, "base address = "
-			"0x%08x, reinit hardware\n", (u32) dev->virtbase);
+			"0x%p, reinit hardware\n", dev->virtbase);
 
 		(void) stu300_init_hw(dev);
 	}

commit af873fcecef567abf8a3468b06dd4e4aab46da6d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:21 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 194
    
    Based on 1 normalized pattern(s):
    
      license terms gnu general public license gpl version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 161 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170027.447718015@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 743c161b22c5..8c3e2d409d63 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -1,6 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2007-2012 ST-Ericsson AB
- * License terms: GNU General Public License (GPL) version 2
  * ST DDC I2C master mode driver, used in e.g. U300 series platforms.
  * Author: Linus Walleij <linus.walleij@stericsson.com>
  * Author: Jonas Aaberg <jonas.aberg@stericsson.com>

commit 252fa60e7054d22c039757d3ef72191d4eb58577
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Wed Apr 3 14:40:17 2019 +0200

    i2c: stu300: use xfer_atomic callback to bail out early
    
    Use the new callback to reject atomic transfers.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 5503fa171df0..743c161b22c5 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -328,12 +328,6 @@ static int stu300_start_and_await_event(struct stu300_dev *dev,
 {
 	int ret;
 
-	if (unlikely(irqs_disabled())) {
-		/* TODO: implement polling for this case if need be. */
-		WARN(1, "irqs are disabled, cannot poll for event\n");
-		return -EIO;
-	}
-
 	/* Lock command issue, fill in an event we wait for */
 	spin_lock_irq(&dev->cmd_issue_lock);
 	init_completion(&dev->cmd_complete);
@@ -380,13 +374,6 @@ static int stu300_await_event(struct stu300_dev *dev,
 {
 	int ret;
 
-	if (unlikely(irqs_disabled())) {
-		/* TODO: implement polling for this case if need be. */
-		dev_err(&dev->pdev->dev, "irqs are disabled on this "
-			"system!\n");
-		return -EIO;
-	}
-
 	/* Is it already here? */
 	spin_lock_irq(&dev->cmd_issue_lock);
 	dev->cmd_err = STU300_ERROR_NONE;
@@ -846,6 +833,13 @@ static int stu300_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 	return num;
 }
 
+static int stu300_xfer_todo(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
+{
+	/* TODO: implement polling for this case if need be. */
+	WARN(1, "%s: atomic transfers not implemented\n", dev_name(&adap->dev));
+	return -EOPNOTSUPP;
+}
+
 static u32 stu300_func(struct i2c_adapter *adap)
 {
 	/* This is the simplest thing you can think of... */
@@ -853,8 +847,9 @@ static u32 stu300_func(struct i2c_adapter *adap)
 }
 
 static const struct i2c_algorithm stu300_algo = {
-	.master_xfer	= stu300_xfer,
-	.functionality	= stu300_func,
+	.master_xfer = stu300_xfer,
+	.master_xfer_atomic = stu300_xfer_todo,
+	.functionality = stu300_func,
 };
 
 static const struct i2c_adapter_quirks stu300_quirks = {

commit 5314355a916aea235968d4c51710a65b7c9811ef
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Mon Jul 23 22:26:11 2018 +0200

    i2c: stu300: use core to detect 'no zero length' quirk
    
    And don't reimplement in the driver.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index fce52bdab2b7..5503fa171df0 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -673,12 +673,6 @@ static int stu300_xfer_msg(struct i2c_adapter *adap,
 			msg->addr, msg->len, msg->flags, stop);
 	}
 
-	/* Zero-length messages are not supported by this hardware */
-	if (msg->len == 0) {
-		ret = -EINVAL;
-		goto exit_disable;
-	}
-
 	/*
 	 * For some reason, sending the address sometimes fails when running
 	 * on  the 13 MHz clock. No interrupt arrives. This is a work around,
@@ -863,6 +857,10 @@ static const struct i2c_algorithm stu300_algo = {
 	.functionality	= stu300_func,
 };
 
+static const struct i2c_adapter_quirks stu300_quirks = {
+	.flags = I2C_AQ_NO_ZERO_LEN,
+};
+
 static int stu300_probe(struct platform_device *pdev)
 {
 	struct stu300_dev *dev;
@@ -920,6 +918,8 @@ static int stu300_probe(struct platform_device *pdev)
 	adap->algo = &stu300_algo;
 	adap->dev.parent = &pdev->dev;
 	adap->dev.of_node = pdev->dev.of_node;
+	adap->quirks = &stu300_quirks;
+
 	i2c_set_adapdata(adap, dev);
 
 	/* i2c device drivers may be active on return from add_adapter() */

commit dbd39cf4249316c4089b8987f20850763ebbf43e
Author: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
Date:   Thu May 31 09:24:02 2018 -0300

    i2c: stu300: use non-archaic spelling of failes
    
    Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo@canonical.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index e866c481bfc3..fce52bdab2b7 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -127,7 +127,7 @@ enum stu300_error {
 
 /*
  * The number of address send athemps tried before giving up.
- * If the first one failes it seems like 5 to 8 attempts are required.
+ * If the first one fails it seems like 5 to 8 attempts are required.
  */
 #define NUM_ADDR_RESEND_ATTEMPTS 12
 

commit 30a6475744cf11f31a296cb85b43bab40ebbea92
Author: Peter Rosin <peda@axentia.se>
Date:   Wed May 16 09:16:47 2018 +0200

    i2c: busses: make use of i2c_8bit_addr_from_msg
    
    Because it looks neater.
    
    For diolan, this allows factoring out some code that is now common
    between if and else.
    
    For eg20t, pch_i2c_writebytes is always called with a write in
    msgs->flags, and pch_i2c_readbytes with a read.
    
    For imx, i2c_imx_dma_write and i2c_imx_write are always called with a
    write in msgs->flags, and i2c_imx_read with a read.
    
    For qup, qup_i2c_write_tx_fifo_v1 is always called with a write in
    qup->msg->flags.
    
    For stu300, also restructure debug output for resends, since that
    code as a result is only handling debug output.
    
    Reviewed-by: Guenter Roeck <linux@roeck-us.net> [diolan]
    Acked-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de> [efm32 and imx]
    Acked-by: Linus Walleij <linus.walleij@linaro.org> [stu300]
    Signed-off-by: Peter Rosin <peda@axentia.se>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index dc63236b45b2..e866c481bfc3 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -602,20 +602,24 @@ static int stu300_send_address(struct stu300_dev *dev,
 	u32 val;
 	int ret;
 
-	if (msg->flags & I2C_M_TEN)
+	if (msg->flags & I2C_M_TEN) {
 		/* This is probably how 10 bit addresses look */
 		val = (0xf0 | (((u32) msg->addr & 0x300) >> 7)) &
 			I2C_DR_D_MASK;
-	else
-		val = ((msg->addr << 1) & I2C_DR_D_MASK);
+		if (msg->flags & I2C_M_RD)
+			/* This is the direction bit */
+			val |= 0x01;
+	} else {
+		val = i2c_8bit_addr_from_msg(msg);
+	}
 
-	if (msg->flags & I2C_M_RD) {
-		/* This is the direction bit */
-		val |= 0x01;
-		if (resend)
+	if (resend) {
+		if (msg->flags & I2C_M_RD)
 			dev_dbg(&dev->pdev->dev, "read resend\n");
-	} else if (resend)
-		dev_dbg(&dev->pdev->dev, "write resend\n");
+		else
+			dev_dbg(&dev->pdev->dev, "write resend\n");
+	}
+
 	stu300_wr8(val, dev->virtbase + I2C_DR);
 
 	/* For 10bit addressing, await 10bit request (EVENT 9) */

commit ea734404f3daf1f6b5103171d848c9d4641fd96b
Author: Wolfram Sang <wsa-dev@sang-engineering.com>
Date:   Tue Aug 9 13:36:17 2016 +0200

    i2c: don't print error when adding adapter fails
    
    The core will do this for us now.
    
    Signed-off-by: Wolfram Sang <wsa-dev@sang-engineering.com>
    Reviewed-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Acked-by: Peter Korsgaard <peter@korsgaard.com>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Ray Jui <ray.jui@broadcom.com>
    Acked-by: Vladimir Zapolskiy <vz@mleia.com>
    Acked-by: Ludovic Desroches <ludovic.desroches@atmel.com>
    Acked-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Acked-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 460c134832ac..dc63236b45b2 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -920,11 +920,8 @@ static int stu300_probe(struct platform_device *pdev)
 
 	/* i2c device drivers may be active on return from add_adapter() */
 	ret = i2c_add_numbered_adapter(adap);
-	if (ret) {
-		dev_err(&pdev->dev, "failure adding ST Micro DDC "
-		       "I2C adapter\n");
+	if (ret)
 		return ret;
-	}
 
 	platform_set_drvdata(pdev, dev);
 	dev_info(&pdev->dev, "ST DDC I2C @ %p, irq %d\n",

commit 8c5ec4c7ec0b58658d0fab813b9aca420b85ebfa
Author: Luis de Bethencourt <luis@debethencourt.com>
Date:   Tue Oct 20 15:16:30 2015 +0100

    i2c: stu300: Fix module autoload for OF platform driver
    
    This platform driver has a OF device ID table but the OF module
    alias information is not created so module autoloading won't work.
    
    Signed-off-by: Luis de Bethencourt <luisbg@osg.samsung.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 4885da9e9298..460c134832ac 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -977,6 +977,7 @@ static const struct of_device_id stu300_dt_match[] = {
 	{ .compatible = "st,ddci2c" },
 	{},
 };
+MODULE_DEVICE_TABLE(of, stu300_dt_match);
 
 static struct platform_driver stu300_i2c_driver = {
 	.driver = {

commit 1ecc4335eba1a264ed8ac5b180a2ffde8113f3db
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:37 2014 +0200

    i2c: busses: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 6a44f37798c8..4885da9e9298 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -981,7 +981,6 @@ static const struct of_device_id stu300_dt_match[] = {
 static struct platform_driver stu300_i2c_driver = {
 	.driver = {
 		.name	= NAME,
-		.owner	= THIS_MODULE,
 		.pm	= STU300_I2C_PM,
 		.of_match_table = stu300_dt_match,
 	},

commit ef417a430233eaec67bd222c392eeec0a2f59eb5
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Thu Jul 10 13:46:34 2014 +0200

    i2c: i2c-stu300: Drop class based scanning to improve bootup time
    
    This driver has been flagged to drop class based instantiation. The removal
    improves boot-up time and is unneeded for embedded controllers. Users have been
    warned to switch for some time now, so we can actually do the removal. Keep the
    DEPRECATED flag, so the core can inform users that the behaviour finally
    changed now. After another transition period, this flag can go, too.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index fefb1c19ec1d..6a44f37798c8 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -909,7 +909,7 @@ static int stu300_probe(struct platform_device *pdev)
 	adap = &dev->adapter;
 	adap->owner = THIS_MODULE;
 	/* DDC class but actually often used for more generic I2C */
-	adap->class = I2C_CLASS_DDC | I2C_CLASS_DEPRECATED;
+	adap->class = I2C_CLASS_DEPRECATED;
 	strlcpy(adap->name, "ST Microelectronics DDC I2C adapter",
 		sizeof(adap->name));
 	adap->nr = bus_nr;

commit 46797a2adbf0cdc3be17707dc64e872eeed86a8a
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue May 13 10:51:58 2014 +0900

    i2c: remove unnecessary OOM messages
    
    The site-specific OOM messages are unnecessary, because they
    duplicate the MM subsystem generic OOM message. For example,
    k.alloc and v.alloc failures use dump_stack().
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Reviewed-by: Jean Delvare <jdelvare@suse.de>
    Acked-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 29b1fb778943..fefb1c19ec1d 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -868,10 +868,8 @@ static int stu300_probe(struct platform_device *pdev)
 	int ret = 0;
 
 	dev = devm_kzalloc(&pdev->dev, sizeof(struct stu300_dev), GFP_KERNEL);
-	if (!dev) {
-		dev_err(&pdev->dev, "could not allocate device struct\n");
+	if (!dev)
 		return -ENOMEM;
-	}
 
 	bus_nr = pdev->id;
 	dev->clk = devm_clk_get(&pdev->dev, NULL);

commit bee749c6f02c859980e44bd669a1f2de144b237f
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Feb 10 11:04:09 2014 +0100

    i2c: i2c-stu300: deprecate class based instantiation
    
    Warn users that class based instantiation is going away soon in favour
    of more robust probing and faster bootup times.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 5b80ef310841..29b1fb778943 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -911,7 +911,7 @@ static int stu300_probe(struct platform_device *pdev)
 	adap = &dev->adapter;
 	adap->owner = THIS_MODULE;
 	/* DDC class but actually often used for more generic I2C */
-	adap->class = I2C_CLASS_DDC;
+	adap->class = I2C_CLASS_DDC | I2C_CLASS_DEPRECATED;
 	strlcpy(adap->name, "ST Microelectronics DDC I2C adapter",
 		sizeof(adap->name));
 	adap->nr = bus_nr;

commit 8faaaead62c3c7394fa6302303ce70e484b509ba
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Tue Jan 7 21:58:06 2014 +0900

    treewide: fix comments and printk msgs
    
    This patch fixed several typo in printk from various
    part of kernel source.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 04a17b9b38bb..5b80ef310841 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -801,7 +801,7 @@ static int stu300_xfer_msg(struct i2c_adapter *adap,
 	/* Check that the bus is free, or wait until some timeout occurs */
 	ret = stu300_wait_while_busy(dev);
 	if (ret != 0) {
-		dev_err(&dev->pdev->dev, "timout waiting for transfer "
+		dev_err(&dev->pdev->dev, "timeout waiting for transfer "
 		       "to commence.\n");
 		goto exit_disable;
 	}

commit 6d2cfb109725b748f47a242f87be9c31bf7e42c0
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Tue Oct 8 22:35:36 2013 +0200

    i2c: i2c-stu300: replace platform_driver_probe to support deferred probing
    
    Subsystems like pinctrl and gpio rightfully make use of deferred probing at
    core level. Now, deferred drivers won't be retried if they don't have a .probe
    function specified in the driver struct. Fix this driver to have that, so the
    devices it supports won't get lost in a deferred probe.
    
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index f8f6f2e552db..04a17b9b38bb 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -859,8 +859,7 @@ static const struct i2c_algorithm stu300_algo = {
 	.functionality	= stu300_func,
 };
 
-static int __init
-stu300_probe(struct platform_device *pdev)
+static int stu300_probe(struct platform_device *pdev)
 {
 	struct stu300_dev *dev;
 	struct i2c_adapter *adap;
@@ -966,8 +965,7 @@ static SIMPLE_DEV_PM_OPS(stu300_pm, stu300_suspend, stu300_resume);
 #define STU300_I2C_PM	NULL
 #endif
 
-static int __exit
-stu300_remove(struct platform_device *pdev)
+static int stu300_remove(struct platform_device *pdev)
 {
 	struct stu300_dev *dev = platform_get_drvdata(pdev);
 
@@ -989,13 +987,14 @@ static struct platform_driver stu300_i2c_driver = {
 		.pm	= STU300_I2C_PM,
 		.of_match_table = stu300_dt_match,
 	},
-	.remove		= __exit_p(stu300_remove),
+	.probe = stu300_probe,
+	.remove = stu300_remove,
 
 };
 
 static int __init stu300_init(void)
 {
-	return platform_driver_probe(&stu300_i2c_driver, stu300_probe);
+	return platform_driver_register(&stu300_i2c_driver);
 }
 
 static void __exit stu300_exit(void)

commit 687b81d083c082bc1e853032e3a2a54f8c251d27
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Thu Jul 11 12:56:15 2013 +0100

    i2c: move OF helpers into the core
    
    I2C of helpers used to live in of_i2c.c but experience (from SPI) shows
    that it is much cleaner to have this in the core. This also removes a
    circular dependency between the helpers and the core, and so we can
    finally register child nodes in the core instead of doing this manually
    in each driver. So, fix the drivers and documentation, too.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 19a40afaf172..f8f6f2e552db 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -17,7 +17,6 @@
 #include <linux/clk.h>
 #include <linux/io.h>
 #include <linux/slab.h>
-#include <linux/of_i2c.h>
 
 /* the name of this kernel module */
 #define NAME "stu300"
@@ -933,7 +932,6 @@ stu300_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, dev);
 	dev_info(&pdev->dev, "ST DDC I2C @ %p, irq %d\n",
 		 dev->virtbase, dev->irq);
-	of_i2c_register_devices(adap);
 
 	return 0;
 }

commit 71f1260e713bc663ade4b200bfff7cfc97bf34a1
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Mon Jul 15 11:29:56 2013 +0900

    i2c: stu300: add CONFIG_PM_SLEEP to suspend/resume functions
    
    Add CONFIG_PM_SLEEP to suspend/resume functions to fix the following
    build warning when CONFIG_PM_SLEEP is not selected. This is because
    sleep PM callbacks defined by SIMPLE_DEV_PM_OPS are only used when
    the CONFIG_PM_SLEEP is enabled.
    
    drivers/i2c/busses/i2c-stu300.c:945:12: warning: 'stu300_suspend' defined but not used [-Wunused-function]
    drivers/i2c/busses/i2c-stu300.c:954:12: warning: 'stu300_resume' defined but not used [-Wunused-function]
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index ded21cfa77da..19a40afaf172 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -938,7 +938,7 @@ stu300_probe(struct platform_device *pdev)
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 static int stu300_suspend(struct device *device)
 {
 	struct stu300_dev *dev = dev_get_drvdata(device);

commit 2806914f5d027c225c7562a0f2dd7e20c3ba8beb
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Tue Jul 23 20:01:39 2013 +0200

    drivers/i2c/busses: don't check resource with devm_ioremap_resource
    
    devm_ioremap_resource does sanity checks on the given resource. No need to
    duplicate this in the driver.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index d1a6b204af00..ded21cfa77da 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -884,9 +884,6 @@ stu300_probe(struct platform_device *pdev)
 
 	dev->pdev = pdev;
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res)
-		return -ENOENT;
-
 	dev->virtbase = devm_ioremap_resource(&pdev->dev, res);
 	dev_dbg(&pdev->dev, "initialize bus device I2C%d on virtual "
 		"base %p\n", bus_nr, dev->virtbase);

commit 2165f836c8f7036491fae41e9bc327a3cdf2fea3
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu May 23 15:26:29 2013 +0200

    i2c: stu300: do not request a specific clock name
    
    We have used the default clock associated with the block
    for a long time, only heuristics in the clock system has
    made this work anyway. This needs to be done away with as
    we start probing this driver and its clocks exclusively
    from the device tree.
    
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 1beaa05a3d2c..d1a6b204af00 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -868,7 +868,6 @@ stu300_probe(struct platform_device *pdev)
 	struct resource *res;
 	int bus_nr;
 	int ret = 0;
-	char clk_name[] = "I2C0";
 
 	dev = devm_kzalloc(&pdev->dev, sizeof(struct stu300_dev), GFP_KERNEL);
 	if (!dev) {
@@ -877,8 +876,7 @@ stu300_probe(struct platform_device *pdev)
 	}
 
 	bus_nr = pdev->id;
-	clk_name[3] += (char)bus_nr;
-	dev->clk = devm_clk_get(&pdev->dev, clk_name);
+	dev->clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(dev->clk)) {
 		dev_err(&pdev->dev, "could not retrieve i2c bus clock\n");
 		return PTR_ERR(dev->clk);

commit 8c58d891576c726bb8217842e955827ba8bb405a
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Apr 11 14:59:47 2013 +0200

    i2c: stu300: device tree support
    
    This adds device tree support for the ST DDC I2C driver known
    as "stu300" in the kernel tree.
    
    Reviewed-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 0a6f941133f6..1beaa05a3d2c 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -17,6 +17,7 @@
 #include <linux/clk.h>
 #include <linux/io.h>
 #include <linux/slab.h>
+#include <linux/of_i2c.h>
 
 /* the name of this kernel module */
 #define NAME "stu300"
@@ -923,6 +924,7 @@ stu300_probe(struct platform_device *pdev)
 	adap->nr = bus_nr;
 	adap->algo = &stu300_algo;
 	adap->dev.parent = &pdev->dev;
+	adap->dev.of_node = pdev->dev.of_node;
 	i2c_set_adapdata(adap, dev);
 
 	/* i2c device drivers may be active on return from add_adapter() */
@@ -934,6 +936,10 @@ stu300_probe(struct platform_device *pdev)
 	}
 
 	platform_set_drvdata(pdev, dev);
+	dev_info(&pdev->dev, "ST DDC I2C @ %p, irq %d\n",
+		 dev->virtbase, dev->irq);
+	of_i2c_register_devices(adap);
+
 	return 0;
 }
 
@@ -978,11 +984,17 @@ stu300_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct of_device_id stu300_dt_match[] = {
+	{ .compatible = "st,ddci2c" },
+	{},
+};
+
 static struct platform_driver stu300_i2c_driver = {
 	.driver = {
 		.name	= NAME,
 		.owner	= THIS_MODULE,
 		.pm	= STU300_I2C_PM,
+		.of_match_table = stu300_dt_match,
 	},
 	.remove		= __exit_p(stu300_remove),
 

commit 52caa59ed335616c5254adff7911465a57ed9f14
Merge: 4c8c225abf97 55827f4aa644
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 26 09:41:53 2013 -0800

    Merge branch 'i2c/for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux
    
    Pull i2c updates from Wolfram Sang:
     "Highlights:
    
       - new drivers for Intel ismt & Broadcom bcm2835
       - a number of drivers got support for more variants and mostly got
         cleaned up on the way (sis630, i801, at91, tegra, designware)
       - i2c got rid of all *_set_drvdata(..., NULL) on remove/probe failure
       - removed the i2c_smbus_process_call from the core since there are no
         users
       - mxs can now switch between PIO and DMA depending on the message
         size and the bus speed can now be arbitrary
    
      In addition, there is the usual bunch of fixes, cleanups, devm_*
      conversions, etc"
    
    Fixed conflict (and buggy devm_* conversion) in i2c-s3c2410.c
    
    * 'i2c/for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux: (39 commits)
      i2c: Remove unneeded xxx_set_drvdata(..., NULL) calls
      i2c: pxa: remove incorrect __exit annotations
      i2c: ocores: Fix pointer to integer cast warning
      i2c: tegra: remove warning dump if timeout happen in transfer
      i2c: fix i2c-ismt.c printk format warning
      i2c: i801: Add Device IDs for Intel Wellsburg PCH
      i2c: add bcm2835 driver
      i2c: ismt: Add Seth and Myself as maintainers
      i2c: sis630: checkpatch cleanup
      i2c: sis630: display unsigned hex
      i2c: sis630: use hex to constants for SMBus commands
      i2c: sis630: fix behavior after collision
      i2c: sis630: clear sticky bits
      i2c: sis630: Add SIS964 support
      i2c: isch: Add module parameter for backbone clock rate if divider is unset
      i2c: at91: fix unsed variable warning when building with !CONFIG_OF
      i2c: Adding support for Intel iSMT SMBus 2.0 host controller
      i2c: sh_mobile: don't send a stop condition by default inside transfers
      i2c: sh_mobile: eliminate an open-coded "goto" loop
      i2c: sh_mobile: fix timeout error handling
      ...

commit 55827f4aa6442ddd1d6a4e1e32f2f457eb113c22
Author: Doug Anderson <dianders@chromium.org>
Date:   Fri Feb 15 13:18:35 2013 +0000

    i2c: Remove unneeded xxx_set_drvdata(..., NULL) calls
    
    There is simply no reason to be manually setting the private driver
    data to NULL in the remove/fail to probe cases.  This is just extra
    cruft code that can be removed.
    
    A few notes:
    * Nothing relies on drvdata being set to NULL.
    * The __device_release_driver() function eventually calls
      dev_set_drvdata(dev, NULL) anyway, so there's no need to do it
      twice.
    * I verified that there were no cases where xxx_get_drvdata() was
      being called in these drivers and checking for / relying on the NULL
      return value.
    
    This could be cleaned up kernel-wide but for now just take the baby
    step and remove from the i2c subsystem.
    
    Reported-by: Wolfram Sang <wsa@the-dreams.de>
    Reported-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Doug Anderson <dianders@chromium.org>
    Reviewed-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Peter Korsgaard <jacmet@sunsite.dk>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Marek Vasut <marex@denx.de>
    Signed-off-by: Wolfram Sang <wolfram@the-dreams.de>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 580a0c04cb42..f1912c8520fe 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -975,7 +975,6 @@ stu300_remove(struct platform_device *pdev)
 	i2c_del_adapter(&dev->adapter);
 	/* Turn off everything */
 	stu300_wr8(0x00, dev->virtbase + I2C_CR);
-	platform_set_drvdata(pdev, NULL);
 	return 0;
 }
 

commit 84dbf809fbae0591d319a7ea76e6032ff434824c
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Mon Jan 21 11:09:03 2013 +0100

    i2c: Convert to devm_ioremap_resource()
    
    Convert all uses of devm_request_and_ioremap() to the newly introduced
    devm_ioremap_resource() which provides more consistent error handling.
    
    devm_ioremap_resource() provides its own error messages so all explicit
    error messages can be removed from the failure code paths.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 580a0c04cb42..60195b590637 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -888,11 +888,11 @@ stu300_probe(struct platform_device *pdev)
 	if (!res)
 		return -ENOENT;
 
-	dev->virtbase = devm_request_and_ioremap(&pdev->dev, res);
+	dev->virtbase = devm_ioremap_resource(&pdev->dev, res);
 	dev_dbg(&pdev->dev, "initialize bus device I2C%d on virtual "
 		"base %p\n", bus_nr, dev->virtbase);
-	if (!dev->virtbase)
-		return -ENOMEM;
+	if (IS_ERR(dev->virtbase))
+		return PTR_ERR(dev->virtbase);
 
 	dev->irq = platform_get_irq(pdev, 0);
 	ret = devm_request_irq(&pdev->dev, dev->irq, stu300_irh, 0, NAME, dev);

commit 6f535b94261b16343cfbc4576a941bd7901b96e1
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Jul 16 13:30:12 2012 +0200

    i2c: stu300: use devm managed resources
    
    Allocate memory for device state using devm_kzalloc(), get the
    clock using devm_clk_get(), get the IRQ using devm_request_irq(),
    request and remap memory using devm_request_and_ioremap().
    All to simplify accounting and letting the kernel do the
    garbage-collection.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 80dd1c074a08..580a0c04cb42 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2007-2009 ST-Ericsson AB
+ * Copyright (C) 2007-2012 ST-Ericsson AB
  * License terms: GNU General Public License (GPL) version 2
  * ST DDC I2C master mode driver, used in e.g. U300 series platforms.
  * Author: Linus Walleij <linus.walleij@stericsson.com>
@@ -139,8 +139,6 @@ module_param(scl_frequency, uint,  0644);
  * struct stu300_dev - the stu300 driver state holder
  * @pdev: parent platform device
  * @adapter: corresponding I2C adapter
- * @phybase: location of I/O area in memory
- * @physize: size of I/O area in memory
  * @clk: hardware block clock
  * @irq: assigned interrupt line
  * @cmd_issue_lock: this locks the following cmd_ variables
@@ -155,8 +153,6 @@ module_param(scl_frequency, uint,  0644);
 struct stu300_dev {
 	struct platform_device	*pdev;
 	struct i2c_adapter	adapter;
-	resource_size_t		phybase;
-	resource_size_t		physize;
 	void __iomem		*virtbase;
 	struct clk		*clk;
 	int			irq;
@@ -873,64 +869,44 @@ stu300_probe(struct platform_device *pdev)
 	int ret = 0;
 	char clk_name[] = "I2C0";
 
-	dev = kzalloc(sizeof(struct stu300_dev), GFP_KERNEL);
+	dev = devm_kzalloc(&pdev->dev, sizeof(struct stu300_dev), GFP_KERNEL);
 	if (!dev) {
 		dev_err(&pdev->dev, "could not allocate device struct\n");
-		ret = -ENOMEM;
-		goto err_no_devmem;
+		return -ENOMEM;
 	}
 
 	bus_nr = pdev->id;
 	clk_name[3] += (char)bus_nr;
-	dev->clk = clk_get(&pdev->dev, clk_name);
+	dev->clk = devm_clk_get(&pdev->dev, clk_name);
 	if (IS_ERR(dev->clk)) {
-		ret = PTR_ERR(dev->clk);
 		dev_err(&pdev->dev, "could not retrieve i2c bus clock\n");
-		goto err_no_clk;
+		return PTR_ERR(dev->clk);
 	}
 
 	dev->pdev = pdev;
-	platform_set_drvdata(pdev, dev);
-
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		ret = -ENOENT;
-		goto err_no_resource;
-	}
+	if (!res)
+		return -ENOENT;
 
-	dev->phybase = res->start;
-	dev->physize = resource_size(res);
-
-	if (request_mem_region(dev->phybase, dev->physize,
-			       NAME " I/O Area") == NULL) {
-		ret = -EBUSY;
-		goto err_no_ioregion;
-	}
-
-	dev->virtbase = ioremap(dev->phybase, dev->physize);
+	dev->virtbase = devm_request_and_ioremap(&pdev->dev, res);
 	dev_dbg(&pdev->dev, "initialize bus device I2C%d on virtual "
 		"base %p\n", bus_nr, dev->virtbase);
-	if (!dev->virtbase) {
-		ret = -ENOMEM;
-		goto err_no_ioremap;
-	}
+	if (!dev->virtbase)
+		return -ENOMEM;
 
 	dev->irq = platform_get_irq(pdev, 0);
-	if (request_irq(dev->irq, stu300_irh, 0,
-			NAME, dev)) {
-		ret = -EIO;
-		goto err_no_irq;
-	}
+	ret = devm_request_irq(&pdev->dev, dev->irq, stu300_irh, 0, NAME, dev);
+	if (ret < 0)
+		return ret;
 
 	dev->speed = scl_frequency;
 
 	clk_prepare_enable(dev->clk);
 	ret = stu300_init_hw(dev);
 	clk_disable(dev->clk);
-
 	if (ret != 0) {
 		dev_err(&dev->pdev->dev, "error initializing hardware.\n");
-		goto err_init_hw;
+		return -EIO;
 	}
 
 	/* IRQ event handling initialization */
@@ -952,30 +928,13 @@ stu300_probe(struct platform_device *pdev)
 	/* i2c device drivers may be active on return from add_adapter() */
 	ret = i2c_add_numbered_adapter(adap);
 	if (ret) {
-		dev_err(&dev->pdev->dev, "failure adding ST Micro DDC "
+		dev_err(&pdev->dev, "failure adding ST Micro DDC "
 		       "I2C adapter\n");
-		goto err_add_adapter;
+		return ret;
 	}
-	return 0;
 
- err_add_adapter:
- err_init_hw:
-	clk_unprepare(dev->clk);
-	free_irq(dev->irq, dev);
- err_no_irq:
-	iounmap(dev->virtbase);
- err_no_ioremap:
-	release_mem_region(dev->phybase, dev->physize);
- err_no_ioregion:
-	platform_set_drvdata(pdev, NULL);
- err_no_resource:
-	clk_put(dev->clk);
- err_no_clk:
-	kfree(dev);
- err_no_devmem:
-	dev_err(&pdev->dev, "failed to add " NAME " adapter: %d\n",
-		pdev->id);
-	return ret;
+	platform_set_drvdata(pdev, dev);
+	return 0;
 }
 
 #ifdef CONFIG_PM
@@ -1016,13 +975,7 @@ stu300_remove(struct platform_device *pdev)
 	i2c_del_adapter(&dev->adapter);
 	/* Turn off everything */
 	stu300_wr8(0x00, dev->virtbase + I2C_CR);
-	free_irq(dev->irq, dev);
-	iounmap(dev->virtbase);
-	release_mem_region(dev->phybase, dev->physize);
-	clk_unprepare(dev->clk);
-	clk_put(dev->clk);
 	platform_set_drvdata(pdev, NULL);
-	kfree(dev);
 	return 0;
 }
 

commit 4aacc4b1b13cecef90d9ccbf9cf3fb4cc99807a0
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Jul 11 21:26:36 2012 +0200

    i2c-stu300: Use struct dev_pm_ops for power management
    
    Make the ST-Ericsson U300 I2C controller driver define its PM
    callbacks through a struct dev_pm_ops object rather than by using
    legacy PM hooks in struct platform_driver.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 79b785150c15..80dd1c074a08 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -979,31 +979,33 @@ stu300_probe(struct platform_device *pdev)
 }
 
 #ifdef CONFIG_PM
-static int stu300_suspend(struct platform_device *pdev, pm_message_t state)
+static int stu300_suspend(struct device *device)
 {
-	struct stu300_dev *dev = platform_get_drvdata(pdev);
+	struct stu300_dev *dev = dev_get_drvdata(device);
 
 	/* Turn off everything */
 	stu300_wr8(0x00, dev->virtbase + I2C_CR);
 	return 0;
 }
 
-static int stu300_resume(struct platform_device *pdev)
+static int stu300_resume(struct device *device)
 {
 	int ret = 0;
-	struct stu300_dev *dev = platform_get_drvdata(pdev);
+	struct stu300_dev *dev = dev_get_drvdata(device);
 
 	clk_enable(dev->clk);
 	ret = stu300_init_hw(dev);
 	clk_disable(dev->clk);
 
 	if (ret != 0)
-		dev_err(&pdev->dev, "error re-initializing hardware.\n");
+		dev_err(device, "error re-initializing hardware.\n");
 	return ret;
 }
+
+static SIMPLE_DEV_PM_OPS(stu300_pm, stu300_suspend, stu300_resume);
+#define STU300_I2C_PM	(&stu300_pm)
 #else
-#define stu300_suspend NULL
-#define stu300_resume NULL
+#define STU300_I2C_PM	NULL
 #endif
 
 static int __exit
@@ -1028,10 +1030,9 @@ static struct platform_driver stu300_i2c_driver = {
 	.driver = {
 		.name	= NAME,
 		.owner	= THIS_MODULE,
+		.pm	= STU300_I2C_PM,
 	},
 	.remove		= __exit_p(stu300_remove),
-	.suspend        = stu300_suspend,
-	.resume         = stu300_resume,
 
 };
 

commit a3f24c0dbd0b9a7624d077b3c1841dde267aaa6c
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Jun 12 19:33:30 2012 +0200

    i2c: stu300: use clk_prepare/unprepare
    
    Make sure we prepare/unprepare the clock for the ST U300
    I2C driver as is required by the clk API especially if you
    use common clock.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 4d44af181f37..79b785150c15 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -924,7 +924,7 @@ stu300_probe(struct platform_device *pdev)
 
 	dev->speed = scl_frequency;
 
-	clk_enable(dev->clk);
+	clk_prepare_enable(dev->clk);
 	ret = stu300_init_hw(dev);
 	clk_disable(dev->clk);
 
@@ -960,6 +960,7 @@ stu300_probe(struct platform_device *pdev)
 
  err_add_adapter:
  err_init_hw:
+	clk_unprepare(dev->clk);
 	free_irq(dev->irq, dev);
  err_no_irq:
 	iounmap(dev->virtbase);
@@ -1016,6 +1017,7 @@ stu300_remove(struct platform_device *pdev)
 	free_irq(dev->irq, dev);
 	iounmap(dev->virtbase);
 	release_mem_region(dev->phybase, dev->physize);
+	clk_unprepare(dev->clk);
 	clk_put(dev->clk);
 	platform_set_drvdata(pdev, NULL);
 	kfree(dev);

commit 4311051c358ad0e66b68934e7a33cf10ba533466
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Wed Sep 21 17:28:33 2011 +0800

    i2c: irq: Remove IRQF_DISABLED
    
    Since commit [c58543c8: genirq: Run irq handlers with interrupts disabled],
    We run all interrupt handlers with interrupts disabled
    and we even check and yell when an interrupt handler
    returns with interrupts enabled (see commit [b738a50a:
    genirq: Warn when handler enables interrupts]).
    
    So now this flag is a NOOP and can be removed.
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Barry Song <21cnbao@gmail.com>
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 99879617e686..4d44af181f37 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -916,7 +916,7 @@ stu300_probe(struct platform_device *pdev)
 	}
 
 	dev->irq = platform_get_irq(pdev, 0);
-	if (request_irq(dev->irq, stu300_irh, IRQF_DISABLED,
+	if (request_irq(dev->irq, stu300_irh, 0,
 			NAME, dev)) {
 		ret = -EIO;
 		goto err_no_irq;

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 266135ddf7fa..99879617e686 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -497,7 +497,7 @@ static int stu300_set_clk(struct stu300_dev *dev, unsigned long clkrate)
 	u32 val;
 	int i = 0;
 
-	/* Locate the apropriate clock setting */
+	/* Locate the appropriate clock setting */
 	while (i < ARRAY_SIZE(stu300_clktable) - 1 &&
 	       stu300_clktable[i].rate < clkrate)
 		i++;
@@ -644,7 +644,7 @@ static int stu300_send_address(struct stu300_dev *dev,
 	ret = stu300_await_event(dev, STU300_EVENT_6);
 
 	/*
-	 * Clear any pending EVENT 6 no matter what happend during
+	 * Clear any pending EVENT 6 no matter what happened during
 	 * await_event.
 	 */
 	val = stu300_r8(dev->virtbase + I2C_CR);

commit f10820e49585f281706ac07570a9e1652bdb5dd9
Author: Wolfram Sang <w.sang@pengutronix.de>
Date:   Mon Jan 31 15:09:23 2011 +0100

    i2c-stu300: make sure adapter-name is terminated
    
    Use strlcpy instead of strncpy.
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    Cc: Linus Walleij <linus.walleij@stericsson.com>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 495be451d326..266135ddf7fa 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -942,7 +942,7 @@ stu300_probe(struct platform_device *pdev)
 	adap->owner = THIS_MODULE;
 	/* DDC class but actually often used for more generic I2C */
 	adap->class = I2C_CLASS_DDC;
-	strncpy(adap->name, "ST Microelectronics DDC I2C adapter",
+	strlcpy(adap->name, "ST Microelectronics DDC I2C adapter",
 		sizeof(adap->name));
 	adap->nr = bus_nr;
 	adap->algo = &stu300_algo;

commit 42df64b1f83fa9b786067a0b5a3aca0fbb2d8db8
Author: Dan Carpenter <error27@gmail.com>
Date:   Wed Apr 7 12:22:58 2010 +0300

    i2c-stu300: off by one issue
    
    If we don't find the correct rate, we want to end the loop with "i"
    pointing to the last element in the array.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 1f5b38be73bc..495be451d326 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -498,7 +498,7 @@ static int stu300_set_clk(struct stu300_dev *dev, unsigned long clkrate)
 	int i = 0;
 
 	/* Locate the apropriate clock setting */
-	while (i < ARRAY_SIZE(stu300_clktable) &&
+	while (i < ARRAY_SIZE(stu300_clktable) - 1 &&
 	       stu300_clktable[i].rate < clkrate)
 		i++;
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index d2728a28a8db..1f5b38be73bc 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -16,6 +16,7 @@
 #include <linux/interrupt.h>
 #include <linux/clk.h>
 #include <linux/io.h>
+#include <linux/slab.h>
 
 /* the name of this kernel module */
 #define NAME "stu300"

commit c37faafa7d46622b749437f7d294201a63af4beb
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Thu Aug 13 22:14:23 2009 +0200

    i2c-stu300: I2C STU300 stability updates
    
    - blk clk is enabled when an irq arrives. The clk should be enabled,
      but just to make sure.
    - All error bits are handled no matter state machine state
    - All irq's will run complete() except for irq's that wasn't an event.
    - No more looking into status registers just in case an interrupt
      has happend and the irq handle wasn't executed.
    - irq_disable/enable are now separete functions.
    - clk settings calculation changed to round upwards instead of
      downwards.
    - Number of address send attempts before giving up is increased to 12
      from 10 since it most times take 8 tries before getting through.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index 182e711318ba..d2728a28a8db 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -117,7 +117,8 @@ enum stu300_error {
 	STU300_ERROR_NONE = 0,
 	STU300_ERROR_ACKNOWLEDGE_FAILURE,
 	STU300_ERROR_BUS_ERROR,
-	STU300_ERROR_ARBITRATION_LOST
+	STU300_ERROR_ARBITRATION_LOST,
+	STU300_ERROR_UNKNOWN
 };
 
 /* timeout waiting for the controller to respond */
@@ -127,7 +128,7 @@ enum stu300_error {
  * The number of address send athemps tried before giving up.
  * If the first one failes it seems like 5 to 8 attempts are required.
  */
-#define NUM_ADDR_RESEND_ATTEMPTS 10
+#define NUM_ADDR_RESEND_ATTEMPTS 12
 
 /* I2C clock speed, in Hz 0-400kHz*/
 static unsigned int scl_frequency = 100000;
@@ -149,6 +150,7 @@ module_param(scl_frequency, uint,  0644);
  * @msg_index: index of current message
  * @msg_len: length of current message
  */
+
 struct stu300_dev {
 	struct platform_device	*pdev;
 	struct i2c_adapter	adapter;
@@ -188,6 +190,27 @@ static inline u32 stu300_r8(void __iomem *address)
 	return readl(address) & 0x000000FFU;
 }
 
+static void stu300_irq_enable(struct stu300_dev *dev)
+{
+	u32 val;
+	val = stu300_r8(dev->virtbase + I2C_CR);
+	val |= I2C_CR_INTERRUPT_ENABLE;
+	/* Twice paranoia (possible HW glitch) */
+	stu300_wr8(val, dev->virtbase + I2C_CR);
+	stu300_wr8(val, dev->virtbase + I2C_CR);
+}
+
+static void stu300_irq_disable(struct stu300_dev *dev)
+{
+	u32 val;
+	val = stu300_r8(dev->virtbase + I2C_CR);
+	val &= ~I2C_CR_INTERRUPT_ENABLE;
+	/* Twice paranoia (possible HW glitch) */
+	stu300_wr8(val, dev->virtbase + I2C_CR);
+	stu300_wr8(val, dev->virtbase + I2C_CR);
+}
+
+
 /*
  * Tells whether a certain event or events occurred in
  * response to a command. The events represent states in
@@ -196,9 +219,10 @@ static inline u32 stu300_r8(void __iomem *address)
  * documentation and can only be treated as abstract state
  * machine states.
  *
- * @ret 0 = event has not occurred, any other value means
- * the event occurred.
+ * @ret 0 = event has not occurred or unknown error, any
+ * other value means the correct event occurred or an error.
  */
+
 static int stu300_event_occurred(struct stu300_dev *dev,
 				   enum stu300_event mr_event) {
 	u32 status1;
@@ -206,11 +230,28 @@ static int stu300_event_occurred(struct stu300_dev *dev,
 
 	/* What event happened? */
 	status1 = stu300_r8(dev->virtbase + I2C_SR1);
+
 	if (!(status1 & I2C_SR1_EVF_IND))
 		/* No event at all */
 		return 0;
+
 	status2 = stu300_r8(dev->virtbase + I2C_SR2);
 
+	/* Block any multiple interrupts */
+	stu300_irq_disable(dev);
+
+	/* Check for errors first */
+	if (status2 & I2C_SR2_AF_IND) {
+		dev->cmd_err = STU300_ERROR_ACKNOWLEDGE_FAILURE;
+		return 1;
+	} else if (status2 & I2C_SR2_BERR_IND) {
+		dev->cmd_err = STU300_ERROR_BUS_ERROR;
+		return 1;
+	} else if (status2 & I2C_SR2_ARLO_IND) {
+		dev->cmd_err = STU300_ERROR_ARBITRATION_LOST;
+		return 1;
+	}
+
 	switch (mr_event) {
 	case STU300_EVENT_1:
 		if (status1 & I2C_SR1_ADSL_IND)
@@ -221,10 +262,6 @@ static int stu300_event_occurred(struct stu300_dev *dev,
 	case STU300_EVENT_7:
 	case STU300_EVENT_8:
 		if (status1 & I2C_SR1_BTF_IND) {
-			if (status2 & I2C_SR2_AF_IND)
-				dev->cmd_err = STU300_ERROR_ACKNOWLEDGE_FAILURE;
-			else if (status2 & I2C_SR2_BERR_IND)
-				dev->cmd_err = STU300_ERROR_BUS_ERROR;
 			return 1;
 		}
 		break;
@@ -240,8 +277,6 @@ static int stu300_event_occurred(struct stu300_dev *dev,
 	case STU300_EVENT_6:
 		if (status2 & I2C_SR2_ENDAD_IND) {
 			/* First check for any errors */
-			if (status2 & I2C_SR2_AF_IND)
-				dev->cmd_err = STU300_ERROR_ACKNOWLEDGE_FAILURE;
 			return 1;
 		}
 		break;
@@ -252,8 +287,15 @@ static int stu300_event_occurred(struct stu300_dev *dev,
 	default:
 		break;
 	}
-	if (status2 & I2C_SR2_ARLO_IND)
-		dev->cmd_err = STU300_ERROR_ARBITRATION_LOST;
+	/* If we get here, we're on thin ice.
+	 * Here we are in a status where we have
+	 * gotten a response that does not match
+	 * what we requested.
+	 */
+	dev->cmd_err = STU300_ERROR_UNKNOWN;
+	dev_err(&dev->pdev->dev,
+		"Unhandled interrupt! %d sr1: 0x%x sr2: 0x%x\n",
+		mr_event, status1, status2);
 	return 0;
 }
 
@@ -262,21 +304,20 @@ static irqreturn_t stu300_irh(int irq, void *data)
 	struct stu300_dev *dev = data;
 	int res;
 
+	/* Just make sure that the block is clocked */
+	clk_enable(dev->clk);
+
 	/* See if this was what we were waiting for */
 	spin_lock(&dev->cmd_issue_lock);
-	if (dev->cmd_event != STU300_EVENT_NONE) {
-		res = stu300_event_occurred(dev, dev->cmd_event);
-		if (res || dev->cmd_err != STU300_ERROR_NONE) {
-			u32 val;
-
-			complete(&dev->cmd_complete);
-			/* Block any multiple interrupts */
-			val = stu300_r8(dev->virtbase + I2C_CR);
-			val &= ~I2C_CR_INTERRUPT_ENABLE;
-			stu300_wr8(val, dev->virtbase + I2C_CR);
-		}
-	}
+
+	res = stu300_event_occurred(dev, dev->cmd_event);
+	if (res || dev->cmd_err != STU300_ERROR_NONE)
+		complete(&dev->cmd_complete);
+
 	spin_unlock(&dev->cmd_issue_lock);
+
+	clk_disable(dev->clk);
+
 	return IRQ_HANDLED;
 }
 
@@ -308,7 +349,6 @@ static int stu300_start_and_await_event(struct stu300_dev *dev,
 	stu300_wr8(cr_value, dev->virtbase + I2C_CR);
 	ret = wait_for_completion_interruptible_timeout(&dev->cmd_complete,
 							STU300_TIMEOUT);
-
 	if (ret < 0) {
 		dev_err(&dev->pdev->dev,
 		       "wait_for_completion_interruptible_timeout() "
@@ -342,7 +382,6 @@ static int stu300_await_event(struct stu300_dev *dev,
 				enum stu300_event mr_event)
 {
 	int ret;
-	u32 val;
 
 	if (unlikely(irqs_disabled())) {
 		/* TODO: implement polling for this case if need be. */
@@ -354,36 +393,18 @@ static int stu300_await_event(struct stu300_dev *dev,
 	/* Is it already here? */
 	spin_lock_irq(&dev->cmd_issue_lock);
 	dev->cmd_err = STU300_ERROR_NONE;
-	if (stu300_event_occurred(dev, mr_event)) {
-		spin_unlock_irq(&dev->cmd_issue_lock);
-		goto exit_await_check_err;
-	}
-	init_completion(&dev->cmd_complete);
-	dev->cmd_err = STU300_ERROR_NONE;
 	dev->cmd_event = mr_event;
 
-	/* Turn on the I2C interrupt for current operation */
-	val = stu300_r8(dev->virtbase + I2C_CR);
-	val |= I2C_CR_INTERRUPT_ENABLE;
-	stu300_wr8(val, dev->virtbase + I2C_CR);
-
-	/* Twice paranoia (possible HW glitch) */
-	stu300_wr8(val, dev->virtbase + I2C_CR);
+	init_completion(&dev->cmd_complete);
 
-	/* Check again: is it already here? */
-	if (unlikely(stu300_event_occurred(dev, mr_event))) {
-		/* Disable IRQ again. */
-		val &= ~I2C_CR_INTERRUPT_ENABLE;
-		stu300_wr8(val, dev->virtbase + I2C_CR);
-		spin_unlock_irq(&dev->cmd_issue_lock);
-		goto exit_await_check_err;
-	}
+	/* Turn on the I2C interrupt for current operation */
+	stu300_irq_enable(dev);
 
 	/* Unlock the command block and wait for the event to occur */
 	spin_unlock_irq(&dev->cmd_issue_lock);
+
 	ret = wait_for_completion_interruptible_timeout(&dev->cmd_complete,
 							STU300_TIMEOUT);
-
 	if (ret < 0) {
 		dev_err(&dev->pdev->dev,
 		       "wait_for_completion_interruptible_timeout()"
@@ -401,7 +422,6 @@ static int stu300_await_event(struct stu300_dev *dev,
 		return -ETIMEDOUT;
 	}
 
- exit_await_check_err:
 	if (dev->cmd_err != STU300_ERROR_NONE) {
 		if (mr_event != STU300_EVENT_6) {
 			dev_err(&dev->pdev->dev, "controller "
@@ -457,18 +477,19 @@ struct stu300_clkset {
 };
 
 static const struct stu300_clkset stu300_clktable[] = {
-	{ 0, 0xFFU },
-	{ 2500000, I2C_OAR2_FR_25_10MHZ },
-	{ 10000000, I2C_OAR2_FR_10_1667MHZ },
-	{ 16670000, I2C_OAR2_FR_1667_2667MHZ },
-	{ 26670000, I2C_OAR2_FR_2667_40MHZ },
-	{ 40000000, I2C_OAR2_FR_40_5333MHZ },
-	{ 53330000, I2C_OAR2_FR_5333_66MHZ },
-	{ 66000000, I2C_OAR2_FR_66_80MHZ },
-	{ 80000000, I2C_OAR2_FR_80_100MHZ },
+	{ 0,         0xFFU },
+	{ 2500000,   I2C_OAR2_FR_25_10MHZ },
+	{ 10000000,  I2C_OAR2_FR_10_1667MHZ },
+	{ 16670000,  I2C_OAR2_FR_1667_2667MHZ },
+	{ 26670000,  I2C_OAR2_FR_2667_40MHZ },
+	{ 40000000,  I2C_OAR2_FR_40_5333MHZ },
+	{ 53330000,  I2C_OAR2_FR_5333_66MHZ },
+	{ 66000000,  I2C_OAR2_FR_66_80MHZ },
+	{ 80000000,  I2C_OAR2_FR_80_100MHZ },
 	{ 100000000, 0xFFU },
 };
 
+
 static int stu300_set_clk(struct stu300_dev *dev, unsigned long clkrate)
 {
 
@@ -494,10 +515,10 @@ static int stu300_set_clk(struct stu300_dev *dev, unsigned long clkrate)
 
 	if (dev->speed > 100000)
 		/* Fast Mode I2C */
-		val = ((clkrate/dev->speed)-9)/3;
+		val = ((clkrate/dev->speed) - 9)/3 + 1;
 	else
 		/* Standard Mode I2C */
-		val = ((clkrate/dev->speed)-7)/2;
+		val = ((clkrate/dev->speed) - 7)/2 + 1;
 
 	/* According to spec the divider must be > 2 */
 	if (val < 0x002) {
@@ -557,6 +578,7 @@ static int stu300_init_hw(struct stu300_dev *dev)
 	 */
 	clkrate = clk_get_rate(dev->clk);
 	ret = stu300_set_clk(dev, clkrate);
+
 	if (ret)
 		return ret;
 	/*
@@ -641,7 +663,6 @@ static int stu300_xfer_msg(struct i2c_adapter *adap,
 	int attempts = 0;
 	struct stu300_dev *dev = i2c_get_adapdata(adap);
 
-
 	clk_enable(dev->clk);
 
 	/* Remove this if (0) to trace each and every message. */
@@ -715,14 +736,15 @@ static int stu300_xfer_msg(struct i2c_adapter *adap,
 
 	if (attempts < NUM_ADDR_RESEND_ATTEMPTS && attempts > 0) {
 		dev_dbg(&dev->pdev->dev, "managed to get address "
-		       "through after %d attempts\n", attempts);
+			"through after %d attempts\n", attempts);
 	} else if (attempts == NUM_ADDR_RESEND_ATTEMPTS) {
 		dev_dbg(&dev->pdev->dev, "I give up, tried %d times "
-		       "to resend address.\n",
-		       NUM_ADDR_RESEND_ATTEMPTS);
+			"to resend address.\n",
+			NUM_ADDR_RESEND_ATTEMPTS);
 		goto exit_disable;
 	}
 
+
 	if (msg->flags & I2C_M_RD) {
 		/* READ: we read the actual bytes one at a time */
 		for (i = 0; i < msg->len; i++) {
@@ -804,8 +826,10 @@ static int stu300_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 {
 	int ret = -1;
 	int i;
+
 	struct stu300_dev *dev = i2c_get_adapdata(adap);
 	dev->msg_len = num;
+
 	for (i = 0; i < num; i++) {
 		/*
 		 * Another driver appears to send stop for each message,
@@ -817,6 +841,7 @@ static int stu300_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 		dev->msg_index = i;
 
 		ret = stu300_xfer_msg(adap, &msgs[i], (i == (num - 1)));
+
 		if (ret != 0) {
 			num = ret;
 			break;
@@ -845,6 +870,7 @@ stu300_probe(struct platform_device *pdev)
 	struct resource *res;
 	int bus_nr;
 	int ret = 0;
+	char clk_name[] = "I2C0";
 
 	dev = kzalloc(sizeof(struct stu300_dev), GFP_KERNEL);
 	if (!dev) {
@@ -854,7 +880,8 @@ stu300_probe(struct platform_device *pdev)
 	}
 
 	bus_nr = pdev->id;
-	dev->clk = clk_get(&pdev->dev, NULL);
+	clk_name[3] += (char)bus_nr;
+	dev->clk = clk_get(&pdev->dev, clk_name);
 	if (IS_ERR(dev->clk)) {
 		ret = PTR_ERR(dev->clk);
 		dev_err(&pdev->dev, "could not retrieve i2c bus clock\n");

commit 18904c0ecdf2cf22347da2adc4b273e9570333d8
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Sat Jun 13 21:51:34 2009 +0200

    i2c: ST DDC I2C U300 bus driver v3
    
    This adds support for the ST Microelectronics DDC I2C bus
    driver. This bus is used in the U300 architecture recently
    added to RMK:s ARM tree.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Reviewed-by: Ben Dooks <ben-linux@fluff.org>
    Reviewed-by: Jean Delvare <khali@linus-fr.org>
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>

diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
new file mode 100644
index 000000000000..182e711318ba
--- /dev/null
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -0,0 +1,1029 @@
+/*
+ * Copyright (C) 2007-2009 ST-Ericsson AB
+ * License terms: GNU General Public License (GPL) version 2
+ * ST DDC I2C master mode driver, used in e.g. U300 series platforms.
+ * Author: Linus Walleij <linus.walleij@stericsson.com>
+ * Author: Jonas Aaberg <jonas.aberg@stericsson.com>
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/spinlock.h>
+#include <linux/completion.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+/* the name of this kernel module */
+#define NAME "stu300"
+
+/* CR (Control Register) 8bit (R/W) */
+#define I2C_CR					(0x00000000)
+#define I2C_CR_RESET_VALUE			(0x00)
+#define I2C_CR_RESET_UMASK			(0x00)
+#define I2C_CR_DDC1_ENABLE			(0x80)
+#define I2C_CR_TRANS_ENABLE			(0x40)
+#define I2C_CR_PERIPHERAL_ENABLE		(0x20)
+#define I2C_CR_DDC2B_ENABLE			(0x10)
+#define I2C_CR_START_ENABLE			(0x08)
+#define I2C_CR_ACK_ENABLE			(0x04)
+#define I2C_CR_STOP_ENABLE			(0x02)
+#define I2C_CR_INTERRUPT_ENABLE			(0x01)
+/* SR1 (Status Register 1) 8bit (R/-) */
+#define I2C_SR1					(0x00000004)
+#define I2C_SR1_RESET_VALUE			(0x00)
+#define I2C_SR1_RESET_UMASK			(0x00)
+#define I2C_SR1_EVF_IND				(0x80)
+#define I2C_SR1_ADD10_IND			(0x40)
+#define I2C_SR1_TRA_IND				(0x20)
+#define I2C_SR1_BUSY_IND			(0x10)
+#define I2C_SR1_BTF_IND				(0x08)
+#define I2C_SR1_ADSL_IND			(0x04)
+#define I2C_SR1_MSL_IND				(0x02)
+#define I2C_SR1_SB_IND				(0x01)
+/* SR2 (Status Register 2) 8bit (R/-) */
+#define I2C_SR2					(0x00000008)
+#define I2C_SR2_RESET_VALUE			(0x00)
+#define I2C_SR2_RESET_UMASK			(0x40)
+#define I2C_SR2_MASK				(0xBF)
+#define I2C_SR2_SCLFAL_IND			(0x80)
+#define I2C_SR2_ENDAD_IND			(0x20)
+#define I2C_SR2_AF_IND				(0x10)
+#define I2C_SR2_STOPF_IND			(0x08)
+#define I2C_SR2_ARLO_IND			(0x04)
+#define I2C_SR2_BERR_IND			(0x02)
+#define I2C_SR2_DDC2BF_IND			(0x01)
+/* CCR (Clock Control Register) 8bit (R/W) */
+#define I2C_CCR					(0x0000000C)
+#define I2C_CCR_RESET_VALUE			(0x00)
+#define I2C_CCR_RESET_UMASK			(0x00)
+#define I2C_CCR_MASK				(0xFF)
+#define I2C_CCR_FMSM				(0x80)
+#define I2C_CCR_CC_MASK				(0x7F)
+/* OAR1 (Own Address Register 1) 8bit (R/W) */
+#define I2C_OAR1				(0x00000010)
+#define I2C_OAR1_RESET_VALUE			(0x00)
+#define I2C_OAR1_RESET_UMASK			(0x00)
+#define I2C_OAR1_ADD_MASK			(0xFF)
+/* OAR2 (Own Address Register 2) 8bit (R/W) */
+#define I2C_OAR2				(0x00000014)
+#define I2C_OAR2_RESET_VALUE			(0x40)
+#define I2C_OAR2_RESET_UMASK			(0x19)
+#define I2C_OAR2_MASK				(0xE6)
+#define I2C_OAR2_FR_25_10MHZ			(0x00)
+#define I2C_OAR2_FR_10_1667MHZ			(0x20)
+#define I2C_OAR2_FR_1667_2667MHZ		(0x40)
+#define I2C_OAR2_FR_2667_40MHZ			(0x60)
+#define I2C_OAR2_FR_40_5333MHZ			(0x80)
+#define I2C_OAR2_FR_5333_66MHZ			(0xA0)
+#define I2C_OAR2_FR_66_80MHZ			(0xC0)
+#define I2C_OAR2_FR_80_100MHZ			(0xE0)
+#define I2C_OAR2_FR_MASK			(0xE0)
+#define I2C_OAR2_ADD_MASK			(0x06)
+/* DR (Data Register) 8bit (R/W) */
+#define I2C_DR					(0x00000018)
+#define I2C_DR_RESET_VALUE			(0x00)
+#define I2C_DR_RESET_UMASK			(0xFF)
+#define I2C_DR_D_MASK				(0xFF)
+/* ECCR (Extended Clock Control Register) 8bit (R/W) */
+#define I2C_ECCR				(0x0000001C)
+#define I2C_ECCR_RESET_VALUE			(0x00)
+#define I2C_ECCR_RESET_UMASK			(0xE0)
+#define I2C_ECCR_MASK				(0x1F)
+#define I2C_ECCR_CC_MASK			(0x1F)
+
+/*
+ * These events are more or less responses to commands
+ * sent into the hardware, presumably reflecting the state
+ * of an internal state machine.
+ */
+enum stu300_event {
+	STU300_EVENT_NONE = 0,
+	STU300_EVENT_1,
+	STU300_EVENT_2,
+	STU300_EVENT_3,
+	STU300_EVENT_4,
+	STU300_EVENT_5,
+	STU300_EVENT_6,
+	STU300_EVENT_7,
+	STU300_EVENT_8,
+	STU300_EVENT_9
+};
+
+enum stu300_error {
+	STU300_ERROR_NONE = 0,
+	STU300_ERROR_ACKNOWLEDGE_FAILURE,
+	STU300_ERROR_BUS_ERROR,
+	STU300_ERROR_ARBITRATION_LOST
+};
+
+/* timeout waiting for the controller to respond */
+#define STU300_TIMEOUT (msecs_to_jiffies(1000))
+
+/*
+ * The number of address send athemps tried before giving up.
+ * If the first one failes it seems like 5 to 8 attempts are required.
+ */
+#define NUM_ADDR_RESEND_ATTEMPTS 10
+
+/* I2C clock speed, in Hz 0-400kHz*/
+static unsigned int scl_frequency = 100000;
+module_param(scl_frequency, uint,  0644);
+
+/**
+ * struct stu300_dev - the stu300 driver state holder
+ * @pdev: parent platform device
+ * @adapter: corresponding I2C adapter
+ * @phybase: location of I/O area in memory
+ * @physize: size of I/O area in memory
+ * @clk: hardware block clock
+ * @irq: assigned interrupt line
+ * @cmd_issue_lock: this locks the following cmd_ variables
+ * @cmd_complete: acknowledge completion for an I2C command
+ * @cmd_event: expected event coming in as a response to a command
+ * @cmd_err: error code as response to a command
+ * @speed: current bus speed in Hz
+ * @msg_index: index of current message
+ * @msg_len: length of current message
+ */
+struct stu300_dev {
+	struct platform_device	*pdev;
+	struct i2c_adapter	adapter;
+	resource_size_t		phybase;
+	resource_size_t		physize;
+	void __iomem		*virtbase;
+	struct clk		*clk;
+	int			irq;
+	spinlock_t		cmd_issue_lock;
+	struct completion	cmd_complete;
+	enum stu300_event	cmd_event;
+	enum stu300_error	cmd_err;
+	unsigned int		speed;
+	int			msg_index;
+	int			msg_len;
+};
+
+/* Local forward function declarations */
+static int stu300_init_hw(struct stu300_dev *dev);
+
+/*
+ * The block needs writes in both MSW and LSW in order
+ * for all data lines to reach their destination.
+ */
+static inline void stu300_wr8(u32 value, void __iomem *address)
+{
+	writel((value << 16) | value, address);
+}
+
+/*
+ * This merely masks off the duplicates which appear
+ * in bytes 1-3. You _MUST_ use 32-bit bus access on this
+ * device, else it will not work.
+ */
+static inline u32 stu300_r8(void __iomem *address)
+{
+	return readl(address) & 0x000000FFU;
+}
+
+/*
+ * Tells whether a certain event or events occurred in
+ * response to a command. The events represent states in
+ * the internal state machine of the hardware. The events
+ * are not very well described in the hardware
+ * documentation and can only be treated as abstract state
+ * machine states.
+ *
+ * @ret 0 = event has not occurred, any other value means
+ * the event occurred.
+ */
+static int stu300_event_occurred(struct stu300_dev *dev,
+				   enum stu300_event mr_event) {
+	u32 status1;
+	u32 status2;
+
+	/* What event happened? */
+	status1 = stu300_r8(dev->virtbase + I2C_SR1);
+	if (!(status1 & I2C_SR1_EVF_IND))
+		/* No event at all */
+		return 0;
+	status2 = stu300_r8(dev->virtbase + I2C_SR2);
+
+	switch (mr_event) {
+	case STU300_EVENT_1:
+		if (status1 & I2C_SR1_ADSL_IND)
+			return 1;
+		break;
+	case STU300_EVENT_2:
+	case STU300_EVENT_3:
+	case STU300_EVENT_7:
+	case STU300_EVENT_8:
+		if (status1 & I2C_SR1_BTF_IND) {
+			if (status2 & I2C_SR2_AF_IND)
+				dev->cmd_err = STU300_ERROR_ACKNOWLEDGE_FAILURE;
+			else if (status2 & I2C_SR2_BERR_IND)
+				dev->cmd_err = STU300_ERROR_BUS_ERROR;
+			return 1;
+		}
+		break;
+	case STU300_EVENT_4:
+		if (status2 & I2C_SR2_STOPF_IND)
+			return 1;
+		break;
+	case STU300_EVENT_5:
+		if (status1 & I2C_SR1_SB_IND)
+			/* Clear start bit */
+			return 1;
+		break;
+	case STU300_EVENT_6:
+		if (status2 & I2C_SR2_ENDAD_IND) {
+			/* First check for any errors */
+			if (status2 & I2C_SR2_AF_IND)
+				dev->cmd_err = STU300_ERROR_ACKNOWLEDGE_FAILURE;
+			return 1;
+		}
+		break;
+	case STU300_EVENT_9:
+		if (status1 & I2C_SR1_ADD10_IND)
+			return 1;
+		break;
+	default:
+		break;
+	}
+	if (status2 & I2C_SR2_ARLO_IND)
+		dev->cmd_err = STU300_ERROR_ARBITRATION_LOST;
+	return 0;
+}
+
+static irqreturn_t stu300_irh(int irq, void *data)
+{
+	struct stu300_dev *dev = data;
+	int res;
+
+	/* See if this was what we were waiting for */
+	spin_lock(&dev->cmd_issue_lock);
+	if (dev->cmd_event != STU300_EVENT_NONE) {
+		res = stu300_event_occurred(dev, dev->cmd_event);
+		if (res || dev->cmd_err != STU300_ERROR_NONE) {
+			u32 val;
+
+			complete(&dev->cmd_complete);
+			/* Block any multiple interrupts */
+			val = stu300_r8(dev->virtbase + I2C_CR);
+			val &= ~I2C_CR_INTERRUPT_ENABLE;
+			stu300_wr8(val, dev->virtbase + I2C_CR);
+		}
+	}
+	spin_unlock(&dev->cmd_issue_lock);
+	return IRQ_HANDLED;
+}
+
+/*
+ * Sends a command and then waits for the bits masked by *flagmask*
+ * to go high or low by IRQ awaiting.
+ */
+static int stu300_start_and_await_event(struct stu300_dev *dev,
+					  u8 cr_value,
+					  enum stu300_event mr_event)
+{
+	int ret;
+
+	if (unlikely(irqs_disabled())) {
+		/* TODO: implement polling for this case if need be. */
+		WARN(1, "irqs are disabled, cannot poll for event\n");
+		return -EIO;
+	}
+
+	/* Lock command issue, fill in an event we wait for */
+	spin_lock_irq(&dev->cmd_issue_lock);
+	init_completion(&dev->cmd_complete);
+	dev->cmd_err = STU300_ERROR_NONE;
+	dev->cmd_event = mr_event;
+	spin_unlock_irq(&dev->cmd_issue_lock);
+
+	/* Turn on interrupt, send command and wait. */
+	cr_value |= I2C_CR_INTERRUPT_ENABLE;
+	stu300_wr8(cr_value, dev->virtbase + I2C_CR);
+	ret = wait_for_completion_interruptible_timeout(&dev->cmd_complete,
+							STU300_TIMEOUT);
+
+	if (ret < 0) {
+		dev_err(&dev->pdev->dev,
+		       "wait_for_completion_interruptible_timeout() "
+		       "returned %d waiting for event %04x\n", ret, mr_event);
+		return ret;
+	}
+
+	if (ret == 0) {
+		dev_err(&dev->pdev->dev, "controller timed out "
+		       "waiting for event %d, reinit hardware\n", mr_event);
+		(void) stu300_init_hw(dev);
+		return -ETIMEDOUT;
+	}
+
+	if (dev->cmd_err != STU300_ERROR_NONE) {
+		dev_err(&dev->pdev->dev, "controller (start) "
+		       "error %d waiting for event %d, reinit hardware\n",
+		       dev->cmd_err, mr_event);
+		(void) stu300_init_hw(dev);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+/*
+ * This waits for a flag to be set, if it is not set on entry, an interrupt is
+ * configured to wait for the flag using a completion.
+ */
+static int stu300_await_event(struct stu300_dev *dev,
+				enum stu300_event mr_event)
+{
+	int ret;
+	u32 val;
+
+	if (unlikely(irqs_disabled())) {
+		/* TODO: implement polling for this case if need be. */
+		dev_err(&dev->pdev->dev, "irqs are disabled on this "
+			"system!\n");
+		return -EIO;
+	}
+
+	/* Is it already here? */
+	spin_lock_irq(&dev->cmd_issue_lock);
+	dev->cmd_err = STU300_ERROR_NONE;
+	if (stu300_event_occurred(dev, mr_event)) {
+		spin_unlock_irq(&dev->cmd_issue_lock);
+		goto exit_await_check_err;
+	}
+	init_completion(&dev->cmd_complete);
+	dev->cmd_err = STU300_ERROR_NONE;
+	dev->cmd_event = mr_event;
+
+	/* Turn on the I2C interrupt for current operation */
+	val = stu300_r8(dev->virtbase + I2C_CR);
+	val |= I2C_CR_INTERRUPT_ENABLE;
+	stu300_wr8(val, dev->virtbase + I2C_CR);
+
+	/* Twice paranoia (possible HW glitch) */
+	stu300_wr8(val, dev->virtbase + I2C_CR);
+
+	/* Check again: is it already here? */
+	if (unlikely(stu300_event_occurred(dev, mr_event))) {
+		/* Disable IRQ again. */
+		val &= ~I2C_CR_INTERRUPT_ENABLE;
+		stu300_wr8(val, dev->virtbase + I2C_CR);
+		spin_unlock_irq(&dev->cmd_issue_lock);
+		goto exit_await_check_err;
+	}
+
+	/* Unlock the command block and wait for the event to occur */
+	spin_unlock_irq(&dev->cmd_issue_lock);
+	ret = wait_for_completion_interruptible_timeout(&dev->cmd_complete,
+							STU300_TIMEOUT);
+
+	if (ret < 0) {
+		dev_err(&dev->pdev->dev,
+		       "wait_for_completion_interruptible_timeout()"
+		       "returned %d waiting for event %04x\n", ret, mr_event);
+		return ret;
+	}
+
+	if (ret == 0) {
+		if (mr_event != STU300_EVENT_6) {
+			dev_err(&dev->pdev->dev, "controller "
+				"timed out waiting for event %d, reinit "
+				"hardware\n", mr_event);
+			(void) stu300_init_hw(dev);
+		}
+		return -ETIMEDOUT;
+	}
+
+ exit_await_check_err:
+	if (dev->cmd_err != STU300_ERROR_NONE) {
+		if (mr_event != STU300_EVENT_6) {
+			dev_err(&dev->pdev->dev, "controller "
+				"error (await_event) %d waiting for event %d, "
+			       "reinit hardware\n", dev->cmd_err, mr_event);
+			(void) stu300_init_hw(dev);
+		}
+		return -EIO;
+	}
+
+	return 0;
+}
+
+/*
+ * Waits for the busy bit to go low by repeated polling.
+ */
+#define BUSY_RELEASE_ATTEMPTS 10
+static int stu300_wait_while_busy(struct stu300_dev *dev)
+{
+	unsigned long timeout;
+	int i;
+
+	for (i = 0; i < BUSY_RELEASE_ATTEMPTS; i++) {
+		timeout = jiffies + STU300_TIMEOUT;
+
+		while (!time_after(jiffies, timeout)) {
+			/* Is not busy? */
+			if ((stu300_r8(dev->virtbase + I2C_SR1) &
+			     I2C_SR1_BUSY_IND) == 0)
+				return 0;
+			msleep(1);
+		}
+
+		dev_err(&dev->pdev->dev, "transaction timed out "
+			"waiting for device to be free (not busy). "
+		       "Attempt: %d\n", i+1);
+
+		dev_err(&dev->pdev->dev, "base address = "
+			"0x%08x, reinit hardware\n", (u32) dev->virtbase);
+
+		(void) stu300_init_hw(dev);
+	}
+
+	dev_err(&dev->pdev->dev, "giving up after %d attempts "
+		"to reset the bus.\n",  BUSY_RELEASE_ATTEMPTS);
+
+	return -ETIMEDOUT;
+}
+
+struct stu300_clkset {
+	unsigned long rate;
+	u32 setting;
+};
+
+static const struct stu300_clkset stu300_clktable[] = {
+	{ 0, 0xFFU },
+	{ 2500000, I2C_OAR2_FR_25_10MHZ },
+	{ 10000000, I2C_OAR2_FR_10_1667MHZ },
+	{ 16670000, I2C_OAR2_FR_1667_2667MHZ },
+	{ 26670000, I2C_OAR2_FR_2667_40MHZ },
+	{ 40000000, I2C_OAR2_FR_40_5333MHZ },
+	{ 53330000, I2C_OAR2_FR_5333_66MHZ },
+	{ 66000000, I2C_OAR2_FR_66_80MHZ },
+	{ 80000000, I2C_OAR2_FR_80_100MHZ },
+	{ 100000000, 0xFFU },
+};
+
+static int stu300_set_clk(struct stu300_dev *dev, unsigned long clkrate)
+{
+
+	u32 val;
+	int i = 0;
+
+	/* Locate the apropriate clock setting */
+	while (i < ARRAY_SIZE(stu300_clktable) &&
+	       stu300_clktable[i].rate < clkrate)
+		i++;
+
+	if (stu300_clktable[i].setting == 0xFFU) {
+		dev_err(&dev->pdev->dev, "too %s clock rate requested "
+			"(%lu Hz).\n", i ? "high" : "low", clkrate);
+		return -EINVAL;
+	}
+
+	stu300_wr8(stu300_clktable[i].setting,
+		   dev->virtbase + I2C_OAR2);
+
+	dev_dbg(&dev->pdev->dev, "Clock rate %lu Hz, I2C bus speed %d Hz "
+		"virtbase %p\n", clkrate, dev->speed, dev->virtbase);
+
+	if (dev->speed > 100000)
+		/* Fast Mode I2C */
+		val = ((clkrate/dev->speed)-9)/3;
+	else
+		/* Standard Mode I2C */
+		val = ((clkrate/dev->speed)-7)/2;
+
+	/* According to spec the divider must be > 2 */
+	if (val < 0x002) {
+		dev_err(&dev->pdev->dev, "too low clock rate (%lu Hz).\n",
+			clkrate);
+		return -EINVAL;
+	}
+
+	/* We have 12 bits clock divider only! */
+	if (val & 0xFFFFF000U) {
+		dev_err(&dev->pdev->dev, "too high clock rate (%lu Hz).\n",
+			clkrate);
+		return -EINVAL;
+	}
+
+	if (dev->speed > 100000) {
+		/* CC6..CC0 */
+		stu300_wr8((val & I2C_CCR_CC_MASK) | I2C_CCR_FMSM,
+			   dev->virtbase + I2C_CCR);
+		dev_dbg(&dev->pdev->dev, "set clock divider to 0x%08x, "
+			"Fast Mode I2C\n", val);
+	} else {
+		/* CC6..CC0 */
+		stu300_wr8((val & I2C_CCR_CC_MASK),
+			   dev->virtbase + I2C_CCR);
+		dev_dbg(&dev->pdev->dev, "set clock divider to "
+			"0x%08x, Standard Mode I2C\n", val);
+	}
+
+	/* CC11..CC7 */
+	stu300_wr8(((val >> 7) & 0x1F),
+		   dev->virtbase + I2C_ECCR);
+
+	return 0;
+}
+
+
+static int stu300_init_hw(struct stu300_dev *dev)
+{
+	u32 dummy;
+	unsigned long clkrate;
+	int ret;
+
+	/* Disable controller */
+	stu300_wr8(0x00, dev->virtbase + I2C_CR);
+	/*
+	 * Set own address to some default value (0x00).
+	 * We do not support slave mode anyway.
+	 */
+	stu300_wr8(0x00, dev->virtbase + I2C_OAR1);
+	/*
+	 * The I2C controller only operates properly in 26 MHz but we
+	 * program this driver as if we didn't know. This will also set the two
+	 * high bits of the own address to zero as well.
+	 * There is no known hardware issue with running in 13 MHz
+	 * However, speeds over 200 kHz are not used.
+	 */
+	clkrate = clk_get_rate(dev->clk);
+	ret = stu300_set_clk(dev, clkrate);
+	if (ret)
+		return ret;
+	/*
+	 * Enable block, do it TWICE (hardware glitch)
+	 * Setting bit 7 can enable DDC mode. (Not used currently.)
+	 */
+	stu300_wr8(I2C_CR_PERIPHERAL_ENABLE,
+				  dev->virtbase + I2C_CR);
+	stu300_wr8(I2C_CR_PERIPHERAL_ENABLE,
+				  dev->virtbase + I2C_CR);
+	/* Make a dummy read of the status register SR1 & SR2 */
+	dummy = stu300_r8(dev->virtbase + I2C_SR2);
+	dummy = stu300_r8(dev->virtbase + I2C_SR1);
+
+	return 0;
+}
+
+
+
+/* Send slave address. */
+static int stu300_send_address(struct stu300_dev *dev,
+				 struct i2c_msg *msg, int resend)
+{
+	u32 val;
+	int ret;
+
+	if (msg->flags & I2C_M_TEN)
+		/* This is probably how 10 bit addresses look */
+		val = (0xf0 | (((u32) msg->addr & 0x300) >> 7)) &
+			I2C_DR_D_MASK;
+	else
+		val = ((msg->addr << 1) & I2C_DR_D_MASK);
+
+	if (msg->flags & I2C_M_RD) {
+		/* This is the direction bit */
+		val |= 0x01;
+		if (resend)
+			dev_dbg(&dev->pdev->dev, "read resend\n");
+	} else if (resend)
+		dev_dbg(&dev->pdev->dev, "write resend\n");
+	stu300_wr8(val, dev->virtbase + I2C_DR);
+
+	/* For 10bit addressing, await 10bit request (EVENT 9) */
+	if (msg->flags & I2C_M_TEN) {
+		ret = stu300_await_event(dev, STU300_EVENT_9);
+		/*
+		 * The slave device wants a 10bit address, send the rest
+		 * of the bits (the LSBits)
+		 */
+		val = msg->addr & I2C_DR_D_MASK;
+		/* This clears "event 9" */
+		stu300_wr8(val, dev->virtbase + I2C_DR);
+		if (ret != 0)
+			return ret;
+	}
+	/* FIXME: Why no else here? two events for 10bit?
+	 * Await event 6 (normal) or event 9 (10bit)
+	 */
+
+	if (resend)
+		dev_dbg(&dev->pdev->dev, "await event 6\n");
+	ret = stu300_await_event(dev, STU300_EVENT_6);
+
+	/*
+	 * Clear any pending EVENT 6 no matter what happend during
+	 * await_event.
+	 */
+	val = stu300_r8(dev->virtbase + I2C_CR);
+	val |= I2C_CR_PERIPHERAL_ENABLE;
+	stu300_wr8(val, dev->virtbase + I2C_CR);
+
+	return ret;
+}
+
+static int stu300_xfer_msg(struct i2c_adapter *adap,
+			     struct i2c_msg *msg, int stop)
+{
+	u32 cr;
+	u32 val;
+	u32 i;
+	int ret;
+	int attempts = 0;
+	struct stu300_dev *dev = i2c_get_adapdata(adap);
+
+
+	clk_enable(dev->clk);
+
+	/* Remove this if (0) to trace each and every message. */
+	if (0) {
+		dev_dbg(&dev->pdev->dev, "I2C message to: 0x%04x, len: %d, "
+			"flags: 0x%04x, stop: %d\n",
+			msg->addr, msg->len, msg->flags, stop);
+	}
+
+	/* Zero-length messages are not supported by this hardware */
+	if (msg->len == 0) {
+		ret = -EINVAL;
+		goto exit_disable;
+	}
+
+	/*
+	 * For some reason, sending the address sometimes fails when running
+	 * on  the 13 MHz clock. No interrupt arrives. This is a work around,
+	 * which tries to restart and send the address up to 10 times before
+	 * really giving up. Usually 5 to 8 attempts are enough.
+	 */
+	do {
+		if (attempts)
+			dev_dbg(&dev->pdev->dev, "wait while busy\n");
+		/* Check that the bus is free, or wait until some timeout */
+		ret = stu300_wait_while_busy(dev);
+		if (ret != 0)
+			goto exit_disable;
+
+		if (attempts)
+			dev_dbg(&dev->pdev->dev, "re-int hw\n");
+		/*
+		 * According to ST, there is no problem if the clock is
+		 * changed between 13 and 26 MHz during a transfer.
+		 */
+		ret = stu300_init_hw(dev);
+		if (ret)
+			goto exit_disable;
+
+		/* Send a start condition */
+		cr = I2C_CR_PERIPHERAL_ENABLE;
+		/* Setting the START bit puts the block in master mode */
+		if (!(msg->flags & I2C_M_NOSTART))
+			cr |= I2C_CR_START_ENABLE;
+		if ((msg->flags & I2C_M_RD) && (msg->len > 1))
+			/* On read more than 1 byte, we need ack. */
+			cr |= I2C_CR_ACK_ENABLE;
+		/* Check that it gets through */
+		if (!(msg->flags & I2C_M_NOSTART)) {
+			if (attempts)
+				dev_dbg(&dev->pdev->dev, "send start event\n");
+			ret = stu300_start_and_await_event(dev, cr,
+							     STU300_EVENT_5);
+		}
+
+		if (attempts)
+			dev_dbg(&dev->pdev->dev, "send address\n");
+
+		if (ret == 0)
+			/* Send address */
+			ret = stu300_send_address(dev, msg, attempts != 0);
+
+		if (ret != 0) {
+			attempts++;
+			dev_dbg(&dev->pdev->dev, "failed sending address, "
+				"retrying. Attempt: %d msg_index: %d/%d\n",
+			       attempts, dev->msg_index, dev->msg_len);
+		}
+
+	} while (ret != 0 && attempts < NUM_ADDR_RESEND_ATTEMPTS);
+
+	if (attempts < NUM_ADDR_RESEND_ATTEMPTS && attempts > 0) {
+		dev_dbg(&dev->pdev->dev, "managed to get address "
+		       "through after %d attempts\n", attempts);
+	} else if (attempts == NUM_ADDR_RESEND_ATTEMPTS) {
+		dev_dbg(&dev->pdev->dev, "I give up, tried %d times "
+		       "to resend address.\n",
+		       NUM_ADDR_RESEND_ATTEMPTS);
+		goto exit_disable;
+	}
+
+	if (msg->flags & I2C_M_RD) {
+		/* READ: we read the actual bytes one at a time */
+		for (i = 0; i < msg->len; i++) {
+			if (i == msg->len-1) {
+				/*
+				 * Disable ACK and set STOP condition before
+				 * reading last byte
+				 */
+				val = I2C_CR_PERIPHERAL_ENABLE;
+
+				if (stop)
+					val |= I2C_CR_STOP_ENABLE;
+
+				stu300_wr8(val,
+					   dev->virtbase + I2C_CR);
+			}
+			/* Wait for this byte... */
+			ret = stu300_await_event(dev, STU300_EVENT_7);
+			if (ret != 0)
+				goto exit_disable;
+			/* This clears event 7 */
+			msg->buf[i] = (u8) stu300_r8(dev->virtbase + I2C_DR);
+		}
+	} else {
+		/* WRITE: we send the actual bytes one at a time */
+		for (i = 0; i < msg->len; i++) {
+			/* Write the byte */
+			stu300_wr8(msg->buf[i],
+				   dev->virtbase + I2C_DR);
+			/* Check status */
+			ret = stu300_await_event(dev, STU300_EVENT_8);
+			/* Next write to DR will clear event 8 */
+			if (ret != 0) {
+				dev_err(&dev->pdev->dev, "error awaiting "
+				       "event 8 (%d)\n", ret);
+				goto exit_disable;
+			}
+		}
+		/* Check NAK */
+		if (!(msg->flags & I2C_M_IGNORE_NAK)) {
+			if (stu300_r8(dev->virtbase + I2C_SR2) &
+			    I2C_SR2_AF_IND) {
+				dev_err(&dev->pdev->dev, "I2C payload "
+				       "send returned NAK!\n");
+				ret = -EIO;
+				goto exit_disable;
+			}
+		}
+		if (stop) {
+			/* Send stop condition */
+			val = I2C_CR_PERIPHERAL_ENABLE;
+			val |= I2C_CR_STOP_ENABLE;
+			stu300_wr8(val, dev->virtbase + I2C_CR);
+		}
+	}
+
+	/* Check that the bus is free, or wait until some timeout occurs */
+	ret = stu300_wait_while_busy(dev);
+	if (ret != 0) {
+		dev_err(&dev->pdev->dev, "timout waiting for transfer "
+		       "to commence.\n");
+		goto exit_disable;
+	}
+
+	/* Dummy read status registers */
+	val = stu300_r8(dev->virtbase + I2C_SR2);
+	val = stu300_r8(dev->virtbase + I2C_SR1);
+	ret = 0;
+
+ exit_disable:
+	/* Disable controller */
+	stu300_wr8(0x00, dev->virtbase + I2C_CR);
+	clk_disable(dev->clk);
+	return ret;
+}
+
+static int stu300_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
+			 int num)
+{
+	int ret = -1;
+	int i;
+	struct stu300_dev *dev = i2c_get_adapdata(adap);
+	dev->msg_len = num;
+	for (i = 0; i < num; i++) {
+		/*
+		 * Another driver appears to send stop for each message,
+		 * here we only do that for the last message. Possibly some
+		 * peripherals require this behaviour, then their drivers
+		 * have to send single messages in order to get "stop" for
+		 * each message.
+		 */
+		dev->msg_index = i;
+
+		ret = stu300_xfer_msg(adap, &msgs[i], (i == (num - 1)));
+		if (ret != 0) {
+			num = ret;
+			break;
+		}
+	}
+
+	return num;
+}
+
+static u32 stu300_func(struct i2c_adapter *adap)
+{
+	/* This is the simplest thing you can think of... */
+	return I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR;
+}
+
+static const struct i2c_algorithm stu300_algo = {
+	.master_xfer	= stu300_xfer,
+	.functionality	= stu300_func,
+};
+
+static int __init
+stu300_probe(struct platform_device *pdev)
+{
+	struct stu300_dev *dev;
+	struct i2c_adapter *adap;
+	struct resource *res;
+	int bus_nr;
+	int ret = 0;
+
+	dev = kzalloc(sizeof(struct stu300_dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&pdev->dev, "could not allocate device struct\n");
+		ret = -ENOMEM;
+		goto err_no_devmem;
+	}
+
+	bus_nr = pdev->id;
+	dev->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(dev->clk)) {
+		ret = PTR_ERR(dev->clk);
+		dev_err(&pdev->dev, "could not retrieve i2c bus clock\n");
+		goto err_no_clk;
+	}
+
+	dev->pdev = pdev;
+	platform_set_drvdata(pdev, dev);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENOENT;
+		goto err_no_resource;
+	}
+
+	dev->phybase = res->start;
+	dev->physize = resource_size(res);
+
+	if (request_mem_region(dev->phybase, dev->physize,
+			       NAME " I/O Area") == NULL) {
+		ret = -EBUSY;
+		goto err_no_ioregion;
+	}
+
+	dev->virtbase = ioremap(dev->phybase, dev->physize);
+	dev_dbg(&pdev->dev, "initialize bus device I2C%d on virtual "
+		"base %p\n", bus_nr, dev->virtbase);
+	if (!dev->virtbase) {
+		ret = -ENOMEM;
+		goto err_no_ioremap;
+	}
+
+	dev->irq = platform_get_irq(pdev, 0);
+	if (request_irq(dev->irq, stu300_irh, IRQF_DISABLED,
+			NAME, dev)) {
+		ret = -EIO;
+		goto err_no_irq;
+	}
+
+	dev->speed = scl_frequency;
+
+	clk_enable(dev->clk);
+	ret = stu300_init_hw(dev);
+	clk_disable(dev->clk);
+
+	if (ret != 0) {
+		dev_err(&dev->pdev->dev, "error initializing hardware.\n");
+		goto err_init_hw;
+	}
+
+	/* IRQ event handling initialization */
+	spin_lock_init(&dev->cmd_issue_lock);
+	dev->cmd_event = STU300_EVENT_NONE;
+	dev->cmd_err = STU300_ERROR_NONE;
+
+	adap = &dev->adapter;
+	adap->owner = THIS_MODULE;
+	/* DDC class but actually often used for more generic I2C */
+	adap->class = I2C_CLASS_DDC;
+	strncpy(adap->name, "ST Microelectronics DDC I2C adapter",
+		sizeof(adap->name));
+	adap->nr = bus_nr;
+	adap->algo = &stu300_algo;
+	adap->dev.parent = &pdev->dev;
+	i2c_set_adapdata(adap, dev);
+
+	/* i2c device drivers may be active on return from add_adapter() */
+	ret = i2c_add_numbered_adapter(adap);
+	if (ret) {
+		dev_err(&dev->pdev->dev, "failure adding ST Micro DDC "
+		       "I2C adapter\n");
+		goto err_add_adapter;
+	}
+	return 0;
+
+ err_add_adapter:
+ err_init_hw:
+	free_irq(dev->irq, dev);
+ err_no_irq:
+	iounmap(dev->virtbase);
+ err_no_ioremap:
+	release_mem_region(dev->phybase, dev->physize);
+ err_no_ioregion:
+	platform_set_drvdata(pdev, NULL);
+ err_no_resource:
+	clk_put(dev->clk);
+ err_no_clk:
+	kfree(dev);
+ err_no_devmem:
+	dev_err(&pdev->dev, "failed to add " NAME " adapter: %d\n",
+		pdev->id);
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int stu300_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct stu300_dev *dev = platform_get_drvdata(pdev);
+
+	/* Turn off everything */
+	stu300_wr8(0x00, dev->virtbase + I2C_CR);
+	return 0;
+}
+
+static int stu300_resume(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct stu300_dev *dev = platform_get_drvdata(pdev);
+
+	clk_enable(dev->clk);
+	ret = stu300_init_hw(dev);
+	clk_disable(dev->clk);
+
+	if (ret != 0)
+		dev_err(&pdev->dev, "error re-initializing hardware.\n");
+	return ret;
+}
+#else
+#define stu300_suspend NULL
+#define stu300_resume NULL
+#endif
+
+static int __exit
+stu300_remove(struct platform_device *pdev)
+{
+	struct stu300_dev *dev = platform_get_drvdata(pdev);
+
+	i2c_del_adapter(&dev->adapter);
+	/* Turn off everything */
+	stu300_wr8(0x00, dev->virtbase + I2C_CR);
+	free_irq(dev->irq, dev);
+	iounmap(dev->virtbase);
+	release_mem_region(dev->phybase, dev->physize);
+	clk_put(dev->clk);
+	platform_set_drvdata(pdev, NULL);
+	kfree(dev);
+	return 0;
+}
+
+static struct platform_driver stu300_i2c_driver = {
+	.driver = {
+		.name	= NAME,
+		.owner	= THIS_MODULE,
+	},
+	.remove		= __exit_p(stu300_remove),
+	.suspend        = stu300_suspend,
+	.resume         = stu300_resume,
+
+};
+
+static int __init stu300_init(void)
+{
+	return platform_driver_probe(&stu300_i2c_driver, stu300_probe);
+}
+
+static void __exit stu300_exit(void)
+{
+	platform_driver_unregister(&stu300_i2c_driver);
+}
+
+/*
+ * The systems using this bus often have very basic devices such
+ * as regulators on the I2C bus, so this needs to be loaded early.
+ * Therefore it is registered in the subsys_initcall().
+ */
+subsys_initcall(stu300_init);
+module_exit(stu300_exit);
+
+MODULE_AUTHOR("Linus Walleij <linus.walleij@stericsson.com>");
+MODULE_DESCRIPTION("ST Micro DDC I2C adapter (" NAME ")");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" NAME);
