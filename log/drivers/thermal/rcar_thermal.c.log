commit b03628b73564cf54e05b7611e22d9886a8822877
Author: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
Date:   Thu May 14 17:25:05 2020 +0200

    thermal: rcar_thermal: Clean up rcar_thermal_update_temp()
    
    Moving the ctemp variable out of the private data structure made it
    possible to clean up rcar_thermal_update_temp(). Initialize the local
    ctemp to the error code to return if the reading fails and just return
    it at the end of the function.
    
    It's OK to change the datatype of old, new and ctemp to int as all
    values are ANDed with CTEMP (0x3f) before being stored. While at it
    change the datatype of the loop variable 'i' to to unsigned int.
    
    Suggested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20200514152505.1927634-1-niklas.soderlund+renesas@ragnatech.se

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index e0c1f2409035..46aeb28b4e90 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -198,8 +198,8 @@ static void _rcar_thermal_bset(struct rcar_thermal_priv *priv, u32 reg,
 static int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)
 {
 	struct device *dev = rcar_priv_to_dev(priv);
-	int i;
-	u32 ctemp, old, new;
+	int old, new, ctemp = -EINVAL;
+	unsigned int i;
 
 	mutex_lock(&priv->lock);
 
@@ -209,7 +209,6 @@ static int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)
 	 */
 	rcar_thermal_bset(priv, THSCR, CPCTL, CPCTL);
 
-	ctemp = 0;
 	old = ~0;
 	for (i = 0; i < 128; i++) {
 		/*
@@ -227,7 +226,7 @@ static int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)
 		old = new;
 	}
 
-	if (!ctemp) {
+	if (ctemp < 0) {
 		dev_err(dev, "thermal sensor was broken\n");
 		goto err_out_unlock;
 	}
@@ -248,7 +247,7 @@ static int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)
 err_out_unlock:
 	mutex_unlock(&priv->lock);
 
-	return ctemp ? ctemp : -EINVAL;
+	return ctemp;
 }
 
 static int rcar_thermal_get_current_temp(struct rcar_thermal_priv *priv,

commit 0fa04202078a7dae3a1199bd61951de3d915ede6
Author: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
Date:   Tue Mar 10 18:00:29 2020 +0100

    thermal: rcar_thermal: Remove lock in rcar_thermal_get_current_temp()
    
    With the ctemp value returned instead of cached in the private data
    structure their is no need to take the lock when translating ctemp into
    a temperature.
    
    Signed-off-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20200310170029.1648996-4-niklas.soderlund+renesas@ragnatech.se

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 4a45b314ef30..e0c1f2409035 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -254,24 +254,20 @@ static int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)
 static int rcar_thermal_get_current_temp(struct rcar_thermal_priv *priv,
 					 int *temp)
 {
-	int ctemp, tmp;
+	int ctemp;
 
 	ctemp = rcar_thermal_update_temp(priv);
 	if (ctemp < 0)
 		return ctemp;
 
-	mutex_lock(&priv->lock);
+	/* Guaranteed operating range is -45C to 125C. */
+
 	if (priv->chip->ctemp_bands == 1)
-		tmp = MCELSIUS((ctemp * 5) - 65);
+		*temp = MCELSIUS((ctemp * 5) - 65);
 	else if (ctemp < 24)
-		tmp = MCELSIUS(((ctemp * 55) - 720) / 10);
+		*temp = MCELSIUS(((ctemp * 55) - 720) / 10);
 	else
-		tmp = MCELSIUS((ctemp * 5) - 60);
-	mutex_unlock(&priv->lock);
-
-	/* Guaranteed operating range is -45C to 125C. */
-
-	*temp = tmp;
+		*temp = MCELSIUS((ctemp * 5) - 60);
 
 	return 0;
 }

commit 57ed737f1646579bf77070109c18ea78db690d18
Author: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
Date:   Tue Mar 10 18:00:28 2020 +0100

    thermal: rcar_thermal: Do not store ctemp in rcar_thermal_priv
    
    There is no need to cache the ctemp value in the private data structure
    as it's always prefetched before it's used. Remove it from the structure
    and have rcar_thermal_update_temp return the value instead of storing
    it.
    
    Signed-off-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20200310170029.1648996-3-niklas.soderlund+renesas@ragnatech.se

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index fc54acdb914a..4a45b314ef30 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -95,7 +95,6 @@ struct rcar_thermal_priv {
 	struct mutex lock;
 	struct list_head list;
 	int id;
-	u32 ctemp;
 };
 
 #define rcar_thermal_for_each_priv(pos, common)	\
@@ -201,7 +200,6 @@ static int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)
 	struct device *dev = rcar_priv_to_dev(priv);
 	int i;
 	u32 ctemp, old, new;
-	int ret = -EINVAL;
 
 	mutex_lock(&priv->lock);
 
@@ -247,32 +245,28 @@ static int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)
 						   ((ctemp - 1) << 0)));
 	}
 
-	dev_dbg(dev, "thermal%d  %d -> %d\n", priv->id, priv->ctemp, ctemp);
-
-	priv->ctemp = ctemp;
-	ret = 0;
 err_out_unlock:
 	mutex_unlock(&priv->lock);
-	return ret;
+
+	return ctemp ? ctemp : -EINVAL;
 }
 
 static int rcar_thermal_get_current_temp(struct rcar_thermal_priv *priv,
 					 int *temp)
 {
-	int tmp;
-	int ret;
+	int ctemp, tmp;
 
-	ret = rcar_thermal_update_temp(priv);
-	if (ret < 0)
-		return ret;
+	ctemp = rcar_thermal_update_temp(priv);
+	if (ctemp < 0)
+		return ctemp;
 
 	mutex_lock(&priv->lock);
 	if (priv->chip->ctemp_bands == 1)
-		tmp = MCELSIUS((priv->ctemp * 5) - 65);
-	else if (priv->ctemp < 24)
-		tmp = MCELSIUS(((priv->ctemp * 55) - 720) / 10);
+		tmp = MCELSIUS((ctemp * 5) - 65);
+	else if (ctemp < 24)
+		tmp = MCELSIUS(((ctemp * 55) - 720) / 10);
 	else
-		tmp = MCELSIUS((priv->ctemp * 5) - 60);
+		tmp = MCELSIUS((ctemp * 5) - 60);
 	mutex_unlock(&priv->lock);
 
 	/* Guaranteed operating range is -45C to 125C. */

commit 7617e771c16611b422c43b3b154dce2b3ee152d5
Author: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
Date:   Tue Mar 10 18:00:27 2020 +0100

    thermal: rcar_thermal: Always update thermal zone on interrupt
    
    Since commit a1ade5653804b8eb ("thermal: rcar: check every
    rcar_thermal_update_temp() return value") the temperature is always read
    in rcar_thermal_get_current_temp() so comparing it before and after
    enabling interrupts have little effect. Remove the check and always
    update the thermal zone when we get an interrupt that the temperature
    have changed.
    
    Signed-off-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20200310170029.1648996-2-niklas.soderlund+renesas@ragnatech.se

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 4a48d1d2a31c..fc54acdb914a 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -387,28 +387,17 @@ static void _rcar_thermal_irq_ctrl(struct rcar_thermal_priv *priv, int enable)
 static void rcar_thermal_work(struct work_struct *work)
 {
 	struct rcar_thermal_priv *priv;
-	int cctemp, nctemp;
 	int ret;
 
 	priv = container_of(work, struct rcar_thermal_priv, work.work);
 
-	ret = rcar_thermal_get_current_temp(priv, &cctemp);
-	if (ret < 0)
-		return;
-
 	ret = rcar_thermal_update_temp(priv);
 	if (ret < 0)
 		return;
 
 	rcar_thermal_irq_enable(priv);
 
-	ret = rcar_thermal_get_current_temp(priv, &nctemp);
-	if (ret < 0)
-		return;
-
-	if (nctemp != cctemp)
-		thermal_zone_device_update(priv->zone,
-					   THERMAL_EVENT_UNSPECIFIED);
+	thermal_zone_device_update(priv->zone, THERMAL_EVENT_UNSPECIFIED);
 }
 
 static u32 rcar_thermal_had_changed(struct rcar_thermal_priv *priv, u32 status)

commit 39056e8a989ef52486e063e34b4822b341e47b0e
Author: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
Date:   Tue Mar 10 12:47:09 2020 +0100

    thermal: rcar_thermal: Handle probe error gracefully
    
    If the common register memory resource is not available the driver needs
    to fail gracefully to disable PM. Instead of returning the error
    directly store it in ret and use the already existing error path.
    
    Signed-off-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20200310114709.1483860-1-niklas.soderlund+renesas@ragnatech.se

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 8f1aafa2044e..4a48d1d2a31c 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -521,8 +521,10 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 			res = platform_get_resource(pdev, IORESOURCE_MEM,
 						    mres++);
 			common->base = devm_ioremap_resource(dev, res);
-			if (IS_ERR(common->base))
-				return PTR_ERR(common->base);
+			if (IS_ERR(common->base)) {
+				ret = PTR_ERR(common->base);
+				goto error_unregister;
+			}
 
 			idle = 0; /* polling delay is not needed */
 		}

commit dff6d4f80509d1aaf07da9534f3f4b6876876caf
Author: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
Date:   Fri Jan 17 17:05:53 2020 +0100

    thermal: rcar_thermal: Remove temperature bound
    
    The hardware manual states that the operation of the sensor is not
    guaranteed outside the range of -45°C to 125°C, not that the readings
    are invalid. Remove the bound check and try to deliver temperature
    readings even if we are outside the guaranteed operation range.
    
    Signed-off-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20200117160554.3812787-2-niklas.soderlund+renesas@ragnatech.se

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index a8dd96d2d24c..8f1aafa2044e 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -275,12 +275,7 @@ static int rcar_thermal_get_current_temp(struct rcar_thermal_priv *priv,
 		tmp = MCELSIUS((priv->ctemp * 5) - 60);
 	mutex_unlock(&priv->lock);
 
-	if ((tmp < MCELSIUS(-45)) || (tmp > MCELSIUS(125))) {
-		struct device *dev = rcar_priv_to_dev(priv);
-
-		dev_err(dev, "it couldn't measure temperature correctly\n");
-		return -EIO;
-	}
+	/* Guaranteed operating range is -45C to 125C. */
 
 	*temp = tmp;
 

commit 263c8c4c76d9da63f1f8805ac5fc62a270448301
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Jan 15 13:54:17 2020 +0100

    thermal: rcar_thermal: Use usleep_range() instead of udelay()
    
    rcar_thermal_update_temp() takes a mutex, so it is always called in a
    context that can sleep.  Hence replace the 300 µs busy loop by a call to
    usleep_range(), to allow other threads to run.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20200115125417.5263-1-geert+renesas@glider.be

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index d0873de718da..a8dd96d2d24c 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -219,7 +219,7 @@ static int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)
 		 * to get stable temperature.
 		 * see "Usage Notes" on datasheet
 		 */
-		udelay(300);
+		usleep_range(300, 400);
 
 		new = rcar_thermal_read(priv, THSSR) & CTEMP;
 		if (new == old) {

commit 20386f0d84a22214d1f037dedfffb6709dd0117a
Author: Yoshihiro Kaneko <ykaneko0929@gmail.com>
Date:   Wed May 8 13:08:45 2019 +0200

    thermal: rcar_thermal: update calculation formula for R-Car Gen3 SoCs
    
    Update calculation for the R-Car Gen3 and RZ/G2 SoCs which have a
    thermal IP block controlled by this driver. That is the:
    
    * R-Car D3 (r8a77995)
    * R-Car E2 (r8a77990)
    * R-Car V3M (r8a77970)
    * RZ/G2E (r8a774c0)
    
    The calculation update is as documented in the R-Car Gen3 User's Manual,
    v1.50 Nov 2018:
    
    - When CTEMP is less than 24
       T = CTEMP[5:0] * 5.5 - 72
    - When CTEMP is equal to/greater than 24
       T = CTEMP[5:0] * 5 - 60
    
    This was inspired by a patch in the BSP by Van Do <van.do.xw@renesas.com>
    
    Signed-off-by: Yoshihiro Kaneko <ykaneko0929@gmail.com>
    Tested-by: Simon Horman <horms+renesas@verge.net.au>
    Acked-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 97462e9b40d8..d0873de718da 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -52,6 +52,7 @@ struct rcar_thermal_chip {
 	unsigned int irq_per_ch : 1;
 	unsigned int needs_suspend_resume : 1;
 	unsigned int nirqs;
+	unsigned int ctemp_bands;
 };
 
 static const struct rcar_thermal_chip rcar_thermal = {
@@ -60,6 +61,7 @@ static const struct rcar_thermal_chip rcar_thermal = {
 	.irq_per_ch = 0,
 	.needs_suspend_resume = 0,
 	.nirqs = 1,
+	.ctemp_bands = 1,
 };
 
 static const struct rcar_thermal_chip rcar_gen2_thermal = {
@@ -68,6 +70,7 @@ static const struct rcar_thermal_chip rcar_gen2_thermal = {
 	.irq_per_ch = 0,
 	.needs_suspend_resume = 0,
 	.nirqs = 1,
+	.ctemp_bands = 1,
 };
 
 static const struct rcar_thermal_chip rcar_gen3_thermal = {
@@ -80,6 +83,7 @@ static const struct rcar_thermal_chip rcar_gen3_thermal = {
 	 * interrupts to detect a temperature change, rise or fall.
 	 */
 	.nirqs = 2,
+	.ctemp_bands = 2,
 };
 
 struct rcar_thermal_priv {
@@ -263,7 +267,12 @@ static int rcar_thermal_get_current_temp(struct rcar_thermal_priv *priv,
 		return ret;
 
 	mutex_lock(&priv->lock);
-	tmp =  MCELSIUS((priv->ctemp * 5) - 65);
+	if (priv->chip->ctemp_bands == 1)
+		tmp = MCELSIUS((priv->ctemp * 5) - 65);
+	else if (priv->ctemp < 24)
+		tmp = MCELSIUS(((priv->ctemp * 55) - 720) / 10);
+	else
+		tmp = MCELSIUS((priv->ctemp * 5) - 60);
 	mutex_unlock(&priv->lock);
 
 	if ((tmp < MCELSIUS(-45)) || (tmp > MCELSIUS(125))) {

commit e36e13003efd8b0160d49138385b0cec570900aa
Author: Yoshihiro Kaneko <ykaneko0929@gmail.com>
Date:   Mon Dec 17 23:50:21 2018 +0900

    thermal: rcar_thermal: add R8A77990 support
    
    Add support for R-Car E3 (R8A77990) thermal support.
    
    Signed-off-by: Yoshihiro Kaneko <ykaneko0929@gmail.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 335cfcbce245..97462e9b40d8 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -120,6 +120,10 @@ static const struct of_device_id rcar_thermal_dt_ids[] = {
 		.compatible = "renesas,thermal-r8a77970",
 		.data = &rcar_gen3_thermal,
 	},
+	{
+		.compatible = "renesas,thermal-r8a77990",
+		.data = &rcar_gen3_thermal,
+	},
 	{
 		.compatible = "renesas,thermal-r8a77995",
 		.data = &rcar_gen3_thermal,

commit b8d3d11203afddf9e6c4e8b8ccecd401b6a8cc3e
Author: Fabrizio Castro <fabrizio.castro@bp.renesas.com>
Date:   Thu Dec 13 20:23:10 2018 +0000

    thermal: rcar_thermal: add R8A774C0 support
    
    Add thermal support for the RZ/G2E SoC (a.k.a. R8A774C0).
    
    Signed-off-by: Fabrizio Castro <fabrizio.castro@bp.renesas.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 8014a207d8d9..335cfcbce245 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -112,6 +112,10 @@ static const struct of_device_id rcar_thermal_dt_ids[] = {
 		.compatible = "renesas,rcar-gen2-thermal",
 		 .data = &rcar_gen2_thermal,
 	},
+	{
+		.compatible = "renesas,thermal-r8a774c0",
+		.data = &rcar_gen3_thermal,
+	},
 	{
 		.compatible = "renesas,thermal-r8a77970",
 		.data = &rcar_gen3_thermal,

commit 0ef7791e2bfb2e10aa95dc492eab72074cef9942
Merge: befa93633193 760eea43f8c6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 26 12:04:29 2018 -0700

    Merge branch 'linus' of git://git.kernel.org/pub/scm/linux/kernel/git/evalenti/linux-soc-thermal
    
    Pull thermal SoC updates from Eduardo Valentin:
     "Several new things coming up. Specifics:
    
       - Rework of tsens and hisi thermal drivers
    
       - OF-thermal now allows sharing multiple cooling devices on maps
    
       - Added support for r8a7744 and R8A77970 on rcar thermal driver
    
       - Added support for r8a774a1 on rcar_gen3 thermal driver
    
       - New thermal driver stm32
    
       - Fixes on multiple thermal drivers: of-thermal, imx, qoriq, armada,
         qcom-spmi, rcar, da9062/61"
    
    * 'linus' of git://git.kernel.org/pub/scm/linux/kernel/git/evalenti/linux-soc-thermal: (41 commits)
      thermal: da9062/61: Prevent hardware access during system suspend
      thermal: rcar_thermal: Prevent doing work after unbind
      thermal: rcar_thermal: Prevent hardware access during system suspend
      thermal: rcar_gen3_thermal: add R8A77980 support
      dt-bindings: thermal: rcar-gen3-thermal: document R8A77980 bindings
      thermal: add stm32 thermal driver
      dt-bindings: stm32-thermal: add binding documentation
      thermal: rcar_thermal: add R8A77970 support
      dt-bindings: thermal: rcar-thermal: document R8A77970 bindings
      thermal: rcar_thermal: fix duplicate IRQ request
      dt-bindings: thermal: rcar: Add device tree support for r8a7744
      thermal/drivers/hisi: Add the dual clusters sensors for hi3660
      thermal/drivers/hisi: Add more sensors channel
      thermal/drivers/hisi: Remove pointless irq field
      thermal/drivers/hisi: Use platform_get_irq_byname
      thermal/drivers/hisi: Replace macro name with relevant sensor location
      thermal/drivers/hisi: Add multiple sensors support
      thermal/drivers/hisi: Prepare to support multiple sensors
      thermal/drivers/hisi: Factor out the probe functions
      thermal/drivers/hisi: Set the thermal zone private data to the sensor pointer
      ...

commit 697ee786f15d7b65c7f3045d45fe3a05d28e0911
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Oct 12 09:20:16 2018 +0200

    thermal: rcar_thermal: Prevent doing work after unbind
    
    When testing bind/unbind on r8a7791/koelsch:
    
        WARNING: CPU: 1 PID: 697 at lib/debugobjects.c:329 debug_print_object+0x8c/0xb4
        ODEBUG: free active (active state 0) object type: timer_list hint: delayed_work_timer_fn+0x0/0x10
    
    This happens if the workqueue runs after the device has been unbound.
    Fix this by cancelling any queued work during remove.
    
    Fixes: e0a5172e9eec7f0d ("thermal: rcar: add interrupt support")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index f0e385dd7a92..6d3205819da3 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -469,6 +469,7 @@ static int rcar_thermal_remove(struct platform_device *pdev)
 
 	rcar_thermal_for_each_priv(priv, common) {
 		rcar_thermal_irq_disable(priv);
+		cancel_delayed_work_sync(&priv->work);
 		if (priv->chip->use_of_thermal)
 			thermal_remove_hwmon_sysfs(priv->zone);
 		else

commit 3a31386217628ffe2491695be2db933c25dde785
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Oct 12 09:20:15 2018 +0200

    thermal: rcar_thermal: Prevent hardware access during system suspend
    
    On r8a7791/koelsch, sometimes the following message is printed during
    system suspend:
    
        rcar_thermal e61f0000.thermal: thermal sensor was broken
    
    This happens if the workqueue runs while the device is already
    suspended.  Fix this by using the freezable system workqueue instead,
    cfr. commit 51e20d0e3a60cf46 ("thermal: Prevent polling from happening
    during system suspend").
    
    Fixes: e0a5172e9eec7f0d ("thermal: rcar: add interrupt support")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Niklas Söderlund <niklas.soderlund+renesas@ragnatech.se>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 98f951391dcb..f0e385dd7a92 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -450,8 +450,8 @@ static irqreturn_t rcar_thermal_irq(int irq, void *data)
 	rcar_thermal_for_each_priv(priv, common) {
 		if (rcar_thermal_had_changed(priv, status)) {
 			rcar_thermal_irq_disable(priv);
-			schedule_delayed_work(&priv->work,
-					      msecs_to_jiffies(300));
+			queue_delayed_work(system_freezable_wq, &priv->work,
+					   msecs_to_jiffies(300));
 		}
 	}
 

commit 92ca366e9b835ada0bfe3c663da91ae44d7e8184
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Fri Oct 5 00:03:13 2018 +0300

    thermal: rcar_thermal: add R8A77970 support
    
    Add the R-Car V3M (R8A77970) SoC support to the R-Car gen2 thermal driver.
    The hardware is the same as in the R-Car D3 (R8A77995) plus the CIVM status
    register (we don't use).
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 39366cf69d7f..98f951391dcb 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -124,6 +124,10 @@ static const struct of_device_id rcar_thermal_dt_ids[] = {
 		.compatible = "renesas,rcar-gen2-thermal",
 		 .data = &rcar_gen2_thermal,
 	},
+	{
+		.compatible = "renesas,thermal-r8a77970",
+		.data = &rcar_gen3_thermal,
+	},
 	{
 		.compatible = "renesas,thermal-r8a77995",
 		.data = &rcar_gen3_thermal,

commit df016bbba63743bbef9ff5c6c282561211dd72cc
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Wed Oct 3 23:47:34 2018 +0300

    thermal: rcar_thermal: fix duplicate IRQ request
    
    The driver on R8A77995 requests the same IRQ twice since
    platform_get_resource() is always called for the 1st IRQ resource.
    
    Fixes: 1969d9dc2079 ("thermal: rcar_thermal: add r8a77995 support")
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Reviewed-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index e77e63070e99..39366cf69d7f 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -504,7 +504,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	pm_runtime_get_sync(dev);
 
 	for (i = 0; i < chip->nirqs; i++) {
-		irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+		irq = platform_get_resource(pdev, IORESOURCE_IRQ, i);
 		if (!irq)
 			continue;
 		if (!common->base) {

commit c954579087f4c0185206cfa777e697874b1e7d13
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Jul 30 07:56:06 2018 +0000

    thermal: rcar_thermal: convert to SPDX identifiers
    
    As original license mentioned, it is GPL-2.0 in SPDX.
    Then, MODULE_LICENSE() should be "GPL v2" instead of "GPL".
    See ${LINUX}/include/linux/module.h
    
            "GPL"           [GNU Public License v2 or later]
            "GPL v2"        [GNU Public License v2]
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index e77e63070e99..78f932822d38 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -1,21 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *  R-Car THS/TSC thermal sensor driver
  *
  * Copyright (C) 2012 Renesas Solutions Corp.
  * Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
  */
 #include <linux/delay.h>
 #include <linux/err.h>
@@ -660,6 +648,6 @@ static struct platform_driver rcar_thermal_driver = {
 };
 module_platform_driver(rcar_thermal_driver);
 
-MODULE_LICENSE("GPL");
+MODULE_LICENSE("GPL v2");
 MODULE_DESCRIPTION("R-Car THS/TSC thermal sensor driver");
 MODULE_AUTHOR("Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>");

commit 542cdf4068049458e1411b120bd5a4bbe3ddc49a
Author: Simon Horman <horms+renesas@verge.net.au>
Date:   Tue Jul 24 13:14:13 2018 +0200

    thermal: rcar_thermal: avoid NULL dereference in absence of IRQ resources
    
    Ensure that the base address used by a call to rcar_thermal_common_write()
    may be NULL if the SOC supports interrupts for use with the thermal device
    but none are defined in DT as is the case for R-Car H1 (r8a7779). Guard
    against this condition to prevent a NULL dereference when the device is
    probed.
    
    Tested on:
    * R-Mobile APE6 (r8a73a4) / APE6EVM
    * R-Car H1 (r8a7779) / Marzen
    * R-Car H2 (r8a7790) / Lager
    * R-Car M2-W (r8a7791) / Koelsch
    * R-Car M2-N (r8a7793) / Gose
    * R-Car D3 ES1.0 (r8a77995) / Draak
    
    Fixes: 1969d9dc2079 ("thermal: rcar_thermal: add r8a77995 support")
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 45fb284d4c11..e77e63070e99 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -598,7 +598,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 			enr_bits |= 3 << (i * 8);
 	}
 
-	if (enr_bits)
+	if (common->base && enr_bits)
 		rcar_thermal_common_write(common, ENR, enr_bits);
 
 	dev_info(dev, "%d sensor probed\n", i);

commit 1969d9dc2079e4b551712e9f0c1c69403aee9769
Author: Yoshihiro Kaneko <ykaneko0929@gmail.com>
Date:   Sun May 20 18:26:17 2018 +0900

    thermal: rcar_thermal: add r8a77995 support
    
    Add support for R-Car D3 (r8a77995) thermal sensor.
    
    Signed-off-by: Yoshihiro Kaneko <ykaneko0929@gmail.com>
    Tested-by: Ulrich Hecht <ulrich.hecht+renesas@gmail.com>
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 73e5fee6cf1d..45fb284d4c11 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -58,10 +58,47 @@ struct rcar_thermal_common {
 	spinlock_t lock;
 };
 
+struct rcar_thermal_chip {
+	unsigned int use_of_thermal : 1;
+	unsigned int has_filonoff : 1;
+	unsigned int irq_per_ch : 1;
+	unsigned int needs_suspend_resume : 1;
+	unsigned int nirqs;
+};
+
+static const struct rcar_thermal_chip rcar_thermal = {
+	.use_of_thermal = 0,
+	.has_filonoff = 1,
+	.irq_per_ch = 0,
+	.needs_suspend_resume = 0,
+	.nirqs = 1,
+};
+
+static const struct rcar_thermal_chip rcar_gen2_thermal = {
+	.use_of_thermal = 1,
+	.has_filonoff = 1,
+	.irq_per_ch = 0,
+	.needs_suspend_resume = 0,
+	.nirqs = 1,
+};
+
+static const struct rcar_thermal_chip rcar_gen3_thermal = {
+	.use_of_thermal = 1,
+	.has_filonoff = 0,
+	.irq_per_ch = 1,
+	.needs_suspend_resume = 1,
+	/*
+	 * The Gen3 chip has 3 interrupts, but this driver uses only 2
+	 * interrupts to detect a temperature change, rise or fall.
+	 */
+	.nirqs = 2,
+};
+
 struct rcar_thermal_priv {
 	void __iomem *base;
 	struct rcar_thermal_common *common;
 	struct thermal_zone_device *zone;
+	const struct rcar_thermal_chip *chip;
 	struct delayed_work work;
 	struct mutex lock;
 	struct list_head list;
@@ -77,13 +114,20 @@ struct rcar_thermal_priv {
 #define rcar_priv_to_dev(priv)		((priv)->common->dev)
 #define rcar_has_irq_support(priv)	((priv)->common->base)
 #define rcar_id_to_shift(priv)		((priv)->id * 8)
-#define rcar_of_data(dev)		((unsigned long)of_device_get_match_data(dev))
-#define rcar_use_of_thermal(dev)	(rcar_of_data(dev) == USE_OF_THERMAL)
 
-#define USE_OF_THERMAL	1
 static const struct of_device_id rcar_thermal_dt_ids[] = {
-	{ .compatible = "renesas,rcar-thermal", },
-	{ .compatible = "renesas,rcar-gen2-thermal", .data = (void *)USE_OF_THERMAL },
+	{
+		.compatible = "renesas,rcar-thermal",
+		.data = &rcar_thermal,
+	},
+	{
+		.compatible = "renesas,rcar-gen2-thermal",
+		 .data = &rcar_gen2_thermal,
+	},
+	{
+		.compatible = "renesas,thermal-r8a77995",
+		.data = &rcar_gen3_thermal,
+	},
 	{},
 };
 MODULE_DEVICE_TABLE(of, rcar_thermal_dt_ids);
@@ -190,7 +234,8 @@ static int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)
 	 * enable IRQ
 	 */
 	if (rcar_has_irq_support(priv)) {
-		rcar_thermal_write(priv, FILONOFF, 0);
+		if (priv->chip->has_filonoff)
+			rcar_thermal_write(priv, FILONOFF, 0);
 
 		/* enable Rising/Falling edge interrupt */
 		rcar_thermal_write(priv, POSNEG,  0x1);
@@ -420,7 +465,7 @@ static int rcar_thermal_remove(struct platform_device *pdev)
 
 	rcar_thermal_for_each_priv(priv, common) {
 		rcar_thermal_irq_disable(priv);
-		if (rcar_use_of_thermal(dev))
+		if (priv->chip->use_of_thermal)
 			thermal_remove_hwmon_sysfs(priv->zone);
 		else
 			thermal_zone_device_unregister(priv->zone);
@@ -438,6 +483,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	struct rcar_thermal_priv *priv;
 	struct device *dev = &pdev->dev;
 	struct resource *res, *irq;
+	const struct rcar_thermal_chip *chip = of_device_get_match_data(dev);
 	int mres = 0;
 	int i;
 	int ret = -ENODEV;
@@ -457,19 +503,35 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	pm_runtime_enable(dev);
 	pm_runtime_get_sync(dev);
 
-	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if (irq) {
-		/*
-		 * platform has IRQ support.
-		 * Then, driver uses common registers
-		 * rcar_has_irq_support() will be enabled
-		 */
-		res = platform_get_resource(pdev, IORESOURCE_MEM, mres++);
-		common->base = devm_ioremap_resource(dev, res);
-		if (IS_ERR(common->base))
-			return PTR_ERR(common->base);
+	for (i = 0; i < chip->nirqs; i++) {
+		irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+		if (!irq)
+			continue;
+		if (!common->base) {
+			/*
+			 * platform has IRQ support.
+			 * Then, driver uses common registers
+			 * rcar_has_irq_support() will be enabled
+			 */
+			res = platform_get_resource(pdev, IORESOURCE_MEM,
+						    mres++);
+			common->base = devm_ioremap_resource(dev, res);
+			if (IS_ERR(common->base))
+				return PTR_ERR(common->base);
+
+			idle = 0; /* polling delay is not needed */
+		}
 
-		idle = 0; /* polling delay is not needed */
+		ret = devm_request_irq(dev, irq->start, rcar_thermal_irq,
+				       IRQF_SHARED, dev_name(dev), common);
+		if (ret) {
+			dev_err(dev, "irq request failed\n ");
+			goto error_unregister;
+		}
+
+		/* update ENR bits */
+		if (chip->irq_per_ch)
+			enr_bits |= 1 << i;
 	}
 
 	for (i = 0;; i++) {
@@ -491,6 +553,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 
 		priv->common = common;
 		priv->id = i;
+		priv->chip = chip;
 		mutex_init(&priv->lock);
 		INIT_LIST_HEAD(&priv->list);
 		INIT_DELAYED_WORK(&priv->work, rcar_thermal_work);
@@ -498,7 +561,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 		if (ret < 0)
 			goto error_unregister;
 
-		if (rcar_use_of_thermal(dev))
+		if (chip->use_of_thermal)
 			priv->zone = devm_thermal_zone_of_sensor_register(
 						dev, i, priv,
 						&rcar_thermal_zone_of_ops);
@@ -515,7 +578,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 			goto error_unregister;
 		}
 
-		if (rcar_use_of_thermal(dev)) {
+		if (chip->use_of_thermal) {
 			/*
 			 * thermal_zone doesn't enable hwmon as default,
 			 * but, enable it here to keep compatible
@@ -531,20 +594,12 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 		list_move_tail(&priv->list, &common->head);
 
 		/* update ENR bits */
-		enr_bits |= 3 << (i * 8);
+		if (!chip->irq_per_ch)
+			enr_bits |= 3 << (i * 8);
 	}
 
-	/* enable temperature comparation */
-	if (irq) {
-		ret = devm_request_irq(dev, irq->start, rcar_thermal_irq, 0,
-				       dev_name(dev), common);
-		if (ret) {
-			dev_err(dev, "irq request failed\n ");
-			goto error_unregister;
-		}
-
+	if (enr_bits)
 		rcar_thermal_common_write(common, ENR, enr_bits);
-	}
 
 	dev_info(dev, "%d sensor probed\n", i);
 
@@ -556,9 +611,48 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	return ret;
 }
 
+#ifdef CONFIG_PM_SLEEP
+static int rcar_thermal_suspend(struct device *dev)
+{
+	struct rcar_thermal_common *common = dev_get_drvdata(dev);
+	struct rcar_thermal_priv *priv = list_first_entry(&common->head,
+							  typeof(*priv), list);
+
+	if (priv->chip->needs_suspend_resume) {
+		rcar_thermal_common_write(common, ENR, 0);
+		rcar_thermal_irq_disable(priv);
+		rcar_thermal_bset(priv, THSCR, CPCTL, 0);
+	}
+
+	return 0;
+}
+
+static int rcar_thermal_resume(struct device *dev)
+{
+	struct rcar_thermal_common *common = dev_get_drvdata(dev);
+	struct rcar_thermal_priv *priv = list_first_entry(&common->head,
+							  typeof(*priv), list);
+	int ret;
+
+	if (priv->chip->needs_suspend_resume) {
+		ret = rcar_thermal_update_temp(priv);
+		if (ret < 0)
+			return ret;
+		rcar_thermal_irq_enable(priv);
+		rcar_thermal_common_write(common, ENR, 0x03);
+	}
+
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(rcar_thermal_pm_ops, rcar_thermal_suspend,
+			 rcar_thermal_resume);
+
 static struct platform_driver rcar_thermal_driver = {
 	.driver	= {
 		.name	= "rcar_thermal",
+		.pm = &rcar_thermal_pm_ops,
 		.of_match_table = rcar_thermal_dt_ids,
 	},
 	.probe		= rcar_thermal_probe,

commit 2d2474a194652f55c7af51068db3c1b851f16711
Merge: 084165a3f8c8 43720df96023
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Oct 12 11:05:23 2016 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux
    
    Pull thermal managament updates from Zhang Rui:
    
     - Enhance thermal "userspace" governor to export the reason when a
       thermal event is triggered and delivered to user space. From Srinivas
       Pandruvada
    
     - Introduce a single TSENS thermal driver for the different versions of
       the TSENS IP that exist, on different qcom msm/apq SoCs'. Support for
       msm8916, msm8960, msm8974 and msm8996 families is also added. From
       Rajendra Nayak
    
     - Introduce hardware-tracked trip points support to the device tree
       thermal sensor framework. The framework supports an arbitrary number
       of trip points. Whenever the current temperature is changed, the trip
       points immediately below and above the current temperature are found,
       driver callback is invoked to program the hardware to get notified
       when either of the two trip points are triggered. Hardware-tracked
       trip points support for rockchip thermal driver is also added at the
       same time. From Sascha Hauer, Caesar Wang
    
     - Introduce a new thermal driver, which enables TMU (Thermal Monitor
       Unit) on QorIQ platform. From Jia Hongtao
    
     - Introduce a new thermal driver for Maxim MAX77620. From Laxman
       Dewangan
    
     - Introduce a new thermal driver for Intel platforms using WhiskeyCove
       PMIC. From Bin Gao
    
     - Add mt2701 chip support to MTK thermal driver. From Dawei Chien
    
     - Enhance Tegra thermal driver to enable soctherm node and set
       "critical", "hot" trips, for Tegra124, Tegra132, Tegra210. From Wei
       Ni
    
     - Add resume support for tango thermal driver. From Marc Gonzalez
    
     - several small fixes and improvements for rockchip, qcom, imx, rcar,
       mtk thermal drivers and thermal core code. From Caesar Wang, Keerthy,
       Rocky Hao, Wei Yongjun, Peter Robinson, Bui Duc Phuc, Axel Lin, Hugh
       Kang
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux: (48 commits)
      thermal: int3403: Process trip change notification
      thermal: int340x: New Interface to read trip and notify
      thermal: user_space gov: Add additional information in uevent
      thermal: Enhance thermal_zone_device_update for events
      arm64: tegra: set hot trips for Tegra210
      arm64: tegra: set critical trips for Tegra210
      arm64: tegra: add soctherm node for Tegra210
      arm64: tegra: set hot trips for Tegra132
      arm64: tegra: set critical trips for Tegra132
      arm64: tegra: use tegra132-soctherm for Tegra132
      arm: tegra: set hot trips for Tegra124
      arm: tegra: set critical trips for Tegra124
      thermal: tegra: add hw-throttle for Tegra132
      thermal: tegra: add hw-throttle function
      of: Add bindings of hw throttle for Tegra soctherm
      thermal: mtk_thermal: Check return value of devm_thermal_zone_of_sensor_register
      thermal: Add Mediatek thermal driver for mt2701.
      dt-bindings: thermal: Add binding document for Mediatek thermal controller
      thermal: max77620: Add thermal driver for reporting junction temp
      thermal: max77620: Add DT binding doc for thermal driver
      ...

commit 0e70f466fb910ae54c4c71243b99385129e93feb
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Fri Aug 26 16:21:16 2016 -0700

    thermal: Enhance thermal_zone_device_update for events
    
    Added one additional parameter to thermal_zone_device_update() to provide
    caller with an optional capability to specify reason.
    Currently this event is used by user space governor to trigger different
    processing based on event code. Also it saves an additional call to read
    temperature when the event is received.
    The following events are cuurently defined:
    - Unspecified event
    - New temperature sample
    - Trip point violated
    - Trip point changed
    - thermal device up and down
    - thermal device power capability changed
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index b5c6442d82d6..6c73d3ecf33b 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -358,7 +358,8 @@ static void rcar_thermal_work(struct work_struct *work)
 		return;
 
 	if (nctemp != cctemp)
-		thermal_zone_device_update(priv->zone);
+		thermal_zone_device_update(priv->zone,
+					   THERMAL_EVENT_UNSPECIFIED);
 }
 
 static u32 rcar_thermal_had_changed(struct rcar_thermal_priv *priv, u32 status)

commit d4b23c5c434a7af053782cc0f9eebee51ec71bb2
Author: Bui Duc Phuc <bd-phuc@jinso.co.jp>
Date:   Mon Aug 22 03:19:49 2016 +0000

    thermal: rcar_thermal: don't call thermal_zone_device_unregister when USE_OF_THERMAL
    
    devm_thermal_zone_of_sensor_register() case doesn't need to call
    thermal_zone_device_unregister().
    Otherwise, rcar-thermal can't register thermal zone again after rebind.
    This patch fixes it.
    
    Signed-off-by: Bui Duc Phuc <bd-phuc@jinso.co.jp>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 4d07644da649..b5c6442d82d6 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -419,9 +419,10 @@ static int rcar_thermal_remove(struct platform_device *pdev)
 
 	rcar_thermal_for_each_priv(priv, common) {
 		rcar_thermal_irq_disable(priv);
-		thermal_zone_device_unregister(priv->zone);
 		if (rcar_use_of_thermal(dev))
 			thermal_remove_hwmon_sysfs(priv->zone);
+		else
+			thermal_zone_device_unregister(priv->zone);
 	}
 
 	pm_runtime_put(dev);

commit 64a411e8042ed00057658000126fd9f2b4105bdd
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Jul 19 10:01:37 2016 +0000

    thermal: rcar-thermal: enable hwmon when thermal_zone_of_sensor_register is used
    
    rcar-thermal is supporting both thermal_zone_of_sensor_register() and
    thermal_zone_device_register(). But thermal_zone_of_sensor_register()
    doesn't enable hwmon as default.
    This patch enables it to keep compatibility
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 71a339271fa5..4d07644da649 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -31,6 +31,8 @@
 #include <linux/spinlock.h>
 #include <linux/thermal.h>
 
+#include "thermal_hwmon.h"
+
 #define IDLE_INTERVAL	5000
 
 #define COMMON_STR	0x00
@@ -75,6 +77,8 @@ struct rcar_thermal_priv {
 #define rcar_priv_to_dev(priv)		((priv)->common->dev)
 #define rcar_has_irq_support(priv)	((priv)->common->base)
 #define rcar_id_to_shift(priv)		((priv)->id * 8)
+#define rcar_of_data(dev)		((unsigned long)of_device_get_match_data(dev))
+#define rcar_use_of_thermal(dev)	(rcar_of_data(dev) == USE_OF_THERMAL)
 
 #define USE_OF_THERMAL	1
 static const struct of_device_id rcar_thermal_dt_ids[] = {
@@ -416,6 +420,8 @@ static int rcar_thermal_remove(struct platform_device *pdev)
 	rcar_thermal_for_each_priv(priv, common) {
 		rcar_thermal_irq_disable(priv);
 		thermal_zone_device_unregister(priv->zone);
+		if (rcar_use_of_thermal(dev))
+			thermal_remove_hwmon_sysfs(priv->zone);
 	}
 
 	pm_runtime_put(dev);
@@ -430,7 +436,6 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	struct rcar_thermal_priv *priv;
 	struct device *dev = &pdev->dev;
 	struct resource *res, *irq;
-	unsigned long of_data = (unsigned long)of_device_get_match_data(dev);
 	int mres = 0;
 	int i;
 	int ret = -ENODEV;
@@ -491,7 +496,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 		if (ret < 0)
 			goto error_unregister;
 
-		if (of_data == USE_OF_THERMAL)
+		if (rcar_use_of_thermal(dev))
 			priv->zone = devm_thermal_zone_of_sensor_register(
 						dev, i, priv,
 						&rcar_thermal_zone_of_ops);
@@ -507,6 +512,17 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 			goto error_unregister;
 		}
 
+		if (rcar_use_of_thermal(dev)) {
+			/*
+			 * thermal_zone doesn't enable hwmon as default,
+			 * but, enable it here to keep compatible
+			 */
+			priv->zone->tzp->no_hwmon = false;
+			ret = thermal_add_hwmon_sysfs(priv->zone);
+			if (ret)
+				goto error_unregister;
+		}
+
 		rcar_thermal_irq_enable(priv);
 
 		list_move_tail(&priv->list, &common->head);

commit 87260d3f7aecba9a5fadc6886c338b2a8fccfca9
Author: Dirk Behme <dirk.behme@de.bosch.com>
Date:   Thu Apr 21 12:24:55 2016 +0200

    thermal: rcar_thermal: Fix priv->zone error handling
    
    In case thermal_zone_xxx_register() returns an error, priv->zone
    isn't NULL any more, but contains the error code.
    
    This is passed to thermal_zone_device_unregister(), then. This checks
    for priv->zone being NULL, but the error code is != NULL. So it works
    with the error code as a pointer. Crashing immediately.
    
    To fix this, reset priv->zone to NULL before entering
    rcar_gen3_thermal_remove().
    
    Signed-off-by: Dirk Behme <dirk.behme@de.bosch.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 71a339271fa5..5f817923f374 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -504,6 +504,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 		if (IS_ERR(priv->zone)) {
 			dev_err(dev, "can't register thermal zone\n");
 			ret = PTR_ERR(priv->zone);
+			priv->zone = NULL;
 			goto error_unregister;
 		}
 

commit 5e325868aa59d3c743aa1c9526f386f30c234cd7
Author: Eduardo Valentin <edubezval@gmail.com>
Date:   Wed Mar 9 13:09:43 2016 -0800

    thermal: convert rcar_thermal to use devm_thermal_zone_of_sensor_register
    
    This changes the driver to use the devm_ version
    of thermal_zone_of_sensor_register and cleans
    up the  local points and unregister calls.
    
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: linux-pm@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 82daba09e150..71a339271fa5 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -492,7 +492,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 			goto error_unregister;
 
 		if (of_data == USE_OF_THERMAL)
-			priv->zone = thermal_zone_of_sensor_register(
+			priv->zone = devm_thermal_zone_of_sensor_register(
 						dev, i, priv,
 						&rcar_thermal_zone_of_ops);
 		else

commit 67bc3f4226c1d29ee820eff98fcaf8a9283938fe
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Tue Mar 1 17:38:31 2016 +0100

    thermal: rcar_thermal: don't open code of_device_get_match_data()
    
    This change will also make Coverity happy by avoiding a theoretical NULL
    pointer dereference; yet another reason is to use the above helper function
    to tighten the code and make it more readable.
    
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 0e735acea33a..82daba09e150 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -430,8 +430,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	struct rcar_thermal_priv *priv;
 	struct device *dev = &pdev->dev;
 	struct resource *res, *irq;
-	const struct of_device_id *of_id = of_match_device(rcar_thermal_dt_ids, dev);
-	unsigned long of_data = (unsigned long)of_id->data;
+	unsigned long of_data = (unsigned long)of_device_get_match_data(dev);
 	int mres = 0;
 	int i;
 	int ret = -ENODEV;

commit 8b477ea56383dc8b838f1f8b506e4571c14ceb30
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 28 02:45:08 2016 +0000

    thermal: rcar: enable to use thermal-zone on DT
    
    This patch enables to use thermal-zone on DT if it was calles as
    "renesas,rcar-thermal-gen2".
    Previous style (= non thermal-zone) is still supported by
    "renesas,rcar-thermal" to keep compatibility for "git bisect".
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 44b9c485157d..0e735acea33a 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -23,6 +23,7 @@
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/module.h>
+#include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/reboot.h>
@@ -75,8 +76,10 @@ struct rcar_thermal_priv {
 #define rcar_has_irq_support(priv)	((priv)->common->base)
 #define rcar_id_to_shift(priv)		((priv)->id * 8)
 
+#define USE_OF_THERMAL	1
 static const struct of_device_id rcar_thermal_dt_ids[] = {
 	{ .compatible = "renesas,rcar-thermal", },
+	{ .compatible = "renesas,rcar-gen2-thermal", .data = (void *)USE_OF_THERMAL },
 	{},
 };
 MODULE_DEVICE_TABLE(of, rcar_thermal_dt_ids);
@@ -200,9 +203,9 @@ static int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)
 	return ret;
 }
 
-static int rcar_thermal_get_temp(struct thermal_zone_device *zone, int *temp)
+static int rcar_thermal_get_current_temp(struct rcar_thermal_priv *priv,
+					 int *temp)
 {
-	struct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);
 	int tmp;
 	int ret;
 
@@ -226,6 +229,20 @@ static int rcar_thermal_get_temp(struct thermal_zone_device *zone, int *temp)
 	return 0;
 }
 
+static int rcar_thermal_of_get_temp(void *data, int *temp)
+{
+	struct rcar_thermal_priv *priv = data;
+
+	return rcar_thermal_get_current_temp(priv, temp);
+}
+
+static int rcar_thermal_get_temp(struct thermal_zone_device *zone, int *temp)
+{
+	struct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);
+
+	return rcar_thermal_get_current_temp(priv, temp);
+}
+
 static int rcar_thermal_get_trip_type(struct thermal_zone_device *zone,
 				      int trip, enum thermal_trip_type *type)
 {
@@ -282,6 +299,10 @@ static int rcar_thermal_notify(struct thermal_zone_device *zone,
 	return 0;
 }
 
+static const struct thermal_zone_of_device_ops rcar_thermal_zone_of_ops = {
+	.get_temp	= rcar_thermal_of_get_temp,
+};
+
 static struct thermal_zone_device_ops rcar_thermal_zone_ops = {
 	.get_temp	= rcar_thermal_get_temp,
 	.get_trip_type	= rcar_thermal_get_trip_type,
@@ -318,14 +339,20 @@ static void rcar_thermal_work(struct work_struct *work)
 
 	priv = container_of(work, struct rcar_thermal_priv, work.work);
 
-	rcar_thermal_get_temp(priv->zone, &cctemp);
+	ret = rcar_thermal_get_current_temp(priv, &cctemp);
+	if (ret < 0)
+		return;
+
 	ret = rcar_thermal_update_temp(priv);
 	if (ret < 0)
 		return;
 
 	rcar_thermal_irq_enable(priv);
 
-	rcar_thermal_get_temp(priv->zone, &nctemp);
+	ret = rcar_thermal_get_current_temp(priv, &nctemp);
+	if (ret < 0)
+		return;
+
 	if (nctemp != cctemp)
 		thermal_zone_device_update(priv->zone);
 }
@@ -403,6 +430,8 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	struct rcar_thermal_priv *priv;
 	struct device *dev = &pdev->dev;
 	struct resource *res, *irq;
+	const struct of_device_id *of_id = of_match_device(rcar_thermal_dt_ids, dev);
+	unsigned long of_data = (unsigned long)of_id->data;
 	int mres = 0;
 	int i;
 	int ret = -ENODEV;
@@ -463,7 +492,13 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 		if (ret < 0)
 			goto error_unregister;
 
-		priv->zone = thermal_zone_device_register("rcar_thermal",
+		if (of_data == USE_OF_THERMAL)
+			priv->zone = thermal_zone_of_sensor_register(
+						dev, i, priv,
+						&rcar_thermal_zone_of_ops);
+		else
+			priv->zone = thermal_zone_device_register(
+						"rcar_thermal",
 						1, 0, priv,
 						&rcar_thermal_zone_ops, NULL, 0,
 						idle);

commit 5440c40b900fa561add48a7e70e9c892f0551387
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 15 01:18:13 2015 +0000

    thermal: rcar: rcar_thermal_get_temp() return error if strange temp
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index fb81fd7e6b81..44b9c485157d 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -203,6 +203,7 @@ static int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)
 static int rcar_thermal_get_temp(struct thermal_zone_device *zone, int *temp)
 {
 	struct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);
+	int tmp;
 	int ret;
 
 	ret = rcar_thermal_update_temp(priv);
@@ -210,9 +211,18 @@ static int rcar_thermal_get_temp(struct thermal_zone_device *zone, int *temp)
 		return ret;
 
 	mutex_lock(&priv->lock);
-	*temp =  MCELSIUS((priv->ctemp * 5) - 65);
+	tmp =  MCELSIUS((priv->ctemp * 5) - 65);
 	mutex_unlock(&priv->lock);
 
+	if ((tmp < MCELSIUS(-45)) || (tmp > MCELSIUS(125))) {
+		struct device *dev = rcar_priv_to_dev(priv);
+
+		dev_err(dev, "it couldn't measure temperature correctly\n");
+		return -EIO;
+	}
+
+	*temp = tmp;
+
 	return 0;
 }
 

commit ffbcdf8a759c6dde71c6c4f646a552f7637bcca7
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 15 01:17:56 2015 +0000

    thermal: rcar: check irq possibility in rcar_thermal_irq_xxx()
    
    Current rcar thermal driver sometimes checks irq possibility when it
    calls rcar_thermal_irq_enable/disable(), but sometimes not.
    This patch checks it inside rcar_thermal_irq_enable/disable().
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index b012d900c3f2..fb81fd7e6b81 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -290,6 +290,9 @@ static void _rcar_thermal_irq_ctrl(struct rcar_thermal_priv *priv, int enable)
 	unsigned long flags;
 	u32 mask = 0x3 << rcar_id_to_shift(priv); /* enable Rising/Falling */
 
+	if (!rcar_has_irq_support(priv))
+		return;
+
 	spin_lock_irqsave(&common->lock, flags);
 
 	rcar_thermal_common_bset(common, INTMSK, mask, enable ? 0 : mask);
@@ -374,8 +377,7 @@ static int rcar_thermal_remove(struct platform_device *pdev)
 	struct rcar_thermal_priv *priv;
 
 	rcar_thermal_for_each_priv(priv, common) {
-		if (rcar_has_irq_support(priv))
-			rcar_thermal_irq_disable(priv);
+		rcar_thermal_irq_disable(priv);
 		thermal_zone_device_unregister(priv->zone);
 	}
 
@@ -461,8 +463,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 			goto error_unregister;
 		}
 
-		if (rcar_has_irq_support(priv))
-			rcar_thermal_irq_enable(priv);
+		rcar_thermal_irq_enable(priv);
 
 		list_move_tail(&priv->list, &common->head);
 

commit a1ade5653804b8eb9d14c5ba964da6d5c2f4cd30
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 15 01:17:40 2015 +0000

    thermal: rcar: check every rcar_thermal_update_temp() return value
    
    Every rcar_thermal_update_temp() return value will be checked.
    
    And also, rcar_thermal_get_temp() always call
    rcar_thermal_update_temp() by this patch.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 96707a6abd7f..b012d900c3f2 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -75,12 +75,6 @@ struct rcar_thermal_priv {
 #define rcar_has_irq_support(priv)	((priv)->common->base)
 #define rcar_id_to_shift(priv)		((priv)->id * 8)
 
-#ifdef DEBUG
-# define rcar_force_update_temp(priv)	1
-#else
-# define rcar_force_update_temp(priv)	0
-#endif
-
 static const struct of_device_id rcar_thermal_dt_ids[] = {
 	{ .compatible = "renesas,rcar-thermal", },
 	{},
@@ -209,9 +203,11 @@ static int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)
 static int rcar_thermal_get_temp(struct thermal_zone_device *zone, int *temp)
 {
 	struct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);
+	int ret;
 
-	if (!rcar_has_irq_support(priv) || rcar_force_update_temp(priv))
-		rcar_thermal_update_temp(priv);
+	ret = rcar_thermal_update_temp(priv);
+	if (ret < 0)
+		return ret;
 
 	mutex_lock(&priv->lock);
 	*temp =  MCELSIUS((priv->ctemp * 5) - 65);
@@ -305,11 +301,15 @@ static void rcar_thermal_work(struct work_struct *work)
 {
 	struct rcar_thermal_priv *priv;
 	int cctemp, nctemp;
+	int ret;
 
 	priv = container_of(work, struct rcar_thermal_priv, work.work);
 
 	rcar_thermal_get_temp(priv->zone, &cctemp);
-	rcar_thermal_update_temp(priv);
+	ret = rcar_thermal_update_temp(priv);
+	if (ret < 0)
+		return;
+
 	rcar_thermal_irq_enable(priv);
 
 	rcar_thermal_get_temp(priv->zone, &nctemp);
@@ -447,7 +447,9 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 		mutex_init(&priv->lock);
 		INIT_LIST_HEAD(&priv->list);
 		INIT_DELAYED_WORK(&priv->work, rcar_thermal_work);
-		rcar_thermal_update_temp(priv);
+		ret = rcar_thermal_update_temp(priv);
+		if (ret < 0)
+			goto error_unregister;
 
 		priv->zone = thermal_zone_device_register("rcar_thermal",
 						1, 0, priv,

commit ca1e4558fcca68a5ac2a4e0f7834f788f9f4ac8f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Dec 15 01:17:07 2015 +0000

    thermal: rcar: move rcar_thermal_dt_ids to upside
    
    This patch is prepare for of-thermal support.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 13d01edc7a04..96707a6abd7f 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -81,6 +81,12 @@ struct rcar_thermal_priv {
 # define rcar_force_update_temp(priv)	0
 #endif
 
+static const struct of_device_id rcar_thermal_dt_ids[] = {
+	{ .compatible = "renesas,rcar-thermal", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rcar_thermal_dt_ids);
+
 /*
  *		basic functions
  */
@@ -484,12 +490,6 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static const struct of_device_id rcar_thermal_dt_ids[] = {
-	{ .compatible = "renesas,rcar-thermal", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, rcar_thermal_dt_ids);
-
 static struct platform_driver rcar_thermal_driver = {
 	.driver	= {
 		.name	= "rcar_thermal",

commit 84f0e490bee0684bd00c8ee02b15487d58bcea9f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Nov 10 02:12:06 2015 +0000

    thermal: rcar_thermal: remove redundant operation
    
    Probe error operation and remove operation are same.
    Let's use same function.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 5d4ae7d705e0..13d01edc7a04 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -361,6 +361,24 @@ static irqreturn_t rcar_thermal_irq(int irq, void *data)
 /*
  *		platform functions
  */
+static int rcar_thermal_remove(struct platform_device *pdev)
+{
+	struct rcar_thermal_common *common = platform_get_drvdata(pdev);
+	struct device *dev = &pdev->dev;
+	struct rcar_thermal_priv *priv;
+
+	rcar_thermal_for_each_priv(priv, common) {
+		if (rcar_has_irq_support(priv))
+			rcar_thermal_irq_disable(priv);
+		thermal_zone_device_unregister(priv->zone);
+	}
+
+	pm_runtime_put(dev);
+	pm_runtime_disable(dev);
+
+	return 0;
+}
+
 static int rcar_thermal_probe(struct platform_device *pdev)
 {
 	struct rcar_thermal_common *common;
@@ -377,6 +395,8 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	if (!common)
 		return -ENOMEM;
 
+	platform_set_drvdata(pdev, common);
+
 	INIT_LIST_HEAD(&common->head);
 	spin_lock_init(&common->lock);
 	common->dev = dev;
@@ -454,43 +474,16 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 		rcar_thermal_common_write(common, ENR, enr_bits);
 	}
 
-	platform_set_drvdata(pdev, common);
-
 	dev_info(dev, "%d sensor probed\n", i);
 
 	return 0;
 
 error_unregister:
-	rcar_thermal_for_each_priv(priv, common) {
-		if (rcar_has_irq_support(priv))
-			rcar_thermal_irq_disable(priv);
-		thermal_zone_device_unregister(priv->zone);
-	}
-
-	pm_runtime_put(dev);
-	pm_runtime_disable(dev);
+	rcar_thermal_remove(pdev);
 
 	return ret;
 }
 
-static int rcar_thermal_remove(struct platform_device *pdev)
-{
-	struct rcar_thermal_common *common = platform_get_drvdata(pdev);
-	struct device *dev = &pdev->dev;
-	struct rcar_thermal_priv *priv;
-
-	rcar_thermal_for_each_priv(priv, common) {
-		if (rcar_has_irq_support(priv))
-			rcar_thermal_irq_disable(priv);
-		thermal_zone_device_unregister(priv->zone);
-	}
-
-	pm_runtime_put(dev);
-	pm_runtime_disable(dev);
-
-	return 0;
-}
-
 static const struct of_device_id rcar_thermal_dt_ids[] = {
 	{ .compatible = "renesas,rcar-thermal", },
 	{},

commit 17e8351a77397e8a83727eb17e3a3e9b8ab5257a
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Fri Jul 24 08:12:54 2015 +0200

    thermal: consistently use int for temperatures
    
    The thermal code uses int, long and unsigned long for temperatures
    in different places.
    
    Using an unsigned type limits the thermal framework to positive
    temperatures without need. Also several drivers currently will report
    temperatures near UINT_MAX for temperatures below 0°C. This will probably
    immediately shut the machine down due to overtemperature if started below
    0°C.
    
    'long' is 64bit on several architectures. This is not needed since INT_MAX °mC
    is above the melting point of all known materials.
    
    Consistently use a plain 'int' for temperatures throughout the thermal code and
    the drivers. This only changes the places in the drivers where the temperature
    is passed around as pointer, when drivers internally use another type this is
    not changed.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Jean Delvare <jdelvare@suse.de>
    Reviewed-by: Lukasz Majewski <l.majewski@samsung.com>
    Reviewed-by: Darren Hart <dvhart@linux.intel.com>
    Reviewed-by: Heiko Stuebner <heiko@sntech.de>
    Reviewed-by: Peter Feuerer <peter@piie.net>
    Cc: Punit Agrawal <punit.agrawal@arm.com>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: Eduardo Valentin <edubezval@gmail.com>
    Cc: linux-pm@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: Jean Delvare <jdelvare@suse.de>
    Cc: Peter Feuerer <peter@piie.net>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Lukasz Majewski <l.majewski@samsung.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: linux-acpi@vger.kernel.org
    Cc: platform-driver-x86@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-omap@vger.kernel.org
    Cc: linux-samsung-soc@vger.kernel.org
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Darren Hart <dvhart@infradead.org>
    Cc: lm-sensors@lm-sensors.org
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index fe4e767018c4..5d4ae7d705e0 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -200,8 +200,7 @@ static int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)
 	return ret;
 }
 
-static int rcar_thermal_get_temp(struct thermal_zone_device *zone,
-				 unsigned long *temp)
+static int rcar_thermal_get_temp(struct thermal_zone_device *zone, int *temp)
 {
 	struct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);
 
@@ -235,7 +234,7 @@ static int rcar_thermal_get_trip_type(struct thermal_zone_device *zone,
 }
 
 static int rcar_thermal_get_trip_temp(struct thermal_zone_device *zone,
-				      int trip, unsigned long *temp)
+				      int trip, int *temp)
 {
 	struct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);
 	struct device *dev = rcar_priv_to_dev(priv);
@@ -299,7 +298,7 @@ static void _rcar_thermal_irq_ctrl(struct rcar_thermal_priv *priv, int enable)
 static void rcar_thermal_work(struct work_struct *work)
 {
 	struct rcar_thermal_priv *priv;
-	unsigned long cctemp, nctemp;
+	int cctemp, nctemp;
 
 	priv = container_of(work, struct rcar_thermal_priv, work.work);
 

commit ac71c7025ebc1ed25114b1be77dc60b7f8cb8544
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Feb 23 16:37:25 2015 +0100

    thermal: rcar: Make error and remove paths symmetrical with init
    
    Swap interrupt disable and thermal zone unregistration in the error and
    remove paths, to make them more symmetrical with the initialization
    path.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 3c2c1720ba4a..fe4e767018c4 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -463,9 +463,9 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 
 error_unregister:
 	rcar_thermal_for_each_priv(priv, common) {
-		thermal_zone_device_unregister(priv->zone);
 		if (rcar_has_irq_support(priv))
 			rcar_thermal_irq_disable(priv);
+		thermal_zone_device_unregister(priv->zone);
 	}
 
 	pm_runtime_put(dev);
@@ -481,9 +481,9 @@ static int rcar_thermal_remove(struct platform_device *pdev)
 	struct rcar_thermal_priv *priv;
 
 	rcar_thermal_for_each_priv(priv, common) {
-		thermal_zone_device_unregister(priv->zone);
 		if (rcar_has_irq_support(priv))
 			rcar_thermal_irq_disable(priv);
+		thermal_zone_device_unregister(priv->zone);
 	}
 
 	pm_runtime_put(dev);

commit 0b37a83a91e885250c68546ce7271ce722120c99
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Feb 23 16:37:24 2015 +0100

    thermal: rcar: Fix race condition between init and interrupt
    
    As soon as the interrupt has been enabled by devm_request_irq(), the
    interrupt routine may be called, depending on the current status of the
    hardware.
    
    However, at that point rcar_thermal_common hasn't been initialized
    complely yet. E.g. rcar_thermal_common.base is still NULL, causing a
    NULL pointer dereference:
    
        Unable to handle kernel NULL pointer dereference at virtual address 0000000c
        pgd = c0004000
        [0000000c] *pgd=00000000
        Internal error: Oops: 5 [#1] SMP ARM
        CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.19.0-rc7-ape6evm-04564-gb6e46cb7cbe82389 #30
        Hardware name: Generic R8A73A4 (Flattened Device Tree)
        task: ee8953c0 ti: ee896000 task.ti: ee896000
        PC is at rcar_thermal_irq+0x1c/0xf0
        LR is at _raw_spin_lock_irqsave+0x48/0x54
    
    Postpone the call to devm_request_irq() until all initialization has
    been done to fix this.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 2580a4872f90..3c2c1720ba4a 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -387,21 +387,9 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 
 	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if (irq) {
-		int ret;
-
 		/*
 		 * platform has IRQ support.
 		 * Then, driver uses common registers
-		 */
-
-		ret = devm_request_irq(dev, irq->start, rcar_thermal_irq, 0,
-				       dev_name(dev), common);
-		if (ret) {
-			dev_err(dev, "irq request failed\n ");
-			return ret;
-		}
-
-		/*
 		 * rcar_has_irq_support() will be enabled
 		 */
 		res = platform_get_resource(pdev, IORESOURCE_MEM, mres++);
@@ -456,8 +444,16 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	}
 
 	/* enable temperature comparation */
-	if (irq)
+	if (irq) {
+		ret = devm_request_irq(dev, irq->start, rcar_thermal_irq, 0,
+				       dev_name(dev), common);
+		if (ret) {
+			dev_err(dev, "irq request failed\n ");
+			goto error_unregister;
+		}
+
 		rcar_thermal_common_write(common, ENR, enr_bits);
+	}
 
 	platform_set_drvdata(pdev, common);
 

commit ee853addd9fedb116bd34a18f11dd5959fcf0428
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Jan 12 17:33:59 2015 +0100

    thermal: rcar: Spelling/grammar: s/drier use .../driver uses ...s/
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 70bb02c24e82..2580a4872f90 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -391,7 +391,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 
 		/*
 		 * platform has IRQ support.
-		 * Then, drier use common register
+		 * Then, driver uses common registers
 		 */
 
 		ret = devm_request_irq(dev, irq->start, rcar_thermal_irq, 0,

commit 913015c6df9a18ad27365afed6f409c024002aab
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Wed Jan 7 10:13:11 2015 +0900

    thermal: rcar: change type of ctemp in rcar_thermal_update_temp()
    
    Since the ctemp is used for rcar_thermal_write() in
    rcar_thermal_update_temp(), the type of 'ctemp' should be "u32" instead
    of "int". This patch also changes type of the helper variables 'old'
    and 'new'.
    
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 2f3b4ff5b9d1..70bb02c24e82 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -63,7 +63,7 @@ struct rcar_thermal_priv {
 	struct mutex lock;
 	struct list_head list;
 	int id;
-	int ctemp;
+	u32 ctemp;
 };
 
 #define rcar_thermal_for_each_priv(pos, common)	\
@@ -145,7 +145,7 @@ static int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)
 {
 	struct device *dev = rcar_priv_to_dev(priv);
 	int i;
-	int ctemp, old, new;
+	u32 ctemp, old, new;
 	int ret = -EINVAL;
 
 	mutex_lock(&priv->lock);

commit 11313746547015ace605c4c347a40350753051e4
Author: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Date:   Wed Jan 7 10:13:10 2015 +0900

    thermal: rcar: fix ENR register value
    
    On R-Mobile APE6, since it has 3 thermal zones, ENR register
    has enable bits in bit 19-16, bit 11-8 and bit 3-0.
    
    However, on R-Car gen2, since it has 1 thermal zone, ENR register has
    enable bits in bit 3-0. (In other words, the write value should always
    be 0 for bit 31-4 of ENR register.)
    
    So, this patch fixes the ENR register value using I/O resource sets.
    
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 8803e693fe68..2f3b4ff5b9d1 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -372,6 +372,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	int i;
 	int ret = -ENODEV;
 	int idle = IDLE_INTERVAL;
+	u32 enr_bits = 0;
 
 	common = devm_kzalloc(dev, sizeof(*common), GFP_KERNEL);
 	if (!common)
@@ -408,9 +409,6 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 		if (IS_ERR(common->base))
 			return PTR_ERR(common->base);
 
-		/* enable temperature comparation */
-		rcar_thermal_common_write(common, ENR, 0x00030303);
-
 		idle = 0; /* polling delay is not needed */
 	}
 
@@ -452,8 +450,15 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 			rcar_thermal_irq_enable(priv);
 
 		list_move_tail(&priv->list, &common->head);
+
+		/* update ENR bits */
+		enr_bits |= 3 << (i * 8);
 	}
 
+	/* enable temperature comparation */
+	if (irq)
+		rcar_thermal_common_write(common, ENR, enr_bits);
+
 	platform_set_drvdata(pdev, common);
 
 	dev_info(dev, "%d sensor probed\n", i);

commit b0a60d88d60b92c769ec589796403937f6e5243e
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Wed May 7 15:03:25 2014 +0900

    thermal: rcar: remove unnecessary OOM messages
    
    The site-specific OOM messages are unnecessary, because they
    duplicate the MM subsystem generic OOM message.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index a8ed0e0265ae..8803e693fe68 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -374,10 +374,8 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	int idle = IDLE_INTERVAL;
 
 	common = devm_kzalloc(dev, sizeof(*common), GFP_KERNEL);
-	if (!common) {
-		dev_err(dev, "Could not allocate common\n");
+	if (!common)
 		return -ENOMEM;
-	}
 
 	INIT_LIST_HEAD(&common->head);
 	spin_lock_init(&common->lock);
@@ -423,7 +421,6 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 
 		priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
 		if (!priv) {
-			dev_err(dev, "Could not allocate priv\n");
 			ret = -ENOMEM;
 			goto error_unregister;
 		}

commit 09be511cdab813c2971c9f9af0cb40f6583cf80d
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Apr 14 19:02:55 2014 +0200

    thermal: rcar: Use pm_runtime_put() i.s.o. pm_runtime_put_sync()
    
    There's no need for this to be synchronous
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 5a37940b02c9..a8ed0e0265ae 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -470,7 +470,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 			rcar_thermal_irq_disable(priv);
 	}
 
-	pm_runtime_put_sync(dev);
+	pm_runtime_put(dev);
 	pm_runtime_disable(dev);
 
 	return ret;
@@ -488,7 +488,7 @@ static int rcar_thermal_remove(struct platform_device *pdev)
 			rcar_thermal_irq_disable(priv);
 	}
 
-	pm_runtime_put_sync(dev);
+	pm_runtime_put(dev);
 	pm_runtime_disable(dev);
 
 	return 0;

commit 9477165ec525d47abb1cb6523698e0cd89d65ddb
Author: Patrick Titiano <ptitiano@baylibre.com>
Date:   Fri Feb 28 14:10:04 2014 +0100

    thermal: rcar-thermal: update thermal zone only when temperature changes
    
    Avoid updating the thermal zone in case an IRQ was triggered but the
    temperature didn't effectively change.
    Note this is not a driver issue.
    Below is a captured debug trace illustrating the purpose of this patch:
    out of 8 thermal zone updates, only 2 are actually necessary.
    
    [   41.120000] rcar_thermal_work(): cctemp=25000
    [   41.120000] rcar_thermal_work(): nctemp=30000
    [   41.120000] rcar_thermal_work(): temp is now 30000C, update thermal zone
    [   58.990000] rcar_thermal_work(): cctemp=30000
    [   58.990000] rcar_thermal_work(): nctemp=30000
    [   58.990000] rcar_thermal_work(): same temp, do not update thermal zone
    [   59.290000] rcar_thermal_work(): cctemp=30000
    [   59.290000] rcar_thermal_work(): nctemp=30000
    [   59.290000] rcar_thermal_work(): same temp, do not update thermal zone
    [   59.590000] rcar_thermal_work(): cctemp=30000
    [   59.590000] rcar_thermal_work(): nctemp=30000
    [   59.590000] rcar_thermal_work(): same temp, do not update thermal zone
    [   59.890000] rcar_thermal_work(): cctemp=30000
    [   59.890000] rcar_thermal_work(): nctemp=30000
    [   59.890000] rcar_thermal_work(): same temp, do not update thermal zone
    [   60.190000] rcar_thermal_work(): cctemp=30000
    [   60.190000] rcar_thermal_work(): nctemp=30000
    [   60.190000] rcar_thermal_work(): same temp, do not update thermal zone
    [   60.490000] rcar_thermal_work(): cctemp=30000
    [   60.490000] rcar_thermal_work(): nctemp=30000
    [   60.490000] rcar_thermal_work(): same temp, do not update thermal zone
    [   60.790000] rcar_thermal_work(): cctemp=30000
    [   60.790000] rcar_thermal_work(): nctemp=35000
    [   60.790000] rcar_thermal_work(): temp is now 35000C, update thermal zone
    
    I suspect this may be due to sensor sampling accuracy / fluctuation,
    but no formal proof.
    
    Signed-off-by: Patrick Titiano <ptitiano@baylibre.com>
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 88cfeec6a28f..5a37940b02c9 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -299,12 +299,17 @@ static void _rcar_thermal_irq_ctrl(struct rcar_thermal_priv *priv, int enable)
 static void rcar_thermal_work(struct work_struct *work)
 {
 	struct rcar_thermal_priv *priv;
+	unsigned long cctemp, nctemp;
 
 	priv = container_of(work, struct rcar_thermal_priv, work.work);
 
+	rcar_thermal_get_temp(priv->zone, &cctemp);
 	rcar_thermal_update_temp(priv);
 	rcar_thermal_irq_enable(priv);
-	thermal_zone_device_update(priv->zone);
+
+	rcar_thermal_get_temp(priv->zone, &nctemp);
+	if (nctemp != cctemp)
+		thermal_zone_device_update(priv->zone);
 }
 
 static u32 rcar_thermal_had_changed(struct rcar_thermal_priv *priv, u32 status)

commit 206c0cba095acbb91d552d220207d690c9b29594
Author: Patrick Titiano <ptitiano@baylibre.com>
Date:   Fri Feb 28 14:10:03 2014 +0100

    thermal: rcar-thermal: fix same mask applied twice
    
    Mask is already applied preceding the if statement.
    Remove the second mask.
    
    Signed-off-by: Patrick Titiano <ptitiano@baylibre.com>
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 79a09d02bbca..88cfeec6a28f 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -313,7 +313,7 @@ static u32 rcar_thermal_had_changed(struct rcar_thermal_priv *priv, u32 status)
 
 	status = (status >> rcar_id_to_shift(priv)) & 0x3;
 
-	if (status & 0x3) {
+	if (status) {
 		dev_dbg(dev, "thermal%d %s%s\n",
 			priv->id,
 			(status & 0x2) ? "Rising " : "",

commit 6fe495e0f80ebe98e311006e6ab491643340917f
Author: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
Date:   Tue Jan 7 19:57:16 2014 +0100

    thermal: rcar: comment spelling
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 88f92e1a9944..79a09d02bbca 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -408,7 +408,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 		/* enable temperature comparation */
 		rcar_thermal_common_write(common, ENR, 0x00030303);
 
-		idle = 0; /* polling delaye is not needed */
+		idle = 0; /* polling delay is not needed */
 	}
 
 	for (i = 0;; i++) {

commit e7cd7886ef0478aaab23f445e2e8cd6e0e6bdd73
Merge: 5454f211ddc2 a1cf1150f127 c21bec86b6e3 794b2e2548ec
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue May 28 10:46:46 2013 +0800

    Merge branches 'misc', 'drv_cleanup', 'devm-cleanup' and 'ti-soc' of .git into next

commit 3db46c939677e32e311d354b619fd552ceafd123
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Tue May 14 23:00:32 2013 +0000

    thermal: rcar: Fix typo in probe information message
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Acked-by: Eduardo Valentin <eduardo.valentin@ti.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 8d7edd4c8228..3eaca06df617 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -458,7 +458,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, common);
 
-	dev_info(dev, "%d sensor proved\n", i);
+	dev_info(dev, "%d sensor probed\n", i);
 
 	return 0;
 

commit c28f692c6f5a836dc628fb6990fb4d3d1859f779
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Fri May 10 08:17:11 2013 +0000

    drivers/thermal: don't check resource with devm_ioremap_resource
    
    devm_ioremap_resource does sanity checks on the given resource. No need to
    duplicate this in the driver.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Eduardo Valentin <eduardo.valentin@ti.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 8d7edd4c8228..72f50bc0456c 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -389,11 +389,6 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 		 * platform has IRQ support.
 		 * Then, drier use common register
 		 */
-		res = platform_get_resource(pdev, IORESOURCE_MEM, mres++);
-		if (!res) {
-			dev_err(dev, "Could not get platform resource\n");
-			return -ENODEV;
-		}
 
 		ret = devm_request_irq(dev, irq->start, rcar_thermal_irq, 0,
 				       dev_name(dev), common);
@@ -405,6 +400,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 		/*
 		 * rcar_has_irq_support() will be enabled
 		 */
+		res = platform_get_resource(pdev, IORESOURCE_MEM, mres++);
 		common->base = devm_ioremap_resource(dev, res);
 		if (IS_ERR(common->base))
 			return PTR_ERR(common->base);

commit 6135ba36f44069ad789bd9f8d6a75eebc3946eba
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Fri May 3 09:57:12 2013 +0000

    Thermal: rcar: Remove redundant platform_set_drvdata()
    
    Commit 0998d06310 (device-core: Ensure drvdata = NULL when no
    driver is bound) removes the need to set driver data field to
    NULL.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Acked-by: Eduardo Valentin <eduardo.valentin@ti.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 8d7edd4c8228..63c7c13d79f3 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -487,8 +487,6 @@ static int rcar_thermal_remove(struct platform_device *pdev)
 			rcar_thermal_irq_disable(priv);
 	}
 
-	platform_set_drvdata(pdev, NULL);
-
 	pm_runtime_put_sync(dev);
 	pm_runtime_disable(dev);
 

commit 51d45d25948bdf7422958b92a2d91dc703b1a4cc
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Mar 26 06:08:52 2013 +0000

    thermal: rcar: add pm_runtime_xxx() support
    
    Current rcar_thermal() didn't care about own power.
    Without this patch, rcar_thermal doesn't work on APE6 board
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 4d6095b9f9df..8d7edd4c8228 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -24,6 +24,7 @@
 #include <linux/io.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
 #include <linux/reboot.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
@@ -377,6 +378,9 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	spin_lock_init(&common->lock);
 	common->dev = dev;
 
+	pm_runtime_enable(dev);
+	pm_runtime_get_sync(dev);
+
 	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if (irq) {
 		int ret;
@@ -465,12 +469,16 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 			rcar_thermal_irq_disable(priv);
 	}
 
+	pm_runtime_put_sync(dev);
+	pm_runtime_disable(dev);
+
 	return ret;
 }
 
 static int rcar_thermal_remove(struct platform_device *pdev)
 {
 	struct rcar_thermal_common *common = platform_get_drvdata(pdev);
+	struct device *dev = &pdev->dev;
 	struct rcar_thermal_priv *priv;
 
 	rcar_thermal_for_each_priv(priv, common) {
@@ -481,6 +489,9 @@ static int rcar_thermal_remove(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, NULL);
 
+	pm_runtime_put_sync(dev);
+	pm_runtime_disable(dev);
+
 	return 0;
 }
 

commit 1dc20828e674a781635286072bae909dc4e5c377
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Mar 26 06:08:10 2013 +0000

    thermal: rcar: tidyup registration failure case
    
    Current rcar_thermal driver didn't care about rcar_theraml_irq_disable()
    when registration failure case on _probe(), and _remove().
    And, it returns without unregistering thermal zone when
    registration failure case on _probe().
    This patch fixes these issue.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 2cc5b6115e3e..4d6095b9f9df 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -419,12 +419,15 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 		priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
 		if (!priv) {
 			dev_err(dev, "Could not allocate priv\n");
-			return -ENOMEM;
+			ret = -ENOMEM;
+			goto error_unregister;
 		}
 
 		priv->base = devm_ioremap_resource(dev, res);
-		if (IS_ERR(priv->base))
-			return PTR_ERR(priv->base);
+		if (IS_ERR(priv->base)) {
+			ret = PTR_ERR(priv->base);
+			goto error_unregister;
+		}
 
 		priv->common = common;
 		priv->id = i;
@@ -443,10 +446,10 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 			goto error_unregister;
 		}
 
-		list_move_tail(&priv->list, &common->head);
-
 		if (rcar_has_irq_support(priv))
 			rcar_thermal_irq_enable(priv);
+
+		list_move_tail(&priv->list, &common->head);
 	}
 
 	platform_set_drvdata(pdev, common);
@@ -456,8 +459,11 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	return 0;
 
 error_unregister:
-	rcar_thermal_for_each_priv(priv, common)
+	rcar_thermal_for_each_priv(priv, common) {
 		thermal_zone_device_unregister(priv->zone);
+		if (rcar_has_irq_support(priv))
+			rcar_thermal_irq_disable(priv);
+	}
 
 	return ret;
 }
@@ -467,8 +473,11 @@ static int rcar_thermal_remove(struct platform_device *pdev)
 	struct rcar_thermal_common *common = platform_get_drvdata(pdev);
 	struct rcar_thermal_priv *priv;
 
-	rcar_thermal_for_each_priv(priv, common)
+	rcar_thermal_for_each_priv(priv, common) {
 		thermal_zone_device_unregister(priv->zone);
+		if (rcar_has_irq_support(priv))
+			rcar_thermal_irq_disable(priv);
+	}
 
 	platform_set_drvdata(pdev, NULL);
 

commit fb84d9907f0ff0e3f7d70d55039ddf0f78d2a472
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Mon Mar 4 16:52:47 2013 +0000

    thermal: rcar_thermal: propagate return value of thermal_zone_device_register
    
    thermal_zone_device_register returns a value contained in the pointer itself
    use PTR_ERR to obtain the address and return it at the end.
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index ab518140207d..2cc5b6115e3e 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -364,6 +364,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	struct resource *res, *irq;
 	int mres = 0;
 	int i;
+	int ret = -ENODEV;
 	int idle = IDLE_INTERVAL;
 
 	common = devm_kzalloc(dev, sizeof(*common), GFP_KERNEL);
@@ -438,6 +439,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 						idle);
 		if (IS_ERR(priv->zone)) {
 			dev_err(dev, "can't register thermal zone\n");
+			ret = PTR_ERR(priv->zone);
 			goto error_unregister;
 		}
 
@@ -457,7 +459,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	rcar_thermal_for_each_priv(priv, common)
 		thermal_zone_device_unregister(priv->zone);
 
-	return -ENODEV;
+	return ret;
 }
 
 static int rcar_thermal_remove(struct platform_device *pdev)

commit 5095526faf38472bf04af919797a1f01a0ccb558
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Mon Mar 4 06:45:33 2013 +0000

    Thermal: rcar: Convert to devm_ioremap_resource()
    
    Use the newly introduced devm_ioremap_resource() instead of
    devm_request_and_ioremap() which provides more consistent error handling.
    
    devm_ioremap_resource() provides its own error messages; so all explicit
    error messages can be removed from the failure code paths.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Reviewed-by: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 04a5566b1723..ab518140207d 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -400,11 +400,9 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 		/*
 		 * rcar_has_irq_support() will be enabled
 		 */
-		common->base = devm_request_and_ioremap(dev, res);
-		if (!common->base) {
-			dev_err(dev, "Unable to ioremap thermal register\n");
-			return -ENOMEM;
-		}
+		common->base = devm_ioremap_resource(dev, res);
+		if (IS_ERR(common->base))
+			return PTR_ERR(common->base);
 
 		/* enable temperature comparation */
 		rcar_thermal_common_write(common, ENR, 0x00030303);
@@ -423,11 +421,9 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 			return -ENOMEM;
 		}
 
-		priv->base = devm_request_and_ioremap(dev, res);
-		if (!priv->base) {
-			dev_err(dev, "Unable to ioremap priv register\n");
-			return -ENOMEM;
-		}
+		priv->base = devm_ioremap_resource(dev, res);
+		if (IS_ERR(priv->base))
+			return PTR_ERR(priv->base);
 
 		priv->common = common;
 		priv->id = i;

commit f0e68fc3caf677e834f7bd0f601800e686b56c98
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Fri Feb 22 13:22:39 2013 +0000

    thermal: rcar: fix missing unlock on error in rcar_thermal_update_temp()
    
    Add the missing unlock before return from function rcar_thermal_update_temp()
    in the error handling case.
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Acked-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 28f091994013..04a5566b1723 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -145,6 +145,7 @@ static int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)
 	struct device *dev = rcar_priv_to_dev(priv);
 	int i;
 	int ctemp, old, new;
+	int ret = -EINVAL;
 
 	mutex_lock(&priv->lock);
 
@@ -174,7 +175,7 @@ static int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)
 
 	if (!ctemp) {
 		dev_err(dev, "thermal sensor was broken\n");
-		return -EINVAL;
+		goto err_out_unlock;
 	}
 
 	/*
@@ -192,10 +193,10 @@ static int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)
 	dev_dbg(dev, "thermal%d  %d -> %d\n", priv->id, priv->ctemp, ctemp);
 
 	priv->ctemp = ctemp;
-
+	ret = 0;
+err_out_unlock:
 	mutex_unlock(&priv->lock);
-
-	return 0;
+	return ret;
 }
 
 static int rcar_thermal_get_temp(struct thermal_zone_device *zone,

commit f5b6d45f8cf688f51140fd21f1da3b90562762a9
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Feb 14 23:26:58 2013 +0100

    thermal: rcar: remove __devinitconst
    
    commit 76cc18874 "thermal: rcar: add Device Tree support"
    added device tree support for this driver, but also added
    an instance of __devinitconst, which is no longer defined
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 909bb4bb837f..28f091994013 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -476,7 +476,7 @@ static int rcar_thermal_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static const struct of_device_id rcar_thermal_dt_ids[] __devinitconst = {
+static const struct of_device_id rcar_thermal_dt_ids[] = {
 	{ .compatible = "renesas,rcar-thermal", },
 	{},
 };

commit 76cc1887496fe80138c6b07c37d7f81e4cf27cde
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 31 09:05:26 2013 +0000

    thermal: rcar: add Device Tree support
    
    Support for loading the Renesas R-Car thermal module via devicetree.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 2eebcadb4c99..909bb4bb837f 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -476,9 +476,16 @@ static int rcar_thermal_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct of_device_id rcar_thermal_dt_ids[] __devinitconst = {
+	{ .compatible = "renesas,rcar-thermal", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rcar_thermal_dt_ids);
+
 static struct platform_driver rcar_thermal_driver = {
 	.driver	= {
 		.name	= "rcar_thermal",
+		.of_match_table = rcar_thermal_dt_ids,
 	},
 	.probe		= rcar_thermal_probe,
 	.remove		= rcar_thermal_remove,

commit e6e053f4e47634c07993cb31893556d24e18b65e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 31 09:26:13 2013 +0000

    thermal: rcar: remove machine_power_off() from rcar_thermal_notify()
    
    Machine/System power-off is run in thermal frame work if
    it become critical temperature.
    This patch removed pointless machine_power_off()
    from thermal_zone_device_ops :: .notify
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 80aae3cf65eb..2eebcadb4c99 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -261,7 +261,6 @@ static int rcar_thermal_notify(struct thermal_zone_device *zone,
 	case THERMAL_TRIP_CRITICAL:
 		/* FIXME */
 		dev_warn(dev, "Thermal reached to critical temperature\n");
-		machine_power_off();
 		break;
 	default:
 		break;

commit e0a5172e9eec7f0d3c476e013c51dab62f3fc666
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 31 09:04:48 2013 +0000

    thermal: rcar: add interrupt support
    
    This patch adds interrupt support for R-Car thermal driver.
    
    New generation R-Car thermal sensor interrupt controller was
    different from old generation.
    This patch supports new generation sensor only,
    since the old generation interrupt controller had never been used before,
    and will never be used in the future.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index cf6aa98956b9..80aae3cf65eb 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -19,6 +19,8 @@
  */
 #include <linux/delay.h>
 #include <linux/err.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
@@ -29,8 +31,15 @@
 
 #define IDLE_INTERVAL	5000
 
+#define COMMON_STR	0x00
+#define COMMON_ENR	0x04
+#define COMMON_INTMSK	0x0c
+
+#define REG_POSNEG	0x20
+#define REG_FILONOFF	0x28
 #define REG_THSCR	0x2c
 #define REG_THSSR	0x30
+#define REG_INTCTRL	0x34
 
 /* THSCR */
 #define CPCTL	(1 << 12)
@@ -42,14 +51,18 @@ struct rcar_thermal_common {
 	void __iomem *base;
 	struct device *dev;
 	struct list_head head;
+	spinlock_t lock;
 };
 
 struct rcar_thermal_priv {
 	void __iomem *base;
 	struct rcar_thermal_common *common;
 	struct thermal_zone_device *zone;
+	struct delayed_work work;
 	struct mutex lock;
 	struct list_head list;
+	int id;
+	int ctemp;
 };
 
 #define rcar_thermal_for_each_priv(pos, common)	\
@@ -59,11 +72,17 @@ struct rcar_thermal_priv {
 #define rcar_zone_to_priv(zone)		((zone)->devdata)
 #define rcar_priv_to_dev(priv)		((priv)->common->dev)
 #define rcar_has_irq_support(priv)	((priv)->common->base)
+#define rcar_id_to_shift(priv)		((priv)->id * 8)
+
+#ifdef DEBUG
+# define rcar_force_update_temp(priv)	1
+#else
+# define rcar_force_update_temp(priv)	0
+#endif
 
 /*
  *		basic functions
  */
-#if 0
 #define rcar_thermal_common_read(c, r) \
 	_rcar_thermal_common_read(c, COMMON_ ##r)
 static u32 _rcar_thermal_common_read(struct rcar_thermal_common *common,
@@ -92,7 +111,6 @@ static void _rcar_thermal_common_bset(struct rcar_thermal_common *common,
 	val |= (data & mask);
 	iowrite32(val, common->base + reg);
 }
-#endif
 
 #define rcar_thermal_read(p, r) _rcar_thermal_read(p, REG_ ##r)
 static u32 _rcar_thermal_read(struct rcar_thermal_priv *priv, u32 reg)
@@ -100,14 +118,12 @@ static u32 _rcar_thermal_read(struct rcar_thermal_priv *priv, u32 reg)
 	return ioread32(priv->base + reg);
 }
 
-#if 0 /* no user at this point */
 #define rcar_thermal_write(p, r, d) _rcar_thermal_write(p, REG_ ##r, d)
 static void _rcar_thermal_write(struct rcar_thermal_priv *priv,
 				u32 reg, u32 data)
 {
 	iowrite32(data, priv->base + reg);
 }
-#endif
 
 #define rcar_thermal_bset(p, r, m, d) _rcar_thermal_bset(p, REG_ ##r, m, d)
 static void _rcar_thermal_bset(struct rcar_thermal_priv *priv, u32 reg,
@@ -124,10 +140,8 @@ static void _rcar_thermal_bset(struct rcar_thermal_priv *priv, u32 reg,
 /*
  *		zone device functions
  */
-static int rcar_thermal_get_temp(struct thermal_zone_device *zone,
-			   unsigned long *temp)
+static int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)
 {
-	struct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);
 	struct device *dev = rcar_priv_to_dev(priv);
 	int i;
 	int ctemp, old, new;
@@ -163,13 +177,42 @@ static int rcar_thermal_get_temp(struct thermal_zone_device *zone,
 		return -EINVAL;
 	}
 
-	*temp = MCELSIUS((ctemp * 5) - 65);
+	/*
+	 * enable IRQ
+	 */
+	if (rcar_has_irq_support(priv)) {
+		rcar_thermal_write(priv, FILONOFF, 0);
+
+		/* enable Rising/Falling edge interrupt */
+		rcar_thermal_write(priv, POSNEG,  0x1);
+		rcar_thermal_write(priv, INTCTRL, (((ctemp - 0) << 8) |
+						   ((ctemp - 1) << 0)));
+	}
+
+	dev_dbg(dev, "thermal%d  %d -> %d\n", priv->id, priv->ctemp, ctemp);
+
+	priv->ctemp = ctemp;
 
 	mutex_unlock(&priv->lock);
 
 	return 0;
 }
 
+static int rcar_thermal_get_temp(struct thermal_zone_device *zone,
+				 unsigned long *temp)
+{
+	struct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);
+
+	if (!rcar_has_irq_support(priv) || rcar_force_update_temp(priv))
+		rcar_thermal_update_temp(priv);
+
+	mutex_lock(&priv->lock);
+	*temp =  MCELSIUS((priv->ctemp * 5) - 65);
+	mutex_unlock(&priv->lock);
+
+	return 0;
+}
+
 static int rcar_thermal_get_trip_type(struct thermal_zone_device *zone,
 				      int trip, enum thermal_trip_type *type)
 {
@@ -234,6 +277,82 @@ static struct thermal_zone_device_ops rcar_thermal_zone_ops = {
 	.notify		= rcar_thermal_notify,
 };
 
+/*
+ *		interrupt
+ */
+#define rcar_thermal_irq_enable(p)	_rcar_thermal_irq_ctrl(p, 1)
+#define rcar_thermal_irq_disable(p)	_rcar_thermal_irq_ctrl(p, 0)
+static void _rcar_thermal_irq_ctrl(struct rcar_thermal_priv *priv, int enable)
+{
+	struct rcar_thermal_common *common = priv->common;
+	unsigned long flags;
+	u32 mask = 0x3 << rcar_id_to_shift(priv); /* enable Rising/Falling */
+
+	spin_lock_irqsave(&common->lock, flags);
+
+	rcar_thermal_common_bset(common, INTMSK, mask, enable ? 0 : mask);
+
+	spin_unlock_irqrestore(&common->lock, flags);
+}
+
+static void rcar_thermal_work(struct work_struct *work)
+{
+	struct rcar_thermal_priv *priv;
+
+	priv = container_of(work, struct rcar_thermal_priv, work.work);
+
+	rcar_thermal_update_temp(priv);
+	rcar_thermal_irq_enable(priv);
+	thermal_zone_device_update(priv->zone);
+}
+
+static u32 rcar_thermal_had_changed(struct rcar_thermal_priv *priv, u32 status)
+{
+	struct device *dev = rcar_priv_to_dev(priv);
+
+	status = (status >> rcar_id_to_shift(priv)) & 0x3;
+
+	if (status & 0x3) {
+		dev_dbg(dev, "thermal%d %s%s\n",
+			priv->id,
+			(status & 0x2) ? "Rising " : "",
+			(status & 0x1) ? "Falling" : "");
+	}
+
+	return status;
+}
+
+static irqreturn_t rcar_thermal_irq(int irq, void *data)
+{
+	struct rcar_thermal_common *common = data;
+	struct rcar_thermal_priv *priv;
+	unsigned long flags;
+	u32 status, mask;
+
+	spin_lock_irqsave(&common->lock, flags);
+
+	mask	= rcar_thermal_common_read(common, INTMSK);
+	status	= rcar_thermal_common_read(common, STR);
+	rcar_thermal_common_write(common, STR, 0x000F0F0F & mask);
+
+	spin_unlock_irqrestore(&common->lock, flags);
+
+	status = status & ~mask;
+
+	/*
+	 * check the status
+	 */
+	rcar_thermal_for_each_priv(priv, common) {
+		if (rcar_thermal_had_changed(priv, status)) {
+			rcar_thermal_irq_disable(priv);
+			schedule_delayed_work(&priv->work,
+					      msecs_to_jiffies(300));
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
 /*
  *		platform functions
  */
@@ -245,6 +364,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	struct resource *res, *irq;
 	int mres = 0;
 	int i;
+	int idle = IDLE_INTERVAL;
 
 	common = devm_kzalloc(dev, sizeof(*common), GFP_KERNEL);
 	if (!common) {
@@ -253,10 +373,13 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	}
 
 	INIT_LIST_HEAD(&common->head);
+	spin_lock_init(&common->lock);
 	common->dev = dev;
 
 	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if (irq) {
+		int ret;
+
 		/*
 		 * platform has IRQ support.
 		 * Then, drier use common register
@@ -267,6 +390,13 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 			return -ENODEV;
 		}
 
+		ret = devm_request_irq(dev, irq->start, rcar_thermal_irq, 0,
+				       dev_name(dev), common);
+		if (ret) {
+			dev_err(dev, "irq request failed\n ");
+			return ret;
+		}
+
 		/*
 		 * rcar_has_irq_support() will be enabled
 		 */
@@ -275,6 +405,11 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 			dev_err(dev, "Unable to ioremap thermal register\n");
 			return -ENOMEM;
 		}
+
+		/* enable temperature comparation */
+		rcar_thermal_common_write(common, ENR, 0x00030303);
+
+		idle = 0; /* polling delaye is not needed */
 	}
 
 	for (i = 0;; i++) {
@@ -295,19 +430,25 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 		}
 
 		priv->common = common;
+		priv->id = i;
 		mutex_init(&priv->lock);
 		INIT_LIST_HEAD(&priv->list);
+		INIT_DELAYED_WORK(&priv->work, rcar_thermal_work);
+		rcar_thermal_update_temp(priv);
 
 		priv->zone = thermal_zone_device_register("rcar_thermal",
 						1, 0, priv,
 						&rcar_thermal_zone_ops, NULL, 0,
-						IDLE_INTERVAL);
+						idle);
 		if (IS_ERR(priv->zone)) {
 			dev_err(dev, "can't register thermal zone\n");
 			goto error_unregister;
 		}
 
 		list_move_tail(&priv->list, &common->head);
+
+		if (rcar_has_irq_support(priv))
+			rcar_thermal_irq_enable(priv);
 	}
 
 	platform_set_drvdata(pdev, common);

commit e9137a582fcbe36d9dedb8d7f6902a059154b14e
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 31 09:03:46 2013 +0000

    thermal: rcar: add read/write functions for common/priv data
    
    R-Car thermal driver will use struct common in next
    feature (interrupt support).
    But the register address is different between struct priv and common.
    This patch adds read/write functions for struct common,
    and use macro technique to avoid wrong register access.
    
    This is preparation patch for next feature (interrupt support),
    therefore, there is no user to use this common read/write
    function at this point.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 1ba02770153a..cf6aa98956b9 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -29,8 +29,8 @@
 
 #define IDLE_INTERVAL	5000
 
-#define THSCR	0x2c
-#define THSSR	0x30
+#define REG_THSCR	0x2c
+#define REG_THSSR	0x30
 
 /* THSCR */
 #define CPCTL	(1 << 12)
@@ -63,21 +63,55 @@ struct rcar_thermal_priv {
 /*
  *		basic functions
  */
-static u32 rcar_thermal_read(struct rcar_thermal_priv *priv, u32 reg)
+#if 0
+#define rcar_thermal_common_read(c, r) \
+	_rcar_thermal_common_read(c, COMMON_ ##r)
+static u32 _rcar_thermal_common_read(struct rcar_thermal_common *common,
+				     u32 reg)
+{
+	return ioread32(common->base + reg);
+}
+
+#define rcar_thermal_common_write(c, r, d) \
+	_rcar_thermal_common_write(c, COMMON_ ##r, d)
+static void _rcar_thermal_common_write(struct rcar_thermal_common *common,
+				       u32 reg, u32 data)
+{
+	iowrite32(data, common->base + reg);
+}
+
+#define rcar_thermal_common_bset(c, r, m, d) \
+	_rcar_thermal_common_bset(c, COMMON_ ##r, m, d)
+static void _rcar_thermal_common_bset(struct rcar_thermal_common *common,
+				      u32 reg, u32 mask, u32 data)
+{
+	u32 val;
+
+	val = ioread32(common->base + reg);
+	val &= ~mask;
+	val |= (data & mask);
+	iowrite32(val, common->base + reg);
+}
+#endif
+
+#define rcar_thermal_read(p, r) _rcar_thermal_read(p, REG_ ##r)
+static u32 _rcar_thermal_read(struct rcar_thermal_priv *priv, u32 reg)
 {
 	return ioread32(priv->base + reg);
 }
 
 #if 0 /* no user at this point */
-static void rcar_thermal_write(struct rcar_thermal_priv *priv,
-			       u32 reg, u32 data)
+#define rcar_thermal_write(p, r, d) _rcar_thermal_write(p, REG_ ##r, d)
+static void _rcar_thermal_write(struct rcar_thermal_priv *priv,
+				u32 reg, u32 data)
 {
 	iowrite32(data, priv->base + reg);
 }
 #endif
 
-static void rcar_thermal_bset(struct rcar_thermal_priv *priv, u32 reg,
-			      u32 mask, u32 data)
+#define rcar_thermal_bset(p, r, m, d) _rcar_thermal_bset(p, REG_ ##r, m, d)
+static void _rcar_thermal_bset(struct rcar_thermal_priv *priv, u32 reg,
+			       u32 mask, u32 data)
 {
 	u32 val;
 

commit 3676d1dd3d3069ca70b8075c0e86482cbaa01c2f
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 31 09:03:33 2013 +0000

    thermal: rcar: multi channel support
    
    R-Car thermal sensor will be multi channel sensor in next generation.
    But "IRQ controlling method" and "register mapping" are
    different between old/new chip.
    
    This patch adds multi sensor support.
    Then, this driver assumes there is common register
    if platform has IRQ resource.
    
    The IRQ will be supported soon.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index e19b267f76d6..1ba02770153a 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -38,16 +38,27 @@
 /* THSSR */
 #define CTEMP	0x3f
 
+struct rcar_thermal_common {
+	void __iomem *base;
+	struct device *dev;
+	struct list_head head;
+};
 
 struct rcar_thermal_priv {
 	void __iomem *base;
-	struct device *dev;
+	struct rcar_thermal_common *common;
+	struct thermal_zone_device *zone;
 	struct mutex lock;
+	struct list_head list;
 };
 
+#define rcar_thermal_for_each_priv(pos, common)	\
+	list_for_each_entry(pos, &common->head, list)
+
 #define MCELSIUS(temp)			((temp) * 1000)
 #define rcar_zone_to_priv(zone)		((zone)->devdata)
-#define rcar_priv_to_dev(priv)		((priv)->dev)
+#define rcar_priv_to_dev(priv)		((priv)->common->dev)
+#define rcar_has_irq_support(priv)	((priv)->common->base)
 
 /*
  *		basic functions
@@ -129,6 +140,7 @@ static int rcar_thermal_get_trip_type(struct thermal_zone_device *zone,
 				      int trip, enum thermal_trip_type *type)
 {
 	struct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);
+	struct device *dev = rcar_priv_to_dev(priv);
 
 	/* see rcar_thermal_get_temp() */
 	switch (trip) {
@@ -136,7 +148,7 @@ static int rcar_thermal_get_trip_type(struct thermal_zone_device *zone,
 		*type = THERMAL_TRIP_CRITICAL;
 		break;
 	default:
-		dev_err(priv->dev, "rcar driver trip error\n");
+		dev_err(dev, "rcar driver trip error\n");
 		return -EINVAL;
 	}
 
@@ -147,6 +159,7 @@ static int rcar_thermal_get_trip_temp(struct thermal_zone_device *zone,
 				      int trip, unsigned long *temp)
 {
 	struct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);
+	struct device *dev = rcar_priv_to_dev(priv);
 
 	/* see rcar_thermal_get_temp() */
 	switch (trip) {
@@ -154,7 +167,7 @@ static int rcar_thermal_get_trip_temp(struct thermal_zone_device *zone,
 		*temp = MCELSIUS(90);
 		break;
 	default:
-		dev_err(priv->dev, "rcar driver trip error\n");
+		dev_err(dev, "rcar driver trip error\n");
 		return -EINVAL;
 	}
 
@@ -165,12 +178,12 @@ static int rcar_thermal_notify(struct thermal_zone_device *zone,
 			       int trip, enum thermal_trip_type type)
 {
 	struct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);
+	struct device *dev = rcar_priv_to_dev(priv);
 
 	switch (type) {
 	case THERMAL_TRIP_CRITICAL:
 		/* FIXME */
-		dev_warn(priv->dev,
-			 "Thermal reached to critical temperature\n");
+		dev_warn(dev, "Thermal reached to critical temperature\n");
 		machine_power_off();
 		break;
 	default:
@@ -192,51 +205,98 @@ static struct thermal_zone_device_ops rcar_thermal_zone_ops = {
  */
 static int rcar_thermal_probe(struct platform_device *pdev)
 {
-	struct thermal_zone_device *zone;
+	struct rcar_thermal_common *common;
 	struct rcar_thermal_priv *priv;
-	struct resource *res;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev, "Could not get platform resource\n");
-		return -ENODEV;
-	}
+	struct device *dev = &pdev->dev;
+	struct resource *res, *irq;
+	int mres = 0;
+	int i;
 
-	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv) {
-		dev_err(&pdev->dev, "Could not allocate priv\n");
+	common = devm_kzalloc(dev, sizeof(*common), GFP_KERNEL);
+	if (!common) {
+		dev_err(dev, "Could not allocate common\n");
 		return -ENOMEM;
 	}
 
-	priv->dev = &pdev->dev;
-	mutex_init(&priv->lock);
-	priv->base = devm_ioremap_nocache(&pdev->dev,
-					  res->start, resource_size(res));
-	if (!priv->base) {
-		dev_err(&pdev->dev, "Unable to ioremap thermal register\n");
-		return -ENOMEM;
+	INIT_LIST_HEAD(&common->head);
+	common->dev = dev;
+
+	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (irq) {
+		/*
+		 * platform has IRQ support.
+		 * Then, drier use common register
+		 */
+		res = platform_get_resource(pdev, IORESOURCE_MEM, mres++);
+		if (!res) {
+			dev_err(dev, "Could not get platform resource\n");
+			return -ENODEV;
+		}
+
+		/*
+		 * rcar_has_irq_support() will be enabled
+		 */
+		common->base = devm_request_and_ioremap(dev, res);
+		if (!common->base) {
+			dev_err(dev, "Unable to ioremap thermal register\n");
+			return -ENOMEM;
+		}
 	}
 
-	zone = thermal_zone_device_register("rcar_thermal", 1, 0, priv,
-					    &rcar_thermal_zone_ops, NULL, 0,
-					    IDLE_INTERVAL);
-	if (IS_ERR(zone)) {
-		dev_err(&pdev->dev, "thermal zone device is NULL\n");
-		return PTR_ERR(zone);
+	for (i = 0;; i++) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, mres++);
+		if (!res)
+			break;
+
+		priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+		if (!priv) {
+			dev_err(dev, "Could not allocate priv\n");
+			return -ENOMEM;
+		}
+
+		priv->base = devm_request_and_ioremap(dev, res);
+		if (!priv->base) {
+			dev_err(dev, "Unable to ioremap priv register\n");
+			return -ENOMEM;
+		}
+
+		priv->common = common;
+		mutex_init(&priv->lock);
+		INIT_LIST_HEAD(&priv->list);
+
+		priv->zone = thermal_zone_device_register("rcar_thermal",
+						1, 0, priv,
+						&rcar_thermal_zone_ops, NULL, 0,
+						IDLE_INTERVAL);
+		if (IS_ERR(priv->zone)) {
+			dev_err(dev, "can't register thermal zone\n");
+			goto error_unregister;
+		}
+
+		list_move_tail(&priv->list, &common->head);
 	}
 
-	platform_set_drvdata(pdev, zone);
+	platform_set_drvdata(pdev, common);
 
-	dev_info(&pdev->dev, "proved\n");
+	dev_info(dev, "%d sensor proved\n", i);
 
 	return 0;
+
+error_unregister:
+	rcar_thermal_for_each_priv(priv, common)
+		thermal_zone_device_unregister(priv->zone);
+
+	return -ENODEV;
 }
 
 static int rcar_thermal_remove(struct platform_device *pdev)
 {
-	struct thermal_zone_device *zone = platform_get_drvdata(pdev);
+	struct rcar_thermal_common *common = platform_get_drvdata(pdev);
+	struct rcar_thermal_priv *priv;
+
+	rcar_thermal_for_each_priv(priv, common)
+		thermal_zone_device_unregister(priv->zone);
 
-	thermal_zone_device_unregister(zone);
 	platform_set_drvdata(pdev, NULL);
 
 	return 0;

commit b2bbc6a2ace78eaca2f6482b58b984519aa783ac
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 31 09:03:22 2013 +0000

    thermal: rcar: use mutex lock instead of spin lock
    
    Current R-Car thermal driver is using spin lock for each
    registers read/write, but it is pointless lock.
    This lock is required while reading temperature,
    but it needs long wait (= 300ms).
    So, this patch used mutex lock while reading temperature,
    instead of spin lock for each registers.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 068b2a1c5c15..e19b267f76d6 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -42,7 +42,7 @@
 struct rcar_thermal_priv {
 	void __iomem *base;
 	struct device *dev;
-	spinlock_t lock;
+	struct mutex lock;
 };
 
 #define MCELSIUS(temp)			((temp) * 1000)
@@ -54,46 +54,26 @@ struct rcar_thermal_priv {
  */
 static u32 rcar_thermal_read(struct rcar_thermal_priv *priv, u32 reg)
 {
-	unsigned long flags;
-	u32 ret;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
-	ret = ioread32(priv->base + reg);
-
-	spin_unlock_irqrestore(&priv->lock, flags);
-
-	return ret;
+	return ioread32(priv->base + reg);
 }
 
 #if 0 /* no user at this point */
 static void rcar_thermal_write(struct rcar_thermal_priv *priv,
 			       u32 reg, u32 data)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->lock, flags);
-
 	iowrite32(data, priv->base + reg);
-
-	spin_unlock_irqrestore(&priv->lock, flags);
 }
 #endif
 
 static void rcar_thermal_bset(struct rcar_thermal_priv *priv, u32 reg,
 			      u32 mask, u32 data)
 {
-	unsigned long flags;
 	u32 val;
 
-	spin_lock_irqsave(&priv->lock, flags);
-
 	val = ioread32(priv->base + reg);
 	val &= ~mask;
 	val |= (data & mask);
 	iowrite32(val, priv->base + reg);
-
-	spin_unlock_irqrestore(&priv->lock, flags);
 }
 
 /*
@@ -107,6 +87,8 @@ static int rcar_thermal_get_temp(struct thermal_zone_device *zone,
 	int i;
 	int ctemp, old, new;
 
+	mutex_lock(&priv->lock);
+
 	/*
 	 * TSC decides a value of CPTAP automatically,
 	 * and this is the conditions which validate interrupt.
@@ -138,6 +120,8 @@ static int rcar_thermal_get_temp(struct thermal_zone_device *zone,
 
 	*temp = MCELSIUS((ctemp * 5) - 65);
 
+	mutex_unlock(&priv->lock);
+
 	return 0;
 }
 
@@ -225,7 +209,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	}
 
 	priv->dev = &pdev->dev;
-	spin_lock_init(&priv->lock);
+	mutex_init(&priv->lock);
 	priv->base = devm_ioremap_nocache(&pdev->dev,
 					  res->start, resource_size(res));
 	if (!priv->base) {

commit f8f53e1874c2dfddf4c6dc69008ba85d6de4d944
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 31 09:03:11 2013 +0000

    thermal: rcar: enable CPCTL to use hardware TSC deciding
    
    If CPCTL was 1 on R-Car thermal, the thermal comparator offset
    is automatically decided by hardware.
    And this CPCTL is the conditions which validate interrupt.
    This patch enabled CPCTL.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 47b2b227c91e..068b2a1c5c15 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -33,7 +33,7 @@
 #define THSSR	0x30
 
 /* THSCR */
-#define CPTAP	0xf
+#define CPCTL	(1 << 12)
 
 /* THSSR */
 #define CTEMP	0x3f
@@ -43,11 +43,11 @@ struct rcar_thermal_priv {
 	void __iomem *base;
 	struct device *dev;
 	spinlock_t lock;
-	u32 comp;
 };
 
 #define MCELSIUS(temp)			((temp) * 1000)
 #define rcar_zone_to_priv(zone)		((zone)->devdata)
+#define rcar_priv_to_dev(priv)		((priv)->dev)
 
 /*
  *		basic functions
@@ -103,79 +103,41 @@ static int rcar_thermal_get_temp(struct thermal_zone_device *zone,
 			   unsigned long *temp)
 {
 	struct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);
-	int val, min, max, tmp;
-
-	tmp = -200; /* default */
-	while (1) {
-		if (priv->comp < 1 || priv->comp > 12) {
-			dev_err(priv->dev,
-				"THSSR invalid data (%d)\n", priv->comp);
-			priv->comp = 4; /* for next thermal */
-			return -EINVAL;
-		}
-
-		/*
-		 * THS comparator offset and the reference temperature
-		 *
-		 * Comparator	| reference	| Temperature field
-		 * offset	| temperature	| measurement
-		 *		| (degrees C)	| (degrees C)
-		 * -------------+---------------+-------------------
-		 *  1		|  -45		|  -45 to  -30
-		 *  2		|  -30		|  -30 to  -15
-		 *  3		|  -15		|  -15 to    0
-		 *  4		|    0		|    0 to  +15
-		 *  5		|  +15		|  +15 to  +30
-		 *  6		|  +30		|  +30 to  +45
-		 *  7		|  +45		|  +45 to  +60
-		 *  8		|  +60		|  +60 to  +75
-		 *  9		|  +75		|  +75 to  +90
-		 * 10		|  +90		|  +90 to +105
-		 * 11		| +105		| +105 to +120
-		 * 12		| +120		| +120 to +135
-		 */
-
-		/* calculate thermal limitation */
-		min = (priv->comp * 15) - 60;
-		max = min + 15;
-
+	struct device *dev = rcar_priv_to_dev(priv);
+	int i;
+	int ctemp, old, new;
+
+	/*
+	 * TSC decides a value of CPTAP automatically,
+	 * and this is the conditions which validate interrupt.
+	 */
+	rcar_thermal_bset(priv, THSCR, CPCTL, CPCTL);
+
+	ctemp = 0;
+	old = ~0;
+	for (i = 0; i < 128; i++) {
 		/*
 		 * we need to wait 300us after changing comparator offset
 		 * to get stable temperature.
 		 * see "Usage Notes" on datasheet
 		 */
-		rcar_thermal_bset(priv, THSCR, CPTAP, priv->comp);
 		udelay(300);
 
-		/* calculate current temperature */
-		val = rcar_thermal_read(priv, THSSR) & CTEMP;
-		val = (val * 5) - 65;
-
-		dev_dbg(priv->dev, "comp/min/max/val = %d/%d/%d/%d\n",
-			priv->comp, min, max, val);
-
-		/*
-		 * If val is same as min/max, then,
-		 * it should try again on next comparator.
-		 * But the val might be correct temperature.
-		 * Keep it on "tmp" and compare with next val.
-		 */
-		if (tmp == val)
-			break;
-
-		if (val <= min) {
-			tmp = min;
-			priv->comp--; /* try again */
-		} else if (val >= max) {
-			tmp = max;
-			priv->comp++; /* try again */
-		} else {
-			tmp = val;
+		new = rcar_thermal_read(priv, THSSR) & CTEMP;
+		if (new == old) {
+			ctemp = new;
 			break;
 		}
+		old = new;
 	}
 
-	*temp = MCELSIUS(tmp);
+	if (!ctemp) {
+		dev_err(dev, "thermal sensor was broken\n");
+		return -EINVAL;
+	}
+
+	*temp = MCELSIUS((ctemp * 5) - 65);
+
 	return 0;
 }
 
@@ -262,7 +224,6 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	}
 
-	priv->comp = 4; /* basic setup */
 	priv->dev = &pdev->dev;
 	spin_lock_init(&priv->lock);
 	priv->base = devm_ioremap_nocache(&pdev->dev,

commit 9dde8f86085d283042718f88eed017eccad73ab9
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Jan 31 09:02:51 2013 +0000

    thermal: rcar: use parenthesis on macro
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 89979ff10e27..47b2b227c91e 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -47,7 +47,7 @@ struct rcar_thermal_priv {
 };
 
 #define MCELSIUS(temp)			((temp) * 1000)
-#define rcar_zone_to_priv(zone)		(zone->devdata)
+#define rcar_zone_to_priv(zone)		((zone)->devdata)
 
 /*
  *		basic functions

commit d2a73e225d113fdccd80373ad9aeb2b58b32a30b
Author: kuninori.morimoto.gx@renesas.com <kuninori.morimoto.gx@renesas.com>
Date:   Sun Dec 2 18:48:41 2012 -0800

    thermal: rcar: add .get_trip_type/temp and .notify support
    
    This patch adds .get_trip_type(), .get_trip_temp(), and .notify()
    on rcar_thermal_zone_ops.
    Driver will try platform power OFF if it reached to
    critical temperature.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 90db951725da..89979ff10e27 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -22,10 +22,13 @@
 #include <linux/io.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#include <linux/reboot.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 #include <linux/thermal.h>
 
+#define IDLE_INTERVAL	5000
+
 #define THSCR	0x2c
 #define THSSR	0x30
 
@@ -176,8 +179,66 @@ static int rcar_thermal_get_temp(struct thermal_zone_device *zone,
 	return 0;
 }
 
+static int rcar_thermal_get_trip_type(struct thermal_zone_device *zone,
+				      int trip, enum thermal_trip_type *type)
+{
+	struct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);
+
+	/* see rcar_thermal_get_temp() */
+	switch (trip) {
+	case 0: /* +90 <= temp */
+		*type = THERMAL_TRIP_CRITICAL;
+		break;
+	default:
+		dev_err(priv->dev, "rcar driver trip error\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rcar_thermal_get_trip_temp(struct thermal_zone_device *zone,
+				      int trip, unsigned long *temp)
+{
+	struct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);
+
+	/* see rcar_thermal_get_temp() */
+	switch (trip) {
+	case 0: /* +90 <= temp */
+		*temp = MCELSIUS(90);
+		break;
+	default:
+		dev_err(priv->dev, "rcar driver trip error\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rcar_thermal_notify(struct thermal_zone_device *zone,
+			       int trip, enum thermal_trip_type type)
+{
+	struct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);
+
+	switch (type) {
+	case THERMAL_TRIP_CRITICAL:
+		/* FIXME */
+		dev_warn(priv->dev,
+			 "Thermal reached to critical temperature\n");
+		machine_power_off();
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
 static struct thermal_zone_device_ops rcar_thermal_zone_ops = {
-	.get_temp = rcar_thermal_get_temp,
+	.get_temp	= rcar_thermal_get_temp,
+	.get_trip_type	= rcar_thermal_get_trip_type,
+	.get_trip_temp	= rcar_thermal_get_trip_temp,
+	.notify		= rcar_thermal_notify,
 };
 
 /*
@@ -211,8 +272,9 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	}
 
-	zone = thermal_zone_device_register("rcar_thermal", 0, 0, priv,
-				    &rcar_thermal_zone_ops, NULL, 0, 0);
+	zone = thermal_zone_device_register("rcar_thermal", 1, 0, priv,
+					    &rcar_thermal_zone_ops, NULL, 0,
+					    IDLE_INTERVAL);
 	if (IS_ERR(zone)) {
 		dev_err(&pdev->dev, "thermal zone device is NULL\n");
 		return PTR_ERR(zone);

commit d12250ef8dc1bbc811d505776be053e358ba82f5
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Nov 26 02:32:20 2012 +0000

    thermal: rcar: add rcar_zone_to_priv() macro
    
    This patch adds rcar_zone_to_priv()
    which is a helper macro for gettign private data.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index f2678ff0ed2b..90db951725da 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -44,6 +44,7 @@ struct rcar_thermal_priv {
 };
 
 #define MCELSIUS(temp)			((temp) * 1000)
+#define rcar_zone_to_priv(zone)		(zone->devdata)
 
 /*
  *		basic functions
@@ -98,7 +99,7 @@ static void rcar_thermal_bset(struct rcar_thermal_priv *priv, u32 reg,
 static int rcar_thermal_get_temp(struct thermal_zone_device *zone,
 			   unsigned long *temp)
 {
-	struct rcar_thermal_priv *priv = zone->devdata;
+	struct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);
 	int val, min, max, tmp;
 
 	tmp = -200; /* default */

commit c499703e64bef8f2e8ffe9ea7ee63a0a926b5530
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Mon Nov 26 02:32:06 2012 +0000

    thermal: rcar: fixup the unit of temperature
    
    The unit of temperature is Milli-Celsius.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 81dce23828f3..f2678ff0ed2b 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -43,6 +43,8 @@ struct rcar_thermal_priv {
 	u32 comp;
 };
 
+#define MCELSIUS(temp)			((temp) * 1000)
+
 /*
  *		basic functions
  */
@@ -169,7 +171,7 @@ static int rcar_thermal_get_temp(struct thermal_zone_device *zone,
 		}
 	}
 
-	*temp = tmp;
+	*temp = MCELSIUS(tmp);
 	return 0;
 }
 

commit 4e8e2f644e11a7d65381967a916ae7cac76a735b
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Tue Oct 2 23:51:09 2012 -0700

    thermal: rcar_thermal: remove explicitly used devm_kfree/iounap()
    
    devm_kfree and devm_iounmap should not have to be explicitly used
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index 762f6373d50c..81dce23828f3 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -185,7 +185,6 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	struct thermal_zone_device *zone;
 	struct rcar_thermal_priv *priv;
 	struct resource *res;
-	int ret;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
@@ -206,16 +205,14 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 					  res->start, resource_size(res));
 	if (!priv->base) {
 		dev_err(&pdev->dev, "Unable to ioremap thermal register\n");
-		ret = -ENOMEM;
-		goto error_free_priv;
+		return -ENOMEM;
 	}
 
 	zone = thermal_zone_device_register("rcar_thermal", 0, 0, priv,
 				    &rcar_thermal_zone_ops, NULL, 0, 0);
 	if (IS_ERR(zone)) {
 		dev_err(&pdev->dev, "thermal zone device is NULL\n");
-		ret = PTR_ERR(zone);
-		goto error_iounmap;
+		return PTR_ERR(zone);
 	}
 
 	platform_set_drvdata(pdev, zone);
@@ -223,26 +220,15 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	dev_info(&pdev->dev, "proved\n");
 
 	return 0;
-
-error_iounmap:
-	devm_iounmap(&pdev->dev, priv->base);
-error_free_priv:
-	devm_kfree(&pdev->dev, priv);
-
-	return ret;
 }
 
 static int rcar_thermal_remove(struct platform_device *pdev)
 {
 	struct thermal_zone_device *zone = platform_get_drvdata(pdev);
-	struct rcar_thermal_priv *priv = zone->devdata;
 
 	thermal_zone_device_unregister(zone);
 	platform_set_drvdata(pdev, NULL);
 
-	devm_iounmap(&pdev->dev, priv->base);
-	devm_kfree(&pdev->dev, priv);
-
 	return 0;
 }
 

commit 50125a9b27dd09e9afdc1b8712ba0b3859886c68
Author: Durgadoss R <durgadoss.r@intel.com>
Date:   Tue Sep 18 11:04:56 2012 +0530

    Thermal: Pass zone parameters as argument to tzd_register
    
    This patch adds the thermal zone parameter as an argument to
    the tzd_register() function call; and updates other drivers
    using this function.
    
    Signed-off-by: Durgadoss R <durgadoss.r@intel.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index f7a1b574a304..762f6373d50c 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -211,7 +211,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 	}
 
 	zone = thermal_zone_device_register("rcar_thermal", 0, 0, priv,
-					    &rcar_thermal_zone_ops, 0, 0);
+				    &rcar_thermal_zone_ops, NULL, 0, 0);
 	if (IS_ERR(zone)) {
 		dev_err(&pdev->dev, "thermal zone device is NULL\n");
 		ret = PTR_ERR(zone);

commit 608f62b996c6e140ff7515abe75305aed4726b33
Author: Devendra Naga <develkernel412222@gmail.com>
Date:   Wed Oct 31 17:46:10 2012 +0900

    thermal: solve compilation errors in rcar_thermal
    
    following were the errors reported
    
    drivers/thermal/rcar_thermal.c: In function ‘rcar_thermal_probe’:
    drivers/thermal/rcar_thermal.c:214:10: warning: passing argument 3 of ‘thermal_zone_device_register’ makes integer from pointer without a cast [enabled by default]
    include/linux/thermal.h:166:29: note: expected ‘int’ but argument is of type ‘struct rcar_thermal_priv *’
    drivers/thermal/rcar_thermal.c:214:10: error: too few arguments to function ‘thermal_zone_device_register’
    include/linux/thermal.h:166:29: note: declared here
    make[1]: *** [drivers/thermal/rcar_thermal.o] Error 1
    make: *** [drivers/thermal/rcar_thermal.o] Error 2
    
    with gcc version 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5)
    
    Signed-off-by: Devendra Naga <develkernel412222@gmail.com>
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
index d4452716aaab..f7a1b574a304 100644
--- a/drivers/thermal/rcar_thermal.c
+++ b/drivers/thermal/rcar_thermal.c
@@ -210,7 +210,7 @@ static int rcar_thermal_probe(struct platform_device *pdev)
 		goto error_free_priv;
 	}
 
-	zone = thermal_zone_device_register("rcar_thermal", 0, priv,
+	zone = thermal_zone_device_register("rcar_thermal", 0, 0, priv,
 					    &rcar_thermal_zone_ops, 0, 0);
 	if (IS_ERR(zone)) {
 		dev_err(&pdev->dev, "thermal zone device is NULL\n");

commit 1e426ffddf2f158367eb6c7b8eb563c814a43283
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Sat Jul 21 10:53:48 2012 +1000

    thermal: add Renesas R-Car thermal sensor support
    
    This patch add basic Renesas R-Car thermal sensor support.
    It was tested on R-Car H1 Marzen board.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Jean Delvare <khali@linux-fr.org>
    Cc: Guenter Roeck <guenter.roeck@ericsson.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>

diff --git a/drivers/thermal/rcar_thermal.c b/drivers/thermal/rcar_thermal.c
new file mode 100644
index 000000000000..d4452716aaab
--- /dev/null
+++ b/drivers/thermal/rcar_thermal.c
@@ -0,0 +1,260 @@
+/*
+ *  R-Car THS/TSC thermal sensor driver
+ *
+ * Copyright (C) 2012 Renesas Solutions Corp.
+ * Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ */
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/thermal.h>
+
+#define THSCR	0x2c
+#define THSSR	0x30
+
+/* THSCR */
+#define CPTAP	0xf
+
+/* THSSR */
+#define CTEMP	0x3f
+
+
+struct rcar_thermal_priv {
+	void __iomem *base;
+	struct device *dev;
+	spinlock_t lock;
+	u32 comp;
+};
+
+/*
+ *		basic functions
+ */
+static u32 rcar_thermal_read(struct rcar_thermal_priv *priv, u32 reg)
+{
+	unsigned long flags;
+	u32 ret;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	ret = ioread32(priv->base + reg);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return ret;
+}
+
+#if 0 /* no user at this point */
+static void rcar_thermal_write(struct rcar_thermal_priv *priv,
+			       u32 reg, u32 data)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	iowrite32(data, priv->base + reg);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+#endif
+
+static void rcar_thermal_bset(struct rcar_thermal_priv *priv, u32 reg,
+			      u32 mask, u32 data)
+{
+	unsigned long flags;
+	u32 val;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	val = ioread32(priv->base + reg);
+	val &= ~mask;
+	val |= (data & mask);
+	iowrite32(val, priv->base + reg);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+/*
+ *		zone device functions
+ */
+static int rcar_thermal_get_temp(struct thermal_zone_device *zone,
+			   unsigned long *temp)
+{
+	struct rcar_thermal_priv *priv = zone->devdata;
+	int val, min, max, tmp;
+
+	tmp = -200; /* default */
+	while (1) {
+		if (priv->comp < 1 || priv->comp > 12) {
+			dev_err(priv->dev,
+				"THSSR invalid data (%d)\n", priv->comp);
+			priv->comp = 4; /* for next thermal */
+			return -EINVAL;
+		}
+
+		/*
+		 * THS comparator offset and the reference temperature
+		 *
+		 * Comparator	| reference	| Temperature field
+		 * offset	| temperature	| measurement
+		 *		| (degrees C)	| (degrees C)
+		 * -------------+---------------+-------------------
+		 *  1		|  -45		|  -45 to  -30
+		 *  2		|  -30		|  -30 to  -15
+		 *  3		|  -15		|  -15 to    0
+		 *  4		|    0		|    0 to  +15
+		 *  5		|  +15		|  +15 to  +30
+		 *  6		|  +30		|  +30 to  +45
+		 *  7		|  +45		|  +45 to  +60
+		 *  8		|  +60		|  +60 to  +75
+		 *  9		|  +75		|  +75 to  +90
+		 * 10		|  +90		|  +90 to +105
+		 * 11		| +105		| +105 to +120
+		 * 12		| +120		| +120 to +135
+		 */
+
+		/* calculate thermal limitation */
+		min = (priv->comp * 15) - 60;
+		max = min + 15;
+
+		/*
+		 * we need to wait 300us after changing comparator offset
+		 * to get stable temperature.
+		 * see "Usage Notes" on datasheet
+		 */
+		rcar_thermal_bset(priv, THSCR, CPTAP, priv->comp);
+		udelay(300);
+
+		/* calculate current temperature */
+		val = rcar_thermal_read(priv, THSSR) & CTEMP;
+		val = (val * 5) - 65;
+
+		dev_dbg(priv->dev, "comp/min/max/val = %d/%d/%d/%d\n",
+			priv->comp, min, max, val);
+
+		/*
+		 * If val is same as min/max, then,
+		 * it should try again on next comparator.
+		 * But the val might be correct temperature.
+		 * Keep it on "tmp" and compare with next val.
+		 */
+		if (tmp == val)
+			break;
+
+		if (val <= min) {
+			tmp = min;
+			priv->comp--; /* try again */
+		} else if (val >= max) {
+			tmp = max;
+			priv->comp++; /* try again */
+		} else {
+			tmp = val;
+			break;
+		}
+	}
+
+	*temp = tmp;
+	return 0;
+}
+
+static struct thermal_zone_device_ops rcar_thermal_zone_ops = {
+	.get_temp = rcar_thermal_get_temp,
+};
+
+/*
+ *		platform functions
+ */
+static int rcar_thermal_probe(struct platform_device *pdev)
+{
+	struct thermal_zone_device *zone;
+	struct rcar_thermal_priv *priv;
+	struct resource *res;
+	int ret;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "Could not get platform resource\n");
+		return -ENODEV;
+	}
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&pdev->dev, "Could not allocate priv\n");
+		return -ENOMEM;
+	}
+
+	priv->comp = 4; /* basic setup */
+	priv->dev = &pdev->dev;
+	spin_lock_init(&priv->lock);
+	priv->base = devm_ioremap_nocache(&pdev->dev,
+					  res->start, resource_size(res));
+	if (!priv->base) {
+		dev_err(&pdev->dev, "Unable to ioremap thermal register\n");
+		ret = -ENOMEM;
+		goto error_free_priv;
+	}
+
+	zone = thermal_zone_device_register("rcar_thermal", 0, priv,
+					    &rcar_thermal_zone_ops, 0, 0);
+	if (IS_ERR(zone)) {
+		dev_err(&pdev->dev, "thermal zone device is NULL\n");
+		ret = PTR_ERR(zone);
+		goto error_iounmap;
+	}
+
+	platform_set_drvdata(pdev, zone);
+
+	dev_info(&pdev->dev, "proved\n");
+
+	return 0;
+
+error_iounmap:
+	devm_iounmap(&pdev->dev, priv->base);
+error_free_priv:
+	devm_kfree(&pdev->dev, priv);
+
+	return ret;
+}
+
+static int rcar_thermal_remove(struct platform_device *pdev)
+{
+	struct thermal_zone_device *zone = platform_get_drvdata(pdev);
+	struct rcar_thermal_priv *priv = zone->devdata;
+
+	thermal_zone_device_unregister(zone);
+	platform_set_drvdata(pdev, NULL);
+
+	devm_iounmap(&pdev->dev, priv->base);
+	devm_kfree(&pdev->dev, priv);
+
+	return 0;
+}
+
+static struct platform_driver rcar_thermal_driver = {
+	.driver	= {
+		.name	= "rcar_thermal",
+	},
+	.probe		= rcar_thermal_probe,
+	.remove		= rcar_thermal_remove,
+};
+module_platform_driver(rcar_thermal_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("R-Car THS/TSC thermal sensor driver");
+MODULE_AUTHOR("Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>");
