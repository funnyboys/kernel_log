commit 160f8d0691659b65a97494c151c95b1287c377ae
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Tue Sep 15 16:26:20 2015 +0300

    spi: omap-uwire: Remove needless bits_per_word and speed_hz tests
    
    SPI core validates both bits_per_word and speed_hz transfer parameters and
    defaults to spi->bits_per_word and spi->max_speed_hz in case these per
    transfer parameters are not set. This allows to remove two needless tests
    from uwire_txrx() and uwire_setup_transfer().
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index 55576db31549..ce8dbdbce312 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -205,7 +205,7 @@ static void uwire_chipselect(struct spi_device *spi, int value)
 static int uwire_txrx(struct spi_device *spi, struct spi_transfer *t)
 {
 	unsigned	len = t->len;
-	unsigned	bits = t->bits_per_word ? : spi->bits_per_word;
+	unsigned	bits = t->bits_per_word;
 	unsigned	bytes;
 	u16		val, w;
 	int		status = 0;
@@ -344,9 +344,10 @@ static int uwire_setup_transfer(struct spi_device *spi, struct spi_transfer *t)
 	/* assume it's already enabled */
 	rate = clk_get_rate(uwire->ck);
 
-	hz = spi->max_speed_hz;
-	if (t != NULL && t->speed_hz)
+	if (t != NULL)
 		hz = t->speed_hz;
+	else
+		hz = spi->max_speed_hz;
 
 	if (!hz) {
 		pr_debug("%s: zero speed?\n", dev_name(&spi->dev));

commit d4f9dcd1ac94e61e097951fd3dfb1cdf000a2660
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Mon Mar 23 14:07:48 2015 +0200

    spi: omap-uwire: Remove needless include asm/irq.h
    
    asm/irq.h is already included by linux/interrupt.h.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index 3c0844457c07..55576db31549 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -44,7 +44,6 @@
 #include <linux/module.h>
 #include <linux/io.h>
 
-#include <asm/irq.h>
 #include <mach/hardware.h>
 #include <asm/mach-types.h>
 

commit 2c658e212ce7e40ace56d9441c8c5634d4d420e3
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Thu Dec 18 16:12:08 2014 +0200

    spi: Remove FSF mailing addresses
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index daf1ada5cd11..3c0844457c07 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -28,10 +28,6 @@
  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 #include <linux/kernel.h>
 #include <linux/init.h>

commit 14ac00e033c57983032993d3b7b3f70b16a9fdbd
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:36 2014 +0200

    spi: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index 8bca90a19dd1..daf1ada5cd11 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -527,7 +527,6 @@ MODULE_ALIAS("platform:omap_uwire");
 static struct platform_driver uwire_driver = {
 	.driver = {
 		.name		= "omap_uwire",
-		.owner		= THIS_MODULE,
 	},
 	.probe = uwire_probe,
 	.remove = uwire_remove,

commit ec17a7f20812c8f5dcd087bf760903a4253c0618
Author: Sachin Kamat <sachin.kamat@samsung.com>
Date:   Tue Jun 24 11:48:19 2014 +0530

    spi: omap-uwire: Fix build error
    
    Fixes the following build error introduced by commit b3f6a57506
    ("spi: omap-uwire: use devm_ functions"):
    drivers/spi/spi-omap-uwire.c:465:2: error: implicit declaration of function ‘devm_ioremap’
    
    Since we are including <linux/io.h>, <asm/io.h> is no longer
    needed. Remove it.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@samsung.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index 8eabbdb0a808..8bca90a19dd1 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -46,10 +46,10 @@
 #include <linux/spi/spi.h>
 #include <linux/spi/spi_bitbang.h>
 #include <linux/module.h>
+#include <linux/io.h>
 
 #include <asm/irq.h>
 #include <mach/hardware.h>
-#include <asm/io.h>
 #include <asm/mach-types.h>
 
 #include <mach/mux.h>

commit 1820a8fc84ef9070271bcaec106b1033dd98fca1
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Jun 24 12:52:46 2014 +0100

    spi: omap-uwire: Ensure devm_ioremap() is prototyped
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index cbf67f92ec22..8eabbdb0a808 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -41,6 +41,7 @@
 #include <linux/err.h>
 #include <linux/clk.h>
 #include <linux/slab.h>
+#include <linux/device.h>
 
 #include <linux/spi/spi.h>
 #include <linux/spi/spi_bitbang.h>

commit b3f6a57506b8c07894549ef3a2aa6bf3b0ba33fd
Author: Himangi Saraogi <himangi774@gmail.com>
Date:   Sat Jun 21 02:08:58 2014 +0530

    spi: omap-uwire: use devm_ functions
    
    This patch introduces the use of devm_clk_get and devm_ioremap instead
    of the unmanaged interfaces and removes the corresponding free function
    calls.
    
    Signed-off-by: Himangi Saraogi <himangi774@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index 0f5a0aa3b871..cbf67f92ec22 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -447,7 +447,6 @@ static void uwire_off(struct uwire_spi *uwire)
 {
 	uwire_write_reg(UWIRE_SR3, 0);
 	clk_disable(uwire->ck);
-	clk_put(uwire->ck);
 	spi_master_put(uwire->bitbang.master);
 }
 
@@ -463,7 +462,7 @@ static int uwire_probe(struct platform_device *pdev)
 
 	uwire = spi_master_get_devdata(master);
 
-	uwire_base = ioremap(UWIRE_BASE_PHYS, UWIRE_IO_SIZE);
+	uwire_base = devm_ioremap(&pdev->dev, UWIRE_BASE_PHYS, UWIRE_IO_SIZE);
 	if (!uwire_base) {
 		dev_dbg(&pdev->dev, "can't ioremap UWIRE\n");
 		spi_master_put(master);
@@ -472,12 +471,11 @@ static int uwire_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, uwire);
 
-	uwire->ck = clk_get(&pdev->dev, "fck");
+	uwire->ck = devm_clk_get(&pdev->dev, "fck");
 	if (IS_ERR(uwire->ck)) {
 		status = PTR_ERR(uwire->ck);
 		dev_dbg(&pdev->dev, "no functional clock?\n");
 		spi_master_put(master);
-		iounmap(uwire_base);
 		return status;
 	}
 	clk_enable(uwire->ck);
@@ -507,7 +505,6 @@ static int uwire_probe(struct platform_device *pdev)
 	status = spi_bitbang_start(&uwire->bitbang);
 	if (status < 0) {
 		uwire_off(uwire);
-		iounmap(uwire_base);
 	}
 	return status;
 }
@@ -520,7 +517,6 @@ static int uwire_remove(struct platform_device *pdev)
 
 	spi_bitbang_stop(&uwire->bitbang);
 	uwire_off(uwire);
-	iounmap(uwire_base);
 	return 0;
 }
 

commit e4745fef5595df7405ea24d6b21ba0e65332bb8e
Author: Axel Lin <axel.lin@ingics.com>
Date:   Fri Mar 28 11:05:55 2014 +0800

    spi: Remove unneeded include of linux/workqueue.h
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index be2a2e108e2f..0f5a0aa3b871 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -37,7 +37,6 @@
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/platform_device.h>
-#include <linux/workqueue.h>
 #include <linux/interrupt.h>
 #include <linux/err.h>
 #include <linux/clk.h>

commit 17523680647be26cf792e58f6e8cccb0fd010fd4
Merge: 6e07b9179aa0 cbab80464f74 d1c18caace25 aca0924b4819 cd2ac0c0cdc5 84a5dc41f64f 00cce74d081e 490c97747d5d 380603712072
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Mar 30 00:51:27 2014 +0000

    Merge remote-tracking branches 'spi/topic/omap-uwire', 'spi/topic/omap100k', 'spi/topic/omap2', 'spi/topic/orion', 'spi/topic/pl022', 'spi/topic/qup', 'spi/topic/rspi' and 'spi/topic/s3c24xx' into spi-next

commit 9dee279b400629100dce152e40e058ae46046922
Merge: 0f38af451fc4 78e39523b8c9 354312f16e49 6f50c6bc61d4 8023d384ff5c aa0fe82629f1 b53b34f042fe
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Mar 30 00:51:03 2014 +0000

    Merge remote-tracking branches 'spi/topic/bus-num', 'spi/topic/cleanup', 'spi/topic/clps711x', 'spi/topic/coldfire', 'spi/topic/completion' and 'spi/topic/davinci' into spi-next

commit d9721ae1493725bb14dcd1a3c19bbb5795e4a42f
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sat Mar 29 18:50:12 2014 +0800

    spi: bitbang: Make spi_bitbang_stop() return void
    
    spi_bitbang_stop() never fails, so make it return void.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index 9313fd3b413d..a4d7bb557792 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -539,14 +539,13 @@ static int uwire_probe(struct platform_device *pdev)
 static int uwire_remove(struct platform_device *pdev)
 {
 	struct uwire_spi	*uwire = platform_get_drvdata(pdev);
-	int			status;
 
 	// FIXME remove all child devices, somewhere ...
 
-	status = spi_bitbang_stop(&uwire->bitbang);
+	spi_bitbang_stop(&uwire->bitbang);
 	uwire_off(uwire);
 	iounmap(uwire_base);
-	return status;
+	return 0;
 }
 
 /* work with hotplug and coldplug */

commit cbab80464f7470432b4b8061333c572a8b9a713f
Author: Nishanth Menon <nm@ti.com>
Date:   Thu Mar 27 11:07:59 2014 -0500

    spi: omap-uwire: add missing iounmap
    
    This fixes the following coccicheck warning:
    linux-2.6/drivers/spi/spi-omap-uwire.c:485:2-8: ERROR: missing iounmap; ioremap on line 471 and execution via conditional on line 481
    
    Signed-off-by: Nishanth Menon <nm@ti.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index f5176bbfa6f1..31ce92ff738b 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -478,6 +478,7 @@ static int uwire_probe(struct platform_device *pdev)
 		status = PTR_ERR(uwire->ck);
 		dev_dbg(&pdev->dev, "no functional clock?\n");
 		spi_master_put(master);
+		iounmap(uwire_base);
 		return status;
 	}
 	clk_enable(uwire->ck);

commit d7a7f6ec14fb07ed9c1167db760bc535b742b382
Author: Axel Lin <axel.lin@ingics.com>
Date:   Wed Mar 26 19:22:08 2014 +0800

    spi: omap-uwire: Remove full duplex check
    
    This driver sets the SPI_MASTER_HALF_DUPLEX flag, so the spi core will check
    transfers to ensure they are not full duplex.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index 95cc6948a2ba..f5176bbfa6f1 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -218,10 +218,6 @@ static int uwire_txrx(struct spi_device *spi, struct spi_transfer *t)
 	if (!t->tx_buf && !t->rx_buf)
 		return 0;
 
-	/* Microwire doesn't read and write concurrently */
-	if (t->tx_buf && t->rx_buf)
-		return -EPERM;
-
 	w = spi->chip_select << 10;
 	w |= CS_CMD;
 

commit 790fc55a77bc041d613da087b3e03bdc59edcfa5
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sat Feb 15 14:26:21 2014 +0800

    spi: omap-uwire: Convert to use bits_per_word_mask
    
    Set bits_per_word_mask so spi core will reject transfers that attempt to use
    an unsupported bits_per_word value.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index 462ddd458217..95cc6948a2ba 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -99,7 +99,6 @@ struct uwire_spi {
 };
 
 struct uwire_state {
-	unsigned	bits_per_word;
 	unsigned	div1_idx;
 };
 
@@ -210,9 +209,8 @@ static void uwire_chipselect(struct spi_device *spi, int value)
 
 static int uwire_txrx(struct spi_device *spi, struct spi_transfer *t)
 {
-	struct uwire_state *ust = spi->controller_state;
 	unsigned	len = t->len;
-	unsigned	bits = ust->bits_per_word;
+	unsigned	bits = t->bits_per_word ? : spi->bits_per_word;
 	unsigned	bytes;
 	u16		val, w;
 	int		status = 0;
@@ -322,7 +320,6 @@ static int uwire_setup_transfer(struct spi_device *spi, struct spi_transfer *t)
 	struct uwire_state	*ust = spi->controller_state;
 	struct uwire_spi	*uwire;
 	unsigned		flags = 0;
-	unsigned		bits;
 	unsigned		hz;
 	unsigned long		rate;
 	int			div1_idx;
@@ -332,17 +329,6 @@ static int uwire_setup_transfer(struct spi_device *spi, struct spi_transfer *t)
 
 	uwire = spi_master_get_devdata(spi->master);
 
-	bits = spi->bits_per_word;
-	if (t != NULL && t->bits_per_word)
-		bits = t->bits_per_word;
-
-	if (bits > 16) {
-		pr_debug("%s: wordsize %d?\n", dev_name(&spi->dev), bits);
-		status = -ENODEV;
-		goto done;
-	}
-	ust->bits_per_word = bits;
-
 	/* mode 0..3, clock inverted separately;
 	 * standard nCS signaling;
 	 * don't treat DI=high as "not ready"
@@ -509,7 +495,7 @@ static int uwire_probe(struct platform_device *pdev)
 
 	/* the spi->mode bits understood by this driver: */
 	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
-
+	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 16);
 	master->flags = SPI_MASTER_HALF_DUPLEX;
 
 	master->bus_num = 2;	/* "official" */

commit 354312f16e49add1da78f0cfb2bcb633709d0071
Author: Axel Lin <axel.lin@ingics.com>
Date:   Tue Feb 11 22:07:30 2014 +0800

    spi: Remove duplicate code to check chip_select
    
    In spi_add_device(), we have the code to validate spi->chip_select.
    So remove the duplicate code in various drivers.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Acked-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index 9313fd3b413d..462ddd458217 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -332,12 +332,6 @@ static int uwire_setup_transfer(struct spi_device *spi, struct spi_transfer *t)
 
 	uwire = spi_master_get_devdata(spi->master);
 
-	if (spi->chip_select > 3) {
-		pr_debug("%s: cs%d?\n", dev_name(&spi->dev), spi->chip_select);
-		status = -ENODEV;
-		goto done;
-	}
-
 	bits = spi->bits_per_word;
 	if (t != NULL && t->bits_per_word)
 		bits = t->bits_per_word;

commit 93e9c900102aa2e9b10ec4758b441c8b6e53daf3
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Tue Oct 8 22:35:39 2013 +0200

    spi: spi-omap-uwire: replace platform_driver_probe to support deferred probing
    
    Subsystems like pinctrl and gpio rightfully make use of deferred probing at
    core level. Now, deferred drivers won't be retried if they don't have a .probe
    function specified in the driver struct. Fix this driver to have that, so the
    devices it supports won't get lost in a deferred probe.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index a6a8f0961750..9313fd3b413d 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -557,7 +557,8 @@ static struct platform_driver uwire_driver = {
 		.name		= "omap_uwire",
 		.owner		= THIS_MODULE,
 	},
-	.remove		= uwire_remove,
+	.probe = uwire_probe,
+	.remove = uwire_remove,
 	// suspend ... unuse ck
 	// resume ... use ck
 };
@@ -579,7 +580,7 @@ static int __init omap_uwire_init(void)
 		omap_writel(val | 0x00AAA000, OMAP7XX_IO_CONF_9);
 	}
 
-	return platform_driver_probe(&uwire_driver, uwire_probe);
+	return platform_driver_register(&uwire_driver);
 }
 
 static void __exit omap_uwire_exit(void)

commit 24b5a82cf5709a4bc577f42fdaa61b23a7f58f08
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Thu May 23 19:20:40 2013 +0900

    spi: use platform_{get,set}_drvdata()
    
    Use the wrapper functions for getting and setting the driver data using
    platform_device instead of using dev_{get,set}_drvdata() with &pdev->dev,
    so we can directly pass a struct platform_device.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index 102b233b50c4..a6a8f0961750 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -495,7 +495,7 @@ static int uwire_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	}
 
-	dev_set_drvdata(&pdev->dev, uwire);
+	platform_set_drvdata(pdev, uwire);
 
 	uwire->ck = clk_get(&pdev->dev, "fck");
 	if (IS_ERR(uwire->ck)) {
@@ -538,7 +538,7 @@ static int uwire_probe(struct platform_device *pdev)
 
 static int uwire_remove(struct platform_device *pdev)
 {
-	struct uwire_spi	*uwire = dev_get_drvdata(&pdev->dev);
+	struct uwire_spi	*uwire = platform_get_drvdata(pdev);
 	int			status;
 
 	// FIXME remove all child devices, somewhere ...

commit 2deff8d602e8c9a2cab4b070be829294e1211f2c
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 5 13:27:35 2013 +0000

    spi: Remove erroneous __init, __exit and __exit_p() references in drivers
    
    Some of the spi driver module remove hooks were annotated with __exit
    and referenced with __exit_p(). Presumably these were supposed to be
    __devinit, __devexit and __devexit_p() since __init/__exit for a
    probe/remove hook has never been correct. They also got missed during
    the big __devinit/__devexit purge since they didn't match the pattern.
    Remove then now to be rid of it.
    
    v2: purge __init also
    
    Reported-by: Arnd Bergmann <arnd@arndb.de>
    [Arnd set a patch cleaning up one, and then I found more]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index 0a94d9dc9c31..102b233b50c4 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -476,7 +476,7 @@ static void uwire_off(struct uwire_spi *uwire)
 	spi_master_put(uwire->bitbang.master);
 }
 
-static int __init uwire_probe(struct platform_device *pdev)
+static int uwire_probe(struct platform_device *pdev)
 {
 	struct spi_master	*master;
 	struct uwire_spi	*uwire;
@@ -536,7 +536,7 @@ static int __init uwire_probe(struct platform_device *pdev)
 	return status;
 }
 
-static int __exit uwire_remove(struct platform_device *pdev)
+static int uwire_remove(struct platform_device *pdev)
 {
 	struct uwire_spi	*uwire = dev_get_drvdata(&pdev->dev);
 	int			status;
@@ -557,7 +557,7 @@ static struct platform_driver uwire_driver = {
 		.name		= "omap_uwire",
 		.owner		= THIS_MODULE,
 	},
-	.remove		= __exit_p(uwire_remove),
+	.remove		= uwire_remove,
 	// suspend ... unuse ck
 	// resume ... use ck
 };

commit 70c494c3122fb3d53518aea53c8cf5d61cad909a
Author: Tony Lindgren <tony@atomide.com>
Date:   Wed Sep 19 10:46:56 2012 -0700

    ARM: OMAP1: Make plat/mux.h omap1 only
    
    We are moving omap2+ to use the device tree based pinctrl-single.c
    and will be removing the old mux framework. This will remove the
    omap1 specific parts from plat-omap.
    
    Acked-by: Felipe Balbi <balbi@ti.com>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Florian Tobias Schandinat <FlorianSchandinat@gmx.de>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: linux-usb@vger.kernel.org
    Cc: linux-pcmcia@lists.infradead.org
    Cc: spi-devel-general@lists.sourceforge.net
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index a3996a1c6345..0a94d9dc9c31 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -52,7 +52,7 @@
 #include <asm/io.h>
 #include <asm/mach-types.h>
 
-#include <plat/mux.h>
+#include <mach/mux.h>
 
 #include <mach/omap7xx.h>	/* OMAP7XX_IO_CONF registers */
 

commit 68cb700c59fae6cd539c9dc1e9f2584f671935a0
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri Aug 31 17:04:35 2012 -0700

    ARM: OMAP1: Move SoC specific headers from plat to mach for omap1
    
    There's no need to have these in plat-omap any longer. Note that these
    could eventually be made local to mach-omap1 instead of being in mach.
    
    But to do that, at least various driver access using omap7xxx.h registers
    needs to be fixed first.
    
    Cc: spi-devel-general@lists.sourceforge.net
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Tony Lindgren <tony@atomide.com>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index 9b0d71696039..a3996a1c6345 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -53,7 +53,8 @@
 #include <asm/mach-types.h>
 
 #include <plat/mux.h>
-#include <plat/omap7xx.h>	/* OMAP7XX_IO_CONF registers */
+
+#include <mach/omap7xx.h>	/* OMAP7XX_IO_CONF registers */
 
 
 /* FIXME address is now a platform device resource,

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index 610f7391456e..9b0d71696039 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -47,7 +47,6 @@
 #include <linux/spi/spi_bitbang.h>
 #include <linux/module.h>
 
-#include <asm/system.h>
 #include <asm/irq.h>
 #include <mach/hardware.h>
 #include <asm/io.h>

commit d7614de422c0b55db0c1013a6c72330187536004
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 3 15:44:29 2011 -0400

    spi: Add module.h to implicit users in drivers/spi
    
    We are clipping down the presence of module.h, since it was
    everywhere.  If you really need it, you better call it out,
    as per this changeset.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
index 00a8e9d7dbe4..610f7391456e 100644
--- a/drivers/spi/spi-omap-uwire.c
+++ b/drivers/spi/spi-omap-uwire.c
@@ -45,6 +45,7 @@
 
 #include <linux/spi/spi.h>
 #include <linux/spi/spi_bitbang.h>
+#include <linux/module.h>
 
 #include <asm/system.h>
 #include <asm/irq.h>

commit ca632f556697d45d67ed5cada7cedf3ddfe0db4b
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Jun 6 01:16:30 2011 -0600

    spi: reorganize drivers
    
    Sort the SPI makefile and enforce the naming convention spi_*.c for
    spi drivers.
    
    This change also rolls the contents of atmel_spi.h into the .c file
    since there is only one user of that particular include file.
    
    v2: - Use 'spi-' prefix instead of 'spi_' to match what seems to be
          be the predominant pattern for subsystem prefixes.
        - Clean up filenames in Kconfig and header comment blocks
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/spi/spi-omap-uwire.c b/drivers/spi/spi-omap-uwire.c
new file mode 100644
index 000000000000..00a8e9d7dbe4
--- /dev/null
+++ b/drivers/spi/spi-omap-uwire.c
@@ -0,0 +1,593 @@
+/*
+ * MicroWire interface driver for OMAP
+ *
+ * Copyright 2003 MontaVista Software Inc. <source@mvista.com>
+ *
+ * Ported to 2.6 OMAP uwire interface.
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * Generalization patches by Juha Yrjola <juha.yrjola@nokia.com>
+ *
+ * Copyright (C) 2005 David Brownell (ported to 2.6 SPI interface)
+ * Copyright (C) 2006 Nokia
+ *
+ * Many updates by Imre Deak <imre.deak@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/mach-types.h>
+
+#include <plat/mux.h>
+#include <plat/omap7xx.h>	/* OMAP7XX_IO_CONF registers */
+
+
+/* FIXME address is now a platform device resource,
+ * and irqs should show there too...
+ */
+#define UWIRE_BASE_PHYS		0xFFFB3000
+
+/* uWire Registers: */
+#define UWIRE_IO_SIZE 0x20
+#define UWIRE_TDR     0x00
+#define UWIRE_RDR     0x00
+#define UWIRE_CSR     0x01
+#define UWIRE_SR1     0x02
+#define UWIRE_SR2     0x03
+#define UWIRE_SR3     0x04
+#define UWIRE_SR4     0x05
+#define UWIRE_SR5     0x06
+
+/* CSR bits */
+#define	RDRB	(1 << 15)
+#define	CSRB	(1 << 14)
+#define	START	(1 << 13)
+#define	CS_CMD	(1 << 12)
+
+/* SR1 or SR2 bits */
+#define UWIRE_READ_FALLING_EDGE		0x0001
+#define UWIRE_READ_RISING_EDGE		0x0000
+#define UWIRE_WRITE_FALLING_EDGE	0x0000
+#define UWIRE_WRITE_RISING_EDGE		0x0002
+#define UWIRE_CS_ACTIVE_LOW		0x0000
+#define UWIRE_CS_ACTIVE_HIGH		0x0004
+#define UWIRE_FREQ_DIV_2		0x0000
+#define UWIRE_FREQ_DIV_4		0x0008
+#define UWIRE_FREQ_DIV_8		0x0010
+#define UWIRE_CHK_READY			0x0020
+#define UWIRE_CLK_INVERTED		0x0040
+
+
+struct uwire_spi {
+	struct spi_bitbang	bitbang;
+	struct clk		*ck;
+};
+
+struct uwire_state {
+	unsigned	bits_per_word;
+	unsigned	div1_idx;
+};
+
+/* REVISIT compile time constant for idx_shift? */
+/*
+ * Or, put it in a structure which is used throughout the driver;
+ * that avoids having to issue two loads for each bit of static data.
+ */
+static unsigned int uwire_idx_shift;
+static void __iomem *uwire_base;
+
+static inline void uwire_write_reg(int idx, u16 val)
+{
+	__raw_writew(val, uwire_base + (idx << uwire_idx_shift));
+}
+
+static inline u16 uwire_read_reg(int idx)
+{
+	return __raw_readw(uwire_base + (idx << uwire_idx_shift));
+}
+
+static inline void omap_uwire_configure_mode(u8 cs, unsigned long flags)
+{
+	u16	w, val = 0;
+	int	shift, reg;
+
+	if (flags & UWIRE_CLK_INVERTED)
+		val ^= 0x03;
+	val = flags & 0x3f;
+	if (cs & 1)
+		shift = 6;
+	else
+		shift = 0;
+	if (cs <= 1)
+		reg = UWIRE_SR1;
+	else
+		reg = UWIRE_SR2;
+
+	w = uwire_read_reg(reg);
+	w &= ~(0x3f << shift);
+	w |= val << shift;
+	uwire_write_reg(reg, w);
+}
+
+static int wait_uwire_csr_flag(u16 mask, u16 val, int might_not_catch)
+{
+	u16 w;
+	int c = 0;
+	unsigned long max_jiffies = jiffies + HZ;
+
+	for (;;) {
+		w = uwire_read_reg(UWIRE_CSR);
+		if ((w & mask) == val)
+			break;
+		if (time_after(jiffies, max_jiffies)) {
+			printk(KERN_ERR "%s: timeout. reg=%#06x "
+					"mask=%#06x val=%#06x\n",
+			       __func__, w, mask, val);
+			return -1;
+		}
+		c++;
+		if (might_not_catch && c > 64)
+			break;
+	}
+	return 0;
+}
+
+static void uwire_set_clk1_div(int div1_idx)
+{
+	u16 w;
+
+	w = uwire_read_reg(UWIRE_SR3);
+	w &= ~(0x03 << 1);
+	w |= div1_idx << 1;
+	uwire_write_reg(UWIRE_SR3, w);
+}
+
+static void uwire_chipselect(struct spi_device *spi, int value)
+{
+	struct	uwire_state *ust = spi->controller_state;
+	u16	w;
+	int	old_cs;
+
+
+	BUG_ON(wait_uwire_csr_flag(CSRB, 0, 0));
+
+	w = uwire_read_reg(UWIRE_CSR);
+	old_cs = (w >> 10) & 0x03;
+	if (value == BITBANG_CS_INACTIVE || old_cs != spi->chip_select) {
+		/* Deselect this CS, or the previous CS */
+		w &= ~CS_CMD;
+		uwire_write_reg(UWIRE_CSR, w);
+	}
+	/* activate specfied chipselect */
+	if (value == BITBANG_CS_ACTIVE) {
+		uwire_set_clk1_div(ust->div1_idx);
+		/* invert clock? */
+		if (spi->mode & SPI_CPOL)
+			uwire_write_reg(UWIRE_SR4, 1);
+		else
+			uwire_write_reg(UWIRE_SR4, 0);
+
+		w = spi->chip_select << 10;
+		w |= CS_CMD;
+		uwire_write_reg(UWIRE_CSR, w);
+	}
+}
+
+static int uwire_txrx(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct uwire_state *ust = spi->controller_state;
+	unsigned	len = t->len;
+	unsigned	bits = ust->bits_per_word;
+	unsigned	bytes;
+	u16		val, w;
+	int		status = 0;
+
+	if (!t->tx_buf && !t->rx_buf)
+		return 0;
+
+	/* Microwire doesn't read and write concurrently */
+	if (t->tx_buf && t->rx_buf)
+		return -EPERM;
+
+	w = spi->chip_select << 10;
+	w |= CS_CMD;
+
+	if (t->tx_buf) {
+		const u8	*buf = t->tx_buf;
+
+		/* NOTE:  DMA could be used for TX transfers */
+
+		/* write one or two bytes at a time */
+		while (len >= 1) {
+			/* tx bit 15 is first sent; we byteswap multibyte words
+			 * (msb-first) on the way out from memory.
+			 */
+			val = *buf++;
+			if (bits > 8) {
+				bytes = 2;
+				val |= *buf++ << 8;
+			} else
+				bytes = 1;
+			val <<= 16 - bits;
+
+#ifdef	VERBOSE
+			pr_debug("%s: write-%d =%04x\n",
+					dev_name(&spi->dev), bits, val);
+#endif
+			if (wait_uwire_csr_flag(CSRB, 0, 0))
+				goto eio;
+
+			uwire_write_reg(UWIRE_TDR, val);
+
+			/* start write */
+			val = START | w | (bits << 5);
+
+			uwire_write_reg(UWIRE_CSR, val);
+			len -= bytes;
+
+			/* Wait till write actually starts.
+			 * This is needed with MPU clock 60+ MHz.
+			 * REVISIT: we may not have time to catch it...
+			 */
+			if (wait_uwire_csr_flag(CSRB, CSRB, 1))
+				goto eio;
+
+			status += bytes;
+		}
+
+		/* REVISIT:  save this for later to get more i/o overlap */
+		if (wait_uwire_csr_flag(CSRB, 0, 0))
+			goto eio;
+
+	} else if (t->rx_buf) {
+		u8		*buf = t->rx_buf;
+
+		/* read one or two bytes at a time */
+		while (len) {
+			if (bits > 8) {
+				bytes = 2;
+			} else
+				bytes = 1;
+
+			/* start read */
+			val = START | w | (bits << 0);
+			uwire_write_reg(UWIRE_CSR, val);
+			len -= bytes;
+
+			/* Wait till read actually starts */
+			(void) wait_uwire_csr_flag(CSRB, CSRB, 1);
+
+			if (wait_uwire_csr_flag(RDRB | CSRB,
+						RDRB, 0))
+				goto eio;
+
+			/* rx bit 0 is last received; multibyte words will
+			 * be properly byteswapped on the way to memory.
+			 */
+			val = uwire_read_reg(UWIRE_RDR);
+			val &= (1 << bits) - 1;
+			*buf++ = (u8) val;
+			if (bytes == 2)
+				*buf++ = val >> 8;
+			status += bytes;
+#ifdef	VERBOSE
+			pr_debug("%s: read-%d =%04x\n",
+					dev_name(&spi->dev), bits, val);
+#endif
+
+		}
+	}
+	return status;
+eio:
+	return -EIO;
+}
+
+static int uwire_setup_transfer(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct uwire_state	*ust = spi->controller_state;
+	struct uwire_spi	*uwire;
+	unsigned		flags = 0;
+	unsigned		bits;
+	unsigned		hz;
+	unsigned long		rate;
+	int			div1_idx;
+	int			div1;
+	int			div2;
+	int			status;
+
+	uwire = spi_master_get_devdata(spi->master);
+
+	if (spi->chip_select > 3) {
+		pr_debug("%s: cs%d?\n", dev_name(&spi->dev), spi->chip_select);
+		status = -ENODEV;
+		goto done;
+	}
+
+	bits = spi->bits_per_word;
+	if (t != NULL && t->bits_per_word)
+		bits = t->bits_per_word;
+
+	if (bits > 16) {
+		pr_debug("%s: wordsize %d?\n", dev_name(&spi->dev), bits);
+		status = -ENODEV;
+		goto done;
+	}
+	ust->bits_per_word = bits;
+
+	/* mode 0..3, clock inverted separately;
+	 * standard nCS signaling;
+	 * don't treat DI=high as "not ready"
+	 */
+	if (spi->mode & SPI_CS_HIGH)
+		flags |= UWIRE_CS_ACTIVE_HIGH;
+
+	if (spi->mode & SPI_CPOL)
+		flags |= UWIRE_CLK_INVERTED;
+
+	switch (spi->mode & (SPI_CPOL | SPI_CPHA)) {
+	case SPI_MODE_0:
+	case SPI_MODE_3:
+		flags |= UWIRE_WRITE_FALLING_EDGE | UWIRE_READ_RISING_EDGE;
+		break;
+	case SPI_MODE_1:
+	case SPI_MODE_2:
+		flags |= UWIRE_WRITE_RISING_EDGE | UWIRE_READ_FALLING_EDGE;
+		break;
+	}
+
+	/* assume it's already enabled */
+	rate = clk_get_rate(uwire->ck);
+
+	hz = spi->max_speed_hz;
+	if (t != NULL && t->speed_hz)
+		hz = t->speed_hz;
+
+	if (!hz) {
+		pr_debug("%s: zero speed?\n", dev_name(&spi->dev));
+		status = -EINVAL;
+		goto done;
+	}
+
+	/* F_INT = mpu_xor_clk / DIV1 */
+	for (div1_idx = 0; div1_idx < 4; div1_idx++) {
+		switch (div1_idx) {
+		case 0:
+			div1 = 2;
+			break;
+		case 1:
+			div1 = 4;
+			break;
+		case 2:
+			div1 = 7;
+			break;
+		default:
+		case 3:
+			div1 = 10;
+			break;
+		}
+		div2 = (rate / div1 + hz - 1) / hz;
+		if (div2 <= 8)
+			break;
+	}
+	if (div1_idx == 4) {
+		pr_debug("%s: lowest clock %ld, need %d\n",
+			dev_name(&spi->dev), rate / 10 / 8, hz);
+		status = -EDOM;
+		goto done;
+	}
+
+	/* we have to cache this and reset in uwire_chipselect as this is a
+	 * global parameter and another uwire device can change it under
+	 * us */
+	ust->div1_idx = div1_idx;
+	uwire_set_clk1_div(div1_idx);
+
+	rate /= div1;
+
+	switch (div2) {
+	case 0:
+	case 1:
+	case 2:
+		flags |= UWIRE_FREQ_DIV_2;
+		rate /= 2;
+		break;
+	case 3:
+	case 4:
+		flags |= UWIRE_FREQ_DIV_4;
+		rate /= 4;
+		break;
+	case 5:
+	case 6:
+	case 7:
+	case 8:
+		flags |= UWIRE_FREQ_DIV_8;
+		rate /= 8;
+		break;
+	}
+	omap_uwire_configure_mode(spi->chip_select, flags);
+	pr_debug("%s: uwire flags %02x, armxor %lu KHz, SCK %lu KHz\n",
+			__func__, flags,
+			clk_get_rate(uwire->ck) / 1000,
+			rate / 1000);
+	status = 0;
+done:
+	return status;
+}
+
+static int uwire_setup(struct spi_device *spi)
+{
+	struct uwire_state *ust = spi->controller_state;
+
+	if (ust == NULL) {
+		ust = kzalloc(sizeof(*ust), GFP_KERNEL);
+		if (ust == NULL)
+			return -ENOMEM;
+		spi->controller_state = ust;
+	}
+
+	return uwire_setup_transfer(spi, NULL);
+}
+
+static void uwire_cleanup(struct spi_device *spi)
+{
+	kfree(spi->controller_state);
+}
+
+static void uwire_off(struct uwire_spi *uwire)
+{
+	uwire_write_reg(UWIRE_SR3, 0);
+	clk_disable(uwire->ck);
+	clk_put(uwire->ck);
+	spi_master_put(uwire->bitbang.master);
+}
+
+static int __init uwire_probe(struct platform_device *pdev)
+{
+	struct spi_master	*master;
+	struct uwire_spi	*uwire;
+	int			status;
+
+	master = spi_alloc_master(&pdev->dev, sizeof *uwire);
+	if (!master)
+		return -ENODEV;
+
+	uwire = spi_master_get_devdata(master);
+
+	uwire_base = ioremap(UWIRE_BASE_PHYS, UWIRE_IO_SIZE);
+	if (!uwire_base) {
+		dev_dbg(&pdev->dev, "can't ioremap UWIRE\n");
+		spi_master_put(master);
+		return -ENOMEM;
+	}
+
+	dev_set_drvdata(&pdev->dev, uwire);
+
+	uwire->ck = clk_get(&pdev->dev, "fck");
+	if (IS_ERR(uwire->ck)) {
+		status = PTR_ERR(uwire->ck);
+		dev_dbg(&pdev->dev, "no functional clock?\n");
+		spi_master_put(master);
+		return status;
+	}
+	clk_enable(uwire->ck);
+
+	if (cpu_is_omap7xx())
+		uwire_idx_shift = 1;
+	else
+		uwire_idx_shift = 2;
+
+	uwire_write_reg(UWIRE_SR3, 1);
+
+	/* the spi->mode bits understood by this driver: */
+	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
+
+	master->flags = SPI_MASTER_HALF_DUPLEX;
+
+	master->bus_num = 2;	/* "official" */
+	master->num_chipselect = 4;
+	master->setup = uwire_setup;
+	master->cleanup = uwire_cleanup;
+
+	uwire->bitbang.master = master;
+	uwire->bitbang.chipselect = uwire_chipselect;
+	uwire->bitbang.setup_transfer = uwire_setup_transfer;
+	uwire->bitbang.txrx_bufs = uwire_txrx;
+
+	status = spi_bitbang_start(&uwire->bitbang);
+	if (status < 0) {
+		uwire_off(uwire);
+		iounmap(uwire_base);
+	}
+	return status;
+}
+
+static int __exit uwire_remove(struct platform_device *pdev)
+{
+	struct uwire_spi	*uwire = dev_get_drvdata(&pdev->dev);
+	int			status;
+
+	// FIXME remove all child devices, somewhere ...
+
+	status = spi_bitbang_stop(&uwire->bitbang);
+	uwire_off(uwire);
+	iounmap(uwire_base);
+	return status;
+}
+
+/* work with hotplug and coldplug */
+MODULE_ALIAS("platform:omap_uwire");
+
+static struct platform_driver uwire_driver = {
+	.driver = {
+		.name		= "omap_uwire",
+		.owner		= THIS_MODULE,
+	},
+	.remove		= __exit_p(uwire_remove),
+	// suspend ... unuse ck
+	// resume ... use ck
+};
+
+static int __init omap_uwire_init(void)
+{
+	/* FIXME move these into the relevant board init code. also, include
+	 * H3 support; it uses tsc2101 like H2 (on a different chipselect).
+	 */
+
+	if (machine_is_omap_h2()) {
+		/* defaults: W21 SDO, U18 SDI, V19 SCL */
+		omap_cfg_reg(N14_1610_UWIRE_CS0);
+		omap_cfg_reg(N15_1610_UWIRE_CS1);
+	}
+	if (machine_is_omap_perseus2()) {
+		/* configure pins: MPU_UW_nSCS1, MPU_UW_SDO, MPU_UW_SCLK */
+		int val = omap_readl(OMAP7XX_IO_CONF_9) & ~0x00EEE000;
+		omap_writel(val | 0x00AAA000, OMAP7XX_IO_CONF_9);
+	}
+
+	return platform_driver_probe(&uwire_driver, uwire_probe);
+}
+
+static void __exit omap_uwire_exit(void)
+{
+	platform_driver_unregister(&uwire_driver);
+}
+
+subsys_initcall(omap_uwire_init);
+module_exit(omap_uwire_exit);
+
+MODULE_LICENSE("GPL");
+
