commit 867bd8868bbd16e17bbd26c5959abc3118902218
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:40 2019 +0300

    spi: spi-loopback-test: use new `delay` field
    
    This change replaces the use of the `delay_usecs` field with the new
    `delay` field. The code/test still uses micro-seconds, but they are now
    configured and used via the `struct spi_delay` format of the `delay` field.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-13-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index 6f18d4952767..b6d79cd156fb 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -298,12 +298,18 @@ static struct spi_test spi_tests[] = {
 			{
 				.tx_buf = TX(0),
 				.rx_buf = RX(0),
-				.delay_usecs = 1000,
+				.delay = {
+					.value = 1000,
+					.unit = SPI_DELAY_UNIT_USECS,
+				},
 			},
 			{
 				.tx_buf = TX(0),
 				.rx_buf = RX(0),
-				.delay_usecs = 1000,
+				.delay = {
+					.value = 1000,
+					.unit = SPI_DELAY_UNIT_USECS,
+				},
 			},
 		},
 	},
@@ -537,7 +543,7 @@ static int spi_test_check_elapsed_time(struct spi_device *spi,
 		unsigned long long nbits = (unsigned long long)BITS_PER_BYTE *
 					   xfer->len;
 
-		delay_usecs += xfer->delay_usecs;
+		delay_usecs += xfer->delay.value;
 		if (!xfer->speed_hz)
 			continue;
 		estimated_time += div_u64(nbits * NSEC_PER_SEC, xfer->speed_hz);

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index bed7403bb6b3..6f18d4952767 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  linux/drivers/spi/spi-loopback-test.c
  *
@@ -6,16 +7,6 @@
  *  Loopback test driver to test several typical spi_message conditions
  *  that a spi_master driver may encounter
  *  this can also get used for regression testing
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
  */
 
 #include <linux/delay.h>

commit 8bc85a871436525cc38f819bbc122d216730e905
Author: Oleksij Rempel <o.rempel@pengutronix.de>
Date:   Tue Jul 25 09:57:08 2017 +0200

    spi: loopback-test: implement testing with no CS
    
    To run spi-loopback-tests on HW without modifications, we need to
    disable Chip Select. This should avoid surprising side effects for
    SPI devices by testing patterns.
    
    Signed-off-by: Oleksij Rempel <o.rempel@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index 64a1e6f212c1..bed7403bb6b3 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -57,6 +57,11 @@ MODULE_PARM_DESC(loop_req,
 		 "if set controller will be asked to enable test loop mode. " \
 		 "If controller supported it, MISO and MOSI will be connected");
 
+static int no_cs;
+module_param(no_cs, int, 0);
+MODULE_PARM_DESC(no_cs,
+		 "if set Chip Select (CS) will not be used");
+
 /* run only a specific test */
 static int run_only_test = -1;
 module_param(run_only_test, int, 0);
@@ -319,11 +324,12 @@ static int spi_loopback_test_probe(struct spi_device *spi)
 {
 	int ret;
 
-	if (loop_req) {
-		spi->mode = SPI_LOOP | spi->mode;
+	if (loop_req || no_cs) {
+		spi->mode |= loop_req ? SPI_LOOP : 0;
+		spi->mode |= no_cs ? SPI_NO_CS : 0;
 		ret = spi_setup(spi);
 		if (ret) {
-			dev_err(&spi->dev, "SPI setup with SPI_LOOP failed (%d)\n",
+			dev_err(&spi->dev, "SPI setup with SPI_LOOP or SPI_NO_CS failed (%d)\n",
 				ret);
 			return ret;
 		}

commit 59a8831da31ebdabf82cac82bf01270d215bf149
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Jul 18 13:42:32 2017 +0100

    spi: loopback-test: make several module parameters static
    
    Several module parameters are local to the source, so make them
    static. Cleans up several sparse warnings such as:
    
    "symbol 'loop_req' was not declared. Should it be static?"
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index 0d3c56e2526c..64a1e6f212c1 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -32,45 +32,45 @@
 #include "spi-test.h"
 
 /* flag to only simulate transfers */
-int simulate_only;
+static int simulate_only;
 module_param(simulate_only, int, 0);
 MODULE_PARM_DESC(simulate_only, "if not 0 do not execute the spi message");
 
 /* dump spi messages */
-int dump_messages;
+static int dump_messages;
 module_param(dump_messages, int, 0);
 MODULE_PARM_DESC(dump_messages,
 		 "=1 dump the basic spi_message_structure, " \
 		 "=2 dump the spi_message_structure including data, " \
 		 "=3 dump the spi_message structure before and after execution");
 /* the device is jumpered for loopback - enabling some rx_buf tests */
-int loopback;
+static int loopback;
 module_param(loopback, int, 0);
 MODULE_PARM_DESC(loopback,
 		 "if set enable loopback mode, where the rx_buf "	\
 		 "is checked to match tx_buf after the spi_message "	\
 		 "is executed");
 
-int loop_req;
+static int loop_req;
 module_param(loop_req, int, 0);
 MODULE_PARM_DESC(loop_req,
 		 "if set controller will be asked to enable test loop mode. " \
 		 "If controller supported it, MISO and MOSI will be connected");
 
 /* run only a specific test */
-int run_only_test = -1;
+static int run_only_test = -1;
 module_param(run_only_test, int, 0);
 MODULE_PARM_DESC(run_only_test,
 		 "only run the test with this number (0-based !)");
 
 /* use vmalloc'ed buffers */
-int use_vmalloc;
+static int use_vmalloc;
 module_param(use_vmalloc, int, 0644);
 MODULE_PARM_DESC(use_vmalloc,
 		 "use vmalloc'ed buffers instead of kmalloc'ed");
 
 /* check rx ranges */
-int check_ranges = 1;
+static int check_ranges = 1;
 module_param(check_ranges, int, 0644);
 MODULE_PARM_DESC(check_ranges,
 		 "checks rx_buffer pattern are valid");

commit f12a616e0cdee71440b72f7602825db424d37879
Author: Oleksij Rempel <o.rempel@pengutronix.de>
Date:   Fri Jul 14 11:42:46 2017 +0200

    spi: loopback-test: provide loop_req option.
    
    Provide a module parameter to request internal loop by the SPI master
    controller.
    This should make loop testing easier without extra HW modification.
    
    For test automation a logic analyzer is recommended for host
    controller-independent verification.
    An example test rig configuration and procedure:
      i.MX6S RIoRBoard           Logic Analyzer
      -----------------------------------------
      (J13  4) GND ------------- GND
      (J13  6) CSPI3-CLK ------> PIN 3
      (J13  8) CSPI3-MOSI <----- PIN 2
         ^ - internal loop configured by SPI_LOOP
         |   or can be user external jamper.
      (J13 10) CSPI3-MISO -----> PIN 1
    
    grab some data and decode it:
    sigrok-cli -d fx2lafw --time 160000 --config samplerate=10m  \
      --channels 0-2 -o dump.sr
    sigrok-cli -i dump.sr -P spi:mosi=1:clk=2 > result_for_regression_tests
    
    Signed-off-by: Oleksij Rempel <o.rempel@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index 3459965004f8..0d3c56e2526c 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -51,6 +51,12 @@ MODULE_PARM_DESC(loopback,
 		 "is checked to match tx_buf after the spi_message "	\
 		 "is executed");
 
+int loop_req;
+module_param(loop_req, int, 0);
+MODULE_PARM_DESC(loop_req,
+		 "if set controller will be asked to enable test loop mode. " \
+		 "If controller supported it, MISO and MOSI will be connected");
+
 /* run only a specific test */
 int run_only_test = -1;
 module_param(run_only_test, int, 0);
@@ -313,6 +319,16 @@ static int spi_loopback_test_probe(struct spi_device *spi)
 {
 	int ret;
 
+	if (loop_req) {
+		spi->mode = SPI_LOOP | spi->mode;
+		ret = spi_setup(spi);
+		if (ret) {
+			dev_err(&spi->dev, "SPI setup with SPI_LOOP failed (%d)\n",
+				ret);
+			return ret;
+		}
+	}
+
 	dev_info(&spi->dev, "Executing spi-loopback-tests\n");
 
 	ret = spi_test_run_tests(spi, spi_tests);

commit 704c3098e4c55a409eaf5ec89cee1bccc8d44f4c
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Tue Jun 20 15:00:53 2017 +0530

    spi: loopback-test: Fix kfree() NULL pointer error.
    
    Here, rx/tx allocation can fail. So avoid kvfree call
    with NULL pointer.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index 514997a143dc..3459965004f8 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -1021,10 +1021,9 @@ int spi_test_run_tests(struct spi_device *spi,
 		rx = vmalloc(SPI_TEST_MAX_SIZE_PLUS);
 	else
 		rx = kzalloc(SPI_TEST_MAX_SIZE_PLUS, GFP_KERNEL);
-	if (!rx) {
-		ret = -ENOMEM;
-		goto out;
-	}
+	if (!rx)
+		return -ENOMEM;
+
 
 	if (use_vmalloc)
 		tx = vmalloc(SPI_TEST_MAX_SIZE_PLUS);
@@ -1032,7 +1031,7 @@ int spi_test_run_tests(struct spi_device *spi,
 		tx = kzalloc(SPI_TEST_MAX_SIZE_PLUS, GFP_KERNEL);
 	if (!tx) {
 		ret = -ENOMEM;
-		goto out;
+		goto err_tx;
 	}
 
 	/* now run the individual tests in the table */
@@ -1057,8 +1056,9 @@ int spi_test_run_tests(struct spi_device *spi,
 	}
 
 out:
-	kvfree(rx);
 	kvfree(tx);
+err_tx:
+	kvfree(rx);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(spi_test_run_tests);

commit 478de2ba0d2dafcd460b17f032139e2b6b4eb1ac
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Jun 26 14:42:31 2017 +0100

    spi: loopback-test: fix spelling mistake: "reruning" -> "rerunning"
    
    trivial fix to spelling mistake in dev_info error message
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index f4875f177df0..514997a143dc 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -894,7 +894,7 @@ int spi_test_execute_msg(struct spi_device *spi, struct spi_test *test,
 		test->elapsed_time = ktime_to_ns(ktime_sub(ktime_get(), start));
 		if (ret == -ETIMEDOUT) {
 			dev_info(&spi->dev,
-				 "spi-message timed out - reruning...\n");
+				 "spi-message timed out - rerunning...\n");
 			/* rerun after a few explicit schedules */
 			for (i = 0; i < 16; i++)
 				schedule();

commit d8f520727f769164fa6ff0ad4a4d965336966999
Merge: fbdd1b2affbd 91b4634632e0 9006a7b3220e 3288d5cb40c0 bfca76185d9b 905e0b5ef969
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Apr 26 15:58:16 2017 +0100

    Merge remote-tracking branches 'spi/topic/spidev', 'spi/topic/spidev-test', 'spi/topic/sunxi', 'spi/topic/tegra' and 'spi/topic/test' into spi-next

commit 905e0b5ef9690c5433b642f46f1d756bb374da17
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Mar 30 11:01:25 2017 +0100

    spi: loopback-test: fix spelling mistake: "minimam" -> "minimum"
    
    trivial fix to spelling mistake in dev_err error message
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index 6888d5c34ac4..e6041539afed 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -520,7 +520,7 @@ static int spi_test_check_elapsed_time(struct spi_device *spi,
 	estimated_time += delay_usecs * NSEC_PER_USEC;
 	if (test->elapsed_time < estimated_time) {
 		dev_err(&spi->dev,
-			"elapsed time %lld ns is shorter than minimam estimated time %lld ns\n",
+			"elapsed time %lld ns is shorter than minimum estimated time %lld ns\n",
 			test->elapsed_time, estimated_time);
 
 		return -EINVAL;

commit d2c14c64d678713fced6f2261ce7d398b4351de5
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Mar 20 13:58:05 2017 +0000

    spi: loopback-test: fix potential integer overflow on multiple
    
    A multiplication of 8U * xfer-len with the type of a 32 bit unsigned int
    is evaluated using 32 bit arithmetic and then used in a context that
    expects an expression of type unsigned long long (64 bits).  Avoid any
    potential overflow by casting BITS_PER_BYTE to unsigned long long.
    
    Detected by CoverityScan, CID#1419691 ("Unintentional integer overflow")
    
    Fixes: ea9936f324356 ("spi: loopback-test: add elapsed time check")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index fcae3377ec26..6888d5c34ac4 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -508,7 +508,8 @@ static int spi_test_check_elapsed_time(struct spi_device *spi,
 
 	for (i = 0; i < test->transfer_count; i++) {
 		struct spi_transfer *xfer = test->transfers + i;
-		unsigned long long nbits = BITS_PER_BYTE * xfer->len;
+		unsigned long long nbits = (unsigned long long)BITS_PER_BYTE *
+					   xfer->len;
 
 		delay_usecs += xfer->delay_usecs;
 		if (!xfer->speed_hz)

commit 8687113e1515f4c9104a6eaedc384ec762c6550f
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Sat Mar 18 03:17:31 2017 +0900

    spi: loopback-test: add test spi_message with delay after transfers
    
    This adds a new test to check whether the spi_transfer.delay_usecs
    setting has properly taken effect.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index 66e8cfd04395..fcae3377ec26 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -273,6 +273,25 @@ static struct spi_test spi_tests[] = {
 			},
 		},
 	},
+	{
+		.description	= "two tx+rx transfers - delay after transfer",
+		.fill_option	= FILL_COUNT_8,
+		.iterate_len    = { ITERATE_MAX_LEN },
+		.iterate_transfer_mask = BIT(0) | BIT(1),
+		.transfer_count = 2,
+		.transfers		= {
+			{
+				.tx_buf = TX(0),
+				.rx_buf = RX(0),
+				.delay_usecs = 1000,
+			},
+			{
+				.tx_buf = TX(0),
+				.rx_buf = RX(0),
+				.delay_usecs = 1000,
+			},
+		},
+	},
 
 	{ /* end of tests sequence */ }
 };

commit ea9936f32435699907807aaac87f993482208578
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Sat Mar 18 03:17:30 2017 +0900

    spi: loopback-test: add elapsed time check
    
    This adds checks whether the elapsed time is longer than the minimam
    estimated time.  The estimated time is calculated with the total
    transfer length per clock rate and optional spi_transfer.delay_usecs.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index 6df6dddc2890..66e8cfd04395 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -20,6 +20,7 @@
 
 #include <linux/delay.h>
 #include <linux/kernel.h>
+#include <linux/ktime.h>
 #include <linux/list.h>
 #include <linux/list_sort.h>
 #include <linux/module.h>
@@ -479,6 +480,35 @@ static int spi_check_rx_ranges(struct spi_device *spi,
 	return ret;
 }
 
+static int spi_test_check_elapsed_time(struct spi_device *spi,
+				       struct spi_test *test)
+{
+	int i;
+	unsigned long long estimated_time = 0;
+	unsigned long long delay_usecs = 0;
+
+	for (i = 0; i < test->transfer_count; i++) {
+		struct spi_transfer *xfer = test->transfers + i;
+		unsigned long long nbits = BITS_PER_BYTE * xfer->len;
+
+		delay_usecs += xfer->delay_usecs;
+		if (!xfer->speed_hz)
+			continue;
+		estimated_time += div_u64(nbits * NSEC_PER_SEC, xfer->speed_hz);
+	}
+
+	estimated_time += delay_usecs * NSEC_PER_USEC;
+	if (test->elapsed_time < estimated_time) {
+		dev_err(&spi->dev,
+			"elapsed time %lld ns is shorter than minimam estimated time %lld ns\n",
+			test->elapsed_time, estimated_time);
+
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static int spi_test_check_loopback_result(struct spi_device *spi,
 					  struct spi_message *msg,
 					  void *tx, void *rx)
@@ -817,12 +847,16 @@ int spi_test_execute_msg(struct spi_device *spi, struct spi_test *test,
 
 	/* only if we do not simulate */
 	if (!simulate_only) {
+		ktime_t start;
+
 		/* dump the complete message before and after the transfer */
 		if (dump_messages == 3)
 			spi_test_dump_message(spi, msg, true);
 
+		start = ktime_get();
 		/* run spi message */
 		ret = spi_sync(spi, msg);
+		test->elapsed_time = ktime_to_ns(ktime_sub(ktime_get(), start));
 		if (ret == -ETIMEDOUT) {
 			dev_info(&spi->dev,
 				 "spi-message timed out - reruning...\n");
@@ -848,6 +882,10 @@ int spi_test_execute_msg(struct spi_device *spi, struct spi_test *test,
 
 		/* run rx-buffer tests */
 		ret = spi_test_check_loopback_result(spi, msg, tx, rx);
+		if (ret)
+			goto exit;
+
+		ret = spi_test_check_elapsed_time(spi, test);
 	}
 
 	/* if requested or on error dump message (including data) */

commit 8916671e93a38c509e2ffb02c2ce3f37efe8af40
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Sat Mar 18 03:17:28 2017 +0900

    spi: loopback-test: add ability to test zero-length transfer
    
    The spi-loopback-test module currently cannot test the spi_message
    including a zero-length transfer.  Because the zero-length transfer is
    treated as a special value in several meanings.
    
    1. The number of spi_transfer to execute in one test case is described
    by spi_test.transfer_count.  It is normally computed by counting number
    of transfers with len > 0 in spi_test.transfers array.
    
    This change stops the detection for the number of spi_transfer.  Each
    spi_test.transfer_count needs to be filled by hand now.
    
    2. The spi_test.iterate_len is a list of transfer length to iterate on.
    This list is terminated by zero, so zero-length transfer cannot be
    included.
    
    This changes the terminal value from 0 to -1.
    
    3. The length for the spi_transfer masked by spi_test.iterate_transfer_mask
    is iterated.  Before starting the iteration, the default value which
    is statically initialized is applied.  In order to specify the default
    value, zero-length is reserved.
    
    Currently, the default values are always '1'.  So this removes this
    trick and add '1' to iterate_len list.
    
    By applying all these changes, the spi-loopback-test can execute spi
    messages with zero-length transfer.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index 85c0c4e391d9..6df6dddc2890 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -63,9 +63,9 @@ static struct spi_test spi_tests[] = {
 		.iterate_len    = { ITERATE_MAX_LEN },
 		.iterate_tx_align = ITERATE_ALIGN,
 		.iterate_rx_align = ITERATE_ALIGN,
+		.transfer_count = 1,
 		.transfers		= {
 			{
-				.len = 1,
 				.tx_buf = TX(0),
 				.rx_buf = RX(0),
 			},
@@ -77,9 +77,9 @@ static struct spi_test spi_tests[] = {
 		.iterate_len    = { ITERATE_MAX_LEN },
 		.iterate_tx_align = ITERATE_ALIGN,
 		.iterate_rx_align = ITERATE_ALIGN,
+		.transfer_count = 1,
 		.transfers		= {
 			{
-				.len = 1,
 				.tx_buf = TX(PAGE_SIZE - 4),
 				.rx_buf = RX(PAGE_SIZE - 4),
 			},
@@ -90,9 +90,9 @@ static struct spi_test spi_tests[] = {
 		.fill_option	= FILL_COUNT_8,
 		.iterate_len    = { ITERATE_MAX_LEN },
 		.iterate_tx_align = ITERATE_ALIGN,
+		.transfer_count = 1,
 		.transfers		= {
 			{
-				.len = 1,
 				.tx_buf = TX(0),
 			},
 		},
@@ -102,9 +102,9 @@ static struct spi_test spi_tests[] = {
 		.fill_option	= FILL_COUNT_8,
 		.iterate_len    = { ITERATE_MAX_LEN },
 		.iterate_rx_align = ITERATE_ALIGN,
+		.transfer_count = 1,
 		.transfers		= {
 			{
-				.len = 1,
 				.rx_buf = RX(0),
 			},
 		},
@@ -115,13 +115,12 @@ static struct spi_test spi_tests[] = {
 		.iterate_len    = { ITERATE_LEN },
 		.iterate_tx_align = ITERATE_ALIGN,
 		.iterate_transfer_mask = BIT(0) | BIT(1),
+		.transfer_count = 2,
 		.transfers		= {
 			{
-				.len = 1,
 				.tx_buf = TX(0),
 			},
 			{
-				.len = 1,
 				/* this is why we cant use ITERATE_MAX_LEN */
 				.tx_buf = TX(SPI_TEST_MAX_SIZE_HALF),
 			},
@@ -133,9 +132,9 @@ static struct spi_test spi_tests[] = {
 		.iterate_len    = { ITERATE_MAX_LEN },
 		.iterate_tx_align = ITERATE_ALIGN,
 		.iterate_transfer_mask = BIT(0),
+		.transfer_count = 2,
 		.transfers		= {
 			{
-				.len = 1,
 				.tx_buf = TX(64),
 			},
 			{
@@ -150,13 +149,13 @@ static struct spi_test spi_tests[] = {
 		.iterate_len    = { ITERATE_MAX_LEN },
 		.iterate_tx_align = ITERATE_ALIGN,
 		.iterate_transfer_mask = BIT(1),
+		.transfer_count = 2,
 		.transfers		= {
 			{
 				.len = 16,
 				.tx_buf = TX(0),
 			},
 			{
-				.len = 1,
 				.tx_buf = TX(64),
 			},
 		},
@@ -167,13 +166,12 @@ static struct spi_test spi_tests[] = {
 		.iterate_len    = { ITERATE_MAX_LEN },
 		.iterate_tx_align = ITERATE_ALIGN,
 		.iterate_transfer_mask = BIT(0) | BIT(1),
+		.transfer_count = 2,
 		.transfers		= {
 			{
-				.len = 1,
 				.tx_buf = TX(0),
 			},
 			{
-				.len = 1,
 				.rx_buf = RX(0),
 			},
 		},
@@ -184,9 +182,9 @@ static struct spi_test spi_tests[] = {
 		.iterate_len    = { ITERATE_MAX_LEN },
 		.iterate_tx_align = ITERATE_ALIGN,
 		.iterate_transfer_mask = BIT(0),
+		.transfer_count = 2,
 		.transfers		= {
 			{
-				.len = 1,
 				.tx_buf = TX(0),
 			},
 			{
@@ -201,13 +199,13 @@ static struct spi_test spi_tests[] = {
 		.iterate_len    = { ITERATE_MAX_LEN },
 		.iterate_tx_align = ITERATE_ALIGN,
 		.iterate_transfer_mask = BIT(1),
+		.transfer_count = 2,
 		.transfers		= {
 			{
 				.len = 1,
 				.tx_buf = TX(0),
 			},
 			{
-				.len = 1,
 				.rx_buf = RX(0),
 			},
 		},
@@ -218,14 +216,13 @@ static struct spi_test spi_tests[] = {
 		.iterate_len    = { ITERATE_LEN },
 		.iterate_tx_align = ITERATE_ALIGN,
 		.iterate_transfer_mask = BIT(0) | BIT(1),
+		.transfer_count = 2,
 		.transfers		= {
 			{
-				.len = 1,
 				.tx_buf = TX(0),
 				.rx_buf = RX(0),
 			},
 			{
-				.len = 1,
 				/* making sure we align without overwrite
 				 * the reason we can not use ITERATE_MAX_LEN
 				 */
@@ -240,9 +237,9 @@ static struct spi_test spi_tests[] = {
 		.iterate_len    = { ITERATE_MAX_LEN },
 		.iterate_tx_align = ITERATE_ALIGN,
 		.iterate_transfer_mask = BIT(0),
+		.transfer_count = 2,
 		.transfers		= {
 			{
-				.len = 1,
 				/* making sure we align without overwrite */
 				.tx_buf = TX(1024),
 				.rx_buf = RX(1024),
@@ -261,6 +258,7 @@ static struct spi_test spi_tests[] = {
 		.iterate_len    = { ITERATE_MAX_LEN },
 		.iterate_tx_align = ITERATE_ALIGN,
 		.iterate_transfer_mask = BIT(1),
+		.transfer_count = 2,
 		.transfers		= {
 			{
 				.len = 1,
@@ -268,7 +266,6 @@ static struct spi_test spi_tests[] = {
 				.rx_buf = RX(0),
 			},
 			{
-				.len = 1,
 				/* making sure we align without overwrite */
 				.tx_buf = TX(1024),
 				.rx_buf = RX(1024),
@@ -503,7 +500,7 @@ static int spi_test_check_loopback_result(struct spi_device *spi,
 	/* if applicable to transfer check that rx_buf is equal to tx_buf */
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		/* if there is no rx, then no check is needed */
-		if (!xfer->rx_buf)
+		if (!xfer->len || !xfer->rx_buf)
 			continue;
 		/* so depending on tx_buf we need to handle things */
 		if (xfer->tx_buf) {
@@ -745,15 +742,6 @@ static int spi_test_run_iter(struct spi_device *spi,
 	/* copy the test template to test */
 	memcpy(&test, testtemplate, sizeof(test));
 
-	/* set up test->transfers to the correct count */
-	if (!test.transfer_count) {
-		for (i = 0;
-		    (i < SPI_TEST_MAX_TRANSFERS) && test.transfers[i].len;
-		    i++) {
-			test.transfer_count++;
-		}
-	}
-
 	/* if iterate_transfer_mask is not set,
 	 * then set it to first transfer only
 	 */
@@ -799,8 +787,7 @@ static int spi_test_run_iter(struct spi_device *spi,
 		/* only when bit in transfer mask is set */
 		if (!(test.iterate_transfer_mask & BIT(i)))
 			continue;
-		if (len)
-			test.transfers[i].len = len;
+		test.transfers[i].len = len;
 		if (test.transfers[i].tx_buf)
 			test.transfers[i].tx_buf += tx_off;
 		if (test.transfers[i].tx_buf)
@@ -910,15 +897,6 @@ int spi_test_run_test(struct spi_device *spi, const struct spi_test *test,
 	/* iterate over all the iterable values using macros
 	 * (to make it a bit more readable...
 	 */
-#define FOR_EACH_ITERATE(var, defaultvalue)				\
-	for (idx_##var = -1, var = defaultvalue;			\
-	     ((idx_##var < 0) ||					\
-		     (							\
-			     (idx_##var < SPI_TEST_MAX_ITERATE) &&	\
-			     (var = test->iterate_##var[idx_##var])	\
-		     )							\
-	     );								\
-	     idx_##var++)
 #define FOR_EACH_ALIGNMENT(var)						\
 	for (var = 0;							\
 	    var < (test->iterate_##var ?				\
@@ -928,7 +906,8 @@ int spi_test_run_test(struct spi_device *spi, const struct spi_test *test,
 			1);						\
 	    var++)
 
-	FOR_EACH_ITERATE(len, 0) {
+	for (idx_len = 0; idx_len < SPI_TEST_MAX_ITERATE &&
+	     (len = test->iterate_len[idx_len]) != -1; idx_len++) {
 		FOR_EACH_ALIGNMENT(tx_align) {
 			FOR_EACH_ALIGNMENT(rx_align) {
 				/* and run the iteration */

commit 8494801db1fc21867f587dae465236100bf228cc
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Sat Mar 18 03:17:27 2017 +0900

    spi: loopback-test: don't skip comparing the first byte of rx_buf
    
    When the loopback parameter is set, rx_buf are compared with tx_buf
    after the spi_message is executed.  But the first byte of buffer is
    not checked.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index 99422f3a15e0..85c0c4e391d9 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -507,7 +507,7 @@ static int spi_test_check_loopback_result(struct spi_device *spi,
 			continue;
 		/* so depending on tx_buf we need to handle things */
 		if (xfer->tx_buf) {
-			for (i = 1; i < xfer->len; i++) {
+			for (i = 0; i < xfer->len; i++) {
 				txb = ((u8 *)xfer->tx_buf)[i];
 				rxb = ((u8 *)xfer->rx_buf)[i];
 				if (txb != rxb)

commit c4e121aeb754f1ac5f2bcc791aa4177dcfb3b401
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Sat Mar 18 03:17:26 2017 +0900

    spi: loopback-test: correct mismatched test description and configuration
    
    The test "two tx-transfers - alter first" actually alters the second
    not the first transfer.  Similarly the test "two tx-transfers - alter
    second" actually alters the first not the second transfer.
    
    The mismatches for the two symmetrical tests cancel each other's
    mistakes.  But it's better to fix the mismatches to avoid confusion.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index 50e620f4e8fe..99422f3a15e0 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -132,7 +132,7 @@ static struct spi_test spi_tests[] = {
 		.fill_option	= FILL_COUNT_8,
 		.iterate_len    = { ITERATE_MAX_LEN },
 		.iterate_tx_align = ITERATE_ALIGN,
-		.iterate_transfer_mask = BIT(1),
+		.iterate_transfer_mask = BIT(0),
 		.transfers		= {
 			{
 				.len = 1,
@@ -149,7 +149,7 @@ static struct spi_test spi_tests[] = {
 		.fill_option	= FILL_COUNT_8,
 		.iterate_len    = { ITERATE_MAX_LEN },
 		.iterate_tx_align = ITERATE_ALIGN,
-		.iterate_transfer_mask = BIT(0),
+		.iterate_transfer_mask = BIT(1),
 		.transfers		= {
 			{
 				.len = 16,

commit e542f7e63cb17242fcfc1be5edd69532cf434697
Author: Frode Isaksen <fisaksen@baylibre.com>
Date:   Fri Mar 17 12:07:58 2017 +0100

    spi: loopback-test: fix compile error on x86
    
    Fix compile error caused by missing vmalloc() definition
    on x86 (and maybe other platforms) by including vmalloc.h.
    
    Signed-off-by: Frode Isaksen <fisaksen@baylibre.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index 35960515382e..4e7843ec8aac 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -25,6 +25,7 @@
 #include <linux/module.h>
 #include <linux/of_device.h>
 #include <linux/printk.h>
+#include <linux/vmalloc.h>
 #include <linux/spi/spi.h>
 
 #include "spi-test.h"

commit 576333a1fb940767e8638fafea908214682e8acd
Author: Frode Isaksen <fisaksen@baylibre.com>
Date:   Thu Feb 23 19:02:01 2017 +0100

    spi: loopback-test: add option to use vmalloc'ed buffers
    
    Using vmalloc'ed buffers will use one SG entry for each page,
    that may provoke DMA errors for large transfers.
    Also vmalloc'ed buffers may cause errors on CPU's with VIVT cache.
    Add this option to catch these errors when testing.
    Note that to catch VIVT cache errors, checking the rx range
    has to be disabled, so this option has been added as well.
    
    Signed-off-by: Frode Isaksen <fisaksen@baylibre.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index 50e620f4e8fe..35960515382e 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -55,6 +55,18 @@ module_param(run_only_test, int, 0);
 MODULE_PARM_DESC(run_only_test,
 		 "only run the test with this number (0-based !)");
 
+/* use vmalloc'ed buffers */
+int use_vmalloc;
+module_param(use_vmalloc, int, 0644);
+MODULE_PARM_DESC(use_vmalloc,
+		 "use vmalloc'ed buffers instead of kmalloc'ed");
+
+/* check rx ranges */
+int check_ranges = 1;
+module_param(check_ranges, int, 0644);
+MODULE_PARM_DESC(check_ranges,
+		 "checks rx_buffer pattern are valid");
+
 /* the actual tests to execute */
 static struct spi_test spi_tests[] = {
 	{
@@ -492,9 +504,11 @@ static int spi_test_check_loopback_result(struct spi_device *spi,
 	int ret;
 
 	/* checks rx_buffer pattern are valid with loopback or without */
-	ret = spi_check_rx_ranges(spi, msg, rx);
-	if (ret)
-		return ret;
+	if (check_ranges) {
+		ret = spi_check_rx_ranges(spi, msg, rx);
+		if (ret)
+			return ret;
+	}
 
 	/* if we run without loopback, then return now */
 	if (!loopback)
@@ -965,13 +979,19 @@ int spi_test_run_tests(struct spi_device *spi,
 	/* allocate rx/tx buffers of 128kB size without devm
 	 * in the hope that is on a page boundary
 	 */
-	rx = kzalloc(SPI_TEST_MAX_SIZE_PLUS, GFP_KERNEL);
+	if (use_vmalloc)
+		rx = vmalloc(SPI_TEST_MAX_SIZE_PLUS);
+	else
+		rx = kzalloc(SPI_TEST_MAX_SIZE_PLUS, GFP_KERNEL);
 	if (!rx) {
 		ret = -ENOMEM;
 		goto out;
 	}
 
-	tx = kzalloc(SPI_TEST_MAX_SIZE_PLUS, GFP_KERNEL);
+	if (use_vmalloc)
+		tx = vmalloc(SPI_TEST_MAX_SIZE_PLUS);
+	else
+		tx = kzalloc(SPI_TEST_MAX_SIZE_PLUS, GFP_KERNEL);
 	if (!tx) {
 		ret = -ENOMEM;
 		goto out;
@@ -999,8 +1019,8 @@ int spi_test_run_tests(struct spi_device *spi,
 	}
 
 out:
-	kfree(rx);
-	kfree(tx);
+	kvfree(rx);
+	kvfree(tx);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(spi_test_run_tests);

commit dc34b89a8c611946bfa18ddc322d355e97811f01
Author: Baoyou Xie <baoyou.xie@linaro.org>
Date:   Wed Aug 31 17:21:47 2016 +0800

    spi: loopback-test: mark rx_ranges_cmp() static
    
    We get 1 warning when building kernel with W=1:
    drivers/spi/spi-loopback-test.c:408:5: warning: no previous prototype for 'rx_ranges_cmp' [-Wmissing-prototypes]
    
    In fact, this function is only used in the file in which it is
    declared and don't need a declaration, but can be made static.
    So this patch marks it 'static'.
    
    Signed-off-by: Baoyou Xie <baoyou.xie@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index faa1b133b0f1..50e620f4e8fe 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -405,7 +405,7 @@ struct rx_ranges {
 	u8 *end;
 };
 
-int rx_ranges_cmp(void *priv, struct list_head *a, struct list_head *b)
+static int rx_ranges_cmp(void *priv, struct list_head *a, struct list_head *b)
 {
 	struct rx_ranges *rx_a = list_entry(a, struct rx_ranges, list);
 	struct rx_ranges *rx_b = list_entry(b, struct rx_ranges, list);

commit b7ddfb9f496e23eafccd1d630f25b68f105e0ee8
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Jun 28 13:15:08 2016 +0100

    spi: loopback-test: fix spelling mistake: "missmatch" -> "mismatch"
    
    trivial fix to spelling mistake in dev_err message
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index cf4bb36bee25..faa1b133b0f1 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -536,7 +536,7 @@ static int spi_test_check_loopback_result(struct spi_device *spi,
 
 mismatch_error:
 	dev_err(&spi->dev,
-		"loopback strangeness - transfer missmatch on byte %04zx - expected 0x%02x, but got 0x%02x\n",
+		"loopback strangeness - transfer mismatch on byte %04zx - expected 0x%02x, but got 0x%02x\n",
 		i, txb, rxb);
 
 	return -EINVAL;

commit ebea7c0545d4d5e554b84c3ee8072f13c3fdd2ba
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 13 21:51:29 2016 +0100

    spi: fix counting in spi-loopback-test code
    
    These variables are always used uninitialized:
    
    drivers/spi/spi-loopback-test.c: In function 'spi_test_run_iter':
    drivers/spi/spi-loopback-test.c:768:17: warning: 'rx_count' may be used uninitialized in this function [-Wmaybe-uninitialized]
    drivers/spi/spi-loopback-test.c:762:17: warning: 'tx_count' may be used uninitialized in this function [-Wmaybe-uninitialized]
    
    Adding an explicit initialization seems to be the only
    workable solution here, to make the code behave correctly
    and build without warning.
    
    Fixes: 84e0c4e5e2c4 ("spi: add loopback test driver to allow for spi_master regression tests")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index 894616f687b0..cf4bb36bee25 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -761,6 +761,7 @@ static int spi_test_run_iter(struct spi_device *spi,
 		test.iterate_transfer_mask = 1;
 
 	/* count number of transfers with tx/rx_buf != NULL */
+	rx_count = tx_count = 0;
 	for (i = 0; i < test.transfer_count; i++) {
 		if (test.transfers[i].tx_buf)
 			tx_count++;

commit 8caad1da223c361e2804b76d68405b1abe7886ff
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Jan 8 13:48:51 2016 +0300

    spi: loopback: fix typo in MODULE_PARM_DESC
    
    There should be an 's' on "dump_message" so it matches the module_param.
    
    Fixes: 84e0c4e5e2c4 ('spi: add loopback test driver to allow for spi_master regression tests')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index 7f79a77c4b68..894616f687b0 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -37,7 +37,7 @@ MODULE_PARM_DESC(simulate_only, "if not 0 do not execute the spi message");
 /* dump spi messages */
 int dump_messages;
 module_param(dump_messages, int, 0);
-MODULE_PARM_DESC(dump_message,
+MODULE_PARM_DESC(dump_messages,
 		 "=1 dump the basic spi_message_structure, " \
 		 "=2 dump the spi_message_structure including data, " \
 		 "=3 dump the spi_message structure before and after execution");

commit 1e8db97f0e5205c0f6fd20c9a4f38cd871bc467f
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Tue Dec 22 18:03:25 2015 +0000

    spi: loopback-test: spi_check_rx_ranges can get always done
    
    The spi_check_rx_ranges can always get executed independent of
    if we have a real loopback situation.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index 81fa9068df43..7f79a77c4b68 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -489,7 +489,18 @@ static int spi_test_check_loopback_result(struct spi_device *spi,
 	struct spi_transfer *xfer;
 	u8 rxb, txb;
 	size_t i;
+	int ret;
+
+	/* checks rx_buffer pattern are valid with loopback or without */
+	ret = spi_check_rx_ranges(spi, msg, rx);
+	if (ret)
+		return ret;
 
+	/* if we run without loopback, then return now */
+	if (!loopback)
+		return 0;
+
+	/* if applicable to transfer check that rx_buf is equal to tx_buf */
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		/* if there is no rx, then no check is needed */
 		if (!xfer->rx_buf)
@@ -521,7 +532,7 @@ static int spi_test_check_loopback_result(struct spi_device *spi,
 		}
 	}
 
-	return spi_check_rx_ranges(spi, msg, rx);
+	return 0;
 
 mismatch_error:
 	dev_err(&spi->dev,
@@ -847,10 +858,8 @@ int spi_test_execute_msg(struct spi_device *spi, struct spi_test *test,
 			goto exit;
 		}
 
-		/* run rx-tests when in loopback mode */
-		if (loopback)
-			ret = spi_test_check_loopback_result(spi, msg,
-							     tx, rx);
+		/* run rx-buffer tests */
+		ret = spi_test_check_loopback_result(spi, msg, tx, rx);
 	}
 
 	/* if requested or on error dump message (including data) */

commit 339ec3ce54e5c7137287dc807555ae69934b2d2a
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Tue Dec 22 18:03:22 2015 +0000

    spi: loopback-test: rename method spi_test_fill_tx to spi_test_fill_pattern
    
    Rename method spi_test_fill_tx to spi_test_fill_pattern
    to better describe what it does.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index 8af2e4070153..81fa9068df43 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -574,7 +574,8 @@ static int spi_test_translate(struct spi_device *spi,
 	return -EINVAL;
 }
 
-static int spi_test_fill_tx(struct spi_device *spi, struct spi_test *test)
+static int spi_test_fill_pattern(struct spi_device *spi,
+				 struct spi_test *test)
 {
 	struct spi_transfer *xfers = test->transfers;
 	u8 *tx_buf;
@@ -691,8 +692,8 @@ static int _spi_test_run_iter(struct spi_device *spi,
 		spi_message_add_tail(x, msg);
 	}
 
-	/* fill in the transfer data */
-	ret = spi_test_fill_tx(spi, test);
+	/* fill in the transfer buffers with pattern */
+	ret = spi_test_fill_pattern(spi, test);
 	if (ret)
 		return ret;
 

commit e6520a3c8877d02c471135afb371e79b04409ab8
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Tue Dec 22 18:03:21 2015 +0000

    spi: loopback-test: write rx pattern also when running without tx_buf
    
    Currently the rx_buf does not get set with the
    SPI_TEST_PATTERN_UNWRITTEN when tx_buf == NULL in the transfer.
    
    Reorder code so that it gets done also under this specific condition.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index 7f497acc906c..8af2e4070153 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -591,6 +591,10 @@ static int spi_test_fill_tx(struct spi_device *spi, struct spi_test *test)
 
 	/* fill all transfers with the pattern requested */
 	for (i = 0; i < test->transfer_count; i++) {
+		/* fill rx_buf with SPI_TEST_PATTERN_UNWRITTEN */
+		if (xfers[i].rx_buf)
+			memset(xfers[i].rx_buf, SPI_TEST_PATTERN_UNWRITTEN,
+			       xfers[i].len);
 		/* if tx_buf is NULL then skip */
 		tx_buf = (u8 *)xfers[i].tx_buf;
 		if (!tx_buf)
@@ -648,10 +652,6 @@ static int spi_test_fill_tx(struct spi_device *spi, struct spi_test *test)
 				return -EINVAL;
 			}
 		}
-		/* fill rx_buf with SPI_TEST_PATTERN_UNWRITTEN */
-		if (xfers[i].rx_buf)
-			memset(xfers[i].rx_buf, SPI_TEST_PATTERN_UNWRITTEN,
-			       xfers[i].len);
 	}
 
 	return 0;

commit fc8773e195350c61e61cc354b1535fb2c09a29f3
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Sun Dec 13 09:45:01 2015 +0000

    spi: loopback: match configuration of test to description
    
    The test "two tx+rx transfers - alter second" actually modifies
    the first not the second transfer, which - in conjunction with
    testing the read data - results also in overwriting data read
    earlier.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index 4481ac766029..7f497acc906c 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -260,7 +260,7 @@ static struct spi_test spi_tests[] = {
 		.fill_option	= FILL_COUNT_8,
 		.iterate_len    = { ITERATE_MAX_LEN },
 		.iterate_tx_align = ITERATE_ALIGN,
-		.iterate_transfer_mask = BIT(0),
+		.iterate_transfer_mask = BIT(1),
 		.transfers		= {
 			{
 				.len = 1,

commit d58b9fda129d7f75358a36b71ec5cc685b4f993e
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Sun Dec 13 09:42:55 2015 +0000

    spi: loopback: fix printk format issues with size_t
    
    Fixes the reported printk format issues reported by kbuild-test-robot.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
index db207362e831..4481ac766029 100644
--- a/drivers/spi/spi-loopback-test.c
+++ b/drivers/spi/spi-loopback-test.c
@@ -345,7 +345,7 @@ static void spi_test_print_hex_dump(char *pre, const void *ptr, size_t len)
 		       DUMP_PREFIX_OFFSET, 16, 1,
 		       ptr, 512, 0);
 	/* print tail */
-	pr_info("%s truncated - continuing at offset %04x\n",
+	pr_info("%s truncated - continuing at offset %04zx\n",
 		pre, len - 512);
 	print_hex_dump(KERN_INFO, pre,
 		       DUMP_PREFIX_OFFSET, 16, 1,
@@ -525,7 +525,7 @@ static int spi_test_check_loopback_result(struct spi_device *spi,
 
 mismatch_error:
 	dev_err(&spi->dev,
-		"loopback strangeness - transfer missmatch on byte %04x - expected 0x%02x, but got 0x%02x\n",
+		"loopback strangeness - transfer missmatch on byte %04zx - expected 0x%02x, but got 0x%02x\n",
 		i, txb, rxb);
 
 	return -EINVAL;
@@ -777,7 +777,7 @@ static int spi_test_run_iter(struct spi_device *spi,
 		dev_info(&spi->dev, "Running test %s\n", test.description);
 	} else {
 		dev_info(&spi->dev,
-			 "  with iteration values: len = %i, tx_off = %i, rx_off = %i\n",
+			 "  with iteration values: len = %zu, tx_off = %zu, rx_off = %zu\n",
 			 len, tx_off, rx_off);
 	}
 

commit 84e0c4e5e2c4ef42b9c6f6d4151973a297ee4656
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Fri Nov 27 13:56:04 2015 +0000

    spi: add loopback test driver to allow for spi_master regression tests
    
    This driver is submitting lots of distinct spi-messages messages
    with all kinds of alignments and length pattern.
    Also distinct kinds of transfer pattern tests are implemented
    (rx, tx, rx/tx, tx+tx, tx+rx,...)
    
    Right now on a raspberry pi 752 distinct spi_messages are executed
    in 13 different scenarios.
    
    Configuration of additional test-pattern is easy, so that when
    new bugs in drivers get detected the relevant transfer pattern can
    also get added to the test framework, so that such situations are
    detected in other drivers as well.
    
    The idea behind this driver is to make it possible to also detect
    regressions in spi_master implementations when changes occur.
    Potentially these tests could get executed automatically in a
    test-server-farm.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-loopback-test.c b/drivers/spi/spi-loopback-test.c
new file mode 100644
index 000000000000..db207362e831
--- /dev/null
+++ b/drivers/spi/spi-loopback-test.c
@@ -0,0 +1,995 @@
+/*
+ *  linux/drivers/spi/spi-loopback-test.c
+ *
+ *  (c) Martin Sperl <kernel@martin.sperl.org>
+ *
+ *  Loopback test driver to test several typical spi_message conditions
+ *  that a spi_master driver may encounter
+ *  this can also get used for regression testing
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/list_sort.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/printk.h>
+#include <linux/spi/spi.h>
+
+#include "spi-test.h"
+
+/* flag to only simulate transfers */
+int simulate_only;
+module_param(simulate_only, int, 0);
+MODULE_PARM_DESC(simulate_only, "if not 0 do not execute the spi message");
+
+/* dump spi messages */
+int dump_messages;
+module_param(dump_messages, int, 0);
+MODULE_PARM_DESC(dump_message,
+		 "=1 dump the basic spi_message_structure, " \
+		 "=2 dump the spi_message_structure including data, " \
+		 "=3 dump the spi_message structure before and after execution");
+/* the device is jumpered for loopback - enabling some rx_buf tests */
+int loopback;
+module_param(loopback, int, 0);
+MODULE_PARM_DESC(loopback,
+		 "if set enable loopback mode, where the rx_buf "	\
+		 "is checked to match tx_buf after the spi_message "	\
+		 "is executed");
+
+/* run only a specific test */
+int run_only_test = -1;
+module_param(run_only_test, int, 0);
+MODULE_PARM_DESC(run_only_test,
+		 "only run the test with this number (0-based !)");
+
+/* the actual tests to execute */
+static struct spi_test spi_tests[] = {
+	{
+		.description	= "tx/rx-transfer - start of page",
+		.fill_option	= FILL_COUNT_8,
+		.iterate_len    = { ITERATE_MAX_LEN },
+		.iterate_tx_align = ITERATE_ALIGN,
+		.iterate_rx_align = ITERATE_ALIGN,
+		.transfers		= {
+			{
+				.len = 1,
+				.tx_buf = TX(0),
+				.rx_buf = RX(0),
+			},
+		},
+	},
+	{
+		.description	= "tx/rx-transfer - crossing PAGE_SIZE",
+		.fill_option	= FILL_COUNT_8,
+		.iterate_len    = { ITERATE_MAX_LEN },
+		.iterate_tx_align = ITERATE_ALIGN,
+		.iterate_rx_align = ITERATE_ALIGN,
+		.transfers		= {
+			{
+				.len = 1,
+				.tx_buf = TX(PAGE_SIZE - 4),
+				.rx_buf = RX(PAGE_SIZE - 4),
+			},
+		},
+	},
+	{
+		.description	= "tx-transfer - only",
+		.fill_option	= FILL_COUNT_8,
+		.iterate_len    = { ITERATE_MAX_LEN },
+		.iterate_tx_align = ITERATE_ALIGN,
+		.transfers		= {
+			{
+				.len = 1,
+				.tx_buf = TX(0),
+			},
+		},
+	},
+	{
+		.description	= "rx-transfer - only",
+		.fill_option	= FILL_COUNT_8,
+		.iterate_len    = { ITERATE_MAX_LEN },
+		.iterate_rx_align = ITERATE_ALIGN,
+		.transfers		= {
+			{
+				.len = 1,
+				.rx_buf = RX(0),
+			},
+		},
+	},
+	{
+		.description	= "two tx-transfers - alter both",
+		.fill_option	= FILL_COUNT_8,
+		.iterate_len    = { ITERATE_LEN },
+		.iterate_tx_align = ITERATE_ALIGN,
+		.iterate_transfer_mask = BIT(0) | BIT(1),
+		.transfers		= {
+			{
+				.len = 1,
+				.tx_buf = TX(0),
+			},
+			{
+				.len = 1,
+				/* this is why we cant use ITERATE_MAX_LEN */
+				.tx_buf = TX(SPI_TEST_MAX_SIZE_HALF),
+			},
+		},
+	},
+	{
+		.description	= "two tx-transfers - alter first",
+		.fill_option	= FILL_COUNT_8,
+		.iterate_len    = { ITERATE_MAX_LEN },
+		.iterate_tx_align = ITERATE_ALIGN,
+		.iterate_transfer_mask = BIT(1),
+		.transfers		= {
+			{
+				.len = 1,
+				.tx_buf = TX(64),
+			},
+			{
+				.len = 1,
+				.tx_buf = TX(0),
+			},
+		},
+	},
+	{
+		.description	= "two tx-transfers - alter second",
+		.fill_option	= FILL_COUNT_8,
+		.iterate_len    = { ITERATE_MAX_LEN },
+		.iterate_tx_align = ITERATE_ALIGN,
+		.iterate_transfer_mask = BIT(0),
+		.transfers		= {
+			{
+				.len = 16,
+				.tx_buf = TX(0),
+			},
+			{
+				.len = 1,
+				.tx_buf = TX(64),
+			},
+		},
+	},
+	{
+		.description	= "two transfers tx then rx - alter both",
+		.fill_option	= FILL_COUNT_8,
+		.iterate_len    = { ITERATE_MAX_LEN },
+		.iterate_tx_align = ITERATE_ALIGN,
+		.iterate_transfer_mask = BIT(0) | BIT(1),
+		.transfers		= {
+			{
+				.len = 1,
+				.tx_buf = TX(0),
+			},
+			{
+				.len = 1,
+				.rx_buf = RX(0),
+			},
+		},
+	},
+	{
+		.description	= "two transfers tx then rx - alter tx",
+		.fill_option	= FILL_COUNT_8,
+		.iterate_len    = { ITERATE_MAX_LEN },
+		.iterate_tx_align = ITERATE_ALIGN,
+		.iterate_transfer_mask = BIT(0),
+		.transfers		= {
+			{
+				.len = 1,
+				.tx_buf = TX(0),
+			},
+			{
+				.len = 1,
+				.rx_buf = RX(0),
+			},
+		},
+	},
+	{
+		.description	= "two transfers tx then rx - alter rx",
+		.fill_option	= FILL_COUNT_8,
+		.iterate_len    = { ITERATE_MAX_LEN },
+		.iterate_tx_align = ITERATE_ALIGN,
+		.iterate_transfer_mask = BIT(1),
+		.transfers		= {
+			{
+				.len = 1,
+				.tx_buf = TX(0),
+			},
+			{
+				.len = 1,
+				.rx_buf = RX(0),
+			},
+		},
+	},
+	{
+		.description	= "two tx+rx transfers - alter both",
+		.fill_option	= FILL_COUNT_8,
+		.iterate_len    = { ITERATE_LEN },
+		.iterate_tx_align = ITERATE_ALIGN,
+		.iterate_transfer_mask = BIT(0) | BIT(1),
+		.transfers		= {
+			{
+				.len = 1,
+				.tx_buf = TX(0),
+				.rx_buf = RX(0),
+			},
+			{
+				.len = 1,
+				/* making sure we align without overwrite
+				 * the reason we can not use ITERATE_MAX_LEN
+				 */
+				.tx_buf = TX(SPI_TEST_MAX_SIZE_HALF),
+				.rx_buf = RX(SPI_TEST_MAX_SIZE_HALF),
+			},
+		},
+	},
+	{
+		.description	= "two tx+rx transfers - alter first",
+		.fill_option	= FILL_COUNT_8,
+		.iterate_len    = { ITERATE_MAX_LEN },
+		.iterate_tx_align = ITERATE_ALIGN,
+		.iterate_transfer_mask = BIT(0),
+		.transfers		= {
+			{
+				.len = 1,
+				/* making sure we align without overwrite */
+				.tx_buf = TX(1024),
+				.rx_buf = RX(1024),
+			},
+			{
+				.len = 1,
+				/* making sure we align without overwrite */
+				.tx_buf = TX(0),
+				.rx_buf = RX(0),
+			},
+		},
+	},
+	{
+		.description	= "two tx+rx transfers - alter second",
+		.fill_option	= FILL_COUNT_8,
+		.iterate_len    = { ITERATE_MAX_LEN },
+		.iterate_tx_align = ITERATE_ALIGN,
+		.iterate_transfer_mask = BIT(0),
+		.transfers		= {
+			{
+				.len = 1,
+				.tx_buf = TX(0),
+				.rx_buf = RX(0),
+			},
+			{
+				.len = 1,
+				/* making sure we align without overwrite */
+				.tx_buf = TX(1024),
+				.rx_buf = RX(1024),
+			},
+		},
+	},
+
+	{ /* end of tests sequence */ }
+};
+
+static int spi_loopback_test_probe(struct spi_device *spi)
+{
+	int ret;
+
+	dev_info(&spi->dev, "Executing spi-loopback-tests\n");
+
+	ret = spi_test_run_tests(spi, spi_tests);
+
+	dev_info(&spi->dev, "Finished spi-loopback-tests with return: %i\n",
+		 ret);
+
+	return ret;
+}
+
+/* non const match table to permit to change via a module parameter */
+static struct of_device_id spi_loopback_test_of_match[] = {
+	{ .compatible	= "linux,spi-loopback-test", },
+	{ }
+};
+
+/* allow to override the compatible string via a module_parameter */
+module_param_string(compatible, spi_loopback_test_of_match[0].compatible,
+		    sizeof(spi_loopback_test_of_match[0].compatible),
+		    0000);
+
+MODULE_DEVICE_TABLE(of, spi_loopback_test_of_match);
+
+static struct spi_driver spi_loopback_test_driver = {
+	.driver = {
+		.name = "spi-loopback-test",
+		.owner = THIS_MODULE,
+		.of_match_table = spi_loopback_test_of_match,
+	},
+	.probe = spi_loopback_test_probe,
+};
+
+module_spi_driver(spi_loopback_test_driver);
+
+MODULE_AUTHOR("Martin Sperl <kernel@martin.sperl.org>");
+MODULE_DESCRIPTION("test spi_driver to check core functionality");
+MODULE_LICENSE("GPL");
+
+/*-------------------------------------------------------------------------*/
+
+/* spi_test implementation */
+
+#define RANGE_CHECK(ptr, plen, start, slen) \
+	((ptr >= start) && (ptr + plen <= start + slen))
+
+/* we allocate one page more, to allow for offsets */
+#define SPI_TEST_MAX_SIZE_PLUS (SPI_TEST_MAX_SIZE + PAGE_SIZE)
+
+static void spi_test_print_hex_dump(char *pre, const void *ptr, size_t len)
+{
+	/* limit the hex_dump */
+	if (len < 1024) {
+		print_hex_dump(KERN_INFO, pre,
+			       DUMP_PREFIX_OFFSET, 16, 1,
+			       ptr, len, 0);
+		return;
+	}
+	/* print head */
+	print_hex_dump(KERN_INFO, pre,
+		       DUMP_PREFIX_OFFSET, 16, 1,
+		       ptr, 512, 0);
+	/* print tail */
+	pr_info("%s truncated - continuing at offset %04x\n",
+		pre, len - 512);
+	print_hex_dump(KERN_INFO, pre,
+		       DUMP_PREFIX_OFFSET, 16, 1,
+		       ptr + (len - 512), 512, 0);
+}
+
+static void spi_test_dump_message(struct spi_device *spi,
+				  struct spi_message *msg,
+				  bool dump_data)
+{
+	struct spi_transfer *xfer;
+	int i;
+	u8 b;
+
+	dev_info(&spi->dev, "  spi_msg@%pK\n", msg);
+	if (msg->status)
+		dev_info(&spi->dev, "    status:        %i\n",
+			 msg->status);
+	dev_info(&spi->dev, "    frame_length:  %i\n",
+		 msg->frame_length);
+	dev_info(&spi->dev, "    actual_length: %i\n",
+		 msg->actual_length);
+
+	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		dev_info(&spi->dev, "    spi_transfer@%pK\n", xfer);
+		dev_info(&spi->dev, "      len:    %i\n", xfer->len);
+		dev_info(&spi->dev, "      tx_buf: %pK\n", xfer->tx_buf);
+		if (dump_data && xfer->tx_buf)
+			spi_test_print_hex_dump("          TX: ",
+						xfer->tx_buf,
+						xfer->len);
+
+		dev_info(&spi->dev, "      rx_buf: %pK\n", xfer->rx_buf);
+		if (dump_data && xfer->rx_buf)
+			spi_test_print_hex_dump("          RX: ",
+						xfer->rx_buf,
+						xfer->len);
+		/* check for unwritten test pattern on rx_buf */
+		if (xfer->rx_buf) {
+			for (i = 0 ; i < xfer->len ; i++) {
+				b = ((u8 *)xfer->rx_buf)[xfer->len - 1 - i];
+				if (b != SPI_TEST_PATTERN_UNWRITTEN)
+					break;
+			}
+			if (i)
+				dev_info(&spi->dev,
+					 "      rx_buf filled with %02x starts at offset: %i\n",
+					 SPI_TEST_PATTERN_UNWRITTEN,
+					 xfer->len - i);
+		}
+	}
+}
+
+struct rx_ranges {
+	struct list_head list;
+	u8 *start;
+	u8 *end;
+};
+
+int rx_ranges_cmp(void *priv, struct list_head *a, struct list_head *b)
+{
+	struct rx_ranges *rx_a = list_entry(a, struct rx_ranges, list);
+	struct rx_ranges *rx_b = list_entry(b, struct rx_ranges, list);
+
+	if (rx_a->start > rx_b->start)
+		return 1;
+	if (rx_a->start < rx_b->start)
+		return -1;
+	return 0;
+}
+
+static int spi_check_rx_ranges(struct spi_device *spi,
+			       struct spi_message *msg,
+			       void *rx)
+{
+	struct spi_transfer *xfer;
+	struct rx_ranges ranges[SPI_TEST_MAX_TRANSFERS], *r;
+	int i = 0;
+	LIST_HEAD(ranges_list);
+	u8 *addr;
+	int ret = 0;
+
+	/* loop over all transfers to fill in the rx_ranges */
+	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		/* if there is no rx, then no check is needed */
+		if (!xfer->rx_buf)
+			continue;
+		/* fill in the rx_range */
+		if (RANGE_CHECK(xfer->rx_buf, xfer->len,
+				rx, SPI_TEST_MAX_SIZE_PLUS)) {
+			ranges[i].start = xfer->rx_buf;
+			ranges[i].end = xfer->rx_buf + xfer->len;
+			list_add(&ranges[i].list, &ranges_list);
+			i++;
+		}
+	}
+
+	/* if no ranges, then we can return and avoid the checks...*/
+	if (!i)
+		return 0;
+
+	/* sort the list */
+	list_sort(NULL, &ranges_list, rx_ranges_cmp);
+
+	/* and iterate over all the rx addresses */
+	for (addr = rx; addr < (u8 *)rx + SPI_TEST_MAX_SIZE_PLUS; addr++) {
+		/* if we are the DO not write pattern,
+		 * then continue with the loop...
+		 */
+		if (*addr == SPI_TEST_PATTERN_DO_NOT_WRITE)
+			continue;
+
+		/* check if we are inside a range */
+		list_for_each_entry(r, &ranges_list, list) {
+			/* if so then set to end... */
+			if ((addr >= r->start) && (addr < r->end))
+				addr = r->end;
+		}
+		/* second test after a (hopefull) translation */
+		if (*addr == SPI_TEST_PATTERN_DO_NOT_WRITE)
+			continue;
+
+		/* if still not found then something has modified too much */
+		/* we could list the "closest" transfer here... */
+		dev_err(&spi->dev,
+			"loopback strangeness - rx changed outside of allowed range at: %pK\n",
+			addr);
+		/* do not return, only set ret,
+		 * so that we list all addresses
+		 */
+		ret = -ERANGE;
+	}
+
+	return ret;
+}
+
+static int spi_test_check_loopback_result(struct spi_device *spi,
+					  struct spi_message *msg,
+					  void *tx, void *rx)
+{
+	struct spi_transfer *xfer;
+	u8 rxb, txb;
+	size_t i;
+
+	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		/* if there is no rx, then no check is needed */
+		if (!xfer->rx_buf)
+			continue;
+		/* so depending on tx_buf we need to handle things */
+		if (xfer->tx_buf) {
+			for (i = 1; i < xfer->len; i++) {
+				txb = ((u8 *)xfer->tx_buf)[i];
+				rxb = ((u8 *)xfer->rx_buf)[i];
+				if (txb != rxb)
+					goto mismatch_error;
+			}
+		} else {
+			/* first byte received */
+			txb = ((u8 *)xfer->rx_buf)[0];
+			/* first byte may be 0 or xff */
+			if (!((txb == 0) || (txb == 0xff))) {
+				dev_err(&spi->dev,
+					"loopback strangeness - we expect 0x00 or 0xff, but not 0x%02x\n",
+					txb);
+				return -EINVAL;
+			}
+			/* check that all bytes are identical */
+			for (i = 1; i < xfer->len; i++) {
+				rxb = ((u8 *)xfer->rx_buf)[i];
+				if (rxb != txb)
+					goto mismatch_error;
+			}
+		}
+	}
+
+	return spi_check_rx_ranges(spi, msg, rx);
+
+mismatch_error:
+	dev_err(&spi->dev,
+		"loopback strangeness - transfer missmatch on byte %04x - expected 0x%02x, but got 0x%02x\n",
+		i, txb, rxb);
+
+	return -EINVAL;
+}
+
+static int spi_test_translate(struct spi_device *spi,
+			      void **ptr, size_t len,
+			      void *tx, void *rx)
+{
+	size_t off;
+
+	/* return on null */
+	if (!*ptr)
+		return 0;
+
+	/* in the MAX_SIZE_HALF case modify the pointer */
+	if (((size_t)*ptr) & SPI_TEST_MAX_SIZE_HALF)
+		/* move the pointer to the correct range */
+		*ptr += (SPI_TEST_MAX_SIZE_PLUS / 2) -
+			SPI_TEST_MAX_SIZE_HALF;
+
+	/* RX range
+	 * - we check against MAX_SIZE_PLUS to allow for automated alignment
+	 */
+	if (RANGE_CHECK(*ptr, len,  RX(0), SPI_TEST_MAX_SIZE_PLUS)) {
+		off = *ptr - RX(0);
+		*ptr = rx + off;
+
+		return 0;
+	}
+
+	/* TX range */
+	if (RANGE_CHECK(*ptr, len,  TX(0), SPI_TEST_MAX_SIZE_PLUS)) {
+		off = *ptr - TX(0);
+		*ptr = tx + off;
+
+		return 0;
+	}
+
+	dev_err(&spi->dev,
+		"PointerRange [%pK:%pK[ not in range [%pK:%pK[ or [%pK:%pK[\n",
+		*ptr, *ptr + len,
+		RX(0), RX(SPI_TEST_MAX_SIZE),
+		TX(0), TX(SPI_TEST_MAX_SIZE));
+
+	return -EINVAL;
+}
+
+static int spi_test_fill_tx(struct spi_device *spi, struct spi_test *test)
+{
+	struct spi_transfer *xfers = test->transfers;
+	u8 *tx_buf;
+	size_t count = 0;
+	int i, j;
+
+#ifdef __BIG_ENDIAN
+#define GET_VALUE_BYTE(value, index, bytes) \
+	(value >> (8 * (bytes - 1 - count % bytes)))
+#else
+#define GET_VALUE_BYTE(value, index, bytes) \
+	(value >> (8 * (count % bytes)))
+#endif
+
+	/* fill all transfers with the pattern requested */
+	for (i = 0; i < test->transfer_count; i++) {
+		/* if tx_buf is NULL then skip */
+		tx_buf = (u8 *)xfers[i].tx_buf;
+		if (!tx_buf)
+			continue;
+		/* modify all the transfers */
+		for (j = 0; j < xfers[i].len; j++, tx_buf++, count++) {
+			/* fill tx */
+			switch (test->fill_option) {
+			case FILL_MEMSET_8:
+				*tx_buf = test->fill_pattern;
+				break;
+			case FILL_MEMSET_16:
+				*tx_buf = GET_VALUE_BYTE(test->fill_pattern,
+							 count, 2);
+				break;
+			case FILL_MEMSET_24:
+				*tx_buf = GET_VALUE_BYTE(test->fill_pattern,
+							 count, 3);
+				break;
+			case FILL_MEMSET_32:
+				*tx_buf = GET_VALUE_BYTE(test->fill_pattern,
+							 count, 4);
+				break;
+			case FILL_COUNT_8:
+				*tx_buf = count;
+				break;
+			case FILL_COUNT_16:
+				*tx_buf = GET_VALUE_BYTE(count, count, 2);
+				break;
+			case FILL_COUNT_24:
+				*tx_buf = GET_VALUE_BYTE(count, count, 3);
+				break;
+			case FILL_COUNT_32:
+				*tx_buf = GET_VALUE_BYTE(count, count, 4);
+				break;
+			case FILL_TRANSFER_BYTE_8:
+				*tx_buf = j;
+				break;
+			case FILL_TRANSFER_BYTE_16:
+				*tx_buf = GET_VALUE_BYTE(j, j, 2);
+				break;
+			case FILL_TRANSFER_BYTE_24:
+				*tx_buf = GET_VALUE_BYTE(j, j, 3);
+				break;
+			case FILL_TRANSFER_BYTE_32:
+				*tx_buf = GET_VALUE_BYTE(j, j, 4);
+				break;
+			case FILL_TRANSFER_NUM:
+				*tx_buf = i;
+				break;
+			default:
+				dev_err(&spi->dev,
+					"unsupported fill_option: %i\n",
+					test->fill_option);
+				return -EINVAL;
+			}
+		}
+		/* fill rx_buf with SPI_TEST_PATTERN_UNWRITTEN */
+		if (xfers[i].rx_buf)
+			memset(xfers[i].rx_buf, SPI_TEST_PATTERN_UNWRITTEN,
+			       xfers[i].len);
+	}
+
+	return 0;
+}
+
+static int _spi_test_run_iter(struct spi_device *spi,
+			      struct spi_test *test,
+			      void *tx, void *rx)
+{
+	struct spi_message *msg = &test->msg;
+	struct spi_transfer *x;
+	int i, ret;
+
+	/* initialize message - zero-filled via static initialization */
+	spi_message_init_no_memset(msg);
+
+	/* fill rx with the DO_NOT_WRITE pattern */
+	memset(rx, SPI_TEST_PATTERN_DO_NOT_WRITE, SPI_TEST_MAX_SIZE_PLUS);
+
+	/* add the individual transfers */
+	for (i = 0; i < test->transfer_count; i++) {
+		x = &test->transfers[i];
+
+		/* patch the values of tx_buf */
+		ret = spi_test_translate(spi, (void **)&x->tx_buf, x->len,
+					 (void *)tx, rx);
+		if (ret)
+			return ret;
+
+		/* patch the values of rx_buf */
+		ret = spi_test_translate(spi, &x->rx_buf, x->len,
+					 (void *)tx, rx);
+		if (ret)
+			return ret;
+
+		/* and add it to the list */
+		spi_message_add_tail(x, msg);
+	}
+
+	/* fill in the transfer data */
+	ret = spi_test_fill_tx(spi, test);
+	if (ret)
+		return ret;
+
+	/* and execute */
+	if (test->execute_msg)
+		ret = test->execute_msg(spi, test, tx, rx);
+	else
+		ret = spi_test_execute_msg(spi, test, tx, rx);
+
+	/* handle result */
+	if (ret == test->expected_return)
+		return 0;
+
+	dev_err(&spi->dev,
+		"test failed - test returned %i, but we expect %i\n",
+		ret, test->expected_return);
+
+	if (ret)
+		return ret;
+
+	/* if it is 0, as we expected something else,
+	 * then return something special
+	 */
+	return -EFAULT;
+}
+
+static int spi_test_run_iter(struct spi_device *spi,
+			     const struct spi_test *testtemplate,
+			     void *tx, void *rx,
+			     size_t len,
+			     size_t tx_off,
+			     size_t rx_off
+	)
+{
+	struct spi_test test;
+	int i, tx_count, rx_count;
+
+	/* copy the test template to test */
+	memcpy(&test, testtemplate, sizeof(test));
+
+	/* set up test->transfers to the correct count */
+	if (!test.transfer_count) {
+		for (i = 0;
+		    (i < SPI_TEST_MAX_TRANSFERS) && test.transfers[i].len;
+		    i++) {
+			test.transfer_count++;
+		}
+	}
+
+	/* if iterate_transfer_mask is not set,
+	 * then set it to first transfer only
+	 */
+	if (!(test.iterate_transfer_mask & (BIT(test.transfer_count) - 1)))
+		test.iterate_transfer_mask = 1;
+
+	/* count number of transfers with tx/rx_buf != NULL */
+	for (i = 0; i < test.transfer_count; i++) {
+		if (test.transfers[i].tx_buf)
+			tx_count++;
+		if (test.transfers[i].rx_buf)
+			rx_count++;
+	}
+
+	/* in some iteration cases warn and exit early,
+	 * as there is nothing to do, that has not been tested already...
+	 */
+	if (tx_off && (!tx_count)) {
+		dev_warn_once(&spi->dev,
+			      "%s: iterate_tx_off configured with tx_buf==NULL - ignoring\n",
+			      test.description);
+		return 0;
+	}
+	if (rx_off && (!rx_count)) {
+		dev_warn_once(&spi->dev,
+			      "%s: iterate_rx_off configured with rx_buf==NULL - ignoring\n",
+			      test.description);
+		return 0;
+	}
+
+	/* write out info */
+	if (!(len || tx_off || rx_off)) {
+		dev_info(&spi->dev, "Running test %s\n", test.description);
+	} else {
+		dev_info(&spi->dev,
+			 "  with iteration values: len = %i, tx_off = %i, rx_off = %i\n",
+			 len, tx_off, rx_off);
+	}
+
+	/* update in the values from iteration values */
+	for (i = 0; i < test.transfer_count; i++) {
+		/* only when bit in transfer mask is set */
+		if (!(test.iterate_transfer_mask & BIT(i)))
+			continue;
+		if (len)
+			test.transfers[i].len = len;
+		if (test.transfers[i].tx_buf)
+			test.transfers[i].tx_buf += tx_off;
+		if (test.transfers[i].tx_buf)
+			test.transfers[i].rx_buf += rx_off;
+	}
+
+	/* and execute */
+	return _spi_test_run_iter(spi, &test, tx, rx);
+}
+
+/**
+ * spi_test_execute_msg - default implementation to run a test
+ *
+ * spi: @spi_device on which to run the @spi_message
+ * test: the test to execute, which already contains @msg
+ * tx:   the tx buffer allocated for the test sequence
+ * rx:   the rx buffer allocated for the test sequence
+ *
+ * Returns: error code of spi_sync as well as basic error checking
+ */
+int spi_test_execute_msg(struct spi_device *spi, struct spi_test *test,
+			 void *tx, void *rx)
+{
+	struct spi_message *msg = &test->msg;
+	int ret = 0;
+	int i;
+
+	/* only if we do not simulate */
+	if (!simulate_only) {
+		/* dump the complete message before and after the transfer */
+		if (dump_messages == 3)
+			spi_test_dump_message(spi, msg, true);
+
+		/* run spi message */
+		ret = spi_sync(spi, msg);
+		if (ret == -ETIMEDOUT) {
+			dev_info(&spi->dev,
+				 "spi-message timed out - reruning...\n");
+			/* rerun after a few explicit schedules */
+			for (i = 0; i < 16; i++)
+				schedule();
+			ret = spi_sync(spi, msg);
+		}
+		if (ret) {
+			dev_err(&spi->dev,
+				"Failed to execute spi_message: %i\n",
+				ret);
+			goto exit;
+		}
+
+		/* do some extra error checks */
+		if (msg->frame_length != msg->actual_length) {
+			dev_err(&spi->dev,
+				"actual length differs from expected\n");
+			ret = -EIO;
+			goto exit;
+		}
+
+		/* run rx-tests when in loopback mode */
+		if (loopback)
+			ret = spi_test_check_loopback_result(spi, msg,
+							     tx, rx);
+	}
+
+	/* if requested or on error dump message (including data) */
+exit:
+	if (dump_messages || ret)
+		spi_test_dump_message(spi, msg,
+				      (dump_messages >= 2) || (ret));
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(spi_test_execute_msg);
+
+/**
+ * spi_test_run_test - run an individual spi_test
+ *                     including all the relevant iterations on:
+ *                     length and buffer alignment
+ *
+ * spi:  the spi_device to send the messages to
+ * test: the test which we need to execute
+ * tx:   the tx buffer allocated for the test sequence
+ * rx:   the rx buffer allocated for the test sequence
+ *
+ * Returns: status code of spi_sync or other failures
+ */
+
+int spi_test_run_test(struct spi_device *spi, const struct spi_test *test,
+		      void *tx, void *rx)
+{
+	int idx_len;
+	size_t len;
+	size_t tx_align, rx_align;
+	int ret;
+
+	/* test for transfer limits */
+	if (test->transfer_count >= SPI_TEST_MAX_TRANSFERS) {
+		dev_err(&spi->dev,
+			"%s: Exceeded max number of transfers with %i\n",
+			test->description, test->transfer_count);
+		return -E2BIG;
+	}
+
+	/* setting up some values in spi_message
+	 * based on some settings in spi_master
+	 * some of this can also get done in the run() method
+	 */
+
+	/* iterate over all the iterable values using macros
+	 * (to make it a bit more readable...
+	 */
+#define FOR_EACH_ITERATE(var, defaultvalue)				\
+	for (idx_##var = -1, var = defaultvalue;			\
+	     ((idx_##var < 0) ||					\
+		     (							\
+			     (idx_##var < SPI_TEST_MAX_ITERATE) &&	\
+			     (var = test->iterate_##var[idx_##var])	\
+		     )							\
+	     );								\
+	     idx_##var++)
+#define FOR_EACH_ALIGNMENT(var)						\
+	for (var = 0;							\
+	    var < (test->iterate_##var ?				\
+			(spi->master->dma_alignment ?			\
+			 spi->master->dma_alignment :			\
+			 test->iterate_##var) :				\
+			1);						\
+	    var++)
+
+	FOR_EACH_ITERATE(len, 0) {
+		FOR_EACH_ALIGNMENT(tx_align) {
+			FOR_EACH_ALIGNMENT(rx_align) {
+				/* and run the iteration */
+				ret = spi_test_run_iter(spi, test,
+							tx, rx,
+							len,
+							tx_align,
+							rx_align);
+				if (ret)
+					return ret;
+			}
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(spi_test_run_test);
+
+/**
+ * spi_test_run_tests - run an array of spi_messages tests
+ * @spi: the spi device on which to run the tests
+ * @tests: NULL-terminated array of @spi_test
+ *
+ * Returns: status errors as per @spi_test_run_test()
+ */
+
+int spi_test_run_tests(struct spi_device *spi,
+		       struct spi_test *tests)
+{
+	char *rx = NULL, *tx = NULL;
+	int ret = 0, count = 0;
+	struct spi_test *test;
+
+	/* allocate rx/tx buffers of 128kB size without devm
+	 * in the hope that is on a page boundary
+	 */
+	rx = kzalloc(SPI_TEST_MAX_SIZE_PLUS, GFP_KERNEL);
+	if (!rx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	tx = kzalloc(SPI_TEST_MAX_SIZE_PLUS, GFP_KERNEL);
+	if (!tx) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/* now run the individual tests in the table */
+	for (test = tests, count = 0; test->description[0];
+	     test++, count++) {
+		/* only run test if requested */
+		if ((run_only_test > -1) && (count != run_only_test))
+			continue;
+		/* run custom implementation */
+		if (test->run_test)
+			ret = test->run_test(spi, test, tx, rx);
+		else
+			ret = spi_test_run_test(spi, test, tx, rx);
+		if (ret)
+			goto out;
+		/* add some delays so that we can easily
+		 * detect the individual tests when using a logic analyzer
+		 * we also add scheduling to avoid potential spi_timeouts...
+		 */
+		mdelay(100);
+		schedule();
+	}
+
+out:
+	kfree(rx);
+	kfree(tx);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(spi_test_run_tests);
