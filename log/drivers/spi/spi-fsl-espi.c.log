commit e74dc5c763448004ec8add422e9db53ee246acce
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:37 2019 +0300

    spi: use new `spi_transfer_delay_exec` helper where straightforward
    
    For many places in the spi drivers, using the new `spi_transfer_delay`
    helper is straightforward.
    It's just replacing:
    ```
      if (t->delay_usecs)
         udelay(t->delay_usecs);
    ```
    with `spi_transfer_delay(t)` which handles both `delay_usecs` and the new
    `delay` field.
    
    This change replaces in all places (in the spi drivers)  where this change
    is simple.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-10-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index f72daf66f3f3..e60581283a24 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -427,8 +427,7 @@ static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)
 
 	ret = fsl_espi_bufs(spi, trans);
 
-	if (trans->delay_usecs)
-		udelay(trans->delay_usecs);
+	spi_transfer_delay_exec(trans);
 
 	return ret;
 }

commit 3984d39b0e41ac4de8b4530ae3911ccf52ed4bbf
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:44 2019 +0300

    spi: spi-fsl-espi: convert transfer delay to `spi_delay` format
    
    The way the max delay is computed for this controller, it looks like it is
    searching for the max delay from an SPI message a using that.
    
    No idea if this is valid. But this change should support both `delay_usecs`
    and the new `delay` data which is of `spi_delay` type.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-17-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index f20326714b9d..f72daf66f3f3 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -437,6 +437,7 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 			       struct spi_message *m)
 {
 	unsigned int delay_usecs = 0, rx_nbits = 0;
+	unsigned int delay_nsecs = 0, delay_nsecs1 = 0;
 	struct spi_transfer *t, trans = {};
 	int ret;
 
@@ -445,8 +446,16 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 		goto out;
 
 	list_for_each_entry(t, &m->transfers, transfer_list) {
-		if (t->delay_usecs > delay_usecs)
-			delay_usecs = t->delay_usecs;
+		if (t->delay_usecs) {
+			if (t->delay_usecs > delay_usecs) {
+				delay_usecs = t->delay_usecs;
+				delay_nsecs = delay_usecs * 1000;
+			}
+		} else {
+			delay_nsecs1 = spi_delay_to_ns(&t->delay, t);
+			if (delay_nsecs1 > delay_nsecs)
+				delay_nsecs = delay_nsecs1;
+		}
 		if (t->rx_nbits > rx_nbits)
 			rx_nbits = t->rx_nbits;
 	}
@@ -457,7 +466,8 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 	trans.len = m->frame_length;
 	trans.speed_hz = t->speed_hz;
 	trans.bits_per_word = t->bits_per_word;
-	trans.delay_usecs = delay_usecs;
+	trans.delay.value = delay_nsecs;
+	trans.delay.unit = SPI_DELAY_UNIT_NSECS;
 	trans.rx_nbits = rx_nbits;
 
 	if (trans.len)

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index cf2118dc91f4..f20326714b9d 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -1,12 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Freescale eSPI controller driver.
  *
  * Copyright 2010 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
  */
 #include <linux/delay.h>
 #include <linux/err.h>

commit 7c5d8a249acadc3e9d5af643c0fe24b608a98269
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Sep 5 10:51:57 2018 +0200

    spi: Do not print a message if spi_controller_{suspend,resume}() fails
    
    spi_controller_{suspend,resume}() already prints an error message on
    failure, so there is no need to repeat this in individual drivers.
    
    Note: spi_master_{suspend,resume}() is an alias for
          spi_controller_{suspend,resume}().
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Reviewed-by: Daniel Mack <daniel@zonque.org>
    Acked-by: Nicolas Ferre <nicolas.ferre@microchip.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 1e8ff6256079..cf2118dc91f4 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -798,10 +798,8 @@ static int of_fsl_espi_suspend(struct device *dev)
 	int ret;
 
 	ret = spi_master_suspend(master);
-	if (ret) {
-		dev_warn(dev, "cannot suspend master\n");
+	if (ret)
 		return ret;
-	}
 
 	return pm_runtime_force_suspend(dev);
 }

commit 516ddd79068dc02b9101bf9551a9ef7dce217b5b
Author: Tiago Brusamarello <tiago.brusamarello@datacom.ind.br>
Date:   Thu Jul 26 11:12:11 2018 -0300

    spi: spi-fsl-espi: Log fifo counters on error
    
    Log RX and TX fifo counters when a transfer is done and these are not
    zero.
    
    Signed-off-by: Tiago Brusamarello <tiago.brusamarello@datacom.ind.br>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 1d332e23f6ed..1e8ff6256079 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -547,8 +547,11 @@ static void fsl_espi_cpu_irq(struct fsl_espi *espi, u32 events)
 		dev_err(espi->dev,
 			"Transfer done but SPIE_DON isn't set!\n");
 
-	if (SPIE_RXCNT(events) || SPIE_TXCNT(events) != FSL_ESPI_FIFO_SIZE)
+	if (SPIE_RXCNT(events) || SPIE_TXCNT(events) != FSL_ESPI_FIFO_SIZE) {
 		dev_err(espi->dev, "Transfer done but rx/tx fifo's aren't empty!\n");
+		dev_err(espi->dev, "SPIE_RXCNT = %d, SPIE_TXCNT = %d\n",
+			SPIE_RXCNT(events), SPIE_TXCNT(events));
+	}
 
 	complete(&espi->done);
 }

commit 7e2ef003302cc797917ce0a2a32cffb4af42c99e
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Nov 30 20:28:09 2016 +0100

    spi: fsl-espi: fix ioread16/iowrite16 endianness
    
    fsl_espi_read_reg16 / fsl_espi_write_reg16 are supposed to read / write
    big endian values. Therefore ioread16be / iowrite16be have to be used.
    
    Fixes:  058234328445 ("eliminate need for linearization when writing to hardware")
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index cd2832940092..1d332e23f6ed 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -124,7 +124,7 @@ static inline u32 fsl_espi_read_reg(struct fsl_espi *espi, int offset)
 
 static inline u16 fsl_espi_read_reg16(struct fsl_espi *espi, int offset)
 {
-	return ioread16(espi->reg_base + offset);
+	return ioread16be(espi->reg_base + offset);
 }
 
 static inline u8 fsl_espi_read_reg8(struct fsl_espi *espi, int offset)
@@ -141,7 +141,7 @@ static inline void fsl_espi_write_reg(struct fsl_espi *espi, int offset,
 static inline void fsl_espi_write_reg16(struct fsl_espi *espi, int offset,
 					u16 val)
 {
-	iowrite16(val, espi->reg_base + offset);
+	iowrite16be(val, espi->reg_base + offset);
 }
 
 static inline void fsl_espi_write_reg8(struct fsl_espi *espi, int offset,

commit d54ef0574ade2eab4d203687d53ed20351e323ab
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sat Nov 26 00:00:28 2016 +0100

    spi: fsl-espi: remove unused linearization code
    
    After introducing direct transfers between hardware and transfer
    buffers remove all code which is unused now.
    
    This includes getting rid of the 64k linearization buffer.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index e93892dca90a..cd2832940092 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -95,9 +95,6 @@ struct fsl_espi {
 	struct device *dev;
 	void __iomem *reg_base;
 
-	const void *tx;
-	void *rx;
-
 	struct list_head *m_transfers;
 	struct spi_transfer *tx_t;
 	unsigned int tx_pos;
@@ -107,11 +104,8 @@ struct fsl_espi {
 	bool rx_done;
 
 	bool swab;
-	unsigned int rx_len;
-	unsigned int tx_len;
 	unsigned int rxskip;
 
-	u8 *local_buf;
 	spinlock_t lock;
 
 	u32 spibrg;             /* SPIBRG input clock */
@@ -156,61 +150,6 @@ static inline void fsl_espi_write_reg8(struct fsl_espi *espi, int offset,
 	iowrite8(val, espi->reg_base + offset);
 }
 
-static void fsl_espi_memcpy_swab(void *to, const void *from,
-				 struct spi_message *m,
-				 struct spi_transfer *t)
-{
-	struct fsl_espi *espi = spi_master_get_devdata(m->spi->master);
-	unsigned int len = t->len;
-
-	if (!espi->swab) {
-		memcpy(to, from, len);
-		return;
-	}
-
-	while (len)
-		if (len >= 4) {
-			*(u32 *)to = swahb32p(from);
-			to += 4;
-			from += 4;
-			len -= 4;
-		} else {
-			*(u16 *)to = swab16p(from);
-			to += 2;
-			from += 2;
-			len -= 2;
-		}
-}
-
-static void fsl_espi_copy_to_buf(struct spi_message *m,
-				 struct fsl_espi *espi)
-{
-	struct spi_transfer *t;
-	u8 *buf = espi->local_buf;
-
-	list_for_each_entry(t, &m->transfers, transfer_list) {
-		if (t->tx_buf)
-			fsl_espi_memcpy_swab(buf, t->tx_buf, m, t);
-		/* In RXSKIP mode controller shifts out zeros internally */
-		else if (!espi->rxskip)
-			memset(buf, 0, t->len);
-		buf += t->len;
-	}
-}
-
-static void fsl_espi_copy_from_buf(struct spi_message *m,
-				   struct fsl_espi *espi)
-{
-	struct spi_transfer *t;
-	u8 *buf = espi->local_buf;
-
-	list_for_each_entry(t, &m->transfers, transfer_list) {
-		if (t->rx_buf)
-			fsl_espi_memcpy_swab(t->rx_buf, buf, m, t);
-		buf += t->len;
-	}
-}
-
 static int fsl_espi_check_message(struct spi_message *m)
 {
 	struct fsl_espi *espi = spi_master_get_devdata(m->spi->master);
@@ -421,12 +360,6 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	u32 mask, spcom;
 	int ret;
 
-	espi->rx_len = t->len;
-	espi->tx_len = t->len;
-
-	espi->tx = t->tx_buf;
-	espi->rx = t->rx_buf;
-
 	reinit_completion(&espi->done);
 
 	/* Set SPCOM[CS] and SPCOM[TRANLEN] field */
@@ -436,10 +369,7 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	/* configure RXSKIP mode */
 	if (espi->rxskip) {
 		spcom |= SPCOM_RXSKIP(espi->rxskip);
-		espi->tx_len = espi->rxskip;
-		espi->rx_len = t->len - espi->rxskip;
 		rx_len = t->len - espi->rxskip;
-		espi->rx = t->rx_buf + espi->rxskip;
 		if (t->rx_nbits == SPI_NBITS_DUAL)
 			spcom |= SPCOM_DO;
 	}
@@ -497,7 +427,6 @@ static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)
 	if (espi->rxskip)
 		espi->rx_t = list_next_entry(espi->rx_t, transfer_list);
 
-	fsl_espi_copy_to_buf(m, espi);
 	fsl_espi_setup_transfer(spi, trans);
 
 	ret = fsl_espi_bufs(spi, trans);
@@ -511,7 +440,6 @@ static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)
 static int fsl_espi_do_one_msg(struct spi_master *master,
 			       struct spi_message *m)
 {
-	struct fsl_espi *espi = spi_master_get_devdata(m->spi->master);
 	unsigned int delay_usecs = 0, rx_nbits = 0;
 	struct spi_transfer *t, trans = {};
 	int ret;
@@ -534,8 +462,6 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 	trans.speed_hz = t->speed_hz;
 	trans.bits_per_word = t->bits_per_word;
 	trans.delay_usecs = delay_usecs;
-	trans.tx_buf = espi->local_buf;
-	trans.rx_buf = espi->local_buf;
 	trans.rx_nbits = rx_nbits;
 
 	if (trans.len)
@@ -773,12 +699,6 @@ static int fsl_espi_probe(struct device *dev, struct resource *mem,
 
 	init_completion(&espi->done);
 
-	espi->local_buf = devm_kmalloc(dev, SPCOM_TRANLEN_MAX, GFP_KERNEL);
-	if (!espi->local_buf) {
-		ret = -ENOMEM;
-		goto err_probe;
-	}
-
 	espi->reg_base = devm_ioremap_resource(dev, mem);
 	if (IS_ERR(espi->reg_base)) {
 		ret = PTR_ERR(espi->reg_base);

commit dcb425f3ba6ebee4269f68461420246ba9d4ec02
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Fri Nov 25 23:59:57 2016 +0100

    spi: fsl-espi: eliminate need for linearization when reading from hardware
    
    Eliminate need for linearization when reading from the hardware and
    write to the transfer buffers directly.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 189ab36b787f..e93892dca90a 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -102,6 +102,9 @@ struct fsl_espi {
 	struct spi_transfer *tx_t;
 	unsigned int tx_pos;
 	bool tx_done;
+	struct spi_transfer *rx_t;
+	unsigned int rx_pos;
+	bool rx_done;
 
 	bool swab;
 	unsigned int rx_len;
@@ -125,6 +128,11 @@ static inline u32 fsl_espi_read_reg(struct fsl_espi *espi, int offset)
 	return ioread32be(espi->reg_base + offset);
 }
 
+static inline u16 fsl_espi_read_reg16(struct fsl_espi *espi, int offset)
+{
+	return ioread16(espi->reg_base + offset);
+}
+
 static inline u8 fsl_espi_read_reg8(struct fsl_espi *espi, int offset)
 {
 	return ioread8(espi->reg_base + offset);
@@ -328,19 +336,53 @@ static void fsl_espi_fill_tx_fifo(struct fsl_espi *espi, u32 events)
 static void fsl_espi_read_rx_fifo(struct fsl_espi *espi, u32 events)
 {
 	u32 rx_fifo_avail = SPIE_RXCNT(events);
+	unsigned int rx_left;
+	void *rx_buf;
 
-	while (rx_fifo_avail >= min(4U, espi->rx_len) && espi->rx_len)
-		if (espi->rx_len >= 4) {
-			*(u32 *)espi->rx = fsl_espi_read_reg(espi, ESPI_SPIRF);
-			espi->rx += 4;
-			espi->rx_len -= 4;
+start:
+	rx_left = espi->rx_t->len - espi->rx_pos;
+	rx_buf = espi->rx_t->rx_buf;
+	while (rx_fifo_avail >= min(4U, rx_left) && rx_left) {
+		if (rx_left >= 4) {
+			u32 val = fsl_espi_read_reg(espi, ESPI_SPIRF);
+
+			if (rx_buf && espi->swab)
+				*(u32 *)(rx_buf + espi->rx_pos) = swahb32(val);
+			else if (rx_buf)
+				*(u32 *)(rx_buf + espi->rx_pos) = val;
+			espi->rx_pos += 4;
+			rx_left -= 4;
 			rx_fifo_avail -= 4;
+		} else if (rx_left >= 2 && rx_buf && espi->swab) {
+			u16 val = fsl_espi_read_reg16(espi, ESPI_SPIRF);
+
+			*(u16 *)(rx_buf + espi->rx_pos) = swab16(val);
+			espi->rx_pos += 2;
+			rx_left -= 2;
+			rx_fifo_avail -= 2;
 		} else {
-			*(u8 *)espi->rx = fsl_espi_read_reg8(espi, ESPI_SPIRF);
-			espi->rx += 1;
-			espi->rx_len -= 1;
+			u8 val = fsl_espi_read_reg8(espi, ESPI_SPIRF);
+
+			if (rx_buf)
+				*(u8 *)(rx_buf + espi->rx_pos) = val;
+			espi->rx_pos += 1;
+			rx_left -= 1;
 			rx_fifo_avail -= 1;
 		}
+	}
+
+	if (!rx_left) {
+		if (list_is_last(&espi->rx_t->transfer_list,
+		    espi->m_transfers)) {
+			espi->rx_done = true;
+			return;
+		}
+		espi->rx_t = list_next_entry(espi->rx_t, transfer_list);
+		espi->rx_pos = 0;
+		/* continue with next transfer if rx fifo is not empty */
+		if (rx_fifo_avail)
+			goto start;
+	}
 }
 
 static void fsl_espi_setup_transfer(struct spi_device *spi,
@@ -375,6 +417,7 @@ static void fsl_espi_setup_transfer(struct spi_device *spi,
 static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 {
 	struct fsl_espi *espi = spi_master_get_devdata(spi->master);
+	unsigned int rx_len = t->len;
 	u32 mask, spcom;
 	int ret;
 
@@ -395,6 +438,7 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 		spcom |= SPCOM_RXSKIP(espi->rxskip);
 		espi->tx_len = espi->rxskip;
 		espi->rx_len = t->len - espi->rxskip;
+		rx_len = t->len - espi->rxskip;
 		espi->rx = t->rx_buf + espi->rxskip;
 		if (t->rx_nbits == SPI_NBITS_DUAL)
 			spcom |= SPCOM_DO;
@@ -404,7 +448,7 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 
 	/* enable interrupts */
 	mask = SPIM_DON;
-	if (espi->rx_len > FSL_ESPI_FIFO_SIZE)
+	if (rx_len > FSL_ESPI_FIFO_SIZE)
 		mask |= SPIM_RXT;
 	fsl_espi_write_reg(espi, ESPI_SPIM, mask);
 
@@ -438,6 +482,10 @@ static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)
 				      transfer_list);
 	espi->tx_pos = 0;
 	espi->tx_done = false;
+	espi->rx_t = list_first_entry(&m->transfers, struct spi_transfer,
+				      transfer_list);
+	espi->rx_pos = 0;
+	espi->rx_done = false;
 
 	espi->rxskip = fsl_espi_check_rxskip_mode(m);
 	if (trans->rx_nbits == SPI_NBITS_DUAL && !espi->rxskip) {
@@ -445,6 +493,10 @@ static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)
 		return -EINVAL;
 	}
 
+	/* In RXSKIP mode skip first transfer for reads */
+	if (espi->rxskip)
+		espi->rx_t = list_next_entry(espi->rx_t, transfer_list);
+
 	fsl_espi_copy_to_buf(m, espi);
 	fsl_espi_setup_transfer(spi, trans);
 
@@ -453,9 +505,6 @@ static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)
 	if (trans->delay_usecs)
 		udelay(trans->delay_usecs);
 
-	if (!ret)
-		fsl_espi_copy_from_buf(m, espi);
-
 	return ret;
 }
 
@@ -556,13 +605,13 @@ static void fsl_espi_cleanup(struct spi_device *spi)
 
 static void fsl_espi_cpu_irq(struct fsl_espi *espi, u32 events)
 {
-	if (espi->rx_len)
+	if (!espi->rx_done)
 		fsl_espi_read_rx_fifo(espi, events);
 
 	if (!espi->tx_done)
 		fsl_espi_fill_tx_fifo(espi, events);
 
-	if (!espi->tx_done || espi->rx_len)
+	if (!espi->tx_done || !espi->rx_done)
 		return;
 
 	/* we're done, but check for errors before returning */

commit 05823432844515e6e6e0e80dd44624a36ea405b7
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Fri Nov 25 23:59:24 2016 +0100

    spi: fsl-espi: eliminate need for linearization when writing to hardware
    
    Eliminate need for linearization when writing to the hardware and
    read from the transfer buffers directly.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 4222578a4dd4..189ab36b787f 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -98,6 +98,11 @@ struct fsl_espi {
 	const void *tx;
 	void *rx;
 
+	struct list_head *m_transfers;
+	struct spi_transfer *tx_t;
+	unsigned int tx_pos;
+	bool tx_done;
+
 	bool swab;
 	unsigned int rx_len;
 	unsigned int tx_len;
@@ -131,6 +136,12 @@ static inline void fsl_espi_write_reg(struct fsl_espi *espi, int offset,
 	iowrite32be(val, espi->reg_base + offset);
 }
 
+static inline void fsl_espi_write_reg16(struct fsl_espi *espi, int offset,
+					u16 val)
+{
+	iowrite16(val, espi->reg_base + offset);
+}
+
 static inline void fsl_espi_write_reg8(struct fsl_espi *espi, int offset,
 				       u8 val)
 {
@@ -260,22 +271,58 @@ static unsigned int fsl_espi_check_rxskip_mode(struct spi_message *m)
 static void fsl_espi_fill_tx_fifo(struct fsl_espi *espi, u32 events)
 {
 	u32 tx_fifo_avail;
+	unsigned int tx_left;
+	const void *tx_buf;
 
 	/* if events is zero transfer has not started and tx fifo is empty */
 	tx_fifo_avail = events ? SPIE_TXCNT(events) :  FSL_ESPI_FIFO_SIZE;
-
-	while (tx_fifo_avail >= min(4U, espi->tx_len) && espi->tx_len)
-		if (espi->tx_len >= 4) {
-			fsl_espi_write_reg(espi, ESPI_SPITF, *(u32 *)espi->tx);
-			espi->tx += 4;
-			espi->tx_len -= 4;
+start:
+	tx_left = espi->tx_t->len - espi->tx_pos;
+	tx_buf = espi->tx_t->tx_buf;
+	while (tx_fifo_avail >= min(4U, tx_left) && tx_left) {
+		if (tx_left >= 4) {
+			if (!tx_buf)
+				fsl_espi_write_reg(espi, ESPI_SPITF, 0);
+			else if (espi->swab)
+				fsl_espi_write_reg(espi, ESPI_SPITF,
+					swahb32p(tx_buf + espi->tx_pos));
+			else
+				fsl_espi_write_reg(espi, ESPI_SPITF,
+					*(u32 *)(tx_buf + espi->tx_pos));
+			espi->tx_pos += 4;
+			tx_left -= 4;
 			tx_fifo_avail -= 4;
+		} else if (tx_left >= 2 && tx_buf && espi->swab) {
+			fsl_espi_write_reg16(espi, ESPI_SPITF,
+					swab16p(tx_buf + espi->tx_pos));
+			espi->tx_pos += 2;
+			tx_left -= 2;
+			tx_fifo_avail -= 2;
 		} else {
-			fsl_espi_write_reg8(espi, ESPI_SPITF, *(u8 *)espi->tx);
-			espi->tx += 1;
-			espi->tx_len -= 1;
+			if (!tx_buf)
+				fsl_espi_write_reg8(espi, ESPI_SPITF, 0);
+			else
+				fsl_espi_write_reg8(espi, ESPI_SPITF,
+					*(u8 *)(tx_buf + espi->tx_pos));
+			espi->tx_pos += 1;
+			tx_left -= 1;
 			tx_fifo_avail -= 1;
 		}
+	}
+
+	if (!tx_left) {
+		/* Last transfer finished, in rxskip mode only one is needed */
+		if (list_is_last(&espi->tx_t->transfer_list,
+		    espi->m_transfers) || espi->rxskip) {
+			espi->tx_done = true;
+			return;
+		}
+		espi->tx_t = list_next_entry(espi->tx_t, transfer_list);
+		espi->tx_pos = 0;
+		/* continue with next transfer if tx fifo is not full */
+		if (tx_fifo_avail)
+			goto start;
+	}
 }
 
 static void fsl_espi_read_rx_fifo(struct fsl_espi *espi, u32 events)
@@ -369,9 +416,7 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	/* Won't hang up forever, SPI bus sometimes got lost interrupts... */
 	ret = wait_for_completion_timeout(&espi->done, 2 * HZ);
 	if (ret == 0)
-		dev_err(espi->dev,
-			"Transaction hanging up (left %u tx bytes, %u rx bytes)\n",
-			espi->tx_len, espi->rx_len);
+		dev_err(espi->dev, "Transfer timed out!\n");
 
 	/* disable rx ints */
 	fsl_espi_write_reg(espi, ESPI_SPIM, 0);
@@ -388,6 +433,12 @@ static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)
 	/* In case of LSB-first and bits_per_word > 8 byte-swap all words */
 	espi->swab = spi->mode & SPI_LSB_FIRST && trans->bits_per_word > 8;
 
+	espi->m_transfers = &m->transfers;
+	espi->tx_t = list_first_entry(&m->transfers, struct spi_transfer,
+				      transfer_list);
+	espi->tx_pos = 0;
+	espi->tx_done = false;
+
 	espi->rxskip = fsl_espi_check_rxskip_mode(m);
 	if (trans->rx_nbits == SPI_NBITS_DUAL && !espi->rxskip) {
 		dev_err(espi->dev, "Dual output mode requires RXSKIP mode!\n");
@@ -508,10 +559,10 @@ static void fsl_espi_cpu_irq(struct fsl_espi *espi, u32 events)
 	if (espi->rx_len)
 		fsl_espi_read_rx_fifo(espi, events);
 
-	if (espi->tx_len)
+	if (!espi->tx_done)
 		fsl_espi_fill_tx_fifo(espi, events);
 
-	if (espi->tx_len || espi->rx_len)
+	if (!espi->tx_done || espi->rx_len)
 		return;
 
 	/* we're done, but check for errors before returning */

commit e1cdee73dfcac393768117511e52a6142587dacf
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Fri Nov 25 23:58:49 2016 +0100

    spi: fsl-espi: determine need for byte swap only once
    
    Determine need for byte swap only once and store it in new member
    swab in struct fsl_espi.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 4fbcc36fa891..4222578a4dd4 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -98,6 +98,7 @@ struct fsl_espi {
 	const void *tx;
 	void *rx;
 
+	bool swab;
 	unsigned int rx_len;
 	unsigned int tx_len;
 	unsigned int rxskip;
@@ -140,14 +141,14 @@ static void fsl_espi_memcpy_swab(void *to, const void *from,
 				 struct spi_message *m,
 				 struct spi_transfer *t)
 {
+	struct fsl_espi *espi = spi_master_get_devdata(m->spi->master);
 	unsigned int len = t->len;
 
-	if (!(m->spi->mode & SPI_LSB_FIRST) || t->bits_per_word <= 8) {
+	if (!espi->swab) {
 		memcpy(to, from, len);
 		return;
 	}
 
-	/* In case of LSB-first and bits_per_word > 8 byte-swap all words */
 	while (len)
 		if (len >= 4) {
 			*(u32 *)to = swahb32p(from);
@@ -384,6 +385,9 @@ static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)
 	struct spi_device *spi = m->spi;
 	int ret;
 
+	/* In case of LSB-first and bits_per_word > 8 byte-swap all words */
+	espi->swab = spi->mode & SPI_LSB_FIRST && trans->bits_per_word > 8;
+
 	espi->rxskip = fsl_espi_check_rxskip_mode(m);
 	if (trans->rx_nbits == SPI_NBITS_DUAL && !espi->rxskip) {
 		dev_err(espi->dev, "Dual output mode requires RXSKIP mode!\n");

commit f254e65ce20fda3c442ebc50ae1502281963a79b
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Tue Nov 15 21:56:33 2016 +0100

    spi: fsl-espi: set spi_master members min_speed_hz and max_speed_hz
    
    ESPI has a max and min supported SPI frequency, determined by the
    clock divider range. Set master->min_speed_hz/max_speed_hz to inform
    the SPI core about these limits.
    Then the SPI core handles cases where a transfer requests a frequency
    outside the supported range.
    
    So far the driver simply set the lowest supported frequency if the
    requested frequency was below the supported range. This is not
    necessarily an appropriate action as the device might not support
    frequencies greater than the requested one.
    With this patch the SPI core will reject transfers requesting a
    too low frequency.
    
    The check in fsl_espi_setup can be removed because the SPI core sets
    spi->max_speed_hz to master->max_speed_hz if it's not set already.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 2635a33b8e98..4fbcc36fa891 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -314,13 +314,6 @@ static void fsl_espi_setup_transfer(struct spi_device *spi,
 	if (pm > 15) {
 		cs->hw_mode |= CSMODE_DIV16;
 		pm = DIV_ROUND_UP(espi->spibrg, hz * 16 * 4) - 1;
-
-		WARN_ONCE(pm > 15,
-			  "%s: Requested speed is too low: %u Hz. Will use %u Hz instead.\n",
-			  dev_name(&spi->dev), hz,
-			  espi->spibrg / (4 * 16 * (15 + 1)));
-		if (pm > 15)
-			pm = 15;
 	}
 
 	cs->hw_mode |= CSMODE_PM(pm);
@@ -460,9 +453,6 @@ static int fsl_espi_setup(struct spi_device *spi)
 	u32 loop_mode;
 	struct fsl_espi_cs *cs = spi_get_ctldata(spi);
 
-	if (!spi->max_speed_hz)
-		return -EINVAL;
-
 	if (!cs) {
 		cs = kzalloc(sizeof(*cs), GFP_KERNEL);
 		if (!cs)
@@ -673,6 +663,9 @@ static int fsl_espi_probe(struct device *dev, struct resource *mem,
 		ret = -EINVAL;
 		goto err_probe;
 	}
+	/* determined by clock divider fields DIV16/PM in register SPMODEx */
+	master->min_speed_hz = DIV_ROUND_UP(espi->spibrg, 4 * 16 * 16);
+	master->max_speed_hz = DIV_ROUND_UP(espi->spibrg, 4);
 
 	init_completion(&espi->done);
 

commit a9a813ddc505279efd94b2b8ff9ead0f7e005b63
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Tue Nov 15 21:37:17 2016 +0100

    spi: fsl-espi: simplify of_fsl_espi_suspend
    
    Simplify of_fsl_espi_suspend a little.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index b5feae31fcc0..2635a33b8e98 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -783,11 +783,7 @@ static int of_fsl_espi_suspend(struct device *dev)
 		return ret;
 	}
 
-	ret = pm_runtime_force_suspend(dev);
-	if (ret < 0)
-		return ret;
-
-	return 0;
+	return pm_runtime_force_suspend(dev);
 }
 
 static int of_fsl_espi_resume(struct device *dev)

commit 278c48d2ab2c2f803a7ac501b67b14aa7e73e771
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Nov 13 14:41:06 2016 +0100

    spi: fsl-espi: separate fsl-espi from fsl-lib completely
    
    After having removed all code dependencies we can make fsl-espi
    completely independent of fsl-lib now.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 8539f0584a8a..b5feae31fcc0 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -23,8 +23,6 @@
 #include <linux/pm_runtime.h>
 #include <sysdev/fsl_soc.h>
 
-#include "spi-fsl-lib.h"
-
 /* eSPI Controller registers */
 #define ESPI_SPMODE	0x00	/* eSPI mode register */
 #define ESPI_SPIE	0x04	/* eSPI event register */

commit 35ab046b52f61c80fd43c3cc10d9ffac25a86b99
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Nov 13 14:40:51 2016 +0100

    spi: fsl-espi: introduce struct fsl_espi
    
    Only few members of struct mpc8xxx_spi are relevant for fsl-espi.
    Therefore replace it with a ESPI-specific struct fsl_espi.
    Replace variable names mpc8xxx_spi and mspi with espi.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 7a903434c881..8539f0584a8a 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -93,30 +93,49 @@
 
 #define AUTOSUSPEND_TIMEOUT 2000
 
+struct fsl_espi {
+	struct device *dev;
+	void __iomem *reg_base;
+
+	const void *tx;
+	void *rx;
+
+	unsigned int rx_len;
+	unsigned int tx_len;
+	unsigned int rxskip;
+
+	u8 *local_buf;
+	spinlock_t lock;
+
+	u32 spibrg;             /* SPIBRG input clock */
+
+	struct completion done;
+};
+
 struct fsl_espi_cs {
 	u32 hw_mode;
 };
 
-static inline u32 fsl_espi_read_reg(struct mpc8xxx_spi *mspi, int offset)
+static inline u32 fsl_espi_read_reg(struct fsl_espi *espi, int offset)
 {
-	return ioread32be(mspi->reg_base + offset);
+	return ioread32be(espi->reg_base + offset);
 }
 
-static inline u8 fsl_espi_read_reg8(struct mpc8xxx_spi *mspi, int offset)
+static inline u8 fsl_espi_read_reg8(struct fsl_espi *espi, int offset)
 {
-	return ioread8(mspi->reg_base + offset);
+	return ioread8(espi->reg_base + offset);
 }
 
-static inline void fsl_espi_write_reg(struct mpc8xxx_spi *mspi, int offset,
+static inline void fsl_espi_write_reg(struct fsl_espi *espi, int offset,
 				      u32 val)
 {
-	iowrite32be(val, mspi->reg_base + offset);
+	iowrite32be(val, espi->reg_base + offset);
 }
 
-static inline void fsl_espi_write_reg8(struct mpc8xxx_spi *mspi, int offset,
+static inline void fsl_espi_write_reg8(struct fsl_espi *espi, int offset,
 				       u8 val)
 {
-	iowrite8(val, mspi->reg_base + offset);
+	iowrite8(val, espi->reg_base + offset);
 }
 
 static void fsl_espi_memcpy_swab(void *to, const void *from,
@@ -146,26 +165,26 @@ static void fsl_espi_memcpy_swab(void *to, const void *from,
 }
 
 static void fsl_espi_copy_to_buf(struct spi_message *m,
-				 struct mpc8xxx_spi *mspi)
+				 struct fsl_espi *espi)
 {
 	struct spi_transfer *t;
-	u8 *buf = mspi->local_buf;
+	u8 *buf = espi->local_buf;
 
 	list_for_each_entry(t, &m->transfers, transfer_list) {
 		if (t->tx_buf)
 			fsl_espi_memcpy_swab(buf, t->tx_buf, m, t);
 		/* In RXSKIP mode controller shifts out zeros internally */
-		else if (!mspi->rxskip)
+		else if (!espi->rxskip)
 			memset(buf, 0, t->len);
 		buf += t->len;
 	}
 }
 
 static void fsl_espi_copy_from_buf(struct spi_message *m,
-				   struct mpc8xxx_spi *mspi)
+				   struct fsl_espi *espi)
 {
 	struct spi_transfer *t;
-	u8 *buf = mspi->local_buf;
+	u8 *buf = espi->local_buf;
 
 	list_for_each_entry(t, &m->transfers, transfer_list) {
 		if (t->rx_buf)
@@ -176,11 +195,11 @@ static void fsl_espi_copy_from_buf(struct spi_message *m,
 
 static int fsl_espi_check_message(struct spi_message *m)
 {
-	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
+	struct fsl_espi *espi = spi_master_get_devdata(m->spi->master);
 	struct spi_transfer *t, *first;
 
 	if (m->frame_length > SPCOM_TRANLEN_MAX) {
-		dev_err(mspi->dev, "message too long, size is %u bytes\n",
+		dev_err(espi->dev, "message too long, size is %u bytes\n",
 			m->frame_length);
 		return -EMSGSIZE;
 	}
@@ -191,7 +210,7 @@ static int fsl_espi_check_message(struct spi_message *m)
 	list_for_each_entry(t, &m->transfers, transfer_list) {
 		if (first->bits_per_word != t->bits_per_word ||
 		    first->speed_hz != t->speed_hz) {
-			dev_err(mspi->dev, "bits_per_word/speed_hz should be the same for all transfers\n");
+			dev_err(espi->dev, "bits_per_word/speed_hz should be the same for all transfers\n");
 			return -EINVAL;
 		}
 	}
@@ -199,7 +218,7 @@ static int fsl_espi_check_message(struct spi_message *m)
 	/* ESPI supports MSB-first transfers for word size 8 / 16 only */
 	if (!(m->spi->mode & SPI_LSB_FIRST) && first->bits_per_word != 8 &&
 	    first->bits_per_word != 16) {
-		dev_err(mspi->dev,
+		dev_err(espi->dev,
 			"MSB-first transfer not supported for wordsize %u\n",
 			first->bits_per_word);
 		return -EINVAL;
@@ -239,41 +258,41 @@ static unsigned int fsl_espi_check_rxskip_mode(struct spi_message *m)
 	return i == 2 ? rxskip : 0;
 }
 
-static void fsl_espi_fill_tx_fifo(struct mpc8xxx_spi *mspi, u32 events)
+static void fsl_espi_fill_tx_fifo(struct fsl_espi *espi, u32 events)
 {
 	u32 tx_fifo_avail;
 
 	/* if events is zero transfer has not started and tx fifo is empty */
 	tx_fifo_avail = events ? SPIE_TXCNT(events) :  FSL_ESPI_FIFO_SIZE;
 
-	while (tx_fifo_avail >= min(4U, mspi->tx_len) && mspi->tx_len)
-		if (mspi->tx_len >= 4) {
-			fsl_espi_write_reg(mspi, ESPI_SPITF, *(u32 *)mspi->tx);
-			mspi->tx += 4;
-			mspi->tx_len -= 4;
+	while (tx_fifo_avail >= min(4U, espi->tx_len) && espi->tx_len)
+		if (espi->tx_len >= 4) {
+			fsl_espi_write_reg(espi, ESPI_SPITF, *(u32 *)espi->tx);
+			espi->tx += 4;
+			espi->tx_len -= 4;
 			tx_fifo_avail -= 4;
 		} else {
-			fsl_espi_write_reg8(mspi, ESPI_SPITF, *(u8 *)mspi->tx);
-			mspi->tx += 1;
-			mspi->tx_len -= 1;
+			fsl_espi_write_reg8(espi, ESPI_SPITF, *(u8 *)espi->tx);
+			espi->tx += 1;
+			espi->tx_len -= 1;
 			tx_fifo_avail -= 1;
 		}
 }
 
-static void fsl_espi_read_rx_fifo(struct mpc8xxx_spi *mspi, u32 events)
+static void fsl_espi_read_rx_fifo(struct fsl_espi *espi, u32 events)
 {
 	u32 rx_fifo_avail = SPIE_RXCNT(events);
 
-	while (rx_fifo_avail >= min(4U, mspi->rx_len) && mspi->rx_len)
-		if (mspi->rx_len >= 4) {
-			*(u32 *)mspi->rx = fsl_espi_read_reg(mspi, ESPI_SPIRF);
-			mspi->rx += 4;
-			mspi->rx_len -= 4;
+	while (rx_fifo_avail >= min(4U, espi->rx_len) && espi->rx_len)
+		if (espi->rx_len >= 4) {
+			*(u32 *)espi->rx = fsl_espi_read_reg(espi, ESPI_SPIRF);
+			espi->rx += 4;
+			espi->rx_len -= 4;
 			rx_fifo_avail -= 4;
 		} else {
-			*(u8 *)mspi->rx = fsl_espi_read_reg8(mspi, ESPI_SPIRF);
-			mspi->rx += 1;
-			mspi->rx_len -= 1;
+			*(u8 *)espi->rx = fsl_espi_read_reg8(espi, ESPI_SPIRF);
+			espi->rx += 1;
+			espi->rx_len -= 1;
 			rx_fifo_avail -= 1;
 		}
 }
@@ -281,7 +300,7 @@ static void fsl_espi_read_rx_fifo(struct mpc8xxx_spi *mspi, u32 events)
 static void fsl_espi_setup_transfer(struct spi_device *spi,
 					struct spi_transfer *t)
 {
-	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
+	struct fsl_espi *espi = spi_master_get_devdata(spi->master);
 	int bits_per_word = t ? t->bits_per_word : spi->bits_per_word;
 	u32 pm, hz = t ? t->speed_hz : spi->max_speed_hz;
 	struct fsl_espi_cs *cs = spi_get_ctldata(spi);
@@ -292,16 +311,16 @@ static void fsl_espi_setup_transfer(struct spi_device *spi,
 
 	cs->hw_mode |= CSMODE_LEN(bits_per_word - 1);
 
-	pm = DIV_ROUND_UP(mpc8xxx_spi->spibrg, hz * 4) - 1;
+	pm = DIV_ROUND_UP(espi->spibrg, hz * 4) - 1;
 
 	if (pm > 15) {
 		cs->hw_mode |= CSMODE_DIV16;
-		pm = DIV_ROUND_UP(mpc8xxx_spi->spibrg, hz * 16 * 4) - 1;
+		pm = DIV_ROUND_UP(espi->spibrg, hz * 16 * 4) - 1;
 
 		WARN_ONCE(pm > 15,
 			  "%s: Requested speed is too low: %u Hz. Will use %u Hz instead.\n",
 			  dev_name(&spi->dev), hz,
-			  mpc8xxx_spi->spibrg / (4 * 16 * (15 + 1)));
+			  espi->spibrg / (4 * 16 * (15 + 1)));
 		if (pm > 15)
 			pm = 15;
 	}
@@ -310,77 +329,77 @@ static void fsl_espi_setup_transfer(struct spi_device *spi,
 
 	/* don't write the mode register if the mode doesn't change */
 	if (cs->hw_mode != hw_mode_old)
-		fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODEx(spi->chip_select),
+		fsl_espi_write_reg(espi, ESPI_SPMODEx(spi->chip_select),
 				   cs->hw_mode);
 }
 
 static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 {
-	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
+	struct fsl_espi *espi = spi_master_get_devdata(spi->master);
 	u32 mask, spcom;
 	int ret;
 
-	mpc8xxx_spi->rx_len = t->len;
-	mpc8xxx_spi->tx_len = t->len;
+	espi->rx_len = t->len;
+	espi->tx_len = t->len;
 
-	mpc8xxx_spi->tx = t->tx_buf;
-	mpc8xxx_spi->rx = t->rx_buf;
+	espi->tx = t->tx_buf;
+	espi->rx = t->rx_buf;
 
-	reinit_completion(&mpc8xxx_spi->done);
+	reinit_completion(&espi->done);
 
 	/* Set SPCOM[CS] and SPCOM[TRANLEN] field */
 	spcom = SPCOM_CS(spi->chip_select);
 	spcom |= SPCOM_TRANLEN(t->len - 1);
 
 	/* configure RXSKIP mode */
-	if (mpc8xxx_spi->rxskip) {
-		spcom |= SPCOM_RXSKIP(mpc8xxx_spi->rxskip);
-		mpc8xxx_spi->tx_len = mpc8xxx_spi->rxskip;
-		mpc8xxx_spi->rx_len = t->len - mpc8xxx_spi->rxskip;
-		mpc8xxx_spi->rx = t->rx_buf + mpc8xxx_spi->rxskip;
+	if (espi->rxskip) {
+		spcom |= SPCOM_RXSKIP(espi->rxskip);
+		espi->tx_len = espi->rxskip;
+		espi->rx_len = t->len - espi->rxskip;
+		espi->rx = t->rx_buf + espi->rxskip;
 		if (t->rx_nbits == SPI_NBITS_DUAL)
 			spcom |= SPCOM_DO;
 	}
 
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPCOM, spcom);
+	fsl_espi_write_reg(espi, ESPI_SPCOM, spcom);
 
 	/* enable interrupts */
 	mask = SPIM_DON;
-	if (mpc8xxx_spi->rx_len > FSL_ESPI_FIFO_SIZE)
+	if (espi->rx_len > FSL_ESPI_FIFO_SIZE)
 		mask |= SPIM_RXT;
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIM, mask);
+	fsl_espi_write_reg(espi, ESPI_SPIM, mask);
 
 	/* Prevent filling the fifo from getting interrupted */
-	spin_lock_irq(&mpc8xxx_spi->lock);
-	fsl_espi_fill_tx_fifo(mpc8xxx_spi, 0);
-	spin_unlock_irq(&mpc8xxx_spi->lock);
+	spin_lock_irq(&espi->lock);
+	fsl_espi_fill_tx_fifo(espi, 0);
+	spin_unlock_irq(&espi->lock);
 
 	/* Won't hang up forever, SPI bus sometimes got lost interrupts... */
-	ret = wait_for_completion_timeout(&mpc8xxx_spi->done, 2 * HZ);
+	ret = wait_for_completion_timeout(&espi->done, 2 * HZ);
 	if (ret == 0)
-		dev_err(mpc8xxx_spi->dev,
+		dev_err(espi->dev,
 			"Transaction hanging up (left %u tx bytes, %u rx bytes)\n",
-			mpc8xxx_spi->tx_len, mpc8xxx_spi->rx_len);
+			espi->tx_len, espi->rx_len);
 
 	/* disable rx ints */
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIM, 0);
+	fsl_espi_write_reg(espi, ESPI_SPIM, 0);
 
 	return ret == 0 ? -ETIMEDOUT : 0;
 }
 
 static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)
 {
-	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
+	struct fsl_espi *espi = spi_master_get_devdata(m->spi->master);
 	struct spi_device *spi = m->spi;
 	int ret;
 
-	mspi->rxskip = fsl_espi_check_rxskip_mode(m);
-	if (trans->rx_nbits == SPI_NBITS_DUAL && !mspi->rxskip) {
-		dev_err(mspi->dev, "Dual output mode requires RXSKIP mode!\n");
+	espi->rxskip = fsl_espi_check_rxskip_mode(m);
+	if (trans->rx_nbits == SPI_NBITS_DUAL && !espi->rxskip) {
+		dev_err(espi->dev, "Dual output mode requires RXSKIP mode!\n");
 		return -EINVAL;
 	}
 
-	fsl_espi_copy_to_buf(m, mspi);
+	fsl_espi_copy_to_buf(m, espi);
 	fsl_espi_setup_transfer(spi, trans);
 
 	ret = fsl_espi_bufs(spi, trans);
@@ -389,7 +408,7 @@ static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)
 		udelay(trans->delay_usecs);
 
 	if (!ret)
-		fsl_espi_copy_from_buf(m, mspi);
+		fsl_espi_copy_from_buf(m, espi);
 
 	return ret;
 }
@@ -397,7 +416,7 @@ static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)
 static int fsl_espi_do_one_msg(struct spi_master *master,
 			       struct spi_message *m)
 {
-	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
+	struct fsl_espi *espi = spi_master_get_devdata(m->spi->master);
 	unsigned int delay_usecs = 0, rx_nbits = 0;
 	struct spi_transfer *t, trans = {};
 	int ret;
@@ -420,8 +439,8 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 	trans.speed_hz = t->speed_hz;
 	trans.bits_per_word = t->bits_per_word;
 	trans.delay_usecs = delay_usecs;
-	trans.tx_buf = mspi->local_buf;
-	trans.rx_buf = mspi->local_buf;
+	trans.tx_buf = espi->local_buf;
+	trans.rx_buf = espi->local_buf;
 	trans.rx_nbits = rx_nbits;
 
 	if (trans.len)
@@ -439,7 +458,7 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 
 static int fsl_espi_setup(struct spi_device *spi)
 {
-	struct mpc8xxx_spi *mpc8xxx_spi;
+	struct fsl_espi *espi;
 	u32 loop_mode;
 	struct fsl_espi_cs *cs = spi_get_ctldata(spi);
 
@@ -453,12 +472,11 @@ static int fsl_espi_setup(struct spi_device *spi)
 		spi_set_ctldata(spi, cs);
 	}
 
-	mpc8xxx_spi = spi_master_get_devdata(spi->master);
+	espi = spi_master_get_devdata(spi->master);
 
-	pm_runtime_get_sync(mpc8xxx_spi->dev);
+	pm_runtime_get_sync(espi->dev);
 
-	cs->hw_mode = fsl_espi_read_reg(mpc8xxx_spi,
-					   ESPI_SPMODEx(spi->chip_select));
+	cs->hw_mode = fsl_espi_read_reg(espi, ESPI_SPMODEx(spi->chip_select));
 	/* mask out bits we are going to set */
 	cs->hw_mode &= ~(CSMODE_CP_BEGIN_EDGECLK | CSMODE_CI_INACTIVEHIGH
 			 | CSMODE_REV);
@@ -471,16 +489,16 @@ static int fsl_espi_setup(struct spi_device *spi)
 		cs->hw_mode |= CSMODE_REV;
 
 	/* Handle the loop mode */
-	loop_mode = fsl_espi_read_reg(mpc8xxx_spi, ESPI_SPMODE);
+	loop_mode = fsl_espi_read_reg(espi, ESPI_SPMODE);
 	loop_mode &= ~SPMODE_LOOP;
 	if (spi->mode & SPI_LOOP)
 		loop_mode |= SPMODE_LOOP;
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODE, loop_mode);
+	fsl_espi_write_reg(espi, ESPI_SPMODE, loop_mode);
 
 	fsl_espi_setup_transfer(spi, NULL);
 
-	pm_runtime_mark_last_busy(mpc8xxx_spi->dev);
-	pm_runtime_put_autosuspend(mpc8xxx_spi->dev);
+	pm_runtime_mark_last_busy(espi->dev);
+	pm_runtime_put_autosuspend(espi->dev);
 
 	return 0;
 }
@@ -493,52 +511,52 @@ static void fsl_espi_cleanup(struct spi_device *spi)
 	spi_set_ctldata(spi, NULL);
 }
 
-static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
+static void fsl_espi_cpu_irq(struct fsl_espi *espi, u32 events)
 {
-	if (mspi->rx_len)
-		fsl_espi_read_rx_fifo(mspi, events);
+	if (espi->rx_len)
+		fsl_espi_read_rx_fifo(espi, events);
 
-	if (mspi->tx_len)
-		fsl_espi_fill_tx_fifo(mspi, events);
+	if (espi->tx_len)
+		fsl_espi_fill_tx_fifo(espi, events);
 
-	if (mspi->tx_len || mspi->rx_len)
+	if (espi->tx_len || espi->rx_len)
 		return;
 
 	/* we're done, but check for errors before returning */
-	events = fsl_espi_read_reg(mspi, ESPI_SPIE);
+	events = fsl_espi_read_reg(espi, ESPI_SPIE);
 
 	if (!(events & SPIE_DON))
-		dev_err(mspi->dev,
+		dev_err(espi->dev,
 			"Transfer done but SPIE_DON isn't set!\n");
 
 	if (SPIE_RXCNT(events) || SPIE_TXCNT(events) != FSL_ESPI_FIFO_SIZE)
-		dev_err(mspi->dev, "Transfer done but rx/tx fifo's aren't empty!\n");
+		dev_err(espi->dev, "Transfer done but rx/tx fifo's aren't empty!\n");
 
-	complete(&mspi->done);
+	complete(&espi->done);
 }
 
 static irqreturn_t fsl_espi_irq(s32 irq, void *context_data)
 {
-	struct mpc8xxx_spi *mspi = context_data;
+	struct fsl_espi *espi = context_data;
 	u32 events;
 
-	spin_lock(&mspi->lock);
+	spin_lock(&espi->lock);
 
 	/* Get interrupt events(tx/rx) */
-	events = fsl_espi_read_reg(mspi, ESPI_SPIE);
+	events = fsl_espi_read_reg(espi, ESPI_SPIE);
 	if (!events) {
-		spin_unlock(&mspi->lock);
+		spin_unlock(&espi->lock);
 		return IRQ_NONE;
 	}
 
-	dev_vdbg(mspi->dev, "%s: events %x\n", __func__, events);
+	dev_vdbg(espi->dev, "%s: events %x\n", __func__, events);
 
-	fsl_espi_cpu_irq(mspi, events);
+	fsl_espi_cpu_irq(espi, events);
 
 	/* Clear the events */
-	fsl_espi_write_reg(mspi, ESPI_SPIE, events);
+	fsl_espi_write_reg(espi, ESPI_SPIE, events);
 
-	spin_unlock(&mspi->lock);
+	spin_unlock(&espi->lock);
 
 	return IRQ_HANDLED;
 }
@@ -547,12 +565,12 @@ static irqreturn_t fsl_espi_irq(s32 irq, void *context_data)
 static int fsl_espi_runtime_suspend(struct device *dev)
 {
 	struct spi_master *master = dev_get_drvdata(dev);
-	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(master);
+	struct fsl_espi *espi = spi_master_get_devdata(master);
 	u32 regval;
 
-	regval = fsl_espi_read_reg(mpc8xxx_spi, ESPI_SPMODE);
+	regval = fsl_espi_read_reg(espi, ESPI_SPMODE);
 	regval &= ~SPMODE_ENABLE;
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODE, regval);
+	fsl_espi_write_reg(espi, ESPI_SPMODE, regval);
 
 	return 0;
 }
@@ -560,12 +578,12 @@ static int fsl_espi_runtime_suspend(struct device *dev)
 static int fsl_espi_runtime_resume(struct device *dev)
 {
 	struct spi_master *master = dev_get_drvdata(dev);
-	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(master);
+	struct fsl_espi *espi = spi_master_get_devdata(master);
 	u32 regval;
 
-	regval = fsl_espi_read_reg(mpc8xxx_spi, ESPI_SPMODE);
+	regval = fsl_espi_read_reg(espi, ESPI_SPMODE);
 	regval |= SPMODE_ENABLE;
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODE, regval);
+	fsl_espi_write_reg(espi, ESPI_SPMODE, regval);
 
 	return 0;
 }
@@ -579,16 +597,16 @@ static size_t fsl_espi_max_message_size(struct spi_device *spi)
 static void fsl_espi_init_regs(struct device *dev, bool initial)
 {
 	struct spi_master *master = dev_get_drvdata(dev);
-	struct mpc8xxx_spi *mspi = spi_master_get_devdata(master);
+	struct fsl_espi *espi = spi_master_get_devdata(master);
 	struct device_node *nc;
 	u32 csmode, cs, prop;
 	int ret;
 
 	/* SPI controller initializations */
-	fsl_espi_write_reg(mspi, ESPI_SPMODE, 0);
-	fsl_espi_write_reg(mspi, ESPI_SPIM, 0);
-	fsl_espi_write_reg(mspi, ESPI_SPCOM, 0);
-	fsl_espi_write_reg(mspi, ESPI_SPIE, 0xffffffff);
+	fsl_espi_write_reg(espi, ESPI_SPMODE, 0);
+	fsl_espi_write_reg(espi, ESPI_SPIM, 0);
+	fsl_espi_write_reg(espi, ESPI_SPCOM, 0);
+	fsl_espi_write_reg(espi, ESPI_SPIE, 0xffffffff);
 
 	/* Init eSPI CS mode register */
 	for_each_available_child_of_node(master->dev.of_node, nc) {
@@ -613,24 +631,24 @@ static void fsl_espi_init_regs(struct device *dev, bool initial)
 			csmode |= CSMODE_AFT(prop);
 		}
 
-		fsl_espi_write_reg(mspi, ESPI_SPMODEx(cs), csmode);
+		fsl_espi_write_reg(espi, ESPI_SPMODEx(cs), csmode);
 
 		if (initial)
 			dev_info(dev, "cs=%u, init_csmode=0x%x\n", cs, csmode);
 	}
 
 	/* Enable SPI interface */
-	fsl_espi_write_reg(mspi, ESPI_SPMODE, SPMODE_INIT_VAL | SPMODE_ENABLE);
+	fsl_espi_write_reg(espi, ESPI_SPMODE, SPMODE_INIT_VAL | SPMODE_ENABLE);
 }
 
 static int fsl_espi_probe(struct device *dev, struct resource *mem,
 			  unsigned int irq, unsigned int num_cs)
 {
 	struct spi_master *master;
-	struct mpc8xxx_spi *mpc8xxx_spi;
+	struct fsl_espi *espi;
 	int ret;
 
-	master = spi_alloc_master(dev, sizeof(struct mpc8xxx_spi));
+	master = spi_alloc_master(dev, sizeof(struct fsl_espi));
 	if (!master)
 		return -ENOMEM;
 
@@ -647,35 +665,33 @@ static int fsl_espi_probe(struct device *dev, struct resource *mem,
 	master->max_message_size = fsl_espi_max_message_size;
 	master->num_chipselect = num_cs;
 
-	mpc8xxx_spi = spi_master_get_devdata(master);
-	spin_lock_init(&mpc8xxx_spi->lock);
+	espi = spi_master_get_devdata(master);
+	spin_lock_init(&espi->lock);
 
-	mpc8xxx_spi->dev = dev;
-	mpc8xxx_spi->spibrg = fsl_get_sys_freq();
-	if (mpc8xxx_spi->spibrg == -1) {
+	espi->dev = dev;
+	espi->spibrg = fsl_get_sys_freq();
+	if (espi->spibrg == -1) {
 		dev_err(dev, "Can't get sys frequency!\n");
 		ret = -EINVAL;
 		goto err_probe;
 	}
 
-	init_completion(&mpc8xxx_spi->done);
+	init_completion(&espi->done);
 
-	mpc8xxx_spi->local_buf =
-		devm_kmalloc(dev, SPCOM_TRANLEN_MAX, GFP_KERNEL);
-	if (!mpc8xxx_spi->local_buf) {
+	espi->local_buf = devm_kmalloc(dev, SPCOM_TRANLEN_MAX, GFP_KERNEL);
+	if (!espi->local_buf) {
 		ret = -ENOMEM;
 		goto err_probe;
 	}
 
-	mpc8xxx_spi->reg_base = devm_ioremap_resource(dev, mem);
-	if (IS_ERR(mpc8xxx_spi->reg_base)) {
-		ret = PTR_ERR(mpc8xxx_spi->reg_base);
+	espi->reg_base = devm_ioremap_resource(dev, mem);
+	if (IS_ERR(espi->reg_base)) {
+		ret = PTR_ERR(espi->reg_base);
 		goto err_probe;
 	}
 
 	/* Register for SPI Interrupt */
-	ret = devm_request_irq(dev, irq, fsl_espi_irq, 0, "fsl_espi",
-			       mpc8xxx_spi);
+	ret = devm_request_irq(dev, irq, fsl_espi_irq, 0, "fsl_espi", espi);
 	if (ret)
 		goto err_probe;
 
@@ -691,7 +707,7 @@ static int fsl_espi_probe(struct device *dev, struct resource *mem,
 	if (ret < 0)
 		goto err_pm;
 
-	dev_info(dev, "at 0x%p (irq = %u)\n", mpc8xxx_spi->reg_base, irq);
+	dev_info(dev, "at 0x%p (irq = %u)\n", espi->reg_base, irq);
 
 	pm_runtime_mark_last_busy(dev);
 	pm_runtime_put_autosuspend(dev);

commit 456c742be68eca1c8c55f4e0384f0418a55a31c5
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Nov 13 14:40:18 2016 +0100

    spi: fsl-espi: factor out fsl_espi_init_regs
    
    The register initialization is the same in fsl_espi_probe and in
    of_fsl_espi_resume. Therefore factor it out into fsl_espi_init_regs.
    
    It was actually a bug that CSMODE_BEF and CSMODE_AFT were not set
    in of_fsl_espi_resume. Seems like nobody ever used values other
    than zero for these parameters.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 5d84694b7323..7a903434c881 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -576,13 +576,58 @@ static size_t fsl_espi_max_message_size(struct spi_device *spi)
 	return SPCOM_TRANLEN_MAX;
 }
 
+static void fsl_espi_init_regs(struct device *dev, bool initial)
+{
+	struct spi_master *master = dev_get_drvdata(dev);
+	struct mpc8xxx_spi *mspi = spi_master_get_devdata(master);
+	struct device_node *nc;
+	u32 csmode, cs, prop;
+	int ret;
+
+	/* SPI controller initializations */
+	fsl_espi_write_reg(mspi, ESPI_SPMODE, 0);
+	fsl_espi_write_reg(mspi, ESPI_SPIM, 0);
+	fsl_espi_write_reg(mspi, ESPI_SPCOM, 0);
+	fsl_espi_write_reg(mspi, ESPI_SPIE, 0xffffffff);
+
+	/* Init eSPI CS mode register */
+	for_each_available_child_of_node(master->dev.of_node, nc) {
+		/* get chip select */
+		ret = of_property_read_u32(nc, "reg", &cs);
+		if (ret || cs >= master->num_chipselect)
+			continue;
+
+		csmode = CSMODE_INIT_VAL;
+
+		/* check if CSBEF is set in device tree */
+		ret = of_property_read_u32(nc, "fsl,csbef", &prop);
+		if (!ret) {
+			csmode &= ~(CSMODE_BEF(0xf));
+			csmode |= CSMODE_BEF(prop);
+		}
+
+		/* check if CSAFT is set in device tree */
+		ret = of_property_read_u32(nc, "fsl,csaft", &prop);
+		if (!ret) {
+			csmode &= ~(CSMODE_AFT(0xf));
+			csmode |= CSMODE_AFT(prop);
+		}
+
+		fsl_espi_write_reg(mspi, ESPI_SPMODEx(cs), csmode);
+
+		if (initial)
+			dev_info(dev, "cs=%u, init_csmode=0x%x\n", cs, csmode);
+	}
+
+	/* Enable SPI interface */
+	fsl_espi_write_reg(mspi, ESPI_SPMODE, SPMODE_INIT_VAL | SPMODE_ENABLE);
+}
+
 static int fsl_espi_probe(struct device *dev, struct resource *mem,
 			  unsigned int irq, unsigned int num_cs)
 {
 	struct spi_master *master;
 	struct mpc8xxx_spi *mpc8xxx_spi;
-	struct device_node *nc;
-	u32 regval, csmode, cs, prop;
 	int ret;
 
 	master = spi_alloc_master(dev, sizeof(struct mpc8xxx_spi));
@@ -634,44 +679,7 @@ static int fsl_espi_probe(struct device *dev, struct resource *mem,
 	if (ret)
 		goto err_probe;
 
-	/* SPI controller initializations */
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODE, 0);
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIM, 0);
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPCOM, 0);
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIE, 0xffffffff);
-
-	/* Init eSPI CS mode register */
-	for_each_available_child_of_node(master->dev.of_node, nc) {
-		/* get chip select */
-		ret = of_property_read_u32(nc, "reg", &cs);
-		if (ret || cs >= num_cs)
-			continue;
-
-		csmode = CSMODE_INIT_VAL;
-
-		/* check if CSBEF is set in device tree */
-		ret = of_property_read_u32(nc, "fsl,csbef", &prop);
-		if (!ret) {
-			csmode &= ~(CSMODE_BEF(0xf));
-			csmode |= CSMODE_BEF(prop);
-		}
-
-		/* check if CSAFT is set in device tree */
-		ret = of_property_read_u32(nc, "fsl,csaft", &prop);
-		if (!ret) {
-			csmode &= ~(CSMODE_AFT(0xf));
-			csmode |= CSMODE_AFT(prop);
-		}
-
-		fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODEx(cs), csmode);
-
-		dev_info(dev, "cs=%u, init_csmode=0x%x\n", cs, csmode);
-	}
-
-	/* Enable SPI interface */
-	regval = SPMODE_INIT_VAL | SPMODE_ENABLE;
-
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODE, regval);
+	fsl_espi_init_regs(dev, true);
 
 	pm_runtime_set_autosuspend_delay(dev, AUTOSUSPEND_TIMEOUT);
 	pm_runtime_use_autosuspend(dev);
@@ -771,27 +779,9 @@ static int of_fsl_espi_suspend(struct device *dev)
 static int of_fsl_espi_resume(struct device *dev)
 {
 	struct spi_master *master = dev_get_drvdata(dev);
-	struct mpc8xxx_spi *mpc8xxx_spi;
-	u32 regval;
-	int i, ret;
-
-	mpc8xxx_spi = spi_master_get_devdata(master);
-
-	/* SPI controller initializations */
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODE, 0);
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIM, 0);
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPCOM, 0);
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIE, 0xffffffff);
-
-	/* Init eSPI CS mode register */
-	for (i = 0; i < master->num_chipselect; i++)
-		fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODEx(i),
-				      CSMODE_INIT_VAL);
-
-	/* Enable SPI interface */
-	regval = SPMODE_INIT_VAL | SPMODE_ENABLE;
+	int ret;
 
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODE, regval);
+	fsl_espi_init_regs(dev, false);
 
 	ret = pm_runtime_force_resume(dev);
 	if (ret < 0)

commit 219b5e3b239226c50ff6c4de6abf0534407df620
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Nov 13 14:38:05 2016 +0100

    spi: fsl-espi: introduce struct fsl_espi_cs
    
    Very little from struct spi_mpc8xxx_cs is relevant for fsl-espi.
    Therefore replace it with struct fsl_espi_cs.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 58314d775925..5d84694b7323 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -93,6 +93,10 @@
 
 #define AUTOSUSPEND_TIMEOUT 2000
 
+struct fsl_espi_cs {
+	u32 hw_mode;
+};
+
 static inline u32 fsl_espi_read_reg(struct mpc8xxx_spi *mspi, int offset)
 {
 	return ioread32be(mspi->reg_base + offset);
@@ -280,7 +284,7 @@ static void fsl_espi_setup_transfer(struct spi_device *spi,
 	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
 	int bits_per_word = t ? t->bits_per_word : spi->bits_per_word;
 	u32 pm, hz = t ? t->speed_hz : spi->max_speed_hz;
-	struct spi_mpc8xxx_cs *cs = spi->controller_state;
+	struct fsl_espi_cs *cs = spi_get_ctldata(spi);
 	u32 hw_mode_old = cs->hw_mode;
 
 	/* mask out bits we are going to set */
@@ -437,7 +441,7 @@ static int fsl_espi_setup(struct spi_device *spi)
 {
 	struct mpc8xxx_spi *mpc8xxx_spi;
 	u32 loop_mode;
-	struct spi_mpc8xxx_cs *cs = spi_get_ctldata(spi);
+	struct fsl_espi_cs *cs = spi_get_ctldata(spi);
 
 	if (!spi->max_speed_hz)
 		return -EINVAL;
@@ -483,7 +487,7 @@ static int fsl_espi_setup(struct spi_device *spi)
 
 static void fsl_espi_cleanup(struct spi_device *spi)
 {
-	struct spi_mpc8xxx_cs *cs = spi_get_ctldata(spi);
+	struct fsl_espi_cs *cs = spi_get_ctldata(spi);
 
 	kfree(cs);
 	spi_set_ctldata(spi, NULL);

commit 7cb55577232fa07a089e0e0353fb445403f34697
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Nov 13 14:37:41 2016 +0100

    spi: fsl-espi: migrate relevant parts of mpc8xxx_spi_probe and of_mpc8xxx_spi_probe
    
    Very little of the library functions mpc8xxx_spi_probe and
    of_mpc8xxx_spi_probe is relevant for fsl-espi.
    
    Therefore migrate the relevant parts to fsl-espi (considering
    that get_brgfreq() always returns -1 on systems with ESPI)
    and remove use of these functions.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index e378622f4a60..58314d775925 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -587,9 +587,9 @@ static int fsl_espi_probe(struct device *dev, struct resource *mem,
 
 	dev_set_drvdata(dev, master);
 
-	mpc8xxx_spi_probe(dev, mem, irq);
-
-	master->mode_bits |= SPI_RX_DUAL;
+	master->mode_bits = SPI_RX_DUAL | SPI_CPOL | SPI_CPHA | SPI_CS_HIGH |
+			    SPI_LSB_FIRST | SPI_LOOP;
+	master->dev.of_node = dev->of_node;
 	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);
 	master->setup = fsl_espi_setup;
 	master->cleanup = fsl_espi_cleanup;
@@ -601,6 +601,16 @@ static int fsl_espi_probe(struct device *dev, struct resource *mem,
 	mpc8xxx_spi = spi_master_get_devdata(master);
 	spin_lock_init(&mpc8xxx_spi->lock);
 
+	mpc8xxx_spi->dev = dev;
+	mpc8xxx_spi->spibrg = fsl_get_sys_freq();
+	if (mpc8xxx_spi->spibrg == -1) {
+		dev_err(dev, "Can't get sys frequency!\n");
+		ret = -EINVAL;
+		goto err_probe;
+	}
+
+	init_completion(&mpc8xxx_spi->done);
+
 	mpc8xxx_spi->local_buf =
 		devm_kmalloc(dev, SPCOM_TRANLEN_MAX, GFP_KERNEL);
 	if (!mpc8xxx_spi->local_buf) {
@@ -713,10 +723,6 @@ static int of_fsl_espi_probe(struct platform_device *ofdev)
 		return -EINVAL;
 	}
 
-	ret = of_mpc8xxx_spi_probe(ofdev);
-	if (ret)
-		return ret;
-
 	num_cs = of_fsl_espi_get_chipselects(dev);
 	if (!num_cs)
 		return -EINVAL;

commit cdb2f77cf520d72a4782354f08deb43db00eff19
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Nov 13 14:36:47 2016 +0100

    spi: fsl-espi: remove usage of mpc8xxx_spi->irq
    
    There's no need to access mpc8xxx_spi->irq, we can use function
    parameter irq directly.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 38d3a9393e23..e378622f4a60 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -615,8 +615,8 @@ static int fsl_espi_probe(struct device *dev, struct resource *mem,
 	}
 
 	/* Register for SPI Interrupt */
-	ret = devm_request_irq(dev, mpc8xxx_spi->irq, fsl_espi_irq,
-			  0, "fsl_espi", mpc8xxx_spi);
+	ret = devm_request_irq(dev, irq, fsl_espi_irq, 0, "fsl_espi",
+			       mpc8xxx_spi);
 	if (ret)
 		goto err_probe;
 
@@ -669,8 +669,7 @@ static int fsl_espi_probe(struct device *dev, struct resource *mem,
 	if (ret < 0)
 		goto err_pm;
 
-	dev_info(dev, "at 0x%p (irq = %d)\n", mpc8xxx_spi->reg_base,
-		 mpc8xxx_spi->irq);
+	dev_info(dev, "at 0x%p (irq = %u)\n", mpc8xxx_spi->reg_base, irq);
 
 	pm_runtime_mark_last_busy(dev);
 	pm_runtime_put_autosuspend(dev);

commit e3ce4f44f6a0e698f945633355d1ba5fbd32cfa6
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Nov 13 14:37:18 2016 +0100

    spi: fsl-espi: remove usage of mpc8xxx_spi->flags
    
    Change the check to access property "mode" directly.
    This allows us to get rid of mpc8xxx_spi->flags in a subsequent
    patch in this patch series as it's used nowhere else.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 29cd4e070d1b..38d3a9393e23 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -620,12 +620,6 @@ static int fsl_espi_probe(struct device *dev, struct resource *mem,
 	if (ret)
 		goto err_probe;
 
-	if (mpc8xxx_spi->flags & SPI_QE_CPU_MODE) {
-		dev_err(dev, "SPI_QE_CPU_MODE is not supported on ESPI!\n");
-		ret = -EINVAL;
-		goto err_probe;
-	}
-
 	/* SPI controller initializations */
 	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODE, 0);
 	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIM, 0);
@@ -715,6 +709,11 @@ static int of_fsl_espi_probe(struct platform_device *ofdev)
 	unsigned int irq, num_cs;
 	int ret;
 
+	if (of_property_read_bool(np, "mode")) {
+		dev_err(dev, "mode property is not supported on ESPI!\n");
+		return -EINVAL;
+	}
+
 	ret = of_mpc8xxx_spi_probe(ofdev);
 	if (ret)
 		return ret;

commit 7454346b0cbc2a71311e1edcf1da5f1113c8a45c
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Nov 13 14:36:39 2016 +0100

    spi: fsl-espi: remove remaining usage of struct fsl_spi_platform_data
    
    Use master->num_chipselect directly instead of pdata->max_chipselect.
    In this context let of_fsl_espi_get_chipselects return max_chipselect.
    
    This change allows us to get rid of struct fsl_spi_platform_data
    completely in the fsl-espi driver.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index e5d7164d3956..29cd4e070d1b 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -573,9 +573,8 @@ static size_t fsl_espi_max_message_size(struct spi_device *spi)
 }
 
 static int fsl_espi_probe(struct device *dev, struct resource *mem,
-			  unsigned int irq)
+			  unsigned int irq, unsigned int num_cs)
 {
-	struct fsl_spi_platform_data *pdata = dev_get_platdata(dev);
 	struct spi_master *master;
 	struct mpc8xxx_spi *mpc8xxx_spi;
 	struct device_node *nc;
@@ -597,6 +596,7 @@ static int fsl_espi_probe(struct device *dev, struct resource *mem,
 	master->transfer_one_message = fsl_espi_do_one_msg;
 	master->auto_runtime_pm = true;
 	master->max_message_size = fsl_espi_max_message_size;
+	master->num_chipselect = num_cs;
 
 	mpc8xxx_spi = spi_master_get_devdata(master);
 	spin_lock_init(&mpc8xxx_spi->lock);
@@ -636,7 +636,7 @@ static int fsl_espi_probe(struct device *dev, struct resource *mem,
 	for_each_available_child_of_node(master->dev.of_node, nc) {
 		/* get chip select */
 		ret = of_property_read_u32(nc, "reg", &cs);
-		if (ret || cs >= pdata->max_chipselect)
+		if (ret || cs >= num_cs)
 			continue;
 
 		csmode = CSMODE_INIT_VAL;
@@ -695,19 +695,16 @@ static int fsl_espi_probe(struct device *dev, struct resource *mem,
 static int of_fsl_espi_get_chipselects(struct device *dev)
 {
 	struct device_node *np = dev->of_node;
-	struct fsl_spi_platform_data *pdata = dev_get_platdata(dev);
 	u32 num_cs;
 	int ret;
 
 	ret = of_property_read_u32(np, "fsl,espi-num-chipselects", &num_cs);
 	if (ret) {
 		dev_err(dev, "No 'fsl,espi-num-chipselects' property\n");
-		return -EINVAL;
+		return 0;
 	}
 
-	pdata->max_chipselect = num_cs;
-
-	return 0;
+	return num_cs;
 }
 
 static int of_fsl_espi_probe(struct platform_device *ofdev)
@@ -715,16 +712,16 @@ static int of_fsl_espi_probe(struct platform_device *ofdev)
 	struct device *dev = &ofdev->dev;
 	struct device_node *np = ofdev->dev.of_node;
 	struct resource mem;
-	unsigned int irq;
+	unsigned int irq, num_cs;
 	int ret;
 
 	ret = of_mpc8xxx_spi_probe(ofdev);
 	if (ret)
 		return ret;
 
-	ret = of_fsl_espi_get_chipselects(dev);
-	if (ret)
-		return ret;
+	num_cs = of_fsl_espi_get_chipselects(dev);
+	if (!num_cs)
+		return -EINVAL;
 
 	ret = of_address_to_resource(np, 0, &mem);
 	if (ret)
@@ -734,7 +731,7 @@ static int of_fsl_espi_probe(struct platform_device *ofdev)
 	if (!irq)
 		return -EINVAL;
 
-	return fsl_espi_probe(dev, &mem, irq);
+	return fsl_espi_probe(dev, &mem, irq, num_cs);
 }
 
 static int of_fsl_espi_remove(struct platform_device *dev)
@@ -765,7 +762,6 @@ static int of_fsl_espi_suspend(struct device *dev)
 
 static int of_fsl_espi_resume(struct device *dev)
 {
-	struct fsl_spi_platform_data *pdata = dev_get_platdata(dev);
 	struct spi_master *master = dev_get_drvdata(dev);
 	struct mpc8xxx_spi *mpc8xxx_spi;
 	u32 regval;
@@ -780,7 +776,7 @@ static int of_fsl_espi_resume(struct device *dev)
 	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIE, 0xffffffff);
 
 	/* Init eSPI CS mode register */
-	for (i = 0; i < pdata->max_chipselect; i++)
+	for (i = 0; i < master->num_chipselect; i++)
 		fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODEx(i),
 				      CSMODE_INIT_VAL);
 

commit 2808f778de3d591c3c84034688fd09e38ada27a6
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Nov 13 14:36:16 2016 +0100

    spi: fsl-espi: don't set pdata->cs_control
    
    Don't set pdata->cs_control as it's nowhere used in fsl-espi and fsl-lib.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index a1e1b68b400a..e5d7164d3956 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -706,7 +706,6 @@ static int of_fsl_espi_get_chipselects(struct device *dev)
 	}
 
 	pdata->max_chipselect = num_cs;
-	pdata->cs_control = NULL;
 
 	return 0;
 }

commit 689d41fbd40afe3938eccfe3ea890872d86aec5b
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Nov 13 14:36:01 2016 +0100

    spi: fsl-espi: remove usage of pdata->initial_spmode
    
    Remove pdata->initial_spmode as it is nowhere set.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 6624c5a06ffc..a1e1b68b400a 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -661,7 +661,7 @@ static int fsl_espi_probe(struct device *dev, struct resource *mem,
 	}
 
 	/* Enable SPI interface */
-	regval = pdata->initial_spmode | SPMODE_INIT_VAL | SPMODE_ENABLE;
+	regval = SPMODE_INIT_VAL | SPMODE_ENABLE;
 
 	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODE, regval);
 
@@ -786,7 +786,7 @@ static int of_fsl_espi_resume(struct device *dev)
 				      CSMODE_INIT_VAL);
 
 	/* Enable SPI interface */
-	regval = pdata->initial_spmode | SPMODE_INIT_VAL | SPMODE_ENABLE;
+	regval = SPMODE_INIT_VAL | SPMODE_ENABLE;
 
 	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODE, regval);
 

commit 8263cb33c8636e4b333d97ef5995a2b484ea48ea
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Nov 9 22:58:34 2016 +0100

    spi: fsl-espi: add support for dual output read mode
    
    This patch adds support for dual output read mode.
    
    It was successfully tested on a P1014-based device with S25FL128S
    SPINOR flash. With 50MHz SPI clock the read rate is 11MByte/s.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 9ccbfbc75933..6624c5a06ffc 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -334,6 +334,8 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 		mpc8xxx_spi->tx_len = mpc8xxx_spi->rxskip;
 		mpc8xxx_spi->rx_len = t->len - mpc8xxx_spi->rxskip;
 		mpc8xxx_spi->rx = t->rx_buf + mpc8xxx_spi->rxskip;
+		if (t->rx_nbits == SPI_NBITS_DUAL)
+			spcom |= SPCOM_DO;
 	}
 
 	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPCOM, spcom);
@@ -369,6 +371,11 @@ static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)
 	int ret;
 
 	mspi->rxskip = fsl_espi_check_rxskip_mode(m);
+	if (trans->rx_nbits == SPI_NBITS_DUAL && !mspi->rxskip) {
+		dev_err(mspi->dev, "Dual output mode requires RXSKIP mode!\n");
+		return -EINVAL;
+	}
+
 	fsl_espi_copy_to_buf(m, mspi);
 	fsl_espi_setup_transfer(spi, trans);
 
@@ -387,7 +394,7 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 			       struct spi_message *m)
 {
 	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
-	unsigned int delay_usecs = 0;
+	unsigned int delay_usecs = 0, rx_nbits = 0;
 	struct spi_transfer *t, trans = {};
 	int ret;
 
@@ -398,6 +405,8 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 	list_for_each_entry(t, &m->transfers, transfer_list) {
 		if (t->delay_usecs > delay_usecs)
 			delay_usecs = t->delay_usecs;
+		if (t->rx_nbits > rx_nbits)
+			rx_nbits = t->rx_nbits;
 	}
 
 	t = list_first_entry(&m->transfers, struct spi_transfer,
@@ -409,6 +418,7 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 	trans.delay_usecs = delay_usecs;
 	trans.tx_buf = mspi->local_buf;
 	trans.rx_buf = mspi->local_buf;
+	trans.rx_nbits = rx_nbits;
 
 	if (trans.len)
 		ret = fsl_espi_trans(m, &trans);
@@ -580,6 +590,7 @@ static int fsl_espi_probe(struct device *dev, struct resource *mem,
 
 	mpc8xxx_spi_probe(dev, mem, irq);
 
+	master->mode_bits |= SPI_RX_DUAL;
 	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);
 	master->setup = fsl_espi_setup;
 	master->cleanup = fsl_espi_cleanup;

commit aca75157d9beb7b171a178446ecdb4d047b9f934
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Nov 9 22:58:01 2016 +0100

    spi: fsl-espi: add support for ESPI RXSKIP mode
    
    This patch adds support for ESPI RXSKIP mode. This mode is optimized
    for flash reads:
    - sends a number of bytes and then reads a number of bytes
    - shifts out zeros automatically when reading
    
    Supporting RXSKIP mode is a prerequisite for supporting dual output
    read mode.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index edb524f831a3..9ccbfbc75933 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -150,7 +150,8 @@ static void fsl_espi_copy_to_buf(struct spi_message *m,
 	list_for_each_entry(t, &m->transfers, transfer_list) {
 		if (t->tx_buf)
 			fsl_espi_memcpy_swab(buf, t->tx_buf, m, t);
-		else
+		/* In RXSKIP mode controller shifts out zeros internally */
+		else if (!mspi->rxskip)
 			memset(buf, 0, t->len);
 		buf += t->len;
 	}
@@ -203,6 +204,37 @@ static int fsl_espi_check_message(struct spi_message *m)
 	return 0;
 }
 
+static unsigned int fsl_espi_check_rxskip_mode(struct spi_message *m)
+{
+	struct spi_transfer *t;
+	unsigned int i = 0, rxskip = 0;
+
+	/*
+	 * prerequisites for ESPI rxskip mode:
+	 * - message has two transfers
+	 * - first transfer is a write and second is a read
+	 *
+	 * In addition the current low-level transfer mechanism requires
+	 * that the rxskip bytes fit into the TX FIFO. Else the transfer
+	 * would hang because after the first FSL_ESPI_FIFO_SIZE bytes
+	 * the TX FIFO isn't re-filled.
+	 */
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+		if (i == 0) {
+			if (!t->tx_buf || t->rx_buf ||
+			    t->len > FSL_ESPI_FIFO_SIZE)
+				return 0;
+			rxskip = t->len;
+		} else if (i == 1) {
+			if (t->tx_buf || !t->rx_buf)
+				return 0;
+		}
+		i++;
+	}
+
+	return i == 2 ? rxskip : 0;
+}
+
 static void fsl_espi_fill_tx_fifo(struct mpc8xxx_spi *mspi, u32 events)
 {
 	u32 tx_fifo_avail;
@@ -281,7 +313,7 @@ static void fsl_espi_setup_transfer(struct spi_device *spi,
 static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 {
 	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
-	u32 mask;
+	u32 mask, spcom;
 	int ret;
 
 	mpc8xxx_spi->rx_len = t->len;
@@ -293,8 +325,18 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	reinit_completion(&mpc8xxx_spi->done);
 
 	/* Set SPCOM[CS] and SPCOM[TRANLEN] field */
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPCOM,
-		(SPCOM_CS(spi->chip_select) | SPCOM_TRANLEN(t->len - 1)));
+	spcom = SPCOM_CS(spi->chip_select);
+	spcom |= SPCOM_TRANLEN(t->len - 1);
+
+	/* configure RXSKIP mode */
+	if (mpc8xxx_spi->rxskip) {
+		spcom |= SPCOM_RXSKIP(mpc8xxx_spi->rxskip);
+		mpc8xxx_spi->tx_len = mpc8xxx_spi->rxskip;
+		mpc8xxx_spi->rx_len = t->len - mpc8xxx_spi->rxskip;
+		mpc8xxx_spi->rx = t->rx_buf + mpc8xxx_spi->rxskip;
+	}
+
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPCOM, spcom);
 
 	/* enable interrupts */
 	mask = SPIM_DON;
@@ -326,6 +368,7 @@ static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)
 	struct spi_device *spi = m->spi;
 	int ret;
 
+	mspi->rxskip = fsl_espi_check_rxskip_mode(m);
 	fsl_espi_copy_to_buf(m, mspi);
 	fsl_espi_setup_transfer(spi, trans);
 

commit 8f3086d2a9c1104f42d2d0247ef52b01c6d898d8
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Fri Nov 4 21:01:12 2016 +0100

    spi: fsl-espi: don't write ESPI_SPMODE register if the mode doesn't change
    
    There's no need to bother the chip if the mode doesn't change.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 1029bd2ff5f1..edb524f831a3 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -249,6 +249,7 @@ static void fsl_espi_setup_transfer(struct spi_device *spi,
 	int bits_per_word = t ? t->bits_per_word : spi->bits_per_word;
 	u32 pm, hz = t ? t->speed_hz : spi->max_speed_hz;
 	struct spi_mpc8xxx_cs *cs = spi->controller_state;
+	u32 hw_mode_old = cs->hw_mode;
 
 	/* mask out bits we are going to set */
 	cs->hw_mode &= ~(CSMODE_LEN(0xF) | CSMODE_DIV16 | CSMODE_PM(0xF));
@@ -271,8 +272,10 @@ static void fsl_espi_setup_transfer(struct spi_device *spi,
 
 	cs->hw_mode |= CSMODE_PM(pm);
 
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODEx(spi->chip_select),
-			   cs->hw_mode);
+	/* don't write the mode register if the mode doesn't change */
+	if (cs->hw_mode != hw_mode_old)
+		fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODEx(spi->chip_select),
+				   cs->hw_mode);
 }
 
 static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)

commit 60d9531a61efc8e6b69d04089d50a0a929090fe1
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Fri Nov 4 21:00:40 2016 +0100

    spi: fsl-espi: remove unneeded call to fsl_espi_setup_transfer
    
    Resetting the chip to a default transfer mode after each transfer
    doesn't provide any benefit. Therefore remove this call.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 8b3a28739d9a..1029bd2ff5f1 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -331,8 +331,6 @@ static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)
 	if (trans->delay_usecs)
 		udelay(trans->delay_usecs);
 
-	fsl_espi_setup_transfer(spi, NULL);
-
 	if (!ret)
 		fsl_espi_copy_from_buf(m, mspi);
 

commit 73aaf15849d9421fa696c3d7785952d8100042b2
Author: Paulo Zaneti <paulo.zaneti@datacom.ind.br>
Date:   Sat Oct 29 11:02:19 2016 +0200

    spi: fsl-espi: fix support for all available clock rates
    
    According to NXP ESPI datasheet, the SPI clock rate is:
    
        spi_clk = System_Clock / ( 2 * DIV16 * ( 1 + PM ) )
    
    Where System_Clock is the platform clock divided by 2,
    DIV16 may be 1 or 16, and PM is a 4 bits integer (0 to 15).
    
    Isolating PM on the expression, we get:
    
        PM = (System_Clock / ( 2 * DIV16 * spi_clk ) ) - 1
    
    Where System_Clock = mpc8xxx_spi->spibrg / 2, spi_clk = hz,
    and DIV16 = 1 or DIV16 = 16. So,
    
        PM = (mpc8xxx_spi->spibrg / ( 4 * hz) ) - 1
    or
        PM = (mpc8xxx_spi->spibrg / ( 16 * 4 * hz) ) - 1
    
    Current spi-fsl-espi driver can't configure the HW for all
    supported clock rates. It filters out clock rates for PM = 0
    and PM = 1.
    
    This patch allows all range of supported clock rates to be
    configured on the ESPI controller.
    
    Signed-off-by: Paulo Zaneti <paulo.zaneti@datacom.ind.br>
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 1d3c9023391d..8b3a28739d9a 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -247,8 +247,7 @@ static void fsl_espi_setup_transfer(struct spi_device *spi,
 {
 	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
 	int bits_per_word = t ? t->bits_per_word : spi->bits_per_word;
-	u32 hz = t ? t->speed_hz : spi->max_speed_hz;
-	u8 pm;
+	u32 pm, hz = t ? t->speed_hz : spi->max_speed_hz;
 	struct spi_mpc8xxx_cs *cs = spi->controller_state;
 
 	/* mask out bits we are going to set */
@@ -256,22 +255,19 @@ static void fsl_espi_setup_transfer(struct spi_device *spi,
 
 	cs->hw_mode |= CSMODE_LEN(bits_per_word - 1);
 
-	if ((mpc8xxx_spi->spibrg / hz) > 64) {
+	pm = DIV_ROUND_UP(mpc8xxx_spi->spibrg, hz * 4) - 1;
+
+	if (pm > 15) {
 		cs->hw_mode |= CSMODE_DIV16;
-		pm = DIV_ROUND_UP(mpc8xxx_spi->spibrg, hz * 16 * 4);
-
-		WARN_ONCE(pm > 33, "%s: Requested speed is too low: %d Hz. "
-			  "Will use %d Hz instead.\n", dev_name(&spi->dev),
-				hz, mpc8xxx_spi->spibrg / (4 * 16 * (32 + 1)));
-		if (pm > 33)
-			pm = 33;
-	} else {
-		pm = DIV_ROUND_UP(mpc8xxx_spi->spibrg, hz * 4);
+		pm = DIV_ROUND_UP(mpc8xxx_spi->spibrg, hz * 16 * 4) - 1;
+
+		WARN_ONCE(pm > 15,
+			  "%s: Requested speed is too low: %u Hz. Will use %u Hz instead.\n",
+			  dev_name(&spi->dev), hz,
+			  mpc8xxx_spi->spibrg / (4 * 16 * (15 + 1)));
+		if (pm > 15)
+			pm = 15;
 	}
-	if (pm)
-		pm--;
-	if (pm < 2)
-		pm = 2;
 
 	cs->hw_mode |= CSMODE_PM(pm);
 

commit 66b8053e249c76b0d800805dac7e7dc80c3d7764
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sat Oct 29 10:53:19 2016 +0200

    spi: fsl-espi: small fix to error path in fsl_espi_irq
    
    spin_lock is used to obtain the spinlock, so spin_unlock
    has to be used here.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 2f95b19e67f7..1d3c9023391d 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -473,7 +473,7 @@ static irqreturn_t fsl_espi_irq(s32 irq, void *context_data)
 	/* Get interrupt events(tx/rx) */
 	events = fsl_espi_read_reg(mspi, ESPI_SPIE);
 	if (!events) {
-		spin_unlock_irq(&mspi->lock);
+		spin_unlock(&mspi->lock);
 		return IRQ_NONE;
 	}
 

commit f05689a662d47896da742f5338eab183ed692c1c
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Oct 27 21:27:35 2016 +0200

    spi: fsl-espi: fix and improve reading from RX FIFO
    
    Currently the driver polls in the ISR for enough bytes in the RX FIFO.
    An ISR should never do this.
    Change it to read as much as possible whenever the ISR is called.
    This also allows to significantly simplify the code.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 239f0362df61..2f95b19e67f7 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -224,6 +224,24 @@ static void fsl_espi_fill_tx_fifo(struct mpc8xxx_spi *mspi, u32 events)
 		}
 }
 
+static void fsl_espi_read_rx_fifo(struct mpc8xxx_spi *mspi, u32 events)
+{
+	u32 rx_fifo_avail = SPIE_RXCNT(events);
+
+	while (rx_fifo_avail >= min(4U, mspi->rx_len) && mspi->rx_len)
+		if (mspi->rx_len >= 4) {
+			*(u32 *)mspi->rx = fsl_espi_read_reg(mspi, ESPI_SPIRF);
+			mspi->rx += 4;
+			mspi->rx_len -= 4;
+			rx_fifo_avail -= 4;
+		} else {
+			*(u8 *)mspi->rx = fsl_espi_read_reg8(mspi, ESPI_SPIRF);
+			mspi->rx += 1;
+			mspi->rx_len -= 1;
+			rx_fifo_avail -= 1;
+		}
+}
+
 static void fsl_espi_setup_transfer(struct spi_device *spi,
 					struct spi_transfer *t)
 {
@@ -423,53 +441,8 @@ static void fsl_espi_cleanup(struct spi_device *spi)
 
 static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 {
-	/* We need handle RX first */
-	if (events & SPIE_RNE) {
-		u32 rx_data, tmp;
-		u8 rx_data_8;
-		int rx_nr_bytes = 4;
-		int ret;
-
-		/* Spin until RX is done */
-		if (SPIE_RXCNT(events) < min(4U, mspi->rx_len)) {
-			ret = spin_event_timeout(
-				!(SPIE_RXCNT(events =
-				fsl_espi_read_reg(mspi, ESPI_SPIE)) <
-						min(4U, mspi->rx_len)),
-						10000, 0); /* 10 msec */
-			if (!ret)
-				dev_err(mspi->dev,
-					 "tired waiting for SPIE_RXCNT\n");
-		}
-
-		if (mspi->rx_len >= 4) {
-			rx_data = fsl_espi_read_reg(mspi, ESPI_SPIRF);
-		} else if (!mspi->rx_len) {
-			dev_err(mspi->dev,
-				"unexpected RX(SPIE_RNE) interrupt occurred,\n"
-				"(local rxlen %d bytes, reg rxlen %d bytes)\n",
-				min(4U, mspi->rx_len), SPIE_RXCNT(events));
-			rx_nr_bytes = 0;
-		} else {
-			rx_nr_bytes = mspi->rx_len;
-			tmp = mspi->rx_len;
-			rx_data = 0;
-			while (tmp--) {
-				rx_data_8 = fsl_espi_read_reg8(mspi,
-							       ESPI_SPIRF);
-				rx_data |= (rx_data_8 << (tmp * 8));
-			}
-
-			rx_data <<= (4 - mspi->rx_len) * 8;
-		}
-
-		mspi->rx_len -= rx_nr_bytes;
-
-		if (rx_nr_bytes && mspi->rx) {
-			*(u32 *)mspi->rx = rx_data;
-			mspi->rx += 4;
-		}
-	}
+	if (mspi->rx_len)
+		fsl_espi_read_rx_fifo(mspi, events);
 
 	if (mspi->tx_len)
 		fsl_espi_fill_tx_fifo(mspi, events);

commit e508cea45bc31de87b35180a9ba5ef9572ffde3f
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Oct 27 21:27:56 2016 +0200

    spi: fsl-espi: make better use of the RX FIFO
    
    So far an interrupt is triggered whenever there's at least one byte
    in the RX FIFO. This results in a unnecessarily high number of
    interrupts.
    Change this to generate an interrupt if
    - RX FIFO is half full (except if all bytes to read fit into the
      RX FIFO anyway)
    - end of transfer has been reached
    
    This way the number of interrupts can be significantly reduced.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index a9593f9691ec..239f0362df61 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -55,9 +55,10 @@
 #define CSMODE_CG(x)		((x) << 3)
 
 #define FSL_ESPI_FIFO_SIZE	32
+#define FSL_ESPI_RXTHR		15
 
 /* Default mode/csmode for eSPI controller */
-#define SPMODE_INIT_VAL (SPMODE_TXTHR(4) | SPMODE_RXTHR(3))
+#define SPMODE_INIT_VAL (SPMODE_TXTHR(4) | SPMODE_RXTHR(FSL_ESPI_RXTHR))
 #define CSMODE_INIT_VAL (CSMODE_POL_1 | CSMODE_BEF(0) \
 		| CSMODE_AFT(0) | CSMODE_CG(1))
 
@@ -263,6 +264,7 @@ static void fsl_espi_setup_transfer(struct spi_device *spi,
 static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 {
 	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
+	u32 mask;
 	int ret;
 
 	mpc8xxx_spi->rx_len = t->len;
@@ -277,8 +279,11 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPCOM,
 		(SPCOM_CS(spi->chip_select) | SPCOM_TRANLEN(t->len - 1)));
 
-	/* enable rx ints */
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIM, SPIM_RNE);
+	/* enable interrupts */
+	mask = SPIM_DON;
+	if (mpc8xxx_spi->rx_len > FSL_ESPI_FIFO_SIZE)
+		mask |= SPIM_RXT;
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIM, mask);
 
 	/* Prevent filling the fifo from getting interrupted */
 	spin_lock_irq(&mpc8xxx_spi->lock);

commit db1b049fad8b12062edffade8272d604b4019eb7
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Oct 27 21:28:02 2016 +0200

    spi: fsl-espi: extend and improve transfer error handling
    
    Extend and improve transfer error handling
    - in case of timeout report also number of remaining rx bytes
    - in case of timeout return ETIMEDOUT instead of EMSGSIZE
    - add sanity checks after all bytes have been sent / read:
     - check that HW has flag SPIE_DON set
     - check that RX / TX FIFO are empty
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index d5506852e63c..a9593f9691ec 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -289,13 +289,13 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	ret = wait_for_completion_timeout(&mpc8xxx_spi->done, 2 * HZ);
 	if (ret == 0)
 		dev_err(mpc8xxx_spi->dev,
-			"Transaction hanging up (left %u bytes)\n",
-			mpc8xxx_spi->tx_len);
+			"Transaction hanging up (left %u tx bytes, %u rx bytes)\n",
+			mpc8xxx_spi->tx_len, mpc8xxx_spi->rx_len);
 
 	/* disable rx ints */
 	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIM, 0);
 
-	return mpc8xxx_spi->tx_len > 0 ? -EMSGSIZE : 0;
+	return ret == 0 ? -ETIMEDOUT : 0;
 }
 
 static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)
@@ -469,8 +469,20 @@ static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 	if (mspi->tx_len)
 		fsl_espi_fill_tx_fifo(mspi, events);
 
-	if (!mspi->tx_len && !mspi->rx_len)
-		complete(&mspi->done);
+	if (mspi->tx_len || mspi->rx_len)
+		return;
+
+	/* we're done, but check for errors before returning */
+	events = fsl_espi_read_reg(mspi, ESPI_SPIE);
+
+	if (!(events & SPIE_DON))
+		dev_err(mspi->dev,
+			"Transfer done but SPIE_DON isn't set!\n");
+
+	if (SPIE_RXCNT(events) || SPIE_TXCNT(events) != FSL_ESPI_FIFO_SIZE)
+		dev_err(mspi->dev, "Transfer done but rx/tx fifo's aren't empty!\n");
+
+	complete(&mspi->done);
 }
 
 static irqreturn_t fsl_espi_irq(s32 irq, void *context_data)

commit b3bec5f95f73520feb05b90244522f24546e96aa
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Oct 27 21:26:46 2016 +0200

    spi: fsl-espi: simplify and inline function fsl_espi_change_mode
    
    The ESPI spec mentions no requirement to turn off the ESPI unit prior
    to changing the mode. Most likely the ESPI unit is only turned off to
    clear the FIFO's as before this patch series single bytes could
    remain in the TX FIFO after transfer end.
    Therefore remove disabling / re-enabling the ESPI unit.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 5a7449f3b3b8..d5506852e63c 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -223,26 +223,6 @@ static void fsl_espi_fill_tx_fifo(struct mpc8xxx_spi *mspi, u32 events)
 		}
 }
 
-static void fsl_espi_change_mode(struct spi_device *spi)
-{
-	struct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);
-	struct spi_mpc8xxx_cs *cs = spi->controller_state;
-	u32 tmp;
-	unsigned long flags;
-
-	/* Turn off IRQs locally to minimize time that SPI is disabled. */
-	local_irq_save(flags);
-
-	/* Turn off SPI unit prior changing mode */
-	tmp = fsl_espi_read_reg(mspi, ESPI_SPMODE);
-	fsl_espi_write_reg(mspi, ESPI_SPMODE, tmp & ~SPMODE_ENABLE);
-	fsl_espi_write_reg(mspi, ESPI_SPMODEx(spi->chip_select),
-			      cs->hw_mode);
-	fsl_espi_write_reg(mspi, ESPI_SPMODE, tmp);
-
-	local_irq_restore(flags);
-}
-
 static void fsl_espi_setup_transfer(struct spi_device *spi,
 					struct spi_transfer *t)
 {
@@ -276,7 +256,8 @@ static void fsl_espi_setup_transfer(struct spi_device *spi,
 
 	cs->hw_mode |= CSMODE_PM(pm);
 
-	fsl_espi_change_mode(spi);
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODEx(spi->chip_select),
+			   cs->hw_mode);
 }
 
 static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)

commit f895e27f591228704954cc8927d9c61b3f3da90f
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Oct 27 21:26:08 2016 +0200

    spi: fsl-espi: Rename len in struct mpc8xxx_spi to rx_len and make it unsigned
    
    Now that we introduced element tx_len in struct mpc8xxx_spi let's
    rename element len to rx_len as it actually is the number of bytes to
    receive. In addition make it unsigned.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 95c1fbfe1cbe..5a7449f3b3b8 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -284,7 +284,7 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
 	int ret;
 
-	mpc8xxx_spi->len = t->len;
+	mpc8xxx_spi->rx_len = t->len;
 	mpc8xxx_spi->tx_len = t->len;
 
 	mpc8xxx_spi->tx = t->tx_buf;
@@ -445,28 +445,28 @@ static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 		int ret;
 
 		/* Spin until RX is done */
-		if (SPIE_RXCNT(events) < min(4, mspi->len)) {
+		if (SPIE_RXCNT(events) < min(4U, mspi->rx_len)) {
 			ret = spin_event_timeout(
 				!(SPIE_RXCNT(events =
 				fsl_espi_read_reg(mspi, ESPI_SPIE)) <
-						min(4, mspi->len)),
+						min(4U, mspi->rx_len)),
 						10000, 0); /* 10 msec */
 			if (!ret)
 				dev_err(mspi->dev,
 					 "tired waiting for SPIE_RXCNT\n");
 		}
 
-		if (mspi->len >= 4) {
+		if (mspi->rx_len >= 4) {
 			rx_data = fsl_espi_read_reg(mspi, ESPI_SPIRF);
-		} else if (mspi->len <= 0) {
+		} else if (!mspi->rx_len) {
 			dev_err(mspi->dev,
 				"unexpected RX(SPIE_RNE) interrupt occurred,\n"
 				"(local rxlen %d bytes, reg rxlen %d bytes)\n",
-				min(4, mspi->len), SPIE_RXCNT(events));
+				min(4U, mspi->rx_len), SPIE_RXCNT(events));
 			rx_nr_bytes = 0;
 		} else {
-			rx_nr_bytes = mspi->len;
-			tmp = mspi->len;
+			rx_nr_bytes = mspi->rx_len;
+			tmp = mspi->rx_len;
 			rx_data = 0;
 			while (tmp--) {
 				rx_data_8 = fsl_espi_read_reg8(mspi,
@@ -474,10 +474,10 @@ static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 				rx_data |= (rx_data_8 << (tmp * 8));
 			}
 
-			rx_data <<= (4 - mspi->len) * 8;
+			rx_data <<= (4 - mspi->rx_len) * 8;
 		}
 
-		mspi->len -= rx_nr_bytes;
+		mspi->rx_len -= rx_nr_bytes;
 
 		if (rx_nr_bytes && mspi->rx) {
 			*(u32 *)mspi->rx = rx_data;
@@ -488,7 +488,7 @@ static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 	if (mspi->tx_len)
 		fsl_espi_fill_tx_fifo(mspi, events);
 
-	if (!mspi->tx_len && !mspi->len)
+	if (!mspi->tx_len && !mspi->rx_len)
 		complete(&mspi->done);
 }
 

commit 54731265966db742dda09008bd9bbe12ae11e93e
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Oct 27 21:25:58 2016 +0200

    spi: fsl-espi: fix and improve writing to TX FIFO
    
    This change addresses two issues:
    - If the TX FIFO is full the ISR polls until there's free space again.
      An ISR should never wait for something.
    - Currently the number of bytes to transfer is rounded up to the next
      multiple of 4. For most transfers therefore few bytes remain in the
      TX FIFO after end of transfer.
      This would cause the next transfer to fail and as a workaround the
      ESPI block is disabled / re-enabled in fsl_espi_change_mode.
      This seems to clear the FIFO's (although it's not mentioned in the
      spec).
    
    With this change the TX FIFO is filled as much as possible initially
    and whenever the ISR is called. Also the exact number of bytes is
    transferred.
    The spinlock protects against a potential race if the first interrupt
    occurs whilst the TX FIFO is still being initially filled.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index f04c2464e854..95c1fbfe1cbe 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -54,6 +54,8 @@
 #define CSMODE_AFT(x)		((x) << 8)
 #define CSMODE_CG(x)		((x) << 3)
 
+#define FSL_ESPI_FIFO_SIZE	32
+
 /* Default mode/csmode for eSPI controller */
 #define SPMODE_INIT_VAL (SPMODE_TXTHR(4) | SPMODE_RXTHR(3))
 #define CSMODE_INIT_VAL (CSMODE_POL_1 | CSMODE_BEF(0) \
@@ -200,6 +202,27 @@ static int fsl_espi_check_message(struct spi_message *m)
 	return 0;
 }
 
+static void fsl_espi_fill_tx_fifo(struct mpc8xxx_spi *mspi, u32 events)
+{
+	u32 tx_fifo_avail;
+
+	/* if events is zero transfer has not started and tx fifo is empty */
+	tx_fifo_avail = events ? SPIE_TXCNT(events) :  FSL_ESPI_FIFO_SIZE;
+
+	while (tx_fifo_avail >= min(4U, mspi->tx_len) && mspi->tx_len)
+		if (mspi->tx_len >= 4) {
+			fsl_espi_write_reg(mspi, ESPI_SPITF, *(u32 *)mspi->tx);
+			mspi->tx += 4;
+			mspi->tx_len -= 4;
+			tx_fifo_avail -= 4;
+		} else {
+			fsl_espi_write_reg8(mspi, ESPI_SPITF, *(u8 *)mspi->tx);
+			mspi->tx += 1;
+			mspi->tx_len -= 1;
+			tx_fifo_avail -= 1;
+		}
+}
+
 static void fsl_espi_change_mode(struct spi_device *spi)
 {
 	struct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);
@@ -262,7 +285,7 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	int ret;
 
 	mpc8xxx_spi->len = t->len;
-	mpc8xxx_spi->count = roundup(t->len, 4) / 4;
+	mpc8xxx_spi->tx_len = t->len;
 
 	mpc8xxx_spi->tx = t->tx_buf;
 	mpc8xxx_spi->rx = t->rx_buf;
@@ -276,21 +299,22 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	/* enable rx ints */
 	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIM, SPIM_RNE);
 
-	/* transmit word */
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPITF, *(u32 *)mpc8xxx_spi->tx);
-	mpc8xxx_spi->tx += 4;
+	/* Prevent filling the fifo from getting interrupted */
+	spin_lock_irq(&mpc8xxx_spi->lock);
+	fsl_espi_fill_tx_fifo(mpc8xxx_spi, 0);
+	spin_unlock_irq(&mpc8xxx_spi->lock);
 
 	/* Won't hang up forever, SPI bus sometimes got lost interrupts... */
 	ret = wait_for_completion_timeout(&mpc8xxx_spi->done, 2 * HZ);
 	if (ret == 0)
 		dev_err(mpc8xxx_spi->dev,
-			"Transaction hanging up (left %d bytes)\n",
-			mpc8xxx_spi->count);
+			"Transaction hanging up (left %u bytes)\n",
+			mpc8xxx_spi->tx_len);
 
 	/* disable rx ints */
 	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIM, 0);
 
-	return mpc8xxx_spi->count > 0 ? -EMSGSIZE : 0;
+	return mpc8xxx_spi->tx_len > 0 ? -EMSGSIZE : 0;
 }
 
 static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)
@@ -461,26 +485,11 @@ static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 		}
 	}
 
-	if (!(events & SPIE_TNF)) {
-		int ret;
-
-		/* spin until TX is done */
-		ret = spin_event_timeout(((events = fsl_espi_read_reg(
-				mspi, ESPI_SPIE)) & SPIE_TNF), 1000, 0);
-		if (!ret) {
-			dev_err(mspi->dev, "tired waiting for SPIE_TNF\n");
-			complete(&mspi->done);
-			return;
-		}
-	}
+	if (mspi->tx_len)
+		fsl_espi_fill_tx_fifo(mspi, events);
 
-	mspi->count -= 1;
-	if (mspi->count) {
-		fsl_espi_write_reg(mspi, ESPI_SPITF, *(u32 *)mspi->tx);
-		mspi->tx += 4;
-	} else {
+	if (!mspi->tx_len && !mspi->len)
 		complete(&mspi->done);
-	}
 }
 
 static irqreturn_t fsl_espi_irq(s32 irq, void *context_data)
@@ -488,10 +497,14 @@ static irqreturn_t fsl_espi_irq(s32 irq, void *context_data)
 	struct mpc8xxx_spi *mspi = context_data;
 	u32 events;
 
+	spin_lock(&mspi->lock);
+
 	/* Get interrupt events(tx/rx) */
 	events = fsl_espi_read_reg(mspi, ESPI_SPIE);
-	if (!events)
+	if (!events) {
+		spin_unlock_irq(&mspi->lock);
 		return IRQ_NONE;
+	}
 
 	dev_vdbg(mspi->dev, "%s: events %x\n", __func__, events);
 
@@ -500,6 +513,8 @@ static irqreturn_t fsl_espi_irq(s32 irq, void *context_data)
 	/* Clear the events */
 	fsl_espi_write_reg(mspi, ESPI_SPIE, events);
 
+	spin_unlock(&mspi->lock);
+
 	return IRQ_HANDLED;
 }
 
@@ -562,6 +577,7 @@ static int fsl_espi_probe(struct device *dev, struct resource *mem,
 	master->max_message_size = fsl_espi_max_message_size;
 
 	mpc8xxx_spi = spi_master_get_devdata(master);
+	spin_lock_init(&mpc8xxx_spi->lock);
 
 	mpc8xxx_spi->local_buf =
 		devm_kmalloc(dev, SPCOM_TRANLEN_MAX, GFP_KERNEL);

commit e9e128a69af2b5fd2a4e01a59cc7e479ce9b8813
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Oct 27 21:24:01 2016 +0200

    spi: fsl-espi: improve check for SPI_QE_CPU_MODE
    
    SPI_QE_CPU_MODE doesn't exist for ESPI and is set by of_mpc8xxx_spi_probe
    based on DT property "mode". This property is not defined for ESPI,
    see Documentation/devicetree/bindings/spi/fsl-spi.txt.
    So print an error message and bail out if SPI_QE_CPU_MODE is set.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 4e8a99d0cb63..f04c2464e854 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -583,8 +583,9 @@ static int fsl_espi_probe(struct device *dev, struct resource *mem,
 		goto err_probe;
 
 	if (mpc8xxx_spi->flags & SPI_QE_CPU_MODE) {
-		mpc8xxx_spi->rx_shift = 16;
-		mpc8xxx_spi->tx_shift = 24;
+		dev_err(dev, "SPI_QE_CPU_MODE is not supported on ESPI!\n");
+		ret = -EINVAL;
+		goto err_probe;
 	}
 
 	/* SPI controller initializations */

commit e3cd6cf425bf40061418edf7b295f654301446fe
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Oct 27 20:24:19 2016 +0200

    spi: fsl-espi: fix merge conflict for commit "avoid processing uninitalized data on error"
    
    Commit 5c0ba57744b1 ("spi: fsl-espi: avoid processing uninitalized
    data on error") applied fine to stable but caused a merge conflict
    on next. This patch fixes that.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index a7e4c284d50a..4e8a99d0cb63 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -456,7 +456,7 @@ static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 		mspi->len -= rx_nr_bytes;
 
 		if (rx_nr_bytes && mspi->rx) {
-			mspi->get_rx(rx_data, mspi);
+			*(u32 *)mspi->rx = rx_data;
 			mspi->rx += 4;
 		}
 	}

commit f9ce28f92385622070f398660e7b2066f02997c8
Merge: 923ab15e1a5c 5c0ba57744b1
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Oct 26 11:30:11 2016 +0100

    Merge branch 'fix/fsl-espi' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi into spi-fsl-espi

commit 5c0ba57744b1422d528f19430dd66d6803cea86f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Oct 25 22:57:10 2016 +0200

    spi: fsl-espi: avoid processing uninitalized data on error
    
    When we get a spurious interrupt in fsl_espi_irq, we end up
    processing four uninitalized bytes of data, as shown in this
    warning message:
    
       drivers/spi/spi-fsl-espi.c: In function 'fsl_espi_irq':
       drivers/spi/spi-fsl-espi.c:462:4: warning: 'rx_data' may be used uninitialized in this function [-Wmaybe-uninitialized]
    
    This adds another check so we skip the data in this case.
    
    Fixes: 6319a68011b8 ("spi/fsl-espi: avoid infinite loops on fsl_espi_cpu_irq()")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 7451585a080e..2c175b9495f7 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -458,7 +458,7 @@ static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 
 		mspi->len -= rx_nr_bytes;
 
-		if (mspi->rx)
+		if (rx_nr_bytes && mspi->rx)
 			mspi->get_rx(rx_data, mspi);
 	}
 

commit 923ab15e1a5ce6248601304440e9f30fbf3bb6ab
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Oct 2 14:22:57 2016 +0200

    spi: fsl-espi: fix handling of word sizes other than 8 bit
    
    The code in fsl_espi_tx_buf_lsb and parts of fsl_espi_setup_transfer
    look very weird and don't reflect the ESPI spec.
    ESPI stores values with <= 8 bit word size right justified as 8 bit
    value and values with > 8 bit word size right justified as 16 bit
    value. Therefore no such shifting is needed.
    Only case MSB-first with 8 bit word size is correctly handled,
    and most likely nobody ever used this driver with a different config.
    
    On ESPI only the case LSB-first with word size > 8 bit needs a
    special handling. In this case a little endian 16 bit value has
    to be written to the TX FIFO what requires a byte swap as the
    host system is big endian.
    The same applies to reading from the RX FIFO.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 65bb70d3bfc4..eea5123abb38 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -112,6 +112,32 @@ static inline void fsl_espi_write_reg8(struct mpc8xxx_spi *mspi, int offset,
 	iowrite8(val, mspi->reg_base + offset);
 }
 
+static void fsl_espi_memcpy_swab(void *to, const void *from,
+				 struct spi_message *m,
+				 struct spi_transfer *t)
+{
+	unsigned int len = t->len;
+
+	if (!(m->spi->mode & SPI_LSB_FIRST) || t->bits_per_word <= 8) {
+		memcpy(to, from, len);
+		return;
+	}
+
+	/* In case of LSB-first and bits_per_word > 8 byte-swap all words */
+	while (len)
+		if (len >= 4) {
+			*(u32 *)to = swahb32p(from);
+			to += 4;
+			from += 4;
+			len -= 4;
+		} else {
+			*(u16 *)to = swab16p(from);
+			to += 2;
+			from += 2;
+			len -= 2;
+		}
+}
+
 static void fsl_espi_copy_to_buf(struct spi_message *m,
 				 struct mpc8xxx_spi *mspi)
 {
@@ -120,7 +146,7 @@ static void fsl_espi_copy_to_buf(struct spi_message *m,
 
 	list_for_each_entry(t, &m->transfers, transfer_list) {
 		if (t->tx_buf)
-			memcpy(buf, t->tx_buf, t->len);
+			fsl_espi_memcpy_swab(buf, t->tx_buf, m, t);
 		else
 			memset(buf, 0, t->len);
 		buf += t->len;
@@ -135,7 +161,7 @@ static void fsl_espi_copy_from_buf(struct spi_message *m,
 
 	list_for_each_entry(t, &m->transfers, transfer_list) {
 		if (t->rx_buf)
-			memcpy(t->rx_buf, buf, t->len);
+			fsl_espi_memcpy_swab(t->rx_buf, buf, m, t);
 		buf += t->len;
 	}
 }
@@ -194,27 +220,6 @@ static void fsl_espi_change_mode(struct spi_device *spi)
 	local_irq_restore(flags);
 }
 
-static u32 fsl_espi_tx_buf_lsb(struct mpc8xxx_spi *mpc8xxx_spi)
-{
-	u32 data;
-	u16 data_h;
-	u16 data_l;
-	const u32 *tx = mpc8xxx_spi->tx;
-
-	if (!tx)
-		return 0;
-
-	data = *tx++ << mpc8xxx_spi->tx_shift;
-	data_l = data & 0xffff;
-	data_h = (data >> 16) & 0xffff;
-	swab16s(&data_l);
-	swab16s(&data_h);
-	data = data_h | data_l;
-
-	mpc8xxx_spi->tx = tx;
-	return data;
-}
-
 static void fsl_espi_setup_transfer(struct spi_device *spi,
 					struct spi_transfer *t)
 {
@@ -224,23 +229,6 @@ static void fsl_espi_setup_transfer(struct spi_device *spi,
 	u8 pm;
 	struct spi_mpc8xxx_cs *cs = spi->controller_state;
 
-	cs->rx_shift = 0;
-	cs->tx_shift = 0;
-	cs->get_rx = mpc8xxx_spi_rx_buf_u32;
-	cs->get_tx = mpc8xxx_spi_tx_buf_u32;
-	if (bits_per_word <= 8) {
-		cs->rx_shift = 8 - bits_per_word;
-	} else {
-		cs->rx_shift = 16 - bits_per_word;
-		if (spi->mode & SPI_LSB_FIRST)
-			cs->get_tx = fsl_espi_tx_buf_lsb;
-	}
-
-	mpc8xxx_spi->rx_shift = cs->rx_shift;
-	mpc8xxx_spi->tx_shift = cs->tx_shift;
-	mpc8xxx_spi->get_rx = cs->get_rx;
-	mpc8xxx_spi->get_tx = cs->get_tx;
-
 	/* mask out bits we are going to set */
 	cs->hw_mode &= ~(CSMODE_LEN(0xF) | CSMODE_DIV16 | CSMODE_PM(0xF));
 
@@ -271,7 +259,6 @@ static void fsl_espi_setup_transfer(struct spi_device *spi,
 static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 {
 	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
-	u32 word;
 	int ret;
 
 	mpc8xxx_spi->len = t->len;
@@ -290,8 +277,8 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIM, SPIM_RNE);
 
 	/* transmit word */
-	word = mpc8xxx_spi->get_tx(mpc8xxx_spi);
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPITF, word);
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPITF, *(u32 *)mpc8xxx_spi->tx);
+	mpc8xxx_spi->tx += 4;
 
 	/* Won't hang up forever, SPI bus sometimes got lost interrupts... */
 	ret = wait_for_completion_timeout(&mpc8xxx_spi->done, 2 * HZ);
@@ -468,8 +455,10 @@ static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 
 		mspi->len -= rx_nr_bytes;
 
-		if (mspi->rx)
-			mspi->get_rx(rx_data, mspi);
+		if (mspi->rx) {
+			*(u32 *)mspi->rx = rx_data;
+			mspi->rx += 4;
+		}
 	}
 
 	if (!(events & SPIE_TNF)) {
@@ -487,9 +476,8 @@ static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 
 	mspi->count -= 1;
 	if (mspi->count) {
-		u32 word = mspi->get_tx(mspi);
-
-		fsl_espi_write_reg(mspi, ESPI_SPITF, word);
+		fsl_espi_write_reg(mspi, ESPI_SPITF, *(u32 *)mspi->tx);
+		mspi->tx += 4;
 	} else {
 		complete(&mspi->done);
 	}

commit e4be7053b9d3aa0a97b311ad77528d8b32236590
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Oct 2 14:22:35 2016 +0200

    spi: fsl-espi: reject MSB-first transfers with word sizes other than 8 or 16
    
    According to the ESPI spec MSB-first transfers are supported for
    word size 8 and 16 only.
    
    Check for this and reject MSB-first transfers with other word sizes.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 1f97cce615d3..65bb70d3bfc4 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -153,6 +153,7 @@ static int fsl_espi_check_message(struct spi_message *m)
 
 	first = list_first_entry(&m->transfers, struct spi_transfer,
 				 transfer_list);
+
 	list_for_each_entry(t, &m->transfers, transfer_list) {
 		if (first->bits_per_word != t->bits_per_word ||
 		    first->speed_hz != t->speed_hz) {
@@ -161,6 +162,15 @@ static int fsl_espi_check_message(struct spi_message *m)
 		}
 	}
 
+	/* ESPI supports MSB-first transfers for word size 8 / 16 only */
+	if (!(m->spi->mode & SPI_LSB_FIRST) && first->bits_per_word != 8 &&
+	    first->bits_per_word != 16) {
+		dev_err(mspi->dev,
+			"MSB-first transfer not supported for wordsize %u\n",
+			first->bits_per_word);
+		return -EINVAL;
+	}
+
 	return 0;
 }
 

commit b497eb024531b712f9d2c6af0bb55ca558a2674e
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sat Oct 1 21:07:52 2016 +0200

    spi: fsl-espi: replace of_get_property with of_property_read_u32
    
    of_property_read_u32 is better here than generic of_get_property:
    - implicit endianness conversion if needed
    - implicit checking of size of property
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 7451585a080e..1f97cce615d3 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -545,9 +545,8 @@ static int fsl_espi_probe(struct device *dev, struct resource *mem,
 	struct spi_master *master;
 	struct mpc8xxx_spi *mpc8xxx_spi;
 	struct device_node *nc;
-	const __be32 *prop;
-	u32 regval, csmode;
-	int i, len, ret;
+	u32 regval, csmode, cs, prop;
+	int ret;
 
 	master = spi_alloc_master(dev, sizeof(struct mpc8xxx_spi));
 	if (!master)
@@ -599,29 +598,29 @@ static int fsl_espi_probe(struct device *dev, struct resource *mem,
 	/* Init eSPI CS mode register */
 	for_each_available_child_of_node(master->dev.of_node, nc) {
 		/* get chip select */
-		prop = of_get_property(nc, "reg", &len);
-		if (!prop || len < sizeof(*prop))
-			continue;
-		i = be32_to_cpup(prop);
-		if (i < 0 || i >= pdata->max_chipselect)
+		ret = of_property_read_u32(nc, "reg", &cs);
+		if (ret || cs >= pdata->max_chipselect)
 			continue;
 
 		csmode = CSMODE_INIT_VAL;
+
 		/* check if CSBEF is set in device tree */
-		prop = of_get_property(nc, "fsl,csbef", &len);
-		if (prop && len >= sizeof(*prop)) {
+		ret = of_property_read_u32(nc, "fsl,csbef", &prop);
+		if (!ret) {
 			csmode &= ~(CSMODE_BEF(0xf));
-			csmode |= CSMODE_BEF(be32_to_cpup(prop));
+			csmode |= CSMODE_BEF(prop);
 		}
+
 		/* check if CSAFT is set in device tree */
-		prop = of_get_property(nc, "fsl,csaft", &len);
-		if (prop && len >= sizeof(*prop)) {
+		ret = of_property_read_u32(nc, "fsl,csaft", &prop);
+		if (!ret) {
 			csmode &= ~(CSMODE_AFT(0xf));
-			csmode |= CSMODE_AFT(be32_to_cpup(prop));
+			csmode |= CSMODE_AFT(prop);
 		}
-		fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODEx(i), csmode);
 
-		dev_info(dev, "cs=%d, init_csmode=0x%x\n", i, csmode);
+		fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODEx(cs), csmode);
+
+		dev_info(dev, "cs=%u, init_csmode=0x%x\n", cs, csmode);
 	}
 
 	/* Enable SPI interface */
@@ -660,16 +659,16 @@ static int of_fsl_espi_get_chipselects(struct device *dev)
 {
 	struct device_node *np = dev->of_node;
 	struct fsl_spi_platform_data *pdata = dev_get_platdata(dev);
-	const u32 *prop;
-	int len;
+	u32 num_cs;
+	int ret;
 
-	prop = of_get_property(np, "fsl,espi-num-chipselects", &len);
-	if (!prop || len < sizeof(*prop)) {
+	ret = of_property_read_u32(np, "fsl,espi-num-chipselects", &num_cs);
+	if (ret) {
 		dev_err(dev, "No 'fsl,espi-num-chipselects' property\n");
 		return -EINVAL;
 	}
 
-	pdata->max_chipselect = *prop;
+	pdata->max_chipselect = num_cs;
 	pdata->cs_control = NULL;
 
 	return 0;

commit 604042af7697314fffb16e266fd7d5ad488439cc
Author: Heiner Kallweit <heiner.kallweit@web.de>
Date:   Sat Sep 17 15:43:31 2016 +0200

    spi: fsl-espi: improve return value handling in fsl_espi_probe
    
    The return value of fsl_espi_probe (currently struct spi_master *)
    is just used for checking whether an error occurred.
    Change the return value type to int and simplify the code.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index dee3f822cea8..7451585a080e 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -538,8 +538,8 @@ static size_t fsl_espi_max_message_size(struct spi_device *spi)
 	return SPCOM_TRANLEN_MAX;
 }
 
-static struct spi_master * fsl_espi_probe(struct device *dev,
-		struct resource *mem, unsigned int irq)
+static int fsl_espi_probe(struct device *dev, struct resource *mem,
+			  unsigned int irq)
 {
 	struct fsl_spi_platform_data *pdata = dev_get_platdata(dev);
 	struct spi_master *master;
@@ -547,13 +547,11 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 	struct device_node *nc;
 	const __be32 *prop;
 	u32 regval, csmode;
-	int i, len, ret = 0;
+	int i, len, ret;
 
 	master = spi_alloc_master(dev, sizeof(struct mpc8xxx_spi));
-	if (!master) {
-		ret = -ENOMEM;
-		goto err;
-	}
+	if (!master)
+		return -ENOMEM;
 
 	dev_set_drvdata(dev, master);
 
@@ -647,7 +645,7 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 	pm_runtime_mark_last_busy(dev);
 	pm_runtime_put_autosuspend(dev);
 
-	return master;
+	return 0;
 
 err_pm:
 	pm_runtime_put_noidle(dev);
@@ -655,8 +653,7 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 	pm_runtime_set_suspended(dev);
 err_probe:
 	spi_master_put(master);
-err:
-	return ERR_PTR(ret);
+	return ret;
 }
 
 static int of_fsl_espi_get_chipselects(struct device *dev)
@@ -682,7 +679,6 @@ static int of_fsl_espi_probe(struct platform_device *ofdev)
 {
 	struct device *dev = &ofdev->dev;
 	struct device_node *np = ofdev->dev.of_node;
-	struct spi_master *master;
 	struct resource mem;
 	unsigned int irq;
 	int ret;
@@ -703,11 +699,7 @@ static int of_fsl_espi_probe(struct platform_device *ofdev)
 	if (!irq)
 		return -EINVAL;
 
-	master = fsl_espi_probe(dev, &mem, irq);
-	if (IS_ERR(master))
-		return PTR_ERR(master);
-
-	return 0;
+	return fsl_espi_probe(dev, &mem, irq);
 }
 
 static int of_fsl_espi_remove(struct platform_device *dev)

commit acf692190f972ee2ed6578f30278f21c244d6148
Author: Heiner Kallweit <heiner.kallweit@web.de>
Date:   Sat Sep 17 15:43:00 2016 +0200

    spi: fsl-espi: simplify of_fsl_espi_probe
    
    Simplify of_fsl_espi_probe.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 4f9d9ec6880a..dee3f822cea8 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -685,7 +685,7 @@ static int of_fsl_espi_probe(struct platform_device *ofdev)
 	struct spi_master *master;
 	struct resource mem;
 	unsigned int irq;
-	int ret = -ENOMEM;
+	int ret;
 
 	ret = of_mpc8xxx_spi_probe(ofdev);
 	if (ret)
@@ -693,28 +693,21 @@ static int of_fsl_espi_probe(struct platform_device *ofdev)
 
 	ret = of_fsl_espi_get_chipselects(dev);
 	if (ret)
-		goto err;
+		return ret;
 
 	ret = of_address_to_resource(np, 0, &mem);
 	if (ret)
-		goto err;
+		return ret;
 
 	irq = irq_of_parse_and_map(np, 0);
-	if (!irq) {
-		ret = -EINVAL;
-		goto err;
-	}
+	if (!irq)
+		return -EINVAL;
 
 	master = fsl_espi_probe(dev, &mem, irq);
-	if (IS_ERR(master)) {
-		ret = PTR_ERR(master);
-		goto err;
-	}
+	if (IS_ERR(master))
+		return PTR_ERR(master);
 
 	return 0;
-
-err:
-	return ret;
 }
 
 static int of_fsl_espi_remove(struct platform_device *dev)

commit fb8ac912df93ea4edc549992d7c9d173e5413164
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sat Sep 17 15:42:42 2016 +0200

    spi: fsl-espi: remove unused variable in fsl_espi_setup
    
    Remove an unused variable.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index a7984aeede6b..4f9d9ec6880a 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -361,7 +361,6 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 static int fsl_espi_setup(struct spi_device *spi)
 {
 	struct mpc8xxx_spi *mpc8xxx_spi;
-	u32 hw_mode;
 	u32 loop_mode;
 	struct spi_mpc8xxx_cs *cs = spi_get_ctldata(spi);
 
@@ -379,7 +378,6 @@ static int fsl_espi_setup(struct spi_device *spi)
 
 	pm_runtime_get_sync(mpc8xxx_spi->dev);
 
-	hw_mode = cs->hw_mode; /* Save original settings */
 	cs->hw_mode = fsl_espi_read_reg(mpc8xxx_spi,
 					   ESPI_SPMODEx(spi->chip_select));
 	/* mask out bits we are going to set */

commit 81abc2ecac838da89076fe9e0e5892ed83bf1ab2
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Tue Sep 13 23:16:06 2016 +0200

    spi: fsl-espi: improve and extend register bit definitions
    
    Add definition of further register bits for use in upcoming
    driver extensions and improve current bit definitions:
    - use BIT macro
    - use bit names as in the chip spec
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 328b04a36328..a7984aeede6b 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -37,18 +37,18 @@
 #define ESPI_SPMODEx(x)	(ESPI_SPMODE0 + (x) * 4)
 
 /* eSPI Controller mode register definitions */
-#define SPMODE_ENABLE		(1 << 31)
-#define SPMODE_LOOP		(1 << 30)
+#define SPMODE_ENABLE		BIT(31)
+#define SPMODE_LOOP		BIT(30)
 #define SPMODE_TXTHR(x)		((x) << 8)
 #define SPMODE_RXTHR(x)		((x) << 0)
 
 /* eSPI Controller CS mode register definitions */
-#define CSMODE_CI_INACTIVEHIGH	(1 << 31)
-#define CSMODE_CP_BEGIN_EDGECLK	(1 << 30)
-#define CSMODE_REV		(1 << 29)
-#define CSMODE_DIV16		(1 << 28)
+#define CSMODE_CI_INACTIVEHIGH	BIT(31)
+#define CSMODE_CP_BEGIN_EDGECLK	BIT(30)
+#define CSMODE_REV		BIT(29)
+#define CSMODE_DIV16		BIT(28)
 #define CSMODE_PM(x)		((x) << 24)
-#define CSMODE_POL_1		(1 << 20)
+#define CSMODE_POL_1		BIT(20)
 #define CSMODE_LEN(x)		((x) << 16)
 #define CSMODE_BEF(x)		((x) << 12)
 #define CSMODE_AFT(x)		((x) << 8)
@@ -60,18 +60,32 @@
 		| CSMODE_AFT(0) | CSMODE_CG(1))
 
 /* SPIE register values */
-#define	SPIE_NE		0x00000200	/* Not empty */
-#define	SPIE_NF		0x00000100	/* Not full */
-
-/* SPIM register values */
-#define	SPIM_NE		0x00000200	/* Not empty */
-#define	SPIM_NF		0x00000100	/* Not full */
 #define SPIE_RXCNT(reg)     ((reg >> 24) & 0x3F)
 #define SPIE_TXCNT(reg)     ((reg >> 16) & 0x3F)
+#define	SPIE_TXE		BIT(15)	/* TX FIFO empty */
+#define	SPIE_DON		BIT(14)	/* TX done */
+#define	SPIE_RXT		BIT(13)	/* RX FIFO threshold */
+#define	SPIE_RXF		BIT(12)	/* RX FIFO full */
+#define	SPIE_TXT		BIT(11)	/* TX FIFO threshold*/
+#define	SPIE_RNE		BIT(9)	/* RX FIFO not empty */
+#define	SPIE_TNF		BIT(8)	/* TX FIFO not full */
+
+/* SPIM register values */
+#define	SPIM_TXE		BIT(15)	/* TX FIFO empty */
+#define	SPIM_DON		BIT(14)	/* TX done */
+#define	SPIM_RXT		BIT(13)	/* RX FIFO threshold */
+#define	SPIM_RXF		BIT(12)	/* RX FIFO full */
+#define	SPIM_TXT		BIT(11)	/* TX FIFO threshold*/
+#define	SPIM_RNE		BIT(9)	/* RX FIFO not empty */
+#define	SPIM_TNF		BIT(8)	/* TX FIFO not full */
 
 /* SPCOM register values */
 #define SPCOM_CS(x)		((x) << 30)
+#define SPCOM_DO		BIT(28) /* Dual output */
+#define SPCOM_TO		BIT(27) /* TX only */
+#define SPCOM_RXSKIP(x)		((x) << 16)
 #define SPCOM_TRANLEN(x)	((x) << 0)
+
 #define	SPCOM_TRANLEN_MAX	0x10000	/* Max transaction length */
 
 #define AUTOSUSPEND_TIMEOUT 2000
@@ -263,7 +277,7 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 		(SPCOM_CS(spi->chip_select) | SPCOM_TRANLEN(t->len - 1)));
 
 	/* enable rx ints */
-	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIM, SPIM_NE);
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIM, SPIM_RNE);
 
 	/* transmit word */
 	word = mpc8xxx_spi->get_tx(mpc8xxx_spi);
@@ -405,7 +419,7 @@ static void fsl_espi_cleanup(struct spi_device *spi)
 static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 {
 	/* We need handle RX first */
-	if (events & SPIE_NE) {
+	if (events & SPIE_RNE) {
 		u32 rx_data, tmp;
 		u8 rx_data_8;
 		int rx_nr_bytes = 4;
@@ -427,7 +441,7 @@ static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 			rx_data = fsl_espi_read_reg(mspi, ESPI_SPIRF);
 		} else if (mspi->len <= 0) {
 			dev_err(mspi->dev,
-				"unexpected RX(SPIE_NE) interrupt occurred,\n"
+				"unexpected RX(SPIE_RNE) interrupt occurred,\n"
 				"(local rxlen %d bytes, reg rxlen %d bytes)\n",
 				min(4, mspi->len), SPIE_RXCNT(events));
 			rx_nr_bytes = 0;
@@ -450,14 +464,14 @@ static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 			mspi->get_rx(rx_data, mspi);
 	}
 
-	if (!(events & SPIE_NF)) {
+	if (!(events & SPIE_TNF)) {
 		int ret;
 
 		/* spin until TX is done */
 		ret = spin_event_timeout(((events = fsl_espi_read_reg(
-				mspi, ESPI_SPIE)) & SPIE_NF), 1000, 0);
+				mspi, ESPI_SPIE)) & SPIE_TNF), 1000, 0);
 		if (!ret) {
-			dev_err(mspi->dev, "tired waiting for SPIE_NF\n");
+			dev_err(mspi->dev, "tired waiting for SPIE_TNF\n");
 			complete(&mspi->done);
 			return;
 		}

commit 46afd38b7de347fd329767957886901ee9912d7a
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Tue Sep 13 23:16:02 2016 +0200

    spi: fsl-espi: align register access with other drivers
    
    Change register access to the method used in other drivers too.
    - use register names as in the chip spec for constants
    - avoid hard to read statements like
      __be32 __iomem *espi_mode = &reg_base->mode
    - get rid of old powerpc-specific functions like in_8
    
    In addition annotate reg_base in struct mpc8xxx_spi as __iomem.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 032bf3af8388..328b04a36328 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -26,16 +26,15 @@
 #include "spi-fsl-lib.h"
 
 /* eSPI Controller registers */
-struct fsl_espi_reg {
-	__be32 mode;		/* 0x000 - eSPI mode register */
-	__be32 event;		/* 0x004 - eSPI event register */
-	__be32 mask;		/* 0x008 - eSPI mask register */
-	__be32 command;		/* 0x00c - eSPI command register */
-	__be32 transmit;	/* 0x010 - eSPI transmit FIFO access register*/
-	__be32 receive;		/* 0x014 - eSPI receive FIFO access register*/
-	u8 res[8];		/* 0x018 - 0x01c reserved */
-	__be32 csmode[4];	/* 0x020 - 0x02c eSPI cs mode register */
-};
+#define ESPI_SPMODE	0x00	/* eSPI mode register */
+#define ESPI_SPIE	0x04	/* eSPI event register */
+#define ESPI_SPIM	0x08	/* eSPI mask register */
+#define ESPI_SPCOM	0x0c	/* eSPI command register */
+#define ESPI_SPITF	0x10	/* eSPI transmit FIFO access register*/
+#define ESPI_SPIRF	0x14	/* eSPI receive FIFO access register*/
+#define ESPI_SPMODE0	0x20	/* eSPI cs0 mode register */
+
+#define ESPI_SPMODEx(x)	(ESPI_SPMODE0 + (x) * 4)
 
 /* eSPI Controller mode register definitions */
 #define SPMODE_ENABLE		(1 << 31)
@@ -77,6 +76,28 @@ struct fsl_espi_reg {
 
 #define AUTOSUSPEND_TIMEOUT 2000
 
+static inline u32 fsl_espi_read_reg(struct mpc8xxx_spi *mspi, int offset)
+{
+	return ioread32be(mspi->reg_base + offset);
+}
+
+static inline u8 fsl_espi_read_reg8(struct mpc8xxx_spi *mspi, int offset)
+{
+	return ioread8(mspi->reg_base + offset);
+}
+
+static inline void fsl_espi_write_reg(struct mpc8xxx_spi *mspi, int offset,
+				      u32 val)
+{
+	iowrite32be(val, mspi->reg_base + offset);
+}
+
+static inline void fsl_espi_write_reg8(struct mpc8xxx_spi *mspi, int offset,
+				       u8 val)
+{
+	iowrite8(val, mspi->reg_base + offset);
+}
+
 static void fsl_espi_copy_to_buf(struct spi_message *m,
 				 struct mpc8xxx_spi *mspi)
 {
@@ -133,9 +154,6 @@ static void fsl_espi_change_mode(struct spi_device *spi)
 {
 	struct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);
 	struct spi_mpc8xxx_cs *cs = spi->controller_state;
-	struct fsl_espi_reg *reg_base = mspi->reg_base;
-	__be32 __iomem *mode = &reg_base->csmode[spi->chip_select];
-	__be32 __iomem *espi_mode = &reg_base->mode;
 	u32 tmp;
 	unsigned long flags;
 
@@ -143,10 +161,11 @@ static void fsl_espi_change_mode(struct spi_device *spi)
 	local_irq_save(flags);
 
 	/* Turn off SPI unit prior changing mode */
-	tmp = mpc8xxx_spi_read_reg(espi_mode);
-	mpc8xxx_spi_write_reg(espi_mode, tmp & ~SPMODE_ENABLE);
-	mpc8xxx_spi_write_reg(mode, cs->hw_mode);
-	mpc8xxx_spi_write_reg(espi_mode, tmp);
+	tmp = fsl_espi_read_reg(mspi, ESPI_SPMODE);
+	fsl_espi_write_reg(mspi, ESPI_SPMODE, tmp & ~SPMODE_ENABLE);
+	fsl_espi_write_reg(mspi, ESPI_SPMODEx(spi->chip_select),
+			      cs->hw_mode);
+	fsl_espi_write_reg(mspi, ESPI_SPMODE, tmp);
 
 	local_irq_restore(flags);
 }
@@ -228,7 +247,6 @@ static void fsl_espi_setup_transfer(struct spi_device *spi,
 static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 {
 	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
-	struct fsl_espi_reg *reg_base = mpc8xxx_spi->reg_base;
 	u32 word;
 	int ret;
 
@@ -241,15 +259,15 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	reinit_completion(&mpc8xxx_spi->done);
 
 	/* Set SPCOM[CS] and SPCOM[TRANLEN] field */
-	mpc8xxx_spi_write_reg(&reg_base->command,
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPCOM,
 		(SPCOM_CS(spi->chip_select) | SPCOM_TRANLEN(t->len - 1)));
 
 	/* enable rx ints */
-	mpc8xxx_spi_write_reg(&reg_base->mask, SPIM_NE);
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIM, SPIM_NE);
 
 	/* transmit word */
 	word = mpc8xxx_spi->get_tx(mpc8xxx_spi);
-	mpc8xxx_spi_write_reg(&reg_base->transmit, word);
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPITF, word);
 
 	/* Won't hang up forever, SPI bus sometimes got lost interrupts... */
 	ret = wait_for_completion_timeout(&mpc8xxx_spi->done, 2 * HZ);
@@ -259,7 +277,7 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 			mpc8xxx_spi->count);
 
 	/* disable rx ints */
-	mpc8xxx_spi_write_reg(&reg_base->mask, 0);
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIM, 0);
 
 	return mpc8xxx_spi->count > 0 ? -EMSGSIZE : 0;
 }
@@ -329,7 +347,6 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 static int fsl_espi_setup(struct spi_device *spi)
 {
 	struct mpc8xxx_spi *mpc8xxx_spi;
-	struct fsl_espi_reg *reg_base;
 	u32 hw_mode;
 	u32 loop_mode;
 	struct spi_mpc8xxx_cs *cs = spi_get_ctldata(spi);
@@ -345,13 +362,12 @@ static int fsl_espi_setup(struct spi_device *spi)
 	}
 
 	mpc8xxx_spi = spi_master_get_devdata(spi->master);
-	reg_base = mpc8xxx_spi->reg_base;
 
 	pm_runtime_get_sync(mpc8xxx_spi->dev);
 
 	hw_mode = cs->hw_mode; /* Save original settings */
-	cs->hw_mode = mpc8xxx_spi_read_reg(
-			&reg_base->csmode[spi->chip_select]);
+	cs->hw_mode = fsl_espi_read_reg(mpc8xxx_spi,
+					   ESPI_SPMODEx(spi->chip_select));
 	/* mask out bits we are going to set */
 	cs->hw_mode &= ~(CSMODE_CP_BEGIN_EDGECLK | CSMODE_CI_INACTIVEHIGH
 			 | CSMODE_REV);
@@ -364,11 +380,11 @@ static int fsl_espi_setup(struct spi_device *spi)
 		cs->hw_mode |= CSMODE_REV;
 
 	/* Handle the loop mode */
-	loop_mode = mpc8xxx_spi_read_reg(&reg_base->mode);
+	loop_mode = fsl_espi_read_reg(mpc8xxx_spi, ESPI_SPMODE);
 	loop_mode &= ~SPMODE_LOOP;
 	if (spi->mode & SPI_LOOP)
 		loop_mode |= SPMODE_LOOP;
-	mpc8xxx_spi_write_reg(&reg_base->mode, loop_mode);
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODE, loop_mode);
 
 	fsl_espi_setup_transfer(spi, NULL);
 
@@ -388,8 +404,6 @@ static void fsl_espi_cleanup(struct spi_device *spi)
 
 static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 {
-	struct fsl_espi_reg *reg_base = mspi->reg_base;
-
 	/* We need handle RX first */
 	if (events & SPIE_NE) {
 		u32 rx_data, tmp;
@@ -401,7 +415,7 @@ static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 		if (SPIE_RXCNT(events) < min(4, mspi->len)) {
 			ret = spin_event_timeout(
 				!(SPIE_RXCNT(events =
-				mpc8xxx_spi_read_reg(&reg_base->event)) <
+				fsl_espi_read_reg(mspi, ESPI_SPIE)) <
 						min(4, mspi->len)),
 						10000, 0); /* 10 msec */
 			if (!ret)
@@ -410,7 +424,7 @@ static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 		}
 
 		if (mspi->len >= 4) {
-			rx_data = mpc8xxx_spi_read_reg(&reg_base->receive);
+			rx_data = fsl_espi_read_reg(mspi, ESPI_SPIRF);
 		} else if (mspi->len <= 0) {
 			dev_err(mspi->dev,
 				"unexpected RX(SPIE_NE) interrupt occurred,\n"
@@ -422,7 +436,8 @@ static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 			tmp = mspi->len;
 			rx_data = 0;
 			while (tmp--) {
-				rx_data_8 = in_8((u8 *)&reg_base->receive);
+				rx_data_8 = fsl_espi_read_reg8(mspi,
+							       ESPI_SPIRF);
 				rx_data |= (rx_data_8 << (tmp * 8));
 			}
 
@@ -439,8 +454,8 @@ static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 		int ret;
 
 		/* spin until TX is done */
-		ret = spin_event_timeout(((events = mpc8xxx_spi_read_reg(
-				&reg_base->event)) & SPIE_NF), 1000, 0);
+		ret = spin_event_timeout(((events = fsl_espi_read_reg(
+				mspi, ESPI_SPIE)) & SPIE_NF), 1000, 0);
 		if (!ret) {
 			dev_err(mspi->dev, "tired waiting for SPIE_NF\n");
 			complete(&mspi->done);
@@ -452,7 +467,7 @@ static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 	if (mspi->count) {
 		u32 word = mspi->get_tx(mspi);
 
-		mpc8xxx_spi_write_reg(&reg_base->transmit, word);
+		fsl_espi_write_reg(mspi, ESPI_SPITF, word);
 	} else {
 		complete(&mspi->done);
 	}
@@ -461,11 +476,10 @@ static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 static irqreturn_t fsl_espi_irq(s32 irq, void *context_data)
 {
 	struct mpc8xxx_spi *mspi = context_data;
-	struct fsl_espi_reg *reg_base = mspi->reg_base;
 	u32 events;
 
 	/* Get interrupt events(tx/rx) */
-	events = mpc8xxx_spi_read_reg(&reg_base->event);
+	events = fsl_espi_read_reg(mspi, ESPI_SPIE);
 	if (!events)
 		return IRQ_NONE;
 
@@ -474,7 +488,7 @@ static irqreturn_t fsl_espi_irq(s32 irq, void *context_data)
 	fsl_espi_cpu_irq(mspi, events);
 
 	/* Clear the events */
-	mpc8xxx_spi_write_reg(&reg_base->event, events);
+	fsl_espi_write_reg(mspi, ESPI_SPIE, events);
 
 	return IRQ_HANDLED;
 }
@@ -484,12 +498,11 @@ static int fsl_espi_runtime_suspend(struct device *dev)
 {
 	struct spi_master *master = dev_get_drvdata(dev);
 	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(master);
-	struct fsl_espi_reg *reg_base = mpc8xxx_spi->reg_base;
 	u32 regval;
 
-	regval = mpc8xxx_spi_read_reg(&reg_base->mode);
+	regval = fsl_espi_read_reg(mpc8xxx_spi, ESPI_SPMODE);
 	regval &= ~SPMODE_ENABLE;
-	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODE, regval);
 
 	return 0;
 }
@@ -498,12 +511,11 @@ static int fsl_espi_runtime_resume(struct device *dev)
 {
 	struct spi_master *master = dev_get_drvdata(dev);
 	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(master);
-	struct fsl_espi_reg *reg_base = mpc8xxx_spi->reg_base;
 	u32 regval;
 
-	regval = mpc8xxx_spi_read_reg(&reg_base->mode);
+	regval = fsl_espi_read_reg(mpc8xxx_spi, ESPI_SPMODE);
 	regval |= SPMODE_ENABLE;
-	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODE, regval);
 
 	return 0;
 }
@@ -520,7 +532,6 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 	struct fsl_spi_platform_data *pdata = dev_get_platdata(dev);
 	struct spi_master *master;
 	struct mpc8xxx_spi *mpc8xxx_spi;
-	struct fsl_espi_reg *reg_base;
 	struct device_node *nc;
 	const __be32 *prop;
 	u32 regval, csmode;
@@ -558,8 +569,6 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 		goto err_probe;
 	}
 
-	reg_base = mpc8xxx_spi->reg_base;
-
 	/* Register for SPI Interrupt */
 	ret = devm_request_irq(dev, mpc8xxx_spi->irq, fsl_espi_irq,
 			  0, "fsl_espi", mpc8xxx_spi);
@@ -572,10 +581,10 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 	}
 
 	/* SPI controller initializations */
-	mpc8xxx_spi_write_reg(&reg_base->mode, 0);
-	mpc8xxx_spi_write_reg(&reg_base->mask, 0);
-	mpc8xxx_spi_write_reg(&reg_base->command, 0);
-	mpc8xxx_spi_write_reg(&reg_base->event, 0xffffffff);
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODE, 0);
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIM, 0);
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPCOM, 0);
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIE, 0xffffffff);
 
 	/* Init eSPI CS mode register */
 	for_each_available_child_of_node(master->dev.of_node, nc) {
@@ -600,7 +609,7 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 			csmode &= ~(CSMODE_AFT(0xf));
 			csmode |= CSMODE_AFT(be32_to_cpup(prop));
 		}
-		mpc8xxx_spi_write_reg(&reg_base->csmode[i], csmode);
+		fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODEx(i), csmode);
 
 		dev_info(dev, "cs=%d, init_csmode=0x%x\n", i, csmode);
 	}
@@ -608,7 +617,7 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 	/* Enable SPI interface */
 	regval = pdata->initial_spmode | SPMODE_INIT_VAL | SPMODE_ENABLE;
 
-	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODE, regval);
 
 	pm_runtime_set_autosuspend_delay(dev, AUTOSUSPEND_TIMEOUT);
 	pm_runtime_use_autosuspend(dev);
@@ -620,7 +629,8 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 	if (ret < 0)
 		goto err_pm;
 
-	dev_info(dev, "at 0x%p (irq = %d)\n", reg_base, mpc8xxx_spi->irq);
+	dev_info(dev, "at 0x%p (irq = %d)\n", mpc8xxx_spi->reg_base,
+		 mpc8xxx_spi->irq);
 
 	pm_runtime_mark_last_busy(dev);
 	pm_runtime_put_autosuspend(dev);
@@ -726,27 +736,26 @@ static int of_fsl_espi_resume(struct device *dev)
 	struct fsl_spi_platform_data *pdata = dev_get_platdata(dev);
 	struct spi_master *master = dev_get_drvdata(dev);
 	struct mpc8xxx_spi *mpc8xxx_spi;
-	struct fsl_espi_reg *reg_base;
 	u32 regval;
 	int i, ret;
 
 	mpc8xxx_spi = spi_master_get_devdata(master);
-	reg_base = mpc8xxx_spi->reg_base;
 
 	/* SPI controller initializations */
-	mpc8xxx_spi_write_reg(&reg_base->mode, 0);
-	mpc8xxx_spi_write_reg(&reg_base->mask, 0);
-	mpc8xxx_spi_write_reg(&reg_base->command, 0);
-	mpc8xxx_spi_write_reg(&reg_base->event, 0xffffffff);
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODE, 0);
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIM, 0);
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPCOM, 0);
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPIE, 0xffffffff);
 
 	/* Init eSPI CS mode register */
 	for (i = 0; i < pdata->max_chipselect; i++)
-		mpc8xxx_spi_write_reg(&reg_base->csmode[i], CSMODE_INIT_VAL);
+		fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODEx(i),
+				      CSMODE_INIT_VAL);
 
 	/* Enable SPI interface */
 	regval = pdata->initial_spmode | SPMODE_INIT_VAL | SPMODE_ENABLE;
 
-	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
+	fsl_espi_write_reg(mpc8xxx_spi, ESPI_SPMODE, regval);
 
 	ret = pm_runtime_force_resume(dev);
 	if (ret < 0)

commit 35f5d71e38f2c0a9e7fdfbe0e9527efc712cfbcf
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Tue Sep 13 23:15:57 2016 +0200

    spi: fsl-espi: improve and simplify interrupt handler
    
    Simplify the interrupt handler a little. In addition don't call
    fsl_espi_cpu_irq() if no event bit is set.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 060624f45ce0..032bf3af8388 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -443,17 +443,11 @@ static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 				&reg_base->event)) & SPIE_NF), 1000, 0);
 		if (!ret) {
 			dev_err(mspi->dev, "tired waiting for SPIE_NF\n");
-
-			/* Clear the SPIE bits */
-			mpc8xxx_spi_write_reg(&reg_base->event, events);
 			complete(&mspi->done);
 			return;
 		}
 	}
 
-	/* Clear the events */
-	mpc8xxx_spi_write_reg(&reg_base->event, events);
-
 	mspi->count -= 1;
 	if (mspi->count) {
 		u32 word = mspi->get_tx(mspi);
@@ -468,19 +462,21 @@ static irqreturn_t fsl_espi_irq(s32 irq, void *context_data)
 {
 	struct mpc8xxx_spi *mspi = context_data;
 	struct fsl_espi_reg *reg_base = mspi->reg_base;
-	irqreturn_t ret = IRQ_NONE;
 	u32 events;
 
 	/* Get interrupt events(tx/rx) */
 	events = mpc8xxx_spi_read_reg(&reg_base->event);
-	if (events)
-		ret = IRQ_HANDLED;
+	if (!events)
+		return IRQ_NONE;
 
 	dev_vdbg(mspi->dev, "%s: events %x\n", __func__, events);
 
 	fsl_espi_cpu_irq(mspi, events);
 
-	return ret;
+	/* Clear the events */
+	mpc8xxx_spi_write_reg(&reg_base->event, events);
+
+	return IRQ_HANDLED;
 }
 
 #ifdef CONFIG_PM

commit d198ebfb75adec5156b07b96dc21b6b9e5144018
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Tue Sep 13 23:15:45 2016 +0200

    spi: fsl-espi: simplify fsl_espi_setup_transfer
    
    If t is not null then the SPI core takes care that bits_per_word and
    speed_hz are populated. This allows to simplify fsl_espi_setup_transfer.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index bef06762a770..060624f45ce0 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -176,23 +176,11 @@ static void fsl_espi_setup_transfer(struct spi_device *spi,
 					struct spi_transfer *t)
 {
 	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
-	int bits_per_word = 0;
+	int bits_per_word = t ? t->bits_per_word : spi->bits_per_word;
+	u32 hz = t ? t->speed_hz : spi->max_speed_hz;
 	u8 pm;
-	u32 hz = 0;
 	struct spi_mpc8xxx_cs *cs = spi->controller_state;
 
-	if (t) {
-		bits_per_word = t->bits_per_word;
-		hz = t->speed_hz;
-	}
-
-	/* spi_transfer level calls that work per-word */
-	if (!bits_per_word)
-		bits_per_word = spi->bits_per_word;
-
-	if (!hz)
-		hz = spi->max_speed_hz;
-
 	cs->rx_shift = 0;
 	cs->tx_shift = 0;
 	cs->get_rx = mpc8xxx_spi_rx_buf_u32;

commit 38d003f1a43f3afd6b5e0da728f06dad07a85687
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 7 22:54:51 2016 +0200

    spi: fsl-espi: merge fsl_espi_trans and fsl_espi_do_trans
    
    Merge both functions to reduce source code size and improve
    readability.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 7b2f997b061f..bef06762a770 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -276,11 +276,13 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	return mpc8xxx_spi->count > 0 ? -EMSGSIZE : 0;
 }
 
-static int fsl_espi_do_trans(struct spi_message *m, struct spi_transfer *trans)
+static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)
 {
+	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
 	struct spi_device *spi = m->spi;
-	int ret = 0;
+	int ret;
 
+	fsl_espi_copy_to_buf(m, mspi);
 	fsl_espi_setup_transfer(spi, trans);
 
 	ret = fsl_espi_bufs(spi, trans);
@@ -290,18 +292,6 @@ static int fsl_espi_do_trans(struct spi_message *m, struct spi_transfer *trans)
 
 	fsl_espi_setup_transfer(spi, NULL);
 
-	return ret;
-}
-
-static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)
-{
-	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
-	int ret;
-
-	fsl_espi_copy_to_buf(m, mspi);
-
-	ret = fsl_espi_do_trans(m, trans);
-
 	if (!ret)
 		fsl_espi_copy_from_buf(m, mspi);
 

commit 06af115d6c6d8b3d7b6cbc8a46f0603e70b1be58
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 7 22:54:35 2016 +0200

    spi: fsl-espi: improve message length handling
    
    Move checking for a zero-length message up in the call chain and
    use m->frame_length instead of re-calculating the overall length
    of all transfers in the message.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 2af7463aea8d..7b2f997b061f 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -283,8 +283,7 @@ static int fsl_espi_do_trans(struct spi_message *m, struct spi_transfer *trans)
 
 	fsl_espi_setup_transfer(spi, trans);
 
-	if (trans->len)
-		ret = fsl_espi_bufs(spi, trans);
+	ret = fsl_espi_bufs(spi, trans);
 
 	if (trans->delay_usecs)
 		udelay(trans->delay_usecs);
@@ -313,7 +312,7 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 			       struct spi_message *m)
 {
 	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
-	unsigned int delay_usecs = 0, xfer_len = 0;
+	unsigned int delay_usecs = 0;
 	struct spi_transfer *t, trans = {};
 	int ret;
 
@@ -322,8 +321,6 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 		goto out;
 
 	list_for_each_entry(t, &m->transfers, transfer_list) {
-		if ((t->tx_buf) || (t->rx_buf))
-			xfer_len += t->len;
 		if (t->delay_usecs > delay_usecs)
 			delay_usecs = t->delay_usecs;
 	}
@@ -331,14 +328,15 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 	t = list_first_entry(&m->transfers, struct spi_transfer,
 			     transfer_list);
 
-	trans.len = xfer_len;
+	trans.len = m->frame_length;
 	trans.speed_hz = t->speed_hz;
 	trans.bits_per_word = t->bits_per_word;
 	trans.delay_usecs = delay_usecs;
 	trans.tx_buf = mspi->local_buf;
 	trans.rx_buf = mspi->local_buf;
 
-	ret = fsl_espi_trans(m, &trans);
+	if (trans.len)
+		ret = fsl_espi_trans(m, &trans);
 
 	m->actual_length = ret ? 0 : trans.len;
 out:

commit cce7e3a2fe39a5b66162a3dc1463a1af598d0803
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 7 22:54:18 2016 +0200

    spi: fsl-espi: factor out handling of read data
    
    Factor out copying read data to the read buffers in the original
    message to a new function fsl_espi_copy_from_buf.
    This also allows to simplify fsl_espi_copy_to_buf.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 7fc9a2c66396..2af7463aea8d 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -77,25 +77,32 @@ struct fsl_espi_reg {
 
 #define AUTOSUSPEND_TIMEOUT 2000
 
-static unsigned int fsl_espi_copy_to_buf(struct spi_message *m,
-					 struct mpc8xxx_spi *mspi)
+static void fsl_espi_copy_to_buf(struct spi_message *m,
+				 struct mpc8xxx_spi *mspi)
 {
-	unsigned int tx_only = 0;
 	struct spi_transfer *t;
 	u8 *buf = mspi->local_buf;
 
 	list_for_each_entry(t, &m->transfers, transfer_list) {
-		if (t->tx_buf) {
+		if (t->tx_buf)
 			memcpy(buf, t->tx_buf, t->len);
-			if (!t->rx_buf)
-				tx_only += t->len;
-		} else {
+		else
 			memset(buf, 0, t->len);
-		}
 		buf += t->len;
 	}
+}
+
+static void fsl_espi_copy_from_buf(struct spi_message *m,
+				   struct mpc8xxx_spi *mspi)
+{
+	struct spi_transfer *t;
+	u8 *buf = mspi->local_buf;
 
-	return tx_only;
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+		if (t->rx_buf)
+			memcpy(t->rx_buf, buf, t->len);
+		buf += t->len;
+	}
 }
 
 static int fsl_espi_check_message(struct spi_message *m)
@@ -287,20 +294,17 @@ static int fsl_espi_do_trans(struct spi_message *m, struct spi_transfer *trans)
 	return ret;
 }
 
-static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans,
-			  u8 *rx_buff)
+static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)
 {
 	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
-	unsigned int tx_only;
 	int ret;
 
-	tx_only = fsl_espi_copy_to_buf(m, mspi);
+	fsl_espi_copy_to_buf(m, mspi);
 
 	ret = fsl_espi_do_trans(m, trans);
 
-	/* If there is at least one RX byte then copy it to rx_buff */
-	if (!ret && rx_buff && trans->len > tx_only)
-		memcpy(rx_buff, trans->rx_buf + tx_only, trans->len - tx_only);
+	if (!ret)
+		fsl_espi_copy_from_buf(m, mspi);
 
 	return ret;
 }
@@ -309,7 +313,6 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 			       struct spi_message *m)
 {
 	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
-	u8 *rx_buf = NULL;
 	unsigned int delay_usecs = 0, xfer_len = 0;
 	struct spi_transfer *t, trans = {};
 	int ret;
@@ -319,8 +322,6 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 		goto out;
 
 	list_for_each_entry(t, &m->transfers, transfer_list) {
-		if (t->rx_buf)
-			rx_buf = t->rx_buf;
 		if ((t->tx_buf) || (t->rx_buf))
 			xfer_len += t->len;
 		if (t->delay_usecs > delay_usecs)
@@ -337,7 +338,7 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 	trans.tx_buf = mspi->local_buf;
 	trans.rx_buf = mspi->local_buf;
 
-	ret = fsl_espi_trans(m, &trans, rx_buf);
+	ret = fsl_espi_trans(m, &trans);
 
 	m->actual_length = ret ? 0 : trans.len;
 out:

commit 96361fafbbfc8a07b4c7ec09d96d742ef68bfbad
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 7 22:54:00 2016 +0200

    spi: fsl-espi: centralize populating struct spi_transfer
    
    Better structure the code by population all elements of struct
    spi_transfer in one place.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 2bfaff64beb8..7fc9a2c66396 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -272,17 +272,8 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 static int fsl_espi_do_trans(struct spi_message *m, struct spi_transfer *trans)
 {
 	struct spi_device *spi = m->spi;
-	struct spi_transfer *t, *first;
 	int ret = 0;
 
-	first = list_first_entry(&m->transfers, struct spi_transfer,
-			transfer_list);
-	list_for_each_entry(t, &m->transfers, transfer_list) {
-		trans->speed_hz = t->speed_hz;
-		trans->bits_per_word = t->bits_per_word;
-		trans->delay_usecs = max(first->delay_usecs, t->delay_usecs);
-	}
-
 	fsl_espi_setup_transfer(spi, trans);
 
 	if (trans->len)
@@ -305,8 +296,6 @@ static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans,
 
 	tx_only = fsl_espi_copy_to_buf(m, mspi);
 
-	trans->tx_buf = mspi->local_buf;
-	trans->rx_buf = mspi->local_buf;
 	ret = fsl_espi_do_trans(m, trans);
 
 	/* If there is at least one RX byte then copy it to rx_buff */
@@ -319,8 +308,9 @@ static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans,
 static int fsl_espi_do_one_msg(struct spi_master *master,
 			       struct spi_message *m)
 {
+	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
 	u8 *rx_buf = NULL;
-	unsigned int xfer_len = 0;
+	unsigned int delay_usecs = 0, xfer_len = 0;
 	struct spi_transfer *t, trans = {};
 	int ret;
 
@@ -333,9 +323,19 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 			rx_buf = t->rx_buf;
 		if ((t->tx_buf) || (t->rx_buf))
 			xfer_len += t->len;
+		if (t->delay_usecs > delay_usecs)
+			delay_usecs = t->delay_usecs;
 	}
 
+	t = list_first_entry(&m->transfers, struct spi_transfer,
+			     transfer_list);
+
 	trans.len = xfer_len;
+	trans.speed_hz = t->speed_hz;
+	trans.bits_per_word = t->bits_per_word;
+	trans.delay_usecs = delay_usecs;
+	trans.tx_buf = mspi->local_buf;
+	trans.rx_buf = mspi->local_buf;
 
 	ret = fsl_espi_trans(m, &trans, rx_buf);
 

commit d3152cf1c8cf3f75d8eb82ae399ea4b35a0df8d4
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 7 22:53:38 2016 +0200

    spi: fsl-espi: factor out initial message checking
    
    Checking the message is currently done at diffrent places in the
    driver. Factor it out to fsl_espi_check_message.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 190ca5ccf834..2bfaff64beb8 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -98,6 +98,30 @@ static unsigned int fsl_espi_copy_to_buf(struct spi_message *m,
 	return tx_only;
 }
 
+static int fsl_espi_check_message(struct spi_message *m)
+{
+	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
+	struct spi_transfer *t, *first;
+
+	if (m->frame_length > SPCOM_TRANLEN_MAX) {
+		dev_err(mspi->dev, "message too long, size is %u bytes\n",
+			m->frame_length);
+		return -EMSGSIZE;
+	}
+
+	first = list_first_entry(&m->transfers, struct spi_transfer,
+				 transfer_list);
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+		if (first->bits_per_word != t->bits_per_word ||
+		    first->speed_hz != t->speed_hz) {
+			dev_err(mspi->dev, "bits_per_word/speed_hz should be the same for all transfers\n");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
 static void fsl_espi_change_mode(struct spi_device *spi)
 {
 	struct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);
@@ -222,11 +246,6 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	reinit_completion(&mpc8xxx_spi->done);
 
 	/* Set SPCOM[CS] and SPCOM[TRANLEN] field */
-	if (t->len > SPCOM_TRANLEN_MAX) {
-		dev_err(mpc8xxx_spi->dev, "Transaction length (%d)"
-				" beyond the SPCOM[TRANLEN] field\n", t->len);
-		return -EINVAL;
-	}
 	mpc8xxx_spi_write_reg(&reg_base->command,
 		(SPCOM_CS(spi->chip_select) | SPCOM_TRANLEN(t->len - 1)));
 
@@ -253,20 +272,12 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 static int fsl_espi_do_trans(struct spi_message *m, struct spi_transfer *trans)
 {
 	struct spi_device *spi = m->spi;
-	struct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);
 	struct spi_transfer *t, *first;
 	int ret = 0;
 
 	first = list_first_entry(&m->transfers, struct spi_transfer,
 			transfer_list);
 	list_for_each_entry(t, &m->transfers, transfer_list) {
-		if ((first->bits_per_word != t->bits_per_word) ||
-			(first->speed_hz != t->speed_hz)) {
-			dev_err(mspi->dev,
-				"bits_per_word/speed_hz should be same for the same SPI transfer\n");
-			return -EINVAL;
-		}
-
 		trans->speed_hz = t->speed_hz;
 		trans->bits_per_word = t->bits_per_word;
 		trans->delay_usecs = max(first->delay_usecs, t->delay_usecs);
@@ -313,6 +324,10 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 	struct spi_transfer *t, trans = {};
 	int ret;
 
+	ret = fsl_espi_check_message(m);
+	if (ret)
+		goto out;
+
 	list_for_each_entry(t, &m->transfers, transfer_list) {
 		if (t->rx_buf)
 			rx_buf = t->rx_buf;
@@ -325,7 +340,7 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 	ret = fsl_espi_trans(m, &trans, rx_buf);
 
 	m->actual_length = ret ? 0 : trans.len;
-
+out:
 	if (m->status == -EINPROGRESS)
 		m->status = ret;
 

commit 5bcc6a2f061266060e0b144302e83e614f683cd7
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 7 22:53:01 2016 +0200

    spi: fsl-espi: merge fsl_espi_bufs and fsl_espi_cpu_bufs
    
    fsl_espi_bufs and fsl_espi_cpu_bufs are very small that we can merge them.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 8d6a570ac704..190ca5ccf834 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -206,31 +206,15 @@ static void fsl_espi_setup_transfer(struct spi_device *spi,
 	fsl_espi_change_mode(spi);
 }
 
-static void fsl_espi_cpu_bufs(struct mpc8xxx_spi *mspi, struct spi_transfer *t,
-		unsigned int len)
-{
-	u32 word;
-	struct fsl_espi_reg *reg_base = mspi->reg_base;
-
-	mspi->count = len;
-
-	/* enable rx ints */
-	mpc8xxx_spi_write_reg(&reg_base->mask, SPIM_NE);
-
-	/* transmit word */
-	word = mspi->get_tx(mspi);
-	mpc8xxx_spi_write_reg(&reg_base->transmit, word);
-}
-
 static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 {
 	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
 	struct fsl_espi_reg *reg_base = mpc8xxx_spi->reg_base;
-	unsigned int len = t->len;
+	u32 word;
 	int ret;
 
 	mpc8xxx_spi->len = t->len;
-	len = roundup(len, 4) / 4;
+	mpc8xxx_spi->count = roundup(t->len, 4) / 4;
 
 	mpc8xxx_spi->tx = t->tx_buf;
 	mpc8xxx_spi->rx = t->rx_buf;
@@ -246,7 +230,12 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	mpc8xxx_spi_write_reg(&reg_base->command,
 		(SPCOM_CS(spi->chip_select) | SPCOM_TRANLEN(t->len - 1)));
 
-	fsl_espi_cpu_bufs(mpc8xxx_spi, t, len);
+	/* enable rx ints */
+	mpc8xxx_spi_write_reg(&reg_base->mask, SPIM_NE);
+
+	/* transmit word */
+	word = mpc8xxx_spi->get_tx(mpc8xxx_spi);
+	mpc8xxx_spi_write_reg(&reg_base->transmit, word);
 
 	/* Won't hang up forever, SPI bus sometimes got lost interrupts... */
 	ret = wait_for_completion_timeout(&mpc8xxx_spi->done, 2 * HZ);

commit 84ccfc371f4a8d1ff86efd7ca7914e33b90325c2
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 7 22:52:43 2016 +0200

    spi: fsl-espi: improve return value handling in fsl_espi_bufs
    
    Return a proper status code from fsl_espi_bufs instead of returning
    the number of remaining words and let the caller evaluate it.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index f8a6dd13ee02..8d6a570ac704 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -258,7 +258,7 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	/* disable rx ints */
 	mpc8xxx_spi_write_reg(&reg_base->mask, 0);
 
-	return mpc8xxx_spi->count;
+	return mpc8xxx_spi->count > 0 ? -EMSGSIZE : 0;
 }
 
 static int fsl_espi_do_trans(struct spi_message *m, struct spi_transfer *trans)
@@ -288,9 +288,6 @@ static int fsl_espi_do_trans(struct spi_message *m, struct spi_transfer *trans)
 	if (trans->len)
 		ret = fsl_espi_bufs(spi, trans);
 
-	if (ret)
-		ret = -EMSGSIZE;
-
 	if (trans->delay_usecs)
 		udelay(trans->delay_usecs);
 

commit 809b1e017bbdaf40d35619e41c1dbc542a5449d2
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 7 22:52:25 2016 +0200

    spi: fsl-espi: merge fsl_espi_cmd_trans and fsl_espi_rw_trans
    
    fsl_espi_cmd_trans and fsl_espi_rw_trans share most of the code so
    we can merge them.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 8554f18e4cf6..f8a6dd13ee02 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -299,23 +299,8 @@ static int fsl_espi_do_trans(struct spi_message *m, struct spi_transfer *trans)
 	return ret;
 }
 
-static int fsl_espi_cmd_trans(struct spi_message *m,
-			      struct spi_transfer *trans, u8 *rx_buff)
-{
-	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
-	int ret;
-
-	fsl_espi_copy_to_buf(m, mspi);
-
-	trans->tx_buf = mspi->local_buf;
-	trans->rx_buf = mspi->local_buf;
-	ret = fsl_espi_do_trans(m, trans);
-
-	return ret;
-}
-
-static int fsl_espi_rw_trans(struct spi_message *m,
-			     struct spi_transfer *trans, u8 *rx_buff)
+static int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans,
+			  u8 *rx_buff)
 {
 	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
 	unsigned int tx_only;
@@ -327,12 +312,9 @@ static int fsl_espi_rw_trans(struct spi_message *m,
 	trans->rx_buf = mspi->local_buf;
 	ret = fsl_espi_do_trans(m, trans);
 
-	if (!ret) {
-		/* If there is at least one RX byte then copy it to rx_buff */
-		if (trans->len > tx_only)
-			memcpy(rx_buff, trans->rx_buf + tx_only,
-			       trans->len - tx_only);
-	}
+	/* If there is at least one RX byte then copy it to rx_buff */
+	if (!ret && rx_buff && trans->len > tx_only)
+		memcpy(rx_buff, trans->rx_buf + tx_only, trans->len - tx_only);
 
 	return ret;
 }
@@ -354,10 +336,7 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 
 	trans.len = xfer_len;
 
-	if (!rx_buf)
-		ret = fsl_espi_cmd_trans(m, &trans, NULL);
-	else
-		ret = fsl_espi_rw_trans(m, &trans, rx_buf);
+	ret = fsl_espi_trans(m, &trans, rx_buf);
 
 	m->actual_length = ret ? 0 : trans.len;
 

commit faceef390702bad8bdf9c93554a3364253d9d943
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 7 22:52:06 2016 +0200

    spi: fsl-espi: eliminate struct fsl_espi_transfer
    
    The remaining elements of struct fsl_espi_transfer are part of struct
    spi_transfer anyway. So we can get rid of struct fsl_espi_transfer
    and use a struct spi_transfer only.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 726d5fdca3b6..8554f18e4cf6 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -37,12 +37,6 @@ struct fsl_espi_reg {
 	__be32 csmode[4];	/* 0x020 - 0x02c eSPI cs mode register */
 };
 
-struct fsl_espi_transfer {
-	const void *tx_buf;
-	void *rx_buf;
-	unsigned len;
-};
-
 /* eSPI Controller mode register definitions */
 #define SPMODE_ENABLE		(1 << 31)
 #define SPMODE_LOOP		(1 << 30)
@@ -267,17 +261,13 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	return mpc8xxx_spi->count;
 }
 
-static int fsl_espi_do_trans(struct spi_message *m,
-			     struct fsl_espi_transfer *tr)
+static int fsl_espi_do_trans(struct spi_message *m, struct spi_transfer *trans)
 {
 	struct spi_device *spi = m->spi;
 	struct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);
-	struct fsl_espi_transfer *espi_trans = tr;
-	struct spi_transfer *t, *first, trans;
+	struct spi_transfer *t, *first;
 	int ret = 0;
 
-	memset(&trans, 0, sizeof(trans));
-
 	first = list_first_entry(&m->transfers, struct spi_transfer,
 			transfer_list);
 	list_for_each_entry(t, &m->transfers, transfer_list) {
@@ -288,25 +278,21 @@ static int fsl_espi_do_trans(struct spi_message *m,
 			return -EINVAL;
 		}
 
-		trans.speed_hz = t->speed_hz;
-		trans.bits_per_word = t->bits_per_word;
-		trans.delay_usecs = max(first->delay_usecs, t->delay_usecs);
+		trans->speed_hz = t->speed_hz;
+		trans->bits_per_word = t->bits_per_word;
+		trans->delay_usecs = max(first->delay_usecs, t->delay_usecs);
 	}
 
-	trans.len = espi_trans->len;
-	trans.tx_buf = espi_trans->tx_buf;
-	trans.rx_buf = espi_trans->rx_buf;
-
-	fsl_espi_setup_transfer(spi, &trans);
+	fsl_espi_setup_transfer(spi, trans);
 
-	if (trans.len)
-		ret = fsl_espi_bufs(spi, &trans);
+	if (trans->len)
+		ret = fsl_espi_bufs(spi, trans);
 
 	if (ret)
 		ret = -EMSGSIZE;
 
-	if (trans.delay_usecs)
-		udelay(trans.delay_usecs);
+	if (trans->delay_usecs)
+		udelay(trans->delay_usecs);
 
 	fsl_espi_setup_transfer(spi, NULL);
 
@@ -314,23 +300,22 @@ static int fsl_espi_do_trans(struct spi_message *m,
 }
 
 static int fsl_espi_cmd_trans(struct spi_message *m,
-			      struct fsl_espi_transfer *trans, u8 *rx_buff)
+			      struct spi_transfer *trans, u8 *rx_buff)
 {
 	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
-	struct fsl_espi_transfer *espi_trans = trans;
 	int ret;
 
 	fsl_espi_copy_to_buf(m, mspi);
 
-	espi_trans->tx_buf = mspi->local_buf;
-	espi_trans->rx_buf = mspi->local_buf;
-	ret = fsl_espi_do_trans(m, espi_trans);
+	trans->tx_buf = mspi->local_buf;
+	trans->rx_buf = mspi->local_buf;
+	ret = fsl_espi_do_trans(m, trans);
 
 	return ret;
 }
 
 static int fsl_espi_rw_trans(struct spi_message *m,
-			     struct fsl_espi_transfer *trans, u8 *rx_buff)
+			     struct spi_transfer *trans, u8 *rx_buff)
 {
 	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
 	unsigned int tx_only;
@@ -355,10 +340,9 @@ static int fsl_espi_rw_trans(struct spi_message *m,
 static int fsl_espi_do_one_msg(struct spi_master *master,
 			       struct spi_message *m)
 {
-	struct spi_transfer *t;
 	u8 *rx_buf = NULL;
 	unsigned int xfer_len = 0;
-	struct fsl_espi_transfer espi_trans;
+	struct spi_transfer *t, trans = {};
 	int ret;
 
 	list_for_each_entry(t, &m->transfers, transfer_list) {
@@ -368,14 +352,14 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 			xfer_len += t->len;
 	}
 
-	espi_trans.len = xfer_len;
+	trans.len = xfer_len;
 
 	if (!rx_buf)
-		ret = fsl_espi_cmd_trans(m, &espi_trans, NULL);
+		ret = fsl_espi_cmd_trans(m, &trans, NULL);
 	else
-		ret = fsl_espi_rw_trans(m, &espi_trans, rx_buf);
+		ret = fsl_espi_rw_trans(m, &trans, rx_buf);
 
-	m->actual_length = ret ? 0 : espi_trans.len;
+	m->actual_length = ret ? 0 : trans.len;
 
 	if (m->status == -EINPROGRESS)
 		m->status = ret;

commit 5cd7b8be6b7b4c4fb9e2bfbfba596d27357cc359
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 7 22:51:48 2016 +0200

    spi: fsl-espi: remove element actual_length from struct fsl_espi_trans
    
    If an error occurs during processing the message, then we don't have
    to populate the actual_length element of struct message.
    So we can get rid of element actual_length in struct
    fsl_espi_transfer.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 6b60f7b29869..726d5fdca3b6 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -41,7 +41,6 @@ struct fsl_espi_transfer {
 	const void *tx_buf;
 	void *rx_buf;
 	unsigned len;
-	unsigned actual_length;
 };
 
 /* eSPI Controller mode register definitions */
@@ -327,8 +326,6 @@ static int fsl_espi_cmd_trans(struct spi_message *m,
 	espi_trans->rx_buf = mspi->local_buf;
 	ret = fsl_espi_do_trans(m, espi_trans);
 
-	espi_trans->actual_length = espi_trans->len;
-
 	return ret;
 }
 
@@ -350,7 +347,6 @@ static int fsl_espi_rw_trans(struct spi_message *m,
 		if (trans->len > tx_only)
 			memcpy(rx_buff, trans->rx_buf + tx_only,
 			       trans->len - tx_only);
-		trans->actual_length += trans->len;
 	}
 
 	return ret;
@@ -373,14 +369,14 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 	}
 
 	espi_trans.len = xfer_len;
-	espi_trans.actual_length = 0;
 
 	if (!rx_buf)
 		ret = fsl_espi_cmd_trans(m, &espi_trans, NULL);
 	else
 		ret = fsl_espi_rw_trans(m, &espi_trans, rx_buf);
 
-	m->actual_length = espi_trans.actual_length;
+	m->actual_length = ret ? 0 : espi_trans.len;
+
 	if (m->status == -EINPROGRESS)
 		m->status = ret;
 

commit 0319d4991ea6e7594f32843e1b47868737056799
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 7 22:51:29 2016 +0200

    spi: fsl-espi: fix status handling in fsl_espi_do_one_msg
    
    If an error occurred during message handling return this error instead
    of always returning 0 and align the code with the generic
    implementation in spi_transfer_one_message.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 5f01b6595442..6b60f7b29869 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -381,9 +381,12 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 		ret = fsl_espi_rw_trans(m, &espi_trans, rx_buf);
 
 	m->actual_length = espi_trans.actual_length;
-	m->status = ret;
+	if (m->status == -EINPROGRESS)
+		m->status = ret;
+
 	spi_finalize_current_message(master);
-	return 0;
+
+	return ret;
 }
 
 static int fsl_espi_setup(struct spi_device *spi)

commit e33a3ade909194ec2ca633a53b428d4dac853f8a
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 7 22:51:10 2016 +0200

    spi: fsl-espi: remove element status from struct fsl_espi_transfer
    
    Use the return values of the functions in the call chain to transport
    status information instead of using an element in struct
    fsl_espi_transfer for this.
    
    This is more in line with the general approach how to handle status
    information and is one step further to eventually get rid of
    struct fsl_espi_transfer completely.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 8e6ef9b153d7..5f01b6595442 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -42,7 +42,6 @@ struct fsl_espi_transfer {
 	void *rx_buf;
 	unsigned len;
 	unsigned actual_length;
-	int status;
 };
 
 /* eSPI Controller mode register definitions */
@@ -269,14 +268,14 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	return mpc8xxx_spi->count;
 }
 
-static void fsl_espi_do_trans(struct spi_message *m,
-				struct fsl_espi_transfer *tr)
+static int fsl_espi_do_trans(struct spi_message *m,
+			     struct fsl_espi_transfer *tr)
 {
 	struct spi_device *spi = m->spi;
 	struct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);
 	struct fsl_espi_transfer *espi_trans = tr;
 	struct spi_transfer *t, *first, trans;
-	int status = 0;
+	int ret = 0;
 
 	memset(&trans, 0, sizeof(trans));
 
@@ -285,10 +284,9 @@ static void fsl_espi_do_trans(struct spi_message *m,
 	list_for_each_entry(t, &m->transfers, transfer_list) {
 		if ((first->bits_per_word != t->bits_per_word) ||
 			(first->speed_hz != t->speed_hz)) {
-			espi_trans->status = -EINVAL;
 			dev_err(mspi->dev,
 				"bits_per_word/speed_hz should be same for the same SPI transfer\n");
-			return;
+			return -EINVAL;
 		}
 
 		trans.speed_hz = t->speed_hz;
@@ -303,52 +301,59 @@ static void fsl_espi_do_trans(struct spi_message *m,
 	fsl_espi_setup_transfer(spi, &trans);
 
 	if (trans.len)
-		status = fsl_espi_bufs(spi, &trans);
+		ret = fsl_espi_bufs(spi, &trans);
 
-	if (status)
-		status = -EMSGSIZE;
+	if (ret)
+		ret = -EMSGSIZE;
 
 	if (trans.delay_usecs)
 		udelay(trans.delay_usecs);
 
-	espi_trans->status = status;
 	fsl_espi_setup_transfer(spi, NULL);
+
+	return ret;
 }
 
-static void fsl_espi_cmd_trans(struct spi_message *m,
-				struct fsl_espi_transfer *trans, u8 *rx_buff)
+static int fsl_espi_cmd_trans(struct spi_message *m,
+			      struct fsl_espi_transfer *trans, u8 *rx_buff)
 {
 	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
 	struct fsl_espi_transfer *espi_trans = trans;
+	int ret;
 
 	fsl_espi_copy_to_buf(m, mspi);
 
 	espi_trans->tx_buf = mspi->local_buf;
 	espi_trans->rx_buf = mspi->local_buf;
-	fsl_espi_do_trans(m, espi_trans);
+	ret = fsl_espi_do_trans(m, espi_trans);
 
 	espi_trans->actual_length = espi_trans->len;
+
+	return ret;
 }
 
-static void fsl_espi_rw_trans(struct spi_message *m,
-				struct fsl_espi_transfer *trans, u8 *rx_buff)
+static int fsl_espi_rw_trans(struct spi_message *m,
+			     struct fsl_espi_transfer *trans, u8 *rx_buff)
 {
 	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
 	unsigned int tx_only;
+	int ret;
 
 	tx_only = fsl_espi_copy_to_buf(m, mspi);
 
 	trans->tx_buf = mspi->local_buf;
 	trans->rx_buf = mspi->local_buf;
-	fsl_espi_do_trans(m, trans);
+	ret = fsl_espi_do_trans(m, trans);
 
-	if (!trans->status) {
+	if (!ret) {
 		/* If there is at least one RX byte then copy it to rx_buff */
 		if (trans->len > tx_only)
 			memcpy(rx_buff, trans->rx_buf + tx_only,
 			       trans->len - tx_only);
 		trans->actual_length += trans->len;
 	}
+
+	return ret;
 }
 
 static int fsl_espi_do_one_msg(struct spi_master *master,
@@ -358,6 +363,7 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 	u8 *rx_buf = NULL;
 	unsigned int xfer_len = 0;
 	struct fsl_espi_transfer espi_trans;
+	int ret;
 
 	list_for_each_entry(t, &m->transfers, transfer_list) {
 		if (t->rx_buf)
@@ -368,15 +374,14 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 
 	espi_trans.len = xfer_len;
 	espi_trans.actual_length = 0;
-	espi_trans.status = 0;
 
 	if (!rx_buf)
-		fsl_espi_cmd_trans(m, &espi_trans, NULL);
+		ret = fsl_espi_cmd_trans(m, &espi_trans, NULL);
 	else
-		fsl_espi_rw_trans(m, &espi_trans, rx_buf);
+		ret = fsl_espi_rw_trans(m, &espi_trans, rx_buf);
 
 	m->actual_length = espi_trans.actual_length;
-	m->status = espi_trans.status;
+	m->status = ret;
 	spi_finalize_current_message(master);
 	return 0;
 }

commit 7c159aa8c103b02a8434ae18b22048952c796e6f
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 7 22:50:53 2016 +0200

    spi: fsl-espi: factor out filling the local buffer
    
    Better structure the code by factoring out filling the local buffer.
    
    In addition don't initialize the complete local buffer at the
    beginning of fsl_espi_do_one_msg. Instead move initialization of
    those parts of the local buffer to be used for transfers w/o tx_buf
    to fsl_espi_copy_to_buf.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 81d7416668b8..8e6ef9b153d7 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -85,6 +85,27 @@ struct fsl_espi_transfer {
 
 #define AUTOSUSPEND_TIMEOUT 2000
 
+static unsigned int fsl_espi_copy_to_buf(struct spi_message *m,
+					 struct mpc8xxx_spi *mspi)
+{
+	unsigned int tx_only = 0;
+	struct spi_transfer *t;
+	u8 *buf = mspi->local_buf;
+
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+		if (t->tx_buf) {
+			memcpy(buf, t->tx_buf, t->len);
+			if (!t->rx_buf)
+				tx_only += t->len;
+		} else {
+			memset(buf, 0, t->len);
+		}
+		buf += t->len;
+	}
+
+	return tx_only;
+}
+
 static void fsl_espi_change_mode(struct spi_device *spi)
 {
 	struct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);
@@ -298,16 +319,9 @@ static void fsl_espi_cmd_trans(struct spi_message *m,
 				struct fsl_espi_transfer *trans, u8 *rx_buff)
 {
 	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
-	struct spi_transfer *t;
-	int i = 0;
 	struct fsl_espi_transfer *espi_trans = trans;
 
-	list_for_each_entry(t, &m->transfers, transfer_list) {
-		if (t->tx_buf) {
-			memcpy(mspi->local_buf + i, t->tx_buf, t->len);
-			i += t->len;
-		}
-	}
+	fsl_espi_copy_to_buf(m, mspi);
 
 	espi_trans->tx_buf = mspi->local_buf;
 	espi_trans->rx_buf = mspi->local_buf;
@@ -320,18 +334,9 @@ static void fsl_espi_rw_trans(struct spi_message *m,
 				struct fsl_espi_transfer *trans, u8 *rx_buff)
 {
 	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
-	struct spi_transfer *t;
-	unsigned int tx_only = 0;
-	int i = 0;
+	unsigned int tx_only;
 
-	list_for_each_entry(t, &m->transfers, transfer_list) {
-		if (t->tx_buf) {
-			memcpy(mspi->local_buf + i, t->tx_buf, t->len);
-			i += t->len;
-			if (!t->rx_buf)
-				tx_only += t->len;
-		}
-	}
+	tx_only = fsl_espi_copy_to_buf(m, mspi);
 
 	trans->tx_buf = mspi->local_buf;
 	trans->rx_buf = mspi->local_buf;
@@ -349,14 +354,11 @@ static void fsl_espi_rw_trans(struct spi_message *m,
 static int fsl_espi_do_one_msg(struct spi_master *master,
 			       struct spi_message *m)
 {
-	struct mpc8xxx_spi *mspi = spi_master_get_devdata(master);
 	struct spi_transfer *t;
 	u8 *rx_buf = NULL;
 	unsigned int xfer_len = 0;
 	struct fsl_espi_transfer espi_trans;
 
-	memset(mspi->local_buf, 0, SPCOM_TRANLEN_MAX);
-
 	list_for_each_entry(t, &m->transfers, transfer_list) {
 		if (t->rx_buf)
 			rx_buf = t->rx_buf;

commit 1423877b73ed5f4982eaba8bed359605b9918a2b
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Sep 7 22:50:22 2016 +0200

    spi: fsl-espi: pre-allocate message buffer
    
    Currently the driver allocates a 64kb buffer for each single message.
    On systems with little and fragmented memory this can result in
    memory allocation errors. Solve this by pre-allocating a buffer.
    
    This patch was developed in OpenWRT long ago, however it never
    made it upstream.
    
    I slightly modified the original patch to re-initialize the buffer
    at the beginning of each transfer.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Signed-off-by: Felix Fietkau <nbd@nbd.name>
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 16fff7237ab2..81d7416668b8 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -297,57 +297,44 @@ static void fsl_espi_do_trans(struct spi_message *m,
 static void fsl_espi_cmd_trans(struct spi_message *m,
 				struct fsl_espi_transfer *trans, u8 *rx_buff)
 {
+	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
 	struct spi_transfer *t;
-	u8 *local_buf;
 	int i = 0;
 	struct fsl_espi_transfer *espi_trans = trans;
 
-	local_buf = kzalloc(SPCOM_TRANLEN_MAX, GFP_KERNEL);
-	if (!local_buf) {
-		espi_trans->status = -ENOMEM;
-		return;
-	}
-
 	list_for_each_entry(t, &m->transfers, transfer_list) {
 		if (t->tx_buf) {
-			memcpy(local_buf + i, t->tx_buf, t->len);
+			memcpy(mspi->local_buf + i, t->tx_buf, t->len);
 			i += t->len;
 		}
 	}
 
-	espi_trans->tx_buf = local_buf;
-	espi_trans->rx_buf = local_buf;
+	espi_trans->tx_buf = mspi->local_buf;
+	espi_trans->rx_buf = mspi->local_buf;
 	fsl_espi_do_trans(m, espi_trans);
 
 	espi_trans->actual_length = espi_trans->len;
-	kfree(local_buf);
 }
 
 static void fsl_espi_rw_trans(struct spi_message *m,
 				struct fsl_espi_transfer *trans, u8 *rx_buff)
 {
+	struct mpc8xxx_spi *mspi = spi_master_get_devdata(m->spi->master);
 	struct spi_transfer *t;
-	u8 *local_buf;
 	unsigned int tx_only = 0;
 	int i = 0;
 
-	local_buf = kzalloc(SPCOM_TRANLEN_MAX, GFP_KERNEL);
-	if (!local_buf) {
-		trans->status = -ENOMEM;
-		return;
-	}
-
 	list_for_each_entry(t, &m->transfers, transfer_list) {
 		if (t->tx_buf) {
-			memcpy(local_buf + i, t->tx_buf, t->len);
+			memcpy(mspi->local_buf + i, t->tx_buf, t->len);
 			i += t->len;
 			if (!t->rx_buf)
 				tx_only += t->len;
 		}
 	}
 
-	trans->tx_buf = local_buf;
-	trans->rx_buf = local_buf;
+	trans->tx_buf = mspi->local_buf;
+	trans->rx_buf = mspi->local_buf;
 	fsl_espi_do_trans(m, trans);
 
 	if (!trans->status) {
@@ -357,18 +344,19 @@ static void fsl_espi_rw_trans(struct spi_message *m,
 			       trans->len - tx_only);
 		trans->actual_length += trans->len;
 	}
-
-	kfree(local_buf);
 }
 
 static int fsl_espi_do_one_msg(struct spi_master *master,
 			       struct spi_message *m)
 {
+	struct mpc8xxx_spi *mspi = spi_master_get_devdata(master);
 	struct spi_transfer *t;
 	u8 *rx_buf = NULL;
 	unsigned int xfer_len = 0;
 	struct fsl_espi_transfer espi_trans;
 
+	memset(mspi->local_buf, 0, SPCOM_TRANLEN_MAX);
+
 	list_for_each_entry(t, &m->transfers, transfer_list) {
 		if (t->rx_buf)
 			rx_buf = t->rx_buf;
@@ -614,6 +602,13 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 
 	mpc8xxx_spi = spi_master_get_devdata(master);
 
+	mpc8xxx_spi->local_buf =
+		devm_kmalloc(dev, SPCOM_TRANLEN_MAX, GFP_KERNEL);
+	if (!mpc8xxx_spi->local_buf) {
+		ret = -ENOMEM;
+		goto err_probe;
+	}
+
 	mpc8xxx_spi->reg_base = devm_ioremap_resource(dev, mem);
 	if (IS_ERR(mpc8xxx_spi->reg_base)) {
 		ret = PTR_ERR(mpc8xxx_spi->reg_base);

commit 71581a1507e642bbc6f698a3f43355552ee8056f
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Sep 4 09:57:18 2016 +0200

    spi: fsl-espi: remove unneeded check in fsl_espi_do_trans
    
    SPI core takes care that both values are always populated.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index b00313bed7e9..16fff7237ab2 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -279,8 +279,7 @@ static void fsl_espi_do_trans(struct spi_message *m,
 	trans.tx_buf = espi_trans->tx_buf;
 	trans.rx_buf = espi_trans->rx_buf;
 
-	if (trans.bits_per_word || trans.speed_hz)
-		fsl_espi_setup_transfer(spi, &trans);
+	fsl_espi_setup_transfer(spi, &trans);
 
 	if (trans.len)
 		status = fsl_espi_bufs(spi, &trans);

commit a755af52f8ef278985d1475070c0647f2e6e47a7
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Sep 4 09:56:57 2016 +0200

    spi: fsl-espi: simplify fsl_espi_setup_transfer
    
    Simplify fsl_espi_setup_transfer a little.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index a9004fe5a5ed..b00313bed7e9 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -166,12 +166,10 @@ static void fsl_espi_setup_transfer(struct spi_device *spi,
 	mpc8xxx_spi->get_rx = cs->get_rx;
 	mpc8xxx_spi->get_tx = cs->get_tx;
 
-	bits_per_word = bits_per_word - 1;
-
 	/* mask out bits we are going to set */
 	cs->hw_mode &= ~(CSMODE_LEN(0xF) | CSMODE_DIV16 | CSMODE_PM(0xF));
 
-	cs->hw_mode |= CSMODE_LEN(bits_per_word);
+	cs->hw_mode |= CSMODE_LEN(bits_per_word - 1);
 
 	if ((mpc8xxx_spi->spibrg / hz) > 64) {
 		cs->hw_mode |= CSMODE_DIV16;

commit daae020ce9fe4324322c6ed18a840234a05d76b3
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Sun Sep 4 09:53:01 2016 +0200

    spi: fsl-espi: remove unused elements n_rx and n_tx in struct fsl_espi_transfer
    
    Both elements are not used, so remove them.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index f9ef50444447..a9004fe5a5ed 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -41,8 +41,6 @@ struct fsl_espi_transfer {
 	const void *tx_buf;
 	void *rx_buf;
 	unsigned len;
-	unsigned n_tx;
-	unsigned n_rx;
 	unsigned actual_length;
 	int status;
 };
@@ -371,24 +369,16 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 {
 	struct spi_transfer *t;
 	u8 *rx_buf = NULL;
-	unsigned int n_tx = 0;
-	unsigned int n_rx = 0;
 	unsigned int xfer_len = 0;
 	struct fsl_espi_transfer espi_trans;
 
 	list_for_each_entry(t, &m->transfers, transfer_list) {
-		if (t->tx_buf)
-			n_tx += t->len;
-		if (t->rx_buf) {
-			n_rx += t->len;
+		if (t->rx_buf)
 			rx_buf = t->rx_buf;
-		}
 		if ((t->tx_buf) || (t->rx_buf))
 			xfer_len += t->len;
 	}
 
-	espi_trans.n_tx = n_tx;
-	espi_trans.n_rx = n_rx;
 	espi_trans.len = xfer_len;
 	espi_trans.actual_length = 0;
 	espi_trans.status = 0;

commit dbd4fefb5b7cba19e3f89c097d93ad02049e38e3
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Aug 25 06:45:55 2016 +0200

    spi: fsl-espi: remove unneeded variable in fsl_espi_do_trans
    
    Creating a message, adding one transfer, and then iterating over
    all transfers in the message doesn't make sense.
    We can simply use the original transfer directly.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 029017818685..f9ef50444447 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -258,11 +258,9 @@ static void fsl_espi_do_trans(struct spi_message *m,
 	struct spi_device *spi = m->spi;
 	struct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);
 	struct fsl_espi_transfer *espi_trans = tr;
-	struct spi_message message;
 	struct spi_transfer *t, *first, trans;
 	int status = 0;
 
-	spi_message_init(&message);
 	memset(&trans, 0, sizeof(trans));
 
 	first = list_first_entry(&m->transfers, struct spi_transfer,
@@ -284,23 +282,18 @@ static void fsl_espi_do_trans(struct spi_message *m,
 	trans.len = espi_trans->len;
 	trans.tx_buf = espi_trans->tx_buf;
 	trans.rx_buf = espi_trans->rx_buf;
-	spi_message_add_tail(&trans, &message);
 
-	list_for_each_entry(t, &message.transfers, transfer_list) {
-		if (t->bits_per_word || t->speed_hz)
-			fsl_espi_setup_transfer(spi, t);
+	if (trans.bits_per_word || trans.speed_hz)
+		fsl_espi_setup_transfer(spi, &trans);
 
-		if (t->len)
-			status = fsl_espi_bufs(spi, t);
+	if (trans.len)
+		status = fsl_espi_bufs(spi, &trans);
 
-		if (status) {
-			status = -EMSGSIZE;
-			break;
-		}
+	if (status)
+		status = -EMSGSIZE;
 
-		if (t->delay_usecs)
-			udelay(t->delay_usecs);
-	}
+	if (trans.delay_usecs)
+		udelay(trans.delay_usecs);
 
 	espi_trans->status = status;
 	fsl_espi_setup_transfer(spi, NULL);

commit 10ed1e6d320ca01deef3bc36df91e04ecd69a60e
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Aug 25 06:45:16 2016 +0200

    spi: fsl-espi: add missing static declaration to fsl_espi_cpu_irq
    
    Add missing static declaration to fsl_espi_cpu_irq.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 2c4714abdde7..029017818685 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -471,7 +471,7 @@ static void fsl_espi_cleanup(struct spi_device *spi)
 	spi_set_ctldata(spi, NULL);
 }
 
-void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
+static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 {
 	struct fsl_espi_reg *reg_base = mspi->reg_base;
 

commit bbb55f6d6276b39a96b7bcd79f1159a1365bb318
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Aug 25 06:44:58 2016 +0200

    spi: fsl-espi: change return type of fsl_espi_cpu_bufs to void
    
    fsl_espi_cpu_bufs always returns 0, so change the return type to void.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 02a55f50f03f..2c4714abdde7 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -197,7 +197,7 @@ static void fsl_espi_setup_transfer(struct spi_device *spi,
 	fsl_espi_change_mode(spi);
 }
 
-static int fsl_espi_cpu_bufs(struct mpc8xxx_spi *mspi, struct spi_transfer *t,
+static void fsl_espi_cpu_bufs(struct mpc8xxx_spi *mspi, struct spi_transfer *t,
 		unsigned int len)
 {
 	u32 word;
@@ -211,8 +211,6 @@ static int fsl_espi_cpu_bufs(struct mpc8xxx_spi *mspi, struct spi_transfer *t,
 	/* transmit word */
 	word = mspi->get_tx(mspi);
 	mpc8xxx_spi_write_reg(&reg_base->transmit, word);
-
-	return 0;
 }
 
 static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
@@ -239,9 +237,7 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	mpc8xxx_spi_write_reg(&reg_base->command,
 		(SPCOM_CS(spi->chip_select) | SPCOM_TRANLEN(t->len - 1)));
 
-	ret = fsl_espi_cpu_bufs(mpc8xxx_spi, t, len);
-	if (ret)
-		return ret;
+	fsl_espi_cpu_bufs(mpc8xxx_spi, t, len);
 
 	/* Won't hang up forever, SPI bus sometimes got lost interrupts... */
 	ret = wait_for_completion_timeout(&mpc8xxx_spi->done, 2 * HZ);

commit ea616ee220e70308cf33fa32496ae9c5ad18e190
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Aug 25 06:44:42 2016 +0200

    spi: fsl-espi: change return type of fsl_espi_setup_transfer to void
    
    fsl_espi_setup_transfer always returns 0, so change the return type
    to void.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index d95fdd0632e4..02a55f50f03f 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -130,7 +130,7 @@ static u32 fsl_espi_tx_buf_lsb(struct mpc8xxx_spi *mpc8xxx_spi)
 	return data;
 }
 
-static int fsl_espi_setup_transfer(struct spi_device *spi,
+static void fsl_espi_setup_transfer(struct spi_device *spi,
 					struct spi_transfer *t)
 {
 	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
@@ -195,7 +195,6 @@ static int fsl_espi_setup_transfer(struct spi_device *spi,
 	cs->hw_mode |= CSMODE_PM(pm);
 
 	fsl_espi_change_mode(spi);
-	return 0;
 }
 
 static int fsl_espi_cpu_bufs(struct mpc8xxx_spi *mspi, struct spi_transfer *t,
@@ -292,13 +291,8 @@ static void fsl_espi_do_trans(struct spi_message *m,
 	spi_message_add_tail(&trans, &message);
 
 	list_for_each_entry(t, &message.transfers, transfer_list) {
-		if (t->bits_per_word || t->speed_hz) {
-			status = -EINVAL;
-
-			status = fsl_espi_setup_transfer(spi, t);
-			if (status < 0)
-				break;
-		}
+		if (t->bits_per_word || t->speed_hz)
+			fsl_espi_setup_transfer(spi, t);
 
 		if (t->len)
 			status = fsl_espi_bufs(spi, t);
@@ -425,7 +419,6 @@ static int fsl_espi_setup(struct spi_device *spi)
 {
 	struct mpc8xxx_spi *mpc8xxx_spi;
 	struct fsl_espi_reg *reg_base;
-	int retval;
 	u32 hw_mode;
 	u32 loop_mode;
 	struct spi_mpc8xxx_cs *cs = spi_get_ctldata(spi);
@@ -466,15 +459,11 @@ static int fsl_espi_setup(struct spi_device *spi)
 		loop_mode |= SPMODE_LOOP;
 	mpc8xxx_spi_write_reg(&reg_base->mode, loop_mode);
 
-	retval = fsl_espi_setup_transfer(spi, NULL);
+	fsl_espi_setup_transfer(spi, NULL);
 
 	pm_runtime_mark_last_busy(mpc8xxx_spi->dev);
 	pm_runtime_put_autosuspend(mpc8xxx_spi->dev);
 
-	if (retval < 0) {
-		cs->hw_mode = hw_mode; /* Restore settings */
-		return retval;
-	}
 	return 0;
 }
 

commit 6bdf03b30ed0ac72d309fe22aed8101f4cc6a2df
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Thu Aug 25 06:43:17 2016 +0200

    spi: fsl-espi: dont include irq.h
    
    irq.h isn't needed and it even shouldn't be included, see comment
    at the beginning of this header file.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 96a2442c1623..d95fdd0632e4 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -12,7 +12,6 @@
 #include <linux/err.h>
 #include <linux/fsl_devices.h>
 #include <linux/interrupt.h>
-#include <linux/irq.h>
 #include <linux/module.h>
 #include <linux/mm.h>
 #include <linux/of.h>

commit 02a595d5d6e4ecc0564ec31afb76202035a7591c
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Aug 17 21:11:01 2016 +0200

    spi: fsl-espi: eliminate spi nor flash read loop
    
    The fsl-espi driver contains a read loop that implicitely assumes that
    the device to read from is a m25p80 SPI NOR flash (bytes 2 - 4 of the
    first write transfer are interpreted as 3 byte flash address).
    
    Now that we have such a read loop in the spi-nor driver and are able
    to correctly indicate the message size limit of the controller,
    the read loop can be removed from the fsl-espi driver.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 8d85a3c343da..96a2442c1623 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -258,23 +258,6 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	return mpc8xxx_spi->count;
 }
 
-static inline void fsl_espi_addr2cmd(unsigned int addr, u8 *cmd)
-{
-	if (cmd) {
-		cmd[1] = (u8)(addr >> 16);
-		cmd[2] = (u8)(addr >> 8);
-		cmd[3] = (u8)(addr >> 0);
-	}
-}
-
-static inline unsigned int fsl_espi_cmd2addr(u8 *cmd)
-{
-	if (cmd)
-		return cmd[1] << 16 | cmd[2] << 8 | cmd[3] << 0;
-
-	return 0;
-}
-
 static void fsl_espi_do_trans(struct spi_message *m,
 				struct fsl_espi_transfer *tr)
 {
@@ -366,68 +349,36 @@ static void fsl_espi_cmd_trans(struct spi_message *m,
 static void fsl_espi_rw_trans(struct spi_message *m,
 				struct fsl_espi_transfer *trans, u8 *rx_buff)
 {
-	struct fsl_espi_transfer *espi_trans = trans;
-	unsigned int total_len = espi_trans->len;
 	struct spi_transfer *t;
 	u8 *local_buf;
-	u8 *rx_buf = rx_buff;
-	unsigned int trans_len;
-	unsigned int addr;
-	unsigned int tx_only;
-	unsigned int rx_pos = 0;
-	unsigned int pos;
-	int i, loop;
+	unsigned int tx_only = 0;
+	int i = 0;
 
 	local_buf = kzalloc(SPCOM_TRANLEN_MAX, GFP_KERNEL);
 	if (!local_buf) {
-		espi_trans->status = -ENOMEM;
+		trans->status = -ENOMEM;
 		return;
 	}
 
-	for (pos = 0, loop = 0; pos < total_len; pos += trans_len, loop++) {
-		trans_len = total_len - pos;
-
-		i = 0;
-		tx_only = 0;
-		list_for_each_entry(t, &m->transfers, transfer_list) {
-			if (t->tx_buf) {
-				memcpy(local_buf + i, t->tx_buf, t->len);
-				i += t->len;
-				if (!t->rx_buf)
-					tx_only += t->len;
-			}
-		}
-
-		/* Add additional TX bytes to compensate SPCOM_TRANLEN_MAX */
-		if (loop > 0)
-			trans_len += tx_only;
-
-		if (trans_len > SPCOM_TRANLEN_MAX)
-			trans_len = SPCOM_TRANLEN_MAX;
-
-		/* Update device offset */
-		if (pos > 0) {
-			addr = fsl_espi_cmd2addr(local_buf);
-			addr += rx_pos;
-			fsl_espi_addr2cmd(addr, local_buf);
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+		if (t->tx_buf) {
+			memcpy(local_buf + i, t->tx_buf, t->len);
+			i += t->len;
+			if (!t->rx_buf)
+				tx_only += t->len;
 		}
+	}
 
-		espi_trans->len = trans_len;
-		espi_trans->tx_buf = local_buf;
-		espi_trans->rx_buf = local_buf;
-		fsl_espi_do_trans(m, espi_trans);
-
-		/* If there is at least one RX byte then copy it to rx_buf */
-		if (tx_only < SPCOM_TRANLEN_MAX)
-			memcpy(rx_buf + rx_pos, espi_trans->rx_buf + tx_only,
-					trans_len - tx_only);
-
-		rx_pos += trans_len - tx_only;
+	trans->tx_buf = local_buf;
+	trans->rx_buf = local_buf;
+	fsl_espi_do_trans(m, trans);
 
-		if (loop > 0)
-			espi_trans->actual_length += espi_trans->len - tx_only;
-		else
-			espi_trans->actual_length += espi_trans->len;
+	if (!trans->status) {
+		/* If there is at least one RX byte then copy it to rx_buff */
+		if (trans->len > tx_only)
+			memcpy(rx_buff, trans->rx_buf + tx_only,
+			       trans->len - tx_only);
+		trans->actual_length += trans->len;
 	}
 
 	kfree(local_buf);
@@ -663,7 +614,7 @@ static int fsl_espi_runtime_resume(struct device *dev)
 }
 #endif
 
-static size_t fsl_espi_max_transfer_size(struct spi_device *spi)
+static size_t fsl_espi_max_message_size(struct spi_device *spi)
 {
 	return SPCOM_TRANLEN_MAX;
 }
@@ -695,7 +646,7 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 	master->cleanup = fsl_espi_cleanup;
 	master->transfer_one_message = fsl_espi_do_one_msg;
 	master->auto_runtime_pm = true;
-	master->max_transfer_size = fsl_espi_max_transfer_size;
+	master->max_message_size = fsl_espi_max_message_size;
 
 	mpc8xxx_spi = spi_master_get_devdata(master);
 

commit 6319a68011b86fa61dc63e94dc4fb716628037f3
Author: Nobuteru Hayashi <hayashi.nbb@ncos.nec.co.jp>
Date:   Fri Mar 18 11:35:21 2016 +0000

    spi/fsl-espi: avoid infinite loops on fsl_espi_cpu_irq()
    
    It brought nearly infinite loops, and was possible to be
    occurred only if the SPI transaction total size are not
    alighed with 4. Loops are here at while (tmp--),
    tmp is unsigned, and set it with minus value.
    
    The loops are executed as a result of unexpected RX interrupt
    occurrence after that. This interrupt may be hardware eratta
    and is not fixed.
    
    Fix mspi->len from minus value to 0 and print warning message.
    
    Signed-off-by: Nobuteru Hayashi <hayashi.nbb@ncos.nec.co.jp>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 64d794b99803..8d85a3c343da 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -544,6 +544,7 @@ void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 	if (events & SPIE_NE) {
 		u32 rx_data, tmp;
 		u8 rx_data_8;
+		int rx_nr_bytes = 4;
 		int ret;
 
 		/* Spin until RX is done */
@@ -560,7 +561,14 @@ void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 
 		if (mspi->len >= 4) {
 			rx_data = mpc8xxx_spi_read_reg(&reg_base->receive);
+		} else if (mspi->len <= 0) {
+			dev_err(mspi->dev,
+				"unexpected RX(SPIE_NE) interrupt occurred,\n"
+				"(local rxlen %d bytes, reg rxlen %d bytes)\n",
+				min(4, mspi->len), SPIE_RXCNT(events));
+			rx_nr_bytes = 0;
 		} else {
+			rx_nr_bytes = mspi->len;
 			tmp = mspi->len;
 			rx_data = 0;
 			while (tmp--) {
@@ -571,7 +579,7 @@ void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 			rx_data <<= (4 - mspi->len) * 8;
 		}
 
-		mspi->len -= 4;
+		mspi->len -= rx_nr_bytes;
 
 		if (mspi->rx)
 			mspi->get_rx(rx_data, mspi);

commit aa70e567c4f0eeb849c6bcef3685bdf1fc3ca19d
Author: Nobuteru Hayashi <hayashi.nbb@ncos.nec.co.jp>
Date:   Fri Mar 18 11:35:21 2016 +0000

    spi/fsl-espi: Don't wait transaction completion forever
    
    Because the eSPI driver uses wait_for_completion(), any stuck-able
    phenomenon at half-way transaction progress made worker task hang up.
    This phenomenon is perhaps caused by eSPI device errata which seems not
    to be published from vendor site yet.
    
    Anyway, we fix hang task by using fixed 2 seconds timeout
    that is our preferred value for eSPI maximum transaction size.
    
    It seems to be better that eSPI driver can detect this stuck and
    report error (EMSGSIZE) to the upper device driver because
    the upper device driver can decide to retry or recover.
    
    Signed-off-by: Nobuteru Hayashi <hayashi.nbb@ncos.nec.co.jp>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 5d7fb81240cd..64d794b99803 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -245,7 +245,12 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	if (ret)
 		return ret;
 
-	wait_for_completion(&mpc8xxx_spi->done);
+	/* Won't hang up forever, SPI bus sometimes got lost interrupts... */
+	ret = wait_for_completion_timeout(&mpc8xxx_spi->done, 2 * HZ);
+	if (ret == 0)
+		dev_err(mpc8xxx_spi->dev,
+			"Transaction hanging up (left %d bytes)\n",
+			mpc8xxx_spi->count);
 
 	/* disable rx ints */
 	mpc8xxx_spi_write_reg(&reg_base->mask, 0);

commit a12ddd60ed0a88c3bb83a8d4c07762e41620bf8c
Author: Nobuteru Hayashi <hayashi.nbb@ncos.nec.co.jp>
Date:   Fri Mar 18 11:35:21 2016 +0000

    spi/fsl-espi: Don't spin forever on SPIE_RXCNT
    
    Infinite loop on SPIE_RXCNT occurred.
    
    while (SPIE_RXCNT(events) < min(4, mspi->len)) {
            cpu_relax();
            events = mpc8xxx_spi_read_reg(&reg_base->event);
    }
    
    We met a soft lockup at fsl_espi_cpu_irq() because of this.
    
    Fix it by using spin_event_timeout() so that fsl_espi_cpu_irq()
    can break loop with timeouts dmesg.
    
    Signed-off-by: Nobuteru Hayashi <hayashi.nbb@ncos.nec.co.jp>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 7cb0c1921495..5d7fb81240cd 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -539,11 +539,18 @@ void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 	if (events & SPIE_NE) {
 		u32 rx_data, tmp;
 		u8 rx_data_8;
+		int ret;
 
 		/* Spin until RX is done */
-		while (SPIE_RXCNT(events) < min(4, mspi->len)) {
-			cpu_relax();
-			events = mpc8xxx_spi_read_reg(&reg_base->event);
+		if (SPIE_RXCNT(events) < min(4, mspi->len)) {
+			ret = spin_event_timeout(
+				!(SPIE_RXCNT(events =
+				mpc8xxx_spi_read_reg(&reg_base->event)) <
+						min(4, mspi->len)),
+						10000, 0); /* 10 msec */
+			if (!ret)
+				dev_err(mspi->dev,
+					 "tired waiting for SPIE_RXCNT\n");
 		}
 
 		if (mspi->len >= 4) {

commit 5cfa1e4e0deced0cccedb4b30facb8a8e68e209b
Author: Hou Zhiqiang <B48286@freescale.com>
Date:   Fri Jan 22 18:58:26 2016 +0800

    spi/fsl-espi: Correct the maximum transaction length
    
    The maximum length during one transcation is 64KiB.
    
    Signed-off-by: Hou Zhiqiang <B48286@freescale.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 7fd6a4c009d2..7cb0c1921495 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -84,7 +84,7 @@ struct fsl_espi_transfer {
 /* SPCOM register values */
 #define SPCOM_CS(x)		((x) << 30)
 #define SPCOM_TRANLEN(x)	((x) << 0)
-#define	SPCOM_TRANLEN_MAX	0xFFFF	/* Max transaction length */
+#define	SPCOM_TRANLEN_MAX	0x10000	/* Max transaction length */
 
 #define AUTOSUSPEND_TIMEOUT 2000
 
@@ -233,7 +233,7 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	reinit_completion(&mpc8xxx_spi->done);
 
 	/* Set SPCOM[CS] and SPCOM[TRANLEN] field */
-	if ((t->len - 1) > SPCOM_TRANLEN_MAX) {
+	if (t->len > SPCOM_TRANLEN_MAX) {
 		dev_err(mpc8xxx_spi->dev, "Transaction length (%d)"
 				" beyond the SPCOM[TRANLEN] field\n", t->len);
 		return -EINVAL;

commit b541eef125fa3ae0df84572459af4e7084cb6343
Author: Michal Suchanek <hramrach@gmail.com>
Date:   Wed Dec 2 10:38:21 2015 +0000

    spi: fsl-espi: expose maximum transfer size limit
    
    The fsl-espi hardware can trasfer at most 64K data so report teh
    limitation.
    
    Based on patch by Heiner Kallweit <hkallweit1@gmail.com>
    
    CC: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Michal Suchanek <hramrach@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index c27124a5ec8e..7fd6a4c009d2 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -643,6 +643,11 @@ static int fsl_espi_runtime_resume(struct device *dev)
 }
 #endif
 
+static size_t fsl_espi_max_transfer_size(struct spi_device *spi)
+{
+	return SPCOM_TRANLEN_MAX;
+}
+
 static struct spi_master * fsl_espi_probe(struct device *dev,
 		struct resource *mem, unsigned int irq)
 {
@@ -670,6 +675,7 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 	master->cleanup = fsl_espi_cleanup;
 	master->transfer_one_message = fsl_espi_do_one_msg;
 	master->auto_runtime_pm = true;
+	master->max_transfer_size = fsl_espi_max_transfer_size;
 
 	mpc8xxx_spi = spi_master_get_devdata(master);
 

commit 37c5db7938093cada165146ee99bd57c97baf6a3
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sun Aug 30 18:35:51 2015 +0800

    spi: fsl-(e)spi: Fix checking return value of devm_ioremap_resource
    
    devm_ioremap_resource() returns ERR_PTR on error.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index db82c872c0f9..c27124a5ec8e 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -674,8 +674,8 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 	mpc8xxx_spi = spi_master_get_devdata(master);
 
 	mpc8xxx_spi->reg_base = devm_ioremap_resource(dev, mem);
-	if (!mpc8xxx_spi->reg_base) {
-		ret = -ENOMEM;
+	if (IS_ERR(mpc8xxx_spi->reg_base)) {
+		ret = PTR_ERR(mpc8xxx_spi->reg_base);
 		goto err_probe;
 	}
 

commit e9abb4db8d108624c293f06dce06b2978e626a13
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Aug 26 21:21:55 2015 +0200

    spi: fsl-espi: add runtime PM
    
    Add runtime PM and use autosuspend instead of suspending the
    SPI controller after each transfer.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index fe54e5788245..db82c872c0f9 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -21,6 +21,7 @@
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
 #include <linux/spi/spi.h>
+#include <linux/pm_runtime.h>
 #include <sysdev/fsl_soc.h>
 
 #include "spi-fsl-lib.h"
@@ -85,6 +86,8 @@ struct fsl_espi_transfer {
 #define SPCOM_TRANLEN(x)	((x) << 0)
 #define	SPCOM_TRANLEN_MAX	0xFFFF	/* Max transaction length */
 
+#define AUTOSUSPEND_TIMEOUT 2000
+
 static void fsl_espi_change_mode(struct spi_device *spi)
 {
 	struct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);
@@ -485,6 +488,8 @@ static int fsl_espi_setup(struct spi_device *spi)
 	mpc8xxx_spi = spi_master_get_devdata(spi->master);
 	reg_base = mpc8xxx_spi->reg_base;
 
+	pm_runtime_get_sync(mpc8xxx_spi->dev);
+
 	hw_mode = cs->hw_mode; /* Save original settings */
 	cs->hw_mode = mpc8xxx_spi_read_reg(
 			&reg_base->csmode[spi->chip_select]);
@@ -507,6 +512,10 @@ static int fsl_espi_setup(struct spi_device *spi)
 	mpc8xxx_spi_write_reg(&reg_base->mode, loop_mode);
 
 	retval = fsl_espi_setup_transfer(spi, NULL);
+
+	pm_runtime_mark_last_busy(mpc8xxx_spi->dev);
+	pm_runtime_put_autosuspend(mpc8xxx_spi->dev);
+
 	if (retval < 0) {
 		cs->hw_mode = hw_mode; /* Restore settings */
 		return retval;
@@ -604,15 +613,14 @@ static irqreturn_t fsl_espi_irq(s32 irq, void *context_data)
 	return ret;
 }
 
-static int fsl_espi_suspend(struct spi_master *master)
+#ifdef CONFIG_PM
+static int fsl_espi_runtime_suspend(struct device *dev)
 {
-	struct mpc8xxx_spi *mpc8xxx_spi;
-	struct fsl_espi_reg *reg_base;
+	struct spi_master *master = dev_get_drvdata(dev);
+	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(master);
+	struct fsl_espi_reg *reg_base = mpc8xxx_spi->reg_base;
 	u32 regval;
 
-	mpc8xxx_spi = spi_master_get_devdata(master);
-	reg_base = mpc8xxx_spi->reg_base;
-
 	regval = mpc8xxx_spi_read_reg(&reg_base->mode);
 	regval &= ~SPMODE_ENABLE;
 	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
@@ -620,21 +628,20 @@ static int fsl_espi_suspend(struct spi_master *master)
 	return 0;
 }
 
-static int fsl_espi_resume(struct spi_master *master)
+static int fsl_espi_runtime_resume(struct device *dev)
 {
-	struct mpc8xxx_spi *mpc8xxx_spi;
-	struct fsl_espi_reg *reg_base;
+	struct spi_master *master = dev_get_drvdata(dev);
+	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(master);
+	struct fsl_espi_reg *reg_base = mpc8xxx_spi->reg_base;
 	u32 regval;
 
-	mpc8xxx_spi = spi_master_get_devdata(master);
-	reg_base = mpc8xxx_spi->reg_base;
-
 	regval = mpc8xxx_spi_read_reg(&reg_base->mode);
 	regval |= SPMODE_ENABLE;
 	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
 
 	return 0;
 }
+#endif
 
 static struct spi_master * fsl_espi_probe(struct device *dev,
 		struct resource *mem, unsigned int irq)
@@ -662,8 +669,7 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 	master->setup = fsl_espi_setup;
 	master->cleanup = fsl_espi_cleanup;
 	master->transfer_one_message = fsl_espi_do_one_msg;
-	master->prepare_transfer_hardware = fsl_espi_resume;
-	master->unprepare_transfer_hardware = fsl_espi_suspend;
+	master->auto_runtime_pm = true;
 
 	mpc8xxx_spi = spi_master_get_devdata(master);
 
@@ -725,14 +731,27 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 
 	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
 
+	pm_runtime_set_autosuspend_delay(dev, AUTOSUSPEND_TIMEOUT);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_get_sync(dev);
+
 	ret = devm_spi_register_master(dev, master);
 	if (ret < 0)
-		goto err_probe;
+		goto err_pm;
 
 	dev_info(dev, "at 0x%p (irq = %d)\n", reg_base, mpc8xxx_spi->irq);
 
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
 	return master;
 
+err_pm:
+	pm_runtime_put_noidle(dev);
+	pm_runtime_disable(dev);
+	pm_runtime_set_suspended(dev);
 err_probe:
 	spi_master_put(master);
 err:
@@ -797,6 +816,13 @@ static int of_fsl_espi_probe(struct platform_device *ofdev)
 	return ret;
 }
 
+static int of_fsl_espi_remove(struct platform_device *dev)
+{
+	pm_runtime_disable(&dev->dev);
+
+	return 0;
+}
+
 #ifdef CONFIG_PM_SLEEP
 static int of_fsl_espi_suspend(struct device *dev)
 {
@@ -809,7 +835,11 @@ static int of_fsl_espi_suspend(struct device *dev)
 		return ret;
 	}
 
-	return fsl_espi_suspend(master);
+	ret = pm_runtime_force_suspend(dev);
+	if (ret < 0)
+		return ret;
+
+	return 0;
 }
 
 static int of_fsl_espi_resume(struct device *dev)
@@ -819,7 +849,7 @@ static int of_fsl_espi_resume(struct device *dev)
 	struct mpc8xxx_spi *mpc8xxx_spi;
 	struct fsl_espi_reg *reg_base;
 	u32 regval;
-	int i;
+	int i, ret;
 
 	mpc8xxx_spi = spi_master_get_devdata(master);
 	reg_base = mpc8xxx_spi->reg_base;
@@ -839,11 +869,17 @@ static int of_fsl_espi_resume(struct device *dev)
 
 	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
 
+	ret = pm_runtime_force_resume(dev);
+	if (ret < 0)
+		return ret;
+
 	return spi_master_resume(master);
 }
 #endif /* CONFIG_PM_SLEEP */
 
 static const struct dev_pm_ops espi_pm = {
+	SET_RUNTIME_PM_OPS(fsl_espi_runtime_suspend,
+			   fsl_espi_runtime_resume, NULL)
 	SET_SYSTEM_SLEEP_PM_OPS(of_fsl_espi_suspend, of_fsl_espi_resume)
 };
 
@@ -860,6 +896,7 @@ static struct platform_driver fsl_espi_driver = {
 		.pm = &espi_pm,
 	},
 	.probe		= of_fsl_espi_probe,
+	.remove		= of_fsl_espi_remove,
 };
 module_platform_driver(fsl_espi_driver);
 

commit 3c5395b66ff69d8d568d0b9ff8b1077e044def5b
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Aug 26 21:21:53 2015 +0200

    spi: fsl-(e)spi: simplify cleanup code
    
    Now that most cleanup is done automatically the remove functions
    can be significantly simplified.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index f35eb2c46782..fe54e5788245 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -797,11 +797,6 @@ static int of_fsl_espi_probe(struct platform_device *ofdev)
 	return ret;
 }
 
-static int of_fsl_espi_remove(struct platform_device *dev)
-{
-	return mpc8xxx_spi_remove(&dev->dev);
-}
-
 #ifdef CONFIG_PM_SLEEP
 static int of_fsl_espi_suspend(struct device *dev)
 {
@@ -865,7 +860,6 @@ static struct platform_driver fsl_espi_driver = {
 		.pm = &espi_pm,
 	},
 	.probe		= of_fsl_espi_probe,
-	.remove		= of_fsl_espi_remove,
 };
 module_platform_driver(fsl_espi_driver);
 

commit 4178b6b1b595003cd6e04711b449797a582e44f5
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Aug 26 21:21:50 2015 +0200

    spi: fsl-(e)spi: migrate to using devm_ functions to simplify cleanup
    
    Migrate fsl-espi and fsl-spi to using the managed devm_ functions
    for resource handling. This simplifies the cleanup.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index d3f05a0525a4..f35eb2c46782 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -604,11 +604,6 @@ static irqreturn_t fsl_espi_irq(s32 irq, void *context_data)
 	return ret;
 }
 
-static void fsl_espi_remove(struct mpc8xxx_spi *mspi)
-{
-	iounmap(mspi->reg_base);
-}
-
 static int fsl_espi_suspend(struct spi_master *master)
 {
 	struct mpc8xxx_spi *mpc8xxx_spi;
@@ -671,9 +666,8 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 	master->unprepare_transfer_hardware = fsl_espi_suspend;
 
 	mpc8xxx_spi = spi_master_get_devdata(master);
-	mpc8xxx_spi->spi_remove = fsl_espi_remove;
 
-	mpc8xxx_spi->reg_base = ioremap(mem->start, resource_size(mem));
+	mpc8xxx_spi->reg_base = devm_ioremap_resource(dev, mem);
 	if (!mpc8xxx_spi->reg_base) {
 		ret = -ENOMEM;
 		goto err_probe;
@@ -682,10 +676,10 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 	reg_base = mpc8xxx_spi->reg_base;
 
 	/* Register for SPI Interrupt */
-	ret = request_irq(mpc8xxx_spi->irq, fsl_espi_irq,
+	ret = devm_request_irq(dev, mpc8xxx_spi->irq, fsl_espi_irq,
 			  0, "fsl_espi", mpc8xxx_spi);
 	if (ret)
-		goto free_irq;
+		goto err_probe;
 
 	if (mpc8xxx_spi->flags & SPI_QE_CPU_MODE) {
 		mpc8xxx_spi->rx_shift = 16;
@@ -731,18 +725,14 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 
 	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
 
-	ret = spi_register_master(master);
+	ret = devm_spi_register_master(dev, master);
 	if (ret < 0)
-		goto unreg_master;
+		goto err_probe;
 
 	dev_info(dev, "at 0x%p (irq = %d)\n", reg_base, mpc8xxx_spi->irq);
 
 	return master;
 
-unreg_master:
-	free_irq(mpc8xxx_spi->irq, mpc8xxx_spi);
-free_irq:
-	iounmap(mpc8xxx_spi->reg_base);
 err_probe:
 	spi_master_put(master);
 err:

commit 5bfb10d78e629196ec9fce7d944e28ee9592ee2f
Merge: 8757091bfa92 9deef024a12e 7a0a1759f7b1 ce2f6ea1cbd4 ea6055c46eda
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Jun 18 00:19:46 2015 +0100

    Merge remote-tracking branches 'spi/fix/fsl-dspi', 'spi/fix/fsl-espi', 'spi/fix/orion' and 'spi/fix/pl022' into spi-linus

commit 7a0a1759f7b157f56b8f291f3664db4b65963c8a
Author: Jane Wan <Jane.Wan@gainspeed.com>
Date:   Fri May 1 16:37:42 2015 -0700

    spi: fsl-espi: Fix an error that can cause fsl espi task blocked
    
    Incorrect condition is used in spin_event_timeout().  When the TX is
    done, the SPIE_NF bit in ESPI_SPIE register is set to 1 to indicate the
    Tx FIFO is not full.  If the bit is 0, it indicates the Tx FIFO is full.
    
    Due to this error, if the Tx FIFO is full at the beginning, but becomes
    not full after handling the Rx FIFO (the SPIE_NF bit is set), the
    spin_event_timeout() returns with timeout occurred.  It causes the
    interrupt handler not to send completion notification to the thread that
    called wait_for_complete() waiting for the notification.
    
    Signed-off-by: Jane Wan <Jane.Wan@gainspeed.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index d0a73a09a9bd..a0dbb51630d9 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -544,9 +544,13 @@ void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 
 		/* spin until TX is done */
 		ret = spin_event_timeout(((events = mpc8xxx_spi_read_reg(
-				&reg_base->event)) & SPIE_NF) == 0, 1000, 0);
+				&reg_base->event)) & SPIE_NF), 1000, 0);
 		if (!ret) {
 			dev_err(mspi->dev, "tired waiting for SPIE_NF\n");
+
+			/* Clear the SPIE bits */
+			mpc8xxx_spi_write_reg(&reg_base->event, events);
+			complete(&mspi->done);
 			return;
 		}
 	}

commit 2000058e892cd6773b3061a56c0bd6535ac15afe
Author: Jonatas Rech <jonatas.rech@datacom.ind.br>
Date:   Wed Apr 15 12:23:18 2015 -0300

    spi: fsl-espi: fix behaviour for full-duplex xfers
    
    This patch makes possible for protocol drivers to do full-duplex SPI
    transfers properly. Until now this driver could only be used for
    half-duplex transfers, since it always expected an spi_transfer with
    non-null tx_buf to be only used for TX, and those with non-null rx_buf
    to be only used for RX.
    
    The fix consists in correcting the fsl_espi_transfer length by taking
    into consideration duplex spi_transfers, and not just by adding n_tx
    and n_rx.
    
    Furthermore, this correction has exposed an inconsistency in the
    protocol driver <-> controller driver interaction. The spi-fsl-espi
    driver artificially inserts TX bytes when message fragmentation is
    necessary (due to SPCOM_TRANLEN_MAX) instead of informing the
    protocol driver of the hardware limitation. This was tested with the
    m25p80 NOR flash protocol driver. Since fixing this issue may cause
    other client drivers to malfunction, it was left as is.
    
    Signed-off-by: Jonatas Rech <jonatas.rech@datacom.ind.br>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index d0a73a09a9bd..80d245ac846f 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -359,14 +359,16 @@ static void fsl_espi_rw_trans(struct spi_message *m,
 				struct fsl_espi_transfer *trans, u8 *rx_buff)
 {
 	struct fsl_espi_transfer *espi_trans = trans;
-	unsigned int n_tx = espi_trans->n_tx;
-	unsigned int n_rx = espi_trans->n_rx;
+	unsigned int total_len = espi_trans->len;
 	struct spi_transfer *t;
 	u8 *local_buf;
 	u8 *rx_buf = rx_buff;
 	unsigned int trans_len;
 	unsigned int addr;
-	int i, pos, loop;
+	unsigned int tx_only;
+	unsigned int rx_pos = 0;
+	unsigned int pos;
+	int i, loop;
 
 	local_buf = kzalloc(SPCOM_TRANLEN_MAX, GFP_KERNEL);
 	if (!local_buf) {
@@ -374,36 +376,48 @@ static void fsl_espi_rw_trans(struct spi_message *m,
 		return;
 	}
 
-	for (pos = 0, loop = 0; pos < n_rx; pos += trans_len, loop++) {
-		trans_len = n_rx - pos;
-		if (trans_len > SPCOM_TRANLEN_MAX - n_tx)
-			trans_len = SPCOM_TRANLEN_MAX - n_tx;
+	for (pos = 0, loop = 0; pos < total_len; pos += trans_len, loop++) {
+		trans_len = total_len - pos;
 
 		i = 0;
+		tx_only = 0;
 		list_for_each_entry(t, &m->transfers, transfer_list) {
 			if (t->tx_buf) {
 				memcpy(local_buf + i, t->tx_buf, t->len);
 				i += t->len;
+				if (!t->rx_buf)
+					tx_only += t->len;
 			}
 		}
 
+		/* Add additional TX bytes to compensate SPCOM_TRANLEN_MAX */
+		if (loop > 0)
+			trans_len += tx_only;
+
+		if (trans_len > SPCOM_TRANLEN_MAX)
+			trans_len = SPCOM_TRANLEN_MAX;
+
+		/* Update device offset */
 		if (pos > 0) {
 			addr = fsl_espi_cmd2addr(local_buf);
-			addr += pos;
+			addr += rx_pos;
 			fsl_espi_addr2cmd(addr, local_buf);
 		}
 
-		espi_trans->n_tx = n_tx;
-		espi_trans->n_rx = trans_len;
-		espi_trans->len = trans_len + n_tx;
+		espi_trans->len = trans_len;
 		espi_trans->tx_buf = local_buf;
 		espi_trans->rx_buf = local_buf;
 		fsl_espi_do_trans(m, espi_trans);
 
-		memcpy(rx_buf + pos, espi_trans->rx_buf + n_tx, trans_len);
+		/* If there is at least one RX byte then copy it to rx_buf */
+		if (tx_only < SPCOM_TRANLEN_MAX)
+			memcpy(rx_buf + rx_pos, espi_trans->rx_buf + tx_only,
+					trans_len - tx_only);
+
+		rx_pos += trans_len - tx_only;
 
 		if (loop > 0)
-			espi_trans->actual_length += espi_trans->len - n_tx;
+			espi_trans->actual_length += espi_trans->len - tx_only;
 		else
 			espi_trans->actual_length += espi_trans->len;
 	}
@@ -418,6 +432,7 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 	u8 *rx_buf = NULL;
 	unsigned int n_tx = 0;
 	unsigned int n_rx = 0;
+	unsigned int xfer_len = 0;
 	struct fsl_espi_transfer espi_trans;
 
 	list_for_each_entry(t, &m->transfers, transfer_list) {
@@ -427,11 +442,13 @@ static int fsl_espi_do_one_msg(struct spi_master *master,
 			n_rx += t->len;
 			rx_buf = t->rx_buf;
 		}
+		if ((t->tx_buf) || (t->rx_buf))
+			xfer_len += t->len;
 	}
 
 	espi_trans.n_tx = n_tx;
 	espi_trans.n_rx = n_rx;
-	espi_trans.len = n_tx + n_rx;
+	espi_trans.len = xfer_len;
 	espi_trans.actual_length = 0;
 	espi_trans.status = 0;
 

commit e6b5be2be4e30037eb551e0ed09dd97bd00d85d3
Merge: 37da7bbbe84f f1c488a78d9f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 16:10:09 2014 -0800

    Merge tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core update from Greg KH:
     "Here's the set of driver core patches for 3.19-rc1.
    
      They are dominated by the removal of the .owner field in platform
      drivers.  They touch a lot of files, but they are "simple" changes,
      just removing a line in a structure.
    
      Other than that, a few minor driver core and debugfs changes.  There
      are some ath9k patches coming in through this tree that have been
      acked by the wireless maintainers as they relied on the debugfs
      changes.
    
      Everything has been in linux-next for a while"
    
    * tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (324 commits)
      Revert "ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries"
      fs: debugfs: add forward declaration for struct device type
      firmware class: Deletion of an unnecessary check before the function call "vunmap"
      firmware loader: fix hung task warning dump
      devcoredump: provide a one-way disable function
      device: Add dev_<level>_once variants
      ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries
      ath: use seq_file api for ath9k debugfs files
      debugfs: add helper function to create device related seq_file
      drivers/base: cacheinfo: remove noisy error boot message
      Revert "core: platform: add warning if driver has no owner"
      drivers: base: support cpu cache information interface to userspace via sysfs
      drivers: base: add cpu_device_create to support per-cpu devices
      topology: replace custom attribute macros with standard DEVICE_ATTR*
      cpumask: factor out show_cpumap into separate helper function
      driver core: Fix unbalanced device reference in drivers_probe
      driver core: fix race with userland in device_add()
      sysfs/kernfs: make read requests on pre-alloc files use the buffer.
      sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
      fs: sysfs: return EGBIG on write if offset is larger than file size
      ...

commit 75506d0e0084ee7f074be3c5da6d5de98ce347b6
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Dec 3 07:56:19 2014 +0100

    spi: fsl-espi: add (un)prepare_transfer_hardware calls to save power if SPI is not in use
    
    Use (un)prepare_transfer_hardware calls to set fsl-espi to
    low-power idle if not in use. Reference manual states:
    
    "The eSPI is in a idle state and consumes minimal power.
    The eSPI BRG is not functioning and the input clock is disabled"
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 90be6405e789..56cadf13519e 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -588,6 +588,38 @@ static void fsl_espi_remove(struct mpc8xxx_spi *mspi)
 	iounmap(mspi->reg_base);
 }
 
+static int fsl_espi_suspend(struct spi_master *master)
+{
+	struct mpc8xxx_spi *mpc8xxx_spi;
+	struct fsl_espi_reg *reg_base;
+	u32 regval;
+
+	mpc8xxx_spi = spi_master_get_devdata(master);
+	reg_base = mpc8xxx_spi->reg_base;
+
+	regval = mpc8xxx_spi_read_reg(&reg_base->mode);
+	regval &= ~SPMODE_ENABLE;
+	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
+
+	return 0;
+}
+
+static int fsl_espi_resume(struct spi_master *master)
+{
+	struct mpc8xxx_spi *mpc8xxx_spi;
+	struct fsl_espi_reg *reg_base;
+	u32 regval;
+
+	mpc8xxx_spi = spi_master_get_devdata(master);
+	reg_base = mpc8xxx_spi->reg_base;
+
+	regval = mpc8xxx_spi_read_reg(&reg_base->mode);
+	regval |= SPMODE_ENABLE;
+	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
+
+	return 0;
+}
+
 static struct spi_master * fsl_espi_probe(struct device *dev,
 		struct resource *mem, unsigned int irq)
 {
@@ -614,6 +646,8 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 	master->setup = fsl_espi_setup;
 	master->cleanup = fsl_espi_cleanup;
 	master->transfer_one_message = fsl_espi_do_one_msg;
+	master->prepare_transfer_hardware = fsl_espi_resume;
+	master->unprepare_transfer_hardware = fsl_espi_suspend;
 
 	mpc8xxx_spi = spi_master_get_devdata(master);
 	mpc8xxx_spi->spi_remove = fsl_espi_remove;
@@ -761,25 +795,15 @@ static int of_fsl_espi_remove(struct platform_device *dev)
 static int of_fsl_espi_suspend(struct device *dev)
 {
 	struct spi_master *master = dev_get_drvdata(dev);
-	struct mpc8xxx_spi *mpc8xxx_spi;
-	struct fsl_espi_reg *reg_base;
-	u32 regval;
 	int ret;
 
-	mpc8xxx_spi = spi_master_get_devdata(master);
-	reg_base = mpc8xxx_spi->reg_base;
-
 	ret = spi_master_suspend(master);
 	if (ret) {
 		dev_warn(dev, "cannot suspend master\n");
 		return ret;
 	}
 
-	regval = mpc8xxx_spi_read_reg(&reg_base->mode);
-	regval &= ~SPMODE_ENABLE;
-	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
-
-	return 0;
+	return fsl_espi_suspend(master);
 }
 
 static int of_fsl_espi_resume(struct device *dev)

commit c592becbe704127ef0b89233ff7f285637491154
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Dec 3 07:56:17 2014 +0100

    spi: fsl-(e)spi: migrate to generic master queueing
    
    Migrates the fsl-(e)spi driver to use the generic master queuing.
    Avoids the "master is unqueued, this is deprecated" warning.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index a7f94b6a9e70..90be6405e789 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -411,7 +411,8 @@ static void fsl_espi_rw_trans(struct spi_message *m,
 	kfree(local_buf);
 }
 
-static void fsl_espi_do_one_msg(struct spi_message *m)
+static int fsl_espi_do_one_msg(struct spi_master *master,
+			       struct spi_message *m)
 {
 	struct spi_transfer *t;
 	u8 *rx_buf = NULL;
@@ -441,8 +442,8 @@ static void fsl_espi_do_one_msg(struct spi_message *m)
 
 	m->actual_length = espi_trans.actual_length;
 	m->status = espi_trans.status;
-	if (m->complete)
-		m->complete(m->context);
+	spi_finalize_current_message(master);
+	return 0;
 }
 
 static int fsl_espi_setup(struct spi_device *spi)
@@ -607,16 +608,14 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 
 	dev_set_drvdata(dev, master);
 
-	ret = mpc8xxx_spi_probe(dev, mem, irq);
-	if (ret)
-		goto err_probe;
+	mpc8xxx_spi_probe(dev, mem, irq);
 
 	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);
 	master->setup = fsl_espi_setup;
 	master->cleanup = fsl_espi_cleanup;
+	master->transfer_one_message = fsl_espi_do_one_msg;
 
 	mpc8xxx_spi = spi_master_get_devdata(master);
-	mpc8xxx_spi->spi_do_one_msg = fsl_espi_do_one_msg;
 	mpc8xxx_spi->spi_remove = fsl_espi_remove;
 
 	mpc8xxx_spi->reg_base = ioremap(mem->start, resource_size(mem));

commit 14ac00e033c57983032993d3b7b3f70b16a9fdbd
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:36 2014 +0200

    spi: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index a7f94b6a9e70..cff2ebd97463 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -827,7 +827,6 @@ MODULE_DEVICE_TABLE(of, of_fsl_espi_match);
 static struct platform_driver fsl_espi_driver = {
 	.driver = {
 		.name = "fsl_espi",
-		.owner = THIS_MODULE,
 		.of_match_table = of_fsl_espi_match,
 		.pm = &espi_pm,
 	},

commit 7020d7697178afbb3fe579edb99afb05211e4bf1
Merge: 1fc845031309 365a7bb32e09 2be01d29f855 f7477c2be868 a31083600476
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Oct 3 16:33:39 2014 +0100

    Merge remote-tracking branches 'spi/topic/davinci', 'spi/topic/doc', 'spi/topic/dw' and 'spi/topic/fsl' into spi-next

commit a31083600476ac11b656bbc70784767f231469ff
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Mon Sep 29 10:57:06 2014 +0800

    spi: fsl: Sort include headers alphabetically
    
    Sort all the include headers alphabetically for the freescale
    spi drivers. If the inlcude headers sorted out of order, maybe
    the best logical choice is to append new ones after the exist
    ones, while this may create a lot of potential for duplicates
    and conflicts for each diffenent changes will add new headers
    in the same location.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 8ebd724e4c59..68b4254069c0 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -8,19 +8,19 @@
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
  */
-#include <linux/module.h>
 #include <linux/delay.h>
-#include <linux/irq.h>
-#include <linux/spi/spi.h>
-#include <linux/platform_device.h>
+#include <linux/err.h>
 #include <linux/fsl_devices.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/module.h>
 #include <linux/mm.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
 #include <linux/of_platform.h>
-#include <linux/interrupt.h>
-#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
 #include <sysdev/fsl_soc.h>
 
 #include "spi-fsl-lib.h"

commit d9f26748128c73ec6bed2846ca52fb1c2edc3ced
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sun Aug 31 12:44:09 2014 +0800

    spi: fsl: Don't use devm_kzalloc in master->setup callback
    
    device_add() expects that any memory allocated via devm_* API is only
    done in the device's probe function.
    
    Fix below boot warning:
    [    3.092348] WARNING: at drivers/base/dd.c:286
    [    3.096637] Modules linked in:
    [    3.099697] CPU: 0 PID: 25 Comm: kworker/u2:1 Tainted: G W 3.16.1-s3k-drv-999-svn5771_knld-999 #158
    [ 3.109610] Workqueue: deferwq deferred_probe_work_func
    [    3.114736] task: c787f020 ti: c790c000 task.ti: c790c000
    [    3.120062] NIP: c01df158 LR: c01df144 CTR: 00000000
    [    3.124983] REGS: c790db30 TRAP: 0700   Tainted: G        W (3.16.1-s3k-drv-999-svn5771_knld-999)
    [    3.134162] MSR: 00029032 <EE,ME,IR,DR,RI>  CR: 22002082 XER: 20000000
    [    3.140703]
    [    3.140703] GPR00: 00000001 c790dbe0 c787f020 00000044 00000054 00000308 c056da0e 20737069
    [    3.140703] GPR08: 33323736 000ebfe0 00000308 000ebfdf 22002082 00000000 c046c5a0 c046c608
    [    3.140703] GPR16: c046c614 c046c620 c046c62c c046c638 c046c648 c046c654 c046c68c c046c6c4
    [    3.140703] GPR24: 00000000 00000000 00000003 c0401aa0 c0596638 c059662c c054e7a8 c7996800
    [    3.170102] NIP [c01df158] driver_probe_device+0xf8/0x334
    [    3.175431] LR [c01df144] driver_probe_device+0xe4/0x334
    [    3.180633] Call Trace:
    [    3.183093] [c790dbe0] [c01df144] driver_probe_device+0xe4/0x334 (unreliable)
    [    3.190147] [c790dc10] [c01dd15c] bus_for_each_drv+0x7c/0xc0
    [    3.195741] [c790dc40] [c01df5fc] device_attach+0xcc/0xf8
    [    3.201076] [c790dc60] [c01dd6d4] bus_probe_device+0xb4/0xc4
    [    3.206666] [c790dc80] [c01db9f8] device_add+0x270/0x564
    [    3.211923] [c790dcc0] [c0219e84] spi_add_device+0xc0/0x190
    [    3.217427] [c790dce0] [c021a79c] spi_register_master+0x720/0x834
    [    3.223455] [c790dd40] [c021cb48] of_fsl_spi_probe+0x55c/0x614
    [    3.229234] [c790dda0] [c01e0d2c] platform_drv_probe+0x30/0x74
    [    3.234987] [c790ddb0] [c01df18c] driver_probe_device+0x12c/0x334
    [    3.241008] [c790dde0] [c01dd15c] bus_for_each_drv+0x7c/0xc0
    [    3.246602] [c790de10] [c01df5fc] device_attach+0xcc/0xf8
    [    3.251937] [c790de30] [c01dd6d4] bus_probe_device+0xb4/0xc4
    [    3.257536] [c790de50] [c01de9d8] deferred_probe_work_func+0x98/0xe0
    [    3.263816] [c790de70] [c00305b8] process_one_work+0x18c/0x440
    [    3.269577] [c790dea0] [c0030a00] worker_thread+0x194/0x67c
    [    3.275105] [c790def0] [c0039198] kthread+0xd0/0xe4
    [    3.279911] [c790df40] [c000c6d0] ret_from_kernel_thread+0x5c/0x64
    [    3.285970] Instruction dump:
    [    3.288900] 80de0000 419e01d0 3b7b0038 3c60c046 7f65db78 38635264 48211b99 813f00a0
    [    3.296559] 381f00a0 7d290278 3169ffff 7c0b4910 <0f000000> 93df0044 7fe3fb78 4bfffd4d
    
    Reported-by: leroy christophe <christophe.leroy@c-s.fr>
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Tested-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 8ebd724e4c59..429e11190265 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -452,16 +452,16 @@ static int fsl_espi_setup(struct spi_device *spi)
 	int retval;
 	u32 hw_mode;
 	u32 loop_mode;
-	struct spi_mpc8xxx_cs *cs = spi->controller_state;
+	struct spi_mpc8xxx_cs *cs = spi_get_ctldata(spi);
 
 	if (!spi->max_speed_hz)
 		return -EINVAL;
 
 	if (!cs) {
-		cs = devm_kzalloc(&spi->dev, sizeof(*cs), GFP_KERNEL);
+		cs = kzalloc(sizeof(*cs), GFP_KERNEL);
 		if (!cs)
 			return -ENOMEM;
-		spi->controller_state = cs;
+		spi_set_ctldata(spi, cs);
 	}
 
 	mpc8xxx_spi = spi_master_get_devdata(spi->master);
@@ -496,6 +496,14 @@ static int fsl_espi_setup(struct spi_device *spi)
 	return 0;
 }
 
+static void fsl_espi_cleanup(struct spi_device *spi)
+{
+	struct spi_mpc8xxx_cs *cs = spi_get_ctldata(spi);
+
+	kfree(cs);
+	spi_set_ctldata(spi, NULL);
+}
+
 void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 {
 	struct fsl_espi_reg *reg_base = mspi->reg_base;
@@ -605,6 +613,7 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 
 	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);
 	master->setup = fsl_espi_setup;
+	master->cleanup = fsl_espi_cleanup;
 
 	mpc8xxx_spi = spi_master_get_devdata(master);
 	mpc8xxx_spi->spi_do_one_msg = fsl_espi_do_one_msg;

commit 8fb3b066a60ec1e39dc2f91eb87e91f434e4da81
Merge: 446fe5e2d561 bf61fb805ce8 7a4005436116 a2cb1be18254 b2fb1872d3d9
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Jun 2 17:08:38 2014 +0100

    Merge remote-tracking branches 'spi/topic/dw', 'spi/topic/fsl', 'spi/topic/fsl-espi' and 'spi/topic/id-const' into spi-next

commit a2cb1be18254fd1479d87f7860af7a8413508e16
Author: Valentin Longchamp <valentin.longchamp@keymile.com>
Date:   Fri May 16 16:46:21 2014 +0200

    spi/fsl-espi: fix rx_buf in fsl_espi_cmd_trans()/fsl_espi_rw_trans()
    
    By default for every espi transfer, the rx_buf is placed right after the
    tx_buf. This can lead to a buffer overflow when the size of both the TX
    and RX data cumulated is higher than the allocated 64K buffer for the
    transfer (this is the case when sending for instance a read command and
    reading 64K back, please see:
    http://article.gmane.org/gmane.linux.drivers.mtd/53411 )
    
    This gets fixed by always setting the RX buffer pointer at the begining
    of the transfer buffer.
    
    [The driver shouldn't be doing the copy in the first place and instead
    sending directly from the supplied buffer but this is at least not worse
    than what's there -- broonie]
    
    Signed-off-by: Valentin Longchamp <valentin.longchamp@keymile.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 24096c84e9c4..f0d7662e4d45 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -348,7 +348,7 @@ static void fsl_espi_cmd_trans(struct spi_message *m,
 	}
 
 	espi_trans->tx_buf = local_buf;
-	espi_trans->rx_buf = local_buf + espi_trans->n_tx;
+	espi_trans->rx_buf = local_buf;
 	fsl_espi_do_trans(m, espi_trans);
 
 	espi_trans->actual_length = espi_trans->len;
@@ -397,7 +397,7 @@ static void fsl_espi_rw_trans(struct spi_message *m,
 		espi_trans->n_rx = trans_len;
 		espi_trans->len = trans_len + n_tx;
 		espi_trans->tx_buf = local_buf;
-		espi_trans->rx_buf = local_buf + n_tx;
+		espi_trans->rx_buf = local_buf;
 		fsl_espi_do_trans(m, espi_trans);
 
 		memcpy(rx_buf + pos, espi_trans->rx_buf + n_tx, trans_len);

commit d0fb47a5237d8b9576113568bacfd27892308b62
Author: Jane Wan <Jane.Wan@gainspeed.com>
Date:   Wed Apr 16 13:09:39 2014 -0700

    spi: fsl-espi: Configure FSL eSPI CSBEF and CSAFT
    
    Make FSL eSPI CSnBEF and CSnAFT fields in ESPI_SPMODEn registers
    (n=0,1,2,3) configurable through device tree.
    
    CSnBEF is the chip select setup time.  It's the delay in bits from the
    activation of chip select pin to the first clock for data frame.
    
    CSnAFT is the chip select hold time.  It's the delay in bits from the
    last clock for data frame to the deactivation of chip select pin.
    
    The FSL eSPI driver hardcodes CSnBEF and CSnAFT to 0.  Need to set
    them to a different value for some device.
    
    Signed-off-by: Jane Wan <Jane.Wan@gainspeed.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index e767f5831b9c..24096c84e9c4 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -586,8 +586,10 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 	struct spi_master *master;
 	struct mpc8xxx_spi *mpc8xxx_spi;
 	struct fsl_espi_reg *reg_base;
-	u32 regval;
-	int i, ret = 0;
+	struct device_node *nc;
+	const __be32 *prop;
+	u32 regval, csmode;
+	int i, len, ret = 0;
 
 	master = spi_alloc_master(dev, sizeof(struct mpc8xxx_spi));
 	if (!master) {
@@ -634,8 +636,32 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 	mpc8xxx_spi_write_reg(&reg_base->event, 0xffffffff);
 
 	/* Init eSPI CS mode register */
-	for (i = 0; i < pdata->max_chipselect; i++)
-		mpc8xxx_spi_write_reg(&reg_base->csmode[i], CSMODE_INIT_VAL);
+	for_each_available_child_of_node(master->dev.of_node, nc) {
+		/* get chip select */
+		prop = of_get_property(nc, "reg", &len);
+		if (!prop || len < sizeof(*prop))
+			continue;
+		i = be32_to_cpup(prop);
+		if (i < 0 || i >= pdata->max_chipselect)
+			continue;
+
+		csmode = CSMODE_INIT_VAL;
+		/* check if CSBEF is set in device tree */
+		prop = of_get_property(nc, "fsl,csbef", &len);
+		if (prop && len >= sizeof(*prop)) {
+			csmode &= ~(CSMODE_BEF(0xf));
+			csmode |= CSMODE_BEF(be32_to_cpup(prop));
+		}
+		/* check if CSAFT is set in device tree */
+		prop = of_get_property(nc, "fsl,csaft", &len);
+		if (prop && len >= sizeof(*prop)) {
+			csmode &= ~(CSMODE_AFT(0xf));
+			csmode |= CSMODE_AFT(be32_to_cpup(prop));
+		}
+		mpc8xxx_spi_write_reg(&reg_base->csmode[i], csmode);
+
+		dev_info(dev, "cs=%d, init_csmode=0x%x\n", i, csmode);
+	}
 
 	/* Enable SPI interface */
 	regval = pdata->initial_spmode | SPMODE_INIT_VAL | SPMODE_ENABLE;

commit abcadeb255074d1351d110ef696b647859fa3d5b
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sun Mar 30 16:43:23 2014 +0800

    spi: fsl: Kill mpc8xxx_spi_cleanup and convert fsl_espi_setup to use devm_kzalloc
    
    In current code, master->cleanup and master->setup are not set in the same
    function. This makes it hard to read and not good for code maintain.
    One example is in fsl-spi.c, master->cleanup is overrided in mpc8xxx_spi_probe()
    which leads to a memory leak.
    
    This patch removes mpc8xxx_spi_cleanup() and converts fsl_espi_setup to use
    devm_kzalloc so we don't need to take care of freeing memory.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index e767f5831b9c..3cf7d65bc739 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -458,7 +458,7 @@ static int fsl_espi_setup(struct spi_device *spi)
 		return -EINVAL;
 
 	if (!cs) {
-		cs = kzalloc(sizeof *cs, GFP_KERNEL);
+		cs = devm_kzalloc(&spi->dev, sizeof(*cs), GFP_KERNEL);
 		if (!cs)
 			return -ENOMEM;
 		spi->controller_state = cs;

commit 6eadd8463101830d50e381185701d58f4ac3abb9
Merge: 09c0998efcb4 0a6d38795a40 e2872090ca82 a6f936db640f 058f11c85126
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Apr 10 23:39:52 2014 +0100

    Merge remote-tracking branches 'spi/fix/complete', 'spi/fix/efm32', 'spi/fix/omap2-mcspi' and 'spi/fix/qup' into spi-linus

commit 0a6d38795a405c49ea0012f04173613382def58c
Author: Axel Lin <axel.lin@ingics.com>
Date:   Wed Apr 2 22:21:04 2014 +0800

    spi: Always check complete callback before calling it
    
    Since commit 1e25cd4729bd "spi: Do not require a completion", this checking is
    required to prevent NULL pointer dereference.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 428dc7a6b62e..e8e3d34bab07 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -446,7 +446,8 @@ static void fsl_espi_do_one_msg(struct spi_message *m)
 
 	m->actual_length = espi_trans.actual_length;
 	m->status = espi_trans.status;
-	m->complete(m->context);
+	if (m->complete)
+		m->complete(m->context);
 }
 
 static int fsl_espi_setup(struct spi_device *spi)

commit f0a71337be7f19cc929aabfffc3ecd4c056df03a
Author: Axel Lin <axel.lin@ingics.com>
Date:   Fri Mar 21 22:59:58 2014 +0800

    spi: fsl-espi: Remove unused bits_per_word variable in fsl_espi_bufs
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 428dc7a6b62e..6fb2b75df821 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -219,13 +219,8 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
 	struct fsl_espi_reg *reg_base = mpc8xxx_spi->reg_base;
 	unsigned int len = t->len;
-	u8 bits_per_word;
 	int ret;
 
-	bits_per_word = spi->bits_per_word;
-	if (t->bits_per_word)
-		bits_per_word = t->bits_per_word;
-
 	mpc8xxx_spi->len = t->len;
 	len = roundup(len, 4) / 4;
 

commit 714bb654e97535c4bed4a8da0628cbc842dc8e31
Author: Hou Zhiqiang <b48286@freescale.com>
Date:   Thu Dec 12 12:53:52 2013 +0800

    spi/fsl-espi: Add Power Management support for eSPI controller
    
    Add PM support for eSPI controller using callback function suspend
    and resume in .driver.pm of platform_driver.
    
    Signed-off-by: Hou Zhiqiang <b48286@freescale.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 8106006cdc39..428dc7a6b62e 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -727,6 +727,66 @@ static int of_fsl_espi_remove(struct platform_device *dev)
 	return mpc8xxx_spi_remove(&dev->dev);
 }
 
+#ifdef CONFIG_PM_SLEEP
+static int of_fsl_espi_suspend(struct device *dev)
+{
+	struct spi_master *master = dev_get_drvdata(dev);
+	struct mpc8xxx_spi *mpc8xxx_spi;
+	struct fsl_espi_reg *reg_base;
+	u32 regval;
+	int ret;
+
+	mpc8xxx_spi = spi_master_get_devdata(master);
+	reg_base = mpc8xxx_spi->reg_base;
+
+	ret = spi_master_suspend(master);
+	if (ret) {
+		dev_warn(dev, "cannot suspend master\n");
+		return ret;
+	}
+
+	regval = mpc8xxx_spi_read_reg(&reg_base->mode);
+	regval &= ~SPMODE_ENABLE;
+	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
+
+	return 0;
+}
+
+static int of_fsl_espi_resume(struct device *dev)
+{
+	struct fsl_spi_platform_data *pdata = dev_get_platdata(dev);
+	struct spi_master *master = dev_get_drvdata(dev);
+	struct mpc8xxx_spi *mpc8xxx_spi;
+	struct fsl_espi_reg *reg_base;
+	u32 regval;
+	int i;
+
+	mpc8xxx_spi = spi_master_get_devdata(master);
+	reg_base = mpc8xxx_spi->reg_base;
+
+	/* SPI controller initializations */
+	mpc8xxx_spi_write_reg(&reg_base->mode, 0);
+	mpc8xxx_spi_write_reg(&reg_base->mask, 0);
+	mpc8xxx_spi_write_reg(&reg_base->command, 0);
+	mpc8xxx_spi_write_reg(&reg_base->event, 0xffffffff);
+
+	/* Init eSPI CS mode register */
+	for (i = 0; i < pdata->max_chipselect; i++)
+		mpc8xxx_spi_write_reg(&reg_base->csmode[i], CSMODE_INIT_VAL);
+
+	/* Enable SPI interface */
+	regval = pdata->initial_spmode | SPMODE_INIT_VAL | SPMODE_ENABLE;
+
+	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
+
+	return spi_master_resume(master);
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static const struct dev_pm_ops espi_pm = {
+	SET_SYSTEM_SLEEP_PM_OPS(of_fsl_espi_suspend, of_fsl_espi_resume)
+};
+
 static const struct of_device_id of_fsl_espi_match[] = {
 	{ .compatible = "fsl,mpc8536-espi" },
 	{}
@@ -738,6 +798,7 @@ static struct platform_driver fsl_espi_driver = {
 		.name = "fsl_espi",
 		.owner = THIS_MODULE,
 		.of_match_table = of_fsl_espi_match,
+		.pm = &espi_pm,
 	},
 	.probe		= of_fsl_espi_probe,
 	.remove		= of_fsl_espi_remove,

commit 7227cd18934276eb6d7cf758f79f8c6feacdc421
Author: Hou Zhiqiang <b48286@freescale.com>
Date:   Wed Dec 11 13:09:40 2013 +0800

    spi/fsl-espi: fix the return value judgment of irq_of_parse_and_map.
    
    Signed-off-by: Hou Zhiqiang <b48286@freescale.com>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 80d8f40f7e05..8106006cdc39 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -705,7 +705,7 @@ static int of_fsl_espi_probe(struct platform_device *ofdev)
 		goto err;
 
 	irq = irq_of_parse_and_map(np, 0);
-	if (!ret) {
+	if (!irq) {
 		ret = -EINVAL;
 		goto err;
 	}

commit 16735d022f72b20ddbb2274b8e109f69575e9b2b
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Thu Nov 14 14:32:02 2013 -0800

    tree-wide: use reinit_completion instead of INIT_COMPLETION
    
    Use this new function to make code more comprehensible, since we are
    reinitialzing the completion, not initializing.
    
    [akpm@linux-foundation.org: linux-next resyncs]
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Linus Walleij <linus.walleij@linaro.org> (personally at LCE13)
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 32200d4f8780..80d8f40f7e05 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -232,7 +232,7 @@ static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
 	mpc8xxx_spi->tx = t->tx_buf;
 	mpc8xxx_spi->rx = t->rx_buf;
 
-	INIT_COMPLETION(mpc8xxx_spi->done);
+	reinit_completion(&mpc8xxx_spi->done);
 
 	/* Set SPCOM[CS] and SPCOM[TRANLEN] field */
 	if ((t->len - 1) > SPCOM_TRANLEN_MAX) {

commit 10d0c9705e80bbd3d587c5fad24599aabaca6688
Merge: 85b656cf1560 c11eede69b6a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Nov 12 16:52:17 2013 +0900

    Merge tag 'devicetree-for-3.13' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux
    
    Pull devicetree updates from Rob Herring:
     "DeviceTree updates for 3.13.  This is a bit larger pull request than
      usual for this cycle with lots of clean-up.
    
       - Cross arch clean-up and consolidation of early DT scanning code.
       - Clean-up and removal of arch prom.h headers.  Makes arch specific
         prom.h optional on all but Sparc.
       - Addition of interrupts-extended property for devices connected to
         multiple interrupt controllers.
       - Refactoring of DT interrupt parsing code in preparation for
         deferred probe of interrupts.
       - ARM cpu and cpu topology bindings documentation.
       - Various DT vendor binding documentation updates"
    
    * tag 'devicetree-for-3.13' of git://git.kernel.org/pub/scm/linux/kernel/git/robh/linux: (82 commits)
      powerpc: add missing explicit OF includes for ppc
      dt/irq: add empty of_irq_count for !OF_IRQ
      dt: disable self-tests for !OF_IRQ
      of: irq: Fix interrupt-map entry matching
      MIPS: Netlogic: replace early_init_devtree() call
      of: Add Panasonic Corporation vendor prefix
      of: Add Chunghwa Picture Tubes Ltd. vendor prefix
      of: Add AU Optronics Corporation vendor prefix
      of/irq: Fix potential buffer overflow
      of/irq: Fix bug in interrupt parsing refactor.
      of: set dma_mask to point to coherent_dma_mask
      of: add vendor prefix for PHYTEC Messtechnik GmbH
      DT: sort vendor-prefixes.txt
      of: Add vendor prefix for Cadence
      of: Add empty for_each_available_child_of_node() macro definition
      arm/versatile: Fix versatile irq specifications.
      of/irq: create interrupts-extended property
      microblaze/pci: Drop PowerPC-ism from irq parsing
      of/irq: Create of_irq_parse_and_map_pci() to consolidate arch code.
      of/irq: Use irq_of_parse_and_map()
      ...

commit b5480950c6cbb7b07ab1c1a5af0dc661a1cb6f24
Merge: e363bbac316f 355e62f5ad12
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Thu Nov 7 10:34:46 2013 -0600

    Merge remote-tracking branch 'grant/devicetree/next' into for-next

commit f7578496a671a96e501f16a5104893275e32c33a
Author: Thierry Reding <thierry.reding@gmail.com>
Date:   Wed Sep 18 15:24:44 2013 +0200

    of/irq: Use irq_of_parse_and_map()
    
    Replace some instances of of_irq_map_one()/irq_create_of_mapping() and
    of_irq_to_resource() by the simpler equivalent irq_of_parse_and_map().
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    [grant.likely: resolved conflicts with core code renames]
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index b8f1103fe28e..3197d55f30cd 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -687,7 +687,7 @@ static int of_fsl_espi_probe(struct platform_device *ofdev)
 	struct device_node *np = ofdev->dev.of_node;
 	struct spi_master *master;
 	struct resource mem;
-	struct resource irq;
+	unsigned int irq;
 	int ret = -ENOMEM;
 
 	ret = of_mpc8xxx_spi_probe(ofdev);
@@ -702,13 +702,13 @@ static int of_fsl_espi_probe(struct platform_device *ofdev)
 	if (ret)
 		goto err;
 
-	ret = of_irq_to_resource(np, 0, &irq);
+	irq = irq_of_parse_and_map(np, 0);
 	if (!ret) {
 		ret = -EINVAL;
 		goto err;
 	}
 
-	master = fsl_espi_probe(dev, &mem, irq.start);
+	master = fsl_espi_probe(dev, &mem, irq);
 	if (IS_ERR(master)) {
 		ret = PTR_ERR(master);
 		goto err;

commit f6bd03a746271f298aa5bfb6e049b245757efaed
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri Oct 11 13:54:00 2013 +0300

    spi: Don't break user-visible strings to multiple source lines in drivers
    
    User-visible strings are more difficult to grep from sources if they are
    separated to multiple source lines. This is worse than over 80 columns long
    line code style violation.
    
    Fix this by making those to single-line strings or by breaking them between
    variables.
    
    While at there, convert if (printk_ratelimit()) dev_warn() to use
    dev_warn_ratelimited in spi-pxa2xx.c.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index b8f1103fe28e..43222d7532d1 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -289,8 +289,8 @@ static void fsl_espi_do_trans(struct spi_message *m,
 		if ((first->bits_per_word != t->bits_per_word) ||
 			(first->speed_hz != t->speed_hz)) {
 			espi_trans->status = -EINVAL;
-			dev_err(mspi->dev, "bits_per_word/speed_hz should be"
-					" same for the same SPI transfer\n");
+			dev_err(mspi->dev,
+				"bits_per_word/speed_hz should be same for the same SPI transfer\n");
 			return;
 		}
 

commit 5af5073004071cedd0343eee51d77955037ec6f3
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Tue Sep 17 14:28:33 2013 -0500

    drivers: clean-up prom.h implicit includes
    
    Powerpc is a mess of implicit includes by prom.h. Add the necessary
    explicit includes to drivers in preparation of prom.h cleanup.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index b8f1103fe28e..c1c936cf0ed4 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -16,6 +16,8 @@
 #include <linux/fsl_devices.h>
 #include <linux/mm.h>
 #include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
 #include <linux/of_platform.h>
 #include <linux/interrupt.h>
 #include <linux/err.h>

commit 8074cf063e410a2c0cf1704c3b31002e21f5df7c
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Jul 30 16:58:59 2013 +0900

    spi: use dev_get_platdata()
    
    Use the wrapper function for retrieving the platform data instead of
    accessing dev->platform_data directly.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 6a74d7848d93..b8f1103fe28e 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -584,7 +584,7 @@ static void fsl_espi_remove(struct mpc8xxx_spi *mspi)
 static struct spi_master * fsl_espi_probe(struct device *dev,
 		struct resource *mem, unsigned int irq)
 {
-	struct fsl_spi_platform_data *pdata = dev->platform_data;
+	struct fsl_spi_platform_data *pdata = dev_get_platdata(dev);
 	struct spi_master *master;
 	struct mpc8xxx_spi *mpc8xxx_spi;
 	struct fsl_espi_reg *reg_base;
@@ -665,7 +665,7 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 static int of_fsl_espi_get_chipselects(struct device *dev)
 {
 	struct device_node *np = dev->of_node;
-	struct fsl_spi_platform_data *pdata = dev->platform_data;
+	struct fsl_spi_platform_data *pdata = dev_get_platdata(dev);
 	const u32 *prop;
 	int len;
 

commit 51faed692b6a76870b53415307be54b39b5d4016
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu May 30 09:59:41 2013 -0600

    spi: fix build break in spi-fsl-espi.c
    
    Fix a build error introduced by 24778be "spi: convert drivers to use
    bits_per_word_mask":
    
    drivers/spi/spi-fsl-espi.c:162:13: error: expected '=', ',', ';', 'asm' or '__attribute__' before '->' token
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 0ef05f198f22..6a74d7848d93 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -153,7 +153,7 @@ static int fsl_espi_setup_transfer(struct spi_device *spi,
 	cs->get_tx = mpc8xxx_spi_tx_buf_u32;
 	if (bits_per_word <= 8) {
 		cs->rx_shift = 8 - bits_per_word;
-	} else
+	} else {
 		cs->rx_shift = 16 - bits_per_word;
 		if (spi->mode & SPI_LSB_FIRST)
 			cs->get_tx = fsl_espi_tx_buf_lsb;

commit 24778be20f87d5aadb19624fc768b3159fa43efc
Author: Stephen Warren <swarren@wwwdotorg.org>
Date:   Tue May 21 20:36:35 2013 -0600

    spi: convert drivers to use bits_per_word_mask
    
    Fill in the recently added spi_master.bits_per_word_mask field in as
    many drivers as possible. Make related cleanups, such as removing any
    redundant error-checking, or empty setup callbacks.
    
    Signed-off-by: Stephen Warren <swarren@wwwdotorg.org>
    Acked-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 24610ca8955d..0ef05f198f22 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -144,10 +144,6 @@ static int fsl_espi_setup_transfer(struct spi_device *spi,
 	if (!bits_per_word)
 		bits_per_word = spi->bits_per_word;
 
-	/* Make sure its a bit width we support [4..16] */
-	if ((bits_per_word < 4) || (bits_per_word > 16))
-		return -EINVAL;
-
 	if (!hz)
 		hz = spi->max_speed_hz;
 
@@ -157,12 +153,10 @@ static int fsl_espi_setup_transfer(struct spi_device *spi,
 	cs->get_tx = mpc8xxx_spi_tx_buf_u32;
 	if (bits_per_word <= 8) {
 		cs->rx_shift = 8 - bits_per_word;
-	} else if (bits_per_word <= 16) {
+	} else
 		cs->rx_shift = 16 - bits_per_word;
 		if (spi->mode & SPI_LSB_FIRST)
 			cs->get_tx = fsl_espi_tx_buf_lsb;
-	} else {
-		return -EINVAL;
 	}
 
 	mpc8xxx_spi->rx_shift = cs->rx_shift;
@@ -609,6 +603,7 @@ static struct spi_master * fsl_espi_probe(struct device *dev,
 	if (ret)
 		goto err_probe;
 
+	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);
 	master->setup = fsl_espi_setup;
 
 	mpc8xxx_spi = spi_master_get_devdata(master);

commit fd4a319bc933ae93e68935b21924a9ca4ba2d060
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Dec 7 16:57:14 2012 +0000

    spi: Remove HOTPLUG section attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Bill Pemberton has done most of the legwork on this series. I've used
    his script to purge the attributes from the drivers/gpio tree.
    
    Reported-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 27bdc47b5250..24610ca8955d 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -587,7 +587,7 @@ static void fsl_espi_remove(struct mpc8xxx_spi *mspi)
 	iounmap(mspi->reg_base);
 }
 
-static struct spi_master * __devinit fsl_espi_probe(struct device *dev,
+static struct spi_master * fsl_espi_probe(struct device *dev,
 		struct resource *mem, unsigned int irq)
 {
 	struct fsl_spi_platform_data *pdata = dev->platform_data;
@@ -686,7 +686,7 @@ static int of_fsl_espi_get_chipselects(struct device *dev)
 	return 0;
 }
 
-static int __devinit of_fsl_espi_probe(struct platform_device *ofdev)
+static int of_fsl_espi_probe(struct platform_device *ofdev)
 {
 	struct device *dev = &ofdev->dev;
 	struct device_node *np = ofdev->dev.of_node;
@@ -725,7 +725,7 @@ static int __devinit of_fsl_espi_probe(struct platform_device *ofdev)
 	return ret;
 }
 
-static int __devexit of_fsl_espi_remove(struct platform_device *dev)
+static int of_fsl_espi_remove(struct platform_device *dev)
 {
 	return mpc8xxx_spi_remove(&dev->dev);
 }
@@ -743,7 +743,7 @@ static struct platform_driver fsl_espi_driver = {
 		.of_match_table = of_fsl_espi_match,
 	},
 	.probe		= of_fsl_espi_probe,
-	.remove		= __devexit_p(of_fsl_espi_remove),
+	.remove		= of_fsl_espi_remove,
 };
 module_platform_driver(fsl_espi_driver);
 

commit d57a4282d04810417c4ed2a49cbbeda8b3569b18
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Sat Apr 7 14:16:53 2012 -0600

    spi/devicetree: Move devicetree support code into spi directory
    
    The SPI device tree support code isn't shared by any other subsystem.  It can
    be moved into the core drivers/spi directory and the exported symbol can be
    removed.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 7523a2429d09..27bdc47b5250 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -17,7 +17,6 @@
 #include <linux/mm.h>
 #include <linux/of.h>
 #include <linux/of_platform.h>
-#include <linux/of_spi.h>
 #include <linux/interrupt.h>
 #include <linux/err.h>
 #include <sysdev/fsl_soc.h>

commit 87bf5ab82884c829366914aaa813cc8b07b9fe58
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Mar 15 18:42:32 2012 +0100

    spi/fsl-espi: Make sure pm is within 2..32
    
    The reference manual says that pm has to stay within 2 and 32. So the
    lowest frequency is 32 and DIV16 set, the highest is 2 and DIV16 unset.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 43350f999314..7523a2429d09 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -182,16 +182,18 @@ static int fsl_espi_setup_transfer(struct spi_device *spi,
 		cs->hw_mode |= CSMODE_DIV16;
 		pm = DIV_ROUND_UP(mpc8xxx_spi->spibrg, hz * 16 * 4);
 
-		WARN_ONCE(pm > 16, "%s: Requested speed is too low: %d Hz. "
+		WARN_ONCE(pm > 33, "%s: Requested speed is too low: %d Hz. "
 			  "Will use %d Hz instead.\n", dev_name(&spi->dev),
-			  hz, mpc8xxx_spi->spibrg / 1024);
-		if (pm > 16)
-			pm = 16;
+				hz, mpc8xxx_spi->spibrg / (4 * 16 * (32 + 1)));
+		if (pm > 33)
+			pm = 33;
 	} else {
 		pm = DIV_ROUND_UP(mpc8xxx_spi->spibrg, hz * 4);
 	}
 	if (pm)
 		pm--;
+	if (pm < 2)
+		pm = 2;
 
 	cs->hw_mode |= CSMODE_PM(pm);
 

commit 35faa55cff56441477973e454f62408714f35cd3
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Thu Mar 15 18:42:31 2012 +0100

    spi/fsl-espi: make the clock computation easier to read
    
    The -1 +1 thingy should probably do what DIV_ROUND_UP does. The 4 is 2
    the  "platform_clock => sysclock" and 2 from the computation part. The 64
    is the same 4 times 16.
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index d770f03705c3..43350f999314 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -180,7 +180,7 @@ static int fsl_espi_setup_transfer(struct spi_device *spi,
 
 	if ((mpc8xxx_spi->spibrg / hz) > 64) {
 		cs->hw_mode |= CSMODE_DIV16;
-		pm = (mpc8xxx_spi->spibrg - 1) / (hz * 64) + 1;
+		pm = DIV_ROUND_UP(mpc8xxx_spi->spibrg, hz * 16 * 4);
 
 		WARN_ONCE(pm > 16, "%s: Requested speed is too low: %d Hz. "
 			  "Will use %d Hz instead.\n", dev_name(&spi->dev),
@@ -188,7 +188,7 @@ static int fsl_espi_setup_transfer(struct spi_device *spi,
 		if (pm > 16)
 			pm = 16;
 	} else {
-		pm = (mpc8xxx_spi->spibrg - 1) / (hz * 4) + 1;
+		pm = DIV_ROUND_UP(mpc8xxx_spi->spibrg, hz * 4);
 	}
 	if (pm)
 		pm--;

commit 940ab88962bc1aff3273a8356d64577a6e386736
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed Oct 5 11:29:49 2011 -0600

    drivercore: Add helper macro for platform_driver boilerplate
    
    For simple modules that contain a single platform_driver without any
    additional setup code then ends up being a block of duplicated
    boilerplate.  This patch adds a new macro, module_platform_driver(),
    which replaces the module_init()/module_exit() registrations with
    template functions.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Reviewed-by: Magnus Damm <magnus.damm@gmail.com>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
index 54e499d5f92c..d770f03705c3 100644
--- a/drivers/spi/spi-fsl-espi.c
+++ b/drivers/spi/spi-fsl-espi.c
@@ -744,18 +744,7 @@ static struct platform_driver fsl_espi_driver = {
 	.probe		= of_fsl_espi_probe,
 	.remove		= __devexit_p(of_fsl_espi_remove),
 };
-
-static int __init fsl_espi_init(void)
-{
-	return platform_driver_register(&fsl_espi_driver);
-}
-module_init(fsl_espi_init);
-
-static void __exit fsl_espi_exit(void)
-{
-	platform_driver_unregister(&fsl_espi_driver);
-}
-module_exit(fsl_espi_exit);
+module_platform_driver(fsl_espi_driver);
 
 MODULE_AUTHOR("Mingkai Hu");
 MODULE_DESCRIPTION("Enhanced Freescale SPI Driver");

commit ca632f556697d45d67ed5cada7cedf3ddfe0db4b
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Jun 6 01:16:30 2011 -0600

    spi: reorganize drivers
    
    Sort the SPI makefile and enforce the naming convention spi_*.c for
    spi drivers.
    
    This change also rolls the contents of atmel_spi.h into the .c file
    since there is only one user of that particular include file.
    
    v2: - Use 'spi-' prefix instead of 'spi_' to match what seems to be
          be the predominant pattern for subsystem prefixes.
        - Clean up filenames in Kconfig and header comment blocks
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c
new file mode 100644
index 000000000000..54e499d5f92c
--- /dev/null
+++ b/drivers/spi/spi-fsl-espi.c
@@ -0,0 +1,762 @@
+/*
+ * Freescale eSPI controller driver.
+ *
+ * Copyright 2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/spi/spi.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/mm.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_spi.h>
+#include <linux/interrupt.h>
+#include <linux/err.h>
+#include <sysdev/fsl_soc.h>
+
+#include "spi-fsl-lib.h"
+
+/* eSPI Controller registers */
+struct fsl_espi_reg {
+	__be32 mode;		/* 0x000 - eSPI mode register */
+	__be32 event;		/* 0x004 - eSPI event register */
+	__be32 mask;		/* 0x008 - eSPI mask register */
+	__be32 command;		/* 0x00c - eSPI command register */
+	__be32 transmit;	/* 0x010 - eSPI transmit FIFO access register*/
+	__be32 receive;		/* 0x014 - eSPI receive FIFO access register*/
+	u8 res[8];		/* 0x018 - 0x01c reserved */
+	__be32 csmode[4];	/* 0x020 - 0x02c eSPI cs mode register */
+};
+
+struct fsl_espi_transfer {
+	const void *tx_buf;
+	void *rx_buf;
+	unsigned len;
+	unsigned n_tx;
+	unsigned n_rx;
+	unsigned actual_length;
+	int status;
+};
+
+/* eSPI Controller mode register definitions */
+#define SPMODE_ENABLE		(1 << 31)
+#define SPMODE_LOOP		(1 << 30)
+#define SPMODE_TXTHR(x)		((x) << 8)
+#define SPMODE_RXTHR(x)		((x) << 0)
+
+/* eSPI Controller CS mode register definitions */
+#define CSMODE_CI_INACTIVEHIGH	(1 << 31)
+#define CSMODE_CP_BEGIN_EDGECLK	(1 << 30)
+#define CSMODE_REV		(1 << 29)
+#define CSMODE_DIV16		(1 << 28)
+#define CSMODE_PM(x)		((x) << 24)
+#define CSMODE_POL_1		(1 << 20)
+#define CSMODE_LEN(x)		((x) << 16)
+#define CSMODE_BEF(x)		((x) << 12)
+#define CSMODE_AFT(x)		((x) << 8)
+#define CSMODE_CG(x)		((x) << 3)
+
+/* Default mode/csmode for eSPI controller */
+#define SPMODE_INIT_VAL (SPMODE_TXTHR(4) | SPMODE_RXTHR(3))
+#define CSMODE_INIT_VAL (CSMODE_POL_1 | CSMODE_BEF(0) \
+		| CSMODE_AFT(0) | CSMODE_CG(1))
+
+/* SPIE register values */
+#define	SPIE_NE		0x00000200	/* Not empty */
+#define	SPIE_NF		0x00000100	/* Not full */
+
+/* SPIM register values */
+#define	SPIM_NE		0x00000200	/* Not empty */
+#define	SPIM_NF		0x00000100	/* Not full */
+#define SPIE_RXCNT(reg)     ((reg >> 24) & 0x3F)
+#define SPIE_TXCNT(reg)     ((reg >> 16) & 0x3F)
+
+/* SPCOM register values */
+#define SPCOM_CS(x)		((x) << 30)
+#define SPCOM_TRANLEN(x)	((x) << 0)
+#define	SPCOM_TRANLEN_MAX	0xFFFF	/* Max transaction length */
+
+static void fsl_espi_change_mode(struct spi_device *spi)
+{
+	struct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);
+	struct spi_mpc8xxx_cs *cs = spi->controller_state;
+	struct fsl_espi_reg *reg_base = mspi->reg_base;
+	__be32 __iomem *mode = &reg_base->csmode[spi->chip_select];
+	__be32 __iomem *espi_mode = &reg_base->mode;
+	u32 tmp;
+	unsigned long flags;
+
+	/* Turn off IRQs locally to minimize time that SPI is disabled. */
+	local_irq_save(flags);
+
+	/* Turn off SPI unit prior changing mode */
+	tmp = mpc8xxx_spi_read_reg(espi_mode);
+	mpc8xxx_spi_write_reg(espi_mode, tmp & ~SPMODE_ENABLE);
+	mpc8xxx_spi_write_reg(mode, cs->hw_mode);
+	mpc8xxx_spi_write_reg(espi_mode, tmp);
+
+	local_irq_restore(flags);
+}
+
+static u32 fsl_espi_tx_buf_lsb(struct mpc8xxx_spi *mpc8xxx_spi)
+{
+	u32 data;
+	u16 data_h;
+	u16 data_l;
+	const u32 *tx = mpc8xxx_spi->tx;
+
+	if (!tx)
+		return 0;
+
+	data = *tx++ << mpc8xxx_spi->tx_shift;
+	data_l = data & 0xffff;
+	data_h = (data >> 16) & 0xffff;
+	swab16s(&data_l);
+	swab16s(&data_h);
+	data = data_h | data_l;
+
+	mpc8xxx_spi->tx = tx;
+	return data;
+}
+
+static int fsl_espi_setup_transfer(struct spi_device *spi,
+					struct spi_transfer *t)
+{
+	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
+	int bits_per_word = 0;
+	u8 pm;
+	u32 hz = 0;
+	struct spi_mpc8xxx_cs *cs = spi->controller_state;
+
+	if (t) {
+		bits_per_word = t->bits_per_word;
+		hz = t->speed_hz;
+	}
+
+	/* spi_transfer level calls that work per-word */
+	if (!bits_per_word)
+		bits_per_word = spi->bits_per_word;
+
+	/* Make sure its a bit width we support [4..16] */
+	if ((bits_per_word < 4) || (bits_per_word > 16))
+		return -EINVAL;
+
+	if (!hz)
+		hz = spi->max_speed_hz;
+
+	cs->rx_shift = 0;
+	cs->tx_shift = 0;
+	cs->get_rx = mpc8xxx_spi_rx_buf_u32;
+	cs->get_tx = mpc8xxx_spi_tx_buf_u32;
+	if (bits_per_word <= 8) {
+		cs->rx_shift = 8 - bits_per_word;
+	} else if (bits_per_word <= 16) {
+		cs->rx_shift = 16 - bits_per_word;
+		if (spi->mode & SPI_LSB_FIRST)
+			cs->get_tx = fsl_espi_tx_buf_lsb;
+	} else {
+		return -EINVAL;
+	}
+
+	mpc8xxx_spi->rx_shift = cs->rx_shift;
+	mpc8xxx_spi->tx_shift = cs->tx_shift;
+	mpc8xxx_spi->get_rx = cs->get_rx;
+	mpc8xxx_spi->get_tx = cs->get_tx;
+
+	bits_per_word = bits_per_word - 1;
+
+	/* mask out bits we are going to set */
+	cs->hw_mode &= ~(CSMODE_LEN(0xF) | CSMODE_DIV16 | CSMODE_PM(0xF));
+
+	cs->hw_mode |= CSMODE_LEN(bits_per_word);
+
+	if ((mpc8xxx_spi->spibrg / hz) > 64) {
+		cs->hw_mode |= CSMODE_DIV16;
+		pm = (mpc8xxx_spi->spibrg - 1) / (hz * 64) + 1;
+
+		WARN_ONCE(pm > 16, "%s: Requested speed is too low: %d Hz. "
+			  "Will use %d Hz instead.\n", dev_name(&spi->dev),
+			  hz, mpc8xxx_spi->spibrg / 1024);
+		if (pm > 16)
+			pm = 16;
+	} else {
+		pm = (mpc8xxx_spi->spibrg - 1) / (hz * 4) + 1;
+	}
+	if (pm)
+		pm--;
+
+	cs->hw_mode |= CSMODE_PM(pm);
+
+	fsl_espi_change_mode(spi);
+	return 0;
+}
+
+static int fsl_espi_cpu_bufs(struct mpc8xxx_spi *mspi, struct spi_transfer *t,
+		unsigned int len)
+{
+	u32 word;
+	struct fsl_espi_reg *reg_base = mspi->reg_base;
+
+	mspi->count = len;
+
+	/* enable rx ints */
+	mpc8xxx_spi_write_reg(&reg_base->mask, SPIM_NE);
+
+	/* transmit word */
+	word = mspi->get_tx(mspi);
+	mpc8xxx_spi_write_reg(&reg_base->transmit, word);
+
+	return 0;
+}
+
+static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);
+	struct fsl_espi_reg *reg_base = mpc8xxx_spi->reg_base;
+	unsigned int len = t->len;
+	u8 bits_per_word;
+	int ret;
+
+	bits_per_word = spi->bits_per_word;
+	if (t->bits_per_word)
+		bits_per_word = t->bits_per_word;
+
+	mpc8xxx_spi->len = t->len;
+	len = roundup(len, 4) / 4;
+
+	mpc8xxx_spi->tx = t->tx_buf;
+	mpc8xxx_spi->rx = t->rx_buf;
+
+	INIT_COMPLETION(mpc8xxx_spi->done);
+
+	/* Set SPCOM[CS] and SPCOM[TRANLEN] field */
+	if ((t->len - 1) > SPCOM_TRANLEN_MAX) {
+		dev_err(mpc8xxx_spi->dev, "Transaction length (%d)"
+				" beyond the SPCOM[TRANLEN] field\n", t->len);
+		return -EINVAL;
+	}
+	mpc8xxx_spi_write_reg(&reg_base->command,
+		(SPCOM_CS(spi->chip_select) | SPCOM_TRANLEN(t->len - 1)));
+
+	ret = fsl_espi_cpu_bufs(mpc8xxx_spi, t, len);
+	if (ret)
+		return ret;
+
+	wait_for_completion(&mpc8xxx_spi->done);
+
+	/* disable rx ints */
+	mpc8xxx_spi_write_reg(&reg_base->mask, 0);
+
+	return mpc8xxx_spi->count;
+}
+
+static inline void fsl_espi_addr2cmd(unsigned int addr, u8 *cmd)
+{
+	if (cmd) {
+		cmd[1] = (u8)(addr >> 16);
+		cmd[2] = (u8)(addr >> 8);
+		cmd[3] = (u8)(addr >> 0);
+	}
+}
+
+static inline unsigned int fsl_espi_cmd2addr(u8 *cmd)
+{
+	if (cmd)
+		return cmd[1] << 16 | cmd[2] << 8 | cmd[3] << 0;
+
+	return 0;
+}
+
+static void fsl_espi_do_trans(struct spi_message *m,
+				struct fsl_espi_transfer *tr)
+{
+	struct spi_device *spi = m->spi;
+	struct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);
+	struct fsl_espi_transfer *espi_trans = tr;
+	struct spi_message message;
+	struct spi_transfer *t, *first, trans;
+	int status = 0;
+
+	spi_message_init(&message);
+	memset(&trans, 0, sizeof(trans));
+
+	first = list_first_entry(&m->transfers, struct spi_transfer,
+			transfer_list);
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+		if ((first->bits_per_word != t->bits_per_word) ||
+			(first->speed_hz != t->speed_hz)) {
+			espi_trans->status = -EINVAL;
+			dev_err(mspi->dev, "bits_per_word/speed_hz should be"
+					" same for the same SPI transfer\n");
+			return;
+		}
+
+		trans.speed_hz = t->speed_hz;
+		trans.bits_per_word = t->bits_per_word;
+		trans.delay_usecs = max(first->delay_usecs, t->delay_usecs);
+	}
+
+	trans.len = espi_trans->len;
+	trans.tx_buf = espi_trans->tx_buf;
+	trans.rx_buf = espi_trans->rx_buf;
+	spi_message_add_tail(&trans, &message);
+
+	list_for_each_entry(t, &message.transfers, transfer_list) {
+		if (t->bits_per_word || t->speed_hz) {
+			status = -EINVAL;
+
+			status = fsl_espi_setup_transfer(spi, t);
+			if (status < 0)
+				break;
+		}
+
+		if (t->len)
+			status = fsl_espi_bufs(spi, t);
+
+		if (status) {
+			status = -EMSGSIZE;
+			break;
+		}
+
+		if (t->delay_usecs)
+			udelay(t->delay_usecs);
+	}
+
+	espi_trans->status = status;
+	fsl_espi_setup_transfer(spi, NULL);
+}
+
+static void fsl_espi_cmd_trans(struct spi_message *m,
+				struct fsl_espi_transfer *trans, u8 *rx_buff)
+{
+	struct spi_transfer *t;
+	u8 *local_buf;
+	int i = 0;
+	struct fsl_espi_transfer *espi_trans = trans;
+
+	local_buf = kzalloc(SPCOM_TRANLEN_MAX, GFP_KERNEL);
+	if (!local_buf) {
+		espi_trans->status = -ENOMEM;
+		return;
+	}
+
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+		if (t->tx_buf) {
+			memcpy(local_buf + i, t->tx_buf, t->len);
+			i += t->len;
+		}
+	}
+
+	espi_trans->tx_buf = local_buf;
+	espi_trans->rx_buf = local_buf + espi_trans->n_tx;
+	fsl_espi_do_trans(m, espi_trans);
+
+	espi_trans->actual_length = espi_trans->len;
+	kfree(local_buf);
+}
+
+static void fsl_espi_rw_trans(struct spi_message *m,
+				struct fsl_espi_transfer *trans, u8 *rx_buff)
+{
+	struct fsl_espi_transfer *espi_trans = trans;
+	unsigned int n_tx = espi_trans->n_tx;
+	unsigned int n_rx = espi_trans->n_rx;
+	struct spi_transfer *t;
+	u8 *local_buf;
+	u8 *rx_buf = rx_buff;
+	unsigned int trans_len;
+	unsigned int addr;
+	int i, pos, loop;
+
+	local_buf = kzalloc(SPCOM_TRANLEN_MAX, GFP_KERNEL);
+	if (!local_buf) {
+		espi_trans->status = -ENOMEM;
+		return;
+	}
+
+	for (pos = 0, loop = 0; pos < n_rx; pos += trans_len, loop++) {
+		trans_len = n_rx - pos;
+		if (trans_len > SPCOM_TRANLEN_MAX - n_tx)
+			trans_len = SPCOM_TRANLEN_MAX - n_tx;
+
+		i = 0;
+		list_for_each_entry(t, &m->transfers, transfer_list) {
+			if (t->tx_buf) {
+				memcpy(local_buf + i, t->tx_buf, t->len);
+				i += t->len;
+			}
+		}
+
+		if (pos > 0) {
+			addr = fsl_espi_cmd2addr(local_buf);
+			addr += pos;
+			fsl_espi_addr2cmd(addr, local_buf);
+		}
+
+		espi_trans->n_tx = n_tx;
+		espi_trans->n_rx = trans_len;
+		espi_trans->len = trans_len + n_tx;
+		espi_trans->tx_buf = local_buf;
+		espi_trans->rx_buf = local_buf + n_tx;
+		fsl_espi_do_trans(m, espi_trans);
+
+		memcpy(rx_buf + pos, espi_trans->rx_buf + n_tx, trans_len);
+
+		if (loop > 0)
+			espi_trans->actual_length += espi_trans->len - n_tx;
+		else
+			espi_trans->actual_length += espi_trans->len;
+	}
+
+	kfree(local_buf);
+}
+
+static void fsl_espi_do_one_msg(struct spi_message *m)
+{
+	struct spi_transfer *t;
+	u8 *rx_buf = NULL;
+	unsigned int n_tx = 0;
+	unsigned int n_rx = 0;
+	struct fsl_espi_transfer espi_trans;
+
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+		if (t->tx_buf)
+			n_tx += t->len;
+		if (t->rx_buf) {
+			n_rx += t->len;
+			rx_buf = t->rx_buf;
+		}
+	}
+
+	espi_trans.n_tx = n_tx;
+	espi_trans.n_rx = n_rx;
+	espi_trans.len = n_tx + n_rx;
+	espi_trans.actual_length = 0;
+	espi_trans.status = 0;
+
+	if (!rx_buf)
+		fsl_espi_cmd_trans(m, &espi_trans, NULL);
+	else
+		fsl_espi_rw_trans(m, &espi_trans, rx_buf);
+
+	m->actual_length = espi_trans.actual_length;
+	m->status = espi_trans.status;
+	m->complete(m->context);
+}
+
+static int fsl_espi_setup(struct spi_device *spi)
+{
+	struct mpc8xxx_spi *mpc8xxx_spi;
+	struct fsl_espi_reg *reg_base;
+	int retval;
+	u32 hw_mode;
+	u32 loop_mode;
+	struct spi_mpc8xxx_cs *cs = spi->controller_state;
+
+	if (!spi->max_speed_hz)
+		return -EINVAL;
+
+	if (!cs) {
+		cs = kzalloc(sizeof *cs, GFP_KERNEL);
+		if (!cs)
+			return -ENOMEM;
+		spi->controller_state = cs;
+	}
+
+	mpc8xxx_spi = spi_master_get_devdata(spi->master);
+	reg_base = mpc8xxx_spi->reg_base;
+
+	hw_mode = cs->hw_mode; /* Save original settings */
+	cs->hw_mode = mpc8xxx_spi_read_reg(
+			&reg_base->csmode[spi->chip_select]);
+	/* mask out bits we are going to set */
+	cs->hw_mode &= ~(CSMODE_CP_BEGIN_EDGECLK | CSMODE_CI_INACTIVEHIGH
+			 | CSMODE_REV);
+
+	if (spi->mode & SPI_CPHA)
+		cs->hw_mode |= CSMODE_CP_BEGIN_EDGECLK;
+	if (spi->mode & SPI_CPOL)
+		cs->hw_mode |= CSMODE_CI_INACTIVEHIGH;
+	if (!(spi->mode & SPI_LSB_FIRST))
+		cs->hw_mode |= CSMODE_REV;
+
+	/* Handle the loop mode */
+	loop_mode = mpc8xxx_spi_read_reg(&reg_base->mode);
+	loop_mode &= ~SPMODE_LOOP;
+	if (spi->mode & SPI_LOOP)
+		loop_mode |= SPMODE_LOOP;
+	mpc8xxx_spi_write_reg(&reg_base->mode, loop_mode);
+
+	retval = fsl_espi_setup_transfer(spi, NULL);
+	if (retval < 0) {
+		cs->hw_mode = hw_mode; /* Restore settings */
+		return retval;
+	}
+	return 0;
+}
+
+void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
+{
+	struct fsl_espi_reg *reg_base = mspi->reg_base;
+
+	/* We need handle RX first */
+	if (events & SPIE_NE) {
+		u32 rx_data, tmp;
+		u8 rx_data_8;
+
+		/* Spin until RX is done */
+		while (SPIE_RXCNT(events) < min(4, mspi->len)) {
+			cpu_relax();
+			events = mpc8xxx_spi_read_reg(&reg_base->event);
+		}
+
+		if (mspi->len >= 4) {
+			rx_data = mpc8xxx_spi_read_reg(&reg_base->receive);
+		} else {
+			tmp = mspi->len;
+			rx_data = 0;
+			while (tmp--) {
+				rx_data_8 = in_8((u8 *)&reg_base->receive);
+				rx_data |= (rx_data_8 << (tmp * 8));
+			}
+
+			rx_data <<= (4 - mspi->len) * 8;
+		}
+
+		mspi->len -= 4;
+
+		if (mspi->rx)
+			mspi->get_rx(rx_data, mspi);
+	}
+
+	if (!(events & SPIE_NF)) {
+		int ret;
+
+		/* spin until TX is done */
+		ret = spin_event_timeout(((events = mpc8xxx_spi_read_reg(
+				&reg_base->event)) & SPIE_NF) == 0, 1000, 0);
+		if (!ret) {
+			dev_err(mspi->dev, "tired waiting for SPIE_NF\n");
+			return;
+		}
+	}
+
+	/* Clear the events */
+	mpc8xxx_spi_write_reg(&reg_base->event, events);
+
+	mspi->count -= 1;
+	if (mspi->count) {
+		u32 word = mspi->get_tx(mspi);
+
+		mpc8xxx_spi_write_reg(&reg_base->transmit, word);
+	} else {
+		complete(&mspi->done);
+	}
+}
+
+static irqreturn_t fsl_espi_irq(s32 irq, void *context_data)
+{
+	struct mpc8xxx_spi *mspi = context_data;
+	struct fsl_espi_reg *reg_base = mspi->reg_base;
+	irqreturn_t ret = IRQ_NONE;
+	u32 events;
+
+	/* Get interrupt events(tx/rx) */
+	events = mpc8xxx_spi_read_reg(&reg_base->event);
+	if (events)
+		ret = IRQ_HANDLED;
+
+	dev_vdbg(mspi->dev, "%s: events %x\n", __func__, events);
+
+	fsl_espi_cpu_irq(mspi, events);
+
+	return ret;
+}
+
+static void fsl_espi_remove(struct mpc8xxx_spi *mspi)
+{
+	iounmap(mspi->reg_base);
+}
+
+static struct spi_master * __devinit fsl_espi_probe(struct device *dev,
+		struct resource *mem, unsigned int irq)
+{
+	struct fsl_spi_platform_data *pdata = dev->platform_data;
+	struct spi_master *master;
+	struct mpc8xxx_spi *mpc8xxx_spi;
+	struct fsl_espi_reg *reg_base;
+	u32 regval;
+	int i, ret = 0;
+
+	master = spi_alloc_master(dev, sizeof(struct mpc8xxx_spi));
+	if (!master) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	dev_set_drvdata(dev, master);
+
+	ret = mpc8xxx_spi_probe(dev, mem, irq);
+	if (ret)
+		goto err_probe;
+
+	master->setup = fsl_espi_setup;
+
+	mpc8xxx_spi = spi_master_get_devdata(master);
+	mpc8xxx_spi->spi_do_one_msg = fsl_espi_do_one_msg;
+	mpc8xxx_spi->spi_remove = fsl_espi_remove;
+
+	mpc8xxx_spi->reg_base = ioremap(mem->start, resource_size(mem));
+	if (!mpc8xxx_spi->reg_base) {
+		ret = -ENOMEM;
+		goto err_probe;
+	}
+
+	reg_base = mpc8xxx_spi->reg_base;
+
+	/* Register for SPI Interrupt */
+	ret = request_irq(mpc8xxx_spi->irq, fsl_espi_irq,
+			  0, "fsl_espi", mpc8xxx_spi);
+	if (ret)
+		goto free_irq;
+
+	if (mpc8xxx_spi->flags & SPI_QE_CPU_MODE) {
+		mpc8xxx_spi->rx_shift = 16;
+		mpc8xxx_spi->tx_shift = 24;
+	}
+
+	/* SPI controller initializations */
+	mpc8xxx_spi_write_reg(&reg_base->mode, 0);
+	mpc8xxx_spi_write_reg(&reg_base->mask, 0);
+	mpc8xxx_spi_write_reg(&reg_base->command, 0);
+	mpc8xxx_spi_write_reg(&reg_base->event, 0xffffffff);
+
+	/* Init eSPI CS mode register */
+	for (i = 0; i < pdata->max_chipselect; i++)
+		mpc8xxx_spi_write_reg(&reg_base->csmode[i], CSMODE_INIT_VAL);
+
+	/* Enable SPI interface */
+	regval = pdata->initial_spmode | SPMODE_INIT_VAL | SPMODE_ENABLE;
+
+	mpc8xxx_spi_write_reg(&reg_base->mode, regval);
+
+	ret = spi_register_master(master);
+	if (ret < 0)
+		goto unreg_master;
+
+	dev_info(dev, "at 0x%p (irq = %d)\n", reg_base, mpc8xxx_spi->irq);
+
+	return master;
+
+unreg_master:
+	free_irq(mpc8xxx_spi->irq, mpc8xxx_spi);
+free_irq:
+	iounmap(mpc8xxx_spi->reg_base);
+err_probe:
+	spi_master_put(master);
+err:
+	return ERR_PTR(ret);
+}
+
+static int of_fsl_espi_get_chipselects(struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	struct fsl_spi_platform_data *pdata = dev->platform_data;
+	const u32 *prop;
+	int len;
+
+	prop = of_get_property(np, "fsl,espi-num-chipselects", &len);
+	if (!prop || len < sizeof(*prop)) {
+		dev_err(dev, "No 'fsl,espi-num-chipselects' property\n");
+		return -EINVAL;
+	}
+
+	pdata->max_chipselect = *prop;
+	pdata->cs_control = NULL;
+
+	return 0;
+}
+
+static int __devinit of_fsl_espi_probe(struct platform_device *ofdev)
+{
+	struct device *dev = &ofdev->dev;
+	struct device_node *np = ofdev->dev.of_node;
+	struct spi_master *master;
+	struct resource mem;
+	struct resource irq;
+	int ret = -ENOMEM;
+
+	ret = of_mpc8xxx_spi_probe(ofdev);
+	if (ret)
+		return ret;
+
+	ret = of_fsl_espi_get_chipselects(dev);
+	if (ret)
+		goto err;
+
+	ret = of_address_to_resource(np, 0, &mem);
+	if (ret)
+		goto err;
+
+	ret = of_irq_to_resource(np, 0, &irq);
+	if (!ret) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	master = fsl_espi_probe(dev, &mem, irq.start);
+	if (IS_ERR(master)) {
+		ret = PTR_ERR(master);
+		goto err;
+	}
+
+	return 0;
+
+err:
+	return ret;
+}
+
+static int __devexit of_fsl_espi_remove(struct platform_device *dev)
+{
+	return mpc8xxx_spi_remove(&dev->dev);
+}
+
+static const struct of_device_id of_fsl_espi_match[] = {
+	{ .compatible = "fsl,mpc8536-espi" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, of_fsl_espi_match);
+
+static struct platform_driver fsl_espi_driver = {
+	.driver = {
+		.name = "fsl_espi",
+		.owner = THIS_MODULE,
+		.of_match_table = of_fsl_espi_match,
+	},
+	.probe		= of_fsl_espi_probe,
+	.remove		= __devexit_p(of_fsl_espi_remove),
+};
+
+static int __init fsl_espi_init(void)
+{
+	return platform_driver_register(&fsl_espi_driver);
+}
+module_init(fsl_espi_init);
+
+static void __exit fsl_espi_exit(void)
+{
+	platform_driver_unregister(&fsl_espi_driver);
+}
+module_exit(fsl_espi_exit);
+
+MODULE_AUTHOR("Mingkai Hu");
+MODULE_DESCRIPTION("Enhanced Freescale SPI Driver");
+MODULE_LICENSE("GPL");
