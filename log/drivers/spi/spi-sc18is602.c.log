commit 6d75145bf6b6558dea5ce3b4f83f3f66444bcac0
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Mon Apr 13 17:40:43 2020 +0200

    spi: sc18is602: Fix a typo in MODULE_DESCRIPTION
    
    This should be 'SC18IS602', not 'SC18IC602'
    
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Link: https://lore.kernel.org/r/20200413154043.23064-1-christophe.jaillet@wanadoo.fr
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-sc18is602.c b/drivers/spi/spi-sc18is602.c
index 5497eeb3bf3e..ee0f3edf49cd 100644
--- a/drivers/spi/spi-sc18is602.c
+++ b/drivers/spi/spi-sc18is602.c
@@ -345,6 +345,6 @@ static struct i2c_driver sc18is602_driver = {
 
 module_i2c_driver(sc18is602_driver);
 
-MODULE_DESCRIPTION("SC18IC602/603 SPI Master Driver");
+MODULE_DESCRIPTION("SC18IS602/603 SPI Master Driver");
 MODULE_AUTHOR("Guenter Roeck");
 MODULE_LICENSE("GPL");

commit e74dc5c763448004ec8add422e9db53ee246acce
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:37 2019 +0300

    spi: use new `spi_transfer_delay_exec` helper where straightforward
    
    For many places in the spi drivers, using the new `spi_transfer_delay`
    helper is straightforward.
    It's just replacing:
    ```
      if (t->delay_usecs)
         udelay(t->delay_usecs);
    ```
    with `spi_transfer_delay(t)` which handles both `delay_usecs` and the new
    `delay` field.
    
    This change replaces in all places (in the spi drivers)  where this change
    is simple.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-10-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-sc18is602.c b/drivers/spi/spi-sc18is602.c
index 11acddc83304..5497eeb3bf3e 100644
--- a/drivers/spi/spi-sc18is602.c
+++ b/drivers/spi/spi-sc18is602.c
@@ -211,8 +211,7 @@ static int sc18is602_transfer_one(struct spi_master *master,
 		}
 		status = 0;
 
-		if (t->delay_usecs)
-			udelay(t->delay_usecs);
+		spi_transfer_delay_exec(t);
 	}
 	m->status = status;
 	spi_finalize_current_message(master);

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/spi/spi-sc18is602.c b/drivers/spi/spi-sc18is602.c
index 52cf0e9189c2..11acddc83304 100644
--- a/drivers/spi/spi-sc18is602.c
+++ b/drivers/spi/spi-sc18is602.c
@@ -1,17 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * NXP SC18IS602/603 SPI driver
  *
  * Copyright (C) Guenter Roeck <linux@roeck-us.net>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include <linux/kernel.h>

commit 68c97b92c0a0dfdc134564f1f1c04b1c8ed27bba
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Wed Feb 22 15:14:20 2017 -0300

    spi: sc18is602: Add OF device ID table
    
    The driver doesn't have a struct of_device_id table but supported devices
    are registered via Device Trees. This is working on the assumption that a
    I2C device registered via OF will always match a legacy I2C device ID and
    that the MODALIAS reported will always be of the form i2c:<device>.
    
    But this could change in the future so the correct approach is to have an
    OF device ID table if the devices are registered via OF.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-sc18is602.c b/drivers/spi/spi-sc18is602.c
index f63714ffb62f..52cf0e9189c2 100644
--- a/drivers/spi/spi-sc18is602.c
+++ b/drivers/spi/spi-sc18is602.c
@@ -21,6 +21,7 @@
 #include <linux/i2c.h>
 #include <linux/delay.h>
 #include <linux/pm_runtime.h>
+#include <linux/of_device.h>
 #include <linux/of.h>
 #include <linux/platform_data/sc18is602.h>
 #include <linux/gpio/consumer.h>
@@ -271,7 +272,10 @@ static int sc18is602_probe(struct i2c_client *client,
 	hw->dev = dev;
 	hw->ctrl = 0xff;
 
-	hw->id = id->driver_data;
+	if (client->dev.of_node)
+		hw->id = (enum chips)of_device_get_match_data(&client->dev);
+	else
+		hw->id = id->driver_data;
 
 	switch (hw->id) {
 	case sc18is602:
@@ -323,9 +327,27 @@ static const struct i2c_device_id sc18is602_id[] = {
 };
 MODULE_DEVICE_TABLE(i2c, sc18is602_id);
 
+static const struct of_device_id sc18is602_of_match[] = {
+	{
+		.compatible = "nxp,sc18is602",
+		.data = (void *)sc18is602
+	},
+	{
+		.compatible = "nxp,sc18is602b",
+		.data = (void *)sc18is602b
+	},
+	{
+		.compatible = "nxp,sc18is603",
+		.data = (void *)sc18is603
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, sc18is602_of_match);
+
 static struct i2c_driver sc18is602_driver = {
 	.driver = {
 		.name = "sc18is602",
+		.of_match_table = of_match_ptr(sc18is602_of_match),
 	},
 	.probe = sc18is602_probe,
 	.id_table = sc18is602_id,

commit 76cce7e3a582e3a86becaa086f24277829e1e0f5
Author: Phil Reid <preid@electromag.com.au>
Date:   Thu Sep 29 10:41:02 2016 +0800

    spi: sc18is602: Change gpiod_set_value to gpiod_set_value_cansleep
    
    To avoid warning when using i2c gpio expander change call to the
    cansleep variant. There should be no issue with sleeping in the
    drivers probe function.
    
    Signed-off-by: Phil Reid <preid@electromag.com.au>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-sc18is602.c b/drivers/spi/spi-sc18is602.c
index 5666b5d20b87..f63714ffb62f 100644
--- a/drivers/spi/spi-sc18is602.c
+++ b/drivers/spi/spi-sc18is602.c
@@ -264,7 +264,7 @@ static int sc18is602_probe(struct i2c_client *client,
 	hw->reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
 	if (IS_ERR(hw->reset))
 		return PTR_ERR(hw->reset);
-	gpiod_set_value(hw->reset, 0);
+	gpiod_set_value_cansleep(hw->reset, 0);
 
 	hw->master = master;
 	hw->client = client;

commit f99008013e199e6b88ef26c98ecb042c94c7450c
Author: Phil Reid <preid@electromag.com.au>
Date:   Wed Aug 31 15:31:38 2016 +0800

    spi: sc18is602: Add reset control via gpio pin.
    
    This sc18is602 has a reset pin that may need to be deasserted.
    Add optional binding to specifiy the reset pin via a gpio and deassert
    during probe.
    
    Signed-off-by: Phil Reid <preid@electromag.com.au>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-sc18is602.c b/drivers/spi/spi-sc18is602.c
index 36af4d48a700..5666b5d20b87 100644
--- a/drivers/spi/spi-sc18is602.c
+++ b/drivers/spi/spi-sc18is602.c
@@ -23,6 +23,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/of.h>
 #include <linux/platform_data/sc18is602.h>
+#include <linux/gpio/consumer.h>
 
 enum chips { sc18is602, sc18is602b, sc18is603 };
 
@@ -50,6 +51,8 @@ struct sc18is602 {
 	u8			buffer[SC18IS602_BUFSIZ + 1];
 	int			tlen;	/* Data queued for tx in buffer */
 	int			rindex;	/* Receive data index in buffer */
+
+	struct gpio_desc	*reset;
 };
 
 static int sc18is602_wait_ready(struct sc18is602 *hw, int len)
@@ -257,6 +260,12 @@ static int sc18is602_probe(struct i2c_client *client,
 	hw = spi_master_get_devdata(master);
 	i2c_set_clientdata(client, hw);
 
+	/* assert reset and then release */
+	hw->reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(hw->reset))
+		return PTR_ERR(hw->reset);
+	gpiod_set_value(hw->reset, 0);
+
 	hw->master = master;
 	hw->client = client;
 	hw->dev = dev;

commit 165f2288e1fc82df0c429942f2b7aef69de17d72
Merge: 8afba181b90f 612762e82ae6 76b17e6e4923 c9bc3e8bf042 0744ea2a01cb b4e27545224e
Author: Mark Brown <broonie@kernel.org>
Date:   Sat Apr 11 23:09:25 2015 +0100

    Merge remote-tracking branches 'spi/topic/qup', 'spi/topic/rockchip', 'spi/topic/rspi', 'spi/topic/s3c64xx' and 'spi/topic/sc18is602' into spi-next

commit b4e27545224e263d271a9d9aa8763357a7e40eaa
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Fri Feb 6 12:27:54 2015 -0800

    spi: sc18is602: Support multiple devices on a single I2C bus if DT is configured
    
    The driver currently only supports a single device per I2C bus since it uses
    the I2C bus number to set the SPI bus number. This makes it impossible to
    connect more than one chip to a single I2C bus.
    
    We don't want to use dynamic bus numbers unconditionally since this would
    result in every instantiation getting a different bus number starting with
    65,535 counting down unless devicetree is configured. If devicetree is
    configured, however, the SPI bus number is obtained from devicetree
    data. So we can use dynamic SPI bus numbers in this case.
    
    Reported-and-Tested-by: Marco Menchise <marco.menchise@gmail.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-sc18is602.c b/drivers/spi/spi-sc18is602.c
index 237f2e7a7179..c04e601152f1 100644
--- a/drivers/spi/spi-sc18is602.c
+++ b/drivers/spi/spi-sc18is602.c
@@ -290,7 +290,7 @@ static int sc18is602_probe(struct i2c_client *client,
 			hw->freq = SC18IS602_CLOCK;
 		break;
 	}
-	master->bus_num = client->adapter->nr;
+	master->bus_num = np ? -1 : client->adapter->nr;
 	master->mode_bits = SPI_CPHA | SPI_CPOL | SPI_LSB_FIRST;
 	master->bits_per_word_mask = SPI_BPW_MASK(8);
 	master->setup = sc18is602_setup;

commit 2c658e212ce7e40ace56d9441c8c5634d4d420e3
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Thu Dec 18 16:12:08 2014 +0200

    spi: Remove FSF mailing addresses
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-sc18is602.c b/drivers/spi/spi-sc18is602.c
index 237f2e7a7179..5a56acf8a43e 100644
--- a/drivers/spi/spi-sc18is602.c
+++ b/drivers/spi/spi-sc18is602.c
@@ -12,10 +12,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 #include <linux/kernel.h>

commit 09e99bca8324c3335794b86802486bb5191861d5
Author: Axel Lin <axel.lin@ingics.com>
Date:   Fri Feb 28 18:39:33 2014 +0800

    spi: sc18is602: Convert to let spi core validate transfer speed
    
    Set master->max_speed_hz and master->min_speed_hz then spi core will handle
    checking transfer speed. So we can remove the same checking in this driver.
    
    This patch also remove testing if hz is 0 because spi->max_speed_hz will be
    default set to master->min_speed_hz if it was not set. So the transfer speed
    will never set to 0.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-sc18is602.c b/drivers/spi/spi-sc18is602.c
index 7fba10bba3b0..237f2e7a7179 100644
--- a/drivers/spi/spi-sc18is602.c
+++ b/drivers/spi/spi-sc18is602.c
@@ -183,17 +183,9 @@ static int sc18is602_setup_transfer(struct sc18is602 *hw, u32 hz, u8 mode)
 static int sc18is602_check_transfer(struct spi_device *spi,
 				    struct spi_transfer *t, int tlen)
 {
-	uint32_t hz;
-
 	if (t && t->len + tlen > SC18IS602_BUFSIZ)
 		return -EINVAL;
 
-	hz = spi->max_speed_hz;
-	if (t && t->speed_hz)
-		hz = t->speed_hz;
-	if (hz == 0)
-		return -EINVAL;
-
 	return 0;
 }
 
@@ -207,14 +199,13 @@ static int sc18is602_transfer_one(struct spi_master *master,
 
 	hw->tlen = 0;
 	list_for_each_entry(t, &m->transfers, transfer_list) {
-		u32 hz = t->speed_hz ? : spi->max_speed_hz;
 		bool do_transfer;
 
 		status = sc18is602_check_transfer(spi, t, hw->tlen);
 		if (status < 0)
 			break;
 
-		status = sc18is602_setup_transfer(hw, hz, spi->mode);
+		status = sc18is602_setup_transfer(hw, t->speed_hz, spi->mode);
 		if (status < 0)
 			break;
 
@@ -305,6 +296,8 @@ static int sc18is602_probe(struct i2c_client *client,
 	master->setup = sc18is602_setup;
 	master->transfer_one_message = sc18is602_transfer_one;
 	master->dev.of_node = np;
+	master->min_speed_hz = hw->freq / 128;
+	master->max_speed_hz = hw->freq / 4;
 
 	error = devm_spi_register_master(dev, master);
 	if (error)

commit c5c67e31bc1b96658169b5b553b9be42e2ca6368
Author: Axel Lin <axel.lin@ingics.com>
Date:   Tue Feb 11 20:54:17 2014 +0800

    spi: sc18is602: Move checking chip_select for SC18IS602 to sc18is602_setup
    
    So it will be checked when spi device is added onto the spi bus.
    spi_add_device() calls spi_setup() which then calls spi->master->setup().
    No need to check it every time sc18is602_transfer_one() is called.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-sc18is602.c b/drivers/spi/spi-sc18is602.c
index b3ac776def9b..7fba10bba3b0 100644
--- a/drivers/spi/spi-sc18is602.c
+++ b/drivers/spi/spi-sc18is602.c
@@ -205,12 +205,6 @@ static int sc18is602_transfer_one(struct spi_master *master,
 	struct spi_transfer *t;
 	int status = 0;
 
-	/* SC18IS602 does not support CS2 */
-	if (hw->id == sc18is602 && spi->chip_select == 2) {
-		status = -ENXIO;
-		goto error;
-	}
-
 	hw->tlen = 0;
 	list_for_each_entry(t, &m->transfers, transfer_list) {
 		u32 hz = t->speed_hz ? : spi->max_speed_hz;
@@ -238,13 +232,23 @@ static int sc18is602_transfer_one(struct spi_master *master,
 		if (t->delay_usecs)
 			udelay(t->delay_usecs);
 	}
-error:
 	m->status = status;
 	spi_finalize_current_message(master);
 
 	return status;
 }
 
+static int sc18is602_setup(struct spi_device *spi)
+{
+	struct sc18is602 *hw = spi_master_get_devdata(spi->master);
+
+	/* SC18IS602 does not support CS2 */
+	if (hw->id == sc18is602 && spi->chip_select == 2)
+		return -ENXIO;
+
+	return 0;
+}
+
 static int sc18is602_probe(struct i2c_client *client,
 			   const struct i2c_device_id *id)
 {
@@ -298,6 +302,7 @@ static int sc18is602_probe(struct i2c_client *client,
 	master->bus_num = client->adapter->nr;
 	master->mode_bits = SPI_CPHA | SPI_CPOL | SPI_LSB_FIRST;
 	master->bits_per_word_mask = SPI_BPW_MASK(8);
+	master->setup = sc18is602_setup;
 	master->transfer_one_message = sc18is602_transfer_one;
 	master->dev.of_node = np;
 

commit 589f6a90e6c5cda51ecb89799c5bff4074e9ef77
Author: Axel Lin <axel.lin@ingics.com>
Date:   Mon Jan 20 23:18:45 2014 +0800

    spi: sc18is602: Remove sc18is602_setup() because it is done by spi core
    
    The checking for spi->mode is done in the implementation of spi_setup().
    Calling sc18is602_check_transfer(spi, NULL, 0) is pointless because
    the code is equivent to checking if spi->max_speed_hz is 0.
    Note, sc18is602_check_transfer actually allows spi->max_speed_hz is 0
    if t->speed_hz is set. So return error in sc18is602_setup() when
    spi->max_speed_hz is 0 does not make sense.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-sc18is602.c b/drivers/spi/spi-sc18is602.c
index 121c2e1dea36..b3ac776def9b 100644
--- a/drivers/spi/spi-sc18is602.c
+++ b/drivers/spi/spi-sc18is602.c
@@ -245,14 +245,6 @@ static int sc18is602_transfer_one(struct spi_master *master,
 	return status;
 }
 
-static int sc18is602_setup(struct spi_device *spi)
-{
-	if (spi->mode & ~(SPI_CPHA | SPI_CPOL | SPI_LSB_FIRST))
-		return -EINVAL;
-
-	return sc18is602_check_transfer(spi, NULL, 0);
-}
-
 static int sc18is602_probe(struct i2c_client *client,
 			   const struct i2c_device_id *id)
 {
@@ -306,7 +298,6 @@ static int sc18is602_probe(struct i2c_client *client,
 	master->bus_num = client->adapter->nr;
 	master->mode_bits = SPI_CPHA | SPI_CPOL | SPI_LSB_FIRST;
 	master->bits_per_word_mask = SPI_BPW_MASK(8);
-	master->setup = sc18is602_setup;
 	master->transfer_one_message = sc18is602_transfer_one;
 	master->dev.of_node = np;
 

commit 8b8b773e6b611e6629ac01f85d401c949d153546
Merge: 341e6df6c887 463654cec264
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Jan 23 13:14:15 2014 +0000

    Merge commit 'spi/topic/sc18is602' into spi-linus

commit 463654cec26466a03615974444d6900f1cd0eeb9
Author: Axel Lin <axel.lin@ingics.com>
Date:   Fri Jan 17 18:00:42 2014 +0800

    spi: sc18is602: Convert to use bits_per_word_mask
    
    Since commit 543bb25 "spi: add ability to validate xfer->bits_per_word in SPI
    core", the driver can set bits_per_word_mask for the master then the SPI core
    will reject transfers that attempt to use an unsupported bits_per_word value.
    So we can remove the bits_per_word checking in sc18is602_check_transfer() and
    let SPI core handle the checking.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-sc18is602.c b/drivers/spi/spi-sc18is602.c
index c1a01d1ac315..c981d215b65b 100644
--- a/drivers/spi/spi-sc18is602.c
+++ b/drivers/spi/spi-sc18is602.c
@@ -183,18 +183,11 @@ static int sc18is602_setup_transfer(struct sc18is602 *hw, u32 hz, u8 mode)
 static int sc18is602_check_transfer(struct spi_device *spi,
 				    struct spi_transfer *t, int tlen)
 {
-	int bpw;
 	uint32_t hz;
 
 	if (t && t->len + tlen > SC18IS602_BUFSIZ)
 		return -EINVAL;
 
-	bpw = spi->bits_per_word;
-	if (t && t->bits_per_word)
-		bpw = t->bits_per_word;
-	if (bpw != 8)
-		return -EINVAL;
-
 	hz = spi->max_speed_hz;
 	if (t && t->speed_hz)
 		hz = t->speed_hz;
@@ -315,6 +308,7 @@ static int sc18is602_probe(struct i2c_client *client,
 	}
 	master->bus_num = client->adapter->nr;
 	master->mode_bits = SPI_CPHA | SPI_CPOL | SPI_LSB_FIRST;
+	master->bits_per_word_mask = SPI_BPW_MASK(8);
 	master->setup = sc18is602_setup;
 	master->transfer_one_message = sc18is602_transfer_one;
 	master->dev.of_node = np;

commit 23061f1eb844edd349c3a0f5f40e244c9d2abfde
Author: Axel Lin <axel.lin@ingics.com>
Date:   Fri Jan 17 18:53:40 2014 +0800

    spi: Remove duplicate code to set default bits_per_word setting
    
    The implementation in spi_setup() already set spi->bits_per_word = 8 when
    spi->bits_per_word is 0 before calling spi->master->setup.
    So we don't need to do it again in setup() callback.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Acked-by: Marek Vasut <marex@denx.de>
    Acked-by: Barry Song <Baohua.Song@csr.com>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-sc18is602.c b/drivers/spi/spi-sc18is602.c
index c1a01d1ac315..1edffed9e098 100644
--- a/drivers/spi/spi-sc18is602.c
+++ b/drivers/spi/spi-sc18is602.c
@@ -254,9 +254,6 @@ static int sc18is602_transfer_one(struct spi_master *master,
 
 static int sc18is602_setup(struct spi_device *spi)
 {
-	if (!spi->bits_per_word)
-		spi->bits_per_word = 8;
-
 	if (spi->mode & ~(SPI_CPHA | SPI_CPOL | SPI_LSB_FIRST))
 		return -EINVAL;
 

commit 15e0964dc2a097de3cf518badf2237b6b6adf7fe
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Wed Dec 4 14:14:30 2013 +0900

    spi: sc18is602: Use devm_spi_register_master()
    
    Use devm_spi_register_master() to make cleanup paths simpler,
    and remove unnecessary remove().
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi-sc18is602.c b/drivers/spi/spi-sc18is602.c
index 9eda21d739c6..c1a01d1ac315 100644
--- a/drivers/spi/spi-sc18is602.c
+++ b/drivers/spi/spi-sc18is602.c
@@ -319,7 +319,7 @@ static int sc18is602_probe(struct i2c_client *client,
 	master->transfer_one_message = sc18is602_transfer_one;
 	master->dev.of_node = np;
 
-	error = spi_register_master(master);
+	error = devm_spi_register_master(dev, master);
 	if (error)
 		goto error_reg;
 
@@ -330,16 +330,6 @@ static int sc18is602_probe(struct i2c_client *client,
 	return error;
 }
 
-static int sc18is602_remove(struct i2c_client *client)
-{
-	struct sc18is602 *hw = i2c_get_clientdata(client);
-	struct spi_master *master = hw->master;
-
-	spi_unregister_master(master);
-
-	return 0;
-}
-
 static const struct i2c_device_id sc18is602_id[] = {
 	{ "sc18is602", sc18is602 },
 	{ "sc18is602b", sc18is602b },
@@ -353,7 +343,6 @@ static struct i2c_driver sc18is602_driver = {
 		.name = "sc18is602",
 	},
 	.probe = sc18is602_probe,
-	.remove = sc18is602_remove,
 	.id_table = sc18is602_id,
 };
 

commit 58ed90de3ef58a19c035355a4a0cd6dfef6d6b0c
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Wed Aug 22 17:28:55 2012 -0700

    spi/sc18is602: Return -EINVAL for probe failures due to I2C function mismatch
    
    If the I2C bus master driver does not support the required functionality,
    the driver returns -ENODEV. This causes a silent probe failure without error
    message. Since the device has to be explicitly instantiated, and the user
    should know the correct bus, this event really reflects an error condition.
    Replace error return value with -EINVAL to trigger an error message showing
    that the probe function failed.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/spi/spi-sc18is602.c b/drivers/spi/spi-sc18is602.c
index dd9896423f0b..9eda21d739c6 100644
--- a/drivers/spi/spi-sc18is602.c
+++ b/drivers/spi/spi-sc18is602.c
@@ -275,7 +275,7 @@ static int sc18is602_probe(struct i2c_client *client,
 
 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |
 				     I2C_FUNC_SMBUS_WRITE_BYTE_DATA))
-		return -ENODEV;
+		return -EINVAL;
 
 	master = spi_alloc_master(dev, sizeof(struct sc18is602));
 	if (!master)

commit 3ce8859e2e72713d3619285cab609d05c3591fc4
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sat Aug 18 09:06:27 2012 -0700

    spi: Master driver for NXP SC18IS602/603
    
    This driver adds support for NXP SC18IS602/603 I2C to SPI bus bridge.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/spi/spi-sc18is602.c b/drivers/spi/spi-sc18is602.c
new file mode 100644
index 000000000000..dd9896423f0b
--- /dev/null
+++ b/drivers/spi/spi-sc18is602.c
@@ -0,0 +1,364 @@
+/*
+ * NXP SC18IS602/603 SPI driver
+ *
+ * Copyright (C) Guenter Roeck <linux@roeck-us.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/pm_runtime.h>
+#include <linux/of.h>
+#include <linux/platform_data/sc18is602.h>
+
+enum chips { sc18is602, sc18is602b, sc18is603 };
+
+#define SC18IS602_BUFSIZ		200
+#define SC18IS602_CLOCK			7372000
+
+#define SC18IS602_MODE_CPHA		BIT(2)
+#define SC18IS602_MODE_CPOL		BIT(3)
+#define SC18IS602_MODE_LSB_FIRST	BIT(5)
+#define SC18IS602_MODE_CLOCK_DIV_4	0x0
+#define SC18IS602_MODE_CLOCK_DIV_16	0x1
+#define SC18IS602_MODE_CLOCK_DIV_64	0x2
+#define SC18IS602_MODE_CLOCK_DIV_128	0x3
+
+struct sc18is602 {
+	struct spi_master	*master;
+	struct device		*dev;
+	u8			ctrl;
+	u32			freq;
+	u32			speed;
+
+	/* I2C data */
+	struct i2c_client	*client;
+	enum chips		id;
+	u8			buffer[SC18IS602_BUFSIZ + 1];
+	int			tlen;	/* Data queued for tx in buffer */
+	int			rindex;	/* Receive data index in buffer */
+};
+
+static int sc18is602_wait_ready(struct sc18is602 *hw, int len)
+{
+	int i, err;
+	int usecs = 1000000 * len / hw->speed + 1;
+	u8 dummy[1];
+
+	for (i = 0; i < 10; i++) {
+		err = i2c_master_recv(hw->client, dummy, 1);
+		if (err >= 0)
+			return 0;
+		usleep_range(usecs, usecs * 2);
+	}
+	return -ETIMEDOUT;
+}
+
+static int sc18is602_txrx(struct sc18is602 *hw, struct spi_message *msg,
+			  struct spi_transfer *t, bool do_transfer)
+{
+	unsigned int len = t->len;
+	int ret;
+
+	if (hw->tlen == 0) {
+		/* First byte (I2C command) is chip select */
+		hw->buffer[0] = 1 << msg->spi->chip_select;
+		hw->tlen = 1;
+		hw->rindex = 0;
+	}
+	/*
+	 * We can not immediately send data to the chip, since each I2C message
+	 * resembles a full SPI message (from CS active to CS inactive).
+	 * Enqueue messages up to the first read or until do_transfer is true.
+	 */
+	if (t->tx_buf) {
+		memcpy(&hw->buffer[hw->tlen], t->tx_buf, len);
+		hw->tlen += len;
+		if (t->rx_buf)
+			do_transfer = true;
+		else
+			hw->rindex = hw->tlen - 1;
+	} else if (t->rx_buf) {
+		/*
+		 * For receive-only transfers we still need to perform a dummy
+		 * write to receive data from the SPI chip.
+		 * Read data starts at the end of transmit data (minus 1 to
+		 * account for CS).
+		 */
+		hw->rindex = hw->tlen - 1;
+		memset(&hw->buffer[hw->tlen], 0, len);
+		hw->tlen += len;
+		do_transfer = true;
+	}
+
+	if (do_transfer && hw->tlen > 1) {
+		ret = sc18is602_wait_ready(hw, SC18IS602_BUFSIZ);
+		if (ret < 0)
+			return ret;
+		ret = i2c_master_send(hw->client, hw->buffer, hw->tlen);
+		if (ret < 0)
+			return ret;
+		if (ret != hw->tlen)
+			return -EIO;
+
+		if (t->rx_buf) {
+			int rlen = hw->rindex + len;
+
+			ret = sc18is602_wait_ready(hw, hw->tlen);
+			if (ret < 0)
+				return ret;
+			ret = i2c_master_recv(hw->client, hw->buffer, rlen);
+			if (ret < 0)
+				return ret;
+			if (ret != rlen)
+				return -EIO;
+			memcpy(t->rx_buf, &hw->buffer[hw->rindex], len);
+		}
+		hw->tlen = 0;
+	}
+	return len;
+}
+
+static int sc18is602_setup_transfer(struct sc18is602 *hw, u32 hz, u8 mode)
+{
+	u8 ctrl = 0;
+	int ret;
+
+	if (mode & SPI_CPHA)
+		ctrl |= SC18IS602_MODE_CPHA;
+	if (mode & SPI_CPOL)
+		ctrl |= SC18IS602_MODE_CPOL;
+	if (mode & SPI_LSB_FIRST)
+		ctrl |= SC18IS602_MODE_LSB_FIRST;
+
+	/* Find the closest clock speed */
+	if (hz >= hw->freq / 4) {
+		ctrl |= SC18IS602_MODE_CLOCK_DIV_4;
+		hw->speed = hw->freq / 4;
+	} else if (hz >= hw->freq / 16) {
+		ctrl |= SC18IS602_MODE_CLOCK_DIV_16;
+		hw->speed = hw->freq / 16;
+	} else if (hz >= hw->freq / 64) {
+		ctrl |= SC18IS602_MODE_CLOCK_DIV_64;
+		hw->speed = hw->freq / 64;
+	} else {
+		ctrl |= SC18IS602_MODE_CLOCK_DIV_128;
+		hw->speed = hw->freq / 128;
+	}
+
+	/*
+	 * Don't do anything if the control value did not change. The initial
+	 * value of 0xff for hw->ctrl ensures that the correct mode will be set
+	 * with the first call to this function.
+	 */
+	if (ctrl == hw->ctrl)
+		return 0;
+
+	ret = i2c_smbus_write_byte_data(hw->client, 0xf0, ctrl);
+	if (ret < 0)
+		return ret;
+
+	hw->ctrl = ctrl;
+
+	return 0;
+}
+
+static int sc18is602_check_transfer(struct spi_device *spi,
+				    struct spi_transfer *t, int tlen)
+{
+	int bpw;
+	uint32_t hz;
+
+	if (t && t->len + tlen > SC18IS602_BUFSIZ)
+		return -EINVAL;
+
+	bpw = spi->bits_per_word;
+	if (t && t->bits_per_word)
+		bpw = t->bits_per_word;
+	if (bpw != 8)
+		return -EINVAL;
+
+	hz = spi->max_speed_hz;
+	if (t && t->speed_hz)
+		hz = t->speed_hz;
+	if (hz == 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int sc18is602_transfer_one(struct spi_master *master,
+				  struct spi_message *m)
+{
+	struct sc18is602 *hw = spi_master_get_devdata(master);
+	struct spi_device *spi = m->spi;
+	struct spi_transfer *t;
+	int status = 0;
+
+	/* SC18IS602 does not support CS2 */
+	if (hw->id == sc18is602 && spi->chip_select == 2) {
+		status = -ENXIO;
+		goto error;
+	}
+
+	hw->tlen = 0;
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+		u32 hz = t->speed_hz ? : spi->max_speed_hz;
+		bool do_transfer;
+
+		status = sc18is602_check_transfer(spi, t, hw->tlen);
+		if (status < 0)
+			break;
+
+		status = sc18is602_setup_transfer(hw, hz, spi->mode);
+		if (status < 0)
+			break;
+
+		do_transfer = t->cs_change || list_is_last(&t->transfer_list,
+							   &m->transfers);
+
+		if (t->len) {
+			status = sc18is602_txrx(hw, m, t, do_transfer);
+			if (status < 0)
+				break;
+			m->actual_length += status;
+		}
+		status = 0;
+
+		if (t->delay_usecs)
+			udelay(t->delay_usecs);
+	}
+error:
+	m->status = status;
+	spi_finalize_current_message(master);
+
+	return status;
+}
+
+static int sc18is602_setup(struct spi_device *spi)
+{
+	if (!spi->bits_per_word)
+		spi->bits_per_word = 8;
+
+	if (spi->mode & ~(SPI_CPHA | SPI_CPOL | SPI_LSB_FIRST))
+		return -EINVAL;
+
+	return sc18is602_check_transfer(spi, NULL, 0);
+}
+
+static int sc18is602_probe(struct i2c_client *client,
+			   const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct device_node *np = dev->of_node;
+	struct sc18is602_platform_data *pdata = dev_get_platdata(dev);
+	struct sc18is602 *hw;
+	struct spi_master *master;
+	int error;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |
+				     I2C_FUNC_SMBUS_WRITE_BYTE_DATA))
+		return -ENODEV;
+
+	master = spi_alloc_master(dev, sizeof(struct sc18is602));
+	if (!master)
+		return -ENOMEM;
+
+	hw = spi_master_get_devdata(master);
+	i2c_set_clientdata(client, hw);
+
+	hw->master = master;
+	hw->client = client;
+	hw->dev = dev;
+	hw->ctrl = 0xff;
+
+	hw->id = id->driver_data;
+
+	switch (hw->id) {
+	case sc18is602:
+	case sc18is602b:
+		master->num_chipselect = 4;
+		hw->freq = SC18IS602_CLOCK;
+		break;
+	case sc18is603:
+		master->num_chipselect = 2;
+		if (pdata) {
+			hw->freq = pdata->clock_frequency;
+		} else {
+			const __be32 *val;
+			int len;
+
+			val = of_get_property(np, "clock-frequency", &len);
+			if (val && len >= sizeof(__be32))
+				hw->freq = be32_to_cpup(val);
+		}
+		if (!hw->freq)
+			hw->freq = SC18IS602_CLOCK;
+		break;
+	}
+	master->bus_num = client->adapter->nr;
+	master->mode_bits = SPI_CPHA | SPI_CPOL | SPI_LSB_FIRST;
+	master->setup = sc18is602_setup;
+	master->transfer_one_message = sc18is602_transfer_one;
+	master->dev.of_node = np;
+
+	error = spi_register_master(master);
+	if (error)
+		goto error_reg;
+
+	return 0;
+
+error_reg:
+	spi_master_put(master);
+	return error;
+}
+
+static int sc18is602_remove(struct i2c_client *client)
+{
+	struct sc18is602 *hw = i2c_get_clientdata(client);
+	struct spi_master *master = hw->master;
+
+	spi_unregister_master(master);
+
+	return 0;
+}
+
+static const struct i2c_device_id sc18is602_id[] = {
+	{ "sc18is602", sc18is602 },
+	{ "sc18is602b", sc18is602b },
+	{ "sc18is603", sc18is603 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, sc18is602_id);
+
+static struct i2c_driver sc18is602_driver = {
+	.driver = {
+		.name = "sc18is602",
+	},
+	.probe = sc18is602_probe,
+	.remove = sc18is602_remove,
+	.id_table = sc18is602_id,
+};
+
+module_i2c_driver(sc18is602_driver);
+
+MODULE_DESCRIPTION("SC18IC602/603 SPI Master Driver");
+MODULE_AUTHOR("Guenter Roeck");
+MODULE_LICENSE("GPL");
