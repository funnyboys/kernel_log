commit 36c72a58d472b4032e09f165ea064a0251c9df07
Author: Lukas Wunner <lukas@wunner.de>
Date:   Mon May 4 13:12:05 2020 +0200

    spi: amd: Drop superfluous member from struct amd_spi
    
    The AMD SPI driver stores a pointer to the spi_master in struct amd_spi
    so that it can get from the latter to the former in amd_spi_fifo_xfer().
    
    It's simpler to just pass the pointer from the sole caller
    amd_spi_master_transfer() and drop the pointer from struct amd_spi.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://lore.kernel.org/r/a088b684ad292faf3bd036e51529e608e5c94638.1588590210.git.lukas@wunner.de
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-amd.c b/drivers/spi/spi-amd.c
index 00f2f3405e08..d0aacd4de1b9 100644
--- a/drivers/spi/spi-amd.c
+++ b/drivers/spi/spi-amd.c
@@ -38,7 +38,6 @@ struct amd_spi {
 	void __iomem *io_remap_addr;
 	unsigned long io_base_addr;
 	u32 rom_addr;
-	struct spi_master *master;
 	u8 chip_select;
 };
 
@@ -164,9 +163,9 @@ static int amd_spi_master_setup(struct spi_device *spi)
 }
 
 static inline int amd_spi_fifo_xfer(struct amd_spi *amd_spi,
+				    struct spi_master *master,
 				    struct spi_message *message)
 {
-	struct spi_master *master = amd_spi->master;
 	struct spi_transfer *xfer = NULL;
 	u8 cmd_opcode;
 	u8 *buf = NULL;
@@ -241,7 +240,7 @@ static int amd_spi_master_transfer(struct spi_master *master,
 	 * Extract spi_transfers from the spi message and
 	 * program the controller.
 	 */
-	amd_spi_fifo_xfer(amd_spi, msg);
+	amd_spi_fifo_xfer(amd_spi, master, msg);
 
 	return 0;
 }
@@ -262,7 +261,6 @@ static int amd_spi_probe(struct platform_device *pdev)
 	}
 
 	amd_spi = spi_master_get_devdata(master);
-	amd_spi->master = master;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	amd_spi->io_remap_addr = devm_ioremap_resource(&pdev->dev, res);

commit 7b9c94bd13cc9dc9c0c4932ebacf756ae612d52a
Author: Lukas Wunner <lukas@wunner.de>
Date:   Mon May 4 13:12:04 2020 +0200

    spi: amd: Fix refcount underflow on remove
    
    The AMD SPI driver calls spi_master_put() in its ->remove() hook even
    though the preceding call to spi_unregister_master() already drops a
    ref, thus leading to a refcount underflow.  Drop the superfluous call
    to spi_master_put().
    
    This only leaves the call to spi_unregister_master() in the ->remove()
    hook, so it's safe to change the ->probe() hook to use the devm version
    of spi_register_master() and drop the ->remove() hook altogether.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://lore.kernel.org/r/5e53ccdf1eecd4e015dba99d0d77389107f8a2e3.1588590210.git.lukas@wunner.de
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-amd.c b/drivers/spi/spi-amd.c
index d3e3516ef957..00f2f3405e08 100644
--- a/drivers/spi/spi-amd.c
+++ b/drivers/spi/spi-amd.c
@@ -282,7 +282,7 @@ static int amd_spi_probe(struct platform_device *pdev)
 	master->transfer_one_message = amd_spi_master_transfer;
 
 	/* Register the controller with SPI framework */
-	err = spi_register_master(master);
+	err = devm_spi_register_master(dev, master);
 	if (err) {
 		dev_err(dev, "error %d registering SPI controller\n", err);
 		goto err_free_master;
@@ -296,16 +296,6 @@ static int amd_spi_probe(struct platform_device *pdev)
 	return err;
 }
 
-static int amd_spi_remove(struct platform_device *pdev)
-{
-	struct amd_spi *amd_spi = platform_get_drvdata(pdev);
-
-	spi_unregister_master(amd_spi->master);
-	spi_master_put(amd_spi->master);
-
-	return 0;
-}
-
 static const struct acpi_device_id spi_acpi_match[] = {
 	{ "AMDI0061", 0 },
 	{},
@@ -318,7 +308,6 @@ static struct platform_driver amd_spi_driver = {
 		.acpi_match_table = ACPI_PTR(spi_acpi_match),
 	},
 	.probe = amd_spi_probe,
-	.remove = amd_spi_remove,
 };
 
 module_platform_driver(amd_spi_driver);

commit 4332ea8f40c80d51a534f194291bf3b7738a7beb
Author: Lukas Wunner <lukas@wunner.de>
Date:   Mon May 4 13:12:03 2020 +0200

    spi: amd: Drop duplicate driver data assignments
    
    The AMD SPI driver calls platform_set_drvdata() on probe even though
    it's already been set by __spi_alloc_controller().  Likewise, it calls
    platform_set_drvdata() on remove even though it's going to be set by
    __device_release_driver().  Drop the duplicate assignments.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://lore.kernel.org/r/499f8ad4759c2ff0f586e0459fb9a293faecff6d.1588590210.git.lukas@wunner.de
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-amd.c b/drivers/spi/spi-amd.c
index a4248b97b67e..d3e3516ef957 100644
--- a/drivers/spi/spi-amd.c
+++ b/drivers/spi/spi-amd.c
@@ -287,7 +287,6 @@ static int amd_spi_probe(struct platform_device *pdev)
 		dev_err(dev, "error %d registering SPI controller\n", err);
 		goto err_free_master;
 	}
-	platform_set_drvdata(pdev, amd_spi);
 
 	return 0;
 
@@ -303,7 +302,6 @@ static int amd_spi_remove(struct platform_device *pdev)
 
 	spi_unregister_master(amd_spi->master);
 	spi_master_put(amd_spi->master);
-	platform_set_drvdata(pdev, NULL);
 
 	return 0;
 }

commit cc17fbec2e785926dafce65d014f8301847dff40
Author: Lukas Wunner <lukas@wunner.de>
Date:   Mon May 4 13:12:02 2020 +0200

    spi: amd: Pass probe errors back to driver core
    
    If probing fails, the AMD SPI driver pretends success to the driver core
    by returning 0.  Return the errno instead.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://lore.kernel.org/r/689f29a359718dab4f5de9ee66c02ea97b3bd9e8.1588590210.git.lukas@wunner.de
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-amd.c b/drivers/spi/spi-amd.c
index 65b53eee5be9..a4248b97b67e 100644
--- a/drivers/spi/spi-amd.c
+++ b/drivers/spi/spi-amd.c
@@ -294,7 +294,7 @@ static int amd_spi_probe(struct platform_device *pdev)
 err_free_master:
 	spi_master_put(master);
 
-	return 0;
+	return err;
 }
 
 static int amd_spi_remove(struct platform_device *pdev)

commit 2b60c49f3ca0648c5b02b60dc0f5b9e2c274bfb5
Author: Lukas Wunner <lukas@wunner.de>
Date:   Mon May 4 13:12:01 2020 +0200

    spi: amd: Fix duplicate iounmap in error path
    
    The AMD SPI driver uses devm_ioremap_resource() to map its registers, so
    they're automatically unmapped via device_release() when the last ref on
    the SPI controller is dropped.  The additional iounmap() in the ->probe()
    error path is thus unnecessary.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://lore.kernel.org/r/497cc38ae2beb7900ae05a1463eb83ff96e2770e.1588590210.git.lukas@wunner.de
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-amd.c b/drivers/spi/spi-amd.c
index c7cfc3dc20b1..65b53eee5be9 100644
--- a/drivers/spi/spi-amd.c
+++ b/drivers/spi/spi-amd.c
@@ -285,14 +285,12 @@ static int amd_spi_probe(struct platform_device *pdev)
 	err = spi_register_master(master);
 	if (err) {
 		dev_err(dev, "error %d registering SPI controller\n", err);
-		goto err_iounmap;
+		goto err_free_master;
 	}
 	platform_set_drvdata(pdev, amd_spi);
 
 	return 0;
 
-err_iounmap:
-	iounmap(amd_spi->io_remap_addr);
 err_free_master:
 	spi_master_put(master);
 

commit f84b604dbaf242d17135f527dbe81093a41226b3
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Wed Apr 29 02:54:26 2020 +0000

    spi: spi-amd: Fix a NULL vs IS_ERR() check in amd_spi_probe()
    
    In case of error, the function devm_ioremap_resource() returns ERR_PTR()
    and never returns NULL. The NULL test in the return value check should
    be replaced with IS_ERR().
    
    Fixes: bbb336f39efc ("spi: spi-amd: Add AMD SPI controller driver support")
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Link: https://lore.kernel.org/r/20200429025426.167664-1-weiyongjun1@huawei.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-amd.c b/drivers/spi/spi-amd.c
index c5a16dd44fa3..c7cfc3dc20b1 100644
--- a/drivers/spi/spi-amd.c
+++ b/drivers/spi/spi-amd.c
@@ -266,10 +266,9 @@ static int amd_spi_probe(struct platform_device *pdev)
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	amd_spi->io_remap_addr = devm_ioremap_resource(&pdev->dev, res);
-
-	if (!amd_spi->io_remap_addr) {
+	if (IS_ERR(amd_spi->io_remap_addr)) {
+		err = PTR_ERR(amd_spi->io_remap_addr);
 		dev_err(dev, "error %d ioremap of SPI registers failed\n", err);
-		err = -ENOMEM;
 		goto err_free_master;
 	}
 	dev_dbg(dev, "io_remap_address: %p\n", amd_spi->io_remap_addr);

commit 68d047cb0a20f612506c6cf3a98e3600a7d4371f
Author: Sanjay R Mehta <sanju.mehta@amd.com>
Date:   Mon Apr 27 23:56:41 2020 -0500

    spi: spi-amd: fix warning
    
    remove unused variable "opcode"
    
    Signed-off-by: Sanjay R Mehta <sanju.mehta@amd.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Link: https://lore.kernel.org/r/1588049801-37995-1-git-send-email-sanju.mehta@amd.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-amd.c b/drivers/spi/spi-amd.c
index 0d9debe1386e..c5a16dd44fa3 100644
--- a/drivers/spi/spi-amd.c
+++ b/drivers/spi/spi-amd.c
@@ -168,7 +168,7 @@ static inline int amd_spi_fifo_xfer(struct amd_spi *amd_spi,
 {
 	struct spi_master *master = amd_spi->master;
 	struct spi_transfer *xfer = NULL;
-	u8 cmd_opcode, opcode = 0;
+	u8 cmd_opcode;
 	u8 *buf = NULL;
 	u32 m_cmd = 0;
 	u32 i = 0;

commit bbb336f39efcb1b5498f65f59f9af5773ad6dc2b
Author: Sanjay R Mehta <sanju.mehta@amd.com>
Date:   Sat Apr 25 14:59:48 2020 -0500

    spi: spi-amd: Add AMD SPI controller driver support
    
    This driver supports SPI Controller for AMD SOCs.This driver
    supports SPI operations using FIFO mode of transfer.
    
    Signed-off-by: Sanjay R Mehta <sanju.mehta@amd.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Link: https://lore.kernel.org/r/1587844788-33997-1-git-send-email-sanju.mehta@amd.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi-amd.c b/drivers/spi/spi-amd.c
new file mode 100644
index 000000000000..0d9debe1386e
--- /dev/null
+++ b/drivers/spi/spi-amd.c
@@ -0,0 +1,333 @@
+// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
+//
+// AMD SPI controller driver
+//
+// Copyright (c) 2020, Advanced Micro Devices, Inc.
+//
+// Author: Sanjay R Mehta <sanju.mehta@amd.com>
+
+#include <linux/acpi.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+
+#define AMD_SPI_CTRL0_REG	0x00
+#define AMD_SPI_EXEC_CMD	BIT(16)
+#define AMD_SPI_FIFO_CLEAR	BIT(20)
+#define AMD_SPI_BUSY		BIT(31)
+
+#define AMD_SPI_OPCODE_MASK	0xFF
+
+#define AMD_SPI_ALT_CS_REG	0x1D
+#define AMD_SPI_ALT_CS_MASK	0x3
+
+#define AMD_SPI_FIFO_BASE	0x80
+#define AMD_SPI_TX_COUNT_REG	0x48
+#define AMD_SPI_RX_COUNT_REG	0x4B
+#define AMD_SPI_STATUS_REG	0x4C
+
+#define AMD_SPI_MEM_SIZE	200
+
+/* M_CMD OP codes for SPI */
+#define AMD_SPI_XFER_TX		1
+#define AMD_SPI_XFER_RX		2
+
+struct amd_spi {
+	void __iomem *io_remap_addr;
+	unsigned long io_base_addr;
+	u32 rom_addr;
+	struct spi_master *master;
+	u8 chip_select;
+};
+
+static inline u8 amd_spi_readreg8(struct spi_master *master, int idx)
+{
+	struct amd_spi *amd_spi = spi_master_get_devdata(master);
+
+	return ioread8((u8 __iomem *)amd_spi->io_remap_addr + idx);
+}
+
+static inline void amd_spi_writereg8(struct spi_master *master, int idx,
+				     u8 val)
+{
+	struct amd_spi *amd_spi = spi_master_get_devdata(master);
+
+	iowrite8(val, ((u8 __iomem *)amd_spi->io_remap_addr + idx));
+}
+
+static inline void amd_spi_setclear_reg8(struct spi_master *master, int idx,
+					 u8 set, u8 clear)
+{
+	u8 tmp = amd_spi_readreg8(master, idx);
+
+	tmp = (tmp & ~clear) | set;
+	amd_spi_writereg8(master, idx, tmp);
+}
+
+static inline u32 amd_spi_readreg32(struct spi_master *master, int idx)
+{
+	struct amd_spi *amd_spi = spi_master_get_devdata(master);
+
+	return ioread32((u8 __iomem *)amd_spi->io_remap_addr + idx);
+}
+
+static inline void amd_spi_writereg32(struct spi_master *master, int idx,
+				      u32 val)
+{
+	struct amd_spi *amd_spi = spi_master_get_devdata(master);
+
+	iowrite32(val, ((u8 __iomem *)amd_spi->io_remap_addr + idx));
+}
+
+static inline void amd_spi_setclear_reg32(struct spi_master *master, int idx,
+					  u32 set, u32 clear)
+{
+	u32 tmp = amd_spi_readreg32(master, idx);
+
+	tmp = (tmp & ~clear) | set;
+	amd_spi_writereg32(master, idx, tmp);
+}
+
+static void amd_spi_select_chip(struct spi_master *master)
+{
+	struct amd_spi *amd_spi = spi_master_get_devdata(master);
+	u8 chip_select = amd_spi->chip_select;
+
+	amd_spi_setclear_reg8(master, AMD_SPI_ALT_CS_REG, chip_select,
+			      AMD_SPI_ALT_CS_MASK);
+}
+
+static void amd_spi_clear_fifo_ptr(struct spi_master *master)
+{
+	amd_spi_setclear_reg32(master, AMD_SPI_CTRL0_REG, AMD_SPI_FIFO_CLEAR,
+			       AMD_SPI_FIFO_CLEAR);
+}
+
+static void amd_spi_set_opcode(struct spi_master *master, u8 cmd_opcode)
+{
+	amd_spi_setclear_reg32(master, AMD_SPI_CTRL0_REG, cmd_opcode,
+			       AMD_SPI_OPCODE_MASK);
+}
+
+static inline void amd_spi_set_rx_count(struct spi_master *master,
+					u8 rx_count)
+{
+	amd_spi_setclear_reg8(master, AMD_SPI_RX_COUNT_REG, rx_count, 0xff);
+}
+
+static inline void amd_spi_set_tx_count(struct spi_master *master,
+					u8 tx_count)
+{
+	amd_spi_setclear_reg8(master, AMD_SPI_TX_COUNT_REG, tx_count, 0xff);
+}
+
+static inline int amd_spi_busy_wait(struct amd_spi *amd_spi)
+{
+	bool spi_busy;
+	int timeout = 100000;
+
+	/* poll for SPI bus to become idle */
+	spi_busy = (ioread32((u8 __iomem *)amd_spi->io_remap_addr +
+		    AMD_SPI_CTRL0_REG) & AMD_SPI_BUSY) == AMD_SPI_BUSY;
+	while (spi_busy) {
+		usleep_range(10, 20);
+		if (timeout-- < 0)
+			return -ETIMEDOUT;
+
+		spi_busy = (ioread32((u8 __iomem *)amd_spi->io_remap_addr +
+			    AMD_SPI_CTRL0_REG) & AMD_SPI_BUSY) == AMD_SPI_BUSY;
+	}
+
+	return 0;
+}
+
+static void amd_spi_execute_opcode(struct spi_master *master)
+{
+	struct amd_spi *amd_spi = spi_master_get_devdata(master);
+
+	/* Set ExecuteOpCode bit in the CTRL0 register */
+	amd_spi_setclear_reg32(master, AMD_SPI_CTRL0_REG, AMD_SPI_EXEC_CMD,
+			       AMD_SPI_EXEC_CMD);
+
+	amd_spi_busy_wait(amd_spi);
+}
+
+static int amd_spi_master_setup(struct spi_device *spi)
+{
+	struct spi_master *master = spi->master;
+
+	amd_spi_clear_fifo_ptr(master);
+
+	return 0;
+}
+
+static inline int amd_spi_fifo_xfer(struct amd_spi *amd_spi,
+				    struct spi_message *message)
+{
+	struct spi_master *master = amd_spi->master;
+	struct spi_transfer *xfer = NULL;
+	u8 cmd_opcode, opcode = 0;
+	u8 *buf = NULL;
+	u32 m_cmd = 0;
+	u32 i = 0;
+	u32 tx_len = 0, rx_len = 0;
+
+	list_for_each_entry(xfer, &message->transfers,
+			    transfer_list) {
+		if (xfer->rx_buf)
+			m_cmd = AMD_SPI_XFER_RX;
+		if (xfer->tx_buf)
+			m_cmd = AMD_SPI_XFER_TX;
+
+		if (m_cmd & AMD_SPI_XFER_TX) {
+			buf = (u8 *)xfer->tx_buf;
+			tx_len = xfer->len - 1;
+			cmd_opcode = *(u8 *)xfer->tx_buf;
+			buf++;
+			amd_spi_set_opcode(master, cmd_opcode);
+
+			/* Write data into the FIFO. */
+			for (i = 0; i < tx_len; i++) {
+				iowrite8(buf[i],
+					 ((u8 __iomem *)amd_spi->io_remap_addr +
+					 AMD_SPI_FIFO_BASE + i));
+			}
+
+			amd_spi_set_tx_count(master, tx_len);
+			amd_spi_clear_fifo_ptr(master);
+			/* Execute command */
+			amd_spi_execute_opcode(master);
+		}
+		if (m_cmd & AMD_SPI_XFER_RX) {
+			/*
+			 * Store no. of bytes to be received from
+			 * FIFO
+			 */
+			rx_len = xfer->len;
+			buf = (u8 *)xfer->rx_buf;
+			amd_spi_set_rx_count(master, rx_len);
+			amd_spi_clear_fifo_ptr(master);
+			/* Execute command */
+			amd_spi_execute_opcode(master);
+			/* Read data from FIFO to receive buffer  */
+			for (i = 0; i < rx_len; i++)
+				buf[i] = amd_spi_readreg8(master,
+							  AMD_SPI_FIFO_BASE +
+							  tx_len + i);
+		}
+	}
+
+	/* Update statistics */
+	message->actual_length = tx_len + rx_len + 1;
+	/* complete the transaction */
+	message->status = 0;
+	spi_finalize_current_message(master);
+
+	return 0;
+}
+
+static int amd_spi_master_transfer(struct spi_master *master,
+				   struct spi_message *msg)
+{
+	struct amd_spi *amd_spi = spi_master_get_devdata(master);
+	struct spi_device *spi = msg->spi;
+
+	amd_spi->chip_select = spi->chip_select;
+	amd_spi_select_chip(master);
+
+	/*
+	 * Extract spi_transfers from the spi message and
+	 * program the controller.
+	 */
+	amd_spi_fifo_xfer(amd_spi, msg);
+
+	return 0;
+}
+
+static int amd_spi_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct spi_master *master;
+	struct amd_spi *amd_spi;
+	struct resource *res;
+	int err = 0;
+
+	/* Allocate storage for spi_master and driver private data */
+	master = spi_alloc_master(dev, sizeof(struct amd_spi));
+	if (!master) {
+		dev_err(dev, "Error allocating SPI master\n");
+		return -ENOMEM;
+	}
+
+	amd_spi = spi_master_get_devdata(master);
+	amd_spi->master = master;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	amd_spi->io_remap_addr = devm_ioremap_resource(&pdev->dev, res);
+
+	if (!amd_spi->io_remap_addr) {
+		dev_err(dev, "error %d ioremap of SPI registers failed\n", err);
+		err = -ENOMEM;
+		goto err_free_master;
+	}
+	dev_dbg(dev, "io_remap_address: %p\n", amd_spi->io_remap_addr);
+
+	/* Initialize the spi_master fields */
+	master->bus_num = 0;
+	master->num_chipselect = 4;
+	master->mode_bits = 0;
+	master->flags = SPI_MASTER_HALF_DUPLEX;
+	master->setup = amd_spi_master_setup;
+	master->transfer_one_message = amd_spi_master_transfer;
+
+	/* Register the controller with SPI framework */
+	err = spi_register_master(master);
+	if (err) {
+		dev_err(dev, "error %d registering SPI controller\n", err);
+		goto err_iounmap;
+	}
+	platform_set_drvdata(pdev, amd_spi);
+
+	return 0;
+
+err_iounmap:
+	iounmap(amd_spi->io_remap_addr);
+err_free_master:
+	spi_master_put(master);
+
+	return 0;
+}
+
+static int amd_spi_remove(struct platform_device *pdev)
+{
+	struct amd_spi *amd_spi = platform_get_drvdata(pdev);
+
+	spi_unregister_master(amd_spi->master);
+	spi_master_put(amd_spi->master);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static const struct acpi_device_id spi_acpi_match[] = {
+	{ "AMDI0061", 0 },
+	{},
+};
+MODULE_DEVICE_TABLE(acpi, spi_acpi_match);
+
+static struct platform_driver amd_spi_driver = {
+	.driver = {
+		.name = "amd_spi",
+		.acpi_match_table = ACPI_PTR(spi_acpi_match),
+	},
+	.probe = amd_spi_probe,
+	.remove = amd_spi_remove,
+};
+
+module_platform_driver(amd_spi_driver);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Sanjay Mehta <sanju.mehta@amd.com>");
+MODULE_DESCRIPTION("AMD SPI Master Controller Driver");
