commit c373643b8688836c1627a805875994fe0012fc17
Author: Mark Brown <broonie@kernel.org>
Date:   Mon May 25 14:31:20 2020 +0100

    spi: Remove note about transfer limit for spi_write_then_read()
    
    Originally spi_write_then_read() used a fixed statically allocated
    buffer which limited the maximum message size it could handle.  This
    restriction was removed a while ago so that we could dynamically
    allocate a buffer if required but the kerneldoc was not updated to
    reflect this, do so.
    
    Reported-by: Marc Kleine-Budde <mkl@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Link: https://lore.kernel.org/r/20200525133120.57273-1-broonie@kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 9d0b3c292e1e..8158e281f354 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -3858,8 +3858,7 @@ static u8	*buf;
  * is zero for success, else a negative errno status code.
  * This call may only be used from a context that may sleep.
  *
- * Parameters to this routine are always copied using a small buffer;
- * portable code should never use this for more than 32 bytes.
+ * Parameters to this routine are always copied using a small buffer.
  * Performance-sensitive or bulk transfer code should instead use
  * spi_{async,sync}() calls with dma-safe buffers.
  *

commit aee67fe879e5030a2f5e1d9af3cb5b2a1027e78a
Author: dillon min <dillon.minfei@gmail.com>
Date:   Mon May 25 11:45:48 2020 +0800

    spi: flags 'SPI_CONTROLLER_MUST_RX' and 'SPI_CONTROLLER_MUST_TX' can't be coexit with 'SPI_3WIRE' mode
    
    since chip spi driver need get the transfer direction by 'tx_buf' and
    'rx_buf' of 'struct spi_transfer' in 'SPI_3WIRE' mode.
    
    so, we need bypass 'SPI_CONTROLLER_MUST_RX' and 'SPI_CONTROLLER_MUST_TX'
    feature in 'SPI_3WIRE' mode
    
    Signed-off-by: dillon min <dillon.minfei@gmail.com>
    Link: https://lore.kernel.org/r/1590378348-8115-9-git-send-email-dillon.minfei@gmail.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index c765c966cc8e..9d0b3c292e1e 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1023,7 +1023,8 @@ static int spi_map_msg(struct spi_controller *ctlr, struct spi_message *msg)
 	void *tmp;
 	unsigned int max_tx, max_rx;
 
-	if (ctlr->flags & (SPI_CONTROLLER_MUST_RX | SPI_CONTROLLER_MUST_TX)) {
+	if ((ctlr->flags & (SPI_CONTROLLER_MUST_RX | SPI_CONTROLLER_MUST_TX))
+		&& !(msg->spi->mode & SPI_3WIRE)) {
 		max_tx = 0;
 		max_rx = 0;
 

commit 8fede89f853a7bfc671f9d8f069ccfe4190061f3
Author: Mark Brown <broonie@kernel.org>
Date:   Fri May 22 16:50:05 2020 +0100

    spi: Make spi_delay_exec() warn if called from atomic context
    
    If the delay used is long enough the spi_delay_exec() will use a sleeping
    function to implement it. Add a might_sleep() here to help avoid callers
    using this from an atomic context and running into problems at runtime on
    other systems.
    
    Suggested-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20200522155005.46099-1-broonie@kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index d32bdc6cbf66..c765c966cc8e 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1160,6 +1160,8 @@ int spi_delay_exec(struct spi_delay *_delay, struct spi_transfer *xfer)
 {
 	int delay;
 
+	might_sleep();
+
 	if (!_delay)
 		return -EINVAL;
 

commit c38a4905caaf78fd7ce8ecece6d3a966933968db
Merge: 73da2352075a b9dd3f6d4172
Author: Mark Brown <broonie@kernel.org>
Date:   Wed May 20 17:55:07 2020 +0100

    Merge branch 'for-5.7' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi into spi-5.8

commit 84855678add8aba927faf76bc2f130a40f94b6f7
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri May 15 17:58:01 2020 +0200

    spi: Fix controller unregister order
    
    When an SPI controller unregisters, it unbinds all its slave devices.
    For this, their drivers may need to access the SPI bus, e.g. to quiesce
    interrupts.
    
    However since commit ffbbdd21329f ("spi: create a message queueing
    infrastructure"), spi_destroy_queue() is executed before unbinding the
    slaves.  It sets ctlr->running = false, thereby preventing SPI bus
    access and causing unbinding of slave devices to fail.
    
    Fix by unbinding slaves before calling spi_destroy_queue().
    
    Fixes: ffbbdd21329f ("spi: create a message queueing infrastructure")
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Cc: stable@vger.kernel.org # v3.4+
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/8aaf9d44c153fe233b17bc2dec4eb679898d7e7b.1589557526.git.lukas@wunner.de
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 531d1de85f7f..25eb96d329ab 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2763,6 +2763,8 @@ void spi_unregister_controller(struct spi_controller *ctlr)
 	struct spi_controller *found;
 	int id = ctlr->bus_num;
 
+	device_for_each_child(&ctlr->dev, NULL, __unregister);
+
 	/* First make sure that this controller was ever added */
 	mutex_lock(&board_lock);
 	found = idr_find(&spi_master_idr, id);
@@ -2775,7 +2777,6 @@ void spi_unregister_controller(struct spi_controller *ctlr)
 	list_del(&ctlr->list);
 	mutex_unlock(&board_lock);
 
-	device_for_each_child(&ctlr->dev, NULL, __unregister);
 	device_unregister(&ctlr->dev);
 	/* free bus id */
 	mutex_lock(&board_lock);

commit f13242d2c5f773428da95f9aa1231f3b2cc64ea4
Merge: b68527dfa952 0392727c261b
Author: Mark Brown <broonie@kernel.org>
Date:   Tue May 5 11:48:25 2020 +0100

    Merge branch 'for-5.7' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi into spi-5.8

commit 49686df5b874e5ed6249bc622b73ad9a9e71cd99
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Apr 10 13:23:15 2020 +0100

    spi: remove redundant assignment to variable ms
    
    The variable ms is being initialized with a value that is never read
    and it is being updated later with a new value.  The initialization is
    redundant and can be removed.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Addresses-Coverity: ("Unused value")
    Link: https://lore.kernel.org/r/20200410122315.17523-1-colin.king@canonical.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index c92c89467e7e..5446b07dcd3a 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1075,7 +1075,7 @@ static int spi_transfer_wait(struct spi_controller *ctlr,
 {
 	struct spi_statistics *statm = &ctlr->statistics;
 	struct spi_statistics *stats = &msg->spi->statistics;
-	unsigned long long ms = 1;
+	unsigned long long ms;
 
 	if (spi_controller_is_slave(ctlr)) {
 		if (wait_for_completion_interruptible(&ctlr->xfer_completion)) {

commit 0dadde344d965566589cd82797893d5aa06557a3
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Apr 13 21:04:06 2020 +0300

    spi: Respect DataBitLength field of SpiSerialBusV2() ACPI resource
    
    By unknown reason the commit 64bee4d28c9e
      ("spi / ACPI: add ACPI enumeration support")
    missed the DataBitLength property to encounter when parse SPI slave
    device data from ACPI.
    
    Fill the gap here.
    
    Fixes: 64bee4d28c9e ("spi / ACPI: add ACPI enumeration support")
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20200413180406.1826-1-andriy.shevchenko@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 0996d238f61e..531d1de85f7f 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2111,6 +2111,7 @@ static int acpi_spi_add_resource(struct acpi_resource *ares, void *data)
 			}
 
 			lookup->max_speed_hz = sb->connection_speed;
+			lookup->bits_per_word = sb->data_bit_length;
 
 			if (sb->clock_phase == ACPI_SPI_SECOND_PHASE)
 				lookup->mode |= SPI_CPHA;

commit 1ba0b52ea73bd46ff053edea21f5630f5277fefe
Merge: 16fbf79b0f83 ebb3b9a92ba9
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Mar 27 15:53:00 2020 +0000

    Merge branch 'spi-5.7' into spi-next

commit 5b16668e638c61a9cd4dffaa41d8b3b6f53f6b3a
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Thu Mar 12 14:45:07 2020 +0100

    spi: acpi: remove superfluous parameter check
    
    to_spi_device() already checks 'dev'. No need to do it before calling
    it.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Niklas SÃ¶derlund <niklas.soderlund+renesas@ragnatech.se>
    Link: https://lore.kernel.org/r/20200312134507.10000-1-wsa@the-dreams.de
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index f6f6b2a0c81c..0996d238f61e 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -4028,7 +4028,7 @@ static struct spi_device *acpi_spi_find_device_by_adev(struct acpi_device *adev)
 	struct device *dev;
 
 	dev = bus_find_device_by_acpi_dev(&spi_bus_type, adev);
-	return dev ? to_spi_device(dev) : NULL;
+	return to_spi_device(dev);
 }
 
 static int acpi_spi_notify(struct notifier_block *nb, unsigned long value,

commit b562b304efc0922d1ef9e7d5b9d333db7497f81a
Merge: caef2df1137a e11e8473bcec
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Mar 11 19:58:20 2020 +0000

    Merge tag 'mtk-mtd-spi-move' of https://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi into spi-5.7
    
    spi: Rewrite mtk-quadspi spi-nor driver with spi-mem
    
    This patchset from Chuanhong Guo <gch981213@gmail.com> adds a spi-mem
    driver for Mediatek SPI-NOR controller, which already has limited
    support by mtk-quadspi. This new driver can make use of full quadspi
    capability of this controller.

commit 671c3bf50ae498dc12aef6c70abe5cfa066b1348
Author: Chuanhong Guo <gch981213@gmail.com>
Date:   Fri Mar 6 16:50:49 2020 +0800

    spi: make spi-max-frequency optional
    
    We only need a spi-max-frequency when we specifically request a
    spi frequency lower than the max speed of spi host.
    This property is already documented as optional property and current
    host drivers are implemented to operate at highest speed possible
    when spi->max_speed_hz is 0.
    This patch makes spi-max-frequency an optional property so that
    we could just omit it to use max controller speed.
    
    Signed-off-by: Chuanhong Guo <gch981213@gmail.com>
    Link: https://lore.kernel.org/r/20200306085052.28258-2-gch981213@gmail.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 38b4c78df506..c0c55dc79972 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1955,13 +1955,8 @@ static int of_spi_parse_dt(struct spi_controller *ctlr, struct spi_device *spi,
 		spi->mode |= SPI_CS_HIGH;
 
 	/* Device speed */
-	rc = of_property_read_u32(nc, "spi-max-frequency", &value);
-	if (rc) {
-		dev_err(&ctlr->dev,
-			"%pOF has no valid 'spi-max-frequency' property (%d)\n", nc, rc);
-		return rc;
-	}
-	spi->max_speed_hz = value;
+	if (!of_property_read_u32(nc, "spi-max-frequency", &value))
+		spi->max_speed_hz = value;
 
 	return 0;
 }

commit ae24a21bbd96a7a4a3e82890285255d7e86540f0
Merge: 43c63729c96f f9981d4f50b4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 6 14:50:16 2020 -0600

    Merge tag 'spi-fix-v5.6-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi
    
    Pull spi fixes from Mark Brown:
     "A selection of small fixes, mostly for drivers, that have arrived
      since the merge window. None of them are earth shattering in
      themselves but all useful for affected systems"
    
    * tag 'spi-fix-v5.6-rc4' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi:
      spi: spi_register_controller(): free bus id on error paths
      spi: bcm63xx-hsspi: Really keep pll clk enabled
      spi: atmel-quadspi: fix possible MMIO window size overrun
      spi/zynqmp: remove entry that causes a cs glitch
      spi: pxa2xx: Add CS control clock quirk
      spi: spidev: Fix CS polarity if GPIO descriptors are used
      spi: qup: call spi_qup_pm_resume_runtime before suspending
      spi: spi-omap2-mcspi: Support probe deferral for DMA channels
      spi: spi-omap2-mcspi: Handle DMA size restriction on AM65x

commit 6a726824aaa3adaaf3bcfca3b471408e225f33d6
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Thu Mar 5 00:00:39 2020 +0200

    spi: Do spi_take_timestamp_pre for as many times as necessary
    
    When dealing with a SPI controller driver that is sending more than 1
    byte at once (or the entire buffer at once), and the SPI peripheral
    driver has requested timestamping for a byte in the middle of the
    buffer, we find that spi_take_timestamp_pre never records a "pre"
    timestamp.
    
    This happens because the function currently expects to be called with
    the "progress" argument >= to what the peripheral has requested to be
    timestamped. But clearly there are cases when that isn't going to fly.
    
    And since we can't change the past when we realize that the opportunity
    to take a "pre" timestamp has just passed and there isn't going to be
    another one, the approach taken is to keep recording the "pre" timestamp
    on each call, overwriting the previously recorded one until the "post"
    timestamp is also taken.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Link: https://lore.kernel.org/r/20200304220044.11193-8-olteanv@gmail.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 292f26807b41..6c223f7d1ddc 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1515,17 +1515,15 @@ void spi_take_timestamp_pre(struct spi_controller *ctlr,
 	if (!xfer->ptp_sts)
 		return;
 
-	if (xfer->timestamped_pre)
+	if (xfer->timestamped)
 		return;
 
-	if (progress < xfer->ptp_sts_word_pre)
+	if (progress > xfer->ptp_sts_word_pre)
 		return;
 
 	/* Capture the resolution of the timestamp */
 	xfer->ptp_sts_word_pre = progress;
 
-	xfer->timestamped_pre = true;
-
 	if (irqs_off) {
 		local_irq_save(ctlr->irq_flags);
 		preempt_disable();
@@ -1554,7 +1552,7 @@ void spi_take_timestamp_post(struct spi_controller *ctlr,
 	if (!xfer->ptp_sts)
 		return;
 
-	if (xfer->timestamped_post)
+	if (xfer->timestamped)
 		return;
 
 	if (progress < xfer->ptp_sts_word_post)
@@ -1570,7 +1568,7 @@ void spi_take_timestamp_post(struct spi_controller *ctlr,
 	/* Capture the resolution of the timestamp */
 	xfer->ptp_sts_word_post = progress;
 
-	xfer->timestamped_post = true;
+	xfer->timestamped = true;
 }
 EXPORT_SYMBOL_GPL(spi_take_timestamp_post);
 
@@ -1675,12 +1673,9 @@ void spi_finalize_current_message(struct spi_controller *ctlr)
 		}
 	}
 
-	if (unlikely(ctlr->ptp_sts_supported)) {
-		list_for_each_entry(xfer, &mesg->transfers, transfer_list) {
-			WARN_ON_ONCE(xfer->ptp_sts && !xfer->timestamped_pre);
-			WARN_ON_ONCE(xfer->ptp_sts && !xfer->timestamped_post);
-		}
-	}
+	if (unlikely(ctlr->ptp_sts_supported))
+		list_for_each_entry(xfer, &mesg->transfers, transfer_list)
+			WARN_ON_ONCE(xfer->ptp_sts && !xfer->timestamped);
 
 	spi_unmap_msg(ctlr, mesg);
 

commit f9981d4f50b475d7dbb70f3022b87a3c8bba9fd6
Author: Aaro Koskinen <aaro.koskinen@nokia.com>
Date:   Wed Mar 4 13:17:40 2020 +0200

    spi: spi_register_controller(): free bus id on error paths
    
    Some error paths leave the bus id allocated. As a result the IDR
    allocation will fail after a deferred probe. Fix by freeing the bus id
    always on error.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@nokia.com>
    Message-Id: <20200304111740.27915-1-aaro.koskinen@nokia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 197c9e0ac2a6..94145b25f446 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2645,7 +2645,7 @@ int spi_register_controller(struct spi_controller *ctlr)
 		if (ctlr->use_gpio_descriptors) {
 			status = spi_get_gpio_descs(ctlr);
 			if (status)
-				return status;
+				goto free_bus_id;
 			/*
 			 * A controller using GPIO descriptors always
 			 * supports SPI_CS_HIGH if need be.
@@ -2655,7 +2655,7 @@ int spi_register_controller(struct spi_controller *ctlr)
 			/* Legacy code path for GPIOs from DT */
 			status = of_spi_get_gpio_numbers(ctlr);
 			if (status)
-				return status;
+				goto free_bus_id;
 		}
 	}
 
@@ -2663,17 +2663,14 @@ int spi_register_controller(struct spi_controller *ctlr)
 	 * Even if it's just one always-selected device, there must
 	 * be at least one chipselect.
 	 */
-	if (!ctlr->num_chipselect)
-		return -EINVAL;
+	if (!ctlr->num_chipselect) {
+		status = -EINVAL;
+		goto free_bus_id;
+	}
 
 	status = device_add(&ctlr->dev);
-	if (status < 0) {
-		/* free bus id */
-		mutex_lock(&board_lock);
-		idr_remove(&spi_master_idr, ctlr->bus_num);
-		mutex_unlock(&board_lock);
-		goto done;
-	}
+	if (status < 0)
+		goto free_bus_id;
 	dev_dbg(dev, "registered %s %s\n",
 			spi_controller_is_slave(ctlr) ? "slave" : "master",
 			dev_name(&ctlr->dev));
@@ -2689,11 +2686,7 @@ int spi_register_controller(struct spi_controller *ctlr)
 		status = spi_controller_initialize_queue(ctlr);
 		if (status) {
 			device_del(&ctlr->dev);
-			/* free bus id */
-			mutex_lock(&board_lock);
-			idr_remove(&spi_master_idr, ctlr->bus_num);
-			mutex_unlock(&board_lock);
-			goto done;
+			goto free_bus_id;
 		}
 	}
 	/* add statistics */
@@ -2708,7 +2701,12 @@ int spi_register_controller(struct spi_controller *ctlr)
 	/* Register devices from the device tree and ACPI */
 	of_register_spi_devices(ctlr);
 	acpi_register_spi_devices(ctlr);
-done:
+	return status;
+
+free_bus_id:
+	mutex_lock(&board_lock);
+	idr_remove(&spi_master_idr, ctlr->bus_num);
+	mutex_unlock(&board_lock);
 	return status;
 }
 EXPORT_SYMBOL_GPL(spi_register_controller);

commit ea23578611dce2eeaf31dcfe12cd7130cf3d1411
Author: John Garry <john.garry@huawei.com>
Date:   Fri Feb 28 23:18:49 2020 +0800

    spi: Allow SPI controller override device buswidth
    
    Currently ACPI firmware description for a SPI device does not have any
    method to describe the data buswidth on the board.
    
    So even through the controller and device may support higher modes than
    standard SPI, it cannot be assumed that the board does - as such, that
    device is limited to standard SPI in such a circumstance.
    
    As a workaround, allow the controller driver supply buswidth override bits,
    which are used inform the core code that the controller driver knows the
    buswidth supported on that board for that device.
    
    A host controller driver might know this info from DMI tables, for example.
    
    Signed-off-by: John Garry <john.garry@huawei.com>
    Link: https://lore.kernel.org/r/1582903131-160033-2-git-send-email-john.garry@huawei.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 38b4c78df506..292f26807b41 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -510,6 +510,7 @@ struct spi_device *spi_alloc_device(struct spi_controller *ctlr)
 	spi->dev.bus = &spi_bus_type;
 	spi->dev.release = spidev_release;
 	spi->cs_gpio = -ENOENT;
+	spi->mode = ctlr->buswidth_override_bits;
 
 	spin_lock_init(&spi->statistics.lock);
 
@@ -2181,9 +2182,10 @@ static acpi_status acpi_register_spi_device(struct spi_controller *ctlr,
 		return AE_NO_MEMORY;
 	}
 
+
 	ACPI_COMPANION_SET(&spi->dev, adev);
 	spi->max_speed_hz	= lookup.max_speed_hz;
-	spi->mode		= lookup.mode;
+	spi->mode		|= lookup.mode;
 	spi->irq		= lookup.irq;
 	spi->bits_per_word	= lookup.bits_per_word;
 	spi->chip_select	= lookup.chip_select;

commit 754a36a58c29718bf5e28b8789b17bffbb60e8a6
Merge: 7265e8fc5108 a5362b84bdff
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Jan 23 12:37:18 2020 +0000

    Merge branch 'spi-5.6' into spi-next

commit 7d93aecdb58d47e8ed90b4a44c0fc9ffb8de941c
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Jan 2 14:38:17 2020 +0100

    spi: Add generic support for unused native cs with cs-gpios
    
    Some SPI master controllers always drive a native chip select when
    performing a transfer.  Hence when using both native and GPIO chip
    selects, at least one native chip select must be left unused, to be
    driven when performing transfers with slave devices using GPIO chip
    selects.
    
    Currently, to find an unused native chip select, SPI controller drivers
    need to parse and process cs-gpios theirselves.  This is not only
    duplicated in each driver that needs it, but also duplicates part of the
    work done later at SPI controller registration time.  Note that this
    cannot be done after spi_register_controller() returns, as at that time,
    slave devices may have been probed already.
    
    Hence add generic support to the SPI subsystem for finding an unused
    native chip select.  Optionally, this unused native chip select, and all
    other in-use native chip selects, can be validated against the maximum
    number of native chip selects available on the controller hardware.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Link: https://lore.kernel.org/r/20200102133822.29346-2-geert+renesas@glider.be
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 5485ef89197c..197c9e0ac2a6 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2464,6 +2464,8 @@ static int spi_get_gpio_descs(struct spi_controller *ctlr)
 	int nb, i;
 	struct gpio_desc **cs;
 	struct device *dev = &ctlr->dev;
+	unsigned long native_cs_mask = 0;
+	unsigned int num_cs_gpios = 0;
 
 	nb = gpiod_count(dev, "cs");
 	ctlr->num_chipselect = max_t(int, nb, ctlr->num_chipselect);
@@ -2505,7 +2507,22 @@ static int spi_get_gpio_descs(struct spi_controller *ctlr)
 			if (!gpioname)
 				return -ENOMEM;
 			gpiod_set_consumer_name(cs[i], gpioname);
+			num_cs_gpios++;
+			continue;
+		}
+
+		if (ctlr->max_native_cs && i >= ctlr->max_native_cs) {
+			dev_err(dev, "Invalid native chip select %d\n", i);
+			return -EINVAL;
 		}
+		native_cs_mask |= BIT(i);
+	}
+
+	ctlr->unused_native_cs = ffz(native_cs_mask);
+	if (num_cs_gpios && ctlr->max_native_cs &&
+	    ctlr->unused_native_cs >= ctlr->max_native_cs) {
+		dev_err(dev, "No unused native chip select available\n");
+		return -EINVAL;
 	}
 
 	return 0;

commit ec7b3f5372e2f674ce19c23ca8f5a2c103025264
Merge: 5acefdc27b73 09b6636cea4f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 6 12:34:44 2020 -0800

    Merge tag 'spi-fix-v5.5-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi
    
    Pull spi fixes from Mark Brown:
     "A small collection of fixes here, one to make the newly added PTP
      timestamping code more accurate, a few driver fixes and a fix for the
      core DT binding to document the fact that we support eight wire buses"
    
    * tag 'spi-fix-v5.5-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi:
      spi: Document Octal mode as valid SPI bus width
      spi: spi-dw: Add lock protect dw_spi rx/tx to prevent concurrent calls
      spi: spi-fsl-dspi: Fix 16-bit word order in 32-bit XSPI mode
      spi: Don't look at TX buffer for PTP system timestamping
      spi: uniphier: Fix FIFO threshold

commit 862dd2a946aa1417f013fb748e2aa0f4349b405b
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Fri Dec 27 03:24:17 2019 +0200

    spi: Don't look at TX buffer for PTP system timestamping
    
    The API for PTP system timestamping (associating a SPI transaction with
    the system time at which it was transferred) is flawed: it assumes that
    the xfer->tx_buf pointer will always be present.
    
    This is, of course, not always the case.
    
    So introduce a "progress" variable that denotes how many word have been
    transferred.
    
    Fix the Freescale DSPI driver, the only user of the API so far, in the
    same patch.
    
    Fixes: b42faeee718c ("spi: Add a PTP system timestamp to the transfer structure")
    Fixes: d6b71dfaeeba ("spi: spi-fsl-dspi: Implement the PTP system timestamping for TCFQ mode")
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Link: https://lore.kernel.org/r/20191227012417.1057-1-olteanv@gmail.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 0d40953b463c..6b95cd957ba7 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1499,8 +1499,7 @@ static void spi_pump_messages(struct kthread_work *work)
  *			    advances its @tx buffer pointer monotonically.
  * @ctlr: Pointer to the spi_controller structure of the driver
  * @xfer: Pointer to the transfer being timestamped
- * @tx: Pointer to the current word within the xfer->tx_buf that the driver is
- *	preparing to transmit right now.
+ * @progress: How many words (not bytes) have been transferred so far
  * @irqs_off: If true, will disable IRQs and preemption for the duration of the
  *	      transfer, for less jitter in time measurement. Only compatible
  *	      with PIO drivers. If true, must follow up with
@@ -1510,21 +1509,19 @@ static void spi_pump_messages(struct kthread_work *work)
  */
 void spi_take_timestamp_pre(struct spi_controller *ctlr,
 			    struct spi_transfer *xfer,
-			    const void *tx, bool irqs_off)
+			    size_t progress, bool irqs_off)
 {
-	u8 bytes_per_word = DIV_ROUND_UP(xfer->bits_per_word, 8);
-
 	if (!xfer->ptp_sts)
 		return;
 
 	if (xfer->timestamped_pre)
 		return;
 
-	if (tx < (xfer->tx_buf + xfer->ptp_sts_word_pre * bytes_per_word))
+	if (progress < xfer->ptp_sts_word_pre)
 		return;
 
 	/* Capture the resolution of the timestamp */
-	xfer->ptp_sts_word_pre = (tx - xfer->tx_buf) / bytes_per_word;
+	xfer->ptp_sts_word_pre = progress;
 
 	xfer->timestamped_pre = true;
 
@@ -1546,23 +1543,20 @@ EXPORT_SYMBOL_GPL(spi_take_timestamp_pre);
  *			     timestamped.
  * @ctlr: Pointer to the spi_controller structure of the driver
  * @xfer: Pointer to the transfer being timestamped
- * @tx: Pointer to the current word within the xfer->tx_buf that the driver has
- *	just transmitted.
+ * @progress: How many words (not bytes) have been transferred so far
  * @irqs_off: If true, will re-enable IRQs and preemption for the local CPU.
  */
 void spi_take_timestamp_post(struct spi_controller *ctlr,
 			     struct spi_transfer *xfer,
-			     const void *tx, bool irqs_off)
+			     size_t progress, bool irqs_off)
 {
-	u8 bytes_per_word = DIV_ROUND_UP(xfer->bits_per_word, 8);
-
 	if (!xfer->ptp_sts)
 		return;
 
 	if (xfer->timestamped_post)
 		return;
 
-	if (tx < (xfer->tx_buf + xfer->ptp_sts_word_post * bytes_per_word))
+	if (progress < xfer->ptp_sts_word_post)
 		return;
 
 	ptp_read_system_postts(xfer->ptp_sts);
@@ -1573,7 +1567,7 @@ void spi_take_timestamp_post(struct spi_controller *ctlr,
 	}
 
 	/* Capture the resolution of the timestamp */
-	xfer->ptp_sts_word_post = (tx - xfer->tx_buf) / bytes_per_word;
+	xfer->ptp_sts_word_post = progress;
 
 	xfer->timestamped_post = true;
 }

commit f971a2074447726ec9a3feee3648a2e157f08248
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Fri Dec 27 03:24:44 2019 +0200

    spi: Catch improper use of PTP system timestamping API
    
    We can catch whether the SPI controller has declared it can take care of
    software timestamping transfers, but didn't. So do it.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Link: https://lore.kernel.org/r/20191227012444.1204-1-olteanv@gmail.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 5e4c4532f7f3..5485ef89197c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1680,6 +1680,13 @@ void spi_finalize_current_message(struct spi_controller *ctlr)
 		}
 	}
 
+	if (unlikely(ctlr->ptp_sts_supported)) {
+		list_for_each_entry(xfer, &mesg->transfers, transfer_list) {
+			WARN_ON_ONCE(xfer->ptp_sts && !xfer->timestamped_pre);
+			WARN_ON_ONCE(xfer->ptp_sts && !xfer->timestamped_post);
+		}
+	}
+
 	spi_unmap_msg(ctlr, mesg);
 
 	if (ctlr->cur_msg_prepared && ctlr->unprepare_message) {

commit ca4196aa10087fe3ba3ce2383761898dc95b5e94
Merge: 8f3ed6d0b0db ffa119f7c42d
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Nov 22 19:56:35 2019 +0000

    Merge branch 'spi-5.5' into spi-next

commit 57a9460705f105e1d79d1410c5cfe285beda8986
Author: Tony Lindgren <tony@atomide.com>
Date:   Mon Nov 11 11:53:34 2019 -0800

    spi: Fix regression to return zero on success instead of positive value
    
    Commit d948e6ca1899 ("spi: add power control when set_cs") added generic
    runtime PM handling, but also changed the return value to be 1 instead
    of 0 that we had earlier as pm_runtime_get functions return a positve
    value on success.
    
    This causes SPI devices to return errors for cases where they do:
    
    ret = spi_setup(spi);
    if (ret)
            return ret;
    
    As in many cases the SPI devices do not check for if (ret < 0).
    
    Let's fix this by setting the status to 0 on succeess after the
    runtime PM calls. Let's not return 0 at the end of the function
    as this might break again later on if the function changes and
    starts returning status again.
    
    Fixes: d948e6ca1899 ("spi: add power control when set_cs")
    Cc: Luhua Xu <luhua.xu@mediatek.com>
    Cc: wsd_upstream@mediatek.com
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Link: https://lore.kernel.org/r/20191111195334.44833-1-tony@atomide.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 294d0038eea6..0d40953b463c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -3269,6 +3269,15 @@ int spi_setup(struct spi_device *spi)
 				status);
 			return status;
 		}
+
+		/*
+		 * We do not want to return positive value from pm_runtime_get,
+		 * there are many instances of devices calling spi_setup() and
+		 * checking for a non-zero return value instead of a negative
+		 * return value.
+		 */
+		status = 0;
+
 		spi_set_cs(spi, false);
 		pm_runtime_mark_last_busy(spi->controller->dev.parent);
 		pm_runtime_put_autosuspend(spi->controller->dev.parent);

commit d948e6ca189985495a21cd622c31e30e72b6b688
Author: Luhua Xu <luhua.xu@mediatek.com>
Date:   Wed Oct 30 17:03:54 2019 +0800

    spi: add power control when set_cs
    
    As to set_cs takes effect immediately, power spi
    is needed when setup spi.
    
    Cc: Mark Brown <broonie@kernel.org>
    Signed-off-by: Luhua Xu <luhua.xu@mediatek.com>
    Link: https://lore.kernel.org/r/1572426234-30019-1-git-send-email-luhua.xu@mediatek.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 5ba19ef809c2..294d0038eea6 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -3261,7 +3261,20 @@ int spi_setup(struct spi_device *spi)
 	if (spi->controller->setup)
 		status = spi->controller->setup(spi);
 
-	spi_set_cs(spi, false);
+	if (spi->controller->auto_runtime_pm && spi->controller->set_cs) {
+		status = pm_runtime_get_sync(spi->controller->dev.parent);
+		if (status < 0) {
+			pm_runtime_put_noidle(spi->controller->dev.parent);
+			dev_err(&spi->controller->dev, "Failed to power device: %d\n",
+				status);
+			return status;
+		}
+		spi_set_cs(spi, false);
+		pm_runtime_mark_last_busy(spi->controller->dev.parent);
+		pm_runtime_put_autosuspend(spi->controller->dev.parent);
+	} else {
+		spi_set_cs(spi, false);
+	}
 
 	if (spi->rt && !spi->controller->rt) {
 		spi->controller->rt = true;

commit 15f794bd977a0135328fbdd8a83cc64c1d267b39
Author: Gregory CLEMENT <gregory.clement@bootlin.com>
Date:   Thu Oct 24 16:13:09 2019 +0200

    spi: Fix NULL pointer when setting SPI_CS_HIGH for GPIO CS
    
    Even if the flag use_gpio_descriptors is set, it is possible that
    cs_gpiods was not allocated, which leads to a kernel crash.
    
    Reported-by: "kernelci.org bot" <bot@kernelci.org>
    Fixes: 3e5ec1db8bfe ("spi: Fix SPI_CS_HIGH setting when using native and GPIO CS")
    Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
    Link: https://lore.kernel.org/r/20191024141309.22434-1-gregory.clement@bootlin.com
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: <stable@vger.kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 38699eaebcea..26b91ee0855d 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1780,7 +1780,8 @@ static int of_spi_parse_dt(struct spi_controller *ctlr, struct spi_device *spi,
 	 * handled in the gpiolib, so all gpio chip selects are "active high"
 	 * in the logical sense, the gpiolib will invert the line if need be.
 	 */
-	if ((ctlr->use_gpio_descriptors) && ctlr->cs_gpiods[spi->chip_select])
+	if ((ctlr->use_gpio_descriptors) && ctlr->cs_gpiods &&
+	    ctlr->cs_gpiods[spi->chip_select])
 		spi->mode |= SPI_CS_HIGH;
 
 	/* Device speed */

commit be73e323aee4e10eccef2b0f862c0196f392f012
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Oct 23 15:16:43 2019 +0300

    spi: Fix spelling in the comments
    
    Two spelling mistakes are being fixed.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20191023121643.25237-1-andriy.shevchenko@linux.intel.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 5414a10afd65..5ba19ef809c2 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -92,7 +92,7 @@ static ssize_t driver_override_store(struct device *dev,
 	if (len) {
 		spi->driver_override = driver_override;
 	} else {
-		/* Emptry string, disable driver override */
+		/* Empty string, disable driver override */
 		spi->driver_override = NULL;
 		kfree(driver_override);
 	}
@@ -469,7 +469,7 @@ static LIST_HEAD(board_list);
 static LIST_HEAD(spi_controller_list);
 
 /*
- * Used to protect add/del opertion for board_info list and
+ * Used to protect add/del operation for board_info list and
  * spi_controller list, and their matching process
  * also used to protect object of type struct idr
  */

commit 112d6212c80a1c560757520bd822a41c0ad15c2c
Merge: 3e5ec1db8bfe 4f5cafb5cb84
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Oct 18 18:30:49 2019 +0100

    Merge tag 'v5.4-rc3' into spi-5.4
    
    Linux 5.4-rc3

commit 3e5ec1db8bfee845d9f8560d1c64aeaccd586398
Author: Gregory CLEMENT <gregory.clement@bootlin.com>
Date:   Fri Oct 18 17:29:29 2019 +0200

    spi: Fix SPI_CS_HIGH setting when using native and GPIO CS
    
    When improving the CS GPIO support at core level, the SPI_CS_HIGH
    has been enabled for all the CS lines used for a given SPI controller.
    
    However, the SPI framework allows to have on the same controller native
    CS and GPIO CS. The native CS may not support the SPI_CS_HIGH, so they
    should not be setup automatically.
    
    With this patch the setting is done only for the CS that will use a
    GPIO as CS
    
    Fixes: f3186dd87669 ("spi: Optionally use GPIO descriptors for CS GPIOs")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
    Link: https://lore.kernel.org/r/20191018152929.3287-1-gregory.clement@bootlin.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index f8b4654a57d3..d07517151340 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1711,15 +1711,7 @@ static int of_spi_parse_dt(struct spi_controller *ctlr, struct spi_device *spi,
 		spi->mode |= SPI_3WIRE;
 	if (of_property_read_bool(nc, "spi-lsb-first"))
 		spi->mode |= SPI_LSB_FIRST;
-
-	/*
-	 * For descriptors associated with the device, polarity inversion is
-	 * handled in the gpiolib, so all chip selects are "active high" in
-	 * the logical sense, the gpiolib will invert the line if need be.
-	 */
-	if (ctlr->use_gpio_descriptors)
-		spi->mode |= SPI_CS_HIGH;
-	else if (of_property_read_bool(nc, "spi-cs-high"))
+	if (of_property_read_bool(nc, "spi-cs-high"))
 		spi->mode |= SPI_CS_HIGH;
 
 	/* Device DUAL/QUAD mode */
@@ -1783,6 +1775,14 @@ static int of_spi_parse_dt(struct spi_controller *ctlr, struct spi_device *spi,
 	}
 	spi->chip_select = value;
 
+	/*
+	 * For descriptors associated with the device, polarity inversion is
+	 * handled in the gpiolib, so all gpio chip selects are "active high"
+	 * in the logical sense, the gpiolib will invert the line if need be.
+	 */
+	if ((ctlr->use_gpio_descriptors) && ctlr->cs_gpiods[spi->chip_select])
+		spi->mode |= SPI_CS_HIGH;
+
 	/* Device speed */
 	rc = of_property_read_u32(nc, "spi-max-frequency", &value);
 	if (rc) {

commit 3984d39b0e41ac4de8b4530ae3911ccf52ed4bbf
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:44 2019 +0300

    spi: spi-fsl-espi: convert transfer delay to `spi_delay` format
    
    The way the max delay is computed for this controller, it looks like it is
    searching for the max delay from an SPI message a using that.
    
    No idea if this is valid. But this change should support both `delay_usecs`
    and the new `delay` data which is of `spi_delay` type.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-17-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 21628b0728f1..5414a10afd65 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1120,7 +1120,7 @@ static void _spi_transfer_delay_ns(u32 ns)
 	}
 }
 
-static int _spi_delay_to_ns(struct spi_delay *_delay, struct spi_transfer *xfer)
+int spi_delay_to_ns(struct spi_delay *_delay, struct spi_transfer *xfer)
 {
 	u32 delay = _delay->value;
 	u32 unit = _delay->unit;
@@ -1153,6 +1153,7 @@ static int _spi_delay_to_ns(struct spi_delay *_delay, struct spi_transfer *xfer)
 
 	return delay;
 }
+EXPORT_SYMBOL_GPL(spi_delay_to_ns);
 
 int spi_delay_exec(struct spi_delay *_delay, struct spi_transfer *xfer)
 {
@@ -1161,7 +1162,7 @@ int spi_delay_exec(struct spi_delay *_delay, struct spi_transfer *xfer)
 	if (!_delay)
 		return -EINVAL;
 
-	delay = _spi_delay_to_ns(_delay, xfer);
+	delay = spi_delay_to_ns(_delay, xfer);
 	if (delay < 0)
 		return delay;
 
@@ -3333,11 +3334,11 @@ static int _spi_xfer_word_delay_update(struct spi_transfer *xfer,
 {
 	int delay1, delay2;
 
-	delay1 = _spi_delay_to_ns(&xfer->word_delay, xfer);
+	delay1 = spi_delay_to_ns(&xfer->word_delay, xfer);
 	if (delay1 < 0)
 		return delay1;
 
-	delay2 = _spi_delay_to_ns(&spi->word_delay, xfer);
+	delay2 = spi_delay_to_ns(&spi->word_delay, xfer);
 	if (delay2 < 0)
 		return delay2;
 

commit 25093bdeb6bcae728e12e3795261dbd3677060a9
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:43 2019 +0300

    spi: implement SW control for CS times
    
    This change implements CS control for setup, hold & inactive delays.
    
    The `cs_setup` delay is completely new, and can help with cases where
    asserting the CS, also brings the device out of power-sleep, where there
    needs to be a longer (than usual), before transferring data.
    
    The `cs_hold` time can overlap with the `delay` (or `delay_usecs`) from an
    SPI transfer. The main difference is that `cs_hold` implies that CS will be
    de-asserted.
    
    The `cs_inactive` delay does not have a clear use-case yet. It has been
    implemented mostly because the `spi_set_cs_timing()` function implements
    it. To some degree, this could overlap or replace `cs_change_delay`, but
    this will require more consideration/investigation in the future.
    
    All these delays have been added to the `spi_controller` struct, as they
    would typically be configured by calling `spi_set_cs_timing()` after an
    `spi_setup()` call.
    
    Software-mode for CS control, implies that the `set_cs_timing()` hook has
    not been provided for the `spi_controller` object.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-16-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 6beeb363515c..21628b0728f1 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -775,6 +775,15 @@ int spi_register_board_info(struct spi_board_info const *info, unsigned n)
 
 static void spi_set_cs(struct spi_device *spi, bool enable)
 {
+	bool enable1 = enable;
+
+	if (!spi->controller->set_cs_timing) {
+		if (enable1)
+			spi_delay_exec(&spi->controller->cs_setup, NULL);
+		else
+			spi_delay_exec(&spi->controller->cs_hold, NULL);
+	}
+
 	if (spi->mode & SPI_CS_HIGH)
 		enable = !enable;
 
@@ -800,6 +809,11 @@ static void spi_set_cs(struct spi_device *spi, bool enable)
 	} else if (spi->controller->set_cs) {
 		spi->controller->set_cs(spi, !enable);
 	}
+
+	if (!spi->controller->set_cs_timing) {
+		if (!enable1)
+			spi_delay_exec(&spi->controller->cs_inactive, NULL);
+	}
 }
 
 #ifdef CONFIG_HAS_DMA
@@ -3278,10 +3292,39 @@ EXPORT_SYMBOL_GPL(spi_setup);
 int spi_set_cs_timing(struct spi_device *spi, struct spi_delay *setup,
 		      struct spi_delay *hold, struct spi_delay *inactive)
 {
+	size_t len;
+
 	if (spi->controller->set_cs_timing)
 		return spi->controller->set_cs_timing(spi, setup, hold,
 						      inactive);
-	return -ENOTSUPP;
+
+	if ((setup && setup->unit == SPI_DELAY_UNIT_SCK) ||
+	    (hold && hold->unit == SPI_DELAY_UNIT_SCK) ||
+	    (inactive && inactive->unit == SPI_DELAY_UNIT_SCK)) {
+		dev_err(&spi->dev,
+			"Clock-cycle delays for CS not supported in SW mode\n");
+		return -ENOTSUPP;
+	}
+
+	len = sizeof(struct spi_delay);
+
+	/* copy delays to controller */
+	if (setup)
+		memcpy(&spi->controller->cs_setup, setup, len);
+	else
+		memset(&spi->controller->cs_setup, 0, len);
+
+	if (hold)
+		memcpy(&spi->controller->cs_hold, hold, len);
+	else
+		memset(&spi->controller->cs_hold, 0, len);
+
+	if (inactive)
+		memcpy(&spi->controller->cs_inactive, inactive, len);
+	else
+		memset(&spi->controller->cs_inactive, 0, len);
+
+	return 0;
 }
 EXPORT_SYMBOL_GPL(spi_set_cs_timing);
 

commit 8105936684681195d9073880b06a123b2e316811
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:42 2019 +0300

    spi: tegra114: change format for `spi_set_cs_timing()` function
    
    The initial version of `spi_set_cs_timing()` was implemented with
    consideration only for clock-cycles as delay.
    
    For cases like `CS setup` time, it's sometimes needed that micro-seconds
    (or nano-seconds) are required, or sometimes even longer delays, for cases
    where the device needs a little longer to start transferring that after CS
    is asserted.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-15-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 2e448078a117..6beeb363515c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -3269,15 +3269,19 @@ EXPORT_SYMBOL_GPL(spi_setup);
 /**
  * spi_set_cs_timing - configure CS setup, hold, and inactive delays
  * @spi: the device that requires specific CS timing configuration
- * @setup: CS setup time in terms of clock count
- * @hold: CS hold time in terms of clock count
- * @inactive_dly: CS inactive delay between transfers in terms of clock count
+ * @setup: CS setup time specified via @spi_delay
+ * @hold: CS hold time specified via @spi_delay
+ * @inactive: CS inactive delay between transfers specified via @spi_delay
+ *
+ * Return: zero on success, else a negative error code.
  */
-void spi_set_cs_timing(struct spi_device *spi, u8 setup, u8 hold,
-		       u8 inactive_dly)
+int spi_set_cs_timing(struct spi_device *spi, struct spi_delay *setup,
+		      struct spi_delay *hold, struct spi_delay *inactive)
 {
 	if (spi->controller->set_cs_timing)
-		spi->controller->set_cs_timing(spi, setup, hold, inactive_dly);
+		return spi->controller->set_cs_timing(spi, setup, hold,
+						      inactive);
+	return -ENOTSUPP;
 }
 EXPORT_SYMBOL_GPL(spi_set_cs_timing);
 

commit bebcfd272df648542c458d28fbd6a8f9428b5310
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:36 2019 +0300

    spi: introduce `delay` field for `spi_transfer` + spi_transfer_delay_exec()
    
    The change introduces the `delay` field to the `spi_transfer` struct as an
    `struct spi_delay` type.
    This intends to eventually replace `delay_usecs`.
    
    But, since there are many users of `delay_usecs`, this needs some
    intermediate work.
    A helper called `spi_transfer_delay_exec()` is also added, which maintains
    backwards compatibility with `delay_usecs`, by assigning the value to
    `delay` if non-zero.
    This should maintain backwards compatibility with current users of
    `udelay_usecs`.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-9-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 307e440dd92d..2e448078a117 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1248,8 +1248,7 @@ static int spi_transfer_one_message(struct spi_controller *ctlr,
 		if (msg->status != -EINPROGRESS)
 			goto out;
 
-		if (xfer->delay_usecs)
-			_spi_transfer_delay_ns(xfer->delay_usecs * 1000);
+		spi_transfer_delay_exec(xfer);
 
 		if (xfer->cs_change) {
 			if (list_is_last(&xfer->transfer_list,
@@ -3026,10 +3025,11 @@ struct spi_replaced_transfers *spi_replace_transfers(
 		/* add to list */
 		list_add(&xfer->transfer_list, rxfer->replaced_after);
 
-		/* clear cs_change and delay_usecs for all but the last */
+		/* clear cs_change and delay for all but the last */
 		if (i) {
 			xfer->cs_change = false;
 			xfer->delay_usecs = 0;
+			xfer->delay.value = 0;
 		}
 	}
 

commit 6c613f68aabf33385c01e949204ac5ed30887161
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:35 2019 +0300

    spi: core,atmel: convert `word_delay_usecs` -> `word_delay` for spi_device
    
    This change does a conversion from the `word_delay_usecs` -> `word_delay`
    for the `spi_device` struct.
    
    This allows users to specify inter-word delays in other unit types
    (nano-seconds or clock cycles), depending on how users want.
    
    The Atmel SPI driver is the only current user of the `word_delay_usecs`
    field (from the `spi_device` struct).
    So, it needed a slight conversion to use the `word_delay` as an `spi_delay`
    struct.
    
    In SPI core, the only required mechanism is to update the `word_delay`
    information per `spi_transfer`. This requires a bit more logic than before,
    because it needs that both delays be converted to a common unit
    (nano-seconds) for comparison.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-8-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b69c14082c52..307e440dd92d 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -3281,6 +3281,26 @@ void spi_set_cs_timing(struct spi_device *spi, u8 setup, u8 hold,
 }
 EXPORT_SYMBOL_GPL(spi_set_cs_timing);
 
+static int _spi_xfer_word_delay_update(struct spi_transfer *xfer,
+				       struct spi_device *spi)
+{
+	int delay1, delay2;
+
+	delay1 = _spi_delay_to_ns(&xfer->word_delay, xfer);
+	if (delay1 < 0)
+		return delay1;
+
+	delay2 = _spi_delay_to_ns(&spi->word_delay, xfer);
+	if (delay2 < 0)
+		return delay2;
+
+	if (delay1 < delay2)
+		memcpy(&xfer->word_delay, &spi->word_delay,
+		       sizeof(xfer->word_delay));
+
+	return 0;
+}
+
 static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 {
 	struct spi_controller *ctlr = spi->controller;
@@ -3416,8 +3436,8 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 				return -EINVAL;
 		}
 
-		if (xfer->word_delay_usecs < spi->word_delay_usecs)
-			xfer->word_delay_usecs = spi->word_delay_usecs;
+		if (_spi_xfer_word_delay_update(xfer, spi))
+			return -EINVAL;
 	}
 
 	message->status = -EINPROGRESS;

commit 329f0dac4cad9fa4b1439a88180d91bcb5c4eaf8
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:31 2019 +0300

    spi: make `cs_change_delay` the first user of the `spi_delay` logic
    
    Since the logic for `spi_delay` struct + `spi_delay_exec()` has been copied
    from the `cs_change_delay` logic, it's natural to make this delay, the
    first user.
    
    The `cs_change_delay` logic requires that the default remain 10 uS, in case
    it is unspecified/unconfigured. So, there is some special handling needed
    to do that.
    
    The ADIS library is one of the few users of the new `cs_change_delay`
    parameter for an spi_transfer.
    
    The introduction of the `spi_delay` struct, requires that the users of of
    `cs_change_delay` get an update. This change also updates the ADIS library.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-4-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 7499a4efbaba..b69c14082c52 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1160,9 +1160,9 @@ EXPORT_SYMBOL_GPL(spi_delay_exec);
 static void _spi_transfer_cs_change_delay(struct spi_message *msg,
 					  struct spi_transfer *xfer)
 {
-	u32 delay = xfer->cs_change_delay;
-	u32 unit = xfer->cs_change_delay_unit;
-	u32 hz;
+	u32 delay = xfer->cs_change_delay.value;
+	u32 unit = xfer->cs_change_delay.unit;
+	int ret;
 
 	/* return early on "fast" mode - for everything but USECS */
 	if (!delay) {
@@ -1171,27 +1171,13 @@ static void _spi_transfer_cs_change_delay(struct spi_message *msg,
 		return;
 	}
 
-	switch (unit) {
-	case SPI_DELAY_UNIT_USECS:
-		delay *= 1000;
-		break;
-	case SPI_DELAY_UNIT_NSECS: /* nothing to do here */
-		break;
-	case SPI_DELAY_UNIT_SCK:
-		/* if there is no effective speed know, then approximate
-		 * by underestimating with half the requested hz
-		 */
-		hz = xfer->effective_speed_hz ?: xfer->speed_hz / 2;
-		delay *= DIV_ROUND_UP(1000000000, hz);
-		break;
-	default:
+	ret = spi_delay_exec(&xfer->cs_change_delay, xfer);
+	if (ret) {
 		dev_err_once(&msg->spi->dev,
 			     "Use of unsupported delay unit %i, using default of 10us\n",
-			     xfer->cs_change_delay_unit);
-		delay = 10000;
+			     unit);
+		_spi_transfer_delay_ns(10000);
 	}
-	/* now sleep for the requested amount of time */
-	_spi_transfer_delay_ns(delay);
 }
 
 /*

commit b2c98153f45fc17b9fcb241000f2d131ddea6030
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:30 2019 +0300

    spi: introduce spi_delay struct as "value + unit" & spi_delay_exec()
    
    There are plenty of delays that have been introduced in SPI core. Most of
    them are in micro-seconds, some need to be in nano-seconds, and some in
    clock-cycles.
    
    For some of these delays (related to transfers & CS timing) it may make
    sense to have a `spi_delay` struct that abstracts these a bit.
    
    The important element of these delays [for unification] seems to be the
    `unit` of the delay.
    It looks like micro-seconds is good enough for most people, but every-once
    in a while, some delays seem to require other units of measurement.
    
    This change adds the `spi_delay` struct & a `spi_delay_exec()` function
    that processes a `spi_delay` object/struct to execute the delay.
    It's a copy of the `cs_change_delay` mechanism, but without the default
    for 10 uS.
    
    The clock-cycle delay unit is a bit special, as it needs to be bound to an
    `spi_transfer` object to execute.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-3-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 7ba981cdb86b..7499a4efbaba 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1106,6 +1106,57 @@ static void _spi_transfer_delay_ns(u32 ns)
 	}
 }
 
+static int _spi_delay_to_ns(struct spi_delay *_delay, struct spi_transfer *xfer)
+{
+	u32 delay = _delay->value;
+	u32 unit = _delay->unit;
+	u32 hz;
+
+	if (!delay)
+		return 0;
+
+	switch (unit) {
+	case SPI_DELAY_UNIT_USECS:
+		delay *= 1000;
+		break;
+	case SPI_DELAY_UNIT_NSECS: /* nothing to do here */
+		break;
+	case SPI_DELAY_UNIT_SCK:
+		/* clock cycles need to be obtained from spi_transfer */
+		if (!xfer)
+			return -EINVAL;
+		/* if there is no effective speed know, then approximate
+		 * by underestimating with half the requested hz
+		 */
+		hz = xfer->effective_speed_hz ?: xfer->speed_hz / 2;
+		if (!hz)
+			return -EINVAL;
+		delay *= DIV_ROUND_UP(1000000000, hz);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return delay;
+}
+
+int spi_delay_exec(struct spi_delay *_delay, struct spi_transfer *xfer)
+{
+	int delay;
+
+	if (!_delay)
+		return -EINVAL;
+
+	delay = _spi_delay_to_ns(_delay, xfer);
+	if (delay < 0)
+		return delay;
+
+	_spi_transfer_delay_ns(delay);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(spi_delay_exec);
+
 static void _spi_transfer_cs_change_delay(struct spi_message *msg,
 					  struct spi_transfer *xfer)
 {

commit 6b3f236a998550dba91a46a22feb1cc02f39fb06
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:29 2019 +0300

    spi: move `cs_change_delay` backwards compat logic outside switch
    
    The `cs_change_delay` backwards compatibility value could be moved outside
    of the switch statement.
    The only reason to do it, is to make the next patches easier to diff.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-2-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 9bb36c32cbf9..7ba981cdb86b 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1114,16 +1114,15 @@ static void _spi_transfer_cs_change_delay(struct spi_message *msg,
 	u32 hz;
 
 	/* return early on "fast" mode - for everything but USECS */
-	if (!delay && unit != SPI_DELAY_UNIT_USECS)
+	if (!delay) {
+		if (unit == SPI_DELAY_UNIT_USECS)
+			_spi_transfer_delay_ns(10000);
 		return;
+	}
 
 	switch (unit) {
 	case SPI_DELAY_UNIT_USECS:
-		/* for compatibility use default of 10us */
-		if (!delay)
-			delay = 10000;
-		else
-			delay *= 1000;
+		delay *= 1000;
 		break;
 	case SPI_DELAY_UNIT_NSECS: /* nothing to do here */
 		break;

commit b42faeee718ce13ef6eb99c24880b58deb54c8fa
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Thu Sep 5 04:01:12 2019 +0300

    spi: Add a PTP system timestamp to the transfer structure
    
    SPI is one of the interfaces used to access devices which have a POSIX
    clock driver (real time clocks, 1588 timers etc). The fact that the SPI
    bus is slow is not what the main problem is, but rather the fact that
    drivers don't take a constant amount of time in transferring data over
    SPI. When there is a high delay in the readout of time, there will be
    uncertainty in the value that has been read out of the peripheral.
    When that delay is constant, the uncertainty can at least be
    approximated with a certain accuracy which is fine more often than not.
    
    Timing jitter occurs all over in the kernel code, and is mainly caused
    by having to let go of the CPU for various reasons such as preemption,
    servicing interrupts, going to sleep, etc. Another major reason is CPU
    dynamic frequency scaling.
    
    It turns out that the problem of retrieving time from a SPI peripheral
    with high accuracy can be solved by the use of "PTP system
    timestamping" - a mechanism to correlate the time when the device has
    snapshotted its internal time counter with the Linux system time at that
    same moment. This is sufficient for having a precise time measurement -
    it is not necessary for the whole SPI transfer to be transmitted "as
    fast as possible", or "as low-jitter as possible". The system has to be
    low-jitter for a very short amount of time to be effective.
    
    This patch introduces a PTP system timestamping mechanism in struct
    spi_transfer. This is to be used by SPI device drivers when they need to
    know the exact time at which the underlying device's time was
    snapshotted. More often than not, SPI peripherals have a very exact
    timing for when their SPI-to-interconnect bridge issues a transaction
    for snapshotting and reading the time register, and that will be
    dependent on when the SPI-to-interconnect bridge figures out that this
    is what it should do, aka as soon as it sees byte N of the SPI transfer.
    Since spi_device drivers are the ones who'd know best how the peripheral
    behaves in this regard, expose a mechanism in spi_transfer which allows
    them to specify which word (or word range) from the transfer should be
    timestamped.
    
    Add a default implementation of the PTP system timestamping in the SPI
    core. This is not going to be satisfactory performance-wise, but should
    at least increase the likelihood that SPI device drivers will use PTP
    system timestamping in the future.
    There are 3 entry points from the core towards the SPI controller
    drivers:
    
    - transfer_one: The driver is passed individual spi_transfers to
      execute. This is the easiest to timestamp.
    
    - transfer_one_message: The core passes the driver an entire spi_message
      (a potential batch of spi_transfers). The core puts the same pre and
      post timestamp to all transfers within a message. This is not ideal,
      but nothing better can be done by default anyway, since the core has
      no insight into how the driver batches the transfers.
    
    - transfer: Like transfer_one_message, but for unqueued drivers (i.e.
      the driver implements its own queue scheduling).
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Link: https://lore.kernel.org/r/20190905010114.26718-3-olteanv@gmail.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index f9502dbbb5c1..9bb36c32cbf9 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1171,6 +1171,11 @@ static int spi_transfer_one_message(struct spi_controller *ctlr,
 		spi_statistics_add_transfer_stats(statm, xfer, ctlr);
 		spi_statistics_add_transfer_stats(stats, xfer, ctlr);
 
+		if (!ctlr->ptp_sts_supported) {
+			xfer->ptp_sts_word_pre = 0;
+			ptp_read_system_prets(xfer->ptp_sts);
+		}
+
 		if (xfer->tx_buf || xfer->rx_buf) {
 			reinit_completion(&ctlr->xfer_completion);
 
@@ -1197,6 +1202,11 @@ static int spi_transfer_one_message(struct spi_controller *ctlr,
 					xfer->len);
 		}
 
+		if (!ctlr->ptp_sts_supported) {
+			ptp_read_system_postts(xfer->ptp_sts);
+			xfer->ptp_sts_word_post = xfer->len;
+		}
+
 		trace_spi_transfer_stop(msg, xfer);
 
 		if (msg->status != -EINPROGRESS)
@@ -1265,6 +1275,7 @@ EXPORT_SYMBOL_GPL(spi_finalize_current_transfer);
  */
 static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 {
+	struct spi_transfer *xfer;
 	struct spi_message *msg;
 	bool was_busy = false;
 	unsigned long flags;
@@ -1391,6 +1402,13 @@ static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 		goto out;
 	}
 
+	if (!ctlr->ptp_sts_supported && !ctlr->transfer_one) {
+		list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+			xfer->ptp_sts_word_pre = 0;
+			ptp_read_system_prets(xfer->ptp_sts);
+		}
+	}
+
 	ret = ctlr->transfer_one_message(ctlr, msg);
 	if (ret) {
 		dev_err(&ctlr->dev,
@@ -1418,6 +1436,99 @@ static void spi_pump_messages(struct kthread_work *work)
 	__spi_pump_messages(ctlr, true);
 }
 
+/**
+ * spi_take_timestamp_pre - helper for drivers to collect the beginning of the
+ *			    TX timestamp for the requested byte from the SPI
+ *			    transfer. The frequency with which this function
+ *			    must be called (once per word, once for the whole
+ *			    transfer, once per batch of words etc) is arbitrary
+ *			    as long as the @tx buffer offset is greater than or
+ *			    equal to the requested byte at the time of the
+ *			    call. The timestamp is only taken once, at the
+ *			    first such call. It is assumed that the driver
+ *			    advances its @tx buffer pointer monotonically.
+ * @ctlr: Pointer to the spi_controller structure of the driver
+ * @xfer: Pointer to the transfer being timestamped
+ * @tx: Pointer to the current word within the xfer->tx_buf that the driver is
+ *	preparing to transmit right now.
+ * @irqs_off: If true, will disable IRQs and preemption for the duration of the
+ *	      transfer, for less jitter in time measurement. Only compatible
+ *	      with PIO drivers. If true, must follow up with
+ *	      spi_take_timestamp_post or otherwise system will crash.
+ *	      WARNING: for fully predictable results, the CPU frequency must
+ *	      also be under control (governor).
+ */
+void spi_take_timestamp_pre(struct spi_controller *ctlr,
+			    struct spi_transfer *xfer,
+			    const void *tx, bool irqs_off)
+{
+	u8 bytes_per_word = DIV_ROUND_UP(xfer->bits_per_word, 8);
+
+	if (!xfer->ptp_sts)
+		return;
+
+	if (xfer->timestamped_pre)
+		return;
+
+	if (tx < (xfer->tx_buf + xfer->ptp_sts_word_pre * bytes_per_word))
+		return;
+
+	/* Capture the resolution of the timestamp */
+	xfer->ptp_sts_word_pre = (tx - xfer->tx_buf) / bytes_per_word;
+
+	xfer->timestamped_pre = true;
+
+	if (irqs_off) {
+		local_irq_save(ctlr->irq_flags);
+		preempt_disable();
+	}
+
+	ptp_read_system_prets(xfer->ptp_sts);
+}
+EXPORT_SYMBOL_GPL(spi_take_timestamp_pre);
+
+/**
+ * spi_take_timestamp_post - helper for drivers to collect the end of the
+ *			     TX timestamp for the requested byte from the SPI
+ *			     transfer. Can be called with an arbitrary
+ *			     frequency: only the first call where @tx exceeds
+ *			     or is equal to the requested word will be
+ *			     timestamped.
+ * @ctlr: Pointer to the spi_controller structure of the driver
+ * @xfer: Pointer to the transfer being timestamped
+ * @tx: Pointer to the current word within the xfer->tx_buf that the driver has
+ *	just transmitted.
+ * @irqs_off: If true, will re-enable IRQs and preemption for the local CPU.
+ */
+void spi_take_timestamp_post(struct spi_controller *ctlr,
+			     struct spi_transfer *xfer,
+			     const void *tx, bool irqs_off)
+{
+	u8 bytes_per_word = DIV_ROUND_UP(xfer->bits_per_word, 8);
+
+	if (!xfer->ptp_sts)
+		return;
+
+	if (xfer->timestamped_post)
+		return;
+
+	if (tx < (xfer->tx_buf + xfer->ptp_sts_word_post * bytes_per_word))
+		return;
+
+	ptp_read_system_postts(xfer->ptp_sts);
+
+	if (irqs_off) {
+		local_irq_restore(ctlr->irq_flags);
+		preempt_enable();
+	}
+
+	/* Capture the resolution of the timestamp */
+	xfer->ptp_sts_word_post = (tx - xfer->tx_buf) / bytes_per_word;
+
+	xfer->timestamped_post = true;
+}
+EXPORT_SYMBOL_GPL(spi_take_timestamp_post);
+
 /**
  * spi_set_thread_rt - set the controller to pump at realtime priority
  * @ctlr: controller to boost priority of
@@ -1503,6 +1614,7 @@ EXPORT_SYMBOL_GPL(spi_get_next_queued_message);
  */
 void spi_finalize_current_message(struct spi_controller *ctlr)
 {
+	struct spi_transfer *xfer;
 	struct spi_message *mesg;
 	unsigned long flags;
 	int ret;
@@ -1511,6 +1623,13 @@ void spi_finalize_current_message(struct spi_controller *ctlr)
 	mesg = ctlr->cur_msg;
 	spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 
+	if (!ctlr->ptp_sts_supported && !ctlr->transfer_one) {
+		list_for_each_entry(xfer, &mesg->transfers, transfer_list) {
+			ptp_read_system_postts(xfer->ptp_sts);
+			xfer->ptp_sts_word_post = xfer->len;
+		}
+	}
+
 	spi_unmap_msg(ctlr, mesg);
 
 	if (ctlr->cur_msg_prepared && ctlr->unprepare_message) {
@@ -3273,6 +3392,7 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 static int __spi_async(struct spi_device *spi, struct spi_message *message)
 {
 	struct spi_controller *ctlr = spi->controller;
+	struct spi_transfer *xfer;
 
 	/*
 	 * Some controllers do not support doing regular SPI transfers. Return
@@ -3288,6 +3408,13 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
 
 	trace_spi_message_submit(message);
 
+	if (!ctlr->ptp_sts_supported) {
+		list_for_each_entry(xfer, &message->transfers, transfer_list) {
+			xfer->ptp_sts_word_pre = 0;
+			ptp_read_system_prets(xfer->ptp_sts);
+		}
+	}
+
 	return ctlr->transfer(spi, message);
 }
 

commit 4feaab05dc1eda3dbb57b097377766002e7a7cb9
Merge: e7345f92c27a 6d4faf3b6b6e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 17 18:40:42 2019 -0700

    Merge tag 'leds-for-5.4-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/j.anaszewski/linux-leds
    
    Pull LED updates from Jacek Anaszewski:
     "In this cycle we've finally managed to contribute the patch set
      sorting out LED naming issues. Besides that there are many changes
      scattered among various LED class drivers and triggers.
    
      LED naming related improvements:
    
       - add new 'function' and 'color' fwnode properties and deprecate
         'label' property which has been frequently abused for conveying
         vendor specific names that have been available in sysfs anyway
    
       - introduce a set of standard LED_FUNCTION* definitions
    
       - introduce a set of standard LED_COLOR_ID* definitions
    
       - add a new {devm_}led_classdev_register_ext() API with the
         capability of automatic LED name composition basing on the
         properties available in the passed fwnode; the function is
         backwards compatible in a sense that it uses 'label' data, if
         present in the fwnode, for creating LED name
    
       - add tools/leds/get_led_device_info.sh script for retrieving LED
         vendor, product and bus names, if applicable; it also performs
         basic validation of an LED name
    
       - update following drivers and their DT bindings to use the new LED
         registration API:
    
            - leds-an30259a, leds-gpio, leds-as3645a, leds-aat1290, leds-cr0014114,
              leds-lm3601x, leds-lm3692x, leds-lp8860, leds-lt3593, leds-sc27xx-blt
    
      Other LED class improvements:
    
       - replace {devm_}led_classdev_register() macros with inlines
    
       - allow to call led_classdev_unregister() unconditionally
    
       - switch to use fwnode instead of be stuck with OF one
    
      LED triggers improvements:
    
       - led-triggers:
            - fix dereferencing of null pointer
            - fix a memory leak bug
    
       - ledtrig-gpio:
            - GPIO 0 is valid
    
      Drop superseeded apu2/3 support from leds-apu since for apu2+ a newer,
      more complete driver exists, based on a generic driver for the AMD
      SOCs gpio-controller, supporting LEDs as well other devices:
    
       - drop profile field from priv data
    
       - drop iosize field from priv data
    
       - drop enum_apu_led_platform_types
    
       - drop superseeded apu2/3 led support
    
       - add pr_fmt prefix for better log output
    
       - fix error message on probing failure
    
      Other misc fixes and improvements to existing LED class drivers:
    
       - leds-ns2, leds-max77650:
            - add of_node_put() before return
    
       - leds-pwm, leds-is31fl32xx:
            - use struct_size() helper
    
       - leds-lm3697, leds-lm36274, leds-lm3532:
            - switch to use fwnode_property_count_uXX()
    
       - leds-lm3532:
            - fix brightness control for i2c mode
            - change the define for the fs current register
            - fixes for the driver for stability
            - add full scale current configuration
            - dt: Add property for full scale current.
            - avoid potentially unpaired regulator calls
            - move static keyword to the front of declarations
            - fix optional led-max-microamp prop error handling
    
       - leds-max77650:
            - add of_node_put() before return
            - add MODULE_ALIAS()
            - Switch to fwnode property API
    
       - leds-as3645a:
            - fix misuse of strlcpy
    
       - leds-netxbig:
            - add of_node_put() in netxbig_leds_get_of_pdata()
            - remove legacy board-file support
    
       - leds-is31fl319x:
            - simplify getting the adapter of a client
    
       - leds-ti-lmu-common:
            - fix coccinelle issue
            - move static keyword to the front of declaration
    
       - leds-syscon:
            - use resource managed variant of device register
    
       - leds-ktd2692:
            - fix a typo in the name of a constant
    
       - leds-lp5562:
            - allow firmware files up to the maximum length
    
       - leds-an30259a:
            - fix typo
    
       - leds-pca953x:
            - include the right header"
    
    * tag 'leds-for-5.4-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/j.anaszewski/linux-leds: (72 commits)
      leds: lm3532: Fix optional led-max-microamp prop error handling
      led: triggers: Fix dereferencing of null pointer
      leds: ti-lmu-common: Move static keyword to the front of declaration
      leds: lm3532: Move static keyword to the front of declarations
      leds: trigger: gpio: GPIO 0 is valid
      leds: pwm: Use struct_size() helper
      leds: is31fl32xx: Use struct_size() helper
      leds: ti-lmu-common: Fix coccinelle issue in TI LMU
      leds: lm3532: Avoid potentially unpaired regulator calls
      leds: syscon: Use resource managed variant of device register
      leds: Replace {devm_}led_classdev_register() macros with inlines
      leds: Allow to call led_classdev_unregister() unconditionally
      leds: lm3532: Add full scale current configuration
      dt: lm3532: Add property for full scale current.
      leds: lm3532: Fixes for the driver for stability
      leds: lm3532: Change the define for the fs current register
      leds: lm3532: Fix brightness control for i2c mode
      leds: Switch to use fwnode instead of be stuck with OF one
      leds: max77650: Switch to fwnode property API
      led: triggers: Fix a memory leak bug
      ...

commit 229e6af102e407feada76d3c270395d7cda2cdfe
Author: Lukas Wunner <lukas@wunner.de>
Date:   Wed Sep 11 12:15:30 2019 +0200

    spi: Guarantee cacheline alignment of driver-private data
    
    __spi_alloc_controller() uses a single allocation to accommodate struct
    spi_controller and the driver-private data, but places the latter behind
    the former.  This order does not guarantee cacheline alignment of the
    driver-private data.  (It does guarantee cacheline alignment of struct
    spi_controller but the structure doesn't make any use of that property.)
    
    Round up struct spi_controller to cacheline size.  A forthcoming commit
    leverages this to grant DMA access to driver-private data of the BCM2835
    SPI master.
    
    An alternative, less economical approach would be to use two allocations.
    
    A third approach consists of reversing the order to conserve memory.
    But Mark Brown is concerned that it may result in a performance penalty
    on architectures that don't like unaligned accesses.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://lore.kernel.org/r/01625b9b26b93417fb09d2c15ad02dfe9cdbbbe5.1568187525.git.lukas@wunner.de
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b2890923d256..f8b4654a57d3 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2188,8 +2188,10 @@ extern struct class spi_slave_class;	/* dummy */
  * __spi_alloc_controller - allocate an SPI master or slave controller
  * @dev: the controller, possibly using the platform_bus
  * @size: how much zeroed driver-private data to allocate; the pointer to this
- *	memory is in the driver_data field of the returned device,
- *	accessible with spi_controller_get_devdata().
+ *	memory is in the driver_data field of the returned device, accessible
+ *	with spi_controller_get_devdata(); the memory is cacheline aligned;
+ *	drivers granting DMA access to portions of their private data need to
+ *	round up @size using ALIGN(size, dma_get_cache_alignment()).
  * @slave: flag indicating whether to allocate an SPI master (false) or SPI
  *	slave (true) controller
  * Context: can sleep
@@ -2211,11 +2213,12 @@ struct spi_controller *__spi_alloc_controller(struct device *dev,
 					      unsigned int size, bool slave)
 {
 	struct spi_controller	*ctlr;
+	size_t ctlr_size = ALIGN(sizeof(*ctlr), dma_get_cache_alignment());
 
 	if (!dev)
 		return NULL;
 
-	ctlr = kzalloc(size + sizeof(*ctlr), GFP_KERNEL);
+	ctlr = kzalloc(size + ctlr_size, GFP_KERNEL);
 	if (!ctlr)
 		return NULL;
 
@@ -2229,7 +2232,7 @@ struct spi_controller *__spi_alloc_controller(struct device *dev,
 		ctlr->dev.class = &spi_master_class;
 	ctlr->dev.parent = dev;
 	pm_suspend_ignore_children(&ctlr->dev, true);
-	spi_controller_set_devdata(ctlr, &ctlr[1]);
+	spi_controller_set_devdata(ctlr, (void *)ctlr + ctlr_size);
 
 	return ctlr;
 }

commit d1c44c9342c17e3314371325d9272684a075b65c
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Thu Sep 5 04:01:11 2019 +0300

    spi: Use an abbreviated pointer to ctlr->cur_msg in __spi_pump_messages
    
    This helps a bit with line fitting now (the list_first_entry call) as
    well as during the next patch which needs to iterate through all
    transfers of ctlr->cur_msg so it timestamps them.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Link: https://lore.kernel.org/r/20190905010114.26718-2-olteanv@gmail.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index aef55acb5ccd..b2890923d256 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1265,8 +1265,9 @@ EXPORT_SYMBOL_GPL(spi_finalize_current_transfer);
  */
 static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 {
-	unsigned long flags;
+	struct spi_message *msg;
 	bool was_busy = false;
+	unsigned long flags;
 	int ret;
 
 	/* Lock queue */
@@ -1325,10 +1326,10 @@ static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 	}
 
 	/* Extract head of queue */
-	ctlr->cur_msg =
-		list_first_entry(&ctlr->queue, struct spi_message, queue);
+	msg = list_first_entry(&ctlr->queue, struct spi_message, queue);
+	ctlr->cur_msg = msg;
 
-	list_del_init(&ctlr->cur_msg->queue);
+	list_del_init(&msg->queue);
 	if (ctlr->busy)
 		was_busy = true;
 	else
@@ -1361,7 +1362,7 @@ static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 			if (ctlr->auto_runtime_pm)
 				pm_runtime_put(ctlr->dev.parent);
 
-			ctlr->cur_msg->status = ret;
+			msg->status = ret;
 			spi_finalize_current_message(ctlr);
 
 			mutex_unlock(&ctlr->io_mutex);
@@ -1369,28 +1370,28 @@ static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 		}
 	}
 
-	trace_spi_message_start(ctlr->cur_msg);
+	trace_spi_message_start(msg);
 
 	if (ctlr->prepare_message) {
-		ret = ctlr->prepare_message(ctlr, ctlr->cur_msg);
+		ret = ctlr->prepare_message(ctlr, msg);
 		if (ret) {
 			dev_err(&ctlr->dev, "failed to prepare message: %d\n",
 				ret);
-			ctlr->cur_msg->status = ret;
+			msg->status = ret;
 			spi_finalize_current_message(ctlr);
 			goto out;
 		}
 		ctlr->cur_msg_prepared = true;
 	}
 
-	ret = spi_map_msg(ctlr, ctlr->cur_msg);
+	ret = spi_map_msg(ctlr, msg);
 	if (ret) {
-		ctlr->cur_msg->status = ret;
+		msg->status = ret;
 		spi_finalize_current_message(ctlr);
 		goto out;
 	}
 
-	ret = ctlr->transfer_one_message(ctlr, ctlr->cur_msg);
+	ret = ctlr->transfer_one_message(ctlr, msg);
 	if (ret) {
 		dev_err(&ctlr->dev,
 			"failed to transfer one message from queue\n");

commit 43004f31ebf2705905460a6d9a77da4182170c38
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Aug 8 17:03:21 2019 +0200

    spi: Rename of_spi_register_master() function
    
    Rename this function to of_spi_get_gpio_numbers() as this
    is what the function does, it does not register a master,
    it is called in the path of registering a master so the
    name is logical in a convoluted way, but it is better to
    follow Rusty Russell's ABI level no 7:
    "The obvious use is (probably) the correct one"
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Link: https://lore.kernel.org/r/20190808150321.23319-1-linus.walleij@linaro.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 8e83c9567353..aef55acb5ccd 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2235,7 +2235,7 @@ struct spi_controller *__spi_alloc_controller(struct device *dev,
 EXPORT_SYMBOL_GPL(__spi_alloc_controller);
 
 #ifdef CONFIG_OF
-static int of_spi_register_master(struct spi_controller *ctlr)
+static int of_spi_get_gpio_numbers(struct spi_controller *ctlr)
 {
 	int nb, i, *cs;
 	struct device_node *np = ctlr->dev.of_node;
@@ -2268,7 +2268,7 @@ static int of_spi_register_master(struct spi_controller *ctlr)
 	return 0;
 }
 #else
-static int of_spi_register_master(struct spi_controller *ctlr)
+static int of_spi_get_gpio_numbers(struct spi_controller *ctlr)
 {
 	return 0;
 }
@@ -2455,7 +2455,7 @@ int spi_register_controller(struct spi_controller *ctlr)
 			ctlr->mode_bits |= SPI_CS_HIGH;
 		} else {
 			/* Legacy code path for GPIOs from DT */
-			status = of_spi_register_master(ctlr);
+			status = of_spi_get_gpio_numbers(ctlr);
 			if (status)
 				return status;
 		}

commit 4ff13d00ebd5533947b083c66d44da3243a2d559
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Thu Aug 1 13:13:53 2019 +0200

    spi: Reduce kthread priority
    
    The SPI thingies request FIFO-99 by default, reduce this to FIFO-50.
    
    FIFO-99 is the very highest priority available to SCHED_FIFO and
    it not a suitable default; it would indicate the SPI work is the
    most important work on the machine.
    
    Cc: Benson Leung <bleung@chromium.org>
    Cc: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Cc: Guenter Roeck <groeck@chromium.org>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: linux-spi@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Link: https://lore.kernel.org/r/20190801111541.917256884@infradead.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 9fd7926e80c0..8e83c9567353 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1434,7 +1434,7 @@ static void spi_pump_messages(struct kthread_work *work)
  */
 static void spi_set_thread_rt(struct spi_controller *ctlr)
 {
-	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
+	struct sched_param param = { .sched_priority = MAX_RT_PRIO / 2 };
 
 	dev_info(&ctlr->dev,
 		"will run message pump with realtime priority\n");

commit cc8b4659491d23577eb8992449d82c7f4f4fc170
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Jul 31 14:47:38 2019 +0200

    spi: core: Use DEVICE_ATTR_RW() for SPI slave control sysfs attribute
    
    Convert the SPI slave control sysfs attribute from DEVICE_ATTR() to
    DEVICE_ATTR_RW(), to reduce boilerplate.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Link: https://lore.kernel.org/r/20190731124738.14519-1-geert+renesas@glider.be
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 75ac046cae52..9fd7926e80c0 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2105,8 +2105,8 @@ static int match_true(struct device *dev, void *data)
 	return 1;
 }
 
-static ssize_t spi_slave_show(struct device *dev,
-			      struct device_attribute *attr, char *buf)
+static ssize_t slave_show(struct device *dev, struct device_attribute *attr,
+			  char *buf)
 {
 	struct spi_controller *ctlr = container_of(dev, struct spi_controller,
 						   dev);
@@ -2117,9 +2117,8 @@ static ssize_t spi_slave_show(struct device *dev,
 		       child ? to_spi_device(child)->modalias : NULL);
 }
 
-static ssize_t spi_slave_store(struct device *dev,
-			       struct device_attribute *attr, const char *buf,
-			       size_t count)
+static ssize_t slave_store(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
 {
 	struct spi_controller *ctlr = container_of(dev, struct spi_controller,
 						   dev);
@@ -2157,7 +2156,7 @@ static ssize_t spi_slave_store(struct device *dev,
 	return count;
 }
 
-static DEVICE_ATTR(slave, 0644, spi_slave_show, spi_slave_store);
+static DEVICE_ATTR_RW(slave);
 
 static struct attribute *spi_slave_attrs[] = {
 	&dev_attr_slave.attr,

commit 00500147cbd3fc51353d0d003eaa9d31c72c0d50
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Tue Jul 23 23:18:36 2019 +0100

    drivers: Introduce device lookup variants by ACPI_COMPANION device
    
    Add a generic helper to match a device by the ACPI_COMPANION device
    and provide wrappers for the device lookup APIs.
    
    Cc: Len Brown <lenb@kernel.org>
    Cc: linux-acpi@vger.kernel.org
    Cc: linux-spi@vger.kernel.org
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: linux-i2c@vger.kernel.org
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de> # I2C parts
    Link: https://lore.kernel.org/r/20190723221838.12024-6-suzuki.poulose@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index a591da87981a..c486a6f84c2c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -3741,11 +3741,6 @@ static int spi_acpi_controller_match(struct device *dev, const void *data)
 	return ACPI_COMPANION(dev->parent) == data;
 }
 
-static int spi_acpi_device_match(struct device *dev, const void *data)
-{
-	return ACPI_COMPANION(dev) == data;
-}
-
 static struct spi_controller *acpi_spi_find_controller_by_adev(struct acpi_device *adev)
 {
 	struct device *dev;
@@ -3765,8 +3760,7 @@ static struct spi_device *acpi_spi_find_device_by_adev(struct acpi_device *adev)
 {
 	struct device *dev;
 
-	dev = bus_find_device(&spi_bus_type, NULL, adev, spi_acpi_device_match);
-
+	dev = bus_find_device_by_acpi_dev(&spi_bus_type, adev);
 	return dev ? to_spi_device(dev) : NULL;
 }
 

commit cfba5de9b99f8bbb8b4ea11b3049784e78b8759b
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Tue Jul 23 23:18:33 2019 +0100

    drivers: Introduce device lookup variants by of_node
    
    Introduce wrappers for {bus/driver/class}_find_device() to
    locate devices by its of_node.
    
    Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
    Cc: Maxime Ripard <maxime.ripard@bootlin.com>
    Cc: dri-devel@lists.freedesktop.org
    Cc: David Airlie <airlied@linux.ie>
    Cc: Daniel Vetter <daniel@ffwll.ch>
    Cc: devicetree@vger.kernel.org
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: linux-i2c@vger.kernel.org
    Cc: linux-rockchip@lists.infradead.org
    Cc: linux-spi@vger.kernel.org
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Cc: Takashi Iwai <tiwai@suse.com>
    Cc: Alan Tull <atull@kernel.org>
    Cc: linux-fpga@vger.kernel.org
    Cc: Peter Rosin <peda@axentia.se>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Heiner Kallweit <hkallweit1@gmail.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Liam Girdwood <lgirdwood@gmail.com>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Thor Thayer <thor.thayer@linux.intel.com>
    Cc: Jiri Slaby <jslaby@suse.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Peter Rosin <peda@axentia.se>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de> # I2C part
    Acked-by: Moritz Fischer <mdf@kernel.org> # For FPGA part
    Acked-by: Mark Brown <broonie@kernel.org>
    Link: https://lore.kernel.org/r/20190723221838.12024-3-suzuki.poulose@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 75ac046cae52..a591da87981a 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -3652,37 +3652,25 @@ EXPORT_SYMBOL_GPL(spi_write_then_read);
 /*-------------------------------------------------------------------------*/
 
 #if IS_ENABLED(CONFIG_OF)
-static int __spi_of_device_match(struct device *dev, const void *data)
-{
-	return dev->of_node == data;
-}
-
 /* must call put_device() when done with returned spi_device device */
 struct spi_device *of_find_spi_device_by_node(struct device_node *node)
 {
-	struct device *dev = bus_find_device(&spi_bus_type, NULL, node,
-						__spi_of_device_match);
+	struct device *dev = bus_find_device_by_of_node(&spi_bus_type, node);
+
 	return dev ? to_spi_device(dev) : NULL;
 }
 EXPORT_SYMBOL_GPL(of_find_spi_device_by_node);
 #endif /* IS_ENABLED(CONFIG_OF) */
 
 #if IS_ENABLED(CONFIG_OF_DYNAMIC)
-static int __spi_of_controller_match(struct device *dev, const void *data)
-{
-	return dev->of_node == data;
-}
-
 /* the spi controllers are not using spi_bus, so we find it with another way */
 static struct spi_controller *of_find_spi_controller_by_node(struct device_node *node)
 {
 	struct device *dev;
 
-	dev = class_find_device(&spi_master_class, NULL, node,
-				__spi_of_controller_match);
+	dev = class_find_device_by_of_node(&spi_master_class, node);
 	if (!dev && IS_ENABLED(CONFIG_SPI_SLAVE))
-		dev = class_find_device(&spi_slave_class, NULL, node,
-					__spi_of_controller_match);
+		dev = class_find_device_by_of_node(&spi_slave_class, node);
 	if (!dev)
 		return NULL;
 

commit f632a8170a6b667ee4e3f552087588f0fe13c4bb
Merge: ef8f3d48afd6 c33d442328f5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 12 12:24:03 2019 -0700

    Merge tag 'driver-core-5.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core and debugfs updates from Greg KH:
     "Here is the "big" driver core and debugfs changes for 5.3-rc1
    
      It's a lot of different patches, all across the tree due to some api
      changes and lots of debugfs cleanups.
    
      Other than the debugfs cleanups, in this set of changes we have:
    
       - bus iteration function cleanups
    
       - scripts/get_abi.pl tool to display and parse Documentation/ABI
         entries in a simple way
    
       - cleanups to Documenatation/ABI/ entries to make them parse easier
         due to typos and other minor things
    
       - default_attrs use for some ktype users
    
       - driver model documentation file conversions to .rst
    
       - compressed firmware file loading
    
       - deferred probe fixes
    
      All of these have been in linux-next for a while, with a bunch of
      merge issues that Stephen has been patient with me for"
    
    * tag 'driver-core-5.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (102 commits)
      debugfs: make error message a bit more verbose
      orangefs: fix build warning from debugfs cleanup patch
      ubifs: fix build warning after debugfs cleanup patch
      driver: core: Allow subsystems to continue deferring probe
      drivers: base: cacheinfo: Ensure cpu hotplug work is done before Intel RDT
      arch_topology: Remove error messages on out-of-memory conditions
      lib: notifier-error-inject: no need to check return value of debugfs_create functions
      swiotlb: no need to check return value of debugfs_create functions
      ceph: no need to check return value of debugfs_create functions
      sunrpc: no need to check return value of debugfs_create functions
      ubifs: no need to check return value of debugfs_create functions
      orangefs: no need to check return value of debugfs_create functions
      nfsd: no need to check return value of debugfs_create functions
      lib: 842: no need to check return value of debugfs_create functions
      debugfs: provide pr_fmt() macro
      debugfs: log errors when something goes wrong
      drivers: s390/cio: Fix compilation warning about const qualifiers
      drivers: Add generic helper to match by of_node
      driver_find_device: Unify the match function with class_find_device()
      bus_find_device: Unify the match callback with class_find_device
      ...

commit 26ac56506b0ea598bd0b52dcbd2d697282af98ed
Merge: 106dbe24d414 924b5867e7bd
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Jul 4 17:35:11 2019 +0100

    Merge remote-tracking branch 'spi/topic/pump-rt' into spi-next

commit b28944c6f6d3951f0c8f23f90c83ef741d30bfca
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Thu Jun 20 14:36:49 2019 +0200

    spi/acpi: avoid spurious matches during slave enumeration
    
    In the new SPI ACPI slave enumeration code, we use the value of
    lookup.max_speed_khz as a flag to decide whether a match occurred.
    However, doing so only makes sense if we initialize its value to
    zero beforehand, or otherwise, random junk from the stack will
    cause spurious matches.
    
    So zero initialize the lookup struct fully, and only set the non-zero
    members explicitly.
    
    Fixes: 4c3c59544f33 ("spi/acpi: enumerate all SPI slaves in the namespace")
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: andy.shevchenko@gmail.com
    Cc: masahisa.kojima@linaro.org
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Cc: linux-acpi@vger.kernel.org
    Cc: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 80d2d14f6294..81e4d9f7c0f4 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1953,7 +1953,7 @@ static acpi_status acpi_register_spi_device(struct spi_controller *ctlr,
 {
 	acpi_handle parent_handle = NULL;
 	struct list_head resource_list;
-	struct acpi_spi_lookup lookup;
+	struct acpi_spi_lookup lookup = {};
 	struct spi_device *spi;
 	int ret;
 
@@ -1962,8 +1962,6 @@ static acpi_status acpi_register_spi_device(struct spi_controller *ctlr,
 		return AE_OK;
 
 	lookup.ctlr		= ctlr;
-	lookup.mode		= 0;
-	lookup.bits_per_word	= 0;
 	lookup.irq		= -1;
 
 	INIT_LIST_HEAD(&resource_list);

commit 418e3ea157efb0eb2c6dd412a8d5f052477c7f5a
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Fri Jun 14 18:53:59 2019 +0100

    bus_find_device: Unify the match callback with class_find_device
    
    There is an arbitrary difference between the prototypes of
    bus_find_device() and class_find_device() preventing their callers
    from passing the same pair of data and match() arguments to both of
    them, which is the const qualifier used in the prototype of
    class_find_device().  If that qualifier is also used in the
    bus_find_device() prototype, it will be possible to pass the same
    match() callback function to both bus_find_device() and
    class_find_device(), which will allow some optimizations to be made in
    order to avoid code duplication going forward.  Also with that, constify
    the "data" parameter as it is passed as a const to the match function.
    
    For this reason, change the prototype of bus_find_device() to match
    the prototype of class_find_device() and adjust its callers to use the
    const qualifier in accordance with the new prototype of it.
    
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Andreas Noever <andreas.noever@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Corey Minyard <minyard@acm.org>
    Cc: Christian Borntraeger <borntraeger@de.ibm.com>
    Cc: David Kershner <david.kershner@unisys.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Felipe Balbi <balbi@kernel.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Harald Freudenberger <freude@linux.ibm.com>
    Cc: Hartmut Knaack <knaack.h@gmx.de>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Jason Gunthorpe <jgg@ziepe.ca>
    Cc: Jonathan Cameron <jic23@kernel.org>
    Cc: "James E.J. Bottomley" <jejb@linux.ibm.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michael Jamet <michael.jamet@intel.com>
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: Peter Oberparleiter <oberpar@linux.ibm.com>
    Cc: Sebastian Ott <sebott@linux.ibm.com>
    Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Cc: Yehezkel Bernat <YehezkelShB@gmail.com>
    Cc: rafael@kernel.org
    Acked-by: Corey Minyard <minyard@acm.org>
    Acked-by: David Kershner <david.kershner@unisys.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de> # for the I2C parts
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 5e75944ad5d1..3da1121f7572 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -3538,7 +3538,7 @@ EXPORT_SYMBOL_GPL(spi_write_then_read);
 /*-------------------------------------------------------------------------*/
 
 #if IS_ENABLED(CONFIG_OF)
-static int __spi_of_device_match(struct device *dev, void *data)
+static int __spi_of_device_match(struct device *dev, const void *data)
 {
 	return dev->of_node == data;
 }
@@ -3639,7 +3639,7 @@ static int spi_acpi_controller_match(struct device *dev, const void *data)
 	return ACPI_COMPANION(dev->parent) == data;
 }
 
-static int spi_acpi_device_match(struct device *dev, void *data)
+static int spi_acpi_device_match(struct device *dev, const void *data)
 {
 	return ACPI_COMPANION(dev) == data;
 }

commit f9481b08220d7dc1ff21e296a330ee8b721b44e4
Author: Tudor Ambarus <tudor.ambarus@microchip.com>
Date:   Wed Jun 19 14:38:28 2019 +0000

    spi: fix ctrl->num_chipselect constraint
    
    at91sam9g25ek showed the following error at probe:
    atmel_spi f0000000.spi: Using dma0chan2 (tx) and dma0chan3 (rx)
    for DMA transfers
    atmel_spi: probe of f0000000.spi failed with error -22
    
    Commit 0a919ae49223 ("spi: Don't call spi_get_gpio_descs() before device name is set")
    moved the calling of spi_get_gpio_descs() after ctrl->dev is set,
    but didn't move the !ctrl->num_chipselect check. When there are
    chip selects in the device tree, the spi-atmel driver lets the
    SPI core discover them when registering the SPI master.
    The ctrl->num_chipselect is thus expected to be set by
    spi_get_gpio_descs().
    
    Move the !ctlr->num_chipselect after spi_get_gpio_descs() as it was
    before the aforementioned commit. While touching this block, get rid
    of the explicit comparison with 0 and update the commenting style.
    
    Fixes: 0a919ae49223 ("spi: Don't call spi_get_gpio_descs() before device name is set")
    Signed-off-by: Tudor Ambarus <tudor.ambarus@microchip.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index a31e1e291335..80d2d14f6294 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2375,11 +2375,6 @@ int spi_register_controller(struct spi_controller *ctlr)
 	if (status)
 		return status;
 
-	/* even if it's just one always-selected device, there must
-	 * be at least one chipselect
-	 */
-	if (ctlr->num_chipselect == 0)
-		return -EINVAL;
 	if (ctlr->bus_num >= 0) {
 		/* devices with a fixed bus num must check-in with the num */
 		mutex_lock(&board_lock);
@@ -2450,6 +2445,13 @@ int spi_register_controller(struct spi_controller *ctlr)
 		}
 	}
 
+	/*
+	 * Even if it's just one always-selected device, there must
+	 * be at least one chipselect.
+	 */
+	if (!ctlr->num_chipselect)
+		return -EINVAL;
+
 	status = device_add(&ctlr->dev);
 	if (status < 0) {
 		/* free bus id */

commit b5e3cf410b486a2415ff09b12f3ef18aba9f53ff
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Jun 19 11:52:54 2019 +0200

    spi/acpi: fix incorrect ACPI parent check
    
    The ACPI device object parsing code for SPI slaves enumerates the
    entire ACPI namespace to look for devices that refer to the master
    in question via the 'resource_source' field in the 'SPISerialBus'
    resource. If that field does not refer to a valid ACPI device or
    if it refers to the wrong SPI master, we should disregard the
    device.
    
    Current, the valid device check is wrong, since it gets the
    polarity of 'status' wrong. This could cause issues if the
    'resource_source' field is bogus but parent_handle happens to
    refer to the correct master (which is not entirely imaginary
    since this code runs in a loop)
    
    So test for ACPI_FAILURE() instead, to make the code more
    self explanatory.
    
    Fixes: 4c3c59544f33 ("spi/acpi: enumerate all SPI slaves in the namespace")
    Reported-by: kbuild test robot <lkp@intel.com>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: andy.shevchenko@gmail.com
    Cc: masahisa.kojima@linaro.org
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Cc: linux-acpi@vger.kernel.org
    Cc: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 01a40bcfc352..a31e1e291335 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1907,7 +1907,7 @@ static int acpi_spi_add_resource(struct acpi_resource *ares, void *data)
 						 sb->resource_source.string_ptr,
 						 &parent_handle);
 
-			if (!status ||
+			if (ACPI_FAILURE(status) ||
 			    ACPI_HANDLE(ctlr->dev.parent) != parent_handle)
 				return -ENODEV;
 

commit f56943699463478617b235930252261d5277bd46
Author: Vladimir Zapolskiy <vz@mleia.com>
Date:   Tue Jun 18 19:28:18 2019 +0300

    spi: don't open code list_for_each_entry_safe_reverse()
    
    The loop declaration in function spi_res_release() can be simplified
    by reusing the common list_for_each_entry_safe_reverse() helper
    macro.
    
    Signed-off-by: Vladimir Zapolskiy <vz@mleia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index e71881afe475..01a40bcfc352 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2721,12 +2721,9 @@ EXPORT_SYMBOL_GPL(spi_res_add);
  */
 void spi_res_release(struct spi_controller *ctlr, struct spi_message *message)
 {
-	struct spi_res *res;
-
-	while (!list_empty(&message->resources)) {
-		res = list_last_entry(&message->resources,
-				      struct spi_res, entry);
+	struct spi_res *res, *tmp;
 
+	list_for_each_entry_safe_reverse(res, tmp, &message->resources, entry) {
 		if (res->release)
 			res->release(ctlr, message, res->data);
 

commit ebc37af5e0a134355ea2b62ed4141458bdbd5389
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Sat Jun 15 20:41:35 2019 +0300

    spi: No need to assign dummy value in spi_unregister_controller()
    
    The device_for_each_child() doesn't require the returned value to be checked.
    Thus, drop the dummy variable completely and have no warning anymore:
    
    drivers/spi/spi.c: In function âspi_unregister_controllerâ:
    drivers/spi/spi.c:2480:6: warning: variable âdummyâ set but not used [-Wunused-but-set-variable]
      int dummy;
          ^~~~~
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 498f9b7419a4..e71881afe475 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2559,7 +2559,6 @@ void spi_unregister_controller(struct spi_controller *ctlr)
 {
 	struct spi_controller *found;
 	int id = ctlr->bus_num;
-	int dummy;
 
 	/* First make sure that this controller was ever added */
 	mutex_lock(&board_lock);
@@ -2573,7 +2572,7 @@ void spi_unregister_controller(struct spi_controller *ctlr)
 	list_del(&ctlr->list);
 	mutex_unlock(&board_lock);
 
-	dummy = device_for_each_child(&ctlr->dev, NULL, __unregister);
+	device_for_each_child(&ctlr->dev, NULL, __unregister);
 	device_unregister(&ctlr->dev);
 	/* free bus id */
 	mutex_lock(&board_lock);

commit 4c3c59544f33e97cf8557f27e05a9904ead16363
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Thu May 30 13:16:34 2019 +0200

    spi/acpi: enumerate all SPI slaves in the namespace
    
    Currently, the ACPI enumeration that takes place when registering a
    SPI master only considers immediate child devices in the ACPI namespace,
    rather than checking the ResourceSource field in the SpiSerialBus()
    resource descriptor.
    
    This is incorrect: SPI slaves could reside anywhere in the ACPI
    namespace, and so we should enumerate the entire namespace and look for
    any device that refers to the newly registered SPI master in its
    resource descriptor.
    
    So refactor the existing code and use a lookup structure so that
    allocating the SPI device structure is deferred until we have identified
    the device as an actual child of the controller. This approach is
    loosely based on the way the I2C subsystem handles ACPI enumeration.
    
    Note that Apple x86 hardware does not rely on SpiSerialBus() resources
    in _CRS but uses nested devices below the controller's device node in
    the ACPI namespace, with a special set of device properties. This means
    we have to take care to only parse those properties for device nodes
    that are direct children of the controller node.
    
    Cc: Mika Westerberg <mika.westerberg@linux.intel.com>
    Cc: linux-spi@vger.kernel.org
    Cc: broonie@kernel.org
    Cc: andy.shevchenko@gmail.com
    Cc: masahisa.kojima@linaro.org
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Cc: linux-acpi@vger.kernel.org
    Cc: Lukas Wunner <lukas@wunner.de>
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index bced6876de79..498f9b7419a4 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1852,9 +1852,18 @@ static void of_register_spi_devices(struct spi_controller *ctlr) { }
 #endif
 
 #ifdef CONFIG_ACPI
-static void acpi_spi_parse_apple_properties(struct spi_device *spi)
+struct acpi_spi_lookup {
+	struct spi_controller 	*ctlr;
+	u32			max_speed_hz;
+	u32			mode;
+	int			irq;
+	u8			bits_per_word;
+	u8			chip_select;
+};
+
+static void acpi_spi_parse_apple_properties(struct acpi_device *dev,
+					    struct acpi_spi_lookup *lookup)
 {
-	struct acpi_device *dev = ACPI_COMPANION(&spi->dev);
 	const union acpi_object *obj;
 
 	if (!x86_apple_machine)
@@ -1862,35 +1871,46 @@ static void acpi_spi_parse_apple_properties(struct spi_device *spi)
 
 	if (!acpi_dev_get_property(dev, "spiSclkPeriod", ACPI_TYPE_BUFFER, &obj)
 	    && obj->buffer.length >= 4)
-		spi->max_speed_hz  = NSEC_PER_SEC / *(u32 *)obj->buffer.pointer;
+		lookup->max_speed_hz  = NSEC_PER_SEC / *(u32 *)obj->buffer.pointer;
 
 	if (!acpi_dev_get_property(dev, "spiWordSize", ACPI_TYPE_BUFFER, &obj)
 	    && obj->buffer.length == 8)
-		spi->bits_per_word = *(u64 *)obj->buffer.pointer;
+		lookup->bits_per_word = *(u64 *)obj->buffer.pointer;
 
 	if (!acpi_dev_get_property(dev, "spiBitOrder", ACPI_TYPE_BUFFER, &obj)
 	    && obj->buffer.length == 8 && !*(u64 *)obj->buffer.pointer)
-		spi->mode |= SPI_LSB_FIRST;
+		lookup->mode |= SPI_LSB_FIRST;
 
 	if (!acpi_dev_get_property(dev, "spiSPO", ACPI_TYPE_BUFFER, &obj)
 	    && obj->buffer.length == 8 &&  *(u64 *)obj->buffer.pointer)
-		spi->mode |= SPI_CPOL;
+		lookup->mode |= SPI_CPOL;
 
 	if (!acpi_dev_get_property(dev, "spiSPH", ACPI_TYPE_BUFFER, &obj)
 	    && obj->buffer.length == 8 &&  *(u64 *)obj->buffer.pointer)
-		spi->mode |= SPI_CPHA;
+		lookup->mode |= SPI_CPHA;
 }
 
 static int acpi_spi_add_resource(struct acpi_resource *ares, void *data)
 {
-	struct spi_device *spi = data;
-	struct spi_controller *ctlr = spi->controller;
+	struct acpi_spi_lookup *lookup = data;
+	struct spi_controller *ctlr = lookup->ctlr;
 
 	if (ares->type == ACPI_RESOURCE_TYPE_SERIAL_BUS) {
 		struct acpi_resource_spi_serialbus *sb;
+		acpi_handle parent_handle;
+		acpi_status status;
 
 		sb = &ares->data.spi_serial_bus;
 		if (sb->type == ACPI_RESOURCE_SERIAL_TYPE_SPI) {
+
+			status = acpi_get_handle(NULL,
+						 sb->resource_source.string_ptr,
+						 &parent_handle);
+
+			if (!status ||
+			    ACPI_HANDLE(ctlr->dev.parent) != parent_handle)
+				return -ENODEV;
+
 			/*
 			 * ACPI DeviceSelection numbering is handled by the
 			 * host controller driver in Windows and can vary
@@ -1903,25 +1923,25 @@ static int acpi_spi_add_resource(struct acpi_resource *ares, void *data)
 						sb->device_selection);
 				if (cs < 0)
 					return cs;
-				spi->chip_select = cs;
+				lookup->chip_select = cs;
 			} else {
-				spi->chip_select = sb->device_selection;
+				lookup->chip_select = sb->device_selection;
 			}
 
-			spi->max_speed_hz = sb->connection_speed;
+			lookup->max_speed_hz = sb->connection_speed;
 
 			if (sb->clock_phase == ACPI_SPI_SECOND_PHASE)
-				spi->mode |= SPI_CPHA;
+				lookup->mode |= SPI_CPHA;
 			if (sb->clock_polarity == ACPI_SPI_START_HIGH)
-				spi->mode |= SPI_CPOL;
+				lookup->mode |= SPI_CPOL;
 			if (sb->device_polarity == ACPI_SPI_ACTIVE_HIGH)
-				spi->mode |= SPI_CS_HIGH;
+				lookup->mode |= SPI_CS_HIGH;
 		}
-	} else if (spi->irq < 0) {
+	} else if (lookup->irq < 0) {
 		struct resource r;
 
 		if (acpi_dev_resource_interrupt(ares, 0, &r))
-			spi->irq = r.start;
+			lookup->irq = r.start;
 	}
 
 	/* Always tell the ACPI core to skip this resource */
@@ -1931,7 +1951,9 @@ static int acpi_spi_add_resource(struct acpi_resource *ares, void *data)
 static acpi_status acpi_register_spi_device(struct spi_controller *ctlr,
 					    struct acpi_device *adev)
 {
+	acpi_handle parent_handle = NULL;
 	struct list_head resource_list;
+	struct acpi_spi_lookup lookup;
 	struct spi_device *spi;
 	int ret;
 
@@ -1939,28 +1961,44 @@ static acpi_status acpi_register_spi_device(struct spi_controller *ctlr,
 	    acpi_device_enumerated(adev))
 		return AE_OK;
 
-	spi = spi_alloc_device(ctlr);
-	if (!spi) {
-		dev_err(&ctlr->dev, "failed to allocate SPI device for %s\n",
-			dev_name(&adev->dev));
-		return AE_NO_MEMORY;
-	}
-
-	ACPI_COMPANION_SET(&spi->dev, adev);
-	spi->irq = -1;
+	lookup.ctlr		= ctlr;
+	lookup.mode		= 0;
+	lookup.bits_per_word	= 0;
+	lookup.irq		= -1;
 
 	INIT_LIST_HEAD(&resource_list);
 	ret = acpi_dev_get_resources(adev, &resource_list,
-				     acpi_spi_add_resource, spi);
+				     acpi_spi_add_resource, &lookup);
 	acpi_dev_free_resource_list(&resource_list);
 
-	acpi_spi_parse_apple_properties(spi);
+	if (ret < 0)
+		/* found SPI in _CRS but it points to another controller */
+		return AE_OK;
 
-	if (ret < 0 || !spi->max_speed_hz) {
-		spi_dev_put(spi);
+	if (!lookup.max_speed_hz &&
+	    !ACPI_FAILURE(acpi_get_parent(adev->handle, &parent_handle)) &&
+	    ACPI_HANDLE(ctlr->dev.parent) == parent_handle) {
+		/* Apple does not use _CRS but nested devices for SPI slaves */
+		acpi_spi_parse_apple_properties(adev, &lookup);
+	}
+
+	if (!lookup.max_speed_hz)
 		return AE_OK;
+
+	spi = spi_alloc_device(ctlr);
+	if (!spi) {
+		dev_err(&ctlr->dev, "failed to allocate SPI device for %s\n",
+			dev_name(&adev->dev));
+		return AE_NO_MEMORY;
 	}
 
+	ACPI_COMPANION_SET(&spi->dev, adev);
+	spi->max_speed_hz	= lookup.max_speed_hz;
+	spi->mode		= lookup.mode;
+	spi->irq		= lookup.irq;
+	spi->bits_per_word	= lookup.bits_per_word;
+	spi->chip_select	= lookup.chip_select;
+
 	acpi_set_modalias(adev, acpi_device_hid(adev), spi->modalias,
 			  sizeof(spi->modalias));
 
@@ -1992,6 +2030,8 @@ static acpi_status acpi_spi_add_device(acpi_handle handle, u32 level,
 	return acpi_register_spi_device(ctlr, adev);
 }
 
+#define SPI_ACPI_ENUMERATE_MAX_DEPTH		32
+
 static void acpi_register_spi_devices(struct spi_controller *ctlr)
 {
 	acpi_status status;
@@ -2001,7 +2041,8 @@ static void acpi_register_spi_devices(struct spi_controller *ctlr)
 	if (!handle)
 		return;
 
-	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,
+	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
+				     SPI_ACPI_ENUMERATE_MAX_DEPTH,
 				     acpi_spi_add_device, NULL, ctlr, NULL);
 	if (ACPI_FAILURE(status))
 		dev_warn(&ctlr->dev, "failed to enumerate SPI slaves\n");

commit aef9752274f4045b0dab577e113da63c96832f77
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Fri Jun 7 13:48:45 2019 -0500

    spi: Use struct_size() helper
    
    One of the more common cases of allocation size calculations is finding
    the size of a structure that has a zero-sized array at the end, along
    with memory for some number of elements for that array. For example:
    
    struct spi_replaced_transfers {
            ...
            struct spi_transfer inserted_transfers[];
    };
    
    Make use of the struct_size() helper instead of an open-coded version
    in order to avoid any potential type mistakes.
    
    So, replace the following form:
    
    insert * sizeof(struct spi_transfer) + sizeof(struct spi_replaced_transfers)
    
    with:
    
    struct_size(rxfer, inserted_transfers, insert)
    
    This code was detected with the help of Coccinelle.
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 232ed4bb8fca..bced6876de79 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2750,8 +2750,7 @@ struct spi_replaced_transfers *spi_replace_transfers(
 
 	/* allocate the structure using spi_res */
 	rxfer = spi_res_alloc(msg->spi, __spi_replace_transfers_release,
-			      insert * sizeof(struct spi_transfer)
-			      + sizeof(struct spi_replaced_transfers)
+			      struct_size(rxfer, inserted_transfers, insert)
 			      + extradatasize,
 			      gfp);
 	if (!rxfer)

commit d9424d6d48c8b6c4e8d9c38e2565bcaf90f4d184
Merge: 0e896f380b84 f3440d9a0da2
Author: Mark Brown <broonie@kernel.org>
Date:   Thu May 23 14:47:04 2019 +0100

    Merge branch 'spi-5.2' into spi-5.3

commit 924b5867e7bd6a6a98014f0517b747465b108011
Author: Douglas Anderson <dianders@chromium.org>
Date:   Wed May 15 09:48:12 2019 -0700

    spi: Allow SPI devices to request the pumping thread be realtime
    
    Right now the only way to get the SPI pumping thread bumped up to
    realtime priority is for the controller to request it.  However it may
    be that the controller works fine with the normal priority but
    communication to a particular SPI device on the bus needs realtime
    priority.
    
    Let's add a way for devices to request realtime priority when they set
    themselves up.
    
    NOTE: this will just affect the priority of transfers that end up on
    the SPI core's pumping thread.  In many cases transfers happen in the
    context of the caller so if you need realtime priority for all
    transfers you should ensure the calling context is also realtime
    priority.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Reviewed-by: Guenter Roeck <groeck@chromium.org>
    Tested-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 5e75944ad5d1..18f70e4bbb31 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1364,10 +1364,32 @@ static void spi_pump_messages(struct kthread_work *work)
 	__spi_pump_messages(ctlr, true);
 }
 
-static int spi_init_queue(struct spi_controller *ctlr)
+/**
+ * spi_set_thread_rt - set the controller to pump at realtime priority
+ * @ctlr: controller to boost priority of
+ *
+ * This can be called because the controller requested realtime priority
+ * (by setting the ->rt value before calling spi_register_controller()) or
+ * because a device on the bus said that its transfers needed realtime
+ * priority.
+ *
+ * NOTE: at the moment if any device on a bus says it needs realtime then
+ * the thread will be at realtime priority for all transfers on that
+ * controller.  If this eventually becomes a problem we may see if we can
+ * find a way to boost the priority only temporarily during relevant
+ * transfers.
+ */
+static void spi_set_thread_rt(struct spi_controller *ctlr)
 {
 	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
 
+	dev_info(&ctlr->dev,
+		"will run message pump with realtime priority\n");
+	sched_setscheduler(ctlr->kworker_task, SCHED_FIFO, &param);
+}
+
+static int spi_init_queue(struct spi_controller *ctlr)
+{
 	ctlr->running = false;
 	ctlr->busy = false;
 
@@ -1387,11 +1409,8 @@ static int spi_init_queue(struct spi_controller *ctlr)
 	 * request and the scheduling of the message pump thread. Without this
 	 * setting the message pump thread will remain at default priority.
 	 */
-	if (ctlr->rt) {
-		dev_info(&ctlr->dev,
-			"will run message pump with realtime priority\n");
-		sched_setscheduler(ctlr->kworker_task, SCHED_FIFO, &param);
-	}
+	if (ctlr->rt)
+		spi_set_thread_rt(ctlr);
 
 	return 0;
 }
@@ -2982,6 +3001,11 @@ int spi_setup(struct spi_device *spi)
 
 	spi_set_cs(spi, false);
 
+	if (spi->rt && !spi->controller->rt) {
+		spi->controller->rt = true;
+		spi_set_thread_rt(spi->controller);
+	}
+
 	dev_dbg(&spi->dev, "setup mode %d, %s%s%s%s%u bits/w, %u Hz max --> %d\n",
 			(int) (spi->mode & (SPI_CPOL | SPI_CPHA)),
 			(spi->mode & SPI_CS_HIGH) ? "cs_high, " : "",

commit f3440d9a0da292dc4998d9393162fcfb996fd671
Author: Super Liu <supercjliu@google.com>
Date:   Wed May 22 14:30:14 2019 +0800

    spi: abort spi_sync if failed to prepare_transfer_hardware
    
    There is no chance to wait spi message complete if failed to
    prepare_transfer_hardware(). Therefore, finalize this message and abort
    transfer with corresponding return status to release this block case.
    
    Logs:
    
    [17400.283005] c7   3267 PM: PM: suspend entry 2019-05-04 03:01:14.403097147 UTC
    [17400.283013] c7   3267 PM: suspend entry (deep)
    [17400.283016] c6   3267 PM: Syncing filesystems ... done.
    [17400.584395] c1    753 spi_geni 890000.spi: spi_geni_prepare_transfer_hardware:Error enabling SE resources -13
    [17400.584404] c1    753 spi_master spi1: failed to prepare transfer hardware
    [17400.664611] c4   3267 PM: PM: suspend exit 2019-05-04 03:01:15.235273018 UTC
    
    Flow:
    
    __spi_sync@spi.c
    |    if (status == 0) {
    |        /* Push out the messages in the calling context if we
    |         * can.
    |         */
    |        if (ctlr->transfer == spi_queued_transfer) {
    |            SPI_STATISTICS_INCREMENT_FIELD(&ctlr->statistics,
    |               spi_sync_immediate);
    |            SPI_STATISTICS_INCREMENT_FIELD(&spi->statistics,
    |               spi_sync_immediate);
    |               __spi_pump_messages(ctlr, false);
    |        }
    |
    |        wait_for_completion(&done);    <== stuck here!!!
    |        status = message->status;
    |    }
    |    message->context = NULL;
    |    return status;
    |
    -->     __spi_pump_messages@spi.c
            |    if (!was_busy && ctlr->prepare_transfer_hardware) {
            |        ret = ctlr->prepare_transfer_hardware(ctlr);
            |        if (ret) {
            |            dev_err(&ctlr->dev,
            |               "failed to prepare transfer hardware\n");
            |
            |        if (ctlr->auto_runtime_pm)
            |            pm_runtime_put(ctlr->dev.parent);
            |            mutex_unlock(&ctlr->io_mutex);
            |            return;
            |        }
            |    }
            |
            -->     spi_geni_prepare_transfer_hardware@spi-geni-qcom.c
                    |    ret = pm_runtime_get_sync(mas->dev);
                    |    if (ret < 0) {
                    |        dev_err(mas->dev,
                    |               "%s:Error enabling SE resources %d\n",
                    |               __func__, ret);
                    |    pm_runtime_put_noidle(mas->dev);
                    |    goto exit_prepare_transfer_hardware;
    
    Signed-off-by: Super Liu <supercjliu@google.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 8eb7460dd744..5e4654032bfa 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1307,10 +1307,15 @@ static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 		ret = ctlr->prepare_transfer_hardware(ctlr);
 		if (ret) {
 			dev_err(&ctlr->dev,
-				"failed to prepare transfer hardware\n");
+				"failed to prepare transfer hardware: %d\n",
+				ret);
 
 			if (ctlr->auto_runtime_pm)
 				pm_runtime_put(ctlr->dev.parent);
+
+			ctlr->cur_msg->status = ret;
+			spi_finalize_current_message(ctlr);
+
 			mutex_unlock(&ctlr->io_mutex);
 			return;
 		}

commit 5d7e2b5ed5858fe739d4cb8ad22dcce7bd9dbe7b
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Sat Feb 23 08:49:49 2019 +0000

    spi: core: allow reporting the effectivly used speed_hz for a transfer
    
    Provide a means for the spi bus driver to report the effectively used
    spi clock frequency used for each spi_transfer.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index cfa3c3decb8a..e9bf0c23da50 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -3126,6 +3126,7 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 	 */
 	message->frame_length = 0;
 	list_for_each_entry(xfer, &message->transfers, transfer_list) {
+		xfer->effective_speed_hz = 0;
 		message->frame_length += xfer->len;
 		if (!xfer->bits_per_word)
 			xfer->bits_per_word = spi->bits_per_word;

commit 0ed56252c9567351344cb7b5cff6140e1bcec943
Author: Mark Brown <broonie@kernel.org>
Date:   Thu May 9 11:27:17 2019 +0900

    spi: Fix Raspberry Pi breakage
    
    This reverts commit c9ba7a16d0f1 (Release spi_res after finalizing
    message) which causes races during cleanup.
    
    Reported-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 5e75944ad5d1..8eb7460dd744 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1181,10 +1181,10 @@ static int spi_transfer_one_message(struct spi_controller *ctlr,
 	if (msg->status && ctlr->handle_err)
 		ctlr->handle_err(ctlr, msg);
 
-	spi_finalize_current_message(ctlr);
-
 	spi_res_release(ctlr, msg);
 
+	spi_finalize_current_message(ctlr);
+
 	return ret;
 }
 

commit d5864e5bed96db7230da45463d6ae7af5b3b4399
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Sat Feb 23 08:49:50 2019 +0000

    spi: core: allow defining time that cs is deasserted as a multiple of SCK
    
    Support setting a delay between cs assert and deassert as
    a multiple of spi clock length.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 7e8ffe3fdc00..cfa3c3decb8a 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1111,6 +1111,7 @@ static void _spi_transfer_cs_change_delay(struct spi_message *msg,
 {
 	u32 delay = xfer->cs_change_delay;
 	u32 unit = xfer->cs_change_delay_unit;
+	u32 hz;
 
 	/* return early on "fast" mode - for everything but USECS */
 	if (!delay && unit != SPI_DELAY_UNIT_USECS)
@@ -1126,6 +1127,13 @@ static void _spi_transfer_cs_change_delay(struct spi_message *msg,
 		break;
 	case SPI_DELAY_UNIT_NSECS: /* nothing to do here */
 		break;
+	case SPI_DELAY_UNIT_SCK:
+		/* if there is no effective speed know, then approximate
+		 * by underestimating with half the requested hz
+		 */
+		hz = xfer->effective_speed_hz ?: xfer->speed_hz / 2;
+		delay *= DIV_ROUND_UP(1000000000, hz);
+		break;
 	default:
 		dev_err_once(&msg->spi->dev,
 			     "Use of unsupported delay unit %i, using default of 10us\n",

commit 0ff2de8bb163551ec4230a5a6f3c40c1f6adec4f
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Sat Feb 23 08:49:48 2019 +0000

    spi: core: allow defining time that cs is deasserted
    
    For some SPI devices that support speed_hz > 1MHz the default 10 us delay
    when cs_change = 1 is typically way to long and may result in poor spi bus
    utilization.
    
    This patch makes it possible to control the delay at micro or nano second
    resolution on a per spi_transfer basis. It even allows an "as fast as
    possible" mode with:
        xfer.cs_change_delay_unit = SPI_DELAY_UNIT_NSECS;
        xfer.cs_change_delay = 0;
    
    The delay code is shared between delay_usecs and cs_change_delay for
    consistency and reuse, so in the future this change_delay_unit could also
    apply to delay_usec as well.
    
    Note that on slower SOCs/CPU actually reaching ns deasserts on cs is not
    realistic as the gpio overhead alone (without any delays added ) may
    already leave cs deasserted for more than 1us - at least on a raspberry pi.
    But at the very least this way we can keep it as short as possible.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 5e75944ad5d1..7e8ffe3fdc00 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1090,6 +1090,52 @@ static int spi_transfer_wait(struct spi_controller *ctlr,
 	return 0;
 }
 
+static void _spi_transfer_delay_ns(u32 ns)
+{
+	if (!ns)
+		return;
+	if (ns <= 1000) {
+		ndelay(ns);
+	} else {
+		u32 us = DIV_ROUND_UP(ns, 1000);
+
+		if (us <= 10)
+			udelay(us);
+		else
+			usleep_range(us, us + DIV_ROUND_UP(us, 10));
+	}
+}
+
+static void _spi_transfer_cs_change_delay(struct spi_message *msg,
+					  struct spi_transfer *xfer)
+{
+	u32 delay = xfer->cs_change_delay;
+	u32 unit = xfer->cs_change_delay_unit;
+
+	/* return early on "fast" mode - for everything but USECS */
+	if (!delay && unit != SPI_DELAY_UNIT_USECS)
+		return;
+
+	switch (unit) {
+	case SPI_DELAY_UNIT_USECS:
+		/* for compatibility use default of 10us */
+		if (!delay)
+			delay = 10000;
+		else
+			delay *= 1000;
+		break;
+	case SPI_DELAY_UNIT_NSECS: /* nothing to do here */
+		break;
+	default:
+		dev_err_once(&msg->spi->dev,
+			     "Use of unsupported delay unit %i, using default of 10us\n",
+			     xfer->cs_change_delay_unit);
+		delay = 10000;
+	}
+	/* now sleep for the requested amount of time */
+	_spi_transfer_delay_ns(delay);
+}
+
 /*
  * spi_transfer_one_message - Default implementation of transfer_one_message()
  *
@@ -1148,14 +1194,8 @@ static int spi_transfer_one_message(struct spi_controller *ctlr,
 		if (msg->status != -EINPROGRESS)
 			goto out;
 
-		if (xfer->delay_usecs) {
-			u16 us = xfer->delay_usecs;
-
-			if (us <= 10)
-				udelay(us);
-			else
-				usleep_range(us, us + DIV_ROUND_UP(us, 10));
-		}
+		if (xfer->delay_usecs)
+			_spi_transfer_delay_ns(xfer->delay_usecs * 1000);
 
 		if (xfer->cs_change) {
 			if (list_is_last(&xfer->transfer_list,
@@ -1163,7 +1203,7 @@ static int spi_transfer_one_message(struct spi_controller *ctlr,
 				keep_cs = true;
 			} else {
 				spi_set_cs(msg->spi, false);
-				udelay(10);
+				_spi_transfer_cs_change_delay(msg, xfer);
 				spi_set_cs(msg->spi, true);
 			}
 		}
@@ -3757,4 +3797,3 @@ static int __init spi_init(void)
  * include needing to have boardinfo data structures be much more public.
  */
 postcore_initcall(spi_init);
-

commit d61ad23cb3be09ff4956e9b9794134456522817f
Author: Serge Semin <fancer.lancer@gmail.com>
Date:   Fri Apr 26 13:30:07 2019 +0300

    spi: Clear SPI_CS_HIGH flag from bad_bits for GPIO chip-select
    
    When GPIO chip-select is used nothing prevents any available SPI
    controllers to work with both CS-high and traditional CS-low modes.
    In fact the SPI bus core code already does it, so we don't need to
    introduce any modification there. But spi_setup() still fails to
    switch the interface settings if CS-high flag is set for the case
    of GPIO-driven slave chip-select when the SPI controller doesn't
    support the hardwired CS-inversion. Lets fix it by clearing the
    SPI_CS_HIGH flag out from bad_bits (unsupported by controller) when
    client chip is selected by GPIO.
    
    This feature is useful for slave devices, which in accordance with
    communication protocol can work with both active-high and active-low
    chip-selects. I am aware of one such device. It is MMC-SPI interface,
    when at init sequence the driver needs to perform a read operation with
    low and high chip-select sequentially (requirement of 74 clock cycles
    with both chipselect, see the mmc_spi driver for details).
    
    Signed-off-by: Serge Semin <fancer.lancer@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 2195fa265aef..5e75944ad5d1 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2945,6 +2945,11 @@ int spi_setup(struct spi_device *spi)
 	 * so it is ignored here.
 	 */
 	bad_bits = spi->mode & ~(spi->controller->mode_bits | SPI_CS_WORD);
+	/* nothing prevents from working with active-high CS in case if it
+	 * is driven by GPIO.
+	 */
+	if (gpio_is_valid(spi->cs_gpio))
+		bad_bits &= ~SPI_CS_HIGH;
 	ugly_bits = bad_bits &
 		    (SPI_TX_DUAL | SPI_TX_QUAD | SPI_TX_OCTAL |
 		     SPI_RX_DUAL | SPI_RX_QUAD | SPI_RX_OCTAL);

commit c9ba7a16d0f1d2b1e70d47296eca5f612c753825
Author: Noralf TrÃ¸nnes <noralf@tronnes.org>
Date:   Sat Apr 13 20:24:13 2019 +0200

    spi: Release spi_res after finalizing message
    
    spi_split_transfers_maxsize() can be used to split a transfer. This
    function uses spi_res to lifetime manage the added transfer structures.
    So in order to finalize the current message while it contains the split
    transfers, spi_res_release() must be called after finalizing.
    
    Signed-off-by: Noralf TrÃ¸nnes <noralf@tronnes.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 3c6c6101b611..2195fa265aef 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1181,10 +1181,10 @@ static int spi_transfer_one_message(struct spi_controller *ctlr,
 	if (msg->status && ctlr->handle_err)
 		ctlr->handle_err(ctlr, msg);
 
-	spi_res_release(ctlr, msg);
-
 	spi_finalize_current_message(ctlr);
 
+	spi_res_release(ctlr, msg);
+
 	return ret;
 }
 

commit 4d1841d64535d60a1378d847cf4cd3f340ea28c2
Author: Noralf TrÃ¸nnes <noralf@tronnes.org>
Date:   Sat Apr 13 20:24:12 2019 +0200

    spi: Remove warning in spi_split_transfers_maxsize()
    
    Don't warn about splitting transfers, the info is available in the
    statistics if needed.
    
    Signed-off-by: Noralf TrÃ¸nnes <noralf@tronnes.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 86a31340ad03..3c6c6101b611 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2788,11 +2788,6 @@ static int __spi_split_transfer_maxsize(struct spi_controller *ctlr,
 	size_t offset;
 	size_t count, i;
 
-	/* warn once about this fact that we are splitting a transfer */
-	dev_warn_once(&msg->spi->dev,
-		      "spi_transfer of length %i exceed max length of %zu - needed to split transfers\n",
-		      xfer->len, maxsize);
-
 	/* calculate how many we have to replace */
 	count = DIV_ROUND_UP(xfer->len, maxsize);
 

commit 76d2f7ee68b669c5825435bad204f3d9b4b55d18
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Fri Apr 12 16:25:51 2019 +0300

    spi: Remove one needless transfer speed fall back case
    
    Falling back to maximum speed of the controller in case of SPI slave
    maximum speed is not set is needless. It already defaults to maximum
    speed of the controller since commit 052eb2d49006 ("spi: core: Set
    max_speed_hz of spi_device default to max_speed_hz of controller").
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index bf4027b54a19..86a31340ad03 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -3084,8 +3084,6 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 
 		if (!xfer->speed_hz)
 			xfer->speed_hz = spi->max_speed_hz;
-		if (!xfer->speed_hz)
-			xfer->speed_hz = ctlr->max_speed_hz;
 
 		if (ctlr->max_speed_hz && xfer->speed_hz > ctlr->max_speed_hz)
 			xfer->speed_hz = ctlr->max_speed_hz;

commit f1ca9992ced71029735784de138f53446363087f
Author: Sowjanya Komatineni <skomatineni@nvidia.com>
Date:   Thu Apr 4 17:14:16 2019 -0700

    spi: add a method for configuring CS timing
    
    This patch creates set_cs_timing SPI master optional method for
    SPI masters to implement configuring CS timing if applicable.
    
    This patch also creates spi_cs_timing accessory for SPI clients to
    use for requesting SPI master controllers to configure device requested
    CS setup time, hold time and inactive delay.
    
    Signed-off-by: Sowjanya Komatineni <skomatineni@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index fd1372fe0505..bf4027b54a19 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2995,6 +2995,21 @@ int spi_setup(struct spi_device *spi)
 }
 EXPORT_SYMBOL_GPL(spi_setup);
 
+/**
+ * spi_set_cs_timing - configure CS setup, hold, and inactive delays
+ * @spi: the device that requires specific CS timing configuration
+ * @setup: CS setup time in terms of clock count
+ * @hold: CS hold time in terms of clock count
+ * @inactive_dly: CS inactive delay between transfers in terms of clock count
+ */
+void spi_set_cs_timing(struct spi_device *spi, u8 setup, u8 hold,
+		       u8 inactive_dly)
+{
+	if (spi->controller->set_cs_timing)
+		spi->controller->set_cs_timing(spi, setup, hold, inactive_dly);
+}
+EXPORT_SYMBOL_GPL(spi_set_cs_timing);
+
 static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 {
 	struct spi_controller *ctlr = spi->controller;

commit b93318a22f23cad8a3732451d83c604f289fcfc7
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Fri Apr 5 18:48:50 2019 +0300

    spi: kill useless initializer in spi_register_controller()
    
    The 'status' local variable is initialized but this value is never used,
    thus kill that initializer.
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index a83fcddf1dad..fd1372fe0505 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2267,7 +2267,7 @@ int spi_register_controller(struct spi_controller *ctlr)
 {
 	struct device		*dev = ctlr->dev.parent;
 	struct boardinfo	*bi;
-	int			status = -ENODEV;
+	int			status;
 	int			id, first_dynamic;
 
 	if (!dev)

commit 0a919ae49223d32ac0e8be3494547fcd1e4aa0aa
Author: Andrey Smirnov <andrew.smirnov@gmail.com>
Date:   Tue Apr 2 21:01:28 2019 -0700

    spi: Don't call spi_get_gpio_descs() before device name is set
    
    Move code calling spi_get_gpio_descs() to happen after ctlr->dev's
    name is set in order to have proper GPIO consumer names.
    
    Before:
    
    cat /sys/kernel/debug/gpio
    gpiochip0: GPIOs 0-31, parent: platform/40049000.gpio, vf610-gpio:
     gpio-6   (                    |regulator-usb0-vbus ) out lo
    
    gpiochip1: GPIOs 32-63, parent: platform/4004a000.gpio, vf610-gpio:
     gpio-36  (                    |scl                 ) in  hi
     gpio-37  (                    |sda                 ) in  hi
     gpio-40  (                    |(null) CS1          ) out lo
     gpio-41  (                    |(null) CS0          ) out lo ACTIVE LOW
     gpio-42  (                    |miso                ) in  hi
     gpio-43  (                    |mosi                ) in  lo
     gpio-44  (                    |sck                 ) out lo
    
    After:
    
    cat /sys/kernel/debug/gpio
    gpiochip0: GPIOs 0-31, parent: platform/40049000.gpio, vf610-gpio:
     gpio-6   (                    |regulator-usb0-vbus ) out lo
    
    gpiochip1: GPIOs 32-63, parent: platform/4004a000.gpio, vf610-gpio:
     gpio-36  (                    |scl                 ) in  hi
     gpio-37  (                    |sda                 ) in  hi
     gpio-40  (                    |spi0 CS1            ) out lo
     gpio-41  (                    |spi0 CS0            ) out lo ACTIVE LOW
     gpio-42  (                    |miso                ) in  hi
     gpio-43  (                    |mosi                ) in  lo
     gpio-44  (                    |sck                 ) out lo
    
    Signed-off-by: Andrey Smirnov <andrew.smirnov@gmail.com>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Chris Healy <cphealy@gmail.com>
    Cc: linux-spi@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 2ad20c735b61..a83fcddf1dad 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2281,24 +2281,6 @@ int spi_register_controller(struct spi_controller *ctlr)
 	if (status)
 		return status;
 
-	if (!spi_controller_is_slave(ctlr)) {
-		if (ctlr->use_gpio_descriptors) {
-			status = spi_get_gpio_descs(ctlr);
-			if (status)
-				return status;
-			/*
-			 * A controller using GPIO descriptors always
-			 * supports SPI_CS_HIGH if need be.
-			 */
-			ctlr->mode_bits |= SPI_CS_HIGH;
-		} else {
-			/* Legacy code path for GPIOs from DT */
-			status = of_spi_register_master(ctlr);
-			if (status)
-				return status;
-		}
-	}
-
 	/* even if it's just one always-selected device, there must
 	 * be at least one chipselect
 	 */
@@ -2355,6 +2337,25 @@ int spi_register_controller(struct spi_controller *ctlr)
 	 * registration fails if the bus ID is in use.
 	 */
 	dev_set_name(&ctlr->dev, "spi%u", ctlr->bus_num);
+
+	if (!spi_controller_is_slave(ctlr)) {
+		if (ctlr->use_gpio_descriptors) {
+			status = spi_get_gpio_descs(ctlr);
+			if (status)
+				return status;
+			/*
+			 * A controller using GPIO descriptors always
+			 * supports SPI_CS_HIGH if need be.
+			 */
+			ctlr->mode_bits |= SPI_CS_HIGH;
+		} else {
+			/* Legacy code path for GPIOs from DT */
+			status = of_spi_register_master(ctlr);
+			if (status)
+				return status;
+		}
+	}
+
 	status = device_add(&ctlr->dev);
 	if (status < 0) {
 		/* free bus id */

commit e1a7d1673062a6a9160b1fc94e1540b747398e01
Merge: 9fda6693335c a026525d4e45
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Apr 5 10:19:10 2019 +0700

    Merge branch 'spi-5.1' into spi-5.2

commit 1723fdec5fcbc4de3d26bbb23a9e1704ee258955
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Apr 3 16:46:56 2019 +0200

    spi: Add missing error handling for CS GPIOs
    
    While devm_gpiod_get_index_optional() returns NULL if the GPIO is not
    present (i.e. -ENOENT), it may still return other error codes, like
    -EPROBE_DEFER.  Currently these are not handled, leading to
    unrecoverable failures later in case of probe deferral:
    
        gpiod_set_consumer_name: invalid GPIO (errorpointer)
        gpiod_direction_output: invalid GPIO (errorpointer)
        gpiod_set_value_cansleep: invalid GPIO (errorpointer)
        gpiod_set_value_cansleep: invalid GPIO (errorpointer)
        gpiod_set_value_cansleep: invalid GPIO (errorpointer)
    
    Detect and propagate errors to fix this.
    
    Fixes: f3186dd876697e69 ("spi: Optionally use GPIO descriptors for CS GPIOs")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 2be394d3bc59..7b6494bd8a9b 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2197,6 +2197,8 @@ static int spi_get_gpio_descs(struct spi_controller *ctlr)
 		 */
 		cs[i] = devm_gpiod_get_index_optional(dev, "cs", i,
 						      GPIOD_OUT_LOW);
+		if (IS_ERR(cs[i]))
+			return PTR_ERR(cs[i]);
 
 		if (cs[i]) {
 			/*

commit ca1438dcb34c7fcad63b6ce14ea63a870b92a69b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Mar 21 13:42:25 2019 +0100

    spi: export tracepoint symbols to modules
    
    The newly added tracepoints in the spi-mxs driver cause a link
    error when the driver is a loadable module:
    
    ERROR: "__tracepoint_spi_transfer_stop" [drivers/spi/spi-mxs.ko] undefined!
    ERROR: "__tracepoint_spi_transfer_start" [drivers/spi/spi-mxs.ko] undefined!
    
    I'm not quite sure where to put the export statements, but
    directly after the inclusion of the header seems as good as
    any other place.
    
    Fixes: f3fdea3af405 ("spi: mxs: add tracing to custom .transfer_one_message callback")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 2be394d3bc59..bd2a424672df 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -36,6 +36,8 @@
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/spi.h>
+EXPORT_TRACEPOINT_SYMBOL(spi_transfer_start);
+EXPORT_TRACEPOINT_SYMBOL(spi_transfer_stop);
 
 #include "internals.h"
 

commit 5442dcaa0d90fc376bdfc179a018931a8f43dea4
Author: Chris Lesiak <chris.lesiak@licor.com>
Date:   Thu Mar 7 20:39:00 2019 +0000

    spi: Fix zero length xfer bug
    
    This fixes a bug for messages containing both zero length and
    unidirectional xfers.
    
    The function spi_map_msg will allocate dummy tx and/or rx buffers
    for use with unidirectional transfers when the hardware can only do
    a bidirectional transfer.  That dummy buffer will be used in place
    of a NULL buffer even when the xfer length is 0.
    
    Then in the function __spi_map_msg, if he hardware can dma,
    the zero length xfer will have spi_map_buf called on the dummy
    buffer.
    
    Eventually, __sg_alloc_table is called and returns -EINVAL
    because nents == 0.
    
    This fix prevents the error by not using the dummy buffer when
    the xfer length is zero.
    
    Signed-off-by: Chris Lesiak <chris.lesiak@licor.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 93986f879b09..2be394d3bc59 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1039,6 +1039,8 @@ static int spi_map_msg(struct spi_controller *ctlr, struct spi_message *msg)
 		if (max_tx || max_rx) {
 			list_for_each_entry(xfer, &msg->transfers,
 					    transfer_list) {
+				if (!xfer->len)
+					continue;
 				if (!xfer->tx_buf)
 					xfer->tx_buf = ctlr->dummy_tx;
 				if (!xfer->rx_buf)

commit 28f7604f48c1cbb69e9c45bc53c84b6ad1f7fa77
Author: Felix Fietkau <nbd@nbd.name>
Date:   Sun Feb 10 00:38:25 2019 +0100

    spi: use gpio[d]_set_value_cansleep for setting chipselect GPIO
    
    Sleeping is safe inside spi_transfer_one_message, and some
    GPIO chips are running on slow busses (such as I2C GPIO
    expanders) and need to sleep for setting values.
    
    Signed-off-by: Felix Fietkau <nbd@nbd.name>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 2f7176f07591..93986f879b09 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -786,9 +786,10 @@ static void spi_set_cs(struct spi_device *spi, bool enable)
 		 */
 		if (!(spi->mode & SPI_NO_CS)) {
 			if (spi->cs_gpiod)
-				gpiod_set_value(spi->cs_gpiod, !enable);
+				gpiod_set_value_cansleep(spi->cs_gpiod,
+							 !enable);
 			else
-				gpio_set_value(spi->cs_gpio, !enable);
+				gpio_set_value_cansleep(spi->cs_gpio, !enable);
 		}
 		/* Some SPI masters need both GPIO CS & slave_select */
 		if ((spi->controller->flags & SPI_MASTER_GPIO_SS) &&

commit b7bb367afa4bf9de60830683305c63030c3e581d
Author: Jonas Bonn <jonas@norrbonn.se>
Date:   Wed Jan 30 09:40:04 2019 +0100

    spi: support inter-word delay requirement for devices
    
    Some devices are slow and cannot keep up with the SPI bus and therefore
    require a short delay between words of the SPI transfer.
    
    The example of this that I'm looking at is a SAMA5D2 with a minimum SPI
    clock of 400kHz talking to an AVR-based SPI slave.  The AVR cannot put
    bytes on the bus fast enough to keep up with the SoC's SPI controller
    even at the lowest bus speed.
    
    This patch introduces the ability to specify a required inter-word
    delay for SPI devices.  It is up to the controller driver to configure
    itself accordingly in order to introduce the requested delay.
    
    Note that, for spi_transfer, there is already a field word_delay that
    provides similar functionality.  This field, however, is specified in
    clock cycles (and worse, SPI controller cycles, not SCK cycles); that
    makes this value dependent on the master clock instead of the device
    clock for which the delay is intended to provide some relief.  This
    patch leaves this old word_delay in place and provides a time-based
    word_delay_us alongside it; the new field fits in the struct padding
    so struct size is constant.  There is only one in-kernel user of the
    word_delay field and presumably that driver could be reworked to use
    the time-based value instead.
    
    The time-based delay is limited to 8 bits as these delays are intended
    to be short.  The SAMA5D2 that I've tested this on limits delays to a
    maximum of ~100us, which is already many word-transfer periods even at
    the minimum transfer speed supported by the controller.
    
    Signed-off-by: Jonas Bonn <jonas@norrbonn.se>
    CC: Mark Brown <broonie@kernel.org>
    CC: Rob Herring <robh+dt@kernel.org>
    CC: Mark Rutland <mark.rutland@arm.com>
    CC: linux-spi@vger.kernel.org
    CC: devicetree@vger.kernel.org
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 0e0f2c62973c..2f7176f07591 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -3050,6 +3050,8 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 	 * it is not set for this transfer.
 	 * Set transfer tx_nbits and rx_nbits as single transfer default
 	 * (SPI_NBITS_SINGLE) if it is not set for this transfer.
+	 * Ensure transfer word_delay is at least as long as that required by
+	 * device itself.
 	 */
 	message->frame_length = 0;
 	list_for_each_entry(xfer, &message->transfers, transfer_list) {
@@ -3120,6 +3122,9 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 				!(spi->mode & SPI_RX_QUAD))
 				return -EINVAL;
 		}
+
+		if (xfer->word_delay_usecs < spi->word_delay_usecs)
+			xfer->word_delay_usecs = spi->word_delay_usecs;
 	}
 
 	message->status = -EINPROGRESS;

commit 2df201e0067d84db5955d07cc0d7ccc3b7295aef
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Jan 16 09:21:07 2019 +0100

    spi: Support high CS when using descriptors
    
    All controllers using GPIO descriptors can by definition
    support high CS connections, so just enforce this when
    registering an SPI controller.
    
    This fixes a regression where controllers were missing
    SPI_CS_HIGH, the drivers would fail like this:
    
    spi spi0.0: setup: unsupported mode bits 4
    cdns-spi fd0b0000.spi: can't setup spi0.0, status -22
    
    This is because as using descriptors moves the CS inversion
    logic over to gpiolib, all such controllers are registered
    with CS active high.
    
    Cc: Jan Kotas <jank@cadence.com>
    Reported-by: Jan Kotas <jank@cadence.com>
    Tested-by: Jan Kotas <jank@cadence.com>
    Fixes: f3186dd87669 ("spi: Optionally use GPIO descriptors for CS GPIOs")
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 13f447a67d67..0e0f2c62973c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2279,6 +2279,11 @@ int spi_register_controller(struct spi_controller *ctlr)
 			status = spi_get_gpio_descs(ctlr);
 			if (status)
 				return status;
+			/*
+			 * A controller using GPIO descriptors always
+			 * supports SPI_CS_HIGH if need be.
+			 */
+			ctlr->mode_bits |= SPI_CS_HIGH;
 		} else {
 			/* Legacy code path for GPIOs from DT */
 			status = of_spi_register_master(ctlr);

commit f0125f1a559be1033055f44e511174aaa75b60cc
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Jan 23 17:29:53 2019 +0000

    spi: Go back to immediate teardown
    
    Commit 412e6037324 ("spi: core: avoid waking pump thread from spi_sync
    instead run teardown delayed") introduced regressions on some boards,
    apparently connected to spi_mem not triggering shutdown properly any
    more.  Since we've thus far been unable to figure out exactly where the
    breakage is revert the optimisation for now.
    
    Reported-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: kernel@martin.sperl.org

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 06b9139664a3..13f447a67d67 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1225,7 +1225,7 @@ static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 		return;
 	}
 
-	/* If another context is idling the device then defer to kthread */
+	/* If another context is idling the device then defer */
 	if (ctlr->idling) {
 		kthread_queue_work(&ctlr->kworker, &ctlr->pump_messages);
 		spin_unlock_irqrestore(&ctlr->queue_lock, flags);
@@ -1239,10 +1239,34 @@ static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 			return;
 		}
 
-		/* schedule idle teardown with a delay of 1 second */
-		kthread_mod_delayed_work(&ctlr->kworker,
-					 &ctlr->pump_idle_teardown,
-					 HZ);
+		/* Only do teardown in the thread */
+		if (!in_kthread) {
+			kthread_queue_work(&ctlr->kworker,
+					   &ctlr->pump_messages);
+			spin_unlock_irqrestore(&ctlr->queue_lock, flags);
+			return;
+		}
+
+		ctlr->busy = false;
+		ctlr->idling = true;
+		spin_unlock_irqrestore(&ctlr->queue_lock, flags);
+
+		kfree(ctlr->dummy_rx);
+		ctlr->dummy_rx = NULL;
+		kfree(ctlr->dummy_tx);
+		ctlr->dummy_tx = NULL;
+		if (ctlr->unprepare_transfer_hardware &&
+		    ctlr->unprepare_transfer_hardware(ctlr))
+			dev_err(&ctlr->dev,
+				"failed to unprepare transfer hardware\n");
+		if (ctlr->auto_runtime_pm) {
+			pm_runtime_mark_last_busy(ctlr->dev.parent);
+			pm_runtime_put_autosuspend(ctlr->dev.parent);
+		}
+		trace_spi_controller_idle(ctlr);
+
+		spin_lock_irqsave(&ctlr->queue_lock, flags);
+		ctlr->idling = false;
 		spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 		return;
 	}
@@ -1335,77 +1359,6 @@ static void spi_pump_messages(struct kthread_work *work)
 	__spi_pump_messages(ctlr, true);
 }
 
-/**
- * spi_pump_idle_teardown - kthread delayed work function which tears down
- *                          the controller settings after some delay
- * @work: pointer to kthread work struct contained in the controller struct
- */
-static void spi_pump_idle_teardown(struct kthread_work *work)
-{
-	struct spi_controller *ctlr =
-		container_of(work, struct spi_controller,
-			     pump_idle_teardown.work);
-	unsigned long flags;
-
-	/* Lock queue */
-	spin_lock_irqsave(&ctlr->queue_lock, flags);
-
-	/* Make sure we are not already running a message */
-	if (ctlr->cur_msg)
-		goto out;
-
-	/* if there is anything in the list then exit */
-	if (!list_empty(&ctlr->queue))
-		goto out;
-
-	/* if the controller is running then exit */
-	if (ctlr->running)
-		goto out;
-
-	/* if the controller is busy then exit */
-	if (ctlr->busy)
-		goto out;
-
-	/* if the controller is idling then exit
-	 * this is actually a bit strange and would indicate that
-	 * this function is scheduled twice, which should not happen
-	 */
-	if (ctlr->idling)
-		goto out;
-
-	/* set up the initial states */
-	ctlr->busy = false;
-	ctlr->idling = true;
-	spin_unlock_irqrestore(&ctlr->queue_lock, flags);
-
-	/* free dummy receive buffers */
-	kfree(ctlr->dummy_rx);
-	ctlr->dummy_rx = NULL;
-	kfree(ctlr->dummy_tx);
-	ctlr->dummy_tx = NULL;
-
-	/* unprepare hardware */
-	if (ctlr->unprepare_transfer_hardware &&
-	    ctlr->unprepare_transfer_hardware(ctlr))
-		dev_err(&ctlr->dev,
-			"failed to unprepare transfer hardware\n");
-	/* handle pm */
-	if (ctlr->auto_runtime_pm) {
-		pm_runtime_mark_last_busy(ctlr->dev.parent);
-		pm_runtime_put_autosuspend(ctlr->dev.parent);
-	}
-
-	/* mark controller as idle */
-	trace_spi_controller_idle(ctlr);
-
-	/* finally put us from idling into stopped */
-	spin_lock_irqsave(&ctlr->queue_lock, flags);
-	ctlr->idling = false;
-
-out:
-	spin_unlock_irqrestore(&ctlr->queue_lock, flags);
-}
-
 static int spi_init_queue(struct spi_controller *ctlr)
 {
 	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
@@ -1421,8 +1374,7 @@ static int spi_init_queue(struct spi_controller *ctlr)
 		return PTR_ERR(ctlr->kworker_task);
 	}
 	kthread_init_work(&ctlr->pump_messages, spi_pump_messages);
-	kthread_init_delayed_work(&ctlr->pump_idle_teardown,
-				  spi_pump_idle_teardown);
+
 	/*
 	 * Controller config will indicate if this controller should run the
 	 * message pump with high (realtime) priority to reduce the transfer
@@ -1494,16 +1446,7 @@ void spi_finalize_current_message(struct spi_controller *ctlr)
 	spin_lock_irqsave(&ctlr->queue_lock, flags);
 	ctlr->cur_msg = NULL;
 	ctlr->cur_msg_prepared = false;
-
-	/* if there is something queued, then wake the queue */
-	if (!list_empty(&ctlr->queue))
-		kthread_queue_work(&ctlr->kworker, &ctlr->pump_messages);
-	else
-		/* otherwise schedule delayed teardown */
-		kthread_mod_delayed_work(&ctlr->kworker,
-					 &ctlr->pump_idle_teardown,
-					 HZ);
-
+	kthread_queue_work(&ctlr->kworker, &ctlr->pump_messages);
 	spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 
 	trace_spi_message_done(mesg);
@@ -1608,7 +1551,7 @@ static int __spi_queued_transfer(struct spi_device *spi,
 	msg->status = -EINPROGRESS;
 
 	list_add_tail(&msg->queue, &ctlr->queue);
-	if (need_pump)
+	if (!ctlr->busy && need_pump)
 		kthread_queue_work(&ctlr->kworker, &ctlr->pump_messages);
 
 	spin_unlock_irqrestore(&ctlr->queue_lock, flags);
@@ -3783,3 +3726,4 @@ static int __init spi_init(void)
  * include needing to have boardinfo data structures be much more public.
  */
 postcore_initcall(spi_init);
+

commit 412e60373245fd1dfae8d4d44c5d1406b3d90971
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Tue Jan 8 12:13:45 2019 +0000

    spi: core: avoid waking pump thread from spi_sync instead run teardown delayed
    
    When spi_sync is running alone with no other spi devices connected
    to the bus the worker thread is woken during spi_finalize_current_message
    to run the teardown code every time.
    
    This is totally unnecessary in the case that there is no message queued.
    
    On a multi-core system this results in one wakeup of the thread for each
    spi_message processed via spi_sync where in most cases the teardown does
    not happen as the hw is already in use.
    
    This patch now delays the teardown by 1 second by using a separate
    kthread_delayed_work for the teardown.
    
    This avoids waking the kthread too often.
    
    For spi_sync transfers in a tight loop (say 40k messages/s) this
    avoids the penalty of waking the worker thread 40k times/s.
    On a rasperry pi 3 with 4 cores the results in 32% of a single core
    only to find out that there is nothing in the queue and it can go back
    to sleep.
    
    With this patch applied the spi-worker is woken exactly once: after
    the load finishes and the spi bus is idle for 1 second.
    
    I believe I have also seen situations where during a spi_sync loop
    the worker thread (triggered by the last message finished) is slightly
    faster and _wins_ the race to process the message, so we are actually
    running the kthread and letting it do some work...
    
    This is also no longer observed with this patch applied as.
    
    Tested with a new CAN controller driver for the mcp2517fd which
    uses spi_sync for interrupt handling and spi_async for scheduling
    of can frames for transmission (in a different thread)
    
    Some statistics when receiving 100000 CAN frames with the mcp25xxfd driver
    on a Raspberry pi 3:
    
    without the patch:
    ------------------
    root@raspcm3:~# for x in $(pgrep spi0) $(pgrep irq/94-mcp25xxf) ; do awk '{printf "%-20s %6i\n", $2,$15}' /proc/$x/stat; done
    (spi0)                    5
    (irq/94-mcp25xxf)         0
    root@raspcm3:~# vmstat 1
    procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
     r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
     1  0      0 821960  13592  50848    0    0    80     2 1986  105  1  2 97  0  0
     0  0      0 821968  13592  50876    0    0     0     0 8046   30  0  0 100  0  0
     0  0      0 821936  13592  50876    0    0     0     0 8032   24  0  0 100  0  0
     0  0      0 821936  13592  50876    0    0     0     0 8035   30  0  0 100  0  0
     0  0      0 821936  13592  50876    0    0     0     0 8033   22  0  0 100  0  0
     2  0      0 821936  13592  50876    0    0     0     0 11598 7129  0  3 97  0  0
     1  0      0 821872  13592  50876    0    0     0     0 37741 59003  0 31 69  0  0
     2  0      0 821840  13592  50876    0    0     0     0 37762 59078  0 29 71  0  0
     2  0      0 821776  13592  50876    0    0     0     0 37593 58792  0 28 72  0  0
     1  0      0 821744  13592  50876    0    0     0     0 37642 58881  0 30 70  0  0
     2  0      0 821680  13592  50876    0    0     0     0 37490 58602  0 27 73  0  0
     1  0      0 821648  13592  50876    0    0     0     0 37412 58418  0 29 71  0  0
     1  0      0 821584  13592  50876    0    0     0     0 37337 58288  0 27 73  0  0
     1  0      0 821552  13592  50876    0    0     0     0 37584 58774  0 27 73  0  0
     0  0      0 821520  13592  50876    0    0     0     0 18363 20566  0  9 91  0  0
     0  0      0 821520  13592  50876    0    0     0     0 8037   32  0  0 100  0  0
     0  0      0 821520  13592  50876    0    0     0     0 8031   23  0  0 100  0  0
     0  0      0 821520  13592  50876    0    0     0     0 8034   26  0  0 100  0  0
     0  0      0 821520  13592  50876    0    0     0     0 8033   24  0  0 100  0  0
    ^C
    root@raspcm3:~# for x in $(pgrep spi0) $(pgrep irq/94-mcp25xxf) ; do awk '{printf "%-20s %6i\n", $2,$15}' /proc/$x/stat; done
    (spi0)                  228
    (irq/94-mcp25xxf)       794
    root@raspcm3:~# cat /proc/interrupts
               CPU0       CPU1       CPU2       CPU3
     17:         34          0          0          0  ARMCTRL-level   1 Edge      3f00b880.mailbox
     27:          1          0          0          0  ARMCTRL-level  35 Edge      timer
     33:    1416870          0          0          0  ARMCTRL-level  41 Edge      3f980000.usb, dwc2_hsotg:usb1
     34:          1          0          0          0  ARMCTRL-level  42 Edge      vc4
     35:          0          0          0          0  ARMCTRL-level  43 Edge      3f004000.txp
     40:       1753          0          0          0  ARMCTRL-level  48 Edge      DMA IRQ
     42:         11          0          0          0  ARMCTRL-level  50 Edge      DMA IRQ
     44:         11          0          0          0  ARMCTRL-level  52 Edge      DMA IRQ
     45:          0          0          0          0  ARMCTRL-level  53 Edge      DMA IRQ
     66:          0          0          0          0  ARMCTRL-level  74 Edge      vc4 crtc
     69:          0          0          0          0  ARMCTRL-level  77 Edge      vc4 crtc
     70:          0          0          0          0  ARMCTRL-level  78 Edge      vc4 crtc
     77:         20          0          0          0  ARMCTRL-level  85 Edge      3f205000.i2c, 3f804000.i2c, 3f805000.i2c
     78:       6346          0          0          0  ARMCTRL-level  86 Edge      3f204000.spi
     80:        205          0          0          0  ARMCTRL-level  88 Edge      mmc0
     81:        493          0          0          0  ARMCTRL-level  89 Edge      uart-pl011
     89:          0          0          0          0  bcm2836-timer   0 Edge      arch_timer
     90:       4291       3821       2180       1649  bcm2836-timer   1 Edge      arch_timer
     94:      14289          0          0          0  pinctrl-bcm2835  16 Level     mcp25xxfd
    IPI0:          0          0          0          0  CPU wakeup interrupts
    IPI1:          0          0          0          0  Timer broadcast interrupts
    IPI2:       3645     242371       7919       1328  Rescheduling interrupts
    IPI3:        112        543        273        194  Function call interrupts
    IPI4:          0          0          0          0  CPU stop interrupts
    IPI5:          1          0          0          0  IRQ work interrupts
    IPI6:          0          0          0          0  completion interrupts
    Err:          0
    
    top shows 93% for the mcp25xxfd interrupt handler, 31% for spi0.
    
    with the patch:
    ---------------
    root@raspcm3:~# for x in $(pgrep spi0) $(pgrep irq/94-mcp25xxf) ; do awk '{printf "%-20s %6i\n", $2,$15}' /proc/$x/stat; done
    (spi0)                    0
    (irq/94-mcp25xxf)         0
    root@raspcm3:~# vmstat 1
    procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
     0  0      0 804768  13584  62628    0    0     0     0 8038   24  0  0 100  0  0
     0  0      0 804768  13584  62628    0    0     0     0 8042   25  0  0 100  0  0
     1  0      0 804704  13584  62628    0    0     0     0 9603 2967  0 20 80  0  0
     1  0      0 804672  13584  62628    0    0     0     0 9828 3380  0 24 76  0  0
     1  0      0 804608  13584  62628    0    0     0     0 9823 3375  0 23 77  0  0
     1  0      0 804608  13584  62628    0    0     0    12 9829 3394  0 23 77  0  0
     1  0      0 804544  13584  62628    0    0     0     0 9816 3362  0 22 78  0  0
     1  0      0 804512  13584  62628    0    0     0     0 9817 3367  0 23 77  0  0
     1  0      0 804448  13584  62628    0    0     0     0 9822 3370  0 22 78  0  0
     1  0      0 804416  13584  62628    0    0     0     0 9815 3367  0 23 77  0  0
     0  0      0 804352  13584  62628    0    0     0    84 9222 2250  0 14 86  0  0
     0  0      0 804352  13592  62620    0    0     0    24 8131  209  0  0 93  7  0
     0  0      0 804320  13592  62628    0    0     0     0 8041   27  0  0 100  0  0
     0  0      0 804352  13592  62628    0    0     0     0 8040   26  0  0 100  0  0
    root@raspcm3:~# for x in $(pgrep spi0) $(pgrep irq/94-mcp25xxf) ; do awk '{printf "%-20s %6i\n", $2,$15}' /proc/$x/stat; done
    (spi0)                    0
    (irq/94-mcp25xxf)       767
    root@raspcm3:~# cat /proc/interrupts
               CPU0       CPU1       CPU2       CPU3
     17:         29          0          0          0  ARMCTRL-level   1 Edge      3f00b880.mailbox
     27:          1          0          0          0  ARMCTRL-level  35 Edge      timer
     33:    1024412          0          0          0  ARMCTRL-level  41 Edge      3f980000.usb, dwc2_hsotg:usb1
     34:          1          0          0          0  ARMCTRL-level  42 Edge      vc4
     35:          0          0          0          0  ARMCTRL-level  43 Edge      3f004000.txp
     40:       1773          0          0          0  ARMCTRL-level  48 Edge      DMA IRQ
     42:         11          0          0          0  ARMCTRL-level  50 Edge      DMA IRQ
     44:         11          0          0          0  ARMCTRL-level  52 Edge      DMA IRQ
     45:          0          0          0          0  ARMCTRL-level  53 Edge      DMA IRQ
     66:          0          0          0          0  ARMCTRL-level  74 Edge      vc4 crtc
     69:          0          0          0          0  ARMCTRL-level  77 Edge      vc4 crtc
     70:          0          0          0          0  ARMCTRL-level  78 Edge      vc4 crtc
     77:         20          0          0          0  ARMCTRL-level  85 Edge      3f205000.i2c, 3f804000.i2c, 3f805000.i2c
     78:       6417          0          0          0  ARMCTRL-level  86 Edge      3f204000.spi
     80:        237          0          0          0  ARMCTRL-level  88 Edge      mmc0
     81:        489          0          0          0  ARMCTRL-level  89 Edge      uart-pl011
     89:          0          0          0          0  bcm2836-timer   0 Edge      arch_timer
     90:       4048       3704       2383       1892  bcm2836-timer   1 Edge      arch_timer
     94:      14287          0          0          0  pinctrl-bcm2835  16 Level     mcp25xxfd
    IPI0:          0          0          0          0  CPU wakeup interrupts
    IPI1:          0          0          0          0  Timer broadcast interrupts
    IPI2:       2361       2948       7890       1616  Rescheduling interrupts
    IPI3:         65        617        301        166  Function call interrupts
    IPI4:          0          0          0          0  CPU stop interrupts
    IPI5:          1          0          0          0  IRQ work interrupts
    IPI6:          0          0          0          0  completion interrupts
    Err:          0
    top shows 91% for the mcp25xxfd interrupt handler, 0% for spi0
    
    So we see that spi0 is no longer getting scheduled wasting CPU cycles
    There are a lot less context switches and corresponding Rescheduling interrupts
    All of these show that this improves efficiency of the system and reduces
    CPU utilization.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 13f447a67d67..06b9139664a3 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1225,7 +1225,7 @@ static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 		return;
 	}
 
-	/* If another context is idling the device then defer */
+	/* If another context is idling the device then defer to kthread */
 	if (ctlr->idling) {
 		kthread_queue_work(&ctlr->kworker, &ctlr->pump_messages);
 		spin_unlock_irqrestore(&ctlr->queue_lock, flags);
@@ -1239,34 +1239,10 @@ static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 			return;
 		}
 
-		/* Only do teardown in the thread */
-		if (!in_kthread) {
-			kthread_queue_work(&ctlr->kworker,
-					   &ctlr->pump_messages);
-			spin_unlock_irqrestore(&ctlr->queue_lock, flags);
-			return;
-		}
-
-		ctlr->busy = false;
-		ctlr->idling = true;
-		spin_unlock_irqrestore(&ctlr->queue_lock, flags);
-
-		kfree(ctlr->dummy_rx);
-		ctlr->dummy_rx = NULL;
-		kfree(ctlr->dummy_tx);
-		ctlr->dummy_tx = NULL;
-		if (ctlr->unprepare_transfer_hardware &&
-		    ctlr->unprepare_transfer_hardware(ctlr))
-			dev_err(&ctlr->dev,
-				"failed to unprepare transfer hardware\n");
-		if (ctlr->auto_runtime_pm) {
-			pm_runtime_mark_last_busy(ctlr->dev.parent);
-			pm_runtime_put_autosuspend(ctlr->dev.parent);
-		}
-		trace_spi_controller_idle(ctlr);
-
-		spin_lock_irqsave(&ctlr->queue_lock, flags);
-		ctlr->idling = false;
+		/* schedule idle teardown with a delay of 1 second */
+		kthread_mod_delayed_work(&ctlr->kworker,
+					 &ctlr->pump_idle_teardown,
+					 HZ);
 		spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 		return;
 	}
@@ -1359,6 +1335,77 @@ static void spi_pump_messages(struct kthread_work *work)
 	__spi_pump_messages(ctlr, true);
 }
 
+/**
+ * spi_pump_idle_teardown - kthread delayed work function which tears down
+ *                          the controller settings after some delay
+ * @work: pointer to kthread work struct contained in the controller struct
+ */
+static void spi_pump_idle_teardown(struct kthread_work *work)
+{
+	struct spi_controller *ctlr =
+		container_of(work, struct spi_controller,
+			     pump_idle_teardown.work);
+	unsigned long flags;
+
+	/* Lock queue */
+	spin_lock_irqsave(&ctlr->queue_lock, flags);
+
+	/* Make sure we are not already running a message */
+	if (ctlr->cur_msg)
+		goto out;
+
+	/* if there is anything in the list then exit */
+	if (!list_empty(&ctlr->queue))
+		goto out;
+
+	/* if the controller is running then exit */
+	if (ctlr->running)
+		goto out;
+
+	/* if the controller is busy then exit */
+	if (ctlr->busy)
+		goto out;
+
+	/* if the controller is idling then exit
+	 * this is actually a bit strange and would indicate that
+	 * this function is scheduled twice, which should not happen
+	 */
+	if (ctlr->idling)
+		goto out;
+
+	/* set up the initial states */
+	ctlr->busy = false;
+	ctlr->idling = true;
+	spin_unlock_irqrestore(&ctlr->queue_lock, flags);
+
+	/* free dummy receive buffers */
+	kfree(ctlr->dummy_rx);
+	ctlr->dummy_rx = NULL;
+	kfree(ctlr->dummy_tx);
+	ctlr->dummy_tx = NULL;
+
+	/* unprepare hardware */
+	if (ctlr->unprepare_transfer_hardware &&
+	    ctlr->unprepare_transfer_hardware(ctlr))
+		dev_err(&ctlr->dev,
+			"failed to unprepare transfer hardware\n");
+	/* handle pm */
+	if (ctlr->auto_runtime_pm) {
+		pm_runtime_mark_last_busy(ctlr->dev.parent);
+		pm_runtime_put_autosuspend(ctlr->dev.parent);
+	}
+
+	/* mark controller as idle */
+	trace_spi_controller_idle(ctlr);
+
+	/* finally put us from idling into stopped */
+	spin_lock_irqsave(&ctlr->queue_lock, flags);
+	ctlr->idling = false;
+
+out:
+	spin_unlock_irqrestore(&ctlr->queue_lock, flags);
+}
+
 static int spi_init_queue(struct spi_controller *ctlr)
 {
 	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
@@ -1374,7 +1421,8 @@ static int spi_init_queue(struct spi_controller *ctlr)
 		return PTR_ERR(ctlr->kworker_task);
 	}
 	kthread_init_work(&ctlr->pump_messages, spi_pump_messages);
-
+	kthread_init_delayed_work(&ctlr->pump_idle_teardown,
+				  spi_pump_idle_teardown);
 	/*
 	 * Controller config will indicate if this controller should run the
 	 * message pump with high (realtime) priority to reduce the transfer
@@ -1446,7 +1494,16 @@ void spi_finalize_current_message(struct spi_controller *ctlr)
 	spin_lock_irqsave(&ctlr->queue_lock, flags);
 	ctlr->cur_msg = NULL;
 	ctlr->cur_msg_prepared = false;
-	kthread_queue_work(&ctlr->kworker, &ctlr->pump_messages);
+
+	/* if there is something queued, then wake the queue */
+	if (!list_empty(&ctlr->queue))
+		kthread_queue_work(&ctlr->kworker, &ctlr->pump_messages);
+	else
+		/* otherwise schedule delayed teardown */
+		kthread_mod_delayed_work(&ctlr->kworker,
+					 &ctlr->pump_idle_teardown,
+					 HZ);
+
 	spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 
 	trace_spi_message_done(mesg);
@@ -1551,7 +1608,7 @@ static int __spi_queued_transfer(struct spi_device *spi,
 	msg->status = -EINPROGRESS;
 
 	list_add_tail(&msg->queue, &ctlr->queue);
-	if (!ctlr->busy && need_pump)
+	if (need_pump)
 		kthread_queue_work(&ctlr->kworker, &ctlr->pump_messages);
 
 	spin_unlock_irqrestore(&ctlr->queue_lock, flags);
@@ -3726,4 +3783,3 @@ static int __init spi_init(void)
  * include needing to have boardinfo data structures be much more public.
  */
 postcore_initcall(spi_init);
-

commit f3186dd876697e696d07136623d5cf0a6fb0bc0f
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Jan 7 16:51:50 2019 +0100

    spi: Optionally use GPIO descriptors for CS GPIOs
    
    This augments the SPI core to optionally use GPIO descriptors
    for chip select on a per-master-driver opt-in basis.
    
    Drivers using this will rely on the SPI core to look up
    GPIO descriptors associated with the device, such as
    when using device tree or board files with GPIO descriptor
    tables.
    
    When getting descriptors from the device tree, this will in
    turn activate the code in gpiolib that was
    added in commit 6953c57ab172
    ("gpio: of: Handle SPI chipselect legacy bindings")
    which means that these descriptors are aware of the active
    low semantics that is the default for SPI CS GPIO lines
    and we can assume that all of these are "active high" and
    thus assign SPI_CS_HIGH to all CS lines on the DT path.
    
    The previously used gpio_set_value() would call down into
    gpiod_set_raw_value() and ignore the polarity inversion
    semantics.
    
    It seems like many drivers go to great lengths to set up the
    CS GPIO line as non-asserted, respecting SPI_CS_HIGH. We pull
    this out of the SPI drivers and into the core, and by simply
    requesting the line as GPIOD_OUT_LOW when retrieveing it from
    the device and relying on the gpiolib to handle any inversion
    semantics. This way a lot of code can be simplified and
    removed in each converted driver.
    
    The end goal after dealing with each driver in turn, is to
    delete the non-descriptor path (of_spi_register_master() for
    example) and let the core deal with only descriptors.
    
    The different SPI drivers have complex interactions with the
    core so we cannot simply change them all over, we need to use
    a stepwise, bisectable approach so that each driver can be
    converted and fixed in isolation.
    
    This patch has the intended side effect of adding support for
    ACPI GPIOs as it starts relying on gpiod_get_*() to get
    the GPIO handle associated with the device.
    
    Cc: Linuxarm <linuxarm@huawei.com>
    Acked-by: Jonathan Cameron <jonathan.cameron@huawei.com>
    Tested-by: Fangjian (Turing) <f.fangjian@huawei.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 9a7def7c3237..13f447a67d67 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -19,6 +19,7 @@
 #include <linux/spi/spi.h>
 #include <linux/spi/spi-mem.h>
 #include <linux/of_gpio.h>
+#include <linux/gpio/consumer.h>
 #include <linux/pm_runtime.h>
 #include <linux/pm_domain.h>
 #include <linux/property.h>
@@ -578,7 +579,10 @@ int spi_add_device(struct spi_device *spi)
 		goto done;
 	}
 
-	if (ctlr->cs_gpios)
+	/* Descriptors take precedence */
+	if (ctlr->cs_gpiods)
+		spi->cs_gpiod = ctlr->cs_gpiods[spi->chip_select];
+	else if (ctlr->cs_gpios)
 		spi->cs_gpio = ctlr->cs_gpios[spi->chip_select];
 
 	/* Drivers may modify this initial i/o setup, but will
@@ -772,10 +776,20 @@ static void spi_set_cs(struct spi_device *spi, bool enable)
 	if (spi->mode & SPI_CS_HIGH)
 		enable = !enable;
 
-	if (gpio_is_valid(spi->cs_gpio)) {
-		/* Honour the SPI_NO_CS flag */
-		if (!(spi->mode & SPI_NO_CS))
-			gpio_set_value(spi->cs_gpio, !enable);
+	if (spi->cs_gpiod || gpio_is_valid(spi->cs_gpio)) {
+		/*
+		 * Honour the SPI_NO_CS flag and invert the enable line, as
+		 * active low is default for SPI. Execution paths that handle
+		 * polarity inversion in gpiolib (such as device tree) will
+		 * enforce active high using the SPI_CS_HIGH resulting in a
+		 * double inversion through the code above.
+		 */
+		if (!(spi->mode & SPI_NO_CS)) {
+			if (spi->cs_gpiod)
+				gpiod_set_value(spi->cs_gpiod, !enable);
+			else
+				gpio_set_value(spi->cs_gpio, !enable);
+		}
 		/* Some SPI masters need both GPIO CS & slave_select */
 		if ((spi->controller->flags & SPI_MASTER_GPIO_SS) &&
 		    spi->controller->set_cs)
@@ -1615,13 +1629,21 @@ static int of_spi_parse_dt(struct spi_controller *ctlr, struct spi_device *spi,
 		spi->mode |= SPI_CPHA;
 	if (of_property_read_bool(nc, "spi-cpol"))
 		spi->mode |= SPI_CPOL;
-	if (of_property_read_bool(nc, "spi-cs-high"))
-		spi->mode |= SPI_CS_HIGH;
 	if (of_property_read_bool(nc, "spi-3wire"))
 		spi->mode |= SPI_3WIRE;
 	if (of_property_read_bool(nc, "spi-lsb-first"))
 		spi->mode |= SPI_LSB_FIRST;
 
+	/*
+	 * For descriptors associated with the device, polarity inversion is
+	 * handled in the gpiolib, so all chip selects are "active high" in
+	 * the logical sense, the gpiolib will invert the line if need be.
+	 */
+	if (ctlr->use_gpio_descriptors)
+		spi->mode |= SPI_CS_HIGH;
+	else if (of_property_read_bool(nc, "spi-cs-high"))
+		spi->mode |= SPI_CS_HIGH;
+
 	/* Device DUAL/QUAD mode */
 	if (!of_property_read_u32(nc, "spi-tx-bus-width", &value)) {
 		switch (value) {
@@ -2137,6 +2159,60 @@ static int of_spi_register_master(struct spi_controller *ctlr)
 }
 #endif
 
+/**
+ * spi_get_gpio_descs() - grab chip select GPIOs for the master
+ * @ctlr: The SPI master to grab GPIO descriptors for
+ */
+static int spi_get_gpio_descs(struct spi_controller *ctlr)
+{
+	int nb, i;
+	struct gpio_desc **cs;
+	struct device *dev = &ctlr->dev;
+
+	nb = gpiod_count(dev, "cs");
+	ctlr->num_chipselect = max_t(int, nb, ctlr->num_chipselect);
+
+	/* No GPIOs at all is fine, else return the error */
+	if (nb == 0 || nb == -ENOENT)
+		return 0;
+	else if (nb < 0)
+		return nb;
+
+	cs = devm_kcalloc(dev, ctlr->num_chipselect, sizeof(*cs),
+			  GFP_KERNEL);
+	if (!cs)
+		return -ENOMEM;
+	ctlr->cs_gpiods = cs;
+
+	for (i = 0; i < nb; i++) {
+		/*
+		 * Most chipselects are active low, the inverted
+		 * semantics are handled by special quirks in gpiolib,
+		 * so initializing them GPIOD_OUT_LOW here means
+		 * "unasserted", in most cases this will drive the physical
+		 * line high.
+		 */
+		cs[i] = devm_gpiod_get_index_optional(dev, "cs", i,
+						      GPIOD_OUT_LOW);
+
+		if (cs[i]) {
+			/*
+			 * If we find a CS GPIO, name it after the device and
+			 * chip select line.
+			 */
+			char *gpioname;
+
+			gpioname = devm_kasprintf(dev, GFP_KERNEL, "%s CS%d",
+						  dev_name(dev), i);
+			if (!gpioname)
+				return -ENOMEM;
+			gpiod_set_consumer_name(cs[i], gpioname);
+		}
+	}
+
+	return 0;
+}
+
 static int spi_controller_check_ops(struct spi_controller *ctlr)
 {
 	/*
@@ -2199,9 +2275,16 @@ int spi_register_controller(struct spi_controller *ctlr)
 		return status;
 
 	if (!spi_controller_is_slave(ctlr)) {
-		status = of_spi_register_master(ctlr);
-		if (status)
-			return status;
+		if (ctlr->use_gpio_descriptors) {
+			status = spi_get_gpio_descs(ctlr);
+			if (status)
+				return status;
+		} else {
+			/* Legacy code path for GPIOs from DT */
+			status = of_spi_register_master(ctlr);
+			if (status)
+				return status;
+		}
 	}
 
 	/* even if it's just one always-selected device, there must
@@ -2915,6 +2998,7 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 	 * cs_change is set for each transfer.
 	 */
 	if ((spi->mode & SPI_CS_WORD) && (!(ctlr->mode_bits & SPI_CS_WORD) ||
+					  spi->cs_gpiod ||
 					  gpio_is_valid(spi->cs_gpio))) {
 		size_t maxsize;
 		int ret;

commit 194276b073a10f04b420484bd81fa4dbb3ae0e1e
Author: Rob Herring <robh@kernel.org>
Date:   Wed Dec 5 13:50:41 2018 -0600

    spi: Use of_node_name_eq for node name comparisons
    
    Convert string compares of DT node names to use of_node_name_eq helper
    instead. This removes direct access to the node name pointer.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 18ebc400249c..9a7def7c3237 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1666,7 +1666,7 @@ static int of_spi_parse_dt(struct spi_controller *ctlr, struct spi_device *spi,
 	}
 
 	if (spi_controller_is_slave(ctlr)) {
-		if (strcmp(nc->name, "slave")) {
+		if (!of_node_name_eq(nc, "slave")) {
 			dev_err(&ctlr->dev, "%pOF is not called 'slave'\n",
 				nc);
 			return -EINVAL;

commit 6b03061f882de49b83ccf44beb3a12c920a2da1b
Author: Yogesh Narayan Gaur <yogeshnarayan.gaur@nxp.com>
Date:   Mon Dec 3 08:39:06 2018 +0000

    spi: add support for octal mode I/O data transfer
    
    Add flags for Octal mode I/O data transfer
    Required for the SPI controller which can do the data transfer (TX/RX)
    on 8 data lines e.g. NXP FlexSPI controller.
     SPI_TX_OCTAL: transmit with 8 wires
     SPI_RX_OCTAL: receive with 8 wires
    
    Signed-off-by: Yogesh Gaur <yogeshnarayan.gaur@nxp.com>
    Reviewed-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b6fd8ea8ac0d..18ebc400249c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1633,6 +1633,9 @@ static int of_spi_parse_dt(struct spi_controller *ctlr, struct spi_device *spi,
 		case 4:
 			spi->mode |= SPI_TX_QUAD;
 			break;
+		case 8:
+			spi->mode |= SPI_TX_OCTAL;
+			break;
 		default:
 			dev_warn(&ctlr->dev,
 				"spi-tx-bus-width %d not supported\n",
@@ -1651,6 +1654,9 @@ static int of_spi_parse_dt(struct spi_controller *ctlr, struct spi_device *spi,
 		case 4:
 			spi->mode |= SPI_RX_QUAD;
 			break;
+		case 8:
+			spi->mode |= SPI_RX_OCTAL;
+			break;
 		default:
 			dev_warn(&ctlr->dev,
 				"spi-rx-bus-width %d not supported\n",
@@ -2839,7 +2845,8 @@ int spi_setup(struct spi_device *spi)
 	/* if it is SPI_3WIRE mode, DUAL and QUAD should be forbidden
 	 */
 	if ((spi->mode & SPI_3WIRE) && (spi->mode &
-		(SPI_TX_DUAL | SPI_TX_QUAD | SPI_RX_DUAL | SPI_RX_QUAD)))
+		(SPI_TX_DUAL | SPI_TX_QUAD | SPI_TX_OCTAL |
+		 SPI_RX_DUAL | SPI_RX_QUAD | SPI_RX_OCTAL)))
 		return -EINVAL;
 	/* help drivers fail *cleanly* when they need options
 	 * that aren't supported with their current controller
@@ -2848,7 +2855,8 @@ int spi_setup(struct spi_device *spi)
 	 */
 	bad_bits = spi->mode & ~(spi->controller->mode_bits | SPI_CS_WORD);
 	ugly_bits = bad_bits &
-		    (SPI_TX_DUAL | SPI_TX_QUAD | SPI_RX_DUAL | SPI_RX_QUAD);
+		    (SPI_TX_DUAL | SPI_TX_QUAD | SPI_TX_OCTAL |
+		     SPI_RX_DUAL | SPI_RX_QUAD | SPI_RX_OCTAL);
 	if (ugly_bits) {
 		dev_warn(&spi->dev,
 			 "setup: ignoring unsupported mode bits %x\n",

commit 787f4889a6cf879a3b8b31cf34804da69b40cc10
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Nov 29 16:24:37 2018 +0000

    spi: Fix formatting of header block
    
    Make everything look intentional by having a C++ comment for the whole
    block, not just the SPDX line.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 430ad637c643..b6fd8ea8ac0d 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1,10 +1,8 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * SPI init/core code
- *
- * Copyright (C) 2005 David Brownell
- * Copyright (C) 2008 Secret Lab Technologies Ltd.
- */
+// SPI init/core code
+//
+// Copyright (C) 2005 David Brownell
+// Copyright (C) 2008 Secret Lab Technologies Ltd.
 
 #include <linux/kernel.h>
 #include <linux/device.h>

commit d57e79601bc587f140a9bbb102493ad86f648ae0
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Nov 15 16:08:32 2018 -0800

    spi: Fix core transfer waits after slave support
    
    The refactoring done as part of adding the core support for handling
    waiting for slave transfer dropped a conditional which meant that we
    started waiting for completion of all transfers, not just those that the
    controller asked for.  This caused hangs and massive delays on platforms
    that don't need the core delay.  Re-add the delay to fix this.
    
    Fixes: 810923f3bf06c11 (spi: Deal with slaves that return from transfer_one() unfinished)
    Reported-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 498d3b9bf3ae..430ad637c643 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1114,9 +1114,11 @@ static int spi_transfer_one_message(struct spi_controller *ctlr,
 				goto out;
 			}
 
-			ret = spi_transfer_wait(ctlr, msg, xfer);
-			if (ret < 0)
-				msg->status = ret;
+			if (ret > 0) {
+				ret = spi_transfer_wait(ctlr, msg, xfer);
+				if (ret < 0)
+					msg->status = ret;
+			}
 		} else {
 			if (xfer->len)
 				dev_err(&msg->spi->dev,

commit 810923f3bf06c11022b7bb370dd3130a956a222e
Author: Lubomir Rintel <lkundrak@v3.sk>
Date:   Tue Nov 13 11:22:24 2018 +0100

    spi: Deal with slaves that return from transfer_one() unfinished
    
    Some drivers, such as spi-pxa2xx return from the transfer_one callback
    immediately, idicating that the transfer will be finished asynchronously.
    
    Normally, spi_transfer_one_message() synchronously waits for the
    transfer to finish with wait_for_completion_timeout(). For slaves, we
    don't want the transaction to time out as it can complete in a long time
    in future. Use wait_for_completion_interruptible() instead.
    
    Signed-off-by: Lubomir Rintel <lkundrak@v3.sk>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 6ca59406b0b7..498d3b9bf3ae 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1037,6 +1037,42 @@ static int spi_map_msg(struct spi_controller *ctlr, struct spi_message *msg)
 	return __spi_map_msg(ctlr, msg);
 }
 
+static int spi_transfer_wait(struct spi_controller *ctlr,
+			     struct spi_message *msg,
+			     struct spi_transfer *xfer)
+{
+	struct spi_statistics *statm = &ctlr->statistics;
+	struct spi_statistics *stats = &msg->spi->statistics;
+	unsigned long long ms = 1;
+
+	if (spi_controller_is_slave(ctlr)) {
+		if (wait_for_completion_interruptible(&ctlr->xfer_completion)) {
+			dev_dbg(&msg->spi->dev, "SPI transfer interrupted\n");
+			return -EINTR;
+		}
+	} else {
+		ms = 8LL * 1000LL * xfer->len;
+		do_div(ms, xfer->speed_hz);
+		ms += ms + 200; /* some tolerance */
+
+		if (ms > UINT_MAX)
+			ms = UINT_MAX;
+
+		ms = wait_for_completion_timeout(&ctlr->xfer_completion,
+						 msecs_to_jiffies(ms));
+
+		if (ms == 0) {
+			SPI_STATISTICS_INCREMENT_FIELD(statm, timedout);
+			SPI_STATISTICS_INCREMENT_FIELD(stats, timedout);
+			dev_err(&msg->spi->dev,
+				"SPI transfer timed out\n");
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
 /*
  * spi_transfer_one_message - Default implementation of transfer_one_message()
  *
@@ -1050,7 +1086,6 @@ static int spi_transfer_one_message(struct spi_controller *ctlr,
 	struct spi_transfer *xfer;
 	bool keep_cs = false;
 	int ret = 0;
-	unsigned long long ms = 1;
 	struct spi_statistics *statm = &ctlr->statistics;
 	struct spi_statistics *stats = &msg->spi->statistics;
 
@@ -1079,28 +1114,9 @@ static int spi_transfer_one_message(struct spi_controller *ctlr,
 				goto out;
 			}
 
-			if (ret > 0) {
-				ret = 0;
-				ms = 8LL * 1000LL * xfer->len;
-				do_div(ms, xfer->speed_hz);
-				ms += ms + 200; /* some tolerance */
-
-				if (ms > UINT_MAX)
-					ms = UINT_MAX;
-
-				ms = wait_for_completion_timeout(&ctlr->xfer_completion,
-								 msecs_to_jiffies(ms));
-			}
-
-			if (ms == 0) {
-				SPI_STATISTICS_INCREMENT_FIELD(statm,
-							       timedout);
-				SPI_STATISTICS_INCREMENT_FIELD(stats,
-							       timedout);
-				dev_err(&msg->spi->dev,
-					"SPI transfer timed out\n");
-				msg->status = -ETIMEDOUT;
-			}
+			ret = spi_transfer_wait(ctlr, msg, xfer);
+			if (ret < 0)
+				msg->status = ret;
 		} else {
 			if (xfer->len)
 				dev_err(&msg->spi->dev,

commit 7b9734dbc5b042bb8d8d930797f346b280057c4e
Merge: 4b51c747e4a5 5f143af7501e
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Oct 21 17:00:17 2018 +0100

    Merge remote-tracking branch 'spi/topic/of' into spi-next

commit 4b51c747e4a52175e63d125db8365b38b06f0343
Merge: 92d58fd13af2 0c903aafc852
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Oct 21 17:00:14 2018 +0100

    Merge branch 'spi-4.20' into spi-next

commit 25972d0c33deb5c49708baa48e7796c8d0348e98
Author: Phil Elwell <phil@raspberrypi.org>
Date:   Fri Oct 12 10:23:18 2018 +0100

    spi: Make GPIO CSs honour the SPI_NO_CS flag
    
    The SPI configuration state includes an SPI_NO_CS flag that disables
    all CS line manipulation, for applications that want to manage their
    own chip selects. However, this flag is ignored by the GPIO CS code
    in the SPI framework.
    
    Correct this omission with a trivial patch.
    
    Signed-off-by: Phil Elwell <phil@raspberrypi.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index fcbd4cfd2818..ea3e5e146764 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -775,7 +775,9 @@ static void spi_set_cs(struct spi_device *spi, bool enable)
 		enable = !enable;
 
 	if (gpio_is_valid(spi->cs_gpio)) {
-		gpio_set_value(spi->cs_gpio, !enable);
+		/* Honour the SPI_NO_CS flag */
+		if (!(spi->mode & SPI_NO_CS))
+			gpio_set_value(spi->cs_gpio, !enable);
 		/* Some SPI masters need both GPIO CS & slave_select */
 		if ((spi->controller->flags & SPI_MASTER_GPIO_SS) &&
 		    spi->controller->set_cs)

commit 5039563e7c25eccd7fec1de6706011009d1c5665
Author: Trent Piepho <tpiepho@impinj.com>
Date:   Thu Sep 20 19:18:32 2018 +0000

    spi: Add driver_override SPI device attribute
    
    This attribute works the same was as the identically named attribute
    for PCI, AMBA, and platform devices.  For reference, see:
    
    commit 3cf385713460 ("ARM: 8256/1: driver coamba: add device binding
    path 'driver_override'")
    commit 3d713e0e382e ("driver core: platform: add device binding path
    'driver_override'")
    commit 782a985d7af2 ("PCI: Introduce new device binding path using
    pci_dev.driver_override")
    
    If the name of a driver is written to this attribute, then the device
    will bind to the named driver and only the named driver.
    
    The device will bind to the driver even if the driver does not list the
    device in its id table.  This behavior is different than the driver's
    bind attribute, which only allows binding to devices that are listed as
    supported by the driver.
    
    It can be used to bind a generic driver, like spidev, to a device.
    
    Signed-off-by: Trent Piepho <tpiepho@impinj.com>
    Reviewed-by: Jan KundrÃÂ¡t <jan.kundrat@cesnet.cz>
    Tested-by: Jan KundrÃÂ¡t <jan.kundrat@cesnet.cz>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 2cfc3df821f6..fcbd4cfd2818 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -51,6 +51,7 @@ static void spidev_release(struct device *dev)
 		spi->controller->cleanup(spi);
 
 	spi_controller_put(spi->controller);
+	kfree(spi->driver_override);
 	kfree(spi);
 }
 
@@ -68,6 +69,51 @@ modalias_show(struct device *dev, struct device_attribute *a, char *buf)
 }
 static DEVICE_ATTR_RO(modalias);
 
+static ssize_t driver_override_store(struct device *dev,
+				     struct device_attribute *a,
+				     const char *buf, size_t count)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	const char *end = memchr(buf, '\n', count);
+	const size_t len = end ? end - buf : count;
+	const char *driver_override, *old;
+
+	/* We need to keep extra room for a newline when displaying value */
+	if (len >= (PAGE_SIZE - 1))
+		return -EINVAL;
+
+	driver_override = kstrndup(buf, len, GFP_KERNEL);
+	if (!driver_override)
+		return -ENOMEM;
+
+	device_lock(dev);
+	old = spi->driver_override;
+	if (len) {
+		spi->driver_override = driver_override;
+	} else {
+		/* Emptry string, disable driver override */
+		spi->driver_override = NULL;
+		kfree(driver_override);
+	}
+	device_unlock(dev);
+	kfree(old);
+
+	return count;
+}
+
+static ssize_t driver_override_show(struct device *dev,
+				    struct device_attribute *a, char *buf)
+{
+	const struct spi_device *spi = to_spi_device(dev);
+	ssize_t len;
+
+	device_lock(dev);
+	len = snprintf(buf, PAGE_SIZE, "%s\n", spi->driver_override ? : "");
+	device_unlock(dev);
+	return len;
+}
+static DEVICE_ATTR_RW(driver_override);
+
 #define SPI_STATISTICS_ATTRS(field, file)				\
 static ssize_t spi_controller_##field##_show(struct device *dev,	\
 					     struct device_attribute *attr, \
@@ -149,6 +195,7 @@ SPI_STATISTICS_SHOW(transfers_split_maxsize, "%lu");
 
 static struct attribute *spi_dev_attrs[] = {
 	&dev_attr_modalias.attr,
+	&dev_attr_driver_override.attr,
 	NULL,
 };
 
@@ -296,6 +343,10 @@ static int spi_match_device(struct device *dev, struct device_driver *drv)
 	const struct spi_device	*spi = to_spi_device(dev);
 	const struct spi_driver	*sdrv = to_spi_driver(drv);
 
+	/* Check override first, and if set, only use the named driver */
+	if (spi->driver_override)
+		return strcmp(spi->driver_override, drv->name) == 0;
+
 	/* Attempt an OF style match */
 	if (of_driver_match_device(dev, drv))
 		return 1;

commit 5f143af7501e7c435c56e181a655493edaa92509
Author: Marco Felsch <m.felsch@pengutronix.de>
Date:   Tue Sep 25 11:42:29 2018 +0200

    spi: make OF helper available for others
    
    The of_find_spi_device_by_node() helper function is useful for other
    modules too. Export the funciton as GPL like all other spi helper
    functions and make it available if CONFIG_OF is enabled, because it isn't
    related to the CONFIG_OF_DYNAMIC context. Finally add a stub if
    CONFIG_OF isn't enabled, so others must not care about it.
    
    Signed-off-by: Marco Felsch <m.felsch@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index ec395a6baf9c..f939f585e917 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -3314,20 +3314,23 @@ EXPORT_SYMBOL_GPL(spi_write_then_read);
 
 /*-------------------------------------------------------------------------*/
 
-#if IS_ENABLED(CONFIG_OF_DYNAMIC)
+#if IS_ENABLED(CONFIG_OF)
 static int __spi_of_device_match(struct device *dev, void *data)
 {
 	return dev->of_node == data;
 }
 
 /* must call put_device() when done with returned spi_device device */
-static struct spi_device *of_find_spi_device_by_node(struct device_node *node)
+struct spi_device *of_find_spi_device_by_node(struct device_node *node)
 {
 	struct device *dev = bus_find_device(&spi_bus_type, NULL, node,
 						__spi_of_device_match);
 	return dev ? to_spi_device(dev) : NULL;
 }
+EXPORT_SYMBOL_GPL(of_find_spi_device_by_node);
+#endif /* IS_ENABLED(CONFIG_OF) */
 
+#if IS_ENABLED(CONFIG_OF_DYNAMIC)
 static int __spi_of_controller_match(struct device *dev, const void *data)
 {
 	return dev->of_node == data;

commit b445bfcb9081ae90fec90b828f3aacc565776901
Author: Marco Felsch <m.felsch@pengutronix.de>
Date:   Tue Sep 25 11:42:28 2018 +0200

    spi: switch to SPDX license identifier
    
    Use the appropriate SPDX license identifier and drop the previous
    license text.
    
    Signed-off-by: Marco Felsch <m.felsch@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index a358acdd98d3..2cfc3df821f6 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1,18 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * SPI init/core code
  *
  * Copyright (C) 2005 David Brownell
  * Copyright (C) 2008 Secret Lab Technologies Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include <linux/kernel.h>

commit 71388b21569754ecd36eabd66fd9ca8c6d761fed
Author: David Lechner <david@lechnology.com>
Date:   Tue Sep 18 12:08:48 2018 -0500

    spi: always use software fallback for SPI_CS_WORD when using cs_gio
    
    This modifies the condition for using the software fallback
    implementation for SPI_CS_WORD when the SPI controller is using a GPIO
    for the CS line. When using a GPIO for CS, the hardware implementation
    won't work, so we just enable the software fallback globally in this
    case.
    
    Signed-off-by: David Lechner <david@lechnology.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index be73d236919f..a358acdd98d3 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2832,11 +2832,13 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 		return -EINVAL;
 
 	/* If an SPI controller does not support toggling the CS line on each
-	 * transfer (indicated by the SPI_CS_WORD flag), we can emulate it by
+	 * transfer (indicated by the SPI_CS_WORD flag) or we are using a GPIO
+	 * for the CS line, we can emulate the CS-per-word hardware function by
 	 * splitting transfers into one-word transfers and ensuring that
 	 * cs_change is set for each transfer.
 	 */
-	if ((spi->mode & SPI_CS_WORD) && !(ctlr->mode_bits & SPI_CS_WORD)) {
+	if ((spi->mode & SPI_CS_WORD) && (!(ctlr->mode_bits & SPI_CS_WORD) ||
+					  gpio_is_valid(spi->cs_gpio))) {
 		size_t maxsize;
 		int ret;
 

commit cbaa62e0094a840fecc853910e0c0454529cec03
Author: David Lechner <david@lechnology.com>
Date:   Wed Sep 12 19:39:18 2018 -0500

    spi: add software implementation for SPI_CS_WORD
    
    This adds a default software implementation for the SPI_CS_WORD flag for
    controllers that don't have such a feature.
    
    The SPI_CS_WORD flag indicates that the CS line should be toggled
    between each word sent, not just between each transfer. The
    implementation works by using existing functions to split transfers into
    one-word-sized transfers and sets the cs_change bit for each of the
    new transfers.
    
    Signed-off-by: David Lechner <david@lechnology.com>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index ec395a6baf9c..be73d236919f 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2774,8 +2774,10 @@ int spi_setup(struct spi_device *spi)
 		return -EINVAL;
 	/* help drivers fail *cleanly* when they need options
 	 * that aren't supported with their current controller
+	 * SPI_CS_WORD has a fallback software implementation,
+	 * so it is ignored here.
 	 */
-	bad_bits = spi->mode & ~spi->controller->mode_bits;
+	bad_bits = spi->mode & ~(spi->controller->mode_bits | SPI_CS_WORD);
 	ugly_bits = bad_bits &
 		    (SPI_TX_DUAL | SPI_TX_QUAD | SPI_RX_DUAL | SPI_RX_QUAD);
 	if (ugly_bits) {
@@ -2829,6 +2831,33 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 	if (list_empty(&message->transfers))
 		return -EINVAL;
 
+	/* If an SPI controller does not support toggling the CS line on each
+	 * transfer (indicated by the SPI_CS_WORD flag), we can emulate it by
+	 * splitting transfers into one-word transfers and ensuring that
+	 * cs_change is set for each transfer.
+	 */
+	if ((spi->mode & SPI_CS_WORD) && !(ctlr->mode_bits & SPI_CS_WORD)) {
+		size_t maxsize;
+		int ret;
+
+		maxsize = (spi->bits_per_word + 7) / 8;
+
+		/* spi_split_transfers_maxsize() requires message->spi */
+		message->spi = spi;
+
+		ret = spi_split_transfers_maxsize(ctlr, message, maxsize,
+						  GFP_KERNEL);
+		if (ret)
+			return ret;
+
+		list_for_each_entry(xfer, &message->transfers, transfer_list) {
+			/* don't change cs_change on the last entry in the list */
+			if (list_is_last(&xfer->transfer_list, &message->transfers))
+				break;
+			xfer->cs_change = 1;
+		}
+	}
+
 	/* Half-duplex links include original MicroWire, and ones with
 	 * only one data pin like SPI_3WIRE (switches direction) or where
 	 * either MOSI or MISO is missing.  They can also be caused by

commit 04b2d03a75652bda989de1595048f0501dc0c0a0
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Aug 21 11:53:03 2018 +0200

    spi: Fix double IDR allocation with DT aliases
    
    If the SPI bus number is provided by a DT alias, idr_alloc() is called
    twice, leading to:
    
        WARNING: CPU: 1 PID: 1 at drivers/spi/spi.c:2179 spi_register_controller+0x11c/0x5d8
        couldn't get idr
    
    Fix this by moving the handling of fixed SPI bus numbers up, before the
    DT handling code fills in ctlr->bus_num.
    
    Fixes: 1a4327fbf4554d5b ("spi: fix IDR collision on systems with both fixed and dynamic SPI bus numbers")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Tested-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index a00d006d4c3a..9da0bc5a036c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2143,8 +2143,17 @@ int spi_register_controller(struct spi_controller *ctlr)
 	 */
 	if (ctlr->num_chipselect == 0)
 		return -EINVAL;
-	/* allocate dynamic bus number using Linux idr */
-	if ((ctlr->bus_num < 0) && ctlr->dev.of_node) {
+	if (ctlr->bus_num >= 0) {
+		/* devices with a fixed bus num must check-in with the num */
+		mutex_lock(&board_lock);
+		id = idr_alloc(&spi_master_idr, ctlr, ctlr->bus_num,
+			ctlr->bus_num + 1, GFP_KERNEL);
+		mutex_unlock(&board_lock);
+		if (WARN(id < 0, "couldn't get idr"))
+			return id == -ENOSPC ? -EBUSY : id;
+		ctlr->bus_num = id;
+	} else if (ctlr->dev.of_node) {
+		/* allocate dynamic bus number using Linux idr */
 		id = of_alias_get_id(ctlr->dev.of_node, "spi");
 		if (id >= 0) {
 			ctlr->bus_num = id;
@@ -2170,15 +2179,6 @@ int spi_register_controller(struct spi_controller *ctlr)
 		if (WARN(id < 0, "couldn't get idr"))
 			return id;
 		ctlr->bus_num = id;
-	} else {
-		/* devices with a fixed bus num must check-in with the num */
-		mutex_lock(&board_lock);
-		id = idr_alloc(&spi_master_idr, ctlr, ctlr->bus_num,
-			ctlr->bus_num + 1, GFP_KERNEL);
-		mutex_unlock(&board_lock);
-		if (WARN(id < 0, "couldn't get idr"))
-			return id == -ENOSPC ? -EBUSY : id;
-		ctlr->bus_num = id;
 	}
 	INIT_LIST_HEAD(&ctlr->queue);
 	spin_lock_init(&ctlr->queue_lock);

commit 1a4327fbf4554d5b78d75b19a13d40d6de220159
Author: Kirill Kapranov <kirill.kapranov@compulab.co.il>
Date:   Mon Aug 13 19:48:10 2018 +0300

    spi: fix IDR collision on systems with both fixed and dynamic SPI bus numbers
    
    On systems where some controllers get a dynamic ID assigned and some have
    a fixed number (e.g. from ACPI tables), the current implementation might
    run into an IDR collision: in case of a fixed bus number is gotten by a
    driver (but not marked busy in IDR tree) and a driver with dynamic bus
    number gets the same ID and predictably fails.
    
    Fix this by means of checking-in fixed IDsin IDR as far as dynamic ones
    at the moment of the controller registration.
    
    Fixes: 9b61e302210e (spi: Pick spi bus number from Linux idr or spi alias)
    Signed-off-by: Kirill Kapranov <kirill.kapranov@compulab.co.il>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index ec395a6baf9c..a00d006d4c3a 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2170,6 +2170,15 @@ int spi_register_controller(struct spi_controller *ctlr)
 		if (WARN(id < 0, "couldn't get idr"))
 			return id;
 		ctlr->bus_num = id;
+	} else {
+		/* devices with a fixed bus num must check-in with the num */
+		mutex_lock(&board_lock);
+		id = idr_alloc(&spi_master_idr, ctlr, ctlr->bus_num,
+			ctlr->bus_num + 1, GFP_KERNEL);
+		mutex_unlock(&board_lock);
+		if (WARN(id < 0, "couldn't get idr"))
+			return id == -ENOSPC ? -EBUSY : id;
+		ctlr->bus_num = id;
 	}
 	INIT_LIST_HEAD(&ctlr->queue);
 	spin_lock_init(&ctlr->queue_lock);

commit a86854d0c599b3202307abceb68feee4d7061578
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:07:58 2018 -0700

    treewide: devm_kzalloc() -> devm_kcalloc()
    
    The devm_kzalloc() function has a 2-factor argument form, devm_kcalloc().
    This patch replaces cases of:
    
            devm_kzalloc(handle, a * b, gfp)
    
    with:
            devm_kcalloc(handle, a * b, gfp)
    
    as well as handling cases of:
    
            devm_kzalloc(handle, a * b * c, gfp)
    
    with:
    
            devm_kzalloc(handle, array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            devm_kcalloc(handle, array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            devm_kzalloc(handle, 4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    Some manual whitespace fixes were needed in this patch, as Coccinelle
    really liked to write "=devm_kcalloc..." instead of "= devm_kcalloc...".
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    expression HANDLE;
    type TYPE;
    expression THING, E;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression HANDLE;
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    expression HANDLE;
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    expression HANDLE;
    identifier SIZE, COUNT;
    @@
    
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression HANDLE;
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression HANDLE;
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    expression HANDLE;
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression HANDLE;
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression HANDLE;
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, sizeof(THING) * C2, ...)
    |
      devm_kzalloc(HANDLE, sizeof(TYPE) * C2, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2, ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index efc624f9e490..ec395a6baf9c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2049,7 +2049,7 @@ static int of_spi_register_master(struct spi_controller *ctlr)
 	else if (nb < 0)
 		return nb;
 
-	cs = devm_kzalloc(&ctlr->dev, sizeof(int) * ctlr->num_chipselect,
+	cs = devm_kcalloc(&ctlr->dev, ctlr->num_chipselect, sizeof(int),
 			  GFP_KERNEL);
 	ctlr->cs_gpios = cs;
 

commit 3c89adb0d11117f64d5b501730be7fb2bf53a479
Merge: 11e7c2188061 a24e16b1310c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 5 09:38:39 2018 -0700

    Merge tag 'pm-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael Wysocki:
     "These include a significant update of the generic power domains
      (genpd) and Operating Performance Points (OPP) frameworks, mostly
      related to the introduction of power domain performance levels,
      cpufreq updates (new driver for Qualcomm Kryo processors, updates of
      the existing drivers, some core fixes, schedutil governor
      improvements), PCI power management fixes, ACPI workaround for
      EC-based wakeup events handling on resume from suspend-to-idle, and
      major updates of the turbostat and pm-graph utilities.
    
      Specifics:
    
       - Introduce power domain performance levels into the the generic
         power domains (genpd) and Operating Performance Points (OPP)
         frameworks (Viresh Kumar, Rajendra Nayak, Dan Carpenter).
    
       - Fix two issues in the runtime PM framework related to the
         initialization and removal of devices using device links (Ulf
         Hansson).
    
       - Clean up the initialization of drivers for devices in PM domains
         (Ulf Hansson, Geert Uytterhoeven).
    
       - Fix a cpufreq core issue related to the policy sysfs interface
         causing CPU online to fail for CPUs sharing one cpufreq policy in
         some situations (Tao Wang).
    
       - Make it possible to use platform-specific suspend/resume hooks in
         the cpufreq-dt driver and make the Armada 37xx DVFS use that
         feature (Viresh Kumar, Miquel Raynal).
    
       - Optimize policy transition notifications in cpufreq (Viresh Kumar).
    
       - Improve the iowait boost mechanism in the schedutil cpufreq
         governor (Patrick Bellasi).
    
       - Improve the handling of deferred frequency updates in the schedutil
         cpufreq governor (Joel Fernandes, Dietmar Eggemann, Rafael Wysocki,
         Viresh Kumar).
    
       - Add a new cpufreq driver for Qualcomm Kryo (Ilia Lin).
    
       - Fix and clean up some cpufreq drivers (Colin Ian King, Dmitry
         Osipenko, Doug Smythies, Luc Van Oostenryck, Simon Horman, Viresh
         Kumar).
    
       - Fix the handling of PCI devices with the DPM_SMART_SUSPEND flag set
         and update stale comments in the PCI core PM code (Rafael Wysocki).
    
       - Work around an issue related to the handling of EC-based wakeup
         events in the ACPI PM core during resume from suspend-to-idle if
         the EC has been put into the low-power mode (Rafael Wysocki).
    
       - Improve the handling of wakeup source objects in the PM core (Doug
         Berger, Mahendran Ganesh, Rafael Wysocki).
    
       - Update the driver core to prevent deferred probe from breaking
         suspend/resume ordering (Feng Kan).
    
       - Clean up the PM core somewhat (Bjorn Helgaas, Ulf Hansson, Rafael
         Wysocki).
    
       - Make the core suspend/resume code and cpufreq support the RT patch
         (Sebastian Andrzej Siewior, Thomas Gleixner).
    
       - Consolidate the PM QoS handling in cpuidle governors (Rafael
         Wysocki).
    
       - Fix a possible crash in the hibernation core (Tetsuo Handa).
    
       - Update the rockchip-io Adaptive Voltage Scaling (AVS) driver (David
         Wu).
    
       - Update the turbostat utility (fixes, cleanups, new CPU IDs, new
         command line options, built-in "Low Power Idle" counters support,
         new POLL and POLL% columns) and add an entry for it to MAINTAINERS
         (Len Brown, Artem Bityutskiy, Chen Yu, Laura Abbott, Matt Turner,
         Prarit Bhargava, Srinivas Pandruvada).
    
       - Update the pm-graph to version 5.1 (Todd Brandt).
    
       - Update the intel_pstate_tracer utility (Doug Smythies)"
    
    * tag 'pm-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (128 commits)
      tools/power turbostat: update version number
      tools/power turbostat: Add Node in output
      tools/power turbostat: add node information into turbostat calculations
      tools/power turbostat: remove num_ from cpu_topology struct
      tools/power turbostat: rename num_cores_per_pkg to num_cores_per_node
      tools/power turbostat: track thread ID in cpu_topology
      tools/power turbostat: Calculate additional node information for a package
      tools/power turbostat: Fix node and siblings lookup data
      tools/power turbostat: set max_num_cpus equal to the cpumask length
      tools/power turbostat: if --num_iterations, print for specific number of iterations
      tools/power turbostat: Add Cannon Lake support
      tools/power turbostat: delete duplicate #defines
      x86: msr-index.h: Correct SNB_C1/C3_AUTO_UNDEMOTE defines
      tools/power turbostat: Correct SNB_C1/C3_AUTO_UNDEMOTE defines
      tools/power turbostat: add POLL and POLL% column
      tools/power turbostat: Fix --hide Pk%pc10
      tools/power turbostat: Build-in "Low Power Idle" counters support
      tools/power turbostat: Don't make man pages executable
      tools/power turbostat: remove blank lines
      tools/power turbostat: a small C-states dump readability immprovement
      ...

commit 7e48e23a1f4a50f93ac1073f1326e0a73829b631
Author: Tony Lindgren <tony@atomide.com>
Date:   Fri May 18 10:30:07 2018 -0700

    spi: Add missing pm_runtime_put_noidle() after failed get
    
    If pm_runtime_get_sync() fails we should call pm_runtime_put_noidle().
    This is probably not a critical fix as we should only hit this when
    things are broken elsewhere.
    
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 8ee1ba13eb23..20b5b2754830 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1212,6 +1212,7 @@ static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 	if (!was_busy && ctlr->auto_runtime_pm) {
 		ret = pm_runtime_get_sync(ctlr->dev.parent);
 		if (ret < 0) {
+			pm_runtime_put_noidle(ctlr->dev.parent);
 			dev_err(&ctlr->dev, "Failed to power device: %d\n",
 				ret);
 			mutex_unlock(&ctlr->io_mutex);

commit 71f277a7bf0b0e65e9571940057c70efc4326bc5
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 26 10:53:10 2018 +0200

    spi: Respect all error codes from dev_pm_domain_attach()
    
    The limitation of being able to check only for -EPROBE_DEFER from
    dev_pm_domain_attach() has been removed. Hence let's respect all error
    codes and bail out accordingly.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 7b213faa0a2b..eeab67f50580 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -356,11 +356,12 @@ static int spi_drv_probe(struct device *dev)
 	}
 
 	ret = dev_pm_domain_attach(dev, true);
-	if (ret != -EPROBE_DEFER) {
-		ret = sdrv->probe(spi);
-		if (ret)
-			dev_pm_domain_detach(dev, true);
-	}
+	if (ret)
+		return ret;
+
+	ret = sdrv->probe(spi);
+	if (ret)
+		dev_pm_domain_detach(dev, true);
 
 	return ret;
 }

commit c1f5ba70decfc2f35edcc10505e3e78fb528d212
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Thu Apr 26 18:18:20 2018 +0200

    spi: Get rid of the spi_flash_read() API
    
    This API has been replaced by the spi_mem_xx() one, its only user
    (spi-nor) has been converted to spi_mem_xx() and all SPI controller
    drivers that were implementing the ->spi_flash_xxx() hooks are also
    implementing the spi_mem ones. So we can safely get rid of this API.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Frieder Schrempf <frieder.schrempf@exceet.de>
    Tested-by: Frieder Schrempf <frieder.schrempf@exceet.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index c85b0cf7b4a9..8ee1ba13eb23 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -3055,63 +3055,6 @@ int spi_async_locked(struct spi_device *spi, struct spi_message *message)
 }
 EXPORT_SYMBOL_GPL(spi_async_locked);
 
-
-int spi_flash_read(struct spi_device *spi,
-		   struct spi_flash_read_message *msg)
-
-{
-	struct spi_controller *master = spi->controller;
-	struct device *rx_dev = NULL;
-	int ret;
-
-	if ((msg->opcode_nbits == SPI_NBITS_DUAL ||
-	     msg->addr_nbits == SPI_NBITS_DUAL) &&
-	    !(spi->mode & (SPI_TX_DUAL | SPI_TX_QUAD)))
-		return -EINVAL;
-	if ((msg->opcode_nbits == SPI_NBITS_QUAD ||
-	     msg->addr_nbits == SPI_NBITS_QUAD) &&
-	    !(spi->mode & SPI_TX_QUAD))
-		return -EINVAL;
-	if (msg->data_nbits == SPI_NBITS_DUAL &&
-	    !(spi->mode & (SPI_RX_DUAL | SPI_RX_QUAD)))
-		return -EINVAL;
-	if (msg->data_nbits == SPI_NBITS_QUAD &&
-	    !(spi->mode &  SPI_RX_QUAD))
-		return -EINVAL;
-
-	if (master->auto_runtime_pm) {
-		ret = pm_runtime_get_sync(master->dev.parent);
-		if (ret < 0) {
-			dev_err(&master->dev, "Failed to power device: %d\n",
-				ret);
-			return ret;
-		}
-	}
-
-	mutex_lock(&master->bus_lock_mutex);
-	mutex_lock(&master->io_mutex);
-	if (master->dma_rx && master->spi_flash_can_dma(spi, msg)) {
-		rx_dev = master->dma_rx->device->dev;
-		ret = spi_map_buf(master, rx_dev, &msg->rx_sg,
-				  msg->buf, msg->len,
-				  DMA_FROM_DEVICE);
-		if (!ret)
-			msg->cur_msg_mapped = true;
-	}
-	ret = master->spi_flash_read(spi, msg);
-	if (msg->cur_msg_mapped)
-		spi_unmap_buf(master, rx_dev, &msg->rx_sg,
-			      DMA_FROM_DEVICE);
-	mutex_unlock(&master->io_mutex);
-	mutex_unlock(&master->bus_lock_mutex);
-
-	if (master->auto_runtime_pm)
-		pm_runtime_put(master->dev.parent);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(spi_flash_read);
-
 /*-------------------------------------------------------------------------*/
 
 /* Utility methods for SPI protocol drivers, layered on

commit b5932f5c68e5fbe74fb7a27b4d0faf919e1e1642
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Thu Apr 26 18:18:15 2018 +0200

    spi: Make support for regular transfers optional when ->mem_ops != NULL
    
    Some SPI/QuadSPI controllers only expose a high-level SPI memory
    interface, thus preventing any regular SPI transfers from being done.
    
    In that case, SPI controller drivers can leave all ->transfer_xxx()
    hooks empty and only implement the spi_mem_ops interface.
    
    Adjust the core to allow such situations:
    - extend spi_controller_check_ops() to accept situations where all
      ->transfer_xxx() pointers are NULL only if ->mem_ops != NULL
    - make sure we do not initialize the SPI message queue if
      ctlr->transfer_one and ctlr->transfer_one_message are missing
    - return -ENOTSUPP if someone tries to do a regular SPI transfer on
      a controller that does not support it
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Frieder Schrempf <frieder.schrempf@exceet.de>
    Tested-by: Frieder Schrempf <frieder.schrempf@exceet.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 9ab65fb2738e..c85b0cf7b4a9 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -28,6 +28,7 @@
 #include <linux/slab.h>
 #include <linux/mod_devicetable.h>
 #include <linux/spi/spi.h>
+#include <linux/spi/spi-mem.h>
 #include <linux/of_gpio.h>
 #include <linux/pm_runtime.h>
 #include <linux/pm_domain.h>
@@ -2071,12 +2072,19 @@ static int of_spi_register_master(struct spi_controller *ctlr)
 static int spi_controller_check_ops(struct spi_controller *ctlr)
 {
 	/*
-	 * The controller must at least implement one of the ->transfer()
-	 * hooks.
+	 * The controller may implement only the high-level SPI-memory like
+	 * operations if it does not support regular SPI transfers, and this is
+	 * valid use case.
+	 * If ->mem_ops is NULL, we request that at least one of the
+	 * ->transfer_xxx() method be implemented.
 	 */
-	if (!ctlr->transfer && !ctlr->transfer_one &&
-	    !ctlr->transfer_one_message)
+	if (ctlr->mem_ops) {
+		if (!ctlr->mem_ops->exec_op)
+			return -EINVAL;
+	} else if (!ctlr->transfer && !ctlr->transfer_one &&
+		   !ctlr->transfer_one_message) {
 		return -EINVAL;
+	}
 
 	return 0;
 }
@@ -2187,10 +2195,14 @@ int spi_register_controller(struct spi_controller *ctlr)
 			spi_controller_is_slave(ctlr) ? "slave" : "master",
 			dev_name(&ctlr->dev));
 
-	/* If we're using a queued driver, start the queue */
-	if (ctlr->transfer)
+	/*
+	 * If we're using a queued driver, start the queue. Note that we don't
+	 * need the queueing logic if the driver is only supporting high-level
+	 * memory operations.
+	 */
+	if (ctlr->transfer) {
 		dev_info(dev, "controller is unqueued, this is deprecated\n");
-	else {
+	} else if (ctlr->transfer_one || ctlr->transfer_one_message) {
 		status = spi_controller_initialize_queue(ctlr);
 		if (status) {
 			device_del(&ctlr->dev);
@@ -2920,6 +2932,13 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
 {
 	struct spi_controller *ctlr = spi->controller;
 
+	/*
+	 * Some controllers do not support doing regular SPI transfers. Return
+	 * ENOTSUPP when this is the case.
+	 */
+	if (!ctlr->transfer)
+		return -ENOTSUPP;
+
 	message->spi = spi;
 
 	SPI_STATISTICS_INCREMENT_FIELD(&ctlr->statistics, spi_async);

commit bdf3a3b59a7ab1972e7d2242c9466ba7e79f0004
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Wed Apr 11 00:44:30 2018 +0200

    spi: Check presence the of ->transfer[_xxx]() before registering a controller
    
    Right now, no checks are done on the presence of a ->transfer[_xxx]()
    method, which can lead to a NULL pointer dereference when someone
    starts sending something on the bus.
    
    Do the check at registration time and refuse to add the controller if
    all ->transfer[_xxx]() pointers are NULL.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 3f4666365678..9ab65fb2738e 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2068,6 +2068,19 @@ static int of_spi_register_master(struct spi_controller *ctlr)
 }
 #endif
 
+static int spi_controller_check_ops(struct spi_controller *ctlr)
+{
+	/*
+	 * The controller must at least implement one of the ->transfer()
+	 * hooks.
+	 */
+	if (!ctlr->transfer && !ctlr->transfer_one &&
+	    !ctlr->transfer_one_message)
+		return -EINVAL;
+
+	return 0;
+}
+
 /**
  * spi_register_controller - register SPI master or slave controller
  * @ctlr: initialized master, originally from spi_alloc_master() or
@@ -2101,6 +2114,14 @@ int spi_register_controller(struct spi_controller *ctlr)
 	if (!dev)
 		return -ENODEV;
 
+	/*
+	 * Make sure all necessary hooks are implemented before registering
+	 * the SPI controller.
+	 */
+	status = spi_controller_check_ops(ctlr);
+	if (status)
+		return status;
+
 	if (!spi_controller_is_slave(ctlr)) {
 		status = of_spi_register_master(ctlr);
 		if (status)

commit 988f259b46646934003ff8ae4966f7233691d1ad
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Sun Apr 22 20:35:15 2018 +0200

    spi: Add an helper to flush the message queue
    
    This is needed by the spi-mem logic to force all messages that have been
    queued before a memory operation to be sent before we start the memory
    operation. We do that in order to guarantee that spi-mem operations do
    not preempt regular SPI transfers.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 86b778d8563e..3f4666365678 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1522,6 +1522,22 @@ static int spi_controller_initialize_queue(struct spi_controller *ctlr)
 	return ret;
 }
 
+/**
+ * spi_flush_queue - Send all pending messages in the queue from the callers'
+ *		     context
+ * @ctlr: controller to process queue for
+ *
+ * This should be used when one wants to ensure all pending messages have been
+ * sent before doing something. Is used by the spi-mem code to make sure SPI
+ * memory operations do not preempt regular SPI transfers that have been queued
+ * before the spi-mem operation.
+ */
+void spi_flush_queue(struct spi_controller *ctlr)
+{
+	if (ctlr->transfer == spi_queued_transfer)
+		__spi_pump_messages(ctlr, false);
+}
+
 /*-------------------------------------------------------------------------*/
 
 #if defined(CONFIG_OF)

commit 46336966bf0852d76f76c1292c057635b05dbb1b
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Sun Apr 22 20:35:14 2018 +0200

    spi: Expose spi_{map,unmap}_buf() for internal use
    
    spi_{map,unmap}_buf() are needed by the spi-mem logic that is about to
    be introduced to prepare data buffer for DMA operations.
    
    Remove the static specifier on these functions and add their prototypes
    to drivers/spi/internals.h. We do not export the symbols here because
    both SPI_MEM and SPI can't be enabled as modules and we'd like to
    prevent controller/device drivers from using these functions.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 7b213faa0a2b..86b778d8563e 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -46,6 +46,8 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/spi.h>
 
+#include "internals.h"
+
 static DEFINE_IDR(spi_master_idr);
 
 static void spidev_release(struct device *dev)
@@ -740,9 +742,9 @@ static void spi_set_cs(struct spi_device *spi, bool enable)
 }
 
 #ifdef CONFIG_HAS_DMA
-static int spi_map_buf(struct spi_controller *ctlr, struct device *dev,
-		       struct sg_table *sgt, void *buf, size_t len,
-		       enum dma_data_direction dir)
+int spi_map_buf(struct spi_controller *ctlr, struct device *dev,
+		struct sg_table *sgt, void *buf, size_t len,
+		enum dma_data_direction dir)
 {
 	const bool vmalloced_buf = is_vmalloc_addr(buf);
 	unsigned int max_seg_size = dma_get_max_seg_size(dev);
@@ -821,8 +823,8 @@ static int spi_map_buf(struct spi_controller *ctlr, struct device *dev,
 	return 0;
 }
 
-static void spi_unmap_buf(struct spi_controller *ctlr, struct device *dev,
-			  struct sg_table *sgt, enum dma_data_direction dir)
+void spi_unmap_buf(struct spi_controller *ctlr, struct device *dev,
+		   struct sg_table *sgt, enum dma_data_direction dir)
 {
 	if (sgt->orig_nents) {
 		dma_unmap_sg(dev, sgt->sgl, sgt->orig_nents, dir);
@@ -907,19 +909,6 @@ static int __spi_unmap_msg(struct spi_controller *ctlr, struct spi_message *msg)
 	return 0;
 }
 #else /* !CONFIG_HAS_DMA */
-static inline int spi_map_buf(struct spi_controller *ctlr, struct device *dev,
-			      struct sg_table *sgt, void *buf, size_t len,
-			      enum dma_data_direction dir)
-{
-	return -EINVAL;
-}
-
-static inline void spi_unmap_buf(struct spi_controller *ctlr,
-				 struct device *dev, struct sg_table *sgt,
-				 enum dma_data_direction dir)
-{
-}
-
 static inline int __spi_map_msg(struct spi_controller *ctlr,
 				struct spi_message *msg)
 {

commit 3ce2dcf70280980adf3f7a9dde4c1a96a20f2d0d
Merge: 43ff2dcef0fd 9581329eff9d e2b714afee32 613bd1ea387b
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Apr 2 15:56:24 2018 +0100

    Merge remote-tracking branches 'spi/fix/atmel', 'spi/fix/pxa2xx' and 'spi/fix/unregiser' into spi-linus

commit 613bd1ea387bb48b7c9a71a0bb451ac15cfbbc01
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Tue Mar 20 10:27:50 2018 +0200

    spi: Fix unregistration of controller with fixed SPI bus number
    
    Commit 9b61e302210e (spi: Pick spi bus number from Linux idr or spi alias)
    ceased to unregister SPI buses with fixed bus numbers. Moreover this is
    visible only if CONFIG_SPI_DEBUG=y is set or when trying to re-register
    the same SPI controller.
    
    rmmod spi_pxa2xx_platform (with CONFIG_SPI_DEBUG=y):
    [   26.788362] spi_master spi1: attempting to delete unregistered controller [spi1]
    
    modprobe spi_pxa2xx_platform:
    [   37.883137] sysfs: cannot create duplicate filename '/devices/pci0000:00/0000:00:19.0/pxa2xx-spi.12/spi_master/spi1'
    [   37.894984] CPU: 1 PID: 1467 Comm: modprobe Not tainted 4.16.0-rc4+ #21
    [   37.902384] Call Trace:
    ...
    [   38.122680] kobject_add_internal failed for spi1 with -EEXIST, don't try to register things with the same name in the same directory.
    [   38.136154] WARNING: CPU: 1 PID: 1467 at lib/kobject.c:238 kobject_add_internal+0x2a5/0x2f0
    ...
    [   38.513817] pxa2xx-spi pxa2xx-spi.12: problem registering spi master
    [   38.521036] pxa2xx-spi: probe of pxa2xx-spi.12 failed with error -17
    
    Fix this by not returning immediately from spi_unregister_controller() if
    idr_find() doesn't find controller with given ID/bus number. It finds
    only those controllers that were registered with dynamic SPI bus
    numbers. Only conditional cleanup between dynamic and fixed bus numbers
    is to remove allocated IDR.
    
    Fixes: 9b61e302210e (spi: Pick spi bus number from Linux idr or spi alias)
    Cc: stable@vger.kernel.org
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b33a727a0158..e90fd442b3f0 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2254,12 +2254,6 @@ void spi_unregister_controller(struct spi_controller *ctlr)
 	mutex_lock(&board_lock);
 	found = idr_find(&spi_master_idr, id);
 	mutex_unlock(&board_lock);
-	if (found != ctlr) {
-		dev_dbg(&ctlr->dev,
-			"attempting to delete unregistered controller [%s]\n",
-			dev_name(&ctlr->dev));
-		return;
-	}
 	if (ctlr->queued) {
 		if (spi_destroy_queue(ctlr))
 			dev_err(&ctlr->dev, "queue remove failed\n");
@@ -2272,7 +2266,8 @@ void spi_unregister_controller(struct spi_controller *ctlr)
 	device_unregister(&ctlr->dev);
 	/* free bus id */
 	mutex_lock(&board_lock);
-	idr_remove(&spi_master_idr, id);
+	if (found == ctlr)
+		idr_remove(&spi_master_idr, id);
 	mutex_unlock(&board_lock);
 }
 EXPORT_SYMBOL_GPL(spi_unregister_controller);

commit ce99319a182fe766be67f96338386f3ec73e321c
Author: Maxime Chevallier <maxime.chevallier@bootlin.com>
Date:   Fri Mar 2 15:55:09 2018 +0100

    spi: Fix scatterlist elements size in spi_map_buf
    
    When SPI transfers can be offloaded using DMA, the SPI core need to
    build a scatterlist to make sure that the buffer to be transferred is
    dma-able.
    
    This patch fixes the scatterlist entry size computation in the case
    where the maximum acceptable scatterlist entry supported by the DMA
    controller is less than PAGE_SIZE, when the buffer is vmalloced.
    
    For each entry, the actual size is given by the minimum between the
    desc_len (which is the max buffer size supported by the DMA controller)
    and the remaining buffer length until we cross a page boundary.
    
    Fixes: 65598c13fd66 ("spi: Fix per-page mapping of unaligned vmalloc-ed buffer")
    Signed-off-by: Maxime Chevallier <maxime.chevallier@bootlin.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b33a727a0158..4153f959f28c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -779,8 +779,14 @@ static int spi_map_buf(struct spi_controller *ctlr, struct device *dev,
 	for (i = 0; i < sgs; i++) {
 
 		if (vmalloced_buf || kmap_buf) {
-			min = min_t(size_t,
-				    len, desc_len - offset_in_page(buf));
+			/*
+			 * Next scatterlist entry size is the minimum between
+			 * the desc_len and the remaining buffer length that
+			 * fits in a page.
+			 */
+			min = min_t(size_t, desc_len,
+				    min_t(size_t, len,
+					  PAGE_SIZE - offset_in_page(buf)));
 			if (vmalloced_buf)
 				vm_page = vmalloc_to_page(buf);
 			else

commit b5f9208dea865ffdd075c55c6e44fcf5e45134b3
Merge: 130555cf3b13 68b892f1fdc4
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Nov 10 21:33:43 2017 +0000

    Merge remote-tracking branch 'spi/topic/core' into spi-next

commit 42bdd7061a6e24d7b21d3d21973615fecef544ef
Author: Lucas Stach <l.stach@pengutronix.de>
Date:   Mon Oct 16 12:27:58 2017 +0200

    spi: fix IDR collision on systems with both fixed and dynamic SPI bus numbers
    
    On systems where some controllers get a dynamic ID assigned and some have
    a fixed number from DT, the current implemention might run into an IDR
    collision if the dynamic controllers gets probed first and get an IDR number,
    which is later requested by the controller with the fixed numbering. When
    this happens the fixed controller will fail to register with the SPI core.
    
    Fix this by skipping all known alias numbers when assigning the dynamic IDs.
    
    Fixes: 9b61e302210e (spi: Pick spi bus number from Linux idr or spi alias)
    Signed-off-by: Lucas Stach <l.stach@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 759c9725495a..3ff0ee88c467 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -45,7 +45,6 @@
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/spi.h>
-#define SPI_DYN_FIRST_BUS_NUM 0
 
 static DEFINE_IDR(spi_master_idr);
 
@@ -2086,7 +2085,7 @@ int spi_register_controller(struct spi_controller *ctlr)
 	struct device		*dev = ctlr->dev.parent;
 	struct boardinfo	*bi;
 	int			status = -ENODEV;
-	int			id;
+	int			id, first_dynamic;
 
 	if (!dev)
 		return -ENODEV;
@@ -2116,9 +2115,15 @@ int spi_register_controller(struct spi_controller *ctlr)
 		}
 	}
 	if (ctlr->bus_num < 0) {
+		first_dynamic = of_alias_get_highest_id("spi");
+		if (first_dynamic < 0)
+			first_dynamic = 0;
+		else
+			first_dynamic++;
+
 		mutex_lock(&board_lock);
-		id = idr_alloc(&spi_master_idr, ctlr, SPI_DYN_FIRST_BUS_NUM, 0,
-			       GFP_KERNEL);
+		id = idr_alloc(&spi_master_idr, ctlr, first_dynamic,
+			       0, GFP_KERNEL);
 		mutex_unlock(&board_lock);
 		if (WARN(id < 0, "couldn't get idr"))
 			return id;

commit 68b892f1fdc493d7cd4e4067596879cd097c1f62
Author: Johan Hovold <johan@kernel.org>
Date:   Mon Oct 30 11:35:26 2017 +0100

    spi: document odd controller reference handling
    
    Document the fact that a reference to the controller is dropped as part
    of deregistration.
    
    This is an odd pattern as the reference is typically taken in
    __spi_alloc_controller() rather than spi_register_controller(). Most
    controller drivers gets it right these days and notably the
    device-managed interface relies on this behaviour.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 6e65524cbfd9..5673cca1d1d0 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2195,7 +2195,7 @@ static void devm_spi_unregister(struct device *dev, void *res)
  * Context: can sleep
  *
  * Register a SPI device as with spi_register_controller() which will
- * automatically be unregister
+ * automatically be unregistered and freed.
  *
  * Return: zero on success, else a negative error code.
  */
@@ -2236,6 +2236,8 @@ static int __unregister(struct device *dev, void *null)
  * only ones directly touching chip registers.
  *
  * This must be called from context that can sleep.
+ *
+ * Note that this function also drops a reference to the controller.
  */
 void spi_unregister_controller(struct spi_controller *ctlr)
 {

commit 67f7b2781fafcc0f52464880154b320fea1ae982
Author: Johan Hovold <johan@kernel.org>
Date:   Mon Oct 30 11:35:25 2017 +0100

    spi: fix use-after-free at controller deregistration
    
    The controller is typically freed as part of device_unregister() so
    store the bus id before deregistration to avoid use-after-free when the
    id is later released.
    
    Fixes: 9b61e302210e ("spi: Pick spi bus number from Linux idr or spi alias")
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable <stable@vger.kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 6e65524cbfd9..759c9725495a 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2240,11 +2240,12 @@ static int __unregister(struct device *dev, void *null)
 void spi_unregister_controller(struct spi_controller *ctlr)
 {
 	struct spi_controller *found;
+	int id = ctlr->bus_num;
 	int dummy;
 
 	/* First make sure that this controller was ever added */
 	mutex_lock(&board_lock);
-	found = idr_find(&spi_master_idr, ctlr->bus_num);
+	found = idr_find(&spi_master_idr, id);
 	mutex_unlock(&board_lock);
 	if (found != ctlr) {
 		dev_dbg(&ctlr->dev,
@@ -2264,7 +2265,7 @@ void spi_unregister_controller(struct spi_controller *ctlr)
 	device_unregister(&ctlr->dev);
 	/* free bus id */
 	mutex_lock(&board_lock);
-	idr_remove(&spi_master_idr, ctlr->bus_num);
+	idr_remove(&spi_master_idr, id);
 	mutex_unlock(&board_lock);
 }
 EXPORT_SYMBOL_GPL(spi_unregister_controller);

commit 53ac64aac9af8cd0e5456c8a9bb68c47b571b0a9
Merge: 439644096c1a 298bd7fb26cb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 5 12:45:03 2017 -0700

    Merge tag 'acpi-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI updates from Rafael Wysocki:
     "These include a usual ACPICA code update (this time to upstream
      revision 20170728), a fix for a boot crash on some systems with
      Thunderbolt devices connected at boot time, a rework of the handling
      of PCI bridges when setting up device wakeup, new support for Apple
      device properties, support for DMA configurations reported via ACPI on
      ARM64, APEI-related updates, ACPI EC driver updates and assorted minor
      modifications in several places.
    
      Specifics:
    
       - Update the ACPICA code in the kernel to upstream revision 20170728
         including:
          * Alias operator handling update (Bob Moore).
          * Deferred resolution of reference package elements (Bob Moore).
          * Support for the _DMA method in walk resources (Bob Moore).
          * Tables handling update and support for deferred table
            verification (Lv Zheng).
          * Update of SMMU models for IORT (Robin Murphy).
          * Compiler and disassembler updates (Alex James, Erik Schmauss,
            Ganapatrao Kulkarni, James Morse).
          * Tools updates (Erik Schmauss, Lv Zheng).
          * Assorted minor fixes and cleanups (Bob Moore, Kees Cook, Lv
            Zheng, Shao Ming).
    
       - Rework the initialization of non-wakeup GPEs with method handlers
         in order to address a boot crash on some systems with Thunderbolt
         devices connected at boot time where we miss an early hotplug event
         due to a delay in GPE enabling (Rafael Wysocki).
    
       - Rework the handling of PCI bridges when setting up ACPI-based
         device wakeup in order to avoid disabling wakeup for bridges
         prematurely (Rafael Wysocki).
    
       - Consolidate Apple DMI checks throughout the tree, add support for
         Apple device properties to the device properties framework and use
         these properties for the handling of I2C and SPI devices on Apple
         systems (Lukas Wunner).
    
       - Add support for _DMA to the ACPI-based device properties lookup
         code and make it possible to use the information from there to
         configure DMA regions on ARM64 systems (Lorenzo Pieralisi).
    
       - Fix several issues in the APEI code, add support for exporting the
         BERT error region over sysfs and update APEI MAINTAINERS entry with
         reviewers information (Borislav Petkov, Dongjiu Geng, Loc Ho, Punit
         Agrawal, Tony Luck, Yazen Ghannam).
    
       - Fix a potential initialization ordering issue in the ACPI EC driver
         and clean it up somewhat (Lv Zheng).
    
       - Update the ACPI SPCR driver to extend the existing XGENE 8250
         workaround in it to a new platform (m400) and to work around an
         Xgene UART clock issue (Graeme Gregory).
    
       - Add a new utility function to the ACPI core to support using ACPI
         OEM ID / OEM Table ID / Revision for system identification in
         blacklisting or similar and switch over the existing code already
         using this information to this new interface (Toshi Kani).
    
       - Fix an xpower PMIC issue related to GPADC reads that always return
         0 without extra pin manipulations (Hans de Goede).
    
       - Add statements to print debug messages in a couple of places in the
         ACPI core for easier diagnostics (Rafael Wysocki).
    
       - Clean up the ACPI processor driver slightly (Colin Ian King, Hanjun
         Guo).
    
       - Clean up the ACPI x86 boot code somewhat (Andy Shevchenko).
    
       - Add a quirk for Dell OptiPlex 9020M to the ACPI backlight driver
         (Alex Hung).
    
       - Assorted fixes, cleanups and updates related to ACPI (Amitoj Kaur
         Chawla, Bhumika Goyal, Frank Rowand, Jean Delvare, Punit Agrawal,
         Ronald TschalÃ¤r, Sumeet Pawnikar)"
    
    * tag 'acpi-4.14-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (75 commits)
      ACPI / APEI: Suppress message if HEST not present
      intel_pstate: convert to use acpi_match_platform_list()
      ACPI / blacklist: add acpi_match_platform_list()
      ACPI, APEI, EINJ: Subtract any matching Register Region from Trigger resources
      ACPI: make device_attribute const
      ACPI / sysfs: Extend ACPI sysfs to provide access to boot error region
      ACPI: APEI: fix the wrong iteration of generic error status block
      ACPI / processor: make function acpi_processor_check_duplicates() static
      ACPI / EC: Clean up EC GPE mask flag
      ACPI: EC: Fix possible issues related to EC initialization order
      ACPI / PM: Add debug statements to acpi_pm_notify_handler()
      ACPI: Add debug statements to acpi_global_event_handler()
      ACPI / scan: Enable GPEs before scanning the namespace
      ACPICA: Make it possible to enable runtime GPEs earlier
      ACPICA: Dispatch active GPEs at init time
      ACPI: SPCR: work around clock issue on xgene UART
      ACPI: SPCR: extend XGENE 8250 workaround to m400
      ACPI / LPSS: Don't abort ACPI scan on missing mem resource
      mailbox: pcc: Drop uninformative output during boot
      ACPI/IORT: Add IORT named component memory address limits
      ...

commit a3a424602aab9a2d3527463f94b2472235d62ff1
Merge: 45cfc32ba4f2 802740890c42 25c56c88a462 d9a017713d90 1a41aa1376df
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Sep 4 15:51:18 2017 +0100

    Merge remote-tracking branches 'spi/topic/cadence', 'spi/topic/dt', 'spi/topic/ep93xx' and 'spi/topic/falcon' into spi-next

commit 9a9a047a39d9173b0639017e5ba249443e76dd9e
Author: Suniel Mahesh <sunil.m@techveda.org>
Date:   Thu Aug 17 18:18:22 2017 +0530

    spi: Kernel coding style fixes
    
    Earlier commit:
    "spi: Pick spi bus number from Linux idr or spi alias"
    (SHA1:9b61e302210eba55768962f2f11e96bb508c2408)
    has introduced some checkpatch issues. As pointed by
    Lukas Wunner this patch does the following:
    - remove whitespaces
    - fix warnings, suspect code indent for conditional statements
    - fix errors, code indent should use tabs
    - remove spaces at the start of the line
    
    Signed-off-by: Suniel Mahesh <sunil.m@techveda.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b851888a0a0b..f47d1ccdf292 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -424,7 +424,7 @@ static LIST_HEAD(spi_controller_list);
 /*
  * Used to protect add/del opertion for board_info list and
  * spi_controller list, and their matching process
- * also used to protect object of type struct idr 
+ * also used to protect object of type struct idr
  */
 static DEFINE_MUTEX(board_lock);
 
@@ -2075,7 +2075,6 @@ int spi_register_controller(struct spi_controller *ctlr)
 	 */
 	if (ctlr->num_chipselect == 0)
 		return -EINVAL;
-	
 	/* allocate dynamic bus number using Linux idr */
 	if ((ctlr->bus_num < 0) && ctlr->dev.of_node) {
 		id = of_alias_get_id(ctlr->dev.of_node, "spi");
@@ -2090,16 +2089,14 @@ int spi_register_controller(struct spi_controller *ctlr)
 		}
 	}
 	if (ctlr->bus_num < 0) {
-			mutex_lock(&board_lock);
-			id = idr_alloc(&spi_master_idr, ctlr,
-				       SPI_DYN_FIRST_BUS_NUM, 0, GFP_KERNEL);
-			mutex_unlock(&board_lock);
-			if (WARN(id < 0, "couldn't get idr"))
-				return id;
-
-			ctlr->bus_num = id;
+		mutex_lock(&board_lock);
+		id = idr_alloc(&spi_master_idr, ctlr, SPI_DYN_FIRST_BUS_NUM, 0,
+			       GFP_KERNEL);
+		mutex_unlock(&board_lock);
+		if (WARN(id < 0, "couldn't get idr"))
+			return id;
+		ctlr->bus_num = id;
 	}
-
 	INIT_LIST_HEAD(&ctlr->queue);
 	spin_lock_init(&ctlr->queue_lock);
 	spin_lock_init(&ctlr->bus_lock_spinlock);
@@ -2222,18 +2219,16 @@ void spi_unregister_controller(struct spi_controller *ctlr)
 	mutex_lock(&board_lock);
 	found = idr_find(&spi_master_idr, ctlr->bus_num);
 	mutex_unlock(&board_lock);
-        if (found != ctlr) {
-                dev_dbg(&ctlr->dev, 
+	if (found != ctlr) {
+		dev_dbg(&ctlr->dev,
 			"attempting to delete unregistered controller [%s]\n",
 			dev_name(&ctlr->dev));
-                return;
-        }
-
+		return;
+	}
 	if (ctlr->queued) {
 		if (spi_destroy_queue(ctlr))
 			dev_err(&ctlr->dev, "queue remove failed\n");
 	}
-
 	mutex_lock(&board_lock);
 	list_del(&ctlr->list);
 	mutex_unlock(&board_lock);

commit 9b61e302210eba55768962f2f11e96bb508c2408
Author: Suniel Mahesh <sunil.m@techveda.org>
Date:   Thu Aug 3 10:05:57 2017 +0530

    spi: Pick spi bus number from Linux idr or spi alias
    
    Modify existing code, for automatically picking the spi bus number based
    on Linux idr scheme as mentioned in FIXME.
    This patch does the following:
    (a) Remove the now unnecessary code which was allocating bus numbers using
        ATOMIC_INIT and atomic_dec_return macros.
    (b) If we have an alias, pick the bus number from alias ID
    (c) Convert to linux idr interface
    
    Signed-off-by: Suniel Mahesh <sunil.m@techveda.org>
    Signed-off-by: Karthik Tummala <karthik@techveda.org>
    Tested-by: Karthik Tummala <karthik@techveda.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index aed78093b130..b851888a0a0b 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -40,9 +40,13 @@
 #include <linux/ioport.h>
 #include <linux/acpi.h>
 #include <linux/highmem.h>
+#include <linux/idr.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/spi.h>
+#define SPI_DYN_FIRST_BUS_NUM 0
+
+static DEFINE_IDR(spi_master_idr);
 
 static void spidev_release(struct device *dev)
 {
@@ -420,6 +424,7 @@ static LIST_HEAD(spi_controller_list);
 /*
  * Used to protect add/del opertion for board_info list and
  * spi_controller list, and their matching process
+ * also used to protect object of type struct idr 
  */
 static DEFINE_MUTEX(board_lock);
 
@@ -2051,11 +2056,10 @@ static int of_spi_register_master(struct spi_controller *ctlr)
  */
 int spi_register_controller(struct spi_controller *ctlr)
 {
-	static atomic_t		dyn_bus_id = ATOMIC_INIT((1<<15) - 1);
 	struct device		*dev = ctlr->dev.parent;
 	struct boardinfo	*bi;
 	int			status = -ENODEV;
-	int			dynamic = 0;
+	int			id;
 
 	if (!dev)
 		return -ENODEV;
@@ -2071,17 +2075,29 @@ int spi_register_controller(struct spi_controller *ctlr)
 	 */
 	if (ctlr->num_chipselect == 0)
 		return -EINVAL;
-
-	if ((ctlr->bus_num < 0) && ctlr->dev.of_node)
-		ctlr->bus_num = of_alias_get_id(ctlr->dev.of_node, "spi");
-
-	/* convention:  dynamically assigned bus IDs count down from the max */
+	
+	/* allocate dynamic bus number using Linux idr */
+	if ((ctlr->bus_num < 0) && ctlr->dev.of_node) {
+		id = of_alias_get_id(ctlr->dev.of_node, "spi");
+		if (id >= 0) {
+			ctlr->bus_num = id;
+			mutex_lock(&board_lock);
+			id = idr_alloc(&spi_master_idr, ctlr, ctlr->bus_num,
+				       ctlr->bus_num + 1, GFP_KERNEL);
+			mutex_unlock(&board_lock);
+			if (WARN(id < 0, "couldn't get idr"))
+				return id == -ENOSPC ? -EBUSY : id;
+		}
+	}
 	if (ctlr->bus_num < 0) {
-		/* FIXME switch to an IDR based scheme, something like
-		 * I2C now uses, so we can't run out of "dynamic" IDs
-		 */
-		ctlr->bus_num = atomic_dec_return(&dyn_bus_id);
-		dynamic = 1;
+			mutex_lock(&board_lock);
+			id = idr_alloc(&spi_master_idr, ctlr,
+				       SPI_DYN_FIRST_BUS_NUM, 0, GFP_KERNEL);
+			mutex_unlock(&board_lock);
+			if (WARN(id < 0, "couldn't get idr"))
+				return id;
+
+			ctlr->bus_num = id;
 	}
 
 	INIT_LIST_HEAD(&ctlr->queue);
@@ -2099,11 +2115,16 @@ int spi_register_controller(struct spi_controller *ctlr)
 	 */
 	dev_set_name(&ctlr->dev, "spi%u", ctlr->bus_num);
 	status = device_add(&ctlr->dev);
-	if (status < 0)
+	if (status < 0) {
+		/* free bus id */
+		mutex_lock(&board_lock);
+		idr_remove(&spi_master_idr, ctlr->bus_num);
+		mutex_unlock(&board_lock);
 		goto done;
-	dev_dbg(dev, "registered %s %s%s\n",
+	}
+	dev_dbg(dev, "registered %s %s\n",
 			spi_controller_is_slave(ctlr) ? "slave" : "master",
-			dev_name(&ctlr->dev), dynamic ? " (dynamic)" : "");
+			dev_name(&ctlr->dev));
 
 	/* If we're using a queued driver, start the queue */
 	if (ctlr->transfer)
@@ -2112,6 +2133,10 @@ int spi_register_controller(struct spi_controller *ctlr)
 		status = spi_controller_initialize_queue(ctlr);
 		if (status) {
 			device_del(&ctlr->dev);
+			/* free bus id */
+			mutex_lock(&board_lock);
+			idr_remove(&spi_master_idr, ctlr->bus_num);
+			mutex_unlock(&board_lock);
 			goto done;
 		}
 	}
@@ -2190,8 +2215,20 @@ static int __unregister(struct device *dev, void *null)
  */
 void spi_unregister_controller(struct spi_controller *ctlr)
 {
+	struct spi_controller *found;
 	int dummy;
 
+	/* First make sure that this controller was ever added */
+	mutex_lock(&board_lock);
+	found = idr_find(&spi_master_idr, ctlr->bus_num);
+	mutex_unlock(&board_lock);
+        if (found != ctlr) {
+                dev_dbg(&ctlr->dev, 
+			"attempting to delete unregistered controller [%s]\n",
+			dev_name(&ctlr->dev));
+                return;
+        }
+
 	if (ctlr->queued) {
 		if (spi_destroy_queue(ctlr))
 			dev_err(&ctlr->dev, "queue remove failed\n");
@@ -2203,6 +2240,10 @@ void spi_unregister_controller(struct spi_controller *ctlr)
 
 	dummy = device_for_each_child(&ctlr->dev, NULL, __unregister);
 	device_unregister(&ctlr->dev);
+	/* free bus id */
+	mutex_lock(&board_lock);
+	idr_remove(&spi_master_idr, ctlr->bus_num);
+	mutex_unlock(&board_lock);
 }
 EXPORT_SYMBOL_GPL(spi_unregister_controller);
 

commit e0bcb680b152c96ee4b561abbeb18743cdcc5ae3
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sun Aug 6 23:15:31 2017 +0300

    spi: use of_property_read_bool()
    
    Use a bit more compact of_property_read_bool() calls instead of the
    of_find_property() calls -- symmetrically with the of_property_read_u32()
    calls already done in of_spi_parse_dt().
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index fe7bba9241ea..aed78093b130 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1532,15 +1532,15 @@ static int of_spi_parse_dt(struct spi_controller *ctlr, struct spi_device *spi,
 	int rc;
 
 	/* Mode (clock phase/polarity/etc.) */
-	if (of_find_property(nc, "spi-cpha", NULL))
+	if (of_property_read_bool(nc, "spi-cpha"))
 		spi->mode |= SPI_CPHA;
-	if (of_find_property(nc, "spi-cpol", NULL))
+	if (of_property_read_bool(nc, "spi-cpol"))
 		spi->mode |= SPI_CPOL;
-	if (of_find_property(nc, "spi-cs-high", NULL))
+	if (of_property_read_bool(nc, "spi-cs-high"))
 		spi->mode |= SPI_CS_HIGH;
-	if (of_find_property(nc, "spi-3wire", NULL))
+	if (of_property_read_bool(nc, "spi-3wire"))
 		spi->mode |= SPI_3WIRE;
-	if (of_find_property(nc, "spi-lsb-first", NULL))
+	if (of_property_read_bool(nc, "spi-lsb-first"))
 		spi->mode |= SPI_LSB_FIRST;
 
 	/* Device DUAL/QUAD mode */

commit 8a2e487e6fc1dddd406175c1f99a733f4a1206e2
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue Aug 1 14:10:41 2017 +0200

    spi: Use Apple device properties in absence of ACPI resources
    
    MacBooks and MacBook Pros introduced since 2015 return empty _CRS data
    for SPI slaves, causing device initialization to fail.  Most of the
    information that would normally be conveyed via _CRS is available
    through ACPI device properties instead, so take advantage of them.
    
    The meaning and appropriate usage of the device properties was reverse
    engineered by Ronald TschalÃ¤r and carried over from these commits
    authored by him:
    
    https://github.com/cb22/macbook12-spi-driver/commit/9a416d699ef4
    https://github.com/cb22/macbook12-spi-driver/commit/0c34936ed9a1
    
    According to Ronald, the device properties have the following meaning:
    
    spiSclkPeriod   /* period in ns */
    spiWordSize     /* in number of bits */
    spiBitOrder     /* 1 = MSB_FIRST, 0 = LSB_FIRST */
    spiSPO          /* clock polarity: 0 = low, 1 = high */
    spiSPH          /* clock phase: 0 = first, 1 = second */
    spiCSDelay      /* delay between cs and receive on reads in 10 us */
    resetA2RUsec    /* active-to-receive delay? */
    resetRecUsec    /* receive delay? */
    
    Reported-by: Leif Liddy <leif.liddy@gmail.com>
    Tested-by: Ronald TschalÃ¤r <ronald@innovation.ch>
    Acked-by: Mark Brown <broonie@kernel.org>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 4fcbb0aa71d3..7d920ea19957 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -40,6 +40,7 @@
 #include <linux/ioport.h>
 #include <linux/acpi.h>
 #include <linux/highmem.h>
+#include <linux/platform_data/x86/apple.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/spi.h>
@@ -1693,6 +1694,35 @@ static void of_register_spi_devices(struct spi_controller *ctlr) { }
 #endif
 
 #ifdef CONFIG_ACPI
+static void acpi_spi_parse_apple_properties(struct spi_device *spi)
+{
+	struct acpi_device *dev = ACPI_COMPANION(&spi->dev);
+	const union acpi_object *obj;
+
+	if (!x86_apple_machine)
+		return;
+
+	if (!acpi_dev_get_property(dev, "spiSclkPeriod", ACPI_TYPE_BUFFER, &obj)
+	    && obj->buffer.length >= 4)
+		spi->max_speed_hz  = NSEC_PER_SEC / *(u32 *)obj->buffer.pointer;
+
+	if (!acpi_dev_get_property(dev, "spiWordSize", ACPI_TYPE_BUFFER, &obj)
+	    && obj->buffer.length == 8)
+		spi->bits_per_word = *(u64 *)obj->buffer.pointer;
+
+	if (!acpi_dev_get_property(dev, "spiBitOrder", ACPI_TYPE_BUFFER, &obj)
+	    && obj->buffer.length == 8 && !*(u64 *)obj->buffer.pointer)
+		spi->mode |= SPI_LSB_FIRST;
+
+	if (!acpi_dev_get_property(dev, "spiSPO", ACPI_TYPE_BUFFER, &obj)
+	    && obj->buffer.length == 8 &&  *(u64 *)obj->buffer.pointer)
+		spi->mode |= SPI_CPOL;
+
+	if (!acpi_dev_get_property(dev, "spiSPH", ACPI_TYPE_BUFFER, &obj)
+	    && obj->buffer.length == 8 &&  *(u64 *)obj->buffer.pointer)
+		spi->mode |= SPI_CPHA;
+}
+
 static int acpi_spi_add_resource(struct acpi_resource *ares, void *data)
 {
 	struct spi_device *spi = data;
@@ -1766,6 +1796,8 @@ static acpi_status acpi_register_spi_device(struct spi_controller *ctlr,
 				     acpi_spi_add_resource, spi);
 	acpi_dev_free_resource_list(&resource_list);
 
+	acpi_spi_parse_apple_properties(spi);
+
 	if (ret < 0 || !spi->max_speed_hz) {
 		spi_dev_put(spi);
 		return AE_OK;

commit 2856670f23a92ab72db850d73f30c0b4b6ba5a76
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Jul 26 16:14:00 2017 +0300

    spi: core: Propagate error code of add_uevent_var()
    
    add_uevent_var() can fail, let caller know about this.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 4fcbb0aa71d3..fe7bba9241ea 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -321,8 +321,7 @@ static int spi_uevent(struct device *dev, struct kobj_uevent_env *env)
 	if (rc != -ENODEV)
 		return rc;
 
-	add_uevent_var(env, "MODALIAS=%s%s", SPI_MODULE_PREFIX, spi->modalias);
-	return 0;
+	return add_uevent_var(env, "MODALIAS=%s%s", SPI_MODULE_PREFIX, spi->modalias);
 }
 
 struct bus_type spi_bus_type = {

commit 25c56c88a4627e7fdbfa12a4c20c75e2ccb366d1
Author: Rob Herring <robh@kernel.org>
Date:   Tue Jul 18 16:43:31 2017 -0500

    spi: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 4fcbb0aa71d3..0725c78b0de6 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1583,8 +1583,8 @@ static int of_spi_parse_dt(struct spi_controller *ctlr, struct spi_device *spi,
 
 	if (spi_controller_is_slave(ctlr)) {
 		if (strcmp(nc->name, "slave")) {
-			dev_err(&ctlr->dev, "%s is not called 'slave'\n",
-				nc->full_name);
+			dev_err(&ctlr->dev, "%pOF is not called 'slave'\n",
+				nc);
 			return -EINVAL;
 		}
 		return 0;
@@ -1593,8 +1593,8 @@ static int of_spi_parse_dt(struct spi_controller *ctlr, struct spi_device *spi,
 	/* Device address */
 	rc = of_property_read_u32(nc, "reg", &value);
 	if (rc) {
-		dev_err(&ctlr->dev, "%s has no valid 'reg' property (%d)\n",
-			nc->full_name, rc);
+		dev_err(&ctlr->dev, "%pOF has no valid 'reg' property (%d)\n",
+			nc, rc);
 		return rc;
 	}
 	spi->chip_select = value;
@@ -1603,8 +1603,7 @@ static int of_spi_parse_dt(struct spi_controller *ctlr, struct spi_device *spi,
 	rc = of_property_read_u32(nc, "spi-max-frequency", &value);
 	if (rc) {
 		dev_err(&ctlr->dev,
-			"%s has no valid 'spi-max-frequency' property (%d)\n",
-			nc->full_name, rc);
+			"%pOF has no valid 'spi-max-frequency' property (%d)\n", nc, rc);
 		return rc;
 	}
 	spi->max_speed_hz = value;
@@ -1621,8 +1620,7 @@ of_register_spi_device(struct spi_controller *ctlr, struct device_node *nc)
 	/* Alloc an spi_device */
 	spi = spi_alloc_device(ctlr);
 	if (!spi) {
-		dev_err(&ctlr->dev, "spi_device alloc error for %s\n",
-			nc->full_name);
+		dev_err(&ctlr->dev, "spi_device alloc error for %pOF\n", nc);
 		rc = -ENOMEM;
 		goto err_out;
 	}
@@ -1631,8 +1629,7 @@ of_register_spi_device(struct spi_controller *ctlr, struct device_node *nc)
 	rc = of_modalias_node(nc, spi->modalias,
 				sizeof(spi->modalias));
 	if (rc < 0) {
-		dev_err(&ctlr->dev, "cannot find modalias for %s\n",
-			nc->full_name);
+		dev_err(&ctlr->dev, "cannot find modalias for %pOF\n", nc);
 		goto err_out;
 	}
 
@@ -1647,8 +1644,7 @@ of_register_spi_device(struct spi_controller *ctlr, struct device_node *nc)
 	/* Register the new device */
 	rc = spi_add_device(spi);
 	if (rc) {
-		dev_err(&ctlr->dev, "spi_device register error %s\n",
-			nc->full_name);
+		dev_err(&ctlr->dev, "spi_device register error %pOF\n", nc);
 		goto err_of_node_put;
 	}
 
@@ -1682,8 +1678,7 @@ static void of_register_spi_devices(struct spi_controller *ctlr)
 		spi = of_register_spi_device(ctlr, nc);
 		if (IS_ERR(spi)) {
 			dev_warn(&ctlr->dev,
-				 "Failed to create SPI device for %s\n",
-				 nc->full_name);
+				 "Failed to create SPI device for %pOF\n", nc);
 			of_node_clear_flag(nc, OF_POPULATED);
 		}
 	}
@@ -3311,8 +3306,8 @@ static int of_spi_notify(struct notifier_block *nb, unsigned long action,
 		put_device(&ctlr->dev);
 
 		if (IS_ERR(spi)) {
-			pr_err("%s: failed to create for '%s'\n",
-					__func__, rd->dn->full_name);
+			pr_err("%s: failed to create for '%pOF'\n",
+					__func__, rd->dn);
 			of_node_clear_flag(rd->dn, OF_POPULATED);
 			return notifier_from_errno(PTR_ERR(spi));
 		}

commit 8caab75fd2c2a92667cbb1cd315720bede3feaa9
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Jun 13 13:23:52 2017 +0200

    spi: Generalize SPI "master" to "controller"
    
    Now struct spi_master is used for both SPI master and slave controllers,
    it makes sense to rename it to struct spi_controller, and replace
    "master" by "controller" where appropriate.
    
    For now this conversion is done for SPI core infrastructure only.
    Wrappers are provided for backwards compatibility, until all SPI drivers
    have been converted.
    
    Noteworthy details:
      - SPI_MASTER_GPIO_SS is retained, as it only makes sense for SPI
        master controllers,
      - spi_busnum_to_master() is retained, as it looks up masters only,
      - A new field spi_device.controller is added, but spi_device.master is
        retained for compatibility (both are always initialized by
        spi_alloc_device()),
      - spi_flash_read() is used by SPI masters only.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index c3f6b524b3ce..4fcbb0aa71d3 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -48,11 +48,11 @@ static void spidev_release(struct device *dev)
 {
 	struct spi_device	*spi = to_spi_device(dev);
 
-	/* spi masters may cleanup for released devices */
-	if (spi->master->cleanup)
-		spi->master->cleanup(spi);
+	/* spi controllers may cleanup for released devices */
+	if (spi->controller->cleanup)
+		spi->controller->cleanup(spi);
 
-	spi_master_put(spi->master);
+	spi_controller_put(spi->controller);
 	kfree(spi);
 }
 
@@ -71,17 +71,17 @@ modalias_show(struct device *dev, struct device_attribute *a, char *buf)
 static DEVICE_ATTR_RO(modalias);
 
 #define SPI_STATISTICS_ATTRS(field, file)				\
-static ssize_t spi_master_##field##_show(struct device *dev,		\
-					 struct device_attribute *attr,	\
-					 char *buf)			\
+static ssize_t spi_controller_##field##_show(struct device *dev,	\
+					     struct device_attribute *attr, \
+					     char *buf)			\
 {									\
-	struct spi_master *master = container_of(dev,			\
-						 struct spi_master, dev); \
-	return spi_statistics_##field##_show(&master->statistics, buf);	\
+	struct spi_controller *ctlr = container_of(dev,			\
+					 struct spi_controller, dev);	\
+	return spi_statistics_##field##_show(&ctlr->statistics, buf);	\
 }									\
-static struct device_attribute dev_attr_spi_master_##field = {		\
+static struct device_attribute dev_attr_spi_controller_##field = {	\
 	.attr = { .name = file, .mode = 0444 },				\
-	.show = spi_master_##field##_show,				\
+	.show = spi_controller_##field##_show,				\
 };									\
 static ssize_t spi_device_##field##_show(struct device *dev,		\
 					 struct device_attribute *attr,	\
@@ -201,51 +201,51 @@ static const struct attribute_group *spi_dev_groups[] = {
 	NULL,
 };
 
-static struct attribute *spi_master_statistics_attrs[] = {
-	&dev_attr_spi_master_messages.attr,
-	&dev_attr_spi_master_transfers.attr,
-	&dev_attr_spi_master_errors.attr,
-	&dev_attr_spi_master_timedout.attr,
-	&dev_attr_spi_master_spi_sync.attr,
-	&dev_attr_spi_master_spi_sync_immediate.attr,
-	&dev_attr_spi_master_spi_async.attr,
-	&dev_attr_spi_master_bytes.attr,
-	&dev_attr_spi_master_bytes_rx.attr,
-	&dev_attr_spi_master_bytes_tx.attr,
-	&dev_attr_spi_master_transfer_bytes_histo0.attr,
-	&dev_attr_spi_master_transfer_bytes_histo1.attr,
-	&dev_attr_spi_master_transfer_bytes_histo2.attr,
-	&dev_attr_spi_master_transfer_bytes_histo3.attr,
-	&dev_attr_spi_master_transfer_bytes_histo4.attr,
-	&dev_attr_spi_master_transfer_bytes_histo5.attr,
-	&dev_attr_spi_master_transfer_bytes_histo6.attr,
-	&dev_attr_spi_master_transfer_bytes_histo7.attr,
-	&dev_attr_spi_master_transfer_bytes_histo8.attr,
-	&dev_attr_spi_master_transfer_bytes_histo9.attr,
-	&dev_attr_spi_master_transfer_bytes_histo10.attr,
-	&dev_attr_spi_master_transfer_bytes_histo11.attr,
-	&dev_attr_spi_master_transfer_bytes_histo12.attr,
-	&dev_attr_spi_master_transfer_bytes_histo13.attr,
-	&dev_attr_spi_master_transfer_bytes_histo14.attr,
-	&dev_attr_spi_master_transfer_bytes_histo15.attr,
-	&dev_attr_spi_master_transfer_bytes_histo16.attr,
-	&dev_attr_spi_master_transfers_split_maxsize.attr,
+static struct attribute *spi_controller_statistics_attrs[] = {
+	&dev_attr_spi_controller_messages.attr,
+	&dev_attr_spi_controller_transfers.attr,
+	&dev_attr_spi_controller_errors.attr,
+	&dev_attr_spi_controller_timedout.attr,
+	&dev_attr_spi_controller_spi_sync.attr,
+	&dev_attr_spi_controller_spi_sync_immediate.attr,
+	&dev_attr_spi_controller_spi_async.attr,
+	&dev_attr_spi_controller_bytes.attr,
+	&dev_attr_spi_controller_bytes_rx.attr,
+	&dev_attr_spi_controller_bytes_tx.attr,
+	&dev_attr_spi_controller_transfer_bytes_histo0.attr,
+	&dev_attr_spi_controller_transfer_bytes_histo1.attr,
+	&dev_attr_spi_controller_transfer_bytes_histo2.attr,
+	&dev_attr_spi_controller_transfer_bytes_histo3.attr,
+	&dev_attr_spi_controller_transfer_bytes_histo4.attr,
+	&dev_attr_spi_controller_transfer_bytes_histo5.attr,
+	&dev_attr_spi_controller_transfer_bytes_histo6.attr,
+	&dev_attr_spi_controller_transfer_bytes_histo7.attr,
+	&dev_attr_spi_controller_transfer_bytes_histo8.attr,
+	&dev_attr_spi_controller_transfer_bytes_histo9.attr,
+	&dev_attr_spi_controller_transfer_bytes_histo10.attr,
+	&dev_attr_spi_controller_transfer_bytes_histo11.attr,
+	&dev_attr_spi_controller_transfer_bytes_histo12.attr,
+	&dev_attr_spi_controller_transfer_bytes_histo13.attr,
+	&dev_attr_spi_controller_transfer_bytes_histo14.attr,
+	&dev_attr_spi_controller_transfer_bytes_histo15.attr,
+	&dev_attr_spi_controller_transfer_bytes_histo16.attr,
+	&dev_attr_spi_controller_transfers_split_maxsize.attr,
 	NULL,
 };
 
-static const struct attribute_group spi_master_statistics_group = {
+static const struct attribute_group spi_controller_statistics_group = {
 	.name  = "statistics",
-	.attrs  = spi_master_statistics_attrs,
+	.attrs  = spi_controller_statistics_attrs,
 };
 
 static const struct attribute_group *spi_master_groups[] = {
-	&spi_master_statistics_group,
+	&spi_controller_statistics_group,
 	NULL,
 };
 
 void spi_statistics_add_transfer_stats(struct spi_statistics *stats,
 				       struct spi_transfer *xfer,
-				       struct spi_master *master)
+				       struct spi_controller *ctlr)
 {
 	unsigned long flags;
 	int l2len = min(fls(xfer->len), SPI_STATISTICS_HISTO_SIZE) - 1;
@@ -260,10 +260,10 @@ void spi_statistics_add_transfer_stats(struct spi_statistics *stats,
 
 	stats->bytes += xfer->len;
 	if ((xfer->tx_buf) &&
-	    (xfer->tx_buf != master->dummy_tx))
+	    (xfer->tx_buf != ctlr->dummy_tx))
 		stats->bytes_tx += xfer->len;
 	if ((xfer->rx_buf) &&
-	    (xfer->rx_buf != master->dummy_rx))
+	    (xfer->rx_buf != ctlr->dummy_rx))
 		stats->bytes_rx += xfer->len;
 
 	spin_unlock_irqrestore(&stats->lock, flags);
@@ -405,7 +405,7 @@ EXPORT_SYMBOL_GPL(__spi_register_driver);
 /*-------------------------------------------------------------------------*/
 
 /* SPI devices should normally not be created by SPI device drivers; that
- * would make them board-specific.  Similarly with SPI master drivers.
+ * would make them board-specific.  Similarly with SPI controller drivers.
  * Device registration normally goes into like arch/.../mach.../board-YYY.c
  * with other readonly (flashable) information about mainboard devices.
  */
@@ -416,17 +416,17 @@ struct boardinfo {
 };
 
 static LIST_HEAD(board_list);
-static LIST_HEAD(spi_master_list);
+static LIST_HEAD(spi_controller_list);
 
 /*
  * Used to protect add/del opertion for board_info list and
- * spi_master list, and their matching process
+ * spi_controller list, and their matching process
  */
 static DEFINE_MUTEX(board_lock);
 
 /**
  * spi_alloc_device - Allocate a new SPI device
- * @master: Controller to which device is connected
+ * @ctlr: Controller to which device is connected
  * Context: can sleep
  *
  * Allows a driver to allocate and initialize a spi_device without
@@ -435,27 +435,27 @@ static DEFINE_MUTEX(board_lock);
  * spi_add_device() on it.
  *
  * Caller is responsible to call spi_add_device() on the returned
- * spi_device structure to add it to the SPI master.  If the caller
+ * spi_device structure to add it to the SPI controller.  If the caller
  * needs to discard the spi_device without adding it, then it should
  * call spi_dev_put() on it.
  *
  * Return: a pointer to the new device, or NULL.
  */
-struct spi_device *spi_alloc_device(struct spi_master *master)
+struct spi_device *spi_alloc_device(struct spi_controller *ctlr)
 {
 	struct spi_device	*spi;
 
-	if (!spi_master_get(master))
+	if (!spi_controller_get(ctlr))
 		return NULL;
 
 	spi = kzalloc(sizeof(*spi), GFP_KERNEL);
 	if (!spi) {
-		spi_master_put(master);
+		spi_controller_put(ctlr);
 		return NULL;
 	}
 
-	spi->master = master;
-	spi->dev.parent = &master->dev;
+	spi->master = spi->controller = ctlr;
+	spi->dev.parent = &ctlr->dev;
 	spi->dev.bus = &spi_bus_type;
 	spi->dev.release = spidev_release;
 	spi->cs_gpio = -ENOENT;
@@ -476,7 +476,7 @@ static void spi_dev_set_name(struct spi_device *spi)
 		return;
 	}
 
-	dev_set_name(&spi->dev, "%s.%u", dev_name(&spi->master->dev),
+	dev_set_name(&spi->dev, "%s.%u", dev_name(&spi->controller->dev),
 		     spi->chip_select);
 }
 
@@ -485,7 +485,7 @@ static int spi_dev_check(struct device *dev, void *data)
 	struct spi_device *spi = to_spi_device(dev);
 	struct spi_device *new_spi = data;
 
-	if (spi->master == new_spi->master &&
+	if (spi->controller == new_spi->controller &&
 	    spi->chip_select == new_spi->chip_select)
 		return -EBUSY;
 	return 0;
@@ -503,15 +503,14 @@ static int spi_dev_check(struct device *dev, void *data)
 int spi_add_device(struct spi_device *spi)
 {
 	static DEFINE_MUTEX(spi_add_lock);
-	struct spi_master *master = spi->master;
-	struct device *dev = master->dev.parent;
+	struct spi_controller *ctlr = spi->controller;
+	struct device *dev = ctlr->dev.parent;
 	int status;
 
 	/* Chipselects are numbered 0..max; validate. */
-	if (spi->chip_select >= master->num_chipselect) {
-		dev_err(dev, "cs%d >= max %d\n",
-			spi->chip_select,
-			master->num_chipselect);
+	if (spi->chip_select >= ctlr->num_chipselect) {
+		dev_err(dev, "cs%d >= max %d\n", spi->chip_select,
+			ctlr->num_chipselect);
 		return -EINVAL;
 	}
 
@@ -531,8 +530,8 @@ int spi_add_device(struct spi_device *spi)
 		goto done;
 	}
 
-	if (master->cs_gpios)
-		spi->cs_gpio = master->cs_gpios[spi->chip_select];
+	if (ctlr->cs_gpios)
+		spi->cs_gpio = ctlr->cs_gpios[spi->chip_select];
 
 	/* Drivers may modify this initial i/o setup, but will
 	 * normally rely on the device being setup.  Devices
@@ -561,7 +560,7 @@ EXPORT_SYMBOL_GPL(spi_add_device);
 
 /**
  * spi_new_device - instantiate one new SPI device
- * @master: Controller to which device is connected
+ * @ctlr: Controller to which device is connected
  * @chip: Describes the SPI device
  * Context: can sleep
  *
@@ -573,7 +572,7 @@ EXPORT_SYMBOL_GPL(spi_add_device);
  *
  * Return: the new device, or NULL.
  */
-struct spi_device *spi_new_device(struct spi_master *master,
+struct spi_device *spi_new_device(struct spi_controller *ctlr,
 				  struct spi_board_info *chip)
 {
 	struct spi_device	*proxy;
@@ -586,7 +585,7 @@ struct spi_device *spi_new_device(struct spi_master *master,
 	 * suggests syslogged diagnostics are best here (ugh).
 	 */
 
-	proxy = spi_alloc_device(master);
+	proxy = spi_alloc_device(ctlr);
 	if (!proxy)
 		return NULL;
 
@@ -604,7 +603,7 @@ struct spi_device *spi_new_device(struct spi_master *master,
 	if (chip->properties) {
 		status = device_add_properties(&proxy->dev, chip->properties);
 		if (status) {
-			dev_err(&master->dev,
+			dev_err(&ctlr->dev,
 				"failed to add properties to '%s': %d\n",
 				chip->modalias, status);
 			goto err_dev_put;
@@ -631,7 +630,7 @@ EXPORT_SYMBOL_GPL(spi_new_device);
  * @spi: spi_device to unregister
  *
  * Start making the passed SPI device vanish. Normally this would be handled
- * by spi_unregister_master().
+ * by spi_unregister_controller().
  */
 void spi_unregister_device(struct spi_device *spi)
 {
@@ -648,17 +647,17 @@ void spi_unregister_device(struct spi_device *spi)
 }
 EXPORT_SYMBOL_GPL(spi_unregister_device);
 
-static void spi_match_master_to_boardinfo(struct spi_master *master,
-				struct spi_board_info *bi)
+static void spi_match_controller_to_boardinfo(struct spi_controller *ctlr,
+					      struct spi_board_info *bi)
 {
 	struct spi_device *dev;
 
-	if (master->bus_num != bi->bus_num)
+	if (ctlr->bus_num != bi->bus_num)
 		return;
 
-	dev = spi_new_device(master, bi);
+	dev = spi_new_device(ctlr, bi);
 	if (!dev)
-		dev_err(master->dev.parent, "can't create new device for %s\n",
+		dev_err(ctlr->dev.parent, "can't create new device for %s\n",
 			bi->modalias);
 }
 
@@ -697,7 +696,7 @@ int spi_register_board_info(struct spi_board_info const *info, unsigned n)
 		return -ENOMEM;
 
 	for (i = 0; i < n; i++, bi++, info++) {
-		struct spi_master *master;
+		struct spi_controller *ctlr;
 
 		memcpy(&bi->board_info, info, sizeof(*info));
 		if (info->properties) {
@@ -709,8 +708,9 @@ int spi_register_board_info(struct spi_board_info const *info, unsigned n)
 
 		mutex_lock(&board_lock);
 		list_add_tail(&bi->list, &board_list);
-		list_for_each_entry(master, &spi_master_list, list)
-			spi_match_master_to_boardinfo(master, &bi->board_info);
+		list_for_each_entry(ctlr, &spi_controller_list, list)
+			spi_match_controller_to_boardinfo(ctlr,
+							  &bi->board_info);
 		mutex_unlock(&board_lock);
 	}
 
@@ -727,16 +727,16 @@ static void spi_set_cs(struct spi_device *spi, bool enable)
 	if (gpio_is_valid(spi->cs_gpio)) {
 		gpio_set_value(spi->cs_gpio, !enable);
 		/* Some SPI masters need both GPIO CS & slave_select */
-		if ((spi->master->flags & SPI_MASTER_GPIO_SS) &&
-		    spi->master->set_cs)
-			spi->master->set_cs(spi, !enable);
-	} else if (spi->master->set_cs) {
-		spi->master->set_cs(spi, !enable);
+		if ((spi->controller->flags & SPI_MASTER_GPIO_SS) &&
+		    spi->controller->set_cs)
+			spi->controller->set_cs(spi, !enable);
+	} else if (spi->controller->set_cs) {
+		spi->controller->set_cs(spi, !enable);
 	}
 }
 
 #ifdef CONFIG_HAS_DMA
-static int spi_map_buf(struct spi_master *master, struct device *dev,
+static int spi_map_buf(struct spi_controller *ctlr, struct device *dev,
 		       struct sg_table *sgt, void *buf, size_t len,
 		       enum dma_data_direction dir)
 {
@@ -761,7 +761,7 @@ static int spi_map_buf(struct spi_master *master, struct device *dev,
 		desc_len = min_t(int, max_seg_size, PAGE_SIZE);
 		sgs = DIV_ROUND_UP(len + offset_in_page(buf), desc_len);
 	} else if (virt_addr_valid(buf)) {
-		desc_len = min_t(int, max_seg_size, master->max_dma_len);
+		desc_len = min_t(int, max_seg_size, ctlr->max_dma_len);
 		sgs = DIV_ROUND_UP(len, desc_len);
 	} else {
 		return -EINVAL;
@@ -811,7 +811,7 @@ static int spi_map_buf(struct spi_master *master, struct device *dev,
 	return 0;
 }
 
-static void spi_unmap_buf(struct spi_master *master, struct device *dev,
+static void spi_unmap_buf(struct spi_controller *ctlr, struct device *dev,
 			  struct sg_table *sgt, enum dma_data_direction dir)
 {
 	if (sgt->orig_nents) {
@@ -820,31 +820,31 @@ static void spi_unmap_buf(struct spi_master *master, struct device *dev,
 	}
 }
 
-static int __spi_map_msg(struct spi_master *master, struct spi_message *msg)
+static int __spi_map_msg(struct spi_controller *ctlr, struct spi_message *msg)
 {
 	struct device *tx_dev, *rx_dev;
 	struct spi_transfer *xfer;
 	int ret;
 
-	if (!master->can_dma)
+	if (!ctlr->can_dma)
 		return 0;
 
-	if (master->dma_tx)
-		tx_dev = master->dma_tx->device->dev;
+	if (ctlr->dma_tx)
+		tx_dev = ctlr->dma_tx->device->dev;
 	else
-		tx_dev = master->dev.parent;
+		tx_dev = ctlr->dev.parent;
 
-	if (master->dma_rx)
-		rx_dev = master->dma_rx->device->dev;
+	if (ctlr->dma_rx)
+		rx_dev = ctlr->dma_rx->device->dev;
 	else
-		rx_dev = master->dev.parent;
+		rx_dev = ctlr->dev.parent;
 
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
-		if (!master->can_dma(master, msg->spi, xfer))
+		if (!ctlr->can_dma(ctlr, msg->spi, xfer))
 			continue;
 
 		if (xfer->tx_buf != NULL) {
-			ret = spi_map_buf(master, tx_dev, &xfer->tx_sg,
+			ret = spi_map_buf(ctlr, tx_dev, &xfer->tx_sg,
 					  (void *)xfer->tx_buf, xfer->len,
 					  DMA_TO_DEVICE);
 			if (ret != 0)
@@ -852,79 +852,78 @@ static int __spi_map_msg(struct spi_master *master, struct spi_message *msg)
 		}
 
 		if (xfer->rx_buf != NULL) {
-			ret = spi_map_buf(master, rx_dev, &xfer->rx_sg,
+			ret = spi_map_buf(ctlr, rx_dev, &xfer->rx_sg,
 					  xfer->rx_buf, xfer->len,
 					  DMA_FROM_DEVICE);
 			if (ret != 0) {
-				spi_unmap_buf(master, tx_dev, &xfer->tx_sg,
+				spi_unmap_buf(ctlr, tx_dev, &xfer->tx_sg,
 					      DMA_TO_DEVICE);
 				return ret;
 			}
 		}
 	}
 
-	master->cur_msg_mapped = true;
+	ctlr->cur_msg_mapped = true;
 
 	return 0;
 }
 
-static int __spi_unmap_msg(struct spi_master *master, struct spi_message *msg)
+static int __spi_unmap_msg(struct spi_controller *ctlr, struct spi_message *msg)
 {
 	struct spi_transfer *xfer;
 	struct device *tx_dev, *rx_dev;
 
-	if (!master->cur_msg_mapped || !master->can_dma)
+	if (!ctlr->cur_msg_mapped || !ctlr->can_dma)
 		return 0;
 
-	if (master->dma_tx)
-		tx_dev = master->dma_tx->device->dev;
+	if (ctlr->dma_tx)
+		tx_dev = ctlr->dma_tx->device->dev;
 	else
-		tx_dev = master->dev.parent;
+		tx_dev = ctlr->dev.parent;
 
-	if (master->dma_rx)
-		rx_dev = master->dma_rx->device->dev;
+	if (ctlr->dma_rx)
+		rx_dev = ctlr->dma_rx->device->dev;
 	else
-		rx_dev = master->dev.parent;
+		rx_dev = ctlr->dev.parent;
 
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
-		if (!master->can_dma(master, msg->spi, xfer))
+		if (!ctlr->can_dma(ctlr, msg->spi, xfer))
 			continue;
 
-		spi_unmap_buf(master, rx_dev, &xfer->rx_sg, DMA_FROM_DEVICE);
-		spi_unmap_buf(master, tx_dev, &xfer->tx_sg, DMA_TO_DEVICE);
+		spi_unmap_buf(ctlr, rx_dev, &xfer->rx_sg, DMA_FROM_DEVICE);
+		spi_unmap_buf(ctlr, tx_dev, &xfer->tx_sg, DMA_TO_DEVICE);
 	}
 
 	return 0;
 }
 #else /* !CONFIG_HAS_DMA */
-static inline int spi_map_buf(struct spi_master *master,
-			      struct device *dev, struct sg_table *sgt,
-			      void *buf, size_t len,
+static inline int spi_map_buf(struct spi_controller *ctlr, struct device *dev,
+			      struct sg_table *sgt, void *buf, size_t len,
 			      enum dma_data_direction dir)
 {
 	return -EINVAL;
 }
 
-static inline void spi_unmap_buf(struct spi_master *master,
+static inline void spi_unmap_buf(struct spi_controller *ctlr,
 				 struct device *dev, struct sg_table *sgt,
 				 enum dma_data_direction dir)
 {
 }
 
-static inline int __spi_map_msg(struct spi_master *master,
+static inline int __spi_map_msg(struct spi_controller *ctlr,
 				struct spi_message *msg)
 {
 	return 0;
 }
 
-static inline int __spi_unmap_msg(struct spi_master *master,
+static inline int __spi_unmap_msg(struct spi_controller *ctlr,
 				  struct spi_message *msg)
 {
 	return 0;
 }
 #endif /* !CONFIG_HAS_DMA */
 
-static inline int spi_unmap_msg(struct spi_master *master,
+static inline int spi_unmap_msg(struct spi_controller *ctlr,
 				struct spi_message *msg)
 {
 	struct spi_transfer *xfer;
@@ -934,63 +933,63 @@ static inline int spi_unmap_msg(struct spi_master *master,
 		 * Restore the original value of tx_buf or rx_buf if they are
 		 * NULL.
 		 */
-		if (xfer->tx_buf == master->dummy_tx)
+		if (xfer->tx_buf == ctlr->dummy_tx)
 			xfer->tx_buf = NULL;
-		if (xfer->rx_buf == master->dummy_rx)
+		if (xfer->rx_buf == ctlr->dummy_rx)
 			xfer->rx_buf = NULL;
 	}
 
-	return __spi_unmap_msg(master, msg);
+	return __spi_unmap_msg(ctlr, msg);
 }
 
-static int spi_map_msg(struct spi_master *master, struct spi_message *msg)
+static int spi_map_msg(struct spi_controller *ctlr, struct spi_message *msg)
 {
 	struct spi_transfer *xfer;
 	void *tmp;
 	unsigned int max_tx, max_rx;
 
-	if (master->flags & (SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX)) {
+	if (ctlr->flags & (SPI_CONTROLLER_MUST_RX | SPI_CONTROLLER_MUST_TX)) {
 		max_tx = 0;
 		max_rx = 0;
 
 		list_for_each_entry(xfer, &msg->transfers, transfer_list) {
-			if ((master->flags & SPI_MASTER_MUST_TX) &&
+			if ((ctlr->flags & SPI_CONTROLLER_MUST_TX) &&
 			    !xfer->tx_buf)
 				max_tx = max(xfer->len, max_tx);
-			if ((master->flags & SPI_MASTER_MUST_RX) &&
+			if ((ctlr->flags & SPI_CONTROLLER_MUST_RX) &&
 			    !xfer->rx_buf)
 				max_rx = max(xfer->len, max_rx);
 		}
 
 		if (max_tx) {
-			tmp = krealloc(master->dummy_tx, max_tx,
+			tmp = krealloc(ctlr->dummy_tx, max_tx,
 				       GFP_KERNEL | GFP_DMA);
 			if (!tmp)
 				return -ENOMEM;
-			master->dummy_tx = tmp;
+			ctlr->dummy_tx = tmp;
 			memset(tmp, 0, max_tx);
 		}
 
 		if (max_rx) {
-			tmp = krealloc(master->dummy_rx, max_rx,
+			tmp = krealloc(ctlr->dummy_rx, max_rx,
 				       GFP_KERNEL | GFP_DMA);
 			if (!tmp)
 				return -ENOMEM;
-			master->dummy_rx = tmp;
+			ctlr->dummy_rx = tmp;
 		}
 
 		if (max_tx || max_rx) {
 			list_for_each_entry(xfer, &msg->transfers,
 					    transfer_list) {
 				if (!xfer->tx_buf)
-					xfer->tx_buf = master->dummy_tx;
+					xfer->tx_buf = ctlr->dummy_tx;
 				if (!xfer->rx_buf)
-					xfer->rx_buf = master->dummy_rx;
+					xfer->rx_buf = ctlr->dummy_rx;
 			}
 		}
 	}
 
-	return __spi_map_msg(master, msg);
+	return __spi_map_msg(ctlr, msg);
 }
 
 /*
@@ -1000,14 +999,14 @@ static int spi_map_msg(struct spi_master *master, struct spi_message *msg)
  * drivers which implement a transfer_one() operation.  It provides
  * standard handling of delays and chip select management.
  */
-static int spi_transfer_one_message(struct spi_master *master,
+static int spi_transfer_one_message(struct spi_controller *ctlr,
 				    struct spi_message *msg)
 {
 	struct spi_transfer *xfer;
 	bool keep_cs = false;
 	int ret = 0;
 	unsigned long long ms = 1;
-	struct spi_statistics *statm = &master->statistics;
+	struct spi_statistics *statm = &ctlr->statistics;
 	struct spi_statistics *stats = &msg->spi->statistics;
 
 	spi_set_cs(msg->spi, true);
@@ -1018,13 +1017,13 @@ static int spi_transfer_one_message(struct spi_master *master,
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		trace_spi_transfer_start(msg, xfer);
 
-		spi_statistics_add_transfer_stats(statm, xfer, master);
-		spi_statistics_add_transfer_stats(stats, xfer, master);
+		spi_statistics_add_transfer_stats(statm, xfer, ctlr);
+		spi_statistics_add_transfer_stats(stats, xfer, ctlr);
 
 		if (xfer->tx_buf || xfer->rx_buf) {
-			reinit_completion(&master->xfer_completion);
+			reinit_completion(&ctlr->xfer_completion);
 
-			ret = master->transfer_one(master, msg->spi, xfer);
+			ret = ctlr->transfer_one(ctlr, msg->spi, xfer);
 			if (ret < 0) {
 				SPI_STATISTICS_INCREMENT_FIELD(statm,
 							       errors);
@@ -1044,7 +1043,7 @@ static int spi_transfer_one_message(struct spi_master *master,
 				if (ms > UINT_MAX)
 					ms = UINT_MAX;
 
-				ms = wait_for_completion_timeout(&master->xfer_completion,
+				ms = wait_for_completion_timeout(&ctlr->xfer_completion,
 								 msecs_to_jiffies(ms));
 			}
 
@@ -1099,33 +1098,33 @@ static int spi_transfer_one_message(struct spi_master *master,
 	if (msg->status == -EINPROGRESS)
 		msg->status = ret;
 
-	if (msg->status && master->handle_err)
-		master->handle_err(master, msg);
+	if (msg->status && ctlr->handle_err)
+		ctlr->handle_err(ctlr, msg);
 
-	spi_res_release(master, msg);
+	spi_res_release(ctlr, msg);
 
-	spi_finalize_current_message(master);
+	spi_finalize_current_message(ctlr);
 
 	return ret;
 }
 
 /**
  * spi_finalize_current_transfer - report completion of a transfer
- * @master: the master reporting completion
+ * @ctlr: the controller reporting completion
  *
  * Called by SPI drivers using the core transfer_one_message()
  * implementation to notify it that the current interrupt driven
  * transfer has finished and the next one may be scheduled.
  */
-void spi_finalize_current_transfer(struct spi_master *master)
+void spi_finalize_current_transfer(struct spi_controller *ctlr)
 {
-	complete(&master->xfer_completion);
+	complete(&ctlr->xfer_completion);
 }
 EXPORT_SYMBOL_GPL(spi_finalize_current_transfer);
 
 /**
  * __spi_pump_messages - function which processes spi message queue
- * @master: master to process queue for
+ * @ctlr: controller to process queue for
  * @in_kthread: true if we are in the context of the message pump thread
  *
  * This function checks if there is any spi message in the queue that
@@ -1136,136 +1135,136 @@ EXPORT_SYMBOL_GPL(spi_finalize_current_transfer);
  * inside spi_sync(); the queue extraction handling at the top of the
  * function should deal with this safely.
  */
-static void __spi_pump_messages(struct spi_master *master, bool in_kthread)
+static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
 {
 	unsigned long flags;
 	bool was_busy = false;
 	int ret;
 
 	/* Lock queue */
-	spin_lock_irqsave(&master->queue_lock, flags);
+	spin_lock_irqsave(&ctlr->queue_lock, flags);
 
 	/* Make sure we are not already running a message */
-	if (master->cur_msg) {
-		spin_unlock_irqrestore(&master->queue_lock, flags);
+	if (ctlr->cur_msg) {
+		spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 		return;
 	}
 
 	/* If another context is idling the device then defer */
-	if (master->idling) {
-		kthread_queue_work(&master->kworker, &master->pump_messages);
-		spin_unlock_irqrestore(&master->queue_lock, flags);
+	if (ctlr->idling) {
+		kthread_queue_work(&ctlr->kworker, &ctlr->pump_messages);
+		spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 		return;
 	}
 
 	/* Check if the queue is idle */
-	if (list_empty(&master->queue) || !master->running) {
-		if (!master->busy) {
-			spin_unlock_irqrestore(&master->queue_lock, flags);
+	if (list_empty(&ctlr->queue) || !ctlr->running) {
+		if (!ctlr->busy) {
+			spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 			return;
 		}
 
 		/* Only do teardown in the thread */
 		if (!in_kthread) {
-			kthread_queue_work(&master->kworker,
-					   &master->pump_messages);
-			spin_unlock_irqrestore(&master->queue_lock, flags);
+			kthread_queue_work(&ctlr->kworker,
+					   &ctlr->pump_messages);
+			spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 			return;
 		}
 
-		master->busy = false;
-		master->idling = true;
-		spin_unlock_irqrestore(&master->queue_lock, flags);
-
-		kfree(master->dummy_rx);
-		master->dummy_rx = NULL;
-		kfree(master->dummy_tx);
-		master->dummy_tx = NULL;
-		if (master->unprepare_transfer_hardware &&
-		    master->unprepare_transfer_hardware(master))
-			dev_err(&master->dev,
+		ctlr->busy = false;
+		ctlr->idling = true;
+		spin_unlock_irqrestore(&ctlr->queue_lock, flags);
+
+		kfree(ctlr->dummy_rx);
+		ctlr->dummy_rx = NULL;
+		kfree(ctlr->dummy_tx);
+		ctlr->dummy_tx = NULL;
+		if (ctlr->unprepare_transfer_hardware &&
+		    ctlr->unprepare_transfer_hardware(ctlr))
+			dev_err(&ctlr->dev,
 				"failed to unprepare transfer hardware\n");
-		if (master->auto_runtime_pm) {
-			pm_runtime_mark_last_busy(master->dev.parent);
-			pm_runtime_put_autosuspend(master->dev.parent);
+		if (ctlr->auto_runtime_pm) {
+			pm_runtime_mark_last_busy(ctlr->dev.parent);
+			pm_runtime_put_autosuspend(ctlr->dev.parent);
 		}
-		trace_spi_master_idle(master);
+		trace_spi_controller_idle(ctlr);
 
-		spin_lock_irqsave(&master->queue_lock, flags);
-		master->idling = false;
-		spin_unlock_irqrestore(&master->queue_lock, flags);
+		spin_lock_irqsave(&ctlr->queue_lock, flags);
+		ctlr->idling = false;
+		spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 		return;
 	}
 
 	/* Extract head of queue */
-	master->cur_msg =
-		list_first_entry(&master->queue, struct spi_message, queue);
+	ctlr->cur_msg =
+		list_first_entry(&ctlr->queue, struct spi_message, queue);
 
-	list_del_init(&master->cur_msg->queue);
-	if (master->busy)
+	list_del_init(&ctlr->cur_msg->queue);
+	if (ctlr->busy)
 		was_busy = true;
 	else
-		master->busy = true;
-	spin_unlock_irqrestore(&master->queue_lock, flags);
+		ctlr->busy = true;
+	spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 
-	mutex_lock(&master->io_mutex);
+	mutex_lock(&ctlr->io_mutex);
 
-	if (!was_busy && master->auto_runtime_pm) {
-		ret = pm_runtime_get_sync(master->dev.parent);
+	if (!was_busy && ctlr->auto_runtime_pm) {
+		ret = pm_runtime_get_sync(ctlr->dev.parent);
 		if (ret < 0) {
-			dev_err(&master->dev, "Failed to power device: %d\n",
+			dev_err(&ctlr->dev, "Failed to power device: %d\n",
 				ret);
-			mutex_unlock(&master->io_mutex);
+			mutex_unlock(&ctlr->io_mutex);
 			return;
 		}
 	}
 
 	if (!was_busy)
-		trace_spi_master_busy(master);
+		trace_spi_controller_busy(ctlr);
 
-	if (!was_busy && master->prepare_transfer_hardware) {
-		ret = master->prepare_transfer_hardware(master);
+	if (!was_busy && ctlr->prepare_transfer_hardware) {
+		ret = ctlr->prepare_transfer_hardware(ctlr);
 		if (ret) {
-			dev_err(&master->dev,
+			dev_err(&ctlr->dev,
 				"failed to prepare transfer hardware\n");
 
-			if (master->auto_runtime_pm)
-				pm_runtime_put(master->dev.parent);
-			mutex_unlock(&master->io_mutex);
+			if (ctlr->auto_runtime_pm)
+				pm_runtime_put(ctlr->dev.parent);
+			mutex_unlock(&ctlr->io_mutex);
 			return;
 		}
 	}
 
-	trace_spi_message_start(master->cur_msg);
+	trace_spi_message_start(ctlr->cur_msg);
 
-	if (master->prepare_message) {
-		ret = master->prepare_message(master, master->cur_msg);
+	if (ctlr->prepare_message) {
+		ret = ctlr->prepare_message(ctlr, ctlr->cur_msg);
 		if (ret) {
-			dev_err(&master->dev,
-				"failed to prepare message: %d\n", ret);
-			master->cur_msg->status = ret;
-			spi_finalize_current_message(master);
+			dev_err(&ctlr->dev, "failed to prepare message: %d\n",
+				ret);
+			ctlr->cur_msg->status = ret;
+			spi_finalize_current_message(ctlr);
 			goto out;
 		}
-		master->cur_msg_prepared = true;
+		ctlr->cur_msg_prepared = true;
 	}
 
-	ret = spi_map_msg(master, master->cur_msg);
+	ret = spi_map_msg(ctlr, ctlr->cur_msg);
 	if (ret) {
-		master->cur_msg->status = ret;
-		spi_finalize_current_message(master);
+		ctlr->cur_msg->status = ret;
+		spi_finalize_current_message(ctlr);
 		goto out;
 	}
 
-	ret = master->transfer_one_message(master, master->cur_msg);
+	ret = ctlr->transfer_one_message(ctlr, ctlr->cur_msg);
 	if (ret) {
-		dev_err(&master->dev,
+		dev_err(&ctlr->dev,
 			"failed to transfer one message from queue\n");
 		goto out;
 	}
 
 out:
-	mutex_unlock(&master->io_mutex);
+	mutex_unlock(&ctlr->io_mutex);
 
 	/* Prod the scheduler in case transfer_one() was busy waiting */
 	if (!ret)
@@ -1274,44 +1273,43 @@ static void __spi_pump_messages(struct spi_master *master, bool in_kthread)
 
 /**
  * spi_pump_messages - kthread work function which processes spi message queue
- * @work: pointer to kthread work struct contained in the master struct
+ * @work: pointer to kthread work struct contained in the controller struct
  */
 static void spi_pump_messages(struct kthread_work *work)
 {
-	struct spi_master *master =
-		container_of(work, struct spi_master, pump_messages);
+	struct spi_controller *ctlr =
+		container_of(work, struct spi_controller, pump_messages);
 
-	__spi_pump_messages(master, true);
+	__spi_pump_messages(ctlr, true);
 }
 
-static int spi_init_queue(struct spi_master *master)
+static int spi_init_queue(struct spi_controller *ctlr)
 {
 	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
 
-	master->running = false;
-	master->busy = false;
+	ctlr->running = false;
+	ctlr->busy = false;
 
-	kthread_init_worker(&master->kworker);
-	master->kworker_task = kthread_run(kthread_worker_fn,
-					   &master->kworker, "%s",
-					   dev_name(&master->dev));
-	if (IS_ERR(master->kworker_task)) {
-		dev_err(&master->dev, "failed to create message pump task\n");
-		return PTR_ERR(master->kworker_task);
+	kthread_init_worker(&ctlr->kworker);
+	ctlr->kworker_task = kthread_run(kthread_worker_fn, &ctlr->kworker,
+					 "%s", dev_name(&ctlr->dev));
+	if (IS_ERR(ctlr->kworker_task)) {
+		dev_err(&ctlr->dev, "failed to create message pump task\n");
+		return PTR_ERR(ctlr->kworker_task);
 	}
-	kthread_init_work(&master->pump_messages, spi_pump_messages);
+	kthread_init_work(&ctlr->pump_messages, spi_pump_messages);
 
 	/*
-	 * Master config will indicate if this controller should run the
+	 * Controller config will indicate if this controller should run the
 	 * message pump with high (realtime) priority to reduce the transfer
 	 * latency on the bus by minimising the delay between a transfer
 	 * request and the scheduling of the message pump thread. Without this
 	 * setting the message pump thread will remain at default priority.
 	 */
-	if (master->rt) {
-		dev_info(&master->dev,
+	if (ctlr->rt) {
+		dev_info(&ctlr->dev,
 			"will run message pump with realtime priority\n");
-		sched_setscheduler(master->kworker_task, SCHED_FIFO, &param);
+		sched_setscheduler(ctlr->kworker_task, SCHED_FIFO, &param);
 	}
 
 	return 0;
@@ -1320,23 +1318,23 @@ static int spi_init_queue(struct spi_master *master)
 /**
  * spi_get_next_queued_message() - called by driver to check for queued
  * messages
- * @master: the master to check for queued messages
+ * @ctlr: the controller to check for queued messages
  *
  * If there are more messages in the queue, the next message is returned from
  * this call.
  *
  * Return: the next message in the queue, else NULL if the queue is empty.
  */
-struct spi_message *spi_get_next_queued_message(struct spi_master *master)
+struct spi_message *spi_get_next_queued_message(struct spi_controller *ctlr)
 {
 	struct spi_message *next;
 	unsigned long flags;
 
 	/* get a pointer to the next message, if any */
-	spin_lock_irqsave(&master->queue_lock, flags);
-	next = list_first_entry_or_null(&master->queue, struct spi_message,
+	spin_lock_irqsave(&ctlr->queue_lock, flags);
+	next = list_first_entry_or_null(&ctlr->queue, struct spi_message,
 					queue);
-	spin_unlock_irqrestore(&master->queue_lock, flags);
+	spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 
 	return next;
 }
@@ -1344,36 +1342,36 @@ EXPORT_SYMBOL_GPL(spi_get_next_queued_message);
 
 /**
  * spi_finalize_current_message() - the current message is complete
- * @master: the master to return the message to
+ * @ctlr: the controller to return the message to
  *
  * Called by the driver to notify the core that the message in the front of the
  * queue is complete and can be removed from the queue.
  */
-void spi_finalize_current_message(struct spi_master *master)
+void spi_finalize_current_message(struct spi_controller *ctlr)
 {
 	struct spi_message *mesg;
 	unsigned long flags;
 	int ret;
 
-	spin_lock_irqsave(&master->queue_lock, flags);
-	mesg = master->cur_msg;
-	spin_unlock_irqrestore(&master->queue_lock, flags);
+	spin_lock_irqsave(&ctlr->queue_lock, flags);
+	mesg = ctlr->cur_msg;
+	spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 
-	spi_unmap_msg(master, mesg);
+	spi_unmap_msg(ctlr, mesg);
 
-	if (master->cur_msg_prepared && master->unprepare_message) {
-		ret = master->unprepare_message(master, mesg);
+	if (ctlr->cur_msg_prepared && ctlr->unprepare_message) {
+		ret = ctlr->unprepare_message(ctlr, mesg);
 		if (ret) {
-			dev_err(&master->dev,
-				"failed to unprepare message: %d\n", ret);
+			dev_err(&ctlr->dev, "failed to unprepare message: %d\n",
+				ret);
 		}
 	}
 
-	spin_lock_irqsave(&master->queue_lock, flags);
-	master->cur_msg = NULL;
-	master->cur_msg_prepared = false;
-	kthread_queue_work(&master->kworker, &master->pump_messages);
-	spin_unlock_irqrestore(&master->queue_lock, flags);
+	spin_lock_irqsave(&ctlr->queue_lock, flags);
+	ctlr->cur_msg = NULL;
+	ctlr->cur_msg_prepared = false;
+	kthread_queue_work(&ctlr->kworker, &ctlr->pump_messages);
+	spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 
 	trace_spi_message_done(mesg);
 
@@ -1383,66 +1381,65 @@ void spi_finalize_current_message(struct spi_master *master)
 }
 EXPORT_SYMBOL_GPL(spi_finalize_current_message);
 
-static int spi_start_queue(struct spi_master *master)
+static int spi_start_queue(struct spi_controller *ctlr)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&master->queue_lock, flags);
+	spin_lock_irqsave(&ctlr->queue_lock, flags);
 
-	if (master->running || master->busy) {
-		spin_unlock_irqrestore(&master->queue_lock, flags);
+	if (ctlr->running || ctlr->busy) {
+		spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 		return -EBUSY;
 	}
 
-	master->running = true;
-	master->cur_msg = NULL;
-	spin_unlock_irqrestore(&master->queue_lock, flags);
+	ctlr->running = true;
+	ctlr->cur_msg = NULL;
+	spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 
-	kthread_queue_work(&master->kworker, &master->pump_messages);
+	kthread_queue_work(&ctlr->kworker, &ctlr->pump_messages);
 
 	return 0;
 }
 
-static int spi_stop_queue(struct spi_master *master)
+static int spi_stop_queue(struct spi_controller *ctlr)
 {
 	unsigned long flags;
 	unsigned limit = 500;
 	int ret = 0;
 
-	spin_lock_irqsave(&master->queue_lock, flags);
+	spin_lock_irqsave(&ctlr->queue_lock, flags);
 
 	/*
 	 * This is a bit lame, but is optimized for the common execution path.
-	 * A wait_queue on the master->busy could be used, but then the common
+	 * A wait_queue on the ctlr->busy could be used, but then the common
 	 * execution path (pump_messages) would be required to call wake_up or
 	 * friends on every SPI message. Do this instead.
 	 */
-	while ((!list_empty(&master->queue) || master->busy) && limit--) {
-		spin_unlock_irqrestore(&master->queue_lock, flags);
+	while ((!list_empty(&ctlr->queue) || ctlr->busy) && limit--) {
+		spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 		usleep_range(10000, 11000);
-		spin_lock_irqsave(&master->queue_lock, flags);
+		spin_lock_irqsave(&ctlr->queue_lock, flags);
 	}
 
-	if (!list_empty(&master->queue) || master->busy)
+	if (!list_empty(&ctlr->queue) || ctlr->busy)
 		ret = -EBUSY;
 	else
-		master->running = false;
+		ctlr->running = false;
 
-	spin_unlock_irqrestore(&master->queue_lock, flags);
+	spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 
 	if (ret) {
-		dev_warn(&master->dev,
-			 "could not stop message queue\n");
+		dev_warn(&ctlr->dev, "could not stop message queue\n");
 		return ret;
 	}
 	return ret;
 }
 
-static int spi_destroy_queue(struct spi_master *master)
+static int spi_destroy_queue(struct spi_controller *ctlr)
 {
 	int ret;
 
-	ret = spi_stop_queue(master);
+	ret = spi_stop_queue(ctlr);
 
 	/*
 	 * kthread_flush_worker will block until all work is done.
@@ -1451,12 +1448,12 @@ static int spi_destroy_queue(struct spi_master *master)
 	 * return anyway.
 	 */
 	if (ret) {
-		dev_err(&master->dev, "problem destroying queue\n");
+		dev_err(&ctlr->dev, "problem destroying queue\n");
 		return ret;
 	}
 
-	kthread_flush_worker(&master->kworker);
-	kthread_stop(master->kworker_task);
+	kthread_flush_worker(&ctlr->kworker);
+	kthread_stop(ctlr->kworker_task);
 
 	return 0;
 }
@@ -1465,23 +1462,23 @@ static int __spi_queued_transfer(struct spi_device *spi,
 				 struct spi_message *msg,
 				 bool need_pump)
 {
-	struct spi_master *master = spi->master;
+	struct spi_controller *ctlr = spi->controller;
 	unsigned long flags;
 
-	spin_lock_irqsave(&master->queue_lock, flags);
+	spin_lock_irqsave(&ctlr->queue_lock, flags);
 
-	if (!master->running) {
-		spin_unlock_irqrestore(&master->queue_lock, flags);
+	if (!ctlr->running) {
+		spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 		return -ESHUTDOWN;
 	}
 	msg->actual_length = 0;
 	msg->status = -EINPROGRESS;
 
-	list_add_tail(&msg->queue, &master->queue);
-	if (!master->busy && need_pump)
-		kthread_queue_work(&master->kworker, &master->pump_messages);
+	list_add_tail(&msg->queue, &ctlr->queue);
+	if (!ctlr->busy && need_pump)
+		kthread_queue_work(&ctlr->kworker, &ctlr->pump_messages);
 
-	spin_unlock_irqrestore(&master->queue_lock, flags);
+	spin_unlock_irqrestore(&ctlr->queue_lock, flags);
 	return 0;
 }
 
@@ -1497,31 +1494,31 @@ static int spi_queued_transfer(struct spi_device *spi, struct spi_message *msg)
 	return __spi_queued_transfer(spi, msg, true);
 }
 
-static int spi_master_initialize_queue(struct spi_master *master)
+static int spi_controller_initialize_queue(struct spi_controller *ctlr)
 {
 	int ret;
 
-	master->transfer = spi_queued_transfer;
-	if (!master->transfer_one_message)
-		master->transfer_one_message = spi_transfer_one_message;
+	ctlr->transfer = spi_queued_transfer;
+	if (!ctlr->transfer_one_message)
+		ctlr->transfer_one_message = spi_transfer_one_message;
 
 	/* Initialize and start queue */
-	ret = spi_init_queue(master);
+	ret = spi_init_queue(ctlr);
 	if (ret) {
-		dev_err(&master->dev, "problem initializing queue\n");
+		dev_err(&ctlr->dev, "problem initializing queue\n");
 		goto err_init_queue;
 	}
-	master->queued = true;
-	ret = spi_start_queue(master);
+	ctlr->queued = true;
+	ret = spi_start_queue(ctlr);
 	if (ret) {
-		dev_err(&master->dev, "problem starting queue\n");
+		dev_err(&ctlr->dev, "problem starting queue\n");
 		goto err_start_queue;
 	}
 
 	return 0;
 
 err_start_queue:
-	spi_destroy_queue(master);
+	spi_destroy_queue(ctlr);
 err_init_queue:
 	return ret;
 }
@@ -1529,7 +1526,7 @@ static int spi_master_initialize_queue(struct spi_master *master)
 /*-------------------------------------------------------------------------*/
 
 #if defined(CONFIG_OF)
-static int of_spi_parse_dt(struct spi_master *master, struct spi_device *spi,
+static int of_spi_parse_dt(struct spi_controller *ctlr, struct spi_device *spi,
 			   struct device_node *nc)
 {
 	u32 value;
@@ -1559,7 +1556,7 @@ static int of_spi_parse_dt(struct spi_master *master, struct spi_device *spi,
 			spi->mode |= SPI_TX_QUAD;
 			break;
 		default:
-			dev_warn(&master->dev,
+			dev_warn(&ctlr->dev,
 				"spi-tx-bus-width %d not supported\n",
 				value);
 			break;
@@ -1577,16 +1574,16 @@ static int of_spi_parse_dt(struct spi_master *master, struct spi_device *spi,
 			spi->mode |= SPI_RX_QUAD;
 			break;
 		default:
-			dev_warn(&master->dev,
+			dev_warn(&ctlr->dev,
 				"spi-rx-bus-width %d not supported\n",
 				value);
 			break;
 		}
 	}
 
-	if (spi_controller_is_slave(master)) {
+	if (spi_controller_is_slave(ctlr)) {
 		if (strcmp(nc->name, "slave")) {
-			dev_err(&master->dev, "%s is not called 'slave'\n",
+			dev_err(&ctlr->dev, "%s is not called 'slave'\n",
 				nc->full_name);
 			return -EINVAL;
 		}
@@ -1596,7 +1593,7 @@ static int of_spi_parse_dt(struct spi_master *master, struct spi_device *spi,
 	/* Device address */
 	rc = of_property_read_u32(nc, "reg", &value);
 	if (rc) {
-		dev_err(&master->dev, "%s has no valid 'reg' property (%d)\n",
+		dev_err(&ctlr->dev, "%s has no valid 'reg' property (%d)\n",
 			nc->full_name, rc);
 		return rc;
 	}
@@ -1605,7 +1602,8 @@ static int of_spi_parse_dt(struct spi_master *master, struct spi_device *spi,
 	/* Device speed */
 	rc = of_property_read_u32(nc, "spi-max-frequency", &value);
 	if (rc) {
-		dev_err(&master->dev, "%s has no valid 'spi-max-frequency' property (%d)\n",
+		dev_err(&ctlr->dev,
+			"%s has no valid 'spi-max-frequency' property (%d)\n",
 			nc->full_name, rc);
 		return rc;
 	}
@@ -1615,15 +1613,15 @@ static int of_spi_parse_dt(struct spi_master *master, struct spi_device *spi,
 }
 
 static struct spi_device *
-of_register_spi_device(struct spi_master *master, struct device_node *nc)
+of_register_spi_device(struct spi_controller *ctlr, struct device_node *nc)
 {
 	struct spi_device *spi;
 	int rc;
 
 	/* Alloc an spi_device */
-	spi = spi_alloc_device(master);
+	spi = spi_alloc_device(ctlr);
 	if (!spi) {
-		dev_err(&master->dev, "spi_device alloc error for %s\n",
+		dev_err(&ctlr->dev, "spi_device alloc error for %s\n",
 			nc->full_name);
 		rc = -ENOMEM;
 		goto err_out;
@@ -1633,12 +1631,12 @@ of_register_spi_device(struct spi_master *master, struct device_node *nc)
 	rc = of_modalias_node(nc, spi->modalias,
 				sizeof(spi->modalias));
 	if (rc < 0) {
-		dev_err(&master->dev, "cannot find modalias for %s\n",
+		dev_err(&ctlr->dev, "cannot find modalias for %s\n",
 			nc->full_name);
 		goto err_out;
 	}
 
-	rc = of_spi_parse_dt(master, spi, nc);
+	rc = of_spi_parse_dt(ctlr, spi, nc);
 	if (rc)
 		goto err_out;
 
@@ -1649,7 +1647,7 @@ of_register_spi_device(struct spi_master *master, struct device_node *nc)
 	/* Register the new device */
 	rc = spi_add_device(spi);
 	if (rc) {
-		dev_err(&master->dev, "spi_device register error %s\n",
+		dev_err(&ctlr->dev, "spi_device register error %s\n",
 			nc->full_name);
 		goto err_of_node_put;
 	}
@@ -1665,39 +1663,40 @@ of_register_spi_device(struct spi_master *master, struct device_node *nc)
 
 /**
  * of_register_spi_devices() - Register child devices onto the SPI bus
- * @master:	Pointer to spi_master device
+ * @ctlr:	Pointer to spi_controller device
  *
  * Registers an spi_device for each child node of controller node which
  * represents a valid SPI slave.
  */
-static void of_register_spi_devices(struct spi_master *master)
+static void of_register_spi_devices(struct spi_controller *ctlr)
 {
 	struct spi_device *spi;
 	struct device_node *nc;
 
-	if (!master->dev.of_node)
+	if (!ctlr->dev.of_node)
 		return;
 
-	for_each_available_child_of_node(master->dev.of_node, nc) {
+	for_each_available_child_of_node(ctlr->dev.of_node, nc) {
 		if (of_node_test_and_set_flag(nc, OF_POPULATED))
 			continue;
-		spi = of_register_spi_device(master, nc);
+		spi = of_register_spi_device(ctlr, nc);
 		if (IS_ERR(spi)) {
-			dev_warn(&master->dev, "Failed to create SPI device for %s\n",
-				nc->full_name);
+			dev_warn(&ctlr->dev,
+				 "Failed to create SPI device for %s\n",
+				 nc->full_name);
 			of_node_clear_flag(nc, OF_POPULATED);
 		}
 	}
 }
 #else
-static void of_register_spi_devices(struct spi_master *master) { }
+static void of_register_spi_devices(struct spi_controller *ctlr) { }
 #endif
 
 #ifdef CONFIG_ACPI
 static int acpi_spi_add_resource(struct acpi_resource *ares, void *data)
 {
 	struct spi_device *spi = data;
-	struct spi_master *master = spi->master;
+	struct spi_controller *ctlr = spi->controller;
 
 	if (ares->type == ACPI_RESOURCE_TYPE_SERIAL_BUS) {
 		struct acpi_resource_spi_serialbus *sb;
@@ -1711,8 +1710,8 @@ static int acpi_spi_add_resource(struct acpi_resource *ares, void *data)
 			 * 0 .. max - 1 so we need to ask the driver to
 			 * translate between the two schemes.
 			 */
-			if (master->fw_translate_cs) {
-				int cs = master->fw_translate_cs(master,
+			if (ctlr->fw_translate_cs) {
+				int cs = ctlr->fw_translate_cs(ctlr,
 						sb->device_selection);
 				if (cs < 0)
 					return cs;
@@ -1741,7 +1740,7 @@ static int acpi_spi_add_resource(struct acpi_resource *ares, void *data)
 	return 1;
 }
 
-static acpi_status acpi_register_spi_device(struct spi_master *master,
+static acpi_status acpi_register_spi_device(struct spi_controller *ctlr,
 					    struct acpi_device *adev)
 {
 	struct list_head resource_list;
@@ -1752,9 +1751,9 @@ static acpi_status acpi_register_spi_device(struct spi_master *master,
 	    acpi_device_enumerated(adev))
 		return AE_OK;
 
-	spi = spi_alloc_device(master);
+	spi = spi_alloc_device(ctlr);
 	if (!spi) {
-		dev_err(&master->dev, "failed to allocate SPI device for %s\n",
+		dev_err(&ctlr->dev, "failed to allocate SPI device for %s\n",
 			dev_name(&adev->dev));
 		return AE_NO_MEMORY;
 	}
@@ -1783,7 +1782,7 @@ static acpi_status acpi_register_spi_device(struct spi_master *master,
 	adev->power.flags.ignore_parent = true;
 	if (spi_add_device(spi)) {
 		adev->power.flags.ignore_parent = false;
-		dev_err(&master->dev, "failed to add SPI device %s from ACPI\n",
+		dev_err(&ctlr->dev, "failed to add SPI device %s from ACPI\n",
 			dev_name(&adev->dev));
 		spi_dev_put(spi);
 	}
@@ -1794,46 +1793,45 @@ static acpi_status acpi_register_spi_device(struct spi_master *master,
 static acpi_status acpi_spi_add_device(acpi_handle handle, u32 level,
 				       void *data, void **return_value)
 {
-	struct spi_master *master = data;
+	struct spi_controller *ctlr = data;
 	struct acpi_device *adev;
 
 	if (acpi_bus_get_device(handle, &adev))
 		return AE_OK;
 
-	return acpi_register_spi_device(master, adev);
+	return acpi_register_spi_device(ctlr, adev);
 }
 
-static void acpi_register_spi_devices(struct spi_master *master)
+static void acpi_register_spi_devices(struct spi_controller *ctlr)
 {
 	acpi_status status;
 	acpi_handle handle;
 
-	handle = ACPI_HANDLE(master->dev.parent);
+	handle = ACPI_HANDLE(ctlr->dev.parent);
 	if (!handle)
 		return;
 
 	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,
-				     acpi_spi_add_device, NULL,
-				     master, NULL);
+				     acpi_spi_add_device, NULL, ctlr, NULL);
 	if (ACPI_FAILURE(status))
-		dev_warn(&master->dev, "failed to enumerate SPI slaves\n");
+		dev_warn(&ctlr->dev, "failed to enumerate SPI slaves\n");
 }
 #else
-static inline void acpi_register_spi_devices(struct spi_master *master) {}
+static inline void acpi_register_spi_devices(struct spi_controller *ctlr) {}
 #endif /* CONFIG_ACPI */
 
-static void spi_master_release(struct device *dev)
+static void spi_controller_release(struct device *dev)
 {
-	struct spi_master *master;
+	struct spi_controller *ctlr;
 
-	master = container_of(dev, struct spi_master, dev);
-	kfree(master);
+	ctlr = container_of(dev, struct spi_controller, dev);
+	kfree(ctlr);
 }
 
 static struct class spi_master_class = {
 	.name		= "spi_master",
 	.owner		= THIS_MODULE,
-	.dev_release	= spi_master_release,
+	.dev_release	= spi_controller_release,
 	.dev_groups	= spi_master_groups,
 };
 
@@ -1845,10 +1843,10 @@ static struct class spi_master_class = {
  */
 int spi_slave_abort(struct spi_device *spi)
 {
-	struct spi_master *master = spi->master;
+	struct spi_controller *ctlr = spi->controller;
 
-	if (spi_controller_is_slave(master) && master->slave_abort)
-		return master->slave_abort(master);
+	if (spi_controller_is_slave(ctlr) && ctlr->slave_abort)
+		return ctlr->slave_abort(ctlr);
 
 	return -ENOTSUPP;
 }
@@ -1862,7 +1860,8 @@ static int match_true(struct device *dev, void *data)
 static ssize_t spi_slave_show(struct device *dev,
 			      struct device_attribute *attr, char *buf)
 {
-	struct spi_master *ctlr = container_of(dev, struct spi_master, dev);
+	struct spi_controller *ctlr = container_of(dev, struct spi_controller,
+						   dev);
 	struct device *child;
 
 	child = device_find_child(&ctlr->dev, NULL, match_true);
@@ -1874,7 +1873,8 @@ static ssize_t spi_slave_store(struct device *dev,
 			       struct device_attribute *attr, const char *buf,
 			       size_t count)
 {
-	struct spi_master *ctlr = container_of(dev, struct spi_master, dev);
+	struct spi_controller *ctlr = container_of(dev, struct spi_controller,
+						   dev);
 	struct spi_device *spi;
 	struct device *child;
 	char name[32];
@@ -1921,7 +1921,7 @@ static const struct attribute_group spi_slave_group = {
 };
 
 static const struct attribute_group *spi_slave_groups[] = {
-	&spi_master_statistics_group,
+	&spi_controller_statistics_group,
 	&spi_slave_group,
 	NULL,
 };
@@ -1929,7 +1929,7 @@ static const struct attribute_group *spi_slave_groups[] = {
 static struct class spi_slave_class = {
 	.name		= "spi_slave",
 	.owner		= THIS_MODULE,
-	.dev_release	= spi_master_release,
+	.dev_release	= spi_controller_release,
 	.dev_groups	= spi_slave_groups,
 };
 #else
@@ -1941,62 +1941,63 @@ extern struct class spi_slave_class;	/* dummy */
  * @dev: the controller, possibly using the platform_bus
  * @size: how much zeroed driver-private data to allocate; the pointer to this
  *	memory is in the driver_data field of the returned device,
- *	accessible with spi_master_get_devdata().
+ *	accessible with spi_controller_get_devdata().
  * @slave: flag indicating whether to allocate an SPI master (false) or SPI
  *	slave (true) controller
  * Context: can sleep
  *
  * This call is used only by SPI controller drivers, which are the
  * only ones directly touching chip registers.  It's how they allocate
- * an spi_master structure, prior to calling spi_register_master().
+ * an spi_controller structure, prior to calling spi_register_controller().
  *
  * This must be called from context that can sleep.
  *
  * The caller is responsible for assigning the bus number and initializing the
- * controller's methods before calling spi_register_master(); and (after errors
- * adding the device) calling spi_master_put() to prevent a memory leak.
+ * controller's methods before calling spi_register_controller(); and (after
+ * errors adding the device) calling spi_controller_put() to prevent a memory
+ * leak.
  *
  * Return: the SPI controller structure on success, else NULL.
  */
-struct spi_master *__spi_alloc_controller(struct device *dev,
-					  unsigned int size, bool slave)
+struct spi_controller *__spi_alloc_controller(struct device *dev,
+					      unsigned int size, bool slave)
 {
-	struct spi_master	*master;
+	struct spi_controller	*ctlr;
 
 	if (!dev)
 		return NULL;
 
-	master = kzalloc(size + sizeof(*master), GFP_KERNEL);
-	if (!master)
+	ctlr = kzalloc(size + sizeof(*ctlr), GFP_KERNEL);
+	if (!ctlr)
 		return NULL;
 
-	device_initialize(&master->dev);
-	master->bus_num = -1;
-	master->num_chipselect = 1;
-	master->slave = slave;
+	device_initialize(&ctlr->dev);
+	ctlr->bus_num = -1;
+	ctlr->num_chipselect = 1;
+	ctlr->slave = slave;
 	if (IS_ENABLED(CONFIG_SPI_SLAVE) && slave)
-		master->dev.class = &spi_slave_class;
+		ctlr->dev.class = &spi_slave_class;
 	else
-		master->dev.class = &spi_master_class;
-	master->dev.parent = dev;
-	pm_suspend_ignore_children(&master->dev, true);
-	spi_master_set_devdata(master, &master[1]);
+		ctlr->dev.class = &spi_master_class;
+	ctlr->dev.parent = dev;
+	pm_suspend_ignore_children(&ctlr->dev, true);
+	spi_controller_set_devdata(ctlr, &ctlr[1]);
 
-	return master;
+	return ctlr;
 }
 EXPORT_SYMBOL_GPL(__spi_alloc_controller);
 
 #ifdef CONFIG_OF
-static int of_spi_register_master(struct spi_master *master)
+static int of_spi_register_master(struct spi_controller *ctlr)
 {
 	int nb, i, *cs;
-	struct device_node *np = master->dev.of_node;
+	struct device_node *np = ctlr->dev.of_node;
 
 	if (!np)
 		return 0;
 
 	nb = of_gpio_named_count(np, "cs-gpios");
-	master->num_chipselect = max_t(int, nb, master->num_chipselect);
+	ctlr->num_chipselect = max_t(int, nb, ctlr->num_chipselect);
 
 	/* Return error only for an incorrectly formed cs-gpios property */
 	if (nb == 0 || nb == -ENOENT)
@@ -2004,15 +2005,14 @@ static int of_spi_register_master(struct spi_master *master)
 	else if (nb < 0)
 		return nb;
 
-	cs = devm_kzalloc(&master->dev,
-			  sizeof(int) * master->num_chipselect,
+	cs = devm_kzalloc(&ctlr->dev, sizeof(int) * ctlr->num_chipselect,
 			  GFP_KERNEL);
-	master->cs_gpios = cs;
+	ctlr->cs_gpios = cs;
 
-	if (!master->cs_gpios)
+	if (!ctlr->cs_gpios)
 		return -ENOMEM;
 
-	for (i = 0; i < master->num_chipselect; i++)
+	for (i = 0; i < ctlr->num_chipselect; i++)
 		cs[i] = -ENOENT;
 
 	for (i = 0; i < nb; i++)
@@ -2021,20 +2021,21 @@ static int of_spi_register_master(struct spi_master *master)
 	return 0;
 }
 #else
-static int of_spi_register_master(struct spi_master *master)
+static int of_spi_register_master(struct spi_controller *ctlr)
 {
 	return 0;
 }
 #endif
 
 /**
- * spi_register_master - register SPI master controller
- * @master: initialized master, originally from spi_alloc_master()
+ * spi_register_controller - register SPI master or slave controller
+ * @ctlr: initialized master, originally from spi_alloc_master() or
+ *	spi_alloc_slave()
  * Context: can sleep
  *
- * SPI master controllers connect to their drivers using some non-SPI bus,
+ * SPI controllers connect to their drivers using some non-SPI bus,
  * such as the platform bus.  The final stage of probe() in that code
- * includes calling spi_register_master() to hook up to this SPI bus glue.
+ * includes calling spi_register_controller() to hook up to this SPI bus glue.
  *
  * SPI controllers use board specific (often SOC specific) bus numbers,
  * and board-specific addressing for SPI devices combines those numbers
@@ -2043,16 +2044,16 @@ static int of_spi_register_master(struct spi_master *master)
  * chip is at which address.
  *
  * This must be called from context that can sleep.  It returns zero on
- * success, else a negative error code (dropping the master's refcount).
+ * success, else a negative error code (dropping the controller's refcount).
  * After a successful return, the caller is responsible for calling
- * spi_unregister_master().
+ * spi_unregister_controller().
  *
  * Return: zero on success, else a negative error code.
  */
-int spi_register_master(struct spi_master *master)
+int spi_register_controller(struct spi_controller *ctlr)
 {
 	static atomic_t		dyn_bus_id = ATOMIC_INIT((1<<15) - 1);
-	struct device		*dev = master->dev.parent;
+	struct device		*dev = ctlr->dev.parent;
 	struct boardinfo	*bi;
 	int			status = -ENODEV;
 	int			dynamic = 0;
@@ -2060,8 +2061,8 @@ int spi_register_master(struct spi_master *master)
 	if (!dev)
 		return -ENODEV;
 
-	if (!spi_controller_is_slave(master)) {
-		status = of_spi_register_master(master);
+	if (!spi_controller_is_slave(ctlr)) {
+		status = of_spi_register_master(ctlr);
 		if (status)
 			return status;
 	}
@@ -2069,97 +2070,100 @@ int spi_register_master(struct spi_master *master)
 	/* even if it's just one always-selected device, there must
 	 * be at least one chipselect
 	 */
-	if (master->num_chipselect == 0)
+	if (ctlr->num_chipselect == 0)
 		return -EINVAL;
 
-	if ((master->bus_num < 0) && master->dev.of_node)
-		master->bus_num = of_alias_get_id(master->dev.of_node, "spi");
+	if ((ctlr->bus_num < 0) && ctlr->dev.of_node)
+		ctlr->bus_num = of_alias_get_id(ctlr->dev.of_node, "spi");
 
 	/* convention:  dynamically assigned bus IDs count down from the max */
-	if (master->bus_num < 0) {
+	if (ctlr->bus_num < 0) {
 		/* FIXME switch to an IDR based scheme, something like
 		 * I2C now uses, so we can't run out of "dynamic" IDs
 		 */
-		master->bus_num = atomic_dec_return(&dyn_bus_id);
+		ctlr->bus_num = atomic_dec_return(&dyn_bus_id);
 		dynamic = 1;
 	}
 
-	INIT_LIST_HEAD(&master->queue);
-	spin_lock_init(&master->queue_lock);
-	spin_lock_init(&master->bus_lock_spinlock);
-	mutex_init(&master->bus_lock_mutex);
-	mutex_init(&master->io_mutex);
-	master->bus_lock_flag = 0;
-	init_completion(&master->xfer_completion);
-	if (!master->max_dma_len)
-		master->max_dma_len = INT_MAX;
+	INIT_LIST_HEAD(&ctlr->queue);
+	spin_lock_init(&ctlr->queue_lock);
+	spin_lock_init(&ctlr->bus_lock_spinlock);
+	mutex_init(&ctlr->bus_lock_mutex);
+	mutex_init(&ctlr->io_mutex);
+	ctlr->bus_lock_flag = 0;
+	init_completion(&ctlr->xfer_completion);
+	if (!ctlr->max_dma_len)
+		ctlr->max_dma_len = INT_MAX;
 
 	/* register the device, then userspace will see it.
 	 * registration fails if the bus ID is in use.
 	 */
-	dev_set_name(&master->dev, "spi%u", master->bus_num);
-	status = device_add(&master->dev);
+	dev_set_name(&ctlr->dev, "spi%u", ctlr->bus_num);
+	status = device_add(&ctlr->dev);
 	if (status < 0)
 		goto done;
 	dev_dbg(dev, "registered %s %s%s\n",
-			spi_controller_is_slave(master) ? "slave" : "master",
-			dev_name(&master->dev), dynamic ? " (dynamic)" : "");
+			spi_controller_is_slave(ctlr) ? "slave" : "master",
+			dev_name(&ctlr->dev), dynamic ? " (dynamic)" : "");
 
 	/* If we're using a queued driver, start the queue */
-	if (master->transfer)
-		dev_info(dev, "master is unqueued, this is deprecated\n");
+	if (ctlr->transfer)
+		dev_info(dev, "controller is unqueued, this is deprecated\n");
 	else {
-		status = spi_master_initialize_queue(master);
+		status = spi_controller_initialize_queue(ctlr);
 		if (status) {
-			device_del(&master->dev);
+			device_del(&ctlr->dev);
 			goto done;
 		}
 	}
 	/* add statistics */
-	spin_lock_init(&master->statistics.lock);
+	spin_lock_init(&ctlr->statistics.lock);
 
 	mutex_lock(&board_lock);
-	list_add_tail(&master->list, &spi_master_list);
+	list_add_tail(&ctlr->list, &spi_controller_list);
 	list_for_each_entry(bi, &board_list, list)
-		spi_match_master_to_boardinfo(master, &bi->board_info);
+		spi_match_controller_to_boardinfo(ctlr, &bi->board_info);
 	mutex_unlock(&board_lock);
 
 	/* Register devices from the device tree and ACPI */
-	of_register_spi_devices(master);
-	acpi_register_spi_devices(master);
+	of_register_spi_devices(ctlr);
+	acpi_register_spi_devices(ctlr);
 done:
 	return status;
 }
-EXPORT_SYMBOL_GPL(spi_register_master);
+EXPORT_SYMBOL_GPL(spi_register_controller);
 
 static void devm_spi_unregister(struct device *dev, void *res)
 {
-	spi_unregister_master(*(struct spi_master **)res);
+	spi_unregister_controller(*(struct spi_controller **)res);
 }
 
 /**
- * devm_spi_register_master - register managed SPI master controller
- * @dev:    device managing SPI master
- * @master: initialized master, originally from spi_alloc_master()
+ * devm_spi_register_controller - register managed SPI master or slave
+ *	controller
+ * @dev:    device managing SPI controller
+ * @ctlr: initialized controller, originally from spi_alloc_master() or
+ *	spi_alloc_slave()
  * Context: can sleep
  *
- * Register a SPI device as with spi_register_master() which will
+ * Register a SPI device as with spi_register_controller() which will
  * automatically be unregister
  *
  * Return: zero on success, else a negative error code.
  */
-int devm_spi_register_master(struct device *dev, struct spi_master *master)
+int devm_spi_register_controller(struct device *dev,
+				 struct spi_controller *ctlr)
 {
-	struct spi_master **ptr;
+	struct spi_controller **ptr;
 	int ret;
 
 	ptr = devres_alloc(devm_spi_unregister, sizeof(*ptr), GFP_KERNEL);
 	if (!ptr)
 		return -ENOMEM;
 
-	ret = spi_register_master(master);
+	ret = spi_register_controller(ctlr);
 	if (!ret) {
-		*ptr = master;
+		*ptr = ctlr;
 		devres_add(dev, ptr);
 	} else {
 		devres_free(ptr);
@@ -2167,7 +2171,7 @@ int devm_spi_register_master(struct device *dev, struct spi_master *master)
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(devm_spi_register_master);
+EXPORT_SYMBOL_GPL(devm_spi_register_controller);
 
 static int __unregister(struct device *dev, void *null)
 {
@@ -2176,71 +2180,71 @@ static int __unregister(struct device *dev, void *null)
 }
 
 /**
- * spi_unregister_master - unregister SPI master controller
- * @master: the master being unregistered
+ * spi_unregister_controller - unregister SPI master or slave controller
+ * @ctlr: the controller being unregistered
  * Context: can sleep
  *
- * This call is used only by SPI master controller drivers, which are the
+ * This call is used only by SPI controller drivers, which are the
  * only ones directly touching chip registers.
  *
  * This must be called from context that can sleep.
  */
-void spi_unregister_master(struct spi_master *master)
+void spi_unregister_controller(struct spi_controller *ctlr)
 {
 	int dummy;
 
-	if (master->queued) {
-		if (spi_destroy_queue(master))
-			dev_err(&master->dev, "queue remove failed\n");
+	if (ctlr->queued) {
+		if (spi_destroy_queue(ctlr))
+			dev_err(&ctlr->dev, "queue remove failed\n");
 	}
 
 	mutex_lock(&board_lock);
-	list_del(&master->list);
+	list_del(&ctlr->list);
 	mutex_unlock(&board_lock);
 
-	dummy = device_for_each_child(&master->dev, NULL, __unregister);
-	device_unregister(&master->dev);
+	dummy = device_for_each_child(&ctlr->dev, NULL, __unregister);
+	device_unregister(&ctlr->dev);
 }
-EXPORT_SYMBOL_GPL(spi_unregister_master);
+EXPORT_SYMBOL_GPL(spi_unregister_controller);
 
-int spi_master_suspend(struct spi_master *master)
+int spi_controller_suspend(struct spi_controller *ctlr)
 {
 	int ret;
 
-	/* Basically no-ops for non-queued masters */
-	if (!master->queued)
+	/* Basically no-ops for non-queued controllers */
+	if (!ctlr->queued)
 		return 0;
 
-	ret = spi_stop_queue(master);
+	ret = spi_stop_queue(ctlr);
 	if (ret)
-		dev_err(&master->dev, "queue stop failed\n");
+		dev_err(&ctlr->dev, "queue stop failed\n");
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(spi_master_suspend);
+EXPORT_SYMBOL_GPL(spi_controller_suspend);
 
-int spi_master_resume(struct spi_master *master)
+int spi_controller_resume(struct spi_controller *ctlr)
 {
 	int ret;
 
-	if (!master->queued)
+	if (!ctlr->queued)
 		return 0;
 
-	ret = spi_start_queue(master);
+	ret = spi_start_queue(ctlr);
 	if (ret)
-		dev_err(&master->dev, "queue restart failed\n");
+		dev_err(&ctlr->dev, "queue restart failed\n");
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(spi_master_resume);
+EXPORT_SYMBOL_GPL(spi_controller_resume);
 
-static int __spi_master_match(struct device *dev, const void *data)
+static int __spi_controller_match(struct device *dev, const void *data)
 {
-	struct spi_master *m;
+	struct spi_controller *ctlr;
 	const u16 *bus_num = data;
 
-	m = container_of(dev, struct spi_master, dev);
-	return m->bus_num == *bus_num;
+	ctlr = container_of(dev, struct spi_controller, dev);
+	return ctlr->bus_num == *bus_num;
 }
 
 /**
@@ -2250,22 +2254,22 @@ static int __spi_master_match(struct device *dev, const void *data)
  *
  * This call may be used with devices that are registered after
  * arch init time.  It returns a refcounted pointer to the relevant
- * spi_master (which the caller must release), or NULL if there is
+ * spi_controller (which the caller must release), or NULL if there is
  * no such master registered.
  *
  * Return: the SPI master structure on success, else NULL.
  */
-struct spi_master *spi_busnum_to_master(u16 bus_num)
+struct spi_controller *spi_busnum_to_master(u16 bus_num)
 {
 	struct device		*dev;
-	struct spi_master	*master = NULL;
+	struct spi_controller	*ctlr = NULL;
 
 	dev = class_find_device(&spi_master_class, NULL, &bus_num,
-				__spi_master_match);
+				__spi_controller_match);
 	if (dev)
-		master = container_of(dev, struct spi_master, dev);
+		ctlr = container_of(dev, struct spi_controller, dev);
 	/* reference got in class_find_device */
-	return master;
+	return ctlr;
 }
 EXPORT_SYMBOL_GPL(spi_busnum_to_master);
 
@@ -2285,7 +2289,7 @@ EXPORT_SYMBOL_GPL(spi_busnum_to_master);
  * Return: the pointer to the allocated data
  *
  * This may get enhanced in the future to allocate from a memory pool
- * of the @spi_device or @spi_master to avoid repeated allocations.
+ * of the @spi_device or @spi_controller to avoid repeated allocations.
  */
 void *spi_res_alloc(struct spi_device *spi,
 		    spi_res_release_t release,
@@ -2337,11 +2341,10 @@ EXPORT_SYMBOL_GPL(spi_res_add);
 
 /**
  * spi_res_release - release all spi resources for this message
- * @master:  the @spi_master
+ * @ctlr:  the @spi_controller
  * @message: the @spi_message
  */
-void spi_res_release(struct spi_master *master,
-		     struct spi_message *message)
+void spi_res_release(struct spi_controller *ctlr, struct spi_message *message)
 {
 	struct spi_res *res;
 
@@ -2350,7 +2353,7 @@ void spi_res_release(struct spi_master *master,
 				      struct spi_res, entry);
 
 		if (res->release)
-			res->release(master, message, res->data);
+			res->release(ctlr, message, res->data);
 
 		list_del(&res->entry);
 
@@ -2363,7 +2366,7 @@ EXPORT_SYMBOL_GPL(spi_res_release);
 
 /* Core methods for spi_message alterations */
 
-static void __spi_replace_transfers_release(struct spi_master *master,
+static void __spi_replace_transfers_release(struct spi_controller *ctlr,
 					    struct spi_message *msg,
 					    void *res)
 {
@@ -2372,7 +2375,7 @@ static void __spi_replace_transfers_release(struct spi_master *master,
 
 	/* call extra callback if requested */
 	if (rxfer->release)
-		rxfer->release(master, msg, res);
+		rxfer->release(ctlr, msg, res);
 
 	/* insert replaced transfers back into the message */
 	list_splice(&rxfer->replaced_transfers, rxfer->replaced_after);
@@ -2492,7 +2495,7 @@ struct spi_replaced_transfers *spi_replace_transfers(
 }
 EXPORT_SYMBOL_GPL(spi_replace_transfers);
 
-static int __spi_split_transfer_maxsize(struct spi_master *master,
+static int __spi_split_transfer_maxsize(struct spi_controller *ctlr,
 					struct spi_message *msg,
 					struct spi_transfer **xferp,
 					size_t maxsize,
@@ -2554,7 +2557,7 @@ static int __spi_split_transfer_maxsize(struct spi_master *master,
 	*xferp = &xfers[count - 1];
 
 	/* increment statistics counters */
-	SPI_STATISTICS_INCREMENT_FIELD(&master->statistics,
+	SPI_STATISTICS_INCREMENT_FIELD(&ctlr->statistics,
 				       transfers_split_maxsize);
 	SPI_STATISTICS_INCREMENT_FIELD(&msg->spi->statistics,
 				       transfers_split_maxsize);
@@ -2566,14 +2569,14 @@ static int __spi_split_transfer_maxsize(struct spi_master *master,
  * spi_split_tranfers_maxsize - split spi transfers into multiple transfers
  *                              when an individual transfer exceeds a
  *                              certain size
- * @master:    the @spi_master for this transfer
+ * @ctlr:    the @spi_controller for this transfer
  * @msg:   the @spi_message to transform
  * @maxsize:  the maximum when to apply this
  * @gfp: GFP allocation flags
  *
  * Return: status of transformation
  */
-int spi_split_transfers_maxsize(struct spi_master *master,
+int spi_split_transfers_maxsize(struct spi_controller *ctlr,
 				struct spi_message *msg,
 				size_t maxsize,
 				gfp_t gfp)
@@ -2589,8 +2592,8 @@ int spi_split_transfers_maxsize(struct spi_master *master,
 	 */
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		if (xfer->len > maxsize) {
-			ret = __spi_split_transfer_maxsize(
-				master, msg, &xfer, maxsize, gfp);
+			ret = __spi_split_transfer_maxsize(ctlr, msg, &xfer,
+							   maxsize, gfp);
 			if (ret)
 				return ret;
 		}
@@ -2602,18 +2605,18 @@ EXPORT_SYMBOL_GPL(spi_split_transfers_maxsize);
 
 /*-------------------------------------------------------------------------*/
 
-/* Core methods for SPI master protocol drivers.  Some of the
+/* Core methods for SPI controller protocol drivers.  Some of the
  * other core methods are currently defined as inline functions.
  */
 
-static int __spi_validate_bits_per_word(struct spi_master *master, u8 bits_per_word)
+static int __spi_validate_bits_per_word(struct spi_controller *ctlr,
+					u8 bits_per_word)
 {
-	if (master->bits_per_word_mask) {
+	if (ctlr->bits_per_word_mask) {
 		/* Only 32 bits fit in the mask */
 		if (bits_per_word > 32)
 			return -EINVAL;
-		if (!(master->bits_per_word_mask &
-				SPI_BPW_MASK(bits_per_word)))
+		if (!(ctlr->bits_per_word_mask & SPI_BPW_MASK(bits_per_word)))
 			return -EINVAL;
 	}
 
@@ -2659,9 +2662,9 @@ int spi_setup(struct spi_device *spi)
 		(SPI_TX_DUAL | SPI_TX_QUAD | SPI_RX_DUAL | SPI_RX_QUAD)))
 		return -EINVAL;
 	/* help drivers fail *cleanly* when they need options
-	 * that aren't supported with their current master
+	 * that aren't supported with their current controller
 	 */
-	bad_bits = spi->mode & ~spi->master->mode_bits;
+	bad_bits = spi->mode & ~spi->controller->mode_bits;
 	ugly_bits = bad_bits &
 		    (SPI_TX_DUAL | SPI_TX_QUAD | SPI_RX_DUAL | SPI_RX_QUAD);
 	if (ugly_bits) {
@@ -2680,15 +2683,16 @@ int spi_setup(struct spi_device *spi)
 	if (!spi->bits_per_word)
 		spi->bits_per_word = 8;
 
-	status = __spi_validate_bits_per_word(spi->master, spi->bits_per_word);
+	status = __spi_validate_bits_per_word(spi->controller,
+					      spi->bits_per_word);
 	if (status)
 		return status;
 
 	if (!spi->max_speed_hz)
-		spi->max_speed_hz = spi->master->max_speed_hz;
+		spi->max_speed_hz = spi->controller->max_speed_hz;
 
-	if (spi->master->setup)
-		status = spi->master->setup(spi);
+	if (spi->controller->setup)
+		status = spi->controller->setup(spi);
 
 	spi_set_cs(spi, false);
 
@@ -2707,7 +2711,7 @@ EXPORT_SYMBOL_GPL(spi_setup);
 
 static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 {
-	struct spi_master *master = spi->master;
+	struct spi_controller *ctlr = spi->controller;
 	struct spi_transfer *xfer;
 	int w_size;
 
@@ -2719,16 +2723,16 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 	 * either MOSI or MISO is missing.  They can also be caused by
 	 * software limitations.
 	 */
-	if ((master->flags & SPI_MASTER_HALF_DUPLEX)
-			|| (spi->mode & SPI_3WIRE)) {
-		unsigned flags = master->flags;
+	if ((ctlr->flags & SPI_CONTROLLER_HALF_DUPLEX) ||
+	    (spi->mode & SPI_3WIRE)) {
+		unsigned flags = ctlr->flags;
 
 		list_for_each_entry(xfer, &message->transfers, transfer_list) {
 			if (xfer->rx_buf && xfer->tx_buf)
 				return -EINVAL;
-			if ((flags & SPI_MASTER_NO_TX) && xfer->tx_buf)
+			if ((flags & SPI_CONTROLLER_NO_TX) && xfer->tx_buf)
 				return -EINVAL;
-			if ((flags & SPI_MASTER_NO_RX) && xfer->rx_buf)
+			if ((flags & SPI_CONTROLLER_NO_RX) && xfer->rx_buf)
 				return -EINVAL;
 		}
 	}
@@ -2748,13 +2752,12 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 		if (!xfer->speed_hz)
 			xfer->speed_hz = spi->max_speed_hz;
 		if (!xfer->speed_hz)
-			xfer->speed_hz = master->max_speed_hz;
+			xfer->speed_hz = ctlr->max_speed_hz;
 
-		if (master->max_speed_hz &&
-		    xfer->speed_hz > master->max_speed_hz)
-			xfer->speed_hz = master->max_speed_hz;
+		if (ctlr->max_speed_hz && xfer->speed_hz > ctlr->max_speed_hz)
+			xfer->speed_hz = ctlr->max_speed_hz;
 
-		if (__spi_validate_bits_per_word(master, xfer->bits_per_word))
+		if (__spi_validate_bits_per_word(ctlr, xfer->bits_per_word))
 			return -EINVAL;
 
 		/*
@@ -2772,8 +2775,8 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 		if (xfer->len % w_size)
 			return -EINVAL;
 
-		if (xfer->speed_hz && master->min_speed_hz &&
-		    xfer->speed_hz < master->min_speed_hz)
+		if (xfer->speed_hz && ctlr->min_speed_hz &&
+		    xfer->speed_hz < ctlr->min_speed_hz)
 			return -EINVAL;
 
 		if (xfer->tx_buf && !xfer->tx_nbits)
@@ -2818,16 +2821,16 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 
 static int __spi_async(struct spi_device *spi, struct spi_message *message)
 {
-	struct spi_master *master = spi->master;
+	struct spi_controller *ctlr = spi->controller;
 
 	message->spi = spi;
 
-	SPI_STATISTICS_INCREMENT_FIELD(&master->statistics, spi_async);
+	SPI_STATISTICS_INCREMENT_FIELD(&ctlr->statistics, spi_async);
 	SPI_STATISTICS_INCREMENT_FIELD(&spi->statistics, spi_async);
 
 	trace_spi_message_submit(message);
 
-	return master->transfer(spi, message);
+	return ctlr->transfer(spi, message);
 }
 
 /**
@@ -2863,7 +2866,7 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
  */
 int spi_async(struct spi_device *spi, struct spi_message *message)
 {
-	struct spi_master *master = spi->master;
+	struct spi_controller *ctlr = spi->controller;
 	int ret;
 	unsigned long flags;
 
@@ -2871,14 +2874,14 @@ int spi_async(struct spi_device *spi, struct spi_message *message)
 	if (ret != 0)
 		return ret;
 
-	spin_lock_irqsave(&master->bus_lock_spinlock, flags);
+	spin_lock_irqsave(&ctlr->bus_lock_spinlock, flags);
 
-	if (master->bus_lock_flag)
+	if (ctlr->bus_lock_flag)
 		ret = -EBUSY;
 	else
 		ret = __spi_async(spi, message);
 
-	spin_unlock_irqrestore(&master->bus_lock_spinlock, flags);
+	spin_unlock_irqrestore(&ctlr->bus_lock_spinlock, flags);
 
 	return ret;
 }
@@ -2917,7 +2920,7 @@ EXPORT_SYMBOL_GPL(spi_async);
  */
 int spi_async_locked(struct spi_device *spi, struct spi_message *message)
 {
-	struct spi_master *master = spi->master;
+	struct spi_controller *ctlr = spi->controller;
 	int ret;
 	unsigned long flags;
 
@@ -2925,11 +2928,11 @@ int spi_async_locked(struct spi_device *spi, struct spi_message *message)
 	if (ret != 0)
 		return ret;
 
-	spin_lock_irqsave(&master->bus_lock_spinlock, flags);
+	spin_lock_irqsave(&ctlr->bus_lock_spinlock, flags);
 
 	ret = __spi_async(spi, message);
 
-	spin_unlock_irqrestore(&master->bus_lock_spinlock, flags);
+	spin_unlock_irqrestore(&ctlr->bus_lock_spinlock, flags);
 
 	return ret;
 
@@ -2941,7 +2944,7 @@ int spi_flash_read(struct spi_device *spi,
 		   struct spi_flash_read_message *msg)
 
 {
-	struct spi_master *master = spi->master;
+	struct spi_controller *master = spi->controller;
 	struct device *rx_dev = NULL;
 	int ret;
 
@@ -2995,7 +2998,7 @@ EXPORT_SYMBOL_GPL(spi_flash_read);
 
 /*-------------------------------------------------------------------------*/
 
-/* Utility methods for SPI master protocol drivers, layered on
+/* Utility methods for SPI protocol drivers, layered on
  * top of the core.  Some other utility methods are defined as
  * inline functions.
  */
@@ -3009,7 +3012,7 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message)
 {
 	DECLARE_COMPLETION_ONSTACK(done);
 	int status;
-	struct spi_master *master = spi->master;
+	struct spi_controller *ctlr = spi->controller;
 	unsigned long flags;
 
 	status = __spi_validate(spi, message);
@@ -3020,7 +3023,7 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message)
 	message->context = &done;
 	message->spi = spi;
 
-	SPI_STATISTICS_INCREMENT_FIELD(&master->statistics, spi_sync);
+	SPI_STATISTICS_INCREMENT_FIELD(&ctlr->statistics, spi_sync);
 	SPI_STATISTICS_INCREMENT_FIELD(&spi->statistics, spi_sync);
 
 	/* If we're not using the legacy transfer method then we will
@@ -3028,14 +3031,14 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message)
 	 * This code would be less tricky if we could remove the
 	 * support for driver implemented message queues.
 	 */
-	if (master->transfer == spi_queued_transfer) {
-		spin_lock_irqsave(&master->bus_lock_spinlock, flags);
+	if (ctlr->transfer == spi_queued_transfer) {
+		spin_lock_irqsave(&ctlr->bus_lock_spinlock, flags);
 
 		trace_spi_message_submit(message);
 
 		status = __spi_queued_transfer(spi, message, false);
 
-		spin_unlock_irqrestore(&master->bus_lock_spinlock, flags);
+		spin_unlock_irqrestore(&ctlr->bus_lock_spinlock, flags);
 	} else {
 		status = spi_async_locked(spi, message);
 	}
@@ -3044,12 +3047,12 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message)
 		/* Push out the messages in the calling context if we
 		 * can.
 		 */
-		if (master->transfer == spi_queued_transfer) {
-			SPI_STATISTICS_INCREMENT_FIELD(&master->statistics,
+		if (ctlr->transfer == spi_queued_transfer) {
+			SPI_STATISTICS_INCREMENT_FIELD(&ctlr->statistics,
 						       spi_sync_immediate);
 			SPI_STATISTICS_INCREMENT_FIELD(&spi->statistics,
 						       spi_sync_immediate);
-			__spi_pump_messages(master, false);
+			__spi_pump_messages(ctlr, false);
 		}
 
 		wait_for_completion(&done);
@@ -3084,9 +3087,9 @@ int spi_sync(struct spi_device *spi, struct spi_message *message)
 {
 	int ret;
 
-	mutex_lock(&spi->master->bus_lock_mutex);
+	mutex_lock(&spi->controller->bus_lock_mutex);
 	ret = __spi_sync(spi, message);
-	mutex_unlock(&spi->master->bus_lock_mutex);
+	mutex_unlock(&spi->controller->bus_lock_mutex);
 
 	return ret;
 }
@@ -3116,7 +3119,7 @@ EXPORT_SYMBOL_GPL(spi_sync_locked);
 
 /**
  * spi_bus_lock - obtain a lock for exclusive SPI bus usage
- * @master: SPI bus master that should be locked for exclusive bus access
+ * @ctlr: SPI bus master that should be locked for exclusive bus access
  * Context: can sleep
  *
  * This call may only be used from a context that may sleep.  The sleep
@@ -3129,15 +3132,15 @@ EXPORT_SYMBOL_GPL(spi_sync_locked);
  *
  * Return: always zero.
  */
-int spi_bus_lock(struct spi_master *master)
+int spi_bus_lock(struct spi_controller *ctlr)
 {
 	unsigned long flags;
 
-	mutex_lock(&master->bus_lock_mutex);
+	mutex_lock(&ctlr->bus_lock_mutex);
 
-	spin_lock_irqsave(&master->bus_lock_spinlock, flags);
-	master->bus_lock_flag = 1;
-	spin_unlock_irqrestore(&master->bus_lock_spinlock, flags);
+	spin_lock_irqsave(&ctlr->bus_lock_spinlock, flags);
+	ctlr->bus_lock_flag = 1;
+	spin_unlock_irqrestore(&ctlr->bus_lock_spinlock, flags);
 
 	/* mutex remains locked until spi_bus_unlock is called */
 
@@ -3147,7 +3150,7 @@ EXPORT_SYMBOL_GPL(spi_bus_lock);
 
 /**
  * spi_bus_unlock - release the lock for exclusive SPI bus usage
- * @master: SPI bus master that was locked for exclusive bus access
+ * @ctlr: SPI bus master that was locked for exclusive bus access
  * Context: can sleep
  *
  * This call may only be used from a context that may sleep.  The sleep
@@ -3158,11 +3161,11 @@ EXPORT_SYMBOL_GPL(spi_bus_lock);
  *
  * Return: always zero.
  */
-int spi_bus_unlock(struct spi_master *master)
+int spi_bus_unlock(struct spi_controller *ctlr)
 {
-	master->bus_lock_flag = 0;
+	ctlr->bus_lock_flag = 0;
 
-	mutex_unlock(&master->bus_lock_mutex);
+	mutex_unlock(&ctlr->bus_lock_mutex);
 
 	return 0;
 }
@@ -3264,48 +3267,48 @@ static struct spi_device *of_find_spi_device_by_node(struct device_node *node)
 	return dev ? to_spi_device(dev) : NULL;
 }
 
-static int __spi_of_master_match(struct device *dev, const void *data)
+static int __spi_of_controller_match(struct device *dev, const void *data)
 {
 	return dev->of_node == data;
 }
 
-/* the spi masters are not using spi_bus, so we find it with another way */
-static struct spi_master *of_find_spi_master_by_node(struct device_node *node)
+/* the spi controllers are not using spi_bus, so we find it with another way */
+static struct spi_controller *of_find_spi_controller_by_node(struct device_node *node)
 {
 	struct device *dev;
 
 	dev = class_find_device(&spi_master_class, NULL, node,
-				__spi_of_master_match);
+				__spi_of_controller_match);
 	if (!dev && IS_ENABLED(CONFIG_SPI_SLAVE))
 		dev = class_find_device(&spi_slave_class, NULL, node,
-					__spi_of_master_match);
+					__spi_of_controller_match);
 	if (!dev)
 		return NULL;
 
 	/* reference got in class_find_device */
-	return container_of(dev, struct spi_master, dev);
+	return container_of(dev, struct spi_controller, dev);
 }
 
 static int of_spi_notify(struct notifier_block *nb, unsigned long action,
 			 void *arg)
 {
 	struct of_reconfig_data *rd = arg;
-	struct spi_master *master;
+	struct spi_controller *ctlr;
 	struct spi_device *spi;
 
 	switch (of_reconfig_get_state_change(action, arg)) {
 	case OF_RECONFIG_CHANGE_ADD:
-		master = of_find_spi_master_by_node(rd->dn->parent);
-		if (master == NULL)
+		ctlr = of_find_spi_controller_by_node(rd->dn->parent);
+		if (ctlr == NULL)
 			return NOTIFY_OK;	/* not for us */
 
 		if (of_node_test_and_set_flag(rd->dn, OF_POPULATED)) {
-			put_device(&master->dev);
+			put_device(&ctlr->dev);
 			return NOTIFY_OK;
 		}
 
-		spi = of_register_spi_device(master, rd->dn);
-		put_device(&master->dev);
+		spi = of_register_spi_device(ctlr, rd->dn);
+		put_device(&ctlr->dev);
 
 		if (IS_ERR(spi)) {
 			pr_err("%s: failed to create for '%s'\n",
@@ -3344,7 +3347,7 @@ extern struct notifier_block spi_of_notifier;
 #endif /* IS_ENABLED(CONFIG_OF_DYNAMIC) */
 
 #if IS_ENABLED(CONFIG_ACPI)
-static int spi_acpi_master_match(struct device *dev, const void *data)
+static int spi_acpi_controller_match(struct device *dev, const void *data)
 {
 	return ACPI_COMPANION(dev->parent) == data;
 }
@@ -3354,19 +3357,19 @@ static int spi_acpi_device_match(struct device *dev, void *data)
 	return ACPI_COMPANION(dev) == data;
 }
 
-static struct spi_master *acpi_spi_find_master_by_adev(struct acpi_device *adev)
+static struct spi_controller *acpi_spi_find_controller_by_adev(struct acpi_device *adev)
 {
 	struct device *dev;
 
 	dev = class_find_device(&spi_master_class, NULL, adev,
-				spi_acpi_master_match);
+				spi_acpi_controller_match);
 	if (!dev && IS_ENABLED(CONFIG_SPI_SLAVE))
 		dev = class_find_device(&spi_slave_class, NULL, adev,
-					spi_acpi_master_match);
+					spi_acpi_controller_match);
 	if (!dev)
 		return NULL;
 
-	return container_of(dev, struct spi_master, dev);
+	return container_of(dev, struct spi_controller, dev);
 }
 
 static struct spi_device *acpi_spi_find_device_by_adev(struct acpi_device *adev)
@@ -3382,17 +3385,17 @@ static int acpi_spi_notify(struct notifier_block *nb, unsigned long value,
 			   void *arg)
 {
 	struct acpi_device *adev = arg;
-	struct spi_master *master;
+	struct spi_controller *ctlr;
 	struct spi_device *spi;
 
 	switch (value) {
 	case ACPI_RECONFIG_DEVICE_ADD:
-		master = acpi_spi_find_master_by_adev(adev->parent);
-		if (!master)
+		ctlr = acpi_spi_find_controller_by_adev(adev->parent);
+		if (!ctlr)
 			break;
 
-		acpi_register_spi_device(master, adev);
-		put_device(&master->dev);
+		acpi_register_spi_device(ctlr, adev);
+		put_device(&ctlr->dev);
 		break;
 	case ACPI_RECONFIG_DEVICE_REMOVE:
 		if (!acpi_device_enumerated(adev))

commit c94085f587a77495eabb78a959bd591bee4ec89b
Merge: ad25c92ecb16 ce70e06c093a b56ffae8998f
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Jun 13 18:51:05 2017 +0100

    Merge branches 'topic/core', 'topic/slave' and 'fix/doc' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi into spi-master

commit 6c364062bfed3c34490e85bea52ff6e2d4f0f281
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon May 22 15:11:41 2017 +0200

    spi: core: Add support for registering SPI slave controllers
    
    Add support for registering SPI slave controllers using the existing SPI
    master framework:
      - SPI slave controllers must use spi_alloc_slave() instead of
        spi_alloc_master(), and should provide an additional callback
        "slave_abort" to abort an ongoing SPI transfer request,
      - SPI slave controllers are added to a new "spi_slave" device class,
      - SPI slave handlers can be bound to the SPI slave device represented
        by an SPI slave controller using a DT child node named "slave",
      - Alternatively, (un)binding an SPI slave handler to the SPI slave
        device represented by an SPI slave controller can be done by
        (un)registering the slave device through a sysfs virtual file named
        "slave".
    
    From the point of view of an SPI slave protocol handler, an SPI slave
    controller looks almost like an ordinary SPI master controller. The only
    exception is that a transfer request will block on the remote SPI
    master, and may be cancelled using spi_slave_abort().
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 89254a55eb2e..6a8280bdc7a8 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1535,15 +1535,6 @@ static int of_spi_parse_dt(struct spi_master *master, struct spi_device *spi,
 	u32 value;
 	int rc;
 
-	/* Device address */
-	rc = of_property_read_u32(nc, "reg", &value);
-	if (rc) {
-		dev_err(&master->dev, "%s has no valid 'reg' property (%d)\n",
-			nc->full_name, rc);
-		return rc;
-	}
-	spi->chip_select = value;
-
 	/* Mode (clock phase/polarity/etc.) */
 	if (of_find_property(nc, "spi-cpha", NULL))
 		spi->mode |= SPI_CPHA;
@@ -1593,6 +1584,24 @@ static int of_spi_parse_dt(struct spi_master *master, struct spi_device *spi,
 		}
 	}
 
+	if (spi_controller_is_slave(master)) {
+		if (strcmp(nc->name, "slave")) {
+			dev_err(&master->dev, "%s is not called 'slave'\n",
+				nc->full_name);
+			return -EINVAL;
+		}
+		return 0;
+	}
+
+	/* Device address */
+	rc = of_property_read_u32(nc, "reg", &value);
+	if (rc) {
+		dev_err(&master->dev, "%s has no valid 'reg' property (%d)\n",
+			nc->full_name, rc);
+		return rc;
+	}
+	spi->chip_select = value;
+
 	/* Device speed */
 	rc = of_property_read_u32(nc, "spi-max-frequency", &value);
 	if (rc) {
@@ -1658,8 +1667,8 @@ of_register_spi_device(struct spi_master *master, struct device_node *nc)
  * of_register_spi_devices() - Register child devices onto the SPI bus
  * @master:	Pointer to spi_master device
  *
- * Registers an spi_device for each child node of master node which has a 'reg'
- * property.
+ * Registers an spi_device for each child node of controller node which
+ * represents a valid SPI slave.
  */
 static void of_register_spi_devices(struct spi_master *master)
 {
@@ -1828,28 +1837,129 @@ static struct class spi_master_class = {
 	.dev_groups	= spi_master_groups,
 };
 
+#ifdef CONFIG_SPI_SLAVE
+/**
+ * spi_slave_abort - abort the ongoing transfer request on an SPI slave
+ *		     controller
+ * @spi: device used for the current transfer
+ */
+int spi_slave_abort(struct spi_device *spi)
+{
+	struct spi_master *master = spi->master;
+
+	if (spi_controller_is_slave(master) && master->slave_abort)
+		return master->slave_abort(master);
+
+	return -ENOTSUPP;
+}
+EXPORT_SYMBOL_GPL(spi_slave_abort);
+
+static int match_true(struct device *dev, void *data)
+{
+	return 1;
+}
+
+static ssize_t spi_slave_show(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	struct spi_master *ctlr = container_of(dev, struct spi_master, dev);
+	struct device *child;
+
+	child = device_find_child(&ctlr->dev, NULL, match_true);
+	return sprintf(buf, "%s\n",
+		       child ? to_spi_device(child)->modalias : NULL);
+}
+
+static ssize_t spi_slave_store(struct device *dev,
+			       struct device_attribute *attr, const char *buf,
+			       size_t count)
+{
+	struct spi_master *ctlr = container_of(dev, struct spi_master, dev);
+	struct spi_device *spi;
+	struct device *child;
+	char name[32];
+	int rc;
+
+	rc = sscanf(buf, "%31s", name);
+	if (rc != 1 || !name[0])
+		return -EINVAL;
+
+	child = device_find_child(&ctlr->dev, NULL, match_true);
+	if (child) {
+		/* Remove registered slave */
+		device_unregister(child);
+		put_device(child);
+	}
+
+	if (strcmp(name, "(null)")) {
+		/* Register new slave */
+		spi = spi_alloc_device(ctlr);
+		if (!spi)
+			return -ENOMEM;
+
+		strlcpy(spi->modalias, name, sizeof(spi->modalias));
+
+		rc = spi_add_device(spi);
+		if (rc) {
+			spi_dev_put(spi);
+			return rc;
+		}
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(slave, 0644, spi_slave_show, spi_slave_store);
+
+static struct attribute *spi_slave_attrs[] = {
+	&dev_attr_slave.attr,
+	NULL,
+};
+
+static const struct attribute_group spi_slave_group = {
+	.attrs = spi_slave_attrs,
+};
+
+static const struct attribute_group *spi_slave_groups[] = {
+	&spi_master_statistics_group,
+	&spi_slave_group,
+	NULL,
+};
+
+static struct class spi_slave_class = {
+	.name		= "spi_slave",
+	.owner		= THIS_MODULE,
+	.dev_release	= spi_master_release,
+	.dev_groups	= spi_slave_groups,
+};
+#else
+extern struct class spi_slave_class;	/* dummy */
+#endif
 
 /**
- * spi_alloc_master - allocate SPI master controller
+ * __spi_alloc_controller - allocate an SPI master or slave controller
  * @dev: the controller, possibly using the platform_bus
  * @size: how much zeroed driver-private data to allocate; the pointer to this
  *	memory is in the driver_data field of the returned device,
  *	accessible with spi_master_get_devdata().
+ * @slave: flag indicating whether to allocate an SPI master (false) or SPI
+ *	slave (true) controller
  * Context: can sleep
  *
- * This call is used only by SPI master controller drivers, which are the
+ * This call is used only by SPI controller drivers, which are the
  * only ones directly touching chip registers.  It's how they allocate
  * an spi_master structure, prior to calling spi_register_master().
  *
  * This must be called from context that can sleep.
  *
- * The caller is responsible for assigning the bus number and initializing
- * the master's methods before calling spi_register_master(); and (after errors
+ * The caller is responsible for assigning the bus number and initializing the
+ * controller's methods before calling spi_register_master(); and (after errors
  * adding the device) calling spi_master_put() to prevent a memory leak.
  *
- * Return: the SPI master structure on success, else NULL.
+ * Return: the SPI controller structure on success, else NULL.
  */
-struct spi_master *spi_alloc_master(struct device *dev, unsigned size)
+struct spi_master *__spi_alloc_controller(struct device *dev,
+					  unsigned int size, bool slave)
 {
 	struct spi_master	*master;
 
@@ -1863,14 +1973,18 @@ struct spi_master *spi_alloc_master(struct device *dev, unsigned size)
 	device_initialize(&master->dev);
 	master->bus_num = -1;
 	master->num_chipselect = 1;
-	master->dev.class = &spi_master_class;
+	master->slave = slave;
+	if (IS_ENABLED(CONFIG_SPI_SLAVE) && slave)
+		master->dev.class = &spi_slave_class;
+	else
+		master->dev.class = &spi_master_class;
 	master->dev.parent = dev;
 	pm_suspend_ignore_children(&master->dev, true);
 	spi_master_set_devdata(master, &master[1]);
 
 	return master;
 }
-EXPORT_SYMBOL_GPL(spi_alloc_master);
+EXPORT_SYMBOL_GPL(__spi_alloc_controller);
 
 #ifdef CONFIG_OF
 static int of_spi_register_master(struct spi_master *master)
@@ -1946,9 +2060,11 @@ int spi_register_master(struct spi_master *master)
 	if (!dev)
 		return -ENODEV;
 
-	status = of_spi_register_master(master);
-	if (status)
-		return status;
+	if (!spi_controller_is_slave(master)) {
+		status = of_spi_register_master(master);
+		if (status)
+			return status;
+	}
 
 	/* even if it's just one always-selected device, there must
 	 * be at least one chipselect
@@ -1985,8 +2101,9 @@ int spi_register_master(struct spi_master *master)
 	status = device_add(&master->dev);
 	if (status < 0)
 		goto done;
-	dev_dbg(dev, "registered master %s%s\n", dev_name(&master->dev),
-			dynamic ? " (dynamic)" : "");
+	dev_dbg(dev, "registered %s %s%s\n",
+			spi_controller_is_slave(master) ? "slave" : "master",
+			dev_name(&master->dev), dynamic ? " (dynamic)" : "");
 
 	/* If we're using a queued driver, start the queue */
 	if (master->transfer)
@@ -3159,6 +3276,9 @@ static struct spi_master *of_find_spi_master_by_node(struct device_node *node)
 
 	dev = class_find_device(&spi_master_class, NULL, node,
 				__spi_of_master_match);
+	if (!dev && IS_ENABLED(CONFIG_SPI_SLAVE))
+		dev = class_find_device(&spi_slave_class, NULL, node,
+					__spi_of_master_match);
 	if (!dev)
 		return NULL;
 
@@ -3240,6 +3360,9 @@ static struct spi_master *acpi_spi_find_master_by_adev(struct acpi_device *adev)
 
 	dev = class_find_device(&spi_master_class, NULL, adev,
 				spi_acpi_master_match);
+	if (!dev && IS_ENABLED(CONFIG_SPI_SLAVE))
+		dev = class_find_device(&spi_slave_class, NULL, adev,
+					spi_acpi_master_match);
 	if (!dev)
 		return NULL;
 
@@ -3312,6 +3435,12 @@ static int __init spi_init(void)
 	if (status < 0)
 		goto err2;
 
+	if (IS_ENABLED(CONFIG_SPI_SLAVE)) {
+		status = class_register(&spi_slave_class);
+		if (status < 0)
+			goto err3;
+	}
+
 	if (IS_ENABLED(CONFIG_OF_DYNAMIC))
 		WARN_ON(of_reconfig_notifier_register(&spi_of_notifier));
 	if (IS_ENABLED(CONFIG_ACPI))
@@ -3319,6 +3448,8 @@ static int __init spi_init(void)
 
 	return 0;
 
+err3:
+	class_unregister(&spi_master_class);
 err2:
 	bus_unregister(&spi_bus_type);
 err1:

commit ad25c92ecb160235668cdeaff26f5907a6fbf6b3
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu May 4 16:29:56 2017 +0200

    spi: core: Replace S_IRUGO permissions by 0444
    
    Octal permissions are preferred over symbolic permissions.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 89254a55eb2e..bd7a546f5d9b 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -80,7 +80,7 @@ static ssize_t spi_master_##field##_show(struct device *dev,		\
 	return spi_statistics_##field##_show(&master->statistics, buf);	\
 }									\
 static struct device_attribute dev_attr_spi_master_##field = {		\
-	.attr = { .name = file, .mode = S_IRUGO },			\
+	.attr = { .name = file, .mode = 0444 },				\
 	.show = spi_master_##field##_show,				\
 };									\
 static ssize_t spi_device_##field##_show(struct device *dev,		\
@@ -91,7 +91,7 @@ static ssize_t spi_device_##field##_show(struct device *dev,		\
 	return spi_statistics_##field##_show(&spi->statistics, buf);	\
 }									\
 static struct device_attribute dev_attr_spi_device_##field = {		\
-	.attr = { .name = file, .mode = S_IRUGO },			\
+	.attr = { .name = file, .mode = 0444 },				\
 	.show = spi_device_##field##_show,				\
 }
 

commit b56ffae8998f7c3fc892f11b32b4dd1975efd993
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu May 4 14:58:28 2017 +0200

    spi: core: Fix devm_spi_register_master() function name in kerneldoc
    
    Fixes: 666d5b4c742ba666 ("spi: core: Add devm_spi_register_master()")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 89254a55eb2e..7bb733d91519 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2021,7 +2021,7 @@ static void devm_spi_unregister(struct device *dev, void *res)
 }
 
 /**
- * dev_spi_register_master - register managed SPI master controller
+ * devm_spi_register_master - register managed SPI master controller
  * @dev:    device managing SPI master
  * @master: initialized master, originally from spi_alloc_master()
  * Context: can sleep

commit 282ec0ea65dab88fda51b5b9b649958ae42f4ac0
Merge: d8f520727f76 c687c46e9e45 251831bd4f49
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Apr 26 15:58:22 2017 +0100

    Merge remote-tracking branches 'spi/topic/ti-qspi' and 'spi/topic/xlp' into spi-next

commit a2d5eda07224680cb711677eff014ea15d809aae
Merge: 2536374352ab f974cf57b1b9 500a32abaf81 fbad6c24396b f72efa7e690a a5b0443c9bf4
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Apr 26 15:58:04 2017 +0100

    Merge remote-tracking branches 'spi/topic/devprop', 'spi/topic/fsl', 'spi/topic/fsl-dspi', 'spi/topic/imx' and 'spi/topic/lantiq' into spi-next

commit 42b1eadf4ead6e7d68f47cd985daa244823c96d3
Merge: fbf3d36cb4c9 833bfade9656
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Apr 26 15:57:58 2017 +0100

    Merge remote-tracking branch 'spi/topic/core' into spi-next

commit 2bca34455b257d75080d87e800ae14afe49001bf
Author: Vignesh R <vigneshr@ti.com>
Date:   Tue Apr 11 17:22:24 2017 +0530

    spi: Add can_dma like interface for spi_flash_read
    
    Add an interface analogous to ->can_dma() for spi_flash_read()
    interface. This will enable SPI controller drivers to inform SPI core
    when not to do DMA mappings.
    
    Signed-off-by: Vignesh R <vigneshr@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 656dd3e3220c..5e1bb43b8a8f 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2811,7 +2811,7 @@ int spi_flash_read(struct spi_device *spi,
 
 	mutex_lock(&master->bus_lock_mutex);
 	mutex_lock(&master->io_mutex);
-	if (master->dma_rx) {
+	if (master->dma_rx && master->spi_flash_can_dma(spi, msg)) {
 		rx_dev = master->dma_rx->device->dev;
 		ret = spi_map_buf(master, rx_dev, &msg->rx_sg,
 				  msg->buf, msg->len,

commit 833bfade96561216aa2129516a5926a0326860a2
Author: Hauke Mehrtens <hauke@hauke-m.de>
Date:   Mon Apr 17 01:38:05 2017 +0200

    spi: double time out tolerance
    
    The generic SPI code calculates how long the issued transfer would take
    and adds 100ms in addition to the timeout as tolerance. On my 500 MHz
    Lantiq Mips SoC I am getting timeouts from the SPI like this when the
    system boots up:
    
    m25p80 spi32766.4: SPI transfer timed out
    blk_update_request: I/O error, dev mtdblock3, sector 2
    SQUASHFS error: squashfs_read_data failed to read block 0x6e
    
    After increasing the tolerance for the timeout to 200ms I haven't seen
    these SPI transfer time outs any more.
    The Lantiq SPI driver in use here has an extra work queue in between,
    which gets triggered when the controller send the last word and the
    hardware FIFOs used for reading and writing are only 8 words long.
    
    Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 656dd3e3220c..0af62c6f93a8 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1012,7 +1012,7 @@ static int spi_transfer_one_message(struct spi_master *master,
 				ret = 0;
 				ms = 8LL * 1000LL * xfer->len;
 				do_div(ms, xfer->speed_hz);
-				ms += ms + 100; /* some tolerance */
+				ms += ms + 200; /* some tolerance */
 
 				if (ms > UINT_MAX)
 					ms = UINT_MAX;

commit f974cf57b1b95839b224b01335c45347f746a365
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Feb 28 14:25:19 2017 -0800

    spi: allow registering empty spi_board_info lists
    
    Many boards form list of spi_board_info entries depending on config,
    and it is possible to end up with empty list. Do not report error
    in such cases.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 6cc86060d22f..f699ea530b88 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -690,7 +690,7 @@ int spi_register_board_info(struct spi_board_info const *info, unsigned n)
 	int i;
 
 	if (!n)
-		return -EINVAL;
+		return 0;
 
 	bi = kcalloc(n, sizeof(*bi), GFP_KERNEL);
 	if (!bi)

commit 826cf175ed705f70a49d04aca832c1cc9ff048d8
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Feb 28 14:25:18 2017 -0800

    spi: allow attaching device properties to SPI board info
    
    Generic device properties support statically defined property sets. For
    them to be usable, we need to attach these property sets before devices
    are registered and probed. Allowing to attach property list to
    spi_board_info structure will allow non-ACPI non-DT boards switch to using
    generic properties and get rid of custom platform data.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 90b5b2efafbf..6cc86060d22f 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -31,6 +31,7 @@
 #include <linux/of_gpio.h>
 #include <linux/pm_runtime.h>
 #include <linux/pm_domain.h>
+#include <linux/property.h>
 #include <linux/export.h>
 #include <linux/sched/rt.h>
 #include <uapi/linux/sched/types.h>
@@ -600,13 +601,28 @@ struct spi_device *spi_new_device(struct spi_master *master,
 	proxy->controller_data = chip->controller_data;
 	proxy->controller_state = NULL;
 
-	status = spi_add_device(proxy);
-	if (status < 0) {
-		spi_dev_put(proxy);
-		return NULL;
+	if (chip->properties) {
+		status = device_add_properties(&proxy->dev, chip->properties);
+		if (status) {
+			dev_err(&master->dev,
+				"failed to add properties to '%s': %d\n",
+				chip->modalias, status);
+			goto err_dev_put;
+		}
 	}
 
+	status = spi_add_device(proxy);
+	if (status < 0)
+		goto err_remove_props;
+
 	return proxy;
+
+err_remove_props:
+	if (chip->properties)
+		device_remove_properties(&proxy->dev);
+err_dev_put:
+	spi_dev_put(proxy);
+	return NULL;
 }
 EXPORT_SYMBOL_GPL(spi_new_device);
 
@@ -664,6 +680,7 @@ static void spi_match_master_to_boardinfo(struct spi_master *master,
  *
  * The board info passed can safely be __initdata ... but be careful of
  * any embedded pointers (platform_data, etc), they're copied as-is.
+ * Device properties are deep-copied though.
  *
  * Return: zero on success, else a negative error code.
  */
@@ -683,6 +700,13 @@ int spi_register_board_info(struct spi_board_info const *info, unsigned n)
 		struct spi_master *master;
 
 		memcpy(&bi->board_info, info, sizeof(*info));
+		if (info->properties) {
+			bi->board_info.properties =
+					property_entries_dup(info->properties);
+			if (IS_ERR(bi->board_info.properties))
+				return PTR_ERR(bi->board_info.properties);
+		}
+
 		mutex_lock(&board_lock);
 		list_add_tail(&bi->list, &board_list);
 		list_for_each_entry(master, &spi_master_list, list)

commit ae7e81c077d60507dcec139e40a6d10cf932cf4b
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 1 18:07:51 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <uapi/linux/sched/types.h>
    
    We are going to move scheduler ABI details to <uapi/linux/sched/types.h>,
    which will be used from a number of .c files.
    
    Create empty placeholder header that maps to <linux/types.h>.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 44222ef9471e..90b5b2efafbf 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -33,6 +33,7 @@
 #include <linux/pm_domain.h>
 #include <linux/export.h>
 #include <linux/sched/rt.h>
+#include <uapi/linux/sched/types.h>
 #include <linux/delay.h>
 #include <linux/kthread.h>
 #include <linux/ioport.h>

commit 43e31e40473a00c936ffb9c2eebedc0566c92e89
Merge: 02c3de110522 ac18c0c4e2b1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 20 17:55:15 2017 -0800

    Merge tag 'acpi-4.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI updates from Rafael Wysocki:
     "These update the ACPICA code in the kernel to upstream revision
      20170119, which among other things updates copyright notices in all of
      the ACPICA files, fix a couple of issues in the ACPI EC and button
      drivers, fix modalias handling for non-discoverable devices with
      DT-compatible identification strings, add a suspend quirk for one
      platform and fix a message in the APEI code.
    
      Specifics:
    
       - Update of the ACPICA code in the kernel to upstream revision
         20170119 including:
    
          + Fixes related to the handling of the bit width and bit offset
            fields in Generic Address Structure (Lv Zheng)
          + ACPI resources handling fix related to invalid resource
            descriptors (Bob Moore)
          + Fix to enable implicit result conversion for several ASL library
            functions (Bob Moore)
          + Support for method invocations as target operands in AML (Bob
            Moore)
          + Fix to use a correct operand type for DeRefOf() in some
            situations (Bob Moore)
          + Utilities updates (Bob Moore, Lv Zheng)
          + Disassembler/debugger updates (David Box, Lv Zheng)
          + Build fixes (Colin Ian King, Lv Zheng)
          + Update of copyright notices in all files (Bob Moore)
    
       - Fix for modalias handling for SPI and I2C devices with
         DT-compatible identification strings (Dan O'Donovan)
    
       - Fixes for the ACPI EC and button drivers (Lv Zheng)
    
       - ACPI processor handling fix related to CPU hotplug (online/offline)
         on x86 (Vitaly Kuznetsov)
    
       - Suspend quirk to save/restore NVS memory over S3 transitions for
         Lenovo G50-45 (Zhang Rui)
    
       - Message formatting fix for the ACPI APEI code (Colin Ian King)"
    
    * tag 'acpi-4.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (32 commits)
      ACPICA: Update version to 20170119
      ACPICA: Tools: Update common signon, remove compilation bit width
      ACPICA: Source tree: Update copyright notices to 2017
      ACPICA: Linuxize: Restore and fix Intel compiler build
      x86/ACPI: keep x86_cpu_to_acpiid mapping valid on CPU hotplug
      spi: acpi: Initialize modalias from of_compatible
      i2c: acpi: Initialize info.type from of_compatible
      ACPI / bus: Introduce acpi_of_modalias() equiv of of_modalias_node()
      ACPI: save NVS memory for Lenovo G50-45
      ACPI, APEI, EINJ: fix malformed newline escape
      ACPI / button: Remove lid_init_state=method mode
      ACPI / button: Change default behavior to lid_init_state=open
      ACPI / EC: Use busy polling mode when GPE is not enabled
      ACPI / EC: Remove old CLEAR_ON_RESUME quirk
      ACPICA: Update version to 20161222
      ACPICA: Parser: Update parse info table for some operators
      ACPICA: Fix a problem with recent extra support for control method invocations
      ACPICA: Parser: Allow method invocations as target operands
      ACPICA: Fix for implicit result conversion for the ToXXX functions
      ACPICA: Resources: Not a valid resource if buffer length too long
      ..

commit e2a3b0df8dea7585a2e64861f3ab7bcbc2a04386
Merge: 2016d52a381c 23e291c2e4c8 ffcfae382375 72bc7ae0633e e7ad4a73364c c2e51ac3d054
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Feb 19 16:41:05 2017 +0000

    Merge remote-tracking branches 'spi/topic/rockchip', 'spi/topic/rspi', 'spi/topic/s3c64xx', 'spi/topic/sh-msiof' and 'spi/topic/slave' into spi-next

commit 3490462378944c7e137657d0d66bb707303cfc96
Merge: 42af2f5c52da 1ce24864bff4
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Feb 19 16:40:55 2017 +0000

    Merge remote-tracking branch 'spi/topic/dma' into spi-next

commit 0c6543f6cda442f5497b2d59ac0dcdda45f4778c
Author: Dan O'Donovan <dan@emutex.com>
Date:   Sun Feb 5 16:30:14 2017 +0000

    spi: acpi: Initialize modalias from of_compatible
    
    When using devicetree spi_device.modalias is set to the compatible
    string with the vendor prefix removed. For SPI devices described via
    ACPI the spi_device.modalias string is initialized by acpi_device_hid.
    When using ACPI and DT ids this string ends up something like "PRP0001".
    
    Change acpi_register_spi_device to use the of_compatible property if
    present. This makes it easier to instantiate spi drivers through ACPI
    with DT ids.
    
    Signed-off-by: Dan O'Donovan <dan@emutex.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Reviewed-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Tested-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 656dd3e3220c..ad7f638a0a5b 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1722,13 +1722,15 @@ static acpi_status acpi_register_spi_device(struct spi_master *master,
 		return AE_OK;
 	}
 
+	acpi_set_modalias(adev, acpi_device_hid(adev), spi->modalias,
+			  sizeof(spi->modalias));
+
 	if (spi->irq < 0)
 		spi->irq = acpi_dev_gpio_irq_get(adev, 0);
 
 	acpi_device_set_enumerated(adev);
 
 	adev->power.flags.ignore_parent = true;
-	strlcpy(spi->modalias, acpi_device_hid(adev), sizeof(spi->modalias));
 	if (spi_add_device(spi)) {
 		adev->power.flags.ignore_parent = false;
 		dev_err(&master->dev, "failed to add SPI device %s from ACPI\n",

commit 8324147f38019865b29d03baf28412d2ec0bd828
Author: Johan Hovold <johan@kernel.org>
Date:   Mon Jan 30 17:47:05 2017 +0100

    spi: fix device-node leaks
    
    Make sure to release the device-node reference taken in
    of_register_spi_device() on errors and when deregistering the device.
    
    Fixes: 284b01897340 ("spi: Add OF binding support for SPI busses")
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 8c05f27bf642..59cb26470d70 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -621,8 +621,10 @@ void spi_unregister_device(struct spi_device *spi)
 	if (!spi)
 		return;
 
-	if (spi->dev.of_node)
+	if (spi->dev.of_node) {
 		of_node_clear_flag(spi->dev.of_node, OF_POPULATED);
+		of_node_put(spi->dev.of_node);
+	}
 	if (ACPI_COMPANION(&spi->dev))
 		acpi_device_clear_enumerated(ACPI_COMPANION(&spi->dev));
 	device_unregister(&spi->dev);
@@ -1603,11 +1605,13 @@ of_register_spi_device(struct spi_master *master, struct device_node *nc)
 	if (rc) {
 		dev_err(&master->dev, "spi_device register error %s\n",
 			nc->full_name);
-		goto err_out;
+		goto err_of_node_put;
 	}
 
 	return spi;
 
+err_of_node_put:
+	of_node_put(nc);
 err_out:
 	spi_dev_put(spi);
 	return ERR_PTR(rc);

commit 88b0aa544af58ce3be125a1845a227264ec9ab89
Author: Daniel Kurtz <djkurtz@chromium.org>
Date:   Fri Jan 27 00:21:53 2017 +0800

    spi: When no dma_chan map buffers with spi_master's parent
    
    Back before commit 1dccb598df54 ("arm64: simplify dma_get_ops"), for
    arm64, devices for which dma_ops were not explicitly set were automatically
    configured to use swiotlb_dma_ops, since this was hard-coded as the
    global "dma_ops" in arm64_dma_init().
    
    Now that global "dma_ops" has been removed, all devices much have their
    dma_ops explicitly set by a call to arch_setup_dma_ops(), otherwise the
    device is assigned dummy_dma_ops, and thus calls to map_sg for such a
    device will fail (return 0).
    
    Mediatek SPI uses DMA but does not use a dma channel.  Support for this
    was added by commit c37f45b5f1cd ("spi: support spi without dma channel
    to use can_dma()"), which uses the master_spi dev to DMA map buffers.
    
    The master_spi device is not a platform device, rather it is created
    in spi_alloc_device(), and therefore its dma_ops are never set.
    
    Therefore, when the mediatek SPI driver when it does DMA (for large SPI
    transactions > 32 bytes), SPI will use spi_map_buf()->dma_map_sg() to
    map the buffer for use in DMA.  But dma_map_sg()->dma_map_sg_attrs() returns
    0, because ops->map_sg is dummy_dma_ops->__dummy_map_sg, and hence
    spi_map_buf() returns -ENOMEM (-12).
    
    Fix this by using the real spi_master's parent device which should be a
    real physical device with DMA properties.
    
    Signed-off-by: Daniel Kurtz <djkurtz@chromium.org>
    Fixes: c37f45b5f1cd ("spi: support spi without dma channel to use can_dma()")
    Cc: Leilk Liu <leilk.liu@mediatek.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 656dd3e3220c..f4d412e48e1c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -805,12 +805,12 @@ static int __spi_map_msg(struct spi_master *master, struct spi_message *msg)
 	if (master->dma_tx)
 		tx_dev = master->dma_tx->device->dev;
 	else
-		tx_dev = &master->dev;
+		tx_dev = master->dev.parent;
 
 	if (master->dma_rx)
 		rx_dev = master->dma_rx->device->dev;
 	else
-		rx_dev = &master->dev;
+		rx_dev = master->dev.parent;
 
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		if (!master->can_dma(master, msg->spi, xfer))
@@ -852,12 +852,12 @@ static int __spi_unmap_msg(struct spi_master *master, struct spi_message *msg)
 	if (master->dma_tx)
 		tx_dev = master->dma_tx->device->dev;
 	else
-		tx_dev = &master->dev;
+		tx_dev = master->dev.parent;
 
 	if (master->dma_rx)
 		rx_dev = master->dma_rx->device->dev;
 	else
-		rx_dev = &master->dev;
+		rx_dev = master->dev.parent;
 
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		if (!master->can_dma(master, msg->spi, xfer))

commit f9bdb7fdd2cac17bdc9c344b6036e6939fa087cd
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Fri Jan 13 12:28:04 2017 +0100

    spi: Use kcalloc() in spi_register_board_info()
    
    A multiplication for the size determination of a memory allocation
    indicated that an array data structure should be processed.
    Thus reuse the corresponding function "kcalloc".
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 656dd3e3220c..8c05f27bf642 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -672,7 +672,7 @@ int spi_register_board_info(struct spi_board_info const *info, unsigned n)
 	if (!n)
 		return -EINVAL;
 
-	bi = kzalloc(n * sizeof(*bi), GFP_KERNEL);
+	bi = kcalloc(n, sizeof(*bi), GFP_KERNEL);
 	if (!bi)
 		return -ENOMEM;
 

commit c2e51ac3d0542440d5b2b8b52ff2ad00751af4da
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Sep 12 22:50:41 2016 +0200

    spi: core: Extract of_spi_parse_dt()
    
    Extract the parsing of SPI slave-specific properties into its own
    function, so it can be reused later for SPI slave controllers.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 656dd3e3220c..1861255866d7 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1502,37 +1502,18 @@ static int spi_master_initialize_queue(struct spi_master *master)
 /*-------------------------------------------------------------------------*/
 
 #if defined(CONFIG_OF)
-static struct spi_device *
-of_register_spi_device(struct spi_master *master, struct device_node *nc)
+static int of_spi_parse_dt(struct spi_master *master, struct spi_device *spi,
+			   struct device_node *nc)
 {
-	struct spi_device *spi;
-	int rc;
 	u32 value;
-
-	/* Alloc an spi_device */
-	spi = spi_alloc_device(master);
-	if (!spi) {
-		dev_err(&master->dev, "spi_device alloc error for %s\n",
-			nc->full_name);
-		rc = -ENOMEM;
-		goto err_out;
-	}
-
-	/* Select device driver */
-	rc = of_modalias_node(nc, spi->modalias,
-				sizeof(spi->modalias));
-	if (rc < 0) {
-		dev_err(&master->dev, "cannot find modalias for %s\n",
-			nc->full_name);
-		goto err_out;
-	}
+	int rc;
 
 	/* Device address */
 	rc = of_property_read_u32(nc, "reg", &value);
 	if (rc) {
 		dev_err(&master->dev, "%s has no valid 'reg' property (%d)\n",
 			nc->full_name, rc);
-		goto err_out;
+		return rc;
 	}
 	spi->chip_select = value;
 
@@ -1590,10 +1571,41 @@ of_register_spi_device(struct spi_master *master, struct device_node *nc)
 	if (rc) {
 		dev_err(&master->dev, "%s has no valid 'spi-max-frequency' property (%d)\n",
 			nc->full_name, rc);
-		goto err_out;
+		return rc;
 	}
 	spi->max_speed_hz = value;
 
+	return 0;
+}
+
+static struct spi_device *
+of_register_spi_device(struct spi_master *master, struct device_node *nc)
+{
+	struct spi_device *spi;
+	int rc;
+
+	/* Alloc an spi_device */
+	spi = spi_alloc_device(master);
+	if (!spi) {
+		dev_err(&master->dev, "spi_device alloc error for %s\n",
+			nc->full_name);
+		rc = -ENOMEM;
+		goto err_out;
+	}
+
+	/* Select device driver */
+	rc = of_modalias_node(nc, spi->modalias,
+				sizeof(spi->modalias));
+	if (rc < 0) {
+		dev_err(&master->dev, "cannot find modalias for %s\n",
+			nc->full_name);
+		goto err_out;
+	}
+
+	rc = of_spi_parse_dt(master, spi, nc);
+	if (rc)
+		goto err_out;
+
 	/* Store a pointer to the node in the device structure */
 	of_node_get(nc);
 	spi->dev.of_node = nc;

commit 3bc1ad252d4f740a7600ded3bf7bee16043f052d
Merge: 0afa0724dfb0 8244bd3ab405 80b444e57948 ccf7d8ee3d6e 7e2ef003302c
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Dec 12 15:54:09 2016 +0000

    Merge remote-tracking branches 'spi/topic/delay', 'spi/topic/dw', 'spi/topic/fsl-dspi' and 'spi/topic/fsl-espi' into spi-next

commit cc939939d81e787fd6a5e86cf81b2ad1cd600bd4
Merge: 05232669503f 8dd4a0163e73
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Dec 12 15:54:03 2016 +0000

    Merge remote-tracking branch 'spi/topic/dma' into spi-next

commit 05232669503f54babf9f899748baf02934fd1051
Merge: b14a8a8028a0 8eee6b9dd30d
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Dec 12 15:54:03 2016 +0000

    Merge remote-tracking branch 'spi/topic/core' into spi-next

commit 8dd4a0163e7315d196e54780591b7426fa78e1fa
Author: Juan Gutierrez <juan.gutierrez@nxp.com>
Date:   Mon Nov 21 16:50:03 2016 -0600

    spi: use sg_next for walking through the allocated scatterlist table
    
    A null dereference or Oops exception might occurs when reading at once the
    whole content of an spi-nor of big enough size that requires an scatterlist
    table that does not fit into one single page.
    
    The spi_map_buf function is ignoring the chained sg case by dereferenceing
    the scatterlist elements in an array fashion. This wrongly assumes that
    the allocation of the scatterlist elements are contiguous. This is true as
    long as the scatterlist table fits within a PAGE_SIZE. However, for
    allocation where the scatter table is bigger than that, the pages allocated
    by sg_alloc might not be contigous.
    
    The sg table can be properly walked by sg_next instead of using an array.
    
    Signed-off-by: Juan Gutierrez <juan.gutierrez@nxp.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 5787b723b593..2cfe67f73476 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -720,6 +720,7 @@ static int spi_map_buf(struct spi_master *master, struct device *dev,
 	int desc_len;
 	int sgs;
 	struct page *vm_page;
+	struct scatterlist *sg;
 	void *sg_buf;
 	size_t min;
 	int i, ret;
@@ -738,6 +739,7 @@ static int spi_map_buf(struct spi_master *master, struct device *dev,
 	if (ret != 0)
 		return ret;
 
+	sg = &sgt->sgl[0];
 	for (i = 0; i < sgs; i++) {
 
 		if (vmalloced_buf || kmap_buf) {
@@ -751,16 +753,17 @@ static int spi_map_buf(struct spi_master *master, struct device *dev,
 				sg_free_table(sgt);
 				return -ENOMEM;
 			}
-			sg_set_page(&sgt->sgl[i], vm_page,
+			sg_set_page(sg, vm_page,
 				    min, offset_in_page(buf));
 		} else {
 			min = min_t(size_t, len, desc_len);
 			sg_buf = buf;
-			sg_set_buf(&sgt->sgl[i], sg_buf, min);
+			sg_set_buf(sg, sg_buf, min);
 		}
 
 		buf += min;
 		len -= min;
+		sg = sg_next(sg);
 	}
 
 	ret = dma_map_sg(dev, sgt->sgl, sgt->nents, dir);

commit 8244bd3ab405a1268223a282b32d28031f7e16fe
Author: Daniel Kurtz <djkurtz@chromium.org>
Date:   Fri Oct 7 18:55:47 2016 +0800

    spi: change post transfer udelay() to usleep_range() for long delays
    
    The spi_transfer parameter delay_usecs allows specifying a time to wait
    after transferring a spi message.  This wait can be quite long - some
    devices, such as some Chrome OS ECs, require as much as 2000 usecs after
    a SPI transaction, before it can respond.
    
    (cf: arch/arm64/boot/dts/nvidia/tegra132-norrin.dts:
       google,cros-ec-spi-msg-delay = <2000>
    )
    
    Blocking a CPU for 2 msecs in a busy loop like this doesn't seem very
    friendly to other processes, so change the blocking delay to a sleep
    to allow other things to use this CPU (or so it can sleep).
    
    This should be safe to do, because:
     (a) A post-transaction delay like this is always specified as a minimum
         wait time
     (b) A delay here is most likely not very time sensitive, as it occurs
         after all data has been transferred
     (c) This delay occurs in a non-critical section of the spi worker thread
         so where it is safe to sleep.
    
    Two caveats:
     1) To avoid penalizing short delays, still use udelay for delays < 10us.
     2) usleep_range() very often picks the upper bound, an upper bounds 10%
        should be plenty.
    
    Signed-off-by: Daniel Kurtz <djkurtz@chromium.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 5787b723b593..42f3e1cb9212 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1034,8 +1034,14 @@ static int spi_transfer_one_message(struct spi_master *master,
 		if (msg->status != -EINPROGRESS)
 			goto out;
 
-		if (xfer->delay_usecs)
-			udelay(xfer->delay_usecs);
+		if (xfer->delay_usecs) {
+			u16 us = xfer->delay_usecs;
+
+			if (us <= 10)
+				udelay(us);
+			else
+				usleep_range(us, us + DIV_ROUND_UP(us, 10));
+		}
 
 		if (xfer->cs_change) {
 			if (list_is_last(&xfer->transfer_list,

commit e0af98a7e025a7263ae7e50264f6f79ed29642a7
Author: Ralf Ramsauer <ralf@ramses-pyramidenbau.de>
Date:   Mon Oct 17 15:59:56 2016 +0200

    spi: mark device nodes only in case of successful instantiation
    
    Instantiated SPI device nodes are marked with OF_POPULATE. This was
    introduced in bd6c164. On unloading, loaded device nodes will of course
    be unmarked. The problem are nodes that fail during initialisation: If a
    node fails, it won't be unloaded and hence not be unmarked.
    
    If a SPI driver module is unloaded and reloaded, it will skip nodes that
    failed before.
    
    Skip device nodes that are already populated and mark them only in case
    of success.
    
    Note that the same issue exists for I2C.
    
    Fixes: bd6c164 ("spi: Mark instantiated device nodes with OF_POPULATE")
    Signed-off-by: Ralf Ramsauer <ralf@ramses-pyramidenbau.de>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 5787b723b593..838783c3fed0 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1618,9 +1618,11 @@ static void of_register_spi_devices(struct spi_master *master)
 		if (of_node_test_and_set_flag(nc, OF_POPULATED))
 			continue;
 		spi = of_register_spi_device(master, nc);
-		if (IS_ERR(spi))
+		if (IS_ERR(spi)) {
 			dev_warn(&master->dev, "Failed to create SPI device for %s\n",
 				nc->full_name);
+			of_node_clear_flag(nc, OF_POPULATED);
+		}
 	}
 }
 #else
@@ -3131,6 +3133,7 @@ static int of_spi_notify(struct notifier_block *nb, unsigned long action,
 		if (IS_ERR(spi)) {
 			pr_err("%s: failed to create for '%s'\n",
 					__func__, rd->dn->full_name);
+			of_node_clear_flag(rd->dn, OF_POPULATED);
 			return notifier_from_errno(PTR_ERR(spi));
 		}
 		break;

commit 8eee6b9dd30d5b20a4c31886057a68bb6a2736c9
Author: Thor Thayer <tthayer@opensource.altera.com>
Date:   Mon Oct 10 09:25:24 2016 -0500

    spi: Add Flag to Enable Slave Select with GPIO Chip Select.
    
    Some SPI masters require slave selection before the transfer
    can begin [1]. The SPI framework currently selects the chip using
    either 1) the internal CS mechanism or 2) the GPIO CS, but not both.
    
    This patch adds a new master->flags define to indicate both the GPIO
    CS and the internal chip select mechanism should be used.
    
    Tested On:
        Altera CycloneV development kit
        Compile tested for build errors on x86_64 (allyesconfigs)
    
    [1] DesignWare dw_apb_ssi Databook, Version 3.20a (page 39)
    
    Signed-off-by: Thor Thayer <tthayer@opensource.altera.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 5787b723b593..cbe15ab5f8a8 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -697,10 +697,15 @@ static void spi_set_cs(struct spi_device *spi, bool enable)
 	if (spi->mode & SPI_CS_HIGH)
 		enable = !enable;
 
-	if (gpio_is_valid(spi->cs_gpio))
+	if (gpio_is_valid(spi->cs_gpio)) {
 		gpio_set_value(spi->cs_gpio, !enable);
-	else if (spi->master->set_cs)
+		/* Some SPI masters need both GPIO CS & slave_select */
+		if ((spi->master->flags & SPI_MASTER_GPIO_SS) &&
+		    spi->master->set_cs)
+			spi->master->set_cs(spi, !enable);
+	} else if (spi->master->set_cs) {
 		spi->master->set_cs(spi, !enable);
+	}
 }
 
 #ifdef CONFIG_HAS_DMA

commit 3989144f863ac576e6efba298d24b0b02a10d4bb
Author: Petr Mladek <pmladek@suse.com>
Date:   Tue Oct 11 13:55:20 2016 -0700

    kthread: kthread worker API cleanup
    
    A good practice is to prefix the names of functions by the name
    of the subsystem.
    
    The kthread worker API is a mix of classic kthreads and workqueues.  Each
    worker has a dedicated kthread.  It runs a generic function that process
    queued works.  It is implemented as part of the kthread subsystem.
    
    This patch renames the existing kthread worker API to use
    the corresponding name from the workqueues API prefixed by
    kthread_:
    
    __init_kthread_worker()         -> __kthread_init_worker()
    init_kthread_worker()           -> kthread_init_worker()
    init_kthread_work()             -> kthread_init_work()
    insert_kthread_work()           -> kthread_insert_work()
    queue_kthread_work()            -> kthread_queue_work()
    flush_kthread_work()            -> kthread_flush_work()
    flush_kthread_worker()          -> kthread_flush_worker()
    
    Note that the names of DEFINE_KTHREAD_WORK*() macros stay
    as they are. It is common that the "DEFINE_" prefix has
    precedence over the subsystem names.
    
    Note that INIT() macros and init() functions use different
    naming scheme. There is no good solution. There are several
    reasons for this solution:
    
      + "init" in the function names stands for the verb "initialize"
        aka "initialize worker". While "INIT" in the macro names
        stands for the noun "INITIALIZER" aka "worker initializer".
    
      + INIT() macros are used only in DEFINE() macros
    
      + init() functions are used close to the other kthread()
        functions. It looks much better if all the functions
        use the same scheme.
    
      + There will be also kthread_destroy_worker() that will
        be used close to kthread_cancel_work(). It is related
        to the init() function. Again it looks better if all
        functions use the same naming scheme.
    
      + there are several precedents for such init() function
        names, e.g. amd_iommu_init_device(), free_area_init_node(),
        jump_label_init_type(),  regmap_init_mmio_clk(),
    
      + It is not an argument but it was inconsistent even before.
    
    [arnd@arndb.de: fix linux-next merge conflict]
     Link: http://lkml.kernel.org/r/20160908135724.1311726-1-arnd@arndb.de
    Link: http://lkml.kernel.org/r/1470754545-17632-3-git-send-email-pmladek@suse.com
    Suggested-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>
    Cc: Josh Triplett <josh@joshtriplett.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Michal Hocko <mhocko@suse.cz>
    Cc: Vlastimil Babka <vbabka@suse.cz>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 8146ccd35a1a..5787b723b593 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1112,7 +1112,7 @@ static void __spi_pump_messages(struct spi_master *master, bool in_kthread)
 
 	/* If another context is idling the device then defer */
 	if (master->idling) {
-		queue_kthread_work(&master->kworker, &master->pump_messages);
+		kthread_queue_work(&master->kworker, &master->pump_messages);
 		spin_unlock_irqrestore(&master->queue_lock, flags);
 		return;
 	}
@@ -1126,7 +1126,7 @@ static void __spi_pump_messages(struct spi_master *master, bool in_kthread)
 
 		/* Only do teardown in the thread */
 		if (!in_kthread) {
-			queue_kthread_work(&master->kworker,
+			kthread_queue_work(&master->kworker,
 					   &master->pump_messages);
 			spin_unlock_irqrestore(&master->queue_lock, flags);
 			return;
@@ -1250,7 +1250,7 @@ static int spi_init_queue(struct spi_master *master)
 	master->running = false;
 	master->busy = false;
 
-	init_kthread_worker(&master->kworker);
+	kthread_init_worker(&master->kworker);
 	master->kworker_task = kthread_run(kthread_worker_fn,
 					   &master->kworker, "%s",
 					   dev_name(&master->dev));
@@ -1258,7 +1258,7 @@ static int spi_init_queue(struct spi_master *master)
 		dev_err(&master->dev, "failed to create message pump task\n");
 		return PTR_ERR(master->kworker_task);
 	}
-	init_kthread_work(&master->pump_messages, spi_pump_messages);
+	kthread_init_work(&master->pump_messages, spi_pump_messages);
 
 	/*
 	 * Master config will indicate if this controller should run the
@@ -1331,7 +1331,7 @@ void spi_finalize_current_message(struct spi_master *master)
 	spin_lock_irqsave(&master->queue_lock, flags);
 	master->cur_msg = NULL;
 	master->cur_msg_prepared = false;
-	queue_kthread_work(&master->kworker, &master->pump_messages);
+	kthread_queue_work(&master->kworker, &master->pump_messages);
 	spin_unlock_irqrestore(&master->queue_lock, flags);
 
 	trace_spi_message_done(mesg);
@@ -1357,7 +1357,7 @@ static int spi_start_queue(struct spi_master *master)
 	master->cur_msg = NULL;
 	spin_unlock_irqrestore(&master->queue_lock, flags);
 
-	queue_kthread_work(&master->kworker, &master->pump_messages);
+	kthread_queue_work(&master->kworker, &master->pump_messages);
 
 	return 0;
 }
@@ -1404,7 +1404,7 @@ static int spi_destroy_queue(struct spi_master *master)
 	ret = spi_stop_queue(master);
 
 	/*
-	 * flush_kthread_worker will block until all work is done.
+	 * kthread_flush_worker will block until all work is done.
 	 * If the reason that stop_queue timed out is that the work will never
 	 * finish, then it does no good to call flush/stop thread, so
 	 * return anyway.
@@ -1414,7 +1414,7 @@ static int spi_destroy_queue(struct spi_master *master)
 		return ret;
 	}
 
-	flush_kthread_worker(&master->kworker);
+	kthread_flush_worker(&master->kworker);
 	kthread_stop(master->kworker_task);
 
 	return 0;
@@ -1438,7 +1438,7 @@ static int __spi_queued_transfer(struct spi_device *spi,
 
 	list_add_tail(&msg->queue, &master->queue);
 	if (!master->busy && need_pump)
-		queue_kthread_work(&master->kworker, &master->pump_messages);
+		kthread_queue_work(&master->kworker, &master->pump_messages);
 
 	spin_unlock_irqrestore(&master->queue_lock, flags);
 	return 0;

commit 6b1576aa875347c6454d911a2e001138c2cec7d5
Author: Thor Thayer <tthayer@opensource.altera.com>
Date:   Mon Oct 10 09:25:24 2016 -0500

    spi: Add Flag to Enable Slave Select with GPIO Chip Select.
    
    Some SPI masters require slave selection before the transfer
    can begin [1]. The SPI framework currently selects the chip using
    either 1) the internal CS mechanism or 2) the GPIO CS, but not both.
    
    This patch adds a new master->flags define to indicate both the GPIO
    CS and the internal chip select mechanism should be used.
    
    Tested On:
        Altera CycloneV development kit
        Compile tested for build errors on x86_64 (allyesconfigs)
    
    [1] DesignWare dw_apb_ssi Databook, Version 3.20a (page 39)
    
    Signed-off-by: Thor Thayer <tthayer@opensource.altera.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 8146ccd35a1a..8708da7c8140 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -697,10 +697,15 @@ static void spi_set_cs(struct spi_device *spi, bool enable)
 	if (spi->mode & SPI_CS_HIGH)
 		enable = !enable;
 
-	if (gpio_is_valid(spi->cs_gpio))
+	if (gpio_is_valid(spi->cs_gpio)) {
 		gpio_set_value(spi->cs_gpio, !enable);
-	else if (spi->master->set_cs)
+		/* Some SPI masters need both GPIO CS & slave_select */
+		if ((spi->master->flags & SPI_MASTER_GPIO_SS) &&
+		    spi->master->set_cs)
+			spi->master->set_cs(spi, !enable);
+	} else if (spi->master->set_cs) {
 		spi->master->set_cs(spi, !enable);
+	}
 }
 
 #ifdef CONFIG_HAS_DMA

commit c5aee51b7aba4fb182cc0f05e8d5b0098366d62e
Merge: 1a8dabf88dbd b1b8153cf0ae
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Sep 30 09:14:07 2016 -0700

    Merge remote-tracking branch 'spi/topic/dma' into spi-next

commit ae4860b5333586b60ca1798f3f83b8b37520904c
Merge: c6935931c189 764f21665a12 2e365a703ea6 2932c287108e b70cd2de0ea8 c3ccf357c3d7 d0716dde375e
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Sep 6 12:32:09 2016 +0100

    Merge remote-tracking branches 'spi/fix/lock', 'spi/fix/maintainers', 'spi/fix/put', 'spi/fix/pxa2xx', 'spi/fix/sh-msiof' and 'spi/fix/timeout' into spi-linus

commit d0716dde375eb6bff332763bb2137302120d263d
Author: Sien Wu <sien.wu@ni.com>
Date:   Thu Sep 1 18:24:29 2016 -0500

    spi: Prevent unexpected SPI time out due to arithmetic overflow
    
    When reading SPI flash as MTD device, the transfer length is
    directly passed to the spi driver. If the requested data size
    exceeds 512KB, it will cause the time out calculation to
    overflow since transfer length is 32-bit unsigned integer.
    This issue is resolved by using 64-bit unsigned integer
    to perform the arithmetic.
    
    Signed-off-by: Sien Wu <sien.wu@ni.com>
    Acked-by: Brad Keryan <brad.keryan@ni.com>
    Acked-by: Gratian Crisan <gratian.crisan@ni.com>
    Acked-by: Brad Mouring <brad.mouring@ni.com>
    
    Natinst-ReviewBoard-ID 150232
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 51ad42fad567..ac889df9b1f3 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -960,7 +960,7 @@ static int spi_transfer_one_message(struct spi_master *master,
 	struct spi_transfer *xfer;
 	bool keep_cs = false;
 	int ret = 0;
-	unsigned long ms = 1;
+	unsigned long long ms = 1;
 	struct spi_statistics *statm = &master->statistics;
 	struct spi_statistics *stats = &msg->spi->statistics;
 
@@ -991,9 +991,13 @@ static int spi_transfer_one_message(struct spi_master *master,
 
 			if (ret > 0) {
 				ret = 0;
-				ms = xfer->len * 8 * 1000 / xfer->speed_hz;
+				ms = 8LL * 1000LL * xfer->len;
+				do_div(ms, xfer->speed_hz);
 				ms += ms + 100; /* some tolerance */
 
+				if (ms > UINT_MAX)
+					ms = UINT_MAX;
+
 				ms = wait_for_completion_timeout(&master->xfer_completion,
 								 msecs_to_jiffies(ms));
 			}

commit b1b8153cf0aeeb7ae6d4f012b8beb2dcfc92c68a
Author: Vignesh R <vigneshr@ti.com>
Date:   Wed Aug 17 15:22:36 2016 +0530

    spi: Add support to handle kmap'd buffers in spi_map_buf()
    
    JFFS2 FS might sometime provide kmap'd buffers as destination
    buffers to read data from flash. Update spi_map_buf() function to
    generate sg_list for such buffers, so that SPI controllers drivers can
    use DMA to read data into such buffers.
    
    Signed-off-by: Vignesh R <vigneshr@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 51ad42fad567..2a5dd22efa34 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -37,6 +37,7 @@
 #include <linux/kthread.h>
 #include <linux/ioport.h>
 #include <linux/acpi.h>
+#include <linux/highmem.h>
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/spi.h>
@@ -709,6 +710,13 @@ static int spi_map_buf(struct spi_master *master, struct device *dev,
 {
 	const bool vmalloced_buf = is_vmalloc_addr(buf);
 	unsigned int max_seg_size = dma_get_max_seg_size(dev);
+#ifdef CONFIG_HIGHMEM
+	const bool kmap_buf = ((unsigned long)buf >= PKMAP_BASE &&
+				(unsigned long)buf < (PKMAP_BASE +
+					(LAST_PKMAP * PAGE_SIZE)));
+#else
+	const bool kmap_buf = false;
+#endif
 	int desc_len;
 	int sgs;
 	struct page *vm_page;
@@ -716,7 +724,7 @@ static int spi_map_buf(struct spi_master *master, struct device *dev,
 	size_t min;
 	int i, ret;
 
-	if (vmalloced_buf) {
+	if (vmalloced_buf || kmap_buf) {
 		desc_len = min_t(int, max_seg_size, PAGE_SIZE);
 		sgs = DIV_ROUND_UP(len + offset_in_page(buf), desc_len);
 	} else if (virt_addr_valid(buf)) {
@@ -732,10 +740,13 @@ static int spi_map_buf(struct spi_master *master, struct device *dev,
 
 	for (i = 0; i < sgs; i++) {
 
-		if (vmalloced_buf) {
+		if (vmalloced_buf || kmap_buf) {
 			min = min_t(size_t,
 				    len, desc_len - offset_in_page(buf));
-			vm_page = vmalloc_to_page(buf);
+			if (vmalloced_buf)
+				vm_page = vmalloc_to_page(buf);
+			else
+				vm_page = kmap_to_page(buf);
 			if (!vm_page) {
 				sg_free_table(sgt);
 				return -ENOMEM;

commit 764f21665a12e99f03124b4c8de722cdbff92213
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Aug 9 17:45:33 2016 +0100

    spi: Drop io_mutex in error paths
    
    A couple of error paths were missing drops of io_mutex.
    
    Reported-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 51ad42fad567..57179d5eea9a 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1159,6 +1159,7 @@ static void __spi_pump_messages(struct spi_master *master, bool in_kthread)
 		if (ret < 0) {
 			dev_err(&master->dev, "Failed to power device: %d\n",
 				ret);
+			mutex_unlock(&master->io_mutex);
 			return;
 		}
 	}
@@ -1174,6 +1175,7 @@ static void __spi_pump_messages(struct spi_master *master, bool in_kthread)
 
 			if (master->auto_runtime_pm)
 				pm_runtime_put(master->dev.parent);
+			mutex_unlock(&master->io_mutex);
 			return;
 		}
 	}

commit 7ae0ae4a022b72f33d23ab6e858163d4b37400a5
Merge: 607e11ab6654 dec34e8b676e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 27 14:11:43 2016 -0700

    Merge tag 'spi-v4.8' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi
    
    Pull spi updates from Mark Brown:
     "Quite a lot of cleanup and maintainence work going on this release in
      various drivers, and also a fix for a nasty locking issue in the core:
    
       - A fix for locking issues when external drivers explicitly locked
         the bus with spi_bus_lock() - we were using the same lock to both
         control access to the physical bus in multi-threaded I/O operations
         and exclude multiple callers.
    
         Confusion between these two caused us to have scenarios where we
         were dropping locks.  These are fixed by splitting into two
         separate locks like should have been done originally, making
         everything much clearer and correct.
    
       - Support for DMA in spi_flash_read().
    
       - Support for instantiating spidev on ACPI systems, including some
         test devices used in Windows validation.
    
       - Use of the core DMA mapping functionality in the McSPI driver.
    
       - Start of support for ThunderX SPI controllers, involving a very big
         set of changes to the Cavium driver.
    
       - Support for Braswell, Exynos 5433, Kaby Lake, Merrifield, RK3036,
         RK3228, RK3368 controllers"
    
    * tag 'spi-v4.8' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi: (64 commits)
      spi: Split bus and I/O locking
      spi: octeon: Split driver into Octeon specific and common parts
      spi: octeon: Move include file from arch/mips to drivers/spi
      spi: octeon: Put register offsets into a struct
      spi: octeon: Store system clock freqency in struct octeon_spi
      spi: octeon: Convert driver to use readq()/writeq() functions
      spi: pic32-sqi: fixup wait_for_completion_timeout return handling
      spi: pic32: fixup wait_for_completion_timeout return handling
      spi: rockchip: limit transfers to (64K - 1) bytes
      spi: xilinx: Return IRQ_NONE if no interrupts were detected
      spi: xilinx: Handle errors from platform_get_irq()
      spi: s3c64xx: restore removed comments
      spi: s3c64xx: add Exynos5433 compatible for ioclk handling
      spi: s3c64xx: use error code from clk_prepare_enable()
      spi: s3c64xx: rename goto labels to meaningful names
      spi: s3c64xx: document the clocks and the clock-name property
      spi: s3c64xx: add exynos5433 spi compatible
      spi: s3c64xx: fix reference leak to master in s3c64xx_spi_remove()
      spi: spi-sh: Remove deprecated create_singlethread_workqueue
      spi: spi-topcliff-pch: Remove deprecated create_singlethread_workqueue
      ...

commit ef4d96ec4ad947360f48677b6007a4c77953b090
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Jul 21 23:53:31 2016 +0100

    spi: Split bus and I/O locking
    
    The current SPI code attempts to use bus_lock_mutex for two purposes. One
    is to implement spi_bus_lock() which grants exclusive access to the bus.
    The other is to serialize access to the physical hardware. This duplicate
    purpose causes confusion which leads to cases where access is not locked
    when a caller holds the bus lock mutex. Fix this by splitting out the I/O
    functionality into a new io_mutex.
    
    This means taking both mutexes in the DMA path, replacing the existing
    mutex with the new I/O one in the message pump (the mutex now always
    being taken in the message pump) and taking the bus lock mutex in
    spi_sync(), allowing __spi_sync() to have no mutex handling.
    
    While we're at it hoist the mutex further up the message pump before we
    power up the device so that all power up/down of the block is covered by
    it and there are no races with in-line pumping of messages.
    
    Reported-by: Rich Felker <dalias@libc.org>
    Tested-by: Rich Felker <dalias@libc.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index c9a8d544e467..d2e7f1350ef6 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1069,7 +1069,6 @@ EXPORT_SYMBOL_GPL(spi_finalize_current_transfer);
  * __spi_pump_messages - function which processes spi message queue
  * @master: master to process queue for
  * @in_kthread: true if we are in the context of the message pump thread
- * @bus_locked: true if the bus mutex is held when calling this function
  *
  * This function checks if there is any spi message in the queue that
  * needs processing and if so call out to the driver to initialize hardware
@@ -1079,8 +1078,7 @@ EXPORT_SYMBOL_GPL(spi_finalize_current_transfer);
  * inside spi_sync(); the queue extraction handling at the top of the
  * function should deal with this safely.
  */
-static void __spi_pump_messages(struct spi_master *master, bool in_kthread,
-				bool bus_locked)
+static void __spi_pump_messages(struct spi_master *master, bool in_kthread)
 {
 	unsigned long flags;
 	bool was_busy = false;
@@ -1152,6 +1150,8 @@ static void __spi_pump_messages(struct spi_master *master, bool in_kthread,
 		master->busy = true;
 	spin_unlock_irqrestore(&master->queue_lock, flags);
 
+	mutex_lock(&master->io_mutex);
+
 	if (!was_busy && master->auto_runtime_pm) {
 		ret = pm_runtime_get_sync(master->dev.parent);
 		if (ret < 0) {
@@ -1176,9 +1176,6 @@ static void __spi_pump_messages(struct spi_master *master, bool in_kthread,
 		}
 	}
 
-	if (!bus_locked)
-		mutex_lock(&master->bus_lock_mutex);
-
 	trace_spi_message_start(master->cur_msg);
 
 	if (master->prepare_message) {
@@ -1208,8 +1205,7 @@ static void __spi_pump_messages(struct spi_master *master, bool in_kthread,
 	}
 
 out:
-	if (!bus_locked)
-		mutex_unlock(&master->bus_lock_mutex);
+	mutex_unlock(&master->io_mutex);
 
 	/* Prod the scheduler in case transfer_one() was busy waiting */
 	if (!ret)
@@ -1225,7 +1221,7 @@ static void spi_pump_messages(struct kthread_work *work)
 	struct spi_master *master =
 		container_of(work, struct spi_master, pump_messages);
 
-	__spi_pump_messages(master, true, master->bus_lock_flag);
+	__spi_pump_messages(master, true);
 }
 
 static int spi_init_queue(struct spi_master *master)
@@ -1887,6 +1883,7 @@ int spi_register_master(struct spi_master *master)
 	spin_lock_init(&master->queue_lock);
 	spin_lock_init(&master->bus_lock_spinlock);
 	mutex_init(&master->bus_lock_mutex);
+	mutex_init(&master->io_mutex);
 	master->bus_lock_flag = 0;
 	init_completion(&master->xfer_completion);
 	if (!master->max_dma_len)
@@ -2767,6 +2764,7 @@ int spi_flash_read(struct spi_device *spi,
 	}
 
 	mutex_lock(&master->bus_lock_mutex);
+	mutex_lock(&master->io_mutex);
 	if (master->dma_rx) {
 		rx_dev = master->dma_rx->device->dev;
 		ret = spi_map_buf(master, rx_dev, &msg->rx_sg,
@@ -2779,6 +2777,7 @@ int spi_flash_read(struct spi_device *spi,
 	if (msg->cur_msg_mapped)
 		spi_unmap_buf(master, rx_dev, &msg->rx_sg,
 			      DMA_FROM_DEVICE);
+	mutex_unlock(&master->io_mutex);
 	mutex_unlock(&master->bus_lock_mutex);
 
 	if (master->auto_runtime_pm)
@@ -2800,8 +2799,7 @@ static void spi_complete(void *arg)
 	complete(arg);
 }
 
-static int __spi_sync(struct spi_device *spi, struct spi_message *message,
-		      int bus_locked)
+static int __spi_sync(struct spi_device *spi, struct spi_message *message)
 {
 	DECLARE_COMPLETION_ONSTACK(done);
 	int status;
@@ -2819,9 +2817,6 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message,
 	SPI_STATISTICS_INCREMENT_FIELD(&master->statistics, spi_sync);
 	SPI_STATISTICS_INCREMENT_FIELD(&spi->statistics, spi_sync);
 
-	if (!bus_locked)
-		mutex_lock(&master->bus_lock_mutex);
-
 	/* If we're not using the legacy transfer method then we will
 	 * try to transfer in the calling context so special case.
 	 * This code would be less tricky if we could remove the
@@ -2839,9 +2834,6 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message,
 		status = spi_async_locked(spi, message);
 	}
 
-	if (!bus_locked)
-		mutex_unlock(&master->bus_lock_mutex);
-
 	if (status == 0) {
 		/* Push out the messages in the calling context if we
 		 * can.
@@ -2851,7 +2843,7 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message,
 						       spi_sync_immediate);
 			SPI_STATISTICS_INCREMENT_FIELD(&spi->statistics,
 						       spi_sync_immediate);
-			__spi_pump_messages(master, false, bus_locked);
+			__spi_pump_messages(master, false);
 		}
 
 		wait_for_completion(&done);
@@ -2884,7 +2876,13 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message,
  */
 int spi_sync(struct spi_device *spi, struct spi_message *message)
 {
-	return __spi_sync(spi, message, spi->master->bus_lock_flag);
+	int ret;
+
+	mutex_lock(&spi->master->bus_lock_mutex);
+	ret = __spi_sync(spi, message);
+	mutex_unlock(&spi->master->bus_lock_mutex);
+
+	return ret;
 }
 EXPORT_SYMBOL_GPL(spi_sync);
 
@@ -2906,7 +2904,7 @@ EXPORT_SYMBOL_GPL(spi_sync);
  */
 int spi_sync_locked(struct spi_device *spi, struct spi_message *message)
 {
-	return __spi_sync(spi, message, 1);
+	return __spi_sync(spi, message);
 }
 EXPORT_SYMBOL_GPL(spi_sync_locked);
 

commit 7f24467f3b357ab6abc146c47fcedd7d57a189b6
Author: Octavian Purdila <octavian.purdila@intel.com>
Date:   Fri Jul 8 19:13:11 2016 +0300

    spi / ACPI: add support for ACPI reconfigure notifications
    
    This patch adds supports for SPI device enumeration and removal via
    ACPI reconfiguration notifications that are send as a result of an
    ACPI table load or unload operation.
    
    The code is very similar with the device tree reconfiguration code
    with only small differences in the way we test and set the enumerated
    state of the device:
    
     * the equivalent of device tree's OF_POPULATED flag is the
       flags.visited field in the ACPI device and the following wrappers
       are used to manipulate it: acpi_device_enumerated(),
       acpi_device_set_enumerated() and acpi_device_clear_enumerated()
    
     * the device tree code checks of status of the OF_POPULATED flag to
       avoid trying to create duplicate Linux devices in two places: once
       when the controller is probed, and once when the reconfigure event
       is received; in the ACPI code the check is performed only once when
       the ACPI namespace is searched because this code path is invoked in
       both of the two mentioned cases
    
    The rest of the enumeration handling is similar with device tree: when
    the Linux device is unregistered the ACPI device is marked as not
    enumerated; also, when a device remove notification is received we
    check that the device is in the enumerated state before continuing
    with the removal of the Linux device.
    
    Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 77e6e45951f4..7589c8af4368 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -622,6 +622,8 @@ void spi_unregister_device(struct spi_device *spi)
 
 	if (spi->dev.of_node)
 		of_node_clear_flag(spi->dev.of_node, OF_POPULATED);
+	if (ACPI_COMPANION(&spi->dev))
+		acpi_device_clear_enumerated(ACPI_COMPANION(&spi->dev));
 	device_unregister(&spi->dev);
 }
 EXPORT_SYMBOL_GPL(spi_unregister_device);
@@ -1646,18 +1648,15 @@ static int acpi_spi_add_resource(struct acpi_resource *ares, void *data)
 	return 1;
 }
 
-static acpi_status acpi_spi_add_device(acpi_handle handle, u32 level,
-				       void *data, void **return_value)
+static acpi_status acpi_register_spi_device(struct spi_master *master,
+					    struct acpi_device *adev)
 {
-	struct spi_master *master = data;
 	struct list_head resource_list;
-	struct acpi_device *adev;
 	struct spi_device *spi;
 	int ret;
 
-	if (acpi_bus_get_device(handle, &adev))
-		return AE_OK;
-	if (acpi_bus_get_status(adev) || !adev->status.present)
+	if (acpi_bus_get_status(adev) || !adev->status.present ||
+	    acpi_device_enumerated(adev))
 		return AE_OK;
 
 	spi = spi_alloc_device(master);
@@ -1683,6 +1682,8 @@ static acpi_status acpi_spi_add_device(acpi_handle handle, u32 level,
 	if (spi->irq < 0)
 		spi->irq = acpi_dev_gpio_irq_get(adev, 0);
 
+	acpi_device_set_enumerated(adev);
+
 	adev->power.flags.ignore_parent = true;
 	strlcpy(spi->modalias, acpi_device_hid(adev), sizeof(spi->modalias));
 	if (spi_add_device(spi)) {
@@ -1695,6 +1696,18 @@ static acpi_status acpi_spi_add_device(acpi_handle handle, u32 level,
 	return AE_OK;
 }
 
+static acpi_status acpi_spi_add_device(acpi_handle handle, u32 level,
+				       void *data, void **return_value)
+{
+	struct spi_master *master = data;
+	struct acpi_device *adev;
+
+	if (acpi_bus_get_device(handle, &adev))
+		return AE_OK;
+
+	return acpi_register_spi_device(master, adev);
+}
+
 static void acpi_register_spi_devices(struct spi_master *master)
 {
 	acpi_status status;
@@ -3107,6 +3120,77 @@ static struct notifier_block spi_of_notifier = {
 extern struct notifier_block spi_of_notifier;
 #endif /* IS_ENABLED(CONFIG_OF_DYNAMIC) */
 
+#if IS_ENABLED(CONFIG_ACPI)
+static int spi_acpi_master_match(struct device *dev, const void *data)
+{
+	return ACPI_COMPANION(dev->parent) == data;
+}
+
+static int spi_acpi_device_match(struct device *dev, void *data)
+{
+	return ACPI_COMPANION(dev) == data;
+}
+
+static struct spi_master *acpi_spi_find_master_by_adev(struct acpi_device *adev)
+{
+	struct device *dev;
+
+	dev = class_find_device(&spi_master_class, NULL, adev,
+				spi_acpi_master_match);
+	if (!dev)
+		return NULL;
+
+	return container_of(dev, struct spi_master, dev);
+}
+
+static struct spi_device *acpi_spi_find_device_by_adev(struct acpi_device *adev)
+{
+	struct device *dev;
+
+	dev = bus_find_device(&spi_bus_type, NULL, adev, spi_acpi_device_match);
+
+	return dev ? to_spi_device(dev) : NULL;
+}
+
+static int acpi_spi_notify(struct notifier_block *nb, unsigned long value,
+			   void *arg)
+{
+	struct acpi_device *adev = arg;
+	struct spi_master *master;
+	struct spi_device *spi;
+
+	switch (value) {
+	case ACPI_RECONFIG_DEVICE_ADD:
+		master = acpi_spi_find_master_by_adev(adev->parent);
+		if (!master)
+			break;
+
+		acpi_register_spi_device(master, adev);
+		put_device(&master->dev);
+		break;
+	case ACPI_RECONFIG_DEVICE_REMOVE:
+		if (!acpi_device_enumerated(adev))
+			break;
+
+		spi = acpi_spi_find_device_by_adev(adev);
+		if (!spi)
+			break;
+
+		spi_unregister_device(spi);
+		put_device(&spi->dev);
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block spi_acpi_notifier = {
+	.notifier_call = acpi_spi_notify,
+};
+#else
+extern struct notifier_block spi_acpi_notifier;
+#endif
+
 static int __init spi_init(void)
 {
 	int	status;
@@ -3127,6 +3211,8 @@ static int __init spi_init(void)
 
 	if (IS_ENABLED(CONFIG_OF_DYNAMIC))
 		WARN_ON(of_reconfig_notifier_register(&spi_of_notifier));
+	if (IS_ENABLED(CONFIG_ACPI))
+		WARN_ON(acpi_reconfig_notifier_register(&spi_acpi_notifier));
 
 	return 0;
 

commit f4502dd1da9b060a49d539eb754ff86cb97b89f0
Author: Vignesh R <vigneshr@ti.com>
Date:   Wed Jun 8 12:18:31 2016 +0530

    spi: Add DMA support for spi_flash_read()
    
    Few SPI devices provide accelerated read interfaces to read from
    SPI-NOR flash devices. These hardwares also support DMA to transfer data
    from flash to memory either via mem-to-mem DMA or dedicated slave DMA
    channels. Hence, add support for DMA in order to improve throughput and
    reduce CPU load.
    Use spi_map_buf() to get sg table for the buffer and pass it to SPI
    driver.
    
    Signed-off-by: Vignesh R <vigneshr@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 77e6e45951f4..c9a8d544e467 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -849,6 +849,20 @@ static int __spi_unmap_msg(struct spi_master *master, struct spi_message *msg)
 	return 0;
 }
 #else /* !CONFIG_HAS_DMA */
+static inline int spi_map_buf(struct spi_master *master,
+			      struct device *dev, struct sg_table *sgt,
+			      void *buf, size_t len,
+			      enum dma_data_direction dir)
+{
+	return -EINVAL;
+}
+
+static inline void spi_unmap_buf(struct spi_master *master,
+				 struct device *dev, struct sg_table *sgt,
+				 enum dma_data_direction dir)
+{
+}
+
 static inline int __spi_map_msg(struct spi_master *master,
 				struct spi_message *msg)
 {
@@ -2725,6 +2739,7 @@ int spi_flash_read(struct spi_device *spi,
 
 {
 	struct spi_master *master = spi->master;
+	struct device *rx_dev = NULL;
 	int ret;
 
 	if ((msg->opcode_nbits == SPI_NBITS_DUAL ||
@@ -2750,9 +2765,22 @@ int spi_flash_read(struct spi_device *spi,
 			return ret;
 		}
 	}
+
 	mutex_lock(&master->bus_lock_mutex);
+	if (master->dma_rx) {
+		rx_dev = master->dma_rx->device->dev;
+		ret = spi_map_buf(master, rx_dev, &msg->rx_sg,
+				  msg->buf, msg->len,
+				  DMA_FROM_DEVICE);
+		if (!ret)
+			msg->cur_msg_mapped = true;
+	}
 	ret = master->spi_flash_read(spi, msg);
+	if (msg->cur_msg_mapped)
+		spi_unmap_buf(master, rx_dev, &msg->rx_sg,
+			      DMA_FROM_DEVICE);
 	mutex_unlock(&master->bus_lock_mutex);
+
 	if (master->auto_runtime_pm)
 		pm_runtime_put(master->dev.parent);
 

commit 38acceff8f02caa8d6b7b4068bb849b619a438d6
Merge: 2dcd0af568b0 8ba811a7d2f0
Author: Mark Brown <broonie@kernel.org>
Date:   Mon May 23 12:16:45 2016 +0100

    Merge remote-tracking branch 'spi/topic/core' into spi-next

commit 8ba811a7d2f0f86a37bd8aaaff35ce1004633430
Author: Moritz Fischer <moritz.fischer@ettus.com>
Date:   Tue May 3 11:59:30 2016 -0700

    spi: Fix simple typo s/impelment/implement
    
    This fixes a simple typo in one of the comments.
    
    Signed-off-by: Moritz Fischer <moritz.fischer@ettus.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index a50f880a5036..9e54d7bf3ec3 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -935,7 +935,7 @@ static int spi_map_msg(struct spi_master *master, struct spi_message *msg)
  * spi_transfer_one_message - Default implementation of transfer_one_message()
  *
  * This is a standard implementation of transfer_one_message() for
- * drivers which impelment a transfer_one() operation.  It provides
+ * drivers which implement a transfer_one() operation.  It provides
  * standard handling of delays and chip select management.
  */
 static int spi_transfer_one_message(struct spi_master *master,

commit 0569a88f3d1ffed94b15569d53872f16e2351099
Author: Vignesh R <vigneshr@ti.com>
Date:   Mon Apr 25 15:14:00 2016 +0530

    spi: return error if kmap'd buffers passed to spi_map_buf()
    
    Current spi_map_buf() implementation supports creates sg_table for
    vmalloc'd and kmalloc'd buffers. Therefore return error if kmap'd buffer
    (or any other buffer) is passed to spi_map_buf().
    
    Signed-off-by: Vignesh R <vigneshr@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 6c4c050e6b65..a50f880a5036 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -717,9 +717,11 @@ static int spi_map_buf(struct spi_master *master, struct device *dev,
 	if (vmalloced_buf) {
 		desc_len = min_t(int, max_seg_size, PAGE_SIZE);
 		sgs = DIV_ROUND_UP(len + offset_in_page(buf), desc_len);
-	} else {
+	} else if (virt_addr_valid(buf)) {
 		desc_len = min_t(int, max_seg_size, master->max_dma_len);
 		sgs = DIV_ROUND_UP(len, desc_len);
+	} else {
+		return -EINVAL;
 	}
 
 	ret = sg_alloc_table(sgt, sgs, GFP_KERNEL);

commit d7e2ee257038baeb03baef602500368a51ee9eef
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Apr 11 13:51:03 2016 +0200

    spi: let SPI masters ignore their children for PM
    
    Let all SPI masters ignore their children: when it comes
    to power management: SPI children have no business doing
    keeping their parents awake: they are completely autonomous
    devices that just use their parent to talk, and the latter
    usecase must be power managed by the host itself on a
    per-message basis.
    
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index de2f2f90d799..6c4c050e6b65 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1764,6 +1764,7 @@ struct spi_master *spi_alloc_master(struct device *dev, unsigned size)
 	master->num_chipselect = 1;
 	master->dev.class = &spi_master_class;
 	master->dev.parent = dev;
+	pm_suspend_ignore_children(&master->dev, true);
 	spi_master_set_devdata(master, &master[1]);
 
 	return master;

commit 24c8cd1b081286fd34340f0e1fc68a774a5a775f
Author: Heiko StÃ¼bner <heiko@sntech.de>
Date:   Fri Mar 18 11:15:11 2016 +0100

    spi: fix possible deadlock between internal bus locks and bus_lock_flag
    
    External users may use spi_bus_lock to get exclusive access. This will
    also grab the bus_lock_mutex and may therefore result in a deadlock if
    __spi_pump_messages also tries to get the mutex.
    
    Therefore adapt spi_pump_messages as well as spi_sync to preset the
    bus_locked parameter according to the master->bus_lock_flag.
    
    Fixes: 49023d2e4ead ("spi: core: Fix deadlock when sending messages")
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index de2f2f90d799..0239b45eed92 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1209,7 +1209,7 @@ static void spi_pump_messages(struct kthread_work *work)
 	struct spi_master *master =
 		container_of(work, struct spi_master, pump_messages);
 
-	__spi_pump_messages(master, true, false);
+	__spi_pump_messages(master, true, master->bus_lock_flag);
 }
 
 static int spi_init_queue(struct spi_master *master)
@@ -2853,7 +2853,7 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message,
  */
 int spi_sync(struct spi_device *spi, struct spi_message *message)
 {
-	return __spi_sync(spi, message, 0);
+	return __spi_sync(spi, message, spi->master->bus_lock_flag);
 }
 EXPORT_SYMBOL_GPL(spi_sync);
 

commit b9facea19b6382b3f24edd25ec5d9a84f93e9f3b
Merge: f91c75d6faef 14a20428e2e0 10f11a2238d4 22640c8a2736 590745017ef3
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Mar 11 14:28:43 2016 +0700

    Merge remote-tracking branches 'spi/topic/lp8841', 'spi/topic/msg', 'spi/topic/pl022' and 'spi/topic/pxa2xx' into spi-next

commit f91c75d6faefdded97d2ecbe8c4f9cf197f68110
Merge: 6beb9fecbde4 ee7683a31683 2f6fdefb3503 49023d2e4ead
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Mar 11 14:28:35 2016 +0700

    Merge remote-tracking branches 'spi/topic/doc', 'spi/topic/dw' and 'spi/topic/flash' into spi-next

commit 6beb9fecbde45f09ea79a67ed5fd8d17e3bf6213
Merge: ce7fb74f546c a0a90718f182 b1353d1c1d45 763dedfcda5f e9dd4edcc985
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Mar 11 14:28:25 2016 +0700

    Merge remote-tracking branches 'spi/topic/acpi', 'spi/topic/axi-engine', 'spi/topic/bcm2835' and 'spi/topic/bcm2835aux' into spi-next

commit a75481ab4a5276770e0fb7e137a4f170b90fc48b
Merge: df9633a7805e df88e91bbfd1
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Mar 11 14:28:20 2016 +0700

    Merge remote-tracking branch 'spi/topic/dma' into spi-next

commit 10f11a2238d4d66e74438b629214b530a77db8e1
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Thu Mar 10 15:01:14 2016 -0300

    spi: Add gfp parameter to kernel-doc to fix build warning
    
    The spi_split_transfers_maxsize() gfp parameter is missing in the
    function kernel-doc so building gives the following warning:
    
    .//drivers/spi/spi.c:2359: warning: No description found for parameter 'gfp'
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 96c764d7efe6..c881493974d8 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2319,6 +2319,7 @@ static int __spi_split_transfer_maxsize(struct spi_master *master,
  * @master:    the @spi_master for this transfer
  * @msg:   the @spi_message to transform
  * @maxsize:  the maximum when to apply this
+ * @gfp: GFP allocation flags
  *
  * Return: status of transformation
  */

commit df88e91bbfd16662f3c8dcba27ad19e9eb4ebcef
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Mar 9 11:20:00 2016 +0200

    spi: respect the maximum segment size of DMA device
    
    The device which is actually does DMA may have a limitation of the maximum
    segment size. Respect this setting when preparing scatter-gather list.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 47eff8012a77..9e6480a2e869 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -702,6 +702,7 @@ static int spi_map_buf(struct spi_master *master, struct device *dev,
 		       enum dma_data_direction dir)
 {
 	const bool vmalloced_buf = is_vmalloc_addr(buf);
+	unsigned int max_seg_size = dma_get_max_seg_size(dev);
 	int desc_len;
 	int sgs;
 	struct page *vm_page;
@@ -710,10 +711,10 @@ static int spi_map_buf(struct spi_master *master, struct device *dev,
 	int i, ret;
 
 	if (vmalloced_buf) {
-		desc_len = PAGE_SIZE;
+		desc_len = min_t(int, max_seg_size, PAGE_SIZE);
 		sgs = DIV_ROUND_UP(len + offset_in_page(buf), desc_len);
 	} else {
-		desc_len = master->max_dma_len;
+		desc_len = min_t(int, max_seg_size, master->max_dma_len);
 		sgs = DIV_ROUND_UP(len, desc_len);
 	}
 
@@ -739,7 +740,6 @@ static int spi_map_buf(struct spi_master *master, struct device *dev,
 			sg_set_buf(&sgt->sgl[i], sg_buf, min);
 		}
 
-
 		buf += min;
 		len -= min;
 	}

commit 49023d2e4ead0fc9e0896331037746b267d46ad4
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Tue Mar 8 12:28:20 2016 +0000

    spi: core: Fix deadlock when sending messages
    
    The function __spi_pump_messages() is called by spi_pump_messages() and
    __spi_sync(). The function __spi_sync() has an argument 'bus_locked'
    that indicates if it is called with the SPI bus mutex held or not. If
    'bus_locked' is false then __spi_sync() will acquire the mutex itself.
    
    Commit 556351f14e74 ("spi: introduce accelerated read support for spi
    flash devices") made a change to acquire the SPI bus mutex within
    __spi_pump_messages(). However, this change did not check to see if the
    mutex is already held. If __spi_sync() is called with the mutex held
    (ie. 'bus_locked' is true), then a deadlock occurs when
    __spi_pump_messages() is called.
    
    Fix this deadlock by passing the 'bus_locked' state from __spi_sync() to
    __spi_pump_messages() and only acquire the mutex if not already held. In
    the case where __spi_pump_messages() is called from spi_pump_messages()
    it is assumed that the mutex is not held and so call
    __spi_pump_messages() with 'bus_locked' set to false. Finally, move the
    unlocking of the mutex to the end of the __spi_pump_messages() function
    to simplify the code and only call cond_resched() if there are no
    errors.
    
    Fixes: 556351f14e74 ("spi: introduce accelerated read support for spi flash devices")
    
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 0b2bbf144460..f565cc8901a6 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1047,6 +1047,7 @@ EXPORT_SYMBOL_GPL(spi_finalize_current_transfer);
  * __spi_pump_messages - function which processes spi message queue
  * @master: master to process queue for
  * @in_kthread: true if we are in the context of the message pump thread
+ * @bus_locked: true if the bus mutex is held when calling this function
  *
  * This function checks if there is any spi message in the queue that
  * needs processing and if so call out to the driver to initialize hardware
@@ -1056,7 +1057,8 @@ EXPORT_SYMBOL_GPL(spi_finalize_current_transfer);
  * inside spi_sync(); the queue extraction handling at the top of the
  * function should deal with this safely.
  */
-static void __spi_pump_messages(struct spi_master *master, bool in_kthread)
+static void __spi_pump_messages(struct spi_master *master, bool in_kthread,
+				bool bus_locked)
 {
 	unsigned long flags;
 	bool was_busy = false;
@@ -1152,7 +1154,9 @@ static void __spi_pump_messages(struct spi_master *master, bool in_kthread)
 		}
 	}
 
-	mutex_lock(&master->bus_lock_mutex);
+	if (!bus_locked)
+		mutex_lock(&master->bus_lock_mutex);
+
 	trace_spi_message_start(master->cur_msg);
 
 	if (master->prepare_message) {
@@ -1162,8 +1166,7 @@ static void __spi_pump_messages(struct spi_master *master, bool in_kthread)
 				"failed to prepare message: %d\n", ret);
 			master->cur_msg->status = ret;
 			spi_finalize_current_message(master);
-			mutex_unlock(&master->bus_lock_mutex);
-			return;
+			goto out;
 		}
 		master->cur_msg_prepared = true;
 	}
@@ -1172,21 +1175,23 @@ static void __spi_pump_messages(struct spi_master *master, bool in_kthread)
 	if (ret) {
 		master->cur_msg->status = ret;
 		spi_finalize_current_message(master);
-		mutex_unlock(&master->bus_lock_mutex);
-		return;
+		goto out;
 	}
 
 	ret = master->transfer_one_message(master, master->cur_msg);
 	if (ret) {
 		dev_err(&master->dev,
 			"failed to transfer one message from queue\n");
-		mutex_unlock(&master->bus_lock_mutex);
-		return;
+		goto out;
 	}
-	mutex_unlock(&master->bus_lock_mutex);
+
+out:
+	if (!bus_locked)
+		mutex_unlock(&master->bus_lock_mutex);
 
 	/* Prod the scheduler in case transfer_one() was busy waiting */
-	cond_resched();
+	if (!ret)
+		cond_resched();
 }
 
 /**
@@ -1198,7 +1203,7 @@ static void spi_pump_messages(struct kthread_work *work)
 	struct spi_master *master =
 		container_of(work, struct spi_master, pump_messages);
 
-	__spi_pump_messages(master, true);
+	__spi_pump_messages(master, true, false);
 }
 
 static int spi_init_queue(struct spi_master *master)
@@ -2462,7 +2467,7 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message,
 						       spi_sync_immediate);
 			SPI_STATISTICS_INCREMENT_FIELD(&spi->statistics,
 						       spi_sync_immediate);
-			__spi_pump_messages(master, false);
+			__spi_pump_messages(master, false, bus_locked);
 		}
 
 		wait_for_completion(&done);

commit 3700ce951c405f748a4767cabe6ac65727cbf767
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Mon Feb 22 20:33:44 2016 +0900

    spi: make xmldocs warning caused by spi.c
    
    This patch fix following warnings while make xmldocs.
    
    .//drivers/spi/spi.c:2354: warning: Excess function parameter
    'message' description in 'spi_split_transfers_maxsize'
    .//drivers/spi/spi.c:2354: warning: Excess function parameter
     'max_size' description in 'spi_split_transfers_maxsize'
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b0c5d45641ec..96c764d7efe6 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2317,8 +2317,8 @@ static int __spi_split_transfer_maxsize(struct spi_master *master,
  *                              when an individual transfer exceeds a
  *                              certain size
  * @master:    the @spi_master for this transfer
- * @message:   the @spi_message to transform
- * @max_size:  the maximum when to apply this
+ * @msg:   the @spi_message to transform
+ * @maxsize:  the maximum when to apply this
  *
  * Return: status of transformation
  */

commit 628269704f19fcfc765499b7158effccfc79b6cf
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Feb 15 18:28:02 2016 +0000

    spi: Add cond_resched() in main message processing loop
    
    When a controller has only PIO support it is very likely that we will
    run into use cases where we spend a very large amount of time consuming
    CPU.  Code that does this should call cond_resched() every once in a
    while to give other tasks more of a chance to run so do that in the main
    SPI loop, the overhead is negligable if it's not needed.
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index dcc6f6e92668..0b2bbf144460 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1184,6 +1184,9 @@ static void __spi_pump_messages(struct spi_master *master, bool in_kthread)
 		return;
 	}
 	mutex_unlock(&master->bus_lock_mutex);
+
+	/* Prod the scheduler in case transfer_one() was busy waiting */
+	cond_resched();
 }
 
 /**

commit 058853979ffc6a1e83c913a692aff8db84f6c417
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Thu Feb 18 15:53:11 2016 +0000

    spi: docbook: add missing parameter documentation
    
    Add missing docbook documentation for the gfp parameter
    in function spi_replace_transfers.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 390d9ee937b6..b0c5d45641ec 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2142,6 +2142,7 @@ static void __spi_replace_transfers_release(struct spi_master *master,
  * @release:       extra release code necessary in some circumstances
  * @extradatasize: extra data to allocate (with alignment guarantees
  *                 of struct @spi_transfer)
+ * @gfp:           gfp flags
  *
  * Returns: pointer to @spi_replaced_transfers,
  *          PTR_ERR(...) in case of errors.

commit c8dab77a1f92095674e4d7fcb151cac4630e10f9
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Wed Feb 17 15:42:28 2016 -0200

    spi: core: Use min_t(size_t,..)
    
    Use min_t(size_t,..) in order to avoid the following
    build warning on ARM64:
    
    include/linux/kernel.h:754:17: warning: comparison of distinct pointer types lacks a cast
      (void) (&_min1 == &_min2);  \
                     ^
    drivers/spi/spi.c:2304:17: note: in expansion of macro 'min'
      xfers[0].len = min(maxsize, xfer[0].len);
    
    Suggested-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Acked-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 9ae199db171b..390d9ee937b6 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2279,7 +2279,7 @@ static int __spi_split_transfer_maxsize(struct spi_master *master,
 	/* the first transfer just needs the length modified, so we
 	 * run it outside the loop
 	 */
-	xfers[0].len = min(maxsize, xfer[0].len);
+	xfers[0].len = min_t(size_t, maxsize, xfer[0].len);
 
 	/* all the others need rx_buf/tx_buf also set */
 	for (i = 1, offset = maxsize; i < count; offset += maxsize, i++) {

commit 7d62f51e74c62afc79f63c70ae48f1b8de57f5d4
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Wed Feb 17 15:42:27 2016 -0200

    spi: core: Use %zu for printing 'size_t' type
    
    Use %zu for printing 'size_t' type in order to fix the following
    build warning on ARM64:
    
    drivers/spi/spi.c: In function '__spi_split_transfer_maxsize':
    drivers/spi/spi.c:2278:2: warning: format '%i' expects argument of type 'int', but argument 4 has type 'size_t' [-Wformat=]
    
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 9490273ed811..9ae199db171b 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2254,7 +2254,7 @@ static int __spi_split_transfer_maxsize(struct spi_master *master,
 
 	/* warn once about this fact that we are splitting a transfer */
 	dev_warn_once(&msg->spi->dev,
-		      "spi_transfer of length %i exceed max length of %i - needed to split transfers\n",
+		      "spi_transfer of length %i exceed max length of %zu - needed to split transfers\n",
 		      xfer->len, maxsize);
 
 	/* calculate how many we have to replace */

commit 08933418d71e52f60859319ef9fb4e6f754297c1
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Sun Feb 14 13:33:50 2016 -0200

    spi: core: Staticize __spi_split_transfer_maxsize()
    
    __spi_split_transfer_maxsize() can be made static as it is only
    used in this file.
    
    This fixes the following sparse warning:
    
    drivers/spi/spi.c:2266:5: warning: symbol '__spi_split_transfer_maxsize' was not declared. Should it be static?
    
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 801e8900898b..9490273ed811 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2241,11 +2241,11 @@ struct spi_replaced_transfers *spi_replace_transfers(
 }
 EXPORT_SYMBOL_GPL(spi_replace_transfers);
 
-int __spi_split_transfer_maxsize(struct spi_master *master,
-				 struct spi_message *msg,
-				 struct spi_transfer **xferp,
-				 size_t maxsize,
-				 gfp_t gfp)
+static int __spi_split_transfer_maxsize(struct spi_master *master,
+					struct spi_message *msg,
+					struct spi_transfer **xferp,
+					size_t maxsize,
+					gfp_t gfp)
 {
 	struct spi_transfer *xfer = *xferp, *xfers;
 	struct spi_replaced_transfers *srt;

commit 657d32efe04197736ed328a34ba659b5172c8cce
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Feb 12 09:38:33 2016 +0300

    spi: checking for NULL instead of IS_ERR
    
    spi_replace_transfers() returns error pointers on error, it never
    returns NULL.
    
    Fixes: d9f121227281 ('spi: core: add spi_split_transfers_maxsize')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 34e3741504f9..801e8900898b 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2262,8 +2262,8 @@ int __spi_split_transfer_maxsize(struct spi_master *master,
 
 	/* create replacement */
 	srt = spi_replace_transfers(msg, xfer, 1, count, NULL, 0, gfp);
-	if (!srt)
-		return -ENOMEM;
+	if (IS_ERR(srt))
+		return PTR_ERR(srt);
 	xfers = srt->inserted_transfers;
 
 	/* now handle each of those newly inserted spi_transfers

commit 556351f14e74db4cd3ddde386457edce7bf0b27f
Author: Vignesh R <vigneshr@ti.com>
Date:   Fri Dec 11 09:39:56 2015 +0530

    spi: introduce accelerated read support for spi flash devices
    
    In addition to providing direct access to SPI bus, some spi controller
    hardwares (like ti-qspi) provide special port (like memory mapped port)
    that are optimized to improve SPI flash read performance.
    This means the controller can automatically send the SPI signals
    required to read data from the SPI flash device.
    For this, SPI controller needs to know flash specific information like
    read command to use, dummy bytes and address width.
    
    Introduce spi_flash_read() interface to support accelerated read
    over SPI flash devices. SPI master drivers can implement this callback to
    support interfaces such as memory mapped read etc. m25p80 flash driver
    and other flash drivers can call this make use of such interfaces. The
    interface should only be used with SPI flashes and cannot be used with
    other SPI devices.
    
    Signed-off-by: Vignesh R <vigneshr@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 47eff8012a77..dcc6f6e92668 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1152,6 +1152,7 @@ static void __spi_pump_messages(struct spi_master *master, bool in_kthread)
 		}
 	}
 
+	mutex_lock(&master->bus_lock_mutex);
 	trace_spi_message_start(master->cur_msg);
 
 	if (master->prepare_message) {
@@ -1161,6 +1162,7 @@ static void __spi_pump_messages(struct spi_master *master, bool in_kthread)
 				"failed to prepare message: %d\n", ret);
 			master->cur_msg->status = ret;
 			spi_finalize_current_message(master);
+			mutex_unlock(&master->bus_lock_mutex);
 			return;
 		}
 		master->cur_msg_prepared = true;
@@ -1170,6 +1172,7 @@ static void __spi_pump_messages(struct spi_master *master, bool in_kthread)
 	if (ret) {
 		master->cur_msg->status = ret;
 		spi_finalize_current_message(master);
+		mutex_unlock(&master->bus_lock_mutex);
 		return;
 	}
 
@@ -1177,8 +1180,10 @@ static void __spi_pump_messages(struct spi_master *master, bool in_kthread)
 	if (ret) {
 		dev_err(&master->dev,
 			"failed to transfer one message from queue\n");
+		mutex_unlock(&master->bus_lock_mutex);
 		return;
 	}
+	mutex_unlock(&master->bus_lock_mutex);
 }
 
 /**
@@ -2351,6 +2356,46 @@ int spi_async_locked(struct spi_device *spi, struct spi_message *message)
 EXPORT_SYMBOL_GPL(spi_async_locked);
 
 
+int spi_flash_read(struct spi_device *spi,
+		   struct spi_flash_read_message *msg)
+
+{
+	struct spi_master *master = spi->master;
+	int ret;
+
+	if ((msg->opcode_nbits == SPI_NBITS_DUAL ||
+	     msg->addr_nbits == SPI_NBITS_DUAL) &&
+	    !(spi->mode & (SPI_TX_DUAL | SPI_TX_QUAD)))
+		return -EINVAL;
+	if ((msg->opcode_nbits == SPI_NBITS_QUAD ||
+	     msg->addr_nbits == SPI_NBITS_QUAD) &&
+	    !(spi->mode & SPI_TX_QUAD))
+		return -EINVAL;
+	if (msg->data_nbits == SPI_NBITS_DUAL &&
+	    !(spi->mode & (SPI_RX_DUAL | SPI_RX_QUAD)))
+		return -EINVAL;
+	if (msg->data_nbits == SPI_NBITS_QUAD &&
+	    !(spi->mode &  SPI_RX_QUAD))
+		return -EINVAL;
+
+	if (master->auto_runtime_pm) {
+		ret = pm_runtime_get_sync(master->dev.parent);
+		if (ret < 0) {
+			dev_err(&master->dev, "Failed to power device: %d\n",
+				ret);
+			return ret;
+		}
+	}
+	mutex_lock(&master->bus_lock_mutex);
+	ret = master->spi_flash_read(spi, msg);
+	mutex_unlock(&master->bus_lock_mutex);
+	if (master->auto_runtime_pm)
+		pm_runtime_put(master->dev.parent);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(spi_flash_read);
+
 /*-------------------------------------------------------------------------*/
 
 /* Utility methods for SPI master protocol drivers, layered on

commit d9f1212272818420fcde611a940c1ad611a8b785
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Mon Dec 14 15:20:20 2015 +0000

    spi: core: add spi_split_transfers_maxsize
    
    Add spi_split_transfers_maxsize method that splits
    spi_transfers transparently into multiple transfers
    that are below the given max-size.
    
    This makes use of the spi_res framework via
    spi_replace_transfers to allocate/free the extra
    transfers as well as reverting back the changes applied
    while processing the spi_message.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 2ec8e66a8098..34e3741504f9 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -144,6 +144,8 @@ SPI_STATISTICS_TRANSFER_BYTES_HISTO(14, "16384-32767");
 SPI_STATISTICS_TRANSFER_BYTES_HISTO(15, "32768-65535");
 SPI_STATISTICS_TRANSFER_BYTES_HISTO(16, "65536+");
 
+SPI_STATISTICS_SHOW(transfers_split_maxsize, "%lu");
+
 static struct attribute *spi_dev_attrs[] = {
 	&dev_attr_modalias.attr,
 	NULL,
@@ -181,6 +183,7 @@ static struct attribute *spi_device_statistics_attrs[] = {
 	&dev_attr_spi_device_transfer_bytes_histo14.attr,
 	&dev_attr_spi_device_transfer_bytes_histo15.attr,
 	&dev_attr_spi_device_transfer_bytes_histo16.attr,
+	&dev_attr_spi_device_transfers_split_maxsize.attr,
 	NULL,
 };
 
@@ -223,6 +226,7 @@ static struct attribute *spi_master_statistics_attrs[] = {
 	&dev_attr_spi_master_transfer_bytes_histo14.attr,
 	&dev_attr_spi_master_transfer_bytes_histo15.attr,
 	&dev_attr_spi_master_transfer_bytes_histo16.attr,
+	&dev_attr_spi_master_transfers_split_maxsize.attr,
 	NULL,
 };
 
@@ -2237,6 +2241,113 @@ struct spi_replaced_transfers *spi_replace_transfers(
 }
 EXPORT_SYMBOL_GPL(spi_replace_transfers);
 
+int __spi_split_transfer_maxsize(struct spi_master *master,
+				 struct spi_message *msg,
+				 struct spi_transfer **xferp,
+				 size_t maxsize,
+				 gfp_t gfp)
+{
+	struct spi_transfer *xfer = *xferp, *xfers;
+	struct spi_replaced_transfers *srt;
+	size_t offset;
+	size_t count, i;
+
+	/* warn once about this fact that we are splitting a transfer */
+	dev_warn_once(&msg->spi->dev,
+		      "spi_transfer of length %i exceed max length of %i - needed to split transfers\n",
+		      xfer->len, maxsize);
+
+	/* calculate how many we have to replace */
+	count = DIV_ROUND_UP(xfer->len, maxsize);
+
+	/* create replacement */
+	srt = spi_replace_transfers(msg, xfer, 1, count, NULL, 0, gfp);
+	if (!srt)
+		return -ENOMEM;
+	xfers = srt->inserted_transfers;
+
+	/* now handle each of those newly inserted spi_transfers
+	 * note that the replacements spi_transfers all are preset
+	 * to the same values as *xferp, so tx_buf, rx_buf and len
+	 * are all identical (as well as most others)
+	 * so we just have to fix up len and the pointers.
+	 *
+	 * this also includes support for the depreciated
+	 * spi_message.is_dma_mapped interface
+	 */
+
+	/* the first transfer just needs the length modified, so we
+	 * run it outside the loop
+	 */
+	xfers[0].len = min(maxsize, xfer[0].len);
+
+	/* all the others need rx_buf/tx_buf also set */
+	for (i = 1, offset = maxsize; i < count; offset += maxsize, i++) {
+		/* update rx_buf, tx_buf and dma */
+		if (xfers[i].rx_buf)
+			xfers[i].rx_buf += offset;
+		if (xfers[i].rx_dma)
+			xfers[i].rx_dma += offset;
+		if (xfers[i].tx_buf)
+			xfers[i].tx_buf += offset;
+		if (xfers[i].tx_dma)
+			xfers[i].tx_dma += offset;
+
+		/* update length */
+		xfers[i].len = min(maxsize, xfers[i].len - offset);
+	}
+
+	/* we set up xferp to the last entry we have inserted,
+	 * so that we skip those already split transfers
+	 */
+	*xferp = &xfers[count - 1];
+
+	/* increment statistics counters */
+	SPI_STATISTICS_INCREMENT_FIELD(&master->statistics,
+				       transfers_split_maxsize);
+	SPI_STATISTICS_INCREMENT_FIELD(&msg->spi->statistics,
+				       transfers_split_maxsize);
+
+	return 0;
+}
+
+/**
+ * spi_split_tranfers_maxsize - split spi transfers into multiple transfers
+ *                              when an individual transfer exceeds a
+ *                              certain size
+ * @master:    the @spi_master for this transfer
+ * @message:   the @spi_message to transform
+ * @max_size:  the maximum when to apply this
+ *
+ * Return: status of transformation
+ */
+int spi_split_transfers_maxsize(struct spi_master *master,
+				struct spi_message *msg,
+				size_t maxsize,
+				gfp_t gfp)
+{
+	struct spi_transfer *xfer;
+	int ret;
+
+	/* iterate over the transfer_list,
+	 * but note that xfer is advanced to the last transfer inserted
+	 * to avoid checking sizes again unnecessarily (also xfer does
+	 * potentiall belong to a different list by the time the
+	 * replacement has happened
+	 */
+	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		if (xfer->len > maxsize) {
+			ret = __spi_split_transfer_maxsize(
+				master, msg, &xfer, maxsize, gfp);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(spi_split_transfers_maxsize);
+
 /*-------------------------------------------------------------------------*/
 
 /* Core methods for SPI master protocol drivers.  Some of the

commit 523baf5a0609690cb742b3662b7ccac0ea0b2ef2
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Mon Dec 14 15:20:19 2015 +0000

    spi: core: add spi_replace_transfers method
    
    Add the spi_replace_transfers method that can get used
    to replace some spi_transfers from a spi_message with other
    transfers.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 894ed0357dd7..2ec8e66a8098 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2107,6 +2107,138 @@ EXPORT_SYMBOL_GPL(spi_res_release);
 
 /*-------------------------------------------------------------------------*/
 
+/* Core methods for spi_message alterations */
+
+static void __spi_replace_transfers_release(struct spi_master *master,
+					    struct spi_message *msg,
+					    void *res)
+{
+	struct spi_replaced_transfers *rxfer = res;
+	size_t i;
+
+	/* call extra callback if requested */
+	if (rxfer->release)
+		rxfer->release(master, msg, res);
+
+	/* insert replaced transfers back into the message */
+	list_splice(&rxfer->replaced_transfers, rxfer->replaced_after);
+
+	/* remove the formerly inserted entries */
+	for (i = 0; i < rxfer->inserted; i++)
+		list_del(&rxfer->inserted_transfers[i].transfer_list);
+}
+
+/**
+ * spi_replace_transfers - replace transfers with several transfers
+ *                         and register change with spi_message.resources
+ * @msg:           the spi_message we work upon
+ * @xfer_first:    the first spi_transfer we want to replace
+ * @remove:        number of transfers to remove
+ * @insert:        the number of transfers we want to insert instead
+ * @release:       extra release code necessary in some circumstances
+ * @extradatasize: extra data to allocate (with alignment guarantees
+ *                 of struct @spi_transfer)
+ *
+ * Returns: pointer to @spi_replaced_transfers,
+ *          PTR_ERR(...) in case of errors.
+ */
+struct spi_replaced_transfers *spi_replace_transfers(
+	struct spi_message *msg,
+	struct spi_transfer *xfer_first,
+	size_t remove,
+	size_t insert,
+	spi_replaced_release_t release,
+	size_t extradatasize,
+	gfp_t gfp)
+{
+	struct spi_replaced_transfers *rxfer;
+	struct spi_transfer *xfer;
+	size_t i;
+
+	/* allocate the structure using spi_res */
+	rxfer = spi_res_alloc(msg->spi, __spi_replace_transfers_release,
+			      insert * sizeof(struct spi_transfer)
+			      + sizeof(struct spi_replaced_transfers)
+			      + extradatasize,
+			      gfp);
+	if (!rxfer)
+		return ERR_PTR(-ENOMEM);
+
+	/* the release code to invoke before running the generic release */
+	rxfer->release = release;
+
+	/* assign extradata */
+	if (extradatasize)
+		rxfer->extradata =
+			&rxfer->inserted_transfers[insert];
+
+	/* init the replaced_transfers list */
+	INIT_LIST_HEAD(&rxfer->replaced_transfers);
+
+	/* assign the list_entry after which we should reinsert
+	 * the @replaced_transfers - it may be spi_message.messages!
+	 */
+	rxfer->replaced_after = xfer_first->transfer_list.prev;
+
+	/* remove the requested number of transfers */
+	for (i = 0; i < remove; i++) {
+		/* if the entry after replaced_after it is msg->transfers
+		 * then we have been requested to remove more transfers
+		 * than are in the list
+		 */
+		if (rxfer->replaced_after->next == &msg->transfers) {
+			dev_err(&msg->spi->dev,
+				"requested to remove more spi_transfers than are available\n");
+			/* insert replaced transfers back into the message */
+			list_splice(&rxfer->replaced_transfers,
+				    rxfer->replaced_after);
+
+			/* free the spi_replace_transfer structure */
+			spi_res_free(rxfer);
+
+			/* and return with an error */
+			return ERR_PTR(-EINVAL);
+		}
+
+		/* remove the entry after replaced_after from list of
+		 * transfers and add it to list of replaced_transfers
+		 */
+		list_move_tail(rxfer->replaced_after->next,
+			       &rxfer->replaced_transfers);
+	}
+
+	/* create copy of the given xfer with identical settings
+	 * based on the first transfer to get removed
+	 */
+	for (i = 0; i < insert; i++) {
+		/* we need to run in reverse order */
+		xfer = &rxfer->inserted_transfers[insert - 1 - i];
+
+		/* copy all spi_transfer data */
+		memcpy(xfer, xfer_first, sizeof(*xfer));
+
+		/* add to list */
+		list_add(&xfer->transfer_list, rxfer->replaced_after);
+
+		/* clear cs_change and delay_usecs for all but the last */
+		if (i) {
+			xfer->cs_change = false;
+			xfer->delay_usecs = 0;
+		}
+	}
+
+	/* set up inserted */
+	rxfer->inserted = insert;
+
+	/* and register it with spi_res/spi_message */
+	spi_res_add(msg, rxfer);
+
+	return rxfer;
+}
+EXPORT_SYMBOL_GPL(spi_replace_transfers);
+
+/*-------------------------------------------------------------------------*/
+
 /* Core methods for SPI master protocol drivers.  Some of the
  * other core methods are currently defined as inline functions.
  */

commit d780c3711d9df9bacd56b71cf23443b895a331ca
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Mon Dec 14 15:20:18 2015 +0000

    spi: core: added spi_resource management
    
    SPI resource management framework used while processing a spi_message
    via the spi-core.
    
    The basic idea is taken from devres, but as the allocation may happen
    fairly frequently, some provisioning (in the form of an unused spi_device
    pointer argument to spi_res_alloc) has been made so that at a later stage
    we may implement reuse objects allocated earlier avoiding the repeated
    allocation by keeping a cache of objects that we can reuse.
    
    This framework can get used for:
    * rewriting spi_messages
      * to fullfill alignment requirements of the spi_master HW
      * to fullfill transfer length requirements
        (e.g: transfers need to be less than 64k)
      * consolidate spi_messages with multiple transfers into a single transfer
      when the total transfer length is below a threshold.
    * reimplement spi_unmap_buf without explicitly needing to check if it has
      been mapped
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 47eff8012a77..894ed0357dd7 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1024,6 +1024,8 @@ static int spi_transfer_one_message(struct spi_master *master,
 	if (msg->status && master->handle_err)
 		master->handle_err(master, msg);
 
+	spi_res_release(master, msg);
+
 	spi_finalize_current_message(master);
 
 	return ret;
@@ -2013,6 +2015,95 @@ struct spi_master *spi_busnum_to_master(u16 bus_num)
 }
 EXPORT_SYMBOL_GPL(spi_busnum_to_master);
 
+/*-------------------------------------------------------------------------*/
+
+/* Core methods for SPI resource management */
+
+/**
+ * spi_res_alloc - allocate a spi resource that is life-cycle managed
+ *                 during the processing of a spi_message while using
+ *                 spi_transfer_one
+ * @spi:     the spi device for which we allocate memory
+ * @release: the release code to execute for this resource
+ * @size:    size to alloc and return
+ * @gfp:     GFP allocation flags
+ *
+ * Return: the pointer to the allocated data
+ *
+ * This may get enhanced in the future to allocate from a memory pool
+ * of the @spi_device or @spi_master to avoid repeated allocations.
+ */
+void *spi_res_alloc(struct spi_device *spi,
+		    spi_res_release_t release,
+		    size_t size, gfp_t gfp)
+{
+	struct spi_res *sres;
+
+	sres = kzalloc(sizeof(*sres) + size, gfp);
+	if (!sres)
+		return NULL;
+
+	INIT_LIST_HEAD(&sres->entry);
+	sres->release = release;
+
+	return sres->data;
+}
+EXPORT_SYMBOL_GPL(spi_res_alloc);
+
+/**
+ * spi_res_free - free an spi resource
+ * @res: pointer to the custom data of a resource
+ *
+ */
+void spi_res_free(void *res)
+{
+	struct spi_res *sres = container_of(res, struct spi_res, data);
+
+	if (!res)
+		return;
+
+	WARN_ON(!list_empty(&sres->entry));
+	kfree(sres);
+}
+EXPORT_SYMBOL_GPL(spi_res_free);
+
+/**
+ * spi_res_add - add a spi_res to the spi_message
+ * @message: the spi message
+ * @res:     the spi_resource
+ */
+void spi_res_add(struct spi_message *message, void *res)
+{
+	struct spi_res *sres = container_of(res, struct spi_res, data);
+
+	WARN_ON(!list_empty(&sres->entry));
+	list_add_tail(&sres->entry, &message->resources);
+}
+EXPORT_SYMBOL_GPL(spi_res_add);
+
+/**
+ * spi_res_release - release all spi resources for this message
+ * @master:  the @spi_master
+ * @message: the @spi_message
+ */
+void spi_res_release(struct spi_master *master,
+		     struct spi_message *message)
+{
+	struct spi_res *res;
+
+	while (!list_empty(&message->resources)) {
+		res = list_last_entry(&message->resources,
+				      struct spi_res, entry);
+
+		if (res->release)
+			res->release(master, message, res->data);
+
+		list_del(&res->entry);
+
+		kfree(res);
+	}
+}
+EXPORT_SYMBOL_GPL(spi_res_release);
 
 /*-------------------------------------------------------------------------*/
 

commit a0a90718f18264dc904d34a580f332006f5561e9
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Feb 8 17:14:28 2016 +0200

    spi: Let drivers translate ACPI DeviceSelection to suitable Linux chip select
    
    In Windows it is up to the SPI host controller driver to handle the ACPI
    DeviceSelection as it likes. The SPI core does not take any part in it.
    This is different in Linux because we always expect to have chip select in
    range of 0 .. master->num_chipselect - 1.
    
    In order to support this in Linux we need a way to allow the driver to
    translate between ACPI DeviceSelection field and Linux chip select number
    so provide a new optional hook ->fw_translate_cs() that can be used by a
    driver to handle translation and call this hook if set during SPI slave
    ACPI enumeration.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 47eff8012a77..2c0c26a57f03 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1581,13 +1581,30 @@ static void of_register_spi_devices(struct spi_master *master) { }
 static int acpi_spi_add_resource(struct acpi_resource *ares, void *data)
 {
 	struct spi_device *spi = data;
+	struct spi_master *master = spi->master;
 
 	if (ares->type == ACPI_RESOURCE_TYPE_SERIAL_BUS) {
 		struct acpi_resource_spi_serialbus *sb;
 
 		sb = &ares->data.spi_serial_bus;
 		if (sb->type == ACPI_RESOURCE_SERIAL_TYPE_SPI) {
-			spi->chip_select = sb->device_selection;
+			/*
+			 * ACPI DeviceSelection numbering is handled by the
+			 * host controller driver in Windows and can vary
+			 * from driver to driver. In Linux we always expect
+			 * 0 .. max - 1 so we need to ask the driver to
+			 * translate between the two schemes.
+			 */
+			if (master->fw_translate_cs) {
+				int cs = master->fw_translate_cs(master,
+						sb->device_selection);
+				if (cs < 0)
+					return cs;
+				spi->chip_select = cs;
+			} else {
+				spi->chip_select = sb->device_selection;
+			}
+
 			spi->max_speed_hz = sb->connection_speed;
 
 			if (sb->clock_phase == ACPI_SPI_SECOND_PHASE)

commit 50ae833e471fe1a1a906a0342bdaa690e69fcc19
Merge: ac53b2e053ff cabeea980879
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 13 11:38:27 2016 -0800

    Merge tag 'spi-v4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi
    
    Pull spi updates from Mark Brown:
     "A quiet release for SPI, not even many driver updates:
    
       - Add a dummy loopback driver for use in exercising framework
         features during development.
    
       - Move the test utilities to tools/ and add support for transferring
         data to and from a file instead of stdin and stdout to spidev_test.
    
       - Support for Mediatek MT2701 and Renesas AG5 deices"
    
    * tag 'spi-v4.5' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi: (69 commits)
      spi: loopback: fix typo in MODULE_PARM_DESC
      spi: sun4i: Prevent chip-select from being activated twice before a transfer
      spi: loopback-test: spi_check_rx_ranges can get always done
      spi: loopback-test: rename method spi_test_fill_tx to spi_test_fill_pattern
      spi: loopback-test: write rx pattern also when running without tx_buf
      spi: fsl-espi: expose maximum transfer size limit
      spi: expose master transfer size limitation.
      spi: zynq: use to_platform_device()
      spi: cadence: use to_platform_device()
      spi: mediatek: Add spi support for mt2701 IC
      spi: mediatek: merge all identical compat to mtk_common_compat
      spi: mtk: Add bindings for mediatek MT2701 soc platform
      spi: mediatek: Prevent overflows in FIFO transfers
      spi: s3c64xx: Remove unused platform_device_id entries
      spi: use to_spi_device
      spi: dw: Use SPI_TMOD_TR rather than magic const 0 to set tmode
      spi: imx: defer spi initialization, if DMA engine is
      spi: imx: return error from dma channel request
      spi: imx: enable loopback only for ECSPI controller family
      spi: imx: fix loopback mode setup after controller reset
      ...

commit 4f9530705b7b9c977044accb035682d9f7df1cdd
Merge: 41d5a700514f bd6c1644a2f6 d599af65fda3 cc023478dc8a ec7f9eb4bea2 edd3899c8cd2
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Jan 11 16:48:35 2016 +0000

    Merge remote-tracking branches 'spi/topic/overlay', 'spi/topic/pxa2xx', 'spi/topic/s3c64xx', 'spi/topic/sh-msiof' and 'spi/topic/spidev' into spi-next

commit 174c21163d83f730f7e0194d4682d5149946a7f8
Merge: f30f072a5f3c d1eba93bd0fc
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Jan 11 16:48:29 2016 +0000

    Merge remote-tracking branch 'spi/topic/core' into spi-next

commit 33ada67da352e138b6dbb372dccad6c3f13b15b2
Author: Christophe RICARD <christophe.ricard@gmail.com>
Date:   Wed Dec 23 23:25:35 2015 +0100

    ACPI / spi: attach GPIO IRQ from ACPI description to SPI device
    
    spi->irq was ignoring GpioInt property setting it to -1.
    acpi_dev_gpio_irq_get returns and configure the slave IRQ according to
    the ACPI slave node description.
    
    It is now inline with devicetree behavior.
    
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Christophe Ricard <christophe-h.ricard@st.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index dee1cb87d24f..151b01c25b40 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1623,6 +1623,9 @@ static acpi_status acpi_spi_add_device(acpi_handle handle, u32 level,
 		return AE_OK;
 	}
 
+	if (spi->irq < 0)
+		spi->irq = acpi_dev_gpio_irq_get(adev, 0);
+
 	adev->power.flags.ignore_parent = true;
 	strlcpy(spi->modalias, acpi_device_hid(adev), sizeof(spi->modalias));
 	if (spi_add_device(spi)) {

commit d1eba93bd0fcd3f699cb8d666bc97788ee85d557
Author: Geliang Tang <geliangtang@163.com>
Date:   Wed Dec 23 00:18:41 2015 +0800

    spi: use to_spi_device
    
    Use to_spi_device() instead of open-coding it.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index e2415be209d5..70828521e6bb 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -84,8 +84,7 @@ static ssize_t spi_device_##field##_show(struct device *dev,		\
 					 struct device_attribute *attr,	\
 					char *buf)			\
 {									\
-	struct spi_device *spi = container_of(dev,			\
-					      struct spi_device, dev);	\
+	struct spi_device *spi = to_spi_device(dev);			\
 	return spi_statistics_##field##_show(&spi->statistics, buf);	\
 }									\
 static struct device_attribute dev_attr_spi_device_##field = {		\

commit 9ce5db27f4a959ca58d768c5c8e5c98a47361e67
Merge: 9f9499ae8e64 157f38f99391
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Dec 16 13:28:31 2015 +0000

    Merge remote-tracking branch 'spi/fix/core' into spi-linus

commit 157f38f993919b648187ba341bfb05d0e91ad2f6
Author: Johan Hovold <johan@kernel.org>
Date:   Mon Dec 14 16:16:19 2015 +0100

    spi: fix parent-device reference leak
    
    Fix parent-device reference leak due to SPI-core taking an unnecessary
    reference to the parent when allocating the master structure, a
    reference that was never released.
    
    Note that driver core takes its own reference to the parent when the
    master device is registered.
    
    Fixes: 49dce689ad4e ("spi doesn't need class_device")
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index e2415be209d5..7bf25274ad78 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1704,7 +1704,7 @@ struct spi_master *spi_alloc_master(struct device *dev, unsigned size)
 	master->bus_num = -1;
 	master->num_chipselect = 1;
 	master->dev.class = &spi_master_class;
-	master->dev.parent = get_device(dev);
+	master->dev.parent = dev;
 	spi_master_set_devdata(master, &master[1]);
 
 	return master;

commit bd6c1644a2f6f46cdf89388e81168a70711fce3a
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Nov 30 15:28:07 2015 +0100

    spi: Mark instantiated device nodes with OF_POPULATE
    
    Mark (and unmark) device nodes with the POPULATE flag as appropriate.
    This is required to avoid multi probing when enabling and populating SPI
    buses in DT overlays.
    
    Based on commit 4f001fd30145a6a8 ("i2c: Mark instantiated device nodes
    with OF_POPULATE").
    
    Suggested-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 3f135cc9a70e..c7486a373af1 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -613,8 +613,12 @@ EXPORT_SYMBOL_GPL(spi_new_device);
  */
 void spi_unregister_device(struct spi_device *spi)
 {
-	if (spi)
-		device_unregister(&spi->dev);
+	if (!spi)
+		return;
+
+	if (spi->dev.of_node)
+		of_node_clear_flag(spi->dev.of_node, OF_POPULATED);
+	device_unregister(&spi->dev);
 }
 EXPORT_SYMBOL_GPL(spi_unregister_device);
 
@@ -1561,6 +1565,8 @@ static void of_register_spi_devices(struct spi_master *master)
 		return;
 
 	for_each_available_child_of_node(master->dev.of_node, nc) {
+		if (of_node_test_and_set_flag(nc, OF_POPULATED))
+			continue;
 		spi = of_register_spi_device(master, nc);
 		if (IS_ERR(spi))
 			dev_warn(&master->dev, "Failed to create SPI device for %s\n",
@@ -2645,6 +2651,11 @@ static int of_spi_notify(struct notifier_block *nb, unsigned long action,
 		if (master == NULL)
 			return NOTIFY_OK;	/* not for us */
 
+		if (of_node_test_and_set_flag(rd->dn, OF_POPULATED)) {
+			put_device(&master->dev);
+			return NOTIFY_OK;
+		}
+
 		spi = of_register_spi_device(master, rd->dn);
 		put_device(&master->dev);
 
@@ -2656,6 +2667,10 @@ static int of_spi_notify(struct notifier_block *nb, unsigned long action,
 		break;
 
 	case OF_RECONFIG_CHANGE_REMOVE:
+		/* already depopulated? */
+		if (!of_node_check_flag(rd->dn, OF_POPULATED))
+			return NOTIFY_OK;
+
 		/* find our device by node */
 		spi = of_find_spi_device_by_node(rd->dn);
 		if (spi == NULL)

commit 3b1884c24c98dada51fc4b05735773f0078711d2
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Nov 30 15:28:06 2015 +0100

    spi: Uninline spi_unregister_device()
    
    Uninline spi_unregister_device() in preparation of adding more code to
    it. Add kerneldoc documentation while we're at it.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index e2415be209d5..3f135cc9a70e 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -604,6 +604,20 @@ struct spi_device *spi_new_device(struct spi_master *master,
 }
 EXPORT_SYMBOL_GPL(spi_new_device);
 
+/**
+ * spi_unregister_device - unregister a single SPI device
+ * @spi: spi_device to unregister
+ *
+ * Start making the passed SPI device vanish. Normally this would be handled
+ * by spi_unregister_master().
+ */
+void spi_unregister_device(struct spi_device *spi)
+{
+	if (spi)
+		device_unregister(&spi->dev);
+}
+EXPORT_SYMBOL_GPL(spi_unregister_device);
+
 static void spi_match_master_to_boardinfo(struct spi_master *master,
 				struct spi_board_info *bi)
 {

commit a057d737d6ad64c47eb60d7c058cdab6585e96a6
Merge: 9f28b3c6ae70 0ba2cf70d234 88c9321d1ddb 98c8dccf2b27 f3d4bb334263
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Nov 30 12:26:47 2015 +0000

    Merge remote-tracking branches 'spi/fix/bcm63xx', 'spi/fix/doc', 'spi/fix/mediatek' and 'spi/fix/pl022' into spi-linus

commit 77e8058810303e5c18b462adb4f761dbb4f3b657
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Fri Nov 27 12:31:09 2015 +0000

    spi: bugfix: spi_message.transfer_length does not get reset
    
    When submitting an identical spi_message multiple times via spi_sync
    the spi_message.frame_length does not get reset to 0 in __spi_validate
    before adding up all spi_transfer.len resulting in
    frame_length > actual_length on all but the first spi_sync call.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index e2415be209d5..a0e346f3b71e 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2130,6 +2130,7 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 	 * Set transfer tx_nbits and rx_nbits as single transfer default
 	 * (SPI_NBITS_SINGLE) if it is not set for this transfer.
 	 */
+	message->frame_length = 0;
 	list_for_each_entry(xfer, &message->transfers, transfer_list) {
 		message->frame_length += xfer->len;
 		if (!xfer->bits_per_word)

commit 88c9321d1ddb9c9539f1ef5da86a35604eb153d5
Author: Thierry Reding <treding@nvidia.com>
Date:   Tue Nov 10 13:03:04 2015 +0100

    spi: Add missing kerneldoc description for parameter
    
    Commit ca5d24854210 ("spi: Add THIS_MODULE to spi_driver in SPI core")
    adds the new __spi_register_driver() function, but keeps the kerneldoc
    for the spi_register_driver() function in place and forgets to add the
    description for the new owner parameter.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index e2415be209d5..20ef4693d48f 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -376,6 +376,7 @@ static void spi_drv_shutdown(struct device *dev)
 
 /**
  * __spi_register_driver - register a SPI driver
+ * @owner: owner module of the driver to register
  * @sdrv: the driver to register
  * Context: can sleep
  *

commit 4c84518523f888994c618585021c76fa499d465e
Merge: fc579056af0b 76f67ea9bf27 160f8d069165 3821a065f567 54bf4505bd64 0db642151ad8
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Nov 4 11:02:12 2015 +0000

    Merge remote-tracking branches 'spi/topic/omap-100k', 'spi/topic/omap-uwire', 'spi/topic/owner', 'spi/topic/pxa' and 'spi/topic/pxa2xx' into spi-next

commit 8c603485752ae844748db94148adc2b46e621d28
Merge: f0a2a049f5e3 97d56dc68268
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Nov 4 11:02:03 2015 +0000

    Merge remote-tracking branch 'spi/topic/doc' into spi-next

commit 3e7018def475847418596c76997e0708bacda2c0
Merge: 5ba838c97ba1 243f07be2423
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Nov 4 11:02:02 2015 +0000

    Merge remote-tracking branch 'spi/topic/core' into spi-next

commit 26cc44f8a366a7fbebed3b98f499c2774bfcda44
Merge: 6a13feb9c828 abeedb0159ee
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Nov 4 11:01:58 2015 +0000

    Merge remote-tracking branch 'spi/fix/core' into spi-linus

commit ca5d24854210dd02548a080d4271560e926c4fcb
Author: Andrew F. Davis <afd@ti.com>
Date:   Fri Oct 23 08:59:10 2015 -0500

    spi: Add THIS_MODULE to spi_driver in SPI core
    
    Add spi_register_driver helper macro that adds THIS_MODULE to
    spi_driver for the registering driver. We rename and modify
    the existing spi_register_driver to enable this.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 3abb3903f2ad..51e33dbe4e05 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -305,12 +305,13 @@ static void spi_drv_shutdown(struct device *dev)
 }
 
 /**
- * spi_register_driver - register a SPI driver
+ * __spi_register_driver - register a SPI driver
  * @sdrv: the driver to register
  * Context: can sleep
  */
-int spi_register_driver(struct spi_driver *sdrv)
+int __spi_register_driver(struct module *owner, struct spi_driver *sdrv)
 {
+	sdrv->driver.owner = owner;
 	sdrv->driver.bus = &spi_bus_type;
 	if (sdrv->probe)
 		sdrv->driver.probe = spi_drv_probe;
@@ -320,7 +321,7 @@ int spi_register_driver(struct spi_driver *sdrv)
 		sdrv->driver.shutdown = spi_drv_shutdown;
 	return driver_register(&sdrv->driver);
 }
-EXPORT_SYMBOL_GPL(spi_register_driver);
+EXPORT_SYMBOL_GPL(__spi_register_driver);
 
 /*-------------------------------------------------------------------------*/
 

commit abeedb0159eec42c52a28fc44457164f71aa12a9
Author: Franklin S Cooper Jr <fcooper@ti.com>
Date:   Fri Oct 16 10:29:03 2015 -0500

    spi: Setup the master controller driver before setting the chipselect
    
    SPI controllers may need to be properly setup before chip selects
    can be used. Therefore, wait until the spi controller has a chance
    to perform their setup procedure before trying to use the chip
    select.
    
    This also insures that the chip selects pins are in a good
    state before asseting them which otherwise may cause confusion.
    
    Signed-off-by: Franklin S Cooper Jr <fcooper@ti.com>
    Tested-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Tested-by: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 3abb3903f2ad..7b528b0aedb9 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1993,11 +1993,11 @@ int spi_setup(struct spi_device *spi)
 	if (!spi->max_speed_hz)
 		spi->max_speed_hz = spi->master->max_speed_hz;
 
-	spi_set_cs(spi, false);
-
 	if (spi->master->setup)
 		status = spi->master->setup(spi);
 
+	spi_set_cs(spi, false);
+
 	dev_dbg(&spi->dev, "setup mode %d, %s%s%s%s%u bits/w, %u Hz max --> %d\n",
 			(int) (spi->mode & (SPI_CPOL | SPI_CPHA)),
 			(spi->mode & SPI_CS_HIGH) ? "cs_high, " : "",

commit 97d56dc6826896852dae1a2bdab7a42ecde32c6f
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Thu Oct 22 18:59:23 2015 +0200

    spi: fix kernel-doc warnings about missing return desc in spi.c
    
    When building docs with make htmldocs, warnings about not having
    a description for the return value are reported, i.e:
    
    warning: No description found for return value of 'spi_register_driver'
    
    Fix these by following the kernel-doc conventions explained in
    Documentation/kernel-doc-nano-HOWTO.txt.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 11454d5aef95..74825db6fdd0 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -378,6 +378,8 @@ static void spi_drv_shutdown(struct device *dev)
  * spi_register_driver - register a SPI driver
  * @sdrv: the driver to register
  * Context: can sleep
+ *
+ * Return: zero on success, else a negative error code.
  */
 int spi_register_driver(struct spi_driver *sdrv)
 {
@@ -429,7 +431,7 @@ static DEFINE_MUTEX(board_lock);
  * needs to discard the spi_device without adding it, then it should
  * call spi_dev_put() on it.
  *
- * Returns a pointer to the new device, or NULL.
+ * Return: a pointer to the new device, or NULL.
  */
 struct spi_device *spi_alloc_device(struct spi_master *master)
 {
@@ -488,7 +490,7 @@ static int spi_dev_check(struct device *dev, void *data)
  * Companion function to spi_alloc_device.  Devices allocated with
  * spi_alloc_device can be added onto the spi bus with this function.
  *
- * Returns 0 on success; negative errno on failure
+ * Return: 0 on success; negative errno on failure
  */
 int spi_add_device(struct spi_device *spi)
 {
@@ -561,7 +563,7 @@ EXPORT_SYMBOL_GPL(spi_add_device);
  * this is exported so that for example a USB or parport based adapter
  * driver could add devices (which it would learn about out-of-band).
  *
- * Returns the new device, or NULL.
+ * Return: the new device, or NULL.
  */
 struct spi_device *spi_new_device(struct spi_master *master,
 				  struct spi_board_info *chip)
@@ -633,6 +635,8 @@ static void spi_match_master_to_boardinfo(struct spi_master *master,
  *
  * The board info passed can safely be __initdata ... but be careful of
  * any embedded pointers (platform_data, etc), they're copied as-is.
+ *
+ * Return: zero on success, else a negative error code.
  */
 int spi_register_board_info(struct spi_board_info const *info, unsigned n)
 {
@@ -1210,6 +1214,8 @@ static int spi_init_queue(struct spi_master *master)
  *
  * If there are more messages in the queue, the next message is returned from
  * this call.
+ *
+ * Return: the next message in the queue, else NULL if the queue is empty.
  */
 struct spi_message *spi_get_next_queued_message(struct spi_master *master)
 {
@@ -1373,6 +1379,8 @@ static int __spi_queued_transfer(struct spi_device *spi,
  * spi_queued_transfer - transfer function for queued transfers
  * @spi: spi device which is requesting transfer
  * @msg: spi message which is to handled is queued to driver queue
+ *
+ * Return: zero on success, else a negative error code.
  */
 static int spi_queued_transfer(struct spi_device *spi, struct spi_message *msg)
 {
@@ -1672,12 +1680,13 @@ static struct class spi_master_class = {
  * only ones directly touching chip registers.  It's how they allocate
  * an spi_master structure, prior to calling spi_register_master().
  *
- * This must be called from context that can sleep.  It returns the SPI
- * master structure on success, else NULL.
+ * This must be called from context that can sleep.
  *
  * The caller is responsible for assigning the bus number and initializing
  * the master's methods before calling spi_register_master(); and (after errors
  * adding the device) calling spi_master_put() to prevent a memory leak.
+ *
+ * Return: the SPI master structure on success, else NULL.
  */
 struct spi_master *spi_alloc_master(struct device *dev, unsigned size)
 {
@@ -1761,6 +1770,8 @@ static int of_spi_register_master(struct spi_master *master)
  * success, else a negative error code (dropping the master's refcount).
  * After a successful return, the caller is responsible for calling
  * spi_unregister_master().
+ *
+ * Return: zero on success, else a negative error code.
  */
 int spi_register_master(struct spi_master *master)
 {
@@ -1854,6 +1865,8 @@ static void devm_spi_unregister(struct device *dev, void *res)
  *
  * Register a SPI device as with spi_register_master() which will
  * automatically be unregister
+ *
+ * Return: zero on success, else a negative error code.
  */
 int devm_spi_register_master(struct device *dev, struct spi_master *master)
 {
@@ -1959,6 +1972,8 @@ static int __spi_master_match(struct device *dev, const void *data)
  * arch init time.  It returns a refcounted pointer to the relevant
  * spi_master (which the caller must release), or NULL if there is
  * no such master registered.
+ *
+ * Return: the SPI master structure on success, else NULL.
  */
 struct spi_master *spi_busnum_to_master(u16 bus_num)
 {
@@ -2012,6 +2027,8 @@ static int __spi_validate_bits_per_word(struct spi_master *master, u8 bits_per_w
  * that the underlying controller or its driver does not support.  For
  * example, not all hardware supports wire transfers using nine bit words,
  * LSB-first wire encoding, or active-high chipselects.
+ *
+ * Return: zero on success, else a negative error code.
  */
 int spi_setup(struct spi_device *spi)
 {
@@ -2230,6 +2247,8 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
  * no other spi_message queued to that device will be processed.
  * (This rule applies equally to all the synchronous transfer calls,
  * which are wrappers around this core asynchronous primitive.)
+ *
+ * Return: zero on success, else a negative error code.
  */
 int spi_async(struct spi_device *spi, struct spi_message *message)
 {
@@ -2282,6 +2301,8 @@ EXPORT_SYMBOL_GPL(spi_async);
  * no other spi_message queued to that device will be processed.
  * (This rule applies equally to all the synchronous transfer calls,
  * which are wrappers around this core asynchronous primitive.)
+ *
+ * Return: zero on success, else a negative error code.
  */
 int spi_async_locked(struct spi_device *spi, struct spi_message *message)
 {
@@ -2397,7 +2418,7 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message,
  * Also, the caller is guaranteeing that the memory associated with the
  * message will not be freed before this call returns.
  *
- * It returns zero on success, else a negative error code.
+ * Return: zero on success, else a negative error code.
  */
 int spi_sync(struct spi_device *spi, struct spi_message *message)
 {
@@ -2419,7 +2440,7 @@ EXPORT_SYMBOL_GPL(spi_sync);
  * SPI bus. It has to be preceded by a spi_bus_lock call. The SPI bus must
  * be released by a spi_bus_unlock call when the exclusive access is over.
  *
- * It returns zero on success, else a negative error code.
+ * Return: zero on success, else a negative error code.
  */
 int spi_sync_locked(struct spi_device *spi, struct spi_message *message)
 {
@@ -2440,7 +2461,7 @@ EXPORT_SYMBOL_GPL(spi_sync_locked);
  * exclusive access is over. Data transfer must be done by spi_sync_locked
  * and spi_async_locked calls when the SPI bus lock is held.
  *
- * It returns zero on success, else a negative error code.
+ * Return: always zero.
  */
 int spi_bus_lock(struct spi_master *master)
 {
@@ -2469,7 +2490,7 @@ EXPORT_SYMBOL_GPL(spi_bus_lock);
  * This call releases an SPI bus lock previously obtained by an spi_bus_lock
  * call.
  *
- * It returns zero on success, else a negative error code.
+ * Return: always zero.
  */
 int spi_bus_unlock(struct spi_master *master)
 {
@@ -2504,6 +2525,8 @@ static u8	*buf;
  * portable code should never use this for more than 32 bytes.
  * Performance-sensitive or bulk transfer code should instead use
  * spi_{async,sync}() calls with dma-safe buffers.
+ *
+ * Return: zero on success, else a negative error code.
  */
 int spi_write_then_read(struct spi_device *spi,
 		const void *txbuf, unsigned n_tx,

commit 0dc9631221c95cc5ba31c115bf21c9b156aab253
Merge: 7379047d5585 243f07be2423 6b7bc0618ff1
Author: Mark Brown <broonie@kernel.org>
Date:   Sat Oct 24 01:28:29 2015 +0900

    Merge branches 'topic/core' and 'topic/stats' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi into spi-doc

commit 243f07be2423efe0b17e8ffafc9a36dad50406d3
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Oct 20 12:28:29 2015 +0300

    spi: core: use gpio_is_valid() helper
    
    Check if GPIO pin is valid by API helper function.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 64c1aedde481..9136f30a9fbd 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -606,7 +606,7 @@ static void spi_set_cs(struct spi_device *spi, bool enable)
 	if (spi->mode & SPI_CS_HIGH)
 		enable = !enable;
 
-	if (spi->cs_gpio >= 0)
+	if (gpio_is_valid(spi->cs_gpio))
 		gpio_set_value(spi->cs_gpio, !enable);
 	else if (spi->master->set_cs)
 		spi->master->set_cs(spi, !enable);

commit 5ab8d262122bc951b308e51cdcc55bc67b1f5fdb
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Oct 14 22:43:07 2015 +0300

    spi: core: propagate return code of __spi_validate_bits_per_word()
    
    Propagate the actual return code of __spi_validate_bits_per_word() in
    spi_setup().
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 40c9afac047f..64c1aedde481 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1956,7 +1956,7 @@ static int __spi_validate_bits_per_word(struct spi_master *master, u8 bits_per_w
 int spi_setup(struct spi_device *spi)
 {
 	unsigned	bad_bits, ugly_bits;
-	int		status = 0;
+	int		status;
 
 	/* check mode to prevent that DUAL and QUAD set at the same time
 	 */
@@ -1993,8 +1993,9 @@ int spi_setup(struct spi_device *spi)
 	if (!spi->bits_per_word)
 		spi->bits_per_word = 8;
 
-	if (__spi_validate_bits_per_word(spi->master, spi->bits_per_word))
-		return -EINVAL;
+	status = __spi_validate_bits_per_word(spi->master, spi->bits_per_word);
+	if (status)
+		return status;
 
 	if (!spi->max_speed_hz)
 		spi->max_speed_hz = spi->master->max_speed_hz;

commit 44af7927316e83eb8865933f7c836dcc85f8eb74
Author: Jon Hunter <jonathanh@nvidia.com>
Date:   Fri Oct 9 15:45:55 2015 +0100

    spi: Map SPI OF client IRQ at probe time
    
    Currently the IRQs for SPI client devices, registered via device-tree,
    are mapped when the client devices are registered. If the corresponding
    irq-chip has not been probed yet, then the probing of the client device
    will fail and will not be retried. Resolve this by mapping the IRQ at
    probe time and allow the probe to be deferred if the IRQ is not yet
    available.
    
    If of_irq_get() returns an error that is not -EPROBE_DEFER, then assume
    that the SPI client does not have an IRQ and set the IRQ number to zero
    (which is equivalent to irq_of_parse_and_map()).
    
    This is based on some inputs from Thierry Reding <treding@nvidia.com>.
    
    Cc: Thierry Reding <treding@nvidia.com>
    Cc: Tomeu Vizoso <tomeu.vizoso@collabora.com>
    Signed-off-by: Jon Hunter <jonathanh@nvidia.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 3abb3903f2ad..40c9afac047f 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -270,15 +270,24 @@ EXPORT_SYMBOL_GPL(spi_bus_type);
 static int spi_drv_probe(struct device *dev)
 {
 	const struct spi_driver		*sdrv = to_spi_driver(dev->driver);
+	struct spi_device		*spi = to_spi_device(dev);
 	int ret;
 
 	ret = of_clk_set_defaults(dev->of_node, false);
 	if (ret)
 		return ret;
 
+	if (dev->of_node) {
+		spi->irq = of_irq_get(dev->of_node, 0);
+		if (spi->irq == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+		if (spi->irq < 0)
+			spi->irq = 0;
+	}
+
 	ret = dev_pm_domain_attach(dev, true);
 	if (ret != -EPROBE_DEFER) {
-		ret = sdrv->probe(to_spi_device(dev));
+		ret = sdrv->probe(spi);
 		if (ret)
 			dev_pm_domain_detach(dev, true);
 	}
@@ -1433,9 +1442,6 @@ of_register_spi_device(struct spi_master *master, struct device_node *nc)
 	}
 	spi->max_speed_hz = value;
 
-	/* IRQ */
-	spi->irq = irq_of_parse_and_map(nc, 0);
-
 	/* Store a pointer to the node in the device structure */
 	of_node_get(nc);
 	spi->dev.of_node = nc;

commit 6b7bc0618ff1a333d2265131b124e966335d5dee
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Mon Jun 22 13:02:04 2015 +0000

    spi: add transfer histogram statistics via sysfs
    
    report transfer sizes as a histogram via the following files:
      /sys/class/spi_master/spi*/statistics/transfer_bytes_histo_*
      /sys/class/spi_master/spi*/spi*.*/statistics/transfer_bytes_histo_*
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 3abb3903f2ad..73face0f6b9c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -123,6 +123,28 @@ SPI_STATISTICS_SHOW(bytes, "%llu");
 SPI_STATISTICS_SHOW(bytes_rx, "%llu");
 SPI_STATISTICS_SHOW(bytes_tx, "%llu");
 
+#define SPI_STATISTICS_TRANSFER_BYTES_HISTO(index, number)		\
+	SPI_STATISTICS_SHOW_NAME(transfer_bytes_histo##index,		\
+				 "transfer_bytes_histo_" number,	\
+				 transfer_bytes_histo[index],  "%lu")
+SPI_STATISTICS_TRANSFER_BYTES_HISTO(0,  "0-1");
+SPI_STATISTICS_TRANSFER_BYTES_HISTO(1,  "2-3");
+SPI_STATISTICS_TRANSFER_BYTES_HISTO(2,  "4-7");
+SPI_STATISTICS_TRANSFER_BYTES_HISTO(3,  "8-15");
+SPI_STATISTICS_TRANSFER_BYTES_HISTO(4,  "16-31");
+SPI_STATISTICS_TRANSFER_BYTES_HISTO(5,  "32-63");
+SPI_STATISTICS_TRANSFER_BYTES_HISTO(6,  "64-127");
+SPI_STATISTICS_TRANSFER_BYTES_HISTO(7,  "128-255");
+SPI_STATISTICS_TRANSFER_BYTES_HISTO(8,  "256-511");
+SPI_STATISTICS_TRANSFER_BYTES_HISTO(9,  "512-1023");
+SPI_STATISTICS_TRANSFER_BYTES_HISTO(10, "1024-2047");
+SPI_STATISTICS_TRANSFER_BYTES_HISTO(11, "2048-4095");
+SPI_STATISTICS_TRANSFER_BYTES_HISTO(12, "4096-8191");
+SPI_STATISTICS_TRANSFER_BYTES_HISTO(13, "8192-16383");
+SPI_STATISTICS_TRANSFER_BYTES_HISTO(14, "16384-32767");
+SPI_STATISTICS_TRANSFER_BYTES_HISTO(15, "32768-65535");
+SPI_STATISTICS_TRANSFER_BYTES_HISTO(16, "65536+");
+
 static struct attribute *spi_dev_attrs[] = {
 	&dev_attr_modalias.attr,
 	NULL,
@@ -143,6 +165,23 @@ static struct attribute *spi_device_statistics_attrs[] = {
 	&dev_attr_spi_device_bytes.attr,
 	&dev_attr_spi_device_bytes_rx.attr,
 	&dev_attr_spi_device_bytes_tx.attr,
+	&dev_attr_spi_device_transfer_bytes_histo0.attr,
+	&dev_attr_spi_device_transfer_bytes_histo1.attr,
+	&dev_attr_spi_device_transfer_bytes_histo2.attr,
+	&dev_attr_spi_device_transfer_bytes_histo3.attr,
+	&dev_attr_spi_device_transfer_bytes_histo4.attr,
+	&dev_attr_spi_device_transfer_bytes_histo5.attr,
+	&dev_attr_spi_device_transfer_bytes_histo6.attr,
+	&dev_attr_spi_device_transfer_bytes_histo7.attr,
+	&dev_attr_spi_device_transfer_bytes_histo8.attr,
+	&dev_attr_spi_device_transfer_bytes_histo9.attr,
+	&dev_attr_spi_device_transfer_bytes_histo10.attr,
+	&dev_attr_spi_device_transfer_bytes_histo11.attr,
+	&dev_attr_spi_device_transfer_bytes_histo12.attr,
+	&dev_attr_spi_device_transfer_bytes_histo13.attr,
+	&dev_attr_spi_device_transfer_bytes_histo14.attr,
+	&dev_attr_spi_device_transfer_bytes_histo15.attr,
+	&dev_attr_spi_device_transfer_bytes_histo16.attr,
 	NULL,
 };
 
@@ -168,6 +207,23 @@ static struct attribute *spi_master_statistics_attrs[] = {
 	&dev_attr_spi_master_bytes.attr,
 	&dev_attr_spi_master_bytes_rx.attr,
 	&dev_attr_spi_master_bytes_tx.attr,
+	&dev_attr_spi_master_transfer_bytes_histo0.attr,
+	&dev_attr_spi_master_transfer_bytes_histo1.attr,
+	&dev_attr_spi_master_transfer_bytes_histo2.attr,
+	&dev_attr_spi_master_transfer_bytes_histo3.attr,
+	&dev_attr_spi_master_transfer_bytes_histo4.attr,
+	&dev_attr_spi_master_transfer_bytes_histo5.attr,
+	&dev_attr_spi_master_transfer_bytes_histo6.attr,
+	&dev_attr_spi_master_transfer_bytes_histo7.attr,
+	&dev_attr_spi_master_transfer_bytes_histo8.attr,
+	&dev_attr_spi_master_transfer_bytes_histo9.attr,
+	&dev_attr_spi_master_transfer_bytes_histo10.attr,
+	&dev_attr_spi_master_transfer_bytes_histo11.attr,
+	&dev_attr_spi_master_transfer_bytes_histo12.attr,
+	&dev_attr_spi_master_transfer_bytes_histo13.attr,
+	&dev_attr_spi_master_transfer_bytes_histo14.attr,
+	&dev_attr_spi_master_transfer_bytes_histo15.attr,
+	&dev_attr_spi_master_transfer_bytes_histo16.attr,
 	NULL,
 };
 
@@ -186,10 +242,15 @@ void spi_statistics_add_transfer_stats(struct spi_statistics *stats,
 				       struct spi_master *master)
 {
 	unsigned long flags;
+	int l2len = min(fls(xfer->len), SPI_STATISTICS_HISTO_SIZE) - 1;
+
+	if (l2len < 0)
+		l2len = 0;
 
 	spin_lock_irqsave(&stats->lock, flags);
 
 	stats->transfers++;
+	stats->transfer_bytes_histo[l2len]++;
 
 	stats->bytes += xfer->len;
 	if ((xfer->tx_buf) &&

commit 92243b6fc8fcb16bf401b055f7a0ba79f70a4115
Merge: a394d635193b 6ff33f3902c3
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Sep 16 20:44:25 2015 +0100

    Merge tag 'v4.3-rc1' into spi-fix-doc
    
    Linux 4.3-rc1

commit a394d635193b641f2c86ead5ada5b115d57c51f8
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sun Sep 6 01:46:54 2015 +0300

    spi: Fix documentation of spi_alloc_master()
    
    Actually, spi_master_put() after spi_alloc_master() must _not_ be followed
    by kfree(). The memory is already freed with the call to spi_master_put()
    through spi_master_class, which registers a release function. Calling both
    spi_master_put() and kfree() results in often nasty (and delayed) crashes
    elsewhere in the kernel, often in the networking stack.
    
    This reverts commit eb4af0f5349235df2e4a5057a72fc8962d00308a.
    
    Link to patch and concerns: https://lkml.org/lkml/2012/9/3/269
    or
    http://lkml.iu.edu/hypermail/linux/kernel/1209.0/00790.html
    
    Alexey Klimov: This revert becomes valid after
    94c69f765f1b4a658d96905ec59928e3e3e07e6a when spi-imx.c
    has been fixed and there is no need to call kfree() so comment
    for spi_alloc_master() should be fixed.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Alexey Klimov <alexey.klimov@linaro.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index cf8b91b23a76..9ce2f156d382 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1437,8 +1437,7 @@ static struct class spi_master_class = {
  *
  * The caller is responsible for assigning the bus number and initializing
  * the master's methods before calling spi_register_master(); and (after errors
- * adding the device) calling spi_master_put() and kfree() to prevent a memory
- * leak.
+ * adding the device) calling spi_master_put() to prevent a memory leak.
  */
 struct spi_master *spi_alloc_master(struct device *dev, unsigned size)
 {

commit c92ec7c7ae99a371bbc69f0258888a0328ba4838
Merge: 2ca0a9d80c3a ed425dcf6afa 65598c13fd66 fe78d0b7691c 89a6356676eb eca2ebc7e007
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Aug 31 14:45:41 2015 +0100

    Merge remote-tracking branches 'spi/topic/s3c64xx', 'spi/topic/sg', 'spi/topic/sh-msiof', 'spi/topic/spidev' and 'spi/topic/stats' into spi-next

commit 8e42ac814c63dd5c5e39bbbfbc9c6578e19c765f
Merge: bc6450994976 c37f45b5f1cd
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Aug 31 14:45:28 2015 +0100

    Merge remote-tracking branch 'spi/topic/dma' into spi-next

commit 63ab645f4d8b2dc1351c41751e7ebb1b3f1c99d3
Author: Stefan BrÃ¼ns <stefan.bruens@rwth-aachen.de>
Date:   Sun Aug 23 16:06:30 2015 +0200

    spi: check bits_per_word in spi_setup
    
    This allows drivers for devices connected via SPI to check if the
    controller supports a given bits_per_word value during setup.
    Currently any BPW value is accepted durings setup, and transfers
    are rejected later.
    
    Signed-off-by: Stefan BrÃ¼ns <stefan.bruens@rwth-aachen.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 637d892b316d..829323ce7cdf 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1740,6 +1740,20 @@ EXPORT_SYMBOL_GPL(spi_busnum_to_master);
  * other core methods are currently defined as inline functions.
  */
 
+static int __spi_validate_bits_per_word(struct spi_master *master, u8 bits_per_word)
+{
+	if (master->bits_per_word_mask) {
+		/* Only 32 bits fit in the mask */
+		if (bits_per_word > 32)
+			return -EINVAL;
+		if (!(master->bits_per_word_mask &
+				SPI_BPW_MASK(bits_per_word)))
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
 /**
  * spi_setup - setup SPI mode and clock rate
  * @spi: the device whose settings are being modified
@@ -1798,6 +1812,9 @@ int spi_setup(struct spi_device *spi)
 	if (!spi->bits_per_word)
 		spi->bits_per_word = 8;
 
+	if (__spi_validate_bits_per_word(spi->master, spi->bits_per_word))
+		return -EINVAL;
+
 	if (!spi->max_speed_hz)
 		spi->max_speed_hz = spi->master->max_speed_hz;
 
@@ -1867,14 +1884,8 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 		    xfer->speed_hz > master->max_speed_hz)
 			xfer->speed_hz = master->max_speed_hz;
 
-		if (master->bits_per_word_mask) {
-			/* Only 32 bits fit in the mask */
-			if (xfer->bits_per_word > 32)
-				return -EINVAL;
-			if (!(master->bits_per_word_mask &
-					BIT(xfer->bits_per_word - 1)))
-				return -EINVAL;
-		}
+		if (__spi_validate_bits_per_word(master, xfer->bits_per_word))
+			return -EINVAL;
 
 		/*
 		 * SPI transfer length should be multiple of SPI word size

commit 7dc9fbc342deb2e2658ebdecb5ffd7ff57945a66
Author: Mark Brown <broonie@kernel.org>
Date:   Thu Aug 20 11:52:18 2015 -0700

    spi: Fall back to master maximum speed if no slave speed specified
    
    If a slave appears with no maximum transfer speed specified fall back to
    using the maximum for the master instead.  It's questionable if we
    should let slaves do this but let's be defensive.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index cf8b91b23a76..637d892b316d 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1860,6 +1860,8 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 
 		if (!xfer->speed_hz)
 			xfer->speed_hz = spi->max_speed_hz;
+		if (!xfer->speed_hz)
+			xfer->speed_hz = master->max_speed_hz;
 
 		if (master->max_speed_hz &&
 		    xfer->speed_hz > master->max_speed_hz)

commit c37f45b5f1cdfcdc351d88950b32658c970582ca
Author: Leilk Liu <leilk.liu@mediatek.com>
Date:   Thu Jul 23 17:10:40 2015 +0800

    spi: support spi without dma channel to use can_dma()
    
    For spi without dma channel and use can_dma(), it can
    use master->dev for struct device.
    
    Signed-off-by: Leilk Liu <leilk.liu@mediatek.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index cf8b91b23a76..f725085a5f07 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -539,8 +539,15 @@ static int __spi_map_msg(struct spi_master *master, struct spi_message *msg)
 	if (!master->can_dma)
 		return 0;
 
-	tx_dev = master->dma_tx->device->dev;
-	rx_dev = master->dma_rx->device->dev;
+	if (master->dma_tx)
+		tx_dev = master->dma_tx->device->dev;
+	else
+		tx_dev = &master->dev;
+
+	if (master->dma_rx)
+		rx_dev = master->dma_rx->device->dev;
+	else
+		rx_dev = &master->dev;
 
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		if (!master->can_dma(master, msg->spi, xfer))
@@ -579,8 +586,15 @@ static int __spi_unmap_msg(struct spi_master *master, struct spi_message *msg)
 	if (!master->cur_msg_mapped || !master->can_dma)
 		return 0;
 
-	tx_dev = master->dma_tx->device->dev;
-	rx_dev = master->dma_rx->device->dev;
+	if (master->dma_tx)
+		tx_dev = master->dma_tx->device->dev;
+	else
+		tx_dev = &master->dev;
+
+	if (master->dma_rx)
+		rx_dev = master->dma_rx->device->dev;
+	else
+		rx_dev = &master->dev;
 
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		if (!master->can_dma(master, msg->spi, xfer))

commit eca2ebc7e007c9e2b8f5ecfcfc74b53fbe68e42b
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Mon Jun 22 13:00:36 2015 +0000

    spi: expose spi_master and spi_device statistics via sysfs
    
    per spi-master statistics accessible as:
      /sys/class/spi_master/spi*/statistics/*
    
    per spi-device statistics accessible via:
      /sys/class/spi_master/spi*/spi*.*/statistics/*
    
    The following statistics are exposed as separate "files" inside
    these directories:
    * messages              number of spi_messages
    * transfers             number of spi_transfers
    * bytes                 number of bytes transferred
    * bytes_rx              number of bytes transmitted
    * bytes_tx              number of bytes received
    * errors                number of errors encounterd
    * timedout              number of messages that have timed out
    * spi_async             number of spi_messages submitted using spi_async
    * spi_sync              number of spi_messages submitted using spi_sync
    * spi_sync_immediate    number of spi_messages submitted using spi_sync,
                            that are handled immediately without a context switch
                            to the spi_pump worker-thread
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index cf8b91b23a76..07476ca083a0 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -67,11 +67,141 @@ modalias_show(struct device *dev, struct device_attribute *a, char *buf)
 }
 static DEVICE_ATTR_RO(modalias);
 
+#define SPI_STATISTICS_ATTRS(field, file)				\
+static ssize_t spi_master_##field##_show(struct device *dev,		\
+					 struct device_attribute *attr,	\
+					 char *buf)			\
+{									\
+	struct spi_master *master = container_of(dev,			\
+						 struct spi_master, dev); \
+	return spi_statistics_##field##_show(&master->statistics, buf);	\
+}									\
+static struct device_attribute dev_attr_spi_master_##field = {		\
+	.attr = { .name = file, .mode = S_IRUGO },			\
+	.show = spi_master_##field##_show,				\
+};									\
+static ssize_t spi_device_##field##_show(struct device *dev,		\
+					 struct device_attribute *attr,	\
+					char *buf)			\
+{									\
+	struct spi_device *spi = container_of(dev,			\
+					      struct spi_device, dev);	\
+	return spi_statistics_##field##_show(&spi->statistics, buf);	\
+}									\
+static struct device_attribute dev_attr_spi_device_##field = {		\
+	.attr = { .name = file, .mode = S_IRUGO },			\
+	.show = spi_device_##field##_show,				\
+}
+
+#define SPI_STATISTICS_SHOW_NAME(name, file, field, format_string)	\
+static ssize_t spi_statistics_##name##_show(struct spi_statistics *stat, \
+					    char *buf)			\
+{									\
+	unsigned long flags;						\
+	ssize_t len;							\
+	spin_lock_irqsave(&stat->lock, flags);				\
+	len = sprintf(buf, format_string, stat->field);			\
+	spin_unlock_irqrestore(&stat->lock, flags);			\
+	return len;							\
+}									\
+SPI_STATISTICS_ATTRS(name, file)
+
+#define SPI_STATISTICS_SHOW(field, format_string)			\
+	SPI_STATISTICS_SHOW_NAME(field, __stringify(field),		\
+				 field, format_string)
+
+SPI_STATISTICS_SHOW(messages, "%lu");
+SPI_STATISTICS_SHOW(transfers, "%lu");
+SPI_STATISTICS_SHOW(errors, "%lu");
+SPI_STATISTICS_SHOW(timedout, "%lu");
+
+SPI_STATISTICS_SHOW(spi_sync, "%lu");
+SPI_STATISTICS_SHOW(spi_sync_immediate, "%lu");
+SPI_STATISTICS_SHOW(spi_async, "%lu");
+
+SPI_STATISTICS_SHOW(bytes, "%llu");
+SPI_STATISTICS_SHOW(bytes_rx, "%llu");
+SPI_STATISTICS_SHOW(bytes_tx, "%llu");
+
 static struct attribute *spi_dev_attrs[] = {
 	&dev_attr_modalias.attr,
 	NULL,
 };
-ATTRIBUTE_GROUPS(spi_dev);
+
+static const struct attribute_group spi_dev_group = {
+	.attrs  = spi_dev_attrs,
+};
+
+static struct attribute *spi_device_statistics_attrs[] = {
+	&dev_attr_spi_device_messages.attr,
+	&dev_attr_spi_device_transfers.attr,
+	&dev_attr_spi_device_errors.attr,
+	&dev_attr_spi_device_timedout.attr,
+	&dev_attr_spi_device_spi_sync.attr,
+	&dev_attr_spi_device_spi_sync_immediate.attr,
+	&dev_attr_spi_device_spi_async.attr,
+	&dev_attr_spi_device_bytes.attr,
+	&dev_attr_spi_device_bytes_rx.attr,
+	&dev_attr_spi_device_bytes_tx.attr,
+	NULL,
+};
+
+static const struct attribute_group spi_device_statistics_group = {
+	.name  = "statistics",
+	.attrs  = spi_device_statistics_attrs,
+};
+
+static const struct attribute_group *spi_dev_groups[] = {
+	&spi_dev_group,
+	&spi_device_statistics_group,
+	NULL,
+};
+
+static struct attribute *spi_master_statistics_attrs[] = {
+	&dev_attr_spi_master_messages.attr,
+	&dev_attr_spi_master_transfers.attr,
+	&dev_attr_spi_master_errors.attr,
+	&dev_attr_spi_master_timedout.attr,
+	&dev_attr_spi_master_spi_sync.attr,
+	&dev_attr_spi_master_spi_sync_immediate.attr,
+	&dev_attr_spi_master_spi_async.attr,
+	&dev_attr_spi_master_bytes.attr,
+	&dev_attr_spi_master_bytes_rx.attr,
+	&dev_attr_spi_master_bytes_tx.attr,
+	NULL,
+};
+
+static const struct attribute_group spi_master_statistics_group = {
+	.name  = "statistics",
+	.attrs  = spi_master_statistics_attrs,
+};
+
+static const struct attribute_group *spi_master_groups[] = {
+	&spi_master_statistics_group,
+	NULL,
+};
+
+void spi_statistics_add_transfer_stats(struct spi_statistics *stats,
+				       struct spi_transfer *xfer,
+				       struct spi_master *master)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&stats->lock, flags);
+
+	stats->transfers++;
+
+	stats->bytes += xfer->len;
+	if ((xfer->tx_buf) &&
+	    (xfer->tx_buf != master->dummy_tx))
+		stats->bytes_tx += xfer->len;
+	if ((xfer->rx_buf) &&
+	    (xfer->rx_buf != master->dummy_rx))
+		stats->bytes_rx += xfer->len;
+
+	spin_unlock_irqrestore(&stats->lock, flags);
+}
+EXPORT_SYMBOL_GPL(spi_statistics_add_transfer_stats);
 
 /* modalias support makes "modprobe $MODALIAS" new-style hotplug work,
  * and the sysfs version makes coldplug work too.
@@ -249,6 +379,9 @@ struct spi_device *spi_alloc_device(struct spi_master *master)
 	spi->dev.bus = &spi_bus_type;
 	spi->dev.release = spidev_release;
 	spi->cs_gpio = -ENOENT;
+
+	spin_lock_init(&spi->statistics.lock);
+
 	device_initialize(&spi->dev);
 	return spi;
 }
@@ -689,17 +822,29 @@ static int spi_transfer_one_message(struct spi_master *master,
 	bool keep_cs = false;
 	int ret = 0;
 	unsigned long ms = 1;
+	struct spi_statistics *statm = &master->statistics;
+	struct spi_statistics *stats = &msg->spi->statistics;
 
 	spi_set_cs(msg->spi, true);
 
+	SPI_STATISTICS_INCREMENT_FIELD(statm, messages);
+	SPI_STATISTICS_INCREMENT_FIELD(stats, messages);
+
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		trace_spi_transfer_start(msg, xfer);
 
+		spi_statistics_add_transfer_stats(statm, xfer, master);
+		spi_statistics_add_transfer_stats(stats, xfer, master);
+
 		if (xfer->tx_buf || xfer->rx_buf) {
 			reinit_completion(&master->xfer_completion);
 
 			ret = master->transfer_one(master, msg->spi, xfer);
 			if (ret < 0) {
+				SPI_STATISTICS_INCREMENT_FIELD(statm,
+							       errors);
+				SPI_STATISTICS_INCREMENT_FIELD(stats,
+							       errors);
 				dev_err(&msg->spi->dev,
 					"SPI transfer failed: %d\n", ret);
 				goto out;
@@ -715,6 +860,10 @@ static int spi_transfer_one_message(struct spi_master *master,
 			}
 
 			if (ms == 0) {
+				SPI_STATISTICS_INCREMENT_FIELD(statm,
+							       timedout);
+				SPI_STATISTICS_INCREMENT_FIELD(stats,
+							       timedout);
 				dev_err(&msg->spi->dev,
 					"SPI transfer timed out\n");
 				msg->status = -ETIMEDOUT;
@@ -1416,10 +1565,10 @@ static struct class spi_master_class = {
 	.name		= "spi_master",
 	.owner		= THIS_MODULE,
 	.dev_release	= spi_master_release,
+	.dev_groups	= spi_master_groups,
 };
 
 
-
 /**
  * spi_alloc_master - allocate SPI master controller
  * @dev: the controller, possibly using the platform_bus
@@ -1585,6 +1734,8 @@ int spi_register_master(struct spi_master *master)
 			goto done;
 		}
 	}
+	/* add statistics */
+	spin_lock_init(&master->statistics.lock);
 
 	mutex_lock(&board_lock);
 	list_add_tail(&master->list, &spi_master_list);
@@ -1939,6 +2090,9 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
 
 	message->spi = spi;
 
+	SPI_STATISTICS_INCREMENT_FIELD(&master->statistics, spi_async);
+	SPI_STATISTICS_INCREMENT_FIELD(&spi->statistics, spi_async);
+
 	trace_spi_message_submit(message);
 
 	return master->transfer(spi, message);
@@ -2075,6 +2229,9 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message,
 	message->context = &done;
 	message->spi = spi;
 
+	SPI_STATISTICS_INCREMENT_FIELD(&master->statistics, spi_sync);
+	SPI_STATISTICS_INCREMENT_FIELD(&spi->statistics, spi_sync);
+
 	if (!bus_locked)
 		mutex_lock(&master->bus_lock_mutex);
 
@@ -2102,8 +2259,13 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message,
 		/* Push out the messages in the calling context if we
 		 * can.
 		 */
-		if (master->transfer == spi_queued_transfer)
+		if (master->transfer == spi_queued_transfer) {
+			SPI_STATISTICS_INCREMENT_FIELD(&master->statistics,
+						       spi_sync_immediate);
+			SPI_STATISTICS_INCREMENT_FIELD(&spi->statistics,
+						       spi_sync_immediate);
 			__spi_pump_messages(master, false);
+		}
 
 		wait_for_completion(&done);
 		status = message->status;

commit 65598c13fd66c3b5eac16d5b8eacc704aa17ce40
Author: Andrew Gabbasov <andrew_gabbasov@mentor.com>
Date:   Tue Jun 30 10:48:37 2015 -0500

    spi: Fix per-page mapping of unaligned vmalloc-ed buffer
    
    spi_map_buf() processes mapping of vmalloc-ed buffers in a special way,
    making mapping of every page separately. However, if the buffer is not
    aligned to page boundary (e.g. sub-array in a vmalloc-ed array), it
    fills the scatter table with page-size unaligned pieces, that cross
    page boundaries. This is incorrect and can, for example, cause memory
    corruption and various crashes when working with ubifs on spi-nor chips
    (though those drivers are themselves buggy in that they should be
    providing DMAable memory to the SPI framework).
    
    Fix this by using proper scatter table size and intra-page buffer lengths,
    so that the whole buffer splits into separate scatter table entries on
    page boundaries.
    
    Signed-off-by: Andrew Gabbasov <andrew_gabbasov@mentor.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index cf8b91b23a76..27e4f1f116ee 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -476,21 +476,30 @@ static int spi_map_buf(struct spi_master *master, struct device *dev,
 		       enum dma_data_direction dir)
 {
 	const bool vmalloced_buf = is_vmalloc_addr(buf);
-	const int desc_len = vmalloced_buf ? PAGE_SIZE : master->max_dma_len;
-	const int sgs = DIV_ROUND_UP(len, desc_len);
+	int desc_len;
+	int sgs;
 	struct page *vm_page;
 	void *sg_buf;
 	size_t min;
 	int i, ret;
 
+	if (vmalloced_buf) {
+		desc_len = PAGE_SIZE;
+		sgs = DIV_ROUND_UP(len + offset_in_page(buf), desc_len);
+	} else {
+		desc_len = master->max_dma_len;
+		sgs = DIV_ROUND_UP(len, desc_len);
+	}
+
 	ret = sg_alloc_table(sgt, sgs, GFP_KERNEL);
 	if (ret != 0)
 		return ret;
 
 	for (i = 0; i < sgs; i++) {
-		min = min_t(size_t, len, desc_len);
 
 		if (vmalloced_buf) {
+			min = min_t(size_t,
+				    len, desc_len - offset_in_page(buf));
 			vm_page = vmalloc_to_page(buf);
 			if (!vm_page) {
 				sg_free_table(sgt);
@@ -499,6 +508,7 @@ static int spi_map_buf(struct spi_master *master, struct device *dev,
 			sg_set_page(&sgt->sgl[i], vm_page,
 				    min, offset_in_page(buf));
 		} else {
+			min = min_t(size_t, len, desc_len);
 			sg_buf = buf;
 			sg_set_buf(&sgt->sgl[i], sg_buf, min);
 		}

commit 4b786458ed99eae9e9d9984a1624a79e9bf6cebb
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Mon May 25 10:13:10 2015 +0000

    spi: restore rx/tx_buf in case of unset CONFIG_HAS_DMA
    
    The case where spi_master sets the flags SPI_MASTER_MUST_RX/TX while
    CONFIG_HAS_DMA is unset (which is unlikley) together with a driver
    that reuses spi_messages with rx/tx_buff set to NULL, can result in:
    * data disclosure over the SPI (for tx_buf == NULL)
    * memory corruption (for rx_buf == NULL)
    
    This happenes when dummy_rx/dummy_tx are changing address due to krealloc
    or free and an allocation of the memory by a different part of the kernel.
    
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index d35c1a13217c..cf8b91b23a76 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -571,7 +571,7 @@ static int __spi_map_msg(struct spi_master *master, struct spi_message *msg)
 	return 0;
 }
 
-static int spi_unmap_msg(struct spi_master *master, struct spi_message *msg)
+static int __spi_unmap_msg(struct spi_master *master, struct spi_message *msg)
 {
 	struct spi_transfer *xfer;
 	struct device *tx_dev, *rx_dev;
@@ -583,15 +583,6 @@ static int spi_unmap_msg(struct spi_master *master, struct spi_message *msg)
 	rx_dev = master->dma_rx->device->dev;
 
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
-		/*
-		 * Restore the original value of tx_buf or rx_buf if they are
-		 * NULL.
-		 */
-		if (xfer->tx_buf == master->dummy_tx)
-			xfer->tx_buf = NULL;
-		if (xfer->rx_buf == master->dummy_rx)
-			xfer->rx_buf = NULL;
-
 		if (!master->can_dma(master, msg->spi, xfer))
 			continue;
 
@@ -608,13 +599,32 @@ static inline int __spi_map_msg(struct spi_master *master,
 	return 0;
 }
 
-static inline int spi_unmap_msg(struct spi_master *master,
-				struct spi_message *msg)
+static inline int __spi_unmap_msg(struct spi_master *master,
+				  struct spi_message *msg)
 {
 	return 0;
 }
 #endif /* !CONFIG_HAS_DMA */
 
+static inline int spi_unmap_msg(struct spi_master *master,
+				struct spi_message *msg)
+{
+	struct spi_transfer *xfer;
+
+	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		/*
+		 * Restore the original value of tx_buf or rx_buf if they are
+		 * NULL.
+		 */
+		if (xfer->tx_buf == master->dummy_tx)
+			xfer->tx_buf = NULL;
+		if (xfer->rx_buf == master->dummy_rx)
+			xfer->rx_buf = NULL;
+	}
+
+	return __spi_unmap_msg(master, msg);
+}
+
 static int spi_map_msg(struct spi_master *master, struct spi_message *msg)
 {
 	struct spi_transfer *xfer;

commit 8e76ef88f607174082023f50b87fe12dcdbe5db5
Author: Martin Sperl <kernel@martin.sperl.org>
Date:   Sun May 10 07:50:45 2015 +0000

    spi: fix race freeing dummy_tx/rx before it is unmapped
    
    Fix a race (with some kernel configurations) where a queued
    master->pump_messages runs and frees dummy_tx/rx before
    spi_unmap_msg is running (or is finished).
    
    This results in the following messages:
      BUG: Bad page state in process
      page:db7ba030 count:0 mapcount:0 mapping:  (null) index:0x0
      flags: 0x200(arch_1)
      page dumped because: PAGE_FLAGS_CHECK_AT_PREP flag set
      ...
    
    Reported-by: Noralf TrÃ¸nnes <noralf@tronnes.org>
    Suggested-by: Noralf TrÃ¸nnes <noralf@tronnes.org>
    Tested-by: Noralf TrÃ¸nnes <noralf@tronnes.org>
    Signed-off-by: Martin Sperl <kernel@martin.sperl.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 50910d85df5a..d35c1a13217c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -988,9 +988,6 @@ void spi_finalize_current_message(struct spi_master *master)
 
 	spin_lock_irqsave(&master->queue_lock, flags);
 	mesg = master->cur_msg;
-	master->cur_msg = NULL;
-
-	queue_kthread_work(&master->kworker, &master->pump_messages);
 	spin_unlock_irqrestore(&master->queue_lock, flags);
 
 	spi_unmap_msg(master, mesg);
@@ -1003,9 +1000,13 @@ void spi_finalize_current_message(struct spi_master *master)
 		}
 	}
 
-	trace_spi_message_done(mesg);
-
+	spin_lock_irqsave(&master->queue_lock, flags);
+	master->cur_msg = NULL;
 	master->cur_msg_prepared = false;
+	queue_kthread_work(&master->kworker, &master->pump_messages);
+	spin_unlock_irqrestore(&master->queue_lock, flags);
+
+	trace_spi_message_done(mesg);
 
 	mesg->state = NULL;
 	if (mesg->complete)

commit f8bb820da4ae863c676156627973a950129559fb
Author: Robin Gong <b38343@freescale.com>
Date:   Thu Apr 16 10:54:18 2015 +0800

    spi: check tx_buf and rx_buf in spi_unmap_msg
    
    Some spi device drivers use the same tx_buf and rx_buf repeatly for better
    performance such as driver/input/touchsreen/ads7846.c, but spi core grab tx_buf
    /rx_buf of transfer and set them as dummy_tx/dummy_rx once they are NULL. Thus,
    in the second time the tx_buf/rx_buf will be replaced by dummy_tx/dummy_rx and
    the data which produced by the last tx or rx may be wrongly sent to the device
    or handled by the upper level protocol. This patch just keep the orignal value
    of tx_buf/rx_buf if they are NULL after this transfer processed.
    
    Signed-off-by: Robin Gong <b38343@freescale.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index d5d7d2235163..50910d85df5a 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -583,6 +583,15 @@ static int spi_unmap_msg(struct spi_master *master, struct spi_message *msg)
 	rx_dev = master->dma_rx->device->dev;
 
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		/*
+		 * Restore the original value of tx_buf or rx_buf if they are
+		 * NULL.
+		 */
+		if (xfer->tx_buf == master->dummy_tx)
+			xfer->tx_buf = NULL;
+		if (xfer->rx_buf == master->dummy_rx)
+			xfer->rx_buf = NULL;
+
 		if (!master->can_dma(master, msg->spi, xfer))
 			continue;
 

commit 8afba181b90fbad372c420c302a57c0c4f9fdae4
Merge: 35fbf8452ce6 db91841b58f9 d4f9dcd1ac94 7183d1ebda47 ea022bbb0090 eecacf73a40f
Author: Mark Brown <broonie@kernel.org>
Date:   Sat Apr 11 23:09:18 2015 +0100

    Merge remote-tracking branches 'spi/topic/omap-100k', 'spi/topic/omap-uwire', 'spi/topic/pl022', 'spi/topic/pm' and 'spi/topic/pxa2xx' into spi-next

commit 431959c0793e0d399303a061424dbaa1b33eb940
Merge: f9de73426c69 057f6061a197 38b6484e5b7b 207cda93f044 ff61eb422024
Author: Mark Brown <broonie@kernel.org>
Date:   Sat Apr 11 23:09:09 2015 +0100

    Merge remote-tracking branches 'spi/topic/blackfin', 'spi/topic/cadence', 'spi/topic/dw' and 'spi/topic/err' into spi-next

commit f9de73426c69ec3357c31a10af5f5acb037dbbaa
Merge: 19655dd08329 ea467326e36b b716c4ffc6a2 704f32d48af2 b3e7766bc459 232a5adc5199
Author: Mark Brown <broonie@kernel.org>
Date:   Sat Apr 11 23:09:03 2015 +0100

    Merge remote-tracking branches 'spi/topic/atmel', 'spi/topic/bcm2385', 'spi/topic/bcm2835', 'spi/topic/bcm53xx' and 'spi/topic/bitbang' into spi-next

commit e897f795a925c95082b6890c6c6a00286b702012
Merge: 31d25e5cdad8 22de3ef94bd1
Author: Mark Brown <broonie@kernel.org>
Date:   Sat Apr 11 23:09:00 2015 +0100

    Merge remote-tracking branch 'spi/topic/core' into spi-next

commit ff61eb422024a4614f898c1c73625e222b219a5d
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Apr 7 20:39:19 2015 +0200

    spi: Make master->handle_err() callback optional to avoid crashes
    
    If a driver doesn't implement the master->handle_err() callback and an
    SPI transfer fails, the kernel will crash with a NULL pointer
    dereference:
    
        Unable to handle kernel NULL pointer dereference at virtual address 00000000
        pgd = c0003000
        [00000000] *pgd=80000040004003, *pmd=00000000
        Internal error: Oops: 80000206 [#1] SMP ARM
        Modules linked in:
        CPU: 1 PID: 1 Comm: swapper/0 Not tainted 4.0.0-rc7-koelsch-05861-g1fc9fdd4add4f783 #1046
        Hardware name: Generic R8A7791 (Flattened Device Tree)
        task: eec359c0 ti: eec54000 task.ti: eec54000
        PC is at 0x0
        LR is at spi_transfer_one_message+0x1cc/0x1f0
    
    Make the master->handle_err() callback optional to avoid the crash.
    
    Also fix a spelling mistake in the callback documentation while we're at
    it.
    
    Fixes: b716c4ffc6a2b0bf ("spi: introduce master->handle_err() callback")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 31d4d9d997e2..771325322995 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -851,7 +851,7 @@ static int spi_transfer_one_message(struct spi_master *master,
 	if (msg->status == -EINPROGRESS)
 		msg->status = ret;
 
-	if (msg->status)
+	if (msg->status && master->handle_err)
 		master->handle_err(master, msg);
 
 	spi_finalize_current_message(master);

commit 22de3ef94bd191537227a7f1bb0908f368601f03
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed Mar 25 13:32:22 2015 -0700

    spi: of: do explicitly request modules for of-registered devices
    
    Trying to register an SPI device asynchronously (via async_schedule() call)
    results in an ugly complaint from request_module() warning about potential
    deadlock (because request_module tries to wait for async works to
    complete, the caller is also an async work in this case).
    
    While we could try to switch to using request_module_nowait(), other buses,
    as well as SPI itself when not using device tree, do not try to load
    modules explicitly, but rather rely on the standard infrastructure (such as
    udev) to execute module loading. There is no reason why SPI OF-described
    devices should be treated differently.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 4023cc98d808..436ae1b6f6cc 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -16,7 +16,6 @@
  */
 
 #include <linux/kernel.h>
-#include <linux/kmod.h>
 #include <linux/device.h>
 #include <linux/init.h>
 #include <linux/cache.h>
@@ -1359,7 +1358,6 @@ of_register_spi_device(struct spi_master *master, struct device_node *nc)
 	spi->dev.of_node = nc;
 
 	/* Register the new device */
-	request_module("%s%s", SPI_MODULE_PREFIX, spi->modalias);
 	rc = spi_add_device(spi);
 	if (rc) {
 		dev_err(&master->dev, "spi_device register error %s\n",

commit 391949b6f02121371e3d7d9082c6d17fd9853034
Author: Uwe Kleine-KÃ¶nig <u.kleine-koenig@pengutronix.de>
Date:   Wed Mar 18 11:27:28 2015 +0100

    spi: trigger trace event for message-done before mesg->complete
    
    With spidev the mesg->complete callback points to spidev_complete.
    Calling this unblocks spidev_sync and so spidev_sync_write finishes. As
    the struct spi_message just read is a local variable in
    spidev_sync_write and recording the trace event accesses this message
    the recording is better done first. The same can happen for
    spidev_sync_read.
    
    This fixes an oops observed on a 3.14-rt system with spidev activity
    after
    
            echo 1 > /sys/kernel/debug/tracing/events/spi/enable
    
    .
    
    Signed-off-by: Uwe Kleine-KÃ¶nig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index c64a3e59fce3..57a195041dc7 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1105,13 +1105,14 @@ void spi_finalize_current_message(struct spi_master *master)
 				"failed to unprepare message: %d\n", ret);
 		}
 	}
+
+	trace_spi_message_done(mesg);
+
 	master->cur_msg_prepared = false;
 
 	mesg->state = NULL;
 	if (mesg->complete)
 		mesg->complete(mesg->context);
-
-	trace_spi_message_done(mesg);
 }
 EXPORT_SYMBOL_GPL(spi_finalize_current_message);
 

commit 1a7b7ee72c218ce9bff274ade13b96ea03eed03d
Author: Ivan T. Ivanov <iivanov@mm-sol.com>
Date:   Fri Mar 13 18:43:49 2015 +0200

    spi: Ensure that CS line is in non-active state after spi_setup()
    
    Some devices samples state of the chip select signal during power up
    and act differently based on this state, so SPI core should ensure
    that CS line is driven in non-active state after spi_setup().
    
    Signed-off-by: Ivan T. Ivanov <iivanov@mm-sol.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index c64a3e59fce3..4023cc98d808 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1893,6 +1893,8 @@ int spi_setup(struct spi_device *spi)
 	if (!spi->max_speed_hz)
 		spi->max_speed_hz = spi->master->max_speed_hz;
 
+	spi_set_cs(spi, false);
+
 	if (spi->master->setup)
 		status = spi->master->setup(spi);
 

commit ea022bbb0090975a21c581d8405fbe90043a6eda
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun Mar 8 14:56:38 2015 +0100

    spi: Remove support for legacy PM
    
    All SPI drivers have been converted from legacy suspend/resume callbacks to
    dev_pm_ops. So we can finally remove support for legacy PM from the SPI
    core.
    
    Since there aren't any special bus specific things to do during
    suspend/resume and since the PM core will automatically fallback directly to
    using the device's PM ops if no bus PM ops are specified there is no need to
    have any special SPI bus PM ops.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index c64a3e59fce3..7a2b7a7cb650 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -129,125 +129,11 @@ static int spi_uevent(struct device *dev, struct kobj_uevent_env *env)
 	return 0;
 }
 
-#ifdef CONFIG_PM_SLEEP
-static int spi_legacy_suspend(struct device *dev, pm_message_t message)
-{
-	int			value = 0;
-	struct spi_driver	*drv = to_spi_driver(dev->driver);
-
-	/* suspend will stop irqs and dma; no more i/o */
-	if (drv) {
-		if (drv->suspend)
-			value = drv->suspend(to_spi_device(dev), message);
-		else
-			dev_dbg(dev, "... can't suspend\n");
-	}
-	return value;
-}
-
-static int spi_legacy_resume(struct device *dev)
-{
-	int			value = 0;
-	struct spi_driver	*drv = to_spi_driver(dev->driver);
-
-	/* resume may restart the i/o queue */
-	if (drv) {
-		if (drv->resume)
-			value = drv->resume(to_spi_device(dev));
-		else
-			dev_dbg(dev, "... can't resume\n");
-	}
-	return value;
-}
-
-static int spi_pm_suspend(struct device *dev)
-{
-	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
-
-	if (pm)
-		return pm_generic_suspend(dev);
-	else
-		return spi_legacy_suspend(dev, PMSG_SUSPEND);
-}
-
-static int spi_pm_resume(struct device *dev)
-{
-	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
-
-	if (pm)
-		return pm_generic_resume(dev);
-	else
-		return spi_legacy_resume(dev);
-}
-
-static int spi_pm_freeze(struct device *dev)
-{
-	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
-
-	if (pm)
-		return pm_generic_freeze(dev);
-	else
-		return spi_legacy_suspend(dev, PMSG_FREEZE);
-}
-
-static int spi_pm_thaw(struct device *dev)
-{
-	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
-
-	if (pm)
-		return pm_generic_thaw(dev);
-	else
-		return spi_legacy_resume(dev);
-}
-
-static int spi_pm_poweroff(struct device *dev)
-{
-	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
-
-	if (pm)
-		return pm_generic_poweroff(dev);
-	else
-		return spi_legacy_suspend(dev, PMSG_HIBERNATE);
-}
-
-static int spi_pm_restore(struct device *dev)
-{
-	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
-
-	if (pm)
-		return pm_generic_restore(dev);
-	else
-		return spi_legacy_resume(dev);
-}
-#else
-#define spi_pm_suspend	NULL
-#define spi_pm_resume	NULL
-#define spi_pm_freeze	NULL
-#define spi_pm_thaw	NULL
-#define spi_pm_poweroff	NULL
-#define spi_pm_restore	NULL
-#endif
-
-static const struct dev_pm_ops spi_pm = {
-	.suspend = spi_pm_suspend,
-	.resume = spi_pm_resume,
-	.freeze = spi_pm_freeze,
-	.thaw = spi_pm_thaw,
-	.poweroff = spi_pm_poweroff,
-	.restore = spi_pm_restore,
-	SET_RUNTIME_PM_OPS(
-		pm_generic_runtime_suspend,
-		pm_generic_runtime_resume,
-		NULL
-	)
-};
-
 struct bus_type spi_bus_type = {
 	.name		= "spi",
 	.dev_groups	= spi_dev_groups,
 	.match		= spi_match_device,
 	.uevent		= spi_uevent,
-	.pm		= &spi_pm,
 };
 EXPORT_SYMBOL_GPL(spi_bus_type);
 

commit b716c4ffc6a2b0bfbcf9619880f335be11b65708
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Feb 27 17:34:15 2015 +0200

    spi: introduce master->handle_err() callback
    
    This callback would be useful to handle an error that occurs in the generic
    implementation of transfer_one_message(). The good candidate for this is to
    drain FIFO and / or to terminate DMA transfers when timeout happened.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index c64a3e59fce3..31d4d9d997e2 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -851,6 +851,9 @@ static int spi_transfer_one_message(struct spi_master *master,
 	if (msg->status == -EINPROGRESS)
 		msg->status = ret;
 
+	if (msg->status)
+		master->handle_err(master, msg);
+
 	spi_finalize_current_message(master);
 
 	return ret;

commit 8328509c4bdf28b83fd7104ca9da01bf3b58c7b0
Merge: d6cd09bea9e4 549858ce76e3 56536a7ff59c fc9e0f71f2d7 9caf5067b9cb f2234691d7d7
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Feb 8 11:16:52 2015 +0800

    Merge remote-tracking branches 'spi/topic/img-spfi', 'spi/topic/imx', 'spi/topic/inline', 'spi/topic/meson' and 'spi/topic/mxs' into spi-next

commit d6cd09bea9e4e1048d566cb2f462a9e0270e6926
Merge: fab4b42a9a3d 7f6d62a2adc6 2c658e212ce7 38455d7ac2e3 ceadfd8de067 650705cf73f8
Author: Mark Brown <broonie@kernel.org>
Date:   Sun Feb 8 11:16:46 2015 +0800

    Merge remote-tracking branches 'spi/topic/falcon', 'spi/topic/fsf', 'spi/topic/fsl', 'spi/topic/fsl-dspi' and 'spi/topic/gpio' into spi-next

commit 682a71b28406a53bdc05c4c0d48443af72f1298e
Author: Nicholas Mc Guire <der.herr@hofr.at>
Date:   Mon Feb 2 03:30:32 2015 -0500

    spi: match var type to return type of wait_for_completion
    
    return type of wait_for_completion_timeout is unsigned long not int, this
    patch changes the type of m from int to unsigned long.
    
    Signed-off-by: Nicholas Mc Guire <der.herr@hofr.at>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 66a70e9bc743..ba17929102ae 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -788,7 +788,7 @@ static int spi_transfer_one_message(struct spi_master *master,
 	struct spi_transfer *xfer;
 	bool keep_cs = false;
 	int ret = 0;
-	int ms = 1;
+	unsigned long ms = 1;
 
 	spi_set_cs(msg->spi, true);
 

commit 2c658e212ce7e40ace56d9441c8c5634d4d420e3
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Thu Dec 18 16:12:08 2014 +0200

    spi: Remove FSF mailing addresses
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 66a70e9bc743..c76cc7568639 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -13,10 +13,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include <linux/kernel.h>

commit 7ef58b32f571bffb7763c6252ad7527562081f34
Merge: 413fd0e3fbf5 c46ca3c8310b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 11 13:06:58 2014 -0800

    Merge tag 'devicetree-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/glikely/linux
    
    Pull devicetree changes from Grant Likely:
     "Lots of activity in the devicetree code for v3.18.  Most of it is
      related to getting all of the overlay support code in place, but there
      are other important things in there.
    
      Highlights:
    
       - OF_RECONFIG notifiers for SPI, I2C and Platform devices.  Those
         subsystems can now respond to live changes to the device tree.
    
       - CONFIG_OF_OVERLAY method for applying live changes to the device
         tree
    
       - Removal of the of_allnodes list.  This used to be used to iterate
         over all the nodes in the device tree, but it is unnecessary
         because the same thing can be done by iterating over the list of
         child pointers.  Getting rid of of_allnodes saves some memory and
         avoids the possibility of of_allnodes being sorted differently from
         the child lists.
    
       - Support for retrieving original DTB blob via sysfs.  Needed by
         kexec.
    
       - More unittests
    
       - Documentation and minor bug fixes"
    
    * tag 'devicetree-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/glikely/linux: (42 commits)
      of: Delete unnecessary check before calling "of_node_put()"
      of: Drop ->next pointer from struct device_node
      spi: Check for spi_of_notifier when CONFIG_OF_DYNAMIC=y
      of: support passing console options with stdout-path
      of: add optional options parameter to of_find_node_by_path()
      of: Add bindings for chosen node, stdout-path
      of: Remove unneeded and incorrect MODULE_DEVICE_TABLE
      ARM: dt: fix up PL011 device tree bindings
      of: base, fix of_property_read_string_helper kernel-doc
      of: remove select of non-existant OF_DEVICE config symbol
      spi/of: Add OF notifier handler
      spi/of: Create new device registration method and accessors
      i2c/of: Add OF_RECONFIG notifier handler
      i2c/of: Factor out Devicetree registration code
      of/overlay: Add overlay unittests
      of/overlay: Introduce DT overlay support
      of/reconfig: Add OF_DYNAMIC notifier for platform_bus_type
      of/reconfig: Always use the same structure for notifiers
      of/reconfig: Add debug output for OF_RECONFIG notifiers
      of/reconfig: Add empty stubs for the of_reconfig methods
      ...

commit fc9e0f71f2d7ea43fa3ba0bea68586d1462cb5a7
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Dec 10 13:46:33 2014 +0000

    spi: Only idle the message pump in the worker kthread
    
    In order to avoid the situation where the kthread is waiting for another
    context to make the hardware idle let the message pump know if it's being
    called from the worker thread context and if it isn't then defer to the
    worker thread instead of idling the hardware immediately. This will ensure
    that if this situation happens we block rather than busy waiting.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index e1bf2579b9c0..3ac188fc36f5 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -875,8 +875,9 @@ void spi_finalize_current_transfer(struct spi_master *master)
 EXPORT_SYMBOL_GPL(spi_finalize_current_transfer);
 
 /**
- * spi_pump_messages - kthread work function which processes spi message queue
- * @work: pointer to kthread work struct contained in the master struct
+ * __spi_pump_messages - function which processes spi message queue
+ * @master: master to process queue for
+ * @in_kthread: true if we are in the context of the message pump thread
  *
  * This function checks if there is any spi message in the queue that
  * needs processing and if so call out to the driver to initialize hardware
@@ -886,10 +887,8 @@ EXPORT_SYMBOL_GPL(spi_finalize_current_transfer);
  * inside spi_sync(); the queue extraction handling at the top of the
  * function should deal with this safely.
  */
-static void spi_pump_messages(struct kthread_work *work)
+static void __spi_pump_messages(struct spi_master *master, bool in_kthread)
 {
-	struct spi_master *master =
-		container_of(work, struct spi_master, pump_messages);
 	unsigned long flags;
 	bool was_busy = false;
 	int ret;
@@ -916,6 +915,15 @@ static void spi_pump_messages(struct kthread_work *work)
 			spin_unlock_irqrestore(&master->queue_lock, flags);
 			return;
 		}
+
+		/* Only do teardown in the thread */
+		if (!in_kthread) {
+			queue_kthread_work(&master->kworker,
+					   &master->pump_messages);
+			spin_unlock_irqrestore(&master->queue_lock, flags);
+			return;
+		}
+
 		master->busy = false;
 		master->idling = true;
 		spin_unlock_irqrestore(&master->queue_lock, flags);
@@ -1004,6 +1012,18 @@ static void spi_pump_messages(struct kthread_work *work)
 	}
 }
 
+/**
+ * spi_pump_messages - kthread work function which processes spi message queue
+ * @work: pointer to kthread work struct contained in the master struct
+ */
+static void spi_pump_messages(struct kthread_work *work)
+{
+	struct spi_master *master =
+		container_of(work, struct spi_master, pump_messages);
+
+	__spi_pump_messages(master, true);
+}
+
 static int spi_init_queue(struct spi_master *master)
 {
 	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
@@ -2163,7 +2183,7 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message,
 		 * can.
 		 */
 		if (master->transfer == spi_queued_transfer)
-			spi_pump_messages(&master->pump_messages);
+			__spi_pump_messages(master, false);
 
 		wait_for_completion(&done);
 		status = message->status;

commit 0461a4149836c792d186027c8c859637a4cfb11a
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Dec 9 21:38:05 2014 +0000

    spi: Pump transfers inside calling context for spi_sync()
    
    If we are using the standard SPI message pump (which all drivers should be
    transitioning over to) then special case the message enqueue and instead of
    starting the worker thread to push messages to the hardware do so in the
    context of the caller if the controller is idle. This avoids a context
    switch in the common case where the controller has a single user in a
    single thread, for short PIO transfers there may be no need to context
    switch away from the calling context to complete the transfer.
    
    The code is a bit more complex than is desirable in part due to the need
    to handle drivers not using the standard queue and in part due to handling
    the various combinations of bus locking and asynchronous submission in
    interrupt context.
    
    It is still suboptimal since it will still wake the message pump for each
    transfer in order to schedule idling of the hardware and if multiple
    contexts are using the controller simultaneously a caller may end up
    pumping a message for some random other thread rather than for itself,
    and if the thread ends up deferring due to another context idling the
    hardware then it will just busy wait.  It can, however, have the benefit
    of aggregating power up and down of the hardware when a caller performs
    a series of transfers back to back without any need for the use of
    spi_async().
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 0bc752d17be5..e1bf2579b9c0 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -882,6 +882,9 @@ EXPORT_SYMBOL_GPL(spi_finalize_current_transfer);
  * needs processing and if so call out to the driver to initialize hardware
  * and transfer each message.
  *
+ * Note that it is called both from the kthread itself and also from
+ * inside spi_sync(); the queue extraction handling at the top of the
+ * function should deal with this safely.
  */
 static void spi_pump_messages(struct kthread_work *work)
 {
@@ -900,6 +903,13 @@ static void spi_pump_messages(struct kthread_work *work)
 		return;
 	}
 
+	/* If another context is idling the device then defer */
+	if (master->idling) {
+		queue_kthread_work(&master->kworker, &master->pump_messages);
+		spin_unlock_irqrestore(&master->queue_lock, flags);
+		return;
+	}
+
 	/* Check if the queue is idle */
 	if (list_empty(&master->queue) || !master->running) {
 		if (!master->busy) {
@@ -907,7 +917,9 @@ static void spi_pump_messages(struct kthread_work *work)
 			return;
 		}
 		master->busy = false;
+		master->idling = true;
 		spin_unlock_irqrestore(&master->queue_lock, flags);
+
 		kfree(master->dummy_rx);
 		master->dummy_rx = NULL;
 		kfree(master->dummy_tx);
@@ -921,6 +933,10 @@ static void spi_pump_messages(struct kthread_work *work)
 			pm_runtime_put_autosuspend(master->dev.parent);
 		}
 		trace_spi_master_idle(master);
+
+		spin_lock_irqsave(&master->queue_lock, flags);
+		master->idling = false;
+		spin_unlock_irqrestore(&master->queue_lock, flags);
 		return;
 	}
 
@@ -1161,12 +1177,9 @@ static int spi_destroy_queue(struct spi_master *master)
 	return 0;
 }
 
-/**
- * spi_queued_transfer - transfer function for queued transfers
- * @spi: spi device which is requesting transfer
- * @msg: spi message which is to handled is queued to driver queue
- */
-static int spi_queued_transfer(struct spi_device *spi, struct spi_message *msg)
+static int __spi_queued_transfer(struct spi_device *spi,
+				 struct spi_message *msg,
+				 bool need_pump)
 {
 	struct spi_master *master = spi->master;
 	unsigned long flags;
@@ -1181,13 +1194,23 @@ static int spi_queued_transfer(struct spi_device *spi, struct spi_message *msg)
 	msg->status = -EINPROGRESS;
 
 	list_add_tail(&msg->queue, &master->queue);
-	if (!master->busy)
+	if (!master->busy && need_pump)
 		queue_kthread_work(&master->kworker, &master->pump_messages);
 
 	spin_unlock_irqrestore(&master->queue_lock, flags);
 	return 0;
 }
 
+/**
+ * spi_queued_transfer - transfer function for queued transfers
+ * @spi: spi device which is requesting transfer
+ * @msg: spi message which is to handled is queued to driver queue
+ */
+static int spi_queued_transfer(struct spi_device *spi, struct spi_message *msg)
+{
+	return __spi_queued_transfer(spi, msg, true);
+}
+
 static int spi_master_initialize_queue(struct spi_master *master)
 {
 	int ret;
@@ -2102,19 +2125,46 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message,
 	DECLARE_COMPLETION_ONSTACK(done);
 	int status;
 	struct spi_master *master = spi->master;
+	unsigned long flags;
+
+	status = __spi_validate(spi, message);
+	if (status != 0)
+		return status;
 
 	message->complete = spi_complete;
 	message->context = &done;
+	message->spi = spi;
 
 	if (!bus_locked)
 		mutex_lock(&master->bus_lock_mutex);
 
-	status = spi_async_locked(spi, message);
+	/* If we're not using the legacy transfer method then we will
+	 * try to transfer in the calling context so special case.
+	 * This code would be less tricky if we could remove the
+	 * support for driver implemented message queues.
+	 */
+	if (master->transfer == spi_queued_transfer) {
+		spin_lock_irqsave(&master->bus_lock_spinlock, flags);
+
+		trace_spi_message_submit(message);
+
+		status = __spi_queued_transfer(spi, message, false);
+
+		spin_unlock_irqrestore(&master->bus_lock_spinlock, flags);
+	} else {
+		status = spi_async_locked(spi, message);
+	}
 
 	if (!bus_locked)
 		mutex_unlock(&master->bus_lock_mutex);
 
 	if (status == 0) {
+		/* Push out the messages in the calling context if we
+		 * can.
+		 */
+		if (master->transfer == spi_queued_transfer)
+			spi_pump_messages(&master->pump_messages);
+
 		wait_for_completion(&done);
 		status = message->status;
 	}

commit 983aee5d7090cf12b624f18533777caa09d067b1
Author: Mark Brown <broonie@kernel.org>
Date:   Tue Dec 9 19:46:56 2014 +0000

    spi: Check to see if the device is processing a message before we idle
    
    cur_msg is updated under the queue lock and holds the message we are
    currently processing. Since currently we only ever do removals in the
    pump kthread it doesn't matter in what order we do things but we want
    to be able to push things out from the submitting thread so pull the
    check to see if we're currently handling a message before we check to
    see if the queue is idle.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b81ccdb1bc16..0bc752d17be5 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -891,8 +891,16 @@ static void spi_pump_messages(struct kthread_work *work)
 	bool was_busy = false;
 	int ret;
 
-	/* Lock queue and check for queue work */
+	/* Lock queue */
 	spin_lock_irqsave(&master->queue_lock, flags);
+
+	/* Make sure we are not already running a message */
+	if (master->cur_msg) {
+		spin_unlock_irqrestore(&master->queue_lock, flags);
+		return;
+	}
+
+	/* Check if the queue is idle */
 	if (list_empty(&master->queue) || !master->running) {
 		if (!master->busy) {
 			spin_unlock_irqrestore(&master->queue_lock, flags);
@@ -916,11 +924,6 @@ static void spi_pump_messages(struct kthread_work *work)
 		return;
 	}
 
-	/* Make sure we are not already running a message */
-	if (master->cur_msg) {
-		spin_unlock_irqrestore(&master->queue_lock, flags);
-		return;
-	}
 	/* Extract head of queue */
 	master->cur_msg =
 		list_first_entry(&master->queue, struct spi_message, queue);

commit 5424d43e4daddf71aaa60d6565c8816af9150adf
Author: Mark Brown <broonie@kernel.org>
Date:   Wed Dec 10 17:40:53 2014 +0000

    spi: Move queue data structure initialisation to main master init
    
    Since most devices now do use the standard queue and in order to avoid
    initialisation ordering issues being introduced by further refactorings
    to improve performance move the initialisation of the queue and the lock
    for it to the main master allocation.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index da7e6225b8f6..b81ccdb1bc16 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -989,9 +989,6 @@ static int spi_init_queue(struct spi_master *master)
 {
 	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
 
-	INIT_LIST_HEAD(&master->queue);
-	spin_lock_init(&master->queue_lock);
-
 	master->running = false;
 	master->busy = false;
 
@@ -1595,6 +1592,8 @@ int spi_register_master(struct spi_master *master)
 		dynamic = 1;
 	}
 
+	INIT_LIST_HEAD(&master->queue);
+	spin_lock_init(&master->queue_lock);
 	spin_lock_init(&master->bus_lock_spinlock);
 	mutex_init(&master->bus_lock_mutex);
 	master->bus_lock_flag = 0;

commit 19a0368028de2575ed562600888d856196ebfc05
Merge: c9508d4b3a0a 98a8f5a0538f
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Dec 8 12:17:11 2014 +0000

    Merge remote-tracking branch 'spi/topic/core' into spi-next

commit 98a8f5a0538fe1a02a6a73a3451f1c093e30bdfc
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Thu Dec 4 11:02:25 2014 +0200

    spi: core: Do not mangle error code from kthread_run()
    
    kthread_run() could return ERR_PTR(-EINTR) from kthread_create_on_node().
    Return the actual error code in spi_init_queue() instead of mangling it to
    -ENOMEM.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index ebcb33df2eb2..4395a5406e5c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1001,7 +1001,7 @@ static int spi_init_queue(struct spi_master *master)
 					   dev_name(&master->dev));
 	if (IS_ERR(master->kworker_task)) {
 		dev_err(&master->dev, "failed to create message pump task\n");
-		return -ENOMEM;
+		return PTR_ERR(master->kworker_task);
 	}
 	init_kthread_work(&master->pump_messages, spi_pump_messages);
 

commit 5267720e7515f0fadf4cdef68dccafc18d48c806
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Wed Nov 26 20:13:57 2014 -0200

    spi: Check for spi_of_notifier when CONFIG_OF_DYNAMIC=y
    
    Since commit ce79d54ae447d651173 ("spi/of: Add OF notifier handler") the
    following warning is seen on a imx53 system that has CONFIG_OF_DYNAMIC=n:
    
    [    0.048119] ------------[ cut here ]------------
    [    0.048146] WARNING: CPU: 0 PID: 1 at drivers/spi/spi.c:2419 spi_init+0x60/0xa8()
    [    0.048158] Modules linked in:
    [    0.048183] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.18.0-rc6-next-20141126-00003-g9388e85 #2080
    [    0.048193] Hardware name: Freescale i.MX53 (Device Tree Support)
    [    0.048203] Backtrace:
    [    0.048235] [<80011f74>] (dump_backtrace) from [<80012110>] (show_stack+0x18/0x1c)
    [    0.048246]  r6:00000973 r5:00000000 r4:00000000 r3:00000000
    [    0.048284] [<800120f8>] (show_stack) from [<806b3ad8>] (dump_stack+0x88/0xa4)
    [    0.048312] [<806b3a50>] (dump_stack) from [<8002a55c>] (warn_slowpath_common+0x80/0xbc)
    [    0.048320]  r5:8096cfcc r4:00000000
    [    0.048343] [<8002a4dc>] (warn_slowpath_common) from [<8002a5bc>] (warn_slowpath_null+0x24/0x2c)
    [    0.048354]  r8:8096cf6c r7:809355ec r6:ddcd7c00 r5:812029e4 r4:00000000
    [    0.048389] [<8002a598>] (warn_slowpath_null) from [<8096cfcc>] (spi_init+0x60/0xa8)
    [    0.048405] [<8096cf6c>] (spi_init) from [<80008a7c>] (do_one_initcall+0x88/0x1e0)
    [    0.048415]  r5:8099e018 r4:8099e018
    [    0.048438] [<800089f4>] (do_one_initcall) from [<80935e38>] (kernel_init_freeable+0x110/0x1e0)
    [    0.048448]  r10:80980700 r9:809806e4 r8:000000cc r7:809355ec r6:809f8940 r5:00000002
    [    0.048478]  r4:8098d744
    [    0.048508] [<80935d28>] (kernel_init_freeable) from [<806ae574>] (kernel_init+0x10/0xf4)
    [    0.048517]  r10:00000000 r9:00000000 r8:00000000 r7:00000000 r6:00000000 r5:806ae564
    [    0.048547]  r4:00000000
    [    0.048565] [<806ae564>] (kernel_init) from [<8000ed68>] (ret_from_fork+0x14/0x2c)
    [    0.048574]  r4:00000000 r3:00000000
    [    0.048616] ---[ end trace 405a65d177dae4fd ]---
    
    Only check of_reconfig_notifier_register() in the CONFIG_OF_DYNAMIC=y case,
    as intended by commit ce79d54ae447d65.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index bf1cab0fad66..cf4ed29c7ee6 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2415,7 +2415,7 @@ static int __init spi_init(void)
 	if (status < 0)
 		goto err2;
 
-	if (IS_ENABLED(CONFIG_OF))
+	if (IS_ENABLED(CONFIG_OF_DYNAMIC))
 		WARN_ON(of_reconfig_notifier_register(&spi_of_notifier));
 
 	return 0;

commit ce79d54ae447d65117303ca9f61ffe9dcbc2465d
Author: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
Date:   Tue Oct 28 22:36:05 2014 +0200

    spi/of: Add OF notifier handler
    
    Add OF notifier handler needed for creating/destroying spi devices
    according to dynamic runtime changes in the DT live tree. This code is
    enabled when CONFIG_OF_DYNAMIC is selected.
    
    Signed-off-by: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Reviewed-by: Mark Brown <broonie@kernel.org>
    Cc: <linux-spi@vger.kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index a3557c57d4f7..bf1cab0fad66 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2317,6 +2317,86 @@ EXPORT_SYMBOL_GPL(spi_write_then_read);
 
 /*-------------------------------------------------------------------------*/
 
+#if IS_ENABLED(CONFIG_OF_DYNAMIC)
+static int __spi_of_device_match(struct device *dev, void *data)
+{
+	return dev->of_node == data;
+}
+
+/* must call put_device() when done with returned spi_device device */
+static struct spi_device *of_find_spi_device_by_node(struct device_node *node)
+{
+	struct device *dev = bus_find_device(&spi_bus_type, NULL, node,
+						__spi_of_device_match);
+	return dev ? to_spi_device(dev) : NULL;
+}
+
+static int __spi_of_master_match(struct device *dev, const void *data)
+{
+	return dev->of_node == data;
+}
+
+/* the spi masters are not using spi_bus, so we find it with another way */
+static struct spi_master *of_find_spi_master_by_node(struct device_node *node)
+{
+	struct device *dev;
+
+	dev = class_find_device(&spi_master_class, NULL, node,
+				__spi_of_master_match);
+	if (!dev)
+		return NULL;
+
+	/* reference got in class_find_device */
+	return container_of(dev, struct spi_master, dev);
+}
+
+static int of_spi_notify(struct notifier_block *nb, unsigned long action,
+			 void *arg)
+{
+	struct of_reconfig_data *rd = arg;
+	struct spi_master *master;
+	struct spi_device *spi;
+
+	switch (of_reconfig_get_state_change(action, arg)) {
+	case OF_RECONFIG_CHANGE_ADD:
+		master = of_find_spi_master_by_node(rd->dn->parent);
+		if (master == NULL)
+			return NOTIFY_OK;	/* not for us */
+
+		spi = of_register_spi_device(master, rd->dn);
+		put_device(&master->dev);
+
+		if (IS_ERR(spi)) {
+			pr_err("%s: failed to create for '%s'\n",
+					__func__, rd->dn->full_name);
+			return notifier_from_errno(PTR_ERR(spi));
+		}
+		break;
+
+	case OF_RECONFIG_CHANGE_REMOVE:
+		/* find our device by node */
+		spi = of_find_spi_device_by_node(rd->dn);
+		if (spi == NULL)
+			return NOTIFY_OK;	/* no? not meant for us */
+
+		/* unregister takes one ref away */
+		spi_unregister_device(spi);
+
+		/* and put the reference of the find */
+		put_device(&spi->dev);
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block spi_of_notifier = {
+	.notifier_call = of_spi_notify,
+};
+#else /* IS_ENABLED(CONFIG_OF_DYNAMIC) */
+extern struct notifier_block spi_of_notifier;
+#endif /* IS_ENABLED(CONFIG_OF_DYNAMIC) */
+
 static int __init spi_init(void)
 {
 	int	status;
@@ -2334,6 +2414,10 @@ static int __init spi_init(void)
 	status = class_register(&spi_master_class);
 	if (status < 0)
 		goto err2;
+
+	if (IS_ENABLED(CONFIG_OF))
+		WARN_ON(of_reconfig_notifier_register(&spi_of_notifier));
+
 	return 0;
 
 err2:

commit aff5e3f89a0b07e7edf9243f913378cc27e4110d
Author: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
Date:   Wed Oct 29 10:40:37 2014 +0200

    spi/of: Create new device registration method and accessors
    
    Dynamically inserting spi device nodes requires the use of a single
    device registration method. Refactor the existing
    of_register_spi_devices() to split out the core functionality for a
    single device into a separate function; of_register_spi_device(). This
    function will be used by the OF_DYNAMIC overlay code to make live
    modifications to the tree.
    
    Methods to lookup a device/master using a device node are added
    as well, of_find_spi_master_by_node() & of_find_spi_device_by_node().
    
    Signed-off-by: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    [grant.likely] Split patch into two pieces for clarity
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Reviewed-by: Mark Brown <broonie@kernel.org>
    Cc: <linux-spi@vger.kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index ebcb33df2eb2..a3557c57d4f7 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1220,6 +1220,121 @@ static int spi_master_initialize_queue(struct spi_master *master)
 /*-------------------------------------------------------------------------*/
 
 #if defined(CONFIG_OF)
+static struct spi_device *
+of_register_spi_device(struct spi_master *master, struct device_node *nc)
+{
+	struct spi_device *spi;
+	int rc;
+	u32 value;
+
+	/* Alloc an spi_device */
+	spi = spi_alloc_device(master);
+	if (!spi) {
+		dev_err(&master->dev, "spi_device alloc error for %s\n",
+			nc->full_name);
+		rc = -ENOMEM;
+		goto err_out;
+	}
+
+	/* Select device driver */
+	rc = of_modalias_node(nc, spi->modalias,
+				sizeof(spi->modalias));
+	if (rc < 0) {
+		dev_err(&master->dev, "cannot find modalias for %s\n",
+			nc->full_name);
+		goto err_out;
+	}
+
+	/* Device address */
+	rc = of_property_read_u32(nc, "reg", &value);
+	if (rc) {
+		dev_err(&master->dev, "%s has no valid 'reg' property (%d)\n",
+			nc->full_name, rc);
+		goto err_out;
+	}
+	spi->chip_select = value;
+
+	/* Mode (clock phase/polarity/etc.) */
+	if (of_find_property(nc, "spi-cpha", NULL))
+		spi->mode |= SPI_CPHA;
+	if (of_find_property(nc, "spi-cpol", NULL))
+		spi->mode |= SPI_CPOL;
+	if (of_find_property(nc, "spi-cs-high", NULL))
+		spi->mode |= SPI_CS_HIGH;
+	if (of_find_property(nc, "spi-3wire", NULL))
+		spi->mode |= SPI_3WIRE;
+	if (of_find_property(nc, "spi-lsb-first", NULL))
+		spi->mode |= SPI_LSB_FIRST;
+
+	/* Device DUAL/QUAD mode */
+	if (!of_property_read_u32(nc, "spi-tx-bus-width", &value)) {
+		switch (value) {
+		case 1:
+			break;
+		case 2:
+			spi->mode |= SPI_TX_DUAL;
+			break;
+		case 4:
+			spi->mode |= SPI_TX_QUAD;
+			break;
+		default:
+			dev_warn(&master->dev,
+				"spi-tx-bus-width %d not supported\n",
+				value);
+			break;
+		}
+	}
+
+	if (!of_property_read_u32(nc, "spi-rx-bus-width", &value)) {
+		switch (value) {
+		case 1:
+			break;
+		case 2:
+			spi->mode |= SPI_RX_DUAL;
+			break;
+		case 4:
+			spi->mode |= SPI_RX_QUAD;
+			break;
+		default:
+			dev_warn(&master->dev,
+				"spi-rx-bus-width %d not supported\n",
+				value);
+			break;
+		}
+	}
+
+	/* Device speed */
+	rc = of_property_read_u32(nc, "spi-max-frequency", &value);
+	if (rc) {
+		dev_err(&master->dev, "%s has no valid 'spi-max-frequency' property (%d)\n",
+			nc->full_name, rc);
+		goto err_out;
+	}
+	spi->max_speed_hz = value;
+
+	/* IRQ */
+	spi->irq = irq_of_parse_and_map(nc, 0);
+
+	/* Store a pointer to the node in the device structure */
+	of_node_get(nc);
+	spi->dev.of_node = nc;
+
+	/* Register the new device */
+	request_module("%s%s", SPI_MODULE_PREFIX, spi->modalias);
+	rc = spi_add_device(spi);
+	if (rc) {
+		dev_err(&master->dev, "spi_device register error %s\n",
+			nc->full_name);
+		goto err_out;
+	}
+
+	return spi;
+
+err_out:
+	spi_dev_put(spi);
+	return ERR_PTR(rc);
+}
+
 /**
  * of_register_spi_devices() - Register child devices onto the SPI bus
  * @master:	Pointer to spi_master device
@@ -1231,116 +1346,15 @@ static void of_register_spi_devices(struct spi_master *master)
 {
 	struct spi_device *spi;
 	struct device_node *nc;
-	int rc;
-	u32 value;
 
 	if (!master->dev.of_node)
 		return;
 
 	for_each_available_child_of_node(master->dev.of_node, nc) {
-		/* Alloc an spi_device */
-		spi = spi_alloc_device(master);
-		if (!spi) {
-			dev_err(&master->dev, "spi_device alloc error for %s\n",
+		spi = of_register_spi_device(master, nc);
+		if (IS_ERR(spi))
+			dev_warn(&master->dev, "Failed to create SPI device for %s\n",
 				nc->full_name);
-			spi_dev_put(spi);
-			continue;
-		}
-
-		/* Select device driver */
-		if (of_modalias_node(nc, spi->modalias,
-				     sizeof(spi->modalias)) < 0) {
-			dev_err(&master->dev, "cannot find modalias for %s\n",
-				nc->full_name);
-			spi_dev_put(spi);
-			continue;
-		}
-
-		/* Device address */
-		rc = of_property_read_u32(nc, "reg", &value);
-		if (rc) {
-			dev_err(&master->dev, "%s has no valid 'reg' property (%d)\n",
-				nc->full_name, rc);
-			spi_dev_put(spi);
-			continue;
-		}
-		spi->chip_select = value;
-
-		/* Mode (clock phase/polarity/etc.) */
-		if (of_find_property(nc, "spi-cpha", NULL))
-			spi->mode |= SPI_CPHA;
-		if (of_find_property(nc, "spi-cpol", NULL))
-			spi->mode |= SPI_CPOL;
-		if (of_find_property(nc, "spi-cs-high", NULL))
-			spi->mode |= SPI_CS_HIGH;
-		if (of_find_property(nc, "spi-3wire", NULL))
-			spi->mode |= SPI_3WIRE;
-		if (of_find_property(nc, "spi-lsb-first", NULL))
-			spi->mode |= SPI_LSB_FIRST;
-
-		/* Device DUAL/QUAD mode */
-		if (!of_property_read_u32(nc, "spi-tx-bus-width", &value)) {
-			switch (value) {
-			case 1:
-				break;
-			case 2:
-				spi->mode |= SPI_TX_DUAL;
-				break;
-			case 4:
-				spi->mode |= SPI_TX_QUAD;
-				break;
-			default:
-				dev_warn(&master->dev,
-					 "spi-tx-bus-width %d not supported\n",
-					 value);
-				break;
-			}
-		}
-
-		if (!of_property_read_u32(nc, "spi-rx-bus-width", &value)) {
-			switch (value) {
-			case 1:
-				break;
-			case 2:
-				spi->mode |= SPI_RX_DUAL;
-				break;
-			case 4:
-				spi->mode |= SPI_RX_QUAD;
-				break;
-			default:
-				dev_warn(&master->dev,
-					 "spi-rx-bus-width %d not supported\n",
-					 value);
-				break;
-			}
-		}
-
-		/* Device speed */
-		rc = of_property_read_u32(nc, "spi-max-frequency", &value);
-		if (rc) {
-			dev_err(&master->dev, "%s has no valid 'spi-max-frequency' property (%d)\n",
-				nc->full_name, rc);
-			spi_dev_put(spi);
-			continue;
-		}
-		spi->max_speed_hz = value;
-
-		/* IRQ */
-		spi->irq = irq_of_parse_and_map(nc, 0);
-
-		/* Store a pointer to the node in the device structure */
-		of_node_get(nc);
-		spi->dev.of_node = nc;
-
-		/* Register the new device */
-		request_module("%s%s", SPI_MODULE_PREFIX, spi->modalias);
-		rc = spi_add_device(spi);
-		if (rc) {
-			dev_err(&master->dev, "spi_device register error %s\n",
-				nc->full_name);
-			spi_dev_put(spi);
-		}
-
 	}
 }
 #else

commit c1aefbdd050e1fb15e92bcaf34d95b17ea952097
Author: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
Date:   Mon Nov 17 09:14:31 2014 +0000

    spi: Fix mapping from vmalloc-ed buffer to scatter list
    
    We can only use page_address on memory that has been mapped using kmap,
    when the buffer passed to the SPI has been allocated by vmalloc the page
    has not necessarily been mapped through kmap. This means sometimes
    page_address will return NULL causing the pointer we pass to sg_set_buf
    to be invalid.
    
    As we only call page_address so that we can pass a virtual address to
    sg_set_buf which will then immediately call virt_to_page on it, fix this
    by calling sg_set_page directly rather then relying on the sg_set_buf
    helper.
    
    Signed-off-by: Charles Keepax <ckeepax@opensource.wolfsonmicro.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index ebcb33df2eb2..50f20f243981 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -615,13 +615,13 @@ static int spi_map_buf(struct spi_master *master, struct device *dev,
 				sg_free_table(sgt);
 				return -ENOMEM;
 			}
-			sg_buf = page_address(vm_page) +
-				((size_t)buf & ~PAGE_MASK);
+			sg_set_page(&sgt->sgl[i], vm_page,
+				    min, offset_in_page(buf));
 		} else {
 			sg_buf = buf;
+			sg_set_buf(&sgt->sgl[i], sg_buf, min);
 		}
 
-		sg_set_buf(&sgt->sgl[i], sg_buf, min);
 
 		buf += min;
 		len -= min;

commit b528392669415dc1e53a047215e5ad6c2de879fc
Merge: 80213c03c415 9f1a05329695
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Oct 9 16:07:43 2014 -0400

    Merge tag 'pm+acpi-3.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
     "Features-wise, to me the most important this time is a rework of
      wakeup interrupts handling in the core that makes them work
      consistently across all of the available sleep states, including
      suspend-to-idle.  Many thanks to Thomas Gleixner for his help with
      this work.
    
      Second is an update of the generic PM domains code that has been in
      need of some care for quite a while.  Unused code is being removed, DT
      support is being added and domains are now going to be attached to
      devices in bus type code in analogy with the ACPI PM domain.  The
      majority of work here was done by Ulf Hansson who also has been the
      most active developer this time.
    
      Apart from this we have a traditional ACPICA update, this time to
      upstream version 20140828 and a few ACPI wakeup interrupts handling
      patches on top of the general rework mentioned above.  There also are
      several cpufreq commits including renaming the cpufreq-cpu0 driver to
      cpufreq-dt, as this is what implements generic DT-based cpufreq
      support, and a new DT-based idle states infrastructure for cpuidle.
    
      In addition to that, the ACPI LPSS driver is updated, ACPI support for
      Apple machines is improved, a few bugs are fixed and a few cleanups
      are made all over.
    
      Finally, the Adaptive Voltage Scaling (AVS) subsystem now has a tree
      maintained by Kevin Hilman that will be merged through the PM tree.
    
      Numbers-wise, the generic PM domains update takes the lead this time
      with 32 non-merge commits, second is cpufreq (15 commits) and the 3rd
      place goes to the wakeup interrupts handling rework (13 commits).
    
      Specifics:
    
       - Rework the handling of wakeup IRQs by the IRQ core such that all of
         them will be switched over to "wakeup" mode in suspend_device_irqs()
         and in that mode the first interrupt will abort system suspend in
         progress or wake up the system if already in suspend-to-idle (or
         equivalent) without executing any interrupt handlers.  Among other
         things that eliminates the wakeup-related motivation to use the
         IRQF_NO_SUSPEND interrupt flag with interrupts which don't really
         need it and should not use it (Thomas Gleixner and Rafael Wysocki)
    
       - Switch over ACPI to handling wakeup interrupts with the help of the
         new mechanism introduced by the above IRQ core rework (Rafael Wysocki)
    
       - Rework the core generic PM domains code to eliminate code that's
         not used, add DT support and add a generic mechanism by which
         devices can be added to PM domains automatically during enumeration
         (Ulf Hansson, Geert Uytterhoeven and Tomasz Figa).
    
       - Add debugfs-based mechanics for debugging generic PM domains
         (Maciej Matraszek).
    
       - ACPICA update to upstream version 20140828.  Included are updates
         related to the SRAT and GTDT tables and the _PSx methods are in the
         METHOD_NAME list now (Bob Moore and Hanjun Guo).
    
       - Add _OSI("Darwin") support to the ACPI core (unfortunately, that
         can't really be done in a straightforward way) to prevent
         Thunderbolt from being turned off on Apple systems after boot (or
         after resume from system suspend) and rework the ACPI Smart Battery
         Subsystem (SBS) driver to work correctly with Apple platforms
         (Matthew Garrett and Andreas Noever).
    
       - ACPI LPSS (Low-Power Subsystem) driver update cleaning up the code,
         adding support for 133MHz I2C source clock on Intel Baytrail to it
         and making it avoid using UART RTS override with Auto Flow Control
         (Heikki Krogerus).
    
       - ACPI backlight updates removing the video_set_use_native_backlight
         quirk which is not necessary any more, making the code check the
         list of output devices returned by the _DOD method to avoid
         creating acpi_video interfaces that won't work and adding a quirk
         for Lenovo Ideapad Z570 (Hans de Goede, Aaron Lu and Stepan Bujnak)
    
       - New Win8 ACPI OSI quirks for some Dell laptops (Edward Lin)
    
       - Assorted ACPI code cleanups (Fabian Frederick, Rasmus Villemoes,
         Sudip Mukherjee, Yijing Wang, and Zhang Rui)
    
       - cpufreq core updates and cleanups (Viresh Kumar, Preeti U Murthy,
         Rasmus Villemoes)
    
       - cpufreq driver updates: cpufreq-cpu0/cpufreq-dt (driver name change
         among other things), ppc-corenet, powernv (Viresh Kumar, Preeti U
         Murthy, Shilpasri G Bhat, Lucas Stach)
    
       - cpuidle support for DT-based idle states infrastructure, new ARM64
         cpuidle driver, cpuidle core cleanups (Lorenzo Pieralisi, Rasmus
         Villemoes)
    
       - ARM big.LITTLE cpuidle driver updates: support for DT-based
         initialization and Exynos5800 compatible string (Lorenzo Pieralisi,
         Kevin Hilman)
    
       - Rework of the test_suspend kernel command line argument and a new
         trace event for console resume (Srinivas Pandruvada, Todd E Brandt)
    
       - Second attempt to optimize swsusp_free() (hibernation core) to make
         it avoid going through all PFNs which may be way too slow on some
         systems (Joerg Roedel)
    
       - devfreq updates (Paul Bolle, Punit Agrawal, Ãrjan Eide).
    
       - rockchip-io Adaptive Voltage Scaling (AVS) driver and AVS entry
         update in MAINTAINERS (Heiko StÃ¼bner, Kevin Hilman)
    
       - PM core fix related to clock management (Geert Uytterhoeven)
    
       - PM core's sysfs code cleanup (Johannes Berg)"
    
    * tag 'pm+acpi-3.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (105 commits)
      ACPI / fan: printk replacement
      PM / clk: Fix crash in clocks management code if !CONFIG_PM_RUNTIME
      PM / Domains: Rename cpu_data to cpuidle_data
      cpufreq: cpufreq-dt: fix potential double put of cpu OF node
      cpufreq: cpu0: rename driver and internals to 'cpufreq_dt'
      PM / hibernate: Iterate over set bits instead of PFNs in swsusp_free()
      cpufreq: ppc-corenet: remove duplicate update of cpu_data
      ACPI / sleep: Rework the handling of ACPI GPE wakeup from suspend-to-idle
      PM / sleep: Rename platform suspend/resume functions in suspend.c
      PM / sleep: Export dpm_suspend_late/noirq() and dpm_resume_early/noirq()
      ACPICA: Introduce acpi_enable_all_wakeup_gpes()
      ACPICA: Clear all non-wakeup GPEs in acpi_hw_enable_wakeup_gpe_block()
      ACPI / video: check _DOD list when creating backlight devices
      PM / Domains: Move dev_pm_domain_attach|detach() to pm_domain.h
      cpufreq: Replace strnicmp with strncasecmp
      cpufreq: powernv: Set the cpus to nominal frequency during reboot/kexec
      cpufreq: powernv: Set the pstate of the last hotplugged out cpu in policy->cpus to minimum
      cpufreq: Allow stop CPU callback to be used by all cpufreq drivers
      PM / devfreq: exynos: Enable building exynos PPMU as module
      PM / devfreq: Export helper functions for drivers
      ...

commit ad71f40a834e6fe8877794230048551cc7ab8180
Merge: 62d02e41eaf0 c7908a37aeee
Author: Mark Brown <broonie@kernel.org>
Date:   Fri Oct 3 16:33:37 2014 +0100

    Merge remote-tracking branch 'spi/topic/core' into spi-next

commit f48c767ce8951e30eb716b8ef69142d21aacbd1d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Sep 29 13:58:47 2014 +0200

    PM / Domains: Move dev_pm_domain_attach|detach() to pm_domain.h
    
    The commit 46420dd73b80 (PM / Domains: Add APIs to attach/detach a PM
    domain for a device) started using errno values in pm.h header file.
    It also failed to include the header for these, thus it caused
    compiler errors.
    
    Instead of including the errno header to pm.h, let's move the functions
    to pm_domain.h, since it's a better match.
    
    Fixes: 46420dd73b80 (PM / Domains: Add APIs to attach/detach a PM domain for a device)
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 72a0beb1fafa..3907f1493e7d 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -35,6 +35,7 @@
 #include <linux/spi/spi.h>
 #include <linux/of_gpio.h>
 #include <linux/pm_runtime.h>
+#include <linux/pm_domain.h>
 #include <linux/export.h>
 #include <linux/sched/rt.h>
 #include <linux/delay.h>

commit c7908a37aeee2a038d7b1492eae29750d8738d2e
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Wed Sep 24 14:30:29 2014 +0800

    spi: Fix possible ZERO_SIZE_PTR pointer dereferencing error.
    
    Since we cannot make sure the 'n' will always be none zero here, and
    then if either equal to zero, the kzalloc() will return ZERO_SIZE_PTR,
    which equals to ((void *)16).
    
    So this patch fix this with just doing the zero check before calling
    kzalloc().
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 0edccc82ece5..cc83cdd969ce 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -552,6 +552,9 @@ int spi_register_board_info(struct spi_board_info const *info, unsigned n)
 	struct boardinfo *bi;
 	int i;
 
+	if (!n)
+		return -EINVAL;
+
 	bi = kzalloc(n * sizeof(*bi), GFP_KERNEL);
 	if (!bi)
 		return -ENOMEM;

commit 676e7c257a339b44b8a613be145b22b85cf2ffc4
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Sep 19 20:27:41 2014 +0200

    spi: core: Convert to dev_pm_domain_attach|detach()
    
    Previously only the ACPI PM domain was supported by the spi bus.
    
    Let's convert to the common attach/detach functions for PM domains,
    which currently means we are extending the support to include the
    generic PM domain as well.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Reviewed-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index ca935df80c88..72a0beb1fafa 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -264,10 +264,12 @@ static int spi_drv_probe(struct device *dev)
 	if (ret)
 		return ret;
 
-	acpi_dev_pm_attach(dev, true);
-	ret = sdrv->probe(to_spi_device(dev));
-	if (ret)
-		acpi_dev_pm_detach(dev, true);
+	ret = dev_pm_domain_attach(dev, true);
+	if (ret != -EPROBE_DEFER) {
+		ret = sdrv->probe(to_spi_device(dev));
+		if (ret)
+			dev_pm_domain_detach(dev, true);
+	}
 
 	return ret;
 }
@@ -278,7 +280,7 @@ static int spi_drv_remove(struct device *dev)
 	int ret;
 
 	ret = sdrv->remove(to_spi_device(dev));
-	acpi_dev_pm_detach(dev, true);
+	dev_pm_domain_detach(dev, true);
 
 	return ret;
 }

commit 360b2eaeb563896ab95db45eb7d1b83c9a04c292
Merge: e0a7ab4b50b0 61a2381c7b28 3f2dad99f6fc 2c67568903d6 08a707b87874 3d0763c006f8 aca26364689e 5d1d150d7d77 3819bc875236
Author: Mark Brown <broonie@kernel.org>
Date:   Sat Aug 30 19:28:04 2014 +0100

    Merge remote-tracking branches 'spi/fix/au1550', 'spi/fix/davinci', 'spi/fix/doc', 'spi/fix/dw', 'spi/fix/omap-mcspi', 'spi/fix/pxa2xx', 'spi/fix/rockchip' and 'spi/fix/rspi' into spi-linus

commit 38ec10f60d9ca3a7eb3a5b52500a67479296b86f
Author: Mark Brown <broonie@linaro.org>
Date:   Sat Aug 16 16:27:41 2014 +0100

    spi: Only call transfer_one() if we have buffers to transfer
    
    Client drivers such as the ChomeOS EC driver sometimes use transfers with
    no buffers and only a delay specified in order to allow a delay after the
    assertion of /CS. Rather than require controller drivers handle this noop
    case gracefully put checks in the core to ensure that we don't call into
    the controller for such transfers.
    
    Reported-by: Addy Ke <addy.ke@rock-chips.com>
    Tested-by: Doug Anderson <dianders@chromium.org>
    Reviewed-by: Doug Anderson <dianders@chromium.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index e0531baf2782..0edccc82ece5 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -789,27 +789,35 @@ static int spi_transfer_one_message(struct spi_master *master,
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		trace_spi_transfer_start(msg, xfer);
 
-		reinit_completion(&master->xfer_completion);
-
-		ret = master->transfer_one(master, msg->spi, xfer);
-		if (ret < 0) {
-			dev_err(&msg->spi->dev,
-				"SPI transfer failed: %d\n", ret);
-			goto out;
-		}
+		if (xfer->tx_buf || xfer->rx_buf) {
+			reinit_completion(&master->xfer_completion);
+
+			ret = master->transfer_one(master, msg->spi, xfer);
+			if (ret < 0) {
+				dev_err(&msg->spi->dev,
+					"SPI transfer failed: %d\n", ret);
+				goto out;
+			}
 
-		if (ret > 0) {
-			ret = 0;
-			ms = xfer->len * 8 * 1000 / xfer->speed_hz;
-			ms += ms + 100; /* some tolerance */
+			if (ret > 0) {
+				ret = 0;
+				ms = xfer->len * 8 * 1000 / xfer->speed_hz;
+				ms += ms + 100; /* some tolerance */
 
-			ms = wait_for_completion_timeout(&master->xfer_completion,
-							 msecs_to_jiffies(ms));
-		}
+				ms = wait_for_completion_timeout(&master->xfer_completion,
+								 msecs_to_jiffies(ms));
+			}
 
-		if (ms == 0) {
-			dev_err(&msg->spi->dev, "SPI transfer timed out\n");
-			msg->status = -ETIMEDOUT;
+			if (ms == 0) {
+				dev_err(&msg->spi->dev,
+					"SPI transfer timed out\n");
+				msg->status = -ETIMEDOUT;
+			}
+		} else {
+			if (xfer->len)
+				dev_err(&msg->spi->dev,
+					"Bufferless transfer has length %u\n",
+					xfer->len);
 		}
 
 		trace_spi_transfer_stop(msg, xfer);

commit 2c67568903d6ae1b8cfa343c649029180239418e
Author: Thierry Reding <treding@nvidia.com>
Date:   Fri Aug 8 13:02:36 2014 +0200

    spi: Add missing kerneldoc bits
    
    These are all arguments or fields that got added without updating the
    kerneldoc comments.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index e6f076d5ffd5..f52f3e647ef8 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -843,6 +843,7 @@ static int spi_transfer_one_message(struct spi_master *master,
 
 /**
  * spi_finalize_current_transfer - report completion of a transfer
+ * @master: the master reporting completion
  *
  * Called by SPI drivers using the core transfer_one_message()
  * implementation to notify it that the current interrupt driven

commit 1325b6550a7b9cda52ee4c0da04fa9f93d2618fc
Merge: dc7aafba6bfa fab6a0410d20
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 5 16:18:13 2014 -0700

    Merge tag 'spi-v3.17' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi
    
    Pull spi updates from Mark Brown:
     "A quiet release, more bug fixes than anything else.  A few things do
      stand out though:
    
       - updates to several drivers to move towards the standard GPIO chip
         select handling in the core.
       - DMA support for the SH MSIOF driver.
       - support for Rockchip SPI controllers (their first mainline
         submission)"
    
    * tag 'spi-v3.17' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi: (64 commits)
      spi: davinci: use spi_device.cs_gpio to store gpio cs per spi device
      spi: davinci: add support to configure gpio cs through dt
      spi/pl022: Explicitly truncate large bitmask
      spi/atmel: Fix pointer to int conversion warnings on 64 bit builds
      spi: davinci: fix to support more than 2 chip selects
      spi: topcliff-pch: don't hardcode PCI slot to get DMA device
      spi: orion: fix incorrect handling of cell-index DT property
      spi: orion: Fix error return code in orion_spi_probe()
      spi/rockchip: fix error return code in rockchip_spi_probe()
      spi/rockchip: remove redundant dev_err call in rockchip_spi_probe()
      spi/rockchip: remove duplicated include from spi-rockchip.c
      ARM: dts: fix the chip select gpios definition in the SPI nodes
      spi: s3c64xx: Update binding documentation
      spi: s3c64xx: use the generic SPI "cs-gpios" property
      spi: s3c64xx: Revert "spi: s3c64xx: Added provision for dedicated cs pin"
      spi: atmel: Use dmaengine_prep_slave_sg() API
      spi: topcliff-pch: Update error messages for dmaengine_prep_slave_sg() API
      spi: sh-msiof: Use correct device for DMA mapping with IOMMU
      spi: sh-msiof: Handle dmaengine_prep_slave_single() failures gracefully
      spi: rspi: Handle dmaengine_prep_slave_sg() failures gracefully
      ...

commit fa2b5647cf733d99df176ae4dd3c1d31d5e50701
Merge: 8331c49c48af 840e9c354f34
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Aug 4 17:21:03 2014 +0100

    Merge remote-tracking branch 'spi/topic/core' into spi-next

commit 86be408bfbd846fab3c4ac21d6f9298bd2e4b790
Author: Sylwester Nawrocki <s.nawrocki@samsung.com>
Date:   Wed Jun 18 17:29:32 2014 +0200

    clk: Support for clock parents and rates assigned from device tree
    
    This patch adds helper functions to configure clock parents and rates
    as specified through 'assigned-clock-parents', 'assigned-clock-rates'
    DT properties for a clock provider or clock consumer device.
    The helpers are now being called by the bus code for the platform, I2C
    and SPI busses, before the driver probing and also in the clock core
    after registration of a clock provider.
    
    Signed-off-by: Sylwester Nawrocki <s.nawrocki@samsung.com>
    Acked-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Mike Turquette <mturquette@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index d4f9670b51bc..22aa41cace82 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -29,6 +29,7 @@
 #include <linux/mutex.h>
 #include <linux/of_device.h>
 #include <linux/of_irq.h>
+#include <linux/clk/clk-conf.h>
 #include <linux/slab.h>
 #include <linux/mod_devicetable.h>
 #include <linux/spi/spi.h>
@@ -259,6 +260,10 @@ static int spi_drv_probe(struct device *dev)
 	const struct spi_driver		*sdrv = to_spi_driver(dev->driver);
 	int ret;
 
+	ret = of_clk_set_defaults(dev->of_node, false);
+	if (ret)
+		return ret;
+
 	acpi_dev_pm_attach(dev, true);
 	ret = sdrv->probe(to_spi_device(dev));
 	if (ret)

commit 3fc25421f55e36426f5e5cc227cacc840493a943
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Jul 10 15:29:33 2014 +0200

    spi: core: Pass correct device to dma_map_sg()
    
    According to Documentation/dmaengine.txt, scatterlists must be mapped
    using the DMA struct device.
    
    However, "dma_chan.dev->device" is the sysfs class device's device.
    Use "dma_chan.device->dev" instead, which is the real DMA device's device.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 91bb512e1009..e691e281e3a2 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -649,8 +649,8 @@ static int __spi_map_msg(struct spi_master *master, struct spi_message *msg)
 	if (!master->can_dma)
 		return 0;
 
-	tx_dev = &master->dma_tx->dev->device;
-	rx_dev = &master->dma_rx->dev->device;
+	tx_dev = master->dma_tx->device->dev;
+	rx_dev = master->dma_rx->device->dev;
 
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		if (!master->can_dma(master, msg->spi, xfer))
@@ -689,8 +689,8 @@ static int spi_unmap_msg(struct spi_master *master, struct spi_message *msg)
 	if (!master->cur_msg_mapped || !master->can_dma)
 		return 0;
 
-	tx_dev = &master->dma_tx->dev->device;
-	rx_dev = &master->dma_rx->dev->device;
+	tx_dev = master->dma_tx->device->dev;
+	rx_dev = master->dma_rx->device->dev;
 
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		if (!master->can_dma(master, msg->spi, xfer))

commit 89e4b66a2e34744615c79349aa936df1b4204faf
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Jul 10 15:29:32 2014 +0200

    spi: core: Fix check for dma_map_sg() failures
    
    According to Documentation/DMA-API.txt, dma_map_sg() returns 0 on failure.
    As spi_map_buf() returns an error code, convert zero into -ENOMEM.
    Keep the existing check for negative numbers just in case.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index d4f9670b51bc..91bb512e1009 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -619,6 +619,8 @@ static int spi_map_buf(struct spi_master *master, struct device *dev,
 	}
 
 	ret = dma_map_sg(dev, sgt->sgl, sgt->nents, dir);
+	if (!ret)
+		ret = -ENOMEM;
 	if (ret < 0) {
 		sg_free_table(sgt);
 		return ret;

commit 840e9c354f3492259a65ae235351cde1089a409e
Author: Mark Brown <broonie@linaro.org>
Date:   Sat Jun 21 11:40:40 2014 +0100

    spi: Remove unused variable
    
    Reported-by: kbuild test robot
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 8bbbba5b6236..cbfb250af5aa 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -345,7 +345,6 @@ static DEFINE_MUTEX(board_lock);
 struct spi_device *spi_alloc_device(struct spi_master *master)
 {
 	struct spi_device	*spi;
-	struct device		*dev = master->dev.parent;
 
 	if (!spi_master_get(master))
 		return NULL;

commit 8331acb3a5515c01a1b73424a56f44c50ad7f1b4
Author: Sachin Kamat <sachin.kamat@samsung.com>
Date:   Fri Jun 13 10:17:42 2014 +0530

    spi: Remove redundant OOM message in spi.c
    
    Let memory subsystem handle the error logging.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@samsung.com>
    Reviewed-by: Naveen Krishna Chatradhi <ch.naveen@samsung.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index d4f9670b51bc..8bbbba5b6236 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -352,7 +352,6 @@ struct spi_device *spi_alloc_device(struct spi_master *master)
 
 	spi = kzalloc(sizeof(*spi), GFP_KERNEL);
 	if (!spi) {
-		dev_err(dev, "cannot alloc spi_device\n");
 		spi_master_put(master);
 		return NULL;
 	}

commit f54645d1aac092d5b3065b1d1fe181dff4deb71d
Merge: 15751f2e717c cd6339e6ced3
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Jun 2 17:08:35 2014 +0100

    Merge remote-tracking branch 'spi/topic/dt' into spi-next

commit 15751f2e717c4cbdf17b0c21f2b1b23a939dafc9
Merge: 03689d2d75d3 80874d8c9e9c
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Jun 2 17:08:34 2014 +0100

    Merge remote-tracking branch 'spi/topic/core' into spi-next

commit 80874d8c9e9cbfa195572dfea46f2314098b3869
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon May 26 14:05:25 2014 +0200

    spi: core: Ignore unsupported spi-[tr]x-bus-width property values
    
    Rejecting unsupported values of spi-tx-bus-width and spi-rx-bus-width
    may break compatibility with future DTs. Just ignore them, falling back
    to Single SPI Transfers.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index f01cbb41e6ca..147e0707f43f 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1247,11 +1247,10 @@ static void of_register_spi_devices(struct spi_master *master)
 				spi->mode |= SPI_TX_QUAD;
 				break;
 			default:
-				dev_err(&master->dev,
-					"spi-tx-bus-width %d not supported\n",
-					value);
-				spi_dev_put(spi);
-				continue;
+				dev_warn(&master->dev,
+					 "spi-tx-bus-width %d not supported\n",
+					 value);
+				break;
 			}
 		}
 
@@ -1266,11 +1265,10 @@ static void of_register_spi_devices(struct spi_master *master)
 				spi->mode |= SPI_RX_QUAD;
 				break;
 			default:
-				dev_err(&master->dev,
-					"spi-rx-bus-width %d not supported\n",
-					value);
-				spi_dev_put(spi);
-				continue;
+				dev_warn(&master->dev,
+					 "spi-rx-bus-width %d not supported\n",
+					 value);
+				break;
 			}
 		}
 

commit c3676d5ceff213cba35af5ee5f320d2e8dc48cdf
Author: Mark Brown <broonie@linaro.org>
Date:   Thu May 1 10:47:52 2014 -0700

    spi: core: Don't destroy master queue if we fail to create it
    
    If we fail to create the master queue for some reason we should not attempt
    to clean it up since attempting to stop a kthread that was not created will
    hang and it's just generally bad practice. Unfortunately at present we call
    spi_destroy_queue() even in cases where the creation fails.
    
    Fix this by fixing the error handling in spi_master_initialize_queue() so
    that we only flag the master as queued or destroy the queue if creation
    succeeded. The change to the flag is done since the general master
    cleanup uses this to destroy the queue.
    
    Reported-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 6046dcd7487e..939edf473235 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1172,7 +1172,6 @@ static int spi_master_initialize_queue(struct spi_master *master)
 {
 	int ret;
 
-	master->queued = true;
 	master->transfer = spi_queued_transfer;
 	if (!master->transfer_one_message)
 		master->transfer_one_message = spi_transfer_one_message;
@@ -1183,6 +1182,7 @@ static int spi_master_initialize_queue(struct spi_master *master)
 		dev_err(&master->dev, "problem initializing queue\n");
 		goto err_init_queue;
 	}
+	master->queued = true;
 	ret = spi_start_queue(master);
 	if (ret) {
 		dev_err(&master->dev, "problem starting queue\n");
@@ -1192,8 +1192,8 @@ static int spi_master_initialize_queue(struct spi_master *master)
 	return 0;
 
 err_start_queue:
-err_init_queue:
 	spi_destroy_queue(master);
+err_init_queue:
 	return ret;
 }
 

commit 2de440f59ca9615c92820d165d5e59756e54026b
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri May 2 06:29:34 2014 +0200

    spi: core: Protect DMA code by #ifdef CONFIG_HAS_DMA
    
    If NO_DMA=y:
    
    drivers/built-in.o: In function `spi_map_buf':
    spi.c:(.text+0x21bc60): undefined reference to `dma_map_sg'
    drivers/built-in.o: In function `spi_unmap_buf.isra.33':
    spi.c:(.text+0x21c32e): undefined reference to `dma_unmap_sg'
    make[3]: *** [vmlinux] Error 1
    
    Protect the DMA code by #ifdef CONFIG_HAS_DMA to fix this:
      - Extract __spi_map_msg() from spi_map_msg(),
      - Provide dummy definitions of __spi_map_msg() and spi_unmap_msg() if
        !CONFIG_HAS_DMA.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 1534fa1dac34..6046dcd7487e 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -580,6 +580,7 @@ static void spi_set_cs(struct spi_device *spi, bool enable)
 		spi->master->set_cs(spi, !enable);
 }
 
+#ifdef CONFIG_HAS_DMA
 static int spi_map_buf(struct spi_master *master, struct device *dev,
 		       struct sg_table *sgt, void *buf, size_t len,
 		       enum dma_data_direction dir)
@@ -637,55 +638,12 @@ static void spi_unmap_buf(struct spi_master *master, struct device *dev,
 	}
 }
 
-static int spi_map_msg(struct spi_master *master, struct spi_message *msg)
+static int __spi_map_msg(struct spi_master *master, struct spi_message *msg)
 {
 	struct device *tx_dev, *rx_dev;
 	struct spi_transfer *xfer;
-	void *tmp;
-	unsigned int max_tx, max_rx;
 	int ret;
 
-	if (master->flags & (SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX)) {
-		max_tx = 0;
-		max_rx = 0;
-
-		list_for_each_entry(xfer, &msg->transfers, transfer_list) {
-			if ((master->flags & SPI_MASTER_MUST_TX) &&
-			    !xfer->tx_buf)
-				max_tx = max(xfer->len, max_tx);
-			if ((master->flags & SPI_MASTER_MUST_RX) &&
-			    !xfer->rx_buf)
-				max_rx = max(xfer->len, max_rx);
-		}
-
-		if (max_tx) {
-			tmp = krealloc(master->dummy_tx, max_tx,
-				       GFP_KERNEL | GFP_DMA);
-			if (!tmp)
-				return -ENOMEM;
-			master->dummy_tx = tmp;
-			memset(tmp, 0, max_tx);
-		}
-
-		if (max_rx) {
-			tmp = krealloc(master->dummy_rx, max_rx,
-				       GFP_KERNEL | GFP_DMA);
-			if (!tmp)
-				return -ENOMEM;
-			master->dummy_rx = tmp;
-		}
-
-		if (max_tx || max_rx) {
-			list_for_each_entry(xfer, &msg->transfers,
-					    transfer_list) {
-				if (!xfer->tx_buf)
-					xfer->tx_buf = master->dummy_tx;
-				if (!xfer->rx_buf)
-					xfer->rx_buf = master->dummy_rx;
-			}
-		}
-	}
-
 	if (!master->can_dma)
 		return 0;
 
@@ -742,6 +700,69 @@ static int spi_unmap_msg(struct spi_master *master, struct spi_message *msg)
 
 	return 0;
 }
+#else /* !CONFIG_HAS_DMA */
+static inline int __spi_map_msg(struct spi_master *master,
+				struct spi_message *msg)
+{
+	return 0;
+}
+
+static inline int spi_unmap_msg(struct spi_master *master,
+				struct spi_message *msg)
+{
+	return 0;
+}
+#endif /* !CONFIG_HAS_DMA */
+
+static int spi_map_msg(struct spi_master *master, struct spi_message *msg)
+{
+	struct spi_transfer *xfer;
+	void *tmp;
+	unsigned int max_tx, max_rx;
+
+	if (master->flags & (SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX)) {
+		max_tx = 0;
+		max_rx = 0;
+
+		list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+			if ((master->flags & SPI_MASTER_MUST_TX) &&
+			    !xfer->tx_buf)
+				max_tx = max(xfer->len, max_tx);
+			if ((master->flags & SPI_MASTER_MUST_RX) &&
+			    !xfer->rx_buf)
+				max_rx = max(xfer->len, max_rx);
+		}
+
+		if (max_tx) {
+			tmp = krealloc(master->dummy_tx, max_tx,
+				       GFP_KERNEL | GFP_DMA);
+			if (!tmp)
+				return -ENOMEM;
+			master->dummy_tx = tmp;
+			memset(tmp, 0, max_tx);
+		}
+
+		if (max_rx) {
+			tmp = krealloc(master->dummy_rx, max_rx,
+				       GFP_KERNEL | GFP_DMA);
+			if (!tmp)
+				return -ENOMEM;
+			master->dummy_rx = tmp;
+		}
+
+		if (max_tx || max_rx) {
+			list_for_each_entry(xfer, &msg->transfers,
+					    transfer_list) {
+				if (!xfer->tx_buf)
+					xfer->tx_buf = master->dummy_tx;
+				if (!xfer->rx_buf)
+					xfer->rx_buf = master->dummy_rx;
+			}
+		}
+	}
+
+	return __spi_map_msg(master, msg);
+}
 
 /*
  * spi_transfer_one_message - Default implementation of transfer_one_message()

commit 83596fbeb5d28e8cb8878786133945d4dc7c0090
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Apr 14 19:39:53 2014 +0200

    spi: core: Ignore unsupported Dual/Quad Transfer Mode bits
    
    The availability of SPI Dual or Quad Transfer Mode as indicated by the
    "spi-tx-bus-width" and "spi-rx-bus-width" properties in the device tree is
    a hardware property of the SPI master, SPI slave, and board wiring.  Hence
    the SPI core should not reject an SPI slave because an SPI master driver
    doesn't (yet) support Dual or Quad Transfer Mode.
    
    Change the lack of Dual or Quad Transfer Mode support in the SPI master
    driver from an error condition to a warning condition, and ignore the
    unsupported mode bits, falling back to Single Transfer Mode, to avoid
    breakages when running old kernels with new device trees.
    
    Fixes: f477b7fb13df (spi: DUAL and QUAD support)
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 4eb9bf02996c..1534fa1dac34 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1756,7 +1756,7 @@ EXPORT_SYMBOL_GPL(spi_busnum_to_master);
  */
 int spi_setup(struct spi_device *spi)
 {
-	unsigned	bad_bits;
+	unsigned	bad_bits, ugly_bits;
 	int		status = 0;
 
 	/* check mode to prevent that DUAL and QUAD set at the same time
@@ -1776,6 +1776,15 @@ int spi_setup(struct spi_device *spi)
 	 * that aren't supported with their current master
 	 */
 	bad_bits = spi->mode & ~spi->master->mode_bits;
+	ugly_bits = bad_bits &
+		    (SPI_TX_DUAL | SPI_TX_QUAD | SPI_RX_DUAL | SPI_RX_QUAD);
+	if (ugly_bits) {
+		dev_warn(&spi->dev,
+			 "setup: ignoring unsupported mode bits %x\n",
+			 ugly_bits);
+		spi->mode &= ~ugly_bits;
+		bad_bits &= ~ugly_bits;
+	}
 	if (bad_bits) {
 		dev_err(&spi->dev, "setup: unsupported mode bits %x\n",
 			bad_bits);

commit cd6339e6ced387ad67b5551dd2931cfd7e8b970b
Author: Zhao Qiang <B45475@freescale.com>
Date:   Tue Apr 1 17:10:50 2014 +0800

    spi: add "spi-lsb-first" to devicetree
    
    add optional property devicetree for SPI slave nodes
    into devicetree so that LSB mode can be enabled by devicetree.
    
    Signed-off-by: Zhao Qiang <B45475@freescale.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 4eb9bf02996c..214045c04705 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1234,6 +1234,8 @@ static void of_register_spi_devices(struct spi_master *master)
 			spi->mode |= SPI_CS_HIGH;
 		if (of_find_property(nc, "spi-3wire", NULL))
 			spi->mode |= SPI_3WIRE;
+		if (of_find_property(nc, "spi-lsb-first", NULL))
+			spi->mode |= SPI_LSB_FIRST;
 
 		/* Device DUAL/QUAD mode */
 		if (!of_property_read_u32(nc, "spi-tx-bus-width", &value)) {

commit eee668a92bc775030178c8a7f0d0abe9cce441d7
Author: Harini Katakam <harinik@xilinx.com>
Date:   Fri Apr 11 12:06:28 2014 +0530

    spi: core: Increase timeout value
    
    The existing timeout value in wait_for_completion_timeout is
    calculated from the transfer length and speed with tolerance of 10msec.
    This is too low because this is used for error conditions such as
    hardware hang etc.
    The xfer->speed_hz considered may not be the actual speed set
    because the best clock divisor is chosen from a limited set such that
    the actual speed <= requested speed. This will lead to timeout being
    less than actual transfer time.
    Considering acceptable latencies, this timeout can be set to a
    value double the expected transfer plus 100 msecs.
    This patch adds the same in the core.
    
    Signed-off-by: Harini Katakam <harinik@xilinx.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 4eb9bf02996c..f01cbb41e6ca 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -775,7 +775,7 @@ static int spi_transfer_one_message(struct spi_master *master,
 		if (ret > 0) {
 			ret = 0;
 			ms = xfer->len * 8 * 1000 / xfer->speed_hz;
-			ms += 10; /* some tolerance */
+			ms += ms + 100; /* some tolerance */
 
 			ms = wait_for_completion_timeout(&master->xfer_completion,
 							 msecs_to_jiffies(ms));

commit b1ad487c42e982bb30f10bfb267f71c5daa3a0d5
Merge: 81235b4ea3aa 743a46b89a59 971e9084beb5 9304f51e5f3e 7661ba5a8452 342451df0710 f8c717a56715 af348519e4a4 16a0ce4e10ed
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Mar 30 00:51:41 2014 +0000

    Merge remote-tracking branches 'spi/topic/sunxi', 'spi/topic/tegra114', 'spi/topic/ti-qspi', 'spi/topic/ti-ssp', 'spi/topic/topcliff-pch', 'spi/topic/txx9', 'spi/topic/xcomm' and 'spi/topic/xfer' into spi-next

commit 9dee279b400629100dce152e40e058ae46046922
Merge: 0f38af451fc4 78e39523b8c9 354312f16e49 6f50c6bc61d4 8023d384ff5c aa0fe82629f1 b53b34f042fe
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Mar 30 00:51:03 2014 +0000

    Merge remote-tracking branches 'spi/topic/bus-num', 'spi/topic/cleanup', 'spi/topic/clps711x', 'spi/topic/coldfire', 'spi/topic/completion' and 'spi/topic/davinci' into spi-next

commit a78389844ea95f18aadda79246587c707586ce89
Merge: 5d0eb26ce836 513273538a6c
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Mar 30 00:50:56 2014 +0000

    Merge remote-tracking branch 'spi/topic/dma' into spi-next

commit 5d0eb26ce83647f0f6ed2e681a77821c92acd014
Merge: ff13a9a6a74a 1e25cd4729bd
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Mar 30 00:50:55 2014 +0000

    Merge remote-tracking branch 'spi/topic/core' into spi-next

commit ff13a9a6a74a73f800a3478518636945713da9f6
Merge: b098d6726bbf 0b73aa63c193
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Mar 30 00:50:53 2014 +0000

    Merge remote-tracking branch 'spi/fix/core' into spi-linus

commit 0b73aa63c193006c3d503d4903dd4792a26e1d50
Author: Mark Brown <broonie@linaro.org>
Date:   Sat Mar 29 23:48:07 2014 +0000

    spi: Fix handling of cs_change in core implementation
    
    The core implementation of cs_change didn't follow the documentation
    which says that cs_change in the middle of the transfer means to briefly
    deassert chip select, instead it followed buggy drivers which change the
    polarity of chip select.  Use a delay of 10us between deassert and
    reassert simply from pulling numbers out of a hat.
    
    Reported-by: Gerhard Sittig <gsi@denx.de>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 23756b0f9036..5d826f047714 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -591,7 +591,6 @@ static int spi_transfer_one_message(struct spi_master *master,
 				    struct spi_message *msg)
 {
 	struct spi_transfer *xfer;
-	bool cur_cs = true;
 	bool keep_cs = false;
 	int ret = 0;
 
@@ -627,8 +626,9 @@ static int spi_transfer_one_message(struct spi_master *master,
 					 &msg->transfers)) {
 				keep_cs = true;
 			} else {
-				cur_cs = !cur_cs;
-				spi_set_cs(msg->spi, cur_cs);
+				spi_set_cs(msg->spi, false);
+				udelay(10);
+				spi_set_cs(msg->spi, true);
 			}
 		}
 

commit 1e25cd4729bd76662d02b142a6a7f8504bb6aea7
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Mar 25 19:28:22 2014 +0000

    spi: Do not require a completion
    
    There is no real reason why we require transfers to have a completion and
    the only user of the completion now checks to see if one has been provided
    before using it so stop enforcing this. This makes it more convenient for
    drivers to chain multiple asynchronous transfers together.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 38e1c315bb13..d94782340b47 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1621,8 +1621,6 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 
 	if (list_empty(&message->transfers))
 		return -EINVAL;
-	if (!message->complete)
-		return -EINVAL;
 
 	/* Half-duplex links include original MicroWire, and ones with
 	 * only one data pin like SPI_3WIRE (switches direction) or where

commit a6f87fad7b5132f026592729ccf65b995cdec35d
Author: Axel Lin <axel.lin@ingics.com>
Date:   Mon Mar 17 10:08:12 2014 +0800

    spi: core: Use master->max_speed_hz as transfer speed when xfer->speed_hz > master->max_speed_hz
    
    When xfer->speed_hz is greater than master->max_speed_hz, it's generally safe
    to use master->max_speed_hz as transfer speed.
    Thus use master->max_speed_hz as transfer speed rather than return error when
    xfer->speed_hz > master->max_speed_hz.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 9d1405440223..38e1c315bb13 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1653,12 +1653,13 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 		message->frame_length += xfer->len;
 		if (!xfer->bits_per_word)
 			xfer->bits_per_word = spi->bits_per_word;
-		if (!xfer->speed_hz) {
+
+		if (!xfer->speed_hz)
 			xfer->speed_hz = spi->max_speed_hz;
-			if (master->max_speed_hz &&
-			    xfer->speed_hz > master->max_speed_hz)
-				xfer->speed_hz = master->max_speed_hz;
-		}
+
+		if (master->max_speed_hz &&
+		    xfer->speed_hz > master->max_speed_hz)
+			xfer->speed_hz = master->max_speed_hz;
 
 		if (master->bits_per_word_mask) {
 			/* Only 32 bits fit in the mask */
@@ -1687,9 +1688,6 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 		if (xfer->speed_hz && master->min_speed_hz &&
 		    xfer->speed_hz < master->min_speed_hz)
 			return -EINVAL;
-		if (xfer->speed_hz && master->max_speed_hz &&
-		    xfer->speed_hz > master->max_speed_hz)
-			return -EINVAL;
 
 		if (xfer->tx_buf && !xfer->tx_nbits)
 			xfer->tx_nbits = SPI_NBITS_SINGLE;

commit 6ea312936d68b557766dafa9a3c4617e14ffa076
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Feb 28 23:03:16 2014 +0900

    spi: core: make zero length transfer valid again
    
    Zero length transfer becomes invalid since
    "spi: core: Validate length of the transfers in message" commit,
    but it should be valid to support an odd device, for example, which
    requires long delay between chipselect and the first transfer, etc.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Tested-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index d5ee965fb285..9d1405440223 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1617,7 +1617,7 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 {
 	struct spi_master *master = spi->master;
 	struct spi_transfer *xfer;
-	int w_size, n_words;
+	int w_size;
 
 	if (list_empty(&message->transfers))
 		return -EINVAL;
@@ -1680,9 +1680,8 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 		else
 			w_size = 4;
 
-		n_words = xfer->len / w_size;
 		/* No partial transfers accepted */
-		if (!n_words || xfer->len % w_size)
+		if (xfer->len % w_size)
 			return -EINVAL;
 
 		if (xfer->speed_hz && master->min_speed_hz &&

commit f97b26b05b1dcd307b2f79d1f9e9d99551987dbb
Author: Axel Lin <axel.lin@ingics.com>
Date:   Fri Feb 21 09:15:18 2014 +0800

    spi: core: Replace msleep with usleep_range to get more accurate sleep time
    
    Fixes below checkpatch warning:
    WARNING: msleep < 20ms can sleep for up to 20ms; see Documentation/timers/timers-howto.txt
    +               msleep(10);
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 1b53eee2cbca..d5ee965fb285 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -892,7 +892,7 @@ static int spi_stop_queue(struct spi_master *master)
 	 */
 	while ((!list_empty(&master->queue) || master->busy) && limit--) {
 		spin_unlock_irqrestore(&master->queue_lock, flags);
-		msleep(10);
+		usleep_range(10000, 11000);
 		spin_lock_irqsave(&master->queue_lock, flags);
 	}
 

commit 4d94bd21b333c695eba97746b615e2efb30240cc
Author: Ivan T. Ivanov <iivanov@mm-sol.com>
Date:   Thu Feb 20 12:02:08 2014 +0200

    spi: core: Validate length of the transfers in message
    
    SPI transfer length should be multiple of SPI word size,
    where SPI word size should be power-of-two multiple
    
    Signed-off-by: Ivan T. Ivanov <iivanov@mm-sol.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index bb660145d19e..1b53eee2cbca 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1617,6 +1617,7 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 {
 	struct spi_master *master = spi->master;
 	struct spi_transfer *xfer;
+	int w_size, n_words;
 
 	if (list_empty(&message->transfers))
 		return -EINVAL;
@@ -1668,6 +1669,22 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 				return -EINVAL;
 		}
 
+		/*
+		 * SPI transfer length should be multiple of SPI word size
+		 * where SPI word size should be power-of-two multiple
+		 */
+		if (xfer->bits_per_word <= 8)
+			w_size = 1;
+		else if (xfer->bits_per_word <= 16)
+			w_size = 2;
+		else
+			w_size = 4;
+
+		n_words = xfer->len / w_size;
+		/* No partial transfers accepted */
+		if (!n_words || xfer->len % w_size)
+			return -EINVAL;
+
 		if (xfer->speed_hz && master->min_speed_hz &&
 		    xfer->speed_hz < master->min_speed_hz)
 			return -EINVAL;

commit aec35f4ee6eefba616065547e6882c084cc7f5cb
Author: Jean Delvare <jdelvare@suse.de>
Date:   Thu Feb 13 15:28:41 2014 +0100

    spi: Clean up probe and remove functions
    
    While backporting 33cf00e5 ("spi: attach/detach SPI device to the ACPI
    power domain"), I noticed that the code changes were suboptimal:
    
    * Why use &spi->dev when we have dev at hand?
    
    * After fixing the above, spi is used only once, so we don't really
      need a local variable for it.
    
    This results in the following clean-up.
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 23756b0f9036..bb660145d19e 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -255,13 +255,12 @@ EXPORT_SYMBOL_GPL(spi_bus_type);
 static int spi_drv_probe(struct device *dev)
 {
 	const struct spi_driver		*sdrv = to_spi_driver(dev->driver);
-	struct spi_device		*spi = to_spi_device(dev);
 	int ret;
 
-	acpi_dev_pm_attach(&spi->dev, true);
-	ret = sdrv->probe(spi);
+	acpi_dev_pm_attach(dev, true);
+	ret = sdrv->probe(to_spi_device(dev));
 	if (ret)
-		acpi_dev_pm_detach(&spi->dev, true);
+		acpi_dev_pm_detach(dev, true);
 
 	return ret;
 }
@@ -269,11 +268,10 @@ static int spi_drv_probe(struct device *dev)
 static int spi_drv_remove(struct device *dev)
 {
 	const struct spi_driver		*sdrv = to_spi_driver(dev->driver);
-	struct spi_device		*spi = to_spi_device(dev);
 	int ret;
 
-	ret = sdrv->remove(spi);
-	acpi_dev_pm_detach(&spi->dev, true);
+	ret = sdrv->remove(to_spi_device(dev));
+	acpi_dev_pm_detach(dev, true);
 
 	return ret;
 }

commit 513273538a6c10dba1170ecdee5c2da15acecdb5
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Feb 12 20:31:26 2014 +0000

    spi: Make max_tx and max_rx the same type
    
    Prevents spurious compiler warnings.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 49313dd0a144..f3fb1acf9ac1 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -644,7 +644,7 @@ static int spi_map_msg(struct spi_master *master, struct spi_message *msg)
 	struct device *tx_dev, *rx_dev;
 	struct spi_transfer *xfer;
 	void *tmp;
-	size_t max_tx, max_rx;
+	unsigned int max_tx, max_rx;
 	int ret;
 
 	if (master->flags & (SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX)) {

commit 797d0dec8aab6b3a3ac22eaa27ea298bf4ab37e4
Merge: b28a960c42fc 1f802f8249a0
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Feb 11 12:08:26 2014 +0000

    Merge remote-tracking branch 'spi/fix/core' into spi-linus

commit 052eb2d49006fe53bc5f62a196dce23345d4a907
Author: Axel Lin <axel.lin@ingics.com>
Date:   Mon Feb 10 00:08:05 2014 +0800

    spi: core: Set max_speed_hz of spi_device default to max_speed_hz of controller
    
    In __spi_validate(), xfer->speed_hz is set to be spi->max_speed_hz if it is not
    set for this transfer. However, if spi->max_speed_hz is also not set,
    xfer->speed_hz is 0. Some drivers (e.g. au1550, tegra114, tegra20-sflash,
    tegra20-slink, etc.) then use below code to avoid setting xfer->speed_hz to 0.
    
            /* Set speed to the spi max fequency if spi device has not set */
            spi->max_speed_hz = spi->max_speed_hz ? : tspi->spi_max_frequency;
    
    Let's handle it in spi core.
    If spi->max_speed_hz is not set, make it default to spi->master->max_speed_hz.
    So In __spi_validate() if both xfer->speed_hz and spi->max_speed_hz are not set,
    xfer->speed_hz will be set to spi->master->max_speed_hz.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 23756b0f9036..e727ddda78bf 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1599,6 +1599,9 @@ int spi_setup(struct spi_device *spi)
 	if (!spi->bits_per_word)
 		spi->bits_per_word = 8;
 
+	if (!spi->max_speed_hz)
+		spi->max_speed_hz = spi->master->max_speed_hz;
+
 	if (spi->master->setup)
 		status = spi->master->setup(spi);
 

commit 6ad45a27cbe343ec8d7888e5edf6335499a4b555
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Feb 2 13:47:47 2014 +0000

    spi: Make core DMA mapping functions generate scatterlists
    
    We cannot unconditionally use dma_map_single() to map data for use with
    SPI since transfers may exceed a page and virtual addresses may not be
    provided with physically contiguous pages. Further, addresses allocated
    using vmalloc() need to be mapped differently to other addresses.
    
    Currently only the MXS driver handles all this, a few drivers do handle
    the possibility that buffers may not be physically contiguous which is
    the main potential problem but many don't even do that. Factoring this
    out into the core will make it easier for drivers to do a good job so if
    the driver is using the core DMA code then generate a scatterlist
    instead of mapping to a single address so do that.
    
    This code is mainly based on a combination of the existing code in the MXS
    and PXA2xx drivers. In future we should be able to extend it to allow the
    core to concatenate adjacent transfers if they are compatible, improving
    performance.
    
    Currently for simplicity clients are not allowed to use the scatterlist
    when they do DMA mapping, in the future the existing single address
    mappings will be replaced with use of the scatterlist most likely as
    part of pre-verifying transfers.
    
    This change makes it mandatory to use scatterlists when using the core DMA
    mapping so update the s3c64xx driver to do this when used with dmaengine.
    Doing so makes the code more ugly but it is expected that the old s3c-dma
    code can be removed very soon.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index bb7cf561c311..49313dd0a144 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -582,13 +582,70 @@ static void spi_set_cs(struct spi_device *spi, bool enable)
 		spi->master->set_cs(spi, !enable);
 }
 
+static int spi_map_buf(struct spi_master *master, struct device *dev,
+		       struct sg_table *sgt, void *buf, size_t len,
+		       enum dma_data_direction dir)
+{
+	const bool vmalloced_buf = is_vmalloc_addr(buf);
+	const int desc_len = vmalloced_buf ? PAGE_SIZE : master->max_dma_len;
+	const int sgs = DIV_ROUND_UP(len, desc_len);
+	struct page *vm_page;
+	void *sg_buf;
+	size_t min;
+	int i, ret;
+
+	ret = sg_alloc_table(sgt, sgs, GFP_KERNEL);
+	if (ret != 0)
+		return ret;
+
+	for (i = 0; i < sgs; i++) {
+		min = min_t(size_t, len, desc_len);
+
+		if (vmalloced_buf) {
+			vm_page = vmalloc_to_page(buf);
+			if (!vm_page) {
+				sg_free_table(sgt);
+				return -ENOMEM;
+			}
+			sg_buf = page_address(vm_page) +
+				((size_t)buf & ~PAGE_MASK);
+		} else {
+			sg_buf = buf;
+		}
+
+		sg_set_buf(&sgt->sgl[i], sg_buf, min);
+
+		buf += min;
+		len -= min;
+	}
+
+	ret = dma_map_sg(dev, sgt->sgl, sgt->nents, dir);
+	if (ret < 0) {
+		sg_free_table(sgt);
+		return ret;
+	}
+
+	sgt->nents = ret;
+
+	return 0;
+}
+
+static void spi_unmap_buf(struct spi_master *master, struct device *dev,
+			  struct sg_table *sgt, enum dma_data_direction dir)
+{
+	if (sgt->orig_nents) {
+		dma_unmap_sg(dev, sgt->sgl, sgt->orig_nents, dir);
+		sg_free_table(sgt);
+	}
+}
+
 static int spi_map_msg(struct spi_master *master, struct spi_message *msg)
 {
-	struct device *dev = master->dev.parent;
 	struct device *tx_dev, *rx_dev;
 	struct spi_transfer *xfer;
 	void *tmp;
 	size_t max_tx, max_rx;
+	int ret;
 
 	if (master->flags & (SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX)) {
 		max_tx = 0;
@@ -631,7 +688,7 @@ static int spi_map_msg(struct spi_master *master, struct spi_message *msg)
 		}
 	}
 
-	if (msg->is_dma_mapped || !master->can_dma)
+	if (!master->can_dma)
 		return 0;
 
 	tx_dev = &master->dma_tx->dev->device;
@@ -642,25 +699,21 @@ static int spi_map_msg(struct spi_master *master, struct spi_message *msg)
 			continue;
 
 		if (xfer->tx_buf != NULL) {
-			xfer->tx_dma = dma_map_single(tx_dev,
-						      (void *)xfer->tx_buf,
-						      xfer->len,
-						      DMA_TO_DEVICE);
-			if (dma_mapping_error(dev, xfer->tx_dma)) {
-				dev_err(dev, "dma_map_single Tx failed\n");
-				return -ENOMEM;
-			}
+			ret = spi_map_buf(master, tx_dev, &xfer->tx_sg,
+					  (void *)xfer->tx_buf, xfer->len,
+					  DMA_TO_DEVICE);
+			if (ret != 0)
+				return ret;
 		}
 
 		if (xfer->rx_buf != NULL) {
-			xfer->rx_dma = dma_map_single(rx_dev,
-						      xfer->rx_buf, xfer->len,
-						      DMA_FROM_DEVICE);
-			if (dma_mapping_error(dev, xfer->rx_dma)) {
-				dev_err(dev, "dma_map_single Rx failed\n");
-				dma_unmap_single(tx_dev, xfer->tx_dma,
-						 xfer->len, DMA_TO_DEVICE);
-				return -ENOMEM;
+			ret = spi_map_buf(master, rx_dev, &xfer->rx_sg,
+					  xfer->rx_buf, xfer->len,
+					  DMA_FROM_DEVICE);
+			if (ret != 0) {
+				spi_unmap_buf(master, tx_dev, &xfer->tx_sg,
+					      DMA_TO_DEVICE);
+				return ret;
 			}
 		}
 	}
@@ -675,7 +728,7 @@ static int spi_unmap_msg(struct spi_master *master, struct spi_message *msg)
 	struct spi_transfer *xfer;
 	struct device *tx_dev, *rx_dev;
 
-	if (!master->cur_msg_mapped || msg->is_dma_mapped || !master->can_dma)
+	if (!master->cur_msg_mapped || !master->can_dma)
 		return 0;
 
 	tx_dev = &master->dma_tx->dev->device;
@@ -685,12 +738,8 @@ static int spi_unmap_msg(struct spi_master *master, struct spi_message *msg)
 		if (!master->can_dma(master, msg->spi, xfer))
 			continue;
 
-		if (xfer->rx_buf)
-			dma_unmap_single(rx_dev, xfer->rx_dma, xfer->len,
-					 DMA_FROM_DEVICE);
-		if (xfer->tx_buf)
-			dma_unmap_single(tx_dev, xfer->tx_dma, xfer->len,
-					 DMA_TO_DEVICE);
+		spi_unmap_buf(master, rx_dev, &xfer->rx_sg, DMA_FROM_DEVICE);
+		spi_unmap_buf(master, tx_dev, &xfer->tx_sg, DMA_TO_DEVICE);
 	}
 
 	return 0;
@@ -1503,6 +1552,8 @@ int spi_register_master(struct spi_master *master)
 	mutex_init(&master->bus_lock_mutex);
 	master->bus_lock_flag = 0;
 	init_completion(&master->xfer_completion);
+	if (!master->max_dma_len)
+		master->max_dma_len = INT_MAX;
 
 	/* register the device, then userspace will see it.
 	 * registration fails if the bus ID is in use.

commit 3a2eba9bd0a6447dfbc01635e4cd0689f5f2bdad
Author: Mark Brown <broonie@linaro.org>
Date:   Tue Jan 28 20:17:03 2014 +0000

    spi: Provide core support for full duplex devices
    
    It is fairly common for SPI devices to require that one or both transfer
    directions is always active. Currently drivers open code this in various
    ways with varying degrees of efficiency. Start factoring this out by
    providing flags SPI_MASTER_MUST_TX and SPI_MASTER_MUST_RX. These will cause
    the core to provide buffers for the requested direction if none are
    specified in the underlying transfer.
    
    Currently this is fairly inefficient since we actually allocate a data
    buffer which may get large, support for mapping transfers using a
    scatterlist will allow us to avoid this for DMA based transfers.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index bcdaa74f1c8e..bb7cf561c311 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -587,6 +587,49 @@ static int spi_map_msg(struct spi_master *master, struct spi_message *msg)
 	struct device *dev = master->dev.parent;
 	struct device *tx_dev, *rx_dev;
 	struct spi_transfer *xfer;
+	void *tmp;
+	size_t max_tx, max_rx;
+
+	if (master->flags & (SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX)) {
+		max_tx = 0;
+		max_rx = 0;
+
+		list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+			if ((master->flags & SPI_MASTER_MUST_TX) &&
+			    !xfer->tx_buf)
+				max_tx = max(xfer->len, max_tx);
+			if ((master->flags & SPI_MASTER_MUST_RX) &&
+			    !xfer->rx_buf)
+				max_rx = max(xfer->len, max_rx);
+		}
+
+		if (max_tx) {
+			tmp = krealloc(master->dummy_tx, max_tx,
+				       GFP_KERNEL | GFP_DMA);
+			if (!tmp)
+				return -ENOMEM;
+			master->dummy_tx = tmp;
+			memset(tmp, 0, max_tx);
+		}
+
+		if (max_rx) {
+			tmp = krealloc(master->dummy_rx, max_rx,
+				       GFP_KERNEL | GFP_DMA);
+			if (!tmp)
+				return -ENOMEM;
+			master->dummy_rx = tmp;
+		}
+
+		if (max_tx || max_rx) {
+			list_for_each_entry(xfer, &msg->transfers,
+					    transfer_list) {
+				if (!xfer->tx_buf)
+					xfer->tx_buf = master->dummy_tx;
+				if (!xfer->rx_buf)
+					xfer->rx_buf = master->dummy_rx;
+			}
+		}
+	}
 
 	if (msg->is_dma_mapped || !master->can_dma)
 		return 0;
@@ -759,6 +802,10 @@ static void spi_pump_messages(struct kthread_work *work)
 		}
 		master->busy = false;
 		spin_unlock_irqrestore(&master->queue_lock, flags);
+		kfree(master->dummy_rx);
+		master->dummy_rx = NULL;
+		kfree(master->dummy_tx);
+		master->dummy_tx = NULL;
 		if (master->unprepare_transfer_hardware &&
 		    master->unprepare_transfer_hardware(master))
 			dev_err(&master->dev,

commit 99adef310f682d6343cb40c1f6c9c25a4b3a450d
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Jan 16 12:22:43 2014 +0000

    spi: Provide core support for DMA mapping transfers
    
    The process of DMA mapping buffers for SPI transfers does not vary between
    devices so in order to save duplication of code in drivers this can be
    factored out into the core, allowing it to be integrated with the work that
    is being done on factoring out the common elements from the data path
    including more sharing of dmaengine code.
    
    In order to use this masters need to provide a can_dma() operation and while
    the hardware is prepared they should ensure that DMA channels are provided
    in tx_dma and rx_dma. The core will then ensure that the buffers are mapped
    for DMA prior to calling transfer_one_message().
    
    Currently the cleanup on error is not complete, this needs to be improved.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 23756b0f9036..bcdaa74f1c8e 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -24,6 +24,8 @@
 #include <linux/device.h>
 #include <linux/init.h>
 #include <linux/cache.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
 #include <linux/mutex.h>
 #include <linux/of_device.h>
 #include <linux/of_irq.h>
@@ -580,6 +582,77 @@ static void spi_set_cs(struct spi_device *spi, bool enable)
 		spi->master->set_cs(spi, !enable);
 }
 
+static int spi_map_msg(struct spi_master *master, struct spi_message *msg)
+{
+	struct device *dev = master->dev.parent;
+	struct device *tx_dev, *rx_dev;
+	struct spi_transfer *xfer;
+
+	if (msg->is_dma_mapped || !master->can_dma)
+		return 0;
+
+	tx_dev = &master->dma_tx->dev->device;
+	rx_dev = &master->dma_rx->dev->device;
+
+	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		if (!master->can_dma(master, msg->spi, xfer))
+			continue;
+
+		if (xfer->tx_buf != NULL) {
+			xfer->tx_dma = dma_map_single(tx_dev,
+						      (void *)xfer->tx_buf,
+						      xfer->len,
+						      DMA_TO_DEVICE);
+			if (dma_mapping_error(dev, xfer->tx_dma)) {
+				dev_err(dev, "dma_map_single Tx failed\n");
+				return -ENOMEM;
+			}
+		}
+
+		if (xfer->rx_buf != NULL) {
+			xfer->rx_dma = dma_map_single(rx_dev,
+						      xfer->rx_buf, xfer->len,
+						      DMA_FROM_DEVICE);
+			if (dma_mapping_error(dev, xfer->rx_dma)) {
+				dev_err(dev, "dma_map_single Rx failed\n");
+				dma_unmap_single(tx_dev, xfer->tx_dma,
+						 xfer->len, DMA_TO_DEVICE);
+				return -ENOMEM;
+			}
+		}
+	}
+
+	master->cur_msg_mapped = true;
+
+	return 0;
+}
+
+static int spi_unmap_msg(struct spi_master *master, struct spi_message *msg)
+{
+	struct spi_transfer *xfer;
+	struct device *tx_dev, *rx_dev;
+
+	if (!master->cur_msg_mapped || msg->is_dma_mapped || !master->can_dma)
+		return 0;
+
+	tx_dev = &master->dma_tx->dev->device;
+	rx_dev = &master->dma_rx->dev->device;
+
+	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		if (!master->can_dma(master, msg->spi, xfer))
+			continue;
+
+		if (xfer->rx_buf)
+			dma_unmap_single(rx_dev, xfer->rx_dma, xfer->len,
+					 DMA_FROM_DEVICE);
+		if (xfer->tx_buf)
+			dma_unmap_single(tx_dev, xfer->tx_dma, xfer->len,
+					 DMA_TO_DEVICE);
+	}
+
+	return 0;
+}
+
 /*
  * spi_transfer_one_message - Default implementation of transfer_one_message()
  *
@@ -752,6 +825,13 @@ static void spi_pump_messages(struct kthread_work *work)
 		master->cur_msg_prepared = true;
 	}
 
+	ret = spi_map_msg(master, master->cur_msg);
+	if (ret) {
+		master->cur_msg->status = ret;
+		spi_finalize_current_message(master);
+		return;
+	}
+
 	ret = master->transfer_one_message(master, master->cur_msg);
 	if (ret) {
 		dev_err(&master->dev,
@@ -841,6 +921,8 @@ void spi_finalize_current_message(struct spi_master *master)
 	queue_kthread_work(&master->kworker, &master->pump_messages);
 	spin_unlock_irqrestore(&master->queue_lock, flags);
 
+	spi_unmap_msg(master, mesg);
+
 	if (master->cur_msg_prepared && master->unprepare_message) {
 		ret = master->unprepare_message(master, mesg);
 		if (ret) {

commit 16a0ce4e10edfe376b3071f161c71c4160c89d6b
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Jan 30 22:16:41 2014 +0000

    spi: Add a timeout when waiting for transfers
    
    Don't wait indefinitely for transfers to complete but time out after 10ms
    more than we expect the transfer to take on the wire.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 23756b0f9036..516643d243c6 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -594,6 +594,7 @@ static int spi_transfer_one_message(struct spi_master *master,
 	bool cur_cs = true;
 	bool keep_cs = false;
 	int ret = 0;
+	int ms = 1;
 
 	spi_set_cs(msg->spi, true);
 
@@ -611,7 +612,16 @@ static int spi_transfer_one_message(struct spi_master *master,
 
 		if (ret > 0) {
 			ret = 0;
-			wait_for_completion(&master->xfer_completion);
+			ms = xfer->len * 8 * 1000 / xfer->speed_hz;
+			ms += 10; /* some tolerance */
+
+			ms = wait_for_completion_timeout(&master->xfer_completion,
+							 msecs_to_jiffies(ms));
+		}
+
+		if (ms == 0) {
+			dev_err(&msg->spi->dev, "SPI transfer timed out\n");
+			msg->status = -ETIMEDOUT;
 		}
 
 		trace_spi_transfer_stop(msg, xfer);

commit 1f802f8249a0da536877842c43c7204064c4de8b
Author: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
Date:   Tue Jan 28 10:33:03 2014 +0100

    spi: Fix crash with double message finalisation on error handling
    
    This reverts commit e120cc0dcf2880a4c5c0a6cb27b655600a1cfa1d.
    
    It causes a NULL pointer dereference with drivers using the generic
    spi_transfer_one_message(), which always calls
    spi_finalize_current_message(), which zeroes master->cur_msg.
    
    Drivers implementing transfer_one_message() theirselves must always call
    spi_finalize_current_message(), even if the transfer failed:
    
     * @transfer_one_message: the subsystem calls the driver to transfer a single
     *      message while queuing transfers that arrive in the meantime. When the
     *      driver is finished with this message, it must call
     *      spi_finalize_current_message() so the subsystem can issue the next
     *      transfer
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 63613a96233c..26f4afd19faf 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -745,9 +745,7 @@ static void spi_pump_messages(struct kthread_work *work)
 	ret = master->transfer_one_message(master, master->cur_msg);
 	if (ret) {
 		dev_err(&master->dev,
-			"failed to transfer one message from queue: %d\n", ret);
-		master->cur_msg->status = ret;
-		spi_finalize_current_message(master);
+			"failed to transfer one message from queue\n");
 		return;
 	}
 }

commit 2d2e7d195b902c419bc0b69ced026aca444d69a8
Merge: 15333539a9b3 8b8b773e6b61
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 25 13:20:36 2014 -0800

    Merge tag 'spi-v3.14-2' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi
    
    Pull spi updates from Mark Brown:
     "A respun version of the merges for the pull request previously sent
      with a few additional fixes.  The last two merges were fixed up by
      hand since the branches have moved on and currently have the prior
      merge in them.
    
      Quite a busy release for the SPI subsystem, mostly in cleanups big and
      small scattered through the stack rather than anything else:
    
       - New driver for the Broadcom BC63xx HSSPI controller
       - Fix duplicate device registration for ACPI
       - Conversion of s3c64xx to DMAEngine (this pulls in platform and DMA
         changes upon which the transiton depends)
       - Some small optimisations to reduce the amount of time we hold locks
         in the datapath, eliminate some redundant checks and the size of a
         spi_transfer
       - Lots of fixes, cleanups and general enhancements to drivers,
         especially the rspi and Atmel drivers"
    
    * tag 'spi-v3.14-2' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi: (112 commits)
      spi: core: Fix transfer failure when master->transfer_one returns positive value
      spi: Correct set_cs() documentation
      spi: Clarify transfer_one() w.r.t. spi_finalize_current_transfer()
      spi: Spelling s/finised/finished/
      spi: sc18is602: Convert to use bits_per_word_mask
      spi: Remove duplicate code to set default bits_per_word setting
      spi/pxa2xx: fix compilation warning when !CONFIG_PM_SLEEP
      spi: clps711x: Add MODULE_ALIAS to support module auto-loading
      spi: rspi: Add missing clk_disable() calls in error and cleanup paths
      spi: rspi: Spelling s/transmition/transmission/
      spi: rspi: Add support for specifying CPHA/CPOL
      spi/pxa2xx: initialize DMA channels to -1 to prevent inadvertent match
      spi: rspi: Add more QSPI register documentation
      spi: rspi: Add more RSPI register documentation
      spi: rspi: Remove dependency on DMAE for SHMOBILE
      spi/s3c64xx: Correct indentation
      spi: sh: Use spi_sh_clear_bit() instead of open-coded
      spi: bitbang: Grammar s/make to make/to make/
      spi: sh-hspi: Spelling s/recive/receive/
      spi: core: Improve tx/rx_nbits check comments
      ...

commit 3c1039745ef2925aceed53d38af0cddac8e36f31
Merge: 7e2c225d585c 1afd9989a6a2
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Jan 23 13:07:01 2014 +0000

    Merge remote-tracking branch 'spi/topic/core' into spi-linus

commit 7e2c225d585cd6d7481ff4ec446a67334ef11f4d
Merge: 7e22e91102c6 13a427988022
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Jan 23 13:07:00 2014 +0000

    Merge remote-tracking branch 'spi/fix/core' into spi-linus

commit 13a4279880229240af38486611c94587492b24d3
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sat Jan 18 22:05:22 2014 +0800

    spi: core: Fix transfer failure when master->transfer_one returns positive value
    
    master->transfer_one returns positive value is not a error.
    So set ret to 0 when master->transfer_one returns positive value.
    Otherwise, I hit "spi_master spi0: failed to transfer one message from queue"
    error when my transfer_one callback returns 1.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 56b41099b40c..8ed1aee13c6f 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -599,8 +599,10 @@ static int spi_transfer_one_message(struct spi_master *master,
 			goto out;
 		}
 
-		if (ret > 0)
+		if (ret > 0) {
+			ret = 0;
 			wait_for_completion(&master->xfer_completion);
+		}
 
 		trace_spi_transfer_stop(msg, xfer);
 

commit 9e8f4882cc49205a688b616c1b6c17bade10587f
Author: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
Date:   Tue Jan 21 16:10:05 2014 +0100

    spi: Spelling s/finised/finished/
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 51e00c6436aa..56b41099b40c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -640,7 +640,7 @@ static int spi_transfer_one_message(struct spi_master *master,
  *
  * Called by SPI drivers using the core transfer_one_message()
  * implementation to notify it that the current interrupt driven
- * transfer has finised and the next one may be scheduled.
+ * transfer has finished and the next one may be scheduled.
  */
 void spi_finalize_current_transfer(struct spi_master *master)
 {

commit 8c4ff6d0094a16809a7ecdd49d71cf06b0a51326
Author: Zhang Rui <rui.zhang@intel.com>
Date:   Tue Jan 14 16:46:37 2014 +0800

    ACPI: fix module autoloading for ACPI enumerated devices
    
    ACPI enumerated devices has ACPI style _HID and _CID strings,
    all of these strings can be used for both driver loading and matching.
    
    Currently, in Platform, I2C and SPI bus, the ACPI style driver matching
    is supported by invoking acpi_driver_match_device() in bus .match() callback.
    But, the module autoloading is still broken.
    
    For example, there is any ACPI device with _HID "INTABCD" that is
    enumerated to platform bus, and we have a driver that can probe it.
    
    The driver exports its module_alias as "acpi:INTABCD" use the following code
    static const struct acpi_device_id xxx_acpi_match[] = {
            { "INTABCD", 0 },
            { }
    };
    MODULE_DEVICE_TABLE(acpi, xxx_acpi_match);
    
    But, unfortunately, the device' modalias is shown as "platform:INTABCD:00",
    please refer to modalias_show() and platform_uevent() in
    drivers/base/platform.c.
    This results in that the driver will not be loaded automatically when the
    device node is created, because their modalias do not match.
    
    This also applies to I2C and SPI bus.
    
    With this patch, the device' modalias will be shown as "acpi:INTABCD" as well.
    
    Signed-off-by: Zhang Rui <rui.zhang@intel.com>
    Acked-by: Mark Brown <broonie@linaro.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 349ebba4b199..827ff49d3d4f 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -58,6 +58,11 @@ static ssize_t
 modalias_show(struct device *dev, struct device_attribute *a, char *buf)
 {
 	const struct spi_device	*spi = to_spi_device(dev);
+	int len;
+
+	len = acpi_device_modalias(dev, buf, PAGE_SIZE - 1);
+	if (len != -ENODEV)
+		return len;
 
 	return sprintf(buf, "%s%s\n", SPI_MODULE_PREFIX, spi->modalias);
 }
@@ -114,6 +119,11 @@ static int spi_match_device(struct device *dev, struct device_driver *drv)
 static int spi_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	const struct spi_device		*spi = to_spi_device(dev);
+	int rc;
+
+	rc = acpi_device_uevent_modalias(dev, env);
+	if (rc != -ENODEV)
+		return rc;
 
 	add_uevent_var(env, "MODALIAS=%s%s", SPI_MODULE_PREFIX, spi->modalias);
 	return 0;

commit 1afd9989a6a2561183be82e420d4d2f3889b7ee7
Author: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
Date:   Sun Jan 12 14:00:29 2014 +0100

    spi: core: Improve tx/rx_nbits check comments
    
      - Rephrase the comments about tx/rx_nbits validity checks,
      - Remove the stale comment about SPI_3WIRE (the code it refers to was
        removed in commit 368ca4e0c75612c0a4d6bbcef7efb944604340c2 ("spi:
        Eliminate 3WIRE spi_transfer check")).
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@linux-m68k.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 36bfa7f820a6..9f26797e4319 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1660,9 +1660,8 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 		if (xfer->rx_buf && !xfer->rx_nbits)
 			xfer->rx_nbits = SPI_NBITS_SINGLE;
 		/* check transfer tx/rx_nbits:
-		 * 1. keep the value is not out of single, dual and quad
-		 * 2. keep tx/rx_nbits is contained by mode in spi_device
-		 * 3. if SPI_3WIRE, tx/rx_nbits should be in single
+		 * 1. check the value matches one of single, dual and quad
+		 * 2. check tx/rx_nbits match the mode in spi_device
 		 */
 		if (xfer->tx_buf) {
 			if (xfer->tx_nbits != SPI_NBITS_SINGLE &&

commit b6fb8d3a1f156c50a35f88b9b55f404034493938
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Jan 9 15:23:55 2014 +0200

    spi: Check conflicting CS based on spi->chip_select instead of device name
    
    Commit e13ac47bec20 (spi: Use stable dev_name for ACPI enumerated SPI
    slaves) changed the SPI device naming to be based on ACPI device name
    instead of carrying bus number and chip select for devices enumerated
    from ACPI namespace.
    
    In case of a buggy BIOS that lists multiple SPI devices sharing the same
    chip select (even though they should use different) the current code fails
    to detect that and allows the devices to be added to the bus.
    
    Fix this by walking through the bus and comparing spi->chip_select instead
    of device name. This should work regardless what the device name will be in
    future.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 0e215237383b..51e00c6436aa 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -370,6 +370,17 @@ static void spi_dev_set_name(struct spi_device *spi)
 		     spi->chip_select);
 }
 
+static int spi_dev_check(struct device *dev, void *data)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct spi_device *new_spi = data;
+
+	if (spi->master == new_spi->master &&
+	    spi->chip_select == new_spi->chip_select)
+		return -EBUSY;
+	return 0;
+}
+
 /**
  * spi_add_device - Add spi_device allocated with spi_alloc_device
  * @spi: spi_device to register
@@ -384,7 +395,6 @@ int spi_add_device(struct spi_device *spi)
 	static DEFINE_MUTEX(spi_add_lock);
 	struct spi_master *master = spi->master;
 	struct device *dev = master->dev.parent;
-	struct device *d;
 	int status;
 
 	/* Chipselects are numbered 0..max; validate. */
@@ -404,12 +414,10 @@ int spi_add_device(struct spi_device *spi)
 	 */
 	mutex_lock(&spi_add_lock);
 
-	d = bus_find_device_by_name(&spi_bus_type, NULL, dev_name(&spi->dev));
-	if (d != NULL) {
+	status = bus_for_each_dev(&spi_bus_type, NULL, spi, spi_dev_check);
+	if (status) {
 		dev_err(dev, "chipselect %d already in use\n",
 				spi->chip_select);
-		put_device(d);
-		status = -EBUSY;
 		goto done;
 	}
 

commit a89e2d2754246645959f1a2f91e37e9b367bfd36
Author: Axel Lin <axel.lin@ingics.com>
Date:   Thu Jan 9 16:03:58 2014 +0800

    spi: core: Use list_first_entry to extract head of queue
    
    For slightly better readability.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 401cd66770f9..36bfa7f820a6 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -685,7 +685,7 @@ static void spi_pump_messages(struct kthread_work *work)
 	}
 	/* Extract head of queue */
 	master->cur_msg =
-	    list_entry(master->queue.next, struct spi_message, queue);
+		list_first_entry(&master->queue, struct spi_message, queue);
 
 	list_del_init(&master->cur_msg->queue);
 	if (master->busy)

commit e120cc0dcf2880a4c5c0a6cb27b655600a1cfa1d
Author: Daniel Santos <daniel.santos@pobox.com>
Date:   Sun Jan 5 17:39:26 2014 -0600

    spidev: fix hang when transfer_one_message fails
    
    This corrects a problem in spi_pump_messages() that leads to an spi
    message hanging forever when a call to transfer_one_message() fails.
    This failure occurs in my MCP2210 driver when the cs_change bit is set
    on the last transfer in a message, an operation which the hardware does
    not support.
    
    Rationale
    Since the transfer_one_message() returns an int, we must presume that it
    may fail.  If transfer_one_message() should never fail, it should return
    void.  Thus, calls to transfer_one_message() should properly manage a
    failure.
    
    Fixes: ffbbdd21329f3 (spi: create a message queueing infrastructure)
    Signed-off-by: Daniel Santos <daniel.santos@pobox.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 18cc625d887f..0e215237383b 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -735,7 +735,9 @@ static void spi_pump_messages(struct kthread_work *work)
 	ret = master->transfer_one_message(master, master->cur_msg);
 	if (ret) {
 		dev_err(&master->dev,
-			"failed to transfer one message from queue\n");
+			"failed to transfer one message from queue: %d\n", ret);
+		master->cur_msg->status = ret;
+		spi_finalize_current_message(master);
 		return;
 	}
 }

commit 1cfd97f93e36b3f8b5d2a26147aaccae0c847a9c
Author: Axel Lin <axel.lin@ingics.com>
Date:   Thu Jan 2 15:16:40 2014 +0800

    spi: core: Use list_first_entry_or_null() instead of open-coded
    
    Use list_first_entry_or_null() to save a few lines.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 2cd9fdc9c7f9..401cd66770f9 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -791,11 +791,8 @@ struct spi_message *spi_get_next_queued_message(struct spi_master *master)
 
 	/* get a pointer to the next message, if any */
 	spin_lock_irqsave(&master->queue_lock, flags);
-	if (list_empty(&master->queue))
-		next = NULL;
-	else
-		next = list_entry(master->queue.next,
-				  struct spi_message, queue);
+	next = list_first_entry_or_null(&master->queue, struct spi_message,
+					queue);
 	spin_unlock_irqrestore(&master->queue_lock, flags);
 
 	return next;

commit 368ca4e0c75612c0a4d6bbcef7efb944604340c2
Author: Trent Piepho <tpiepho@gmail.com>
Date:   Thu Dec 26 21:51:06 2013 -0800

    spi: Eliminate 3WIRE spi_transfer check
    
    Checking for SPI_3WIRE isn't needed.  spi_setup() already prevents 3WIRE
    mode from being combined with DUAL or QUAD mode support.  So there is no
    need to differentiate between a single bit device with SPI_3WIRE set and
    one with without.  It doesn't change the allowed bit widths.
    
    Signed-off-by: Trent Piepho <tpiepho@gmail.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 857ee8c407b1..2cd9fdc9c7f9 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1678,9 +1678,6 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 			if ((xfer->tx_nbits == SPI_NBITS_QUAD) &&
 				!(spi->mode & SPI_TX_QUAD))
 				return -EINVAL;
-			if ((spi->mode & SPI_3WIRE) &&
-				(xfer->tx_nbits != SPI_NBITS_SINGLE))
-				return -EINVAL;
 		}
 		/* check transfer rx_nbits */
 		if (xfer->rx_buf) {
@@ -1694,9 +1691,6 @@ static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 			if ((xfer->rx_nbits == SPI_NBITS_QUAD) &&
 				!(spi->mode & SPI_RX_QUAD))
 				return -EINVAL;
-			if ((spi->mode & SPI_3WIRE) &&
-				(xfer->rx_nbits != SPI_NBITS_SINGLE))
-				return -EINVAL;
 		}
 	}
 

commit b8aba7611b9a5a1f67f081be84270c67baf4d2c3
Merge: 6ce4eac1f600 4b92894ee70c
Author: Mark Brown <broonie@linaro.org>
Date:   Thu Nov 28 11:31:35 2013 +0000

    Merge remote-tracking branch 'spi/fix/core' into spi-linus

commit 90808738fd242ef2533e86f2f481bebe8a7aa11b
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Nov 13 23:44:15 2013 +0000

    spi: Factor validation and initialisation of messages outside lock
    
    Currently we do a bunch of per-message validation and initialisation in
    __spi_async() which is called with the bus lock held. Since none of this
    validation depends on the current bus status there's no need to hold the
    lock to do it so split it out into a separate __spi_validate() function
    which is called prior to taking the bus lock.
    
    This could be slightly neater but keep things simple for now to show the
    code motion clearly.
    
    Based on observations from Martin Sperl.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 18cc625d887f..857ee8c407b1 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1596,15 +1596,11 @@ int spi_setup(struct spi_device *spi)
 }
 EXPORT_SYMBOL_GPL(spi_setup);
 
-static int __spi_async(struct spi_device *spi, struct spi_message *message)
+static int __spi_validate(struct spi_device *spi, struct spi_message *message)
 {
 	struct spi_master *master = spi->master;
 	struct spi_transfer *xfer;
 
-	message->spi = spi;
-
-	trace_spi_message_submit(message);
-
 	if (list_empty(&message->transfers))
 		return -EINVAL;
 	if (!message->complete)
@@ -1705,6 +1701,18 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
 	}
 
 	message->status = -EINPROGRESS;
+
+	return 0;
+}
+
+static int __spi_async(struct spi_device *spi, struct spi_message *message)
+{
+	struct spi_master *master = spi->master;
+
+	message->spi = spi;
+
+	trace_spi_message_submit(message);
+
 	return master->transfer(spi, message);
 }
 
@@ -1743,6 +1751,10 @@ int spi_async(struct spi_device *spi, struct spi_message *message)
 	int ret;
 	unsigned long flags;
 
+	ret = __spi_validate(spi, message);
+	if (ret != 0)
+		return ret;
+
 	spin_lock_irqsave(&master->bus_lock_spinlock, flags);
 
 	if (master->bus_lock_flag)
@@ -1791,6 +1803,10 @@ int spi_async_locked(struct spi_device *spi, struct spi_message *message)
 	int ret;
 	unsigned long flags;
 
+	ret = __spi_validate(spi, message);
+	if (ret != 0)
+		return ret;
+
 	spin_lock_irqsave(&master->bus_lock_spinlock, flags);
 
 	ret = __spi_async(spi, message);

commit 4b92894ee70c9110c083aa60b0663d357495864d
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Nov 21 16:11:15 2013 -0700

    spi: core: invert success test in devm_spi_register_master
    
    devres_add() should be called when the action to be undone succeeded,
    not when it failed. Fix the inverted test in devm_spi_register_master()
    which was doing the opposite.
    
    The user-visible issue without this fix is:
    insmod spi-tegra114.ko
      Assume there's an MTD device on that SPI bus, which creates /dev/mtd0.
    rmmod spi-tegra114
      Doesn't remove devices on the SPI bus.
    insmod spi-tegra114.ko
      Creates a duplicate SPI device which creates /dev/mtd1.
    hexdump -C /dev/mtd0
      That's the old device, which uses an SPI bus hosted by a non-existent
      module, which causes the oops below.
    
    Unable to handle kernel paging request at virtual address bf0017c0
    pgd = c0004000
    [bf0017c0] *pgd=ad51b811, *pte=00000000, *ppte=00000000
    Internal error: Oops: 80000007 [#1] PREEMPT SMP ARM
    ...
    PC is at 0xbf0017c0
    LR is at spi_pump_messages+0x15c/0x204
    pc : [<bf0017c0>] lr : [<c02f0af8>] psr: 60000113
    ...
    
    Fixes: 666d5b4c742b ("spi: core: Add devm_spi_register_master()")
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 8d05accf706c..481e13f0db54 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1390,7 +1390,7 @@ int devm_spi_register_master(struct device *dev, struct spi_master *master)
 		return -ENOMEM;
 
 	ret = spi_register_master(master);
-	if (ret != 0) {
+	if (!ret) {
 		*ptr = master;
 		devres_add(dev, ptr);
 	} else {

commit 82023bb7f75b0052f40d3e74169d191c3e4e6286
Merge: e6d69a60b77a ed6a82546d2e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 20 13:25:04 2013 -0800

    Merge tag 'pm+acpi-2-3.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more ACPI and power management updates from Rafael Wysocki:
    
     - ACPI-based device hotplug fixes for issues introduced recently and a
       fix for an older error code path bug in the ACPI PCI host bridge
       driver
    
     - Fix for recently broken OMAP cpufreq build from Viresh Kumar
    
     - Fix for a recent hibernation regression related to s2disk
    
     - Fix for a locking-related regression in the ACPI EC driver from
       Puneet Kumar
    
     - System suspend error code path fix related to runtime PM and runtime
       PM documentation update from Ulf Hansson
    
     - cpufreq's conservative governor fix from Xiaoguang Chen
    
     - New processor IDs for intel_idle and turbostat and removal of an
       obsolete Kconfig option from Len Brown
    
     - New device IDs for the ACPI LPSS (Low-Power Subsystem) driver and
       ACPI-based PCI hotplug (ACPIPHP) cleanup from Mika Westerberg
    
     - Removal of several ACPI video DMI blacklist entries that are not
       necessary any more from Aaron Lu
    
     - Rework of the ACPI companion representation in struct device and code
       cleanup related to that change from Rafael J Wysocki, Lan Tianyu and
       Jarkko Nikula
    
     - Fixes for assigning names to ACPI-enumerated I2C and SPI devices from
       Jarkko Nikula
    
    * tag 'pm+acpi-2-3.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (24 commits)
      PCI / hotplug / ACPI: Drop unused acpiphp_debug declaration
      ACPI / scan: Set flags.match_driver in acpi_bus_scan_fixed()
      ACPI / PCI root: Clear driver_data before failing enumeration
      ACPI / hotplug: Fix PCI host bridge hot removal
      ACPI / hotplug: Fix acpi_bus_get_device() return value check
      cpufreq: governor: Remove fossil comment in the cpufreq_governor_dbs()
      ACPI / video: clean up DMI table for initial black screen problem
      ACPI / EC: Ensure lock is acquired before accessing ec struct members
      PM / Hibernate: Do not crash kernel in free_basic_memory_bitmaps()
      ACPI / AC: Remove struct acpi_device pointer from struct acpi_ac
      spi: Use stable dev_name for ACPI enumerated SPI slaves
      i2c: Use stable dev_name for ACPI enumerated I2C slaves
      ACPI: Provide acpi_dev_name accessor for struct acpi_device device name
      ACPI / bind: Use (put|get)_device() on ACPI device objects too
      ACPI: Eliminate the DEVICE_ACPI_HANDLE() macro
      ACPI / driver core: Store an ACPI device pointer in struct acpi_dev_node
      cpufreq: OMAP: Fix compilation error 'r & ret undeclared'
      PM / Runtime: Fix error path for prepare
      PM / Runtime: Update documentation around probe|remove|suspend
      cpufreq: conservative: set requested_freq to policy max when it is over policy max
      ...

commit 16735d022f72b20ddbb2274b8e109f69575e9b2b
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Thu Nov 14 14:32:02 2013 -0800

    tree-wide: use reinit_completion instead of INIT_COMPLETION
    
    Use this new function to make code more comprehensible, since we are
    reinitialzing the completion, not initializing.
    
    [akpm@linux-foundation.org: linux-next resyncs]
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Linus Walleij <linus.walleij@linaro.org> (personally at LCE13)
    Cc: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 927998aa5e71..8d85ddc46011 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -571,7 +571,7 @@ static int spi_transfer_one_message(struct spi_master *master,
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		trace_spi_transfer_start(msg, xfer);
 
-		INIT_COMPLETION(master->xfer_completion);
+		reinit_completion(&master->xfer_completion);
 
 		ret = master->transfer_one(master, msg->spi, xfer);
 		if (ret < 0) {

commit e13ac47bec20797fa9262cffcae9cf0e3aa1b9b2
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Thu Nov 14 14:03:53 2013 +0200

    spi: Use stable dev_name for ACPI enumerated SPI slaves
    
    Current spi bus_num.chip_select "spix.y" based device naming scheme may not
    be stable enough to be used in name based matching, for instance within
    ALSA SoC subsystem.
    
    This can be problem in PC kind of platforms if there are changes in SPI bus
    configuration, amount of busses or probe order.
    
    This patch addresses the problem by using the ACPI device name with
    "spi-" prefix for ACPI enumerated SPI slave. For them device name
    "spix.y" becomes "spi-INTABCD:ij".
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Acked-by: Mark Brown <broonie@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index a968d8549ee5..8763d93ce2b7 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -357,6 +357,19 @@ struct spi_device *spi_alloc_device(struct spi_master *master)
 }
 EXPORT_SYMBOL_GPL(spi_alloc_device);
 
+static void spi_dev_set_name(struct spi_device *spi)
+{
+	struct acpi_device *adev = ACPI_COMPANION(&spi->dev);
+
+	if (adev) {
+		dev_set_name(&spi->dev, "spi-%s", acpi_dev_name(adev));
+		return;
+	}
+
+	dev_set_name(&spi->dev, "%s.%u", dev_name(&spi->master->dev),
+		     spi->chip_select);
+}
+
 /**
  * spi_add_device - Add spi_device allocated with spi_alloc_device
  * @spi: spi_device to register
@@ -383,9 +396,7 @@ int spi_add_device(struct spi_device *spi)
 	}
 
 	/* Set the bus ID string */
-	dev_set_name(&spi->dev, "%s.%u", dev_name(&spi->master->dev),
-			spi->chip_select);
-
+	spi_dev_set_name(spi);
 
 	/* We need to make sure there's no other device with this
 	 * chipselect **BEFORE** we call setup(), else we'll trash

commit 7b1998116bbb2f3e5dd6cb9a8ee6db479b0b50a9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Nov 11 22:41:56 2013 +0100

    ACPI / driver core: Store an ACPI device pointer in struct acpi_dev_node
    
    Modify struct acpi_dev_node to contain a pointer to struct acpi_device
    associated with the given device object (that is, its ACPI companion
    device) instead of an ACPI handle corresponding to it.  Introduce two
    new macros for manipulating that pointer in a CONFIG_ACPI-safe way,
    ACPI_COMPANION() and ACPI_COMPANION_SET(), and rework the
    ACPI_HANDLE() macro to take the above changes into account.
    Drop the ACPI_HANDLE_SET() macro entirely and rework its users to
    use ACPI_COMPANION_SET() instead.  For some of them who used to
    pass the result of acpi_get_child() directly to ACPI_HANDLE_SET()
    introduce a helper routine acpi_preset_companion() doing an
    equivalent thing.
    
    The main motivation for doing this is that there are things
    represented by struct acpi_device objects that don't have valid
    ACPI handles (so called fixed ACPI hardware features, such as
    power and sleep buttons) and we would like to create platform
    device objects for them and "glue" them to their ACPI companions
    in the usual way (which currently is impossible due to the
    lack of valid ACPI handles).  However, there are more reasons
    why it may be useful.
    
    First, struct acpi_device pointers allow of much better type checking
    than void pointers which are ACPI handles, so it should be more
    difficult to write buggy code using modified struct acpi_dev_node
    and the new macros.  Second, the change should help to reduce (over
    time) the number of places in which the result of ACPI_HANDLE() is
    passed to acpi_bus_get_device() in order to obtain a pointer to the
    struct acpi_device associated with the given "physical" device,
    because now that pointer is returned by ACPI_COMPANION() directly.
    Finally, the change should make it easier to write generic code that
    will build both for CONFIG_ACPI set and unset without adding explicit
    compiler directives to it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com> # on Haswell
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Aaron Lu <aaron.lu@intel.com> # for ATA and SDIO part

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 927998aa5e71..a968d8549ee5 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1144,7 +1144,7 @@ static acpi_status acpi_spi_add_device(acpi_handle handle, u32 level,
 		return AE_NO_MEMORY;
 	}
 
-	ACPI_HANDLE_SET(&spi->dev, handle);
+	ACPI_COMPANION_SET(&spi->dev, adev);
 	spi->irq = -1;
 
 	INIT_LIST_HEAD(&resource_list);

commit f9300eaaac1ca300083ad41937923a90cc3a2394
Merge: 7f2dc5c4bcbf faddf2f5d278
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 14 13:41:48 2013 +0900

    Merge tag 'pm+acpi-3.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael J Wysocki:
    
     - New power capping framework and the the Intel Running Average Power
       Limit (RAPL) driver using it from Srinivas Pandruvada and Jacob Pan.
    
     - Addition of the in-kernel switching feature to the arm_big_little
       cpufreq driver from Viresh Kumar and Nicolas Pitre.
    
     - cpufreq support for iMac G5 from Aaro Koskinen.
    
     - Baytrail processors support for intel_pstate from Dirk Brandewie.
    
     - cpufreq support for Midway/ECX-2000 from Mark Langsdorf.
    
     - ARM vexpress/TC2 cpufreq support from Sudeep KarkadaNagesha.
    
     - ACPI power management support for the I2C and SPI bus types from Mika
       Westerberg and Lv Zheng.
    
     - cpufreq core fixes and cleanups from Viresh Kumar, Srivatsa S Bhat,
       Stratos Karafotis, Xiaoguang Chen, Lan Tianyu.
    
     - cpufreq drivers updates (mostly fixes and cleanups) from Viresh
       Kumar, Aaro Koskinen, Jungseok Lee, Sudeep KarkadaNagesha, Lukasz
       Majewski, Manish Badarkhe, Hans-Christian Egtvedt, Evgeny Kapaev.
    
     - intel_pstate updates from Dirk Brandewie and Adrian Huang.
    
     - ACPICA update to version 20130927 includig fixes and cleanups and
       some reduction of divergences between the ACPICA code in the kernel
       and ACPICA upstream in order to improve the automatic ACPICA patch
       generation process.  From Bob Moore, Lv Zheng, Tomasz Nowicki, Naresh
       Bhat, Bjorn Helgaas, David E Box.
    
     - ACPI IPMI driver fixes and cleanups from Lv Zheng.
    
     - ACPI hotplug fixes and cleanups from Bjorn Helgaas, Toshi Kani, Zhang
       Yanfei, Rafael J Wysocki.
    
     - Conversion of the ACPI AC driver to the platform bus type and
       multiple driver fixes and cleanups related to ACPI from Zhang Rui.
    
     - ACPI processor driver fixes and cleanups from Hanjun Guo, Jiang Liu,
       Bartlomiej Zolnierkiewicz, Mathieu RhÃ©aume, Rafael J Wysocki.
    
     - Fixes and cleanups and new blacklist entries related to the ACPI
       video support from Aaron Lu, Felipe Contreras, Lennart Poettering,
       Kirill Tkhai.
    
     - cpuidle core cleanups from Viresh Kumar and Lorenzo Pieralisi.
    
     - cpuidle drivers fixes and cleanups from Daniel Lezcano, Jingoo Han,
       Bartlomiej Zolnierkiewicz, Prarit Bhargava.
    
     - devfreq updates from Sachin Kamat, Dan Carpenter, Manish Badarkhe.
    
     - Operation Performance Points (OPP) core updates from Nishanth Menon.
    
     - Runtime power management core fix from Rafael J Wysocki and update
       from Ulf Hansson.
    
     - Hibernation fixes from Aaron Lu and Rafael J Wysocki.
    
     - Device suspend/resume lockup detection mechanism from Benoit Goby.
    
     - Removal of unused proc directories created for various ACPI drivers
       from Lan Tianyu.
    
     - ACPI LPSS driver fix and new device IDs for the ACPI platform scan
       handler from Heikki Krogerus and Jarkko Nikula.
    
     - New ACPI _OSI blacklist entry for Toshiba NB100 from Levente Kurusa.
    
     - Assorted fixes and cleanups related to ACPI from Andy Shevchenko, Al
       Stone, Bartlomiej Zolnierkiewicz, Colin Ian King, Dan Carpenter,
       Felipe Contreras, Jianguo Wu, Lan Tianyu, Yinghai Lu, Mathias Krause,
       Liu Chuansheng.
    
     - Assorted PM fixes and cleanups from Andy Shevchenko, Thierry Reding,
       Jean-Christophe Plagniol-Villard.
    
    * tag 'pm+acpi-3.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (386 commits)
      cpufreq: conservative: fix requested_freq reduction issue
      ACPI / hotplug: Consolidate deferred execution of ACPI hotplug routines
      PM / runtime: Use pm_runtime_put_sync() in __device_release_driver()
      ACPI / event: remove unneeded NULL pointer check
      Revert "ACPI / video: Ignore BIOS initial backlight value for HP 250 G1"
      ACPI / video: Quirk initial backlight level 0
      ACPI / video: Fix initial level validity test
      intel_pstate: skip the driver if ACPI has power mgmt option
      PM / hibernate: Avoid overflow in hibernate_preallocate_memory()
      ACPI / hotplug: Do not execute "insert in progress" _OST
      ACPI / hotplug: Carry out PCI root eject directly
      ACPI / hotplug: Merge device hot-removal routines
      ACPI / hotplug: Make acpi_bus_hot_remove_device() internal
      ACPI / hotplug: Simplify device ejection routines
      ACPI / hotplug: Fix handle_root_bridge_removal()
      ACPI / hotplug: Refuse to hot-remove all objects with disabled hotplug
      ACPI / scan: Start matching drivers after trying scan handlers
      ACPI: Remove acpi_pci_slot_init() headers from internal.h
      ACPI / blacklist: fix name of ThinkPad Edge E530
      PowerCap: Fix build error with option -Werror=format-security
      ...
    
    Conflicts:
            arch/arm/mach-omap2/opp.c
            drivers/Kconfig
            drivers/spi/spi.c

commit 8211e6b8facd9d0da3e8f6e51657cba8b0af19da
Merge: c25b2c9eb365 0732a9d2a155
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Oct 25 09:51:29 2013 +0100

    Merge remote-tracking branch 'spi/topic/loop' into spi-next

commit 8f737d6185e010769f144418edb3d10fca05b2ba
Merge: d42b70f5c733 5fe5f05e2202
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Oct 25 09:51:25 2013 +0100

    Merge remote-tracking branch 'spi/topic/core' into spi-next

commit 52d85ebb7b639448e596a8577bf981f5b139f4fd
Merge: 2ef2e60d2f4d db9371b853e7
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Oct 25 09:51:21 2013 +0100

    Merge remote-tracking branch 'spi/topic/bfin' into spi-next

commit 5fe5f05e2202414a8b9015e9aedf19e08f6fe832
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Mon Oct 14 10:31:51 2013 +0900

    spi: Fix checkpatch issue
    
    Fix the following checkpatch error and warnings.
    
      ERROR: space required after that ',' (ctx:VxV)
      WARNING: quoted string split across lines
      WARNING: max() should probably be max_t(int, nb, master->num_chipselect)
      WARNING: sizeof *spi should be sizeof(*spi)
      WARNING: sizeof *master should be sizeof(*master)
      WARNING: sizeof x should be sizeof(x)
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 7f8057f3433a..956b26c2b737 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -325,7 +325,7 @@ struct spi_device *spi_alloc_device(struct spi_master *master)
 	if (!spi_master_get(master))
 		return NULL;
 
-	spi = kzalloc(sizeof *spi, GFP_KERNEL);
+	spi = kzalloc(sizeof(*spi), GFP_KERNEL);
 	if (!spi) {
 		dev_err(dev, "cannot alloc spi_device\n");
 		spi_master_put(master);
@@ -1093,7 +1093,7 @@ struct spi_master *spi_alloc_master(struct device *dev, unsigned size)
 	if (!dev)
 		return NULL;
 
-	master = kzalloc(size + sizeof *master, GFP_KERNEL);
+	master = kzalloc(size + sizeof(*master), GFP_KERNEL);
 	if (!master)
 		return NULL;
 
@@ -1118,7 +1118,7 @@ static int of_spi_register_master(struct spi_master *master)
 		return 0;
 
 	nb = of_gpio_named_count(np, "cs-gpios");
-	master->num_chipselect = max(nb, (int)master->num_chipselect);
+	master->num_chipselect = max_t(int, nb, master->num_chipselect);
 
 	/* Return error only for an incorrectly formed cs-gpios property */
 	if (nb == 0 || nb == -ENOENT)
@@ -1398,8 +1398,7 @@ int spi_setup(struct spi_device *spi)
 	if (spi->master->setup)
 		status = spi->master->setup(spi);
 
-	dev_dbg(&spi->dev, "setup mode %d, %s%s%s%s"
-				"%u bits/w, %u Hz max --> %d\n",
+	dev_dbg(&spi->dev, "setup mode %d, %s%s%s%s%u bits/w, %u Hz max --> %d\n",
 			(int) (spi->mode & (SPI_CPOL | SPI_CPHA)),
 			(spi->mode & SPI_CS_HIGH) ? "cs_high, " : "",
 			(spi->mode & SPI_LSB_FIRST) ? "lsb, " : "",
@@ -1758,7 +1757,7 @@ int spi_bus_unlock(struct spi_master *master)
 EXPORT_SYMBOL_GPL(spi_bus_unlock);
 
 /* portable code must never pass more than 32 bytes */
-#define	SPI_BUFSIZ	max(32,SMP_CACHE_BYTES)
+#define	SPI_BUFSIZ	max(32, SMP_CACHE_BYTES)
 
 static u8	*buf;
 
@@ -1807,7 +1806,7 @@ int spi_write_then_read(struct spi_device *spi,
 	}
 
 	spi_message_init(&message);
-	memset(x, 0, sizeof x);
+	memset(x, 0, sizeof(x));
 	if (n_tx) {
 		x[0].len = n_tx;
 		spi_message_add_tail(&x[0], &message);

commit 2cc6e2e0c8157b9e6ed8dbe5c7284865f6afbd46
Merge: b158935f70b9 ebd805cc14be
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Oct 11 20:10:13 2013 +0100

    Merge remote-tracking branch 'spi/topic/s3c64xx' into spi-loop

commit b158935f70b9c156903338053216dd0adf7ce31c
Author: Mark Brown <broonie@linaro.org>
Date:   Sat Oct 5 11:50:40 2013 +0100

    spi: Provide common spi_message processing loop
    
    The loops which SPI controller drivers use to process the list of transfers
    in a spi_message are typically very similar and have some error prone areas
    such as the handling of /CS. Help simplify drivers by factoring this code
    out into the core - if drivers provide a transfer_one() function instead
    of a transfer_one_message() function the core will handle processing at the
    message level.
    
    /CS can be controlled by either setting cs_gpio or providing a set_cs
    function. If this is not possible for hardware reasons then both can be
    omitted and the driver should continue to implement manual /CS handling.
    
    This is a first step in refactoring and it is expected that there will be
    further enhancements, for example factoring out of the mapping of transfers
    for DMA and the initiation and completion of interrupt driven transfers.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 8a30c6b66a64..85c18d8a86b3 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -526,6 +526,95 @@ int spi_register_board_info(struct spi_board_info const *info, unsigned n)
 
 /*-------------------------------------------------------------------------*/
 
+static void spi_set_cs(struct spi_device *spi, bool enable)
+{
+	if (spi->mode & SPI_CS_HIGH)
+		enable = !enable;
+
+	if (spi->cs_gpio >= 0)
+		gpio_set_value(spi->cs_gpio, !enable);
+	else if (spi->master->set_cs)
+		spi->master->set_cs(spi, !enable);
+}
+
+/*
+ * spi_transfer_one_message - Default implementation of transfer_one_message()
+ *
+ * This is a standard implementation of transfer_one_message() for
+ * drivers which impelment a transfer_one() operation.  It provides
+ * standard handling of delays and chip select management.
+ */
+static int spi_transfer_one_message(struct spi_master *master,
+				    struct spi_message *msg)
+{
+	struct spi_transfer *xfer;
+	bool cur_cs = true;
+	bool keep_cs = false;
+	int ret = 0;
+
+	spi_set_cs(msg->spi, true);
+
+	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		trace_spi_transfer_start(msg, xfer);
+
+		INIT_COMPLETION(master->xfer_completion);
+
+		ret = master->transfer_one(master, msg->spi, xfer);
+		if (ret < 0) {
+			dev_err(&msg->spi->dev,
+				"SPI transfer failed: %d\n", ret);
+			goto out;
+		}
+
+		if (ret > 0)
+			wait_for_completion(&master->xfer_completion);
+
+		trace_spi_transfer_stop(msg, xfer);
+
+		if (msg->status != -EINPROGRESS)
+			goto out;
+
+		if (xfer->delay_usecs)
+			udelay(xfer->delay_usecs);
+
+		if (xfer->cs_change) {
+			if (list_is_last(&xfer->transfer_list,
+					 &msg->transfers)) {
+				keep_cs = true;
+			} else {
+				cur_cs = !cur_cs;
+				spi_set_cs(msg->spi, cur_cs);
+			}
+		}
+
+		msg->actual_length += xfer->len;
+	}
+
+out:
+	if (ret != 0 || !keep_cs)
+		spi_set_cs(msg->spi, false);
+
+	if (msg->status == -EINPROGRESS)
+		msg->status = ret;
+
+	spi_finalize_current_message(master);
+
+	return ret;
+}
+
+/**
+ * spi_finalize_current_transfer - report completion of a transfer
+ *
+ * Called by SPI drivers using the core transfer_one_message()
+ * implementation to notify it that the current interrupt driven
+ * transfer has finised and the next one may be scheduled.
+ */
+void spi_finalize_current_transfer(struct spi_master *master)
+{
+	complete(&master->xfer_completion);
+}
+EXPORT_SYMBOL_GPL(spi_finalize_current_transfer);
+
 /**
  * spi_pump_messages - kthread work function which processes spi message queue
  * @work: pointer to kthread work struct contained in the master struct
@@ -836,6 +925,8 @@ static int spi_master_initialize_queue(struct spi_master *master)
 
 	master->queued = true;
 	master->transfer = spi_queued_transfer;
+	if (!master->transfer_one_message)
+		master->transfer_one_message = spi_transfer_one_message;
 
 	/* Initialize and start queue */
 	ret = spi_init_queue(master);
@@ -1242,6 +1333,7 @@ int spi_register_master(struct spi_master *master)
 	spin_lock_init(&master->bus_lock_spinlock);
 	mutex_init(&master->bus_lock_mutex);
 	master->bus_lock_flag = 0;
+	init_completion(&master->xfer_completion);
 
 	/* register the device, then userspace will see it.
 	 * registration fails if the bus ID is in use.

commit 2841a5fc375e9c573d10b82db30fa8a4cc25301c
Author: Mark Brown <broonie@linaro.org>
Date:   Sat Oct 5 00:23:12 2013 +0100

    spi: Provide per-message prepare and unprepare operations
    
    Many SPI drivers perform setup and tear down on every message, usually
    doing things like DMA mapping the message. Provide hooks for them to use
    to provide such operations.
    
    This is of limited value for drivers that implement transfer_one_message()
    but will be of much greater utility with future factoring out of standard
    implementations of that function.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 8bef0c9a7233..8a30c6b66a64 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -606,6 +606,18 @@ static void spi_pump_messages(struct kthread_work *work)
 
 	trace_spi_message_start(master->cur_msg);
 
+	if (master->prepare_message) {
+		ret = master->prepare_message(master, master->cur_msg);
+		if (ret) {
+			dev_err(&master->dev,
+				"failed to prepare message: %d\n", ret);
+			master->cur_msg->status = ret;
+			spi_finalize_current_message(master);
+			return;
+		}
+		master->cur_msg_prepared = true;
+	}
+
 	ret = master->transfer_one_message(master, master->cur_msg);
 	if (ret) {
 		dev_err(&master->dev,
@@ -687,6 +699,7 @@ void spi_finalize_current_message(struct spi_master *master)
 {
 	struct spi_message *mesg;
 	unsigned long flags;
+	int ret;
 
 	spin_lock_irqsave(&master->queue_lock, flags);
 	mesg = master->cur_msg;
@@ -695,6 +708,15 @@ void spi_finalize_current_message(struct spi_master *master)
 	queue_kthread_work(&master->kworker, &master->pump_messages);
 	spin_unlock_irqrestore(&master->queue_lock, flags);
 
+	if (master->cur_msg_prepared && master->unprepare_message) {
+		ret = master->unprepare_message(master, mesg);
+		if (ret) {
+			dev_err(&master->dev,
+				"failed to unprepare message: %d\n", ret);
+		}
+	}
+	master->cur_msg_prepared = false;
+
 	mesg->state = NULL;
 	if (mesg->complete)
 		mesg->complete(mesg->context);

commit 33cf00e5708290f7e57d949219ef443a2aef34e0
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Oct 10 13:28:48 2013 +0300

    spi: attach/detach SPI device to the ACPI power domain
    
    If the SPI device is enumerated from ACPI namespace (it has an ACPI handle)
    it might have ACPI methods that needs to be called in order to transition
    the device to different power states (such as _PSx).
    
    We follow what has been done for platform and I2C buses here and attach the
    SPI device to the ACPI power domain if the device has an ACPI handle. This
    makes sure that the device is powered on when its ->probe() is called.
    
    For non-ACPI devices this patch is a no-op.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Mark Brown <broonie@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 9e039c60c068..740f9ddda227 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -240,15 +240,27 @@ EXPORT_SYMBOL_GPL(spi_bus_type);
 static int spi_drv_probe(struct device *dev)
 {
 	const struct spi_driver		*sdrv = to_spi_driver(dev->driver);
+	struct spi_device		*spi = to_spi_device(dev);
+	int ret;
+
+	acpi_dev_pm_attach(&spi->dev, true);
+	ret = sdrv->probe(spi);
+	if (ret)
+		acpi_dev_pm_detach(&spi->dev, true);
 
-	return sdrv->probe(to_spi_device(dev));
+	return ret;
 }
 
 static int spi_drv_remove(struct device *dev)
 {
 	const struct spi_driver		*sdrv = to_spi_driver(dev->driver);
+	struct spi_device		*spi = to_spi_device(dev);
+	int ret;
+
+	ret = sdrv->remove(spi);
+	acpi_dev_pm_detach(&spi->dev, true);
 
-	return sdrv->remove(to_spi_device(dev));
+	return ret;
 }
 
 static void spi_drv_shutdown(struct device *dev)
@@ -1025,8 +1037,10 @@ static acpi_status acpi_spi_add_device(acpi_handle handle, u32 level,
 		return AE_OK;
 	}
 
+	adev->power.flags.ignore_parent = true;
 	strlcpy(spi->modalias, dev_name(&adev->dev), sizeof(spi->modalias));
 	if (spi_add_device(spi)) {
+		adev->power.flags.ignore_parent = false;
 		dev_err(&master->dev, "failed to add SPI device %s from ACPI\n",
 			dev_name(&adev->dev));
 		spi_dev_put(spi);

commit cf9eb39c6f7b42fdf9aa6f1af28780b2522a847a
Author: Jarkko Nikula <jarkko.nikula@linux.intel.com>
Date:   Thu Oct 10 17:19:17 2013 +0300

    spi: Fix modalias for ACPI enumerated SPI devices
    
    There is a minor fault about ACPI enumerated SPI devices with their modalias
    attribute. Now modalias is set by device instance not by hardware ID.
    For example "spi:INTABCD:00", "spi:INTABCD:01" etc.
    
    This means each device instance gets different modalias which does match
    with generated modules.alias. Currently this is not problem as matching can
    happen also with "acpi:INTABCD" modalias.
    
    Fix this by using ACPI hardware ID.
    
    Signed-off-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 9e039c60c068..e57e9acd75cb 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1025,7 +1025,7 @@ static acpi_status acpi_spi_add_device(acpi_handle handle, u32 level,
 		return AE_OK;
 	}
 
-	strlcpy(spi->modalias, dev_name(&adev->dev), sizeof(spi->modalias));
+	strlcpy(spi->modalias, acpi_device_hid(adev), sizeof(spi->modalias));
 	if (spi_add_device(spi)) {
 		dev_err(&master->dev, "failed to add SPI device %s from ACPI\n",
 			dev_name(&adev->dev));

commit aa7da564cab718d04c77e3a3c73926473e7a94f7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Oct 7 18:27:38 2013 -0700

    spi: convert bus code to use dev_groups
    
    The dev_attrs field of struct bus_type is going away soon, dev_groups
    should be used instead.  This converts the spi bus code to use the
    correct field.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 1cd491f79422..7f8057f3433a 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -58,11 +58,13 @@ modalias_show(struct device *dev, struct device_attribute *a, char *buf)
 
 	return sprintf(buf, "%s%s\n", SPI_MODULE_PREFIX, spi->modalias);
 }
+static DEVICE_ATTR_RO(modalias);
 
-static struct device_attribute spi_dev_attrs[] = {
-	__ATTR_RO(modalias),
-	__ATTR_NULL,
+static struct attribute *spi_dev_attrs[] = {
+	&dev_attr_modalias.attr,
+	NULL,
 };
+ATTRIBUTE_GROUPS(spi_dev);
 
 /* modalias support makes "modprobe $MODALIAS" new-style hotplug work,
  * and the sysfs version makes coldplug work too.
@@ -229,7 +231,7 @@ static const struct dev_pm_ops spi_pm = {
 
 struct bus_type spi_bus_type = {
 	.name		= "spi",
-	.dev_attrs	= spi_dev_attrs,
+	.dev_groups	= spi_dev_groups,
 	.match		= spi_match_device,
 	.uevent		= spi_uevent,
 	.pm		= &spi_pm,

commit 56ec1978ff07380bbdc0a942c8779ec9fd9e02ee
Author: Mark Brown <broonie@linaro.org>
Date:   Mon Oct 7 19:33:53 2013 +0100

    spi: Provide trace points for message processing
    
    Provide tracepoints for the lifecycle of a message from submission to
    completion and for the active time for masters to help with performance
    analysis of SPI I/O.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 9e039c60c068..8bef0c9a7233 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -39,6 +39,9 @@
 #include <linux/ioport.h>
 #include <linux/acpi.h>
 
+#define CREATE_TRACE_POINTS
+#include <trace/events/spi.h>
+
 static void spidev_release(struct device *dev)
 {
 	struct spi_device	*spi = to_spi_device(dev);
@@ -557,6 +560,7 @@ static void spi_pump_messages(struct kthread_work *work)
 			pm_runtime_mark_last_busy(master->dev.parent);
 			pm_runtime_put_autosuspend(master->dev.parent);
 		}
+		trace_spi_master_idle(master);
 		return;
 	}
 
@@ -585,6 +589,9 @@ static void spi_pump_messages(struct kthread_work *work)
 		}
 	}
 
+	if (!was_busy)
+		trace_spi_master_busy(master);
+
 	if (!was_busy && master->prepare_transfer_hardware) {
 		ret = master->prepare_transfer_hardware(master);
 		if (ret) {
@@ -597,6 +604,8 @@ static void spi_pump_messages(struct kthread_work *work)
 		}
 	}
 
+	trace_spi_message_start(master->cur_msg);
+
 	ret = master->transfer_one_message(master, master->cur_msg);
 	if (ret) {
 		dev_err(&master->dev,
@@ -689,6 +698,8 @@ void spi_finalize_current_message(struct spi_master *master)
 	mesg->state = NULL;
 	if (mesg->complete)
 		mesg->complete(mesg->context);
+
+	trace_spi_message_done(mesg);
 }
 EXPORT_SYMBOL_GPL(spi_finalize_current_message);
 
@@ -1421,6 +1432,10 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
 	struct spi_master *master = spi->master;
 	struct spi_transfer *xfer;
 
+	message->spi = spi;
+
+	trace_spi_message_submit(message);
+
 	if (list_empty(&message->transfers))
 		return -EINVAL;
 	if (!message->complete)
@@ -1520,7 +1535,6 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
 		}
 	}
 
-	message->spi = spi;
 	message->status = -EINPROGRESS;
 	return master->transfer(spi, message);
 }

commit 89da4293a7bb29ac42b7dd2c2573c8a5ebb0b6c7
Author: Trent Piepho <tpiepho@gmail.com>
Date:   Fri Sep 27 05:37:25 2013 -0700

    spi: Use of_property_read_u32
    
    Instead of getting the raw property, checking the length, and doing
    endian conversion each time, use the OF function
    of_property_read_u32() that does all that.
    
    Error messages are slightly improved with error codes from
    of_property_read_u32() for different ways the property may be invalid
    (missing, too short, etc.)
    
    Signed-off-by: Trent Piepho <tpiepho@gmail.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 74a526ce8c04..1cd491f79422 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -838,9 +838,8 @@ static void of_register_spi_devices(struct spi_master *master)
 {
 	struct spi_device *spi;
 	struct device_node *nc;
-	const __be32 *prop;
 	int rc;
-	int len;
+	u32 value;
 
 	if (!master->dev.of_node)
 		return;
@@ -865,14 +864,14 @@ static void of_register_spi_devices(struct spi_master *master)
 		}
 
 		/* Device address */
-		prop = of_get_property(nc, "reg", &len);
-		if (!prop || len < sizeof(*prop)) {
-			dev_err(&master->dev, "%s has no 'reg' property\n",
-				nc->full_name);
+		rc = of_property_read_u32(nc, "reg", &value);
+		if (rc) {
+			dev_err(&master->dev, "%s has no valid 'reg' property (%d)\n",
+				nc->full_name, rc);
 			spi_dev_put(spi);
 			continue;
 		}
-		spi->chip_select = be32_to_cpup(prop);
+		spi->chip_select = value;
 
 		/* Mode (clock phase/polarity/etc.) */
 		if (of_find_property(nc, "spi-cpha", NULL))
@@ -885,55 +884,53 @@ static void of_register_spi_devices(struct spi_master *master)
 			spi->mode |= SPI_3WIRE;
 
 		/* Device DUAL/QUAD mode */
-		prop = of_get_property(nc, "spi-tx-bus-width", &len);
-		if (prop && len == sizeof(*prop)) {
-			switch (be32_to_cpup(prop)) {
-			case SPI_NBITS_SINGLE:
+		if (!of_property_read_u32(nc, "spi-tx-bus-width", &value)) {
+			switch (value) {
+			case 1:
 				break;
-			case SPI_NBITS_DUAL:
+			case 2:
 				spi->mode |= SPI_TX_DUAL;
 				break;
-			case SPI_NBITS_QUAD:
+			case 4:
 				spi->mode |= SPI_TX_QUAD;
 				break;
 			default:
 				dev_err(&master->dev,
 					"spi-tx-bus-width %d not supported\n",
-					be32_to_cpup(prop));
+					value);
 				spi_dev_put(spi);
 				continue;
 			}
 		}
 
-		prop = of_get_property(nc, "spi-rx-bus-width", &len);
-		if (prop && len == sizeof(*prop)) {
-			switch (be32_to_cpup(prop)) {
-			case SPI_NBITS_SINGLE:
+		if (!of_property_read_u32(nc, "spi-rx-bus-width", &value)) {
+			switch (value) {
+			case 1:
 				break;
-			case SPI_NBITS_DUAL:
+			case 2:
 				spi->mode |= SPI_RX_DUAL;
 				break;
-			case SPI_NBITS_QUAD:
+			case 4:
 				spi->mode |= SPI_RX_QUAD;
 				break;
 			default:
 				dev_err(&master->dev,
 					"spi-rx-bus-width %d not supported\n",
-					be32_to_cpup(prop));
+					value);
 				spi_dev_put(spi);
 				continue;
 			}
 		}
 
 		/* Device speed */
-		prop = of_get_property(nc, "spi-max-frequency", &len);
-		if (!prop || len < sizeof(*prop)) {
-			dev_err(&master->dev, "%s has no 'spi-max-frequency' property\n",
-				nc->full_name);
+		rc = of_property_read_u32(nc, "spi-max-frequency", &value);
+		if (rc) {
+			dev_err(&master->dev, "%s has no valid 'spi-max-frequency' property (%d)\n",
+				nc->full_name, rc);
 			spi_dev_put(spi);
 			continue;
 		}
-		spi->max_speed_hz = be32_to_cpup(prop);
+		spi->max_speed_hz = value;
 
 		/* IRQ */
 		spi->irq = irq_of_parse_and_map(nc, 0);

commit 70fac17cec347c4013cb8f380c6fe6554a13d884
Author: Mathias Krause <minipli@googlemail.com>
Date:   Sat Aug 31 20:24:14 2013 +0200

    spi: simplify call to request_module()
    
    request_module() can handle format strings on its own, no need to create
    the full module name ourself.
    
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 9e039c60c068..74a526ce8c04 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -839,7 +839,6 @@ static void of_register_spi_devices(struct spi_master *master)
 	struct spi_device *spi;
 	struct device_node *nc;
 	const __be32 *prop;
-	char modalias[SPI_NAME_SIZE + 4];
 	int rc;
 	int len;
 
@@ -944,9 +943,7 @@ static void of_register_spi_devices(struct spi_master *master)
 		spi->dev.of_node = nc;
 
 		/* Register the new device */
-		snprintf(modalias, sizeof(modalias), "%s%s", SPI_MODULE_PREFIX,
-			 spi->modalias);
-		request_module(modalias);
+		request_module("%s%s", SPI_MODULE_PREFIX, spi->modalias);
 		rc = spi_add_device(spi);
 		if (rc) {
 			dev_err(&master->dev, "spi_device register error %s\n",

commit 666d5b4c742ba666eb68b467d777b7862f362ae5
Author: Mark Brown <broonie@linaro.org>
Date:   Sat Aug 31 18:50:52 2013 +0100

    spi: core: Add devm_spi_register_master()
    
    Help simplify the cleanup code for SPI master drivers by providing a
    managed master registration function, ensuring that the master is
    automatically unregistered whenever the device is unbound.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 9e039c60c068..a586ceb111fc 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1245,6 +1245,41 @@ int spi_register_master(struct spi_master *master)
 }
 EXPORT_SYMBOL_GPL(spi_register_master);
 
+static void devm_spi_unregister(struct device *dev, void *res)
+{
+	spi_unregister_master(*(struct spi_master **)res);
+}
+
+/**
+ * dev_spi_register_master - register managed SPI master controller
+ * @dev:    device managing SPI master
+ * @master: initialized master, originally from spi_alloc_master()
+ * Context: can sleep
+ *
+ * Register a SPI device as with spi_register_master() which will
+ * automatically be unregister
+ */
+int devm_spi_register_master(struct device *dev, struct spi_master *master)
+{
+	struct spi_master **ptr;
+	int ret;
+
+	ptr = devres_alloc(devm_spi_unregister, sizeof(*ptr), GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+
+	ret = spi_register_master(master);
+	if (ret != 0) {
+		*ptr = master;
+		devres_add(dev, ptr);
+	} else {
+		devres_free(ptr);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(devm_spi_register_master);
+
 static int __unregister(struct device *dev, void *null)
 {
 	spi_unregister_device(to_spi_device(dev));

commit 278ac33bbd8b3ff70f9518665c892c1b6f5625b7
Merge: 85cac431329b a110f93d8b46
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Sep 1 13:49:07 2013 +0100

    Merge remote-tracking branch 'spi/topic/quad' into spi-next

commit 85cac431329bd09f7d30d489591d7af0d658b008
Merge: 793b3cb6acc0 b6460366fbad
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Sep 1 13:49:06 2013 +0100

    Merge remote-tracking branch 'spi/topic/qspi' into spi-next

commit 9020b75467ff81b2ae257bbf19acff462854d4ab
Merge: 84c86edab3a3 078726ce6d56
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Sep 1 13:48:58 2013 +0100

    Merge remote-tracking branch 'spi/topic/msglen' into spi-next

commit 7e718b4bd2ea78702b0f00c668ba99ccfa987181
Merge: 1f54f94284c3 e93b07244d6e
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Sep 1 13:48:50 2013 +0100

    Merge remote-tracking branch 'spi/topic/core' into spi-next

commit a110f93d8b4672c4ad18d911f62b9e861010e83b
Author: wangyuhang <wangyuhang2014@gmail.com>
Date:   Sun Sep 1 17:36:21 2013 +0800

    spi: quad: fix the name of DT property
    
    spi: quad: fix the name of DT property in patch
    
    The previous property name spi-tx-nbits and spi-rx-nbits looks not
    human-readable. To make it consistent with other devices, using property
    name spi-tx-bus-width and spi-rx-bus-width instead of the previous one
    specify the number of data wires that spi controller will work in.
    Add the specification in spi-bus.txt.
    
    Signed-off-by: wangyuhang <wangyuhang2014@gmail.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 7557f611457f..0075318f4fa1 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -870,7 +870,7 @@ static void of_register_spi_devices(struct spi_master *master)
 			spi->mode |= SPI_3WIRE;
 
 		/* Device DUAL/QUAD mode */
-		prop = of_get_property(nc, "spi-tx-nbits", &len);
+		prop = of_get_property(nc, "spi-tx-bus-width", &len);
 		if (prop && len == sizeof(*prop)) {
 			switch (be32_to_cpup(prop)) {
 			case SPI_NBITS_SINGLE:
@@ -883,14 +883,14 @@ static void of_register_spi_devices(struct spi_master *master)
 				break;
 			default:
 				dev_err(&master->dev,
-					"spi-tx-nbits %d not supported\n",
+					"spi-tx-bus-width %d not supported\n",
 					be32_to_cpup(prop));
 				spi_dev_put(spi);
 				continue;
 			}
 		}
 
-		prop = of_get_property(nc, "spi-rx-nbits", &len);
+		prop = of_get_property(nc, "spi-rx-bus-width", &len);
 		if (prop && len == sizeof(*prop)) {
 			switch (be32_to_cpup(prop)) {
 			case SPI_NBITS_SINGLE:
@@ -903,7 +903,7 @@ static void of_register_spi_devices(struct spi_master *master)
 				break;
 			default:
 				dev_err(&master->dev,
-					"spi-rx-nbits %d not supported\n",
+					"spi-rx-bus-width %d not supported\n",
 					be32_to_cpup(prop));
 				spi_dev_put(spi);
 				continue;

commit e93b07244d6e1d6105df78b6117b00c940006b45
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sat Aug 31 20:25:52 2013 +0800

    spi: core: Fix spi_register_master error handling
    
    In the case spi_master_initialize_queue() fails, current code calls
    device_unregister() before return error from spi_register_master().
    However, all the drivers call spi_master_put() in the error path if
    spi_register_master() fails. Thus we should call device_del() rather than
    device_unregister() before return error from spi_register_master().
    
    This also makes all the spi_register_master() error handling consistent,
    because all other error paths of spi_register_master() expect drivers to
    call spi_master_put() if spi_register_master() fails.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b1db83f1b4aa..f56017ea55e9 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1169,7 +1169,7 @@ int spi_register_master(struct spi_master *master)
 	else {
 		status = spi_master_initialize_queue(master);
 		if (status) {
-			device_unregister(&master->dev);
+			device_del(&master->dev);
 			goto done;
 		}
 	}

commit a822e99c70f448c4068ea85bb195dac0b2eb3afe
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Aug 30 23:19:40 2013 +0100

    spi: quad: Make DT properties optional
    
    The addition SPI quad support made the DT properties mandatory, breaking
    compatibility with existing systems. Fix that by making them optional,
    also improving the error messages while we're at it.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Tested-by: Stephen Warren <swarren@nvidia.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index f0a6582061d5..7557f611457f 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -871,47 +871,43 @@ static void of_register_spi_devices(struct spi_master *master)
 
 		/* Device DUAL/QUAD mode */
 		prop = of_get_property(nc, "spi-tx-nbits", &len);
-		if (!prop || len < sizeof(*prop)) {
-			dev_err(&master->dev, "%s has no 'spi-tx-nbits' property\n",
-				nc->full_name);
-			spi_dev_put(spi);
-			continue;
-		}
-		switch (be32_to_cpup(prop)) {
-		case SPI_NBITS_SINGLE:
-			break;
-		case SPI_NBITS_DUAL:
-			spi->mode |= SPI_TX_DUAL;
-			break;
-		case SPI_NBITS_QUAD:
-			spi->mode |= SPI_TX_QUAD;
-			break;
-		default:
-			dev_err(&master->dev, "spi-tx-nbits value is not supported\n");
-			spi_dev_put(spi);
-			continue;
+		if (prop && len == sizeof(*prop)) {
+			switch (be32_to_cpup(prop)) {
+			case SPI_NBITS_SINGLE:
+				break;
+			case SPI_NBITS_DUAL:
+				spi->mode |= SPI_TX_DUAL;
+				break;
+			case SPI_NBITS_QUAD:
+				spi->mode |= SPI_TX_QUAD;
+				break;
+			default:
+				dev_err(&master->dev,
+					"spi-tx-nbits %d not supported\n",
+					be32_to_cpup(prop));
+				spi_dev_put(spi);
+				continue;
+			}
 		}
 
 		prop = of_get_property(nc, "spi-rx-nbits", &len);
-		if (!prop || len < sizeof(*prop)) {
-			dev_err(&master->dev, "%s has no 'spi-rx-nbits' property\n",
-				nc->full_name);
-			spi_dev_put(spi);
-			continue;
-		}
-		switch (be32_to_cpup(prop)) {
-		case SPI_NBITS_SINGLE:
-			break;
-		case SPI_NBITS_DUAL:
-			spi->mode |= SPI_RX_DUAL;
-			break;
-		case SPI_NBITS_QUAD:
-			spi->mode |= SPI_RX_QUAD;
-			break;
-		default:
-			dev_err(&master->dev, "spi-rx-nbits value is not supported\n");
-			spi_dev_put(spi);
-			continue;
+		if (prop && len == sizeof(*prop)) {
+			switch (be32_to_cpup(prop)) {
+			case SPI_NBITS_SINGLE:
+				break;
+			case SPI_NBITS_DUAL:
+				spi->mode |= SPI_RX_DUAL;
+				break;
+			case SPI_NBITS_QUAD:
+				spi->mode |= SPI_RX_QUAD;
+				break;
+			default:
+				dev_err(&master->dev,
+					"spi-rx-nbits %d not supported\n",
+					be32_to_cpup(prop));
+				spi_dev_put(spi);
+				continue;
+			}
 		}
 
 		/* Device speed */

commit d5ee722ab942451929ccf5bec4fb41f6d044b5c7
Author: wangyuhang <wangyuhang2014@gmail.com>
Date:   Fri Aug 30 18:05:10 2013 +0800

    spi: quad: Fix missing return
    
    Delete a "return" when commit the patch to a new kernel version
     by mistake. So recover it.
    
    Signed-off-by: wangyuhang <wangyuhang2014@gmail.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 50f7fc3ed793..f0a6582061d5 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1463,6 +1463,7 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
 			return -EINVAL;
 		if (xfer->speed_hz && master->max_speed_hz &&
 		    xfer->speed_hz > master->max_speed_hz)
+			return -EINVAL;
 
 		if (xfer->tx_buf && !xfer->tx_nbits)
 			xfer->tx_nbits = SPI_NBITS_SINGLE;

commit 21e34a3306e7f0399cc0e10c24cb0e7790dfbcac
Merge: 505a14954e2d db90a44177ac
Author: Mark Brown <broonie@linaro.org>
Date:   Fri Aug 23 12:00:15 2013 +0100

    Merge remote-tracking branch 'spi/topic/quad' into spi-qspi

commit 96b3eace39d2ecfdb07003856ddd8f6973dfe7bb
Author: Axel Lin <axel.lin@ingics.com>
Date:   Thu Aug 22 23:41:34 2013 +0800

    spi: Remove a redundant test for master->running in spi_queued_transfer
    
    We have tested master->running immediately after grab the master->queue_lock.
    The status of master->running won't be changed until we release the lock.
    Thus remove a redundant test for master->running.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 978dda2c5239..b1db83f1b4aa 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -774,7 +774,7 @@ static int spi_queued_transfer(struct spi_device *spi, struct spi_message *msg)
 	msg->status = -EINPROGRESS;
 
 	list_add_tail(&msg->queue, &master->queue);
-	if (master->running && !master->busy)
+	if (!master->busy)
 		queue_kthread_work(&master->kworker, &master->pump_messages);
 
 	spin_unlock_irqrestore(&master->queue_lock, flags);

commit db90a44177ac39fc22b2da5235b231fccdd4c673
Author: Sourav Poddar <sourav.poddar@ti.com>
Date:   Thu Aug 22 21:20:48 2013 +0530

    spi: conditional checking of mode and transfer bits.
    
    There is a bug in the following patch:
    http://comments.gmane.org/gmane.linux.kernel.spi.devel/14420
    
    spi: DUAL and QUAD support
    
        fix the previous patch some mistake below:
        1. DT in slave node, use "spi-tx-nbits = <1/2/4>" in place of using
           "spi-tx-dual, spi-tx-quad" directly, same to rx. So correct the
           previous way to get the property in @of_register_spi_devices().
        2. Change the value of transfer bit macro(SPI_NBITS_SINGLE, SPI_NBITS_DUAL
           SPI_NBITS_QUAD) to 0x01, 0x02 and 0x04 to match the actual wires.
        3. Add the following check
           (1)keep the tx_nbits and rx_nbits in spi_transfer is not beyond the
              single, dual and quad.
           (2)keep tx_nbits and rx_nbits are contained by @spi_device->mode
              example: if @spi_device->mode = DUAL, then tx/rx_nbits can not be set
                       to QUAD(SPI_NBITS_QUAD)
           (3)if "@spi_device->mode & SPI_3WIRE", then tx/rx_nbits should be in
              single(SPI_NBITS_SINGLE)
    
    Checking of the tx/rx transfer bits and mode bits should be done conditionally
    based on type of buffer filled else EINVAL condition will
    always get hit either for rx or tx.
    
    Signed-off-by: Sourav Poddar <sourav.poddar@ti.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 39d38756e984..50f7fc3ed793 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1473,33 +1473,37 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
 		 * 2. keep tx/rx_nbits is contained by mode in spi_device
 		 * 3. if SPI_3WIRE, tx/rx_nbits should be in single
 		 */
-		if (xfer->tx_nbits != SPI_NBITS_SINGLE &&
-			xfer->tx_nbits != SPI_NBITS_DUAL &&
-			xfer->tx_nbits != SPI_NBITS_QUAD)
-			return -EINVAL;
-		if ((xfer->tx_nbits == SPI_NBITS_DUAL) &&
-			!(spi->mode & (SPI_TX_DUAL | SPI_TX_QUAD)))
-			return -EINVAL;
-		if ((xfer->tx_nbits == SPI_NBITS_QUAD) &&
-			!(spi->mode & SPI_TX_QUAD))
-			return -EINVAL;
-		if ((spi->mode & SPI_3WIRE) &&
-			(xfer->tx_nbits != SPI_NBITS_SINGLE))
-			return -EINVAL;
+		if (xfer->tx_buf) {
+			if (xfer->tx_nbits != SPI_NBITS_SINGLE &&
+				xfer->tx_nbits != SPI_NBITS_DUAL &&
+				xfer->tx_nbits != SPI_NBITS_QUAD)
+				return -EINVAL;
+			if ((xfer->tx_nbits == SPI_NBITS_DUAL) &&
+				!(spi->mode & (SPI_TX_DUAL | SPI_TX_QUAD)))
+				return -EINVAL;
+			if ((xfer->tx_nbits == SPI_NBITS_QUAD) &&
+				!(spi->mode & SPI_TX_QUAD))
+				return -EINVAL;
+			if ((spi->mode & SPI_3WIRE) &&
+				(xfer->tx_nbits != SPI_NBITS_SINGLE))
+				return -EINVAL;
+		}
 		/* check transfer rx_nbits */
-		if (xfer->rx_nbits != SPI_NBITS_SINGLE &&
-			xfer->rx_nbits != SPI_NBITS_DUAL &&
-			xfer->rx_nbits != SPI_NBITS_QUAD)
-			return -EINVAL;
-		if ((xfer->rx_nbits == SPI_NBITS_DUAL) &&
-			!(spi->mode & (SPI_RX_DUAL | SPI_RX_QUAD)))
-			return -EINVAL;
-		if ((xfer->rx_nbits == SPI_NBITS_QUAD) &&
-			!(spi->mode & SPI_RX_QUAD))
-			return -EINVAL;
-		if ((spi->mode & SPI_3WIRE) &&
-			(xfer->rx_nbits != SPI_NBITS_SINGLE))
-			return -EINVAL;
+		if (xfer->rx_buf) {
+			if (xfer->rx_nbits != SPI_NBITS_SINGLE &&
+				xfer->rx_nbits != SPI_NBITS_DUAL &&
+				xfer->rx_nbits != SPI_NBITS_QUAD)
+				return -EINVAL;
+			if ((xfer->rx_nbits == SPI_NBITS_DUAL) &&
+				!(spi->mode & (SPI_RX_DUAL | SPI_RX_QUAD)))
+				return -EINVAL;
+			if ((xfer->rx_nbits == SPI_NBITS_QUAD) &&
+				!(spi->mode & SPI_RX_QUAD))
+				return -EINVAL;
+			if ((spi->mode & SPI_3WIRE) &&
+				(xfer->rx_nbits != SPI_NBITS_SINGLE))
+				return -EINVAL;
+		}
 	}
 
 	message->spi = spi;

commit f477b7fb13df2b843997559ff34e87d054ba6538
Author: wangyuhang <wangyuhang2014@gmail.com>
Date:   Sun Aug 11 18:15:17 2013 +0800

    spi: DUAL and QUAD support
    
    fix the previous patch some mistake below:
    1. DT in slave node, use "spi-tx-nbits = <1/2/4>" in place of using
       "spi-tx-dual, spi-tx-quad" directly, same to rx. So correct the
       previous way to get the property in @of_register_spi_devices().
    2. Change the value of transfer bit macro(SPI_NBITS_SINGLE, SPI_NBITS_DUAL
       SPI_NBITS_QUAD) to 0x01, 0x02 and 0x04 to match the actual wires.
    3. Add the following check
       (1)keep the tx_nbits and rx_nbits in spi_transfer is not beyond the
          single, dual and quad.
       (2)keep tx_nbits and rx_nbits are contained by @spi_device->mode
          example: if @spi_device->mode = DUAL, then tx/rx_nbits can not be set
                   to QUAD(SPI_NBITS_QUAD)
       (3)if "@spi_device->mode & SPI_3WIRE", then tx/rx_nbits should be in
          single(SPI_NBITS_SINGLE)
    
    Signed-off-by: wangyuhang <wangyuhang2014@gmail.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 2a20c32c8277..39d38756e984 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -869,6 +869,51 @@ static void of_register_spi_devices(struct spi_master *master)
 		if (of_find_property(nc, "spi-3wire", NULL))
 			spi->mode |= SPI_3WIRE;
 
+		/* Device DUAL/QUAD mode */
+		prop = of_get_property(nc, "spi-tx-nbits", &len);
+		if (!prop || len < sizeof(*prop)) {
+			dev_err(&master->dev, "%s has no 'spi-tx-nbits' property\n",
+				nc->full_name);
+			spi_dev_put(spi);
+			continue;
+		}
+		switch (be32_to_cpup(prop)) {
+		case SPI_NBITS_SINGLE:
+			break;
+		case SPI_NBITS_DUAL:
+			spi->mode |= SPI_TX_DUAL;
+			break;
+		case SPI_NBITS_QUAD:
+			spi->mode |= SPI_TX_QUAD;
+			break;
+		default:
+			dev_err(&master->dev, "spi-tx-nbits value is not supported\n");
+			spi_dev_put(spi);
+			continue;
+		}
+
+		prop = of_get_property(nc, "spi-rx-nbits", &len);
+		if (!prop || len < sizeof(*prop)) {
+			dev_err(&master->dev, "%s has no 'spi-rx-nbits' property\n",
+				nc->full_name);
+			spi_dev_put(spi);
+			continue;
+		}
+		switch (be32_to_cpup(prop)) {
+		case SPI_NBITS_SINGLE:
+			break;
+		case SPI_NBITS_DUAL:
+			spi->mode |= SPI_RX_DUAL;
+			break;
+		case SPI_NBITS_QUAD:
+			spi->mode |= SPI_RX_QUAD;
+			break;
+		default:
+			dev_err(&master->dev, "spi-rx-nbits value is not supported\n");
+			spi_dev_put(spi);
+			continue;
+		}
+
 		/* Device speed */
 		prop = of_get_property(nc, "spi-max-frequency", &len);
 		if (!prop || len < sizeof(*prop)) {
@@ -1316,6 +1361,19 @@ int spi_setup(struct spi_device *spi)
 	unsigned	bad_bits;
 	int		status = 0;
 
+	/* check mode to prevent that DUAL and QUAD set at the same time
+	 */
+	if (((spi->mode & SPI_TX_DUAL) && (spi->mode & SPI_TX_QUAD)) ||
+		((spi->mode & SPI_RX_DUAL) && (spi->mode & SPI_RX_QUAD))) {
+		dev_err(&spi->dev,
+		"setup: can not select dual and quad at the same time\n");
+		return -EINVAL;
+	}
+	/* if it is SPI_3WIRE mode, DUAL and QUAD should be forbidden
+	 */
+	if ((spi->mode & SPI_3WIRE) && (spi->mode &
+		(SPI_TX_DUAL | SPI_TX_QUAD | SPI_RX_DUAL | SPI_RX_QUAD)))
+		return -EINVAL;
 	/* help drivers fail *cleanly* when they need options
 	 * that aren't supported with their current master
 	 */
@@ -1378,6 +1436,8 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
 	/**
 	 * Set transfer bits_per_word and max speed as spi device default if
 	 * it is not set for this transfer.
+	 * Set transfer tx_nbits and rx_nbits as single transfer default
+	 * (SPI_NBITS_SINGLE) if it is not set for this transfer.
 	 */
 	list_for_each_entry(xfer, &message->transfers, transfer_list) {
 		if (!xfer->bits_per_word)
@@ -1403,6 +1463,42 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
 			return -EINVAL;
 		if (xfer->speed_hz && master->max_speed_hz &&
 		    xfer->speed_hz > master->max_speed_hz)
+
+		if (xfer->tx_buf && !xfer->tx_nbits)
+			xfer->tx_nbits = SPI_NBITS_SINGLE;
+		if (xfer->rx_buf && !xfer->rx_nbits)
+			xfer->rx_nbits = SPI_NBITS_SINGLE;
+		/* check transfer tx/rx_nbits:
+		 * 1. keep the value is not out of single, dual and quad
+		 * 2. keep tx/rx_nbits is contained by mode in spi_device
+		 * 3. if SPI_3WIRE, tx/rx_nbits should be in single
+		 */
+		if (xfer->tx_nbits != SPI_NBITS_SINGLE &&
+			xfer->tx_nbits != SPI_NBITS_DUAL &&
+			xfer->tx_nbits != SPI_NBITS_QUAD)
+			return -EINVAL;
+		if ((xfer->tx_nbits == SPI_NBITS_DUAL) &&
+			!(spi->mode & (SPI_TX_DUAL | SPI_TX_QUAD)))
+			return -EINVAL;
+		if ((xfer->tx_nbits == SPI_NBITS_QUAD) &&
+			!(spi->mode & SPI_TX_QUAD))
+			return -EINVAL;
+		if ((spi->mode & SPI_3WIRE) &&
+			(xfer->tx_nbits != SPI_NBITS_SINGLE))
+			return -EINVAL;
+		/* check transfer rx_nbits */
+		if (xfer->rx_nbits != SPI_NBITS_SINGLE &&
+			xfer->rx_nbits != SPI_NBITS_DUAL &&
+			xfer->rx_nbits != SPI_NBITS_QUAD)
+			return -EINVAL;
+		if ((xfer->rx_nbits == SPI_NBITS_DUAL) &&
+			!(spi->mode & (SPI_RX_DUAL | SPI_RX_QUAD)))
+			return -EINVAL;
+		if ((xfer->rx_nbits == SPI_NBITS_QUAD) &&
+			!(spi->mode & SPI_RX_QUAD))
+			return -EINVAL;
+		if ((spi->mode & SPI_3WIRE) &&
+			(xfer->rx_nbits != SPI_NBITS_SINGLE))
 			return -EINVAL;
 	}
 

commit 56ede94a000bb9635b326db38baf66da6dfc174e
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Wed Aug 14 10:25:28 2013 +0200

    spi: limit default transfer speed to controller's max speed
    
    Since the 'spi: Support transfer speed checking in the core'
    change, the SPI core validates the desired speed of a given
    transfer against the minimum and maximum speeds supported by
    the controller.
    
    If the speed of a transfer is not specified, the core uses
    the maximum speed of the actual SPI device. However if the
    maximum speed of the actual device is greater than the
    maximum speed of the controller, the core will reject the
    transfer due to the aforementioned change.
    
    Change the code to use the maximum speed of the controller
    by default if that is below the device's maximum speed.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index c2899161ccac..2a20c32c8277 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1382,8 +1382,13 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
 	list_for_each_entry(xfer, &message->transfers, transfer_list) {
 		if (!xfer->bits_per_word)
 			xfer->bits_per_word = spi->bits_per_word;
-		if (!xfer->speed_hz)
+		if (!xfer->speed_hz) {
 			xfer->speed_hz = spi->max_speed_hz;
+			if (master->max_speed_hz &&
+			    xfer->speed_hz > master->max_speed_hz)
+				xfer->speed_hz = master->max_speed_hz;
+		}
+
 		if (master->bits_per_word_mask) {
 			/* Only 32 bits fit in the mask */
 			if (xfer->bits_per_word > 32)

commit 49834de234f3cf592c3d242c889ca603db8e7050
Author: Mark Brown <broonie@linaro.org>
Date:   Sun Jul 28 14:47:02 2013 +0100

    spi: Provide core support for runtime PM during transfers
    
    Most SPI drivers that implement runtime PM support use identical code to
    do so: they acquire a runtime PM lock in prepare_transfer_hardware() and
    then they release it in unprepare_transfer_hardware(). The variations in
    this are mostly missing error checking and the choice to use autosuspend.
    
    Since these runtime PM calls are normally the only thing in the prepare
    and unprepare callbacks and the autosuspend API transparently does the
    right thing on devices with autosuspend disabled factor all of this out
    into the core with a flag to enable the behaviour.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>
    Reviewed-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 978dda2c5239..361cced68069 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -553,6 +553,10 @@ static void spi_pump_messages(struct kthread_work *work)
 		    master->unprepare_transfer_hardware(master))
 			dev_err(&master->dev,
 				"failed to unprepare transfer hardware\n");
+		if (master->auto_runtime_pm) {
+			pm_runtime_mark_last_busy(master->dev.parent);
+			pm_runtime_put_autosuspend(master->dev.parent);
+		}
 		return;
 	}
 
@@ -572,11 +576,23 @@ static void spi_pump_messages(struct kthread_work *work)
 		master->busy = true;
 	spin_unlock_irqrestore(&master->queue_lock, flags);
 
+	if (!was_busy && master->auto_runtime_pm) {
+		ret = pm_runtime_get_sync(master->dev.parent);
+		if (ret < 0) {
+			dev_err(&master->dev, "Failed to power device: %d\n",
+				ret);
+			return;
+		}
+	}
+
 	if (!was_busy && master->prepare_transfer_hardware) {
 		ret = master->prepare_transfer_hardware(master);
 		if (ret) {
 			dev_err(&master->dev,
 				"failed to prepare transfer hardware\n");
+
+			if (master->auto_runtime_pm)
+				pm_runtime_put(master->dev.parent);
 			return;
 		}
 	}

commit 078726ce6d56a767533064e0f2f2100d7cb6fc22
Author: Sourav Poddar <sourav.poddar@ti.com>
Date:   Thu Jul 18 15:31:25 2013 +0530

    driver: spi: Modify core to compute the message length
    
    Make spi core calculate the message length while
    populating the other transfer parameters.
    
    Usecase, driver can use it to populate framelength filed in their
    controller.
    
    Signed-off-by: Sourav Poddar <sourav.poddar@ti.com>
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 978dda2c5239..7e3446cab72f 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1375,6 +1375,7 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
 	 * it is not set for this transfer.
 	 */
 	list_for_each_entry(xfer, &message->transfers, transfer_list) {
+		message->frame_length += xfer->len;
 		if (!xfer->bits_per_word)
 			xfer->bits_per_word = spi->bits_per_word;
 		if (!xfer->speed_hz)

commit 24a0013a04e81e95198daab98edf4df02e191568
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Jul 10 15:05:40 2013 +0100

    spi: More sanity checks for transfers
    
    Check that transfers are non-empty and that there is a completion for
    them.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index a52f16685d6a..c2899161ccac 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1351,6 +1351,11 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
 	struct spi_master *master = spi->master;
 	struct spi_transfer *xfer;
 
+	if (list_empty(&message->transfers))
+		return -EINVAL;
+	if (!message->complete)
+		return -EINVAL;
+
 	/* Half-duplex links include original MicroWire, and ones with
 	 * only one data pin like SPI_3WIRE (switches direction) or where
 	 * either MOSI or MISO is missing.  They can also be caused by

commit a2fd4f9fa3b9f051550b36c4dfa74bc32bda24ee
Author: Mark Brown <broonie@linaro.org>
Date:   Wed Jul 10 14:57:26 2013 +0100

    spi: Support transfer speed checking in the core
    
    Allow drivers to avoid implementing their own checks for simple rates by
    specifying the limits in the master structure.
    
    Signed-off-by: Mark Brown <broonie@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 978dda2c5239..a52f16685d6a 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1387,6 +1387,13 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
 					BIT(xfer->bits_per_word - 1)))
 				return -EINVAL;
 		}
+
+		if (xfer->speed_hz && master->min_speed_hz &&
+		    xfer->speed_hz < master->min_speed_hz)
+			return -EINVAL;
+		if (xfer->speed_hz && master->max_speed_hz &&
+		    xfer->speed_hz > master->max_speed_hz)
+			return -EINVAL;
 	}
 
 	message->spi = spi;

commit 7f0ef0267e20d62d45d527911a993b1e998f4968
Merge: 862f00125491 9307c2952450
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 3 17:12:13 2013 -0700

    Merge branch 'akpm' (updates from Andrew Morton)
    
    Merge first patch-bomb from Andrew Morton:
     - various misc bits
     - I'm been patchmonkeying ocfs2 for a while, as Joel and Mark have been
       distracted.  There has been quite a bit of activity.
     - About half the MM queue
     - Some backlight bits
     - Various lib/ updates
     - checkpatch updates
     - zillions more little rtc patches
     - ptrace
     - signals
     - exec
     - procfs
     - rapidio
     - nbd
     - aoe
     - pps
     - memstick
     - tools/testing/selftests updates
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (445 commits)
      tools/testing/selftests: don't assume the x bit is set on scripts
      selftests: add .gitignore for kcmp
      selftests: fix clean target in kcmp Makefile
      selftests: add .gitignore for vm
      selftests: add hugetlbfstest
      self-test: fix make clean
      selftests: exit 1 on failure
      kernel/resource.c: remove the unneeded assignment in function __find_resource
      aio: fix wrong comment in aio_complete()
      drivers/w1/slaves/w1_ds2408.c: add magic sequence to disable P0 test mode
      drivers/memstick/host/r592.c: convert to module_pci_driver
      drivers/memstick/host/jmb38x_ms: convert to module_pci_driver
      pps-gpio: add device-tree binding and support
      drivers/pps/clients/pps-gpio.c: convert to module_platform_driver
      drivers/pps/clients/pps-gpio.c: convert to devm_* helpers
      drivers/parport/share.c: use kzalloc
      Documentation/accounting/getdelays.c: avoid strncpy in accounting tool
      aoe: update internal version number to v83
      aoe: update copyright date
      aoe: perform I/O completions in parallel
      ...

commit f170168b9a0b61ea1e647b082b38f605f1d3de3e
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Jul 3 15:04:58 2013 -0700

    drivers: avoid parsing names as kthread_run() format strings
    
    Calling kthread_run with a single name parameter causes it to be handled
    as a format string. Many callers are passing potentially dynamic string
    content, so use "%s" in those cases to avoid any potential accidents.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 32b7bb111eb6..085db8b2f2bc 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -601,7 +601,7 @@ static int spi_init_queue(struct spi_master *master)
 
 	init_kthread_worker(&master->kworker);
 	master->kworker_task = kthread_run(kthread_worker_fn,
-					   &master->kworker,
+					   &master->kworker, "%s",
 					   dev_name(&master->dev));
 	if (IS_ERR(master->kworker_task)) {
 		dev_err(&master->dev, "failed to create message pump task\n");

commit 45f0a85c8258741d11bda25c0a5669c06267204a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 3 21:49:52 2013 +0200

    PM / Runtime: Rework the "runtime idle" helper routine
    
    The "runtime idle" helper routine, rpm_idle(), currently ignores
    return values from .runtime_idle() callbacks executed by it.
    However, it turns out that many subsystems use
    pm_generic_runtime_idle() which checks the return value of the
    driver's callback and executes pm_runtime_suspend() for the device
    unless that value is not 0.  If that logic is moved to rpm_idle()
    instead, pm_generic_runtime_idle() can be dropped and its users
    will not need any .runtime_idle() callbacks any more.
    
    Moreover, the PCI, SCSI, and SATA subsystems' .runtime_idle()
    routines, pci_pm_runtime_idle(), scsi_runtime_idle(), and
    ata_port_runtime_idle(), respectively, as well as a few drivers'
    ones may be simplified if rpm_idle() calls rpm_suspend() after 0 has
    been returned by the .runtime_idle() callback executed by it.
    
    To reduce overall code bloat, make the changes described above.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 32b7bb111eb6..095cfaded1c0 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -223,7 +223,7 @@ static const struct dev_pm_ops spi_pm = {
 	SET_RUNTIME_PM_OPS(
 		pm_generic_runtime_suspend,
 		pm_generic_runtime_resume,
-		pm_generic_runtime_idle
+		NULL
 	)
 };
 

commit 88b0357dde1c2721a64268e4601d1c2dec1158b0
Merge: 0faa3146f172 3086c9f64821
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon May 13 18:27:18 2013 +0400

    Merge remote-tracking branch 'spi/fix/grant' into spi-linus

commit 61f3d0a9883d965b498edeb673235bddc92770fd
Merge: 8ded8d4e4fac cd8d984f0def
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 29 16:38:41 2013 -0700

    Merge tag 'spi-v3.10' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi
    
    Pull spi updates from Mark Brown:
     "A fairly quiet release for SPI, mainly driver work.  A few highlights:
    
       - Supports bits per word compatibility checking in the core.
       - Allow use of the IP used in Freescale SPI controllers outside
         Freescale SoCs.
       - DMA support for the Atmel SPI driver.
       - New drivers for the BCM2835 and Tegra114"
    
    * tag 'spi-v3.10' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi: (68 commits)
      spi-topcliff-pch: fix to use list_for_each_entry_safe() when delete list items
      spi-topcliff-pch: missing platform_driver_unregister() on error in pch_spi_init()
      ARM: dts: add pinctrl property for spi node for atmel SoC
      ARM: dts: add spi nodes for the atmel boards
      ARM: dts: add spi nodes for atmel SoC
      ARM: at91: add clocks for spi dt entries
      spi/spi-atmel: add dmaengine support
      spi/spi-atmel: add flag to controller data for lock operations
      spi/spi-atmel: add physical base address
      spi/sirf: fix MODULE_DEVICE_TABLE
      MAINTAINERS: Add git repository and update my address
      spi/s3c64xx: Check for errors in dmaengine prepare_transfer()
      spi/s3c64xx: Fix non-dmaengine usage
      spi: omap2-mcspi: fix error return code in omap2_mcspi_probe()
      spi/s3c64xx: let device core setup the default pin configuration
      MAINTAINERS: Update Grant's email address and maintainership
      spi: omap2-mcspi: Fix transfers if DMADEVICES is not set
      spi: s3c64xx: move to generic dmaengine API
      spi-gpio: init CS before spi_bitbang_setup()
      spi: spi-mpc512x-psc: let transmiter/receiver enabled when in xfer loop
      ...

commit 8ec5d84ef51cc64ed02bb9bf0e43a652178252c1
Author: Andreas Larsson <andreas@gaisler.com>
Date:   Wed Feb 13 14:23:24 2013 +0100

    spi: Return error from of_spi_register_master on bad "cs-gpios" property
    
    This makes sure that an error is returned on an incorrectly formed
    "cs-gpios" property, but reports success when the "cs-gpios" property is
    well formed or missing.
    
    When holes in the cs-gpios property phandle list is used to indicate
    that some other form of chipselect is to be used it is important that
    failure to read a broken "cs-gpios" property does not silently fail
    leading to the spi controller to use an unintended chipselect.
    
    Signed-off-by: Andreas Larsson <andreas@gaisler.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index bcca66c5107f..3738e7cbff33 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1067,8 +1067,11 @@ static int of_spi_register_master(struct spi_master *master)
 	nb = of_gpio_named_count(np, "cs-gpios");
 	master->num_chipselect = max(nb, (int)master->num_chipselect);
 
-	if (nb < 1)
+	/* Return error only for an incorrectly formed cs-gpios property */
+	if (nb == 0 || nb == -ENOENT)
 		return 0;
+	else if (nb < 0)
+		return nb;
 
 	cs = devm_kzalloc(&master->dev,
 			  sizeof(int) * master->num_chipselect,

commit 446411e18b2cb17d153e45f634a3c9a79ada3ac2
Author: Andreas Larsson <andreas@gaisler.com>
Date:   Wed Feb 13 14:20:25 2013 +0100

    spi: Initialize cs_gpio and cs_gpios with -ENOENT
    
    The return value from of_get_named_gpio is -ENOENT when the given index
    matches a hole in the "cs-gpios" property phandle list. However, the
    default value of cs_gpio in struct spi_device and entries of cs_gpios in
    struct spi_master is -EINVAL, which is documented to indicate that a
    GPIO line should not be used for the given spi_device.
    
    This sets the default value of cs_gpio in struct spi_device and entries
    of cs_gpios in struct spi_master to -ENOENT. Thus, -ENOENT is the only
    value used to indicate that no GPIO line should be used.
    
    Signed-off-by: Andreas Larsson <andreas@gaisler.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 004b10f184d4..bcca66c5107f 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -334,7 +334,7 @@ struct spi_device *spi_alloc_device(struct spi_master *master)
 	spi->dev.parent = &master->dev;
 	spi->dev.bus = &spi_bus_type;
 	spi->dev.release = spidev_release;
-	spi->cs_gpio = -EINVAL;
+	spi->cs_gpio = -ENOENT;
 	device_initialize(&spi->dev);
 	return spi;
 }
@@ -1079,7 +1079,7 @@ static int of_spi_register_master(struct spi_master *master)
 		return -ENOMEM;
 
 	for (i = 0; i < master->num_chipselect; i++)
-		cs[i] = -EINVAL;
+		cs[i] = -ENOENT;
 
 	for (i = 0; i < nb; i++)
 		cs[i] = of_get_named_gpio(np, "cs-gpios", i);

commit e0a77f26312a8b23b6040073c50b0c19b82ce8b4
Merge: e24b0bfa2f04 1ad849aee5f5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 5 10:04:41 2013 -0700

    Merge tag 'spi-fix-v3.9-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/misc
    
    Pull spi fixes from Mark Brown:
     "A bunch of small driver fixes plus a fix for error handling in the
      core - nothing too exciting overall."
    
    * tag 'spi-fix-v3.9-rc5' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/misc:
      spi/mpc512x-psc: optionally keep PSC SS asserted across xfer segmensts
      spi: Unlock a spinlock before calling into the controller driver.
      spi/s3c64xx: modified error interrupt handling and init
      spi/bcm63xx: don't disable non enabled clocks in probe error path
      spi/bcm63xx: Remove unused variable
      spi: slink-tegra20: move runtime pm calls to transfer_one_message

commit 29896178cff0cd6e4ee78edc26158cc197a6b504
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Apr 1 00:21:08 2013 +0000

    ACPI / SPI: Use parent's ACPI_HANDLE() in acpi_register_spi_devices()
    
    The ACPI handle of struct spi_master's dev member should not be
    set, because this causes that struct spi_master to be associated
    with the ACPI device node corresponding to its parent as the
    second "physical_device", which is incorrect (this happens during
    the registration of struct spi_master).  Consequently,
    acpi_register_spi_devices() should use the ACPI handle of the
    parent of the struct spi_master it is called for rather than that
    struct spi_master's ACPI handle (which should be NULL).
    
    Make that happen and modify the spi-pxa2xx driver, which currently is
    the only driver for ACPI-enumerated SPI controller chips, not to set
    the ACPI handle for the struct spi_master it creates.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index f996c600eb8c..5e073d897edb 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -984,7 +984,7 @@ static void acpi_register_spi_devices(struct spi_master *master)
 	acpi_status status;
 	acpi_handle handle;
 
-	handle = ACPI_HANDLE(&master->dev);
+	handle = ACPI_HANDLE(master->dev.parent);
 	if (!handle)
 		return;
 

commit e47ef0f1affff3e017d0477b283a26beeb45258a
Merge: 823cd0454325 1ad849aee5f5
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Mon Apr 1 14:55:16 2013 +0100

    Merge branch 'spi-fix' into spi-next

commit b0b36b861e434ee1c1a64cb39259e262f79af62e
Author: Bryan Freed <bfreed@chromium.org>
Date:   Wed Mar 13 11:17:40 2013 -0700

    spi: Unlock a spinlock before calling into the controller driver.
    
    spi_pump_messages() calls into a controller driver with
    unprepare_transfer_hardware() which is documented as "This may sleep".
    As in the prepare_transfer_hardware() call below, we should release the
    queue_lock spinlock before making the call.
    Rework the logic a bit to hold queue_lock to protect the 'busy' flag,
    then release it to call unprepare_transfer_hardware().
    
    Signed-off-by: Bryan Freed <bfreed@chromium.org>
    Reviewed-by: Doug Anderson <dianders@chromium.org>
    Signed-off-by: Doug Anderson <dianders@chromium.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index f996c600eb8c..5b96250b0628 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -543,17 +543,16 @@ static void spi_pump_messages(struct kthread_work *work)
 	/* Lock queue and check for queue work */
 	spin_lock_irqsave(&master->queue_lock, flags);
 	if (list_empty(&master->queue) || !master->running) {
-		if (master->busy && master->unprepare_transfer_hardware) {
-			ret = master->unprepare_transfer_hardware(master);
-			if (ret) {
-				spin_unlock_irqrestore(&master->queue_lock, flags);
-				dev_err(&master->dev,
-					"failed to unprepare transfer hardware\n");
-				return;
-			}
+		if (!master->busy) {
+			spin_unlock_irqrestore(&master->queue_lock, flags);
+			return;
 		}
 		master->busy = false;
 		spin_unlock_irqrestore(&master->queue_lock, flags);
+		if (master->unprepare_transfer_hardware &&
+		    master->unprepare_transfer_hardware(master))
+			dev_err(&master->dev,
+				"failed to unprepare transfer hardware\n");
 		return;
 	}
 

commit 543bb255a1987836e64f5b7a63664ead8b32b042
Author: Stephen Warren <swarren@wwwdotorg.org>
Date:   Tue Mar 26 20:37:57 2013 -0600

    spi: add ability to validate xfer->bits_per_word in SPI core
    
    Allow SPI masters to define the set of bits_per_word values they support.
    If they do this, then the SPI core will reject transfers that attempt to
    use an unsupported bits_per_word value. This eliminates the need for each
    SPI driver to implement this checking in most cases.
    
    Signed-off-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index f996c600eb8c..0cabf1560550 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1377,6 +1377,14 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
 			xfer->bits_per_word = spi->bits_per_word;
 		if (!xfer->speed_hz)
 			xfer->speed_hz = spi->max_speed_hz;
+		if (master->bits_per_word_mask) {
+			/* Only 32 bits fit in the mask */
+			if (xfer->bits_per_word > 32)
+				return -EINVAL;
+			if (!(master->bits_per_word_mask &
+					BIT(xfer->bits_per_word - 1)))
+				return -EINVAL;
+		}
 	}
 
 	message->spi = spi;

commit 06991c28f37ad68e5c03777f5c3b679b56e3dac1
Merge: 460dc1eecf37 74fef7a8fd1d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 21 12:05:51 2013 -0800

    Merge tag 'driver-core-3.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core patches from Greg Kroah-Hartman:
     "Here is the big driver core merge for 3.9-rc1
    
      There are two major series here, both of which touch lots of drivers
      all over the kernel, and will cause you some merge conflicts:
    
       - add a new function called devm_ioremap_resource() to properly be
         able to check return values.
    
       - remove CONFIG_EXPERIMENTAL
    
      Other than those patches, there's not much here, some minor fixes and
      updates"
    
    Fix up trivial conflicts
    
    * tag 'driver-core-3.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (221 commits)
      base: memory: fix soft/hard_offline_page permissions
      drivercore: Fix ordering between deferred_probe and exiting initcalls
      backlight: fix class_find_device() arguments
      TTY: mark tty_get_device call with the proper const values
      driver-core: constify data for class_find_device()
      firmware: Ignore abort check when no user-helper is used
      firmware: Reduce ifdef CONFIG_FW_LOADER_USER_HELPER
      firmware: Make user-mode helper optional
      firmware: Refactoring for splitting user-mode helper code
      Driver core: treat unregistered bus_types as having no devices
      watchdog: Convert to devm_ioremap_resource()
      thermal: Convert to devm_ioremap_resource()
      spi: Convert to devm_ioremap_resource()
      power: Convert to devm_ioremap_resource()
      mtd: Convert to devm_ioremap_resource()
      mmc: Convert to devm_ioremap_resource()
      mfd: Convert to devm_ioremap_resource()
      media: Convert to devm_ioremap_resource()
      iommu: Convert to devm_ioremap_resource()
      drm: Convert to devm_ioremap_resource()
      ...

commit b3cdda2b4f541439ca4205793040aa2e1c852e3b
Merge: 3aad3f03b2b6 02bbde7849e6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 20 11:04:46 2013 -0800

    Merge tag 'dt-for-linus' of git://git.secretlab.ca/git/linux
    
    Pull device tree changes from Grant Likely:
     "All around device tree changes destined for v3.8.  Aside from the
      documentation updates the highlights in this branch include:
    
       - Kbuild changes for using CPP with .dts files
       - locking fix from preempt_rt patchset
       - include DT alias names in device uevent
       - Selftest bugfixes and improvements
       - New function for counting phandles stanzas in a property
       - constify argument to of_node_full_name()
       - Various bug fixes
    
      This tree did also contain a commit to use platform_device_add instead
      of open-coding the device add code, but it caused problems with amba
      devices and needed to be reverted."
    
    * tag 'dt-for-linus' of git://git.secretlab.ca/git/linux: (23 commits)
      Revert "of: use platform_device_add"
      kbuild: limit dtc+cpp include path
      gpio: Make of_count_named_gpios() use new of_count_phandle_with_args()
      of: Create function for counting number of phandles in a property
      of/base: Clean up exit paths for of_parse_phandle_with_args()
      of/selftest: Use selftest() macro throughout
      of/selftest: Fix GPIOs selftest to cover the 7th case
      of: fix recursive locking in of_get_next_available_child()
      documentation/devicetree: Fix a typo in exynos-dw-mshc.txt
      OF: convert devtree lock from rw_lock to raw spinlock
      of/exynos_g2d: Add Bindings for exynos G2D driver
      kbuild: create a rule to run the pre-processor on *.dts files
      input: Extend matrix-keypad device tree binding
      devicetree: Move NS2 LEDs binding into LEDs directory
      of: use platform_device_add
      powerpc/5200: Fix size to request_mem_region() call
      documentation/devicetree: Fix typos
      of: add 'const' to of_node_full_name parameter
      of: Output devicetree alias names in uevent
      DT: add vendor prefixes for Renesas and Toshiba
      ...

commit 3aad3f03b2b6d2d977b985c49274cdb78a1593e5
Merge: 10b6339e9324 095c3752e673
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 20 11:03:22 2013 -0800

    Merge tag 'spi-for-linus' of git://git.secretlab.ca/git/linux
    
    Pull SPI changes from Grant Likely:
     "Changes to both core spi code and spi device drivers.  The driver
      changes are the usual set of bug fixes and platform enablement.
    
      Core code changes include:
    
       - More intelligent assignment of SPI bus numbers when using DT
    
       - Common mechanism for using gpios as CS lines
    
       - Pull checks for bits_per_word and transfer speed out of drivers and
         into core code
    
       - Ensure temporary DMA buffers are DMA safe"
    
    * tag 'spi-for-linus' of git://git.secretlab.ca/git/linux: (50 commits)
      spi: Document cs_gpios and cs_gpio in kernel-doc
      spi/of: Fix initialization of cs_gpios array
      spi/pxa2xx: add support for Lynxpoint SPI controllers
      spi/pxa2xx: add support for Intel Low Power Subsystem SPI
      spi/pxa2xx: add support for SPI_LOOP
      spi/pxa2xx: add support for runtime PM
      spi/pxa2xx: add support for DMA engine
      spi/pxa2xx: break out the private DMA API usage into a separate file
      spi/ath79: add shutdown handler
      spi/mips-lantiq: set SPI_MASTER_HALF_DUPLEX flag
      spi/mips-lantiq: make use of spi_finalize_current_message
      spi/bcm63xx: work around inability to keep CS up
      spi/davinci: use request_threaded_irq() to fix deadlock
      spi/orion: Use module_platform_driver()
      spi/bcm63xx: reject transfers unable to transfer
      spi: Ensure memory used for spi_write_then_read() is DMA safe
      spi/spi-mpc512x-psc: init mode bits supported by the driver
      spi/mpc512x-psc: don't use obsolet cell-index property
      spi: Remove erroneous __init, __exit and __exit_p() references in drivers
      spi/s3c64xx: fix checkpatch warnings and error
      ...

commit e80beb27d2f81a1c3c8887e0e0a82d77bb392d28
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 12 17:48:37 2013 +0000

    gpio: Make of_count_named_gpios() use new of_count_phandle_with_args()
    
    This patch replaces the horribly coded of_count_named_gpios() with a
    call to of_count_phandle_with_args() which is far more efficient. This
    also changes the return value of of_gpio_count() & of_gpio_named_count()
    from 'unsigned int' to 'int' so that it can return an error code. All
    the users of that function are fixed up to correctly handle a negative
    return value.
    
    v2: Split GPIO portion into a separate patch
    
    Tested-by: Andreas Larsson <andreas@gaisler.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 19ee901577da..21c47482d9fd 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1059,15 +1059,14 @@ EXPORT_SYMBOL_GPL(spi_alloc_master);
 #ifdef CONFIG_OF
 static int of_spi_register_master(struct spi_master *master)
 {
-	u16 nb;
-	int i, *cs;
+	int nb, i, *cs;
 	struct device_node *np = master->dev.of_node;
 
 	if (!np)
 		return 0;
 
 	nb = of_gpio_named_count(np, "cs-gpios");
-	master->num_chipselect = max(nb, master->num_chipselect);
+	master->num_chipselect = max(nb, (int)master->num_chipselect);
 
 	if (nb < 1)
 		return 0;

commit 0da83bb1c9d2690465d27cb8887918e6664f647e
Author: Andreas Larsson <andreas@gaisler.com>
Date:   Tue Jan 29 15:53:40 2013 +0100

    spi/of: Fix initialization of cs_gpios array
    
    Using memset does not set an array of integers properly. Replace with a
    loop to set each element properly.
    
    Signed-off-by: Andreas Larsson <andreas@gaisler.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index d1e0a316826d..6707cb2f4fa4 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1080,7 +1080,8 @@ static int of_spi_register_master(struct spi_master *master)
 	if (!master->cs_gpios)
 		return -ENOMEM;
 
-	memset(cs, -EINVAL, master->num_chipselect);
+	for (i = 0; i < master->num_chipselect; i++)
+		cs[i] = -EINVAL;
 
 	for (i = 0; i < nb; i++)
 		cs[i] = of_get_named_gpio(np, "cs-gpios", i);

commit 8bd75c77b7c6a3954140dd2e20346aef3efe4a35
Author: Clark Williams <williams@redhat.com>
Date:   Thu Feb 7 09:47:07 2013 -0600

    sched/rt: Move rt specific bits into new header file
    
    Move rt scheduler definitions out of include/linux/sched.h into
    new file include/linux/sched/rt.h
    
    Signed-off-by: Clark Williams <williams@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/20130207094707.7b9f825f@riff.lan
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 19ee901577da..3a6083b386a1 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -33,7 +33,7 @@
 #include <linux/of_gpio.h>
 #include <linux/pm_runtime.h>
 #include <linux/export.h>
-#include <linux/sched.h>
+#include <linux/sched/rt.h>
 #include <linux/delay.h>
 #include <linux/kthread.h>
 #include <linux/ioport.h>

commit 9f3b795a626ee79574595e06d1437fe0c7d51d29
Author: MichaÅ MirosÅaw <mirq-linux@rere.qmqm.pl>
Date:   Fri Feb 1 20:40:17 2013 +0100

    driver-core: constify data for class_find_device()
    
    All in-kernel users of class_find_device() don't really need mutable
    data for match callback.
    
    In two places (kernel/power/suspend_test.c, drivers/scsi/osd/osd_uld.c)
    this patch changes match callbacks to use const search data.
    
    The const is propagated to rtc_class_open() and power_supply_get_by_name()
    parameters.
    
    Note that there's a dev reference leak in suspend_test.c that's not
    touched in this patch.
    
    Signed-off-by: MichaÅ MirosÅaw <mirq-linux@rere.qmqm.pl>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 19ee901577da..493ce4a71717 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1248,10 +1248,10 @@ int spi_master_resume(struct spi_master *master)
 }
 EXPORT_SYMBOL_GPL(spi_master_resume);
 
-static int __spi_master_match(struct device *dev, void *data)
+static int __spi_master_match(struct device *dev, const void *data)
 {
 	struct spi_master *m;
-	u16 *bus_num = data;
+	const u16 *bus_num = data;
 
 	m = container_of(dev, struct spi_master, dev);
 	return m->bus_num == *bus_num;

commit 2cd94c8a1b4184b48ecbc16b353dcbb513053285
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Jan 27 14:35:04 2013 +0800

    spi: Ensure memory used for spi_write_then_read() is DMA safe
    
    Use GFP_DMA in order to ensure that the memory we allocate for transfers
    in spi_write_then_read() can be DMAed. On most platforms this will have
    no effect.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 2edbe1903804..d1e0a316826d 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1661,7 +1661,8 @@ int spi_write_then_read(struct spi_device *spi,
 	 * using the pre-allocated buffer or the transfer is too large.
 	 */
 	if ((n_tx + n_rx) > SPI_BUFSIZ || !mutex_trylock(&lock)) {
-		local_buf = kmalloc(max((unsigned)SPI_BUFSIZ, n_tx + n_rx), GFP_KERNEL);
+		local_buf = kmalloc(max((unsigned)SPI_BUFSIZ, n_tx + n_rx),
+				    GFP_KERNEL | GFP_DMA);
 		if (!local_buf)
 			return -ENOMEM;
 	} else {

commit 059b8ffeee5b427949872bb6ed5db5ae0788054e
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Sat Jan 5 00:17:14 2013 +0530

    spi: make sure all transfer has proper speed set
    
    When spi client does the spi transfer and if it does not set
    the speed for each transfer then set it as default
    of spi device in spi core before calling low level transfer.
    
    This will remove the extra check in low level driver for setting
    speed.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 08ff4acd5225..2edbe1903804 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1369,12 +1369,14 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
 	}
 
 	/**
-	 * Set transfer bits_per_word as spi device default if it is not
-	 * set for this transfer.
+	 * Set transfer bits_per_word and max speed as spi device default if
+	 * it is not set for this transfer.
 	 */
 	list_for_each_entry(xfer, &message->transfers, transfer_list) {
 		if (!xfer->bits_per_word)
 			xfer->bits_per_word = spi->bits_per_word;
+		if (!xfer->speed_hz)
+			xfer->speed_hz = spi->max_speed_hz;
 	}
 
 	message->spi = spi;

commit bb29785e0d6d150181704be2efcc3141044625e2
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Dec 21 19:32:09 2012 +0000

    spi/of: Use DT aliases for assigning bus number
    
    Linux assigns a number to each spi_master in the system, but when the
    platform used the device tree, the numbers are dynamically assigned and
    are not predictable. In general this shouldn't matter since the kernel
    doesn't use the bus number for anything other than matching a bus to
    spi_boardinfo (not used for DT). However, sometimes userspace needs to
    figure out which bus is which, so it makes sense to use the global
    /aliases namespace to choose a specific bus number.
    
    It is safe to derive the bus number from an alias because aliases will
    never cause two buses to try and use the same bus number. (At one time
    the cell-index property was used for this purpose, but cell-index has
    the risk of an id collision).
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Anatolij Gustschin <agust@denx.de>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 19ee901577da..08ff4acd5225 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1135,6 +1135,9 @@ int spi_register_master(struct spi_master *master)
 	if (master->num_chipselect == 0)
 		return -EINVAL;
 
+	if ((master->bus_num < 0) && master->dev.of_node)
+		master->bus_num = of_alias_get_id(master->dev.of_node, "spi");
+
 	/* convention:  dynamically assigned bus IDs count down from the max */
 	if (master->bus_num < 0) {
 		/* FIXME switch to an IDR based scheme, something like

commit cb71941a682270dd5164d1332900694d19caa5e1
Author: David Daney <david.daney@cavium.com>
Date:   Tue May 22 15:47:19 2012 -0700

    of/spi: Fix SPI module loading by using proper "spi:" modalias prefixes.
    
    To get modprobe to automatically load the proper modules, we need to
    prefix things with "spi:".  Partially based on Grant Likely's suggestions.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    [grant.likely: reworked because drivers/of/of_spi.c has been removed]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index ab095acdb2a8..19ee901577da 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -824,6 +824,7 @@ static void of_register_spi_devices(struct spi_master *master)
 	struct spi_device *spi;
 	struct device_node *nc;
 	const __be32 *prop;
+	char modalias[SPI_NAME_SIZE + 4];
 	int rc;
 	int len;
 
@@ -887,7 +888,9 @@ static void of_register_spi_devices(struct spi_master *master)
 		spi->dev.of_node = nc;
 
 		/* Register the new device */
-		request_module(spi->modalias);
+		snprintf(modalias, sizeof(modalias), "%s%s", SPI_MODULE_PREFIX,
+			 spi->modalias);
+		request_module(modalias);
 		rc = spi_add_device(spi);
 		if (rc) {
 			dev_err(&master->dev, "spi_device register error %s\n",

commit d3b43e12b2c8c69f79ab76dcdc5956f47c376378
Merge: 15de0599277f 7cb943615aab
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 13 19:15:11 2012 -0800

    Merge tag 'spi-for-linus' of git://git.secretlab.ca/git/linux-2.6
    
    Pull SPI updates from Grant Likely:
     "Primarily SPI device driver bug fixes, one removal of an old driver,
      and some new tegra support.  There is some core code change too, but
      all in all pretty small stuff.
    
      The new features to note are:
       - Common code for describing GPIO CS lines in the device tree
       - Remove the SPI_BUFSIZ limitation on spi_write_the_read()
       - core spi ensures bits_per_word is set correctly
       - SPARC can now use SPI"
    
    * tag 'spi-for-linus' of git://git.secretlab.ca/git/linux-2.6: (36 commits)
      spi/sparc: Allow of_register_spi_devices for sparc
      spi: Remove HOTPLUG section attributes
      spi: Add support for specifying 3-wire mode via device tree
      spi: Fix comparison of different integer types
      spi/orion: Add SPI_CHPA and SPI_CPOL support to kirkwood driver.
      spi/sh: Add SH Mobile series as dependency to MSIOF controller
      spi/sh-msiof: Remove unneeded clock name
      spi: Remove SPI_BUFSIZ restriction on spi_write_then_read()
      spi/stmp: remove obsolete driver
      spi/clps711x: New SPI master driver
      spi: omap2-mcspi: remove duplicate inclusion of linux/err.h
      spi: omap2-mcspi: Fix the redifine warning
      spi/sh-hspi: add CS manual control support
      of_spi: add generic binding support to specify cs gpio
      spi: omap2-mcspi: remove duplicated include from spi-omap2-mcspi.c
      spi/bitbang: (cosmetic) simplify list manipulation
      spi/bitbang: avoid needless loop flow manipulations
      spi/omap: fix D0/D1 direction confusion
      spi: tegra: add spi driver for sflash controller
      spi: Dont call master->setup if not populated
      ...

commit bad73c5aa069f1f14cc07ce7bbae8d463635560c
Merge: b58ed041a360 f316fc56555a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 11 12:45:35 2012 -0800

    Merge tag 'pm+acpi-for-3.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
    
     - Introduction of device PM QoS flags.
    
     - ACPI device power management update allowing subsystems other than
       PCI to use it more easily.
    
     - ACPI device enumeration rework allowing additional kinds of devices
       to be enumerated via ACPI.  From Mika Westerberg, Adrian Hunter,
       Mathias Nyman, Andy Shevchenko, and Rafael J. Wysocki.
    
     - ACPICA update to version 20121018 from Bob Moore and Lv Zheng.
    
     - ACPI memory hotplug update from Wen Congyang and Yasuaki Ishimatsu.
    
     - Introduction of acpi_handle_<level>() messaging macros and ACPI-based
       CPU hot-remove support from Toshi Kani.
    
     - ACPI EC updates from Feng Tang.
    
     - cpufreq updates from Viresh Kumar, Fabio Baltieri and others.
    
     - cpuidle changes to quickly notice governor prediction failure from
       Youquan Song.
    
     - Support for using multiple cpuidle drivers at the same time and
       cpuidle cleanups from Daniel Lezcano.
    
     - devfreq updates from Nishanth Menon and others.
    
     - cpupower update from Thomas Renninger.
    
     - Fixes and small cleanups all over the place.
    
    * tag 'pm+acpi-for-3.8-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (196 commits)
      mmc: sdhci-acpi: enable runtime-pm for device HID INT33C6
      ACPI: add Haswell LPSS devices to acpi_platform_device_ids list
      ACPI: add documentation about ACPI 5 enumeration
      pnpacpi: fix incorrect TEST_ALPHA() test
      ACPI / PM: Fix header of acpi_dev_pm_detach() in acpi.h
      ACPI / video: ignore BIOS initial backlight value for HP Folio 13-2000
      ACPI : do not use Lid and Sleep button for S5 wakeup
      ACPI / PNP: Do not crash due to stale pointer use during system resume
      ACPI / video: Add "Asus UL30VT" to ACPI video detect blacklist
      ACPI: do acpisleep dmi check when CONFIG_ACPI_SLEEP is set
      spi / ACPI: add ACPI enumeration support
      gpio / ACPI: add ACPI support
      PM / devfreq: remove compiler error with module governors (2)
      cpupower: IvyBridge (0x3a and 0x3e models) support
      cpupower: Provide -c param for cpupower monitor to schedule process on all cores
      cpupower tools: Fix warning and a bug with the cpu package count
      cpupower tools: Fix malloc of cpu_info structure
      cpupower tools: Fix issues with sysfs_topology_read_file
      cpupower tools: Fix minor warnings
      cpupower tools: Update .gitignore for files created in the debug directories
      ...

commit 7cb943615aabbd72624f77f0a84b8c5d627cf846
Author: Andreas Larsson <andreas@gaisler.com>
Date:   Tue Dec 4 15:09:38 2012 +0100

    spi/sparc: Allow of_register_spi_devices for sparc
    
    The spi support code works on SPARC too. No reason to exclude it from
    the party.
    
    Signed-off-by: Andreas Larsson <andreas@gaisler.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 689eaf7485af..b8335a1f82ef 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -805,7 +805,7 @@ static int spi_master_initialize_queue(struct spi_master *master)
 
 /*-------------------------------------------------------------------------*/
 
-#if defined(CONFIG_OF) && !defined(CONFIG_SPARC)
+#if defined(CONFIG_OF)
 /**
  * of_register_spi_devices() - Register child devices onto the SPI bus
  * @master:	Pointer to spi_master device

commit fd4a319bc933ae93e68935b21924a9ca4ba2d060
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Dec 7 16:57:14 2012 +0000

    spi: Remove HOTPLUG section attributes
    
    CONFIG_HOTPLUG is going away as an option.  As result the __dev*
    markings will be going away.
    
    Remove use of __devinit, __devexit_p, __devinitdata, __devinitconst,
    and __devexit.
    
    Bill Pemberton has done most of the legwork on this series. I've used
    his script to purge the attributes from the drivers/gpio tree.
    
    Reported-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 2ca5f079ff01..689eaf7485af 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -492,8 +492,7 @@ static void spi_match_master_to_boardinfo(struct spi_master *master,
  * The board info passed can safely be __initdata ... but be careful of
  * any embedded pointers (platform_data, etc), they're copied as-is.
  */
-int __devinit
-spi_register_board_info(struct spi_board_info const *info, unsigned n)
+int spi_register_board_info(struct spi_board_info const *info, unsigned n)
 {
 	struct boardinfo *bi;
 	int i;

commit c20151dff8a6d503c0d0cc4387c33a618cdabcb7
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Dec 6 16:55:33 2012 +0100

    spi: Add support for specifying 3-wire mode via device tree
    
    This patch allows to specify that a SPI device is connected in 3-wire mode via
    device tree.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b370d292d19c..2ca5f079ff01 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -861,6 +861,8 @@ static void of_register_spi_devices(struct spi_master *master)
 			spi->mode |= SPI_CPOL;
 		if (of_find_property(nc, "spi-cs-high", NULL))
 			spi->mode |= SPI_CS_HIGH;
+		if (of_find_property(nc, "spi-3wire", NULL))
+			spi->mode |= SPI_3WIRE;
 
 		/* Device speed */
 		prop = of_get_property(nc, "spi-max-frequency", &len);

commit 5323f49853ba5f37d9975fe6bd13546c2ec790c8
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Dec 6 23:28:36 2012 +0000

    spi: Fix comparison of different integer types
    
    Fix problem discovered with sparse:
    + drivers/spi/spi.c:1554:37: sparse: incompatible types in comparison expression (different signedness)
    drivers/spi/spi.c: In function 'spi_write_then_read':
    drivers/spi/spi.c:1554:23: warning: comparison of distinct pointer types lacks a cast [enabled by default]
    
    The change to SPI_BUFSIZ was introduced in commit b3a223ee2, "spi:
    Remove SPI_BUFSIZ restriction on spi_write_then_read()"
    
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 22c71e238fdf..b370d292d19c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1551,7 +1551,7 @@ int spi_write_then_read(struct spi_device *spi,
 	 * using the pre-allocated buffer or the transfer is too large.
 	 */
 	if ((n_tx + n_rx) > SPI_BUFSIZ || !mutex_trylock(&lock)) {
-		local_buf = kmalloc(max(SPI_BUFSIZ, n_tx + n_rx), GFP_KERNEL);
+		local_buf = kmalloc(max((unsigned)SPI_BUFSIZ, n_tx + n_rx), GFP_KERNEL);
 		if (!local_buf)
 			return -ENOMEM;
 	} else {

commit b3a223ee2d1a4635b0643c547bc0096a37334ed1
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sun Dec 2 12:54:25 2012 +0900

    spi: Remove SPI_BUFSIZ restriction on spi_write_then_read()
    
    In order to avoid constantly allocating and deallocating there is a fixed
    buffer which spi_write_then_read() uses for transfers, with an early error
    check to ensure that the transfer fits within the buffer. This limits the
    size of transfers to this size, currently max(32, SMP_CACHE_BYTES).
    
    Since we can dynamically allocate and in fact already have a fallback
    to do so when there is contention for the fixed buffer remove this
    restriction and instead dynamically allocate a suitably sized buffer if
    the transfer won't fit.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index f1217ae59f3d..22c71e238fdf 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1545,12 +1545,18 @@ int spi_write_then_read(struct spi_device *spi,
 	struct spi_transfer	x[2];
 	u8			*local_buf;
 
-	/* Use preallocated DMA-safe buffer.  We can't avoid copying here,
-	 * (as a pure convenience thing), but we can keep heap costs
-	 * out of the hot path ...
+	/* Use preallocated DMA-safe buffer if we can.  We can't avoid
+	 * copying here, (as a pure convenience thing), but we can
+	 * keep heap costs out of the hot path unless someone else is
+	 * using the pre-allocated buffer or the transfer is too large.
 	 */
-	if ((n_tx + n_rx) > SPI_BUFSIZ)
-		return -EINVAL;
+	if ((n_tx + n_rx) > SPI_BUFSIZ || !mutex_trylock(&lock)) {
+		local_buf = kmalloc(max(SPI_BUFSIZ, n_tx + n_rx), GFP_KERNEL);
+		if (!local_buf)
+			return -ENOMEM;
+	} else {
+		local_buf = buf;
+	}
 
 	spi_message_init(&message);
 	memset(x, 0, sizeof x);
@@ -1563,14 +1569,6 @@ int spi_write_then_read(struct spi_device *spi,
 		spi_message_add_tail(&x[1], &message);
 	}
 
-	/* ... unless someone else is using the pre-allocated buffer */
-	if (!mutex_trylock(&lock)) {
-		local_buf = kmalloc(SPI_BUFSIZ, GFP_KERNEL);
-		if (!local_buf)
-			return -ENOMEM;
-	} else
-		local_buf = buf;
-
 	memcpy(local_buf, txbuf, n_tx);
 	x[0].tx_buf = local_buf;
 	x[1].rx_buf = local_buf + n_tx;

commit a34fc82e234255b657e62c3ce0c12e9439a59e80
Merge: 161b96c383c4 227c4ce6eac9
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Dec 6 13:58:31 2012 +0000

    Merge branch 'spi-next' from git://git.kernel.org/pub/scm/linux/kernel/git/broonie/misc.git
    
    Pull in the changes Mark has queued up for SPI

commit 64bee4d28c9e2296f4f12a6c4cc40d085c2c9534
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Fri Nov 30 12:37:53 2012 +0100

    spi / ACPI: add ACPI enumeration support
    
    ACPI 5 introduced SPISerialBus resource that allows us to enumerate and
    configure the SPI slave devices behind the SPI controller. This patch adds
    support for this to the SPI core.
    
    In addition we bind ACPI nodes to SPI devices. This makes it possible for
    the slave drivers to get the ACPI handle for further configuration.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 84c2861d6f4d..1ab05234729f 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -35,6 +35,8 @@
 #include <linux/sched.h>
 #include <linux/delay.h>
 #include <linux/kthread.h>
+#include <linux/ioport.h>
+#include <linux/acpi.h>
 
 static void spidev_release(struct device *dev)
 {
@@ -93,6 +95,10 @@ static int spi_match_device(struct device *dev, struct device_driver *drv)
 	if (of_driver_match_device(dev, drv))
 		return 1;
 
+	/* Then try ACPI */
+	if (acpi_driver_match_device(dev, drv))
+		return 1;
+
 	if (sdrv->id_table)
 		return !!spi_match_id(sdrv->id_table, spi);
 
@@ -888,6 +894,100 @@ static void of_register_spi_devices(struct spi_master *master)
 static void of_register_spi_devices(struct spi_master *master) { }
 #endif
 
+#ifdef CONFIG_ACPI
+static int acpi_spi_add_resource(struct acpi_resource *ares, void *data)
+{
+	struct spi_device *spi = data;
+
+	if (ares->type == ACPI_RESOURCE_TYPE_SERIAL_BUS) {
+		struct acpi_resource_spi_serialbus *sb;
+
+		sb = &ares->data.spi_serial_bus;
+		if (sb->type == ACPI_RESOURCE_SERIAL_TYPE_SPI) {
+			spi->chip_select = sb->device_selection;
+			spi->max_speed_hz = sb->connection_speed;
+
+			if (sb->clock_phase == ACPI_SPI_SECOND_PHASE)
+				spi->mode |= SPI_CPHA;
+			if (sb->clock_polarity == ACPI_SPI_START_HIGH)
+				spi->mode |= SPI_CPOL;
+			if (sb->device_polarity == ACPI_SPI_ACTIVE_HIGH)
+				spi->mode |= SPI_CS_HIGH;
+		}
+	} else if (spi->irq < 0) {
+		struct resource r;
+
+		if (acpi_dev_resource_interrupt(ares, 0, &r))
+			spi->irq = r.start;
+	}
+
+	/* Always tell the ACPI core to skip this resource */
+	return 1;
+}
+
+static acpi_status acpi_spi_add_device(acpi_handle handle, u32 level,
+				       void *data, void **return_value)
+{
+	struct spi_master *master = data;
+	struct list_head resource_list;
+	struct acpi_device *adev;
+	struct spi_device *spi;
+	int ret;
+
+	if (acpi_bus_get_device(handle, &adev))
+		return AE_OK;
+	if (acpi_bus_get_status(adev) || !adev->status.present)
+		return AE_OK;
+
+	spi = spi_alloc_device(master);
+	if (!spi) {
+		dev_err(&master->dev, "failed to allocate SPI device for %s\n",
+			dev_name(&adev->dev));
+		return AE_NO_MEMORY;
+	}
+
+	ACPI_HANDLE_SET(&spi->dev, handle);
+	spi->irq = -1;
+
+	INIT_LIST_HEAD(&resource_list);
+	ret = acpi_dev_get_resources(adev, &resource_list,
+				     acpi_spi_add_resource, spi);
+	acpi_dev_free_resource_list(&resource_list);
+
+	if (ret < 0 || !spi->max_speed_hz) {
+		spi_dev_put(spi);
+		return AE_OK;
+	}
+
+	strlcpy(spi->modalias, dev_name(&adev->dev), sizeof(spi->modalias));
+	if (spi_add_device(spi)) {
+		dev_err(&master->dev, "failed to add SPI device %s from ACPI\n",
+			dev_name(&adev->dev));
+		spi_dev_put(spi);
+	}
+
+	return AE_OK;
+}
+
+static void acpi_register_spi_devices(struct spi_master *master)
+{
+	acpi_status status;
+	acpi_handle handle;
+
+	handle = ACPI_HANDLE(&master->dev);
+	if (!handle)
+		return;
+
+	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,
+				     acpi_spi_add_device, NULL,
+				     master, NULL);
+	if (ACPI_FAILURE(status))
+		dev_warn(&master->dev, "failed to enumerate SPI slaves\n");
+}
+#else
+static inline void acpi_register_spi_devices(struct spi_master *master) {}
+#endif /* CONFIG_ACPI */
+
 static void spi_master_release(struct device *dev)
 {
 	struct spi_master *master;
@@ -1023,8 +1123,9 @@ int spi_register_master(struct spi_master *master)
 		spi_match_master_to_boardinfo(master, &bi->board_info);
 	mutex_unlock(&board_lock);
 
-	/* Register devices from the device tree */
+	/* Register devices from the device tree and ACPI */
 	of_register_spi_devices(master);
+	acpi_register_spi_devices(master);
 done:
 	return status;
 }

commit f3b6159e6a12136ac9c59aaa92ba9f3e484df650
Author: Alexander Sverdlin <alexander.sverdlin@sysgo.com>
Date:   Thu Nov 29 08:59:29 2012 +0100

    of/spi: Honour "status=disabled" property of device
    
    Currently of_register_spi_devices() function registers all SPI devices,
    independetly from their status property in device tree. According to
    "ePAPR 1.1" spec, device should only be registered if there is no
    "status" property, or it has "ok" (or "okay") value (see
    of_device_is_available()). In case of "platform devices",
    of_platform_device_create_pdata() checks for "status" and ensures
    that disabled devices are not pupulated. But such check for SPI buses
    was missing until now. Fix it.
    
    Signed-off-by: Alexander Sverdlin <alexander.sverdlin@sysgo.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 84c2861d6f4d..d3e64080c409 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -819,7 +819,7 @@ static void of_register_spi_devices(struct spi_master *master)
 	if (!master->dev.of_node)
 		return;
 
-	for_each_child_of_node(master->dev.of_node, nc) {
+	for_each_available_child_of_node(master->dev.of_node, nc) {
 		/* Alloc an spi_device */
 		spi = spi_alloc_device(master);
 		if (!spi) {

commit 743179849015dc71bb2ea63d8cd4bfa7fdfb4bc6
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
Date:   Thu Nov 15 20:19:57 2012 +0100

    of_spi: add generic binding support to specify cs gpio
    
    This will allow to use gpio for chip select with no modification in the
    driver binding
    
    When use the cs-gpios, the gpio number will be passed via the cs_gpio field
    and the number of chip select will automatically increased with max(hw cs, gpio cs).
    
    So if for example the controller has 2 CS lines, and the cs-gpios
    property looks like this:
    
    cs-gpios = <&gpio1 0 0> <0> <&gpio1 1 0> <&gpio1 2 0>;
    
    Then it should be configured so that num_chipselect = 4 with the
    following mapping:
    
    cs0 : &gpio1 0 0
    cs1 : native
    cs2 : &gpio1 1 0
    cs3 : &gpio1 2 0
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Cc: devicetree-discuss@lists.ozlabs.org
    Cc: spi-devel-general@lists.sourceforge.net
    Signed-off-by: Richard Genoud <richard.genoud@gmail.com>
    [grant.likely: fixed up type of cs count so min() can do type checking]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 84c2861d6f4d..1587a4a5ff41 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -30,6 +30,7 @@
 #include <linux/slab.h>
 #include <linux/mod_devicetable.h>
 #include <linux/spi/spi.h>
+#include <linux/of_gpio.h>
 #include <linux/pm_runtime.h>
 #include <linux/export.h>
 #include <linux/sched.h>
@@ -327,6 +328,7 @@ struct spi_device *spi_alloc_device(struct spi_master *master)
 	spi->dev.parent = &master->dev;
 	spi->dev.bus = &spi_bus_type;
 	spi->dev.release = spidev_release;
+	spi->cs_gpio = -EINVAL;
 	device_initialize(&spi->dev);
 	return spi;
 }
@@ -344,15 +346,16 @@ EXPORT_SYMBOL_GPL(spi_alloc_device);
 int spi_add_device(struct spi_device *spi)
 {
 	static DEFINE_MUTEX(spi_add_lock);
-	struct device *dev = spi->master->dev.parent;
+	struct spi_master *master = spi->master;
+	struct device *dev = master->dev.parent;
 	struct device *d;
 	int status;
 
 	/* Chipselects are numbered 0..max; validate. */
-	if (spi->chip_select >= spi->master->num_chipselect) {
+	if (spi->chip_select >= master->num_chipselect) {
 		dev_err(dev, "cs%d >= max %d\n",
 			spi->chip_select,
-			spi->master->num_chipselect);
+			master->num_chipselect);
 		return -EINVAL;
 	}
 
@@ -376,6 +379,9 @@ int spi_add_device(struct spi_device *spi)
 		goto done;
 	}
 
+	if (master->cs_gpios)
+		spi->cs_gpio = master->cs_gpios[spi->chip_select];
+
 	/* Drivers may modify this initial i/o setup, but will
 	 * normally rely on the device being setup.  Devices
 	 * using SPI_CS_HIGH can't coexist well otherwise...
@@ -946,6 +952,44 @@ struct spi_master *spi_alloc_master(struct device *dev, unsigned size)
 }
 EXPORT_SYMBOL_GPL(spi_alloc_master);
 
+#ifdef CONFIG_OF
+static int of_spi_register_master(struct spi_master *master)
+{
+	u16 nb;
+	int i, *cs;
+	struct device_node *np = master->dev.of_node;
+
+	if (!np)
+		return 0;
+
+	nb = of_gpio_named_count(np, "cs-gpios");
+	master->num_chipselect = max(nb, master->num_chipselect);
+
+	if (nb < 1)
+		return 0;
+
+	cs = devm_kzalloc(&master->dev,
+			  sizeof(int) * master->num_chipselect,
+			  GFP_KERNEL);
+	master->cs_gpios = cs;
+
+	if (!master->cs_gpios)
+		return -ENOMEM;
+
+	memset(cs, -EINVAL, master->num_chipselect);
+
+	for (i = 0; i < nb; i++)
+		cs[i] = of_get_named_gpio(np, "cs-gpios", i);
+
+	return 0;
+}
+#else
+static int of_spi_register_master(struct spi_master *master)
+{
+	return 0;
+}
+#endif
+
 /**
  * spi_register_master - register SPI master controller
  * @master: initialized master, originally from spi_alloc_master()
@@ -977,6 +1021,10 @@ int spi_register_master(struct spi_master *master)
 	if (!dev)
 		return -ENODEV;
 
+	status = of_spi_register_master(master);
+	if (status)
+		return status;
+
 	/* even if it's just one always-selected device, there must
 	 * be at least one chipselect
 	 */

commit 19f15f0efdbdffeb29072208cfc666f61bf9897a
Merge: fad8f9c0b28f caae070c48f3 24bc89716163
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Nov 9 16:47:00 2012 +0000

    Merge branches 'spi-core' and 'spi-tegra' into spi-next

commit caae070c48f39b4f7312e7473f6d3576f426e7fb
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Fri Nov 9 14:35:22 2012 +0530

    spi: Dont call master->setup if not populated
    
    Currently the master->setup() is called unconditionally.
    The assumption is that every driver need to implement this
    callback. This encourages drivers to populate empty functions
    to prevent crashing.
    
    This patch prevents the call of master->setup() if it is not
    populated.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 84c2861d6f4d..619c7df0d27f 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1156,7 +1156,7 @@ EXPORT_SYMBOL_GPL(spi_busnum_to_master);
 int spi_setup(struct spi_device *spi)
 {
 	unsigned	bad_bits;
-	int		status;
+	int		status = 0;
 
 	/* help drivers fail *cleanly* when they need options
 	 * that aren't supported with their current master
@@ -1171,7 +1171,8 @@ int spi_setup(struct spi_device *spi)
 	if (!spi->bits_per_word)
 		spi->bits_per_word = 8;
 
-	status = spi->master->setup(spi);
+	if (spi->master->setup)
+		status = spi->master->setup(spi);
 
 	dev_dbg(&spi->dev, "setup mode %d, %s%s%s%s"
 				"%u bits/w, %u Hz max --> %d\n",

commit e6811d1d7a6a38ee637fe219c3b67dbfe17e8b3f
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Fri Nov 9 14:36:45 2012 +0530

    spi: make sure all transfer has bits_per_word set
    
    When spi client does the spi transfer and does not sets
    the bits_per_word for each transfer then set it as default
    of spi device in spi core before calling low level transfer.
    
    Removing the similar code from spi-tegra20-slink driver as
    it is not required.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 84c2861d6f4d..518e5955664c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1190,6 +1190,7 @@ EXPORT_SYMBOL_GPL(spi_setup);
 static int __spi_async(struct spi_device *spi, struct spi_message *message)
 {
 	struct spi_master *master = spi->master;
+	struct spi_transfer *xfer;
 
 	/* Half-duplex links include original MicroWire, and ones with
 	 * only one data pin like SPI_3WIRE (switches direction) or where
@@ -1198,7 +1199,6 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
 	 */
 	if ((master->flags & SPI_MASTER_HALF_DUPLEX)
 			|| (spi->mode & SPI_3WIRE)) {
-		struct spi_transfer *xfer;
 		unsigned flags = master->flags;
 
 		list_for_each_entry(xfer, &message->transfers, transfer_list) {
@@ -1211,6 +1211,15 @@ static int __spi_async(struct spi_device *spi, struct spi_message *message)
 		}
 	}
 
+	/**
+	 * Set transfer bits_per_word as spi device default if it is not
+	 * set for this transfer.
+	 */
+	list_for_each_entry(xfer, &message->transfers, transfer_list) {
+		if (!xfer->bits_per_word)
+			xfer->bits_per_word = spi->bits_per_word;
+	}
+
 	message->spi = spi;
 	message->status = -EINPROGRESS;
 	return master->transfer(spi, message);

commit d8e328b3bd65fdefc9c49a27ee80c28e0a44b653
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Sun May 20 00:08:13 2012 -0600

    spi: Add "spi:" prefix to modalias attribute of spi devices
    
    The modalias attribute of spi devices doesn't have the "spi:" prefix
    that is used in the UEVENT and in spi device drivers.  This patch adds
    the prefix so the modprobe can correctly match modules to devices.
    
    Reported-by: David Daney <david.daney@cavium.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 1041cb83d67a..84c2861d6f4d 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -53,7 +53,7 @@ modalias_show(struct device *dev, struct device_attribute *a, char *buf)
 {
 	const struct spi_device	*spi = to_spi_device(dev);
 
-	return sprintf(buf, "%s\n", spi->modalias);
+	return sprintf(buf, "%s%s\n", SPI_MODULE_PREFIX, spi->modalias);
 }
 
 static struct device_attribute spi_dev_attrs[] = {

commit 1e8a52e18cfb381bc9cc1f0b720540364d2a6edd
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Sat May 19 23:42:08 2012 -0600

    spi: By default setup spi_masters with 1 chipselect and dynamics bus number
    
    Trivial simplification.  Instead of requiring spi master drivers to
    always set the bus number (even when a dynamic number is desired),
    this patch modifies spi_alloc_master() to initialize num_chipselect to
    1 (because there will always be at least one CS) and bus_num to -1 for
    dynamic allocation.  This simplifies the code needed to be written for
    drivers.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 2d65b1684cdc..1041cb83d67a 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -936,6 +936,8 @@ struct spi_master *spi_alloc_master(struct device *dev, unsigned size)
 		return NULL;
 
 	device_initialize(&master->dev);
+	master->bus_num = -1;
+	master->num_chipselect = 1;
 	master->dev.class = &spi_master_class;
 	master->dev.parent = get_device(dev);
 	spi_master_set_devdata(master, &master[1]);

commit 7dfd2bd70228d1f8d468d58cb3d12ecd618479ed
Author: Shubhrajyoti D <shubhrajyoti@ti.com>
Date:   Thu May 10 19:20:41 2012 +0530

    spi: Dont call prepare/unprepare transfer if not populated
    
    Currently the prepare/unprepare transfer are called unconditionally.
    The assumption is that every driver using the spi core queue infrastructure
    has to populate the prepare and unprepare functions. This encourages
    drivers to populate empty functions to prevent crashing.
    This patch prevents the call to prepare/unprepare if not populated.
    
    Signed-off-by: Shubhrajyoti D <shubhrajyoti@ti.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    [grant.likely: fix whitespace defect]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 37c555ec59ab..2d65b1684cdc 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -532,7 +532,7 @@ static void spi_pump_messages(struct kthread_work *work)
 	/* Lock queue and check for queue work */
 	spin_lock_irqsave(&master->queue_lock, flags);
 	if (list_empty(&master->queue) || !master->running) {
-		if (master->busy) {
+		if (master->busy && master->unprepare_transfer_hardware) {
 			ret = master->unprepare_transfer_hardware(master);
 			if (ret) {
 				spin_unlock_irqrestore(&master->queue_lock, flags);
@@ -562,7 +562,7 @@ static void spi_pump_messages(struct kthread_work *work)
 		master->busy = true;
 	spin_unlock_irqrestore(&master->queue_lock, flags);
 
-	if (!was_busy) {
+	if (!was_busy && master->prepare_transfer_hardware) {
 		ret = master->prepare_transfer_hardware(master);
 		if (ret) {
 			dev_err(&master->dev,

commit d57a4282d04810417c4ed2a49cbbeda8b3569b18
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Sat Apr 7 14:16:53 2012 -0600

    spi/devicetree: Move devicetree support code into spi directory
    
    The SPI device tree support code isn't shared by any other subsystem.  It can
    be moved into the core drivers/spi directory and the exported symbol can be
    removed.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Rob Herring <rob.herring@calxeda.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 3d8f662e4fe9..37c555ec59ab 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -2,6 +2,7 @@
  * SPI init/core code
  *
  * Copyright (C) 2005 David Brownell
+ * Copyright (C) 2008 Secret Lab Technologies Ltd.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -19,15 +20,16 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/kmod.h>
 #include <linux/device.h>
 #include <linux/init.h>
 #include <linux/cache.h>
 #include <linux/mutex.h>
 #include <linux/of_device.h>
+#include <linux/of_irq.h>
 #include <linux/slab.h>
 #include <linux/mod_devicetable.h>
 #include <linux/spi/spi.h>
-#include <linux/of_spi.h>
 #include <linux/pm_runtime.h>
 #include <linux/export.h>
 #include <linux/sched.h>
@@ -798,6 +800,94 @@ static int spi_master_initialize_queue(struct spi_master *master)
 
 /*-------------------------------------------------------------------------*/
 
+#if defined(CONFIG_OF) && !defined(CONFIG_SPARC)
+/**
+ * of_register_spi_devices() - Register child devices onto the SPI bus
+ * @master:	Pointer to spi_master device
+ *
+ * Registers an spi_device for each child node of master node which has a 'reg'
+ * property.
+ */
+static void of_register_spi_devices(struct spi_master *master)
+{
+	struct spi_device *spi;
+	struct device_node *nc;
+	const __be32 *prop;
+	int rc;
+	int len;
+
+	if (!master->dev.of_node)
+		return;
+
+	for_each_child_of_node(master->dev.of_node, nc) {
+		/* Alloc an spi_device */
+		spi = spi_alloc_device(master);
+		if (!spi) {
+			dev_err(&master->dev, "spi_device alloc error for %s\n",
+				nc->full_name);
+			spi_dev_put(spi);
+			continue;
+		}
+
+		/* Select device driver */
+		if (of_modalias_node(nc, spi->modalias,
+				     sizeof(spi->modalias)) < 0) {
+			dev_err(&master->dev, "cannot find modalias for %s\n",
+				nc->full_name);
+			spi_dev_put(spi);
+			continue;
+		}
+
+		/* Device address */
+		prop = of_get_property(nc, "reg", &len);
+		if (!prop || len < sizeof(*prop)) {
+			dev_err(&master->dev, "%s has no 'reg' property\n",
+				nc->full_name);
+			spi_dev_put(spi);
+			continue;
+		}
+		spi->chip_select = be32_to_cpup(prop);
+
+		/* Mode (clock phase/polarity/etc.) */
+		if (of_find_property(nc, "spi-cpha", NULL))
+			spi->mode |= SPI_CPHA;
+		if (of_find_property(nc, "spi-cpol", NULL))
+			spi->mode |= SPI_CPOL;
+		if (of_find_property(nc, "spi-cs-high", NULL))
+			spi->mode |= SPI_CS_HIGH;
+
+		/* Device speed */
+		prop = of_get_property(nc, "spi-max-frequency", &len);
+		if (!prop || len < sizeof(*prop)) {
+			dev_err(&master->dev, "%s has no 'spi-max-frequency' property\n",
+				nc->full_name);
+			spi_dev_put(spi);
+			continue;
+		}
+		spi->max_speed_hz = be32_to_cpup(prop);
+
+		/* IRQ */
+		spi->irq = irq_of_parse_and_map(nc, 0);
+
+		/* Store a pointer to the node in the device structure */
+		of_node_get(nc);
+		spi->dev.of_node = nc;
+
+		/* Register the new device */
+		request_module(spi->modalias);
+		rc = spi_add_device(spi);
+		if (rc) {
+			dev_err(&master->dev, "spi_device register error %s\n",
+				nc->full_name);
+			spi_dev_put(spi);
+		}
+
+	}
+}
+#else
+static void of_register_spi_devices(struct spi_master *master) { }
+#endif
+
 static void spi_master_release(struct device *dev)
 {
 	struct spi_master *master;

commit a66590de86483eeefc3074ab1ba1a7f45a89308e
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Wed Mar 14 18:37:15 2012 +0100

    spi: remove redundant variable assignment
    
    The status variable is guaranteed to be 0 at that location anyway.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index eb3587a30df2..3d8f662e4fe9 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -931,8 +931,6 @@ int spi_register_master(struct spi_master *master)
 		spi_match_master_to_boardinfo(master, &bi->board_info);
 	mutex_unlock(&board_lock);
 
-	status = 0;
-
 	/* Register devices from the device tree */
 	of_register_spi_devices(master);
 done:

commit 9af4acc096eeb1ddd6f507d291c7c901949224a6
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Sat Mar 10 11:57:29 2012 +0300

    spi: release lock on error path in spi_pump_messages()
    
    We should release the lock here and enable IRQs before returning.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    [grant.likely: move unlock above dev_err() call]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 7ea06af8636a..eb3587a30df2 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -533,6 +533,7 @@ static void spi_pump_messages(struct kthread_work *work)
 		if (master->busy) {
 			ret = master->unprepare_transfer_hardware(master);
 			if (ret) {
+				spin_unlock_irqrestore(&master->queue_lock, flags);
 				dev_err(&master->dev,
 					"failed to unprepare transfer hardware\n");
 				return;

commit 690fb11be34cc908ef895d16c6c1673df1b4667a
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Fri Feb 17 16:23:29 2012 -0800

    spi: Mark spi_register_board_info() __devinit
    
    Some systems have SPI devices located on plugin modules which are
    enumerated at runtime as devices. The drivers for these plugin modules
    need to register their SPI devices at probe() time so want to be able
    to call spi_register_board_info() but that function is currently marked
    as __init rather than __devinit so this usage isn't legal. Change the
    annotation to __devinit to handle this.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index c12a9dba2d82..7ea06af8636a 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -484,7 +484,7 @@ static void spi_match_master_to_boardinfo(struct spi_master *master,
  * The board info passed can safely be __initdata ... but be careful of
  * any embedded pointers (platform_data, etc), they're copied as-is.
  */
-int __init
+int __devinit
 spi_register_board_info(struct spi_board_info const *info, unsigned n)
 {
 	struct boardinfo *bi;

commit eb4af0f5349235df2e4a5057a72fc8962d00308a
Author: Uwe Kleine-KÃ¶nig <u.kleine-koenig@pengutronix.de>
Date:   Thu Feb 23 10:40:14 2012 +0100

    spi/doc: spi_master_put must be followed up by kfree
    
    Signed-off-by: Uwe Kleine-KÃ¶nig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 5ae1e84d9037..c12a9dba2d82 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -830,7 +830,8 @@ static struct class spi_master_class = {
  *
  * The caller is responsible for assigning the bus number and initializing
  * the master's methods before calling spi_register_master(); and (after errors
- * adding the device) calling spi_master_put() to prevent a memory leak.
+ * adding the device) calling spi_master_put() and kfree() to prevent a memory
+ * leak.
  */
 struct spi_master *spi_alloc_master(struct device *dev, unsigned size)
 {

commit ffbbdd21329f3e15eeca6df2d4bc11c04d9d91c0
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Feb 22 10:05:38 2012 +0100

    spi: create a message queueing infrastructure
    
    This rips the message queue in the PL022 driver out and pushes
    it into (optional) common infrastructure. Drivers that want to
    use the message pumping thread will need to define the new
    per-messags transfer methods and leave the deprecated transfer()
    method as NULL.
    
    Most of the design is described in the documentation changes that
    are included in this patch.
    
    Since there is a queue that need to be stopped when the system
    is suspending/resuming, two new calls are implemented for the
    device drivers to call in their suspend()/resume() functions:
    spi_master_suspend() and spi_master_resume().
    
    ChangeLog v1->v2:
    - Remove Kconfig entry and do not make the queue support optional
      at all, instead be more agressive and have it as part of the
      compulsory infrastructure.
    - If the .transfer() method is implemented, delete print a small
      deprecation notice and do not start the transfer pump.
    - Fix a bitrotted comment.
    ChangeLog v2->v3:
    - Fix up a problematic sequence courtesy of Chris Blair.
    - Stop rather than destroy the queue on suspend() courtesy of
      Chris Blair.
    
    Signed-off-by: Chris Blair <chris.blair@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b2ccdea30cb9..5ae1e84d9037 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -30,6 +30,9 @@
 #include <linux/of_spi.h>
 #include <linux/pm_runtime.h>
 #include <linux/export.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/kthread.h>
 
 static void spidev_release(struct device *dev)
 {
@@ -507,6 +510,293 @@ spi_register_board_info(struct spi_board_info const *info, unsigned n)
 
 /*-------------------------------------------------------------------------*/
 
+/**
+ * spi_pump_messages - kthread work function which processes spi message queue
+ * @work: pointer to kthread work struct contained in the master struct
+ *
+ * This function checks if there is any spi message in the queue that
+ * needs processing and if so call out to the driver to initialize hardware
+ * and transfer each message.
+ *
+ */
+static void spi_pump_messages(struct kthread_work *work)
+{
+	struct spi_master *master =
+		container_of(work, struct spi_master, pump_messages);
+	unsigned long flags;
+	bool was_busy = false;
+	int ret;
+
+	/* Lock queue and check for queue work */
+	spin_lock_irqsave(&master->queue_lock, flags);
+	if (list_empty(&master->queue) || !master->running) {
+		if (master->busy) {
+			ret = master->unprepare_transfer_hardware(master);
+			if (ret) {
+				dev_err(&master->dev,
+					"failed to unprepare transfer hardware\n");
+				return;
+			}
+		}
+		master->busy = false;
+		spin_unlock_irqrestore(&master->queue_lock, flags);
+		return;
+	}
+
+	/* Make sure we are not already running a message */
+	if (master->cur_msg) {
+		spin_unlock_irqrestore(&master->queue_lock, flags);
+		return;
+	}
+	/* Extract head of queue */
+	master->cur_msg =
+	    list_entry(master->queue.next, struct spi_message, queue);
+
+	list_del_init(&master->cur_msg->queue);
+	if (master->busy)
+		was_busy = true;
+	else
+		master->busy = true;
+	spin_unlock_irqrestore(&master->queue_lock, flags);
+
+	if (!was_busy) {
+		ret = master->prepare_transfer_hardware(master);
+		if (ret) {
+			dev_err(&master->dev,
+				"failed to prepare transfer hardware\n");
+			return;
+		}
+	}
+
+	ret = master->transfer_one_message(master, master->cur_msg);
+	if (ret) {
+		dev_err(&master->dev,
+			"failed to transfer one message from queue\n");
+		return;
+	}
+}
+
+static int spi_init_queue(struct spi_master *master)
+{
+	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };
+
+	INIT_LIST_HEAD(&master->queue);
+	spin_lock_init(&master->queue_lock);
+
+	master->running = false;
+	master->busy = false;
+
+	init_kthread_worker(&master->kworker);
+	master->kworker_task = kthread_run(kthread_worker_fn,
+					   &master->kworker,
+					   dev_name(&master->dev));
+	if (IS_ERR(master->kworker_task)) {
+		dev_err(&master->dev, "failed to create message pump task\n");
+		return -ENOMEM;
+	}
+	init_kthread_work(&master->pump_messages, spi_pump_messages);
+
+	/*
+	 * Master config will indicate if this controller should run the
+	 * message pump with high (realtime) priority to reduce the transfer
+	 * latency on the bus by minimising the delay between a transfer
+	 * request and the scheduling of the message pump thread. Without this
+	 * setting the message pump thread will remain at default priority.
+	 */
+	if (master->rt) {
+		dev_info(&master->dev,
+			"will run message pump with realtime priority\n");
+		sched_setscheduler(master->kworker_task, SCHED_FIFO, &param);
+	}
+
+	return 0;
+}
+
+/**
+ * spi_get_next_queued_message() - called by driver to check for queued
+ * messages
+ * @master: the master to check for queued messages
+ *
+ * If there are more messages in the queue, the next message is returned from
+ * this call.
+ */
+struct spi_message *spi_get_next_queued_message(struct spi_master *master)
+{
+	struct spi_message *next;
+	unsigned long flags;
+
+	/* get a pointer to the next message, if any */
+	spin_lock_irqsave(&master->queue_lock, flags);
+	if (list_empty(&master->queue))
+		next = NULL;
+	else
+		next = list_entry(master->queue.next,
+				  struct spi_message, queue);
+	spin_unlock_irqrestore(&master->queue_lock, flags);
+
+	return next;
+}
+EXPORT_SYMBOL_GPL(spi_get_next_queued_message);
+
+/**
+ * spi_finalize_current_message() - the current message is complete
+ * @master: the master to return the message to
+ *
+ * Called by the driver to notify the core that the message in the front of the
+ * queue is complete and can be removed from the queue.
+ */
+void spi_finalize_current_message(struct spi_master *master)
+{
+	struct spi_message *mesg;
+	unsigned long flags;
+
+	spin_lock_irqsave(&master->queue_lock, flags);
+	mesg = master->cur_msg;
+	master->cur_msg = NULL;
+
+	queue_kthread_work(&master->kworker, &master->pump_messages);
+	spin_unlock_irqrestore(&master->queue_lock, flags);
+
+	mesg->state = NULL;
+	if (mesg->complete)
+		mesg->complete(mesg->context);
+}
+EXPORT_SYMBOL_GPL(spi_finalize_current_message);
+
+static int spi_start_queue(struct spi_master *master)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&master->queue_lock, flags);
+
+	if (master->running || master->busy) {
+		spin_unlock_irqrestore(&master->queue_lock, flags);
+		return -EBUSY;
+	}
+
+	master->running = true;
+	master->cur_msg = NULL;
+	spin_unlock_irqrestore(&master->queue_lock, flags);
+
+	queue_kthread_work(&master->kworker, &master->pump_messages);
+
+	return 0;
+}
+
+static int spi_stop_queue(struct spi_master *master)
+{
+	unsigned long flags;
+	unsigned limit = 500;
+	int ret = 0;
+
+	spin_lock_irqsave(&master->queue_lock, flags);
+
+	/*
+	 * This is a bit lame, but is optimized for the common execution path.
+	 * A wait_queue on the master->busy could be used, but then the common
+	 * execution path (pump_messages) would be required to call wake_up or
+	 * friends on every SPI message. Do this instead.
+	 */
+	while ((!list_empty(&master->queue) || master->busy) && limit--) {
+		spin_unlock_irqrestore(&master->queue_lock, flags);
+		msleep(10);
+		spin_lock_irqsave(&master->queue_lock, flags);
+	}
+
+	if (!list_empty(&master->queue) || master->busy)
+		ret = -EBUSY;
+	else
+		master->running = false;
+
+	spin_unlock_irqrestore(&master->queue_lock, flags);
+
+	if (ret) {
+		dev_warn(&master->dev,
+			 "could not stop message queue\n");
+		return ret;
+	}
+	return ret;
+}
+
+static int spi_destroy_queue(struct spi_master *master)
+{
+	int ret;
+
+	ret = spi_stop_queue(master);
+
+	/*
+	 * flush_kthread_worker will block until all work is done.
+	 * If the reason that stop_queue timed out is that the work will never
+	 * finish, then it does no good to call flush/stop thread, so
+	 * return anyway.
+	 */
+	if (ret) {
+		dev_err(&master->dev, "problem destroying queue\n");
+		return ret;
+	}
+
+	flush_kthread_worker(&master->kworker);
+	kthread_stop(master->kworker_task);
+
+	return 0;
+}
+
+/**
+ * spi_queued_transfer - transfer function for queued transfers
+ * @spi: spi device which is requesting transfer
+ * @msg: spi message which is to handled is queued to driver queue
+ */
+static int spi_queued_transfer(struct spi_device *spi, struct spi_message *msg)
+{
+	struct spi_master *master = spi->master;
+	unsigned long flags;
+
+	spin_lock_irqsave(&master->queue_lock, flags);
+
+	if (!master->running) {
+		spin_unlock_irqrestore(&master->queue_lock, flags);
+		return -ESHUTDOWN;
+	}
+	msg->actual_length = 0;
+	msg->status = -EINPROGRESS;
+
+	list_add_tail(&msg->queue, &master->queue);
+	if (master->running && !master->busy)
+		queue_kthread_work(&master->kworker, &master->pump_messages);
+
+	spin_unlock_irqrestore(&master->queue_lock, flags);
+	return 0;
+}
+
+static int spi_master_initialize_queue(struct spi_master *master)
+{
+	int ret;
+
+	master->queued = true;
+	master->transfer = spi_queued_transfer;
+
+	/* Initialize and start queue */
+	ret = spi_init_queue(master);
+	if (ret) {
+		dev_err(&master->dev, "problem initializing queue\n");
+		goto err_init_queue;
+	}
+	ret = spi_start_queue(master);
+	if (ret) {
+		dev_err(&master->dev, "problem starting queue\n");
+		goto err_start_queue;
+	}
+
+	return 0;
+
+err_start_queue:
+err_init_queue:
+	spi_destroy_queue(master);
+	return ret;
+}
+
+/*-------------------------------------------------------------------------*/
+
 static void spi_master_release(struct device *dev)
 {
 	struct spi_master *master;
@@ -522,6 +812,7 @@ static struct class spi_master_class = {
 };
 
 
+
 /**
  * spi_alloc_master - allocate SPI master controller
  * @dev: the controller, possibly using the platform_bus
@@ -621,6 +912,17 @@ int spi_register_master(struct spi_master *master)
 	dev_dbg(dev, "registered master %s%s\n", dev_name(&master->dev),
 			dynamic ? " (dynamic)" : "");
 
+	/* If we're using a queued driver, start the queue */
+	if (master->transfer)
+		dev_info(dev, "master is unqueued, this is deprecated\n");
+	else {
+		status = spi_master_initialize_queue(master);
+		if (status) {
+			device_unregister(&master->dev);
+			goto done;
+		}
+	}
+
 	mutex_lock(&board_lock);
 	list_add_tail(&master->list, &spi_master_list);
 	list_for_each_entry(bi, &board_list, list)
@@ -636,7 +938,6 @@ int spi_register_master(struct spi_master *master)
 }
 EXPORT_SYMBOL_GPL(spi_register_master);
 
-
 static int __unregister(struct device *dev, void *null)
 {
 	spi_unregister_device(to_spi_device(dev));
@@ -657,6 +958,11 @@ void spi_unregister_master(struct spi_master *master)
 {
 	int dummy;
 
+	if (master->queued) {
+		if (spi_destroy_queue(master))
+			dev_err(&master->dev, "queue remove failed\n");
+	}
+
 	mutex_lock(&board_lock);
 	list_del(&master->list);
 	mutex_unlock(&board_lock);
@@ -666,6 +972,37 @@ void spi_unregister_master(struct spi_master *master)
 }
 EXPORT_SYMBOL_GPL(spi_unregister_master);
 
+int spi_master_suspend(struct spi_master *master)
+{
+	int ret;
+
+	/* Basically no-ops for non-queued masters */
+	if (!master->queued)
+		return 0;
+
+	ret = spi_stop_queue(master);
+	if (ret)
+		dev_err(&master->dev, "queue stop failed\n");
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(spi_master_suspend);
+
+int spi_master_resume(struct spi_master *master)
+{
+	int ret;
+
+	if (!master->queued)
+		return 0;
+
+	ret = spi_start_queue(master);
+	if (ret)
+		dev_err(&master->dev, "queue restart failed\n");
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(spi_master_resume);
+
 static int __spi_master_match(struct device *dev, void *data)
 {
 	struct spi_master *m;

commit 178db7d30f94707efca1a189753c105ef69942ed
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Mon Dec 12 01:15:06 2011 +0100

    spi: Fix device unregistration when unregistering the bus master
    
    Device are added as children of the bus master's parent device, but
    spi_unregister_master() looks for devices to unregister in the bus
    master's children. This results in the child devices not being
    unregistered.
    
    Fix this by registering devices as direct children of the bus master.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 77eae99af11c..b2ccdea30cb9 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -319,7 +319,7 @@ struct spi_device *spi_alloc_device(struct spi_master *master)
 	}
 
 	spi->master = master;
-	spi->dev.parent = dev;
+	spi->dev.parent = &master->dev;
 	spi->dev.bus = &spi_bus_type;
 	spi->dev.release = spidev_release;
 	device_initialize(&spi->dev);

commit 025ed130608766bf2a18523a1ac11a860746a4e4
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 10 12:57:55 2011 -0400

    spi: Add export.h for THIS_MODULE/EXPORT_SYMBOL to spi.c
    
    This uses both EXPORT_SYMBOL and THIS_MODULE, both which come from
    the export.h file now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 4d1b9f517ce8..77eae99af11c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -29,6 +29,7 @@
 #include <linux/spi/spi.h>
 #include <linux/of_spi.h>
 #include <linux/pm_runtime.h>
+#include <linux/export.h>
 
 static void spidev_release(struct device *dev)
 {

commit ca632f556697d45d67ed5cada7cedf3ddfe0db4b
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Jun 6 01:16:30 2011 -0600

    spi: reorganize drivers
    
    Sort the SPI makefile and enforce the naming convention spi_*.c for
    spi drivers.
    
    This change also rolls the contents of atmel_spi.h into the .c file
    since there is only one user of that particular include file.
    
    v2: - Use 'spi-' prefix instead of 'spi_' to match what seems to be
          be the predominant pattern for subsystem prefixes.
        - Clean up filenames in Kconfig and header comment blocks
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 2e13a14bba3f..4d1b9f517ce8 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1,5 +1,5 @@
 /*
- * spi.c - SPI init/core code
+ * SPI init/core code
  *
  * Copyright (C) 2005 David Brownell
  *

commit 0c4a1590189b426814748d2e03b95541852b3af6
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Wed May 11 00:09:30 2011 +0200

    spi: Use void pointers for data in simple SPI I/O operations
    
    Currently the simple SPI I/O operations all take pointers to u8 * buffers
    to operate on. This creates needless type compatibility issues and the
    underlying spi_transfer structure uses void pointers anyway so convert the
    API over to take void pointers too.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 82b9a428c323..2e13a14bba3f 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -1047,8 +1047,8 @@ static u8	*buf;
  * spi_{async,sync}() calls with dma-safe buffers.
  */
 int spi_write_then_read(struct spi_device *spi,
-		const u8 *txbuf, unsigned n_tx,
-		u8 *rxbuf, unsigned n_rx)
+		const void *txbuf, unsigned n_tx,
+		void *rxbuf, unsigned n_rx)
 {
 	static DEFINE_MUTEX(lock);
 

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 34bb17f03019..82b9a428c323 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -957,7 +957,7 @@ EXPORT_SYMBOL_GPL(spi_sync);
  * drivers may DMA directly into and out of the message buffers.
  *
  * This call should be used by drivers that require exclusive access to the
- * SPI bus. It has to be preceeded by a spi_bus_lock call. The SPI bus must
+ * SPI bus. It has to be preceded by a spi_bus_lock call. The SPI bus must
  * be released by a spi_bus_unlock call when the exclusive access is over.
  *
  * It returns zero on success, else a negative error code.

commit 3ae22e8c8ac39daf88ae32f047fb23825be7c646
Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
Date:   Sat Dec 25 15:32:27 2010 +0100

    spi / PM: Support dev_pm_ops
    
    Allow SPI drivers to use runtime PM and other dev_pm_ops features by
    implementing dev_pm_ops for the bus. The existing bus specific suspend
    and resume functions will be called if a driver does not provide dev_pm_ops
    allowing for transition to the new model.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b02d0cbce890..34bb17f03019 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -28,6 +28,7 @@
 #include <linux/mod_devicetable.h>
 #include <linux/spi/spi.h>
 #include <linux/of_spi.h>
+#include <linux/pm_runtime.h>
 
 static void spidev_release(struct device *dev)
 {
@@ -100,9 +101,8 @@ static int spi_uevent(struct device *dev, struct kobj_uevent_env *env)
 	return 0;
 }
 
-#ifdef	CONFIG_PM
-
-static int spi_suspend(struct device *dev, pm_message_t message)
+#ifdef CONFIG_PM_SLEEP
+static int spi_legacy_suspend(struct device *dev, pm_message_t message)
 {
 	int			value = 0;
 	struct spi_driver	*drv = to_spi_driver(dev->driver);
@@ -117,7 +117,7 @@ static int spi_suspend(struct device *dev, pm_message_t message)
 	return value;
 }
 
-static int spi_resume(struct device *dev)
+static int spi_legacy_resume(struct device *dev)
 {
 	int			value = 0;
 	struct spi_driver	*drv = to_spi_driver(dev->driver);
@@ -132,18 +132,94 @@ static int spi_resume(struct device *dev)
 	return value;
 }
 
+static int spi_pm_suspend(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_suspend(dev);
+	else
+		return spi_legacy_suspend(dev, PMSG_SUSPEND);
+}
+
+static int spi_pm_resume(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_resume(dev);
+	else
+		return spi_legacy_resume(dev);
+}
+
+static int spi_pm_freeze(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_freeze(dev);
+	else
+		return spi_legacy_suspend(dev, PMSG_FREEZE);
+}
+
+static int spi_pm_thaw(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_thaw(dev);
+	else
+		return spi_legacy_resume(dev);
+}
+
+static int spi_pm_poweroff(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_poweroff(dev);
+	else
+		return spi_legacy_suspend(dev, PMSG_HIBERNATE);
+}
+
+static int spi_pm_restore(struct device *dev)
+{
+	const struct dev_pm_ops *pm = dev->driver ? dev->driver->pm : NULL;
+
+	if (pm)
+		return pm_generic_restore(dev);
+	else
+		return spi_legacy_resume(dev);
+}
 #else
-#define spi_suspend	NULL
-#define spi_resume	NULL
+#define spi_pm_suspend	NULL
+#define spi_pm_resume	NULL
+#define spi_pm_freeze	NULL
+#define spi_pm_thaw	NULL
+#define spi_pm_poweroff	NULL
+#define spi_pm_restore	NULL
 #endif
 
+static const struct dev_pm_ops spi_pm = {
+	.suspend = spi_pm_suspend,
+	.resume = spi_pm_resume,
+	.freeze = spi_pm_freeze,
+	.thaw = spi_pm_thaw,
+	.poweroff = spi_pm_poweroff,
+	.restore = spi_pm_restore,
+	SET_RUNTIME_PM_OPS(
+		pm_generic_runtime_suspend,
+		pm_generic_runtime_resume,
+		pm_generic_runtime_idle
+	)
+};
+
 struct bus_type spi_bus_type = {
 	.name		= "spi",
 	.dev_attrs	= spi_dev_attrs,
 	.match		= spi_match_device,
 	.uevent		= spi_uevent,
-	.suspend	= spi_suspend,
-	.resume		= spi_resume,
+	.pm		= &spi_pm,
 };
 EXPORT_SYMBOL_GPL(spi_bus_type);
 

commit 97dbf37d89b6d387a5fe79ffe3b72c37ec12db43
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Tue Dec 21 17:24:31 2010 -0800

    drivers/spi/spi.c: don't release the spi device twice
    
    This was fixed by David Lamparter in v2.6.36-rc5 3486008 ("spi: free
    children in spi_unregister_master, not siblings") and broken again in
    v2.6.37-rc1~2^2~4 during the merge of 2b9603a0 ("spi: enable
    spi_board_info to be registered after spi_master").
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: David Lamparter <equinox@diac24.net>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 709c836607de..b02d0cbce890 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -584,8 +584,7 @@ void spi_unregister_master(struct spi_master *master)
 	list_del(&master->list);
 	mutex_unlock(&board_lock);
 
-	dummy = device_for_each_child(master->dev.parent, &master->dev,
-					__unregister);
+	dummy = device_for_each_child(&master->dev, NULL, __unregister);
 	device_unregister(&master->dev);
 }
 EXPORT_SYMBOL_GPL(spi_unregister_master);

commit eb288a1f45e2aa903ac8edf67dc6d59df0369fe1
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Thu Oct 21 21:06:44 2010 +0200

    spi: fixed odd static string conventions in core code
    
    This patch removes convention of passing a static string as a
    parameter to another static string.  The convention is intended to
    reduce text usage by sharing the common bits of the string, but the
    implementation is inherently fragile (a change to one format string
    but not the other will nullify any possible advantage), it isn't
    necessarily a net win depending on what this compiler does, and it
    it reduces code readability.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    [grant.likely@secretlab.ca: removed dev_dbg->dev_err hunk]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 0845cd4c5155..709c836607de 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -300,16 +300,16 @@ int spi_add_device(struct spi_device *spi)
 	 */
 	status = spi_setup(spi);
 	if (status < 0) {
-		dev_err(dev, "can't %s %s, status %d\n",
-				"setup", dev_name(&spi->dev), status);
+		dev_err(dev, "can't setup %s, status %d\n",
+				dev_name(&spi->dev), status);
 		goto done;
 	}
 
 	/* Device may be bound to an active driver when this returns */
 	status = device_add(&spi->dev);
 	if (status < 0)
-		dev_err(dev, "can't %s %s, status %d\n",
-				"add", dev_name(&spi->dev), status);
+		dev_err(dev, "can't add %s, status %d\n",
+				dev_name(&spi->dev), status);
 	else
 		dev_dbg(dev, "registered child %s\n", dev_name(&spi->dev));
 
@@ -658,7 +658,7 @@ int spi_setup(struct spi_device *spi)
 	 */
 	bad_bits = spi->mode & ~spi->master->mode_bits;
 	if (bad_bits) {
-		dev_dbg(&spi->dev, "setup: unsupported mode bits %x\n",
+		dev_err(&spi->dev, "setup: unsupported mode bits %x\n",
 			bad_bits);
 		return -EINVAL;
 	}

commit 2b9603a0d7e395fb844af90fba71448bc8019077
Author: Feng Tang <feng.tang@intel.com>
Date:   Mon Aug 2 15:52:15 2010 +0800

    spi: enable spi_board_info to be registered after spi_master
    
    Currently spi_register_board_info() has to be called before its related
    spi_master be registered, otherwise these board info will be just ignored.
    
    This patch will remove this order limit, it adds a global spi master list
    like the existing global board info listr. Whenever a board info or a
    spi_master is registered, the spi master list or board info list
    will be scanned, and a new spi device will be created if there is a
    master-board info match.
    
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b5a78a1f4421..0845cd4c5155 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -29,11 +29,6 @@
 #include <linux/spi/spi.h>
 #include <linux/of_spi.h>
 
-
-/* SPI bustype and spi_master class are registered after board init code
- * provides the SPI device tables, ensuring that both are present by the
- * time controller driver registration causes spi_devices to "enumerate".
- */
 static void spidev_release(struct device *dev)
 {
 	struct spi_device	*spi = to_spi_device(dev);
@@ -202,11 +197,16 @@ EXPORT_SYMBOL_GPL(spi_register_driver);
 
 struct boardinfo {
 	struct list_head	list;
-	unsigned		n_board_info;
-	struct spi_board_info	board_info[0];
+	struct spi_board_info	board_info;
 };
 
 static LIST_HEAD(board_list);
+static LIST_HEAD(spi_master_list);
+
+/*
+ * Used to protect add/del opertion for board_info list and
+ * spi_master list, and their matching process
+ */
 static DEFINE_MUTEX(board_lock);
 
 /**
@@ -371,6 +371,20 @@ struct spi_device *spi_new_device(struct spi_master *master,
 }
 EXPORT_SYMBOL_GPL(spi_new_device);
 
+static void spi_match_master_to_boardinfo(struct spi_master *master,
+				struct spi_board_info *bi)
+{
+	struct spi_device *dev;
+
+	if (master->bus_num != bi->bus_num)
+		return;
+
+	dev = spi_new_device(master, bi);
+	if (!dev)
+		dev_err(master->dev.parent, "can't create new device for %s\n",
+			bi->modalias);
+}
+
 /**
  * spi_register_board_info - register SPI devices for a given board
  * @info: array of chip descriptors
@@ -393,43 +407,25 @@ EXPORT_SYMBOL_GPL(spi_new_device);
 int __init
 spi_register_board_info(struct spi_board_info const *info, unsigned n)
 {
-	struct boardinfo	*bi;
+	struct boardinfo *bi;
+	int i;
 
-	bi = kmalloc(sizeof(*bi) + n * sizeof *info, GFP_KERNEL);
+	bi = kzalloc(n * sizeof(*bi), GFP_KERNEL);
 	if (!bi)
 		return -ENOMEM;
-	bi->n_board_info = n;
-	memcpy(bi->board_info, info, n * sizeof *info);
 
-	mutex_lock(&board_lock);
-	list_add_tail(&bi->list, &board_list);
-	mutex_unlock(&board_lock);
-	return 0;
-}
+	for (i = 0; i < n; i++, bi++, info++) {
+		struct spi_master *master;
 
-/* FIXME someone should add support for a __setup("spi", ...) that
- * creates board info from kernel command lines
- */
-
-static void scan_boardinfo(struct spi_master *master)
-{
-	struct boardinfo	*bi;
-
-	mutex_lock(&board_lock);
-	list_for_each_entry(bi, &board_list, list) {
-		struct spi_board_info	*chip = bi->board_info;
-		unsigned		n;
-
-		for (n = bi->n_board_info; n > 0; n--, chip++) {
-			if (chip->bus_num != master->bus_num)
-				continue;
-			/* NOTE: this relies on spi_new_device to
-			 * issue diagnostics when given bogus inputs
-			 */
-			(void) spi_new_device(master, chip);
-		}
+		memcpy(&bi->board_info, info, sizeof(*info));
+		mutex_lock(&board_lock);
+		list_add_tail(&bi->list, &board_list);
+		list_for_each_entry(master, &spi_master_list, list)
+			spi_match_master_to_boardinfo(master, &bi->board_info);
+		mutex_unlock(&board_lock);
 	}
-	mutex_unlock(&board_lock);
+
+	return 0;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -512,6 +508,7 @@ int spi_register_master(struct spi_master *master)
 {
 	static atomic_t		dyn_bus_id = ATOMIC_INIT((1<<15) - 1);
 	struct device		*dev = master->dev.parent;
+	struct boardinfo	*bi;
 	int			status = -ENODEV;
 	int			dynamic = 0;
 
@@ -547,8 +544,12 @@ int spi_register_master(struct spi_master *master)
 	dev_dbg(dev, "registered master %s%s\n", dev_name(&master->dev),
 			dynamic ? " (dynamic)" : "");
 
-	/* populate children from any spi device tables */
-	scan_boardinfo(master);
+	mutex_lock(&board_lock);
+	list_add_tail(&master->list, &spi_master_list);
+	list_for_each_entry(bi, &board_list, list)
+		spi_match_master_to_boardinfo(master, &bi->board_info);
+	mutex_unlock(&board_lock);
+
 	status = 0;
 
 	/* Register devices from the device tree */
@@ -579,7 +580,12 @@ void spi_unregister_master(struct spi_master *master)
 {
 	int dummy;
 
-	dummy = device_for_each_child(&master->dev, NULL, __unregister);
+	mutex_lock(&board_lock);
+	list_del(&master->list);
+	mutex_unlock(&board_lock);
+
+	dummy = device_for_each_child(master->dev.parent, &master->dev,
+					__unregister);
 	device_unregister(&master->dev);
 }
 EXPORT_SYMBOL_GPL(spi_unregister_master);

commit 2b7a32f7ecb24d01bd0b2d5097d7c7ebe7082ba7
Author: Sinan Akman <sinan@writeme.com>
Date:   Sat Oct 2 21:28:29 2010 -0600

    of/spi: Fix OF-style driver binding of spi devices
    
    This patch adds the OF hook to the spi core so that devices
    can automatically be registered based on device tree data.  This fixes
    a problem with spi devices not binding to drivers after the cleanup of
    the spi & i2c binding code.
    
    Signed-off-by: Sinan Akman <sinan@writeme.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 0bcf4c1601a2..b5a78a1f4421 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -23,6 +23,7 @@
 #include <linux/init.h>
 #include <linux/cache.h>
 #include <linux/mutex.h>
+#include <linux/of_device.h>
 #include <linux/slab.h>
 #include <linux/mod_devicetable.h>
 #include <linux/spi/spi.h>
@@ -86,6 +87,10 @@ static int spi_match_device(struct device *dev, struct device_driver *drv)
 	const struct spi_device	*spi = to_spi_device(dev);
 	const struct spi_driver	*sdrv = to_spi_driver(drv);
 
+	/* Attempt an OF style match */
+	if (of_driver_match_device(dev, drv))
+		return 1;
+
 	if (sdrv->id_table)
 		return !!spi_match_id(sdrv->id_table, spi);
 

commit 34860089c9e8abcc77428d29743b37ff756197e7
Author: David Lamparter <equinox@diac24.net>
Date:   Mon Aug 30 23:54:17 2010 +0200

    spi: free children in spi_unregister_master, not siblings
    
    introduced by 49dce689 ("spi doesn't need class_device") and bad-fixed
    by 350d0076 ("spi: fix double-free on spi_unregister_master"),
    spi_unregister_master would previously device_unregister all of the spi
    master's siblings (instead of its children). hilarity ensues.
    
    fix it to unregister children.
    
    Signed-off-by: David Lamparter <equinox@diac24.net>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index a9e5c79ae52a..0bcf4c1601a2 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -554,11 +554,9 @@ int spi_register_master(struct spi_master *master)
 EXPORT_SYMBOL_GPL(spi_register_master);
 
 
-static int __unregister(struct device *dev, void *master_dev)
+static int __unregister(struct device *dev, void *null)
 {
-	/* note: before about 2.6.14-rc1 this would corrupt memory: */
-	if (dev != master_dev)
-		spi_unregister_device(to_spi_device(dev));
+	spi_unregister_device(to_spi_device(dev));
 	return 0;
 }
 
@@ -576,8 +574,7 @@ void spi_unregister_master(struct spi_master *master)
 {
 	int dummy;
 
-	dummy = device_for_each_child(master->dev.parent, &master->dev,
-					__unregister);
+	dummy = device_for_each_child(&master->dev, NULL, __unregister);
 	device_unregister(&master->dev);
 }
 EXPORT_SYMBOL_GPL(spi_unregister_master);

commit b171aa27700c78511086a759383b033949c9d7f0
Merge: 11ac552477e3 b4225885deb5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Aug 14 11:54:09 2010 -0700

    Merge branch 'next-spi' of git://git.secretlab.ca/git/linux-2.6
    
    * 'next-spi' of git://git.secretlab.ca/git/linux-2.6:
      spi/amba_pl022: Fix probe and remove hook section annotations.
      spi/mpc5121: change annotations for probe and remove functions
      spi/bitbang: reinitialize transfer parameters for every message
      spi/spi-gpio: add support for controllers without MISO or MOSI pin
      spi/bitbang: add support for SPI_MASTER_NO_{TX, RX} modes
      SPI100k: Fix 8-bit and RX-only transfers
      spi/mmc_spi: mmc_spi adaptations for SPI bus locking API
      spi/mmc_spi: SPI bus locking API, using mutex
    
    Fix trivial conflict in drivers/spi/mpc512x_psc_spi.c due to 'struct
    of_device' => 'struct platform_device' rename and __init/__exit to
    __devinit/__devexit fix.

commit 12b15e83289bc7cf2ec9a342412e0c955beeb395
Author: Anatolij Gustschin <agust@denx.de>
Date:   Tue Jul 27 22:35:58 2010 +0200

    of/spi: call of_register_spi_devices() from spi core code
    
    Move of_register_spi_devices() call from drivers to
    spi_register_master(). Also change the function to use
    the struct device_node pointer from master spi device
    instead of passing it as function argument.
    
    Signed-off-by: Anatolij Gustschin <agust@denx.de>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b3a1f9259b62..1bb1b88780ce 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -26,6 +26,7 @@
 #include <linux/slab.h>
 #include <linux/mod_devicetable.h>
 #include <linux/spi/spi.h>
+#include <linux/of_spi.h>
 
 
 /* SPI bustype and spi_master class are registered after board init code
@@ -540,6 +541,9 @@ int spi_register_master(struct spi_master *master)
 	/* populate children from any spi device tables */
 	scan_boardinfo(master);
 	status = 0;
+
+	/* Register devices from the device tree */
+	of_register_spi_devices(master);
 done:
 	return status;
 }

commit cf32b71e981ca63e8f349d8585ca2a3583b556e0
Author: Ernst Schwab <eschwab@online.de>
Date:   Mon Jun 28 17:49:29 2010 -0700

    spi/mmc_spi: SPI bus locking API, using mutex
    
    SPI bus locking API to allow exclusive access to the SPI bus, especially, but
    not limited to, for the mmc_spi driver.
    
    Coded according to an outline from Grant Likely; here is his
    specification (accidentally swapped function names corrected):
    
    It requires 3 things to be added to struct spi_master.
    - 1 Mutex
    - 1 spin lock
    - 1 flag.
    
    The mutex protects spi_sync, and provides sleeping "for free"
    The spinlock protects the atomic spi_async call.
    The flag is set when the lock is obtained, and checked while holding
    the spinlock in spi_async().  If the flag is checked, then spi_async()
    must fail immediately.
    
    The current runtime API looks like this:
    spi_async(struct spi_device*, struct spi_message*);
    spi_sync(struct spi_device*, struct spi_message*);
    
    The API needs to be extended to this:
    spi_async(struct spi_device*, struct spi_message*)
    spi_sync(struct spi_device*, struct spi_message*)
    spi_bus_lock(struct spi_master*)  /* although struct spi_device* might
    be easier */
    spi_bus_unlock(struct spi_master*)
    spi_async_locked(struct spi_device*, struct spi_message*)
    spi_sync_locked(struct spi_device*, struct spi_message*)
    
    Drivers can only call the last two if they already hold the spi_master_lock().
    
    spi_bus_lock() obtains the mutex, obtains the spin lock, sets the
    flag, and releases the spin lock before returning.  It doesn't even
    need to sleep while waiting for "in-flight" spi_transactions to
    complete because its purpose is to guarantee no additional
    transactions are added.  It does not guarantee that the bus is idle.
    
    spi_bus_unlock() clears the flag and releases the mutex, which will
    wake up any waiters.
    
    The difference between spi_async() and spi_async_locked() is that the
    locked version bypasses the check of the lock flag.  Both versions
    need to obtain the spinlock.
    
    The difference between spi_sync() and spi_sync_locked() is that
    spi_sync() must hold the mutex while enqueuing a new transfer.
    spi_sync_locked() doesn't because the mutex is already held.  Note
    however that spi_sync must *not* continue to hold the mutex while
    waiting for the transfer to complete, otherwise only one transfer
    could be queued up at a time!
    
    Almost no code needs to be written.  The current spi_async() and
    spi_sync() can probably be renamed to __spi_async() and __spi_sync()
    so that spi_async(), spi_sync(), spi_async_locked() and
    spi_sync_locked() can just become wrappers around the common code.
    
    spi_sync() is protected by a mutex because it can sleep
    spi_async() needs to be protected with a flag and a spinlock because
    it can be called atomically and must not sleep
    
    Signed-off-by: Ernst Schwab <eschwab@online.de>
    [grant.likely@secretlab.ca: use spin_lock_irqsave()]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Tested-by: Matt Fleming <matt@console-pimps.org>
    Tested-by: Antonio Ospite <ospite@studenti.unina.it>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b3a1f9259b62..fdde7061ef58 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -527,6 +527,10 @@ int spi_register_master(struct spi_master *master)
 		dynamic = 1;
 	}
 
+	spin_lock_init(&master->bus_lock_spinlock);
+	mutex_init(&master->bus_lock_mutex);
+	master->bus_lock_flag = 0;
+
 	/* register the device, then userspace will see it.
 	 * registration fails if the bus ID is in use.
 	 */
@@ -666,6 +670,35 @@ int spi_setup(struct spi_device *spi)
 }
 EXPORT_SYMBOL_GPL(spi_setup);
 
+static int __spi_async(struct spi_device *spi, struct spi_message *message)
+{
+	struct spi_master *master = spi->master;
+
+	/* Half-duplex links include original MicroWire, and ones with
+	 * only one data pin like SPI_3WIRE (switches direction) or where
+	 * either MOSI or MISO is missing.  They can also be caused by
+	 * software limitations.
+	 */
+	if ((master->flags & SPI_MASTER_HALF_DUPLEX)
+			|| (spi->mode & SPI_3WIRE)) {
+		struct spi_transfer *xfer;
+		unsigned flags = master->flags;
+
+		list_for_each_entry(xfer, &message->transfers, transfer_list) {
+			if (xfer->rx_buf && xfer->tx_buf)
+				return -EINVAL;
+			if ((flags & SPI_MASTER_NO_TX) && xfer->tx_buf)
+				return -EINVAL;
+			if ((flags & SPI_MASTER_NO_RX) && xfer->rx_buf)
+				return -EINVAL;
+		}
+	}
+
+	message->spi = spi;
+	message->status = -EINPROGRESS;
+	return master->transfer(spi, message);
+}
+
 /**
  * spi_async - asynchronous SPI transfer
  * @spi: device with which data will be exchanged
@@ -698,33 +731,68 @@ EXPORT_SYMBOL_GPL(spi_setup);
 int spi_async(struct spi_device *spi, struct spi_message *message)
 {
 	struct spi_master *master = spi->master;
+	int ret;
+	unsigned long flags;
 
-	/* Half-duplex links include original MicroWire, and ones with
-	 * only one data pin like SPI_3WIRE (switches direction) or where
-	 * either MOSI or MISO is missing.  They can also be caused by
-	 * software limitations.
-	 */
-	if ((master->flags & SPI_MASTER_HALF_DUPLEX)
-			|| (spi->mode & SPI_3WIRE)) {
-		struct spi_transfer *xfer;
-		unsigned flags = master->flags;
+	spin_lock_irqsave(&master->bus_lock_spinlock, flags);
 
-		list_for_each_entry(xfer, &message->transfers, transfer_list) {
-			if (xfer->rx_buf && xfer->tx_buf)
-				return -EINVAL;
-			if ((flags & SPI_MASTER_NO_TX) && xfer->tx_buf)
-				return -EINVAL;
-			if ((flags & SPI_MASTER_NO_RX) && xfer->rx_buf)
-				return -EINVAL;
-		}
-	}
+	if (master->bus_lock_flag)
+		ret = -EBUSY;
+	else
+		ret = __spi_async(spi, message);
 
-	message->spi = spi;
-	message->status = -EINPROGRESS;
-	return master->transfer(spi, message);
+	spin_unlock_irqrestore(&master->bus_lock_spinlock, flags);
+
+	return ret;
 }
 EXPORT_SYMBOL_GPL(spi_async);
 
+/**
+ * spi_async_locked - version of spi_async with exclusive bus usage
+ * @spi: device with which data will be exchanged
+ * @message: describes the data transfers, including completion callback
+ * Context: any (irqs may be blocked, etc)
+ *
+ * This call may be used in_irq and other contexts which can't sleep,
+ * as well as from task contexts which can sleep.
+ *
+ * The completion callback is invoked in a context which can't sleep.
+ * Before that invocation, the value of message->status is undefined.
+ * When the callback is issued, message->status holds either zero (to
+ * indicate complete success) or a negative error code.  After that
+ * callback returns, the driver which issued the transfer request may
+ * deallocate the associated memory; it's no longer in use by any SPI
+ * core or controller driver code.
+ *
+ * Note that although all messages to a spi_device are handled in
+ * FIFO order, messages may go to different devices in other orders.
+ * Some device might be higher priority, or have various "hard" access
+ * time requirements, for example.
+ *
+ * On detection of any fault during the transfer, processing of
+ * the entire message is aborted, and the device is deselected.
+ * Until returning from the associated message completion callback,
+ * no other spi_message queued to that device will be processed.
+ * (This rule applies equally to all the synchronous transfer calls,
+ * which are wrappers around this core asynchronous primitive.)
+ */
+int spi_async_locked(struct spi_device *spi, struct spi_message *message)
+{
+	struct spi_master *master = spi->master;
+	int ret;
+	unsigned long flags;
+
+	spin_lock_irqsave(&master->bus_lock_spinlock, flags);
+
+	ret = __spi_async(spi, message);
+
+	spin_unlock_irqrestore(&master->bus_lock_spinlock, flags);
+
+	return ret;
+
+}
+EXPORT_SYMBOL_GPL(spi_async_locked);
+
 
 /*-------------------------------------------------------------------------*/
 
@@ -738,6 +806,32 @@ static void spi_complete(void *arg)
 	complete(arg);
 }
 
+static int __spi_sync(struct spi_device *spi, struct spi_message *message,
+		      int bus_locked)
+{
+	DECLARE_COMPLETION_ONSTACK(done);
+	int status;
+	struct spi_master *master = spi->master;
+
+	message->complete = spi_complete;
+	message->context = &done;
+
+	if (!bus_locked)
+		mutex_lock(&master->bus_lock_mutex);
+
+	status = spi_async_locked(spi, message);
+
+	if (!bus_locked)
+		mutex_unlock(&master->bus_lock_mutex);
+
+	if (status == 0) {
+		wait_for_completion(&done);
+		status = message->status;
+	}
+	message->context = NULL;
+	return status;
+}
+
 /**
  * spi_sync - blocking/synchronous SPI data transfers
  * @spi: device with which data will be exchanged
@@ -761,21 +855,86 @@ static void spi_complete(void *arg)
  */
 int spi_sync(struct spi_device *spi, struct spi_message *message)
 {
-	DECLARE_COMPLETION_ONSTACK(done);
-	int status;
-
-	message->complete = spi_complete;
-	message->context = &done;
-	status = spi_async(spi, message);
-	if (status == 0) {
-		wait_for_completion(&done);
-		status = message->status;
-	}
-	message->context = NULL;
-	return status;
+	return __spi_sync(spi, message, 0);
 }
 EXPORT_SYMBOL_GPL(spi_sync);
 
+/**
+ * spi_sync_locked - version of spi_sync with exclusive bus usage
+ * @spi: device with which data will be exchanged
+ * @message: describes the data transfers
+ * Context: can sleep
+ *
+ * This call may only be used from a context that may sleep.  The sleep
+ * is non-interruptible, and has no timeout.  Low-overhead controller
+ * drivers may DMA directly into and out of the message buffers.
+ *
+ * This call should be used by drivers that require exclusive access to the
+ * SPI bus. It has to be preceeded by a spi_bus_lock call. The SPI bus must
+ * be released by a spi_bus_unlock call when the exclusive access is over.
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int spi_sync_locked(struct spi_device *spi, struct spi_message *message)
+{
+	return __spi_sync(spi, message, 1);
+}
+EXPORT_SYMBOL_GPL(spi_sync_locked);
+
+/**
+ * spi_bus_lock - obtain a lock for exclusive SPI bus usage
+ * @master: SPI bus master that should be locked for exclusive bus access
+ * Context: can sleep
+ *
+ * This call may only be used from a context that may sleep.  The sleep
+ * is non-interruptible, and has no timeout.
+ *
+ * This call should be used by drivers that require exclusive access to the
+ * SPI bus. The SPI bus must be released by a spi_bus_unlock call when the
+ * exclusive access is over. Data transfer must be done by spi_sync_locked
+ * and spi_async_locked calls when the SPI bus lock is held.
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int spi_bus_lock(struct spi_master *master)
+{
+	unsigned long flags;
+
+	mutex_lock(&master->bus_lock_mutex);
+
+	spin_lock_irqsave(&master->bus_lock_spinlock, flags);
+	master->bus_lock_flag = 1;
+	spin_unlock_irqrestore(&master->bus_lock_spinlock, flags);
+
+	/* mutex remains locked until spi_bus_unlock is called */
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(spi_bus_lock);
+
+/**
+ * spi_bus_unlock - release the lock for exclusive SPI bus usage
+ * @master: SPI bus master that was locked for exclusive bus access
+ * Context: can sleep
+ *
+ * This call may only be used from a context that may sleep.  The sleep
+ * is non-interruptible, and has no timeout.
+ *
+ * This call releases an SPI bus lock previously obtained by an spi_bus_lock
+ * call.
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int spi_bus_unlock(struct spi_master *master)
+{
+	master->bus_lock_flag = 0;
+
+	mutex_unlock(&master->bus_lock_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(spi_bus_unlock);
+
 /* portable code must never pass more than 32 bytes */
 #define	SPI_BUFSIZ	max(32,SMP_CACHE_BYTES)
 

commit 07a389feefd79d41c8542cf31ce1cf25a1466e2c
Author: Roman Tereshonkov <roman.tereshonkov@nokia.com>
Date:   Mon Apr 12 09:56:35 2010 +0000

    spi: spi_device memory should be released instead of device.
    
    The memory for dev variable is allocated as a part of
    spi_device structure memory which the dev belongs to.
    Thus when the memory is released the right pointer is used.
    
    Signed-off-by: Roman Tereshonkov <roman.tereshonkov@nokia.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index ec429d156a57..b3a1f9259b62 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -41,7 +41,7 @@ static void spidev_release(struct device *dev)
 		spi->master->cleanup(spi);
 
 	spi_master_put(spi->master);
-	kfree(dev);
+	kfree(spi);
 }
 
 static ssize_t

commit 8ec130a017ebd8b931344edde7013ffb18fa1965
Author: Roman Tereshonkov <roman.tereshonkov@nokia.com>
Date:   Fri Apr 16 09:52:59 2010 +0000

    spi: release device claimed by bus_find_device_by_name
    
    In success case the function bus_find_device_by_name calls
    get_device. In our context put_device should be called to
    decrease the device count usage.
    
    Signed-off-by: Roman Tereshonkov <roman.tereshonkov@nokia.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 9ffb0fdbd6fe..ec429d156a57 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -257,6 +257,7 @@ int spi_add_device(struct spi_device *spi)
 {
 	static DEFINE_MUTEX(spi_add_lock);
 	struct device *dev = spi->master->dev.parent;
+	struct device *d;
 	int status;
 
 	/* Chipselects are numbered 0..max; validate. */
@@ -278,10 +279,11 @@ int spi_add_device(struct spi_device *spi)
 	 */
 	mutex_lock(&spi_add_lock);
 
-	if (bus_find_device_by_name(&spi_bus_type, NULL, dev_name(&spi->dev))
-			!= NULL) {
+	d = bus_find_device_by_name(&spi_bus_type, NULL, dev_name(&spi->dev));
+	if (d != NULL) {
 		dev_err(dev, "chipselect %d already in use\n",
 				spi->chip_select);
+		put_device(d);
 		status = -EBUSY;
 		goto done;
 	}

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b76f2468a84a..9ffb0fdbd6fe 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -23,6 +23,7 @@
 #include <linux/init.h>
 #include <linux/cache.h>
 #include <linux/mutex.h>
+#include <linux/slab.h>
 #include <linux/mod_devicetable.h>
 #include <linux/spi/spi.h>
 

commit 568d0697f42771425ae9f1e9a3db769fef7e10b6
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Tue Sep 22 16:46:18 2009 -0700

    spi: handle TX-only/RX-only
    
    Support two new half-duplex SPI implementation restrictions, for links
    that talk to TX-only or RX-only devices.  (Existing half-duplex flavors
    support both transfer directions, just not at the same time.)
    
    Move spi_async() into the spi.c core, and stop inlining it.  Then make
    that function perform error checks and reject messages that demand more
    than the underlying controller can support.
    
    Based on a patch from Marek Szyprowski which did this only for the
    bitbanged GPIO driver.
    
    Cc: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 49e84860c8da..b76f2468a84a 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -663,6 +663,65 @@ int spi_setup(struct spi_device *spi)
 }
 EXPORT_SYMBOL_GPL(spi_setup);
 
+/**
+ * spi_async - asynchronous SPI transfer
+ * @spi: device with which data will be exchanged
+ * @message: describes the data transfers, including completion callback
+ * Context: any (irqs may be blocked, etc)
+ *
+ * This call may be used in_irq and other contexts which can't sleep,
+ * as well as from task contexts which can sleep.
+ *
+ * The completion callback is invoked in a context which can't sleep.
+ * Before that invocation, the value of message->status is undefined.
+ * When the callback is issued, message->status holds either zero (to
+ * indicate complete success) or a negative error code.  After that
+ * callback returns, the driver which issued the transfer request may
+ * deallocate the associated memory; it's no longer in use by any SPI
+ * core or controller driver code.
+ *
+ * Note that although all messages to a spi_device are handled in
+ * FIFO order, messages may go to different devices in other orders.
+ * Some device might be higher priority, or have various "hard" access
+ * time requirements, for example.
+ *
+ * On detection of any fault during the transfer, processing of
+ * the entire message is aborted, and the device is deselected.
+ * Until returning from the associated message completion callback,
+ * no other spi_message queued to that device will be processed.
+ * (This rule applies equally to all the synchronous transfer calls,
+ * which are wrappers around this core asynchronous primitive.)
+ */
+int spi_async(struct spi_device *spi, struct spi_message *message)
+{
+	struct spi_master *master = spi->master;
+
+	/* Half-duplex links include original MicroWire, and ones with
+	 * only one data pin like SPI_3WIRE (switches direction) or where
+	 * either MOSI or MISO is missing.  They can also be caused by
+	 * software limitations.
+	 */
+	if ((master->flags & SPI_MASTER_HALF_DUPLEX)
+			|| (spi->mode & SPI_3WIRE)) {
+		struct spi_transfer *xfer;
+		unsigned flags = master->flags;
+
+		list_for_each_entry(xfer, &message->transfers, transfer_list) {
+			if (xfer->rx_buf && xfer->tx_buf)
+				return -EINVAL;
+			if ((flags & SPI_MASTER_NO_TX) && xfer->tx_buf)
+				return -EINVAL;
+			if ((flags & SPI_MASTER_NO_RX) && xfer->rx_buf)
+				return -EINVAL;
+		}
+	}
+
+	message->spi = spi;
+	message->status = -EINPROGRESS;
+	return master->transfer(spi, message);
+}
+EXPORT_SYMBOL_GPL(spi_async);
+
 
 /*-------------------------------------------------------------------------*/
 

commit e0626e3844e8f430fc1a4417f523a00797df7ca6
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Tue Sep 22 16:46:08 2009 -0700

    spi: prefix modalias with "spi:"
    
    This makes it consistent with other buses (platform, i2c, vio, ...).  I'm
    not sure why we use the prefixes, but there must be a reason.
    
    This was easy enough to do it, and I did it.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Jean Delvare <khali@linux-fr.org>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Dmitry Torokhov <dtor@mail.ru>
    Cc: Samuel Ortiz <sameo@openedhand.com>
    Cc: "John W. Linville" <linville@tuxdriver.com>
    Acked-by: Mike Frysinger <vapier.adi@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 8518a6eb63f3..49e84860c8da 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -23,6 +23,7 @@
 #include <linux/init.h>
 #include <linux/cache.h>
 #include <linux/mutex.h>
+#include <linux/mod_devicetable.h>
 #include <linux/spi/spi.h>
 
 
@@ -93,7 +94,7 @@ static int spi_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	const struct spi_device		*spi = to_spi_device(dev);
 
-	add_uevent_var(env, "MODALIAS=%s", spi->modalias);
+	add_uevent_var(env, "MODALIAS=%s%s", SPI_MODULE_PREFIX, spi->modalias);
 	return 0;
 }
 

commit 75368bf6c2876d8f33abfe77aa3864869a3893eb
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Tue Sep 22 16:46:04 2009 -0700

    spi: add support for device table matching
    
    With this patch spi drivers can use standard spi_driver.id_table and
    MODULE_DEVICE_TABLE() mechanisms to bind against the devices.  Just like
    we do with I2C drivers.
    
    This is useful when a single driver supports several variants of devices
    but it is not possible to detect them in run-time (like non-JEDEC chips
    probing in drivers/mtd/devices/m25p80.c), and when platform_data usage is
    overkill.
    
    This patch also makes life a lot easier on OpenFirmware platforms, since
    with OF we extensively use proper device IDs in modaliases.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Jean Delvare <khali@linux-fr.org>
    Cc: Ben Dooks <ben-linux@fluff.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 70845ccd85c3..8518a6eb63f3 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -59,9 +59,32 @@ static struct device_attribute spi_dev_attrs[] = {
  * and the sysfs version makes coldplug work too.
  */
 
+static const struct spi_device_id *spi_match_id(const struct spi_device_id *id,
+						const struct spi_device *sdev)
+{
+	while (id->name[0]) {
+		if (!strcmp(sdev->modalias, id->name))
+			return id;
+		id++;
+	}
+	return NULL;
+}
+
+const struct spi_device_id *spi_get_device_id(const struct spi_device *sdev)
+{
+	const struct spi_driver *sdrv = to_spi_driver(sdev->dev.driver);
+
+	return spi_match_id(sdrv->id_table, sdev);
+}
+EXPORT_SYMBOL_GPL(spi_get_device_id);
+
 static int spi_match_device(struct device *dev, struct device_driver *drv)
 {
 	const struct spi_device	*spi = to_spi_device(dev);
+	const struct spi_driver	*sdrv = to_spi_driver(drv);
+
+	if (sdrv->id_table)
+		return !!spi_match_id(sdrv->id_table, spi);
 
 	return strcmp(spi->modalias, drv->name) == 0;
 }

commit 275704970c76c2453b656967586de9c35d247eae
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Wed Jun 17 16:26:06 2009 -0700

    spi: fix spi_write_then_read() comment
    
    Buffer needs not be dma-safe, not rx data length.
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index a525a3a848c1..70845ccd85c3 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -700,8 +700,8 @@ static u8	*buf;
  * @spi: device with which data will be exchanged
  * @txbuf: data to be written (need not be dma-safe)
  * @n_tx: size of txbuf, in bytes
- * @rxbuf: buffer into which data will be read
- * @n_rx: size of rxbuf, in bytes (need not be dma-safe)
+ * @rxbuf: buffer into which data will be read (need not be dma-safe)
+ * @n_rx: size of rxbuf, in bytes
  * Context: can sleep
  *
  * This performs a half duplex MicroWire style transaction with the

commit e7db06b5d5afcef15c4c3e61c3a7441ed7ad1407
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Jun 17 16:26:04 2009 -0700

    spi: move more spi_setup() functionality into core
    
    Move some common spi_setup() error checks into the SPI framework from the
    spi_master controller drivers:
    
     - Add a new "mode_bits" field to spi_master
    
     - Use that in spi_setup to validate the spi->mode value being
       requested.  Setting this new field is now mandatory for any
       controller supporting more than vanilla SPI_MODE_0.
    
     - Update all spi_master drivers to:
    
         * Initialize that field
         * Remove current spi_setup() checks using that value.
    
    This is a net minor code shrink.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 0276bc37e255..a525a3a848c1 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -607,8 +607,19 @@ EXPORT_SYMBOL_GPL(spi_busnum_to_master);
  */
 int spi_setup(struct spi_device *spi)
 {
+	unsigned	bad_bits;
 	int		status;
 
+	/* help drivers fail *cleanly* when they need options
+	 * that aren't supported with their current master
+	 */
+	bad_bits = spi->mode & ~spi->master->mode_bits;
+	if (bad_bits) {
+		dev_dbg(&spi->dev, "setup: unsupported mode bits %x\n",
+			bad_bits);
+		return -EINVAL;
+	}
+
 	if (!spi->bits_per_word)
 		spi->bits_per_word = 8;
 

commit 7d0771970c51e736758525dd71fb82dd036b823a
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Jun 17 16:26:03 2009 -0700

    spi: move common spi_setup() functionality into core
    
    Start moving some spi_setup() functionality into the SPI core from the
    various spi_master controller drivers:
    
     - Make that function stop being an inline;
    
     - Move two common idioms from drivers into that new function:
        * Default bits_per_word to 8 if that field isn't set
        * Issue a standardized dev_dbg() message
    
    This is a net minor source code shrink, and supports enhancments found in
    some follow-up patches.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 8eba98c8ed1e..0276bc37e255 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -265,7 +265,7 @@ int spi_add_device(struct spi_device *spi)
 	 * normally rely on the device being setup.  Devices
 	 * using SPI_CS_HIGH can't coexist well otherwise...
 	 */
-	status = spi->master->setup(spi);
+	status = spi_setup(spi);
 	if (status < 0) {
 		dev_err(dev, "can't %s %s, status %d\n",
 				"setup", dev_name(&spi->dev), status);
@@ -583,6 +583,59 @@ EXPORT_SYMBOL_GPL(spi_busnum_to_master);
 
 /*-------------------------------------------------------------------------*/
 
+/* Core methods for SPI master protocol drivers.  Some of the
+ * other core methods are currently defined as inline functions.
+ */
+
+/**
+ * spi_setup - setup SPI mode and clock rate
+ * @spi: the device whose settings are being modified
+ * Context: can sleep, and no requests are queued to the device
+ *
+ * SPI protocol drivers may need to update the transfer mode if the
+ * device doesn't work with its default.  They may likewise need
+ * to update clock rates or word sizes from initial values.  This function
+ * changes those settings, and must be called from a context that can sleep.
+ * Except for SPI_CS_HIGH, which takes effect immediately, the changes take
+ * effect the next time the device is selected and data is transferred to
+ * or from it.  When this function returns, the spi device is deselected.
+ *
+ * Note that this call will fail if the protocol driver specifies an option
+ * that the underlying controller or its driver does not support.  For
+ * example, not all hardware supports wire transfers using nine bit words,
+ * LSB-first wire encoding, or active-high chipselects.
+ */
+int spi_setup(struct spi_device *spi)
+{
+	int		status;
+
+	if (!spi->bits_per_word)
+		spi->bits_per_word = 8;
+
+	status = spi->master->setup(spi);
+
+	dev_dbg(&spi->dev, "setup mode %d, %s%s%s%s"
+				"%u bits/w, %u Hz max --> %d\n",
+			(int) (spi->mode & (SPI_CPOL | SPI_CPHA)),
+			(spi->mode & SPI_CS_HIGH) ? "cs_high, " : "",
+			(spi->mode & SPI_LSB_FIRST) ? "lsb, " : "",
+			(spi->mode & SPI_3WIRE) ? "3wire, " : "",
+			(spi->mode & SPI_LOOP) ? "loopback, " : "",
+			spi->bits_per_word, spi->max_speed_hz,
+			status);
+
+	return status;
+}
+EXPORT_SYMBOL_GPL(spi_setup);
+
+
+/*-------------------------------------------------------------------------*/
+
+/* Utility methods for SPI master protocol drivers, layered on
+ * top of the core.  Some other utility methods are defined as
+ * inline functions.
+ */
+
 static void spi_complete(void *arg)
 {
 	complete(arg);

commit bdff549ebeff92b1a6952e5501caf16a6f8898c8
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Mon Apr 13 14:39:57 2009 -0700

    spi: spi_write_then_read() bugfixes
    
    The "simplify spi_write_then_read()" patch included two regressions from
    the 2.6.27 behaviors:
    
     - The data it wrote out during the (full duplex) read side
       of the transfer was not zeroed.
    
     - It fails completely on half duplex hardware, such as
       Microwire and most "3-wire" SPI variants.
    
    So, revert that patch.  A revised version should be submitted at some
    point, which can get the speedup on standard hardware (full duplex)
    without breaking on less-capable half-duplex stuff.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: <stable@kernel.org>         [2.6.28.x, 2.6.29.x]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 643908b74bc0..8eba98c8ed1e 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -658,7 +658,7 @@ int spi_write_then_read(struct spi_device *spi,
 
 	int			status;
 	struct spi_message	message;
-	struct spi_transfer	x;
+	struct spi_transfer	x[2];
 	u8			*local_buf;
 
 	/* Use preallocated DMA-safe buffer.  We can't avoid copying here,
@@ -669,9 +669,15 @@ int spi_write_then_read(struct spi_device *spi,
 		return -EINVAL;
 
 	spi_message_init(&message);
-	memset(&x, 0, sizeof x);
-	x.len = n_tx + n_rx;
-	spi_message_add_tail(&x, &message);
+	memset(x, 0, sizeof x);
+	if (n_tx) {
+		x[0].len = n_tx;
+		spi_message_add_tail(&x[0], &message);
+	}
+	if (n_rx) {
+		x[1].len = n_rx;
+		spi_message_add_tail(&x[1], &message);
+	}
 
 	/* ... unless someone else is using the pre-allocated buffer */
 	if (!mutex_trylock(&lock)) {
@@ -682,15 +688,15 @@ int spi_write_then_read(struct spi_device *spi,
 		local_buf = buf;
 
 	memcpy(local_buf, txbuf, n_tx);
-	x.tx_buf = local_buf;
-	x.rx_buf = local_buf;
+	x[0].tx_buf = local_buf;
+	x[1].rx_buf = local_buf + n_tx;
 
 	/* do the i/o */
 	status = spi_sync(spi, &message);
 	if (status == 0)
-		memcpy(rxbuf, x.rx_buf + n_tx, n_rx);
+		memcpy(rxbuf, x[1].rx_buf, n_rx);
 
-	if (x.tx_buf == buf)
+	if (x[0].tx_buf == buf)
 		mutex_unlock(&lock);
 	else
 		kfree(local_buf);

commit 35f74fcab1228be03eab5f4d21ddc89fca1bc5b8
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Jan 6 10:44:37 2009 -0800

    spi: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 3734dc9708e1..643908b74bc0 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -47,7 +47,7 @@ modalias_show(struct device *dev, struct device_attribute *a, char *buf)
 {
 	const struct spi_device	*spi = to_spi_device(dev);
 
-	return snprintf(buf, BUS_ID_SIZE + 1, "%s\n", spi->modalias);
+	return sprintf(buf, "%s\n", spi->modalias);
 }
 
 static struct device_attribute spi_dev_attrs[] = {
@@ -63,7 +63,7 @@ static int spi_match_device(struct device *dev, struct device_driver *drv)
 {
 	const struct spi_device	*spi = to_spi_device(dev);
 
-	return strncmp(spi->modalias, drv->name, BUS_ID_SIZE) == 0;
+	return strcmp(spi->modalias, drv->name) == 0;
 }
 
 static int spi_uevent(struct device *dev, struct kobj_uevent_env *env)
@@ -243,8 +243,7 @@ int spi_add_device(struct spi_device *spi)
 	}
 
 	/* Set the bus ID string */
-	snprintf(spi->dev.bus_id, sizeof spi->dev.bus_id,
-			"%s.%u", spi->master->dev.bus_id,
+	dev_set_name(&spi->dev, "%s.%u", dev_name(&spi->master->dev),
 			spi->chip_select);
 
 
@@ -254,7 +253,7 @@ int spi_add_device(struct spi_device *spi)
 	 */
 	mutex_lock(&spi_add_lock);
 
-	if (bus_find_device_by_name(&spi_bus_type, NULL, spi->dev.bus_id)
+	if (bus_find_device_by_name(&spi_bus_type, NULL, dev_name(&spi->dev))
 			!= NULL) {
 		dev_err(dev, "chipselect %d already in use\n",
 				spi->chip_select);
@@ -269,7 +268,7 @@ int spi_add_device(struct spi_device *spi)
 	status = spi->master->setup(spi);
 	if (status < 0) {
 		dev_err(dev, "can't %s %s, status %d\n",
-				"setup", spi->dev.bus_id, status);
+				"setup", dev_name(&spi->dev), status);
 		goto done;
 	}
 
@@ -277,9 +276,9 @@ int spi_add_device(struct spi_device *spi)
 	status = device_add(&spi->dev);
 	if (status < 0)
 		dev_err(dev, "can't %s %s, status %d\n",
-				"add", spi->dev.bus_id, status);
+				"add", dev_name(&spi->dev), status);
 	else
-		dev_dbg(dev, "registered child %s\n", spi->dev.bus_id);
+		dev_dbg(dev, "registered child %s\n", dev_name(&spi->dev));
 
 done:
 	mutex_unlock(&spi_add_lock);
@@ -504,12 +503,11 @@ int spi_register_master(struct spi_master *master)
 	/* register the device, then userspace will see it.
 	 * registration fails if the bus ID is in use.
 	 */
-	snprintf(master->dev.bus_id, sizeof master->dev.bus_id,
-		"spi%u", master->bus_num);
+	dev_set_name(&master->dev, "spi%u", master->bus_num);
 	status = device_add(&master->dev);
 	if (status < 0)
 		goto done;
-	dev_dbg(dev, "registered master %s%s\n", master->dev.bus_id,
+	dev_dbg(dev, "registered master %s%s\n", dev_name(&master->dev),
 			dynamic ? " (dynamic)" : "");
 
 	/* populate children from any spi device tables */

commit 673c0c00382ed807f09d94e806f3519ddeeb4f70
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Oct 15 22:02:46 2008 -0700

    spi: core and gpio expanders use subsys_init
    
    Make the SPI external GPIO expander drivers register themselves at
    subsys_initcall() time when they're statically linked, and make the SPI
    core do its driver model initialization earlier so that's safe.
    
    SOC-integrated GPIOs are available starting very early -- often before
    initcalls start to run, or earily in arch_initcall() at latest -- so this
    improves consistency, letting more subsystems rely on GPIOs being usable
    by their own subsys_initcall() code.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 2de6b0e72f3f..3734dc9708e1 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -738,5 +738,5 @@ static int __init spi_init(void)
  * driver registration) _could_ be dynamically linked (modular) ... costs
  * include needing to have boardinfo data structures be much more public.
  */
-subsys_initcall(spi_init);
+postcore_initcall(spi_init);
 

commit f9b90e39cbc5c4d6ef60022fd1f25d541df0aad1
Author: Vernon Sauder <vernoninhand@gmail.com>
Date:   Wed Oct 15 22:02:40 2008 -0700

    spi: simplify spi_write_then_read()
    
    Modify spi_write_then_read() to use one transfer.  This speeds up all
    callers, and is a minor code shrink.
    
    Signed-off-by: Vernon Sauder <Vernon.Sauder@gmail.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 75e86865234c..2de6b0e72f3f 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -660,7 +660,7 @@ int spi_write_then_read(struct spi_device *spi,
 
 	int			status;
 	struct spi_message	message;
-	struct spi_transfer	x[2];
+	struct spi_transfer	x;
 	u8			*local_buf;
 
 	/* Use preallocated DMA-safe buffer.  We can't avoid copying here,
@@ -671,15 +671,9 @@ int spi_write_then_read(struct spi_device *spi,
 		return -EINVAL;
 
 	spi_message_init(&message);
-	memset(x, 0, sizeof x);
-	if (n_tx) {
-		x[0].len = n_tx;
-		spi_message_add_tail(&x[0], &message);
-	}
-	if (n_rx) {
-		x[1].len = n_rx;
-		spi_message_add_tail(&x[1], &message);
-	}
+	memset(&x, 0, sizeof x);
+	x.len = n_tx + n_rx;
+	spi_message_add_tail(&x, &message);
 
 	/* ... unless someone else is using the pre-allocated buffer */
 	if (!mutex_trylock(&lock)) {
@@ -690,15 +684,15 @@ int spi_write_then_read(struct spi_device *spi,
 		local_buf = buf;
 
 	memcpy(local_buf, txbuf, n_tx);
-	x[0].tx_buf = local_buf;
-	x[1].rx_buf = local_buf + n_tx;
+	x.tx_buf = local_buf;
+	x.rx_buf = local_buf;
 
 	/* do the i/o */
 	status = spi_sync(spi, &message);
 	if (status == 0)
-		memcpy(rxbuf, x[1].rx_buf, n_rx);
+		memcpy(rxbuf, x.rx_buf + n_tx, n_rx);
 
-	if (x[0].tx_buf == buf)
+	if (x.tx_buf == buf)
 		mutex_unlock(&lock);
 	else
 		kfree(local_buf);

commit e48880e02e7e7ead9daa47fe3a20486f550668d3
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Fri Aug 15 00:40:44 2008 -0700

    spi: bugfix spi_add_device() with duplicate chipselects
    
    When reviewing a recent patch I noticed a potential trouble spot in the
    registration of new SPI devices.  The SPI master driver is told to set
    the device up before adding it to the driver model, so that it's always
    properly set up when probe() is called.  (This is important, because in
    the case of inverted chipselects, this device can make the bus misbehave
    until it's properly deselected.  It's got to be set up even if no driver
    binds to the device.)
    
    The trouble spot is that it doesn't first verify that no other device
    has been added using that chipselect.  If such a device has been added,
    its configuration gets trashed.  (Fortunately this has not been a common
    error!)
    
    The fix here adds an explicit check, and a mutex to protect the relevant
    critical region.
    
    [akpm@linux-foundation.org: make the lock local to spi_add_device()]
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 964124b60db2..75e86865234c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -226,10 +226,11 @@ EXPORT_SYMBOL_GPL(spi_alloc_device);
  * Companion function to spi_alloc_device.  Devices allocated with
  * spi_alloc_device can be added onto the spi bus with this function.
  *
- * Returns 0 on success; non-zero on failure
+ * Returns 0 on success; negative errno on failure
  */
 int spi_add_device(struct spi_device *spi)
 {
+	static DEFINE_MUTEX(spi_add_lock);
 	struct device *dev = spi->master->dev.parent;
 	int status;
 
@@ -246,26 +247,43 @@ int spi_add_device(struct spi_device *spi)
 			"%s.%u", spi->master->dev.bus_id,
 			spi->chip_select);
 
-	/* drivers may modify this initial i/o setup */
+
+	/* We need to make sure there's no other device with this
+	 * chipselect **BEFORE** we call setup(), else we'll trash
+	 * its configuration.  Lock against concurrent add() calls.
+	 */
+	mutex_lock(&spi_add_lock);
+
+	if (bus_find_device_by_name(&spi_bus_type, NULL, spi->dev.bus_id)
+			!= NULL) {
+		dev_err(dev, "chipselect %d already in use\n",
+				spi->chip_select);
+		status = -EBUSY;
+		goto done;
+	}
+
+	/* Drivers may modify this initial i/o setup, but will
+	 * normally rely on the device being setup.  Devices
+	 * using SPI_CS_HIGH can't coexist well otherwise...
+	 */
 	status = spi->master->setup(spi);
 	if (status < 0) {
 		dev_err(dev, "can't %s %s, status %d\n",
 				"setup", spi->dev.bus_id, status);
-		return status;
+		goto done;
 	}
 
-	/* driver core catches callers that misbehave by defining
-	 * devices that already exist.
-	 */
+	/* Device may be bound to an active driver when this returns */
 	status = device_add(&spi->dev);
-	if (status < 0) {
+	if (status < 0)
 		dev_err(dev, "can't %s %s, status %d\n",
 				"add", spi->dev.bus_id, status);
-		return status;
-	}
+	else
+		dev_dbg(dev, "registered child %s\n", spi->dev.bus_id);
 
-	dev_dbg(dev, "registered child %s\n", spi->dev.bus_id);
-	return 0;
+done:
+	mutex_unlock(&spi_add_lock);
+	return status;
 }
 EXPORT_SYMBOL_GPL(spi_add_device);
 

commit dc87c98e8f635a718f1abb2c3e15fc77c0001651
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu May 15 16:50:22 2008 -0600

    spi: split up spi_new_device() to allow two stage registration.
    
    spi_new_device() allocates and registers an spi device all in one swoop.
    If the driver needs to add extra data to the spi_device before it is
    registered, then this causes problems.  This is needed for OF device
    tree support so that the SPI device tree helper can add a pointer to
    the device node after the device is allocated, but before the device
    is registered.  OF aware SPI devices can then retrieve data out of the
    device node to populate a platform data structure.
    
    This patch splits the allocation and registration portions of code out
    of spi_new_device() and creates two new functions; spi_alloc_device()
    and spi_register_device().  spi_new_device() is modified to use the new
    functions for allocation and registration.  None of the existing users
    of spi_new_device() should be affected by this change.
    
    Drivers using the new API can forego the use of spi_board_info
    structure to describe the device layout and populate data into the
    spi_device structure directly.
    
    This change is in preparation for adding an OF device tree parser to
    generate spi_devices based on data in the device tree.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index ecca4a6a6f94..964124b60db2 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -178,6 +178,96 @@ struct boardinfo {
 static LIST_HEAD(board_list);
 static DEFINE_MUTEX(board_lock);
 
+/**
+ * spi_alloc_device - Allocate a new SPI device
+ * @master: Controller to which device is connected
+ * Context: can sleep
+ *
+ * Allows a driver to allocate and initialize a spi_device without
+ * registering it immediately.  This allows a driver to directly
+ * fill the spi_device with device parameters before calling
+ * spi_add_device() on it.
+ *
+ * Caller is responsible to call spi_add_device() on the returned
+ * spi_device structure to add it to the SPI master.  If the caller
+ * needs to discard the spi_device without adding it, then it should
+ * call spi_dev_put() on it.
+ *
+ * Returns a pointer to the new device, or NULL.
+ */
+struct spi_device *spi_alloc_device(struct spi_master *master)
+{
+	struct spi_device	*spi;
+	struct device		*dev = master->dev.parent;
+
+	if (!spi_master_get(master))
+		return NULL;
+
+	spi = kzalloc(sizeof *spi, GFP_KERNEL);
+	if (!spi) {
+		dev_err(dev, "cannot alloc spi_device\n");
+		spi_master_put(master);
+		return NULL;
+	}
+
+	spi->master = master;
+	spi->dev.parent = dev;
+	spi->dev.bus = &spi_bus_type;
+	spi->dev.release = spidev_release;
+	device_initialize(&spi->dev);
+	return spi;
+}
+EXPORT_SYMBOL_GPL(spi_alloc_device);
+
+/**
+ * spi_add_device - Add spi_device allocated with spi_alloc_device
+ * @spi: spi_device to register
+ *
+ * Companion function to spi_alloc_device.  Devices allocated with
+ * spi_alloc_device can be added onto the spi bus with this function.
+ *
+ * Returns 0 on success; non-zero on failure
+ */
+int spi_add_device(struct spi_device *spi)
+{
+	struct device *dev = spi->master->dev.parent;
+	int status;
+
+	/* Chipselects are numbered 0..max; validate. */
+	if (spi->chip_select >= spi->master->num_chipselect) {
+		dev_err(dev, "cs%d >= max %d\n",
+			spi->chip_select,
+			spi->master->num_chipselect);
+		return -EINVAL;
+	}
+
+	/* Set the bus ID string */
+	snprintf(spi->dev.bus_id, sizeof spi->dev.bus_id,
+			"%s.%u", spi->master->dev.bus_id,
+			spi->chip_select);
+
+	/* drivers may modify this initial i/o setup */
+	status = spi->master->setup(spi);
+	if (status < 0) {
+		dev_err(dev, "can't %s %s, status %d\n",
+				"setup", spi->dev.bus_id, status);
+		return status;
+	}
+
+	/* driver core catches callers that misbehave by defining
+	 * devices that already exist.
+	 */
+	status = device_add(&spi->dev);
+	if (status < 0) {
+		dev_err(dev, "can't %s %s, status %d\n",
+				"add", spi->dev.bus_id, status);
+		return status;
+	}
+
+	dev_dbg(dev, "registered child %s\n", spi->dev.bus_id);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(spi_add_device);
 
 /**
  * spi_new_device - instantiate one new SPI device
@@ -197,7 +287,6 @@ struct spi_device *spi_new_device(struct spi_master *master,
 				  struct spi_board_info *chip)
 {
 	struct spi_device	*proxy;
-	struct device		*dev = master->dev.parent;
 	int			status;
 
 	/* NOTE:  caller did any chip->bus_num checks necessary.
@@ -207,66 +296,28 @@ struct spi_device *spi_new_device(struct spi_master *master,
 	 * suggests syslogged diagnostics are best here (ugh).
 	 */
 
-	/* Chipselects are numbered 0..max; validate. */
-	if (chip->chip_select >= master->num_chipselect) {
-		dev_err(dev, "cs%d > max %d\n",
-			chip->chip_select,
-			master->num_chipselect);
-		return NULL;
-	}
-
-	if (!spi_master_get(master))
+	proxy = spi_alloc_device(master);
+	if (!proxy)
 		return NULL;
 
 	WARN_ON(strlen(chip->modalias) >= sizeof(proxy->modalias));
 
-	proxy = kzalloc(sizeof *proxy, GFP_KERNEL);
-	if (!proxy) {
-		dev_err(dev, "can't alloc dev for cs%d\n",
-			chip->chip_select);
-		goto fail;
-	}
-	proxy->master = master;
 	proxy->chip_select = chip->chip_select;
 	proxy->max_speed_hz = chip->max_speed_hz;
 	proxy->mode = chip->mode;
 	proxy->irq = chip->irq;
 	strlcpy(proxy->modalias, chip->modalias, sizeof(proxy->modalias));
-
-	snprintf(proxy->dev.bus_id, sizeof proxy->dev.bus_id,
-			"%s.%u", master->dev.bus_id,
-			chip->chip_select);
-	proxy->dev.parent = dev;
-	proxy->dev.bus = &spi_bus_type;
 	proxy->dev.platform_data = (void *) chip->platform_data;
 	proxy->controller_data = chip->controller_data;
 	proxy->controller_state = NULL;
-	proxy->dev.release = spidev_release;
 
-	/* drivers may modify this initial i/o setup */
-	status = master->setup(proxy);
+	status = spi_add_device(proxy);
 	if (status < 0) {
-		dev_err(dev, "can't %s %s, status %d\n",
-				"setup", proxy->dev.bus_id, status);
-		goto fail;
+		spi_dev_put(proxy);
+		return NULL;
 	}
 
-	/* driver core catches callers that misbehave by defining
-	 * devices that already exist.
-	 */
-	status = device_register(&proxy->dev);
-	if (status < 0) {
-		dev_err(dev, "can't %s %s, status %d\n",
-				"add", proxy->dev.bus_id, status);
-		goto fail;
-	}
-	dev_dbg(dev, "registered child %s\n", proxy->dev.bus_id);
 	return proxy;
-
-fail:
-	spi_master_put(master);
-	kfree(proxy);
-	return NULL;
 }
 EXPORT_SYMBOL_GPL(spi_new_device);
 

commit 102eb97564c73ea73645b38599c5cbe6f54b030c
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed Jul 23 21:29:55 2008 -0700

    spi: make spi_board_info.modalias a char array
    
    Currently, 'modalias' in the spi_device structure is a 'const char *'.
    The spi_new_device() function fills in the modalias value from a passed in
    spi_board_info data block.  Since it is a pointer copy, the new spi_device
    remains dependent on the spi_board_info structure after the new spi_device
    is registered (no other fields in spi_device directly depend on the
    spi_board_info structure; all of the other data is copied).
    
    This causes a problem when dynamically propulating the list of attached
    SPI devices.  For example, in arch/powerpc, the list of SPI devices can be
    populated from data in the device tree.  With the current code, the device
    tree adapter must kmalloc() a new spi_board_info structure for each new
    SPI device it finds in the device tree, and there is no simple mechanism
    in place for keeping track of these allocations.
    
    This patch changes modalias from a 'const char *' to a fixed char array.
    By copying the modalias string instead of referencing it, the dependency
    on the spi_board_info structure is eliminated and an outside caller does
    not need to maintain a separate spi_board_info allocation for each device.
    
    If searched through the code to the best of my ability for any references
    to modalias which may be affected by this change and haven't found
    anything.  It has been tested with the lite5200b platform in arch/powerpc.
    
    [dbrownell@users.sourceforge.net: cope with linux-next changes: KOBJ_NAME_LEN obliterated, etc]
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 1771b2456bfa..ecca4a6a6f94 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -218,6 +218,8 @@ struct spi_device *spi_new_device(struct spi_master *master,
 	if (!spi_master_get(master))
 		return NULL;
 
+	WARN_ON(strlen(chip->modalias) >= sizeof(proxy->modalias));
+
 	proxy = kzalloc(sizeof *proxy, GFP_KERNEL);
 	if (!proxy) {
 		dev_err(dev, "can't alloc dev for cs%d\n",
@@ -229,7 +231,7 @@ struct spi_device *spi_new_device(struct spi_master *master,
 	proxy->max_speed_hz = chip->max_speed_hz;
 	proxy->mode = chip->mode;
 	proxy->irq = chip->irq;
-	proxy->modalias = chip->modalias;
+	strlcpy(proxy->modalias, chip->modalias, sizeof(proxy->modalias));
 
 	snprintf(proxy->dev.bus_id, sizeof proxy->dev.bus_id,
 			"%s.%u", master->dev.bus_id,

commit 695794ae0c5bdd9bd06e35b118801e2e9be04f9e
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu May 22 17:21:08 2008 -0400

    Driver Core: add ability for class_find_device to start in middle of list
    
    This mirrors the functionality that driver_find_device has as well.
    
    We add a start variable, and all callers of the function are fixed up at
    the same time.
    
    The block layer will be using this new functionality in a follow-on
    patch.
    
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 1ad12afc6ba0..1771b2456bfa 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -502,7 +502,7 @@ struct spi_master *spi_busnum_to_master(u16 bus_num)
 	struct device		*dev;
 	struct spi_master	*master = NULL;
 
-	dev = class_find_device(&spi_master_class, &bus_num,
+	dev = class_find_device(&spi_master_class, NULL, &bus_num,
 				__spi_master_match);
 	if (dev)
 		master = container_of(dev, struct spi_master, dev);

commit 3c72426f0539c1abce17918d1456f7a6a5a11f90
Author: David Brownell <david-b@pacbell.net>
Date:   Wed Feb 6 01:38:10 2008 -0800

    spi core: stop updating dev->power.power_state
    
    Don't update dev->power.power_state any more in the SPI core.  The only
    reason to update this scheduled-to-be-removed field was to make the
    already-removed /sys/devices/.../power/state files work better.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 5e5d29bb2dd5..1ad12afc6ba0 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -76,39 +76,33 @@ static int spi_uevent(struct device *dev, struct kobj_uevent_env *env)
 
 #ifdef	CONFIG_PM
 
-/*
- * NOTE:  the suspend() method for an spi_master controller driver
- * should verify that all its child devices are marked as suspended;
- * suspend requests delivered through sysfs power/state files don't
- * enforce such constraints.
- */
 static int spi_suspend(struct device *dev, pm_message_t message)
 {
-	int			value;
+	int			value = 0;
 	struct spi_driver	*drv = to_spi_driver(dev->driver);
 
-	if (!drv || !drv->suspend)
-		return 0;
-
 	/* suspend will stop irqs and dma; no more i/o */
-	value = drv->suspend(to_spi_device(dev), message);
-	if (value == 0)
-		dev->power.power_state = message;
+	if (drv) {
+		if (drv->suspend)
+			value = drv->suspend(to_spi_device(dev), message);
+		else
+			dev_dbg(dev, "... can't suspend\n");
+	}
 	return value;
 }
 
 static int spi_resume(struct device *dev)
 {
-	int			value;
+	int			value = 0;
 	struct spi_driver	*drv = to_spi_driver(dev->driver);
 
-	if (!drv || !drv->resume)
-		return 0;
-
 	/* resume may restart the i/o queue */
-	value = drv->resume(to_spi_device(dev));
-	if (value == 0)
-		dev->power.power_state = PMSG_ON;
+	if (drv) {
+		if (drv->resume)
+			value = drv->resume(to_spi_device(dev));
+		else
+			dev_dbg(dev, "... can't resume\n");
+	}
 	return value;
 }
 

commit 911f21501f50b16ce77f37b01e90b5b73c8c80bf
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Feb 6 01:36:15 2008 -0800

    Remove inclusions of <linux/autoconf.h>
    
    Nothing should ever include this file.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: "Mike Frysinger" <vapier.adi@gmail.com>
    Acked-by: "Bryan Wu" <cooloney.lkml@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 682a6a48fec3..5e5d29bb2dd5 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -18,7 +18,6 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#include <linux/autoconf.h>
 #include <linux/kernel.h>
 #include <linux/device.h>
 #include <linux/init.h>

commit 5ed2c832ed256b18d90c2462369c62fd79312e6c
Author: Dave Young <hidave.darkstar@gmail.com>
Date:   Tue Jan 22 15:14:18 2008 +0800

    spi: use class iteration api
    
    Convert to use the class iteration api.
    
    Signed-off-by: Dave Young <hidave.darkstar@gmail.com>
    Acked-by: David Brownell <david-b@pacbell.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 93e9de46977a..682a6a48fec3 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -485,6 +485,15 @@ void spi_unregister_master(struct spi_master *master)
 }
 EXPORT_SYMBOL_GPL(spi_unregister_master);
 
+static int __spi_master_match(struct device *dev, void *data)
+{
+	struct spi_master *m;
+	u16 *bus_num = data;
+
+	m = container_of(dev, struct spi_master, dev);
+	return m->bus_num == *bus_num;
+}
+
 /**
  * spi_busnum_to_master - look up master associated with bus_num
  * @bus_num: the master's bus number
@@ -499,17 +508,12 @@ struct spi_master *spi_busnum_to_master(u16 bus_num)
 {
 	struct device		*dev;
 	struct spi_master	*master = NULL;
-	struct spi_master	*m;
-
-	down(&spi_master_class.sem);
-	list_for_each_entry(dev, &spi_master_class.children, node) {
-		m = container_of(dev, struct spi_master, dev);
-		if (m->bus_num == bus_num) {
-			master = spi_master_get(m);
-			break;
-		}
-	}
-	up(&spi_master_class.sem);
+
+	dev = class_find_device(&spi_master_class, &bus_num,
+				__spi_master_match);
+	if (dev)
+		master = container_of(dev, struct spi_master, dev);
+	/* reference got in class_find_device */
 	return master;
 }
 EXPORT_SYMBOL_GPL(spi_busnum_to_master);

commit 9b938b749065d6a94172ac24d9748bd66a03da4c
Author: Marc Pignat <marc.pignat@hevs.ch>
Date:   Tue Dec 4 23:45:10 2007 -0800

    spi: simplify spi_sync() calling convention
    
    Simplify spi_sync calling convention, eliminating the need to check both
    the return value AND the message->status.  In consequence, this corrects
    misbehaviours of spi_read and spi_write (which only checked the former) and
    their callers.
    
    Signed-off-by: Marc Pignat <marc.pignat@hevs.ch>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 6ca07c9929e6..93e9de46977a 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -541,10 +541,7 @@ static void spi_complete(void *arg)
  * Also, the caller is guaranteeing that the memory associated with the
  * message will not be freed before this call returns.
  *
- * The return value is a negative error code if the message could not be
- * submitted, else zero.  When the value is zero, then message->status is
- * also defined;  it's the completion code for the transfer, either zero
- * or a negative error code from the controller driver.
+ * It returns zero on success, else a negative error code.
  */
 int spi_sync(struct spi_device *spi, struct spi_message *message)
 {
@@ -554,8 +551,10 @@ int spi_sync(struct spi_device *spi, struct spi_message *message)
 	message->complete = spi_complete;
 	message->context = &done;
 	status = spi_async(spi, message);
-	if (status == 0)
+	if (status == 0) {
 		wait_for_completion(&done);
+		status = message->status;
+	}
 	message->context = NULL;
 	return status;
 }
@@ -628,10 +627,8 @@ int spi_write_then_read(struct spi_device *spi,
 
 	/* do the i/o */
 	status = spi_sync(spi, &message);
-	if (status == 0) {
+	if (status == 0)
 		memcpy(rxbuf, x[1].rx_buf, n_rx);
-		status = message.status;
-	}
 
 	if (x[0].tx_buf == buf)
 		mutex_unlock(&lock);

commit 068f4070868c801c7d7aa1ae1193c1c854193545
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Dec 4 23:45:09 2007 -0800

    SPI: use mutex not semaphore
    
    Make spi_write_then_read() use a mutex not a binary semaphore.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b31f4431849b..6ca07c9929e6 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -589,7 +589,7 @@ int spi_write_then_read(struct spi_device *spi,
 		const u8 *txbuf, unsigned n_tx,
 		u8 *rxbuf, unsigned n_rx)
 {
-	static DECLARE_MUTEX(lock);
+	static DEFINE_MUTEX(lock);
 
 	int			status;
 	struct spi_message	message;
@@ -615,7 +615,7 @@ int spi_write_then_read(struct spi_device *spi,
 	}
 
 	/* ... unless someone else is using the pre-allocated buffer */
-	if (down_trylock(&lock)) {
+	if (!mutex_trylock(&lock)) {
 		local_buf = kmalloc(SPI_BUFSIZ, GFP_KERNEL);
 		if (!local_buf)
 			return -ENOMEM;
@@ -634,7 +634,7 @@ int spi_write_then_read(struct spi_device *spi,
 	}
 
 	if (x[0].tx_buf == buf)
-		up(&lock);
+		mutex_unlock(&lock);
 	else
 		kfree(local_buf);
 

commit 350d0076c5763ca2b88ca05e3889bfa7c1905f21
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Wed Nov 14 16:59:22 2007 -0800

    spi: fix double-free on spi_unregister_master
    
    After 49dce689ad4ef0fd1f970ef762168e4bd46f69a3, device_for_each_child
    iteration hits the master device itself.  Do not call spi_unregister_device()
    for the master device.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Acked-by: David Brownell <david-b@pacbell.net>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 89769ce16f88..b31f4431849b 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -457,10 +457,11 @@ int spi_register_master(struct spi_master *master)
 EXPORT_SYMBOL_GPL(spi_register_master);
 
 
-static int __unregister(struct device *dev, void *unused)
+static int __unregister(struct device *dev, void *master_dev)
 {
 	/* note: before about 2.6.14-rc1 this would corrupt memory: */
-	spi_unregister_device(to_spi_device(dev));
+	if (dev != master_dev)
+		spi_unregister_device(to_spi_device(dev));
 	return 0;
 }
 
@@ -478,7 +479,8 @@ void spi_unregister_master(struct spi_master *master)
 {
 	int dummy;
 
-	dummy = device_for_each_child(master->dev.parent, NULL, __unregister);
+	dummy = device_for_each_child(master->dev.parent, &master->dev,
+					__unregister);
 	device_unregister(&master->dev);
 }
 EXPORT_SYMBOL_GPL(spi_unregister_master);

commit 49dce689ad4ef0fd1f970ef762168e4bd46f69a3
Author: Tony Jones <tonyj@suse.de>
Date:   Tue Oct 16 01:27:48 2007 -0700

    spi doesn't need class_device
    
    Make the SPI framework and drivers stop using class_device.  Update docs
    accordingly ...  highlighting just which sysfs paths should be
    "safe"/stable.
    
    Signed-off-by: Tony Jones <tonyj@suse.de>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index bcb8dd5fb0b4..89769ce16f88 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -204,7 +204,7 @@ struct spi_device *spi_new_device(struct spi_master *master,
 				  struct spi_board_info *chip)
 {
 	struct spi_device	*proxy;
-	struct device		*dev = master->cdev.dev;
+	struct device		*dev = master->dev.parent;
 	int			status;
 
 	/* NOTE:  caller did any chip->bus_num checks necessary.
@@ -239,7 +239,7 @@ struct spi_device *spi_new_device(struct spi_master *master,
 	proxy->modalias = chip->modalias;
 
 	snprintf(proxy->dev.bus_id, sizeof proxy->dev.bus_id,
-			"%s.%u", master->cdev.class_id,
+			"%s.%u", master->dev.bus_id,
 			chip->chip_select);
 	proxy->dev.parent = dev;
 	proxy->dev.bus = &spi_bus_type;
@@ -338,18 +338,18 @@ static void scan_boardinfo(struct spi_master *master)
 
 /*-------------------------------------------------------------------------*/
 
-static void spi_master_release(struct class_device *cdev)
+static void spi_master_release(struct device *dev)
 {
 	struct spi_master *master;
 
-	master = container_of(cdev, struct spi_master, cdev);
+	master = container_of(dev, struct spi_master, dev);
 	kfree(master);
 }
 
 static struct class spi_master_class = {
 	.name		= "spi_master",
 	.owner		= THIS_MODULE,
-	.release	= spi_master_release,
+	.dev_release	= spi_master_release,
 };
 
 
@@ -357,7 +357,7 @@ static struct class spi_master_class = {
  * spi_alloc_master - allocate SPI master controller
  * @dev: the controller, possibly using the platform_bus
  * @size: how much zeroed driver-private data to allocate; the pointer to this
- *	memory is in the class_data field of the returned class_device,
+ *	memory is in the driver_data field of the returned device,
  *	accessible with spi_master_get_devdata().
  * Context: can sleep
  *
@@ -383,9 +383,9 @@ struct spi_master *spi_alloc_master(struct device *dev, unsigned size)
 	if (!master)
 		return NULL;
 
-	class_device_initialize(&master->cdev);
-	master->cdev.class = &spi_master_class;
-	master->cdev.dev = get_device(dev);
+	device_initialize(&master->dev);
+	master->dev.class = &spi_master_class;
+	master->dev.parent = get_device(dev);
 	spi_master_set_devdata(master, &master[1]);
 
 	return master;
@@ -415,7 +415,7 @@ EXPORT_SYMBOL_GPL(spi_alloc_master);
 int spi_register_master(struct spi_master *master)
 {
 	static atomic_t		dyn_bus_id = ATOMIC_INIT((1<<15) - 1);
-	struct device		*dev = master->cdev.dev;
+	struct device		*dev = master->dev.parent;
 	int			status = -ENODEV;
 	int			dynamic = 0;
 
@@ -440,12 +440,12 @@ int spi_register_master(struct spi_master *master)
 	/* register the device, then userspace will see it.
 	 * registration fails if the bus ID is in use.
 	 */
-	snprintf(master->cdev.class_id, sizeof master->cdev.class_id,
+	snprintf(master->dev.bus_id, sizeof master->dev.bus_id,
 		"spi%u", master->bus_num);
-	status = class_device_add(&master->cdev);
+	status = device_add(&master->dev);
 	if (status < 0)
 		goto done;
-	dev_dbg(dev, "registered master %s%s\n", master->cdev.class_id,
+	dev_dbg(dev, "registered master %s%s\n", master->dev.bus_id,
 			dynamic ? " (dynamic)" : "");
 
 	/* populate children from any spi device tables */
@@ -478,8 +478,8 @@ void spi_unregister_master(struct spi_master *master)
 {
 	int dummy;
 
-	dummy = device_for_each_child(master->cdev.dev, NULL, __unregister);
-	class_device_unregister(&master->cdev);
+	dummy = device_for_each_child(master->dev.parent, NULL, __unregister);
+	device_unregister(&master->dev);
 }
 EXPORT_SYMBOL_GPL(spi_unregister_master);
 
@@ -495,13 +495,13 @@ EXPORT_SYMBOL_GPL(spi_unregister_master);
  */
 struct spi_master *spi_busnum_to_master(u16 bus_num)
 {
-	struct class_device	*cdev;
+	struct device		*dev;
 	struct spi_master	*master = NULL;
 	struct spi_master	*m;
 
 	down(&spi_master_class.sem);
-	list_for_each_entry(cdev, &spi_master_class.children, node) {
-		m = container_of(cdev, struct spi_master, cdev);
+	list_for_each_entry(dev, &spi_master_class.children, node) {
+		m = container_of(dev, struct spi_master, dev);
 		if (m->bus_num == bus_num) {
 			master = spi_master_get(m);
 			break;

commit 7eff2e7a8b65c25920207324e56611150eb1cd9a
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Aug 14 15:15:12 2007 +0200

    Driver core: change add_uevent_var to use a struct
    
    This changes the uevent buffer functions to use a struct instead of a
    long list of parameters. It does no longer require the caller to do the
    proper buffer termination and size accounting, which is currently wrong
    in some places. It fixes a known bug where parts of the uevent
    environment are overwritten because of wrong index calculations.
    
    Many thanks to Mathieu Desnoyers for finding bugs and improving the
    error handling.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index e84d21597943..bcb8dd5fb0b4 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -67,14 +67,11 @@ static int spi_match_device(struct device *dev, struct device_driver *drv)
 	return strncmp(spi->modalias, drv->name, BUS_ID_SIZE) == 0;
 }
 
-static int spi_uevent(struct device *dev, char **envp, int num_envp,
-		char *buffer, int buffer_size)
+static int spi_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	const struct spi_device		*spi = to_spi_device(dev);
 
-	envp[0] = buffer;
-	snprintf(buffer, buffer_size, "MODALIAS=%s", spi->modalias);
-	envp[1] = NULL;
+	add_uevent_var(env, "MODALIAS=%s", spi->modalias);
 	return 0;
 }
 

commit 082c8cb4e5e68c0fd29cc10c59db94d2284fd2b0
Author: David Brownell <david-b@pacbell.net>
Date:   Tue Jul 31 00:39:45 2007 -0700

    spi device setup gets better error checking
    
    This updates some error reporting paths in SPI device setup:
    
     - Move validation logic for SPI chipselects to spi_new_device(),
       which is where it should always have been.
    
     - In spi_new_device(), emit error messages if the device can't
       be created.  This is LOTS better than a silent failure; though
       eventually, the calling convention should probably change to
       use the <linux/err.h> conventions.
    
     - Includes one previously-missing check:  SPI masters must always
       have at least one chipselect, even for dedicated busses which
       always keep it selected!
    
    It also adds a FIXME (IDR for dynamic ID allocation) so the issue doesn't live
    purely in my mailbox.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index b05de30b5d9b..e84d21597943 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -200,6 +200,8 @@ static DEFINE_MUTEX(board_lock);
  * platforms may not be able to use spi_register_board_info though, and
  * this is exported so that for example a USB or parport based adapter
  * driver could add devices (which it would learn about out-of-band).
+ *
+ * Returns the new device, or NULL.
  */
 struct spi_device *spi_new_device(struct spi_master *master,
 				  struct spi_board_info *chip)
@@ -208,7 +210,20 @@ struct spi_device *spi_new_device(struct spi_master *master,
 	struct device		*dev = master->cdev.dev;
 	int			status;
 
-	/* NOTE:  caller did any chip->bus_num checks necessary */
+	/* NOTE:  caller did any chip->bus_num checks necessary.
+	 *
+	 * Also, unless we change the return value convention to use
+	 * error-or-pointer (not NULL-or-pointer), troubleshootability
+	 * suggests syslogged diagnostics are best here (ugh).
+	 */
+
+	/* Chipselects are numbered 0..max; validate. */
+	if (chip->chip_select >= master->num_chipselect) {
+		dev_err(dev, "cs%d > max %d\n",
+			chip->chip_select,
+			master->num_chipselect);
+		return NULL;
+	}
 
 	if (!spi_master_get(master))
 		return NULL;
@@ -236,10 +251,10 @@ struct spi_device *spi_new_device(struct spi_master *master,
 	proxy->controller_state = NULL;
 	proxy->dev.release = spidev_release;
 
-	/* drivers may modify this default i/o setup */
+	/* drivers may modify this initial i/o setup */
 	status = master->setup(proxy);
 	if (status < 0) {
-		dev_dbg(dev, "can't %s %s, status %d\n",
+		dev_err(dev, "can't %s %s, status %d\n",
 				"setup", proxy->dev.bus_id, status);
 		goto fail;
 	}
@@ -249,7 +264,7 @@ struct spi_device *spi_new_device(struct spi_master *master,
 	 */
 	status = device_register(&proxy->dev);
 	if (status < 0) {
-		dev_dbg(dev, "can't %s %s, status %d\n",
+		dev_err(dev, "can't %s %s, status %d\n",
 				"add", proxy->dev.bus_id, status);
 		goto fail;
 	}
@@ -306,7 +321,6 @@ spi_register_board_info(struct spi_board_info const *info, unsigned n)
 static void scan_boardinfo(struct spi_master *master)
 {
 	struct boardinfo	*bi;
-	struct device		*dev = master->cdev.dev;
 
 	mutex_lock(&board_lock);
 	list_for_each_entry(bi, &board_list, list) {
@@ -316,17 +330,9 @@ static void scan_boardinfo(struct spi_master *master)
 		for (n = bi->n_board_info; n > 0; n--, chip++) {
 			if (chip->bus_num != master->bus_num)
 				continue;
-			/* some controllers only have one chip, so they
-			 * might not use chipselects.  otherwise, the
-			 * chipselects are numbered 0..max.
+			/* NOTE: this relies on spi_new_device to
+			 * issue diagnostics when given bogus inputs
 			 */
-			if (chip->chip_select >= master->num_chipselect
-					&& master->num_chipselect) {
-				dev_dbg(dev, "cs%d > max %d\n",
-					chip->chip_select,
-					master->num_chipselect);
-				continue;
-			}
 			(void) spi_new_device(master, chip);
 		}
 	}
@@ -419,8 +425,17 @@ int spi_register_master(struct spi_master *master)
 	if (!dev)
 		return -ENODEV;
 
+	/* even if it's just one always-selected device, there must
+	 * be at least one chipselect
+	 */
+	if (master->num_chipselect == 0)
+		return -EINVAL;
+
 	/* convention:  dynamically assigned bus IDs count down from the max */
 	if (master->bus_num < 0) {
+		/* FIXME switch to an IDR based scheme, something like
+		 * I2C now uses, so we can't run out of "dynamic" IDs
+		 */
 		master->bus_num = atomic_dec_return(&dyn_bus_id);
 		dynamic = 1;
 	}

commit 149a6501f90df457d75a1954dd5a29434a182e6a
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sat Jul 21 04:37:52 2007 -0700

    spi.c:scan_boardinfo() mustn't be __init_or_module
    
    WARNING: drivers/built-in.o(.text+0x889735): Section mismatch: reference to .init.text:scan_boardinfo (between 'spi_register_master' and '__unregister')
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 018884d7a5fa..b05de30b5d9b 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -303,8 +303,7 @@ spi_register_board_info(struct spi_board_info const *info, unsigned n)
  * creates board info from kernel command lines
  */
 
-static void __init_or_module
-scan_boardinfo(struct spi_master *master)
+static void scan_boardinfo(struct spi_master *master)
 {
 	struct boardinfo	*bi;
 	struct device		*dev = master->cdev.dev;

commit 940408289842677cfe9e053a6c423bf3fb922560
Author: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
Date:   Tue Jul 17 04:04:16 2007 -0700

    use mutex instead of semaphore in SPI core/init code
    
    The SPI core/init code uses a semaphore as mutex.  Use the mutex API instead
    of the (binary) semaphore.
    
    Signed-off-by: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
    Acked-by: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 4831edbae2d5..018884d7a5fa 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -23,6 +23,7 @@
 #include <linux/device.h>
 #include <linux/init.h>
 #include <linux/cache.h>
+#include <linux/mutex.h>
 #include <linux/spi/spi.h>
 
 
@@ -185,7 +186,7 @@ struct boardinfo {
 };
 
 static LIST_HEAD(board_list);
-static DECLARE_MUTEX(board_lock);
+static DEFINE_MUTEX(board_lock);
 
 
 /**
@@ -292,9 +293,9 @@ spi_register_board_info(struct spi_board_info const *info, unsigned n)
 	bi->n_board_info = n;
 	memcpy(bi->board_info, info, n * sizeof *info);
 
-	down(&board_lock);
+	mutex_lock(&board_lock);
 	list_add_tail(&bi->list, &board_list);
-	up(&board_lock);
+	mutex_unlock(&board_lock);
 	return 0;
 }
 
@@ -308,7 +309,7 @@ scan_boardinfo(struct spi_master *master)
 	struct boardinfo	*bi;
 	struct device		*dev = master->cdev.dev;
 
-	down(&board_lock);
+	mutex_lock(&board_lock);
 	list_for_each_entry(bi, &board_list, list) {
 		struct spi_board_info	*chip = bi->board_info;
 		unsigned		n;
@@ -330,7 +331,7 @@ scan_boardinfo(struct spi_master *master)
 			(void) spi_new_device(master, chip);
 		}
 	}
-	up(&board_lock);
+	mutex_unlock(&board_lock);
 }
 
 /*-------------------------------------------------------------------------*/

commit e44a45ae7b7f7c7a4ebd6aa39b703bf2b97fe848
Author: David Brownell <david-b@pacbell.net>
Date:   Sun Jun 3 13:50:40 2007 -0700

    SPI dynamic busid generation bugfix
    
    Fix SPI dynamic bus ID assignment to start at 2^15-1 rather than a negative
    number.  Valid bus ids are supposed to be positive, and are (now) stored in
    an 's16' value.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index c3219b29b5ac..4831edbae2d5 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -411,7 +411,7 @@ EXPORT_SYMBOL_GPL(spi_alloc_master);
  */
 int spi_register_master(struct spi_master *master)
 {
-	static atomic_t		dyn_bus_id = ATOMIC_INIT((1<<16) - 1);
+	static atomic_t		dyn_bus_id = ATOMIC_INIT((1<<15) - 1);
 	struct device		*dev = master->cdev.dev;
 	int			status = -ENODEV;
 	int			dynamic = 0;

commit 33e34dc6ee2cb2cf2d50e65c5b825d9ebb8b9e66
Author: David Brownell <david-b@pacbell.net>
Date:   Tue May 8 00:32:21 2007 -0700

    SPI kerneldoc
    
    Various documentation updates for the SPI infrastructure, to clarify things
    that may not have been clear, to cope with lack of editing, and fix
    omissions.
    
    Also, plug SPI into the kernel-api DocBook template, and fix all the
    resulting glitches in document generation.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: "Randy.Dunlap" <rdunlap@xenotime.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 6657331eed93..c3219b29b5ac 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -152,6 +152,11 @@ static void spi_drv_shutdown(struct device *dev)
 	sdrv->shutdown(to_spi_device(dev));
 }
 
+/**
+ * spi_register_driver - register a SPI driver
+ * @sdrv: the driver to register
+ * Context: can sleep
+ */
 int spi_register_driver(struct spi_driver *sdrv)
 {
 	sdrv->driver.bus = &spi_bus_type;
@@ -183,7 +188,13 @@ static LIST_HEAD(board_list);
 static DECLARE_MUTEX(board_lock);
 
 
-/* On typical mainboards, this is purely internal; and it's not needed
+/**
+ * spi_new_device - instantiate one new SPI device
+ * @master: Controller to which device is connected
+ * @chip: Describes the SPI device
+ * Context: can sleep
+ *
+ * On typical mainboards, this is purely internal; and it's not needed
  * after board init creates the hard-wired devices.  Some development
  * platforms may not be able to use spi_register_board_info though, and
  * this is exported so that for example a USB or parport based adapter
@@ -251,7 +262,12 @@ struct spi_device *spi_new_device(struct spi_master *master,
 }
 EXPORT_SYMBOL_GPL(spi_new_device);
 
-/*
+/**
+ * spi_register_board_info - register SPI devices for a given board
+ * @info: array of chip descriptors
+ * @n: how many descriptors are provided
+ * Context: can sleep
+ *
  * Board-specific early init code calls this (probably during arch_initcall)
  * with segments of the SPI device table.  Any device nodes are created later,
  * after the relevant parent SPI controller (bus_num) is defined.  We keep
@@ -337,9 +353,10 @@ static struct class spi_master_class = {
 /**
  * spi_alloc_master - allocate SPI master controller
  * @dev: the controller, possibly using the platform_bus
- * @size: how much driver-private data to preallocate; the pointer to this
+ * @size: how much zeroed driver-private data to allocate; the pointer to this
  *	memory is in the class_data field of the returned class_device,
  *	accessible with spi_master_get_devdata().
+ * Context: can sleep
  *
  * This call is used only by SPI master controller drivers, which are the
  * only ones directly touching chip registers.  It's how they allocate
@@ -375,6 +392,7 @@ EXPORT_SYMBOL_GPL(spi_alloc_master);
 /**
  * spi_register_master - register SPI master controller
  * @master: initialized master, originally from spi_alloc_master()
+ * Context: can sleep
  *
  * SPI master controllers connect to their drivers using some non-SPI bus,
  * such as the platform bus.  The final stage of probe() in that code
@@ -437,6 +455,7 @@ static int __unregister(struct device *dev, void *unused)
 /**
  * spi_unregister_master - unregister SPI master controller
  * @master: the master being unregistered
+ * Context: can sleep
  *
  * This call is used only by SPI master controller drivers, which are the
  * only ones directly touching chip registers.
@@ -455,6 +474,7 @@ EXPORT_SYMBOL_GPL(spi_unregister_master);
 /**
  * spi_busnum_to_master - look up master associated with bus_num
  * @bus_num: the master's bus number
+ * Context: can sleep
  *
  * This call may be used with devices that are registered after
  * arch init time.  It returns a refcounted pointer to the relevant
@@ -492,6 +512,7 @@ static void spi_complete(void *arg)
  * spi_sync - blocking/synchronous SPI data transfers
  * @spi: device with which data will be exchanged
  * @message: describes the data transfers
+ * Context: can sleep
  *
  * This call may only be used from a context that may sleep.  The sleep
  * is non-interruptible, and has no timeout.  Low-overhead controller
@@ -508,7 +529,7 @@ static void spi_complete(void *arg)
  *
  * The return value is a negative error code if the message could not be
  * submitted, else zero.  When the value is zero, then message->status is
- * also defined:  it's the completion code for the transfer, either zero
+ * also defined;  it's the completion code for the transfer, either zero
  * or a negative error code from the controller driver.
  */
 int spi_sync(struct spi_device *spi, struct spi_message *message)
@@ -538,6 +559,7 @@ static u8	*buf;
  * @n_tx: size of txbuf, in bytes
  * @rxbuf: buffer into which data will be read
  * @n_rx: size of rxbuf, in bytes (need not be dma-safe)
+ * Context: can sleep
  *
  * This performs a half duplex MicroWire style transaction with the
  * device, sending txbuf and then reading rxbuf.  The return value
@@ -545,7 +567,8 @@ static u8	*buf;
  * This call may only be used from a context that may sleep.
  *
  * Parameters to this routine are always copied using a small buffer;
- * performance-sensitive or bulk transfer code should instead use
+ * portable code should never use this for more than 32 bytes.
+ * Performance-sensitive or bulk transfer code should instead use
  * spi_{async,sync}() calls with dma-safe buffers.
  */
 int spi_write_then_read(struct spi_device *spi,

commit e9d5a461157c1244475bc400fcac7f871608715e
Author: Adrian Bunk <bunk@stusta.de>
Date:   Mon Mar 26 21:32:23 2007 -0800

    [PATCH] drivers/spi/: fix section mismatches
    
      WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:spi_register_master from .text between 'spi_bitbang_start' (at offset 0x84e11a) and 'bitbang_work'
      WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:spi_alloc_master from .text between 'butterfly_attach' (at offset 0x84e681) and 'at25_remove'
      WARNING: drivers/built-in.o - Section mismatch: reference to .init.text:spi_new_device from .text between 'butterfly_attach' (at offset 0x84e7e4) and 'at25_remove'
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 2328128728be..6657331eed93 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -189,8 +189,8 @@ static DECLARE_MUTEX(board_lock);
  * this is exported so that for example a USB or parport based adapter
  * driver could add devices (which it would learn about out-of-band).
  */
-struct spi_device *__init_or_module
-spi_new_device(struct spi_master *master, struct spi_board_info *chip)
+struct spi_device *spi_new_device(struct spi_master *master,
+				  struct spi_board_info *chip)
 {
 	struct spi_device	*proxy;
 	struct device		*dev = master->cdev.dev;
@@ -352,8 +352,7 @@ static struct class spi_master_class = {
  * the master's methods before calling spi_register_master(); and (after errors
  * adding the device) calling spi_master_put() to prevent a memory leak.
  */
-struct spi_master * __init_or_module
-spi_alloc_master(struct device *dev, unsigned size)
+struct spi_master *spi_alloc_master(struct device *dev, unsigned size)
 {
 	struct spi_master	*master;
 
@@ -392,8 +391,7 @@ EXPORT_SYMBOL_GPL(spi_alloc_master);
  * After a successful return, the caller is responsible for calling
  * spi_unregister_master().
  */
-int __init_or_module
-spi_register_master(struct spi_master *master)
+int spi_register_master(struct spi_master *master)
 {
 	static atomic_t		dyn_bus_id = ATOMIC_INIT((1<<16) - 1);
 	struct device		*dev = master->cdev.dev;

commit 0ffa0285052607513a29f529ddb5061c907fd8a6
Author: Hans-Peter Nilsson <hans-peter.nilsson@axis.com>
Date:   Mon Feb 12 00:52:45 2007 -0800

    [PATCH] SPI cleanup() method param becomes non-const
    
    I'd like to assign NULL to kfree()d members of a structure.  I can't do
    that without ugly casting (see the PXA patch) when the structure pointed to
    is const-qualified.  I don't really see a reason why the cleanup method
    isn't allowed to alter the object it should clean up.  :-)
    
    No, I didn't test the PXA patch, but I verified that the NULL-assignment
    doesn't stop me from doing rmmod/insmodding my own spi_bitbang-based
    driver.
    
    Signed-off-by: Hans-Peter Nilsson <hp@axis.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 6307428d2c94..2328128728be 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -32,7 +32,7 @@
  */
 static void spidev_release(struct device *dev)
 {
-	const struct spi_device	*spi = to_spi_device(dev);
+	struct spi_device	*spi = to_spi_device(dev);
 
 	/* spi masters may cleanup for released devices */
 	if (spi->master->cleanup)

commit 07b2463046247ce580ff9b37e91394f2f6424768
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Feb 7 21:34:08 2007 -0800

    Revert "Driver core: convert SPI code to use struct device"
    
    This reverts commit 2943ecf2ed32632473c06f1975db47a7aa98c10f.
    
    This should go through the SPI maintainer, it was my fault that it did
    not.  Especially as it conflicts with other patches he has pending.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 35d8c01b42ac..6307428d2c94 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -193,7 +193,7 @@ struct spi_device *__init_or_module
 spi_new_device(struct spi_master *master, struct spi_board_info *chip)
 {
 	struct spi_device	*proxy;
-	struct device		*dev = &master->dev;
+	struct device		*dev = master->cdev.dev;
 	int			status;
 
 	/* NOTE:  caller did any chip->bus_num checks necessary */
@@ -215,7 +215,7 @@ spi_new_device(struct spi_master *master, struct spi_board_info *chip)
 	proxy->modalias = chip->modalias;
 
 	snprintf(proxy->dev.bus_id, sizeof proxy->dev.bus_id,
-			"%s.%u", master->dev.bus_id,
+			"%s.%u", master->cdev.class_id,
 			chip->chip_select);
 	proxy->dev.parent = dev;
 	proxy->dev.bus = &spi_bus_type;
@@ -290,7 +290,7 @@ static void __init_or_module
 scan_boardinfo(struct spi_master *master)
 {
 	struct boardinfo	*bi;
-	struct device		*dev = master->dev.parent;
+	struct device		*dev = master->cdev.dev;
 
 	down(&board_lock);
 	list_for_each_entry(bi, &board_list, list) {
@@ -319,18 +319,18 @@ scan_boardinfo(struct spi_master *master)
 
 /*-------------------------------------------------------------------------*/
 
-static void spi_master_release(struct device *dev)
+static void spi_master_release(struct class_device *cdev)
 {
 	struct spi_master *master;
 
-	master = container_of(dev, struct spi_master, dev);
+	master = container_of(cdev, struct spi_master, cdev);
 	kfree(master);
 }
 
 static struct class spi_master_class = {
 	.name		= "spi_master",
 	.owner		= THIS_MODULE,
-	.dev_release	= spi_master_release,
+	.release	= spi_master_release,
 };
 
 
@@ -364,9 +364,9 @@ spi_alloc_master(struct device *dev, unsigned size)
 	if (!master)
 		return NULL;
 
-	device_initialize(&master->dev);
-	master->dev.class = &spi_master_class;
-	master->dev.parent = get_device(dev);
+	class_device_initialize(&master->cdev);
+	master->cdev.class = &spi_master_class;
+	master->cdev.dev = get_device(dev);
 	spi_master_set_devdata(master, &master[1]);
 
 	return master;
@@ -396,7 +396,7 @@ int __init_or_module
 spi_register_master(struct spi_master *master)
 {
 	static atomic_t		dyn_bus_id = ATOMIC_INIT((1<<16) - 1);
-	struct device		*dev = master->dev.parent;
+	struct device		*dev = master->cdev.dev;
 	int			status = -ENODEV;
 	int			dynamic = 0;
 
@@ -412,12 +412,12 @@ spi_register_master(struct spi_master *master)
 	/* register the device, then userspace will see it.
 	 * registration fails if the bus ID is in use.
 	 */
-	snprintf(master->dev.bus_id, sizeof master->dev.bus_id,
+	snprintf(master->cdev.class_id, sizeof master->cdev.class_id,
 		"spi%u", master->bus_num);
-	status = device_add(&master->dev);
+	status = class_device_add(&master->cdev);
 	if (status < 0)
 		goto done;
-	dev_dbg(dev, "registered master %s%s\n", master->dev.bus_id,
+	dev_dbg(dev, "registered master %s%s\n", master->cdev.class_id,
 			dynamic ? " (dynamic)" : "");
 
 	/* populate children from any spi device tables */
@@ -449,8 +449,8 @@ void spi_unregister_master(struct spi_master *master)
 {
 	int dummy;
 
-	dummy = device_for_each_child(&master->dev, NULL, __unregister);
-	device_unregister(&master->dev);
+	dummy = device_for_each_child(master->cdev.dev, NULL, __unregister);
+	class_device_unregister(&master->cdev);
 }
 EXPORT_SYMBOL_GPL(spi_unregister_master);
 
@@ -471,7 +471,7 @@ struct spi_master *spi_busnum_to_master(u16 bus_num)
 
 	down(&spi_master_class.sem);
 	list_for_each_entry(cdev, &spi_master_class.children, node) {
-		m = container_of(cdev, struct spi_master, dev.kobj);
+		m = container_of(cdev, struct spi_master, cdev);
 		if (m->bus_num == bus_num) {
 			master = spi_master_get(m);
 			break;

commit 2943ecf2ed32632473c06f1975db47a7aa98c10f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jan 22 13:45:38 2007 -0800

    Driver core: convert SPI code to use struct device
    
    Converts from using struct "class_device" to "struct device" making
    everything show up properly in /sys/devices/ with symlinks from the
    /sys/class directory.
    
    Cc: <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 6307428d2c94..35d8c01b42ac 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -193,7 +193,7 @@ struct spi_device *__init_or_module
 spi_new_device(struct spi_master *master, struct spi_board_info *chip)
 {
 	struct spi_device	*proxy;
-	struct device		*dev = master->cdev.dev;
+	struct device		*dev = &master->dev;
 	int			status;
 
 	/* NOTE:  caller did any chip->bus_num checks necessary */
@@ -215,7 +215,7 @@ spi_new_device(struct spi_master *master, struct spi_board_info *chip)
 	proxy->modalias = chip->modalias;
 
 	snprintf(proxy->dev.bus_id, sizeof proxy->dev.bus_id,
-			"%s.%u", master->cdev.class_id,
+			"%s.%u", master->dev.bus_id,
 			chip->chip_select);
 	proxy->dev.parent = dev;
 	proxy->dev.bus = &spi_bus_type;
@@ -290,7 +290,7 @@ static void __init_or_module
 scan_boardinfo(struct spi_master *master)
 {
 	struct boardinfo	*bi;
-	struct device		*dev = master->cdev.dev;
+	struct device		*dev = master->dev.parent;
 
 	down(&board_lock);
 	list_for_each_entry(bi, &board_list, list) {
@@ -319,18 +319,18 @@ scan_boardinfo(struct spi_master *master)
 
 /*-------------------------------------------------------------------------*/
 
-static void spi_master_release(struct class_device *cdev)
+static void spi_master_release(struct device *dev)
 {
 	struct spi_master *master;
 
-	master = container_of(cdev, struct spi_master, cdev);
+	master = container_of(dev, struct spi_master, dev);
 	kfree(master);
 }
 
 static struct class spi_master_class = {
 	.name		= "spi_master",
 	.owner		= THIS_MODULE,
-	.release	= spi_master_release,
+	.dev_release	= spi_master_release,
 };
 
 
@@ -364,9 +364,9 @@ spi_alloc_master(struct device *dev, unsigned size)
 	if (!master)
 		return NULL;
 
-	class_device_initialize(&master->cdev);
-	master->cdev.class = &spi_master_class;
-	master->cdev.dev = get_device(dev);
+	device_initialize(&master->dev);
+	master->dev.class = &spi_master_class;
+	master->dev.parent = get_device(dev);
 	spi_master_set_devdata(master, &master[1]);
 
 	return master;
@@ -396,7 +396,7 @@ int __init_or_module
 spi_register_master(struct spi_master *master)
 {
 	static atomic_t		dyn_bus_id = ATOMIC_INIT((1<<16) - 1);
-	struct device		*dev = master->cdev.dev;
+	struct device		*dev = master->dev.parent;
 	int			status = -ENODEV;
 	int			dynamic = 0;
 
@@ -412,12 +412,12 @@ spi_register_master(struct spi_master *master)
 	/* register the device, then userspace will see it.
 	 * registration fails if the bus ID is in use.
 	 */
-	snprintf(master->cdev.class_id, sizeof master->cdev.class_id,
+	snprintf(master->dev.bus_id, sizeof master->dev.bus_id,
 		"spi%u", master->bus_num);
-	status = class_device_add(&master->cdev);
+	status = device_add(&master->dev);
 	if (status < 0)
 		goto done;
-	dev_dbg(dev, "registered master %s%s\n", master->cdev.class_id,
+	dev_dbg(dev, "registered master %s%s\n", master->dev.bus_id,
 			dynamic ? " (dynamic)" : "");
 
 	/* populate children from any spi device tables */
@@ -449,8 +449,8 @@ void spi_unregister_master(struct spi_master *master)
 {
 	int dummy;
 
-	dummy = device_for_each_child(master->cdev.dev, NULL, __unregister);
-	class_device_unregister(&master->cdev);
+	dummy = device_for_each_child(&master->dev, NULL, __unregister);
+	device_unregister(&master->dev);
 }
 EXPORT_SYMBOL_GPL(spi_unregister_master);
 
@@ -471,7 +471,7 @@ struct spi_master *spi_busnum_to_master(u16 bus_num)
 
 	down(&spi_master_class.sem);
 	list_for_each_entry(cdev, &spi_master_class.children, node) {
-		m = container_of(cdev, struct spi_master, cdev);
+		m = container_of(cdev, struct spi_master, dev.kobj);
 		if (m->bus_num == bus_num) {
 			master = spi_master_get(m);
 			break;

commit 1e9a51dca19dc1d8807c63cb3bd4413d3f95aaf5
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jan 26 00:56:54 2007 -0800

    [PATCH] SPI: alternative fix for spi_busnum_to_master
    
    If a SPI master device exists, udev (udevtrigger) causes kernel crash, due
    to wrong kobj pointer in kobject_uevent_env().  This problem was not in
    2.6.19.
    
    The backtrace (on MIPS) was:
    [<8024db6c>] kobject_uevent_env+0x54c/0x5e8
    [<802a8264>] store_uevent+0x1c/0x3c  (in drivers/class.c)
    [<801cb14c>] subsys_attr_store+0x2c/0x50
    [<801cb80c>] flush_write_buffer+0x38/0x5c
    [<801cb900>] sysfs_write_file+0xd0/0x190
    [<80181444>] vfs_write+0xc4/0x1a0
    [<80181cdc>] sys_write+0x54/0xa0
    [<8010dae4>] stack_done+0x20/0x3c
    
    flush_write_buffer() passes kobject of spi_master_class.subsys to
    subsys_addr_store(), then subsys_addr_store() passes a pointer to a struct
    subsystem to store_uevent() which expects a pointer to a struct
    class_device.  The problem seems subsys_attr_store() called instead of
    class_device_attr_store().
    
    This mismatch was caused by commit
    3bd0f6943520e459659d10f3282285e43d3990f1, which overrides kset of master
    class.  This made spi_master_class.subsys.kset.ktype NULL so
    subsys_sysfs_ops is used instead of class_dev_sysfs_ops.
    
    The commit was to fix spi_busnum_to_master().  Here is a patch fixes
    this function in other way, just searching children list of
    class_device.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 270e6211c2e3..6307428d2c94 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -366,7 +366,6 @@ spi_alloc_master(struct device *dev, unsigned size)
 
 	class_device_initialize(&master->cdev);
 	master->cdev.class = &spi_master_class;
-	kobj_set_kset_s(&master->cdev, spi_master_class.subsys);
 	master->cdev.dev = get_device(dev);
 	spi_master_set_devdata(master, &master[1]);
 
@@ -466,14 +465,20 @@ EXPORT_SYMBOL_GPL(spi_unregister_master);
  */
 struct spi_master *spi_busnum_to_master(u16 bus_num)
 {
-	char			name[9];
-	struct kobject		*bus;
-
-	snprintf(name, sizeof name, "spi%u", bus_num);
-	bus = kset_find_obj(&spi_master_class.subsys.kset, name);
-	if (bus)
-		return container_of(bus, struct spi_master, cdev.kobj);
-	return NULL;
+	struct class_device	*cdev;
+	struct spi_master	*master = NULL;
+	struct spi_master	*m;
+
+	down(&spi_master_class.sem);
+	list_for_each_entry(cdev, &spi_master_class.children, node) {
+		m = container_of(cdev, struct spi_master, cdev);
+		if (m->bus_num == bus_num) {
+			master = spi_master_get(m);
+			break;
+		}
+	}
+	up(&spi_master_class.sem);
+	return master;
 }
 EXPORT_SYMBOL_GPL(spi_busnum_to_master);
 

commit 3bd0f6943520e459659d10f3282285e43d3990f1
Author: Hans-Christian Egtvedt <hcegtvedt@atmel.com>
Date:   Wed Dec 6 20:36:19 2006 -0800

    [PATCH] spi: set kset of master class dev explicitly
    
    <quote Imre Deak from Thu, 12 Jan 2006 21:18:54 +0200>
      In order for spi_busnum_to_master to work spi master devices must be linked
      into the spi_master_class.subsys.kset list.  At the moment the default
      class_obj_subsys.kset is used and we can't enumerate the master devices.
    </quote>
    
    Signed-off-by: Hans-Christian Egtvedt <hcegtvedt@atmel.com>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 7d215eaa1370..270e6211c2e3 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -366,6 +366,7 @@ spi_alloc_master(struct device *dev, unsigned size)
 
 	class_device_initialize(&master->cdev);
 	master->cdev.class = &spi_master_class;
+	kobj_set_kset_s(&master->cdev, spi_master_class.subsys);
 	master->cdev.dev = get_device(dev);
 	spi_master_set_devdata(master, &master[1]);
 

commit 4740d387f3cb9e63f48f2488815b38a2c92755c8
Author: Hans-Christian Egtvedt <hcegtvedt@atmel.com>
Date:   Wed Dec 6 20:36:17 2006 -0800

    [PATCH] spi: correct bus_num and buffer bug in spi core
    
    Correct the following in driver/spi/spi.c in function spi_busnum_to_master:
    
     * must allow bus_num 0, the if is really not needed.
     * correct the name buffer which is too small for bus_num >= 10000. It
    
    should be 9 bytes big, not 8.
    
    Signed-off-by: Hans-Christian Egtvedt <hcegtvedt@atmel.com>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 1a3c963dc48a..7d215eaa1370 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -465,15 +465,13 @@ EXPORT_SYMBOL_GPL(spi_unregister_master);
  */
 struct spi_master *spi_busnum_to_master(u16 bus_num)
 {
-	if (bus_num) {
-		char			name[8];
-		struct kobject		*bus;
-
-		snprintf(name, sizeof name, "spi%u", bus_num);
-		bus = kset_find_obj(&spi_master_class.subsys.kset, name);
-		if (bus)
-			return container_of(bus, struct spi_master, cdev.kobj);
-	}
+	char			name[9];
+	struct kobject		*bus;
+
+	snprintf(name, sizeof name, "spi%u", bus_num);
+	bus = kset_find_obj(&spi_master_class.subsys.kset, name);
+	if (bus)
+		return container_of(bus, struct spi_master, cdev.kobj);
 	return NULL;
 }
 EXPORT_SYMBOL_GPL(spi_busnum_to_master);

commit 89fc9a1a79725c3e5c3b66cb6bd2c7d9eeab29fa
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Dec 6 20:35:35 2006 -0800

    [PATCH] SPI: improve sysfs compiler complaint handling
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 09f2c74a40c5..1a3c963dc48a 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -447,7 +447,9 @@ static int __unregister(struct device *dev, void *unused)
  */
 void spi_unregister_master(struct spi_master *master)
 {
-	(void) device_for_each_child(master->cdev.dev, NULL, __unregister);
+	int dummy;
+
+	dummy = device_for_each_child(master->cdev.dev, NULL, __unregister);
 	class_device_unregister(&master->cdev);
 }
 EXPORT_SYMBOL_GPL(spi_unregister_master);

commit e94b1766097d53e6f3ccfb36c8baa562ffeda3fc
Author: Christoph Lameter <clameter@sgi.com>
Date:   Wed Dec 6 20:33:17 2006 -0800

    [PATCH] slab: remove SLAB_KERNEL
    
    SLAB_KERNEL is an alias of GFP_KERNEL.
    
    Signed-off-by: Christoph Lameter <clameter@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index c3c0626f550b..09f2c74a40c5 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -360,7 +360,7 @@ spi_alloc_master(struct device *dev, unsigned size)
 	if (!dev)
 		return NULL;
 
-	master = kzalloc(size + sizeof *master, SLAB_KERNEL);
+	master = kzalloc(size + sizeof *master, GFP_KERNEL);
 	if (!master)
 		return NULL;
 
@@ -607,7 +607,7 @@ static int __init spi_init(void)
 {
 	int	status;
 
-	buf = kmalloc(SPI_BUFSIZ, SLAB_KERNEL);
+	buf = kmalloc(SPI_BUFSIZ, GFP_KERNEL);
 	if (!buf) {
 		status = -ENOMEM;
 		goto err0;

commit d3e5a938e7ed718f6d191e8b6b176fcfeb88a294
Author: Andrew Morton <akpm@osdl.org>
Date:   Thu Nov 2 22:07:20 2006 -0800

    [PATCH] spi section fix
    
    WARNING: vmlinux - Section mismatch: reference to .init.text:spi_register_board_info from __ksymtab_gpl between '__ksymtab_spi_register_board_info' (at offset 0xc032f7d0) and '__ksymtab_spi_alloc_master'
    
    Fix this by removing the export.
    
    Acked-by: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 146298ad7371..c3c0626f550b 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -281,7 +281,6 @@ spi_register_board_info(struct spi_board_info const *info, unsigned n)
 	up(&board_lock);
 	return 0;
 }
-EXPORT_SYMBOL_GPL(spi_register_board_info);
 
 /* FIXME someone should add support for a __setup("spi", ...) that
  * creates board info from kernel command lines

commit 60be6b9a41cb0da0df7a9f11486da56baebf04cd
Author: Ingo Molnar <mingo@elte.hu>
Date:   Mon Jul 3 00:25:26 2006 -0700

    [PATCH] lockdep: annotate on-stack completions
    
    lockdep needs to have the waitqueue lock initialized for on-stack waitqueues
    implicitly initialized by DECLARE_COMPLETION().  Annotate on-stack completions
    accordingly.
    
    Has no effect on non-lockdep kernels.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index ed1cdf6ac8f3..146298ad7371 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -510,7 +510,7 @@ static void spi_complete(void *arg)
  */
 int spi_sync(struct spi_device *spi, struct spi_message *message)
 {
-	DECLARE_COMPLETION(done);
+	DECLARE_COMPLETION_ONSTACK(done);
 	int status;
 
 	message->complete = spi_complete;

commit 980a01c9bfb090cb8a991e39e56ac379c30c61b8
Author: David Brownell <david-b@pacbell.net>
Date:   Wed Jun 28 07:47:15 2006 -0700

    [PATCH] SPI: infrastructure to initialize spi_device.mode early
    
    This patch adds earlier initialization of spi_device.mode, as needed
    on boards using nondefault chipselect polarity.  An example would be
    ones using the RS5C348 RTC without an external signal inverter between
    the RTC chipselect and the SPI controller.
    
    Without this mechanism, the first setup() call for that chip would
    wrongly enable chips, corrupting transfers to/from other chips sharing
    that SPI bus.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 1cea4a6799fe..ed1cdf6ac8f3 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -210,6 +210,7 @@ spi_new_device(struct spi_master *master, struct spi_board_info *chip)
 	proxy->master = master;
 	proxy->chip_select = chip->chip_select;
 	proxy->max_speed_hz = chip->max_speed_hz;
+	proxy->mode = chip->mode;
 	proxy->irq = chip->irq;
 	proxy->modalias = chip->modalias;
 

commit ba1a051319dc2bec9f43b7cef11c6e5270107fd6
Author: dmitry pervushin <dpervushin@ru.mvista.com>
Date:   Sat May 20 15:00:14 2006 -0700

    [PATCH] minor SPI doc fix
    
    Because several developers asked me about referenced but missing
    spi_add_master(), I think that this patch should be applied ...  it
    corrects comments so they refer to spi_register_master() instead.
    
    Signed-off-by: dmitry pervushin <dpervushin@ru.mvista.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 7a3f733051e9..1cea4a6799fe 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -338,18 +338,18 @@ static struct class spi_master_class = {
  * spi_alloc_master - allocate SPI master controller
  * @dev: the controller, possibly using the platform_bus
  * @size: how much driver-private data to preallocate; the pointer to this
- * 	memory is in the class_data field of the returned class_device,
+ *	memory is in the class_data field of the returned class_device,
  *	accessible with spi_master_get_devdata().
  *
  * This call is used only by SPI master controller drivers, which are the
  * only ones directly touching chip registers.  It's how they allocate
- * an spi_master structure, prior to calling spi_add_master().
+ * an spi_master structure, prior to calling spi_register_master().
  *
  * This must be called from context that can sleep.  It returns the SPI
  * master structure on success, else NULL.
  *
  * The caller is responsible for assigning the bus number and initializing
- * the master's methods before calling spi_add_master(); and (after errors
+ * the master's methods before calling spi_register_master(); and (after errors
  * adding the device) calling spi_master_put() to prevent a memory leak.
  */
 struct spi_master * __init_or_module

commit a020ed7521a9737bcf3e34eb880867c60c3c68d0
Author: David Brownell <david-b@pacbell.net>
Date:   Mon Apr 3 15:49:04 2006 -0700

    [PATCH] SPI: busnum == 0 needs to work
    
    We need to be able to have a "SPI bus 0" matching chip numbering; but
    that number was wrongly used to flag dynamic allocation of a bus number.
    
    This patch resolves that issue; now negative numbers trigger dynamic alloc.
    
    It also updates the how-to-write-a-controller-driver overview to mention
    this stuff.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 1168ef015887..7a3f733051e9 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -395,7 +395,7 @@ EXPORT_SYMBOL_GPL(spi_alloc_master);
 int __init_or_module
 spi_register_master(struct spi_master *master)
 {
-	static atomic_t		dyn_bus_id = ATOMIC_INIT(0);
+	static atomic_t		dyn_bus_id = ATOMIC_INIT((1<<16) - 1);
 	struct device		*dev = master->cdev.dev;
 	int			status = -ENODEV;
 	int			dynamic = 0;
@@ -404,7 +404,7 @@ spi_register_master(struct spi_master *master)
 		return -ENODEV;
 
 	/* convention:  dynamically assigned bus IDs count down from the max */
-	if (master->bus_num == 0) {
+	if (master->bus_num < 0) {
 		master->bus_num = atomic_dec_return(&dyn_bus_id);
 		dynamic = 1;
 	}

commit a9948b6194b46e489aa3b4d111d6dfd786c39c4b
Author: David Brownell <david-b@pacbell.net>
Date:   Sun Apr 2 10:37:40 2006 -0800

    [PATCH] SPI: spi bounce buffer has a minimum length
    
    Make sure that spi_write_then_read() can always handle at least 32 bytes
    of transfer (total, both directions), minimizing one portability issue.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 94f5e8ed83a7..1168ef015887 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -522,7 +522,8 @@ int spi_sync(struct spi_device *spi, struct spi_message *message)
 }
 EXPORT_SYMBOL_GPL(spi_sync);
 
-#define	SPI_BUFSIZ	(SMP_CACHE_BYTES)
+/* portable code must never pass more than 32 bytes */
+#define	SPI_BUFSIZ	max(32,SMP_CACHE_BYTES)
 
 static u8	*buf;
 

commit d2799f083dcad0413ad1a396e9bc32d9afb70535
Author: Stephen Street <stephen@streetfiresound.com>
Date:   Mon Feb 20 18:27:56 2006 -0800

    [PATCH] spi: Fix modular master driver remove and device suspend/remove
    
    Fix two problems in the spi subsystem:
    
    1) spi subsystem core dumps when modular spi master is unloaded.
    2) spi subsystem core dumps when spi slave device is suspended/resumed and
       module slave driver is not loaded.
    
    Signed-off-by: Stephen Street <stephen@streetfiresound.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 791c4dc550ae..94f5e8ed83a7 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -90,7 +90,7 @@ static int spi_suspend(struct device *dev, pm_message_t message)
 	int			value;
 	struct spi_driver	*drv = to_spi_driver(dev->driver);
 
-	if (!drv->suspend)
+	if (!drv || !drv->suspend)
 		return 0;
 
 	/* suspend will stop irqs and dma; no more i/o */
@@ -105,7 +105,7 @@ static int spi_resume(struct device *dev)
 	int			value;
 	struct spi_driver	*drv = to_spi_driver(dev->driver);
 
-	if (!drv->resume)
+	if (!drv || !drv->resume)
 		return 0;
 
 	/* resume may restart the i/o queue */
@@ -449,7 +449,6 @@ void spi_unregister_master(struct spi_master *master)
 {
 	(void) device_for_each_child(master->cdev.dev, NULL, __unregister);
 	class_device_unregister(&master->cdev);
-	master->cdev.dev = NULL;
 }
 EXPORT_SYMBOL_GPL(spi_unregister_master);
 

commit 5d870c8e216f121307445c71caa72e7e10a20061
Author: Andrew Morton <akpm@osdl.org>
Date:   Wed Jan 11 11:23:49 2006 -0800

    [PATCH] spi: remove fastcall crap
    
    gcc4 generates warnings when a non-FASTCALL function pointer is assigned to a
    FASTCALL one.  Perhaps it has taste.
    
    Cc: David Brownell <david-b@pacbell.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index cdb242de901d..791c4dc550ae 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -480,6 +480,11 @@ EXPORT_SYMBOL_GPL(spi_busnum_to_master);
 
 /*-------------------------------------------------------------------------*/
 
+static void spi_complete(void *arg)
+{
+	complete(arg);
+}
+
 /**
  * spi_sync - blocking/synchronous SPI data transfers
  * @spi: device with which data will be exchanged
@@ -508,7 +513,7 @@ int spi_sync(struct spi_device *spi, struct spi_message *message)
 	DECLARE_COMPLETION(done);
 	int status;
 
-	message->complete = (void (*)(void *)) complete;
+	message->complete = spi_complete;
 	message->context = &done;
 	status = spi_async(spi, message);
 	if (status == 0)

commit 8275c642ccdce09a2146d0a9eb022e3698ee927e
Author: Vitaly Wool <vwool@ru.mvista.com>
Date:   Sun Jan 8 13:34:28 2006 -0800

    [PATCH] spi: use linked lists rather than an array
    
    This makes the SPI core and its users access transfers in the SPI message
    structure as linked list not as an array, as discussed on LKML.
    
    From: David Brownell <dbrownell@users.sourceforge.net>
    
      Updates including doc, bugfixes to the list code, add
      spi_message_add_tail().  Plus, initialize things _before_ grabbing the
      locks in some cases (in case it grows more expensive).  This also merges
      some bitbang updates of mine that didn't yet make it into the mm tree.
    
    Signed-off-by: Vitaly Wool <vwool@ru.mvista.com>
    Signed-off-by: Dmitry Pervushin <dpervushin@gmail.com>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 3ecedccdb96c..cdb242de901d 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -557,6 +557,17 @@ int spi_write_then_read(struct spi_device *spi,
 	if ((n_tx + n_rx) > SPI_BUFSIZ)
 		return -EINVAL;
 
+	spi_message_init(&message);
+	memset(x, 0, sizeof x);
+	if (n_tx) {
+		x[0].len = n_tx;
+		spi_message_add_tail(&x[0], &message);
+	}
+	if (n_rx) {
+		x[1].len = n_rx;
+		spi_message_add_tail(&x[1], &message);
+	}
+
 	/* ... unless someone else is using the pre-allocated buffer */
 	if (down_trylock(&lock)) {
 		local_buf = kmalloc(SPI_BUFSIZ, GFP_KERNEL);
@@ -565,18 +576,11 @@ int spi_write_then_read(struct spi_device *spi,
 	} else
 		local_buf = buf;
 
-	memset(x, 0, sizeof x);
-
 	memcpy(local_buf, txbuf, n_tx);
 	x[0].tx_buf = local_buf;
-	x[0].len = n_tx;
-
 	x[1].rx_buf = local_buf + n_tx;
-	x[1].len = n_rx;
 
 	/* do the i/o */
-	message.transfers = x;
-	message.n_transfer = ARRAY_SIZE(x);
 	status = spi_sync(spi, &message);
 	if (status == 0) {
 		memcpy(rxbuf, x[1].rx_buf, n_rx);

commit 0c868461fcb8413cb9f691d68e5b99b0fd3c0737
Author: David Brownell <david-b@pacbell.net>
Date:   Sun Jan 8 13:34:25 2006 -0800

    [PATCH] SPI core tweaks, bugfix
    
    This includes various updates to the SPI core:
    
      - Fixes a driver model refcount bug in spi_unregister_master() paths.
    
      - The spi_master structures now have wrappers which help keep drivers
        from needing class-level get/put for device data or for refcounts.
    
      - Check for a few setup errors that would cause oopsing later.
    
      - Docs say more about memory management.  Highlights the use of DMA-safe
        i/o buffers, and zero-initializing spi_message and such metadata.
    
      - Provide a simple alloc/free for spi_message and its spi_transfer;
        this is only one of the possible memory management policies.
    
    Nothing to break code that already works.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 2ecb86cb3689..3ecedccdb96c 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -38,7 +38,7 @@ static void spidev_release(struct device *dev)
 	if (spi->master->cleanup)
 		spi->master->cleanup(spi);
 
-	class_device_put(&spi->master->cdev);
+	spi_master_put(spi->master);
 	kfree(dev);
 }
 
@@ -90,7 +90,7 @@ static int spi_suspend(struct device *dev, pm_message_t message)
 	int			value;
 	struct spi_driver	*drv = to_spi_driver(dev->driver);
 
-	if (!drv || !drv->suspend)
+	if (!drv->suspend)
 		return 0;
 
 	/* suspend will stop irqs and dma; no more i/o */
@@ -105,7 +105,7 @@ static int spi_resume(struct device *dev)
 	int			value;
 	struct spi_driver	*drv = to_spi_driver(dev->driver);
 
-	if (!drv || !drv->resume)
+	if (!drv->resume)
 		return 0;
 
 	/* resume may restart the i/o queue */
@@ -198,7 +198,7 @@ spi_new_device(struct spi_master *master, struct spi_board_info *chip)
 
 	/* NOTE:  caller did any chip->bus_num checks necessary */
 
-	if (!class_device_get(&master->cdev))
+	if (!spi_master_get(master))
 		return NULL;
 
 	proxy = kzalloc(sizeof *proxy, GFP_KERNEL);
@@ -244,7 +244,7 @@ spi_new_device(struct spi_master *master, struct spi_board_info *chip)
 	return proxy;
 
 fail:
-	class_device_put(&master->cdev);
+	spi_master_put(master);
 	kfree(proxy);
 	return NULL;
 }
@@ -324,8 +324,6 @@ static void spi_master_release(struct class_device *cdev)
 	struct spi_master *master;
 
 	master = container_of(cdev, struct spi_master, cdev);
-	put_device(master->cdev.dev);
-	master->cdev.dev = NULL;
 	kfree(master);
 }
 
@@ -339,8 +337,9 @@ static struct class spi_master_class = {
 /**
  * spi_alloc_master - allocate SPI master controller
  * @dev: the controller, possibly using the platform_bus
- * @size: how much driver-private data to preallocate; a pointer to this
- * 	memory in the class_data field of the returned class_device
+ * @size: how much driver-private data to preallocate; the pointer to this
+ * 	memory is in the class_data field of the returned class_device,
+ *	accessible with spi_master_get_devdata().
  *
  * This call is used only by SPI master controller drivers, which are the
  * only ones directly touching chip registers.  It's how they allocate
@@ -350,14 +349,17 @@ static struct class spi_master_class = {
  * master structure on success, else NULL.
  *
  * The caller is responsible for assigning the bus number and initializing
- * the master's methods before calling spi_add_master(), or else (on error)
- * calling class_device_put() to prevent a memory leak.
+ * the master's methods before calling spi_add_master(); and (after errors
+ * adding the device) calling spi_master_put() to prevent a memory leak.
  */
 struct spi_master * __init_or_module
 spi_alloc_master(struct device *dev, unsigned size)
 {
 	struct spi_master	*master;
 
+	if (!dev)
+		return NULL;
+
 	master = kzalloc(size + sizeof *master, SLAB_KERNEL);
 	if (!master)
 		return NULL;
@@ -365,7 +367,7 @@ spi_alloc_master(struct device *dev, unsigned size)
 	class_device_initialize(&master->cdev);
 	master->cdev.class = &spi_master_class;
 	master->cdev.dev = get_device(dev);
-	class_set_devdata(&master->cdev, &master[1]);
+	spi_master_set_devdata(master, &master[1]);
 
 	return master;
 }
@@ -387,6 +389,8 @@ EXPORT_SYMBOL_GPL(spi_alloc_master);
  *
  * This must be called from context that can sleep.  It returns zero on
  * success, else a negative error code (dropping the master's refcount).
+ * After a successful return, the caller is responsible for calling
+ * spi_unregister_master().
  */
 int __init_or_module
 spi_register_master(struct spi_master *master)
@@ -396,6 +400,9 @@ spi_register_master(struct spi_master *master)
 	int			status = -ENODEV;
 	int			dynamic = 0;
 
+	if (!dev)
+		return -ENODEV;
+
 	/* convention:  dynamically assigned bus IDs count down from the max */
 	if (master->bus_num == 0) {
 		master->bus_num = atomic_dec_return(&dyn_bus_id);
@@ -425,7 +432,7 @@ EXPORT_SYMBOL_GPL(spi_register_master);
 static int __unregister(struct device *dev, void *unused)
 {
 	/* note: before about 2.6.14-rc1 this would corrupt memory: */
-	device_unregister(dev);
+	spi_unregister_device(to_spi_device(dev));
 	return 0;
 }
 
@@ -440,8 +447,9 @@ static int __unregister(struct device *dev, void *unused)
  */
 void spi_unregister_master(struct spi_master *master)
 {
-	class_device_unregister(&master->cdev);
 	(void) device_for_each_child(master->cdev.dev, NULL, __unregister);
+	class_device_unregister(&master->cdev);
+	master->cdev.dev = NULL;
 }
 EXPORT_SYMBOL_GPL(spi_unregister_master);
 
@@ -487,6 +495,9 @@ EXPORT_SYMBOL_GPL(spi_busnum_to_master);
  * by leaving it selected in anticipation that the next message will go
  * to the same chip.  (That may increase power usage.)
  *
+ * Also, the caller is guaranteeing that the memory associated with the
+ * message will not be freed before this call returns.
+ *
  * The return value is a negative error code if the message could not be
  * submitted, else zero.  When the value is zero, then message->status is
  * also defined:  it's the completion code for the transfer, either zero
@@ -524,9 +535,9 @@ static u8	*buf;
  * is zero for success, else a negative errno status code.
  * This call may only be used from a context that may sleep.
  *
- * Parameters to this routine are always copied using a small buffer,
- * large transfers should use use spi_{async,sync}() calls with
- * dma-safe buffers.
+ * Parameters to this routine are always copied using a small buffer;
+ * performance-sensitive or bulk transfer code should instead use
+ * spi_{async,sync}() calls with dma-safe buffers.
  */
 int spi_write_then_read(struct spi_device *spi,
 		const u8 *txbuf, unsigned n_tx,

commit b885244eb2628e0b8206e7edaaa6a314da78e9a4
Author: David Brownell <david-b@pacbell.net>
Date:   Sun Jan 8 13:34:23 2006 -0800

    [PATCH] spi: add spi_driver to SPI framework
    
    This is a refresh of the "Simple SPI Framework" found in 2.6.15-rc3-mm1
    which makes the following changes:
    
      * There's now a "struct spi_driver".  This increase the footprint
        of the core a bit, since it now includes code to do what the driver
        core was previously handling directly.  Documentation and comments
        were updated to match.
    
      * spi_alloc_master() now does class_device_initialize(), so it can
        at least be refcounted before spi_register_master().  To match,
        spi_register_master() switched over to class_device_add().
    
      * States explicitly that after transfer errors, spi_devices will be
        deselected.  We want fault recovery procedures to work the same
        for all controller drivers.
    
      * Minor tweaks:  controller_data no longer points to readonly data;
        prevent some potential cast-from-null bugs with container_of calls;
        clarifies some existing kerneldoc,
    
    And a few small cleanups.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 7cd356b17644..2ecb86cb3689 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -26,13 +26,9 @@
 #include <linux/spi/spi.h>
 
 
-/* SPI bustype and spi_master class are registered during early boot,
- * usually before board init code provides the SPI device tables, and
- * are available later when driver init code needs them.
- *
- * Drivers for SPI devices started out like those for platform bus
- * devices.  But both have changed in 2.6.15; maybe this should get
- * an "spi_driver" structure at some point (not currently needed)
+/* SPI bustype and spi_master class are registered after board init code
+ * provides the SPI device tables, ensuring that both are present by the
+ * time controller driver registration causes spi_devices to "enumerate".
  */
 static void spidev_release(struct device *dev)
 {
@@ -83,10 +79,7 @@ static int spi_uevent(struct device *dev, char **envp, int num_envp,
 
 #ifdef	CONFIG_PM
 
-/* Suspend/resume in "struct device_driver" don't really need that
- * strange third parameter, so we just make it a constant and expect
- * SPI drivers to ignore it just like most platform drivers do.
- *
+/*
  * NOTE:  the suspend() method for an spi_master controller driver
  * should verify that all its child devices are marked as suspended;
  * suspend requests delivered through sysfs power/state files don't
@@ -94,13 +87,14 @@ static int spi_uevent(struct device *dev, char **envp, int num_envp,
  */
 static int spi_suspend(struct device *dev, pm_message_t message)
 {
-	int	value;
+	int			value;
+	struct spi_driver	*drv = to_spi_driver(dev->driver);
 
-	if (!dev->driver || !dev->driver->suspend)
+	if (!drv || !drv->suspend)
 		return 0;
 
 	/* suspend will stop irqs and dma; no more i/o */
-	value = dev->driver->suspend(dev, message);
+	value = drv->suspend(to_spi_device(dev), message);
 	if (value == 0)
 		dev->power.power_state = message;
 	return value;
@@ -108,13 +102,14 @@ static int spi_suspend(struct device *dev, pm_message_t message)
 
 static int spi_resume(struct device *dev)
 {
-	int	value;
+	int			value;
+	struct spi_driver	*drv = to_spi_driver(dev->driver);
 
-	if (!dev->driver || !dev->driver->resume)
+	if (!drv || !drv->resume)
 		return 0;
 
 	/* resume may restart the i/o queue */
-	value = dev->driver->resume(dev);
+	value = drv->resume(to_spi_device(dev));
 	if (value == 0)
 		dev->power.power_state = PMSG_ON;
 	return value;
@@ -135,6 +130,41 @@ struct bus_type spi_bus_type = {
 };
 EXPORT_SYMBOL_GPL(spi_bus_type);
 
+
+static int spi_drv_probe(struct device *dev)
+{
+	const struct spi_driver		*sdrv = to_spi_driver(dev->driver);
+
+	return sdrv->probe(to_spi_device(dev));
+}
+
+static int spi_drv_remove(struct device *dev)
+{
+	const struct spi_driver		*sdrv = to_spi_driver(dev->driver);
+
+	return sdrv->remove(to_spi_device(dev));
+}
+
+static void spi_drv_shutdown(struct device *dev)
+{
+	const struct spi_driver		*sdrv = to_spi_driver(dev->driver);
+
+	sdrv->shutdown(to_spi_device(dev));
+}
+
+int spi_register_driver(struct spi_driver *sdrv)
+{
+	sdrv->driver.bus = &spi_bus_type;
+	if (sdrv->probe)
+		sdrv->driver.probe = spi_drv_probe;
+	if (sdrv->remove)
+		sdrv->driver.remove = spi_drv_remove;
+	if (sdrv->shutdown)
+		sdrv->driver.shutdown = spi_drv_shutdown;
+	return driver_register(&sdrv->driver);
+}
+EXPORT_SYMBOL_GPL(spi_register_driver);
+
 /*-------------------------------------------------------------------------*/
 
 /* SPI devices should normally not be created by SPI device drivers; that
@@ -208,13 +238,15 @@ spi_new_device(struct spi_master *master, struct spi_board_info *chip)
 	if (status < 0) {
 		dev_dbg(dev, "can't %s %s, status %d\n",
 				"add", proxy->dev.bus_id, status);
-fail:
-		class_device_put(&master->cdev);
-		kfree(proxy);
-		return NULL;
+		goto fail;
 	}
 	dev_dbg(dev, "registered child %s\n", proxy->dev.bus_id);
 	return proxy;
+
+fail:
+	class_device_put(&master->cdev);
+	kfree(proxy);
+	return NULL;
 }
 EXPORT_SYMBOL_GPL(spi_new_device);
 
@@ -237,11 +269,11 @@ spi_register_board_info(struct spi_board_info const *info, unsigned n)
 {
 	struct boardinfo	*bi;
 
-	bi = kmalloc (sizeof (*bi) + n * sizeof (*info), GFP_KERNEL);
+	bi = kmalloc(sizeof(*bi) + n * sizeof *info, GFP_KERNEL);
 	if (!bi)
 		return -ENOMEM;
 	bi->n_board_info = n;
-	memcpy(bi->board_info, info, n * sizeof (*info));
+	memcpy(bi->board_info, info, n * sizeof *info);
 
 	down(&board_lock);
 	list_add_tail(&bi->list, &board_list);
@@ -330,6 +362,7 @@ spi_alloc_master(struct device *dev, unsigned size)
 	if (!master)
 		return NULL;
 
+	class_device_initialize(&master->cdev);
 	master->cdev.class = &spi_master_class;
 	master->cdev.dev = get_device(dev);
 	class_set_devdata(&master->cdev, &master[1]);
@@ -366,7 +399,7 @@ spi_register_master(struct spi_master *master)
 	/* convention:  dynamically assigned bus IDs count down from the max */
 	if (master->bus_num == 0) {
 		master->bus_num = atomic_dec_return(&dyn_bus_id);
-		dynamic = 0;
+		dynamic = 1;
 	}
 
 	/* register the device, then userspace will see it.
@@ -374,11 +407,9 @@ spi_register_master(struct spi_master *master)
 	 */
 	snprintf(master->cdev.class_id, sizeof master->cdev.class_id,
 		"spi%u", master->bus_num);
-	status = class_device_register(&master->cdev);
-	if (status < 0) {
-		class_device_put(&master->cdev);
+	status = class_device_add(&master->cdev);
+	if (status < 0)
 		goto done;
-	}
 	dev_dbg(dev, "registered master %s%s\n", master->cdev.class_id,
 			dynamic ? " (dynamic)" : "");
 
@@ -491,6 +522,7 @@ static u8	*buf;
  * This performs a half duplex MicroWire style transaction with the
  * device, sending txbuf and then reading rxbuf.  The return value
  * is zero for success, else a negative errno status code.
+ * This call may only be used from a context that may sleep.
  *
  * Parameters to this routine are always copied using a small buffer,
  * large transfers should use use spi_{async,sync}() calls with
@@ -553,16 +585,38 @@ EXPORT_SYMBOL_GPL(spi_write_then_read);
 
 static int __init spi_init(void)
 {
+	int	status;
+
 	buf = kmalloc(SPI_BUFSIZ, SLAB_KERNEL);
-	if (!buf)
-		return -ENOMEM;
+	if (!buf) {
+		status = -ENOMEM;
+		goto err0;
+	}
+
+	status = bus_register(&spi_bus_type);
+	if (status < 0)
+		goto err1;
 
-	bus_register(&spi_bus_type);
-	class_register(&spi_master_class);
+	status = class_register(&spi_master_class);
+	if (status < 0)
+		goto err2;
 	return 0;
+
+err2:
+	bus_unregister(&spi_bus_type);
+err1:
+	kfree(buf);
+	buf = NULL;
+err0:
+	return status;
 }
+
 /* board_info is normally registered in arch_initcall(),
  * but even essential drivers wait till later
+ *
+ * REVISIT only boardinfo really needs static linking. the rest (device and
+ * driver registration) _could_ be dynamically linked (modular) ... costs
+ * include needing to have boardinfo data structures be much more public.
  */
 subsys_initcall(spi_init);
 

commit 8ae12a0d85987dc138f8c944cb78a92bf466cea0
Author: David Brownell <david-b@pacbell.net>
Date:   Sun Jan 8 13:34:19 2006 -0800

    [PATCH] spi: simple SPI framework
    
    This is the core of a small SPI framework, implementing the model of a
    queue of messages which complete asynchronously (with thin synchronous
    wrappers on top).
    
      - It's still less than 2KB of ".text" (ARM).  If there's got to be a
        mid-layer for something so simple, that's the right size budget.  :)
    
      - The guts use board-specific SPI device tables to build the driver
        model tree.  (Hardware probing is rarely an option.)
    
      - This version of Kconfig includes no drivers.  At this writing there
        are two known master controller drivers (PXA/SSP, OMAP MicroWire)
        and three protocol drivers (CS8415a, ADS7846, DataFlash) with LKML
        mentions of other drivers in development.
    
      - No userspace API.  There are several implementations to compare.
        Implement them like any other driver, and bind them with sysfs.
    
    The changes from last version posted to LKML (on 11-Nov-2005) are minor,
    and include:
    
      - One bugfix (removes a FIXME), with the visible effect of making device
        names be "spiB.C" where B is the bus number and C is the chipselect.
    
      - The "caller provides DMA mappings" mechanism now has kerneldoc, for
        DMA drivers that want to be fancy.
    
      - Hey, the framework init can be subsys_init.  Even though board init
        logic fires earlier, at arch_init ... since the framework init is
        for driver support, and the board init support uses static init.
    
      - Various additional spec/doc clarifications based on discussions
        with other folk.  It adds a brief "thank you" at the end, for folk
        who've helped nudge this framework into existence.
    
    As I've said before, I think that "protocol tweaking" is the main support
    that this driver framework will need to evolve.
    
    From: Mark Underwood <basicmark@yahoo.com>
    
      Update the SPI framework to remove a potential priority inversion case by
      reverting to kmalloc if the pre-allocated DMA-safe buffer isn't available.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
new file mode 100644
index 000000000000..7cd356b17644
--- /dev/null
+++ b/drivers/spi/spi.c
@@ -0,0 +1,568 @@
+/*
+ * spi.c - SPI init/core code
+ *
+ * Copyright (C) 2005 David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/cache.h>
+#include <linux/spi/spi.h>
+
+
+/* SPI bustype and spi_master class are registered during early boot,
+ * usually before board init code provides the SPI device tables, and
+ * are available later when driver init code needs them.
+ *
+ * Drivers for SPI devices started out like those for platform bus
+ * devices.  But both have changed in 2.6.15; maybe this should get
+ * an "spi_driver" structure at some point (not currently needed)
+ */
+static void spidev_release(struct device *dev)
+{
+	const struct spi_device	*spi = to_spi_device(dev);
+
+	/* spi masters may cleanup for released devices */
+	if (spi->master->cleanup)
+		spi->master->cleanup(spi);
+
+	class_device_put(&spi->master->cdev);
+	kfree(dev);
+}
+
+static ssize_t
+modalias_show(struct device *dev, struct device_attribute *a, char *buf)
+{
+	const struct spi_device	*spi = to_spi_device(dev);
+
+	return snprintf(buf, BUS_ID_SIZE + 1, "%s\n", spi->modalias);
+}
+
+static struct device_attribute spi_dev_attrs[] = {
+	__ATTR_RO(modalias),
+	__ATTR_NULL,
+};
+
+/* modalias support makes "modprobe $MODALIAS" new-style hotplug work,
+ * and the sysfs version makes coldplug work too.
+ */
+
+static int spi_match_device(struct device *dev, struct device_driver *drv)
+{
+	const struct spi_device	*spi = to_spi_device(dev);
+
+	return strncmp(spi->modalias, drv->name, BUS_ID_SIZE) == 0;
+}
+
+static int spi_uevent(struct device *dev, char **envp, int num_envp,
+		char *buffer, int buffer_size)
+{
+	const struct spi_device		*spi = to_spi_device(dev);
+
+	envp[0] = buffer;
+	snprintf(buffer, buffer_size, "MODALIAS=%s", spi->modalias);
+	envp[1] = NULL;
+	return 0;
+}
+
+#ifdef	CONFIG_PM
+
+/* Suspend/resume in "struct device_driver" don't really need that
+ * strange third parameter, so we just make it a constant and expect
+ * SPI drivers to ignore it just like most platform drivers do.
+ *
+ * NOTE:  the suspend() method for an spi_master controller driver
+ * should verify that all its child devices are marked as suspended;
+ * suspend requests delivered through sysfs power/state files don't
+ * enforce such constraints.
+ */
+static int spi_suspend(struct device *dev, pm_message_t message)
+{
+	int	value;
+
+	if (!dev->driver || !dev->driver->suspend)
+		return 0;
+
+	/* suspend will stop irqs and dma; no more i/o */
+	value = dev->driver->suspend(dev, message);
+	if (value == 0)
+		dev->power.power_state = message;
+	return value;
+}
+
+static int spi_resume(struct device *dev)
+{
+	int	value;
+
+	if (!dev->driver || !dev->driver->resume)
+		return 0;
+
+	/* resume may restart the i/o queue */
+	value = dev->driver->resume(dev);
+	if (value == 0)
+		dev->power.power_state = PMSG_ON;
+	return value;
+}
+
+#else
+#define spi_suspend	NULL
+#define spi_resume	NULL
+#endif
+
+struct bus_type spi_bus_type = {
+	.name		= "spi",
+	.dev_attrs	= spi_dev_attrs,
+	.match		= spi_match_device,
+	.uevent		= spi_uevent,
+	.suspend	= spi_suspend,
+	.resume		= spi_resume,
+};
+EXPORT_SYMBOL_GPL(spi_bus_type);
+
+/*-------------------------------------------------------------------------*/
+
+/* SPI devices should normally not be created by SPI device drivers; that
+ * would make them board-specific.  Similarly with SPI master drivers.
+ * Device registration normally goes into like arch/.../mach.../board-YYY.c
+ * with other readonly (flashable) information about mainboard devices.
+ */
+
+struct boardinfo {
+	struct list_head	list;
+	unsigned		n_board_info;
+	struct spi_board_info	board_info[0];
+};
+
+static LIST_HEAD(board_list);
+static DECLARE_MUTEX(board_lock);
+
+
+/* On typical mainboards, this is purely internal; and it's not needed
+ * after board init creates the hard-wired devices.  Some development
+ * platforms may not be able to use spi_register_board_info though, and
+ * this is exported so that for example a USB or parport based adapter
+ * driver could add devices (which it would learn about out-of-band).
+ */
+struct spi_device *__init_or_module
+spi_new_device(struct spi_master *master, struct spi_board_info *chip)
+{
+	struct spi_device	*proxy;
+	struct device		*dev = master->cdev.dev;
+	int			status;
+
+	/* NOTE:  caller did any chip->bus_num checks necessary */
+
+	if (!class_device_get(&master->cdev))
+		return NULL;
+
+	proxy = kzalloc(sizeof *proxy, GFP_KERNEL);
+	if (!proxy) {
+		dev_err(dev, "can't alloc dev for cs%d\n",
+			chip->chip_select);
+		goto fail;
+	}
+	proxy->master = master;
+	proxy->chip_select = chip->chip_select;
+	proxy->max_speed_hz = chip->max_speed_hz;
+	proxy->irq = chip->irq;
+	proxy->modalias = chip->modalias;
+
+	snprintf(proxy->dev.bus_id, sizeof proxy->dev.bus_id,
+			"%s.%u", master->cdev.class_id,
+			chip->chip_select);
+	proxy->dev.parent = dev;
+	proxy->dev.bus = &spi_bus_type;
+	proxy->dev.platform_data = (void *) chip->platform_data;
+	proxy->controller_data = chip->controller_data;
+	proxy->controller_state = NULL;
+	proxy->dev.release = spidev_release;
+
+	/* drivers may modify this default i/o setup */
+	status = master->setup(proxy);
+	if (status < 0) {
+		dev_dbg(dev, "can't %s %s, status %d\n",
+				"setup", proxy->dev.bus_id, status);
+		goto fail;
+	}
+
+	/* driver core catches callers that misbehave by defining
+	 * devices that already exist.
+	 */
+	status = device_register(&proxy->dev);
+	if (status < 0) {
+		dev_dbg(dev, "can't %s %s, status %d\n",
+				"add", proxy->dev.bus_id, status);
+fail:
+		class_device_put(&master->cdev);
+		kfree(proxy);
+		return NULL;
+	}
+	dev_dbg(dev, "registered child %s\n", proxy->dev.bus_id);
+	return proxy;
+}
+EXPORT_SYMBOL_GPL(spi_new_device);
+
+/*
+ * Board-specific early init code calls this (probably during arch_initcall)
+ * with segments of the SPI device table.  Any device nodes are created later,
+ * after the relevant parent SPI controller (bus_num) is defined.  We keep
+ * this table of devices forever, so that reloading a controller driver will
+ * not make Linux forget about these hard-wired devices.
+ *
+ * Other code can also call this, e.g. a particular add-on board might provide
+ * SPI devices through its expansion connector, so code initializing that board
+ * would naturally declare its SPI devices.
+ *
+ * The board info passed can safely be __initdata ... but be careful of
+ * any embedded pointers (platform_data, etc), they're copied as-is.
+ */
+int __init
+spi_register_board_info(struct spi_board_info const *info, unsigned n)
+{
+	struct boardinfo	*bi;
+
+	bi = kmalloc (sizeof (*bi) + n * sizeof (*info), GFP_KERNEL);
+	if (!bi)
+		return -ENOMEM;
+	bi->n_board_info = n;
+	memcpy(bi->board_info, info, n * sizeof (*info));
+
+	down(&board_lock);
+	list_add_tail(&bi->list, &board_list);
+	up(&board_lock);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(spi_register_board_info);
+
+/* FIXME someone should add support for a __setup("spi", ...) that
+ * creates board info from kernel command lines
+ */
+
+static void __init_or_module
+scan_boardinfo(struct spi_master *master)
+{
+	struct boardinfo	*bi;
+	struct device		*dev = master->cdev.dev;
+
+	down(&board_lock);
+	list_for_each_entry(bi, &board_list, list) {
+		struct spi_board_info	*chip = bi->board_info;
+		unsigned		n;
+
+		for (n = bi->n_board_info; n > 0; n--, chip++) {
+			if (chip->bus_num != master->bus_num)
+				continue;
+			/* some controllers only have one chip, so they
+			 * might not use chipselects.  otherwise, the
+			 * chipselects are numbered 0..max.
+			 */
+			if (chip->chip_select >= master->num_chipselect
+					&& master->num_chipselect) {
+				dev_dbg(dev, "cs%d > max %d\n",
+					chip->chip_select,
+					master->num_chipselect);
+				continue;
+			}
+			(void) spi_new_device(master, chip);
+		}
+	}
+	up(&board_lock);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static void spi_master_release(struct class_device *cdev)
+{
+	struct spi_master *master;
+
+	master = container_of(cdev, struct spi_master, cdev);
+	put_device(master->cdev.dev);
+	master->cdev.dev = NULL;
+	kfree(master);
+}
+
+static struct class spi_master_class = {
+	.name		= "spi_master",
+	.owner		= THIS_MODULE,
+	.release	= spi_master_release,
+};
+
+
+/**
+ * spi_alloc_master - allocate SPI master controller
+ * @dev: the controller, possibly using the platform_bus
+ * @size: how much driver-private data to preallocate; a pointer to this
+ * 	memory in the class_data field of the returned class_device
+ *
+ * This call is used only by SPI master controller drivers, which are the
+ * only ones directly touching chip registers.  It's how they allocate
+ * an spi_master structure, prior to calling spi_add_master().
+ *
+ * This must be called from context that can sleep.  It returns the SPI
+ * master structure on success, else NULL.
+ *
+ * The caller is responsible for assigning the bus number and initializing
+ * the master's methods before calling spi_add_master(), or else (on error)
+ * calling class_device_put() to prevent a memory leak.
+ */
+struct spi_master * __init_or_module
+spi_alloc_master(struct device *dev, unsigned size)
+{
+	struct spi_master	*master;
+
+	master = kzalloc(size + sizeof *master, SLAB_KERNEL);
+	if (!master)
+		return NULL;
+
+	master->cdev.class = &spi_master_class;
+	master->cdev.dev = get_device(dev);
+	class_set_devdata(&master->cdev, &master[1]);
+
+	return master;
+}
+EXPORT_SYMBOL_GPL(spi_alloc_master);
+
+/**
+ * spi_register_master - register SPI master controller
+ * @master: initialized master, originally from spi_alloc_master()
+ *
+ * SPI master controllers connect to their drivers using some non-SPI bus,
+ * such as the platform bus.  The final stage of probe() in that code
+ * includes calling spi_register_master() to hook up to this SPI bus glue.
+ *
+ * SPI controllers use board specific (often SOC specific) bus numbers,
+ * and board-specific addressing for SPI devices combines those numbers
+ * with chip select numbers.  Since SPI does not directly support dynamic
+ * device identification, boards need configuration tables telling which
+ * chip is at which address.
+ *
+ * This must be called from context that can sleep.  It returns zero on
+ * success, else a negative error code (dropping the master's refcount).
+ */
+int __init_or_module
+spi_register_master(struct spi_master *master)
+{
+	static atomic_t		dyn_bus_id = ATOMIC_INIT(0);
+	struct device		*dev = master->cdev.dev;
+	int			status = -ENODEV;
+	int			dynamic = 0;
+
+	/* convention:  dynamically assigned bus IDs count down from the max */
+	if (master->bus_num == 0) {
+		master->bus_num = atomic_dec_return(&dyn_bus_id);
+		dynamic = 0;
+	}
+
+	/* register the device, then userspace will see it.
+	 * registration fails if the bus ID is in use.
+	 */
+	snprintf(master->cdev.class_id, sizeof master->cdev.class_id,
+		"spi%u", master->bus_num);
+	status = class_device_register(&master->cdev);
+	if (status < 0) {
+		class_device_put(&master->cdev);
+		goto done;
+	}
+	dev_dbg(dev, "registered master %s%s\n", master->cdev.class_id,
+			dynamic ? " (dynamic)" : "");
+
+	/* populate children from any spi device tables */
+	scan_boardinfo(master);
+	status = 0;
+done:
+	return status;
+}
+EXPORT_SYMBOL_GPL(spi_register_master);
+
+
+static int __unregister(struct device *dev, void *unused)
+{
+	/* note: before about 2.6.14-rc1 this would corrupt memory: */
+	device_unregister(dev);
+	return 0;
+}
+
+/**
+ * spi_unregister_master - unregister SPI master controller
+ * @master: the master being unregistered
+ *
+ * This call is used only by SPI master controller drivers, which are the
+ * only ones directly touching chip registers.
+ *
+ * This must be called from context that can sleep.
+ */
+void spi_unregister_master(struct spi_master *master)
+{
+	class_device_unregister(&master->cdev);
+	(void) device_for_each_child(master->cdev.dev, NULL, __unregister);
+}
+EXPORT_SYMBOL_GPL(spi_unregister_master);
+
+/**
+ * spi_busnum_to_master - look up master associated with bus_num
+ * @bus_num: the master's bus number
+ *
+ * This call may be used with devices that are registered after
+ * arch init time.  It returns a refcounted pointer to the relevant
+ * spi_master (which the caller must release), or NULL if there is
+ * no such master registered.
+ */
+struct spi_master *spi_busnum_to_master(u16 bus_num)
+{
+	if (bus_num) {
+		char			name[8];
+		struct kobject		*bus;
+
+		snprintf(name, sizeof name, "spi%u", bus_num);
+		bus = kset_find_obj(&spi_master_class.subsys.kset, name);
+		if (bus)
+			return container_of(bus, struct spi_master, cdev.kobj);
+	}
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(spi_busnum_to_master);
+
+
+/*-------------------------------------------------------------------------*/
+
+/**
+ * spi_sync - blocking/synchronous SPI data transfers
+ * @spi: device with which data will be exchanged
+ * @message: describes the data transfers
+ *
+ * This call may only be used from a context that may sleep.  The sleep
+ * is non-interruptible, and has no timeout.  Low-overhead controller
+ * drivers may DMA directly into and out of the message buffers.
+ *
+ * Note that the SPI device's chip select is active during the message,
+ * and then is normally disabled between messages.  Drivers for some
+ * frequently-used devices may want to minimize costs of selecting a chip,
+ * by leaving it selected in anticipation that the next message will go
+ * to the same chip.  (That may increase power usage.)
+ *
+ * The return value is a negative error code if the message could not be
+ * submitted, else zero.  When the value is zero, then message->status is
+ * also defined:  it's the completion code for the transfer, either zero
+ * or a negative error code from the controller driver.
+ */
+int spi_sync(struct spi_device *spi, struct spi_message *message)
+{
+	DECLARE_COMPLETION(done);
+	int status;
+
+	message->complete = (void (*)(void *)) complete;
+	message->context = &done;
+	status = spi_async(spi, message);
+	if (status == 0)
+		wait_for_completion(&done);
+	message->context = NULL;
+	return status;
+}
+EXPORT_SYMBOL_GPL(spi_sync);
+
+#define	SPI_BUFSIZ	(SMP_CACHE_BYTES)
+
+static u8	*buf;
+
+/**
+ * spi_write_then_read - SPI synchronous write followed by read
+ * @spi: device with which data will be exchanged
+ * @txbuf: data to be written (need not be dma-safe)
+ * @n_tx: size of txbuf, in bytes
+ * @rxbuf: buffer into which data will be read
+ * @n_rx: size of rxbuf, in bytes (need not be dma-safe)
+ *
+ * This performs a half duplex MicroWire style transaction with the
+ * device, sending txbuf and then reading rxbuf.  The return value
+ * is zero for success, else a negative errno status code.
+ *
+ * Parameters to this routine are always copied using a small buffer,
+ * large transfers should use use spi_{async,sync}() calls with
+ * dma-safe buffers.
+ */
+int spi_write_then_read(struct spi_device *spi,
+		const u8 *txbuf, unsigned n_tx,
+		u8 *rxbuf, unsigned n_rx)
+{
+	static DECLARE_MUTEX(lock);
+
+	int			status;
+	struct spi_message	message;
+	struct spi_transfer	x[2];
+	u8			*local_buf;
+
+	/* Use preallocated DMA-safe buffer.  We can't avoid copying here,
+	 * (as a pure convenience thing), but we can keep heap costs
+	 * out of the hot path ...
+	 */
+	if ((n_tx + n_rx) > SPI_BUFSIZ)
+		return -EINVAL;
+
+	/* ... unless someone else is using the pre-allocated buffer */
+	if (down_trylock(&lock)) {
+		local_buf = kmalloc(SPI_BUFSIZ, GFP_KERNEL);
+		if (!local_buf)
+			return -ENOMEM;
+	} else
+		local_buf = buf;
+
+	memset(x, 0, sizeof x);
+
+	memcpy(local_buf, txbuf, n_tx);
+	x[0].tx_buf = local_buf;
+	x[0].len = n_tx;
+
+	x[1].rx_buf = local_buf + n_tx;
+	x[1].len = n_rx;
+
+	/* do the i/o */
+	message.transfers = x;
+	message.n_transfer = ARRAY_SIZE(x);
+	status = spi_sync(spi, &message);
+	if (status == 0) {
+		memcpy(rxbuf, x[1].rx_buf, n_rx);
+		status = message.status;
+	}
+
+	if (x[0].tx_buf == buf)
+		up(&lock);
+	else
+		kfree(local_buf);
+
+	return status;
+}
+EXPORT_SYMBOL_GPL(spi_write_then_read);
+
+/*-------------------------------------------------------------------------*/
+
+static int __init spi_init(void)
+{
+	buf = kmalloc(SPI_BUFSIZ, SLAB_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	bus_register(&spi_bus_type);
+	class_register(&spi_master_class);
+	return 0;
+}
+/* board_info is normally registered in arch_initcall(),
+ * but even essential drivers wait till later
+ */
+subsys_initcall(spi_init);
+
