commit a4098bc6eed5e31e0391bcc068e61804c98138df
Author: Igor Druzhinin <igor.druzhinin@citrix.com>
Date:   Thu Sep 12 19:31:51 2019 +0100

    xen/pci: reserve MCFG areas earlier
    
    If MCFG area is not reserved in E820, Xen by default will defer its usage
    until Dom0 registers it explicitly after ACPI parser recognizes it as
    a reserved resource in DSDT. Having it reserved in E820 is not
    mandatory according to "PCI Firmware Specification, rev 3.2" (par. 4.1.2)
    and firmware is free to keep a hole in E820 in that place. Xen doesn't know
    what exactly is inside this hole since it lacks full ACPI view of the
    platform therefore it's potentially harmful to access MCFG region
    without additional checks as some machines are known to provide
    inconsistent information on the size of the region.
    
    Now xen_mcfg_late() runs after acpi_init() which is too late as some basic
    PCI enumeration starts exactly there as well. Trying to register a device
    prior to MCFG reservation causes multiple problems with PCIe extended
    capability initializations in Xen (e.g. SR-IOV VF BAR sizing). There are
    no convenient hooks for us to subscribe to so register MCFG areas earlier
    upon the first invocation of xen_add_device(). It should be safe to do once
    since all the boot time buses must have their MCFG areas in MCFG table
    already and we don't support PCI bus hot-plug.
    
    Signed-off-by: Igor Druzhinin <igor.druzhinin@citrix.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/drivers/xen/pci.c b/drivers/xen/pci.c
index 3eeb9bea7630..224df03ce42e 100644
--- a/drivers/xen/pci.c
+++ b/drivers/xen/pci.c
@@ -17,6 +17,8 @@
 #include "../pci/pci.h"
 #ifdef CONFIG_PCI_MMCONFIG
 #include <asm/pci_x86.h>
+
+static int xen_mcfg_late(void);
 #endif
 
 static bool __read_mostly pci_seg_supported = true;
@@ -28,7 +30,18 @@ static int xen_add_device(struct device *dev)
 #ifdef CONFIG_PCI_IOV
 	struct pci_dev *physfn = pci_dev->physfn;
 #endif
-
+#ifdef CONFIG_PCI_MMCONFIG
+	static bool pci_mcfg_reserved = false;
+	/*
+	 * Reserve MCFG areas in Xen on first invocation due to this being
+	 * potentially called from inside of acpi_init immediately after
+	 * MCFG table has been finally parsed.
+	 */
+	if (!pci_mcfg_reserved) {
+		xen_mcfg_late();
+		pci_mcfg_reserved = true;
+	}
+#endif
 	if (pci_seg_supported) {
 		struct {
 			struct physdev_pci_device_add add;
@@ -201,7 +214,7 @@ static int __init register_xen_pci_notifier(void)
 arch_initcall(register_xen_pci_notifier);
 
 #ifdef CONFIG_PCI_MMCONFIG
-static int __init xen_mcfg_late(void)
+static int xen_mcfg_late(void)
 {
 	struct pci_mmcfg_region *cfg;
 	int rc;
@@ -240,8 +253,4 @@ static int __init xen_mcfg_late(void)
 	}
 	return 0;
 }
-/*
- * Needs to be done after acpi_init which are subsys_initcall.
- */
-subsys_initcall_sync(xen_mcfg_late);
 #endif

commit 3b20eb23724d493eca79f02b1e062bd5432e29d0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:35 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 320
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation this program
      is distributed in the hope it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 59 temple place suite 330 boston ma 02111
      1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 33 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000435.254582722@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/xen/pci.c b/drivers/xen/pci.c
index 7494dbeb4409..3eeb9bea7630 100644
--- a/drivers/xen/pci.c
+++ b/drivers/xen/pci.c
@@ -1,19 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (c) 2009, Intel Corporation.
  *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
- * Place - Suite 330, Boston, MA 02111-1307 USA.
- *
  * Author: Weidong Han <weidong.han@intel.com>
  */
 

commit 0b97b03d88b40bfbd7ff0e069186a137d9786d43
Author: Ross Lagerwall <ross.lagerwall@citrix.com>
Date:   Thu Apr 9 08:05:10 2015 +0100

    xen/pci: Try harder to get PXM information for Xen
    
    If the device being added to Xen is not contained in the ACPI table,
    walk the PCI device tree to find a parent that is contained in the ACPI
    table before finding the PXM information from this device.
    
    Previously, it would try to get a handle for the device, then the
    device's bridge, then the physfn.  This changes the order so that it
    tries to get a handle for the device, then the physfn, the walks up the
    PCI device tree.
    
    Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>

diff --git a/drivers/xen/pci.c b/drivers/xen/pci.c
index 95ee4302ffb8..7494dbeb4409 100644
--- a/drivers/xen/pci.c
+++ b/drivers/xen/pci.c
@@ -19,6 +19,7 @@
 
 #include <linux/pci.h>
 #include <linux/acpi.h>
+#include <linux/pci-acpi.h>
 #include <xen/xen.h>
 #include <xen/interface/physdev.h>
 #include <xen/interface/xen.h>
@@ -67,12 +68,22 @@ static int xen_add_device(struct device *dev)
 
 #ifdef CONFIG_ACPI
 		handle = ACPI_HANDLE(&pci_dev->dev);
-		if (!handle && pci_dev->bus->bridge)
-			handle = ACPI_HANDLE(pci_dev->bus->bridge);
 #ifdef CONFIG_PCI_IOV
 		if (!handle && pci_dev->is_virtfn)
 			handle = ACPI_HANDLE(physfn->bus->bridge);
 #endif
+		if (!handle) {
+			/*
+			 * This device was not listed in the ACPI name space at
+			 * all. Try to get acpi handle of parent pci bus.
+			 */
+			struct pci_bus *pbus;
+			for (pbus = pci_dev->bus; pbus; pbus = pbus->parent) {
+				handle = acpi_pci_get_bridge_handle(pbus);
+				if (handle)
+					break;
+			}
+		}
 		if (handle) {
 			acpi_status status;
 

commit 486edb24952c930966dad125f6727017353e9361
Author: Boris Ostrovsky <boris.ostrovsky@oracle.com>
Date:   Mon Aug 4 18:17:23 2014 -0400

    xen/pci: Allocate memory for physdev_pci_device_add's optarr
    
    physdev_pci_device_add's optarr[] is a zero-sized array and therefore
    reference to add.optarr[0] is accessing memory that does not belong to
    the 'add' variable.
    
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Reviewed-by: Jan Beulich <jbeulich@suse.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>

diff --git a/drivers/xen/pci.c b/drivers/xen/pci.c
index dd9c249ea311..95ee4302ffb8 100644
--- a/drivers/xen/pci.c
+++ b/drivers/xen/pci.c
@@ -41,24 +41,29 @@ static int xen_add_device(struct device *dev)
 #endif
 
 	if (pci_seg_supported) {
-		struct physdev_pci_device_add add = {
-			.seg = pci_domain_nr(pci_dev->bus),
-			.bus = pci_dev->bus->number,
-			.devfn = pci_dev->devfn
+		struct {
+			struct physdev_pci_device_add add;
+			uint32_t pxm;
+		} add_ext = {
+			.add.seg = pci_domain_nr(pci_dev->bus),
+			.add.bus = pci_dev->bus->number,
+			.add.devfn = pci_dev->devfn
 		};
+		struct physdev_pci_device_add *add = &add_ext.add;
+
 #ifdef CONFIG_ACPI
 		acpi_handle handle;
 #endif
 
 #ifdef CONFIG_PCI_IOV
 		if (pci_dev->is_virtfn) {
-			add.flags = XEN_PCI_DEV_VIRTFN;
-			add.physfn.bus = physfn->bus->number;
-			add.physfn.devfn = physfn->devfn;
+			add->flags = XEN_PCI_DEV_VIRTFN;
+			add->physfn.bus = physfn->bus->number;
+			add->physfn.devfn = physfn->devfn;
 		} else
 #endif
 		if (pci_ari_enabled(pci_dev->bus) && PCI_SLOT(pci_dev->devfn))
-			add.flags = XEN_PCI_DEV_EXTFN;
+			add->flags = XEN_PCI_DEV_EXTFN;
 
 #ifdef CONFIG_ACPI
 		handle = ACPI_HANDLE(&pci_dev->dev);
@@ -77,8 +82,8 @@ static int xen_add_device(struct device *dev)
 				status = acpi_evaluate_integer(handle, "_PXM",
 							       NULL, &pxm);
 				if (ACPI_SUCCESS(status)) {
-					add.optarr[0] = pxm;
-					add.flags |= XEN_PCI_DEV_PXM;
+					add->optarr[0] = pxm;
+					add->flags |= XEN_PCI_DEV_PXM;
 					break;
 				}
 				status = acpi_get_parent(handle, &handle);
@@ -86,7 +91,7 @@ static int xen_add_device(struct device *dev)
 		}
 #endif /* CONFIG_ACPI */
 
-		r = HYPERVISOR_physdev_op(PHYSDEVOP_pci_device_add, &add);
+		r = HYPERVISOR_physdev_op(PHYSDEVOP_pci_device_add, add);
 		if (r != -ENOSYS)
 			return r;
 		pci_seg_supported = false;

commit b7ef4a6dd35d1b47db72fbd1a31c8fd0da7a74f3
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Tue Dec 31 20:46:27 2013 +0100

    xen/pci: Fix build on non-x86
    
    We can't include <asm/pci_x86.h> if this isn't x86, and we only need
    it if CONFIG_PCI_MMCONFIG is enabled.
    
    Fixes: 8deb3eb1461e ('xen/mcfg: Call PHYSDEVOP_pci_mmcfg_reserved for MCFG areas.')
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Reviewed-by: David Vrabel <david.vrabel@citrix.com>
    Acked-by: Ian Campbell <ian.campbell@citrix.com>

diff --git a/drivers/xen/pci.c b/drivers/xen/pci.c
index 188825122aae..dd9c249ea311 100644
--- a/drivers/xen/pci.c
+++ b/drivers/xen/pci.c
@@ -26,7 +26,9 @@
 #include <asm/xen/hypervisor.h>
 #include <asm/xen/hypercall.h>
 #include "../pci/pci.h"
+#ifdef CONFIG_PCI_MMCONFIG
 #include <asm/pci_x86.h>
+#endif
 
 static bool __read_mostly pci_seg_supported = true;
 

commit 82023bb7f75b0052f40d3e74169d191c3e4e6286
Merge: e6d69a60b77a ed6a82546d2e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 20 13:25:04 2013 -0800

    Merge tag 'pm+acpi-2-3.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more ACPI and power management updates from Rafael Wysocki:
    
     - ACPI-based device hotplug fixes for issues introduced recently and a
       fix for an older error code path bug in the ACPI PCI host bridge
       driver
    
     - Fix for recently broken OMAP cpufreq build from Viresh Kumar
    
     - Fix for a recent hibernation regression related to s2disk
    
     - Fix for a locking-related regression in the ACPI EC driver from
       Puneet Kumar
    
     - System suspend error code path fix related to runtime PM and runtime
       PM documentation update from Ulf Hansson
    
     - cpufreq's conservative governor fix from Xiaoguang Chen
    
     - New processor IDs for intel_idle and turbostat and removal of an
       obsolete Kconfig option from Len Brown
    
     - New device IDs for the ACPI LPSS (Low-Power Subsystem) driver and
       ACPI-based PCI hotplug (ACPIPHP) cleanup from Mika Westerberg
    
     - Removal of several ACPI video DMI blacklist entries that are not
       necessary any more from Aaron Lu
    
     - Rework of the ACPI companion representation in struct device and code
       cleanup related to that change from Rafael J Wysocki, Lan Tianyu and
       Jarkko Nikula
    
     - Fixes for assigning names to ACPI-enumerated I2C and SPI devices from
       Jarkko Nikula
    
    * tag 'pm+acpi-2-3.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (24 commits)
      PCI / hotplug / ACPI: Drop unused acpiphp_debug declaration
      ACPI / scan: Set flags.match_driver in acpi_bus_scan_fixed()
      ACPI / PCI root: Clear driver_data before failing enumeration
      ACPI / hotplug: Fix PCI host bridge hot removal
      ACPI / hotplug: Fix acpi_bus_get_device() return value check
      cpufreq: governor: Remove fossil comment in the cpufreq_governor_dbs()
      ACPI / video: clean up DMI table for initial black screen problem
      ACPI / EC: Ensure lock is acquired before accessing ec struct members
      PM / Hibernate: Do not crash kernel in free_basic_memory_bitmaps()
      ACPI / AC: Remove struct acpi_device pointer from struct acpi_ac
      spi: Use stable dev_name for ACPI enumerated SPI slaves
      i2c: Use stable dev_name for ACPI enumerated I2C slaves
      ACPI: Provide acpi_dev_name accessor for struct acpi_device device name
      ACPI / bind: Use (put|get)_device() on ACPI device objects too
      ACPI: Eliminate the DEVICE_ACPI_HANDLE() macro
      ACPI / driver core: Store an ACPI device pointer in struct acpi_dev_node
      cpufreq: OMAP: Fix compilation error 'r & ret undeclared'
      PM / Runtime: Fix error path for prepare
      PM / Runtime: Update documentation around probe|remove|suspend
      cpufreq: conservative: set requested_freq to policy max when it is over policy max
      ...

commit 3a83f992490f8235661b768e53bd5f14915420ac
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Nov 14 23:17:21 2013 +0100

    ACPI: Eliminate the DEVICE_ACPI_HANDLE() macro
    
    Since DEVICE_ACPI_HANDLE() is now literally identical to
    ACPI_HANDLE(), replace it with the latter everywhere and drop its
    definition from include/acpi.h.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/xen/pci.c b/drivers/xen/pci.c
index 18fff88254eb..cc86b267056f 100644
--- a/drivers/xen/pci.c
+++ b/drivers/xen/pci.c
@@ -58,12 +58,12 @@ static int xen_add_device(struct device *dev)
 			add.flags = XEN_PCI_DEV_EXTFN;
 
 #ifdef CONFIG_ACPI
-		handle = DEVICE_ACPI_HANDLE(&pci_dev->dev);
+		handle = ACPI_HANDLE(&pci_dev->dev);
 		if (!handle && pci_dev->bus->bridge)
-			handle = DEVICE_ACPI_HANDLE(pci_dev->bus->bridge);
+			handle = ACPI_HANDLE(pci_dev->bus->bridge);
 #ifdef CONFIG_PCI_IOV
 		if (!handle && pci_dev->is_virtfn)
-			handle = DEVICE_ACPI_HANDLE(physfn->bus->bridge);
+			handle = ACPI_HANDLE(physfn->bus->bridge);
 #endif
 		if (handle) {
 			acpi_status status;

commit 8deb3eb1461e4cb136c88d03ec5a6729ccf2f933
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Fri Oct 25 16:26:02 2013 -0400

    xen/mcfg: Call PHYSDEVOP_pci_mmcfg_reserved for MCFG areas.
    
    The PCI MMCONFIG area is usually reserved via the E820 so the Xen hypervisor
    is aware of these regions. But they can also be enumerated in the ACPI
    DSDT which means the hypervisor won't know of them until the initial
    domain informs it of via PHYSDEVOP_pci_mmcfg_reserved.
    
    This is what this patch does for all of the MCFG regions that the
    initial domain is aware of (E820 enumerated and ACPI).
    
    Reported-by:  Santosh Jodh <Santosh.Jodh@citrix.com>
    CC: Jan Beulich <JBeulich@suse.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    CC: David Vrabel <david.vrabel@citrix.com>
    CC: Mukesh Rathor <mukesh.rathor@oracle.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    [v1: Redid it a bit]
    [v2: Dropped the P2M 1-1 setting]
    [v3: Check for Xen in-case we are running under baremetal]
    [v4: Wrap with CONFIG_PCI_MMCONFIG]

diff --git a/drivers/xen/pci.c b/drivers/xen/pci.c
index 18fff88254eb..d15f6e80479f 100644
--- a/drivers/xen/pci.c
+++ b/drivers/xen/pci.c
@@ -26,6 +26,7 @@
 #include <asm/xen/hypervisor.h>
 #include <asm/xen/hypercall.h>
 #include "../pci/pci.h"
+#include <asm/pci_x86.h>
 
 static bool __read_mostly pci_seg_supported = true;
 
@@ -192,3 +193,49 @@ static int __init register_xen_pci_notifier(void)
 }
 
 arch_initcall(register_xen_pci_notifier);
+
+#ifdef CONFIG_PCI_MMCONFIG
+static int __init xen_mcfg_late(void)
+{
+	struct pci_mmcfg_region *cfg;
+	int rc;
+
+	if (!xen_initial_domain())
+		return 0;
+
+	if ((pci_probe & PCI_PROBE_MMCONF) == 0)
+		return 0;
+
+	if (list_empty(&pci_mmcfg_list))
+		return 0;
+
+	/* Check whether they are in the right area. */
+	list_for_each_entry(cfg, &pci_mmcfg_list, list) {
+		struct physdev_pci_mmcfg_reserved r;
+
+		r.address = cfg->address;
+		r.segment = cfg->segment;
+		r.start_bus = cfg->start_bus;
+		r.end_bus = cfg->end_bus;
+		r.flags = XEN_PCI_MMCFG_RESERVED;
+
+		rc = HYPERVISOR_physdev_op(PHYSDEVOP_pci_mmcfg_reserved, &r);
+		switch (rc) {
+		case 0:
+		case -ENOSYS:
+			continue;
+
+		default:
+			pr_warn("Failed to report MMCONFIG reservation"
+				" state for %s to hypervisor"
+				" (%d)\n",
+				cfg->name, rc);
+		}
+	}
+	return 0;
+}
+/*
+ * Needs to be done after acpi_init which are subsys_initcall.
+ */
+subsys_initcall_sync(xen_mcfg_late);
+#endif

commit 780dbcd0eedec6528d777b668019dabb36badf1a
Author: Zhang, Yang Z <yang.z.zhang@intel.com>
Date:   Tue May 22 08:40:16 2012 +0000

    xen/pci: Check for PCI bridge before using it.
    
    Some SR-IOV devices may use more than one bus number, but there is no real bridges
    because that have internal routing mechanism. So need to check whether the bridge is
    existing before using it.
    
    Signed-off-by: Yang Zhang <yang.z.zhang@Intel.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/xen/pci.c b/drivers/xen/pci.c
index b84bf0b6cc34..18fff88254eb 100644
--- a/drivers/xen/pci.c
+++ b/drivers/xen/pci.c
@@ -59,7 +59,7 @@ static int xen_add_device(struct device *dev)
 
 #ifdef CONFIG_ACPI
 		handle = DEVICE_ACPI_HANDLE(&pci_dev->dev);
-		if (!handle)
+		if (!handle && pci_dev->bus->bridge)
 			handle = DEVICE_ACPI_HANDLE(pci_dev->bus->bridge);
 #ifdef CONFIG_PCI_IOV
 		if (!handle && pci_dev->is_virtfn)

commit daedd8708fe7707ed651bb1c83162f25c48a947c
Merge: 6a6662ced415 6b71c52e7f84
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Nov 6 20:13:34 2011 -0800

    Merge branch 'stable/cleanups-3.2' of git://git.kernel.org/pub/scm/linux/kernel/git/konrad/xen
    
    * 'stable/cleanups-3.2' of git://git.kernel.org/pub/scm/linux/kernel/git/konrad/xen:
      xen: use static initializers in xen-balloon.c
      Xen: fix braces and tabs coding style issue in xenbus_probe.c
      Xen: fix braces coding style issue in xenbus_probe.h
      Xen: fix whitespaces,tabs coding style issue in drivers/xen/pci.c
      Xen: fix braces coding style issue in gntdev.c and grant-table.c
      Xen: fix whitespaces,tabs coding style issue in drivers/xen/events.c
      Xen: fix whitespaces,tabs coding style issue in drivers/xen/balloon.c
    
    Fix up trivial whitespace-conflicts in
     drivers/xen/{balloon.c,pci.c,xenbus/xenbus_probe.c}

commit 55e901fc1f03dd8437f877813c68b6014cdbeefd
Author: Jan Beulich <JBeulich@suse.com>
Date:   Thu Sep 22 09:17:57 2011 +0100

    xen/pci: support multi-segment systems
    
    Now that the hypercall interface changes are in -unstable, make the
    kernel side code not ignore the segment (aka domain) number anymore
    (which results in pretty odd behavior on such systems). Rather, if
    only the old interfaces are available, don't call them for devices on
    non-zero segments at all.
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    [v1: Edited git description]
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/xen/pci.c b/drivers/xen/pci.c
index 02c402b1ed80..66057075d6e2 100644
--- a/drivers/xen/pci.c
+++ b/drivers/xen/pci.c
@@ -18,6 +18,7 @@
  */
 
 #include <linux/pci.h>
+#include <linux/acpi.h>
 #include <xen/xen.h>
 #include <xen/interface/physdev.h>
 #include <xen/interface/xen.h>
@@ -26,26 +27,85 @@
 #include <asm/xen/hypercall.h>
 #include "../pci/pci.h"
 
+static bool __read_mostly pci_seg_supported = true;
+
 static int xen_add_device(struct device *dev)
 {
 	int r;
 	struct pci_dev *pci_dev = to_pci_dev(dev);
+#ifdef CONFIG_PCI_IOV
+	struct pci_dev *physfn = pci_dev->physfn;
+#endif
+
+	if (pci_seg_supported) {
+		struct physdev_pci_device_add add = {
+			.seg = pci_domain_nr(pci_dev->bus),
+			.bus = pci_dev->bus->number,
+			.devfn = pci_dev->devfn
+		};
+#ifdef CONFIG_ACPI
+		acpi_handle handle;
+#endif
 
 #ifdef CONFIG_PCI_IOV
-	if (pci_dev->is_virtfn) {
+		if (pci_dev->is_virtfn) {
+			add.flags = XEN_PCI_DEV_VIRTFN;
+			add.physfn.bus = physfn->bus->number;
+			add.physfn.devfn = physfn->devfn;
+		} else
+#endif
+		if (pci_ari_enabled(pci_dev->bus) && PCI_SLOT(pci_dev->devfn))
+			add.flags = XEN_PCI_DEV_EXTFN;
+
+#ifdef CONFIG_ACPI
+		handle = DEVICE_ACPI_HANDLE(&pci_dev->dev);
+		if (!handle)
+			handle = DEVICE_ACPI_HANDLE(pci_dev->bus->bridge);
+#ifdef CONFIG_PCI_IOV
+		if (!handle && pci_dev->is_virtfn)
+			handle = DEVICE_ACPI_HANDLE(physfn->bus->bridge);
+#endif
+		if (handle) {
+			acpi_status status;
+
+			do {
+				unsigned long long pxm;
+
+				status = acpi_evaluate_integer(handle, "_PXM",
+							       NULL, &pxm);
+				if (ACPI_SUCCESS(status)) {
+					add.optarr[0] = pxm;
+					add.flags |= XEN_PCI_DEV_PXM;
+					break;
+				}
+				status = acpi_get_parent(handle, &handle);
+			} while (ACPI_SUCCESS(status));
+		}
+#endif /* CONFIG_ACPI */
+
+		r = HYPERVISOR_physdev_op(PHYSDEVOP_pci_device_add, &add);
+		if (r != -ENOSYS)
+			return r;
+		pci_seg_supported = false;
+	}
+
+	if (pci_domain_nr(pci_dev->bus))
+		r = -ENOSYS;
+#ifdef CONFIG_PCI_IOV
+	else if (pci_dev->is_virtfn) {
 		struct physdev_manage_pci_ext manage_pci_ext = {
 			.bus		= pci_dev->bus->number,
 			.devfn		= pci_dev->devfn,
 			.is_virtfn 	= 1,
-			.physfn.bus	= pci_dev->physfn->bus->number,
-			.physfn.devfn	= pci_dev->physfn->devfn,
+			.physfn.bus	= physfn->bus->number,
+			.physfn.devfn	= physfn->devfn,
 		};
 
 		r = HYPERVISOR_physdev_op(PHYSDEVOP_manage_pci_add_ext,
 			&manage_pci_ext);
-	} else
+	}
 #endif
-	if (pci_ari_enabled(pci_dev->bus) && PCI_SLOT(pci_dev->devfn)) {
+	else if (pci_ari_enabled(pci_dev->bus) && PCI_SLOT(pci_dev->devfn)) {
 		struct physdev_manage_pci_ext manage_pci_ext = {
 			.bus		= pci_dev->bus->number,
 			.devfn		= pci_dev->devfn,
@@ -71,13 +131,27 @@ static int xen_remove_device(struct device *dev)
 {
 	int r;
 	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct physdev_manage_pci manage_pci;
 
-	manage_pci.bus = pci_dev->bus->number;
-	manage_pci.devfn = pci_dev->devfn;
+	if (pci_seg_supported) {
+		struct physdev_pci_device device = {
+			.seg = pci_domain_nr(pci_dev->bus),
+			.bus = pci_dev->bus->number,
+			.devfn = pci_dev->devfn
+		};
 
-	r = HYPERVISOR_physdev_op(PHYSDEVOP_manage_pci_remove,
-		&manage_pci);
+		r = HYPERVISOR_physdev_op(PHYSDEVOP_pci_device_remove,
+					  &device);
+	} else if (pci_domain_nr(pci_dev->bus))
+		r = -ENOSYS;
+	else {
+		struct physdev_manage_pci manage_pci = {
+			.bus = pci_dev->bus->number,
+			.devfn = pci_dev->devfn
+		};
+
+		r = HYPERVISOR_physdev_op(PHYSDEVOP_manage_pci_remove,
+					  &manage_pci);
+	}
 
 	return r;
 }

commit 12e13ac84ca70e6641a4750e9317aa2d2c1f6f50
Author: Jan Beulich <JBeulich@novell.com>
Date:   Wed Aug 17 09:32:32 2011 +0100

    xen/pci: make bus notifier handler return sane values
    
    Notifier functions are expected to return NOTIFY_* codes, not -E...
    ones. In particular, since the respective hypercalls failing is not
    fatal to the operation of the Dom0 kernel, it must be avoided to
    return negative values here as those would make it appear as if
    NOTIFY_STOP_MASK wa set, suppressing further notification calls to
    other interested parties (which is also why we don't want to use
    notifier_from_errno() here).
    
    While at it, also notify the user of a failed hypercall.
    
    Signed-off-by: Jan Beulich <jbeulich@novell.com>
    [v1: Added dev_err and the disable MSI/MSI-X call]
    [v2: Removed the disable MSI/MSI-X call]
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/xen/pci.c b/drivers/xen/pci.c
index cef4bafc07dc..02c402b1ed80 100644
--- a/drivers/xen/pci.c
+++ b/drivers/xen/pci.c
@@ -96,13 +96,16 @@ static int xen_pci_notifier(struct notifier_block *nb,
 		r = xen_remove_device(dev);
 		break;
 	default:
-		break;
+		return NOTIFY_DONE;
 	}
-
-	return r;
+	if (r)
+		dev_err(dev, "Failed to %s - passthrough or MSI/MSI-X might fail!\n",
+			action == BUS_NOTIFY_ADD_DEVICE ? "add" :
+			(action == BUS_NOTIFY_DEL_DEVICE ? "delete" : "?"));
+	return NOTIFY_OK;
 }
 
-struct notifier_block device_nb = {
+static struct notifier_block device_nb = {
 	.notifier_call = xen_pci_notifier,
 };
 

commit 4b0109830842fa645c7f7460dc713cedfe4473f6
Author: Ruslan Pisarev <ruslan@rpisarev.org.ua>
Date:   Tue Jul 26 14:16:38 2011 +0300

    Xen: fix whitespaces,tabs coding style issue in drivers/xen/pci.c
    
    This is a patch to the pci.c file that fixed up whitespaces, tabs warnings found by the checkpatch.pl tools.
    
    Signed-off-by: Ruslan Pisarev <ruslan@rpisarev.org.ua>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/xen/pci.c b/drivers/xen/pci.c
index cef4bafc07dc..c4448ee5595f 100644
--- a/drivers/xen/pci.c
+++ b/drivers/xen/pci.c
@@ -36,7 +36,7 @@ static int xen_add_device(struct device *dev)
 		struct physdev_manage_pci_ext manage_pci_ext = {
 			.bus		= pci_dev->bus->number,
 			.devfn		= pci_dev->devfn,
-			.is_virtfn 	= 1,
+			.is_virtfn	= 1,
 			.physfn.bus	= pci_dev->physfn->bus->number,
 			.physfn.devfn	= pci_dev->physfn->devfn,
 		};
@@ -56,7 +56,7 @@ static int xen_add_device(struct device *dev)
 			&manage_pci_ext);
 	} else {
 		struct physdev_manage_pci manage_pci = {
-			.bus 	= pci_dev->bus->number,
+			.bus	= pci_dev->bus->number,
 			.devfn	= pci_dev->devfn,
 		};
 

commit e28c31a96b1570f17731b18e8efabb7308d0c22c
Author: Weidong Han <weidong.han@intel.com>
Date:   Wed Oct 27 17:55:04 2010 +0100

    xen: register xen pci notifier
    
    Register a pci notifier to add (or remove) pci devices to Xen via
    hypercalls. Xen needs to know the pci devices present in the system to
    handle pci passthrough and even MSI remapping in the initial domain.
    
    Signed-off-by: Weidong Han <weidong.han@intel.com>
    Signed-off-by: Qing He <qing.he@intel.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>

diff --git a/drivers/xen/pci.c b/drivers/xen/pci.c
new file mode 100644
index 000000000000..cef4bafc07dc
--- /dev/null
+++ b/drivers/xen/pci.c
@@ -0,0 +1,117 @@
+/*
+ * Copyright (c) 2009, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place - Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * Author: Weidong Han <weidong.han@intel.com>
+ */
+
+#include <linux/pci.h>
+#include <xen/xen.h>
+#include <xen/interface/physdev.h>
+#include <xen/interface/xen.h>
+
+#include <asm/xen/hypervisor.h>
+#include <asm/xen/hypercall.h>
+#include "../pci/pci.h"
+
+static int xen_add_device(struct device *dev)
+{
+	int r;
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+
+#ifdef CONFIG_PCI_IOV
+	if (pci_dev->is_virtfn) {
+		struct physdev_manage_pci_ext manage_pci_ext = {
+			.bus		= pci_dev->bus->number,
+			.devfn		= pci_dev->devfn,
+			.is_virtfn 	= 1,
+			.physfn.bus	= pci_dev->physfn->bus->number,
+			.physfn.devfn	= pci_dev->physfn->devfn,
+		};
+
+		r = HYPERVISOR_physdev_op(PHYSDEVOP_manage_pci_add_ext,
+			&manage_pci_ext);
+	} else
+#endif
+	if (pci_ari_enabled(pci_dev->bus) && PCI_SLOT(pci_dev->devfn)) {
+		struct physdev_manage_pci_ext manage_pci_ext = {
+			.bus		= pci_dev->bus->number,
+			.devfn		= pci_dev->devfn,
+			.is_extfn	= 1,
+		};
+
+		r = HYPERVISOR_physdev_op(PHYSDEVOP_manage_pci_add_ext,
+			&manage_pci_ext);
+	} else {
+		struct physdev_manage_pci manage_pci = {
+			.bus 	= pci_dev->bus->number,
+			.devfn	= pci_dev->devfn,
+		};
+
+		r = HYPERVISOR_physdev_op(PHYSDEVOP_manage_pci_add,
+			&manage_pci);
+	}
+
+	return r;
+}
+
+static int xen_remove_device(struct device *dev)
+{
+	int r;
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct physdev_manage_pci manage_pci;
+
+	manage_pci.bus = pci_dev->bus->number;
+	manage_pci.devfn = pci_dev->devfn;
+
+	r = HYPERVISOR_physdev_op(PHYSDEVOP_manage_pci_remove,
+		&manage_pci);
+
+	return r;
+}
+
+static int xen_pci_notifier(struct notifier_block *nb,
+			    unsigned long action, void *data)
+{
+	struct device *dev = data;
+	int r = 0;
+
+	switch (action) {
+	case BUS_NOTIFY_ADD_DEVICE:
+		r = xen_add_device(dev);
+		break;
+	case BUS_NOTIFY_DEL_DEVICE:
+		r = xen_remove_device(dev);
+		break;
+	default:
+		break;
+	}
+
+	return r;
+}
+
+struct notifier_block device_nb = {
+	.notifier_call = xen_pci_notifier,
+};
+
+static int __init register_xen_pci_notifier(void)
+{
+	if (!xen_initial_domain())
+		return 0;
+
+	return bus_register_notifier(&pci_bus_type, &device_nb);
+}
+
+arch_initcall(register_xen_pci_notifier);
