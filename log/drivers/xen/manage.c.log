commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 5bb01a62f214..cd046684e0d1 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Handle extern requests for shutdown, reboot and sysrq
  */

commit 87dffe86d406bee8782cac2db035acb9a28620a7
Author: Vitaly Kuznetsov <vkuznets@redhat.com>
Date:   Thu Sep 6 13:26:08 2018 +0200

    xen/manage: don't complain about an empty value in control/sysrq node
    
    When guest receives a sysrq request from the host it acknowledges it by
    writing '\0' to control/sysrq xenstore node. This, however, make xenstore
    watch fire again but xenbus_scanf() fails to parse empty value with "%c"
    format string:
    
     sysrq: SysRq : Emergency Sync
     Emergency Sync complete
     xen:manage: Error -34 reading sysrq code in control/sysrq
    
    Ignore -ERANGE the same way we already ignore -ENOENT, empty value in
    control/sysrq is totally legal.
    
    Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
    Reviewed-by: Wei Liu <wei.liu2@citrix.com>
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index c93d8ef8df34..5bb01a62f214 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -280,9 +280,11 @@ static void sysrq_handler(struct xenbus_watch *watch, const char *path,
 		/*
 		 * The Xenstore watch fires directly after registering it and
 		 * after a suspend/resume cycle. So ENOENT is no error but
-		 * might happen in those cases.
+		 * might happen in those cases. ERANGE is observed when we get
+		 * an empty value (''), this happens when we acknowledge the
+		 * request by writing '\0' below.
 		 */
-		if (err != -ENOENT)
+		if (err != -ENOENT && err != -ERANGE)
 			pr_err("Error %d reading sysrq code in control/sysrq\n",
 			       err);
 		xenbus_transaction_end(xbt, 1);

commit 84c029a73327cef571eaa61c7d6e67e8031b52ec
Author: Zhouyang Jia <jiazhouyang09@gmail.com>
Date:   Fri Jun 15 07:34:52 2018 +0800

    xen: add error handling for xenbus_printf
    
    When xenbus_printf fails, the lack of error-handling code may
    cause unexpected results.
    
    This patch adds error-handling code after calling xenbus_printf.
    
    Signed-off-by: Zhouyang Jia <jiazhouyang09@gmail.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Juergen Gross <jgross@suse.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 8835065029d3..c93d8ef8df34 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -289,8 +289,15 @@ static void sysrq_handler(struct xenbus_watch *watch, const char *path,
 		return;
 	}
 
-	if (sysrq_key != '\0')
-		xenbus_printf(xbt, "control", "sysrq", "%c", '\0');
+	if (sysrq_key != '\0') {
+		err = xenbus_printf(xbt, "control", "sysrq", "%c", '\0');
+		if (err) {
+			pr_err("%s: Error %d writing sysrq in control/sysrq\n",
+			       __func__, err);
+			xenbus_transaction_end(xbt, 1);
+			return;
+		}
+	}
 
 	err = xenbus_transaction_end(xbt, 0);
 	if (err == -EAGAIN)
@@ -342,7 +349,12 @@ static int setup_shutdown_watcher(void)
 			continue;
 		snprintf(node, FEATURE_PATH_SIZE, "feature-%s",
 			 shutdown_handlers[idx].command);
-		xenbus_printf(XBT_NIL, "control", node, "%u", 1);
+		err = xenbus_printf(XBT_NIL, "control", node, "%u", 1);
+		if (err) {
+			pr_err("%s: Error %d writing %s\n", __func__,
+				err, node);
+			return err;
+		}
 	}
 
 	return 0;

commit 5e25f5db6abb96ca8ee2aaedcb863daa6dfcc07a
Author: Dongli Zhang <dongli.zhang@oracle.com>
Date:   Wed Nov 1 09:46:33 2017 +0800

    xen/time: do not decrease steal time after live migration on xen
    
    After guest live migration on xen, steal time in /proc/stat
    (cpustat[CPUTIME_STEAL]) might decrease because steal returned by
    xen_steal_lock() might be less than this_rq()->prev_steal_time which is
    derived from previous return value of xen_steal_clock().
    
    For instance, steal time of each vcpu is 335 before live migration.
    
    cpu  198 0 368 200064 1962 0 0 1340 0 0
    cpu0 38 0 81 50063 492 0 0 335 0 0
    cpu1 65 0 97 49763 634 0 0 335 0 0
    cpu2 38 0 81 50098 462 0 0 335 0 0
    cpu3 56 0 107 50138 374 0 0 335 0 0
    
    After live migration, steal time is reduced to 312.
    
    cpu  200 0 370 200330 1971 0 0 1248 0 0
    cpu0 38 0 82 50123 500 0 0 312 0 0
    cpu1 65 0 97 49832 634 0 0 312 0 0
    cpu2 39 0 82 50167 462 0 0 312 0 0
    cpu3 56 0 107 50207 374 0 0 312 0 0
    
    Since runstate times are cumulative and cleared during xen live migration
    by xen hypervisor, the idea of this patch is to accumulate runstate times
    to global percpu variables before live migration suspend. Once guest VM is
    resumed, xen_get_runstate_snapshot_cpu() would always return the sum of new
    runstate times and previously accumulated times stored in global percpu
    variables.
    
    Comment above HYPERVISOR_suspend() has been removed as it is inaccurate:
    the call can return an error code (e.g., possibly -EPERM in the future).
    
    Similar and more severe issue would impact prior linux 4.8-4.10 as
    discussed by Michael Las at
    https://0xstubs.org/debugging-a-flaky-cpu-steal-time-counter-on-a-paravirtualized-xen-guest,
    which would overflow steal time and lead to 100% st usage in top command
    for linux 4.8-4.10. A backport of this patch would fix that issue.
    
    [boris: added linux/slab.h to driver/xen/time.c, slightly reformatted
            commit message]
    
    References: https://0xstubs.org/debugging-a-flaky-cpu-steal-time-counter-on-a-paravirtualized-xen-guest
    Signed-off-by: Dongli Zhang <dongli.zhang@oracle.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index c425d03d37d2..8835065029d3 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -72,18 +72,15 @@ static int xen_suspend(void *data)
 	}
 
 	gnttab_suspend();
+	xen_manage_runstate_time(-1);
 	xen_arch_pre_suspend();
 
-	/*
-	 * This hypercall returns 1 if suspend was cancelled
-	 * or the domain was merely checkpointed, and 0 if it
-	 * is resuming in a new domain.
-	 */
 	si->cancelled = HYPERVISOR_suspend(xen_pv_domain()
                                            ? virt_to_gfn(xen_start_info)
                                            : 0);
 
 	xen_arch_post_suspend(si->cancelled);
+	xen_manage_runstate_time(si->cancelled ? 1 : 0);
 	gnttab_resume();
 
 	if (!si->cancelled) {

commit 6e6c5b960644125b6f2fc2cd04e62bff0771923e
Merge: c136b84393d4 c54590cac51d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 6 19:11:24 2017 -0700

    Merge tag 'for-linus-4.13-rc1-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/xen/tip
    
    Pull xen updates from Juergen Gross:
     "Other than fixes and cleanups it contains:
    
       - support > 32 VCPUs at domain restore
    
       - support for new sysfs nodes related to Xen
    
       - some performance tuning for Linux running as Xen guest"
    
    * tag 'for-linus-4.13-rc1-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/xen/tip:
      x86/xen: allow userspace access during hypercalls
      x86: xen: remove unnecessary variable in xen_foreach_remap_area()
      xen: allocate page for shared info page from low memory
      xen: avoid deadlock in xenbus driver
      xen: add sysfs node for hypervisor build id
      xen: sync include/xen/interface/version.h
      xen: add sysfs node for guest type
      doc,xen: document hypervisor sysfs nodes for xen
      xen/vcpu: Handle xen_vcpu_setup() failure at boot
      xen/vcpu: Handle xen_vcpu_setup() failure in hotplug
      xen/pv: Fix OOPS on restore for a PV, !SMP domain
      xen/pvh*: Support > 32 VCPUs at domain restore
      xen/vcpu: Simplify xen_vcpu related code
      xen-evtchn: Bind dyn evtchn:qemu-dm interrupt to next online VCPU
      xen: avoid type warning in xchg_xen_ulong
      xen: fix HYPERVISOR_dm_op() prototype
      xen: don't print error message in case of missing Xenstore entry
      arm/xen: Adjust one function call together with a variable assignment
      arm/xen: Delete an error message for a failed memory allocation in __set_phys_to_machine_multi()
      arm/xen: Improve a size determination in __set_phys_to_machine_multi()

commit 4e93b6481c87ea5afde944a32b4908357ec58992
Author: Juergen Gross <jgross@suse.com>
Date:   Tue May 30 20:52:26 2017 +0200

    xen: don't print error message in case of missing Xenstore entry
    
    When registering for the Xenstore watch of the node control/sysrq the
    handler will be called at once. Don't issue an error message if the
    Xenstore node isn't there, as it will be created only when an event
    is being triggered.
    
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Juergen Gross <jgross@suse.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index c1ec8ee80924..60cf71f1b256 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -277,8 +277,16 @@ static void sysrq_handler(struct xenbus_watch *watch, const char *path,
 	err = xenbus_transaction_start(&xbt);
 	if (err)
 		return;
-	if (xenbus_scanf(xbt, "control", "sysrq", "%c", &sysrq_key) < 0) {
-		pr_err("Unable to read sysrq code in control/sysrq\n");
+	err = xenbus_scanf(xbt, "control", "sysrq", "%c", &sysrq_key);
+	if (err < 0) {
+		/*
+		 * The Xenstore watch fires directly after registering it and
+		 * after a suspend/resume cycle. So ENOENT is no error but
+		 * might happen in those cases.
+		 */
+		if (err != -ENOENT)
+			pr_err("Error %d reading sysrq code in control/sysrq\n",
+			       err);
 		xenbus_transaction_end(xbt, 1);
 		return;
 	}

commit 69a78ff226fe0241ab6cb9dd961667be477e3cf7
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 16 20:42:47 2017 +0200

    init: Introduce SYSTEM_SCHEDULING state
    
    might_sleep() debugging and smp_processor_id() debugging should be active
    right after the scheduler starts working. The init task can invoke
    smp_processor_id() from preemptible context as it is pinned on the boot cpu
    until sched_smp_init() removes the pinning and lets it schedule on all non
    isolated cpus.
    
    Add a new state which allows to enable those checks earlier and add it to
    the xen do_poweroff() function.
    
    No functional change.
    
    Tested-by: Mark Rutland <mark.rutland@arm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Acked-by: Mark Rutland <mark.rutland@arm.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Link: http://lkml.kernel.org/r/20170516184736.196214622@linutronix.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index c1ec8ee80924..9e35032351a0 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -190,6 +190,7 @@ static void do_poweroff(void)
 {
 	switch (system_state) {
 	case SYSTEM_BOOTING:
+	case SYSTEM_SCHEDULING:
 		orderly_poweroff(true);
 		break;
 	case SYSTEM_RUNNING:

commit 5584ea250ae44f929feb4c7bd3877d1c5edbf813
Author: Juergen Gross <jgross@suse.com>
Date:   Thu Feb 9 14:39:57 2017 +0100

    xen: modify xenstore watch event interface
    
    Today a Xenstore watch event is delivered via a callback function
    declared as:
    
    void (*callback)(struct xenbus_watch *,
                     const char **vec, unsigned int len);
    
    As all watch events only ever come with two parameters (path and token)
    changing the prototype to:
    
    void (*callback)(struct xenbus_watch *,
                     const char *path, const char *token);
    
    is the natural thing to do.
    
    Apply this change and adapt all users.
    
    Cc: konrad.wilk@oracle.com
    Cc: roger.pau@citrix.com
    Cc: wei.liu2@citrix.com
    Cc: paul.durrant@citrix.com
    Cc: netdev@vger.kernel.org
    
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Reviewed-by: Paul Durrant <paul.durrant@citrix.com>
    Reviewed-by: Wei Liu <wei.liu2@citrix.com>
    Reviewed-by: Roger Pau Monné <roger.pau@citrix.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 357a8db859c9..c1ec8ee80924 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -218,7 +218,7 @@ static struct shutdown_handler shutdown_handlers[] = {
 };
 
 static void shutdown_handler(struct xenbus_watch *watch,
-			     const char **vec, unsigned int len)
+			     const char *path, const char *token)
 {
 	char *str;
 	struct xenbus_transaction xbt;
@@ -266,8 +266,8 @@ static void shutdown_handler(struct xenbus_watch *watch,
 }
 
 #ifdef CONFIG_MAGIC_SYSRQ
-static void sysrq_handler(struct xenbus_watch *watch, const char **vec,
-			  unsigned int len)
+static void sysrq_handler(struct xenbus_watch *watch, const char *path,
+			  const char *token)
 {
 	char sysrq_key = '\0';
 	struct xenbus_transaction xbt;

commit 4fed1b125eb6252bde478665fc05d4819f774fa8
Author: Jan Beulich <JBeulich@suse.com>
Date:   Fri Feb 3 01:54:05 2017 -0700

    xen/manage: correct return value check on xenbus_scanf()
    
    A negative return value indicates an error; in fact the function at
    present won't ever return zero.
    
    Signed-off-by: Jan Beulich <jbeulich@suse.com>
    Reviewed-by: Juergen Gross <jgross@suse.com>
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 26e5e8507f03..357a8db859c9 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -277,7 +277,7 @@ static void sysrq_handler(struct xenbus_watch *watch, const char **vec,
 	err = xenbus_transaction_start(&xbt);
 	if (err)
 		return;
-	if (!xenbus_scanf(xbt, "control", "sysrq", "%c", &sysrq_key)) {
+	if (xenbus_scanf(xbt, "control", "sysrq", "%c", &sysrq_key) < 0) {
 		pr_err("Unable to read sysrq code in control/sysrq\n");
 		xenbus_transaction_end(xbt, 1);
 		return;

commit 44b3c7af02ca2701b6b90ee30c9d1d9c3ae07653
Author: Juergen Gross <jgross@suse.com>
Date:   Tue Oct 11 13:34:16 2016 +0200

    xenbus: advertise control feature flags
    
    The Xen docs specify several flags which a guest can set to advertise
    which values of the xenstore control/shutdown key it will recognize.
    This patch adds code to write all the relevant feature-flag keys.
    
    Based-on-patch-by: Paul Durrant <paul.durrant@citrix.com>
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Reviewed-by: David Vrabel <david.vrabel@citrix.com>
    Reviewed-by: Paul Durrant <paul.durrant@citrix.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index e12bd3635f83..26e5e8507f03 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -168,7 +168,9 @@ static void do_suspend(void)
 #endif	/* CONFIG_HIBERNATE_CALLBACKS */
 
 struct shutdown_handler {
-	const char *command;
+#define SHUTDOWN_CMD_SIZE 11
+	const char command[SHUTDOWN_CMD_SIZE];
+	bool flag;
 	void (*cb)(void);
 };
 
@@ -206,22 +208,22 @@ static void do_reboot(void)
 	ctrl_alt_del();
 }
 
+static struct shutdown_handler shutdown_handlers[] = {
+	{ "poweroff",	true,	do_poweroff },
+	{ "halt",	false,	do_poweroff },
+	{ "reboot",	true,	do_reboot   },
+#ifdef CONFIG_HIBERNATE_CALLBACKS
+	{ "suspend",	true,	do_suspend  },
+#endif
+};
+
 static void shutdown_handler(struct xenbus_watch *watch,
 			     const char **vec, unsigned int len)
 {
 	char *str;
 	struct xenbus_transaction xbt;
 	int err;
-	static struct shutdown_handler handlers[] = {
-		{ "poweroff",	do_poweroff },
-		{ "halt",	do_poweroff },
-		{ "reboot",	do_reboot   },
-#ifdef CONFIG_HIBERNATE_CALLBACKS
-		{ "suspend",	do_suspend  },
-#endif
-		{NULL, NULL},
-	};
-	static struct shutdown_handler *handler;
+	int idx;
 
 	if (shutting_down != SHUTDOWN_INVALID)
 		return;
@@ -238,13 +240,13 @@ static void shutdown_handler(struct xenbus_watch *watch,
 		return;
 	}
 
-	for (handler = &handlers[0]; handler->command; handler++) {
-		if (strcmp(str, handler->command) == 0)
+	for (idx = 0; idx < ARRAY_SIZE(shutdown_handlers); idx++) {
+		if (strcmp(str, shutdown_handlers[idx].command) == 0)
 			break;
 	}
 
 	/* Only acknowledge commands which we are prepared to handle. */
-	if (handler->cb)
+	if (idx < ARRAY_SIZE(shutdown_handlers))
 		xenbus_write(xbt, "control", "shutdown", "");
 
 	err = xenbus_transaction_end(xbt, 0);
@@ -253,8 +255,8 @@ static void shutdown_handler(struct xenbus_watch *watch,
 		goto again;
 	}
 
-	if (handler->cb) {
-		handler->cb();
+	if (idx < ARRAY_SIZE(shutdown_handlers)) {
+		shutdown_handlers[idx].cb();
 	} else {
 		pr_info("Ignoring shutdown request: %s\n", str);
 		shutting_down = SHUTDOWN_INVALID;
@@ -310,6 +312,9 @@ static struct notifier_block xen_reboot_nb = {
 static int setup_shutdown_watcher(void)
 {
 	int err;
+	int idx;
+#define FEATURE_PATH_SIZE (SHUTDOWN_CMD_SIZE + sizeof("feature-"))
+	char node[FEATURE_PATH_SIZE];
 
 	err = register_xenbus_watch(&shutdown_watch);
 	if (err) {
@@ -326,6 +331,14 @@ static int setup_shutdown_watcher(void)
 	}
 #endif
 
+	for (idx = 0; idx < ARRAY_SIZE(shutdown_handlers); idx++) {
+		if (!shutdown_handlers[idx].flag)
+			continue;
+		snprintf(node, FEATURE_PATH_SIZE, "feature-%s",
+			 shutdown_handlers[idx].command);
+		xenbus_printf(XBT_NIL, "control", node, "%u", 1);
+	}
+
 	return 0;
 }
 

commit 0df4f266b3af90442bbeb5e685a84a80745beba0
Author: Julien Grall <julien.grall@citrix.com>
Date:   Fri Aug 7 17:34:37 2015 +0100

    xen: Use correctly the Xen memory terminologies
    
    Based on include/xen/mm.h [1], Linux is mistakenly using MFN when GFN
    is meant, I suspect this is because the first support for Xen was for
    PV. This resulted in some misimplementation of helpers on ARM and
    confused developers about the expected behavior.
    
    For instance, with pfn_to_mfn, we expect to get an MFN based on the name.
    Although, if we look at the implementation on x86, it's returning a GFN.
    
    For clarity and avoid new confusion, replace any reference to mfn with
    gfn in any helpers used by PV drivers. The x86 code will still keep some
    reference of pfn_to_mfn which may be used by all kind of guests
    No changes as been made in the hypercall field, even
    though they may be invalid, in order to keep the same as the defintion
    in xen repo.
    
    Note that page_to_mfn has been renamed to xen_page_to_gfn to avoid a
    name to close to the KVM function gfn_to_page.
    
    Take also the opportunity to simplify simple construction such
    as pfn_to_mfn(page_to_pfn(page)) into xen_page_to_gfn. More complex clean up
    will come in follow-up patches.
    
    [1] http://xenbits.xen.org/gitweb/?p=xen.git;a=commitdiff;h=e758ed14f390342513405dd766e874934573e6cb
    
    Signed-off-by: Julien Grall <julien.grall@citrix.com>
    Reviewed-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Wei Liu <wei.liu2@citrix.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index d10effee9b9e..e12bd3635f83 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -80,7 +80,7 @@ static int xen_suspend(void *data)
 	 * is resuming in a new domain.
 	 */
 	si->cancelled = HYPERVISOR_suspend(xen_pv_domain()
-                                           ? virt_to_mfn(xen_start_info)
+                                           ? virt_to_gfn(xen_start_info)
                                            : 0);
 
 	xen_arch_post_suspend(si->cancelled);

commit a9fd60e2683fb80f5b26a7d686aebe3327a63e70
Author: Julien Grall <julien.grall@citrix.com>
Date:   Wed Jun 17 15:28:02 2015 +0100

    xen: Include xen/page.h rather than asm/xen/page.h
    
    Using xen/page.h will be necessary later for using common xen page
    helpers.
    
    As xen/page.h already include asm/xen/page.h, always use the later.
    
    Signed-off-by: Julien Grall <julien.grall@citrix.com>
    Reviewed-by: David Vrabel <david.vrabel@citrix.com>
    Cc: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Cc: Ian Campbell <ian.campbell@citrix.com>
    Cc: Wei Liu <wei.liu2@citrix.com>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: netdev@vger.kernel.org
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 9e6a85104a20..d10effee9b9e 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -19,10 +19,10 @@
 #include <xen/grant_table.h>
 #include <xen/events.h>
 #include <xen/hvc-console.h>
+#include <xen/page.h>
 #include <xen/xen-ops.h>
 
 #include <asm/xen/hypercall.h>
-#include <asm/xen/page.h>
 #include <asm/xen/hypervisor.h>
 
 enum shutdown_state {

commit 2b953a5e994ce279904ec70220f7d4f31d380a0a
Author: Boris Ostrovsky <boris.ostrovsky@oracle.com>
Date:   Tue Apr 28 18:46:20 2015 -0400

    xen: Suspend ticks on all CPUs during suspend
    
    Commit 77e32c89a711 ("clockevents: Manage device's state separately for
    the core") decouples clockevent device's modes from states. With this
    change when a Xen guest tries to resume, it won't be calling its
    set_mode op which needs to be done on each VCPU in order to make the
    hypervisor aware that we are in oneshot mode.
    
    This happens because clockevents_tick_resume() (which is an intermediate
    step of resuming ticks on a processor) doesn't call clockevents_set_state()
    anymore and because during suspend clockevent devices on all VCPUs (except
    for the one doing the suspend) are left in ONESHOT state. As result, during
    resume the clockevents state machine will assume that device is already
    where it should be and doesn't need to be updated.
    
    To avoid this problem we should suspend ticks on all VCPUs during
    suspend.
    
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index bf1940706422..9e6a85104a20 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -131,6 +131,8 @@ static void do_suspend(void)
 		goto out_resume;
 	}
 
+	xen_arch_suspend();
+
 	si.cancelled = 1;
 
 	err = stop_machine(xen_suspend, &si, cpumask_of(0));
@@ -148,11 +150,12 @@ static void do_suspend(void)
 		si.cancelled = 1;
 	}
 
+	xen_arch_resume();
+
 out_resume:
-	if (!si.cancelled) {
-		xen_arch_resume();
+	if (!si.cancelled)
 		xs_resume();
-	} else
+	else
 		xs_suspend_cancel();
 
 	dpm_resume_end(si.cancelled ? PMSG_THAW : PMSG_RESTORE);

commit 72978b2fe2f2cdf9f319c6c6dcdbe92b38de2be2
Author: Ross Lagerwall <ross.lagerwall@citrix.com>
Date:   Mon Jan 19 13:19:38 2015 +0000

    xen/manage: Fix USB interaction issues when resuming
    
    Commit 61a734d305e1 ("xen/manage: Always freeze/thaw processes when
    suspend/resuming") ensured that userspace processes were always frozen
    before suspending to reduce interaction issues when resuming devices.
    However, freeze_processes() does not freeze kernel threads.  Freeze
    kernel threads as well to prevent deadlocks with the khubd thread when
    resuming devices.
    
    This is what native suspend and resume does.
    
    Example deadlock:
    [ 7279.648010]  [<ffffffff81446bde>] ? xen_poll_irq_timeout+0x3e/0x50
    [ 7279.648010]  [<ffffffff81448d60>] xen_poll_irq+0x10/0x20
    [ 7279.648010]  [<ffffffff81011723>] xen_lock_spinning+0xb3/0x120
    [ 7279.648010]  [<ffffffff810115d1>] __raw_callee_save_xen_lock_spinning+0x11/0x20
    [ 7279.648010]  [<ffffffff815620b6>] ? usb_control_msg+0xe6/0x120
    [ 7279.648010]  [<ffffffff81747e50>] ? _raw_spin_lock_irq+0x50/0x60
    [ 7279.648010]  [<ffffffff8174522c>] wait_for_completion+0xac/0x160
    [ 7279.648010]  [<ffffffff8109c520>] ? try_to_wake_up+0x2c0/0x2c0
    [ 7279.648010]  [<ffffffff814b60f2>] dpm_wait+0x32/0x40
    [ 7279.648010]  [<ffffffff814b6eb0>] device_resume+0x90/0x210
    [ 7279.648010]  [<ffffffff814b7d71>] dpm_resume+0x121/0x250
    [ 7279.648010]  [<ffffffff8144c570>] ? xenbus_dev_request_and_reply+0xc0/0xc0
    [ 7279.648010]  [<ffffffff814b80d5>] dpm_resume_end+0x15/0x30
    [ 7279.648010]  [<ffffffff81449fba>] do_suspend+0x10a/0x200
    [ 7279.648010]  [<ffffffff8144a2f0>] ? xen_pre_suspend+0x20/0x20
    [ 7279.648010]  [<ffffffff8144a1d0>] shutdown_handler+0x120/0x150
    [ 7279.648010]  [<ffffffff8144c60f>] xenwatch_thread+0x9f/0x160
    [ 7279.648010]  [<ffffffff810ac510>] ? finish_wait+0x80/0x80
    [ 7279.648010]  [<ffffffff8108d189>] kthread+0xc9/0xe0
    [ 7279.648010]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    [ 7279.648010]  [<ffffffff8175087c>] ret_from_fork+0x7c/0xb0
    [ 7279.648010]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    
    [ 7441.216287] INFO: task khubd:89 blocked for more than 120 seconds.
    [ 7441.219457]       Tainted: G            X 3.13.11-ckt12.kz #1
    [ 7441.222176] "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    [ 7441.225827] khubd           D ffff88003f433440     0    89      2 0x00000000
    [ 7441.229258]  ffff88003ceb9b98 0000000000000046 ffff88003ce83000 0000000000013440
    [ 7441.232959]  ffff88003ceb9fd8 0000000000013440 ffff88003cd13000 ffff88003ce83000
    [ 7441.236658]  0000000000000286 ffff88003d3e0000 ffff88003ceb9bd0 00000001001aa01e
    [ 7441.240415] Call Trace:
    [ 7441.241614]  [<ffffffff817442f9>] schedule+0x29/0x70
    [ 7441.243930]  [<ffffffff81743406>] schedule_timeout+0x166/0x2c0
    [ 7441.246681]  [<ffffffff81075b80>] ? call_timer_fn+0x110/0x110
    [ 7441.249339]  [<ffffffff8174357e>] schedule_timeout_uninterruptible+0x1e/0x20
    [ 7441.252644]  [<ffffffff81077710>] msleep+0x20/0x30
    [ 7441.254812]  [<ffffffff81555f00>] hub_port_reset+0xf0/0x580
    [ 7441.257400]  [<ffffffff81558465>] hub_port_init+0x75/0xb40
    [ 7441.259981]  [<ffffffff814bb3c9>] ? update_autosuspend+0x39/0x60
    [ 7441.262817]  [<ffffffff814bb4f0>] ? pm_runtime_set_autosuspend_delay+0x50/0xa0
    [ 7441.266212]  [<ffffffff8155a64a>] hub_thread+0x71a/0x1750
    [ 7441.268728]  [<ffffffff810ac510>] ? finish_wait+0x80/0x80
    [ 7441.271272]  [<ffffffff81559f30>] ? usb_port_resume+0x670/0x670
    [ 7441.274067]  [<ffffffff8108d189>] kthread+0xc9/0xe0
    [ 7441.276305]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    [ 7441.279131]  [<ffffffff8175087c>] ret_from_fork+0x7c/0xb0
    [ 7441.281659]  [<ffffffff8108d0c0>] ? flush_kthread_worker+0x80/0x80
    
    Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index f8bb36f9d9ce..bf1940706422 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -105,10 +105,16 @@ static void do_suspend(void)
 
 	err = freeze_processes();
 	if (err) {
-		pr_err("%s: freeze failed %d\n", __func__, err);
+		pr_err("%s: freeze processes failed %d\n", __func__, err);
 		goto out;
 	}
 
+	err = freeze_kernel_threads();
+	if (err) {
+		pr_err("%s: freeze kernel threads failed %d\n", __func__, err);
+		goto out_thaw;
+	}
+
 	err = dpm_suspend_start(PMSG_FREEZE);
 	if (err) {
 		pr_err("%s: dpm_suspend_start %d\n", __func__, err);

commit 61a734d305e16944b42730ef582a7171dc733321
Author: Ross Lagerwall <ross.lagerwall@citrix.com>
Date:   Mon Aug 18 10:41:36 2014 +0100

    xen/manage: Always freeze/thaw processes when suspend/resuming
    
    Always freeze processes when suspending and thaw processes when resuming
    to prevent a race noticeable with HVM guests.
    
    This prevents a deadlock where the khubd kthread (which is designed to
    be freezable) acquires a usb device lock and then tries to allocate
    memory which requires the disk which hasn't been resumed yet.
    Meanwhile, the xenwatch thread deadlocks waiting for the usb device
    lock.
    
    Freezing processes fixes this because the khubd thread is only thawed
    after the xenwatch thread finishes resuming all the devices.
    
    Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 5f1e1f3cd186..f8bb36f9d9ce 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -103,16 +103,11 @@ static void do_suspend(void)
 
 	shutting_down = SHUTDOWN_SUSPEND;
 
-#ifdef CONFIG_PREEMPT
-	/* If the kernel is preemptible, we need to freeze all the processes
-	   to prevent them from being in the middle of a pagetable update
-	   during suspend. */
 	err = freeze_processes();
 	if (err) {
 		pr_err("%s: freeze failed %d\n", __func__, err);
 		goto out;
 	}
-#endif
 
 	err = dpm_suspend_start(PMSG_FREEZE);
 	if (err) {
@@ -157,10 +152,8 @@ static void do_suspend(void)
 	dpm_resume_end(si.cancelled ? PMSG_THAW : PMSG_RESTORE);
 
 out_thaw:
-#ifdef CONFIG_PREEMPT
 	thaw_processes();
 out:
-#endif
 	shutting_down = SHUTDOWN_INVALID;
 }
 #endif	/* CONFIG_HIBERNATE_CALLBACKS */

commit 1b6478231c6f5f844185acb32045cf195028cfce
Author: David Vrabel <david.vrabel@citrix.com>
Date:   Wed Jul 2 17:25:23 2014 +0100

    xen/manage: fix potential deadlock when resuming the console
    
    Calling xen_console_resume() in xen_suspend() causes a warning because
    it locks irq_mapping_update_lock (a mutex) and this may sleep.  If a
    userspace process is using the evtchn device then this mutex may be
    locked at the point of the stop_machine() call and
    xen_console_resume() would then deadlock.
    
    Resuming the console after stop_machine() returns avoids this
    deadlock.
    
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: <stable@vger.kernel.org>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index c3667b202f2f..5f1e1f3cd186 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -88,7 +88,6 @@ static int xen_suspend(void *data)
 
 	if (!si->cancelled) {
 		xen_irq_resume();
-		xen_console_resume();
 		xen_timer_resume();
 	}
 
@@ -135,6 +134,10 @@ static void do_suspend(void)
 
 	err = stop_machine(xen_suspend, &si, cpumask_of(0));
 
+	/* Resume console as early as possible. */
+	if (!si.cancelled)
+		xen_console_resume();
+
 	raw_notifier_call_chain(&xen_resume_notifier, 0, NULL);
 
 	dpm_resume_start(si.cancelled ? PMSG_THAW : PMSG_RESTORE);

commit aa8532c32216ae07c3813b9aeb774517878a7573
Author: David Vrabel <david.vrabel@citrix.com>
Date:   Thu May 8 11:09:23 2014 +0100

    xen: refactor suspend pre/post hooks
    
    New architectures currently have to provide implementations of 5 different
    functions: xen_arch_pre_suspend(), xen_arch_post_suspend(),
    xen_arch_hvm_post_suspend(), xen_mm_pin_all(), and xen_mm_unpin_all().
    
    Refactor the suspend code to only require xen_arch_pre_suspend() and
    xen_arch_post_suspend().
    
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 32f9236c959f..c3667b202f2f 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -41,9 +41,6 @@ static enum shutdown_state shutting_down = SHUTDOWN_INVALID;
 
 struct suspend_info {
 	int cancelled;
-	unsigned long arg; /* extra hypercall argument */
-	void (*pre)(void);
-	void (*post)(int cancelled);
 };
 
 static RAW_NOTIFIER_HEAD(xen_resume_notifier);
@@ -61,26 +58,6 @@ void xen_resume_notifier_unregister(struct notifier_block *nb)
 EXPORT_SYMBOL_GPL(xen_resume_notifier_unregister);
 
 #ifdef CONFIG_HIBERNATE_CALLBACKS
-static void xen_hvm_post_suspend(int cancelled)
-{
-	xen_arch_hvm_post_suspend(cancelled);
-	gnttab_resume();
-}
-
-static void xen_pre_suspend(void)
-{
-	xen_mm_pin_all();
-	gnttab_suspend();
-	xen_arch_pre_suspend();
-}
-
-static void xen_post_suspend(int cancelled)
-{
-	xen_arch_post_suspend(cancelled);
-	gnttab_resume();
-	xen_mm_unpin_all();
-}
-
 static int xen_suspend(void *data)
 {
 	struct suspend_info *si = data;
@@ -94,18 +71,20 @@ static int xen_suspend(void *data)
 		return err;
 	}
 
-	if (si->pre)
-		si->pre();
+	gnttab_suspend();
+	xen_arch_pre_suspend();
 
 	/*
 	 * This hypercall returns 1 if suspend was cancelled
 	 * or the domain was merely checkpointed, and 0 if it
 	 * is resuming in a new domain.
 	 */
-	si->cancelled = HYPERVISOR_suspend(si->arg);
+	si->cancelled = HYPERVISOR_suspend(xen_pv_domain()
+                                           ? virt_to_mfn(xen_start_info)
+                                           : 0);
 
-	if (si->post)
-		si->post(si->cancelled);
+	xen_arch_post_suspend(si->cancelled);
+	gnttab_resume();
 
 	if (!si->cancelled) {
 		xen_irq_resume();
@@ -154,16 +133,6 @@ static void do_suspend(void)
 
 	si.cancelled = 1;
 
-	if (xen_hvm_domain()) {
-		si.arg = 0UL;
-		si.pre = NULL;
-		si.post = &xen_hvm_post_suspend;
-	} else {
-		si.arg = virt_to_mfn(xen_start_info);
-		si.pre = &xen_pre_suspend;
-		si.post = &xen_post_suspend;
-	}
-
 	err = stop_machine(xen_suspend, &si, cpumask_of(0));
 
 	raw_notifier_call_chain(&xen_resume_notifier, 0, NULL);

commit eb47f71200b7d5b4c8c1f8c75675f592d855aafd
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Fri Apr 4 14:53:41 2014 -0400

    xen/manage: Poweroff forcefully if user-space is not yet up.
    
    The user can launch the guest in this sequence:
    
    xl create -p /vm.cfg    [launch, but pause it]
    xl shutdown latest      [sets control/shutdown=poweroff]
    xl unpause latest
    xl console latest       [and see that the guest has completely
    ignored the shutdown request]
    
    In reality the guest hasn't ignored it. It registers a watch
    and gets a notification that there is value. It then calls
    the shutdown_handler which ends up calling orderly_shutdown.
    
    Unfortunately that is so early in the bootup that there
    are no user-space. Which means that the orderly_shutdown fails.
    But since the force flag was set to false it continues on without
    reporting.
    
    What we really want to is to use the force when we are in the
    SYSTEM_BOOTING state and not use the 'force' when SYSTEM_RUNNING.
    
    However, if we are in the running state - and the shutdown command
    has been given before the user-space has been setup, there is nothing
    we can do. Worst yet, we stop ignoring the 'xl shutdown' requests!
    
    As such, the other part of this patch is to only stop ignoring
    the 'xl shutdown' when we are truly in the power off sequence.
    
    That means the user can do multiple 'xl shutdown' and we will try
    to act on them instead of ignoring them.
    
    Fixes-Bug: http://bugs.xenproject.org/xen/bug/6
    Reported-by:  Alex Bligh <alex@alex.org.uk>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index fc6c94c0b436..32f9236c959f 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -198,10 +198,32 @@ struct shutdown_handler {
 	void (*cb)(void);
 };
 
+static int poweroff_nb(struct notifier_block *cb, unsigned long code, void *unused)
+{
+	switch (code) {
+	case SYS_DOWN:
+	case SYS_HALT:
+	case SYS_POWER_OFF:
+		shutting_down = SHUTDOWN_POWEROFF;
+	default:
+		break;
+	}
+	return NOTIFY_DONE;
+}
 static void do_poweroff(void)
 {
-	shutting_down = SHUTDOWN_POWEROFF;
-	orderly_poweroff(false);
+	switch (system_state) {
+	case SYSTEM_BOOTING:
+		orderly_poweroff(true);
+		break;
+	case SYSTEM_RUNNING:
+		orderly_poweroff(false);
+		break;
+	default:
+		/* Don't do it when we are halting/rebooting. */
+		pr_info("Ignoring Xen toolstack shutdown.\n");
+		break;
+	}
 }
 
 static void do_reboot(void)
@@ -307,6 +329,10 @@ static struct xenbus_watch shutdown_watch = {
 	.callback = shutdown_handler
 };
 
+static struct notifier_block xen_reboot_nb = {
+	.notifier_call = poweroff_nb,
+};
+
 static int setup_shutdown_watcher(void)
 {
 	int err;
@@ -317,6 +343,7 @@ static int setup_shutdown_watcher(void)
 		return err;
 	}
 
+
 #ifdef CONFIG_MAGIC_SYSRQ
 	err = register_xenbus_watch(&sysrq_watch);
 	if (err) {
@@ -345,6 +372,7 @@ int xen_setup_shutdown_event(void)
 	if (!xen_domain())
 		return -ENODEV;
 	register_xenstore_notifier(&xenstore_notifier);
+	register_reboot_notifier(&xen_reboot_nb);
 
 	return 0;
 }

commit cd979883b9ede90643e019f33cb317933eb867b4
Author: Stanislaw Gruszka <sgruszka@redhat.com>
Date:   Wed Feb 26 11:30:30 2014 +0100

    xen/acpi-processor: fix enabling interrupts on syscore_resume
    
    syscore->resume() callback is expected to do not enable interrupts,
    it generates warning like below otherwise:
    
    [ 9386.365390] WARNING: CPU: 0 PID: 6733 at drivers/base/syscore.c:104 syscore_resume+0x9a/0xe0()
    [ 9386.365403] Interrupts enabled after xen_acpi_processor_resume+0x0/0x34 [xen_acpi_processor]
    ...
    [ 9386.365429] Call Trace:
    [ 9386.365434]  [<ffffffff81667a8b>] dump_stack+0x45/0x56
    [ 9386.365437]  [<ffffffff8106921d>] warn_slowpath_common+0x7d/0xa0
    [ 9386.365439]  [<ffffffff8106928c>] warn_slowpath_fmt+0x4c/0x50
    [ 9386.365442]  [<ffffffffa0261bb0>] ? xen_upload_processor_pm_data+0x300/0x300 [xen_acpi_processor]
    [ 9386.365443]  [<ffffffff814055fa>] syscore_resume+0x9a/0xe0
    [ 9386.365445]  [<ffffffff810aef42>] suspend_devices_and_enter+0x402/0x470
    [ 9386.365447]  [<ffffffff810af128>] pm_suspend+0x178/0x260
    
    On xen_acpi_processor_resume() we call various procedures, which are
    non atomic and can enable interrupts. To prevent the issue introduce
    separate resume notify called after we enable interrupts on resume
    and before we call other drivers resume callbacks.
    
    Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 624e8dc24532..fc6c94c0b436 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -46,6 +46,20 @@ struct suspend_info {
 	void (*post)(int cancelled);
 };
 
+static RAW_NOTIFIER_HEAD(xen_resume_notifier);
+
+void xen_resume_notifier_register(struct notifier_block *nb)
+{
+	raw_notifier_chain_register(&xen_resume_notifier, nb);
+}
+EXPORT_SYMBOL_GPL(xen_resume_notifier_register);
+
+void xen_resume_notifier_unregister(struct notifier_block *nb)
+{
+	raw_notifier_chain_unregister(&xen_resume_notifier, nb);
+}
+EXPORT_SYMBOL_GPL(xen_resume_notifier_unregister);
+
 #ifdef CONFIG_HIBERNATE_CALLBACKS
 static void xen_hvm_post_suspend(int cancelled)
 {
@@ -152,6 +166,8 @@ static void do_suspend(void)
 
 	err = stop_machine(xen_suspend, &si, cpumask_of(0));
 
+	raw_notifier_call_chain(&xen_resume_notifier, 0, NULL);
+
 	dpm_resume_start(si.cancelled ? PMSG_THAW : PMSG_RESTORE);
 
 	if (err) {

commit 21884a83b2192a00885d7244a1dda32debd2fbc7
Merge: 8b70a90cabaf 73b0cd674ccc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 6 14:09:38 2013 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer core updates from Thomas Gleixner:
     "The timer changes contain:
    
       - posix timer code consolidation and fixes for odd corner cases
    
       - sched_clock implementation moved from ARM to core code to avoid
         duplication by other architectures
    
       - alarm timer updates
    
       - clocksource and clockevents unregistration facilities
    
       - clocksource/events support for new hardware
    
       - precise nanoseconds RTC readout (Xen feature)
    
       - generic support for Xen suspend/resume oddities
    
       - the usual lot of fixes and cleanups all over the place
    
      The parts which touch other areas (ARM/XEN) have been coordinated with
      the relevant maintainers.  Though this results in an handful of
      trivial to solve merge conflicts, which we preferred over nasty cross
      tree merge dependencies.
    
      The patches which have been committed in the last few days are bug
      fixes plus the posix timer lot.  The latter was in akpms queue and
      next for quite some time; they just got forgotten and Frederic
      collected them last minute."
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (59 commits)
      hrtimer: Remove unused variable
      hrtimers: Move SMP function call to thread context
      clocksource: Reselect clocksource when watchdog validated high-res capability
      posix-cpu-timers: don't account cpu timer after stopped thread runtime accounting
      posix_timers: fix racy timer delta caching on task exit
      posix-timers: correctly get dying task time sample in posix_cpu_timer_schedule()
      selftests: add basic posix timers selftests
      posix_cpu_timers: consolidate expired timers check
      posix_cpu_timers: consolidate timer list cleanups
      posix_cpu_timer: consolidate expiry time type
      tick: Sanitize broadcast control logic
      tick: Prevent uncontrolled switch to oneshot mode
      tick: Make oneshot broadcast robust vs. CPU offlining
      x86: xen: Sync the CMOS RTC as well as the Xen wallclock
      x86: xen: Sync the wallclock when the system time is set
      timekeeping: Indicate that clock was set in the pvclock gtod notifier
      timekeeping: Pass flags instead of multiple bools to timekeeping_update()
      xen: Remove clock_was_set() call in the resume path
      hrtimers: Support resuming with two or more CPUs online (but stopped)
      timer: Fix jiffies wrap behavior of round_jiffies_common()
      ...

commit 0eb071651474952c8b6daecd36b378e2d01be22c
Author: David Vrabel <david.vrabel@citrix.com>
Date:   Thu Jun 27 11:35:44 2013 +0100

    xen: Remove clock_was_set() call in the resume path
    
    commit 359cdd3f866(xen: maintain clock offset over save/restore) added
    a clock_was_set() call into the xen resume code to propagate the
    system time changes. With the modified hrtimer resume code, which
    makes sure that all cpus are notified this call is not longer necessary.
    
    [ tglx: Separated it from the hrtimer change ]
    
    Signed-off-by: David Vrabel <david.vrabel@citrix.com>
    Cc: Konrad Rzeszutek Wilk  <konrad.wilk@oracle.com>
    Cc: John Stultz  <john.stultz@linaro.org>
    Cc: <xen-devel@lists.xen.org>
    Link: http://lkml.kernel.org/r/1372329348-20841-2-git-send-email-david.vrabel@citrix.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 412b96cc5305..421da856135d 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -166,9 +166,6 @@ static void do_suspend(void)
 
 	dpm_resume_end(si.cancelled ? PMSG_THAW : PMSG_RESTORE);
 
-	/* Make sure timer events get retriggered on all CPUs */
-	clock_was_set();
-
 out_thaw:
 #ifdef CONFIG_PREEMPT
 	thaw_processes();

commit 283c0972d53769ee44750cad4c27e3f5fa26ec1f
Author: Joe Perches <joe@perches.com>
Date:   Fri Jun 28 03:21:41 2013 -0700

    xen: Convert printks to pr_<level>
    
    Convert printks to pr_<level> (excludes printk(KERN_DEBUG...)
    to be more consistent throughout the xen subsystem.
    
    Add pr_fmt with KBUILD_MODNAME or "xen:" KBUILD_MODNAME
    Coalesce formats and add missing word spaces
    Add missing newlines
    Align arguments and reflow to 80 columns
    Remove DRV_NAME from formats as pr_fmt adds the same content
    
    This does change some of the prefixes of these messages
    but it also does make them more consistent.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index b1005d4a953d..9385b4524547 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -1,6 +1,9 @@
 /*
  * Handle extern requests for shutdown, reboot and sysrq
  */
+
+#define pr_fmt(fmt) "xen:" KBUILD_MODNAME ": " fmt
+
 #include <linux/kernel.h>
 #include <linux/err.h>
 #include <linux/slab.h>
@@ -73,8 +76,7 @@ static int xen_suspend(void *data)
 
 	err = syscore_suspend();
 	if (err) {
-		printk(KERN_ERR "xen_suspend: system core suspend failed: %d\n",
-			err);
+		pr_err("%s: system core suspend failed: %d\n", __func__, err);
 		return err;
 	}
 
@@ -115,14 +117,14 @@ static void do_suspend(void)
 	   during suspend. */
 	err = freeze_processes();
 	if (err) {
-		printk(KERN_ERR "xen suspend: freeze failed %d\n", err);
+		pr_err("%s: freeze failed %d\n", __func__, err);
 		goto out;
 	}
 #endif
 
 	err = dpm_suspend_start(PMSG_FREEZE);
 	if (err) {
-		printk(KERN_ERR "xen suspend: dpm_suspend_start %d\n", err);
+		pr_err("%s: dpm_suspend_start %d\n", __func__, err);
 		goto out_thaw;
 	}
 
@@ -131,7 +133,7 @@ static void do_suspend(void)
 
 	err = dpm_suspend_end(PMSG_FREEZE);
 	if (err) {
-		printk(KERN_ERR "dpm_suspend_end failed: %d\n", err);
+		pr_err("dpm_suspend_end failed: %d\n", err);
 		si.cancelled = 0;
 		goto out_resume;
 	}
@@ -153,7 +155,7 @@ static void do_suspend(void)
 	dpm_resume_start(si.cancelled ? PMSG_THAW : PMSG_RESTORE);
 
 	if (err) {
-		printk(KERN_ERR "failed to start xen_suspend: %d\n", err);
+		pr_err("failed to start xen_suspend: %d\n", err);
 		si.cancelled = 1;
 	}
 
@@ -245,7 +247,7 @@ static void shutdown_handler(struct xenbus_watch *watch,
 	if (handler->cb) {
 		handler->cb();
 	} else {
-		printk(KERN_INFO "Ignoring shutdown request: %s\n", str);
+		pr_info("Ignoring shutdown request: %s\n", str);
 		shutting_down = SHUTDOWN_INVALID;
 	}
 
@@ -265,8 +267,7 @@ static void sysrq_handler(struct xenbus_watch *watch, const char **vec,
 	if (err)
 		return;
 	if (!xenbus_scanf(xbt, "control", "sysrq", "%c", &sysrq_key)) {
-		printk(KERN_ERR "Unable to read sysrq code in "
-		       "control/sysrq\n");
+		pr_err("Unable to read sysrq code in control/sysrq\n");
 		xenbus_transaction_end(xbt, 1);
 		return;
 	}
@@ -299,14 +300,14 @@ static int setup_shutdown_watcher(void)
 
 	err = register_xenbus_watch(&shutdown_watch);
 	if (err) {
-		printk(KERN_ERR "Failed to set shutdown watcher\n");
+		pr_err("Failed to set shutdown watcher\n");
 		return err;
 	}
 
 #ifdef CONFIG_MAGIC_SYSRQ
 	err = register_xenbus_watch(&sysrq_watch);
 	if (err) {
-		printk(KERN_ERR "Failed to set sysrq watcher\n");
+		pr_err("Failed to set sysrq watcher\n");
 		return err;
 	}
 #endif

commit 65e053a7038c608f89272d4fb1f899890c579f0a
Author: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
Date:   Thu Jun 27 14:28:38 2013 +0100

    xen: ifdef CONFIG_HIBERNATE_CALLBACKS xen_*_suspend
    
    xen_hvm_post_suspend, xen_pre_suspend, xen_post_suspend are only used if
    CONFIG_HIBERNATE_CALLBACKS is defined, resulting in:
    
    drivers/xen/manage.c:46:13: warning: ‘xen_hvm_post_suspend’ defined but not used [-Wunused-function]
    drivers/xen/manage.c:52:13: warning: ‘xen_pre_suspend’ defined but not used [-Wunused-function]
    drivers/xen/manage.c:59:13: warning: ‘xen_post_suspend’ defined but not used [-Wunused-function]
    
    If the kernel config is missing CONFIG_HIBERNATE_CALLBACKS.
    
    Simply ifdef CONFIG_HIBERNATE_CALLBACKS the three functions.
    
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 412b96cc5305..b1005d4a953d 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -43,6 +43,7 @@ struct suspend_info {
 	void (*post)(int cancelled);
 };
 
+#ifdef CONFIG_HIBERNATE_CALLBACKS
 static void xen_hvm_post_suspend(int cancelled)
 {
 	xen_arch_hvm_post_suspend(cancelled);
@@ -63,7 +64,6 @@ static void xen_post_suspend(int cancelled)
 	xen_mm_unpin_all();
 }
 
-#ifdef CONFIG_HIBERNATE_CALLBACKS
 static int xen_suspend(void *data)
 {
 	struct suspend_info *si = data;

commit 186bab1ce04f99153b7eeb3348438b654c24c24b
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Tue Apr 17 14:35:49 2012 -0400

    xen/resume: Fix compile warnings.
    
    linux/drivers/xen/manage.c: In function 'do_suspend':
    linux/drivers/xen/manage.c:160:5: warning: 'si.cancelled' may be used uninitialized in this function
    
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 9e14ae6cd49c..412b96cc5305 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -132,6 +132,7 @@ static void do_suspend(void)
 	err = dpm_suspend_end(PMSG_FREEZE);
 	if (err) {
 		printk(KERN_ERR "dpm_suspend_end failed: %d\n", err);
+		si.cancelled = 0;
 		goto out_resume;
 	}
 

commit cf579dfb82550e34de7ccf3ef090d8b834ccd3a9
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Jan 29 20:38:29 2012 +0100

    PM / Sleep: Introduce "late suspend" and "early resume" of devices
    
    The current device suspend/resume phases during system-wide power
    transitions appear to be insufficient for some platforms that want
    to use the same callback routines for saving device states and
    related operations during runtime suspend/resume as well as during
    system suspend/resume.  In principle, they could point their
    .suspend_noirq() and .resume_noirq() to the same callback routines
    as their .runtime_suspend() and .runtime_resume(), respectively,
    but at least some of them require device interrupts to be enabled
    while the code in those routines is running.
    
    It also makes sense to have device suspend-resume callbacks that will
    be executed with runtime PM disabled and with device interrupts
    enabled in case someone needs to run some special code in that
    context during system-wide power transitions.
    
    Apart from this, .suspend_noirq() and .resume_noirq() were introduced
    as a workaround for drivers using shared interrupts and failing to
    prevent their interrupt handlers from accessing suspended hardware.
    It appears to be better not to use them for other porposes, or we may
    have to deal with some serious confusion (which seems to be happening
    already).
    
    For the above reasons, introduce new device suspend/resume phases,
    "late suspend" and "early resume" (and analogously for hibernation)
    whose callback will be executed with runtime PM disabled and with
    device interrupts enabled and whose callback pointers generally may
    point to runtime suspend/resume routines.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Reviewed-by: Kevin Hilman <khilman@ti.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index ce4fa0831860..9e14ae6cd49c 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -129,9 +129,9 @@ static void do_suspend(void)
 	printk(KERN_DEBUG "suspending xenstore...\n");
 	xs_suspend();
 
-	err = dpm_suspend_noirq(PMSG_FREEZE);
+	err = dpm_suspend_end(PMSG_FREEZE);
 	if (err) {
-		printk(KERN_ERR "dpm_suspend_noirq failed: %d\n", err);
+		printk(KERN_ERR "dpm_suspend_end failed: %d\n", err);
 		goto out_resume;
 	}
 
@@ -149,7 +149,7 @@ static void do_suspend(void)
 
 	err = stop_machine(xen_suspend, &si, cpumask_of(0));
 
-	dpm_resume_noirq(si.cancelled ? PMSG_THAW : PMSG_RESTORE);
+	dpm_resume_start(si.cancelled ? PMSG_THAW : PMSG_RESTORE);
 
 	if (err) {
 		printk(KERN_ERR "failed to start xen_suspend: %d\n", err);

commit 63c9744b9a53b8113b6d33ca361452b28f2ec391
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 10 13:22:07 2011 -0400

    xen: Add export.h for THIS_MODULE/EXPORT_SYMBOL to various xen users.
    
    Things like THIS_MODULE and EXPORT_SYMBOL were simply everywhere
    because module.h was also everywhere.  But we are fixing the latter.
    So we need to call out the real users in advance.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 0b5366b5be20..ce4fa0831860 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -9,6 +9,7 @@
 #include <linux/stop_machine.h>
 #include <linux/freezer.h>
 #include <linux/syscore_ops.h>
+#include <linux/export.h>
 
 #include <xen/xen.h>
 #include <xen/xenbus.h>

commit 2e711c04dbbf7a7732a3f7073b1fc285d12b369d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Apr 26 19:15:07 2011 +0200

    PM: Remove sysdev suspend, resume and shutdown operations
    
    Since suspend, resume and shutdown operations in struct sysdev_class
    and struct sysdev_driver are not used any more, remove them.  Also
    drop sysdev_suspend(), sysdev_resume() and sysdev_shutdown() used
    for executing those operations and modify all of their users
    accordingly.  This reduces kernel code size quite a bit and reduces
    its complexity.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index a2eee574784e..0b5366b5be20 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -70,12 +70,7 @@ static int xen_suspend(void *data)
 
 	BUG_ON(!irqs_disabled());
 
-	err = sysdev_suspend(PMSG_FREEZE);
-	if (!err) {
-		err = syscore_suspend();
-		if (err)
-			sysdev_resume();
-	}
+	err = syscore_suspend();
 	if (err) {
 		printk(KERN_ERR "xen_suspend: system core suspend failed: %d\n",
 			err);
@@ -102,7 +97,6 @@ static int xen_suspend(void *data)
 	}
 
 	syscore_resume();
-	sysdev_resume();
 
 	return 0;
 }

commit 19234c0819da0e043a02710488dfd9b242b42eba
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed Apr 20 00:36:11 2011 +0200

    PM: Add missing syscore_suspend() and syscore_resume() calls
    
    Device suspend/resume infrastructure is used not only by the suspend
    and hibernate code in kernel/power, but also by APM, Xen and the
    kexec jump feature.  However, commit 40dc166cb5dddbd36aa4ad11c03915ea
    (PM / Core: Introduce struct syscore_ops for core subsystems PM)
    failed to add syscore_suspend() and syscore_resume() calls to that
    code, which generally leads to breakage when the features in question
    are used.
    
    To fix this problem, add the missing syscore_suspend() and
    syscore_resume() calls to arch/x86/kernel/apm_32.c, kernel/kexec.c
    and drivers/xen/manage.c.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Ian Campbell <ian.campbell@citrix.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 1ac94125bf93..a2eee574784e 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -8,6 +8,7 @@
 #include <linux/sysrq.h>
 #include <linux/stop_machine.h>
 #include <linux/freezer.h>
+#include <linux/syscore_ops.h>
 
 #include <xen/xen.h>
 #include <xen/xenbus.h>
@@ -70,8 +71,13 @@ static int xen_suspend(void *data)
 	BUG_ON(!irqs_disabled());
 
 	err = sysdev_suspend(PMSG_FREEZE);
+	if (!err) {
+		err = syscore_suspend();
+		if (err)
+			sysdev_resume();
+	}
 	if (err) {
-		printk(KERN_ERR "xen_suspend: sysdev_suspend failed: %d\n",
+		printk(KERN_ERR "xen_suspend: system core suspend failed: %d\n",
 			err);
 		return err;
 	}
@@ -95,6 +101,7 @@ static int xen_suspend(void *data)
 		xen_timer_resume();
 	}
 
+	syscore_resume();
 	sysdev_resume();
 
 	return 0;

commit 1f112cee07b314e244ee9e71d9c1e6950dc13327
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Apr 11 22:54:42 2011 +0200

    PM / Hibernate: Introduce CONFIG_HIBERNATE_CALLBACKS
    
    Xen save/restore is going to use hibernate device callbacks for
    quiescing devices and putting them back to normal operations and it
    would need to select CONFIG_HIBERNATION for this purpose.  However,
    that also would cause the hibernate interfaces for user space to be
    enabled, which might confuse user space, because the Xen kernels
    don't support hibernation.  Moreover, it would be wasteful, as it
    would make the Xen kernels include a substantial amount of code that
    they would never use.
    
    To address this issue introduce new power management Kconfig option
    CONFIG_HIBERNATE_CALLBACKS, such that it will only select the code
    that is necessary for the hibernate device callbacks to work and make
    CONFIG_HIBERNATION select it.  Then, Xen save/restore will be able to
    select CONFIG_HIBERNATE_CALLBACKS without dragging the entire
    hibernate code along with it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: Shriram Rajagopalan <rshriram@cs.ubc.ca>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 95143dd6904d..1ac94125bf93 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -61,7 +61,7 @@ static void xen_post_suspend(int cancelled)
 	xen_mm_unpin_all();
 }
 
-#ifdef CONFIG_HIBERNATION
+#ifdef CONFIG_HIBERNATE_CALLBACKS
 static int xen_suspend(void *data)
 {
 	struct suspend_info *si = data;
@@ -173,7 +173,7 @@ static void do_suspend(void)
 #endif
 	shutting_down = SHUTDOWN_INVALID;
 }
-#endif	/* CONFIG_HIBERNATION */
+#endif	/* CONFIG_HIBERNATE_CALLBACKS */
 
 struct shutdown_handler {
 	const char *command;
@@ -202,7 +202,7 @@ static void shutdown_handler(struct xenbus_watch *watch,
 		{ "poweroff",	do_poweroff },
 		{ "halt",	do_poweroff },
 		{ "reboot",	do_reboot   },
-#ifdef CONFIG_HIBERNATION
+#ifdef CONFIG_HIBERNATE_CALLBACKS
 		{ "suspend",	do_suspend  },
 #endif
 		{NULL, NULL},

commit b3e96c0c756211e805c6941d4a6e5f6e1995cb6b
Author: Shriram Rajagopalan <rshriram@cs.ubc.ca>
Date:   Tue Feb 22 14:59:06 2011 -0800

    xen: use freeze/restore/thaw PM events for suspend/resume/chkpt
    
    Use PM_FREEZE, PM_THAW and PM_RESTORE power events for
    suspend/resume/checkpoint functionality, instead of PM_SUSPEND
    and PM_RESUME. Use of these pm events fixes the Xen Guest hangup
    when taking checkpoints. When a suspend event is cancelled
    (while taking checkpoints once/continuously), we use PM_THAW
    instead of PM_RESUME. PM_RESTORE is used when suspend is not
    cancelled. See Documentation/power/devices.txt and linux/pm.h
    for more info about freeze, thaw and restore. The sequence of
    pm events in a suspend-resume scenario is shown below.
    
            dpm_suspend_start(PMSG_FREEZE);
    
                    dpm_suspend_noirq(PMSG_FREEZE);
    
                           sysdev_suspend(PMSG_FREEZE);
                           cancelled = suspend_hypercall()
                           sysdev_resume();
    
                   dpm_resume_noirq(cancelled ? PMSG_THAW : PMSG_RESTORE);
    
           dpm_resume_end(cancelled ? PMSG_THAW : PMSG_RESTORE);
    
    Acked-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Shriram Rajagopalan <rshriram@cs.ubc.ca>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index ebb292859b59..95143dd6904d 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -61,7 +61,7 @@ static void xen_post_suspend(int cancelled)
 	xen_mm_unpin_all();
 }
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_HIBERNATION
 static int xen_suspend(void *data)
 {
 	struct suspend_info *si = data;
@@ -69,7 +69,7 @@ static int xen_suspend(void *data)
 
 	BUG_ON(!irqs_disabled());
 
-	err = sysdev_suspend(PMSG_SUSPEND);
+	err = sysdev_suspend(PMSG_FREEZE);
 	if (err) {
 		printk(KERN_ERR "xen_suspend: sysdev_suspend failed: %d\n",
 			err);
@@ -118,7 +118,7 @@ static void do_suspend(void)
 	}
 #endif
 
-	err = dpm_suspend_start(PMSG_SUSPEND);
+	err = dpm_suspend_start(PMSG_FREEZE);
 	if (err) {
 		printk(KERN_ERR "xen suspend: dpm_suspend_start %d\n", err);
 		goto out_thaw;
@@ -127,7 +127,7 @@ static void do_suspend(void)
 	printk(KERN_DEBUG "suspending xenstore...\n");
 	xs_suspend();
 
-	err = dpm_suspend_noirq(PMSG_SUSPEND);
+	err = dpm_suspend_noirq(PMSG_FREEZE);
 	if (err) {
 		printk(KERN_ERR "dpm_suspend_noirq failed: %d\n", err);
 		goto out_resume;
@@ -147,7 +147,7 @@ static void do_suspend(void)
 
 	err = stop_machine(xen_suspend, &si, cpumask_of(0));
 
-	dpm_resume_noirq(PMSG_RESUME);
+	dpm_resume_noirq(si.cancelled ? PMSG_THAW : PMSG_RESTORE);
 
 	if (err) {
 		printk(KERN_ERR "failed to start xen_suspend: %d\n", err);
@@ -161,7 +161,7 @@ static void do_suspend(void)
 	} else
 		xs_suspend_cancel();
 
-	dpm_resume_end(PMSG_RESUME);
+	dpm_resume_end(si.cancelled ? PMSG_THAW : PMSG_RESTORE);
 
 	/* Make sure timer events get retriggered on all CPUs */
 	clock_was_set();
@@ -173,7 +173,7 @@ static void do_suspend(void)
 #endif
 	shutting_down = SHUTDOWN_INVALID;
 }
-#endif	/* CONFIG_PM_SLEEP */
+#endif	/* CONFIG_HIBERNATION */
 
 struct shutdown_handler {
 	const char *command;
@@ -202,7 +202,7 @@ static void shutdown_handler(struct xenbus_watch *watch,
 		{ "poweroff",	do_poweroff },
 		{ "halt",	do_poweroff },
 		{ "reboot",	do_reboot   },
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_HIBERNATION
 		{ "suspend",	do_suspend  },
 #endif
 		{NULL, NULL},

commit b056b6a0144de90707cd22cf7b4f60bf69c86d59
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Feb 17 11:04:20 2011 +0000

    xen: suspend: remove xen_hvm_suspend
    
    It is now identical to xen_suspend, the differences are encapsulated
    in the suspend_info struct.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 5b7a0a9402e7..ebb292859b59 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -62,44 +62,6 @@ static void xen_post_suspend(int cancelled)
 }
 
 #ifdef CONFIG_PM_SLEEP
-static int xen_hvm_suspend(void *data)
-{
-	struct suspend_info *si = data;
-	int err;
-
-	BUG_ON(!irqs_disabled());
-
-	err = sysdev_suspend(PMSG_SUSPEND);
-	if (err) {
-		printk(KERN_ERR "xen_hvm_suspend: sysdev_suspend failed: %d\n",
-		       err);
-		return err;
-	}
-
-	if (si->pre)
-		si->pre();
-
-	/*
-	 * This hypercall returns 1 if suspend was cancelled
-	 * or the domain was merely checkpointed, and 0 if it
-	 * is resuming in a new domain.
-	 */
-	si->cancelled = HYPERVISOR_suspend(si->arg);
-
-	if (si->post)
-		si->post(si->cancelled);
-
-	if (!si->cancelled) {
-		xen_irq_resume();
-		xen_console_resume();
-		xen_timer_resume();
-	}
-
-	sysdev_resume();
-
-	return 0;
-}
-
 static int xen_suspend(void *data)
 {
 	struct suspend_info *si = data;
@@ -183,10 +145,7 @@ static void do_suspend(void)
 		si.post = &xen_post_suspend;
 	}
 
-	if (xen_hvm_domain())
-		err = stop_machine(xen_hvm_suspend, &si, cpumask_of(0));
-	else
-		err = stop_machine(xen_suspend, &si, cpumask_of(0));
+	err = stop_machine(xen_suspend, &si, cpumask_of(0));
 
 	dpm_resume_noirq(PMSG_RESUME);
 

commit 55fb4acef7089a6d4d93ed8caae6c258d06cfaf7
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Feb 17 11:04:20 2011 +0000

    xen: suspend: pull pre/post suspend hooks out into suspend_info
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index a6bd2e9ca106..5b7a0a9402e7 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -37,6 +37,8 @@ static enum shutdown_state shutting_down = SHUTDOWN_INVALID;
 struct suspend_info {
 	int cancelled;
 	unsigned long arg; /* extra hypercall argument */
+	void (*pre)(void);
+	void (*post)(int cancelled);
 };
 
 static void xen_hvm_post_suspend(int cancelled)
@@ -74,6 +76,9 @@ static int xen_hvm_suspend(void *data)
 		return err;
 	}
 
+	if (si->pre)
+		si->pre();
+
 	/*
 	 * This hypercall returns 1 if suspend was cancelled
 	 * or the domain was merely checkpointed, and 0 if it
@@ -81,7 +86,8 @@ static int xen_hvm_suspend(void *data)
 	 */
 	si->cancelled = HYPERVISOR_suspend(si->arg);
 
-	xen_hvm_post_suspend(si->cancelled);
+	if (si->post)
+		si->post(si->cancelled);
 
 	if (!si->cancelled) {
 		xen_irq_resume();
@@ -108,7 +114,8 @@ static int xen_suspend(void *data)
 		return err;
 	}
 
-	xen_pre_suspend();
+	if (si->pre)
+		si->pre();
 
 	/*
 	 * This hypercall returns 1 if suspend was cancelled
@@ -117,7 +124,8 @@ static int xen_suspend(void *data)
 	 */
 	si->cancelled = HYPERVISOR_suspend(si->arg);
 
-	xen_post_suspend(si->cancelled);
+	if (si->post)
+		si->post(si->cancelled);
 
 	if (!si->cancelled) {
 		xen_irq_resume();
@@ -165,10 +173,15 @@ static void do_suspend(void)
 
 	si.cancelled = 1;
 
-	if (xen_hvm_domain())
+	if (xen_hvm_domain()) {
 		si.arg = 0UL;
-	else
+		si.pre = NULL;
+		si.post = &xen_hvm_post_suspend;
+	} else {
 		si.arg = virt_to_mfn(xen_start_info);
+		si.pre = &xen_pre_suspend;
+		si.post = &xen_post_suspend;
+	}
 
 	if (xen_hvm_domain())
 		err = stop_machine(xen_hvm_suspend, &si, cpumask_of(0));

commit 07af38102fc4f260cc5a2418ec833707f53cdf70
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Feb 17 11:04:20 2011 +0000

    xen: suspend: move arch specific pre/post suspend hooks into generic hooks
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 33312c09829e..a6bd2e9ca106 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -39,8 +39,9 @@ struct suspend_info {
 	unsigned long arg; /* extra hypercall argument */
 };
 
-static void xen_hvm_post_suspend(void)
+static void xen_hvm_post_suspend(int cancelled)
 {
+	xen_arch_hvm_post_suspend(cancelled);
 	gnttab_resume();
 }
 
@@ -48,10 +49,12 @@ static void xen_pre_suspend(void)
 {
 	xen_mm_pin_all();
 	gnttab_suspend();
+	xen_arch_pre_suspend();
 }
 
-static void xen_post_suspend(void)
+static void xen_post_suspend(int cancelled)
 {
+	xen_arch_post_suspend(cancelled);
 	gnttab_resume();
 	xen_mm_unpin_all();
 }
@@ -78,8 +81,7 @@ static int xen_hvm_suspend(void *data)
 	 */
 	si->cancelled = HYPERVISOR_suspend(si->arg);
 
-	xen_arch_hvm_post_suspend(si->cancelled);
-	xen_hvm_post_suspend();
+	xen_hvm_post_suspend(si->cancelled);
 
 	if (!si->cancelled) {
 		xen_irq_resume();
@@ -107,7 +109,6 @@ static int xen_suspend(void *data)
 	}
 
 	xen_pre_suspend();
-	xen_arch_pre_suspend();
 
 	/*
 	 * This hypercall returns 1 if suspend was cancelled
@@ -116,8 +117,7 @@ static int xen_suspend(void *data)
 	 */
 	si->cancelled = HYPERVISOR_suspend(si->arg);
 
-	xen_arch_post_suspend(si->cancelled);
-	xen_post_suspend();
+	xen_post_suspend(si->cancelled);
 
 	if (!si->cancelled) {
 		xen_irq_resume();

commit 82043bb60d24d2897074905c94be5a53071e8913
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Feb 17 11:04:20 2011 +0000

    xen: suspend: refactor non-arch specific pre/post suspend hooks
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 134eb73ca596..33312c09829e 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -39,6 +39,23 @@ struct suspend_info {
 	unsigned long arg; /* extra hypercall argument */
 };
 
+static void xen_hvm_post_suspend(void)
+{
+	gnttab_resume();
+}
+
+static void xen_pre_suspend(void)
+{
+	xen_mm_pin_all();
+	gnttab_suspend();
+}
+
+static void xen_post_suspend(void)
+{
+	gnttab_resume();
+	xen_mm_unpin_all();
+}
+
 #ifdef CONFIG_PM_SLEEP
 static int xen_hvm_suspend(void *data)
 {
@@ -62,7 +79,7 @@ static int xen_hvm_suspend(void *data)
 	si->cancelled = HYPERVISOR_suspend(si->arg);
 
 	xen_arch_hvm_post_suspend(si->cancelled);
-	gnttab_resume();
+	xen_hvm_post_suspend();
 
 	if (!si->cancelled) {
 		xen_irq_resume();
@@ -89,8 +106,7 @@ static int xen_suspend(void *data)
 		return err;
 	}
 
-	xen_mm_pin_all();
-	gnttab_suspend();
+	xen_pre_suspend();
 	xen_arch_pre_suspend();
 
 	/*
@@ -101,8 +117,7 @@ static int xen_suspend(void *data)
 	si->cancelled = HYPERVISOR_suspend(si->arg);
 
 	xen_arch_post_suspend(si->cancelled);
-	gnttab_resume();
-	xen_mm_unpin_all();
+	xen_post_suspend();
 
 	if (!si->cancelled) {
 		xen_irq_resume();

commit 03c8142bd2fb3b87effa6ecb2f8957be588bc85f
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Feb 17 11:04:20 2011 +0000

    xen: suspend: add "arch" to pre/post suspend hooks
    
    xen_pre_device_suspend is unused on ia64.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 6ce6b91e7645..134eb73ca596 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -61,7 +61,7 @@ static int xen_hvm_suspend(void *data)
 	 */
 	si->cancelled = HYPERVISOR_suspend(si->arg);
 
-	xen_hvm_post_suspend(si->cancelled);
+	xen_arch_hvm_post_suspend(si->cancelled);
 	gnttab_resume();
 
 	if (!si->cancelled) {
@@ -91,7 +91,7 @@ static int xen_suspend(void *data)
 
 	xen_mm_pin_all();
 	gnttab_suspend();
-	xen_pre_suspend();
+	xen_arch_pre_suspend();
 
 	/*
 	 * This hypercall returns 1 if suspend was cancelled
@@ -100,7 +100,7 @@ static int xen_suspend(void *data)
 	 */
 	si->cancelled = HYPERVISOR_suspend(si->arg);
 
-	xen_post_suspend(si->cancelled);
+	xen_arch_post_suspend(si->cancelled);
 	gnttab_resume();
 	xen_mm_unpin_all();
 

commit 36b401e2c2788c7b4881115ddbbff603fe4cf78d
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Feb 17 11:04:20 2011 +0000

    xen: suspend: pass extra hypercall argument via suspend_info struct
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 5c0184fb9d84..6ce6b91e7645 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -36,6 +36,7 @@ static enum shutdown_state shutting_down = SHUTDOWN_INVALID;
 
 struct suspend_info {
 	int cancelled;
+	unsigned long arg; /* extra hypercall argument */
 };
 
 #ifdef CONFIG_PM_SLEEP
@@ -58,7 +59,7 @@ static int xen_hvm_suspend(void *data)
 	 * or the domain was merely checkpointed, and 0 if it
 	 * is resuming in a new domain.
 	 */
-	si->cancelled = HYPERVISOR_suspend(0UL);
+	si->cancelled = HYPERVISOR_suspend(si->arg);
 
 	xen_hvm_post_suspend(si->cancelled);
 	gnttab_resume();
@@ -97,7 +98,7 @@ static int xen_suspend(void *data)
 	 * or the domain was merely checkpointed, and 0 if it
 	 * is resuming in a new domain.
 	 */
-	si->cancelled = HYPERVISOR_suspend(virt_to_mfn(xen_start_info));
+	si->cancelled = HYPERVISOR_suspend(si->arg);
 
 	xen_post_suspend(si->cancelled);
 	gnttab_resume();
@@ -149,6 +150,11 @@ static void do_suspend(void)
 
 	si.cancelled = 1;
 
+	if (xen_hvm_domain())
+		si.arg = 0UL;
+	else
+		si.arg = virt_to_mfn(xen_start_info);
+
 	if (xen_hvm_domain())
 		err = stop_machine(xen_hvm_suspend, &si, cpumask_of(0));
 	else

commit ceb180294790c8a6a437533488616f6b591b49d0
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Feb 17 11:04:20 2011 +0000

    xen: suspend: refactor cancellation flag into a structure
    
    Will add extra fields in subsequent patches.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 4dd01865ad18..5c0184fb9d84 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -34,11 +34,15 @@ enum shutdown_state {
 /* Ignore multiple shutdown requests. */
 static enum shutdown_state shutting_down = SHUTDOWN_INVALID;
 
+struct suspend_info {
+	int cancelled;
+};
+
 #ifdef CONFIG_PM_SLEEP
 static int xen_hvm_suspend(void *data)
 {
+	struct suspend_info *si = data;
 	int err;
-	int *cancelled = data;
 
 	BUG_ON(!irqs_disabled());
 
@@ -54,12 +58,12 @@ static int xen_hvm_suspend(void *data)
 	 * or the domain was merely checkpointed, and 0 if it
 	 * is resuming in a new domain.
 	 */
-	*cancelled = HYPERVISOR_suspend(0UL);
+	si->cancelled = HYPERVISOR_suspend(0UL);
 
-	xen_hvm_post_suspend(*cancelled);
+	xen_hvm_post_suspend(si->cancelled);
 	gnttab_resume();
 
-	if (!*cancelled) {
+	if (!si->cancelled) {
 		xen_irq_resume();
 		xen_console_resume();
 		xen_timer_resume();
@@ -72,8 +76,8 @@ static int xen_hvm_suspend(void *data)
 
 static int xen_suspend(void *data)
 {
+	struct suspend_info *si = data;
 	int err;
-	int *cancelled = data;
 
 	BUG_ON(!irqs_disabled());
 
@@ -93,13 +97,13 @@ static int xen_suspend(void *data)
 	 * or the domain was merely checkpointed, and 0 if it
 	 * is resuming in a new domain.
 	 */
-	*cancelled = HYPERVISOR_suspend(virt_to_mfn(xen_start_info));
+	si->cancelled = HYPERVISOR_suspend(virt_to_mfn(xen_start_info));
 
-	xen_post_suspend(*cancelled);
+	xen_post_suspend(si->cancelled);
 	gnttab_resume();
 	xen_mm_unpin_all();
 
-	if (!*cancelled) {
+	if (!si->cancelled) {
 		xen_irq_resume();
 		xen_console_resume();
 		xen_timer_resume();
@@ -113,7 +117,7 @@ static int xen_suspend(void *data)
 static void do_suspend(void)
 {
 	int err;
-	int cancelled = 1;
+	struct suspend_info si;
 
 	shutting_down = SHUTDOWN_SUSPEND;
 
@@ -143,20 +147,22 @@ static void do_suspend(void)
 		goto out_resume;
 	}
 
+	si.cancelled = 1;
+
 	if (xen_hvm_domain())
-		err = stop_machine(xen_hvm_suspend, &cancelled, cpumask_of(0));
+		err = stop_machine(xen_hvm_suspend, &si, cpumask_of(0));
 	else
-		err = stop_machine(xen_suspend, &cancelled, cpumask_of(0));
+		err = stop_machine(xen_suspend, &si, cpumask_of(0));
 
 	dpm_resume_noirq(PMSG_RESUME);
 
 	if (err) {
 		printk(KERN_ERR "failed to start xen_suspend: %d\n", err);
-		cancelled = 1;
+		si.cancelled = 1;
 	}
 
 out_resume:
-	if (!cancelled) {
+	if (!si.cancelled) {
 		xen_arch_resume();
 		xs_resume();
 	} else

commit bd1c0ad28451df4610d352c7e438213c84de0c28
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Feb 17 11:04:20 2011 +0000

    xen: suspend: use HYPERVISOR_suspend for PVHVM case instead of open coding
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 972bf783a182..4dd01865ad18 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -38,7 +38,6 @@ static enum shutdown_state shutting_down = SHUTDOWN_INVALID;
 static int xen_hvm_suspend(void *data)
 {
 	int err;
-	struct sched_shutdown r = { .reason = SHUTDOWN_suspend };
 	int *cancelled = data;
 
 	BUG_ON(!irqs_disabled());
@@ -50,7 +49,12 @@ static int xen_hvm_suspend(void *data)
 		return err;
 	}
 
-	*cancelled = HYPERVISOR_sched_op(SCHEDOP_shutdown, &r);
+	/*
+	 * This hypercall returns 1 if suspend was cancelled
+	 * or the domain was merely checkpointed, and 0 if it
+	 * is resuming in a new domain.
+	 */
+	*cancelled = HYPERVISOR_suspend(0UL);
 
 	xen_hvm_post_suspend(*cancelled);
 	gnttab_resume();

commit 552717231e50b478dfd19d63fd97879476ae051d
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Feb 17 11:04:20 2011 +0000

    xen: do not respond to unknown xenstore control requests
    
    The PV xenbus control/shutdown node is written by the toolstack as a
    request to the guest to perform a particular action (shutdown, reboot,
    suspend etc). The guest is expected to acknowledge that it will
    complete a request by clearing the control node.
    
    Previously it would acknowledge any request, even if it did not know
    what to do with it. Specifically in the case where CONFIG_PM_SLEEP is
    not enabled the kernel would acknowledge a suspend request even though
    it was not actually going to do anything.
    
    Instead make the kernel only acknowledge requests if it is actually
    going to do something with it. This will improve the toolstack's
    ability to diagnose and deal with failures.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Reviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index b2a8d7856ce3..972bf783a182 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -172,12 +172,39 @@ static void do_suspend(void)
 }
 #endif	/* CONFIG_PM_SLEEP */
 
+struct shutdown_handler {
+	const char *command;
+	void (*cb)(void);
+};
+
+static void do_poweroff(void)
+{
+	shutting_down = SHUTDOWN_POWEROFF;
+	orderly_poweroff(false);
+}
+
+static void do_reboot(void)
+{
+	shutting_down = SHUTDOWN_POWEROFF; /* ? */
+	ctrl_alt_del();
+}
+
 static void shutdown_handler(struct xenbus_watch *watch,
 			     const char **vec, unsigned int len)
 {
 	char *str;
 	struct xenbus_transaction xbt;
 	int err;
+	static struct shutdown_handler handlers[] = {
+		{ "poweroff",	do_poweroff },
+		{ "halt",	do_poweroff },
+		{ "reboot",	do_reboot   },
+#ifdef CONFIG_PM_SLEEP
+		{ "suspend",	do_suspend  },
+#endif
+		{NULL, NULL},
+	};
+	static struct shutdown_handler *handler;
 
 	if (shutting_down != SHUTDOWN_INVALID)
 		return;
@@ -194,7 +221,14 @@ static void shutdown_handler(struct xenbus_watch *watch,
 		return;
 	}
 
-	xenbus_write(xbt, "control", "shutdown", "");
+	for (handler = &handlers[0]; handler->command; handler++) {
+		if (strcmp(str, handler->command) == 0)
+			break;
+	}
+
+	/* Only acknowledge commands which we are prepared to handle. */
+	if (handler->cb)
+		xenbus_write(xbt, "control", "shutdown", "");
 
 	err = xenbus_transaction_end(xbt, 0);
 	if (err == -EAGAIN) {
@@ -202,17 +236,8 @@ static void shutdown_handler(struct xenbus_watch *watch,
 		goto again;
 	}
 
-	if (strcmp(str, "poweroff") == 0 ||
-	    strcmp(str, "halt") == 0) {
-		shutting_down = SHUTDOWN_POWEROFF;
-		orderly_poweroff(false);
-	} else if (strcmp(str, "reboot") == 0) {
-		shutting_down = SHUTDOWN_POWEROFF; /* ? */
-		ctrl_alt_del();
-#ifdef CONFIG_PM_SLEEP
-	} else if (strcmp(str, "suspend") == 0) {
-		do_suspend();
-#endif
+	if (handler->cb) {
+		handler->cb();
 	} else {
 		printk(KERN_INFO "Ignoring shutdown request: %s\n", str);
 		shutting_down = SHUTDOWN_INVALID;

commit 702d4eb9b3de4398ab99cf0a4e799e552c7ab756
Author: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
Date:   Thu Dec 2 17:54:50 2010 +0000

    xen: no need to delay xen_setup_shutdown_event for hvm guests anymore
    
    Now that xenstore_ready is used correctly for PV on HVM guests too, we
    don't need to delay the initialization of xen_setup_shutdown_event
    anymore.
    
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Acked-by: Jeremy Fitzhardinge <jeremy@goop.org>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 24177272bcb8..b2a8d7856ce3 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -291,27 +291,18 @@ static int shutdown_event(struct notifier_block *notifier,
 	return NOTIFY_DONE;
 }
 
-static int __init __setup_shutdown_event(void)
-{
-	/* Delay initialization in the PV on HVM case */
-	if (xen_hvm_domain())
-		return 0;
-
-	if (!xen_pv_domain())
-		return -ENODEV;
-
-	return xen_setup_shutdown_event();
-}
-
 int xen_setup_shutdown_event(void)
 {
 	static struct notifier_block xenstore_notifier = {
 		.notifier_call = shutdown_event
 	};
+
+	if (!xen_domain())
+		return -ENODEV;
 	register_xenstore_notifier(&xenstore_notifier);
 
 	return 0;
 }
 EXPORT_SYMBOL_GPL(xen_setup_shutdown_event);
 
-subsys_initcall(__setup_shutdown_event);
+subsys_initcall(xen_setup_shutdown_event);

commit 8dd38383a51d0fb6b025dc330aaa3470281da3b2
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Feb 17 10:31:20 2011 +0000

    xen: suspend and resume system devices when running PVHVM
    
    Otherwise we fail to properly suspend/resume all of the emulated devices.
    
    Something between 2.6.38-rc2 and rc3 appears to have exposed this
    issue, but it's always been wrong not to do this.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Acked-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Acked-by: Jeremy Fitzhardinge <jeremy@goop.org>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index db8c4c4ac880..24177272bcb8 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -37,11 +37,19 @@ static enum shutdown_state shutting_down = SHUTDOWN_INVALID;
 #ifdef CONFIG_PM_SLEEP
 static int xen_hvm_suspend(void *data)
 {
+	int err;
 	struct sched_shutdown r = { .reason = SHUTDOWN_suspend };
 	int *cancelled = data;
 
 	BUG_ON(!irqs_disabled());
 
+	err = sysdev_suspend(PMSG_SUSPEND);
+	if (err) {
+		printk(KERN_ERR "xen_hvm_suspend: sysdev_suspend failed: %d\n",
+		       err);
+		return err;
+	}
+
 	*cancelled = HYPERVISOR_sched_op(SCHEDOP_shutdown, &r);
 
 	xen_hvm_post_suspend(*cancelled);
@@ -53,6 +61,8 @@ static int xen_hvm_suspend(void *data)
 		xen_timer_resume();
 	}
 
+	sysdev_resume();
+
 	return 0;
 }
 

commit 6411fe69b8c4fd7811339c88c1843d562099fa2b
Author: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
Date:   Wed Dec 1 14:51:44 2010 +0000

    xen: resume the pv console for hvm guests too
    
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index ef9c7db52077..db8c4c4ac880 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -49,6 +49,7 @@ static int xen_hvm_suspend(void *data)
 
 	if (!*cancelled) {
 		xen_irq_resume();
+		xen_console_resume();
 		xen_timer_resume();
 	}
 

commit f335397d177c906256ee1bba28e8c49e8ec63817
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Aug 17 21:15:47 2010 -0700

    Input: sysrq - drop tty argument form handle_sysrq()
    
    Sysrq operations do not accept tty argument anymore so no need to pass
    it to us.
    
    [Stephen Rothwell <sfr@canb.auug.org.au>: fix build breakage in drm code
     caused by sysrq using bool but not including linux/types.h]
    
    [Sachin Sant <sachinp@in.ibm.com>: fix build breakage in s390 keyboadr
     driver]
    
    Acked-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Acked-by: Jason Wessel <jason.wessel@windriver.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 1799bd890315..ef9c7db52077 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -237,7 +237,7 @@ static void sysrq_handler(struct xenbus_watch *watch, const char **vec,
 		goto again;
 
 	if (sysrq_key != '\0')
-		handle_sysrq(sysrq_key, NULL);
+		handle_sysrq(sysrq_key);
 }
 
 static struct xenbus_watch sysrq_watch = {

commit 016b6f5fe8398b0291cece60b749d7c930a2e09c
Author: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
Date:   Fri May 14 12:45:07 2010 +0100

    xen: Add suspend/resume support for PV on HVM guests.
    
    Suspend/resume requires few different things on HVM: the suspend
    hypercall is different; we don't need to save/restore memory related
    settings; except the shared info page and the callback mechanism.
    
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index af9c5594d315..1799bd890315 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -9,6 +9,7 @@
 #include <linux/stop_machine.h>
 #include <linux/freezer.h>
 
+#include <xen/xen.h>
 #include <xen/xenbus.h>
 #include <xen/grant_table.h>
 #include <xen/events.h>
@@ -17,6 +18,7 @@
 
 #include <asm/xen/hypercall.h>
 #include <asm/xen/page.h>
+#include <asm/xen/hypervisor.h>
 
 enum shutdown_state {
 	SHUTDOWN_INVALID = -1,
@@ -33,10 +35,30 @@ enum shutdown_state {
 static enum shutdown_state shutting_down = SHUTDOWN_INVALID;
 
 #ifdef CONFIG_PM_SLEEP
-static int xen_suspend(void *data)
+static int xen_hvm_suspend(void *data)
 {
+	struct sched_shutdown r = { .reason = SHUTDOWN_suspend };
 	int *cancelled = data;
+
+	BUG_ON(!irqs_disabled());
+
+	*cancelled = HYPERVISOR_sched_op(SCHEDOP_shutdown, &r);
+
+	xen_hvm_post_suspend(*cancelled);
+	gnttab_resume();
+
+	if (!*cancelled) {
+		xen_irq_resume();
+		xen_timer_resume();
+	}
+
+	return 0;
+}
+
+static int xen_suspend(void *data)
+{
 	int err;
+	int *cancelled = data;
 
 	BUG_ON(!irqs_disabled());
 
@@ -106,7 +128,10 @@ static void do_suspend(void)
 		goto out_resume;
 	}
 
-	err = stop_machine(xen_suspend, &cancelled, cpumask_of(0));
+	if (xen_hvm_domain())
+		err = stop_machine(xen_hvm_suspend, &cancelled, cpumask_of(0));
+	else
+		err = stop_machine(xen_suspend, &cancelled, cpumask_of(0));
 
 	dpm_resume_noirq(PMSG_RESUME);
 
@@ -255,7 +280,19 @@ static int shutdown_event(struct notifier_block *notifier,
 	return NOTIFY_DONE;
 }
 
-static int __init setup_shutdown_event(void)
+static int __init __setup_shutdown_event(void)
+{
+	/* Delay initialization in the PV on HVM case */
+	if (xen_hvm_domain())
+		return 0;
+
+	if (!xen_pv_domain())
+		return -ENODEV;
+
+	return xen_setup_shutdown_event();
+}
+
+int xen_setup_shutdown_event(void)
 {
 	static struct notifier_block xenstore_notifier = {
 		.notifier_call = shutdown_event
@@ -266,4 +303,4 @@ static int __init setup_shutdown_event(void)
 }
 EXPORT_SYMBOL_GPL(xen_setup_shutdown_event);
 
-subsys_initcall(setup_shutdown_event);
+subsys_initcall(__setup_shutdown_event);

commit 183d03cc4ff39e0f0d952c09aa96d0abfd6e0c3c
Author: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
Date:   Mon May 17 17:08:21 2010 +0100

    xen: Xen PCI platform device driver.
    
    Add the xen pci platform device driver that is responsible
    for initializing the grant table and xenbus in PV on HVM mode.
    Few changes to xenbus and grant table are necessary to allow the delayed
    initialization in HVM mode.
    Grant table needs few additional modifications to work in HVM mode.
    
    The Xen PCI platform device raises an irq every time an event has been
    delivered to us. However these interrupts are only delivered to vcpu 0.
    The Xen PCI platform interrupt handler calls xen_hvm_evtchn_do_upcall
    that is a little wrapper around __xen_evtchn_do_upcall, the traditional
    Xen upcall handler, the very same used with traditional PV guests.
    
    When running on HVM the event channel upcall is never called while in
    progress because it is a normal Linux irq handler (and we cannot switch
    the irq chip wholesale to the Xen PV ones as we are running QEMU and
    might have passed in PCI devices), therefore we cannot be sure that
    evtchn_upcall_pending is 0 when returning.
    For this reason if evtchn_upcall_pending is set by Xen we need to loop
    again on the event channels set pending otherwise we might loose some
    event channel deliveries.
    
    Signed-off-by: Stefano Stabellini <stefano.stabellini@eu.citrix.com>
    Signed-off-by: Sheng Yang <sheng@linux.intel.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 07e857b0de13..af9c5594d315 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -264,5 +264,6 @@ static int __init setup_shutdown_event(void)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(xen_setup_shutdown_event);
 
 subsys_initcall(setup_shutdown_event);

commit f3bc3189a001ec85c7b1119ad4aa5e39eea0f05e
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Mon May 24 14:33:41 2010 -0700

    xen: fix build when SYSRQ is disabled
    
    Fix build error when CONFIG_MAGIC_SYSRQ is not enabled:
    
    drivers/xen/manage.c:223: error: implicit declaration of function 'handle_sysrq'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Acked-by: Jeremy Fitzhardinge <jeremy@xensource.com>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 8943b8ccee1a..07e857b0de13 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -185,6 +185,7 @@ static void shutdown_handler(struct xenbus_watch *watch,
 	kfree(str);
 }
 
+#ifdef CONFIG_MAGIC_SYSRQ
 static void sysrq_handler(struct xenbus_watch *watch, const char **vec,
 			  unsigned int len)
 {
@@ -214,15 +215,16 @@ static void sysrq_handler(struct xenbus_watch *watch, const char **vec,
 		handle_sysrq(sysrq_key, NULL);
 }
 
-static struct xenbus_watch shutdown_watch = {
-	.node = "control/shutdown",
-	.callback = shutdown_handler
-};
-
 static struct xenbus_watch sysrq_watch = {
 	.node = "control/sysrq",
 	.callback = sysrq_handler
 };
+#endif
+
+static struct xenbus_watch shutdown_watch = {
+	.node = "control/shutdown",
+	.callback = shutdown_handler
+};
 
 static int setup_shutdown_watcher(void)
 {
@@ -234,11 +236,13 @@ static int setup_shutdown_watcher(void)
 		return err;
 	}
 
+#ifdef CONFIG_MAGIC_SYSRQ
 	err = register_xenbus_watch(&sysrq_watch);
 	if (err) {
 		printk(KERN_ERR "Failed to set sysrq watcher\n");
 		return err;
 	}
+#endif
 
 	return 0;
 }

commit 3fc1f1e27a5b807791d72e5d992aa33b668a6626
Author: Tejun Heo <tj@kernel.org>
Date:   Thu May 6 18:49:20 2010 +0200

    stop_machine: reimplement using cpu_stop
    
    Reimplement stop_machine using cpu_stop.  As cpu stoppers are
    guaranteed to be available for all online cpus,
    stop_machine_create/destroy() are no longer necessary and removed.
    
    With resource management and synchronization handled by cpu_stop, the
    new implementation is much simpler.  Asking the cpu_stop to execute
    the stop_cpu() state machine on all online cpus with cpu hotplug
    disabled is enough.
    
    stop_machine itself doesn't need to manage any global resources
    anymore, so all per-instance information is rolled into struct
    stop_machine_data and the mutex and all static data variables are
    removed.
    
    The previous implementation created and destroyed RT workqueues as
    necessary which made stop_machine() calls highly expensive on very
    large machines.  According to Dimitri Sivanich, preventing the dynamic
    creation/destruction makes booting faster more than twice on very
    large machines.  cpu_stop resources are preallocated for all online
    cpus and should have the same effect.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>
    Acked-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Dimitri Sivanich <sivanich@sgi.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 2ac4440e7b08..8943b8ccee1a 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -80,12 +80,6 @@ static void do_suspend(void)
 
 	shutting_down = SHUTDOWN_SUSPEND;
 
-	err = stop_machine_create();
-	if (err) {
-		printk(KERN_ERR "xen suspend: failed to setup stop_machine %d\n", err);
-		goto out;
-	}
-
 #ifdef CONFIG_PREEMPT
 	/* If the kernel is preemptible, we need to freeze all the processes
 	   to prevent them from being in the middle of a pagetable update
@@ -93,7 +87,7 @@ static void do_suspend(void)
 	err = freeze_processes();
 	if (err) {
 		printk(KERN_ERR "xen suspend: freeze failed %d\n", err);
-		goto out_destroy_sm;
+		goto out;
 	}
 #endif
 
@@ -136,12 +130,8 @@ static void do_suspend(void)
 out_thaw:
 #ifdef CONFIG_PREEMPT
 	thaw_processes();
-
-out_destroy_sm:
-#endif
-	stop_machine_destroy();
-
 out:
+#endif
 	shutting_down = SHUTDOWN_INVALID;
 }
 #endif	/* CONFIG_PM_SLEEP */

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 5d42d55e299b..2ac4440e7b08 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -3,6 +3,7 @@
  */
 #include <linux/kernel.h>
 #include <linux/err.h>
+#include <linux/slab.h>
 #include <linux/reboot.h>
 #include <linux/sysrq.h>
 #include <linux/stop_machine.h>

commit c5cae661d6cf808b6984762f763261adf35f3eb7
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Thu Dec 17 13:57:09 2009 +0000

    xen: fix hang on suspend.
    
    In 65f63384 "xen: improve error handling in do_suspend" I said:
        - xs_suspend()/xs_resume() and dpm_suspend_noirq()/dpm_resume_noirq() were not
          nested in the obvious way.
    and changed the ordering of the calls as so:
        BEFORE              AFTER
        xs_suspend          dpm_suspend_noirq
        dpm_suspend_noirq   xs_suspend
        *SUSPEND*           *SUSPEND*
        dpm_resume_noirq    dpm_resume_noirq
        xs_resume           xs_resume
    Clearly this is not an improvement and I was talking rubbish.
    
    In particular the new ordering is susceptible to a hang if a xenstore write is
    in progress at the point at which the suspend kicks in. When the suspend
    process calls xs_suspend it tries to take the request_mutex but if a write is
    in progress it could be looping in xenbus_xs.c:read_reply() waiting for
    something to arrive on &xs_state.reply_list while holding the request_mutex
    (taken in the caller of read_reply).
    
    However if we have done dpm_suspend_noirq before xs_suspend then we won't get
    any more xenstore interrupts and process_msg() will never be woken up to add
    anything to the reply_list.
    
    Fix this by calling xs_suspend before dpm_suspend_noirq. If dpm_suspend_noirq
    fails then make sure we go through the xs_suspend_cancel() code path.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Acked-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Cc: Stable Kernel <stable@kernel.org>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index c4997930afc7..5d42d55e299b 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -102,15 +102,15 @@ static void do_suspend(void)
 		goto out_thaw;
 	}
 
+	printk(KERN_DEBUG "suspending xenstore...\n");
+	xs_suspend();
+
 	err = dpm_suspend_noirq(PMSG_SUSPEND);
 	if (err) {
 		printk(KERN_ERR "dpm_suspend_noirq failed: %d\n", err);
 		goto out_resume;
 	}
 
-	printk(KERN_DEBUG "suspending xenstore...\n");
-	xs_suspend();
-
 	err = stop_machine(xen_suspend, &cancelled, cpumask_of(0));
 
 	dpm_resume_noirq(PMSG_RESUME);
@@ -120,13 +120,13 @@ static void do_suspend(void)
 		cancelled = 1;
 	}
 
+out_resume:
 	if (!cancelled) {
 		xen_arch_resume();
 		xs_resume();
 	} else
 		xs_suspend_cancel();
 
-out_resume:
 	dpm_resume_end(PMSG_RESUME);
 
 	/* Make sure timer events get retriggered on all CPUs */

commit b4606f2165153833247823e8c04c5e88cb3d298b
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Tue Dec 1 11:47:15 2009 +0000

    xen: explicitly create/destroy stop_machine workqueues outside suspend/resume region.
    
    I have observed cases where the implicit stop_machine_destroy() done by
    stop_machine() hangs while destroying the workqueues, specifically in
    kthread_stop(). This seems to be because timer ticks are not restarted
    until after stop_machine() returns.
    
    Fortunately stop_machine provides a facility to pre-create/post-destroy
    the workqueues so use this to ensure that workqueues are only destroyed
    after everything is really up and running again.
    
    I only actually observed this failure with 2.6.30. It seems that newer
    kernels are somehow more robust against doing kthread_stop() without timer
    interrupts (I tried some backports of some likely looking candidates but
    did not track down the commit which added this robustness). However this
    change seems like a reasonable belt&braces thing to do.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Cc: Stable Kernel <stable@kernel.org>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 2fb7d39b814c..c4997930afc7 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -79,6 +79,12 @@ static void do_suspend(void)
 
 	shutting_down = SHUTDOWN_SUSPEND;
 
+	err = stop_machine_create();
+	if (err) {
+		printk(KERN_ERR "xen suspend: failed to setup stop_machine %d\n", err);
+		goto out;
+	}
+
 #ifdef CONFIG_PREEMPT
 	/* If the kernel is preemptible, we need to freeze all the processes
 	   to prevent them from being in the middle of a pagetable update
@@ -86,7 +92,7 @@ static void do_suspend(void)
 	err = freeze_processes();
 	if (err) {
 		printk(KERN_ERR "xen suspend: freeze failed %d\n", err);
-		goto out;
+		goto out_destroy_sm;
 	}
 #endif
 
@@ -129,7 +135,11 @@ static void do_suspend(void)
 out_thaw:
 #ifdef CONFIG_PREEMPT
 	thaw_processes();
+
+out_destroy_sm:
 #endif
+	stop_machine_destroy();
+
 out:
 	shutting_down = SHUTDOWN_INVALID;
 }

commit 65f63384b391bf4d384327d8a7c6de9860290b5c
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Tue Dec 1 11:47:14 2009 +0000

    xen: improve error handling in do_suspend.
    
    The existing error handling has a few issues:
    - If freeze_processes() fails it exits with shutting_down = SHUTDOWN_SUSPEND.
    - If dpm_suspend_noirq() fails it exits without resuming xenbus.
    - If stop_machine() fails it exits without resuming xenbus or calling
      dpm_resume_end().
    - xs_suspend()/xs_resume() and dpm_suspend_noirq()/dpm_resume_noirq() were not
      nested in the obvious way.
    
    Fix by ensuring each failure case goto's the correct label. Treat a failure of
    stop_machine() as a cancelled suspend in order to follow the correct resume
    path.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Cc: Stable Kernel <stable@kernel.org>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 7b69a1aef877..2fb7d39b814c 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -86,32 +86,32 @@ static void do_suspend(void)
 	err = freeze_processes();
 	if (err) {
 		printk(KERN_ERR "xen suspend: freeze failed %d\n", err);
-		return;
+		goto out;
 	}
 #endif
 
 	err = dpm_suspend_start(PMSG_SUSPEND);
 	if (err) {
 		printk(KERN_ERR "xen suspend: dpm_suspend_start %d\n", err);
-		goto out;
+		goto out_thaw;
 	}
 
-	printk(KERN_DEBUG "suspending xenstore...\n");
-	xs_suspend();
-
 	err = dpm_suspend_noirq(PMSG_SUSPEND);
 	if (err) {
 		printk(KERN_ERR "dpm_suspend_noirq failed: %d\n", err);
-		goto resume_devices;
+		goto out_resume;
 	}
 
+	printk(KERN_DEBUG "suspending xenstore...\n");
+	xs_suspend();
+
 	err = stop_machine(xen_suspend, &cancelled, cpumask_of(0));
 
 	dpm_resume_noirq(PMSG_RESUME);
 
 	if (err) {
 		printk(KERN_ERR "failed to start xen_suspend: %d\n", err);
-		goto out;
+		cancelled = 1;
 	}
 
 	if (!cancelled) {
@@ -120,15 +120,17 @@ static void do_suspend(void)
 	} else
 		xs_suspend_cancel();
 
-resume_devices:
+out_resume:
 	dpm_resume_end(PMSG_RESUME);
 
 	/* Make sure timer events get retriggered on all CPUs */
 	clock_was_set();
-out:
+
+out_thaw:
 #ifdef CONFIG_PREEMPT
 	thaw_processes();
 #endif
+out:
 	shutting_down = SHUTDOWN_INVALID;
 }
 #endif	/* CONFIG_PM_SLEEP */

commit 922cc38ab71d1360978e65207e4a4f4988987127
Author: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
Date:   Tue Nov 24 09:58:49 2009 -0800

    xen: don't call dpm_resume_noirq() with interrupts disabled.
    
    dpm_resume_noirq() takes a mutex, so it can't be called from a no-interrupt
    context.  Don't call it from within the stop-machine function, but just
    afterwards, since we're resuming anyway, regardless of what happened.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Cc: Stable Kernel <stable@kernel.org>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 10d03d7931c4..7b69a1aef877 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -43,7 +43,6 @@ static int xen_suspend(void *data)
 	if (err) {
 		printk(KERN_ERR "xen_suspend: sysdev_suspend failed: %d\n",
 			err);
-		dpm_resume_noirq(PMSG_RESUME);
 		return err;
 	}
 
@@ -69,7 +68,6 @@ static int xen_suspend(void *data)
 	}
 
 	sysdev_resume();
-	dpm_resume_noirq(PMSG_RESUME);
 
 	return 0;
 }
@@ -108,6 +106,9 @@ static void do_suspend(void)
 	}
 
 	err = stop_machine(xen_suspend, &cancelled, cpumask_of(0));
+
+	dpm_resume_noirq(PMSG_RESUME);
+
 	if (err) {
 		printk(KERN_ERR "failed to start xen_suspend: %d\n", err);
 		goto out;
@@ -119,8 +120,6 @@ static void do_suspend(void)
 	} else
 		xs_suspend_cancel();
 
-	dpm_resume_noirq(PMSG_RESUME);
-
 resume_devices:
 	dpm_resume_end(PMSG_RESUME);
 

commit d161630297a20802d01c55847bfcba85d2118a9f
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Sun May 24 22:05:42 2009 +0200

    PM core: rename suspend and resume functions
    
    This patch (as1241) renames a bunch of functions in the PM core.
    Rather than go through a boring list of name changes, suffice it to
    say that in the end we have a bunch of pairs of functions:
    
            device_resume_noirq     dpm_resume_noirq
            device_resume           dpm_resume
            device_complete         dpm_complete
            device_suspend_noirq    dpm_suspend_noirq
            device_suspend          dpm_suspend
            device_prepare          dpm_prepare
    
    in which device_X does the X operation on a single device and dpm_X
    invokes device_X for all devices in the dpm_list.
    
    In addition, the old dpm_power_up and device_resume_noirq have been
    combined into a single function (dpm_resume_noirq).
    
    Lastly, dpm_suspend_start and dpm_resume_end are the renamed versions
    of the former top-level device_suspend and device_resume routines.
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Acked-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index d5b327ac4039..10d03d7931c4 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -43,7 +43,7 @@ static int xen_suspend(void *data)
 	if (err) {
 		printk(KERN_ERR "xen_suspend: sysdev_suspend failed: %d\n",
 			err);
-		device_resume_noirq(PMSG_RESUME);
+		dpm_resume_noirq(PMSG_RESUME);
 		return err;
 	}
 
@@ -69,7 +69,7 @@ static int xen_suspend(void *data)
 	}
 
 	sysdev_resume();
-	device_resume_noirq(PMSG_RESUME);
+	dpm_resume_noirq(PMSG_RESUME);
 
 	return 0;
 }
@@ -92,18 +92,18 @@ static void do_suspend(void)
 	}
 #endif
 
-	err = device_suspend(PMSG_SUSPEND);
+	err = dpm_suspend_start(PMSG_SUSPEND);
 	if (err) {
-		printk(KERN_ERR "xen suspend: device_suspend %d\n", err);
+		printk(KERN_ERR "xen suspend: dpm_suspend_start %d\n", err);
 		goto out;
 	}
 
 	printk(KERN_DEBUG "suspending xenstore...\n");
 	xs_suspend();
 
-	err = device_suspend_noirq(PMSG_SUSPEND);
+	err = dpm_suspend_noirq(PMSG_SUSPEND);
 	if (err) {
-		printk(KERN_ERR "device_suspend_noirq failed: %d\n", err);
+		printk(KERN_ERR "dpm_suspend_noirq failed: %d\n", err);
 		goto resume_devices;
 	}
 
@@ -119,10 +119,10 @@ static void do_suspend(void)
 	} else
 		xs_suspend_cancel();
 
-	device_resume_noirq(PMSG_RESUME);
+	dpm_resume_noirq(PMSG_RESUME);
 
 resume_devices:
-	device_resume(PMSG_RESUME);
+	dpm_resume_end(PMSG_RESUME);
 
 	/* Make sure timer events get retriggered on all CPUs */
 	clock_was_set();

commit e39a71ef80877f4e30d808af9acceec80f4d2f7c
Author: Magnus Damm <damm@igel.co.jp>
Date:   Fri May 15 00:53:26 2009 +0200

    PM: Rename device_power_down/up()
    
    Rename the functions performing "_noirq" dev_pm_ops
    operations from device_power_down() and device_power_up()
    to device_suspend_noirq() and device_resume_noirq().
    
    The new function names are chosen to show that the functions
    are responsible for calling the _noirq() versions to finalize
    the suspend/resume operation. The current function names do
    not perform power down/up anymore so the names may be misleading.
    
    Global function renames:
    - device_power_down() -> device_suspend_noirq()
    - device_power_up() -> device_resume_noirq()
    
    Static function renames:
    - suspend_device_noirq() -> __device_suspend_noirq()
    - resume_device_noirq() -> __device_resume_noirq()
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Len Brown <lenb@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index fddc2025dece..d5b327ac4039 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -43,7 +43,7 @@ static int xen_suspend(void *data)
 	if (err) {
 		printk(KERN_ERR "xen_suspend: sysdev_suspend failed: %d\n",
 			err);
-		device_power_up(PMSG_RESUME);
+		device_resume_noirq(PMSG_RESUME);
 		return err;
 	}
 
@@ -69,7 +69,7 @@ static int xen_suspend(void *data)
 	}
 
 	sysdev_resume();
-	device_power_up(PMSG_RESUME);
+	device_resume_noirq(PMSG_RESUME);
 
 	return 0;
 }
@@ -101,9 +101,9 @@ static void do_suspend(void)
 	printk(KERN_DEBUG "suspending xenstore...\n");
 	xs_suspend();
 
-	err = device_power_down(PMSG_SUSPEND);
+	err = device_suspend_noirq(PMSG_SUSPEND);
 	if (err) {
-		printk(KERN_ERR "device_power_down failed: %d\n", err);
+		printk(KERN_ERR "device_suspend_noirq failed: %d\n", err);
 		goto resume_devices;
 	}
 
@@ -119,7 +119,7 @@ static void do_suspend(void)
 	} else
 		xs_suspend_cancel();
 
-	device_power_up(PMSG_RESUME);
+	device_resume_noirq(PMSG_RESUME);
 
 resume_devices:
 	device_resume(PMSG_RESUME);

commit 38f4b8c0da01ae7cd9b93386842ce272d6fde9ab
Merge: a81145402735 8e2c4f2844c0
Author: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
Date:   Tue Apr 7 13:34:16 2009 -0700

    Merge commit 'origin/master' into for-linus/xen/master
    
    * commit 'origin/master': (4825 commits)
      Fix build errors due to CONFIG_BRANCH_TRACER=y
      parport: Use the PCI IRQ if offered
      tty: jsm cleanups
      Adjust path to gpio headers
      KGDB_SERIAL_CONSOLE check for module
      Change KCONFIG name
      tty: Blackin CTS/RTS
      Change hardware flow control from poll to interrupt driven
      Add support for the MAX3100 SPI UART.
      lanana: assign a device name and numbering for MAX3100
      serqt: initial clean up pass for tty side
      tty: Use the generic RS485 ioctl on CRIS
      tty: Correct inline types for tty_driver_kref_get()
      splice: fix deadlock in splicing to file
      nilfs2: support nanosecond timestamp
      nilfs2: introduce secondary super block
      nilfs2: simplify handling of active state of segments
      nilfs2: mark minor flag for checkpoint created by internal operation
      nilfs2: clean up sketch file
      nilfs2: super block operations fix endian bug
      ...
    
    Conflicts:
            arch/x86/include/asm/thread_info.h
            arch/x86/lguest/boot.c
            drivers/xen/manage.c

commit 2ed8d2b3a81bdbb0418301628ccdb008ac9f40b7
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Mar 16 22:34:06 2009 +0100

    PM: Rework handling of interrupts during suspend-resume
    
    Use the functions introduced in by the previous patch,
    suspend_device_irqs(), resume_device_irqs() and check_wakeup_irqs(),
    to rework the handling of interrupts during suspend (hibernation) and
    resume.  Namely, interrupts will only be disabled on the CPU right
    before suspending sysdevs, while device drivers will be prevented
    from receiving interrupts, with the help of the new helper function,
    before their "late" suspend callbacks run (and analogously during
    resume).
    
    In addition, since the device interrups are now disabled before the
    CPU has turned all interrupts off and the CPU will ACK the interrupts
    setting the IRQ_PENDING bit for them, check in sysdev_suspend() if
    any wake-up interrupts are pending and abort suspend if that's the
    case.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 3ccd348d112d..0d61db1e7b49 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -39,12 +39,6 @@ static int xen_suspend(void *data)
 
 	BUG_ON(!irqs_disabled());
 
-	err = device_power_down(PMSG_SUSPEND);
-	if (err) {
-		printk(KERN_ERR "xen_suspend: device_power_down failed: %d\n",
-		       err);
-		return err;
-	}
 	err = sysdev_suspend(PMSG_SUSPEND);
 	if (err) {
 		printk(KERN_ERR "xen_suspend: sysdev_suspend failed: %d\n",
@@ -69,7 +63,6 @@ static int xen_suspend(void *data)
 	xen_mm_unpin_all();
 
 	sysdev_resume();
-	device_power_up(PMSG_RESUME);
 
 	if (!*cancelled) {
 		xen_irq_resume();
@@ -108,6 +101,12 @@ static void do_suspend(void)
 	/* XXX use normal device tree? */
 	xenbus_suspend();
 
+	err = device_power_down(PMSG_SUSPEND);
+	if (err) {
+		printk(KERN_ERR "device_power_down failed: %d\n", err);
+		goto resume_devices;
+	}
+
 	err = stop_machine(xen_suspend, &cancelled, cpumask_of(0));
 	if (err) {
 		printk(KERN_ERR "failed to start xen_suspend: %d\n", err);
@@ -120,6 +119,9 @@ static void do_suspend(void)
 	} else
 		xenbus_suspend_cancel();
 
+	device_power_up(PMSG_RESUME);
+
+resume_devices:
 	device_resume(PMSG_RESUME);
 
 	/* Make sure timer events get retriggered on all CPUs */

commit de5b31bd47de7e6f41be2e271318dbc8f1af354d
Author: Ian Campbell <ian.campbell@citrix.com>
Date:   Mon Feb 9 12:05:50 2009 -0800

    xen: use device model for suspending xenbus devices
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index b703dd2c9f11..5269bb4d2496 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -104,9 +104,8 @@ static void do_suspend(void)
 		goto out;
 	}
 
-	printk("suspending xenbus...\n");
-	/* XXX use normal device tree? */
-	xenbus_suspend();
+	printk(KERN_DEBUG "suspending xenstore...\n");
+	xs_suspend();
 
 	err = stop_machine(xen_suspend, &cancelled, cpumask_of(0));
 	if (err) {
@@ -116,9 +115,9 @@ static void do_suspend(void)
 
 	if (!cancelled) {
 		xen_arch_resume();
-		xenbus_resume();
+		xs_resume();
 	} else
-		xenbus_suspend_cancel();
+		xs_suspend_cancel();
 
 	device_resume(PMSG_RESUME);
 

commit 1e6fcf840e11ceff8a656a678c6e4b0560a98e08
Author: Ian Campbell <Ian.Campbell@citrix.com>
Date:   Wed Mar 25 17:46:42 2009 +0000

    xen: resume interrupts before system devices.
    
    Impact: bugfix Xen domain restore
    
    Otherwise the first timer interrupt after resume is missed and we never
    get another.
    
    Signed-off-by: Ian Campbell <ian.campbell@citrix.com>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 3ccd348d112d..b703dd2c9f11 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -68,15 +68,15 @@ static int xen_suspend(void *data)
 	gnttab_resume();
 	xen_mm_unpin_all();
 
-	sysdev_resume();
-	device_power_up(PMSG_RESUME);
-
 	if (!*cancelled) {
 		xen_irq_resume();
 		xen_console_resume();
 		xen_timer_resume();
 	}
 
+	sysdev_resume();
+	device_power_up(PMSG_RESUME);
+
 	return 0;
 }
 

commit fc6fc7f1b1095b92d4834e69b385b91e412a7ce5
Merge: ef1f87aa7ba6 770824bdc421
Author: Ingo Molnar <mingo@elte.hu>
Date:   Sun Feb 22 20:05:19 2009 +0100

    Merge branch 'linus' into x86/apic
    
    Conflicts:
            arch/x86/mach-default/setup.c
    
    Semantic conflict resolution:
            arch/x86/kernel/setup.c
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

commit 770824bdc421ff58a64db608294323571c949f4c
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Feb 22 18:38:50 2009 +0100

    PM: Split up sysdev_[suspend|resume] from device_power_[down|up]
    
    Move the sysdev_suspend/resume from the callee to the callers, with
    no real change in semantics, so that we can rework the disabling of
    interrupts during suspend/hibernation.
    
    This is based on an earlier patch from Linus.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 9b91617b9582..56892a142ee2 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -45,6 +45,13 @@ static int xen_suspend(void *data)
 		       err);
 		return err;
 	}
+	err = sysdev_suspend(PMSG_SUSPEND);
+	if (err) {
+		printk(KERN_ERR "xen_suspend: sysdev_suspend failed: %d\n",
+			err);
+		device_power_up(PMSG_RESUME);
+		return err;
+	}
 
 	xen_mm_pin_all();
 	gnttab_suspend();
@@ -61,6 +68,7 @@ static int xen_suspend(void *data)
 	gnttab_resume();
 	xen_mm_unpin_all();
 
+	sysdev_resume();
 	device_power_up(PMSG_RESUME);
 
 	if (!*cancelled) {

commit f7df8ed164996cd2c6aca9674388be6ef78d8b37
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Sat Jan 10 21:58:09 2009 -0800

    cpumask: convert misc driver functions
    
    Impact: use new cpumask API.
    
    Convert misc driver functions to use struct cpumask.
    
    To Do:
      - Convert iucv_buffer_cpumask to cpumask_var_t.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Mike Travis <travis@sgi.com>
    Acked-by: Dean Nelson <dcn@sgi.com>
    Cc: Robert Richter <robert.richter@amd.com>
    Cc: oprofile-list@lists.sf.net
    Cc: Jeremy Fitzhardinge <jeremy@xensource.com>
    Cc: Chris Wright <chrisw@sous-sol.org>
    Cc: virtualization@lists.osdl.org
    Cc: xen-devel@lists.xensource.com
    Cc: Ursula Braun <ursula.braun@de.ibm.com>
    Cc: linux390@de.ibm.com
    Cc: linux-s390@vger.kernel.org

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 9b91617b9582..e7e83b65c18f 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -100,7 +100,7 @@ static void do_suspend(void)
 	/* XXX use normal device tree? */
 	xenbus_suspend();
 
-	err = stop_machine(xen_suspend, &cancelled, &cpumask_of_cpu(0));
+	err = stop_machine(xen_suspend, &cancelled, cpumask_of(0));
 	if (err) {
 		printk(KERN_ERR "failed to start xen_suspend: %d\n", err);
 		goto out;

commit ed6e5e507e4752c3fb1090d0601f46e7a78c860e
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Tue Oct 14 17:50:40 2008 -0700

    xen: don't reload cr3 on suspend
    
    It isn't necessary, and it makes the code needlessly non-portable.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Cc: Isaku Yamahata <yamahata@valinux.co.jp>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index d0e87cbe157c..9b91617b9582 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -39,8 +39,6 @@ static int xen_suspend(void *data)
 
 	BUG_ON(!irqs_disabled());
 
-	load_cr3(swapper_pg_dir);
-
 	err = device_power_down(PMSG_SUSPEND);
 	if (err) {
 		printk(KERN_ERR "xen_suspend: device_power_down failed: %d\n",

commit 37a7c0f3e3e808b8d24f2187a25d2de39e46d822
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Tue Aug 26 00:19:26 2008 -0500

    stop_machine: wean Xen off stop_machine_run
    
    This is the last use of (the deprecated) stop_machine_run in the tree.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Acked-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index a5bc91ae6ff6..d0e87cbe157c 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -102,7 +102,7 @@ static void do_suspend(void)
 	/* XXX use normal device tree? */
 	xenbus_suspend();
 
-	err = stop_machine_run(xen_suspend, &cancelled, 0);
+	err = stop_machine(xen_suspend, &cancelled, &cpumask_of_cpu(0));
 	if (err) {
 		printk(KERN_ERR "failed to start xen_suspend: %d\n", err);
 		goto out;

commit 55ca089e2579de90f048aca2a3030b8b2f864813
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu Jul 17 13:09:24 2008 +1000

    linux-next: pci tree build failure
    
    Today's linux-next build (x86_64 allmodconfig) failed like this:
    
     drivers/xen/manage.c: In function 'xen_suspend':
     drivers/xen/manage.c:66: error: too few arguments to function 'device_power_up'
     drivers/xen/manage.c: In function 'do_suspend':
     drivers/xen/manage.c:117: error: too few arguments to function 'device_resume'
    
    Caused by commit 1eede070a59e1cc73da51e1aaa00d9ab86572cfc ("Introduce new
    top level suspend and hibernation callbacks") interacting with new
    usages ...
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Jeremy Fitzhardinge <jeremy@goop.org>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Jesse Barnes <jbarnes@virtuousgeek.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 2bb268e4ac56..a5bc91ae6ff6 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -63,7 +63,7 @@ static int xen_suspend(void *data)
 	gnttab_resume();
 	xen_mm_unpin_all();
 
-	device_power_up();
+	device_power_up(PMSG_RESUME);
 
 	if (!*cancelled) {
 		xen_irq_resume();
@@ -114,7 +114,7 @@ static void do_suspend(void)
 	} else
 		xenbus_suspend_cancel();
 
-	device_resume();
+	device_resume(PMSG_RESUME);
 
 	/* Make sure timer events get retriggered on all CPUs */
 	clock_was_set();

commit ad55db9fed6d6cd09333045945cb03ba2c070085
Author: Isaku Yamahata <yamahata@valinux.co.jp>
Date:   Tue Jul 8 15:06:32 2008 -0700

    xen: add xen_arch_resume()/xen_timer_resume hook for ia64 support
    
    add xen_timer_resume() hook.
    
    Timer resume should be done after event channel is resumed.
    add xen_arch_resume() hook when ipi becomes usable after resume.
    After resume, some cpu specific resource must be reinitialized
    on ia64 that can't be set by another cpu.
    
    However available hooks is run once on only one cpu so that ipi has
    to be used.
    
    During stop_machine_run() ipi can't be used because interrupt is masked.
    So add another hook after stop_machine_run().
    Another approach might be use resume hook which is run by
    device_resume(). However device_resume() may be executed on
    suspend error recovery path.
    
    So it is necessary to determine whether it is executed on real resume path
    or error recovery path.
    
    Signed-off-by: Isaku Yamahata <yamahata@valinux.co.jp>
    Cc: Stephen Tweedie <sct@redhat.com>
    Cc: Eduardo Habkost <ehabkost@redhat.com>
    Cc: Mark McLoughlin <markmc@redhat.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 5b546e365f00..2bb268e4ac56 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -68,6 +68,7 @@ static int xen_suspend(void *data)
 	if (!*cancelled) {
 		xen_irq_resume();
 		xen_console_resume();
+		xen_timer_resume();
 	}
 
 	return 0;
@@ -107,9 +108,10 @@ static void do_suspend(void)
 		goto out;
 	}
 
-	if (!cancelled)
+	if (!cancelled) {
+		xen_arch_resume();
 		xenbus_resume();
-	else
+	} else
 		xenbus_suspend_cancel();
 
 	device_resume();

commit c78277288e3d561d55fb48bc0fe8d6e2cf4d0880
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Thu May 29 09:02:19 2008 +0100

    CONFIG_PM_SLEEP fix: xen: fix compilation when CONFIG_PM_SLEEP is disabled
    
    Xen save/restore depends on CONFIG_PM_SLEEP being set for device_power_up/down.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Acked-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index 675c3dd23962..5b546e365f00 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -31,6 +31,7 @@ enum shutdown_state {
 /* Ignore multiple shutdown requests. */
 static enum shutdown_state shutting_down = SHUTDOWN_INVALID;
 
+#ifdef CONFIG_PM_SLEEP
 static int xen_suspend(void *data)
 {
 	int *cancelled = data;
@@ -121,6 +122,7 @@ static void do_suspend(void)
 #endif
 	shutting_down = SHUTDOWN_INVALID;
 }
+#endif	/* CONFIG_PM_SLEEP */
 
 static void shutdown_handler(struct xenbus_watch *watch,
 			     const char **vec, unsigned int len)

commit 359cdd3f866b6219a6729e313faf2221397f3278
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Mon May 26 23:31:28 2008 +0100

    xen: maintain clock offset over save/restore
    
    Hook into the device model to make sure that timekeeping's resume handler
    is called.  This deals with our clocksource's non-monotonicity over the
    save/restore.  Explicitly call clock_has_changed() to make sure that
    all the timers get retriggered properly.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index ba85fa2cff33..675c3dd23962 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -34,14 +34,21 @@ static enum shutdown_state shutting_down = SHUTDOWN_INVALID;
 static int xen_suspend(void *data)
 {
 	int *cancelled = data;
+	int err;
 
 	BUG_ON(!irqs_disabled());
 
 	load_cr3(swapper_pg_dir);
 
+	err = device_power_down(PMSG_SUSPEND);
+	if (err) {
+		printk(KERN_ERR "xen_suspend: device_power_down failed: %d\n",
+		       err);
+		return err;
+	}
+
 	xen_mm_pin_all();
 	gnttab_suspend();
-	xen_time_suspend();
 	xen_pre_suspend();
 
 	/*
@@ -52,10 +59,11 @@ static int xen_suspend(void *data)
 	*cancelled = HYPERVISOR_suspend(virt_to_mfn(xen_start_info));
 
 	xen_post_suspend(*cancelled);
-	xen_time_resume();
 	gnttab_resume();
 	xen_mm_unpin_all();
 
+	device_power_up();
+
 	if (!*cancelled) {
 		xen_irq_resume();
 		xen_console_resume();
@@ -105,7 +113,8 @@ static void do_suspend(void)
 
 	device_resume();
 
-
+	/* Make sure timer events get retriggered on all CPUs */
+	clock_was_set();
 out:
 #ifdef CONFIG_PREEMPT
 	thaw_processes();

commit 0e91398f2a5d4eb6b07df8115917d0d1cf3e9b58
Author: Jeremy Fitzhardinge <jeremy@goop.org>
Date:   Mon May 26 23:31:27 2008 +0100

    xen: implement save/restore
    
    This patch implements Xen save/restore and migration.
    
    Saving is triggered via xenbus, which is polled in
    drivers/xen/manage.c.  When a suspend request comes in, the kernel
    prepares itself for saving by:
    
    1 - Freeze all processes.  This is primarily to prevent any
        partially-completed pagetable updates from confusing the suspend
        process.  If CONFIG_PREEMPT isn't defined, then this isn't necessary.
    
    2 - Suspend xenbus and other devices
    
    3 - Stop_machine, to make sure all the other vcpus are quiescent.  The
        Xen tools require the domain to run its save off vcpu0.
    
    4 - Within the stop_machine state, it pins any unpinned pgds (under
        construction or destruction), performs canonicalizes various other
        pieces of state (mostly converting mfns to pfns), and finally
    
    5 - Suspend the domain
    
    Restore reverses the steps used to save the domain, ending when all
    the frozen processes are thawed.
    
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
index aa7af9e6abc0..ba85fa2cff33 100644
--- a/drivers/xen/manage.c
+++ b/drivers/xen/manage.c
@@ -5,21 +5,113 @@
 #include <linux/err.h>
 #include <linux/reboot.h>
 #include <linux/sysrq.h>
+#include <linux/stop_machine.h>
+#include <linux/freezer.h>
 
 #include <xen/xenbus.h>
-
-#define SHUTDOWN_INVALID  -1
-#define SHUTDOWN_POWEROFF  0
-#define SHUTDOWN_SUSPEND   2
-/* Code 3 is SHUTDOWN_CRASH, which we don't use because the domain can only
- * report a crash, not be instructed to crash!
- * HALT is the same as POWEROFF, as far as we're concerned.  The tools use
- * the distinction when we return the reason code to them.
- */
-#define SHUTDOWN_HALT      4
+#include <xen/grant_table.h>
+#include <xen/events.h>
+#include <xen/hvc-console.h>
+#include <xen/xen-ops.h>
+
+#include <asm/xen/hypercall.h>
+#include <asm/xen/page.h>
+
+enum shutdown_state {
+	SHUTDOWN_INVALID = -1,
+	SHUTDOWN_POWEROFF = 0,
+	SHUTDOWN_SUSPEND = 2,
+	/* Code 3 is SHUTDOWN_CRASH, which we don't use because the domain can only
+	   report a crash, not be instructed to crash!
+	   HALT is the same as POWEROFF, as far as we're concerned.  The tools use
+	   the distinction when we return the reason code to them.  */
+	 SHUTDOWN_HALT = 4,
+};
 
 /* Ignore multiple shutdown requests. */
-static int shutting_down = SHUTDOWN_INVALID;
+static enum shutdown_state shutting_down = SHUTDOWN_INVALID;
+
+static int xen_suspend(void *data)
+{
+	int *cancelled = data;
+
+	BUG_ON(!irqs_disabled());
+
+	load_cr3(swapper_pg_dir);
+
+	xen_mm_pin_all();
+	gnttab_suspend();
+	xen_time_suspend();
+	xen_pre_suspend();
+
+	/*
+	 * This hypercall returns 1 if suspend was cancelled
+	 * or the domain was merely checkpointed, and 0 if it
+	 * is resuming in a new domain.
+	 */
+	*cancelled = HYPERVISOR_suspend(virt_to_mfn(xen_start_info));
+
+	xen_post_suspend(*cancelled);
+	xen_time_resume();
+	gnttab_resume();
+	xen_mm_unpin_all();
+
+	if (!*cancelled) {
+		xen_irq_resume();
+		xen_console_resume();
+	}
+
+	return 0;
+}
+
+static void do_suspend(void)
+{
+	int err;
+	int cancelled = 1;
+
+	shutting_down = SHUTDOWN_SUSPEND;
+
+#ifdef CONFIG_PREEMPT
+	/* If the kernel is preemptible, we need to freeze all the processes
+	   to prevent them from being in the middle of a pagetable update
+	   during suspend. */
+	err = freeze_processes();
+	if (err) {
+		printk(KERN_ERR "xen suspend: freeze failed %d\n", err);
+		return;
+	}
+#endif
+
+	err = device_suspend(PMSG_SUSPEND);
+	if (err) {
+		printk(KERN_ERR "xen suspend: device_suspend %d\n", err);
+		goto out;
+	}
+
+	printk("suspending xenbus...\n");
+	/* XXX use normal device tree? */
+	xenbus_suspend();
+
+	err = stop_machine_run(xen_suspend, &cancelled, 0);
+	if (err) {
+		printk(KERN_ERR "failed to start xen_suspend: %d\n", err);
+		goto out;
+	}
+
+	if (!cancelled)
+		xenbus_resume();
+	else
+		xenbus_suspend_cancel();
+
+	device_resume();
+
+
+out:
+#ifdef CONFIG_PREEMPT
+	thaw_processes();
+#endif
+	shutting_down = SHUTDOWN_INVALID;
+}
 
 static void shutdown_handler(struct xenbus_watch *watch,
 			     const char **vec, unsigned int len)
@@ -52,11 +144,17 @@ static void shutdown_handler(struct xenbus_watch *watch,
 	}
 
 	if (strcmp(str, "poweroff") == 0 ||
-	    strcmp(str, "halt") == 0)
+	    strcmp(str, "halt") == 0) {
+		shutting_down = SHUTDOWN_POWEROFF;
 		orderly_poweroff(false);
-	else if (strcmp(str, "reboot") == 0)
+	} else if (strcmp(str, "reboot") == 0) {
+		shutting_down = SHUTDOWN_POWEROFF; /* ? */
 		ctrl_alt_del();
-	else {
+#ifdef CONFIG_PM_SLEEP
+	} else if (strcmp(str, "suspend") == 0) {
+		do_suspend();
+#endif
+	} else {
 		printk(KERN_INFO "Ignoring shutdown request: %s\n", str);
 		shutting_down = SHUTDOWN_INVALID;
 	}

commit ec9b2065d4d3b797604c09a569083dd9ff951b1b
Author: Isaku Yamahata <yamahata@valinux.co.jp>
Date:   Mon May 26 23:31:13 2008 +0100

    xen: Move manage.c to drivers/xen for ia64/xen support
    
    move arch/x86/xen/manage.c under drivers/xen/to share codes
    with x86 and ia64.
    ia64/xen also uses manage.c
    
    Signed-off-by: Isaku Yamahata <yamahata@valinux.co.jp>
    Signed-off-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c
new file mode 100644
index 000000000000..aa7af9e6abc0
--- /dev/null
+++ b/drivers/xen/manage.c
@@ -0,0 +1,143 @@
+/*
+ * Handle extern requests for shutdown, reboot and sysrq
+ */
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/reboot.h>
+#include <linux/sysrq.h>
+
+#include <xen/xenbus.h>
+
+#define SHUTDOWN_INVALID  -1
+#define SHUTDOWN_POWEROFF  0
+#define SHUTDOWN_SUSPEND   2
+/* Code 3 is SHUTDOWN_CRASH, which we don't use because the domain can only
+ * report a crash, not be instructed to crash!
+ * HALT is the same as POWEROFF, as far as we're concerned.  The tools use
+ * the distinction when we return the reason code to them.
+ */
+#define SHUTDOWN_HALT      4
+
+/* Ignore multiple shutdown requests. */
+static int shutting_down = SHUTDOWN_INVALID;
+
+static void shutdown_handler(struct xenbus_watch *watch,
+			     const char **vec, unsigned int len)
+{
+	char *str;
+	struct xenbus_transaction xbt;
+	int err;
+
+	if (shutting_down != SHUTDOWN_INVALID)
+		return;
+
+ again:
+	err = xenbus_transaction_start(&xbt);
+	if (err)
+		return;
+
+	str = (char *)xenbus_read(xbt, "control", "shutdown", NULL);
+	/* Ignore read errors and empty reads. */
+	if (XENBUS_IS_ERR_READ(str)) {
+		xenbus_transaction_end(xbt, 1);
+		return;
+	}
+
+	xenbus_write(xbt, "control", "shutdown", "");
+
+	err = xenbus_transaction_end(xbt, 0);
+	if (err == -EAGAIN) {
+		kfree(str);
+		goto again;
+	}
+
+	if (strcmp(str, "poweroff") == 0 ||
+	    strcmp(str, "halt") == 0)
+		orderly_poweroff(false);
+	else if (strcmp(str, "reboot") == 0)
+		ctrl_alt_del();
+	else {
+		printk(KERN_INFO "Ignoring shutdown request: %s\n", str);
+		shutting_down = SHUTDOWN_INVALID;
+	}
+
+	kfree(str);
+}
+
+static void sysrq_handler(struct xenbus_watch *watch, const char **vec,
+			  unsigned int len)
+{
+	char sysrq_key = '\0';
+	struct xenbus_transaction xbt;
+	int err;
+
+ again:
+	err = xenbus_transaction_start(&xbt);
+	if (err)
+		return;
+	if (!xenbus_scanf(xbt, "control", "sysrq", "%c", &sysrq_key)) {
+		printk(KERN_ERR "Unable to read sysrq code in "
+		       "control/sysrq\n");
+		xenbus_transaction_end(xbt, 1);
+		return;
+	}
+
+	if (sysrq_key != '\0')
+		xenbus_printf(xbt, "control", "sysrq", "%c", '\0');
+
+	err = xenbus_transaction_end(xbt, 0);
+	if (err == -EAGAIN)
+		goto again;
+
+	if (sysrq_key != '\0')
+		handle_sysrq(sysrq_key, NULL);
+}
+
+static struct xenbus_watch shutdown_watch = {
+	.node = "control/shutdown",
+	.callback = shutdown_handler
+};
+
+static struct xenbus_watch sysrq_watch = {
+	.node = "control/sysrq",
+	.callback = sysrq_handler
+};
+
+static int setup_shutdown_watcher(void)
+{
+	int err;
+
+	err = register_xenbus_watch(&shutdown_watch);
+	if (err) {
+		printk(KERN_ERR "Failed to set shutdown watcher\n");
+		return err;
+	}
+
+	err = register_xenbus_watch(&sysrq_watch);
+	if (err) {
+		printk(KERN_ERR "Failed to set sysrq watcher\n");
+		return err;
+	}
+
+	return 0;
+}
+
+static int shutdown_event(struct notifier_block *notifier,
+			  unsigned long event,
+			  void *data)
+{
+	setup_shutdown_watcher();
+	return NOTIFY_DONE;
+}
+
+static int __init setup_shutdown_event(void)
+{
+	static struct notifier_block xenstore_notifier = {
+		.notifier_call = shutdown_event
+	};
+	register_xenstore_notifier(&xenstore_notifier);
+
+	return 0;
+}
+
+subsys_initcall(setup_shutdown_event);
