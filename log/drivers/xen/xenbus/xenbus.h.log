commit c534374ecf044384ddd24474b91fd0d31e720464
Author: Paul Durrant <pdurrant@amazon.com>
Date:   Wed Dec 11 15:29:53 2019 +0000

    xenbus: move xenbus_dev_shutdown() into frontend code...
    
    ...and make it static
    
    xenbus_dev_shutdown() is seemingly intended to cause clean shutdown of PV
    frontends when a guest is rebooted. Indeed the function waits for a
    conpletion which is only set by a call to xenbus_frontend_closed().
    
    This patch removes the shutdown() method from backends and moves
    xenbus_dev_shutdown() from xenbus_probe.c into xenbus_probe_frontend.c,
    renaming it appropriately and making it static.
    
    NOTE: In the case where the backend is running in a driver domain, the
          toolstack should have already terminated any frontends that may be
          using it (since Xen does not support re-startable PV driver domains)
          so xenbus_dev_shutdown() should never be called.
    
    Signed-off-by: Paul Durrant <pdurrant@amazon.com>
    Reviewed-by: Juergen Gross <jgross@suse.com>
    Signed-off-by: Juergen Gross <jgross@suse.com>

diff --git a/drivers/xen/xenbus/xenbus.h b/drivers/xen/xenbus/xenbus.h
index d75a2385b37c..5f5b8a7d5b80 100644
--- a/drivers/xen/xenbus/xenbus.h
+++ b/drivers/xen/xenbus/xenbus.h
@@ -116,8 +116,6 @@ int xenbus_probe_devices(struct xen_bus_type *bus);
 
 void xenbus_dev_changed(const char *node, struct xen_bus_type *bus);
 
-void xenbus_dev_shutdown(struct device *_dev);
-
 int xenbus_dev_suspend(struct device *dev);
 int xenbus_dev_resume(struct device *dev);
 int xenbus_dev_cancel(struct device *dev);

commit d10e0cc113c9e1b64b5c6e3db37b5c839794f3df
Author: Ross Lagerwall <ross.lagerwall@citrix.com>
Date:   Mon May 13 14:56:35 2019 +0100

    xenbus: Avoid deadlock during suspend due to open transactions
    
    During a suspend/resume, the xenwatch thread waits for all outstanding
    xenstore requests and transactions to complete. This does not work
    correctly for transactions started by userspace because it waits for
    them to complete after freezing userspace threads which means the
    transactions have no way of completing, resulting in a deadlock. This is
    trivial to reproduce by running this script and then suspending the VM:
    
        import pyxs, time
        c = pyxs.client.Client(xen_bus_path="/dev/xen/xenbus")
        c.connect()
        c.transaction()
        time.sleep(3600)
    
    Even if this deadlock were resolved, misbehaving userspace should not
    prevent a VM from being migrated. So, instead of waiting for these
    transactions to complete before suspending, store the current generation
    id for each transaction when it is started. The global generation id is
    incremented during resume. If the caller commits the transaction and the
    generation id does not match the current generation id, return EAGAIN so
    that they try again. If the transaction was instead discarded, return OK
    since no changes were made anyway.
    
    This only affects users of the xenbus file interface. In-kernel users of
    xenbus are assumed to be well-behaved and complete all transactions
    before freezing.
    
    Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
    Reviewed-by: Juergen Gross <jgross@suse.com>
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/drivers/xen/xenbus/xenbus.h b/drivers/xen/xenbus/xenbus.h
index 092981171df1..d75a2385b37c 100644
--- a/drivers/xen/xenbus/xenbus.h
+++ b/drivers/xen/xenbus/xenbus.h
@@ -83,6 +83,7 @@ struct xb_req_data {
 	int num_vecs;
 	int err;
 	enum xb_req_state state;
+	bool user_req;
 	void (*cb)(struct xb_req_data *);
 	void *par;
 };
@@ -133,4 +134,6 @@ void xenbus_ring_ops_init(void);
 int xenbus_dev_request_and_reply(struct xsd_sockmsg *msg, void *par);
 void xenbus_dev_queue_reply(struct xb_req_data *req);
 
+extern unsigned int xb_dev_generation_id;
+
 #endif

commit 29fee6eed2811ff1089b30fc579a2d19d78016ab
Author: Joao Martins <joao.m.martins@oracle.com>
Date:   Fri Feb 2 17:42:33 2018 +0000

    xenbus: track caller request id
    
    Commit fd8aa9095a95 ("xen: optimize xenbus driver for multiple concurrent
    xenstore accesses") optimized xenbus concurrent accesses but in doing so
    broke UABI of /dev/xen/xenbus. Through /dev/xen/xenbus applications are in
    charge of xenbus message exchange with the correct header and body. Now,
    after the mentioned commit the replies received by application will no
    longer have the header req_id echoed back as it was on request (see
    specification below for reference), because that particular field is being
    overwritten by kernel.
    
    struct xsd_sockmsg
    {
      uint32_t type;  /* XS_??? */
      uint32_t req_id;/* Request identifier, echoed in daemon's response.  */
      uint32_t tx_id; /* Transaction id (0 if not related to a transaction). */
      uint32_t len;   /* Length of data following this. */
    
      /* Generally followed by nul-terminated string(s). */
    };
    
    Before there was only one request at a time so req_id could simply be
    forwarded back and forth. To allow simultaneous requests we need a
    different req_id for each message thus kernel keeps a monotonic increasing
    counter for this field and is written on every request irrespective of
    userspace value.
    
    Forwarding again the req_id on userspace requests is not a solution because
    we would open the possibility of userspace-generated req_id colliding with
    kernel ones. So this patch instead takes another route which is to
    artificially keep user req_id while keeping the xenbus logic as is. We do
    that by saving the original req_id before xs_send(), use the private kernel
    counter as req_id and then once reply comes and was validated, we restore
    back the original req_id.
    
    Cc: <stable@vger.kernel.org> # 4.11
    Fixes: fd8aa9095a ("xen: optimize xenbus driver for multiple concurrent xenstore accesses")
    Reported-by: Bhavesh Davda <bhavesh.davda@oracle.com>
    Signed-off-by: Joao Martins <joao.m.martins@oracle.com>
    Reviewed-by: Juergen Gross <jgross@suse.com>
    Signed-off-by: Juergen Gross <jgross@suse.com>

diff --git a/drivers/xen/xenbus/xenbus.h b/drivers/xen/xenbus/xenbus.h
index 149c5e7efc89..092981171df1 100644
--- a/drivers/xen/xenbus/xenbus.h
+++ b/drivers/xen/xenbus/xenbus.h
@@ -76,6 +76,7 @@ struct xb_req_data {
 	struct list_head list;
 	wait_queue_head_t wq;
 	struct xsd_sockmsg msg;
+	uint32_t caller_req_id;
 	enum xsd_sockmsg_type type;
 	char *body;
 	const struct kvec *vec;

commit fd8aa9095a95c02dcc35540a263267c29b8fda9d
Author: Juergen Gross <jgross@suse.com>
Date:   Thu Feb 9 14:39:58 2017 +0100

    xen: optimize xenbus driver for multiple concurrent xenstore accesses
    
    Handling of multiple concurrent Xenstore accesses through xenbus driver
    either from the kernel or user land is rather lame today: xenbus is
    capable to have one access active only at one point of time.
    
    Rewrite xenbus to handle multiple requests concurrently by making use
    of the request id of the Xenstore protocol. This requires to:
    
    - Instead of blocking inside xb_read() when trying to read data from
      the xenstore ring buffer do so only in the main loop of
      xenbus_thread().
    
    - Instead of doing writes to the xenstore ring buffer in the context of
      the caller just queue the request and do the write in the dedicated
      xenbus thread.
    
    - Instead of just forwarding the request id specified by the caller of
      xenbus to xenstore use a xenbus internal unique request id. This will
      allow multiple outstanding requests.
    
    - Modify the locking scheme in order to allow multiple requests being
      active in parallel.
    
    - Instead of waiting for the reply of a user's xenstore request after
      writing the request to the xenstore ring buffer return directly to
      the caller and do the waiting in the read path.
    
    Additionally signal handling was optimized by avoiding waking up the
    xenbus thread or sending an event to Xenstore in case the addressed
    entity is known to be running already.
    
    As a result communication with Xenstore is sped up by a factor of up
    to 5: depending on the request type (read or write) and the amount of
    data transferred the gain was at least 20% (small reads) and went up to
    a factor of 5 for large writes.
    
    In the end some more rough edges of xenbus have been smoothed:
    
    - Handling of memory shortage when reading from xenstore ring buffer in
      the xenbus driver was not optimal: it was busy looping and issuing a
      warning in each loop.
    
    - In case of xenstore not running in dom0 but in a stubdom we end up
      with two xenbus threads running as the initialization of xenbus in
      dom0 expecting a local xenstored will be redone later when connecting
      to the xenstore domain. Up to now this was no problem as locking
      would prevent the two xenbus threads interfering with each other, but
      this was just a waste of kernel resources.
    
    - An out of memory situation while writing to or reading from the
      xenstore ring buffer no longer will lead to a possible loss of
      synchronization with xenstore.
    
    - The user read and write part are now interruptible by signals.
    
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/drivers/xen/xenbus/xenbus.h b/drivers/xen/xenbus/xenbus.h
index 51995276f549..149c5e7efc89 100644
--- a/drivers/xen/xenbus/xenbus.h
+++ b/drivers/xen/xenbus/xenbus.h
@@ -32,6 +32,10 @@
 #ifndef _XENBUS_XENBUS_H
 #define _XENBUS_XENBUS_H
 
+#include <linux/mutex.h>
+#include <linux/uio.h>
+#include <xen/xenbus.h>
+
 #define XEN_BUS_ID_SIZE			20
 
 struct xen_bus_type {
@@ -52,16 +56,49 @@ enum xenstore_init {
 	XS_LOCAL,
 };
 
+struct xs_watch_event {
+	struct list_head list;
+	unsigned int len;
+	struct xenbus_watch *handle;
+	const char *path;
+	const char *token;
+	char body[];
+};
+
+enum xb_req_state {
+	xb_req_state_queued,
+	xb_req_state_wait_reply,
+	xb_req_state_got_reply,
+	xb_req_state_aborted
+};
+
+struct xb_req_data {
+	struct list_head list;
+	wait_queue_head_t wq;
+	struct xsd_sockmsg msg;
+	enum xsd_sockmsg_type type;
+	char *body;
+	const struct kvec *vec;
+	int num_vecs;
+	int err;
+	enum xb_req_state state;
+	void (*cb)(struct xb_req_data *);
+	void *par;
+};
+
 extern enum xenstore_init xen_store_domain_type;
 extern const struct attribute_group *xenbus_dev_groups[];
+extern struct mutex xs_response_mutex;
+extern struct list_head xs_reply_list;
+extern struct list_head xb_write_list;
+extern wait_queue_head_t xb_waitq;
+extern struct mutex xb_write_mutex;
 
 int xs_init(void);
 int xb_init_comms(void);
 void xb_deinit_comms(void);
-int xb_write(const void *data, unsigned int len);
-int xb_read(void *data, unsigned int len);
-int xb_data_to_read(void);
-int xb_wait_for_data_to_read(void);
+int xs_watch_msg(struct xs_watch_event *event);
+void xs_request_exit(struct xb_req_data *req);
 
 int xenbus_match(struct device *_dev, struct device_driver *_drv);
 int xenbus_dev_probe(struct device *_dev);
@@ -92,6 +129,7 @@ int xenbus_read_otherend_details(struct xenbus_device *xendev,
 
 void xenbus_ring_ops_init(void);
 
-void *xenbus_dev_request_and_reply(struct xsd_sockmsg *msg);
+int xenbus_dev_request_and_reply(struct xsd_sockmsg *msg, void *par);
+void xenbus_dev_queue_reply(struct xb_req_data *req);
 
 #endif

commit 5584ea250ae44f929feb4c7bd3877d1c5edbf813
Author: Juergen Gross <jgross@suse.com>
Date:   Thu Feb 9 14:39:57 2017 +0100

    xen: modify xenstore watch event interface
    
    Today a Xenstore watch event is delivered via a callback function
    declared as:
    
    void (*callback)(struct xenbus_watch *,
                     const char **vec, unsigned int len);
    
    As all watch events only ever come with two parameters (path and token)
    changing the prototype to:
    
    void (*callback)(struct xenbus_watch *,
                     const char *path, const char *token);
    
    is the natural thing to do.
    
    Apply this change and adapt all users.
    
    Cc: konrad.wilk@oracle.com
    Cc: roger.pau@citrix.com
    Cc: wei.liu2@citrix.com
    Cc: paul.durrant@citrix.com
    Cc: netdev@vger.kernel.org
    
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Reviewed-by: Paul Durrant <paul.durrant@citrix.com>
    Reviewed-by: Wei Liu <wei.liu2@citrix.com>
    Reviewed-by: Roger Pau Monn√© <roger.pau@citrix.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/drivers/xen/xenbus/xenbus.h b/drivers/xen/xenbus/xenbus.h
index a6b007dfdaa8..51995276f549 100644
--- a/drivers/xen/xenbus/xenbus.h
+++ b/drivers/xen/xenbus/xenbus.h
@@ -40,8 +40,8 @@ struct xen_bus_type {
 	int (*get_bus_id)(char bus_id[XEN_BUS_ID_SIZE], const char *nodename);
 	int (*probe)(struct xen_bus_type *bus, const char *type,
 		     const char *dir);
-	void (*otherend_changed)(struct xenbus_watch *watch, const char **vec,
-				 unsigned int len);
+	void (*otherend_changed)(struct xenbus_watch *watch, const char *path,
+				 const char *token);
 	struct bus_type bus;
 };
 
@@ -84,7 +84,7 @@ int xenbus_dev_resume(struct device *dev);
 int xenbus_dev_cancel(struct device *dev);
 
 void xenbus_otherend_changed(struct xenbus_watch *watch,
-			     const char **vec, unsigned int len,
+			     const char *path, const char *token,
 			     int ignore_on_shutdown);
 
 int xenbus_read_otherend_details(struct xenbus_device *xendev,

commit 332f791dc98d98116f4473b726f67c9321b0f31e
Author: Juergen Gross <jgross@suse.com>
Date:   Thu Feb 9 14:39:56 2017 +0100

    xen: clean up xenbus internal headers
    
    The xenbus driver has an awful mixture of internally and globally
    visible headers: some of the internally used only stuff is defined in
    the global header include/xen/xenbus.h while some stuff defined in
    internal headers is used by other drivers, too.
    
    Clean this up by moving the externally used symbols to
    include/xen/xenbus.h and the symbols used internally only to a new
    header drivers/xen/xenbus/xenbus.h replacing xenbus_comms.h and
    xenbus_probe.h
    
    Signed-off-by: Juergen Gross <jgross@suse.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/drivers/xen/xenbus/xenbus.h b/drivers/xen/xenbus/xenbus.h
new file mode 100644
index 000000000000..a6b007dfdaa8
--- /dev/null
+++ b/drivers/xen/xenbus/xenbus.h
@@ -0,0 +1,97 @@
+/*
+ * Private include for xenbus communications.
+ *
+ * Copyright (C) 2005 Rusty Russell, IBM Corporation
+ * Copyright (C) 2005 XenSource Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation; or, when distributed
+ * separately from the Linux kernel or incorporated into other
+ * software packages, subject to the following license:
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this source file (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef _XENBUS_XENBUS_H
+#define _XENBUS_XENBUS_H
+
+#define XEN_BUS_ID_SIZE			20
+
+struct xen_bus_type {
+	char *root;
+	unsigned int levels;
+	int (*get_bus_id)(char bus_id[XEN_BUS_ID_SIZE], const char *nodename);
+	int (*probe)(struct xen_bus_type *bus, const char *type,
+		     const char *dir);
+	void (*otherend_changed)(struct xenbus_watch *watch, const char **vec,
+				 unsigned int len);
+	struct bus_type bus;
+};
+
+enum xenstore_init {
+	XS_UNKNOWN,
+	XS_PV,
+	XS_HVM,
+	XS_LOCAL,
+};
+
+extern enum xenstore_init xen_store_domain_type;
+extern const struct attribute_group *xenbus_dev_groups[];
+
+int xs_init(void);
+int xb_init_comms(void);
+void xb_deinit_comms(void);
+int xb_write(const void *data, unsigned int len);
+int xb_read(void *data, unsigned int len);
+int xb_data_to_read(void);
+int xb_wait_for_data_to_read(void);
+
+int xenbus_match(struct device *_dev, struct device_driver *_drv);
+int xenbus_dev_probe(struct device *_dev);
+int xenbus_dev_remove(struct device *_dev);
+int xenbus_register_driver_common(struct xenbus_driver *drv,
+				  struct xen_bus_type *bus,
+				  struct module *owner,
+				  const char *mod_name);
+int xenbus_probe_node(struct xen_bus_type *bus,
+		      const char *type,
+		      const char *nodename);
+int xenbus_probe_devices(struct xen_bus_type *bus);
+
+void xenbus_dev_changed(const char *node, struct xen_bus_type *bus);
+
+void xenbus_dev_shutdown(struct device *_dev);
+
+int xenbus_dev_suspend(struct device *dev);
+int xenbus_dev_resume(struct device *dev);
+int xenbus_dev_cancel(struct device *dev);
+
+void xenbus_otherend_changed(struct xenbus_watch *watch,
+			     const char **vec, unsigned int len,
+			     int ignore_on_shutdown);
+
+int xenbus_read_otherend_details(struct xenbus_device *xendev,
+				 char *id_node, char *path_node);
+
+void xenbus_ring_ops_init(void);
+
+void *xenbus_dev_request_and_reply(struct xsd_sockmsg *msg);
+
+#endif
