commit 0148a635ce40d65653bfda469fae8e4b8360baf3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Feb 1 10:07:32 2018 -0500

    xen: fix poll misannotation
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/xen/pvcalls-front.h b/drivers/xen/pvcalls-front.h
index 3332978f4fcd..f694ad77379f 100644
--- a/drivers/xen/pvcalls-front.h
+++ b/drivers/xen/pvcalls-front.h
@@ -20,7 +20,7 @@ int pvcalls_front_recvmsg(struct socket *sock,
 			  struct msghdr *msg,
 			  size_t len,
 			  int flags);
-unsigned int pvcalls_front_poll(struct file *file,
+__poll_t pvcalls_front_poll(struct file *file,
 				struct socket *sock,
 				poll_table *wait);
 int pvcalls_front_release(struct socket *sock);

commit 235a71c5390316429e2c7823119c5ea439816beb
Author: Stefano Stabellini <sstabellini@kernel.org>
Date:   Mon Oct 30 15:41:02 2017 -0700

    xen/pvcalls: implement release command
    
    Send PVCALLS_RELEASE to the backend and wait for a reply. Take both
    in_mutex and out_mutex to avoid concurrent accesses. Then, free the
    socket.
    
    For passive sockets, check whether we have already pre-allocated an
    active socket for the purpose of being accepted. If so, free that as
    well.
    
    Signed-off-by: Stefano Stabellini <stefano@aporeto.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    CC: boris.ostrovsky@oracle.com
    CC: jgross@suse.com
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/drivers/xen/pvcalls-front.h b/drivers/xen/pvcalls-front.h
index 25e05b8f2d72..3332978f4fcd 100644
--- a/drivers/xen/pvcalls-front.h
+++ b/drivers/xen/pvcalls-front.h
@@ -23,5 +23,6 @@ int pvcalls_front_recvmsg(struct socket *sock,
 unsigned int pvcalls_front_poll(struct file *file,
 				struct socket *sock,
 				poll_table *wait);
+int pvcalls_front_release(struct socket *sock);
 
 #endif

commit 5842c83596fcfa742978ec2840440ab56c7fdf79
Author: Stefano Stabellini <sstabellini@kernel.org>
Date:   Mon Oct 30 15:41:01 2017 -0700

    xen/pvcalls: implement poll command
    
    For active sockets, check the indexes and use the inflight_conn_req
    waitqueue to wait.
    
    For passive sockets if an accept is outstanding
    (PVCALLS_FLAG_ACCEPT_INFLIGHT), check if it has been answered by looking
    at bedata->rsp[req_id]. If so, return POLLIN.  Otherwise use the
    inflight_accept_req waitqueue.
    
    If no accepts are inflight, send PVCALLS_POLL to the backend. If we have
    outstanding POLL requests awaiting for a response use the inflight_req
    waitqueue: inflight_req is awaken when a new response is received; on
    wakeup we check whether the POLL response is arrived by looking at the
    PVCALLS_FLAG_POLL_RET flag. We set the flag from
    pvcalls_front_event_handler, if the response was for a POLL command.
    
    In pvcalls_front_event_handler, get the struct sock_mapping from the
    poll id (we previously converted struct sock_mapping* to uintptr_t and
    used it as id).
    
    Signed-off-by: Stefano Stabellini <stefano@aporeto.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    CC: boris.ostrovsky@oracle.com
    CC: jgross@suse.com
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/drivers/xen/pvcalls-front.h b/drivers/xen/pvcalls-front.h
index de24041e9a86..25e05b8f2d72 100644
--- a/drivers/xen/pvcalls-front.h
+++ b/drivers/xen/pvcalls-front.h
@@ -20,5 +20,8 @@ int pvcalls_front_recvmsg(struct socket *sock,
 			  struct msghdr *msg,
 			  size_t len,
 			  int flags);
+unsigned int pvcalls_front_poll(struct file *file,
+				struct socket *sock,
+				poll_table *wait);
 
 #endif

commit ae0d04052e077ccb71772bf5c7cb1049f4d587d2
Author: Stefano Stabellini <sstabellini@kernel.org>
Date:   Mon Oct 30 15:41:00 2017 -0700

    xen/pvcalls: implement recvmsg
    
    Implement recvmsg by copying data from the "in" ring. If not enough data
    is available and the recvmsg call is blocking, then wait on the
    inflight_conn_req waitqueue. Take the active socket in_mutex so that
    only one function can access the ring at any given time.
    
    Signed-off-by: Stefano Stabellini <stefano@aporeto.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    CC: boris.ostrovsky@oracle.com
    CC: jgross@suse.com
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/drivers/xen/pvcalls-front.h b/drivers/xen/pvcalls-front.h
index d937c24c90c3..de24041e9a86 100644
--- a/drivers/xen/pvcalls-front.h
+++ b/drivers/xen/pvcalls-front.h
@@ -16,5 +16,9 @@ int pvcalls_front_accept(struct socket *sock,
 int pvcalls_front_sendmsg(struct socket *sock,
 			  struct msghdr *msg,
 			  size_t len);
+int pvcalls_front_recvmsg(struct socket *sock,
+			  struct msghdr *msg,
+			  size_t len,
+			  int flags);
 
 #endif

commit 45ddce214a797de65c0418bebf90c1b564c3ee3d
Author: Stefano Stabellini <sstabellini@kernel.org>
Date:   Mon Oct 30 15:40:59 2017 -0700

    xen/pvcalls: implement sendmsg
    
    Send data to an active socket by copying data to the "out" ring. Take
    the active socket out_mutex so that only one function can access the
    ring at any given time.
    
    If not enough room is available on the ring, rather than returning
    immediately or sleep-waiting, spin for up to 5000 cycles. This small
    optimization turns out to improve performance significantly.
    
    Signed-off-by: Stefano Stabellini <stefano@aporeto.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    CC: boris.ostrovsky@oracle.com
    CC: jgross@suse.com
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/drivers/xen/pvcalls-front.h b/drivers/xen/pvcalls-front.h
index ab4f1dad3142..d937c24c90c3 100644
--- a/drivers/xen/pvcalls-front.h
+++ b/drivers/xen/pvcalls-front.h
@@ -13,5 +13,8 @@ int pvcalls_front_listen(struct socket *sock, int backlog);
 int pvcalls_front_accept(struct socket *sock,
 			 struct socket *newsock,
 			 int flags);
+int pvcalls_front_sendmsg(struct socket *sock,
+			  struct msghdr *msg,
+			  size_t len);
 
 #endif

commit 9774c6cca26610d065a75d2ac8c5e3fcf0a209b3
Author: Stefano Stabellini <sstabellini@kernel.org>
Date:   Mon Oct 30 15:40:58 2017 -0700

    xen/pvcalls: implement accept command
    
    Introduce a waitqueue to allow only one outstanding accept command at
    any given time and to implement polling on the passive socket. Introduce
    a flags field to keep track of in-flight accept and poll commands.
    
    Send PVCALLS_ACCEPT to the backend. Allocate a new active socket. Make
    sure that only one accept command is executed at any given time by
    setting PVCALLS_FLAG_ACCEPT_INFLIGHT and waiting on the
    inflight_accept_req waitqueue.
    
    Convert the new struct sock_mapping pointer into an uintptr_t and use it
    as id for the new socket to pass to the backend.
    
    Check if the accept call is non-blocking: in that case after sending the
    ACCEPT command to the backend store the sock_mapping pointer of the new
    struct and the inflight req_id then return -EAGAIN (which will respond
    only when there is something to accept). Next time accept is called,
    we'll check if the ACCEPT command has been answered, if so we'll pick up
    where we left off, otherwise we return -EAGAIN again.
    
    Note that, differently from the other commands, we can use
    wait_event_interruptible (instead of wait_event) in the case of accept
    as we are able to track the req_id of the ACCEPT response that we are
    waiting.
    
    Signed-off-by: Stefano Stabellini <stefano@aporeto.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    CC: boris.ostrovsky@oracle.com
    CC: jgross@suse.com
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/drivers/xen/pvcalls-front.h b/drivers/xen/pvcalls-front.h
index aa8fe1007da5..ab4f1dad3142 100644
--- a/drivers/xen/pvcalls-front.h
+++ b/drivers/xen/pvcalls-front.h
@@ -10,5 +10,8 @@ int pvcalls_front_bind(struct socket *sock,
 		       struct sockaddr *addr,
 		       int addr_len);
 int pvcalls_front_listen(struct socket *sock, int backlog);
+int pvcalls_front_accept(struct socket *sock,
+			 struct socket *newsock,
+			 int flags);
 
 #endif

commit 1853f11d72ed46310ff3c5a60264b2f8a53f8c25
Author: Stefano Stabellini <sstabellini@kernel.org>
Date:   Mon Oct 30 15:40:57 2017 -0700

    xen/pvcalls: implement listen command
    
    Send PVCALLS_LISTEN to the backend.
    
    Signed-off-by: Stefano Stabellini <stefano@aporeto.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    CC: boris.ostrovsky@oracle.com
    CC: jgross@suse.com
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/drivers/xen/pvcalls-front.h b/drivers/xen/pvcalls-front.h
index 8b0a2749d4b8..aa8fe1007da5 100644
--- a/drivers/xen/pvcalls-front.h
+++ b/drivers/xen/pvcalls-front.h
@@ -9,5 +9,6 @@ int pvcalls_front_connect(struct socket *sock, struct sockaddr *addr,
 int pvcalls_front_bind(struct socket *sock,
 		       struct sockaddr *addr,
 		       int addr_len);
+int pvcalls_front_listen(struct socket *sock, int backlog);
 
 #endif

commit 67ea9893cbc2f892f491ec620d6bbab262b80770
Author: Stefano Stabellini <sstabellini@kernel.org>
Date:   Mon Oct 30 15:40:56 2017 -0700

    xen/pvcalls: implement bind command
    
    Send PVCALLS_BIND to the backend. Introduce a new structure, part of
    struct sock_mapping, to store information specific to passive sockets.
    
    Introduce a status field to keep track of the status of the passive
    socket.
    
    Signed-off-by: Stefano Stabellini <stefano@aporeto.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    CC: boris.ostrovsky@oracle.com
    CC: jgross@suse.com
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/drivers/xen/pvcalls-front.h b/drivers/xen/pvcalls-front.h
index 63b0417c31d3..8b0a2749d4b8 100644
--- a/drivers/xen/pvcalls-front.h
+++ b/drivers/xen/pvcalls-front.h
@@ -6,5 +6,8 @@
 int pvcalls_front_socket(struct socket *sock);
 int pvcalls_front_connect(struct socket *sock, struct sockaddr *addr,
 			  int addr_len, int flags);
+int pvcalls_front_bind(struct socket *sock,
+		       struct sockaddr *addr,
+		       int addr_len);
 
 #endif

commit cb1c7d9bbc878a67af270ccd2d23f6d1450579db
Author: Stefano Stabellini <sstabellini@kernel.org>
Date:   Mon Oct 30 15:40:55 2017 -0700

    xen/pvcalls: implement connect command
    
    Send PVCALLS_CONNECT to the backend. Allocate a new ring and evtchn for
    the active socket.
    
    Introduce fields in struct sock_mapping to keep track of active sockets.
    Introduce a waitqueue to allow the frontend to wait on data coming from
    the backend on the active socket (recvmsg command).
    
    Two mutexes (one of reads and one for writes) will be used to protect
    the active socket in and out rings from concurrent accesses.
    
    Signed-off-by: Stefano Stabellini <stefano@aporeto.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    CC: boris.ostrovsky@oracle.com
    CC: jgross@suse.com
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/drivers/xen/pvcalls-front.h b/drivers/xen/pvcalls-front.h
index b7dabedf5ccb..63b0417c31d3 100644
--- a/drivers/xen/pvcalls-front.h
+++ b/drivers/xen/pvcalls-front.h
@@ -4,5 +4,7 @@
 #include <linux/net.h>
 
 int pvcalls_front_socket(struct socket *sock);
+int pvcalls_front_connect(struct socket *sock, struct sockaddr *addr,
+			  int addr_len, int flags);
 
 #endif

commit 2195046bfd69e487d9a76dc47840f15c8412840c
Author: Stefano Stabellini <sstabellini@kernel.org>
Date:   Mon Oct 30 15:40:54 2017 -0700

    xen/pvcalls: implement socket command and handle events
    
    Send a PVCALLS_SOCKET command to the backend, use the masked
    req_prod_pvt as req_id. This way, req_id is guaranteed to be between 0
    and PVCALLS_NR_REQ_PER_RING. We already have a slot in the rsp array
    ready for the response, and there cannot be two outstanding responses
    with the same req_id.
    
    Wait for the response by waiting on the inflight_req waitqueue and
    check for the req_id field in rsp[req_id]. Use atomic accesses and
    barriers to read the field. Note that the barriers are simple smp
    barriers (as opposed to virt barriers) because they are for internal
    frontend synchronization, not frontend<->backend communication.
    
    Once a response is received, clear the corresponding rsp slot by setting
    req_id to PVCALLS_INVALID_ID. Note that PVCALLS_INVALID_ID is invalid
    only from the frontend point of view. It is not part of the PVCalls
    protocol.
    
    pvcalls_front_event_handler is in charge of copying responses from the
    ring to the appropriate rsp slot. It is done by copying the body of the
    response first, then by copying req_id atomically. After the copies,
    wake up anybody waiting on waitqueue.
    
    socket_lock protects accesses to the ring.
    
    Convert the pointer to sock_mapping into an uintptr_t and use it as
    id for the new socket to pass to the backend. The struct will be fully
    initialized later on connect or bind.
    
    sock->sk->sk_send_head is not used for ip sockets: reuse the field to
    store a pointer to the struct sock_mapping corresponding to the socket.
    This way, we can easily get the struct sock_mapping from the struct
    socket.
    
    Signed-off-by: Stefano Stabellini <stefano@aporeto.com>
    Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    CC: boris.ostrovsky@oracle.com
    CC: jgross@suse.com
    Signed-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>

diff --git a/drivers/xen/pvcalls-front.h b/drivers/xen/pvcalls-front.h
new file mode 100644
index 000000000000..b7dabedf5ccb
--- /dev/null
+++ b/drivers/xen/pvcalls-front.h
@@ -0,0 +1,8 @@
+#ifndef __PVCALLS_FRONT_H__
+#define __PVCALLS_FRONT_H__
+
+#include <linux/net.h>
+
+int pvcalls_front_socket(struct socket *sock);
+
+#endif
