commit 41760d0e0f1a013e607956eaf22a60ff6dd03784
Author: Kees Cook <keescook@chromium.org>
Date:   Sat Oct 21 12:09:17 2017 -0700

    drivers/pcmcia: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: David Howells <dhowells@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-pcmcia@lists.infradead.org
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk> # for soc_common.c

diff --git a/drivers/pcmcia/bcm63xx_pcmcia.c b/drivers/pcmcia/bcm63xx_pcmcia.c
index 0802e0bc7d0c..16f573173471 100644
--- a/drivers/pcmcia/bcm63xx_pcmcia.c
+++ b/drivers/pcmcia/bcm63xx_pcmcia.c
@@ -263,12 +263,12 @@ static int bcm63xx_pcmcia_get_status(struct pcmcia_socket *sock,
 /*
  * socket polling timer callback
  */
-static void bcm63xx_pcmcia_poll(unsigned long data)
+static void bcm63xx_pcmcia_poll(struct timer_list *t)
 {
 	struct bcm63xx_pcmcia_socket *skt;
 	unsigned int stat, events;
 
-	skt = (struct bcm63xx_pcmcia_socket *)data;
+	skt = from_timer(skt, t, timer);
 
 	spin_lock_bh(&skt->lock);
 
@@ -392,7 +392,7 @@ static int bcm63xx_drv_pcmcia_probe(struct platform_device *pdev)
 	sock->map_size = resource_size(skt->common_res);
 
 	/* initialize polling timer */
-	setup_timer(&skt->timer, bcm63xx_pcmcia_poll, (unsigned long)skt);
+	timer_setup(&skt->timer, bcm63xx_pcmcia_poll, 0);
 
 	/* initialize  pcmcia  control register,  drive  VS[12] to  0,
 	 * leave CB IDSEL to the old  value since it is set by the PCI

commit 0178a7a54d408d2c5b7bbe7eee9450bffbec0989
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jul 18 16:58:07 2014 -0700

    pcmcia: remove DEFINE_PCI_DEVICE_TABLE usage
    
    It's not needed, just use the "real" structure definition instead.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/bcm63xx_pcmcia.c b/drivers/pcmcia/bcm63xx_pcmcia.c
index 0c6aac1232fc..0802e0bc7d0c 100644
--- a/drivers/pcmcia/bcm63xx_pcmcia.c
+++ b/drivers/pcmcia/bcm63xx_pcmcia.c
@@ -475,7 +475,7 @@ static void bcm63xx_cb_exit(struct pci_dev *dev)
 	bcm63xx_cb_dev = NULL;
 }
 
-static DEFINE_PCI_DEVICE_TABLE(bcm63xx_cb_table) = {
+static const struct pci_device_id bcm63xx_cb_table[] = {
 	{
 		.vendor		= PCI_VENDOR_ID_BROADCOM,
 		.device		= BCM6348_CPU_ID,

commit e765a02cb64bfef53f290122ca0897ef329a4e76
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:05 2012 -0500

    pcmcia: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/bcm63xx_pcmcia.c b/drivers/pcmcia/bcm63xx_pcmcia.c
index 7d2167995821..0c6aac1232fc 100644
--- a/drivers/pcmcia/bcm63xx_pcmcia.c
+++ b/drivers/pcmcia/bcm63xx_pcmcia.c
@@ -436,7 +436,7 @@ static int bcm63xx_drv_pcmcia_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int __devexit bcm63xx_drv_pcmcia_remove(struct platform_device *pdev)
+static int bcm63xx_drv_pcmcia_remove(struct platform_device *pdev)
 {
 	struct bcm63xx_pcmcia_socket *skt;
 	struct resource *res;
@@ -469,7 +469,7 @@ static int bcm63xx_cb_probe(struct pci_dev *dev,
 	return platform_driver_register(&bcm63xx_pcmcia_driver);
 }
 
-static void __devexit bcm63xx_cb_exit(struct pci_dev *dev)
+static void bcm63xx_cb_exit(struct pci_dev *dev)
 {
 	platform_driver_unregister(&bcm63xx_pcmcia_driver);
 	bcm63xx_cb_dev = NULL;

commit 34cdf25a126f053698d549cc12a9c30e9a8a0bab
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:23:12 2012 -0500

    pcmcia: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Acked-by: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/bcm63xx_pcmcia.c b/drivers/pcmcia/bcm63xx_pcmcia.c
index 57d1053d5bfa..7d2167995821 100644
--- a/drivers/pcmcia/bcm63xx_pcmcia.c
+++ b/drivers/pcmcia/bcm63xx_pcmcia.c
@@ -323,7 +323,7 @@ static struct pccard_operations bcm63xx_pcmcia_operations = {
 /*
  * register pcmcia socket to core
  */
-static int __devinit bcm63xx_drv_pcmcia_probe(struct platform_device *pdev)
+static int bcm63xx_drv_pcmcia_probe(struct platform_device *pdev)
 {
 	struct bcm63xx_pcmcia_socket *skt;
 	struct pcmcia_socket *sock;
@@ -461,7 +461,7 @@ struct platform_driver bcm63xx_pcmcia_driver = {
 };
 
 #ifdef CONFIG_CARDBUS
-static int __devinit bcm63xx_cb_probe(struct pci_dev *dev,
+static int bcm63xx_cb_probe(struct pci_dev *dev,
 				      const struct pci_device_id *id)
 {
 	/* keep pci device */

commit 96364e3a5cf1416c158a276134d9a4fc861548c2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:20:38 2012 -0500

    pcmcia: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/bcm63xx_pcmcia.c b/drivers/pcmcia/bcm63xx_pcmcia.c
index c2e997a570bf..57d1053d5bfa 100644
--- a/drivers/pcmcia/bcm63xx_pcmcia.c
+++ b/drivers/pcmcia/bcm63xx_pcmcia.c
@@ -453,7 +453,7 @@ static int __devexit bcm63xx_drv_pcmcia_remove(struct platform_device *pdev)
 
 struct platform_driver bcm63xx_pcmcia_driver = {
 	.probe	= bcm63xx_drv_pcmcia_probe,
-	.remove	= __devexit_p(bcm63xx_drv_pcmcia_remove),
+	.remove	= bcm63xx_drv_pcmcia_remove,
 	.driver	= {
 		.name	= "bcm63xx_pcmcia",
 		.owner  = THIS_MODULE,
@@ -503,7 +503,7 @@ static struct pci_driver bcm63xx_cardbus_driver = {
 	.name		= "bcm63xx_cardbus",
 	.id_table	= bcm63xx_cb_table,
 	.probe		= bcm63xx_cb_probe,
-	.remove		= __devexit_p(bcm63xx_cb_exit),
+	.remove		= bcm63xx_cb_exit,
 };
 #endif
 

commit 2b2c5d8c1dff8ed42d6d841f56428c0ce2bd71b5
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Dec 27 16:17:46 2011 +0800

    pcmcia: Convert to DEFINE_PCI_DEVICE_TABLE
    
    Convert static struct pci_device_id *[] to static DEFINE_PCI_DEVICE_TABLE
    tables. Also convert to use PCI_DEVICE macro for better readablity.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/bcm63xx_pcmcia.c b/drivers/pcmcia/bcm63xx_pcmcia.c
index 693577e0fefc..c2e997a570bf 100644
--- a/drivers/pcmcia/bcm63xx_pcmcia.c
+++ b/drivers/pcmcia/bcm63xx_pcmcia.c
@@ -475,7 +475,7 @@ static void __devexit bcm63xx_cb_exit(struct pci_dev *dev)
 	bcm63xx_cb_dev = NULL;
 }
 
-static struct pci_device_id bcm63xx_cb_table[] = {
+static DEFINE_PCI_DEVICE_TABLE(bcm63xx_cb_table) = {
 	{
 		.vendor		= PCI_VENDOR_ID_BROADCOM,
 		.device		= BCM6348_CPU_ID,

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/pcmcia/bcm63xx_pcmcia.c b/drivers/pcmcia/bcm63xx_pcmcia.c
index bc88a3b19bb3..693577e0fefc 100644
--- a/drivers/pcmcia/bcm63xx_pcmcia.c
+++ b/drivers/pcmcia/bcm63xx_pcmcia.c
@@ -11,6 +11,7 @@
 #include <linux/ioport.h>
 #include <linux/timer.h>
 #include <linux/platform_device.h>
+#include <linux/slab.h>
 #include <linux/delay.h>
 #include <linux/pci.h>
 #include <linux/gpio.h>

commit 553d6d5f5b84f11fad8043688137dac96df1a06d
Author: Maxime Bizon <mbizon@freebox.fr>
Date:   Mon Sep 28 14:49:43 2009 +0200

    MIPS: BCM63xx: Add PCMCIA & Cardbus support.
    
    Signed-off-by: Maxime Bizon <mbizon@freebox.fr>
    Reviewed-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/drivers/pcmcia/bcm63xx_pcmcia.c b/drivers/pcmcia/bcm63xx_pcmcia.c
new file mode 100644
index 000000000000..bc88a3b19bb3
--- /dev/null
+++ b/drivers/pcmcia/bcm63xx_pcmcia.c
@@ -0,0 +1,536 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2008 Maxime Bizon <mbizon@freebox.fr>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/timer.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/gpio.h>
+
+#include <bcm63xx_regs.h>
+#include <bcm63xx_io.h>
+#include "bcm63xx_pcmcia.h"
+
+#define PFX	"bcm63xx_pcmcia: "
+
+#ifdef CONFIG_CARDBUS
+/* if cardbus is used, platform device needs reference to actual pci
+ * device */
+static struct pci_dev *bcm63xx_cb_dev;
+#endif
+
+/*
+ * read/write helper for pcmcia regs
+ */
+static inline u32 pcmcia_readl(struct bcm63xx_pcmcia_socket *skt, u32 off)
+{
+	return bcm_readl(skt->base + off);
+}
+
+static inline void pcmcia_writel(struct bcm63xx_pcmcia_socket *skt,
+				 u32 val, u32 off)
+{
+	bcm_writel(val, skt->base + off);
+}
+
+/*
+ * This callback should (re-)initialise the socket, turn on status
+ * interrupts and PCMCIA bus, and wait for power to stabilise so that
+ * the card status signals report correctly.
+ *
+ * Hardware cannot do that.
+ */
+static int bcm63xx_pcmcia_sock_init(struct pcmcia_socket *sock)
+{
+	return 0;
+}
+
+/*
+ * This callback should remove power on the socket, disable IRQs from
+ * the card, turn off status interrupts, and disable the PCMCIA bus.
+ *
+ * Hardware cannot do that.
+ */
+static int bcm63xx_pcmcia_suspend(struct pcmcia_socket *sock)
+{
+	return 0;
+}
+
+/*
+ * Implements the set_socket() operation for the in-kernel PCMCIA
+ * service (formerly SS_SetSocket in Card Services). We more or
+ * less punt all of this work and let the kernel handle the details
+ * of power configuration, reset, &c. We also record the value of
+ * `state' in order to regurgitate it to the PCMCIA core later.
+ */
+static int bcm63xx_pcmcia_set_socket(struct pcmcia_socket *sock,
+				     socket_state_t *state)
+{
+	struct bcm63xx_pcmcia_socket *skt;
+	unsigned long flags;
+	u32 val;
+
+	skt = sock->driver_data;
+
+	spin_lock_irqsave(&skt->lock, flags);
+
+	/* note: hardware cannot control socket power, so we will
+	 * always report SS_POWERON */
+
+	/* apply socket reset */
+	val = pcmcia_readl(skt, PCMCIA_C1_REG);
+	if (state->flags & SS_RESET)
+		val |= PCMCIA_C1_RESET_MASK;
+	else
+		val &= ~PCMCIA_C1_RESET_MASK;
+
+	/* reverse reset logic for cardbus card */
+	if (skt->card_detected && (skt->card_type & CARD_CARDBUS))
+		val ^= PCMCIA_C1_RESET_MASK;
+
+	pcmcia_writel(skt, val, PCMCIA_C1_REG);
+
+	/* keep requested state for event reporting */
+	skt->requested_state = *state;
+
+	spin_unlock_irqrestore(&skt->lock, flags);
+
+	return 0;
+}
+
+/*
+ * identity cardtype from VS[12] input, CD[12] input while only VS2 is
+ * floating, and CD[12] input while only VS1 is floating
+ */
+enum {
+	IN_VS1 = (1 << 0),
+	IN_VS2 = (1 << 1),
+	IN_CD1_VS2H = (1 << 2),
+	IN_CD2_VS2H = (1 << 3),
+	IN_CD1_VS1H = (1 << 4),
+	IN_CD2_VS1H = (1 << 5),
+};
+
+static const u8 vscd_to_cardtype[] = {
+
+	/* VS1 float, VS2 float */
+	[IN_VS1 | IN_VS2] = (CARD_PCCARD | CARD_5V),
+
+	/* VS1 grounded, VS2 float */
+	[IN_VS2] = (CARD_PCCARD | CARD_5V | CARD_3V),
+
+	/* VS1 grounded, VS2 grounded */
+	[0] = (CARD_PCCARD | CARD_5V | CARD_3V | CARD_XV),
+
+	/* VS1 tied to CD1, VS2 float */
+	[IN_VS1 | IN_VS2 | IN_CD1_VS1H] = (CARD_CARDBUS | CARD_3V),
+
+	/* VS1 grounded, VS2 tied to CD2 */
+	[IN_VS2 | IN_CD2_VS2H] = (CARD_CARDBUS | CARD_3V | CARD_XV),
+
+	/* VS1 tied to CD2, VS2 grounded */
+	[IN_VS1 | IN_CD2_VS1H] = (CARD_CARDBUS | CARD_3V | CARD_XV | CARD_YV),
+
+	/* VS1 float, VS2 grounded */
+	[IN_VS1] = (CARD_PCCARD | CARD_XV),
+
+	/* VS1 float, VS2 tied to CD2 */
+	[IN_VS1 | IN_VS2 | IN_CD2_VS2H] = (CARD_CARDBUS | CARD_3V),
+
+	/* VS1 float, VS2 tied to CD1 */
+	[IN_VS1 | IN_VS2 | IN_CD1_VS2H] = (CARD_CARDBUS | CARD_XV | CARD_YV),
+
+	/* VS1 tied to CD2, VS2 float */
+	[IN_VS1 | IN_VS2 | IN_CD2_VS1H] = (CARD_CARDBUS | CARD_YV),
+
+	/* VS2 grounded, VS1 is tied to CD1, CD2 is grounded */
+	[IN_VS1 | IN_CD1_VS1H] = 0, /* ignore cardbay */
+};
+
+/*
+ * poll hardware to check card insertion status
+ */
+static unsigned int __get_socket_status(struct bcm63xx_pcmcia_socket *skt)
+{
+	unsigned int stat;
+	u32 val;
+
+	stat = 0;
+
+	/* check CD for card presence */
+	val = pcmcia_readl(skt, PCMCIA_C1_REG);
+
+	if (!(val & PCMCIA_C1_CD1_MASK) && !(val & PCMCIA_C1_CD2_MASK))
+		stat |= SS_DETECT;
+
+	/* if new insertion, detect cardtype */
+	if ((stat & SS_DETECT) && !skt->card_detected) {
+		unsigned int stat = 0;
+
+		/* float VS1, float VS2 */
+		val |= PCMCIA_C1_VS1OE_MASK;
+		val |= PCMCIA_C1_VS2OE_MASK;
+		pcmcia_writel(skt, val, PCMCIA_C1_REG);
+
+		/* wait for output to stabilize and read VS[12] */
+		udelay(10);
+		val = pcmcia_readl(skt, PCMCIA_C1_REG);
+		stat |= (val & PCMCIA_C1_VS1_MASK) ? IN_VS1 : 0;
+		stat |= (val & PCMCIA_C1_VS2_MASK) ? IN_VS2 : 0;
+
+		/* drive VS1 low, float VS2 */
+		val &= ~PCMCIA_C1_VS1OE_MASK;
+		val |= PCMCIA_C1_VS2OE_MASK;
+		pcmcia_writel(skt, val, PCMCIA_C1_REG);
+
+		/* wait for output to stabilize and read CD[12] */
+		udelay(10);
+		val = pcmcia_readl(skt, PCMCIA_C1_REG);
+		stat |= (val & PCMCIA_C1_CD1_MASK) ? IN_CD1_VS2H : 0;
+		stat |= (val & PCMCIA_C1_CD2_MASK) ? IN_CD2_VS2H : 0;
+
+		/* float VS1, drive VS2 low */
+		val |= PCMCIA_C1_VS1OE_MASK;
+		val &= ~PCMCIA_C1_VS2OE_MASK;
+		pcmcia_writel(skt, val, PCMCIA_C1_REG);
+
+		/* wait for output to stabilize and read CD[12] */
+		udelay(10);
+		val = pcmcia_readl(skt, PCMCIA_C1_REG);
+		stat |= (val & PCMCIA_C1_CD1_MASK) ? IN_CD1_VS1H : 0;
+		stat |= (val & PCMCIA_C1_CD2_MASK) ? IN_CD2_VS1H : 0;
+
+		/* guess cardtype from all this */
+		skt->card_type = vscd_to_cardtype[stat];
+		if (!skt->card_type)
+			dev_err(&skt->socket.dev, "unsupported card type\n");
+
+		/* drive both VS pin to 0 again */
+		val &= ~(PCMCIA_C1_VS1OE_MASK | PCMCIA_C1_VS2OE_MASK);
+
+		/* enable correct logic */
+		val &= ~(PCMCIA_C1_EN_PCMCIA_MASK | PCMCIA_C1_EN_CARDBUS_MASK);
+		if (skt->card_type & CARD_PCCARD)
+			val |= PCMCIA_C1_EN_PCMCIA_MASK;
+		else
+			val |= PCMCIA_C1_EN_CARDBUS_MASK;
+
+		pcmcia_writel(skt, val, PCMCIA_C1_REG);
+	}
+	skt->card_detected = (stat & SS_DETECT) ? 1 : 0;
+
+	/* report card type/voltage */
+	if (skt->card_type & CARD_CARDBUS)
+		stat |= SS_CARDBUS;
+	if (skt->card_type & CARD_3V)
+		stat |= SS_3VCARD;
+	if (skt->card_type & CARD_XV)
+		stat |= SS_XVCARD;
+	stat |= SS_POWERON;
+
+	if (gpio_get_value(skt->pd->ready_gpio))
+		stat |= SS_READY;
+
+	return stat;
+}
+
+/*
+ * core request to get current socket status
+ */
+static int bcm63xx_pcmcia_get_status(struct pcmcia_socket *sock,
+				     unsigned int *status)
+{
+	struct bcm63xx_pcmcia_socket *skt;
+
+	skt = sock->driver_data;
+
+	spin_lock_bh(&skt->lock);
+	*status = __get_socket_status(skt);
+	spin_unlock_bh(&skt->lock);
+
+	return 0;
+}
+
+/*
+ * socket polling timer callback
+ */
+static void bcm63xx_pcmcia_poll(unsigned long data)
+{
+	struct bcm63xx_pcmcia_socket *skt;
+	unsigned int stat, events;
+
+	skt = (struct bcm63xx_pcmcia_socket *)data;
+
+	spin_lock_bh(&skt->lock);
+
+	stat = __get_socket_status(skt);
+
+	/* keep only changed bits, and mask with required one from the
+	 * core */
+	events = (stat ^ skt->old_status) & skt->requested_state.csc_mask;
+	skt->old_status = stat;
+	spin_unlock_bh(&skt->lock);
+
+	if (events)
+		pcmcia_parse_events(&skt->socket, events);
+
+	mod_timer(&skt->timer,
+		  jiffies + msecs_to_jiffies(BCM63XX_PCMCIA_POLL_RATE));
+}
+
+static int bcm63xx_pcmcia_set_io_map(struct pcmcia_socket *sock,
+				     struct pccard_io_map *map)
+{
+	/* this doesn't seem to be called by pcmcia layer if static
+	 * mapping is used */
+	return 0;
+}
+
+static int bcm63xx_pcmcia_set_mem_map(struct pcmcia_socket *sock,
+				      struct pccard_mem_map *map)
+{
+	struct bcm63xx_pcmcia_socket *skt;
+	struct resource *res;
+
+	skt = sock->driver_data;
+	if (map->flags & MAP_ATTRIB)
+		res = skt->attr_res;
+	else
+		res = skt->common_res;
+
+	map->static_start = res->start + map->card_start;
+	return 0;
+}
+
+static struct pccard_operations bcm63xx_pcmcia_operations = {
+	.init			= bcm63xx_pcmcia_sock_init,
+	.suspend		= bcm63xx_pcmcia_suspend,
+	.get_status		= bcm63xx_pcmcia_get_status,
+	.set_socket		= bcm63xx_pcmcia_set_socket,
+	.set_io_map		= bcm63xx_pcmcia_set_io_map,
+	.set_mem_map		= bcm63xx_pcmcia_set_mem_map,
+};
+
+/*
+ * register pcmcia socket to core
+ */
+static int __devinit bcm63xx_drv_pcmcia_probe(struct platform_device *pdev)
+{
+	struct bcm63xx_pcmcia_socket *skt;
+	struct pcmcia_socket *sock;
+	struct resource *res, *irq_res;
+	unsigned int regmem_size = 0, iomem_size = 0;
+	u32 val;
+	int ret;
+
+	skt = kzalloc(sizeof(*skt), GFP_KERNEL);
+	if (!skt)
+		return -ENOMEM;
+	spin_lock_init(&skt->lock);
+	sock = &skt->socket;
+	sock->driver_data = skt;
+
+	/* make sure we have all resources we need */
+	skt->common_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	skt->attr_res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	skt->pd = pdev->dev.platform_data;
+	if (!skt->common_res || !skt->attr_res || !irq_res || !skt->pd) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	/* remap pcmcia registers */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	regmem_size = resource_size(res);
+	if (!request_mem_region(res->start, regmem_size, "bcm63xx_pcmcia")) {
+		ret = -EINVAL;
+		goto err;
+	}
+	skt->reg_res = res;
+
+	skt->base = ioremap(res->start, regmem_size);
+	if (!skt->base) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	/* remap io registers */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 3);
+	iomem_size = resource_size(res);
+	skt->io_base = ioremap(res->start, iomem_size);
+	if (!skt->io_base) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	/* resources are static */
+	sock->resource_ops = &pccard_static_ops;
+	sock->ops = &bcm63xx_pcmcia_operations;
+	sock->owner = THIS_MODULE;
+	sock->dev.parent = &pdev->dev;
+	sock->features = SS_CAP_STATIC_MAP | SS_CAP_PCCARD;
+	sock->io_offset = (unsigned long)skt->io_base;
+	sock->pci_irq = irq_res->start;
+
+#ifdef CONFIG_CARDBUS
+	sock->cb_dev = bcm63xx_cb_dev;
+	if (bcm63xx_cb_dev)
+		sock->features |= SS_CAP_CARDBUS;
+#endif
+
+	/* assume common & attribute memory have the same size */
+	sock->map_size = resource_size(skt->common_res);
+
+	/* initialize polling timer */
+	setup_timer(&skt->timer, bcm63xx_pcmcia_poll, (unsigned long)skt);
+
+	/* initialize  pcmcia  control register,  drive  VS[12] to  0,
+	 * leave CB IDSEL to the old  value since it is set by the PCI
+	 * layer */
+	val = pcmcia_readl(skt, PCMCIA_C1_REG);
+	val &= PCMCIA_C1_CBIDSEL_MASK;
+	val |= PCMCIA_C1_EN_PCMCIA_GPIO_MASK;
+	pcmcia_writel(skt, val, PCMCIA_C1_REG);
+
+	/*
+	 * Hardware has only one set of timings registers, not one for
+	 * each memory access type, so we configure them for the
+	 * slowest one: attribute memory.
+	 */
+	val = PCMCIA_C2_DATA16_MASK;
+	val |= 10 << PCMCIA_C2_RWCOUNT_SHIFT;
+	val |= 6 << PCMCIA_C2_INACTIVE_SHIFT;
+	val |= 3 << PCMCIA_C2_SETUP_SHIFT;
+	val |= 3 << PCMCIA_C2_HOLD_SHIFT;
+	pcmcia_writel(skt, val, PCMCIA_C2_REG);
+
+	ret = pcmcia_register_socket(sock);
+	if (ret)
+		goto err;
+
+	/* start polling socket */
+	mod_timer(&skt->timer,
+		  jiffies + msecs_to_jiffies(BCM63XX_PCMCIA_POLL_RATE));
+
+	platform_set_drvdata(pdev, skt);
+	return 0;
+
+err:
+	if (skt->io_base)
+		iounmap(skt->io_base);
+	if (skt->base)
+		iounmap(skt->base);
+	if (skt->reg_res)
+		release_mem_region(skt->reg_res->start, regmem_size);
+	kfree(skt);
+	return ret;
+}
+
+static int __devexit bcm63xx_drv_pcmcia_remove(struct platform_device *pdev)
+{
+	struct bcm63xx_pcmcia_socket *skt;
+	struct resource *res;
+
+	skt = platform_get_drvdata(pdev);
+	del_timer_sync(&skt->timer);
+	iounmap(skt->base);
+	iounmap(skt->io_base);
+	res = skt->reg_res;
+	release_mem_region(res->start, resource_size(res));
+	kfree(skt);
+	return 0;
+}
+
+struct platform_driver bcm63xx_pcmcia_driver = {
+	.probe	= bcm63xx_drv_pcmcia_probe,
+	.remove	= __devexit_p(bcm63xx_drv_pcmcia_remove),
+	.driver	= {
+		.name	= "bcm63xx_pcmcia",
+		.owner  = THIS_MODULE,
+	},
+};
+
+#ifdef CONFIG_CARDBUS
+static int __devinit bcm63xx_cb_probe(struct pci_dev *dev,
+				      const struct pci_device_id *id)
+{
+	/* keep pci device */
+	bcm63xx_cb_dev = dev;
+	return platform_driver_register(&bcm63xx_pcmcia_driver);
+}
+
+static void __devexit bcm63xx_cb_exit(struct pci_dev *dev)
+{
+	platform_driver_unregister(&bcm63xx_pcmcia_driver);
+	bcm63xx_cb_dev = NULL;
+}
+
+static struct pci_device_id bcm63xx_cb_table[] = {
+	{
+		.vendor		= PCI_VENDOR_ID_BROADCOM,
+		.device		= BCM6348_CPU_ID,
+		.subvendor	= PCI_VENDOR_ID_BROADCOM,
+		.subdevice	= PCI_ANY_ID,
+		.class		= PCI_CLASS_BRIDGE_CARDBUS << 8,
+		.class_mask	= ~0,
+	},
+
+	{
+		.vendor		= PCI_VENDOR_ID_BROADCOM,
+		.device		= BCM6358_CPU_ID,
+		.subvendor	= PCI_VENDOR_ID_BROADCOM,
+		.subdevice	= PCI_ANY_ID,
+		.class		= PCI_CLASS_BRIDGE_CARDBUS << 8,
+		.class_mask	= ~0,
+	},
+
+	{ },
+};
+
+MODULE_DEVICE_TABLE(pci, bcm63xx_cb_table);
+
+static struct pci_driver bcm63xx_cardbus_driver = {
+	.name		= "bcm63xx_cardbus",
+	.id_table	= bcm63xx_cb_table,
+	.probe		= bcm63xx_cb_probe,
+	.remove		= __devexit_p(bcm63xx_cb_exit),
+};
+#endif
+
+/*
+ * if cardbus support is enabled, register our platform device after
+ * our fake cardbus bridge has been registered
+ */
+static int __init bcm63xx_pcmcia_init(void)
+{
+#ifdef CONFIG_CARDBUS
+	return pci_register_driver(&bcm63xx_cardbus_driver);
+#else
+	return platform_driver_register(&bcm63xx_pcmcia_driver);
+#endif
+}
+
+static void __exit bcm63xx_pcmcia_exit(void)
+{
+#ifdef CONFIG_CARDBUS
+	return pci_unregister_driver(&bcm63xx_cardbus_driver);
+#else
+	platform_driver_unregister(&bcm63xx_pcmcia_driver);
+#endif
+}
+
+module_init(bcm63xx_pcmcia_init);
+module_exit(bcm63xx_pcmcia_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Maxime Bizon <mbizon@freebox.fr>");
+MODULE_DESCRIPTION("Linux PCMCIA Card Services: bcm63xx Socket Controller");
