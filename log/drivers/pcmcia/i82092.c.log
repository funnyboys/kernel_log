commit 71705c611263cad99edf85a5ea021e098cac032b
Author: Simon Geis <simon.geis@fau.de>
Date:   Fri Dec 13 14:53:14 2019 +0100

    PCMCIA/i82092: remove #if 0 block
    
    Remove the unused function indirect_read16, which
    is similar to indirect_read with the exception that
    it reads 16 instead of 8 bit.
    
    Co-developed-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Simon Geis <simon.geis@fau.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 2189f8b0ded4..85887d885b5f 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -200,26 +200,6 @@ static unsigned char indirect_read(int socket, unsigned short reg)
 	return val;
 }
 
-#if 0
-static unsigned short indirect_read16(int socket, unsigned short reg)
-{
-	unsigned short int port;
-	unsigned short tmp;
-	unsigned long flags;
-
-	spin_lock_irqsave(&port_lock, flags);
-	reg  = reg + socket * 0x40;
-	port = sockets[socket].io_base;
-	outb(reg, port);
-	tmp = inb(port+1);
-	reg++;
-	outb(reg, port);
-	tmp = tmp | (inb(port+1)<<8);
-	spin_unlock_irqrestore(&port_lock, flags);
-	return tmp;
-}
-#endif
-
 static void indirect_write(int socket, unsigned short reg, unsigned char value)
 {
 	unsigned short int port;

commit 52739f063f7e991326eecfffa2538e1f425d2580
Author: Simon Geis <simon.geis@fau.de>
Date:   Fri Dec 13 14:53:13 2019 +0100

    PCMCIA/i82092: delete enter/leave macro
    
    Remove the enter/leave macros and the corresponding calls.
    These are obsolete since ftrace is available.
    
    Co-developed-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Simon Geis <simon.geis@fau.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index a80bdb4fee48..2189f8b0ded4 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -76,8 +76,6 @@ static int i82092aa_pci_probe(struct pci_dev *dev,
 	unsigned char configbyte;
 	int i, ret;
 
-	enter("i82092aa_pci_probe");
-
 	ret = pci_enable_device(dev);
 	if (ret)
 		return ret;
@@ -158,7 +156,6 @@ static int i82092aa_pci_probe(struct pci_dev *dev,
 			goto err_out_free_sockets;
 	}
 
-	leave("i82092aa_pci_probe");
 	return 0;
 
 err_out_free_sockets:
@@ -178,14 +175,10 @@ static void i82092aa_pci_remove(struct pci_dev *dev)
 {
 	int i;
 
-	enter("i82092aa_pci_remove");
-
 	free_irq(dev->irq, i82092aa_interrupt);
 
 	for (i = 0; i < socket_count; i++)
 		pcmcia_unregister_socket(&sockets[i].socket);
-
-	leave("i82092aa_pci_remove");
 }
 
 static DEFINE_SPINLOCK(port_lock);
@@ -322,8 +315,6 @@ static irqreturn_t i82092aa_interrupt(int irq, void *dev)
 
 	unsigned int events, active = 0;
 
-/*	enter("i82092aa_interrupt");*/
-
 	while (1) {
 		loopcount++;
 		if (loopcount > 20) {
@@ -377,7 +368,6 @@ static irqreturn_t i82092aa_interrupt(int irq, void *dev)
 			break;
 	}
 	return IRQ_RETVAL(handled);
-/*	leave("i82092aa_interrupt");*/
 }
 
 
@@ -388,8 +378,6 @@ static int card_present(int socketno)
 {
 	unsigned int val;
 
-	enter("card_present");
-
 	if ((socketno < 0) || (socketno >= MAX_SOCKETS))
 		return 0;
 	if (sockets[socketno].io_base == 0)
@@ -397,23 +385,18 @@ static int card_present(int socketno)
 
 
 	val = indirect_read(socketno, 1); /* Interface status register */
-	if ((val&12) == 12) {
-		leave("card_present 1");
+	if ((val&12) == 12)
 		return 1;
-	}
 
-	leave("card_present 0");
 	return 0;
 }
 
 static void set_bridge_state(int sock)
 {
-	enter("set_bridge_state");
 	indirect_write(sock, I365_GBLCTL, 0x00);
 	indirect_write(sock, I365_GENCTL, 0x00);
 
 	indirect_setbit(sock, I365_INTCTL, 0x08);
-	leave("set_bridge_state");
 }
 
 
@@ -424,8 +407,6 @@ static int i82092aa_init(struct pcmcia_socket *sock)
 	pccard_io_map io = { 0, 0, 0, 0, 1 };
 	pccard_mem_map mem = { .res = &res, };
 
-	enter("i82092aa_init");
-
 	for (i = 0; i < 2; i++) {
 		io.map = i;
 		i82092aa_set_io_map(sock, &io);
@@ -434,8 +415,7 @@ static int i82092aa_init(struct pcmcia_socket *sock)
 		mem.map = i;
 		i82092aa_set_mem_map(sock, &mem);
 	}
-	
-	leave("i82092aa_init");
+
 	return 0;
 }
 
@@ -444,8 +424,6 @@ static int i82092aa_get_status(struct pcmcia_socket *socket, u_int *value)
 	unsigned int sock = container_of(socket,
 				struct socket_info, socket)->number;
 	unsigned int status;
-	
-	enter("i82092aa_get_status");
 
 	/* Interface Status Register */
 	status = indirect_read(sock, I365_STATUS);
@@ -477,7 +455,6 @@ static int i82092aa_get_status(struct pcmcia_socket *socket, u_int *value)
 	if (status & I365_CS_POWERON)
 		(*value) |= SS_POWERON;  /* power is applied to the card */
 
-	leave("i82092aa_get_status");
 	return 0;
 }
 
@@ -490,8 +467,6 @@ static int i82092aa_set_socket(struct pcmcia_socket *socket,
 	unsigned int sock = sock_info->number;
 	unsigned char reg;
 
-	enter("i82092aa_set_socket");
-
 	/* First, set the global controller options */
 
 	set_bridge_state(sock);
@@ -535,7 +510,6 @@ static int i82092aa_set_socket(struct pcmcia_socket *socket,
 		dev_err(&sock_info->dev->dev,
 			"%s called with invalid VCC power value: %i",
 			__func__, state->Vcc);
-		leave("i82092aa_set_socket");
 		return -EINVAL;
 	}
 
@@ -557,7 +531,6 @@ static int i82092aa_set_socket(struct pcmcia_socket *socket,
 		dev_err(&sock_info->dev->dev,
 			"%s called with invalid VPP power value: %i",
 			__func__, state->Vcc);
-		leave("i82092aa_set_socket");
 		return -EINVAL;
 	}
 
@@ -589,7 +562,6 @@ static int i82092aa_set_socket(struct pcmcia_socket *socket,
 	indirect_write(sock, I365_CSCINT, reg);
 	(void)indirect_read(sock, I365_CSC);
 
-	leave("i82092aa_set_socket");
 	return 0;
 }
 
@@ -601,20 +573,15 @@ static int i82092aa_set_io_map(struct pcmcia_socket *socket,
 	unsigned int sock = sock_info->number;
 	unsigned char map, ioctl;
 
-	enter("i82092aa_set_io_map");
-
 	map = io->map;
 
 	/* Check error conditions */
-	if (map > 1) {
-		leave("i82092aa_set_io_map with invalid map");
+	if (map > 1)
 		return -EINVAL;
-	}
+
 	if ((io->start > 0xffff) || (io->stop > 0xffff)
-				 || (io->stop < io->start)) {
-		leave("i82092aa_set_io_map with invalid io");
+				 || (io->stop < io->start))
 		return -EINVAL;
-	}
 
 	/* Turn off the window before changing anything */
 	if (indirect_read(sock, I365_ADDRWIN) & I365_ENA_IO(map))
@@ -635,7 +602,6 @@ static int i82092aa_set_io_map(struct pcmcia_socket *socket,
 	if (io->flags & MAP_ACTIVE)
 		indirect_setbit(sock, I365_ADDRWIN, I365_ENA_IO(map));
 
-	leave("i82092aa_set_io_map");
 	return 0;
 }
 
@@ -649,20 +615,14 @@ static int i82092aa_set_mem_map(struct pcmcia_socket *socket,
 	unsigned short base, i;
 	unsigned char map;
 
-	enter("i82092aa_set_mem_map");
-
 	pcibios_resource_to_bus(sock_info->dev->bus, &region, mem->res);
 
 	map = mem->map;
-	if (map > 4) {
-		leave("i82092aa_set_mem_map: invalid map");
+	if (map > 4)
 		return -EINVAL;
-	}
-
 
 	if ((mem->card_start > 0x3ffffff) || (region.start > region.end) ||
 	     (mem->speed > 1000)) {
-		leave("i82092aa_set_mem_map: invalid address / speed");
 		dev_err(&sock_info->dev->dev,
 			"invalid mem map for socket %i: %llx to %llx with a start of %x\n",
 			sock,
@@ -717,7 +677,6 @@ static int i82092aa_set_mem_map(struct pcmcia_socket *socket,
 	if (mem->flags & MAP_ACTIVE)
 		indirect_setbit(sock, I365_ADDRWIN, I365_ENA_MEM(map));
 
-	leave("i82092aa_set_mem_map");
 	return 0;
 }
 
@@ -728,11 +687,9 @@ static int i82092aa_module_init(void)
 
 static void i82092aa_module_exit(void)
 {
-	enter("i82092aa_module_exit");
 	pci_unregister_driver(&i82092aa_pci_driver);
 	if (sockets[0].io_base > 0)
 		release_region(sockets[0].io_base, 2);
-	leave("i82092aa_module_exit");
 }
 
 module_init(i82092aa_module_init);

commit ac5af87725f7f0e14ff99b7d784e652cba9c21b7
Author: Simon Geis <simon.geis@fau.de>
Date:   Fri Dec 13 14:53:12 2019 +0100

    PCMCIA/i82092: include <linux/io.h> instead of <asm/io.h>
    
    Include the more general linux/io.h instead of asm/io.h
    as checkpatch suggests.
    
    Co-developed-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Simon Geis <simon.geis@fau.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 3d2ff208b87b..a80bdb4fee48 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -18,7 +18,7 @@
 
 #include <pcmcia/ss.h>
 
-#include <asm/io.h>
+#include <linux/io.h>
 
 #include "i82092aa.h"
 #include "i82365.h"

commit 152b4bb57aa43f7f6f55abbb75ccbab818ef3892
Author: Simon Geis <simon.geis@fau.de>
Date:   Fri Dec 13 14:53:11 2019 +0100

    PCMCIA/i82092: shorten the lines with over 80 characters
    
    Split the lines with more than 80 characters
    in order to improve readability of the code.
    
    Co-developed-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Simon Geis <simon.geis@fau.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 2d31832fa439..3d2ff208b87b 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -70,7 +70,8 @@ static struct socket_info sockets[MAX_SOCKETS];
 static int socket_count;	/* shortcut */
 
 
-static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
+static int i82092aa_pci_probe(struct pci_dev *dev,
+			      const struct pci_device_id *id)
 {
 	unsigned char configbyte;
 	int i, ret;
@@ -81,7 +82,9 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 	if (ret)
 		return ret;
 
-	pci_read_config_byte(dev, 0x40, &configbyte);  /* PCI Configuration Control */
+	/* PCI Configuration Control */
+	pci_read_config_byte(dev, 0x40, &configbyte);
+
 	switch (configbyte&6) {
 	case 0:
 		socket_count = 2;
@@ -128,9 +131,13 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 		}
 	}
 
-	/* Now, specifiy that all interrupts are to be done as PCI interrupts */
-	configbyte = 0xFF; /* bitmask, one bit per event, 1 = PCI interrupt, 0 = ISA interrupt */
-	pci_write_config_byte(dev, 0x50, configbyte); /* PCI Interrupt Routing Register */
+	/* Now, specifiy that all interrupts are to be done as PCI interrupts
+	 * bitmask, one bit per event, 1 = PCI interrupt, 0 = ISA interrupt
+	 */
+	configbyte = 0xFF;
+
+	/* PCI Interrupt Routing Register */
+	pci_write_config_byte(dev, 0x50, configbyte);
 
 	/* Register the interrupt handler */
 	dev_dbg(&dev->dev, "Requesting interrupt %i\n", dev->irq);
@@ -251,7 +258,8 @@ static void indirect_setbit(int socket, unsigned short reg, unsigned char mask)
 }
 
 
-static void indirect_resetbit(int socket, unsigned short reg, unsigned char mask)
+static void indirect_resetbit(int socket,
+			      unsigned short reg, unsigned char mask)
 {
 	unsigned short int port;
 	unsigned char val;
@@ -268,7 +276,8 @@ static void indirect_resetbit(int socket, unsigned short reg, unsigned char mask
 	spin_unlock_irqrestore(&port_lock, flags);
 }
 
-static void indirect_write16(int socket, unsigned short reg, unsigned short value)
+static void indirect_write16(int socket,
+			     unsigned short reg, unsigned short value)
 {
 	unsigned short int port;
 	unsigned char val;
@@ -327,10 +336,12 @@ static irqreturn_t i82092aa_interrupt(int irq, void *dev)
 		for (i = 0; i < socket_count; i++) {
 			int csc;
 
-			if (sockets[i].card_state == 0) /* Inactive socket, should not happen */
+			/* Inactive socket, should not happen */
+			if (sockets[i].card_state == 0)
 				continue;
 
-			csc = indirect_read(i, I365_CSC); /* card status change register */
+			/* card status change register */
+			csc = indirect_read(i, I365_CSC);
 
 			if (csc == 0)  /* no events on this socket */
 				continue;
@@ -345,12 +356,16 @@ static irqreturn_t i82092aa_interrupt(int irq, void *dev)
 
 			if (indirect_read(i, I365_INTCTL) & I365_PC_IOCARD) {
 				/* For IO/CARDS, bit 0 means "read the card" */
-				events |= (csc & I365_CSC_STSCHG) ? SS_STSCHG : 0;
+				if (csc & I365_CSC_STSCHG)
+					events |= SS_STSCHG;
 			} else {
 				/* Check for battery/ready events */
-				events |= (csc & I365_CSC_BVD1) ? SS_BATDEAD : 0;
-				events |= (csc & I365_CSC_BVD2) ? SS_BATWARN : 0;
-				events |= (csc & I365_CSC_READY) ? SS_READY : 0;
+				if (csc & I365_CSC_BVD1)
+					events |= SS_BATDEAD;
+				if (csc & I365_CSC_BVD2)
+					events |= SS_BATWARN;
+				if (csc & I365_CSC_READY)
+					events |= SS_READY;
 			}
 
 			if (events)
@@ -426,12 +441,15 @@ static int i82092aa_init(struct pcmcia_socket *sock)
 
 static int i82092aa_get_status(struct pcmcia_socket *socket, u_int *value)
 {
-	unsigned int sock = container_of(socket, struct socket_info, socket)->number;
+	unsigned int sock = container_of(socket,
+				struct socket_info, socket)->number;
 	unsigned int status;
 	
 	enter("i82092aa_get_status");
-	
-	status = indirect_read(sock, I365_STATUS); /* Interface Status Register */
+
+	/* Interface Status Register */
+	status = indirect_read(sock, I365_STATUS);
+
 	*value = 0;
 
 	if ((status & I365_CS_DETECT) == I365_CS_DETECT)
@@ -464,7 +482,8 @@ static int i82092aa_get_status(struct pcmcia_socket *socket, u_int *value)
 }
 
 
-static int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *state)
+static int i82092aa_set_socket(struct pcmcia_socket *socket,
+			       socket_state_t *state)
 {
 	struct socket_info *sock_info = container_of(socket, struct socket_info,
 						     socket);
@@ -480,12 +499,15 @@ static int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *sta
 	/* Values for the IGENC register */
 
 	reg = 0;
-	if (!(state->flags & SS_RESET))	/* The reset bit has "inverse" logic */
+
+	/* The reset bit has "inverse" logic */
+	if (!(state->flags & SS_RESET))
 		reg = reg | I365_PC_RESET;
 	if (state->flags & SS_IOCARD)
 		reg = reg | I365_PC_IOCARD;
 
-	indirect_write(sock, I365_INTCTL, reg); /* IGENC, Interrupt and General Control Register */
+	/* IGENC, Interrupt and General Control Register */
+	indirect_write(sock, I365_INTCTL, reg);
 
 	/* Power registers */
 
@@ -560,7 +582,9 @@ static int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *sta
 
 	}
 
-	/* now write the value and clear the (probably bogus) pending stuff by doing a dummy read*/
+	/* now write the value and clear the (probably bogus) pending stuff
+	 * by doing a dummy read
+	 */
 
 	indirect_write(sock, I365_CSCINT, reg);
 	(void)indirect_read(sock, I365_CSC);
@@ -569,7 +593,8 @@ static int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *sta
 	return 0;
 }
 
-static int i82092aa_set_io_map(struct pcmcia_socket *socket, struct pccard_io_map *io)
+static int i82092aa_set_io_map(struct pcmcia_socket *socket,
+			       struct pccard_io_map *io)
 {
 	struct socket_info *sock_info = container_of(socket, struct socket_info,
 						     socket);
@@ -585,7 +610,8 @@ static int i82092aa_set_io_map(struct pcmcia_socket *socket, struct pccard_io_ma
 		leave("i82092aa_set_io_map with invalid map");
 		return -EINVAL;
 	}
-	if ((io->start > 0xffff) || (io->stop > 0xffff) || (io->stop < io->start)) {
+	if ((io->start > 0xffff) || (io->stop > 0xffff)
+				 || (io->stop < io->start)) {
 		leave("i82092aa_set_io_map with invalid io");
 		return -EINVAL;
 	}
@@ -613,9 +639,11 @@ static int i82092aa_set_io_map(struct pcmcia_socket *socket, struct pccard_io_ma
 	return 0;
 }
 
-static int i82092aa_set_mem_map(struct pcmcia_socket *socket, struct pccard_mem_map *mem)
+static int i82092aa_set_mem_map(struct pcmcia_socket *socket,
+				struct pccard_mem_map *mem)
 {
-	struct socket_info *sock_info = container_of(socket, struct socket_info, socket);
+	struct socket_info *sock_info = container_of(socket, struct socket_info,
+						     socket);
 	unsigned int sock = sock_info->number;
 	struct pci_bus_region region;
 	unsigned short base, i;
@@ -636,8 +664,7 @@ static int i82092aa_set_mem_map(struct pcmcia_socket *socket, struct pccard_mem_
 	     (mem->speed > 1000)) {
 		leave("i82092aa_set_mem_map: invalid address / speed");
 		dev_err(&sock_info->dev->dev,
-			"invalid mem map for socket %i: %llx to %llx with a "
-			"start of %x\n",
+			"invalid mem map for socket %i: %llx to %llx with a start of %x\n",
 			sock,
 			(unsigned long long)region.start,
 			(unsigned long long)region.end,

commit 908864641f635892d4df265fe92425a5166c748b
Author: Simon Geis <simon.geis@fau.de>
Date:   Fri Dec 13 14:53:10 2019 +0100

    PCMCIA/i82092: move assignment out of if condition
    
    Improve readability by moving the assignment out of if conditions.
    
    Co-developed-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Simon Geis <simon.geis@fau.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index c7996fe25622..2d31832fa439 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -77,7 +77,8 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 
 	enter("i82092aa_pci_probe");
 
-	if ((ret = pci_enable_device(dev)))
+	ret = pci_enable_device(dev);
+	if (ret)
 		return ret;
 
 	pci_read_config_byte(dev, 0x40, &configbyte);  /* PCI Configuration Control */
@@ -133,7 +134,9 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 
 	/* Register the interrupt handler */
 	dev_dbg(&dev->dev, "Requesting interrupt %i\n", dev->irq);
-	if ((ret = request_irq(dev->irq, i82092aa_interrupt, IRQF_SHARED, "i82092aa", i82092aa_interrupt))) {
+	ret = request_irq(dev->irq, i82092aa_interrupt, IRQF_SHARED,
+			  "i82092aa", i82092aa_interrupt);
+	if (ret) {
 		dev_err(&dev->dev, "Failed to register IRQ %d, aborting\n",
 			dev->irq);
 		goto err_out_free_res;

commit 6aaf8ff3265041263988d81102afe51923359a81
Author: Simon Geis <simon.geis@fau.de>
Date:   Fri Dec 13 14:53:09 2019 +0100

    PCMCIA/i82092: change code indentation
    
    Align switch and case labels in order to improve readability.
    For the same reason, change the indentation of an if-statement.
    
    Co-developed-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Simon Geis <simon.geis@fau.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 019a4f088db5..c7996fe25622 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -82,22 +82,22 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 
 	pci_read_config_byte(dev, 0x40, &configbyte);  /* PCI Configuration Control */
 	switch (configbyte&6) {
-		case 0:
-			socket_count = 2;
-			break;
-		case 2:
-			socket_count = 1;
-			break;
-		case 4:
-		case 6:
-			socket_count = 4;
-			break;
-
-		default:
-			dev_err(&dev->dev,
-				"Oops, you did something we didn't think of.\n");
-			ret = -EIO;
-			goto err_out_disable;
+	case 0:
+		socket_count = 2;
+		break;
+	case 2:
+		socket_count = 1;
+		break;
+	case 4:
+	case 6:
+		socket_count = 4;
+		break;
+
+	default:
+		dev_err(&dev->dev,
+			"Oops, you did something we didn't think of.\n");
+		ret = -EIO;
+		goto err_out_disable;
 	}
 	dev_info(&dev->dev, "configured as a %d socket device.\n",
 		 socket_count);
@@ -498,42 +498,42 @@ static int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *sta
 	}
 
 	switch (state->Vcc) {
-		case 0:
-			break;
-		case 50:
-			dev_info(&sock_info->dev->dev,
-				 "setting voltage to Vcc to 5V on socket %i\n",
-				 sock);
-			reg |= I365_VCC_5V;
-			break;
-		default:
-			dev_err(&sock_info->dev->dev,
-				"%s called with invalid VCC power value: %i",
-				__func__, state->Vcc);
-			leave("i82092aa_set_socket");
-			return -EINVAL;
+	case 0:
+		break;
+	case 50:
+		dev_info(&sock_info->dev->dev,
+			 "setting voltage to Vcc to 5V on socket %i\n",
+			 sock);
+		reg |= I365_VCC_5V;
+		break;
+	default:
+		dev_err(&sock_info->dev->dev,
+			"%s called with invalid VCC power value: %i",
+			__func__, state->Vcc);
+		leave("i82092aa_set_socket");
+		return -EINVAL;
 	}
 
 	switch (state->Vpp) {
-		case 0:
-			dev_info(&sock_info->dev->dev,
-				 "not setting Vpp on socket %i\n", sock);
-			break;
-		case 50:
-			dev_info(&sock_info->dev->dev,
-				 "setting Vpp to 5.0 for socket %i\n", sock);
-			reg |= I365_VPP1_5V | I365_VPP2_5V;
-			break;
-		case 120:
-			dev_info(&sock_info->dev->dev, "setting Vpp to 12.0\n");
-			reg |= I365_VPP1_12V | I365_VPP2_12V;
-			break;
-		default:
-			dev_err(&sock_info->dev->dev,
-				"%s called with invalid VPP power value: %i",
-				__func__, state->Vcc);
-			leave("i82092aa_set_socket");
-			return -EINVAL;
+	case 0:
+		dev_info(&sock_info->dev->dev,
+			 "not setting Vpp on socket %i\n", sock);
+		break;
+	case 50:
+		dev_info(&sock_info->dev->dev,
+			 "setting Vpp to 5.0 for socket %i\n", sock);
+		reg |= I365_VPP1_5V | I365_VPP2_5V;
+		break;
+	case 120:
+		dev_info(&sock_info->dev->dev, "setting Vpp to 12.0\n");
+		reg |= I365_VPP1_12V | I365_VPP2_12V;
+		break;
+	default:
+		dev_err(&sock_info->dev->dev,
+			"%s called with invalid VPP power value: %i",
+			__func__, state->Vcc);
+		leave("i82092aa_set_socket");
+		return -EINVAL;
 	}
 
 	if (reg != indirect_read(sock, I365_POWER)) /* only write if changed */
@@ -659,17 +659,17 @@ static int i82092aa_set_mem_map(struct pcmcia_socket *socket, struct pccard_mem_
 
 	i = (region.end >> 12) & 0x0fff;
 	switch (to_cycles(mem->speed)) {
-		case 0:
-			break;
-		case 1:
-			i |= I365_MEM_WS0;
-			break;
-		case 2:
-			i |= I365_MEM_WS1;
-			break;
-		default:
-			i |= I365_MEM_WS1 | I365_MEM_WS0;
-			break;
+	case 0:
+		break;
+	case 1:
+		i |= I365_MEM_WS0;
+		break;
+	case 2:
+		i |= I365_MEM_WS1;
+		break;
+	default:
+		i |= I365_MEM_WS1 | I365_MEM_WS0;
+		break;
 	}
 
 	indirect_write16(sock, base+I365_W_STOP, i);
@@ -701,7 +701,7 @@ static void i82092aa_module_exit(void)
 	enter("i82092aa_module_exit");
 	pci_unregister_driver(&i82092aa_pci_driver);
 	if (sockets[0].io_base > 0)
-			 release_region(sockets[0].io_base, 2);
+		release_region(sockets[0].io_base, 2);
 	leave("i82092aa_module_exit");
 }
 

commit 4ae66dd778e3e2245648347b3366e15e68aeb685
Author: Simon Geis <simon.geis@fau.de>
Date:   Fri Dec 13 14:53:08 2019 +0100

    PCMCIA/i82092: insert blank line after declarations
    
    Improve readability of the code by inserting a blank line
    after variable declarations.
    
    Co-developed-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Simon Geis <simon.geis@fau.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index f51f7352d3af..019a4f088db5 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -187,6 +187,7 @@ static unsigned char indirect_read(int socket, unsigned short reg)
 	unsigned short int port;
 	unsigned char val;
 	unsigned long flags;
+
 	spin_lock_irqsave(&port_lock, flags);
 	reg += socket * 0x40;
 	port = sockets[socket].io_base;
@@ -202,6 +203,7 @@ static unsigned short indirect_read16(int socket, unsigned short reg)
 	unsigned short int port;
 	unsigned short tmp;
 	unsigned long flags;
+
 	spin_lock_irqsave(&port_lock, flags);
 	reg  = reg + socket * 0x40;
 	port = sockets[socket].io_base;
@@ -219,6 +221,7 @@ static void indirect_write(int socket, unsigned short reg, unsigned char value)
 {
 	unsigned short int port;
 	unsigned long flags;
+
 	spin_lock_irqsave(&port_lock, flags);
 	reg = reg + socket * 0x40;
 	port = sockets[socket].io_base;
@@ -232,6 +235,7 @@ static void indirect_setbit(int socket, unsigned short reg, unsigned char mask)
 	unsigned short int port;
 	unsigned char val;
 	unsigned long flags;
+
 	spin_lock_irqsave(&port_lock, flags);
 	reg = reg + socket * 0x40;
 	port = sockets[socket].io_base;
@@ -249,6 +253,7 @@ static void indirect_resetbit(int socket, unsigned short reg, unsigned char mask
 	unsigned short int port;
 	unsigned char val;
 	unsigned long flags;
+
 	spin_lock_irqsave(&port_lock, flags);
 	reg = reg + socket * 0x40;
 	port = sockets[socket].io_base;
@@ -265,6 +270,7 @@ static void indirect_write16(int socket, unsigned short reg, unsigned short valu
 	unsigned short int port;
 	unsigned char val;
 	unsigned long flags;
+
 	spin_lock_irqsave(&port_lock, flags);
 	reg = reg + socket * 0x40;
 	port = sockets[socket].io_base;
@@ -317,6 +323,7 @@ static irqreturn_t i82092aa_interrupt(int irq, void *dev)
 
 		for (i = 0; i < socket_count; i++) {
 			int csc;
+
 			if (sockets[i].card_state == 0) /* Inactive socket, should not happen */
 				continue;
 
@@ -362,6 +369,7 @@ static irqreturn_t i82092aa_interrupt(int irq, void *dev)
 static int card_present(int socketno)
 {
 	unsigned int val;
+
 	enter("card_present");
 
 	if ((socketno < 0) || (socketno >= MAX_SOCKETS))

commit ae1f62c5408a6c33363475f2d1909fec32f0dc47
Author: Simon Geis <simon.geis@fau.de>
Date:   Fri Dec 13 14:53:07 2019 +0100

    PCMCIA/i82092: remove braces around single statement blocks
    
    Remove braces around single statement blocks in order to
    improve readability.
    
    Co-developed-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Simon Geis <simon.geis@fau.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 47854d8d2acb..f51f7352d3af 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -144,9 +144,8 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 		sockets[i].socket.ops = &i82092aa_operations;
 		sockets[i].socket.resource_ops = &pccard_nonstatic_ops;
 		ret = pcmcia_register_socket(&sockets[i].socket);
-		if (ret) {
+		if (ret)
 			goto err_out_free_sockets;
-		}
 	}
 
 	leave("i82092aa_pci_probe");
@@ -154,9 +153,8 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 
 err_out_free_sockets:
 	if (i) {
-		for (i--; i >= 0; i--) {
+		for (i--; i >= 0; i--)
 			pcmcia_unregister_socket(&sockets[i].socket);
-		}
 	}
 	free_irq(dev->irq, i82092aa_interrupt);
 err_out_free_res:
@@ -345,9 +343,8 @@ static irqreturn_t i82092aa_interrupt(int irq, void *dev)
 				events |= (csc & I365_CSC_READY) ? SS_READY : 0;
 			}
 
-			if (events) {
+			if (events)
 				pcmcia_parse_events(&sockets[i].socket, events);
-			}
 			active |= events;
 		}
 
@@ -426,9 +423,8 @@ static int i82092aa_get_status(struct pcmcia_socket *socket, u_int *value)
 	status = indirect_read(sock, I365_STATUS); /* Interface Status Register */
 	*value = 0;
 
-	if ((status & I365_CS_DETECT) == I365_CS_DETECT) {
+	if ((status & I365_CS_DETECT) == I365_CS_DETECT)
 		*value |= SS_DETECT;
-	}
 
 	/* IO cards have a different meaning of bits 0,1 */
 	/* Also notice the inverse-logic on the bits */
@@ -538,9 +534,8 @@ static int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *sta
 	/* Enable specific interrupt events */
 
 	reg = 0x00;
-	if (state->csc_mask & SS_DETECT) {
+	if (state->csc_mask & SS_DETECT)
 		reg |= I365_CSC_DETECT;
-	}
 	if (state->flags & SS_IOCARD) {
 		if (state->csc_mask & SS_STSCHG)
 			reg |= I365_CSC_STSCHG;

commit 4839879f8af1309216e5edcce787bafba31c72b3
Author: Simon Geis <simon.geis@fau.de>
Date:   Fri Dec 13 14:53:06 2019 +0100

    PCMCIA/i82092: add/remove spaces to improve readability
    
    Improve the readability by adding whitespaces after commas and around
    comparative operations. Also change indentation of one comment block.
    While at it, remove trailing whitespaces and spaces before tabs.
    
    Co-developed-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Simon Geis <simon.geis@fau.de>
    [linux@dominikbrodowski.net: fixup one additional definition]
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 4971a667c730..47854d8d2acb 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0-only
-/* 
+/*
  * Driver for Intel I82092AA PCI-PCMCIA bridge.
  *
  * (C) 2001 Red Hat, Inc.
@@ -33,16 +33,16 @@ static const struct pci_device_id i82092aa_pci_ids[] = {
 MODULE_DEVICE_TABLE(pci, i82092aa_pci_ids);
 
 static struct pci_driver i82092aa_pci_driver = {
-	.name           = "i82092aa",
-	.id_table       = i82092aa_pci_ids,
-	.probe          = i82092aa_pci_probe,
-	.remove         = i82092aa_pci_remove,
+	.name		= "i82092aa",
+	.id_table	= i82092aa_pci_ids,
+	.probe		= i82092aa_pci_probe,
+	.remove	= i82092aa_pci_remove,
 };
 
 
 /* the pccard structure and its functions */
 static struct pccard_operations i82092aa_operations = {
-	.init 		 	= i82092aa_init,
+	.init			= i82092aa_init,
 	.get_status		= i82092aa_get_status,
 	.set_socket		= i82092aa_set_socket,
 	.set_io_map		= i82092aa_set_io_map,
@@ -53,33 +53,35 @@ static struct pccard_operations i82092aa_operations = {
 
 struct socket_info {
 	int	number;
-	int	card_state; 	/*  0 = no socket,
-				    1 = empty socket, 
-				    2 = card but not initialized,
-				    3 = operational card */
-	unsigned int io_base; 	/* base io address of the socket */
-	
+	int	card_state;
+		/* 0 = no socket,
+		 * 1 = empty socket,
+		 * 2 = card but not initialized,
+		 * 3 = operational card
+		 */
+	unsigned int io_base;	/* base io address of the socket */
+
 	struct pcmcia_socket socket;
 	struct pci_dev *dev;	/* The PCI device for the socket */
 };
 
 #define MAX_SOCKETS 4
 static struct socket_info sockets[MAX_SOCKETS];
-static int socket_count;  /* shortcut */                                  	                                	
+static int socket_count;	/* shortcut */
 
 
 static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	unsigned char configbyte;
 	int i, ret;
-	
+
 	enter("i82092aa_pci_probe");
-	
+
 	if ((ret = pci_enable_device(dev)))
 		return ret;
-		
+
 	pci_read_config_byte(dev, 0x40, &configbyte);  /* PCI Configuration Control */
-	switch(configbyte&6) {
+	switch (configbyte&6) {
 		case 0:
 			socket_count = 2;
 			break;
@@ -90,7 +92,7 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 		case 6:
 			socket_count = 4;
 			break;
-			
+
 		default:
 			dev_err(&dev->dev,
 				"Oops, you did something we didn't think of.\n");
@@ -104,8 +106,8 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 		ret = -EBUSY;
 		goto err_out_disable;
 	}
-	
-	for (i = 0;i<socket_count;i++) {
+
+	for (i = 0; i < socket_count; i++) {
 		sockets[i].card_state = 1; /* 1 = present but empty */
 		sockets[i].io_base = pci_resource_start(dev, 0);
 		sockets[i].socket.features |= SS_CAP_PCCARD;
@@ -116,7 +118,7 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 		sockets[i].socket.owner = THIS_MODULE;
 
 		sockets[i].number = i;
-		
+
 		if (card_present(i)) {
 			sockets[i].card_state = 3;
 			dev_dbg(&dev->dev, "slot %i is occupied\n", i);
@@ -124,7 +126,7 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 			dev_dbg(&dev->dev, "slot %i is vacant\n", i);
 		}
 	}
-		
+
 	/* Now, specifiy that all interrupts are to be done as PCI interrupts */
 	configbyte = 0xFF; /* bitmask, one bit per event, 1 = PCI interrupt, 0 = ISA interrupt */
 	pci_write_config_byte(dev, 0x50, configbyte); /* PCI Interrupt Routing Register */
@@ -137,7 +139,7 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 		goto err_out_free_res;
 	}
 
-	for (i = 0; i<socket_count; i++) {
+	for (i = 0; i < socket_count; i++) {
 		sockets[i].socket.dev.parent = &dev->dev;
 		sockets[i].socket.ops = &i82092aa_operations;
 		sockets[i].socket.resource_ops = &pccard_nonstatic_ops;
@@ -152,7 +154,7 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 
 err_out_free_sockets:
 	if (i) {
-		for (i--;i>=0;i--) {
+		for (i--; i >= 0; i--) {
 			pcmcia_unregister_socket(&sockets[i].socket);
 		}
 	}
@@ -161,7 +163,7 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 	release_region(pci_resource_start(dev, 0), 2);
 err_out_disable:
 	pci_disable_device(dev);
-	return ret;			
+	return ret;
 }
 
 static void i82092aa_pci_remove(struct pci_dev *dev)
@@ -169,7 +171,7 @@ static void i82092aa_pci_remove(struct pci_dev *dev)
 	int i;
 
 	enter("i82092aa_pci_remove");
-	
+
 	free_irq(dev->irq, i82092aa_interrupt);
 
 	for (i = 0; i < socket_count; i++)
@@ -187,12 +189,12 @@ static unsigned char indirect_read(int socket, unsigned short reg)
 	unsigned short int port;
 	unsigned char val;
 	unsigned long flags;
-	spin_lock_irqsave(&port_lock,flags);
+	spin_lock_irqsave(&port_lock, flags);
 	reg += socket * 0x40;
 	port = sockets[socket].io_base;
-	outb(reg,port);
+	outb(reg, port);
 	val = inb(port+1);
-	spin_unlock_irqrestore(&port_lock,flags);
+	spin_unlock_irqrestore(&port_lock, flags);
 	return val;
 }
 
@@ -202,15 +204,15 @@ static unsigned short indirect_read16(int socket, unsigned short reg)
 	unsigned short int port;
 	unsigned short tmp;
 	unsigned long flags;
-	spin_lock_irqsave(&port_lock,flags);
+	spin_lock_irqsave(&port_lock, flags);
 	reg  = reg + socket * 0x40;
 	port = sockets[socket].io_base;
-	outb(reg,port);
+	outb(reg, port);
 	tmp = inb(port+1);
 	reg++;
-	outb(reg,port);
+	outb(reg, port);
 	tmp = tmp | (inb(port+1)<<8);
-	spin_unlock_irqrestore(&port_lock,flags);
+	spin_unlock_irqrestore(&port_lock, flags);
 	return tmp;
 }
 #endif
@@ -219,12 +221,12 @@ static void indirect_write(int socket, unsigned short reg, unsigned char value)
 {
 	unsigned short int port;
 	unsigned long flags;
-	spin_lock_irqsave(&port_lock,flags);
+	spin_lock_irqsave(&port_lock, flags);
 	reg = reg + socket * 0x40;
-	port = sockets[socket].io_base; 
-	outb(reg,port);
-	outb(value,port+1);
-	spin_unlock_irqrestore(&port_lock,flags);
+	port = sockets[socket].io_base;
+	outb(reg, port);
+	outb(value, port+1);
+	spin_unlock_irqrestore(&port_lock, flags);
 }
 
 static void indirect_setbit(int socket, unsigned short reg, unsigned char mask)
@@ -232,15 +234,15 @@ static void indirect_setbit(int socket, unsigned short reg, unsigned char mask)
 	unsigned short int port;
 	unsigned char val;
 	unsigned long flags;
-	spin_lock_irqsave(&port_lock,flags);
+	spin_lock_irqsave(&port_lock, flags);
 	reg = reg + socket * 0x40;
-	port = sockets[socket].io_base; 
-	outb(reg,port);
+	port = sockets[socket].io_base;
+	outb(reg, port);
 	val = inb(port+1);
 	val |= mask;
-	outb(reg,port);
-	outb(val,port+1);
-	spin_unlock_irqrestore(&port_lock,flags);
+	outb(reg, port);
+	outb(val, port+1);
+	spin_unlock_irqrestore(&port_lock, flags);
 }
 
 
@@ -249,15 +251,15 @@ static void indirect_resetbit(int socket, unsigned short reg, unsigned char mask
 	unsigned short int port;
 	unsigned char val;
 	unsigned long flags;
-	spin_lock_irqsave(&port_lock,flags);
+	spin_lock_irqsave(&port_lock, flags);
 	reg = reg + socket * 0x40;
-	port = sockets[socket].io_base; 
-	outb(reg,port);
+	port = sockets[socket].io_base;
+	outb(reg, port);
 	val = inb(port+1);
 	val &= ~mask;
-	outb(reg,port);
-	outb(val,port+1);
-	spin_unlock_irqrestore(&port_lock,flags);
+	outb(reg, port);
+	outb(val, port+1);
+	spin_unlock_irqrestore(&port_lock, flags);
 }
 
 static void indirect_write16(int socket, unsigned short reg, unsigned short value)
@@ -265,20 +267,20 @@ static void indirect_write16(int socket, unsigned short reg, unsigned short valu
 	unsigned short int port;
 	unsigned char val;
 	unsigned long flags;
-	spin_lock_irqsave(&port_lock,flags);
+	spin_lock_irqsave(&port_lock, flags);
 	reg = reg + socket * 0x40;
-	port = sockets[socket].io_base; 
-	
-	outb(reg,port);
+	port = sockets[socket].io_base;
+
+	outb(reg, port);
 	val = value & 255;
-	outb(val,port+1);
-	
+	outb(val, port+1);
+
 	reg++;
-	
-	outb(reg,port);
+
+	outb(reg, port);
 	val = value>>8;
-	outb(val,port+1);
-	spin_unlock_irqrestore(&port_lock,flags);
+	outb(val, port+1);
+	spin_unlock_irqrestore(&port_lock, flags);
 }
 
 /* simple helper functions */
@@ -287,12 +289,12 @@ static int cycle_time = 120;
 
 static int to_cycles(int ns)
 {
-	if (cycle_time!=0)
+	if (cycle_time != 0)
 		return ns/cycle_time;
 	else
 		return 0;
 }
-    
+
 
 /* Interrupt handler functionality */
 
@@ -302,56 +304,55 @@ static irqreturn_t i82092aa_interrupt(int irq, void *dev)
 	int loopcount = 0;
 	int handled = 0;
 
-	unsigned int events, active=0;
-	
+	unsigned int events, active = 0;
+
 /*	enter("i82092aa_interrupt");*/
-	
+
 	while (1) {
 		loopcount++;
-		if (loopcount>20) {
+		if (loopcount > 20) {
 			pr_err("i82092aa: infinite eventloop in interrupt\n");
 			break;
 		}
-		
+
 		active = 0;
-		
-		for (i=0;i<socket_count;i++) {
+
+		for (i = 0; i < socket_count; i++) {
 			int csc;
-			if (sockets[i].card_state==0) /* Inactive socket, should not happen */
+			if (sockets[i].card_state == 0) /* Inactive socket, should not happen */
+				continue;
+
+			csc = indirect_read(i, I365_CSC); /* card status change register */
+
+			if (csc == 0)  /* no events on this socket */
 				continue;
-			
-			csc = indirect_read(i,I365_CSC); /* card status change register */
-			
-			if (csc==0)  /* no events on this socket */
-			   	continue;
 			handled = 1;
 			events = 0;
-			 
+
 			if (csc & I365_CSC_DETECT) {
 				events |= SS_DETECT;
 				dev_info(&sockets[i].dev->dev,
 					 "Card detected in socket %i!\n", i);
-			 }
-			
-			if (indirect_read(i,I365_INTCTL) & I365_PC_IOCARD) { 
+			}
+
+			if (indirect_read(i, I365_INTCTL) & I365_PC_IOCARD) {
 				/* For IO/CARDS, bit 0 means "read the card" */
-				events |= (csc & I365_CSC_STSCHG) ? SS_STSCHG : 0; 
+				events |= (csc & I365_CSC_STSCHG) ? SS_STSCHG : 0;
 			} else {
 				/* Check for battery/ready events */
 				events |= (csc & I365_CSC_BVD1) ? SS_BATDEAD : 0;
 				events |= (csc & I365_CSC_BVD2) ? SS_BATWARN : 0;
 				events |= (csc & I365_CSC_READY) ? SS_READY : 0;
 			}
-			
+
 			if (events) {
 				pcmcia_parse_events(&sockets[i].socket, events);
 			}
 			active |= events;
 		}
-				
-		if (active==0) /* no more events to handle */
-			break;				
-		
+
+		if (active == 0) /* no more events to handle */
+			break;
 	}
 	return IRQ_RETVAL(handled);
 /*	leave("i82092aa_interrupt");*/
@@ -362,22 +363,22 @@ static irqreturn_t i82092aa_interrupt(int irq, void *dev)
 /* socket functions */
 
 static int card_present(int socketno)
-{	
+{
 	unsigned int val;
 	enter("card_present");
-	
-	if ((socketno<0) || (socketno >= MAX_SOCKETS))
+
+	if ((socketno < 0) || (socketno >= MAX_SOCKETS))
 		return 0;
 	if (sockets[socketno].io_base == 0)
 		return 0;
 
-		
+
 	val = indirect_read(socketno, 1); /* Interface status register */
-	if ((val&12)==12) {
+	if ((val&12) == 12) {
 		leave("card_present 1");
 		return 1;
 	}
-		
+
 	leave("card_present 0");
 	return 0;
 }
@@ -385,40 +386,36 @@ static int card_present(int socketno)
 static void set_bridge_state(int sock)
 {
 	enter("set_bridge_state");
-	indirect_write(sock, I365_GBLCTL,0x00);
-	indirect_write(sock, I365_GENCTL,0x00);
-	
-	indirect_setbit(sock, I365_INTCTL,0x08);
+	indirect_write(sock, I365_GBLCTL, 0x00);
+	indirect_write(sock, I365_GENCTL, 0x00);
+
+	indirect_setbit(sock, I365_INTCTL, 0x08);
 	leave("set_bridge_state");
 }
 
 
-
-
-
-      
 static int i82092aa_init(struct pcmcia_socket *sock)
 {
 	int i;
 	struct resource res = { .start = 0, .end = 0x0fff };
-        pccard_io_map io = { 0, 0, 0, 0, 1 };
+	pccard_io_map io = { 0, 0, 0, 0, 1 };
 	pccard_mem_map mem = { .res = &res, };
-        
-        enter("i82092aa_init");
-                        
-        for (i = 0; i < 2; i++) {
-        	io.map = i;
-                i82092aa_set_io_map(sock, &io);
+
+	enter("i82092aa_init");
+
+	for (i = 0; i < 2; i++) {
+		io.map = i;
+		i82092aa_set_io_map(sock, &io);
 	}
-        for (i = 0; i < 5; i++) {
-        	mem.map = i;
-                i82092aa_set_mem_map(sock, &mem);
+	for (i = 0; i < 5; i++) {
+		mem.map = i;
+		i82092aa_set_mem_map(sock, &mem);
 	}
 	
 	leave("i82092aa_init");
 	return 0;
 }
-                                                                                                                                                                                                                                              
+
 static int i82092aa_get_status(struct pcmcia_socket *socket, u_int *value)
 {
 	unsigned int sock = container_of(socket, struct socket_info, socket)->number;
@@ -426,16 +423,16 @@ static int i82092aa_get_status(struct pcmcia_socket *socket, u_int *value)
 	
 	enter("i82092aa_get_status");
 	
-	status = indirect_read(sock,I365_STATUS); /* Interface Status Register */
+	status = indirect_read(sock, I365_STATUS); /* Interface Status Register */
 	*value = 0;
-	
+
 	if ((status & I365_CS_DETECT) == I365_CS_DETECT) {
 		*value |= SS_DETECT;
 	}
-		
+
 	/* IO cards have a different meaning of bits 0,1 */
 	/* Also notice the inverse-logic on the bits */
-	if (indirect_read(sock, I365_INTCTL) & I365_PC_IOCARD)	{
+	if (indirect_read(sock, I365_INTCTL) & I365_PC_IOCARD) {
 		/* IO card */
 		if (!(status & I365_CS_STSCHG))
 			*value |= SS_STSCHG;
@@ -445,13 +442,13 @@ static int i82092aa_get_status(struct pcmcia_socket *socket, u_int *value)
 		if (!(status & I365_CS_BVD2))
 			*value |= SS_BATWARN;
 	}
-	 
+
 	if (status & I365_CS_WRPROT)
 		(*value) |= SS_WRPROT;	/* card is write protected */
-	 
+
 	if (status & I365_CS_READY)
 		(*value) |= SS_READY;    /* card is not busy */
-	 	
+
 	if (status & I365_CS_POWERON)
 		(*value) |= SS_POWERON;  /* power is applied to the card */
 
@@ -460,33 +457,33 @@ static int i82092aa_get_status(struct pcmcia_socket *socket, u_int *value)
 }
 
 
-static int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *state) 
+static int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *state)
 {
 	struct socket_info *sock_info = container_of(socket, struct socket_info,
 						     socket);
 	unsigned int sock = sock_info->number;
 	unsigned char reg;
-	
+
 	enter("i82092aa_set_socket");
-	
+
 	/* First, set the global controller options */
-	
+
 	set_bridge_state(sock);
-	
+
 	/* Values for the IGENC register */
-	
+
 	reg = 0;
-	if (!(state->flags & SS_RESET)) 	/* The reset bit has "inverse" logic */
-		reg = reg | I365_PC_RESET;  
-	if (state->flags & SS_IOCARD) 
+	if (!(state->flags & SS_RESET))	/* The reset bit has "inverse" logic */
+		reg = reg | I365_PC_RESET;
+	if (state->flags & SS_IOCARD)
 		reg = reg | I365_PC_IOCARD;
-		
-	indirect_write(sock,I365_INTCTL,reg); /* IGENC, Interrupt and General Control Register */
-	
+
+	indirect_write(sock, I365_INTCTL, reg); /* IGENC, Interrupt and General Control Register */
+
 	/* Power registers */
-	
+
 	reg = I365_PWR_NORESET; /* default: disable resetdrv on resume */
-	
+
 	if (state->flags & SS_PWR_AUTO) {
 		dev_info(&sock_info->dev->dev, "Auto power\n");
 		reg |= I365_PWR_AUTO;	/* automatic power mngmnt */
@@ -495,11 +492,11 @@ static int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *sta
 		dev_info(&sock_info->dev->dev, "Power Enabled\n");
 		reg |= I365_PWR_OUT;	/* enable power */
 	}
-	
+
 	switch (state->Vcc) {
-		case 0:	
+		case 0:
 			break;
-		case 50: 
+		case 50:
 			dev_info(&sock_info->dev->dev,
 				 "setting voltage to Vcc to 5V on socket %i\n",
 				 sock);
@@ -512,19 +509,18 @@ static int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *sta
 			leave("i82092aa_set_socket");
 			return -EINVAL;
 	}
-	
-	
+
 	switch (state->Vpp) {
-		case 0:	
+		case 0:
 			dev_info(&sock_info->dev->dev,
 				 "not setting Vpp on socket %i\n", sock);
 			break;
-		case 50: 
+		case 50:
 			dev_info(&sock_info->dev->dev,
 				 "setting Vpp to 5.0 for socket %i\n", sock);
 			reg |= I365_VPP1_5V | I365_VPP2_5V;
 			break;
-		case 120: 
+		case 120:
 			dev_info(&sock_info->dev->dev, "setting Vpp to 12.0\n");
 			reg |= I365_VPP1_12V | I365_VPP2_12V;
 			break;
@@ -535,12 +531,12 @@ static int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *sta
 			leave("i82092aa_set_socket");
 			return -EINVAL;
 	}
-	
-	if (reg != indirect_read(sock,I365_POWER)) /* only write if changed */
-		indirect_write(sock,I365_POWER,reg);
-		
+
+	if (reg != indirect_read(sock, I365_POWER)) /* only write if changed */
+		indirect_write(sock, I365_POWER, reg);
+
 	/* Enable specific interrupt events */
-	
+
 	reg = 0x00;
 	if (state->csc_mask & SS_DETECT) {
 		reg |= I365_CSC_DETECT;
@@ -549,19 +545,19 @@ static int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *sta
 		if (state->csc_mask & SS_STSCHG)
 			reg |= I365_CSC_STSCHG;
 	} else {
-		if (state->csc_mask & SS_BATDEAD) 
+		if (state->csc_mask & SS_BATDEAD)
 			reg |= I365_CSC_BVD1;
-		if (state->csc_mask & SS_BATWARN) 
+		if (state->csc_mask & SS_BATWARN)
 			reg |= I365_CSC_BVD2;
-		if (state->csc_mask & SS_READY) 
-			reg |= I365_CSC_READY; 
-		                        
+		if (state->csc_mask & SS_READY)
+			reg |= I365_CSC_READY;
+
 	}
-	
+
 	/* now write the value and clear the (probably bogus) pending stuff by doing a dummy read*/
-	
-	indirect_write(sock,I365_CSCINT,reg);
-	(void)indirect_read(sock,I365_CSC);
+
+	indirect_write(sock, I365_CSCINT, reg);
+	(void)indirect_read(sock, I365_CSC);
 
 	leave("i82092aa_set_socket");
 	return 0;
@@ -573,41 +569,41 @@ static int i82092aa_set_io_map(struct pcmcia_socket *socket, struct pccard_io_ma
 						     socket);
 	unsigned int sock = sock_info->number;
 	unsigned char map, ioctl;
-	
+
 	enter("i82092aa_set_io_map");
-	
+
 	map = io->map;
-	
-	/* Check error conditions */	
+
+	/* Check error conditions */
 	if (map > 1) {
 		leave("i82092aa_set_io_map with invalid map");
 		return -EINVAL;
 	}
-	if ((io->start > 0xffff) || (io->stop > 0xffff) || (io->stop < io->start)){
+	if ((io->start > 0xffff) || (io->stop > 0xffff) || (io->stop < io->start)) {
 		leave("i82092aa_set_io_map with invalid io");
 		return -EINVAL;
 	}
 
-	/* Turn off the window before changing anything */ 
+	/* Turn off the window before changing anything */
 	if (indirect_read(sock, I365_ADDRWIN) & I365_ENA_IO(map))
 		indirect_resetbit(sock, I365_ADDRWIN, I365_ENA_IO(map));
 
 	/* write the new values */
-	indirect_write16(sock,I365_IO(map)+I365_W_START,io->start);            	
-	indirect_write16(sock,I365_IO(map)+I365_W_STOP,io->stop);            	
-	            	
-	ioctl = indirect_read(sock,I365_IOCTL) & ~I365_IOCTL_MASK(map);
-	
+	indirect_write16(sock, I365_IO(map)+I365_W_START, io->start);
+	indirect_write16(sock, I365_IO(map)+I365_W_STOP, io->stop);
+
+	ioctl = indirect_read(sock, I365_IOCTL) & ~I365_IOCTL_MASK(map);
+
 	if (io->flags & (MAP_16BIT|MAP_AUTOSZ))
 		ioctl |= I365_IOCTL_16BIT(map);
-		
-	indirect_write(sock,I365_IOCTL,ioctl);
-	
+
+	indirect_write(sock, I365_IOCTL, ioctl);
+
 	/* Turn the window back on if needed */
 	if (io->flags & MAP_ACTIVE)
-		indirect_setbit(sock,I365_ADDRWIN,I365_ENA_IO(map));
-			
-	leave("i82092aa_set_io_map");	
+		indirect_setbit(sock, I365_ADDRWIN, I365_ENA_IO(map));
+
+	leave("i82092aa_set_io_map");
 	return 0;
 }
 
@@ -618,20 +614,20 @@ static int i82092aa_set_mem_map(struct pcmcia_socket *socket, struct pccard_mem_
 	struct pci_bus_region region;
 	unsigned short base, i;
 	unsigned char map;
-	
+
 	enter("i82092aa_set_mem_map");
 
 	pcibios_resource_to_bus(sock_info->dev->bus, &region, mem->res);
-	
+
 	map = mem->map;
 	if (map > 4) {
 		leave("i82092aa_set_mem_map: invalid map");
 		return -EINVAL;
 	}
-	
-	
-	if ( (mem->card_start > 0x3ffffff) || (region.start > region.end) ||
-	     (mem->speed > 1000) ) {
+
+
+	if ((mem->card_start > 0x3ffffff) || (region.start > region.end) ||
+	     (mem->speed > 1000)) {
 		leave("i82092aa_set_mem_map: invalid address / speed");
 		dev_err(&sock_info->dev->dev,
 			"invalid mem map for socket %i: %llx to %llx with a "
@@ -642,24 +638,23 @@ static int i82092aa_set_mem_map(struct pcmcia_socket *socket, struct pccard_mem_
 			mem->card_start);
 		return -EINVAL;
 	}
-	
+
 	/* Turn off the window before changing anything */
 	if (indirect_read(sock, I365_ADDRWIN) & I365_ENA_MEM(map))
-	              indirect_resetbit(sock, I365_ADDRWIN, I365_ENA_MEM(map));
-	                 
-	                 
+		indirect_resetbit(sock, I365_ADDRWIN, I365_ENA_MEM(map));
+
 	/* write the start address */
 	base = I365_MEM(map);
 	i = (region.start >> 12) & 0x0fff;
-	if (mem->flags & MAP_16BIT) 
+	if (mem->flags & MAP_16BIT)
 		i |= I365_MEM_16BIT;
 	if (mem->flags & MAP_0WS)
-		i |= I365_MEM_0WS;	
-	indirect_write16(sock,base+I365_W_START,i);
-		               
+		i |= I365_MEM_0WS;
+	indirect_write16(sock, base+I365_W_START, i);
+
 	/* write the stop address */
-	
-	i= (region.end >> 12) & 0x0fff;
+
+	i = (region.end >> 12) & 0x0fff;
 	switch (to_cycles(mem->speed)) {
 		case 0:
 			break;
@@ -673,22 +668,22 @@ static int i82092aa_set_mem_map(struct pcmcia_socket *socket, struct pccard_mem_
 			i |= I365_MEM_WS1 | I365_MEM_WS0;
 			break;
 	}
-	
-	indirect_write16(sock,base+I365_W_STOP,i);
-	
+
+	indirect_write16(sock, base+I365_W_STOP, i);
+
 	/* card start */
-	
+
 	i = ((mem->card_start - region.start) >> 12) & 0x3fff;
 	if (mem->flags & MAP_WRPROT)
 		i |= I365_MEM_WRPROT;
 	if (mem->flags & MAP_ATTRIB)
 		i |= I365_MEM_REG;
-	indirect_write16(sock,base+I365_W_OFF,i);
-	
+	indirect_write16(sock, base+I365_W_OFF, i);
+
 	/* Enable the window if necessary */
 	if (mem->flags & MAP_ACTIVE)
 		indirect_setbit(sock, I365_ADDRWIN, I365_ENA_MEM(map));
-	            
+
 	leave("i82092aa_set_mem_map");
 	return 0;
 }
@@ -702,7 +697,7 @@ static void i82092aa_module_exit(void)
 {
 	enter("i82092aa_module_exit");
 	pci_unregister_driver(&i82092aa_pci_driver);
-	if (sockets[0].io_base>0)
+	if (sockets[0].io_base > 0)
 			 release_region(sockets[0].io_base, 2);
 	leave("i82092aa_module_exit");
 }

commit 26a0a10419fd8ee1b45f8a91f38ded230410b262
Author: Simon Geis <simon.geis@fau.de>
Date:   Fri Dec 13 14:53:04 2019 +0100

    PCMCIA/i82092: use dev_<level> instead of printk
    
    Improve the log output by using the device-aware dev_err()/dev_info()
    functions. While at it, update one remaining printk(KERN_ERR ...) call
    to the preferred pr_err() call and delete commented out debugging lines.
    
    Co-developed-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Lukas Panzer <lukas.panzer@fau.de>
    Signed-off-by: Simon Geis <simon.geis@fau.de>
    [linux@dominikbrodowski.net: disapply unneeded part of patch]
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index aad8a46605be..4971a667c730 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -92,11 +92,13 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 			break;
 			
 		default:
-			printk(KERN_ERR "i82092aa: Oops, you did something we didn't think of.\n");
+			dev_err(&dev->dev,
+				"Oops, you did something we didn't think of.\n");
 			ret = -EIO;
 			goto err_out_disable;
 	}
-	printk(KERN_INFO "i82092aa: configured as a %d socket device.\n", socket_count);
+	dev_info(&dev->dev, "configured as a %d socket device.\n",
+		 socket_count);
 
 	if (!request_region(pci_resource_start(dev, 0), 2, "i82092aa")) {
 		ret = -EBUSY;
@@ -117,9 +119,9 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 		
 		if (card_present(i)) {
 			sockets[i].card_state = 3;
-			dev_dbg(&dev->dev, "i82092aa: slot %i is occupied\n", i);
+			dev_dbg(&dev->dev, "slot %i is occupied\n", i);
 		} else {
-			dev_dbg(&dev->dev, "i82092aa: slot %i is vacant\n", i);
+			dev_dbg(&dev->dev, "slot %i is vacant\n", i);
 		}
 	}
 		
@@ -130,7 +132,8 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 	/* Register the interrupt handler */
 	dev_dbg(&dev->dev, "Requesting interrupt %i\n", dev->irq);
 	if ((ret = request_irq(dev->irq, i82092aa_interrupt, IRQF_SHARED, "i82092aa", i82092aa_interrupt))) {
-		printk(KERN_ERR "i82092aa: Failed to register IRQ %d, aborting\n", dev->irq);
+		dev_err(&dev->dev, "Failed to register IRQ %d, aborting\n",
+			dev->irq);
 		goto err_out_free_res;
 	}
 
@@ -306,7 +309,7 @@ static irqreturn_t i82092aa_interrupt(int irq, void *dev)
 	while (1) {
 		loopcount++;
 		if (loopcount>20) {
-			printk(KERN_ERR "i82092aa: infinite eventloop in interrupt \n");
+			pr_err("i82092aa: infinite eventloop in interrupt\n");
 			break;
 		}
 		
@@ -326,7 +329,8 @@ static irqreturn_t i82092aa_interrupt(int irq, void *dev)
 			 
 			if (csc & I365_CSC_DETECT) {
 				events |= SS_DETECT;
-				printk("Card detected in socket %i!\n",i);
+				dev_info(&sockets[i].dev->dev,
+					 "Card detected in socket %i!\n", i);
 			 }
 			
 			if (indirect_read(i,I365_INTCTL) & I365_PC_IOCARD) { 
@@ -458,7 +462,9 @@ static int i82092aa_get_status(struct pcmcia_socket *socket, u_int *value)
 
 static int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *state) 
 {
-	unsigned int sock = container_of(socket, struct socket_info, socket)->number;
+	struct socket_info *sock_info = container_of(socket, struct socket_info,
+						     socket);
+	unsigned int sock = sock_info->number;
 	unsigned char reg;
 	
 	enter("i82092aa_set_socket");
@@ -482,11 +488,11 @@ static int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *sta
 	reg = I365_PWR_NORESET; /* default: disable resetdrv on resume */
 	
 	if (state->flags & SS_PWR_AUTO) {
-		printk("Auto power\n");
+		dev_info(&sock_info->dev->dev, "Auto power\n");
 		reg |= I365_PWR_AUTO;	/* automatic power mngmnt */
 	}
 	if (state->flags & SS_OUTPUT_ENA) {
-		printk("Power Enabled \n");
+		dev_info(&sock_info->dev->dev, "Power Enabled\n");
 		reg |= I365_PWR_OUT;	/* enable power */
 	}
 	
@@ -494,11 +500,15 @@ static int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *sta
 		case 0:	
 			break;
 		case 50: 
-			printk("setting voltage to Vcc to 5V on socket %i\n",sock);
+			dev_info(&sock_info->dev->dev,
+				 "setting voltage to Vcc to 5V on socket %i\n",
+				 sock);
 			reg |= I365_VCC_5V;
 			break;
 		default:
-			printk("i82092aa: i82092aa_set_socket called with invalid VCC power value: %i ", state->Vcc);
+			dev_err(&sock_info->dev->dev,
+				"%s called with invalid VCC power value: %i",
+				__func__, state->Vcc);
 			leave("i82092aa_set_socket");
 			return -EINVAL;
 	}
@@ -506,18 +516,22 @@ static int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *sta
 	
 	switch (state->Vpp) {
 		case 0:	
-			printk("not setting Vpp on socket %i\n",sock);
+			dev_info(&sock_info->dev->dev,
+				 "not setting Vpp on socket %i\n", sock);
 			break;
 		case 50: 
-			printk("setting Vpp to 5.0 for socket %i\n",sock);
+			dev_info(&sock_info->dev->dev,
+				 "setting Vpp to 5.0 for socket %i\n", sock);
 			reg |= I365_VPP1_5V | I365_VPP2_5V;
 			break;
 		case 120: 
-			printk("setting Vpp to 12.0\n");
+			dev_info(&sock_info->dev->dev, "setting Vpp to 12.0\n");
 			reg |= I365_VPP1_12V | I365_VPP2_12V;
 			break;
 		default:
-			printk("i82092aa: i82092aa_set_socket called with invalid VPP power value: %i ", state->Vcc);
+			dev_err(&sock_info->dev->dev,
+				"%s called with invalid VPP power value: %i",
+				__func__, state->Vcc);
 			leave("i82092aa_set_socket");
 			return -EINVAL;
 	}
@@ -555,7 +569,9 @@ static int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *sta
 
 static int i82092aa_set_io_map(struct pcmcia_socket *socket, struct pccard_io_map *io)
 {
-	unsigned int sock = container_of(socket, struct socket_info, socket)->number;
+	struct socket_info *sock_info = container_of(socket, struct socket_info,
+						     socket);
+	unsigned int sock = sock_info->number;
 	unsigned char map, ioctl;
 	
 	enter("i82092aa_set_io_map");
@@ -576,8 +592,6 @@ static int i82092aa_set_io_map(struct pcmcia_socket *socket, struct pccard_io_ma
 	if (indirect_read(sock, I365_ADDRWIN) & I365_ENA_IO(map))
 		indirect_resetbit(sock, I365_ADDRWIN, I365_ENA_IO(map));
 
-/*	printk("set_io_map: Setting range to %x - %x \n",io->start,io->stop);  */
-	
 	/* write the new values */
 	indirect_write16(sock,I365_IO(map)+I365_W_START,io->start);            	
 	indirect_write16(sock,I365_IO(map)+I365_W_STOP,io->stop);            	
@@ -619,7 +633,8 @@ static int i82092aa_set_mem_map(struct pcmcia_socket *socket, struct pccard_mem_
 	if ( (mem->card_start > 0x3ffffff) || (region.start > region.end) ||
 	     (mem->speed > 1000) ) {
 		leave("i82092aa_set_mem_map: invalid address / speed");
-		printk("invalid mem map for socket %i: %llx to %llx with a "
+		dev_err(&sock_info->dev->dev,
+			"invalid mem map for socket %i: %llx to %llx with a "
 			"start of %x\n",
 			sock,
 			(unsigned long long)region.start,
@@ -633,8 +648,6 @@ static int i82092aa_set_mem_map(struct pcmcia_socket *socket, struct pccard_mem_
 	              indirect_resetbit(sock, I365_ADDRWIN, I365_ENA_MEM(map));
 	                 
 	                 
-/* 	printk("set_mem_map: Setting map %i range to %x - %x on socket %i, speed is %i, active = %i \n",map, region.start,region.end,sock,mem->speed,mem->flags & MAP_ACTIVE);  */
-
 	/* write the start address */
 	base = I365_MEM(map);
 	i = (region.start >> 12) & 0x0fff;
@@ -668,12 +681,8 @@ static int i82092aa_set_mem_map(struct pcmcia_socket *socket, struct pccard_mem_
 	i = ((mem->card_start - region.start) >> 12) & 0x3fff;
 	if (mem->flags & MAP_WRPROT)
 		i |= I365_MEM_WRPROT;
-	if (mem->flags & MAP_ATTRIB) {
-/*		printk("requesting attribute memory for socket %i\n",sock);*/
+	if (mem->flags & MAP_ATTRIB)
 		i |= I365_MEM_REG;
-	} else {
-/*		printk("requesting normal memory for socket %i\n",sock);*/
-	}
 	indirect_write16(sock,base+I365_W_OFF,i);
 	
 	/* Enable the window if necessary */

commit 84182fc7c16f3e882977879c464fa14f2561bfad
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Oct 31 16:46:02 2018 +0000

    pcmcia: clean an indentation issues, remove extraneous spaces
    
    Trivial fix to clean up indentation issues, remove spaces
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 245d60189375..aad8a46605be 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -431,27 +431,25 @@ static int i82092aa_get_status(struct pcmcia_socket *socket, u_int *value)
 		
 	/* IO cards have a different meaning of bits 0,1 */
 	/* Also notice the inverse-logic on the bits */
-	 if (indirect_read(sock, I365_INTCTL) & I365_PC_IOCARD)	{
-	 	/* IO card */
-	 	if (!(status & I365_CS_STSCHG))
-	 		*value |= SS_STSCHG;
-	 } else { /* non I/O card */
-	 	if (!(status & I365_CS_BVD1))
-	 		*value |= SS_BATDEAD;
-	 	if (!(status & I365_CS_BVD2))
-	 		*value |= SS_BATWARN;
-	 		
-	 }
+	if (indirect_read(sock, I365_INTCTL) & I365_PC_IOCARD)	{
+		/* IO card */
+		if (!(status & I365_CS_STSCHG))
+			*value |= SS_STSCHG;
+	} else { /* non I/O card */
+		if (!(status & I365_CS_BVD1))
+			*value |= SS_BATDEAD;
+		if (!(status & I365_CS_BVD2))
+			*value |= SS_BATWARN;
+	}
 	 
-	 if (status & I365_CS_WRPROT)
-	 	(*value) |= SS_WRPROT;	/* card is write protected */
+	if (status & I365_CS_WRPROT)
+		(*value) |= SS_WRPROT;	/* card is write protected */
 	 
-	 if (status & I365_CS_READY)
-	 	(*value) |= SS_READY;    /* card is not busy */
+	if (status & I365_CS_READY)
+		(*value) |= SS_READY;    /* card is not busy */
 	 	
-	 if (status & I365_CS_POWERON)
-	 	(*value) |= SS_POWERON;  /* power is applied to the card */
-
+	if (status & I365_CS_POWERON)
+		(*value) |= SS_POWERON;  /* power is applied to the card */
 
 	leave("i82092aa_get_status");
 	return 0;

commit 836e9494f4485127a5b505ae57e4387bea8b53c4
Author: Adam Zerella <adam.zerella@gmail.com>
Date:   Sun Aug 25 15:35:10 2019 +1000

    pcmcia/i82092: Refactored dprintk macro for dev_dbg().
    
    As suggested in https://kernelnewbies.org/KernelJanitors/Todo
    this patch replaces the outdated macro of DPRINTK for dev_dbg()
    
    To: Dominik Brodowski <linux@dominikbrodowski.net>
    To: Thomas Gleixner <tglx@linutronix.de>
    To: Adam Zerella <adam.zerella@gmail.com>
    To: linux-kernel@vger.kernel.org
    Signed-off-by: Adam Zerella <adam.zerella@gmail.com>
    Link: https://lore.kernel.org/r/20190825053513.13990-1-adam.zerella@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index ec54a2aa5cb8..245d60189375 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -117,9 +117,9 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 		
 		if (card_present(i)) {
 			sockets[i].card_state = 3;
-			dprintk(KERN_DEBUG "i82092aa: slot %i is occupied\n",i);
+			dev_dbg(&dev->dev, "i82092aa: slot %i is occupied\n", i);
 		} else {
-			dprintk(KERN_DEBUG "i82092aa: slot %i is vacant\n",i);
+			dev_dbg(&dev->dev, "i82092aa: slot %i is vacant\n", i);
 		}
 	}
 		
@@ -128,7 +128,7 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 	pci_write_config_byte(dev, 0x50, configbyte); /* PCI Interrupt Routing Register */
 
 	/* Register the interrupt handler */
-	dprintk(KERN_DEBUG "Requesting interrupt %i \n",dev->irq);
+	dev_dbg(&dev->dev, "Requesting interrupt %i\n", dev->irq);
 	if ((ret = request_irq(dev->irq, i82092aa_interrupt, IRQF_SHARED, "i82092aa", i82092aa_interrupt))) {
 		printk(KERN_ERR "i82092aa: Failed to register IRQ %d, aborting\n", dev->irq);
 		goto err_out_free_res;

commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index aae7e6df99cd..ec54a2aa5cb8 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* 
  * Driver for Intel I82092AA PCI-PCMCIA bridge.
  *

commit 0178a7a54d408d2c5b7bbe7eee9450bffbec0989
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jul 18 16:58:07 2014 -0700

    pcmcia: remove DEFINE_PCI_DEVICE_TABLE usage
    
    It's not needed, just use the "real" structure definition instead.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 7d47456429a1..aae7e6df99cd 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -25,7 +25,7 @@
 MODULE_LICENSE("GPL");
 
 /* PCI core routines */
-static DEFINE_PCI_DEVICE_TABLE(i82092aa_pci_ids) = {
+static const struct pci_device_id i82092aa_pci_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82092AA_0) },
 	{ }
 };

commit fc2798502f860b18f3c7121e4dc659d3d9d28d74
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Dec 9 22:54:40 2013 -0800

    PCI: Convert pcibios_resource_to_bus() to take a pci_bus, not a pci_dev
    
    These interfaces:
    
      pcibios_resource_to_bus(struct pci_dev *dev, *bus_region, *resource)
      pcibios_bus_to_resource(struct pci_dev *dev, *resource, *bus_region)
    
    took a pci_dev, but they really depend only on the pci_bus.  And we want to
    use them in resource allocation paths where we have the bus but not a
    device, so this patch converts them to take the pci_bus instead of the
    pci_dev:
    
      pcibios_resource_to_bus(struct pci_bus *bus, *bus_region, *resource)
      pcibios_bus_to_resource(struct pci_bus *bus, *resource, *bus_region)
    
    In fact, with standard PCI-PCI bridges, they only depend on the host
    bridge, because that's the only place address translation occurs, but
    we aren't going that far yet.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 519c4d6003a6..7d47456429a1 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -608,7 +608,7 @@ static int i82092aa_set_mem_map(struct pcmcia_socket *socket, struct pccard_mem_
 	
 	enter("i82092aa_set_mem_map");
 
-	pcibios_resource_to_bus(sock_info->dev, &region, mem->res);
+	pcibios_resource_to_bus(sock_info->dev->bus, &region, mem->res);
 	
 	map = mem->map;
 	if (map > 4) {

commit 36c286d5a45731d957d02c317ee2ce775e856765
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Dec 14 18:01:08 2012 +0300

    pcmcia: i82092: fix i82092aa_pci_remove()
    
    Smatch complains because the call to
            pci_set_drvdata(dev, &sockets[i].socket);
    is reading one step beyond the end of the sockets[] array.  It will
    crash when we use it later.
    
    The only place which uses pci_get_drvdata() is i82092aa_pci_remove().
    That function should loop through all the sockets and unregister them.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 3578e1ca97a0..519c4d6003a6 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -133,8 +133,6 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 		goto err_out_free_res;
 	}
 
-	pci_set_drvdata(dev, &sockets[i].socket);
-
 	for (i = 0; i<socket_count; i++) {
 		sockets[i].socket.dev.parent = &dev->dev;
 		sockets[i].socket.ops = &i82092aa_operations;
@@ -164,14 +162,14 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 
 static void i82092aa_pci_remove(struct pci_dev *dev)
 {
-	struct pcmcia_socket *socket = pci_get_drvdata(dev);
+	int i;
 
 	enter("i82092aa_pci_remove");
 	
 	free_irq(dev->irq, i82092aa_interrupt);
 
-	if (socket)
-		pcmcia_unregister_socket(socket);
+	for (i = 0; i < socket_count; i++)
+		pcmcia_unregister_socket(&sockets[i].socket);
 
 	leave("i82092aa_pci_remove");
 }

commit e765a02cb64bfef53f290122ca0897ef329a4e76
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:05 2012 -0500

    pcmcia: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 26832de5f12c..3578e1ca97a0 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -162,7 +162,7 @@ static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *i
 	return ret;			
 }
 
-static void __devexit i82092aa_pci_remove(struct pci_dev *dev)
+static void i82092aa_pci_remove(struct pci_dev *dev)
 {
 	struct pcmcia_socket *socket = pci_get_drvdata(dev);
 

commit 34cdf25a126f053698d549cc12a9c30e9a8a0bab
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:23:12 2012 -0500

    pcmcia: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Acked-by: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 3f6110008e9b..26832de5f12c 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -67,7 +67,7 @@ static struct socket_info sockets[MAX_SOCKETS];
 static int socket_count;  /* shortcut */                                  	                                	
 
 
-static int __devinit i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
+static int i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	unsigned char configbyte;
 	int i, ret;

commit 96364e3a5cf1416c158a276134d9a4fc861548c2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:20:38 2012 -0500

    pcmcia: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 4e8831bdb6ef..3f6110008e9b 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -35,7 +35,7 @@ static struct pci_driver i82092aa_pci_driver = {
 	.name           = "i82092aa",
 	.id_table       = i82092aa_pci_ids,
 	.probe          = i82092aa_pci_probe,
-	.remove         = __devexit_p(i82092aa_pci_remove),
+	.remove         = i82092aa_pci_remove,
 };
 
 

commit a6f707b601c3f85d4b816ea08a757ea1af4f1cc0
Merge: ef08e7826842 80af9e6d7ae6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 29 16:00:48 2012 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/brodo/pcmcia
    
    Pull a few PCMCIA updates from Dominik Brodowski.
    
    Fix up trivial conflict (modified code in question had been removed) in
    drivers/pcmcia/soc_common.c.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/brodo/pcmcia:
      pcmcia at91_cf: fix raw gpio number usage
      ARM: pxa: fix error handling in pxa2xx_drv_pcmcia_probe
      pcmcia: Convert to DEFINE_PCI_DEVICE_TABLE
      pcmcia: convert drivers/pcmcia/* to use module_platform_driver()
      pcmcia: irq: Remove IRQF_DISABLED

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 3e447d0387b7..0b66bfc0e148 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -17,7 +17,6 @@
 
 #include <pcmcia/ss.h>
 
-#include <asm/system.h>
 #include <asm/io.h>
 
 #include "i82092aa.h"

commit 2b2c5d8c1dff8ed42d6d841f56428c0ce2bd71b5
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Dec 27 16:17:46 2011 +0800

    pcmcia: Convert to DEFINE_PCI_DEVICE_TABLE
    
    Convert static struct pci_device_id *[] to static DEFINE_PCI_DEVICE_TABLE
    tables. Also convert to use PCI_DEVICE macro for better readablity.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 3e447d0387b7..17035236ad2e 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -26,14 +26,9 @@
 MODULE_LICENSE("GPL");
 
 /* PCI core routines */
-static struct pci_device_id i82092aa_pci_ids[] = {
-	{
-	      .vendor = PCI_VENDOR_ID_INTEL,
-	      .device = PCI_DEVICE_ID_INTEL_82092AA_0,
-	      .subvendor = PCI_ANY_ID,
-	      .subdevice = PCI_ANY_ID,
-	 },
-	 {} 
+static DEFINE_PCI_DEVICE_TABLE(i82092aa_pci_ids) = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82092AA_0) },
+	{ }
 };
 MODULE_DEVICE_TABLE(pci, i82092aa_pci_ids);
 

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index fc7906eaf228..3e447d0387b7 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -54,7 +54,7 @@ static struct pccard_operations i82092aa_operations = {
 	.set_mem_map		= i82092aa_set_mem_map,
 };
 
-/* The card can do upto 4 sockets, allocate a structure for each of them */
+/* The card can do up to 4 sockets, allocate a structure for each of them */
 
 struct socket_info {
 	int	number;

commit 1ac71e5a35eebee60cdcf15b3980bd94498f037b
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Jul 29 19:27:09 2010 +0200

    pcmcia: convert pcmcia_request_configuration to pcmcia_enable_device
    
    pcmcia_enable_device() now replaces pcmcia_request_configuration().
    Instead of config_req_t, all necessary flags are either passed as
    a parameter to pcmcia_enable_device(), or (in rare circumstances)
    set in struct pcmcia_device -> flags.
    
    With the last remaining user of include/pcmcia/cs.h gone, remove
    all references.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: linux-scsi@vger.kernel.org
    Acked-by: Gustavo F. Padovan <padovan@profusion.mobi> (for drivers/bluetooth)
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 05d0879ce935..fc7906eaf228 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -16,7 +16,6 @@
 #include <linux/device.h>
 
 #include <pcmcia/ss.h>
-#include <pcmcia/cs.h>
 
 #include <asm/system.h>
 #include <asm/io.h>

commit ac8b422838046ffc26be4874a3cbae0d313f4209
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Jul 21 22:38:13 2010 +0200

    pcmcia: remove cs_types.h
    
    Remove cs_types.h which is no longer needed: Most definitions aren't
    used at all, a few can be made away with, and two remaining definitions
    (typedefs, unfortunatley) may be moved to more specific places.
    
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    Acked-by: Marcel Holtmann <marcel@holtmann.org> (for drivers/bluetooth/)
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 3003bb3dfcc0..05d0879ce935 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -15,7 +15,6 @@
 #include <linux/interrupt.h>
 #include <linux/device.h>
 
-#include <pcmcia/cs_types.h>
 #include <pcmcia/ss.h>
 #include <pcmcia/cs.h>
 

commit d7646f7632549124fe70fec8af834c7c1246f365
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Mon Mar 15 21:46:34 2010 +0100

    pcmcia: use dev_pm_ops for class pcmcia_socket_class
    
    Instead of requiring PCMCIA socket drivers to call various functions
    during their (bus) resume and suspend functions, register an own
    dev_pm_ops for this class. This fixes several suspend/resume bugs
    seen on db1xxx-ss, and probably on some other socket drivers, too.
    
    With regard to the asymmetry with only _noirq suspend, but split up
    resume, please see bug 14334 and commit 9905d1b411946fb3 .
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index f5da62653313..3003bb3dfcc0 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -39,27 +39,11 @@ static struct pci_device_id i82092aa_pci_ids[] = {
 };
 MODULE_DEVICE_TABLE(pci, i82092aa_pci_ids);
 
-#ifdef CONFIG_PM
-static int i82092aa_socket_suspend (struct pci_dev *dev, pm_message_t state)
-{
-	return pcmcia_socket_dev_suspend(&dev->dev);
-}
-
-static int i82092aa_socket_resume (struct pci_dev *dev)
-{
-	return pcmcia_socket_dev_resume(&dev->dev);
-}
-#endif
-
 static struct pci_driver i82092aa_pci_driver = {
 	.name           = "i82092aa",
 	.id_table       = i82092aa_pci_ids,
 	.probe          = i82092aa_pci_probe,
 	.remove         = __devexit_p(i82092aa_pci_remove),
-#ifdef CONFIG_PM
-	.suspend        = i82092aa_socket_suspend,
-	.resume         = i82092aa_socket_resume,
-#endif
 };
 
 

commit 7a96e87d6e58a07235a2bc3eff9b093af4937a72
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Mar 13 17:42:39 2010 +0100

    pcmcia: pd6729, i82092: use parent (PCI) resources
    
    A newly added parent resource entry for the root PCI bus, such as
    
    40000000-ffffffff : PCI Bus #00
    
    means that the pd6729 and i82092 drivers cannot allocate iomem as
    freely as before, unless they do so as PCI devices. Therefore, set
    socket->cb_dev so that rsrc_nonstatic.c does the right thing.
    
    Reported-by: Komuro <komurojun-mbn@nifty.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index a04f21c8170f..f5da62653313 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -133,6 +133,7 @@ static int __devinit i82092aa_pci_probe(struct pci_dev *dev, const struct pci_de
 		sockets[i].socket.map_size = 0x1000;
 		sockets[i].socket.irq_mask = 0;
 		sockets[i].socket.pci_irq  = dev->irq;
+		sockets[i].socket.cb_dev  = dev;
 		sockets[i].socket.owner = THIS_MODULE;
 
 		sockets[i].number = i;

commit 827b4649d4626bf97b203b4bcd69476bb9b4e760
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Sep 29 00:10:41 2009 +0200

    PM / PCMCIA: Drop second argument of pcmcia_socket_dev_suspend()
    
    pcmcia_socket_dev_suspend() doesn't use its second argument, so it
    may be dropped safely.
    
    This change is necessary for the subsequent yenta suspend/resume fix.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: stable@kernel.org

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 46561face128..a04f21c8170f 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -42,7 +42,7 @@ MODULE_DEVICE_TABLE(pci, i82092aa_pci_ids);
 #ifdef CONFIG_PM
 static int i82092aa_socket_suspend (struct pci_dev *dev, pm_message_t state)
 {
-	return pcmcia_socket_dev_suspend(&dev->dev, state);
+	return pcmcia_socket_dev_suspend(&dev->dev);
 }
 
 static int i82092aa_socket_resume (struct pci_dev *dev)

commit f36fe2b90fe93e2f586b24f42413bf8cfad8f626
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue May 20 01:02:40 2008 +0300

    pcmcia: remove CVS keywords
    
    This patch removes CVS keywords that weren't updated for a long time
    from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index e13618656ff7..46561face128 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -5,8 +5,6 @@
  *
  * Author: Arjan Van De Ven <arjanv@redhat.com>
  * Loosly based on i82365.c from the pcmcia-cs package
- *
- * $Id: i82092aa.c,v 1.2 2001/10/23 14:43:34 arjanv Exp $
  */
 
 #include <linux/kernel.h>

commit ba66ddfa613886cbb554f7b064dc05bdc2c7138b
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Thu May 1 04:34:51 2008 -0700

    pcmcia: silence section mismatch warnings from pci_driver variables
    
    Silence following warnings:
    WARNING: drivers/pcmcia/built-in.o(.data+0x14e0): Section mismatch in reference from the variable pd6729_pci_drv to the function .devinit.text:pd6729_pci_probe()
    WARNING: drivers/pcmcia/built-in.o(.data+0x14e8): Section mismatch in reference from the variable pd6729_pci_drv to the function .devexit.text:pd6729_pci_remove()
    WARNING: drivers/pcmcia/built-in.o(.data+0x16c0): Section mismatch in reference from the variable i82092aa_pci_drv to the function .devinit.text:i82092aa_pci_probe()
    WARNING: drivers/pcmcia/built-in.o(.data+0x16c8): Section mismatch in reference from the variable i82092aa_pci_drv to the function .devexit.text:i82092aa_pci_remove()
    
    Rename the variables from *_drv to *_driver so modpost ignore the OK
    references to __devinit/__devexit functions.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index e54ecc580d9e..e13618656ff7 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -53,7 +53,7 @@ static int i82092aa_socket_resume (struct pci_dev *dev)
 }
 #endif
 
-static struct pci_driver i82092aa_pci_drv = {
+static struct pci_driver i82092aa_pci_driver = {
 	.name           = "i82092aa",
 	.id_table       = i82092aa_pci_ids,
 	.probe          = i82092aa_pci_probe,
@@ -714,13 +714,13 @@ static int i82092aa_set_mem_map(struct pcmcia_socket *socket, struct pccard_mem_
 
 static int i82092aa_module_init(void)
 {
-	return pci_register_driver(&i82092aa_pci_drv);
+	return pci_register_driver(&i82092aa_pci_driver);
 }
 
 static void i82092aa_module_exit(void)
 {
 	enter("i82092aa_module_exit");
-	pci_unregister_driver(&i82092aa_pci_drv);
+	pci_unregister_driver(&i82092aa_pci_driver);
 	if (sockets[0].io_base>0)
 			 release_region(sockets[0].io_base, 2);
 	leave("i82092aa_module_exit");

commit f96ee7a41ed93ce5962961eb07c2afe8cddb6603
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Mon Feb 4 23:35:48 2008 -0800

    PCI: drivers/pcmcia/i82092.c: fix up after pci_bus_region changes
    
    drivers/pcmcia/i82092.c: In function 'i82092aa_set_mem_map':
    drivers/pcmcia/i82092.c:650: warning: format '%lx' expects type 'long unsigned int', but argument 3 has type 'resource_size_t'
    drivers/pcmcia/i82092.c:650: warning: format '%lx' expects type 'long unsigned int', but argument 4 has type 'resource_size_t'
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 749515534cc0..e54ecc580d9e 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -647,7 +647,12 @@ static int i82092aa_set_mem_map(struct pcmcia_socket *socket, struct pccard_mem_
 	if ( (mem->card_start > 0x3ffffff) || (region.start > region.end) ||
 	     (mem->speed > 1000) ) {
 		leave("i82092aa_set_mem_map: invalid address / speed");
-		printk("invalid mem map for socket %i : %lx to %lx with a start of %x \n",sock,region.start, region.end, mem->card_start);
+		printk("invalid mem map for socket %i: %llx to %llx with a "
+			"start of %x\n",
+			sock,
+			(unsigned long long)region.start,
+			(unsigned long long)region.end,
+			mem->card_start);
 		return -EINVAL;
 	}
 	

commit 906da809c5be30b4c7f32bb6a489fb25ad794878
Author: Olof Johansson <olof@lixom.net>
Date:   Mon Feb 4 22:27:35 2008 -0800

    pcmcia: replace kio_addr_t with unsigned int everywhere
    
    Remove kio_addr_t, and replace it with unsigned int.  No known architecture
    needs more than 32 bits for IO addresses and ports and having a separate type
    for it is just messy.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index df21e2d16f87..749515534cc0 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -82,7 +82,7 @@ struct socket_info {
 				    1 = empty socket, 
 				    2 = card but not initialized,
 				    3 = operational card */
-	kio_addr_t io_base; 	/* base io address of the socket */
+	unsigned int io_base; 	/* base io address of the socket */
 	
 	struct pcmcia_socket socket;
 	struct pci_dev *dev;	/* The PCI device for the socket */

commit 873733188a019acdb7fa253011cbdc0a8afd97f3
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Sep 12 17:00:10 2006 +0200

    Driver core: convert pcmcia code to use struct device
    
    Converts from using struct "class_device" to "struct device" making
    everything show up properly in /sys/devices/ with symlinks from the
    /sys/class directory.
    
    Cc: <linux-pcmcia@lists.infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index c2ea07aa7a12..df21e2d16f87 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -161,7 +161,7 @@ static int __devinit i82092aa_pci_probe(struct pci_dev *dev, const struct pci_de
 	pci_set_drvdata(dev, &sockets[i].socket);
 
 	for (i = 0; i<socket_count; i++) {
-		sockets[i].socket.dev.dev = &dev->dev;
+		sockets[i].socket.dev.parent = &dev->dev;
 		sockets[i].socket.ops = &i82092aa_operations;
 		sockets[i].socket.resource_ops = &pccard_nonstatic_ops;
 		ret = pcmcia_register_socket(&sockets[i].socket);

commit f465ce176fb2f1778a04fc3fcb2b8aa564901419
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Fri Oct 20 14:44:13 2006 -0700

    [PATCH] i82092: wire up errors from pci_register_driver()
    
    debugging goo removed to not leave assymetry in it after possible "leave"
    removal.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index d316d956f3b1..c2ea07aa7a12 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -709,10 +709,7 @@ static int i82092aa_set_mem_map(struct pcmcia_socket *socket, struct pccard_mem_
 
 static int i82092aa_module_init(void)
 {
-	enter("i82092aa_module_init");
-	pci_register_driver(&i82092aa_pci_drv);
-	leave("i82092aa_module_init");
-	return 0;
+	return pci_register_driver(&i82092aa_pci_drv);
 }
 
 static void i82092aa_module_exit(void)

commit f237de58b13bf65ba2f7fab896daacb92ae7ddef
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Fri Oct 20 14:44:13 2006 -0700

    [PATCH] CONFIG_PM=n slim: drivers/pcmcia/*
    
    Remove some code which is unneeded if CONFIG_PM=n.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 82715f448957..d316d956f3b1 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -41,6 +41,7 @@ static struct pci_device_id i82092aa_pci_ids[] = {
 };
 MODULE_DEVICE_TABLE(pci, i82092aa_pci_ids);
 
+#ifdef CONFIG_PM
 static int i82092aa_socket_suspend (struct pci_dev *dev, pm_message_t state)
 {
 	return pcmcia_socket_dev_suspend(&dev->dev, state);
@@ -50,14 +51,17 @@ static int i82092aa_socket_resume (struct pci_dev *dev)
 {
 	return pcmcia_socket_dev_resume(&dev->dev);
 }
+#endif
 
 static struct pci_driver i82092aa_pci_drv = {
 	.name           = "i82092aa",
 	.id_table       = i82092aa_pci_ids,
 	.probe          = i82092aa_pci_probe,
 	.remove         = __devexit_p(i82092aa_pci_remove),
+#ifdef CONFIG_PM
 	.suspend        = i82092aa_socket_suspend,
 	.resume         = i82092aa_socket_resume,
+#endif
 };
 
 

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 2163aa75a257..82715f448957 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -315,7 +315,7 @@ static int to_cycles(int ns)
 
 /* Interrupt handler functionality */
 
-static irqreturn_t i82092aa_interrupt(int irq, void *dev, struct pt_regs *regs)
+static irqreturn_t i82092aa_interrupt(int irq, void *dev)
 {
 	int i;
 	int loopcount = 0;

commit dace145374b8e39aeb920304c358ab5e220341ab
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:38 2006 -0700

    [PATCH] irq-flags: misc drivers: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index d5f03a338c6c..2163aa75a257 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -149,7 +149,7 @@ static int __devinit i82092aa_pci_probe(struct pci_dev *dev, const struct pci_de
 
 	/* Register the interrupt handler */
 	dprintk(KERN_DEBUG "Requesting interrupt %i \n",dev->irq);
-	if ((ret = request_irq(dev->irq, i82092aa_interrupt, SA_SHIRQ, "i82092aa", i82092aa_interrupt))) {
+	if ((ret = request_irq(dev->irq, i82092aa_interrupt, IRQF_SHARED, "i82092aa", i82092aa_interrupt))) {
 		printk(KERN_ERR "i82092aa: Failed to register IRQ %d, aborting\n", dev->irq);
 		goto err_out_free_res;
 	}

commit e904663b4d511884145df54bead401840389853a
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Jan 10 21:35:49 2006 +0100

    [PATCH] pcmcia: remove include of config.h
    
    Remove the inclusion of include/config.h as it isn't needed any longer.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index 7979c85df3dc..d5f03a338c6c 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -10,7 +10,6 @@
  */
 
 #include <linux/kernel.h>
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/init.h>

commit 9da4bc6d6a38c1c3d850c046d0aee324c1a2e52a
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Nov 12 23:56:33 2005 +0100

    [PATCH] pcmcia: remove get_socket callback
    
    The .get_socket callback is never used by the PCMCIA core, therefore remove
    it.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
index f3fdc748659d..7979c85df3dc 100644
--- a/drivers/pcmcia/i82092.c
+++ b/drivers/pcmcia/i82092.c
@@ -66,7 +66,6 @@ static struct pci_driver i82092aa_pci_drv = {
 static struct pccard_operations i82092aa_operations = {
 	.init 		 	= i82092aa_init,
 	.get_status		= i82092aa_get_status,
-	.get_socket		= i82092aa_get_socket,
 	.set_socket		= i82092aa_set_socket,
 	.set_io_map		= i82092aa_set_io_map,
 	.set_mem_map		= i82092aa_set_mem_map,
@@ -482,78 +481,6 @@ static int i82092aa_get_status(struct pcmcia_socket *socket, u_int *value)
 }
 
 
-static int i82092aa_get_socket(struct pcmcia_socket *socket, socket_state_t *state) 
-{
-	unsigned int sock = container_of(socket, struct socket_info, socket)->number;
-	unsigned char reg,vcc,vpp;
-	
-	enter("i82092aa_get_socket");
-	state->flags    = 0;
-	state->Vcc      = 0;
-	state->Vpp      = 0;
-	state->io_irq   = 0;
-	state->csc_mask = 0;
-
-	/* First the power status of the socket */
-	reg = indirect_read(sock,I365_POWER); /* PCTRL - Power Control Register */
-
-	if (reg & I365_PWR_AUTO)
-		state->flags |= SS_PWR_AUTO;  /* Automatic Power Switch */
-		
-	if (reg & I365_PWR_OUT)
-		state->flags |= SS_OUTPUT_ENA; /* Output signals are enabled */
-		
-	vcc = reg & I365_VCC_MASK;    vpp = reg & I365_VPP1_MASK;
-	
-	if (reg & I365_VCC_5V) { /* Can still be 3.3V, in this case the Vcc value will be overwritten later */
-		state->Vcc = 50;
-		
-		if (vpp == I365_VPP1_5V)
-			state->Vpp = 50;
-		if (vpp == I365_VPP1_12V)
-			state->Vpp = 120;
-			
-	}
-	
-	if ((reg & I365_VCC_3V)==I365_VCC_3V)
-		state->Vcc = 33;
-	
-	
-	/* Now the IO card, RESET flags and IO interrupt */
-	
-	reg = indirect_read(sock, I365_INTCTL); /* IGENC, Interrupt and General Control */
-	
-	if ((reg & I365_PC_RESET)==0)
-		state->flags |= SS_RESET;
-	if (reg & I365_PC_IOCARD) 
-		state->flags |= SS_IOCARD; /* This is an IO card */
-	
-	/* Set the IRQ number */
-	if (sockets[sock].dev!=NULL)
-		state->io_irq = sockets[sock].dev->irq;
-	
-	/* Card status change */
-	reg = indirect_read(sock, I365_CSCINT); /* CSCICR, Card Status Change Interrupt Configuration */
-	
-	if (reg & I365_CSC_DETECT) 
-		state->csc_mask |= SS_DETECT; /* Card detect is enabled */
-	
-	if (state->flags & SS_IOCARD) {/* IO Cards behave different */
-		if (reg & I365_CSC_STSCHG)
-			state->csc_mask |= SS_STSCHG;
-	} else {
-		if (reg & I365_CSC_BVD1) 
-			state->csc_mask |= SS_BATDEAD;
-		if (reg & I365_CSC_BVD2) 
-			state->csc_mask |= SS_BATWARN;
-		if (reg & I365_CSC_READY) 
-			state->csc_mask |= SS_READY;
-	}
-		
-	leave("i82092aa_get_socket");
-	return 0;
-}
-
 static int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *state) 
 {
 	unsigned int sock = container_of(socket, struct socket_info, socket)->number;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c
new file mode 100644
index 000000000000..f3fdc748659d
--- /dev/null
+++ b/drivers/pcmcia/i82092.c
@@ -0,0 +1,799 @@
+/* 
+ * Driver for Intel I82092AA PCI-PCMCIA bridge.
+ *
+ * (C) 2001 Red Hat, Inc.
+ *
+ * Author: Arjan Van De Ven <arjanv@redhat.com>
+ * Loosly based on i82365.c from the pcmcia-cs package
+ *
+ * $Id: i82092aa.c,v 1.2 2001/10/23 14:43:34 arjanv Exp $
+ */
+
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+
+#include <pcmcia/cs_types.h>
+#include <pcmcia/ss.h>
+#include <pcmcia/cs.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+
+#include "i82092aa.h"
+#include "i82365.h"
+
+MODULE_LICENSE("GPL");
+
+/* PCI core routines */
+static struct pci_device_id i82092aa_pci_ids[] = {
+	{
+	      .vendor = PCI_VENDOR_ID_INTEL,
+	      .device = PCI_DEVICE_ID_INTEL_82092AA_0,
+	      .subvendor = PCI_ANY_ID,
+	      .subdevice = PCI_ANY_ID,
+	 },
+	 {} 
+};
+MODULE_DEVICE_TABLE(pci, i82092aa_pci_ids);
+
+static int i82092aa_socket_suspend (struct pci_dev *dev, pm_message_t state)
+{
+	return pcmcia_socket_dev_suspend(&dev->dev, state);
+}
+
+static int i82092aa_socket_resume (struct pci_dev *dev)
+{
+	return pcmcia_socket_dev_resume(&dev->dev);
+}
+
+static struct pci_driver i82092aa_pci_drv = {
+	.name           = "i82092aa",
+	.id_table       = i82092aa_pci_ids,
+	.probe          = i82092aa_pci_probe,
+	.remove         = __devexit_p(i82092aa_pci_remove),
+	.suspend        = i82092aa_socket_suspend,
+	.resume         = i82092aa_socket_resume,
+};
+
+
+/* the pccard structure and its functions */
+static struct pccard_operations i82092aa_operations = {
+	.init 		 	= i82092aa_init,
+	.get_status		= i82092aa_get_status,
+	.get_socket		= i82092aa_get_socket,
+	.set_socket		= i82092aa_set_socket,
+	.set_io_map		= i82092aa_set_io_map,
+	.set_mem_map		= i82092aa_set_mem_map,
+};
+
+/* The card can do upto 4 sockets, allocate a structure for each of them */
+
+struct socket_info {
+	int	number;
+	int	card_state; 	/*  0 = no socket,
+				    1 = empty socket, 
+				    2 = card but not initialized,
+				    3 = operational card */
+	kio_addr_t io_base; 	/* base io address of the socket */
+	
+	struct pcmcia_socket socket;
+	struct pci_dev *dev;	/* The PCI device for the socket */
+};
+
+#define MAX_SOCKETS 4
+static struct socket_info sockets[MAX_SOCKETS];
+static int socket_count;  /* shortcut */                                  	                                	
+
+
+static int __devinit i82092aa_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	unsigned char configbyte;
+	int i, ret;
+	
+	enter("i82092aa_pci_probe");
+	
+	if ((ret = pci_enable_device(dev)))
+		return ret;
+		
+	pci_read_config_byte(dev, 0x40, &configbyte);  /* PCI Configuration Control */
+	switch(configbyte&6) {
+		case 0:
+			socket_count = 2;
+			break;
+		case 2:
+			socket_count = 1;
+			break;
+		case 4:
+		case 6:
+			socket_count = 4;
+			break;
+			
+		default:
+			printk(KERN_ERR "i82092aa: Oops, you did something we didn't think of.\n");
+			ret = -EIO;
+			goto err_out_disable;
+	}
+	printk(KERN_INFO "i82092aa: configured as a %d socket device.\n", socket_count);
+
+	if (!request_region(pci_resource_start(dev, 0), 2, "i82092aa")) {
+		ret = -EBUSY;
+		goto err_out_disable;
+	}
+	
+	for (i = 0;i<socket_count;i++) {
+		sockets[i].card_state = 1; /* 1 = present but empty */
+		sockets[i].io_base = pci_resource_start(dev, 0);
+		sockets[i].socket.features |= SS_CAP_PCCARD;
+		sockets[i].socket.map_size = 0x1000;
+		sockets[i].socket.irq_mask = 0;
+		sockets[i].socket.pci_irq  = dev->irq;
+		sockets[i].socket.owner = THIS_MODULE;
+
+		sockets[i].number = i;
+		
+		if (card_present(i)) {
+			sockets[i].card_state = 3;
+			dprintk(KERN_DEBUG "i82092aa: slot %i is occupied\n",i);
+		} else {
+			dprintk(KERN_DEBUG "i82092aa: slot %i is vacant\n",i);
+		}
+	}
+		
+	/* Now, specifiy that all interrupts are to be done as PCI interrupts */
+	configbyte = 0xFF; /* bitmask, one bit per event, 1 = PCI interrupt, 0 = ISA interrupt */
+	pci_write_config_byte(dev, 0x50, configbyte); /* PCI Interrupt Routing Register */
+
+	/* Register the interrupt handler */
+	dprintk(KERN_DEBUG "Requesting interrupt %i \n",dev->irq);
+	if ((ret = request_irq(dev->irq, i82092aa_interrupt, SA_SHIRQ, "i82092aa", i82092aa_interrupt))) {
+		printk(KERN_ERR "i82092aa: Failed to register IRQ %d, aborting\n", dev->irq);
+		goto err_out_free_res;
+	}
+
+	pci_set_drvdata(dev, &sockets[i].socket);
+
+	for (i = 0; i<socket_count; i++) {
+		sockets[i].socket.dev.dev = &dev->dev;
+		sockets[i].socket.ops = &i82092aa_operations;
+		sockets[i].socket.resource_ops = &pccard_nonstatic_ops;
+		ret = pcmcia_register_socket(&sockets[i].socket);
+		if (ret) {
+			goto err_out_free_sockets;
+		}
+	}
+
+	leave("i82092aa_pci_probe");
+	return 0;
+
+err_out_free_sockets:
+	if (i) {
+		for (i--;i>=0;i--) {
+			pcmcia_unregister_socket(&sockets[i].socket);
+		}
+	}
+	free_irq(dev->irq, i82092aa_interrupt);
+err_out_free_res:
+	release_region(pci_resource_start(dev, 0), 2);
+err_out_disable:
+	pci_disable_device(dev);
+	return ret;			
+}
+
+static void __devexit i82092aa_pci_remove(struct pci_dev *dev)
+{
+	struct pcmcia_socket *socket = pci_get_drvdata(dev);
+
+	enter("i82092aa_pci_remove");
+	
+	free_irq(dev->irq, i82092aa_interrupt);
+
+	if (socket)
+		pcmcia_unregister_socket(socket);
+
+	leave("i82092aa_pci_remove");
+}
+
+static DEFINE_SPINLOCK(port_lock);
+
+/* basic value read/write functions */
+
+static unsigned char indirect_read(int socket, unsigned short reg)
+{
+	unsigned short int port;
+	unsigned char val;
+	unsigned long flags;
+	spin_lock_irqsave(&port_lock,flags);
+	reg += socket * 0x40;
+	port = sockets[socket].io_base;
+	outb(reg,port);
+	val = inb(port+1);
+	spin_unlock_irqrestore(&port_lock,flags);
+	return val;
+}
+
+#if 0
+static unsigned short indirect_read16(int socket, unsigned short reg)
+{
+	unsigned short int port;
+	unsigned short tmp;
+	unsigned long flags;
+	spin_lock_irqsave(&port_lock,flags);
+	reg  = reg + socket * 0x40;
+	port = sockets[socket].io_base;
+	outb(reg,port);
+	tmp = inb(port+1);
+	reg++;
+	outb(reg,port);
+	tmp = tmp | (inb(port+1)<<8);
+	spin_unlock_irqrestore(&port_lock,flags);
+	return tmp;
+}
+#endif
+
+static void indirect_write(int socket, unsigned short reg, unsigned char value)
+{
+	unsigned short int port;
+	unsigned long flags;
+	spin_lock_irqsave(&port_lock,flags);
+	reg = reg + socket * 0x40;
+	port = sockets[socket].io_base; 
+	outb(reg,port);
+	outb(value,port+1);
+	spin_unlock_irqrestore(&port_lock,flags);
+}
+
+static void indirect_setbit(int socket, unsigned short reg, unsigned char mask)
+{
+	unsigned short int port;
+	unsigned char val;
+	unsigned long flags;
+	spin_lock_irqsave(&port_lock,flags);
+	reg = reg + socket * 0x40;
+	port = sockets[socket].io_base; 
+	outb(reg,port);
+	val = inb(port+1);
+	val |= mask;
+	outb(reg,port);
+	outb(val,port+1);
+	spin_unlock_irqrestore(&port_lock,flags);
+}
+
+
+static void indirect_resetbit(int socket, unsigned short reg, unsigned char mask)
+{
+	unsigned short int port;
+	unsigned char val;
+	unsigned long flags;
+	spin_lock_irqsave(&port_lock,flags);
+	reg = reg + socket * 0x40;
+	port = sockets[socket].io_base; 
+	outb(reg,port);
+	val = inb(port+1);
+	val &= ~mask;
+	outb(reg,port);
+	outb(val,port+1);
+	spin_unlock_irqrestore(&port_lock,flags);
+}
+
+static void indirect_write16(int socket, unsigned short reg, unsigned short value)
+{
+	unsigned short int port;
+	unsigned char val;
+	unsigned long flags;
+	spin_lock_irqsave(&port_lock,flags);
+	reg = reg + socket * 0x40;
+	port = sockets[socket].io_base; 
+	
+	outb(reg,port);
+	val = value & 255;
+	outb(val,port+1);
+	
+	reg++;
+	
+	outb(reg,port);
+	val = value>>8;
+	outb(val,port+1);
+	spin_unlock_irqrestore(&port_lock,flags);
+}
+
+/* simple helper functions */
+/* External clock time, in nanoseconds.  120 ns = 8.33 MHz */
+static int cycle_time = 120;
+
+static int to_cycles(int ns)
+{
+	if (cycle_time!=0)
+		return ns/cycle_time;
+	else
+		return 0;
+}
+    
+
+/* Interrupt handler functionality */
+
+static irqreturn_t i82092aa_interrupt(int irq, void *dev, struct pt_regs *regs)
+{
+	int i;
+	int loopcount = 0;
+	int handled = 0;
+
+	unsigned int events, active=0;
+	
+/*	enter("i82092aa_interrupt");*/
+	
+	while (1) {
+		loopcount++;
+		if (loopcount>20) {
+			printk(KERN_ERR "i82092aa: infinite eventloop in interrupt \n");
+			break;
+		}
+		
+		active = 0;
+		
+		for (i=0;i<socket_count;i++) {
+			int csc;
+			if (sockets[i].card_state==0) /* Inactive socket, should not happen */
+				continue;
+			
+			csc = indirect_read(i,I365_CSC); /* card status change register */
+			
+			if (csc==0)  /* no events on this socket */
+			   	continue;
+			handled = 1;
+			events = 0;
+			 
+			if (csc & I365_CSC_DETECT) {
+				events |= SS_DETECT;
+				printk("Card detected in socket %i!\n",i);
+			 }
+			
+			if (indirect_read(i,I365_INTCTL) & I365_PC_IOCARD) { 
+				/* For IO/CARDS, bit 0 means "read the card" */
+				events |= (csc & I365_CSC_STSCHG) ? SS_STSCHG : 0; 
+			} else {
+				/* Check for battery/ready events */
+				events |= (csc & I365_CSC_BVD1) ? SS_BATDEAD : 0;
+				events |= (csc & I365_CSC_BVD2) ? SS_BATWARN : 0;
+				events |= (csc & I365_CSC_READY) ? SS_READY : 0;
+			}
+			
+			if (events) {
+				pcmcia_parse_events(&sockets[i].socket, events);
+			}
+			active |= events;
+		}
+				
+		if (active==0) /* no more events to handle */
+			break;				
+		
+	}
+	return IRQ_RETVAL(handled);
+/*	leave("i82092aa_interrupt");*/
+}
+
+
+
+/* socket functions */
+
+static int card_present(int socketno)
+{	
+	unsigned int val;
+	enter("card_present");
+	
+	if ((socketno<0) || (socketno >= MAX_SOCKETS))
+		return 0;
+	if (sockets[socketno].io_base == 0)
+		return 0;
+
+		
+	val = indirect_read(socketno, 1); /* Interface status register */
+	if ((val&12)==12) {
+		leave("card_present 1");
+		return 1;
+	}
+		
+	leave("card_present 0");
+	return 0;
+}
+
+static void set_bridge_state(int sock)
+{
+	enter("set_bridge_state");
+	indirect_write(sock, I365_GBLCTL,0x00);
+	indirect_write(sock, I365_GENCTL,0x00);
+	
+	indirect_setbit(sock, I365_INTCTL,0x08);
+	leave("set_bridge_state");
+}
+
+
+
+
+
+      
+static int i82092aa_init(struct pcmcia_socket *sock)
+{
+	int i;
+	struct resource res = { .start = 0, .end = 0x0fff };
+        pccard_io_map io = { 0, 0, 0, 0, 1 };
+	pccard_mem_map mem = { .res = &res, };
+        
+        enter("i82092aa_init");
+                        
+        for (i = 0; i < 2; i++) {
+        	io.map = i;
+                i82092aa_set_io_map(sock, &io);
+	}
+        for (i = 0; i < 5; i++) {
+        	mem.map = i;
+                i82092aa_set_mem_map(sock, &mem);
+	}
+	
+	leave("i82092aa_init");
+	return 0;
+}
+                                                                                                                                                                                                                                              
+static int i82092aa_get_status(struct pcmcia_socket *socket, u_int *value)
+{
+	unsigned int sock = container_of(socket, struct socket_info, socket)->number;
+	unsigned int status;
+	
+	enter("i82092aa_get_status");
+	
+	status = indirect_read(sock,I365_STATUS); /* Interface Status Register */
+	*value = 0;
+	
+	if ((status & I365_CS_DETECT) == I365_CS_DETECT) {
+		*value |= SS_DETECT;
+	}
+		
+	/* IO cards have a different meaning of bits 0,1 */
+	/* Also notice the inverse-logic on the bits */
+	 if (indirect_read(sock, I365_INTCTL) & I365_PC_IOCARD)	{
+	 	/* IO card */
+	 	if (!(status & I365_CS_STSCHG))
+	 		*value |= SS_STSCHG;
+	 } else { /* non I/O card */
+	 	if (!(status & I365_CS_BVD1))
+	 		*value |= SS_BATDEAD;
+	 	if (!(status & I365_CS_BVD2))
+	 		*value |= SS_BATWARN;
+	 		
+	 }
+	 
+	 if (status & I365_CS_WRPROT)
+	 	(*value) |= SS_WRPROT;	/* card is write protected */
+	 
+	 if (status & I365_CS_READY)
+	 	(*value) |= SS_READY;    /* card is not busy */
+	 	
+	 if (status & I365_CS_POWERON)
+	 	(*value) |= SS_POWERON;  /* power is applied to the card */
+
+
+	leave("i82092aa_get_status");
+	return 0;
+}
+
+
+static int i82092aa_get_socket(struct pcmcia_socket *socket, socket_state_t *state) 
+{
+	unsigned int sock = container_of(socket, struct socket_info, socket)->number;
+	unsigned char reg,vcc,vpp;
+	
+	enter("i82092aa_get_socket");
+	state->flags    = 0;
+	state->Vcc      = 0;
+	state->Vpp      = 0;
+	state->io_irq   = 0;
+	state->csc_mask = 0;
+
+	/* First the power status of the socket */
+	reg = indirect_read(sock,I365_POWER); /* PCTRL - Power Control Register */
+
+	if (reg & I365_PWR_AUTO)
+		state->flags |= SS_PWR_AUTO;  /* Automatic Power Switch */
+		
+	if (reg & I365_PWR_OUT)
+		state->flags |= SS_OUTPUT_ENA; /* Output signals are enabled */
+		
+	vcc = reg & I365_VCC_MASK;    vpp = reg & I365_VPP1_MASK;
+	
+	if (reg & I365_VCC_5V) { /* Can still be 3.3V, in this case the Vcc value will be overwritten later */
+		state->Vcc = 50;
+		
+		if (vpp == I365_VPP1_5V)
+			state->Vpp = 50;
+		if (vpp == I365_VPP1_12V)
+			state->Vpp = 120;
+			
+	}
+	
+	if ((reg & I365_VCC_3V)==I365_VCC_3V)
+		state->Vcc = 33;
+	
+	
+	/* Now the IO card, RESET flags and IO interrupt */
+	
+	reg = indirect_read(sock, I365_INTCTL); /* IGENC, Interrupt and General Control */
+	
+	if ((reg & I365_PC_RESET)==0)
+		state->flags |= SS_RESET;
+	if (reg & I365_PC_IOCARD) 
+		state->flags |= SS_IOCARD; /* This is an IO card */
+	
+	/* Set the IRQ number */
+	if (sockets[sock].dev!=NULL)
+		state->io_irq = sockets[sock].dev->irq;
+	
+	/* Card status change */
+	reg = indirect_read(sock, I365_CSCINT); /* CSCICR, Card Status Change Interrupt Configuration */
+	
+	if (reg & I365_CSC_DETECT) 
+		state->csc_mask |= SS_DETECT; /* Card detect is enabled */
+	
+	if (state->flags & SS_IOCARD) {/* IO Cards behave different */
+		if (reg & I365_CSC_STSCHG)
+			state->csc_mask |= SS_STSCHG;
+	} else {
+		if (reg & I365_CSC_BVD1) 
+			state->csc_mask |= SS_BATDEAD;
+		if (reg & I365_CSC_BVD2) 
+			state->csc_mask |= SS_BATWARN;
+		if (reg & I365_CSC_READY) 
+			state->csc_mask |= SS_READY;
+	}
+		
+	leave("i82092aa_get_socket");
+	return 0;
+}
+
+static int i82092aa_set_socket(struct pcmcia_socket *socket, socket_state_t *state) 
+{
+	unsigned int sock = container_of(socket, struct socket_info, socket)->number;
+	unsigned char reg;
+	
+	enter("i82092aa_set_socket");
+	
+	/* First, set the global controller options */
+	
+	set_bridge_state(sock);
+	
+	/* Values for the IGENC register */
+	
+	reg = 0;
+	if (!(state->flags & SS_RESET)) 	/* The reset bit has "inverse" logic */
+		reg = reg | I365_PC_RESET;  
+	if (state->flags & SS_IOCARD) 
+		reg = reg | I365_PC_IOCARD;
+		
+	indirect_write(sock,I365_INTCTL,reg); /* IGENC, Interrupt and General Control Register */
+	
+	/* Power registers */
+	
+	reg = I365_PWR_NORESET; /* default: disable resetdrv on resume */
+	
+	if (state->flags & SS_PWR_AUTO) {
+		printk("Auto power\n");
+		reg |= I365_PWR_AUTO;	/* automatic power mngmnt */
+	}
+	if (state->flags & SS_OUTPUT_ENA) {
+		printk("Power Enabled \n");
+		reg |= I365_PWR_OUT;	/* enable power */
+	}
+	
+	switch (state->Vcc) {
+		case 0:	
+			break;
+		case 50: 
+			printk("setting voltage to Vcc to 5V on socket %i\n",sock);
+			reg |= I365_VCC_5V;
+			break;
+		default:
+			printk("i82092aa: i82092aa_set_socket called with invalid VCC power value: %i ", state->Vcc);
+			leave("i82092aa_set_socket");
+			return -EINVAL;
+	}
+	
+	
+	switch (state->Vpp) {
+		case 0:	
+			printk("not setting Vpp on socket %i\n",sock);
+			break;
+		case 50: 
+			printk("setting Vpp to 5.0 for socket %i\n",sock);
+			reg |= I365_VPP1_5V | I365_VPP2_5V;
+			break;
+		case 120: 
+			printk("setting Vpp to 12.0\n");
+			reg |= I365_VPP1_12V | I365_VPP2_12V;
+			break;
+		default:
+			printk("i82092aa: i82092aa_set_socket called with invalid VPP power value: %i ", state->Vcc);
+			leave("i82092aa_set_socket");
+			return -EINVAL;
+	}
+	
+	if (reg != indirect_read(sock,I365_POWER)) /* only write if changed */
+		indirect_write(sock,I365_POWER,reg);
+		
+	/* Enable specific interrupt events */
+	
+	reg = 0x00;
+	if (state->csc_mask & SS_DETECT) {
+		reg |= I365_CSC_DETECT;
+	}
+	if (state->flags & SS_IOCARD) {
+		if (state->csc_mask & SS_STSCHG)
+			reg |= I365_CSC_STSCHG;
+	} else {
+		if (state->csc_mask & SS_BATDEAD) 
+			reg |= I365_CSC_BVD1;
+		if (state->csc_mask & SS_BATWARN) 
+			reg |= I365_CSC_BVD2;
+		if (state->csc_mask & SS_READY) 
+			reg |= I365_CSC_READY; 
+		                        
+	}
+	
+	/* now write the value and clear the (probably bogus) pending stuff by doing a dummy read*/
+	
+	indirect_write(sock,I365_CSCINT,reg);
+	(void)indirect_read(sock,I365_CSC);
+
+	leave("i82092aa_set_socket");
+	return 0;
+}
+
+static int i82092aa_set_io_map(struct pcmcia_socket *socket, struct pccard_io_map *io)
+{
+	unsigned int sock = container_of(socket, struct socket_info, socket)->number;
+	unsigned char map, ioctl;
+	
+	enter("i82092aa_set_io_map");
+	
+	map = io->map;
+	
+	/* Check error conditions */	
+	if (map > 1) {
+		leave("i82092aa_set_io_map with invalid map");
+		return -EINVAL;
+	}
+	if ((io->start > 0xffff) || (io->stop > 0xffff) || (io->stop < io->start)){
+		leave("i82092aa_set_io_map with invalid io");
+		return -EINVAL;
+	}
+
+	/* Turn off the window before changing anything */ 
+	if (indirect_read(sock, I365_ADDRWIN) & I365_ENA_IO(map))
+		indirect_resetbit(sock, I365_ADDRWIN, I365_ENA_IO(map));
+
+/*	printk("set_io_map: Setting range to %x - %x \n",io->start,io->stop);  */
+	
+	/* write the new values */
+	indirect_write16(sock,I365_IO(map)+I365_W_START,io->start);            	
+	indirect_write16(sock,I365_IO(map)+I365_W_STOP,io->stop);            	
+	            	
+	ioctl = indirect_read(sock,I365_IOCTL) & ~I365_IOCTL_MASK(map);
+	
+	if (io->flags & (MAP_16BIT|MAP_AUTOSZ))
+		ioctl |= I365_IOCTL_16BIT(map);
+		
+	indirect_write(sock,I365_IOCTL,ioctl);
+	
+	/* Turn the window back on if needed */
+	if (io->flags & MAP_ACTIVE)
+		indirect_setbit(sock,I365_ADDRWIN,I365_ENA_IO(map));
+			
+	leave("i82092aa_set_io_map");	
+	return 0;
+}
+
+static int i82092aa_set_mem_map(struct pcmcia_socket *socket, struct pccard_mem_map *mem)
+{
+	struct socket_info *sock_info = container_of(socket, struct socket_info, socket);
+	unsigned int sock = sock_info->number;
+	struct pci_bus_region region;
+	unsigned short base, i;
+	unsigned char map;
+	
+	enter("i82092aa_set_mem_map");
+
+	pcibios_resource_to_bus(sock_info->dev, &region, mem->res);
+	
+	map = mem->map;
+	if (map > 4) {
+		leave("i82092aa_set_mem_map: invalid map");
+		return -EINVAL;
+	}
+	
+	
+	if ( (mem->card_start > 0x3ffffff) || (region.start > region.end) ||
+	     (mem->speed > 1000) ) {
+		leave("i82092aa_set_mem_map: invalid address / speed");
+		printk("invalid mem map for socket %i : %lx to %lx with a start of %x \n",sock,region.start, region.end, mem->card_start);
+		return -EINVAL;
+	}
+	
+	/* Turn off the window before changing anything */
+	if (indirect_read(sock, I365_ADDRWIN) & I365_ENA_MEM(map))
+	              indirect_resetbit(sock, I365_ADDRWIN, I365_ENA_MEM(map));
+	                 
+	                 
+/* 	printk("set_mem_map: Setting map %i range to %x - %x on socket %i, speed is %i, active = %i \n",map, region.start,region.end,sock,mem->speed,mem->flags & MAP_ACTIVE);  */
+
+	/* write the start address */
+	base = I365_MEM(map);
+	i = (region.start >> 12) & 0x0fff;
+	if (mem->flags & MAP_16BIT) 
+		i |= I365_MEM_16BIT;
+	if (mem->flags & MAP_0WS)
+		i |= I365_MEM_0WS;	
+	indirect_write16(sock,base+I365_W_START,i);
+		               
+	/* write the stop address */
+	
+	i= (region.end >> 12) & 0x0fff;
+	switch (to_cycles(mem->speed)) {
+		case 0:
+			break;
+		case 1:
+			i |= I365_MEM_WS0;
+			break;
+		case 2:
+			i |= I365_MEM_WS1;
+			break;
+		default:
+			i |= I365_MEM_WS1 | I365_MEM_WS0;
+			break;
+	}
+	
+	indirect_write16(sock,base+I365_W_STOP,i);
+	
+	/* card start */
+	
+	i = ((mem->card_start - region.start) >> 12) & 0x3fff;
+	if (mem->flags & MAP_WRPROT)
+		i |= I365_MEM_WRPROT;
+	if (mem->flags & MAP_ATTRIB) {
+/*		printk("requesting attribute memory for socket %i\n",sock);*/
+		i |= I365_MEM_REG;
+	} else {
+/*		printk("requesting normal memory for socket %i\n",sock);*/
+	}
+	indirect_write16(sock,base+I365_W_OFF,i);
+	
+	/* Enable the window if necessary */
+	if (mem->flags & MAP_ACTIVE)
+		indirect_setbit(sock, I365_ADDRWIN, I365_ENA_MEM(map));
+	            
+	leave("i82092aa_set_mem_map");
+	return 0;
+}
+
+static int i82092aa_module_init(void)
+{
+	enter("i82092aa_module_init");
+	pci_register_driver(&i82092aa_pci_drv);
+	leave("i82092aa_module_init");
+	return 0;
+}
+
+static void i82092aa_module_exit(void)
+{
+	enter("i82092aa_module_exit");
+	pci_unregister_driver(&i82092aa_pci_drv);
+	if (sockets[0].io_base>0)
+			 release_region(sockets[0].io_base, 2);
+	leave("i82092aa_module_exit");
+}
+
+module_init(i82092aa_module_init);
+module_exit(i82092aa_module_exit);
+
