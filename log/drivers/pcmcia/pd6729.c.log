commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:03:40 2018 -0700

    treewide: kzalloc() -> kcalloc()
    
    The kzalloc() function has a 2-factor argument form, kcalloc(). This
    patch replaces cases of:
    
            kzalloc(a * b, gfp)
    
    with:
            kcalloc(a * b, gfp)
    
    as well as handling cases of:
    
            kzalloc(a * b * c, gfp)
    
    with:
    
            kzalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kzalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kzalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kzalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kzalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kzalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kzalloc
    + kcalloc
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kzalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(sizeof(THING) * C2, ...)
    |
      kzalloc(sizeof(TYPE) * C2, ...)
    |
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(C1 * C2, ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 959ae3e65ef8..f0af9985ca09 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -628,7 +628,7 @@ static int pd6729_pci_probe(struct pci_dev *dev,
 	char configbyte;
 	struct pd6729_socket *socket;
 
-	socket = kzalloc(sizeof(struct pd6729_socket) * MAX_SOCKETS,
+	socket = kcalloc(MAX_SOCKETS, sizeof(struct pd6729_socket),
 			 GFP_KERNEL);
 	if (!socket) {
 		dev_warn(&dev->dev, "failed to kzalloc socket.\n");

commit 41760d0e0f1a013e607956eaf22a60ff6dd03784
Author: Kees Cook <keescook@chromium.org>
Date:   Sat Oct 21 12:09:17 2017 -0700

    drivers/pcmcia: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: David Howells <dhowells@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-pcmcia@lists.infradead.org
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk> # for soc_common.c

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 0f70b4d58f9e..959ae3e65ef8 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -234,9 +234,9 @@ static irqreturn_t pd6729_interrupt(int irq, void *dev)
 
 /* socket functions */
 
-static void pd6729_interrupt_wrapper(unsigned long data)
+static void pd6729_interrupt_wrapper(struct timer_list *t)
 {
-	struct pd6729_socket *socket = (struct pd6729_socket *) data;
+	struct pd6729_socket *socket = from_timer(socket, t, poll_timer);
 
 	pd6729_interrupt(0, (void *)socket);
 	mod_timer(&socket->poll_timer, jiffies + HZ);
@@ -707,8 +707,7 @@ static int pd6729_pci_probe(struct pci_dev *dev,
 		}
 	} else {
 		/* poll Card status change */
-		setup_timer(&socket->poll_timer, pd6729_interrupt_wrapper,
-			    (unsigned long)socket);
+		timer_setup(&socket->poll_timer, pd6729_interrupt_wrapper, 0);
 		mod_timer(&socket->poll_timer, jiffies + HZ);
 	}
 

commit 03b225b16d75bccf9bc4d82607964a08148adf61
Author: Vaishali Thakkar <vthakkar1994@gmail.com>
Date:   Wed Feb 11 16:15:31 2015 +0530

    pcmcia: Use setup_timer and mod_timer
    
    This patch introduces the use of functions setup_timer
    and mod_timer.
    
    This is done using Coccinelle and semantic patch used
    for this as follows:
    
    // <smpl>
    @@
    expression x,y,z,a,b;
    @@
    
    -init_timer (&x);
    +setup_timer (&x, y, z);
    +mod_timer (&a, b);
    -x.function = y;
    -x.data = z;
    -x.expires = b;
    -add_timer(&a);
    
    // </smpl>
    
    Signed-off-by: Vaishali Thakkar <vthakkar1994@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 34ace4854dc2..0f70b4d58f9e 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -707,11 +707,9 @@ static int pd6729_pci_probe(struct pci_dev *dev,
 		}
 	} else {
 		/* poll Card status change */
-		init_timer(&socket->poll_timer);
-		socket->poll_timer.function = pd6729_interrupt_wrapper;
-		socket->poll_timer.data = (unsigned long)socket;
-		socket->poll_timer.expires = jiffies + HZ;
-		add_timer(&socket->poll_timer);
+		setup_timer(&socket->poll_timer, pd6729_interrupt_wrapper,
+			    (unsigned long)socket);
+		mod_timer(&socket->poll_timer, jiffies + HZ);
 	}
 
 	for (i = 0; i < MAX_SOCKETS; i++) {

commit 0178a7a54d408d2c5b7bbe7eee9450bffbec0989
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jul 18 16:58:07 2014 -0700

    pcmcia: remove DEFINE_PCI_DEVICE_TABLE usage
    
    It's not needed, just use the "real" structure definition instead.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 622dd6fe7347..34ace4854dc2 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -764,7 +764,7 @@ static void pd6729_pci_remove(struct pci_dev *dev)
 	kfree(socket);
 }
 
-static DEFINE_PCI_DEVICE_TABLE(pd6729_pci_ids) = {
+static const struct pci_device_id pd6729_pci_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_CIRRUS, PCI_DEVICE_ID_CIRRUS_6729) },
 	{ }
 };

commit ae647589a419d65778a7d06bd608a6fd526676e4
Author: Libo Chen <libo.chen@huawei.com>
Date:   Fri Sep 13 14:49:41 2013 -0700

    drivers/pcmcia/pd6729.c: convert to module_pci_driver
    
    Use module_pci_driver instead of init/exit, make code clean.
    
    Signed-off-by: Libo Chen <libo.chen@huawei.com>
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index a4c16ee5c718..622dd6fe7347 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -777,15 +777,4 @@ static struct pci_driver pd6729_pci_driver = {
 	.remove		= pd6729_pci_remove,
 };
 
-static int pd6729_module_init(void)
-{
-	return pci_register_driver(&pd6729_pci_driver);
-}
-
-static void pd6729_module_exit(void)
-{
-	pci_unregister_driver(&pd6729_pci_driver);
-}
-
-module_init(pd6729_module_init);
-module_exit(pd6729_module_exit);
+module_pci_driver(pd6729_pci_driver);

commit 214da6728acac285cac0e8e9b6c4c13838b8e1b0
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Fri Jun 7 10:16:54 2013 +0800

    pcmcia: pd6729: fix error return code in pd6729_pci_probe()
    
    Fix to return a negative error code from the error handling
    case instead of 0, as done elsewhere in this function.
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index b29d97e170ae..a4c16ee5c718 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -644,6 +644,7 @@ static int pd6729_pci_probe(struct pci_dev *dev,
 	if (!pci_resource_start(dev, 0)) {
 		dev_warn(&dev->dev, "refusing to load the driver as the "
 			"io_base is NULL.\n");
+		ret = -ENOMEM;
 		goto err_out_disable;
 	}
 
@@ -673,6 +674,7 @@ static int pd6729_pci_probe(struct pci_dev *dev,
 	mask = pd6729_isa_scan();
 	if (irq_mode == 0 && mask == 0) {
 		dev_warn(&dev->dev, "no ISA interrupt is available.\n");
+		ret = -ENODEV;
 		goto err_out_free_res;
 	}
 

commit e765a02cb64bfef53f290122ca0897ef329a4e76
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:05 2012 -0500

    pcmcia: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 4bb8426afe6d..b29d97e170ae 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -739,7 +739,7 @@ static int pd6729_pci_probe(struct pci_dev *dev,
 	return ret;
 }
 
-static void __devexit pd6729_pci_remove(struct pci_dev *dev)
+static void pd6729_pci_remove(struct pci_dev *dev)
 {
 	int i;
 	struct pd6729_socket *socket = pci_get_drvdata(dev);

commit 34cdf25a126f053698d549cc12a9c30e9a8a0bab
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:23:12 2012 -0500

    pcmcia: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Acked-by: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index aa79c0cc6dcf..4bb8426afe6d 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -589,7 +589,7 @@ static int pd6729_check_irq(int irq)
 	return 0;
 }
 
-static u_int __devinit pd6729_isa_scan(void)
+static u_int pd6729_isa_scan(void)
 {
 	u_int mask0, mask = 0;
 	int i;
@@ -620,7 +620,7 @@ static u_int __devinit pd6729_isa_scan(void)
 	return mask;
 }
 
-static int __devinit pd6729_pci_probe(struct pci_dev *dev,
+static int pd6729_pci_probe(struct pci_dev *dev,
 				      const struct pci_device_id *id)
 {
 	int i, j, ret;

commit 96364e3a5cf1416c158a276134d9a4fc861548c2
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:20:38 2012 -0500

    pcmcia: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 253e3867dec7..aa79c0cc6dcf 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -772,7 +772,7 @@ static struct pci_driver pd6729_pci_driver = {
 	.name		= "pd6729",
 	.id_table	= pd6729_pci_ids,
 	.probe		= pd6729_pci_probe,
-	.remove		= __devexit_p(pd6729_pci_remove),
+	.remove		= pd6729_pci_remove,
 };
 
 static int pd6729_module_init(void)

commit a6f707b601c3f85d4b816ea08a757ea1af4f1cc0
Merge: ef08e7826842 80af9e6d7ae6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 29 16:00:48 2012 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/brodo/pcmcia
    
    Pull a few PCMCIA updates from Dominik Brodowski.
    
    Fix up trivial conflict (modified code in question had been removed) in
    drivers/pcmcia/soc_common.c.
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/brodo/pcmcia:
      pcmcia at91_cf: fix raw gpio number usage
      ARM: pxa: fix error handling in pxa2xx_drv_pcmcia_probe
      pcmcia: Convert to DEFINE_PCI_DEVICE_TABLE
      pcmcia: convert drivers/pcmcia/* to use module_platform_driver()
      pcmcia: irq: Remove IRQF_DISABLED

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 96c72e90b79c..0f8b70b27762 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -19,7 +19,6 @@
 
 #include <pcmcia/ss.h>
 
-#include <asm/system.h>
 
 #include "pd6729.h"
 #include "i82365.h"

commit 2b2c5d8c1dff8ed42d6d841f56428c0ce2bd71b5
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Dec 27 16:17:46 2011 +0800

    pcmcia: Convert to DEFINE_PCI_DEVICE_TABLE
    
    Convert static struct pci_device_id *[] to static DEFINE_PCI_DEVICE_TABLE
    tables. Also convert to use PCI_DEVICE macro for better readablity.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 96c72e90b79c..5928247a4af0 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -763,13 +763,8 @@ static void __devexit pd6729_pci_remove(struct pci_dev *dev)
 	kfree(socket);
 }
 
-static struct pci_device_id pd6729_pci_ids[] = {
-	{
-		.vendor		= PCI_VENDOR_ID_CIRRUS,
-		.device		= PCI_DEVICE_ID_CIRRUS_6729,
-		.subvendor	= PCI_ANY_ID,
-		.subdevice	= PCI_ANY_ID,
-	},
+static DEFINE_PCI_DEVICE_TABLE(pd6729_pci_ids) = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CIRRUS, PCI_DEVICE_ID_CIRRUS_6729) },
 	{ }
 };
 MODULE_DEVICE_TABLE(pci, pd6729_pci_ids);

commit 006839f12e9dc484a6227b263843f987abb709a4
Author: Komuro <komurojun-mbn@nifty.com>
Date:   Sat Oct 23 07:02:05 2010 +0900

    pd6729: Coding Style fixes
    
    pd6729: remove unnecessary space.
    
    Signed-off-by: Komuro <komurojun-mbn@nifty.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 8cbfa067171f..96c72e90b79c 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -725,17 +725,17 @@ static int __devinit pd6729_pci_probe(struct pci_dev *dev,
 
 	return 0;
 
- err_out_free_res2:
+err_out_free_res2:
 	if (irq_mode == 1)
 		free_irq(dev->irq, socket);
 	else
 		del_timer_sync(&socket->poll_timer);
- err_out_free_res:
+err_out_free_res:
 	pci_release_regions(dev);
- err_out_disable:
+err_out_disable:
 	pci_disable_device(dev);
 
- err_out_free_mem:
+err_out_free_mem:
 	kfree(socket);
 	return ret;
 }

commit 1ac71e5a35eebee60cdcf15b3980bd94498f037b
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Jul 29 19:27:09 2010 +0200

    pcmcia: convert pcmcia_request_configuration to pcmcia_enable_device
    
    pcmcia_enable_device() now replaces pcmcia_request_configuration().
    Instead of config_req_t, all necessary flags are either passed as
    a parameter to pcmcia_enable_device(), or (in rare circumstances)
    set in struct pcmcia_device -> flags.
    
    With the last remaining user of include/pcmcia/cs.h gone, remove
    all references.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: linux-scsi@vger.kernel.org
    Acked-by: Gustavo F. Padovan <padovan@profusion.mobi> (for drivers/bluetooth)
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index deef6656ab7b..8cbfa067171f 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -18,7 +18,6 @@
 #include <linux/io.h>
 
 #include <pcmcia/ss.h>
-#include <pcmcia/cs.h>
 
 #include <asm/system.h>
 

commit 40d24ff9b4309d37999bc0ae91a271f57651d9dd
Author: Rahul Ruikar <rahul.ruikar@gmail.com>
Date:   Sun Sep 26 17:00:29 2010 +0530

    pcmcia: pd6729: Fix error path
    
    In error return path
    call pci_disable_device() which was enabled earlier.
    
    Signed-off-by: Rahul Ruikar <rahul.ruikar@gmail.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index b8a869af0f44..deef6656ab7b 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -646,7 +646,7 @@ static int __devinit pd6729_pci_probe(struct pci_dev *dev,
 	if (!pci_resource_start(dev, 0)) {
 		dev_warn(&dev->dev, "refusing to load the driver as the "
 			"io_base is NULL.\n");
-		goto err_out_free_mem;
+		goto err_out_disable;
 	}
 
 	dev_info(&dev->dev, "Cirrus PD6729 PCI to PCMCIA Bridge at 0x%llx "

commit ac8b422838046ffc26be4874a3cbae0d313f4209
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Jul 21 22:38:13 2010 +0200

    pcmcia: remove cs_types.h
    
    Remove cs_types.h which is no longer needed: Most definitions aren't
    used at all, a few can be made away with, and two remaining definitions
    (typedefs, unfortunatley) may be moved to more specific places.
    
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    Acked-by: Marcel Holtmann <marcel@holtmann.org> (for drivers/bluetooth/)
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index b61a13663a0a..b8a869af0f44 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -17,7 +17,6 @@
 #include <linux/device.h>
 #include <linux/io.h>
 
-#include <pcmcia/cs_types.h>
 #include <pcmcia/ss.h>
 #include <pcmcia/cs.h>
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 4a34268cc512..b61a13663a0a 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -9,6 +9,7 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/slab.h>
 #include <linux/pci.h>
 #include <linux/init.h>
 #include <linux/workqueue.h>

commit d7646f7632549124fe70fec8af834c7c1246f365
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Mon Mar 15 21:46:34 2010 +0100

    pcmcia: use dev_pm_ops for class pcmcia_socket_class
    
    Instead of requiring PCMCIA socket drivers to call various functions
    during their (bus) resume and suspend functions, register an own
    dev_pm_ops for this class. This fixes several suspend/resume bugs
    seen on db1xxx-ss, and probably on some other socket drivers, too.
    
    With regard to the asymmetry with only _noirq suspend, but split up
    resume, please see bug 14334 and commit 9905d1b411946fb3 .
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 47f342f1b0fc..4a34268cc512 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -764,18 +764,6 @@ static void __devexit pd6729_pci_remove(struct pci_dev *dev)
 	kfree(socket);
 }
 
-#ifdef CONFIG_PM
-static int pd6729_socket_suspend(struct pci_dev *dev, pm_message_t state)
-{
-	return pcmcia_socket_dev_suspend(&dev->dev);
-}
-
-static int pd6729_socket_resume(struct pci_dev *dev)
-{
-	return pcmcia_socket_dev_resume(&dev->dev);
-}
-#endif
-
 static struct pci_device_id pd6729_pci_ids[] = {
 	{
 		.vendor		= PCI_VENDOR_ID_CIRRUS,
@@ -792,10 +780,6 @@ static struct pci_driver pd6729_pci_driver = {
 	.id_table	= pd6729_pci_ids,
 	.probe		= pd6729_pci_probe,
 	.remove		= __devexit_p(pd6729_pci_remove),
-#ifdef CONFIG_PM
-	.suspend	= pd6729_socket_suspend,
-	.resume		= pd6729_socket_resume,
-#endif
 };
 
 static int pd6729_module_init(void)

commit 5cbb2b941d2cc77e6b915e8e55d375be632c9f6a
Author: Komuro <komurojun-mbn@nifty.com>
Date:   Sat Mar 20 06:39:19 2010 +0900

    pd6729: Coding Style fixes
    
    Signed-off-by: Komuro <komurojun-mbn@nifty.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 7ba57a565cd7..47f342f1b0fc 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -14,13 +14,13 @@
 #include <linux/workqueue.h>
 #include <linux/interrupt.h>
 #include <linux/device.h>
+#include <linux/io.h>
 
 #include <pcmcia/cs_types.h>
 #include <pcmcia/ss.h>
 #include <pcmcia/cs.h>
 
 #include <asm/system.h>
-#include <asm/io.h>
 
 #include "pd6729.h"
 #include "i82365.h"
@@ -222,9 +222,9 @@ static irqreturn_t pd6729_interrupt(int irq, void *dev)
 						? SS_READY : 0;
 			}
 
-			if (events) {
+			if (events)
 				pcmcia_parse_events(&socket[i].socket, events);
-			}
+
 			active |= events;
 		}
 
@@ -256,9 +256,8 @@ static int pd6729_get_status(struct pcmcia_socket *sock, u_int *value)
 	status = indirect_read(socket, I365_STATUS);
 	*value = 0;
 
-	if ((status & I365_CS_DETECT) == I365_CS_DETECT) {
+	if ((status & I365_CS_DETECT) == I365_CS_DETECT)
 		*value |= SS_DETECT;
-	}
 
 	/*
 	 * IO cards have a different meaning of bits 0,1
@@ -308,7 +307,7 @@ static int pd6729_set_socket(struct pcmcia_socket *sock, socket_state_t *state)
 	socket->card_irq = state->io_irq;
 
 	reg = 0;
- 	/* The reset bit has "inverse" logic */
+	/* The reset bit has "inverse" logic */
 	if (!(state->flags & SS_RESET))
 		reg |= I365_PC_RESET;
 	if (state->flags & SS_IOCARD)
@@ -380,7 +379,7 @@ static int pd6729_set_socket(struct pcmcia_socket *sock, socket_state_t *state)
 		indirect_write(socket, I365_POWER, reg);
 
 	if (irq_mode == 1) {
-		 /* all interrupts are to be done as PCI interrupts */
+		/* all interrupts are to be done as PCI interrupts */
 		data = PD67_EC1_INV_MGMT_IRQ | PD67_EC1_INV_CARD_IRQ;
 	} else
 		data = 0;
@@ -391,9 +390,9 @@ static int pd6729_set_socket(struct pcmcia_socket *sock, socket_state_t *state)
 	/* Enable specific interrupt events */
 
 	reg = 0x00;
-	if (state->csc_mask & SS_DETECT) {
+	if (state->csc_mask & SS_DETECT)
 		reg |= I365_CSC_DETECT;
-	}
+
 	if (state->flags & SS_IOCARD) {
 		if (state->csc_mask & SS_STSCHG)
 			reg |= I365_CSC_STSCHG;
@@ -450,9 +449,12 @@ static int pd6729_set_io_map(struct pcmcia_socket *sock,
 
 	ioctl = indirect_read(socket, I365_IOCTL) & ~I365_IOCTL_MASK(map);
 
-	if (io->flags & MAP_0WS) ioctl |= I365_IOCTL_0WS(map);
-	if (io->flags & MAP_16BIT) ioctl |= I365_IOCTL_16BIT(map);
-	if (io->flags & MAP_AUTOSZ) ioctl |= I365_IOCTL_IOCS16(map);
+	if (io->flags & MAP_0WS)
+		ioctl |= I365_IOCTL_0WS(map);
+	if (io->flags & MAP_16BIT)
+		ioctl |= I365_IOCTL_16BIT(map);
+	if (io->flags & MAP_AUTOSZ)
+		ioctl |= I365_IOCTL_IOCS16(map);
 
 	indirect_write(socket, I365_IOCTL, ioctl);
 
@@ -497,7 +499,7 @@ static int pd6729_set_mem_map(struct pcmcia_socket *sock,
 
 	/* write the stop address */
 
-	i= (mem->res->end >> 12) & 0x0fff;
+	i = (mem->res->end >> 12) & 0x0fff;
 	switch (to_cycles(mem->speed)) {
 	case 0:
 		break;
@@ -563,7 +565,7 @@ static int pd6729_init(struct pcmcia_socket *sock)
 
 /* the pccard structure and its functions */
 static struct pccard_operations pd6729_operations = {
-	.init 			= pd6729_init,
+	.init			= pd6729_init,
 	.get_status		= pd6729_get_status,
 	.set_socket		= pd6729_set_socket,
 	.set_io_map		= pd6729_set_io_map,
@@ -578,8 +580,13 @@ static irqreturn_t pd6729_test(int irq, void *dev)
 
 static int pd6729_check_irq(int irq)
 {
-	if (request_irq(irq, pd6729_test, IRQF_PROBE_SHARED, "x", pd6729_test)
-		!= 0) return -1;
+	int ret;
+
+	ret = request_irq(irq, pd6729_test, IRQF_PROBE_SHARED, "x",
+			  pd6729_test);
+	if (ret)
+		return -1;
+
 	free_irq(irq, pd6729_test);
 	return 0;
 }
@@ -591,7 +598,7 @@ static u_int __devinit pd6729_isa_scan(void)
 
 	if (irq_mode == 1) {
 		printk(KERN_INFO "pd6729: PCI card interrupts, "
-						"PCI status changes\n");
+		       "PCI status changes\n");
 		return 0;
 	}
 
@@ -607,9 +614,10 @@ static u_int __devinit pd6729_isa_scan(void)
 		if (mask & (1<<i))
 			printk("%s%d", ((mask & ((1<<i)-1)) ? "," : ""), i);
 
-	if (mask == 0) printk("none!");
-
-	printk("  polling status changes.\n");
+	if (mask == 0)
+		printk("none!");
+	else
+		printk("  polling status changes.\n");
 
 	return mask;
 }
@@ -624,11 +632,16 @@ static int __devinit pd6729_pci_probe(struct pci_dev *dev,
 
 	socket = kzalloc(sizeof(struct pd6729_socket) * MAX_SOCKETS,
 			 GFP_KERNEL);
-	if (!socket)
+	if (!socket) {
+		dev_warn(&dev->dev, "failed to kzalloc socket.\n");
 		return -ENOMEM;
+	}
 
-	if ((ret = pci_enable_device(dev)))
+	ret = pci_enable_device(dev);
+	if (ret) {
+		dev_warn(&dev->dev, "failed to enable pci_device.\n");
 		goto err_out_free_mem;
+	}
 
 	if (!pci_resource_start(dev, 0)) {
 		dev_warn(&dev->dev, "refusing to load the driver as the "
@@ -639,7 +652,7 @@ static int __devinit pd6729_pci_probe(struct pci_dev *dev,
 	dev_info(&dev->dev, "Cirrus PD6729 PCI to PCMCIA Bridge at 0x%llx "
 		"on irq %d\n",
 		(unsigned long long)pci_resource_start(dev, 0), dev->irq);
- 	/*
+	/*
 	 * Since we have no memory BARs some firmware may not
 	 * have had PCI_COMMAND_MEMORY enabled, yet the device needs it.
 	 */
@@ -685,8 +698,9 @@ static int __devinit pd6729_pci_probe(struct pci_dev *dev,
 	pci_set_drvdata(dev, socket);
 	if (irq_mode == 1) {
 		/* Register the interrupt handler */
-		if ((ret = request_irq(dev->irq, pd6729_interrupt, IRQF_SHARED,
-							"pd6729", socket))) {
+		ret = request_irq(dev->irq, pd6729_interrupt, IRQF_SHARED,
+				  "pd6729", socket);
+		if (ret) {
 			dev_err(&dev->dev, "Failed to register irq %d\n",
 				dev->irq);
 			goto err_out_free_res;

commit 7a96e87d6e58a07235a2bc3eff9b093af4937a72
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Mar 13 17:42:39 2010 +0100

    pcmcia: pd6729, i82092: use parent (PCI) resources
    
    A newly added parent resource entry for the root PCI bus, such as
    
    40000000-ffffffff : PCI Bus #00
    
    means that the pd6729 and i82092 drivers cannot allocate iomem as
    freely as before, unless they do so as PCI devices. Therefore, set
    socket->cb_dev so that rsrc_nonstatic.c does the right thing.
    
    Reported-by: Komuro <komurojun-mbn@nifty.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 7c204910a777..7ba57a565cd7 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -671,6 +671,7 @@ static int __devinit pd6729_pci_probe(struct pci_dev *dev,
 		socket[i].socket.map_size = 0x1000;
 		socket[i].socket.irq_mask = mask;
 		socket[i].socket.pci_irq  = dev->irq;
+		socket[i].socket.cb_dev = dev;
 		socket[i].socket.owner = THIS_MODULE;
 
 		socket[i].number = i;

commit f9097dce5d799462e086adca28815dac5006bb30
Author: Komuro <komurojun-mbn@nifty.com>
Date:   Sun Feb 28 15:39:33 2010 +0900

    pcmcia: remove irq_list parameter from pd6729
    
    Remoe the irq_list parameter from pd6729, as it can and should be set
    via sysfs (and -- if available -- pcmciautils, which reads the information
    from /etc/pcmcia/config.opts )
    
    [linux@dominikbrodowski.net: updated commit message]
    Signed-off-by: Komuro <komurojun-mbn@nifty.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index e1741cd875aa..7c204910a777 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -48,23 +48,13 @@ MODULE_AUTHOR("Jun Komuro <komurojun-mbn@nifty.com>");
  *     Specifies the interrupt delivery mode.  The default (1) is to use PCI
  *     interrupts; a value of 0 selects ISA interrupts. This must be set for
  *     correct operation of PCI card readers.
- *
- *  irq_list=i,j,...
- *     This list limits the set of interrupts that can be used by PCMCIA
- *     cards.
- *     The default list is 3,4,5,7,9,10,11.
- *     (irq_list parameter is not used, if irq_mode = 1)
  */
 
 static int irq_mode = 1; /* 0 = ISA interrupt, 1 = PCI interrupt */
-static int irq_list[16];
-static unsigned int irq_list_count = 0;
 
 module_param(irq_mode, int, 0444);
-module_param_array(irq_list, int, &irq_list_count, 0444);
 MODULE_PARM_DESC(irq_mode,
 		"interrupt delivery mode. 0 = ISA, 1 = PCI. default is 1");
-MODULE_PARM_DESC(irq_list, "interrupts that can be used by PCMCIA cards");
 
 static DEFINE_SPINLOCK(port_lock);
 
@@ -605,13 +595,7 @@ static u_int __devinit pd6729_isa_scan(void)
 		return 0;
 	}
 
-	if (irq_list_count == 0)
-		mask0 = 0xffff;
-	else
-		for (i = mask0 = 0; i < irq_list_count; i++)
-			mask0 |= (1<<irq_list[i]);
-
-	mask0 &= PD67_MASK;
+	mask0 = PD67_MASK;
 
 	/* just find interrupts that aren't in use */
 	for (i = 0; i < 16; i++)

commit a7149f9a26eb44a5658d56335c23104ba529e9f6
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Oct 24 18:07:16 2009 +0200

    pcmcia: use dev_dbg and dev_print in pd6729.c
    
    As suggested by Wolfram Sang <w.sang@pengutronix.de>, use dev_dbg(),
    and dev_{err,warn,info}() in pd6729.c, and add some "\n" suggested by
    Komuro <komurojun-mbn@nifty.com>. In the ISR, use pr_devel() and
    dev_vdbg() as they are only compiled if DEBUG (or, for dev_vdbg(),
    VERBOSE_DEBUG) are set explicitly.
    
    CC: Komuro <komurojun-mbn@nifty.com>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 70a33468bcd0..e1741cd875aa 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -213,7 +213,8 @@ static irqreturn_t pd6729_interrupt(int irq, void *dev)
 
 			if (csc & I365_CSC_DETECT) {
 				events |= SS_DETECT;
-				dprintk("Card detected in socket %i!\n", i);
+				dev_vdbg(&socket[i].socket.dev,
+					"Card detected in socket %i!\n", i);
 			}
 
 			if (indirect_read(&socket[i], I365_INTCTL)
@@ -331,11 +332,11 @@ static int pd6729_set_socket(struct pcmcia_socket *sock, socket_state_t *state)
 	reg = I365_PWR_NORESET; /* default: disable resetdrv on resume */
 
 	if (state->flags & SS_PWR_AUTO) {
-		dprintk("Auto power\n");
+		dev_dbg(&sock->dev, "Auto power\n");
 		reg |= I365_PWR_AUTO;	/* automatic power mngmnt */
 	}
 	if (state->flags & SS_OUTPUT_ENA) {
-		dprintk("Power Enabled\n");
+		dev_dbg(&sock->dev, "Power Enabled\n");
 		reg |= I365_PWR_OUT;	/* enable power */
 	}
 
@@ -343,40 +344,44 @@ static int pd6729_set_socket(struct pcmcia_socket *sock, socket_state_t *state)
 	case 0:
 		break;
 	case 33:
-		dprintk("setting voltage to Vcc to 3.3V on socket %i\n",
+		dev_dbg(&sock->dev,
+			"setting voltage to Vcc to 3.3V on socket %i\n",
 			socket->number);
 		reg |= I365_VCC_5V;
 		indirect_setbit(socket, PD67_MISC_CTL_1, PD67_MC1_VCC_3V);
 		break;
 	case 50:
-		dprintk("setting voltage to Vcc to 5V on socket %i\n",
+		dev_dbg(&sock->dev,
+			"setting voltage to Vcc to 5V on socket %i\n",
 			socket->number);
 		reg |= I365_VCC_5V;
 		indirect_resetbit(socket, PD67_MISC_CTL_1, PD67_MC1_VCC_3V);
 		break;
 	default:
-		dprintk("pd6729: pd6729_set_socket called with "
-				"invalid VCC power value: %i\n",
-			state->Vcc);
+		dev_dbg(&sock->dev,
+			"pd6729_set_socket called with invalid VCC power "
+			"value: %i\n", state->Vcc);
 		return -EINVAL;
 	}
 
 	switch (state->Vpp) {
 	case 0:
-		dprintk("not setting Vpp on socket %i\n", socket->number);
+		dev_dbg(&sock->dev, "not setting Vpp on socket %i\n",
+			socket->number);
 		break;
 	case 33:
 	case 50:
-		dprintk("setting Vpp to Vcc for socket %i\n", socket->number);
+		dev_dbg(&sock->dev, "setting Vpp to Vcc for socket %i\n",
+			socket->number);
 		reg |= I365_VPP1_5V;
 		break;
 	case 120:
-		dprintk("setting Vpp to 12.0\n");
+		dev_dbg(&sock->dev, "setting Vpp to 12.0\n");
 		reg |= I365_VPP1_12V;
 		break;
 	default:
-		dprintk("pd6729: pd6729_set_socket called with invalid VPP power value: %i\n",
-			state->Vpp);
+		dev_dbg(&sock->dev, "pd6729: pd6729_set_socket called with "
+			"invalid VPP power value: %i\n", state->Vpp);
 		return -EINVAL;
 	}
 
@@ -438,7 +443,7 @@ static int pd6729_set_io_map(struct pcmcia_socket *sock,
 
 	/* Check error conditions */
 	if (map > 1) {
-		dprintk("pd6729_set_io_map with invalid map");
+		dev_dbg(&sock->dev, "pd6729_set_io_map with invalid map\n");
 		return -EINVAL;
 	}
 
@@ -446,7 +451,7 @@ static int pd6729_set_io_map(struct pcmcia_socket *sock,
 	if (indirect_read(socket, I365_ADDRWIN) & I365_ENA_IO(map))
 		indirect_resetbit(socket, I365_ADDRWIN, I365_ENA_IO(map));
 
-	/* dprintk("set_io_map: Setting range to %x - %x\n",
+	/* dev_dbg(&sock->dev, "set_io_map: Setting range to %x - %x\n",
 	   io->start, io->stop);*/
 
 	/* write the new values */
@@ -478,12 +483,12 @@ static int pd6729_set_mem_map(struct pcmcia_socket *sock,
 
 	map = mem->map;
 	if (map > 4) {
-		printk("pd6729_set_mem_map: invalid map");
+		dev_warn(&sock->dev, "invalid map requested\n");
 		return -EINVAL;
 	}
 
 	if ((mem->res->start > mem->res->end) || (mem->speed > 1000)) {
-		printk("pd6729_set_mem_map: invalid address / speed");
+		dev_warn(&sock->dev, "invalid invalid address / speed\n");
 		return -EINVAL;
 	}
 
@@ -529,12 +534,12 @@ static int pd6729_set_mem_map(struct pcmcia_socket *sock,
 	if (mem->flags & MAP_WRPROT)
 		i |= I365_MEM_WRPROT;
 	if (mem->flags & MAP_ATTRIB) {
-		/* dprintk("requesting attribute memory for socket %i\n",
-			socket->number);*/
+		/* dev_dbg(&sock->dev, "requesting attribute memory for "
+		   "socket %i\n", socket->number);*/
 		i |= I365_MEM_REG;
 	} else {
-		/* dprintk("requesting normal memory for socket %i\n",
-			socket->number);*/
+		/* dev_dbg(&sock->dev, "requesting normal memory for "
+		   "socket %i\n", socket->number);*/
 	}
 	indirect_write16(socket, base + I365_W_OFF, i);
 
@@ -577,7 +582,7 @@ static struct pccard_operations pd6729_operations = {
 
 static irqreturn_t pd6729_test(int irq, void *dev)
 {
-	dprintk("-> hit on irq %d\n", irq);
+	pr_devel("-> hit on irq %d\n", irq);
 	return IRQ_HANDLED;
 }
 
@@ -642,13 +647,13 @@ static int __devinit pd6729_pci_probe(struct pci_dev *dev,
 		goto err_out_free_mem;
 
 	if (!pci_resource_start(dev, 0)) {
-		printk(KERN_INFO "pd6729: refusing to load the driver "
-				 "as the io_base is 0.\n");
+		dev_warn(&dev->dev, "refusing to load the driver as the "
+			"io_base is NULL.\n");
 		goto err_out_free_mem;
 	}
 
-	printk(KERN_INFO "pd6729: Cirrus PD6729 PCI to PCMCIA Bridge "
-		"at 0x%llx on irq %d\n",
+	dev_info(&dev->dev, "Cirrus PD6729 PCI to PCMCIA Bridge at 0x%llx "
+		"on irq %d\n",
 		(unsigned long long)pci_resource_start(dev, 0), dev->irq);
  	/*
 	 * Since we have no memory BARs some firmware may not
@@ -656,14 +661,14 @@ static int __devinit pd6729_pci_probe(struct pci_dev *dev,
 	 */
 	pci_read_config_byte(dev, PCI_COMMAND, &configbyte);
 	if (!(configbyte & PCI_COMMAND_MEMORY)) {
-		printk(KERN_DEBUG "pd6729: Enabling PCI_COMMAND_MEMORY.\n");
+		dev_dbg(&dev->dev, "pd6729: Enabling PCI_COMMAND_MEMORY.\n");
 		configbyte |= PCI_COMMAND_MEMORY;
 		pci_write_config_byte(dev, PCI_COMMAND, configbyte);
 	}
 
 	ret = pci_request_regions(dev, "pd6729");
 	if (ret) {
-		printk(KERN_INFO "pd6729: pci request region failed.\n");
+		dev_warn(&dev->dev, "pci request region failed.\n");
 		goto err_out_disable;
 	}
 
@@ -672,7 +677,7 @@ static int __devinit pd6729_pci_probe(struct pci_dev *dev,
 
 	mask = pd6729_isa_scan();
 	if (irq_mode == 0 && mask == 0) {
-		printk(KERN_INFO "pd6729: no ISA interrupt is available.\n");
+		dev_warn(&dev->dev, "no ISA interrupt is available.\n");
 		goto err_out_free_res;
 	}
 
@@ -697,8 +702,8 @@ static int __devinit pd6729_pci_probe(struct pci_dev *dev,
 		/* Register the interrupt handler */
 		if ((ret = request_irq(dev->irq, pd6729_interrupt, IRQF_SHARED,
 							"pd6729", socket))) {
-			printk(KERN_ERR "pd6729: Failed to register irq %d, "
-							"aborting\n", dev->irq);
+			dev_err(&dev->dev, "Failed to register irq %d\n",
+				dev->irq);
 			goto err_out_free_res;
 		}
 	} else {
@@ -713,8 +718,7 @@ static int __devinit pd6729_pci_probe(struct pci_dev *dev,
 	for (i = 0; i < MAX_SOCKETS; i++) {
 		ret = pcmcia_register_socket(&socket[i].socket);
 		if (ret) {
-			printk(KERN_INFO "pd6729: pcmcia_register_socket "
-					       "failed.\n");
+			dev_warn(&dev->dev, "pcmcia_register_socket failed.\n");
 			for (j = 0; j < i ; j++)
 				pcmcia_unregister_socket(&socket[j].socket);
 			goto err_out_free_res2;

commit 94efb72328afa29ea5fd93e48ed17489afcdaa12
Author: Komuro <komurojun-mbn@nifty.com>
Date:   Sat Oct 24 08:07:39 2009 +0900

    pcmcia: do not load the pd6729 driver if io_base is NULL
    
    The CL-PD6729 chip in some docking station is not initialized properly
    under Linux. In that case, do not load the pd6729 driver.
    
    [Dominik Brodowski <linux@dominikbrodowski.net>: spelling fixes, check for NULL not 0]
    Signed-off-by: Komuro <komurojun-mbn@nifty.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 1c39d3438f20..70a33468bcd0 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -641,6 +641,12 @@ static int __devinit pd6729_pci_probe(struct pci_dev *dev,
 	if ((ret = pci_enable_device(dev)))
 		goto err_out_free_mem;
 
+	if (!pci_resource_start(dev, 0)) {
+		printk(KERN_INFO "pd6729: refusing to load the driver "
+				 "as the io_base is 0.\n");
+		goto err_out_free_mem;
+	}
+
 	printk(KERN_INFO "pd6729: Cirrus PD6729 PCI to PCMCIA Bridge "
 		"at 0x%llx on irq %d\n",
 		(unsigned long long)pci_resource_start(dev, 0), dev->irq);

commit 827b4649d4626bf97b203b4bcd69476bb9b4e760
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Sep 29 00:10:41 2009 +0200

    PM / PCMCIA: Drop second argument of pcmcia_socket_dev_suspend()
    
    pcmcia_socket_dev_suspend() doesn't use its second argument, so it
    may be dropped safely.
    
    This change is necessary for the subsequent yenta suspend/resume fix.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: stable@kernel.org

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 8bed1dab9039..1c39d3438f20 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -758,7 +758,7 @@ static void __devexit pd6729_pci_remove(struct pci_dev *dev)
 #ifdef CONFIG_PM
 static int pd6729_socket_suspend(struct pci_dev *dev, pm_message_t state)
 {
-	return pcmcia_socket_dev_suspend(&dev->dev, state);
+	return pcmcia_socket_dev_suspend(&dev->dev);
 }
 
 static int pd6729_socket_resume(struct pci_dev *dev)

commit ba66ddfa613886cbb554f7b064dc05bdc2c7138b
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Thu May 1 04:34:51 2008 -0700

    pcmcia: silence section mismatch warnings from pci_driver variables
    
    Silence following warnings:
    WARNING: drivers/pcmcia/built-in.o(.data+0x14e0): Section mismatch in reference from the variable pd6729_pci_drv to the function .devinit.text:pd6729_pci_probe()
    WARNING: drivers/pcmcia/built-in.o(.data+0x14e8): Section mismatch in reference from the variable pd6729_pci_drv to the function .devexit.text:pd6729_pci_remove()
    WARNING: drivers/pcmcia/built-in.o(.data+0x16c0): Section mismatch in reference from the variable i82092aa_pci_drv to the function .devinit.text:i82092aa_pci_probe()
    WARNING: drivers/pcmcia/built-in.o(.data+0x16c8): Section mismatch in reference from the variable i82092aa_pci_drv to the function .devexit.text:i82092aa_pci_remove()
    
    Rename the variables from *_drv to *_driver so modpost ignore the OK
    references to __devinit/__devexit functions.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index abc10fe49bd8..8bed1dab9039 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -778,7 +778,7 @@ static struct pci_device_id pd6729_pci_ids[] = {
 };
 MODULE_DEVICE_TABLE(pci, pd6729_pci_ids);
 
-static struct pci_driver pd6729_pci_drv = {
+static struct pci_driver pd6729_pci_driver = {
 	.name		= "pd6729",
 	.id_table	= pd6729_pci_ids,
 	.probe		= pd6729_pci_probe,
@@ -791,12 +791,12 @@ static struct pci_driver pd6729_pci_drv = {
 
 static int pd6729_module_init(void)
 {
-	return pci_register_driver(&pd6729_pci_drv);
+	return pci_register_driver(&pd6729_pci_driver);
 }
 
 static void pd6729_module_exit(void)
 {
-	pci_unregister_driver(&pd6729_pci_drv);
+	pci_unregister_driver(&pd6729_pci_driver);
 }
 
 module_init(pd6729_module_init);

commit 64a6f9500d8e8a8e1b1adc2120e56cc88df5727f
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sun Oct 14 19:35:30 2007 +0100

    signedness: module_param_array nump argument
    
    ... should be unsigned int
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index dd0ddf19ee57..abc10fe49bd8 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -58,7 +58,7 @@ MODULE_AUTHOR("Jun Komuro <komurojun-mbn@nifty.com>");
 
 static int irq_mode = 1; /* 0 = ISA interrupt, 1 = PCI interrupt */
 static int irq_list[16];
-static int irq_list_count = 0;
+static unsigned int irq_list_count = 0;
 
 module_param(irq_mode, int, 0444);
 module_param_array(irq_list, int, &irq_list_count, 0444);

commit 873733188a019acdb7fa253011cbdc0a8afd97f3
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Sep 12 17:00:10 2006 +0200

    Driver core: convert pcmcia code to use struct device
    
    Converts from using struct "class_device" to "struct device" making
    everything show up properly in /sys/devices/ with symlinks from the
    /sys/class directory.
    
    Cc: <linux-pcmcia@lists.infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 360c24896548..dd0ddf19ee57 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -682,7 +682,7 @@ static int __devinit pd6729_pci_probe(struct pci_dev *dev,
 
 		socket[i].socket.ops = &pd6729_operations;
 		socket[i].socket.resource_ops = &pccard_nonstatic_ops;
-		socket[i].socket.dev.dev = &dev->dev;
+		socket[i].socket.dev.parent = &dev->dev;
 		socket[i].socket.driver_data = &socket[i];
 	}
 

commit 3e022d0c77e159a59d3ebfc44ad76a05202c2a6b
Author: Komuro <komurojun-mbn@nifty.com>
Date:   Sat Nov 4 10:00:47 2006 +0900

    [PATCH] pcmcia: allow shared IRQs on pd6729 sockets
    
    Use IRQF_PROBE_SHARED flag for request_irq() to find an unused
    interrupt for PCMCIA cards.
    
    Signed-off-by: Komuro <komurojun-mbn@nifty.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index a70f97fdbbdd..360c24896548 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -581,10 +581,10 @@ static irqreturn_t pd6729_test(int irq, void *dev)
 	return IRQ_HANDLED;
 }
 
-static int pd6729_check_irq(int irq, int flags)
+static int pd6729_check_irq(int irq)
 {
-	if (request_irq(irq, pd6729_test, flags, "x", pd6729_test) != 0)
-		return -1;
+	if (request_irq(irq, pd6729_test, IRQF_PROBE_SHARED, "x", pd6729_test)
+		!= 0) return -1;
 	free_irq(irq, pd6729_test);
 	return 0;
 }
@@ -610,7 +610,7 @@ static u_int __devinit pd6729_isa_scan(void)
 
 	/* just find interrupts that aren't in use */
 	for (i = 0; i < 16; i++)
-		if ((mask0 & (1 << i)) && (pd6729_check_irq(i, 0) == 0))
+		if ((mask0 & (1 << i)) && (pd6729_check_irq(i) == 0))
 			mask |= (1 << i);
 
 	printk(KERN_INFO "pd6729: ISA irqs = ");

commit f237de58b13bf65ba2f7fab896daacb92ae7ddef
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Fri Oct 20 14:44:13 2006 -0700

    [PATCH] CONFIG_PM=n slim: drivers/pcmcia/*
    
    Remove some code which is unneeded if CONFIG_PM=n.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index c83a0a6b158f..a70f97fdbbdd 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -755,6 +755,7 @@ static void __devexit pd6729_pci_remove(struct pci_dev *dev)
 	kfree(socket);
 }
 
+#ifdef CONFIG_PM
 static int pd6729_socket_suspend(struct pci_dev *dev, pm_message_t state)
 {
 	return pcmcia_socket_dev_suspend(&dev->dev, state);
@@ -764,6 +765,7 @@ static int pd6729_socket_resume(struct pci_dev *dev)
 {
 	return pcmcia_socket_dev_resume(&dev->dev);
 }
+#endif
 
 static struct pci_device_id pd6729_pci_ids[] = {
 	{
@@ -781,8 +783,10 @@ static struct pci_driver pd6729_pci_drv = {
 	.id_table	= pd6729_pci_ids,
 	.probe		= pd6729_pci_probe,
 	.remove		= __devexit_p(pd6729_pci_remove),
+#ifdef CONFIG_PM
 	.suspend	= pd6729_socket_suspend,
 	.resume		= pd6729_socket_resume,
+#endif
 };
 
 static int pd6729_module_init(void)

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 22c5e7427ddd..c83a0a6b158f 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -182,7 +182,7 @@ static void indirect_write16(struct pd6729_socket *socket, unsigned short reg,
 
 /* Interrupt handler functionality */
 
-static irqreturn_t pd6729_interrupt(int irq, void *dev, struct pt_regs *regs)
+static irqreturn_t pd6729_interrupt(int irq, void *dev)
 {
 	struct pd6729_socket *socket = (struct pd6729_socket *)dev;
 	int i;
@@ -249,7 +249,7 @@ static void pd6729_interrupt_wrapper(unsigned long data)
 {
 	struct pd6729_socket *socket = (struct pd6729_socket *) data;
 
-	pd6729_interrupt(0, (void *)socket, NULL);
+	pd6729_interrupt(0, (void *)socket);
 	mod_timer(&socket->poll_timer, jiffies + HZ);
 }
 
@@ -575,7 +575,7 @@ static struct pccard_operations pd6729_operations = {
 	.set_mem_map		= pd6729_set_mem_map,
 };
 
-static irqreturn_t pd6729_test(int irq, void *dev, struct pt_regs *regs)
+static irqreturn_t pd6729_test(int irq, void *dev)
 {
 	dprintk("-> hit on irq %d\n", irq);
 	return IRQ_HANDLED;

commit dace145374b8e39aeb920304c358ab5e220341ab
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:38 2006 -0700

    [PATCH] irq-flags: misc drivers: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 9ee26c1b8635..22c5e7427ddd 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -689,7 +689,7 @@ static int __devinit pd6729_pci_probe(struct pci_dev *dev,
 	pci_set_drvdata(dev, socket);
 	if (irq_mode == 1) {
 		/* Register the interrupt handler */
-		if ((ret = request_irq(dev->irq, pd6729_interrupt, SA_SHIRQ,
+		if ((ret = request_irq(dev->irq, pd6729_interrupt, IRQF_SHARED,
 							"pd6729", socket))) {
 			printk(KERN_ERR "pd6729: Failed to register irq %d, "
 							"aborting\n", dev->irq);

commit 490ab72af6a7a74b1d77e8f1b67fdfad04371876
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 12 15:17:34 2006 -0700

    [PATCH] 64bit resource: fix up printks for resources in pcmcia drivers
    
    This is needed if we wish to change the size of the resource structures.
    
    Based on an original patch from Vivek Goyal <vgoyal@in.ibm.com>
    
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 247ab837f841..9ee26c1b8635 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -642,7 +642,8 @@ static int __devinit pd6729_pci_probe(struct pci_dev *dev,
 		goto err_out_free_mem;
 
 	printk(KERN_INFO "pd6729: Cirrus PD6729 PCI to PCMCIA Bridge "
-		"at 0x%lx on irq %d\n",	pci_resource_start(dev, 0), dev->irq);
+		"at 0x%llx on irq %d\n",
+		(unsigned long long)pci_resource_start(dev, 0), dev->irq);
  	/*
 	 * Since we have no memory BARs some firmware may not
 	 * have had PCI_COMMAND_MEMORY enabled, yet the device needs it.

commit 9781b8b055bd0a02a043ed80fb8d59d703a49daf
Author: Andrew Morton <akpm@osdl.org>
Date:   Sat May 20 15:00:32 2006 -0700

    [PATCH] pd6729 section fix
    
    WARNING: drivers/pcmcia/pd6729.o - Section mismatch: reference to .init.text: from .text between 'pd6729_pci_probe' (at offset 0x9a8) and 'pd6729_pci_remove'
    
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 16d1ea7b0a18..247ab837f841 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -589,7 +589,7 @@ static int pd6729_check_irq(int irq, int flags)
 	return 0;
 }
 
-static u_int __init pd6729_isa_scan(void)
+static u_int __devinit pd6729_isa_scan(void)
 {
 	u_int mask0, mask = 0;
 	int i;

commit e904663b4d511884145df54bead401840389853a
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Jan 10 21:35:49 2006 +0100

    [PATCH] pcmcia: remove include of config.h
    
    Remove the inclusion of include/config.h as it isn't needed any longer.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index f2789afb22b2..16d1ea7b0a18 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -8,7 +8,6 @@
  */
 
 #include <linux/kernel.h>
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/init.h>

commit 8084b372adac9c24ff7abdd939b2e8816e7b88a3
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Dec 11 21:18:26 2005 +0100

    [PATCH] pcmcia: kzalloc conversion
    
    Convert users of kmalloc and memset to kzalloc
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index e7a6d9ac5ed8..f2789afb22b2 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -634,13 +634,11 @@ static int __devinit pd6729_pci_probe(struct pci_dev *dev,
 	char configbyte;
 	struct pd6729_socket *socket;
 
-	socket = kmalloc(sizeof(struct pd6729_socket) * MAX_SOCKETS,
+	socket = kzalloc(sizeof(struct pd6729_socket) * MAX_SOCKETS,
 			 GFP_KERNEL);
 	if (!socket)
 		return -ENOMEM;
 
-	memset(socket, 0, sizeof(struct pd6729_socket) * MAX_SOCKETS);
-
 	if ((ret = pci_enable_device(dev)))
 		goto err_out_free_mem;
 

commit 9da4bc6d6a38c1c3d850c046d0aee324c1a2e52a
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Nov 12 23:56:33 2005 +0100

    [PATCH] pcmcia: remove get_socket callback
    
    The .get_socket callback is never used by the PCMCIA core, therefore remove
    it.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 20642f0e7bfe..e7a6d9ac5ed8 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -304,75 +304,6 @@ static int pd6729_get_status(struct pcmcia_socket *sock, u_int *value)
 }
 
 
-static int pd6729_get_socket(struct pcmcia_socket *sock, socket_state_t *state)
-{
-	struct pd6729_socket *socket
-			= container_of(sock, struct pd6729_socket, socket);
-	unsigned char reg, vcc, vpp;
-
-	state->flags    = 0;
-	state->Vcc      = 0;
-	state->Vpp      = 0;
-	state->io_irq   = 0;
-	state->csc_mask = 0;
-
-	/* First the power status of the socket */
-	reg = indirect_read(socket, I365_POWER);
-
-	if (reg & I365_PWR_AUTO)
-		state->flags |= SS_PWR_AUTO;  /* Automatic Power Switch */
-
-	if (reg & I365_PWR_OUT)
-		state->flags |= SS_OUTPUT_ENA; /* Output signals are enabled */
-
-	vcc = reg & I365_VCC_MASK;    vpp = reg & I365_VPP1_MASK;
-
-	if (reg & I365_VCC_5V) {
-		state->Vcc = (indirect_read(socket, PD67_MISC_CTL_1) &
-			PD67_MC1_VCC_3V) ? 33 : 50;
-
-		if (vpp == I365_VPP1_5V) {
-			if (state->Vcc == 50)
-				state->Vpp = 50;
-			else
-				state->Vpp = 33;
-		}
-		if (vpp == I365_VPP1_12V)
-			state->Vpp = 120;
-	}
-
-	/* Now the IO card, RESET flags and IO interrupt */
-	reg = indirect_read(socket, I365_INTCTL);
-
-	if ((reg & I365_PC_RESET) == 0)
-		state->flags |= SS_RESET;
-	if (reg & I365_PC_IOCARD)
-		state->flags |= SS_IOCARD; /* This is an IO card */
-
-	/* Set the IRQ number */
-	state->io_irq = socket->card_irq;
-
-	/* Card status change */
-	reg = indirect_read(socket, I365_CSCINT);
-
-	if (reg & I365_CSC_DETECT)
-		state->csc_mask |= SS_DETECT; /* Card detect is enabled */
-
-	if (state->flags & SS_IOCARD) {/* IO Cards behave different */
-		if (reg & I365_CSC_STSCHG)
-			state->csc_mask |= SS_STSCHG;
-	} else {
-		if (reg & I365_CSC_BVD1)
-			state->csc_mask |= SS_BATDEAD;
-		if (reg & I365_CSC_BVD2)
-			state->csc_mask |= SS_BATWARN;
-		if (reg & I365_CSC_READY)
-			state->csc_mask |= SS_READY;
-	}
-
-	return 0;
-}
-
 static int pd6729_set_socket(struct pcmcia_socket *sock, socket_state_t *state)
 {
 	struct pd6729_socket *socket
@@ -640,7 +571,6 @@ static int pd6729_init(struct pcmcia_socket *sock)
 static struct pccard_operations pd6729_operations = {
 	.init 			= pd6729_init,
 	.get_status		= pd6729_get_status,
-	.get_socket		= pd6729_get_socket,
 	.set_socket		= pd6729_set_socket,
 	.set_io_map		= pd6729_set_io_map,
 	.set_mem_map		= pd6729_set_mem_map,

commit c35e66a4216c99fe94868ed3f714bd2708d0032a
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu May 5 16:15:56 2005 -0700

    [PATCH] pcmcia: enable 32-bit memory windows on pd6729
    
    Enable 32-bit memory windows on pd6729 PCI-PCMCIA bridges.
    
    Signed-off-by: Jarkko Raja <jar@pcuf.fi>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 3f4364341d8d..20642f0e7bfe 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -744,7 +744,7 @@ static int __devinit pd6729_pci_probe(struct pci_dev *dev,
 
 	for (i = 0; i < MAX_SOCKETS; i++) {
 		socket[i].io_base = pci_resource_start(dev, 0);
-		socket[i].socket.features |= SS_CAP_PCCARD;
+		socket[i].socket.features |= SS_CAP_PAGE_REGS | SS_CAP_PCCARD;
 		socket[i].socket.map_size = 0x1000;
 		socket[i].socket.irq_mask = mask;
 		socket[i].socket.pci_irq  = dev->irq;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
new file mode 100644
index 000000000000..3f4364341d8d
--- /dev/null
+++ b/drivers/pcmcia/pd6729.c
@@ -0,0 +1,871 @@
+/*
+ * Driver for the Cirrus PD6729 PCI-PCMCIA bridge.
+ *
+ * Based on the i82092.c driver.
+ *
+ * This software may be used and distributed according to the terms of
+ * the GNU General Public License, incorporated herein by reference.
+ */
+
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+
+#include <pcmcia/cs_types.h>
+#include <pcmcia/ss.h>
+#include <pcmcia/cs.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+
+#include "pd6729.h"
+#include "i82365.h"
+#include "cirrus.h"
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Driver for the Cirrus PD6729 PCI-PCMCIA bridge");
+MODULE_AUTHOR("Jun Komuro <komurojun-mbn@nifty.com>");
+
+#define MAX_SOCKETS 2
+
+/*
+ * simple helper functions
+ * External clock time, in nanoseconds.  120 ns = 8.33 MHz
+ */
+#define to_cycles(ns)	((ns)/120)
+
+#ifndef NO_IRQ
+#define NO_IRQ	((unsigned int)(0))
+#endif
+
+/*
+ * PARAMETERS
+ *  irq_mode=n
+ *     Specifies the interrupt delivery mode.  The default (1) is to use PCI
+ *     interrupts; a value of 0 selects ISA interrupts. This must be set for
+ *     correct operation of PCI card readers.
+ *
+ *  irq_list=i,j,...
+ *     This list limits the set of interrupts that can be used by PCMCIA
+ *     cards.
+ *     The default list is 3,4,5,7,9,10,11.
+ *     (irq_list parameter is not used, if irq_mode = 1)
+ */
+
+static int irq_mode = 1; /* 0 = ISA interrupt, 1 = PCI interrupt */
+static int irq_list[16];
+static int irq_list_count = 0;
+
+module_param(irq_mode, int, 0444);
+module_param_array(irq_list, int, &irq_list_count, 0444);
+MODULE_PARM_DESC(irq_mode,
+		"interrupt delivery mode. 0 = ISA, 1 = PCI. default is 1");
+MODULE_PARM_DESC(irq_list, "interrupts that can be used by PCMCIA cards");
+
+static DEFINE_SPINLOCK(port_lock);
+
+/* basic value read/write functions */
+
+static unsigned char indirect_read(struct pd6729_socket *socket,
+				   unsigned short reg)
+{
+	unsigned long port;
+	unsigned char val;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port_lock, flags);
+	reg += socket->number * 0x40;
+	port = socket->io_base;
+	outb(reg, port);
+	val = inb(port + 1);
+	spin_unlock_irqrestore(&port_lock, flags);
+
+	return val;
+}
+
+static unsigned short indirect_read16(struct pd6729_socket *socket,
+				      unsigned short reg)
+{
+	unsigned long port;
+	unsigned short tmp;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port_lock, flags);
+	reg  = reg + socket->number * 0x40;
+	port = socket->io_base;
+	outb(reg, port);
+	tmp = inb(port + 1);
+	reg++;
+	outb(reg, port);
+	tmp = tmp | (inb(port + 1) << 8);
+	spin_unlock_irqrestore(&port_lock, flags);
+
+	return tmp;
+}
+
+static void indirect_write(struct pd6729_socket *socket, unsigned short reg,
+			   unsigned char value)
+{
+	unsigned long port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port_lock, flags);
+	reg = reg + socket->number * 0x40;
+	port = socket->io_base;
+	outb(reg, port);
+	outb(value, port + 1);
+	spin_unlock_irqrestore(&port_lock, flags);
+}
+
+static void indirect_setbit(struct pd6729_socket *socket, unsigned short reg,
+			    unsigned char mask)
+{
+	unsigned long port;
+	unsigned char val;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port_lock, flags);
+	reg = reg + socket->number * 0x40;
+	port = socket->io_base;
+	outb(reg, port);
+	val = inb(port + 1);
+	val |= mask;
+	outb(reg, port);
+	outb(val, port + 1);
+	spin_unlock_irqrestore(&port_lock, flags);
+}
+
+static void indirect_resetbit(struct pd6729_socket *socket, unsigned short reg,
+			      unsigned char mask)
+{
+	unsigned long port;
+	unsigned char val;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port_lock, flags);
+	reg = reg + socket->number * 0x40;
+	port = socket->io_base;
+	outb(reg, port);
+	val = inb(port + 1);
+	val &= ~mask;
+	outb(reg, port);
+	outb(val, port + 1);
+	spin_unlock_irqrestore(&port_lock, flags);
+}
+
+static void indirect_write16(struct pd6729_socket *socket, unsigned short reg,
+			     unsigned short value)
+{
+	unsigned long port;
+	unsigned char val;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port_lock, flags);
+	reg = reg + socket->number * 0x40;
+	port = socket->io_base;
+
+	outb(reg, port);
+	val = value & 255;
+	outb(val, port + 1);
+
+	reg++;
+
+	outb(reg, port);
+	val = value >> 8;
+	outb(val, port + 1);
+	spin_unlock_irqrestore(&port_lock, flags);
+}
+
+/* Interrupt handler functionality */
+
+static irqreturn_t pd6729_interrupt(int irq, void *dev, struct pt_regs *regs)
+{
+	struct pd6729_socket *socket = (struct pd6729_socket *)dev;
+	int i;
+	int loopcount = 0;
+	int handled = 0;
+	unsigned int events, active = 0;
+
+	while (1) {
+		loopcount++;
+		if (loopcount > 20) {
+			printk(KERN_ERR "pd6729: infinite eventloop "
+			       "in interrupt\n");
+			break;
+		}
+
+		active = 0;
+
+		for (i = 0; i < MAX_SOCKETS; i++) {
+			unsigned int csc;
+
+			/* card status change register */
+			csc = indirect_read(&socket[i], I365_CSC);
+			if (csc == 0)  /* no events on this socket */
+				continue;
+
+			handled = 1;
+			events = 0;
+
+			if (csc & I365_CSC_DETECT) {
+				events |= SS_DETECT;
+				dprintk("Card detected in socket %i!\n", i);
+			}
+
+			if (indirect_read(&socket[i], I365_INTCTL)
+						& I365_PC_IOCARD) {
+				/* For IO/CARDS, bit 0 means "read the card" */
+				events |= (csc & I365_CSC_STSCHG)
+						? SS_STSCHG : 0;
+			} else {
+				/* Check for battery/ready events */
+				events |= (csc & I365_CSC_BVD1)
+						? SS_BATDEAD : 0;
+				events |= (csc & I365_CSC_BVD2)
+						? SS_BATWARN : 0;
+				events |= (csc & I365_CSC_READY)
+						? SS_READY : 0;
+			}
+
+			if (events) {
+				pcmcia_parse_events(&socket[i].socket, events);
+			}
+			active |= events;
+		}
+
+		if (active == 0) /* no more events to handle */
+			break;
+	}
+	return IRQ_RETVAL(handled);
+}
+
+/* socket functions */
+
+static void pd6729_interrupt_wrapper(unsigned long data)
+{
+	struct pd6729_socket *socket = (struct pd6729_socket *) data;
+
+	pd6729_interrupt(0, (void *)socket, NULL);
+	mod_timer(&socket->poll_timer, jiffies + HZ);
+}
+
+static int pd6729_get_status(struct pcmcia_socket *sock, u_int *value)
+{
+	struct pd6729_socket *socket
+			= container_of(sock, struct pd6729_socket, socket);
+	unsigned int status;
+	unsigned int data;
+	struct pd6729_socket *t;
+
+	/* Interface Status Register */
+	status = indirect_read(socket, I365_STATUS);
+	*value = 0;
+
+	if ((status & I365_CS_DETECT) == I365_CS_DETECT) {
+		*value |= SS_DETECT;
+	}
+
+	/*
+	 * IO cards have a different meaning of bits 0,1
+	 * Also notice the inverse-logic on the bits
+	 */
+	if (indirect_read(socket, I365_INTCTL) & I365_PC_IOCARD) {
+		/* IO card */
+		if (!(status & I365_CS_STSCHG))
+			*value |= SS_STSCHG;
+	} else {
+		/* non I/O card */
+		if (!(status & I365_CS_BVD1))
+			*value |= SS_BATDEAD;
+		if (!(status & I365_CS_BVD2))
+			*value |= SS_BATWARN;
+	}
+
+	if (status & I365_CS_WRPROT)
+		*value |= SS_WRPROT;	/* card is write protected */
+
+	if (status & I365_CS_READY)
+		*value |= SS_READY;	/* card is not busy */
+
+	if (status & I365_CS_POWERON)
+		*value |= SS_POWERON;	/* power is applied to the card */
+
+	t = (socket->number) ? socket : socket + 1;
+	indirect_write(t, PD67_EXT_INDEX, PD67_EXTERN_DATA);
+	data = indirect_read16(t, PD67_EXT_DATA);
+	*value |= (data & PD67_EXD_VS1(socket->number)) ? 0 : SS_3VCARD;
+
+	return 0;
+}
+
+
+static int pd6729_get_socket(struct pcmcia_socket *sock, socket_state_t *state)
+{
+	struct pd6729_socket *socket
+			= container_of(sock, struct pd6729_socket, socket);
+	unsigned char reg, vcc, vpp;
+
+	state->flags    = 0;
+	state->Vcc      = 0;
+	state->Vpp      = 0;
+	state->io_irq   = 0;
+	state->csc_mask = 0;
+
+	/* First the power status of the socket */
+	reg = indirect_read(socket, I365_POWER);
+
+	if (reg & I365_PWR_AUTO)
+		state->flags |= SS_PWR_AUTO;  /* Automatic Power Switch */
+
+	if (reg & I365_PWR_OUT)
+		state->flags |= SS_OUTPUT_ENA; /* Output signals are enabled */
+
+	vcc = reg & I365_VCC_MASK;    vpp = reg & I365_VPP1_MASK;
+
+	if (reg & I365_VCC_5V) {
+		state->Vcc = (indirect_read(socket, PD67_MISC_CTL_1) &
+			PD67_MC1_VCC_3V) ? 33 : 50;
+
+		if (vpp == I365_VPP1_5V) {
+			if (state->Vcc == 50)
+				state->Vpp = 50;
+			else
+				state->Vpp = 33;
+		}
+		if (vpp == I365_VPP1_12V)
+			state->Vpp = 120;
+	}
+
+	/* Now the IO card, RESET flags and IO interrupt */
+	reg = indirect_read(socket, I365_INTCTL);
+
+	if ((reg & I365_PC_RESET) == 0)
+		state->flags |= SS_RESET;
+	if (reg & I365_PC_IOCARD)
+		state->flags |= SS_IOCARD; /* This is an IO card */
+
+	/* Set the IRQ number */
+	state->io_irq = socket->card_irq;
+
+	/* Card status change */
+	reg = indirect_read(socket, I365_CSCINT);
+
+	if (reg & I365_CSC_DETECT)
+		state->csc_mask |= SS_DETECT; /* Card detect is enabled */
+
+	if (state->flags & SS_IOCARD) {/* IO Cards behave different */
+		if (reg & I365_CSC_STSCHG)
+			state->csc_mask |= SS_STSCHG;
+	} else {
+		if (reg & I365_CSC_BVD1)
+			state->csc_mask |= SS_BATDEAD;
+		if (reg & I365_CSC_BVD2)
+			state->csc_mask |= SS_BATWARN;
+		if (reg & I365_CSC_READY)
+			state->csc_mask |= SS_READY;
+	}
+
+	return 0;
+}
+
+static int pd6729_set_socket(struct pcmcia_socket *sock, socket_state_t *state)
+{
+	struct pd6729_socket *socket
+			= container_of(sock, struct pd6729_socket, socket);
+	unsigned char reg, data;
+
+	/* First, set the global controller options */
+	indirect_write(socket, I365_GBLCTL, 0x00);
+	indirect_write(socket, I365_GENCTL, 0x00);
+
+	/* Values for the IGENC register */
+	socket->card_irq = state->io_irq;
+
+	reg = 0;
+ 	/* The reset bit has "inverse" logic */
+	if (!(state->flags & SS_RESET))
+		reg |= I365_PC_RESET;
+	if (state->flags & SS_IOCARD)
+		reg |= I365_PC_IOCARD;
+
+	/* IGENC, Interrupt and General Control Register */
+	indirect_write(socket, I365_INTCTL, reg);
+
+	/* Power registers */
+
+	reg = I365_PWR_NORESET; /* default: disable resetdrv on resume */
+
+	if (state->flags & SS_PWR_AUTO) {
+		dprintk("Auto power\n");
+		reg |= I365_PWR_AUTO;	/* automatic power mngmnt */
+	}
+	if (state->flags & SS_OUTPUT_ENA) {
+		dprintk("Power Enabled\n");
+		reg |= I365_PWR_OUT;	/* enable power */
+	}
+
+	switch (state->Vcc) {
+	case 0:
+		break;
+	case 33:
+		dprintk("setting voltage to Vcc to 3.3V on socket %i\n",
+			socket->number);
+		reg |= I365_VCC_5V;
+		indirect_setbit(socket, PD67_MISC_CTL_1, PD67_MC1_VCC_3V);
+		break;
+	case 50:
+		dprintk("setting voltage to Vcc to 5V on socket %i\n",
+			socket->number);
+		reg |= I365_VCC_5V;
+		indirect_resetbit(socket, PD67_MISC_CTL_1, PD67_MC1_VCC_3V);
+		break;
+	default:
+		dprintk("pd6729: pd6729_set_socket called with "
+				"invalid VCC power value: %i\n",
+			state->Vcc);
+		return -EINVAL;
+	}
+
+	switch (state->Vpp) {
+	case 0:
+		dprintk("not setting Vpp on socket %i\n", socket->number);
+		break;
+	case 33:
+	case 50:
+		dprintk("setting Vpp to Vcc for socket %i\n", socket->number);
+		reg |= I365_VPP1_5V;
+		break;
+	case 120:
+		dprintk("setting Vpp to 12.0\n");
+		reg |= I365_VPP1_12V;
+		break;
+	default:
+		dprintk("pd6729: pd6729_set_socket called with invalid VPP power value: %i\n",
+			state->Vpp);
+		return -EINVAL;
+	}
+
+	/* only write if changed */
+	if (reg != indirect_read(socket, I365_POWER))
+		indirect_write(socket, I365_POWER, reg);
+
+	if (irq_mode == 1) {
+		 /* all interrupts are to be done as PCI interrupts */
+		data = PD67_EC1_INV_MGMT_IRQ | PD67_EC1_INV_CARD_IRQ;
+	} else
+		data = 0;
+
+	indirect_write(socket, PD67_EXT_INDEX, PD67_EXT_CTL_1);
+	indirect_write(socket, PD67_EXT_DATA, data);
+
+	/* Enable specific interrupt events */
+
+	reg = 0x00;
+	if (state->csc_mask & SS_DETECT) {
+		reg |= I365_CSC_DETECT;
+	}
+	if (state->flags & SS_IOCARD) {
+		if (state->csc_mask & SS_STSCHG)
+			reg |= I365_CSC_STSCHG;
+	} else {
+		if (state->csc_mask & SS_BATDEAD)
+			reg |= I365_CSC_BVD1;
+		if (state->csc_mask & SS_BATWARN)
+			reg |= I365_CSC_BVD2;
+		if (state->csc_mask & SS_READY)
+			reg |= I365_CSC_READY;
+	}
+	if (irq_mode == 1)
+		reg |= 0x30;	/* management IRQ: PCI INTA# = "irq 3" */
+	indirect_write(socket, I365_CSCINT, reg);
+
+	reg = indirect_read(socket, I365_INTCTL);
+	if (irq_mode == 1)
+		reg |= 0x03;	/* card IRQ: PCI INTA# = "irq 3" */
+	else
+		reg |= socket->card_irq;
+	indirect_write(socket, I365_INTCTL, reg);
+
+	/* now clear the (probably bogus) pending stuff by doing a dummy read */
+	(void)indirect_read(socket, I365_CSC);
+
+	return 0;
+}
+
+static int pd6729_set_io_map(struct pcmcia_socket *sock,
+			     struct pccard_io_map *io)
+{
+	struct pd6729_socket *socket
+			= container_of(sock, struct pd6729_socket, socket);
+	unsigned char map, ioctl;
+
+	map = io->map;
+
+	/* Check error conditions */
+	if (map > 1) {
+		dprintk("pd6729_set_io_map with invalid map");
+		return -EINVAL;
+	}
+
+	/* Turn off the window before changing anything */
+	if (indirect_read(socket, I365_ADDRWIN) & I365_ENA_IO(map))
+		indirect_resetbit(socket, I365_ADDRWIN, I365_ENA_IO(map));
+
+	/* dprintk("set_io_map: Setting range to %x - %x\n",
+	   io->start, io->stop);*/
+
+	/* write the new values */
+	indirect_write16(socket, I365_IO(map)+I365_W_START, io->start);
+	indirect_write16(socket, I365_IO(map)+I365_W_STOP, io->stop);
+
+	ioctl = indirect_read(socket, I365_IOCTL) & ~I365_IOCTL_MASK(map);
+
+	if (io->flags & MAP_0WS) ioctl |= I365_IOCTL_0WS(map);
+	if (io->flags & MAP_16BIT) ioctl |= I365_IOCTL_16BIT(map);
+	if (io->flags & MAP_AUTOSZ) ioctl |= I365_IOCTL_IOCS16(map);
+
+	indirect_write(socket, I365_IOCTL, ioctl);
+
+	/* Turn the window back on if needed */
+	if (io->flags & MAP_ACTIVE)
+		indirect_setbit(socket, I365_ADDRWIN, I365_ENA_IO(map));
+
+	return 0;
+}
+
+static int pd6729_set_mem_map(struct pcmcia_socket *sock,
+			      struct pccard_mem_map *mem)
+{
+	struct pd6729_socket *socket
+			 = container_of(sock, struct pd6729_socket, socket);
+	unsigned short base, i;
+	unsigned char map;
+
+	map = mem->map;
+	if (map > 4) {
+		printk("pd6729_set_mem_map: invalid map");
+		return -EINVAL;
+	}
+
+	if ((mem->res->start > mem->res->end) || (mem->speed > 1000)) {
+		printk("pd6729_set_mem_map: invalid address / speed");
+		return -EINVAL;
+	}
+
+	/* Turn off the window before changing anything */
+	if (indirect_read(socket, I365_ADDRWIN) & I365_ENA_MEM(map))
+		indirect_resetbit(socket, I365_ADDRWIN, I365_ENA_MEM(map));
+
+	/* write the start address */
+	base = I365_MEM(map);
+	i = (mem->res->start >> 12) & 0x0fff;
+	if (mem->flags & MAP_16BIT)
+		i |= I365_MEM_16BIT;
+	if (mem->flags & MAP_0WS)
+		i |= I365_MEM_0WS;
+	indirect_write16(socket, base + I365_W_START, i);
+
+	/* write the stop address */
+
+	i= (mem->res->end >> 12) & 0x0fff;
+	switch (to_cycles(mem->speed)) {
+	case 0:
+		break;
+	case 1:
+		i |= I365_MEM_WS0;
+		break;
+	case 2:
+		i |= I365_MEM_WS1;
+		break;
+	default:
+		i |= I365_MEM_WS1 | I365_MEM_WS0;
+		break;
+	}
+
+	indirect_write16(socket, base + I365_W_STOP, i);
+
+	/* Take care of high byte */
+	indirect_write(socket, PD67_EXT_INDEX, PD67_MEM_PAGE(map));
+	indirect_write(socket, PD67_EXT_DATA, mem->res->start >> 24);
+
+	/* card start */
+
+	i = ((mem->card_start - mem->res->start) >> 12) & 0x3fff;
+	if (mem->flags & MAP_WRPROT)
+		i |= I365_MEM_WRPROT;
+	if (mem->flags & MAP_ATTRIB) {
+		/* dprintk("requesting attribute memory for socket %i\n",
+			socket->number);*/
+		i |= I365_MEM_REG;
+	} else {
+		/* dprintk("requesting normal memory for socket %i\n",
+			socket->number);*/
+	}
+	indirect_write16(socket, base + I365_W_OFF, i);
+
+	/* Enable the window if necessary */
+	if (mem->flags & MAP_ACTIVE)
+		indirect_setbit(socket, I365_ADDRWIN, I365_ENA_MEM(map));
+
+	return 0;
+}
+
+static int pd6729_init(struct pcmcia_socket *sock)
+{
+	int i;
+	struct resource res = { .end = 0x0fff };
+	pccard_io_map io = { 0, 0, 0, 0, 1 };
+	pccard_mem_map mem = { .res = &res, };
+
+	pd6729_set_socket(sock, &dead_socket);
+	for (i = 0; i < 2; i++) {
+		io.map = i;
+		pd6729_set_io_map(sock, &io);
+	}
+	for (i = 0; i < 5; i++) {
+		mem.map = i;
+		pd6729_set_mem_map(sock, &mem);
+	}
+
+	return 0;
+}
+
+
+/* the pccard structure and its functions */
+static struct pccard_operations pd6729_operations = {
+	.init 			= pd6729_init,
+	.get_status		= pd6729_get_status,
+	.get_socket		= pd6729_get_socket,
+	.set_socket		= pd6729_set_socket,
+	.set_io_map		= pd6729_set_io_map,
+	.set_mem_map		= pd6729_set_mem_map,
+};
+
+static irqreturn_t pd6729_test(int irq, void *dev, struct pt_regs *regs)
+{
+	dprintk("-> hit on irq %d\n", irq);
+	return IRQ_HANDLED;
+}
+
+static int pd6729_check_irq(int irq, int flags)
+{
+	if (request_irq(irq, pd6729_test, flags, "x", pd6729_test) != 0)
+		return -1;
+	free_irq(irq, pd6729_test);
+	return 0;
+}
+
+static u_int __init pd6729_isa_scan(void)
+{
+	u_int mask0, mask = 0;
+	int i;
+
+	if (irq_mode == 1) {
+		printk(KERN_INFO "pd6729: PCI card interrupts, "
+						"PCI status changes\n");
+		return 0;
+	}
+
+	if (irq_list_count == 0)
+		mask0 = 0xffff;
+	else
+		for (i = mask0 = 0; i < irq_list_count; i++)
+			mask0 |= (1<<irq_list[i]);
+
+	mask0 &= PD67_MASK;
+
+	/* just find interrupts that aren't in use */
+	for (i = 0; i < 16; i++)
+		if ((mask0 & (1 << i)) && (pd6729_check_irq(i, 0) == 0))
+			mask |= (1 << i);
+
+	printk(KERN_INFO "pd6729: ISA irqs = ");
+	for (i = 0; i < 16; i++)
+		if (mask & (1<<i))
+			printk("%s%d", ((mask & ((1<<i)-1)) ? "," : ""), i);
+
+	if (mask == 0) printk("none!");
+
+	printk("  polling status changes.\n");
+
+	return mask;
+}
+
+static int __devinit pd6729_pci_probe(struct pci_dev *dev,
+				      const struct pci_device_id *id)
+{
+	int i, j, ret;
+	u_int mask;
+	char configbyte;
+	struct pd6729_socket *socket;
+
+	socket = kmalloc(sizeof(struct pd6729_socket) * MAX_SOCKETS,
+			 GFP_KERNEL);
+	if (!socket)
+		return -ENOMEM;
+
+	memset(socket, 0, sizeof(struct pd6729_socket) * MAX_SOCKETS);
+
+	if ((ret = pci_enable_device(dev)))
+		goto err_out_free_mem;
+
+	printk(KERN_INFO "pd6729: Cirrus PD6729 PCI to PCMCIA Bridge "
+		"at 0x%lx on irq %d\n",	pci_resource_start(dev, 0), dev->irq);
+ 	/*
+	 * Since we have no memory BARs some firmware may not
+	 * have had PCI_COMMAND_MEMORY enabled, yet the device needs it.
+	 */
+	pci_read_config_byte(dev, PCI_COMMAND, &configbyte);
+	if (!(configbyte & PCI_COMMAND_MEMORY)) {
+		printk(KERN_DEBUG "pd6729: Enabling PCI_COMMAND_MEMORY.\n");
+		configbyte |= PCI_COMMAND_MEMORY;
+		pci_write_config_byte(dev, PCI_COMMAND, configbyte);
+	}
+
+	ret = pci_request_regions(dev, "pd6729");
+	if (ret) {
+		printk(KERN_INFO "pd6729: pci request region failed.\n");
+		goto err_out_disable;
+	}
+
+	if (dev->irq == NO_IRQ)
+		irq_mode = 0;	/* fall back to ISA interrupt mode */
+
+	mask = pd6729_isa_scan();
+	if (irq_mode == 0 && mask == 0) {
+		printk(KERN_INFO "pd6729: no ISA interrupt is available.\n");
+		goto err_out_free_res;
+	}
+
+	for (i = 0; i < MAX_SOCKETS; i++) {
+		socket[i].io_base = pci_resource_start(dev, 0);
+		socket[i].socket.features |= SS_CAP_PCCARD;
+		socket[i].socket.map_size = 0x1000;
+		socket[i].socket.irq_mask = mask;
+		socket[i].socket.pci_irq  = dev->irq;
+		socket[i].socket.owner = THIS_MODULE;
+
+		socket[i].number = i;
+
+		socket[i].socket.ops = &pd6729_operations;
+		socket[i].socket.resource_ops = &pccard_nonstatic_ops;
+		socket[i].socket.dev.dev = &dev->dev;
+		socket[i].socket.driver_data = &socket[i];
+	}
+
+	pci_set_drvdata(dev, socket);
+	if (irq_mode == 1) {
+		/* Register the interrupt handler */
+		if ((ret = request_irq(dev->irq, pd6729_interrupt, SA_SHIRQ,
+							"pd6729", socket))) {
+			printk(KERN_ERR "pd6729: Failed to register irq %d, "
+							"aborting\n", dev->irq);
+			goto err_out_free_res;
+		}
+	} else {
+		/* poll Card status change */
+		init_timer(&socket->poll_timer);
+		socket->poll_timer.function = pd6729_interrupt_wrapper;
+		socket->poll_timer.data = (unsigned long)socket;
+		socket->poll_timer.expires = jiffies + HZ;
+		add_timer(&socket->poll_timer);
+	}
+
+	for (i = 0; i < MAX_SOCKETS; i++) {
+		ret = pcmcia_register_socket(&socket[i].socket);
+		if (ret) {
+			printk(KERN_INFO "pd6729: pcmcia_register_socket "
+					       "failed.\n");
+			for (j = 0; j < i ; j++)
+				pcmcia_unregister_socket(&socket[j].socket);
+			goto err_out_free_res2;
+		}
+	}
+
+	return 0;
+
+ err_out_free_res2:
+	if (irq_mode == 1)
+		free_irq(dev->irq, socket);
+	else
+		del_timer_sync(&socket->poll_timer);
+ err_out_free_res:
+	pci_release_regions(dev);
+ err_out_disable:
+	pci_disable_device(dev);
+
+ err_out_free_mem:
+	kfree(socket);
+	return ret;
+}
+
+static void __devexit pd6729_pci_remove(struct pci_dev *dev)
+{
+	int i;
+	struct pd6729_socket *socket = pci_get_drvdata(dev);
+
+	for (i = 0; i < MAX_SOCKETS; i++) {
+		/* Turn off all interrupt sources */
+		indirect_write(&socket[i], I365_CSCINT, 0);
+		indirect_write(&socket[i], I365_INTCTL, 0);
+
+		pcmcia_unregister_socket(&socket[i].socket);
+	}
+
+	if (irq_mode == 1)
+		free_irq(dev->irq, socket);
+	else
+		del_timer_sync(&socket->poll_timer);
+	pci_release_regions(dev);
+	pci_disable_device(dev);
+
+	kfree(socket);
+}
+
+static int pd6729_socket_suspend(struct pci_dev *dev, pm_message_t state)
+{
+	return pcmcia_socket_dev_suspend(&dev->dev, state);
+}
+
+static int pd6729_socket_resume(struct pci_dev *dev)
+{
+	return pcmcia_socket_dev_resume(&dev->dev);
+}
+
+static struct pci_device_id pd6729_pci_ids[] = {
+	{
+		.vendor		= PCI_VENDOR_ID_CIRRUS,
+		.device		= PCI_DEVICE_ID_CIRRUS_6729,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(pci, pd6729_pci_ids);
+
+static struct pci_driver pd6729_pci_drv = {
+	.name		= "pd6729",
+	.id_table	= pd6729_pci_ids,
+	.probe		= pd6729_pci_probe,
+	.remove		= __devexit_p(pd6729_pci_remove),
+	.suspend	= pd6729_socket_suspend,
+	.resume		= pd6729_socket_resume,
+};
+
+static int pd6729_module_init(void)
+{
+	return pci_register_driver(&pd6729_pci_drv);
+}
+
+static void pd6729_module_exit(void)
+{
+	pci_unregister_driver(&pd6729_pci_drv);
+}
+
+module_init(pd6729_module_init);
+module_exit(pd6729_module_exit);
