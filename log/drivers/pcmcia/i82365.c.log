commit 41760d0e0f1a013e607956eaf22a60ff6dd03784
Author: Kees Cook <keescook@chromium.org>
Date:   Sat Oct 21 12:09:17 2017 -0700

    drivers/pcmcia: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: David Howells <dhowells@redhat.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-pcmcia@lists.infradead.org
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk> # for soc_common.c

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index fb38cc01859f..891ccea2cccb 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -875,7 +875,7 @@ static irqreturn_t pcic_interrupt(int irq, void *dev)
     return IRQ_RETVAL(handled);
 } /* pcic_interrupt */
 
-static void pcic_interrupt_wrapper(u_long data)
+static void pcic_interrupt_wrapper(struct timer_list *unused)
 {
     pcic_interrupt(0, NULL);
     poll_timer.expires = jiffies + poll_interval;
@@ -1289,9 +1289,7 @@ static int __init init_i82365(void)
 
     /* Finally, schedule a polling interrupt */
     if (poll_interval != 0) {
-	poll_timer.function = pcic_interrupt_wrapper;
-	poll_timer.data = 0;
-	init_timer(&poll_timer);
+	timer_setup(&poll_timer, pcic_interrupt_wrapper, 0);
     	poll_timer.expires = jiffies + poll_interval;
 	add_timer(&poll_timer);
     }

commit 9149ba1fc2276181c7f80969d349ea25a7f9fe1f
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 4 16:54:27 2017 +0100

    Annotate hardware config module parameters in drivers/pcmcia/
    
    When the kernel is running in secure boot mode, we lock down the kernel to
    prevent userspace from modifying the running kernel image.  Whilst this
    includes prohibiting access to things like /dev/mem, it must also prevent
    access by means of configuring driver modules in such a way as to cause a
    device to access or modify the kernel image.
    
    To this end, annotate module_param* statements that refer to hardware
    configuration and indicate for future reference what type of parameter they
    specify.  The parameter parser in the core sees this information and can
    skip such parameters with an error message if the kernel is locked down.
    The module initialisation then runs as normal, but just sees whatever the
    default values for those parameters is.
    
    Note that we do still need to do the module initialisation because some
    drivers have viable defaults set in case parameters aren't specified and
    some drivers support automatic configuration (e.g. PNP or PCI) in addition
    to manually coded parameters.
    
    This patch annotates drivers in drivers/pcmcia/.
    
    Suggested-by: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: linux-pcmcia@lists.infradead.org

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index eb0d80a429e4..fb38cc01859f 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -108,12 +108,12 @@ static int async_clock = -1;
 static int cable_mode = -1;
 static int wakeup = 0;
 
-module_param(i365_base, ulong, 0444);
+module_param_hw(i365_base, ulong, ioport, 0444);
 module_param(ignore, int, 0444);
 module_param(extra_sockets, int, 0444);
-module_param(irq_mask, int, 0444);
-module_param_array(irq_list, int, &irq_list_count, 0444);
-module_param(cs_irq, int, 0444);
+module_param_hw(irq_mask, int, other, 0444);
+module_param_hw_array(irq_list, int, irq, &irq_list_count, 0444);
+module_param_hw(cs_irq, int, irq, 0444);
 module_param(async_clock, int, 0444);
 module_param(cable_mode, int, 0444);
 module_param(wakeup, int, 0444);

commit 8b0eb8377d3a2cbe242bb4d0a499d21cffe4c8b6
Author: Himangi Saraogi <himangi774@gmail.com>
Date:   Wed Aug 6 19:35:47 2014 +0530

    pcmcia: Remove typedef in structs and emum
    
    The Linux kernel coding style guidelines suggest not using typedefs
    for structure and enum types. This patch gets rid of the typedefs for
    cirrus_state_t, vg46x_state_t and pcic_id. Also, the names of the structs
    are changed to drop the _t, to make the name look less typedef-like.
    
    The following Coccinelle semantic patch detects the cases for struct type:
    
    @tn@
    identifier i;
    type td;
    @@
    
    -typedef
     struct i { ... }
    -td
     ;
    
    @@
    type tn.td;
    identifier tn.i;
    @@
    
    -td
    + struct i
    
    [linux@dominikbrodowski.net: fix patch to apply cleanly after e632cd94723e
     was applied first]
    Signed-off-by: Himangi Saraogi <himangi774@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 22e9b52107b1..eb0d80a429e4 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -132,14 +132,14 @@ module_param(recov_time, int, 0444);
 
 /*====================================================================*/
 
-typedef struct cirrus_state_t {
+struct cirrus_state {
     u_char		misc1, misc2;
     u_char		timer[6];
-} cirrus_state_t;
+};
 
-typedef struct vg46x_state_t {
+struct vg46x_state {
     u_char		ctl, ema;
-} vg46x_state_t;
+};
 
 struct i82365_socket {
     u_short		type, flags;
@@ -149,8 +149,8 @@ struct i82365_socket {
     u_short		psock;
     u_char		cs_irq, intr;
     union {
-	cirrus_state_t		cirrus;
-	vg46x_state_t		vg46x;
+	struct cirrus_state		cirrus;
+	struct vg46x_state		vg46x;
     } state;
 };
 
@@ -173,11 +173,11 @@ static struct timer_list poll_timer;
 /*====================================================================*/
 
 /* These definitions must match the pcic table! */
-typedef enum pcic_id {
+enum pcic_id {
     IS_I82365A, IS_I82365B, IS_I82365DF,
     IS_IBM, IS_RF5Cx96, IS_VLSI, IS_VG468, IS_VG469,
     IS_PD6710, IS_PD672X, IS_VT83C469,
-} pcic_id;
+};
 
 /* Flags for classifying groups of controllers */
 #define IS_VADEM	0x0001
@@ -189,12 +189,12 @@ typedef enum pcic_id {
 #define IS_REGISTERED	0x2000
 #define IS_ALIVE	0x8000
 
-typedef struct pcic_t {
+struct pcic {
     char		*name;
     u_short		flags;
-} pcic_t;
+};
 
-static pcic_t pcic[] = {
+static struct pcic pcic[] = {
     { "Intel i82365sl A step", 0 },
     { "Intel i82365sl B step", 0 },
     { "Intel i82365sl DF", IS_DF_PWR },
@@ -294,7 +294,7 @@ static void i365_set_pair(u_short sock, u_short reg, u_short data)
 static void cirrus_get_state(u_short s)
 {
     int i;
-    cirrus_state_t *p = &socket[s].state.cirrus;
+    struct cirrus_state *p = &socket[s].state.cirrus;
     p->misc1 = i365_get(s, PD67_MISC_CTL_1);
     p->misc1 &= (PD67_MC1_MEDIA_ENA | PD67_MC1_INPACK_ENA);
     p->misc2 = i365_get(s, PD67_MISC_CTL_2);
@@ -306,7 +306,7 @@ static void cirrus_set_state(u_short s)
 {
     int i;
     u_char misc;
-    cirrus_state_t *p = &socket[s].state.cirrus;
+    struct cirrus_state *p = &socket[s].state.cirrus;
 
     misc = i365_get(s, PD67_MISC_CTL_2);
     i365_set(s, PD67_MISC_CTL_2, p->misc2);
@@ -321,7 +321,7 @@ static void cirrus_set_state(u_short s)
 static u_int __init cirrus_set_opts(u_short s, char *buf)
 {
     struct i82365_socket *t = &socket[s];
-    cirrus_state_t *p = &socket[s].state.cirrus;
+    struct cirrus_state *p = &socket[s].state.cirrus;
     u_int mask = 0xffff;
 
     if (has_ring == -1) has_ring = 1;
@@ -377,7 +377,7 @@ static u_int __init cirrus_set_opts(u_short s, char *buf)
 
 static void vg46x_get_state(u_short s)
 {
-    vg46x_state_t *p = &socket[s].state.vg46x;
+    struct vg46x_state *p = &socket[s].state.vg46x;
     p->ctl = i365_get(s, VG468_CTL);
     if (socket[s].type == IS_VG469)
 	p->ema = i365_get(s, VG469_EXT_MODE);
@@ -385,7 +385,7 @@ static void vg46x_get_state(u_short s)
 
 static void vg46x_set_state(u_short s)
 {
-    vg46x_state_t *p = &socket[s].state.vg46x;
+    struct vg46x_state *p = &socket[s].state.vg46x;
     i365_set(s, VG468_CTL, p->ctl);
     if (socket[s].type == IS_VG469)
 	i365_set(s, VG469_EXT_MODE, p->ema);
@@ -393,7 +393,7 @@ static void vg46x_set_state(u_short s)
 
 static u_int __init vg46x_set_opts(u_short s, char *buf)
 {
-    vg46x_state_t *p = &socket[s].state.vg46x;
+    struct vg46x_state *p = &socket[s].state.vg46x;
     
     flip(p->ctl, VG468_CTL_ASYNC, async_clock);
     flip(p->ema, VG469_MODE_CABLE, cable_mode);

commit 221f7edb732d5b81d0b41b5c4811121e1c400064
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Wed Aug 29 10:40:04 2012 -0400

    PCMCIA: Remove commented references to dead class_device_create_file()
    
    Since this routine doesn't even exist anymore, there's no point
    leaving in commented code using it.
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 479b7951b1c3..22e9b52107b1 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -1285,13 +1285,6 @@ static int __init init_i82365(void)
 	    ret = pcmcia_register_socket(&socket[i].socket);
 	    if (!ret)
 		    socket[i].flags |= IS_REGISTERED;
-
-#if 0 /* driver model ordering issue */
-	   class_device_create_file(&socket[i].socket.dev,
-			   	    &class_device_attr_info);
-	   class_device_create_file(&socket[i].socket.dev,
-			   	    &class_device_attr_exca);
-#endif
     }
 
     /* Finally, schedule a polling interrupt */

commit e632cd94723e12083ee5d0c633f37ce504a54c2b
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Tue Apr 10 18:56:49 2012 -0600

    pcmcia: replace open-coded ARRAY_SIZE with macro
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index a2c138719bac..479b7951b1c3 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -208,7 +208,7 @@ static pcic_t pcic[] = {
     { "VIA VT83C469", IS_CIRRUS|IS_VIA },
 };
 
-#define PCIC_COUNT	(sizeof(pcic)/sizeof(pcic_t))
+#define PCIC_COUNT	ARRAY_SIZE(pcic)
 
 /*====================================================================*/
 

commit 735fc3ec3434dd71c3846766a857812571c79925
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:21 2014 +0200

    pcmcia: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index e6f3d17dd2b4..a2c138719bac 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -1233,7 +1233,6 @@ static struct pccard_operations pcic_operations = {
 static struct platform_driver i82365_driver = {
 	.driver = {
 		.name = "i82365",
-		.owner		= THIS_MODULE,
 	},
 };
 

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 72a033a2acdb..e6f3d17dd2b4 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -48,7 +48,6 @@
 #include <linux/bitops.h>
 #include <asm/irq.h>
 #include <asm/io.h>
-#include <asm/system.h>
 
 #include <pcmcia/ss.h>
 

commit 1ac71e5a35eebee60cdcf15b3980bd94498f037b
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Jul 29 19:27:09 2010 +0200

    pcmcia: convert pcmcia_request_configuration to pcmcia_enable_device
    
    pcmcia_enable_device() now replaces pcmcia_request_configuration().
    Instead of config_req_t, all necessary flags are either passed as
    a parameter to pcmcia_enable_device(), or (in rare circumstances)
    set in struct pcmcia_device -> flags.
    
    With the last remaining user of include/pcmcia/cs.h gone, remove
    all references.
    
    CC: netdev@vger.kernel.org
    CC: linux-wireless@vger.kernel.org
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    CC: Jiri Kosina <jkosina@suse.cz>
    CC: linux-scsi@vger.kernel.org
    Acked-by: Gustavo F. Padovan <padovan@profusion.mobi> (for drivers/bluetooth)
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 61746bd598b3..72a033a2acdb 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -51,7 +51,6 @@
 #include <asm/system.h>
 
 #include <pcmcia/ss.h>
-#include <pcmcia/cs.h>
 
 #include <linux/isapnp.h>
 

commit ac8b422838046ffc26be4874a3cbae0d313f4209
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Wed Jul 21 22:38:13 2010 +0200

    pcmcia: remove cs_types.h
    
    Remove cs_types.h which is no longer needed: Most definitions aren't
    used at all, a few can be made away with, and two remaining definitions
    (typedefs, unfortunatley) may be moved to more specific places.
    
    CC: linux-ide@vger.kernel.org
    CC: linux-usb@vger.kernel.org
    CC: laforge@gnumonks.org
    CC: linux-mtd@lists.infradead.org
    CC: alsa-devel@alsa-project.org
    CC: linux-serial@vger.kernel.org
    Acked-by: Marcel Holtmann <marcel@holtmann.org> (for drivers/bluetooth/)
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 9e2a15628de5..61746bd598b3 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -50,7 +50,6 @@
 #include <asm/io.h>
 #include <asm/system.h>
 
-#include <pcmcia/cs_types.h>
 #include <pcmcia/ss.h>
 #include <pcmcia/cs.h>
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index d53d9b5659c7..9e2a15628de5 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -40,7 +40,6 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/timer.h>
-#include <linux/slab.h>
 #include <linux/ioport.h>
 #include <linux/delay.h>
 #include <linux/workqueue.h>

commit d7646f7632549124fe70fec8af834c7c1246f365
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Mon Mar 15 21:46:34 2010 +0100

    pcmcia: use dev_pm_ops for class pcmcia_socket_class
    
    Instead of requiring PCMCIA socket drivers to call various functions
    during their (bus) resume and suspend functions, register an own
    dev_pm_ops for this class. This fixes several suspend/resume bugs
    seen on db1xxx-ss, and probably on some other socket drivers, too.
    
    With regard to the asymmetry with only _noirq suspend, but split up
    resume, please see bug 14334 and commit 9905d1b411946fb3 .
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index c13fd9360511..d53d9b5659c7 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -1223,16 +1223,7 @@ static int pcic_init(struct pcmcia_socket *s)
 	return 0;
 }
 
-static int i82365_drv_pcmcia_suspend(struct platform_device *dev,
-				     pm_message_t state)
-{
-	return pcmcia_socket_dev_suspend(&dev->dev);
-}
 
-static int i82365_drv_pcmcia_resume(struct platform_device *dev)
-{
-	return pcmcia_socket_dev_resume(&dev->dev);
-}
 static struct pccard_operations pcic_operations = {
 	.init			= pcic_init,
 	.get_status		= pcic_get_status,
@@ -1248,8 +1239,6 @@ static struct platform_driver i82365_driver = {
 		.name = "i82365",
 		.owner		= THIS_MODULE,
 	},
-	.suspend 	= i82365_drv_pcmcia_suspend,
-	.resume 	= i82365_drv_pcmcia_resume,
 };
 
 static struct platform_device *i82365_device;

commit c9f50dddd184a020d64dab63fa795967f0f14aa4
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Fri Oct 23 12:56:46 2009 +0200

    pcmcia: use dynamic debug in PCMCIA socket drivers
    
    Make use of the dynamic debug infrastructure in various PCMCIA socket
    drivers. By doing so, only the drivers relying on soc_common make use
    of CONFIG_PCMCIA_DEBUG. Therefore, update the Kconfig entry accordingly.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index a4aacb830b80..c13fd9360511 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -63,21 +63,6 @@
 #include "vg468.h"
 #include "ricoh.h"
 
-#ifdef CONFIG_PCMCIA_DEBUG
-static const char version[] =
-"i82365.c 1.265 1999/11/10 18:36:21 (David Hinds)";
-
-static int pc_debug;
-
-module_param(pc_debug, int, 0644);
-
-#define debug(lvl, fmt, arg...) do {				\
-	if (pc_debug > (lvl))					\
-		printk(KERN_DEBUG "i82365: " fmt , ## arg);	\
-} while (0)
-#else
-#define debug(lvl, fmt, arg...) do { } while (0)
-#endif
 
 static irqreturn_t i365_count_irq(int, void *);
 static inline int _check_irq(int irq, int flags)
@@ -501,13 +486,13 @@ static irqreturn_t i365_count_irq(int irq, void *dev)
 {
     i365_get(irq_sock, I365_CSC);
     irq_hits++;
-    debug(2, "-> hit on irq %d\n", irq);
+    pr_debug("i82365: -> hit on irq %d\n", irq);
     return IRQ_HANDLED;
 }
 
 static u_int __init test_irq(u_short sock, int irq)
 {
-    debug(2, "  testing ISA irq %d\n", irq);
+    pr_debug("i82365:  testing ISA irq %d\n", irq);
     if (request_irq(irq, i365_count_irq, IRQF_PROBE_SHARED, "scan",
 			i365_count_irq) != 0)
 	return 1;
@@ -515,7 +500,7 @@ static u_int __init test_irq(u_short sock, int irq)
     msleep(10);
     if (irq_hits) {
 	free_irq(irq, i365_count_irq);
-	debug(2, "    spurious hit!\n");
+	pr_debug("i82365:    spurious hit!\n");
 	return 1;
     }
 
@@ -528,7 +513,7 @@ static u_int __init test_irq(u_short sock, int irq)
 
     /* mask all interrupts */
     i365_set(sock, I365_CSCINT, 0);
-    debug(2, "    hits = %d\n", irq_hits);
+    pr_debug("i82365:    hits = %d\n", irq_hits);
     
     return (irq_hits != 1);
 }
@@ -854,7 +839,7 @@ static irqreturn_t pcic_interrupt(int irq, void *dev)
     u_long flags = 0;
     int handled = 0;
 
-    debug(4, "pcic_interrupt(%d)\n", irq);
+    pr_debug("pcic_interrupt(%d)\n", irq);
 
     for (j = 0; j < 20; j++) {
 	active = 0;
@@ -878,7 +863,7 @@ static irqreturn_t pcic_interrupt(int irq, void *dev)
 		events |= (csc & I365_CSC_READY) ? SS_READY : 0;
 	    }
 	    ISA_UNLOCK(i, flags);
-	    debug(2, "socket %d event 0x%02x\n", i, events);
+	    pr_debug("socket %d event 0x%02x\n", i, events);
 
 	    if (events)
 		pcmcia_parse_events(&socket[i].socket, events);
@@ -890,7 +875,7 @@ static irqreturn_t pcic_interrupt(int irq, void *dev)
     if (j == 20)
 	printk(KERN_NOTICE "i82365: infinite loop in interrupt handler\n");
 
-    debug(4, "interrupt done\n");
+    pr_debug("pcic_interrupt done\n");
     return IRQ_RETVAL(handled);
 } /* pcic_interrupt */
 
@@ -932,7 +917,7 @@ static int i365_get_status(u_short sock, u_int *value)
 	}
     }
     
-    debug(1, "GetStatus(%d) = %#4.4x\n", sock, *value);
+    pr_debug("GetStatus(%d) = %#4.4x\n", sock, *value);
     return 0;
 } /* i365_get_status */
 
@@ -943,7 +928,7 @@ static int i365_set_socket(u_short sock, socket_state_t *state)
     struct i82365_socket *t = &socket[sock];
     u_char reg;
     
-    debug(1, "SetSocket(%d, flags %#3.3x, Vcc %d, Vpp %d, "
+    pr_debug("SetSocket(%d, flags %#3.3x, Vcc %d, Vpp %d, "
 	  "io_irq %d, csc_mask %#2.2x)\n", sock, state->flags,
 	  state->Vcc, state->Vpp, state->io_irq, state->csc_mask);
     
@@ -1052,7 +1037,7 @@ static int i365_set_io_map(u_short sock, struct pccard_io_map *io)
 {
     u_char map, ioctl;
     
-    debug(1, "SetIOMap(%d, %d, %#2.2x, %d ns, "
+    pr_debug("SetIOMap(%d, %d, %#2.2x, %d ns, "
 	  "%#llx-%#llx)\n", sock, io->map, io->flags, io->speed,
 	  (unsigned long long)io->start, (unsigned long long)io->stop);
     map = io->map;
@@ -1082,7 +1067,7 @@ static int i365_set_mem_map(u_short sock, struct pccard_mem_map *mem)
     u_short base, i;
     u_char map;
     
-    debug(1, "SetMemMap(%d, %d, %#2.2x, %d ns, %#llx-%#llx, "
+    pr_debug("SetMemMap(%d, %d, %#2.2x, %d ns, %#llx-%#llx, "
 	  "%#x)\n", sock, mem->map, mem->flags, mem->speed,
 	  (unsigned long long)mem->res->start,
 	  (unsigned long long)mem->res->end, mem->card_start);

commit 01373046612d2bbd01064c3beaf18ff3338dafae
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Sun Oct 11 18:50:09 2009 -0700

    pcmcia: fix controller printk format warnings
    
    Fix new pcmcia printk format warnings:
    [This has now moved from linux-next to mainline.
    Originally sent 2009-SEP-17.]
    
    drivers/pcmcia/i82365.c:1055: warning: format '%#x' expects type 'unsigned int', but argument 6 has type 'phys_addr_t'
    drivers/pcmcia/i82365.c:1055: warning: format '%#x' expects type 'unsigned int', but argument 7 has type 'phys_addr_t'
    drivers/pcmcia/tcic.c:734: warning: format '%#x' expects type 'unsigned int', but argument 6 has type 'phys_addr_t'
    drivers/pcmcia/tcic.c:734: warning: format '%#x' expects type 'unsigned int', but argument 7 has type 'phys_addr_t'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index b906abe26ad0..a4aacb830b80 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -1053,8 +1053,8 @@ static int i365_set_io_map(u_short sock, struct pccard_io_map *io)
     u_char map, ioctl;
     
     debug(1, "SetIOMap(%d, %d, %#2.2x, %d ns, "
-	  "%#x-%#x)\n", sock, io->map, io->flags,
-	  io->speed, io->start, io->stop);
+	  "%#llx-%#llx)\n", sock, io->map, io->flags, io->speed,
+	  (unsigned long long)io->start, (unsigned long long)io->stop);
     map = io->map;
     if ((map > 1) || (io->start > 0xffff) || (io->stop > 0xffff) ||
 	(io->stop < io->start)) return -EINVAL;

commit 827b4649d4626bf97b203b4bcd69476bb9b4e760
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Tue Sep 29 00:10:41 2009 +0200

    PM / PCMCIA: Drop second argument of pcmcia_socket_dev_suspend()
    
    pcmcia_socket_dev_suspend() doesn't use its second argument, so it
    may be dropped safely.
    
    This change is necessary for the subsequent yenta suspend/resume fix.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: stable@kernel.org

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 40d4953e4b12..b906abe26ad0 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -1241,7 +1241,7 @@ static int pcic_init(struct pcmcia_socket *s)
 static int i82365_drv_pcmcia_suspend(struct platform_device *dev,
 				     pm_message_t state)
 {
-	return pcmcia_socket_dev_suspend(&dev->dev, state);
+	return pcmcia_socket_dev_suspend(&dev->dev);
 }
 
 static int i82365_drv_pcmcia_resume(struct platform_device *dev)

commit 7a192ec334cab9fafe3a8665a65af398b0e24730
Author: Ming Lei <tom.leiming@gmail.com>
Date:   Fri Feb 6 23:40:12 2009 +0800

    platform driver: fix incorrect use of 'platform_bus_type' with 'struct device_driver'
    
    This patch fixes the bug reported in
            http://bugzilla.kernel.org/show_bug.cgi?id=11681.
    
    "Lots of device drivers register a 'struct device_driver' with
    the '.bus' member set to '&platform_bus_type'. This is wrong,
    since the platform_bus functions expect the 'struct device_driver'
    to be wrapped up in a 'struct platform_driver' which provides
    some additional callbacks (like suspend_late, resume_early).
    The effect may be that platform_suspend_late() uses bogus data
    outside the device_driver struct as a pointer pointer to the
    device driver's suspend_late() function or other hard to
    reproduce failures."(Lothar Wassmann)
    
    Signed-off-by: Ming Lei <tom.leiming@gmail.com>
    Acked-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Acked-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 71653ab84890..40d4953e4b12 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -1238,6 +1238,16 @@ static int pcic_init(struct pcmcia_socket *s)
 	return 0;
 }
 
+static int i82365_drv_pcmcia_suspend(struct platform_device *dev,
+				     pm_message_t state)
+{
+	return pcmcia_socket_dev_suspend(&dev->dev, state);
+}
+
+static int i82365_drv_pcmcia_resume(struct platform_device *dev)
+{
+	return pcmcia_socket_dev_resume(&dev->dev);
+}
 static struct pccard_operations pcic_operations = {
 	.init			= pcic_init,
 	.get_status		= pcic_get_status,
@@ -1248,11 +1258,13 @@ static struct pccard_operations pcic_operations = {
 
 /*====================================================================*/
 
-static struct device_driver i82365_driver = {
-	.name = "i82365",
-	.bus = &platform_bus_type,
-	.suspend = pcmcia_socket_dev_suspend,
-	.resume = pcmcia_socket_dev_resume,
+static struct platform_driver i82365_driver = {
+	.driver = {
+		.name = "i82365",
+		.owner		= THIS_MODULE,
+	},
+	.suspend 	= i82365_drv_pcmcia_suspend,
+	.resume 	= i82365_drv_pcmcia_resume,
 };
 
 static struct platform_device *i82365_device;
@@ -1261,7 +1273,7 @@ static int __init init_i82365(void)
 {
     int i, ret;
 
-    ret = driver_register(&i82365_driver);
+    ret = platform_driver_register(&i82365_driver);
     if (ret)
 	goto err_out;
 
@@ -1337,7 +1349,7 @@ static int __init init_i82365(void)
 	pnp_disable_dev(i82365_pnpdev);
 #endif
 err_driver_unregister:
-    driver_unregister(&i82365_driver);
+    platform_driver_unregister(&i82365_driver);
 err_out:
     return ret;
 } /* init_i82365 */
@@ -1365,7 +1377,7 @@ static void __exit exit_i82365(void)
     if (i82365_pnpdev)
     		pnp_disable_dev(i82365_pnpdev);
 #endif
-    driver_unregister(&i82365_driver);
+    platform_driver_unregister(&i82365_driver);
 } /* exit_i82365 */
 
 module_init(init_i82365);

commit 7d16b658bd093e75a9f72a69e2dafd2b154c4395
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Aug 2 21:02:01 2008 +0200

    pcmcia: don't add extra DEBUG cflag
    
    Use CONFIG_PCMCIA_DEBUG instead of DEBUG so that dev_dbg() and other tricks
    work properly.
    
    (includes bugfixes from and
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
    )
    
    Signed-off-by: Dominik Broodwski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 68f6b2702bc4..71653ab84890 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -63,7 +63,7 @@
 #include "vg468.h"
 #include "ricoh.h"
 
-#ifdef DEBUG
+#ifdef CONFIG_PCMCIA_DEBUG
 static const char version[] =
 "i82365.c 1.265 1999/11/10 18:36:21 (David Hinds)";
 

commit 2df697036ba69ea99b73a2dbf82dcc8fec62d4ab
Author: Leonardo Potenza <lpotenza@inwind.it>
Date:   Tue Apr 1 23:47:09 2008 +0200

    pcmcia: i82365.c: check request_irq return value
    
    Add a check for the request_irq() return value.
    
    Signed-off-by: Leonardo Potenza <lpotenza@inwind.it>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 32a2ab119798..68f6b2702bc4 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -1263,7 +1263,7 @@ static int __init init_i82365(void)
 
     ret = driver_register(&i82365_driver);
     if (ret)
-	return ret;
+	goto err_out;
 
     i82365_device = platform_device_alloc("i82365", 0);
     if (i82365_device) {
@@ -1273,10 +1273,8 @@ static int __init init_i82365(void)
     } else
 	    ret = -ENOMEM;
 
-    if (ret) {
-	driver_unregister(&i82365_driver);
-	return ret;
-    }
+    if (ret)
+	goto err_driver_unregister;
 
     printk(KERN_INFO "Intel ISA PCIC probe: ");
     sockets = 0;
@@ -1285,16 +1283,17 @@ static int __init init_i82365(void)
 
     if (sockets == 0) {
 	printk("not found.\n");
-	platform_device_unregister(i82365_device);
-	release_region(i365_base, 2);
-	driver_unregister(&i82365_driver);
-	return -ENODEV;
+	ret = -ENODEV;
+	goto err_dev_unregister;
     }
 
     /* Set up interrupt handler(s) */
     if (grab_irq != 0)
-	request_irq(cs_irq, pcic_interrupt, 0, "i82365", pcic_interrupt);
-    
+	ret = request_irq(cs_irq, pcic_interrupt, 0, "i82365", pcic_interrupt);
+
+    if (ret)
+	goto err_socket_release;
+
     /* register sockets with the pcmcia core */
     for (i = 0; i < sockets; i++) {
 	    socket[i].socket.dev.parent = &i82365_device->dev;
@@ -1324,7 +1323,23 @@ static int __init init_i82365(void)
     }
     
     return 0;
-    
+err_socket_release:
+    for (i = 0; i < sockets; i++) {
+	/* Turn off all interrupt sources! */
+	i365_set(i, I365_CSCINT, 0);
+	release_region(socket[i].ioaddr, 2);
+    }
+err_dev_unregister:
+    platform_device_unregister(i82365_device);
+    release_region(i365_base, 2);
+#ifdef CONFIG_PNP
+    if (i82365_pnpdev)
+	pnp_disable_dev(i82365_pnpdev);
+#endif
+err_driver_unregister:
+    driver_unregister(&i82365_driver);
+err_out:
+    return ret;
 } /* init_i82365 */
 
 static void __exit exit_i82365(void)

commit 906da809c5be30b4c7f32bb6a489fb25ad794878
Author: Olof Johansson <olof@lixom.net>
Date:   Mon Feb 4 22:27:35 2008 -0800

    pcmcia: replace kio_addr_t with unsigned int everywhere
    
    Remove kio_addr_t, and replace it with unsigned int.  No known architecture
    needs more than 32 bits for IO addresses and ports and having a separate type
    for it is just messy.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 839bb1c0db58..32a2ab119798 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -164,7 +164,7 @@ struct i82365_socket {
     u_short		type, flags;
     struct pcmcia_socket	socket;
     unsigned int	number;
-    kio_addr_t		ioaddr;
+    unsigned int	ioaddr;
     u_short		psock;
     u_char		cs_irq, intr;
     union {
@@ -238,7 +238,7 @@ static u_char i365_get(u_short sock, u_short reg)
     unsigned long flags;
     spin_lock_irqsave(&bus_lock,flags);
     {
-	kio_addr_t port = socket[sock].ioaddr;
+	unsigned int port = socket[sock].ioaddr;
 	u_char val;
 	reg = I365_REG(socket[sock].psock, reg);
 	outb(reg, port); val = inb(port+1);
@@ -252,7 +252,7 @@ static void i365_set(u_short sock, u_short reg, u_char data)
     unsigned long flags;
     spin_lock_irqsave(&bus_lock,flags);
     {
-	kio_addr_t port = socket[sock].ioaddr;
+	unsigned int port = socket[sock].ioaddr;
 	u_char val = I365_REG(socket[sock].psock, reg);
 	outb(val, port); outb(data, port+1);
 	spin_unlock_irqrestore(&bus_lock,flags);
@@ -588,7 +588,7 @@ static int to_cycles(int ns)
 
 /*====================================================================*/
 
-static int __init identify(kio_addr_t port, u_short sock)
+static int __init identify(unsigned int port, u_short sock)
 {
     u_char val;
     int type = -1;
@@ -659,7 +659,7 @@ static int __init identify(kio_addr_t port, u_short sock)
 static int __init is_alive(u_short sock)
 {
     u_char stat;
-    kio_addr_t start, stop;
+    unsigned int start, stop;
     
     stat = i365_get(sock, I365_STATUS);
     start = i365_get_pair(sock, I365_IO(0)+I365_W_START);
@@ -678,7 +678,7 @@ static int __init is_alive(u_short sock)
 
 /*====================================================================*/
 
-static void __init add_socket(kio_addr_t port, int psock, int type)
+static void __init add_socket(unsigned int port, int psock, int type)
 {
     socket[sockets].ioaddr = port;
     socket[sockets].psock = psock;
@@ -698,7 +698,7 @@ static void __init add_pcic(int ns, int type)
     base = sockets-ns;
     if (base == 0) printk("\n");
     printk(KERN_INFO "  %s", pcic[type].name);
-    printk(" ISA-to-PCMCIA at port %#lx ofs 0x%02x",
+    printk(" ISA-to-PCMCIA at port %#x ofs 0x%02x",
 	       t->ioaddr, t->psock*0x40);
     printk(", %d socket%s\n", ns, ((ns > 1) ? "s" : ""));
 
@@ -772,7 +772,7 @@ static struct pnp_dev *i82365_pnpdev;
 static void __init isa_probe(void)
 {
     int i, j, sock, k, ns, id;
-    kio_addr_t port;
+    unsigned int port;
 #ifdef CONFIG_PNP
     struct isapnp_device_id *devid;
     struct pnp_dev *dev;
@@ -1053,7 +1053,7 @@ static int i365_set_io_map(u_short sock, struct pccard_io_map *io)
     u_char map, ioctl;
     
     debug(1, "SetIOMap(%d, %d, %#2.2x, %d ns, "
-	  "%#lx-%#lx)\n", sock, io->map, io->flags,
+	  "%#x-%#x)\n", sock, io->map, io->flags,
 	  io->speed, io->start, io->stop);
     map = io->map;
     if ((map > 1) || (io->start > 0xffff) || (io->stop > 0xffff) ||

commit 64a6f9500d8e8a8e1b1adc2120e56cc88df5727f
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sun Oct 14 19:35:30 2007 +0100

    signedness: module_param_array nump argument
    
    ... should be unsigned int
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 71b33707117f..839bb1c0db58 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -101,7 +101,7 @@ static int ignore = -1;
 /* Bit map or list of interrupts to choose from */
 static u_int irq_mask = 0xffff;
 static int irq_list[16];
-static int irq_list_count;
+static unsigned int irq_list_count;
 /* The card status change interrupt -- 0 means autoselect */
 static int cs_irq = 0;
 

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 72ff2f615b33..71b33707117f 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -40,7 +40,6 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/timer.h>
-#include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/ioport.h>
 #include <linux/delay.h>

commit 873733188a019acdb7fa253011cbdc0a8afd97f3
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Sep 12 17:00:10 2006 +0200

    Driver core: convert pcmcia code to use struct device
    
    Converts from using struct "class_device" to "struct device" making
    everything show up properly in /sys/devices/ with symlinks from the
    /sys/class directory.
    
    Cc: <linux-pcmcia@lists.infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index ea74f98a7350..72ff2f615b33 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -1298,7 +1298,7 @@ static int __init init_i82365(void)
     
     /* register sockets with the pcmcia core */
     for (i = 0; i < sockets; i++) {
-	    socket[i].socket.dev.dev = &i82365_device->dev;
+	    socket[i].socket.dev.parent = &i82365_device->dev;
 	    socket[i].socket.ops = &pcic_operations;
 	    socket[i].socket.resource_ops = &pccard_nonstatic_ops;
 	    socket[i].socket.owner = THIS_MODULE;

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 1cc2682394b1..ea74f98a7350 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -80,7 +80,7 @@ module_param(pc_debug, int, 0644);
 #define debug(lvl, fmt, arg...) do { } while (0)
 #endif
 
-static irqreturn_t i365_count_irq(int, void *, struct pt_regs *);
+static irqreturn_t i365_count_irq(int, void *);
 static inline int _check_irq(int irq, int flags)
 {
     if (request_irq(irq, i365_count_irq, flags, "x", i365_count_irq) != 0)
@@ -498,7 +498,7 @@ static u_int __init set_bridge_opts(u_short s, u_short ns)
 static volatile u_int irq_hits;
 static u_short irq_sock;
 
-static irqreturn_t i365_count_irq(int irq, void *dev, struct pt_regs *regs)
+static irqreturn_t i365_count_irq(int irq, void *dev)
 {
     i365_get(irq_sock, I365_CSC);
     irq_hits++;
@@ -848,8 +848,7 @@ static void __init isa_probe(void)
 
 /*====================================================================*/
 
-static irqreturn_t pcic_interrupt(int irq, void *dev,
-				    struct pt_regs *regs)
+static irqreturn_t pcic_interrupt(int irq, void *dev)
 {
     int i, j, csc;
     u_int events, active;
@@ -898,7 +897,7 @@ static irqreturn_t pcic_interrupt(int irq, void *dev,
 
 static void pcic_interrupt_wrapper(u_long data)
 {
-    pcic_interrupt(0, NULL, NULL);
+    pcic_interrupt(0, NULL);
     poll_timer.expires = jiffies + poll_interval;
     add_timer(&poll_timer);
 }

commit dace145374b8e39aeb920304c358ab5e220341ab
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:38 2006 -0700

    [PATCH] irq-flags: misc drivers: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index ff51a65d9433..1cc2682394b1 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -509,7 +509,7 @@ static irqreturn_t i365_count_irq(int irq, void *dev, struct pt_regs *regs)
 static u_int __init test_irq(u_short sock, int irq)
 {
     debug(2, "  testing ISA irq %d\n", irq);
-    if (request_irq(irq, i365_count_irq, SA_PROBEIRQ, "scan",
+    if (request_irq(irq, i365_count_irq, IRQF_PROBE_SHARED, "scan",
 			i365_count_irq) != 0)
 	return 1;
     irq_hits = 0; irq_sock = sock;
@@ -562,7 +562,7 @@ static u_int __init isa_scan(u_short sock, u_int mask0)
     } else {
 	/* Fallback: just find interrupts that aren't in use */
 	for (i = 0; i < 16; i++)
-	    if ((mask0 & (1 << i)) && (_check_irq(i, SA_PROBEIRQ) == 0))
+	    if ((mask0 & (1 << i)) && (_check_irq(i, IRQF_PROBE_SHARED) == 0))
 		mask1 |= (1 << i);
 	printk("default");
 	/* If scan failed, default to polled status */
@@ -726,7 +726,7 @@ static void __init add_pcic(int ns, int type)
 	u_int cs_mask = mask & ((cs_irq) ? (1<<cs_irq) : ~(1<<12));
 	for (cs_irq = 15; cs_irq > 0; cs_irq--)
 	    if ((cs_mask & (1 << cs_irq)) &&
-		(_check_irq(cs_irq, SA_PROBEIRQ) == 0))
+		(_check_irq(cs_irq, IRQF_PROBE_SHARED) == 0))
 		break;
 	if (cs_irq) {
 	    grab_irq = 1;

commit 490ab72af6a7a74b1d77e8f1b67fdfad04371876
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 12 15:17:34 2006 -0700

    [PATCH] 64bit resource: fix up printks for resources in pcmcia drivers
    
    This is needed if we wish to change the size of the resource structures.
    
    Based on an original patch from Vivek Goyal <vgoyal@in.ibm.com>
    
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index a2f05f485156..ff51a65d9433 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -1084,9 +1084,10 @@ static int i365_set_mem_map(u_short sock, struct pccard_mem_map *mem)
     u_short base, i;
     u_char map;
     
-    debug(1, "SetMemMap(%d, %d, %#2.2x, %d ns, %#lx-%#lx, "
+    debug(1, "SetMemMap(%d, %d, %#2.2x, %d ns, %#llx-%#llx, "
 	  "%#x)\n", sock, mem->map, mem->flags, mem->speed,
-	  mem->res->start, mem->res->end, mem->card_start);
+	  (unsigned long long)mem->res->start,
+	  (unsigned long long)mem->res->end, mem->card_start);
 
     map = mem->map;
     if ((map > 4) || (mem->card_start > 0x3ffffff) ||

commit 13e87ec68641fd54f3fa04eef3419d034ed2115a
Author: Andrew Morton <akpm@osdl.org>
Date:   Thu Apr 27 18:39:18 2006 -0700

    [PATCH] request_irq(): remove warnings from irq probing
    
    - Add new SA_PROBEIRQ which suppresses the new sharing-mismatch warning.
      Some drivers like to use request_irq() to find an unused interrupt slot.
    
    - Use it in i82365.c
    
    - Kill unused SA_PROBE.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index bd0308e89815..a2f05f485156 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -509,7 +509,8 @@ static irqreturn_t i365_count_irq(int irq, void *dev, struct pt_regs *regs)
 static u_int __init test_irq(u_short sock, int irq)
 {
     debug(2, "  testing ISA irq %d\n", irq);
-    if (request_irq(irq, i365_count_irq, 0, "scan", i365_count_irq) != 0)
+    if (request_irq(irq, i365_count_irq, SA_PROBEIRQ, "scan",
+			i365_count_irq) != 0)
 	return 1;
     irq_hits = 0; irq_sock = sock;
     msleep(10);
@@ -561,7 +562,7 @@ static u_int __init isa_scan(u_short sock, u_int mask0)
     } else {
 	/* Fallback: just find interrupts that aren't in use */
 	for (i = 0; i < 16; i++)
-	    if ((mask0 & (1 << i)) && (_check_irq(i, 0) == 0))
+	    if ((mask0 & (1 << i)) && (_check_irq(i, SA_PROBEIRQ) == 0))
 		mask1 |= (1 << i);
 	printk("default");
 	/* If scan failed, default to polled status */
@@ -725,7 +726,7 @@ static void __init add_pcic(int ns, int type)
 	u_int cs_mask = mask & ((cs_irq) ? (1<<cs_irq) : ~(1<<12));
 	for (cs_irq = 15; cs_irq > 0; cs_irq--)
 	    if ((cs_mask & (1 << cs_irq)) &&
-		(_check_irq(cs_irq, 0) == 0))
+		(_check_irq(cs_irq, SA_PROBEIRQ) == 0))
 		break;
 	if (cs_irq) {
 	    grab_irq = 1;

commit e904663b4d511884145df54bead401840389853a
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Tue Jan 10 21:35:49 2006 +0100

    [PATCH] pcmcia: remove include of config.h
    
    Remove the inclusion of include/config.h as it isn't needed any longer.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 35a92d1e4945..bd0308e89815 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -34,7 +34,6 @@
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/fcntl.h>
 #include <linux/string.h>

commit 9da4bc6d6a38c1c3d850c046d0aee324c1a2e52a
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sat Nov 12 23:56:33 2005 +0100

    [PATCH] pcmcia: remove get_socket callback
    
    The .get_socket callback is never used by the PCMCIA core, therefore remove
    it.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 4d56bc9926d6..35a92d1e4945 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -940,78 +940,6 @@ static int i365_get_status(u_short sock, u_int *value)
 
 /*====================================================================*/
 
-static int i365_get_socket(u_short sock, socket_state_t *state)
-{
-    struct i82365_socket *t = &socket[sock];
-    u_char reg, vcc, vpp;
-    
-    reg = i365_get(sock, I365_POWER);
-    state->flags = (reg & I365_PWR_AUTO) ? SS_PWR_AUTO : 0;
-    state->flags |= (reg & I365_PWR_OUT) ? SS_OUTPUT_ENA : 0;
-    vcc = reg & I365_VCC_MASK; vpp = reg & I365_VPP1_MASK;
-    state->Vcc = state->Vpp = 0;
-    if (t->flags & IS_CIRRUS) {
-	if (i365_get(sock, PD67_MISC_CTL_1) & PD67_MC1_VCC_3V) {
-	    if (reg & I365_VCC_5V) state->Vcc = 33;
-	    if (vpp == I365_VPP1_5V) state->Vpp = 33;
-	} else {
-	    if (reg & I365_VCC_5V) state->Vcc = 50;
-	    if (vpp == I365_VPP1_5V) state->Vpp = 50;
-	}
-	if (vpp == I365_VPP1_12V) state->Vpp = 120;
-    } else if (t->flags & IS_VG_PWR) {
-	if (i365_get(sock, VG469_VSELECT) & VG469_VSEL_VCC) {
-	    if (reg & I365_VCC_5V) state->Vcc = 33;
-	    if (vpp == I365_VPP1_5V) state->Vpp = 33;
-	} else {
-	    if (reg & I365_VCC_5V) state->Vcc = 50;
-	    if (vpp == I365_VPP1_5V) state->Vpp = 50;
-	}
-	if (vpp == I365_VPP1_12V) state->Vpp = 120;
-    } else if (t->flags & IS_DF_PWR) {
-	if (vcc == I365_VCC_3V) state->Vcc = 33;
-	if (vcc == I365_VCC_5V) state->Vcc = 50;
-	if (vpp == I365_VPP1_5V) state->Vpp = 50;
-	if (vpp == I365_VPP1_12V) state->Vpp = 120;
-    } else {
-	if (reg & I365_VCC_5V) {
-	    state->Vcc = 50;
-	    if (vpp == I365_VPP1_5V) state->Vpp = 50;
-	    if (vpp == I365_VPP1_12V) state->Vpp = 120;
-	}
-    }
-
-    /* IO card, RESET flags, IO interrupt */
-    reg = i365_get(sock, I365_INTCTL);
-    state->flags |= (reg & I365_PC_RESET) ? 0 : SS_RESET;
-    if (reg & I365_PC_IOCARD) state->flags |= SS_IOCARD;
-    state->io_irq = reg & I365_IRQ_MASK;
-    
-    /* speaker control */
-    if (t->flags & IS_CIRRUS) {
-	if (i365_get(sock, PD67_MISC_CTL_1) & PD67_MC1_SPKR_ENA)
-	    state->flags |= SS_SPKR_ENA;
-    }
-    
-    /* Card status change mask */
-    reg = i365_get(sock, I365_CSCINT);
-    state->csc_mask = (reg & I365_CSC_DETECT) ? SS_DETECT : 0;
-    if (state->flags & SS_IOCARD)
-	state->csc_mask |= (reg & I365_CSC_STSCHG) ? SS_STSCHG : 0;
-    else {
-	state->csc_mask |= (reg & I365_CSC_BVD1) ? SS_BATDEAD : 0;
-	state->csc_mask |= (reg & I365_CSC_BVD2) ? SS_BATWARN : 0;
-	state->csc_mask |= (reg & I365_CSC_READY) ? SS_READY : 0;
-    }
-    
-    debug(1, "GetSocket(%d) = flags %#3.3x, Vcc %d, Vpp %d, "
-	  "io_irq %d, csc_mask %#2.2x\n", sock, state->flags,
-	  state->Vcc, state->Vpp, state->io_irq, state->csc_mask);
-    return 0;
-} /* i365_get_socket */
-
-/*====================================================================*/
-
 static int i365_set_socket(u_short sock, socket_state_t *state)
 {
     struct i82365_socket *t = &socket[sock];
@@ -1265,16 +1193,6 @@ static int pcic_get_status(struct pcmcia_socket *s, u_int *value)
 	LOCKED(i365_get_status(sock, value));
 }
 
-static int pcic_get_socket(struct pcmcia_socket *s, socket_state_t *state)
-{
-	unsigned int sock = container_of(s, struct i82365_socket, socket)->number;
-
-	if (socket[sock].flags & IS_ALIVE)
-		return -EINVAL;
-
-	LOCKED(i365_get_socket(sock, state));
-}
-
 static int pcic_set_socket(struct pcmcia_socket *s, socket_state_t *state)
 {
 	unsigned int sock = container_of(s, struct i82365_socket, socket)->number;
@@ -1324,7 +1242,6 @@ static int pcic_init(struct pcmcia_socket *s)
 static struct pccard_operations pcic_operations = {
 	.init			= pcic_init,
 	.get_status		= pcic_get_status,
-	.get_socket		= pcic_get_socket,
 	.set_socket		= pcic_set_socket,
 	.set_io_map		= pcic_set_io_map,
 	.set_mem_map		= pcic_set_mem_map,

commit dfb279c97510da659816f4f055146bb1f9f0a870
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Nov 10 16:26:13 2005 +0100

    [PCMCIA] i82365: use new platform_device helpers
    
    Use the new platform_device helpers in the i82365 driver to get rid of the
    "device 'i823650' does not have a release() function" warning, and to solve
    bug #3676.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 4ddd76239b34..4d56bc9926d6 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -1339,10 +1339,7 @@ static struct device_driver i82365_driver = {
 	.resume = pcmcia_socket_dev_resume,
 };
 
-static struct platform_device i82365_device = {
-	.name = "i82365",
-	.id = 0,
-};
+static struct platform_device *i82365_device;
 
 static int __init init_i82365(void)
 {
@@ -1352,7 +1349,14 @@ static int __init init_i82365(void)
     if (ret)
 	return ret;
 
-    ret = platform_device_register(&i82365_device);
+    i82365_device = platform_device_alloc("i82365", 0);
+    if (i82365_device) {
+	    ret = platform_device_add(i82365_device);
+	    if (ret)
+		    platform_device_put(i82365_device);
+    } else
+	    ret = -ENOMEM;
+
     if (ret) {
 	driver_unregister(&i82365_driver);
 	return ret;
@@ -1365,7 +1369,7 @@ static int __init init_i82365(void)
 
     if (sockets == 0) {
 	printk("not found.\n");
-	platform_device_unregister(&i82365_device);
+	platform_device_unregister(i82365_device);
 	release_region(i365_base, 2);
 	driver_unregister(&i82365_driver);
 	return -ENODEV;
@@ -1377,7 +1381,7 @@ static int __init init_i82365(void)
     
     /* register sockets with the pcmcia core */
     for (i = 0; i < sockets; i++) {
-	    socket[i].socket.dev.dev = &i82365_device.dev;
+	    socket[i].socket.dev.dev = &i82365_device->dev;
 	    socket[i].socket.ops = &pcic_operations;
 	    socket[i].socket.resource_ops = &pccard_nonstatic_ops;
 	    socket[i].socket.owner = THIS_MODULE;
@@ -1415,7 +1419,7 @@ static void __exit exit_i82365(void)
 	    if (socket[i].flags & IS_REGISTERED)
 		    pcmcia_unregister_socket(&socket[i].socket);
     }
-    platform_device_unregister(&i82365_device);
+    platform_device_unregister(i82365_device);
     if (poll_interval != 0)
 	del_timer_sync(&poll_timer);
     if (grab_irq != 0)

commit a2932b35a0efd01b20a3f598d19db052d64935f5
Author: Igor Popik <igor.popik@gmail.com>
Date:   Thu Oct 6 20:32:58 2005 +0200

    [PCMCIA] i82365: release all resources if no devices are found
    
    The i82365 driver does not release all the resources when the device is not
    found. This can cause an oops when reading /proc/ioports after module
    unload.
    
    Signed-off-by: Igor Popik <igor.popik@gmail.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 7ce455d01cc9..4ddd76239b34 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -1366,6 +1366,7 @@ static int __init init_i82365(void)
     if (sockets == 0) {
 	printk("not found.\n");
 	platform_device_unregister(&i82365_device);
+	release_region(i365_base, 2);
 	driver_unregister(&i82365_driver);
 	return -ENODEV;
     }

commit d052d1beff706920e82c5d55006b08e256b5df09
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Oct 29 19:07:23 2005 +0100

    Create platform_device.h to contain all the platform device details.
    Convert everyone who uses platform_bus_type to include
    linux/platform_device.h.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 4a41f67d185d..7ce455d01cc9 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -47,7 +47,7 @@
 #include <linux/delay.h>
 #include <linux/workqueue.h>
 #include <linux/interrupt.h>
-#include <linux/device.h>
+#include <linux/platform_device.h>
 #include <linux/bitops.h>
 #include <asm/irq.h>
 #include <asm/io.h>

commit 9480e307cd88ef09ec9294c7d97ebec18e6d2221
Author: Russell King <rmk@arm.linux.org.uk>
Date:   Fri Oct 28 09:52:56 2005 -0700

    [PATCH] DRIVER MODEL: Get rid of the obsolete tri-level suspend/resume callbacks
    
    In PM v1, all devices were called at SUSPEND_DISABLE level.  Then
    all devices were called at SUSPEND_SAVE_STATE level, and finally
    SUSPEND_POWER_DOWN level.  However, with PM v2, to maintain
    compatibility for platform devices, I arranged for the PM v2
    suspend/resume callbacks to call the old PM v1 suspend/resume
    callbacks three times with each level in order so that existing
    drivers continued to work.
    
    Since this is obsolete infrastructure which is no longer necessary,
    we can remove it.  Here's an (untested) patch to do exactly that.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index a713015e8228..4a41f67d185d 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -1332,27 +1332,11 @@ static struct pccard_operations pcic_operations = {
 
 /*====================================================================*/
 
-static int i82365_suspend(struct device *dev, pm_message_t state, u32 level)
-{
-	int ret = 0;
-	if (level == SUSPEND_SAVE_STATE)
-		ret = pcmcia_socket_dev_suspend(dev, state);
-	return ret;
-}
-
-static int i82365_resume(struct device *dev, u32 level)
-{
-	int ret = 0;
-	if (level == RESUME_RESTORE_STATE)
-		ret = pcmcia_socket_dev_resume(dev);
-	return ret;
-}
-
 static struct device_driver i82365_driver = {
 	.name = "i82365",
 	.bus = &platform_bus_type,
-	.suspend = i82365_suspend,
-	.resume = i82365_resume,
+	.suspend = pcmcia_socket_dev_suspend,
+	.resume = pcmcia_socket_dev_resume,
 };
 
 static struct platform_device i82365_device = {

commit 44670d2b50efd2443c3810239d6ea3fd02f8ef64
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Thu Jul 7 17:59:05 2005 -0700

    [PATCH] pcmcia: remove references to pcmcia/version.h
    
    As a follow-up, remove the inclusion of pcmcia/version.h in many files.
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 3546158ef776..a713015e8228 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -53,7 +53,6 @@
 #include <asm/io.h>
 #include <asm/system.h>
 
-#include <pcmcia/version.h>
 #include <pcmcia/cs_types.h>
 #include <pcmcia/ss.h>
 #include <pcmcia/cs.h>

commit 69a4d56bae492b1a5e74459d9d771d9bc7f9320f
Author: Ian Campbell <icampbell@arcom.com>
Date:   Thu Jul 7 17:58:52 2005 -0700

    [PATCH] pcmcia: fix i82365 request_region double usage
    
    http://www.kernel.org/git/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=f354942cb301fed273f423fb5c4f57bde3efc5b2
    converted the check_region() calls in drivers/pcmcia/i82365.c into
    request_regions.  Unfortunately this seems to have broken things.
    
    isa_probe() used to call check_region() and then call add_pcic() which would
    request_region().
    
    Now isa_probe() calls request_region() and then calls add_pcic() which calls
    request_region() again, this fails and add_pcic() returns immediately without
    doing all the setup etc.
    
    On the face of it the patch below fixes the problem, by not doing the second
    request region in add_pcic().  I think this is preferable to remove the call
    in isa_probe() since identify() touches the I/O regions and is called before
    add_pcic().
    
    However I haven't fully grokked the meaning of the code which follows the
    request_region() in isa_probe(), so I'm not sure that the handling WRT
    multiple sockets and multiple bridge chips is correct.  In particular I'm not
    convinced that the regions for subsequent sockets and/or bridges will be
    requested at all.  I suspect a more thorough reworking by someone who
    understands what is going on there might be in order.
    
    I should mention that I'm actually messing about with this on an ARM platform
    with wacky memory and i/o mapping offsets etc, it doesn't quite work yet for
    other reasons which preclude full testing etc, but I think the problem above
    is still present for more normal x86 stuff.
    
    Signed-off-by: Ian Campbell <icampbell@arcom.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index d72f9a35c8bd..3546158ef776 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -698,14 +698,6 @@ static void __init add_pcic(int ns, int type)
     struct i82365_socket *t = &socket[sockets-ns];
 
     base = sockets-ns;
-    if (t->ioaddr > 0) {
-	if (!request_region(t->ioaddr, 2, "i82365")) {
-	    printk(KERN_ERR "i82365: IO region conflict at %#lx, not available\n",
-			t->ioaddr);
-	    return;
-	}
-    }
-    
     if (base == 0) printk("\n");
     printk(KERN_INFO "  %s", pcic[type].name);
     printk(" ISA-to-PCMCIA at port %#lx ofs 0x%02x",

commit f354942cb301fed273f423fb5c4f57bde3efc5b2
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Mon Jun 27 16:28:55 2005 -0700

    [PATCH] pcmcia: use request_region in i82365
    
          randy_dunlap <rdunlap@xenotime.net>
    
    Convert deprecated check_region() calls to request/release region.
    Add return value check on one request_region().
    
    I suspect that it may do an extra release_region(), which should
    generate a warning message from the kernel.
    
    Signed-off-by: randy_dunlap <rdunlap@xenotime.net>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
index 90a335a5d9fa..d72f9a35c8bd 100644
--- a/drivers/pcmcia/i82365.c
+++ b/drivers/pcmcia/i82365.c
@@ -669,11 +669,13 @@ static int __init is_alive(u_short sock)
     if ((stat & I365_CS_DETECT) && (stat & I365_CS_POWERON) &&
 	(i365_get(sock, I365_INTCTL) & I365_PC_IOCARD) &&
 	(i365_get(sock, I365_ADDRWIN) & I365_ENA_IO(0)) &&
-	(check_region(start, stop-start+1) != 0) &&
-	((start & 0xfeef) != 0x02e8))
-	return 1;
-    else
-	return 0;
+	((start & 0xfeef) != 0x02e8)) {
+	if (!request_region(start, stop-start+1, "i82365"))
+	    return 1;
+	release_region(start, stop-start+1);
+    }
+
+    return 0;
 }
 
 /*====================================================================*/
@@ -696,7 +698,13 @@ static void __init add_pcic(int ns, int type)
     struct i82365_socket *t = &socket[sockets-ns];
 
     base = sockets-ns;
-    if (t->ioaddr > 0) request_region(t->ioaddr, 2, "i82365");
+    if (t->ioaddr > 0) {
+	if (!request_region(t->ioaddr, 2, "i82365")) {
+	    printk(KERN_ERR "i82365: IO region conflict at %#lx, not available\n",
+			t->ioaddr);
+	    return;
+	}
+    }
     
     if (base == 0) printk("\n");
     printk(KERN_INFO "  %s", pcic[type].name);
@@ -803,7 +811,7 @@ static void __init isa_probe(void)
     }
 #endif
 
-    if (check_region(i365_base, 2) != 0) {
+    if (!request_region(i365_base, 2, "i82365")) {
 	if (sockets == 0)
 	    printk("port conflict at %#lx\n", i365_base);
 	return;
@@ -1441,6 +1449,7 @@ static void __exit exit_i82365(void)
 	i365_set(i, I365_CSCINT, 0);
 	release_region(socket[i].ioaddr, 2);
     }
+    release_region(i365_base, 2);
 #ifdef CONFIG_PNP
     if (i82365_pnpdev)
     		pnp_disable_dev(i82365_pnpdev);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pcmcia/i82365.c b/drivers/pcmcia/i82365.c
new file mode 100644
index 000000000000..90a335a5d9fa
--- /dev/null
+++ b/drivers/pcmcia/i82365.c
@@ -0,0 +1,1454 @@
+/*======================================================================
+
+    Device driver for Intel 82365 and compatible PC Card controllers.
+
+    i82365.c 1.265 1999/11/10 18:36:21
+
+    The contents of this file are subject to the Mozilla Public
+    License Version 1.1 (the "License"); you may not use this file
+    except in compliance with the License. You may obtain a copy of
+    the License at http://www.mozilla.org/MPL/
+
+    Software distributed under the License is distributed on an "AS
+    IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+    implied. See the License for the specific language governing
+    rights and limitations under the License.
+
+    The initial developer of the original code is David A. Hinds
+    <dahinds@users.sourceforge.net>.  Portions created by David A. Hinds
+    are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.
+
+    Alternatively, the contents of this file may be used under the
+    terms of the GNU General Public License version 2 (the "GPL"), in which
+    case the provisions of the GPL are applicable instead of the
+    above.  If you wish to allow the use of your version of this file
+    only under the terms of the GPL and not to allow others to use
+    your version of this file under the MPL, indicate your decision
+    by deleting the provisions above and replace them with the notice
+    and other provisions required by the GPL.  If you do not delete
+    the provisions above, a recipient may use your version of this
+    file under either the MPL or the GPL.
+    
+======================================================================*/
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/bitops.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/system.h>
+
+#include <pcmcia/version.h>
+#include <pcmcia/cs_types.h>
+#include <pcmcia/ss.h>
+#include <pcmcia/cs.h>
+
+#include <linux/isapnp.h>
+
+/* ISA-bus controllers */
+#include "i82365.h"
+#include "cirrus.h"
+#include "vg468.h"
+#include "ricoh.h"
+
+#ifdef DEBUG
+static const char version[] =
+"i82365.c 1.265 1999/11/10 18:36:21 (David Hinds)";
+
+static int pc_debug;
+
+module_param(pc_debug, int, 0644);
+
+#define debug(lvl, fmt, arg...) do {				\
+	if (pc_debug > (lvl))					\
+		printk(KERN_DEBUG "i82365: " fmt , ## arg);	\
+} while (0)
+#else
+#define debug(lvl, fmt, arg...) do { } while (0)
+#endif
+
+static irqreturn_t i365_count_irq(int, void *, struct pt_regs *);
+static inline int _check_irq(int irq, int flags)
+{
+    if (request_irq(irq, i365_count_irq, flags, "x", i365_count_irq) != 0)
+	return -1;
+    free_irq(irq, i365_count_irq);
+    return 0;
+}
+
+/*====================================================================*/
+
+/* Parameters that can be set with 'insmod' */
+
+/* Default base address for i82365sl and other ISA chips */
+static unsigned long i365_base = 0x3e0;
+/* Should we probe at 0x3e2 for an extra ISA controller? */
+static int extra_sockets = 0;
+/* Specify a socket number to ignore */
+static int ignore = -1;
+/* Bit map or list of interrupts to choose from */
+static u_int irq_mask = 0xffff;
+static int irq_list[16];
+static int irq_list_count;
+/* The card status change interrupt -- 0 means autoselect */
+static int cs_irq = 0;
+
+/* Probe for safe interrupts? */
+static int do_scan = 1;
+/* Poll status interval -- 0 means default to interrupt */
+static int poll_interval = 0;
+/* External clock time, in nanoseconds.  120 ns = 8.33 MHz */
+static int cycle_time = 120;
+
+/* Cirrus options */
+static int has_dma = -1;
+static int has_led = -1;
+static int has_ring = -1;
+static int dynamic_mode = 0;
+static int freq_bypass = -1;
+static int setup_time = -1;
+static int cmd_time = -1;
+static int recov_time = -1;
+
+/* Vadem options */
+static int async_clock = -1;
+static int cable_mode = -1;
+static int wakeup = 0;
+
+module_param(i365_base, ulong, 0444);
+module_param(ignore, int, 0444);
+module_param(extra_sockets, int, 0444);
+module_param(irq_mask, int, 0444);
+module_param_array(irq_list, int, &irq_list_count, 0444);
+module_param(cs_irq, int, 0444);
+module_param(async_clock, int, 0444);
+module_param(cable_mode, int, 0444);
+module_param(wakeup, int, 0444);
+
+module_param(do_scan, int, 0444);
+module_param(poll_interval, int, 0444);
+module_param(cycle_time, int, 0444);
+module_param(has_dma, int, 0444);
+module_param(has_led, int, 0444);
+module_param(has_ring, int, 0444);
+module_param(dynamic_mode, int, 0444);
+module_param(freq_bypass, int, 0444);
+module_param(setup_time, int, 0444);
+module_param(cmd_time, int, 0444);
+module_param(recov_time, int, 0444);
+
+/*====================================================================*/
+
+typedef struct cirrus_state_t {
+    u_char		misc1, misc2;
+    u_char		timer[6];
+} cirrus_state_t;
+
+typedef struct vg46x_state_t {
+    u_char		ctl, ema;
+} vg46x_state_t;
+
+struct i82365_socket {
+    u_short		type, flags;
+    struct pcmcia_socket	socket;
+    unsigned int	number;
+    kio_addr_t		ioaddr;
+    u_short		psock;
+    u_char		cs_irq, intr;
+    union {
+	cirrus_state_t		cirrus;
+	vg46x_state_t		vg46x;
+    } state;
+};
+
+/* Where we keep track of our sockets... */
+static int sockets = 0;
+static struct i82365_socket socket[8] = {
+    { 0, }, /* ... */
+};
+
+/* Default ISA interrupt mask */
+#define I365_MASK	0xdeb8	/* irq 15,14,12,11,10,9,7,5,4,3 */
+
+static int grab_irq;
+static DEFINE_SPINLOCK(isa_lock);
+#define ISA_LOCK(n, f) spin_lock_irqsave(&isa_lock, f)
+#define ISA_UNLOCK(n, f) spin_unlock_irqrestore(&isa_lock, f)
+
+static struct timer_list poll_timer;
+
+/*====================================================================*/
+
+/* These definitions must match the pcic table! */
+typedef enum pcic_id {
+    IS_I82365A, IS_I82365B, IS_I82365DF,
+    IS_IBM, IS_RF5Cx96, IS_VLSI, IS_VG468, IS_VG469,
+    IS_PD6710, IS_PD672X, IS_VT83C469,
+} pcic_id;
+
+/* Flags for classifying groups of controllers */
+#define IS_VADEM	0x0001
+#define IS_CIRRUS	0x0002
+#define IS_VIA		0x0010
+#define IS_UNKNOWN	0x0400
+#define IS_VG_PWR	0x0800
+#define IS_DF_PWR	0x1000
+#define IS_REGISTERED	0x2000
+#define IS_ALIVE	0x8000
+
+typedef struct pcic_t {
+    char		*name;
+    u_short		flags;
+} pcic_t;
+
+static pcic_t pcic[] = {
+    { "Intel i82365sl A step", 0 },
+    { "Intel i82365sl B step", 0 },
+    { "Intel i82365sl DF", IS_DF_PWR },
+    { "IBM Clone", 0 },
+    { "Ricoh RF5C296/396", 0 },
+    { "VLSI 82C146", 0 },
+    { "Vadem VG-468", IS_VADEM },
+    { "Vadem VG-469", IS_VADEM|IS_VG_PWR },
+    { "Cirrus PD6710", IS_CIRRUS },
+    { "Cirrus PD672x", IS_CIRRUS },
+    { "VIA VT83C469", IS_CIRRUS|IS_VIA },
+};
+
+#define PCIC_COUNT	(sizeof(pcic)/sizeof(pcic_t))
+
+/*====================================================================*/
+
+static DEFINE_SPINLOCK(bus_lock);
+
+static u_char i365_get(u_short sock, u_short reg)
+{
+    unsigned long flags;
+    spin_lock_irqsave(&bus_lock,flags);
+    {
+	kio_addr_t port = socket[sock].ioaddr;
+	u_char val;
+	reg = I365_REG(socket[sock].psock, reg);
+	outb(reg, port); val = inb(port+1);
+	spin_unlock_irqrestore(&bus_lock,flags);
+	return val;
+    }
+}
+
+static void i365_set(u_short sock, u_short reg, u_char data)
+{
+    unsigned long flags;
+    spin_lock_irqsave(&bus_lock,flags);
+    {
+	kio_addr_t port = socket[sock].ioaddr;
+	u_char val = I365_REG(socket[sock].psock, reg);
+	outb(val, port); outb(data, port+1);
+	spin_unlock_irqrestore(&bus_lock,flags);
+    }
+}
+
+static void i365_bset(u_short sock, u_short reg, u_char mask)
+{
+    u_char d = i365_get(sock, reg);
+    d |= mask;
+    i365_set(sock, reg, d);
+}
+
+static void i365_bclr(u_short sock, u_short reg, u_char mask)
+{
+    u_char d = i365_get(sock, reg);
+    d &= ~mask;
+    i365_set(sock, reg, d);
+}
+
+static void i365_bflip(u_short sock, u_short reg, u_char mask, int b)
+{
+    u_char d = i365_get(sock, reg);
+    if (b)
+	d |= mask;
+    else
+	d &= ~mask;
+    i365_set(sock, reg, d);
+}
+
+static u_short i365_get_pair(u_short sock, u_short reg)
+{
+    u_short a, b;
+    a = i365_get(sock, reg);
+    b = i365_get(sock, reg+1);
+    return (a + (b<<8));
+}
+
+static void i365_set_pair(u_short sock, u_short reg, u_short data)
+{
+    i365_set(sock, reg, data & 0xff);
+    i365_set(sock, reg+1, data >> 8);
+}
+
+/*======================================================================
+
+    Code to save and restore global state information for Cirrus
+    PD67xx controllers, and to set and report global configuration
+    options.
+
+    The VIA controllers also use these routines, as they are mostly
+    Cirrus lookalikes, without the timing registers.
+    
+======================================================================*/
+
+#define flip(v,b,f) (v = ((f)<0) ? v : ((f) ? ((v)|(b)) : ((v)&(~b))))
+
+static void cirrus_get_state(u_short s)
+{
+    int i;
+    cirrus_state_t *p = &socket[s].state.cirrus;
+    p->misc1 = i365_get(s, PD67_MISC_CTL_1);
+    p->misc1 &= (PD67_MC1_MEDIA_ENA | PD67_MC1_INPACK_ENA);
+    p->misc2 = i365_get(s, PD67_MISC_CTL_2);
+    for (i = 0; i < 6; i++)
+	p->timer[i] = i365_get(s, PD67_TIME_SETUP(0)+i);
+}
+
+static void cirrus_set_state(u_short s)
+{
+    int i;
+    u_char misc;
+    cirrus_state_t *p = &socket[s].state.cirrus;
+
+    misc = i365_get(s, PD67_MISC_CTL_2);
+    i365_set(s, PD67_MISC_CTL_2, p->misc2);
+    if (misc & PD67_MC2_SUSPEND) mdelay(50);
+    misc = i365_get(s, PD67_MISC_CTL_1);
+    misc &= ~(PD67_MC1_MEDIA_ENA | PD67_MC1_INPACK_ENA);
+    i365_set(s, PD67_MISC_CTL_1, misc | p->misc1);
+    for (i = 0; i < 6; i++)
+	i365_set(s, PD67_TIME_SETUP(0)+i, p->timer[i]);
+}
+
+static u_int __init cirrus_set_opts(u_short s, char *buf)
+{
+    struct i82365_socket *t = &socket[s];
+    cirrus_state_t *p = &socket[s].state.cirrus;
+    u_int mask = 0xffff;
+
+    if (has_ring == -1) has_ring = 1;
+    flip(p->misc2, PD67_MC2_IRQ15_RI, has_ring);
+    flip(p->misc2, PD67_MC2_DYNAMIC_MODE, dynamic_mode);
+    flip(p->misc2, PD67_MC2_FREQ_BYPASS, freq_bypass);
+    if (p->misc2 & PD67_MC2_IRQ15_RI)
+	strcat(buf, " [ring]");
+    if (p->misc2 & PD67_MC2_DYNAMIC_MODE)
+	strcat(buf, " [dyn mode]");
+    if (p->misc2 & PD67_MC2_FREQ_BYPASS)
+	strcat(buf, " [freq bypass]");
+    if (p->misc1 & PD67_MC1_INPACK_ENA)
+	strcat(buf, " [inpack]");
+    if (p->misc2 & PD67_MC2_IRQ15_RI)
+	mask &= ~0x8000;
+    if (has_led > 0) {
+	strcat(buf, " [led]");
+	mask &= ~0x1000;
+    }
+    if (has_dma > 0) {
+	strcat(buf, " [dma]");
+	mask &= ~0x0600;
+    }
+    if (!(t->flags & IS_VIA)) {
+	if (setup_time >= 0)
+	    p->timer[0] = p->timer[3] = setup_time;
+	if (cmd_time > 0) {
+	    p->timer[1] = cmd_time;
+	    p->timer[4] = cmd_time*2+4;
+	}
+	if (p->timer[1] == 0) {
+	    p->timer[1] = 6; p->timer[4] = 16;
+	    if (p->timer[0] == 0)
+		p->timer[0] = p->timer[3] = 1;
+	}
+	if (recov_time >= 0)
+	    p->timer[2] = p->timer[5] = recov_time;
+	buf += strlen(buf);
+	sprintf(buf, " [%d/%d/%d] [%d/%d/%d]", p->timer[0], p->timer[1],
+		p->timer[2], p->timer[3], p->timer[4], p->timer[5]);
+    }
+    return mask;
+}
+
+/*======================================================================
+
+    Code to save and restore global state information for Vadem VG468
+    and VG469 controllers, and to set and report global configuration
+    options.
+    
+======================================================================*/
+
+static void vg46x_get_state(u_short s)
+{
+    vg46x_state_t *p = &socket[s].state.vg46x;
+    p->ctl = i365_get(s, VG468_CTL);
+    if (socket[s].type == IS_VG469)
+	p->ema = i365_get(s, VG469_EXT_MODE);
+}
+
+static void vg46x_set_state(u_short s)
+{
+    vg46x_state_t *p = &socket[s].state.vg46x;
+    i365_set(s, VG468_CTL, p->ctl);
+    if (socket[s].type == IS_VG469)
+	i365_set(s, VG469_EXT_MODE, p->ema);
+}
+
+static u_int __init vg46x_set_opts(u_short s, char *buf)
+{
+    vg46x_state_t *p = &socket[s].state.vg46x;
+    
+    flip(p->ctl, VG468_CTL_ASYNC, async_clock);
+    flip(p->ema, VG469_MODE_CABLE, cable_mode);
+    if (p->ctl & VG468_CTL_ASYNC)
+	strcat(buf, " [async]");
+    if (p->ctl & VG468_CTL_INPACK)
+	strcat(buf, " [inpack]");
+    if (socket[s].type == IS_VG469) {
+	u_char vsel = i365_get(s, VG469_VSELECT);
+	if (vsel & VG469_VSEL_EXT_STAT) {
+	    strcat(buf, " [ext mode]");
+	    if (vsel & VG469_VSEL_EXT_BUS)
+		strcat(buf, " [isa buf]");
+	}
+	if (p->ema & VG469_MODE_CABLE)
+	    strcat(buf, " [cable]");
+	if (p->ema & VG469_MODE_COMPAT)
+	    strcat(buf, " [c step]");
+    }
+    return 0xffff;
+}
+
+/*======================================================================
+
+    Generic routines to get and set controller options
+    
+======================================================================*/
+
+static void get_bridge_state(u_short s)
+{
+    struct i82365_socket *t = &socket[s];
+    if (t->flags & IS_CIRRUS)
+	cirrus_get_state(s);
+    else if (t->flags & IS_VADEM)
+	vg46x_get_state(s);
+}
+
+static void set_bridge_state(u_short s)
+{
+    struct i82365_socket *t = &socket[s];
+    if (t->flags & IS_CIRRUS)
+	cirrus_set_state(s);
+    else {
+	i365_set(s, I365_GBLCTL, 0x00);
+	i365_set(s, I365_GENCTL, 0x00);
+    }
+    i365_bflip(s, I365_INTCTL, I365_INTR_ENA, t->intr);
+    if (t->flags & IS_VADEM)
+	vg46x_set_state(s);
+}
+
+static u_int __init set_bridge_opts(u_short s, u_short ns)
+{
+    u_short i;
+    u_int m = 0xffff;
+    char buf[128];
+
+    for (i = s; i < s+ns; i++) {
+	if (socket[i].flags & IS_ALIVE) {
+	    printk(KERN_INFO "    host opts [%d]: already alive!\n", i);
+	    continue;
+	}
+	buf[0] = '\0';
+	get_bridge_state(i);
+	if (socket[i].flags & IS_CIRRUS)
+	    m = cirrus_set_opts(i, buf);
+	else if (socket[i].flags & IS_VADEM)
+	    m = vg46x_set_opts(i, buf);
+	set_bridge_state(i);
+	printk(KERN_INFO "    host opts [%d]:%s\n", i,
+	       (*buf) ? buf : " none");
+    }
+    return m;
+}
+
+/*======================================================================
+
+    Interrupt testing code, for ISA and PCI interrupts
+    
+======================================================================*/
+
+static volatile u_int irq_hits;
+static u_short irq_sock;
+
+static irqreturn_t i365_count_irq(int irq, void *dev, struct pt_regs *regs)
+{
+    i365_get(irq_sock, I365_CSC);
+    irq_hits++;
+    debug(2, "-> hit on irq %d\n", irq);
+    return IRQ_HANDLED;
+}
+
+static u_int __init test_irq(u_short sock, int irq)
+{
+    debug(2, "  testing ISA irq %d\n", irq);
+    if (request_irq(irq, i365_count_irq, 0, "scan", i365_count_irq) != 0)
+	return 1;
+    irq_hits = 0; irq_sock = sock;
+    msleep(10);
+    if (irq_hits) {
+	free_irq(irq, i365_count_irq);
+	debug(2, "    spurious hit!\n");
+	return 1;
+    }
+
+    /* Generate one interrupt */
+    i365_set(sock, I365_CSCINT, I365_CSC_DETECT | (irq << 4));
+    i365_bset(sock, I365_GENCTL, I365_CTL_SW_IRQ);
+    udelay(1000);
+
+    free_irq(irq, i365_count_irq);
+
+    /* mask all interrupts */
+    i365_set(sock, I365_CSCINT, 0);
+    debug(2, "    hits = %d\n", irq_hits);
+    
+    return (irq_hits != 1);
+}
+
+static u_int __init isa_scan(u_short sock, u_int mask0)
+{
+    u_int mask1 = 0;
+    int i;
+
+#ifdef __alpha__
+#define PIC 0x4d0
+    /* Don't probe level-triggered interrupts -- reserved for PCI */
+    mask0 &= ~(inb(PIC) | (inb(PIC+1) << 8));
+#endif
+    
+    if (do_scan) {
+	set_bridge_state(sock);
+	i365_set(sock, I365_CSCINT, 0);
+	for (i = 0; i < 16; i++)
+	    if ((mask0 & (1 << i)) && (test_irq(sock, i) == 0))
+		mask1 |= (1 << i);
+	for (i = 0; i < 16; i++)
+	    if ((mask1 & (1 << i)) && (test_irq(sock, i) != 0))
+		mask1 ^= (1 << i);
+    }
+    
+    printk(KERN_INFO "    ISA irqs (");
+    if (mask1) {
+	printk("scanned");
+    } else {
+	/* Fallback: just find interrupts that aren't in use */
+	for (i = 0; i < 16; i++)
+	    if ((mask0 & (1 << i)) && (_check_irq(i, 0) == 0))
+		mask1 |= (1 << i);
+	printk("default");
+	/* If scan failed, default to polled status */
+	if (!cs_irq && (poll_interval == 0)) poll_interval = HZ;
+    }
+    printk(") = ");
+    
+    for (i = 0; i < 16; i++)
+	if (mask1 & (1<<i))
+	    printk("%s%d", ((mask1 & ((1<<i)-1)) ? "," : ""), i);
+    if (mask1 == 0) printk("none!");
+    
+    return mask1;
+}
+
+/*====================================================================*/
+
+/* Time conversion functions */
+
+static int to_cycles(int ns)
+{
+    return ns/cycle_time;
+}
+
+/*====================================================================*/
+
+static int __init identify(kio_addr_t port, u_short sock)
+{
+    u_char val;
+    int type = -1;
+
+    /* Use the next free entry in the socket table */
+    socket[sockets].ioaddr = port;
+    socket[sockets].psock = sock;
+    
+    /* Wake up a sleepy Cirrus controller */
+    if (wakeup) {
+	i365_bclr(sockets, PD67_MISC_CTL_2, PD67_MC2_SUSPEND);
+	/* Pause at least 50 ms */
+	mdelay(50);
+    }
+    
+    if ((val = i365_get(sockets, I365_IDENT)) & 0x70)
+	return -1;
+    switch (val) {
+    case 0x82:
+	type = IS_I82365A; break;
+    case 0x83:
+	type = IS_I82365B; break;
+    case 0x84:
+	type = IS_I82365DF; break;
+    case 0x88: case 0x89: case 0x8a:
+	type = IS_IBM; break;
+    }
+    
+    /* Check for Vadem VG-468 chips */
+    outb(0x0e, port);
+    outb(0x37, port);
+    i365_bset(sockets, VG468_MISC, VG468_MISC_VADEMREV);
+    val = i365_get(sockets, I365_IDENT);
+    if (val & I365_IDENT_VADEM) {
+	i365_bclr(sockets, VG468_MISC, VG468_MISC_VADEMREV);
+	type = ((val & 7) >= 4) ? IS_VG469 : IS_VG468;
+    }
+
+    /* Check for Ricoh chips */
+    val = i365_get(sockets, RF5C_CHIP_ID);
+    if ((val == RF5C_CHIP_RF5C296) || (val == RF5C_CHIP_RF5C396))
+	type = IS_RF5Cx96;
+    
+    /* Check for Cirrus CL-PD67xx chips */
+    i365_set(sockets, PD67_CHIP_INFO, 0);
+    val = i365_get(sockets, PD67_CHIP_INFO);
+    if ((val & PD67_INFO_CHIP_ID) == PD67_INFO_CHIP_ID) {
+	val = i365_get(sockets, PD67_CHIP_INFO);
+	if ((val & PD67_INFO_CHIP_ID) == 0) {
+	    type = (val & PD67_INFO_SLOTS) ? IS_PD672X : IS_PD6710;
+	    i365_set(sockets, PD67_EXT_INDEX, 0xe5);
+	    if (i365_get(sockets, PD67_EXT_INDEX) != 0xe5)
+		type = IS_VT83C469;
+	}
+    }
+    return type;
+} /* identify */
+
+/*======================================================================
+
+    See if a card is present, powered up, in IO mode, and already
+    bound to a (non PC Card) Linux driver.  We leave these alone.
+
+    We make an exception for cards that seem to be serial devices.
+    
+======================================================================*/
+
+static int __init is_alive(u_short sock)
+{
+    u_char stat;
+    kio_addr_t start, stop;
+    
+    stat = i365_get(sock, I365_STATUS);
+    start = i365_get_pair(sock, I365_IO(0)+I365_W_START);
+    stop = i365_get_pair(sock, I365_IO(0)+I365_W_STOP);
+    if ((stat & I365_CS_DETECT) && (stat & I365_CS_POWERON) &&
+	(i365_get(sock, I365_INTCTL) & I365_PC_IOCARD) &&
+	(i365_get(sock, I365_ADDRWIN) & I365_ENA_IO(0)) &&
+	(check_region(start, stop-start+1) != 0) &&
+	((start & 0xfeef) != 0x02e8))
+	return 1;
+    else
+	return 0;
+}
+
+/*====================================================================*/
+
+static void __init add_socket(kio_addr_t port, int psock, int type)
+{
+    socket[sockets].ioaddr = port;
+    socket[sockets].psock = psock;
+    socket[sockets].type = type;
+    socket[sockets].flags = pcic[type].flags;
+    if (is_alive(sockets))
+	socket[sockets].flags |= IS_ALIVE;
+    sockets++;
+}
+
+static void __init add_pcic(int ns, int type)
+{
+    u_int mask = 0, i, base;
+    int isa_irq = 0;
+    struct i82365_socket *t = &socket[sockets-ns];
+
+    base = sockets-ns;
+    if (t->ioaddr > 0) request_region(t->ioaddr, 2, "i82365");
+    
+    if (base == 0) printk("\n");
+    printk(KERN_INFO "  %s", pcic[type].name);
+    printk(" ISA-to-PCMCIA at port %#lx ofs 0x%02x",
+	       t->ioaddr, t->psock*0x40);
+    printk(", %d socket%s\n", ns, ((ns > 1) ? "s" : ""));
+
+    /* Set host options, build basic interrupt mask */
+    if (irq_list_count == 0)
+	mask = irq_mask;
+    else
+	for (i = mask = 0; i < irq_list_count; i++)
+	    mask |= (1<<irq_list[i]);
+    mask &= I365_MASK & set_bridge_opts(base, ns);
+    /* Scan for ISA interrupts */
+    mask = isa_scan(base, mask);
+        
+    /* Poll if only two interrupts available */
+    if (!poll_interval) {
+	u_int tmp = (mask & 0xff20);
+	tmp = tmp & (tmp-1);
+	if ((tmp & (tmp-1)) == 0)
+	    poll_interval = HZ;
+    }
+    /* Only try an ISA cs_irq if this is the first controller */
+    if (!grab_irq && (cs_irq || !poll_interval)) {
+	/* Avoid irq 12 unless it is explicitly requested */
+	u_int cs_mask = mask & ((cs_irq) ? (1<<cs_irq) : ~(1<<12));
+	for (cs_irq = 15; cs_irq > 0; cs_irq--)
+	    if ((cs_mask & (1 << cs_irq)) &&
+		(_check_irq(cs_irq, 0) == 0))
+		break;
+	if (cs_irq) {
+	    grab_irq = 1;
+	    isa_irq = cs_irq;
+	    printk(" status change on irq %d\n", cs_irq);
+	}
+    }
+    
+    if (!isa_irq) {
+	if (poll_interval == 0)
+	    poll_interval = HZ;
+	printk(" polling interval = %d ms\n",
+	       poll_interval * 1000 / HZ);
+	
+    }
+    
+    /* Update socket interrupt information, capabilities */
+    for (i = 0; i < ns; i++) {
+	t[i].socket.features |= SS_CAP_PCCARD;
+	t[i].socket.map_size = 0x1000;
+	t[i].socket.irq_mask = mask;
+	t[i].cs_irq = isa_irq;
+    }
+
+} /* add_pcic */
+
+/*====================================================================*/
+
+#ifdef CONFIG_PNP
+static struct isapnp_device_id id_table[] __initdata = {
+	{ 	ISAPNP_ANY_ID, ISAPNP_ANY_ID, ISAPNP_VENDOR('P', 'N', 'P'),
+		ISAPNP_FUNCTION(0x0e00), (unsigned long) "Intel 82365-Compatible" },
+	{ 	ISAPNP_ANY_ID, ISAPNP_ANY_ID, ISAPNP_VENDOR('P', 'N', 'P'),
+		ISAPNP_FUNCTION(0x0e01), (unsigned long) "Cirrus Logic CL-PD6720" },
+	{ 	ISAPNP_ANY_ID, ISAPNP_ANY_ID, ISAPNP_VENDOR('P', 'N', 'P'),
+		ISAPNP_FUNCTION(0x0e02), (unsigned long) "VLSI VL82C146" },
+	{	0 }
+};
+MODULE_DEVICE_TABLE(isapnp, id_table);
+
+static struct pnp_dev *i82365_pnpdev;
+#endif
+
+static void __init isa_probe(void)
+{
+    int i, j, sock, k, ns, id;
+    kio_addr_t port;
+#ifdef CONFIG_PNP
+    struct isapnp_device_id *devid;
+    struct pnp_dev *dev;
+
+    for (devid = id_table; devid->vendor; devid++) {
+	if ((dev = pnp_find_dev(NULL, devid->vendor, devid->function, NULL))) {
+	
+	    if (pnp_device_attach(dev) < 0)
+	    	continue;
+
+	    if (pnp_activate_dev(dev) < 0) {
+		printk("activate failed\n");
+		pnp_device_detach(dev);
+		break;
+	    }
+
+	    if (!pnp_port_valid(dev, 0)) {
+		printk("invalid resources ?\n");
+		pnp_device_detach(dev);
+		break;
+	    }
+	    i365_base = pnp_port_start(dev, 0);
+	    i82365_pnpdev = dev;
+	    break;
+	}
+    }
+#endif
+
+    if (check_region(i365_base, 2) != 0) {
+	if (sockets == 0)
+	    printk("port conflict at %#lx\n", i365_base);
+	return;
+    }
+
+    id = identify(i365_base, 0);
+    if ((id == IS_I82365DF) && (identify(i365_base, 1) != id)) {
+	for (i = 0; i < 4; i++) {
+	    if (i == ignore) continue;
+	    port = i365_base + ((i & 1) << 2) + ((i & 2) << 1);
+	    sock = (i & 1) << 1;
+	    if (identify(port, sock) == IS_I82365DF) {
+		add_socket(port, sock, IS_VLSI);
+		add_pcic(1, IS_VLSI);
+	    }
+	}
+    } else {
+	for (i = 0; i < 8; i += 2) {
+	    if (sockets && !extra_sockets && (i == 4))
+		break;
+	    port = i365_base + 2*(i>>2);
+	    sock = (i & 3);
+	    id = identify(port, sock);
+	    if (id < 0) continue;
+
+	    for (j = ns = 0; j < 2; j++) {
+		/* Does the socket exist? */
+		if ((ignore == i+j) || (identify(port, sock+j) < 0))
+		    continue;
+		/* Check for bad socket decode */
+		for (k = 0; k <= sockets; k++)
+		    i365_set(k, I365_MEM(0)+I365_W_OFF, k);
+		for (k = 0; k <= sockets; k++)
+		    if (i365_get(k, I365_MEM(0)+I365_W_OFF) != k)
+			break;
+		if (k <= sockets) break;
+		add_socket(port, sock+j, id); ns++;
+	    }
+	    if (ns != 0) add_pcic(ns, id);
+	}
+    }
+}
+
+/*====================================================================*/
+
+static irqreturn_t pcic_interrupt(int irq, void *dev,
+				    struct pt_regs *regs)
+{
+    int i, j, csc;
+    u_int events, active;
+    u_long flags = 0;
+    int handled = 0;
+
+    debug(4, "pcic_interrupt(%d)\n", irq);
+
+    for (j = 0; j < 20; j++) {
+	active = 0;
+	for (i = 0; i < sockets; i++) {
+	    if (socket[i].cs_irq != irq)
+		continue;
+	    handled = 1;
+	    ISA_LOCK(i, flags);
+	    csc = i365_get(i, I365_CSC);
+	    if ((csc == 0) || (i365_get(i, I365_IDENT) & 0x70)) {
+		ISA_UNLOCK(i, flags);
+		continue;
+	    }
+	    events = (csc & I365_CSC_DETECT) ? SS_DETECT : 0;
+
+	    if (i365_get(i, I365_INTCTL) & I365_PC_IOCARD)
+		events |= (csc & I365_CSC_STSCHG) ? SS_STSCHG : 0;
+	    else {
+		events |= (csc & I365_CSC_BVD1) ? SS_BATDEAD : 0;
+		events |= (csc & I365_CSC_BVD2) ? SS_BATWARN : 0;
+		events |= (csc & I365_CSC_READY) ? SS_READY : 0;
+	    }
+	    ISA_UNLOCK(i, flags);
+	    debug(2, "socket %d event 0x%02x\n", i, events);
+
+	    if (events)
+		pcmcia_parse_events(&socket[i].socket, events);
+
+	    active |= events;
+	}
+	if (!active) break;
+    }
+    if (j == 20)
+	printk(KERN_NOTICE "i82365: infinite loop in interrupt handler\n");
+
+    debug(4, "interrupt done\n");
+    return IRQ_RETVAL(handled);
+} /* pcic_interrupt */
+
+static void pcic_interrupt_wrapper(u_long data)
+{
+    pcic_interrupt(0, NULL, NULL);
+    poll_timer.expires = jiffies + poll_interval;
+    add_timer(&poll_timer);
+}
+
+/*====================================================================*/
+
+static int i365_get_status(u_short sock, u_int *value)
+{
+    u_int status;
+    
+    status = i365_get(sock, I365_STATUS);
+    *value = ((status & I365_CS_DETECT) == I365_CS_DETECT)
+	? SS_DETECT : 0;
+	
+    if (i365_get(sock, I365_INTCTL) & I365_PC_IOCARD)
+	*value |= (status & I365_CS_STSCHG) ? 0 : SS_STSCHG;
+    else {
+	*value |= (status & I365_CS_BVD1) ? 0 : SS_BATDEAD;
+	*value |= (status & I365_CS_BVD2) ? 0 : SS_BATWARN;
+    }
+    *value |= (status & I365_CS_WRPROT) ? SS_WRPROT : 0;
+    *value |= (status & I365_CS_READY) ? SS_READY : 0;
+    *value |= (status & I365_CS_POWERON) ? SS_POWERON : 0;
+
+    if (socket[sock].type == IS_VG469) {
+	status = i365_get(sock, VG469_VSENSE);
+	if (socket[sock].psock & 1) {
+	    *value |= (status & VG469_VSENSE_B_VS1) ? 0 : SS_3VCARD;
+	    *value |= (status & VG469_VSENSE_B_VS2) ? 0 : SS_XVCARD;
+	} else {
+	    *value |= (status & VG469_VSENSE_A_VS1) ? 0 : SS_3VCARD;
+	    *value |= (status & VG469_VSENSE_A_VS2) ? 0 : SS_XVCARD;
+	}
+    }
+    
+    debug(1, "GetStatus(%d) = %#4.4x\n", sock, *value);
+    return 0;
+} /* i365_get_status */
+
+/*====================================================================*/
+
+static int i365_get_socket(u_short sock, socket_state_t *state)
+{
+    struct i82365_socket *t = &socket[sock];
+    u_char reg, vcc, vpp;
+    
+    reg = i365_get(sock, I365_POWER);
+    state->flags = (reg & I365_PWR_AUTO) ? SS_PWR_AUTO : 0;
+    state->flags |= (reg & I365_PWR_OUT) ? SS_OUTPUT_ENA : 0;
+    vcc = reg & I365_VCC_MASK; vpp = reg & I365_VPP1_MASK;
+    state->Vcc = state->Vpp = 0;
+    if (t->flags & IS_CIRRUS) {
+	if (i365_get(sock, PD67_MISC_CTL_1) & PD67_MC1_VCC_3V) {
+	    if (reg & I365_VCC_5V) state->Vcc = 33;
+	    if (vpp == I365_VPP1_5V) state->Vpp = 33;
+	} else {
+	    if (reg & I365_VCC_5V) state->Vcc = 50;
+	    if (vpp == I365_VPP1_5V) state->Vpp = 50;
+	}
+	if (vpp == I365_VPP1_12V) state->Vpp = 120;
+    } else if (t->flags & IS_VG_PWR) {
+	if (i365_get(sock, VG469_VSELECT) & VG469_VSEL_VCC) {
+	    if (reg & I365_VCC_5V) state->Vcc = 33;
+	    if (vpp == I365_VPP1_5V) state->Vpp = 33;
+	} else {
+	    if (reg & I365_VCC_5V) state->Vcc = 50;
+	    if (vpp == I365_VPP1_5V) state->Vpp = 50;
+	}
+	if (vpp == I365_VPP1_12V) state->Vpp = 120;
+    } else if (t->flags & IS_DF_PWR) {
+	if (vcc == I365_VCC_3V) state->Vcc = 33;
+	if (vcc == I365_VCC_5V) state->Vcc = 50;
+	if (vpp == I365_VPP1_5V) state->Vpp = 50;
+	if (vpp == I365_VPP1_12V) state->Vpp = 120;
+    } else {
+	if (reg & I365_VCC_5V) {
+	    state->Vcc = 50;
+	    if (vpp == I365_VPP1_5V) state->Vpp = 50;
+	    if (vpp == I365_VPP1_12V) state->Vpp = 120;
+	}
+    }
+
+    /* IO card, RESET flags, IO interrupt */
+    reg = i365_get(sock, I365_INTCTL);
+    state->flags |= (reg & I365_PC_RESET) ? 0 : SS_RESET;
+    if (reg & I365_PC_IOCARD) state->flags |= SS_IOCARD;
+    state->io_irq = reg & I365_IRQ_MASK;
+    
+    /* speaker control */
+    if (t->flags & IS_CIRRUS) {
+	if (i365_get(sock, PD67_MISC_CTL_1) & PD67_MC1_SPKR_ENA)
+	    state->flags |= SS_SPKR_ENA;
+    }
+    
+    /* Card status change mask */
+    reg = i365_get(sock, I365_CSCINT);
+    state->csc_mask = (reg & I365_CSC_DETECT) ? SS_DETECT : 0;
+    if (state->flags & SS_IOCARD)
+	state->csc_mask |= (reg & I365_CSC_STSCHG) ? SS_STSCHG : 0;
+    else {
+	state->csc_mask |= (reg & I365_CSC_BVD1) ? SS_BATDEAD : 0;
+	state->csc_mask |= (reg & I365_CSC_BVD2) ? SS_BATWARN : 0;
+	state->csc_mask |= (reg & I365_CSC_READY) ? SS_READY : 0;
+    }
+    
+    debug(1, "GetSocket(%d) = flags %#3.3x, Vcc %d, Vpp %d, "
+	  "io_irq %d, csc_mask %#2.2x\n", sock, state->flags,
+	  state->Vcc, state->Vpp, state->io_irq, state->csc_mask);
+    return 0;
+} /* i365_get_socket */
+
+/*====================================================================*/
+
+static int i365_set_socket(u_short sock, socket_state_t *state)
+{
+    struct i82365_socket *t = &socket[sock];
+    u_char reg;
+    
+    debug(1, "SetSocket(%d, flags %#3.3x, Vcc %d, Vpp %d, "
+	  "io_irq %d, csc_mask %#2.2x)\n", sock, state->flags,
+	  state->Vcc, state->Vpp, state->io_irq, state->csc_mask);
+    
+    /* First set global controller options */
+    set_bridge_state(sock);
+    
+    /* IO card, RESET flag, IO interrupt */
+    reg = t->intr;
+    reg |= state->io_irq;
+    reg |= (state->flags & SS_RESET) ? 0 : I365_PC_RESET;
+    reg |= (state->flags & SS_IOCARD) ? I365_PC_IOCARD : 0;
+    i365_set(sock, I365_INTCTL, reg);
+    
+    reg = I365_PWR_NORESET;
+    if (state->flags & SS_PWR_AUTO) reg |= I365_PWR_AUTO;
+    if (state->flags & SS_OUTPUT_ENA) reg |= I365_PWR_OUT;
+
+    if (t->flags & IS_CIRRUS) {
+	if (state->Vpp != 0) {
+	    if (state->Vpp == 120)
+		reg |= I365_VPP1_12V;
+	    else if (state->Vpp == state->Vcc)
+		reg |= I365_VPP1_5V;
+	    else return -EINVAL;
+	}
+	if (state->Vcc != 0) {
+	    reg |= I365_VCC_5V;
+	    if (state->Vcc == 33)
+		i365_bset(sock, PD67_MISC_CTL_1, PD67_MC1_VCC_3V);
+	    else if (state->Vcc == 50)
+		i365_bclr(sock, PD67_MISC_CTL_1, PD67_MC1_VCC_3V);
+	    else return -EINVAL;
+	}
+    } else if (t->flags & IS_VG_PWR) {
+	if (state->Vpp != 0) {
+	    if (state->Vpp == 120)
+		reg |= I365_VPP1_12V;
+	    else if (state->Vpp == state->Vcc)
+		reg |= I365_VPP1_5V;
+	    else return -EINVAL;
+	}
+	if (state->Vcc != 0) {
+	    reg |= I365_VCC_5V;
+	    if (state->Vcc == 33)
+		i365_bset(sock, VG469_VSELECT, VG469_VSEL_VCC);
+	    else if (state->Vcc == 50)
+		i365_bclr(sock, VG469_VSELECT, VG469_VSEL_VCC);
+	    else return -EINVAL;
+	}
+    } else if (t->flags & IS_DF_PWR) {
+	switch (state->Vcc) {
+	case 0:		break;
+	case 33:   	reg |= I365_VCC_3V; break;
+	case 50:	reg |= I365_VCC_5V; break;
+	default:	return -EINVAL;
+	}
+	switch (state->Vpp) {
+	case 0:		break;
+	case 50:   	reg |= I365_VPP1_5V; break;
+	case 120:	reg |= I365_VPP1_12V; break;
+	default:	return -EINVAL;
+	}
+    } else {
+	switch (state->Vcc) {
+	case 0:		break;
+	case 50:	reg |= I365_VCC_5V; break;
+	default:	return -EINVAL;
+	}
+	switch (state->Vpp) {
+	case 0:		break;
+	case 50:	reg |= I365_VPP1_5V | I365_VPP2_5V; break;
+	case 120:	reg |= I365_VPP1_12V | I365_VPP2_12V; break;
+	default:	return -EINVAL;
+	}
+    }
+    
+    if (reg != i365_get(sock, I365_POWER))
+	i365_set(sock, I365_POWER, reg);
+
+    /* Chipset-specific functions */
+    if (t->flags & IS_CIRRUS) {
+	/* Speaker control */
+	i365_bflip(sock, PD67_MISC_CTL_1, PD67_MC1_SPKR_ENA,
+		   state->flags & SS_SPKR_ENA);
+    }
+    
+    /* Card status change interrupt mask */
+    reg = t->cs_irq << 4;
+    if (state->csc_mask & SS_DETECT) reg |= I365_CSC_DETECT;
+    if (state->flags & SS_IOCARD) {
+	if (state->csc_mask & SS_STSCHG) reg |= I365_CSC_STSCHG;
+    } else {
+	if (state->csc_mask & SS_BATDEAD) reg |= I365_CSC_BVD1;
+	if (state->csc_mask & SS_BATWARN) reg |= I365_CSC_BVD2;
+	if (state->csc_mask & SS_READY) reg |= I365_CSC_READY;
+    }
+    i365_set(sock, I365_CSCINT, reg);
+    i365_get(sock, I365_CSC);
+    
+    return 0;
+} /* i365_set_socket */
+
+/*====================================================================*/
+
+static int i365_set_io_map(u_short sock, struct pccard_io_map *io)
+{
+    u_char map, ioctl;
+    
+    debug(1, "SetIOMap(%d, %d, %#2.2x, %d ns, "
+	  "%#lx-%#lx)\n", sock, io->map, io->flags,
+	  io->speed, io->start, io->stop);
+    map = io->map;
+    if ((map > 1) || (io->start > 0xffff) || (io->stop > 0xffff) ||
+	(io->stop < io->start)) return -EINVAL;
+    /* Turn off the window before changing anything */
+    if (i365_get(sock, I365_ADDRWIN) & I365_ENA_IO(map))
+	i365_bclr(sock, I365_ADDRWIN, I365_ENA_IO(map));
+    i365_set_pair(sock, I365_IO(map)+I365_W_START, io->start);
+    i365_set_pair(sock, I365_IO(map)+I365_W_STOP, io->stop);
+    ioctl = i365_get(sock, I365_IOCTL) & ~I365_IOCTL_MASK(map);
+    if (io->speed) ioctl |= I365_IOCTL_WAIT(map);
+    if (io->flags & MAP_0WS) ioctl |= I365_IOCTL_0WS(map);
+    if (io->flags & MAP_16BIT) ioctl |= I365_IOCTL_16BIT(map);
+    if (io->flags & MAP_AUTOSZ) ioctl |= I365_IOCTL_IOCS16(map);
+    i365_set(sock, I365_IOCTL, ioctl);
+    /* Turn on the window if necessary */
+    if (io->flags & MAP_ACTIVE)
+	i365_bset(sock, I365_ADDRWIN, I365_ENA_IO(map));
+    return 0;
+} /* i365_set_io_map */
+
+/*====================================================================*/
+
+static int i365_set_mem_map(u_short sock, struct pccard_mem_map *mem)
+{
+    u_short base, i;
+    u_char map;
+    
+    debug(1, "SetMemMap(%d, %d, %#2.2x, %d ns, %#lx-%#lx, "
+	  "%#x)\n", sock, mem->map, mem->flags, mem->speed,
+	  mem->res->start, mem->res->end, mem->card_start);
+
+    map = mem->map;
+    if ((map > 4) || (mem->card_start > 0x3ffffff) ||
+	(mem->res->start > mem->res->end) || (mem->speed > 1000))
+	return -EINVAL;
+    if ((mem->res->start > 0xffffff) || (mem->res->end > 0xffffff))
+	return -EINVAL;
+	
+    /* Turn off the window before changing anything */
+    if (i365_get(sock, I365_ADDRWIN) & I365_ENA_MEM(map))
+	i365_bclr(sock, I365_ADDRWIN, I365_ENA_MEM(map));
+    
+    base = I365_MEM(map);
+    i = (mem->res->start >> 12) & 0x0fff;
+    if (mem->flags & MAP_16BIT) i |= I365_MEM_16BIT;
+    if (mem->flags & MAP_0WS) i |= I365_MEM_0WS;
+    i365_set_pair(sock, base+I365_W_START, i);
+    
+    i = (mem->res->end >> 12) & 0x0fff;
+    switch (to_cycles(mem->speed)) {
+    case 0:	break;
+    case 1:	i |= I365_MEM_WS0; break;
+    case 2:	i |= I365_MEM_WS1; break;
+    default:	i |= I365_MEM_WS1 | I365_MEM_WS0; break;
+    }
+    i365_set_pair(sock, base+I365_W_STOP, i);
+    
+    i = ((mem->card_start - mem->res->start) >> 12) & 0x3fff;
+    if (mem->flags & MAP_WRPROT) i |= I365_MEM_WRPROT;
+    if (mem->flags & MAP_ATTRIB) i |= I365_MEM_REG;
+    i365_set_pair(sock, base+I365_W_OFF, i);
+    
+    /* Turn on the window if necessary */
+    if (mem->flags & MAP_ACTIVE)
+	i365_bset(sock, I365_ADDRWIN, I365_ENA_MEM(map));
+    return 0;
+} /* i365_set_mem_map */
+
+#if 0 /* driver model ordering issue */
+/*======================================================================
+
+    Routines for accessing socket information and register dumps via
+    /sys/class/pcmcia_socket/...
+    
+======================================================================*/
+
+static ssize_t show_info(struct class_device *class_dev, char *buf)
+{
+	struct i82365_socket *s = container_of(class_dev, struct i82365_socket, socket.dev);
+	return sprintf(buf, "type:     %s\npsock:    %d\n",
+		       pcic[s->type].name, s->psock);
+}
+
+static ssize_t show_exca(struct class_device *class_dev, char *buf)
+{
+	struct i82365_socket *s = container_of(class_dev, struct i82365_socket, socket.dev);
+	unsigned short sock;
+	int i;
+	ssize_t ret = 0;
+	unsigned long flags = 0;
+
+	sock = s->number;
+
+	ISA_LOCK(sock, flags);
+	for (i = 0; i < 0x40; i += 4) {
+		ret += sprintf(buf, "%02x %02x %02x %02x%s",
+			       i365_get(sock,i), i365_get(sock,i+1),
+			       i365_get(sock,i+2), i365_get(sock,i+3),
+			       ((i % 16) == 12) ? "\n" : " ");
+		buf += ret;
+	}
+	ISA_UNLOCK(sock, flags);
+
+	return ret;
+}
+
+static CLASS_DEVICE_ATTR(exca, S_IRUGO, show_exca, NULL);
+static CLASS_DEVICE_ATTR(info, S_IRUGO, show_info, NULL);
+#endif
+
+/*====================================================================*/
+
+/* this is horribly ugly... proper locking needs to be done here at 
+ * some time... */
+#define LOCKED(x) do { \
+	int retval; \
+	unsigned long flags; \
+	spin_lock_irqsave(&isa_lock, flags); \
+	retval = x; \
+	spin_unlock_irqrestore(&isa_lock, flags); \
+	return retval; \
+} while (0)
+	
+
+static int pcic_get_status(struct pcmcia_socket *s, u_int *value)
+{
+	unsigned int sock = container_of(s, struct i82365_socket, socket)->number;
+
+	if (socket[sock].flags & IS_ALIVE) {
+		*value = 0;
+		return -EINVAL;
+	}
+
+	LOCKED(i365_get_status(sock, value));
+}
+
+static int pcic_get_socket(struct pcmcia_socket *s, socket_state_t *state)
+{
+	unsigned int sock = container_of(s, struct i82365_socket, socket)->number;
+
+	if (socket[sock].flags & IS_ALIVE)
+		return -EINVAL;
+
+	LOCKED(i365_get_socket(sock, state));
+}
+
+static int pcic_set_socket(struct pcmcia_socket *s, socket_state_t *state)
+{
+	unsigned int sock = container_of(s, struct i82365_socket, socket)->number;
+
+	if (socket[sock].flags & IS_ALIVE)
+		return -EINVAL;
+
+	LOCKED(i365_set_socket(sock, state));
+}
+
+static int pcic_set_io_map(struct pcmcia_socket *s, struct pccard_io_map *io)
+{
+	unsigned int sock = container_of(s, struct i82365_socket, socket)->number;
+	if (socket[sock].flags & IS_ALIVE)
+		return -EINVAL;
+
+	LOCKED(i365_set_io_map(sock, io));
+}
+
+static int pcic_set_mem_map(struct pcmcia_socket *s, struct pccard_mem_map *mem)
+{
+	unsigned int sock = container_of(s, struct i82365_socket, socket)->number;
+	if (socket[sock].flags & IS_ALIVE)
+		return -EINVAL;
+
+	LOCKED(i365_set_mem_map(sock, mem));
+}
+
+static int pcic_init(struct pcmcia_socket *s)
+{
+	int i;
+	struct resource res = { .start = 0, .end = 0x1000 };
+	pccard_io_map io = { 0, 0, 0, 0, 1 };
+	pccard_mem_map mem = { .res = &res, };
+
+	for (i = 0; i < 2; i++) {
+		io.map = i;
+		pcic_set_io_map(s, &io);
+	}
+	for (i = 0; i < 5; i++) {
+		mem.map = i;
+		pcic_set_mem_map(s, &mem);
+	}
+	return 0;
+}
+
+static struct pccard_operations pcic_operations = {
+	.init			= pcic_init,
+	.get_status		= pcic_get_status,
+	.get_socket		= pcic_get_socket,
+	.set_socket		= pcic_set_socket,
+	.set_io_map		= pcic_set_io_map,
+	.set_mem_map		= pcic_set_mem_map,
+};
+
+/*====================================================================*/
+
+static int i82365_suspend(struct device *dev, pm_message_t state, u32 level)
+{
+	int ret = 0;
+	if (level == SUSPEND_SAVE_STATE)
+		ret = pcmcia_socket_dev_suspend(dev, state);
+	return ret;
+}
+
+static int i82365_resume(struct device *dev, u32 level)
+{
+	int ret = 0;
+	if (level == RESUME_RESTORE_STATE)
+		ret = pcmcia_socket_dev_resume(dev);
+	return ret;
+}
+
+static struct device_driver i82365_driver = {
+	.name = "i82365",
+	.bus = &platform_bus_type,
+	.suspend = i82365_suspend,
+	.resume = i82365_resume,
+};
+
+static struct platform_device i82365_device = {
+	.name = "i82365",
+	.id = 0,
+};
+
+static int __init init_i82365(void)
+{
+    int i, ret;
+
+    ret = driver_register(&i82365_driver);
+    if (ret)
+	return ret;
+
+    ret = platform_device_register(&i82365_device);
+    if (ret) {
+	driver_unregister(&i82365_driver);
+	return ret;
+    }
+
+    printk(KERN_INFO "Intel ISA PCIC probe: ");
+    sockets = 0;
+
+    isa_probe();
+
+    if (sockets == 0) {
+	printk("not found.\n");
+	platform_device_unregister(&i82365_device);
+	driver_unregister(&i82365_driver);
+	return -ENODEV;
+    }
+
+    /* Set up interrupt handler(s) */
+    if (grab_irq != 0)
+	request_irq(cs_irq, pcic_interrupt, 0, "i82365", pcic_interrupt);
+    
+    /* register sockets with the pcmcia core */
+    for (i = 0; i < sockets; i++) {
+	    socket[i].socket.dev.dev = &i82365_device.dev;
+	    socket[i].socket.ops = &pcic_operations;
+	    socket[i].socket.resource_ops = &pccard_nonstatic_ops;
+	    socket[i].socket.owner = THIS_MODULE;
+	    socket[i].number = i;
+	    ret = pcmcia_register_socket(&socket[i].socket);
+	    if (!ret)
+		    socket[i].flags |= IS_REGISTERED;
+
+#if 0 /* driver model ordering issue */
+	   class_device_create_file(&socket[i].socket.dev,
+			   	    &class_device_attr_info);
+	   class_device_create_file(&socket[i].socket.dev,
+			   	    &class_device_attr_exca);
+#endif
+    }
+
+    /* Finally, schedule a polling interrupt */
+    if (poll_interval != 0) {
+	poll_timer.function = pcic_interrupt_wrapper;
+	poll_timer.data = 0;
+	init_timer(&poll_timer);
+    	poll_timer.expires = jiffies + poll_interval;
+	add_timer(&poll_timer);
+    }
+    
+    return 0;
+    
+} /* init_i82365 */
+
+static void __exit exit_i82365(void)
+{
+    int i;
+
+    for (i = 0; i < sockets; i++) {
+	    if (socket[i].flags & IS_REGISTERED)
+		    pcmcia_unregister_socket(&socket[i].socket);
+    }
+    platform_device_unregister(&i82365_device);
+    if (poll_interval != 0)
+	del_timer_sync(&poll_timer);
+    if (grab_irq != 0)
+	free_irq(cs_irq, pcic_interrupt);
+    for (i = 0; i < sockets; i++) {
+	/* Turn off all interrupt sources! */
+	i365_set(i, I365_CSCINT, 0);
+	release_region(socket[i].ioaddr, 2);
+    }
+#ifdef CONFIG_PNP
+    if (i82365_pnpdev)
+    		pnp_disable_dev(i82365_pnpdev);
+#endif
+    driver_unregister(&i82365_driver);
+} /* exit_i82365 */
+
+module_init(init_i82365);
+module_exit(exit_i82365);
+MODULE_LICENSE("Dual MPL/GPL");
+/*====================================================================*/
