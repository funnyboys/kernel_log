commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/pxa2xx_cm_x270.c b/drivers/pcmcia/pxa2xx_cm_x270.c
index f59223f2307d..36e35da5f887 100644
--- a/drivers/pcmcia/pxa2xx_cm_x270.c
+++ b/drivers/pcmcia/pxa2xx_cm_x270.c
@@ -1,13 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * linux/drivers/pcmcia/pxa/pxa_cm_x270.c
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * Compulab Ltd., 2003, 2007, 2008
  * Mike Rapoport <mike@compulab.co.il>
- *
  */
 
 #include <linux/platform_device.h>

commit 1c3d038bd5fb9dc868bb7474caaddc7aea4d562e
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Jan 14 16:21:50 2012 +0000

    PCMCIA: soc_common: remove explicit wrprot initialization in socket drivers
    
    soc_common already initializes state.wrprot to zero, so explicitly
    setting wrprot to zero in the socket drivers has no additional effect.
    
    Acked-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_cm_x270.c b/drivers/pcmcia/pxa2xx_cm_x270.c
index efb5f132851b..f59223f2307d 100644
--- a/drivers/pcmcia/pxa2xx_cm_x270.c
+++ b/drivers/pcmcia/pxa2xx_cm_x270.c
@@ -48,7 +48,6 @@ static void cmx270_pcmcia_socket_state(struct soc_pcmcia_socket *skt,
 {
 	state->vs_3v  = 0;
 	state->vs_Xv  = 0;
-	state->wrprot = 0;  /* not available */
 }
 
 

commit a9bb5a4bf9f84256499c802fd397d56d55227e4f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Jan 13 22:56:32 2012 +0000

    PCMCIA: pxa: convert PXA socket drivers to use new irq/gpio management
    
    Convert all the PXA platform socket drivers to use the new irq/gpio
    management provided by soc_common.  This relieves these drivers from
    having to do anything with these GPIOs other than provide the numbers
    to soc_common.
    
    Acked-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_cm_x270.c b/drivers/pcmcia/pxa2xx_cm_x270.c
index 3dc7621a0767..efb5f132851b 100644
--- a/drivers/pcmcia/pxa2xx_cm_x270.c
+++ b/drivers/pcmcia/pxa2xx_cm_x270.c
@@ -22,14 +22,6 @@
 #define GPIO_PCMCIA_S0_RDYINT	(82)
 #define GPIO_PCMCIA_RESET	(53)
 
-#define PCMCIA_S0_CD_VALID	gpio_to_irq(GPIO_PCMCIA_S0_CD_VALID)
-#define PCMCIA_S0_RDYINT	gpio_to_irq(GPIO_PCMCIA_S0_RDYINT)
-
-
-static struct pcmcia_irqs irqs[] = {
-	{ .sock = 0, .str = "PCMCIA0 CD" },
-};
-
 static int cmx270_pcmcia_hw_init(struct soc_pcmcia_socket *skt)
 {
 	int ret = gpio_request(GPIO_PCMCIA_RESET, "PCCard reset");
@@ -37,18 +29,16 @@ static int cmx270_pcmcia_hw_init(struct soc_pcmcia_socket *skt)
 		return ret;
 	gpio_direction_output(GPIO_PCMCIA_RESET, 0);
 
-	skt->socket.pci_irq = PCMCIA_S0_RDYINT;
-	irqs[0].irq = PCMCIA_S0_CD_VALID;
-	ret = soc_pcmcia_request_irqs(skt, irqs, ARRAY_SIZE(irqs));
-	if (!ret)
-		gpio_free(GPIO_PCMCIA_RESET);
+	skt->stat[SOC_STAT_CD].gpio = GPIO_PCMCIA_S0_CD_VALID;
+	skt->stat[SOC_STAT_CD].name = "PCMCIA0 CD";
+	skt->stat[SOC_STAT_RDY].gpio = GPIO_PCMCIA_S0_RDYINT;
+	skt->stat[SOC_STAT_RDY].name = "PCMCIA0 RDY";
 
 	return ret;
 }
 
 static void cmx270_pcmcia_shutdown(struct soc_pcmcia_socket *skt)
 {
-	soc_pcmcia_free_irqs(skt, irqs, ARRAY_SIZE(irqs));
 	gpio_free(GPIO_PCMCIA_RESET);
 }
 
@@ -56,10 +46,6 @@ static void cmx270_pcmcia_shutdown(struct soc_pcmcia_socket *skt)
 static void cmx270_pcmcia_socket_state(struct soc_pcmcia_socket *skt,
 				       struct pcmcia_state *state)
 {
-	state->detect = (gpio_get_value(GPIO_PCMCIA_S0_CD_VALID) == 0) ? 1 : 0;
-	state->ready  = (gpio_get_value(GPIO_PCMCIA_S0_RDYINT) == 0) ? 0 : 1;
-	state->bvd1   = 1;
-	state->bvd2   = 1;
 	state->vs_3v  = 0;
 	state->vs_Xv  = 0;
 	state->wrprot = 0;  /* not available */

commit 951c486f62490e032da0ad17e93270b0cfb6687f
Author: Haojian Zhuang <haojian.zhuang@marvell.com>
Date:   Mon Nov 14 20:52:26 2011 +0800

    driver: pcmcia: replace IRQ_GPIO() with gpio_to_irq()
    
    Use common gpio_to_irq() to replace machine dependant macro IRQ_GPIO().
    
    Signed-off-by: Haojian Zhuang <haojian.zhuang@marvell.com>

diff --git a/drivers/pcmcia/pxa2xx_cm_x270.c b/drivers/pcmcia/pxa2xx_cm_x270.c
index 923f315926ef..3dc7621a0767 100644
--- a/drivers/pcmcia/pxa2xx_cm_x270.c
+++ b/drivers/pcmcia/pxa2xx_cm_x270.c
@@ -16,20 +16,18 @@
 #include <linux/gpio.h>
 #include <linux/export.h>
 
-#include <asm/mach-types.h>
-
 #include "soc_common.h"
 
 #define GPIO_PCMCIA_S0_CD_VALID	(84)
 #define GPIO_PCMCIA_S0_RDYINT	(82)
 #define GPIO_PCMCIA_RESET	(53)
 
-#define PCMCIA_S0_CD_VALID	IRQ_GPIO(GPIO_PCMCIA_S0_CD_VALID)
-#define PCMCIA_S0_RDYINT	IRQ_GPIO(GPIO_PCMCIA_S0_RDYINT)
+#define PCMCIA_S0_CD_VALID	gpio_to_irq(GPIO_PCMCIA_S0_CD_VALID)
+#define PCMCIA_S0_RDYINT	gpio_to_irq(GPIO_PCMCIA_S0_RDYINT)
 
 
 static struct pcmcia_irqs irqs[] = {
-	{ 0, PCMCIA_S0_CD_VALID, "PCMCIA0 CD" },
+	{ .sock = 0, .str = "PCMCIA0 CD" },
 };
 
 static int cmx270_pcmcia_hw_init(struct soc_pcmcia_socket *skt)
@@ -40,6 +38,7 @@ static int cmx270_pcmcia_hw_init(struct soc_pcmcia_socket *skt)
 	gpio_direction_output(GPIO_PCMCIA_RESET, 0);
 
 	skt->socket.pci_irq = PCMCIA_S0_RDYINT;
+	irqs[0].irq = PCMCIA_S0_CD_VALID;
 	ret = soc_pcmcia_request_irqs(skt, irqs, ARRAY_SIZE(irqs));
 	if (!ret)
 		gpio_free(GPIO_PCMCIA_RESET);

commit 402b20de62f4183d70fae335ca33b0327bdf0afd
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 31 16:21:42 2011 -0400

    pcmcia: Add export.h to drivers/pcmcia as required.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/pcmcia/pxa2xx_cm_x270.c b/drivers/pcmcia/pxa2xx_cm_x270.c
index 6ee42b4c3e68..923f315926ef 100644
--- a/drivers/pcmcia/pxa2xx_cm_x270.c
+++ b/drivers/pcmcia/pxa2xx_cm_x270.c
@@ -14,6 +14,7 @@
 #include <linux/irq.h>
 #include <linux/delay.h>
 #include <linux/gpio.h>
+#include <linux/export.h>
 
 #include <asm/mach-types.h>
 

commit 7594549e8acec8123c45e26750b7820d9e938760
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Wed Jul 13 15:54:57 2011 +0100

    pcmcia: pxa2xx: remove empty socket_init / socket_resume functions.
    
    Now the are optional, let us get rid of the ones that don't have
    any content.
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pxa2xx_cm_x270.c b/drivers/pcmcia/pxa2xx_cm_x270.c
index 5662646b84da..6ee42b4c3e68 100644
--- a/drivers/pcmcia/pxa2xx_cm_x270.c
+++ b/drivers/pcmcia/pxa2xx_cm_x270.c
@@ -82,23 +82,12 @@ static int cmx270_pcmcia_configure_socket(struct soc_pcmcia_socket *skt,
 	return 0;
 }
 
-static void cmx270_pcmcia_socket_init(struct soc_pcmcia_socket *skt)
-{
-}
-
-static void cmx270_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)
-{
-}
-
-
 static struct pcmcia_low_level cmx270_pcmcia_ops __initdata = {
 	.owner			= THIS_MODULE,
 	.hw_init		= cmx270_pcmcia_hw_init,
 	.hw_shutdown		= cmx270_pcmcia_shutdown,
 	.socket_state		= cmx270_pcmcia_socket_state,
 	.configure_socket	= cmx270_pcmcia_configure_socket,
-	.socket_init		= cmx270_pcmcia_socket_init,
-	.socket_suspend		= cmx270_pcmcia_socket_suspend,
 	.nr			= 1,
 };
 

commit 66024db57d5b9011e274b314affad68f370c0d6f
Author: Russell King - ARM Linux <linux@arm.linux.org.uk>
Date:   Sun Mar 29 22:45:26 2009 +0100

    PCMCIA: stop duplicating pci_irq in soc_pcmcia_socket
    
    skt->irq is a mere duplication of pcmcia_socket's pci_irq member.
    Get rid of it.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pxa2xx_cm_x270.c b/drivers/pcmcia/pxa2xx_cm_x270.c
index a7b943d01e34..5662646b84da 100644
--- a/drivers/pcmcia/pxa2xx_cm_x270.c
+++ b/drivers/pcmcia/pxa2xx_cm_x270.c
@@ -38,7 +38,7 @@ static int cmx270_pcmcia_hw_init(struct soc_pcmcia_socket *skt)
 		return ret;
 	gpio_direction_output(GPIO_PCMCIA_RESET, 0);
 
-	skt->irq = PCMCIA_S0_RDYINT;
+	skt->socket.pci_irq = PCMCIA_S0_RDYINT;
 	ret = soc_pcmcia_request_irqs(skt, irqs, ARRAY_SIZE(irqs));
 	if (!ret)
 		gpio_free(GPIO_PCMCIA_RESET);

commit 5742964e916269e01a3467d2bff2601180b7da3d
Author: Eric Miao <eric.miao@marvell.com>
Date:   Mon Jan 19 15:28:07 2009 +0800

    [ARM] pxa: remove unnecessary #include of pxa-regs.h and hardware.h
    
    pxa-regs.h and hardware.h are not intended for use directly in driver
    code, remove those unnecessary references.
    
    Signed-off-by: Eric Miao <eric.miao@marvell.com>

diff --git a/drivers/pcmcia/pxa2xx_cm_x270.c b/drivers/pcmcia/pxa2xx_cm_x270.c
index 6c3aac377126..a7b943d01e34 100644
--- a/drivers/pcmcia/pxa2xx_cm_x270.c
+++ b/drivers/pcmcia/pxa2xx_cm_x270.c
@@ -16,7 +16,6 @@
 #include <linux/gpio.h>
 
 #include <asm/mach-types.h>
-#include <mach/pxa-regs.h>
 
 #include "soc_common.h"
 

commit 8616e2fb6930103a8408998777ec8a2332f5e89d
Author: Mike Rapoport <mike@compulab.co.il>
Date:   Sun Oct 5 10:27:22 2008 +0100

    [ARM] 5283/1: pxa: add CM-X255 pcmcia support
    
    Signed-off-by: Russ Dill <russ.dill@gmail.com>
    Signed-off-by: Mike Rapoport <mike@compulab.co.il>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_cm_x270.c b/drivers/pcmcia/pxa2xx_cm_x270.c
index bcff5cfed051..6c3aac377126 100644
--- a/drivers/pcmcia/pxa2xx_cm_x270.c
+++ b/drivers/pcmcia/pxa2xx_cm_x270.c
@@ -105,13 +105,10 @@ static struct pcmcia_low_level cmx270_pcmcia_ops __initdata = {
 
 static struct platform_device *cmx270_pcmcia_device;
 
-static int __init cmx270_pcmcia_init(void)
+int __init cmx270_pcmcia_init(void)
 {
 	int ret;
 
-	if (!machine_is_armcore())
-		return -ENODEV;
-
 	cmx270_pcmcia_device = platform_device_alloc("pxa2xx-pcmcia", -1);
 
 	if (!cmx270_pcmcia_device)
@@ -131,14 +128,7 @@ static int __init cmx270_pcmcia_init(void)
 	return ret;
 }
 
-static void __exit cmx270_pcmcia_exit(void)
+void __exit cmx270_pcmcia_exit(void)
 {
 	platform_device_unregister(cmx270_pcmcia_device);
 }
-
-module_init(cmx270_pcmcia_init);
-module_exit(cmx270_pcmcia_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Mike Rapoport <mike@compulab.co.il>");
-MODULE_DESCRIPTION("CM-x270 PCMCIA driver");

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_cm_x270.c b/drivers/pcmcia/pxa2xx_cm_x270.c
index bb95db7d2b76..bcff5cfed051 100644
--- a/drivers/pcmcia/pxa2xx_cm_x270.c
+++ b/drivers/pcmcia/pxa2xx_cm_x270.c
@@ -16,7 +16,7 @@
 #include <linux/gpio.h>
 
 #include <asm/mach-types.h>
-#include <asm/arch/pxa-regs.h>
+#include <mach/pxa-regs.h>
 
 #include "soc_common.h"
 

commit 779c545d945eeb7778c27c531bae58df7767229d
Author: Mike Rapoport <mike@compulab.co.il>
Date:   Tue Jun 17 09:48:03 2008 +0100

    [ARM] 5104/1: CM-X270: PCMCIA updates
    
    Convert to use gpio_lib interface.
    Remove support for second PCMCIA slot to avoid run-time conflicts with MMC/SD
    because of shared GPIO
    
    Signed-off-by: Mike Rapoport <mike@compulab.co.il>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_cm_x270.c b/drivers/pcmcia/pxa2xx_cm_x270.c
index f123fce65f2e..bb95db7d2b76 100644
--- a/drivers/pcmcia/pxa2xx_cm_x270.c
+++ b/drivers/pcmcia/pxa2xx_cm_x270.c
@@ -5,83 +5,60 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
- * Compulab Ltd., 2003, 2007
+ * Compulab Ltd., 2003, 2007, 2008
  * Mike Rapoport <mike@compulab.co.il>
  *
  */
 
-#include <linux/kernel.h>
-#include <linux/sched.h>
 #include <linux/platform_device.h>
 #include <linux/irq.h>
 #include <linux/delay.h>
+#include <linux/gpio.h>
 
-#include <pcmcia/ss.h>
-#include <asm/hardware.h>
 #include <asm/mach-types.h>
-
 #include <asm/arch/pxa-regs.h>
-#include <asm/arch/pxa2xx-gpio.h>
-#include <asm/arch/cm-x270.h>
 
 #include "soc_common.h"
 
+#define GPIO_PCMCIA_S0_CD_VALID	(84)
+#define GPIO_PCMCIA_S0_RDYINT	(82)
+#define GPIO_PCMCIA_RESET	(53)
+
+#define PCMCIA_S0_CD_VALID	IRQ_GPIO(GPIO_PCMCIA_S0_CD_VALID)
+#define PCMCIA_S0_RDYINT	IRQ_GPIO(GPIO_PCMCIA_S0_RDYINT)
+
+
 static struct pcmcia_irqs irqs[] = {
 	{ 0, PCMCIA_S0_CD_VALID, "PCMCIA0 CD" },
-	{ 1, PCMCIA_S1_CD_VALID, "PCMCIA1 CD" },
 };
 
 static int cmx270_pcmcia_hw_init(struct soc_pcmcia_socket *skt)
 {
-	GPSR(GPIO48_nPOE) = GPIO_bit(GPIO48_nPOE) |
-		GPIO_bit(GPIO49_nPWE) |
-		GPIO_bit(GPIO50_nPIOR) |
-		GPIO_bit(GPIO51_nPIOW) |
-		GPIO_bit(GPIO85_nPCE_1) |
-		GPIO_bit(GPIO54_nPCE_2);
-
-	pxa_gpio_mode(GPIO48_nPOE_MD);
-	pxa_gpio_mode(GPIO49_nPWE_MD);
-	pxa_gpio_mode(GPIO50_nPIOR_MD);
-	pxa_gpio_mode(GPIO51_nPIOW_MD);
-	pxa_gpio_mode(GPIO85_nPCE_1_MD);
-	pxa_gpio_mode(GPIO54_nPCE_2_MD);
-	pxa_gpio_mode(GPIO55_nPREG_MD);
-	pxa_gpio_mode(GPIO56_nPWAIT_MD);
-	pxa_gpio_mode(GPIO57_nIOIS16_MD);
-
-	/* Reset signal */
-	pxa_gpio_mode(GPIO53_nPCE_2 | GPIO_OUT);
-	GPCR(GPIO53_nPCE_2) = GPIO_bit(GPIO53_nPCE_2);
-
-	set_irq_type(PCMCIA_S0_CD_VALID, IRQ_TYPE_EDGE_BOTH);
-	set_irq_type(PCMCIA_S1_CD_VALID, IRQ_TYPE_EDGE_BOTH);
-
-	/* irq's for slots: */
-	set_irq_type(PCMCIA_S0_RDYINT, IRQ_TYPE_EDGE_FALLING);
-	set_irq_type(PCMCIA_S1_RDYINT, IRQ_TYPE_EDGE_FALLING);
-
-	skt->irq = (skt->nr == 0) ? PCMCIA_S0_RDYINT : PCMCIA_S1_RDYINT;
-	return soc_pcmcia_request_irqs(skt, irqs, ARRAY_SIZE(irqs));
+	int ret = gpio_request(GPIO_PCMCIA_RESET, "PCCard reset");
+	if (ret)
+		return ret;
+	gpio_direction_output(GPIO_PCMCIA_RESET, 0);
+
+	skt->irq = PCMCIA_S0_RDYINT;
+	ret = soc_pcmcia_request_irqs(skt, irqs, ARRAY_SIZE(irqs));
+	if (!ret)
+		gpio_free(GPIO_PCMCIA_RESET);
+
+	return ret;
 }
 
 static void cmx270_pcmcia_shutdown(struct soc_pcmcia_socket *skt)
 {
 	soc_pcmcia_free_irqs(skt, irqs, ARRAY_SIZE(irqs));
-
-	set_irq_type(IRQ_TO_GPIO(PCMCIA_S0_CD_VALID), IRQ_TYPE_NONE);
-	set_irq_type(IRQ_TO_GPIO(PCMCIA_S1_CD_VALID), IRQ_TYPE_NONE);
-
-	set_irq_type(IRQ_TO_GPIO(PCMCIA_S0_RDYINT), IRQ_TYPE_NONE);
-	set_irq_type(IRQ_TO_GPIO(PCMCIA_S1_RDYINT), IRQ_TYPE_NONE);
+	gpio_free(GPIO_PCMCIA_RESET);
 }
 
 
 static void cmx270_pcmcia_socket_state(struct soc_pcmcia_socket *skt,
 				       struct pcmcia_state *state)
 {
-	state->detect = (PCC_DETECT(skt->nr) == 0) ? 1 : 0;
-	state->ready  = (PCC_READY(skt->nr) == 0) ? 0 : 1;
+	state->detect = (gpio_get_value(GPIO_PCMCIA_S0_CD_VALID) == 0) ? 1 : 0;
+	state->ready  = (gpio_get_value(GPIO_PCMCIA_S0_RDYINT) == 0) ? 0 : 1;
 	state->bvd1   = 1;
 	state->bvd2   = 1;
 	state->vs_3v  = 0;
@@ -93,32 +70,16 @@ static void cmx270_pcmcia_socket_state(struct soc_pcmcia_socket *skt,
 static int cmx270_pcmcia_configure_socket(struct soc_pcmcia_socket *skt,
 					  const socket_state_t *state)
 {
-	GPSR(GPIO49_nPWE) = GPIO_bit(GPIO49_nPWE);
-	pxa_gpio_mode(GPIO49_nPWE | GPIO_OUT);
-
 	switch (skt->nr) {
 	case 0:
 		if (state->flags & SS_RESET) {
-			GPCR(GPIO49_nPWE) = GPIO_bit(GPIO49_nPWE);
-			GPSR(GPIO53_nPCE_2) = GPIO_bit(GPIO53_nPCE_2);
-			udelay(10);
-			GPCR(GPIO53_nPCE_2) = GPIO_bit(GPIO53_nPCE_2);
-			GPSR(GPIO49_nPWE) = GPIO_bit(GPIO49_nPWE);
-		}
-		break;
-	case 1:
-		if (state->flags & SS_RESET) {
-			GPCR(GPIO49_nPWE) = GPIO_bit(GPIO49_nPWE);
-			GPSR(GPIO53_nPCE_2) = GPIO_bit(GPIO53_nPCE_2);
+			gpio_set_value(GPIO_PCMCIA_RESET, 1);
 			udelay(10);
-			GPCR(GPIO53_nPCE_2) = GPIO_bit(GPIO53_nPCE_2);
-			GPSR(GPIO49_nPWE) = GPIO_bit(GPIO49_nPWE);
+			gpio_set_value(GPIO_PCMCIA_RESET, 0);
 		}
 		break;
 	}
 
-	pxa_gpio_mode(GPIO49_nPWE_MD);
-
 	return 0;
 }
 
@@ -139,7 +100,7 @@ static struct pcmcia_low_level cmx270_pcmcia_ops __initdata = {
 	.configure_socket	= cmx270_pcmcia_configure_socket,
 	.socket_init		= cmx270_pcmcia_socket_init,
 	.socket_suspend		= cmx270_pcmcia_socket_suspend,
-	.nr			= 2,
+	.nr			= 1,
 };
 
 static struct platform_device *cmx270_pcmcia_device;

commit 4e5e8de0dbdeb08df2b4c15fa2b0ba2216091793
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Apr 24 15:28:11 2008 +0100

    [ARM] pxa: avoid kfreeing static data if platform device fails to register
    
    When a dynamically allocated platform device is 'put', the platform
    device's platform_data is kfree'd.  This is bad if it's pointing at
    static data.  Use the provided function to register platform data
    for these devices.
    
    This also means we can mark the pcmcia ops structures as __initdata.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_cm_x270.c b/drivers/pcmcia/pxa2xx_cm_x270.c
index 4a6c020afb37..f123fce65f2e 100644
--- a/drivers/pcmcia/pxa2xx_cm_x270.c
+++ b/drivers/pcmcia/pxa2xx_cm_x270.c
@@ -131,7 +131,7 @@ static void cmx270_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)
 }
 
 
-static struct pcmcia_low_level cmx270_pcmcia_ops = {
+static struct pcmcia_low_level cmx270_pcmcia_ops __initdata = {
 	.owner			= THIS_MODULE,
 	.hw_init		= cmx270_pcmcia_hw_init,
 	.hw_shutdown		= cmx270_pcmcia_shutdown,
@@ -156,10 +156,13 @@ static int __init cmx270_pcmcia_init(void)
 	if (!cmx270_pcmcia_device)
 		return -ENOMEM;
 
-	cmx270_pcmcia_device->dev.platform_data = &cmx270_pcmcia_ops;
+	ret = platform_device_add_data(cmx270_pcmcia_device, &cmx270_pcmcia_ops,
+				       sizeof(cmx270_pcmcia_ops));
 
-	printk(KERN_INFO "Registering cm-x270 PCMCIA interface.\n");
-	ret = platform_device_add(cmx270_pcmcia_device);
+	if (ret == 0) {
+		printk(KERN_INFO "Registering cm-x270 PCMCIA interface.\n");
+		ret = platform_device_add(cmx270_pcmcia_device);
+	}
 
 	if (ret)
 		platform_device_put(cmx270_pcmcia_device);

commit 04ba0f656f7580d8a51a5b3441e088309141b67a
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Apr 24 15:23:25 2008 +0100

    [ARM] pxa: avoid registering multiple pxa2xx_pcmcia devices
    
    cm_x270 and mainstone both register their PCMCIA devices using the same
    name, resulting in a warning message from the kernel.  Avoid this by
    making the cm_x270 and mainstone PCMCIA initialisation conditional on
    the machine type we're running on.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_cm_x270.c b/drivers/pcmcia/pxa2xx_cm_x270.c
index e7ab060ff118..4a6c020afb37 100644
--- a/drivers/pcmcia/pxa2xx_cm_x270.c
+++ b/drivers/pcmcia/pxa2xx_cm_x270.c
@@ -18,6 +18,7 @@
 
 #include <pcmcia/ss.h>
 #include <asm/hardware.h>
+#include <asm/mach-types.h>
 
 #include <asm/arch/pxa-regs.h>
 #include <asm/arch/pxa2xx-gpio.h>
@@ -147,6 +148,9 @@ static int __init cmx270_pcmcia_init(void)
 {
 	int ret;
 
+	if (!machine_is_armcore())
+		return -ENODEV;
+
 	cmx270_pcmcia_device = platform_device_alloc("pxa2xx-pcmcia", -1);
 
 	if (!cmx270_pcmcia_device)

commit a683b14df8f4320d0ef6cac93a6d9806173bf339
Author: eric miao <eric.miao@marvell.com>
Date:   Mon Mar 3 09:44:25 2008 +0800

    [ARM] pxa: separate GPIOs and their mode definitions to pxa2xx-gpio.h
    
    two reasons:
    1. GPIO namings and their mode definitions are conceptually not part
       of the PXA register definitions
    
    2. this is actually a temporary move in the transition of PXA2xx to
       use MFP-alike APIs (as what PXA3xx is now doing), so that legacy
       code will still work and new code can be added in step by step
    
    Signed-off-by: eric miao <eric.miao@marvell.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_cm_x270.c b/drivers/pcmcia/pxa2xx_cm_x270.c
index fbf2f3a6984c..e7ab060ff118 100644
--- a/drivers/pcmcia/pxa2xx_cm_x270.c
+++ b/drivers/pcmcia/pxa2xx_cm_x270.c
@@ -20,6 +20,7 @@
 #include <asm/hardware.h>
 
 #include <asm/arch/pxa-regs.h>
+#include <asm/arch/pxa2xx-gpio.h>
 #include <asm/arch/cm-x270.h>
 
 #include "soc_common.h"

commit 87944f3361fc033b73617aa663135c6e468957a7
Author: Mike Rapoport <mike@compulab.co.il>
Date:   Sun Sep 23 16:00:20 2007 +0100

    [ARM] 4578/1: CM-x270: PCMCIA support
    
    This patch provides support for PCMCIA on CM-X270
    
    Signed-off-by: Mike Rapoport <mike@compulab.co.il>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_cm_x270.c b/drivers/pcmcia/pxa2xx_cm_x270.c
new file mode 100644
index 000000000000..fbf2f3a6984c
--- /dev/null
+++ b/drivers/pcmcia/pxa2xx_cm_x270.c
@@ -0,0 +1,175 @@
+/*
+ * linux/drivers/pcmcia/pxa/pxa_cm_x270.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Compulab Ltd., 2003, 2007
+ * Mike Rapoport <mike@compulab.co.il>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+
+#include <pcmcia/ss.h>
+#include <asm/hardware.h>
+
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/cm-x270.h>
+
+#include "soc_common.h"
+
+static struct pcmcia_irqs irqs[] = {
+	{ 0, PCMCIA_S0_CD_VALID, "PCMCIA0 CD" },
+	{ 1, PCMCIA_S1_CD_VALID, "PCMCIA1 CD" },
+};
+
+static int cmx270_pcmcia_hw_init(struct soc_pcmcia_socket *skt)
+{
+	GPSR(GPIO48_nPOE) = GPIO_bit(GPIO48_nPOE) |
+		GPIO_bit(GPIO49_nPWE) |
+		GPIO_bit(GPIO50_nPIOR) |
+		GPIO_bit(GPIO51_nPIOW) |
+		GPIO_bit(GPIO85_nPCE_1) |
+		GPIO_bit(GPIO54_nPCE_2);
+
+	pxa_gpio_mode(GPIO48_nPOE_MD);
+	pxa_gpio_mode(GPIO49_nPWE_MD);
+	pxa_gpio_mode(GPIO50_nPIOR_MD);
+	pxa_gpio_mode(GPIO51_nPIOW_MD);
+	pxa_gpio_mode(GPIO85_nPCE_1_MD);
+	pxa_gpio_mode(GPIO54_nPCE_2_MD);
+	pxa_gpio_mode(GPIO55_nPREG_MD);
+	pxa_gpio_mode(GPIO56_nPWAIT_MD);
+	pxa_gpio_mode(GPIO57_nIOIS16_MD);
+
+	/* Reset signal */
+	pxa_gpio_mode(GPIO53_nPCE_2 | GPIO_OUT);
+	GPCR(GPIO53_nPCE_2) = GPIO_bit(GPIO53_nPCE_2);
+
+	set_irq_type(PCMCIA_S0_CD_VALID, IRQ_TYPE_EDGE_BOTH);
+	set_irq_type(PCMCIA_S1_CD_VALID, IRQ_TYPE_EDGE_BOTH);
+
+	/* irq's for slots: */
+	set_irq_type(PCMCIA_S0_RDYINT, IRQ_TYPE_EDGE_FALLING);
+	set_irq_type(PCMCIA_S1_RDYINT, IRQ_TYPE_EDGE_FALLING);
+
+	skt->irq = (skt->nr == 0) ? PCMCIA_S0_RDYINT : PCMCIA_S1_RDYINT;
+	return soc_pcmcia_request_irqs(skt, irqs, ARRAY_SIZE(irqs));
+}
+
+static void cmx270_pcmcia_shutdown(struct soc_pcmcia_socket *skt)
+{
+	soc_pcmcia_free_irqs(skt, irqs, ARRAY_SIZE(irqs));
+
+	set_irq_type(IRQ_TO_GPIO(PCMCIA_S0_CD_VALID), IRQ_TYPE_NONE);
+	set_irq_type(IRQ_TO_GPIO(PCMCIA_S1_CD_VALID), IRQ_TYPE_NONE);
+
+	set_irq_type(IRQ_TO_GPIO(PCMCIA_S0_RDYINT), IRQ_TYPE_NONE);
+	set_irq_type(IRQ_TO_GPIO(PCMCIA_S1_RDYINT), IRQ_TYPE_NONE);
+}
+
+
+static void cmx270_pcmcia_socket_state(struct soc_pcmcia_socket *skt,
+				       struct pcmcia_state *state)
+{
+	state->detect = (PCC_DETECT(skt->nr) == 0) ? 1 : 0;
+	state->ready  = (PCC_READY(skt->nr) == 0) ? 0 : 1;
+	state->bvd1   = 1;
+	state->bvd2   = 1;
+	state->vs_3v  = 0;
+	state->vs_Xv  = 0;
+	state->wrprot = 0;  /* not available */
+}
+
+
+static int cmx270_pcmcia_configure_socket(struct soc_pcmcia_socket *skt,
+					  const socket_state_t *state)
+{
+	GPSR(GPIO49_nPWE) = GPIO_bit(GPIO49_nPWE);
+	pxa_gpio_mode(GPIO49_nPWE | GPIO_OUT);
+
+	switch (skt->nr) {
+	case 0:
+		if (state->flags & SS_RESET) {
+			GPCR(GPIO49_nPWE) = GPIO_bit(GPIO49_nPWE);
+			GPSR(GPIO53_nPCE_2) = GPIO_bit(GPIO53_nPCE_2);
+			udelay(10);
+			GPCR(GPIO53_nPCE_2) = GPIO_bit(GPIO53_nPCE_2);
+			GPSR(GPIO49_nPWE) = GPIO_bit(GPIO49_nPWE);
+		}
+		break;
+	case 1:
+		if (state->flags & SS_RESET) {
+			GPCR(GPIO49_nPWE) = GPIO_bit(GPIO49_nPWE);
+			GPSR(GPIO53_nPCE_2) = GPIO_bit(GPIO53_nPCE_2);
+			udelay(10);
+			GPCR(GPIO53_nPCE_2) = GPIO_bit(GPIO53_nPCE_2);
+			GPSR(GPIO49_nPWE) = GPIO_bit(GPIO49_nPWE);
+		}
+		break;
+	}
+
+	pxa_gpio_mode(GPIO49_nPWE_MD);
+
+	return 0;
+}
+
+static void cmx270_pcmcia_socket_init(struct soc_pcmcia_socket *skt)
+{
+}
+
+static void cmx270_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)
+{
+}
+
+
+static struct pcmcia_low_level cmx270_pcmcia_ops = {
+	.owner			= THIS_MODULE,
+	.hw_init		= cmx270_pcmcia_hw_init,
+	.hw_shutdown		= cmx270_pcmcia_shutdown,
+	.socket_state		= cmx270_pcmcia_socket_state,
+	.configure_socket	= cmx270_pcmcia_configure_socket,
+	.socket_init		= cmx270_pcmcia_socket_init,
+	.socket_suspend		= cmx270_pcmcia_socket_suspend,
+	.nr			= 2,
+};
+
+static struct platform_device *cmx270_pcmcia_device;
+
+static int __init cmx270_pcmcia_init(void)
+{
+	int ret;
+
+	cmx270_pcmcia_device = platform_device_alloc("pxa2xx-pcmcia", -1);
+
+	if (!cmx270_pcmcia_device)
+		return -ENOMEM;
+
+	cmx270_pcmcia_device->dev.platform_data = &cmx270_pcmcia_ops;
+
+	printk(KERN_INFO "Registering cm-x270 PCMCIA interface.\n");
+	ret = platform_device_add(cmx270_pcmcia_device);
+
+	if (ret)
+		platform_device_put(cmx270_pcmcia_device);
+
+	return ret;
+}
+
+static void __exit cmx270_pcmcia_exit(void)
+{
+	platform_device_unregister(cmx270_pcmcia_device);
+}
+
+module_init(cmx270_pcmcia_init);
+module_exit(cmx270_pcmcia_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Mike Rapoport <mike@compulab.co.il>");
+MODULE_DESCRIPTION("CM-x270 PCMCIA driver");
