commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index 89ebd8c76636..5fdd25a9e28e 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -1,14 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Sharp SL-C7xx Series PCMCIA routines
  *
  * Copyright (c) 2004-2005 Richard Purdie
  *
  * Based on Sharp's 2.4 kernel patches and pxa2xx_mainstone.c
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  */
 
 #include <linux/module.h>

commit 34cdf25a126f053698d549cc12a9c30e9a8a0bab
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:23:12 2012 -0500

    pcmcia: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Haojian Zhuang <haojian.zhuang@gmail.com>
    Acked-by: Eric Miao <eric.y.miao@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index 7dd879ce514d..89ebd8c76636 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -208,7 +208,7 @@ static struct pcmcia_low_level sharpsl_pcmcia_ops = {
 #ifdef CONFIG_SA1100_COLLIE
 #include "sa11xx_base.h"
 
-int __devinit pcmcia_collie_init(struct device *dev)
+int pcmcia_collie_init(struct device *dev)
 {
        int ret = -ENODEV;
 

commit fdc858a466b738d35d3492bc7cf77b1dac98bf7c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Apr 30 13:50:56 2012 +0000

    pcmcia: sharpsl: don't discard sharpsl_pcmcia_ops
    
    The sharpsl_pcmcia_ops structure gets passed into
    sa11xx_drv_pcmcia_probe, where it gets accessed at run-time,
    unlike all other pcmcia drivers that pass their structures
    into platform_device_add_data, which makes a copy.
    
    This means the gcc warning is valid and the structure
    must not be marked as __initdata.
    
    Without this patch, building collie_defconfig results in:
    
    drivers/pcmcia/pxa2xx_sharpsl.c:22:31: fatal error: mach-pxa/hardware.h: No such file or directory
    compilation terminated.
    make[3]: *** [drivers/pcmcia/pxa2xx_sharpsl.o] Error 1
    make[2]: *** [drivers/pcmcia] Error 2
    make[1]: *** [drivers] Error 2
    make: *** [sub-make] Error 2
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Pavel Machek <pavel@suse.cz>
    Cc: linux-pcmcia@lists.infradead.org
    Cc: Jochen Friedrich <jochen@scram.de>
    Cc: stable@vger.kernel.org

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index b066273b6b4f..7dd879ce514d 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -194,7 +194,7 @@ static void sharpsl_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)
 	sharpsl_pcmcia_init_reset(skt);
 }
 
-static struct pcmcia_low_level sharpsl_pcmcia_ops __initdata = {
+static struct pcmcia_low_level sharpsl_pcmcia_ops = {
 	.owner                  = THIS_MODULE,
 	.hw_init                = sharpsl_pcmcia_hw_init,
 	.socket_state           = sharpsl_pcmcia_socket_state,

commit a9bb5a4bf9f84256499c802fd397d56d55227e4f
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Fri Jan 13 22:56:32 2012 +0000

    PCMCIA: pxa: convert PXA socket drivers to use new irq/gpio management
    
    Convert all the PXA platform socket drivers to use the new irq/gpio
    management provided by soc_common.  This relieves these drivers from
    having to do anything with these GPIOs other than provide the numbers
    to soc_common.
    
    Acked-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index 69ae2fd22400..b066273b6b4f 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -46,21 +46,9 @@ static void sharpsl_pcmcia_init_reset(struct soc_pcmcia_socket *skt)
 
 static int sharpsl_pcmcia_hw_init(struct soc_pcmcia_socket *skt)
 {
-	int ret;
-
-	/* Register interrupts */
 	if (SCOOP_DEV[skt->nr].cd_irq >= 0) {
-		struct pcmcia_irqs cd_irq;
-
-		cd_irq.sock = skt->nr;
-		cd_irq.irq  = SCOOP_DEV[skt->nr].cd_irq;
-		cd_irq.str  = SCOOP_DEV[skt->nr].cd_irq_str;
-		ret = soc_pcmcia_request_irqs(skt, &cd_irq, 1);
-
-		if (ret) {
-			printk(KERN_ERR "Request for Compact Flash IRQ failed\n");
-			return ret;
-		}
+		skt->stat[SOC_STAT_CD].irq = SCOOP_DEV[skt->nr].cd_irq;
+		skt->stat[SOC_STAT_CD].name = SCOOP_DEV[skt->nr].cd_irq_str;
 	}
 
 	skt->socket.pci_irq = SCOOP_DEV[skt->nr].irq;
@@ -68,19 +56,6 @@ static int sharpsl_pcmcia_hw_init(struct soc_pcmcia_socket *skt)
 	return 0;
 }
 
-static void sharpsl_pcmcia_hw_shutdown(struct soc_pcmcia_socket *skt)
-{
-	if (SCOOP_DEV[skt->nr].cd_irq >= 0) {
-		struct pcmcia_irqs cd_irq;
-
-		cd_irq.sock = skt->nr;
-		cd_irq.irq  = SCOOP_DEV[skt->nr].cd_irq;
-		cd_irq.str  = SCOOP_DEV[skt->nr].cd_irq_str;
-		soc_pcmcia_free_irqs(skt, &cd_irq, 1);
-	}
-}
-
-
 static void sharpsl_pcmcia_socket_state(struct soc_pcmcia_socket *skt,
 				    struct pcmcia_state *state)
 {
@@ -222,7 +197,6 @@ static void sharpsl_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)
 static struct pcmcia_low_level sharpsl_pcmcia_ops __initdata = {
 	.owner                  = THIS_MODULE,
 	.hw_init                = sharpsl_pcmcia_hw_init,
-	.hw_shutdown            = sharpsl_pcmcia_hw_shutdown,
 	.socket_state           = sharpsl_pcmcia_socket_state,
 	.configure_socket       = sharpsl_pcmcia_configure_socket,
 	.socket_init            = sharpsl_pcmcia_socket_init,

commit b34e7b4f05730e6f26e9d8d3736271b0e4cdeac2
Author: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
Date:   Tue Jun 14 09:21:05 2011 +0400

    ARM: scoop: drop pcmcia_init callback
    
    A pcmcia_init callback isn't used on any of the platforms. Drop it.
    
    Signed-off-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Signed-off-by: Eric Miao <eric.y.miao@gmail.com>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index 81af2b3bcc00..69ae2fd22400 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -48,9 +48,6 @@ static int sharpsl_pcmcia_hw_init(struct soc_pcmcia_socket *skt)
 {
 	int ret;
 
-	if (platform_scoop_config->pcmcia_init)
-		platform_scoop_config->pcmcia_init();
-
 	/* Register interrupts */
 	if (SCOOP_DEV[skt->nr].cd_irq >= 0) {
 		struct pcmcia_irqs cd_irq;

commit 5b85e04e93f9a2963e88156cae8629ee72efd890
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu Nov 4 10:46:14 2010 +0100

    pcmcia/sa1100: don't put machine specific init functions in .init.text
    
    These are called by sa11x0_drv_pcmcia_probe (which is marked now with
    __devinit) so they can go to .devinit.text now, too.
    
    This fixes:
    
            WARNING: drivers/pcmcia/sa1100_cs.o(.text+0x10): Section mismatch in reference from the function sa11x0_drv_pcmcia_probe() to the function .init.text:pcmcia_simpad_init()
            The function sa11x0_drv_pcmcia_probe() references
            the function __init pcmcia_simpad_init().
            This is often because sa11x0_drv_pcmcia_probe lacks a __init
            annotation or the annotation of pcmcia_simpad_init is wrong.
    
    and a similar warning for pcmcia_collie_init, pcmcia_cerf_init,
    pcmcia_h3600_init and pcmcia_shannon_init.
    
    While at it mark pcmcia_assabet_init with __devinit, too.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    CC: Russell King <linux@arm.linux.org.uk>
    CC: Eric Miao <eric.y.miao@gmail.com>
    CC: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index 0ea3b29440e6..81af2b3bcc00 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -237,7 +237,7 @@ static struct pcmcia_low_level sharpsl_pcmcia_ops __initdata = {
 #ifdef CONFIG_SA1100_COLLIE
 #include "sa11xx_base.h"
 
-int __init pcmcia_collie_init(struct device *dev)
+int __devinit pcmcia_collie_init(struct device *dev)
 {
        int ret = -ENODEV;
 

commit 66024db57d5b9011e274b314affad68f370c0d6f
Author: Russell King - ARM Linux <linux@arm.linux.org.uk>
Date:   Sun Mar 29 22:45:26 2009 +0100

    PCMCIA: stop duplicating pci_irq in soc_pcmcia_socket
    
    skt->irq is a mere duplication of pcmcia_socket's pci_irq member.
    Get rid of it.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index bc43f78f6f0b..0ea3b29440e6 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -66,7 +66,7 @@ static int sharpsl_pcmcia_hw_init(struct soc_pcmcia_socket *skt)
 		}
 	}
 
-	skt->irq = SCOOP_DEV[skt->nr].irq;
+	skt->socket.pci_irq = SCOOP_DEV[skt->nr].irq;
 
 	return 0;
 }

commit ae1036a2f4e8f83b544ddce4f875a1e4e2ac7b62
Author: Dmitry Baryshkov <dbaryshkov@gmail.com>
Date:   Mon Apr 20 17:48:28 2009 +0100

    [ARM] 5458/1: pcmcia: pxa2xx-sharpsl: check if we do have Scoop config
    
    Check if we really have Scoop config, otherwice we can get a nice Oops
    during probe.
    
    Signed-off-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index 1cd02f5a23a0..bc43f78f6f0b 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -255,6 +255,9 @@ static int __init sharpsl_pcmcia_init(void)
 {
 	int ret;
 
+	if (!platform_scoop_config)
+		return -ENODEV;
+
 	sharpsl_pcmcia_ops.nr = platform_scoop_config->num_devs;
 	sharpsl_pcmcia_device = platform_device_alloc("pxa2xx-pcmcia", -1);
 

commit a09e64fbc0094e3073dbb09c3b4bfe4ab669244b
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Tue Aug 5 16:14:15 2008 +0100

    [ARM] Move include/asm-arm/arch-* to arch/arm/*/include/mach
    
    This just leaves include/asm-arm/plat-* to deal with.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index 58395bff9a72..1cd02f5a23a0 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -19,7 +19,7 @@
 #include <linux/platform_device.h>
 
 #include <asm/mach-types.h>
-#include <asm/arch/hardware.h>
+#include <mach/hardware.h>
 #include <asm/irq.h>
 #include <asm/hardware/scoop.h>
 

commit be509729356b7433f73df2b9a966674a437fbbc1
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Aug 4 10:41:28 2008 +0100

    [ARM] Remove asm/hardware.h, use asm/arch/hardware.h instead
    
    Remove includes of asm/hardware.h in addition to asm/arch/hardware.h.
    Then, since asm/hardware.h only exists to include asm/arch/hardware.h,
    update everything to directly include asm/arch/hardware.h and remove
    asm/hardware.h.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index d71f93d45833..58395bff9a72 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -19,7 +19,7 @@
 #include <linux/platform_device.h>
 
 #include <asm/mach-types.h>
-#include <asm/hardware.h>
+#include <asm/arch/hardware.h>
 #include <asm/irq.h>
 #include <asm/hardware/scoop.h>
 

commit 4e5e8de0dbdeb08df2b4c15fa2b0ba2216091793
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Apr 24 15:28:11 2008 +0100

    [ARM] pxa: avoid kfreeing static data if platform device fails to register
    
    When a dynamically allocated platform device is 'put', the platform
    device's platform_data is kfree'd.  This is bad if it's pointing at
    static data.  Use the provided function to register platform data
    for these devices.
    
    This also means we can mark the pcmcia ops structures as __initdata.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index d5c33bd78d68..d71f93d45833 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -222,7 +222,7 @@ static void sharpsl_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)
 	sharpsl_pcmcia_init_reset(skt);
 }
 
-static struct pcmcia_low_level sharpsl_pcmcia_ops = {
+static struct pcmcia_low_level sharpsl_pcmcia_ops __initdata = {
 	.owner                  = THIS_MODULE,
 	.hw_init                = sharpsl_pcmcia_hw_init,
 	.hw_shutdown            = sharpsl_pcmcia_hw_shutdown,
@@ -261,10 +261,12 @@ static int __init sharpsl_pcmcia_init(void)
 	if (!sharpsl_pcmcia_device)
 		return -ENOMEM;
 
-	sharpsl_pcmcia_device->dev.platform_data = &sharpsl_pcmcia_ops;
-	sharpsl_pcmcia_device->dev.parent = platform_scoop_config->devs[0].dev;
-
-	ret = platform_device_add(sharpsl_pcmcia_device);
+	ret = platform_device_add_data(sharpsl_pcmcia_device,
+			&sharpsl_pcmcia_ops, sizeof(sharpsl_pcmcia_ops));
+	if (ret == 0) {
+		sharpsl_pcmcia_device->dev.parent = platform_scoop_config->devs[0].dev;
+		ret = platform_device_add(sharpsl_pcmcia_device);
+	}
 
 	if (ret)
 		platform_device_put(sharpsl_pcmcia_device);

commit 43cc71eed1250755986da4c0f9898f9a635cb3bf
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sat Aug 18 04:40:39 2007 +0200

    platform: prefix MODALIAS with "platform:"
    
    Prefix platform modalias strings with "platform:", which
    modprobe config to blacklist alias resolving if userspace
    configures it.
    
    Send uevents for all platform devices.
    
    Add MODULE_ALIAS's to: pxa2xx_pcmcia, ds1742 and pcspkr to trigger
    module autoloading by userspace.
    
      $ modinfo pcspkr
      alias:          platform:pcspkr
      license:        GPL
      description:    PC Speaker beeper driver
      ...
    
      $ modprobe -n -v platform:pcspkr
      insmod /lib/modules/2.6.23-rc3-g28e8351a-dirty/kernel/drivers/input/misc/pcspkr.ko
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index a2daa3f531b2..d5c33bd78d68 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -261,7 +261,6 @@ static int __init sharpsl_pcmcia_init(void)
 	if (!sharpsl_pcmcia_device)
 		return -ENOMEM;
 
-	sharpsl_pcmcia_device->dev.uevent_suppress = 0;
 	sharpsl_pcmcia_device->dev.platform_data = &sharpsl_pcmcia_ops;
 	sharpsl_pcmcia_device->dev.parent = platform_scoop_config->devs[0].dev;
 
@@ -284,3 +283,4 @@ module_exit(sharpsl_pcmcia_exit);
 
 MODULE_DESCRIPTION("Sharp SL Series PCMCIA Support");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:pxa2xx-pcmcia");

commit 49a4ec188f9a96c9a5567956718213d38a456a19
Author: David Brownell <david-b@pacbell.net>
Date:   Tue May 8 00:29:39 2007 -0700

    fix hotplug for legacy platform drivers
    
    We've had various reports of some legacy "probe the hardware" style
    platform drivers having nasty problems with hotplug support.
    
    The core issue is that those legacy drivers don't fully conform to the
    driver model.  They assume a role that should be the responsibility of
    infrastructure code: creating device nodes.
    
    The "modprobe" step in hotplugging relies on drivers to have split those
    roles into different modules.  The lack of this split causes the problems.
    When a driver creates nodes for devices that don't exist (sending a hotplug
    event), then exits (aborting one modprobe) before the "modprobe $MODALIAS"
    step completes (by failing, since it's in the middle of a modprobe), the
    result can be an endless loop of modprobe invocations ...  badness.
    
    This fix uses the newish per-device flag controlling issuance of "add"
    events.  (A previous version of this patch used a per-device "driver can
    hotplug" flag, which only scrubbed $MODALIAS from the environment rather
    than suppressing the entire hotplug event.) It also shrinks that flag to
    one bit, saving a word in "struct device".
    
    So the net of this patch is removing some nasty failures with legacy
    drivers, while retaining hotplug capability for the majority of platform
    drivers.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Greg KH <gregkh@suse.de>
    Cc: Andres Salomon <dilinger@debian.org>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index b7b9e149c5b9..a2daa3f531b2 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -261,6 +261,7 @@ static int __init sharpsl_pcmcia_init(void)
 	if (!sharpsl_pcmcia_device)
 		return -ENOMEM;
 
+	sharpsl_pcmcia_device->dev.uevent_suppress = 0;
 	sharpsl_pcmcia_device->dev.platform_data = &sharpsl_pcmcia_ops;
 	sharpsl_pcmcia_device->dev.parent = platform_scoop_config->devs[0].dev;
 

commit 7ea3bbbc8997df1ae7dc4e736d163dabc00f4721
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Tue Apr 18 23:18:53 2006 +0100

    [ARM] 3478/1: SharpSL SCOOP: Fix potenial build failure
    
    Patch from Richard Purdie
    
    Move platform_scoop_config from the SharpSL scoop PCMCIA driver to
    the SCOOP driver. This avoids build failures when PCMCIA is not built
    or is modular (scoop.c itself cannot be modular).
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index fd3647368955..b7b9e149c5b9 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -26,14 +26,6 @@
 #include "soc_common.h"
 
 #define	NO_KEEP_VS 0x0001
-
-/* PCMCIA to Scoop linkage
-
-   There is no easy way to link multiple scoop devices into one
-   single entity for the pxa2xx_pcmcia device so this structure
-   is used which is setup by the platform code
-*/
-struct scoop_pcmcia_config *platform_scoop_config;
 #define SCOOP_DEV platform_scoop_config->devs
 
 static void sharpsl_pcmcia_init_reset(struct soc_pcmcia_socket *skt)

commit b016450f9f603210239e1a91e3c28f17c310dcc7
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Tue Jan 10 17:16:12 2006 +0000

    [ARM] 3250/1: Change pxa2xx PCMCIA drivers to use platform_device_alloc
    
    Patch from Richard Purdie
    
    Change mainstone and sharpsl pxa2xx pcmcia drivers to use
    platform_device_alloc which fixes a memory leak.
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index 12a7244a5ec8..fd3647368955 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -263,30 +263,25 @@ static int __init sharpsl_pcmcia_init(void)
 {
 	int ret;
 
-	sharpsl_pcmcia_ops.nr=platform_scoop_config->num_devs;
-	sharpsl_pcmcia_device = kzalloc(sizeof(*sharpsl_pcmcia_device), GFP_KERNEL);
+	sharpsl_pcmcia_ops.nr = platform_scoop_config->num_devs;
+	sharpsl_pcmcia_device = platform_device_alloc("pxa2xx-pcmcia", -1);
+
 	if (!sharpsl_pcmcia_device)
 		return -ENOMEM;
 
-	sharpsl_pcmcia_device->name = "pxa2xx-pcmcia";
 	sharpsl_pcmcia_device->dev.platform_data = &sharpsl_pcmcia_ops;
-	sharpsl_pcmcia_device->dev.parent=platform_scoop_config->devs[0].dev;
+	sharpsl_pcmcia_device->dev.parent = platform_scoop_config->devs[0].dev;
+
+	ret = platform_device_add(sharpsl_pcmcia_device);
 
-	ret = platform_device_register(sharpsl_pcmcia_device);
 	if (ret)
-		kfree(sharpsl_pcmcia_device);
+		platform_device_put(sharpsl_pcmcia_device);
 
 	return ret;
 }
 
 static void __exit sharpsl_pcmcia_exit(void)
 {
-	/*
-	 * This call is supposed to free our sharpsl_pcmcia_device.
-	 * Unfortunately platform_device don't have a free method, and
-	 * we can't assume it's free of any reference at this point so we
-	 * can't free it either.
-	 */
 	platform_device_unregister(sharpsl_pcmcia_device);
 }
 

commit 123656d4cc8c946f578ebd18c2050f5251720428
Merge: a62c80e55980 0aec63e67c69
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Jan 7 14:40:05 2006 +0000

    Merge with Linus' kernel.

commit 8084b372adac9c24ff7abdd939b2e8816e7b88a3
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Sun Dec 11 21:18:26 2005 +0100

    [PATCH] pcmcia: kzalloc conversion
    
    Convert users of kmalloc and memset to kzalloc
    
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index 56c58831e80e..b5fdeec20b15 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -264,11 +264,10 @@ static int __init sharpsl_pcmcia_init(void)
 	int ret;
 
 	sharpsl_pcmcia_ops.nr=platform_scoop_config->num_devs;
-	sharpsl_pcmcia_device = kmalloc(sizeof(*sharpsl_pcmcia_device), GFP_KERNEL);
+	sharpsl_pcmcia_device = kzalloc(sizeof(*sharpsl_pcmcia_device), GFP_KERNEL);
 	if (!sharpsl_pcmcia_device)
 		return -ENOMEM;
 
-	memset(sharpsl_pcmcia_device, 0, sizeof(*sharpsl_pcmcia_device));
 	sharpsl_pcmcia_device->name = "pxa2xx-pcmcia";
 	sharpsl_pcmcia_device->dev.platform_data = &sharpsl_pcmcia_ops;
 	sharpsl_pcmcia_device->dev.parent=platform_scoop_config->devs[0].dev;

commit 945b957972844881002ab4f68534581f4427a30b
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Thu Jan 5 20:44:57 2006 +0000

    [ARM] 3230/1: Sharp Scoop: Fix Shared Power Control Issues
    
    Patch from Richard Purdie
    
    The SL-Cxx00 devices have a power control register in SCOOP that is
    shared by both CF and MMC/SD card slots. The CF reset code was resetting
    this register leading to various lockups as the MMC power was suddenly
    lost. This patch handles the CPR register in a more sensitive manner.
    
    It also removes some unneeded collie specific calls as the reset code
    handles this.
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index 56c58831e80e..4fbd995360b0 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -36,9 +36,18 @@
 struct scoop_pcmcia_config *platform_scoop_config;
 #define SCOOP_DEV platform_scoop_config->devs
 
-static void sharpsl_pcmcia_init_reset(struct scoop_pcmcia_dev *scoopdev)
+static void sharpsl_pcmcia_init_reset(struct soc_pcmcia_socket *skt)
 {
+	struct scoop_pcmcia_dev *scoopdev = &SCOOP_DEV[skt->nr];
+
 	reset_scoop(scoopdev->dev);
+
+	/* Shared power controls need to be handled carefully */
+	if (platform_scoop_config->power_ctrl)
+		platform_scoop_config->power_ctrl(scoopdev->dev, 0x0000, skt->nr);
+	else
+		write_scoop_reg(scoopdev->dev, SCOOP_CPR, 0x0000);
+
 	scoopdev->keep_vs = NO_KEEP_VS;
 	scoopdev->keep_rd = 0;
 }
@@ -208,26 +217,17 @@ static int sharpsl_pcmcia_configure_socket(struct soc_pcmcia_socket *skt,
 
 static void sharpsl_pcmcia_socket_init(struct soc_pcmcia_socket *skt)
 {
-	sharpsl_pcmcia_init_reset(&SCOOP_DEV[skt->nr]);
+	sharpsl_pcmcia_init_reset(skt);
 
 	/* Enable interrupt */
 	write_scoop_reg(SCOOP_DEV[skt->nr].dev, SCOOP_IMR, 0x00C0);
 	write_scoop_reg(SCOOP_DEV[skt->nr].dev, SCOOP_MCR, 0x0101);
 	SCOOP_DEV[skt->nr].keep_vs = NO_KEEP_VS;
-
-	if (machine_is_collie())
-		/* We need to disable SS_OUTPUT_ENA here. */
-		write_scoop_reg(SCOOP_DEV[skt->nr].dev, SCOOP_CPR, read_scoop_reg(SCOOP_DEV[skt->nr].dev, SCOOP_CPR) & ~0x0080);
 }
 
 static void sharpsl_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)
 {
-	/* CF_BUS_OFF */
-	sharpsl_pcmcia_init_reset(&SCOOP_DEV[skt->nr]);
-
-	if (machine_is_collie())
-		/* We need to disable SS_OUTPUT_ENA here. */
-		write_scoop_reg(SCOOP_DEV[skt->nr].dev, SCOOP_CPR, read_scoop_reg(SCOOP_DEV[skt->nr].dev, SCOOP_CPR) & ~0x0080);
+	sharpsl_pcmcia_init_reset(skt);
 }
 
 static struct pcmcia_low_level sharpsl_pcmcia_ops = {

commit a63ae4427c6af66d6eda26e5da8fed53f8fbede3
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Tue Nov 8 19:15:43 2005 +0000

    [ARM] 3093/1: SharpSL PCMCIA Updates for Cxx00 models
    
    Patch from Richard Purdie
    
    The Sharp SL-Cxx00 models have a combined power control for the SD
    and CF slot 0. This patch adds hooks to the scoop driver to allow
    machines to provide a custom control function for this and such a
    function is added for spitz/akita/borzoi.
    
    It also moves the gpio init code into the machine files as this
    is machine dependent and differs between some models. A couple of
    warnings when compiling for collie are also fixed.
    
    Signed-off-by: Richard Purdie
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index fe5ea36e7de3..56c58831e80e 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -22,16 +22,20 @@
 #include <asm/hardware.h>
 #include <asm/irq.h>
 #include <asm/hardware/scoop.h>
-#ifdef CONFIG_SA1100_COLLIE
-#include <asm/arch-sa1100/collie.h>
-#else
-#include <asm/arch-pxa/pxa-regs.h>
-#endif
 
 #include "soc_common.h"
 
 #define	NO_KEEP_VS 0x0001
 
+/* PCMCIA to Scoop linkage
+
+   There is no easy way to link multiple scoop devices into one
+   single entity for the pxa2xx_pcmcia device so this structure
+   is used which is setup by the platform code
+*/
+struct scoop_pcmcia_config *platform_scoop_config;
+#define SCOOP_DEV platform_scoop_config->devs
+
 static void sharpsl_pcmcia_init_reset(struct scoop_pcmcia_dev *scoopdev)
 {
 	reset_scoop(scoopdev->dev);
@@ -43,38 +47,16 @@ static int sharpsl_pcmcia_hw_init(struct soc_pcmcia_socket *skt)
 {
 	int ret;
 
-#ifndef CONFIG_SA1100_COLLIE
-	/*
-	 * Setup default state of GPIO outputs
-	 * before we enable them as outputs.
-	 */
-	GPSR(GPIO48_nPOE) =
-		GPIO_bit(GPIO48_nPOE) |
-		GPIO_bit(GPIO49_nPWE) |
-		GPIO_bit(GPIO50_nPIOR) |
-		GPIO_bit(GPIO51_nPIOW) |
-		GPIO_bit(GPIO52_nPCE_1) |
-		GPIO_bit(GPIO53_nPCE_2);
-
-	pxa_gpio_mode(GPIO48_nPOE_MD);
-	pxa_gpio_mode(GPIO49_nPWE_MD);
-	pxa_gpio_mode(GPIO50_nPIOR_MD);
-	pxa_gpio_mode(GPIO51_nPIOW_MD);
-	pxa_gpio_mode(GPIO52_nPCE_1_MD);
-	pxa_gpio_mode(GPIO53_nPCE_2_MD);
-	pxa_gpio_mode(GPIO54_pSKTSEL_MD);
-	pxa_gpio_mode(GPIO55_nPREG_MD);
-	pxa_gpio_mode(GPIO56_nPWAIT_MD);
-	pxa_gpio_mode(GPIO57_nIOIS16_MD);
-#endif
+	if (platform_scoop_config->pcmcia_init)
+		platform_scoop_config->pcmcia_init();
 
 	/* Register interrupts */
-	if (scoop_devs[skt->nr].cd_irq >= 0) {
+	if (SCOOP_DEV[skt->nr].cd_irq >= 0) {
 		struct pcmcia_irqs cd_irq;
 
 		cd_irq.sock = skt->nr;
-		cd_irq.irq  = scoop_devs[skt->nr].cd_irq;
-		cd_irq.str  = scoop_devs[skt->nr].cd_irq_str;
+		cd_irq.irq  = SCOOP_DEV[skt->nr].cd_irq;
+		cd_irq.str  = SCOOP_DEV[skt->nr].cd_irq_str;
 		ret = soc_pcmcia_request_irqs(skt, &cd_irq, 1);
 
 		if (ret) {
@@ -83,19 +65,19 @@ static int sharpsl_pcmcia_hw_init(struct soc_pcmcia_socket *skt)
 		}
 	}
 
-	skt->irq = scoop_devs[skt->nr].irq;
+	skt->irq = SCOOP_DEV[skt->nr].irq;
 
 	return 0;
 }
 
 static void sharpsl_pcmcia_hw_shutdown(struct soc_pcmcia_socket *skt)
 {
-	if (scoop_devs[skt->nr].cd_irq >= 0) {
+	if (SCOOP_DEV[skt->nr].cd_irq >= 0) {
 		struct pcmcia_irqs cd_irq;
 
 		cd_irq.sock = skt->nr;
-		cd_irq.irq  = scoop_devs[skt->nr].cd_irq;
-		cd_irq.str  = scoop_devs[skt->nr].cd_irq_str;
+		cd_irq.irq  = SCOOP_DEV[skt->nr].cd_irq;
+		cd_irq.str  = SCOOP_DEV[skt->nr].cd_irq_str;
 		soc_pcmcia_free_irqs(skt, &cd_irq, 1);
 	}
 }
@@ -105,9 +87,9 @@ static void sharpsl_pcmcia_socket_state(struct soc_pcmcia_socket *skt,
 				    struct pcmcia_state *state)
 {
 	unsigned short cpr, csr;
-	struct device *scoop = scoop_devs[skt->nr].dev;
+	struct device *scoop = SCOOP_DEV[skt->nr].dev;
 
-	cpr = read_scoop_reg(scoop_devs[skt->nr].dev, SCOOP_CPR);
+	cpr = read_scoop_reg(SCOOP_DEV[skt->nr].dev, SCOOP_CPR);
 
 	write_scoop_reg(scoop, SCOOP_IRM, 0x00FF);
 	write_scoop_reg(scoop, SCOOP_ISR, 0x0000);
@@ -116,21 +98,25 @@ static void sharpsl_pcmcia_socket_state(struct soc_pcmcia_socket *skt,
 	if (csr & 0x0004) {
 		/* card eject */
 		write_scoop_reg(scoop, SCOOP_CDR, 0x0000);
-		scoop_devs[skt->nr].keep_vs = NO_KEEP_VS;
+		SCOOP_DEV[skt->nr].keep_vs = NO_KEEP_VS;
 	}
-	else if (!(scoop_devs[skt->nr].keep_vs & NO_KEEP_VS)) {
+	else if (!(SCOOP_DEV[skt->nr].keep_vs & NO_KEEP_VS)) {
 		/* keep vs1,vs2 */
 		write_scoop_reg(scoop, SCOOP_CDR, 0x0000);
-		csr |= scoop_devs[skt->nr].keep_vs;
+		csr |= SCOOP_DEV[skt->nr].keep_vs;
 	}
 	else if (cpr & 0x0003) {
 		/* power on */
 		write_scoop_reg(scoop, SCOOP_CDR, 0x0000);
-		scoop_devs[skt->nr].keep_vs = (csr & 0x00C0);
+		SCOOP_DEV[skt->nr].keep_vs = (csr & 0x00C0);
 	}
 	else {
 		/* card detect */
-		write_scoop_reg(scoop, SCOOP_CDR, 0x0002);
+	        if ((machine_is_spitz() || machine_is_borzoi()) && skt->nr == 1) {
+	                write_scoop_reg(scoop, SCOOP_CDR, 0x0000);
+	        } else {
+		        write_scoop_reg(scoop, SCOOP_CDR, 0x0002);
+	        }
 	}
 
 	state->detect = (csr & 0x0004) ? 0 : 1;
@@ -144,7 +130,6 @@ static void sharpsl_pcmcia_socket_state(struct soc_pcmcia_socket *skt,
 	if ((cpr & 0x0080) && ((cpr & 0x8040) != 0x8040)) {
 		printk(KERN_ERR "sharpsl_pcmcia_socket_state(): CPR=%04X, Low voltage!\n", cpr);
 	}
-
 }
 
 
@@ -152,7 +137,7 @@ static int sharpsl_pcmcia_configure_socket(struct soc_pcmcia_socket *skt,
 				       const socket_state_t *state)
 {
 	unsigned long flags;
-	struct device *scoop = scoop_devs[skt->nr].dev;
+	struct device *scoop = SCOOP_DEV[skt->nr].dev;
 
 	unsigned short cpr, ncpr, ccr, nccr, mcr, nmcr, imr, nimr;
 
@@ -177,8 +162,13 @@ static int sharpsl_pcmcia_configure_socket(struct soc_pcmcia_socket *skt,
 	nccr = (ccr = read_scoop_reg(scoop, SCOOP_CCR)) & ~0x0080;
 	nimr = (imr = read_scoop_reg(scoop, SCOOP_IMR)) & ~0x003E;
 
-	ncpr |= (state->Vcc == 33) ? 0x0001 :
-				(state->Vcc == 50) ? 0x0002 : 0;
+	if ((machine_is_spitz() || machine_is_borzoi() || machine_is_akita()) && skt->nr == 0) {
+	        ncpr |= (state->Vcc == 33) ? 0x0002 :
+		        (state->Vcc == 50) ? 0x0002 : 0;
+	} else {
+	        ncpr |= (state->Vcc == 33) ? 0x0001 :
+		        (state->Vcc == 50) ? 0x0002 : 0;
+	}
 	nmcr |= (state->flags&SS_IOCARD) ? 0x0010 : 0;
 	ncpr |= (state->flags&SS_OUTPUT_ENA) ? 0x0080 : 0;
 	nccr |= (state->flags&SS_RESET)? 0x0080: 0;
@@ -190,18 +180,22 @@ static int sharpsl_pcmcia_configure_socket(struct soc_pcmcia_socket *skt,
 			((skt->status&SS_WRPROT) ? 0x0008 : 0);
 
 	if (!(ncpr & 0x0003)) {
-		scoop_devs[skt->nr].keep_rd = 0;
-	} else if (!scoop_devs[skt->nr].keep_rd) {
+		SCOOP_DEV[skt->nr].keep_rd = 0;
+	} else if (!SCOOP_DEV[skt->nr].keep_rd) {
 		if (nccr & 0x0080)
-			scoop_devs[skt->nr].keep_rd = 1;
+			SCOOP_DEV[skt->nr].keep_rd = 1;
 		else
 			nccr |= 0x0080;
 	}
 
 	if (mcr != nmcr)
 		write_scoop_reg(scoop, SCOOP_MCR, nmcr);
-	if (cpr != ncpr)
-		write_scoop_reg(scoop, SCOOP_CPR, ncpr);
+	if (cpr != ncpr) {
+		if (platform_scoop_config->power_ctrl)
+			platform_scoop_config->power_ctrl(scoop, ncpr , skt->nr);
+		else
+		        write_scoop_reg(scoop, SCOOP_CPR, ncpr);
+	}
 	if (ccr != nccr)
 		write_scoop_reg(scoop, SCOOP_CCR, nccr);
 	if (imr != nimr)
@@ -214,43 +208,43 @@ static int sharpsl_pcmcia_configure_socket(struct soc_pcmcia_socket *skt,
 
 static void sharpsl_pcmcia_socket_init(struct soc_pcmcia_socket *skt)
 {
-	sharpsl_pcmcia_init_reset(&scoop_devs[skt->nr]);
+	sharpsl_pcmcia_init_reset(&SCOOP_DEV[skt->nr]);
 
 	/* Enable interrupt */
-	write_scoop_reg(scoop_devs[skt->nr].dev, SCOOP_IMR, 0x00C0);
-	write_scoop_reg(scoop_devs[skt->nr].dev, SCOOP_MCR, 0x0101);
-	scoop_devs[skt->nr].keep_vs = NO_KEEP_VS;
+	write_scoop_reg(SCOOP_DEV[skt->nr].dev, SCOOP_IMR, 0x00C0);
+	write_scoop_reg(SCOOP_DEV[skt->nr].dev, SCOOP_MCR, 0x0101);
+	SCOOP_DEV[skt->nr].keep_vs = NO_KEEP_VS;
 
 	if (machine_is_collie())
 		/* We need to disable SS_OUTPUT_ENA here. */
-		write_scoop_reg(scoop_devs[skt->nr].dev, SCOOP_CPR, read_scoop_reg(scoop_devs[skt->nr].dev, SCOOP_CPR) & ~0x0080);
+		write_scoop_reg(SCOOP_DEV[skt->nr].dev, SCOOP_CPR, read_scoop_reg(SCOOP_DEV[skt->nr].dev, SCOOP_CPR) & ~0x0080);
 }
 
 static void sharpsl_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)
 {
 	/* CF_BUS_OFF */
-	sharpsl_pcmcia_init_reset(&scoop_devs[skt->nr]);
+	sharpsl_pcmcia_init_reset(&SCOOP_DEV[skt->nr]);
 
 	if (machine_is_collie())
 		/* We need to disable SS_OUTPUT_ENA here. */
-		write_scoop_reg(scoop_devs[skt->nr].dev, SCOOP_CPR, read_scoop_reg(scoop_devs[skt->nr].dev, SCOOP_CPR) & ~0x0080);
+		write_scoop_reg(SCOOP_DEV[skt->nr].dev, SCOOP_CPR, read_scoop_reg(SCOOP_DEV[skt->nr].dev, SCOOP_CPR) & ~0x0080);
 }
 
 static struct pcmcia_low_level sharpsl_pcmcia_ops = {
-	.owner				= THIS_MODULE,
-	.hw_init			= sharpsl_pcmcia_hw_init,
-	.hw_shutdown		= sharpsl_pcmcia_hw_shutdown,
-	.socket_state		= sharpsl_pcmcia_socket_state,
-	.configure_socket	= sharpsl_pcmcia_configure_socket,
-	.socket_init		= sharpsl_pcmcia_socket_init,
-	.socket_suspend		= sharpsl_pcmcia_socket_suspend,
-	.first				= 0,
-	.nr					= 0,
+	.owner                  = THIS_MODULE,
+	.hw_init                = sharpsl_pcmcia_hw_init,
+	.hw_shutdown            = sharpsl_pcmcia_hw_shutdown,
+	.socket_state           = sharpsl_pcmcia_socket_state,
+	.configure_socket       = sharpsl_pcmcia_configure_socket,
+	.socket_init            = sharpsl_pcmcia_socket_init,
+	.socket_suspend         = sharpsl_pcmcia_socket_suspend,
+	.first                  = 0,
+	.nr                     = 0,
 };
 
-static struct platform_device *sharpsl_pcmcia_device;
-
 #ifdef CONFIG_SA1100_COLLIE
+#include "sa11xx_base.h"
+
 int __init pcmcia_collie_init(struct device *dev)
 {
        int ret = -ENODEV;
@@ -263,11 +257,13 @@ int __init pcmcia_collie_init(struct device *dev)
 
 #else
 
+static struct platform_device *sharpsl_pcmcia_device;
+
 static int __init sharpsl_pcmcia_init(void)
 {
 	int ret;
 
-	sharpsl_pcmcia_ops.nr=scoop_num;
+	sharpsl_pcmcia_ops.nr=platform_scoop_config->num_devs;
 	sharpsl_pcmcia_device = kmalloc(sizeof(*sharpsl_pcmcia_device), GFP_KERNEL);
 	if (!sharpsl_pcmcia_device)
 		return -ENOMEM;
@@ -275,7 +271,7 @@ static int __init sharpsl_pcmcia_init(void)
 	memset(sharpsl_pcmcia_device, 0, sizeof(*sharpsl_pcmcia_device));
 	sharpsl_pcmcia_device->name = "pxa2xx-pcmcia";
 	sharpsl_pcmcia_device->dev.platform_data = &sharpsl_pcmcia_ops;
-	sharpsl_pcmcia_device->dev.parent=scoop_devs[0].dev;
+	sharpsl_pcmcia_device->dev.parent=platform_scoop_config->devs[0].dev;
 
 	ret = platform_device_register(sharpsl_pcmcia_device);
 	if (ret)

commit 4fd5f8267dd37aaebadfabe71d9c808821eea05a
Merge: eb16292ba8a6 8576762ff5d1
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Mon Oct 31 07:32:56 2005 -0800

    Merge master.kernel.org:/home/rmk/linux-2.6-drvmodel
    
    Manual #include fixups for clashes - there may be some unnecessary

commit 77bb86a1b9f8b872d8efc33c4f4359f809220252
Author: Pavel Machek <pavel@ucw.cz>
Date:   Sun Oct 30 23:39:02 2005 +0000

    [ARM] Support pcmcia slot on sharp sl-5500
    
    This adds support for pcmcia slot on sharp zaurus sl-5500.
    pxa2xx_sharpsl.c thus becomes quite miss-named, but I guess that
    is not worth fixing?
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index a1178a600e3c..bd924336a49f 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -18,10 +18,15 @@
 #include <linux/interrupt.h>
 #include <linux/device.h>
 
+#include <asm/mach-types.h>
 #include <asm/hardware.h>
 #include <asm/irq.h>
 #include <asm/hardware/scoop.h>
-#include <asm/arch/pxa-regs.h>
+#ifdef CONFIG_SA1100_COLLIE
+#include <asm/arch-sa1100/collie.h>
+#else
+#include <asm/arch-pxa/pxa-regs.h>
+#endif
 
 #include "soc_common.h"
 
@@ -38,6 +43,7 @@ static int sharpsl_pcmcia_hw_init(struct soc_pcmcia_socket *skt)
 {
 	int ret;
 
+#ifndef CONFIG_SA1100_COLLIE
 	/*
 	 * Setup default state of GPIO outputs
 	 * before we enable them as outputs.
@@ -60,6 +66,7 @@ static int sharpsl_pcmcia_hw_init(struct soc_pcmcia_socket *skt)
 	pxa_gpio_mode(GPIO55_nPREG_MD);
 	pxa_gpio_mode(GPIO56_nPWAIT_MD);
 	pxa_gpio_mode(GPIO57_nIOIS16_MD);
+#endif
 
 	/* Register interrupts */
 	if (scoop_devs[skt->nr].cd_irq >= 0) {
@@ -213,12 +220,20 @@ static void sharpsl_pcmcia_socket_init(struct soc_pcmcia_socket *skt)
 	write_scoop_reg(scoop_devs[skt->nr].dev, SCOOP_IMR, 0x00C0);
 	write_scoop_reg(scoop_devs[skt->nr].dev, SCOOP_MCR, 0x0101);
 	scoop_devs[skt->nr].keep_vs = NO_KEEP_VS;
+
+	if (machine_is_collie())
+		/* We need to disable SS_OUTPUT_ENA here. */
+		write_scoop_reg(scoop_devs[skt->nr].dev, SCOOP_CPR, read_scoop_reg(scoop_devs[skt->nr].dev, SCOOP_CPR) & ~0x0080);
 }
 
 static void sharpsl_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)
 {
 	/* CF_BUS_OFF */
 	sharpsl_pcmcia_init_reset(&scoop_devs[skt->nr]);
+
+	if (machine_is_collie())
+		/* We need to disable SS_OUTPUT_ENA here. */
+		write_scoop_reg(scoop_devs[skt->nr].dev, SCOOP_CPR, read_scoop_reg(scoop_devs[skt->nr].dev, SCOOP_CPR) & ~0x0080);
 }
 
 static struct pcmcia_low_level sharpsl_pcmcia_ops = {
@@ -235,6 +250,19 @@ static struct pcmcia_low_level sharpsl_pcmcia_ops = {
 
 static struct platform_device *sharpsl_pcmcia_device;
 
+#ifdef CONFIG_SA1100_COLLIE
+int __init pcmcia_collie_init(struct device *dev)
+{
+       int ret = -ENODEV;
+
+       if (machine_is_collie())
+               ret = sa11xx_drv_pcmcia_probe(dev, &sharpsl_pcmcia_ops, 0, 1);
+
+       return ret;
+}
+
+#else
+
 static int __init sharpsl_pcmcia_init(void)
 {
 	int ret;
@@ -269,6 +297,7 @@ static void __exit sharpsl_pcmcia_exit(void)
 
 fs_initcall(sharpsl_pcmcia_init);
 module_exit(sharpsl_pcmcia_exit);
+#endif
 
 MODULE_DESCRIPTION("Sharp SL Series PCMCIA Support");
 MODULE_LICENSE("GPL");

commit d052d1beff706920e82c5d55006b08e256b5df09
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Oct 29 19:07:23 2005 +0100

    Create platform_device.h to contain all the platform device details.
    Convert everyone who uses platform_bus_type to include
    linux/platform_device.h.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index a1178a600e3c..b54a8b8c0fca 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -16,7 +16,7 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/interrupt.h>
-#include <linux/device.h>
+#include <linux/platform_device.h>
 
 #include <asm/hardware.h>
 #include <asm/irq.h>

commit 0ce7625f3c1e3f921f6b83f7e944e00031a39dfa
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Mon Sep 5 20:49:54 2005 +0100

    [ARM] 2882/1: pxa2xx_sharpsl: Update PCMCIA driver to support variety of new hardware
    
    Patch from Richard Purdie
    
    This patch updates the PCMCIA pxa2xx_sharpsl driver to support multiple scoop
    devices by adding a scoop to pcmcia slot mapping structure. It adds platform
    support for poodle, is known to work on spitz (which is dual slot) and
    should also support collie with a minor amount of further work.
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index 7bac2f7d8b3f..a1178a600e3c 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -20,27 +20,18 @@
 
 #include <asm/hardware.h>
 #include <asm/irq.h>
-
 #include <asm/hardware/scoop.h>
-#include <asm/arch/corgi.h>
 #include <asm/arch/pxa-regs.h>
 
 #include "soc_common.h"
 
 #define	NO_KEEP_VS 0x0001
 
-static unsigned char keep_vs;
-static unsigned char keep_rd;
-
-static struct pcmcia_irqs irqs[] = {
-	{ 0, CORGI_IRQ_GPIO_CF_CD, "PCMCIA0 CD"},
-};
-
-static void sharpsl_pcmcia_init_reset(void)
+static void sharpsl_pcmcia_init_reset(struct scoop_pcmcia_dev *scoopdev)
 {
-	reset_scoop(&corgiscoop_device.dev);
-	keep_vs = NO_KEEP_VS;
-	keep_rd = 0;
+	reset_scoop(scoopdev->dev);
+	scoopdev->keep_vs = NO_KEEP_VS;
+	scoopdev->keep_rd = 0;
 }
 
 static int sharpsl_pcmcia_hw_init(struct soc_pcmcia_socket *skt)
@@ -71,29 +62,35 @@ static int sharpsl_pcmcia_hw_init(struct soc_pcmcia_socket *skt)
 	pxa_gpio_mode(GPIO57_nIOIS16_MD);
 
 	/* Register interrupts */
-	ret = soc_pcmcia_request_irqs(skt, irqs, ARRAY_SIZE(irqs));
-
-	if (ret) {
-		printk(KERN_ERR "Request for Compact Flash IRQ failed\n");
-		return ret;
+	if (scoop_devs[skt->nr].cd_irq >= 0) {
+		struct pcmcia_irqs cd_irq;
+
+		cd_irq.sock = skt->nr;
+		cd_irq.irq  = scoop_devs[skt->nr].cd_irq;
+		cd_irq.str  = scoop_devs[skt->nr].cd_irq_str;
+		ret = soc_pcmcia_request_irqs(skt, &cd_irq, 1);
+
+		if (ret) {
+			printk(KERN_ERR "Request for Compact Flash IRQ failed\n");
+			return ret;
+		}
 	}
 
-	/* Enable interrupt */
-	write_scoop_reg(&corgiscoop_device.dev, SCOOP_IMR, 0x00C0);
-	write_scoop_reg(&corgiscoop_device.dev, SCOOP_MCR, 0x0101);
-	keep_vs = NO_KEEP_VS;
-
-	skt->irq = CORGI_IRQ_GPIO_CF_IRQ;
+	skt->irq = scoop_devs[skt->nr].irq;
 
 	return 0;
 }
 
 static void sharpsl_pcmcia_hw_shutdown(struct soc_pcmcia_socket *skt)
 {
-	soc_pcmcia_free_irqs(skt, irqs, ARRAY_SIZE(irqs));
+	if (scoop_devs[skt->nr].cd_irq >= 0) {
+		struct pcmcia_irqs cd_irq;
 
-	/* CF_BUS_OFF */
-	sharpsl_pcmcia_init_reset();
+		cd_irq.sock = skt->nr;
+		cd_irq.irq  = scoop_devs[skt->nr].cd_irq;
+		cd_irq.str  = scoop_devs[skt->nr].cd_irq_str;
+		soc_pcmcia_free_irqs(skt, &cd_irq, 1);
+	}
 }
 
 
@@ -101,31 +98,32 @@ static void sharpsl_pcmcia_socket_state(struct soc_pcmcia_socket *skt,
 				    struct pcmcia_state *state)
 {
 	unsigned short cpr, csr;
+	struct device *scoop = scoop_devs[skt->nr].dev;
 
-	cpr = read_scoop_reg(&corgiscoop_device.dev, SCOOP_CPR);
+	cpr = read_scoop_reg(scoop_devs[skt->nr].dev, SCOOP_CPR);
 
-	write_scoop_reg(&corgiscoop_device.dev, SCOOP_IRM, 0x00FF);
-	write_scoop_reg(&corgiscoop_device.dev, SCOOP_ISR, 0x0000);
-	write_scoop_reg(&corgiscoop_device.dev, SCOOP_IRM, 0x0000);
-	csr = read_scoop_reg(&corgiscoop_device.dev, SCOOP_CSR);
+	write_scoop_reg(scoop, SCOOP_IRM, 0x00FF);
+	write_scoop_reg(scoop, SCOOP_ISR, 0x0000);
+	write_scoop_reg(scoop, SCOOP_IRM, 0x0000);
+	csr = read_scoop_reg(scoop, SCOOP_CSR);
 	if (csr & 0x0004) {
 		/* card eject */
-		write_scoop_reg(&corgiscoop_device.dev, SCOOP_CDR, 0x0000);
-		keep_vs = NO_KEEP_VS;
+		write_scoop_reg(scoop, SCOOP_CDR, 0x0000);
+		scoop_devs[skt->nr].keep_vs = NO_KEEP_VS;
 	}
-	else if (!(keep_vs & NO_KEEP_VS)) {
+	else if (!(scoop_devs[skt->nr].keep_vs & NO_KEEP_VS)) {
 		/* keep vs1,vs2 */
-		write_scoop_reg(&corgiscoop_device.dev, SCOOP_CDR, 0x0000);
-		csr |= keep_vs;
+		write_scoop_reg(scoop, SCOOP_CDR, 0x0000);
+		csr |= scoop_devs[skt->nr].keep_vs;
 	}
 	else if (cpr & 0x0003) {
 		/* power on */
-		write_scoop_reg(&corgiscoop_device.dev, SCOOP_CDR, 0x0000);
-		keep_vs = (csr & 0x00C0);
+		write_scoop_reg(scoop, SCOOP_CDR, 0x0000);
+		scoop_devs[skt->nr].keep_vs = (csr & 0x00C0);
 	}
 	else {
 		/* card detect */
-		write_scoop_reg(&corgiscoop_device.dev, SCOOP_CDR, 0x0002);
+		write_scoop_reg(scoop, SCOOP_CDR, 0x0002);
 	}
 
 	state->detect = (csr & 0x0004) ? 0 : 1;
@@ -147,6 +145,7 @@ static int sharpsl_pcmcia_configure_socket(struct soc_pcmcia_socket *skt,
 				       const socket_state_t *state)
 {
 	unsigned long flags;
+	struct device *scoop = scoop_devs[skt->nr].dev;
 
 	unsigned short cpr, ncpr, ccr, nccr, mcr, nmcr, imr, nimr;
 
@@ -166,10 +165,10 @@ static int sharpsl_pcmcia_configure_socket(struct soc_pcmcia_socket *skt,
 
 	local_irq_save(flags);
 
-	nmcr = (mcr = read_scoop_reg(&corgiscoop_device.dev, SCOOP_MCR)) & ~0x0010;
-	ncpr = (cpr = read_scoop_reg(&corgiscoop_device.dev, SCOOP_CPR)) & ~0x0083;
-	nccr = (ccr = read_scoop_reg(&corgiscoop_device.dev, SCOOP_CCR)) & ~0x0080;
-	nimr = (imr = read_scoop_reg(&corgiscoop_device.dev, SCOOP_IMR)) & ~0x003E;
+	nmcr = (mcr = read_scoop_reg(scoop, SCOOP_MCR)) & ~0x0010;
+	ncpr = (cpr = read_scoop_reg(scoop, SCOOP_CPR)) & ~0x0083;
+	nccr = (ccr = read_scoop_reg(scoop, SCOOP_CCR)) & ~0x0080;
+	nimr = (imr = read_scoop_reg(scoop, SCOOP_IMR)) & ~0x003E;
 
 	ncpr |= (state->Vcc == 33) ? 0x0001 :
 				(state->Vcc == 50) ? 0x0002 : 0;
@@ -184,22 +183,22 @@ static int sharpsl_pcmcia_configure_socket(struct soc_pcmcia_socket *skt,
 			((skt->status&SS_WRPROT) ? 0x0008 : 0);
 
 	if (!(ncpr & 0x0003)) {
-		keep_rd = 0;
-	} else if (!keep_rd) {
+		scoop_devs[skt->nr].keep_rd = 0;
+	} else if (!scoop_devs[skt->nr].keep_rd) {
 		if (nccr & 0x0080)
-			keep_rd = 1;
+			scoop_devs[skt->nr].keep_rd = 1;
 		else
 			nccr |= 0x0080;
 	}
 
 	if (mcr != nmcr)
-		write_scoop_reg(&corgiscoop_device.dev, SCOOP_MCR, nmcr);
+		write_scoop_reg(scoop, SCOOP_MCR, nmcr);
 	if (cpr != ncpr)
-		write_scoop_reg(&corgiscoop_device.dev, SCOOP_CPR, ncpr);
+		write_scoop_reg(scoop, SCOOP_CPR, ncpr);
 	if (ccr != nccr)
-		write_scoop_reg(&corgiscoop_device.dev, SCOOP_CCR, nccr);
+		write_scoop_reg(scoop, SCOOP_CCR, nccr);
 	if (imr != nimr)
-		write_scoop_reg(&corgiscoop_device.dev, SCOOP_IMR, nimr);
+		write_scoop_reg(scoop, SCOOP_IMR, nimr);
 
 	local_irq_restore(flags);
 
@@ -208,10 +207,18 @@ static int sharpsl_pcmcia_configure_socket(struct soc_pcmcia_socket *skt,
 
 static void sharpsl_pcmcia_socket_init(struct soc_pcmcia_socket *skt)
 {
+	sharpsl_pcmcia_init_reset(&scoop_devs[skt->nr]);
+
+	/* Enable interrupt */
+	write_scoop_reg(scoop_devs[skt->nr].dev, SCOOP_IMR, 0x00C0);
+	write_scoop_reg(scoop_devs[skt->nr].dev, SCOOP_MCR, 0x0101);
+	scoop_devs[skt->nr].keep_vs = NO_KEEP_VS;
 }
 
 static void sharpsl_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)
 {
+	/* CF_BUS_OFF */
+	sharpsl_pcmcia_init_reset(&scoop_devs[skt->nr]);
 }
 
 static struct pcmcia_low_level sharpsl_pcmcia_ops = {
@@ -223,7 +230,7 @@ static struct pcmcia_low_level sharpsl_pcmcia_ops = {
 	.socket_init		= sharpsl_pcmcia_socket_init,
 	.socket_suspend		= sharpsl_pcmcia_socket_suspend,
 	.first				= 0,
-	.nr					= 1,
+	.nr					= 0,
 };
 
 static struct platform_device *sharpsl_pcmcia_device;
@@ -232,12 +239,15 @@ static int __init sharpsl_pcmcia_init(void)
 {
 	int ret;
 
+	sharpsl_pcmcia_ops.nr=scoop_num;
 	sharpsl_pcmcia_device = kmalloc(sizeof(*sharpsl_pcmcia_device), GFP_KERNEL);
 	if (!sharpsl_pcmcia_device)
 		return -ENOMEM;
+
 	memset(sharpsl_pcmcia_device, 0, sizeof(*sharpsl_pcmcia_device));
 	sharpsl_pcmcia_device->name = "pxa2xx-pcmcia";
 	sharpsl_pcmcia_device->dev.platform_data = &sharpsl_pcmcia_ops;
+	sharpsl_pcmcia_device->dev.parent=scoop_devs[0].dev;
 
 	ret = platform_device_register(sharpsl_pcmcia_device);
 	if (ret)

commit f36598aeca4c2dbaa607bf6f774e38eb965402f2
Author: Richard Purdie <rpurdie@rpsys.net>
Date:   Sat Sep 3 19:39:25 2005 +0100

    [ARM] 2873/1: PCMCIA soc: Allow access to filesystems on CF at boot time
    
    Patch from Richard Purdie
    
    This change makes the soc pcmcia interfaces available earlier in the
    boot process meaning devices like CF microdrives can be used for the
    root filesystem.
    
    Signed-off-by: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
index 42efe218867a..7bac2f7d8b3f 100644
--- a/drivers/pcmcia/pxa2xx_sharpsl.c
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -257,7 +257,7 @@ static void __exit sharpsl_pcmcia_exit(void)
 	platform_device_unregister(sharpsl_pcmcia_device);
 }
 
-module_init(sharpsl_pcmcia_init);
+fs_initcall(sharpsl_pcmcia_init);
 module_exit(sharpsl_pcmcia_exit);
 
 MODULE_DESCRIPTION("Sharp SL Series PCMCIA Support");

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/pcmcia/pxa2xx_sharpsl.c b/drivers/pcmcia/pxa2xx_sharpsl.c
new file mode 100644
index 000000000000..42efe218867a
--- /dev/null
+++ b/drivers/pcmcia/pxa2xx_sharpsl.c
@@ -0,0 +1,264 @@
+/*
+ * Sharp SL-C7xx Series PCMCIA routines
+ *
+ * Copyright (c) 2004-2005 Richard Purdie
+ *
+ * Based on Sharp's 2.4 kernel patches and pxa2xx_mainstone.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+
+#include <asm/hardware/scoop.h>
+#include <asm/arch/corgi.h>
+#include <asm/arch/pxa-regs.h>
+
+#include "soc_common.h"
+
+#define	NO_KEEP_VS 0x0001
+
+static unsigned char keep_vs;
+static unsigned char keep_rd;
+
+static struct pcmcia_irqs irqs[] = {
+	{ 0, CORGI_IRQ_GPIO_CF_CD, "PCMCIA0 CD"},
+};
+
+static void sharpsl_pcmcia_init_reset(void)
+{
+	reset_scoop(&corgiscoop_device.dev);
+	keep_vs = NO_KEEP_VS;
+	keep_rd = 0;
+}
+
+static int sharpsl_pcmcia_hw_init(struct soc_pcmcia_socket *skt)
+{
+	int ret;
+
+	/*
+	 * Setup default state of GPIO outputs
+	 * before we enable them as outputs.
+	 */
+	GPSR(GPIO48_nPOE) =
+		GPIO_bit(GPIO48_nPOE) |
+		GPIO_bit(GPIO49_nPWE) |
+		GPIO_bit(GPIO50_nPIOR) |
+		GPIO_bit(GPIO51_nPIOW) |
+		GPIO_bit(GPIO52_nPCE_1) |
+		GPIO_bit(GPIO53_nPCE_2);
+
+	pxa_gpio_mode(GPIO48_nPOE_MD);
+	pxa_gpio_mode(GPIO49_nPWE_MD);
+	pxa_gpio_mode(GPIO50_nPIOR_MD);
+	pxa_gpio_mode(GPIO51_nPIOW_MD);
+	pxa_gpio_mode(GPIO52_nPCE_1_MD);
+	pxa_gpio_mode(GPIO53_nPCE_2_MD);
+	pxa_gpio_mode(GPIO54_pSKTSEL_MD);
+	pxa_gpio_mode(GPIO55_nPREG_MD);
+	pxa_gpio_mode(GPIO56_nPWAIT_MD);
+	pxa_gpio_mode(GPIO57_nIOIS16_MD);
+
+	/* Register interrupts */
+	ret = soc_pcmcia_request_irqs(skt, irqs, ARRAY_SIZE(irqs));
+
+	if (ret) {
+		printk(KERN_ERR "Request for Compact Flash IRQ failed\n");
+		return ret;
+	}
+
+	/* Enable interrupt */
+	write_scoop_reg(&corgiscoop_device.dev, SCOOP_IMR, 0x00C0);
+	write_scoop_reg(&corgiscoop_device.dev, SCOOP_MCR, 0x0101);
+	keep_vs = NO_KEEP_VS;
+
+	skt->irq = CORGI_IRQ_GPIO_CF_IRQ;
+
+	return 0;
+}
+
+static void sharpsl_pcmcia_hw_shutdown(struct soc_pcmcia_socket *skt)
+{
+	soc_pcmcia_free_irqs(skt, irqs, ARRAY_SIZE(irqs));
+
+	/* CF_BUS_OFF */
+	sharpsl_pcmcia_init_reset();
+}
+
+
+static void sharpsl_pcmcia_socket_state(struct soc_pcmcia_socket *skt,
+				    struct pcmcia_state *state)
+{
+	unsigned short cpr, csr;
+
+	cpr = read_scoop_reg(&corgiscoop_device.dev, SCOOP_CPR);
+
+	write_scoop_reg(&corgiscoop_device.dev, SCOOP_IRM, 0x00FF);
+	write_scoop_reg(&corgiscoop_device.dev, SCOOP_ISR, 0x0000);
+	write_scoop_reg(&corgiscoop_device.dev, SCOOP_IRM, 0x0000);
+	csr = read_scoop_reg(&corgiscoop_device.dev, SCOOP_CSR);
+	if (csr & 0x0004) {
+		/* card eject */
+		write_scoop_reg(&corgiscoop_device.dev, SCOOP_CDR, 0x0000);
+		keep_vs = NO_KEEP_VS;
+	}
+	else if (!(keep_vs & NO_KEEP_VS)) {
+		/* keep vs1,vs2 */
+		write_scoop_reg(&corgiscoop_device.dev, SCOOP_CDR, 0x0000);
+		csr |= keep_vs;
+	}
+	else if (cpr & 0x0003) {
+		/* power on */
+		write_scoop_reg(&corgiscoop_device.dev, SCOOP_CDR, 0x0000);
+		keep_vs = (csr & 0x00C0);
+	}
+	else {
+		/* card detect */
+		write_scoop_reg(&corgiscoop_device.dev, SCOOP_CDR, 0x0002);
+	}
+
+	state->detect = (csr & 0x0004) ? 0 : 1;
+	state->ready  = (csr & 0x0002) ? 1 : 0;
+	state->bvd1   = (csr & 0x0010) ? 1 : 0;
+	state->bvd2   = (csr & 0x0020) ? 1 : 0;
+	state->wrprot = (csr & 0x0008) ? 1 : 0;
+	state->vs_3v  = (csr & 0x0040) ? 0 : 1;
+	state->vs_Xv  = (csr & 0x0080) ? 0 : 1;
+
+	if ((cpr & 0x0080) && ((cpr & 0x8040) != 0x8040)) {
+		printk(KERN_ERR "sharpsl_pcmcia_socket_state(): CPR=%04X, Low voltage!\n", cpr);
+	}
+
+}
+
+
+static int sharpsl_pcmcia_configure_socket(struct soc_pcmcia_socket *skt,
+				       const socket_state_t *state)
+{
+	unsigned long flags;
+
+	unsigned short cpr, ncpr, ccr, nccr, mcr, nmcr, imr, nimr;
+
+	switch (state->Vcc) {
+	case	0:  	break;
+	case 	33: 	break;
+	case	50: 	break;
+	default:
+		 printk(KERN_ERR "sharpsl_pcmcia_configure_socket(): bad Vcc %u\n", state->Vcc);
+		 return -1;
+	}
+
+	if ((state->Vpp!=state->Vcc) && (state->Vpp!=0)) {
+		printk(KERN_ERR "CF slot cannot support Vpp %u\n", state->Vpp);
+		return -1;
+	}
+
+	local_irq_save(flags);
+
+	nmcr = (mcr = read_scoop_reg(&corgiscoop_device.dev, SCOOP_MCR)) & ~0x0010;
+	ncpr = (cpr = read_scoop_reg(&corgiscoop_device.dev, SCOOP_CPR)) & ~0x0083;
+	nccr = (ccr = read_scoop_reg(&corgiscoop_device.dev, SCOOP_CCR)) & ~0x0080;
+	nimr = (imr = read_scoop_reg(&corgiscoop_device.dev, SCOOP_IMR)) & ~0x003E;
+
+	ncpr |= (state->Vcc == 33) ? 0x0001 :
+				(state->Vcc == 50) ? 0x0002 : 0;
+	nmcr |= (state->flags&SS_IOCARD) ? 0x0010 : 0;
+	ncpr |= (state->flags&SS_OUTPUT_ENA) ? 0x0080 : 0;
+	nccr |= (state->flags&SS_RESET)? 0x0080: 0;
+	nimr |=	((skt->status&SS_DETECT) ? 0x0004 : 0)|
+			((skt->status&SS_READY)  ? 0x0002 : 0)|
+			((skt->status&SS_BATDEAD)? 0x0010 : 0)|
+			((skt->status&SS_BATWARN)? 0x0020 : 0)|
+			((skt->status&SS_STSCHG) ? 0x0010 : 0)|
+			((skt->status&SS_WRPROT) ? 0x0008 : 0);
+
+	if (!(ncpr & 0x0003)) {
+		keep_rd = 0;
+	} else if (!keep_rd) {
+		if (nccr & 0x0080)
+			keep_rd = 1;
+		else
+			nccr |= 0x0080;
+	}
+
+	if (mcr != nmcr)
+		write_scoop_reg(&corgiscoop_device.dev, SCOOP_MCR, nmcr);
+	if (cpr != ncpr)
+		write_scoop_reg(&corgiscoop_device.dev, SCOOP_CPR, ncpr);
+	if (ccr != nccr)
+		write_scoop_reg(&corgiscoop_device.dev, SCOOP_CCR, nccr);
+	if (imr != nimr)
+		write_scoop_reg(&corgiscoop_device.dev, SCOOP_IMR, nimr);
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static void sharpsl_pcmcia_socket_init(struct soc_pcmcia_socket *skt)
+{
+}
+
+static void sharpsl_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)
+{
+}
+
+static struct pcmcia_low_level sharpsl_pcmcia_ops = {
+	.owner				= THIS_MODULE,
+	.hw_init			= sharpsl_pcmcia_hw_init,
+	.hw_shutdown		= sharpsl_pcmcia_hw_shutdown,
+	.socket_state		= sharpsl_pcmcia_socket_state,
+	.configure_socket	= sharpsl_pcmcia_configure_socket,
+	.socket_init		= sharpsl_pcmcia_socket_init,
+	.socket_suspend		= sharpsl_pcmcia_socket_suspend,
+	.first				= 0,
+	.nr					= 1,
+};
+
+static struct platform_device *sharpsl_pcmcia_device;
+
+static int __init sharpsl_pcmcia_init(void)
+{
+	int ret;
+
+	sharpsl_pcmcia_device = kmalloc(sizeof(*sharpsl_pcmcia_device), GFP_KERNEL);
+	if (!sharpsl_pcmcia_device)
+		return -ENOMEM;
+	memset(sharpsl_pcmcia_device, 0, sizeof(*sharpsl_pcmcia_device));
+	sharpsl_pcmcia_device->name = "pxa2xx-pcmcia";
+	sharpsl_pcmcia_device->dev.platform_data = &sharpsl_pcmcia_ops;
+
+	ret = platform_device_register(sharpsl_pcmcia_device);
+	if (ret)
+		kfree(sharpsl_pcmcia_device);
+
+	return ret;
+}
+
+static void __exit sharpsl_pcmcia_exit(void)
+{
+	/*
+	 * This call is supposed to free our sharpsl_pcmcia_device.
+	 * Unfortunately platform_device don't have a free method, and
+	 * we can't assume it's free of any reference at this point so we
+	 * can't free it either.
+	 */
+	platform_device_unregister(sharpsl_pcmcia_device);
+}
+
+module_init(sharpsl_pcmcia_init);
+module_exit(sharpsl_pcmcia_exit);
+
+MODULE_DESCRIPTION("Sharp SL Series PCMCIA Support");
+MODULE_LICENSE("GPL");
