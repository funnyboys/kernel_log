commit bf89b0bf3038cdc972b563b16c68cee1b8eefb31
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:58:22 2020 +0100

    ata: make "libata.force" kernel parameter optional
    
    Add ATA_FORCE config option (visible only if EXPERT config
    option is enabled) and make "libata.force" kernel parameter
    optional.
    
    Code size savings on m68k arch using (modified) atari_defconfig:
    
       text    data     bss     dec     hex filename
    w/ CONFIG_ATA_FORCE=y:
      31983     572      40   32595    7f53 drivers/ata/libata-core.o
    w/ CONFIG_ATA_FROCE=n:
      28958     316      32   29306    727a drivers/ata/libata-core.o
    
    Suggested-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 6c808cf39135..68cdd81d747c 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -37,7 +37,11 @@ extern int libata_noacpi;
 extern int libata_allow_tpm;
 extern const struct device_type ata_port_type;
 extern struct ata_link *ata_dev_phys_link(struct ata_device *dev);
+#ifdef CONFIG_ATA_FORCE
 extern void ata_force_cbl(struct ata_port *ap);
+#else
+static inline void ata_force_cbl(struct ata_port *ap) { }
+#endif
 extern u64 ata_tf_to_lba(const struct ata_taskfile *tf);
 extern u64 ata_tf_to_lba48(const struct ata_taskfile *tf);
 extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev, int tag);

commit 15964ff72832ee489ae9e31c4e1a924e80e05dcb
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:58:19 2020 +0100

    ata: move ata_sas_*() to libata-sata.c
    
    * un-inline:
      - ata_scsi_dump_cdb()
      - __ata_scsi_queuecmd()
    
    * un-static:
      - ata_scsi_sdev_config()
      - ata_scsi_dev_config()
      - ata_scsi_dump_cdb()
      - __ata_scsi_queuecmd()
    
    * move ata_sas_*() to libata-sata.c:
    
    * add static inlines for CONFIG_SATA_HOST=n case for
      ata_sas_{allocate,free}_tag()
    
    Code size savings on m68k arch using (modified) atari_defconfig:
    
       text    data     bss     dec     hex filename
    before:
      19137      23     576   19736    4d18 drivers/ata/libata-scsi.o
    after:
      18330      23     576   18929    49f1 drivers/ata/libata-scsi.o
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index ce3f3c039572..6c808cf39135 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -87,6 +87,18 @@ extern unsigned int ata_read_log_page(struct ata_device *dev, u8 log,
 
 #define to_ata_port(d) container_of(d, struct ata_port, tdev)
 
+/* libata-sata.c */
+#ifdef CONFIG_SATA_HOST
+int ata_sas_allocate_tag(struct ata_port *ap);
+void ata_sas_free_tag(unsigned int tag, struct ata_port *ap);
+#else
+static inline int ata_sas_allocate_tag(struct ata_port *ap)
+{
+	return -EOPNOTSUPP;
+}
+static inline void ata_sas_free_tag(unsigned int tag, struct ata_port *ap) { }
+#endif
+
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
 extern unsigned int ata_acpi_gtf_filter;
@@ -130,9 +142,10 @@ extern void ata_scsi_dev_rescan(struct work_struct *work);
 extern int ata_bus_probe(struct ata_port *ap);
 extern int ata_scsi_user_scan(struct Scsi_Host *shost, unsigned int channel,
 			      unsigned int id, u64 lun);
-int ata_sas_allocate_tag(struct ata_port *ap);
-void ata_sas_free_tag(unsigned int tag, struct ata_port *ap);
-
+void ata_scsi_sdev_config(struct scsi_device *sdev);
+int ata_scsi_dev_config(struct scsi_device *sdev, struct ata_device *dev);
+void ata_scsi_dump_cdb(struct ata_port *ap, struct scsi_cmnd *cmd);
+int __ata_scsi_queuecmd(struct scsi_cmnd *scmd, struct ata_device *dev);
 
 /* libata-eh.c */
 extern unsigned long ata_internal_cmd_timeout(struct ata_device *dev, u8 cmd);

commit ec811a94c5bb6916d01c02dc99c8cecfa59cbb85
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:58:18 2020 +0100

    ata: start separating SATA specific code from libata-scsi.c
    
    Start separating SATA specific code from libata-scsi.c:
    
    * un-static ata_scsi_find_dev()
    
    * move following code to libata-sata.c:
      - SATA only sysfs device attributes handling
      - __ata_change_queue_depth()
      - ata_scsi_change_queue_depth()
    
    * cover with CONFIG_SATA_HOST ifdef SATA only sysfs device
      attributes handling code and ATA_SHT_NCQ() macro in
      <linux/libata.h>
    
    Code size savings on m68k arch using (modified) atari_defconfig:
    
       text    data     bss     dec     hex filename
    before:
      20702     105     576   21383    5387 drivers/ata/libata-scsi.o
    after:
      19137      23     576   19736    4d18 drivers/ata/libata-scsi.o
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index cd8090ad43e5..ce3f3c039572 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -112,6 +112,8 @@ static inline void ata_acpi_bind_dev(struct ata_device *dev) {}
 #endif
 
 /* libata-scsi.c */
+extern struct ata_device *ata_scsi_find_dev(struct ata_port *ap,
+					    const struct scsi_device *scsidev);
 extern int ata_scsi_add_hosts(struct ata_host *host,
 			      struct scsi_host_template *sht);
 extern void ata_scsi_scan_host(struct ata_port *ap, int sync);

commit 78c97c80d76b0590fc6ff5e20f4b18f105aa4fae
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:58:15 2020 +0100

    ata: move sata_link_hardreset() to libata-sata.c
    
    * move sata_link_hardreset() to libata-sata.c
    
    * add static inline for CONFIG_SATA_HOST=n case
    
    * make sata_set_spd_needed() static
    
    Code size savings on m68k arch using (modified) atari_defconfig:
    
       text    data     bss     dec     hex filename
    before:
      32724     572      40   33336    8238 drivers/ata/libata-core.o
    after:
      32559     572      40   33171    8193 drivers/ata/libata-core.o
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 53b45ebe3d55..cd8090ad43e5 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -87,13 +87,6 @@ extern unsigned int ata_read_log_page(struct ata_device *dev, u8 log,
 
 #define to_ata_port(d) container_of(d, struct ata_port, tdev)
 
-/* libata-sata.c */
-#ifdef CONFIG_SATA_HOST
-int sata_set_spd_needed(struct ata_link *link);
-#else
-static inline int sata_set_spd_needed(struct ata_link *link) { return 1; }
-#endif
-
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
 extern unsigned int ata_acpi_gtf_filter;

commit ab4117cf2470618ffd5af16fa7c363b81260d6e7
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Thu Mar 26 16:58:13 2020 +0100

    ata: move *sata_set_spd*() to libata-sata.c
    
    * move *sata_set_spd*() to libata-sata.c
    
    * add static inlines for CONFIG_SATA_HOST=n case
    
    Code size savings on m68k arch using (modified) atari_defconfig:
    
       text    data     bss     dec     hex filename
    before:
      32842     572      40   33458    82ae drivers/ata/libata-core.o
    after:
      32812     572      40   33428    8290 drivers/ata/libata-core.o
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index cd8090ad43e5..53b45ebe3d55 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -87,6 +87,13 @@ extern unsigned int ata_read_log_page(struct ata_device *dev, u8 log,
 
 #define to_ata_port(d) container_of(d, struct ata_port, tdev)
 
+/* libata-sata.c */
+#ifdef CONFIG_SATA_HOST
+int sata_set_spd_needed(struct ata_link *link);
+#else
+static inline int sata_set_spd_needed(struct ata_link *link) { return 1; }
+#endif
+
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
 extern unsigned int ata_acpi_gtf_filter;

commit c82ee6d3beaa489058c1fe1ca710042a07df9d40
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:48 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 18
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 or at your option any
      later version this program is distributed in the hope that it will
      be useful but without any warranty without even the implied warranty
      of merchantability or fitness for a particular purpose see the gnu
      general public license for more details you should have received a
      copy of the gnu general public license along with this program see
      the file copying if not write to the free software foundation 675
      mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 52 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154042.342335923@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index f953cb4bb1ba..cd8090ad43e5 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -1,28 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  *  libata.h - helper library for ATA
  *
  *  Copyright 2003-2004 Red Hat, Inc.  All rights reserved.
  *  Copyright 2003-2004 Jeff Garzik
  *
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- *
  *  libata documentation is available via 'make {ps|pdf}docs',
  *  as Documentation/driver-api/libata.rst
- *
  */
 
 #ifndef __LIBATA_H__

commit 2fa4a32613c9182b00e46872755b0662374424a7
Author: Jason Yan <yanaijie@huawei.com>
Date:   Thu May 10 11:05:16 2018 +0800

    scsi: libsas: dynamically allocate and free ata host
    
    Commit 2623c7a5f2 ("libata: add refcounting to ata_host") v4.17+ introduced
    refcounting to ata_host and will increase or decrease the refcount when
    adding or deleting transport ATA port.
    
    Now the ata host for libsas is embedded in domain_device, and the ->kref
    member is not initialized. Afer we add ata transport class, ata_host_get()
    will be called when adding transport ATA port and a warning will be
    triggered as below:
    
    refcount_t: increment on 0; use-after-free.
    WARNING: CPU: 2 PID: 103 at
    lib/refcount.c:153 refcount_inc+0x40/0x48 ......  Call trace:
     refcount_inc+0x40/0x48
     ata_host_get+0x10/0x18
     ata_tport_add+0x40/0x120
     ata_sas_tport_add+0xc/0x14
     sas_ata_init+0x7c/0xc8
     sas_discover_domain+0x380/0x53c
     process_one_work+0x12c/0x288
     worker_thread+0x58/0x3f0
     kthread+0xfc/0x128
     ret_from_fork+0x10/0x18
    
    And also when removing transport ATA port ata_host_put() will be called and
    another similar warning will be triggered. If the refcount decreased to
    zero, the ata host will be freed. But this ata host is only part of
    domain_device, it cannot be freed directly.
    
    So we have to change this embedded static ata host to a dynamically
    allocated ata host and initialize the ->kref member. To use ata_host_get()
    and ata_host_put() in libsas, we need to move the declaration of these
    functions to the public libata.h and export them.
    
    Fixes: b6240a4df018 ("scsi: libsas: add transport class for ATA devices")
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    CC: John Garry <john.garry@huawei.com>
    CC: Taras Kondratiuk <takondra@cisco.com>
    CC: Tejun Heo <tj@kernel.org>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 9e21c49cf6be..f953cb4bb1ba 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -100,8 +100,6 @@ extern int ata_port_probe(struct ata_port *ap);
 extern void __ata_port_probe(struct ata_port *ap);
 extern unsigned int ata_read_log_page(struct ata_device *dev, u8 log,
 				      u8 page, void *buf, unsigned int sectors);
-extern void ata_host_get(struct ata_host *host);
-extern void ata_host_put(struct ata_host *host);
 
 #define to_ata_port(d) container_of(d, struct ata_port, tdev)
 

commit 2623c7a5f2799569d8bb05eb211da524a8144cb3
Author: Taras Kondratiuk <takondra@cisco.com>
Date:   Fri Mar 9 08:34:41 2018 +0000

    libata: add refcounting to ata_host
    
    After commit 9a6d6a2ddabb ("ata: make ata port as parent device of scsi
    host") manual driver unbind/remove causes use-after-free.
    
    Unbind unconditionally invokes devres_release_all() which calls
    ata_host_release() and frees ata_host/ata_port memory while it is still
    being referenced as a parent of SCSI host. When SCSI host is finally
    released scsi_host_dev_release() calls put_device(parent) and accesses
    freed ata_port memory.
    
    Add reference counting to make sure that ata_host lives long enough.
    
    Bug report: https://lkml.org/lkml/2017/11/1/945
    Fixes: 9a6d6a2ddabb ("ata: make ata port as parent device of scsi host")
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Lin Ming <minggr@gmail.com>
    Cc: linux-ide@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Taras Kondratiuk <takondra@cisco.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index f953cb4bb1ba..9e21c49cf6be 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -100,6 +100,8 @@ extern int ata_port_probe(struct ata_port *ap);
 extern void __ata_port_probe(struct ata_port *ap);
 extern unsigned int ata_read_log_page(struct ata_device *dev, u8 log,
 				      u8 page, void *buf, unsigned int sectors);
+extern void ata_host_get(struct ata_host *host);
+extern void ata_host_put(struct ata_host *host);
 
 #define to_ata_port(d) container_of(d, struct ata_port, tdev)
 

commit 1bc03573e1c9024d4e4be97df4a1e0931edbae2c
Merge: 1be2172e96e3 5bca462d2d18
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 15 14:11:41 2017 -0800

    Merge branch 'for-4.15' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata
    
    Pull libata updates from Tejun Heo:
     "Nothing too interesting or alarming. Other than a new power saving
      mode addition to ahci and crash fix on a tracepoint, all changes are
      trivial or device-specific"
    
    * 'for-4.15' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata: (22 commits)
      ahci: imx: Handle increased read failures for IMX53 temperature sensor in low frequency mode.
      ata: sata_dwc_460ex: Propagate platform device ID to DMA driver
      ata: fixes kernel crash while tracing ata_eh_link_autopsy event
      ata: pata_pdc2027x: Fix space before '[' error.
      libata: fix spelling mistake: 'ambigious' -> 'ambiguous'
      ata: ceva: Add SMMU support for SATA IP
      ata: ceva: Correct the suspend and resume logic for SATA
      ata: ceva: Correct the AXI bus configuration for SATA ports
      ata: ceva: Add CCI support for SATA if CCI is enabled
      ata: ceva: Make RxWaterMark value as module parameter
      ata: ceva: Disable Device Sleep capability
      ata: ceva: Add gen 3 mode support in driver
      ata: ceva: Move sata port phy oob settings to device-tree
      devicetree: bindings: Add sata port phy config parameters in ahci-ceva
      ata: mark expected switch fall-throughs
      ata: sata_mv: remove a redundant assignment to pointer ehi
      ahci: Add support for Cavium's fifth generation SATA controller
      ata: sata_rcar: Use of_device_get_match_data() helper
      libata: make ata_port_type const
      libata: make static arrays const, reduces object code size
      ...

commit b93ab338f7f0e39321b282d694a52736fdab172b
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Oct 16 14:56:42 2017 -0700

    libata: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Tejun Heo <tj@kernel.org>
    Cc: linux-ide@vger.kernel.org
    Link: https://lkml.kernel.org/r/20171005004842.GA23011@beast

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 839d487394b7..08a245b76417 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -154,7 +154,7 @@ extern void ata_internal_cmd_timed_out(struct ata_device *dev, u8 cmd);
 extern void ata_eh_acquire(struct ata_port *ap);
 extern void ata_eh_release(struct ata_port *ap);
 extern void ata_scsi_error(struct Scsi_Host *host);
-extern void ata_eh_fastdrain_timerfn(unsigned long arg);
+extern void ata_eh_fastdrain_timerfn(struct timer_list *t);
 extern void ata_qc_schedule_eh(struct ata_queued_cmd *qc);
 extern void ata_dev_disable(struct ata_device *dev);
 extern void ata_eh_detach_dev(struct ata_device *dev);

commit 8df82c13a3756f831b0d748226ce932515728e04
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Sep 30 22:10:40 2017 +0530

    libata: make ata_port_type const
    
    Make this const as it is only stored in the const field of a device
    structure. Make the declaration in header const too.
    
    Structure found using Coccinelle and changes done by hand.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 839d487394b7..18bf1e995a18 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -51,7 +51,7 @@ extern int atapi_passthru16;
 extern int libata_fua;
 extern int libata_noacpi;
 extern int libata_allow_tpm;
-extern struct device_type ata_port_type;
+extern const struct device_type ata_port_type;
 extern struct ata_link *ata_dev_phys_link(struct ata_device *dev);
 extern void ata_force_cbl(struct ata_port *ap);
 extern u64 ata_tf_to_lba(const struct ata_taskfile *tf);

commit f01f62c257cc343246a5a9b2df8135f01fc044ab
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Jun 4 14:42:20 2017 +0200

    libata: move ata_read_log_page to libata-core.c
    
    It is core functionality, and only one of the users is in the EH code.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 5afe35baf61b..839d487394b7 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -98,6 +98,8 @@ extern struct ata_port *ata_port_alloc(struct ata_host *host);
 extern const char *sata_spd_string(unsigned int spd);
 extern int ata_port_probe(struct ata_port *ap);
 extern void __ata_port_probe(struct ata_port *ap);
+extern unsigned int ata_read_log_page(struct ata_device *dev, u8 log,
+				      u8 page, void *buf, unsigned int sectors);
 
 #define to_ata_port(d) container_of(d, struct ata_port, tdev)
 
@@ -160,8 +162,6 @@ extern void ata_eh_about_to_do(struct ata_link *link, struct ata_device *dev,
 			       unsigned int action);
 extern void ata_eh_done(struct ata_link *link, struct ata_device *dev,
 			unsigned int action);
-extern unsigned int ata_read_log_page(struct ata_device *dev, u8 log,
-				      u8 page, void *buf, unsigned int sectors);
 extern void ata_eh_autopsy(struct ata_port *ap);
 const char *ata_get_cmd_descript(u8 command);
 extern void ata_eh_report(struct ata_port *ap);

commit 9bb9a39ce51eae886575251e87d9292f679e3e32
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Tue May 16 09:16:37 2017 -0300

    ata: update references for libata documentation
    
    The libata documentation is now using ReST. Update references
    to it to point to the new place.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 120fce0befd3..5afe35baf61b 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -21,7 +21,7 @@
  *
  *
  *  libata documentation is available via 'make {ps|pdf}docs',
- *  as Documentation/DocBook/libata.*
+ *  as Documentation/driver-api/libata.rst
  *
  */
 

commit 79f4d1d5c0d7d115b5a693a5bb369e69efb7e7a5
Merge: 97a229f90731 73b2951414f6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 21 17:21:32 2017 -0800

    Merge branch 'for-4.11' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata
    
    Pull libata updates from Tejun Heo:
    
     - Bartlomiej added pata_falcon
    
     - Christoph is trying to remove use of static 4k buf.  It's still WIP
    
     - config cleanup around HAS_DMA
    
     - other fixes and driver-specific changes
    
    * 'for-4.11' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata: (29 commits)
      ata: pata_of_platform: using of_property_read_u32() helper
      pata_atiixp: Don't use unconnected secondary port on SB600/SB700
      libata-sff: Don't scan disabled ports when checking for legacy mode.
      pata_octeon_cf: remove unused local variables from octeon_cf_set_piomode()
      ahci: qoriq: added ls2088a platforms support
      ahci: qoriq: report error when ecc register address is missing in dts
      ahci: qoriq: added a condition to enable dma coherence
      Revert "libata: switch to dynamic allocation instead of ata_scsi_rbuf"
      ahci: imx: fix building without hwmon or thermal
      ata: add Atari Falcon PATA controller driver
      ata: pass queued command to ->sff_data_xfer method
      ata: allow subsystem to be used on m68k arch
      libata: switch to dynamic allocation instead of ata_scsi_rbuf
      libata: don't call ata_scsi_rbuf_fill for command without a response buffer
      libata: call ->scsi_done from ata_scsi_simulate
      libata: remove the done callback from ata_scsi_args
      libata: move struct ata_scsi_args to libata-scsi.c
      libata: avoid global response buffer in atapi_qc_complete
      libata-eh: Use switch() instead of sparse array for protocol strings
      ata: sata_mv: Convert to devm_ioremap_resource()
      ...

commit b6a05c823fc573a65efc4466f174abf05f922e0f
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 30 13:18:58 2017 +0100

    scsi: remove eh_timed_out methods in the transport template
    
    Instead define the timeout behavior purely based on the host_template
    eh_timed_out method and wire up the existing transport implementations
    in the host templates.  This also clears up the confusion that the
    transport template method overrides the host template one, so some
    drivers have to re-override the transport template one.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 8f3a5596dd67..06d479d1f302 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -159,7 +159,6 @@ extern unsigned long ata_internal_cmd_timeout(struct ata_device *dev, u8 cmd);
 extern void ata_internal_cmd_timed_out(struct ata_device *dev, u8 cmd);
 extern void ata_eh_acquire(struct ata_port *ap);
 extern void ata_eh_release(struct ata_port *ap);
-extern enum blk_eh_timer_return ata_scsi_timed_out(struct scsi_cmnd *cmd);
 extern void ata_scsi_error(struct Scsi_Host *host);
 extern void ata_eh_fastdrain_timerfn(unsigned long arg);
 extern void ata_qc_schedule_eh(struct ata_queued_cmd *qc);

commit f0a37d12f51a51d61f68dd30123f2b1927b56bb6
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jan 10 09:41:44 2017 +0100

    libata: move struct ata_scsi_args to libata-scsi.c
    
    It's only used in libata-scsi.c, so move it closer to the users.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 1133e9439f9c..bba39a62552b 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -31,13 +31,6 @@
 #define DRV_NAME	"libata"
 #define DRV_VERSION	"3.00"	/* must be exactly four chars */
 
-struct ata_scsi_args {
-	struct ata_device	*dev;
-	u16			*id;
-	struct scsi_cmnd	*cmd;
-	void			(*done)(struct scsi_cmnd *);
-};
-
 /* libata-core.c */
 enum {
 	/* flags for ata_dev_read_id() */

commit 6cf32ed9eee2d34db441ba6ebad3ec2d67952688
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Jan 3 19:09:48 2017 +0100

    libata: Make ata_sg_clean() static again
    
    Commit 70e6ad0c6d1e6cb9 ("[PATCH] libata: prepare ata_sg_clean() for
    invocation from EH") made ata_sg_clean() global, but no user outside
    libata-core.c has ever materialized.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 8f3a5596dd67..1133e9439f9c 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -89,7 +89,6 @@ extern int sata_down_spd_limit(struct ata_link *link, u32 spd_limit);
 extern int ata_down_xfermask_limit(struct ata_device *dev, unsigned int sel);
 extern unsigned int ata_dev_set_feature(struct ata_device *dev,
 					u8 enable, u8 feature);
-extern void ata_sg_clean(struct ata_queued_cmd *qc);
 extern void ata_qc_free(struct ata_queued_cmd *qc);
 extern void ata_qc_issue(struct ata_queued_cmd *qc);
 extern void __ata_qc_complete(struct ata_queued_cmd *qc);

commit 8e061784b51ec4a4efed0deaafb5bd9725bf5b06
Author: Adam Manzanares <adam.manzanares@hgst.com>
Date:   Mon Oct 17 11:27:29 2016 -0700

    ata: Enabling ATA Command Priorities
    
    This patch checks to see if an ATA device supports NCQ command priorities.
    If so and the user has specified an iocontext that indicates
    IO_PRIO_CLASS_RT then we build a tf with a high priority command.
    
    This is done to improve the tail latency of commands that are high
    priority by passing priority to the device.
    
    tj: Removed trivial ata_ncq_prio_enabled() and open-coded the test.
    
    Signed-off-by: Adam Manzanares <adam.manzanares@hgst.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 3b301a48007c..8f3a5596dd67 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -66,7 +66,7 @@ extern u64 ata_tf_to_lba48(const struct ata_taskfile *tf);
 extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev, int tag);
 extern int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
 			   u64 block, u32 n_block, unsigned int tf_flags,
-			   unsigned int tag);
+			   unsigned int tag, int class);
 extern u64 ata_tf_read_block(const struct ata_taskfile *tf,
 			     struct ata_device *dev);
 extern unsigned ata_exec_internal(struct ata_device *dev,

commit 06dbde5f3a44248fc02e24d662ac4849202abb48
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 4 11:44:03 2016 +0200

    libata: Implement control mode page to select sense format
    
    Implement MODE SELECT for the control mode page to allow the OS
    to switch to descriptor sense.
    
    tj: Dropped s/sb/cmd->sense_buffer/ in ata_gen_ata_sense().  Added
        @dev description to ata_msense_ctl_mode().
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index dbc67604b3c5..3b301a48007c 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -138,7 +138,8 @@ extern int ata_scsi_add_hosts(struct ata_host *host,
 			      struct scsi_host_template *sht);
 extern void ata_scsi_scan_host(struct ata_port *ap, int sync);
 extern int ata_scsi_offline_dev(struct ata_device *dev);
-extern void ata_scsi_set_sense(struct scsi_cmnd *cmd, u8 sk, u8 asc, u8 ascq);
+extern void ata_scsi_set_sense(struct ata_device *dev,
+			       struct scsi_cmnd *cmd, u8 sk, u8 asc, u8 ascq);
 extern void ata_scsi_set_sense_information(struct ata_device *dev,
 					   struct scsi_cmnd *cmd,
 					   const struct ata_taskfile *tf);

commit 492bf62107347aca764070dbc9d412da6bda73d1
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 4 11:43:59 2016 +0200

    libata-eh: Set 'information' field for autosense
    
    If NCQ autosense or the sense data reporting feature is enabled
    the LBA of the offending command should be stored in the sense
    data 'information' field.
    
    tj: s/(u64)-1/U64_MAX/
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 507c22f7a63b..dbc67604b3c5 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -139,6 +139,9 @@ extern int ata_scsi_add_hosts(struct ata_host *host,
 extern void ata_scsi_scan_host(struct ata_port *ap, int sync);
 extern int ata_scsi_offline_dev(struct ata_device *dev);
 extern void ata_scsi_set_sense(struct scsi_cmnd *cmd, u8 sk, u8 asc, u8 ascq);
+extern void ata_scsi_set_sense_information(struct ata_device *dev,
+					   struct scsi_cmnd *cmd,
+					   const struct ata_taskfile *tf);
 extern void ata_scsi_media_change_notify(struct ata_device *dev);
 extern void ata_scsi_hotplug(struct work_struct *work);
 extern void ata_schedule_scsi_eh(struct Scsi_Host *shost);

commit cffd1ee991c566bca937392cfacdafbe3b7b58c6
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 4 11:43:57 2016 +0200

    libata: sanitize ata_tf_read_block()
    
    Return U64_MAX if ata_tf_read_block() could not decode the LBA
    address, and do not set the information sense descriptor in
    ata_gen_ata_sense() in these cases.
    
    tj: s/(u64)-1/U64_MAX/
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 8cfdd9616d16..507c22f7a63b 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -67,7 +67,8 @@ extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev, int tag);
 extern int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
 			   u64 block, u32 n_block, unsigned int tf_flags,
 			   unsigned int tag);
-extern u64 ata_tf_read_block(struct ata_taskfile *tf, struct ata_device *dev);
+extern u64 ata_tf_read_block(const struct ata_taskfile *tf,
+			     struct ata_device *dev);
 extern unsigned ata_exec_internal(struct ata_device *dev,
 				  struct ata_taskfile *tf, const u8 *cdb,
 				  int dma_dir, void *buf, unsigned int buflen,

commit 5b01e4b9efa0b78672cbbea830c9fbcc7f239e29
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Apr 4 11:43:54 2016 +0200

    libata: Implement NCQ autosense
    
    Some newer devices support NCQ autosense (cf ACS-4), so we should
    be using it to retrieve the sense code and speed up recovery.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index f840ca18a7c0..8cfdd9616d16 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -137,6 +137,7 @@ extern int ata_scsi_add_hosts(struct ata_host *host,
 			      struct scsi_host_template *sht);
 extern void ata_scsi_scan_host(struct ata_port *ap, int sync);
 extern int ata_scsi_offline_dev(struct ata_device *dev);
+extern void ata_scsi_set_sense(struct scsi_cmnd *cmd, u8 sk, u8 asc, u8 ascq);
 extern void ata_scsi_media_change_notify(struct ata_device *dev);
 extern void ata_scsi_hotplug(struct work_struct *work);
 extern void ata_schedule_scsi_eh(struct Scsi_Host *shost);

commit 74a80d67b8316eb3fbeb73dafc060a5a0a708587
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Aug 3 11:46:39 2015 -0400

    Revert "libata: Implement NCQ autosense"
    
    This reverts commit 42b966fbf35da9c87f08d98f9b8978edf9e717cf.
    
    As implemented, ACS-4 sense reporting for ATA devices bypasses error
    diagnosis and handling in libata degrading EH behavior significantly.
    Revert the related changes for now.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: stable@vger.kernel.org #v4.1+

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 8cfdd9616d16..f840ca18a7c0 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -137,7 +137,6 @@ extern int ata_scsi_add_hosts(struct ata_host *host,
 			      struct scsi_host_template *sht);
 extern void ata_scsi_scan_host(struct ata_port *ap, int sync);
 extern int ata_scsi_offline_dev(struct ata_device *dev);
-extern void ata_scsi_set_sense(struct scsi_cmnd *cmd, u8 sk, u8 asc, u8 ascq);
 extern void ata_scsi_media_change_notify(struct ata_device *dev);
 extern void ata_scsi_hotplug(struct work_struct *work);
 extern void ata_schedule_scsi_eh(struct Scsi_Host *shost);

commit fe16d4f202c59a560533a223bc6375739ee30944
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Aug 3 11:41:33 2015 -0400

    Revert "libata-eh: Set 'information' field for autosense"
    
    This reverts commit a1524f226a02aa6edebd90ae0752e97cfd78b159.
    
    As implemented, ACS-4 sense reporting for ATA devices bypasses error
    diagnosis and handling in libata degrading EH behavior significantly.
    Revert the related changes for now.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: stable@vger.kernel.org #v4.1+

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index a998a175f9f1..8cfdd9616d16 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -67,8 +67,7 @@ extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev, int tag);
 extern int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
 			   u64 block, u32 n_block, unsigned int tf_flags,
 			   unsigned int tag);
-extern u64 ata_tf_read_block(const struct ata_taskfile *tf,
-			     struct ata_device *dev);
+extern u64 ata_tf_read_block(struct ata_taskfile *tf, struct ata_device *dev);
 extern unsigned ata_exec_internal(struct ata_device *dev,
 				  struct ata_taskfile *tf, const u8 *cdb,
 				  int dma_dir, void *buf, unsigned int buflen,
@@ -139,8 +138,6 @@ extern int ata_scsi_add_hosts(struct ata_host *host,
 extern void ata_scsi_scan_host(struct ata_port *ap, int sync);
 extern int ata_scsi_offline_dev(struct ata_device *dev);
 extern void ata_scsi_set_sense(struct scsi_cmnd *cmd, u8 sk, u8 asc, u8 ascq);
-extern void ata_scsi_set_sense_information(struct scsi_cmnd *cmd,
-					   const struct ata_taskfile *tf);
 extern void ata_scsi_media_change_notify(struct ata_device *dev);
 extern void ata_scsi_hotplug(struct work_struct *work);
 extern void ata_schedule_scsi_eh(struct Scsi_Host *shost);

commit a1524f226a02aa6edebd90ae0752e97cfd78b159
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Mar 27 16:46:37 2015 +0100

    libata-eh: Set 'information' field for autosense
    
    If NCQ autosense or the sense data reporting feature is enabled
    the LBA of the offending command should be stored in the sense
    data 'information' field.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 8cfdd9616d16..a998a175f9f1 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -67,7 +67,8 @@ extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev, int tag);
 extern int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
 			   u64 block, u32 n_block, unsigned int tf_flags,
 			   unsigned int tag);
-extern u64 ata_tf_read_block(struct ata_taskfile *tf, struct ata_device *dev);
+extern u64 ata_tf_read_block(const struct ata_taskfile *tf,
+			     struct ata_device *dev);
 extern unsigned ata_exec_internal(struct ata_device *dev,
 				  struct ata_taskfile *tf, const u8 *cdb,
 				  int dma_dir, void *buf, unsigned int buflen,
@@ -138,6 +139,8 @@ extern int ata_scsi_add_hosts(struct ata_host *host,
 extern void ata_scsi_scan_host(struct ata_port *ap, int sync);
 extern int ata_scsi_offline_dev(struct ata_device *dev);
 extern void ata_scsi_set_sense(struct scsi_cmnd *cmd, u8 sk, u8 asc, u8 ascq);
+extern void ata_scsi_set_sense_information(struct scsi_cmnd *cmd,
+					   const struct ata_taskfile *tf);
 extern void ata_scsi_media_change_notify(struct ata_device *dev);
 extern void ata_scsi_hotplug(struct work_struct *work);
 extern void ata_schedule_scsi_eh(struct Scsi_Host *shost);

commit 42b966fbf35da9c87f08d98f9b8978edf9e717cf
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Mar 27 16:46:35 2015 +0100

    libata: Implement NCQ autosense
    
    Some newer devices support NCQ autosense (cf ACS-4), so we should
    be using it to retrieve the sense code and speed up recovery.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index f840ca18a7c0..8cfdd9616d16 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -137,6 +137,7 @@ extern int ata_scsi_add_hosts(struct ata_host *host,
 			      struct scsi_host_template *sht);
 extern void ata_scsi_scan_host(struct ata_port *ap, int sync);
 extern int ata_scsi_offline_dev(struct ata_device *dev);
+extern void ata_scsi_set_sense(struct scsi_cmnd *cmd, u8 sk, u8 asc, u8 ascq);
 extern void ata_scsi_media_change_notify(struct ata_device *dev);
 extern void ata_scsi_hotplug(struct work_struct *work);
 extern void ata_schedule_scsi_eh(struct Scsi_Host *shost);

commit 8494bcf5b7c4b2416687e233dd34d4c6b6fe5653
Merge: 3e12cefbe143 b042a3ca9490
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 12 14:30:53 2015 -0800

    Merge branch 'for-3.20/drivers' of git://git.kernel.dk/linux-block
    
    Pull block driver changes from Jens Axboe:
     "This contains:
    
       - The 4k/partition fixes for brd from Boaz/Matthew.
    
       - A few xen front/back block fixes from David Vrabel and Roger Pau
         Monne.
    
       - Floppy changes from Takashi, cleaning the device file creation.
    
       - Switching libata to use the new blk-mq tagging policy, removing
         code (and a suboptimal implementation) from libata.  This will
         throw you a merge conflict, since a bug in the original libata
         tagging code was fixed since this code was branched.  Trivial.
         From Shaohua.
    
       - Conversion of loop to blk-mq, from Ming Lei.
    
       - Cleanup of the io_schedule() handling in bsg from Peter Zijlstra.
         He claims it improves on unreadable code, which will cost him a
         beer.
    
       - Maintainer update or NDB, now handled by Markus Pargmann.
    
       - NVMe:
            - Optimization from me that avoids a kmalloc/kfree per IO for
              smaller (<= 8KB) IO. This cuts about 1% of high IOPS CPU
              overhead.
            - Removal of (now) dead RCU code, a relic from before NVMe was
              converted to blk-mq"
    
    * 'for-3.20/drivers' of git://git.kernel.dk/linux-block:
      xen-blkback: default to X86_32 ABI on x86
      xen-blkfront: fix accounting of reqs when migrating
      xen-blkback,xen-blkfront: add myself as maintainer
      block: Simplify bsg complete all
      floppy: Avoid manual call of device_create_file()
      NVMe: avoid kmalloc/kfree for smaller IO
      MAINTAINERS: Update NBD maintainer
      libata: make sata_sil24 use fifo tag allocator
      libata: move sas ata tag allocation to libata-scsi.c
      libata: use blk taging
      NVMe: within nvme_free_queues(), delete RCU sychro/deferred free
      null_blk: suppress invalid partition info
      brd: Request from fdisk 4k alignment
      brd: Fix all partitions BUGs
      axonram: Fix bug in direct_access
      loop: add blk-mq.h include
      block: loop: don't handle REQ_FUA explicitly
      block: loop: introduce lo_discard() and lo_req_flush()
      block: loop: say goodby to bio
      block: loop: improve performance via blk-mq

commit 98bd4be1ba95f2fe7f543910792b7163a5de06eb
Author: Shaohua Li <shli@fb.com>
Date:   Fri Jan 23 19:52:07 2015 -0800

    libata: move sas ata tag allocation to libata-scsi.c
    
    Basically move the sas ata tag allocation to libata-scsi.c to make it clear
    these staffs are just for sas.
    
    Signed-off-by: Shaohua Li <shli@fb.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 40405135bbb6..8c491cd8805b 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -145,6 +145,8 @@ extern void ata_scsi_dev_rescan(struct work_struct *work);
 extern int ata_bus_probe(struct ata_port *ap);
 extern int ata_scsi_user_scan(struct Scsi_Host *shost, unsigned int channel,
 			      unsigned int id, u64 lun);
+int ata_sas_allocate_tag(struct ata_port *ap);
+void ata_sas_free_tag(unsigned int tag, struct ata_port *ap);
 
 
 /* libata-eh.c */

commit 12cb5ce101abfaf74421f8cc9f196e708209eb79
Author: Shaohua Li <shli@fb.com>
Date:   Thu Jan 15 17:32:27 2015 -0800

    libata: use blk taging
    
    libata uses its own tag management which is duplication and the
    implementation is poor. And if we switch to blk-mq, tag is build-in.
    It's time to switch to generic taging.
    
    The SAS driver has its own tag management, and looks we can't directly
    map the host controler tag to SATA tag. So I just bypassed the SAS case.
    
    I changed the code/variable name for the tag management of libata to
    make it self contained. Only sas will use it. Later if libsas implements
    its tag management, the tag management code in libata can be deleted
    easily.
    
    Cc: Jens Axboe <axboe@fb.com>
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Shaohua Li <shli@fb.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 5f4e0cca56ec..40405135bbb6 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -63,7 +63,7 @@ extern struct ata_link *ata_dev_phys_link(struct ata_device *dev);
 extern void ata_force_cbl(struct ata_port *ap);
 extern u64 ata_tf_to_lba(const struct ata_taskfile *tf);
 extern u64 ata_tf_to_lba48(const struct ata_taskfile *tf);
-extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev);
+extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev, int tag);
 extern int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
 			   u64 block, u32 n_block, unsigned int tf_flags,
 			   unsigned int tag);

commit e88af2f8de7914d311e66854eba2889710ee364e
Author: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
Date:   Sun Jan 11 15:27:01 2015 +0100

    ata: libata-core: Remove unused function
    
    Remove the function ata_do_simple_cmd() that is not used anywhere.
    
    This was partially found by using a static code analysis program called cppcheck.
    
    Signed-off-by: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 5f4e0cca56ec..82ebe263d2f1 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -76,7 +76,6 @@ extern unsigned ata_exec_internal_sg(struct ata_device *dev,
 				     struct ata_taskfile *tf, const u8 *cdb,
 				     int dma_dir, struct scatterlist *sg,
 				     unsigned int n_elem, unsigned long timeout);
-extern unsigned int ata_do_simple_cmd(struct ata_device *dev, u8 cmd);
 extern int ata_wait_ready(struct ata_link *link, unsigned long deadline,
 			  int (*check_ready)(struct ata_link *link));
 extern int ata_dev_read_id(struct ata_device *dev, unsigned int *p_class,

commit 9cb78c16f5dadefd8dc5ba0ae5a2f26cd59419b3
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Jun 25 15:27:36 2014 +0200

    scsi: use 64-bit LUNs
    
    The SCSI standard defines 64-bit values for LUNs, and large arrays
    employing large or hierarchical LUN numbers become more and more
    common.
    
    So update the linux SCSI stack to use 64-bit LUN numbers.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@infradead.org>
    Reviewed-by: Ewan Milne <emilne@redhat.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 45b5ab3a95d5..5f4e0cca56ec 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -144,7 +144,7 @@ extern void ata_schedule_scsi_eh(struct Scsi_Host *shost);
 extern void ata_scsi_dev_rescan(struct work_struct *work);
 extern int ata_bus_probe(struct ata_port *ap);
 extern int ata_scsi_user_scan(struct Scsi_Host *shost, unsigned int channel,
-			      unsigned int id, unsigned int lun);
+			      unsigned int id, u64 lun);
 
 
 /* libata-eh.c */

commit b08fc109ce4a32ce2f73f6e0437abc94ab1dd023
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Thu Oct 17 15:38:53 2013 +0200

    ATA / ACPI: remove power dependent device handling
    
    Previously, we wanted SCSI devices corrsponding to ATA devices to
    be runtime resumed when the power resource for those ATA device was
    turned on by some other device, so we added the SCSI device to the
    dependent device list of the ATA device's ACPI node.  However, this
    code has no effect after commit 41863fc (ACPI / power: Drop automaitc
    resume of power resource dependent devices) and the mechanism it was
    supposed to implement is regarded as a bad idea now, so drop it.
    
    [rjw: Changelog]
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index eeeb77845d48..45b5ab3a95d5 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -121,8 +121,6 @@ extern void ata_acpi_set_state(struct ata_port *ap, pm_message_t state);
 extern void ata_acpi_bind_port(struct ata_port *ap);
 extern void ata_acpi_bind_dev(struct ata_device *dev);
 extern acpi_handle ata_dev_acpi_handle(struct ata_device *dev);
-extern void ata_scsi_acpi_bind(struct ata_device *dev);
-extern void ata_scsi_acpi_unbind(struct ata_device *dev);
 #else
 static inline void ata_acpi_dissociate(struct ata_host *host) { }
 static inline int ata_acpi_on_suspend(struct ata_port *ap) { return 0; }
@@ -133,8 +131,6 @@ static inline void ata_acpi_set_state(struct ata_port *ap,
 				      pm_message_t state) { }
 static inline void ata_acpi_bind_port(struct ata_port *ap) {}
 static inline void ata_acpi_bind_dev(struct ata_device *dev) {}
-static inline void ata_scsi_acpi_bind(struct ata_device *dev) {}
-static inline void ata_scsi_acpi_unbind(struct ata_device *dev) {}
 #endif
 
 /* libata-scsi.c */

commit 03f7b802b876904971f23f00f562061309e95e08
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Tue Aug 27 14:07:12 2013 -0400

    libata: acpi: Remove ata_dev_acpi_handle stub in libata.h
    
    The ata_dev_acpi_handle is defined in libata-acpi.c and the only
    external user is libata-zpodd.c, which is built when CONFIG_ATA_ACPI
    is set, so there is no need to make an empty stub function for
    ONFIG_ATA_ACPI case in libata.h. It also causes compile errors due to
    acpi_handle is not defined when !CONFIG_ACPI. This patch fixes this
    problem by removing the empty stub.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 3e9cc95a0222..eeeb77845d48 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -133,7 +133,6 @@ static inline void ata_acpi_set_state(struct ata_port *ap,
 				      pm_message_t state) { }
 static inline void ata_acpi_bind_port(struct ata_port *ap) {}
 static inline void ata_acpi_bind_dev(struct ata_device *dev) {}
-static inline acpi_handle ata_dev_acpi_handle(struct ata_device *dev) { return NULL; }
 static inline void ata_scsi_acpi_bind(struct ata_device *dev) {}
 static inline void ata_scsi_acpi_unbind(struct ata_device *dev) {}
 #endif

commit f1bc1e4c44b1b78fe34431936c60759b5aad5e3f
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Fri Aug 23 10:17:54 2013 +0800

    ata: acpi: rework the ata acpi bind support
    
    Binding ACPI handle to SCSI device has several drawbacks, namely:
    1 During ATA device initialization time, ACPI handle will be needed
      while SCSI devices are not created yet. So each time ACPI handle is
      needed, instead of retrieving the handle by ACPI_HANDLE macro,
      a namespace scan is performed to find the handle for the corresponding
      ATA device. This is inefficient, and also expose a restriction on
      calling path not holding any lock.
    2 The binding to SCSI device tree makes code complex, while at the same
      time doesn't bring us any benefit. All ACPI handlings are still done
      in ATA module, not in SCSI.
    
    Rework the ATA ACPI binding code to bind ACPI handle to ATA transport
    devices(ATA port and ATA device). The binding needs to be done only once,
    since the ATA transport devices do not go away with hotplug. And due to
    this, the flush_work call in hotplug handler for ATA bay is no longer
    needed.
    
    Tested on an Intel test platform for binding and runtime power off for
    ODD(ZPODD) and hard disk; on an ASUS S400C for binding and normal boot
    and S3, where its SATA port node has _SDD and _GTF control methods when
    configured as an AHCI controller and its PATA device node has _GTF
    control method when configured as an IDE controller. SATA PMP binding
    and ATA hotplug is not tested.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Tested-by: Dirk Griesbach <spamthis@freenet.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index cc8a6e879dfb..3e9cc95a0222 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -118,9 +118,11 @@ extern void ata_acpi_on_resume(struct ata_port *ap);
 extern int ata_acpi_on_devcfg(struct ata_device *dev);
 extern void ata_acpi_on_disable(struct ata_device *dev);
 extern void ata_acpi_set_state(struct ata_port *ap, pm_message_t state);
-extern int ata_acpi_register(void);
-extern void ata_acpi_unregister(void);
-extern void ata_acpi_hotplug_init(struct ata_host *host);
+extern void ata_acpi_bind_port(struct ata_port *ap);
+extern void ata_acpi_bind_dev(struct ata_device *dev);
+extern acpi_handle ata_dev_acpi_handle(struct ata_device *dev);
+extern void ata_scsi_acpi_bind(struct ata_device *dev);
+extern void ata_scsi_acpi_unbind(struct ata_device *dev);
 #else
 static inline void ata_acpi_dissociate(struct ata_host *host) { }
 static inline int ata_acpi_on_suspend(struct ata_port *ap) { return 0; }
@@ -129,9 +131,11 @@ static inline int ata_acpi_on_devcfg(struct ata_device *dev) { return 0; }
 static inline void ata_acpi_on_disable(struct ata_device *dev) { }
 static inline void ata_acpi_set_state(struct ata_port *ap,
 				      pm_message_t state) { }
-static inline int ata_acpi_register(void) { return 0; }
-static inline void ata_acpi_unregister(void) { }
-static inline void ata_acpi_hotplug_init(struct ata_host *host) {}
+static inline void ata_acpi_bind_port(struct ata_port *ap) {}
+static inline void ata_acpi_bind_dev(struct ata_device *dev) {}
+static inline acpi_handle ata_dev_acpi_handle(struct ata_device *dev) { return NULL; }
+static inline void ata_scsi_acpi_bind(struct ata_device *dev) {}
+static inline void ata_scsi_acpi_unbind(struct ata_device *dev) {}
 #endif
 
 /* libata-scsi.c */

commit 88ba5478837098b71573bb7d6002be33156ea7e4
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Thu Jul 25 13:47:02 2013 +0800

    libata: acpi: remove dead code for ata_acpi_(un)bind
    
    Commit 7381fe737 "libata-acpi: remove redundent code for power resource
    handling" removed ata_acpi_(un)bind but left their prototypes in libata.h,
    so remove them.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 577d902bc4de..cc8a6e879dfb 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -120,8 +120,6 @@ extern void ata_acpi_on_disable(struct ata_device *dev);
 extern void ata_acpi_set_state(struct ata_port *ap, pm_message_t state);
 extern int ata_acpi_register(void);
 extern void ata_acpi_unregister(void);
-extern void ata_acpi_bind(struct ata_device *dev);
-extern void ata_acpi_unbind(struct ata_device *dev);
 extern void ata_acpi_hotplug_init(struct ata_host *host);
 #else
 static inline void ata_acpi_dissociate(struct ata_host *host) { }
@@ -133,8 +131,6 @@ static inline void ata_acpi_set_state(struct ata_port *ap,
 				      pm_message_t state) { }
 static inline int ata_acpi_register(void) { return 0; }
 static inline void ata_acpi_unregister(void) { }
-static inline void ata_acpi_bind(struct ata_device *dev) { }
-static inline void ata_acpi_unbind(struct ata_device *dev) { }
 static inline void ata_acpi_hotplug_init(struct ata_host *host) {}
 #endif
 

commit 44521527be36172864e6e7a6fba4b66e9aa48e40
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Thu Jun 20 09:38:34 2013 +0800

    libata-acpi: add back ACPI based hotplug functionality
    
    Commit 30dcf76acc69 "libata: migrate ACPI code over to new bindings"
    mistakenly dropped the code to register hotplug notificaion handler
    for ATA port/devices, causing regression for people using ATA bay,
    as kernel bug #59871 shows.
    
    Fix this by adding back the hotplug notification handler registration
    code.  Since this code has to be run once and notification needs to
    be installed on every ATA port/devices handle no matter if there is
    actual device attached, we can't do this in binding time for ATA
    device ACPI handle, as the binding only occurs when a SCSI device is
    created, i.e. there is device attached.  So introduce the
    ata_acpi_hotplug_init() function to loop scan all ATA ACPI handles
    and if it is available, install the notificaion handler for it during
    ATA init time.
    
    With the ATA ACPI handle binding to SCSI device tree, it is possible
    now that when the SCSI hotplug work removes the SCSI device, the ACPI
    unbind function will find that the corresponding ACPI device has
    already been deleted by dock driver, causing a scaring message like:
    [  128.263966] scsi 4:0:0:0: Oops, 'acpi_handle' corrupt
    Fix this by waiting for SCSI hotplug task finish in our notificaion
    handler, so that the removal of ACPI device done in ACPI unbind
    function triggered by the removal of SCSI device is run earlier when
    ACPI device is still available.
    
    [rjw: Rebased]
    References: https://bugzilla.kernel.org/show_bug.cgi?id=59871
    Reported-bisected-and-tested-by: Dirk Griesbach <spamthis@freenet.de>
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Cc: 3.6+ <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index c949dd311b2e..577d902bc4de 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -122,6 +122,7 @@ extern int ata_acpi_register(void);
 extern void ata_acpi_unregister(void);
 extern void ata_acpi_bind(struct ata_device *dev);
 extern void ata_acpi_unbind(struct ata_device *dev);
+extern void ata_acpi_hotplug_init(struct ata_host *host);
 #else
 static inline void ata_acpi_dissociate(struct ata_host *host) { }
 static inline int ata_acpi_on_suspend(struct ata_port *ap) { return 0; }
@@ -134,6 +135,7 @@ static inline int ata_acpi_register(void) { return 0; }
 static inline void ata_acpi_unregister(void) { }
 static inline void ata_acpi_bind(struct ata_device *dev) { }
 static inline void ata_acpi_unbind(struct ata_device *dev) { }
+static inline void ata_acpi_hotplug_init(struct ata_host *host) {}
 #endif
 
 /* libata-scsi.c */

commit 213342053db58eabdaddff9c036c2b81ca63c443
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Tue Jan 15 17:21:01 2013 +0800

    libata: handle power transition of ODD
    
    When ata port is runtime suspended, it will check if the ODD attched to
    it is a zero power(ZP) capable ODD and if the ZP capable ODD is in zero
    power ready state. And if this is not the case, the highest acpi state
    will be limited to ACPI_STATE_D3_HOT to avoid powering off the ODD. And
    if the ODD can be powered off, runtime wake capability needs to be
    enabled and powered_off flag will be set to let resume code knows that
    the ODD was in powered off state.
    
    And on resume, before it is powered on, if it was powered off during
    suspend, runtime wake capability needs to be disabled. After it is
    recovered, the ODD is considered functional, post power on processing
    like eject tray if the ODD is drawer type is done, and several ZPODD
    related fields will also be reset.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index b9b2bb1d5dc6..c949dd311b2e 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -242,11 +242,19 @@ static inline bool zpodd_dev_enabled(struct ata_device *dev)
 	return dev->zpodd != NULL;
 }
 void zpodd_on_suspend(struct ata_device *dev);
+bool zpodd_zpready(struct ata_device *dev);
+void zpodd_enable_run_wake(struct ata_device *dev);
+void zpodd_disable_run_wake(struct ata_device *dev);
+void zpodd_post_poweron(struct ata_device *dev);
 #else /* CONFIG_SATA_ZPODD */
 static inline void zpodd_init(struct ata_device *dev) {}
 static inline void zpodd_exit(struct ata_device *dev) {}
 static inline bool zpodd_dev_enabled(struct ata_device *dev) { return false; }
 static inline void zpodd_on_suspend(struct ata_device *dev) {}
+static inline bool zpodd_zpready(struct ata_device *dev) { return false; }
+static inline void zpodd_enable_run_wake(struct ata_device *dev) {}
+static inline void zpodd_disable_run_wake(struct ata_device *dev) {}
+static inline void zpodd_post_poweron(struct ata_device *dev) {}
 #endif /* CONFIG_SATA_ZPODD */
 
 #endif /* __LIBATA_H__ */

commit 3dc67440d99b2c718ef5f1eb1424a9066ffa3fb9
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Tue Jan 15 17:21:00 2013 +0800

    libata: check zero power ready status for ZPODD
    
    Per the Mount Fuji spec, the ODD is considered zero power ready when:
      - For slot type ODD, no media inside;
      - For tray type ODD, no media inside and tray closed.
    
    The information can be retrieved by either the returned information of
    command GET_EVENT_STATUS_NOTIFICATION(the command is used to poll for
    media event) or sense code.
    
    The information provided by the media status byte is not accurate, it
    is possible that after a new disc is just inserted, the status byte
    still returns media not present. So this information can not be used as
    the deciding factor, we use sense code to decide if zpready status is
    true.
    
    When we first sensed the ODD in the zero power ready state, the
    zp_sampled will be set and timestamp will be recoreded. And after ODD
    stayed in this state for some pre-defined period, the ODD is considered
    as power off ready and the zp_ready flag will be set. The zp_ready flag
    serves as the deciding factor other code will use to see if power off is
    OK for the ODD.
    
    The Mount Fuji spec suggests a delay should be used here, to avoid the
    case user ejects the ODD and then instantly inserts a new one again, so
    that we can avoid a power transition. And some ODDs may be slow to place
    its head to the home position after disc is ejected, so a delay here is
    generally a good idea. And the delay time can be changed via the module
    param zpodd_poweroff_delay.
    
    The zero power ready status check is performed in the ata port's runtime
    suspend code path, when port is not frozen yet, as we need to issue some
    IOs to the ODD.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index a21740b4ee11..b9b2bb1d5dc6 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -182,6 +182,9 @@ extern void ata_eh_finish(struct ata_port *ap);
 extern int ata_ering_map(struct ata_ering *ering,
 			 int (*map_fn)(struct ata_ering_entry *, void *),
 		  	 void *arg);
+extern unsigned int atapi_eh_tur(struct ata_device *dev, u8 *r_sense_key);
+extern unsigned int atapi_eh_request_sense(struct ata_device *dev,
+					   u8 *sense_buf, u8 dfl_sense_key);
 
 /* libata-pmp.c */
 #ifdef CONFIG_SATA_PMP
@@ -238,10 +241,12 @@ static inline bool zpodd_dev_enabled(struct ata_device *dev)
 {
 	return dev->zpodd != NULL;
 }
+void zpodd_on_suspend(struct ata_device *dev);
 #else /* CONFIG_SATA_ZPODD */
 static inline void zpodd_init(struct ata_device *dev) {}
 static inline void zpodd_exit(struct ata_device *dev) {}
 static inline bool zpodd_dev_enabled(struct ata_device *dev) { return false; }
+static inline void zpodd_on_suspend(struct ata_device *dev) {}
 #endif /* CONFIG_SATA_ZPODD */
 
 #endif /* __LIBATA_H__ */

commit afe759511808cd5bb508b598007cf0c7b0ca8e08
Author: Aaron Lu <aaron.lu@intel.com>
Date:   Tue Jan 15 17:20:58 2013 +0800

    libata: identify and init ZPODD devices
    
    The ODD can be enabled for ZPODD if the following three conditions are
    satisfied:
    1 The ODD supports device attention;
    2 The platform can runtime power off the ODD through ACPI;
    3 The ODD is either slot type or drawer type.
    For such ODDs, zpodd_init is called and a new structure is allocated for
    it to store ZPODD related stuffs.
    
    And the zpodd_dev_enabled function is used to test if ZPODD is currently
    enabled for this ODD.
    
    A new config CONFIG_SATA_ZPODD is added to selectively build ZPODD code.
    
    Signed-off-by: Aaron Lu <aaron.lu@intel.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 7148a58020b9..a21740b4ee11 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -230,4 +230,18 @@ static inline void ata_sff_exit(void)
 { }
 #endif /* CONFIG_ATA_SFF */
 
+/* libata-zpodd.c */
+#ifdef CONFIG_SATA_ZPODD
+void zpodd_init(struct ata_device *dev);
+void zpodd_exit(struct ata_device *dev);
+static inline bool zpodd_dev_enabled(struct ata_device *dev)
+{
+	return dev->zpodd != NULL;
+}
+#else /* CONFIG_SATA_ZPODD */
+static inline void zpodd_init(struct ata_device *dev) {}
+static inline void zpodd_exit(struct ata_device *dev) {}
+static inline bool zpodd_dev_enabled(struct ata_device *dev) { return false; }
+#endif /* CONFIG_SATA_ZPODD */
+
 #endif /* __LIBATA_H__ */

commit 65fe1f0f66a57380229a4ced844188103135f37b
Author: Shane Huang <shane.huang@amd.com>
Date:   Fri Sep 7 22:40:01 2012 +0800

    ahci: implement aggressive SATA device sleep support
    
    Device Sleep is a feature as described in AHCI 1.3.1 Technical Proposal.
    This feature enables an HBA and SATA storage device to enter the DevSleep
    interface state, enabling lower power SATA-based systems.
    
    Aggressive Device Sleep enables the HBA to assert the DEVSLP signal as
    soon as there are no commands outstanding to the device and the port
    specific Device Sleep idle timer has expired. This enables autonomous
    entry into the DevSleep interface state without waiting for software
    in power sensitive systems.
    
    This patch enables Aggressive Device Sleep only if both host controller
    and device support it.
    
    Tested on AMD reference board together with Device Sleep supported device
    sample.
    
    Signed-off-by: Shane Huang <shane.huang@amd.com>
    Reviewed-by: Aaron Lu <aaron.lwe@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 50e4dff0604e..7148a58020b9 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -165,6 +165,8 @@ extern void ata_eh_about_to_do(struct ata_link *link, struct ata_device *dev,
 			       unsigned int action);
 extern void ata_eh_done(struct ata_link *link, struct ata_device *dev,
 			unsigned int action);
+extern unsigned int ata_read_log_page(struct ata_device *dev, u8 log,
+				      u8 page, void *buf, unsigned int sectors);
 extern void ata_eh_autopsy(struct ata_port *ap);
 const char *ata_get_cmd_descript(u8 command);
 extern void ata_eh_report(struct ata_port *ap);

commit e91df93ebd7bef40d175d51ab7bcbd3b5c4fc212
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Mon Jul 2 12:31:19 2012 +0800

    libata-acpi: add missing inlines in libata.h
    
    Adds inline for ata_acpi_unregister/ata_acpi_bind/ata_acpi_unbind
    in drivers/ata/libata.h for !CONFIG_ATA_ACPI to fix below warnings.
    
    warning: 'ata_acpi_unregister' defined but not used [-Wunused-function]
    warning: 'ata_acpi_bind' defined but not used [-Wunused-function]
    warning: 'ata_acpi_unbind' defined but not used [-Wunused-function]
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 44a7939b5bb6..50e4dff0604e 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -131,9 +131,9 @@ static inline void ata_acpi_on_disable(struct ata_device *dev) { }
 static inline void ata_acpi_set_state(struct ata_port *ap,
 				      pm_message_t state) { }
 static inline int ata_acpi_register(void) { return 0; }
-static void ata_acpi_unregister(void) { }
-static void ata_acpi_bind(struct ata_device *dev) { }
-static void ata_acpi_unbind(struct ata_device *dev) { }
+static inline void ata_acpi_unregister(void) { }
+static inline void ata_acpi_bind(struct ata_device *dev) { }
+static inline void ata_acpi_unbind(struct ata_device *dev) { }
 #endif
 
 /* libata-scsi.c */

commit 3bd46600a7a7e938c54df8cdbac9910668c7dfb0
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Mon Jun 25 16:13:06 2012 +0800

    libata-acpi: add ata port runtime D3Cold support
    
    ATA port may support runtime D3Cold state, for example, Zero-power ODD case.
    This patch adds wakeup notifier and enable/disable run_wake during
    supend/resume.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index b0d5294982eb..44a7939b5bb6 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -120,6 +120,8 @@ extern void ata_acpi_on_disable(struct ata_device *dev);
 extern void ata_acpi_set_state(struct ata_port *ap, pm_message_t state);
 extern int ata_acpi_register(void);
 extern void ata_acpi_unregister(void);
+extern void ata_acpi_bind(struct ata_device *dev);
+extern void ata_acpi_unbind(struct ata_device *dev);
 #else
 static inline void ata_acpi_dissociate(struct ata_host *host) { }
 static inline int ata_acpi_on_suspend(struct ata_port *ap) { return 0; }
@@ -130,6 +132,8 @@ static inline void ata_acpi_set_state(struct ata_port *ap,
 				      pm_message_t state) { }
 static inline int ata_acpi_register(void) { return 0; }
 static void ata_acpi_unregister(void) { }
+static void ata_acpi_bind(struct ata_device *dev) { }
+static void ata_acpi_unbind(struct ata_device *dev) { }
 #endif
 
 /* libata-scsi.c */

commit 30dcf76acc695cbd2fa919e294670fe9552e16e7
Author: Matthew Garrett <mjg@redhat.com>
Date:   Mon Jun 25 16:13:04 2012 +0800

    libata: migrate ACPI code over to new bindings
    
    Now that we have the ability to directly glue the ACPI namespace to the
    driver model in libata, we don't need the custom code to handle the same
    thing. Remove it and migrate the functions over to the new code.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Holger Macht <holger@homac.de>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 7f48b602b01b..b0d5294982eb 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -112,9 +112,6 @@ extern void __ata_port_probe(struct ata_port *ap);
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
 extern unsigned int ata_acpi_gtf_filter;
-
-extern void ata_acpi_associate_sata_port(struct ata_port *ap);
-extern void ata_acpi_associate(struct ata_host *host);
 extern void ata_acpi_dissociate(struct ata_host *host);
 extern int ata_acpi_on_suspend(struct ata_port *ap);
 extern void ata_acpi_on_resume(struct ata_port *ap);
@@ -124,8 +121,6 @@ extern void ata_acpi_set_state(struct ata_port *ap, pm_message_t state);
 extern int ata_acpi_register(void);
 extern void ata_acpi_unregister(void);
 #else
-static inline void ata_acpi_associate_sata_port(struct ata_port *ap) { }
-static inline void ata_acpi_associate(struct ata_host *host) { }
 static inline void ata_acpi_dissociate(struct ata_host *host) { }
 static inline int ata_acpi_on_suspend(struct ata_port *ap) { return 0; }
 static inline void ata_acpi_on_resume(struct ata_port *ap) { }

commit 6b66d95895c149cbc04d4fac5a2f5477c543a8ae
Author: Matthew Garrett <mjg@redhat.com>
Date:   Mon Jun 25 16:13:03 2012 +0800

    libata: bind the Linux device tree to the ACPI device tree
    
    Associate the ACPI device tree and libata devices.
    This patch uses the generic ACPI glue framework to do so.
    
    Signed-off-by: Matthew Garrett <mjg@redhat.com>
    Signed-off-by: Holger Macht <holger@homac.de>
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 9d0fd0b71852..7f48b602b01b 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -107,6 +107,8 @@ extern const char *sata_spd_string(unsigned int spd);
 extern int ata_port_probe(struct ata_port *ap);
 extern void __ata_port_probe(struct ata_port *ap);
 
+#define to_ata_port(d) container_of(d, struct ata_port, tdev)
+
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
 extern unsigned int ata_acpi_gtf_filter;
@@ -119,6 +121,8 @@ extern void ata_acpi_on_resume(struct ata_port *ap);
 extern int ata_acpi_on_devcfg(struct ata_device *dev);
 extern void ata_acpi_on_disable(struct ata_device *dev);
 extern void ata_acpi_set_state(struct ata_port *ap, pm_message_t state);
+extern int ata_acpi_register(void);
+extern void ata_acpi_unregister(void);
 #else
 static inline void ata_acpi_associate_sata_port(struct ata_port *ap) { }
 static inline void ata_acpi_associate(struct ata_host *host) { }
@@ -129,6 +133,8 @@ static inline int ata_acpi_on_devcfg(struct ata_device *dev) { return 0; }
 static inline void ata_acpi_on_disable(struct ata_device *dev) { }
 static inline void ata_acpi_set_state(struct ata_port *ap,
 				      pm_message_t state) { }
+static inline int ata_acpi_register(void) { return 0; }
+static void ata_acpi_unregister(void) { }
 #endif
 
 /* libata-scsi.c */

commit 85d6725b7c0d7e3fa4261fdd4c020be4224fc9f1
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sat Mar 10 23:28:46 2012 -0800

    libata: make ata_print_id atomic
    
    This variable is incremented from multiple contexts (module_init via
    libata-lldds and the libsas discovery thread).  Make it atomic to head
    off any chance of libsas and libata creating duplicate ids.
    
    Acked-by: Jacek Danecki <jacek.danecki@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 2e26fcaf635b..9d0fd0b71852 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -53,7 +53,7 @@ enum {
 	ATA_DNXFER_QUIET	= (1 << 31),
 };
 
-extern unsigned int ata_print_id;
+extern atomic_t ata_print_id;
 extern int atapi_passthru16;
 extern int libata_fua;
 extern int libata_noacpi;

commit 9508a66f898d46e726a318469312b45e0b1d078b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jan 18 20:47:01 2012 -0800

    [SCSI] libsas: async ata scanning
    
    libsas ata error handling is already async but this does not help the
    scan case.  Move initial link recovery out from under host->scan_mutex,
    and delay synchronization with eh until after all port probe/recovery
    work has been queued.
    
    Device ordering is maintained with scan order by still calling
    sas_rphy_add() in order of domain discovery.
    
    Since we now scan the domain list when invoking libata-eh we need to be
    careful to check for fully initialized ata ports.
    
    Acked-by: Jack Wang <jack_wang@usish.com>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 1fab235ee516..2e26fcaf635b 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -105,6 +105,7 @@ extern int ata_cmd_ioctl(struct scsi_device *scsidev, void __user *arg);
 extern struct ata_port *ata_port_alloc(struct ata_host *host);
 extern const char *sata_spd_string(unsigned int spd);
 extern int ata_port_probe(struct ata_port *ap);
+extern void __ata_port_probe(struct ata_port *ap);
 
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI

commit 81c757bc696284f39f07766f0c2ca67af64ce9bd
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Dec 2 16:07:01 2011 -0800

    [SCSI] libsas: execute transport link resets with libata-eh via host workqueue
    
    Link resets leave ata affiliations intact, so arrange for libsas to make
    an effort to avoid dropping the device due to a slow-to-recover link.
    Towards this end carry out reset in the host workqueue so that it can
    check for ata devices and kick the reset request to libata.  Hard
    resets, in contrast, bypass libata since they are meant for associating
    an ata device with another initiator in the domain (tears down
    affiliations).
    
    Need to add a new transport_sas_phy_reset() since the current
    sas_phy_reset() is a utility function to libsas lldds.  They are not
    prepared for it to loop back into eh.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 814486d35c44..1fab235ee516 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -151,7 +151,6 @@ extern void ata_eh_acquire(struct ata_port *ap);
 extern void ata_eh_release(struct ata_port *ap);
 extern enum blk_eh_timer_return ata_scsi_timed_out(struct scsi_cmnd *cmd);
 extern void ata_scsi_error(struct Scsi_Host *host);
-extern void ata_port_wait_eh(struct ata_port *ap);
 extern void ata_eh_fastdrain_timerfn(unsigned long arg);
 extern void ata_qc_schedule_eh(struct ata_queued_cmd *qc);
 extern void ata_dev_disable(struct ata_device *dev);

commit 5ef41082912bdfcb33fa53b8dba2ad17dea2ef90
Author: Lin Ming <ming.m.lin@intel.com>
Date:   Mon Dec 5 09:20:27 2011 +0800

    ata: add ata port system PM callbacks
    
    Change ata_host_request_pm to ata_port_request_pm which performs
    port suspend/resume.
    
    Add ata port type driver which implements port PM callbacks.
    
    Signed-off-by: Lin Ming <ming.m.lin@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 773de97988a2..814486d35c44 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -58,6 +58,7 @@ extern int atapi_passthru16;
 extern int libata_fua;
 extern int libata_noacpi;
 extern int libata_allow_tpm;
+extern struct device_type ata_port_type;
 extern struct ata_link *ata_dev_phys_link(struct ata_device *dev);
 extern void ata_force_cbl(struct ata_port *ap);
 extern u64 ata_tf_to_lba(const struct ata_taskfile *tf);

commit 238c9cf9ea88bbbb9fd0f60c2cc9511c10b4585c
Author: James Bottomley <James.Bottomley@suse.de>
Date:   Sun Jan 23 08:28:33 2011 -0600

    libata: plumb sas port scan into standard libata paths
    
    The function ata_sas_port_init() has always really done its own thing.
    However, as a precursor to moving to the libata new eh, it has to be
    properly using the standard libata scan paths.  This means separating
    the current libata scan paths into pieces which can be shared with
    libsas and pieces which cant (really just the async call and the host
    scan).
    
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index a9be110dbf51..773de97988a2 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -103,6 +103,7 @@ extern int ata_task_ioctl(struct scsi_device *scsidev, void __user *arg);
 extern int ata_cmd_ioctl(struct scsi_device *scsidev, void __user *arg);
 extern struct ata_port *ata_port_alloc(struct ata_host *host);
 extern const char *sata_spd_string(unsigned int spd);
+extern int ata_port_probe(struct ata_port *ap);
 
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI

commit c0c362b60e259e3480a36ef70280d545818844f0
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Sep 6 17:57:14 2010 +0200

    libata: implement cross-port EH exclusion
    
    In libata, the non-EH code paths should always take and release
    ap->lock explicitly when accessing hardware or shared data structures.
    However, once EH is active, it's assumed that the port is owned by EH
    and EH methods don't explicitly take ap->lock unless race from irq
    handler or other code paths are expected.  However, libata EH didn't
    guarantee exclusion among EHs for ports of the same host.  IOW,
    multiple EHs may execute in parallel on multiple ports of the same
    controller.
    
    In many cases, especially in SATA, the ports are completely
    independent of each other and this doesn't cause problems; however,
    there are cases where different ports share the same resource, which
    lead to obscure timing related bugs such as the one fixed by commit
    213373cf (ata_piix: fix locking around SIDPR access).
    
    This patch implements exclusion among EHs of the same host.  When EH
    begins, it acquires per-host EH ownership by calling ata_eh_acquire().
    When EH finishes, the ownership is released by calling
    ata_eh_release().  EH ownership is also released whenever the EH
    thread goes to sleep from ata_msleep() or explicitly and reacquired
    after waking up.
    
    This ensures that while EH is actively accessing the hardware, it has
    exclusive access to it while allowing EHs to interleave and progress
    in parallel as they hit waiting stages, which dominate the time spent
    in EH.  This achieves cross-port EH exclusion without pervasive and
    fragile changes while still allowing parallel EH for the most part.
    
    This was first reported by yuanding02@gmail.com more than three years
    ago in the following bugzilla.  :-)
    
      https://bugzilla.kernel.org/show_bug.cgi?id=8223
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Reported-by: yuanding02@gmail.com
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 7c070a4b1c08..a9be110dbf51 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -145,6 +145,8 @@ extern int ata_scsi_user_scan(struct Scsi_Host *shost, unsigned int channel,
 /* libata-eh.c */
 extern unsigned long ata_internal_cmd_timeout(struct ata_device *dev, u8 cmd);
 extern void ata_internal_cmd_timed_out(struct ata_device *dev, u8 cmd);
+extern void ata_eh_acquire(struct ata_port *ap);
+extern void ata_eh_release(struct ata_port *ap);
 extern enum blk_eh_timer_return ata_scsi_timed_out(struct scsi_cmnd *cmd);
 extern void ata_scsi_error(struct Scsi_Host *host);
 extern void ata_port_wait_eh(struct ata_port *ap);

commit 6c8ea89cecd780faa4f4c8ed8b3b6ab88f9fa841
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 1 17:50:07 2010 +0200

    libata: implement LPM support for port multipliers
    
    Port multipliers can do DIPM on fan-out links fine.  Implement support
    for it.  Tested w/ SIMG 57xx and marvell PMPs.  Both the host and
    fan-out links enter power save modes nicely.
    
    SIMG 37xx and 47xx report link offline on SStatus causing EH to detach
    the devices.  Blacklisted.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 55a6f413a550..7c070a4b1c08 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -176,6 +176,8 @@ extern int ata_ering_map(struct ata_ering *ering,
 #ifdef CONFIG_SATA_PMP
 extern int sata_pmp_scr_read(struct ata_link *link, int reg, u32 *val);
 extern int sata_pmp_scr_write(struct ata_link *link, int reg, u32 val);
+extern int sata_pmp_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,
+			    unsigned hints);
 extern int sata_pmp_attach(struct ata_device *dev);
 #else /* CONFIG_SATA_PMP */
 static inline int sata_pmp_scr_read(struct ata_link *link, int reg, u32 *val)
@@ -188,6 +190,12 @@ static inline int sata_pmp_scr_write(struct ata_link *link, int reg, u32 val)
 	return -EINVAL;
 }
 
+static inline int sata_pmp_set_lpm(struct ata_link *link,
+				   enum ata_lpm_policy policy, unsigned hints)
+{
+	return -EINVAL;
+}
+
 static inline int sata_pmp_attach(struct ata_device *dev)
 {
 	return -EINVAL;

commit 6b7ae9545ad9875a289f4191c0216b473e313cb9
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 1 17:50:06 2010 +0200

    libata: reimplement link power management
    
    The current LPM implementation has the following issues.
    
    * Operation order isn't well thought-out.  e.g. HIPM should be
      configured after IPM in SControl is properly configured.  Not the
      other way around.
    
    * Suspend/resume paths call ata_lpm_enable/disable() which must only
      be called from EH context directly.  Also, ata_lpm_enable/disable()
      were called whether LPM was in use or not.
    
    * Implementation is per-port when it should be per-link.  As a result,
      it can't be used for controllers with slave links or PMP.
    
    * LPM state isn't managed consistently.  After a link reset for
      whatever reason including suspend/resume the actual LPM state would
      be reset leaving ap->lpm_policy inconsistent.
    
    * Generic/driver-specific logic boundary isn't clear.  Currently,
      libahci has to mangle stuff which libata EH proper should be
      handling.  This makes the implementation unnecessarily complex and
      fragile.
    
    * Tied to ALPM.  Doesn't consider DIPM only cases and doesn't check
      whether the device allows HIPM.
    
    * Error handling isn't implemented.
    
    Given the extent of mismatch with the rest of libata, I don't think
    trying to fix it piecewise makes much sense.  This patch reimplements
    LPM support.
    
    * The new implementation is per-link.  The target policy is still
      port-wide (ap->target_lpm_policy) but all the mechanisms and states
      are per-link and integrate well with the rest of link abstraction
      and can work with slave and PMP links.
    
    * Core EH has proper control of LPM state.  LPM state is reconfigured
      when and only when reconfiguration is necessary.  It makes sure that
      LPM state is reset when probing for new device on the link.
      Controller agnostic logic is now implemented in libata EH proper and
      driver implementation only has to deal with controller specifics.
    
    * Proper error handling.  LPM config failure is attributed to the
      device on the link and LPM is disabled for the link if it fails
      repeatedly.
    
    * ops->enable/disable_pm() are replaced with single ops->set_lpm()
      which takes @policy and @hints.  This simplifies driver specific
      implementation.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 65b6a73c3ac7..55a6f413a550 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -102,10 +102,6 @@ extern int sata_link_init_spd(struct ata_link *link);
 extern int ata_task_ioctl(struct scsi_device *scsidev, void __user *arg);
 extern int ata_cmd_ioctl(struct scsi_device *scsidev, void __user *arg);
 extern struct ata_port *ata_port_alloc(struct ata_host *host);
-extern void ata_dev_enable_pm(struct ata_device *dev,
-			      enum ata_lpm_policy policy);
-extern void ata_lpm_schedule(struct ata_port *ap,
-			     enum ata_lpm_policy policy);
 extern const char *sata_spd_string(unsigned int spd);
 
 /* libata-acpi.c */

commit 1152b2617a6e1943b6b82e07c962950e56f1000c
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 1 17:50:05 2010 +0200

    libata: implement sata_link_scr_lpm() and make ata_dev_set_feature() global
    
    Link power management is about to be reimplemented.  Prepare for it.
    
    * Implement sata_link_scr_lpm().
    
    * Drop static from ata_dev_set_feature() and make it available to
      other libata files.
    
    * Trivial whitespace adjustments.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 1471462e3e3c..65b6a73c3ac7 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -86,6 +86,8 @@ extern int ata_dev_revalidate(struct ata_device *dev, unsigned int new_class,
 extern int ata_dev_configure(struct ata_device *dev);
 extern int sata_down_spd_limit(struct ata_link *link, u32 spd_limit);
 extern int ata_down_xfermask_limit(struct ata_device *dev, unsigned int sel);
+extern unsigned int ata_dev_set_feature(struct ata_device *dev,
+					u8 enable, u8 feature);
 extern void ata_sg_clean(struct ata_queued_cmd *qc);
 extern void ata_qc_free(struct ata_queued_cmd *qc);
 extern void ata_qc_issue(struct ata_queued_cmd *qc);

commit c93b263e0d4fa8ce5fec0142a98196d1a127e845
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 1 17:50:04 2010 +0200

    libata: clean up lpm related symbols and sysfs show/store functions
    
    Link power management related symbols are in confusing state w/ mixed
    usages of lpm, ipm and pm.  This patch cleans up lpm related symbols
    and sysfs show/store functions as follows.
    
    * lpm states - NOT_AVAILABLE, MIN_POWER, MAX_PERFORMANCE and
      MEDIUM_POWER are renamed to ATA_LPM_UNKNOWN and
      ATA_LPM_{MIN|MAX|MED}_POWER.
    
    * Pre/postfixes are unified to lpm.
    
    * sysfs show/store functions for link_power_management_policy were
      curiously named get/put and unnecessarily complex.  Renamed to
      show/store and simplified.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 142102b94df5..1471462e3e3c 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -100,8 +100,10 @@ extern int sata_link_init_spd(struct ata_link *link);
 extern int ata_task_ioctl(struct scsi_device *scsidev, void __user *arg);
 extern int ata_cmd_ioctl(struct scsi_device *scsidev, void __user *arg);
 extern struct ata_port *ata_port_alloc(struct ata_host *host);
-extern void ata_dev_enable_pm(struct ata_device *dev, enum link_pm policy);
-extern void ata_lpm_schedule(struct ata_port *ap, enum link_pm);
+extern void ata_dev_enable_pm(struct ata_device *dev,
+			      enum ata_lpm_policy policy);
+extern void ata_lpm_schedule(struct ata_port *ap,
+			     enum ata_lpm_policy policy);
 extern const char *sata_spd_string(unsigned int spd);
 
 /* libata-acpi.c */

commit d9027470b88631d0956ac37cdadfdeb9cdcf2c99
Author: Gwendal Grignou <gwendal@google.com>
Date:   Tue May 25 12:31:38 2010 -0700

    [libata] Add ATA transport class
    
    This is a scheleton for libata transport class.
    All information is read only, exporting information from libata:
    - ata_port class: one per ATA port
    - ata_link class: one per ATA port or 15 for SATA Port Multiplier
    - ata_device class: up to 2 for PATA link, usually one for SATA.
    
    Signed-off-by: Gwendal Grignou <gwendal@google.com>
    Reviewed-by: Grant Grundler <grundler@google.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 9ce1ecc63e39..142102b94df5 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -102,6 +102,7 @@ extern int ata_cmd_ioctl(struct scsi_device *scsidev, void __user *arg);
 extern struct ata_port *ata_port_alloc(struct ata_host *host);
 extern void ata_dev_enable_pm(struct ata_device *dev, enum link_pm policy);
 extern void ata_lpm_schedule(struct ata_port *ap, enum link_pm);
+extern const char *sata_spd_string(unsigned int spd);
 
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
@@ -137,6 +138,9 @@ extern void ata_scsi_hotplug(struct work_struct *work);
 extern void ata_schedule_scsi_eh(struct Scsi_Host *shost);
 extern void ata_scsi_dev_rescan(struct work_struct *work);
 extern int ata_bus_probe(struct ata_port *ap);
+extern int ata_scsi_user_scan(struct Scsi_Host *shost, unsigned int channel,
+			      unsigned int id, unsigned int lun);
+
 
 /* libata-eh.c */
 extern unsigned long ata_internal_cmd_timeout(struct ata_device *dev, u8 cmd);
@@ -164,6 +168,9 @@ extern int ata_eh_recover(struct ata_port *ap, ata_prereset_fn_t prereset,
 			  ata_postreset_fn_t postreset,
 			  struct ata_link **r_failed_disk);
 extern void ata_eh_finish(struct ata_port *ap);
+extern int ata_ering_map(struct ata_ering *ering,
+			 int (*map_fn)(struct ata_ering_entry *, void *),
+		  	 void *arg);
 
 /* libata-pmp.c */
 #ifdef CONFIG_SATA_PMP

commit ad72cf9885c536e3adae03f8337557ac9dd1e4bb
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jul 2 10:03:52 2010 +0200

    libata: take advantage of cmwq and remove concurrency limitations
    
    libata has two concurrency related limitations.
    
    a. ata_wq which is used for polling PIO has single thread per CPU.  If
       there are multiple devices doing polling PIO on the same CPU, they
       can't be executed simultaneously.
    
    b. ata_aux_wq which is used for SCSI probing has single thread.  In
       cases where SCSI probing is stalled for extended period of time
       which is possible for ATAPI devices, this will stall all probing.
    
    #a is solved by increasing maximum concurrency of ata_wq.  Please note
    that polling PIO might be used under allocation path and thus needs to
    be served by a separate wq with a rescuer.
    
    #b is solved by using the default wq instead and achieving exclusion
    via per-port mutex.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 4b84ed60324a..9ce1ecc63e39 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -54,7 +54,6 @@ enum {
 };
 
 extern unsigned int ata_print_id;
-extern struct workqueue_struct *ata_aux_wq;
 extern int atapi_passthru16;
 extern int libata_fua;
 extern int libata_noacpi;

commit fe06e5f9b7c61dc567edace3f4909672067f7d7e
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 10 21:41:39 2010 +0200

    libata-sff: separate out BMDMA EH
    
    Some of error handling logic in ata_sff_error_handler() and all of
    ata_sff_post_internal_cmd() are for BMDMA.  Create
    ata_bmdma_error_handler() and ata_bmdma_post_internal_cmd() and move
    BMDMA part into those.
    
    While at it, change DMA protocol check to ata_is_dma(), fix
    post_internal_cmd to call ap->ops->bmdma_stop instead of directly
    calling ata_bmdma_stop() and open code hardreset selection so that
    ata_std_error_handler() doesn't have to know about sff hardreset.
    
    As these two functions are BMDMA specific, there's no reason to check
    for bmdma_addr before calling bmdma methods if the protocol of the
    failed command is DMA.  sata_mv and pata_mpc52xx now don't need to set
    .post_internal_cmd to ATA_OP_NULL and pata_icside and sata_qstor don't
    need to set it to their bmdma_stop routines.
    
    ata_sff_post_internal_cmd() becomes noop and is removed.
    
    This fixes p3 described in clean-up-BMDMA-initialization patch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 002390cdc041..4b84ed60324a 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -38,17 +38,6 @@ struct ata_scsi_args {
 	void			(*done)(struct scsi_cmnd *);
 };
 
-static inline int ata_is_builtin_hardreset(ata_reset_fn_t reset)
-{
-	if (reset == sata_std_hardreset)
-		return 1;
-#ifdef CONFIG_ATA_SFF
-	if (reset == sata_sff_hardreset)
-		return 1;
-#endif
-	return 0;
-}
-
 /* libata-core.c */
 enum {
 	/* flags for ata_dev_read_id() */

commit c429137a67b82788d24682153bb9c96501a9ef34
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 10 21:41:38 2010 +0200

    libata-sff: port_task is SFF specific
    
    port_task is tightly bound to the standard SFF PIO HSM implementation.
    Using it for any other purpose would be error-prone and there's no
    such user and if some drivers need such feature, it would be much
    better off using its own.  Move it inside CONFIG_ATA_SFF and rename it
    to sff_pio_task.
    
    The only function which is exposed to the core layer is
    ata_sff_flush_pio_task() which is renamed from ata_port_flush_task()
    and now also takes care of resetting hsm_task_state to HSM_ST_IDLE,
    which is possible as it's now specific to PIO HSM.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index d89502f3123a..002390cdc041 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -79,7 +79,6 @@ extern int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
 			   u64 block, u32 n_block, unsigned int tf_flags,
 			   unsigned int tag);
 extern u64 ata_tf_read_block(struct ata_taskfile *tf, struct ata_device *dev);
-extern void ata_port_flush_task(struct ata_port *ap);
 extern unsigned ata_exec_internal(struct ata_device *dev,
 				  struct ata_taskfile *tf, const u8 *cdb,
 				  int dma_dir, void *buf, unsigned int buflen,
@@ -202,11 +201,13 @@ static inline int sata_pmp_attach(struct ata_device *dev)
 
 /* libata-sff.c */
 #ifdef CONFIG_ATA_SFF
-extern void ata_pio_task(struct work_struct *work);
+extern void ata_sff_flush_pio_task(struct ata_port *ap);
 extern void ata_sff_port_init(struct ata_port *ap);
 extern int ata_sff_init(void);
 extern void ata_sff_exit(void);
 #else /* CONFIG_ATA_SFF */
+static inline void ata_sff_flush_pio_task(struct ata_port *ap)
+{ }
 static inline void ata_sff_port_init(struct ata_port *ap)
 { }
 static inline int ata_sff_init(void)

commit 270390e1ae1818b111543b8bfffa08095d73c1a5
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 10 21:41:35 2010 +0200

    libata-sff: introduce ata_sff_init/exit() and ata_sff_port_init()
    
    In preparation of proper SFF/BMDMA separation, introduce
    ata_sff_init/exit() and ata_sff_port_init().  These functions
    currently don't do anything.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 132da80aa23a..d89502f3123a 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -203,6 +203,16 @@ static inline int sata_pmp_attach(struct ata_device *dev)
 /* libata-sff.c */
 #ifdef CONFIG_ATA_SFF
 extern void ata_pio_task(struct work_struct *work);
+extern void ata_sff_port_init(struct ata_port *ap);
+extern int ata_sff_init(void);
+extern void ata_sff_exit(void);
+#else /* CONFIG_ATA_SFF */
+static inline void ata_sff_port_init(struct ata_port *ap)
+{ }
+static inline int ata_sff_init(void)
+{ return 0; }
+static inline void ata_sff_exit(void)
+{ }
 #endif /* CONFIG_ATA_SFF */
 
 #endif /* __LIBATA_H__ */

commit c7a8209f766961eea4cfc6f22d2d6e06ef63546c
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 10 21:41:29 2010 +0200

    libata-sff: kill unused prototype and make ata_dev_select() static
    
    ata_irq_on() was renamed to ata_sff_irq_on() and exported a while ago
    but prototype for the original function lingered in
    drivers/ata/libata.h.  Kill it.  Also, ata_dev_select() is only used
    inside drivers/ata/libata-sff.c.  Make it static.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 823e63096362..132da80aa23a 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -202,9 +202,6 @@ static inline int sata_pmp_attach(struct ata_device *dev)
 
 /* libata-sff.c */
 #ifdef CONFIG_ATA_SFF
-extern void ata_dev_select(struct ata_port *ap, unsigned int device,
-                           unsigned int wait, unsigned int can_sleep);
-extern u8 ata_irq_on(struct ata_port *ap);
 extern void ata_pio_task(struct work_struct *work);
 #endif /* CONFIG_ATA_SFF */
 

commit 110f66d25c33c2259b1125255fa7063ab07b8340
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 16 04:17:28 2009 +0900

    libata: make gtf_filter per-dev
    
    Add ->gtf_filter to ata_device and set it to ata_acpi_gtf_filter when
    initializing ata_link.  This is to allow quirks which apply different
    gtf filters.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index be8e2628f82c..823e63096362 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -118,6 +118,8 @@ extern void ata_lpm_schedule(struct ata_port *ap, enum link_pm);
 
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
+extern unsigned int ata_acpi_gtf_filter;
+
 extern void ata_acpi_associate_sata_port(struct ata_port *ap);
 extern void ata_acpi_associate(struct ata_host *host);
 extern void ata_acpi_dissociate(struct ata_host *host);

commit 6521148c6449724c3b707820b9c535c7e8b8afcd
Author: Robert Hancock <hancockrwd@gmail.com>
Date:   Tue Jul 14 20:43:39 2009 -0600

    libata: add command name parsing for error output
    
    This patch improve libata's output for error/notification messages
    to allow easier comprehension and debugging:
    
    When ATAPI commands issued through the SCSI layer fail, use SCSI
    functions to print the CDB in human-readable form instead of just
    dumping out the CDB in hex.
    
    Print out the name of the failed command (as defined by the ATA
    specification) in error handling output along with the raw register
    contents.
    
    When reporting status of ACPI taskfile commands executed on resume,
    also output the names of the commands being executed (or not) in
    readable form.
    
    Since the extra data for printing command names increases kernel
    size slightly, a config option has been added to allow disabling
    command name output (as well as some of the error register parsing)
    for those highly sensitive to kernel text size.
    
    Signed-off-by: Robert Hancock <hancockrwd@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 89a1e0018e71..be8e2628f82c 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -164,6 +164,7 @@ extern void ata_eh_about_to_do(struct ata_link *link, struct ata_device *dev,
 extern void ata_eh_done(struct ata_link *link, struct ata_device *dev,
 			unsigned int action);
 extern void ata_eh_autopsy(struct ata_port *ap);
+const char *ata_get_cmd_descript(u8 command);
 extern void ata_eh_report(struct ata_port *ap);
 extern int ata_eh_reset(struct ata_link *link, int classify,
 			ata_prereset_fn_t prereset, ata_reset_fn_t softreset,

commit 1a660164c291f41b2aa853a7269b310933574ef9
Author: Mark Lord <mlord@pobox.com>
Date:   Wed Feb 25 15:18:32 2009 -0500

    [libata] Export ata_pio_queue_task() so that it can be used from sata_mv.
    
    Signed-off-by: Mark Lord <mlord@pobox.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index cea8014cd87e..89a1e0018e71 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -79,8 +79,6 @@ extern int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
 			   u64 block, u32 n_block, unsigned int tf_flags,
 			   unsigned int tag);
 extern u64 ata_tf_read_block(struct ata_taskfile *tf, struct ata_device *dev);
-extern void ata_pio_queue_task(struct ata_port *ap, void *data,
-			       unsigned long delay);
 extern void ata_port_flush_task(struct ata_port *ap);
 extern unsigned ata_exec_internal(struct ata_device *dev,
 				  struct ata_taskfile *tf, const u8 *cdb,

commit a07d499b4759881db1359dd8812eecd00b0e0a28
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jan 29 20:31:33 2009 +0900

    libata: add @spd_limit to sata_down_spd_limit()
    
    Add @spd_limit to sata_down_spd_limit() so that the caller can specify
    the SPD limit it wants.  This parameter doesn't get in the way even
    when it's too low.  The closest possible limit is applied.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 0a6f5be15112..cea8014cd87e 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -99,7 +99,7 @@ extern int ata_dev_reread_id(struct ata_device *dev, unsigned int readid_flags);
 extern int ata_dev_revalidate(struct ata_device *dev, unsigned int new_class,
 			      unsigned int readid_flags);
 extern int ata_dev_configure(struct ata_device *dev);
-extern int sata_down_spd_limit(struct ata_link *link);
+extern int sata_down_spd_limit(struct ata_link *link, u32 spd_limit);
 extern int ata_down_xfermask_limit(struct ata_device *dev, unsigned int sel);
 extern void ata_sg_clean(struct ata_queued_cmd *qc);
 extern void ata_qc_free(struct ata_queued_cmd *qc);

commit 678afac678061ee41bc3007885003c125912a8e2
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jan 29 20:31:30 2009 +0900

    libata: move ata_dev_disable() to libata-eh.c
    
    ata_dev_disable() is about to be more tightly integrated into EH
    logic.  Move it to libata-eh.c.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index fe2839e58774..0a6f5be15112 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -79,7 +79,6 @@ extern int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
 			   u64 block, u32 n_block, unsigned int tf_flags,
 			   unsigned int tag);
 extern u64 ata_tf_read_block(struct ata_taskfile *tf, struct ata_device *dev);
-extern void ata_dev_disable(struct ata_device *dev);
 extern void ata_pio_queue_task(struct ata_port *ap, void *data,
 			       unsigned long delay);
 extern void ata_port_flush_task(struct ata_port *ap);
@@ -160,6 +159,7 @@ extern void ata_scsi_error(struct Scsi_Host *host);
 extern void ata_port_wait_eh(struct ata_port *ap);
 extern void ata_eh_fastdrain_timerfn(unsigned long arg);
 extern void ata_qc_schedule_eh(struct ata_queued_cmd *qc);
+extern void ata_dev_disable(struct ata_device *dev);
 extern void ata_eh_detach_dev(struct ata_device *dev);
 extern void ata_eh_about_to_do(struct ata_link *link, struct ata_device *dev,
 			       unsigned int action);

commit 8a8bc22332ee6ea49137508467a76aa7f4367719
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 10 14:48:21 2008 +0900

    libata: revert convert-to-block-tagging patches
    
    This patch reverts the following three commits which convert libata to
    use block layer tagging.
    
     43a49cbdf31e812c0d8f553d433b09b421f5d52c
     e013e13bf605b9e6b702adffbe2853cfc60e7806
     2fca5ccf97d2c28bcfce44f5b07d85e74e3cd18e
    
    Although using block layer tagging is the right direction, due to the
    tight coupling among tag number, data structure allocation and
    hardware command slot allocation, libata doesn't work correctly with
    the current conversion.
    
    The biggest problem is guaranteeing that tag 0 is always used for
    non-NCQ commands.  Due to the way blk-tag is implemented and how SCSI
    starts and finishes requests, such guarantee can't be made.  I'm not
    sure whether this would actually break any low level driver but it
    doesn't look like a good idea to break such assumption given the
    frailty of ATA controllers.
    
    So, for the time being, keep using the old dumb in-libata qc
    allocation.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Jens Axobe <jens.axboe@oracle.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index d3831d39bdaa..fe2839e58774 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -74,7 +74,7 @@ extern struct ata_link *ata_dev_phys_link(struct ata_device *dev);
 extern void ata_force_cbl(struct ata_port *ap);
 extern u64 ata_tf_to_lba(const struct ata_taskfile *tf);
 extern u64 ata_tf_to_lba48(const struct ata_taskfile *tf);
-extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev, int tag);
+extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev);
 extern int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
 			   u64 block, u32 n_block, unsigned int tf_flags,
 			   unsigned int tag);
@@ -103,6 +103,7 @@ extern int ata_dev_configure(struct ata_device *dev);
 extern int sata_down_spd_limit(struct ata_link *link);
 extern int ata_down_xfermask_limit(struct ata_device *dev, unsigned int sel);
 extern void ata_sg_clean(struct ata_queued_cmd *qc);
+extern void ata_qc_free(struct ata_queued_cmd *qc);
 extern void ata_qc_issue(struct ata_queued_cmd *qc);
 extern void __ata_qc_complete(struct ata_queued_cmd *qc);
 extern int atapi_check_dma(struct ata_queued_cmd *qc);
@@ -118,22 +119,6 @@ extern struct ata_port *ata_port_alloc(struct ata_host *host);
 extern void ata_dev_enable_pm(struct ata_device *dev, enum link_pm policy);
 extern void ata_lpm_schedule(struct ata_port *ap, enum link_pm);
 
-/**
- *	ata_qc_free - free unused ata_queued_cmd
- *	@qc: Command to complete
- *
- *	Designed to free unused ata_queued_cmd object
- *	in case something prevents using it.
- *
- *	LOCKING:
- *	spin_lock_irqsave(host lock)
- */
-static inline void ata_qc_free(struct ata_queued_cmd *qc)
-{
-	qc->flags = 0;
-	qc->tag = ATA_TAG_POISON;
-}
-
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
 extern void ata_acpi_associate_sata_port(struct ata_port *ap);

commit 2fca5ccf97d2c28bcfce44f5b07d85e74e3cd18e
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Wed Oct 22 09:34:49 2008 +0200

    libata: switch to using block layer tagging support
    
    libata currently has a pretty dumb ATA_MAX_QUEUE loop for finding
    a free tag to use. Instead of fixing that up, convert libata to
    using block layer tagging - gets rid of code in libata, and is also
    much faster.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index fe2839e58774..d3831d39bdaa 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -74,7 +74,7 @@ extern struct ata_link *ata_dev_phys_link(struct ata_device *dev);
 extern void ata_force_cbl(struct ata_port *ap);
 extern u64 ata_tf_to_lba(const struct ata_taskfile *tf);
 extern u64 ata_tf_to_lba48(const struct ata_taskfile *tf);
-extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev);
+extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev, int tag);
 extern int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
 			   u64 block, u32 n_block, unsigned int tf_flags,
 			   unsigned int tag);
@@ -103,7 +103,6 @@ extern int ata_dev_configure(struct ata_device *dev);
 extern int sata_down_spd_limit(struct ata_link *link);
 extern int ata_down_xfermask_limit(struct ata_device *dev, unsigned int sel);
 extern void ata_sg_clean(struct ata_queued_cmd *qc);
-extern void ata_qc_free(struct ata_queued_cmd *qc);
 extern void ata_qc_issue(struct ata_queued_cmd *qc);
 extern void __ata_qc_complete(struct ata_queued_cmd *qc);
 extern int atapi_check_dma(struct ata_queued_cmd *qc);
@@ -119,6 +118,22 @@ extern struct ata_port *ata_port_alloc(struct ata_host *host);
 extern void ata_dev_enable_pm(struct ata_device *dev, enum link_pm policy);
 extern void ata_lpm_schedule(struct ata_port *ap, enum link_pm);
 
+/**
+ *	ata_qc_free - free unused ata_queued_cmd
+ *	@qc: Command to complete
+ *
+ *	Designed to free unused ata_queued_cmd object
+ *	in case something prevents using it.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host lock)
+ */
+static inline void ata_qc_free(struct ata_queued_cmd *qc)
+{
+	qc->flags = 0;
+	qc->tag = ATA_TAG_POISON;
+}
+
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
 extern void ata_acpi_associate_sata_port(struct ata_port *ap);

commit e26feff647ef34423b048b940540a0059001ddb0
Merge: d403a6484f03 b911e473d246
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 10 10:52:45 2008 -0700

    Merge branch 'for-2.6.28' of git://git.kernel.dk/linux-2.6-block
    
    * 'for-2.6.28' of git://git.kernel.dk/linux-2.6-block: (132 commits)
      doc/cdrom: Trvial documentation error, file not present
      block_dev: fix kernel-doc in new functions
      block: add some comments around the bio read-write flags
      block: mark bio_split_pool static
      block: Find bio sector offset given idx and offset
      block: gendisk integrity wrapper
      block: Switch blk_integrity_compare from bdev to gendisk
      block: Fix double put in blk_integrity_unregister
      block: Introduce integrity data ownership flag
      block: revert part of d7533ad0e132f92e75c1b2eb7c26387b25a583c1
      bio.h: Remove unused conditional code
      block: remove end_{queued|dequeued}_request()
      block: change elevator to use __blk_end_request()
      gdrom: change to use __blk_end_request()
      memstick: change to use __blk_end_request()
      virtio_blk: change to use __blk_end_request()
      blktrace: use BLKTRACE_BDEV_SIZE as the name size for setup structure
      block: add lld busy state exporting interface
      block: Fix blk_start_queueing() to not kick a stopped queue
      include blktrace_api.h in headers_install
      ...

commit 242f9dcb8ba6f68fcd217a119a7648a4f69290e9
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Sun Sep 14 05:55:09 2008 -0700

    block: unify request timeout handling
    
    Right now SCSI and others do their own command timeout handling.
    Move those bits to the block layer.
    
    Instead of having a timer per command, we try to be a bit more clever
    and simply have one per-queue. This avoids the overhead of having to
    tear down and setup a timer for each command, so it will result in a lot
    less timer fiddling.
    
    Signed-off-by: Mike Anderson <andmike@linux.vnet.ibm.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index ade5c75b6144..24f5005478b0 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -152,7 +152,7 @@ extern int ata_bus_probe(struct ata_port *ap);
 /* libata-eh.c */
 extern unsigned long ata_internal_cmd_timeout(struct ata_device *dev, u8 cmd);
 extern void ata_internal_cmd_timed_out(struct ata_device *dev, u8 cmd);
-extern enum scsi_eh_timer_return ata_scsi_timed_out(struct scsi_cmnd *cmd);
+extern enum blk_eh_timer_return ata_scsi_timed_out(struct scsi_cmnd *cmd);
 extern void ata_scsi_error(struct Scsi_Host *host);
 extern void ata_port_wait_eh(struct ata_port *ap);
 extern void ata_eh_fastdrain_timerfn(unsigned long arg);

commit b1c72916abbdd0a55015c87358536ca0ebaf6735
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jul 31 17:02:43 2008 +0900

    libata: implement slave_link
    
    Explanation taken from the comment of ata_slave_link_init().
    
     In libata, a port contains links and a link contains devices.  There
     is single host link but if a PMP is attached to it, there can be
     multiple fan-out links.  On SATA, there's usually a single device
     connected to a link but PATA and SATA controllers emulating TF based
     interface can have two - master and slave.
    
     However, there are a few controllers which don't fit into this
     abstraction too well - SATA controllers which emulate TF interface
     with both master and slave devices but also have separate SCR
     register sets for each device.  These controllers need separate links
     for physical link handling (e.g. onlineness, link speed) but should
     be treated like a traditional M/S controller for everything else
     (e.g. command issue, softreset).
    
     slave_link is libata's way of handling this class of controllers
     without impacting core layer too much.  For anything other than
     physical link handling, the default host link is used for both master
     and slave.  For physical link handling, separate @ap->slave_link is
     used.  All dirty details are implemented inside libata core layer.
     From LLD's POV, the only difference is that prereset, hardreset and
     postreset are called once more for the slave link, so the reset
     sequence looks like the following.
    
     prereset(M) -> prereset(S) -> hardreset(M) -> hardreset(S) ->
     softreset(M) -> postreset(M) -> postreset(S)
    
     Note that softreset is called only for the master.  Softreset resets
     both M/S by definition, so SRST on master should handle both (the
     standard method will work just fine).
    
    As slave_link excludes PMP support and only code paths which deal with
    the attributes of physical link are affected, all the changes are
    localized to libata.h, libata-core.c and libata-eh.c.
    
     * ata_is_host_link() updated so that slave_link is considered as host
       link too.
    
     * iterator extended to iterate over the slave_link when using the
       underbarred version.
    
     * force param handling updated such that devno 16 is mapped to the
       slave link/device.
    
     * ata_link_on/offline() updated to return the combined result from
       master and slave link.  ata_phys_link_on/offline() are the direct
       versions.
    
     * EH autopsy and report are performed separately for master slave
       links.  Reset is udpated to implement the above described reset
       sequence.
    
    Except for reset update, most changes are minor, many of them just
    modifying dev->link to ata_dev_phys_link(dev) or using phys online
    test instead.
    
    After this update, LLDs can take full advantage of per-dev SCR
    registers by simply turning on slave link.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index ade5c75b6144..e96de96e3020 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -70,6 +70,7 @@ extern int atapi_passthru16;
 extern int libata_fua;
 extern int libata_noacpi;
 extern int libata_allow_tpm;
+extern struct ata_link *ata_dev_phys_link(struct ata_device *dev);
 extern void ata_force_cbl(struct ata_port *ap);
 extern u64 ata_tf_to_lba(const struct ata_taskfile *tf);
 extern u64 ata_tf_to_lba48(const struct ata_taskfile *tf);
@@ -107,6 +108,8 @@ extern void ata_qc_issue(struct ata_queued_cmd *qc);
 extern void __ata_qc_complete(struct ata_queued_cmd *qc);
 extern int atapi_check_dma(struct ata_queued_cmd *qc);
 extern void swap_buf_le16(u16 *buf, unsigned int buf_words);
+extern bool ata_phys_link_online(struct ata_link *link);
+extern bool ata_phys_link_offline(struct ata_link *link);
 extern void ata_dev_init(struct ata_device *dev);
 extern void ata_link_init(struct ata_port *ap, struct ata_link *link, int pmp);
 extern int sata_link_init_spd(struct ata_link *link);

commit 2486fa561a3192bbbec39c7feef87a1e07bd6342
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jul 31 07:52:40 2008 +0900

    libata: update atapi disable handling
    
    Global and per-LLD ATAPI disable checks were done in the command issue
    path probably because it was left out during EH conversion.  On
    affected machines, this can cause lots of warning messages.  Move them
    to where they belong - the probing path.
    
    Reported by Chunbo Luo.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Chunbo Luo <chunbo.luo@windriver.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index f6f9c28ec7f8..ade5c75b6144 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -66,7 +66,6 @@ enum {
 
 extern unsigned int ata_print_id;
 extern struct workqueue_struct *ata_aux_wq;
-extern int atapi_enabled;
 extern int atapi_passthru16;
 extern int libata_fua;
 extern int libata_noacpi;

commit 87fbc5a060faf2394bee88a93519f9b9d434727c
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue May 20 02:17:54 2008 +0900

    libata: improve EH internal command timeout handling
    
    ATA_TMOUT_INTERNAL which was 30secs were used for all internal
    commands which is way too long when something goes wrong.  This patch
    implements command type based stepped timeouts.  Different command
    types can use different timeouts and each command type can use
    different timeout values after timeouts.
    
    ie. the initial timeout is set to a value which should cover most of
    the cases but not too long so that run away cases don't delay things
    too much.  After the first try times out, the second try can use
    longer timeout and if that one times out too, it can go for full 30sec
    timeout.
    
    IDENTIFYs use 5s - 10s - 30s timeout and all other commands use 5s -
    10s timeouts.
    
    This patch significantly cuts down the needed time to handle failure
    cases while still allowing libata to work with nut job devices through
    retries.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 1cf803adbc95..f6f9c28ec7f8 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -151,6 +151,8 @@ extern void ata_scsi_dev_rescan(struct work_struct *work);
 extern int ata_bus_probe(struct ata_port *ap);
 
 /* libata-eh.c */
+extern unsigned long ata_internal_cmd_timeout(struct ata_device *dev, u8 cmd);
+extern void ata_internal_cmd_timed_out(struct ata_device *dev, u8 cmd);
 extern enum scsi_eh_timer_return ata_scsi_timed_out(struct scsi_cmnd *cmd);
 extern void ata_scsi_error(struct Scsi_Host *host);
 extern void ata_port_wait_eh(struct ata_port *ap);

commit 5895ef9a5b746e7cc9ebda50c87fbd11562da0a4
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Jun 17 12:36:26 2008 +0900

    libata: don't check whether to use DMA or not for no data commands
    
    There's no reason to check whether to use DMA or not for no data
    commands.  Don't do it.  While at it, make local variable using_pio in
    atapi_xlat() set iff ATAPI_PROT_PIO is going to be used and rename
    ata_check_atapi_dma() to atapi_check_dma() for consistency.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 4514283937ea..1cf803adbc95 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -106,7 +106,7 @@ extern void ata_sg_clean(struct ata_queued_cmd *qc);
 extern void ata_qc_free(struct ata_queued_cmd *qc);
 extern void ata_qc_issue(struct ata_queued_cmd *qc);
 extern void __ata_qc_complete(struct ata_queued_cmd *qc);
-extern int ata_check_atapi_dma(struct ata_queued_cmd *qc);
+extern int atapi_check_dma(struct ata_queued_cmd *qc);
 extern void swap_buf_le16(u16 *buf, unsigned int buf_words);
 extern void ata_dev_init(struct ata_device *dev);
 extern void ata_link_init(struct ata_port *ap, struct ata_link *link, int pmp);

commit f0761be344f9b1cc4284b1d945933cd983c233a4
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 28 17:16:52 2008 +0900

    libata-scsi: clean up inquiry / mode sense related functions
    
    * make ata_scsiop_*() static
    * make ata_scsi_set_sense() static and move it above its users
    * make ata_scsi_rbuf_fill() static
    * kill unused ata_scsi_badcmd()
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index ae2cfd95d43e..4514283937ea 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -146,34 +146,6 @@ extern void ata_scsi_scan_host(struct ata_port *ap, int sync);
 extern int ata_scsi_offline_dev(struct ata_device *dev);
 extern void ata_scsi_media_change_notify(struct ata_device *dev);
 extern void ata_scsi_hotplug(struct work_struct *work);
-extern unsigned int ata_scsiop_inq_std(struct ata_scsi_args *args, u8 *rbuf,
-			       unsigned int buflen);
-
-extern unsigned int ata_scsiop_inq_00(struct ata_scsi_args *args, u8 *rbuf,
-			      unsigned int buflen);
-
-extern unsigned int ata_scsiop_inq_80(struct ata_scsi_args *args, u8 *rbuf,
-			      unsigned int buflen);
-extern unsigned int ata_scsiop_inq_83(struct ata_scsi_args *args, u8 *rbuf,
-			      unsigned int buflen);
-extern unsigned int ata_scsiop_noop(struct ata_scsi_args *args, u8 *rbuf,
-			    unsigned int buflen);
-extern unsigned int ata_scsiop_sync_cache(struct ata_scsi_args *args, u8 *rbuf,
-				  unsigned int buflen);
-extern unsigned int ata_scsiop_mode_sense(struct ata_scsi_args *args, u8 *rbuf,
-				  unsigned int buflen);
-extern unsigned int ata_scsiop_read_cap(struct ata_scsi_args *args, u8 *rbuf,
-			        unsigned int buflen);
-extern unsigned int ata_scsiop_report_luns(struct ata_scsi_args *args, u8 *rbuf,
-				   unsigned int buflen);
-extern void ata_scsi_badcmd(struct scsi_cmnd *cmd,
-			    void (*done)(struct scsi_cmnd *),
-			    u8 asc, u8 ascq);
-extern void ata_scsi_set_sense(struct scsi_cmnd *cmd,
-			       u8 sk, u8 asc, u8 ascq);
-extern void ata_scsi_rbuf_fill(struct ata_scsi_args *args,
-                        unsigned int (*actor) (struct ata_scsi_args *args,
-                                           u8 *rbuf, unsigned int buflen));
 extern void ata_schedule_scsi_eh(struct Scsi_Host *shost);
 extern void ata_scsi_dev_rescan(struct work_struct *work);
 extern int ata_bus_probe(struct ata_port *ap);

commit 1dc55e876182a13dcc5991c3aab893f38455d8a7
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Apr 21 11:51:17 2008 +0300

    make sata_set_spd_needed() static
    
    sata_set_spd_needed() can now become static.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 4aeeabb10a47..ae2cfd95d43e 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -101,7 +101,6 @@ extern int ata_dev_revalidate(struct ata_device *dev, unsigned int new_class,
 			      unsigned int readid_flags);
 extern int ata_dev_configure(struct ata_device *dev);
 extern int sata_down_spd_limit(struct ata_link *link);
-extern int sata_set_spd_needed(struct ata_link *link);
 extern int ata_down_xfermask_limit(struct ata_device *dev, unsigned int sel);
 extern void ata_sg_clean(struct ata_queued_cmd *qc);
 extern void ata_qc_free(struct ata_queued_cmd *qc);

commit 88fcd5627563722483427a55113c0a83f56e8080
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:22 2008 +0900

    libata: make PMP support optional
    
    Make PMP support optional by adding CONFIG_SATA_PMP and leaving out
    libata-pmp.c if it isn't set.  PMP helpers return constant values if
    PMP support is not enabled and PMP declarations alias non-PMP
    counterparts.  This makes the compiler to leave out PMP related part
    out and LLDs to use non-PMP counterparts automatically.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 42b30e38495d..4aeeabb10a47 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -203,9 +203,26 @@ extern int ata_eh_recover(struct ata_port *ap, ata_prereset_fn_t prereset,
 extern void ata_eh_finish(struct ata_port *ap);
 
 /* libata-pmp.c */
+#ifdef CONFIG_SATA_PMP
 extern int sata_pmp_scr_read(struct ata_link *link, int reg, u32 *val);
 extern int sata_pmp_scr_write(struct ata_link *link, int reg, u32 val);
 extern int sata_pmp_attach(struct ata_device *dev);
+#else /* CONFIG_SATA_PMP */
+static inline int sata_pmp_scr_read(struct ata_link *link, int reg, u32 *val)
+{
+	return -EINVAL;
+}
+
+static inline int sata_pmp_scr_write(struct ata_link *link, int reg, u32 val)
+{
+	return -EINVAL;
+}
+
+static inline int sata_pmp_attach(struct ata_device *dev)
+{
+	return -EINVAL;
+}
+#endif /* CONFIG_SATA_PMP */
 
 /* libata-sff.c */
 #ifdef CONFIG_ATA_SFF

commit 48515f6c006c2a9d7b624ee8ad068018c2d3fe0e
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:21 2008 +0900

    libata: separate PMP support code from core code
    
    Most of PMP support code is already in libata-pmp.c.  All that are in
    libata-core.c are sata_pmp_port_ops and EXPORTs.  Move them to
    libata-pmp.c.  Also, collect PMP related prototypes and declarations
    in header files and move them right above of SFF stuff.
    
    This change is to make PMP support optional.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 6b70a624828c..42b30e38495d 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -179,11 +179,6 @@ extern void ata_schedule_scsi_eh(struct Scsi_Host *shost);
 extern void ata_scsi_dev_rescan(struct work_struct *work);
 extern int ata_bus_probe(struct ata_port *ap);
 
-/* libata-pmp.c */
-extern int sata_pmp_scr_read(struct ata_link *link, int reg, u32 *val);
-extern int sata_pmp_scr_write(struct ata_link *link, int reg, u32 val);
-extern int sata_pmp_attach(struct ata_device *dev);
-
 /* libata-eh.c */
 extern enum scsi_eh_timer_return ata_scsi_timed_out(struct scsi_cmnd *cmd);
 extern void ata_scsi_error(struct Scsi_Host *host);
@@ -207,6 +202,11 @@ extern int ata_eh_recover(struct ata_port *ap, ata_prereset_fn_t prereset,
 			  struct ata_link **r_failed_disk);
 extern void ata_eh_finish(struct ata_port *ap);
 
+/* libata-pmp.c */
+extern int sata_pmp_scr_read(struct ata_link *link, int reg, u32 *val);
+extern int sata_pmp_scr_write(struct ata_link *link, int reg, u32 val);
+extern int sata_pmp_attach(struct ata_device *dev);
+
 /* libata-sff.c */
 #ifdef CONFIG_ATA_SFF
 extern void ata_dev_select(struct ata_port *ap, unsigned int device,

commit 127102aea2ea9ec4e9ca233e2b1a75c8d3b058c4
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:21 2008 +0900

    libata: make SFF support optional
    
    Now that SFF support is completely separated out from the core layer,
    it can be made optional.  Add CONFIG_ATA_SFF and let SFF drivers
    depend on it.  If CONFIG_ATA_SFF isn't set, all codes in libata-sff.c
    and data structures for SFF support are disabled.  This saves good
    number of bytes for small systems.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 87f54a1db3b0..6b70a624828c 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -42,8 +42,10 @@ static inline int ata_is_builtin_hardreset(ata_reset_fn_t reset)
 {
 	if (reset == sata_std_hardreset)
 		return 1;
+#ifdef CONFIG_ATA_SFF
 	if (reset == sata_sff_hardreset)
 		return 1;
+#endif
 	return 0;
 }
 
@@ -206,9 +208,11 @@ extern int ata_eh_recover(struct ata_port *ap, ata_prereset_fn_t prereset,
 extern void ata_eh_finish(struct ata_port *ap);
 
 /* libata-sff.c */
+#ifdef CONFIG_ATA_SFF
 extern void ata_dev_select(struct ata_port *ap, unsigned int device,
                            unsigned int wait, unsigned int can_sleep);
 extern u8 ata_irq_on(struct ata_port *ap);
 extern void ata_pio_task(struct work_struct *work);
+#endif /* CONFIG_ATA_SFF */
 
 #endif /* __LIBATA_H__ */

commit 57c9efdfb3cee5d4564fcb5f70555e2edb1bc52a
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:19 2008 +0900

    libata: implement and use sata_std_hardreset()
    
    Implement sata_std_hardreset(), which simply wraps around
    sata_link_hardreset().  sata_std_hardreset() becomes new standard
    hardreset method for sata_port_ops and sata_sff_hardreset() moves from
    ata_base_port_ops to ata_sff_port_ops, which is where it really
    belongs.
    
    ata_is_builtin_hardreset() is added so that both
    ata_std_error_handler() and ata_sff_error_handler() skip both builtin
    hardresets if SCR isn't accessible.
    
    piix_sidpr_hardreset() in ata_piix.c is identical to
    sata_std_hardreset() in functionality and got replaced with the
    standard function.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 08af43e2c081..87f54a1db3b0 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -38,6 +38,15 @@ struct ata_scsi_args {
 	void			(*done)(struct scsi_cmnd *);
 };
 
+static inline int ata_is_builtin_hardreset(ata_reset_fn_t reset)
+{
+	if (reset == sata_std_hardreset)
+		return 1;
+	if (reset == sata_sff_hardreset)
+		return 1;
+	return 0;
+}
+
 /* libata-core.c */
 enum {
 	/* flags for ata_dev_read_id() */

commit aa2731ad9ad80ac3fca48bd1c4cf0eceede4810e
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:19 2008 +0900

    libata: separate out ata_wait_ready() and implement ata_wait_after_reset()
    
    Factor out waiting logic (which is common to all ATA controllers) from
    ata_sff_wait_ready() into ata_wait_ready().  ata_wait_ready() takes
    @check_ready function pointer and uses it to poll for readiness.  This
    allows non-SFF controllers to use ata_wait_ready() to wait for link
    readiness.
    
    This patch also implements ata_wait_after_reset() - generic version of
    ata_sff_wait_after_reset() - using ata_wait_ready().
    
    ata_sff_wait_ready() is reimplemented using ata_wait_ready() and
    ata_sff_check_ready().  Functionality remains the same.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 11b5f67a19d4..08af43e2c081 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -81,6 +81,8 @@ extern unsigned ata_exec_internal_sg(struct ata_device *dev,
 				     int dma_dir, struct scatterlist *sg,
 				     unsigned int n_elem, unsigned long timeout);
 extern unsigned int ata_do_simple_cmd(struct ata_device *dev, u8 cmd);
+extern int ata_wait_ready(struct ata_link *link, unsigned long deadline,
+			  int (*check_ready)(struct ata_link *link));
 extern int ata_dev_read_id(struct ata_device *dev, unsigned int *p_class,
 			   unsigned int flags, u16 *id);
 extern int ata_dev_reread_id(struct ata_device *dev, unsigned int readid_flags);

commit d8b81b8008a0f131e01bb6eb5c681c900c327e2b
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Mar 27 19:14:25 2008 +0900

    libata: kill unused ata_flush_cache()
    
    ata_flush_code() hasn't been in use for quite some time now.  Kill it.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 5e8d0359bccb..11b5f67a19d4 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -96,7 +96,6 @@ extern void ata_qc_issue(struct ata_queued_cmd *qc);
 extern void __ata_qc_complete(struct ata_queued_cmd *qc);
 extern int ata_check_atapi_dma(struct ata_queued_cmd *qc);
 extern void swap_buf_le16(u16 *buf, unsigned int buf_words);
-extern int ata_flush_cache(struct ata_device *dev);
 extern void ata_dev_init(struct ata_device *dev);
 extern void ata_link_init(struct ata_port *ap, struct ata_link *link, int pmp);
 extern int sata_link_init_spd(struct ata_link *link);

commit a5987e0a1b569146ed9cfa0a8c275a21b344fcaa
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Mar 27 19:14:23 2008 +0900

    libata: make ata_tf_to_lba[48]() generic
    
    ata_tf_to_lba[48]() currently return LBA in tf + 1 for
    ata_read_native_max_address().  Make them return LBA and make it
    global so that it can be used to read LBA off TF for other purposes.
    ata_read_native_max_address() now adds 1 itself.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index a69f663c7402..5e8d0359bccb 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -61,6 +61,8 @@ extern int libata_fua;
 extern int libata_noacpi;
 extern int libata_allow_tpm;
 extern void ata_force_cbl(struct ata_port *ap);
+extern u64 ata_tf_to_lba(const struct ata_taskfile *tf);
+extern u64 ata_tf_to_lba48(const struct ata_taskfile *tf);
 extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev);
 extern int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
 			   u64 block, u32 n_block, unsigned int tf_flags,

commit 624d5c514eed18d5a93062e9d86d67065175f30a
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 22:16:41 2008 +0900

    libata: reorganize SFF related stuff
    
    * Move SFF related functions from libata-core.c to libata-sff.c.
    
      ata_[bmdma_]sff_port_ops, ata_devchk(), ata_dev_try_classify(),
      ata_std_dev_select(), ata_tf_to_host(), ata_busy_sleep(),
      ata_wait_after_reset(), ata_wait_ready(), ata_bus_post_reset(),
      ata_bus_softreset(), ata_bus_reset(), ata_std_softreset(),
      sata_std_hardreset(), ata_fill_sg(), ata_fill_sg_dumb(),
      ata_qc_prep(), ata_dump_qc_prep(), ata_data_xfer(),
      ata_data_xfer_noirq(), ata_pio_sector(), ata_pio_sectors(),
      atapi_send_cdb(), __atapi_pio_bytes(), atapi_pio_bytes(),
      ata_hsm_ok_in_wq(), ata_hsm_qc_complete(), ata_hsm_move(),
      ata_pio_task(), ata_qc_issue_prot(), ata_host_intr(),
      ata_interrupt(), ata_std_ports()
    
    * Make ata_pio_queue_task() global as it's now called from
      libata-sff.c.
    
    * Move SFF related stuff in include/linux/libata.h and
      drivers/ata/libata.h into one place.  While at it, move timing
      constants into the global enum definition and fortify comments a
      bit.
    
    This patch strictly moves stuff around and as such doesn't cause any
    functional difference.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index aa884f71a12a..a69f663c7402 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -67,6 +67,8 @@ extern int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
 			   unsigned int tag);
 extern u64 ata_tf_read_block(struct ata_taskfile *tf, struct ata_device *dev);
 extern void ata_dev_disable(struct ata_device *dev);
+extern void ata_pio_queue_task(struct ata_port *ap, void *data,
+			       unsigned long delay);
 extern void ata_port_flush_task(struct ata_port *ap);
 extern unsigned ata_exec_internal(struct ata_device *dev,
 				  struct ata_taskfile *tf, const u8 *cdb,
@@ -91,8 +93,6 @@ extern void ata_qc_free(struct ata_queued_cmd *qc);
 extern void ata_qc_issue(struct ata_queued_cmd *qc);
 extern void __ata_qc_complete(struct ata_queued_cmd *qc);
 extern int ata_check_atapi_dma(struct ata_queued_cmd *qc);
-extern void ata_dev_select(struct ata_port *ap, unsigned int device,
-                           unsigned int wait, unsigned int can_sleep);
 extern void swap_buf_le16(u16 *buf, unsigned int buf_words);
 extern int ata_flush_cache(struct ata_device *dev);
 extern void ata_dev_init(struct ata_device *dev);
@@ -194,7 +194,9 @@ extern int ata_eh_recover(struct ata_port *ap, ata_prereset_fn_t prereset,
 extern void ata_eh_finish(struct ata_port *ap);
 
 /* libata-sff.c */
+extern void ata_dev_select(struct ata_port *ap, unsigned int device,
+                           unsigned int wait, unsigned int can_sleep);
 extern u8 ata_irq_on(struct ata_port *ap);
-
+extern void ata_pio_task(struct work_struct *work);
 
 #endif /* __LIBATA_H__ */

commit c5c61bda5ecceaa0f16d326cd2c2147468a4c443
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Feb 25 02:07:25 2008 +0200

    make atapi_dmadir static
    
    atapi_dmadir can now become static.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 6036dedfe377..aa884f71a12a 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -56,7 +56,6 @@ enum {
 extern unsigned int ata_print_id;
 extern struct workqueue_struct *ata_aux_wq;
 extern int atapi_enabled;
-extern int atapi_dmadir;
 extern int atapi_passthru16;
 extern int libata_fua;
 extern int libata_noacpi;

commit 332673257056d8be8a69d759eda90a799af5472d
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Feb 13 09:15:09 2008 +0900

    libata: implement libata.force module parameter
    
    This patch implements libata.force module parameter which can
    selectively override ATA port, link and device configurations
    including cable type, SATA PHY SPD limit, transfer mode and NCQ.
    
    For example, you can say "use 1.5Gbps for all fan-out ports attached
    to the second port but allow 3.0Gbps for the PMP device itself, oh,
    the device attached to the third fan-out port chokes on NCQ and
    shouldn't go over UDMA4" by the following.
    
     libata.force=2:1.5g,2.15:3.0g,2.03:noncq,udma4
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 409ffb9af163..6036dedfe377 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -61,6 +61,7 @@ extern int atapi_passthru16;
 extern int libata_fua;
 extern int libata_noacpi;
 extern int libata_allow_tpm;
+extern void ata_force_cbl(struct ata_port *ap);
 extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev);
 extern int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
 			   u64 block, u32 n_block, unsigned int tf_flags,

commit 6f1d1e3a03fd04a9d9c82fd3cf414020097bb142
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Nov 27 19:28:55 2007 +0900

    libata: move ata_set_mode() to libata-eh.c
    
    Move ata_set_mode() to libata-eh.c.  ata_set_mode() is surely an EH
    action and will be more tightly coupled with the rest of error
    handling.  Move it to libata-eh.c.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 8cf0874f248b..409ffb9af163 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -86,7 +86,6 @@ extern int ata_dev_configure(struct ata_device *dev);
 extern int sata_down_spd_limit(struct ata_link *link);
 extern int sata_set_spd_needed(struct ata_link *link);
 extern int ata_down_xfermask_limit(struct ata_device *dev, unsigned int sel);
-extern int ata_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
 extern void ata_sg_clean(struct ata_queued_cmd *qc);
 extern void ata_qc_free(struct ata_queued_cmd *qc);
 extern void ata_qc_issue(struct ata_queued_cmd *qc);
@@ -187,6 +186,7 @@ extern void ata_eh_report(struct ata_port *ap);
 extern int ata_eh_reset(struct ata_link *link, int classify,
 			ata_prereset_fn_t prereset, ata_reset_fn_t softreset,
 			ata_reset_fn_t hardreset, ata_postreset_fn_t postreset);
+extern int ata_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
 extern int ata_eh_recover(struct ata_port *ap, ata_prereset_fn_t prereset,
 			  ata_reset_fn_t softreset, ata_reset_fn_t hardreset,
 			  ata_postreset_fn_t postreset,

commit bd3adca52bc43b72c75db3e4c7809d47923b154c
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Fri Nov 2 09:32:38 2007 +0800

    libata-acpi: add ACPI _PSx method
    
    ACPI spec (ver 3.0a, p289) requires IDE power on/off executes ACPI _PSx
    methods. As recently most PATA drivers use libata, this patch adds _PSx
    method support in libata. ACPI spec doesn't mention if SATA requires the
    same _PSx method.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Acked-by: Len Brown <len.brown@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 048e26cfb339..8cf0874f248b 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -114,6 +114,7 @@ extern int ata_acpi_on_suspend(struct ata_port *ap);
 extern void ata_acpi_on_resume(struct ata_port *ap);
 extern int ata_acpi_on_devcfg(struct ata_device *dev);
 extern void ata_acpi_on_disable(struct ata_device *dev);
+extern void ata_acpi_set_state(struct ata_port *ap, pm_message_t state);
 #else
 static inline void ata_acpi_associate_sata_port(struct ata_port *ap) { }
 static inline void ata_acpi_associate(struct ata_host *host) { }
@@ -122,6 +123,8 @@ static inline int ata_acpi_on_suspend(struct ata_port *ap) { return 0; }
 static inline void ata_acpi_on_resume(struct ata_port *ap) { }
 static inline int ata_acpi_on_devcfg(struct ata_device *dev) { return 0; }
 static inline void ata_acpi_on_disable(struct ata_device *dev) { }
+static inline void ata_acpi_set_state(struct ata_port *ap,
+				      pm_message_t state) { }
 #endif
 
 /* libata-scsi.c */

commit ae8d4ee7ff429136c8b482c3b38ed994c021d3fc
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Sun Nov 4 22:05:49 2007 -0500

    libata: Disable ATA8-ACS proposed Trusted Computing features by default
    
    Historically word 48 in the identify data was used to mean 32bit I/O
    was supported for VLB IDE etc. ATA8 reassigns this word to the Trusted
    Computing Group, where it is used for TCG features. This means that
    an ATA8 TCG drive is going to trigger 32bit I/O on some systems which
    will be funny.
    
    Anyway we need to sort this out ready for ATA8 so:
    - Reorder the ata.h header a bit so the ata_version function occurs early
      in it
    - Make dword_io check the ATA version
    - Add an ATA8 version checking TCG presence test
    
    While we are at it the current drafts have a flaw where it may not be
    possible to disable TCG features at boot (and opt out of the trusted
    model) as TCG intends because it relies on presence of a different
    optional feature (DCS). Handle this in software by refusing the TCG
    commands if libata.allow_tpm is not set. (We must make it possible
    as some environments such as proprietary VDR devices will doubtless
    want to use it to lock up content)
    
    Finally as with CPRM print a warning so that the user knows they may
    not be able to full access and use the device.
    
    Signed-off-by: Alan Cox <alan@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index bbe59c2fd1e2..048e26cfb339 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -60,6 +60,7 @@ extern int atapi_dmadir;
 extern int atapi_passthru16;
 extern int libata_fua;
 extern int libata_noacpi;
+extern int libata_allow_tpm;
 extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev);
 extern int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
 			   u64 block, u32 n_block, unsigned int tf_flags,

commit 562f0c2d771ee7be6b37fe015f94a929f8056120
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Dec 15 15:05:01 2007 +0900

    libata-acpi: add new hooks ata_acpi_dissociate() and ata_acpi_on_disable()
    
    Add two hooks - ata_acpi_dissociate() which is called during driver
    detach after the whole host is shutdown and ata_acpi_on_disable()
    which is called when a device is disabled.
    
    Signed-off-by: Tejun heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 0e6cf3a484dc..bbe59c2fd1e2 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -108,15 +108,19 @@ extern void ata_lpm_schedule(struct ata_port *ap, enum link_pm);
 #ifdef CONFIG_ATA_ACPI
 extern void ata_acpi_associate_sata_port(struct ata_port *ap);
 extern void ata_acpi_associate(struct ata_host *host);
+extern void ata_acpi_dissociate(struct ata_host *host);
 extern int ata_acpi_on_suspend(struct ata_port *ap);
 extern void ata_acpi_on_resume(struct ata_port *ap);
-extern int ata_acpi_on_devcfg(struct ata_device *adev);
+extern int ata_acpi_on_devcfg(struct ata_device *dev);
+extern void ata_acpi_on_disable(struct ata_device *dev);
 #else
 static inline void ata_acpi_associate_sata_port(struct ata_port *ap) { }
 static inline void ata_acpi_associate(struct ata_host *host) { }
+static inline void ata_acpi_dissociate(struct ata_host *host) { }
 static inline int ata_acpi_on_suspend(struct ata_port *ap) { return 0; }
 static inline void ata_acpi_on_resume(struct ata_port *ap) { }
-static inline int ata_acpi_on_devcfg(struct ata_device *adev) { return 0; }
+static inline int ata_acpi_on_devcfg(struct ata_device *dev) { return 0; }
+static inline void ata_acpi_on_disable(struct ata_device *dev) { }
 #endif
 
 /* libata-scsi.c */

commit ca77329fb713b7fea6a307068e0dd0248e7aa640
Author: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Date:   Thu Oct 25 00:58:59 2007 -0400

    [libata] Link power management infrastructure
    
    Device Initiated Power Management, which is defined
    in SATA 2.5 can be enabled for disks which support it.
    This patch enables DIPM when the user sets the link
    power management policy to "min_power".
    
    Additionally, libata drivers can define a function
    (enable_pm) that will perform hardware specific actions to
    enable whatever power management policy the user set up
    for Host Initiated Power management (HIPM).
    This power management policy will be activated after all
    disks have been enumerated and intialized.  Drivers should
    also define disable_pm, which will turn off link power
    management, but not change link power management policy.
    
    Documentation/scsi/link_power_management_policy.txt has additional
    information.
    
    Signed-off-by:  Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 90df58a3edc9..0e6cf3a484dc 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -101,6 +101,8 @@ extern int sata_link_init_spd(struct ata_link *link);
 extern int ata_task_ioctl(struct scsi_device *scsidev, void __user *arg);
 extern int ata_cmd_ioctl(struct scsi_device *scsidev, void __user *arg);
 extern struct ata_port *ata_port_alloc(struct ata_host *host);
+extern void ata_dev_enable_pm(struct ata_device *dev, enum link_pm policy);
+extern void ata_lpm_schedule(struct ata_port *ap, enum link_pm);
 
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI

commit 2b789108fc1dcba22050a7e6e29ae5ebaea427dd
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Oct 9 15:05:44 2007 +0900

    libata: add @timeout to ata_exec_internal[_sg]()
    
    Add @timeout argument to ata_exec_internal[_sg]().  If 0, default
    timeout ata_probe_timeout is used.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index f8bd955c5ba7..90df58a3edc9 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -69,11 +69,12 @@ extern void ata_dev_disable(struct ata_device *dev);
 extern void ata_port_flush_task(struct ata_port *ap);
 extern unsigned ata_exec_internal(struct ata_device *dev,
 				  struct ata_taskfile *tf, const u8 *cdb,
-				  int dma_dir, void *buf, unsigned int buflen);
+				  int dma_dir, void *buf, unsigned int buflen,
+				  unsigned long timeout);
 extern unsigned ata_exec_internal_sg(struct ata_device *dev,
 				     struct ata_taskfile *tf, const u8 *cdb,
 				     int dma_dir, struct scatterlist *sg,
-				     unsigned int n_elem);
+				     unsigned int n_elem, unsigned long timeout);
 extern unsigned int ata_do_simple_cmd(struct ata_device *dev, u8 cmd);
 extern int ata_dev_read_id(struct ata_device *dev, unsigned int *p_class,
 			   unsigned int flags, u16 *id);

commit d0df8b5d0fb547a3351c2a4b1ded7f7cde5d713a
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Sep 23 13:19:54 2007 +0900

    libata-pmp: extend ACPI support to cover PMP
    
    Extend ata_acpi_associate_sata_port() such that it can handle PMP and
    call it when PMP is attached and detached.
    
    Build breakage when !CONFIG_ATA_ACPI was spotted and fixed by Petr
    Vandrovec.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Petr Vandrovec <petr@vandrovec.name>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index a44172fd1f5c..f8bd955c5ba7 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -103,11 +103,13 @@ extern struct ata_port *ata_port_alloc(struct ata_host *host);
 
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
+extern void ata_acpi_associate_sata_port(struct ata_port *ap);
 extern void ata_acpi_associate(struct ata_host *host);
 extern int ata_acpi_on_suspend(struct ata_port *ap);
 extern void ata_acpi_on_resume(struct ata_port *ap);
 extern int ata_acpi_on_devcfg(struct ata_device *adev);
 #else
+static inline void ata_acpi_associate_sata_port(struct ata_port *ap) { }
 static inline void ata_acpi_associate(struct ata_host *host) { }
 static inline int ata_acpi_on_suspend(struct ata_port *ap) { return 0; }
 static inline void ata_acpi_on_resume(struct ata_port *ap) { }

commit 633273a3ed1cf37ced90475b0f95cf81deab04f1
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Sep 23 13:19:54 2007 +0900

    libata-pmp: hook PMP support and enable it
    
    Hook PMP support into libata and enable it.  Connect SCR and probing
    functions, and update ata_dev_classify() to detect PMP.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index a9b9c9e1e105..a44172fd1f5c 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -29,7 +29,7 @@
 #define __LIBATA_H__
 
 #define DRV_NAME	"libata"
-#define DRV_VERSION	"2.21"	/* must be exactly four chars */
+#define DRV_VERSION	"3.00"	/* must be exactly four chars */
 
 struct ata_scsi_args {
 	struct ata_device	*dev;

commit 3af9a77af9e2b72366363864bfcd3d51465ff98a
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Sep 23 13:19:54 2007 +0900

    libata-pmp: implement Port Multiplier support
    
    Implement Port Multiplier support.  To support PMP, a LLDD has to
    supply ops->pmp_read() and pmp_write().  If non-null, ->pmp_attach and
    ->pmp_detach are called on PMP attach and detach, respectively.
    
    ->pmp_read/write() can be called while the port is frozen, so they
    must be implemented by polling.  This patch supplies several helpers
    to ease ->pmp_read/write() implementation.
    
    Also, irq_handler and error_handler must be PMP aware.  Most of PMP
    aware EH can be done by calling ata_pmp_do_eh() with appropriate
    methods.  PMP EH uses separate set of reset methods and this patch
    implements standard prereset, hardreset and postreset methods.
    
    This patch only implements PMP support.  The next patch will integrate
    PMP into the reset of libata and thus enable PMP support.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index ebe22982e80c..a9b9c9e1e105 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -153,6 +153,11 @@ extern void ata_schedule_scsi_eh(struct Scsi_Host *shost);
 extern void ata_scsi_dev_rescan(struct work_struct *work);
 extern int ata_bus_probe(struct ata_port *ap);
 
+/* libata-pmp.c */
+extern int sata_pmp_scr_read(struct ata_link *link, int reg, u32 *val);
+extern int sata_pmp_scr_write(struct ata_link *link, int reg, u32 val);
+extern int sata_pmp_attach(struct ata_device *dev);
+
 /* libata-eh.c */
 extern enum scsi_eh_timer_return ata_scsi_timed_out(struct scsi_cmnd *cmd);
 extern void ata_scsi_error(struct Scsi_Host *host);

commit 7d77b247088fb360aa74bfdd9e19bce1e1987668
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Sep 23 13:14:13 2007 +0900

    libata-pmp-prep: implement sata_async_notification()
    
    AN serves multiple purposes.  For ATAPI, it's used for media change
    notification.  For PMP, for downstream PHY status change notification.
    Implement sata_async_notification() which demultiplexes AN.
    
    To avoid unnecessary port events, ATAPI AN is not enabled if PMP is
    attached but SNTF is not available.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Kriten Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 0f3e355fdfd7..ebe22982e80c 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -119,6 +119,7 @@ extern int ata_scsi_add_hosts(struct ata_host *host,
 			      struct scsi_host_template *sht);
 extern void ata_scsi_scan_host(struct ata_port *ap, int sync);
 extern int ata_scsi_offline_dev(struct ata_device *dev);
+extern void ata_scsi_media_change_notify(struct ata_device *dev);
 extern void ata_scsi_hotplug(struct work_struct *work);
 extern unsigned int ata_scsiop_inq_std(struct ata_scsi_args *args, u8 *rbuf,
 			       unsigned int buflen);

commit fb7fd61454c8681cd2621051a710b78a00369203
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Sep 23 13:14:12 2007 +0900

    libata-pmp-prep: make a number of functions global to libata
    
    Make a number of functions from libata-core.c and libata-eh.c global
    to libata (drivers/ata/libata.h).  These will be used by PMP.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index d4d369908c0f..0f3e355fdfd7 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -95,6 +95,8 @@ extern void ata_dev_select(struct ata_port *ap, unsigned int device,
 extern void swap_buf_le16(u16 *buf, unsigned int buf_words);
 extern int ata_flush_cache(struct ata_device *dev);
 extern void ata_dev_init(struct ata_device *dev);
+extern void ata_link_init(struct ata_port *ap, struct ata_link *link, int pmp);
+extern int sata_link_init_spd(struct ata_link *link);
 extern int ata_task_ioctl(struct scsi_device *scsidev, void __user *arg);
 extern int ata_cmd_ioctl(struct scsi_device *scsidev, void __user *arg);
 extern struct ata_port *ata_port_alloc(struct ata_host *host);
@@ -156,6 +158,21 @@ extern void ata_scsi_error(struct Scsi_Host *host);
 extern void ata_port_wait_eh(struct ata_port *ap);
 extern void ata_eh_fastdrain_timerfn(unsigned long arg);
 extern void ata_qc_schedule_eh(struct ata_queued_cmd *qc);
+extern void ata_eh_detach_dev(struct ata_device *dev);
+extern void ata_eh_about_to_do(struct ata_link *link, struct ata_device *dev,
+			       unsigned int action);
+extern void ata_eh_done(struct ata_link *link, struct ata_device *dev,
+			unsigned int action);
+extern void ata_eh_autopsy(struct ata_port *ap);
+extern void ata_eh_report(struct ata_port *ap);
+extern int ata_eh_reset(struct ata_link *link, int classify,
+			ata_prereset_fn_t prereset, ata_reset_fn_t softreset,
+			ata_reset_fn_t hardreset, ata_postreset_fn_t postreset);
+extern int ata_eh_recover(struct ata_port *ap, ata_prereset_fn_t prereset,
+			  ata_reset_fn_t softreset, ata_reset_fn_t hardreset,
+			  ata_postreset_fn_t postreset,
+			  struct ata_link **r_failed_disk);
+extern void ata_eh_finish(struct ata_port *ap);
 
 /* libata-sff.c */
 extern u8 ata_irq_on(struct ata_port *ap);

commit 422c9daa8b5bea09f3393b11a106afd68850b39b
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Sep 23 13:14:12 2007 +0900

    libata-pmp-prep: add @new_class to ata_dev_revalidate()
    
    Consider newly found class code while revalidating.  PMP resetting
    always results in valid class code and issuing PMP commands to
    ATA/ATAPI device isn't very attractive.  Add @new_class to
    ata_dev_revalidate() and check class code for revalidation.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index e45f6d5542d5..d4d369908c0f 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -78,7 +78,8 @@ extern unsigned int ata_do_simple_cmd(struct ata_device *dev, u8 cmd);
 extern int ata_dev_read_id(struct ata_device *dev, unsigned int *p_class,
 			   unsigned int flags, u16 *id);
 extern int ata_dev_reread_id(struct ata_device *dev, unsigned int readid_flags);
-extern int ata_dev_revalidate(struct ata_device *dev, unsigned int readid_flags);
+extern int ata_dev_revalidate(struct ata_device *dev, unsigned int new_class,
+			      unsigned int readid_flags);
 extern int ata_dev_configure(struct ata_device *dev);
 extern int sata_down_spd_limit(struct ata_link *link);
 extern int sata_set_spd_needed(struct ata_link *link);

commit c78968bb0f7714ceba1cdfa23714454fc98cefdf
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Sep 21 21:03:28 2007 -0400

    [libata] SCSI: simulator version, not device version, belongs in VPD
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 11f64a43b38a..e45f6d5542d5 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -29,6 +29,7 @@
 #define __LIBATA_H__
 
 #define DRV_NAME	"libata"
+#define DRV_VERSION	"2.21"	/* must be exactly four chars */
 
 struct ata_scsi_args {
 	struct ata_device	*dev;

commit baf4fdfaaf5cb9f4fb1c341c8cef60a64e580582
Author: Mark Lord <liml@rtr.ca>
Date:   Wed Aug 8 01:08:45 2007 +0900

    libata: add support for ATA_16 on ATAPI
    
    Add support for issuing ATA_16 passthru commands to ATAPI devices
    managed by libata.  It requires the previous CDB length fix patch.
    
    A boot/module parameter, "atapi_passthru16=0" can be used to globally
    disable this feature, if ever desired.
    
    tj: restructured __ata_scsi_queuecmd() according to Jeff's suggestion.
    
    Signed-off-by: Mark Lord <liml@rtr.ca>
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 6d85edefa7c6..11f64a43b38a 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -56,6 +56,7 @@ extern unsigned int ata_print_id;
 extern struct workqueue_struct *ata_aux_wq;
 extern int atapi_enabled;
 extern int atapi_dmadir;
+extern int atapi_passthru16;
 extern int libata_fua;
 extern int libata_noacpi;
 extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev);

commit 0260731f0187840e272bfa10d3ba0f3e417976f5
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Aug 6 18:36:23 2007 +0900

    libata-link: linkify config/EH related functions
    
    Make the following functions deal with ata_link instead of ata_port.
    
    * ata_set_mode()
    * ata_eh_autopsy() and related functions
    * ata_eh_report() and related functions
    * suspend/resume related functions
    * ata_eh_recover() and related functions
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 700843a9f30a..6d85edefa7c6 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -81,7 +81,7 @@ extern int ata_dev_configure(struct ata_device *dev);
 extern int sata_down_spd_limit(struct ata_link *link);
 extern int sata_set_spd_needed(struct ata_link *link);
 extern int ata_down_xfermask_limit(struct ata_device *dev, unsigned int sel);
-extern int ata_set_mode(struct ata_port *ap, struct ata_device **r_failed_dev);
+extern int ata_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
 extern void ata_sg_clean(struct ata_queued_cmd *qc);
 extern void ata_qc_free(struct ata_queued_cmd *qc);
 extern void ata_qc_issue(struct ata_queued_cmd *qc);

commit 936fd7328657884d5a69a55666c74a55aa83ca27
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Aug 6 18:36:23 2007 +0900

    libata-link: linkify PHY-related functions
    
    Make the following PHY-related functions to deal with ata_link instead
    of ata_port.
    
    * sata_print_link_status()
    * sata_down_spd_limit()
    * ata_set_sata_spd_limit() and friends
    * sata_link_debounce/resume()
    * sata_scr_valid/read/write/write_flush()
    * ata_link_on/offline()
    
    This patch introduces no behavior change.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 564cd234c805..700843a9f30a 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -78,8 +78,8 @@ extern int ata_dev_read_id(struct ata_device *dev, unsigned int *p_class,
 extern int ata_dev_reread_id(struct ata_device *dev, unsigned int readid_flags);
 extern int ata_dev_revalidate(struct ata_device *dev, unsigned int readid_flags);
 extern int ata_dev_configure(struct ata_device *dev);
-extern int sata_down_spd_limit(struct ata_port *ap);
-extern int sata_set_spd_needed(struct ata_port *ap);
+extern int sata_down_spd_limit(struct ata_link *link);
+extern int sata_set_spd_needed(struct ata_link *link);
 extern int ata_down_xfermask_limit(struct ata_device *dev, unsigned int sel);
 extern int ata_set_mode(struct ata_port *ap, struct ata_device **r_failed_dev);
 extern void ata_sg_clean(struct ata_queued_cmd *qc);

commit 5ddf24c5ea9d715dc4f5d5d5dd1c9337d90466dc
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jul 16 14:29:41 2007 +0900

    libata: implement EH fast drain
    
    In most cases, when EH is scheduled, all in-flight commands are
    aborted causing EH to kick in immediately.  However, in some cases
    (especially with PMP), it's unclear which commands are affected by the
    error condition and although aborting all in-flight commands work, it
    isn't optimal and may cause unnecessary disruption.  On the other
    hand, waiting for in-flight commands to drain themselves can take up
    to 30seconds.
    
    This patch implements EH fast drain to handle such situations.  It
    gives in-flight commands some time to finish up but doesn't wait for
    too long.  After EH is scheduled, fast drain timer is started and if
    no other completion occurs in ATA_EH_FASTDRAIN_INTERVAL all in-flight
    commands are aborted.  If any completion occurred in the interval, the
    port is given another interval to finish up itself.
    
    Currently ATA_EH_FASTDRAIN_INTERVAL is 3 secs which should be enough
    for finishing up most commands.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 48836b22ce2f..564cd234c805 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -151,6 +151,7 @@ extern int ata_bus_probe(struct ata_port *ap);
 extern enum scsi_eh_timer_return ata_scsi_timed_out(struct scsi_cmnd *cmd);
 extern void ata_scsi_error(struct Scsi_Host *host);
 extern void ata_port_wait_eh(struct ata_port *ap);
+extern void ata_eh_fastdrain_timerfn(unsigned long arg);
 extern void ata_qc_schedule_eh(struct ata_queued_cmd *qc);
 
 /* libata-sff.c */

commit 1ae463171cc1b1ea6dad7bcb298e96c073e7373e
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Jul 16 14:29:40 2007 +0900

    libata: improve SCSI scan failure handling
    
    SCSI scan may fail due to memory allocation failure even if EH is not
    in progress.  Due to use of GFP_ATOMIC in SCSI scan path, allocation
    failure isn't too rare especially while probing multiple devices at
    once which is the case when a bunch of devices are connected to PMP.
    
    This patch moves SCSI scan failure detetion logic from
    ata_scsi_hotplug() to ata_scsi_scan_host() and implement synchronous
    scan behavior.  The synchronous path sleeps briefly and repeats SCSI
    scan if some devices aren't attached properly.  It contains robust
    retry loop to minimize the chance of device misdetection during boot
    and falls back to async retry if everything fails.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index ba17fc5f2e99..48836b22ce2f 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -112,7 +112,7 @@ static inline int ata_acpi_on_devcfg(struct ata_device *adev) { return 0; }
 /* libata-scsi.c */
 extern int ata_scsi_add_hosts(struct ata_host *host,
 			      struct scsi_host_template *sht);
-extern void ata_scsi_scan_host(struct ata_port *ap);
+extern void ata_scsi_scan_host(struct ata_port *ap, int sync);
 extern int ata_scsi_offline_dev(struct ata_device *dev);
 extern void ata_scsi_hotplug(struct work_struct *work);
 extern unsigned int ata_scsiop_inq_std(struct ata_scsi_args *args, u8 *rbuf,

commit 64578a3de723d502621860f9d4d28f34d001b066
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue May 15 03:28:16 2007 +0900

    libata-acpi: implement _GTM/_STM support
    
    Implement _GTM/_STM support.  acpi_gtm is added to ata_port which
    stores _GTM parameters over suspend/resume cycle.  A new hook
    ata_acpi_on_suspend() is responsible for storing _GTM parameters
    during suspend.  _STM is executed in ata_acpi_on_resume().  With this
    change, invoking _GTF is safe on IDE hierarchy and acpi_sata check
    before _GTF is removed.
    
    ata_acpi_gtm() and ata_acpi_stm() implementation is taken from Alan
    Cox's pata_acpi implementation.  ata_acpi_gtm() is fixed such that the
    result parameter is not shifted by sizeof(union acpi_object).
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index bee7cbc4c97c..ba17fc5f2e99 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -99,10 +99,12 @@ extern struct ata_port *ata_port_alloc(struct ata_host *host);
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
 extern void ata_acpi_associate(struct ata_host *host);
+extern int ata_acpi_on_suspend(struct ata_port *ap);
 extern void ata_acpi_on_resume(struct ata_port *ap);
 extern int ata_acpi_on_devcfg(struct ata_device *adev);
 #else
 static inline void ata_acpi_associate(struct ata_host *host) { }
+static inline int ata_acpi_on_suspend(struct ata_port *ap) { return 0; }
 static inline void ata_acpi_on_resume(struct ata_port *ap) { }
 static inline int ata_acpi_on_devcfg(struct ata_device *adev) { return 0; }
 #endif

commit 6746544c3b143ca7071d144f1882ccbe1f47b08d
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue May 15 03:28:16 2007 +0900

    libata: reimplement ACPI invocation
    
    This patch reimplements ACPI invocation such that, instead of
    exporting ACPI details to the rest of libata, ACPI event handlers -
    ata_acpi_on_resume() and ata_acpi_on_devcfg() - are used.  These two
    functions are responsible for determining whether specific ACPI method
    is used and when.
    
    On resume, _GTF is scheduled by setting ATA_DFLAG_ACPI_PENDING device
    flag.  This is done this way to avoid performing the action on wrong
    device device (device swapping while suspended).
    
    On every ata_dev_configure(), ata_acpi_on_devcfg() is called, which
    performs _SDD and _GTF.  _GTF is performed only after resuming and, if
    SATA, hardreset as the ACPI spec specifies.  As _GTF may contain
    arbitrary commands, IDENTIFY page is re-read after _GTF taskfiles are
    executed.
    
    If one of ACPI methods fails, ata_acpi_on_devcfg() retries on the
    first failure.  If it fails again on the second try, ACPI is disabled
    on the device.  Note that successful configuration clears ACPI failed
    status.
    
    With all feature checks moved to the above two functions,
    do_drive_set_taskfiles() is trivial and thus collapsed into
    ata_acpi_exec_tfs(), which is now static and converted to return the
    number of executed taskfiles to be used by ata_acpi_on_resume().  As
    failures are handled properly, ata_acpi_push_id() now returns -errno
    on errors instead of unconditional zero.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 29037cd7c651..bee7cbc4c97c 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -99,18 +99,12 @@ extern struct ata_port *ata_port_alloc(struct ata_host *host);
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
 extern void ata_acpi_associate(struct ata_host *host);
-extern int ata_acpi_exec_tfs(struct ata_port *ap);
-extern int ata_acpi_push_id(struct ata_device *dev);
+extern void ata_acpi_on_resume(struct ata_port *ap);
+extern int ata_acpi_on_devcfg(struct ata_device *adev);
 #else
 static inline void ata_acpi_associate(struct ata_host *host) { }
-static inline int ata_acpi_exec_tfs(struct ata_port *ap)
-{
-	return 0;
-}
-static inline int ata_acpi_push_id(struct ata_device *dev)
-{
-	return 0;
-}
+static inline void ata_acpi_on_resume(struct ata_port *ap) { }
+static inline int ata_acpi_on_devcfg(struct ata_device *adev) { return 0; }
 #endif
 
 /* libata-scsi.c */

commit fafbae87db88a73b166d3bc3294d209207f27056
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue May 15 03:28:16 2007 +0900

    libata-acpi: implement ata_acpi_associate()
    
    * Add acpi_handle to ata_host and ata_port.  Rename
      ata_device->obj_handle to ->acpi_handle and move it above such that
      it doesn't get cleared on reconfiguration.
    
    * Replace ACPI node association which ata_acpi_associate() which is
      called once during host initialization.  Unlike the previous
      implementation, ata_acpi_associate() uses ATA_FLAG_ACPI_SATA to
      choose between IDE or SATA ACPI hierarchy and uses simple child look
      up instead of recursive walk to match the nodes.  This is way safer
      and simpler.  Please read the following message for more info.
    
      http://article.gmane.org/gmane.linux.ide/17554
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 5e2466658420..29037cd7c651 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -98,9 +98,11 @@ extern struct ata_port *ata_port_alloc(struct ata_host *host);
 
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
+extern void ata_acpi_associate(struct ata_host *host);
 extern int ata_acpi_exec_tfs(struct ata_port *ap);
 extern int ata_acpi_push_id(struct ata_device *dev);
 #else
+static inline void ata_acpi_associate(struct ata_host *host) { }
 static inline int ata_acpi_exec_tfs(struct ata_port *ap)
 {
 	return 0;

commit d9aca22cf443f5ed77d15a320abbab055ae4a976
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu May 17 16:43:26 2007 +0200

    libata: remove libata.spindown_compat
    
    With STANDBYDOWN tracking added, libata.spindown_compat isn't
    necessary anymore.  If userspace shutdown(8) issues STANDBYNOW, libata
    warns.  If userspace shutdown(8) doesn't issue STANDBYNOW, libata does
    the right thing.  Userspace can tell whether kernel supports spindown
    by testing whether sysfs node manage_start_stop exists as before.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 13cb0c9af68d..5e2466658420 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -58,7 +58,6 @@ extern int atapi_enabled;
 extern int atapi_dmadir;
 extern int libata_fua;
 extern int libata_noacpi;
-extern int ata_spindown_compat;
 extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev);
 extern int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
 			   u64 block, u32 n_block, unsigned int tf_flags,

commit fe30911b34098db58c21d0f936f6c3f17f32deb8
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue May 15 03:28:15 2007 +0900

    libata: separate out ata_dev_reread_id()
    
    Separate out ata_dev_reread_id() from ata_dev_revalidate().
    ata_dev_reread_id() reads IDENTIFY page and determines whether the
    same device is still there.  ata_dev_revalidate() reconfigures after
    reread completes.  This will be used by ACPI update.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 8b71b73a199c..13cb0c9af68d 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -76,7 +76,8 @@ extern unsigned ata_exec_internal_sg(struct ata_device *dev,
 extern unsigned int ata_do_simple_cmd(struct ata_device *dev, u8 cmd);
 extern int ata_dev_read_id(struct ata_device *dev, unsigned int *p_class,
 			   unsigned int flags, u16 *id);
-extern int ata_dev_revalidate(struct ata_device *dev, unsigned int flags);
+extern int ata_dev_reread_id(struct ata_device *dev, unsigned int readid_flags);
+extern int ata_dev_revalidate(struct ata_device *dev, unsigned int readid_flags);
 extern int ata_dev_configure(struct ata_device *dev);
 extern int sata_down_spd_limit(struct ata_port *ap);
 extern int sata_set_spd_needed(struct ata_port *ap);

commit 3a32a8e96694a243ec7e7feb6d76dfc4b1fe90c1
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat May 5 23:50:38 2007 +0900

    libata-acpi: clean up parameters and misc stuff
    
    This patch cleans up libata-acpi such that it looks similar to other
    libata files.  This patch doesn't introuce any behavior changes.
    
    * make libata-acpi functions take ata_device instead of ata_port +
      device index
    * s/atadev/dev/
    * de-indent local variable declarations
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 49ec182e5057..8b71b73a199c 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -99,13 +99,13 @@ extern struct ata_port *ata_port_alloc(struct ata_host *host);
 /* libata-acpi.c */
 #ifdef CONFIG_ATA_ACPI
 extern int ata_acpi_exec_tfs(struct ata_port *ap);
-extern int ata_acpi_push_id(struct ata_port *ap, unsigned int ix);
+extern int ata_acpi_push_id(struct ata_device *dev);
 #else
 static inline int ata_acpi_exec_tfs(struct ata_port *ap)
 {
 	return 0;
 }
-static inline int ata_acpi_push_id(struct ata_port *ap, unsigned int ix)
+static inline int ata_acpi_push_id(struct ata_device *dev)
 {
 	return 0;
 }

commit e92351bb53c0849fabfa80be53cbf3b0aa166e54
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat May 5 23:50:38 2007 +0900

    libata-acpi: s/CONFIG_SATA_ACPI/CONFIG_ATA_ACPI/
    
    ACPI applies to both SATA and PATA.  Drop the 'S' from the config
    variable.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 316bf8ae4536..49ec182e5057 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -97,7 +97,7 @@ extern int ata_cmd_ioctl(struct scsi_device *scsidev, void __user *arg);
 extern struct ata_port *ata_port_alloc(struct ata_host *host);
 
 /* libata-acpi.c */
-#ifdef CONFIG_SATA_ACPI
+#ifdef CONFIG_ATA_ACPI
 extern int ata_acpi_exec_tfs(struct ata_port *ap);
 extern int ata_acpi_push_id(struct ata_port *ap, unsigned int ix);
 #else

commit 920a4b1038e442700a1cfac77ea7e20bd615a2c3
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri May 4 21:28:48 2007 +0200

    libata: implement libata.spindown_compat
    
    Now that libata uses sd->manage_start_stop, libata spins down disk on
    shutdown.  In an attempt to compensate libata's previous shortcoming,
    some distros sync and spin down disks attached via libata in their
    shutdown(8).  Some disks spin back up just to spin down again on
    STANDBYNOW1 if the command is issued when the disk is spun down, so
    this double spinning down causes problem.
    
    This patch implements module parameter libata.spindown_compat which,
    when set to one (default value), prevents libata from spinning down
    disks on shutdown thus avoiding double spinning down.  Note that
    libata spins down disks for suspend to mem and disk, so with
    libata.spindown_compat set to one, disks should be properly spun down
    in all cases without modifying shutdown(8).
    
    shutdown(8) should be fixed eventually.  Some drive do spin up on
    SYNCHRONZE_CACHE even when their cache is clean.  Those disks
    currently spin up briefly when sd tries to shutdown the device and
    then the machine powers off immediately, which can't be good for the
    head.  We can't skip SYNCHRONIZE_CACHE during shudown as it can be
    dangerous data integrity-wise.
    
    So, this spindown_compat parameter is already scheduled for removal by
    the end of the next year and here's what shutdown(8) should do.
    
      * Check whether /sys/modules/libata/parameters/spindown_compat
        exists.  If it does, write 0 to it.
    
      * For each libata harddisk {
            * Check whether /sys/class/scsi_disk/h:c:i:l/manage_start_stop
              exists.  Iff it doesn't, synchronize cache and spin the disk
              down as before.
      }
    
    The above procedure will make shutdown(8) work properly with kernels
    before this change, ones with this workaround and later ones without
    it.
    
    To accelerate shutdown(8) updates, if the compat mode is in use, this
    patch prints BIG FAT warning for five seconds during shutdown (the
    optimal interval to annoy the user just the right amount discovered by
    hours of tireless usability testing).
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 5f4d40cd3288..316bf8ae4536 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -58,6 +58,7 @@ extern int atapi_enabled;
 extern int atapi_dmadir;
 extern int libata_fua;
 extern int libata_noacpi;
+extern int ata_spindown_compat;
 extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev);
 extern int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
 			   u64 block, u32 n_block, unsigned int tf_flags,

commit 6bfff31e77cfa1b13490337e5a4dbaa3407e83ac
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Apr 17 23:44:08 2007 +0900

    libata: kill probe_ent and related helpers
    
    All drivers are converted to new init model.  Kill probe_ent,
    ata_device_add() and ata_pci_init_native_mode().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index b4d5253d627a..5f4d40cd3288 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -93,8 +93,6 @@ extern int ata_flush_cache(struct ata_device *dev);
 extern void ata_dev_init(struct ata_device *dev);
 extern int ata_task_ioctl(struct scsi_device *scsidev, void __user *arg);
 extern int ata_cmd_ioctl(struct scsi_device *scsidev, void __user *arg);
-extern struct ata_probe_ent *ata_probe_ent_alloc(struct device *dev,
-						 const struct ata_port_info *port);
 extern struct ata_port *ata_port_alloc(struct ata_host *host);
 
 /* libata-acpi.c */

commit f31871951b38daf2d7ca17daad59fdb735062da3
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Apr 17 23:44:07 2007 +0900

    libata: separate out ata_host_alloc() and ata_host_register()
    
    Reorganize ata_host_alloc() and its subroutines into the following
    three functions.
    
    * ata_host_alloc() : allocates host and its ports.  shost is not
      registered automatically.
    
    * ata_scsi_add_hosts() : allocates and adds shosts associated with an
      ATA host.  Used by ata_host_register().
    
    * ata_host_register() : takes a fully initialized ata_host structure
      and registers it to libata layer and probes it.
    
    Only ata_host_alloc() and ata_host_register() are exported.
    ata_device_add() is rewritten using the above functions.  This patch
    does not introduce any observable behavior change.  Things worth
    mentioning.
    
    * print_id is assigned at registration time and LLDs are allowed to
      overallocate ports and reduce host->n_ports during initialization.
      ata_host_register() will throw away unused ports automatically.
    
    * All SCSI host initialization stuff now resides in
      ata_scsi_add_hosts() in libata-scsi.c, where it should be.
    
    * ipr is now the only user of ata_host_init().  Either kill it by
      converting ipr to use ata_host_alloc() and friends or rename and
      move it to libata-scsi.c
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 1f1e3a51f859..b4d5253d627a 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -52,6 +52,7 @@ enum {
 	ATA_DNXFER_QUIET	= (1 << 31),
 };
 
+extern unsigned int ata_print_id;
 extern struct workqueue_struct *ata_aux_wq;
 extern int atapi_enabled;
 extern int atapi_dmadir;
@@ -92,10 +93,9 @@ extern int ata_flush_cache(struct ata_device *dev);
 extern void ata_dev_init(struct ata_device *dev);
 extern int ata_task_ioctl(struct scsi_device *scsidev, void __user *arg);
 extern int ata_cmd_ioctl(struct scsi_device *scsidev, void __user *arg);
-extern void ata_port_init(struct ata_port *ap, struct ata_host *host,
-			  const struct ata_probe_ent *ent, unsigned int port_no);
 extern struct ata_probe_ent *ata_probe_ent_alloc(struct device *dev,
 						 const struct ata_port_info *port);
+extern struct ata_port *ata_port_alloc(struct ata_host *host);
 
 /* libata-acpi.c */
 #ifdef CONFIG_SATA_ACPI
@@ -113,8 +113,8 @@ static inline int ata_acpi_push_id(struct ata_port *ap, unsigned int ix)
 #endif
 
 /* libata-scsi.c */
-extern struct scsi_transport_template ata_scsi_transport_template;
-
+extern int ata_scsi_add_hosts(struct ata_host *host,
+			      struct scsi_host_template *sht);
 extern void ata_scsi_scan_host(struct ata_port *ap);
 extern int ata_scsi_offline_dev(struct ata_device *dev);
 extern void ata_scsi_hotplug(struct work_struct *work);

commit d7d0dad62a641c156386288a747c1a2f6bb2e42d
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Mar 28 01:57:37 2007 -0400

    [libata] Disable ACPI by default; fix namespace problems
    
    Not yet ready to turn on ATA ACPI by default, for either PATA or SATA.
    
    Also, rename the global-scope module parameter variable 'noacpi' to
    something more libata-specific, reducing the potential for namespace
    collision.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index c42671493e8c..1f1e3a51f859 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -56,7 +56,7 @@ extern struct workqueue_struct *ata_aux_wq;
 extern int atapi_enabled;
 extern int atapi_dmadir;
 extern int libata_fua;
-extern int noacpi;
+extern int libata_noacpi;
 extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev);
 extern int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
 			   u64 block, u32 n_block, unsigned int tf_flags,

commit 4bb64fb98168981d3e5a0e790c077ff511768e84
Author: Alan <alan@lxorguk.ukuu.org.uk>
Date:   Fri Feb 16 01:40:04 2007 -0800

    SiS warning fixes
    
    Somehow the sis_info133 external definition ended up in libata.h and that
    was included by both drivers.  However libata.h contains libata-* specific
    internals and clashing defines like DRV_NAME so this makes a mess.  Move
    the extern into the C file and remove the warnings
    
    [akpm@linux-foundation.org: create sis.h to avoid extern-decl-in-C]
    Signed-off-by: Alan Cox <alan@redhat.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 29bd7f80fc40..c42671493e8c 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -159,7 +159,5 @@ extern void ata_qc_schedule_eh(struct ata_queued_cmd *qc);
 /* libata-sff.c */
 extern u8 ata_irq_on(struct ata_port *ap);
 
-/* pata_sis.c */
-extern struct ata_port_info sis_info133;
 
 #endif /* __LIBATA_H__ */

commit 909706a2477a92b6e0f3083ed4b944cb1d09acfa
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Feb 2 16:22:31 2007 +0900

    libata: kill ATA_DNXFER_ANY
    
    ATA_DNXFER_ANY isn't used anymore.  Kill it.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 8533de67d87e..29bd7f80fc40 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -48,7 +48,6 @@ enum {
 	ATA_DNXFER_40C		= 2,	/* apply 40c cable limit */
 	ATA_DNXFER_FORCE_PIO	= 3,	/* force PIO */
 	ATA_DNXFER_FORCE_PIO0	= 4,	/* force PIO0 */
-	ATA_DNXFER_ANY		= 5,	/* speed down any */
 
 	ATA_DNXFER_QUIET	= (1 << 31),
 };

commit 458337dbb120d33f326e2b19d54eca8cf179b5c0
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Feb 2 16:22:30 2007 +0900

    libata: improve ata_down_xfermask_limit()
    
    Make ata_down_xfermask_limit() accept @sel instead of @force_pio0.
    @sel selects how the xfermask limit will be adjusted.  The following
    selectors are defined.
    
    * ATA_DNXFER_PIO        : only speed down PIO
    * ATA_DNXFER_DMA        : only speed down DMA, don't cause transfer mode change
    * ATA_DNXFER_40C        : apply 40c cable limit
    * ATA_DNXFER_FORCE_PIO  : force PIO
    * ATA_DNXFER_FORCE_PIO0 : force PIO0 (same as original with @force_pio0 == 1)
    * ATA_DNXFER_ANY        : same as original with @force_pio0 == 0
    
    Currently, only ANY and FORCE_PIO0 are used to maintain the original
    behavior.  Other selectors will be used later to improve EH speed down
    sequence.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 0ad7781d72a3..8533de67d87e 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -41,6 +41,16 @@ struct ata_scsi_args {
 enum {
 	/* flags for ata_dev_read_id() */
 	ATA_READID_POSTRESET	= (1 << 0), /* reading ID after reset */
+
+	/* selector for ata_down_xfermask_limit() */
+	ATA_DNXFER_PIO		= 0,	/* speed down PIO */
+	ATA_DNXFER_DMA		= 1,	/* speed down DMA */
+	ATA_DNXFER_40C		= 2,	/* apply 40c cable limit */
+	ATA_DNXFER_FORCE_PIO	= 3,	/* force PIO */
+	ATA_DNXFER_FORCE_PIO0	= 4,	/* force PIO0 */
+	ATA_DNXFER_ANY		= 5,	/* speed down any */
+
+	ATA_DNXFER_QUIET	= (1 << 31),
 };
 
 extern struct workqueue_struct *ata_aux_wq;
@@ -69,7 +79,7 @@ extern int ata_dev_revalidate(struct ata_device *dev, unsigned int flags);
 extern int ata_dev_configure(struct ata_device *dev);
 extern int sata_down_spd_limit(struct ata_port *ap);
 extern int sata_set_spd_needed(struct ata_port *ap);
-extern int ata_down_xfermask_limit(struct ata_device *dev, int force_pio0);
+extern int ata_down_xfermask_limit(struct ata_device *dev, unsigned int sel);
 extern int ata_set_mode(struct ata_port *ap, struct ata_device **r_failed_dev);
 extern void ata_sg_clean(struct ata_queued_cmd *qc);
 extern void ata_qc_free(struct ata_queued_cmd *qc);

commit 7ea1fbc2a2449bc034a3d255f36f2e5486d52fe8
Author: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Date:   Thu Sep 28 11:29:12 2006 -0700

    [PATCH] libata: ACPI _SDD support
    
    _SDD (Set Device Data) is an ACPI method that is used to tell the
    firmware what the identify data is of the device that is attached to
    the port.  It is an optional method, and it's ok for it to be missing.
    Because of this, we always return success from the routine that calls
    this method, even if the execution fails.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>
    (cherry picked from 39aa79e0a1f5f2e28aa341f035940746a98b45b1 commit)

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index ea02903e8503..0ad7781d72a3 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -91,11 +91,16 @@ extern struct ata_probe_ent *ata_probe_ent_alloc(struct device *dev,
 /* libata-acpi.c */
 #ifdef CONFIG_SATA_ACPI
 extern int ata_acpi_exec_tfs(struct ata_port *ap);
+extern int ata_acpi_push_id(struct ata_port *ap, unsigned int ix);
 #else
 static inline int ata_acpi_exec_tfs(struct ata_port *ap)
 {
 	return 0;
 }
+static inline int ata_acpi_push_id(struct ata_port *ap, unsigned int ix)
+{
+	return 0;
+}
 #endif
 
 /* libata-scsi.c */

commit 11ef697b37e3c85ce1ac21f7711babf1f5b12784
Author: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
Date:   Thu Sep 28 11:29:01 2006 -0700

    [PATCH] libata: ACPI and _GTF support
    
    _GTF is an acpi method that is used to reinitialize the drive.  It returns
    a task file containing ata commands that are sent back to the drive to restore
    it to boot up defaults.
    
    Signed-off-by: Kristen Carlson Accardi <kristen.c.accardi@intel.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>
    (cherry picked from 9c69cab24b51a89664f4c0dfaf8a436d32117624 commit)

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 06ccf230e3c2..ea02903e8503 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -47,6 +47,7 @@ extern struct workqueue_struct *ata_aux_wq;
 extern int atapi_enabled;
 extern int atapi_dmadir;
 extern int libata_fua;
+extern int noacpi;
 extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev);
 extern int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
 			   u64 block, u32 n_block, unsigned int tf_flags,
@@ -87,6 +88,15 @@ extern void ata_port_init(struct ata_port *ap, struct ata_host *host,
 extern struct ata_probe_ent *ata_probe_ent_alloc(struct device *dev,
 						 const struct ata_port_info *port);
 
+/* libata-acpi.c */
+#ifdef CONFIG_SATA_ACPI
+extern int ata_acpi_exec_tfs(struct ata_port *ap);
+#else
+static inline int ata_acpi_exec_tfs(struct ata_port *ap)
+{
+	return 0;
+}
+#endif
 
 /* libata-scsi.c */
 extern struct scsi_transport_template ata_scsi_transport_template;

commit fda0efc5977864a90f365aeeb13f2546854e2aa9
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Jan 31 07:43:15 2007 -0500

    [libata] Shuffle DRV_xxx in core and SiS drivers, to kill warnings
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 94eeb3d3c674..06ccf230e3c2 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -29,7 +29,6 @@
 #define __LIBATA_H__
 
 #define DRV_NAME	"libata"
-#define DRV_VERSION	"2.00"	/* must be exactly four chars */
 
 struct ata_scsi_args {
 	struct ata_device	*dev;

commit 77a527eadb425b60db3f5f0aae6a4c51c38e35e5
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Jan 30 00:59:17 2007 -0800

    fix CONFIG_SATA_SIS=y compile error
    
    Static code shouldn't be used from other modules.
    
    drivers/built-in.o: In function `sis_init_one':
    sata_sis.c:(.text+0x7634cd): undefined reference to `sis_info133'
    sata_sis.c:(.text+0x7634d6): undefined reference to `sis_info133'
    
    While I was at it, I also moved the prototype of this struct to a header
    file.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 81ae41d5f23f..94eeb3d3c674 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -136,4 +136,7 @@ extern void ata_qc_schedule_eh(struct ata_queued_cmd *qc);
 /* libata-sff.c */
 extern u8 ata_irq_on(struct ata_port *ap);
 
+/* pata_sis.c */
+extern struct ata_port_info sis_info133;
+
 #endif /* __LIBATA_H__ */

commit 9db73724453a9350e1c22dbe732d427e2939a5c9
Merge: 4c1ac1b49122 e62438630ca3
Author: David Howells <dhowells@redhat.com>
Date:   Tue Dec 5 17:01:28 2006 +0000

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
    
            drivers/ata/libata-scsi.c
            include/linux/libata.h
    
    Futher merge of Linus's head and compilation fixups.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

commit 800b399669ad495ad4361d134df87401ae36f44f
Author: Tejun Heo <htejun@gmail.com>
Date:   Sun Dec 3 21:34:13 2006 +0900

    [PATCH] libata: always use polling IDENTIFY
    
    libata switched to IRQ-driven IDENTIFY when IRQ-driven PIO was
    introduced.  This has caused a lot of problems including device
    misdetection and phantom device.
    
    ATA_FLAG_DETECT_POLLING was added recently to selectively use polling
    IDENTIFY on problemetic drivers but many controllers and devices are
    affected by this problem and trying to adding ATA_FLAG_DETECT_POLLING
    for each such case is diffcult and not very rewarding.
    
    This patch makes libata always use polling IDENTIFY.  This is
    consistent with libata's original behavior and drivers/ide's behavior.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 1ff3f59504c9..107b2b565229 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -42,8 +42,6 @@ struct ata_scsi_args {
 enum {
 	/* flags for ata_dev_read_id() */
 	ATA_READID_POSTRESET	= (1 << 0), /* reading ID after reset */
-	ATA_READID_DETECT	= (1 << 1), /* perform presence detection
-					     * using polling IDENTIFY */
 };
 
 extern struct workqueue_struct *ata_aux_wq;

commit 70e6ad0c6d1e6cb9ee3c036a85ca2561eb1fd766
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Nov 14 22:47:10 2006 +0900

    [PATCH] libata: prepare ata_sg_clean() for invocation from EH
    
    Make ata_sg_clean() global and don't allow NCQ for internal commands.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 60576b1237e4..1ff3f59504c9 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -73,6 +73,7 @@ extern int sata_down_spd_limit(struct ata_port *ap);
 extern int sata_set_spd_needed(struct ata_port *ap);
 extern int ata_down_xfermask_limit(struct ata_device *dev, int force_pio0);
 extern int ata_set_mode(struct ata_port *ap, struct ata_device **r_failed_dev);
+extern void ata_sg_clean(struct ata_queued_cmd *qc);
 extern void ata_qc_free(struct ata_queued_cmd *qc);
 extern void ata_qc_issue(struct ata_queued_cmd *qc);
 extern void __ata_qc_complete(struct ata_queued_cmd *qc);

commit bd056d7eeb55d696556ee4f5ee2acb67b2d16df4
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Nov 14 22:47:10 2006 +0900

    [PATCH] libata: separate out rw ATA taskfile building into ata_build_rw_tf()
    
    Separate out rw ATA taskfile building from ata_scsi_rw_xlat() into
    ata_build_rw_tf().  This will be used to improve media error handling.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index ca6f36c13115..60576b1237e4 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -51,7 +51,9 @@ extern int atapi_enabled;
 extern int atapi_dmadir;
 extern int libata_fua;
 extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev);
-extern int ata_rwcmd_protocol(struct ata_queued_cmd *qc);
+extern int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
+			   u64 block, u32 n_block, unsigned int tf_flags,
+			   unsigned int tag);
 extern u64 ata_tf_read_block(struct ata_taskfile *tf, struct ata_device *dev);
 extern void ata_dev_disable(struct ata_device *dev);
 extern void ata_port_flush_task(struct ata_port *ap);

commit 2432697ba0ce312d60be5009ffe1fa054a761bb9
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Nov 14 22:47:09 2006 +0900

    [PATCH] libata: implement ata_exec_internal_sg()
    
    Sg'ify ata_exec_internal() and call it ata_exec_internal_sg().
    Wrapper function around ata_exec_internal_sg() is implemented to
    provide ata_exec_internal() interface.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 2d532da8c398..ca6f36c13115 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -58,6 +58,10 @@ extern void ata_port_flush_task(struct ata_port *ap);
 extern unsigned ata_exec_internal(struct ata_device *dev,
 				  struct ata_taskfile *tf, const u8 *cdb,
 				  int dma_dir, void *buf, unsigned int buflen);
+extern unsigned ata_exec_internal_sg(struct ata_device *dev,
+				     struct ata_taskfile *tf, const u8 *cdb,
+				     int dma_dir, struct scatterlist *sg,
+				     unsigned int n_elem);
 extern unsigned int ata_do_simple_cmd(struct ata_device *dev, u8 cmd);
 extern int ata_dev_read_id(struct ata_device *dev, unsigned int *p_class,
 			   unsigned int flags, u16 *id);

commit 35b649fe2587b2e569c17c022ba3506ba441b6a2
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Nov 14 22:37:35 2006 +0900

    [PATCH] libata: implement ata_tf_read_block()
    
    Implement ata_tf_read_block().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index be2ac39f013b..2d532da8c398 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -52,6 +52,7 @@ extern int atapi_dmadir;
 extern int libata_fua;
 extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev);
 extern int ata_rwcmd_protocol(struct ata_queued_cmd *qc);
+extern u64 ata_tf_read_block(struct ata_taskfile *tf, struct ata_device *dev);
 extern void ata_dev_disable(struct ata_device *dev);
 extern void ata_port_flush_task(struct ata_port *ap);
 extern unsigned ata_exec_internal(struct ata_device *dev,

commit 55a8e2c83ce50548dfef74bb19dfe2b809cb3099
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Nov 10 18:08:10 2006 +0900

    [PATCH] libata: implement presence detection via polling IDENTIFY
    
    On some controllers (ICHs in piix mode), there is *NO* reliable way to
    determine device presence other than issuing IDENTIFY and see how the
    transaction proceeds by watching the TF status register.
    
    libata acted this way before irq-pio and phantom devices caused very
    little problem but now that IDENTIFY is performed using IRQ drive PIO,
    such phantom devices now result in multiple 30sec timeouts during
    boot.
    
    This patch implements ATA_FLAG_DETECT_POLLING.  If a LLD sets this
    flag, libata core issues the initial IDENTIFY in polling mode and if
    the initial data transfer fails w/ HSM violation, the port is
    considered to be empty thus replicating the old libata and IDE
    behavior.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index bb98390aa01a..be2ac39f013b 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -42,6 +42,8 @@ struct ata_scsi_args {
 enum {
 	/* flags for ata_dev_read_id() */
 	ATA_READID_POSTRESET	= (1 << 0), /* reading ID after reset */
+	ATA_READID_DETECT	= (1 << 1), /* perform presence detection
+					     * using polling IDENTIFY */
 };
 
 extern struct workqueue_struct *ata_aux_wq;

commit bff0464769f2a1bd348265de704471747378e247
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Nov 10 18:08:10 2006 +0900

    [PATCH] libata: convert @post_reset to @flags in ata_dev_read_id()
    
    Make ata_dev_read_id() take @flags instead of @post_reset.  Currently
    there is only one flag defined - ATA_READID_POSTRESET, which is
    equivalent to @post_reset.  This is preparation for polling presence
    detection.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index e4ffb2e38992..bb98390aa01a 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -39,6 +39,11 @@ struct ata_scsi_args {
 };
 
 /* libata-core.c */
+enum {
+	/* flags for ata_dev_read_id() */
+	ATA_READID_POSTRESET	= (1 << 0), /* reading ID after reset */
+};
+
 extern struct workqueue_struct *ata_aux_wq;
 extern int atapi_enabled;
 extern int atapi_dmadir;
@@ -52,8 +57,8 @@ extern unsigned ata_exec_internal(struct ata_device *dev,
 				  int dma_dir, void *buf, unsigned int buflen);
 extern unsigned int ata_do_simple_cmd(struct ata_device *dev, u8 cmd);
 extern int ata_dev_read_id(struct ata_device *dev, unsigned int *p_class,
-			   int post_reset, u16 *id);
-extern int ata_dev_revalidate(struct ata_device *dev, int post_reset);
+			   unsigned int flags, u16 *id);
+extern int ata_dev_revalidate(struct ata_device *dev, unsigned int flags);
 extern int ata_dev_configure(struct ata_device *dev);
 extern int sata_down_spd_limit(struct ata_port *ap);
 extern int sata_set_spd_needed(struct ata_port *ap);

commit efdaedc443e935eda82e9e78a6e65d1f993d242f
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Nov 1 18:38:52 2006 +0900

    [PATCH] libata: implement ATA_EHI_PRINTINFO
    
    Implement ehi flag ATA_EHI_PRINTINFO.  This flag is set when device
    configuration needs to print out device info.  This used to be handled
    by @print_info argument to ata_dev_configure() but LLDs also need to
    know about it in ->dev_config() callback.
    
    This patch replaces @print_info w/ ATA_EHI_PRINTINFO and make sata_sil
    print workaround messages only on the initial configuration.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index c83300055ec5..e4ffb2e38992 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -54,7 +54,7 @@ extern unsigned int ata_do_simple_cmd(struct ata_device *dev, u8 cmd);
 extern int ata_dev_read_id(struct ata_device *dev, unsigned int *p_class,
 			   int post_reset, u16 *id);
 extern int ata_dev_revalidate(struct ata_device *dev, int post_reset);
-extern int ata_dev_configure(struct ata_device *dev, int print_info);
+extern int ata_dev_configure(struct ata_device *dev);
 extern int sata_down_spd_limit(struct ata_port *ap);
 extern int sata_set_spd_needed(struct ata_port *ap);
 extern int ata_down_xfermask_limit(struct ata_device *dev, int force_pio0);

commit 90088bb41200b4da962282dfd45db82544adac3b
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Oct 9 11:10:26 2006 +0900

    [PATCH] libata: move ata_irq_on() into libata-sff.c
    
    ata_irq_on() isn't used outside of libata core layer.  The function is
    TF/SFF interface specific but currently used by core path with some
    hack too.  Move it from include/linux/libata.h to
    drivers/ata/libata-sff.c.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 0ed263be652a..c83300055ec5 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -120,4 +120,7 @@ extern void ata_scsi_error(struct Scsi_Host *host);
 extern void ata_port_wait_eh(struct ata_port *ap);
 extern void ata_qc_schedule_eh(struct ata_queued_cmd *qc);
 
+/* libata-sff.c */
+extern u8 ata_irq_on(struct ata_port *ap);
+
 #endif /* __LIBATA_H__ */

commit 65f27f38446e1976cc98fd3004b110fedcddd189
Author: David Howells <dhowells@redhat.com>
Date:   Wed Nov 22 14:55:48 2006 +0000

    WorkStruct: Pass the work_struct pointer instead of context data
    
    Pass the work_struct pointer to the work function rather than context data.
    The work function can use container_of() to work out the data.
    
    For the cases where the container of the work_struct may go away the moment the
    pending bit is cleared, it is made possible to defer the release of the
    structure by deferring the clearing of the pending bit.
    
    To make this work, an extra flag is introduced into the management side of the
    work_struct.  This governs auto-release of the structure upon execution.
    
    Ordinarily, the work queue executor would release the work_struct for further
    scheduling or deallocation by clearing the pending bit prior to jumping to the
    work function.  This means that, unless the driver makes some guarantee itself
    that the work_struct won't go away, the work function may not access anything
    else in the work_struct or its container lest they be deallocated..  This is a
    problem if the auxiliary data is taken away (as done by the last patch).
    
    However, if the pending bit is *not* cleared before jumping to the work
    function, then the work function *may* access the work_struct and its container
    with no problems.  But then the work function must itself release the
    work_struct by calling work_release().
    
    In most cases, automatic release is fine, so this is the default.  Special
    initiators exist for the non-auto-release case (ending in _NAR).
    
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index 0ed263be652a..7e0f3aff873d 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -81,7 +81,7 @@ extern struct scsi_transport_template ata_scsi_transport_template;
 
 extern void ata_scsi_scan_host(struct ata_port *ap);
 extern int ata_scsi_offline_dev(struct ata_device *dev);
-extern void ata_scsi_hotplug(void *data);
+extern void ata_scsi_hotplug(struct work_struct *work);
 extern unsigned int ata_scsiop_inq_std(struct ata_scsi_args *args, u8 *rbuf,
 			       unsigned int buflen);
 
@@ -111,7 +111,7 @@ extern void ata_scsi_rbuf_fill(struct ata_scsi_args *args,
                         unsigned int (*actor) (struct ata_scsi_args *args,
                                            u8 *rbuf, unsigned int buflen));
 extern void ata_schedule_scsi_eh(struct Scsi_Host *shost);
-extern void ata_scsi_dev_rescan(void *data);
+extern void ata_scsi_dev_rescan(struct work_struct *work);
 extern int ata_bus_probe(struct ata_port *ap);
 
 /* libata-eh.c */

commit 6e42acc4115bc376b8523acbcba2b2b7cc27d016
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Oct 27 19:08:42 2006 -0700

    [PATCH] libata: unexport ata_dev_revalidate()
    
    ata_dev_revalidate() isn't used outside of libata core.  Unexport it.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index a5ecb71390a9..0ed263be652a 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -53,6 +53,7 @@ extern unsigned ata_exec_internal(struct ata_device *dev,
 extern unsigned int ata_do_simple_cmd(struct ata_device *dev, u8 cmd);
 extern int ata_dev_read_id(struct ata_device *dev, unsigned int *p_class,
 			   int post_reset, u16 *id);
+extern int ata_dev_revalidate(struct ata_device *dev, int post_reset);
 extern int ata_dev_configure(struct ata_device *dev, int print_info);
 extern int sata_down_spd_limit(struct ata_port *ap);
 extern int sata_set_spd_needed(struct ata_port *ap);

commit cca3974e48607c3775dc73b544a5700b2e37c21a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Aug 24 03:19:22 2006 -0400

    libata: Grand renaming.
    
    The biggest change is that ata_host_set is renamed to ata_host.
    
    * ata_host_set                  => ata_host
    * ata_probe_ent->host_flags     => ata_probe_ent->port_flags
    * ata_probe_ent->host_set_flags => ata_probe_ent->_host_flags
    * ata_host_stats                => ata_port_stats
    * ata_port->host                => ata_port->scsi_host
    * ata_port->host_set            => ata_port->host
    * ata_port_info->host_flags     => ata_port_info->flags
    * ata_(.*)host_set(.*)\(\)      => ata_\1host\2()
    
    The leading underscore in ata_probe_ent->_host_flags is to avoid
    reusing ->host_flags for different purpose.  Currently, the only user
    of the field is libata-bmdma.c and probe_ent itself is scheduled to be
    removed.
    
    ata_port->host is reused for different purpose but this field is used
    inside libata core proper and of different type.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
index d4a4f82360ec..a5ecb71390a9 100644
--- a/drivers/ata/libata.h
+++ b/drivers/ata/libata.h
@@ -69,7 +69,7 @@ extern int ata_flush_cache(struct ata_device *dev);
 extern void ata_dev_init(struct ata_device *dev);
 extern int ata_task_ioctl(struct scsi_device *scsidev, void __user *arg);
 extern int ata_cmd_ioctl(struct scsi_device *scsidev, void __user *arg);
-extern void ata_port_init(struct ata_port *ap, struct ata_host_set *host_set,
+extern void ata_port_init(struct ata_port *ap, struct ata_host *host,
 			  const struct ata_probe_ent *ent, unsigned int port_no);
 extern struct ata_probe_ent *ata_probe_ent_alloc(struct device *dev,
 						 const struct ata_port_info *port);

commit c6fd280766a050b13360d7c2d59a3d6bd3a27d9a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Aug 10 07:31:37 2006 -0400

    Move libata to drivers/ata.

diff --git a/drivers/ata/libata.h b/drivers/ata/libata.h
new file mode 100644
index 000000000000..d4a4f82360ec
--- /dev/null
+++ b/drivers/ata/libata.h
@@ -0,0 +1,122 @@
+/*
+ *  libata.h - helper library for ATA
+ *
+ *  Copyright 2003-2004 Red Hat, Inc.  All rights reserved.
+ *  Copyright 2003-2004 Jeff Garzik
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ *  libata documentation is available via 'make {ps|pdf}docs',
+ *  as Documentation/DocBook/libata.*
+ *
+ */
+
+#ifndef __LIBATA_H__
+#define __LIBATA_H__
+
+#define DRV_NAME	"libata"
+#define DRV_VERSION	"2.00"	/* must be exactly four chars */
+
+struct ata_scsi_args {
+	struct ata_device	*dev;
+	u16			*id;
+	struct scsi_cmnd	*cmd;
+	void			(*done)(struct scsi_cmnd *);
+};
+
+/* libata-core.c */
+extern struct workqueue_struct *ata_aux_wq;
+extern int atapi_enabled;
+extern int atapi_dmadir;
+extern int libata_fua;
+extern struct ata_queued_cmd *ata_qc_new_init(struct ata_device *dev);
+extern int ata_rwcmd_protocol(struct ata_queued_cmd *qc);
+extern void ata_dev_disable(struct ata_device *dev);
+extern void ata_port_flush_task(struct ata_port *ap);
+extern unsigned ata_exec_internal(struct ata_device *dev,
+				  struct ata_taskfile *tf, const u8 *cdb,
+				  int dma_dir, void *buf, unsigned int buflen);
+extern unsigned int ata_do_simple_cmd(struct ata_device *dev, u8 cmd);
+extern int ata_dev_read_id(struct ata_device *dev, unsigned int *p_class,
+			   int post_reset, u16 *id);
+extern int ata_dev_configure(struct ata_device *dev, int print_info);
+extern int sata_down_spd_limit(struct ata_port *ap);
+extern int sata_set_spd_needed(struct ata_port *ap);
+extern int ata_down_xfermask_limit(struct ata_device *dev, int force_pio0);
+extern int ata_set_mode(struct ata_port *ap, struct ata_device **r_failed_dev);
+extern void ata_qc_free(struct ata_queued_cmd *qc);
+extern void ata_qc_issue(struct ata_queued_cmd *qc);
+extern void __ata_qc_complete(struct ata_queued_cmd *qc);
+extern int ata_check_atapi_dma(struct ata_queued_cmd *qc);
+extern void ata_dev_select(struct ata_port *ap, unsigned int device,
+                           unsigned int wait, unsigned int can_sleep);
+extern void swap_buf_le16(u16 *buf, unsigned int buf_words);
+extern int ata_flush_cache(struct ata_device *dev);
+extern void ata_dev_init(struct ata_device *dev);
+extern int ata_task_ioctl(struct scsi_device *scsidev, void __user *arg);
+extern int ata_cmd_ioctl(struct scsi_device *scsidev, void __user *arg);
+extern void ata_port_init(struct ata_port *ap, struct ata_host_set *host_set,
+			  const struct ata_probe_ent *ent, unsigned int port_no);
+extern struct ata_probe_ent *ata_probe_ent_alloc(struct device *dev,
+						 const struct ata_port_info *port);
+
+
+/* libata-scsi.c */
+extern struct scsi_transport_template ata_scsi_transport_template;
+
+extern void ata_scsi_scan_host(struct ata_port *ap);
+extern int ata_scsi_offline_dev(struct ata_device *dev);
+extern void ata_scsi_hotplug(void *data);
+extern unsigned int ata_scsiop_inq_std(struct ata_scsi_args *args, u8 *rbuf,
+			       unsigned int buflen);
+
+extern unsigned int ata_scsiop_inq_00(struct ata_scsi_args *args, u8 *rbuf,
+			      unsigned int buflen);
+
+extern unsigned int ata_scsiop_inq_80(struct ata_scsi_args *args, u8 *rbuf,
+			      unsigned int buflen);
+extern unsigned int ata_scsiop_inq_83(struct ata_scsi_args *args, u8 *rbuf,
+			      unsigned int buflen);
+extern unsigned int ata_scsiop_noop(struct ata_scsi_args *args, u8 *rbuf,
+			    unsigned int buflen);
+extern unsigned int ata_scsiop_sync_cache(struct ata_scsi_args *args, u8 *rbuf,
+				  unsigned int buflen);
+extern unsigned int ata_scsiop_mode_sense(struct ata_scsi_args *args, u8 *rbuf,
+				  unsigned int buflen);
+extern unsigned int ata_scsiop_read_cap(struct ata_scsi_args *args, u8 *rbuf,
+			        unsigned int buflen);
+extern unsigned int ata_scsiop_report_luns(struct ata_scsi_args *args, u8 *rbuf,
+				   unsigned int buflen);
+extern void ata_scsi_badcmd(struct scsi_cmnd *cmd,
+			    void (*done)(struct scsi_cmnd *),
+			    u8 asc, u8 ascq);
+extern void ata_scsi_set_sense(struct scsi_cmnd *cmd,
+			       u8 sk, u8 asc, u8 ascq);
+extern void ata_scsi_rbuf_fill(struct ata_scsi_args *args,
+                        unsigned int (*actor) (struct ata_scsi_args *args,
+                                           u8 *rbuf, unsigned int buflen));
+extern void ata_schedule_scsi_eh(struct Scsi_Host *shost);
+extern void ata_scsi_dev_rescan(void *data);
+extern int ata_bus_probe(struct ata_port *ap);
+
+/* libata-eh.c */
+extern enum scsi_eh_timer_return ata_scsi_timed_out(struct scsi_cmnd *cmd);
+extern void ata_scsi_error(struct Scsi_Host *host);
+extern void ata_port_wait_eh(struct ata_port *ap);
+extern void ata_qc_schedule_eh(struct ata_queued_cmd *qc);
+
+#endif /* __LIBATA_H__ */
