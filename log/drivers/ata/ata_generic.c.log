commit 58eb8cd565af4a104395e3c10443951c1f73dafe
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Wed May 7 17:17:44 2014 +0200

    ata: use CONFIG_PM_SLEEP instead of CONFIG_PM where applicable in host drivers
    
    This patch fixes host drivers to use CONFIG_PM_SLEEP instead of CONFIG_PM
    where applicable.  Benefits of this change:
    
    * unused code is not being compiled in for CONFIG_PM=y, CONFIG_PM_SLEEP=n
      and CONFIG_PM_RUNTIME=y configurations
    
    * easier transition to use struct dev_pm_ops and SIMPLE_DEV_PM_OPS() in
      the future
    
    * more consistent code (there are host drivers which are using the correct
      CONFIG_PM_SLEEP checks already)
    
    The patch leaves the core libata code and ->port_[suspend,resume] support
    in sata_[inic162x,nv,sil24].c alone for now.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 9498a7d3846f..9ff545ce8da3 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -241,7 +241,7 @@ static struct pci_driver ata_generic_pci_driver = {
 	.id_table	= ata_generic,
 	.probe 		= ata_generic_init_one,
 	.remove		= ata_pci_remove_one,
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 	.suspend	= ata_pci_device_suspend,
 	.resume		= ata_pci_device_resume,
 #endif

commit 1bc18086231c130895b87ec049be8ddcdab552b8
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Jan 21 16:22:51 2014 -0500

    ata: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Cc: linux-ide@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 7d196656adb5..9498a7d3846f 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -19,7 +19,6 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/pci.h>
-#include <linux/init.h>
 #include <linux/blkdev.h>
 #include <linux/delay.h>
 #include <scsi/scsi_host.h>

commit cb85696d7277592ddbd2897db9a29f3ec6e9fe11
Author: James Laird <jhl@mafipulation.org>
Date:   Tue Nov 19 11:06:38 2013 +1100

    ahci: mcp89: enter AHCI mode under Apple BIOS emulation
    
    Apple's BIOS emulation forcibly disables MCP89 AHCI, eg. on Macbook7,1.
    We can re-enable it, replacing the previous workaround of using
    ata_generic.
    
    tj: whitespace adjustments, dropped inline from is_mcp89_apple()
    
    Signed-off-by: James Laird <jhl@mafipulation.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index f8f38a08abc5..7d196656adb5 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -221,13 +221,6 @@ static struct pci_device_id ata_generic[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_OPTI,   PCI_DEVICE_ID_OPTI_82C558), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_CENATEK,PCI_DEVICE_ID_CENATEK_IDE),
 	  .driver_data = ATA_GEN_FORCE_DMA },
-	/*
-	 * For some reason, MCP89 on MacBook 7,1 doesn't work with
-	 * ahci, use ata_generic instead.
-	 */
-	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP89_SATA,
-	  PCI_VENDOR_ID_APPLE, 0xcb89,
-	  .driver_data = ATA_GEN_FORCE_DMA },
 #if !defined(CONFIG_PATA_TOSHIBA) && !defined(CONFIG_PATA_TOSHIBA_MODULE)
 	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_1), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_2),  },

commit 2fc75da0c59634b81223af497c4a037822f6e457
Author: Axel Lin <axel.lin@gmail.com>
Date:   Thu Apr 19 13:43:05 2012 +0800

    ata: use module_pci_driver
    
    This patch converts the drivers in drivers/ata/* to use module_pci_driver()
    macro which makes the code smaller and a bit simpler.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Cc: Mikael Pettersson <mikpe@it.uu.se>
    Cc: Mark Lord <kernel@teksavvy.com>
    Cc: Jeremy Higdon <jeremy@sgi.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index aae115600b74..f8f38a08abc5 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -255,17 +255,7 @@ static struct pci_driver ata_generic_pci_driver = {
 #endif
 };
 
-static int __init ata_generic_init(void)
-{
-	return pci_register_driver(&ata_generic_pci_driver);
-}
-
-
-static void __exit ata_generic_exit(void)
-{
-	pci_unregister_driver(&ata_generic_pci_driver);
-}
-
+module_pci_driver(ata_generic_pci_driver);
 
 MODULE_AUTHOR("Alan Cox");
 MODULE_DESCRIPTION("low-level driver for generic ATA");
@@ -273,7 +263,4 @@ MODULE_LICENSE("GPL");
 MODULE_DEVICE_TABLE(pci, ata_generic);
 MODULE_VERSION(DRV_VERSION);
 
-module_init(ata_generic_init);
-module_exit(ata_generic_exit);
-
 module_param(all_generic_ide, int, 0);

commit 47ee9108c1dcca434f479e9e520789d2a2ab7917
Author: Andi Kleen <ak@linux.intel.com>
Date:   Fri May 11 09:33:23 2012 -0700

    ata_generic: Skip is_intel_ider() check when ata_generic=1 is set
    
    When ata_generic_ide=1 is set don't do the is_intel_ider() magic
    check. We found at least one box who needed that.
    
    Cc: alan@linux.intel.com
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 7df56ec31819..aae115600b74 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -177,7 +177,7 @@ static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id
 	if ((id->driver_data & ATA_GEN_CLASS_MATCH) && all_generic_ide == 0)
 		return -ENODEV;
 
-	if (id->driver_data & ATA_GEN_INTEL_IDER)
+	if ((id->driver_data & ATA_GEN_INTEL_IDER) && !all_generic_ide)
 		if (!is_intel_ider(dev))
 			return -ENODEV;
 

commit a9a79dfec239568bdbf778242f8fcd10bcc5b9e2
Author: Joe Perches <joe@perches.com>
Date:   Fri Apr 15 15:51:59 2011 -0700

    ata: Convert ata_<foo>_printk(KERN_<LEVEL> to ata_<foo>_<level>
    
    Saves text by removing nearly duplicated text format strings by
    creating ata_<foo>_printk functions and printf extension %pV.
    
    ata defconfig size shrinks ~5% (~8KB), allyesconfig ~2.5% (~13KB)
    
    Format string duplication comes from:
    
     #define ata_link_printk(link, lv, fmt, args...) do { \
           if (sata_pmp_attached((link)->ap) || (link)->ap->slave_link)    \
                   printk("%sata%u.%02u: "fmt, lv, (link)->ap->print_id,   \
                          (link)->pmp , ##args); \
           else \
                   printk("%sata%u: "fmt, lv, (link)->ap->print_id , ##args); \
           } while(0)
    
    Coalesce long formats.
    
    $ size drivers/ata/built-in.*
       text    data     bss     dec     hex filename
     544969   73893  116584  735446   b38d6 drivers/ata/built-in.allyesconfig.ata.o
     558429   73893  117864  750186   b726a drivers/ata/built-in.allyesconfig.dev_level.o
     141328   14689    4220  160237   271ed drivers/ata/built-in.defconfig.ata.o
     149567   14689    4220  168476   2921c drivers/ata/built-in.defconfig.dev_level.o
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 721d38bfa339..7df56ec31819 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -81,14 +81,13 @@ static int generic_set_mode(struct ata_link *link, struct ata_device **unused)
 				xfer_mask |= ata_xfer_mode2mask(XFER_MW_DMA_0);
 			}
 
-			ata_dev_printk(dev, KERN_INFO, "configured for %s\n",
-				       name);
+			ata_dev_info(dev, "configured for %s\n", name);
 
 			dev->xfer_mode = ata_xfer_mask2mode(xfer_mask);
 			dev->xfer_shift = ata_xfer_mode2shift(dev->xfer_mode);
 			dev->flags &= ~ATA_DFLAG_PIO;
 		} else {
-			ata_dev_printk(dev, KERN_INFO, "configured for PIO\n");
+			ata_dev_info(dev, "configured for PIO\n");
 			dev->xfer_mode = XFER_PIO_0;
 			dev->xfer_shift = ATA_SHIFT_PIO;
 			dev->flags |= ATA_DFLAG_PIO;

commit 4fca377f7488095ab04035e2bfe5c59873c22382
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Feb 15 01:13:24 2011 -0500

    [libata] trivial: trim trailing whitespace for drivers/ata/*.[ch]

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 6981f7680a00..721d38bfa339 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -237,7 +237,7 @@ static struct pci_device_id ata_generic[] = {
 #endif
 	/* Intel, IDE class device */
 	{ PCI_VENDOR_ID_INTEL, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
-	  PCI_CLASS_STORAGE_IDE << 8, 0xFFFFFF00UL, 
+	  PCI_CLASS_STORAGE_IDE << 8, 0xFFFFFF00UL,
 	  .driver_data = ATA_GEN_INTEL_IDER },
 	/* Must come last. If you add entries adjust this table appropriately */
 	{ PCI_DEVICE_CLASS(PCI_CLASS_STORAGE_IDE << 8, 0xFFFFFF00UL),

commit 60039a5295b3d82a48fe132c699987d2e1408675
Author: Alan Cox <alan@linux.intel.com>
Date:   Tue Sep 28 13:19:38 2010 +0100

    ata: Intel IDE-R support
    
    Intel IDE-R devices are part of the Intel AMT management setup. They don't
    have any special configuration registers or settings so the ata_generic
    driver will support them fully.
    
    Rather than add a huge table of IDs for each chipset and keep sending in
    new ones this patch autodetects them.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index cc5f7726bde7..6981f7680a00 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -35,6 +35,7 @@
 enum {
 	ATA_GEN_CLASS_MATCH		= (1 << 0),
 	ATA_GEN_FORCE_DMA		= (1 << 1),
+	ATA_GEN_INTEL_IDER		= (1 << 2),
 };
 
 /**
@@ -108,6 +109,49 @@ static struct ata_port_operations generic_port_ops = {
 
 static int all_generic_ide;		/* Set to claim all devices */
 
+/**
+ *	is_intel_ider		-	identify intel IDE-R devices
+ *	@dev: PCI device
+ *
+ *	Distinguish Intel IDE-R controller devices from other Intel IDE
+ *	devices. IDE-R devices have no timing registers and are in
+ *	most respects virtual. They should be driven by the ata_generic
+ *	driver.
+ *
+ *	IDE-R devices have PCI offset 0xF8.L as zero, later Intel ATA has
+ *	it non zero. All Intel ATA has 0x40 writable (timing), but it is
+ *	not writable on IDE-R devices (this is guaranteed).
+ */
+
+static int is_intel_ider(struct pci_dev *dev)
+{
+	/* For Intel IDE the value at 0xF8 is only zero on IDE-R
+	   interfaces */
+	u32 r;
+	u16 t;
+
+	/* Check the manufacturing ID, it will be zero for IDE-R */
+	pci_read_config_dword(dev, 0xF8, &r);
+	/* Not IDE-R: punt so that ata_(old)piix gets it */
+	if (r != 0)
+		return 0;
+	/* 0xF8 will also be zero on some early Intel IDE devices
+	   but they will have a sane timing register */
+	pci_read_config_word(dev, 0x40, &t);
+	if (t != 0)
+		return 0;
+	/* Finally check if the timing register is writable so that
+	   we eliminate any early devices hot-docked in a docking
+	   station */
+	pci_write_config_word(dev, 0x40, 1);
+	pci_read_config_word(dev, 0x40, &t);
+	if (t) {
+		pci_write_config_word(dev, 0x40, 0);
+		return 0;
+	}
+	return 1;
+}
+
 /**
  *	ata_generic_init		-	attach generic IDE
  *	@dev: PCI device found
@@ -134,6 +178,10 @@ static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id
 	if ((id->driver_data & ATA_GEN_CLASS_MATCH) && all_generic_ide == 0)
 		return -ENODEV;
 
+	if (id->driver_data & ATA_GEN_INTEL_IDER)
+		if (!is_intel_ider(dev))
+			return -ENODEV;
+
 	/* Devices that need care */
 	if (dev->vendor == PCI_VENDOR_ID_UMC &&
 	    dev->device == PCI_DEVICE_ID_UMC_UM8886A &&
@@ -186,7 +234,11 @@ static struct pci_device_id ata_generic[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_2),  },
 	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_3),  },
 	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_5),  },
-#endif	
+#endif
+	/* Intel, IDE class device */
+	{ PCI_VENDOR_ID_INTEL, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
+	  PCI_CLASS_STORAGE_IDE << 8, 0xFFFFFF00UL, 
+	  .driver_data = ATA_GEN_INTEL_IDER },
 	/* Must come last. If you add entries adjust this table appropriately */
 	{ PCI_DEVICE_CLASS(PCI_CLASS_STORAGE_IDE << 8, 0xFFFFFF00UL),
 	  .driver_data = ATA_GEN_CLASS_MATCH },

commit 728e0eaf99631d197e5158e21b4a8c4335a39231
Author: Tejun Heo <tj@kernel.org>
Date:   Fri Jul 2 14:41:24 2010 +0200

    ata_generic: drop hard coded DMA force logic for CENATEK
    
    Commit 1529c69adc (ata_generic: implement ATA_GEN_* flags and force
    enable DMA on MBP 7,1) implemented ATA_GEN_FORCE_DMA for forcing DMA
    mode and applied it to CENATEK but forgot to remove the original hard
    coded logic.  This is removal of redundant logic and doesn't affect
    correctness.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Andy Whitcroft <apw@canonical.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 7107a6929deb..cc5f7726bde7 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -54,7 +54,6 @@ static int generic_set_mode(struct ata_link *link, struct ata_device **unused)
 	const struct pci_device_id *id = ap->host->private_data;
 	int dma_enabled = 0;
 	struct ata_device *dev;
-	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
 
 	if (id->driver_data & ATA_GEN_FORCE_DMA) {
 		dma_enabled = 0xff;
@@ -63,9 +62,6 @@ static int generic_set_mode(struct ata_link *link, struct ata_device **unused)
 		dma_enabled = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
 	}
 
-	if (pdev->vendor == PCI_VENDOR_ID_CENATEK)
-		dma_enabled = 0xFF;
-
 	ata_for_each_dev(dev, link, ENABLED) {
 		/* We don't really care */
 		dev->pio_mode = XFER_PIO_0;

commit 1529c69adce1e95f7ae72f0441590c226bbac7fc
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Jun 22 12:27:26 2010 +0200

    ata_generic: implement ATA_GEN_* flags and force enable DMA on MBP 7,1
    
    IDE mode of MCP89 on MBP 7,1 doesn't set DMA enable bits in the BMDMA
    status register.  Make the following changes to work around the problem.
    
    * Instead of using hard coded 1 in id->driver_data as class code
      match, use ATA_GEN_CLASS_MATCH and carry the matched id in
      host->private_data.
    
    * Instead of matching PCI_VENDOR_ID_CENATEK, use ATA_GEN_FORCE_DMA
      flag in id instead.
    
    * Add ATA_GEN_FORCE_DMA to the id entry of MBP 7,1.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Peer Chen <pchen@nvidia.com>
    Cc: stable@kernel.org
    Reported-by: Anders Østhus <grapz666@gmail.com>
    Reported-by: Andreas Graf <andreas_graf@csgraf.de>
    Reported-by: Benoit Gschwind <gschwind@gnu-log.net>
    Reported-by: Damien Cassou <damien.cassou@gmail.com>
    Reported-by: tixetsal@juno.com
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index d4ccf74c4c94..7107a6929deb 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -32,6 +32,11 @@
  *	A generic parallel ATA driver using libata
  */
 
+enum {
+	ATA_GEN_CLASS_MATCH		= (1 << 0),
+	ATA_GEN_FORCE_DMA		= (1 << 1),
+};
+
 /**
  *	generic_set_mode	-	mode setting
  *	@link: link to set up
@@ -46,13 +51,17 @@
 static int generic_set_mode(struct ata_link *link, struct ata_device **unused)
 {
 	struct ata_port *ap = link->ap;
+	const struct pci_device_id *id = ap->host->private_data;
 	int dma_enabled = 0;
 	struct ata_device *dev;
 	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
 
-	/* Bits 5 and 6 indicate if DMA is active on master/slave */
-	if (ap->ioaddr.bmdma_addr)
+	if (id->driver_data & ATA_GEN_FORCE_DMA) {
+		dma_enabled = 0xff;
+	} else if (ap->ioaddr.bmdma_addr) {
+		/* Bits 5 and 6 indicate if DMA is active on master/slave */
 		dma_enabled = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
+	}
 
 	if (pdev->vendor == PCI_VENDOR_ID_CENATEK)
 		dma_enabled = 0xFF;
@@ -126,7 +135,7 @@ static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id
 	const struct ata_port_info *ppi[] = { &info, NULL };
 
 	/* Don't use the generic entry unless instructed to do so */
-	if (id->driver_data == 1 && all_generic_ide == 0)
+	if ((id->driver_data & ATA_GEN_CLASS_MATCH) && all_generic_ide == 0)
 		return -ENODEV;
 
 	/* Devices that need care */
@@ -155,7 +164,7 @@ static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id
 			return rc;
 		pcim_pin_device(dev);
 	}
-	return ata_pci_bmdma_init_one(dev, ppi, &generic_sht, NULL, 0);
+	return ata_pci_bmdma_init_one(dev, ppi, &generic_sht, (void *)id, 0);
 }
 
 static struct pci_device_id ata_generic[] = {
@@ -167,13 +176,15 @@ static struct pci_device_id ata_generic[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_HINT,   PCI_DEVICE_ID_HINT_VXPROII_IDE), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_VIA,    PCI_DEVICE_ID_VIA_82C561), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_OPTI,   PCI_DEVICE_ID_OPTI_82C558), },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CENATEK,PCI_DEVICE_ID_CENATEK_IDE), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CENATEK,PCI_DEVICE_ID_CENATEK_IDE),
+	  .driver_data = ATA_GEN_FORCE_DMA },
 	/*
 	 * For some reason, MCP89 on MacBook 7,1 doesn't work with
 	 * ahci, use ata_generic instead.
 	 */
 	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP89_SATA,
-	  PCI_VENDOR_ID_APPLE, 0xcb89, },
+	  PCI_VENDOR_ID_APPLE, 0xcb89,
+	  .driver_data = ATA_GEN_FORCE_DMA },
 #if !defined(CONFIG_PATA_TOSHIBA) && !defined(CONFIG_PATA_TOSHIBA_MODULE)
 	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_1), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_2),  },
@@ -181,7 +192,8 @@ static struct pci_device_id ata_generic[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_5),  },
 #endif	
 	/* Must come last. If you add entries adjust this table appropriately */
-	{ PCI_ANY_ID,		PCI_ANY_ID,			   PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_STORAGE_IDE << 8, 0xFFFFFF00UL, 1},
+	{ PCI_DEVICE_CLASS(PCI_CLASS_STORAGE_IDE << 8, 0xFFFFFF00UL),
+	  .driver_data = ATA_GEN_CLASS_MATCH },
 	{ 0, },
 };
 

commit c6353b4520788e34098bbf61c73fb9618ca7fdd6
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Jun 17 11:42:22 2010 +0200

    ahci,ata_generic: let ata_generic handle new MBP w/ MCP89
    
    For yet unknown reason, MCP89 on MBP 7,1 doesn't work w/ ahci under
    linux but the controller doesn't require explicit mode setting and
    works fine with ata_generic.  Make ahci ignore the controller on MBP
    7,1 and let ata_generic take it for now.
    
    Reported in bko#15923.
    
      https://bugzilla.kernel.org/show_bug.cgi?id=15923
    
    NVIDIA is investigating why ahci mode doesn't work.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Peer Chen <pchen@nvidia.com>
    Cc: stable@kernel.org
    Reported-by: Anders Østhus <grapz666@gmail.com>
    Reported-by: Andreas Graf <andreas_graf@csgraf.de>
    Reported-by: Benoit Gschwind <gschwind@gnu-log.net>
    Reported-by: Damien Cassou <damien.cassou@gmail.com>
    Reported-by: tixetsal@juno.com
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 573158a9668d..d4ccf74c4c94 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -168,6 +168,12 @@ static struct pci_device_id ata_generic[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_VIA,    PCI_DEVICE_ID_VIA_82C561), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_OPTI,   PCI_DEVICE_ID_OPTI_82C558), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_CENATEK,PCI_DEVICE_ID_CENATEK_IDE), },
+	/*
+	 * For some reason, MCP89 on MacBook 7,1 doesn't work with
+	 * ahci, use ata_generic instead.
+	 */
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE_MCP89_SATA,
+	  PCI_VENDOR_ID_APPLE, 0xcb89, },
 #if !defined(CONFIG_PATA_TOSHIBA) && !defined(CONFIG_PATA_TOSHIBA_MODULE)
 	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_1), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_2),  },

commit 1c5afdf7a629d2e77de8dd043b97a33dcd7e6dfa
Author: Tejun Heo <tj@kernel.org>
Date:   Wed May 19 22:10:22 2010 +0200

    libata-sff: separate out BMDMA init
    
    Separate out ata_pci_bmdma_prepare_host() and ata_pci_bmdma_init_one()
    from their SFF counterparts.  SFF ones no longer try to initialize
    BMDMA or set PCI master.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 33fb614f9784..573158a9668d 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -155,7 +155,7 @@ static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id
 			return rc;
 		pcim_pin_device(dev);
 	}
-	return ata_pci_sff_init_one(dev, ppi, &generic_sht, NULL, 0);
+	return ata_pci_bmdma_init_one(dev, ppi, &generic_sht, NULL, 0);
 }
 
 static struct pci_device_id ata_generic[] = {

commit 16ea0fc98d53c72cb4e1a9edcb685a87e3a81430
Author: Alan Cox <alan@linux.intel.com>
Date:   Tue Feb 23 02:26:06 2010 -0500

    libata: Pass host flags into the pci helper
    
    This allows parallel scan and the like to be set without having to stop
    using the existing full helper functions. This patch merely adds the argument
    and fixes up the callers. It doesn't undo the special cases already in the
    tree or add any new parallel callers.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 12e26c3c68e3..33fb614f9784 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -155,7 +155,7 @@ static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id
 			return rc;
 		pcim_pin_device(dev);
 	}
-	return ata_pci_sff_init_one(dev, ppi, &generic_sht, NULL);
+	return ata_pci_sff_init_one(dev, ppi, &generic_sht, NULL, 0);
 }
 
 static struct pci_device_id ata_generic[] = {

commit 8e182a90f91456335756d2ce304ad470795d98e1
Author: Alan Cox <alan@linux.intel.com>
Date:   Mon Nov 30 13:23:11 2009 +0000

    pata_piccolo: Driver for old Toshiba chipsets
    
    We were never able to get docs for this out of Toshiba for years. Dave
    Barnes produced a NetBSD driver however and from that we can fill in the
    needed tables.
    
    As we correct the PCI identifiers a bit also update the old ide generic driver
    at the same time so it stays compiling.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index ecfd22b4f1ce..12e26c3c68e3 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -168,9 +168,12 @@ static struct pci_device_id ata_generic[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_VIA,    PCI_DEVICE_ID_VIA_82C561), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_OPTI,   PCI_DEVICE_ID_OPTI_82C558), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_CENATEK,PCI_DEVICE_ID_CENATEK_IDE), },
-	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO), },
+#if !defined(CONFIG_PATA_TOSHIBA) && !defined(CONFIG_PATA_TOSHIBA_MODULE)
 	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_1), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_2),  },
+	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_3),  },
+	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_5),  },
+#endif	
 	/* Must come last. If you add entries adjust this table appropriately */
 	{ PCI_ANY_ID,		PCI_ANY_ID,			   PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_STORAGE_IDE << 8, 0xFFFFFF00UL, 1},
 	{ 0, },

commit 14bdef982caeda19afe34010482867c18217c641
Author: Erik Inge Bolsø <knan-lkml@anduin.net>
Date:   Sat Mar 14 21:38:24 2009 +0100

    [libata] convert drivers to use ata.h mode mask defines
    
    No functional changes in this patch.
    
    Signed-off-by: Erik Inge Bolsø <knan-lkml@anduin.net>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index dc48a6398abe..ecfd22b4f1ce 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -118,8 +118,8 @@ static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id
 	u16 command;
 	static const struct ata_port_info info = {
 		.flags = ATA_FLAG_SLAVE_POSS,
-		.pio_mask = 0x1f,
-		.mwdma_mask = 0x07,
+		.pio_mask = ATA_PIO4,
+		.mwdma_mask = ATA_MWDMA2,
 		.udma_mask = ATA_UDMA5,
 		.port_ops = &generic_port_ops
 	};

commit 1eca4365be25c540650693e941bc06a66cf38f94
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 3 20:03:17 2008 +0900

    libata: beef up iterators
    
    There currently are the following looping constructs.
    
    * __ata_port_for_each_link() for all available links
    * ata_port_for_each_link() for edge links
    * ata_link_for_each_dev() for all devices
    * ata_link_for_each_dev_reverse() for all devices in reverse order
    
    Now there's a need for looping construct which is similar to
    __ata_port_for_each_link() but iterates over PMP links before the host
    link.  Instead of adding another one with long name, do the following
    cleanup.
    
    * Implement and export ata_link_next() and ata_dev_next() which take
      @mode parameter and can be used to build custom loop.
    * Implement ata_for_each_link() and ata_for_each_dev() which take
      looping mode explicitly.
    
    The following iteration modes are implemented.
    
    * ATA_LITER_EDGE                : loop over edge links
    * ATA_LITER_HOST_FIRST          : loop over all links, host link first
    * ATA_LITER_PMP_FIRST           : loop over all links, PMP links first
    
    * ATA_DITER_ENABLED             : loop over enabled devices
    * ATA_DITER_ENABLED_REVERSE     : loop over enabled devices in reverse order
    * ATA_DITER_ALL                 : loop over all devices
    * ATA_DITER_ALL_REVERSE         : loop over all devices in reverse order
    
    This change removes exlicit device enabledness checks from many loops
    and makes it clear which ones are iterated over in which direction.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 5c33767e66de..dc48a6398abe 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -57,10 +57,7 @@ static int generic_set_mode(struct ata_link *link, struct ata_device **unused)
 	if (pdev->vendor == PCI_VENDOR_ID_CENATEK)
 		dma_enabled = 0xFF;
 
-	ata_link_for_each_dev(dev, link) {
-		if (!ata_dev_enabled(dev))
-			continue;
-
+	ata_for_each_dev(dev, link, ENABLED) {
 		/* We don't really care */
 		dev->pio_mode = XFER_PIO_0;
 		dev->dma_mode = XFER_MW_DMA_0;

commit ab77163008c596aad9624ceab190d840c0143fa8
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Oct 27 15:09:10 2008 +0000

    ata: Switch all my stuff to a common address
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 75a406f5e694..5c33767e66de 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -1,6 +1,6 @@
 /*
  *  ata_generic.c - Generic PATA/SATA controller driver.
- *  Copyright 2005 Red Hat Inc <alan@redhat.com>, all rights reserved.
+ *  Copyright 2005 Red Hat Inc, all rights reserved.
  *
  *  Elements from ide/pci/generic.c
  *	    Copyright (C) 2001-2002	Andre Hedrick <andre@linux-ide.org>

commit 05177f178efe1459d2d0ac05430027ba201889a4
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Fri May 2 15:13:39 2008 -0700

    pata_atiixp: Don't disable
    
    A couple of distributions (Fedora, Ubuntu) were having weird problems with the
    ATI IXP series PATA controllers being reported as simplex.  At the heart of
    the problem is that both distros ignored the recommendations to load pata_acpi
    and ata_generic *AFTER* specific host drivers.
    
    The underlying cause however is that if you D3 and then D0 an ATI IXP it
    helpfully throws away some configuration and won't let you rewrite it.
    
    Add checks to ata_generic and pata_acpi to pin ATIIXP devices.  Possibly the
    real answer here is to quirk them and pin them, but right now we can't do that
    before they've been pcim_enable()'d by a driver.
    
    I'm indebted to David Gero for this.  His bug report not only reported the
    problem but identified the cause correctly and he had tested the right values
    to prove what was going on
    
    [If you backport this for 2.6.24 you will need to pull in the 2.6.25
    removal of the bogus WARN_ON() in pcim_enagle]
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Tested-by: David Gero <davidg@havidave.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 47aeccd52fa9..75a406f5e694 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -152,6 +152,12 @@ static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id
 	if (dev->vendor == PCI_VENDOR_ID_AL)
 		ata_pci_bmdma_clear_simplex(dev);
 
+	if (dev->vendor == PCI_VENDOR_ID_ATI) {
+		int rc = pcim_enable_device(dev);
+		if (rc < 0)
+			return rc;
+		pcim_pin_device(dev);
+	}
 	return ata_pci_sff_init_one(dev, ppi, &generic_sht, NULL);
 }
 

commit 9363c3825ea9ad76561eb48a395349dd29211ed6
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:16 2008 +0900

    libata: rename SFF functions
    
    SFF functions have confusing names.  Some have sff prefix, some have
    bmdma, some std, some pci and some none.  Unify the naming by...
    
    * SFF functions which are common to both BMDMA and non-BMDMA are
      prefixed with ata_sff_.
    
    * SFF functions which are specific to BMDMA are prefixed with
      ata_bmdma_.
    
    * SFF functions which are specific to PCI but apply to both BMDMA and
      non-BMDMA are prefixed with ata_pci_sff_.
    
    * SFF functions which are specific to PCI and BMDMA are prefixed with
      ata_pci_bmdma_.
    
    * Drop generic prefixes from LLD specific routines.  For example,
      bfin_std_dev_select -> bfin_dev_select.
    
    The following renames are noteworthy.
    
      ata_qc_issue_prot() -> ata_sff_qc_issue()
      ata_pci_default_filter() -> ata_bmdma_mode_filter()
      ata_dev_try_classify() -> ata_sff_dev_classify()
    
    This rename is in preparation of separating SFF support out of libata
    core layer.  This patch strictly renames functions and doesn't
    introduce any behavior difference.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index b23e2a1099c5..47aeccd52fa9 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -150,9 +150,9 @@ static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id
 		return -ENODEV;
 
 	if (dev->vendor == PCI_VENDOR_ID_AL)
-	    	ata_pci_clear_simplex(dev);
+		ata_pci_bmdma_clear_simplex(dev);
 
-	return ata_pci_init_one(dev, ppi, &generic_sht, NULL);
+	return ata_pci_sff_init_one(dev, ppi, &generic_sht, NULL);
 }
 
 static struct pci_device_id ata_generic[] = {

commit 887125e3740283be25564bfc6fb5d24974b651ab
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:49 2008 +0900

    libata: stop overloading port_info->private_data
    
    port_info->private_data is currently used for two purposes - to record
    private data about the port_info or to specify host->private_data to
    use when allocating ata_host.
    
    This overloading is confusing and counter-intuitive in that
    port_info->private_data becomes host->private_data instead of
    port->private_data.  In addition, port_info and host don't correspond
    to each other 1-to-1.  Currently, the first non-NULL
    port_info->private_data is used.
    
    This patch makes port_info->private_data just be what it is -
    private_data for the port_info where LLD can jot down extra info.
    libata no longer sets host->private_data to the first non-NULL
    port_info->private_data, @host_priv argument is added to
    ata_pci_init_one() instead.  LLDs which use ata_pci_init_one() can use
    this argument to pass in pointer to host private data.  LLDs which
    don't should use init-register model anyway and can initialize
    host->private_data directly.
    
    Adding @host_priv instead of using init-register model for LLDs which
    use ata_pci_init_one() is suggested by Alan Cox.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index a912ee01a47c..b23e2a1099c5 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -152,7 +152,7 @@ static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id
 	if (dev->vendor == PCI_VENDOR_ID_AL)
 	    	ata_pci_clear_simplex(dev);
 
-	return ata_pci_init_one(dev, ppi, &generic_sht);
+	return ata_pci_init_one(dev, ppi, &generic_sht, NULL);
 }
 
 static struct pci_device_id ata_generic[] = {

commit 1bd5b715a305f6f13455e89becbd839010dd14b5
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:49 2008 +0900

    libata: make ata_pci_init_one() not use ops->irq_handler and pi->sht
    
    ata_pci_init_one() is the only function which uses ops->irq_handler
    and pi->sht.  Other initialization functions take the same information
    as arguments.  This causes confusion and duplicate unused entries in
    structures.
    
    Make ata_pci_init_one() take sht as an argument and use ata_interrupt
    implicitly.  All current users use ata_interrupt and if different irq
    handler is necessary open coding ata_pci_init_one() using
    ata_prepare_sff_host() and ata_activate_sff_host can be done under ten
    lines including error handling and driver which requires custom
    interrupt handler is likely to require custom initialization anyway.
    
    As ata_pci_init_one() was the last user of ops->irq_handler, this
    patch also kills the field.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 0b5b515ae159..a912ee01a47c 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -120,7 +120,6 @@ static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id
 {
 	u16 command;
 	static const struct ata_port_info info = {
-		.sht = &generic_sht,
 		.flags = ATA_FLAG_SLAVE_POSS,
 		.pio_mask = 0x1f,
 		.mwdma_mask = 0x07,
@@ -153,7 +152,7 @@ static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id
 	if (dev->vendor == PCI_VENDOR_ID_AL)
 	    	ata_pci_clear_simplex(dev);
 
-	return ata_pci_init_one(dev, ppi);
+	return ata_pci_init_one(dev, ppi, &generic_sht);
 }
 
 static struct pci_device_id ata_generic[] = {

commit 029cfd6b74fc5c517865fad78cf4a3ea8d9b664a
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:49 2008 +0900

    libata: implement and use ops inheritance
    
    libata lets low level drivers build ata_port_operations table and
    register it with libata core layer.  This allows low level drivers
    high level of flexibility but also burdens them with lots of
    boilerplate entries.
    
    This becomes worse for drivers which support related similar
    controllers which differ slightly.  They share most of the operations
    except for a few.  However, the driver still needs to list all
    operations for each variant.  This results in large number of
    duplicate entries, which is not only inefficient but also error-prone
    as it becomes very difficult to tell what the actual differences are.
    
    This duplicate boilerplates all over the low level drivers also make
    updating the core layer exteremely difficult and error-prone.  When
    compounded with multi-branched development model, it ends up
    accumulating inconsistencies over time.  Some of those inconsistencies
    cause immediate problems and fixed.  Others just remain there dormant
    making maintenance increasingly difficult.
    
    To rectify the problem, this patch implements ata_port_operations
    inheritance.  To allow LLDs to easily re-use their own ops tables
    overriding only specific methods, this patch implements poor man's
    class inheritance.  An ops table has ->inherits field which can be set
    to any ops table as long as it doesn't create a loop.  When the host
    is started, the inheritance chain is followed and any operation which
    isn't specified is taken from the nearest ancestor which has it
    specified.  This operation is called finalization and done only once
    per an ops table and the LLD doesn't have to do anything special about
    it other than making the ops table non-const such that libata can
    update it.
    
    libata provides four base ops tables lower drivers can inherit from -
    base, sata, pmp, sff and bmdma.  To avoid overriding these ops
    accidentaly, these ops are declared const and LLDs should always
    inherit these instead of using them directly.
    
    After finalization, all the ops table are identical before and after
    the patch except for setting .irq_handler to ata_interrupt in drivers
    which didn't use to.  The .irq_handler doesn't have any actual effect
    and the field will soon be removed by later patch.
    
    * sata_sx4 is still using old style EH and currently doesn't take
      advantage of ops inheritance.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 5c64ce134c6c..0b5b515ae159 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -99,36 +99,9 @@ static struct scsi_host_template generic_sht = {
 };
 
 static struct ata_port_operations generic_port_ops = {
-	.set_mode	= generic_set_mode,
-	.mode_filter	= ata_pci_default_filter,
-
-	.tf_load	= ata_tf_load,
-	.tf_read	= ata_tf_read,
-	.check_status 	= ata_check_status,
-	.exec_command	= ata_exec_command,
-	.dev_select 	= ata_std_dev_select,
-
-	.bmdma_setup 	= ata_bmdma_setup,
-	.bmdma_start 	= ata_bmdma_start,
-	.bmdma_stop	= ata_bmdma_stop,
-	.bmdma_status 	= ata_bmdma_status,
-
-	.data_xfer	= ata_data_xfer,
-
-	.freeze		= ata_bmdma_freeze,
-	.thaw		= ata_bmdma_thaw,
-	.error_handler	= ata_bmdma_error_handler,
-	.post_internal_cmd = ata_bmdma_post_internal_cmd,
+	.inherits	= &ata_bmdma_port_ops,
 	.cable_detect	= ata_cable_unknown,
-
-	.qc_prep 	= ata_qc_prep,
-	.qc_issue	= ata_qc_issue_prot,
-
-	.irq_handler	= ata_interrupt,
-	.irq_clear	= ata_bmdma_irq_clear,
-	.irq_on		= ata_irq_on,
-
-	.port_start	= ata_sff_port_start,
+	.set_mode	= generic_set_mode,
 };
 
 static int all_generic_ide;		/* Set to claim all devices */

commit 68d1d07b510bb57a504588adc2bd2758adea0965
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:49 2008 +0900

    libata: implement and use SHT initializers
    
    libata lets low level drivers build scsi_host_template and register it
    to the SCSI layer.  This allows low level drivers high level of
    flexibility but also burdens them with lots of boilerplate entries.
    
    This patch implements SHT initializers which can be used to initialize
    all the boilerplate entries in a sht.  Three variants of them are
    implemented - BASE, BMDMA and NCQ - for different types of drivers.
    Note that entries can be overriden by putting individual initializers
    after the helper macro.
    
    All sht tables are identical before and after this patch.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index db4c3cb78fda..5c64ce134c6c 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -95,21 +95,7 @@ static int generic_set_mode(struct ata_link *link, struct ata_device **unused)
 }
 
 static struct scsi_host_template generic_sht = {
-	.module			= THIS_MODULE,
-	.name			= DRV_NAME,
-	.ioctl			= ata_scsi_ioctl,
-	.queuecommand		= ata_scsi_queuecmd,
-	.can_queue		= ATA_DEF_QUEUE,
-	.this_id		= ATA_SHT_THIS_ID,
-	.sg_tablesize		= LIBATA_MAX_PRD,
-	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
-	.emulated		= ATA_SHT_EMULATED,
-	.use_clustering		= ATA_SHT_USE_CLUSTERING,
-	.proc_name		= DRV_NAME,
-	.dma_boundary		= ATA_DMA_BOUNDARY,
-	.slave_configure	= ata_scsi_slave_config,
-	.slave_destroy		= ata_scsi_slave_destroy,
-	.bios_param		= ata_std_bios_param,
+	ATA_BMDMA_SHT(DRV_NAME),
 };
 
 static struct ata_port_operations generic_port_ops = {

commit 6bd99b4e0998571808fc1f09d5162348f21ff8c1
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:48 2008 +0900

    libata: normalize port_info, port_operations and sht tables
    
    Over the time, port info, ops and sht structures developed quite a bit
    of inconsistencies.  This patch updates drivers.
    
    * Enable/disable_pm callbacks added to all ahci ops tables.
    
    * Every driver for SFF controllers now uses ata_sff_port_start()
      instead of ata_port_start() unless the driver has custom
      implementation.
    
    * Every driver for SFF controllers now uses ata_pci_default_filter()
      unless the driver has custom implementation.
    
    * Removed an odd port_info->sht initialization from ata_piix.c.
      Likely a merge byproduct.
    
    * A port which has ATA_FLAG_SATA set doesn't need to set cable_detect
      to ata_cable_sata().  Remove it from via and mv port ops.
    
    * Some drivers had unnecessary .max_sectors initialization which is
      ignored and was missing .slave_destroy callback.  Fixed.
    
    * Removed unnecessary sht initializations port_info's.
    
    * Removed onsolete scsi device suspend/resume callbacks from
      pata_bf54x.
    
    * No reason to set ata_pci_default_filter() and bmdma functions for
      PIO-only drivers.  Remove those callbacks and replace
      ata_bmdma_irq_clear with ata_noop_irq_clear.
    
    * pata_platform sets port_start to ata_dummy_ret0.  port_start can
      just be set to NULL.
    
    * sata_fsl supports NCQ but was missing qc_defer.  Fixed.
    
    * pata_rb600_cf implements dummy port_start.  Removed.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 20534202fc79..db4c3cb78fda 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -114,6 +114,7 @@ static struct scsi_host_template generic_sht = {
 
 static struct ata_port_operations generic_port_ops = {
 	.set_mode	= generic_set_mode,
+	.mode_filter	= ata_pci_default_filter,
 
 	.tf_load	= ata_tf_load,
 	.tf_read	= ata_tf_read,

commit 5e8f757cb2e0f67bf43f71d5180a8bf0ab3484eb
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Sat Jan 19 16:07:58 2008 +0000

    ata_generic: Cenatek support
    
    Not much to do here. It's an ata memory as disk.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index d11a4f1fe86a..20534202fc79 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -26,7 +26,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME "ata_generic"
-#define DRV_VERSION "0.2.13"
+#define DRV_VERSION "0.2.15"
 
 /*
  *	A generic parallel ATA driver using libata
@@ -48,11 +48,15 @@ static int generic_set_mode(struct ata_link *link, struct ata_device **unused)
 	struct ata_port *ap = link->ap;
 	int dma_enabled = 0;
 	struct ata_device *dev;
+	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
 
 	/* Bits 5 and 6 indicate if DMA is active on master/slave */
 	if (ap->ioaddr.bmdma_addr)
 		dma_enabled = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
 
+	if (pdev->vendor == PCI_VENDOR_ID_CENATEK)
+		dma_enabled = 0xFF;
+
 	ata_link_for_each_dev(dev, link) {
 		if (!ata_dev_enabled(dev))
 			continue;
@@ -201,6 +205,7 @@ static struct pci_device_id ata_generic[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_HINT,   PCI_DEVICE_ID_HINT_VXPROII_IDE), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_VIA,    PCI_DEVICE_ID_VIA_82C561), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_OPTI,   PCI_DEVICE_ID_OPTI_82C558), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CENATEK,PCI_DEVICE_ID_CENATEK_IDE), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_1), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_2),  },

commit 9d3501ab962b1506d93974faf8509251b4a85fbc
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Nov 27 19:43:41 2007 +0900

    libata: kill ata_id_to_dma_mode()
    
    ata_id_to_dma_mode() isn't quite generic.  The function is basically
    privately implemented ata_id_xfermask() combined with hardcoded mode
    printing and configuration which are specific to ata_generic.
    
    Kill the function and open code it in generic_set_mode() using generic
    xfermode handling functions.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index fb5434c8ae6e..d11a4f1fe86a 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -63,7 +63,22 @@ static int generic_set_mode(struct ata_link *link, struct ata_device **unused)
 		/* We do need the right mode information for DMA or PIO
 		   and this comes from the current configuration flags */
 		if (dma_enabled & (1 << (5 + dev->devno))) {
-			ata_id_to_dma_mode(dev, XFER_MW_DMA_0);
+			unsigned int xfer_mask = ata_id_xfermask(dev->id);
+			const char *name;
+
+			if (xfer_mask & (ATA_MASK_MWDMA | ATA_MASK_UDMA))
+				name = ata_mode_string(xfer_mask);
+			else {
+				/* SWDMA perhaps? */
+				name = "DMA";
+				xfer_mask |= ata_xfer_mode2mask(XFER_MW_DMA_0);
+			}
+
+			ata_dev_printk(dev, KERN_INFO, "configured for %s\n",
+				       name);
+
+			dev->xfer_mode = ata_xfer_mask2mode(xfer_mask);
+			dev->xfer_shift = ata_xfer_mode2shift(dev->xfer_mode);
 			dev->flags &= ~ATA_DFLAG_PIO;
 		} else {
 			ata_dev_printk(dev, KERN_INFO, "configured for PIO\n");

commit f8ab6d8e15a9b978f79aee794c263014c2959dfc
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Nov 27 19:43:38 2007 +0900

    ata_generic: unindent loop in generic_set_mode()
    
    Unindent loop body in generic_set_mode().  This is to ease future
    change.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 90329982bef7..fb5434c8ae6e 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -54,21 +54,22 @@ static int generic_set_mode(struct ata_link *link, struct ata_device **unused)
 		dma_enabled = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
 
 	ata_link_for_each_dev(dev, link) {
-		if (ata_dev_enabled(dev)) {
-			/* We don't really care */
-			dev->pio_mode = XFER_PIO_0;
-			dev->dma_mode = XFER_MW_DMA_0;
-			/* We do need the right mode information for DMA or PIO
-			   and this comes from the current configuration flags */
-			if (dma_enabled & (1 << (5 + dev->devno))) {
-				ata_id_to_dma_mode(dev, XFER_MW_DMA_0);
-				dev->flags &= ~ATA_DFLAG_PIO;
-			} else {
-				ata_dev_printk(dev, KERN_INFO, "configured for PIO\n");
-				dev->xfer_mode = XFER_PIO_0;
-				dev->xfer_shift = ATA_SHIFT_PIO;
-				dev->flags |= ATA_DFLAG_PIO;
-			}
+		if (!ata_dev_enabled(dev))
+			continue;
+
+		/* We don't really care */
+		dev->pio_mode = XFER_PIO_0;
+		dev->dma_mode = XFER_MW_DMA_0;
+		/* We do need the right mode information for DMA or PIO
+		   and this comes from the current configuration flags */
+		if (dma_enabled & (1 << (5 + dev->devno))) {
+			ata_id_to_dma_mode(dev, XFER_MW_DMA_0);
+			dev->flags &= ~ATA_DFLAG_PIO;
+		} else {
+			ata_dev_printk(dev, KERN_INFO, "configured for PIO\n");
+			dev->xfer_mode = XFER_PIO_0;
+			dev->xfer_shift = ATA_SHIFT_PIO;
+			dev->flags |= ATA_DFLAG_PIO;
 		}
 	}
 	return 0;

commit 81ad1837b590775336f68eafcae8dab13a975b3a
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Wed Aug 22 22:55:41 2007 +0100

    libata: Switch most of the remaining SFF drivers to ata_sff_port_start
    
    This avoids allocating DMA buffers if not needed but at the moment is
    mostly just a neatness item.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index afe71a6e0dab..90329982bef7 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -121,7 +121,7 @@ static struct ata_port_operations generic_port_ops = {
 	.irq_clear	= ata_bmdma_irq_clear,
 	.irq_on		= ata_irq_on,
 
-	.port_start	= ata_port_start,
+	.port_start	= ata_sff_port_start,
 };
 
 static int all_generic_ide;		/* Set to claim all devices */

commit ac8869d56d95a8c74403e6f7a47d74fcfcc1b988
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Aug 16 03:17:03 2007 -0400

    [libata] Remove ->port_disable() hook
    
    It was always set to ata_port_disable().  Removed the hook, and replaced
    the very few ap->ops->port_disable() callsites with direct calls to
    ata_port_disable().
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 6ec1bbc4fcc4..afe71a6e0dab 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -95,7 +95,6 @@ static struct scsi_host_template generic_sht = {
 static struct ata_port_operations generic_port_ops = {
 	.set_mode	= generic_set_mode,
 
-	.port_disable	= ata_port_disable,
 	.tf_load	= ata_tf_load,
 	.tf_read	= ata_tf_read,
 	.check_status 	= ata_check_status,

commit 6d32d30f55020d766388df7515f771f68c973033
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Aug 15 05:38:46 2007 -0400

    [libata] Remove ->irq_ack() hook, and ata_dummy_irq_on()
    
    * ->irq_ack() is redundant to what the irq handler already
      performs... chk-status + irq-clear.  Furthermore, it is only
      called in one place, when screaming-irq-debugging is enabled,
      so we don't want to bother with a hook just for that.
    
    * ata_dummy_irq_on() is only ever used in drivers that have
      no callpath reaching ->irq_on().  Remove .irq_on hook from
      those drivers, and the now-unused ata_dummy_irq_on()
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index e390ad47c8ef..6ec1bbc4fcc4 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -121,7 +121,6 @@ static struct ata_port_operations generic_port_ops = {
 	.irq_handler	= ata_interrupt,
 	.irq_clear	= ata_bmdma_irq_clear,
 	.irq_on		= ata_irq_on,
-	.irq_ack	= ata_irq_ack,
 
 	.port_start	= ata_port_start,
 };

commit 0260731f0187840e272bfa10d3ba0f3e417976f5
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Aug 6 18:36:23 2007 +0900

    libata-link: linkify config/EH related functions
    
    Make the following functions deal with ata_link instead of ata_port.
    
    * ata_set_mode()
    * ata_eh_autopsy() and related functions
    * ata_eh_report() and related functions
    * suspend/resume related functions
    * ata_eh_recover() and related functions
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 44328a16075c..e390ad47c8ef 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -34,7 +34,7 @@
 
 /**
  *	generic_set_mode	-	mode setting
- *	@ap: interface to set up
+ *	@link: link to set up
  *	@unused: returned device on error
  *
  *	Use a non standard set_mode function. We don't want to be tuned.
@@ -43,8 +43,9 @@
  *	and respect them.
  */
 
-static int generic_set_mode(struct ata_port *ap, struct ata_device **unused)
+static int generic_set_mode(struct ata_link *link, struct ata_device **unused)
 {
+	struct ata_port *ap = link->ap;
 	int dma_enabled = 0;
 	struct ata_device *dev;
 
@@ -52,7 +53,7 @@ static int generic_set_mode(struct ata_port *ap, struct ata_device **unused)
 	if (ap->ioaddr.bmdma_addr)
 		dma_enabled = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
 
-	ata_link_for_each_dev(dev, &ap->link) {
+	ata_link_for_each_dev(dev, link) {
 		if (ata_dev_enabled(dev)) {
 			/* We don't really care */
 			dev->pio_mode = XFER_PIO_0;

commit f58229f8060055b08b34008ea08f31de1e2f003c
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Aug 6 18:36:23 2007 +0900

    libata-link: implement and use link/device iterators
    
    Multiple links and different number of devices per link should be
    considered to iterate over links and devices.  This patch implements
    and uses link and device iterators - ata_port_for_each_link() and
    ata_link_for_each_dev() - and ata_link_max_devices().
    
    This change makes a lot of functions iterate over only possible
    devices instead of from dev 0 to dev ATA_MAX_DEVICES.  All such
    changes have been examined and nothing should be broken.
    
    While at it, add a separating comment before device helpers to
    distinguish them better from link helpers and others.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index b5e390ff5bd8..44328a16075c 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -46,21 +46,20 @@
 static int generic_set_mode(struct ata_port *ap, struct ata_device **unused)
 {
 	int dma_enabled = 0;
-	int i;
+	struct ata_device *dev;
 
 	/* Bits 5 and 6 indicate if DMA is active on master/slave */
 	if (ap->ioaddr.bmdma_addr)
 		dma_enabled = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
 
-	for (i = 0; i < ATA_MAX_DEVICES; i++) {
-		struct ata_device *dev = &ap->link.device[i];
+	ata_link_for_each_dev(dev, &ap->link) {
 		if (ata_dev_enabled(dev)) {
 			/* We don't really care */
 			dev->pio_mode = XFER_PIO_0;
 			dev->dma_mode = XFER_MW_DMA_0;
 			/* We do need the right mode information for DMA or PIO
 			   and this comes from the current configuration flags */
-			if (dma_enabled & (1 << (5 + i))) {
+			if (dma_enabled & (1 << (5 + dev->devno))) {
 				ata_id_to_dma_mode(dev, XFER_MW_DMA_0);
 				dev->flags &= ~ATA_DFLAG_PIO;
 			} else {

commit 9af5c9c97dc9d599281778864c72b385f0c63341
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Aug 6 18:36:22 2007 +0900

    libata-link: introduce ata_link
    
    Introduce ata_link.  It abstracts PHY and sits between ata_port and
    ata_device.  This new level of abstraction is necessary to support
    SATA Port Multiplier, which basically adds a bunch of links (PHYs) to
    a ATA host port.  Fields related to command execution, spd_limit and
    EH are per-link and thus moved to ata_link.
    
    This patch only defines the host link.  Multiple link handling will be
    added later.  Also, a lot of ap->link derefences are added but many of
    them will be removed as each part is converted to deal directly with
    ata_link instead of ata_port.
    
    This patch introduces no behavior change.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: James Bottomley <James.Bottomley@SteelEye.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 945466954724..b5e390ff5bd8 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -53,7 +53,7 @@ static int generic_set_mode(struct ata_port *ap, struct ata_device **unused)
 		dma_enabled = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
 
 	for (i = 0; i < ATA_MAX_DEVICES; i++) {
-		struct ata_device *dev = &ap->device[i];
+		struct ata_device *dev = &ap->link.device[i];
 		if (ata_dev_enabled(dev)) {
 			/* We don't really care */
 			dev->pio_mode = XFER_PIO_0;

commit 2a3103ce4357a09c2289405f969acec0edf4398f
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Aug 31 04:54:06 2007 -0400

    [libata] Bump driver versions
    
    Bump the versions for drivers that were modified, but had not already
    had a version number bump.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 430fcf4f9ef3..945466954724 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -26,7 +26,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME "ata_generic"
-#define DRV_VERSION "0.2.12"
+#define DRV_VERSION "0.2.13"
 
 /*
  *	A generic parallel ATA driver using libata

commit bf6263a853c9c143bf03f0a6fdcc68ab714fb5f5
Author: Jeff Garzik <jeff@garzik.org>
Date:   Mon Jul 9 12:16:50 2007 -0400

    [libata] Use ATA_UDMAx standard masks when filling driver's udma_mask info
    
    The ATA_UDMAx masks are self-documenting, and far better than manually
    writing in the hex mask.
    
    Note that pata_it8213 mask differed from the comment.  Added a FIXME there.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 0878fb5b3254..430fcf4f9ef3 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -146,7 +146,7 @@ static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id
 		.flags = ATA_FLAG_SLAVE_POSS,
 		.pio_mask = 0x1f,
 		.mwdma_mask = 0x07,
-		.udma_mask = 0x3f,
+		.udma_mask = ATA_UDMA5,
 		.port_ops = &generic_port_ops
 	};
 	const struct ata_port_info *ppi[] = { &info, NULL };

commit 1d2808fd3d2d5d2c0483796a0f443d1cb3f11367
Author: Jeff Garzik <jeff@garzik.org>
Date:   Mon May 28 06:59:48 2007 -0400

    [libata] PATA drivers: remove ATA_FLAG_SRST
    
    This flag only has meaning in old-EH drivers, and these drivers have
    already been converted to the new EH.  Remove.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 4c6e95c95e4a..0878fb5b3254 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -143,7 +143,7 @@ static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id
 	u16 command;
 	static const struct ata_port_info info = {
 		.sht = &generic_sht,
-		.flags = ATA_FLAG_SLAVE_POSS | ATA_FLAG_SRST,
+		.flags = ATA_FLAG_SLAVE_POSS,
 		.pio_mask = 0x1f,
 		.mwdma_mask = 0x07,
 		.udma_mask = 0x3f,

commit d6f4d5eafdd0bbdaa166a0650d27045c26ca63dd
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue Jul 3 15:11:30 2007 +0100

    ata_generic: Check the right register for the DMA enabled flags
    
    Mirrors change in IT821X
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 7565f022bd69..4c6e95c95e4a 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -50,7 +50,7 @@ static int generic_set_mode(struct ata_port *ap, struct ata_device **unused)
 
 	/* Bits 5 and 6 indicate if DMA is active on master/slave */
 	if (ap->ioaddr.bmdma_addr)
-		dma_enabled = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_CMD);
+		dma_enabled = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
 
 	for (i = 0; i < ATA_MAX_DEVICES; i++) {
 		struct ata_device *dev = &ap->device[i];

commit 8bc3fc470eb25af4d70c72485cbcb130cc657691
Author: Jeff Garzik <jeff@garzik.org>
Date:   Mon May 21 20:26:38 2007 -0400

    libata: bump versions
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index c3d753296bc6..7565f022bd69 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -26,7 +26,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME "ata_generic"
-#define DRV_VERSION "0.2.11"
+#define DRV_VERSION "0.2.12"
 
 /*
  *	A generic parallel ATA driver using libata

commit 1626aeb881236c8cb022b5e4ca594146a951d669
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri May 4 12:43:58 2007 +0200

    libata: clean up SFF init mess
    
    The intention of using port_mask in SFF init helpers was to eventually
    support exoctic configurations such as combination of legacy and
    native port on the same controller.  This never became actually
    necessary and the related code always has been subtly broken one way
    or the other.  Now that new init model is in place, there is no reason
    to make common helpers capable of handling all corner cases.  Exotic
    cases can simply dealt within LLDs as necessary.
    
    This patch removes port_mask handling in SFF init helpers.  SFF init
    helpers don't take n_ports argument and interpret it into port_mask
    anymore.  All information is carried via port_info.  n_ports argument
    is dropped and always two ports are allocated.  LLD can tell SFF to
    skip certain port by marking it dummy.  Note that SFF code has been
    treating unuvailable ports this way for a long time until recent
    breakage fix from Linus and is consistent with how other drivers
    handle with unavailable ports.
    
    This fixes 1-port legacy host handling still broken after the recent
    native mode fix and simplifies SFF init logic.  The following changes
    are made...
    
    * ata_pci_init_native_host() and ata_init_legacy_host() both now try
      to initialized whatever they can and mark failed ports dummy.  They
      return 0 if any port is successfully initialized.
    
    * ata_pci_prepare_native_host() and ata_pci_init_one() now doesn't
      take n_ports argument.  All info should be specified via port_info
      array.  Always two ports are allocated.
    
    * ata_pci_init_bmdma() exported to be used by LLDs in exotic cases.
    
    * port_info handling in all LLDs are standardized - all port_info
      arrays are const stack variable named ppi.  Unless the second port
      is different from the first, its port_info is specified as NULL
      (tells libata that it's identical to the last non-NULL port_info).
    
    * pata_hpt37x/hpt3x2n: don't modify static variable directly.  Make an
      on-stack copy instead as ata_piix does.
    
    * pata_uli: It has 4 ports instead of 2.  Don't use
      ata_pci_prepare_native_host().  Allocate the host explicitly and use
      init helpers.  It's simple enough.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 0f19e3223358..c3d753296bc6 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -141,7 +141,7 @@ static int all_generic_ide;		/* Set to claim all devices */
 static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	u16 command;
-	static struct ata_port_info info = {
+	static const struct ata_port_info info = {
 		.sht = &generic_sht,
 		.flags = ATA_FLAG_SLAVE_POSS | ATA_FLAG_SRST,
 		.pio_mask = 0x1f,
@@ -149,7 +149,7 @@ static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id
 		.udma_mask = 0x3f,
 		.port_ops = &generic_port_ops
 	};
-	static struct ata_port_info *port_info[2] = { &info, &info };
+	const struct ata_port_info *ppi[] = { &info, NULL };
 
 	/* Don't use the generic entry unless instructed to do so */
 	if (id->driver_data == 1 && all_generic_ide == 0)
@@ -175,7 +175,7 @@ static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id
 	if (dev->vendor == PCI_VENDOR_ID_AL)
 	    	ata_pci_clear_simplex(dev);
 
-	return ata_pci_init_one(dev, port_info, 2);
+	return ata_pci_init_one(dev, ppi);
 }
 
 static struct pci_device_id ata_generic[] = {

commit 9666f4009c22f6520ac3fb8a19c9e32ab973e828
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri May 4 21:27:47 2007 +0200

    libata: reimplement suspend/resume support using sdev->manage_start_stop
    
    Reimplement suspend/resume support using sdev->manage_start_stop.
    
    * Device suspend/resume is now SCSI layer's responsibility and the
      code is simplified a lot.
    
    * DPM is dropped.  This also simplifies code a lot.  Suspend/resume
      status is port-wide now.
    
    * ata_scsi_device_suspend/resume() and ata_dev_ready() removed.
    
    * Resume now has to wait for disk to spin up before proceeding.  I
      couldn't find easy way out as libata is in EH waiting for the
      disk to be ready and sd is waiting for EH to complete to issue
      START_STOP.
    
    * sdev->manage_start_stop is set to 1 in ata_scsi_slave_config().
      This fixes spindown on shutdown and suspend-to-disk.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 92a491ddd030..0f19e3223358 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -54,7 +54,7 @@ static int generic_set_mode(struct ata_port *ap, struct ata_device **unused)
 
 	for (i = 0; i < ATA_MAX_DEVICES; i++) {
 		struct ata_device *dev = &ap->device[i];
-		if (ata_dev_ready(dev)) {
+		if (ata_dev_enabled(dev)) {
 			/* We don't really care */
 			dev->pio_mode = XFER_PIO_0;
 			dev->dma_mode = XFER_MW_DMA_0;
@@ -90,10 +90,6 @@ static struct scsi_host_template generic_sht = {
 	.slave_configure	= ata_scsi_slave_config,
 	.slave_destroy		= ata_scsi_slave_destroy,
 	.bios_param		= ata_std_bios_param,
-#ifdef CONFIG_PM
-	.resume			= ata_scsi_device_resume,
-	.suspend		= ata_scsi_device_suspend,
-#endif
 };
 
 static struct ata_port_operations generic_port_ops = {

commit eb4a2c7f03db06dda0370591c958fa5a62ff2ec3
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Wed Apr 11 00:04:20 2007 +0100

    pata: cable methods
    
    Versus upstream as requested
    
    Last of the trivial switches to cable_detect methods.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index d8e79882b880..92a491ddd030 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -32,35 +32,6 @@
  *	A generic parallel ATA driver using libata
  */
 
-/**
- *	generic_pre_reset		-	probe begin
- *	@ap: ATA port
- *
- *	Set up cable type and use generic probe init
- */
-
-static int generic_pre_reset(struct ata_port *ap)
-{
-	ap->cbl = ATA_CBL_PATA80;
-	return ata_std_prereset(ap);
-}
-
-
-/**
- *	generic_error_handler - Probe specified port on PATA host controller
- *	@ap: Port to probe
- *	@classes:
- *
- *	LOCKING:
- *	None (inherited from caller).
- */
-
-
-static void generic_error_handler(struct ata_port *ap)
-{
-	ata_bmdma_drive_eh(ap, generic_pre_reset, ata_std_softreset, NULL, ata_std_postreset);
-}
-
 /**
  *	generic_set_mode	-	mode setting
  *	@ap: interface to set up
@@ -144,8 +115,9 @@ static struct ata_port_operations generic_port_ops = {
 
 	.freeze		= ata_bmdma_freeze,
 	.thaw		= ata_bmdma_thaw,
-	.error_handler	= generic_error_handler,
+	.error_handler	= ata_bmdma_error_handler,
 	.post_internal_cmd = ata_bmdma_post_internal_cmd,
+	.cable_detect	= ata_cable_unknown,
 
 	.qc_prep 	= ata_qc_prep,
 	.qc_issue	= ata_qc_issue_prot,

commit 438ac6d5e3f8106a6bd1a5682c508d660294a85d
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Mar 2 17:31:26 2007 +0900

    libata: add missing CONFIG_PM in LLDs
    
    Add missing #ifdef CONFIG_PM conditionals around all PM related parts
    in libata LLDs.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index f48b4883c930..d8e79882b880 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -119,8 +119,10 @@ static struct scsi_host_template generic_sht = {
 	.slave_configure	= ata_scsi_slave_config,
 	.slave_destroy		= ata_scsi_slave_destroy,
 	.bios_param		= ata_std_bios_param,
+#ifdef CONFIG_PM
 	.resume			= ata_scsi_device_resume,
 	.suspend		= ata_scsi_device_suspend,
+#endif
 };
 
 static struct ata_port_operations generic_port_ops = {
@@ -230,8 +232,10 @@ static struct pci_driver ata_generic_pci_driver = {
 	.id_table	= ata_generic,
 	.probe 		= ata_generic_init_one,
 	.remove		= ata_pci_remove_one,
+#ifdef CONFIG_PM
 	.suspend	= ata_pci_device_suspend,
 	.resume		= ata_pci_device_resume,
+#endif
 };
 
 static int __init ata_generic_init(void)

commit cb48cab7f363014e0a5dc21f7b4892c15d626d41
Author: Jeff Garzik <jeff@garzik.org>
Date:   Mon Feb 26 06:04:24 2007 -0500

    [libata] bump versions
    
    Bump versions based on changes submitted during 2.6.21 merge window.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 7649039cc6a9..f48b4883c930 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -26,7 +26,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME "ata_generic"
-#define DRV_VERSION "0.2.10"
+#define DRV_VERSION "0.2.11"
 
 /*
  *	A generic parallel ATA driver using libata

commit 616ece2e7e5363574d172d64b19ffe9535606a1b
Author: Alan <alan@lxorguk.ukuu.org.uk>
Date:   Tue Feb 20 18:15:03 2007 +0000

    libata: Use new id_to_dma_mode function to tidy reporting in more drivers (minimally tested)
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index be66ea08da55..7649039cc6a9 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -90,10 +90,10 @@ static int generic_set_mode(struct ata_port *ap, struct ata_device **unused)
 			/* We do need the right mode information for DMA or PIO
 			   and this comes from the current configuration flags */
 			if (dma_enabled & (1 << (5 + i))) {
-				dev->xfer_mode = XFER_MW_DMA_0;
-				dev->xfer_shift = ATA_SHIFT_MWDMA;
+				ata_id_to_dma_mode(dev, XFER_MW_DMA_0);
 				dev->flags &= ~ATA_DFLAG_PIO;
 			} else {
+				ata_dev_printk(dev, KERN_INFO, "configured for PIO\n");
 				dev->xfer_mode = XFER_PIO_0;
 				dev->xfer_shift = ATA_SHIFT_PIO;
 				dev->flags |= ATA_DFLAG_PIO;

commit 246ce3b675843e0369643cceb4faeb6cf6d19a30
Author: Akira Iguchi <akira2.iguchi@toshiba.co.jp>
Date:   Fri Jan 26 16:27:58 2007 +0900

    libata: add another IRQ calls (libata drivers)
    
    This patch is against each libata driver.
    
    Two IRQ calls are added in ata_port_operations.
    - irq_on() is used to enable interrupts.
    - irq_ack() is used to acknowledge a device interrupt.
    
    In most drivers, ata_irq_on() and ata_irq_ack() are used for
    irq_on and irq_ack respectively.
    
    In some drivers (ex: ahci, sata_sil24) which cannot use them
    as is, ata_dummy_irq_on() and ata_dummy_irq_ack() are used.
    
    Signed-off-by: Kou Ishizaki <kou.ishizaki@toshiba.co.jp>
    Signed-off-by: Akira Iguchi <akira2.iguchi@toshiba.co.jp>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index c79887f31841..be66ea08da55 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -150,6 +150,8 @@ static struct ata_port_operations generic_port_ops = {
 
 	.irq_handler	= ata_interrupt,
 	.irq_clear	= ata_bmdma_irq_clear,
+	.irq_on		= ata_irq_on,
+	.irq_ack	= ata_irq_ack,
 
 	.port_start	= ata_port_start,
 };

commit 0d5ff566779f894ca9937231a181eb31e4adff0e
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Feb 1 15:06:36 2007 +0900

    libata: convert to iomap
    
    Convert libata core layer and LLDs to use iomap.
    
    * managed iomap is used.  Pointer to pcim_iomap_table() is cached at
      host->iomap and used through out LLDs.  This basically replaces
      host->mmio_base.
    
    * if possible, pcim_iomap_regions() is used
    
    Most iomap operation conversions are taken from Jeff Garzik
    <jgarzik@pobox.com>'s iomap branch.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index a25cbd653b0c..c79887f31841 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -79,7 +79,7 @@ static int generic_set_mode(struct ata_port *ap, struct ata_device **unused)
 
 	/* Bits 5 and 6 indicate if DMA is active on master/slave */
 	if (ap->ioaddr.bmdma_addr)
-		dma_enabled = inb(ap->ioaddr.bmdma_addr + ATA_DMA_CMD);
+		dma_enabled = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_CMD);
 
 	for (i = 0; i < ATA_MAX_DEVICES; i++) {
 		struct ata_device *dev = &ap->device[i];
@@ -138,7 +138,7 @@ static struct ata_port_operations generic_port_ops = {
 	.bmdma_stop	= ata_bmdma_stop,
 	.bmdma_status 	= ata_bmdma_status,
 
-	.data_xfer	= ata_pio_data_xfer,
+	.data_xfer	= ata_data_xfer,
 
 	.freeze		= ata_bmdma_freeze,
 	.thaw		= ata_bmdma_thaw,

commit 24dc5f33ea4b504cfbd23fa159a4cacba8e4d800
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Jan 20 16:00:28 2007 +0900

    libata: update libata LLDs to use devres
    
    Update libata LLDs to use devres.  Core layer is already converted to
    support managed LLDs.  This patch simplifies initialization and fixes
    many resource related bugs in init failure and detach path.  For
    example, all converted drivers now handle ata_device_add() failure
    gracefully without excessive resource rollback code.
    
    As most resources are released automatically on driver detach, many
    drivers don't need or can do with much simpler ->{port|host}_stop().
    In general, stop callbacks are need iff port or host needs to be given
    commands to shut it down.  Note that freezing is enough in many cases
    and ports are automatically frozen before being detached.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 24af56081b5d..a25cbd653b0c 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -152,8 +152,6 @@ static struct ata_port_operations generic_port_ops = {
 	.irq_clear	= ata_bmdma_irq_clear,
 
 	.port_start	= ata_port_start,
-	.port_stop	= ata_port_stop,
-	.host_stop	= ata_host_stop
 };
 
 static int all_generic_ide;		/* Set to claim all devices */

commit b229a7b0aed808f2ef6a5e9dbf78b0f17cefb4d0
Author: Alan <alan@lxorguk.ukuu.org.uk>
Date:   Wed Jan 24 11:47:07 2007 +0000

    libata: set_mode, Fix the FIXME
    
    When set_mode() changed ->set_mode didn't adapt. This makes the needed
    changes and removes the relevant FIXME case.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 908751d27e76..24af56081b5d 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -64,6 +64,7 @@ static void generic_error_handler(struct ata_port *ap)
 /**
  *	generic_set_mode	-	mode setting
  *	@ap: interface to set up
+ *	@unused: returned device on error
  *
  *	Use a non standard set_mode function. We don't want to be tuned.
  *	The BIOS configured everything. Our job is not to fiddle. We
@@ -71,7 +72,7 @@ static void generic_error_handler(struct ata_port *ap)
  *	and respect them.
  */
 
-static void generic_set_mode(struct ata_port *ap)
+static int generic_set_mode(struct ata_port *ap, struct ata_device **unused)
 {
 	int dma_enabled = 0;
 	int i;
@@ -82,7 +83,7 @@ static void generic_set_mode(struct ata_port *ap)
 
 	for (i = 0; i < ATA_MAX_DEVICES; i++) {
 		struct ata_device *dev = &ap->device[i];
-		if (ata_dev_enabled(dev)) {
+		if (ata_dev_ready(dev)) {
 			/* We don't really care */
 			dev->pio_mode = XFER_PIO_0;
 			dev->dma_mode = XFER_MW_DMA_0;
@@ -99,6 +100,7 @@ static void generic_set_mode(struct ata_port *ap)
 			}
 		}
 	}
+	return 0;
 }
 
 static struct scsi_host_template generic_sht = {

commit 2eab80ac0c96fb98267afeb12a4899801564c75b
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Nov 29 12:20:26 2006 +0900

    [PATCH] libata: kill unnecessary sht->max_sectors initializations
    
    sht->max_sectors is overrided unconditionally in ->slave_configure.
    There's no reason to set it to any value.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index c7e8f033125d..908751d27e76 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -109,7 +109,6 @@ static struct scsi_host_template generic_sht = {
 	.can_queue		= ATA_DEF_QUEUE,
 	.this_id		= ATA_SHT_THIS_ID,
 	.sg_tablesize		= LIBATA_MAX_PRD,
-	.max_sectors		= ATA_MAX_SECTORS,
 	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
 	.emulated		= ATA_SHT_EMULATED,
 	.use_clustering		= ATA_SHT_USE_CLUSTERING,

commit 30ced0f0d211999f316930eff7287aa5a9995bef
Author: Alan <alan@lxorguk.ukuu.org.uk>
Date:   Wed Nov 22 16:57:36 2006 +0000

    [PATCH] PATA libata: suspend/resume simple cases
    
    This patch adds the suspend/resume callbacks for drivers which don't need
    any additional help (beyond the pci resume quirk patch I posted earlier
    anyway). Also bring version numbers back inline with master copies.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 1b9ba4dfac65..c7e8f033125d 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -26,7 +26,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME "ata_generic"
-#define DRV_VERSION "0.2.7"
+#define DRV_VERSION "0.2.10"
 
 /*
  *	A generic parallel ATA driver using libata
@@ -118,6 +118,8 @@ static struct scsi_host_template generic_sht = {
 	.slave_configure	= ata_scsi_slave_config,
 	.slave_destroy		= ata_scsi_slave_destroy,
 	.bios_param		= ata_std_bios_param,
+	.resume			= ata_scsi_device_resume,
+	.suspend		= ata_scsi_device_suspend,
 };
 
 static struct ata_port_operations generic_port_ops = {
@@ -226,7 +228,9 @@ static struct pci_driver ata_generic_pci_driver = {
 	.name 		= DRV_NAME,
 	.id_table	= ata_generic,
 	.probe 		= ata_generic_init_one,
-	.remove		= ata_pci_remove_one
+	.remove		= ata_pci_remove_one,
+	.suspend	= ata_pci_device_suspend,
+	.resume		= ata_pci_device_resume,
 };
 
 static int __init ata_generic_init(void)

commit 2f27ce03628acdb81ead4abe914c713e04a3229e
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue Oct 10 14:28:12 2006 -0700

    [PATCH] pci_module_init-convertion-in-ata_genericc fix
    
    Acked-by: Alan Cox <alan@redhat.com> but please apply as follows to keep
    revision id straight
    
    Cc: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index a44c20c0c757..1b9ba4dfac65 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -26,7 +26,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME "ata_generic"
-#define DRV_VERSION "0.2.6"
+#define DRV_VERSION "0.2.7"
 
 /*
  *	A generic parallel ATA driver using libata

commit 3f03c6713a4adfae058f4f1db5acde393db44ec0
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Tue Oct 10 14:28:12 2006 -0700

    [PATCH] pci_module_init convertion in ata_generic.c
    
    pci_module_init convertion in ata_generic.c.
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Acked-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 4a80ff9312b8..a44c20c0c757 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -231,7 +231,7 @@ static struct pci_driver ata_generic_pci_driver = {
 
 static int __init ata_generic_init(void)
 {
-	return pci_module_init(&ata_generic_pci_driver);
+	return pci_register_driver(&ata_generic_pci_driver);
 }
 
 

commit afdfe899e6420eac6c5eb3bc8c89456dff38d40e
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Nov 29 11:26:47 2006 +0900

    [PATCH] libata: add missing sht->slave_destroy
    
    Many LLDs are missing sht->slave_destroy.  The method is mandatory to
    support device warm unplugging (echo 1 > /sys/.../delete).  Without
    it, libata might access released scsi device.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 377425e71391..4a80ff9312b8 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -116,6 +116,7 @@ static struct scsi_host_template generic_sht = {
 	.proc_name		= DRV_NAME,
 	.dma_boundary		= ATA_DMA_BOUNDARY,
 	.slave_configure	= ata_scsi_slave_config,
+	.slave_destroy		= ata_scsi_slave_destroy,
 	.bios_param		= ata_std_bios_param,
 };
 

commit bda3028813bd07f34f30288a492fbf6f7b8712dd
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Sep 27 05:41:13 2006 -0400

    [libata] Don't use old-EH ->eng_timeout() hook when not needed
    
    The PATA driver set got converted to the new error handling setup, but
    the old hooks were accidentally left in place.  Now, removed.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 1d1c30a2fcd0..377425e71391 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -143,7 +143,7 @@ static struct ata_port_operations generic_port_ops = {
 
 	.qc_prep 	= ata_qc_prep,
 	.qc_issue	= ata_qc_issue_prot,
-	.eng_timeout	= ata_eng_timeout,
+
 	.irq_handler	= ata_interrupt,
 	.irq_clear	= ata_bmdma_irq_clear,
 

commit 85cd7251b9112e3dabeac9fd3b175601ca607241
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Aug 31 00:03:49 2006 -0400

    [libata #pata-drivers] Trim trailing whitespace.

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
index 20b191dcf7ed..1d1c30a2fcd0 100644
--- a/drivers/ata/ata_generic.c
+++ b/drivers/ata/ata_generic.c
@@ -2,18 +2,18 @@
  *  ata_generic.c - Generic PATA/SATA controller driver.
  *  Copyright 2005 Red Hat Inc <alan@redhat.com>, all rights reserved.
  *
- *  Elements from ide/pci/generic.c 
+ *  Elements from ide/pci/generic.c
  *	    Copyright (C) 2001-2002	Andre Hedrick <andre@linux-ide.org>
  *	    Portions (C) Copyright 2002  Red Hat Inc <alan@redhat.com>
  *
  *  May be copied or modified under the terms of the GNU General Public License
- *  
+ *
  *  Driver for PCI IDE interfaces implementing the standard bus mastering
  *  interface functionality. This assumes the BIOS did the drive set up and
  *  tuning for us. By default we do not grab all IDE class devices as they
  *  may have other drivers or need fixups to avoid problems. Instead we keep
  *  a default list of stuff without documentation/driver that appears to
- *  work.  
+ *  work.
  */
 
 #include <linux/kernel.h>
@@ -38,7 +38,7 @@
  *
  *	Set up cable type and use generic probe init
  */
- 
+
 static int generic_pre_reset(struct ata_port *ap)
 {
 	ap->cbl = ATA_CBL_PATA80;
@@ -55,7 +55,7 @@ static int generic_pre_reset(struct ata_port *ap)
  *	None (inherited from caller).
  */
 
- 
+
 static void generic_error_handler(struct ata_port *ap)
 {
 	ata_bmdma_drive_eh(ap, generic_pre_reset, ata_std_softreset, NULL, ata_std_postreset);
@@ -68,9 +68,9 @@ static void generic_error_handler(struct ata_port *ap)
  *	Use a non standard set_mode function. We don't want to be tuned.
  *	The BIOS configured everything. Our job is not to fiddle. We
  *	read the dma enabled bits from the PCI configuration of the device
- *	and respect them. 
+ *	and respect them.
  */
- 
+
 static void generic_set_mode(struct ata_port *ap)
 {
 	int dma_enabled = 0;
@@ -79,14 +79,14 @@ static void generic_set_mode(struct ata_port *ap)
 	/* Bits 5 and 6 indicate if DMA is active on master/slave */
 	if (ap->ioaddr.bmdma_addr)
 		dma_enabled = inb(ap->ioaddr.bmdma_addr + ATA_DMA_CMD);
-	
+
 	for (i = 0; i < ATA_MAX_DEVICES; i++) {
 		struct ata_device *dev = &ap->device[i];
 		if (ata_dev_enabled(dev)) {
 			/* We don't really care */
 			dev->pio_mode = XFER_PIO_0;
 			dev->dma_mode = XFER_MW_DMA_0;
-			/* We do need the right mode information for DMA or PIO 
+			/* We do need the right mode information for DMA or PIO
 			   and this comes from the current configuration flags */
 			if (dma_enabled & (1 << (5 + i))) {
 				dev->xfer_mode = XFER_MW_DMA_0;
@@ -121,7 +121,7 @@ static struct scsi_host_template generic_sht = {
 
 static struct ata_port_operations generic_port_ops = {
 	.set_mode	= generic_set_mode,
-	
+
 	.port_disable	= ata_port_disable,
 	.tf_load	= ata_tf_load,
 	.tf_read	= ata_tf_read,
@@ -133,7 +133,7 @@ static struct ata_port_operations generic_port_ops = {
 	.bmdma_start 	= ata_bmdma_start,
 	.bmdma_stop	= ata_bmdma_stop,
 	.bmdma_status 	= ata_bmdma_status,
-	
+
 	.data_xfer	= ata_pio_data_xfer,
 
 	.freeze		= ata_bmdma_freeze,
@@ -150,8 +150,8 @@ static struct ata_port_operations generic_port_ops = {
 	.port_start	= ata_port_start,
 	.port_stop	= ata_port_stop,
 	.host_stop	= ata_host_stop
-};	
-	
+};
+
 static int all_generic_ide;		/* Set to claim all devices */
 
 /**
@@ -160,10 +160,10 @@ static int all_generic_ide;		/* Set to claim all devices */
  *	@id: match entry
  *
  *	Called each time a matching IDE interface is found. We check if the
- *	interface is one we wish to claim and if so we perform any chip 
+ *	interface is one we wish to claim and if so we perform any chip
  *	specific hacks then let the ATA layer do the heavy lifting.
  */
- 
+
 static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	u16 command;
@@ -176,7 +176,7 @@ static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id
 		.port_ops = &generic_port_ops
 	};
 	static struct ata_port_info *port_info[2] = { &info, &info };
-		
+
 	/* Don't use the generic entry unless instructed to do so */
 	if (id->driver_data == 1 && all_generic_ide == 0)
 		return -ENODEV;
@@ -197,7 +197,7 @@ static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id
 	pci_read_config_word(dev, PCI_COMMAND, &command);
 	if (!(command & PCI_COMMAND_IO))
 		return -ENODEV;
-		
+
 	if (dev->vendor == PCI_VENDOR_ID_AL)
 	    	ata_pci_clear_simplex(dev);
 
@@ -207,7 +207,7 @@ static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id
 static struct pci_device_id ata_generic[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_PCTECH, PCI_DEVICE_ID_PCTECH_SAMURAI_IDE), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_HOLTEK, PCI_DEVICE_ID_HOLTEK_6565), },
-	{ PCI_DEVICE(PCI_VENDOR_ID_UMC,    PCI_DEVICE_ID_UMC_UM8673F), }, 
+	{ PCI_DEVICE(PCI_VENDOR_ID_UMC,    PCI_DEVICE_ID_UMC_UM8673F), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_UMC,    PCI_DEVICE_ID_UMC_UM8886A), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_UMC,    PCI_DEVICE_ID_UMC_UM8886BF), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_HINT,   PCI_DEVICE_ID_HINT_VXPROII_IDE), },

commit 669a5db411d85a14f86cd92bc16bf7ab5b8aa235
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Aug 29 18:12:40 2006 -0400

    [libata] Add a bunch of PATA drivers.
    
    The vast majority of drivers and changes are from Alan Cox.  Albert Lee
    contributed and maintains pata_pdc2027x.  Adrian Bunk, Andrew Morton,
    and Tejun Heo contributed various minor fixes and updates.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/ata_generic.c b/drivers/ata/ata_generic.c
new file mode 100644
index 000000000000..20b191dcf7ed
--- /dev/null
+++ b/drivers/ata/ata_generic.c
@@ -0,0 +1,252 @@
+/*
+ *  ata_generic.c - Generic PATA/SATA controller driver.
+ *  Copyright 2005 Red Hat Inc <alan@redhat.com>, all rights reserved.
+ *
+ *  Elements from ide/pci/generic.c 
+ *	    Copyright (C) 2001-2002	Andre Hedrick <andre@linux-ide.org>
+ *	    Portions (C) Copyright 2002  Red Hat Inc <alan@redhat.com>
+ *
+ *  May be copied or modified under the terms of the GNU General Public License
+ *  
+ *  Driver for PCI IDE interfaces implementing the standard bus mastering
+ *  interface functionality. This assumes the BIOS did the drive set up and
+ *  tuning for us. By default we do not grab all IDE class devices as they
+ *  may have other drivers or need fixups to avoid problems. Instead we keep
+ *  a default list of stuff without documentation/driver that appears to
+ *  work.  
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include <scsi/scsi_host.h>
+#include <linux/libata.h>
+
+#define DRV_NAME "ata_generic"
+#define DRV_VERSION "0.2.6"
+
+/*
+ *	A generic parallel ATA driver using libata
+ */
+
+/**
+ *	generic_pre_reset		-	probe begin
+ *	@ap: ATA port
+ *
+ *	Set up cable type and use generic probe init
+ */
+ 
+static int generic_pre_reset(struct ata_port *ap)
+{
+	ap->cbl = ATA_CBL_PATA80;
+	return ata_std_prereset(ap);
+}
+
+
+/**
+ *	generic_error_handler - Probe specified port on PATA host controller
+ *	@ap: Port to probe
+ *	@classes:
+ *
+ *	LOCKING:
+ *	None (inherited from caller).
+ */
+
+ 
+static void generic_error_handler(struct ata_port *ap)
+{
+	ata_bmdma_drive_eh(ap, generic_pre_reset, ata_std_softreset, NULL, ata_std_postreset);
+}
+
+/**
+ *	generic_set_mode	-	mode setting
+ *	@ap: interface to set up
+ *
+ *	Use a non standard set_mode function. We don't want to be tuned.
+ *	The BIOS configured everything. Our job is not to fiddle. We
+ *	read the dma enabled bits from the PCI configuration of the device
+ *	and respect them. 
+ */
+ 
+static void generic_set_mode(struct ata_port *ap)
+{
+	int dma_enabled = 0;
+	int i;
+
+	/* Bits 5 and 6 indicate if DMA is active on master/slave */
+	if (ap->ioaddr.bmdma_addr)
+		dma_enabled = inb(ap->ioaddr.bmdma_addr + ATA_DMA_CMD);
+	
+	for (i = 0; i < ATA_MAX_DEVICES; i++) {
+		struct ata_device *dev = &ap->device[i];
+		if (ata_dev_enabled(dev)) {
+			/* We don't really care */
+			dev->pio_mode = XFER_PIO_0;
+			dev->dma_mode = XFER_MW_DMA_0;
+			/* We do need the right mode information for DMA or PIO 
+			   and this comes from the current configuration flags */
+			if (dma_enabled & (1 << (5 + i))) {
+				dev->xfer_mode = XFER_MW_DMA_0;
+				dev->xfer_shift = ATA_SHIFT_MWDMA;
+				dev->flags &= ~ATA_DFLAG_PIO;
+			} else {
+				dev->xfer_mode = XFER_PIO_0;
+				dev->xfer_shift = ATA_SHIFT_PIO;
+				dev->flags |= ATA_DFLAG_PIO;
+			}
+		}
+	}
+}
+
+static struct scsi_host_template generic_sht = {
+	.module			= THIS_MODULE,
+	.name			= DRV_NAME,
+	.ioctl			= ata_scsi_ioctl,
+	.queuecommand		= ata_scsi_queuecmd,
+	.can_queue		= ATA_DEF_QUEUE,
+	.this_id		= ATA_SHT_THIS_ID,
+	.sg_tablesize		= LIBATA_MAX_PRD,
+	.max_sectors		= ATA_MAX_SECTORS,
+	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
+	.emulated		= ATA_SHT_EMULATED,
+	.use_clustering		= ATA_SHT_USE_CLUSTERING,
+	.proc_name		= DRV_NAME,
+	.dma_boundary		= ATA_DMA_BOUNDARY,
+	.slave_configure	= ata_scsi_slave_config,
+	.bios_param		= ata_std_bios_param,
+};
+
+static struct ata_port_operations generic_port_ops = {
+	.set_mode	= generic_set_mode,
+	
+	.port_disable	= ata_port_disable,
+	.tf_load	= ata_tf_load,
+	.tf_read	= ata_tf_read,
+	.check_status 	= ata_check_status,
+	.exec_command	= ata_exec_command,
+	.dev_select 	= ata_std_dev_select,
+
+	.bmdma_setup 	= ata_bmdma_setup,
+	.bmdma_start 	= ata_bmdma_start,
+	.bmdma_stop	= ata_bmdma_stop,
+	.bmdma_status 	= ata_bmdma_status,
+	
+	.data_xfer	= ata_pio_data_xfer,
+
+	.freeze		= ata_bmdma_freeze,
+	.thaw		= ata_bmdma_thaw,
+	.error_handler	= generic_error_handler,
+	.post_internal_cmd = ata_bmdma_post_internal_cmd,
+
+	.qc_prep 	= ata_qc_prep,
+	.qc_issue	= ata_qc_issue_prot,
+	.eng_timeout	= ata_eng_timeout,
+	.irq_handler	= ata_interrupt,
+	.irq_clear	= ata_bmdma_irq_clear,
+
+	.port_start	= ata_port_start,
+	.port_stop	= ata_port_stop,
+	.host_stop	= ata_host_stop
+};	
+	
+static int all_generic_ide;		/* Set to claim all devices */
+
+/**
+ *	ata_generic_init		-	attach generic IDE
+ *	@dev: PCI device found
+ *	@id: match entry
+ *
+ *	Called each time a matching IDE interface is found. We check if the
+ *	interface is one we wish to claim and if so we perform any chip 
+ *	specific hacks then let the ATA layer do the heavy lifting.
+ */
+ 
+static int ata_generic_init_one(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	u16 command;
+	static struct ata_port_info info = {
+		.sht = &generic_sht,
+		.flags = ATA_FLAG_SLAVE_POSS | ATA_FLAG_SRST,
+		.pio_mask = 0x1f,
+		.mwdma_mask = 0x07,
+		.udma_mask = 0x3f,
+		.port_ops = &generic_port_ops
+	};
+	static struct ata_port_info *port_info[2] = { &info, &info };
+		
+	/* Don't use the generic entry unless instructed to do so */
+	if (id->driver_data == 1 && all_generic_ide == 0)
+		return -ENODEV;
+
+	/* Devices that need care */
+	if (dev->vendor == PCI_VENDOR_ID_UMC &&
+	    dev->device == PCI_DEVICE_ID_UMC_UM8886A &&
+	    (!(PCI_FUNC(dev->devfn) & 1)))
+		return -ENODEV;
+
+	if (dev->vendor == PCI_VENDOR_ID_OPTI &&
+	    dev->device == PCI_DEVICE_ID_OPTI_82C558 &&
+	    (!(PCI_FUNC(dev->devfn) & 1)))
+		return -ENODEV;
+
+	/* Don't re-enable devices in generic mode or we will break some
+	   motherboards with disabled and unused IDE controllers */
+	pci_read_config_word(dev, PCI_COMMAND, &command);
+	if (!(command & PCI_COMMAND_IO))
+		return -ENODEV;
+		
+	if (dev->vendor == PCI_VENDOR_ID_AL)
+	    	ata_pci_clear_simplex(dev);
+
+	return ata_pci_init_one(dev, port_info, 2);
+}
+
+static struct pci_device_id ata_generic[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_PCTECH, PCI_DEVICE_ID_PCTECH_SAMURAI_IDE), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_HOLTEK, PCI_DEVICE_ID_HOLTEK_6565), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_UMC,    PCI_DEVICE_ID_UMC_UM8673F), }, 
+	{ PCI_DEVICE(PCI_VENDOR_ID_UMC,    PCI_DEVICE_ID_UMC_UM8886A), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_UMC,    PCI_DEVICE_ID_UMC_UM8886BF), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_HINT,   PCI_DEVICE_ID_HINT_VXPROII_IDE), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_VIA,    PCI_DEVICE_ID_VIA_82C561), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_OPTI,   PCI_DEVICE_ID_OPTI_82C558), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_1), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA,PCI_DEVICE_ID_TOSHIBA_PICCOLO_2),  },
+	/* Must come last. If you add entries adjust this table appropriately */
+	{ PCI_ANY_ID,		PCI_ANY_ID,			   PCI_ANY_ID, PCI_ANY_ID, PCI_CLASS_STORAGE_IDE << 8, 0xFFFFFF00UL, 1},
+	{ 0, },
+};
+
+static struct pci_driver ata_generic_pci_driver = {
+	.name 		= DRV_NAME,
+	.id_table	= ata_generic,
+	.probe 		= ata_generic_init_one,
+	.remove		= ata_pci_remove_one
+};
+
+static int __init ata_generic_init(void)
+{
+	return pci_module_init(&ata_generic_pci_driver);
+}
+
+
+static void __exit ata_generic_exit(void)
+{
+	pci_unregister_driver(&ata_generic_pci_driver);
+}
+
+
+MODULE_AUTHOR("Alan Cox");
+MODULE_DESCRIPTION("low-level driver for generic ATA");
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(pci, ata_generic);
+MODULE_VERSION(DRV_VERSION);
+
+module_init(ata_generic_init);
+module_exit(ata_generic_exit);
+
+module_param(all_generic_ide, int, 0);
