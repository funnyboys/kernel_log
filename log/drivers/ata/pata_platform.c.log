commit baac9ce1f333260485e9084809e909d3ce6c69dd
Author: Alexander Shiyan <shc_work@mail.ru>
Date:   Sat Jan 19 07:52:02 2019 +0300

    ata: pata_platform: Add IRQF_SHARED to IRQ flags
    
    It's quite possible that multiple devices can be hooked up
    to the same interrupt line with the processor. So add IRQF_SHARED
    in request irq.
    
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Alexander Shiyan <shc_work@mail.ru>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 31cd0f39b0a7..5aba691f09af 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -114,7 +114,7 @@ int __pata_platform_probe(struct device *dev, struct resource *io_res,
 	 */
 	if (irq_res && irq_res->start > 0) {
 		irq = irq_res->start;
-		irq_flags = irq_res->flags & IRQF_TRIGGER_MASK;
+		irq_flags = (irq_res->flags & IRQF_TRIGGER_MASK) | IRQF_SHARED;
 	}
 
 	/*

commit f3d5e4f18dba18d7c2303dda68b9dbcf5ccc05cd
Author: Alexander Shiyan <shc_work@mail.ru>
Date:   Sat Jan 19 07:52:01 2019 +0300

    ata: pata_of_platform: Allow to use 16-bit wide data transfer
    
    In some cases, the system bus can be configured for 16-bit mode,
    in this case using read/write functions for 32-bit values
    results in two cycles of 16 bits each, which is wrong.
    This patch adds the devicetree flag to switch the driver to
    use 16-bit mode for I/O transfers.
    
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Alexander Shiyan <shc_work@mail.ru>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index d6f8f5406442..31cd0f39b0a7 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -47,13 +47,6 @@ static struct scsi_host_template pata_platform_sht = {
 	ATA_PIO_SHT(DRV_NAME),
 };
 
-static struct ata_port_operations pata_platform_port_ops = {
-	.inherits		= &ata_sff_port_ops,
-	.sff_data_xfer		= ata_sff_data_xfer32,
-	.cable_detect		= ata_cable_unknown,
-	.set_mode		= pata_platform_set_mode,
-};
-
 static void pata_platform_setup_port(struct ata_ioports *ioaddr,
 				     unsigned int shift)
 {
@@ -79,6 +72,7 @@ static void pata_platform_setup_port(struct ata_ioports *ioaddr,
  *	@ioport_shift: I/O port shift
  *	@__pio_mask: PIO mask
  *	@sht: scsi_host_template to use when registering
+ *	@use16bit: Flag to indicate 16-bit IO instead of 32-bit
  *
  *	Register a platform bus IDE interface. Such interfaces are PIO and we
  *	assume do not support IRQ sharing.
@@ -101,7 +95,7 @@ static void pata_platform_setup_port(struct ata_ioports *ioaddr,
 int __pata_platform_probe(struct device *dev, struct resource *io_res,
 			  struct resource *ctl_res, struct resource *irq_res,
 			  unsigned int ioport_shift, int __pio_mask,
-			  struct scsi_host_template *sht)
+			  struct scsi_host_template *sht, bool use16bit)
 {
 	struct ata_host *host;
 	struct ata_port *ap;
@@ -131,7 +125,15 @@ int __pata_platform_probe(struct device *dev, struct resource *io_res,
 		return -ENOMEM;
 	ap = host->ports[0];
 
-	ap->ops = &pata_platform_port_ops;
+	ap->ops = devm_kzalloc(dev, sizeof(*ap->ops), GFP_KERNEL);
+	ap->ops->inherits = &ata_sff_port_ops;
+	ap->ops->cable_detect = ata_cable_unknown;
+	ap->ops->set_mode = pata_platform_set_mode;
+	if (use16bit)
+		ap->ops->sff_data_xfer = ata_sff_data_xfer;
+	else
+		ap->ops->sff_data_xfer = ata_sff_data_xfer32;
+
 	ap->pio_mask = __pio_mask;
 	ap->flags |= ATA_FLAG_SLAVE_POSS;
 
@@ -218,7 +220,7 @@ static int pata_platform_probe(struct platform_device *pdev)
 
 	return __pata_platform_probe(&pdev->dev, io_res, ctl_res, irq_res,
 				     pp_info ? pp_info->ioport_shift : 0,
-				     pio_mask, &pata_platform_sht);
+				     pio_mask, &pata_platform_sht, false);
 }
 
 static struct platform_driver pata_platform_driver = {

commit 23ebda2fc715534d383d59ae6740d4e3ebd43798
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed Jul 11 17:21:05 2018 +0200

    libata: remove ata_sff_data_xfer_noirq()
    
    ata_sff_data_xfer_noirq() is invoked via the ->sff_data_xfer hook. The
    latter is invoked by ata_pio_sector(), atapi_send_cdb() and
    __atapi_pio_bytes() which in turn is invoked by ata_sff_hsm_move().
    The latter function requires that the "ap->lock" lock is held which
    needs to be taken with disabled interrupts.
    
    There is no need have to have ata_sff_data_xfer_noirq() which invokes
    ata_sff_data_xfer32() with disabled interrupts because at this point the
    interrupts are already disabled.
    Remove the function and its references to it and replace all callers
    with ata_sff_data_xfer32().
    
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index c503ded87bb8..d6f8f5406442 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -49,7 +49,7 @@ static struct scsi_host_template pata_platform_sht = {
 
 static struct ata_port_operations pata_platform_port_ops = {
 	.inherits		= &ata_sff_port_ops,
-	.sff_data_xfer		= ata_sff_data_xfer_noirq,
+	.sff_data_xfer		= ata_sff_data_xfer32,
 	.cable_detect		= ata_cable_unknown,
 	.set_mode		= pata_platform_set_mode,
 };

commit 17263905399471016cda6c1975044d14291c5ba5
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Thu Jan 29 08:30:30 2015 +0900

    ata: pata_platform: fix owner module reference mismatch for scsi host
    
    The owner module reference of the pata_of_platform's scsi_host is
    initialized to pata_platform's one, because pata_of_platform driver
    use a scsi_host_template defined in pata_platform.  So this drivers
    can be unloaded even if the scsi device is being accessed.
    
    This fixes it by propagating the scsi_host_template to pata_of_platform
    driver.  The scsi_host_template is passed through a new
    argument of __pata_platform_probe().
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Cc: linux-ide@vger.kernel.org
    Cc: linux-scsi@vger.kernel.org

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 1eedfe46d7c8..c503ded87bb8 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -78,6 +78,7 @@ static void pata_platform_setup_port(struct ata_ioports *ioaddr,
  *	@irq_res: Resource representing IRQ and its flags
  *	@ioport_shift: I/O port shift
  *	@__pio_mask: PIO mask
+ *	@sht: scsi_host_template to use when registering
  *
  *	Register a platform bus IDE interface. Such interfaces are PIO and we
  *	assume do not support IRQ sharing.
@@ -99,7 +100,8 @@ static void pata_platform_setup_port(struct ata_ioports *ioaddr,
  */
 int __pata_platform_probe(struct device *dev, struct resource *io_res,
 			  struct resource *ctl_res, struct resource *irq_res,
-			  unsigned int ioport_shift, int __pio_mask)
+			  unsigned int ioport_shift, int __pio_mask,
+			  struct scsi_host_template *sht)
 {
 	struct ata_host *host;
 	struct ata_port *ap;
@@ -170,7 +172,7 @@ int __pata_platform_probe(struct device *dev, struct resource *io_res,
 
 	/* activate */
 	return ata_host_activate(host, irq, irq ? ata_sff_interrupt : NULL,
-				 irq_flags, &pata_platform_sht);
+				 irq_flags, sht);
 }
 EXPORT_SYMBOL_GPL(__pata_platform_probe);
 
@@ -216,7 +218,7 @@ static int pata_platform_probe(struct platform_device *pdev)
 
 	return __pata_platform_probe(&pdev->dev, io_res, ctl_res, irq_res,
 				     pp_info ? pp_info->ioport_shift : 0,
-				     pio_mask);
+				     pio_mask, &pata_platform_sht);
 }
 
 static struct platform_driver pata_platform_driver = {

commit 65c662ab63d2055d883bc97386aa779cbbb81f93
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:17 2014 +0200

    ata: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index f8cff3e247c5..1eedfe46d7c8 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -224,7 +224,6 @@ static struct platform_driver pata_platform_driver = {
 	.remove		= ata_platform_remove_one,
 	.driver = {
 		.name		= DRV_NAME,
-		.owner		= THIS_MODULE,
 	},
 };
 

commit 53f3cc46336b9e514c98556b4a009a69ed808d3b
Author: Alexander Shiyan <shc_work@mail.ru>
Date:   Sat Aug 23 14:45:47 2014 +0400

    pata_platform: Remove useless irq_flags field
    
    IRQ flags can be obtained from resource structure, there are no need
    to use additional field in the platform_data to store these values.
    This patch removes this field and convert existing users of this driver
    to use IRQ flags from the resources.
    
    Signed-off-by: Alexander Shiyan <shc_work@mail.ru>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index a5579b55e332..f8cff3e247c5 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -118,7 +118,7 @@ int __pata_platform_probe(struct device *dev, struct resource *io_res,
 	 */
 	if (irq_res && irq_res->start > 0) {
 		irq = irq_res->start;
-		irq_flags = irq_res->flags;
+		irq_flags = irq_res->flags & IRQF_TRIGGER_MASK;
 	}
 
 	/*
@@ -213,8 +213,6 @@ static int pata_platform_probe(struct platform_device *pdev)
 	 * And the IRQ
 	 */
 	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if (irq_res)
-		irq_res->flags = pp_info ? pp_info->irq_flags : 0;
 
 	return __pata_platform_probe(&pdev->dev, io_res, ctl_res, irq_res,
 				     pp_info ? pp_info->ioport_shift : 0,

commit 1bc18086231c130895b87ec049be8ddcdab552b8
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Jan 21 16:22:51 2014 -0500

    ata: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Cc: linux-ide@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 02794885de10..a5579b55e332 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -13,7 +13,6 @@
  */
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/init.h>
 #include <linux/blkdev.h>
 #include <scsi/scsi_host.h>
 #include <linux/ata.h>

commit 61b8c345aa8c50c6a99a90560a107d02124f0293
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Jul 30 17:16:05 2013 +0900

    ata: use dev_get_platdata()
    
    Use the wrapper function for retrieving the platform data instead of
    accessing dev->platform_data directly.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 71e093767f4e..02794885de10 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -180,7 +180,7 @@ static int pata_platform_probe(struct platform_device *pdev)
 	struct resource *io_res;
 	struct resource *ctl_res;
 	struct resource *irq_res;
-	struct pata_platform_info *pp_info = pdev->dev.platform_data;
+	struct pata_platform_info *pp_info = dev_get_platdata(&pdev->dev);
 
 	/*
 	 * Simple resource validation ..

commit 0ec24914675c48213378da550db494bf154f0f6c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:19:58 2012 -0800

    Drivers: ata: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Cc: Viresh Kumar <viresh.linux@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index f4372d0c7ce6..71e093767f4e 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -98,12 +98,9 @@ static void pata_platform_setup_port(struct ata_ioports *ioaddr,
  *
  *	If no IRQ resource is present, PIO polling mode is used instead.
  */
-int __devinit __pata_platform_probe(struct device *dev,
-				    struct resource *io_res,
-				    struct resource *ctl_res,
-				    struct resource *irq_res,
-				    unsigned int ioport_shift,
-				    int __pio_mask)
+int __pata_platform_probe(struct device *dev, struct resource *io_res,
+			  struct resource *ctl_res, struct resource *irq_res,
+			  unsigned int ioport_shift, int __pio_mask)
 {
 	struct ata_host *host;
 	struct ata_port *ap;
@@ -178,7 +175,7 @@ int __devinit __pata_platform_probe(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(__pata_platform_probe);
 
-static int __devinit pata_platform_probe(struct platform_device *pdev)
+static int pata_platform_probe(struct platform_device *pdev)
 {
 	struct resource *io_res;
 	struct resource *ctl_res;

commit 156f34d26a74c6ea060fb43d898f17509ed8e18a
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Nov 2 00:46:24 2012 -0700

    pata_platform: remove unused remove function
    
    All users of __pata_platform_remove() have been converted to utilize the
    common ata_platform_remove_one().
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 449aa29931bc..f4372d0c7ce6 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -178,23 +178,6 @@ int __devinit __pata_platform_probe(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(__pata_platform_probe);
 
-/**
- *	__pata_platform_remove		-	unplug a platform interface
- *	@dev: device
- *
- *	A platform bus ATA device has been unplugged. Perform the needed
- *	cleanup. Also called on module unload for any active devices.
- */
-int __pata_platform_remove(struct device *dev)
-{
-	struct ata_host *host = dev_get_drvdata(dev);
-
-	ata_host_detach(host);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(__pata_platform_remove);
-
 static int __devinit pata_platform_probe(struct platform_device *pdev)
 {
 	struct resource *io_res;

commit ccd1196a924a0fd64132297a121794c347f52d3a
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Nov 2 00:46:23 2012 -0700

    pata_platform: utilize common ata_platform_remove_one()
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index f1848aeda783..449aa29931bc 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -242,14 +242,9 @@ static int __devinit pata_platform_probe(struct platform_device *pdev)
 				     pio_mask);
 }
 
-static int __devexit pata_platform_remove(struct platform_device *pdev)
-{
-	return __pata_platform_remove(&pdev->dev);
-}
-
 static struct platform_driver pata_platform_driver = {
 	.probe		= pata_platform_probe,
-	.remove		= __devexit_p(pata_platform_remove),
+	.remove		= ata_platform_remove_one,
 	.driver = {
 		.name		= DRV_NAME,
 		.owner		= THIS_MODULE,

commit 99c8ea3e57e7b5551ffd9cd401c4bf302b5664e3
Author: Axel Lin <axel.lin@gmail.com>
Date:   Sun Nov 27 14:44:26 2011 +0800

    SATA/PATA: convert drivers/ata/* to use module_platform_driver()
    
    This patch converts the drivers in drivers/ata/* to use the
    module_platform_driver() macro which makes the code smaller and a bit
    simpler.
    
    Cc: Viresh Kumar <viresh.kumar@st.com>
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Cc: Arnaud Patard <arnaud.patard@rtp-net.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Sylvain Munaut <tnt@246tNt.com>
    Cc: Anton Vorontsov <avorontsov@ru.mvista.com>
    Cc: Marek Vasut <marek.vasut@gmail.com>
    Cc: Florian Fainelli <florian@openwrt.org>
    Cc: Mark Miesfeld <mmiesfeld@amcc.com>
    Cc: Ashish Kalra <ashish.kalra@freescale.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 2067308f683f..f1848aeda783 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -256,17 +256,7 @@ static struct platform_driver pata_platform_driver = {
 	},
 };
 
-static int __init pata_platform_init(void)
-{
-	return platform_driver_register(&pata_platform_driver);
-}
-
-static void __exit pata_platform_exit(void)
-{
-	platform_driver_unregister(&pata_platform_driver);
-}
-module_init(pata_platform_init);
-module_exit(pata_platform_exit);
+module_platform_driver(pata_platform_driver);
 
 module_param(pio_mask, int, 0);
 

commit a9a79dfec239568bdbf778242f8fcd10bcc5b9e2
Author: Joe Perches <joe@perches.com>
Date:   Fri Apr 15 15:51:59 2011 -0700

    ata: Convert ata_<foo>_printk(KERN_<LEVEL> to ata_<foo>_<level>
    
    Saves text by removing nearly duplicated text format strings by
    creating ata_<foo>_printk functions and printf extension %pV.
    
    ata defconfig size shrinks ~5% (~8KB), allyesconfig ~2.5% (~13KB)
    
    Format string duplication comes from:
    
     #define ata_link_printk(link, lv, fmt, args...) do { \
           if (sata_pmp_attached((link)->ap) || (link)->ap->slave_link)    \
                   printk("%sata%u.%02u: "fmt, lv, (link)->ap->print_id,   \
                          (link)->pmp , ##args); \
           else \
                   printk("%sata%u: "fmt, lv, (link)->ap->print_id , ##args); \
           } while(0)
    
    Coalesce long formats.
    
    $ size drivers/ata/built-in.*
       text    data     bss     dec     hex filename
     544969   73893  116584  735446   b38d6 drivers/ata/built-in.allyesconfig.ata.o
     558429   73893  117864  750186   b726a drivers/ata/built-in.allyesconfig.dev_level.o
     141328   14689    4220  160237   271ed drivers/ata/built-in.defconfig.ata.o
     149567   14689    4220  168476   2921c drivers/ata/built-in.defconfig.dev_level.o
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 50400fa120fe..2067308f683f 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -39,7 +39,7 @@ static int pata_platform_set_mode(struct ata_link *link, struct ata_device **unu
 		dev->pio_mode = dev->xfer_mode = XFER_PIO_0;
 		dev->xfer_shift = ATA_SHIFT_PIO;
 		dev->flags |= ATA_DFLAG_PIO;
-		ata_dev_printk(dev, KERN_INFO, "configured for PIO\n");
+		ata_dev_info(dev, "configured for PIO\n");
 	}
 	return 0;
 }

commit c7087652e1890a3feef35b30ee1d4be68e1932cd
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 10 21:41:34 2010 +0200

    libata-sff: clean up BMDMA initialization
    
    When BMDMA initialization failed or BMDMA was not available for
    whatever reason, bmdma_addr was left at zero and used as an indication
    that BMDMA shouldn't be used.  This leads to the following problems.
    
    p1. For BMDMA drivers which don't use traditional BMDMA register,
        ata_bmdma_mode_filter() incorrectly inhibits DMA modes.  Those
        drivers either have to inherit from ata_sff_port_ops or clear
        ->mode_filter explicitly.
    
    p2. non-BMDMA drivers call into BMDMA PRD table allocation.  It
        doesn't actually allocate PRD table if bmdma_addr is not
        initialized but is still confusing.
    
    p3. For BMDMA drivers which don't use traditional BMDMA register, some
        methods might not be invoked as expected (e.g. bmdma_stop from
        ata_sff_post_internal_cmd()).
    
    p4. SFF drivers w/ custom DMA interface implement noop BMDMA ops
        worrying libata core might call into one of them.
    
    These problems are caused by the muddy line between SFF and BMDMA and
    the assumption that all BMDMA controllers initialize bmdma_addr.
    
    This patch fixes p1 and p2 by removing the bmdma_addr assumption and
    moving prd allocation to BMDMA port start.  Later patches will fix the
    remaining issues.
    
    This patch improves BMDMA initialization such that
    
    * When BMDMA register initialization fails, falls back to PIO instead
      of failing.  ata_pci_bmdma_init() never fails now.
    
    * When ata_pci_bmdma_init() falls back to PIO, it clears
      ap->mwdma_mask and udma_mask instead of depending on
      ata_bmdma_mode_filter().  This makes ata_bmdma_mode_filter()
      unnecessary thus resolving p1.
    
    * ata_port_start() which actually is BMDMA specific is moved to
      ata_bmdma_port_start().  ata_port_start() and ata_sff_port_start()
      are killed.
    
    * ata_sff_port_start32() is moved and renamed to
      ata_bmdma_port_start32().
    
    Drivers which no longer call into PRD table allocation are...
    
      pdc_adma, sata_inic162x, sata_qstor, sata_sx4, pata_cmd640 and all
      drivers which inherit from ata_sff_port_ops.
    
    pata_icside sets ->port_start to ATA_OP_NULL as it doesn't need PRD
    but is a BMDMA controller and doesn't have custom port_start like
    other such controllers.
    
    Note that with the previous patch which makes all and only BMDMA
    drivers inherit from ata_bmdma_port_ops, this change doesn't break
    drivers which need PRD table.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 3f6ebc6c665a..50400fa120fe 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -53,7 +53,6 @@ static struct ata_port_operations pata_platform_port_ops = {
 	.sff_data_xfer		= ata_sff_data_xfer_noirq,
 	.cable_detect		= ata_cable_unknown,
 	.set_mode		= pata_platform_set_mode,
-	.port_start		= ATA_OP_NULL,
 };
 
 static void pata_platform_setup_port(struct ata_ioports *ioaddr,

commit 041b5eac254107cd3ba60034c38a411531cc64ee
Author: Julia Lawall <julia@diku.dk>
Date:   Thu Aug 6 16:05:08 2009 -0700

    drivers/ata: use resource_size
    
    Use the function resource_size, which reduces the chance of introducing
    off-by-one errors in calculating the resource size.
    
    The semantic patch that makes this change is as follows:
    (http://www.emn.fr/x-info/coccinelle/)
    
    // <smpl>
    @@
    struct resource *res;
    @@
    
    - (res->end - res->start) + 1
    + resource_size(res)
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index d8d743af3225..3f6ebc6c665a 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -151,14 +151,14 @@ int __devinit __pata_platform_probe(struct device *dev,
 	 */
 	if (mmio) {
 		ap->ioaddr.cmd_addr = devm_ioremap(dev, io_res->start,
-				io_res->end - io_res->start + 1);
+				resource_size(io_res));
 		ap->ioaddr.ctl_addr = devm_ioremap(dev, ctl_res->start,
-				ctl_res->end - ctl_res->start + 1);
+				resource_size(ctl_res));
 	} else {
 		ap->ioaddr.cmd_addr = devm_ioport_map(dev, io_res->start,
-				io_res->end - io_res->start + 1);
+				resource_size(io_res));
 		ap->ioaddr.ctl_addr = devm_ioport_map(dev, ctl_res->start,
-				ctl_res->end - ctl_res->start + 1);
+				resource_size(ctl_res));
 	}
 	if (!ap->ioaddr.cmd_addr || !ap->ioaddr.ctl_addr) {
 		dev_err(dev, "failed to map IO/CTL base\n");

commit 78a7ba47fbc34a387e6347179ba571236596efbb
Author: Sonic Zhang <sonic.zhang@analog.com>
Date:   Thu Jan 8 00:37:12 2009 +0800

    pata_platform: __pata_platform_remove() shouldn't be in discard section
    
    --
      UPD     include/linux/compile.h
    `___pata_platform_remove' referenced in section `__ksymtab_gpl' of
    drivers/built-in.o: defined in discarded section `.devexit.text' of
    drivers/built-in.o
    make: *** [.tmp_vmlinux1] Error 1
    --
    
    __pata_platform_remove() should not be in discarded section
    __pata_platform_remove(struct device *dev) is invoked in both
    pata_platform.c and pata_of_platform.c by reomve function defined in
    discarded section ".devexit.text". An exported function should not be put
    into discarded section.
    
    Signed-off-by: Sonic Zhang <sonic.zhang@analog.com>
    Signed-off-by: Bryan Wu <cooloney@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 6afa07a37648..d8d743af3225 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -186,7 +186,7 @@ EXPORT_SYMBOL_GPL(__pata_platform_probe);
  *	A platform bus ATA device has been unplugged. Perform the needed
  *	cleanup. Also called on module unload for any active devices.
  */
-int __devexit __pata_platform_remove(struct device *dev)
+int __pata_platform_remove(struct device *dev)
 {
 	struct ata_host *host = dev_get_drvdata(dev);
 

commit 1eca4365be25c540650693e941bc06a66cf38f94
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Nov 3 20:03:17 2008 +0900

    libata: beef up iterators
    
    There currently are the following looping constructs.
    
    * __ata_port_for_each_link() for all available links
    * ata_port_for_each_link() for edge links
    * ata_link_for_each_dev() for all devices
    * ata_link_for_each_dev_reverse() for all devices in reverse order
    
    Now there's a need for looping construct which is similar to
    __ata_port_for_each_link() but iterates over PMP links before the host
    link.  Instead of adding another one with long name, do the following
    cleanup.
    
    * Implement and export ata_link_next() and ata_dev_next() which take
      @mode parameter and can be used to build custom loop.
    * Implement ata_for_each_link() and ata_for_each_dev() which take
      looping mode explicitly.
    
    The following iteration modes are implemented.
    
    * ATA_LITER_EDGE                : loop over edge links
    * ATA_LITER_HOST_FIRST          : loop over all links, host link first
    * ATA_LITER_PMP_FIRST           : loop over all links, PMP links first
    
    * ATA_DITER_ENABLED             : loop over enabled devices
    * ATA_DITER_ENABLED_REVERSE     : loop over enabled devices in reverse order
    * ATA_DITER_ALL                 : loop over all devices
    * ATA_DITER_ALL_REVERSE         : loop over all devices in reverse order
    
    This change removes exlicit device enabledness checks from many loops
    and makes it clear which ones are iterated over in which direction.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 77e4e3b17f54..6afa07a37648 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -34,14 +34,12 @@ static int pata_platform_set_mode(struct ata_link *link, struct ata_device **unu
 {
 	struct ata_device *dev;
 
-	ata_link_for_each_dev(dev, link) {
-		if (ata_dev_enabled(dev)) {
-			/* We don't really care */
-			dev->pio_mode = dev->xfer_mode = XFER_PIO_0;
-			dev->xfer_shift = ATA_SHIFT_PIO;
-			dev->flags |= ATA_DFLAG_PIO;
-			ata_dev_printk(dev, KERN_INFO, "configured for PIO\n");
-		}
+	ata_for_each_dev(dev, link, ENABLED) {
+		/* We don't really care */
+		dev->pio_mode = dev->xfer_mode = XFER_PIO_0;
+		dev->xfer_shift = ATA_SHIFT_PIO;
+		dev->flags |= ATA_DFLAG_PIO;
+		ata_dev_printk(dev, KERN_INFO, "configured for PIO\n");
 	}
 	return 0;
 }

commit ab77163008c596aad9624ceab190d840c0143fa8
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Oct 27 15:09:10 2008 +0000

    ata: Switch all my stuff to a common address
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 8f65ad61b8af..77e4e3b17f54 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -5,7 +5,7 @@
  *
  * Based on pata_pcmcia:
  *
- *   Copyright 2005-2006 Red Hat Inc <alan@redhat.com>, all rights reserved.
+ *   Copyright 2005-2006 Red Hat Inc, all rights reserved.
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive

commit 458622fcdc5b316de8d74efd7e610803f0308c14
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri Apr 18 13:41:57 2008 -0700

    ATA/IDE: fix platform driver hotplug/coldplug
    
    Since 43cc71eed1250755986da4c0f9898f9a635cb3bf, the platform modalias
    is prefixed with "platform:".  Add MODULE_ALIAS() to the hotpluggable
    ATA and IDE platform drivers, to re-enable auto loading.
    
    NOTE: both ata/pata_platform.c and ide/legacy/ide_platform.c claim
    to provide "the" platform_pata driver, and there's no build-time
    mutual exclusion mechanism.  This means that configs which enable
    both drivers will make some trouble when hotplugging...
    
    [dbrownell@users.sourceforge.net: more drivers, registration fixes]
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Tejun Heo <htejun@gmail.com>
    Acked-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 6527c56c34a3..8f65ad61b8af 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -277,3 +277,4 @@ MODULE_AUTHOR("Paul Mundt");
 MODULE_DESCRIPTION("low-level driver for platform device ATA");
 MODULE_LICENSE("GPL");
 MODULE_VERSION(DRV_VERSION);
+MODULE_ALIAS("platform:" DRV_NAME);

commit 5682ed33aae05d10a25c95633ef9d9c062825888
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:16 2008 +0900

    libata: rename SFF port ops
    
    Add sff_ prefix to SFF specific port ops.
    
    This rename is in preparation of separating SFF support out of libata
    core layer.  This patch strictly renames ops and doesn't introduce any
    behavior difference.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 1edfc13d05d2..6527c56c34a3 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -52,7 +52,7 @@ static struct scsi_host_template pata_platform_sht = {
 
 static struct ata_port_operations pata_platform_port_ops = {
 	.inherits		= &ata_sff_port_ops,
-	.data_xfer		= ata_sff_data_xfer_noirq,
+	.sff_data_xfer		= ata_sff_data_xfer_noirq,
 	.cable_detect		= ata_cable_unknown,
 	.set_mode		= pata_platform_set_mode,
 	.port_start		= ATA_OP_NULL,

commit 9363c3825ea9ad76561eb48a395349dd29211ed6
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:16 2008 +0900

    libata: rename SFF functions
    
    SFF functions have confusing names.  Some have sff prefix, some have
    bmdma, some std, some pci and some none.  Unify the naming by...
    
    * SFF functions which are common to both BMDMA and non-BMDMA are
      prefixed with ata_sff_.
    
    * SFF functions which are specific to BMDMA are prefixed with
      ata_bmdma_.
    
    * SFF functions which are specific to PCI but apply to both BMDMA and
      non-BMDMA are prefixed with ata_pci_sff_.
    
    * SFF functions which are specific to PCI and BMDMA are prefixed with
      ata_pci_bmdma_.
    
    * Drop generic prefixes from LLD specific routines.  For example,
      bfin_std_dev_select -> bfin_dev_select.
    
    The following renames are noteworthy.
    
      ata_qc_issue_prot() -> ata_sff_qc_issue()
      ata_pci_default_filter() -> ata_bmdma_mode_filter()
      ata_dev_try_classify() -> ata_sff_dev_classify()
    
    This rename is in preparation of separating SFF support out of libata
    core layer.  This patch strictly renames functions and doesn't
    introduce any behavior difference.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 0588c9b7e73e..1edfc13d05d2 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -52,7 +52,7 @@ static struct scsi_host_template pata_platform_sht = {
 
 static struct ata_port_operations pata_platform_port_ops = {
 	.inherits		= &ata_sff_port_ops,
-	.data_xfer		= ata_data_xfer_noirq,
+	.data_xfer		= ata_sff_data_xfer_noirq,
 	.cable_detect		= ata_cable_unknown,
 	.set_mode		= pata_platform_set_mode,
 	.port_start		= ATA_OP_NULL,
@@ -176,7 +176,7 @@ int __devinit __pata_platform_probe(struct device *dev,
 		      (unsigned long long)ctl_res->start);
 
 	/* activate */
-	return ata_host_activate(host, irq, irq ? ata_interrupt : NULL,
+	return ata_host_activate(host, irq, irq ? ata_sff_interrupt : NULL,
 				 irq_flags, &pata_platform_sht);
 }
 EXPORT_SYMBOL_GPL(__pata_platform_probe);

commit 029cfd6b74fc5c517865fad78cf4a3ea8d9b664a
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:49 2008 +0900

    libata: implement and use ops inheritance
    
    libata lets low level drivers build ata_port_operations table and
    register it with libata core layer.  This allows low level drivers
    high level of flexibility but also burdens them with lots of
    boilerplate entries.
    
    This becomes worse for drivers which support related similar
    controllers which differ slightly.  They share most of the operations
    except for a few.  However, the driver still needs to list all
    operations for each variant.  This results in large number of
    duplicate entries, which is not only inefficient but also error-prone
    as it becomes very difficult to tell what the actual differences are.
    
    This duplicate boilerplates all over the low level drivers also make
    updating the core layer exteremely difficult and error-prone.  When
    compounded with multi-branched development model, it ends up
    accumulating inconsistencies over time.  Some of those inconsistencies
    cause immediate problems and fixed.  Others just remain there dormant
    making maintenance increasingly difficult.
    
    To rectify the problem, this patch implements ata_port_operations
    inheritance.  To allow LLDs to easily re-use their own ops tables
    overriding only specific methods, this patch implements poor man's
    class inheritance.  An ops table has ->inherits field which can be set
    to any ops table as long as it doesn't create a loop.  When the host
    is started, the inheritance chain is followed and any operation which
    isn't specified is taken from the nearest ancestor which has it
    specified.  This operation is called finalization and done only once
    per an ops table and the LLD doesn't have to do anything special about
    it other than making the ops table non-const such that libata can
    update it.
    
    libata provides four base ops tables lower drivers can inherit from -
    base, sata, pmp, sff and bmdma.  To avoid overriding these ops
    accidentaly, these ops are declared const and LLDs should always
    inherit these instead of using them directly.
    
    After finalization, all the ops table are identical before and after
    the patch except for setting .irq_handler to ata_interrupt in drivers
    which didn't use to.  The .irq_handler doesn't have any actual effect
    and the field will soon be removed by later patch.
    
    * sata_sx4 is still using old style EH and currently doesn't take
      advantage of ops inheritance.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index cd2d03a4591a..0588c9b7e73e 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -51,27 +51,11 @@ static struct scsi_host_template pata_platform_sht = {
 };
 
 static struct ata_port_operations pata_platform_port_ops = {
-	.set_mode		= pata_platform_set_mode,
-
-	.tf_load		= ata_tf_load,
-	.tf_read		= ata_tf_read,
-	.check_status		= ata_check_status,
-	.exec_command		= ata_exec_command,
-	.dev_select		= ata_std_dev_select,
-
-	.freeze			= ata_bmdma_freeze,
-	.thaw			= ata_bmdma_thaw,
-	.error_handler		= ata_bmdma_error_handler,
-	.post_internal_cmd	= ata_bmdma_post_internal_cmd,
-	.cable_detect		= ata_cable_unknown,
-
-	.qc_prep		= ata_qc_prep,
-	.qc_issue		= ata_qc_issue_prot,
-
+	.inherits		= &ata_sff_port_ops,
 	.data_xfer		= ata_data_xfer_noirq,
-
-	.irq_clear		= ata_noop_irq_clear,
-	.irq_on			= ata_irq_on,
+	.cable_detect		= ata_cable_unknown,
+	.set_mode		= pata_platform_set_mode,
+	.port_start		= ATA_OP_NULL,
 };
 
 static void pata_platform_setup_port(struct ata_ioports *ioaddr,

commit 68d1d07b510bb57a504588adc2bd2758adea0965
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:49 2008 +0900

    libata: implement and use SHT initializers
    
    libata lets low level drivers build scsi_host_template and register it
    to the SCSI layer.  This allows low level drivers high level of
    flexibility but also burdens them with lots of boilerplate entries.
    
    This patch implements SHT initializers which can be used to initialize
    all the boilerplate entries in a sht.  Three variants of them are
    implemented - BASE, BMDMA and NCQ - for different types of drivers.
    Note that entries can be overriden by putting individual initializers
    after the helper macro.
    
    All sht tables are identical before and after this patch.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 602f5562d6fb..cd2d03a4591a 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -47,21 +47,7 @@ static int pata_platform_set_mode(struct ata_link *link, struct ata_device **unu
 }
 
 static struct scsi_host_template pata_platform_sht = {
-	.module			= THIS_MODULE,
-	.name			= DRV_NAME,
-	.ioctl			= ata_scsi_ioctl,
-	.queuecommand		= ata_scsi_queuecmd,
-	.can_queue		= ATA_DEF_QUEUE,
-	.this_id		= ATA_SHT_THIS_ID,
-	.sg_tablesize		= LIBATA_MAX_PRD,
-	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
-	.emulated		= ATA_SHT_EMULATED,
-	.use_clustering		= ATA_SHT_USE_CLUSTERING,
-	.proc_name		= DRV_NAME,
-	.dma_boundary		= ATA_DMA_BOUNDARY,
-	.slave_configure	= ata_scsi_slave_config,
-	.slave_destroy		= ata_scsi_slave_destroy,
-	.bios_param		= ata_std_bios_param,
+	ATA_PIO_SHT(DRV_NAME),
 };
 
 static struct ata_port_operations pata_platform_port_ops = {

commit 6bd99b4e0998571808fc1f09d5162348f21ff8c1
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:48 2008 +0900

    libata: normalize port_info, port_operations and sht tables
    
    Over the time, port info, ops and sht structures developed quite a bit
    of inconsistencies.  This patch updates drivers.
    
    * Enable/disable_pm callbacks added to all ahci ops tables.
    
    * Every driver for SFF controllers now uses ata_sff_port_start()
      instead of ata_port_start() unless the driver has custom
      implementation.
    
    * Every driver for SFF controllers now uses ata_pci_default_filter()
      unless the driver has custom implementation.
    
    * Removed an odd port_info->sht initialization from ata_piix.c.
      Likely a merge byproduct.
    
    * A port which has ATA_FLAG_SATA set doesn't need to set cable_detect
      to ata_cable_sata().  Remove it from via and mv port ops.
    
    * Some drivers had unnecessary .max_sectors initialization which is
      ignored and was missing .slave_destroy callback.  Fixed.
    
    * Removed unnecessary sht initializations port_info's.
    
    * Removed onsolete scsi device suspend/resume callbacks from
      pata_bf54x.
    
    * No reason to set ata_pci_default_filter() and bmdma functions for
      PIO-only drivers.  Remove those callbacks and replace
      ata_bmdma_irq_clear with ata_noop_irq_clear.
    
    * pata_platform sets port_start to ata_dummy_ret0.  port_start can
      just be set to NULL.
    
    * sata_fsl supports NCQ but was missing qc_defer.  Fixed.
    
    * pata_rb600_cf implements dummy port_start.  Removed.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index a8429f5c3006..602f5562d6fb 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -46,8 +46,6 @@ static int pata_platform_set_mode(struct ata_link *link, struct ata_device **unu
 	return 0;
 }
 
-static int ata_dummy_ret0(struct ata_port *ap)	{ return 0; }
-
 static struct scsi_host_template pata_platform_sht = {
 	.module			= THIS_MODULE,
 	.name			= DRV_NAME,
@@ -88,8 +86,6 @@ static struct ata_port_operations pata_platform_port_ops = {
 
 	.irq_clear		= ata_noop_irq_clear,
 	.irq_on			= ata_irq_on,
-
-	.port_start		= ata_dummy_ret0,
 };
 
 static void pata_platform_setup_port(struct ata_ioports *ioaddr,

commit 358f9a77a668660729e705fde9c3cf69f013aa98
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:47 2008 +0900

    libata: implement and use ata_noop_irq_clear()
    
    ->irq_clear() is used to clear IRQ bit of a SFF controller and isn't
    useful for drivers which don't use libata SFF HSM implementation.
    However, it's a required callback and many drivers implement their own
    noop version as placeholder.  This patch implements ata_noop_irq_clear
    and use it to replace those custom placeholders.
    
    Also, SFF drivers which don't support BMDMA don't need to use
    ata_bmdma_irq_clear().  It becomes noop if BMDMA address isn't
    initialized.  Convert them to use ata_noop_irq_clear().
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index aad7adc6ea56..a8429f5c3006 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -86,7 +86,7 @@ static struct ata_port_operations pata_platform_port_ops = {
 
 	.data_xfer		= ata_data_xfer_noirq,
 
-	.irq_clear		= ata_bmdma_irq_clear,
+	.irq_clear		= ata_noop_irq_clear,
 	.irq_on			= ata_irq_on,
 
 	.port_start		= ata_dummy_ret0,

commit 0a87e3e92b299e0f1a69b36664ecde2fc296c40a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Feb 1 18:02:30 2008 -0500

    Rename: linux/pata_platform.h to linux/ata_platform.h
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 224bb6c2030a..aad7adc6ea56 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -19,7 +19,7 @@
 #include <linux/ata.h>
 #include <linux/libata.h>
 #include <linux/platform_device.h>
-#include <linux/pata_platform.h>
+#include <linux/ata_platform.h>
 
 #define DRV_NAME "pata_platform"
 #define DRV_VERSION "1.2"

commit cf03613e9662c28372b8c83538fb402df37c53f5
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Wed Jan 9 22:10:22 2008 +0300

    libata: pata_platform: make probe and remove functions device type neutral
    
    Split pata_platform_{probe,remove} into two pieces:
    1. pata_platform_{probe,remove} -- platform_device-dependant bits;
    2. __ptata_platform_{probe,remove} -- device type neutral bits.
    
    This is done to not duplicate code for the OF-platform driver.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Acked-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Olof Johansson <olof@lixom.net>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index ac03a90a6168..224bb6c2030a 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -93,14 +93,9 @@ static struct ata_port_operations pata_platform_port_ops = {
 };
 
 static void pata_platform_setup_port(struct ata_ioports *ioaddr,
-				     struct pata_platform_info *info)
+				     unsigned int shift)
 {
-	unsigned int shift = 0;
-
 	/* Fixup the port shift for platforms that need it */
-	if (info && info->ioport_shift)
-		shift = info->ioport_shift;
-
 	ioaddr->data_addr	= ioaddr->cmd_addr + (ATA_REG_DATA    << shift);
 	ioaddr->error_addr	= ioaddr->cmd_addr + (ATA_REG_ERR     << shift);
 	ioaddr->feature_addr	= ioaddr->cmd_addr + (ATA_REG_FEATURE << shift);
@@ -114,8 +109,13 @@ static void pata_platform_setup_port(struct ata_ioports *ioaddr,
 }
 
 /**
- *	pata_platform_probe		-	attach a platform interface
- *	@pdev: platform device
+ *	__pata_platform_probe		-	attach a platform interface
+ *	@dev: device
+ *	@io_res: Resource representing I/O base
+ *	@ctl_res: Resource representing CTL base
+ *	@irq_res: Resource representing IRQ and its flags
+ *	@ioport_shift: I/O port shift
+ *	@__pio_mask: PIO mask
  *
  *	Register a platform bus IDE interface. Such interfaces are PIO and we
  *	assume do not support IRQ sharing.
@@ -135,42 +135,18 @@ static void pata_platform_setup_port(struct ata_ioports *ioaddr,
  *
  *	If no IRQ resource is present, PIO polling mode is used instead.
  */
-static int __devinit pata_platform_probe(struct platform_device *pdev)
+int __devinit __pata_platform_probe(struct device *dev,
+				    struct resource *io_res,
+				    struct resource *ctl_res,
+				    struct resource *irq_res,
+				    unsigned int ioport_shift,
+				    int __pio_mask)
 {
-	struct resource *io_res, *ctl_res;
 	struct ata_host *host;
 	struct ata_port *ap;
-	struct pata_platform_info *pp_info;
 	unsigned int mmio;
-	int irq;
-
-	/*
-	 * Simple resource validation ..
-	 */
-	if ((pdev->num_resources != 3) && (pdev->num_resources != 2)) {
-		dev_err(&pdev->dev, "invalid number of resources\n");
-		return -EINVAL;
-	}
-
-	/*
-	 * Get the I/O base first
-	 */
-	io_res = platform_get_resource(pdev, IORESOURCE_IO, 0);
-	if (io_res == NULL) {
-		io_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-		if (unlikely(io_res == NULL))
-			return -EINVAL;
-	}
-
-	/*
-	 * Then the CTL base
-	 */
-	ctl_res = platform_get_resource(pdev, IORESOURCE_IO, 1);
-	if (ctl_res == NULL) {
-		ctl_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-		if (unlikely(ctl_res == NULL))
-			return -EINVAL;
-	}
+	int irq = 0;
+	int irq_flags = 0;
 
 	/*
 	 * Check for MMIO
@@ -181,20 +157,21 @@ static int __devinit pata_platform_probe(struct platform_device *pdev)
 	/*
 	 * And the IRQ
 	 */
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0)
-		irq = 0;	/* no irq */
+	if (irq_res && irq_res->start > 0) {
+		irq = irq_res->start;
+		irq_flags = irq_res->flags;
+	}
 
 	/*
 	 * Now that that's out of the way, wire up the port..
 	 */
-	host = ata_host_alloc(&pdev->dev, 1);
+	host = ata_host_alloc(dev, 1);
 	if (!host)
 		return -ENOMEM;
 	ap = host->ports[0];
 
 	ap->ops = &pata_platform_port_ops;
-	ap->pio_mask = pio_mask;
+	ap->pio_mask = __pio_mask;
 	ap->flags |= ATA_FLAG_SLAVE_POSS;
 
 	/*
@@ -209,25 +186,24 @@ static int __devinit pata_platform_probe(struct platform_device *pdev)
 	 * Handle the MMIO case
 	 */
 	if (mmio) {
-		ap->ioaddr.cmd_addr = devm_ioremap(&pdev->dev, io_res->start,
+		ap->ioaddr.cmd_addr = devm_ioremap(dev, io_res->start,
 				io_res->end - io_res->start + 1);
-		ap->ioaddr.ctl_addr = devm_ioremap(&pdev->dev, ctl_res->start,
+		ap->ioaddr.ctl_addr = devm_ioremap(dev, ctl_res->start,
 				ctl_res->end - ctl_res->start + 1);
 	} else {
-		ap->ioaddr.cmd_addr = devm_ioport_map(&pdev->dev, io_res->start,
+		ap->ioaddr.cmd_addr = devm_ioport_map(dev, io_res->start,
 				io_res->end - io_res->start + 1);
-		ap->ioaddr.ctl_addr = devm_ioport_map(&pdev->dev, ctl_res->start,
+		ap->ioaddr.ctl_addr = devm_ioport_map(dev, ctl_res->start,
 				ctl_res->end - ctl_res->start + 1);
 	}
 	if (!ap->ioaddr.cmd_addr || !ap->ioaddr.ctl_addr) {
-		dev_err(&pdev->dev, "failed to map IO/CTL base\n");
+		dev_err(dev, "failed to map IO/CTL base\n");
 		return -ENOMEM;
 	}
 
 	ap->ioaddr.altstatus_addr = ap->ioaddr.ctl_addr;
 
-	pp_info = pdev->dev.platform_data;
-	pata_platform_setup_port(&ap->ioaddr, pp_info);
+	pata_platform_setup_port(&ap->ioaddr, ioport_shift);
 
 	ata_port_desc(ap, "%s cmd 0x%llx ctl 0x%llx", mmio ? "mmio" : "ioport",
 		      (unsigned long long)io_res->start,
@@ -235,26 +211,78 @@ static int __devinit pata_platform_probe(struct platform_device *pdev)
 
 	/* activate */
 	return ata_host_activate(host, irq, irq ? ata_interrupt : NULL,
-				 pp_info ? pp_info->irq_flags : 0,
-				 &pata_platform_sht);
+				 irq_flags, &pata_platform_sht);
 }
+EXPORT_SYMBOL_GPL(__pata_platform_probe);
 
 /**
- *	pata_platform_remove	-	unplug a platform interface
- *	@pdev: platform device
+ *	__pata_platform_remove		-	unplug a platform interface
+ *	@dev: device
  *
  *	A platform bus ATA device has been unplugged. Perform the needed
  *	cleanup. Also called on module unload for any active devices.
  */
-static int __devexit pata_platform_remove(struct platform_device *pdev)
+int __devexit __pata_platform_remove(struct device *dev)
 {
-	struct device *dev = &pdev->dev;
 	struct ata_host *host = dev_get_drvdata(dev);
 
 	ata_host_detach(host);
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(__pata_platform_remove);
+
+static int __devinit pata_platform_probe(struct platform_device *pdev)
+{
+	struct resource *io_res;
+	struct resource *ctl_res;
+	struct resource *irq_res;
+	struct pata_platform_info *pp_info = pdev->dev.platform_data;
+
+	/*
+	 * Simple resource validation ..
+	 */
+	if ((pdev->num_resources != 3) && (pdev->num_resources != 2)) {
+		dev_err(&pdev->dev, "invalid number of resources\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * Get the I/O base first
+	 */
+	io_res = platform_get_resource(pdev, IORESOURCE_IO, 0);
+	if (io_res == NULL) {
+		io_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (unlikely(io_res == NULL))
+			return -EINVAL;
+	}
+
+	/*
+	 * Then the CTL base
+	 */
+	ctl_res = platform_get_resource(pdev, IORESOURCE_IO, 1);
+	if (ctl_res == NULL) {
+		ctl_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+		if (unlikely(ctl_res == NULL))
+			return -EINVAL;
+	}
+
+	/*
+	 * And the IRQ
+	 */
+	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (irq_res)
+		irq_res->flags = pp_info ? pp_info->irq_flags : 0;
+
+	return __pata_platform_probe(&pdev->dev, io_res, ctl_res, irq_res,
+				     pp_info ? pp_info->ioport_shift : 0,
+				     pio_mask);
+}
+
+static int __devexit pata_platform_remove(struct platform_device *pdev)
+{
+	return __pata_platform_remove(&pdev->dev);
+}
 
 static struct platform_driver pata_platform_driver = {
 	.probe		= pata_platform_probe,

commit f7fc0ceb4d72ea5c40d50053b68ebecfbd0cc38c
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Thu Nov 8 11:15:21 2007 +0900

    libata: pata_platform: Support polling-mode configuration.
    
    Some SH boards (old R2D-1 boards) have generally not had working CF
    under libata, due to both buswidth issues (handled by Aoi Shinkai
    in 43f4b8c7578b928892b6f01d374346ae14e5eb70), and buggy interrupt
    controllers. For these sorts of boards simply disabling the IRQ and
    polling ends up working fine.
    
    This conditionalizes the IRQ resource for pata_platform and lets
    platforms that want to use polling mode simply omit the resource
    entirely.
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index fc72a965643d..ac03a90a6168 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -1,7 +1,7 @@
 /*
  * Generic platform device PATA driver
  *
- * Copyright (C) 2006  Paul Mundt
+ * Copyright (C) 2006 - 2007  Paul Mundt
  *
  * Based on pata_pcmcia:
  *
@@ -22,7 +22,7 @@
 #include <linux/pata_platform.h>
 
 #define DRV_NAME "pata_platform"
-#define DRV_VERSION "1.1"
+#define DRV_VERSION "1.2"
 
 static int pio_mask = 1;
 
@@ -120,15 +120,20 @@ static void pata_platform_setup_port(struct ata_ioports *ioaddr,
  *	Register a platform bus IDE interface. Such interfaces are PIO and we
  *	assume do not support IRQ sharing.
  *
- *	Platform devices are expected to contain 3 resources per port:
+ *	Platform devices are expected to contain at least 2 resources per port:
  *
  *		- I/O Base (IORESOURCE_IO or IORESOURCE_MEM)
  *		- CTL Base (IORESOURCE_IO or IORESOURCE_MEM)
+ *
+ *	and optionally:
+ *
  *		- IRQ	   (IORESOURCE_IRQ)
  *
  *	If the base resources are both mem types, the ioremap() is handled
  *	here. For IORESOURCE_IO, it's assumed that there's no remapping
  *	necessary.
+ *
+ *	If no IRQ resource is present, PIO polling mode is used instead.
  */
 static int __devinit pata_platform_probe(struct platform_device *pdev)
 {
@@ -137,11 +142,12 @@ static int __devinit pata_platform_probe(struct platform_device *pdev)
 	struct ata_port *ap;
 	struct pata_platform_info *pp_info;
 	unsigned int mmio;
+	int irq;
 
 	/*
 	 * Simple resource validation ..
 	 */
-	if (unlikely(pdev->num_resources != 3)) {
+	if ((pdev->num_resources != 3) && (pdev->num_resources != 2)) {
 		dev_err(&pdev->dev, "invalid number of resources\n");
 		return -EINVAL;
 	}
@@ -172,6 +178,13 @@ static int __devinit pata_platform_probe(struct platform_device *pdev)
 	mmio = (( io_res->flags == IORESOURCE_MEM) &&
 		(ctl_res->flags == IORESOURCE_MEM));
 
+	/*
+	 * And the IRQ
+	 */
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		irq = 0;	/* no irq */
+
 	/*
 	 * Now that that's out of the way, wire up the port..
 	 */
@@ -184,6 +197,14 @@ static int __devinit pata_platform_probe(struct platform_device *pdev)
 	ap->pio_mask = pio_mask;
 	ap->flags |= ATA_FLAG_SLAVE_POSS;
 
+	/*
+	 * Use polling mode if there's no IRQ
+	 */
+	if (!irq) {
+		ap->flags |= ATA_FLAG_PIO_POLLING;
+		ata_port_desc(ap, "no IRQ, using PIO polling");
+	}
+
 	/*
 	 * Handle the MMIO case
 	 */
@@ -213,9 +234,9 @@ static int __devinit pata_platform_probe(struct platform_device *pdev)
 		      (unsigned long long)ctl_res->start);
 
 	/* activate */
-	return ata_host_activate(host, platform_get_irq(pdev, 0),
-				 ata_interrupt, pp_info ? pp_info->irq_flags
-				 : 0, &pata_platform_sht);
+	return ata_host_activate(host, irq, irq ? ata_interrupt : NULL,
+				 pp_info ? pp_info->irq_flags : 0,
+				 &pata_platform_sht);
 }
 
 /**

commit cbcdd87593a1d85c5c4b259945a3a09eee12814d
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Aug 18 13:14:55 2007 +0900

    libata: implement and use ata_port_desc() to report port configuration
    
    Currently, port configuration reporting has the following problems.
    
    * iomapped address is reported instead of raw address
    * report contains irrelevant fields or lacks necessary fields for
      non-SFF controllers.
    * host->irq/irq2 are there just for reporting and hacky.
    
    This patch implements and uses ata_port_desc() and
    ata_port_pbar_desc().  ata_port_desc() is almost identical to
    ata_ehi_push_desc() except that it takes @ap instead of @ehi, has no
    locking requirement, can only be used during host initialization and "
    " is used as separator instead of ", ".  ata_port_pbar_desc() is a
    helper to ease reporting of a PCI BAR or an offsetted address into it.
    
    LLD pushes whatever description it wants using the above two
    functions.  The accumulated description is printed on host
    registration after "[S/P]ATA max MAX_XFERMODE ".
    
    SFF init helpers and ata_host_activate() automatically add
    descriptions for addresses and irq respectively, so only LLDs which
    isn't standard SFF need to add custom descriptions.  In many cases,
    such controllers need to report different things anyway.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index b04ce5f98410..fc72a965643d 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -208,6 +208,10 @@ static int __devinit pata_platform_probe(struct platform_device *pdev)
 	pp_info = pdev->dev.platform_data;
 	pata_platform_setup_port(&ap->ioaddr, pp_info);
 
+	ata_port_desc(ap, "%s cmd 0x%llx ctl 0x%llx", mmio ? "mmio" : "ioport",
+		      (unsigned long long)io_res->start,
+		      (unsigned long long)ctl_res->start);
+
 	/* activate */
 	return ata_host_activate(host, platform_get_irq(pdev, 0),
 				 ata_interrupt, pp_info ? pp_info->irq_flags

commit ac8869d56d95a8c74403e6f7a47d74fcfcc1b988
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Aug 16 03:17:03 2007 -0400

    [libata] Remove ->port_disable() hook
    
    It was always set to ata_port_disable().  Removed the hook, and replaced
    the very few ap->ops->port_disable() callsites with direct calls to
    ata_port_disable().
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index a616616706da..b04ce5f98410 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -69,7 +69,6 @@ static struct scsi_host_template pata_platform_sht = {
 static struct ata_port_operations pata_platform_port_ops = {
 	.set_mode		= pata_platform_set_mode,
 
-	.port_disable		= ata_port_disable,
 	.tf_load		= ata_tf_load,
 	.tf_read		= ata_tf_read,
 	.check_status		= ata_check_status,

commit 6d32d30f55020d766388df7515f771f68c973033
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Aug 15 05:38:46 2007 -0400

    [libata] Remove ->irq_ack() hook, and ata_dummy_irq_on()
    
    * ->irq_ack() is redundant to what the irq handler already
      performs... chk-status + irq-clear.  Furthermore, it is only
      called in one place, when screaming-irq-debugging is enabled,
      so we don't want to bother with a hook just for that.
    
    * ata_dummy_irq_on() is only ever used in drivers that have
      no callpath reaching ->irq_on().  Remove .irq_on hook from
      those drivers, and the now-unused ata_dummy_irq_on()
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 9dc628931e99..a616616706da 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -89,7 +89,6 @@ static struct ata_port_operations pata_platform_port_ops = {
 
 	.irq_clear		= ata_bmdma_irq_clear,
 	.irq_on			= ata_irq_on,
-	.irq_ack		= ata_irq_ack,
 
 	.port_start		= ata_dummy_ret0,
 };

commit b8773531cc54c1ed10c8ec301353ee6b53b601a5
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Fri Aug 10 13:59:33 2007 -0700

    libata-add-irq_flags-to-struct-pata_platform_info-fix
    
    Remove unneeded, undesirable cast of void*.
    
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: Sonic Zhang <sonic.adi@gmail.com>
    Cc: Tejun Heo <htejun@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 37e5158391da..9dc628931e99 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -207,7 +207,7 @@ static int __devinit pata_platform_probe(struct platform_device *pdev)
 
 	ap->ioaddr.altstatus_addr = ap->ioaddr.ctl_addr;
 
-	pp_info = (struct pata_platform_info *)(pdev->dev.platform_data);
+	pp_info = pdev->dev.platform_data;
 	pata_platform_setup_port(&ap->ioaddr, pp_info);
 
 	/* activate */

commit 0260731f0187840e272bfa10d3ba0f3e417976f5
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Aug 6 18:36:23 2007 +0900

    libata-link: linkify config/EH related functions
    
    Make the following functions deal with ata_link instead of ata_port.
    
    * ata_set_mode()
    * ata_eh_autopsy() and related functions
    * ata_eh_report() and related functions
    * suspend/resume related functions
    * ata_eh_recover() and related functions
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index ee1605bfc29f..37e5158391da 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -30,11 +30,11 @@ static int pio_mask = 1;
  * Provide our own set_mode() as we don't want to change anything that has
  * already been configured..
  */
-static int pata_platform_set_mode(struct ata_port *ap, struct ata_device **unused)
+static int pata_platform_set_mode(struct ata_link *link, struct ata_device **unused)
 {
 	struct ata_device *dev;
 
-	ata_link_for_each_dev(dev, &ap->link) {
+	ata_link_for_each_dev(dev, link) {
 		if (ata_dev_enabled(dev)) {
 			/* We don't really care */
 			dev->pio_mode = dev->xfer_mode = XFER_PIO_0;

commit f58229f8060055b08b34008ea08f31de1e2f003c
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Aug 6 18:36:23 2007 +0900

    libata-link: implement and use link/device iterators
    
    Multiple links and different number of devices per link should be
    considered to iterate over links and devices.  This patch implements
    and uses link and device iterators - ata_port_for_each_link() and
    ata_link_for_each_dev() - and ata_link_max_devices().
    
    This change makes a lot of functions iterate over only possible
    devices instead of from dev 0 to dev ATA_MAX_DEVICES.  All such
    changes have been examined and nothing should be broken.
    
    While at it, add a separating comment before device helpers to
    distinguish them better from link helpers and others.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index e89656bffa84..ee1605bfc29f 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -32,11 +32,9 @@ static int pio_mask = 1;
  */
 static int pata_platform_set_mode(struct ata_port *ap, struct ata_device **unused)
 {
-	int i;
-
-	for (i = 0; i < ATA_MAX_DEVICES; i++) {
-		struct ata_device *dev = &ap->link.device[i];
+	struct ata_device *dev;
 
+	ata_link_for_each_dev(dev, &ap->link) {
 		if (ata_dev_enabled(dev)) {
 			/* We don't really care */
 			dev->pio_mode = dev->xfer_mode = XFER_PIO_0;

commit 9af5c9c97dc9d599281778864c72b385f0c63341
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Aug 6 18:36:22 2007 +0900

    libata-link: introduce ata_link
    
    Introduce ata_link.  It abstracts PHY and sits between ata_port and
    ata_device.  This new level of abstraction is necessary to support
    SATA Port Multiplier, which basically adds a bunch of links (PHYs) to
    a ATA host port.  Fields related to command execution, spd_limit and
    EH are per-link and thus moved to ata_link.
    
    This patch only defines the host link.  Multiple link handling will be
    added later.  Also, a lot of ap->link derefences are added but many of
    them will be removed as each part is converted to deal directly with
    ata_link instead of ata_port.
    
    This patch introduces no behavior change.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: James Bottomley <James.Bottomley@SteelEye.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 5086d03f2d7c..e89656bffa84 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -35,7 +35,7 @@ static int pata_platform_set_mode(struct ata_port *ap, struct ata_device **unuse
 	int i;
 
 	for (i = 0; i < ATA_MAX_DEVICES; i++) {
-		struct ata_device *dev = &ap->device[i];
+		struct ata_device *dev = &ap->link.device[i];
 
 		if (ata_dev_enabled(dev)) {
 			/* We don't really care */

commit 2a3103ce4357a09c2289405f969acec0edf4398f
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Aug 31 04:54:06 2007 -0400

    [libata] Bump driver versions
    
    Bump the versions for drivers that were modified, but had not already
    had a version number bump.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index a909f793ffc1..5086d03f2d7c 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -22,7 +22,7 @@
 #include <linux/pata_platform.h>
 
 #define DRV_NAME "pata_platform"
-#define DRV_VERSION "1.0"
+#define DRV_VERSION "1.1"
 
 static int pio_mask = 1;
 

commit 83b6839ec33becca78ebf6035489733a62e750bb
Author: Magnus Damm <magnus.damm@gmail.com>
Date:   Fri Jul 20 12:50:58 2007 +0900

    pata_platform: Fix NULL pointer dereference
    
    pata_platform: Fix NULL pointer dereference
    
    pata_platform currently dereferences a NULL pointer in pata_platform_probe()
    if pdev->dev.platform_data is set to NULL. This breakage was most likely
    introduced by commit 5f45bc50976ee1f408f7171af155aec646655a37.
    
    Signed-off-by: Magnus Damm <damm@igel.co.jp>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 79f841bca593..a909f793ffc1 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -213,8 +213,9 @@ static int __devinit pata_platform_probe(struct platform_device *pdev)
 	pata_platform_setup_port(&ap->ioaddr, pp_info);
 
 	/* activate */
-	return ata_host_activate(host, platform_get_irq(pdev, 0), ata_interrupt,
-				 pp_info->irq_flags, &pata_platform_sht);
+	return ata_host_activate(host, platform_get_irq(pdev, 0),
+				 ata_interrupt, pp_info ? pp_info->irq_flags
+				 : 0, &pata_platform_sht);
 }
 
 /**

commit 5f45bc50976ee1f408f7171af155aec646655a37
Author: Sonic Zhang <sonic.adi@gmail.com>
Date:   Fri Jun 15 17:45:49 2007 +0800

    Add irq_flags to struct pata_platform_info
    
    On some embedded platforms, such as blackfin, the gpio interrupt for
    IDE interface is designed to be triggered with high voltage. The gpio
    port should be configured properly by set_irq_type() when register
    the irq. This patch enable the generic pata platform driver to
    accept platform irq flags data.
    
    Signed-off-by: Sonic Zhang <sonic.adi@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index cbb7866940d6..79f841bca593 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -139,6 +139,7 @@ static int __devinit pata_platform_probe(struct platform_device *pdev)
 	struct resource *io_res, *ctl_res;
 	struct ata_host *host;
 	struct ata_port *ap;
+	struct pata_platform_info *pp_info;
 	unsigned int mmio;
 
 	/*
@@ -208,11 +209,12 @@ static int __devinit pata_platform_probe(struct platform_device *pdev)
 
 	ap->ioaddr.altstatus_addr = ap->ioaddr.ctl_addr;
 
-	pata_platform_setup_port(&ap->ioaddr, pdev->dev.platform_data);
+	pp_info = (struct pata_platform_info *)(pdev->dev.platform_data);
+	pata_platform_setup_port(&ap->ioaddr, pp_info);
 
 	/* activate */
 	return ata_host_activate(host, platform_get_irq(pdev, 0), ata_interrupt,
-				 0, &pata_platform_sht);
+				 pp_info->irq_flags, &pata_platform_sht);
 }
 
 /**

commit 8bc3fc470eb25af4d70c72485cbcb130cc657691
Author: Jeff Garzik <jeff@garzik.org>
Date:   Mon May 21 20:26:38 2007 -0400

    libata: bump versions
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 1f6384895a4f..cbb7866940d6 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -22,7 +22,7 @@
 #include <linux/pata_platform.h>
 
 #define DRV_NAME "pata_platform"
-#define DRV_VERSION "0.1.2"
+#define DRV_VERSION "1.0"
 
 static int pio_mask = 1;
 

commit b9a3b4d1453689f2927668fcdc4827fdccf44d1b
Author: Olof Johansson <olof@lixom.net>
Date:   Wed May 9 23:00:20 2007 -0500

    pata_platform: don't use generic ata_port_start
    
    I have a system where I have a simple IDE controller that sits on a
    local bus without bus master dma capability, and thus no dma_mapping
    ops defined for the device/bus.
    
    pata_platform works great for me, with the exception of using the generic
    ata_port_start which tries to do a dmam_alloc_coherent.
    
    Looks like it doesn't need to allocate a prd table at all, so replace it
    with a dummy function instead.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index a0a650c7f272..1f6384895a4f 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -48,6 +48,8 @@ static int pata_platform_set_mode(struct ata_port *ap, struct ata_device **unuse
 	return 0;
 }
 
+static int ata_dummy_ret0(struct ata_port *ap)	{ return 0; }
+
 static struct scsi_host_template pata_platform_sht = {
 	.module			= THIS_MODULE,
 	.name			= DRV_NAME,
@@ -91,7 +93,7 @@ static struct ata_port_operations pata_platform_port_ops = {
 	.irq_on			= ata_irq_on,
 	.irq_ack		= ata_irq_ack,
 
-	.port_start		= ata_port_start,
+	.port_start		= ata_dummy_ret0,
 };
 
 static void pata_platform_setup_port(struct ata_ioports *ioaddr,

commit 5d728824efeda61d304153bfcf1378a3c18b7d70
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Apr 17 23:44:08 2007 +0900

    libata: convert the remaining PATA drivers to new init model
    
    Convert pdc_adma, pata_cs5520, pata_isapnp, pata_ixp4xx_cf,
    pata_legacy, pata_mpc52xx, pata_mpiix, pata_pcmcia, pata_pdc2027x,
    pata_platform, pata_qdi, pata_scc and pata_winbond to new init model.
    
    * init_one()'s now follow more consistent init order
    
    * cs5520 now registers one host with two ports, not two hosts.  If any
      of the two ports are disabled, it's made dummy as other drivers do.
    
    Tested pdc_adma and pata_legacy.  Both are as broken as before.  The
    rest are compile tested only.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 507eb1ee05f8..a0a650c7f272 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -87,7 +87,6 @@ static struct ata_port_operations pata_platform_port_ops = {
 
 	.data_xfer		= ata_data_xfer_noirq,
 
-	.irq_handler		= ata_interrupt,
 	.irq_clear		= ata_bmdma_irq_clear,
 	.irq_on			= ata_irq_on,
 	.irq_ack		= ata_irq_ack,
@@ -136,7 +135,8 @@ static void pata_platform_setup_port(struct ata_ioports *ioaddr,
 static int __devinit pata_platform_probe(struct platform_device *pdev)
 {
 	struct resource *io_res, *ctl_res;
-	struct ata_probe_ent ae;
+	struct ata_host *host;
+	struct ata_port *ap;
 	unsigned int mmio;
 
 	/*
@@ -176,44 +176,41 @@ static int __devinit pata_platform_probe(struct platform_device *pdev)
 	/*
 	 * Now that that's out of the way, wire up the port..
 	 */
-	memset(&ae, 0, sizeof(struct ata_probe_ent));
-	INIT_LIST_HEAD(&ae.node);
-	ae.dev = &pdev->dev;
-	ae.port_ops = &pata_platform_port_ops;
-	ae.sht = &pata_platform_sht;
-	ae.n_ports = 1;
-	ae.pio_mask = pio_mask;
-	ae.irq = platform_get_irq(pdev, 0);
-	ae.irq_flags = 0;
-	ae.port_flags = ATA_FLAG_SLAVE_POSS | ATA_FLAG_SRST;
+	host = ata_host_alloc(&pdev->dev, 1);
+	if (!host)
+		return -ENOMEM;
+	ap = host->ports[0];
+
+	ap->ops = &pata_platform_port_ops;
+	ap->pio_mask = pio_mask;
+	ap->flags |= ATA_FLAG_SLAVE_POSS;
 
 	/*
 	 * Handle the MMIO case
 	 */
 	if (mmio) {
-		ae.port[0].cmd_addr = devm_ioremap(&pdev->dev, io_res->start,
+		ap->ioaddr.cmd_addr = devm_ioremap(&pdev->dev, io_res->start,
 				io_res->end - io_res->start + 1);
-		ae.port[0].ctl_addr = devm_ioremap(&pdev->dev, ctl_res->start,
+		ap->ioaddr.ctl_addr = devm_ioremap(&pdev->dev, ctl_res->start,
 				ctl_res->end - ctl_res->start + 1);
 	} else {
-		ae.port[0].cmd_addr = devm_ioport_map(&pdev->dev, io_res->start,
+		ap->ioaddr.cmd_addr = devm_ioport_map(&pdev->dev, io_res->start,
 				io_res->end - io_res->start + 1);
-		ae.port[0].ctl_addr = devm_ioport_map(&pdev->dev, ctl_res->start,
+		ap->ioaddr.ctl_addr = devm_ioport_map(&pdev->dev, ctl_res->start,
 				ctl_res->end - ctl_res->start + 1);
 	}
-	if (!ae.port[0].cmd_addr || !ae.port[0].ctl_addr) {
+	if (!ap->ioaddr.cmd_addr || !ap->ioaddr.ctl_addr) {
 		dev_err(&pdev->dev, "failed to map IO/CTL base\n");
 		return -ENOMEM;
 	}
 
-	ae.port[0].altstatus_addr = ae.port[0].ctl_addr;
+	ap->ioaddr.altstatus_addr = ap->ioaddr.ctl_addr;
 
-	pata_platform_setup_port(&ae.port[0], pdev->dev.platform_data);
+	pata_platform_setup_port(&ap->ioaddr, pdev->dev.platform_data);
 
-	if (unlikely(ata_device_add(&ae) == 0))
-		return -ENODEV;
-
-	return 0;
+	/* activate */
+	return ata_host_activate(host, platform_get_irq(pdev, 0), ata_interrupt,
+				 0, &pata_platform_sht);
 }
 
 /**

commit 570cb62deef574db10bcf1b4e9a8a0cbf7b101ee
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Thu Mar 8 22:54:04 2007 +0000

    pata_platform: Add cable_detect method
    
    Signed-off-by: Alan Cox <number6@the-village.bc.nu>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 4b82a5435a4e..507eb1ee05f8 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -80,6 +80,7 @@ static struct ata_port_operations pata_platform_port_ops = {
 	.thaw			= ata_bmdma_thaw,
 	.error_handler		= ata_bmdma_error_handler,
 	.post_internal_cmd	= ata_bmdma_post_internal_cmd,
+	.cable_detect		= ata_cable_unknown,
 
 	.qc_prep		= ata_qc_prep,
 	.qc_issue		= ata_qc_issue_prot,

commit 1aa56cca5bfa396c791e93b38e4776ef39b590a7
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Feb 27 22:33:21 2007 +0900

    libata: clear drvdata in ata_host_release(), take#2
    
    Clearing drvdata in ->remove_one causes NULL pointer deference.  Clear
    drvdata only in ata_host_release() after all resources are freed.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 02ea95fcba69..4b82a5435a4e 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -228,7 +228,6 @@ static int __devexit pata_platform_remove(struct platform_device *pdev)
 	struct ata_host *host = dev_get_drvdata(dev);
 
 	ata_host_detach(host);
-	dev_set_drvdata(dev, NULL);
 
 	return 0;
 }

commit e852f7054df7cf4be686d8cff9c33333a36b59e9
Author: Alan <alan@lxorguk.ukuu.org.uk>
Date:   Tue Feb 20 17:35:43 2007 +0000

    pata: Display Configuring .. lines for devices with private set_mode methods
    
    We can't specify which mode in the cases below but we can at least say
    PIO and look consistent with the default.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 479a326114e0..02ea95fcba69 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -42,6 +42,7 @@ static int pata_platform_set_mode(struct ata_port *ap, struct ata_device **unuse
 			dev->pio_mode = dev->xfer_mode = XFER_PIO_0;
 			dev->xfer_shift = ATA_SHIFT_PIO;
 			dev->flags |= ATA_DFLAG_PIO;
+			ata_dev_printk(dev, KERN_INFO, "configured for PIO\n");
 		}
 	}
 	return 0;

commit 246ce3b675843e0369643cceb4faeb6cf6d19a30
Author: Akira Iguchi <akira2.iguchi@toshiba.co.jp>
Date:   Fri Jan 26 16:27:58 2007 +0900

    libata: add another IRQ calls (libata drivers)
    
    This patch is against each libata driver.
    
    Two IRQ calls are added in ata_port_operations.
    - irq_on() is used to enable interrupts.
    - irq_ack() is used to acknowledge a device interrupt.
    
    In most drivers, ata_irq_on() and ata_irq_ack() are used for
    irq_on and irq_ack respectively.
    
    In some drivers (ex: ahci, sata_sil24) which cannot use them
    as is, ata_dummy_irq_on() and ata_dummy_irq_ack() are used.
    
    Signed-off-by: Kou Ishizaki <kou.ishizaki@toshiba.co.jp>
    Signed-off-by: Akira Iguchi <akira2.iguchi@toshiba.co.jp>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index b35fc29f4db5..479a326114e0 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -87,6 +87,8 @@ static struct ata_port_operations pata_platform_port_ops = {
 
 	.irq_handler		= ata_interrupt,
 	.irq_clear		= ata_bmdma_irq_clear,
+	.irq_on			= ata_irq_on,
+	.irq_ack		= ata_irq_ack,
 
 	.port_start		= ata_port_start,
 };

commit 0d5ff566779f894ca9937231a181eb31e4adff0e
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Feb 1 15:06:36 2007 +0900

    libata: convert to iomap
    
    Convert libata core layer and LLDs to use iomap.
    
    * managed iomap is used.  Pointer to pcim_iomap_table() is cached at
      host->iomap and used through out LLDs.  This basically replaces
      host->mmio_base.
    
    * if possible, pcim_iomap_regions() is used
    
    Most iomap operation conversions are taken from Jeff Garzik
    <jgarzik@pobox.com>'s iomap branch.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 8a261a3daeda..b35fc29f4db5 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -83,7 +83,7 @@ static struct ata_port_operations pata_platform_port_ops = {
 	.qc_prep		= ata_qc_prep,
 	.qc_issue		= ata_qc_issue_prot,
 
-	.data_xfer		= ata_pio_data_xfer_noirq,
+	.data_xfer		= ata_data_xfer_noirq,
 
 	.irq_handler		= ata_interrupt,
 	.irq_clear		= ata_bmdma_irq_clear,
@@ -134,7 +134,6 @@ static int __devinit pata_platform_probe(struct platform_device *pdev)
 	struct resource *io_res, *ctl_res;
 	struct ata_probe_ent ae;
 	unsigned int mmio;
-	int ret;
 
 	/*
 	 * Simple resource validation ..
@@ -188,48 +187,29 @@ static int __devinit pata_platform_probe(struct platform_device *pdev)
 	 * Handle the MMIO case
 	 */
 	if (mmio) {
-		ae.port_flags |= ATA_FLAG_MMIO;
-
-		ae.port[0].cmd_addr = (unsigned long)
-			devm_ioremap(&pdev->dev, io_res->start,
-				     io_res->end - io_res->start + 1);
-		if (unlikely(!ae.port[0].cmd_addr)) {
-			dev_err(&pdev->dev, "failed to remap IO base\n");
-			return -ENXIO;
-		}
-
-		ae.port[0].ctl_addr = (unsigned long)
-			devm_ioremap(&pdev->dev, ctl_res->start,
-				     ctl_res->end - ctl_res->start + 1);
-		if (unlikely(!ae.port[0].ctl_addr)) {
-			dev_err(&pdev->dev, "failed to remap CTL base\n");
-			ret = -ENXIO;
-			goto bad_remap;
-		}
+		ae.port[0].cmd_addr = devm_ioremap(&pdev->dev, io_res->start,
+				io_res->end - io_res->start + 1);
+		ae.port[0].ctl_addr = devm_ioremap(&pdev->dev, ctl_res->start,
+				ctl_res->end - ctl_res->start + 1);
 	} else {
-		ae.port[0].cmd_addr = io_res->start;
-		ae.port[0].ctl_addr = ctl_res->start;
+		ae.port[0].cmd_addr = devm_ioport_map(&pdev->dev, io_res->start,
+				io_res->end - io_res->start + 1);
+		ae.port[0].ctl_addr = devm_ioport_map(&pdev->dev, ctl_res->start,
+				ctl_res->end - ctl_res->start + 1);
+	}
+	if (!ae.port[0].cmd_addr || !ae.port[0].ctl_addr) {
+		dev_err(&pdev->dev, "failed to map IO/CTL base\n");
+		return -ENOMEM;
 	}
 
 	ae.port[0].altstatus_addr = ae.port[0].ctl_addr;
 
 	pata_platform_setup_port(&ae.port[0], pdev->dev.platform_data);
 
-	if (unlikely(ata_device_add(&ae) == 0)) {
-		ret = -ENODEV;
-		goto add_failed;
-	}
+	if (unlikely(ata_device_add(&ae) == 0))
+		return -ENODEV;
 
 	return 0;
-
-add_failed:
-	if (ae.port[0].ctl_addr && mmio)
-		iounmap((void __iomem *)ae.port[0].ctl_addr);
-bad_remap:
-	if (ae.port[0].cmd_addr && mmio)
-		iounmap((void __iomem *)ae.port[0].cmd_addr);
-
-	return ret;
 }
 
 /**

commit 1a68ff13c8a9b517de3fd4187dc525412a6eba1b
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Feb 1 15:05:22 2007 +0900

    pata_platform: fix devres conversion
    
    devres updates for pata_platform were dropped while merging devres
    patches due to merge conflict.  This is the updated version.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 40ae11cbfda4..8a261a3daeda 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -47,23 +47,6 @@ static int pata_platform_set_mode(struct ata_port *ap, struct ata_device **unuse
 	return 0;
 }
 
-static void pata_platform_host_stop(struct ata_host *host)
-{
-	int i;
-
-	/*
-	 * Unmap the bases for MMIO
-	 */
-	for (i = 0; i < host->n_ports; i++) {
-		struct ata_port *ap = host->ports[i];
-
-		if (ap->flags & ATA_FLAG_MMIO) {
-			iounmap((void __iomem *)ap->ioaddr.ctl_addr);
-			iounmap((void __iomem *)ap->ioaddr.cmd_addr);
-		}
-	}
-}
-
 static struct scsi_host_template pata_platform_sht = {
 	.module			= THIS_MODULE,
 	.name			= DRV_NAME,
@@ -106,8 +89,6 @@ static struct ata_port_operations pata_platform_port_ops = {
 	.irq_clear		= ata_bmdma_irq_clear,
 
 	.port_start		= ata_port_start,
-	.port_stop		= ata_port_stop,
-	.host_stop		= pata_platform_host_stop
 };
 
 static void pata_platform_setup_port(struct ata_ioports *ioaddr,
@@ -209,15 +190,17 @@ static int __devinit pata_platform_probe(struct platform_device *pdev)
 	if (mmio) {
 		ae.port_flags |= ATA_FLAG_MMIO;
 
-		ae.port[0].cmd_addr = (unsigned long)ioremap(io_res->start,
-				io_res->end - io_res->start + 1);
+		ae.port[0].cmd_addr = (unsigned long)
+			devm_ioremap(&pdev->dev, io_res->start,
+				     io_res->end - io_res->start + 1);
 		if (unlikely(!ae.port[0].cmd_addr)) {
 			dev_err(&pdev->dev, "failed to remap IO base\n");
 			return -ENXIO;
 		}
 
-		ae.port[0].ctl_addr = (unsigned long)ioremap(ctl_res->start,
-				ctl_res->end - ctl_res->start + 1);
+		ae.port[0].ctl_addr = (unsigned long)
+			devm_ioremap(&pdev->dev, ctl_res->start,
+				     ctl_res->end - ctl_res->start + 1);
 		if (unlikely(!ae.port[0].ctl_addr)) {
 			dev_err(&pdev->dev, "failed to remap CTL base\n");
 			ret = -ENXIO;
@@ -261,7 +244,7 @@ static int __devexit pata_platform_remove(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct ata_host *host = dev_get_drvdata(dev);
 
-	ata_host_remove(host);
+	ata_host_detach(host);
 	dev_set_drvdata(dev, NULL);
 
 	return 0;

commit 161c888b0b4d28775dfe35274ee90c16a91b4365
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Tue Jan 30 13:23:45 2007 +0000

    [PATCH] pata_platform: fallout from set_mode() change
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 443b1d85c6c4..40ae11cbfda4 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -30,7 +30,7 @@ static int pio_mask = 1;
  * Provide our own set_mode() as we don't want to change anything that has
  * already been configured..
  */
-static void pata_platform_set_mode(struct ata_port *ap)
+static int pata_platform_set_mode(struct ata_port *ap, struct ata_device **unused)
 {
 	int i;
 
@@ -44,6 +44,7 @@ static void pata_platform_set_mode(struct ata_port *ap)
 			dev->flags |= ATA_DFLAG_PIO;
 		}
 	}
+	return 0;
 }
 
 static void pata_platform_host_stop(struct ata_host *host)

commit 2eab80ac0c96fb98267afeb12a4899801564c75b
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Nov 29 12:20:26 2006 +0900

    [PATCH] libata: kill unnecessary sht->max_sectors initializations
    
    sht->max_sectors is overrided unconditionally in ->slave_configure.
    There's no reason to set it to any value.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 5ff74e4ce590..443b1d85c6c4 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -71,7 +71,6 @@ static struct scsi_host_template pata_platform_sht = {
 	.can_queue		= ATA_DEF_QUEUE,
 	.this_id		= ATA_SHT_THIS_ID,
 	.sg_tablesize		= LIBATA_MAX_PRD,
-	.max_sectors		= ATA_MAX_SECTORS,
 	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
 	.emulated		= ATA_SHT_EMULATED,
 	.use_clustering		= ATA_SHT_USE_CLUSTERING,

commit c972b60bf167a3d2c3da23df2af1eac93229e7cc
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Nov 29 12:10:46 2006 +0900

    [PATCH] libata: add missing sht->slave_destroy
    
    Add missing sht->slave_destroy.  Most drivers received this fix in
    didn't.  Fix those four drives.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
index 63d6687f0ba9..5ff74e4ce590 100644
--- a/drivers/ata/pata_platform.c
+++ b/drivers/ata/pata_platform.c
@@ -78,6 +78,7 @@ static struct scsi_host_template pata_platform_sht = {
 	.proc_name		= DRV_NAME,
 	.dma_boundary		= ATA_DMA_BOUNDARY,
 	.slave_configure	= ata_scsi_slave_config,
+	.slave_destroy		= ata_scsi_slave_destroy,
 	.bios_param		= ata_std_bios_param,
 };
 

commit a20c9e820864e18b59d2a4f2f04e8b6053986c95
Author: Paul Mundt <lethal@linux-sh.org>
Date:   Fri Oct 27 19:08:48 2006 -0700

    [PATCH] ata: Generic platform_device libata driver
    
    needs a changelog
    
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_platform.c b/drivers/ata/pata_platform.c
new file mode 100644
index 000000000000..63d6687f0ba9
--- /dev/null
+++ b/drivers/ata/pata_platform.c
@@ -0,0 +1,295 @@
+/*
+ * Generic platform device PATA driver
+ *
+ * Copyright (C) 2006  Paul Mundt
+ *
+ * Based on pata_pcmcia:
+ *
+ *   Copyright 2005-2006 Red Hat Inc <alan@redhat.com>, all rights reserved.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/blkdev.h>
+#include <scsi/scsi_host.h>
+#include <linux/ata.h>
+#include <linux/libata.h>
+#include <linux/platform_device.h>
+#include <linux/pata_platform.h>
+
+#define DRV_NAME "pata_platform"
+#define DRV_VERSION "0.1.2"
+
+static int pio_mask = 1;
+
+/*
+ * Provide our own set_mode() as we don't want to change anything that has
+ * already been configured..
+ */
+static void pata_platform_set_mode(struct ata_port *ap)
+{
+	int i;
+
+	for (i = 0; i < ATA_MAX_DEVICES; i++) {
+		struct ata_device *dev = &ap->device[i];
+
+		if (ata_dev_enabled(dev)) {
+			/* We don't really care */
+			dev->pio_mode = dev->xfer_mode = XFER_PIO_0;
+			dev->xfer_shift = ATA_SHIFT_PIO;
+			dev->flags |= ATA_DFLAG_PIO;
+		}
+	}
+}
+
+static void pata_platform_host_stop(struct ata_host *host)
+{
+	int i;
+
+	/*
+	 * Unmap the bases for MMIO
+	 */
+	for (i = 0; i < host->n_ports; i++) {
+		struct ata_port *ap = host->ports[i];
+
+		if (ap->flags & ATA_FLAG_MMIO) {
+			iounmap((void __iomem *)ap->ioaddr.ctl_addr);
+			iounmap((void __iomem *)ap->ioaddr.cmd_addr);
+		}
+	}
+}
+
+static struct scsi_host_template pata_platform_sht = {
+	.module			= THIS_MODULE,
+	.name			= DRV_NAME,
+	.ioctl			= ata_scsi_ioctl,
+	.queuecommand		= ata_scsi_queuecmd,
+	.can_queue		= ATA_DEF_QUEUE,
+	.this_id		= ATA_SHT_THIS_ID,
+	.sg_tablesize		= LIBATA_MAX_PRD,
+	.max_sectors		= ATA_MAX_SECTORS,
+	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
+	.emulated		= ATA_SHT_EMULATED,
+	.use_clustering		= ATA_SHT_USE_CLUSTERING,
+	.proc_name		= DRV_NAME,
+	.dma_boundary		= ATA_DMA_BOUNDARY,
+	.slave_configure	= ata_scsi_slave_config,
+	.bios_param		= ata_std_bios_param,
+};
+
+static struct ata_port_operations pata_platform_port_ops = {
+	.set_mode		= pata_platform_set_mode,
+
+	.port_disable		= ata_port_disable,
+	.tf_load		= ata_tf_load,
+	.tf_read		= ata_tf_read,
+	.check_status		= ata_check_status,
+	.exec_command		= ata_exec_command,
+	.dev_select		= ata_std_dev_select,
+
+	.freeze			= ata_bmdma_freeze,
+	.thaw			= ata_bmdma_thaw,
+	.error_handler		= ata_bmdma_error_handler,
+	.post_internal_cmd	= ata_bmdma_post_internal_cmd,
+
+	.qc_prep		= ata_qc_prep,
+	.qc_issue		= ata_qc_issue_prot,
+
+	.data_xfer		= ata_pio_data_xfer_noirq,
+
+	.irq_handler		= ata_interrupt,
+	.irq_clear		= ata_bmdma_irq_clear,
+
+	.port_start		= ata_port_start,
+	.port_stop		= ata_port_stop,
+	.host_stop		= pata_platform_host_stop
+};
+
+static void pata_platform_setup_port(struct ata_ioports *ioaddr,
+				     struct pata_platform_info *info)
+{
+	unsigned int shift = 0;
+
+	/* Fixup the port shift for platforms that need it */
+	if (info && info->ioport_shift)
+		shift = info->ioport_shift;
+
+	ioaddr->data_addr	= ioaddr->cmd_addr + (ATA_REG_DATA    << shift);
+	ioaddr->error_addr	= ioaddr->cmd_addr + (ATA_REG_ERR     << shift);
+	ioaddr->feature_addr	= ioaddr->cmd_addr + (ATA_REG_FEATURE << shift);
+	ioaddr->nsect_addr	= ioaddr->cmd_addr + (ATA_REG_NSECT   << shift);
+	ioaddr->lbal_addr	= ioaddr->cmd_addr + (ATA_REG_LBAL    << shift);
+	ioaddr->lbam_addr	= ioaddr->cmd_addr + (ATA_REG_LBAM    << shift);
+	ioaddr->lbah_addr	= ioaddr->cmd_addr + (ATA_REG_LBAH    << shift);
+	ioaddr->device_addr	= ioaddr->cmd_addr + (ATA_REG_DEVICE  << shift);
+	ioaddr->status_addr	= ioaddr->cmd_addr + (ATA_REG_STATUS  << shift);
+	ioaddr->command_addr	= ioaddr->cmd_addr + (ATA_REG_CMD     << shift);
+}
+
+/**
+ *	pata_platform_probe		-	attach a platform interface
+ *	@pdev: platform device
+ *
+ *	Register a platform bus IDE interface. Such interfaces are PIO and we
+ *	assume do not support IRQ sharing.
+ *
+ *	Platform devices are expected to contain 3 resources per port:
+ *
+ *		- I/O Base (IORESOURCE_IO or IORESOURCE_MEM)
+ *		- CTL Base (IORESOURCE_IO or IORESOURCE_MEM)
+ *		- IRQ	   (IORESOURCE_IRQ)
+ *
+ *	If the base resources are both mem types, the ioremap() is handled
+ *	here. For IORESOURCE_IO, it's assumed that there's no remapping
+ *	necessary.
+ */
+static int __devinit pata_platform_probe(struct platform_device *pdev)
+{
+	struct resource *io_res, *ctl_res;
+	struct ata_probe_ent ae;
+	unsigned int mmio;
+	int ret;
+
+	/*
+	 * Simple resource validation ..
+	 */
+	if (unlikely(pdev->num_resources != 3)) {
+		dev_err(&pdev->dev, "invalid number of resources\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * Get the I/O base first
+	 */
+	io_res = platform_get_resource(pdev, IORESOURCE_IO, 0);
+	if (io_res == NULL) {
+		io_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (unlikely(io_res == NULL))
+			return -EINVAL;
+	}
+
+	/*
+	 * Then the CTL base
+	 */
+	ctl_res = platform_get_resource(pdev, IORESOURCE_IO, 1);
+	if (ctl_res == NULL) {
+		ctl_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+		if (unlikely(ctl_res == NULL))
+			return -EINVAL;
+	}
+
+	/*
+	 * Check for MMIO
+	 */
+	mmio = (( io_res->flags == IORESOURCE_MEM) &&
+		(ctl_res->flags == IORESOURCE_MEM));
+
+	/*
+	 * Now that that's out of the way, wire up the port..
+	 */
+	memset(&ae, 0, sizeof(struct ata_probe_ent));
+	INIT_LIST_HEAD(&ae.node);
+	ae.dev = &pdev->dev;
+	ae.port_ops = &pata_platform_port_ops;
+	ae.sht = &pata_platform_sht;
+	ae.n_ports = 1;
+	ae.pio_mask = pio_mask;
+	ae.irq = platform_get_irq(pdev, 0);
+	ae.irq_flags = 0;
+	ae.port_flags = ATA_FLAG_SLAVE_POSS | ATA_FLAG_SRST;
+
+	/*
+	 * Handle the MMIO case
+	 */
+	if (mmio) {
+		ae.port_flags |= ATA_FLAG_MMIO;
+
+		ae.port[0].cmd_addr = (unsigned long)ioremap(io_res->start,
+				io_res->end - io_res->start + 1);
+		if (unlikely(!ae.port[0].cmd_addr)) {
+			dev_err(&pdev->dev, "failed to remap IO base\n");
+			return -ENXIO;
+		}
+
+		ae.port[0].ctl_addr = (unsigned long)ioremap(ctl_res->start,
+				ctl_res->end - ctl_res->start + 1);
+		if (unlikely(!ae.port[0].ctl_addr)) {
+			dev_err(&pdev->dev, "failed to remap CTL base\n");
+			ret = -ENXIO;
+			goto bad_remap;
+		}
+	} else {
+		ae.port[0].cmd_addr = io_res->start;
+		ae.port[0].ctl_addr = ctl_res->start;
+	}
+
+	ae.port[0].altstatus_addr = ae.port[0].ctl_addr;
+
+	pata_platform_setup_port(&ae.port[0], pdev->dev.platform_data);
+
+	if (unlikely(ata_device_add(&ae) == 0)) {
+		ret = -ENODEV;
+		goto add_failed;
+	}
+
+	return 0;
+
+add_failed:
+	if (ae.port[0].ctl_addr && mmio)
+		iounmap((void __iomem *)ae.port[0].ctl_addr);
+bad_remap:
+	if (ae.port[0].cmd_addr && mmio)
+		iounmap((void __iomem *)ae.port[0].cmd_addr);
+
+	return ret;
+}
+
+/**
+ *	pata_platform_remove	-	unplug a platform interface
+ *	@pdev: platform device
+ *
+ *	A platform bus ATA device has been unplugged. Perform the needed
+ *	cleanup. Also called on module unload for any active devices.
+ */
+static int __devexit pata_platform_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct ata_host *host = dev_get_drvdata(dev);
+
+	ata_host_remove(host);
+	dev_set_drvdata(dev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver pata_platform_driver = {
+	.probe		= pata_platform_probe,
+	.remove		= __devexit_p(pata_platform_remove),
+	.driver = {
+		.name		= DRV_NAME,
+		.owner		= THIS_MODULE,
+	},
+};
+
+static int __init pata_platform_init(void)
+{
+	return platform_driver_register(&pata_platform_driver);
+}
+
+static void __exit pata_platform_exit(void)
+{
+	platform_driver_unregister(&pata_platform_driver);
+}
+module_init(pata_platform_init);
+module_exit(pata_platform_exit);
+
+module_param(pio_mask, int, 0);
+
+MODULE_AUTHOR("Paul Mundt");
+MODULE_DESCRIPTION("low-level driver for platform device ATA");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
