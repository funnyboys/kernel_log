commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index 84c6b225b56e..4b2ba813dcab 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *    pata_ns87415.c - NS87415 (non PARISC) PATA
  *

commit 58eb8cd565af4a104395e3c10443951c1f73dafe
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Wed May 7 17:17:44 2014 +0200

    ata: use CONFIG_PM_SLEEP instead of CONFIG_PM where applicable in host drivers
    
    This patch fixes host drivers to use CONFIG_PM_SLEEP instead of CONFIG_PM
    where applicable.  Benefits of this change:
    
    * unused code is not being compiled in for CONFIG_PM=y, CONFIG_PM_SLEEP=n
      and CONFIG_PM_RUNTIME=y configurations
    
    * easier transition to use struct dev_pm_ops and SIMPLE_DEV_PM_OPS() in
      the future
    
    * more consistent code (there are host drivers which are using the correct
      CONFIG_PM_SLEEP checks already)
    
    The patch leaves the core libata code and ->port_[suspend,resume] support
    in sata_[inic162x,nv,sil24].c alone for now.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index d44df7ccfe43..84c6b225b56e 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -385,7 +385,7 @@ static const struct pci_device_id ns87415_pci_tbl[] = {
 	{ }	/* terminate list */
 };
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 static int ns87415_reinit_one(struct pci_dev *pdev)
 {
 	struct ata_host *host = pci_get_drvdata(pdev);
@@ -407,7 +407,7 @@ static struct pci_driver ns87415_pci_driver = {
 	.id_table		= ns87415_pci_tbl,
 	.probe			= ns87415_init_one,
 	.remove			= ata_pci_remove_one,
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 	.suspend		= ata_pci_device_suspend,
 	.resume			= ns87415_reinit_one,
 #endif

commit 1bc18086231c130895b87ec049be8ddcdab552b8
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Jan 21 16:22:51 2014 -0500

    ata: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Cc: linux-ide@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index 16dc3a63a23d..d44df7ccfe43 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -25,7 +25,6 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/pci.h>
-#include <linux/init.h>
 #include <linux/blkdev.h>
 #include <linux/delay.h>
 #include <linux/device.h>

commit 0a86e1c857134efe2cdb31d74bc7ea21721db494
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Mon Jun 3 14:05:36 2013 +0900

    ata: use pci_get_drvdata()
    
    Use the wrapper function for getting the driver data using pci_dev
    instead of using dev_get_drvdata() with &pdev->dev, so we can directly
    pass a struct pci_dev.  This is a purely cosmetic change.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index 6f6fa1060505..16dc3a63a23d 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -389,7 +389,7 @@ static const struct pci_device_id ns87415_pci_tbl[] = {
 #ifdef CONFIG_PM
 static int ns87415_reinit_one(struct pci_dev *pdev)
 {
-	struct ata_host *host = dev_get_drvdata(&pdev->dev);
+	struct ata_host *host = pci_get_drvdata(pdev);
 	int rc;
 
 	rc = ata_pci_device_do_resume(pdev);

commit 2fc75da0c59634b81223af497c4a037822f6e457
Author: Axel Lin <axel.lin@gmail.com>
Date:   Thu Apr 19 13:43:05 2012 +0800

    ata: use module_pci_driver
    
    This patch converts the drivers in drivers/ata/* to use module_pci_driver()
    macro which makes the code smaller and a bit simpler.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Cc: Mikael Pettersson <mikpe@it.uu.se>
    Cc: Mark Lord <kernel@teksavvy.com>
    Cc: Jeremy Higdon <jeremy@sgi.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index f1d517bc5b49..6f6fa1060505 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -414,18 +414,7 @@ static struct pci_driver ns87415_pci_driver = {
 #endif
 };
 
-static int __init ns87415_init(void)
-{
-	return pci_register_driver(&ns87415_pci_driver);
-}
-
-static void __exit ns87415_exit(void)
-{
-	pci_unregister_driver(&ns87415_pci_driver);
-}
-
-module_init(ns87415_init);
-module_exit(ns87415_exit);
+module_pci_driver(ns87415_pci_driver);
 
 MODULE_AUTHOR("Alan Cox");
 MODULE_DESCRIPTION("ATA low-level driver for NS87415 controllers");

commit 06296a1e684bcd40b9a28d5d8030809e4295528b
Author: Joe Perches <joe@perches.com>
Date:   Fri Apr 15 15:52:00 2011 -0700

    ata: Add and use ata_print_version_once
    
    Use a single mechanism to show driver version.
    Reduces text a tiny bit too.
    
    Remove uses of static int printed_version
    Add and use ata_print_version(const struct device *, const char *ver)
    and ata_print_version_once.
    
    $ size drivers/ata/built-in.*
       text    data     bss     dec     hex filename
     544969   73893  116584  735446   b38d6 drivers/ata/built-in.allyesconfig.ata.o
     543870   73893  116592  734355   b34ad drivers/ata/built-in.allyesconfig.print_once.o
     141328   14689    4220  160237   271ed drivers/ata/built-in.defconfig.ata.o
     141212   14689    4220  160121   27179 drivers/ata/built-in.defconfig.print_once.o
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index 605f198f958c..f1d517bc5b49 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -350,7 +350,6 @@ static void ns87415_fixup(struct pci_dev *pdev)
 
 static int ns87415_init_one (struct pci_dev *pdev, const struct pci_device_id *ent)
 {
-	static int printed_version;
 	static const struct ata_port_info info = {
 		.flags		= ATA_FLAG_SLAVE_POSS,
 		.pio_mask	= ATA_PIO4,
@@ -370,9 +369,7 @@ static int ns87415_init_one (struct pci_dev *pdev, const struct pci_device_id *e
 	if (PCI_SLOT(pdev->devfn) == 0x0E)
 		ppi[0] = &info87560;
 #endif
-	if (!printed_version++)
-		dev_printk(KERN_DEBUG, &pdev->dev,
-			   "version " DRV_VERSION "\n");
+	ata_print_version_once(&pdev->dev, DRV_VERSION);
 
 	rc = pcim_enable_device(pdev);
 	if (rc)

commit 1c5afdf7a629d2e77de8dd043b97a33dcd7e6dfa
Author: Tejun Heo <tj@kernel.org>
Date:   Wed May 19 22:10:22 2010 +0200

    libata-sff: separate out BMDMA init
    
    Separate out ata_pci_bmdma_prepare_host() and ata_pci_bmdma_init_one()
    from their SFF counterparts.  SFF ones no longer try to initialize
    BMDMA or set PCI master.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index fdbba2d76d3e..605f198f958c 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -380,7 +380,7 @@ static int ns87415_init_one (struct pci_dev *pdev, const struct pci_device_id *e
 
 	ns87415_fixup(pdev);
 
-	return ata_pci_sff_init_one(pdev, ppi, &ns87415_sht, NULL, 0);
+	return ata_pci_bmdma_init_one(pdev, ppi, &ns87415_sht, NULL, 0);
 }
 
 static const struct pci_device_id ns87415_pci_tbl[] = {

commit f60d70113fa04e32aee2dedbf304a48469c9c45c
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 10 21:41:41 2010 +0200

    libata-sff: prd is BMDMA specific
    
    struct ata_prd and ap->prd are BMDMA specific.  Add bmdma_ prefix to
    them and move them inside CONFIG_ATA_SFF.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index 830431f036a1..fdbba2d76d3e 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -126,7 +126,7 @@ static void ns87415_bmdma_setup(struct ata_queued_cmd *qc)
 
 	/* load PRD table addr. */
 	mb();	/* make sure PRD table writes are visible to controller */
-	iowrite32(ap->prd_dma, ap->ioaddr.bmdma_addr + ATA_DMA_TABLE_OFS);
+	iowrite32(ap->bmdma_prd_dma, ap->ioaddr.bmdma_addr + ATA_DMA_TABLE_OFS);
 
 	/* specify data direction, triple-check start bit is clear */
 	dmactl = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_CMD);

commit 16ea0fc98d53c72cb4e1a9edcb685a87e3a81430
Author: Alan Cox <alan@linux.intel.com>
Date:   Tue Feb 23 02:26:06 2010 -0500

    libata: Pass host flags into the pci helper
    
    This allows parallel scan and the like to be set without having to stop
    using the existing full helper functions. This patch merely adds the argument
    and fixes up the callers. It doesn't undo the special cases already in the
    tree or add any new parallel callers.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index 061aa1c41a48..830431f036a1 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -380,7 +380,7 @@ static int ns87415_init_one (struct pci_dev *pdev, const struct pci_device_id *e
 
 	ns87415_fixup(pdev);
 
-	return ata_pci_sff_init_one(pdev, ppi, &ns87415_sht, NULL);
+	return ata_pci_sff_init_one(pdev, ppi, &ns87415_sht, NULL, 0);
 }
 
 static const struct pci_device_id ns87415_pci_tbl[] = {

commit a809c68752e63312c20fb027cf33da4a5ac384a5
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu Dec 3 20:32:12 2009 +0100

    pata_ns87415: Power Management fix
    
    Fix ->resume method to do chipset specific setup.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index 773b1590b492..061aa1c41a48 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -325,6 +325,13 @@ static struct scsi_host_template ns87415_sht = {
 	ATA_BMDMA_SHT(DRV_NAME),
 };
 
+static void ns87415_fixup(struct pci_dev *pdev)
+{
+	/* Select 512 byte sectors */
+	pci_write_config_byte(pdev, 0x55, 0xEE);
+	/* Select PIO0 8bit clocking */
+	pci_write_config_byte(pdev, 0x54, 0xB7);
+}
 
 /**
  *	ns87415_init_one - Register 87415 ATA PCI device with kernel services
@@ -371,10 +378,8 @@ static int ns87415_init_one (struct pci_dev *pdev, const struct pci_device_id *e
 	if (rc)
 		return rc;
 
-	/* Select 512 byte sectors */
-	pci_write_config_byte(pdev, 0x55, 0xEE);
-	/* Select PIO0 8bit clocking */
-	pci_write_config_byte(pdev, 0x54, 0xB7);
+	ns87415_fixup(pdev);
+
 	return ata_pci_sff_init_one(pdev, ppi, &ns87415_sht, NULL);
 }
 
@@ -384,6 +389,23 @@ static const struct pci_device_id ns87415_pci_tbl[] = {
 	{ }	/* terminate list */
 };
 
+#ifdef CONFIG_PM
+static int ns87415_reinit_one(struct pci_dev *pdev)
+{
+	struct ata_host *host = dev_get_drvdata(&pdev->dev);
+	int rc;
+
+	rc = ata_pci_device_do_resume(pdev);
+	if (rc)
+		return rc;
+
+	ns87415_fixup(pdev);
+
+	ata_host_resume(host);
+	return 0;
+}
+#endif
+
 static struct pci_driver ns87415_pci_driver = {
 	.name			= DRV_NAME,
 	.id_table		= ns87415_pci_tbl,
@@ -391,7 +413,7 @@ static struct pci_driver ns87415_pci_driver = {
 	.remove			= ata_pci_remove_one,
 #ifdef CONFIG_PM
 	.suspend		= ata_pci_device_suspend,
-	.resume			= ata_pci_device_resume,
+	.resume			= ns87415_reinit_one,
 #endif
 };
 

commit 14bdef982caeda19afe34010482867c18217c641
Author: Erik Inge Bolsø <knan-lkml@anduin.net>
Date:   Sat Mar 14 21:38:24 2009 +0100

    [libata] convert drivers to use ata.h mode mask defines
    
    No functional changes in this patch.
    
    Signed-off-by: Erik Inge Bolsø <knan-lkml@anduin.net>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index 89bf5f865d6a..773b1590b492 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -346,8 +346,8 @@ static int ns87415_init_one (struct pci_dev *pdev, const struct pci_device_id *e
 	static int printed_version;
 	static const struct ata_port_info info = {
 		.flags		= ATA_FLAG_SLAVE_POSS,
-		.pio_mask	= 0x1f,	/* pio0-4 */
-		.mwdma_mask	= 0x07, /* mwdma0-2 */
+		.pio_mask	= ATA_PIO4,
+		.mwdma_mask	= ATA_MWDMA2,
 		.port_ops	= &ns87415_pata_ops,
 	};
 	const struct ata_port_info *ppi[] = { &info, NULL };
@@ -355,8 +355,8 @@ static int ns87415_init_one (struct pci_dev *pdev, const struct pci_device_id *e
 #if defined(CONFIG_SUPERIO)
 	static const struct ata_port_info info87560 = {
 		.flags		= ATA_FLAG_SLAVE_POSS,
-		.pio_mask	= 0x1f,	/* pio0-4 */
-		.mwdma_mask	= 0x07, /* mwdma0-2 */
+		.pio_mask	= ATA_PIO4,
+		.mwdma_mask	= ATA_MWDMA2,
 		.port_ops	= &ns87560_pata_ops,
 	};
 

commit ab77163008c596aad9624ceab190d840c0143fa8
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Oct 27 15:09:10 2008 +0000

    ata: Switch all my stuff to a common address
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index e0aa7eaaee0a..89bf5f865d6a 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -1,7 +1,7 @@
 /*
  *    pata_ns87415.c - NS87415 (non PARISC) PATA
  *
- *	(C) 2005 Red Hat <alan@redhat.com>
+ *	(C) 2005 Red Hat <alan@lxorguk.ukuu.org.uk>
  *
  *    This is a fairly generic MWDMA controller. It has some limitations
  *    as it requires timing reloads on PIO/DMA transitions but it is otherwise

commit 07633b5d0723ce2ec31262e1096dcf61311bf078
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed May 14 16:17:00 2008 -0700

    ata: remove FIT() macro
    
    Use the kernel-provided clamp_val() macro.
    
    FIT was always applied to a member of struct ata_timing (unsigned short)
    and two constants.  clamp_val will not cast to short anymore.
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index ae92b0049bd5..e0aa7eaaee0a 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -66,8 +66,8 @@ static void ns87415_set_mode(struct ata_port *ap, struct ata_device *adev, u8 mo
 
 	ata_timing_compute(adev, adev->pio_mode, &t, T, 0);
 
-	clocking = 17 - FIT(t.active, 2, 17);
-	clocking |= (16 - FIT(t.recover, 1, 16)) << 4;
+	clocking = 17 - clamp_val(t.active, 2, 17);
+	clocking |= (16 - clamp_val(t.recover, 1, 16)) << 4;
  	/* Use the same timing for read and write bytes */
 	clocking |= (clocking << 8);
 	pci_write_config_word(dev, timing, clocking);

commit 5682ed33aae05d10a25c95633ef9d9c062825888
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:16 2008 +0900

    libata: rename SFF port ops
    
    Add sff_ prefix to SFF specific port ops.
    
    This rename is in preparation of separating SFF support out of libata
    core layer.  This patch strictly renames ops and doesn't introduce any
    behavior difference.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index 03a52cefc010..ae92b0049bd5 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -138,7 +138,7 @@ static void ns87415_bmdma_setup(struct ata_queued_cmd *qc)
 		dmactl |= ATA_DMA_WR;
 	iowrite8(dmactl, ap->ioaddr.bmdma_addr + ATA_DMA_CMD);
 	/* issue r/w command */
-	ap->ops->exec_command(ap, &qc->tf);
+	ap->ops->sff_exec_command(ap, &qc->tf);
 }
 
 /**
@@ -306,7 +306,7 @@ static struct ata_port_operations ns87415_pata_ops = {
 	.bmdma_setup		= ns87415_bmdma_setup,
 	.bmdma_start		= ns87415_bmdma_start,
 	.bmdma_stop		= ns87415_bmdma_stop,
-	.irq_clear		= ns87415_irq_clear,
+	.sff_irq_clear		= ns87415_irq_clear,
 
 	.cable_detect		= ata_cable_40wire,
 	.set_piomode		= ns87415_set_piomode,
@@ -315,8 +315,8 @@ static struct ata_port_operations ns87415_pata_ops = {
 #if defined(CONFIG_SUPERIO)
 static struct ata_port_operations ns87560_pata_ops = {
 	.inherits		= &ns87415_pata_ops,
-	.tf_read		= ns87560_tf_read,
-	.check_status		= ns87560_check_status,
+	.sff_tf_read		= ns87560_tf_read,
+	.sff_check_status	= ns87560_check_status,
 	.bmdma_status		= ns87560_bmdma_status,
 };
 #endif

commit 9363c3825ea9ad76561eb48a395349dd29211ed6
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:16 2008 +0900

    libata: rename SFF functions
    
    SFF functions have confusing names.  Some have sff prefix, some have
    bmdma, some std, some pci and some none.  Unify the naming by...
    
    * SFF functions which are common to both BMDMA and non-BMDMA are
      prefixed with ata_sff_.
    
    * SFF functions which are specific to BMDMA are prefixed with
      ata_bmdma_.
    
    * SFF functions which are specific to PCI but apply to both BMDMA and
      non-BMDMA are prefixed with ata_pci_sff_.
    
    * SFF functions which are specific to PCI and BMDMA are prefixed with
      ata_pci_bmdma_.
    
    * Drop generic prefixes from LLD specific routines.  For example,
      bfin_std_dev_select -> bfin_dev_select.
    
    The following renames are noteworthy.
    
      ata_qc_issue_prot() -> ata_sff_qc_issue()
      ata_pci_default_filter() -> ata_bmdma_mode_filter()
      ata_dev_try_classify() -> ata_sff_dev_classify()
    
    This rename is in preparation of separating SFF support out of libata
    core layer.  This patch strictly renames functions and doesn't
    introduce any behavior difference.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index cdd79d6fc0ee..03a52cefc010 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -172,14 +172,14 @@ static void ns87415_bmdma_stop(struct ata_queued_cmd *qc)
 }
 
 /**
- *	ns87415_bmdma_irq_clear		-	Clear interrupt
+ *	ns87415_irq_clear		-	Clear interrupt
  *	@ap: Channel to clear
  *
  *	Erratum: Due to a chip bug regisers 02 and 0A bit 1 and 2 (the
  *	error bits) are reset by writing to register 00 or 08.
  */
 
-static void ns87415_bmdma_irq_clear(struct ata_port *ap)
+static void ns87415_irq_clear(struct ata_port *ap)
 {
 	void __iomem *mmio = ap->ioaddr.bmdma_addr;
 
@@ -306,7 +306,7 @@ static struct ata_port_operations ns87415_pata_ops = {
 	.bmdma_setup		= ns87415_bmdma_setup,
 	.bmdma_start		= ns87415_bmdma_start,
 	.bmdma_stop		= ns87415_bmdma_stop,
-	.irq_clear		= ns87415_bmdma_irq_clear,
+	.irq_clear		= ns87415_irq_clear,
 
 	.cable_detect		= ata_cable_40wire,
 	.set_piomode		= ns87415_set_piomode,
@@ -375,7 +375,7 @@ static int ns87415_init_one (struct pci_dev *pdev, const struct pci_device_id *e
 	pci_write_config_byte(pdev, 0x55, 0xEE);
 	/* Select PIO0 8bit clocking */
 	pci_write_config_byte(pdev, 0x54, 0xB7);
-	return ata_pci_init_one(pdev, ppi, &ns87415_sht, NULL);
+	return ata_pci_sff_init_one(pdev, ppi, &ns87415_sht, NULL);
 }
 
 static const struct pci_device_id ns87415_pci_tbl[] = {

commit 887125e3740283be25564bfc6fb5d24974b651ab
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:49 2008 +0900

    libata: stop overloading port_info->private_data
    
    port_info->private_data is currently used for two purposes - to record
    private data about the port_info or to specify host->private_data to
    use when allocating ata_host.
    
    This overloading is confusing and counter-intuitive in that
    port_info->private_data becomes host->private_data instead of
    port->private_data.  In addition, port_info and host don't correspond
    to each other 1-to-1.  Currently, the first non-NULL
    port_info->private_data is used.
    
    This patch makes port_info->private_data just be what it is -
    private_data for the port_info where LLD can jot down extra info.
    libata no longer sets host->private_data to the first non-NULL
    port_info->private_data, @host_priv argument is added to
    ata_pci_init_one() instead.  LLDs which use ata_pci_init_one() can use
    this argument to pass in pointer to host private data.  LLDs which
    don't should use init-register model anyway and can initialize
    host->private_data directly.
    
    Adding @host_priv instead of using init-register model for LLDs which
    use ata_pci_init_one() is suggested by Alan Cox.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index 42508940e4a9..cdd79d6fc0ee 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -375,7 +375,7 @@ static int ns87415_init_one (struct pci_dev *pdev, const struct pci_device_id *e
 	pci_write_config_byte(pdev, 0x55, 0xEE);
 	/* Select PIO0 8bit clocking */
 	pci_write_config_byte(pdev, 0x54, 0xB7);
-	return ata_pci_init_one(pdev, ppi, &ns87415_sht);
+	return ata_pci_init_one(pdev, ppi, &ns87415_sht, NULL);
 }
 
 static const struct pci_device_id ns87415_pci_tbl[] = {

commit 1bd5b715a305f6f13455e89becbd839010dd14b5
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:49 2008 +0900

    libata: make ata_pci_init_one() not use ops->irq_handler and pi->sht
    
    ata_pci_init_one() is the only function which uses ops->irq_handler
    and pi->sht.  Other initialization functions take the same information
    as arguments.  This causes confusion and duplicate unused entries in
    structures.
    
    Make ata_pci_init_one() take sht as an argument and use ata_interrupt
    implicitly.  All current users use ata_interrupt and if different irq
    handler is necessary open coding ata_pci_init_one() using
    ata_prepare_sff_host() and ata_activate_sff_host can be done under ten
    lines including error handling and driver which requires custom
    interrupt handler is likely to require custom initialization anyway.
    
    As ata_pci_init_one() was the last user of ops->irq_handler, this
    patch also kills the field.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index 38d86a262dbb..42508940e4a9 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -345,7 +345,6 @@ static int ns87415_init_one (struct pci_dev *pdev, const struct pci_device_id *e
 {
 	static int printed_version;
 	static const struct ata_port_info info = {
-		.sht		= &ns87415_sht,
 		.flags		= ATA_FLAG_SLAVE_POSS,
 		.pio_mask	= 0x1f,	/* pio0-4 */
 		.mwdma_mask	= 0x07, /* mwdma0-2 */
@@ -355,7 +354,6 @@ static int ns87415_init_one (struct pci_dev *pdev, const struct pci_device_id *e
 	int rc;
 #if defined(CONFIG_SUPERIO)
 	static const struct ata_port_info info87560 = {
-		.sht		= &ns87415_sht,
 		.flags		= ATA_FLAG_SLAVE_POSS,
 		.pio_mask	= 0x1f,	/* pio0-4 */
 		.mwdma_mask	= 0x07, /* mwdma0-2 */
@@ -377,7 +375,7 @@ static int ns87415_init_one (struct pci_dev *pdev, const struct pci_device_id *e
 	pci_write_config_byte(pdev, 0x55, 0xEE);
 	/* Select PIO0 8bit clocking */
 	pci_write_config_byte(pdev, 0x54, 0xB7);
-	return ata_pci_init_one(pdev, ppi);
+	return ata_pci_init_one(pdev, ppi, &ns87415_sht);
 }
 
 static const struct pci_device_id ns87415_pci_tbl[] = {

commit 029cfd6b74fc5c517865fad78cf4a3ea8d9b664a
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:49 2008 +0900

    libata: implement and use ops inheritance
    
    libata lets low level drivers build ata_port_operations table and
    register it with libata core layer.  This allows low level drivers
    high level of flexibility but also burdens them with lots of
    boilerplate entries.
    
    This becomes worse for drivers which support related similar
    controllers which differ slightly.  They share most of the operations
    except for a few.  However, the driver still needs to list all
    operations for each variant.  This results in large number of
    duplicate entries, which is not only inefficient but also error-prone
    as it becomes very difficult to tell what the actual differences are.
    
    This duplicate boilerplates all over the low level drivers also make
    updating the core layer exteremely difficult and error-prone.  When
    compounded with multi-branched development model, it ends up
    accumulating inconsistencies over time.  Some of those inconsistencies
    cause immediate problems and fixed.  Others just remain there dormant
    making maintenance increasingly difficult.
    
    To rectify the problem, this patch implements ata_port_operations
    inheritance.  To allow LLDs to easily re-use their own ops tables
    overriding only specific methods, this patch implements poor man's
    class inheritance.  An ops table has ->inherits field which can be set
    to any ops table as long as it doesn't create a loop.  When the host
    is started, the inheritance chain is followed and any operation which
    isn't specified is taken from the nearest ancestor which has it
    specified.  This operation is called finalization and done only once
    per an ops table and the LLD doesn't have to do anything special about
    it other than making the ops table non-const such that libata can
    update it.
    
    libata provides four base ops tables lower drivers can inherit from -
    base, sata, pmp, sff and bmdma.  To avoid overriding these ops
    accidentaly, these ops are declared const and LLDs should always
    inherit these instead of using them directly.
    
    After finalization, all the ops table are identical before and after
    the patch except for setting .irq_handler to ata_interrupt in drivers
    which didn't use to.  The .irq_handler doesn't have any actual effect
    and the field will soon be removed by later patch.
    
    * sata_sx4 is still using old style EH and currently doesn't take
      advantage of ops inheritance.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index 78d634423cbf..38d86a262dbb 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -297,73 +297,29 @@ static u8 ns87560_bmdma_status(struct ata_port *ap)
 {
 	return ns87560_read_buggy(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
 }
+#endif		/* 87560 SuperIO Support */
 
-static const struct ata_port_operations ns87560_pata_ops = {
-	.set_piomode		= ns87415_set_piomode,
-	.mode_filter		= ata_pci_default_filter,
+static struct ata_port_operations ns87415_pata_ops = {
+	.inherits		= &ata_bmdma_port_ops,
 
-	.tf_load		= ata_tf_load,
-	.tf_read		= ns87560_tf_read,
-	.check_status		= ns87560_check_status,
 	.check_atapi_dma	= ns87415_check_atapi_dma,
-	.exec_command		= ata_exec_command,
-	.dev_select		= ata_std_dev_select,
-
-	.freeze			= ata_bmdma_freeze,
-	.thaw			= ata_bmdma_thaw,
-	.error_handler		= ata_bmdma_error_handler,
-	.post_internal_cmd 	= ata_bmdma_post_internal_cmd,
-	.cable_detect		= ata_cable_40wire,
-
 	.bmdma_setup		= ns87415_bmdma_setup,
 	.bmdma_start		= ns87415_bmdma_start,
 	.bmdma_stop		= ns87415_bmdma_stop,
-	.bmdma_status		= ns87560_bmdma_status,
-	.qc_prep		= ata_qc_prep,
-	.qc_issue		= ata_qc_issue_prot,
-	.data_xfer		= ata_data_xfer,
-
-	.irq_handler		= ata_interrupt,
 	.irq_clear		= ns87415_bmdma_irq_clear,
-	.irq_on			= ata_irq_on,
-
-	.port_start		= ata_sff_port_start,
-};
-
-#endif		/* 87560 SuperIO Support */
-
-
-static const struct ata_port_operations ns87415_pata_ops = {
-	.set_piomode		= ns87415_set_piomode,
-	.mode_filter		= ata_pci_default_filter,
 
-	.tf_load		= ata_tf_load,
-	.tf_read		= ata_tf_read,
-	.check_status		= ata_check_status,
-	.check_atapi_dma	= ns87415_check_atapi_dma,
-	.exec_command		= ata_exec_command,
-	.dev_select		= ata_std_dev_select,
-
-	.freeze			= ata_bmdma_freeze,
-	.thaw			= ata_bmdma_thaw,
-	.error_handler		= ata_bmdma_error_handler,
-	.post_internal_cmd 	= ata_bmdma_post_internal_cmd,
 	.cable_detect		= ata_cable_40wire,
+	.set_piomode		= ns87415_set_piomode,
+};
 
-	.bmdma_setup		= ns87415_bmdma_setup,
-	.bmdma_start		= ns87415_bmdma_start,
-	.bmdma_stop		= ns87415_bmdma_stop,
-	.bmdma_status		= ata_bmdma_status,
-	.qc_prep		= ata_qc_prep,
-	.qc_issue		= ata_qc_issue_prot,
-	.data_xfer		= ata_data_xfer,
-
-	.irq_handler		= ata_interrupt,
-	.irq_clear		= ns87415_bmdma_irq_clear,
-	.irq_on			= ata_irq_on,
-
-	.port_start		= ata_sff_port_start,
+#if defined(CONFIG_SUPERIO)
+static struct ata_port_operations ns87560_pata_ops = {
+	.inherits		= &ns87415_pata_ops,
+	.tf_read		= ns87560_tf_read,
+	.check_status		= ns87560_check_status,
+	.bmdma_status		= ns87560_bmdma_status,
 };
+#endif
 
 static struct scsi_host_template ns87415_sht = {
 	ATA_BMDMA_SHT(DRV_NAME),

commit 68d1d07b510bb57a504588adc2bd2758adea0965
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:49 2008 +0900

    libata: implement and use SHT initializers
    
    libata lets low level drivers build scsi_host_template and register it
    to the SCSI layer.  This allows low level drivers high level of
    flexibility but also burdens them with lots of boilerplate entries.
    
    This patch implements SHT initializers which can be used to initialize
    all the boilerplate entries in a sht.  Three variants of them are
    implemented - BASE, BMDMA and NCQ - for different types of drivers.
    Note that entries can be overriden by putting individual initializers
    after the helper macro.
    
    All sht tables are identical before and after this patch.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index 93eb958cb0c9..78d634423cbf 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -366,21 +366,7 @@ static const struct ata_port_operations ns87415_pata_ops = {
 };
 
 static struct scsi_host_template ns87415_sht = {
-	.module			= THIS_MODULE,
-	.name			= DRV_NAME,
-	.ioctl			= ata_scsi_ioctl,
-	.queuecommand		= ata_scsi_queuecmd,
-	.can_queue		= ATA_DEF_QUEUE,
-	.this_id		= ATA_SHT_THIS_ID,
-	.sg_tablesize		= LIBATA_MAX_PRD,
-	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
-	.emulated		= ATA_SHT_EMULATED,
-	.use_clustering		= ATA_SHT_USE_CLUSTERING,
-	.proc_name		= DRV_NAME,
-	.dma_boundary		= ATA_DMA_BOUNDARY,
-	.slave_configure	= ata_scsi_slave_config,
-	.slave_destroy		= ata_scsi_slave_destroy,
-	.bios_param		= ata_std_bios_param,
+	ATA_BMDMA_SHT(DRV_NAME),
 };
 
 

commit f08048e94564d009b19038cfbdd800aa83e79c7f
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:47 2008 +0900

    libata: PCI device should be powered up before being accessed
    
    PCI device should be powered up or powered up before its PCI regsiters
    are accessed.  Although PCI configuration register access is allowed
    in D3hot, PCI device is free to reset its status when transiting from
    D3hot to D0 causing configuration data to change.
    
    Many libata SFF drivers which use ata_pci_init_one() read and update
    configuration registers before calling ata_pci_init_one() which
    enables the PCI device.  Also, in resume paths, some drivers access
    registers without resuming the PCI device.
    
    This patch adds a call to pcim_enable_device() in init path if
    register is accessed before calling ata_pci_init_one() and make resume
    paths first resume PCI devices, access PCI configuration regiters then
    resume ATA host.
    
    While at it...
    
    * cmd640 was strange in that it set ->resume even when CONFIG_PM is
      not.  This is by-product of minimal build fix.  Updated.
    
    * In cs5530, Don't BUG() on reinit failure.  Just whine and fail
      resume.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index d0e2e50823b1..93eb958cb0c9 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -410,6 +410,7 @@ static int ns87415_init_one (struct pci_dev *pdev, const struct pci_device_id *e
 		.port_ops	= &ns87415_pata_ops,
 	};
 	const struct ata_port_info *ppi[] = { &info, NULL };
+	int rc;
 #if defined(CONFIG_SUPERIO)
 	static const struct ata_port_info info87560 = {
 		.sht		= &ns87415_sht,
@@ -425,6 +426,11 @@ static int ns87415_init_one (struct pci_dev *pdev, const struct pci_device_id *e
 	if (!printed_version++)
 		dev_printk(KERN_DEBUG, &pdev->dev,
 			   "version " DRV_VERSION "\n");
+
+	rc = pcim_enable_device(pdev);
+	if (rc)
+		return rc;
+
 	/* Select 512 byte sectors */
 	pci_write_config_byte(pdev, 0x55, 0xEE);
 	/* Select PIO0 8bit clocking */

commit a9efacbad1a735ec410acb26c9de72be8efb33d5
Author: Frank Lichtenheld <frank@lichtenheld.de>
Date:   Mon Oct 29 02:49:20 2007 +0100

    pata_ns87415: define SUPERIO_IDE_MAX_RETRIES
    
    Code copied from drivers/ide/pci/ns87415.c uses this, so copy the
    definition from there as well.
    
    Fixes the following build error:
      CC [M]  drivers/ata/pata_ns87415.o
    drivers/ata/pata_ns87415.c: In function ‘ns87560_read_buggy’:
    drivers/ata/pata_ns87415.c:228: error: ‘SUPERIO_IDE_MAX_RETRIES’ undeclared (first use in this function)
    drivers/ata/pata_ns87415.c:228: error: (Each undeclared identifier is reported only once
    drivers/ata/pata_ns87415.c:228: error: for each function it appears in.)
    
    Signed-off-by: Frank Lichtenheld <frank@lichtenheld.de>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index b9a17eb100d0..d0e2e50823b1 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -215,6 +215,8 @@ static int ns87415_check_atapi_dma(struct ata_queued_cmd *qc)
 
 #include <asm/superio.h>
 
+#define SUPERIO_IDE_MAX_RETRIES 25
+
 /**
  *	ns87560_read_buggy	-	workaround buggy Super I/O chip
  *	@port: Port to read

commit 2dcb407e61458ded17503d6bd12b8c064965368b
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Oct 19 06:42:56 2007 -0400

    [libata] checkpatch-inspired cleanups
    
    Tackle the relatively sane complaints of checkpatch --file.
    
    The vast majority is indentation and whitespace changes, the rest are
    
    * #include fixes
    * printk KERN_xxx prefix addition
    * BSS/initializer cleanups
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
index bb97ef583f9b..b9a17eb100d0 100644
--- a/drivers/ata/pata_ns87415.c
+++ b/drivers/ata/pata_ns87415.c
@@ -17,7 +17,7 @@
  *    TODO:
  *	Test PARISC SuperIO
  *	Get someone to test on SPARC
- *	Implement lazy pio/dma switching for better performance	
+ *	Implement lazy pio/dma switching for better performance
  *	8bit shared timing.
  *	See if we need to kill the FIFO for ATAPI
  */
@@ -60,10 +60,10 @@ static void ns87415_set_mode(struct ata_port *ap, struct ata_device *adev, u8 mo
 	u16 clocking;
 	u8 iordy;
 	u8 status;
-	
+
 	/* Timing register format is 17 - low nybble read timing with
 	   the high nybble being 16 - x for recovery time in PCI clocks */
-   
+
 	ata_timing_compute(adev, adev->pio_mode, &t, T, 0);
 
 	clocking = 17 - FIT(t.active, 2, 17);
@@ -71,7 +71,7 @@ static void ns87415_set_mode(struct ata_port *ap, struct ata_device *adev, u8 mo
  	/* Use the same timing for read and write bytes */
 	clocking |= (clocking << 8);
 	pci_write_config_word(dev, timing, clocking);
-	
+
 	/* Set the IORDY enable versus DMA enable on or off properly */
 	pci_read_config_byte(dev, 0x42, &iordy);
 	iordy &= ~(1 << (4 + unit));
@@ -185,7 +185,7 @@ static void ns87415_bmdma_irq_clear(struct ata_port *ap)
 
 	if (!mmio)
 		return;
-	iowrite8((ioread8(mmio + ATA_DMA_CMD) | ATA_DMA_INTR | ATA_DMA_ERR), 
+	iowrite8((ioread8(mmio + ATA_DMA_CMD) | ATA_DMA_INTR | ATA_DMA_ERR),
 			mmio + ATA_DMA_CMD);
 }
 

commit c4b5b7b6c4423ec4ced4177c87d2da04de324028
Author: Alan Cox <alan@redhat.com>
Date:   Sat Sep 29 02:35:10 2007 -0400

    pata_ns87415: Initial cut at 87415/87560 IDE support
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    [plus SuperIO fixes by Kyle McMartin]
    [plus a cleanup from me]
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_ns87415.c b/drivers/ata/pata_ns87415.c
new file mode 100644
index 000000000000..bb97ef583f9b
--- /dev/null
+++ b/drivers/ata/pata_ns87415.c
@@ -0,0 +1,467 @@
+/*
+ *    pata_ns87415.c - NS87415 (non PARISC) PATA
+ *
+ *	(C) 2005 Red Hat <alan@redhat.com>
+ *
+ *    This is a fairly generic MWDMA controller. It has some limitations
+ *    as it requires timing reloads on PIO/DMA transitions but it is otherwise
+ *    fairly well designed.
+ *
+ *    This driver assumes the firmware has left the chip in a valid ST506
+ *    compliant state, either legacy IRQ 14/15 or native INTA shared. You
+ *    may need to add platform code if your system fails to do this.
+ *
+ *    The same cell appears in the 87560 controller used by some PARISC
+ *    systems. This has its own special mountain of errata.
+ *
+ *    TODO:
+ *	Test PARISC SuperIO
+ *	Get someone to test on SPARC
+ *	Implement lazy pio/dma switching for better performance	
+ *	8bit shared timing.
+ *	See if we need to kill the FIFO for ATAPI
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <scsi/scsi_host.h>
+#include <linux/libata.h>
+#include <linux/ata.h>
+
+#define DRV_NAME	"pata_ns87415"
+#define DRV_VERSION	"0.0.1"
+
+/**
+ *	ns87415_set_mode - Initialize host controller mode timings
+ *	@ap: Port whose timings we are configuring
+ *	@adev: Device whose timings we are configuring
+ *	@mode: Mode to set
+ *
+ *	Program the mode registers for this controller, channel and
+ *	device. Because the chip is quite an old design we have to do this
+ *	for PIO/DMA switches.
+ *
+ *	LOCKING:
+ *	None (inherited from caller).
+ */
+
+static void ns87415_set_mode(struct ata_port *ap, struct ata_device *adev, u8 mode)
+{
+	struct pci_dev *dev	= to_pci_dev(ap->host->dev);
+	int unit		= 2 * ap->port_no + adev->devno;
+	int timing		= 0x44 + 2 * unit;
+	unsigned long T		= 1000000000 / 33333;	/* PCI clocks */
+	struct ata_timing t;
+	u16 clocking;
+	u8 iordy;
+	u8 status;
+	
+	/* Timing register format is 17 - low nybble read timing with
+	   the high nybble being 16 - x for recovery time in PCI clocks */
+   
+	ata_timing_compute(adev, adev->pio_mode, &t, T, 0);
+
+	clocking = 17 - FIT(t.active, 2, 17);
+	clocking |= (16 - FIT(t.recover, 1, 16)) << 4;
+ 	/* Use the same timing for read and write bytes */
+	clocking |= (clocking << 8);
+	pci_write_config_word(dev, timing, clocking);
+	
+	/* Set the IORDY enable versus DMA enable on or off properly */
+	pci_read_config_byte(dev, 0x42, &iordy);
+	iordy &= ~(1 << (4 + unit));
+	if (mode >= XFER_MW_DMA_0 || !ata_pio_need_iordy(adev))
+		iordy |= (1 << (4 + unit));
+
+	/* Paranoia: We shouldn't ever get here with busy write buffers
+	   but if so wait */
+
+	pci_read_config_byte(dev, 0x43, &status);
+	while (status & 0x03) {
+		udelay(1);
+		pci_read_config_byte(dev, 0x43, &status);
+	}
+	/* Flip the IORDY/DMA bits now we are sure the write buffers are
+	   clear */
+	pci_write_config_byte(dev, 0x42, iordy);
+
+	/* TODO: Set byte 54 command timing to the best 8bit
+	   mode shared by all four devices */
+}
+
+/**
+ *	ns87415_set_piomode - Initialize host controller PATA PIO timings
+ *	@ap: Port whose timings we are configuring
+ *	@adev: Device to program
+ *
+ *	Set PIO mode for device, in host controller PCI config space.
+ *
+ *	LOCKING:
+ *	None (inherited from caller).
+ */
+
+static void ns87415_set_piomode(struct ata_port *ap, struct ata_device *adev)
+{
+	ns87415_set_mode(ap, adev, adev->pio_mode);
+}
+
+/**
+ *	ns87415_bmdma_setup		-	Set up DMA
+ *	@qc: Command block
+ *
+ *	Set up for bus masterng DMA. We have to do this ourselves
+ *	rather than use the helper due to a chip erratum
+ */
+
+static void ns87415_bmdma_setup(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	unsigned int rw = (qc->tf.flags & ATA_TFLAG_WRITE);
+	u8 dmactl;
+
+	/* load PRD table addr. */
+	mb();	/* make sure PRD table writes are visible to controller */
+	iowrite32(ap->prd_dma, ap->ioaddr.bmdma_addr + ATA_DMA_TABLE_OFS);
+
+	/* specify data direction, triple-check start bit is clear */
+	dmactl = ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_CMD);
+	dmactl &= ~(ATA_DMA_WR | ATA_DMA_START);
+	/* Due to an erratum we need to write these bits to the wrong
+	   place - which does save us an I/O bizarrely */
+	dmactl |= ATA_DMA_INTR | ATA_DMA_ERR;
+	if (!rw)
+		dmactl |= ATA_DMA_WR;
+	iowrite8(dmactl, ap->ioaddr.bmdma_addr + ATA_DMA_CMD);
+	/* issue r/w command */
+	ap->ops->exec_command(ap, &qc->tf);
+}
+
+/**
+ *	ns87415_bmdma_start		-	Begin DMA transfer
+ *	@qc: Command block
+ *
+ *	Switch the timings for the chip and set up for a DMA transfer
+ *	before the DMA burst begins.
+ *
+ *	FIXME: We should do lazy switching on bmdma_start versus
+ *	ata_pio_data_xfer for better performance.
+ */
+
+static void ns87415_bmdma_start(struct ata_queued_cmd *qc)
+{
+	ns87415_set_mode(qc->ap, qc->dev, qc->dev->dma_mode);
+	ata_bmdma_start(qc);
+}
+
+/**
+ *	ns87415_bmdma_stop		-	End DMA transfer
+ *	@qc: Command block
+ *
+ *	End DMA mode and switch the controller back into PIO mode
+ */
+
+static void ns87415_bmdma_stop(struct ata_queued_cmd *qc)
+{
+	ata_bmdma_stop(qc);
+	ns87415_set_mode(qc->ap, qc->dev, qc->dev->pio_mode);
+}
+
+/**
+ *	ns87415_bmdma_irq_clear		-	Clear interrupt
+ *	@ap: Channel to clear
+ *
+ *	Erratum: Due to a chip bug regisers 02 and 0A bit 1 and 2 (the
+ *	error bits) are reset by writing to register 00 or 08.
+ */
+
+static void ns87415_bmdma_irq_clear(struct ata_port *ap)
+{
+	void __iomem *mmio = ap->ioaddr.bmdma_addr;
+
+	if (!mmio)
+		return;
+	iowrite8((ioread8(mmio + ATA_DMA_CMD) | ATA_DMA_INTR | ATA_DMA_ERR), 
+			mmio + ATA_DMA_CMD);
+}
+
+/**
+ *	ns87415_check_atapi_dma		-	ATAPI DMA filter
+ *	@qc: Command block
+ *
+ *	Disable ATAPI DMA (for now). We may be able to do DMA if we
+ *	kill the prefetching. This isn't clear.
+ */
+
+static int ns87415_check_atapi_dma(struct ata_queued_cmd *qc)
+{
+	return -EOPNOTSUPP;
+}
+
+#if defined(CONFIG_SUPERIO)
+
+/* SUPERIO 87560 is a PoS chip that NatSem denies exists.
+ * Unfortunately, it's built-in on all Astro-based PA-RISC workstations
+ * which use the integrated NS87514 cell for CD-ROM support.
+ * i.e we have to support for CD-ROM installs.
+ * See drivers/parisc/superio.c for more gory details.
+ *
+ * Workarounds taken from drivers/ide/pci/ns87415.c
+ */
+
+#include <asm/superio.h>
+
+/**
+ *	ns87560_read_buggy	-	workaround buggy Super I/O chip
+ *	@port: Port to read
+ *
+ *	Work around chipset problems in the 87560 SuperIO chip
+ */
+
+static u8 ns87560_read_buggy(void __iomem *port)
+{
+	u8 tmp;
+	int retries = SUPERIO_IDE_MAX_RETRIES;
+	do {
+		tmp = ioread8(port);
+		if (tmp != 0)
+			return tmp;
+		udelay(50);
+	} while(retries-- > 0);
+	return tmp;
+}
+
+/**
+ *	ns87560_check_status
+ *	@ap: channel to check
+ *
+ *	Return the status of the channel working around the
+ *	87560 flaws.
+ */
+
+static u8 ns87560_check_status(struct ata_port *ap)
+{
+	return ns87560_read_buggy(ap->ioaddr.status_addr);
+}
+
+/**
+ *	ns87560_tf_read - input device's ATA taskfile shadow registers
+ *	@ap: Port from which input is read
+ *	@tf: ATA taskfile register set for storing input
+ *
+ *	Reads ATA taskfile registers for currently-selected device
+ *	into @tf. Work around the 87560 bugs.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+void ns87560_tf_read(struct ata_port *ap, struct ata_taskfile *tf)
+{
+	struct ata_ioports *ioaddr = &ap->ioaddr;
+
+	tf->command = ns87560_check_status(ap);
+	tf->feature = ioread8(ioaddr->error_addr);
+	tf->nsect = ioread8(ioaddr->nsect_addr);
+	tf->lbal = ioread8(ioaddr->lbal_addr);
+	tf->lbam = ioread8(ioaddr->lbam_addr);
+	tf->lbah = ioread8(ioaddr->lbah_addr);
+	tf->device = ns87560_read_buggy(ioaddr->device_addr);
+
+	if (tf->flags & ATA_TFLAG_LBA48) {
+		iowrite8(tf->ctl | ATA_HOB, ioaddr->ctl_addr);
+		tf->hob_feature = ioread8(ioaddr->error_addr);
+		tf->hob_nsect = ioread8(ioaddr->nsect_addr);
+		tf->hob_lbal = ioread8(ioaddr->lbal_addr);
+		tf->hob_lbam = ioread8(ioaddr->lbam_addr);
+		tf->hob_lbah = ioread8(ioaddr->lbah_addr);
+		iowrite8(tf->ctl, ioaddr->ctl_addr);
+		ap->last_ctl = tf->ctl;
+	}
+}
+
+/**
+ *	ns87560_bmdma_status
+ *	@ap: channel to check
+ *
+ *	Return the DMA status of the channel working around the
+ *	87560 flaws.
+ */
+
+static u8 ns87560_bmdma_status(struct ata_port *ap)
+{
+	return ns87560_read_buggy(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
+}
+
+static const struct ata_port_operations ns87560_pata_ops = {
+	.set_piomode		= ns87415_set_piomode,
+	.mode_filter		= ata_pci_default_filter,
+
+	.tf_load		= ata_tf_load,
+	.tf_read		= ns87560_tf_read,
+	.check_status		= ns87560_check_status,
+	.check_atapi_dma	= ns87415_check_atapi_dma,
+	.exec_command		= ata_exec_command,
+	.dev_select		= ata_std_dev_select,
+
+	.freeze			= ata_bmdma_freeze,
+	.thaw			= ata_bmdma_thaw,
+	.error_handler		= ata_bmdma_error_handler,
+	.post_internal_cmd 	= ata_bmdma_post_internal_cmd,
+	.cable_detect		= ata_cable_40wire,
+
+	.bmdma_setup		= ns87415_bmdma_setup,
+	.bmdma_start		= ns87415_bmdma_start,
+	.bmdma_stop		= ns87415_bmdma_stop,
+	.bmdma_status		= ns87560_bmdma_status,
+	.qc_prep		= ata_qc_prep,
+	.qc_issue		= ata_qc_issue_prot,
+	.data_xfer		= ata_data_xfer,
+
+	.irq_handler		= ata_interrupt,
+	.irq_clear		= ns87415_bmdma_irq_clear,
+	.irq_on			= ata_irq_on,
+
+	.port_start		= ata_sff_port_start,
+};
+
+#endif		/* 87560 SuperIO Support */
+
+
+static const struct ata_port_operations ns87415_pata_ops = {
+	.set_piomode		= ns87415_set_piomode,
+	.mode_filter		= ata_pci_default_filter,
+
+	.tf_load		= ata_tf_load,
+	.tf_read		= ata_tf_read,
+	.check_status		= ata_check_status,
+	.check_atapi_dma	= ns87415_check_atapi_dma,
+	.exec_command		= ata_exec_command,
+	.dev_select		= ata_std_dev_select,
+
+	.freeze			= ata_bmdma_freeze,
+	.thaw			= ata_bmdma_thaw,
+	.error_handler		= ata_bmdma_error_handler,
+	.post_internal_cmd 	= ata_bmdma_post_internal_cmd,
+	.cable_detect		= ata_cable_40wire,
+
+	.bmdma_setup		= ns87415_bmdma_setup,
+	.bmdma_start		= ns87415_bmdma_start,
+	.bmdma_stop		= ns87415_bmdma_stop,
+	.bmdma_status		= ata_bmdma_status,
+	.qc_prep		= ata_qc_prep,
+	.qc_issue		= ata_qc_issue_prot,
+	.data_xfer		= ata_data_xfer,
+
+	.irq_handler		= ata_interrupt,
+	.irq_clear		= ns87415_bmdma_irq_clear,
+	.irq_on			= ata_irq_on,
+
+	.port_start		= ata_sff_port_start,
+};
+
+static struct scsi_host_template ns87415_sht = {
+	.module			= THIS_MODULE,
+	.name			= DRV_NAME,
+	.ioctl			= ata_scsi_ioctl,
+	.queuecommand		= ata_scsi_queuecmd,
+	.can_queue		= ATA_DEF_QUEUE,
+	.this_id		= ATA_SHT_THIS_ID,
+	.sg_tablesize		= LIBATA_MAX_PRD,
+	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
+	.emulated		= ATA_SHT_EMULATED,
+	.use_clustering		= ATA_SHT_USE_CLUSTERING,
+	.proc_name		= DRV_NAME,
+	.dma_boundary		= ATA_DMA_BOUNDARY,
+	.slave_configure	= ata_scsi_slave_config,
+	.slave_destroy		= ata_scsi_slave_destroy,
+	.bios_param		= ata_std_bios_param,
+};
+
+
+/**
+ *	ns87415_init_one - Register 87415 ATA PCI device with kernel services
+ *	@pdev: PCI device to register
+ *	@ent: Entry in ns87415_pci_tbl matching with @pdev
+ *
+ *	Called from kernel PCI layer.  We probe for combined mode (sigh),
+ *	and then hand over control to libata, for it to do the rest.
+ *
+ *	LOCKING:
+ *	Inherited from PCI layer (may sleep).
+ *
+ *	RETURNS:
+ *	Zero on success, or -ERRNO value.
+ */
+
+static int ns87415_init_one (struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	static int printed_version;
+	static const struct ata_port_info info = {
+		.sht		= &ns87415_sht,
+		.flags		= ATA_FLAG_SLAVE_POSS,
+		.pio_mask	= 0x1f,	/* pio0-4 */
+		.mwdma_mask	= 0x07, /* mwdma0-2 */
+		.port_ops	= &ns87415_pata_ops,
+	};
+	const struct ata_port_info *ppi[] = { &info, NULL };
+#if defined(CONFIG_SUPERIO)
+	static const struct ata_port_info info87560 = {
+		.sht		= &ns87415_sht,
+		.flags		= ATA_FLAG_SLAVE_POSS,
+		.pio_mask	= 0x1f,	/* pio0-4 */
+		.mwdma_mask	= 0x07, /* mwdma0-2 */
+		.port_ops	= &ns87560_pata_ops,
+	};
+
+	if (PCI_SLOT(pdev->devfn) == 0x0E)
+		ppi[0] = &info87560;
+#endif
+	if (!printed_version++)
+		dev_printk(KERN_DEBUG, &pdev->dev,
+			   "version " DRV_VERSION "\n");
+	/* Select 512 byte sectors */
+	pci_write_config_byte(pdev, 0x55, 0xEE);
+	/* Select PIO0 8bit clocking */
+	pci_write_config_byte(pdev, 0x54, 0xB7);
+	return ata_pci_init_one(pdev, ppi);
+}
+
+static const struct pci_device_id ns87415_pci_tbl[] = {
+	{ PCI_VDEVICE(NS, PCI_DEVICE_ID_NS_87415), },
+
+	{ }	/* terminate list */
+};
+
+static struct pci_driver ns87415_pci_driver = {
+	.name			= DRV_NAME,
+	.id_table		= ns87415_pci_tbl,
+	.probe			= ns87415_init_one,
+	.remove			= ata_pci_remove_one,
+#ifdef CONFIG_PM
+	.suspend		= ata_pci_device_suspend,
+	.resume			= ata_pci_device_resume,
+#endif
+};
+
+static int __init ns87415_init(void)
+{
+	return pci_register_driver(&ns87415_pci_driver);
+}
+
+static void __exit ns87415_exit(void)
+{
+	pci_unregister_driver(&ns87415_pci_driver);
+}
+
+module_init(ns87415_init);
+module_exit(ns87415_exit);
+
+MODULE_AUTHOR("Alan Cox");
+MODULE_DESCRIPTION("ATA low-level driver for NS87415 controllers");
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(pci, ns87415_pci_tbl);
+MODULE_VERSION(DRV_VERSION);
