commit b5e55556182d2e43da035df1bffbd492c72a7994
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Aug 26 12:57:25 2019 +0200

    libata: switch remaining drivers to use dma_set_mask_and_coherent
    
    Use dma_set_mask_and_coherent instead of separate dma_set_mask and
    dma_set_coherent_mask calls.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 099a5c68a4c9..9052148b306d 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -155,14 +155,10 @@ static int cs5520_init_one(struct pci_dev *pdev, const struct pci_device_id *id)
 		return -ENODEV;
 	}
 
-	if (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {
+	if (dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32))) {
 		printk(KERN_ERR DRV_NAME ": unable to configure DMA mask.\n");
 		return -ENODEV;
 	}
-	if (dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32))) {
-		printk(KERN_ERR DRV_NAME ": unable to configure consistent DMA mask.\n");
-		return -ENODEV;
-	}
 
 	/* Map IO ports and initialize host accordingly */
 	iomap[0] = devm_ioport_map(&pdev->dev, cmd_port[0], 8);

commit 3e0a4e85803345e31ae2d0009bedf252e43278cb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 23 11:14:55 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 118
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 or at your option any
      later version this program is distributed in the hope that it will
      be useful but without any warranty without even the implied warranty
      of merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 44 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190523091651.032047323@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 4cb24070cc2d..099a5c68a4c9 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *	IDE tuning and bus mastering support for the CS5510/CS5520
  *	chipsets
@@ -18,16 +19,6 @@
  *
  *	(c) Copyright Red Hat Inc 2002
  *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2, or (at your option) any
- * later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
  * Documentation:
  *	Not publicly available.
  */

commit c54c719b558e0eb3ba60b1390aeb47ed25ff4352
Author: Quentin Lambert <lambert.quentin@gmail.com>
Date:   Wed Apr 8 14:34:10 2015 +0200

    ata: remove deprecated use of pci api
    
    Replace occurences of the pci api by appropriate call to the dma api.
    
    A simplified version of the semantic patch that finds this problem is as
    follows: (http://coccinelle.lip6.fr)
    
    @deprecated@
    idexpression id;
    position p;
    @@
    
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @bad1@
    idexpression id;
    position deprecated.p;
    @@
    ...when != &id->dev
       when != pci_get_drvdata ( id )
       when != pci_enable_device ( id )
    (
      pci_dma_supported@p ( id, ...)
    |
      pci_alloc_consistent@p ( id, ...)
    )
    
    @depends on !bad1@
    idexpression id;
    expression direction;
    position deprecated.p;
    @@
    
    (
    - pci_dma_supported@p ( id,
    + dma_supported ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    |
    - pci_alloc_consistent@p ( id,
    + dma_alloc_coherent ( &id->dev,
    ...
    + , GFP_ATOMIC
      )
    )
    
    Signed-off-by: Quentin Lambert <lambert.quentin@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index d65cb9d2fa8c..4cb24070cc2d 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -164,11 +164,11 @@ static int cs5520_init_one(struct pci_dev *pdev, const struct pci_device_id *id)
 		return -ENODEV;
 	}
 
-	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {
+	if (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {
 		printk(KERN_ERR DRV_NAME ": unable to configure DMA mask.\n");
 		return -ENODEV;
 	}
-	if (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {
+	if (dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32))) {
 		printk(KERN_ERR DRV_NAME ": unable to configure consistent DMA mask.\n");
 		return -ENODEV;
 	}

commit 58eb8cd565af4a104395e3c10443951c1f73dafe
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Wed May 7 17:17:44 2014 +0200

    ata: use CONFIG_PM_SLEEP instead of CONFIG_PM where applicable in host drivers
    
    This patch fixes host drivers to use CONFIG_PM_SLEEP instead of CONFIG_PM
    where applicable.  Benefits of this change:
    
    * unused code is not being compiled in for CONFIG_PM=y, CONFIG_PM_SLEEP=n
      and CONFIG_PM_RUNTIME=y configurations
    
    * easier transition to use struct dev_pm_ops and SIMPLE_DEV_PM_OPS() in
      the future
    
    * more consistent code (there are host drivers which are using the correct
      CONFIG_PM_SLEEP checks already)
    
    The patch leaves the core libata code and ->port_[suspend,resume] support
    in sata_[inic162x,nv,sil24].c alone for now.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index bcde4b786807..d65cb9d2fa8c 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -229,7 +229,7 @@ static int cs5520_init_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	return ata_host_register(host, &cs5520_sht);
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 /**
  *	cs5520_reinit_one	-	device resume
  *	@pdev: PCI device
@@ -278,7 +278,7 @@ static int cs5520_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)
 	pci_save_state(pdev);
 	return 0;
 }
-#endif /* CONFIG_PM */
+#endif /* CONFIG_PM_SLEEP */
 
 /* For now keep DMA off. We can set it for all but A rev CS5510 once the
    core ATA code can handle it */
@@ -295,7 +295,7 @@ static struct pci_driver cs5520_pci_driver = {
 	.id_table	= pata_cs5520,
 	.probe 		= cs5520_init_one,
 	.remove		= ata_pci_remove_one,
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 	.suspend	= cs5520_pci_device_suspend,
 	.resume		= cs5520_reinit_one,
 #endif

commit 1bc18086231c130895b87ec049be8ddcdab552b8
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Jan 21 16:22:51 2014 -0500

    ata: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Cc: linux-ide@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index f10baabbf5db..bcde4b786807 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -34,7 +34,6 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/pci.h>
-#include <linux/init.h>
 #include <linux/blkdev.h>
 #include <linux/delay.h>
 #include <scsi/scsi_host.h>

commit 0a86e1c857134efe2cdb31d74bc7ea21721db494
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Mon Jun 3 14:05:36 2013 +0900

    ata: use pci_get_drvdata()
    
    Use the wrapper function for getting the driver data using pci_dev
    instead of using dev_get_drvdata() with &pdev->dev, so we can directly
    pass a struct pci_dev.  This is a purely cosmetic change.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index bfcf377e8f77..f10baabbf5db 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -241,7 +241,7 @@ static int cs5520_init_one(struct pci_dev *pdev, const struct pci_device_id *id)
 
 static int cs5520_reinit_one(struct pci_dev *pdev)
 {
-	struct ata_host *host = dev_get_drvdata(&pdev->dev);
+	struct ata_host *host = pci_get_drvdata(pdev);
 	u8 pcicfg;
 	int rc;
 
@@ -269,7 +269,7 @@ static int cs5520_reinit_one(struct pci_dev *pdev)
 
 static int cs5520_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)
 {
-	struct ata_host *host = dev_get_drvdata(&pdev->dev);
+	struct ata_host *host = pci_get_drvdata(pdev);
 	int rc = 0;
 
 	rc = ata_host_suspend(host, mesg);

commit 0ec24914675c48213378da550db494bf154f0f6c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:19:58 2012 -0800

    Drivers: ata: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Cc: Viresh Kumar <viresh.linux@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index de74d804f031..bfcf377e8f77 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -115,7 +115,7 @@ static struct ata_port_operations cs5520_port_ops = {
 	.set_piomode		= cs5520_set_piomode,
 };
 
-static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_device_id *id)
+static int cs5520_init_one(struct pci_dev *pdev, const struct pci_device_id *id)
 {
 	static const unsigned int cmd_port[] = { 0x1F0, 0x170 };
 	static const unsigned int ctl_port[] = { 0x3F6, 0x376 };

commit 2fc75da0c59634b81223af497c4a037822f6e457
Author: Axel Lin <axel.lin@gmail.com>
Date:   Thu Apr 19 13:43:05 2012 +0800

    ata: use module_pci_driver
    
    This patch converts the drivers in drivers/ata/* to use module_pci_driver()
    macro which makes the code smaller and a bit simpler.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Cc: Mikael Pettersson <mikpe@it.uu.se>
    Cc: Mark Lord <kernel@teksavvy.com>
    Cc: Jeremy Higdon <jeremy@sgi.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 9ddcddc66a20..de74d804f031 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -302,22 +302,10 @@ static struct pci_driver cs5520_pci_driver = {
 #endif
 };
 
-static int __init cs5520_init(void)
-{
-	return pci_register_driver(&cs5520_pci_driver);
-}
-
-static void __exit cs5520_exit(void)
-{
-	pci_unregister_driver(&cs5520_pci_driver);
-}
+module_pci_driver(cs5520_pci_driver);
 
 MODULE_AUTHOR("Alan Cox");
 MODULE_DESCRIPTION("low-level driver for Cyrix CS5510/5520");
 MODULE_LICENSE("GPL");
 MODULE_DEVICE_TABLE(pci, pata_cs5520);
 MODULE_VERSION(DRV_VERSION);
-
-module_init(cs5520_init);
-module_exit(cs5520_exit);
-

commit a44fec1fce5d5d14cc3ac4545b8da346394de666
Author: Joe Perches <joe@perches.com>
Date:   Fri Apr 15 15:51:58 2011 -0700

    ata: Convert dev_printk(KERN_<LEVEL> to dev_<level>(
    
    Saves a bit of text as the call takes fewer args.
    
    Coalesce a few formats.
    Convert a few bare printks to pr_cont.
    
    $ size drivers/ata/built-in.o*
       text    data     bss     dec     hex filename
     558429   73893  117864  750186   b726a drivers/ata/built-in.o.allyesconfig.new
     559574   73893  117888  751355   b76fb drivers/ata/built-in.o.allyesconfig.old
     149567   14689    4220  168476   2921c drivers/ata/built-in.o.defconfig.new
     149851   14689    4220  168760   29338 drivers/ata/built-in.o.defconfig.old
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jeff Garzik <jgarzik@pobox.com>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index e3254fcff0f1..9ddcddc66a20 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -149,8 +149,7 @@ static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_devi
 		ppi[1] = &pi;
 
 	if ((pcicfg & 0x40) == 0) {
-		dev_printk(KERN_WARNING, &pdev->dev,
-			   "DMA mode disabled. Enabling.\n");
+		dev_warn(&pdev->dev, "DMA mode disabled. Enabling.\n");
 		pci_write_config_byte(pdev, 0x60, pcicfg | 0x40);
 	}
 

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 030952f1f97c..e3254fcff0f1 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -29,7 +29,7 @@
  * General Public License for more details.
  *
  * Documentation:
- *	Not publically available.
+ *	Not publicly available.
  */
 #include <linux/kernel.h>
 #include <linux/module.h>

commit c3b2889424c26f3b42962b6f39aabb4f1fd1b576
Author: Tejun Heo <tj@kernel.org>
Date:   Wed May 19 22:10:21 2010 +0200

    libata-sff: separate out BMDMA irq handler
    
    Separate out BMDMA irq handler from SFF irq handler.  The misnamed
    host_intr() functions are renamed to ata_sff_port_intr() and
    ata_bmdma_port_intr().  Common parts are factored into
    __ata_sff_port_intr() and __ata_sff_interrupt() and used by sff and
    bmdma interrupt routines.
    
    All BMDMA drivers now use ata_bmdma_interrupt() or
    ata_bmdma_port_intr() while all non-BMDMA SFF ones use
    ata_sff_interrupt() or ata_sff_port_intr().
    
    For now, ata_pci_sff_init_one() uses ata_bmdma_interrupt() as it's
    used by both SFF and BMDMA drivers.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 17c5f346ff01..030952f1f97c 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -221,7 +221,7 @@ static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_devi
 			continue;
 
 		rc = devm_request_irq(&pdev->dev, irq[ap->port_no],
-				      ata_sff_interrupt, 0, DRV_NAME, host);
+				      ata_bmdma_interrupt, 0, DRV_NAME, host);
 		if (rc)
 			return rc;
 

commit f47451c45fe0032ef491aaf3e0623fa0154e156d
Author: Tejun Heo <tj@kernel.org>
Date:   Mon May 10 21:41:40 2010 +0200

    libata-sff: ata_sff_[dumb_]qc_prep are BMDMA specific
    
    Both qc_prep functions deal only with BMDMA PRD setup and PIO only SFF
    drivers don't need them.  Rename to ata_bmdma_[dumb_]qc_prep() and
    relocate.
    
    All usages are renamed except for pdc_adma and sata_qstor.  Those two
    drivers are not BMDMA drivers and don't need to call BMDMA qc_prep
    functions.  Calls to ata_sff_qc_prep() in the two drivers are removed.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 95ebdac517f2..17c5f346ff01 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -110,7 +110,7 @@ static struct scsi_host_template cs5520_sht = {
 
 static struct ata_port_operations cs5520_port_ops = {
 	.inherits		= &ata_bmdma_port_ops,
-	.qc_prep		= ata_sff_dumb_qc_prep,
+	.qc_prep		= ata_bmdma_dumb_qc_prep,
 	.cable_detect		= ata_cable_40wire,
 	.set_piomode		= cs5520_set_piomode,
 };

commit 940a68de56c1952c29d9f3c1a769a82b1bdd2b67
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Thu Dec 3 20:32:09 2009 +0100

    pata_cs5520: remove dead VDMA support
    
    It has been dead for the last three years (== since the initial driver
    merge) and probability that it will ever get fixed is quite low.
    
    Since there is no reason to keep this dead code around any longer just
    remove it (it can still be retrieved from the git history if necessary).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 0df83cf74233..95ebdac517f2 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -89,49 +89,13 @@ static void cs5520_set_timings(struct ata_port *ap, struct ata_device *adev, int
 				(cs5520_pio_clocks[pio].assert));
 }
 
-/**
- *	cs5520_enable_dma	-	turn on DMA bits
- *
- *	Turn on the DMA bits for this disk. Needed because the BIOS probably
- *	has not done the work for us. Belongs in the core SATA code.
- */
-
-static void cs5520_enable_dma(struct ata_port *ap, struct ata_device *adev)
-{
-	/* Set the DMA enable/disable flag */
-	u8 reg = ioread8(ap->ioaddr.bmdma_addr + 0x02);
-	reg |= 1<<(adev->devno + 5);
-	iowrite8(reg, ap->ioaddr.bmdma_addr + 0x02);
-}
-
-/**
- *	cs5520_set_dmamode	-	program DMA timings
- *	@ap: ATA port
- *	@adev: ATA device
- *
- *	Program the DMA mode timings for the controller according to the pio
- *	clocking table. Note that this device sets the DMA timings to PIO
- *	mode values. This may seem bizarre but the 5520 architecture talks
- *	PIO mode to the disk and DMA mode to the controller so the underlying
- *	transfers are PIO timed.
- */
-
-static void cs5520_set_dmamode(struct ata_port *ap, struct ata_device *adev)
-{
-	static const int dma_xlate[3] = { XFER_PIO_0, XFER_PIO_3, XFER_PIO_4 };
-	cs5520_set_timings(ap, adev, dma_xlate[adev->dma_mode]);
-	cs5520_enable_dma(ap, adev);
-}
-
 /**
  *	cs5520_set_piomode	-	program PIO timings
  *	@ap: ATA port
  *	@adev: ATA device
  *
  *	Program the PIO mode timings for the controller according to the pio
- *	clocking table. We know pio_mode will equal dma_mode because of the
- *	CS5520 architecture. At least once we turned DMA on and wrote a
- *	mode setter.
+ *	clocking table.
  */
 
 static void cs5520_set_piomode(struct ata_port *ap, struct ata_device *adev)
@@ -149,7 +113,6 @@ static struct ata_port_operations cs5520_port_ops = {
 	.qc_prep		= ata_sff_dumb_qc_prep,
 	.cable_detect		= ata_cable_40wire,
 	.set_piomode		= cs5520_set_piomode,
-	.set_dmamode		= cs5520_set_dmamode,
 };
 
 static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_device_id *id)

commit 284901a90a9e0b812ca3f5f852cbbfb60d10249d
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:15 2009 -0700

    dma-mapping: replace all DMA_32BIT_MASK macro with DMA_BIT_MASK(32)
    
    Replace all DMA_32BIT_MASK macro with DMA_BIT_MASK(32)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index db6a96984f3f..0df83cf74233 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -203,11 +203,11 @@ static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_devi
 		return -ENODEV;
 	}
 
-	if (pci_set_dma_mask(pdev, DMA_32BIT_MASK)) {
+	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {
 		printk(KERN_ERR DRV_NAME ": unable to configure DMA mask.\n");
 		return -ENODEV;
 	}
-	if (pci_set_consistent_dma_mask(pdev, DMA_32BIT_MASK)) {
+	if (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {
 		printk(KERN_ERR DRV_NAME ": unable to configure consistent DMA mask.\n");
 		return -ENODEV;
 	}

commit 14bdef982caeda19afe34010482867c18217c641
Author: Erik Inge Bolsø <knan-lkml@anduin.net>
Date:   Sat Mar 14 21:38:24 2009 +0100

    [libata] convert drivers to use ata.h mode mask defines
    
    No functional changes in this patch.
    
    Signed-off-by: Erik Inge Bolsø <knan-lkml@anduin.net>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 1186bcd2781c..db6a96984f3f 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -158,7 +158,7 @@ static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_devi
 	static const unsigned int ctl_port[] = { 0x3F6, 0x376 };
 	struct ata_port_info pi = {
 		.flags		= ATA_FLAG_SLAVE_POSS,
-		.pio_mask	= 0x1f,
+		.pio_mask	= ATA_PIO4,
 		.port_ops	= &cs5520_port_ops,
 	};
 	const struct ata_port_info *ppi[2];

commit 9363c3825ea9ad76561eb48a395349dd29211ed6
Author: Tejun Heo <htejun@gmail.com>
Date:   Mon Apr 7 22:47:16 2008 +0900

    libata: rename SFF functions
    
    SFF functions have confusing names.  Some have sff prefix, some have
    bmdma, some std, some pci and some none.  Unify the naming by...
    
    * SFF functions which are common to both BMDMA and non-BMDMA are
      prefixed with ata_sff_.
    
    * SFF functions which are specific to BMDMA are prefixed with
      ata_bmdma_.
    
    * SFF functions which are specific to PCI but apply to both BMDMA and
      non-BMDMA are prefixed with ata_pci_sff_.
    
    * SFF functions which are specific to PCI and BMDMA are prefixed with
      ata_pci_bmdma_.
    
    * Drop generic prefixes from LLD specific routines.  For example,
      bfin_std_dev_select -> bfin_dev_select.
    
    The following renames are noteworthy.
    
      ata_qc_issue_prot() -> ata_sff_qc_issue()
      ata_pci_default_filter() -> ata_bmdma_mode_filter()
      ata_dev_try_classify() -> ata_sff_dev_classify()
    
    This rename is in preparation of separating SFF support out of libata
    core layer.  This patch strictly renames functions and doesn't
    introduce any behavior difference.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 46d0ce32ee5a..1186bcd2781c 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -146,7 +146,7 @@ static struct scsi_host_template cs5520_sht = {
 
 static struct ata_port_operations cs5520_port_ops = {
 	.inherits		= &ata_bmdma_port_ops,
-	.qc_prep		= ata_dumb_qc_prep,
+	.qc_prep		= ata_sff_dumb_qc_prep,
 	.cable_detect		= ata_cable_40wire,
 	.set_piomode		= cs5520_set_piomode,
 	.set_dmamode		= cs5520_set_dmamode,
@@ -227,7 +227,7 @@ static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_devi
 	ioaddr->ctl_addr = iomap[1];
 	ioaddr->altstatus_addr = iomap[1];
 	ioaddr->bmdma_addr = iomap[4];
-	ata_std_ports(ioaddr);
+	ata_sff_std_ports(ioaddr);
 
 	ata_port_desc(host->ports[0],
 		      "cmd 0x%x ctl 0x%x", cmd_port[0], ctl_port[0]);
@@ -238,7 +238,7 @@ static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_devi
 	ioaddr->ctl_addr = iomap[3];
 	ioaddr->altstatus_addr = iomap[3];
 	ioaddr->bmdma_addr = iomap[4] + 8;
-	ata_std_ports(ioaddr);
+	ata_sff_std_ports(ioaddr);
 
 	ata_port_desc(host->ports[1],
 		      "cmd 0x%x ctl 0x%x", cmd_port[1], ctl_port[1]);
@@ -258,7 +258,7 @@ static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_devi
 			continue;
 
 		rc = devm_request_irq(&pdev->dev, irq[ap->port_no],
-				      ata_interrupt, 0, DRV_NAME, host);
+				      ata_sff_interrupt, 0, DRV_NAME, host);
 		if (rc)
 			return rc;
 

commit 029cfd6b74fc5c517865fad78cf4a3ea8d9b664a
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:49 2008 +0900

    libata: implement and use ops inheritance
    
    libata lets low level drivers build ata_port_operations table and
    register it with libata core layer.  This allows low level drivers
    high level of flexibility but also burdens them with lots of
    boilerplate entries.
    
    This becomes worse for drivers which support related similar
    controllers which differ slightly.  They share most of the operations
    except for a few.  However, the driver still needs to list all
    operations for each variant.  This results in large number of
    duplicate entries, which is not only inefficient but also error-prone
    as it becomes very difficult to tell what the actual differences are.
    
    This duplicate boilerplates all over the low level drivers also make
    updating the core layer exteremely difficult and error-prone.  When
    compounded with multi-branched development model, it ends up
    accumulating inconsistencies over time.  Some of those inconsistencies
    cause immediate problems and fixed.  Others just remain there dormant
    making maintenance increasingly difficult.
    
    To rectify the problem, this patch implements ata_port_operations
    inheritance.  To allow LLDs to easily re-use their own ops tables
    overriding only specific methods, this patch implements poor man's
    class inheritance.  An ops table has ->inherits field which can be set
    to any ops table as long as it doesn't create a loop.  When the host
    is started, the inheritance chain is followed and any operation which
    isn't specified is taken from the nearest ancestor which has it
    specified.  This operation is called finalization and done only once
    per an ops table and the LLD doesn't have to do anything special about
    it other than making the ops table non-const such that libata can
    update it.
    
    libata provides four base ops tables lower drivers can inherit from -
    base, sata, pmp, sff and bmdma.  To avoid overriding these ops
    accidentaly, these ops are declared const and LLDs should always
    inherit these instead of using them directly.
    
    After finalization, all the ops table are identical before and after
    the patch except for setting .irq_handler to ata_interrupt in drivers
    which didn't use to.  The .irq_handler doesn't have any actual effect
    and the field will soon be removed by later patch.
    
    * sata_sx4 is still using old style EH and currently doesn't take
      advantage of ops inheritance.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 7e643099a444..46d0ce32ee5a 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -145,34 +145,11 @@ static struct scsi_host_template cs5520_sht = {
 };
 
 static struct ata_port_operations cs5520_port_ops = {
+	.inherits		= &ata_bmdma_port_ops,
+	.qc_prep		= ata_dumb_qc_prep,
+	.cable_detect		= ata_cable_40wire,
 	.set_piomode		= cs5520_set_piomode,
 	.set_dmamode		= cs5520_set_dmamode,
-	.mode_filter		= ata_pci_default_filter,
-
-	.tf_load		= ata_tf_load,
-	.tf_read		= ata_tf_read,
-	.check_status		= ata_check_status,
-	.exec_command		= ata_exec_command,
-	.dev_select		= ata_std_dev_select,
-
-	.freeze			= ata_bmdma_freeze,
-	.thaw			= ata_bmdma_thaw,
-	.error_handler		= ata_bmdma_error_handler,
-	.post_internal_cmd	= ata_bmdma_post_internal_cmd,
-	.cable_detect		= ata_cable_40wire,
-
-	.bmdma_setup		= ata_bmdma_setup,
-	.bmdma_start		= ata_bmdma_start,
-	.bmdma_stop		= ata_bmdma_stop,
-	.bmdma_status		= ata_bmdma_status,
-	.qc_prep		= ata_dumb_qc_prep,
-	.qc_issue		= ata_qc_issue_prot,
-	.data_xfer		= ata_data_xfer,
-
-	.irq_clear		= ata_bmdma_irq_clear,
-	.irq_on			= ata_irq_on,
-
-	.port_start		= ata_sff_port_start,
 };
 
 static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_device_id *id)

commit 68d1d07b510bb57a504588adc2bd2758adea0965
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:49 2008 +0900

    libata: implement and use SHT initializers
    
    libata lets low level drivers build scsi_host_template and register it
    to the SCSI layer.  This allows low level drivers high level of
    flexibility but also burdens them with lots of boilerplate entries.
    
    This patch implements SHT initializers which can be used to initialize
    all the boilerplate entries in a sht.  Three variants of them are
    implemented - BASE, BMDMA and NCQ - for different types of drivers.
    Note that entries can be overriden by putting individual initializers
    after the helper macro.
    
    All sht tables are identical before and after this patch.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 44ad2c9d488f..7e643099a444 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -140,21 +140,8 @@ static void cs5520_set_piomode(struct ata_port *ap, struct ata_device *adev)
 }
 
 static struct scsi_host_template cs5520_sht = {
-	.module			= THIS_MODULE,
-	.name			= DRV_NAME,
-	.ioctl			= ata_scsi_ioctl,
-	.queuecommand		= ata_scsi_queuecmd,
-	.can_queue		= ATA_DEF_QUEUE,
-	.this_id		= ATA_SHT_THIS_ID,
+	ATA_BMDMA_SHT(DRV_NAME),
 	.sg_tablesize		= LIBATA_DUMB_MAX_PRD,
-	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
-	.emulated		= ATA_SHT_EMULATED,
-	.use_clustering		= ATA_SHT_USE_CLUSTERING,
-	.proc_name		= DRV_NAME,
-	.dma_boundary		= ATA_DMA_BOUNDARY,
-	.slave_configure	= ata_scsi_slave_config,
-	.slave_destroy		= ata_scsi_slave_destroy,
-	.bios_param		= ata_std_bios_param,
 };
 
 static struct ata_port_operations cs5520_port_ops = {

commit 6bd99b4e0998571808fc1f09d5162348f21ff8c1
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:48 2008 +0900

    libata: normalize port_info, port_operations and sht tables
    
    Over the time, port info, ops and sht structures developed quite a bit
    of inconsistencies.  This patch updates drivers.
    
    * Enable/disable_pm callbacks added to all ahci ops tables.
    
    * Every driver for SFF controllers now uses ata_sff_port_start()
      instead of ata_port_start() unless the driver has custom
      implementation.
    
    * Every driver for SFF controllers now uses ata_pci_default_filter()
      unless the driver has custom implementation.
    
    * Removed an odd port_info->sht initialization from ata_piix.c.
      Likely a merge byproduct.
    
    * A port which has ATA_FLAG_SATA set doesn't need to set cable_detect
      to ata_cable_sata().  Remove it from via and mv port ops.
    
    * Some drivers had unnecessary .max_sectors initialization which is
      ignored and was missing .slave_destroy callback.  Fixed.
    
    * Removed unnecessary sht initializations port_info's.
    
    * Removed onsolete scsi device suspend/resume callbacks from
      pata_bf54x.
    
    * No reason to set ata_pci_default_filter() and bmdma functions for
      PIO-only drivers.  Remove those callbacks and replace
      ata_bmdma_irq_clear with ata_noop_irq_clear.
    
    * pata_platform sets port_start to ata_dummy_ret0.  port_start can
      just be set to NULL.
    
    * sata_fsl supports NCQ but was missing qc_defer.  Fixed.
    
    * pata_rb600_cf implements dummy port_start.  Removed.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index dd6b2355fcdc..44ad2c9d488f 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -160,6 +160,7 @@ static struct scsi_host_template cs5520_sht = {
 static struct ata_port_operations cs5520_port_ops = {
 	.set_piomode		= cs5520_set_piomode,
 	.set_dmamode		= cs5520_set_dmamode,
+	.mode_filter		= ata_pci_default_filter,
 
 	.tf_load		= ata_tf_load,
 	.tf_read		= ata_tf_read,

commit f08048e94564d009b19038cfbdd800aa83e79c7f
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Mar 25 12:22:47 2008 +0900

    libata: PCI device should be powered up before being accessed
    
    PCI device should be powered up or powered up before its PCI regsiters
    are accessed.  Although PCI configuration register access is allowed
    in D3hot, PCI device is free to reset its status when transiting from
    D3hot to D0 causing configuration data to change.
    
    Many libata SFF drivers which use ata_pci_init_one() read and update
    configuration registers before calling ata_pci_init_one() which
    enables the PCI device.  Also, in resume paths, some drivers access
    registers without resuming the PCI device.
    
    This patch adds a call to pcim_enable_device() in init path if
    register is accessed before calling ata_pci_init_one() and make resume
    paths first resume PCI devices, access PCI configuration regiters then
    resume ATA host.
    
    While at it...
    
    * cmd640 was strange in that it set ->resume even when CONFIG_PM is
      not.  This is by-product of minimal build fix.  Updated.
    
    * In cs5530, Don't BUG() on reinit failure.  Just whine and fail
      resume.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 7ed279b0a12e..dd6b2355fcdc 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -203,6 +203,10 @@ static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_devi
 	struct ata_ioports *ioaddr;
 	int i, rc;
 
+	rc = pcim_enable_device(pdev);
+	if (rc)
+		return rc;
+
 	/* IDE port enable bits */
 	pci_read_config_byte(pdev, 0x60, &pcicfg);
 
@@ -310,11 +314,20 @@ static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_devi
 
 static int cs5520_reinit_one(struct pci_dev *pdev)
 {
+	struct ata_host *host = dev_get_drvdata(&pdev->dev);
 	u8 pcicfg;
+	int rc;
+
+	rc = ata_pci_device_do_resume(pdev);
+	if (rc)
+		return rc;
+
 	pci_read_config_byte(pdev, 0x60, &pcicfg);
 	if ((pcicfg & 0x40) == 0)
 		pci_write_config_byte(pdev, 0x60, pcicfg | 0x40);
-	return ata_pci_device_resume(pdev);
+
+	ata_host_resume(host);
+	return 0;
 }
 
 /**

commit 0948391641918b95d8d96c15089eb5ac156850b3
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Thu Dec 20 15:28:09 2007 +1100

    PCI: Remove users of pci_enable_device_bars()
    
    This patch converts users of pci_enable_device_bars() to the new
    pci_enable_device_{io,mem} interface.
    
    The new API fits nicely, except maybe for the QLA case where a bit of
    code re-organization might be a good idea but I prefer sticking to the
    simple patch as I don't have hardware to test on.
    
    I'll also need some feedback on the cs5520 change.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index d4590f546c49..7ed279b0a12e 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -229,7 +229,7 @@ static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_devi
 		return -ENOMEM;
 
 	/* Perform set up for DMA */
-	if (pci_enable_device_bars(pdev, 1<<2)) {
+	if (pci_enable_device_io(pdev)) {
 		printk(KERN_ERR DRV_NAME ": unable to configure BAR2.\n");
 		return -ENODEV;
 	}

commit 4ca4e439640cd1d3659cbcf60e7a73c2ae0450b3
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Sun Dec 30 09:32:22 2007 +0000

    libata annotations and fixes
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 33f7f0843f4f..d4590f546c49 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -198,7 +198,7 @@ static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_devi
 	};
 	const struct ata_port_info *ppi[2];
 	u8 pcicfg;
-	void *iomap[5];
+	void __iomem *iomap[5];
 	struct ata_host *host;
 	struct ata_ioports *ioaddr;
 	int i, rc;

commit 2855568b1ee4f58ef2c0a13ddfceb4b0b216b7ed
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Oct 11 17:12:35 2007 -0400

    [libata] struct pci_dev related cleanups
    
    * remove pointless pci_dev_to_dev() wrapper.  Just directly reference
      the embedded struct device like everyone else does.
    
    * pata_cs5520: delete cs5520_remove_one(), it was a duplicate of
      ata_pci_remove_one()
    
    * linux/libata.h: don't bother including linux/pci.h, we don't need it.
      Simply declare 'struct pci_dev' and assume interested parties will
      include the header, as they should be doing anyway.
    
    * linux/libata.h: consolidate all CONFIG_PCI declarations into a
      single location in the header.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index ff1eb84c7d22..33f7f0843f4f 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -299,24 +299,6 @@ static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_devi
 	return ata_host_register(host, &cs5520_sht);
 }
 
-/**
- *	cs5520_remove_one	-	device unload
- *	@pdev: PCI device being removed
- *
- *	Handle an unplug/unload event for a PCI device. Unload the
- *	PCI driver but do not use the default handler as we manage
- *	resources ourself and *MUST NOT* disable the device as it has
- *	other functions.
- */
-
-static void __devexit cs5520_remove_one(struct pci_dev *pdev)
-{
-	struct device *dev = pci_dev_to_dev(pdev);
-	struct ata_host *host = dev_get_drvdata(dev);
-
-	ata_host_detach(host);
-}
-
 #ifdef CONFIG_PM
 /**
  *	cs5520_reinit_one	-	device resume
@@ -373,7 +355,7 @@ static struct pci_driver cs5520_pci_driver = {
 	.name 		= DRV_NAME,
 	.id_table	= pata_cs5520,
 	.probe 		= cs5520_init_one,
-	.remove		= cs5520_remove_one,
+	.remove		= ata_pci_remove_one,
 #ifdef CONFIG_PM
 	.suspend	= cs5520_pci_device_suspend,
 	.resume		= cs5520_reinit_one,

commit cbcdd87593a1d85c5c4b259945a3a09eee12814d
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Aug 18 13:14:55 2007 +0900

    libata: implement and use ata_port_desc() to report port configuration
    
    Currently, port configuration reporting has the following problems.
    
    * iomapped address is reported instead of raw address
    * report contains irrelevant fields or lacks necessary fields for
      non-SFF controllers.
    * host->irq/irq2 are there just for reporting and hacky.
    
    This patch implements and uses ata_port_desc() and
    ata_port_pbar_desc().  ata_port_desc() is almost identical to
    ata_ehi_push_desc() except that it takes @ap instead of @ehi, has no
    locking requirement, can only be used during host initialization and "
    " is used as separator instead of ", ".  ata_port_pbar_desc() is a
    helper to ease reporting of a PCI BAR or an offsetted address into it.
    
    LLD pushes whatever description it wants using the above two
    functions.  The accumulated description is printed on host
    registration after "[S/P]ATA max MAX_XFERMODE ".
    
    SFF init helpers and ata_host_activate() automatically add
    descriptions for addresses and irq respectively, so only LLDs which
    isn't standard SFF need to add custom descriptions.  In many cases,
    such controllers need to report different things anyway.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 1ae6b6bd8564..ff1eb84c7d22 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -189,6 +189,8 @@ static struct ata_port_operations cs5520_port_ops = {
 
 static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_device_id *id)
 {
+	static const unsigned int cmd_port[] = { 0x1F0, 0x170 };
+	static const unsigned int ctl_port[] = { 0x3F6, 0x376 };
 	struct ata_port_info pi = {
 		.flags		= ATA_FLAG_SLAVE_POSS,
 		.pio_mask	= 0x1f,
@@ -242,10 +244,10 @@ static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_devi
 	}
 
 	/* Map IO ports and initialize host accordingly */
-	iomap[0] = devm_ioport_map(&pdev->dev, 0x1F0, 8);
-	iomap[1] = devm_ioport_map(&pdev->dev, 0x3F6, 1);
-	iomap[2] = devm_ioport_map(&pdev->dev, 0x170, 8);
-	iomap[3] = devm_ioport_map(&pdev->dev, 0x376, 1);
+	iomap[0] = devm_ioport_map(&pdev->dev, cmd_port[0], 8);
+	iomap[1] = devm_ioport_map(&pdev->dev, ctl_port[0], 1);
+	iomap[2] = devm_ioport_map(&pdev->dev, cmd_port[1], 8);
+	iomap[3] = devm_ioport_map(&pdev->dev, ctl_port[1], 1);
 	iomap[4] = pcim_iomap(pdev, 2, 0);
 
 	if (!iomap[0] || !iomap[1] || !iomap[2] || !iomap[3] || !iomap[4])
@@ -258,6 +260,10 @@ static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_devi
 	ioaddr->bmdma_addr = iomap[4];
 	ata_std_ports(ioaddr);
 
+	ata_port_desc(host->ports[0],
+		      "cmd 0x%x ctl 0x%x", cmd_port[0], ctl_port[0]);
+	ata_port_pbar_desc(host->ports[0], 4, 0, "bmdma");
+
 	ioaddr = &host->ports[1]->ioaddr;
 	ioaddr->cmd_addr = iomap[2];
 	ioaddr->ctl_addr = iomap[3];
@@ -265,6 +271,10 @@ static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_devi
 	ioaddr->bmdma_addr = iomap[4] + 8;
 	ata_std_ports(ioaddr);
 
+	ata_port_desc(host->ports[1],
+		      "cmd 0x%x ctl 0x%x", cmd_port[1], ctl_port[1]);
+	ata_port_pbar_desc(host->ports[1], 4, 8, "bmdma");
+
 	/* activate the host */
 	pci_set_master(pdev);
 	rc = ata_host_start(host);
@@ -283,10 +293,7 @@ static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_devi
 		if (rc)
 			return rc;
 
-		if (i == 0)
-			host->irq = irq[0];
-		else
-			host->irq2 = irq[1];
+		ata_port_desc(ap, "irq %d", irq[i]);
 	}
 
 	return ata_host_register(host, &cs5520_sht);

commit 81ad1837b590775336f68eafcae8dab13a975b3a
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Wed Aug 22 22:55:41 2007 +0100

    libata: Switch most of the remaining SFF drivers to ata_sff_port_start
    
    This avoids allocating DMA buffers if not needed but at the moment is
    mostly just a neatness item.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index fe37e3e80f27..1ae6b6bd8564 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -184,7 +184,7 @@ static struct ata_port_operations cs5520_port_ops = {
 	.irq_clear		= ata_bmdma_irq_clear,
 	.irq_on			= ata_irq_on,
 
-	.port_start		= ata_port_start,
+	.port_start		= ata_sff_port_start,
 };
 
 static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_device_id *id)

commit ac8869d56d95a8c74403e6f7a47d74fcfcc1b988
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Aug 16 03:17:03 2007 -0400

    [libata] Remove ->port_disable() hook
    
    It was always set to ata_port_disable().  Removed the hook, and replaced
    the very few ap->ops->port_disable() callsites with direct calls to
    ata_port_disable().
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 300dcff949e2..fe37e3e80f27 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -158,7 +158,6 @@ static struct scsi_host_template cs5520_sht = {
 };
 
 static struct ata_port_operations cs5520_port_ops = {
-	.port_disable		= ata_port_disable,
 	.set_piomode		= cs5520_set_piomode,
 	.set_dmamode		= cs5520_set_dmamode,
 

commit 6d32d30f55020d766388df7515f771f68c973033
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Aug 15 05:38:46 2007 -0400

    [libata] Remove ->irq_ack() hook, and ata_dummy_irq_on()
    
    * ->irq_ack() is redundant to what the irq handler already
      performs... chk-status + irq-clear.  Furthermore, it is only
      called in one place, when screaming-irq-debugging is enabled,
      so we don't want to bother with a hook just for that.
    
    * ata_dummy_irq_on() is only ever used in drivers that have
      no callpath reaching ->irq_on().  Remove .irq_on hook from
      those drivers, and the now-unused ata_dummy_irq_on()
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index e2459088cdcd..300dcff949e2 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -184,7 +184,6 @@ static struct ata_port_operations cs5520_port_ops = {
 
 	.irq_clear		= ata_bmdma_irq_clear,
 	.irq_on			= ata_irq_on,
-	.irq_ack		= ata_irq_ack,
 
 	.port_start		= ata_port_start,
 };

commit 2a3103ce4357a09c2289405f969acec0edf4398f
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Aug 31 04:54:06 2007 -0400

    [libata] Bump driver versions
    
    Bump the versions for drivers that were modified, but had not already
    had a version number bump.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 7dc76e71bd55..e2459088cdcd 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -41,7 +41,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"pata_cs5520"
-#define DRV_VERSION	"0.6.5"
+#define DRV_VERSION	"0.6.6"
 
 struct pio_clocks
 {

commit 8c6b065b792061c2e471d530127f2348fd9d243d
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Fri Jul 20 15:36:31 2007 +0100

    pata_cs5520: Fix probe bug regression introduced in 2.6.22
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linux Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 6bf037d82b5a..7dc76e71bd55 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -275,7 +275,7 @@ static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_devi
 
 	for (i = 0; i < 2; i++) {
 		static const int irq[] = { 14, 15 };
-		struct ata_port *ap = host->ports[0];
+		struct ata_port *ap = host->ports[i];
 
 		if (ata_port_is_dummy(ap))
 			continue;

commit d26fc9551a15fdad0d5de8376a78816b8af44f00
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Fri Jul 6 19:13:52 2007 -0400

    libata: Support chips with 64K PRD quirk
    
    Add ata_dumb_qc_prep and supporting logic so that a driver can just
    specify it needs to be helped in this area. 64K entries are split
    as with drivers/ide.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 00cf0134079c..6bf037d82b5a 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -146,7 +146,7 @@ static struct scsi_host_template cs5520_sht = {
 	.queuecommand		= ata_scsi_queuecmd,
 	.can_queue		= ATA_DEF_QUEUE,
 	.this_id		= ATA_SHT_THIS_ID,
-	.sg_tablesize		= LIBATA_MAX_PRD,
+	.sg_tablesize		= LIBATA_DUMB_MAX_PRD,
 	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
 	.emulated		= ATA_SHT_EMULATED,
 	.use_clustering		= ATA_SHT_USE_CLUSTERING,
@@ -178,7 +178,7 @@ static struct ata_port_operations cs5520_port_ops = {
 	.bmdma_start		= ata_bmdma_start,
 	.bmdma_stop		= ata_bmdma_stop,
 	.bmdma_status		= ata_bmdma_status,
-	.qc_prep		= ata_qc_prep,
+	.qc_prep		= ata_dumb_qc_prep,
 	.qc_issue		= ata_qc_issue_prot,
 	.data_xfer		= ata_data_xfer,
 

commit 4031826b3ca40982880f6b9f2282c7d7fad60d77
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Jul 3 01:38:47 2007 +0900

    libata: fix assigned IRQ reporting
    
    host->irq and host->irq2 should be set before ata_host_register() for
    IRQ reporting to work.  Move up host->irq assignment in
    ata_host_activate() and add it to ata_pci_init_one() native path and
    pata_cs5520.
    
    The port info printing in ata_host_register() doesn't fit all the
    different controllers.  It should probably be moved out to LLDs with
    some helpers in the future.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 1aabe15ad9d3..00cf0134079c 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -284,6 +284,11 @@ static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_devi
 				      ata_interrupt, 0, DRV_NAME, host);
 		if (rc)
 			return rc;
+
+		if (i == 0)
+			host->irq = irq[0];
+		else
+			host->irq2 = irq[1];
 	}
 
 	return ata_host_register(host, &cs5520_sht);

commit 8bc3fc470eb25af4d70c72485cbcb130cc657691
Author: Jeff Garzik <jeff@garzik.org>
Date:   Mon May 21 20:26:38 2007 -0400

    libata: bump versions
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 83bcc5b32597..1aabe15ad9d3 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -41,7 +41,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"pata_cs5520"
-#define DRV_VERSION	"0.6.4"
+#define DRV_VERSION	"0.6.5"
 
 struct pio_clocks
 {

commit 9666f4009c22f6520ac3fb8a19c9e32ab973e828
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri May 4 21:27:47 2007 +0200

    libata: reimplement suspend/resume support using sdev->manage_start_stop
    
    Reimplement suspend/resume support using sdev->manage_start_stop.
    
    * Device suspend/resume is now SCSI layer's responsibility and the
      code is simplified a lot.
    
    * DPM is dropped.  This also simplifies code a lot.  Suspend/resume
      status is port-wide now.
    
    * ata_scsi_device_suspend/resume() and ata_dev_ready() removed.
    
    * Resume now has to wait for disk to spin up before proceeding.  I
      couldn't find easy way out as libata is in EH waiting for the
      disk to be ready and sd is waiting for EH to complete to issue
      START_STOP.
    
    * sdev->manage_start_stop is set to 1 in ata_scsi_slave_config().
      This fixes spindown on shutdown and suspend-to-disk.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 79bef0d1fad3..83bcc5b32597 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -155,10 +155,6 @@ static struct scsi_host_template cs5520_sht = {
 	.slave_configure	= ata_scsi_slave_config,
 	.slave_destroy		= ata_scsi_slave_destroy,
 	.bios_param		= ata_std_bios_param,
-#ifdef CONFIG_PM
-	.resume			= ata_scsi_device_resume,
-	.suspend		= ata_scsi_device_suspend,
-#endif
 };
 
 static struct ata_port_operations cs5520_port_ops = {

commit 5d728824efeda61d304153bfcf1378a3c18b7d70
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Apr 17 23:44:08 2007 +0900

    libata: convert the remaining PATA drivers to new init model
    
    Convert pdc_adma, pata_cs5520, pata_isapnp, pata_ixp4xx_cf,
    pata_legacy, pata_mpc52xx, pata_mpiix, pata_pcmcia, pata_pdc2027x,
    pata_platform, pata_qdi, pata_scc and pata_winbond to new init model.
    
    * init_one()'s now follow more consistent init order
    
    * cs5520 now registers one host with two ports, not two hosts.  If any
      of the two ports are disabled, it's made dummy as other drivers do.
    
    Tested pdc_adma and pata_legacy.  Both are as broken as before.  The
    rest are compile tested only.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index b5b27baa0be1..79bef0d1fad3 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -186,7 +186,6 @@ static struct ata_port_operations cs5520_port_ops = {
 	.qc_issue		= ata_qc_issue_prot,
 	.data_xfer		= ata_data_xfer,
 
-	.irq_handler		= ata_interrupt,
 	.irq_clear		= ata_bmdma_irq_clear,
 	.irq_on			= ata_irq_on,
 	.irq_ack		= ata_irq_ack,
@@ -194,91 +193,104 @@ static struct ata_port_operations cs5520_port_ops = {
 	.port_start		= ata_port_start,
 };
 
-static int __devinit cs5520_init_one(struct pci_dev *dev, const struct pci_device_id *id)
+static int __devinit cs5520_init_one(struct pci_dev *pdev, const struct pci_device_id *id)
 {
+	struct ata_port_info pi = {
+		.flags		= ATA_FLAG_SLAVE_POSS,
+		.pio_mask	= 0x1f,
+		.port_ops	= &cs5520_port_ops,
+	};
+	const struct ata_port_info *ppi[2];
 	u8 pcicfg;
-	void __iomem *iomap[5];
-	static struct ata_probe_ent probe[2];
-	int ports = 0;
+	void *iomap[5];
+	struct ata_host *host;
+	struct ata_ioports *ioaddr;
+	int i, rc;
 
 	/* IDE port enable bits */
-	pci_read_config_byte(dev, 0x60, &pcicfg);
+	pci_read_config_byte(pdev, 0x60, &pcicfg);
 
 	/* Check if the ATA ports are enabled */
 	if ((pcicfg & 3) == 0)
 		return -ENODEV;
 
+	ppi[0] = ppi[1] = &ata_dummy_port_info;
+	if (pcicfg & 1)
+		ppi[0] = &pi;
+	if (pcicfg & 2)
+		ppi[1] = &pi;
+
 	if ((pcicfg & 0x40) == 0) {
-		printk(KERN_WARNING DRV_NAME ": DMA mode disabled. Enabling.\n");
-		pci_write_config_byte(dev, 0x60, pcicfg | 0x40);
+		dev_printk(KERN_WARNING, &pdev->dev,
+			   "DMA mode disabled. Enabling.\n");
+		pci_write_config_byte(pdev, 0x60, pcicfg | 0x40);
 	}
 
+	pi.mwdma_mask = id->driver_data;
+
+	host = ata_host_alloc_pinfo(&pdev->dev, ppi, 2);
+	if (!host)
+		return -ENOMEM;
+
 	/* Perform set up for DMA */
-	if (pci_enable_device_bars(dev, 1<<2)) {
+	if (pci_enable_device_bars(pdev, 1<<2)) {
 		printk(KERN_ERR DRV_NAME ": unable to configure BAR2.\n");
 		return -ENODEV;
 	}
-	pci_set_master(dev);
-	if (pci_set_dma_mask(dev, DMA_32BIT_MASK)) {
+
+	if (pci_set_dma_mask(pdev, DMA_32BIT_MASK)) {
 		printk(KERN_ERR DRV_NAME ": unable to configure DMA mask.\n");
 		return -ENODEV;
 	}
-	if (pci_set_consistent_dma_mask(dev, DMA_32BIT_MASK)) {
+	if (pci_set_consistent_dma_mask(pdev, DMA_32BIT_MASK)) {
 		printk(KERN_ERR DRV_NAME ": unable to configure consistent DMA mask.\n");
 		return -ENODEV;
 	}
 
-	/* Map IO ports */
-	iomap[0] = devm_ioport_map(&dev->dev, 0x1F0, 8);
-	iomap[1] = devm_ioport_map(&dev->dev, 0x3F6, 1);
-	iomap[2] = devm_ioport_map(&dev->dev, 0x170, 8);
-	iomap[3] = devm_ioport_map(&dev->dev, 0x376, 1);
-	iomap[4] = pcim_iomap(dev, 2, 0);
+	/* Map IO ports and initialize host accordingly */
+	iomap[0] = devm_ioport_map(&pdev->dev, 0x1F0, 8);
+	iomap[1] = devm_ioport_map(&pdev->dev, 0x3F6, 1);
+	iomap[2] = devm_ioport_map(&pdev->dev, 0x170, 8);
+	iomap[3] = devm_ioport_map(&pdev->dev, 0x376, 1);
+	iomap[4] = pcim_iomap(pdev, 2, 0);
 
 	if (!iomap[0] || !iomap[1] || !iomap[2] || !iomap[3] || !iomap[4])
 		return -ENOMEM;
 
-	/* We have to do our own plumbing as the PCI setup for this
-	   chipset is non-standard so we can't punt to the libata code */
-
-	INIT_LIST_HEAD(&probe[0].node);
-	probe[0].dev = pci_dev_to_dev(dev);
-	probe[0].port_ops = &cs5520_port_ops;
-	probe[0].sht = &cs5520_sht;
-	probe[0].pio_mask = 0x1F;
-	probe[0].mwdma_mask = id->driver_data;
-	probe[0].irq = 14;
-	probe[0].irq_flags = 0;
-	probe[0].port_flags = ATA_FLAG_SLAVE_POSS|ATA_FLAG_SRST;
-	probe[0].n_ports = 1;
-	probe[0].port[0].cmd_addr = iomap[0];
-	probe[0].port[0].ctl_addr = iomap[1];
-	probe[0].port[0].altstatus_addr = iomap[1];
-	probe[0].port[0].bmdma_addr = iomap[4];
-
-	/* The secondary lurks at different addresses but is otherwise
-	   the same beastie */
-
-	probe[1] = probe[0];
-	INIT_LIST_HEAD(&probe[1].node);
-	probe[1].irq = 15;
-	probe[1].port[0].cmd_addr = iomap[2];
-	probe[1].port[0].ctl_addr = iomap[3];
-	probe[1].port[0].altstatus_addr = iomap[3];
-	probe[1].port[0].bmdma_addr = iomap[4] + 8;
-
-	/* Let libata fill in the port details */
-	ata_std_ports(&probe[0].port[0]);
-	ata_std_ports(&probe[1].port[0]);
-
-	/* Now add the ports that are active */
-	if (pcicfg & 1)
-		ports += ata_device_add(&probe[0]);
-	if (pcicfg & 2)
-		ports += ata_device_add(&probe[1]);
-	if (ports)
-		return 0;
-	return -ENODEV;
+	ioaddr = &host->ports[0]->ioaddr;
+	ioaddr->cmd_addr = iomap[0];
+	ioaddr->ctl_addr = iomap[1];
+	ioaddr->altstatus_addr = iomap[1];
+	ioaddr->bmdma_addr = iomap[4];
+	ata_std_ports(ioaddr);
+
+	ioaddr = &host->ports[1]->ioaddr;
+	ioaddr->cmd_addr = iomap[2];
+	ioaddr->ctl_addr = iomap[3];
+	ioaddr->altstatus_addr = iomap[3];
+	ioaddr->bmdma_addr = iomap[4] + 8;
+	ata_std_ports(ioaddr);
+
+	/* activate the host */
+	pci_set_master(pdev);
+	rc = ata_host_start(host);
+	if (rc)
+		return rc;
+
+	for (i = 0; i < 2; i++) {
+		static const int irq[] = { 14, 15 };
+		struct ata_port *ap = host->ports[0];
+
+		if (ata_port_is_dummy(ap))
+			continue;
+
+		rc = devm_request_irq(&pdev->dev, irq[ap->port_no],
+				      ata_interrupt, 0, DRV_NAME, host);
+		if (rc)
+			return rc;
+	}
+
+	return ata_host_register(host, &cs5520_sht);
 }
 
 /**

commit a73984a0d5664fa1bfdd9f0a475b8d74af7f44a6
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Mar 9 08:37:46 2007 -0500

    [libata] More PATA driver ->cable_detect support
    
    Roll-up of ->cable_detect feature addition patches, authored and
    signed-off-by Alan Cox.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 55cc293e7487..b5b27baa0be1 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -139,18 +139,6 @@ static void cs5520_set_piomode(struct ata_port *ap, struct ata_device *adev)
 	cs5520_set_timings(ap, adev, adev->pio_mode);
 }
 
-
-static int cs5520_pre_reset(struct ata_port *ap)
-{
-	ap->cbl = ATA_CBL_PATA40;
-	return ata_std_prereset(ap);
-}
-
-static void cs5520_error_handler(struct ata_port *ap)
-{
-	return ata_bmdma_drive_eh(ap, cs5520_pre_reset, ata_std_softreset, NULL, ata_std_postreset);
-}
-
 static struct scsi_host_template cs5520_sht = {
 	.module			= THIS_MODULE,
 	.name			= DRV_NAME,
@@ -186,8 +174,9 @@ static struct ata_port_operations cs5520_port_ops = {
 
 	.freeze			= ata_bmdma_freeze,
 	.thaw			= ata_bmdma_thaw,
-	.error_handler		= cs5520_error_handler,
+	.error_handler		= ata_bmdma_error_handler,
 	.post_internal_cmd	= ata_bmdma_post_internal_cmd,
+	.cable_detect		= ata_cable_40wire,
 
 	.bmdma_setup		= ata_bmdma_setup,
 	.bmdma_start		= ata_bmdma_start,

commit edceec3d6737ae2c901d9abc55f791cf3b42c470
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Wed Mar 14 09:19:00 2007 +0000

    [PATCH] trivial ATA iomem annotations
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: Jeff Garzik <jgarzik@pobox.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 7ef834250a43..55cc293e7487 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -208,7 +208,7 @@ static struct ata_port_operations cs5520_port_ops = {
 static int __devinit cs5520_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	u8 pcicfg;
-	void *iomap[5];
+	void __iomem *iomap[5];
 	static struct ata_probe_ent probe[2];
 	int ports = 0;
 

commit 438ac6d5e3f8106a6bd1a5682c508d660294a85d
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Mar 2 17:31:26 2007 +0900

    libata: add missing CONFIG_PM in LLDs
    
    Add missing #ifdef CONFIG_PM conditionals around all PM related parts
    in libata LLDs.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 8ff2d58c599e..7ef834250a43 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -167,8 +167,10 @@ static struct scsi_host_template cs5520_sht = {
 	.slave_configure	= ata_scsi_slave_config,
 	.slave_destroy		= ata_scsi_slave_destroy,
 	.bios_param		= ata_std_bios_param,
+#ifdef CONFIG_PM
 	.resume			= ata_scsi_device_resume,
 	.suspend		= ata_scsi_device_suspend,
+#endif
 };
 
 static struct ata_port_operations cs5520_port_ops = {
@@ -308,6 +310,7 @@ static void __devexit cs5520_remove_one(struct pci_dev *pdev)
 	ata_host_detach(host);
 }
 
+#ifdef CONFIG_PM
 /**
  *	cs5520_reinit_one	-	device resume
  *	@pdev: PCI device
@@ -347,6 +350,7 @@ static int cs5520_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)
 	pci_save_state(pdev);
 	return 0;
 }
+#endif /* CONFIG_PM */
 
 /* For now keep DMA off. We can set it for all but A rev CS5510 once the
    core ATA code can handle it */
@@ -363,8 +367,10 @@ static struct pci_driver cs5520_pci_driver = {
 	.id_table	= pata_cs5520,
 	.probe 		= cs5520_init_one,
 	.remove		= cs5520_remove_one,
+#ifdef CONFIG_PM
 	.suspend	= cs5520_pci_device_suspend,
 	.resume		= cs5520_reinit_one,
+#endif
 };
 
 static int __init cs5520_init(void)

commit 1aa56cca5bfa396c791e93b38e4776ef39b590a7
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Feb 27 22:33:21 2007 +0900

    libata: clear drvdata in ata_host_release(), take#2
    
    Clearing drvdata in ->remove_one causes NULL pointer deference.  Clear
    drvdata only in ata_host_release() after all resources are freed.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index c1334c6c4156..8ff2d58c599e 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -306,7 +306,6 @@ static void __devexit cs5520_remove_one(struct pci_dev *pdev)
 	struct ata_host *host = dev_get_drvdata(dev);
 
 	ata_host_detach(host);
-	dev_set_drvdata(dev, NULL);
 }
 
 /**

commit cb48cab7f363014e0a5dc21f7b4892c15d626d41
Author: Jeff Garzik <jeff@garzik.org>
Date:   Mon Feb 26 06:04:24 2007 -0500

    [libata] bump versions
    
    Bump versions based on changes submitted during 2.6.21 merge window.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 21dcf395791b..c1334c6c4156 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -41,7 +41,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"pata_cs5520"
-#define DRV_VERSION	"0.6.3"
+#define DRV_VERSION	"0.6.4"
 
 struct pio_clocks
 {

commit a84471fe269c38ea3725345c43ad64e5f489bea2
Author: Jeff Garzik <jeff@garzik.org>
Date:   Mon Feb 26 05:51:33 2007 -0500

    [libata] Trim trailing whitespace.
    
    No code changes.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index b49d8b70577a..21dcf395791b 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -348,7 +348,7 @@ static int cs5520_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)
 	pci_save_state(pdev);
 	return 0;
 }
- 
+
 /* For now keep DMA off. We can set it for all but A rev CS5510 once the
    core ATA code can handle it */
 

commit aa6de4942c25f05cb7f4aa8efa20c5ec0884d8f1
Author: Alan <alan@lxorguk.ukuu.org.uk>
Date:   Tue Feb 20 17:44:25 2007 +0000

    pata_cs5520: suspend/resume
    
    The CS5520 isn't just an ATA controller and we must not
    pci_disable_device it as it turns into pci_disable_computer.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 1ce8fcfd7826..b49d8b70577a 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -325,6 +325,30 @@ static int cs5520_reinit_one(struct pci_dev *pdev)
 		pci_write_config_byte(pdev, 0x60, pcicfg | 0x40);
 	return ata_pci_device_resume(pdev);
 }
+
+/**
+ *	cs5520_pci_device_suspend	-	device suspend
+ *	@pdev: PCI device
+ *
+ *	We have to cut and waste bits from the standard method because
+ *	the 5520 is a bit odd and not just a pure ATA device. As a result
+ *	we must not disable it. The needed code is short and this avoids
+ *	chip specific mess in the core code.
+ */
+
+static int cs5520_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)
+{
+	struct ata_host *host = dev_get_drvdata(&pdev->dev);
+	int rc = 0;
+
+	rc = ata_host_suspend(host, mesg);
+	if (rc)
+		return rc;
+
+	pci_save_state(pdev);
+	return 0;
+}
+ 
 /* For now keep DMA off. We can set it for all but A rev CS5510 once the
    core ATA code can handle it */
 
@@ -340,7 +364,7 @@ static struct pci_driver cs5520_pci_driver = {
 	.id_table	= pata_cs5520,
 	.probe 		= cs5520_init_one,
 	.remove		= cs5520_remove_one,
-	.suspend	= ata_pci_device_suspend,
+	.suspend	= cs5520_pci_device_suspend,
 	.resume		= cs5520_reinit_one,
 };
 

commit 246ce3b675843e0369643cceb4faeb6cf6d19a30
Author: Akira Iguchi <akira2.iguchi@toshiba.co.jp>
Date:   Fri Jan 26 16:27:58 2007 +0900

    libata: add another IRQ calls (libata drivers)
    
    This patch is against each libata driver.
    
    Two IRQ calls are added in ata_port_operations.
    - irq_on() is used to enable interrupts.
    - irq_ack() is used to acknowledge a device interrupt.
    
    In most drivers, ata_irq_on() and ata_irq_ack() are used for
    irq_on and irq_ack respectively.
    
    In some drivers (ex: ahci, sata_sil24) which cannot use them
    as is, ata_dummy_irq_on() and ata_dummy_irq_ack() are used.
    
    Signed-off-by: Kou Ishizaki <kou.ishizaki@toshiba.co.jp>
    Signed-off-by: Akira Iguchi <akira2.iguchi@toshiba.co.jp>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 801a00efa3ee..1ce8fcfd7826 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -197,6 +197,8 @@ static struct ata_port_operations cs5520_port_ops = {
 
 	.irq_handler		= ata_interrupt,
 	.irq_clear		= ata_bmdma_irq_clear,
+	.irq_on			= ata_irq_on,
+	.irq_ack		= ata_irq_ack,
 
 	.port_start		= ata_port_start,
 };

commit 0d5ff566779f894ca9937231a181eb31e4adff0e
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Feb 1 15:06:36 2007 +0900

    libata: convert to iomap
    
    Convert libata core layer and LLDs to use iomap.
    
    * managed iomap is used.  Pointer to pcim_iomap_table() is cached at
      host->iomap and used through out LLDs.  This basically replaces
      host->mmio_base.
    
    * if possible, pcim_iomap_regions() is used
    
    Most iomap operation conversions are taken from Jeff Garzik
    <jgarzik@pobox.com>'s iomap branch.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 63bdcbe45583..801a00efa3ee 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -99,9 +99,9 @@ static void cs5520_set_timings(struct ata_port *ap, struct ata_device *adev, int
 static void cs5520_enable_dma(struct ata_port *ap, struct ata_device *adev)
 {
 	/* Set the DMA enable/disable flag */
-	u8 reg = inb(ap->ioaddr.bmdma_addr + 0x02);
+	u8 reg = ioread8(ap->ioaddr.bmdma_addr + 0x02);
 	reg |= 1<<(adev->devno + 5);
-	outb(reg, ap->ioaddr.bmdma_addr + 0x02);
+	iowrite8(reg, ap->ioaddr.bmdma_addr + 0x02);
 }
 
 /**
@@ -193,7 +193,7 @@ static struct ata_port_operations cs5520_port_ops = {
 	.bmdma_status		= ata_bmdma_status,
 	.qc_prep		= ata_qc_prep,
 	.qc_issue		= ata_qc_issue_prot,
-	.data_xfer		= ata_pio_data_xfer,
+	.data_xfer		= ata_data_xfer,
 
 	.irq_handler		= ata_interrupt,
 	.irq_clear		= ata_bmdma_irq_clear,
@@ -204,6 +204,7 @@ static struct ata_port_operations cs5520_port_ops = {
 static int __devinit cs5520_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	u8 pcicfg;
+	void *iomap[5];
 	static struct ata_probe_ent probe[2];
 	int ports = 0;
 
@@ -234,6 +235,16 @@ static int __devinit cs5520_init_one(struct pci_dev *dev, const struct pci_devic
 		return -ENODEV;
 	}
 
+	/* Map IO ports */
+	iomap[0] = devm_ioport_map(&dev->dev, 0x1F0, 8);
+	iomap[1] = devm_ioport_map(&dev->dev, 0x3F6, 1);
+	iomap[2] = devm_ioport_map(&dev->dev, 0x170, 8);
+	iomap[3] = devm_ioport_map(&dev->dev, 0x376, 1);
+	iomap[4] = pcim_iomap(dev, 2, 0);
+
+	if (!iomap[0] || !iomap[1] || !iomap[2] || !iomap[3] || !iomap[4])
+		return -ENOMEM;
+
 	/* We have to do our own plumbing as the PCI setup for this
 	   chipset is non-standard so we can't punt to the libata code */
 
@@ -247,10 +258,10 @@ static int __devinit cs5520_init_one(struct pci_dev *dev, const struct pci_devic
 	probe[0].irq_flags = 0;
 	probe[0].port_flags = ATA_FLAG_SLAVE_POSS|ATA_FLAG_SRST;
 	probe[0].n_ports = 1;
-	probe[0].port[0].cmd_addr = 0x1F0;
-	probe[0].port[0].ctl_addr = 0x3F6;
-	probe[0].port[0].altstatus_addr = 0x3F6;
-	probe[0].port[0].bmdma_addr = pci_resource_start(dev, 2);
+	probe[0].port[0].cmd_addr = iomap[0];
+	probe[0].port[0].ctl_addr = iomap[1];
+	probe[0].port[0].altstatus_addr = iomap[1];
+	probe[0].port[0].bmdma_addr = iomap[4];
 
 	/* The secondary lurks at different addresses but is otherwise
 	   the same beastie */
@@ -258,10 +269,10 @@ static int __devinit cs5520_init_one(struct pci_dev *dev, const struct pci_devic
 	probe[1] = probe[0];
 	INIT_LIST_HEAD(&probe[1].node);
 	probe[1].irq = 15;
-	probe[1].port[0].cmd_addr = 0x170;
-	probe[1].port[0].ctl_addr = 0x376;
-	probe[1].port[0].altstatus_addr = 0x376;
-	probe[1].port[0].bmdma_addr = pci_resource_start(dev, 2) + 8;
+	probe[1].port[0].cmd_addr = iomap[2];
+	probe[1].port[0].ctl_addr = iomap[3];
+	probe[1].port[0].altstatus_addr = iomap[3];
+	probe[1].port[0].bmdma_addr = iomap[4] + 8;
 
 	/* Let libata fill in the port details */
 	ata_std_ports(&probe[0].port[0]);

commit 24dc5f33ea4b504cfbd23fa159a4cacba8e4d800
Author: Tejun Heo <htejun@gmail.com>
Date:   Sat Jan 20 16:00:28 2007 +0900

    libata: update libata LLDs to use devres
    
    Update libata LLDs to use devres.  Core layer is already converted to
    support managed LLDs.  This patch simplifies initialization and fixes
    many resource related bugs in init failure and detach path.  For
    example, all converted drivers now handle ata_device_add() failure
    gracefully without excessive resource rollback code.
    
    As most resources are released automatically on driver detach, many
    drivers don't need or can do with much simpler ->{port|host}_stop().
    In general, stop callbacks are need iff port or host needs to be given
    commands to shut it down.  Note that freezing is enough in many cases
    and ports are automatically frozen before being detached.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 476b87963f5d..63bdcbe45583 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -199,8 +199,6 @@ static struct ata_port_operations cs5520_port_ops = {
 	.irq_clear		= ata_bmdma_irq_clear,
 
 	.port_start		= ata_port_start,
-	.port_stop		= ata_port_stop,
-	.host_stop		= ata_host_stop,
 };
 
 static int __devinit cs5520_init_one(struct pci_dev *dev, const struct pci_device_id *id)
@@ -294,7 +292,7 @@ static void __devexit cs5520_remove_one(struct pci_dev *pdev)
 	struct device *dev = pci_dev_to_dev(pdev);
 	struct ata_host *host = dev_get_drvdata(dev);
 
-	ata_host_remove(host);
+	ata_host_detach(host);
 	dev_set_drvdata(dev, NULL);
 }
 

commit f20b16ff7c19d1c369ee07470952aca093551ed0
Author: Jeff Garzik <jeff@garzik.org>
Date:   Mon Dec 11 11:14:06 2006 -0500

    [libata] trim trailing whitespace
    
    Most of these contributed by that mysterious figger known as A.C.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 9f165a8e032d..476b87963f5d 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -305,7 +305,7 @@ static void __devexit cs5520_remove_one(struct pci_dev *pdev)
  *	Do any reconfiguration work needed by a resume from RAM. We need
  *	to restore DMA mode support on BIOSen which disabled it
  */
- 
+
 static int cs5520_reinit_one(struct pci_dev *pdev)
 {
 	u8 pcicfg;

commit 2eab80ac0c96fb98267afeb12a4899801564c75b
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Nov 29 12:20:26 2006 +0900

    [PATCH] libata: kill unnecessary sht->max_sectors initializations
    
    sht->max_sectors is overrided unconditionally in ->slave_configure.
    There's no reason to set it to any value.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index f839c0304b3a..9f165a8e032d 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -159,7 +159,6 @@ static struct scsi_host_template cs5520_sht = {
 	.can_queue		= ATA_DEF_QUEUE,
 	.this_id		= ATA_SHT_THIS_ID,
 	.sg_tablesize		= LIBATA_MAX_PRD,
-	.max_sectors		= ATA_MAX_SECTORS,
 	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
 	.emulated		= ATA_SHT_EMULATED,
 	.use_clustering		= ATA_SHT_USE_CLUSTERING,

commit 8501120f1df1aa6abe38b51ab91df08ccaa1b971
Author: Alan <alan@lxorguk.ukuu.org.uk>
Date:   Wed Nov 22 17:01:06 2006 +0000

    [PATCH] pata_cs5520: resume support
    
    The CS5520 doesn't need much help to resume but we do need to restore
    pcicfg which may have been reset to the BIOS default which is
    sometimes incorrect.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 33d2b88f9c79..f839c0304b3a 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -41,7 +41,7 @@
 #include <linux/libata.h>
 
 #define DRV_NAME	"pata_cs5520"
-#define DRV_VERSION	"0.6.2"
+#define DRV_VERSION	"0.6.3"
 
 struct pio_clocks
 {
@@ -168,6 +168,8 @@ static struct scsi_host_template cs5520_sht = {
 	.slave_configure	= ata_scsi_slave_config,
 	.slave_destroy		= ata_scsi_slave_destroy,
 	.bios_param		= ata_std_bios_param,
+	.resume			= ata_scsi_device_resume,
+	.suspend		= ata_scsi_device_suspend,
 };
 
 static struct ata_port_operations cs5520_port_ops = {
@@ -297,6 +299,22 @@ static void __devexit cs5520_remove_one(struct pci_dev *pdev)
 	dev_set_drvdata(dev, NULL);
 }
 
+/**
+ *	cs5520_reinit_one	-	device resume
+ *	@pdev: PCI device
+ *
+ *	Do any reconfiguration work needed by a resume from RAM. We need
+ *	to restore DMA mode support on BIOSen which disabled it
+ */
+ 
+static int cs5520_reinit_one(struct pci_dev *pdev)
+{
+	u8 pcicfg;
+	pci_read_config_byte(pdev, 0x60, &pcicfg);
+	if ((pcicfg & 0x40) == 0)
+		pci_write_config_byte(pdev, 0x60, pcicfg | 0x40);
+	return ata_pci_device_resume(pdev);
+}
 /* For now keep DMA off. We can set it for all but A rev CS5510 once the
    core ATA code can handle it */
 
@@ -311,7 +329,9 @@ static struct pci_driver cs5520_pci_driver = {
 	.name 		= DRV_NAME,
 	.id_table	= pata_cs5520,
 	.probe 		= cs5520_init_one,
-	.remove		= cs5520_remove_one
+	.remove		= cs5520_remove_one,
+	.suspend	= ata_pci_device_suspend,
+	.resume		= cs5520_reinit_one,
 };
 
 static int __init cs5520_init(void)

commit afdfe899e6420eac6c5eb3bc8c89456dff38d40e
Author: Tejun Heo <htejun@gmail.com>
Date:   Wed Nov 29 11:26:47 2006 +0900

    [PATCH] libata: add missing sht->slave_destroy
    
    Many LLDs are missing sht->slave_destroy.  The method is mandatory to
    support device warm unplugging (echo 1 > /sys/.../delete).  Without
    it, libata might access released scsi device.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 2cd3c0ff76df..33d2b88f9c79 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -166,6 +166,7 @@ static struct scsi_host_template cs5520_sht = {
 	.proc_name		= DRV_NAME,
 	.dma_boundary		= ATA_DMA_BOUNDARY,
 	.slave_configure	= ata_scsi_slave_config,
+	.slave_destroy		= ata_scsi_slave_destroy,
 	.bios_param		= ata_std_bios_param,
 };
 

commit 2d2744fc8be620a2dc469cf48349e3e704119f1b
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Sep 28 20:21:59 2006 -0400

    [libata] PCI ID table cleanup in various drivers
    
    * Use PCI_VDEVICE() macro
    * const-ify pci_device_id table
    * standardize list terminator as "{ }"
    * convert spaces to tab in pci_driver struct (Alan-ism)
    * various minor whitespace cleanups
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index a6c6cebd0dae..2cd3c0ff76df 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -299,10 +299,11 @@ static void __devexit cs5520_remove_one(struct pci_dev *pdev)
 /* For now keep DMA off. We can set it for all but A rev CS5510 once the
    core ATA code can handle it */
 
-static struct pci_device_id pata_cs5520[] = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_CYRIX, PCI_DEVICE_ID_CYRIX_5510), },
-	{ PCI_DEVICE(PCI_VENDOR_ID_CYRIX, PCI_DEVICE_ID_CYRIX_5520), },
-	{ 0, },
+static const struct pci_device_id pata_cs5520[] = {
+	{ PCI_VDEVICE(CYRIX, PCI_DEVICE_ID_CYRIX_5510), },
+	{ PCI_VDEVICE(CYRIX, PCI_DEVICE_ID_CYRIX_5520), },
+
+	{ },
 };
 
 static struct pci_driver cs5520_pci_driver = {
@@ -312,7 +313,6 @@ static struct pci_driver cs5520_pci_driver = {
 	.remove		= cs5520_remove_one
 };
 
-
 static int __init cs5520_init(void)
 {
 	return pci_register_driver(&cs5520_pci_driver);

commit bda3028813bd07f34f30288a492fbf6f7b8712dd
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Sep 27 05:41:13 2006 -0400

    [libata] Don't use old-EH ->eng_timeout() hook when not needed
    
    The PATA driver set got converted to the new error handling setup, but
    the old hooks were accidentally left in place.  Now, removed.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
index 792ce4828510..a6c6cebd0dae 100644
--- a/drivers/ata/pata_cs5520.c
+++ b/drivers/ata/pata_cs5520.c
@@ -193,8 +193,6 @@ static struct ata_port_operations cs5520_port_ops = {
 	.qc_issue		= ata_qc_issue_prot,
 	.data_xfer		= ata_pio_data_xfer,
 
-	.eng_timeout		= ata_eng_timeout,
-
 	.irq_handler		= ata_interrupt,
 	.irq_clear		= ata_bmdma_irq_clear,
 

commit 669a5db411d85a14f86cd92bc16bf7ab5b8aa235
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Aug 29 18:12:40 2006 -0400

    [libata] Add a bunch of PATA drivers.
    
    The vast majority of drivers and changes are from Alan Cox.  Albert Lee
    contributed and maintains pata_pdc2027x.  Adrian Bunk, Andrew Morton,
    and Tejun Heo contributed various minor fixes and updates.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/ata/pata_cs5520.c b/drivers/ata/pata_cs5520.c
new file mode 100644
index 000000000000..792ce4828510
--- /dev/null
+++ b/drivers/ata/pata_cs5520.c
@@ -0,0 +1,336 @@
+/*
+ *	IDE tuning and bus mastering support for the CS5510/CS5520
+ *	chipsets
+ *
+ *	The CS5510/CS5520 are slightly unusual devices. Unlike the
+ *	typical IDE controllers they do bus mastering with the drive in
+ *	PIO mode and smarter silicon.
+ *
+ *	The practical upshot of this is that we must always tune the
+ *	drive for the right PIO mode. We must also ignore all the blacklists
+ *	and the drive bus mastering DMA information. Also to confuse matters
+ *	further we can do DMA on PIO only drives.
+ *
+ *	DMA on the 5510 also requires we disable_hlt() during DMA on early
+ *	revisions.
+ *
+ *	*** This driver is strictly experimental ***
+ *
+ *	(c) Copyright Red Hat Inc 2002
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * Documentation:
+ *	Not publically available.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include <scsi/scsi_host.h>
+#include <linux/libata.h>
+
+#define DRV_NAME	"pata_cs5520"
+#define DRV_VERSION	"0.6.2"
+
+struct pio_clocks
+{
+	int address;
+	int assert;
+	int recovery;
+};
+
+static const struct pio_clocks cs5520_pio_clocks[]={
+	{3, 6, 11},
+	{2, 5, 6},
+	{1, 4, 3},
+	{1, 3, 2},
+	{1, 2, 1}
+};
+
+/**
+ *	cs5520_set_timings	-	program PIO timings
+ *	@ap: ATA port
+ *	@adev: ATA device
+ *
+ *	Program the PIO mode timings for the controller according to the pio
+ *	clocking table.
+ */
+
+static void cs5520_set_timings(struct ata_port *ap, struct ata_device *adev, int pio)
+{
+	struct pci_dev *pdev = to_pci_dev(ap->host->dev);
+	int slave = adev->devno;
+
+	pio -= XFER_PIO_0;
+
+	/* Channel command timing */
+	pci_write_config_byte(pdev, 0x62 + ap->port_no,
+				(cs5520_pio_clocks[pio].recovery << 4) |
+				(cs5520_pio_clocks[pio].assert));
+	/* FIXME: should these use address ? */
+	/* Read command timing */
+	pci_write_config_byte(pdev, 0x64 +  4*ap->port_no + slave,
+				(cs5520_pio_clocks[pio].recovery << 4) |
+				(cs5520_pio_clocks[pio].assert));
+	/* Write command timing */
+	pci_write_config_byte(pdev, 0x66 +  4*ap->port_no + slave,
+				(cs5520_pio_clocks[pio].recovery << 4) |
+				(cs5520_pio_clocks[pio].assert));
+}
+
+/**
+ *	cs5520_enable_dma	-	turn on DMA bits
+ *
+ *	Turn on the DMA bits for this disk. Needed because the BIOS probably
+ *	has not done the work for us. Belongs in the core SATA code.
+ */
+
+static void cs5520_enable_dma(struct ata_port *ap, struct ata_device *adev)
+{
+	/* Set the DMA enable/disable flag */
+	u8 reg = inb(ap->ioaddr.bmdma_addr + 0x02);
+	reg |= 1<<(adev->devno + 5);
+	outb(reg, ap->ioaddr.bmdma_addr + 0x02);
+}
+
+/**
+ *	cs5520_set_dmamode	-	program DMA timings
+ *	@ap: ATA port
+ *	@adev: ATA device
+ *
+ *	Program the DMA mode timings for the controller according to the pio
+ *	clocking table. Note that this device sets the DMA timings to PIO
+ *	mode values. This may seem bizarre but the 5520 architecture talks
+ *	PIO mode to the disk and DMA mode to the controller so the underlying
+ *	transfers are PIO timed.
+ */
+
+static void cs5520_set_dmamode(struct ata_port *ap, struct ata_device *adev)
+{
+	static const int dma_xlate[3] = { XFER_PIO_0, XFER_PIO_3, XFER_PIO_4 };
+	cs5520_set_timings(ap, adev, dma_xlate[adev->dma_mode]);
+	cs5520_enable_dma(ap, adev);
+}
+
+/**
+ *	cs5520_set_piomode	-	program PIO timings
+ *	@ap: ATA port
+ *	@adev: ATA device
+ *
+ *	Program the PIO mode timings for the controller according to the pio
+ *	clocking table. We know pio_mode will equal dma_mode because of the
+ *	CS5520 architecture. At least once we turned DMA on and wrote a
+ *	mode setter.
+ */
+
+static void cs5520_set_piomode(struct ata_port *ap, struct ata_device *adev)
+{
+	cs5520_set_timings(ap, adev, adev->pio_mode);
+}
+
+
+static int cs5520_pre_reset(struct ata_port *ap)
+{
+	ap->cbl = ATA_CBL_PATA40;
+	return ata_std_prereset(ap);
+}
+
+static void cs5520_error_handler(struct ata_port *ap)
+{
+	return ata_bmdma_drive_eh(ap, cs5520_pre_reset, ata_std_softreset, NULL, ata_std_postreset);
+}
+
+static struct scsi_host_template cs5520_sht = {
+	.module			= THIS_MODULE,
+	.name			= DRV_NAME,
+	.ioctl			= ata_scsi_ioctl,
+	.queuecommand		= ata_scsi_queuecmd,
+	.can_queue		= ATA_DEF_QUEUE,
+	.this_id		= ATA_SHT_THIS_ID,
+	.sg_tablesize		= LIBATA_MAX_PRD,
+	.max_sectors		= ATA_MAX_SECTORS,
+	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
+	.emulated		= ATA_SHT_EMULATED,
+	.use_clustering		= ATA_SHT_USE_CLUSTERING,
+	.proc_name		= DRV_NAME,
+	.dma_boundary		= ATA_DMA_BOUNDARY,
+	.slave_configure	= ata_scsi_slave_config,
+	.bios_param		= ata_std_bios_param,
+};
+
+static struct ata_port_operations cs5520_port_ops = {
+	.port_disable		= ata_port_disable,
+	.set_piomode		= cs5520_set_piomode,
+	.set_dmamode		= cs5520_set_dmamode,
+
+	.tf_load		= ata_tf_load,
+	.tf_read		= ata_tf_read,
+	.check_status		= ata_check_status,
+	.exec_command		= ata_exec_command,
+	.dev_select		= ata_std_dev_select,
+
+	.freeze			= ata_bmdma_freeze,
+	.thaw			= ata_bmdma_thaw,
+	.error_handler		= cs5520_error_handler,
+	.post_internal_cmd	= ata_bmdma_post_internal_cmd,
+
+	.bmdma_setup		= ata_bmdma_setup,
+	.bmdma_start		= ata_bmdma_start,
+	.bmdma_stop		= ata_bmdma_stop,
+	.bmdma_status		= ata_bmdma_status,
+	.qc_prep		= ata_qc_prep,
+	.qc_issue		= ata_qc_issue_prot,
+	.data_xfer		= ata_pio_data_xfer,
+
+	.eng_timeout		= ata_eng_timeout,
+
+	.irq_handler		= ata_interrupt,
+	.irq_clear		= ata_bmdma_irq_clear,
+
+	.port_start		= ata_port_start,
+	.port_stop		= ata_port_stop,
+	.host_stop		= ata_host_stop,
+};
+
+static int __devinit cs5520_init_one(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	u8 pcicfg;
+	static struct ata_probe_ent probe[2];
+	int ports = 0;
+
+	/* IDE port enable bits */
+	pci_read_config_byte(dev, 0x60, &pcicfg);
+
+	/* Check if the ATA ports are enabled */
+	if ((pcicfg & 3) == 0)
+		return -ENODEV;
+
+	if ((pcicfg & 0x40) == 0) {
+		printk(KERN_WARNING DRV_NAME ": DMA mode disabled. Enabling.\n");
+		pci_write_config_byte(dev, 0x60, pcicfg | 0x40);
+	}
+
+	/* Perform set up for DMA */
+	if (pci_enable_device_bars(dev, 1<<2)) {
+		printk(KERN_ERR DRV_NAME ": unable to configure BAR2.\n");
+		return -ENODEV;
+	}
+	pci_set_master(dev);
+	if (pci_set_dma_mask(dev, DMA_32BIT_MASK)) {
+		printk(KERN_ERR DRV_NAME ": unable to configure DMA mask.\n");
+		return -ENODEV;
+	}
+	if (pci_set_consistent_dma_mask(dev, DMA_32BIT_MASK)) {
+		printk(KERN_ERR DRV_NAME ": unable to configure consistent DMA mask.\n");
+		return -ENODEV;
+	}
+
+	/* We have to do our own plumbing as the PCI setup for this
+	   chipset is non-standard so we can't punt to the libata code */
+
+	INIT_LIST_HEAD(&probe[0].node);
+	probe[0].dev = pci_dev_to_dev(dev);
+	probe[0].port_ops = &cs5520_port_ops;
+	probe[0].sht = &cs5520_sht;
+	probe[0].pio_mask = 0x1F;
+	probe[0].mwdma_mask = id->driver_data;
+	probe[0].irq = 14;
+	probe[0].irq_flags = 0;
+	probe[0].port_flags = ATA_FLAG_SLAVE_POSS|ATA_FLAG_SRST;
+	probe[0].n_ports = 1;
+	probe[0].port[0].cmd_addr = 0x1F0;
+	probe[0].port[0].ctl_addr = 0x3F6;
+	probe[0].port[0].altstatus_addr = 0x3F6;
+	probe[0].port[0].bmdma_addr = pci_resource_start(dev, 2);
+
+	/* The secondary lurks at different addresses but is otherwise
+	   the same beastie */
+
+	probe[1] = probe[0];
+	INIT_LIST_HEAD(&probe[1].node);
+	probe[1].irq = 15;
+	probe[1].port[0].cmd_addr = 0x170;
+	probe[1].port[0].ctl_addr = 0x376;
+	probe[1].port[0].altstatus_addr = 0x376;
+	probe[1].port[0].bmdma_addr = pci_resource_start(dev, 2) + 8;
+
+	/* Let libata fill in the port details */
+	ata_std_ports(&probe[0].port[0]);
+	ata_std_ports(&probe[1].port[0]);
+
+	/* Now add the ports that are active */
+	if (pcicfg & 1)
+		ports += ata_device_add(&probe[0]);
+	if (pcicfg & 2)
+		ports += ata_device_add(&probe[1]);
+	if (ports)
+		return 0;
+	return -ENODEV;
+}
+
+/**
+ *	cs5520_remove_one	-	device unload
+ *	@pdev: PCI device being removed
+ *
+ *	Handle an unplug/unload event for a PCI device. Unload the
+ *	PCI driver but do not use the default handler as we manage
+ *	resources ourself and *MUST NOT* disable the device as it has
+ *	other functions.
+ */
+
+static void __devexit cs5520_remove_one(struct pci_dev *pdev)
+{
+	struct device *dev = pci_dev_to_dev(pdev);
+	struct ata_host *host = dev_get_drvdata(dev);
+
+	ata_host_remove(host);
+	dev_set_drvdata(dev, NULL);
+}
+
+/* For now keep DMA off. We can set it for all but A rev CS5510 once the
+   core ATA code can handle it */
+
+static struct pci_device_id pata_cs5520[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CYRIX, PCI_DEVICE_ID_CYRIX_5510), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CYRIX, PCI_DEVICE_ID_CYRIX_5520), },
+	{ 0, },
+};
+
+static struct pci_driver cs5520_pci_driver = {
+	.name 		= DRV_NAME,
+	.id_table	= pata_cs5520,
+	.probe 		= cs5520_init_one,
+	.remove		= cs5520_remove_one
+};
+
+
+static int __init cs5520_init(void)
+{
+	return pci_register_driver(&cs5520_pci_driver);
+}
+
+static void __exit cs5520_exit(void)
+{
+	pci_unregister_driver(&cs5520_pci_driver);
+}
+
+MODULE_AUTHOR("Alan Cox");
+MODULE_DESCRIPTION("low-level driver for Cyrix CS5510/5520");
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(pci, pata_cs5520);
+MODULE_VERSION(DRV_VERSION);
+
+module_init(cs5520_init);
+module_exit(cs5520_exit);
+
