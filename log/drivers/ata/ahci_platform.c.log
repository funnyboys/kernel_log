commit 8d7c56d08fafd55887de16bf7f9c2817a1257bab
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 19:08:10 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 45
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 or at your option any
      later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 11 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520170858.370933192@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index cf1e0e18a7a9..3aab2e3d57f3 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * AHCI SATA platform driver
  *
@@ -5,11 +6,6 @@
  *   Jeff Garzik <jgarzik@pobox.com>
  * Copyright 2010  MontaVista Software, LLC.
  *   Anton Vorontsov <avorontsov@ru.mvista.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
  */
 
 #include <linux/kernel.h>

commit 20bdc376b427cb420836f39ee8f281ea85dbaeef
Author: Suman Tripathi <stripathi@amperecomputing.com>
Date:   Fri Sep 7 08:32:17 2018 -0600

    ata: Disable AHCI ALPM feature for Ampere Computing eMAG SATA
    
    Due to hardware errata, Ampere Computing eMAG SATA can't support
    AHCI ALPM feature. This patch disables the AHCI ALPM feature for
    eMAG SATA.
    
    Signed-off-by: Suman Trpathi <stripathi@amperecomputing.com>
    Signed-off-by: Rameshwar Prasad Sahu <rameshwar.sahu@amperecomputing.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 46f0bd75eff7..cf1e0e18a7a9 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -33,6 +33,13 @@ static const struct ata_port_info ahci_port_info = {
 	.port_ops	= &ahci_platform_ops,
 };
 
+static const struct ata_port_info ahci_port_info_nolpm = {
+	.flags		= AHCI_FLAG_COMMON | ATA_FLAG_NO_LPM,
+	.pio_mask	= ATA_PIO4,
+	.udma_mask	= ATA_UDMA6,
+	.port_ops	= &ahci_platform_ops,
+};
+
 static struct scsi_host_template ahci_platform_sht = {
 	AHCI_SHT(DRV_NAME),
 };
@@ -41,6 +48,7 @@ static int ahci_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct ahci_host_priv *hpriv;
+	const struct ata_port_info *port;
 	int rc;
 
 	hpriv = ahci_platform_get_resources(pdev,
@@ -58,7 +66,11 @@ static int ahci_probe(struct platform_device *pdev)
 	if (of_device_is_compatible(dev->of_node, "hisilicon,hisi-ahci"))
 		hpriv->flags |= AHCI_HFLAG_NO_FBS | AHCI_HFLAG_NO_NCQ;
 
-	rc = ahci_platform_init_host(pdev, hpriv, &ahci_port_info,
+	port = acpi_device_get_match_data(dev);
+	if (!port)
+		port = &ahci_port_info;
+
+	rc = ahci_platform_init_host(pdev, hpriv, port,
 				     &ahci_platform_sht);
 	if (rc)
 		goto disable_resources;
@@ -85,6 +97,7 @@ static const struct of_device_id ahci_of_match[] = {
 MODULE_DEVICE_TABLE(of, ahci_of_match);
 
 static const struct acpi_device_id ahci_acpi_match[] = {
+	{ "APMC0D33", (unsigned long)&ahci_port_info_nolpm },
 	{ ACPI_DEVICE_CLASS(PCI_CLASS_STORAGE_SATA_AHCI, 0xffffff) },
 	{},
 };

commit 0519359784328bfa92bf0931bf0cff3b58c16932
Merge: 596766102a3a 2d17f460c5d7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 24 13:20:33 2018 -0700

    Merge branch 'for-4.19' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata
    
    Pull libata updates from Tejun Heo:
     "Nothing too interesting. Mostly ahci and ahci_platform changes, many
      around power management"
    
    * 'for-4.19' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata: (22 commits)
      ata: ahci_platform: enable to get and control reset
      ata: libahci_platform: add reset control support
      ata: add an extra argument to ahci_platform_get_resources()
      ata: sata_rcar: Add r8a77965 support
      ata: sata_rcar: exclude setting of PHY registers in Gen3
      ata: sata_rcar: really mask all interrupts on Gen2 and later
      Revert "ata: ahci_platform: allow disabling of hotplug to save power"
      ata: libahci: Allow reconfigure of DEVSLP register
      ata: libahci: Correct setting of DEVSLP register
      ata: ahci: Enable DEVSLP by default on x86 with SLP_S0
      ata: ahci: Support state with min power but Partial low power state
      Revert "ata: ahci_platform: convert kcalloc to devm_kcalloc"
      ata: sata_rcar: Add rudimentary Runtime PM support
      ata: sata_rcar: Provide a short-hand for &pdev->dev
      ata: Only output sg element mapped number in verbose debug
      ata: Guard ata_scsi_dump_cdb() by ATA_VERBOSE_DEBUG
      ata: ahci_platform: convert kcalloc to devm_kcalloc
      ata: ahci_platform: convert kzallloc to kcalloc
      ata: ahci_platform: correct parameter documentation for ahci_platform_shutdown
      libata: remove ata_sff_data_xfer_noirq()
      ...

commit 2d17f460c5d79fa9fc794e813377f3276acf81ce
Author: Kunihiko Hayashi <hayashi.kunihiko@socionext.com>
Date:   Wed Aug 22 21:13:03 2018 +0900

    ata: ahci_platform: enable to get and control reset
    
    Unlike SoC-specific driver, generic ahci_platform driver doesn't
    have any chances to control resets.
    
    This adds AHCI_PLATFORM_GET_RESETS to ahci_platform_get_resources()
    on the generic driver to enable reset control support.
    
    Suggested-by: Hans de Goede <hdegoede@redhat.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Signed-off-by: Kunihiko Hayashi <hayashi.kunihiko@socionext.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 570927316962..ddd930852b2e 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -43,7 +43,8 @@ static int ahci_probe(struct platform_device *pdev)
 	struct ahci_host_priv *hpriv;
 	int rc;
 
-	hpriv = ahci_platform_get_resources(pdev, 0);
+	hpriv = ahci_platform_get_resources(pdev,
+					    AHCI_PLATFORM_GET_RESETS);
 	if (IS_ERR(hpriv))
 		return PTR_ERR(hpriv);
 

commit 16af2d65842d343c2f95733c3993a0b5baab08f9
Author: Kunihiko Hayashi <hayashi.kunihiko@socionext.com>
Date:   Wed Aug 22 21:13:01 2018 +0900

    ata: add an extra argument to ahci_platform_get_resources()
    
    Add an extra argument to ahci_platform_get_resources(), that is
    for the bitmap representing the resource to get in this function.
    
    Currently there is no resources to be defined, so all the callers set
    '0' to the argument.
    
    Suggested-by: Hans de Goede <hdegoede@redhat.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Kunihiko Hayashi <hayashi.kunihiko@socionext.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 99f9a895a459..570927316962 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -43,7 +43,7 @@ static int ahci_probe(struct platform_device *pdev)
 	struct ahci_host_priv *hpriv;
 	int rc;
 
-	hpriv = ahci_platform_get_resources(pdev);
+	hpriv = ahci_platform_get_resources(pdev, 0);
 	if (IS_ERR(hpriv))
 		return PTR_ERR(hpriv);
 

commit eac7e072d7e99fad1b6e817c608b03c48205241e
Author: Tejun Heo <tj@kernel.org>
Date:   Mon Aug 6 10:22:35 2018 -0700

    Revert "ata: ahci_platform: allow disabling of hotplug to save power"
    
    This reverts commit aece27a2f01be4bb7683790f69cd1bed3a0929a2.
    
    Causes boot failure on some devices.
    
     http://lore.kernel.org/r/CA+G9fYuKW_jCFZPqG4tz=QY9ROfHO38KiCp9XTA+KaDOFVtcqQ@mail.gmail.com
    
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 757729376eda..99f9a895a459 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -68,13 +68,8 @@ static int ahci_probe(struct platform_device *pdev)
 	return rc;
 }
 
-#ifdef CONFIG_PM_SLEEP
-static const struct dev_pm_ops ahci_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(ahci_platform_suspend, ahci_platform_resume)
-	SET_RUNTIME_PM_OPS(ahci_platform_runtime_suspend,
-			ahci_platform_runtime_resume, NULL)
-};
-#endif
+static SIMPLE_DEV_PM_OPS(ahci_pm_ops, ahci_platform_suspend,
+			 ahci_platform_resume);
 
 static const struct of_device_id ahci_of_match[] = {
 	{ .compatible = "generic-ahci", },
@@ -103,9 +98,7 @@ static struct platform_driver ahci_driver = {
 		.name = DRV_NAME,
 		.of_match_table = ahci_of_match,
 		.acpi_match_table = ahci_acpi_match,
-#ifdef CONFIG_PM_SLEEP
 		.pm = &ahci_pm_ops,
-#endif
 	},
 };
 module_platform_driver(ahci_driver);

commit 956698445d1beb9f7fdcd842bb829a0c2f05d86d
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Tue Apr 24 22:05:17 2018 +0200

    ata: ahci-platform: Remove support for Exynos5440
    
    The Exynos5440 is not actively developed, there are no development
    boards available and probably there are no real products with it.
    Remove wide-tree support for Exynos5440.
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Reviewed-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 99f9a895a459..564570ea3e27 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -75,7 +75,6 @@ static const struct of_device_id ahci_of_match[] = {
 	{ .compatible = "generic-ahci", },
 	/* Keep the following compatibles for device tree compatibility */
 	{ .compatible = "snps,spear-ahci", },
-	{ .compatible = "snps,exynos5440-ahci", },
 	{ .compatible = "ibm,476gtr-ahci", },
 	{ .compatible = "snps,dwc-ahci", },
 	{ .compatible = "hisilicon,hisi-ahci", },

commit aece27a2f01be4bb7683790f69cd1bed3a0929a2
Author: Samuel Morris <samorris@lexmark.com>
Date:   Tue May 29 10:06:12 2018 +0000

    ata: ahci_platform: allow disabling of hotplug to save power
    
    A number of resources remain powered to support hotplug. On platforms
    I've worked with, allowing the ahci_platform to suspend saves about
    150mW. This patch enables rpm and allows the device to be auto-suspended
    through sysfs.
    
    Signed-off-by: Samuel Morris <samorris@lexmark.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 99f9a895a459..757729376eda 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -68,8 +68,13 @@ static int ahci_probe(struct platform_device *pdev)
 	return rc;
 }
 
-static SIMPLE_DEV_PM_OPS(ahci_pm_ops, ahci_platform_suspend,
-			 ahci_platform_resume);
+#ifdef CONFIG_PM_SLEEP
+static const struct dev_pm_ops ahci_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(ahci_platform_suspend, ahci_platform_resume)
+	SET_RUNTIME_PM_OPS(ahci_platform_runtime_suspend,
+			ahci_platform_runtime_resume, NULL)
+};
+#endif
 
 static const struct of_device_id ahci_of_match[] = {
 	{ .compatible = "generic-ahci", },
@@ -98,7 +103,9 @@ static struct platform_driver ahci_driver = {
 		.name = DRV_NAME,
 		.of_match_table = ahci_of_match,
 		.acpi_match_table = ahci_acpi_match,
+#ifdef CONFIG_PM_SLEEP
 		.pm = &ahci_pm_ops,
+#endif
 	},
 };
 module_platform_driver(ahci_driver);

commit 8eede5bc4ef04281fbba7ddfe157052d0e76075d
Author: Nate Watterson <nwatters@codeaurora.org>
Date:   Thu Jul 20 15:26:24 2017 -0400

    ata: ahci_platform: Add shutdown handler
    
    The newly introduced ahci_platform_shutdown() method is called during
    system shutdown to disable host controller DMA and interrupts in order
    to avoid potentially corrupting or otherwise interfering with a new
    kernel being started with kexec.
    
    Signed-off-by: Nate Watterson <nwatters@codeaurora.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 62a04c8fb5c9..99f9a895a459 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -93,6 +93,7 @@ MODULE_DEVICE_TABLE(acpi, ahci_acpi_match);
 static struct platform_driver ahci_driver = {
 	.probe = ahci_probe,
 	.remove = ata_platform_remove_one,
+	.shutdown = ahci_platform_shutdown,
 	.driver = {
 		.name = DRV_NAME,
 		.of_match_table = ahci_of_match,

commit 17dcc37e3e847bc0e67a5b1ec52471fcc6c18682
Author: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
Date:   Fri Apr 1 08:52:57 2016 +0100

    ata: ahci-platform: Add ports-implemented DT bindings.
    
    On some SOCs PORTS_IMPL register value is never programmed by the
    firmware and left at zero value. Which means that no sata ports are
    available for software. AHCI driver used to cope up with this by
    fabricating the port_map if the PORTS_IMPL register is read zero,
    but recent patch broke this workaround as zero value was valid for
    NVMe disks.
    
    This patch adds ports-implemented DT bindings as workaround for this issue
    in a way that DT can can override the PORTS_IMPL register in cases where
    the firmware did not program it already.
    
    Fixes: 566d1827df2e ("libata: disable forced PORTS_IMPL for >= AHCI 1.3")
    Cc: stable@vger.kernel.org # v4.5+
    Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Acked-by: Tejun Heo <tj@kernel.org>
    Reviewed-by: Andy Gross <andy.gross@linaro.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 40442332bfa7..62a04c8fb5c9 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -51,6 +51,9 @@ static int ahci_probe(struct platform_device *pdev)
 	if (rc)
 		return rc;
 
+	of_property_read_u32(dev->of_node,
+			     "ports-implemented", &hpriv->force_port_map);
+
 	if (of_device_is_compatible(dev->of_node, "hisilicon,hisi-ahci"))
 		hpriv->flags |= AHCI_HFLAG_NO_FBS | AHCI_HFLAG_NO_NCQ;
 

commit a2127e400edd2258fda6d83fe8b10b878a3595d9
Author: Aleksey Makarov <aleksey.makarov@caviumnetworks.com>
Date:   Thu Feb 11 13:53:08 2016 +0000

    libata: support AHCI on OCTEON platform
    
    The OCTEON SATA controller is currently found on cn71XX devices.
    
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Hans de Goede <hdegoede@redhat.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: David Daney <david.daney@cavium.com>
    Signed-off-by: Vinita Gupta <vgupta@caviumnetworks.com>
    Signed-off-by: Aleksey Makarov <aleksey.makarov@auriga.com>
    Signed-off-by: Zubair Lutfullah Kakakhel <Zubair.Kakakhel@imgtec.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 04975b851c23..40442332bfa7 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -76,6 +76,7 @@ static const struct of_device_id ahci_of_match[] = {
 	{ .compatible = "ibm,476gtr-ahci", },
 	{ .compatible = "snps,dwc-ahci", },
 	{ .compatible = "hisilicon,hisi-ahci", },
+	{ .compatible = "cavium,octeon-7130-ahci", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, ahci_of_match);

commit fc4f370d77f867fe327fb3591030930693e5438e
Author: Tang Yuantian <Yuantian.Tang@freescale.com>
Date:   Mon Sep 7 16:23:14 2015 +0800

    Revert "ahci: added support for Freescale AHCI sata"
    
    This reverts commit 5163fb62541e
    ("ahci: added support for Freescale AHCI sata")
    
    The reverted patch added Freescale QorIQ AHCI sata support to
    ahci_platform driver though, but it left SoC specific settings to uboot.
    It leads to QorIQ sata heavily depending on uboot. In order to removing
    the dependency we first revert the old patch and then will add a new driver
    for QorIQ SATA.
    Since there are no LS* platforms that have been upstreamed, So
    the revert would not break anything exists.
    
    Signed-off-by: Tang Yuantian <Yuantian.Tang@freescale.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 1befb114c384..04975b851c23 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -76,7 +76,6 @@ static const struct of_device_id ahci_of_match[] = {
 	{ .compatible = "ibm,476gtr-ahci", },
 	{ .compatible = "snps,dwc-ahci", },
 	{ .compatible = "hisilicon,hisi-ahci", },
-	{ .compatible = "fsl,qoriq-ahci", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, ahci_of_match);

commit 2051e9248688e4c36e4de2e93b88fa0d74e86261
Author: Suthikulpanit, Suravee <Suravee.Suthikulpanit@amd.com>
Date:   Tue Jul 7 01:55:21 2015 +0200

    ata: ahci_platform: Add ACPI _CLS matching
    
    This patch adds ACPI supports for AHCI platform driver, which uses _CLS
    method to match the device.
    
    The following is an example of ASL structure in DSDT for a SATA controller,
    which contains _CLS package to be matched by the ahci_platform driver:
    
      Device (AHC0) // AHCI Controller
      {
        Name(_HID, "AMDI0600")
        Name (_CCA, 1)
        Name (_CLS, Package (3)
        {
          0x01, // Base Class: Mass Storage
          0x06, // Sub-Class: serial ATA
          0x01, // Interface: AHCI
        })
        Name (_CRS, ResourceTemplate ()
        {
          Memory32Fixed (ReadWrite, 0xE0300000, 0x00010000)
          Interrupt (ResourceConsumer, Level, ActiveHigh, Exclusive,,,) { 387 }
        })
      }
    
    Also, since ATA driver should not require PCI support for ATA_ACPI,
    this patch removes dependency in the driver/ata/Kconfig.
    
    Acked-by: Tejun Heo <tj@kernel.org>
    Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
    Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 614c78f510f0..1befb114c384 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -20,6 +20,8 @@
 #include <linux/platform_device.h>
 #include <linux/libata.h>
 #include <linux/ahci_platform.h>
+#include <linux/acpi.h>
+#include <linux/pci_ids.h>
 #include "ahci.h"
 
 #define DRV_NAME "ahci"
@@ -79,12 +81,19 @@ static const struct of_device_id ahci_of_match[] = {
 };
 MODULE_DEVICE_TABLE(of, ahci_of_match);
 
+static const struct acpi_device_id ahci_acpi_match[] = {
+	{ ACPI_DEVICE_CLASS(PCI_CLASS_STORAGE_SATA_AHCI, 0xffffff) },
+	{},
+};
+MODULE_DEVICE_TABLE(acpi, ahci_acpi_match);
+
 static struct platform_driver ahci_driver = {
 	.probe = ahci_probe,
 	.remove = ata_platform_remove_one,
 	.driver = {
 		.name = DRV_NAME,
 		.of_match_table = ahci_of_match,
+		.acpi_match_table = ahci_acpi_match,
 		.pm = &ahci_pm_ops,
 	},
 };

commit 5163fb62541e38fea400f96dcef9aa539fd00b48
Author: Tang Yuantian <Yuantian.Tang@freescale.com>
Date:   Thu Jun 4 15:10:04 2015 +0800

    ahci: added support for Freescale AHCI sata
    
    Freescale introduced QorIQ series SOCs, like ls1021 ls2085, with AHCI
    sata support. It complies with the serial ATA 3.0 specification
    and the AHCI 1.3 specification.
    
    Signed-off-by: Shaohui Xie <Shaohui.Xie@freescale.com>
    Signed-off-by: Yuantian Tang <Yuantian.Tang@freescale.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 78d6ae0b90c4..614c78f510f0 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -74,6 +74,7 @@ static const struct of_device_id ahci_of_match[] = {
 	{ .compatible = "ibm,476gtr-ahci", },
 	{ .compatible = "snps,dwc-ahci", },
 	{ .compatible = "hisilicon,hisi-ahci", },
+	{ .compatible = "fsl,qoriq-ahci", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, ahci_of_match);

commit 018d5ef2048fcab339467bcbebccf588c9bd2531
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Thu Jan 29 08:30:29 2015 +0900

    ata: ahci_platform: fix owner module reference mismatch for scsi host
    
    The owner module reference of the ahci platform's scsi_host is
    initialized to libahci_platform's one, because these drivers use a
    scsi_host_template defined in libahci_platform.  So these drivers can
    be unloaded even if the scsi device is being accessed.
    
    This fixes it by pushing the scsi_host_template from libahci_platform
    to all leaf drivers.  The scsi_host_template is passed through a new
    argument of ahci_platform_init_host().
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Cc: linux-ide@vger.kernel.org
    Cc: linux-scsi@vger.kernel.org

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 18d539837045..78d6ae0b90c4 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -22,6 +22,8 @@
 #include <linux/ahci_platform.h>
 #include "ahci.h"
 
+#define DRV_NAME "ahci"
+
 static const struct ata_port_info ahci_port_info = {
 	.flags		= AHCI_FLAG_COMMON,
 	.pio_mask	= ATA_PIO4,
@@ -29,6 +31,10 @@ static const struct ata_port_info ahci_port_info = {
 	.port_ops	= &ahci_platform_ops,
 };
 
+static struct scsi_host_template ahci_platform_sht = {
+	AHCI_SHT(DRV_NAME),
+};
+
 static int ahci_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -46,7 +52,8 @@ static int ahci_probe(struct platform_device *pdev)
 	if (of_device_is_compatible(dev->of_node, "hisilicon,hisi-ahci"))
 		hpriv->flags |= AHCI_HFLAG_NO_FBS | AHCI_HFLAG_NO_NCQ;
 
-	rc = ahci_platform_init_host(pdev, hpriv, &ahci_port_info);
+	rc = ahci_platform_init_host(pdev, hpriv, &ahci_port_info,
+				     &ahci_platform_sht);
 	if (rc)
 		goto disable_resources;
 
@@ -75,7 +82,7 @@ static struct platform_driver ahci_driver = {
 	.probe = ahci_probe,
 	.remove = ata_platform_remove_one,
 	.driver = {
-		.name = "ahci",
+		.name = DRV_NAME,
 		.of_match_table = ahci_of_match,
 		.pm = &ahci_pm_ops,
 	},

commit 65c662ab63d2055d883bc97386aa779cbbb81f93
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:17 2014 +0200

    ata: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 06f1d59fa678..18d539837045 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -76,7 +76,6 @@ static struct platform_driver ahci_driver = {
 	.remove = ata_platform_remove_one,
 	.driver = {
 		.name = "ahci",
-		.owner = THIS_MODULE,
 		.of_match_table = ahci_of_match,
 		.pm = &ahci_pm_ops,
 	},

commit 515d9b2c03943ca904cd135e1b1d9ddd168c1b27
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Tue Aug 12 18:22:27 2014 +0200

    ata: remove deprecated struct ahci_platform_data
    
    The last user of the deprecated struct ahci_platform_data has been
    cleaned up recently (SPEAr1340 got a proper PHY driver).
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Acked-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index f61ddb9146d6..06f1d59fa678 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -32,7 +32,6 @@ static const struct ata_port_info ahci_port_info = {
 static int ahci_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
-	struct ahci_platform_data *pdata = dev_get_platdata(dev);
 	struct ahci_host_priv *hpriv;
 	int rc;
 
@@ -44,29 +43,14 @@ static int ahci_probe(struct platform_device *pdev)
 	if (rc)
 		return rc;
 
-	/*
-	 * Some platforms might need to prepare for mmio region access,
-	 * which could be done in the following init call. So, the mmio
-	 * region shouldn't be accessed before init (if provided) has
-	 * returned successfully.
-	 */
-	if (pdata && pdata->init) {
-		rc = pdata->init(dev, hpriv->mmio);
-		if (rc)
-			goto disable_resources;
-	}
-
 	if (of_device_is_compatible(dev->of_node, "hisilicon,hisi-ahci"))
 		hpriv->flags |= AHCI_HFLAG_NO_FBS | AHCI_HFLAG_NO_NCQ;
 
 	rc = ahci_platform_init_host(pdev, hpriv, &ahci_port_info);
 	if (rc)
-		goto pdata_exit;
+		goto disable_resources;
 
 	return 0;
-pdata_exit:
-	if (pdata && pdata->exit)
-		pdata->exit(dev);
 disable_resources:
 	ahci_platform_disable_resources(hpriv);
 	return rc;

commit 30f3c73c9b526a88920d098dcb331319e284e1b3
Author: Antoine Ténart <antoine.tenart@free-electrons.com>
Date:   Wed Jul 30 20:13:58 2014 +0200

    ata: ahci_platform: add a generic AHCI compatible
    
    The ahci_platform driver is a generic driver using the libahci_platform
    functions. Add a generic compatible to avoid having an endless list of
    compatibles with no differences for the same driver.
    
    Signed-off-by: Antoine Ténart <antoine.tenart@free-electrons.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index fb3eca5cd66c..f61ddb9146d6 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -76,6 +76,8 @@ static SIMPLE_DEV_PM_OPS(ahci_pm_ops, ahci_platform_suspend,
 			 ahci_platform_resume);
 
 static const struct of_device_id ahci_of_match[] = {
+	{ .compatible = "generic-ahci", },
+	/* Keep the following compatibles for device tree compatibility */
 	{ .compatible = "snps,spear-ahci", },
 	{ .compatible = "snps,exynos5440-ahci", },
 	{ .compatible = "ibm,476gtr-ahci", },

commit 725c7b570fda4207e465ff8856c2c12c2645a685
Author: Antoine Ténart <antoine.tenart@free-electrons.com>
Date:   Wed Jul 30 20:13:56 2014 +0200

    ata: libahci_platform: move port_map parameters into the AHCI structure
    
    This patch moves force_port_map and mask_port_map into the
    ahci_host_priv structure. This allows to modify them into the AHCI
    framework. This is needed by the new dt bindings representing ports as
    the port_map mask is computed automatically.
    
    Parameters modifying force_port_map, mask_port_map and flags have been
    removed from the ahci_platform_init_host() function, and inputs in the
    ahci_host_priv structure are now directly filed.
    
    Signed-off-by: Antoine Ténart <antoine.tenart@free-electrons.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index b10d81ddb528..fb3eca5cd66c 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -34,7 +34,6 @@ static int ahci_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct ahci_platform_data *pdata = dev_get_platdata(dev);
 	struct ahci_host_priv *hpriv;
-	unsigned long hflags = 0;
 	int rc;
 
 	hpriv = ahci_platform_get_resources(pdev);
@@ -58,10 +57,9 @@ static int ahci_probe(struct platform_device *pdev)
 	}
 
 	if (of_device_is_compatible(dev->of_node, "hisilicon,hisi-ahci"))
-		hflags |= AHCI_HFLAG_NO_FBS | AHCI_HFLAG_NO_NCQ;
+		hpriv->flags |= AHCI_HFLAG_NO_FBS | AHCI_HFLAG_NO_NCQ;
 
-	rc = ahci_platform_init_host(pdev, hpriv, &ahci_port_info,
-				     hflags, 0, 0);
+	rc = ahci_platform_init_host(pdev, hpriv, &ahci_port_info);
 	if (rc)
 		goto pdata_exit;
 

commit 72cbaa3d2f563d7b48c9f8aef47ec9aa3a31adf2
Author: Kefeng Wang <kefeng.wang@linaro.org>
Date:   Tue Jun 24 16:54:23 2014 -0400

    ahci: disable ncq feature for hisilicon sata
    
    NCQ feature is unsupported on hisilicon sata controller, so disable
    it.  This version of IP is used by hip04 and hix5hd2 soc.
    
    tj: "|=" was replaced with "=" for no reason.  Restored "|=".
    
    Signed-off-by: Kefeng Wang <kefeng.wang@linaro.org>
    Sigend-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index ebe505c17763..b10d81ddb528 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -58,7 +58,7 @@ static int ahci_probe(struct platform_device *pdev)
 	}
 
 	if (of_device_is_compatible(dev->of_node, "hisilicon,hisi-ahci"))
-		hflags |= AHCI_HFLAG_NO_FBS;
+		hflags |= AHCI_HFLAG_NO_FBS | AHCI_HFLAG_NO_NCQ;
 
 	rc = ahci_platform_init_host(pdev, hpriv, &ahci_port_info,
 				     hflags, 0, 0);

commit a1a205df6ee224f62c6d21cedebcb723db17fe0d
Author: Kefeng Wang <kefeng.wang@linaro.org>
Date:   Wed May 14 14:13:42 2014 +0800

    ahci: add support for Hisilicon sata
    
    The hip04 SoC of hisilicon has an AHCI compliant SATA controller,
    and it is compliant with the ahci 1.3 and sata 3.0 specification.
    
    There is a wrong bit in HOST_CAP of hip04 sata controller, which
    enable unsupported feature of FBS, use AHCI_HFLAG_NO_FBS hflag to
    disable it.
    
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Kefeng Wang <kefeng.wang@linaro.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index a476a1fd3f8f..ebe505c17763 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -16,6 +16,7 @@
 #include <linux/module.h>
 #include <linux/pm.h>
 #include <linux/device.h>
+#include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/libata.h>
 #include <linux/ahci_platform.h>
@@ -33,6 +34,7 @@ static int ahci_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct ahci_platform_data *pdata = dev_get_platdata(dev);
 	struct ahci_host_priv *hpriv;
+	unsigned long hflags = 0;
 	int rc;
 
 	hpriv = ahci_platform_get_resources(pdev);
@@ -55,7 +57,11 @@ static int ahci_probe(struct platform_device *pdev)
 			goto disable_resources;
 	}
 
-	rc = ahci_platform_init_host(pdev, hpriv, &ahci_port_info, 0, 0, 0);
+	if (of_device_is_compatible(dev->of_node, "hisilicon,hisi-ahci"))
+		hflags |= AHCI_HFLAG_NO_FBS;
+
+	rc = ahci_platform_init_host(pdev, hpriv, &ahci_port_info,
+				     hflags, 0, 0);
 	if (rc)
 		goto pdata_exit;
 
@@ -76,6 +82,7 @@ static const struct of_device_id ahci_of_match[] = {
 	{ .compatible = "snps,exynos5440-ahci", },
 	{ .compatible = "ibm,476gtr-ahci", },
 	{ .compatible = "snps,dwc-ahci", },
+	{ .compatible = "hisilicon,hisi-ahci", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, ahci_of_match);

commit f9f36917903b57c571b1ddcfc6bc794ca4dd8232
Author: Kefeng Wang <kefeng.wang@linaro.org>
Date:   Wed May 14 14:13:41 2014 +0800

    libahci_platform: add host_flags parameter in ahci_platform_init_host()
    
    Add a dynamic host_flags argument to make ahci_platform_init_host more flexible,
    then remove the AHCI_HFLAGS(...) argument from some driver's ata_port_info,
    and pass that in as the new argument.
    
    Cc: Hans de Geode <hdegoede@redhat.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Kefeng Wang <kefeng.wang@linaro.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index ef67e79944f9..a476a1fd3f8f 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -55,7 +55,7 @@ static int ahci_probe(struct platform_device *pdev)
 			goto disable_resources;
 	}
 
-	rc = ahci_platform_init_host(pdev, hpriv, &ahci_port_info, 0, 0);
+	rc = ahci_platform_init_host(pdev, hpriv, &ahci_port_info, 0, 0, 0);
 	if (rc)
 		goto pdata_exit;
 

commit fd990556f0fa25446c6bfa9cf4c9e49d387d4472
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Tue Mar 25 19:51:39 2014 +0100

    ata: move library code from ahci_platform.c to libahci_platform.c
    
    Move AHCI platform library code from ahci_platform.c to
    libahci_platform.c and fix dependencies for ahci_st,
    ahci_imx and ahci_sunxi drivers.
    
    Acked-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 7bd6adf54b3e..ef67e79944f9 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -12,28 +12,15 @@
  * any later version.
  */
 
-#include <linux/clk.h>
 #include <linux/kernel.h>
-#include <linux/gfp.h>
 #include <linux/module.h>
 #include <linux/pm.h>
-#include <linux/interrupt.h>
 #include <linux/device.h>
 #include <linux/platform_device.h>
 #include <linux/libata.h>
 #include <linux/ahci_platform.h>
-#include <linux/phy/phy.h>
-#include <linux/pm_runtime.h>
 #include "ahci.h"
 
-static void ahci_host_stop(struct ata_host *host);
-
-struct ata_port_operations ahci_platform_ops = {
-	.inherits	= &ahci_ops,
-	.host_stop	= ahci_host_stop,
-};
-EXPORT_SYMBOL_GPL(ahci_platform_ops);
-
 static const struct ata_port_info ahci_port_info = {
 	.flags		= AHCI_FLAG_COMMON,
 	.pio_mask	= ATA_PIO4,
@@ -41,345 +28,6 @@ static const struct ata_port_info ahci_port_info = {
 	.port_ops	= &ahci_platform_ops,
 };
 
-static struct scsi_host_template ahci_platform_sht = {
-	AHCI_SHT("ahci_platform"),
-};
-
-/**
- * ahci_platform_enable_clks - Enable platform clocks
- * @hpriv: host private area to store config values
- *
- * This function enables all the clks found in hpriv->clks, starting at
- * index 0. If any clk fails to enable it disables all the clks already
- * enabled in reverse order, and then returns an error.
- *
- * RETURNS:
- * 0 on success otherwise a negative error code
- */
-int ahci_platform_enable_clks(struct ahci_host_priv *hpriv)
-{
-	int c, rc;
-
-	for (c = 0; c < AHCI_MAX_CLKS && hpriv->clks[c]; c++) {
-		rc = clk_prepare_enable(hpriv->clks[c]);
-		if (rc)
-			goto disable_unprepare_clk;
-	}
-	return 0;
-
-disable_unprepare_clk:
-	while (--c >= 0)
-		clk_disable_unprepare(hpriv->clks[c]);
-	return rc;
-}
-EXPORT_SYMBOL_GPL(ahci_platform_enable_clks);
-
-/**
- * ahci_platform_disable_clks - Disable platform clocks
- * @hpriv: host private area to store config values
- *
- * This function disables all the clks found in hpriv->clks, in reverse
- * order of ahci_platform_enable_clks (starting at the end of the array).
- */
-void ahci_platform_disable_clks(struct ahci_host_priv *hpriv)
-{
-	int c;
-
-	for (c = AHCI_MAX_CLKS - 1; c >= 0; c--)
-		if (hpriv->clks[c])
-			clk_disable_unprepare(hpriv->clks[c]);
-}
-EXPORT_SYMBOL_GPL(ahci_platform_disable_clks);
-
-/**
- * ahci_platform_enable_resources - Enable platform resources
- * @hpriv: host private area to store config values
- *
- * This function enables all ahci_platform managed resources in the
- * following order:
- * 1) Regulator
- * 2) Clocks (through ahci_platform_enable_clks)
- * 3) Phy
- *
- * If resource enabling fails at any point the previous enabled resources
- * are disabled in reverse order.
- *
- * RETURNS:
- * 0 on success otherwise a negative error code
- */
-int ahci_platform_enable_resources(struct ahci_host_priv *hpriv)
-{
-	int rc;
-
-	if (hpriv->target_pwr) {
-		rc = regulator_enable(hpriv->target_pwr);
-		if (rc)
-			return rc;
-	}
-
-	rc = ahci_platform_enable_clks(hpriv);
-	if (rc)
-		goto disable_regulator;
-
-	if (hpriv->phy) {
-		rc = phy_init(hpriv->phy);
-		if (rc)
-			goto disable_clks;
-
-		rc = phy_power_on(hpriv->phy);
-		if (rc) {
-			phy_exit(hpriv->phy);
-			goto disable_clks;
-		}
-	}
-
-	return 0;
-
-disable_clks:
-	ahci_platform_disable_clks(hpriv);
-
-disable_regulator:
-	if (hpriv->target_pwr)
-		regulator_disable(hpriv->target_pwr);
-	return rc;
-}
-EXPORT_SYMBOL_GPL(ahci_platform_enable_resources);
-
-/**
- * ahci_platform_disable_resources - Disable platform resources
- * @hpriv: host private area to store config values
- *
- * This function disables all ahci_platform managed resources in the
- * following order:
- * 1) Phy
- * 2) Clocks (through ahci_platform_disable_clks)
- * 3) Regulator
- */
-void ahci_platform_disable_resources(struct ahci_host_priv *hpriv)
-{
-	if (hpriv->phy) {
-		phy_power_off(hpriv->phy);
-		phy_exit(hpriv->phy);
-	}
-
-	ahci_platform_disable_clks(hpriv);
-
-	if (hpriv->target_pwr)
-		regulator_disable(hpriv->target_pwr);
-}
-EXPORT_SYMBOL_GPL(ahci_platform_disable_resources);
-
-static void ahci_platform_put_resources(struct device *dev, void *res)
-{
-	struct ahci_host_priv *hpriv = res;
-	int c;
-
-	if (hpriv->got_runtime_pm) {
-		pm_runtime_put_sync(dev);
-		pm_runtime_disable(dev);
-	}
-
-	for (c = 0; c < AHCI_MAX_CLKS && hpriv->clks[c]; c++)
-		clk_put(hpriv->clks[c]);
-}
-
-/**
- * ahci_platform_get_resources - Get platform resources
- * @pdev: platform device to get resources for
- *
- * This function allocates an ahci_host_priv struct, and gets the following
- * resources, storing a reference to them inside the returned struct:
- *
- * 1) mmio registers (IORESOURCE_MEM 0, mandatory)
- * 2) regulator for controlling the targets power (optional)
- * 3) 0 - AHCI_MAX_CLKS clocks, as specified in the devs devicetree node,
- *    or for non devicetree enabled platforms a single clock
- *	4) phy (optional)
- *
- * RETURNS:
- * The allocated ahci_host_priv on success, otherwise an ERR_PTR value
- */
-struct ahci_host_priv *ahci_platform_get_resources(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct ahci_host_priv *hpriv;
-	struct clk *clk;
-	int i, rc = -ENOMEM;
-
-	if (!devres_open_group(dev, NULL, GFP_KERNEL))
-		return ERR_PTR(-ENOMEM);
-
-	hpriv = devres_alloc(ahci_platform_put_resources, sizeof(*hpriv),
-			     GFP_KERNEL);
-	if (!hpriv)
-		goto err_out;
-
-	devres_add(dev, hpriv);
-
-	hpriv->mmio = devm_ioremap_resource(dev,
-			      platform_get_resource(pdev, IORESOURCE_MEM, 0));
-	if (IS_ERR(hpriv->mmio)) {
-		dev_err(dev, "no mmio space\n");
-		rc = PTR_ERR(hpriv->mmio);
-		goto err_out;
-	}
-
-	hpriv->target_pwr = devm_regulator_get_optional(dev, "target");
-	if (IS_ERR(hpriv->target_pwr)) {
-		rc = PTR_ERR(hpriv->target_pwr);
-		if (rc == -EPROBE_DEFER)
-			goto err_out;
-		hpriv->target_pwr = NULL;
-	}
-
-	for (i = 0; i < AHCI_MAX_CLKS; i++) {
-		/*
-		 * For now we must use clk_get(dev, NULL) for the first clock,
-		 * because some platforms (da850, spear13xx) are not yet
-		 * converted to use devicetree for clocks.  For new platforms
-		 * this is equivalent to of_clk_get(dev->of_node, 0).
-		 */
-		if (i == 0)
-			clk = clk_get(dev, NULL);
-		else
-			clk = of_clk_get(dev->of_node, i);
-
-		if (IS_ERR(clk)) {
-			rc = PTR_ERR(clk);
-			if (rc == -EPROBE_DEFER)
-				goto err_out;
-			break;
-		}
-		hpriv->clks[i] = clk;
-	}
-
-	hpriv->phy = devm_phy_get(dev, "sata-phy");
-	if (IS_ERR(hpriv->phy)) {
-		rc = PTR_ERR(hpriv->phy);
-		switch (rc) {
-		case -ENODEV:
-		case -ENOSYS:
-			/* continue normally */
-			hpriv->phy = NULL;
-			break;
-
-		case -EPROBE_DEFER:
-			goto err_out;
-
-		default:
-			dev_err(dev, "couldn't get sata-phy\n");
-			goto err_out;
-		}
-	}
-
-	pm_runtime_enable(dev);
-	pm_runtime_get_sync(dev);
-	hpriv->got_runtime_pm = true;
-
-	devres_remove_group(dev, NULL);
-	return hpriv;
-
-err_out:
-	devres_release_group(dev, NULL);
-	return ERR_PTR(rc);
-}
-EXPORT_SYMBOL_GPL(ahci_platform_get_resources);
-
-/**
- * ahci_platform_init_host - Bring up an ahci-platform host
- * @pdev: platform device pointer for the host
- * @hpriv: ahci-host private data for the host
- * @pi_template: template for the ata_port_info to use
- * @force_port_map: param passed to ahci_save_initial_config
- * @mask_port_map: param passed to ahci_save_initial_config
- *
- * This function does all the usual steps needed to bring up an
- * ahci-platform host, note any necessary resources (ie clks, phy, etc.)
- * must be initialized / enabled before calling this.
- *
- * RETURNS:
- * 0 on success otherwise a negative error code
- */
-int ahci_platform_init_host(struct platform_device *pdev,
-			    struct ahci_host_priv *hpriv,
-			    const struct ata_port_info *pi_template,
-			    unsigned int force_port_map,
-			    unsigned int mask_port_map)
-{
-	struct device *dev = &pdev->dev;
-	struct ata_port_info pi = *pi_template;
-	const struct ata_port_info *ppi[] = { &pi, NULL };
-	struct ata_host *host;
-	int i, irq, n_ports, rc;
-
-	irq = platform_get_irq(pdev, 0);
-	if (irq <= 0) {
-		dev_err(dev, "no irq\n");
-		return -EINVAL;
-	}
-
-	/* prepare host */
-	hpriv->flags |= (unsigned long)pi.private_data;
-
-	ahci_save_initial_config(dev, hpriv, force_port_map, mask_port_map);
-
-	if (hpriv->cap & HOST_CAP_NCQ)
-		pi.flags |= ATA_FLAG_NCQ;
-
-	if (hpriv->cap & HOST_CAP_PMP)
-		pi.flags |= ATA_FLAG_PMP;
-
-	ahci_set_em_messages(hpriv, &pi);
-
-	/* CAP.NP sometimes indicate the index of the last enabled
-	 * port, at other times, that of the last possible port, so
-	 * determining the maximum port number requires looking at
-	 * both CAP.NP and port_map.
-	 */
-	n_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));
-
-	host = ata_host_alloc_pinfo(dev, ppi, n_ports);
-	if (!host)
-		return -ENOMEM;
-
-	host->private_data = hpriv;
-
-	if (!(hpriv->cap & HOST_CAP_SSS) || ahci_ignore_sss)
-		host->flags |= ATA_HOST_PARALLEL_SCAN;
-	else
-		dev_info(dev, "SSS flag set, parallel bus scan disabled\n");
-
-	if (pi.flags & ATA_FLAG_EM)
-		ahci_reset_em(host);
-
-	for (i = 0; i < host->n_ports; i++) {
-		struct ata_port *ap = host->ports[i];
-
-		ata_port_desc(ap, "mmio %pR",
-			      platform_get_resource(pdev, IORESOURCE_MEM, 0));
-		ata_port_desc(ap, "port 0x%x", 0x100 + ap->port_no * 0x80);
-
-		/* set enclosure management message type */
-		if (ap->flags & ATA_FLAG_EM)
-			ap->em_message_type = hpriv->em_msg_type;
-
-		/* disabled/not-implemented port */
-		if (!(hpriv->port_map & (1 << i)))
-			ap->ops = &ata_dummy_port_ops;
-	}
-
-	rc = ahci_reset_controller(host);
-	if (rc)
-		return rc;
-
-	ahci_init_controller(host);
-	ahci_print_info(host, "platform");
-
-	return ata_host_activate(host, irq, ahci_interrupt, IRQF_SHARED,
-				 &ahci_platform_sht);
-}
-EXPORT_SYMBOL_GPL(ahci_platform_init_host);
-
 static int ahci_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -420,169 +68,6 @@ static int ahci_probe(struct platform_device *pdev)
 	return rc;
 }
 
-static void ahci_host_stop(struct ata_host *host)
-{
-	struct device *dev = host->dev;
-	struct ahci_platform_data *pdata = dev_get_platdata(dev);
-	struct ahci_host_priv *hpriv = host->private_data;
-
-	if (pdata && pdata->exit)
-		pdata->exit(dev);
-
-	ahci_platform_disable_resources(hpriv);
-}
-
-#ifdef CONFIG_PM_SLEEP
-/**
- * ahci_platform_suspend_host - Suspend an ahci-platform host
- * @dev: device pointer for the host
- *
- * This function does all the usual steps needed to suspend an
- * ahci-platform host, note any necessary resources (ie clks, phy, etc.)
- * must be disabled after calling this.
- *
- * RETURNS:
- * 0 on success otherwise a negative error code
- */
-int ahci_platform_suspend_host(struct device *dev)
-{
-	struct ata_host *host = dev_get_drvdata(dev);
-	struct ahci_host_priv *hpriv = host->private_data;
-	void __iomem *mmio = hpriv->mmio;
-	u32 ctl;
-
-	if (hpriv->flags & AHCI_HFLAG_NO_SUSPEND) {
-		dev_err(dev, "firmware update required for suspend/resume\n");
-		return -EIO;
-	}
-
-	/*
-	 * AHCI spec rev1.1 section 8.3.3:
-	 * Software must disable interrupts prior to requesting a
-	 * transition of the HBA to D3 state.
-	 */
-	ctl = readl(mmio + HOST_CTL);
-	ctl &= ~HOST_IRQ_EN;
-	writel(ctl, mmio + HOST_CTL);
-	readl(mmio + HOST_CTL); /* flush */
-
-	return ata_host_suspend(host, PMSG_SUSPEND);
-}
-EXPORT_SYMBOL_GPL(ahci_platform_suspend_host);
-
-/**
- * ahci_platform_resume_host - Resume an ahci-platform host
- * @dev: device pointer for the host
- *
- * This function does all the usual steps needed to resume an ahci-platform
- * host, note any necessary resources (ie clks, phy, etc.)  must be
- * initialized / enabled before calling this.
- *
- * RETURNS:
- * 0 on success otherwise a negative error code
- */
-int ahci_platform_resume_host(struct device *dev)
-{
-	struct ata_host *host = dev_get_drvdata(dev);
-	int rc;
-
-	if (dev->power.power_state.event == PM_EVENT_SUSPEND) {
-		rc = ahci_reset_controller(host);
-		if (rc)
-			return rc;
-
-		ahci_init_controller(host);
-	}
-
-	ata_host_resume(host);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(ahci_platform_resume_host);
-
-/**
- * ahci_platform_suspend - Suspend an ahci-platform device
- * @dev: the platform device to suspend
- *
- * This function suspends the host associated with the device, followed by
- * disabling all the resources of the device.
- *
- * RETURNS:
- * 0 on success otherwise a negative error code
- */
-int ahci_platform_suspend(struct device *dev)
-{
-	struct ahci_platform_data *pdata = dev_get_platdata(dev);
-	struct ata_host *host = dev_get_drvdata(dev);
-	struct ahci_host_priv *hpriv = host->private_data;
-	int rc;
-
-	rc = ahci_platform_suspend_host(dev);
-	if (rc)
-		return rc;
-
-	if (pdata && pdata->suspend) {
-		rc = pdata->suspend(dev);
-		if (rc)
-			goto resume_host;
-	}
-
-	ahci_platform_disable_resources(hpriv);
-
-	return 0;
-
-resume_host:
-	ahci_platform_resume_host(dev);
-	return rc;
-}
-EXPORT_SYMBOL_GPL(ahci_platform_suspend);
-
-/**
- * ahci_platform_resume - Resume an ahci-platform device
- * @dev: the platform device to resume
- *
- * This function enables all the resources of the device followed by
- * resuming the host associated with the device.
- *
- * RETURNS:
- * 0 on success otherwise a negative error code
- */
-int ahci_platform_resume(struct device *dev)
-{
-	struct ahci_platform_data *pdata = dev_get_platdata(dev);
-	struct ata_host *host = dev_get_drvdata(dev);
-	struct ahci_host_priv *hpriv = host->private_data;
-	int rc;
-
-	rc = ahci_platform_enable_resources(hpriv);
-	if (rc)
-		return rc;
-
-	if (pdata && pdata->resume) {
-		rc = pdata->resume(dev);
-		if (rc)
-			goto disable_resources;
-	}
-
-	rc = ahci_platform_resume_host(dev);
-	if (rc)
-		goto disable_resources;
-
-	/* We resumed so update PM runtime state */
-	pm_runtime_disable(dev);
-	pm_runtime_set_active(dev);
-	pm_runtime_enable(dev);
-
-	return 0;
-
-disable_resources:
-	ahci_platform_disable_resources(hpriv);
-
-	return rc;
-}
-EXPORT_SYMBOL_GPL(ahci_platform_resume);
-#endif
-
 static SIMPLE_DEV_PM_OPS(ahci_pm_ops, ahci_platform_suspend,
 			 ahci_platform_resume);
 

commit 83b03fd67b9b3fa3795871169f3c08c35b3d6ea8
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Tue Mar 25 19:51:38 2014 +0100

    ata: ahci_platform: fix ahci_platform_data->suspend method handling
    
    Looking at ST SPEAr1340 AHCI code (the only user of the deprecated
    pdata->suspend and pdata->resume) it is obvious the we should return
    after calling pdata->suspend() only if the function have returned
    non-zero return value.  The code has been broken since commit 1e70c2
    ("ata/ahci_platform: Add clock framework support").  Fix it.
    
    Cc: Viresh Kumar <viresh.linux@gmail.com>
    Cc: Shiraz Hashim <shiraz.hashim@st.com>
    Acked-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 70fbf664a73c..7bd6adf54b3e 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -521,12 +521,19 @@ int ahci_platform_suspend(struct device *dev)
 	if (rc)
 		return rc;
 
-	if (pdata && pdata->suspend)
-		return pdata->suspend(dev);
+	if (pdata && pdata->suspend) {
+		rc = pdata->suspend(dev);
+		if (rc)
+			goto resume_host;
+	}
 
 	ahci_platform_disable_resources(hpriv);
 
 	return 0;
+
+resume_host:
+	ahci_platform_resume_host(dev);
+	return rc;
 }
 EXPORT_SYMBOL_GPL(ahci_platform_suspend);
 

commit 5434b203156ef245b7847128c446c5b54f12a6d4
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Fri Mar 14 18:22:09 2014 +0100

    ata: ahci_platform: fix devm_ioremap_resource() return value checking
    
    devm_ioremap_resource() returns a pointer to the remapped memory or
    an ERR_PTR() encoded error code on failure.  Fix the check inside
    ahci_platform_get_resources() accordingly.
    
    Also while at it remove a needless line break.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index db24d2a08051..70fbf664a73c 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -199,8 +199,7 @@ static void ahci_platform_put_resources(struct device *dev, void *res)
  * RETURNS:
  * The allocated ahci_host_priv on success, otherwise an ERR_PTR value
  */
-struct ahci_host_priv *ahci_platform_get_resources(
-	struct platform_device *pdev)
+struct ahci_host_priv *ahci_platform_get_resources(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct ahci_host_priv *hpriv;
@@ -219,8 +218,9 @@ struct ahci_host_priv *ahci_platform_get_resources(
 
 	hpriv->mmio = devm_ioremap_resource(dev,
 			      platform_get_resource(pdev, IORESOURCE_MEM, 0));
-	if (!hpriv->mmio) {
+	if (IS_ERR(hpriv->mmio)) {
 		dev_err(dev, "no mmio space\n");
+		rc = PTR_ERR(hpriv->mmio);
 		goto err_out;
 	}
 

commit 6ef95e87763fd69889655f4f14e499377a54d066
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Feb 22 17:22:55 2014 +0100

    ahci_platform: Drop unused ahci_platform_data members
    
    These members are not used anywhere, and in the future we want
    ahci_platform_data to go away entirely so there is no reason to keep these
    around.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 8fab4bf9042a..db24d2a08051 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -384,7 +384,6 @@ static int ahci_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct ahci_platform_data *pdata = dev_get_platdata(dev);
-	const struct ata_port_info *pi_template;
 	struct ahci_host_priv *hpriv;
 	int rc;
 
@@ -408,14 +407,7 @@ static int ahci_probe(struct platform_device *pdev)
 			goto disable_resources;
 	}
 
-	if (pdata && pdata->ata_port_info)
-		pi_template = pdata->ata_port_info;
-	else
-		pi_template = &ahci_port_info;
-
-	rc = ahci_platform_init_host(pdev, hpriv, pi_template,
-				     pdata ? pdata->force_port_map : 0,
-				     pdata ? pdata->mask_port_map  : 0);
+	rc = ahci_platform_init_host(pdev, hpriv, &ahci_port_info, 0, 0);
 	if (rc)
 		goto pdata_exit;
 

commit c093e1d36e317c5ac2dc788f407119259fc260fe
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Feb 22 17:22:54 2014 +0100

    ahci_platform: Drop support for imx53-ahci platform device type
    
    Since the 3.13 release the ahci_imx driver has proper devicetree enabled
    support for ahci on imx53 and that is used instead of the old board file
    created imx53-ahci platform device.
    
    Note this patch also complete drops the id-table, an id-table is not needed
    for a single id platform driver, the name field in the driver struct suffices.
    
    And the code already has an explicit "MODULE_ALIAS("platform:ahci");" so the
    id-table is not needed for that either.
    
    Cc: Marek Vasut <marex@denx.de>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index d3d2bad516b4..8fab4bf9042a 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -28,49 +28,17 @@
 
 static void ahci_host_stop(struct ata_host *host);
 
-enum ahci_type {
-	AHCI,		/* standard platform ahci */
-	IMX53_AHCI,	/* ahci on i.mx53 */
-};
-
-static struct platform_device_id ahci_devtype[] = {
-	{
-		.name = "ahci",
-		.driver_data = AHCI,
-	}, {
-		.name = "imx53-ahci",
-		.driver_data = IMX53_AHCI,
-	}, {
-		/* sentinel */
-	}
-};
-MODULE_DEVICE_TABLE(platform, ahci_devtype);
-
 struct ata_port_operations ahci_platform_ops = {
 	.inherits	= &ahci_ops,
 	.host_stop	= ahci_host_stop,
 };
 EXPORT_SYMBOL_GPL(ahci_platform_ops);
 
-static struct ata_port_operations ahci_platform_retry_srst_ops = {
-	.inherits	= &ahci_pmp_retry_srst_ops,
-	.host_stop	= ahci_host_stop,
-};
-
-static const struct ata_port_info ahci_port_info[] = {
-	/* by features */
-	[AHCI] = {
-		.flags		= AHCI_FLAG_COMMON,
-		.pio_mask	= ATA_PIO4,
-		.udma_mask	= ATA_UDMA6,
-		.port_ops	= &ahci_platform_ops,
-	},
-	[IMX53_AHCI] = {
-		.flags		= AHCI_FLAG_COMMON,
-		.pio_mask	= ATA_PIO4,
-		.udma_mask	= ATA_UDMA6,
-		.port_ops	= &ahci_platform_retry_srst_ops,
-	},
+static const struct ata_port_info ahci_port_info = {
+	.flags		= AHCI_FLAG_COMMON,
+	.pio_mask	= ATA_PIO4,
+	.udma_mask	= ATA_UDMA6,
+	.port_ops	= &ahci_platform_ops,
 };
 
 static struct scsi_host_template ahci_platform_sht = {
@@ -416,7 +384,6 @@ static int ahci_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct ahci_platform_data *pdata = dev_get_platdata(dev);
-	const struct platform_device_id *id = platform_get_device_id(pdev);
 	const struct ata_port_info *pi_template;
 	struct ahci_host_priv *hpriv;
 	int rc;
@@ -444,7 +411,7 @@ static int ahci_probe(struct platform_device *pdev)
 	if (pdata && pdata->ata_port_info)
 		pi_template = pdata->ata_port_info;
 	else
-		pi_template = &ahci_port_info[id ? id->driver_data : 0];
+		pi_template = &ahci_port_info;
 
 	rc = ahci_platform_init_host(pdev, hpriv, pi_template,
 				     pdata ? pdata->force_port_map : 0,
@@ -638,7 +605,6 @@ static struct platform_driver ahci_driver = {
 		.of_match_table = ahci_of_match,
 		.pm = &ahci_pm_ops,
 	},
-	.id_table	= ahci_devtype,
 };
 module_platform_driver(ahci_driver);
 

commit f1df8641e27b7edb978bdc7aaf50c235bc9e8be9
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Feb 22 17:22:53 2014 +0100

    ahci_platform: Drop support for ahci-strict platform device type
    
    I've done a grep over the entire kernel tree and nothing is using this
    (anymore?).
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index fc32863d6a5a..d3d2bad516b4 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -31,7 +31,6 @@ static void ahci_host_stop(struct ata_host *host);
 enum ahci_type {
 	AHCI,		/* standard platform ahci */
 	IMX53_AHCI,	/* ahci on i.mx53 */
-	STRICT_AHCI,	/* delayed DMA engine start */
 };
 
 static struct platform_device_id ahci_devtype[] = {
@@ -41,9 +40,6 @@ static struct platform_device_id ahci_devtype[] = {
 	}, {
 		.name = "imx53-ahci",
 		.driver_data = IMX53_AHCI,
-	}, {
-		.name = "strict-ahci",
-		.driver_data = STRICT_AHCI,
 	}, {
 		/* sentinel */
 	}
@@ -75,13 +71,6 @@ static const struct ata_port_info ahci_port_info[] = {
 		.udma_mask	= ATA_UDMA6,
 		.port_ops	= &ahci_platform_retry_srst_ops,
 	},
-	[STRICT_AHCI] = {
-		AHCI_HFLAGS	(AHCI_HFLAG_DELAY_ENGINE),
-		.flags		= AHCI_FLAG_COMMON,
-		.pio_mask	= ATA_PIO4,
-		.udma_mask	= ATA_UDMA6,
-		.port_ops	= &ahci_platform_ops,
-	},
 };
 
 static struct scsi_host_template ahci_platform_sht = {

commit e708e46edac8ab2f31e7ee991aa3c5b87638e658
Author: Roger Quadros <rogerq@ti.com>
Date:   Sat Feb 22 16:53:41 2014 +0100

    ata: ahci_platform: runtime resume the device before use
    
    On OMAP platforms the device needs to be runtime resumed before it can
    be accessed. The OMAP HWMOD framework takes care of enabling the
    module and its resources based on the device's runtime PM state.
    
    In this patch we runtime resume during .probe() and runtime suspend
    after .remove().
    
    We also update the runtime PM state during .resume().
    
    CC: Balaji T K <balajitk@ti.com>
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 243dde36cd98..fc32863d6a5a 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -23,6 +23,7 @@
 #include <linux/libata.h>
 #include <linux/ahci_platform.h>
 #include <linux/phy/phy.h>
+#include <linux/pm_runtime.h>
 #include "ahci.h"
 
 static void ahci_host_stop(struct ata_host *host);
@@ -216,6 +217,11 @@ static void ahci_platform_put_resources(struct device *dev, void *res)
 	struct ahci_host_priv *hpriv = res;
 	int c;
 
+	if (hpriv->got_runtime_pm) {
+		pm_runtime_put_sync(dev);
+		pm_runtime_disable(dev);
+	}
+
 	for (c = 0; c < AHCI_MAX_CLKS && hpriv->clks[c]; c++)
 		clk_put(hpriv->clks[c]);
 }
@@ -309,6 +315,10 @@ struct ahci_host_priv *ahci_platform_get_resources(
 		}
 	}
 
+	pm_runtime_enable(dev);
+	pm_runtime_get_sync(dev);
+	hpriv->got_runtime_pm = true;
+
 	devres_remove_group(dev, NULL);
 	return hpriv;
 
@@ -603,6 +613,11 @@ int ahci_platform_resume(struct device *dev)
 	if (rc)
 		goto disable_resources;
 
+	/* We resumed so update PM runtime state */
+	pm_runtime_disable(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+
 	return 0;
 
 disable_resources:

commit 21b5faeec229d4f70a7f60a7b0b065c98198f491
Author: Roger Quadros <rogerq@ti.com>
Date:   Sat Feb 22 16:53:40 2014 +0100

    ata: ahci_platform: Manage SATA PHY
    
    Some platforms have a PHY hooked up to the SATA controller. The PHY
    needs to be initialized and powered up for SATA to work. We do that
    using the PHY framework.
    
    tj: Minor comment formatting updates.
    
    CC: Balaji T K <balajitk@ti.com>
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tejun Heo<tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 968e7d94af17..243dde36cd98 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -22,6 +22,7 @@
 #include <linux/platform_device.h>
 #include <linux/libata.h>
 #include <linux/ahci_platform.h>
+#include <linux/phy/phy.h>
 #include "ahci.h"
 
 static void ahci_host_stop(struct ata_host *host);
@@ -140,6 +141,7 @@ EXPORT_SYMBOL_GPL(ahci_platform_disable_clks);
  * following order:
  * 1) Regulator
  * 2) Clocks (through ahci_platform_enable_clks)
+ * 3) Phy
  *
  * If resource enabling fails at any point the previous enabled resources
  * are disabled in reverse order.
@@ -161,8 +163,23 @@ int ahci_platform_enable_resources(struct ahci_host_priv *hpriv)
 	if (rc)
 		goto disable_regulator;
 
+	if (hpriv->phy) {
+		rc = phy_init(hpriv->phy);
+		if (rc)
+			goto disable_clks;
+
+		rc = phy_power_on(hpriv->phy);
+		if (rc) {
+			phy_exit(hpriv->phy);
+			goto disable_clks;
+		}
+	}
+
 	return 0;
 
+disable_clks:
+	ahci_platform_disable_clks(hpriv);
+
 disable_regulator:
 	if (hpriv->target_pwr)
 		regulator_disable(hpriv->target_pwr);
@@ -176,11 +193,17 @@ EXPORT_SYMBOL_GPL(ahci_platform_enable_resources);
  *
  * This function disables all ahci_platform managed resources in the
  * following order:
- * 1) Clocks (through ahci_platform_disable_clks)
- * 2) Regulator
+ * 1) Phy
+ * 2) Clocks (through ahci_platform_disable_clks)
+ * 3) Regulator
  */
 void ahci_platform_disable_resources(struct ahci_host_priv *hpriv)
 {
+	if (hpriv->phy) {
+		phy_power_off(hpriv->phy);
+		phy_exit(hpriv->phy);
+	}
+
 	ahci_platform_disable_clks(hpriv);
 
 	if (hpriv->target_pwr)
@@ -208,6 +231,7 @@ static void ahci_platform_put_resources(struct device *dev, void *res)
  * 2) regulator for controlling the targets power (optional)
  * 3) 0 - AHCI_MAX_CLKS clocks, as specified in the devs devicetree node,
  *    or for non devicetree enabled platforms a single clock
+ *	4) phy (optional)
  *
  * RETURNS:
  * The allocated ahci_host_priv on success, otherwise an ERR_PTR value
@@ -266,6 +290,25 @@ struct ahci_host_priv *ahci_platform_get_resources(
 		hpriv->clks[i] = clk;
 	}
 
+	hpriv->phy = devm_phy_get(dev, "sata-phy");
+	if (IS_ERR(hpriv->phy)) {
+		rc = PTR_ERR(hpriv->phy);
+		switch (rc) {
+		case -ENODEV:
+		case -ENOSYS:
+			/* continue normally */
+			hpriv->phy = NULL;
+			break;
+
+		case -EPROBE_DEFER:
+			goto err_out;
+
+		default:
+			dev_err(dev, "couldn't get sata-phy\n");
+			goto err_out;
+		}
+	}
+
 	devres_remove_group(dev, NULL);
 	return hpriv;
 

commit c431147184c05849f1d7e14f8fd6254e1026319d
Author: Roger Quadros <rogerq@ti.com>
Date:   Sat Feb 22 16:53:38 2014 +0100

    ata: ahci_platform: Add DT compatible for Synopsis DWC AHCI controller
    
    Add compatible string "snps,dwc-ahci", which should be used
    for Synopsis Designware SATA cores. e.g. on TI OMAP5 and DRA7 platforms.
    
    Signed-off-by: Roger Quadros <rogerq@ti.com>
    Reviewed-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 01f7bbe65572..968e7d94af17 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -577,6 +577,7 @@ static const struct of_device_id ahci_of_match[] = {
 	{ .compatible = "snps,spear-ahci", },
 	{ .compatible = "snps,exynos5440-ahci", },
 	{ .compatible = "ibm,476gtr-ahci", },
+	{ .compatible = "snps,dwc-ahci", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, ahci_of_match);

commit 648cb6fd83b97f0f772db783a280af300fa9f2bc
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Feb 22 16:53:35 2014 +0100

    ahci-platform: "Library-ise" suspend / resume functionality
    
    Split suspend / resume code into host suspend / resume functionality and
    resource enable / disabling phases, and export the new suspend_ / resume_host
    functions.
    
    tj: Minor comment formatting updates.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 19e9eaafb1f2..01f7bbe65572 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -432,14 +432,23 @@ static void ahci_host_stop(struct ata_host *host)
 }
 
 #ifdef CONFIG_PM_SLEEP
-static int ahci_suspend(struct device *dev)
+/**
+ * ahci_platform_suspend_host - Suspend an ahci-platform host
+ * @dev: device pointer for the host
+ *
+ * This function does all the usual steps needed to suspend an
+ * ahci-platform host, note any necessary resources (ie clks, phy, etc.)
+ * must be disabled after calling this.
+ *
+ * RETURNS:
+ * 0 on success otherwise a negative error code
+ */
+int ahci_platform_suspend_host(struct device *dev)
 {
-	struct ahci_platform_data *pdata = dev_get_platdata(dev);
 	struct ata_host *host = dev_get_drvdata(dev);
 	struct ahci_host_priv *hpriv = host->private_data;
 	void __iomem *mmio = hpriv->mmio;
 	u32 ctl;
-	int rc;
 
 	if (hpriv->flags & AHCI_HFLAG_NO_SUSPEND) {
 		dev_err(dev, "firmware update required for suspend/resume\n");
@@ -456,7 +465,58 @@ static int ahci_suspend(struct device *dev)
 	writel(ctl, mmio + HOST_CTL);
 	readl(mmio + HOST_CTL); /* flush */
 
-	rc = ata_host_suspend(host, PMSG_SUSPEND);
+	return ata_host_suspend(host, PMSG_SUSPEND);
+}
+EXPORT_SYMBOL_GPL(ahci_platform_suspend_host);
+
+/**
+ * ahci_platform_resume_host - Resume an ahci-platform host
+ * @dev: device pointer for the host
+ *
+ * This function does all the usual steps needed to resume an ahci-platform
+ * host, note any necessary resources (ie clks, phy, etc.)  must be
+ * initialized / enabled before calling this.
+ *
+ * RETURNS:
+ * 0 on success otherwise a negative error code
+ */
+int ahci_platform_resume_host(struct device *dev)
+{
+	struct ata_host *host = dev_get_drvdata(dev);
+	int rc;
+
+	if (dev->power.power_state.event == PM_EVENT_SUSPEND) {
+		rc = ahci_reset_controller(host);
+		if (rc)
+			return rc;
+
+		ahci_init_controller(host);
+	}
+
+	ata_host_resume(host);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ahci_platform_resume_host);
+
+/**
+ * ahci_platform_suspend - Suspend an ahci-platform device
+ * @dev: the platform device to suspend
+ *
+ * This function suspends the host associated with the device, followed by
+ * disabling all the resources of the device.
+ *
+ * RETURNS:
+ * 0 on success otherwise a negative error code
+ */
+int ahci_platform_suspend(struct device *dev)
+{
+	struct ahci_platform_data *pdata = dev_get_platdata(dev);
+	struct ata_host *host = dev_get_drvdata(dev);
+	struct ahci_host_priv *hpriv = host->private_data;
+	int rc;
+
+	rc = ahci_platform_suspend_host(dev);
 	if (rc)
 		return rc;
 
@@ -467,8 +527,19 @@ static int ahci_suspend(struct device *dev)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(ahci_platform_suspend);
 
-static int ahci_resume(struct device *dev)
+/**
+ * ahci_platform_resume - Resume an ahci-platform device
+ * @dev: the platform device to resume
+ *
+ * This function enables all the resources of the device followed by
+ * resuming the host associated with the device.
+ *
+ * RETURNS:
+ * 0 on success otherwise a negative error code
+ */
+int ahci_platform_resume(struct device *dev)
 {
 	struct ahci_platform_data *pdata = dev_get_platdata(dev);
 	struct ata_host *host = dev_get_drvdata(dev);
@@ -485,15 +556,9 @@ static int ahci_resume(struct device *dev)
 			goto disable_resources;
 	}
 
-	if (dev->power.power_state.event == PM_EVENT_SUSPEND) {
-		rc = ahci_reset_controller(host);
-		if (rc)
-			goto disable_resources;
-
-		ahci_init_controller(host);
-	}
-
-	ata_host_resume(host);
+	rc = ahci_platform_resume_host(dev);
+	if (rc)
+		goto disable_resources;
 
 	return 0;
 
@@ -502,9 +567,11 @@ static int ahci_resume(struct device *dev)
 
 	return rc;
 }
+EXPORT_SYMBOL_GPL(ahci_platform_resume);
 #endif
 
-static SIMPLE_DEV_PM_OPS(ahci_pm_ops, ahci_suspend, ahci_resume);
+static SIMPLE_DEV_PM_OPS(ahci_pm_ops, ahci_platform_suspend,
+			 ahci_platform_resume);
 
 static const struct of_device_id ahci_of_match[] = {
 	{ .compatible = "snps,spear-ahci", },

commit 23b07d4cb3c0c850055cf968af44019b8da185fb
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Feb 22 16:53:34 2014 +0100

    ahci-platform: "Library-ise" ahci_probe functionality
    
    ahci_probe consists of 3 steps:
    1) Get resources (get mmio, clks, regulator)
    2) Enable resources, handled by ahci_platform_enable_resouces
    3) The more or less standard ahci-host controller init sequence
    
    This commit refactors step 1 and 3 into separate functions, so the platform
    drivers for AHCI implementations which need a specific order in step 2,
    and / or need to do some custom register poking at some time, can re-use
    ahci-platform.c code without needing to copy and paste it.
    
    Note that ahci_platform_init_host's prototype takes the 3 non function
    members of ahci_platform_data as arguments, the idea is that drivers using
    the new exported utility functions will not use ahci_platform_data at all,
    and hopefully in the future ahci_platform_data can go away entirely.
    
    tj: Minor comment formatting updates.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index a32df31013cb..19e9eaafb1f2 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -188,64 +188,60 @@ void ahci_platform_disable_resources(struct ahci_host_priv *hpriv)
 }
 EXPORT_SYMBOL_GPL(ahci_platform_disable_resources);
 
-static void ahci_put_clks(struct ahci_host_priv *hpriv)
+static void ahci_platform_put_resources(struct device *dev, void *res)
 {
+	struct ahci_host_priv *hpriv = res;
 	int c;
 
 	for (c = 0; c < AHCI_MAX_CLKS && hpriv->clks[c]; c++)
 		clk_put(hpriv->clks[c]);
 }
 
-static int ahci_probe(struct platform_device *pdev)
+/**
+ * ahci_platform_get_resources - Get platform resources
+ * @pdev: platform device to get resources for
+ *
+ * This function allocates an ahci_host_priv struct, and gets the following
+ * resources, storing a reference to them inside the returned struct:
+ *
+ * 1) mmio registers (IORESOURCE_MEM 0, mandatory)
+ * 2) regulator for controlling the targets power (optional)
+ * 3) 0 - AHCI_MAX_CLKS clocks, as specified in the devs devicetree node,
+ *    or for non devicetree enabled platforms a single clock
+ *
+ * RETURNS:
+ * The allocated ahci_host_priv on success, otherwise an ERR_PTR value
+ */
+struct ahci_host_priv *ahci_platform_get_resources(
+	struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
-	struct ahci_platform_data *pdata = dev_get_platdata(dev);
-	const struct platform_device_id *id = platform_get_device_id(pdev);
-	struct ata_port_info pi = ahci_port_info[id ? id->driver_data : 0];
-	const struct ata_port_info *ppi[] = { &pi, NULL };
 	struct ahci_host_priv *hpriv;
-	struct ata_host *host;
-	struct resource *mem;
 	struct clk *clk;
-	int irq;
-	int n_ports;
-	int i;
-	int rc;
+	int i, rc = -ENOMEM;
 
-	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!mem) {
-		dev_err(dev, "no mmio space\n");
-		return -EINVAL;
-	}
-
-	irq = platform_get_irq(pdev, 0);
-	if (irq <= 0) {
-		dev_err(dev, "no irq\n");
-		return -EINVAL;
-	}
+	if (!devres_open_group(dev, NULL, GFP_KERNEL))
+		return ERR_PTR(-ENOMEM);
 
-	if (pdata && pdata->ata_port_info)
-		pi = *pdata->ata_port_info;
-
-	hpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);
-	if (!hpriv) {
-		dev_err(dev, "can't alloc ahci_host_priv\n");
-		return -ENOMEM;
-	}
+	hpriv = devres_alloc(ahci_platform_put_resources, sizeof(*hpriv),
+			     GFP_KERNEL);
+	if (!hpriv)
+		goto err_out;
 
-	hpriv->flags |= (unsigned long)pi.private_data;
+	devres_add(dev, hpriv);
 
-	hpriv->mmio = devm_ioremap(dev, mem->start, resource_size(mem));
+	hpriv->mmio = devm_ioremap_resource(dev,
+			      platform_get_resource(pdev, IORESOURCE_MEM, 0));
 	if (!hpriv->mmio) {
-		dev_err(dev, "can't map %pR\n", mem);
-		return -ENOMEM;
+		dev_err(dev, "no mmio space\n");
+		goto err_out;
 	}
 
 	hpriv->target_pwr = devm_regulator_get_optional(dev, "target");
 	if (IS_ERR(hpriv->target_pwr)) {
 		rc = PTR_ERR(hpriv->target_pwr);
 		if (rc == -EPROBE_DEFER)
-			return -EPROBE_DEFER;
+			goto err_out;
 		hpriv->target_pwr = NULL;
 	}
 
@@ -264,33 +260,59 @@ static int ahci_probe(struct platform_device *pdev)
 		if (IS_ERR(clk)) {
 			rc = PTR_ERR(clk);
 			if (rc == -EPROBE_DEFER)
-				goto free_clk;
+				goto err_out;
 			break;
 		}
 		hpriv->clks[i] = clk;
 	}
 
-	rc = ahci_platform_enable_resources(hpriv);
-	if (rc)
-		goto free_clk;
+	devres_remove_group(dev, NULL);
+	return hpriv;
 
-	/*
-	 * Some platforms might need to prepare for mmio region access,
-	 * which could be done in the following init call. So, the mmio
-	 * region shouldn't be accessed before init (if provided) has
-	 * returned successfully.
-	 */
-	if (pdata && pdata->init) {
-		rc = pdata->init(dev, hpriv->mmio);
-		if (rc)
-			goto disable_resources;
-	}
+err_out:
+	devres_release_group(dev, NULL);
+	return ERR_PTR(rc);
+}
+EXPORT_SYMBOL_GPL(ahci_platform_get_resources);
+
+/**
+ * ahci_platform_init_host - Bring up an ahci-platform host
+ * @pdev: platform device pointer for the host
+ * @hpriv: ahci-host private data for the host
+ * @pi_template: template for the ata_port_info to use
+ * @force_port_map: param passed to ahci_save_initial_config
+ * @mask_port_map: param passed to ahci_save_initial_config
+ *
+ * This function does all the usual steps needed to bring up an
+ * ahci-platform host, note any necessary resources (ie clks, phy, etc.)
+ * must be initialized / enabled before calling this.
+ *
+ * RETURNS:
+ * 0 on success otherwise a negative error code
+ */
+int ahci_platform_init_host(struct platform_device *pdev,
+			    struct ahci_host_priv *hpriv,
+			    const struct ata_port_info *pi_template,
+			    unsigned int force_port_map,
+			    unsigned int mask_port_map)
+{
+	struct device *dev = &pdev->dev;
+	struct ata_port_info pi = *pi_template;
+	const struct ata_port_info *ppi[] = { &pi, NULL };
+	struct ata_host *host;
+	int i, irq, n_ports, rc;
 
-	ahci_save_initial_config(dev, hpriv,
-		pdata ? pdata->force_port_map : 0,
-		pdata ? pdata->mask_port_map  : 0);
+	irq = platform_get_irq(pdev, 0);
+	if (irq <= 0) {
+		dev_err(dev, "no irq\n");
+		return -EINVAL;
+	}
 
 	/* prepare host */
+	hpriv->flags |= (unsigned long)pi.private_data;
+
+	ahci_save_initial_config(dev, hpriv, force_port_map, mask_port_map);
+
 	if (hpriv->cap & HOST_CAP_NCQ)
 		pi.flags |= ATA_FLAG_NCQ;
 
@@ -307,10 +329,8 @@ static int ahci_probe(struct platform_device *pdev)
 	n_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));
 
 	host = ata_host_alloc_pinfo(dev, ppi, n_ports);
-	if (!host) {
-		rc = -ENOMEM;
-		goto pdata_exit;
-	}
+	if (!host)
+		return -ENOMEM;
 
 	host->private_data = hpriv;
 
@@ -325,7 +345,8 @@ static int ahci_probe(struct platform_device *pdev)
 	for (i = 0; i < host->n_ports; i++) {
 		struct ata_port *ap = host->ports[i];
 
-		ata_port_desc(ap, "mmio %pR", mem);
+		ata_port_desc(ap, "mmio %pR",
+			      platform_get_resource(pdev, IORESOURCE_MEM, 0));
 		ata_port_desc(ap, "port 0x%x", 0x100 + ap->port_no * 0x80);
 
 		/* set enclosure management message type */
@@ -339,13 +360,53 @@ static int ahci_probe(struct platform_device *pdev)
 
 	rc = ahci_reset_controller(host);
 	if (rc)
-		goto pdata_exit;
+		return rc;
 
 	ahci_init_controller(host);
 	ahci_print_info(host, "platform");
 
-	rc = ata_host_activate(host, irq, ahci_interrupt, IRQF_SHARED,
-			       &ahci_platform_sht);
+	return ata_host_activate(host, irq, ahci_interrupt, IRQF_SHARED,
+				 &ahci_platform_sht);
+}
+EXPORT_SYMBOL_GPL(ahci_platform_init_host);
+
+static int ahci_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct ahci_platform_data *pdata = dev_get_platdata(dev);
+	const struct platform_device_id *id = platform_get_device_id(pdev);
+	const struct ata_port_info *pi_template;
+	struct ahci_host_priv *hpriv;
+	int rc;
+
+	hpriv = ahci_platform_get_resources(pdev);
+	if (IS_ERR(hpriv))
+		return PTR_ERR(hpriv);
+
+	rc = ahci_platform_enable_resources(hpriv);
+	if (rc)
+		return rc;
+
+	/*
+	 * Some platforms might need to prepare for mmio region access,
+	 * which could be done in the following init call. So, the mmio
+	 * region shouldn't be accessed before init (if provided) has
+	 * returned successfully.
+	 */
+	if (pdata && pdata->init) {
+		rc = pdata->init(dev, hpriv->mmio);
+		if (rc)
+			goto disable_resources;
+	}
+
+	if (pdata && pdata->ata_port_info)
+		pi_template = pdata->ata_port_info;
+	else
+		pi_template = &ahci_port_info[id ? id->driver_data : 0];
+
+	rc = ahci_platform_init_host(pdev, hpriv, pi_template,
+				     pdata ? pdata->force_port_map : 0,
+				     pdata ? pdata->mask_port_map  : 0);
 	if (rc)
 		goto pdata_exit;
 
@@ -355,8 +416,6 @@ static int ahci_probe(struct platform_device *pdev)
 		pdata->exit(dev);
 disable_resources:
 	ahci_platform_disable_resources(hpriv);
-free_clk:
-	ahci_put_clks(hpriv);
 	return rc;
 }
 
@@ -370,7 +429,6 @@ static void ahci_host_stop(struct ata_host *host)
 		pdata->exit(dev);
 
 	ahci_platform_disable_resources(hpriv);
-	ahci_put_clks(hpriv);
 }
 
 #ifdef CONFIG_PM_SLEEP

commit 96a01ba52c60fdd74dd6e8cf06645d06515b1396
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Feb 22 16:53:33 2014 +0100

    ahci-platform: Add enable_ / disable_resources helper functions
    
    tj: Minor comment formatting updates.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 4befd78133ad..a32df31013cb 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -132,6 +132,62 @@ void ahci_platform_disable_clks(struct ahci_host_priv *hpriv)
 }
 EXPORT_SYMBOL_GPL(ahci_platform_disable_clks);
 
+/**
+ * ahci_platform_enable_resources - Enable platform resources
+ * @hpriv: host private area to store config values
+ *
+ * This function enables all ahci_platform managed resources in the
+ * following order:
+ * 1) Regulator
+ * 2) Clocks (through ahci_platform_enable_clks)
+ *
+ * If resource enabling fails at any point the previous enabled resources
+ * are disabled in reverse order.
+ *
+ * RETURNS:
+ * 0 on success otherwise a negative error code
+ */
+int ahci_platform_enable_resources(struct ahci_host_priv *hpriv)
+{
+	int rc;
+
+	if (hpriv->target_pwr) {
+		rc = regulator_enable(hpriv->target_pwr);
+		if (rc)
+			return rc;
+	}
+
+	rc = ahci_platform_enable_clks(hpriv);
+	if (rc)
+		goto disable_regulator;
+
+	return 0;
+
+disable_regulator:
+	if (hpriv->target_pwr)
+		regulator_disable(hpriv->target_pwr);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(ahci_platform_enable_resources);
+
+/**
+ * ahci_platform_disable_resources - Disable platform resources
+ * @hpriv: host private area to store config values
+ *
+ * This function disables all ahci_platform managed resources in the
+ * following order:
+ * 1) Clocks (through ahci_platform_disable_clks)
+ * 2) Regulator
+ */
+void ahci_platform_disable_resources(struct ahci_host_priv *hpriv)
+{
+	ahci_platform_disable_clks(hpriv);
+
+	if (hpriv->target_pwr)
+		regulator_disable(hpriv->target_pwr);
+}
+EXPORT_SYMBOL_GPL(ahci_platform_disable_resources);
+
 static void ahci_put_clks(struct ahci_host_priv *hpriv)
 {
 	int c;
@@ -214,15 +270,9 @@ static int ahci_probe(struct platform_device *pdev)
 		hpriv->clks[i] = clk;
 	}
 
-	if (hpriv->target_pwr) {
-		rc = regulator_enable(hpriv->target_pwr);
-		if (rc)
-			goto free_clk;
-	}
-
-	rc = ahci_enable_clks(dev, hpriv);
+	rc = ahci_platform_enable_resources(hpriv);
 	if (rc)
-		goto disable_regulator;
+		goto free_clk;
 
 	/*
 	 * Some platforms might need to prepare for mmio region access,
@@ -233,7 +283,7 @@ static int ahci_probe(struct platform_device *pdev)
 	if (pdata && pdata->init) {
 		rc = pdata->init(dev, hpriv->mmio);
 		if (rc)
-			goto disable_unprepare_clk;
+			goto disable_resources;
 	}
 
 	ahci_save_initial_config(dev, hpriv,
@@ -303,11 +353,8 @@ static int ahci_probe(struct platform_device *pdev)
 pdata_exit:
 	if (pdata && pdata->exit)
 		pdata->exit(dev);
-disable_unprepare_clk:
-	ahci_disable_clks(hpriv);
-disable_regulator:
-	if (hpriv->target_pwr)
-		regulator_disable(hpriv->target_pwr);
+disable_resources:
+	ahci_platform_disable_resources(hpriv);
 free_clk:
 	ahci_put_clks(hpriv);
 	return rc;
@@ -322,11 +369,8 @@ static void ahci_host_stop(struct ata_host *host)
 	if (pdata && pdata->exit)
 		pdata->exit(dev);
 
-	ahci_disable_clks(hpriv);
+	ahci_platform_disable_resources(hpriv);
 	ahci_put_clks(hpriv);
-
-	if (hpriv->target_pwr)
-		regulator_disable(hpriv->target_pwr);
 }
 
 #ifdef CONFIG_PM_SLEEP
@@ -361,10 +405,7 @@ static int ahci_suspend(struct device *dev)
 	if (pdata && pdata->suspend)
 		return pdata->suspend(dev);
 
-	ahci_disable_clks(hpriv);
-
-	if (hpriv->target_pwr)
-		regulator_disable(hpriv->target_pwr);
+	ahci_platform_disable_resources(hpriv);
 
 	return 0;
 }
@@ -376,26 +417,20 @@ static int ahci_resume(struct device *dev)
 	struct ahci_host_priv *hpriv = host->private_data;
 	int rc;
 
-	if (hpriv->target_pwr) {
-		rc = regulator_enable(hpriv->target_pwr);
-		if (rc)
-			return rc;
-	}
-
-	rc = ahci_enable_clks(dev, hpriv);
+	rc = ahci_platform_enable_resources(hpriv);
 	if (rc)
-		goto disable_regulator;
+		return rc;
 
 	if (pdata && pdata->resume) {
 		rc = pdata->resume(dev);
 		if (rc)
-			goto disable_unprepare_clk;
+			goto disable_resources;
 	}
 
 	if (dev->power.power_state.event == PM_EVENT_SUSPEND) {
 		rc = ahci_reset_controller(host);
 		if (rc)
-			goto disable_unprepare_clk;
+			goto disable_resources;
 
 		ahci_init_controller(host);
 	}
@@ -404,11 +439,8 @@ static int ahci_resume(struct device *dev)
 
 	return 0;
 
-disable_unprepare_clk:
-	ahci_disable_clks(hpriv);
-disable_regulator:
-	if (hpriv->target_pwr)
-		regulator_disable(hpriv->target_pwr);
+disable_resources:
+	ahci_platform_disable_resources(hpriv);
 
 	return rc;
 }

commit 4b3e603a298db26c6c37e8b08adcce24d014df13
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Feb 22 16:53:32 2014 +0100

    ahci-platform: Add support for an optional regulator for sata-target power
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 8d5a9a7ce958..4befd78133ad 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -185,6 +185,14 @@ static int ahci_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	}
 
+	hpriv->target_pwr = devm_regulator_get_optional(dev, "target");
+	if (IS_ERR(hpriv->target_pwr)) {
+		rc = PTR_ERR(hpriv->target_pwr);
+		if (rc == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+		hpriv->target_pwr = NULL;
+	}
+
 	for (i = 0; i < AHCI_MAX_CLKS; i++) {
 		/*
 		 * For now we must use clk_get(dev, NULL) for the first clock,
@@ -206,9 +214,15 @@ static int ahci_probe(struct platform_device *pdev)
 		hpriv->clks[i] = clk;
 	}
 
+	if (hpriv->target_pwr) {
+		rc = regulator_enable(hpriv->target_pwr);
+		if (rc)
+			goto free_clk;
+	}
+
 	rc = ahci_enable_clks(dev, hpriv);
 	if (rc)
-		goto free_clk;
+		goto disable_regulator;
 
 	/*
 	 * Some platforms might need to prepare for mmio region access,
@@ -291,6 +305,9 @@ static int ahci_probe(struct platform_device *pdev)
 		pdata->exit(dev);
 disable_unprepare_clk:
 	ahci_disable_clks(hpriv);
+disable_regulator:
+	if (hpriv->target_pwr)
+		regulator_disable(hpriv->target_pwr);
 free_clk:
 	ahci_put_clks(hpriv);
 	return rc;
@@ -307,6 +324,9 @@ static void ahci_host_stop(struct ata_host *host)
 
 	ahci_disable_clks(hpriv);
 	ahci_put_clks(hpriv);
+
+	if (hpriv->target_pwr)
+		regulator_disable(hpriv->target_pwr);
 }
 
 #ifdef CONFIG_PM_SLEEP
@@ -343,6 +363,9 @@ static int ahci_suspend(struct device *dev)
 
 	ahci_disable_clks(hpriv);
 
+	if (hpriv->target_pwr)
+		regulator_disable(hpriv->target_pwr);
+
 	return 0;
 }
 
@@ -353,9 +376,15 @@ static int ahci_resume(struct device *dev)
 	struct ahci_host_priv *hpriv = host->private_data;
 	int rc;
 
+	if (hpriv->target_pwr) {
+		rc = regulator_enable(hpriv->target_pwr);
+		if (rc)
+			return rc;
+	}
+
 	rc = ahci_enable_clks(dev, hpriv);
 	if (rc)
-		return rc;
+		goto disable_regulator;
 
 	if (pdata && pdata->resume) {
 		rc = pdata->resume(dev);
@@ -377,6 +406,9 @@ static int ahci_resume(struct device *dev)
 
 disable_unprepare_clk:
 	ahci_disable_clks(hpriv);
+disable_regulator:
+	if (hpriv->target_pwr)
+		regulator_disable(hpriv->target_pwr);
 
 	return rc;
 }

commit 156c5887948cd191417f18026aab9ce26e5a95da
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Sat Feb 22 16:53:31 2014 +0100

    ahci-platform: Add support for devices with more then 1 clock
    
    The allwinner-sun4i AHCI controller needs 2 clocks to be enabled and the
    imx AHCI controller needs 3 clocks to be enabled.
    
    tj: Minor comment formatting updates.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 9302d8143393..8d5a9a7ce958 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -86,6 +86,60 @@ static struct scsi_host_template ahci_platform_sht = {
 	AHCI_SHT("ahci_platform"),
 };
 
+/**
+ * ahci_platform_enable_clks - Enable platform clocks
+ * @hpriv: host private area to store config values
+ *
+ * This function enables all the clks found in hpriv->clks, starting at
+ * index 0. If any clk fails to enable it disables all the clks already
+ * enabled in reverse order, and then returns an error.
+ *
+ * RETURNS:
+ * 0 on success otherwise a negative error code
+ */
+int ahci_platform_enable_clks(struct ahci_host_priv *hpriv)
+{
+	int c, rc;
+
+	for (c = 0; c < AHCI_MAX_CLKS && hpriv->clks[c]; c++) {
+		rc = clk_prepare_enable(hpriv->clks[c]);
+		if (rc)
+			goto disable_unprepare_clk;
+	}
+	return 0;
+
+disable_unprepare_clk:
+	while (--c >= 0)
+		clk_disable_unprepare(hpriv->clks[c]);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(ahci_platform_enable_clks);
+
+/**
+ * ahci_platform_disable_clks - Disable platform clocks
+ * @hpriv: host private area to store config values
+ *
+ * This function disables all the clks found in hpriv->clks, in reverse
+ * order of ahci_platform_enable_clks (starting at the end of the array).
+ */
+void ahci_platform_disable_clks(struct ahci_host_priv *hpriv)
+{
+	int c;
+
+	for (c = AHCI_MAX_CLKS - 1; c >= 0; c--)
+		if (hpriv->clks[c])
+			clk_disable_unprepare(hpriv->clks[c]);
+}
+EXPORT_SYMBOL_GPL(ahci_platform_disable_clks);
+
+static void ahci_put_clks(struct ahci_host_priv *hpriv)
+{
+	int c;
+
+	for (c = 0; c < AHCI_MAX_CLKS && hpriv->clks[c]; c++)
+		clk_put(hpriv->clks[c]);
+}
+
 static int ahci_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -96,6 +150,7 @@ static int ahci_probe(struct platform_device *pdev)
 	struct ahci_host_priv *hpriv;
 	struct ata_host *host;
 	struct resource *mem;
+	struct clk *clk;
 	int irq;
 	int n_ports;
 	int i;
@@ -130,17 +185,31 @@ static int ahci_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	}
 
-	hpriv->clk = clk_get(dev, NULL);
-	if (IS_ERR(hpriv->clk)) {
-		dev_err(dev, "can't get clock\n");
-	} else {
-		rc = clk_prepare_enable(hpriv->clk);
-		if (rc) {
-			dev_err(dev, "clock prepare enable failed");
-			goto free_clk;
+	for (i = 0; i < AHCI_MAX_CLKS; i++) {
+		/*
+		 * For now we must use clk_get(dev, NULL) for the first clock,
+		 * because some platforms (da850, spear13xx) are not yet
+		 * converted to use devicetree for clocks.  For new platforms
+		 * this is equivalent to of_clk_get(dev->of_node, 0).
+		 */
+		if (i == 0)
+			clk = clk_get(dev, NULL);
+		else
+			clk = of_clk_get(dev->of_node, i);
+
+		if (IS_ERR(clk)) {
+			rc = PTR_ERR(clk);
+			if (rc == -EPROBE_DEFER)
+				goto free_clk;
+			break;
 		}
+		hpriv->clks[i] = clk;
 	}
 
+	rc = ahci_enable_clks(dev, hpriv);
+	if (rc)
+		goto free_clk;
+
 	/*
 	 * Some platforms might need to prepare for mmio region access,
 	 * which could be done in the following init call. So, the mmio
@@ -221,11 +290,9 @@ static int ahci_probe(struct platform_device *pdev)
 	if (pdata && pdata->exit)
 		pdata->exit(dev);
 disable_unprepare_clk:
-	if (!IS_ERR(hpriv->clk))
-		clk_disable_unprepare(hpriv->clk);
+	ahci_disable_clks(hpriv);
 free_clk:
-	if (!IS_ERR(hpriv->clk))
-		clk_put(hpriv->clk);
+	ahci_put_clks(hpriv);
 	return rc;
 }
 
@@ -238,10 +305,8 @@ static void ahci_host_stop(struct ata_host *host)
 	if (pdata && pdata->exit)
 		pdata->exit(dev);
 
-	if (!IS_ERR(hpriv->clk)) {
-		clk_disable_unprepare(hpriv->clk);
-		clk_put(hpriv->clk);
-	}
+	ahci_disable_clks(hpriv);
+	ahci_put_clks(hpriv);
 }
 
 #ifdef CONFIG_PM_SLEEP
@@ -276,8 +341,7 @@ static int ahci_suspend(struct device *dev)
 	if (pdata && pdata->suspend)
 		return pdata->suspend(dev);
 
-	if (!IS_ERR(hpriv->clk))
-		clk_disable_unprepare(hpriv->clk);
+	ahci_disable_clks(hpriv);
 
 	return 0;
 }
@@ -289,13 +353,9 @@ static int ahci_resume(struct device *dev)
 	struct ahci_host_priv *hpriv = host->private_data;
 	int rc;
 
-	if (!IS_ERR(hpriv->clk)) {
-		rc = clk_prepare_enable(hpriv->clk);
-		if (rc) {
-			dev_err(dev, "clock prepare enable failed");
-			return rc;
-		}
-	}
+	rc = ahci_enable_clks(dev, hpriv);
+	if (rc)
+		return rc;
 
 	if (pdata && pdata->resume) {
 		rc = pdata->resume(dev);
@@ -316,8 +376,7 @@ static int ahci_resume(struct device *dev)
 	return 0;
 
 disable_unprepare_clk:
-	if (!IS_ERR(hpriv->clk))
-		clk_disable_unprepare(hpriv->clk);
+	ahci_disable_clks(hpriv);
 
 	return rc;
 }

commit 1bc18086231c130895b87ec049be8ddcdab552b8
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Jan 21 16:22:51 2014 -0500

    ata: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Cc: linux-ide@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 4b231baceb09..9302d8143393 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -17,7 +17,6 @@
 #include <linux/gfp.h>
 #include <linux/module.h>
 #include <linux/pm.h>
-#include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/device.h>
 #include <linux/platform_device.h>

commit 2435dcb98cfe13c246aa27df393e22bc24bbcd20
Author: Alistair Popple <alistair@popple.id.au>
Date:   Fri Nov 22 13:08:29 2013 +1100

    ahci: add support for IBM Akebono platform device
    
    The new IBM Akebono board has a PPC476GTR SoC with an AHCI compliant
    SATA controller. This patch adds a compatible property for the new SoC
    to the AHCI platform driver.
    
    Signed-off-by: Alistair Popple <alistair@popple.id.au>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index f9554318504f..4b231baceb09 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -329,6 +329,7 @@ static SIMPLE_DEV_PM_OPS(ahci_pm_ops, ahci_suspend, ahci_resume);
 static const struct of_device_id ahci_of_match[] = {
 	{ .compatible = "snps,spear-ahci", },
 	{ .compatible = "snps,exynos5440-ahci", },
+	{ .compatible = "ibm,476gtr-ahci", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, ahci_of_match);

commit 13aa7e0bc20f7f7e5ef45f0defc4ff4380802302
Merge: c08acff0544c 9f961a5f6efc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 13 15:18:22 2013 +0900

    Merge branch 'for-3.13' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata
    
    Pull libata changes from Tejun Heo:
     "Nothing too interesting.  Only two minor fixes in libata core.  Most
      changes are specific to hardware which isn't too common"
    
    * 'for-3.13' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata:
      ahci: Add Device IDs for Intel Wildcat Point-LP
      sata_rcar: Convert to clk_prepare/unprepare
      drivers/libata: Set max sector to 65535 for Slimtype DVD A DS8A9SH drive
      libata: Add some missing command descriptions
      sata_highbank: clear whole array in highbank_initialize_phys()
      ahci: disabled FBS prior to issuing software reset
      libata: Fix display of sata speed
      ahci: imx: setup power saving methods
      ata_piix: minor typo and a printk fix
      ahci: Changing two module params with static and __read_mostly

commit 8b789d89813fae01908ecc825c9dfc0ec90647ad
Author: Richard Zhu <r65037@freescale.com>
Date:   Tue Oct 15 10:44:54 2013 +0800

    ahci: imx: setup power saving methods
    
    In order to save power consumption as much as possible.
    
    * Disable sata phy internal pll reference clock when sysetem enter
      into suspend mode, enable it after resume.
    
    * Setup module parameter used to enable imx ahci test power down
      mode(PDDQ) or not, when there is no device detected on the port
    
    * minor modifications:
      - The format of the copyright is changed, because that the original
        one can't pass fsl internal patch reivew without the character
        '(c)'.
      - Exports ahci_platform_ops and ahci_error_handler().
    
    NOTE:
    * The hot-plug can't be supported when PDDQ mode is ever enabled.
    
    * module parameter usage how-to:
      - default: enable PDDQ mode when no device detected.
      - add "ahci-imx.hotplug=1" into kernel command line if your don't
        want to enable PDDQ mode when no device detected on the port.
    
    tj: Slightly updated description and comments.
    
    Signed-off-by: Richard Zhu <r65037@freescale.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 2daaee05cab1..7708ca71f14e 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -49,10 +49,11 @@ static struct platform_device_id ahci_devtype[] = {
 };
 MODULE_DEVICE_TABLE(platform, ahci_devtype);
 
-static struct ata_port_operations ahci_platform_ops = {
+struct ata_port_operations ahci_platform_ops = {
 	.inherits	= &ahci_ops,
 	.host_stop	= ahci_host_stop,
 };
+EXPORT_SYMBOL_GPL(ahci_platform_ops);
 
 static struct ata_port_operations ahci_platform_retry_srst_ops = {
 	.inherits	= &ahci_pmp_retry_srst_ops,

commit 0fed4c09dca6820adaee28e55cd4283e74d029cd
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Sat Oct 5 09:15:59 2013 +0900

    ahci_platform: use dev_info() instead of printk()
    
    Change "raw" printk() call to dev_info() to provide a better
    message to userspace so it can properly identify the device
    and not just have to guess.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 2daaee05cab1..7d3b85385bfc 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -184,7 +184,7 @@ static int ahci_probe(struct platform_device *pdev)
 	if (!(hpriv->cap & HOST_CAP_SSS) || ahci_ignore_sss)
 		host->flags |= ATA_HOST_PARALLEL_SCAN;
 	else
-		printk(KERN_INFO "ahci: SSS flag set, parallel bus scan disabled\n");
+		dev_info(dev, "SSS flag set, parallel bus scan disabled\n");
 
 	if (pi.flags & ATA_FLAG_EM)
 		ahci_reset_em(host);

commit 1e8f5f761ca3636bb6e281d9dd8adfa887b38eea
Author: Girish K S <girishks2000@gmail.com>
Date:   Tue Apr 16 14:58:02 2013 +0530

    ahci: sata: add support for exynos5440 sata
    
    This patch adds the compatible string of the exynos5440 sata controller
    compliant with the ahci 1.3 and sata 3.0 specification.
    
    changes in v2:
                    changed the compatible string by adding the actual IP
    owners name instead of the SoC vendor name.
    
    Signed-off-by: Girish K S <ks.giri@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 7a8a2841fe64..2daaee05cab1 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -327,6 +327,7 @@ static SIMPLE_DEV_PM_OPS(ahci_pm_ops, ahci_suspend, ahci_resume);
 
 static const struct of_device_id ahci_of_match[] = {
 	{ .compatible = "snps,spear-ahci", },
+	{ .compatible = "snps,exynos5440-ahci", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, ahci_of_match);

commit 0ec24914675c48213378da550db494bf154f0f6c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:19:58 2012 -0800

    Drivers: ata: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Cc: Viresh Kumar <viresh.linux@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 1cc467bdb63d..7a8a2841fe64 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -86,7 +86,7 @@ static struct scsi_host_template ahci_platform_sht = {
 	AHCI_SHT("ahci_platform"),
 };
 
-static int __devinit ahci_probe(struct platform_device *pdev)
+static int ahci_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct ahci_platform_data *pdata = dev_get_platdata(dev);

commit 071d3ad37485a82e0543a503272c45cdd32053dd
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Wed Dec 5 23:44:20 2012 -0800

    ahci_platform: make structs static
    
    These structs are used only for ahci_platform.c, so they should be
    static. Thanks to Fengguang for the (automated) suggestion.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Cc: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 1d90690d85f7..1cc467bdb63d 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -49,12 +49,12 @@ static struct platform_device_id ahci_devtype[] = {
 };
 MODULE_DEVICE_TABLE(platform, ahci_devtype);
 
-struct ata_port_operations ahci_platform_ops = {
+static struct ata_port_operations ahci_platform_ops = {
 	.inherits	= &ahci_ops,
 	.host_stop	= ahci_host_stop,
 };
 
-struct ata_port_operations ahci_platform_retry_srst_ops = {
+static struct ata_port_operations ahci_platform_retry_srst_ops = {
 	.inherits	= &ahci_pmp_retry_srst_ops,
 	.host_stop	= ahci_host_stop,
 };
@@ -323,7 +323,7 @@ static int ahci_resume(struct device *dev)
 }
 #endif
 
-SIMPLE_DEV_PM_OPS(ahci_pm_ops, ahci_suspend, ahci_resume);
+static SIMPLE_DEV_PM_OPS(ahci_pm_ops, ahci_suspend, ahci_resume);
 
 static const struct of_device_id ahci_of_match[] = {
 	{ .compatible = "snps,spear-ahci", },

commit 83291d65cbeadda2bd600b6c500df7046dcd6fa9
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Nov 2 00:46:19 2012 -0700

    ahci_platform: utilize common ata_platform_remove_one()
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 5aa4309d4481..1d90690d85f7 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -229,16 +229,6 @@ static int __devinit ahci_probe(struct platform_device *pdev)
 	return rc;
 }
 
-static int __devexit ahci_remove(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	struct ata_host *host = dev_get_drvdata(dev);
-
-	ata_host_detach(host);
-
-	return 0;
-}
-
 static void ahci_host_stop(struct ata_host *host)
 {
 	struct device *dev = host->dev;
@@ -343,7 +333,7 @@ MODULE_DEVICE_TABLE(of, ahci_of_match);
 
 static struct platform_driver ahci_driver = {
 	.probe = ahci_probe,
-	.remove = __devexit_p(ahci_remove),
+	.remove = ata_platform_remove_one,
 	.driver = {
 		.name = "ahci",
 		.owner = THIS_MODULE,

commit 1896b15eddb4ff7266bccf3efa981885ecf80ab1
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Nov 2 00:46:17 2012 -0700

    ahci_platform: perform platform exit in host_stop() hook
    
    AHCI platform devices may provide an exit() routine, via
    ahci_platform_data, that powers off the SATA core. Such a routine should
    be executed from the ata_port_operations host_stop() hook. That way, the
    ATA subsystem can perform any last-minute hardware cleanup (via devres,
    for example), then trigger the power-off at the appropriate time.
    
    This patch fixes bus errors triggered during module removal or device
    unbinding, seen on an SoC SATA core.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index fbbfa2bccbcd..5aa4309d4481 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -25,6 +25,8 @@
 #include <linux/ahci_platform.h>
 #include "ahci.h"
 
+static void ahci_host_stop(struct ata_host *host);
+
 enum ahci_type {
 	AHCI,		/* standard platform ahci */
 	IMX53_AHCI,	/* ahci on i.mx53 */
@@ -47,6 +49,15 @@ static struct platform_device_id ahci_devtype[] = {
 };
 MODULE_DEVICE_TABLE(platform, ahci_devtype);
 
+struct ata_port_operations ahci_platform_ops = {
+	.inherits	= &ahci_ops,
+	.host_stop	= ahci_host_stop,
+};
+
+struct ata_port_operations ahci_platform_retry_srst_ops = {
+	.inherits	= &ahci_pmp_retry_srst_ops,
+	.host_stop	= ahci_host_stop,
+};
 
 static const struct ata_port_info ahci_port_info[] = {
 	/* by features */
@@ -54,20 +65,20 @@ static const struct ata_port_info ahci_port_info[] = {
 		.flags		= AHCI_FLAG_COMMON,
 		.pio_mask	= ATA_PIO4,
 		.udma_mask	= ATA_UDMA6,
-		.port_ops	= &ahci_ops,
+		.port_ops	= &ahci_platform_ops,
 	},
 	[IMX53_AHCI] = {
 		.flags		= AHCI_FLAG_COMMON,
 		.pio_mask	= ATA_PIO4,
 		.udma_mask	= ATA_UDMA6,
-		.port_ops	= &ahci_pmp_retry_srst_ops,
+		.port_ops	= &ahci_platform_retry_srst_ops,
 	},
 	[STRICT_AHCI] = {
 		AHCI_HFLAGS	(AHCI_HFLAG_DELAY_ENGINE),
 		.flags		= AHCI_FLAG_COMMON,
 		.pio_mask	= ATA_PIO4,
 		.udma_mask	= ATA_UDMA6,
-		.port_ops	= &ahci_ops,
+		.port_ops	= &ahci_platform_ops,
 	},
 };
 
@@ -221,12 +232,19 @@ static int __devinit ahci_probe(struct platform_device *pdev)
 static int __devexit ahci_remove(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
-	struct ahci_platform_data *pdata = dev_get_platdata(dev);
 	struct ata_host *host = dev_get_drvdata(dev);
-	struct ahci_host_priv *hpriv = host->private_data;
 
 	ata_host_detach(host);
 
+	return 0;
+}
+
+static void ahci_host_stop(struct ata_host *host)
+{
+	struct device *dev = host->dev;
+	struct ahci_platform_data *pdata = dev_get_platdata(dev);
+	struct ahci_host_priv *hpriv = host->private_data;
+
 	if (pdata && pdata->exit)
 		pdata->exit(dev);
 
@@ -234,8 +252,6 @@ static int __devexit ahci_remove(struct platform_device *pdev)
 		clk_disable_unprepare(hpriv->clk);
 		clk_put(hpriv->clk);
 	}
-
-	return 0;
 }
 
 #ifdef CONFIG_PM_SLEEP

commit 9a99e4768a6dcfa50d1cda1b2f55c9ea5c4213cc
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Nov 2 00:46:16 2012 -0700

    ahci_platform: convert to module_platform_driver
    
    The ahci_platform driver can now use the module_platform_driver() macro.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index c598fd7cbf3f..fbbfa2bccbcd 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -336,18 +336,7 @@ static struct platform_driver ahci_driver = {
 	},
 	.id_table	= ahci_devtype,
 };
-
-static int __init ahci_init(void)
-{
-	return platform_driver_register(&ahci_driver);
-}
-module_init(ahci_init);
-
-static void __exit ahci_exit(void)
-{
-	platform_driver_unregister(&ahci_driver);
-}
-module_exit(ahci_exit);
+module_platform_driver(ahci_driver);
 
 MODULE_DESCRIPTION("AHCI SATA platform driver");
 MODULE_AUTHOR("Anton Vorontsov <avorontsov@ru.mvista.com>");

commit 941c77fd0f2f6f5964a3f9fba4e8779714faf832
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Nov 2 00:46:15 2012 -0700

    ahci_platform: enable hotplug unbinding
    
    platform_driver_probe() should be used for registering this driver only
    if we want to
    
        "...remove its run-once probe() infrastructure from memory after the
        driver has bound to the device."
    
    However, we may want to leave the probe infrastructure in place in order
    to support binding/unbinding a device dynamically. This is useful, for
    instance, as a power management mechanism, where a device can be totally
    powered down when unbound (whereas with runtime power management,
    powering down the SATA core would incur unacceptable loss of
    functionality).
    
    Thus, convert this driver to use platform_driver_register().
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index b7078afddb74..c598fd7cbf3f 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -75,7 +75,7 @@ static struct scsi_host_template ahci_platform_sht = {
 	AHCI_SHT("ahci_platform"),
 };
 
-static int __init ahci_probe(struct platform_device *pdev)
+static int __devinit ahci_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct ahci_platform_data *pdata = dev_get_platdata(dev);
@@ -326,6 +326,7 @@ static const struct of_device_id ahci_of_match[] = {
 MODULE_DEVICE_TABLE(of, ahci_of_match);
 
 static struct platform_driver ahci_driver = {
+	.probe = ahci_probe,
 	.remove = __devexit_p(ahci_remove),
 	.driver = {
 		.name = "ahci",
@@ -338,7 +339,7 @@ static struct platform_driver ahci_driver = {
 
 static int __init ahci_init(void)
 {
-	return platform_driver_probe(&ahci_driver, ahci_probe);
+	return platform_driver_register(&ahci_driver);
 }
 module_init(ahci_init);
 

commit 29448ec129c5c9c7ece2ef28c72a0dafd70c8af2
Author: Yuanhan Liu <yuanhan.liu@linux.intel.com>
Date:   Tue Oct 16 22:59:01 2012 +0800

    [libata] PM callbacks should be conditionally compiled on CONFIG_PM_SLEEP
    
    This will fix warnings like following when CONFIG_PM_SLEEP is not set:
    
            warning: 'xxx_suspend' defined but not used [-Wunused-function]
            warning: 'xxx_resume' defined but not used [-Wunused-function]
    
    Because
            SET_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn)
    
    Only references the callbacks on CONFIG_PM_SLEEP (instead of CONFIG_PM).
    
    Cc: Viresh Kumar <viresh.linux@gmail.com>
    Cc: linux-ide@vger.kernel.org
    Signed-off-by: Yuanhan Liu <yuanhan.liu@linux.intel.com>
    Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index b1ae48054dc5..b7078afddb74 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -238,7 +238,7 @@ static int __devexit ahci_remove(struct platform_device *pdev)
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 static int ahci_suspend(struct device *dev)
 {
 	struct ahci_platform_data *pdata = dev_get_platdata(dev);

commit f1e70c2c535923de253eea2021376a936eb8d478
Author: Viresh Kumar <viresh.kumar@linaro.com>
Date:   Mon Aug 27 10:37:19 2012 +0530

    ata/ahci_platform: Add clock framework support
    
    On many architectures, drivers are supposed to prepare/unprepare &
    enable/disable functional clock of device. This patch adds clock support for
    ahci_platform.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index dc187c746649..b1ae48054dc5 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -12,6 +12,7 @@
  * any later version.
  */
 
+#include <linux/clk.h>
 #include <linux/kernel.h>
 #include <linux/gfp.h>
 #include <linux/module.h>
@@ -118,6 +119,17 @@ static int __init ahci_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	}
 
+	hpriv->clk = clk_get(dev, NULL);
+	if (IS_ERR(hpriv->clk)) {
+		dev_err(dev, "can't get clock\n");
+	} else {
+		rc = clk_prepare_enable(hpriv->clk);
+		if (rc) {
+			dev_err(dev, "clock prepare enable failed");
+			goto free_clk;
+		}
+	}
+
 	/*
 	 * Some platforms might need to prepare for mmio region access,
 	 * which could be done in the following init call. So, the mmio
@@ -127,7 +139,7 @@ static int __init ahci_probe(struct platform_device *pdev)
 	if (pdata && pdata->init) {
 		rc = pdata->init(dev, hpriv->mmio);
 		if (rc)
-			return rc;
+			goto disable_unprepare_clk;
 	}
 
 	ahci_save_initial_config(dev, hpriv,
@@ -153,7 +165,7 @@ static int __init ahci_probe(struct platform_device *pdev)
 	host = ata_host_alloc_pinfo(dev, ppi, n_ports);
 	if (!host) {
 		rc = -ENOMEM;
-		goto err0;
+		goto pdata_exit;
 	}
 
 	host->private_data = hpriv;
@@ -183,7 +195,7 @@ static int __init ahci_probe(struct platform_device *pdev)
 
 	rc = ahci_reset_controller(host);
 	if (rc)
-		goto err0;
+		goto pdata_exit;
 
 	ahci_init_controller(host);
 	ahci_print_info(host, "platform");
@@ -191,12 +203,18 @@ static int __init ahci_probe(struct platform_device *pdev)
 	rc = ata_host_activate(host, irq, ahci_interrupt, IRQF_SHARED,
 			       &ahci_platform_sht);
 	if (rc)
-		goto err0;
+		goto pdata_exit;
 
 	return 0;
-err0:
+pdata_exit:
 	if (pdata && pdata->exit)
 		pdata->exit(dev);
+disable_unprepare_clk:
+	if (!IS_ERR(hpriv->clk))
+		clk_disable_unprepare(hpriv->clk);
+free_clk:
+	if (!IS_ERR(hpriv->clk))
+		clk_put(hpriv->clk);
 	return rc;
 }
 
@@ -205,12 +223,18 @@ static int __devexit ahci_remove(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct ahci_platform_data *pdata = dev_get_platdata(dev);
 	struct ata_host *host = dev_get_drvdata(dev);
+	struct ahci_host_priv *hpriv = host->private_data;
 
 	ata_host_detach(host);
 
 	if (pdata && pdata->exit)
 		pdata->exit(dev);
 
+	if (!IS_ERR(hpriv->clk)) {
+		clk_disable_unprepare(hpriv->clk);
+		clk_put(hpriv->clk);
+	}
+
 	return 0;
 }
 
@@ -245,6 +269,10 @@ static int ahci_suspend(struct device *dev)
 
 	if (pdata && pdata->suspend)
 		return pdata->suspend(dev);
+
+	if (!IS_ERR(hpriv->clk))
+		clk_disable_unprepare(hpriv->clk);
+
 	return 0;
 }
 
@@ -252,18 +280,27 @@ static int ahci_resume(struct device *dev)
 {
 	struct ahci_platform_data *pdata = dev_get_platdata(dev);
 	struct ata_host *host = dev_get_drvdata(dev);
+	struct ahci_host_priv *hpriv = host->private_data;
 	int rc;
 
+	if (!IS_ERR(hpriv->clk)) {
+		rc = clk_prepare_enable(hpriv->clk);
+		if (rc) {
+			dev_err(dev, "clock prepare enable failed");
+			return rc;
+		}
+	}
+
 	if (pdata && pdata->resume) {
 		rc = pdata->resume(dev);
 		if (rc)
-			return rc;
+			goto disable_unprepare_clk;
 	}
 
 	if (dev->power.power_state.event == PM_EVENT_SUSPEND) {
 		rc = ahci_reset_controller(host);
 		if (rc)
-			return rc;
+			goto disable_unprepare_clk;
 
 		ahci_init_controller(host);
 	}
@@ -271,6 +308,12 @@ static int ahci_resume(struct device *dev)
 	ata_host_resume(host);
 
 	return 0;
+
+disable_unprepare_clk:
+	if (!IS_ERR(hpriv->clk))
+		clk_disable_unprepare(hpriv->clk);
+
+	return rc;
 }
 #endif
 

commit 8996b89d6bc98ae2f6d6e6e624a42a3f89d06949
Author: Mark Langsdorf <mark.langsdorf@calxeda.com>
Date:   Thu Sep 6 16:03:30 2012 -0500

    ata: add platform driver for Calxeda AHCI controller
    
    Calxeda highbank SATA phy has intermittent problems bringing up a link
    with Gen3 drives. Retrying the phy hard reset can work-around this issue,
    but each reset also disables spread spectrum support. The reset function
    also needs to reprogram the phy to enable spread spectrum support.
    
    Create a new driver based on ahci_platform to support the Calxeda Highbank
    SATA controller.
    
    Signed-off-by: Mark Langsdorf <mark.langsdorf@calxeda.com>
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 09728e09cb31..dc187c746649 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -277,7 +277,6 @@ static int ahci_resume(struct device *dev)
 SIMPLE_DEV_PM_OPS(ahci_pm_ops, ahci_suspend, ahci_resume);
 
 static const struct of_device_id ahci_of_match[] = {
-	{ .compatible = "calxeda,hb-ahci", },
 	{ .compatible = "snps,spear-ahci", },
 	{},
 };

commit 18c25ff457d1f035361cfea2cd8c7d1d477d2221
Author: Shiraz Hashim <shiraz.hashim@st.com>
Date:   Fri Mar 16 15:49:55 2012 +0530

    ahci_platform: add hibernation callbacks
    
    Use existing suspend, resume implementation for hibernation callbacks.
    
    Signed-off-by: Shiraz Hashim <shiraz.hashim@st.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 9e419e1c2006..09728e09cb31 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -15,6 +15,7 @@
 #include <linux/kernel.h>
 #include <linux/gfp.h>
 #include <linux/module.h>
+#include <linux/pm.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/device.h>
@@ -271,13 +272,10 @@ static int ahci_resume(struct device *dev)
 
 	return 0;
 }
-
-static struct dev_pm_ops ahci_pm_ops = {
-	.suspend		= &ahci_suspend,
-	.resume			= &ahci_resume,
-};
 #endif
 
+SIMPLE_DEV_PM_OPS(ahci_pm_ops, ahci_suspend, ahci_resume);
+
 static const struct of_device_id ahci_of_match[] = {
 	{ .compatible = "calxeda,hb-ahci", },
 	{ .compatible = "snps,spear-ahci", },
@@ -291,9 +289,7 @@ static struct platform_driver ahci_driver = {
 		.name = "ahci",
 		.owner = THIS_MODULE,
 		.of_match_table = ahci_of_match,
-#ifdef CONFIG_PM
 		.pm = &ahci_pm_ops,
-#endif
 	},
 	.id_table	= ahci_devtype,
 };

commit 5f098a3ea72e73ad3733c3280fd5ee04816dc999
Author: Viresh Kumar <viresh.linux@gmail.com>
Date:   Sat Apr 21 17:40:12 2012 +0530

    ata: ahci_platform: Add synopsys ahci controller in DT's compatible list
    
    SPEAr13xx series of SoCs contain Synopsys AHCI SATA Controller which shares
    ahci_platform driver with other controller versions.
    
    This patch updates DT compatible list for ahci_platform. It also updates and
    renames binding documentation to more generic name.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@st.com>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 0c86c77764bc..9e419e1c2006 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -280,6 +280,7 @@ static struct dev_pm_ops ahci_pm_ops = {
 
 static const struct of_device_id ahci_of_match[] = {
 	{ .compatible = "calxeda,hb-ahci", },
+	{ .compatible = "snps,spear-ahci", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, ahci_of_match);

commit d408e2b14fba4fa214fa5bc24b7baae8a55e563c
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Feb 21 10:38:44 2012 -0800

    ahci_platform: add STRICT_AHCI platform type
    
    Some platforms need to make use of the AHCI_HFLAG_DELAY_ENGINE flag.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Cc: stable@kernel.org

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 48be4e189163..0c86c77764bc 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -26,6 +26,7 @@
 enum ahci_type {
 	AHCI,		/* standard platform ahci */
 	IMX53_AHCI,	/* ahci on i.mx53 */
+	STRICT_AHCI,	/* delayed DMA engine start */
 };
 
 static struct platform_device_id ahci_devtype[] = {
@@ -35,6 +36,9 @@ static struct platform_device_id ahci_devtype[] = {
 	}, {
 		.name = "imx53-ahci",
 		.driver_data = IMX53_AHCI,
+	}, {
+		.name = "strict-ahci",
+		.driver_data = STRICT_AHCI,
 	}, {
 		/* sentinel */
 	}
@@ -56,6 +60,13 @@ static const struct ata_port_info ahci_port_info[] = {
 		.udma_mask	= ATA_UDMA6,
 		.port_ops	= &ahci_pmp_retry_srst_ops,
 	},
+	[STRICT_AHCI] = {
+		AHCI_HFLAGS	(AHCI_HFLAG_DELAY_ENGINE),
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_ops,
+	},
 };
 
 static struct scsi_host_template ahci_platform_sht = {

commit 17ab594fa5f6c766a3daf304d2e6b643f863c24c
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Nov 18 11:10:10 2011 -0800

    ahci: platform support for suspend/resume
    
    Add platform hooks for custom suspend() and resume() functions. The
    generic suspend/resume code in drivers/ata/ahci_platform.c is adapted
    from the PCI version in drivers/ata/ahci.c.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 43b875810d1b..48be4e189163 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -202,6 +202,71 @@ static int __devexit ahci_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#ifdef CONFIG_PM
+static int ahci_suspend(struct device *dev)
+{
+	struct ahci_platform_data *pdata = dev_get_platdata(dev);
+	struct ata_host *host = dev_get_drvdata(dev);
+	struct ahci_host_priv *hpriv = host->private_data;
+	void __iomem *mmio = hpriv->mmio;
+	u32 ctl;
+	int rc;
+
+	if (hpriv->flags & AHCI_HFLAG_NO_SUSPEND) {
+		dev_err(dev, "firmware update required for suspend/resume\n");
+		return -EIO;
+	}
+
+	/*
+	 * AHCI spec rev1.1 section 8.3.3:
+	 * Software must disable interrupts prior to requesting a
+	 * transition of the HBA to D3 state.
+	 */
+	ctl = readl(mmio + HOST_CTL);
+	ctl &= ~HOST_IRQ_EN;
+	writel(ctl, mmio + HOST_CTL);
+	readl(mmio + HOST_CTL); /* flush */
+
+	rc = ata_host_suspend(host, PMSG_SUSPEND);
+	if (rc)
+		return rc;
+
+	if (pdata && pdata->suspend)
+		return pdata->suspend(dev);
+	return 0;
+}
+
+static int ahci_resume(struct device *dev)
+{
+	struct ahci_platform_data *pdata = dev_get_platdata(dev);
+	struct ata_host *host = dev_get_drvdata(dev);
+	int rc;
+
+	if (pdata && pdata->resume) {
+		rc = pdata->resume(dev);
+		if (rc)
+			return rc;
+	}
+
+	if (dev->power.power_state.event == PM_EVENT_SUSPEND) {
+		rc = ahci_reset_controller(host);
+		if (rc)
+			return rc;
+
+		ahci_init_controller(host);
+	}
+
+	ata_host_resume(host);
+
+	return 0;
+}
+
+static struct dev_pm_ops ahci_pm_ops = {
+	.suspend		= &ahci_suspend,
+	.resume			= &ahci_resume,
+};
+#endif
+
 static const struct of_device_id ahci_of_match[] = {
 	{ .compatible = "calxeda,hb-ahci", },
 	{},
@@ -214,6 +279,9 @@ static struct platform_driver ahci_driver = {
 		.name = "ahci",
 		.owner = THIS_MODULE,
 		.of_match_table = ahci_of_match,
+#ifdef CONFIG_PM
+		.pm = &ahci_pm_ops,
+#endif
 	},
 	.id_table	= ahci_devtype,
 };

commit ff956135008bca99b5e38f48f0d10a2c04fef2d6
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Tue Nov 15 21:00:56 2011 -0600

    [libata] ahci_platform: fix DT probing
    
    The change in commit 904c04feaf13ed "ahci_platform: Add the board_ids..."
    doesn't work for the DT probing case as platform_get_device_id returns
    NULL. Pick the default ahci_port_info in this case.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Anton Vorontsov <cbouatmailru@gmail.com>
    Cc: Richard Zhu <richard.zhu@linaro.org>
    Cc: linux-ide@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index ec555951176e..43b875810d1b 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -67,7 +67,7 @@ static int __init ahci_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct ahci_platform_data *pdata = dev_get_platdata(dev);
 	const struct platform_device_id *id = platform_get_device_id(pdev);
-	struct ata_port_info pi = ahci_port_info[id->driver_data];
+	struct ata_port_info pi = ahci_port_info[id ? id->driver_data : 0];
 	const struct ata_port_info *ppi[] = { &pi, NULL };
 	struct ahci_host_priv *hpriv;
 	struct ata_host *host;

commit 003456145f0d23b73f080abd1fd7981788438693
Author: JiSheng Zhang <jszhang3@gmail.com>
Date:   Mon Oct 31 21:20:10 2011 +0800

    ahci_platform: use dev_get_platdata()
    
    Use dev_get_platdata() to retrieve the struct ahci_platform_data data
    from the platform.
    
    Signed-off-by: JiSheng Zhang <jszhang3@gmail.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 004f2ce3dc73..ec555951176e 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -65,7 +65,7 @@ static struct scsi_host_template ahci_platform_sht = {
 static int __init ahci_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
-	struct ahci_platform_data *pdata = dev->platform_data;
+	struct ahci_platform_data *pdata = dev_get_platdata(dev);
 	const struct platform_device_id *id = platform_get_device_id(pdev);
 	struct ata_port_info pi = ahci_port_info[id->driver_data];
 	const struct ata_port_info *ppi[] = { &pi, NULL };
@@ -191,7 +191,7 @@ static int __init ahci_probe(struct platform_device *pdev)
 static int __devexit ahci_remove(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
-	struct ahci_platform_data *pdata = dev->platform_data;
+	struct ahci_platform_data *pdata = dev_get_platdata(dev);
 	struct ata_host *host = dev_get_drvdata(dev);
 
 	ata_host_detach(host);

commit 02aac316abf436a7529d46a71f7083f9f9ef4b49
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Wed Nov 3 21:04:59 2010 -0500

    ahci: add DT binding for Calxeda AHCI controller
    
    Add devicetree match table to ahci platform driver for Calxeda Highbank
    AHCI controller.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Cc: linux-ide@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: devicetree-discuss@lists.ozlabs.org

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index c03277d37748..004f2ce3dc73 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -202,11 +202,18 @@ static int __devexit ahci_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct of_device_id ahci_of_match[] = {
+	{ .compatible = "calxeda,hb-ahci", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ahci_of_match);
+
 static struct platform_driver ahci_driver = {
 	.remove = __devexit_p(ahci_remove),
 	.driver = {
 		.name = "ahci",
 		.owner = THIS_MODULE,
+		.of_match_table = ahci_of_match,
 	},
 	.id_table	= ahci_devtype,
 };

commit 904c04feaf13ed58790a34a0b11cd7b885b94b4b
Author: Richard Zhu <richard.zhu@linaro.org>
Date:   Wed Sep 28 15:41:54 2011 +0800

    [libata] ahci_platform: Add the board_ids and pi refer to different features
    
    On imx53 AHCI, soft reset fails with IPMS set when PMP
    is enabled but SATA HDD/ODD is connected to SATA port,
    do soft reset again to port 0.
    So the 'ahci_pmp_retry_srst_ops' is required when imx53
    ahci is present.
    
    Signed-off-by: Richard Zhu <richard.zhu@linaro.org>
    Acked-by: Eric Miao <eric.miao@linaro.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 6fef1fa75c54..c03277d37748 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -23,6 +23,41 @@
 #include <linux/ahci_platform.h>
 #include "ahci.h"
 
+enum ahci_type {
+	AHCI,		/* standard platform ahci */
+	IMX53_AHCI,	/* ahci on i.mx53 */
+};
+
+static struct platform_device_id ahci_devtype[] = {
+	{
+		.name = "ahci",
+		.driver_data = AHCI,
+	}, {
+		.name = "imx53-ahci",
+		.driver_data = IMX53_AHCI,
+	}, {
+		/* sentinel */
+	}
+};
+MODULE_DEVICE_TABLE(platform, ahci_devtype);
+
+
+static const struct ata_port_info ahci_port_info[] = {
+	/* by features */
+	[AHCI] = {
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_ops,
+	},
+	[IMX53_AHCI] = {
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_pmp_retry_srst_ops,
+	},
+};
+
 static struct scsi_host_template ahci_platform_sht = {
 	AHCI_SHT("ahci_platform"),
 };
@@ -31,12 +66,8 @@ static int __init ahci_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct ahci_platform_data *pdata = dev->platform_data;
-	struct ata_port_info pi = {
-		.flags		= AHCI_FLAG_COMMON,
-		.pio_mask	= ATA_PIO4,
-		.udma_mask	= ATA_UDMA6,
-		.port_ops	= &ahci_ops,
-	};
+	const struct platform_device_id *id = platform_get_device_id(pdev);
+	struct ata_port_info pi = ahci_port_info[id->driver_data];
 	const struct ata_port_info *ppi[] = { &pi, NULL };
 	struct ahci_host_priv *hpriv;
 	struct ata_host *host;
@@ -177,6 +208,7 @@ static struct platform_driver ahci_driver = {
 		.name = "ahci",
 		.owner = THIS_MODULE,
 	},
+	.id_table	= ahci_devtype,
 };
 
 static int __init ahci_init(void)

commit 6b7ae9545ad9875a289f4191c0216b473e313cb9
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 1 17:50:06 2010 +0200

    libata: reimplement link power management
    
    The current LPM implementation has the following issues.
    
    * Operation order isn't well thought-out.  e.g. HIPM should be
      configured after IPM in SControl is properly configured.  Not the
      other way around.
    
    * Suspend/resume paths call ata_lpm_enable/disable() which must only
      be called from EH context directly.  Also, ata_lpm_enable/disable()
      were called whether LPM was in use or not.
    
    * Implementation is per-port when it should be per-link.  As a result,
      it can't be used for controllers with slave links or PMP.
    
    * LPM state isn't managed consistently.  After a link reset for
      whatever reason including suspend/resume the actual LPM state would
      be reset leaving ap->lpm_policy inconsistent.
    
    * Generic/driver-specific logic boundary isn't clear.  Currently,
      libahci has to mangle stuff which libata EH proper should be
      handling.  This makes the implementation unnecessarily complex and
      fragile.
    
    * Tied to ALPM.  Doesn't consider DIPM only cases and doesn't check
      whether the device allows HIPM.
    
    * Error handling isn't implemented.
    
    Given the extent of mismatch with the rest of libata, I don't think
    trying to fix it piecewise makes much sense.  This patch reimplements
    LPM support.
    
    * The new implementation is per-link.  The target policy is still
      port-wide (ap->target_lpm_policy) but all the mechanisms and states
      are per-link and integrate well with the rest of link abstraction
      and can work with slave and PMP links.
    
    * Core EH has proper control of LPM state.  LPM state is reconfigured
      when and only when reconfiguration is necessary.  It makes sure that
      LPM state is reset when probing for new device on the link.
      Controller agnostic logic is now implemented in libata EH proper and
      driver implementation only has to deal with controller specifics.
    
    * Proper error handling.  LPM config failure is attributed to the
      device on the link and LPM is disabled for the link if it fails
      repeatedly.
    
    * ops->enable/disable_pm() are replaced with single ops->set_lpm()
      which takes @policy and @hints.  This simplifies driver specific
      implementation.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 07556853c0d6..6fef1fa75c54 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -129,9 +129,6 @@ static int __init ahci_probe(struct platform_device *pdev)
 		ata_port_desc(ap, "mmio %pR", mem);
 		ata_port_desc(ap, "port 0x%x", 0x100 + ap->port_no * 0x80);
 
-		/* set initial link pm policy */
-		ap->lpm_policy = ATA_LPM_UNKNOWN;
-
 		/* set enclosure management message type */
 		if (ap->flags & ATA_FLAG_EM)
 			ap->em_message_type = hpriv->em_msg_type;

commit c93b263e0d4fa8ce5fec0142a98196d1a127e845
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Sep 1 17:50:04 2010 +0200

    libata: clean up lpm related symbols and sysfs show/store functions
    
    Link power management related symbols are in confusing state w/ mixed
    usages of lpm, ipm and pm.  This patch cleans up lpm related symbols
    and sysfs show/store functions as follows.
    
    * lpm states - NOT_AVAILABLE, MIN_POWER, MAX_PERFORMANCE and
      MEDIUM_POWER are renamed to ATA_LPM_UNKNOWN and
      ATA_LPM_{MIN|MAX|MED}_POWER.
    
    * Pre/postfixes are unified to lpm.
    
    * sysfs show/store functions for link_power_management_policy were
      curiously named get/put and unnecessarily complex.  Renamed to
      show/store and simplified.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 84b643270e7a..07556853c0d6 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -130,7 +130,7 @@ static int __init ahci_probe(struct platform_device *pdev)
 		ata_port_desc(ap, "port 0x%x", 0x100 + ap->port_no * 0x80);
 
 		/* set initial link pm policy */
-		ap->pm_policy = NOT_AVAILABLE;
+		ap->lpm_policy = ATA_LPM_UNKNOWN;
 
 		/* set enclosure management message type */
 		if (ap->flags & ATA_FLAG_EM)

commit fad16e7a7f67eef8d33f8ad58850db89382b09ce
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Sep 21 09:25:48 2010 +0200

    ahci: fix module refcount breakage introduced by libahci split
    
    libata depends on scsi_host_template for module reference counting and
    sht's should be owned by each low level driver.  During libahci split,
    the sht was left with libahci.ko leaving the actual low level drivers
    not reference counted.  This made ahci and ahci_platform always
    unloadable even while they're being actively used.
    
    Fix it by defining AHCI_SHT() macro in ahci.h and defining a sht for
    each low level ahci driver.
    
    stable: only applicable to 2.6.35.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Reported-by: Pedro Francisco <pedrogfrancisco@gmail.com>
    Tested-by: Michael Tokarev <mjt@tls.msk.ru>
    Cc: stable@kernel.org
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 4e97f33cca44..84b643270e7a 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -23,6 +23,10 @@
 #include <linux/ahci_platform.h>
 #include "ahci.h"
 
+static struct scsi_host_template ahci_platform_sht = {
+	AHCI_SHT("ahci_platform"),
+};
+
 static int __init ahci_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -145,7 +149,7 @@ static int __init ahci_probe(struct platform_device *pdev)
 	ahci_print_info(host, "platform");
 
 	rc = ata_host_activate(host, irq, ahci_interrupt, IRQF_SHARED,
-			       &ahci_sht);
+			       &ahci_platform_sht);
 	if (rc)
 		goto err0;
 

commit da10a2002cf25a11f18fa1b5e327b9ed717f819c
Author: Anton Vorontsov <avorontsov@mvista.com>
Date:   Fri Jun 25 16:20:53 2010 +0400

    ahci_platform: Remove unneeded ahci_driver.probe assignment
    
    The driver is using platform_driver_probe() during initialization,
    so ahci_driver.probe hook is never used.
    
    But it causes the following (harmless, luckily) section mismatch:
    
      WARNING: vmlinux.o(.data+0x2fb20): Section mismatch in reference
      from the variable ahci_driver to the function .init.text:ahci_probe()
    
    This patch removes the ahci_driver.probe assignment, thus fixes
    the warning.
    
    p.s. Note that there's another patch[1] from Rene Bolldorf that
    tried to solve the same issue by __refdata annotation. __refdata
    says that this reference is actually OK, but in fact it is not OK,
    because dereferencing .probe() will cause problems. So the proper
    fix is to remove the assignment.
    
    [1] http://kerneltrap.org/mailarchive/linux-kernel/2010/3/18/4549547
    
    Signed-off-by: Anton Vorontsov <avorontsov@mvista.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 68ef6b563b7d..4e97f33cca44 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -171,7 +171,6 @@ static int __devexit ahci_remove(struct platform_device *pdev)
 }
 
 static struct platform_driver ahci_driver = {
-	.probe = ahci_probe,
 	.remove = __devexit_p(ahci_remove),
 	.driver = {
 		.name = "ahci",

commit 08354809d6c73eb73973e132502a0a4e53250971
Author: Jassi Brar <jassi.brar@samsung.com>
Date:   Fri Jun 25 18:21:19 2010 +0900

    ahci_platform: Provide for vendor specific init
    
    Some AHCI implementations may use Vendor Specific HBA[A0h, FFh]
    and/or Port[70h, 7Fh] registers to 'prepare' for initialization.
    For that, the platform needs memory mapped address of AHCI registers.
    
    This patch adds the 'mmio' argument and reorders the call to
    platform init function.
    
    Signed-off-by: Jassi Brar <jassi.brar@samsung.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 5e11b160f247..68ef6b563b7d 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -54,19 +54,13 @@ static int __init ahci_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
-	if (pdata && pdata->init) {
-		rc = pdata->init(dev);
-		if (rc)
-			return rc;
-	}
-
 	if (pdata && pdata->ata_port_info)
 		pi = *pdata->ata_port_info;
 
 	hpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);
 	if (!hpriv) {
-		rc = -ENOMEM;
-		goto err0;
+		dev_err(dev, "can't alloc ahci_host_priv\n");
+		return -ENOMEM;
 	}
 
 	hpriv->flags |= (unsigned long)pi.private_data;
@@ -74,8 +68,19 @@ static int __init ahci_probe(struct platform_device *pdev)
 	hpriv->mmio = devm_ioremap(dev, mem->start, resource_size(mem));
 	if (!hpriv->mmio) {
 		dev_err(dev, "can't map %pR\n", mem);
-		rc = -ENOMEM;
-		goto err0;
+		return -ENOMEM;
+	}
+
+	/*
+	 * Some platforms might need to prepare for mmio region access,
+	 * which could be done in the following init call. So, the mmio
+	 * region shouldn't be accessed before init (if provided) has
+	 * returned successfully.
+	 */
+	if (pdata && pdata->init) {
+		rc = pdata->init(dev, hpriv->mmio);
+		if (rc)
+			return rc;
 	}
 
 	ahci_save_initial_config(dev, hpriv,

commit 55787183ade44c4f826f581a068f52a1a80c6a2e
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri May 14 17:23:37 2010 -0400

    ahci_platform: properly set up EM messaging
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 19bfd1d76d40..5e11b160f247 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -125,7 +125,7 @@ static int __init ahci_probe(struct platform_device *pdev)
 
 		/* set enclosure management message type */
 		if (ap->flags & ATA_FLAG_EM)
-			ap->em_message_type = ahci_em_messages;
+			ap->em_message_type = hpriv->em_msg_type;
 
 		/* disabled/not-implemented port */
 		if (!(hpriv->port_map & (1 << i)))

commit fbaf666b854c04b2d8ebca17114ee409ddea08b5
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Mar 30 02:52:43 2010 +0900

    libata: update gfp/slab.h includes
    
    Implicit slab.h inclusion via percpu.h is about to go away.  Make sure
    gfp.h or slab.h is included as necessary.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
index 42cdd7363fad..19bfd1d76d40 100644
--- a/drivers/ata/ahci_platform.c
+++ b/drivers/ata/ahci_platform.c
@@ -13,6 +13,7 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/gfp.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>

commit 1c2a49f61785ebbcbfb481a2aab659020f0457f7
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Thu Mar 4 20:06:06 2010 +0300

    ahci: Add platform driver
    
    This can be used for AHCI-compatible interfaces implemented inside
    System-On-Chip solutions, or AHCI devices connected via localbus.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/ahci_platform.c b/drivers/ata/ahci_platform.c
new file mode 100644
index 000000000000..42cdd7363fad
--- /dev/null
+++ b/drivers/ata/ahci_platform.c
@@ -0,0 +1,191 @@
+/*
+ * AHCI SATA platform driver
+ *
+ * Copyright 2004-2005  Red Hat, Inc.
+ *   Jeff Garzik <jgarzik@pobox.com>
+ * Copyright 2010  MontaVista Software, LLC.
+ *   Anton Vorontsov <avorontsov@ru.mvista.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/libata.h>
+#include <linux/ahci_platform.h>
+#include "ahci.h"
+
+static int __init ahci_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct ahci_platform_data *pdata = dev->platform_data;
+	struct ata_port_info pi = {
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_ops,
+	};
+	const struct ata_port_info *ppi[] = { &pi, NULL };
+	struct ahci_host_priv *hpriv;
+	struct ata_host *host;
+	struct resource *mem;
+	int irq;
+	int n_ports;
+	int i;
+	int rc;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem) {
+		dev_err(dev, "no mmio space\n");
+		return -EINVAL;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq <= 0) {
+		dev_err(dev, "no irq\n");
+		return -EINVAL;
+	}
+
+	if (pdata && pdata->init) {
+		rc = pdata->init(dev);
+		if (rc)
+			return rc;
+	}
+
+	if (pdata && pdata->ata_port_info)
+		pi = *pdata->ata_port_info;
+
+	hpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);
+	if (!hpriv) {
+		rc = -ENOMEM;
+		goto err0;
+	}
+
+	hpriv->flags |= (unsigned long)pi.private_data;
+
+	hpriv->mmio = devm_ioremap(dev, mem->start, resource_size(mem));
+	if (!hpriv->mmio) {
+		dev_err(dev, "can't map %pR\n", mem);
+		rc = -ENOMEM;
+		goto err0;
+	}
+
+	ahci_save_initial_config(dev, hpriv,
+		pdata ? pdata->force_port_map : 0,
+		pdata ? pdata->mask_port_map  : 0);
+
+	/* prepare host */
+	if (hpriv->cap & HOST_CAP_NCQ)
+		pi.flags |= ATA_FLAG_NCQ;
+
+	if (hpriv->cap & HOST_CAP_PMP)
+		pi.flags |= ATA_FLAG_PMP;
+
+	ahci_set_em_messages(hpriv, &pi);
+
+	/* CAP.NP sometimes indicate the index of the last enabled
+	 * port, at other times, that of the last possible port, so
+	 * determining the maximum port number requires looking at
+	 * both CAP.NP and port_map.
+	 */
+	n_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));
+
+	host = ata_host_alloc_pinfo(dev, ppi, n_ports);
+	if (!host) {
+		rc = -ENOMEM;
+		goto err0;
+	}
+
+	host->private_data = hpriv;
+
+	if (!(hpriv->cap & HOST_CAP_SSS) || ahci_ignore_sss)
+		host->flags |= ATA_HOST_PARALLEL_SCAN;
+	else
+		printk(KERN_INFO "ahci: SSS flag set, parallel bus scan disabled\n");
+
+	if (pi.flags & ATA_FLAG_EM)
+		ahci_reset_em(host);
+
+	for (i = 0; i < host->n_ports; i++) {
+		struct ata_port *ap = host->ports[i];
+
+		ata_port_desc(ap, "mmio %pR", mem);
+		ata_port_desc(ap, "port 0x%x", 0x100 + ap->port_no * 0x80);
+
+		/* set initial link pm policy */
+		ap->pm_policy = NOT_AVAILABLE;
+
+		/* set enclosure management message type */
+		if (ap->flags & ATA_FLAG_EM)
+			ap->em_message_type = ahci_em_messages;
+
+		/* disabled/not-implemented port */
+		if (!(hpriv->port_map & (1 << i)))
+			ap->ops = &ata_dummy_port_ops;
+	}
+
+	rc = ahci_reset_controller(host);
+	if (rc)
+		goto err0;
+
+	ahci_init_controller(host);
+	ahci_print_info(host, "platform");
+
+	rc = ata_host_activate(host, irq, ahci_interrupt, IRQF_SHARED,
+			       &ahci_sht);
+	if (rc)
+		goto err0;
+
+	return 0;
+err0:
+	if (pdata && pdata->exit)
+		pdata->exit(dev);
+	return rc;
+}
+
+static int __devexit ahci_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct ahci_platform_data *pdata = dev->platform_data;
+	struct ata_host *host = dev_get_drvdata(dev);
+
+	ata_host_detach(host);
+
+	if (pdata && pdata->exit)
+		pdata->exit(dev);
+
+	return 0;
+}
+
+static struct platform_driver ahci_driver = {
+	.probe = ahci_probe,
+	.remove = __devexit_p(ahci_remove),
+	.driver = {
+		.name = "ahci",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init ahci_init(void)
+{
+	return platform_driver_probe(&ahci_driver, ahci_probe);
+}
+module_init(ahci_init);
+
+static void __exit ahci_exit(void)
+{
+	platform_driver_unregister(&ahci_driver);
+}
+module_exit(ahci_exit);
+
+MODULE_DESCRIPTION("AHCI SATA platform driver");
+MODULE_AUTHOR("Anton Vorontsov <avorontsov@ru.mvista.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:ahci");
