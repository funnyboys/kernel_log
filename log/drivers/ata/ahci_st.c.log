commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/ata/ahci_st.c b/drivers/ata/ahci_st.c
index 21c5c44832ef..c268264c2129 100644
--- a/drivers/ata/ahci_st.c
+++ b/drivers/ata/ahci_st.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2012 STMicroelectronics Limited
  *
  * Authors: Francesco Virlinzi <francesco.virlinzi@st.com>
  *	    Alexandre Torgue <alexandre.torgue@st.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/init.h>

commit 16af2d65842d343c2f95733c3993a0b5baab08f9
Author: Kunihiko Hayashi <hayashi.kunihiko@socionext.com>
Date:   Wed Aug 22 21:13:01 2018 +0900

    ata: add an extra argument to ahci_platform_get_resources()
    
    Add an extra argument to ahci_platform_get_resources(), that is
    for the bitmap representing the resource to get in this function.
    
    Currently there is no resources to be defined, so all the callers set
    '0' to the argument.
    
    Suggested-by: Hans de Goede <hdegoede@redhat.com>
    Cc: Thierry Reding <thierry.reding@gmail.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Cc: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Kunihiko Hayashi <hayashi.kunihiko@socionext.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_st.c b/drivers/ata/ahci_st.c
index bc345f249555..21c5c44832ef 100644
--- a/drivers/ata/ahci_st.c
+++ b/drivers/ata/ahci_st.c
@@ -156,7 +156,7 @@ static int st_ahci_probe(struct platform_device *pdev)
 	if (!drv_data)
 		return -ENOMEM;
 
-	hpriv = ahci_platform_get_resources(pdev);
+	hpriv = ahci_platform_get_resources(pdev, 0);
 	if (IS_ERR(hpriv))
 		return PTR_ERR(hpriv);
 	hpriv->plat_data = drv_data;

commit e7190699ca8c8daa52bfc62c01a71dea6decc9ee
Author: Patrice Chotard <patrice.chotard@st.com>
Date:   Wed Aug 10 17:37:29 2016 +0200

    ahci: st: Add ports-implemented property in support
    
    Despite ST AHCI version = 1.3, reading HOST_PORTS_IMPL
    returns 0. So force_port_map to 1 by using ports-implemented
    DT property.
    
    Signed-off-by: Patrice Chotard <patrice.chotard@st.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_st.c b/drivers/ata/ahci_st.c
index 8ff428fe8e0f..bc345f249555 100644
--- a/drivers/ata/ahci_st.c
+++ b/drivers/ata/ahci_st.c
@@ -147,6 +147,7 @@ static struct scsi_host_template ahci_platform_sht = {
 
 static int st_ahci_probe(struct platform_device *pdev)
 {
+	struct device *dev = &pdev->dev;
 	struct st_ahci_drv_data *drv_data;
 	struct ahci_host_priv *hpriv;
 	int err;
@@ -170,6 +171,9 @@ static int st_ahci_probe(struct platform_device *pdev)
 
 	st_ahci_configure_oob(hpriv->mmio);
 
+	of_property_read_u32(dev->of_node,
+			     "ports-implemented", &hpriv->force_port_map);
+
 	err = ahci_platform_init_host(pdev, hpriv, &st_ahci_port_info,
 				      &ahci_platform_sht);
 	if (err) {

commit e0e2674b92056c24c69940d5f405ea4aef5e4010
Author: Peter Griffin <peter.griffin@linaro.org>
Date:   Mon Apr 20 14:41:05 2015 +0100

    ata: ahci_st: fixup layering violations / drvdata errors
    
    Brian noticed while working on another SATA driver that uses libahci_platform,
    an error in this driver; it tries to the the driver data for its
    device, while libata also thinks it can set the driver data. See:
    
      ahci_platform_init_host()
      -> ata_host_alloc_pinfo()
         -> ata_host_alloc()
            -> dev_set_drvdata()
    
    So instead of sticking the IP-specific platform data into drvdata, let's
    use the plat_data variable that is reserved for this use.
    
    Addtionally plat_data isn't set until ahci_platform_init_host() has been
    called further down in probe(). So re-work the st_ahci_probe_resets and
    st_ahci_deassert_resets functions to take ahci_host_priv *hpriv as a
    parameter.
    
    Signed-off-by: Peter Griffin <peter.griffin@linaro.org>
    Suggested-by: Brian Norris <computersforpeace@gmail.com>
    Cc: Srinivas Kandagatla <srinivas.kandagatla@gmail.com>
    Cc: Maxime Coquelin <maxime.coquelin@st.com>
    Cc: Patrice Chotard <patrice.chotard@st.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_st.c b/drivers/ata/ahci_st.c
index ea0ff005b86c..8ff428fe8e0f 100644
--- a/drivers/ata/ahci_st.c
+++ b/drivers/ata/ahci_st.c
@@ -37,7 +37,6 @@ struct st_ahci_drv_data {
 	struct reset_control *pwr;
 	struct reset_control *sw_rst;
 	struct reset_control *pwr_rst;
-	struct ahci_host_priv *hpriv;
 };
 
 static void st_ahci_configure_oob(void __iomem *mmio)
@@ -55,9 +54,10 @@ static void st_ahci_configure_oob(void __iomem *mmio)
 	writel(new_val, mmio + ST_AHCI_OOBR);
 }
 
-static int st_ahci_deassert_resets(struct device *dev)
+static int st_ahci_deassert_resets(struct ahci_host_priv *hpriv,
+				struct device *dev)
 {
-	struct st_ahci_drv_data *drv_data = dev_get_drvdata(dev);
+	struct st_ahci_drv_data *drv_data = hpriv->plat_data;
 	int err;
 
 	if (drv_data->pwr) {
@@ -90,8 +90,8 @@ static int st_ahci_deassert_resets(struct device *dev)
 static void st_ahci_host_stop(struct ata_host *host)
 {
 	struct ahci_host_priv *hpriv = host->private_data;
+	struct st_ahci_drv_data *drv_data = hpriv->plat_data;
 	struct device *dev = host->dev;
-	struct st_ahci_drv_data *drv_data = dev_get_drvdata(dev);
 	int err;
 
 	if (drv_data->pwr) {
@@ -103,29 +103,30 @@ static void st_ahci_host_stop(struct ata_host *host)
 	ahci_platform_disable_resources(hpriv);
 }
 
-static int st_ahci_probe_resets(struct platform_device *pdev)
+static int st_ahci_probe_resets(struct ahci_host_priv *hpriv,
+				struct device *dev)
 {
-	struct st_ahci_drv_data *drv_data = platform_get_drvdata(pdev);
+	struct st_ahci_drv_data *drv_data = hpriv->plat_data;
 
-	drv_data->pwr = devm_reset_control_get(&pdev->dev, "pwr-dwn");
+	drv_data->pwr = devm_reset_control_get(dev, "pwr-dwn");
 	if (IS_ERR(drv_data->pwr)) {
-		dev_info(&pdev->dev, "power reset control not defined\n");
+		dev_info(dev, "power reset control not defined\n");
 		drv_data->pwr = NULL;
 	}
 
-	drv_data->sw_rst = devm_reset_control_get(&pdev->dev, "sw-rst");
+	drv_data->sw_rst = devm_reset_control_get(dev, "sw-rst");
 	if (IS_ERR(drv_data->sw_rst)) {
-		dev_info(&pdev->dev, "soft reset control not defined\n");
+		dev_info(dev, "soft reset control not defined\n");
 		drv_data->sw_rst = NULL;
 	}
 
-	drv_data->pwr_rst = devm_reset_control_get(&pdev->dev, "pwr-rst");
+	drv_data->pwr_rst = devm_reset_control_get(dev, "pwr-rst");
 	if (IS_ERR(drv_data->pwr_rst)) {
-		dev_dbg(&pdev->dev, "power soft reset control not defined\n");
+		dev_dbg(dev, "power soft reset control not defined\n");
 		drv_data->pwr_rst = NULL;
 	}
 
-	return st_ahci_deassert_resets(&pdev->dev);
+	return st_ahci_deassert_resets(hpriv, dev);
 }
 
 static struct ata_port_operations st_ahci_port_ops = {
@@ -154,15 +155,12 @@ static int st_ahci_probe(struct platform_device *pdev)
 	if (!drv_data)
 		return -ENOMEM;
 
-	platform_set_drvdata(pdev, drv_data);
-
 	hpriv = ahci_platform_get_resources(pdev);
 	if (IS_ERR(hpriv))
 		return PTR_ERR(hpriv);
+	hpriv->plat_data = drv_data;
 
-	drv_data->hpriv = hpriv;
-
-	err = st_ahci_probe_resets(pdev);
+	err = st_ahci_probe_resets(hpriv, &pdev->dev);
 	if (err)
 		return err;
 
@@ -170,7 +168,7 @@ static int st_ahci_probe(struct platform_device *pdev)
 	if (err)
 		return err;
 
-	st_ahci_configure_oob(drv_data->hpriv->mmio);
+	st_ahci_configure_oob(hpriv->mmio);
 
 	err = ahci_platform_init_host(pdev, hpriv, &st_ahci_port_info,
 				      &ahci_platform_sht);
@@ -185,8 +183,9 @@ static int st_ahci_probe(struct platform_device *pdev)
 #ifdef CONFIG_PM_SLEEP
 static int st_ahci_suspend(struct device *dev)
 {
-	struct st_ahci_drv_data *drv_data = dev_get_drvdata(dev);
-	struct ahci_host_priv *hpriv = drv_data->hpriv;
+	struct ata_host *host = dev_get_drvdata(dev);
+	struct ahci_host_priv *hpriv = host->private_data;
+	struct st_ahci_drv_data *drv_data = hpriv->plat_data;
 	int err;
 
 	err = ahci_platform_suspend_host(dev);
@@ -208,21 +207,21 @@ static int st_ahci_suspend(struct device *dev)
 
 static int st_ahci_resume(struct device *dev)
 {
-	struct st_ahci_drv_data *drv_data = dev_get_drvdata(dev);
-	struct ahci_host_priv *hpriv = drv_data->hpriv;
+	struct ata_host *host = dev_get_drvdata(dev);
+	struct ahci_host_priv *hpriv = host->private_data;
 	int err;
 
 	err = ahci_platform_enable_resources(hpriv);
 	if (err)
 		return err;
 
-	err = st_ahci_deassert_resets(dev);
+	err = st_ahci_deassert_resets(hpriv, dev);
 	if (err) {
 		ahci_platform_disable_resources(hpriv);
 		return err;
 	}
 
-	st_ahci_configure_oob(drv_data->hpriv->mmio);
+	st_ahci_configure_oob(hpriv->mmio);
 
 	return ahci_platform_resume_host(dev);
 }

commit 9a1e75e11a8d09c5cba022e1ac04b0785354f708
Author: Peter Griffin <peter.griffin@linaro.org>
Date:   Tue Mar 31 08:35:09 2015 +0100

    ahci: st: st_configure_oob must be called after IP is clocked.
    
    Currently the ahci_st driver will hang the system on probe, as the
    st_configure_oob function does some register writes before the IP
    is clocked. This patch moves the function call to after
    ahci_platform_enable_resources (which enables the IP clock), and
    resolves the hang.
    
    Addtionally st_ahci_configure_oob should be called in the st_ahci_resume
    function, so we also rectify that ensuring it is also called after
    the IP clock has been enabled.
    
    Signed-off-by: Peter Griffin <peter.griffin@linaro.org>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Maxime Coquelin <maxime.coquelin@st.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_st.c b/drivers/ata/ahci_st.c
index bc971af262e7..ea0ff005b86c 100644
--- a/drivers/ata/ahci_st.c
+++ b/drivers/ata/ahci_st.c
@@ -68,8 +68,6 @@ static int st_ahci_deassert_resets(struct device *dev)
 		}
 	}
 
-	st_ahci_configure_oob(drv_data->hpriv->mmio);
-
 	if (drv_data->sw_rst) {
 		err = reset_control_deassert(drv_data->sw_rst);
 		if (err) {
@@ -172,6 +170,8 @@ static int st_ahci_probe(struct platform_device *pdev)
 	if (err)
 		return err;
 
+	st_ahci_configure_oob(drv_data->hpriv->mmio);
+
 	err = ahci_platform_init_host(pdev, hpriv, &st_ahci_port_info,
 				      &ahci_platform_sht);
 	if (err) {
@@ -222,6 +222,8 @@ static int st_ahci_resume(struct device *dev)
 		return err;
 	}
 
+	st_ahci_configure_oob(drv_data->hpriv->mmio);
+
 	return ahci_platform_resume_host(dev);
 }
 #endif

commit 018d5ef2048fcab339467bcbebccf588c9bd2531
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Thu Jan 29 08:30:29 2015 +0900

    ata: ahci_platform: fix owner module reference mismatch for scsi host
    
    The owner module reference of the ahci platform's scsi_host is
    initialized to libahci_platform's one, because these drivers use a
    scsi_host_template defined in libahci_platform.  So these drivers can
    be unloaded even if the scsi device is being accessed.
    
    This fixes it by pushing the scsi_host_template from libahci_platform
    to all leaf drivers.  The scsi_host_template is passed through a new
    argument of ahci_platform_init_host().
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Cc: linux-ide@vger.kernel.org
    Cc: linux-scsi@vger.kernel.org

diff --git a/drivers/ata/ahci_st.c b/drivers/ata/ahci_st.c
index 2f9e8317cc16..bc971af262e7 100644
--- a/drivers/ata/ahci_st.c
+++ b/drivers/ata/ahci_st.c
@@ -23,6 +23,8 @@
 
 #include "ahci.h"
 
+#define DRV_NAME  "st_ahci"
+
 #define ST_AHCI_OOBR			0xbc
 #define ST_AHCI_OOBR_WE			BIT(31)
 #define ST_AHCI_OOBR_CWMIN_SHIFT	24
@@ -140,6 +142,10 @@ static const struct ata_port_info st_ahci_port_info = {
 	.port_ops       = &st_ahci_port_ops,
 };
 
+static struct scsi_host_template ahci_platform_sht = {
+	AHCI_SHT(DRV_NAME),
+};
+
 static int st_ahci_probe(struct platform_device *pdev)
 {
 	struct st_ahci_drv_data *drv_data;
@@ -166,7 +172,8 @@ static int st_ahci_probe(struct platform_device *pdev)
 	if (err)
 		return err;
 
-	err = ahci_platform_init_host(pdev, hpriv, &st_ahci_port_info);
+	err = ahci_platform_init_host(pdev, hpriv, &st_ahci_port_info,
+				      &ahci_platform_sht);
 	if (err) {
 		ahci_platform_disable_resources(hpriv);
 		return err;
@@ -229,7 +236,7 @@ MODULE_DEVICE_TABLE(of, st_ahci_match);
 
 static struct platform_driver st_ahci_driver = {
 	.driver = {
-		.name = "st_ahci",
+		.name = DRV_NAME,
 		.pm = &st_ahci_pm_ops,
 		.of_match_table = of_match_ptr(st_ahci_match),
 	},

commit 65c662ab63d2055d883bc97386aa779cbbb81f93
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:17 2014 +0200

    ata: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/ata/ahci_st.c b/drivers/ata/ahci_st.c
index 835d6eea84fd..2f9e8317cc16 100644
--- a/drivers/ata/ahci_st.c
+++ b/drivers/ata/ahci_st.c
@@ -230,7 +230,6 @@ MODULE_DEVICE_TABLE(of, st_ahci_match);
 static struct platform_driver st_ahci_driver = {
 	.driver = {
 		.name = "st_ahci",
-		.owner = THIS_MODULE,
 		.pm = &st_ahci_pm_ops,
 		.of_match_table = of_match_ptr(st_ahci_match),
 	},

commit 725c7b570fda4207e465ff8856c2c12c2645a685
Author: Antoine Ténart <antoine.tenart@free-electrons.com>
Date:   Wed Jul 30 20:13:56 2014 +0200

    ata: libahci_platform: move port_map parameters into the AHCI structure
    
    This patch moves force_port_map and mask_port_map into the
    ahci_host_priv structure. This allows to modify them into the AHCI
    framework. This is needed by the new dt bindings representing ports as
    the port_map mask is computed automatically.
    
    Parameters modifying force_port_map, mask_port_map and flags have been
    removed from the ahci_platform_init_host() function, and inputs in the
    ahci_host_priv structure are now directly filed.
    
    Signed-off-by: Antoine Ténart <antoine.tenart@free-electrons.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_st.c b/drivers/ata/ahci_st.c
index 29821b9fd13d..835d6eea84fd 100644
--- a/drivers/ata/ahci_st.c
+++ b/drivers/ata/ahci_st.c
@@ -166,7 +166,7 @@ static int st_ahci_probe(struct platform_device *pdev)
 	if (err)
 		return err;
 
-	err = ahci_platform_init_host(pdev, hpriv, &st_ahci_port_info, 0, 0, 0);
+	err = ahci_platform_init_host(pdev, hpriv, &st_ahci_port_info);
 	if (err) {
 		ahci_platform_disable_resources(hpriv);
 		return err;

commit 09de99db23df55c7415d110f6c62281dedd77384
Author: Kiran Padwal <kiran.padwal21@gmail.com>
Date:   Tue Jul 22 19:45:43 2014 +0530

    ahci: st: Make of_device_id array const
    
    Make of_device_id array const, because all OF functions handle it as const.
    
    Signed-off-by: Kiran Padwal <kiran.padwal21@gmail.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_st.c b/drivers/ata/ahci_st.c
index 2595598df9ce..29821b9fd13d 100644
--- a/drivers/ata/ahci_st.c
+++ b/drivers/ata/ahci_st.c
@@ -221,7 +221,7 @@ static int st_ahci_resume(struct device *dev)
 
 static SIMPLE_DEV_PM_OPS(st_ahci_pm_ops, st_ahci_suspend, st_ahci_resume);
 
-static struct of_device_id st_ahci_match[] = {
+static const struct of_device_id st_ahci_match[] = {
 	{ .compatible = "st,ahci", },
 	{},
 };

commit f9f36917903b57c571b1ddcfc6bc794ca4dd8232
Author: Kefeng Wang <kefeng.wang@linaro.org>
Date:   Wed May 14 14:13:41 2014 +0800

    libahci_platform: add host_flags parameter in ahci_platform_init_host()
    
    Add a dynamic host_flags argument to make ahci_platform_init_host more flexible,
    then remove the AHCI_HFLAGS(...) argument from some driver's ata_port_info,
    and pass that in as the new argument.
    
    Cc: Hans de Geode <hdegoede@redhat.com>
    Reviewed-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Kefeng Wang <kefeng.wang@linaro.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_st.c b/drivers/ata/ahci_st.c
index 633222226c19..2595598df9ce 100644
--- a/drivers/ata/ahci_st.c
+++ b/drivers/ata/ahci_st.c
@@ -166,7 +166,7 @@ static int st_ahci_probe(struct platform_device *pdev)
 	if (err)
 		return err;
 
-	err = ahci_platform_init_host(pdev, hpriv, &st_ahci_port_info, 0, 0);
+	err = ahci_platform_init_host(pdev, hpriv, &st_ahci_port_info, 0, 0, 0);
 	if (err) {
 		ahci_platform_disable_resources(hpriv);
 		return err;

commit b032378b4c3ffba86d2c78699b385ae646397938
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Fri Mar 14 19:21:59 2014 +0100

    ata: ahci_st: remove deprecated struct ahci_platform_data usage
    
    struct ahci_platform_data is deprecated (please see comments in
    <linux/ahci_platform.h> for details).  Convert ahci_st driver to
    use custom ->host_stop method instead.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_st.c b/drivers/ata/ahci_st.c
index e1aa5447a400..633222226c19 100644
--- a/drivers/ata/ahci_st.c
+++ b/drivers/ata/ahci_st.c
@@ -87,10 +87,11 @@ static int st_ahci_deassert_resets(struct device *dev)
 	return 0;
 }
 
-static void st_ahci_exit(struct device *dev)
+static void st_ahci_host_stop(struct ata_host *host)
 {
+	struct ahci_host_priv *hpriv = host->private_data;
+	struct device *dev = host->dev;
 	struct st_ahci_drv_data *drv_data = dev_get_drvdata(dev);
-	struct ahci_host_priv *hpriv = drv_data->hpriv;
 	int err;
 
 	if (drv_data->pwr) {
@@ -127,17 +128,21 @@ static int st_ahci_probe_resets(struct platform_device *pdev)
 	return st_ahci_deassert_resets(&pdev->dev);
 }
 
+static struct ata_port_operations st_ahci_port_ops = {
+	.inherits	= &ahci_platform_ops,
+	.host_stop	= st_ahci_host_stop,
+};
+
 static const struct ata_port_info st_ahci_port_info = {
 	.flags          = AHCI_FLAG_COMMON,
 	.pio_mask       = ATA_PIO4,
 	.udma_mask      = ATA_UDMA6,
-	.port_ops       = &ahci_platform_ops,
+	.port_ops       = &st_ahci_port_ops,
 };
 
 static int st_ahci_probe(struct platform_device *pdev)
 {
 	struct st_ahci_drv_data *drv_data;
-	struct ahci_platform_data *pdata;
 	struct ahci_host_priv *hpriv;
 	int err;
 
@@ -147,13 +152,6 @@ static int st_ahci_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, drv_data);
 
-	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
-	if (!pdata)
-		return -ENOMEM;
-
-	pdata->exit = st_ahci_exit;
-	pdev->dev.platform_data = pdata;
-
 	hpriv = ahci_platform_get_resources(pdev);
 	if (IS_ERR(hpriv))
 		return PTR_ERR(hpriv);

commit 33081b34681742add8d8c1e49fc93045415e5a18
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Fri Mar 14 19:20:58 2014 +0100

    ata: ahci_st: build fixes
    
    * The config option for ahci_st driver was renamed from
      CONFIG_SATA_AHCI_ST to CONFIG_AHCI_ST but Makefile was
      not updated.  Fix it (also while at it move the ahci_st
      driver entry below ahci_imx and ahci_sunxi ones).
    
    * Fix a few build issues in the ahci_st driver itself.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_st.c b/drivers/ata/ahci_st.c
index 17191b96648e..e1aa5447a400 100644
--- a/drivers/ata/ahci_st.c
+++ b/drivers/ata/ahci_st.c
@@ -87,7 +87,7 @@ static int st_ahci_deassert_resets(struct device *dev)
 	return 0;
 }
 
-static int st_ahci_exit(struct device *dev)
+static void st_ahci_exit(struct device *dev)
 {
 	struct st_ahci_drv_data *drv_data = dev_get_drvdata(dev);
 	struct ahci_host_priv *hpriv = drv_data->hpriv;
@@ -96,12 +96,10 @@ static int st_ahci_exit(struct device *dev)
 	if (drv_data->pwr) {
 		err = reset_control_assert(drv_data->pwr);
 		if (err)
-			dev_err(&pdev->dev, "unable to pwrdwn\n");
+			dev_err(dev, "unable to pwrdwn\n");
 	}
 
 	ahci_platform_disable_resources(hpriv);
-
-	return 0;
 }
 
 static int st_ahci_probe_resets(struct platform_device *pdev)
@@ -186,9 +184,9 @@ static int st_ahci_suspend(struct device *dev)
 	struct ahci_host_priv *hpriv = drv_data->hpriv;
 	int err;
 
-	ret = ahci_platform_suspend_host(dev);
-	if (ret)
-		return ret;
+	err = ahci_platform_suspend_host(dev);
+	if (err)
+		return err;
 
 	if (drv_data->pwr) {
 		err = reset_control_assert(drv_data->pwr);

commit 761a8c2765df17ac5296e2631a16ec08d1a0cb1c
Author: Lee Jones <lee.jones@linaro.org>
Date:   Wed Mar 12 12:39:42 2014 +0000

    ahci: st: Invoke AHCI Platform Suspend/Resume
    
    This is where we disable IRQs on suspend and update the internal
    power state during suspend/resume.
    
    Suggested-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_st.c b/drivers/ata/ahci_st.c
index 3edec5db3717..17191b96648e 100644
--- a/drivers/ata/ahci_st.c
+++ b/drivers/ata/ahci_st.c
@@ -186,6 +186,10 @@ static int st_ahci_suspend(struct device *dev)
 	struct ahci_host_priv *hpriv = drv_data->hpriv;
 	int err;
 
+	ret = ahci_platform_suspend_host(dev);
+	if (ret)
+		return ret;
+
 	if (drv_data->pwr) {
 		err = reset_control_assert(drv_data->pwr);
 		if (err) {
@@ -215,7 +219,7 @@ static int st_ahci_resume(struct device *dev)
 		return err;
 	}
 
-	return 0;
+	return ahci_platform_resume_host(dev);
 }
 #endif
 

commit a82370842834875c81b482181af280353aa6be05
Author: Lee Jones <lee.jones@linaro.org>
Date:   Wed Mar 12 12:39:40 2014 +0000

    ahci: st: Utilise ata_platform_remove_one() call
    
    ata_platform_remove_one() allows us to specify our own exit function
    via platform data then goes off and removes ATA Host and Port in
    preparation for device removal.
    
    Suggested-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_st.c b/drivers/ata/ahci_st.c
index a28532aad97b..3edec5db3717 100644
--- a/drivers/ata/ahci_st.c
+++ b/drivers/ata/ahci_st.c
@@ -87,6 +87,23 @@ static int st_ahci_deassert_resets(struct device *dev)
 	return 0;
 }
 
+static int st_ahci_exit(struct device *dev)
+{
+	struct st_ahci_drv_data *drv_data = dev_get_drvdata(dev);
+	struct ahci_host_priv *hpriv = drv_data->hpriv;
+	int err;
+
+	if (drv_data->pwr) {
+		err = reset_control_assert(drv_data->pwr);
+		if (err)
+			dev_err(&pdev->dev, "unable to pwrdwn\n");
+	}
+
+	ahci_platform_disable_resources(hpriv);
+
+	return 0;
+}
+
 static int st_ahci_probe_resets(struct platform_device *pdev)
 {
 	struct st_ahci_drv_data *drv_data = platform_get_drvdata(pdev);
@@ -122,6 +139,7 @@ static const struct ata_port_info st_ahci_port_info = {
 static int st_ahci_probe(struct platform_device *pdev)
 {
 	struct st_ahci_drv_data *drv_data;
+	struct ahci_platform_data *pdata;
 	struct ahci_host_priv *hpriv;
 	int err;
 
@@ -131,6 +149,13 @@ static int st_ahci_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, drv_data);
 
+	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	pdata->exit = st_ahci_exit;
+	pdev->dev.platform_data = pdata;
+
 	hpriv = ahci_platform_get_resources(pdev);
 	if (IS_ERR(hpriv))
 		return PTR_ERR(hpriv);
@@ -154,23 +179,6 @@ static int st_ahci_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int st_ahci_remove(struct platform_device *pdev)
-{
-	struct st_ahci_drv_data *drv_data = platform_get_drvdata(pdev);
-	struct ahci_host_priv *hpriv = drv_data->hpriv;
-	int err;
-
-	if (drv_data->pwr) {
-		err = reset_control_assert(drv_data->pwr);
-		if (err)
-			dev_err(&pdev->dev, "unable to pwrdwn\n");
-	}
-
-	ahci_platform_disable_resources(hpriv);
-
-	return 0;
-}
-
 #ifdef CONFIG_PM_SLEEP
 static int st_ahci_suspend(struct device *dev)
 {
@@ -227,7 +235,7 @@ static struct platform_driver st_ahci_driver = {
 		.of_match_table = of_match_ptr(st_ahci_match),
 	},
 	.probe = st_ahci_probe,
-	.remove = st_ahci_remove,
+	.remove = ata_platform_remove_one,
 };
 module_platform_driver(st_ahci_driver);
 

commit c51a848973da8b347191c0e317da3b912c2cdb6a
Author: Lee Jones <lee.jones@linaro.org>
Date:   Wed Mar 12 12:39:39 2014 +0000

    ahci: st: Remove legacy dependencies on PHY
    
    Suggested-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_st.c b/drivers/ata/ahci_st.c
index f5af660835b0..a28532aad97b 100644
--- a/drivers/ata/ahci_st.c
+++ b/drivers/ata/ahci_st.c
@@ -16,7 +16,6 @@
 #include <linux/clk.h>
 #include <linux/of.h>
 #include <linux/ahci_platform.h>
-#include <linux/phy/phy.h>
 #include <linux/libata.h>
 #include <linux/reset.h>
 #include <linux/io.h>
@@ -33,7 +32,6 @@
 
 struct st_ahci_drv_data {
 	struct platform_device *ahci;
-	struct phy *phy;
 	struct reset_control *pwr;
 	struct reset_control *sw_rst;
 	struct reset_control *pwr_rst;

commit 4a2e51234038fb8b24963a2f32e8b55980085a23
Author: Lee Jones <lee.jones@linaro.org>
Date:   Wed Mar 12 12:39:38 2014 +0000

    ahci: st: Standardise naming conventions
    
    Other devices have adopted similar naming conventions which have been
    accepted as the standard. This patch brings any mention of the the ST
    AHCI driver into line with them.
    
    Suggested-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_st.c b/drivers/ata/ahci_st.c
index 2f951332227f..f5af660835b0 100644
--- a/drivers/ata/ahci_st.c
+++ b/drivers/ata/ahci_st.c
@@ -235,5 +235,5 @@ module_platform_driver(st_ahci_driver);
 
 MODULE_AUTHOR("Alexandre Torgue <alexandre.torgue@st.com>");
 MODULE_AUTHOR("Francesco Virlinzi <francesco.virlinzi@st.com>");
-MODULE_DESCRIPTION("STMicroelectronics Sata Ahci driver");
+MODULE_DESCRIPTION("STMicroelectronics SATA AHCI Driver");
 MODULE_LICENSE("GPL v2");

commit 76884cb2f7da5282019bf5c90e8f804429150742
Author: Lee Jones <lee.jones@linaro.org>
Date:   Wed Feb 26 14:47:21 2014 +0000

    ahci: st: Add support for ST's SATA IP
    
    Acked-by: Alexandre Torgue <alexandre.torgue@st.com>
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/ahci_st.c b/drivers/ata/ahci_st.c
new file mode 100644
index 000000000000..2f951332227f
--- /dev/null
+++ b/drivers/ata/ahci_st.c
@@ -0,0 +1,239 @@
+/*
+ * Copyright (C) 2012 STMicroelectronics Limited
+ *
+ * Authors: Francesco Virlinzi <francesco.virlinzi@st.com>
+ *	    Alexandre Torgue <alexandre.torgue@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/export.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/ahci_platform.h>
+#include <linux/phy/phy.h>
+#include <linux/libata.h>
+#include <linux/reset.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+
+#include "ahci.h"
+
+#define ST_AHCI_OOBR			0xbc
+#define ST_AHCI_OOBR_WE			BIT(31)
+#define ST_AHCI_OOBR_CWMIN_SHIFT	24
+#define ST_AHCI_OOBR_CWMAX_SHIFT	16
+#define ST_AHCI_OOBR_CIMIN_SHIFT	8
+#define ST_AHCI_OOBR_CIMAX_SHIFT	0
+
+struct st_ahci_drv_data {
+	struct platform_device *ahci;
+	struct phy *phy;
+	struct reset_control *pwr;
+	struct reset_control *sw_rst;
+	struct reset_control *pwr_rst;
+	struct ahci_host_priv *hpriv;
+};
+
+static void st_ahci_configure_oob(void __iomem *mmio)
+{
+	unsigned long old_val, new_val;
+
+	new_val = (0x02 << ST_AHCI_OOBR_CWMIN_SHIFT) |
+		  (0x04 << ST_AHCI_OOBR_CWMAX_SHIFT) |
+		  (0x08 << ST_AHCI_OOBR_CIMIN_SHIFT) |
+		  (0x0C << ST_AHCI_OOBR_CIMAX_SHIFT);
+
+	old_val = readl(mmio + ST_AHCI_OOBR);
+	writel(old_val | ST_AHCI_OOBR_WE, mmio + ST_AHCI_OOBR);
+	writel(new_val | ST_AHCI_OOBR_WE, mmio + ST_AHCI_OOBR);
+	writel(new_val, mmio + ST_AHCI_OOBR);
+}
+
+static int st_ahci_deassert_resets(struct device *dev)
+{
+	struct st_ahci_drv_data *drv_data = dev_get_drvdata(dev);
+	int err;
+
+	if (drv_data->pwr) {
+		err = reset_control_deassert(drv_data->pwr);
+		if (err) {
+			dev_err(dev, "unable to bring out of pwrdwn\n");
+			return err;
+		}
+	}
+
+	st_ahci_configure_oob(drv_data->hpriv->mmio);
+
+	if (drv_data->sw_rst) {
+		err = reset_control_deassert(drv_data->sw_rst);
+		if (err) {
+			dev_err(dev, "unable to bring out of sw-rst\n");
+			return err;
+		}
+	}
+
+	if (drv_data->pwr_rst) {
+		err = reset_control_deassert(drv_data->pwr_rst);
+		if (err) {
+			dev_err(dev, "unable to bring out of pwr-rst\n");
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int st_ahci_probe_resets(struct platform_device *pdev)
+{
+	struct st_ahci_drv_data *drv_data = platform_get_drvdata(pdev);
+
+	drv_data->pwr = devm_reset_control_get(&pdev->dev, "pwr-dwn");
+	if (IS_ERR(drv_data->pwr)) {
+		dev_info(&pdev->dev, "power reset control not defined\n");
+		drv_data->pwr = NULL;
+	}
+
+	drv_data->sw_rst = devm_reset_control_get(&pdev->dev, "sw-rst");
+	if (IS_ERR(drv_data->sw_rst)) {
+		dev_info(&pdev->dev, "soft reset control not defined\n");
+		drv_data->sw_rst = NULL;
+	}
+
+	drv_data->pwr_rst = devm_reset_control_get(&pdev->dev, "pwr-rst");
+	if (IS_ERR(drv_data->pwr_rst)) {
+		dev_dbg(&pdev->dev, "power soft reset control not defined\n");
+		drv_data->pwr_rst = NULL;
+	}
+
+	return st_ahci_deassert_resets(&pdev->dev);
+}
+
+static const struct ata_port_info st_ahci_port_info = {
+	.flags          = AHCI_FLAG_COMMON,
+	.pio_mask       = ATA_PIO4,
+	.udma_mask      = ATA_UDMA6,
+	.port_ops       = &ahci_platform_ops,
+};
+
+static int st_ahci_probe(struct platform_device *pdev)
+{
+	struct st_ahci_drv_data *drv_data;
+	struct ahci_host_priv *hpriv;
+	int err;
+
+	drv_data = devm_kzalloc(&pdev->dev, sizeof(*drv_data), GFP_KERNEL);
+	if (!drv_data)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, drv_data);
+
+	hpriv = ahci_platform_get_resources(pdev);
+	if (IS_ERR(hpriv))
+		return PTR_ERR(hpriv);
+
+	drv_data->hpriv = hpriv;
+
+	err = st_ahci_probe_resets(pdev);
+	if (err)
+		return err;
+
+	err = ahci_platform_enable_resources(hpriv);
+	if (err)
+		return err;
+
+	err = ahci_platform_init_host(pdev, hpriv, &st_ahci_port_info, 0, 0);
+	if (err) {
+		ahci_platform_disable_resources(hpriv);
+		return err;
+	}
+
+	return 0;
+}
+
+static int st_ahci_remove(struct platform_device *pdev)
+{
+	struct st_ahci_drv_data *drv_data = platform_get_drvdata(pdev);
+	struct ahci_host_priv *hpriv = drv_data->hpriv;
+	int err;
+
+	if (drv_data->pwr) {
+		err = reset_control_assert(drv_data->pwr);
+		if (err)
+			dev_err(&pdev->dev, "unable to pwrdwn\n");
+	}
+
+	ahci_platform_disable_resources(hpriv);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int st_ahci_suspend(struct device *dev)
+{
+	struct st_ahci_drv_data *drv_data = dev_get_drvdata(dev);
+	struct ahci_host_priv *hpriv = drv_data->hpriv;
+	int err;
+
+	if (drv_data->pwr) {
+		err = reset_control_assert(drv_data->pwr);
+		if (err) {
+			dev_err(dev, "unable to pwrdwn");
+			return err;
+		}
+	}
+
+	ahci_platform_disable_resources(hpriv);
+
+	return 0;
+}
+
+static int st_ahci_resume(struct device *dev)
+{
+	struct st_ahci_drv_data *drv_data = dev_get_drvdata(dev);
+	struct ahci_host_priv *hpriv = drv_data->hpriv;
+	int err;
+
+	err = ahci_platform_enable_resources(hpriv);
+	if (err)
+		return err;
+
+	err = st_ahci_deassert_resets(dev);
+	if (err) {
+		ahci_platform_disable_resources(hpriv);
+		return err;
+	}
+
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(st_ahci_pm_ops, st_ahci_suspend, st_ahci_resume);
+
+static struct of_device_id st_ahci_match[] = {
+	{ .compatible = "st,ahci", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, st_ahci_match);
+
+static struct platform_driver st_ahci_driver = {
+	.driver = {
+		.name = "st_ahci",
+		.owner = THIS_MODULE,
+		.pm = &st_ahci_pm_ops,
+		.of_match_table = of_match_ptr(st_ahci_match),
+	},
+	.probe = st_ahci_probe,
+	.remove = st_ahci_remove,
+};
+module_platform_driver(st_ahci_driver);
+
+MODULE_AUTHOR("Alexandre Torgue <alexandre.torgue@st.com>");
+MODULE_AUTHOR("Francesco Virlinzi <francesco.virlinzi@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics Sata Ahci driver");
+MODULE_LICENSE("GPL v2");
