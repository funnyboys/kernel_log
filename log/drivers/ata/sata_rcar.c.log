commit eea1238867205b9e48a67c1a63219529a73c46fd
Author: Navid Emamdoost <navid.emamdoost@gmail.com>
Date:   Thu Jun 4 22:06:43 2020 -0500

    sata_rcar: handle pm_runtime_get_sync failure cases
    
    Calling pm_runtime_get_sync increments the counter even in case of
    failure, causing incorrect ref count. Call pm_runtime_put if
    pm_runtime_get_sync fails.
    
    Signed-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 980aacdbcf3b..141ac600b64c 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -907,7 +907,7 @@ static int sata_rcar_probe(struct platform_device *pdev)
 	pm_runtime_enable(dev);
 	ret = pm_runtime_get_sync(dev);
 	if (ret < 0)
-		goto err_pm_disable;
+		goto err_pm_put;
 
 	host = ata_host_alloc(dev, 1);
 	if (!host) {
@@ -937,7 +937,6 @@ static int sata_rcar_probe(struct platform_device *pdev)
 
 err_pm_put:
 	pm_runtime_put(dev);
-err_pm_disable:
 	pm_runtime_disable(dev);
 	return ret;
 }
@@ -991,8 +990,10 @@ static int sata_rcar_resume(struct device *dev)
 	int ret;
 
 	ret = pm_runtime_get_sync(dev);
-	if (ret < 0)
+	if (ret < 0) {
+		pm_runtime_put(dev);
 		return ret;
+	}
 
 	if (priv->type == RCAR_GEN3_SATA) {
 		sata_rcar_init_module(priv);
@@ -1017,8 +1018,10 @@ static int sata_rcar_restore(struct device *dev)
 	int ret;
 
 	ret = pm_runtime_get_sync(dev);
-	if (ret < 0)
+	if (ret < 0) {
+		pm_runtime_put(dev);
 		return ret;
+	}
 
 	sata_rcar_setup_port(host);
 

commit 95364f36701e62dd50eee91e1303187fd1a9f567
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Thu Oct 31 10:59:45 2019 +0100

    ata: make qc_prep return ata_completion_errors
    
    In case a driver wants to return an error from qc_prep, return enum
    ata_completion_errors. sata_mv is one of those drivers -- see the next
    patch. Other drivers return the newly defined AC_ERR_OK.
    
    [v2] use enum ata_completion_errors and AC_ERR_OK.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: linux-ide@vger.kernel.org
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 3495e1733a8e..980aacdbcf3b 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -550,12 +550,14 @@ static void sata_rcar_bmdma_fill_sg(struct ata_queued_cmd *qc)
 	prd[si - 1].addr |= cpu_to_le32(SATA_RCAR_DTEND);
 }
 
-static void sata_rcar_qc_prep(struct ata_queued_cmd *qc)
+static enum ata_completion_errors sata_rcar_qc_prep(struct ata_queued_cmd *qc)
 {
 	if (!(qc->flags & ATA_QCFLAG_DMAMAP))
-		return;
+		return AC_ERR_OK;
 
 	sata_rcar_bmdma_fill_sg(qc);
+
+	return AC_ERR_OK;
 }
 
 static void sata_rcar_bmdma_setup(struct ata_queued_cmd *qc)

commit cf12c6729c7405c06b3e1bfccac7aa7ad007e1b7
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Apr 29 17:22:09 2019 +0200

    sata_rcar: Remove ata_host_alloc() error printing
    
    ata_host_alloc() can only fail due to memory allocation failures.
    Hence there is no need to print a message, as the memory allocation core
    code already takes care of that.
    
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Reviewed-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 59b2317acea9..3495e1733a8e 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -909,7 +909,6 @@ static int sata_rcar_probe(struct platform_device *pdev)
 
 	host = ata_host_alloc(dev, 1);
 	if (!host) {
-		dev_err(dev, "ata_host_alloc failed\n");
 		ret = -ENOMEM;
 		goto err_pm_put;
 	}

commit 9f83cfdb1ace3ef268ecc6fda50058d2ec37d603
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sat Nov 24 21:14:16 2018 +0300

    sata_rcar: fix deferred probing
    
    The driver overrides the error codes returned by platform_get_irq() to
    -EINVAL, so if it returns -EPROBE_DEFER, the driver would fail the probe
    permanently instead of the deferred probing. Switch to propagating the
    error code upstream, still checking/overriding IRQ0 as libata regards it
    as "no IRQ" (thus polling) anyway...
    
    Fixes: 9ec36cafe43b ("of/irq: do irq resolution in platform_get_irq")
    Reviewed-by: Simon Horman <horms+renesas@verge.net.au>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 4b1ff5bc256a..59b2317acea9 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -891,7 +891,9 @@ static int sata_rcar_probe(struct platform_device *pdev)
 	int ret = 0;
 
 	irq = platform_get_irq(pdev, 0);
-	if (irq <= 0)
+	if (irq < 0)
+		return irq;
+	if (!irq)
 		return -EINVAL;
 
 	priv = devm_kzalloc(dev, sizeof(struct sata_rcar_priv), GFP_KERNEL);

commit bb39ba6a8deab70752b836a36c62205b1c65b559
Author: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
Date:   Thu Nov 8 06:34:34 2018 +0000

    sata_rcar: convert to SPDX identifiers
    
    This patch updates license to use SPDX-License-Identifier
    instead of verbose license text.
    
    Signed-off-by: Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 10ecb232245d..4b1ff5bc256a 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -1,14 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Renesas R-Car SATA driver
  *
  * Author: Vladimir Barinov <source@cogentembedded.com>
  * Copyright (C) 2013-2015 Cogent Embedded, Inc.
  * Copyright (C) 2013-2015 Renesas Solutions Corp.
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
  */
 
 #include <linux/kernel.h>

commit 96b954895470fa1f64232fd9b1e31f445b8a3c35
Author: Masaharu Hayakawa <masaharu.hayakawa.ry@renesas.com>
Date:   Mon Aug 6 12:42:00 2018 +0200

    ata: sata_rcar: exclude setting of PHY registers in Gen3
    
    According to documentation, setting of PHY registers is unnecessary with
    R-Car Gen3. The registers are not even described. So, don't initialize
    them.
    
    Signed-off-by: Masaharu Hayakawa <masaharu.hayakawa.ry@renesas.com>
    [wsa: updated commit message]
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Reviewed-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 1ad168f76ef3..10ecb232245d 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -830,10 +830,11 @@ static void sata_rcar_init_controller(struct ata_host *host)
 		sata_rcar_gen1_phy_init(priv);
 		break;
 	case RCAR_GEN2_SATA:
-	case RCAR_GEN3_SATA:
 	case RCAR_R8A7790_ES1_SATA:
 		sata_rcar_gen2_phy_init(priv);
 		break;
+	case RCAR_GEN3_SATA:
+		break;
 	default:
 		dev_warn(host->dev, "SATA phy is not initialized\n");
 		break;
@@ -995,7 +996,6 @@ static int sata_rcar_resume(struct device *dev)
 		return ret;
 
 	if (priv->type == RCAR_GEN3_SATA) {
-		sata_rcar_gen2_phy_init(priv);
 		sata_rcar_init_module(priv);
 	} else {
 		/* ack and mask */

commit e207610fffbc339d14c663a6966454b8e9b2deff
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Mon Aug 6 12:40:05 2018 +0200

    ata: sata_rcar: really mask all interrupts on Gen2 and later
    
    Since R-Car Gen2, a new bit has been introduced to the interrupt mask
    register. Update the code to handle it properly as well.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Reviewed-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 3b8ed10bfb8f..1ad168f76ef3 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -109,6 +109,8 @@
 #define SATAINTMASK_ERRMSK		BIT(2)
 #define SATAINTMASK_ERRCRTMSK		BIT(1)
 #define SATAINTMASK_ATAMSK		BIT(0)
+#define SATAINTMASK_ALL_GEN1		0x7ff
+#define SATAINTMASK_ALL_GEN2		0xfff
 
 #define SATA_RCAR_INT_MASK		(SATAINTMASK_SERRMSK | \
 					 SATAINTMASK_ATAMSK)
@@ -152,6 +154,7 @@ enum sata_rcar_type {
 
 struct sata_rcar_priv {
 	void __iomem *base;
+	u32 sataint_mask;
 	enum sata_rcar_type type;
 };
 
@@ -225,7 +228,7 @@ static void sata_rcar_freeze(struct ata_port *ap)
 	struct sata_rcar_priv *priv = ap->host->private_data;
 
 	/* mask */
-	iowrite32(0x7ff, priv->base + SATAINTMASK_REG);
+	iowrite32(priv->sataint_mask, priv->base + SATAINTMASK_REG);
 
 	ata_sff_freeze(ap);
 }
@@ -241,7 +244,7 @@ static void sata_rcar_thaw(struct ata_port *ap)
 	ata_sff_thaw(ap);
 
 	/* unmask */
-	iowrite32(0x7ff & ~SATA_RCAR_INT_MASK, base + SATAINTMASK_REG);
+	iowrite32(priv->sataint_mask & ~SATA_RCAR_INT_MASK, base + SATAINTMASK_REG);
 }
 
 static void sata_rcar_ioread16_rep(void __iomem *reg, void *buffer, int count)
@@ -735,7 +738,7 @@ static irqreturn_t sata_rcar_interrupt(int irq, void *dev_instance)
 	if (!sataintstat)
 		goto done;
 	/* ack */
-	iowrite32(~sataintstat & 0x7ff, base + SATAINTSTAT_REG);
+	iowrite32(~sataintstat & priv->sataint_mask, base + SATAINTSTAT_REG);
 
 	ap = host->ports[0];
 
@@ -808,7 +811,7 @@ static void sata_rcar_init_module(struct sata_rcar_priv *priv)
 
 	/* ack and mask */
 	iowrite32(0, base + SATAINTSTAT_REG);
-	iowrite32(0x7ff, base + SATAINTMASK_REG);
+	iowrite32(priv->sataint_mask, base + SATAINTMASK_REG);
 
 	/* enable interrupts */
 	iowrite32(ATAPI_INT_ENABLE_SATAINT, base + ATAPI_INT_ENABLE_REG);
@@ -818,9 +821,12 @@ static void sata_rcar_init_controller(struct ata_host *host)
 {
 	struct sata_rcar_priv *priv = host->private_data;
 
+	priv->sataint_mask = SATAINTMASK_ALL_GEN2;
+
 	/* reset and setup phy */
 	switch (priv->type) {
 	case RCAR_GEN1_SATA:
+		priv->sataint_mask = SATAINTMASK_ALL_GEN1;
 		sata_rcar_gen1_phy_init(priv);
 		break;
 	case RCAR_GEN2_SATA:
@@ -948,7 +954,7 @@ static int sata_rcar_remove(struct platform_device *pdev)
 	iowrite32(0, base + ATAPI_INT_ENABLE_REG);
 	/* ack and mask */
 	iowrite32(0, base + SATAINTSTAT_REG);
-	iowrite32(0x7ff, base + SATAINTMASK_REG);
+	iowrite32(priv->sataint_mask, base + SATAINTMASK_REG);
 
 	pm_runtime_put(&pdev->dev);
 	pm_runtime_disable(&pdev->dev);
@@ -969,7 +975,7 @@ static int sata_rcar_suspend(struct device *dev)
 		/* disable interrupts */
 		iowrite32(0, base + ATAPI_INT_ENABLE_REG);
 		/* mask */
-		iowrite32(0x7ff, base + SATAINTMASK_REG);
+		iowrite32(priv->sataint_mask, base + SATAINTMASK_REG);
 
 		pm_runtime_put(dev);
 	}
@@ -994,7 +1000,7 @@ static int sata_rcar_resume(struct device *dev)
 	} else {
 		/* ack and mask */
 		iowrite32(0, base + SATAINTSTAT_REG);
-		iowrite32(0x7ff, base + SATAINTMASK_REG);
+		iowrite32(priv->sataint_mask, base + SATAINTMASK_REG);
 
 		/* enable interrupts */
 		iowrite32(ATAPI_INT_ENABLE_SATAINT,

commit 1ecd34ddf63ef1d4015da5e5de6881e6845a6b0a
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jul 20 14:27:39 2018 +0200

    ata: sata_rcar: Add rudimentary Runtime PM support
    
    Replace the explicit clock handling to enable/disable the SATA module by
    calls to Runtime PM.
    
    This makes the driver independent of actual SoC clock/power hierarchies,
    and is needed to support virtualization, where the guest is not in full
    control of power management.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index f972c2c5ebd3..3b8ed10bfb8f 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -17,7 +17,7 @@
 #include <linux/libata.h>
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
-#include <linux/clk.h>
+#include <linux/pm_runtime.h>
 #include <linux/err.h>
 
 #define DRV_NAME "sata_rcar"
@@ -152,7 +152,6 @@ enum sata_rcar_type {
 
 struct sata_rcar_priv {
 	void __iomem *base;
-	struct clk *clk;
 	enum sata_rcar_type type;
 };
 
@@ -897,21 +896,17 @@ static int sata_rcar_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	priv->type = (enum sata_rcar_type)of_device_get_match_data(dev);
-	priv->clk = devm_clk_get(dev, NULL);
-	if (IS_ERR(priv->clk)) {
-		dev_err(dev, "failed to get access to sata clock\n");
-		return PTR_ERR(priv->clk);
-	}
 
-	ret = clk_prepare_enable(priv->clk);
-	if (ret)
-		return ret;
+	pm_runtime_enable(dev);
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0)
+		goto err_pm_disable;
 
 	host = ata_host_alloc(dev, 1);
 	if (!host) {
 		dev_err(dev, "ata_host_alloc failed\n");
 		ret = -ENOMEM;
-		goto cleanup;
+		goto err_pm_put;
 	}
 
 	host->private_data = priv;
@@ -920,7 +915,7 @@ static int sata_rcar_probe(struct platform_device *pdev)
 	priv->base = devm_ioremap_resource(dev, mem);
 	if (IS_ERR(priv->base)) {
 		ret = PTR_ERR(priv->base);
-		goto cleanup;
+		goto err_pm_put;
 	}
 
 	/* setup port */
@@ -934,9 +929,10 @@ static int sata_rcar_probe(struct platform_device *pdev)
 	if (!ret)
 		return 0;
 
-cleanup:
-	clk_disable_unprepare(priv->clk);
-
+err_pm_put:
+	pm_runtime_put(dev);
+err_pm_disable:
+	pm_runtime_disable(dev);
 	return ret;
 }
 
@@ -954,7 +950,8 @@ static int sata_rcar_remove(struct platform_device *pdev)
 	iowrite32(0, base + SATAINTSTAT_REG);
 	iowrite32(0x7ff, base + SATAINTMASK_REG);
 
-	clk_disable_unprepare(priv->clk);
+	pm_runtime_put(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
 
 	return 0;
 }
@@ -974,7 +971,7 @@ static int sata_rcar_suspend(struct device *dev)
 		/* mask */
 		iowrite32(0x7ff, base + SATAINTMASK_REG);
 
-		clk_disable_unprepare(priv->clk);
+		pm_runtime_put(dev);
 	}
 
 	return ret;
@@ -987,8 +984,8 @@ static int sata_rcar_resume(struct device *dev)
 	void __iomem *base = priv->base;
 	int ret;
 
-	ret = clk_prepare_enable(priv->clk);
-	if (ret)
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0)
 		return ret;
 
 	if (priv->type == RCAR_GEN3_SATA) {
@@ -1012,11 +1009,10 @@ static int sata_rcar_resume(struct device *dev)
 static int sata_rcar_restore(struct device *dev)
 {
 	struct ata_host *host = dev_get_drvdata(dev);
-	struct sata_rcar_priv *priv = host->private_data;
 	int ret;
 
-	ret = clk_prepare_enable(priv->clk);
-	if (ret)
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0)
 		return ret;
 
 	sata_rcar_setup_port(host);

commit c01e229f24eb133ca85453597447477974b07f20
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Fri Jul 20 14:27:38 2018 +0200

    ata: sata_rcar: Provide a short-hand for &pdev->dev
    
    No functional changes.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 6456e07db72a..f972c2c5ebd3 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -881,6 +881,7 @@ MODULE_DEVICE_TABLE(of, sata_rcar_match);
 
 static int sata_rcar_probe(struct platform_device *pdev)
 {
+	struct device *dev = &pdev->dev;
 	struct ata_host *host;
 	struct sata_rcar_priv *priv;
 	struct resource *mem;
@@ -891,15 +892,14 @@ static int sata_rcar_probe(struct platform_device *pdev)
 	if (irq <= 0)
 		return -EINVAL;
 
-	priv = devm_kzalloc(&pdev->dev, sizeof(struct sata_rcar_priv),
-			   GFP_KERNEL);
+	priv = devm_kzalloc(dev, sizeof(struct sata_rcar_priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 
-	priv->type = (enum sata_rcar_type)of_device_get_match_data(&pdev->dev);
-	priv->clk = devm_clk_get(&pdev->dev, NULL);
+	priv->type = (enum sata_rcar_type)of_device_get_match_data(dev);
+	priv->clk = devm_clk_get(dev, NULL);
 	if (IS_ERR(priv->clk)) {
-		dev_err(&pdev->dev, "failed to get access to sata clock\n");
+		dev_err(dev, "failed to get access to sata clock\n");
 		return PTR_ERR(priv->clk);
 	}
 
@@ -907,9 +907,9 @@ static int sata_rcar_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	host = ata_host_alloc(&pdev->dev, 1);
+	host = ata_host_alloc(dev, 1);
 	if (!host) {
-		dev_err(&pdev->dev, "ata_host_alloc failed\n");
+		dev_err(dev, "ata_host_alloc failed\n");
 		ret = -ENOMEM;
 		goto cleanup;
 	}
@@ -917,7 +917,7 @@ static int sata_rcar_probe(struct platform_device *pdev)
 	host->private_data = priv;
 
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	priv->base = devm_ioremap_resource(&pdev->dev, mem);
+	priv->base = devm_ioremap_resource(dev, mem);
 	if (IS_ERR(priv->base)) {
 		ret = PTR_ERR(priv->base);
 		goto cleanup;

commit 8f8ca51dbb4da0457f57f83d94aea81931b0707a
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Feb 13 13:43:23 2018 +0100

    ata: sata_rcar: Remove unused variable in sata_rcar_init_controller()
    
    drivers/ata/sata_rcar.c: In function 'sata_rcar_init_controller':
    drivers/ata/sata_rcar.c:821:8: warning: unused variable 'base' [-Wunused-variable]
    
    Fixes: da77d76b95a0e894 ("sata_rcar: Reset SATA PHY when Salvator-X board resumes")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 6f47ca34767d..6456e07db72a 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -818,7 +818,6 @@ static void sata_rcar_init_module(struct sata_rcar_priv *priv)
 static void sata_rcar_init_controller(struct ata_host *host)
 {
 	struct sata_rcar_priv *priv = host->private_data;
-	void __iomem *base = priv->base;
 
 	/* reset and setup phy */
 	switch (priv->type) {

commit da77d76b95a0e8940793f4f7fe12a4a2d2048e39
Author: Khiem Nguyen <khiem.nguyen.xt@rvc.renesas.com>
Date:   Mon Feb 5 04:18:51 2018 +0900

    sata_rcar: Reset SATA PHY when Salvator-X board resumes
    
    Because power of Salvator-X board is cut off in suspend,
    it needs to reset SATA PHY state in resume.
    Otherwise, SATA partition could not be accessed anymore.
    
    Signed-off-by: Khiem Nguyen <khiem.nguyen.xt@rvc.renesas.com>
    Signed-off-by: Hien Dang <hien.dang.eb@rvc.renesas.com>
    [reinit phy in sata_rcar_resume() function on R-Car Gen3 only]
    [factor out SATA module init sequence]
    [fixed the prefix for the subject]
    Signed-off-by: Yoshihiro Kaneko <ykaneko0929@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 80ee2f2a50d0..6f47ca34767d 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -146,6 +146,7 @@
 enum sata_rcar_type {
 	RCAR_GEN1_SATA,
 	RCAR_GEN2_SATA,
+	RCAR_GEN3_SATA,
 	RCAR_R8A7790_ES1_SATA,
 };
 
@@ -784,26 +785,11 @@ static void sata_rcar_setup_port(struct ata_host *host)
 	ioaddr->command_addr	= ioaddr->cmd_addr + (ATA_REG_CMD << 2);
 }
 
-static void sata_rcar_init_controller(struct ata_host *host)
+static void sata_rcar_init_module(struct sata_rcar_priv *priv)
 {
-	struct sata_rcar_priv *priv = host->private_data;
 	void __iomem *base = priv->base;
 	u32 val;
 
-	/* reset and setup phy */
-	switch (priv->type) {
-	case RCAR_GEN1_SATA:
-		sata_rcar_gen1_phy_init(priv);
-		break;
-	case RCAR_GEN2_SATA:
-	case RCAR_R8A7790_ES1_SATA:
-		sata_rcar_gen2_phy_init(priv);
-		break;
-	default:
-		dev_warn(host->dev, "SATA phy is not initialized\n");
-		break;
-	}
-
 	/* SATA-IP reset state */
 	val = ioread32(base + ATAPI_CONTROL1_REG);
 	val |= ATAPI_CONTROL1_RESET;
@@ -824,10 +810,34 @@ static void sata_rcar_init_controller(struct ata_host *host)
 	/* ack and mask */
 	iowrite32(0, base + SATAINTSTAT_REG);
 	iowrite32(0x7ff, base + SATAINTMASK_REG);
+
 	/* enable interrupts */
 	iowrite32(ATAPI_INT_ENABLE_SATAINT, base + ATAPI_INT_ENABLE_REG);
 }
 
+static void sata_rcar_init_controller(struct ata_host *host)
+{
+	struct sata_rcar_priv *priv = host->private_data;
+	void __iomem *base = priv->base;
+
+	/* reset and setup phy */
+	switch (priv->type) {
+	case RCAR_GEN1_SATA:
+		sata_rcar_gen1_phy_init(priv);
+		break;
+	case RCAR_GEN2_SATA:
+	case RCAR_GEN3_SATA:
+	case RCAR_R8A7790_ES1_SATA:
+		sata_rcar_gen2_phy_init(priv);
+		break;
+	default:
+		dev_warn(host->dev, "SATA phy is not initialized\n");
+		break;
+	}
+
+	sata_rcar_init_module(priv);
+}
+
 static const struct of_device_id sata_rcar_match[] = {
 	{
 		/* Deprecated by "renesas,sata-r8a7779" */
@@ -856,7 +866,7 @@ static const struct of_device_id sata_rcar_match[] = {
 	},
 	{
 		.compatible = "renesas,sata-r8a7795",
-		.data = (void *)RCAR_GEN2_SATA
+		.data = (void *)RCAR_GEN3_SATA
 	},
 	{
 		.compatible = "renesas,rcar-gen2-sata",
@@ -864,7 +874,7 @@ static const struct of_device_id sata_rcar_match[] = {
 	},
 	{
 		.compatible = "renesas,rcar-gen3-sata",
-		.data = (void *)RCAR_GEN2_SATA
+		.data = (void *)RCAR_GEN3_SATA
 	},
 	{ },
 };
@@ -982,11 +992,18 @@ static int sata_rcar_resume(struct device *dev)
 	if (ret)
 		return ret;
 
-	/* ack and mask */
-	iowrite32(0, base + SATAINTSTAT_REG);
-	iowrite32(0x7ff, base + SATAINTMASK_REG);
-	/* enable interrupts */
-	iowrite32(ATAPI_INT_ENABLE_SATAINT, base + ATAPI_INT_ENABLE_REG);
+	if (priv->type == RCAR_GEN3_SATA) {
+		sata_rcar_gen2_phy_init(priv);
+		sata_rcar_init_module(priv);
+	} else {
+		/* ack and mask */
+		iowrite32(0, base + SATAINTSTAT_REG);
+		iowrite32(0x7ff, base + SATAINTMASK_REG);
+
+		/* enable interrupts */
+		iowrite32(ATAPI_INT_ENABLE_SATAINT,
+			  base + ATAPI_INT_ENABLE_REG);
+	}
 
 	ata_host_resume(host);
 

commit 03b623fbc5d8d24d45d4e8cd4ba245b0170891f3
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Wed Oct 4 14:13:07 2017 +0200

    ata: sata_rcar: Use of_device_get_match_data() helper
    
    Use the of_device_get_match_data() helper instead of open coding.
    Note that the sata_rcar driver is used with DT only, so there's always a
    valid match.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 537d11869069..80ee2f2a50d0 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -872,7 +872,6 @@ MODULE_DEVICE_TABLE(of, sata_rcar_match);
 
 static int sata_rcar_probe(struct platform_device *pdev)
 {
-	const struct of_device_id *of_id;
 	struct ata_host *host;
 	struct sata_rcar_priv *priv;
 	struct resource *mem;
@@ -888,11 +887,7 @@ static int sata_rcar_probe(struct platform_device *pdev)
 	if (!priv)
 		return -ENOMEM;
 
-	of_id = of_match_device(sata_rcar_match, &pdev->dev);
-	if (!of_id)
-		return -ENODEV;
-
-	priv->type = (enum sata_rcar_type)of_id->data;
+	priv->type = (enum sata_rcar_type)of_device_get_match_data(&pdev->dev);
 	priv->clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(priv->clk)) {
 		dev_err(&pdev->dev, "failed to get access to sata clock\n");

commit 6ac1d1532c888b030acb3b4ac82425448cb15198
Author: Simon Horman <horms+renesas@verge.net.au>
Date:   Tue Jul 11 13:44:20 2017 +0200

    ata: sata_rcar: add gen[23] fallback compatibility strings
    
    Add fallback compatibility string for R-Car Gen 2 and 3.
    
    In the case of Renesas R-Car hardware we know that there are generations of
    SoCs, e.g. Gen 1 and 2. But beyond that its not clear what the relationship
    between IP blocks might be. For example, I believe that r8a7790 is older
    than r8a7791 but that doesn't imply that the latter is a descendant of the
    former or vice versa.
    
    We can, however, by examining the documentation and behaviour of the
    hardware at run-time observe that the current driver implementation appears
    to be compatible with the IP blocks on SoCs within a given generation.
    
    For the above reasons and convenience when enabling new SoCs a
    per-generation fallback compatibility string scheme being adopted for
    drivers for Renesas SoCs.
    
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>
    Acked-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Reviewed-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index ee9844758736..537d11869069 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -858,6 +858,14 @@ static const struct of_device_id sata_rcar_match[] = {
 		.compatible = "renesas,sata-r8a7795",
 		.data = (void *)RCAR_GEN2_SATA
 	},
+	{
+		.compatible = "renesas,rcar-gen2-sata",
+		.data = (void *)RCAR_GEN2_SATA
+	},
+	{
+		.compatible = "renesas,rcar-gen3-sata",
+		.data = (void *)RCAR_GEN2_SATA
+	},
 	{ },
 };
 MODULE_DEVICE_TABLE(of, sata_rcar_match);

commit 109a5db5042c035ded330b948a710b9a0c20934d
Merge: a4c20b9a574b d80210f25ff0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 6 09:41:58 2017 -0700

    Merge branch 'for-4.13' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata
    
    Pull libata updates from Tejun Heo:
    
     - Christoph added support for TCG OPAL self encrypting disks
    
     - Minwoo added support for ATA PASS-THROUGH(32)
    
     - Linus Walleij removed spurious drvdata assignments in some drivers
    
     - Support for a few new device and other fixes
    
    * 'for-4.13' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata: (33 commits)
      sd: add support for TCG OPAL self encrypting disks
      libata: fix build warning from unused goto label
      libata: Support for an ATA PASS-THROUGH(32) command.
      ahci: Add Device ID for ASMedia 1061R and 1062R
      sata_via: Enable optional hotplug on VT6420
      ata: ahci_brcm: Avoid writing to read-only registers
      libata: Add the AHCI_HFLAG_NO_WRITE_TO_RO flag
      libata: Add the AHCI_HFLAG_YES_ALPM flag
      ata: ftide010: fix resource printing
      libata: make the function name in comment match the actual function
      ata: sata_rcar: make of_device_ids const.
      ata: pata_octeon_cf: make of_device_ids const.
      libata: Convert bare printks to pr_cont
      libahci: wrong comments in ahci_do_softreset()
      ata: declare ata_port_info structures as const
      ata: Add driver for Faraday Technology FTIDE010
      ata: Add DT bindings for the Gemini SATA bridge
      ata: Add DT bindings for Faraday Technology FTIDE010
      libata: implement SECURITY PROTOCOL IN/OUT
      libata: factor out a ata_identify_page_supported helper
      ...

commit a5893870f8145b782e42d5ff187ae1dee6f2b650
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Fri Jun 16 17:32:21 2017 +0530

    ata: sata_rcar: make of_device_ids const.
    
    of_device_ids are not supposed to change at runtime. All functions
    working with of_device_ids provided by <linux/of.h> work with const
    of_device_ids. So mark the non-const structs as const.
    
    File size before:
       text    data     bss     dec     hex filename
       3946    2296       0    6242    1862 drivers/ata/sata_rcar.o
    
    File size after constify sata_rcar_match.
       text    data     bss     dec     hex filename
       5554     696       0    6250    186a drivers/ata/sata_rcar.o
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 5d38245a7a73..35945e31ba7d 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -828,7 +828,7 @@ static void sata_rcar_init_controller(struct ata_host *host)
 	iowrite32(ATAPI_INT_ENABLE_SATAINT, base + ATAPI_INT_ENABLE_REG);
 }
 
-static struct of_device_id sata_rcar_match[] = {
+static const struct of_device_id sata_rcar_match[] = {
 	{
 		/* Deprecated by "renesas,sata-r8a7779" */
 		.compatible = "renesas,rcar-sata",

commit 5dc63fdcc09f47fb226b8bc7d83a61feb787d817
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Tue May 9 16:00:28 2017 +0530

    ata: sata_rcar: Handle return value of clk_prepare_enable
    
    Here, Clock enable can failed. So adding an error check for
    clk_prepare_enable.
    
    tj: minor style updates
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 5d38245a7a73..b7939a2c1fab 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -890,7 +890,10 @@ static int sata_rcar_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "failed to get access to sata clock\n");
 		return PTR_ERR(priv->clk);
 	}
-	clk_prepare_enable(priv->clk);
+
+	ret = clk_prepare_enable(priv->clk);
+	if (ret)
+		return ret;
 
 	host = ata_host_alloc(&pdev->dev, 1);
 	if (!host) {
@@ -970,8 +973,11 @@ static int sata_rcar_resume(struct device *dev)
 	struct ata_host *host = dev_get_drvdata(dev);
 	struct sata_rcar_priv *priv = host->private_data;
 	void __iomem *base = priv->base;
+	int ret;
 
-	clk_prepare_enable(priv->clk);
+	ret = clk_prepare_enable(priv->clk);
+	if (ret)
+		return ret;
 
 	/* ack and mask */
 	iowrite32(0, base + SATAINTSTAT_REG);
@@ -988,8 +994,11 @@ static int sata_rcar_restore(struct device *dev)
 {
 	struct ata_host *host = dev_get_drvdata(dev);
 	struct sata_rcar_priv *priv = host->private_data;
+	int ret;
 
-	clk_prepare_enable(priv->clk);
+	ret = clk_prepare_enable(priv->clk);
+	if (ret)
+		return ret;
 
 	sata_rcar_setup_port(host);
 

commit 989e0aac1a801e9e9580632c9fd448a7aaca596a
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Fri Dec 30 15:01:17 2016 +0100

    ata: pass queued command to ->sff_data_xfer method
    
    For Atari Falcon PATA support we need to check the current command
    in its ->sff_data_xfer method.  Update core code and all users
    accordingly.
    
    There should be no functional changes caused by this patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index f72d601e300a..5d38245a7a73 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -447,11 +447,11 @@ static void sata_rcar_exec_command(struct ata_port *ap,
 	ata_sff_pause(ap);
 }
 
-static unsigned int sata_rcar_data_xfer(struct ata_device *dev,
+static unsigned int sata_rcar_data_xfer(struct ata_queued_cmd *qc,
 					      unsigned char *buf,
 					      unsigned int buflen, int rw)
 {
-	struct ata_port *ap = dev->link->ap;
+	struct ata_port *ap = qc->dev->link->ap;
 	void __iomem *data_addr = ap->ioaddr.data_addr;
 	unsigned int words = buflen >> 1;
 

commit 7f64d642893bc0e6c501f95dad01c36783a94bee
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Nov 24 15:45:04 2015 +0100

    ata: sata_rcar: Remove obsolete platform_device_id entries
    
    Since commit c99cd90d98a98aa1 ("ARM: shmobile: r8a7779: Remove legacy
    SoC code"), R-Car SoCs are only supported in generic DT-only ARM
    multi-platform builds.  The driver doesn't need to match platform
    devices by name anymore, hence remove the remaining platform_device_id
    entries and platform device support.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 2b20b31f317d..f72d601e300a 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -862,13 +862,6 @@ static struct of_device_id sata_rcar_match[] = {
 };
 MODULE_DEVICE_TABLE(of, sata_rcar_match);
 
-static const struct platform_device_id sata_rcar_id_table[] = {
-	{ "sata_rcar", RCAR_GEN1_SATA }, /* Deprecated by "sata-r8a7779" */
-	{ "sata-r8a7779", RCAR_GEN1_SATA },
-	{ },
-};
-MODULE_DEVICE_TABLE(platform, sata_rcar_id_table);
-
 static int sata_rcar_probe(struct platform_device *pdev)
 {
 	const struct of_device_id *of_id;
@@ -888,11 +881,10 @@ static int sata_rcar_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	of_id = of_match_device(sata_rcar_match, &pdev->dev);
-	if (of_id)
-		priv->type = (enum sata_rcar_type)of_id->data;
-	else
-		priv->type = platform_get_device_id(pdev)->driver_data;
+	if (!of_id)
+		return -ENODEV;
 
+	priv->type = (enum sata_rcar_type)of_id->data;
 	priv->clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(priv->clk)) {
 		dev_err(&pdev->dev, "failed to get access to sata clock\n");
@@ -1022,7 +1014,6 @@ static const struct dev_pm_ops sata_rcar_pm_ops = {
 static struct platform_driver sata_rcar_driver = {
 	.probe		= sata_rcar_probe,
 	.remove		= sata_rcar_remove,
-	.id_table	= sata_rcar_id_table,
 	.driver = {
 		.name		= DRV_NAME,
 		.of_match_table	= sata_rcar_match,

commit fec7bc433a29ea75b83dd9447629c99b2d4d727a
Author: Kouei Abe <kouei.abe.cp@renesas.com>
Date:   Fri Nov 20 21:33:02 2015 +0900

    sata_rcar: Add compatible string for r8a7795
    
    R-Car H3 SoC has compatible SATA controller with R-Car Gen2 SoCs.
    
    Signed-off-by: Kouei Abe <kouei.abe.cp@renesas.com>
    Signed-off-by: Yoshihiro Kaneko <ykaneko0929@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 8804127b108c..2b20b31f317d 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -854,6 +854,10 @@ static struct of_device_id sata_rcar_match[] = {
 		.compatible = "renesas,sata-r8a7793",
 		.data = (void *)RCAR_GEN2_SATA
 	},
+	{
+		.compatible = "renesas,sata-r8a7795",
+		.data = (void *)RCAR_GEN2_SATA
+	},
 	{ },
 };
 MODULE_DEVICE_TABLE(of, sata_rcar_match);

commit 5dbc247c2a11f6b9febb854a55be5ae6be720df6
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Jun 23 14:55:13 2015 +0200

    ata: sata_rcar: Remove obsolete sata-r8a779* platform_device_id entries
    
    Since commit a483dcbfa21f919c ("ARM: shmobile: lager: Remove legacy
    board support"), R-Car Gen2 SoCs are only supported in generic DT-only
    ARM multi-platform builds.  The driver doesn't need to match platform
    devices by name anymore, hence remove the corresponding
    platform_device_id entry.
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index d49a5193b7de..8804127b108c 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -861,10 +861,6 @@ MODULE_DEVICE_TABLE(of, sata_rcar_match);
 static const struct platform_device_id sata_rcar_id_table[] = {
 	{ "sata_rcar", RCAR_GEN1_SATA }, /* Deprecated by "sata-r8a7779" */
 	{ "sata-r8a7779", RCAR_GEN1_SATA },
-	{ "sata-r8a7790", RCAR_GEN2_SATA },
-	{ "sata-r8a7790-es1", RCAR_R8A7790_ES1_SATA },
-	{ "sata-r8a7791", RCAR_GEN2_SATA },
-	{ "sata-r8a7793", RCAR_GEN2_SATA },
 	{ },
 };
 MODULE_DEVICE_TABLE(platform, sata_rcar_id_table);

commit 5bc27ef72719acb1cf745f16ce5583b57ea660aa
Author: Mikhail Ulyanov <mikhail.ulyanov@cogentembedded.com>
Date:   Sat Jan 17 02:00:36 2015 +0300

    sata_rcar: extend PM methods
    
    In order to make it possible to restore from hibernation not only in Linux but
    also in e.g. U-Boot, we have to extend  sata_rcar_{suspend|resume}() to {freeze|
    thaw}() PM  methods and implement  the  restore() PM method.
    
    Signed-off-by: Mikhail Ulyanov <mikhail.ulyanov@cogentembedded.com>
    [Sergei: killed unused variable, changed the order of initializers, modified
    copyrights, renamed, modified changelog.]
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index cb0d2e644af5..d49a5193b7de 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -2,8 +2,8 @@
  * Renesas R-Car SATA driver
  *
  * Author: Vladimir Barinov <source@cogentembedded.com>
- * Copyright (C) 2013 Cogent Embedded, Inc.
- * Copyright (C) 2013 Renesas Solutions Corp.
+ * Copyright (C) 2013-2015 Cogent Embedded, Inc.
+ * Copyright (C) 2013-2015 Renesas Solutions Corp.
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -992,9 +992,30 @@ static int sata_rcar_resume(struct device *dev)
 	return 0;
 }
 
+static int sata_rcar_restore(struct device *dev)
+{
+	struct ata_host *host = dev_get_drvdata(dev);
+	struct sata_rcar_priv *priv = host->private_data;
+
+	clk_prepare_enable(priv->clk);
+
+	sata_rcar_setup_port(host);
+
+	/* initialize host controller */
+	sata_rcar_init_controller(host);
+
+	ata_host_resume(host);
+
+	return 0;
+}
+
 static const struct dev_pm_ops sata_rcar_pm_ops = {
 	.suspend	= sata_rcar_suspend,
 	.resume		= sata_rcar_resume,
+	.freeze		= sata_rcar_suspend,
+	.thaw		= sata_rcar_resume,
+	.poweroff	= sata_rcar_suspend,
+	.restore	= sata_rcar_restore,
 };
 #endif
 

commit e6b5be2be4e30037eb551e0ed09dd97bd00d85d3
Merge: 37da7bbbe84f f1c488a78d9f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 16:10:09 2014 -0800

    Merge tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core update from Greg KH:
     "Here's the set of driver core patches for 3.19-rc1.
    
      They are dominated by the removal of the .owner field in platform
      drivers.  They touch a lot of files, but they are "simple" changes,
      just removing a line in a structure.
    
      Other than that, a few minor driver core and debugfs changes.  There
      are some ath9k patches coming in through this tree that have been
      acked by the wireless maintainers as they relied on the debugfs
      changes.
    
      Everything has been in linux-next for a while"
    
    * tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (324 commits)
      Revert "ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries"
      fs: debugfs: add forward declaration for struct device type
      firmware class: Deletion of an unnecessary check before the function call "vunmap"
      firmware loader: fix hung task warning dump
      devcoredump: provide a one-way disable function
      device: Add dev_<level>_once variants
      ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries
      ath: use seq_file api for ath9k debugfs files
      debugfs: add helper function to create device related seq_file
      drivers/base: cacheinfo: remove noisy error boot message
      Revert "core: platform: add warning if driver has no owner"
      drivers: base: support cpu cache information interface to userspace via sysfs
      drivers: base: add cpu_device_create to support per-cpu devices
      topology: replace custom attribute macros with standard DEVICE_ATTR*
      cpumask: factor out show_cpumap into separate helper function
      driver core: Fix unbalanced device reference in drivers_probe
      driver core: fix race with userland in device_add()
      sysfs/kernfs: make read requests on pre-alloc files use the buffer.
      sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
      fs: sysfs: return EGBIG on write if offset is larger than file size
      ...

commit e35b98849f2530bb77f8fe649b3eaa1489ff9d33
Author: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
Date:   Tue Oct 28 12:45:32 2014 +0900

    ata: sata_rcar: Add r8a7793 device support
    
    Signed-off-by: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
    Signed-off-by: Yoshihiro Kaneko <ykaneko0929@gmail.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 8732e42db3a9..ea1fbc1d4c5f 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -850,6 +850,10 @@ static struct of_device_id sata_rcar_match[] = {
 		.compatible = "renesas,sata-r8a7791",
 		.data = (void *)RCAR_GEN2_SATA
 	},
+	{
+		.compatible = "renesas,sata-r8a7793",
+		.data = (void *)RCAR_GEN2_SATA
+	},
 	{ },
 };
 MODULE_DEVICE_TABLE(of, sata_rcar_match);
@@ -860,6 +864,7 @@ static const struct platform_device_id sata_rcar_id_table[] = {
 	{ "sata-r8a7790", RCAR_GEN2_SATA },
 	{ "sata-r8a7790-es1", RCAR_R8A7790_ES1_SATA },
 	{ "sata-r8a7791", RCAR_GEN2_SATA },
+	{ "sata-r8a7793", RCAR_GEN2_SATA },
 	{ },
 };
 MODULE_DEVICE_TABLE(platform, sata_rcar_id_table);

commit aa1cf25887099bba68f1f3879c0d394e08b8779f
Author: Simon Horman <horms+renesas@verge.net.au>
Date:   Mon Oct 27 09:14:30 2014 +0900

    ata: sata_rcar: Disable DIPM mode for r8a7790 ES1
    
    Unlike other SATA R-Car r8a7790 controllers the r8a7790 ES1 SATA R-Car
    controller needs to be run with DIPM disabled.
    
    Signed-off-by: Simon Horman <horms+renesas@verge.net.au>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 61eb6d77dac7..8732e42db3a9 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -146,6 +146,7 @@
 enum sata_rcar_type {
 	RCAR_GEN1_SATA,
 	RCAR_GEN2_SATA,
+	RCAR_R8A7790_ES1_SATA,
 };
 
 struct sata_rcar_priv {
@@ -763,6 +764,9 @@ static void sata_rcar_setup_port(struct ata_host *host)
 	ap->udma_mask	= ATA_UDMA6;
 	ap->flags	|= ATA_FLAG_SATA;
 
+	if (priv->type == RCAR_R8A7790_ES1_SATA)
+		ap->flags	|= ATA_FLAG_NO_DIPM;
+
 	ioaddr->cmd_addr = base + SDATA_REG;
 	ioaddr->ctl_addr = base + SSDEVCON_REG;
 	ioaddr->scr_addr = base + SCRSSTS_REG;
@@ -792,6 +796,7 @@ static void sata_rcar_init_controller(struct ata_host *host)
 		sata_rcar_gen1_phy_init(priv);
 		break;
 	case RCAR_GEN2_SATA:
+	case RCAR_R8A7790_ES1_SATA:
 		sata_rcar_gen2_phy_init(priv);
 		break;
 	default:
@@ -837,6 +842,10 @@ static struct of_device_id sata_rcar_match[] = {
 		.compatible = "renesas,sata-r8a7790",
 		.data = (void *)RCAR_GEN2_SATA
 	},
+	{
+		.compatible = "renesas,sata-r8a7790-es1",
+		.data = (void *)RCAR_R8A7790_ES1_SATA
+	},
 	{
 		.compatible = "renesas,sata-r8a7791",
 		.data = (void *)RCAR_GEN2_SATA
@@ -849,6 +858,7 @@ static const struct platform_device_id sata_rcar_id_table[] = {
 	{ "sata_rcar", RCAR_GEN1_SATA }, /* Deprecated by "sata-r8a7779" */
 	{ "sata-r8a7779", RCAR_GEN1_SATA },
 	{ "sata-r8a7790", RCAR_GEN2_SATA },
+	{ "sata-r8a7790-es1", RCAR_R8A7790_ES1_SATA },
 	{ "sata-r8a7791", RCAR_GEN2_SATA },
 	{ },
 };

commit 65c662ab63d2055d883bc97386aa779cbbb81f93
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:17 2014 +0200

    ata: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 61eb6d77dac7..ad7725245d39 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -989,7 +989,6 @@ static struct platform_driver sata_rcar_driver = {
 	.id_table	= sata_rcar_id_table,
 	.driver = {
 		.name		= DRV_NAME,
-		.owner		= THIS_MODULE,
 		.of_match_table	= sata_rcar_match,
 #ifdef CONFIG_PM_SLEEP
 		.pm		= &sata_rcar_pm_ops,

commit 58eb8cd565af4a104395e3c10443951c1f73dafe
Author: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
Date:   Wed May 7 17:17:44 2014 +0200

    ata: use CONFIG_PM_SLEEP instead of CONFIG_PM where applicable in host drivers
    
    This patch fixes host drivers to use CONFIG_PM_SLEEP instead of CONFIG_PM
    where applicable.  Benefits of this change:
    
    * unused code is not being compiled in for CONFIG_PM=y, CONFIG_PM_SLEEP=n
      and CONFIG_PM_RUNTIME=y configurations
    
    * easier transition to use struct dev_pm_ops and SIMPLE_DEV_PM_OPS() in
      the future
    
    * more consistent code (there are host drivers which are using the correct
      CONFIG_PM_SLEEP checks already)
    
    The patch leaves the core libata code and ->port_[suspend,resume] support
    in sata_[inic162x,nv,sil24].c alone for now.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 2b25bd83fc9d..61eb6d77dac7 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -937,7 +937,7 @@ static int sata_rcar_remove(struct platform_device *pdev)
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 static int sata_rcar_suspend(struct device *dev)
 {
 	struct ata_host *host = dev_get_drvdata(dev);
@@ -991,7 +991,7 @@ static struct platform_driver sata_rcar_driver = {
 		.name		= DRV_NAME,
 		.owner		= THIS_MODULE,
 		.of_match_table	= sata_rcar_match,
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 		.pm		= &sata_rcar_pm_ops,
 #endif
 	},

commit e67adb4e669db834c1f95cbdf99bb4e9ec8455b3
Author: Valentine Barshak <valentine.barshak@cogentembedded.com>
Date:   Fri Nov 8 16:09:29 2013 +0400

    sata_rcar: Add R-Car Gen2 SATA PHY support
    
    R-Car Gen2 SoCs have a different PHY which is not compatible
    with the older R-Car H1 (R8A7779) version.
    This adds OF/platform device id tables and PHY initialization
    callbacks for the following Gen2 SoCs:
      * R-Car H2: R8A7790;
      * R-Car M2: R8A7791.
    
    PHY initialization method is chosen based on the device id.
    Default PHY settings are applied for Gen2 SoCs, which should
    suit the Gen2 boards available.
    
    While at it, this also adds "sata-r8a7779" compatibility string
    for R8A7779 SATA, while keeping the old one for compatibility.
    
    Signed-off-by: Valentine Barshak <valentine.barshak@cogentembedded.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 1dae9a9009f7..2b25bd83fc9d 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -15,6 +15,7 @@
 #include <linux/module.h>
 #include <linux/ata.h>
 #include <linux/libata.h>
+#include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
 #include <linux/err.h>
@@ -123,12 +124,37 @@
 
 #define SATA_RCAR_DMA_BOUNDARY		0x1FFFFFFEUL
 
+/* Gen2 Physical Layer Control Registers */
+#define RCAR_GEN2_PHY_CTL1_REG		0x1704
+#define RCAR_GEN2_PHY_CTL1		0x34180002
+#define RCAR_GEN2_PHY_CTL1_SS		0xC180	/* Spread Spectrum */
+
+#define RCAR_GEN2_PHY_CTL2_REG		0x170C
+#define RCAR_GEN2_PHY_CTL2		0x00002303
+
+#define RCAR_GEN2_PHY_CTL3_REG		0x171C
+#define RCAR_GEN2_PHY_CTL3		0x000B0194
+
+#define RCAR_GEN2_PHY_CTL4_REG		0x1724
+#define RCAR_GEN2_PHY_CTL4		0x00030994
+
+#define RCAR_GEN2_PHY_CTL5_REG		0x1740
+#define RCAR_GEN2_PHY_CTL5		0x03004001
+#define RCAR_GEN2_PHY_CTL5_DC		BIT(1)	/* DC connection */
+#define RCAR_GEN2_PHY_CTL5_TR		BIT(2)	/* Termination Resistor */
+
+enum sata_rcar_type {
+	RCAR_GEN1_SATA,
+	RCAR_GEN2_SATA,
+};
+
 struct sata_rcar_priv {
 	void __iomem *base;
 	struct clk *clk;
+	enum sata_rcar_type type;
 };
 
-static void sata_rcar_phy_initialize(struct sata_rcar_priv *priv)
+static void sata_rcar_gen1_phy_preinit(struct sata_rcar_priv *priv)
 {
 	void __iomem *base = priv->base;
 
@@ -141,8 +167,8 @@ static void sata_rcar_phy_initialize(struct sata_rcar_priv *priv)
 	iowrite32(0, base + SATAPHYRESET_REG);
 }
 
-static void sata_rcar_phy_write(struct sata_rcar_priv *priv, u16 reg, u32 val,
-				int group)
+static void sata_rcar_gen1_phy_write(struct sata_rcar_priv *priv, u16 reg,
+				     u32 val, int group)
 {
 	void __iomem *base = priv->base;
 	int timeout;
@@ -170,6 +196,29 @@ static void sata_rcar_phy_write(struct sata_rcar_priv *priv, u16 reg, u32 val,
 	iowrite32(0, base + SATAPHYADDR_REG);
 }
 
+static void sata_rcar_gen1_phy_init(struct sata_rcar_priv *priv)
+{
+	sata_rcar_gen1_phy_preinit(priv);
+	sata_rcar_gen1_phy_write(priv, SATAPCTLR1_REG, 0x00200188, 0);
+	sata_rcar_gen1_phy_write(priv, SATAPCTLR1_REG, 0x00200188, 1);
+	sata_rcar_gen1_phy_write(priv, SATAPCTLR3_REG, 0x0000A061, 0);
+	sata_rcar_gen1_phy_write(priv, SATAPCTLR2_REG, 0x20000000, 0);
+	sata_rcar_gen1_phy_write(priv, SATAPCTLR2_REG, 0x20000000, 1);
+	sata_rcar_gen1_phy_write(priv, SATAPCTLR4_REG, 0x28E80000, 0);
+}
+
+static void sata_rcar_gen2_phy_init(struct sata_rcar_priv *priv)
+{
+	void __iomem *base = priv->base;
+
+	iowrite32(RCAR_GEN2_PHY_CTL1, base + RCAR_GEN2_PHY_CTL1_REG);
+	iowrite32(RCAR_GEN2_PHY_CTL2, base + RCAR_GEN2_PHY_CTL2_REG);
+	iowrite32(RCAR_GEN2_PHY_CTL3, base + RCAR_GEN2_PHY_CTL3_REG);
+	iowrite32(RCAR_GEN2_PHY_CTL4, base + RCAR_GEN2_PHY_CTL4_REG);
+	iowrite32(RCAR_GEN2_PHY_CTL5 | RCAR_GEN2_PHY_CTL5_DC |
+		  RCAR_GEN2_PHY_CTL5_TR, base + RCAR_GEN2_PHY_CTL5_REG);
+}
+
 static void sata_rcar_freeze(struct ata_port *ap)
 {
 	struct sata_rcar_priv *priv = ap->host->private_data;
@@ -738,13 +787,17 @@ static void sata_rcar_init_controller(struct ata_host *host)
 	u32 val;
 
 	/* reset and setup phy */
-	sata_rcar_phy_initialize(priv);
-	sata_rcar_phy_write(priv, SATAPCTLR1_REG, 0x00200188, 0);
-	sata_rcar_phy_write(priv, SATAPCTLR1_REG, 0x00200188, 1);
-	sata_rcar_phy_write(priv, SATAPCTLR3_REG, 0x0000A061, 0);
-	sata_rcar_phy_write(priv, SATAPCTLR2_REG, 0x20000000, 0);
-	sata_rcar_phy_write(priv, SATAPCTLR2_REG, 0x20000000, 1);
-	sata_rcar_phy_write(priv, SATAPCTLR4_REG, 0x28E80000, 0);
+	switch (priv->type) {
+	case RCAR_GEN1_SATA:
+		sata_rcar_gen1_phy_init(priv);
+		break;
+	case RCAR_GEN2_SATA:
+		sata_rcar_gen2_phy_init(priv);
+		break;
+	default:
+		dev_warn(host->dev, "SATA phy is not initialized\n");
+		break;
+	}
 
 	/* SATA-IP reset state */
 	val = ioread32(base + ATAPI_CONTROL1_REG);
@@ -770,8 +823,40 @@ static void sata_rcar_init_controller(struct ata_host *host)
 	iowrite32(ATAPI_INT_ENABLE_SATAINT, base + ATAPI_INT_ENABLE_REG);
 }
 
+static struct of_device_id sata_rcar_match[] = {
+	{
+		/* Deprecated by "renesas,sata-r8a7779" */
+		.compatible = "renesas,rcar-sata",
+		.data = (void *)RCAR_GEN1_SATA,
+	},
+	{
+		.compatible = "renesas,sata-r8a7779",
+		.data = (void *)RCAR_GEN1_SATA,
+	},
+	{
+		.compatible = "renesas,sata-r8a7790",
+		.data = (void *)RCAR_GEN2_SATA
+	},
+	{
+		.compatible = "renesas,sata-r8a7791",
+		.data = (void *)RCAR_GEN2_SATA
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, sata_rcar_match);
+
+static const struct platform_device_id sata_rcar_id_table[] = {
+	{ "sata_rcar", RCAR_GEN1_SATA }, /* Deprecated by "sata-r8a7779" */
+	{ "sata-r8a7779", RCAR_GEN1_SATA },
+	{ "sata-r8a7790", RCAR_GEN2_SATA },
+	{ "sata-r8a7791", RCAR_GEN2_SATA },
+	{ },
+};
+MODULE_DEVICE_TABLE(platform, sata_rcar_id_table);
+
 static int sata_rcar_probe(struct platform_device *pdev)
 {
+	const struct of_device_id *of_id;
 	struct ata_host *host;
 	struct sata_rcar_priv *priv;
 	struct resource *mem;
@@ -787,6 +872,12 @@ static int sata_rcar_probe(struct platform_device *pdev)
 	if (!priv)
 		return -ENOMEM;
 
+	of_id = of_match_device(sata_rcar_match, &pdev->dev);
+	if (of_id)
+		priv->type = (enum sata_rcar_type)of_id->data;
+	else
+		priv->type = platform_get_device_id(pdev)->driver_data;
+
 	priv->clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(priv->clk)) {
 		dev_err(&pdev->dev, "failed to get access to sata clock\n");
@@ -892,15 +983,10 @@ static const struct dev_pm_ops sata_rcar_pm_ops = {
 };
 #endif
 
-static struct of_device_id sata_rcar_match[] = {
-	{ .compatible = "renesas,rcar-sata", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, sata_rcar_match);
-
 static struct platform_driver sata_rcar_driver = {
 	.probe		= sata_rcar_probe,
 	.remove		= sata_rcar_remove,
+	.id_table	= sata_rcar_id_table,
 	.driver = {
 		.name		= DRV_NAME,
 		.owner		= THIS_MODULE,

commit 329b4287a4fc1d5d98a9f74b6f4f5d986a6c61f4
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Mon Oct 28 23:49:21 2013 +0100

    sata_rcar: Convert to clk_prepare/unprepare
    
    Turn clk_enable() and clk_disable() calls into clk_prepare_enable() and
    clk_disable_unprepare() to get ready for the migration to the common
    clock framework.
    
    Cc: linux-ide@vger.kernel.org
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index c2d95e9fb971..1dae9a9009f7 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -792,7 +792,7 @@ static int sata_rcar_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "failed to get access to sata clock\n");
 		return PTR_ERR(priv->clk);
 	}
-	clk_enable(priv->clk);
+	clk_prepare_enable(priv->clk);
 
 	host = ata_host_alloc(&pdev->dev, 1);
 	if (!host) {
@@ -822,7 +822,7 @@ static int sata_rcar_probe(struct platform_device *pdev)
 		return 0;
 
 cleanup:
-	clk_disable(priv->clk);
+	clk_disable_unprepare(priv->clk);
 
 	return ret;
 }
@@ -841,7 +841,7 @@ static int sata_rcar_remove(struct platform_device *pdev)
 	iowrite32(0, base + SATAINTSTAT_REG);
 	iowrite32(0x7ff, base + SATAINTMASK_REG);
 
-	clk_disable(priv->clk);
+	clk_disable_unprepare(priv->clk);
 
 	return 0;
 }
@@ -861,7 +861,7 @@ static int sata_rcar_suspend(struct device *dev)
 		/* mask */
 		iowrite32(0x7ff, base + SATAINTMASK_REG);
 
-		clk_disable(priv->clk);
+		clk_disable_unprepare(priv->clk);
 	}
 
 	return ret;
@@ -873,7 +873,7 @@ static int sata_rcar_resume(struct device *dev)
 	struct sata_rcar_priv *priv = host->private_data;
 	void __iomem *base = priv->base;
 
-	clk_enable(priv->clk);
+	clk_prepare_enable(priv->clk);
 
 	/* ack and mask */
 	iowrite32(0, base + SATAINTSTAT_REG);

commit 4a9b7f9f2704405c05b213f8f51e9f7f1fe02d1a
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Wed Aug 14 11:11:31 2013 +0200

    drivers/ata/sata_rcar.c: simplify use of devm_ioremap_resource
    
    Remove unneeded error handling on the result of a call to
    platform_get_resource when the value is passed to devm_ioremap_resource.
    
    Move the call to platform_get_resource adjacent to the call to
    devm_ioremap_resource to make the connection between them more clear.
    
    A simplified version of the semantic patch that makes this change is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    expression pdev,res,n,e,e1;
    expression ret != 0;
    identifier l;
    @@
    
    - res = platform_get_resource(pdev, IORESOURCE_MEM, n);
      ... when != res
    - if (res == NULL) { ... \(goto l;\|return ret;\) }
      ... when != res
    + res = platform_get_resource(pdev, IORESOURCE_MEM, n);
      e = devm_ioremap_resource(e1, res);
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 8108eb065444..c2d95e9fb971 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -778,10 +778,6 @@ static int sata_rcar_probe(struct platform_device *pdev)
 	int irq;
 	int ret = 0;
 
-	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (mem == NULL)
-		return -EINVAL;
-
 	irq = platform_get_irq(pdev, 0);
 	if (irq <= 0)
 		return -EINVAL;
@@ -807,6 +803,7 @@ static int sata_rcar_probe(struct platform_device *pdev)
 
 	host->private_data = priv;
 
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	priv->base = devm_ioremap_resource(&pdev->dev, mem);
 	if (IS_ERR(priv->base)) {
 		ret = PTR_ERR(priv->base);

commit 5a0a6a4f17a3606289f96356383db695a555bdbd
Merge: 9bbb1b0e2a83 1cfc7df3de10
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Jul 2 19:54:16 2013 -0700

    Merge branch 'libata/for-3.10-fixes' into libata/for-3.11
    
    libata/for-3.10-fixes never got submitted during v3.10 cycle.  Merge
    it into for-3.11 so that it can be routed together with other changes
    scheduled for v3.11.
    
    Three trivial conflicts in drivers/ata/sata_rcar.c.  All are caused by
    1b20f6a9ad ("sata_rcar: add 'base' local variable to some functions")
    conflicting with logic updates in for-3.10-fixes.  The offending
    commit simply adds local variable @base on functions which
    dereferences sata_rcar_priv->base multiple times.  The resolutions are
    trivial - applying s/priv->base/base/ in the conflicting logic
    updates.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>

commit 5ba59b59cb413b9d89f40532bad3529d5185dd3c
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Mon Jun 3 13:16:05 2013 -0700

    sata_rcar: fix compilation warning in sata_rcar_thaw()
    
    When compiling the driver with gcc 4.8, it gives the following warning:
    
     drivers/ata/sata_rcar.c: In function `sata_rcar_thaw':
     drivers/ata/sata_rcar.c:183:2: warning: large integer implicitly truncated to unsigned type [-Woverflow]
    
    Fix the warning by explicit cast of the 'unsigned long' value to 'u32'.
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 249c8a289bfd..d51423463479 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -180,7 +180,7 @@ static void sata_rcar_thaw(struct ata_port *ap)
 	struct sata_rcar_priv *priv = ap->host->private_data;
 
 	/* ack */
-	iowrite32(~SATA_RCAR_INT_MASK, priv->base + SATAINTSTAT_REG);
+	iowrite32(~(u32)SATA_RCAR_INT_MASK, priv->base + SATAINTSTAT_REG);
 
 	ata_sff_thaw(ap);
 

commit 52a2a1087b5924de00484f35ef5e2a73f61dbd22
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Sat Jun 1 02:38:35 2013 +0400

    sata_rcar: fix interrupt handling
    
    The driver's interrupt handling code is too picky in deciding whether it should
    handle an interrupt or not which causes completely unneeded spurious interrupts.
    Thus make sata_rcar_{ata|serr}_interrupt() *void*; add ATA status register read
    to sata_rcar_ata_interrupt() to clear an unexpected ATA interrupt -- it doesn't
    get cleared by writing to the SATAINTSTAT register in the interrupt mode we use.
    
    Also, in sata_rcar_ata_interrupt() we should check SATAINTSTAT register only for
    enabled interrupts and we should clear  only those interrupts  that we have read
    as active first time around, because else we have  a  race and risk clearing  an
    interrupt that  can  occur between read  and write of the  SATAINTSTAT  register
    and never registering it...
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index a8e091aafdde..249c8a289bfd 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -619,17 +619,16 @@ static struct ata_port_operations sata_rcar_port_ops = {
 	.bmdma_status		= sata_rcar_bmdma_status,
 };
 
-static int sata_rcar_serr_interrupt(struct ata_port *ap)
+static void sata_rcar_serr_interrupt(struct ata_port *ap)
 {
 	struct sata_rcar_priv *priv = ap->host->private_data;
 	struct ata_eh_info *ehi = &ap->link.eh_info;
 	int freeze = 0;
-	int handled = 0;
 	u32 serror;
 
 	serror = ioread32(priv->base + SCRSERR_REG);
 	if (!serror)
-		return 0;
+		return;
 
 	DPRINTK("SError @host_intr: 0x%x\n", serror);
 
@@ -642,7 +641,6 @@ static int sata_rcar_serr_interrupt(struct ata_port *ap)
 		ata_ehi_push_desc(ehi, "%s", "hotplug");
 
 		freeze = serror & SERR_COMM_WAKE ? 0 : 1;
-		handled = 1;
 	}
 
 	/* freeze or abort */
@@ -650,11 +648,9 @@ static int sata_rcar_serr_interrupt(struct ata_port *ap)
 		ata_port_freeze(ap);
 	else
 		ata_port_abort(ap);
-
-	return handled;
 }
 
-static int sata_rcar_ata_interrupt(struct ata_port *ap)
+static void sata_rcar_ata_interrupt(struct ata_port *ap)
 {
 	struct ata_queued_cmd *qc;
 	int handled = 0;
@@ -663,7 +659,9 @@ static int sata_rcar_ata_interrupt(struct ata_port *ap)
 	if (qc)
 		handled |= ata_bmdma_port_intr(ap, qc);
 
-	return handled;
+	/* be sure to clear ATA interrupt */
+	if (!handled)
+		sata_rcar_check_status(ap);
 }
 
 static irqreturn_t sata_rcar_interrupt(int irq, void *dev_instance)
@@ -678,20 +676,21 @@ static irqreturn_t sata_rcar_interrupt(int irq, void *dev_instance)
 	spin_lock_irqsave(&host->lock, flags);
 
 	sataintstat = ioread32(priv->base + SATAINTSTAT_REG);
+	sataintstat &= SATA_RCAR_INT_MASK;
 	if (!sataintstat)
 		goto done;
 	/* ack */
-	iowrite32(sataintstat & ~SATA_RCAR_INT_MASK,
-		 priv->base + SATAINTSTAT_REG);
+	iowrite32(~sataintstat & 0x7ff, priv->base + SATAINTSTAT_REG);
 
 	ap = host->ports[0];
 
 	if (sataintstat & SATAINTSTAT_ATA)
-		handled |= sata_rcar_ata_interrupt(ap);
+		sata_rcar_ata_interrupt(ap);
 
 	if (sataintstat & SATAINTSTAT_SERR)
-		handled |= sata_rcar_serr_interrupt(ap);
+		sata_rcar_serr_interrupt(ap);
 
+	handled = 1;
 done:
 	spin_unlock_irqrestore(&host->lock, flags);
 

commit 1b20f6a9adaa4b88d520d279c3d605f65b898625
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Tue May 28 02:46:41 2013 +0400

    sata_rcar: add 'base' local variable to some functions
    
    The 'base' field of 'struct sata_rcar_priv' is used very often
    throughout the driver, so it seems worth loading it into a local
    variable if it's used more than once in a function.
    
    While at it, put some unitialized variables after intialized ones for
    aesthetic reasons. :-)
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 178165be0c32..f0d3e43570ee 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -130,41 +130,44 @@ struct sata_rcar_priv {
 
 static void sata_rcar_phy_initialize(struct sata_rcar_priv *priv)
 {
+	void __iomem *base = priv->base;
+
 	/* idle state */
-	iowrite32(0, priv->base + SATAPHYADDR_REG);
+	iowrite32(0, base + SATAPHYADDR_REG);
 	/* reset */
-	iowrite32(SATAPHYRESET_PHYRST, priv->base + SATAPHYRESET_REG);
+	iowrite32(SATAPHYRESET_PHYRST, base + SATAPHYRESET_REG);
 	udelay(10);
 	/* deassert reset */
-	iowrite32(0, priv->base + SATAPHYRESET_REG);
+	iowrite32(0, base + SATAPHYRESET_REG);
 }
 
 static void sata_rcar_phy_write(struct sata_rcar_priv *priv, u16 reg, u32 val,
 				int group)
 {
+	void __iomem *base = priv->base;
 	int timeout;
 
 	/* deassert reset */
-	iowrite32(0, priv->base + SATAPHYRESET_REG);
+	iowrite32(0, base + SATAPHYRESET_REG);
 	/* lane 1 */
-	iowrite32(SATAPHYACCEN_PHYLANE, priv->base + SATAPHYACCEN_REG);
+	iowrite32(SATAPHYACCEN_PHYLANE, base + SATAPHYACCEN_REG);
 	/* write phy register value */
-	iowrite32(val, priv->base + SATAPHYWDATA_REG);
+	iowrite32(val, base + SATAPHYWDATA_REG);
 	/* set register group */
 	if (group)
 		reg |= SATAPHYADDR_PHYRATEMODE;
 	/* write command */
-	iowrite32(SATAPHYADDR_PHYCMD_WRITE | reg, priv->base + SATAPHYADDR_REG);
+	iowrite32(SATAPHYADDR_PHYCMD_WRITE | reg, base + SATAPHYADDR_REG);
 	/* wait for ack */
 	for (timeout = 0; timeout < 100; timeout++) {
-		val = ioread32(priv->base + SATAPHYACK_REG);
+		val = ioread32(base + SATAPHYACK_REG);
 		if (val & SATAPHYACK_PHYACK)
 			break;
 	}
 	if (timeout >= 100)
 		pr_err("%s timeout\n", __func__);
 	/* idle state */
-	iowrite32(0, priv->base + SATAPHYADDR_REG);
+	iowrite32(0, base + SATAPHYADDR_REG);
 }
 
 static void sata_rcar_freeze(struct ata_port *ap)
@@ -180,14 +183,15 @@ static void sata_rcar_freeze(struct ata_port *ap)
 static void sata_rcar_thaw(struct ata_port *ap)
 {
 	struct sata_rcar_priv *priv = ap->host->private_data;
+	void __iomem *base = priv->base;
 
 	/* ack */
-	iowrite32(~SATA_RCAR_INT_MASK, priv->base + SATAINTSTAT_REG);
+	iowrite32(~SATA_RCAR_INT_MASK, base + SATAINTSTAT_REG);
 
 	ata_sff_thaw(ap);
 
 	/* unmask */
-	iowrite32(0x7ff & ~SATA_RCAR_INT_MASK, priv->base + SATAINTMASK_REG);
+	iowrite32(0x7ff & ~SATA_RCAR_INT_MASK, base + SATAINTMASK_REG);
 }
 
 static void sata_rcar_ioread16_rep(void __iomem *reg, void *buffer, int count)
@@ -509,15 +513,16 @@ static void sata_rcar_bmdma_setup(struct ata_queued_cmd *qc)
 {
 	struct ata_port *ap = qc->ap;
 	unsigned int rw = qc->tf.flags & ATA_TFLAG_WRITE;
-	u32 dmactl;
 	struct sata_rcar_priv *priv = ap->host->private_data;
+	void __iomem *base = priv->base;
+	u32 dmactl;
 
 	/* load PRD table addr. */
 	mb();   /* make sure PRD table writes are visible to controller */
-	iowrite32(ap->bmdma_prd_dma, priv->base + ATAPI_DTB_ADR_REG);
+	iowrite32(ap->bmdma_prd_dma, base + ATAPI_DTB_ADR_REG);
 
 	/* specify data direction, triple-check start bit is clear */
-	dmactl = ioread32(priv->base + ATAPI_CONTROL1_REG);
+	dmactl = ioread32(base + ATAPI_CONTROL1_REG);
 	dmactl &= ~(ATAPI_CONTROL1_RW | ATAPI_CONTROL1_STOP);
 	if (dmactl & ATAPI_CONTROL1_START) {
 		dmactl &= ~ATAPI_CONTROL1_START;
@@ -525,7 +530,7 @@ static void sata_rcar_bmdma_setup(struct ata_queued_cmd *qc)
 	}
 	if (!rw)
 		dmactl |= ATAPI_CONTROL1_RW;
-	iowrite32(dmactl, priv->base + ATAPI_CONTROL1_REG);
+	iowrite32(dmactl, base + ATAPI_CONTROL1_REG);
 
 	/* issue r/w command */
 	ap->ops->sff_exec_command(ap, &qc->tf);
@@ -534,27 +539,29 @@ static void sata_rcar_bmdma_setup(struct ata_queued_cmd *qc)
 static void sata_rcar_bmdma_start(struct ata_queued_cmd *qc)
 {
 	struct ata_port *ap = qc->ap;
-	u32 dmactl;
 	struct sata_rcar_priv *priv = ap->host->private_data;
+	void __iomem *base = priv->base;
+	u32 dmactl;
 
 	/* start host DMA transaction */
-	dmactl = ioread32(priv->base + ATAPI_CONTROL1_REG);
+	dmactl = ioread32(base + ATAPI_CONTROL1_REG);
 	dmactl |= ATAPI_CONTROL1_START;
-	iowrite32(dmactl, priv->base + ATAPI_CONTROL1_REG);
+	iowrite32(dmactl, base + ATAPI_CONTROL1_REG);
 }
 
 static void sata_rcar_bmdma_stop(struct ata_queued_cmd *qc)
 {
 	struct ata_port *ap = qc->ap;
 	struct sata_rcar_priv *priv = ap->host->private_data;
+	void __iomem *base = priv->base;
 	u32 dmactl;
 
 	/* force termination of DMA transfer if active */
-	dmactl = ioread32(priv->base + ATAPI_CONTROL1_REG);
+	dmactl = ioread32(base + ATAPI_CONTROL1_REG);
 	if (dmactl & ATAPI_CONTROL1_START) {
 		dmactl &= ~ATAPI_CONTROL1_START;
 		dmactl |= ATAPI_CONTROL1_STOP;
-		iowrite32(dmactl, priv->base + ATAPI_CONTROL1_REG);
+		iowrite32(dmactl, base + ATAPI_CONTROL1_REG);
 	}
 
 	/* one-PIO-cycle guaranteed wait, per spec, for HDMA1:0 transition */
@@ -564,8 +571,8 @@ static void sata_rcar_bmdma_stop(struct ata_queued_cmd *qc)
 static u8 sata_rcar_bmdma_status(struct ata_port *ap)
 {
 	struct sata_rcar_priv *priv = ap->host->private_data;
-	u32 status;
 	u8 host_stat = 0;
+	u32 status;
 
 	status = ioread32(priv->base + ATAPI_STATUS_REG);
 	if (status & ATAPI_STATUS_DEVINT)
@@ -666,19 +673,19 @@ static irqreturn_t sata_rcar_interrupt(int irq, void *dev_instance)
 {
 	struct ata_host *host = dev_instance;
 	struct sata_rcar_priv *priv = host->private_data;
-	struct ata_port *ap;
+	void __iomem *base = priv->base;
 	unsigned int handled = 0;
+	struct ata_port *ap;
 	u32 sataintstat;
 	unsigned long flags;
 
 	spin_lock_irqsave(&host->lock, flags);
 
-	sataintstat = ioread32(priv->base + SATAINTSTAT_REG);
+	sataintstat = ioread32(base + SATAINTSTAT_REG);
 	if (!sataintstat)
 		goto done;
 	/* ack */
-	iowrite32(sataintstat & ~SATA_RCAR_INT_MASK,
-		 priv->base + SATAINTSTAT_REG);
+	iowrite32(sataintstat & ~SATA_RCAR_INT_MASK, base + SATAINTSTAT_REG);
 
 	ap = host->ports[0];
 
@@ -699,15 +706,16 @@ static void sata_rcar_setup_port(struct ata_host *host)
 	struct ata_port *ap = host->ports[0];
 	struct ata_ioports *ioaddr = &ap->ioaddr;
 	struct sata_rcar_priv *priv = host->private_data;
+	void __iomem *base = priv->base;
 
 	ap->ops		= &sata_rcar_port_ops;
 	ap->pio_mask	= ATA_PIO4;
 	ap->udma_mask	= ATA_UDMA6;
 	ap->flags	|= ATA_FLAG_SATA;
 
-	ioaddr->cmd_addr = priv->base + SDATA_REG;
-	ioaddr->ctl_addr = priv->base + SSDEVCON_REG;
-	ioaddr->scr_addr = priv->base + SCRSSTS_REG;
+	ioaddr->cmd_addr = base + SDATA_REG;
+	ioaddr->ctl_addr = base + SSDEVCON_REG;
+	ioaddr->scr_addr = base + SCRSSTS_REG;
 	ioaddr->altstatus_addr = ioaddr->ctl_addr;
 
 	ioaddr->data_addr	= ioaddr->cmd_addr + (ATA_REG_DATA << 2);
@@ -725,6 +733,7 @@ static void sata_rcar_setup_port(struct ata_host *host)
 static void sata_rcar_init_controller(struct ata_host *host)
 {
 	struct sata_rcar_priv *priv = host->private_data;
+	void __iomem *base = priv->base;
 	u32 val;
 
 	/* reset and setup phy */
@@ -737,27 +746,27 @@ static void sata_rcar_init_controller(struct ata_host *host)
 	sata_rcar_phy_write(priv, SATAPCTLR4_REG, 0x28E80000, 0);
 
 	/* SATA-IP reset state */
-	val = ioread32(priv->base + ATAPI_CONTROL1_REG);
+	val = ioread32(base + ATAPI_CONTROL1_REG);
 	val |= ATAPI_CONTROL1_RESET;
-	iowrite32(val, priv->base + ATAPI_CONTROL1_REG);
+	iowrite32(val, base + ATAPI_CONTROL1_REG);
 
 	/* ISM mode, PRD mode, DTEND flag at bit 0 */
-	val = ioread32(priv->base + ATAPI_CONTROL1_REG);
+	val = ioread32(base + ATAPI_CONTROL1_REG);
 	val |= ATAPI_CONTROL1_ISM;
 	val |= ATAPI_CONTROL1_DESE;
 	val |= ATAPI_CONTROL1_DTA32M;
-	iowrite32(val, priv->base + ATAPI_CONTROL1_REG);
+	iowrite32(val, base + ATAPI_CONTROL1_REG);
 
 	/* Release the SATA-IP from the reset state */
-	val = ioread32(priv->base + ATAPI_CONTROL1_REG);
+	val = ioread32(base + ATAPI_CONTROL1_REG);
 	val &= ~ATAPI_CONTROL1_RESET;
-	iowrite32(val, priv->base + ATAPI_CONTROL1_REG);
+	iowrite32(val, base + ATAPI_CONTROL1_REG);
 
 	/* ack and mask */
-	iowrite32(0, priv->base + SATAINTSTAT_REG);
-	iowrite32(0x7ff, priv->base + SATAINTMASK_REG);
+	iowrite32(0, base + SATAINTSTAT_REG);
+	iowrite32(0x7ff, base + SATAINTMASK_REG);
 	/* enable interrupts */
-	iowrite32(ATAPI_INT_ENABLE_SATAINT, priv->base + ATAPI_INT_ENABLE_REG);
+	iowrite32(ATAPI_INT_ENABLE_SATAINT, base + ATAPI_INT_ENABLE_REG);
 }
 
 static int sata_rcar_probe(struct platform_device *pdev)
@@ -824,14 +833,15 @@ static int sata_rcar_remove(struct platform_device *pdev)
 {
 	struct ata_host *host = platform_get_drvdata(pdev);
 	struct sata_rcar_priv *priv = host->private_data;
+	void __iomem *base = priv->base;
 
 	ata_host_detach(host);
 
 	/* disable interrupts */
-	iowrite32(0, priv->base + ATAPI_INT_ENABLE_REG);
+	iowrite32(0, base + ATAPI_INT_ENABLE_REG);
 	/* ack and mask */
-	iowrite32(0, priv->base + SATAINTSTAT_REG);
-	iowrite32(0x7ff, priv->base + SATAINTMASK_REG);
+	iowrite32(0, base + SATAINTSTAT_REG);
+	iowrite32(0x7ff, base + SATAINTMASK_REG);
 
 	clk_disable(priv->clk);
 
@@ -843,14 +853,15 @@ static int sata_rcar_suspend(struct device *dev)
 {
 	struct ata_host *host = dev_get_drvdata(dev);
 	struct sata_rcar_priv *priv = host->private_data;
+	void __iomem *base = priv->base;
 	int ret;
 
 	ret = ata_host_suspend(host, PMSG_SUSPEND);
 	if (!ret) {
 		/* disable interrupts */
-		iowrite32(0, priv->base + ATAPI_INT_ENABLE_REG);
+		iowrite32(0, base + ATAPI_INT_ENABLE_REG);
 		/* mask */
-		iowrite32(0x7ff, priv->base + SATAINTMASK_REG);
+		iowrite32(0x7ff, base + SATAINTMASK_REG);
 
 		clk_disable(priv->clk);
 	}
@@ -862,14 +873,15 @@ static int sata_rcar_resume(struct device *dev)
 {
 	struct ata_host *host = dev_get_drvdata(dev);
 	struct sata_rcar_priv *priv = host->private_data;
+	void __iomem *base = priv->base;
 
 	clk_enable(priv->clk);
 
 	/* ack and mask */
-	iowrite32(0, priv->base + SATAINTSTAT_REG);
-	iowrite32(0x7ff, priv->base + SATAINTMASK_REG);
+	iowrite32(0, base + SATAINTSTAT_REG);
+	iowrite32(0x7ff, base + SATAINTMASK_REG);
 	/* enable interrupts */
-	iowrite32(ATAPI_INT_ENABLE_SATAINT, priv->base + ATAPI_INT_ENABLE_REG);
+	iowrite32(ATAPI_INT_ENABLE_SATAINT, base + ATAPI_INT_ENABLE_REG);
 
 	ata_host_resume(host);
 

commit 8bfbeed58665dbbf63813017712bd0c8e978379e
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Tue May 28 02:45:08 2013 +0400

    sata_rcar: correct 'sata_rcar_sht'
    
    Using ATA_BMDMA_SHT() to intialize 'sata_rcar_sht' was suboptimal as
    the R-Car descriptor table transfer counter is 28 bits wide (bit 1 to
    bit 28), so that the 'dma_boundary' field of 0xFFFF is just too small,
    as well as the 'sg_tablesize' field of 128.  Use ATA_BASE_SHT() to
    initialize 'sata_rcar_sht' instead and give proper values to the
    'dma_boundary' and 'sg_tablesize' fields explicitly.
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 629b07c452c5..178165be0c32 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -121,6 +121,8 @@
 /* Descriptor table word 0 bit (when DTA32M = 1) */
 #define SATA_RCAR_DTEND			BIT(0)
 
+#define SATA_RCAR_DMA_BOUNDARY		0x1FFFFFFEUL
+
 struct sata_rcar_priv {
 	void __iomem *base;
 	struct clk *clk;
@@ -575,7 +577,14 @@ static u8 sata_rcar_bmdma_status(struct ata_port *ap)
 }
 
 static struct scsi_host_template sata_rcar_sht = {
-	ATA_BMDMA_SHT(DRV_NAME),
+	ATA_BASE_SHT(DRV_NAME),
+	/*
+	 * This controller allows transfer chunks up to 512MB which cross 64KB
+	 * boundaries, therefore the DMA limits are more relaxed than standard
+	 * ATA SFF.
+	 */
+	.sg_tablesize		= ATA_MAX_PRD,
+	.dma_boundary		= SATA_RCAR_DMA_BOUNDARY,
 };
 
 static struct ata_port_operations sata_rcar_port_ops = {

commit 333279c82b984f3eac61feff2b76a8b79e3db6c8
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Tue May 28 02:43:23 2013 +0400

    sata_rcar: kill superfluous code in sata_rcar_bmdma_fill_sg()
    
    I've modified sata_rcar_bmdma_fill_sg() to take care of splitting long
    scatter/ gather segments due to the descriptor table transfer counter
    being only 28 bits wide (bit 1 to bit 28) but that was in vain as even
    if 'sata_rcar_sht' specified a correct 'dma_boundary' field, the DMA
    and block layers would have split the S/G segments on the necassary
    boundaries. Since the driver uses ATA_BMDMA_SHT() to initilaize
    'sata_rcar_sht', the boundary is much smaller, only 0xFFFF, so the
    code I've added is even more useless, and it's better to just remove
    it.
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 889c25a6337e..629b07c452c5 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -474,11 +474,10 @@ static void sata_rcar_bmdma_fill_sg(struct ata_queued_cmd *qc)
 	struct ata_port *ap = qc->ap;
 	struct ata_bmdma_prd *prd = ap->bmdma_prd;
 	struct scatterlist *sg;
-	unsigned int si, pi;
+	unsigned int si;
 
-	pi = 0;
 	for_each_sg(qc->sg, sg, qc->n_elem, si) {
-		u32 addr, sg_len, len;
+		u32 addr, sg_len;
 
 		/*
 		 * Note: h/w doesn't support 64-bit, so we unconditionally
@@ -487,24 +486,13 @@ static void sata_rcar_bmdma_fill_sg(struct ata_queued_cmd *qc)
 		addr = (u32)sg_dma_address(sg);
 		sg_len = sg_dma_len(sg);
 
-		/* H/w transfer count is only 29 bits long, let's be careful */
-		while (sg_len) {
-			len = sg_len;
-			if (len > 0x1ffffffe)
-				len = 0x1ffffffe;
-
-			prd[pi].addr = cpu_to_le32(addr);
-			prd[pi].flags_len = cpu_to_le32(len);
-			VPRINTK("PRD[%u] = (0x%X, 0x%X)\n", pi, addr, len);
-
-			pi++;
-			sg_len -= len;
-			addr += len;
-		}
+		prd[si].addr = cpu_to_le32(addr);
+		prd[si].flags_len = cpu_to_le32(sg_len);
+		VPRINTK("PRD[%u] = (0x%X, 0x%X)\n", si, addr, sg_len);
 	}
 
 	/* end-of-table flag */
-	prd[pi - 1].addr |= cpu_to_le32(SATA_RCAR_DTEND);
+	prd[si - 1].addr |= cpu_to_le32(SATA_RCAR_DTEND);
 }
 
 static void sata_rcar_qc_prep(struct ata_queued_cmd *qc)

commit d89995db5f238e618389604b848b431da240eb69
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Thu May 23 19:41:21 2013 +0900

    ata: use platform_{get,set}_drvdata()
    
    Use the wrapper functions for getting and setting the driver data using
    platform_device instead of using dev_{get,set}_drvdata() with &pdev->dev,
    so we can directly pass a struct platform_device.
    
    Also, unnecessary dev_set_drvdata() is removed, because the driver core
    clears the driver data to NULL after device_release or on probe failure.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 4799868bd733..889c25a6337e 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -825,7 +825,7 @@ static int sata_rcar_probe(struct platform_device *pdev)
 
 static int sata_rcar_remove(struct platform_device *pdev)
 {
-	struct ata_host *host = dev_get_drvdata(&pdev->dev);
+	struct ata_host *host = platform_get_drvdata(pdev);
 	struct sata_rcar_priv *priv = host->private_data;
 
 	ata_host_detach(host);

commit df7e131f6359f20ed8f0a37db039c4f6420a18c2
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Tue May 21 23:07:54 2013 +0400

    sata_rcar: clear STOP bit in bmdma_start() method
    
    Iff bmdma_setup() has to stop a DMA transfer before starting a new
    one, then the STOP bit in the ATAPI_CONTROL1 register will remain set
    (it's only cleared when setting the START bit to 1) and then
    bmdma_start() method will set both START and STOP bits simultaneously
    which should abort the transfer being just started.  Avoid that by
    explicitly clearing the STOP bit in bmdma_start() method (in this case
    it will be ignored on write).
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index 4799868bd733..a8e091aafdde 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -549,6 +549,7 @@ static void sata_rcar_bmdma_start(struct ata_queued_cmd *qc)
 
 	/* start host DMA transaction */
 	dmactl = ioread32(priv->base + ATAPI_CONTROL1_REG);
+	dmactl &= ~ATAPI_CONTROL1_STOP;
 	dmactl |= ATAPI_CONTROL1_START;
 	iowrite32(dmactl, priv->base + ATAPI_CONTROL1_REG);
 }

commit 2de1d5e159ccf317a9285a0dfaa6e4262500d7dd
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Thu Apr 4 14:56:36 2013 +0530

    sata_rcar: Convert to devm_ioremap_resource()
    
    Use the newly introduced devm_ioremap_resource() instead of
    devm_request_and_ioremap() which provides more consistent error handling.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Acked-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
index caf33f620c35..4799868bd733 100644
--- a/drivers/ata/sata_rcar.c
+++ b/drivers/ata/sata_rcar.c
@@ -17,6 +17,7 @@
 #include <linux/libata.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
+#include <linux/err.h>
 
 #define DRV_NAME "sata_rcar"
 
@@ -799,9 +800,9 @@ static int sata_rcar_probe(struct platform_device *pdev)
 
 	host->private_data = priv;
 
-	priv->base = devm_request_and_ioremap(&pdev->dev, mem);
-	if (!priv->base) {
-		ret = -EADDRNOTAVAIL;
+	priv->base = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(priv->base)) {
+		ret = PTR_ERR(priv->base);
 		goto cleanup;
 	}
 

commit 163cf81d266f017d718ef786fbbb6b2513ce7ec3
Author: Vladimir Barinov <vladimir.barinov@cogentembedded.com>
Date:   Wed Feb 20 23:10:29 2013 +0300

    libata: add R-Car SATA driver
    
    Add Renesas R-Car on-chip 3Gbps SATA controller driver.
    
    Signed-off-by: Vladimir Barinov <vladimir.barinov@cogentembedded.com>
    [Sergei: few bugs fixed, significant cleanup]
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>

diff --git a/drivers/ata/sata_rcar.c b/drivers/ata/sata_rcar.c
new file mode 100644
index 000000000000..caf33f620c35
--- /dev/null
+++ b/drivers/ata/sata_rcar.c
@@ -0,0 +1,910 @@
+/*
+ * Renesas R-Car SATA driver
+ *
+ * Author: Vladimir Barinov <source@cogentembedded.com>
+ * Copyright (C) 2013 Cogent Embedded, Inc.
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/ata.h>
+#include <linux/libata.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#define DRV_NAME "sata_rcar"
+
+/* SH-Navi2G/ATAPI-ATA compatible task registers */
+#define DATA_REG			0x100
+#define SDEVCON_REG			0x138
+
+/* SH-Navi2G/ATAPI module compatible control registers */
+#define ATAPI_CONTROL1_REG		0x180
+#define ATAPI_STATUS_REG		0x184
+#define ATAPI_INT_ENABLE_REG		0x188
+#define ATAPI_DTB_ADR_REG		0x198
+#define ATAPI_DMA_START_ADR_REG		0x19C
+#define ATAPI_DMA_TRANS_CNT_REG		0x1A0
+#define ATAPI_CONTROL2_REG		0x1A4
+#define ATAPI_SIG_ST_REG		0x1B0
+#define ATAPI_BYTE_SWAP_REG		0x1BC
+
+/* ATAPI control 1 register (ATAPI_CONTROL1) bits */
+#define ATAPI_CONTROL1_ISM		BIT(16)
+#define ATAPI_CONTROL1_DTA32M		BIT(11)
+#define ATAPI_CONTROL1_RESET		BIT(7)
+#define ATAPI_CONTROL1_DESE		BIT(3)
+#define ATAPI_CONTROL1_RW		BIT(2)
+#define ATAPI_CONTROL1_STOP		BIT(1)
+#define ATAPI_CONTROL1_START		BIT(0)
+
+/* ATAPI status register (ATAPI_STATUS) bits */
+#define ATAPI_STATUS_SATAINT		BIT(11)
+#define ATAPI_STATUS_DNEND		BIT(6)
+#define ATAPI_STATUS_DEVTRM		BIT(5)
+#define ATAPI_STATUS_DEVINT		BIT(4)
+#define ATAPI_STATUS_ERR		BIT(2)
+#define ATAPI_STATUS_NEND		BIT(1)
+#define ATAPI_STATUS_ACT		BIT(0)
+
+/* Interrupt enable register (ATAPI_INT_ENABLE) bits */
+#define ATAPI_INT_ENABLE_SATAINT	BIT(11)
+#define ATAPI_INT_ENABLE_DNEND		BIT(6)
+#define ATAPI_INT_ENABLE_DEVTRM		BIT(5)
+#define ATAPI_INT_ENABLE_DEVINT		BIT(4)
+#define ATAPI_INT_ENABLE_ERR		BIT(2)
+#define ATAPI_INT_ENABLE_NEND		BIT(1)
+#define ATAPI_INT_ENABLE_ACT		BIT(0)
+
+/* Access control registers for physical layer control register */
+#define SATAPHYADDR_REG			0x200
+#define SATAPHYWDATA_REG		0x204
+#define SATAPHYACCEN_REG		0x208
+#define SATAPHYRESET_REG		0x20C
+#define SATAPHYRDATA_REG		0x210
+#define SATAPHYACK_REG			0x214
+
+/* Physical layer control address command register (SATAPHYADDR) bits */
+#define SATAPHYADDR_PHYRATEMODE		BIT(10)
+#define SATAPHYADDR_PHYCMD_READ		BIT(9)
+#define SATAPHYADDR_PHYCMD_WRITE	BIT(8)
+
+/* Physical layer control enable register (SATAPHYACCEN) bits */
+#define SATAPHYACCEN_PHYLANE		BIT(0)
+
+/* Physical layer control reset register (SATAPHYRESET) bits */
+#define SATAPHYRESET_PHYRST		BIT(1)
+#define SATAPHYRESET_PHYSRES		BIT(0)
+
+/* Physical layer control acknowledge register (SATAPHYACK) bits */
+#define SATAPHYACK_PHYACK		BIT(0)
+
+/* Serial-ATA HOST control registers */
+#define BISTCONF_REG			0x102C
+#define SDATA_REG			0x1100
+#define SSDEVCON_REG			0x1204
+
+#define SCRSSTS_REG			0x1400
+#define SCRSERR_REG			0x1404
+#define SCRSCON_REG			0x1408
+#define SCRSACT_REG			0x140C
+
+#define SATAINTSTAT_REG			0x1508
+#define SATAINTMASK_REG			0x150C
+
+/* SATA INT status register (SATAINTSTAT) bits */
+#define SATAINTSTAT_SERR		BIT(3)
+#define SATAINTSTAT_ATA			BIT(0)
+
+/* SATA INT mask register (SATAINTSTAT) bits */
+#define SATAINTMASK_SERRMSK		BIT(3)
+#define SATAINTMASK_ERRMSK		BIT(2)
+#define SATAINTMASK_ERRCRTMSK		BIT(1)
+#define SATAINTMASK_ATAMSK		BIT(0)
+
+#define SATA_RCAR_INT_MASK		(SATAINTMASK_SERRMSK | \
+					 SATAINTMASK_ATAMSK)
+
+/* Physical Layer Control Registers */
+#define SATAPCTLR1_REG			0x43
+#define SATAPCTLR2_REG			0x52
+#define SATAPCTLR3_REG			0x5A
+#define SATAPCTLR4_REG			0x60
+
+/* Descriptor table word 0 bit (when DTA32M = 1) */
+#define SATA_RCAR_DTEND			BIT(0)
+
+struct sata_rcar_priv {
+	void __iomem *base;
+	struct clk *clk;
+};
+
+static void sata_rcar_phy_initialize(struct sata_rcar_priv *priv)
+{
+	/* idle state */
+	iowrite32(0, priv->base + SATAPHYADDR_REG);
+	/* reset */
+	iowrite32(SATAPHYRESET_PHYRST, priv->base + SATAPHYRESET_REG);
+	udelay(10);
+	/* deassert reset */
+	iowrite32(0, priv->base + SATAPHYRESET_REG);
+}
+
+static void sata_rcar_phy_write(struct sata_rcar_priv *priv, u16 reg, u32 val,
+				int group)
+{
+	int timeout;
+
+	/* deassert reset */
+	iowrite32(0, priv->base + SATAPHYRESET_REG);
+	/* lane 1 */
+	iowrite32(SATAPHYACCEN_PHYLANE, priv->base + SATAPHYACCEN_REG);
+	/* write phy register value */
+	iowrite32(val, priv->base + SATAPHYWDATA_REG);
+	/* set register group */
+	if (group)
+		reg |= SATAPHYADDR_PHYRATEMODE;
+	/* write command */
+	iowrite32(SATAPHYADDR_PHYCMD_WRITE | reg, priv->base + SATAPHYADDR_REG);
+	/* wait for ack */
+	for (timeout = 0; timeout < 100; timeout++) {
+		val = ioread32(priv->base + SATAPHYACK_REG);
+		if (val & SATAPHYACK_PHYACK)
+			break;
+	}
+	if (timeout >= 100)
+		pr_err("%s timeout\n", __func__);
+	/* idle state */
+	iowrite32(0, priv->base + SATAPHYADDR_REG);
+}
+
+static void sata_rcar_freeze(struct ata_port *ap)
+{
+	struct sata_rcar_priv *priv = ap->host->private_data;
+
+	/* mask */
+	iowrite32(0x7ff, priv->base + SATAINTMASK_REG);
+
+	ata_sff_freeze(ap);
+}
+
+static void sata_rcar_thaw(struct ata_port *ap)
+{
+	struct sata_rcar_priv *priv = ap->host->private_data;
+
+	/* ack */
+	iowrite32(~SATA_RCAR_INT_MASK, priv->base + SATAINTSTAT_REG);
+
+	ata_sff_thaw(ap);
+
+	/* unmask */
+	iowrite32(0x7ff & ~SATA_RCAR_INT_MASK, priv->base + SATAINTMASK_REG);
+}
+
+static void sata_rcar_ioread16_rep(void __iomem *reg, void *buffer, int count)
+{
+	u16 *ptr = buffer;
+
+	while (count--) {
+		u16 data = ioread32(reg);
+
+		*ptr++ = data;
+	}
+}
+
+static void sata_rcar_iowrite16_rep(void __iomem *reg, void *buffer, int count)
+{
+	const u16 *ptr = buffer;
+
+	while (count--)
+		iowrite32(*ptr++, reg);
+}
+
+static u8 sata_rcar_check_status(struct ata_port *ap)
+{
+	return ioread32(ap->ioaddr.status_addr);
+}
+
+static u8 sata_rcar_check_altstatus(struct ata_port *ap)
+{
+	return ioread32(ap->ioaddr.altstatus_addr);
+}
+
+static void sata_rcar_set_devctl(struct ata_port *ap, u8 ctl)
+{
+	iowrite32(ctl, ap->ioaddr.ctl_addr);
+}
+
+static void sata_rcar_dev_select(struct ata_port *ap, unsigned int device)
+{
+	iowrite32(ATA_DEVICE_OBS, ap->ioaddr.device_addr);
+	ata_sff_pause(ap);	/* needed; also flushes, for mmio */
+}
+
+static unsigned int sata_rcar_ata_devchk(struct ata_port *ap,
+					 unsigned int device)
+{
+	struct ata_ioports *ioaddr = &ap->ioaddr;
+	u8 nsect, lbal;
+
+	sata_rcar_dev_select(ap, device);
+
+	iowrite32(0x55, ioaddr->nsect_addr);
+	iowrite32(0xaa, ioaddr->lbal_addr);
+
+	iowrite32(0xaa, ioaddr->nsect_addr);
+	iowrite32(0x55, ioaddr->lbal_addr);
+
+	iowrite32(0x55, ioaddr->nsect_addr);
+	iowrite32(0xaa, ioaddr->lbal_addr);
+
+	nsect = ioread32(ioaddr->nsect_addr);
+	lbal  = ioread32(ioaddr->lbal_addr);
+
+	if (nsect == 0x55 && lbal == 0xaa)
+		return 1;	/* found a device */
+
+	return 0;		/* nothing found */
+}
+
+static int sata_rcar_wait_after_reset(struct ata_link *link,
+				      unsigned long deadline)
+{
+	struct ata_port *ap = link->ap;
+
+	ata_msleep(ap, ATA_WAIT_AFTER_RESET);
+
+	return ata_sff_wait_ready(link, deadline);
+}
+
+static int sata_rcar_bus_softreset(struct ata_port *ap, unsigned long deadline)
+{
+	struct ata_ioports *ioaddr = &ap->ioaddr;
+
+	DPRINTK("ata%u: bus reset via SRST\n", ap->print_id);
+
+	/* software reset.  causes dev0 to be selected */
+	iowrite32(ap->ctl, ioaddr->ctl_addr);
+	udelay(20);
+	iowrite32(ap->ctl | ATA_SRST, ioaddr->ctl_addr);
+	udelay(20);
+	iowrite32(ap->ctl, ioaddr->ctl_addr);
+	ap->last_ctl = ap->ctl;
+
+	/* wait the port to become ready */
+	return sata_rcar_wait_after_reset(&ap->link, deadline);
+}
+
+static int sata_rcar_softreset(struct ata_link *link, unsigned int *classes,
+			       unsigned long deadline)
+{
+	struct ata_port *ap = link->ap;
+	unsigned int devmask = 0;
+	int rc;
+	u8 err;
+
+	/* determine if device 0 is present */
+	if (sata_rcar_ata_devchk(ap, 0))
+		devmask |= 1 << 0;
+
+	/* issue bus reset */
+	DPRINTK("about to softreset, devmask=%x\n", devmask);
+	rc = sata_rcar_bus_softreset(ap, deadline);
+	/* if link is occupied, -ENODEV too is an error */
+	if (rc && (rc != -ENODEV || sata_scr_valid(link))) {
+		ata_link_err(link, "SRST failed (errno=%d)\n", rc);
+		return rc;
+	}
+
+	/* determine by signature whether we have ATA or ATAPI devices */
+	classes[0] = ata_sff_dev_classify(&link->device[0], devmask, &err);
+
+	DPRINTK("classes[0]=%u\n", classes[0]);
+	return 0;
+}
+
+static void sata_rcar_tf_load(struct ata_port *ap,
+			      const struct ata_taskfile *tf)
+{
+	struct ata_ioports *ioaddr = &ap->ioaddr;
+	unsigned int is_addr = tf->flags & ATA_TFLAG_ISADDR;
+
+	if (tf->ctl != ap->last_ctl) {
+		iowrite32(tf->ctl, ioaddr->ctl_addr);
+		ap->last_ctl = tf->ctl;
+		ata_wait_idle(ap);
+	}
+
+	if (is_addr && (tf->flags & ATA_TFLAG_LBA48)) {
+		iowrite32(tf->hob_feature, ioaddr->feature_addr);
+		iowrite32(tf->hob_nsect, ioaddr->nsect_addr);
+		iowrite32(tf->hob_lbal, ioaddr->lbal_addr);
+		iowrite32(tf->hob_lbam, ioaddr->lbam_addr);
+		iowrite32(tf->hob_lbah, ioaddr->lbah_addr);
+		VPRINTK("hob: feat 0x%X nsect 0x%X, lba 0x%X 0x%X 0x%X\n",
+			tf->hob_feature,
+			tf->hob_nsect,
+			tf->hob_lbal,
+			tf->hob_lbam,
+			tf->hob_lbah);
+	}
+
+	if (is_addr) {
+		iowrite32(tf->feature, ioaddr->feature_addr);
+		iowrite32(tf->nsect, ioaddr->nsect_addr);
+		iowrite32(tf->lbal, ioaddr->lbal_addr);
+		iowrite32(tf->lbam, ioaddr->lbam_addr);
+		iowrite32(tf->lbah, ioaddr->lbah_addr);
+		VPRINTK("feat 0x%X nsect 0x%X lba 0x%X 0x%X 0x%X\n",
+			tf->feature,
+			tf->nsect,
+			tf->lbal,
+			tf->lbam,
+			tf->lbah);
+	}
+
+	if (tf->flags & ATA_TFLAG_DEVICE) {
+		iowrite32(tf->device, ioaddr->device_addr);
+		VPRINTK("device 0x%X\n", tf->device);
+	}
+
+	ata_wait_idle(ap);
+}
+
+static void sata_rcar_tf_read(struct ata_port *ap, struct ata_taskfile *tf)
+{
+	struct ata_ioports *ioaddr = &ap->ioaddr;
+
+	tf->command = sata_rcar_check_status(ap);
+	tf->feature = ioread32(ioaddr->error_addr);
+	tf->nsect = ioread32(ioaddr->nsect_addr);
+	tf->lbal = ioread32(ioaddr->lbal_addr);
+	tf->lbam = ioread32(ioaddr->lbam_addr);
+	tf->lbah = ioread32(ioaddr->lbah_addr);
+	tf->device = ioread32(ioaddr->device_addr);
+
+	if (tf->flags & ATA_TFLAG_LBA48) {
+		iowrite32(tf->ctl | ATA_HOB, ioaddr->ctl_addr);
+		tf->hob_feature = ioread32(ioaddr->error_addr);
+		tf->hob_nsect = ioread32(ioaddr->nsect_addr);
+		tf->hob_lbal = ioread32(ioaddr->lbal_addr);
+		tf->hob_lbam = ioread32(ioaddr->lbam_addr);
+		tf->hob_lbah = ioread32(ioaddr->lbah_addr);
+		iowrite32(tf->ctl, ioaddr->ctl_addr);
+		ap->last_ctl = tf->ctl;
+	}
+}
+
+static void sata_rcar_exec_command(struct ata_port *ap,
+				   const struct ata_taskfile *tf)
+{
+	DPRINTK("ata%u: cmd 0x%X\n", ap->print_id, tf->command);
+
+	iowrite32(tf->command, ap->ioaddr.command_addr);
+	ata_sff_pause(ap);
+}
+
+static unsigned int sata_rcar_data_xfer(struct ata_device *dev,
+					      unsigned char *buf,
+					      unsigned int buflen, int rw)
+{
+	struct ata_port *ap = dev->link->ap;
+	void __iomem *data_addr = ap->ioaddr.data_addr;
+	unsigned int words = buflen >> 1;
+
+	/* Transfer multiple of 2 bytes */
+	if (rw == READ)
+		sata_rcar_ioread16_rep(data_addr, buf, words);
+	else
+		sata_rcar_iowrite16_rep(data_addr, buf, words);
+
+	/* Transfer trailing byte, if any. */
+	if (unlikely(buflen & 0x01)) {
+		unsigned char pad[2] = { };
+
+		/* Point buf to the tail of buffer */
+		buf += buflen - 1;
+
+		/*
+		 * Use io*16_rep() accessors here as well to avoid pointlessly
+		 * swapping bytes to and from on the big endian machines...
+		 */
+		if (rw == READ) {
+			sata_rcar_ioread16_rep(data_addr, pad, 1);
+			*buf = pad[0];
+		} else {
+			pad[0] = *buf;
+			sata_rcar_iowrite16_rep(data_addr, pad, 1);
+		}
+		words++;
+	}
+
+	return words << 1;
+}
+
+static void sata_rcar_drain_fifo(struct ata_queued_cmd *qc)
+{
+	int count;
+	struct ata_port *ap;
+
+	/* We only need to flush incoming data when a command was running */
+	if (qc == NULL || qc->dma_dir == DMA_TO_DEVICE)
+		return;
+
+	ap = qc->ap;
+	/* Drain up to 64K of data before we give up this recovery method */
+	for (count = 0; (ap->ops->sff_check_status(ap) & ATA_DRQ) &&
+			count < 65536; count += 2)
+		ioread32(ap->ioaddr.data_addr);
+
+	/* Can become DEBUG later */
+	if (count)
+		ata_port_dbg(ap, "drained %d bytes to clear DRQ\n", count);
+}
+
+static int sata_rcar_scr_read(struct ata_link *link, unsigned int sc_reg,
+			      u32 *val)
+{
+	if (sc_reg > SCR_ACTIVE)
+		return -EINVAL;
+
+	*val = ioread32(link->ap->ioaddr.scr_addr + (sc_reg << 2));
+	return 0;
+}
+
+static int sata_rcar_scr_write(struct ata_link *link, unsigned int sc_reg,
+			       u32 val)
+{
+	if (sc_reg > SCR_ACTIVE)
+		return -EINVAL;
+
+	iowrite32(val, link->ap->ioaddr.scr_addr + (sc_reg << 2));
+	return 0;
+}
+
+static void sata_rcar_bmdma_fill_sg(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	struct ata_bmdma_prd *prd = ap->bmdma_prd;
+	struct scatterlist *sg;
+	unsigned int si, pi;
+
+	pi = 0;
+	for_each_sg(qc->sg, sg, qc->n_elem, si) {
+		u32 addr, sg_len, len;
+
+		/*
+		 * Note: h/w doesn't support 64-bit, so we unconditionally
+		 * truncate dma_addr_t to u32.
+		 */
+		addr = (u32)sg_dma_address(sg);
+		sg_len = sg_dma_len(sg);
+
+		/* H/w transfer count is only 29 bits long, let's be careful */
+		while (sg_len) {
+			len = sg_len;
+			if (len > 0x1ffffffe)
+				len = 0x1ffffffe;
+
+			prd[pi].addr = cpu_to_le32(addr);
+			prd[pi].flags_len = cpu_to_le32(len);
+			VPRINTK("PRD[%u] = (0x%X, 0x%X)\n", pi, addr, len);
+
+			pi++;
+			sg_len -= len;
+			addr += len;
+		}
+	}
+
+	/* end-of-table flag */
+	prd[pi - 1].addr |= cpu_to_le32(SATA_RCAR_DTEND);
+}
+
+static void sata_rcar_qc_prep(struct ata_queued_cmd *qc)
+{
+	if (!(qc->flags & ATA_QCFLAG_DMAMAP))
+		return;
+
+	sata_rcar_bmdma_fill_sg(qc);
+}
+
+static void sata_rcar_bmdma_setup(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	unsigned int rw = qc->tf.flags & ATA_TFLAG_WRITE;
+	u32 dmactl;
+	struct sata_rcar_priv *priv = ap->host->private_data;
+
+	/* load PRD table addr. */
+	mb();   /* make sure PRD table writes are visible to controller */
+	iowrite32(ap->bmdma_prd_dma, priv->base + ATAPI_DTB_ADR_REG);
+
+	/* specify data direction, triple-check start bit is clear */
+	dmactl = ioread32(priv->base + ATAPI_CONTROL1_REG);
+	dmactl &= ~(ATAPI_CONTROL1_RW | ATAPI_CONTROL1_STOP);
+	if (dmactl & ATAPI_CONTROL1_START) {
+		dmactl &= ~ATAPI_CONTROL1_START;
+		dmactl |= ATAPI_CONTROL1_STOP;
+	}
+	if (!rw)
+		dmactl |= ATAPI_CONTROL1_RW;
+	iowrite32(dmactl, priv->base + ATAPI_CONTROL1_REG);
+
+	/* issue r/w command */
+	ap->ops->sff_exec_command(ap, &qc->tf);
+}
+
+static void sata_rcar_bmdma_start(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	u32 dmactl;
+	struct sata_rcar_priv *priv = ap->host->private_data;
+
+	/* start host DMA transaction */
+	dmactl = ioread32(priv->base + ATAPI_CONTROL1_REG);
+	dmactl |= ATAPI_CONTROL1_START;
+	iowrite32(dmactl, priv->base + ATAPI_CONTROL1_REG);
+}
+
+static void sata_rcar_bmdma_stop(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	struct sata_rcar_priv *priv = ap->host->private_data;
+	u32 dmactl;
+
+	/* force termination of DMA transfer if active */
+	dmactl = ioread32(priv->base + ATAPI_CONTROL1_REG);
+	if (dmactl & ATAPI_CONTROL1_START) {
+		dmactl &= ~ATAPI_CONTROL1_START;
+		dmactl |= ATAPI_CONTROL1_STOP;
+		iowrite32(dmactl, priv->base + ATAPI_CONTROL1_REG);
+	}
+
+	/* one-PIO-cycle guaranteed wait, per spec, for HDMA1:0 transition */
+	ata_sff_dma_pause(ap);
+}
+
+static u8 sata_rcar_bmdma_status(struct ata_port *ap)
+{
+	struct sata_rcar_priv *priv = ap->host->private_data;
+	u32 status;
+	u8 host_stat = 0;
+
+	status = ioread32(priv->base + ATAPI_STATUS_REG);
+	if (status & ATAPI_STATUS_DEVINT)
+		host_stat |= ATA_DMA_INTR;
+	if (status & ATAPI_STATUS_ACT)
+		host_stat |= ATA_DMA_ACTIVE;
+
+	return host_stat;
+}
+
+static struct scsi_host_template sata_rcar_sht = {
+	ATA_BMDMA_SHT(DRV_NAME),
+};
+
+static struct ata_port_operations sata_rcar_port_ops = {
+	.inherits		= &ata_bmdma_port_ops,
+
+	.freeze			= sata_rcar_freeze,
+	.thaw			= sata_rcar_thaw,
+	.softreset		= sata_rcar_softreset,
+
+	.scr_read		= sata_rcar_scr_read,
+	.scr_write		= sata_rcar_scr_write,
+
+	.sff_dev_select		= sata_rcar_dev_select,
+	.sff_set_devctl		= sata_rcar_set_devctl,
+	.sff_check_status	= sata_rcar_check_status,
+	.sff_check_altstatus	= sata_rcar_check_altstatus,
+	.sff_tf_load		= sata_rcar_tf_load,
+	.sff_tf_read		= sata_rcar_tf_read,
+	.sff_exec_command	= sata_rcar_exec_command,
+	.sff_data_xfer		= sata_rcar_data_xfer,
+	.sff_drain_fifo		= sata_rcar_drain_fifo,
+
+	.qc_prep		= sata_rcar_qc_prep,
+
+	.bmdma_setup		= sata_rcar_bmdma_setup,
+	.bmdma_start		= sata_rcar_bmdma_start,
+	.bmdma_stop		= sata_rcar_bmdma_stop,
+	.bmdma_status		= sata_rcar_bmdma_status,
+};
+
+static int sata_rcar_serr_interrupt(struct ata_port *ap)
+{
+	struct sata_rcar_priv *priv = ap->host->private_data;
+	struct ata_eh_info *ehi = &ap->link.eh_info;
+	int freeze = 0;
+	int handled = 0;
+	u32 serror;
+
+	serror = ioread32(priv->base + SCRSERR_REG);
+	if (!serror)
+		return 0;
+
+	DPRINTK("SError @host_intr: 0x%x\n", serror);
+
+	/* first, analyze and record host port events */
+	ata_ehi_clear_desc(ehi);
+
+	if (serror & (SERR_DEV_XCHG | SERR_PHYRDY_CHG)) {
+		/* Setup a soft-reset EH action */
+		ata_ehi_hotplugged(ehi);
+		ata_ehi_push_desc(ehi, "%s", "hotplug");
+
+		freeze = serror & SERR_COMM_WAKE ? 0 : 1;
+		handled = 1;
+	}
+
+	/* freeze or abort */
+	if (freeze)
+		ata_port_freeze(ap);
+	else
+		ata_port_abort(ap);
+
+	return handled;
+}
+
+static int sata_rcar_ata_interrupt(struct ata_port *ap)
+{
+	struct ata_queued_cmd *qc;
+	int handled = 0;
+
+	qc = ata_qc_from_tag(ap, ap->link.active_tag);
+	if (qc)
+		handled |= ata_bmdma_port_intr(ap, qc);
+
+	return handled;
+}
+
+static irqreturn_t sata_rcar_interrupt(int irq, void *dev_instance)
+{
+	struct ata_host *host = dev_instance;
+	struct sata_rcar_priv *priv = host->private_data;
+	struct ata_port *ap;
+	unsigned int handled = 0;
+	u32 sataintstat;
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	sataintstat = ioread32(priv->base + SATAINTSTAT_REG);
+	if (!sataintstat)
+		goto done;
+	/* ack */
+	iowrite32(sataintstat & ~SATA_RCAR_INT_MASK,
+		 priv->base + SATAINTSTAT_REG);
+
+	ap = host->ports[0];
+
+	if (sataintstat & SATAINTSTAT_ATA)
+		handled |= sata_rcar_ata_interrupt(ap);
+
+	if (sataintstat & SATAINTSTAT_SERR)
+		handled |= sata_rcar_serr_interrupt(ap);
+
+done:
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	return IRQ_RETVAL(handled);
+}
+
+static void sata_rcar_setup_port(struct ata_host *host)
+{
+	struct ata_port *ap = host->ports[0];
+	struct ata_ioports *ioaddr = &ap->ioaddr;
+	struct sata_rcar_priv *priv = host->private_data;
+
+	ap->ops		= &sata_rcar_port_ops;
+	ap->pio_mask	= ATA_PIO4;
+	ap->udma_mask	= ATA_UDMA6;
+	ap->flags	|= ATA_FLAG_SATA;
+
+	ioaddr->cmd_addr = priv->base + SDATA_REG;
+	ioaddr->ctl_addr = priv->base + SSDEVCON_REG;
+	ioaddr->scr_addr = priv->base + SCRSSTS_REG;
+	ioaddr->altstatus_addr = ioaddr->ctl_addr;
+
+	ioaddr->data_addr	= ioaddr->cmd_addr + (ATA_REG_DATA << 2);
+	ioaddr->error_addr	= ioaddr->cmd_addr + (ATA_REG_ERR << 2);
+	ioaddr->feature_addr	= ioaddr->cmd_addr + (ATA_REG_FEATURE << 2);
+	ioaddr->nsect_addr	= ioaddr->cmd_addr + (ATA_REG_NSECT << 2);
+	ioaddr->lbal_addr	= ioaddr->cmd_addr + (ATA_REG_LBAL << 2);
+	ioaddr->lbam_addr	= ioaddr->cmd_addr + (ATA_REG_LBAM << 2);
+	ioaddr->lbah_addr	= ioaddr->cmd_addr + (ATA_REG_LBAH << 2);
+	ioaddr->device_addr	= ioaddr->cmd_addr + (ATA_REG_DEVICE << 2);
+	ioaddr->status_addr	= ioaddr->cmd_addr + (ATA_REG_STATUS << 2);
+	ioaddr->command_addr	= ioaddr->cmd_addr + (ATA_REG_CMD << 2);
+}
+
+static void sata_rcar_init_controller(struct ata_host *host)
+{
+	struct sata_rcar_priv *priv = host->private_data;
+	u32 val;
+
+	/* reset and setup phy */
+	sata_rcar_phy_initialize(priv);
+	sata_rcar_phy_write(priv, SATAPCTLR1_REG, 0x00200188, 0);
+	sata_rcar_phy_write(priv, SATAPCTLR1_REG, 0x00200188, 1);
+	sata_rcar_phy_write(priv, SATAPCTLR3_REG, 0x0000A061, 0);
+	sata_rcar_phy_write(priv, SATAPCTLR2_REG, 0x20000000, 0);
+	sata_rcar_phy_write(priv, SATAPCTLR2_REG, 0x20000000, 1);
+	sata_rcar_phy_write(priv, SATAPCTLR4_REG, 0x28E80000, 0);
+
+	/* SATA-IP reset state */
+	val = ioread32(priv->base + ATAPI_CONTROL1_REG);
+	val |= ATAPI_CONTROL1_RESET;
+	iowrite32(val, priv->base + ATAPI_CONTROL1_REG);
+
+	/* ISM mode, PRD mode, DTEND flag at bit 0 */
+	val = ioread32(priv->base + ATAPI_CONTROL1_REG);
+	val |= ATAPI_CONTROL1_ISM;
+	val |= ATAPI_CONTROL1_DESE;
+	val |= ATAPI_CONTROL1_DTA32M;
+	iowrite32(val, priv->base + ATAPI_CONTROL1_REG);
+
+	/* Release the SATA-IP from the reset state */
+	val = ioread32(priv->base + ATAPI_CONTROL1_REG);
+	val &= ~ATAPI_CONTROL1_RESET;
+	iowrite32(val, priv->base + ATAPI_CONTROL1_REG);
+
+	/* ack and mask */
+	iowrite32(0, priv->base + SATAINTSTAT_REG);
+	iowrite32(0x7ff, priv->base + SATAINTMASK_REG);
+	/* enable interrupts */
+	iowrite32(ATAPI_INT_ENABLE_SATAINT, priv->base + ATAPI_INT_ENABLE_REG);
+}
+
+static int sata_rcar_probe(struct platform_device *pdev)
+{
+	struct ata_host *host;
+	struct sata_rcar_priv *priv;
+	struct resource *mem;
+	int irq;
+	int ret = 0;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (mem == NULL)
+		return -EINVAL;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq <= 0)
+		return -EINVAL;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(struct sata_rcar_priv),
+			   GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(priv->clk)) {
+		dev_err(&pdev->dev, "failed to get access to sata clock\n");
+		return PTR_ERR(priv->clk);
+	}
+	clk_enable(priv->clk);
+
+	host = ata_host_alloc(&pdev->dev, 1);
+	if (!host) {
+		dev_err(&pdev->dev, "ata_host_alloc failed\n");
+		ret = -ENOMEM;
+		goto cleanup;
+	}
+
+	host->private_data = priv;
+
+	priv->base = devm_request_and_ioremap(&pdev->dev, mem);
+	if (!priv->base) {
+		ret = -EADDRNOTAVAIL;
+		goto cleanup;
+	}
+
+	/* setup port */
+	sata_rcar_setup_port(host);
+
+	/* initialize host controller */
+	sata_rcar_init_controller(host);
+
+	ret = ata_host_activate(host, irq, sata_rcar_interrupt, 0,
+				&sata_rcar_sht);
+	if (!ret)
+		return 0;
+
+cleanup:
+	clk_disable(priv->clk);
+
+	return ret;
+}
+
+static int sata_rcar_remove(struct platform_device *pdev)
+{
+	struct ata_host *host = dev_get_drvdata(&pdev->dev);
+	struct sata_rcar_priv *priv = host->private_data;
+
+	ata_host_detach(host);
+
+	/* disable interrupts */
+	iowrite32(0, priv->base + ATAPI_INT_ENABLE_REG);
+	/* ack and mask */
+	iowrite32(0, priv->base + SATAINTSTAT_REG);
+	iowrite32(0x7ff, priv->base + SATAINTMASK_REG);
+
+	clk_disable(priv->clk);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int sata_rcar_suspend(struct device *dev)
+{
+	struct ata_host *host = dev_get_drvdata(dev);
+	struct sata_rcar_priv *priv = host->private_data;
+	int ret;
+
+	ret = ata_host_suspend(host, PMSG_SUSPEND);
+	if (!ret) {
+		/* disable interrupts */
+		iowrite32(0, priv->base + ATAPI_INT_ENABLE_REG);
+		/* mask */
+		iowrite32(0x7ff, priv->base + SATAINTMASK_REG);
+
+		clk_disable(priv->clk);
+	}
+
+	return ret;
+}
+
+static int sata_rcar_resume(struct device *dev)
+{
+	struct ata_host *host = dev_get_drvdata(dev);
+	struct sata_rcar_priv *priv = host->private_data;
+
+	clk_enable(priv->clk);
+
+	/* ack and mask */
+	iowrite32(0, priv->base + SATAINTSTAT_REG);
+	iowrite32(0x7ff, priv->base + SATAINTMASK_REG);
+	/* enable interrupts */
+	iowrite32(ATAPI_INT_ENABLE_SATAINT, priv->base + ATAPI_INT_ENABLE_REG);
+
+	ata_host_resume(host);
+
+	return 0;
+}
+
+static const struct dev_pm_ops sata_rcar_pm_ops = {
+	.suspend	= sata_rcar_suspend,
+	.resume		= sata_rcar_resume,
+};
+#endif
+
+static struct of_device_id sata_rcar_match[] = {
+	{ .compatible = "renesas,rcar-sata", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sata_rcar_match);
+
+static struct platform_driver sata_rcar_driver = {
+	.probe		= sata_rcar_probe,
+	.remove		= sata_rcar_remove,
+	.driver = {
+		.name		= DRV_NAME,
+		.owner		= THIS_MODULE,
+		.of_match_table	= sata_rcar_match,
+#ifdef CONFIG_PM
+		.pm		= &sata_rcar_pm_ops,
+#endif
+	},
+};
+
+module_platform_driver(sata_rcar_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_DESCRIPTION("Renesas R-Car SATA controller low level driver");
