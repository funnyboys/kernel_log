commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 8463f5def0f5..c56773c25757 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * drivers/cpufreq/cpufreq_governor.h
  *
@@ -8,10 +9,6 @@
  *		(C) 2003 Jun Nakajima <jun.nakajima@intel.com>
  *		(C) 2009 Alexander Clouter <alex@digriz.org.uk>
  *		(c) 2012 Viresh Kumar <viresh.kumar@linaro.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #ifndef _CPUFREQ_GOVERNOR_H

commit ed4676e254630c1f00a4fc8f3821890fff7e3643
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jul 19 15:42:46 2017 +0530

    cpufreq: Replace "max_transition_latency" with "dynamic_switching"
    
    There is no limitation in the ondemand or conservative governors which
    disallow the transition_latency to be greater than 10 ms.
    
    The max_transition_latency field is rather used to disallow automatic
    dynamic frequency switching for platforms which didn't wanted these
    governors to run.
    
    Replace max_transition_latency with a boolean (dynamic_switching) and
    check for transition_latency == CPUFREQ_ETERNAL along with that. This
    makes it pretty straight forward to read/understand now.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 95f207eb820e..8463f5def0f5 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -159,7 +159,7 @@ void cpufreq_dbs_governor_limits(struct cpufreq_policy *policy);
 #define CPUFREQ_DBS_GOVERNOR_INITIALIZER(_name_)			\
 	{								\
 		.name = _name_,						\
-		.max_transition_latency	= TRANSITION_LATENCY_LIMIT,	\
+		.dynamic_switching = true,				\
 		.owner = THIS_MODULE,					\
 		.init = cpufreq_dbs_governor_init,			\
 		.exit = cpufreq_dbs_governor_exit,			\

commit 2d045036322c29b69c22f06530f1130338d06373
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jul 19 15:42:41 2017 +0530

    cpufreq: governor: Drop min_sampling_rate
    
    The cpufreq core and governors aren't supposed to set a limit on how
    fast we want to try changing the frequency. This is currently done for
    the legacy governors with help of min_sampling_rate.
    
    At worst, we may end up setting the sampling rate to a value lower than
    the rate at which frequency can be changed and then one of the CPUs in
    the policy will be only changing frequency for ever.
    
    But that is something for the user to decide and there is no need to
    have special handling for such cases in the core. Leave it for the user
    to figure out.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 0236ec2cd654..95f207eb820e 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -41,7 +41,6 @@ enum {OD_NORMAL_SAMPLE, OD_SUB_SAMPLE};
 struct dbs_data {
 	struct gov_attr_set attr_set;
 	void *tuners;
-	unsigned int min_sampling_rate;
 	unsigned int ignore_nice_load;
 	unsigned int sampling_rate;
 	unsigned int sampling_down_factor;

commit 55687da166bf51129ed6b110d7711f4c7560abe2
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 8 18:51:31 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/cpufreq.h>
    
    We are going to split <linux/sched/cpufreq.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and a couple of .c files.
    
    Create a trivial placeholder <linux/sched/cpufreq.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index f5717ca070cc..0236ec2cd654 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -20,6 +20,7 @@
 #include <linux/atomic.h>
 #include <linux/irq_work.h>
 #include <linux/cpufreq.h>
+#include <linux/sched/cpufreq.h>
 #include <linux/kernel_stat.h>
 #include <linux/module.h>
 #include <linux/mutex.h>

commit 00bfe05889e91b5112893b001e4a47b0a0f8bdd7
Author: Stratos Karafotis <stratosk@semaphore.gr>
Date:   Wed Nov 16 19:26:29 2016 +0200

    cpufreq: conservative: Decrease frequency faster for deferred updates
    
    Conservative governor changes the CPU frequency in steps.
    That means that if a CPU runs at max frequency, it will need several
    sampling periods to return to min frequency when the workload
    is finished.
    
    If the update function that calculates the load and target frequency
    is deferred, the governor might need even more time to decrease the
    frequency.
    
    This may have impact to power consumption and after all conservative
    should decrease the frequency if there is no workload at every sampling
    rate.
    
    To resolve the above issue calculate the number of sampling periods
    that the update is deferred. Considering that for each sampling period
    conservative should drop the frequency by a freq_step because the
    CPU was idle apply the proper subtraction to requested frequency.
    
    Below, the kernel trace with and without this patch. First an
    intensive workload is applied on a specific CPU. Then the workload
    is removed and the CPU goes to idle.
    
    WITHOUT
    
         <idle>-0     [007] dN..   620.329153: cpu_idle: state=4294967295 cpu_id=7
    kworker/7:2-556   [007] ....   620.350857: cpu_frequency: state=1700000 cpu_id=7
    kworker/7:2-556   [007] ....   620.370856: cpu_frequency: state=1900000 cpu_id=7
    kworker/7:2-556   [007] ....   620.390854: cpu_frequency: state=2100000 cpu_id=7
    kworker/7:2-556   [007] ....   620.411853: cpu_frequency: state=2200000 cpu_id=7
    kworker/7:2-556   [007] ....   620.432854: cpu_frequency: state=2400000 cpu_id=7
    kworker/7:2-556   [007] ....   620.453854: cpu_frequency: state=2600000 cpu_id=7
    kworker/7:2-556   [007] ....   620.494856: cpu_frequency: state=2900000 cpu_id=7
    kworker/7:2-556   [007] ....   620.515856: cpu_frequency: state=3100000 cpu_id=7
    kworker/7:2-556   [007] ....   620.536858: cpu_frequency: state=3300000 cpu_id=7
    kworker/7:2-556   [007] ....   620.557857: cpu_frequency: state=3401000 cpu_id=7
         <idle>-0     [007] d...   669.591363: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...   669.591939: cpu_idle: state=4294967295 cpu_id=7
         <idle>-0     [007] d...   669.591980: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] dN..   669.591989: cpu_idle: state=4294967295 cpu_id=7
    ...
         <idle>-0     [007] d...   670.201224: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...   670.221975: cpu_idle: state=4294967295 cpu_id=7
    kworker/7:2-556   [007] ....   670.222016: cpu_frequency: state=3300000 cpu_id=7
         <idle>-0     [007] d...   670.222026: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...   670.234964: cpu_idle: state=4294967295 cpu_id=7
    ...
         <idle>-0     [007] d...   670.801251: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...   671.236046: cpu_idle: state=4294967295 cpu_id=7
    kworker/7:2-556   [007] ....   671.236073: cpu_frequency: state=3100000 cpu_id=7
         <idle>-0     [007] d...   671.236112: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...   671.393437: cpu_idle: state=4294967295 cpu_id=7
    ...
         <idle>-0     [007] d...   671.401277: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...   671.404083: cpu_idle: state=4294967295 cpu_id=7
    kworker/7:2-556   [007] ....   671.404111: cpu_frequency: state=2900000 cpu_id=7
         <idle>-0     [007] d...   671.404125: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...   671.404974: cpu_idle: state=4294967295 cpu_id=7
    ...
         <idle>-0     [007] d...   671.501180: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...   671.995414: cpu_idle: state=4294967295 cpu_id=7
    kworker/7:2-556   [007] ....   671.995459: cpu_frequency: state=2800000 cpu_id=7
         <idle>-0     [007] d...   671.995469: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...   671.996287: cpu_idle: state=4294967295 cpu_id=7
    ...
         <idle>-0     [007] d...   672.001305: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...   672.078374: cpu_idle: state=4294967295 cpu_id=7
    kworker/7:2-556   [007] ....   672.078410: cpu_frequency: state=2600000 cpu_id=7
         <idle>-0     [007] d...   672.078419: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...   672.158020: cpu_idle: state=4294967295 cpu_id=7
    kworker/7:2-556   [007] ....   672.158040: cpu_frequency: state=2400000 cpu_id=7
         <idle>-0     [007] d...   672.158044: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...   672.160038: cpu_idle: state=4294967295 cpu_id=7
    ...
         <idle>-0     [007] d...   672.234557: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...   672.237121: cpu_idle: state=4294967295 cpu_id=7
    kworker/7:2-556   [007] ....   672.237174: cpu_frequency: state=2100000 cpu_id=7
         <idle>-0     [007] d...   672.237186: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...   672.237778: cpu_idle: state=4294967295 cpu_id=7
    ...
         <idle>-0     [007] d...   672.267902: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...   672.269860: cpu_idle: state=4294967295 cpu_id=7
    kworker/7:2-556   [007] ....   672.269906: cpu_frequency: state=1900000 cpu_id=7
         <idle>-0     [007] d...   672.269914: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...   672.271902: cpu_idle: state=4294967295 cpu_id=7
    ...
         <idle>-0     [007] d...   672.751342: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...   672.823056: cpu_idle: state=4294967295 cpu_id=7
    kworker/7:2-556   [007] ....   672.823095: cpu_frequency: state=1600000 cpu_id=7
    
    WITH
    
         <idle>-0     [007] dN..  4380.928009: cpu_idle: state=4294967295 cpu_id=7
    kworker/7:2-399   [007] ....  4380.949767: cpu_frequency: state=2000000 cpu_id=7
    kworker/7:2-399   [007] ....  4380.969765: cpu_frequency: state=2200000 cpu_id=7
    kworker/7:2-399   [007] ....  4381.009766: cpu_frequency: state=2500000 cpu_id=7
    kworker/7:2-399   [007] ....  4381.029767: cpu_frequency: state=2600000 cpu_id=7
    kworker/7:2-399   [007] ....  4381.049769: cpu_frequency: state=2800000 cpu_id=7
    kworker/7:2-399   [007] ....  4381.069769: cpu_frequency: state=3000000 cpu_id=7
    kworker/7:2-399   [007] ....  4381.089771: cpu_frequency: state=3100000 cpu_id=7
    kworker/7:2-399   [007] ....  4381.109772: cpu_frequency: state=3400000 cpu_id=7
    kworker/7:2-399   [007] ....  4381.129773: cpu_frequency: state=3401000 cpu_id=7
         <idle>-0     [007] d...  4428.226159: cpu_idle: state=1 cpu_id=7
         <idle>-0     [007] d...  4428.226176: cpu_idle: state=4294967295 cpu_id=7
         <idle>-0     [007] d...  4428.226181: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...  4428.227177: cpu_idle: state=4294967295 cpu_id=7
    ...
         <idle>-0     [007] d...  4428.551640: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...  4428.649239: cpu_idle: state=4294967295 cpu_id=7
    kworker/7:2-399   [007] ....  4428.649268: cpu_frequency: state=2800000 cpu_id=7
         <idle>-0     [007] d...  4428.649278: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...  4428.689856: cpu_idle: state=4294967295 cpu_id=7
    ...
         <idle>-0     [007] d...  4428.799542: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...  4428.801683: cpu_idle: state=4294967295 cpu_id=7
    kworker/7:2-399   [007] ....  4428.801748: cpu_frequency: state=1700000 cpu_id=7
         <idle>-0     [007] d...  4428.801761: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...  4428.806545: cpu_idle: state=4294967295 cpu_id=7
    ...
         <idle>-0     [007] d...  4429.051880: cpu_idle: state=4 cpu_id=7
         <idle>-0     [007] d...  4429.086240: cpu_idle: state=4294967295 cpu_id=7
    kworker/7:2-399   [007] ....  4429.086293: cpu_frequency: state=1600000 cpu_id=7
    
    Without the patch the CPU dropped to min frequency after 3.2s
    With the patch applied the CPU dropped to min frequency after 0.86s
    
    Signed-off-by: Stratos Karafotis <stratosk@semaphore.gr>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 9660cc6b4b39..f5717ca070cc 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -97,6 +97,7 @@ struct policy_dbs_info {
 	struct list_head list;
 	/* Multiplier for increasing sample delay temporarily. */
 	unsigned int rate_mult;
+	unsigned int idle_periods;	/* For conservative */
 	/* Status indicators */
 	bool is_shared;		/* This object is used by multiple CPUs */
 	bool work_in_progress;	/* Work is being queued up or in progress */

commit 26f0dbc9ab158afe86bac5ece2fcaf873d6bd8ad
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Nov 8 11:06:33 2016 +0530

    cpufreq: governor: Don't use 'timer' keyword
    
    The earlier implementation of governors used background timers and so
    functions, mutex, etc had 'timer' keyword in their names.
    
    But that's not true anymore. Replace 'timer' with 'update', as those
    functions, variables are based around updates to frequency.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index ef1037e9c92b..9660cc6b4b39 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -85,7 +85,7 @@ struct policy_dbs_info {
 	 * Per policy mutex that serializes load evaluation from limit-change
 	 * and work-handler.
 	 */
-	struct mutex timer_mutex;
+	struct mutex update_mutex;
 
 	u64 last_sample_time;
 	s64 sample_delay_ns;
@@ -135,7 +135,7 @@ struct dbs_governor {
 	 */
 	struct dbs_data *gdbs_data;
 
-	unsigned int (*gov_dbs_timer)(struct cpufreq_policy *policy);
+	unsigned int (*gov_dbs_update)(struct cpufreq_policy *policy);
 	struct policy_dbs_info *(*alloc)(void);
 	void (*free)(struct policy_dbs_info *policy_dbs);
 	int (*init)(struct dbs_data *dbs_data);

commit 9a15fb2c797a15524e63eacb10bd6cd68a99e830
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed May 18 22:59:49 2016 +0200

    cpufreq: Drop the 'initialized' field from struct cpufreq_governor
    
    The 'initialized' field in struct cpufreq_governor is only used by
    the conservative governor (as a usage counter) and the way that
    happens is far from straightforward and arguably incorrect.
    
    Namely, the value of 'initialized' is checked by
    cpufreq_dbs_governor_init() and cpufreq_dbs_governor_exit() and
    the results of those checks are passed (as the second argument) to
    the ->init() and ->exit() callbacks in struct dbs_governor.  Those
    callbacks are only implemented by the ondemand and conservative
    governors and ondemand doesn't use their second argument at all.
    In turn, the conservative governor uses it to decide whether or not
    to either register or unregister a transition notifier.
    
    That whole mechanism is not only unnecessarily convoluted, but also
    racy, because the 'initialized' field of struct cpufreq_governor is
    updated in cpufreq_init_governor() and cpufreq_exit_governor() under
    policy->rwsem which doesn't help if one of these functions is run
    twice in parallel for different policies (which isn't impossible in
    principle), for example.
    
    Instead of it, add a proper usage counter to the conservative
    governor and update it from cs_init() and cs_exit() which is
    guaranteed to be non-racy, as those functions are only called
    under gov_dbs_data_mutex which is global.
    
    With that in place, drop the 'initialized' field from struct
    cpufreq_governor as it is not used any more.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 36f0d19dd869..ef1037e9c92b 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -138,8 +138,8 @@ struct dbs_governor {
 	unsigned int (*gov_dbs_timer)(struct cpufreq_policy *policy);
 	struct policy_dbs_info *(*alloc)(void);
 	void (*free)(struct policy_dbs_info *policy_dbs);
-	int (*init)(struct dbs_data *dbs_data, bool notify);
-	void (*exit)(struct dbs_data *dbs_data, bool notify);
+	int (*init)(struct dbs_data *dbs_data);
+	void (*exit)(struct dbs_data *dbs_data);
 	void (*start)(struct cpufreq_policy *policy);
 };
 

commit e788892ba3cc71d385b75895f7a375fbc659ce86
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Jun 2 23:24:15 2016 +0200

    cpufreq: governor: Get rid of governor events
    
    The design of the cpufreq governor API is not very straightforward,
    as struct cpufreq_governor provides only one callback to be invoked
    from different code paths for different purposes.  The purpose it is
    invoked for is determined by its second "event" argument, causing it
    to act as a "callback multiplexer" of sorts.
    
    Unfortunately, that leads to extra complexity in governors, some of
    which implement the ->governor() callback as a switch statement
    that simply checks the event argument and invokes a separate function
    to handle that specific event.
    
    That extra complexity can be eliminated by replacing the all-purpose
    ->governor() callback with a family of callbacks to carry out specific
    governor operations: initialization and exit, start and stop and policy
    limits updates.  That also turns out to reduce the code size too, so
    do it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 34eb214b6d57..36f0d19dd869 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -148,6 +148,25 @@ static inline struct dbs_governor *dbs_governor_of(struct cpufreq_policy *policy
 	return container_of(policy->governor, struct dbs_governor, gov);
 }
 
+/* Governor callback routines */
+int cpufreq_dbs_governor_init(struct cpufreq_policy *policy);
+void cpufreq_dbs_governor_exit(struct cpufreq_policy *policy);
+int cpufreq_dbs_governor_start(struct cpufreq_policy *policy);
+void cpufreq_dbs_governor_stop(struct cpufreq_policy *policy);
+void cpufreq_dbs_governor_limits(struct cpufreq_policy *policy);
+
+#define CPUFREQ_DBS_GOVERNOR_INITIALIZER(_name_)			\
+	{								\
+		.name = _name_,						\
+		.max_transition_latency	= TRANSITION_LATENCY_LIMIT,	\
+		.owner = THIS_MODULE,					\
+		.init = cpufreq_dbs_governor_init,			\
+		.exit = cpufreq_dbs_governor_exit,			\
+		.start = cpufreq_dbs_governor_start,			\
+		.stop = cpufreq_dbs_governor_stop,			\
+		.limits = cpufreq_dbs_governor_limits,			\
+	}
+
 /* Governor specific operations */
 struct od_ops {
 	unsigned int (*powersave_bias_target)(struct cpufreq_policy *policy,
@@ -155,7 +174,6 @@ struct od_ops {
 };
 
 unsigned int dbs_update(struct cpufreq_policy *policy);
-int cpufreq_governor_dbs(struct cpufreq_policy *policy, unsigned int event);
 void od_register_powersave_bias_handler(unsigned int (*f)
 		(struct cpufreq_policy *, unsigned int, unsigned int),
 		unsigned int powersave_bias);

commit b4f4b4b37133340befa354fbaa54d8e84ea86103
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Apr 28 01:19:03 2016 +0200

    cpufreq: governor: Change confusing struct field and variable names
    
    The name of the prev_cpu_wall field in struct cpu_dbs_info is
    confusing, because it doesn't represent wall time, but the previous
    update time as returned by get_cpu_idle_time() (that may be the
    current value of jiffies_64 in some cases, for example).
    
    Moreover, the names of some related variables in dbs_update() take
    that confusion further.
    
    Rename all of those things to make their names reflect the purpose
    more accurately.  While at it, drop unnecessary parens from one of
    the updated expressions.
    
    No functional changes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Chen Yu <yu.c.chen@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 3e0eb7c54903..34eb214b6d57 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -111,7 +111,7 @@ static inline void gov_update_sample_delay(struct policy_dbs_info *policy_dbs,
 /* Per cpu structures */
 struct cpu_dbs_info {
 	u64 prev_cpu_idle;
-	u64 prev_cpu_wall;
+	u64 prev_update_time;
 	u64 prev_cpu_nice;
 	/*
 	 * Used to keep track of load in the previous interval. However, when

commit 379480d8258056bfdbaa65e4d3f024bb5b34b52b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Mar 22 02:51:56 2016 +0100

    cpufreq: Move governor symbols to cpufreq.h
    
    Move definitions of symbols related to transition latency and
    sampling rate to include/linux/cpufreq.h so they can be used by
    (future) goverernors located outside of drivers/cpufreq/.
    
    No functional changes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 181a43058ece..3e0eb7c54903 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -24,20 +24,6 @@
 #include <linux/module.h>
 #include <linux/mutex.h>
 
-/*
- * The polling frequency depends on the capability of the processor. Default
- * polling frequency is 1000 times the transition latency of the processor. The
- * governor will work on any processor with transition latency <= 10ms, using
- * appropriate sampling rate.
- *
- * For CPUs with transition latency > 10ms (mostly drivers with CPUFREQ_ETERNAL)
- * this governor will not work. All times here are in us (micro seconds).
- */
-#define MIN_SAMPLING_RATE_RATIO			(2)
-#define LATENCY_MULTIPLIER			(1000)
-#define MIN_LATENCY_MULTIPLIER			(20)
-#define TRANSITION_LATENCY_LIMIT		(10 * 1000 * 1000)
-
 /* Ondemand Sampling types */
 enum {OD_NORMAL_SAMPLE, OD_SUB_SAMPLE};
 

commit 66893b6ac9952ec9d9409e9d85eaacf37bba8d15
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Mar 22 02:50:45 2016 +0100

    cpufreq: Move governor attribute set headers to cpufreq.h
    
    Move definitions and function headers related to struct gov_attr_set
    to include/linux/cpufreq.h so they can be used by (future) goverernors
    located outside of drivers/cpufreq/.
    
    No functional changes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index ccdd0814efbc..181a43058ece 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -41,19 +41,6 @@
 /* Ondemand Sampling types */
 enum {OD_NORMAL_SAMPLE, OD_SUB_SAMPLE};
 
-struct gov_attr_set {
-	struct kobject kobj;
-	struct list_head policy_list;
-	struct mutex update_lock;
-	int usage_count;
-};
-
-extern const struct sysfs_ops governor_sysfs_ops;
-
-void gov_attr_set_init(struct gov_attr_set *attr_set, struct list_head *list_node);
-void gov_attr_set_get(struct gov_attr_set *attr_set, struct list_head *list_node);
-unsigned int gov_attr_set_put(struct gov_attr_set *attr_set, struct list_head *list_node);
-
 /*
  * Abbreviations:
  * dbs: used as a shortform for demand based switching It helps to keep variable
@@ -80,14 +67,6 @@ static inline struct dbs_data *to_dbs_data(struct gov_attr_set *attr_set)
 	return container_of(attr_set, struct dbs_data, attr_set);
 }
 
-/* Governor's specific attributes */
-struct governor_attr {
-	struct attribute attr;
-	ssize_t (*show)(struct gov_attr_set *attr_set, char *buf);
-	ssize_t (*store)(struct gov_attr_set *attr_set, const char *buf,
-			 size_t count);
-};
-
 #define gov_show_one(_gov, file_name)					\
 static ssize_t show_##file_name						\
 (struct gov_attr_set *attr_set, char *buf)				\

commit 2d0c58ad60376160ee8b535e570a38b9a349b6a4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Mar 22 02:49:15 2016 +0100

    cpufreq: governor: Move abstract gov_attr_set code to seperate file
    
    Move abstract code related to struct gov_attr_set to a separate (new)
    file so it can be shared with (future) goverernors that won't share
    more code with "ondemand" and "conservative".
    
    No intentional functional changes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index f4ad431130b8..ccdd0814efbc 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -48,6 +48,12 @@ struct gov_attr_set {
 	int usage_count;
 };
 
+extern const struct sysfs_ops governor_sysfs_ops;
+
+void gov_attr_set_init(struct gov_attr_set *attr_set, struct list_head *list_node);
+void gov_attr_set_get(struct gov_attr_set *attr_set, struct list_head *list_node);
+unsigned int gov_attr_set_put(struct gov_attr_set *attr_set, struct list_head *list_node);
+
 /*
  * Abbreviations:
  * dbs: used as a shortform for demand based switching It helps to keep variable

commit 0dd3c1d678aa219a7332984fcedbdd8970e92d5b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Mar 22 02:47:51 2016 +0100

    cpufreq: governor: New data type for management part of dbs_data
    
    In addition to fields representing governor tunables, struct dbs_data
    contains some fields needed for the management of objects of that
    type.  As it turns out, that part of struct dbs_data may be shared
    with (future) governors that won't use the common code used by
    "ondemand" and "conservative", so move it to a separate struct type
    and modify the code using struct dbs_data to follow.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 61ff82fe0613..f4ad431130b8 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -41,6 +41,13 @@
 /* Ondemand Sampling types */
 enum {OD_NORMAL_SAMPLE, OD_SUB_SAMPLE};
 
+struct gov_attr_set {
+	struct kobject kobj;
+	struct list_head policy_list;
+	struct mutex update_lock;
+	int usage_count;
+};
+
 /*
  * Abbreviations:
  * dbs: used as a shortform for demand based switching It helps to keep variable
@@ -52,7 +59,7 @@ enum {OD_NORMAL_SAMPLE, OD_SUB_SAMPLE};
 
 /* Governor demand based switching data (per-policy or global). */
 struct dbs_data {
-	int usage_count;
+	struct gov_attr_set attr_set;
 	void *tuners;
 	unsigned int min_sampling_rate;
 	unsigned int ignore_nice_load;
@@ -60,37 +67,35 @@ struct dbs_data {
 	unsigned int sampling_down_factor;
 	unsigned int up_threshold;
 	unsigned int io_is_busy;
-
-	struct kobject kobj;
-	struct list_head policy_dbs_list;
-	/*
-	 * Protect concurrent updates to governor tunables from sysfs,
-	 * policy_dbs_list and usage_count.
-	 */
-	struct mutex mutex;
 };
 
+static inline struct dbs_data *to_dbs_data(struct gov_attr_set *attr_set)
+{
+	return container_of(attr_set, struct dbs_data, attr_set);
+}
+
 /* Governor's specific attributes */
-struct dbs_data;
 struct governor_attr {
 	struct attribute attr;
-	ssize_t (*show)(struct dbs_data *dbs_data, char *buf);
-	ssize_t (*store)(struct dbs_data *dbs_data, const char *buf,
+	ssize_t (*show)(struct gov_attr_set *attr_set, char *buf);
+	ssize_t (*store)(struct gov_attr_set *attr_set, const char *buf,
 			 size_t count);
 };
 
 #define gov_show_one(_gov, file_name)					\
 static ssize_t show_##file_name						\
-(struct dbs_data *dbs_data, char *buf)					\
+(struct gov_attr_set *attr_set, char *buf)				\
 {									\
+	struct dbs_data *dbs_data = to_dbs_data(attr_set);		\
 	struct _gov##_dbs_tuners *tuners = dbs_data->tuners;		\
 	return sprintf(buf, "%u\n", tuners->file_name);			\
 }
 
 #define gov_show_one_common(file_name)					\
 static ssize_t show_##file_name						\
-(struct dbs_data *dbs_data, char *buf)					\
+(struct gov_attr_set *attr_set, char *buf)				\
 {									\
+	struct dbs_data *dbs_data = to_dbs_data(attr_set);		\
 	return sprintf(buf, "%u\n", dbs_data->file_name);		\
 }
 
@@ -184,7 +189,7 @@ void od_register_powersave_bias_handler(unsigned int (*f)
 		(struct cpufreq_policy *, unsigned int, unsigned int),
 		unsigned int powersave_bias);
 void od_unregister_powersave_bias_handler(void);
-ssize_t store_sampling_rate(struct dbs_data *dbs_data, const char *buf,
+ssize_t store_sampling_rate(struct gov_attr_set *attr_set, const char *buf,
 			    size_t count);
 void gov_update_cpu_data(struct dbs_data *dbs_data);
 #endif /* _CPUFREQ_GOVERNOR_H */

commit e3f5ed9393042188a1716d3873415ef44161addf
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Feb 18 02:33:43 2016 +0100

    cpufreq: governor: Make dbs_data_mutex static
    
    That mutex is only used by cpufreq_governor_dbs() and it doesn't
    need to be exported to modules, so make it static and drop the
    export incantation.
    
    No functional changes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index ece70ab6bbfc..61ff82fe0613 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -178,7 +178,6 @@ struct od_ops {
 			unsigned int freq_next, unsigned int relation);
 };
 
-extern struct mutex dbs_data_mutex;
 unsigned int dbs_update(struct cpufreq_policy *policy);
 int cpufreq_governor_dbs(struct cpufreq_policy *policy, unsigned int event);
 void od_register_powersave_bias_handler(unsigned int (*f)

commit 47ebaac1f32dc606262be48a72f9cea6af376414
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Feb 18 18:41:36 2016 +0100

    cpufreq: governor: Relocate definitions of tuners structures
    
    Move the definitions of struct od_dbs_tuners and struct cs_dbs_tuners
    from the common governor header to the ondemand and conservative
    governor code, respectively, as they don't need to be in the common
    header any more.
    
    No functional changes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 58749da97099..ece70ab6bbfc 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -148,16 +148,6 @@ struct cpu_dbs_info {
 	struct policy_dbs_info *policy_dbs;
 };
 
-/* Per policy Governors sysfs tunables */
-struct od_dbs_tuners {
-	unsigned int powersave_bias;
-};
-
-struct cs_dbs_tuners {
-	unsigned int down_threshold;
-	unsigned int freq_step;
-};
-
 /* Common Governor data across policies */
 struct dbs_governor {
 	struct cpufreq_governor gov;

commit 8c8f77fd0719a079450f59debed4f69ede825adb
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Feb 21 00:51:27 2016 +0100

    cpufreq: governor: Move per-CPU data to the common code
    
    After previous changes there is only one piece of code in the
    ondemand governor making references to per-CPU data structures,
    but it can be easily modified to avoid doing that, so modify it
    accordingly and move the definition of per-CPU data used by the
    ondemand and conservative governors to the common code.  Next,
    change that code to access the per-CPU data structures directly
    rather than via a governor callback.
    
    This causes the ->get_cpu_cdbs governor callback to become
    unnecessary, so drop it along with the macro and function
    definitions related to it.
    
    Finally, drop the definitions of struct od_cpu_dbs_info_s and
    struct cs_cpu_dbs_info_s that aren't necessary any more.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 354e0d306ff5..58749da97099 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -41,13 +41,6 @@
 /* Ondemand Sampling types */
 enum {OD_NORMAL_SAMPLE, OD_SUB_SAMPLE};
 
-/* create helper routines */
-#define define_get_cpu_dbs_routines(_dbs_info)				\
-static struct cpu_dbs_info *get_cpu_cdbs(int cpu)			\
-{									\
-	return &per_cpu(_dbs_info, cpu).cdbs;				\
-}
-
 /*
  * Abbreviations:
  * dbs: used as a shortform for demand based switching It helps to keep variable
@@ -155,14 +148,6 @@ struct cpu_dbs_info {
 	struct policy_dbs_info *policy_dbs;
 };
 
-struct od_cpu_dbs_info_s {
-	struct cpu_dbs_info cdbs;
-};
-
-struct cs_cpu_dbs_info_s {
-	struct cpu_dbs_info cdbs;
-};
-
 /* Per policy Governors sysfs tunables */
 struct od_dbs_tuners {
 	unsigned int powersave_bias;
@@ -184,7 +169,6 @@ struct dbs_governor {
 	 */
 	struct dbs_data *gdbs_data;
 
-	struct cpu_dbs_info *(*get_cpu_cdbs)(int cpu);
 	unsigned int (*gov_dbs_timer)(struct cpufreq_policy *policy);
 	struct policy_dbs_info *(*alloc)(void);
 	void (*free)(struct policy_dbs_info *policy_dbs);
@@ -213,5 +197,5 @@ void od_register_powersave_bias_handler(unsigned int (*f)
 void od_unregister_powersave_bias_handler(void);
 ssize_t store_sampling_rate(struct dbs_data *dbs_data, const char *buf,
 			    size_t count);
-void gov_update_cpu_data(struct dbs_governor *gov, struct dbs_data *dbs_data);
+void gov_update_cpu_data(struct dbs_data *dbs_data);
 #endif /* _CPUFREQ_GOVERNOR_H */

commit 7d5a9956af4ccf7d5cc0cd1f8d27d1691321bfc6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Feb 18 18:40:14 2016 +0100

    cpufreq: governor: Make governor private data per-policy
    
    Some fields in struct od_cpu_dbs_info_s and struct cs_cpu_dbs_info_s
    are only used for a limited set of CPUs.  Namely, if a policy is
    shared between multiple CPUs, those fields will only be used for one
    of them (policy->cpu).  This means that they really are per-policy
    rather than per-CPU and holding room for them in per-CPU data
    structures is generally wasteful.  Also moving those fields into
    per-policy data structures will allow some significant simplifications
    to be made going forward.
    
    For this reason, introduce struct cs_policy_dbs_info and
    struct od_policy_dbs_info to hold those fields.  Define each of the
    new structures as an extension of struct policy_dbs_info (such that
    struct policy_dbs_info is embedded in each of them) and introduce
    new ->alloc and ->free governor callbacks to allocate and free
    those structures, respectively, such that ->alloc() will return
    a pointer to the struct policy_dbs_info embedded in the allocated
    data structure and ->free() will take that pointer as its argument.
    
    With that, modify the code accessing the data fields in question
    in per-CPU data objects to look for them in the new structures
    via the struct policy_dbs_info pointer available to it and drop
    them from struct od_cpu_dbs_info_s and struct cs_cpu_dbs_info_s.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 5c7d1ea96fff..354e0d306ff5 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -157,17 +157,10 @@ struct cpu_dbs_info {
 
 struct od_cpu_dbs_info_s {
 	struct cpu_dbs_info cdbs;
-	struct cpufreq_frequency_table *freq_table;
-	unsigned int freq_lo;
-	unsigned int freq_lo_delay_us;
-	unsigned int freq_hi_delay_us;
-	unsigned int sample_type:1;
 };
 
 struct cs_cpu_dbs_info_s {
 	struct cpu_dbs_info cdbs;
-	unsigned int down_skip;
-	unsigned int requested_freq;
 };
 
 /* Per policy Governors sysfs tunables */
@@ -193,6 +186,8 @@ struct dbs_governor {
 
 	struct cpu_dbs_info *(*get_cpu_cdbs)(int cpu);
 	unsigned int (*gov_dbs_timer)(struct cpufreq_policy *policy);
+	struct policy_dbs_info *(*alloc)(void);
+	void (*free)(struct policy_dbs_info *policy_dbs);
 	int (*init)(struct dbs_data *dbs_data, bool notify);
 	void (*exit)(struct dbs_data *dbs_data, bool notify);
 	void (*start)(struct cpufreq_policy *policy);

commit a33cce1c6cc3268d8b4843bf1e4ac1e70b27d107
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Feb 18 02:26:55 2016 +0100

    cpufreq: governor: Fix CPU load information updates via ->store
    
    The ->store() callbacks of some tunable sysfs attributes of the
    ondemand and conservative governors trigger immediate updates of
    the CPU load information for all CPUs "governed" by the given
    dbs_data by walking the cpu_dbs_info structures for all online
    CPUs in the system and updating them.
    
    This is questionable for two reasons.  First, it may lead to a lot of
    extra overhead on a system with many CPUs if the given dbs_data is
    only associated with a few of them.  Second, if governor tunables are
    per-policy, the CPUs associated with the other sets of governor
    tunables should not be updated.
    
    To address this issue, use the observation that in all of the places
    in question the update operation may be carried out in the same way
    (because all of the tunables involved are now located in struct
    dbs_data and readily available to the common code) and make the
    code in those places invoke the same (new) helper function that
    will carry out the update correctly.
    
    That new function always checks the ignore_nice_load tunable value
    and updates the CPUs' prev_cpu_nice data fields if that's set, which
    wasn't done by the original code in store_io_is_busy(), but it
    should have been done in there too.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index ec98065dc30d..5c7d1ea96fff 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -218,4 +218,5 @@ void od_register_powersave_bias_handler(unsigned int (*f)
 void od_unregister_powersave_bias_handler(void);
 ssize_t store_sampling_rate(struct dbs_data *dbs_data, const char *buf,
 			    size_t count);
+void gov_update_cpu_data(struct dbs_governor *gov, struct dbs_data *dbs_data);
 #endif /* _CPUFREQ_GOVERNOR_H */

commit 76c5f66aa10720a377dfe8beebd39a0b2a938965
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Feb 18 02:24:32 2016 +0100

    cpufreq: ondemand: Drop one more callback from struct od_ops
    
    The ->powersave_bias_init_cpu callback in struct od_ops is only used
    in one place and that invocation may be replaced with a direct call
    to the function pointed to by that callback, so change the code
    accordingly and drop the callback.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index ee46f34f04d7..ec98065dc30d 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -205,7 +205,6 @@ static inline struct dbs_governor *dbs_governor_of(struct cpufreq_policy *policy
 
 /* Governor specific operations */
 struct od_ops {
-	void (*powersave_bias_init_cpu)(int cpu);
 	unsigned int (*powersave_bias_target)(struct cpufreq_policy *policy,
 			unsigned int freq_next, unsigned int relation);
 };

commit 8434dadbb457813a127f56d9f0fb7d22035027b9
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Feb 18 02:22:42 2016 +0100

    cpufreq: governor: Drop unused governor callback and data fields
    
    After some previous changes, the ->get_cpu_dbs_info_s governor
    callback and the "governor" field in struct dbs_governor (whose
    value represents the governor type) are not used any more, so
    drop them.
    
    Also drop the unused gov_ops field from struct dbs_governor.
    
    No functional changes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 2ae0ad50ca3d..ee46f34f04d7 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -46,11 +46,6 @@ enum {OD_NORMAL_SAMPLE, OD_SUB_SAMPLE};
 static struct cpu_dbs_info *get_cpu_cdbs(int cpu)			\
 {									\
 	return &per_cpu(_dbs_info, cpu).cdbs;				\
-}									\
-									\
-static void *get_cpu_dbs_info_s(int cpu)				\
-{									\
-	return &per_cpu(_dbs_info, cpu);				\
 }
 
 /*
@@ -188,10 +183,6 @@ struct cs_dbs_tuners {
 /* Common Governor data across policies */
 struct dbs_governor {
 	struct cpufreq_governor gov;
-
-	#define GOV_ONDEMAND		0
-	#define GOV_CONSERVATIVE	1
-	int governor;
 	struct kobj_type kobj_type;
 
 	/*
@@ -201,14 +192,10 @@ struct dbs_governor {
 	struct dbs_data *gdbs_data;
 
 	struct cpu_dbs_info *(*get_cpu_cdbs)(int cpu);
-	void *(*get_cpu_dbs_info_s)(int cpu);
 	unsigned int (*gov_dbs_timer)(struct cpufreq_policy *policy);
 	int (*init)(struct dbs_data *dbs_data, bool notify);
 	void (*exit)(struct dbs_data *dbs_data, bool notify);
 	void (*start)(struct cpufreq_policy *policy);
-
-	/* Governor specific ops, see below */
-	void *gov_ops;
 };
 
 static inline struct dbs_governor *dbs_governor_of(struct cpufreq_policy *policy)
@@ -216,7 +203,7 @@ static inline struct dbs_governor *dbs_governor_of(struct cpufreq_policy *policy
 	return container_of(policy->governor, struct dbs_governor, gov);
 }
 
-/* Governor specific ops, will be passed to dbs_data->gov_ops */
+/* Governor specific operations */
 struct od_ops {
 	void (*powersave_bias_init_cpu)(int cpu);
 	unsigned int (*powersave_bias_target)(struct cpufreq_policy *policy,

commit 702c9e542a25cf95683c08c56e711eddb80020ac
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Feb 18 02:21:21 2016 +0100

    cpufreq: governor: Add a ->start callback for governors
    
    To avoid having to check the governor type explicitly in the common
    code in order to initialize data structures specific to the governor
    type properly, add a ->start callback to struct dbs_governor and
    use it to initialize those data structures for the ondemand and
    conservative governors.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 7b3639328066..2ae0ad50ca3d 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -205,6 +205,7 @@ struct dbs_governor {
 	unsigned int (*gov_dbs_timer)(struct cpufreq_policy *policy);
 	int (*init)(struct dbs_data *dbs_data, bool notify);
 	void (*exit)(struct dbs_data *dbs_data, bool notify);
+	void (*start)(struct cpufreq_policy *policy);
 
 	/* Governor specific ops, see below */
 	void *gov_ops;

commit 8847e038c1d19c20dda0d7a590e31ffa528da8a5
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Feb 18 02:20:13 2016 +0100

    cpufreq: governor: Move io_is_busy to struct dbs_data
    
    The io_is_busy governor tunable is only used by the ondemand governor
    and is located in the ondemand-specific data structure, but it is
    looked at by the common governor code that has to do ugly things to
    get to that value, so move it to struct dbs_data and modify ondemand
    accordingly.
    
    Since the conservative governor never touches that field, it will
    be always 0 for that governor and it won't have any effect on the
    results of computations in that case.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 675e1cdbb46c..7b3639328066 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -71,6 +71,7 @@ struct dbs_data {
 	unsigned int sampling_rate;
 	unsigned int sampling_down_factor;
 	unsigned int up_threshold;
+	unsigned int io_is_busy;
 
 	struct kobject kobj;
 	struct list_head policy_dbs_list;
@@ -177,7 +178,6 @@ struct cs_cpu_dbs_info_s {
 /* Per policy Governors sysfs tunables */
 struct od_dbs_tuners {
 	unsigned int powersave_bias;
-	unsigned int io_is_busy;
 };
 
 struct cs_dbs_tuners {

commit 8eb055d3f53e52805907ea54e2eec0885be91a50
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Feb 16 21:02:32 2016 +0100

    cpufreq: ondemand: Drop unused callback from struct od_ops
    
    The ->freq_increase callback in struct od_ops is never invoked,
    so drop it.
    
    No functional changes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 7ae0c71143fa..675e1cdbb46c 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -220,7 +220,6 @@ struct od_ops {
 	void (*powersave_bias_init_cpu)(int cpu);
 	unsigned int (*powersave_bias_target)(struct cpufreq_policy *policy,
 			unsigned int freq_next, unsigned int relation);
-	void (*freq_increase)(struct cpufreq_policy *policy, unsigned int freq);
 };
 
 extern struct mutex dbs_data_mutex;

commit 07aa4402a009bc83194860e7869c491bab854d1c
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Feb 15 02:22:13 2016 +0100

    cpufreq: governor: Use microseconds in sample delay computations
    
    Do not convert microseconds to jiffies and the other way around
    in governor computations related to the sampling rate and sample
    delay and drop delay_for_sampling_rate() which isn't of any use
    then.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index f21d1e125cba..7ae0c71143fa 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -163,8 +163,8 @@ struct od_cpu_dbs_info_s {
 	struct cpu_dbs_info cdbs;
 	struct cpufreq_frequency_table *freq_table;
 	unsigned int freq_lo;
-	unsigned int freq_lo_jiffies;
-	unsigned int freq_hi_jiffies;
+	unsigned int freq_lo_delay_us;
+	unsigned int freq_hi_delay_us;
 	unsigned int sample_type:1;
 };
 
@@ -223,17 +223,6 @@ struct od_ops {
 	void (*freq_increase)(struct cpufreq_policy *policy, unsigned int freq);
 };
 
-static inline int delay_for_sampling_rate(unsigned int sampling_rate)
-{
-	int delay = usecs_to_jiffies(sampling_rate);
-
-	/* We want all CPUs to do sampling nearly on same jiffy */
-	if (num_online_cpus() > 1)
-		delay -= jiffies % delay;
-
-	return delay;
-}
-
 extern struct mutex dbs_data_mutex;
 unsigned int dbs_update(struct cpufreq_policy *policy);
 int cpufreq_governor_dbs(struct cpufreq_policy *policy, unsigned int event);

commit 57dc3bcd454eb420ddf25d89852993b61b351327
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Feb 15 02:20:51 2016 +0100

    cpufreq: governor: Move rate_mult to struct policy_dbs
    
    The rate_mult field in struct od_cpu_dbs_info_s is used by the code
    shared with the conservative governor and to access it that code
    has to do an ugly governor type check.  However, first of all it
    is ever only used for policy->cpu, so it is per-policy rather than
    per-CPU and second, it is initialized to 1 by cpufreq_governor_start(),
    so if the conservative governor never modifies it, it will have no
    effect on the results of any computations.
    
    For these reasons, move rate_mult to struct policy_dbs_info (as a
    common field).
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 38b9512820b0..f21d1e125cba 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -130,6 +130,8 @@ struct policy_dbs_info {
 	/* dbs_data may be shared between multiple policy objects */
 	struct dbs_data *dbs_data;
 	struct list_head list;
+	/* Multiplier for increasing sample delay temporarily. */
+	unsigned int rate_mult;
 	/* Status indicators */
 	bool is_shared;		/* This object is used by multiple CPUs */
 	bool work_in_progress;	/* Work is being queued up or in progress */
@@ -163,7 +165,6 @@ struct od_cpu_dbs_info_s {
 	unsigned int freq_lo;
 	unsigned int freq_lo_jiffies;
 	unsigned int freq_hi_jiffies;
-	unsigned int rate_mult;
 	unsigned int sample_type:1;
 };
 

commit 4cccf7555770b787fa80791a1407a27301f03920
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Feb 15 02:19:31 2016 +0100

    cpufreq: governor: Get rid of the ->gov_check_cpu callback
    
    The way the ->gov_check_cpu governor callback is used by the ondemand
    and conservative governors is not really straightforward.  Namely, the
    governor calls dbs_check_cpu() that updates the load information for
    the policy and the invokes ->gov_check_cpu() for the governor.
    
    To get rid of that entanglement, notice that cpufreq_governor_limits()
    doesn't need to call dbs_check_cpu() directly.  Instead, it can simply
    reset the sample delay to 0 which will cause a sample to be taken
    immediately.  The result of that is practically equivalent to calling
    dbs_check_cpu() except that it will trigger a full update of governor
    internal state and not just the ->gov_check_cpu() part.
    
    Following that observation, make cpufreq_governor_limits() reset
    the sample delay and turn dbs_check_cpu() into a function that will
    simply evaluate the load and return the result called dbs_update().
    
    That function can now be called by governors from the routines that
    previously were pointed to by ->gov_check_cpu and those routines
    can be called directly by each governor instead of dbs_check_cpu().
    This way ->gov_check_cpu becomes unnecessary, so drop it.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 521daac38ba5..38b9512820b0 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -202,7 +202,6 @@ struct dbs_governor {
 	struct cpu_dbs_info *(*get_cpu_cdbs)(int cpu);
 	void *(*get_cpu_dbs_info_s)(int cpu);
 	unsigned int (*gov_dbs_timer)(struct cpufreq_policy *policy);
-	void (*gov_check_cpu)(int cpu, unsigned int load);
 	int (*init)(struct dbs_data *dbs_data, bool notify);
 	void (*exit)(struct dbs_data *dbs_data, bool notify);
 
@@ -235,7 +234,7 @@ static inline int delay_for_sampling_rate(unsigned int sampling_rate)
 }
 
 extern struct mutex dbs_data_mutex;
-void dbs_check_cpu(struct cpufreq_policy *policy);
+unsigned int dbs_update(struct cpufreq_policy *policy);
 int cpufreq_governor_dbs(struct cpufreq_policy *policy, unsigned int event);
 void od_register_powersave_bias_handler(unsigned int (*f)
 		(struct cpufreq_policy *, unsigned int, unsigned int),

commit e4db2813d2e558b6b6bee464308678a57732b390
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Feb 15 02:13:42 2016 +0100

    cpufreq: governor: Avoid atomic operations in hot paths
    
    Rework the handling of work items by dbs_update_util_handler() and
    dbs_work_handler() so the former (which is executed in scheduler
    paths) only uses atomic operations when absolutely necessary.  That
    is, when the policy is shared and dbs_update_util_handler() has
    already decided that this is the time to queue up a work item.
    
    In particular, this avoids the atomic ops entirely on platforms where
    policy objects are never shared.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 8138eff5e25b..521daac38ba5 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -130,6 +130,9 @@ struct policy_dbs_info {
 	/* dbs_data may be shared between multiple policy objects */
 	struct dbs_data *dbs_data;
 	struct list_head list;
+	/* Status indicators */
+	bool is_shared;		/* This object is used by multiple CPUs */
+	bool work_in_progress;	/* Work is being queued up or in progress */
 };
 
 static inline void gov_update_sample_delay(struct policy_dbs_info *policy_dbs,

commit aded387b94b69aeab10e1d112bab7f82c9241527
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Feb 11 17:31:15 2016 +0530

    cpufreq: conservative: Update sample_delay_ns immediately
    
    The ondemand governor already updates sample_delay_ns immediately on
    updates to the sampling rate, but conservative doesn't do that.
    
    It was left out earlier as the code was really too complex to get
    that done easily.  Things are sorted out very well now, however, and
    the conservative governor can be modified to follow ondemand in that
    respect.
    
    Moreover, since the code needed to implement that in the
    conservative governor would be identical to the corresponding
    ondemand governor's code, make that code common and change both
    governors to use it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Juri Lelli <juri.lelli@arm.com>
    Tested-by: Shilpasri G Bhat <shilpa.bhat@linux.vnet.ibm.com>
    [ rjw: Changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index e9ec411042c3..8138eff5e25b 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -238,4 +238,6 @@ void od_register_powersave_bias_handler(unsigned int (*f)
 		(struct cpufreq_policy *, unsigned int, unsigned int),
 		unsigned int powersave_bias);
 void od_unregister_powersave_bias_handler(void);
+ssize_t store_sampling_rate(struct dbs_data *dbs_data, const char *buf,
+			    size_t count);
 #endif /* _CPUFREQ_GOVERNOR_H */

commit 99522fe6788f5bf627dce7c20ed9484c933511a3
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Feb 11 17:31:13 2016 +0530

    cpufreq: Remove cpufreq_governor_lock
    
    We used to drop policy->rwsem just before calling __cpufreq_governor()
    in some cases earlier and so it was possible that __cpufreq_governor()
    ran concurrently via separate threads for the same policy.
    
    In order to guarantee valid state transitions for governors,
    'governor_enabled' was required to be protected using some locking
    and cpufreq_governor_lock was added for that.
    
    But now __cpufreq_governor() is always called under policy->rwsem,
    and 'governor_enabled' is protected against races even without
    cpufreq_governor_lock.
    
    Get rid of the extra lock now.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Juri Lelli <juri.lelli@arm.com>
    Tested-by: Shilpasri G Bhat <shilpa.bhat@linux.vnet.ibm.com>
    [ rjw : Changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 8bf4775ce03c..e9ec411042c3 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -232,7 +232,6 @@ static inline int delay_for_sampling_rate(unsigned int sampling_rate)
 }
 
 extern struct mutex dbs_data_mutex;
-extern struct mutex cpufreq_governor_lock;
 void dbs_check_cpu(struct cpufreq_policy *policy);
 int cpufreq_governor_dbs(struct cpufreq_policy *policy, unsigned int event);
 void od_register_powersave_bias_handler(unsigned int (*f)

commit c54df0718423ea2941151d8516eb76ca6a32a4b4
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Feb 10 11:00:25 2016 +0530

    cpufreq: governor: Create and traverse list of policy_dbs to avoid deadlock
    
    The dbs_data_mutex lock is currently used in two places.  First,
    cpufreq_governor_dbs() uses it to guarantee mutual exclusion between
    invocations of governor operations from the core.  Second, it is used by
    ondemand governor's update_sampling_rate() to ensure the stability of
    data structures walked by it.
    
    The second usage is quite problematic, because update_sampling_rate() is
    called from a governor sysfs attribute's ->store callback and that leads
    to a deadlock scenario involving cpufreq_governor_exit() which runs
    under dbs_data_mutex.  Thus it is better to rework the code so
    update_sampling_rate() doesn't need to acquire dbs_data_mutex.
    
    To that end, rework update_sampling_rate() to walk a list of policy_dbs
    objects supported by the dbs_data one it has been called for (instead of
    walking cpu_dbs_info object for all CPUs).  The list manipulation is
    protected with dbs_data->mutex which also is held around the execution
    of update_sampling_rate(), it is not necessary to hold dbs_data_mutex in
    that function any more.
    
    Reported-by: Juri Lelli <juri.lelli@arm.com>
    Reported-by: Shilpasri G Bhat <shilpa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Subject & changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 0eb66a6c9503..8bf4775ce03c 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -73,7 +73,11 @@ struct dbs_data {
 	unsigned int up_threshold;
 
 	struct kobject kobj;
-	/* Protect concurrent updates to governor tunables from sysfs */
+	struct list_head policy_dbs_list;
+	/*
+	 * Protect concurrent updates to governor tunables from sysfs,
+	 * policy_dbs_list and usage_count.
+	 */
 	struct mutex mutex;
 };
 
@@ -125,6 +129,7 @@ struct policy_dbs_info {
 	struct work_struct work;
 	/* dbs_data may be shared between multiple policy objects */
 	struct dbs_data *dbs_data;
+	struct list_head list;
 };
 
 static inline void gov_update_sample_delay(struct policy_dbs_info *policy_dbs,

commit fd8ddc482a7a5e015c0613c4d96543d5efad047c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Feb 9 09:01:34 2016 +0530

    cpufreq: governor: Drop unused macros for creating governor tunable attributes
    
    The previous commit introduced a new set of macros for creating sysfs
    attributes that represent governor tunables and the old macros used for
    this purpose are not needed any more, so drop them.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Juri Lelli <juri.lelli@arm.com>
    Tested-by: Shilpasri G Bhat <shilpa.bhat@linux.vnet.ibm.com>
    [ rjw: Subject & changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index bdb6e4940b75..0eb66a6c9503 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -41,95 +41,6 @@
 /* Ondemand Sampling types */
 enum {OD_NORMAL_SAMPLE, OD_SUB_SAMPLE};
 
-/*
- * Macro for creating governors sysfs routines
- *
- * - gov_sys: One governor instance per whole system
- * - gov_pol: One governor instance per policy
- */
-
-/* Create attributes */
-#define gov_sys_attr_ro(_name)						\
-static struct global_attr _name##_gov_sys =				\
-__ATTR(_name, 0444, show_##_name##_gov_sys, NULL)
-
-#define gov_sys_attr_rw(_name)						\
-static struct global_attr _name##_gov_sys =				\
-__ATTR(_name, 0644, show_##_name##_gov_sys, store_##_name##_gov_sys)
-
-#define gov_pol_attr_ro(_name)						\
-static struct freq_attr _name##_gov_pol =				\
-__ATTR(_name, 0444, show_##_name##_gov_pol, NULL)
-
-#define gov_pol_attr_rw(_name)						\
-static struct freq_attr _name##_gov_pol =				\
-__ATTR(_name, 0644, show_##_name##_gov_pol, store_##_name##_gov_pol)
-
-#define gov_sys_pol_attr_rw(_name)					\
-	gov_sys_attr_rw(_name);						\
-	gov_pol_attr_rw(_name)
-
-#define gov_sys_pol_attr_ro(_name)					\
-	gov_sys_attr_ro(_name);						\
-	gov_pol_attr_ro(_name)
-
-/* Create show/store routines */
-#define show_one(_gov, file_name)					\
-static ssize_t show_##file_name##_gov_sys				\
-(struct kobject *kobj, struct attribute *attr, char *buf)		\
-{									\
-	struct _gov##_dbs_tuners *tuners = _gov##_dbs_gov.gdbs_data->tuners; \
-	return sprintf(buf, "%u\n", tuners->file_name);			\
-}									\
-									\
-static ssize_t show_##file_name##_gov_pol				\
-(struct cpufreq_policy *policy, char *buf)				\
-{									\
-	struct policy_dbs_info *policy_dbs = policy->governor_data;	\
-	struct dbs_data *dbs_data = policy_dbs->dbs_data;		\
-	struct _gov##_dbs_tuners *tuners = dbs_data->tuners;		\
-	return sprintf(buf, "%u\n", tuners->file_name);			\
-}
-
-#define store_one(_gov, file_name)					\
-static ssize_t store_##file_name##_gov_sys				\
-(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count) \
-{									\
-	struct dbs_data *dbs_data = _gov##_dbs_gov.gdbs_data;		\
-	return store_##file_name(dbs_data, buf, count);			\
-}									\
-									\
-static ssize_t store_##file_name##_gov_pol				\
-(struct cpufreq_policy *policy, const char *buf, size_t count)		\
-{									\
-	struct policy_dbs_info *policy_dbs = policy->governor_data;	\
-	return store_##file_name(policy_dbs->dbs_data, buf, count);			\
-}
-
-#define show_store_one(_gov, file_name)					\
-show_one(_gov, file_name);						\
-store_one(_gov, file_name)
-
-#define show_one_common(_gov, file_name)				\
-static ssize_t show_##file_name##_gov_sys				\
-(struct kobject *kobj, struct attribute *attr, char *buf)		\
-{									\
-	struct dbs_data *dbs_data = _gov##_dbs_gov.gdbs_data;		\
-	return sprintf(buf, "%u\n", dbs_data->file_name);		\
-}									\
-									\
-static ssize_t show_##file_name##_gov_pol				\
-(struct cpufreq_policy *policy, char *buf)				\
-{									\
-	struct policy_dbs_info *policy_dbs = policy->governor_data;	\
-	struct dbs_data *dbs_data = policy_dbs->dbs_data;		\
-	return sprintf(buf, "%u\n", dbs_data->file_name);		\
-}
-
-#define show_store_one_common(_gov, file_name)				\
-show_one_common(_gov, file_name);					\
-store_one(_gov, file_name)
-
 /* create helper routines */
 #define define_get_cpu_dbs_routines(_dbs_info)				\
 static struct cpu_dbs_info *get_cpu_cdbs(int cpu)			\

commit c4435630361d9bebf7154a0c842dc1fb7ae39c99
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Feb 9 09:01:33 2016 +0530

    cpufreq: governor: New sysfs show/store callbacks for governor tunables
    
    The ondemand and conservative governors use the global-attr or freq-attr
    structures to represent sysfs attributes corresponding to their tunables
    (which of them is actually used depends on whether or not different
    policy objects can use the same governor with different tunables at the
    same time and, consequently, on where those attributes are located in
    sysfs).
    
    Unfortunately, in the freq-attr case, the standard cpufreq show/store
    sysfs attribute callbacks are applied to the governor tunable attributes
    and they always acquire the policy->rwsem lock before carrying out the
    operation.  That may lead to an ABBA deadlock if governor tunable
    attributes are removed under policy->rwsem while one of them is being
    accessed concurrently (if sysfs attributes removal wins the race, it
    will wait for the access to complete with policy->rwsem held while the
    attribute callback will block on policy->rwsem indefinitely).
    
    We attempted to address this issue by dropping policy->rwsem around
    governor tunable attributes removal (that is, around invocations of the
    ->governor callback with the event arg equal to CPUFREQ_GOV_POLICY_EXIT)
    in cpufreq_set_policy(), but that opened up race conditions that had not
    been possible with policy->rwsem held all the time.  Therefore
    policy->rwsem cannot be dropped in cpufreq_set_policy() at any point,
    but the deadlock situation described above must be avoided too.
    
    To that end, use the observation that in principle governor tunables may
    be represented by the same data type regardless of whether the governor
    is system-wide or per-policy and introduce a new structure, struct
    governor_attr, for representing them and new corresponding macros for
    creating show/store sysfs callbacks for them.  Also make their parent
    kobject use a new kobject type whose default show/store callbacks are
    not related to the standard core cpufreq ones in any way (and they don't
    acquire policy->rwsem in particular).
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Juri Lelli <juri.lelli@arm.com>
    Tested-by: Shilpasri G Bhat <shilpa.bhat@linux.vnet.ibm.com>
    [ rjw: Subject & changelog + rebase ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index e296362d21d2..bdb6e4940b75 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -160,8 +160,44 @@ struct dbs_data {
 	unsigned int sampling_rate;
 	unsigned int sampling_down_factor;
 	unsigned int up_threshold;
+
+	struct kobject kobj;
+	/* Protect concurrent updates to governor tunables from sysfs */
+	struct mutex mutex;
+};
+
+/* Governor's specific attributes */
+struct dbs_data;
+struct governor_attr {
+	struct attribute attr;
+	ssize_t (*show)(struct dbs_data *dbs_data, char *buf);
+	ssize_t (*store)(struct dbs_data *dbs_data, const char *buf,
+			 size_t count);
 };
 
+#define gov_show_one(_gov, file_name)					\
+static ssize_t show_##file_name						\
+(struct dbs_data *dbs_data, char *buf)					\
+{									\
+	struct _gov##_dbs_tuners *tuners = dbs_data->tuners;		\
+	return sprintf(buf, "%u\n", tuners->file_name);			\
+}
+
+#define gov_show_one_common(file_name)					\
+static ssize_t show_##file_name						\
+(struct dbs_data *dbs_data, char *buf)					\
+{									\
+	return sprintf(buf, "%u\n", dbs_data->file_name);		\
+}
+
+#define gov_attr_ro(_name)						\
+static struct governor_attr _name =					\
+__ATTR(_name, 0444, show_##_name, NULL)
+
+#define gov_attr_rw(_name)						\
+static struct governor_attr _name =					\
+__ATTR(_name, 0644, show_##_name, store_##_name)
+
 /* Common to all CPUs of a policy */
 struct policy_dbs_info {
 	struct cpufreq_policy *policy;
@@ -236,8 +272,7 @@ struct dbs_governor {
 	#define GOV_ONDEMAND		0
 	#define GOV_CONSERVATIVE	1
 	int governor;
-	struct attribute_group *attr_group_gov_sys; /* one governor - system */
-	struct attribute_group *attr_group_gov_pol; /* one governor - policy */
+	struct kobj_type kobj_type;
 
 	/*
 	 * Common data for platforms that don't set

commit ff4b17895e3166084c76ae703cb1c757bcc59799
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Feb 9 09:01:32 2016 +0530

    cpufreq: governor: Move common tunables to 'struct dbs_data'
    
    There are a few common tunables shared between the ondemand and
    conservative governors.  Move them to struct dbs_data to simplify
    code.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Juri Lelli <juri.lelli@arm.com>
    Tested-by: Shilpasri G Bhat <shilpa.bhat@linux.vnet.ibm.com>
    [ rjw: Changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index cdf7536ac5fb..e296362d21d2 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -153,9 +153,13 @@ static void *get_cpu_dbs_info_s(int cpu)				\
 
 /* Governor demand based switching data (per-policy or global). */
 struct dbs_data {
-	unsigned int min_sampling_rate;
 	int usage_count;
 	void *tuners;
+	unsigned int min_sampling_rate;
+	unsigned int ignore_nice_load;
+	unsigned int sampling_rate;
+	unsigned int sampling_down_factor;
+	unsigned int up_threshold;
 };
 
 /* Common to all CPUs of a policy */
@@ -216,19 +220,11 @@ struct cs_cpu_dbs_info_s {
 
 /* Per policy Governors sysfs tunables */
 struct od_dbs_tuners {
-	unsigned int ignore_nice_load;
-	unsigned int sampling_rate;
-	unsigned int sampling_down_factor;
-	unsigned int up_threshold;
 	unsigned int powersave_bias;
 	unsigned int io_is_busy;
 };
 
 struct cs_dbs_tuners {
-	unsigned int ignore_nice_load;
-	unsigned int sampling_rate;
-	unsigned int sampling_down_factor;
-	unsigned int up_threshold;
 	unsigned int down_threshold;
 	unsigned int freq_step;
 };

commit d0684d3b8934cfb8171755cdb1fc87f4c0335655
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Feb 9 09:01:31 2016 +0530

    cpufreq: governor: Create generic macro for common tunables
    
    Some tunables are present in governor-specific structures, whereas one
    (min_sampling_rate) is located directly in struct dbs_data.
    
    There is a special macro for creating its sysfs attribute and the
    show/store callbacks, but since more tunables are going to be moved
    to struct dbs_data, a new generic macro for such cases will be useful,
    so add it and use it for min_sampling_rate.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Juri Lelli <juri.lelli@arm.com>
    Tested-by: Shilpasri G Bhat <shilpa.bhat@linux.vnet.ibm.com>
    [ rjw: Subject & changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 37537220e48c..cdf7536ac5fb 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -110,6 +110,26 @@ static ssize_t store_##file_name##_gov_pol				\
 show_one(_gov, file_name);						\
 store_one(_gov, file_name)
 
+#define show_one_common(_gov, file_name)				\
+static ssize_t show_##file_name##_gov_sys				\
+(struct kobject *kobj, struct attribute *attr, char *buf)		\
+{									\
+	struct dbs_data *dbs_data = _gov##_dbs_gov.gdbs_data;		\
+	return sprintf(buf, "%u\n", dbs_data->file_name);		\
+}									\
+									\
+static ssize_t show_##file_name##_gov_pol				\
+(struct cpufreq_policy *policy, char *buf)				\
+{									\
+	struct policy_dbs_info *policy_dbs = policy->governor_data;	\
+	struct dbs_data *dbs_data = policy_dbs->dbs_data;		\
+	return sprintf(buf, "%u\n", dbs_data->file_name);		\
+}
+
+#define show_store_one_common(_gov, file_name)				\
+show_one_common(_gov, file_name);					\
+store_one(_gov, file_name)
+
 /* create helper routines */
 #define define_get_cpu_dbs_routines(_dbs_info)				\
 static struct cpu_dbs_info *get_cpu_cdbs(int cpu)			\
@@ -264,22 +284,6 @@ static inline int delay_for_sampling_rate(unsigned int sampling_rate)
 	return delay;
 }
 
-#define declare_show_sampling_rate_min(_gov)				\
-static ssize_t show_sampling_rate_min_gov_sys				\
-(struct kobject *kobj, struct attribute *attr, char *buf)		\
-{									\
-	struct dbs_data *dbs_data = _gov##_dbs_gov.gdbs_data;		\
-	return sprintf(buf, "%u\n", dbs_data->min_sampling_rate);	\
-}									\
-									\
-static ssize_t show_sampling_rate_min_gov_pol				\
-(struct cpufreq_policy *policy, char *buf)				\
-{									\
-	struct policy_dbs_info *policy_dbs = policy->governor_data;	\
-	struct dbs_data *dbs_data = policy_dbs->dbs_data;		\
-	return sprintf(buf, "%u\n", dbs_data->min_sampling_rate);	\
-}
-
 extern struct mutex dbs_data_mutex;
 extern struct mutex cpufreq_governor_lock;
 void dbs_check_cpu(struct cpufreq_policy *policy);

commit 686cc637c99324ad52a6f8e59181f6407405bfe2
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Feb 8 23:41:10 2016 +0100

    cpufreq: governor: Rename skip_work to work_count
    
    The skip_work field in struct policy_dbs_info technically is a
    counter, so give it a new name to reflect that.
    
    No functional changes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 95e6834d36a8..37537220e48c 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -149,7 +149,7 @@ struct policy_dbs_info {
 
 	u64 last_sample_time;
 	s64 sample_delay_ns;
-	atomic_t skip_work;
+	atomic_t work_count;
 	struct irq_work irq_work;
 	struct work_struct work;
 	/* dbs_data may be shared between multiple policy objects */

commit bc505475b85de9a9903e84ef0b369d4637354201
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Feb 7 16:24:26 2016 +0100

    cpufreq: governor: Rearrange governor data structures
    
    The struct policy_dbs_info objects representing per-policy governor
    data are not accessible directly from the corresponding policy
    objects.  To access them, one has to get a pointer to the
    struct cpu_dbs_info of policy->cpu and use the policy_dbs field of
    that which isn't really straightforward.
    
    To address that rearrange the governor data structures so the
    governor_data pointer in struct cpufreq_policy will point to
    struct policy_dbs_info (instead of struct dbs_data) and that will
    contain a pointer to struct dbs_data.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 63868d7f14f5..95e6834d36a8 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -85,7 +85,8 @@ static ssize_t show_##file_name##_gov_sys				\
 static ssize_t show_##file_name##_gov_pol				\
 (struct cpufreq_policy *policy, char *buf)				\
 {									\
-	struct dbs_data *dbs_data = policy->governor_data;		\
+	struct policy_dbs_info *policy_dbs = policy->governor_data;	\
+	struct dbs_data *dbs_data = policy_dbs->dbs_data;		\
 	struct _gov##_dbs_tuners *tuners = dbs_data->tuners;		\
 	return sprintf(buf, "%u\n", tuners->file_name);			\
 }
@@ -101,8 +102,8 @@ static ssize_t store_##file_name##_gov_sys				\
 static ssize_t store_##file_name##_gov_pol				\
 (struct cpufreq_policy *policy, const char *buf, size_t count)		\
 {									\
-	struct dbs_data *dbs_data = policy->governor_data;		\
-	return store_##file_name(dbs_data, buf, count);			\
+	struct policy_dbs_info *policy_dbs = policy->governor_data;	\
+	return store_##file_name(policy_dbs->dbs_data, buf, count);			\
 }
 
 #define show_store_one(_gov, file_name)					\
@@ -130,6 +131,13 @@ static void *get_cpu_dbs_info_s(int cpu)				\
  * cs_*: Conservative governor
  */
 
+/* Governor demand based switching data (per-policy or global). */
+struct dbs_data {
+	unsigned int min_sampling_rate;
+	int usage_count;
+	void *tuners;
+};
+
 /* Common to all CPUs of a policy */
 struct policy_dbs_info {
 	struct cpufreq_policy *policy;
@@ -144,6 +152,8 @@ struct policy_dbs_info {
 	atomic_t skip_work;
 	struct irq_work irq_work;
 	struct work_struct work;
+	/* dbs_data may be shared between multiple policy objects */
+	struct dbs_data *dbs_data;
 };
 
 static inline void gov_update_sample_delay(struct policy_dbs_info *policy_dbs,
@@ -204,7 +214,6 @@ struct cs_dbs_tuners {
 };
 
 /* Common Governor data across policies */
-struct dbs_data;
 struct dbs_governor {
 	struct cpufreq_governor gov;
 
@@ -236,13 +245,6 @@ static inline struct dbs_governor *dbs_governor_of(struct cpufreq_policy *policy
 	return container_of(policy->governor, struct dbs_governor, gov);
 }
 
-/* Governor Per policy data */
-struct dbs_data {
-	unsigned int min_sampling_rate;
-	int usage_count;
-	void *tuners;
-};
-
 /* Governor specific ops, will be passed to dbs_data->gov_ops */
 struct od_ops {
 	void (*powersave_bias_init_cpu)(int cpu);
@@ -273,7 +275,8 @@ static ssize_t show_sampling_rate_min_gov_sys				\
 static ssize_t show_sampling_rate_min_gov_pol				\
 (struct cpufreq_policy *policy, char *buf)				\
 {									\
-	struct dbs_data *dbs_data = policy->governor_data;		\
+	struct policy_dbs_info *policy_dbs = policy->governor_data;	\
+	struct dbs_data *dbs_data = policy_dbs->dbs_data;		\
 	return sprintf(buf, "%u\n", dbs_data->min_sampling_rate);	\
 }
 

commit d10b5eb5fce436ba22443ab83eeb36e195dbf772
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sat Feb 6 13:50:24 2016 +0100

    cpufreq: governor: Drop cpu argument from dbs_check_cpu()
    
    Since policy->cpu is always passed as the second argument to
    dbs_check_cpu(), it is not really necessary to pass it, because
    the function can obtain that value via its first argument just fine.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index c90a2d3766fd..63868d7f14f5 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -279,7 +279,7 @@ static ssize_t show_sampling_rate_min_gov_pol				\
 
 extern struct mutex dbs_data_mutex;
 extern struct mutex cpufreq_governor_lock;
-void dbs_check_cpu(struct cpufreq_policy *policy, int cpu);
+void dbs_check_cpu(struct cpufreq_policy *policy);
 int cpufreq_governor_dbs(struct cpufreq_policy *policy, unsigned int event);
 void od_register_powersave_bias_handler(unsigned int (*f)
 		(struct cpufreq_policy *, unsigned int, unsigned int),

commit e40e7b255e591d0448500c7910ec5693f58026bd
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 10 17:07:44 2016 +0100

    cpufreq: governor: Rename cpu_common_dbs_info to policy_dbs_info
    
    The struct cpu_common_dbs_info structure represents the per-policy
    part of the governor data (for the ondemand and conservative
    governors), but its name doesn't reflect its purpose.
    
    Rename it to struct policy_dbs_info and rename variables related to
    it accordingly.
    
    No functional changes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index c8b7ec22871c..c90a2d3766fd 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -131,7 +131,7 @@ static void *get_cpu_dbs_info_s(int cpu)				\
  */
 
 /* Common to all CPUs of a policy */
-struct cpu_common_dbs_info {
+struct policy_dbs_info {
 	struct cpufreq_policy *policy;
 	/*
 	 * Per policy mutex that serializes load evaluation from limit-change
@@ -146,10 +146,10 @@ struct cpu_common_dbs_info {
 	struct work_struct work;
 };
 
-static inline void gov_update_sample_delay(struct cpu_common_dbs_info *shared,
+static inline void gov_update_sample_delay(struct policy_dbs_info *policy_dbs,
 					   unsigned int delay_us)
 {
-	shared->sample_delay_ns = delay_us * NSEC_PER_USEC;
+	policy_dbs->sample_delay_ns = delay_us * NSEC_PER_USEC;
 }
 
 /* Per cpu structures */
@@ -165,7 +165,7 @@ struct cpu_dbs_info {
 	 */
 	unsigned int prev_load;
 	struct update_util_data update_util;
-	struct cpu_common_dbs_info *shared;
+	struct policy_dbs_info *policy_dbs;
 };
 
 struct od_cpu_dbs_info_s {

commit ea59ee0dc9796a4e879291cc2f4728d04c499313
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Feb 7 16:09:51 2016 +0100

    cpufreq: governor: Drop the gov pointer from struct dbs_data
    
    Since it is possible to obtain a pointer to struct dbs_governor
    from a pointer to the struct governor embedded in it with the help
    of container_of(), the additional gov pointer in struct dbs_data
    isn't really necessary.
    
    Drop that pointer and make the code using it reach the dbs_governor
    object via policy->governor.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 8e280b8c446a..c8b7ec22871c 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -231,9 +231,13 @@ struct dbs_governor {
 	void *gov_ops;
 };
 
+static inline struct dbs_governor *dbs_governor_of(struct cpufreq_policy *policy)
+{
+	return container_of(policy->governor, struct dbs_governor, gov);
+}
+
 /* Governor Per policy data */
 struct dbs_data {
-	struct dbs_governor *gov;
 	unsigned int min_sampling_rate;
 	int usage_count;
 	void *tuners;
@@ -275,7 +279,7 @@ static ssize_t show_sampling_rate_min_gov_pol				\
 
 extern struct mutex dbs_data_mutex;
 extern struct mutex cpufreq_governor_lock;
-void dbs_check_cpu(struct dbs_data *dbs_data, int cpu);
+void dbs_check_cpu(struct cpufreq_policy *policy, int cpu);
 int cpufreq_governor_dbs(struct cpufreq_policy *policy, unsigned int event);
 void od_register_powersave_bias_handler(unsigned int (*f)
 		(struct cpufreq_policy *, unsigned int, unsigned int),

commit 906a6e5aaef24d3c80bf6a06c794c7541aca64be
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Feb 7 16:07:51 2016 +0100

    cpufreq: governor: Rework cpufreq_governor_dbs()
    
    Since it is possible to obtain a pointer to struct dbs_governor
    from a pointer to the struct governor embedded in it via
    container_of(), the second argument of cpufreq_governor_init()
    is not necessary.  Accordingly, cpufreq_governor_dbs() doesn't
    need its second argument either and the ->governor callbacks
    for both the ondemand and conservative governors may be set
    to cpufreq_governor_dbs() directly.  Make that happen.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Saravana Kannan <skannan@codeaurora.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index ed87b8442985..8e280b8c446a 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -276,8 +276,7 @@ static ssize_t show_sampling_rate_min_gov_pol				\
 extern struct mutex dbs_data_mutex;
 extern struct mutex cpufreq_governor_lock;
 void dbs_check_cpu(struct dbs_data *dbs_data, int cpu);
-int cpufreq_governor_dbs(struct cpufreq_policy *policy,
-		struct dbs_governor *gov, unsigned int event);
+int cpufreq_governor_dbs(struct cpufreq_policy *policy, unsigned int event);
 void od_register_powersave_bias_handler(unsigned int (*f)
 		(struct cpufreq_policy *, unsigned int, unsigned int),
 		unsigned int powersave_bias);

commit 7bdad34d0890b69c30e8c6a50c9c2311a839fd68
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Feb 7 16:05:07 2016 +0100

    cpufreq: governor: Rename some data types and variables
    
    The ondemand and conservative governors are represented by
    struct common_dbs_data whose name doesn't reflect the purpose it
    is used for, so rename it to struct dbs_governor and rename
    variables of that type accordingly.
    
    No functional changes.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 2fa3cf104314..ed87b8442985 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -78,7 +78,7 @@ __ATTR(_name, 0644, show_##_name##_gov_pol, store_##_name##_gov_pol)
 static ssize_t show_##file_name##_gov_sys				\
 (struct kobject *kobj, struct attribute *attr, char *buf)		\
 {									\
-	struct _gov##_dbs_tuners *tuners = _gov##_dbs_cdata.gdbs_data->tuners; \
+	struct _gov##_dbs_tuners *tuners = _gov##_dbs_gov.gdbs_data->tuners; \
 	return sprintf(buf, "%u\n", tuners->file_name);			\
 }									\
 									\
@@ -94,7 +94,7 @@ static ssize_t show_##file_name##_gov_pol				\
 static ssize_t store_##file_name##_gov_sys				\
 (struct kobject *kobj, struct attribute *attr, const char *buf, size_t count) \
 {									\
-	struct dbs_data *dbs_data = _gov##_dbs_cdata.gdbs_data;		\
+	struct dbs_data *dbs_data = _gov##_dbs_gov.gdbs_data;		\
 	return store_##file_name(dbs_data, buf, count);			\
 }									\
 									\
@@ -205,7 +205,7 @@ struct cs_dbs_tuners {
 
 /* Common Governor data across policies */
 struct dbs_data;
-struct common_dbs_data {
+struct dbs_governor {
 	struct cpufreq_governor gov;
 
 	#define GOV_ONDEMAND		0
@@ -233,7 +233,7 @@ struct common_dbs_data {
 
 /* Governor Per policy data */
 struct dbs_data {
-	struct common_dbs_data *cdata;
+	struct dbs_governor *gov;
 	unsigned int min_sampling_rate;
 	int usage_count;
 	void *tuners;
@@ -262,7 +262,7 @@ static inline int delay_for_sampling_rate(unsigned int sampling_rate)
 static ssize_t show_sampling_rate_min_gov_sys				\
 (struct kobject *kobj, struct attribute *attr, char *buf)		\
 {									\
-	struct dbs_data *dbs_data = _gov##_dbs_cdata.gdbs_data;		\
+	struct dbs_data *dbs_data = _gov##_dbs_gov.gdbs_data;		\
 	return sprintf(buf, "%u\n", dbs_data->min_sampling_rate);	\
 }									\
 									\
@@ -277,7 +277,7 @@ extern struct mutex dbs_data_mutex;
 extern struct mutex cpufreq_governor_lock;
 void dbs_check_cpu(struct dbs_data *dbs_data, int cpu);
 int cpufreq_governor_dbs(struct cpufreq_policy *policy,
-		struct common_dbs_data *cdata, unsigned int event);
+		struct dbs_governor *gov, unsigned int event);
 void od_register_powersave_bias_handler(unsigned int (*f)
 		(struct cpufreq_policy *, unsigned int, unsigned int),
 		unsigned int powersave_bias);

commit af926185231a6e30d11a6035410b61405e203c3b
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Fri Feb 5 03:16:08 2016 +0100

    cpufreq: governor: Put governor structure into common_dbs_data
    
    For the ondemand and conservative governors (generally, governors
    that use the common code in cpufreq_governor.c), there are two static
    data structures representing the governor, the struct governor
    structure (the interface to the cpufreq core) and the struct
    common_dbs_data one (the interface to the cpufreq_governor.c code).
    
    There's no fundamental reason why those two structures have to be
    separate.  Moreover, if the struct governor one is included into
    struct common_dbs_data, it will be possible to reach the latter from
    the policy via its policy->governor pointer, so it won't be necessary
    to pass a separate pointer to it around.  For this reason, embed
    struct governor in struct common_dbs_data.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Saravana Kannan <skannan@codeaurora.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index a9df62e87fcb..2fa3cf104314 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -206,7 +206,8 @@ struct cs_dbs_tuners {
 /* Common Governor data across policies */
 struct dbs_data;
 struct common_dbs_data {
-	/* Common across governors */
+	struct cpufreq_governor gov;
+
 	#define GOV_ONDEMAND		0
 	#define GOV_CONSERVATIVE	1
 	int governor;

commit 2bb8d94fb03f808022c620f54b602a1e26d5cbac
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Feb 7 16:01:31 2016 +0100

    cpufreq: governor: Use common mutex for dbs_data protection
    
    Every governor relying on the common code in cpufreq_governor.c
    has to provide its own mutex in struct common_dbs_data.  However,
    there actually is no need to have a separate mutex per governor
    for this purpose, they may be using the same global mutex just
    fine.  Accordingly, introduce a single common mutex for that and
    drop the mutex field from struct common_dbs_data.
    
    That at least will ensure that the mutex is always present and
    initialized regardless of what the particular governors do.
    
    Another benefit is that the common code does not need a pointer to
    a governor-related structure to get to the mutex which sometimes
    helps.
    
    Finally, it makes the code generally easier to follow.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Saravana Kannan <skannan@codeaurora.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 541777192dbc..a9df62e87fcb 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -228,11 +228,6 @@ struct common_dbs_data {
 
 	/* Governor specific ops, see below */
 	void *gov_ops;
-
-	/*
-	 * Protects governor's data (struct dbs_data and struct common_dbs_data)
-	 */
-	struct mutex mutex;
 };
 
 /* Governor Per policy data */
@@ -277,6 +272,7 @@ static ssize_t show_sampling_rate_min_gov_pol				\
 	return sprintf(buf, "%u\n", dbs_data->min_sampling_rate);	\
 }
 
+extern struct mutex dbs_data_mutex;
 extern struct mutex cpufreq_governor_lock;
 void dbs_check_cpu(struct dbs_data *dbs_data, int cpu);
 int cpufreq_governor_dbs(struct cpufreq_policy *policy,

commit 9be4fd2c7723a3057b0b39676fe4c8d5fd7118a4
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Feb 10 16:53:50 2016 +0100

    cpufreq: governor: Replace timers with utilization update callbacks
    
    Instead of using a per-CPU deferrable timer for queuing up governor
    work items, register a utilization update callback that will be
    invoked from the scheduler on utilization changes.
    
    The sampling rate is still the same as what was used for the
    deferrable timers and the added irq_work overhead should be offset by
    the eliminated timers overhead, so in theory the functional impact of
    this patch should not be significant.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Gautham R. Shenoy <ego@linux.vnet.ibm.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 91e767a058a7..541777192dbc 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -18,6 +18,7 @@
 #define _CPUFREQ_GOVERNOR_H
 
 #include <linux/atomic.h>
+#include <linux/irq_work.h>
 #include <linux/cpufreq.h>
 #include <linux/kernel_stat.h>
 #include <linux/module.h>
@@ -138,11 +139,19 @@ struct cpu_common_dbs_info {
 	 */
 	struct mutex timer_mutex;
 
-	ktime_t time_stamp;
+	u64 last_sample_time;
+	s64 sample_delay_ns;
 	atomic_t skip_work;
+	struct irq_work irq_work;
 	struct work_struct work;
 };
 
+static inline void gov_update_sample_delay(struct cpu_common_dbs_info *shared,
+					   unsigned int delay_us)
+{
+	shared->sample_delay_ns = delay_us * NSEC_PER_USEC;
+}
+
 /* Per cpu structures */
 struct cpu_dbs_info {
 	u64 prev_cpu_idle;
@@ -155,7 +164,7 @@ struct cpu_dbs_info {
 	 * wake-up from idle.
 	 */
 	unsigned int prev_load;
-	struct timer_list timer;
+	struct update_util_data update_util;
 	struct cpu_common_dbs_info *shared;
 };
 
@@ -212,8 +221,7 @@ struct common_dbs_data {
 
 	struct cpu_dbs_info *(*get_cpu_cdbs)(int cpu);
 	void *(*get_cpu_dbs_info_s)(int cpu);
-	unsigned int (*gov_dbs_timer)(struct cpufreq_policy *policy,
-				      bool modify_all);
+	unsigned int (*gov_dbs_timer)(struct cpufreq_policy *policy);
 	void (*gov_check_cpu)(int cpu, unsigned int load);
 	int (*init)(struct dbs_data *dbs_data, bool notify);
 	void (*exit)(struct dbs_data *dbs_data, bool notify);
@@ -270,9 +278,6 @@ static ssize_t show_sampling_rate_min_gov_pol				\
 }
 
 extern struct mutex cpufreq_governor_lock;
-
-void gov_add_timers(struct cpufreq_policy *policy, unsigned int delay);
-void gov_cancel_work(struct cpu_common_dbs_info *shared);
 void dbs_check_cpu(struct dbs_data *dbs_data, int cpu);
 int cpufreq_governor_dbs(struct cpufreq_policy *policy,
 		struct common_dbs_data *cdata, unsigned int event);

commit 2dd3e724b4e2237cfaaf155cab72af02c1c420cc
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue Dec 8 21:44:05 2015 +0100

    cpufreq: governor: Use lockless timer function
    
    It is possible to get rid of the timer_lock spinlock used by the
    governor timer function for synchronization, but a couple of races
    need to be avoided.
    
    The first race is between multiple dbs_timer_handler() instances
    that may be running in parallel with each other on different
    CPUs.  Namely, one of them has to queue up the work item, but it
    cannot be queued up more than once.  To achieve that,
    atomic_inc_return() can be used on the skip_work field of
    struct cpu_common_dbs_info.
    
    The second race is between an already running dbs_timer_handler()
    and gov_cancel_work().  In that case the dbs_timer_handler() might
    not notice the skip_work incrementation in gov_cancel_work() and
    it might queue up its work item after gov_cancel_work() had
    returned (and that work item would corrupt skip_work going
    forward).  To prevent that from happening, gov_cancel_work()
    can be made wait for the timer function to complete (on all CPUs)
    right after skip_work has been incremented.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 76742902491e..91e767a058a7 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -17,6 +17,7 @@
 #ifndef _CPUFREQ_GOVERNOR_H
 #define _CPUFREQ_GOVERNOR_H
 
+#include <linux/atomic.h>
 #include <linux/cpufreq.h>
 #include <linux/kernel_stat.h>
 #include <linux/module.h>
@@ -137,14 +138,8 @@ struct cpu_common_dbs_info {
 	 */
 	struct mutex timer_mutex;
 
-	/*
-	 * Per policy lock that serializes access to queuing work from timer
-	 * handlers.
-	 */
-	spinlock_t timer_lock;
-
 	ktime_t time_stamp;
-	unsigned int skip_work;
+	atomic_t skip_work;
 	struct work_struct work;
 };
 

commit 70f43e5e798c8818d97d8d6a9bd4cd3235af9686
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Dec 9 07:34:42 2015 +0530

    cpufreq: governor: replace per-CPU delayed work with timers
    
    cpufreq governors evaluate load at sampling rate and based on that they
    update frequency for a group of CPUs belonging to the same cpufreq
    policy.
    
    This is required to be done in a single thread for all policy->cpus, but
    because we don't want to wakeup idle CPUs to do just that, we use
    deferrable work for this. If we would have used a single delayed
    deferrable work for the entire policy, there were chances that the CPU
    required to run the handler can be in idle and we might end up not
    changing the frequency for the entire group with load variations.
    
    And so we were forced to keep per-cpu works, and only the one that
    expires first need to do the real work and others are rescheduled for
    next sampling time.
    
    We have been using the more complex solution until now, where we used a
    delayed deferrable work for this, which is a combination of a timer and
    a work.
    
    This could be made lightweight by keeping per-cpu deferred timers with a
    single work item, which is scheduled by the first timer that expires.
    
    This patch does just that and here are important changes:
    - The timer handler will run in irq context and so we need to use a
      spin_lock instead of the timer_mutex. And so a separate timer_lock is
      created. This also makes the use of the mutex and lock quite clear, as
      we know what exactly they are protecting.
    - A new field 'skip_work' is added to track when the timer handlers can
      queue a work. More comments present in code.
    
    Suggested-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Ashwin Chaugule <ashwin.chaugule@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 0c7589016b6c..76742902491e 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -132,12 +132,20 @@ static void *get_cpu_dbs_info_s(int cpu)				\
 struct cpu_common_dbs_info {
 	struct cpufreq_policy *policy;
 	/*
-	 * percpu mutex that serializes governor limit change with dbs_timer
-	 * invocation. We do not want dbs_timer to run when user is changing
-	 * the governor or limits.
+	 * Per policy mutex that serializes load evaluation from limit-change
+	 * and work-handler.
 	 */
 	struct mutex timer_mutex;
+
+	/*
+	 * Per policy lock that serializes access to queuing work from timer
+	 * handlers.
+	 */
+	spinlock_t timer_lock;
+
 	ktime_t time_stamp;
+	unsigned int skip_work;
+	struct work_struct work;
 };
 
 /* Per cpu structures */
@@ -152,7 +160,7 @@ struct cpu_dbs_info {
 	 * wake-up from idle.
 	 */
 	unsigned int prev_load;
-	struct delayed_work dwork;
+	struct timer_list timer;
 	struct cpu_common_dbs_info *shared;
 };
 
@@ -268,11 +276,11 @@ static ssize_t show_sampling_rate_min_gov_pol				\
 
 extern struct mutex cpufreq_governor_lock;
 
+void gov_add_timers(struct cpufreq_policy *policy, unsigned int delay);
+void gov_cancel_work(struct cpu_common_dbs_info *shared);
 void dbs_check_cpu(struct dbs_data *dbs_data, int cpu);
 int cpufreq_governor_dbs(struct cpufreq_policy *policy,
 		struct common_dbs_data *cdata, unsigned int event);
-void gov_queue_work(struct dbs_data *dbs_data, struct cpufreq_policy *policy,
-		unsigned int delay, bool all_cpus);
 void od_register_powersave_bias_handler(unsigned int (*f)
 		(struct cpufreq_policy *, unsigned int, unsigned int),
 		unsigned int powersave_bias);

commit affde5d06af1e39c2929e36a063e3912f02fc58f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Dec 3 09:37:51 2015 +0530

    cpufreq: governor: Pass policy as argument to ->gov_dbs_timer()
    
    Pass 'policy' as argument to ->gov_dbs_timer() instead of cdbs and
    dbs_data.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 5621bb03e874..0c7589016b6c 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -209,8 +209,7 @@ struct common_dbs_data {
 
 	struct cpu_dbs_info *(*get_cpu_cdbs)(int cpu);
 	void *(*get_cpu_dbs_info_s)(int cpu);
-	unsigned int (*gov_dbs_timer)(struct cpu_dbs_info *cdbs,
-				      struct dbs_data *dbs_data,
+	unsigned int (*gov_dbs_timer)(struct cpufreq_policy *policy,
 				      bool modify_all);
 	void (*gov_check_cpu)(int cpu, unsigned int load);
 	int (*init)(struct dbs_data *dbs_data, bool notify);

commit 03d5eec000973e80b1a1ccdef16ed8206621c3e4
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Sep 8 07:10:34 2015 +0530

    cpufreq: conservative: remove 'enable' field
    
    Conservative governor has its own 'enable' field to check if
    conservative governor is used for a CPU or not
    
    This can be checked by policy->governor with 'cpufreq_gov_conservative'
    and so this field can be dropped.
    
    Because its not guaranteed that dbs_info->cdbs.shared will a valid
    pointer for all CPUs (will be NULL for CPUs that don't use
    ondemand/conservative governors), we can't use it anymore. Lets get
    policy with cpufreq_cpu_get_raw() instead.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 50f171796632..5621bb03e874 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -170,7 +170,6 @@ struct cs_cpu_dbs_info_s {
 	struct cpu_dbs_info cdbs;
 	unsigned int down_skip;
 	unsigned int requested_freq;
-	unsigned int enable:1;
 };
 
 /* Per policy Governors sysfs tunables */

commit 43e0ee361e96229959c2ce1eda1ad9d6b3c191b2
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat Jul 18 11:31:00 2015 +0530

    cpufreq: governor: split out common part of {cs|od}_dbs_timer()
    
    Some part of cs_dbs_timer() and od_dbs_timer() is exactly same and is
    unnecessarily duplicated.
    
    Create the real work-handler in cpufreq_governor.c and put the common
    code in this routine (dbs_timer()).
    
    Shouldn't make any functional change.
    
    Reviewed-and-tested-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 8e4a25f0730c..50f171796632 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -132,8 +132,8 @@ static void *get_cpu_dbs_info_s(int cpu)				\
 struct cpu_common_dbs_info {
 	struct cpufreq_policy *policy;
 	/*
-	 * percpu mutex that serializes governor limit change with gov_dbs_timer
-	 * invocation. We do not want gov_dbs_timer to run when user is changing
+	 * percpu mutex that serializes governor limit change with dbs_timer
+	 * invocation. We do not want dbs_timer to run when user is changing
 	 * the governor or limits.
 	 */
 	struct mutex timer_mutex;
@@ -210,7 +210,9 @@ struct common_dbs_data {
 
 	struct cpu_dbs_info *(*get_cpu_cdbs)(int cpu);
 	void *(*get_cpu_dbs_info_s)(int cpu);
-	void (*gov_dbs_timer)(struct work_struct *work);
+	unsigned int (*gov_dbs_timer)(struct cpu_dbs_info *cdbs,
+				      struct dbs_data *dbs_data,
+				      bool modify_all);
 	void (*gov_check_cpu)(int cpu, unsigned int load);
 	int (*init)(struct dbs_data *dbs_data, bool notify);
 	void (*exit)(struct dbs_data *dbs_data, bool notify);
@@ -269,8 +271,6 @@ static ssize_t show_sampling_rate_min_gov_pol				\
 extern struct mutex cpufreq_governor_lock;
 
 void dbs_check_cpu(struct dbs_data *dbs_data, int cpu);
-bool need_load_eval(struct cpu_common_dbs_info *shared,
-		    unsigned int sampling_rate);
 int cpufreq_governor_dbs(struct cpufreq_policy *policy,
 		struct common_dbs_data *cdata, unsigned int event);
 void gov_queue_work(struct dbs_data *dbs_data, struct cpufreq_policy *policy,

commit 44152cb82d1ad6ae6f8b47c5437f6f1e65ca82c4
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat Jul 18 11:30:59 2015 +0530

    cpufreq: governor: Keep single copy of information common to policy->cpus
    
    Some information is common to all CPUs belonging to a policy, but are
    kept on per-cpu basis. Lets keep that in another structure common to all
    policy->cpus. That will make updates/reads to that less complex and less
    error prone.
    
    The memory for cpu_common_dbs_info is allocated/freed at INIT/EXIT, so
    that it we don't reallocate it for STOP/START sequence. It will be also
    be used (in next patch) while the governor is stopped and so must not be
    freed that early.
    
    Reviewed-and-tested-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index a0f8eb79ee6d..8e4a25f0730c 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -128,6 +128,18 @@ static void *get_cpu_dbs_info_s(int cpu)				\
  * cs_*: Conservative governor
  */
 
+/* Common to all CPUs of a policy */
+struct cpu_common_dbs_info {
+	struct cpufreq_policy *policy;
+	/*
+	 * percpu mutex that serializes governor limit change with gov_dbs_timer
+	 * invocation. We do not want gov_dbs_timer to run when user is changing
+	 * the governor or limits.
+	 */
+	struct mutex timer_mutex;
+	ktime_t time_stamp;
+};
+
 /* Per cpu structures */
 struct cpu_dbs_info {
 	u64 prev_cpu_idle;
@@ -140,15 +152,8 @@ struct cpu_dbs_info {
 	 * wake-up from idle.
 	 */
 	unsigned int prev_load;
-	struct cpufreq_policy *policy;
 	struct delayed_work dwork;
-	/*
-	 * percpu mutex that serializes governor limit change with gov_dbs_timer
-	 * invocation. We do not want gov_dbs_timer to run when user is changing
-	 * the governor or limits.
-	 */
-	struct mutex timer_mutex;
-	ktime_t time_stamp;
+	struct cpu_common_dbs_info *shared;
 };
 
 struct od_cpu_dbs_info_s {
@@ -264,7 +269,8 @@ static ssize_t show_sampling_rate_min_gov_pol				\
 extern struct mutex cpufreq_governor_lock;
 
 void dbs_check_cpu(struct dbs_data *dbs_data, int cpu);
-bool need_load_eval(struct cpu_dbs_info *cdbs, unsigned int sampling_rate);
+bool need_load_eval(struct cpu_common_dbs_info *shared,
+		    unsigned int sampling_rate);
 int cpufreq_governor_dbs(struct cpufreq_policy *policy,
 		struct common_dbs_data *cdata, unsigned int event);
 void gov_queue_work(struct dbs_data *dbs_data, struct cpufreq_policy *policy,

commit 42994af63cd1aafc9289035cf621e501b08732e9
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 19 17:18:05 2015 +0530

    cpufreq: governor: rename cur_policy as policy
    
    Just call it 'policy', cur_policy is unnecessarily long and doesn't
    have any special meaning.
    
    Reviewed-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 6b5e33f68064..a0f8eb79ee6d 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -140,7 +140,7 @@ struct cpu_dbs_info {
 	 * wake-up from idle.
 	 */
 	unsigned int prev_load;
-	struct cpufreq_policy *cur_policy;
+	struct cpufreq_policy *policy;
 	struct delayed_work dwork;
 	/*
 	 * percpu mutex that serializes governor limit change with gov_dbs_timer

commit 875b8508f9607b92e3ef4ece2fddf86d61351085
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 19 17:18:03 2015 +0530

    cpufreq: governor: Rename 'cpu_dbs_common_info' to 'cpu_dbs_info'
    
    Its not common info to all CPUs, but a structure representing common
    type of cpu info to both governor types. Lets drop 'common_' from its
    name.
    
    Reviewed-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 1bbf8c87fdd5..6b5e33f68064 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -109,7 +109,7 @@ store_one(_gov, file_name)
 
 /* create helper routines */
 #define define_get_cpu_dbs_routines(_dbs_info)				\
-static struct cpu_dbs_common_info *get_cpu_cdbs(int cpu)		\
+static struct cpu_dbs_info *get_cpu_cdbs(int cpu)			\
 {									\
 	return &per_cpu(_dbs_info, cpu).cdbs;				\
 }									\
@@ -129,7 +129,7 @@ static void *get_cpu_dbs_info_s(int cpu)				\
  */
 
 /* Per cpu structures */
-struct cpu_dbs_common_info {
+struct cpu_dbs_info {
 	u64 prev_cpu_idle;
 	u64 prev_cpu_wall;
 	u64 prev_cpu_nice;
@@ -152,7 +152,7 @@ struct cpu_dbs_common_info {
 };
 
 struct od_cpu_dbs_info_s {
-	struct cpu_dbs_common_info cdbs;
+	struct cpu_dbs_info cdbs;
 	struct cpufreq_frequency_table *freq_table;
 	unsigned int freq_lo;
 	unsigned int freq_lo_jiffies;
@@ -162,7 +162,7 @@ struct od_cpu_dbs_info_s {
 };
 
 struct cs_cpu_dbs_info_s {
-	struct cpu_dbs_common_info cdbs;
+	struct cpu_dbs_info cdbs;
 	unsigned int down_skip;
 	unsigned int requested_freq;
 	unsigned int enable:1;
@@ -203,7 +203,7 @@ struct common_dbs_data {
 	 */
 	struct dbs_data *gdbs_data;
 
-	struct cpu_dbs_common_info *(*get_cpu_cdbs)(int cpu);
+	struct cpu_dbs_info *(*get_cpu_cdbs)(int cpu);
 	void *(*get_cpu_dbs_info_s)(int cpu);
 	void (*gov_dbs_timer)(struct work_struct *work);
 	void (*gov_check_cpu)(int cpu, unsigned int load);
@@ -264,8 +264,7 @@ static ssize_t show_sampling_rate_min_gov_pol				\
 extern struct mutex cpufreq_governor_lock;
 
 void dbs_check_cpu(struct dbs_data *dbs_data, int cpu);
-bool need_load_eval(struct cpu_dbs_common_info *cdbs,
-		unsigned int sampling_rate);
+bool need_load_eval(struct cpu_dbs_info *cdbs, unsigned int sampling_rate);
 int cpufreq_governor_dbs(struct cpufreq_policy *policy,
 		struct common_dbs_data *cdata, unsigned int event);
 void gov_queue_work(struct dbs_data *dbs_data, struct cpufreq_policy *policy,

commit d3574c851148266177ea9ecae10a317e6eae94de
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 19 17:18:02 2015 +0530

    cpufreq: governor: Drop unused field 'cpu'
    
    Its not used at all, drop it.
    
    Reviewed-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 352eecaae789..1bbf8c87fdd5 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -130,7 +130,6 @@ static void *get_cpu_dbs_info_s(int cpu)				\
 
 /* Per cpu structures */
 struct cpu_dbs_common_info {
-	int cpu;
 	u64 prev_cpu_idle;
 	u64 prev_cpu_wall;
 	u64 prev_cpu_nice;

commit 386d46e6d5238c9648399eb1e0c418d06f4126a2
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 19 17:18:01 2015 +0530

    cpufreq: governor: Name delayed-work as dwork
    
    Delayed work was named as 'work' and to access work within it we do
    work.work. Not much readable. Rename delayed_work as 'dwork'.
    
    Reviewed-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 34736f5e869d..352eecaae789 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -142,7 +142,7 @@ struct cpu_dbs_common_info {
 	 */
 	unsigned int prev_load;
 	struct cpufreq_policy *cur_policy;
-	struct delayed_work work;
+	struct delayed_work dwork;
 	/*
 	 * percpu mutex that serializes governor limit change with gov_dbs_timer
 	 * invocation. We do not want gov_dbs_timer to run when user is changing

commit 732b6d617a4cfd8363d1f70a06bff38b8c1a19e9
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jun 3 15:57:13 2015 +0530

    cpufreq: governor: Serialize governor callbacks
    
    There are several races reported in cpufreq core around governors (only
    ondemand and conservative) by different people.
    
    There are at least two race scenarios present in governor code:
     (a) Concurrent access/updates of governor internal structures.
    
     It is possible that fields such as 'dbs_data->usage_count', etc.  are
     accessed simultaneously for different policies using same governor
     structure (i.e. CPUFREQ_HAVE_GOVERNOR_PER_POLICY flag unset). And
     because of this we can dereference bad pointers.
    
     For example consider a system with two CPUs with separate 'struct
     cpufreq_policy' instances. CPU0 governor: ondemand and CPU1: powersave.
     CPU0 switching to powersave and CPU1 to ondemand:
            CPU0                            CPU1
    
            store*                          store*
    
            cpufreq_governor_exit()         cpufreq_governor_init()
                                            dbs_data = cdata->gdbs_data;
    
            if (!--dbs_data->usage_count)
                    kfree(dbs_data);
    
                                            dbs_data->usage_count++;
                                            *Bad pointer dereference*
    
     There are other races possible between EXIT and START/STOP/LIMIT as
     well. Its really complicated.
    
     (b) Switching governor state in bad sequence:
    
     For example trying to switch a governor to START state, when the
     governor is in EXIT state. There are some checks present in
     __cpufreq_governor() but they aren't sufficient as they compare events
     against 'policy->governor_enabled', where as we need to take governor's
     state into account, which can be used by multiple policies.
    
    These two issues need to be solved separately and the responsibility
    should be properly divided between cpufreq and governor core.
    
    The first problem is more about the governor core, as it needs to
    protect its structures properly. And the second problem should be fixed
    in cpufreq core instead of governor, as its all about sequence of
    events.
    
    This patch is trying to solve only the first problem.
    
    There are two types of data we need to protect,
    - 'struct common_dbs_data': No matter what, there is going to be a
      single copy of this per governor.
    - 'struct dbs_data': With CPUFREQ_HAVE_GOVERNOR_PER_POLICY flag set, we
      will have per-policy copy of this data, otherwise a single copy.
    
    Because of such complexities, the mutex present in 'struct dbs_data' is
    insufficient to solve our problem. For example we need to protect
    fetching of 'dbs_data' from different structures at the beginning of
    cpufreq_governor_dbs(), to make sure it isn't currently being updated.
    
    This can be fixed if we can guarantee serialization of event parsing
    code for an individual governor. This is best solved with a mutex per
    governor, and the placeholder for that is 'struct common_dbs_data'.
    
    And so this patch moves the mutex from 'struct dbs_data' to 'struct
    common_dbs_data' and takes it at the beginning and drops it at the end
    of cpufreq_governor_dbs().
    
    Tested with and without following configuration options:
    
    CONFIG_LOCKDEP_SUPPORT=y
    CONFIG_DEBUG_RT_MUTEXES=y
    CONFIG_DEBUG_PI_LIST=y
    CONFIG_DEBUG_SPINLOCK=y
    CONFIG_DEBUG_MUTEXES=y
    CONFIG_DEBUG_LOCK_ALLOC=y
    CONFIG_PROVE_LOCKING=y
    CONFIG_LOCKDEP=y
    CONFIG_DEBUG_ATOMIC_SLEEP=y
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 1690120df487..34736f5e869d 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -213,6 +213,11 @@ struct common_dbs_data {
 
 	/* Governor specific ops, see below */
 	void *gov_ops;
+
+	/*
+	 * Protects governor's data (struct dbs_data and struct common_dbs_data)
+	 */
+	struct mutex mutex;
 };
 
 /* Governor Per policy data */
@@ -221,9 +226,6 @@ struct dbs_data {
 	unsigned int min_sampling_rate;
 	int usage_count;
 	void *tuners;
-
-	/* dbs_mutex protects dbs_enable in governor start/stop */
-	struct mutex mutex;
 };
 
 /* Governor specific ops, will be passed to dbs_data->gov_ops */

commit 8e0484d2b38aeb2bcce0a7b32e6b33d72c11ad85
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jun 3 15:57:11 2015 +0530

    cpufreq: governor: register notifier from cs_init()
    
    Notifiers are required only for conservative governor and the common
    governor code is unnecessarily polluted with that. Handle that from
    cs_init/exit() instead of cpufreq_governor_dbs().
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index cc401d147e72..1690120df487 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -208,8 +208,8 @@ struct common_dbs_data {
 	void *(*get_cpu_dbs_info_s)(int cpu);
 	void (*gov_dbs_timer)(struct work_struct *work);
 	void (*gov_check_cpu)(int cpu, unsigned int load);
-	int (*init)(struct dbs_data *dbs_data);
-	void (*exit)(struct dbs_data *dbs_data);
+	int (*init)(struct dbs_data *dbs_data, bool notify);
+	void (*exit)(struct dbs_data *dbs_data, bool notify);
 
 	/* Governor specific ops, see below */
 	void *gov_ops;
@@ -234,10 +234,6 @@ struct od_ops {
 	void (*freq_increase)(struct cpufreq_policy *policy, unsigned int freq);
 };
 
-struct cs_ops {
-	struct notifier_block *notifier_block;
-};
-
 static inline int delay_for_sampling_rate(unsigned int sampling_rate)
 {
 	int delay = usecs_to_jiffies(sampling_rate);

commit c8ae481b9a12f5cea080651ea87736104b111f8e
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jun 9 14:21:24 2014 +0530

    cpufreq: governor: remove copy_prev_load from 'struct cpu_dbs_common_info'
    
    'copy_prev_load' was recently added by commit: 18b46ab (cpufreq: governor: Be
    friendly towards latency-sensitive bursty workloads).
    
    It actually is a bit redundant as we also have 'prev_load' which can store any
    integer value and can be used instead of 'copy_prev_load' by setting it zero.
    
    True load can also turn out to be zero during long idle intervals (and hence the
    actual value of 'prev_load' and the overloaded value can clash). However this is
    not a problem because, if the true load was really zero in the previous
    interval, it makes sense to evaluate the load afresh for the current interval
    rather than copying the previous load.
    
    So, drop 'copy_prev_load' and use 'prev_load' instead.
    
    Update comments as well to make it more clear.
    
    There is another change here which was probably missed by Srivatsa during the
    last version of updates he made. The unlikely in the 'if' statement was covering
    only half of the condition and the whole line should actually come under it.
    
    Also checkpatch is made more silent as it was reporting this (--strict option):
    
    CHECK: Alignment should match open parenthesis
    +               if (unlikely(wall_time > (2 * sampling_rate) &&
    +                                               j_cdbs->prev_load)) {
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index c2a5b7e8070a..cc401d147e72 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -134,12 +134,13 @@ struct cpu_dbs_common_info {
 	u64 prev_cpu_idle;
 	u64 prev_cpu_wall;
 	u64 prev_cpu_nice;
-	unsigned int prev_load;
 	/*
-	 * Flag to ensure that we copy the previous load only once, upon the
-	 * first wake-up from idle.
+	 * Used to keep track of load in the previous interval. However, when
+	 * explicitly set to zero, it is used as a flag to ensure that we copy
+	 * the previous load to the current interval only once, upon the first
+	 * wake-up from idle.
 	 */
-	bool copy_prev_load;
+	unsigned int prev_load;
 	struct cpufreq_policy *cur_policy;
 	struct delayed_work work;
 	/*

commit 18b46abd0009516c1973a57ccf4d01b9eaa3422a
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Sun Jun 8 02:11:43 2014 +0530

    cpufreq: governor: Be friendly towards latency-sensitive bursty workloads
    
    Cpufreq governors like the ondemand governor calculate the load on the CPU
    periodically by employing deferrable timers. A deferrable timer won't fire
    if the CPU is completely idle (and there are no other timers to be run), in
    order to avoid unnecessary wakeups and thus save CPU power.
    
    However, the load calculation logic is agnostic to all this, and this can
    lead to the problem described below.
    
    Time (ms)               CPU 1
    
    100                Task-A running
    
    110                Governor's timer fires, finds load as 100% in the last
                       10ms interval and increases the CPU frequency.
    
    110.5              Task-A running
    
    120                Governor's timer fires, finds load as 100% in the last
                       10ms interval and increases the CPU frequency.
    
    125                Task-A went to sleep. With nothing else to do, CPU 1
                       went completely idle.
    
    200                Task-A woke up and started running again.
    
    200.5              Governor's deferred timer (which was originally programmed
                       to fire at time 130) fires now. It calculates load for the
                       time period 120 to 200.5, and finds the load is almost zero.
                       Hence it decreases the CPU frequency to the minimum.
    
    210                Governor's timer fires, finds load as 100% in the last
                       10ms interval and increases the CPU frequency.
    
    So, after the workload woke up and started running, the frequency was suddenly
    dropped to absolute minimum, and after that, there was an unnecessary delay of
    10ms (sampling period) to increase the CPU frequency back to a reasonable value.
    And this pattern repeats for every wake-up-from-cpu-idle for that workload.
    This can be quite undesirable for latency- or response-time sensitive bursty
    workloads. So we need to fix the governor's logic to detect such wake-up-from-
    cpu-idle scenarios and start the workload at a reasonably high CPU frequency.
    
    One extreme solution would be to fake a load of 100% in such scenarios. But
    that might lead to undesirable side-effects such as frequency spikes (which
    might also need voltage changes) especially if the previous frequency happened
    to be very low.
    
    We just want to avoid the stupidity of dropping down the frequency to a minimum
    and then enduring a needless (and long) delay before ramping it up back again.
    So, let us simply carry forward the previous load - that is, let us just pretend
    that the 'load' for the current time-window is the same as the load for the
    previous window. That way, the frequency and voltage will continue to be set
    to whatever values they were set at previously. This means that bursty workloads
    will get a chance to influence the CPU frequency at which they wake up from
    cpu-idle, based on their past execution history. Thus, they might be able to
    avoid suffering from slow wakeups and long response-times.
    
    However, we should take care not to over-do this. For example, such a "copy
    previous load" logic will benefit cases like this: (where # represents busy
    and . represents idle)
    
    ##########.........#########.........###########...........##########........
    
    but it will be detrimental in cases like the one shown below, because it will
    retain the high frequency (copied from the previous interval) even in a mostly
    idle system:
    
    ##########.........#.................#.....................#...............
    
    (i.e., the workload finished and the remaining tasks are such that their busy
    periods are smaller than the sampling interval, which causes the timer to
    always get deferred. So, this will make the copy-previous-load logic copy
    the initial high load to subsequent idle periods over and over again, thus
    keeping the frequency high unnecessarily).
    
    So, we modify this copy-previous-load logic such that it is used only once
    upon every wakeup-from-idle. Thus if we have 2 consecutive idle periods, the
    previous load won't get blindly copied over; cpufreq will freshly evaluate the
    load in the second idle interval, thus ensuring that the system comes back to
    its normal state.
    
    [ The right way to solve this whole problem is to teach the CPU frequency
    governors to also track load on a per-task basis, not just a per-CPU basis,
    and then use both the data sources intelligently to set the appropriate
    frequency on the CPUs. But that involves redesigning the cpufreq subsystem,
    so this patch should make the situation bearable until then. ]
    
    Experimental results:
    +-------------------+
    
    I ran a modified version of ebizzy (called 'sleeping-ebizzy') that sleeps in
    between its execution such that its total utilization can be a user-defined
    value, say 10% or 20% (higher the utilization specified, lesser the amount of
    sleeps injected). This ebizzy was run with a single-thread, tied to CPU 8.
    
    Behavior observed with tracing (sample taken from 40% utilization runs):
    ------------------------------------------------------------------------
    
    Without patch:
    ~~~~~~~~~~~~~~
    kworker/8:2-12137  416.335742: cpu_frequency: state=2061000 cpu_id=8
    kworker/8:2-12137  416.335744: sched_switch: prev_comm=kworker/8:2 ==> next_comm=ebizzy
          <...>-40753  416.345741: sched_switch: prev_comm=ebizzy ==> next_comm=kworker/8:2
    kworker/8:2-12137  416.345744: cpu_frequency: state=4123000 cpu_id=8
    kworker/8:2-12137  416.345746: sched_switch: prev_comm=kworker/8:2 ==> next_comm=ebizzy
          <...>-40753  416.355738: sched_switch: prev_comm=ebizzy ==> next_comm=kworker/8:2
    <snip>  ---------------------------------------------------------------------  <snip>
          <...>-40753  416.402202: sched_switch: prev_comm=ebizzy ==> next_comm=swapper/8
         <idle>-0      416.502130: sched_switch: prev_comm=swapper/8 ==> next_comm=ebizzy
          <...>-40753  416.505738: sched_switch: prev_comm=ebizzy ==> next_comm=kworker/8:2
    kworker/8:2-12137  416.505739: cpu_frequency: state=2061000 cpu_id=8
    kworker/8:2-12137  416.505741: sched_switch: prev_comm=kworker/8:2 ==> next_comm=ebizzy
          <...>-40753  416.515739: sched_switch: prev_comm=ebizzy ==> next_comm=kworker/8:2
    kworker/8:2-12137  416.515742: cpu_frequency: state=4123000 cpu_id=8
    kworker/8:2-12137  416.515744: sched_switch: prev_comm=kworker/8:2 ==> next_comm=ebizzy
    
    Observation: Ebizzy went idle at 416.402202, and started running again at
    416.502130. But cpufreq noticed the long idle period, and dropped the frequency
    at 416.505739, only to increase it back again at 416.515742, realizing that the
    workload is in-fact CPU bound. Thus ebizzy needlessly ran at the lowest frequency
    for almost 13 milliseconds (almost 1 full sample period), and this pattern
    repeats on every sleep-wakeup. This could hurt latency-sensitive workloads quite
    a lot.
    
    With patch:
    ~~~~~~~~~~~
    
    kworker/8:2-29802  464.832535: cpu_frequency: state=2061000 cpu_id=8
    <snip>  ---------------------------------------------------------------------  <snip>
    kworker/8:2-29802  464.962538: sched_switch: prev_comm=kworker/8:2 ==> next_comm=ebizzy
          <...>-40738  464.972533: sched_switch: prev_comm=ebizzy ==> next_comm=kworker/8:2
    kworker/8:2-29802  464.972536: cpu_frequency: state=4123000 cpu_id=8
    kworker/8:2-29802  464.972538: sched_switch: prev_comm=kworker/8:2 ==> next_comm=ebizzy
          <...>-40738  464.982531: sched_switch: prev_comm=ebizzy ==> next_comm=kworker/8:2
    <snip>  ---------------------------------------------------------------------  <snip>
    kworker/8:2-29802  465.022533: sched_switch: prev_comm=kworker/8:2 ==> next_comm=ebizzy
          <...>-40738  465.032531: sched_switch: prev_comm=ebizzy ==> next_comm=kworker/8:2
    kworker/8:2-29802  465.032532: sched_switch: prev_comm=kworker/8:2 ==> next_comm=ebizzy
          <...>-40738  465.035797: sched_switch: prev_comm=ebizzy ==> next_comm=swapper/8
         <idle>-0      465.240178: sched_switch: prev_comm=swapper/8 ==> next_comm=ebizzy
          <...>-40738  465.242533: sched_switch: prev_comm=ebizzy ==> next_comm=kworker/8:2
    kworker/8:2-29802  465.242535: sched_switch: prev_comm=kworker/8:2 ==> next_comm=ebizzy
          <...>-40738  465.252531: sched_switch: prev_comm=ebizzy ==> next_comm=kworker/8:2
    
    Observation: Ebizzy went idle at 465.035797, and started running again at
    465.240178. Since ebizzy was the only real workload running on this CPU,
    cpufreq retained the frequency at 4.1Ghz throughout the run of ebizzy, no
    matter how many times ebizzy slept and woke-up in-between. Thus, ebizzy
    got the 10ms worth of 4.1 Ghz benefit during every sleep-wakeup (as compared
    to the run without the patch) and this boost gave a modest improvement in total
    throughput, as shown below.
    
    Sleeping-ebizzy records-per-second:
    -----------------------------------
    
    Utilization  Without patch  With patch  Difference (Absolute and % values)
        10%         274767        277046        +  2279 (+0.829%)
        20%         543429        553484        + 10055 (+1.850%)
        40%        1090744       1107959        + 17215 (+1.578%)
        60%        1634908       1662018        + 27110 (+1.658%)
    
    A rudimentary and somewhat approximately latency-sensitive workload such as
    sleeping-ebizzy itself showed a consistent, noticeable performance improvement
    with this patch. Hence, workloads that are truly latency-sensitive will benefit
    quite a bit from this change. Moreover, this is an overall win-win since this
    patch does not hurt power-savings at all (because, this patch does not reduce
    the idle time or idle residency; and the high frequency of the CPU when it goes
    to cpu-idle does not affect/hurt the power-savings of deep idle states).
    
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Reviewed-by: Gautham R. Shenoy <ego@linux.vnet.ibm.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index bfb9ae14142c..c2a5b7e8070a 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -134,6 +134,12 @@ struct cpu_dbs_common_info {
 	u64 prev_cpu_idle;
 	u64 prev_cpu_wall;
 	u64 prev_cpu_nice;
+	unsigned int prev_load;
+	/*
+	 * Flag to ensure that we copy the previous load only once, upon the
+	 * first wake-up from idle.
+	 */
+	bool copy_prev_load;
 	struct cpufreq_policy *cur_policy;
 	struct delayed_work work;
 	/*

commit 6f1e4efd882eccca10bac45b77e14bcb4979dc54
Author: Jane Li <jiel@marvell.com>
Date:   Fri Jan 3 17:17:41 2014 +0800

    cpufreq: Fix timer/workqueue corruption by protecting reading governor_enabled
    
    When a CPU is hot removed we'll cancel all the delayed work items via
    gov_cancel_work(). Sometimes the delayed work function determines that
    it should adjust the delay for all other CPUs that the policy is
    managing. If this scenario occurs, the canceling CPU will cancel its own
    work but queue up the other CPUs works to run.
    
    Commit 3617f2 (cpufreq: Fix timer/workqueue corruption due to double
    queueing) has tried to fix this, but reading governor_enabled is not
    protected by cpufreq_governor_lock. Even though od_dbs_timer() checks
    governor_enabled before gov_queue_work(), this scenario may occur. For
    example:
    
     CPU0                                        CPU1
     ----                                        ----
     cpu_down()
      ...                                        <work runs>
      __cpufreq_remove_dev()                     od_dbs_timer()
       __cpufreq_governor()                       policy->governor_enabled
        policy->governor_enabled = false;
        cpufreq_governor_dbs()
         case CPUFREQ_GOV_STOP:
          gov_cancel_work(dbs_data, policy);
           cpu0 work is canceled
            timer is canceled
            cpu1 work is canceled
            <waits for cpu1>
                                                  gov_queue_work(*, *, true);
                                                   cpu0 work queued
                                                   cpu1 work queued
                                                   cpu2 work queued
                                                   ...
            cpu1 work is canceled
            cpu2 work is canceled
            ...
    
    At the end of the GOV_STOP case cpu0 still has a work queued to
    run although the code is expecting all of the works to be
    canceled. __cpufreq_remove_dev() will then proceed to
    re-initialize all the other CPUs works except for the CPU that is
    going down. The CPUFREQ_GOV_START case in cpufreq_governor_dbs()
    will trample over the queued work and debugobjects will spit out
    a warning:
    
    WARNING: at lib/debugobjects.c:260 debug_print_object+0x94/0xbc()
    ODEBUG: init active (active state 0) object type: timer_list hint: delayed_work_timer_fn+0x0/0x14
    Modules linked in:
    CPU: 1 PID: 1205 Comm: sh Tainted: G        W    3.10.0 #200
    [<c01144f0>] (unwind_backtrace+0x0/0xf8) from [<c0111d98>] (show_stack+0x10/0x14)
    [<c0111d98>] (show_stack+0x10/0x14) from [<c01272cc>] (warn_slowpath_common+0x4c/0x68)
    [<c01272cc>] (warn_slowpath_common+0x4c/0x68) from [<c012737c>] (warn_slowpath_fmt+0x30/0x40)
    [<c012737c>] (warn_slowpath_fmt+0x30/0x40) from [<c034c640>] (debug_print_object+0x94/0xbc)
    [<c034c640>] (debug_print_object+0x94/0xbc) from [<c034c7f8>] (__debug_object_init+0xc8/0x3c0)
    [<c034c7f8>] (__debug_object_init+0xc8/0x3c0) from [<c01360e0>] (init_timer_key+0x20/0x104)
    [<c01360e0>] (init_timer_key+0x20/0x104) from [<c04872ac>] (cpufreq_governor_dbs+0x1dc/0x68c)
    [<c04872ac>] (cpufreq_governor_dbs+0x1dc/0x68c) from [<c04833a8>] (__cpufreq_governor+0x80/0x1b0)
    [<c04833a8>] (__cpufreq_governor+0x80/0x1b0) from [<c0483704>] (__cpufreq_remove_dev.isra.12+0x22c/0x380)
    [<c0483704>] (__cpufreq_remove_dev.isra.12+0x22c/0x380) from [<c0692f38>] (cpufreq_cpu_callback+0x48/0x5c)
    [<c0692f38>] (cpufreq_cpu_callback+0x48/0x5c) from [<c014fb40>] (notifier_call_chain+0x44/0x84)
    [<c014fb40>] (notifier_call_chain+0x44/0x84) from [<c012ae44>] (__cpu_notify+0x2c/0x48)
    [<c012ae44>] (__cpu_notify+0x2c/0x48) from [<c068dd40>] (_cpu_down+0x80/0x258)
    [<c068dd40>] (_cpu_down+0x80/0x258) from [<c068df40>] (cpu_down+0x28/0x3c)
    [<c068df40>] (cpu_down+0x28/0x3c) from [<c068e4c0>] (store_online+0x30/0x74)
    [<c068e4c0>] (store_online+0x30/0x74) from [<c03a7308>] (dev_attr_store+0x18/0x24)
    [<c03a7308>] (dev_attr_store+0x18/0x24) from [<c0256fe0>] (sysfs_write_file+0x100/0x180)
    [<c0256fe0>] (sysfs_write_file+0x100/0x180) from [<c01fec9c>] (vfs_write+0xbc/0x184)
    [<c01fec9c>] (vfs_write+0xbc/0x184) from [<c01ff034>] (SyS_write+0x40/0x68)
    [<c01ff034>] (SyS_write+0x40/0x68) from [<c010e200>] (ret_fast_syscall+0x0/0x48)
    
    In gov_queue_work(), lock cpufreq_governor_lock before gov_queue_work,
    and unlock it after __gov_queue_work(). In this way, governor_enabled
    is guaranteed not changed in gov_queue_work().
    
    Signed-off-by: Jane Li <jiel@marvell.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index b5f2b8618949..bfb9ae14142c 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -257,6 +257,8 @@ static ssize_t show_sampling_rate_min_gov_pol				\
 	return sprintf(buf, "%u\n", dbs_data->min_sampling_rate);	\
 }
 
+extern struct mutex cpufreq_governor_lock;
+
 void dbs_check_cpu(struct dbs_data *dbs_data, int cpu);
 bool need_load_eval(struct cpu_dbs_common_info *cdbs,
 		unsigned int sampling_rate);

commit 0b981e70748861a3e10ea2e2a689bdcee3e15085
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Oct 2 14:13:18 2013 +0530

    cpufreq: use cpufreq_driver->flags to mark CPUFREQ_HAVE_GOVERNOR_PER_POLICY
    
    Use cpufreq_driver->flags to mark CPUFREQ_HAVE_GOVERNOR_PER_POLICY instead
    of a separate field within cpufreq_driver. This will save some bytes of
    memory.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 88cd39f7b0e9..b5f2b8618949 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -191,7 +191,10 @@ struct common_dbs_data {
 	struct attribute_group *attr_group_gov_sys; /* one governor - system */
 	struct attribute_group *attr_group_gov_pol; /* one governor - policy */
 
-	/* Common data for platforms that don't set have_governor_per_policy */
+	/*
+	 * Common data for platforms that don't set
+	 * CPUFREQ_HAVE_GOVERNOR_PER_POLICY
+	 */
 	struct dbs_data *gdbs_data;
 
 	struct cpu_dbs_common_info *(*get_cpu_cdbs)(int cpu);

commit c4afc410942f9f0675a5431adbdb03cf5908d1df
Author: Stratos Karafotis <stratosk@semaphore.gr>
Date:   Mon Aug 26 21:42:21 2013 +0300

    cpufreq: governor: Fix typos in comments
    
     - 'Governer' should be 'Governor'.
     - 'S' is used for Siemens (electrical conductance) in SI units,
       so use small 's' for seconds.
    
    Signed-off-by: Stratos Karafotis <stratosk@semaphore.gr>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index a02d78b25898..88cd39f7b0e9 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -25,11 +25,11 @@
 /*
  * The polling frequency depends on the capability of the processor. Default
  * polling frequency is 1000 times the transition latency of the processor. The
- * governor will work on any processor with transition latency <= 10mS, using
+ * governor will work on any processor with transition latency <= 10ms, using
  * appropriate sampling rate.
  *
- * For CPUs with transition latency > 10mS (mostly drivers with CPUFREQ_ETERNAL)
- * this governor will not work. All times here are in uS.
+ * For CPUs with transition latency > 10ms (mostly drivers with CPUFREQ_ETERNAL)
+ * this governor will not work. All times here are in us (micro seconds).
  */
 #define MIN_SAMPLING_RATE_RATIO			(2)
 #define LATENCY_MULTIPLIER			(1000)
@@ -162,7 +162,7 @@ struct cs_cpu_dbs_info_s {
 	unsigned int enable:1;
 };
 
-/* Per policy Governers sysfs tunables */
+/* Per policy Governors sysfs tunables */
 struct od_dbs_tuners {
 	unsigned int ignore_nice_load;
 	unsigned int sampling_rate;
@@ -181,7 +181,7 @@ struct cs_dbs_tuners {
 	unsigned int freq_step;
 };
 
-/* Common Governer data across policies */
+/* Common Governor data across policies */
 struct dbs_data;
 struct common_dbs_data {
 	/* Common across governors */
@@ -205,7 +205,7 @@ struct common_dbs_data {
 	void *gov_ops;
 };
 
-/* Governer Per policy data */
+/* Governor Per policy data */
 struct dbs_data {
 	struct common_dbs_data *cdata;
 	unsigned int min_sampling_rate;

commit c49a089c3eedbc4b3fa9c3d469599a6c14dea4c5
Merge: d4e4ab86bcba 3de9bdeb2863
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Wed Aug 14 22:21:16 2013 +0200

    Merge back earlier 'pm-cpufreq' material

commit 3a3e9e06d0c11b8efa95933a88c9e67209fa4330
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Aug 6 22:53:05 2013 +0530

    cpufreq: Give consistent names to cpufreq_policy objects
    
    They are called policy, cur_policy, new_policy, data, etc.  Just call
    them policy wherever possible.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index cf0b7a4425b0..264e509a9149 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -221,7 +221,7 @@ struct od_ops {
 	void (*powersave_bias_init_cpu)(int cpu);
 	unsigned int (*powersave_bias_target)(struct cpufreq_policy *policy,
 			unsigned int freq_next, unsigned int relation);
-	void (*freq_increase)(struct cpufreq_policy *p, unsigned int freq);
+	void (*freq_increase)(struct cpufreq_policy *policy, unsigned int freq);
 };
 
 struct cs_ops {

commit 5ff0a268037d344f86df690ccb994d8bc015d2d9
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Aug 6 22:53:03 2013 +0530

    cpufreq: Clean up header files included in the core
    
    This patch addresses the following issues in the header files in the
    cpufreq core:
     - Include headers in ascending order, so that we don't add same
       many times by mistake.
     - <asm/> must be included after <linux/>, so that they override
       whatever they need to.
     - Remove unnecessary includes.
     - Don't include files already included by cpufreq.h or
       cpufreq_governor.h.
    
    [rjw: Changelog]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 0e0dd4c82020..cf0b7a4425b0 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -18,10 +18,9 @@
 #define _CPUFREQ_GOVERNOR_H
 
 #include <linux/cpufreq.h>
-#include <linux/kobject.h>
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
 #include <linux/mutex.h>
-#include <linux/workqueue.h>
-#include <linux/sysfs.h>
 
 /*
  * The polling frequency depends on the capability of the processor. Default

commit 6c4640c3adfd97ce10efed7c07405f52d002b9a8
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Aug 5 12:28:02 2013 +0530

    cpufreq: rename ignore_nice as ignore_nice_load
    
    This sysfs file was called ignore_nice_load earlier and commit
    4d5dcc4 (cpufreq: governor: Implement per policy instances of
    governors) changed its name to ignore_nice by mistake.
    
    Lets get it renamed back to its original name.
    
    Reported-by: Martin von Gagern <Martin.vGagern@gmx.net>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: 3.10+ <stable@vger.kernel.org> # 3.10+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 6663ec3b3056..d5f12b4b11b8 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -165,7 +165,7 @@ struct cs_cpu_dbs_info_s {
 
 /* Per policy Governers sysfs tunables */
 struct od_dbs_tuners {
-	unsigned int ignore_nice;
+	unsigned int ignore_nice_load;
 	unsigned int sampling_rate;
 	unsigned int sampling_down_factor;
 	unsigned int up_threshold;
@@ -175,7 +175,7 @@ struct od_dbs_tuners {
 };
 
 struct cs_dbs_tuners {
-	unsigned int ignore_nice;
+	unsigned int ignore_nice_load;
 	unsigned int sampling_rate;
 	unsigned int sampling_down_factor;
 	unsigned int up_threshold;

commit dfa5bb622555d9da0df21b50f46ebdeef390041b
Author: Stratos Karafotis <stratosk@semaphore.gr>
Date:   Wed Jun 5 19:01:25 2013 +0300

    cpufreq: ondemand: Change the calculation of target frequency
    
    The ondemand governor calculates load in terms of frequency and
    increases it only if load_freq is greater than up_threshold
    multiplied by the current or average frequency.  This appears to
    produce oscillations of frequency between min and max because,
    for example, a relatively small load can easily saturate minimum
    frequency and lead the CPU to the max.  Then, it will decrease
    back to the min due to small load_freq.
    
    Change the calculation method of load and target frequency on the
    basis of the following two observations:
    
     - Load computation should not depend on the current or average
       measured frequency.  For example, absolute load of 80% at 100MHz
       is not necessarily equivalent to 8% at 1000MHz in the next
       sampling interval.
    
     - It should be possible to increase the target frequency to any
       value present in the frequency table proportional to the absolute
       load, rather than to the max only, so that:
    
       Target frequency = C * load
    
       where we take C = policy->cpuinfo.max_freq / 100.
    
    Tested on Intel i7-3770 CPU @ 3.40GHz and on Quad core 1500MHz Krait.
    Phoronix benchmark of Linux Kernel Compilation 3.1 test shows an
    increase ~1.5% in performance. cpufreq_stats (time_in_state) shows
    that middle frequencies are used more, with this patch.  Highest
    and lowest frequencies were used less by ~9%.
    
    [rjw: We have run multiple other tests on kernels with this
     change applied and in the vast majority of cases it turns out
     that the resulting performance improvement also leads to reduced
     consumption of energy.  The change is additionally justified by
     the overall simplification of the code in question.]
    
    Signed-off-by: Stratos Karafotis <stratosk@semaphore.gr>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 6663ec3b3056..0e0dd4c82020 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -169,7 +169,6 @@ struct od_dbs_tuners {
 	unsigned int sampling_rate;
 	unsigned int sampling_down_factor;
 	unsigned int up_threshold;
-	unsigned int adj_up_threshold;
 	unsigned int powersave_bias;
 	unsigned int io_is_busy;
 };

commit bb176f7d038fee4d46b3293e64e173bfb05ab7b5
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jun 19 14:19:33 2013 +0530

    cpufreq: Fix minor formatting issues
    
    There were a few noticeable formatting issues in core cpufreq code.
    This cleans them up to make code look better.  The changes include:
     - Whitespace cleanup.
     - Rearrangements of code.
     - Multiline comments fixes.
     - Formatting changes to fit 80 columns.
    
    Copyright information in cpufreq.c is also updated to include my name
    for 2013.
    
    [rjw: Changelog]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index e7bbf767380d..6663ec3b3056 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -81,7 +81,7 @@ static ssize_t show_##file_name##_gov_sys				\
 	return sprintf(buf, "%u\n", tuners->file_name);			\
 }									\
 									\
-static ssize_t show_##file_name##_gov_pol					\
+static ssize_t show_##file_name##_gov_pol				\
 (struct cpufreq_policy *policy, char *buf)				\
 {									\
 	struct dbs_data *dbs_data = policy->governor_data;		\
@@ -91,7 +91,7 @@ static ssize_t show_##file_name##_gov_pol					\
 
 #define store_one(_gov, file_name)					\
 static ssize_t store_##file_name##_gov_sys				\
-(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count)	\
+(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count) \
 {									\
 	struct dbs_data *dbs_data = _gov##_dbs_cdata.gdbs_data;		\
 	return store_##file_name(dbs_data, buf, count);			\

commit 72a4ce340a7ebf39e1c6fdc8f5feb4f974d6c635
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri May 17 11:26:32 2013 +0000

    cpufreq: Move get_cpu_idle_time() to cpufreq.c
    
    Governors other than ondemand and conservative can also use
    get_cpu_idle_time() and they aren't required to compile
    cpufreq_governor.c. So, move these independent routines to
    cpufreq.c instead.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index e16a96130cb3..e7bbf767380d 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -256,7 +256,6 @@ static ssize_t show_sampling_rate_min_gov_pol				\
 	return sprintf(buf, "%u\n", dbs_data->min_sampling_rate);	\
 }
 
-u64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy);
 void dbs_check_cpu(struct dbs_data *dbs_data, int cpu);
 bool need_load_eval(struct cpu_dbs_common_info *cdbs,
 		unsigned int sampling_rate);

commit a97c98adddbe98e824b69e6d7b320c8dc91fe581
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Apr 30 14:32:17 2013 +0000

    cpufreq: governors: Fix CPUFREQ_GOV_POLICY_{INIT|EXIT} notifiers
    
    There are two types of INIT/EXIT activities that we need to do for
    governors:
     - Done only once per governor (doesn't depend how many instances of
       the governor there are). eg: cpufreq_register_notifier() for
       conservative governor.
     - Done per governor instance, eg: sysfs_{create|remove}_group().
    
    There were some corner cases where current code isn't able to handle
    them separately and so failing for some test cases.
    
    We use two separate variables now for keeping track of above two
    requirements.
     - governor->initialized for first one
     - dbs_data->usage_count for per governor instance
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 8ac33538d0bd..e16a96130cb3 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -211,6 +211,7 @@ struct common_dbs_data {
 struct dbs_data {
 	struct common_dbs_data *cdata;
 	unsigned int min_sampling_rate;
+	int usage_count;
 	void *tuners;
 
 	/* dbs_mutex protects dbs_enable in governor start/stop */

commit 885f925eef411f549f17bc64dd054a3269cf66cd
Merge: e4f5a3adc454 45c009a9a447
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Apr 28 02:10:46 2013 +0200

    Merge branch 'pm-cpufreq'
    
    * pm-cpufreq: (57 commits)
      cpufreq: MAINTAINERS: Add co-maintainer
      cpufreq: pxa2xx: initialize variables
      ARM: S5pv210: compiling issue, ARM_S5PV210_CPUFREQ needs CONFIG_CPU_FREQ_TABLE=y
      cpufreq: cpu0: Put cpu parent node after using it
      cpufreq: ARM big LITTLE: Adapt to latest cpufreq updates
      cpufreq: ARM big LITTLE: put DT nodes after using them
      cpufreq: Don't call __cpufreq_governor() for drivers without target()
      cpufreq: exynos5440: Protect OPP search calls with RCU lock
      cpufreq: dbx500: Round to closest available freq
      cpufreq: Call __cpufreq_governor() with correct policy->cpus mask
      cpufreq / intel_pstate: Optimize intel_pstate_set_policy
      cpufreq: OMAP: instantiate omap-cpufreq as a platform_driver
      arm: exynos: Enable OPP library support for exynos5440
      cpufreq: exynos: Remove error return even if no soc is found
      cpufreq: exynos: Add cpufreq driver for exynos5440
      cpufreq: AMD "frequency sensitivity feedback" powersave bias for ondemand governor
      cpufreq: ondemand: allow custom powersave_bias_target handler to be registered
      cpufreq: convert cpufreq_driver to using RCU
      cpufreq: powerpc/platforms/cell: move cpufreq driver to drivers/cpufreq
      cpufreq: sparc: move cpufreq driver to drivers/cpufreq
      ...
    
    Conflicts:
            MAINTAINERS (with commit a8e39c3 from pm-cpuidle)
            drivers/cpufreq/cpufreq_governor.h (with commit beb0ff3)

commit fb30809efa3edeb692a6b29125a07c9eceb322dc
Author: Jacob Shin <jacob.shin@amd.com>
Date:   Tue Apr 2 09:56:56 2013 -0500

    cpufreq: ondemand: allow custom powersave_bias_target handler to be registered
    
    This allows for another [arch specific] driver to hook into existing
    powersave bias function of the ondemand governor. i.e. This allows AMD
    specific powersave bias function (in a separate AMD specific driver)
    to aid ondemand governor's frequency transition decisions.
    
    Signed-off-by: Jacob Shin <jacob.shin@amd.com>
    Acked-by: Thomas Renninger <trenn@suse.de>
    Acked-by: Borislav Petkov <bp@suse.de>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 513cc8234e5e..9f668e94dead 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -263,4 +263,8 @@ int cpufreq_governor_dbs(struct cpufreq_policy *policy,
 		struct common_dbs_data *cdata, unsigned int event);
 void gov_queue_work(struct dbs_data *dbs_data, struct cpufreq_policy *policy,
 		unsigned int delay, bool all_cpus);
+void od_register_powersave_bias_handler(unsigned int (*f)
+		(struct cpufreq_policy *, unsigned int, unsigned int),
+		unsigned int powersave_bias);
+void od_unregister_powersave_bias_handler(void);
 #endif /* _CPUFREQ_GOVERNER_H */

commit beb0ff390e208e71668a1389e3db02631a88cff5
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Apr 2 12:26:15 2013 +0000

    cpufreq: Correct header guards typo
    
    It should be "governor".
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 46bde01eee62..cc4bd2f6838a 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -14,8 +14,8 @@
  * published by the Free Software Foundation.
  */
 
-#ifndef _CPUFREQ_GOVERNER_H
-#define _CPUFREQ_GOVERNER_H
+#ifndef _CPUFREQ_GOVERNOR_H
+#define _CPUFREQ_GOVERNOR_H
 
 #include <linux/cpufreq.h>
 #include <linux/kobject.h>
@@ -175,4 +175,4 @@ bool need_load_eval(struct cpu_dbs_common_info *cdbs,
 		unsigned int sampling_rate);
 int cpufreq_governor_dbs(struct dbs_data *dbs_data,
 		struct cpufreq_policy *policy, unsigned int event);
-#endif /* _CPUFREQ_GOVERNER_H */
+#endif /* _CPUFREQ_GOVERNOR_H */

commit 9366d84052e7c5b2eca804c08cfcd00b490f4de2
Author: Stratos Karafotis <stratosk@semaphore.gr>
Date:   Thu Feb 28 16:57:32 2013 +0000

    cpufreq: governors: Calculate iowait time only when necessary
    
    Currently we always calculate the CPU iowait time and add it to idle time.
    If we are in ondemand and we use io_is_busy, we re-calculate iowait time
    and we subtract it from idle time.
    
    With this patch iowait time is calculated only when necessary avoiding
    the double call to get_cpu_iowait_time_us. We use a parameter in
    function get_cpu_idle_time to distinguish when the iowait time will be
    added to idle time or not, without the need of keeping the prev_io_wait.
    
    Signed-off-by: Stratos Karafotis <stratosk@semaphore.gr>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.,org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index c9c269f2b973..513cc8234e5e 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -148,7 +148,6 @@ struct cpu_dbs_common_info {
 
 struct od_cpu_dbs_info_s {
 	struct cpu_dbs_common_info cdbs;
-	u64 prev_cpu_iowait;
 	struct cpufreq_frequency_table *freq_table;
 	unsigned int freq_lo;
 	unsigned int freq_lo_jiffies;
@@ -256,7 +255,7 @@ static ssize_t show_sampling_rate_min_gov_pol				\
 	return sprintf(buf, "%u\n", dbs_data->min_sampling_rate);	\
 }
 
-u64 get_cpu_idle_time(unsigned int cpu, u64 *wall);
+u64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy);
 void dbs_check_cpu(struct dbs_data *dbs_data, int cpu);
 bool need_load_eval(struct cpu_dbs_common_info *cdbs,
 		unsigned int sampling_rate);

commit 031299b3be30f3ecab110fff8faad85af70e1797
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Feb 27 12:24:03 2013 +0530

    cpufreq: governors: Avoid unnecessary per cpu timer interrupts
    
    Following patch has introduced per cpu timers or works for ondemand and
    conservative governors.
    
            commit 2abfa876f1117b0ab45f191fb1f82c41b1cbc8fe
            Author: Rickard Andersson <rickard.andersson@stericsson.com>
            Date:   Thu Dec 27 14:55:38 2012 +0000
    
                cpufreq: handle SW coordinated CPUs
    
    This causes additional unnecessary interrupts on all cpus when the load is
    recently evaluated by any other cpu. i.e. When load is recently evaluated by cpu
    x, we don't really need any other cpu to evaluate this load again for the next
    sampling_rate time.
    
    Some sort of code is present to avoid that but we are still getting timer
    interrupts for all cpus. A good way of avoiding this would be to modify delays
    for all cpus (policy->cpus) whenever any cpu has evaluated load.
    
    This patch does this change and some related code cleanup.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 27b588aeacc1..c9c269f2b973 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -262,4 +262,6 @@ bool need_load_eval(struct cpu_dbs_common_info *cdbs,
 		unsigned int sampling_rate);
 int cpufreq_governor_dbs(struct cpufreq_policy *policy,
 		struct common_dbs_data *cdata, unsigned int event);
+void gov_queue_work(struct dbs_data *dbs_data, struct cpufreq_policy *policy,
+		unsigned int delay, bool all_cpus);
 #endif /* _CPUFREQ_GOVERNER_H */

commit 98104ee28f451024170a9dfb7bec31bfcb7e7c14
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Feb 26 15:07:24 2013 +0530

    cpufreq: governor: Set MIN_LATENCY_MULTIPLIER to 20
    
    Currently MIN_LATENCY_MULTIPLIER is set defined as 100 and so on a system with
    transition latency of 1 ms, the minimum sampling time comes to be around 100 ms.
    That is quite big if you want to get better performance for your system.
    
    Redefine MIN_LATENCY_MULTIPLIER to 20 so that we can support 20ms sampling rate
    for such platforms.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index c83cabf14b2f..27b588aeacc1 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -34,7 +34,7 @@
  */
 #define MIN_SAMPLING_RATE_RATIO			(2)
 #define LATENCY_MULTIPLIER			(1000)
-#define MIN_LATENCY_MULTIPLIER			(100)
+#define MIN_LATENCY_MULTIPLIER			(20)
 #define TRANSITION_LATENCY_LIMIT		(10 * 1000 * 1000)
 
 /* Ondemand Sampling types */

commit 4d5dcc4211f9def4281eafb54b8ed483862e8135
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Mar 27 15:58:58 2013 +0000

    cpufreq: governor: Implement per policy instances of governors
    
    Currently, there can't be multiple instances of single governor_type.
    If we have a multi-package system, where we have multiple instances
    of struct policy (per package), we can't have multiple instances of
    same governor. i.e. We can't have multiple instances of ondemand
    governor for multiple packages.
    
    Governors directory in sysfs is created at /sys/devices/system/cpu/cpufreq/
    governor-name/. Which again reflects that there can be only one
    instance of a governor_type in the system.
    
    This is a bottleneck for multicluster system, where we want different
    packages to use same governor type, but with different tunables.
    
    This patch uses the infrastructure provided by earlier patch and
    implements init/exit routines for ondemand and conservative
    governors.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 46bde01eee62..c83cabf14b2f 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -40,14 +40,75 @@
 /* Ondemand Sampling types */
 enum {OD_NORMAL_SAMPLE, OD_SUB_SAMPLE};
 
-/* Macro creating sysfs show routines */
-#define show_one(_gov, file_name, object)				\
-static ssize_t show_##file_name						\
+/*
+ * Macro for creating governors sysfs routines
+ *
+ * - gov_sys: One governor instance per whole system
+ * - gov_pol: One governor instance per policy
+ */
+
+/* Create attributes */
+#define gov_sys_attr_ro(_name)						\
+static struct global_attr _name##_gov_sys =				\
+__ATTR(_name, 0444, show_##_name##_gov_sys, NULL)
+
+#define gov_sys_attr_rw(_name)						\
+static struct global_attr _name##_gov_sys =				\
+__ATTR(_name, 0644, show_##_name##_gov_sys, store_##_name##_gov_sys)
+
+#define gov_pol_attr_ro(_name)						\
+static struct freq_attr _name##_gov_pol =				\
+__ATTR(_name, 0444, show_##_name##_gov_pol, NULL)
+
+#define gov_pol_attr_rw(_name)						\
+static struct freq_attr _name##_gov_pol =				\
+__ATTR(_name, 0644, show_##_name##_gov_pol, store_##_name##_gov_pol)
+
+#define gov_sys_pol_attr_rw(_name)					\
+	gov_sys_attr_rw(_name);						\
+	gov_pol_attr_rw(_name)
+
+#define gov_sys_pol_attr_ro(_name)					\
+	gov_sys_attr_ro(_name);						\
+	gov_pol_attr_ro(_name)
+
+/* Create show/store routines */
+#define show_one(_gov, file_name)					\
+static ssize_t show_##file_name##_gov_sys				\
 (struct kobject *kobj, struct attribute *attr, char *buf)		\
 {									\
-	return sprintf(buf, "%u\n", _gov##_tuners.object);		\
+	struct _gov##_dbs_tuners *tuners = _gov##_dbs_cdata.gdbs_data->tuners; \
+	return sprintf(buf, "%u\n", tuners->file_name);			\
+}									\
+									\
+static ssize_t show_##file_name##_gov_pol					\
+(struct cpufreq_policy *policy, char *buf)				\
+{									\
+	struct dbs_data *dbs_data = policy->governor_data;		\
+	struct _gov##_dbs_tuners *tuners = dbs_data->tuners;		\
+	return sprintf(buf, "%u\n", tuners->file_name);			\
+}
+
+#define store_one(_gov, file_name)					\
+static ssize_t store_##file_name##_gov_sys				\
+(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count)	\
+{									\
+	struct dbs_data *dbs_data = _gov##_dbs_cdata.gdbs_data;		\
+	return store_##file_name(dbs_data, buf, count);			\
+}									\
+									\
+static ssize_t store_##file_name##_gov_pol				\
+(struct cpufreq_policy *policy, const char *buf, size_t count)		\
+{									\
+	struct dbs_data *dbs_data = policy->governor_data;		\
+	return store_##file_name(dbs_data, buf, count);			\
 }
 
+#define show_store_one(_gov, file_name)					\
+show_one(_gov, file_name);						\
+store_one(_gov, file_name)
+
+/* create helper routines */
 #define define_get_cpu_dbs_routines(_dbs_info)				\
 static struct cpu_dbs_common_info *get_cpu_cdbs(int cpu)		\
 {									\
@@ -103,7 +164,7 @@ struct cs_cpu_dbs_info_s {
 	unsigned int enable:1;
 };
 
-/* Governers sysfs tunables */
+/* Per policy Governers sysfs tunables */
 struct od_dbs_tuners {
 	unsigned int ignore_nice;
 	unsigned int sampling_rate;
@@ -123,31 +184,42 @@ struct cs_dbs_tuners {
 	unsigned int freq_step;
 };
 
-/* Per Governer data */
-struct dbs_data {
+/* Common Governer data across policies */
+struct dbs_data;
+struct common_dbs_data {
 	/* Common across governors */
 	#define GOV_ONDEMAND		0
 	#define GOV_CONSERVATIVE	1
 	int governor;
-	unsigned int min_sampling_rate;
-	struct attribute_group *attr_group;
-	void *tuners;
+	struct attribute_group *attr_group_gov_sys; /* one governor - system */
+	struct attribute_group *attr_group_gov_pol; /* one governor - policy */
 
-	/* dbs_mutex protects dbs_enable in governor start/stop */
-	struct mutex mutex;
+	/* Common data for platforms that don't set have_governor_per_policy */
+	struct dbs_data *gdbs_data;
 
 	struct cpu_dbs_common_info *(*get_cpu_cdbs)(int cpu);
 	void *(*get_cpu_dbs_info_s)(int cpu);
 	void (*gov_dbs_timer)(struct work_struct *work);
 	void (*gov_check_cpu)(int cpu, unsigned int load);
+	int (*init)(struct dbs_data *dbs_data);
+	void (*exit)(struct dbs_data *dbs_data);
 
 	/* Governor specific ops, see below */
 	void *gov_ops;
 };
 
+/* Governer Per policy data */
+struct dbs_data {
+	struct common_dbs_data *cdata;
+	unsigned int min_sampling_rate;
+	void *tuners;
+
+	/* dbs_mutex protects dbs_enable in governor start/stop */
+	struct mutex mutex;
+};
+
 /* Governor specific ops, will be passed to dbs_data->gov_ops */
 struct od_ops {
-	int (*io_busy)(void);
 	void (*powersave_bias_init_cpu)(int cpu);
 	unsigned int (*powersave_bias_target)(struct cpufreq_policy *policy,
 			unsigned int freq_next, unsigned int relation);
@@ -169,10 +241,25 @@ static inline int delay_for_sampling_rate(unsigned int sampling_rate)
 	return delay;
 }
 
+#define declare_show_sampling_rate_min(_gov)				\
+static ssize_t show_sampling_rate_min_gov_sys				\
+(struct kobject *kobj, struct attribute *attr, char *buf)		\
+{									\
+	struct dbs_data *dbs_data = _gov##_dbs_cdata.gdbs_data;		\
+	return sprintf(buf, "%u\n", dbs_data->min_sampling_rate);	\
+}									\
+									\
+static ssize_t show_sampling_rate_min_gov_pol				\
+(struct cpufreq_policy *policy, char *buf)				\
+{									\
+	struct dbs_data *dbs_data = policy->governor_data;		\
+	return sprintf(buf, "%u\n", dbs_data->min_sampling_rate);	\
+}
+
 u64 get_cpu_idle_time(unsigned int cpu, u64 *wall);
 void dbs_check_cpu(struct dbs_data *dbs_data, int cpu);
 bool need_load_eval(struct cpu_dbs_common_info *cdbs,
 		unsigned int sampling_rate);
-int cpufreq_governor_dbs(struct dbs_data *dbs_data,
-		struct cpufreq_policy *policy, unsigned int event);
+int cpufreq_governor_dbs(struct cpufreq_policy *policy,
+		struct common_dbs_data *cdata, unsigned int event);
 #endif /* _CPUFREQ_GOVERNER_H */

commit e5dde92cb2befb108ae8cfe8db68a954c164d77c
Author: Namhyung Kim <namhyung.kim@lge.com>
Date:   Thu Feb 28 05:38:00 2013 +0000

    cpufreq: Fix a typo in comment
    
    Fix a typo in a comment in cpufreq_governor.h.
    
    [rjw: Changelog]
    Signed-off-by: Namhyung Kim <namhyung@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index d2ac91150600..46bde01eee62 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -64,7 +64,7 @@ static void *get_cpu_dbs_info_s(int cpu)				\
  * dbs: used as a shortform for demand based switching It helps to keep variable
  *	names smaller, simpler
  * cdbs: common dbs
- * on_*: On-demand governor
+ * od_*: On-demand governor
  * cs_*: Conservative governor
  */
 

commit 4bd4e42819c7b5b2d608b353f4d9a7717e586479
Author: Stratos Karafotis <stratosk@semaphore.gr>
Date:   Wed Feb 6 13:34:00 2013 +0100

    cpufreq: ondemand: Replace down_differential tuner with adj_up_threshold
    
    In order to avoid the calculation of up_threshold - down_differential
    every time that the frequency must be decreased, we replace the
    down_differential tuner with the adj_up_threshold which keeps the
    difference across multiple checks.
    
    Update the adj_up_threshold only when the up_theshold is also updated.
    
    Signed-off-by: Stratos Karafotis <stratosk@semaphore.gr>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 16314b65ca67..d2ac91150600 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -109,7 +109,7 @@ struct od_dbs_tuners {
 	unsigned int sampling_rate;
 	unsigned int sampling_down_factor;
 	unsigned int up_threshold;
-	unsigned int down_differential;
+	unsigned int adj_up_threshold;
 	unsigned int powersave_bias;
 	unsigned int io_is_busy;
 };

commit 4447266b842d27f77b017a59eb9dc38ad7b299f1
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jan 31 17:28:02 2013 +0000

    cpufreq: governors: Remove code redundancy between governors
    
    With the inclusion of following patches:
    
    9f4eb10 cpufreq: conservative: call dbs_check_cpu only when necessary
    772b4b1 cpufreq: ondemand: call dbs_check_cpu only when necessary
    
    code redundancy between the conservative and ondemand governors is
    introduced again, so get rid of it.
    
    [rjw: Changelog]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Fabio Baltieri <fabio.baltieri@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index c19a16c34361..16314b65ca67 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -171,6 +171,8 @@ static inline int delay_for_sampling_rate(unsigned int sampling_rate)
 
 u64 get_cpu_idle_time(unsigned int cpu, u64 *wall);
 void dbs_check_cpu(struct dbs_data *dbs_data, int cpu);
+bool need_load_eval(struct cpu_dbs_common_info *cdbs,
+		unsigned int sampling_rate);
 int cpufreq_governor_dbs(struct dbs_data *dbs_data,
 		struct cpufreq_policy *policy, unsigned int event);
 #endif /* _CPUFREQ_GOVERNER_H */

commit 8eeed0956615294200be783bb67d851280b5b1b9
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jan 31 17:28:01 2013 +0000

    cpufreq: governors: Get rid of dbs_data->enable field
    
    CPUFREQ_GOV_START/STOP are called only once for all policy->cpus and hence we
    don't need to adapt cpufreq_governor_dbs() routine for multiple calls.
    
    So, this patch removes dbs_data->enable field entirely. And rearrange code a
    bit.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Fabio Baltieri <fabio.baltieri@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index b72e628e7ed6..c19a16c34361 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -130,7 +130,6 @@ struct dbs_data {
 	#define GOV_CONSERVATIVE	1
 	int governor;
 	unsigned int min_sampling_rate;
-	unsigned int enable; /* number of CPUs using this policy */
 	struct attribute_group *attr_group;
 	void *tuners;
 

commit 2624f90c16413990ecb0414400174a066319a9f5
Author: Fabio Baltieri <fabio.baltieri@linaro.org>
Date:   Thu Jan 31 09:44:40 2013 +0000

    cpufreq: governors: implement generic policy_is_shared
    
    Implement a generic helper function policy_is_shared() to replace the
    current dbs_sw_coordinated_cpus() at cpufreq level, so that it can be
    used by code other than cpufreq governors.
    
    Suggested-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Fabio Baltieri <fabio.baltieri@linaro.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index aaf073daa9fb..b72e628e7ed6 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -172,7 +172,6 @@ static inline int delay_for_sampling_rate(unsigned int sampling_rate)
 
 u64 get_cpu_idle_time(unsigned int cpu, u64 *wall);
 void dbs_check_cpu(struct dbs_data *dbs_data, int cpu);
-bool dbs_sw_coordinated_cpus(struct cpu_dbs_common_info *cdbs);
 int cpufreq_governor_dbs(struct dbs_data *dbs_data,
 		struct cpufreq_policy *policy, unsigned int event);
 #endif /* _CPUFREQ_GOVERNER_H */

commit da53d61e21a5869b2e44247bb37deb8be387e063
Author: Fabio Baltieri <fabio.baltieri@linaro.org>
Date:   Thu Dec 27 14:55:40 2012 +0000

    cpufreq: ondemand: call dbs_check_cpu only when necessary
    
    Modify ondemand timer to not resample CPU utilization if recently
    sampled from another SW coordinated core.
    
    Signed-off-by: Fabio Baltieri <fabio.baltieri@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 5bf6fb8023ef..aaf073daa9fb 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -82,6 +82,7 @@ struct cpu_dbs_common_info {
 	 * the governor or limits.
 	 */
 	struct mutex timer_mutex;
+	ktime_t time_stamp;
 };
 
 struct od_cpu_dbs_info_s {

commit 2abfa876f1117b0ab45f191fb1f82c41b1cbc8fe
Author: Rickard Andersson <rickard.andersson@stericsson.com>
Date:   Thu Dec 27 14:55:38 2012 +0000

    cpufreq: handle SW coordinated CPUs
    
    This patch fixes a bug that occurred when we had load on a secondary CPU
    and the primary CPU was sleeping. Only one sampling timer was spawned
    and it was spawned as a deferred timer on the primary CPU, so when a
    secondary CPU had a change in load this was not detected by the cpufreq
    governor (both ondemand and conservative).
    
    This patch make sure that deferred timers are run on all CPUs in the
    case of software controlled CPUs that run on the same frequency.
    
    Signed-off-by: Rickard Andersson <rickard.andersson@stericsson.com>
    Signed-off-by: Fabio Baltieri <fabio.baltieri@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index f6616540c53d..5bf6fb8023ef 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -171,6 +171,7 @@ static inline int delay_for_sampling_rate(unsigned int sampling_rate)
 
 u64 get_cpu_idle_time(unsigned int cpu, u64 *wall);
 void dbs_check_cpu(struct dbs_data *dbs_data, int cpu);
+bool dbs_sw_coordinated_cpus(struct cpu_dbs_common_info *cdbs);
 int cpufreq_governor_dbs(struct dbs_data *dbs_data,
 		struct cpufreq_policy *policy, unsigned int event);
 #endif /* _CPUFREQ_GOVERNER_H */

commit 1e7586a18a2ab69a160837c0a4be31f7147cfb5e
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Oct 26 00:51:21 2012 +0200

    cpufreq: Fix sparse warnings by updating cputime64_t to u64
    
    There were few sparse warnings due to mismatch of type on function arguments.
    Two types were used u64 and cputime64_t. Both are actually u64, so use u64 only.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 34e14adfc3f9..f6616540c53d 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -17,7 +17,6 @@
 #ifndef _CPUFREQ_GOVERNER_H
 #define _CPUFREQ_GOVERNER_H
 
-#include <asm/cputime.h>
 #include <linux/cpufreq.h>
 #include <linux/kobject.h>
 #include <linux/mutex.h>
@@ -72,9 +71,9 @@ static void *get_cpu_dbs_info_s(int cpu)				\
 /* Per cpu structures */
 struct cpu_dbs_common_info {
 	int cpu;
-	cputime64_t prev_cpu_idle;
-	cputime64_t prev_cpu_wall;
-	cputime64_t prev_cpu_nice;
+	u64 prev_cpu_idle;
+	u64 prev_cpu_wall;
+	u64 prev_cpu_nice;
 	struct cpufreq_policy *cur_policy;
 	struct delayed_work work;
 	/*
@@ -87,7 +86,7 @@ struct cpu_dbs_common_info {
 
 struct od_cpu_dbs_info_s {
 	struct cpu_dbs_common_info cdbs;
-	cputime64_t prev_cpu_iowait;
+	u64 prev_cpu_iowait;
 	struct cpufreq_frequency_table *freq_table;
 	unsigned int freq_lo;
 	unsigned int freq_lo_jiffies;
@@ -170,7 +169,7 @@ static inline int delay_for_sampling_rate(unsigned int sampling_rate)
 	return delay;
 }
 
-cputime64_t get_cpu_idle_time(unsigned int cpu, cputime64_t *wall);
+u64 get_cpu_idle_time(unsigned int cpu, u64 *wall);
 void dbs_check_cpu(struct dbs_data *dbs_data, int cpu);
 int cpufreq_governor_dbs(struct dbs_data *dbs_data,
 		struct cpufreq_policy *policy, unsigned int event);

commit 4471a34f9a1f2da220272e823bdb8e8fa83a7661
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Oct 26 00:47:42 2012 +0200

    cpufreq: governors: remove redundant code
    
    Initially ondemand governor was written and then using its code conservative
    governor is written. It used a lot of code from ondemand governor, but copy of
    code was created instead of using the same routines from both governors. Which
    increased code redundancy, which is difficult to manage.
    
    This patch is an attempt to move common part of both the governors to
    cpufreq_governor.c file to come over above mentioned issues.
    
    This shouldn't change anything from functionality point of view.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
new file mode 100644
index 000000000000..34e14adfc3f9
--- /dev/null
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -0,0 +1,177 @@
+/*
+ * drivers/cpufreq/cpufreq_governor.h
+ *
+ * Header file for CPUFreq governors common code
+ *
+ * Copyright	(C) 2001 Russell King
+ *		(C) 2003 Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>.
+ *		(C) 2003 Jun Nakajima <jun.nakajima@intel.com>
+ *		(C) 2009 Alexander Clouter <alex@digriz.org.uk>
+ *		(c) 2012 Viresh Kumar <viresh.kumar@linaro.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _CPUFREQ_GOVERNER_H
+#define _CPUFREQ_GOVERNER_H
+
+#include <asm/cputime.h>
+#include <linux/cpufreq.h>
+#include <linux/kobject.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/sysfs.h>
+
+/*
+ * The polling frequency depends on the capability of the processor. Default
+ * polling frequency is 1000 times the transition latency of the processor. The
+ * governor will work on any processor with transition latency <= 10mS, using
+ * appropriate sampling rate.
+ *
+ * For CPUs with transition latency > 10mS (mostly drivers with CPUFREQ_ETERNAL)
+ * this governor will not work. All times here are in uS.
+ */
+#define MIN_SAMPLING_RATE_RATIO			(2)
+#define LATENCY_MULTIPLIER			(1000)
+#define MIN_LATENCY_MULTIPLIER			(100)
+#define TRANSITION_LATENCY_LIMIT		(10 * 1000 * 1000)
+
+/* Ondemand Sampling types */
+enum {OD_NORMAL_SAMPLE, OD_SUB_SAMPLE};
+
+/* Macro creating sysfs show routines */
+#define show_one(_gov, file_name, object)				\
+static ssize_t show_##file_name						\
+(struct kobject *kobj, struct attribute *attr, char *buf)		\
+{									\
+	return sprintf(buf, "%u\n", _gov##_tuners.object);		\
+}
+
+#define define_get_cpu_dbs_routines(_dbs_info)				\
+static struct cpu_dbs_common_info *get_cpu_cdbs(int cpu)		\
+{									\
+	return &per_cpu(_dbs_info, cpu).cdbs;				\
+}									\
+									\
+static void *get_cpu_dbs_info_s(int cpu)				\
+{									\
+	return &per_cpu(_dbs_info, cpu);				\
+}
+
+/*
+ * Abbreviations:
+ * dbs: used as a shortform for demand based switching It helps to keep variable
+ *	names smaller, simpler
+ * cdbs: common dbs
+ * on_*: On-demand governor
+ * cs_*: Conservative governor
+ */
+
+/* Per cpu structures */
+struct cpu_dbs_common_info {
+	int cpu;
+	cputime64_t prev_cpu_idle;
+	cputime64_t prev_cpu_wall;
+	cputime64_t prev_cpu_nice;
+	struct cpufreq_policy *cur_policy;
+	struct delayed_work work;
+	/*
+	 * percpu mutex that serializes governor limit change with gov_dbs_timer
+	 * invocation. We do not want gov_dbs_timer to run when user is changing
+	 * the governor or limits.
+	 */
+	struct mutex timer_mutex;
+};
+
+struct od_cpu_dbs_info_s {
+	struct cpu_dbs_common_info cdbs;
+	cputime64_t prev_cpu_iowait;
+	struct cpufreq_frequency_table *freq_table;
+	unsigned int freq_lo;
+	unsigned int freq_lo_jiffies;
+	unsigned int freq_hi_jiffies;
+	unsigned int rate_mult;
+	unsigned int sample_type:1;
+};
+
+struct cs_cpu_dbs_info_s {
+	struct cpu_dbs_common_info cdbs;
+	unsigned int down_skip;
+	unsigned int requested_freq;
+	unsigned int enable:1;
+};
+
+/* Governers sysfs tunables */
+struct od_dbs_tuners {
+	unsigned int ignore_nice;
+	unsigned int sampling_rate;
+	unsigned int sampling_down_factor;
+	unsigned int up_threshold;
+	unsigned int down_differential;
+	unsigned int powersave_bias;
+	unsigned int io_is_busy;
+};
+
+struct cs_dbs_tuners {
+	unsigned int ignore_nice;
+	unsigned int sampling_rate;
+	unsigned int sampling_down_factor;
+	unsigned int up_threshold;
+	unsigned int down_threshold;
+	unsigned int freq_step;
+};
+
+/* Per Governer data */
+struct dbs_data {
+	/* Common across governors */
+	#define GOV_ONDEMAND		0
+	#define GOV_CONSERVATIVE	1
+	int governor;
+	unsigned int min_sampling_rate;
+	unsigned int enable; /* number of CPUs using this policy */
+	struct attribute_group *attr_group;
+	void *tuners;
+
+	/* dbs_mutex protects dbs_enable in governor start/stop */
+	struct mutex mutex;
+
+	struct cpu_dbs_common_info *(*get_cpu_cdbs)(int cpu);
+	void *(*get_cpu_dbs_info_s)(int cpu);
+	void (*gov_dbs_timer)(struct work_struct *work);
+	void (*gov_check_cpu)(int cpu, unsigned int load);
+
+	/* Governor specific ops, see below */
+	void *gov_ops;
+};
+
+/* Governor specific ops, will be passed to dbs_data->gov_ops */
+struct od_ops {
+	int (*io_busy)(void);
+	void (*powersave_bias_init_cpu)(int cpu);
+	unsigned int (*powersave_bias_target)(struct cpufreq_policy *policy,
+			unsigned int freq_next, unsigned int relation);
+	void (*freq_increase)(struct cpufreq_policy *p, unsigned int freq);
+};
+
+struct cs_ops {
+	struct notifier_block *notifier_block;
+};
+
+static inline int delay_for_sampling_rate(unsigned int sampling_rate)
+{
+	int delay = usecs_to_jiffies(sampling_rate);
+
+	/* We want all CPUs to do sampling nearly on same jiffy */
+	if (num_online_cpus() > 1)
+		delay -= jiffies % delay;
+
+	return delay;
+}
+
+cputime64_t get_cpu_idle_time(unsigned int cpu, cputime64_t *wall);
+void dbs_check_cpu(struct dbs_data *dbs_data, int cpu);
+int cpufreq_governor_dbs(struct dbs_data *dbs_data,
+		struct cpufreq_policy *policy, unsigned int event);
+#endif /* _CPUFREQ_GOVERNER_H */
