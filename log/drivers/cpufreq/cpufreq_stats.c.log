commit 3c0897c180c6605ebbdfa1b4badc71e181fc4cdc
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Mar 11 08:13:41 2020 +0100

    cpufreq: Use scnprintf() for avoiding potential buffer overflow
    
    Since snprintf() returns the would-be-output size instead of the
    actual output size, the succeeding calls may go beyond the given
    buffer limit.  Fix it by replacing with scnprintf().
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index f9bcf0f3ea30..94d959a8e954 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -90,35 +90,35 @@ static ssize_t show_trans_table(struct cpufreq_policy *policy, char *buf)
 	if (policy->fast_switch_enabled)
 		return 0;
 
-	len += snprintf(buf + len, PAGE_SIZE - len, "   From  :    To\n");
-	len += snprintf(buf + len, PAGE_SIZE - len, "         : ");
+	len += scnprintf(buf + len, PAGE_SIZE - len, "   From  :    To\n");
+	len += scnprintf(buf + len, PAGE_SIZE - len, "         : ");
 	for (i = 0; i < stats->state_num; i++) {
 		if (len >= PAGE_SIZE)
 			break;
-		len += snprintf(buf + len, PAGE_SIZE - len, "%9u ",
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%9u ",
 				stats->freq_table[i]);
 	}
 	if (len >= PAGE_SIZE)
 		return PAGE_SIZE;
 
-	len += snprintf(buf + len, PAGE_SIZE - len, "\n");
+	len += scnprintf(buf + len, PAGE_SIZE - len, "\n");
 
 	for (i = 0; i < stats->state_num; i++) {
 		if (len >= PAGE_SIZE)
 			break;
 
-		len += snprintf(buf + len, PAGE_SIZE - len, "%9u: ",
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%9u: ",
 				stats->freq_table[i]);
 
 		for (j = 0; j < stats->state_num; j++) {
 			if (len >= PAGE_SIZE)
 				break;
-			len += snprintf(buf + len, PAGE_SIZE - len, "%9u ",
+			len += scnprintf(buf + len, PAGE_SIZE - len, "%9u ",
 					stats->trans_table[i*stats->max_state+j]);
 		}
 		if (len >= PAGE_SIZE)
 			break;
-		len += snprintf(buf + len, PAGE_SIZE - len, "\n");
+		len += scnprintf(buf + len, PAGE_SIZE - len, "\n");
 	}
 
 	if (len >= PAGE_SIZE) {

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 08b192eb22c6..f9bcf0f3ea30 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  drivers/cpufreq/cpufreq_stats.c
  *
  *  Copyright (C) 2003-2004 Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>.
  *  (C) 2004 Zou Nan hai <nanhai.zou@intel.com>.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/cpu.h>

commit fcccc5c838c1999785a5aeb9e3bdcd00957f3e15
Author: Kyle Lin <linkyle0915@gmail.com>
Date:   Tue Apr 9 16:43:04 2019 +0800

    cpufreq: stats: Use lock by stat to replace global spin lock
    
    Stats is updated by each policy, using the lock by stat can
    reduce the contention.
    
    Signed-off-by: Kyle Lin <linkyle0915@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index e2db5581489a..08b192eb22c6 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -14,7 +14,6 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 
-static DEFINE_SPINLOCK(cpufreq_stats_lock);
 
 struct cpufreq_stats {
 	unsigned int total_trans;
@@ -23,6 +22,7 @@ struct cpufreq_stats {
 	unsigned int state_num;
 	unsigned int last_index;
 	u64 *time_in_state;
+	spinlock_t lock;
 	unsigned int *freq_table;
 	unsigned int *trans_table;
 };
@@ -39,12 +39,12 @@ static void cpufreq_stats_clear_table(struct cpufreq_stats *stats)
 {
 	unsigned int count = stats->max_state;
 
-	spin_lock(&cpufreq_stats_lock);
+	spin_lock(&stats->lock);
 	memset(stats->time_in_state, 0, count * sizeof(u64));
 	memset(stats->trans_table, 0, count * count * sizeof(int));
 	stats->last_time = get_jiffies_64();
 	stats->total_trans = 0;
-	spin_unlock(&cpufreq_stats_lock);
+	spin_unlock(&stats->lock);
 }
 
 static ssize_t show_total_trans(struct cpufreq_policy *policy, char *buf)
@@ -62,9 +62,9 @@ static ssize_t show_time_in_state(struct cpufreq_policy *policy, char *buf)
 	if (policy->fast_switch_enabled)
 		return 0;
 
-	spin_lock(&cpufreq_stats_lock);
+	spin_lock(&stats->lock);
 	cpufreq_stats_update(stats);
-	spin_unlock(&cpufreq_stats_lock);
+	spin_unlock(&stats->lock);
 
 	for (i = 0; i < stats->state_num; i++) {
 		len += sprintf(buf + len, "%u %llu\n", stats->freq_table[i],
@@ -211,6 +211,7 @@ void cpufreq_stats_create_table(struct cpufreq_policy *policy)
 	stats->state_num = i;
 	stats->last_time = get_jiffies_64();
 	stats->last_index = freq_table_get_index(stats, policy->cur);
+	spin_lock_init(&stats->lock);
 
 	policy->stats = stats;
 	ret = sysfs_create_group(&policy->kobj, &stats_attr_group);
@@ -242,11 +243,11 @@ void cpufreq_stats_record_transition(struct cpufreq_policy *policy,
 	if (old_index == -1 || new_index == -1 || old_index == new_index)
 		return;
 
-	spin_lock(&cpufreq_stats_lock);
+	spin_lock(&stats->lock);
 	cpufreq_stats_update(stats);
 
 	stats->last_index = new_index;
 	stats->trans_table[old_index * stats->max_state + new_index]++;
 	stats->total_trans++;
-	spin_unlock(&cpufreq_stats_lock);
+	spin_unlock(&stats->lock);
 }

commit 9795607dc41e7606e90e48bffe6927bee32cd336
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 1 11:45:45 2019 +0530

    cpufreq: stats: Fix concurrency issues while resetting stats
    
    It is possible for cpufreq_stats_clear_table() and
    cpufreq_stats_record_transition() to get called concurrently and they
    will try to update same variables simultaneously and may lead to
    corruption of data.
    
    Prevent that with the help of existing spinlock.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 941e63e3e652..e2db5581489a 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -31,20 +31,20 @@ static void cpufreq_stats_update(struct cpufreq_stats *stats)
 {
 	unsigned long long cur_time = get_jiffies_64();
 
-	spin_lock(&cpufreq_stats_lock);
 	stats->time_in_state[stats->last_index] += cur_time - stats->last_time;
 	stats->last_time = cur_time;
-	spin_unlock(&cpufreq_stats_lock);
 }
 
 static void cpufreq_stats_clear_table(struct cpufreq_stats *stats)
 {
 	unsigned int count = stats->max_state;
 
+	spin_lock(&cpufreq_stats_lock);
 	memset(stats->time_in_state, 0, count * sizeof(u64));
 	memset(stats->trans_table, 0, count * count * sizeof(int));
 	stats->last_time = get_jiffies_64();
 	stats->total_trans = 0;
+	spin_unlock(&cpufreq_stats_lock);
 }
 
 static ssize_t show_total_trans(struct cpufreq_policy *policy, char *buf)
@@ -62,7 +62,10 @@ static ssize_t show_time_in_state(struct cpufreq_policy *policy, char *buf)
 	if (policy->fast_switch_enabled)
 		return 0;
 
+	spin_lock(&cpufreq_stats_lock);
 	cpufreq_stats_update(stats);
+	spin_unlock(&cpufreq_stats_lock);
+
 	for (i = 0; i < stats->state_num; i++) {
 		len += sprintf(buf + len, "%u %llu\n", stats->freq_table[i],
 			(unsigned long long)
@@ -239,9 +242,11 @@ void cpufreq_stats_record_transition(struct cpufreq_policy *policy,
 	if (old_index == -1 || new_index == -1 || old_index == new_index)
 		return;
 
+	spin_lock(&cpufreq_stats_lock);
 	cpufreq_stats_update(stats);
 
 	stats->last_index = new_index;
 	stats->trans_table[old_index * stats->max_state + new_index]++;
 	stats->total_trans++;
+	spin_unlock(&cpufreq_stats_lock);
 }

commit 10b818211d04805da731087e596fc7c6ce199dea
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 1 11:45:44 2019 +0530

    cpufreq: stats: Declare freq-attr right after their callbacks
    
    Freq attribute for "trans_table" is defined right after its callback
    (without any blank line between them), but the others are defined
    separately later on. Keep this consistent and define all attributes
    right after their callbacks.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 1572129844a5..941e63e3e652 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -51,6 +51,7 @@ static ssize_t show_total_trans(struct cpufreq_policy *policy, char *buf)
 {
 	return sprintf(buf, "%d\n", policy->stats->total_trans);
 }
+cpufreq_freq_attr_ro(total_trans);
 
 static ssize_t show_time_in_state(struct cpufreq_policy *policy, char *buf)
 {
@@ -69,6 +70,7 @@ static ssize_t show_time_in_state(struct cpufreq_policy *policy, char *buf)
 	}
 	return len;
 }
+cpufreq_freq_attr_ro(time_in_state);
 
 static ssize_t store_reset(struct cpufreq_policy *policy, const char *buf,
 			   size_t count)
@@ -77,6 +79,7 @@ static ssize_t store_reset(struct cpufreq_policy *policy, const char *buf,
 	cpufreq_stats_clear_table(policy->stats);
 	return count;
 }
+cpufreq_freq_attr_wo(reset);
 
 static ssize_t show_trans_table(struct cpufreq_policy *policy, char *buf)
 {
@@ -126,10 +129,6 @@ static ssize_t show_trans_table(struct cpufreq_policy *policy, char *buf)
 }
 cpufreq_freq_attr_ro(trans_table);
 
-cpufreq_freq_attr_ro(total_trans);
-cpufreq_freq_attr_ro(time_in_state);
-cpufreq_freq_attr_wo(reset);
-
 static struct attribute *default_attrs[] = {
 	&total_trans.attr,
 	&time_in_state.attr,

commit d476ec4f7f5aba47b0a570cbf659d7330d7e71cf
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jan 4 08:53:54 2018 +0530

    cpufreq: stats: Change return type of cpufreq_stats_update() as void
    
    It always returns 0 and none of its callers check its return value. Make
    it return void.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 1e55b5790853..1572129844a5 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -27,7 +27,7 @@ struct cpufreq_stats {
 	unsigned int *trans_table;
 };
 
-static int cpufreq_stats_update(struct cpufreq_stats *stats)
+static void cpufreq_stats_update(struct cpufreq_stats *stats)
 {
 	unsigned long long cur_time = get_jiffies_64();
 
@@ -35,7 +35,6 @@ static int cpufreq_stats_update(struct cpufreq_stats *stats)
 	stats->time_in_state[stats->last_index] += cur_time - stats->last_time;
 	stats->last_time = cur_time;
 	spin_unlock(&cpufreq_stats_lock);
-	return 0;
 }
 
 static void cpufreq_stats_clear_table(struct cpufreq_stats *stats)

commit f7bc9b209e27c0b617378400136cc663a6314d0c
Author: Gautham R. Shenoy <ego@linux.vnet.ibm.com>
Date:   Tue Nov 7 13:39:29 2017 +0530

    cpufreq: stats: Handle the case when trans_table goes beyond PAGE_SIZE
    
    On platforms with large number of Pstates, the transition table, which
    is a NxN matrix, can overflow beyond the PAGE_SIZE boundary.
    
    This can be seen on POWER9 which has 100+ Pstates.
    
    As a result, each time the trans_table is read for any of the CPUs, we
    will get the following error.
    
    ---------------------------------------------------
    fill_read_buffer: show+0x0/0xa0 returned bad count
    ---------------------------------------------------
    
    This patch ensures that in case of an overflow, we print a warning
    once in the dmesg and return FILE TOO LARGE error for this and all
    subsequent accesses of trans_table.
    
    Signed-off-by: Gautham R. Shenoy <ego@linux.vnet.ibm.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index e75880eb037d..1e55b5790853 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -118,8 +118,11 @@ static ssize_t show_trans_table(struct cpufreq_policy *policy, char *buf)
 			break;
 		len += snprintf(buf + len, PAGE_SIZE - len, "\n");
 	}
-	if (len >= PAGE_SIZE)
-		return PAGE_SIZE;
+
+	if (len >= PAGE_SIZE) {
+		pr_warn_once("cpufreq transition table exceeds PAGE_SIZE. Disabling\n");
+		return -EFBIG;
+	}
 	return len;
 }
 cpufreq_freq_attr_ro(trans_table);

commit 4d25ec19669292a65a32498eabdabdd32b1a8747
Merge: 907afe5923b4 5d72ed35678a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 14 13:12:32 2017 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux
    
    Pull thermal management updates from Zhang Rui:
    
     - Improve thermal cpu_cooling interaction with cpufreq core.
    
       The cpu_cooling driver is designed to use CPU frequency scaling to
       avoid high thermal states for a platform. But it wasn't glued really
       well with cpufreq core.
    
       For example clipped-cpus is copied from the policy structure and its
       much better to use the policy->cpus (or related_cpus) fields directly
       as they may have got updated. Not that things were broken before this
       series, but they can be optimized a bit more.
    
       This series tries to improve interactions between cpufreq core and
       cpu_cooling driver and does some fixes/cleanups to the cpu_cooling
       driver. (Viresh Kumar)
    
     - A couple of fixes and cleanups in thermal core and imx, hisilicon,
       bcm_2835, int340x thermal drivers. (Arvind Yadav, Dan Carpenter,
       Sumeet Pawnikar, Srinivas Pandruvada, Willy WOLFF)
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/rzhang/linux: (24 commits)
      thermal: bcm2835: fix an error code in probe()
      thermal: hisilicon: Handle return value of clk_prepare_enable
      thermal: imx: Handle return value of clk_prepare_enable
      thermal: int340x: check for sensor when PTYP is missing
      Thermal/int340x: Fix few typos and kernel-doc style
      thermal: fix source code documentation for parameters
      thermal: cpu_cooling: Replace kmalloc with kmalloc_array
      thermal: cpu_cooling: Rearrange struct cpufreq_cooling_device
      thermal: cpu_cooling: 'freq' can't be zero in cpufreq_state2power()
      thermal: cpu_cooling: don't store cpu_dev in cpufreq_cdev
      thermal: cpu_cooling: get_level() can't fail
      thermal: cpu_cooling: create structure for idle time stats
      thermal: cpu_cooling: merge frequency and power tables
      thermal: cpu_cooling: get rid of 'allowed_cpus'
      thermal: cpu_cooling: OPPs are registered for all CPUs
      thermal: cpu_cooling: store cpufreq policy
      cpufreq: create cpufreq_table_count_valid_entries()
      thermal: cpu_cooling: use cpufreq_policy to register cooling device
      thermal: cpu_cooling: get rid of a variable in cpufreq_set_cur_state()
      thermal: cpu_cooling: remove cpufreq_cooling_get_level()
      ...

commit 402202e8deac760aec1b54d96183f37047a51a45
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Mon Jul 3 13:29:04 2017 +0530

    cpufreq: cpufreq_stats: constify attribute_group structures
    
    attribute_groups are not supposed to change at runtime. All functions
    working with attribute_groups provided by <linux/sysfs.h> work with const
    attribute_group. So mark the non-const structs as const.
    
    File size before:
       text    data     bss     dec     hex filename
       1655     256       4    1915     77b drivers/cpufreq/cpufreq_stats.o
    
    File size After adding 'const':
       text    data     bss     dec     hex filename
       1695     192       4    1891     763 drivers/cpufreq/cpufreq_stats.o
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index f570ead62454..d362739a71f3 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -135,7 +135,7 @@ static struct attribute *default_attrs[] = {
 	&trans_table.attr,
 	NULL
 };
-static struct attribute_group stats_attr_group = {
+static const struct attribute_group stats_attr_group = {
 	.attrs = default_attrs,
 	.name = "stats"
 };

commit 55d852931319d2e3ccde86cd426405231ce6c6ac
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Apr 25 15:57:15 2017 +0530

    cpufreq: create cpufreq_table_count_valid_entries()
    
    We need such a routine at two places already, lets create one.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Lukasz Luba <lukasz.luba@arm.com>
    Tested-by: Lukasz Luba <lukasz.luba@arm.com>
    Signed-off-by: Eduardo Valentin <edubezval@gmail.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index f570ead62454..9c3d319dc129 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -170,11 +170,10 @@ void cpufreq_stats_create_table(struct cpufreq_policy *policy)
 	unsigned int i = 0, count = 0, ret = -ENOMEM;
 	struct cpufreq_stats *stats;
 	unsigned int alloc_size;
-	struct cpufreq_frequency_table *pos, *table;
+	struct cpufreq_frequency_table *pos;
 
-	/* We need cpufreq table for creating stats table */
-	table = policy->freq_table;
-	if (unlikely(!table))
+	count = cpufreq_table_count_valid_entries(policy);
+	if (!count)
 		return;
 
 	/* stats already initialized */
@@ -185,10 +184,6 @@ void cpufreq_stats_create_table(struct cpufreq_policy *policy)
 	if (!stats)
 		return;
 
-	/* Find total allocation size */
-	cpufreq_for_each_valid_entry(pos, table)
-		count++;
-
 	alloc_size = count * sizeof(int) + count * sizeof(u64);
 
 	alloc_size += count * count * sizeof(int);
@@ -205,7 +200,7 @@ void cpufreq_stats_create_table(struct cpufreq_policy *policy)
 	stats->max_state = count;
 
 	/* Find valid-unique entries */
-	cpufreq_for_each_valid_entry(pos, table)
+	cpufreq_for_each_valid_entry(pos, policy->freq_table)
 		if (freq_table_get_index(stats, pos->frequency) == -1)
 			stats->freq_table[i++] = pos->frequency;
 

commit 02c3de1105228e367320e7fdeffbf511904f398c
Merge: 7aa7d608112b eee77a8a0d26
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Feb 20 17:41:31 2017 -0800

    Merge tag 'pm-4.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael Wysocki:
     "The majority of changes go into the Operating Performance Points (OPP)
      framework and cpufreq this time, followed by devfreq and some
      scattered updates all over.
    
      The OPP changes are mostly related to switching over from RCU-based
      synchronization, that turned out to be overly complicated and
      problematic, to reference counting using krefs.
    
      In the cpufreq land there are core cleanups, documentation updates, a
      new driver for Broadcom BMIPS SoCs, a new cpufreq-dt sub-driver for TI
      SoCs that require special handling, ARM64 SoCs support for the qoriq
      driver, intel_pstate updates, powernv driver update and assorted
      fixes.
    
      The devfreq changes are mostly fixes related to the sysfs interface
      and some Exynos drivers updates.
    
      Apart from that, the cpuidle menu governor will support per-CPU PM QoS
      constraints for the wakeup latency now, some bugs in the wakeup IRQs
      framework are fixed, the generic power domains framework should handle
      asynchronous invocations of *noirq suspend/resume callbacks from now
      on, the analyze_suspend.py script is updated and there is a new tool
      for intel_pstate diagnostics.
    
      Specifics:
    
       - Operating Performance Points (OPP) framework fixes, cleanups and
         switch over from RCU-based synchronization to reference counting
         using krefs (Viresh Kumar, Wei Yongjun, Dave Gerlach)
    
       - cpufreq core cleanups and documentation updates (Viresh Kumar,
         Rafael Wysocki)
    
       - New cpufreq driver for Broadcom BMIPS SoCs (Markus Mayer)
    
       - New cpufreq-dt sub-driver for TI SoCs requiring special handling,
         like in the AM335x, AM437x, DRA7x, and AM57x families, along with
         new DT bindings for it (Dave Gerlach, Paul Gortmaker)
    
       - ARM64 SoCs support for the qoriq cpufreq driver (Tang Yuantian)
    
       - intel_pstate driver updates including a new sysfs knob to control
         the driver's operation mode and fixes related to the no_turbo sysfs
         knob and the hardware-managed P-states feature support (Rafael
         Wysocki, Srinivas Pandruvada)
    
       - New interface to export ultra-turbo frequencies for the powernv
         cpufreq driver (Shilpasri Bhat)
    
       - Assorted fixes for cpufreq drivers (Arnd Bergmann, Dan Carpenter,
         Wei Yongjun)
    
       - devfreq core fixes, mostly related to the sysfs interface exported
         by it (Chanwoo Choi, Chris Diamand)
    
       - Updates of the exynos-bus and exynos-ppmu devfreq drivers (Chanwoo
         Choi)
    
       - Device PM QoS extension to support CPUs and support for per-CPU
         wakeup (device resume) latency constraints in the cpuidle menu
         governor (Alex Shi)
    
       - Wakeup IRQs framework fixes (Grygorii Strashko)
    
       - Generic power domains framework update including a fix to make it
         handle asynchronous invocations of *noirq suspend/resume callbacks
         correctly (Ulf Hansson, Geert Uytterhoeven)
    
       - Assorted fixes and cleanups in the core suspend/hibernate code, PM
         QoS framework and x86 ACPI idle support code (Corentin Labbe, Geert
         Uytterhoeven, Geliang Tang, John Keeping, Nick Desaulniers)
    
       - Update of the analyze_suspend.py script is updated to version 4.5
         offering multiple improvements (Todd Brandt)
    
       - New tool for intel_pstate diagnostics using the pstate_sample
         tracepoint (Doug Smythies)"
    
    * tag 'pm-4.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (85 commits)
      MAINTAINERS: cpufreq: add bmips-cpufreq.c
      PM / QoS: Fix memory leak on resume_latency.notifiers
      PM / Documentation: Spelling s/wrtie/write/
      PM / sleep: Fix test_suspend after sleep state rework
      cpufreq: CPPC: add ACPI_PROCESSOR dependency
      cpufreq: make ti-cpufreq explicitly non-modular
      cpufreq: Do not clear real_cpus mask on policy init
      tools/power/x86: Debug utility for intel_pstate driver
      AnalyzeSuspend: fix drag and zoom bug in javascript
      PM / wakeirq: report a wakeup_event on dedicated wekup irq
      PM / wakeirq: Fix spurious wake-up events for dedicated wakeirqs
      PM / wakeirq: Enable dedicated wakeirq for suspend
      cpufreq: dt: Don't use generic platdev driver for ti-cpufreq platforms
      cpufreq: ti: Add cpufreq driver to determine available OPPs at runtime
      Documentation: dt: add bindings for ti-cpufreq
      PM / OPP: Expose _of_get_opp_desc_node as dev_pm_opp API
      cpufreq: qoriq: Don't look at clock implementation details
      cpufreq: qoriq: add ARM64 SoCs support
      PM / Domains: Provide dummy governors if CONFIG_PM_GENERIC_DOMAINS=n
      cpufreq: brcmstb-avs-cpufreq: remove unnecessary platform_set_drvdata()
      ...

commit 801e0f378fe7d53f87246037bf40567277275418
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jan 5 13:57:41 2017 +0530

    cpufreq: Remove CONFIG_CPU_FREQ_STAT_DETAILS config option
    
    This doesn't have any benefit apart from saving a small amount of memory
    when it is disabled. The ifdef hackery in the code makes it dirty
    unnecessarily.
    
    Clean it up by removing the Kconfig option completely. Few defconfigs
    are also updated and CONFIG_CPU_FREQ_STAT_DETAILS is replaced with
    CONFIG_CPU_FREQ_STAT now in them, as users wanted stats to be enabled.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
    Reviewed-by: Chanwoo Choi <cw00.choi@samsung.com>
    Acked-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index ac284e66839c..18abd454da43 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -25,9 +25,7 @@ struct cpufreq_stats {
 	unsigned int last_index;
 	u64 *time_in_state;
 	unsigned int *freq_table;
-#ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 	unsigned int *trans_table;
-#endif
 };
 
 static int cpufreq_stats_update(struct cpufreq_stats *stats)
@@ -46,9 +44,7 @@ static void cpufreq_stats_clear_table(struct cpufreq_stats *stats)
 	unsigned int count = stats->max_state;
 
 	memset(stats->time_in_state, 0, count * sizeof(u64));
-#ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 	memset(stats->trans_table, 0, count * count * sizeof(int));
-#endif
 	stats->last_time = get_jiffies_64();
 	stats->total_trans = 0;
 }
@@ -84,7 +80,6 @@ static ssize_t store_reset(struct cpufreq_policy *policy, const char *buf,
 	return count;
 }
 
-#ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 static ssize_t show_trans_table(struct cpufreq_policy *policy, char *buf)
 {
 	struct cpufreq_stats *stats = policy->stats;
@@ -129,7 +124,6 @@ static ssize_t show_trans_table(struct cpufreq_policy *policy, char *buf)
 	return len;
 }
 cpufreq_freq_attr_ro(trans_table);
-#endif
 
 cpufreq_freq_attr_ro(total_trans);
 cpufreq_freq_attr_ro(time_in_state);
@@ -139,9 +133,7 @@ static struct attribute *default_attrs[] = {
 	&total_trans.attr,
 	&time_in_state.attr,
 	&reset.attr,
-#ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 	&trans_table.attr,
-#endif
 	NULL
 };
 static struct attribute_group stats_attr_group = {
@@ -200,9 +192,7 @@ void cpufreq_stats_create_table(struct cpufreq_policy *policy)
 
 	alloc_size = count * sizeof(int) + count * sizeof(u64);
 
-#ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 	alloc_size += count * count * sizeof(int);
-#endif
 
 	/* Allocate memory for time_in_state/freq_table/trans_table in one go */
 	stats->time_in_state = kzalloc(alloc_size, GFP_KERNEL);
@@ -211,9 +201,7 @@ void cpufreq_stats_create_table(struct cpufreq_policy *policy)
 
 	stats->freq_table = (unsigned int *)(stats->time_in_state + count);
 
-#ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 	stats->trans_table = stats->freq_table + count;
-#endif
 
 	stats->max_state = count;
 
@@ -259,8 +247,6 @@ void cpufreq_stats_record_transition(struct cpufreq_policy *policy,
 	cpufreq_stats_update(stats);
 
 	stats->last_index = new_index;
-#ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 	stats->trans_table[old_index * stats->max_state + new_index]++;
-#endif
 	stats->total_trans++;
 }

commit 7fb1327ee9b92fca27662f9b9d60c7c3376d6c69
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Tue Jan 31 04:09:19 2017 +0100

    sched/cputime: Convert kcpustat to nsecs
    
    Kernel CPU stats are stored in cputime_t which is an architecture
    defined type, and hence a bit opaque and requiring accessors and mutators
    for any operation.
    
    Converting them to nsecs simplifies the code and is one step toward
    the removal of cputime_t in the core code.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Stanislaw Gruszka <sgruszka@redhat.com>
    Cc: Wanpeng Li <wanpeng.li@hotmail.com>
    Link: http://lkml.kernel.org/r/1485832191-26889-4-git-send-email-fweisbec@gmail.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index ac284e66839c..17048bbec287 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -13,7 +13,6 @@
 #include <linux/cpufreq.h>
 #include <linux/module.h>
 #include <linux/slab.h>
-#include <linux/cputime.h>
 
 static DEFINE_SPINLOCK(cpufreq_stats_lock);
 

commit ee7930ee27fe5240398cc302fa8eb4454725f188
Author: Markus Mayer <mmayer@broadcom.com>
Date:   Mon Nov 7 10:02:23 2016 -0800

    cpufreq: stats: New sysfs attribute for clearing statistics
    
    Allow CPUfreq statistics to be cleared by writing anything to
    /sys/.../cpufreq/stats/reset.
    
    Signed-off-by: Markus Mayer <mmayer@broadcom.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 06d3abdffd3a..ac284e66839c 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -41,6 +41,18 @@ static int cpufreq_stats_update(struct cpufreq_stats *stats)
 	return 0;
 }
 
+static void cpufreq_stats_clear_table(struct cpufreq_stats *stats)
+{
+	unsigned int count = stats->max_state;
+
+	memset(stats->time_in_state, 0, count * sizeof(u64));
+#ifdef CONFIG_CPU_FREQ_STAT_DETAILS
+	memset(stats->trans_table, 0, count * count * sizeof(int));
+#endif
+	stats->last_time = get_jiffies_64();
+	stats->total_trans = 0;
+}
+
 static ssize_t show_total_trans(struct cpufreq_policy *policy, char *buf)
 {
 	return sprintf(buf, "%d\n", policy->stats->total_trans);
@@ -64,6 +76,14 @@ static ssize_t show_time_in_state(struct cpufreq_policy *policy, char *buf)
 	return len;
 }
 
+static ssize_t store_reset(struct cpufreq_policy *policy, const char *buf,
+			   size_t count)
+{
+	/* We don't care what is written to the attribute. */
+	cpufreq_stats_clear_table(policy->stats);
+	return count;
+}
+
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 static ssize_t show_trans_table(struct cpufreq_policy *policy, char *buf)
 {
@@ -113,10 +133,12 @@ cpufreq_freq_attr_ro(trans_table);
 
 cpufreq_freq_attr_ro(total_trans);
 cpufreq_freq_attr_ro(time_in_state);
+cpufreq_freq_attr_wo(reset);
 
 static struct attribute *default_attrs[] = {
 	&total_trans.attr,
 	&time_in_state.attr,
+	&reset.attr,
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 	&trans_table.attr,
 #endif

commit f8bfc116cacbdf7e0e655d8a798a242087ed70a5
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 3 10:58:47 2016 +0530

    cpufreq: Remove cpufreq_frequency_get_table()
    
    Most of the callers of cpufreq_frequency_get_table() already have the
    pointer to a valid 'policy' structure and they don't really need to go
    through the per-cpu variable first and then a check to validate the
    frequency, in order to find the freq-table for the policy.
    
    Directly use the policy->freq_table field instead for them.
    
    Only one user of that API is left after above changes, cpu_cooling.c and
    it accesses the freq_table in a racy way as the policy can get freed in
    between.
    
    Fix it by using cpufreq_cpu_get() properly.
    
    Since there are no more users of cpufreq_frequency_get_table() left, get
    rid of it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Javi Merino <javi.merino@arm.com> (cpu_cooling.c)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index c6e7f81a0397..06d3abdffd3a 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -157,11 +157,10 @@ void cpufreq_stats_create_table(struct cpufreq_policy *policy)
 	unsigned int i = 0, count = 0, ret = -ENOMEM;
 	struct cpufreq_stats *stats;
 	unsigned int alloc_size;
-	unsigned int cpu = policy->cpu;
 	struct cpufreq_frequency_table *pos, *table;
 
 	/* We need cpufreq table for creating stats table */
-	table = cpufreq_frequency_get_table(cpu);
+	table = policy->freq_table;
 	if (unlikely(!table))
 		return;
 

commit 1aefc75b2449eb68a6fc3ca932e2a4ee353b748d
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Tue May 31 22:14:44 2016 +0200

    cpufreq: stats: Make the stats code non-modular
    
    The modularity of cpufreq_stats is quite problematic.
    
    First off, the usage of policy notifiers for the initialization
    and cleanup in the cpufreq_stats module is inherently racy with
    respect to CPU offline/online and the initialization and cleanup
    of the cpufreq driver.
    
    Second, fast frequency switching (used by the schedutil governor)
    cannot be enabled if any transition notifiers are registered, so
    if the cpufreq_stats module (that registers a transition notifier
    for updating transition statistics) is loaded, the schedutil governor
    cannot use fast frequency switching.
    
    On the other hand, allowing cpufreq_stats to be built as a module
    doesn't really add much value.  Arguably, there's not much reason
    for that code to be modular at all.
    
    For the above reasons, make the cpufreq stats code non-modular,
    modify the core to invoke functions provided by that code directly
    and drop the notifiers from it.
    
    Make the stats sysfs attributes appear empty if fast frequency
    switching is enabled as the statistics will not be updated in that
    case anyway (and returning -EBUSY from those attributes breaks
    powertop).
    
    While at it, clean up Kconfig help for the CPU_FREQ_STAT and
    CPU_FREQ_STAT_DETAILS options.
    
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 5e370a30a964..c6e7f81a0397 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -15,7 +15,7 @@
 #include <linux/slab.h>
 #include <linux/cputime.h>
 
-static spinlock_t cpufreq_stats_lock;
+static DEFINE_SPINLOCK(cpufreq_stats_lock);
 
 struct cpufreq_stats {
 	unsigned int total_trans;
@@ -52,6 +52,9 @@ static ssize_t show_time_in_state(struct cpufreq_policy *policy, char *buf)
 	ssize_t len = 0;
 	int i;
 
+	if (policy->fast_switch_enabled)
+		return 0;
+
 	cpufreq_stats_update(stats);
 	for (i = 0; i < stats->state_num; i++) {
 		len += sprintf(buf + len, "%u %llu\n", stats->freq_table[i],
@@ -68,6 +71,9 @@ static ssize_t show_trans_table(struct cpufreq_policy *policy, char *buf)
 	ssize_t len = 0;
 	int i, j;
 
+	if (policy->fast_switch_enabled)
+		return 0;
+
 	len += snprintf(buf + len, PAGE_SIZE - len, "   From  :    To\n");
 	len += snprintf(buf + len, PAGE_SIZE - len, "         : ");
 	for (i = 0; i < stats->state_num; i++) {
@@ -130,7 +136,7 @@ static int freq_table_get_index(struct cpufreq_stats *stats, unsigned int freq)
 	return -1;
 }
 
-static void __cpufreq_stats_free_table(struct cpufreq_policy *policy)
+void cpufreq_stats_free_table(struct cpufreq_policy *policy)
 {
 	struct cpufreq_stats *stats = policy->stats;
 
@@ -146,20 +152,7 @@ static void __cpufreq_stats_free_table(struct cpufreq_policy *policy)
 	policy->stats = NULL;
 }
 
-static void cpufreq_stats_free_table(unsigned int cpu)
-{
-	struct cpufreq_policy *policy;
-
-	policy = cpufreq_cpu_get(cpu);
-	if (!policy)
-		return;
-
-	__cpufreq_stats_free_table(policy);
-
-	cpufreq_cpu_put(policy);
-}
-
-static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
+void cpufreq_stats_create_table(struct cpufreq_policy *policy)
 {
 	unsigned int i = 0, count = 0, ret = -ENOMEM;
 	struct cpufreq_stats *stats;
@@ -170,15 +163,15 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
 	/* We need cpufreq table for creating stats table */
 	table = cpufreq_frequency_get_table(cpu);
 	if (unlikely(!table))
-		return 0;
+		return;
 
 	/* stats already initialized */
 	if (policy->stats)
-		return -EEXIST;
+		return;
 
 	stats = kzalloc(sizeof(*stats), GFP_KERNEL);
 	if (!stats)
-		return -ENOMEM;
+		return;
 
 	/* Find total allocation size */
 	cpufreq_for_each_valid_entry(pos, table)
@@ -215,80 +208,32 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
 	policy->stats = stats;
 	ret = sysfs_create_group(&policy->kobj, &stats_attr_group);
 	if (!ret)
-		return 0;
+		return;
 
 	/* We failed, release resources */
 	policy->stats = NULL;
 	kfree(stats->time_in_state);
 free_stat:
 	kfree(stats);
-
-	return ret;
-}
-
-static void cpufreq_stats_create_table(unsigned int cpu)
-{
-	struct cpufreq_policy *policy;
-
-	/*
-	 * "likely(!policy)" because normally cpufreq_stats will be registered
-	 * before cpufreq driver
-	 */
-	policy = cpufreq_cpu_get(cpu);
-	if (likely(!policy))
-		return;
-
-	__cpufreq_stats_create_table(policy);
-
-	cpufreq_cpu_put(policy);
 }
 
-static int cpufreq_stat_notifier_policy(struct notifier_block *nb,
-		unsigned long val, void *data)
+void cpufreq_stats_record_transition(struct cpufreq_policy *policy,
+				     unsigned int new_freq)
 {
-	int ret = 0;
-	struct cpufreq_policy *policy = data;
-
-	if (val == CPUFREQ_CREATE_POLICY)
-		ret = __cpufreq_stats_create_table(policy);
-	else if (val == CPUFREQ_REMOVE_POLICY)
-		__cpufreq_stats_free_table(policy);
-
-	return ret;
-}
-
-static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
-		unsigned long val, void *data)
-{
-	struct cpufreq_freqs *freq = data;
-	struct cpufreq_policy *policy = cpufreq_cpu_get(freq->cpu);
-	struct cpufreq_stats *stats;
+	struct cpufreq_stats *stats = policy->stats;
 	int old_index, new_index;
 
-	if (!policy) {
-		pr_err("%s: No policy found\n", __func__);
-		return 0;
-	}
-
-	if (val != CPUFREQ_POSTCHANGE)
-		goto put_policy;
-
-	if (!policy->stats) {
+	if (!stats) {
 		pr_debug("%s: No stats found\n", __func__);
-		goto put_policy;
+		return;
 	}
 
-	stats = policy->stats;
-
 	old_index = stats->last_index;
-	new_index = freq_table_get_index(stats, freq->new);
+	new_index = freq_table_get_index(stats, new_freq);
 
 	/* We can't do stats->time_in_state[-1]= .. */
-	if (old_index == -1 || new_index == -1)
-		goto put_policy;
-
-	if (old_index == new_index)
-		goto put_policy;
+	if (old_index == -1 || new_index == -1 || old_index == new_index)
+		return;
 
 	cpufreq_stats_update(stats);
 
@@ -297,61 +242,4 @@ static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
 	stats->trans_table[old_index * stats->max_state + new_index]++;
 #endif
 	stats->total_trans++;
-
-put_policy:
-	cpufreq_cpu_put(policy);
-	return 0;
 }
-
-static struct notifier_block notifier_policy_block = {
-	.notifier_call = cpufreq_stat_notifier_policy
-};
-
-static struct notifier_block notifier_trans_block = {
-	.notifier_call = cpufreq_stat_notifier_trans
-};
-
-static int __init cpufreq_stats_init(void)
-{
-	int ret;
-	unsigned int cpu;
-
-	spin_lock_init(&cpufreq_stats_lock);
-	ret = cpufreq_register_notifier(&notifier_policy_block,
-				CPUFREQ_POLICY_NOTIFIER);
-	if (ret)
-		return ret;
-
-	for_each_online_cpu(cpu)
-		cpufreq_stats_create_table(cpu);
-
-	ret = cpufreq_register_notifier(&notifier_trans_block,
-				CPUFREQ_TRANSITION_NOTIFIER);
-	if (ret) {
-		cpufreq_unregister_notifier(&notifier_policy_block,
-				CPUFREQ_POLICY_NOTIFIER);
-		for_each_online_cpu(cpu)
-			cpufreq_stats_free_table(cpu);
-		return ret;
-	}
-
-	return 0;
-}
-static void __exit cpufreq_stats_exit(void)
-{
-	unsigned int cpu;
-
-	cpufreq_unregister_notifier(&notifier_policy_block,
-			CPUFREQ_POLICY_NOTIFIER);
-	cpufreq_unregister_notifier(&notifier_trans_block,
-			CPUFREQ_TRANSITION_NOTIFIER);
-	for_each_online_cpu(cpu)
-		cpufreq_stats_free_table(cpu);
-}
-
-MODULE_AUTHOR("Zou Nan hai <nanhai.zou@intel.com>");
-MODULE_DESCRIPTION("Export cpufreq stats via sysfs");
-MODULE_LICENSE("GPL");
-
-module_init(cpufreq_stats_init);
-module_exit(cpufreq_stats_exit);

commit 490285c65e2398a533035dd9d75cb606a61ea39a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 6 21:09:15 2015 +0530

    cpufreq: stats: drop unnecessary locking
    
    There is no possibility of any race on updating last_index, trans_table or
    total_trans as these are updated only by cpufreq_stat_notifier_trans() which
    will be called sequentially.
    
    The only place where locking is still relevant is: cpufreq_stats_update(), which
    updates time_in_state and last_time. This can be called by two thread in
    parallel, that may result in races.
    
    The two threads being:
    - sysfs read of time_in_state
    - and frequency transition that calls cpufreq_stat_notifier_trans().
    
    Remove locking from the first case mentioned above.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index c948086a332b..5e370a30a964 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -207,12 +207,10 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
 	cpufreq_for_each_valid_entry(pos, table)
 		if (freq_table_get_index(stats, pos->frequency) == -1)
 			stats->freq_table[i++] = pos->frequency;
-	stats->state_num = i;
 
-	spin_lock(&cpufreq_stats_lock);
+	stats->state_num = i;
 	stats->last_time = get_jiffies_64();
 	stats->last_index = freq_table_get_index(stats, policy->cur);
-	spin_unlock(&cpufreq_stats_lock);
 
 	policy->stats = stats;
 	ret = sysfs_create_group(&policy->kobj, &stats_attr_group);
@@ -294,13 +292,11 @@ static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
 
 	cpufreq_stats_update(stats);
 
-	spin_lock(&cpufreq_stats_lock);
 	stats->last_index = new_index;
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 	stats->trans_table[old_index * stats->max_state + new_index]++;
 #endif
 	stats->total_trans++;
-	spin_unlock(&cpufreq_stats_lock);
 
 put_policy:
 	cpufreq_cpu_put(policy);

commit e73476949c6d1e2edd04bbf7b5bae30afa370e33
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 6 21:09:14 2015 +0530

    cpufreq: stats: don't update stats on false notifiers
    
    We need to call cpufreq_stats_update() to update 'time_in_state' for the last
    frequency. This is achieved by calling it from cpufreq_stat_notifier_trans(),
    which is called after frequency transition.
    
    But if we detect that the cpu's frequency haven't really changed and its a false
    POSTCHANGE notification, we don't really need to update time_in_state.
    
    It wouldn't cause any harm in calling cpufreq_stats_update() but we can avoid
    calling it here and call it when the frequency really changes. The result will
    be the same but more efficient.
    
    Reviewed-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 4cd261156fff..c948086a332b 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -289,11 +289,11 @@ static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
 	if (old_index == -1 || new_index == -1)
 		goto put_policy;
 
-	cpufreq_stats_update(stats);
-
 	if (old_index == new_index)
 		goto put_policy;
 
+	cpufreq_stats_update(stats);
+
 	spin_lock(&cpufreq_stats_lock);
 	stats->last_index = new_index;
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS

commit 9225913d386537f84f0eb72f022a8b4b9e684846
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 6 21:09:13 2015 +0530

    cpufreq: stats: don't update stats from show_trans_table()
    
    cpufreq_stats_update() updates time_in_state and nothing else. It should ideally
    be updated only in two cases:
    - User requested for the current value of time_in_state.
    - We have switched states and so need to update time for the last state.
    
    Currently, we are also doing this while user asks for the transition table of
    frequencies. It wouldn't do any harm, but no good as well. Its useless here.
    
    Remove it.
    
    Reviewed-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index a9a6dc479adf..4cd261156fff 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -68,7 +68,6 @@ static ssize_t show_trans_table(struct cpufreq_policy *policy, char *buf)
 	ssize_t len = 0;
 	int i, j;
 
-	cpufreq_stats_update(stats);
 	len += snprintf(buf + len, PAGE_SIZE - len, "   From  :    To\n");
 	len += snprintf(buf + len, PAGE_SIZE - len, "         : ");
 	for (i = 0; i < stats->state_num; i++) {

commit c960f9b22d63934401949fb20d10ec4e69b535b2
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 6 21:09:12 2015 +0530

    cpufreq: stats: time_in_state can't be NULL in cpufreq_stats_update()
    
    'time_in_state' can't be NULL if 'stats' is valid. These are allocated together
    and only if time_in_state is allocated successfully, we update policy->stats.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 5d7bf9b1dfc5..a9a6dc479adf 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -35,9 +35,7 @@ static int cpufreq_stats_update(struct cpufreq_stats *stats)
 	unsigned long long cur_time = get_jiffies_64();
 
 	spin_lock(&cpufreq_stats_lock);
-	if (stats->time_in_state)
-		stats->time_in_state[stats->last_index] +=
-			cur_time - stats->last_time;
+	stats->time_in_state[stats->last_index] += cur_time - stats->last_time;
 	stats->last_time = cur_time;
 	spin_unlock(&cpufreq_stats_lock);
 	return 0;

commit a685c6d023c77303ca8700f37bf06eb85ffbf06a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 6 21:09:11 2015 +0530

    cpufreq: stats: create sysfs group once we are ready
    
    Userspace is free to read value of any file from cpufreq/stats directory once
    they are created. __cpufreq_stats_create_table() is creating the sysfs files
    first and then allocating resources for them. Though it would be quite difficult
    to trigger the racy situation here, but for the sake of keeping sensible code
    lets create sysfs entries only after we are ready to go.
    
    This also does some makeup to the routine to make it look better.
    
    Reviewed-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index e1fe0a945639..5d7bf9b1dfc5 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -164,12 +164,13 @@ static void cpufreq_stats_free_table(unsigned int cpu)
 
 static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
 {
-	unsigned int i, count = 0, ret = 0;
+	unsigned int i = 0, count = 0, ret = -ENOMEM;
 	struct cpufreq_stats *stats;
 	unsigned int alloc_size;
 	unsigned int cpu = policy->cpu;
 	struct cpufreq_frequency_table *pos, *table;
 
+	/* We need cpufreq table for creating stats table */
 	table = cpufreq_frequency_get_table(cpu);
 	if (unlikely(!table))
 		return 0;
@@ -179,15 +180,10 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
 		return -EEXIST;
 
 	stats = kzalloc(sizeof(*stats), GFP_KERNEL);
-	if ((stats) == NULL)
+	if (!stats)
 		return -ENOMEM;
 
-	ret = sysfs_create_group(&policy->kobj, &stats_attr_group);
-	if (ret)
-		goto error_out;
-
-	policy->stats = stats;
-
+	/* Find total allocation size */
 	cpufreq_for_each_valid_entry(pos, table)
 		count++;
 
@@ -196,32 +192,42 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 	alloc_size += count * count * sizeof(int);
 #endif
-	stats->max_state = count;
+
+	/* Allocate memory for time_in_state/freq_table/trans_table in one go */
 	stats->time_in_state = kzalloc(alloc_size, GFP_KERNEL);
-	if (!stats->time_in_state) {
-		ret = -ENOMEM;
-		goto error_alloc;
-	}
+	if (!stats->time_in_state)
+		goto free_stat;
+
 	stats->freq_table = (unsigned int *)(stats->time_in_state + count);
 
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 	stats->trans_table = stats->freq_table + count;
 #endif
-	i = 0;
+
+	stats->max_state = count;
+
+	/* Find valid-unique entries */
 	cpufreq_for_each_valid_entry(pos, table)
 		if (freq_table_get_index(stats, pos->frequency) == -1)
 			stats->freq_table[i++] = pos->frequency;
 	stats->state_num = i;
+
 	spin_lock(&cpufreq_stats_lock);
 	stats->last_time = get_jiffies_64();
 	stats->last_index = freq_table_get_index(stats, policy->cur);
 	spin_unlock(&cpufreq_stats_lock);
-	return 0;
-error_alloc:
-	sysfs_remove_group(&policy->kobj, &stats_attr_group);
-error_out:
-	kfree(stats);
+
+	policy->stats = stats;
+	ret = sysfs_create_group(&policy->kobj, &stats_attr_group);
+	if (!ret)
+		return 0;
+
+	/* We failed, release resources */
 	policy->stats = NULL;
+	kfree(stats->time_in_state);
+free_stat:
+	kfree(stats);
+
 	return ret;
 }
 

commit c92f2125ac5338151bb5c45e371c701e107e3197
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 6 21:09:09 2015 +0530

    cpufreq: stats: drop 'cpu' field of struct cpufreq_stats
    
    'cpu' field of struct cpufreq_stats isn't used anymore and so can be dropped.
    This change makes cpufreq_stats_update_policy_cpu() empty and so that is removed
    as well.
    
    Reviewed-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index cdc5233cf0c4..e1fe0a945639 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -18,7 +18,6 @@
 static spinlock_t cpufreq_stats_lock;
 
 struct cpufreq_stats {
-	unsigned int cpu;
 	unsigned int total_trans;
 	unsigned long long last_time;
 	unsigned int max_state;
@@ -187,7 +186,6 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
 	if (ret)
 		goto error_out;
 
-	stats->cpu = cpu;
 	policy->stats = stats;
 
 	cpufreq_for_each_valid_entry(pos, table)
@@ -244,22 +242,12 @@ static void cpufreq_stats_create_table(unsigned int cpu)
 	cpufreq_cpu_put(policy);
 }
 
-static void cpufreq_stats_update_policy_cpu(struct cpufreq_policy *policy)
-{
-	policy->stats->cpu = policy->cpu;
-}
-
 static int cpufreq_stat_notifier_policy(struct notifier_block *nb,
 		unsigned long val, void *data)
 {
 	int ret = 0;
 	struct cpufreq_policy *policy = data;
 
-	if (val == CPUFREQ_UPDATE_POLICY_CPU) {
-		cpufreq_stats_update_policy_cpu(policy);
-		return 0;
-	}
-
 	if (val == CPUFREQ_CREATE_POLICY)
 		ret = __cpufreq_stats_create_table(policy);
 	else if (val == CPUFREQ_REMOVE_POLICY)

commit 5094160786ede5c08a6901648787a5bf9b0dc2e1
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 6 21:09:07 2015 +0530

    cpufreq: stats: rename 'struct cpufreq_stats' objects as 'stats'
    
    Currently we name objects of 'struct cpufreq_stats' as 'stat' and 'stats'.
    Use 'stats' to make it consistent.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 3792b2e2f4a8..cdc5233cf0c4 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -31,15 +31,15 @@ struct cpufreq_stats {
 #endif
 };
 
-static int cpufreq_stats_update(struct cpufreq_stats *stat)
+static int cpufreq_stats_update(struct cpufreq_stats *stats)
 {
 	unsigned long long cur_time = get_jiffies_64();
 
 	spin_lock(&cpufreq_stats_lock);
-	if (stat->time_in_state)
-		stat->time_in_state[stat->last_index] +=
-			cur_time - stat->last_time;
-	stat->last_time = cur_time;
+	if (stats->time_in_state)
+		stats->time_in_state[stats->last_index] +=
+			cur_time - stats->last_time;
+	stats->last_time = cur_time;
 	spin_unlock(&cpufreq_stats_lock);
 	return 0;
 }
@@ -51,15 +51,15 @@ static ssize_t show_total_trans(struct cpufreq_policy *policy, char *buf)
 
 static ssize_t show_time_in_state(struct cpufreq_policy *policy, char *buf)
 {
-	struct cpufreq_stats *stat = policy->stats;
+	struct cpufreq_stats *stats = policy->stats;
 	ssize_t len = 0;
 	int i;
 
-	cpufreq_stats_update(stat);
-	for (i = 0; i < stat->state_num; i++) {
-		len += sprintf(buf + len, "%u %llu\n", stat->freq_table[i],
+	cpufreq_stats_update(stats);
+	for (i = 0; i < stats->state_num; i++) {
+		len += sprintf(buf + len, "%u %llu\n", stats->freq_table[i],
 			(unsigned long long)
-			jiffies_64_to_clock_t(stat->time_in_state[i]));
+			jiffies_64_to_clock_t(stats->time_in_state[i]));
 	}
 	return len;
 }
@@ -67,36 +67,36 @@ static ssize_t show_time_in_state(struct cpufreq_policy *policy, char *buf)
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 static ssize_t show_trans_table(struct cpufreq_policy *policy, char *buf)
 {
-	struct cpufreq_stats *stat = policy->stats;
+	struct cpufreq_stats *stats = policy->stats;
 	ssize_t len = 0;
 	int i, j;
 
-	cpufreq_stats_update(stat);
+	cpufreq_stats_update(stats);
 	len += snprintf(buf + len, PAGE_SIZE - len, "   From  :    To\n");
 	len += snprintf(buf + len, PAGE_SIZE - len, "         : ");
-	for (i = 0; i < stat->state_num; i++) {
+	for (i = 0; i < stats->state_num; i++) {
 		if (len >= PAGE_SIZE)
 			break;
 		len += snprintf(buf + len, PAGE_SIZE - len, "%9u ",
-				stat->freq_table[i]);
+				stats->freq_table[i]);
 	}
 	if (len >= PAGE_SIZE)
 		return PAGE_SIZE;
 
 	len += snprintf(buf + len, PAGE_SIZE - len, "\n");
 
-	for (i = 0; i < stat->state_num; i++) {
+	for (i = 0; i < stats->state_num; i++) {
 		if (len >= PAGE_SIZE)
 			break;
 
 		len += snprintf(buf + len, PAGE_SIZE - len, "%9u: ",
-				stat->freq_table[i]);
+				stats->freq_table[i]);
 
-		for (j = 0; j < stat->state_num; j++) {
+		for (j = 0; j < stats->state_num; j++) {
 			if (len >= PAGE_SIZE)
 				break;
 			len += snprintf(buf + len, PAGE_SIZE - len, "%9u ",
-					stat->trans_table[i*stat->max_state+j]);
+					stats->trans_table[i*stats->max_state+j]);
 		}
 		if (len >= PAGE_SIZE)
 			break;
@@ -125,28 +125,28 @@ static struct attribute_group stats_attr_group = {
 	.name = "stats"
 };
 
-static int freq_table_get_index(struct cpufreq_stats *stat, unsigned int freq)
+static int freq_table_get_index(struct cpufreq_stats *stats, unsigned int freq)
 {
 	int index;
-	for (index = 0; index < stat->max_state; index++)
-		if (stat->freq_table[index] == freq)
+	for (index = 0; index < stats->max_state; index++)
+		if (stats->freq_table[index] == freq)
 			return index;
 	return -1;
 }
 
 static void __cpufreq_stats_free_table(struct cpufreq_policy *policy)
 {
-	struct cpufreq_stats *stat = policy->stats;
+	struct cpufreq_stats *stats = policy->stats;
 
 	/* Already freed */
-	if (!stat)
+	if (!stats)
 		return;
 
-	pr_debug("%s: Free stat table\n", __func__);
+	pr_debug("%s: Free stats table\n", __func__);
 
 	sysfs_remove_group(&policy->kobj, &stats_attr_group);
-	kfree(stat->time_in_state);
-	kfree(stat);
+	kfree(stats->time_in_state);
+	kfree(stats);
 	policy->stats = NULL;
 }
 
@@ -166,7 +166,7 @@ static void cpufreq_stats_free_table(unsigned int cpu)
 static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
 {
 	unsigned int i, count = 0, ret = 0;
-	struct cpufreq_stats *stat;
+	struct cpufreq_stats *stats;
 	unsigned int alloc_size;
 	unsigned int cpu = policy->cpu;
 	struct cpufreq_frequency_table *pos, *table;
@@ -179,16 +179,16 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
 	if (policy->stats)
 		return -EEXIST;
 
-	stat = kzalloc(sizeof(*stat), GFP_KERNEL);
-	if ((stat) == NULL)
+	stats = kzalloc(sizeof(*stats), GFP_KERNEL);
+	if ((stats) == NULL)
 		return -ENOMEM;
 
 	ret = sysfs_create_group(&policy->kobj, &stats_attr_group);
 	if (ret)
 		goto error_out;
 
-	stat->cpu = cpu;
-	policy->stats = stat;
+	stats->cpu = cpu;
+	policy->stats = stats;
 
 	cpufreq_for_each_valid_entry(pos, table)
 		count++;
@@ -198,31 +198,31 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 	alloc_size += count * count * sizeof(int);
 #endif
-	stat->max_state = count;
-	stat->time_in_state = kzalloc(alloc_size, GFP_KERNEL);
-	if (!stat->time_in_state) {
+	stats->max_state = count;
+	stats->time_in_state = kzalloc(alloc_size, GFP_KERNEL);
+	if (!stats->time_in_state) {
 		ret = -ENOMEM;
 		goto error_alloc;
 	}
-	stat->freq_table = (unsigned int *)(stat->time_in_state + count);
+	stats->freq_table = (unsigned int *)(stats->time_in_state + count);
 
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
-	stat->trans_table = stat->freq_table + count;
+	stats->trans_table = stats->freq_table + count;
 #endif
 	i = 0;
 	cpufreq_for_each_valid_entry(pos, table)
-		if (freq_table_get_index(stat, pos->frequency) == -1)
-			stat->freq_table[i++] = pos->frequency;
-	stat->state_num = i;
+		if (freq_table_get_index(stats, pos->frequency) == -1)
+			stats->freq_table[i++] = pos->frequency;
+	stats->state_num = i;
 	spin_lock(&cpufreq_stats_lock);
-	stat->last_time = get_jiffies_64();
-	stat->last_index = freq_table_get_index(stat, policy->cur);
+	stats->last_time = get_jiffies_64();
+	stats->last_index = freq_table_get_index(stats, policy->cur);
 	spin_unlock(&cpufreq_stats_lock);
 	return 0;
 error_alloc:
 	sysfs_remove_group(&policy->kobj, &stats_attr_group);
 error_out:
-	kfree(stat);
+	kfree(stats);
 	policy->stats = NULL;
 	return ret;
 }
@@ -273,7 +273,7 @@ static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
 {
 	struct cpufreq_freqs *freq = data;
 	struct cpufreq_policy *policy = cpufreq_cpu_get(freq->cpu);
-	struct cpufreq_stats *stat;
+	struct cpufreq_stats *stats;
 	int old_index, new_index;
 
 	if (!policy) {
@@ -289,26 +289,26 @@ static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
 		goto put_policy;
 	}
 
-	stat = policy->stats;
+	stats = policy->stats;
 
-	old_index = stat->last_index;
-	new_index = freq_table_get_index(stat, freq->new);
+	old_index = stats->last_index;
+	new_index = freq_table_get_index(stats, freq->new);
 
-	/* We can't do stat->time_in_state[-1]= .. */
+	/* We can't do stats->time_in_state[-1]= .. */
 	if (old_index == -1 || new_index == -1)
 		goto put_policy;
 
-	cpufreq_stats_update(stat);
+	cpufreq_stats_update(stats);
 
 	if (old_index == new_index)
 		goto put_policy;
 
 	spin_lock(&cpufreq_stats_lock);
-	stat->last_index = new_index;
+	stats->last_index = new_index;
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
-	stat->trans_table[old_index * stat->max_state + new_index]++;
+	stats->trans_table[old_index * stats->max_state + new_index]++;
 #endif
-	stat->total_trans++;
+	stats->total_trans++;
 	spin_unlock(&cpufreq_stats_lock);
 
 put_policy:

commit a9aaf2915ee265735c28b764551d084e61a694e0
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 13 11:34:00 2015 +0530

    cpufreq: stats: get rid of per-cpu cpufreq_stats_table
    
    All CPUs sharing a cpufreq policy share stats too. For this reason,
    add a stats pointer to struct cpufreq_policy and drop per-CPU variable
    cpufreq_stats_table used for accessing cpufreq stats so as to reduce
    code complexity.
    
    Reviewed-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 6c234f548601..3792b2e2f4a8 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -31,8 +31,6 @@ struct cpufreq_stats {
 #endif
 };
 
-static DEFINE_PER_CPU(struct cpufreq_stats *, cpufreq_stats_table);
-
 static int cpufreq_stats_update(struct cpufreq_stats *stat)
 {
 	unsigned long long cur_time = get_jiffies_64();
@@ -48,20 +46,15 @@ static int cpufreq_stats_update(struct cpufreq_stats *stat)
 
 static ssize_t show_total_trans(struct cpufreq_policy *policy, char *buf)
 {
-	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, policy->cpu);
-	if (!stat)
-		return 0;
-	return sprintf(buf, "%d\n",
-			per_cpu(cpufreq_stats_table, stat->cpu)->total_trans);
+	return sprintf(buf, "%d\n", policy->stats->total_trans);
 }
 
 static ssize_t show_time_in_state(struct cpufreq_policy *policy, char *buf)
 {
+	struct cpufreq_stats *stat = policy->stats;
 	ssize_t len = 0;
 	int i;
-	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, policy->cpu);
-	if (!stat)
-		return 0;
+
 	cpufreq_stats_update(stat);
 	for (i = 0; i < stat->state_num; i++) {
 		len += sprintf(buf + len, "%u %llu\n", stat->freq_table[i],
@@ -74,12 +67,10 @@ static ssize_t show_time_in_state(struct cpufreq_policy *policy, char *buf)
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 static ssize_t show_trans_table(struct cpufreq_policy *policy, char *buf)
 {
+	struct cpufreq_stats *stat = policy->stats;
 	ssize_t len = 0;
 	int i, j;
 
-	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, policy->cpu);
-	if (!stat)
-		return 0;
 	cpufreq_stats_update(stat);
 	len += snprintf(buf + len, PAGE_SIZE - len, "   From  :    To\n");
 	len += snprintf(buf + len, PAGE_SIZE - len, "         : ");
@@ -145,8 +136,9 @@ static int freq_table_get_index(struct cpufreq_stats *stat, unsigned int freq)
 
 static void __cpufreq_stats_free_table(struct cpufreq_policy *policy)
 {
-	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, policy->cpu);
+	struct cpufreq_stats *stat = policy->stats;
 
+	/* Already freed */
 	if (!stat)
 		return;
 
@@ -155,7 +147,7 @@ static void __cpufreq_stats_free_table(struct cpufreq_policy *policy)
 	sysfs_remove_group(&policy->kobj, &stats_attr_group);
 	kfree(stat->time_in_state);
 	kfree(stat);
-	per_cpu(cpufreq_stats_table, policy->cpu) = NULL;
+	policy->stats = NULL;
 }
 
 static void cpufreq_stats_free_table(unsigned int cpu)
@@ -184,7 +176,7 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
 		return 0;
 
 	/* stats already initialized */
-	if (per_cpu(cpufreq_stats_table, cpu))
+	if (policy->stats)
 		return -EEXIST;
 
 	stat = kzalloc(sizeof(*stat), GFP_KERNEL);
@@ -196,7 +188,7 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
 		goto error_out;
 
 	stat->cpu = cpu;
-	per_cpu(cpufreq_stats_table, cpu) = stat;
+	policy->stats = stat;
 
 	cpufreq_for_each_valid_entry(pos, table)
 		count++;
@@ -231,7 +223,7 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
 	sysfs_remove_group(&policy->kobj, &stats_attr_group);
 error_out:
 	kfree(stat);
-	per_cpu(cpufreq_stats_table, cpu) = NULL;
+	policy->stats = NULL;
 	return ret;
 }
 
@@ -254,15 +246,7 @@ static void cpufreq_stats_create_table(unsigned int cpu)
 
 static void cpufreq_stats_update_policy_cpu(struct cpufreq_policy *policy)
 {
-	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table,
-			policy->last_cpu);
-
-	pr_debug("Updating stats_table for new_cpu %u from last_cpu %u\n",
-			policy->cpu, policy->last_cpu);
-	per_cpu(cpufreq_stats_table, policy->cpu) = per_cpu(cpufreq_stats_table,
-			policy->last_cpu);
-	per_cpu(cpufreq_stats_table, policy->last_cpu) = NULL;
-	stat->cpu = policy->cpu;
+	policy->stats->cpu = policy->cpu;
 }
 
 static int cpufreq_stat_notifier_policy(struct notifier_block *nb,
@@ -288,27 +272,36 @@ static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
 		unsigned long val, void *data)
 {
 	struct cpufreq_freqs *freq = data;
+	struct cpufreq_policy *policy = cpufreq_cpu_get(freq->cpu);
 	struct cpufreq_stats *stat;
 	int old_index, new_index;
 
-	if (val != CPUFREQ_POSTCHANGE)
+	if (!policy) {
+		pr_err("%s: No policy found\n", __func__);
 		return 0;
+	}
 
-	stat = per_cpu(cpufreq_stats_table, freq->cpu);
-	if (!stat)
-		return 0;
+	if (val != CPUFREQ_POSTCHANGE)
+		goto put_policy;
+
+	if (!policy->stats) {
+		pr_debug("%s: No stats found\n", __func__);
+		goto put_policy;
+	}
+
+	stat = policy->stats;
 
 	old_index = stat->last_index;
 	new_index = freq_table_get_index(stat, freq->new);
 
 	/* We can't do stat->time_in_state[-1]= .. */
 	if (old_index == -1 || new_index == -1)
-		return 0;
+		goto put_policy;
 
 	cpufreq_stats_update(stat);
 
 	if (old_index == new_index)
-		return 0;
+		goto put_policy;
 
 	spin_lock(&cpufreq_stats_lock);
 	stat->last_index = new_index;
@@ -317,6 +310,9 @@ static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
 #endif
 	stat->total_trans++;
 	spin_unlock(&cpufreq_stats_lock);
+
+put_policy:
+	cpufreq_cpu_put(policy);
 	return 0;
 }
 

commit 2aba0c1bae564a59fc38c407abf7985f9e347cc4
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 6 21:09:05 2015 +0530

    cpufreq: stats: pass 'stat' to cpufreq_stats_update()
    
    It is better to pass a struct cpufreq_stats pointer to cpufreq_stats_update()
    instead of a CPU number, because that's all it needs.
    
    Even if we pass a cpu number to cpufreq_stats_update(), it reads the per-cpu
    variable to get 'stats' out of it. So we are doing these operations
    unnecessarily:
    - First getting the cpu number to pass to cpufreq_stats_update(), stat->cpu.
    - And then getting stats from the cpu, per_cpu(cpufreq_stats_table, cpu).
    
    Reviewed-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index e9d68420b876..6c234f548601 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -33,13 +33,11 @@ struct cpufreq_stats {
 
 static DEFINE_PER_CPU(struct cpufreq_stats *, cpufreq_stats_table);
 
-static int cpufreq_stats_update(unsigned int cpu)
+static int cpufreq_stats_update(struct cpufreq_stats *stat)
 {
-	struct cpufreq_stats *stat;
 	unsigned long long cur_time = get_jiffies_64();
 
 	spin_lock(&cpufreq_stats_lock);
-	stat = per_cpu(cpufreq_stats_table, cpu);
 	if (stat->time_in_state)
 		stat->time_in_state[stat->last_index] +=
 			cur_time - stat->last_time;
@@ -64,7 +62,7 @@ static ssize_t show_time_in_state(struct cpufreq_policy *policy, char *buf)
 	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, policy->cpu);
 	if (!stat)
 		return 0;
-	cpufreq_stats_update(stat->cpu);
+	cpufreq_stats_update(stat);
 	for (i = 0; i < stat->state_num; i++) {
 		len += sprintf(buf + len, "%u %llu\n", stat->freq_table[i],
 			(unsigned long long)
@@ -82,7 +80,7 @@ static ssize_t show_trans_table(struct cpufreq_policy *policy, char *buf)
 	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, policy->cpu);
 	if (!stat)
 		return 0;
-	cpufreq_stats_update(stat->cpu);
+	cpufreq_stats_update(stat);
 	len += snprintf(buf + len, PAGE_SIZE - len, "   From  :    To\n");
 	len += snprintf(buf + len, PAGE_SIZE - len, "         : ");
 	for (i = 0; i < stat->state_num; i++) {
@@ -307,7 +305,7 @@ static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
 	if (old_index == -1 || new_index == -1)
 		return 0;
 
-	cpufreq_stats_update(freq->cpu);
+	cpufreq_stats_update(stat);
 
 	if (old_index == new_index)
 		return 0;

commit f93dbbbd108936b18b3230af36d9a36866ce69a7
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 6 21:09:04 2015 +0530

    cpufreq: stats: don't check for freq table while freeing stats
    
    While we allocate stats, we do need to check if freq-table is present
    or not as we need to use it then. But while freeing stats, all we need
    to know is if stats holds a valid pointer value. There is no use of
    testing if cpufreq table is present or not.
    
    Don't check it.
    
    Reviewed-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 21bec770569d..e9d68420b876 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -168,8 +168,7 @@ static void cpufreq_stats_free_table(unsigned int cpu)
 	if (!policy)
 		return;
 
-	if (cpufreq_frequency_get_table(policy->cpu))
-		__cpufreq_stats_free_table(policy);
+	__cpufreq_stats_free_table(policy);
 
 	cpufreq_cpu_put(policy);
 }

commit 9531347c61f689ac6de899a03ce91be4157277f7
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 6 21:09:03 2015 +0530

    cpufreq: stats: initialize 'cur_time' on its definition
    
    'cur_time' is defined in the first line and is then assigned a value
    in the next line. Initialize it while defining it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 14f8d858a63d..21bec770569d 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -36,9 +36,8 @@ static DEFINE_PER_CPU(struct cpufreq_stats *, cpufreq_stats_table);
 static int cpufreq_stats_update(unsigned int cpu)
 {
 	struct cpufreq_stats *stat;
-	unsigned long long cur_time;
+	unsigned long long cur_time = get_jiffies_64();
 
-	cur_time = get_jiffies_64();
 	spin_lock(&cpufreq_stats_lock);
 	stat = per_cpu(cpufreq_stats_table, cpu);
 	if (stat->time_in_state)

commit 43b9cdaf5c22230269b8edd99ec78380a6ac0715
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 6 21:09:02 2015 +0530

    cpufreq: stats: remove unused cpufreq_stats_attribute
    
    It was never used, but is there since the first commit. Remove it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index d2299ca2fc2c..14f8d858a63d 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -33,11 +33,6 @@ struct cpufreq_stats {
 
 static DEFINE_PER_CPU(struct cpufreq_stats *, cpufreq_stats_table);
 
-struct cpufreq_stats_attribute {
-	struct attribute attr;
-	ssize_t(*show) (struct cpufreq_stats *, char *);
-};
-
 static int cpufreq_stats_update(unsigned int cpu)
 {
 	struct cpufreq_stats *stat;

commit b8c674482f3cd0d93d07dbc2518cc96c3cc24ed0
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 6 21:09:01 2015 +0530

    cpufreq: stats: return -EEXIST when stats are already allocated
    
    __cpufreq_stats_create_table() is called from:
    
    - cpufreq notifier on creation of a new policy. Stats will always be
      NULL here.
    - cpufreq_stats_init() for all CPUs as cpufreq-stats might have been
      initialized after cpufreq driver. For any policy, 'stats' will be
      NULL for the first CPU only and will be valid for all other CPUs
      managed by the same policy.
    
    While we return for other CPUs, we don't return the right error value.
    It's not that we would fail with -EBUSY. But generally, this is what
    these return values mean:
    - EBUSY: we are busy right now, try again. And the retry attempt might
      be immediate.
    - EEXIST: We already have what you are trying to create and there is no
      need to create it again, and so no more tries are required.
    
    Reviewed-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 80801f880dd8..d2299ca2fc2c 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -192,8 +192,10 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
 	if (unlikely(!table))
 		return 0;
 
+	/* stats already initialized */
 	if (per_cpu(cpufreq_stats_table, cpu))
-		return -EBUSY;
+		return -EEXIST;
+
 	stat = kzalloc(sizeof(*stat), GFP_KERNEL);
 	if ((stat) == NULL)
 		return -ENOMEM;

commit 00d0b29472d1605851c12c77aaa3664413a71fbf
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 6 21:09:00 2015 +0530

    cpufreq: stats: Improve module description string
    
    The MODULE_DESCRIPTION() string is just too long and then is broken into
    multiple lines just to make checkpatch happy.
    
    Rewrite it to make it more precise.
    
    Reviewed-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 0cd9b4dcef99..80801f880dd8 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -374,8 +374,7 @@ static void __exit cpufreq_stats_exit(void)
 }
 
 MODULE_AUTHOR("Zou Nan hai <nanhai.zou@intel.com>");
-MODULE_DESCRIPTION("'cpufreq_stats' - A driver to export cpufreq stats "
-				"through sysfs filesystem");
+MODULE_DESCRIPTION("Export cpufreq stats via sysfs");
 MODULE_LICENSE("GPL");
 
 module_init(cpufreq_stats_init);

commit 041526f915a90b2b628cd0253e2c85da8040276d
Author: Stratos Karafotis <stratosk@semaphore.gr>
Date:   Fri Apr 25 23:15:38 2014 +0300

    cpufreq: Use cpufreq_for_each_* macros for frequency table iteration
    
    The cpufreq core now supports the cpufreq_for_each_entry and
    cpufreq_for_each_valid_entry macros helpers for iteration over the
    cpufreq_frequency_table, so use them.
    
    It should have no functional changes.
    
    Signed-off-by: Stratos Karafotis <stratosk@semaphore.gr>
    Acked-by: Lad, Prabhakar <prabhakar.csengg@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index ecaaebf969fc..0cd9b4dcef99 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -182,11 +182,11 @@ static void cpufreq_stats_free_table(unsigned int cpu)
 
 static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
 {
-	unsigned int i, j, count = 0, ret = 0;
+	unsigned int i, count = 0, ret = 0;
 	struct cpufreq_stats *stat;
 	unsigned int alloc_size;
 	unsigned int cpu = policy->cpu;
-	struct cpufreq_frequency_table *table;
+	struct cpufreq_frequency_table *pos, *table;
 
 	table = cpufreq_frequency_get_table(cpu);
 	if (unlikely(!table))
@@ -205,12 +205,8 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
 	stat->cpu = cpu;
 	per_cpu(cpufreq_stats_table, cpu) = stat;
 
-	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
-		unsigned int freq = table[i].frequency;
-		if (freq == CPUFREQ_ENTRY_INVALID)
-			continue;
+	cpufreq_for_each_valid_entry(pos, table)
 		count++;
-	}
 
 	alloc_size = count * sizeof(int) + count * sizeof(u64);
 
@@ -228,15 +224,11 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 	stat->trans_table = stat->freq_table + count;
 #endif
-	j = 0;
-	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
-		unsigned int freq = table[i].frequency;
-		if (freq == CPUFREQ_ENTRY_INVALID)
-			continue;
-		if (freq_table_get_index(stat, freq) == -1)
-			stat->freq_table[j++] = freq;
-	}
-	stat->state_num = j;
+	i = 0;
+	cpufreq_for_each_valid_entry(pos, table)
+		if (freq_table_get_index(stat, pos->frequency) == -1)
+			stat->freq_table[i++] = pos->frequency;
+	stat->state_num = i;
 	spin_lock(&cpufreq_stats_lock);
 	stat->last_time = get_jiffies_64();
 	stat->last_index = freq_table_get_index(stat, policy->cur);

commit 4dedde7c7a18f55180574f934dbc1be84ca0400b
Merge: 683b6c6f82a6 0ecfe310f451
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 1 12:48:54 2014 -0700

    Merge tag 'pm+acpi-3.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI and power management updates from Rafael Wysocki:
     "The majority of this material spent some time in linux-next, some of
      it even several weeks.  There are a few relatively fresh commits in
      it, but they are mostly fixes and simple cleanups.
    
      ACPI took the lead this time, both in terms of the number of commits
      and the number of modified lines of code, cpufreq follows and there
      are a few changes in the PM core and in cpuidle too.
    
      A new feature that already got some LWN.net's attention is the device
      PM QoS extension allowing latency tolerance requirements to be
      propagated from leaf devices to their ancestors with hardware
      interfaces for specifying latency tolerance.  That should help systems
      with hardware-driven power management to avoid going too far with it
      in cases when there are latency tolerance constraints.
    
      There also are some significant changes in the ACPI core related to
      the way in which hotplug notifications are handled.  They affect PCI
      hotplug (ACPIPHP) and the ACPI dock station code too.  The bottom line
      is that all those notification now go through the root notify handler
      and are propagated to the interested subsystems by means of callbacks
      instead of having to install a notify handler for each device object
      that we can potentially get hotplug notifications for.
    
      In addition to that ACPICA will now advertise "Windows 2013"
      compatibility for _OSI, because some systems out there don't work
      correctly if that is not done (some of them don't even boot).
    
      On the system suspend side of things, all of the device suspend and
      resume callbacks, except for ->prepare() and ->complete(), are now
      going to be executed asynchronously as that turns out to speed up
      system suspend and resume on some platforms quite significantly and we
      have a few more optimizations in that area.
    
      Apart from that, there are some new device IDs and fixes and cleanups
      all over.  In particular, the system suspend and resume handling by
      cpufreq should be improved and the cpuidle menu governor should be a
      bit more robust now.
    
      Specifics:
    
       - Device PM QoS support for latency tolerance constraints on systems
         with hardware interfaces allowing such constraints to be specified.
         That is necessary to prevent hardware-driven power management from
         becoming overly aggressive on some systems and to prevent power
         management features leading to excessive latencies from being used
         in some cases.
    
       - Consolidation of the handling of ACPI hotplug notifications for
         device objects.  This causes all device hotplug notifications to go
         through the root notify handler (that was executed for all of them
         anyway before) that propagates them to individual subsystems, if
         necessary, by executing callbacks provided by those subsystems
         (those callbacks are associated with struct acpi_device objects
         during device enumeration).  As a result, the code in question
         becomes both smaller in size and more straightforward and all of
         those changes should not affect users.
    
       - ACPICA update, including fixes related to the handling of _PRT in
         cases when it is broken and the addition of "Windows 2013" to the
         list of supported "features" for _OSI (which is necessary to
         support systems that work incorrectly or don't even boot without
         it).  Changes from Bob Moore and Lv Zheng.
    
       - Consolidation of ACPI _OST handling from Jiang Liu.
    
       - ACPI battery and AC fixes allowing unusual system configurations to
         be handled by that code from Alexander Mezin.
    
       - New device IDs for the ACPI LPSS driver from Chiau Ee Chew.
    
       - ACPI fan and thermal optimizations related to system suspend and
         resume from Aaron Lu.
    
       - Cleanups related to ACPI video from Jean Delvare.
    
       - Assorted ACPI fixes and cleanups from Al Stone, Hanjun Guo, Lan
         Tianyu, Paul Bolle, Tomasz Nowicki.
    
       - Intel RAPL (Running Average Power Limits) driver cleanups from
         Jacob Pan.
    
       - intel_pstate fixes and cleanups from Dirk Brandewie.
    
       - cpufreq fixes related to system suspend/resume handling from Viresh
         Kumar.
    
       - cpufreq core fixes and cleanups from Viresh Kumar, Stratos
         Karafotis, Saravana Kannan, Rashika Kheria, Joe Perches.
    
       - cpufreq drivers updates from Viresh Kumar, Zhuoyu Zhang, Rob
         Herring.
    
       - cpuidle fixes related to the menu governor from Tuukka Tikkanen.
    
       - cpuidle fix related to coupled CPUs handling from Paul Burton.
    
       - Asynchronous execution of all device suspend and resume callbacks,
         except for ->prepare and ->complete, during system suspend and
         resume from Chuansheng Liu.
    
       - Delayed resuming of runtime-suspended devices during system suspend
         for the PCI bus type and ACPI PM domain.
    
       - New set of PM helper routines to allow device runtime PM callbacks
         to be used during system suspend and resume more easily from Ulf
         Hansson.
    
       - Assorted fixes and cleanups in the PM core from Geert Uytterhoeven,
         Prabhakar Lad, Philipp Zabel, Rashika Kheria, Sebastian Capella.
    
       - devfreq fix from Saravana Kannan"
    
    * tag 'pm+acpi-3.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (162 commits)
      PM / devfreq: Rewrite devfreq_update_status() to fix multiple bugs
      PM / sleep: Correct whitespace errors in <linux/pm.h>
      intel_pstate: Set core to min P state during core offline
      cpufreq: Add stop CPU callback to cpufreq_driver interface
      cpufreq: Remove unnecessary braces
      cpufreq: Fix checkpatch errors and warnings
      cpufreq: powerpc: add cpufreq transition latency for FSL e500mc SoCs
      MAINTAINERS: Reorder maintainer addresses for PM and ACPI
      PM / Runtime: Update runtime_idle() documentation for return value meaning
      video / output: Drop display output class support
      fujitsu-laptop: Drop unneeded include
      acer-wmi: Stop selecting VIDEO_OUTPUT_CONTROL
      ACPI / gpu / drm: Stop selecting VIDEO_OUTPUT_CONTROL
      ACPI / video: fix ACPI_VIDEO dependencies
      cpufreq: remove unused notifier: CPUFREQ_{SUSPENDCHANGE|RESUMECHANGE}
      cpufreq: Do not allow ->setpolicy drivers to provide ->target
      cpufreq: arm_big_little: set 'physical_cluster' for each CPU
      cpufreq: arm_big_little: make vexpress driver depend on bL core driver
      ACPI / button: Add ACPI Button event via netlink routine
      ACPI: Remove duplicate definitions of PREFIX
      ...

commit bfc3f0281e08066fa8111c3972cff6edc1049864
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Wed Mar 5 16:33:42 2014 +0100

    cputime: Default implementation of nsecs -> cputime conversion
    
    The architectures that override cputime_t (s390, ppc) don't provide
    any version of nsecs_to_cputime(). Indeed this cputime_t implementation
    by backend only happens when CONFIG_VIRT_CPU_ACCOUNTING_NATIVE=y under
    which the core code doesn't make any use of nsecs_to_cputime().
    
    At least for now.
    
    We are going to make a broader use of it so lets provide a default
    version with a per usecs granularity. It should be good enough for most
    usecases.
    
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Marcelo Tosatti <mtosatti@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Rik van Riel <riel@redhat.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 5793e1447fb1..79911a27a48a 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -13,7 +13,7 @@
 #include <linux/cpufreq.h>
 #include <linux/module.h>
 #include <linux/slab.h>
-#include <asm/cputime.h>
+#include <linux/cputime.h>
 
 static spinlock_t cpufreq_stats_lock;
 

commit ad4c2302c20a6906eb2f10defdb0e982bab5eb0b
Author: Saravana Kannan <skannan@codeaurora.org>
Date:   Thu Feb 27 17:58:36 2014 -0800

    cpufreq: stats: Refactor common code into __cpufreq_stats_create_table()
    
    cpufreq_frequency_get_table() is called from all callers of
    __cpufreq_stats_create_table(). So, move it inside.
    
    Suggested-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Saravana Kannan <skannan@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index c52b44071100..eb214d83ad6b 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -180,13 +180,18 @@ static void cpufreq_stats_free_table(unsigned int cpu)
 	cpufreq_cpu_put(policy);
 }
 
-static int __cpufreq_stats_create_table(struct cpufreq_policy *policy,
-		struct cpufreq_frequency_table *table)
+static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
 {
 	unsigned int i, j, count = 0, ret = 0;
 	struct cpufreq_stats *stat;
 	unsigned int alloc_size;
 	unsigned int cpu = policy->cpu;
+	struct cpufreq_frequency_table *table;
+
+	table = cpufreq_frequency_get_table(cpu);
+	if (unlikely(!table))
+		return 0;
+
 	if (per_cpu(cpufreq_stats_table, cpu))
 		return -EBUSY;
 	stat = kzalloc(sizeof(*stat), GFP_KERNEL);
@@ -248,7 +253,6 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy,
 static void cpufreq_stats_create_table(unsigned int cpu)
 {
 	struct cpufreq_policy *policy;
-	struct cpufreq_frequency_table *table;
 
 	/*
 	 * "likely(!policy)" because normally cpufreq_stats will be registered
@@ -258,9 +262,7 @@ static void cpufreq_stats_create_table(unsigned int cpu)
 	if (likely(!policy))
 		return;
 
-	table = cpufreq_frequency_get_table(policy->cpu);
-	if (likely(table))
-		__cpufreq_stats_create_table(policy, table);
+	__cpufreq_stats_create_table(policy);
 
 	cpufreq_cpu_put(policy);
 }
@@ -283,20 +285,14 @@ static int cpufreq_stat_notifier_policy(struct notifier_block *nb,
 {
 	int ret = 0;
 	struct cpufreq_policy *policy = data;
-	struct cpufreq_frequency_table *table;
-	unsigned int cpu = policy->cpu;
 
 	if (val == CPUFREQ_UPDATE_POLICY_CPU) {
 		cpufreq_stats_update_policy_cpu(policy);
 		return 0;
 	}
 
-	table = cpufreq_frequency_get_table(cpu);
-	if (!table)
-		return 0;
-
 	if (val == CPUFREQ_CREATE_POLICY)
-		ret = __cpufreq_stats_create_table(policy, table);
+		ret = __cpufreq_stats_create_table(policy);
 	else if (val == CPUFREQ_REMOVE_POLICY)
 		__cpufreq_stats_free_table(policy);
 

commit 0b7528d963e7dda51dd07fa7b1f14a9bf03b1cee
Author: Saravana Kannan <skannan@codeaurora.org>
Date:   Thu Feb 27 17:58:35 2014 -0800

    cpufreq: stats: Fix error handling in __cpufreq_stats_create_table()
    
    Remove sysfs group if __cpufreq_stats_create_table() fails after creating
    one.
    
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Saravana Kannan <skannan@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index e4bd27f1a9d8..c52b44071100 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -216,7 +216,7 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy,
 	stat->time_in_state = kzalloc(alloc_size, GFP_KERNEL);
 	if (!stat->time_in_state) {
 		ret = -ENOMEM;
-		goto error_out;
+		goto error_alloc;
 	}
 	stat->freq_table = (unsigned int *)(stat->time_in_state + count);
 
@@ -237,6 +237,8 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy,
 	stat->last_index = freq_table_get_index(stat, policy->cur);
 	spin_unlock(&cpufreq_stats_lock);
 	return 0;
+error_alloc:
+	sysfs_remove_group(&policy->kobj, &stats_attr_group);
 error_out:
 	kfree(stat);
 	per_cpu(cpufreq_stats_table, cpu) = NULL;

commit b24a5b6512a6fb89f3b99b9b0f829b4448e62db0
Author: Saravana Kannan <skannan@codeaurora.org>
Date:   Thu Feb 27 17:58:34 2014 -0800

    cpufreq: stats: Remove redundant cpufreq_cpu_get() call
    
    __cpufreq_stats_create_table always gets pass the valid and real policy
    struct. So, there's no need to call cpufreq_cpu_get() to get the policy
    again.
    
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Saravana Kannan <skannan@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 5793e1447fb1..e4bd27f1a9d8 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -185,7 +185,6 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy,
 {
 	unsigned int i, j, count = 0, ret = 0;
 	struct cpufreq_stats *stat;
-	struct cpufreq_policy *current_policy;
 	unsigned int alloc_size;
 	unsigned int cpu = policy->cpu;
 	if (per_cpu(cpufreq_stats_table, cpu))
@@ -194,13 +193,7 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy,
 	if ((stat) == NULL)
 		return -ENOMEM;
 
-	current_policy = cpufreq_cpu_get(cpu);
-	if (current_policy == NULL) {
-		ret = -EINVAL;
-		goto error_get_fail;
-	}
-
-	ret = sysfs_create_group(&current_policy->kobj, &stats_attr_group);
+	ret = sysfs_create_group(&policy->kobj, &stats_attr_group);
 	if (ret)
 		goto error_out;
 
@@ -243,11 +236,8 @@ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy,
 	stat->last_time = get_jiffies_64();
 	stat->last_index = freq_table_get_index(stat, policy->cur);
 	spin_unlock(&cpufreq_stats_lock);
-	cpufreq_cpu_put(current_policy);
 	return 0;
 error_out:
-	cpufreq_cpu_put(current_policy);
-error_get_fail:
 	kfree(stat);
 	per_cpu(cpufreq_stats_table, cpu) = NULL;
 	return ret;

commit b3f9ff88db6e149086dc111e5652106005fd5923
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 7 07:10:13 2014 +0530

    cpufreq: stats: create sysfs entries when cpufreq_stats is a module
    
    When cpufreq_stats is compiled in as a module, cpufreq driver would
    have already been registered. And so the CPUFREQ_CREATE_POLICY
    notifiers wouldn't be called for it. Hence no sysfs entries for stats. :(
    
    This patch calls cpufreq_stats_create_table() for each online CPU from
    cpufreq_stats_init() and so if policy is already created for CPUx then
    we will register sysfs stats for it.
    
    When its not compiled as module, we will return early as policy wouldn't
    be found for any of the CPUs.
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Tested-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 9dd58835456e..5793e1447fb1 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -180,7 +180,7 @@ static void cpufreq_stats_free_table(unsigned int cpu)
 	cpufreq_cpu_put(policy);
 }
 
-static int cpufreq_stats_create_table(struct cpufreq_policy *policy,
+static int __cpufreq_stats_create_table(struct cpufreq_policy *policy,
 		struct cpufreq_frequency_table *table)
 {
 	unsigned int i, j, count = 0, ret = 0;
@@ -253,6 +253,26 @@ static int cpufreq_stats_create_table(struct cpufreq_policy *policy,
 	return ret;
 }
 
+static void cpufreq_stats_create_table(unsigned int cpu)
+{
+	struct cpufreq_policy *policy;
+	struct cpufreq_frequency_table *table;
+
+	/*
+	 * "likely(!policy)" because normally cpufreq_stats will be registered
+	 * before cpufreq driver
+	 */
+	policy = cpufreq_cpu_get(cpu);
+	if (likely(!policy))
+		return;
+
+	table = cpufreq_frequency_get_table(policy->cpu);
+	if (likely(table))
+		__cpufreq_stats_create_table(policy, table);
+
+	cpufreq_cpu_put(policy);
+}
+
 static void cpufreq_stats_update_policy_cpu(struct cpufreq_policy *policy)
 {
 	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table,
@@ -284,7 +304,7 @@ static int cpufreq_stat_notifier_policy(struct notifier_block *nb,
 		return 0;
 
 	if (val == CPUFREQ_CREATE_POLICY)
-		ret = cpufreq_stats_create_table(policy, table);
+		ret = __cpufreq_stats_create_table(policy, table);
 	else if (val == CPUFREQ_REMOVE_POLICY)
 		__cpufreq_stats_free_table(policy);
 
@@ -346,6 +366,9 @@ static int __init cpufreq_stats_init(void)
 	if (ret)
 		return ret;
 
+	for_each_online_cpu(cpu)
+		cpufreq_stats_create_table(cpu);
+
 	ret = cpufreq_register_notifier(&notifier_trans_block,
 				CPUFREQ_TRANSITION_NOTIFIER);
 	if (ret) {

commit 2d13594dcb7eaa41fa180e8a3b27a8f10845381f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 7 07:10:12 2014 +0530

    cpufreq: stats: free table and remove sysfs entry in a single routine
    
    We don't have code paths now where we need to do these two things
    separately, so it is better do them in a single routine. Just as
    they are allocated in a single routine.
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Tested-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 8fa58440ea95..9dd58835456e 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -151,40 +151,32 @@ static int freq_table_get_index(struct cpufreq_stats *stat, unsigned int freq)
 	return -1;
 }
 
-/* should be called late in the CPU removal sequence so that the stats
- * memory is still available in case someone tries to use it.
- */
-static void cpufreq_stats_free_table(unsigned int cpu)
+static void __cpufreq_stats_free_table(struct cpufreq_policy *policy)
 {
-	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, cpu);
+	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, policy->cpu);
 
-	if (stat) {
-		pr_debug("%s: Free stat table\n", __func__);
-		kfree(stat->time_in_state);
-		kfree(stat);
-		per_cpu(cpufreq_stats_table, cpu) = NULL;
-	}
+	if (!stat)
+		return;
+
+	pr_debug("%s: Free stat table\n", __func__);
+
+	sysfs_remove_group(&policy->kobj, &stats_attr_group);
+	kfree(stat->time_in_state);
+	kfree(stat);
+	per_cpu(cpufreq_stats_table, policy->cpu) = NULL;
 }
 
-/* must be called early in the CPU removal sequence (before
- * cpufreq_remove_dev) so that policy is still valid.
- */
-static void cpufreq_stats_free_sysfs(unsigned int cpu)
+static void cpufreq_stats_free_table(unsigned int cpu)
 {
-	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
+	struct cpufreq_policy *policy;
 
+	policy = cpufreq_cpu_get(cpu);
 	if (!policy)
 		return;
 
-	if (!cpufreq_frequency_get_table(cpu))
-		goto put_ref;
-
-	if (!policy_is_shared(policy)) {
-		pr_debug("%s: Free sysfs stat\n", __func__);
-		sysfs_remove_group(&policy->kobj, &stats_attr_group);
-	}
+	if (cpufreq_frequency_get_table(policy->cpu))
+		__cpufreq_stats_free_table(policy);
 
-put_ref:
 	cpufreq_cpu_put(policy);
 }
 
@@ -293,10 +285,8 @@ static int cpufreq_stat_notifier_policy(struct notifier_block *nb,
 
 	if (val == CPUFREQ_CREATE_POLICY)
 		ret = cpufreq_stats_create_table(policy, table);
-	else if (val == CPUFREQ_REMOVE_POLICY) {
-		cpufreq_stats_free_sysfs(cpu);
-		cpufreq_stats_free_table(cpu);
-	}
+	else if (val == CPUFREQ_REMOVE_POLICY)
+		__cpufreq_stats_free_table(policy);
 
 	return ret;
 }
@@ -376,10 +366,8 @@ static void __exit cpufreq_stats_exit(void)
 			CPUFREQ_POLICY_NOTIFIER);
 	cpufreq_unregister_notifier(&notifier_trans_block,
 			CPUFREQ_TRANSITION_NOTIFIER);
-	for_each_online_cpu(cpu) {
+	for_each_online_cpu(cpu)
 		cpufreq_stats_free_table(cpu);
-		cpufreq_stats_free_sysfs(cpu);
-	}
 }
 
 MODULE_AUTHOR("Zou Nan hai <nanhai.zou@intel.com>");

commit 027cc2e4a6127fdf29e17a422aacb5ecd9830cbb
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 7 07:10:11 2014 +0530

    cpufreq: stats: remove hotplug notifiers
    
    Either CPUs are hot-unplugged or suspend/resume occurs, cpufreq core
    will send notifications to cpufreq-stats and stats structure and sysfs
    entries would be correctly handled..
    
    And so we don't actually need hotcpu notifiers in cpufreq-stats anymore.
    We were only handling cpu hot-unplug events here and that are already
    taken care of by POLICY notifiers.
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Tested-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 0f7156252453..8fa58440ea95 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -294,11 +294,8 @@ static int cpufreq_stat_notifier_policy(struct notifier_block *nb,
 	if (val == CPUFREQ_CREATE_POLICY)
 		ret = cpufreq_stats_create_table(policy, table);
 	else if (val == CPUFREQ_REMOVE_POLICY) {
-		/* This might already be freed by cpu hotplug notifier */
-		if (per_cpu(cpufreq_stats_table, cpu)) {
-			cpufreq_stats_free_sysfs(cpu);
-			cpufreq_stats_free_table(cpu);
-		}
+		cpufreq_stats_free_sysfs(cpu);
+		cpufreq_stats_free_table(cpu);
 	}
 
 	return ret;
@@ -340,33 +337,6 @@ static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
 	return 0;
 }
 
-static int cpufreq_stat_cpu_callback(struct notifier_block *nfb,
-					       unsigned long action,
-					       void *hcpu)
-{
-	unsigned int cpu = (unsigned long)hcpu;
-
-	/* Don't free/allocate stats during suspend/resume */
-	if (action & CPU_TASKS_FROZEN)
-		return 0;
-
-	switch (action) {
-	case CPU_DOWN_PREPARE:
-		cpufreq_stats_free_sysfs(cpu);
-		break;
-	case CPU_DEAD:
-		cpufreq_stats_free_table(cpu);
-		break;
-	}
-	return NOTIFY_OK;
-}
-
-/* priority=1 so this will get called before cpufreq_remove_dev */
-static struct notifier_block cpufreq_stat_cpu_notifier __refdata = {
-	.notifier_call = cpufreq_stat_cpu_callback,
-	.priority = 1,
-};
-
 static struct notifier_block notifier_policy_block = {
 	.notifier_call = cpufreq_stat_notifier_policy
 };
@@ -386,14 +356,11 @@ static int __init cpufreq_stats_init(void)
 	if (ret)
 		return ret;
 
-	register_hotcpu_notifier(&cpufreq_stat_cpu_notifier);
-
 	ret = cpufreq_register_notifier(&notifier_trans_block,
 				CPUFREQ_TRANSITION_NOTIFIER);
 	if (ret) {
 		cpufreq_unregister_notifier(&notifier_policy_block,
 				CPUFREQ_POLICY_NOTIFIER);
-		unregister_hotcpu_notifier(&cpufreq_stat_cpu_notifier);
 		for_each_online_cpu(cpu)
 			cpufreq_stats_free_table(cpu);
 		return ret;
@@ -409,7 +376,6 @@ static void __exit cpufreq_stats_exit(void)
 			CPUFREQ_POLICY_NOTIFIER);
 	cpufreq_unregister_notifier(&notifier_trans_block,
 			CPUFREQ_TRANSITION_NOTIFIER);
-	unregister_hotcpu_notifier(&cpufreq_stat_cpu_notifier);
 	for_each_online_cpu(cpu) {
 		cpufreq_stats_free_table(cpu);
 		cpufreq_stats_free_sysfs(cpu);

commit fcd7af917abba798cd954419030142e95139359f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 7 07:10:10 2014 +0530

    cpufreq: stats: handle cpufreq_unregister_driver() and suspend/resume properly
    
    There are several problems with cpufreq stats in the way it handles
    cpufreq_unregister_driver() and suspend/resume..
    
     - We must not lose data collected so far when suspend/resume happens
       and so stats directories must not be removed/allocated during these
       operations, which is done currently.
    
     - cpufreq_stat has registered notifiers with both cpufreq and hotplug.
       It adds sysfs stats directory with a cpufreq notifier: CPUFREQ_NOTIFY
       and removes this directory with a notifier from hotplug core.
    
       In case cpufreq_unregister_driver() is called (on rmmod cpufreq driver),
       stats directories per cpu aren't removed as CPUs are still online. The
       only call cpufreq_stats gets is cpufreq_stats_update_policy_cpu() for
       all CPUs except the last of each policy. And pointer to stat information
       is stored in the entry for last CPU in the per-cpu cpufreq_stats_table.
       But policy structure would be freed inside cpufreq core and so that will
       result in memory leak inside cpufreq stats (as we are never freeing
       memory for stats).
    
       Now if we again insert the module cpufreq_register_driver() will be
       called and we will again allocate stats data and put it on for first
       CPU of every policy.  In case we only have a single CPU per policy, we
       will return with a error from cpufreq_stats_create_table() due to this
       code:
    
            if (per_cpu(cpufreq_stats_table, cpu))
                    return -EBUSY;
    
       And so probably cpufreq stats directory would not show up anymore (as
       it was added inside last policies->kobj which doesn't exist anymore).
       I haven't tested it, though. Also the values in stats files wouldn't
       be refreshed as we are using the earlier stats structure.
    
     - CPUFREQ_NOTIFY is called from cpufreq_set_policy() which is called for
       scenarios where we don't really want cpufreq_stat_notifier_policy() to get
       called. For example whenever we are changing anything related to a policy:
       min/max/current freq, etc. cpufreq_set_policy() is called and so cpufreq
       stats is notified. Where we don't do any useful stuff other than simply
       returning with -EBUSY from cpufreq_stats_create_table(). And so this
       isn't the right notifier that cpufreq stats..
    
     Due to all above reasons this patch does following changes:
     - Add new notifiers CPUFREQ_CREATE_POLICY and CPUFREQ_REMOVE_POLICY,
       which are only called when policy is created/destroyed. They aren't
       called for suspend/resume paths..
     - Use these notifiers in cpufreq_stat_notifier_policy() to create/destory
       stats sysfs entries. And so cpufreq_unregister_driver() or suspend/resume
       shouldn't be a problem for cpufreq_stats.
     - Return early from cpufreq_stat_cpu_callback() for suspend/resume sequence,
       so that we don't free stats structure.
    
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Tested-by: Nicolas Pitre <nico@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 4cf0d2805cb2..0f7156252453 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -277,7 +277,7 @@ static void cpufreq_stats_update_policy_cpu(struct cpufreq_policy *policy)
 static int cpufreq_stat_notifier_policy(struct notifier_block *nb,
 		unsigned long val, void *data)
 {
-	int ret;
+	int ret = 0;
 	struct cpufreq_policy *policy = data;
 	struct cpufreq_frequency_table *table;
 	unsigned int cpu = policy->cpu;
@@ -287,15 +287,21 @@ static int cpufreq_stat_notifier_policy(struct notifier_block *nb,
 		return 0;
 	}
 
-	if (val != CPUFREQ_NOTIFY)
-		return 0;
 	table = cpufreq_frequency_get_table(cpu);
 	if (!table)
 		return 0;
-	ret = cpufreq_stats_create_table(policy, table);
-	if (ret)
-		return ret;
-	return 0;
+
+	if (val == CPUFREQ_CREATE_POLICY)
+		ret = cpufreq_stats_create_table(policy, table);
+	else if (val == CPUFREQ_REMOVE_POLICY) {
+		/* This might already be freed by cpu hotplug notifier */
+		if (per_cpu(cpufreq_stats_table, cpu)) {
+			cpufreq_stats_free_sysfs(cpu);
+			cpufreq_stats_free_table(cpu);
+		}
+	}
+
+	return ret;
 }
 
 static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
@@ -340,6 +346,10 @@ static int cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 {
 	unsigned int cpu = (unsigned long)hcpu;
 
+	/* Don't free/allocate stats during suspend/resume */
+	if (action & CPU_TASKS_FROZEN)
+		return 0;
+
 	switch (action) {
 	case CPU_DOWN_PREPARE:
 		cpufreq_stats_free_sysfs(cpu);

commit a857c0b9e24e39fe5be82451b65377795f9538d8
Author: Andreas Schwab <schwab@linux-m68k.org>
Date:   Sat Sep 7 18:35:08 2013 +0200

    cpufreq: Fix wrong time unit conversion
    
    The time spent by a CPU under a given frequency is stored in jiffies unit
    in the cpu var cpufreq_stats_table->time_in_state[i], i being the index of
    the frequency.
    
    This is what is displayed in the following file on the right column:
    
         cat /sys/devices/system/cpu/cpuX/cpufreq/stats/time_in_state
         2301000 19835820
         2300000 3172
         [...]
    
    Now cpufreq converts this jiffies unit delta to clock_t before returning it
    to the user as in the above file. And that conversion is achieved using the API
    cputime64_to_clock_t().
    
    Although it accidentally works on traditional tick based cputime accounting, where
    cputime_t maps directly to jiffies, it doesn't work with other types of cputime
    accounting such as CONFIG_VIRT_CPU_ACCOUNTING_* where cputime_t can map to nsecs
    or any granularity preffered by the architecture.
    
    For example we get a buggy zero delta on full dyntick configurations:
    
         cat /sys/devices/system/cpu/cpuX/cpufreq/stats/time_in_state
         2301000 0
         2300000 0
         [...]
    
    Fix this with using the proper jiffies_64_t to clock_t conversion.
    
    Reported-and-tested-by: Carsten Emde <C.Emde@osadl.org>
    Signed-off-by: Andreas Schwab <schwab@linux-m68k.org>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 04452f026ed0..4cf0d2805cb2 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -74,7 +74,7 @@ static ssize_t show_time_in_state(struct cpufreq_policy *policy, char *buf)
 	for (i = 0; i < stat->state_num; i++) {
 		len += sprintf(buf + len, "%u %llu\n", stat->freq_table[i],
 			(unsigned long long)
-			cputime64_to_clock_t(stat->time_in_state[i]));
+			jiffies_64_to_clock_t(stat->time_in_state[i]));
 	}
 	return len;
 }

commit d5b73cd870e2b049ef566aec2791dbf5fd26a7ec
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Aug 6 22:53:06 2013 +0530

    cpufreq: Use sizeof(*ptr) convetion for computing sizes
    
    Chapter 14 of Documentation/CodingStyle says:
    
    The preferred form for passing a size of a struct is the following:
    
            p = kmalloc(sizeof(*p), ...);
    
    The alternative form where struct name is spelled out hurts
    readability and introduces an opportunity for a bug when the pointer
    variable type is changed but the corresponding sizeof that is passed
    to a memory allocator is not.
    
    This wasn't followed consistently in drivers/cpufreq, let's make it
    more consistent by always following this rule.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index a17b14ee37d8..04452f026ed0 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -198,7 +198,7 @@ static int cpufreq_stats_create_table(struct cpufreq_policy *policy,
 	unsigned int cpu = policy->cpu;
 	if (per_cpu(cpufreq_stats_table, cpu))
 		return -EBUSY;
-	stat = kzalloc(sizeof(struct cpufreq_stats), GFP_KERNEL);
+	stat = kzalloc(sizeof(*stat), GFP_KERNEL);
 	if ((stat) == NULL)
 		return -ENOMEM;
 

commit 3a3e9e06d0c11b8efa95933a88c9e67209fa4330
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Aug 6 22:53:05 2013 +0530

    cpufreq: Give consistent names to cpufreq_policy objects
    
    They are called policy, cur_policy, new_policy, data, etc.  Just call
    them policy wherever possible.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index a7143b0597af..a17b14ee37d8 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -193,7 +193,7 @@ static int cpufreq_stats_create_table(struct cpufreq_policy *policy,
 {
 	unsigned int i, j, count = 0, ret = 0;
 	struct cpufreq_stats *stat;
-	struct cpufreq_policy *data;
+	struct cpufreq_policy *current_policy;
 	unsigned int alloc_size;
 	unsigned int cpu = policy->cpu;
 	if (per_cpu(cpufreq_stats_table, cpu))
@@ -202,13 +202,13 @@ static int cpufreq_stats_create_table(struct cpufreq_policy *policy,
 	if ((stat) == NULL)
 		return -ENOMEM;
 
-	data = cpufreq_cpu_get(cpu);
-	if (data == NULL) {
+	current_policy = cpufreq_cpu_get(cpu);
+	if (current_policy == NULL) {
 		ret = -EINVAL;
 		goto error_get_fail;
 	}
 
-	ret = sysfs_create_group(&data->kobj, &stats_attr_group);
+	ret = sysfs_create_group(&current_policy->kobj, &stats_attr_group);
 	if (ret)
 		goto error_out;
 
@@ -251,10 +251,10 @@ static int cpufreq_stats_create_table(struct cpufreq_policy *policy,
 	stat->last_time = get_jiffies_64();
 	stat->last_index = freq_table_get_index(stat, policy->cur);
 	spin_unlock(&cpufreq_stats_lock);
-	cpufreq_cpu_put(data);
+	cpufreq_cpu_put(current_policy);
 	return 0;
 error_out:
-	cpufreq_cpu_put(data);
+	cpufreq_cpu_put(current_policy);
 error_get_fail:
 	kfree(stat);
 	per_cpu(cpufreq_stats_table, cpu) = NULL;

commit 5ff0a268037d344f86df690ccb994d8bc015d2d9
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Aug 6 22:53:03 2013 +0530

    cpufreq: Clean up header files included in the core
    
    This patch addresses the following issues in the header files in the
    cpufreq core:
     - Include headers in ascending order, so that we don't add same
       many times by mistake.
     - <asm/> must be included after <linux/>, so that they override
       whatever they need to.
     - Remove unnecessary includes.
     - Don't include files already included by cpufreq.h or
       cpufreq_governor.h.
    
    [rjw: Changelog]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index cb3841355454..a7143b0597af 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -9,17 +9,10 @@
  * published by the Free Software Foundation.
  */
 
-#include <linux/kernel.h>
-#include <linux/slab.h>
 #include <linux/cpu.h>
-#include <linux/sysfs.h>
 #include <linux/cpufreq.h>
 #include <linux/module.h>
-#include <linux/jiffies.h>
-#include <linux/percpu.h>
-#include <linux/kobject.h>
-#include <linux/spinlock.h>
-#include <linux/notifier.h>
+#include <linux/slab.h>
 #include <asm/cputime.h>
 
 static spinlock_t cpufreq_stats_lock;

commit 5302c3fb2e62f4ca5e43e060491ba299f58c5231
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Tue Jul 30 04:25:25 2013 +0530

    cpufreq: Perform light-weight init/teardown during suspend/resume
    
    Now that we have the infrastructure to perform a light-weight init/tear-down,
    use that in the cpufreq CPU hotplug notifier when invoked from the
    suspend/resume path.
    
    This also ensures that the file permissions of the cpufreq sysfs files are
    preserved across suspend/resume, something which commit a66b2e (cpufreq:
    Preserve sysfs files across suspend/resume) originally intended to do, but
    had to be reverted due to other problems.
    
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index bc73be225be5..cb3841355454 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -349,11 +349,9 @@ static int cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 
 	switch (action) {
 	case CPU_DOWN_PREPARE:
-	case CPU_DOWN_PREPARE_FROZEN:
 		cpufreq_stats_free_sysfs(cpu);
 		break;
 	case CPU_DEAD:
-	case CPU_DEAD_FROZEN:
 		cpufreq_stats_free_table(cpu);
 		break;
 	}

commit 23d328994b548d6822b88fe7e1903652afc354e0
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Tue Jul 30 04:23:56 2013 +0530

    cpufreq: Fix misplaced call to cpufreq_update_policy()
    
    The call to cpufreq_update_policy() is placed in the CPU hotplug callback
    of cpufreq_stats, which has a higher priority than the CPU hotplug callback
    of cpufreq-core. As a result, during CPU_ONLINE/CPU_ONLINE_FROZEN, we end up
    calling cpufreq_update_policy() *before* calling cpufreq_add_dev() !
    And for uninitialized CPUs, it just returns silently, not doing anything.
    
    To add to that, cpufreq_stats is not even the right place to call
    cpufreq_update_policy() to begin with. The cpufreq core ought to handle
    this in its own callback, from an elegance/relevance perspective.
    
    So move the invocation of cpufreq_update_policy() to cpufreq_cpu_callback,
    and place it *after* cpufreq_add_dev().
    
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index d37568c5ca9c..bc73be225be5 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -348,10 +348,6 @@ static int cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 	unsigned int cpu = (unsigned long)hcpu;
 
 	switch (action) {
-	case CPU_ONLINE:
-	case CPU_ONLINE_FROZEN:
-		cpufreq_update_policy(cpu);
-		break;
 	case CPU_DOWN_PREPARE:
 	case CPU_DOWN_PREPARE_FROZEN:
 		cpufreq_stats_free_sysfs(cpu);
@@ -390,8 +386,6 @@ static int __init cpufreq_stats_init(void)
 		return ret;
 
 	register_hotcpu_notifier(&cpufreq_stat_cpu_notifier);
-	for_each_online_cpu(cpu)
-		cpufreq_update_policy(cpu);
 
 	ret = cpufreq_register_notifier(&notifier_trans_block,
 				CPUFREQ_TRANSITION_NOTIFIER);

commit b7356abb9fb952d385caef6d58d7e7aff17a478e
Merge: ecb2cf1a6b63 5a8d28155930
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 19 09:59:06 2013 -0700

    Merge tag 'pm+acpi-3.11-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management and ACPI fixes from Rafael Wysocki:
     "These are fixes collected over the last week, most importnatly two
      cpufreq reverts fixing regressions introduced in 3.10, an autoseelp
      fix preventing systems using it from crashing during shutdown and two
      ACPI scan fixes related to hotplug.
    
      Specifics:
    
       - Two cpufreq commits from the 3.10 cycle introduced regressions.
         The first of them was buggy (it did way much more than it needed to
         do) and the second one attempted to fix an issue introduced by the
         first one.  Fixes from Srivatsa S Bhat revert both.
    
       - If autosleep triggers during system shutdown and the shutdown
         callbacks of some device drivers have been called already, it may
         crash the system.  Fix from Liu Shuo prevents that from happening
         by making try_to_suspend() check system_state.
    
       - The ACPI memory hotplug driver doesn't clear its driver_data on
         errors which may cause a NULL poiter dereference to happen later.
         Fix from Toshi Kani.
    
       - The ACPI namespace scanning code should not try to attach scan
         handlers to device objects that have them already, which may
         confuse things quite a bit, and it should rescan the whole
         namespace branch starting at the given node after receiving a bus
         check notify event even if the device at that particular node has
         been discovered already.  Fixes from Rafael J Wysocki.
    
       - New ACPI video blacklist entry for a system whose initial backlight
         setting from the BIOS doesn't make sense.  From Lan Tianyu.
    
       - Garbage string output avoindance for ACPI PNP from Liu Shuo.
    
       - Two Kconfig fixes for issues introduced recently in the s3c24xx
         cpufreq driver (when moving the driver to drivers/cpufreq) from
         Paul Bolle.
    
       - Trivial comment fix in pm_wakeup.h from Chanwoo Choi"
    
    * tag 'pm+acpi-3.11-rc2' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      ACPI / video: ignore BIOS initial backlight value for Fujitsu E753
      PNP / ACPI: avoid garbage in resource name
      cpufreq: Revert commit 2f7021a8 to fix CPU hotplug regression
      cpufreq: s3c24xx: fix "depends on ARM_S3C24XX" in Kconfig
      cpufreq: s3c24xx: rename CONFIG_CPU_FREQ_S3C24XX_DEBUGFS
      PM / Sleep: Fix comment typo in pm_wakeup.h
      PM / Sleep: avoid 'autosleep' in shutdown progress
      cpufreq: Revert commit a66b2e to fix suspend/resume regression
      ACPI / memhotplug: Fix a stale pointer in error path
      ACPI / scan: Always call acpi_bus_scan() for bus check notifications
      ACPI / scan: Do not try to attach scan handlers to devices having them

commit 2760984f6578d5a462155bb4727766d0c8b68387
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jun 19 13:54:04 2013 -0400

    cpufreq: delete __cpuinit usage from all cpufreq files
    
    The __cpuinit type of throwaway sections might have made sense
    some time ago when RAM was more constrained, but now the savings
    do not offset the cost and complications.  For example, the fix in
    commit 5e427ec2d0 ("x86: Fix bit corruption at CPU resume time")
    is a good example of the nasty type of bugs that can be created
    with improper use of the various __init prefixes.
    
    After a discussion on LKML[1] it was decided that cpuinit should go
    the way of devinit and be phased out.  Once all the users are gone,
    we can then finally remove the macros themselves from linux/init.h.
    
    This removes all the drivers/cpufreq uses of the __cpuinit macros
    from all C files.
    
    [1] https://lkml.org/lkml/2013/5/20/589
    
    [v2: leave 2nd lines of args misaligned as requested by Viresh]
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: cpufreq@vger.kernel.org
    Cc: linux-pm@vger.kernel.org
    Acked-by: Dirk Brandewie <dirk.j.brandewie@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index cd9e81713a71..c1ec11c513c1 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -341,7 +341,7 @@ static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
 	return 0;
 }
 
-static int __cpuinit cpufreq_stat_cpu_callback(struct notifier_block *nfb,
+static int cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 					       unsigned long action,
 					       void *hcpu)
 {

commit aae760ed21cd690fe8a6db9f3a177ad55d7e12ab
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Fri Jul 12 03:45:37 2013 +0530

    cpufreq: Revert commit a66b2e to fix suspend/resume regression
    
    commit a66b2e (cpufreq: Preserve sysfs files across suspend/resume)
    has unfortunately caused several things in the cpufreq subsystem to
    break subtly after a suspend/resume cycle.
    
    The intention of that patch was to retain the file permissions of the
    cpufreq related sysfs files across suspend/resume.  To achieve that,
    the commit completely removed the calls to cpufreq_add_dev() and
    __cpufreq_remove_dev() during suspend/resume transitions.  But the
    problem is that those functions do 2 kinds of things:
      1. Low-level initialization/tear-down that are critical to the
         correct functioning of cpufreq-core.
      2. Kobject and sysfs related initialization/teardown.
    
    Ideally we should have reorganized the code to cleanly separate these
    two responsibilities, and skipped only the sysfs related parts during
    suspend/resume.  Since we skipped the entire callbacks instead (which
    also included some CPU and cpufreq-specific critical components),
    cpufreq subsystem started behaving erratically after suspend/resume.
    
    So revert the commit to fix the regression.  We'll revisit and address
    the original goal of that commit separately, since it involves quite a
    bit of careful code reorganization and appears to be non-trivial.
    
    (While reverting the commit, note that another commit f51e1eb
     (cpufreq: Fix cpufreq regression after suspend/resume) already
     reverted part of the original set of changes.  So revert only the
     remaining ones).
    
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Paul Bolle <pebolle@tiscali.nl>
    Cc: 3.10+ <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index cd9e81713a71..12225d19ffcb 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -353,13 +353,11 @@ static int __cpuinit cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 		cpufreq_update_policy(cpu);
 		break;
 	case CPU_DOWN_PREPARE:
+	case CPU_DOWN_PREPARE_FROZEN:
 		cpufreq_stats_free_sysfs(cpu);
 		break;
 	case CPU_DEAD:
-		cpufreq_stats_free_table(cpu);
-		break;
-	case CPU_UP_CANCELED_FROZEN:
-		cpufreq_stats_free_sysfs(cpu);
+	case CPU_DEAD_FROZEN:
 		cpufreq_stats_free_table(cpu);
 		break;
 	}

commit f51e1eb63d9c28cec188337ee656a13be6980cfd
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Mon Jul 1 00:40:55 2013 +0200

    cpufreq: Fix cpufreq regression after suspend/resume
    
    Toralf Frster reported that the cpufreq ondemand governor behaves erratically
    (doesn't scale well) after a suspend/resume cycle. The problem was that the
    cpufreq subsystem's idea of the cpu frequencies differed from the actual
    frequencies set in the hardware after a suspend/resume cycle. Toralf bisected
    the problem to commit a66b2e5 (cpufreq: Preserve sysfs files across
    suspend/resume).
    
    Among other (harmless) things, that commit skipped the call to
    cpufreq_update_policy() in the resume path. But cpufreq_update_policy() plays
    an important role during resume, because it is responsible for checking if
    the BIOS changed the cpu frequencies behind our back and resynchronize the
    cpufreq subsystem's knowledge of the cpu frequencies, and update them
    accordingly.
    
    So, restore the call to cpufreq_update_policy() in the resume path to fix
    the cpufreq regression.
    
    Reported-and-tested-by: Toralf Frster <toralf.foerster@gmx.de>
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Cc: 3.10+ <stable@vger.kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 6d35caa91167..cd9e81713a71 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -349,6 +349,7 @@ static int __cpuinit cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 
 	switch (action) {
 	case CPU_ONLINE:
+	case CPU_ONLINE_FROZEN:
 		cpufreq_update_policy(cpu);
 		break;
 	case CPU_DOWN_PREPARE:

commit bb176f7d038fee4d46b3293e64e173bfb05ab7b5
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jun 19 14:19:33 2013 +0530

    cpufreq: Fix minor formatting issues
    
    There were a few noticeable formatting issues in core cpufreq code.
    This cleans them up to make code look better.  The changes include:
     - Whitespace cleanup.
     - Rearrangements of code.
     - Multiline comments fixes.
     - Formatting changes to fit 80 columns.
    
    Copyright information in cpufreq.c is also updated to include my name
    for 2013.
    
    [rjw: Changelog]
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index fb65decffa28..6d35caa91167 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -27,7 +27,7 @@ static spinlock_t cpufreq_stats_lock;
 struct cpufreq_stats {
 	unsigned int cpu;
 	unsigned int total_trans;
-	unsigned long long  last_time;
+	unsigned long long last_time;
 	unsigned int max_state;
 	unsigned int state_num;
 	unsigned int last_index;
@@ -116,7 +116,7 @@ static ssize_t show_trans_table(struct cpufreq_policy *policy, char *buf)
 		len += snprintf(buf + len, PAGE_SIZE - len, "%9u: ",
 				stat->freq_table[i]);
 
-		for (j = 0; j < stat->state_num; j++)   {
+		for (j = 0; j < stat->state_num; j++) {
 			if (len >= PAGE_SIZE)
 				break;
 			len += snprintf(buf + len, PAGE_SIZE - len, "%9u ",

commit a66b2e503fc79fff6632d02ef5a0ee47c1d2553d
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Wed May 15 21:47:17 2013 +0200

    cpufreq: Preserve sysfs files across suspend/resume
    
    The file permissions of cpufreq per-cpu sysfs files are not preserved
    across suspend/resume because we internally go through the CPU
    Hotplug path which reinitializes the file permissions on CPU online.
    
    But the user is not supposed to know that we are using CPU hotplug
    internally within suspend/resume (IOW, the kernel should not silently
    wreck the user-set file permissions across a suspend cycle).
    Therefore, we need to preserve the file permissions as they are
    across suspend/resume.
    
    The simplest way to achieve that is to just not touch the sysfs files
    at all - ie., just ignore the CPU hotplug notifications in the
    suspend/resume path (_FROZEN) in the cpufreq hotplug callback.
    
    Reported-by: Robert Jarzmik <robert.jarzmik@intel.com>
    Reported-by: Durgadoss R <durgadoss.r@intel.com>
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index bfd6273fd873..fb65decffa28 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -349,15 +349,16 @@ static int __cpuinit cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 
 	switch (action) {
 	case CPU_ONLINE:
-	case CPU_ONLINE_FROZEN:
 		cpufreq_update_policy(cpu);
 		break;
 	case CPU_DOWN_PREPARE:
-	case CPU_DOWN_PREPARE_FROZEN:
 		cpufreq_stats_free_sysfs(cpu);
 		break;
 	case CPU_DEAD:
-	case CPU_DEAD_FROZEN:
+		cpufreq_stats_free_table(cpu);
+		break;
+	case CPU_UP_CANCELED_FROZEN:
+		cpufreq_stats_free_sysfs(cpu);
 		cpufreq_stats_free_table(cpu);
 		break;
 	}

commit 187da1d97f3a949b967274d7ee2f95d3a4f39251
Author: viresh kumar <viresh.kumar@linaro.org>
Date:   Fri Mar 22 10:13:52 2013 +0000

    cpufreq: stats: do cpufreq_cpu_put() corresponding to cpufreq_cpu_get()
    
    In cpufreq_stats_free_sysfs() we aren't balancing calls to
    cpufreq_cpu_get() with cpufreq_cpu_put(). This will never let us have
    ref count to policy->kobj as zero.
    
    We will get a hang if somehow cpufreq_driver_unregister() is called.
    And that can happen when we compile our driver as module and
    insmod/rmmod it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Amit Kucheria <amit.kucheria@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 2fd779eb1ed1..bfd6273fd873 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -180,15 +180,19 @@ static void cpufreq_stats_free_sysfs(unsigned int cpu)
 {
 	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
 
-	if (!cpufreq_frequency_get_table(cpu))
+	if (!policy)
 		return;
 
-	if (policy && !policy_is_shared(policy)) {
+	if (!cpufreq_frequency_get_table(cpu))
+		goto put_ref;
+
+	if (!policy_is_shared(policy)) {
 		pr_debug("%s: Free sysfs stat\n", __func__);
 		sysfs_remove_group(&policy->kobj, &stats_attr_group);
 	}
-	if (policy)
-		cpufreq_cpu_put(policy);
+
+put_ref:
+	cpufreq_cpu_put(policy);
 }
 
 static int cpufreq_stats_create_table(struct cpufreq_policy *policy,

commit 633d47d653f3a717fb68293d24ab7059c480f71b
Author: Dirk Brandewie <dirk.brandewie@gmail.com>
Date:   Wed Feb 6 09:02:12 2013 -0800

    cpufreq_stats: do not remove sysfs files if frequency table is not present
    
    The sysfs files for cpufreq_stats are created in cpufreq_stats_create_table()
    called from cpufreq_stat_notifier_policy() when a policy is added to
    the cpu. cpufreq_stats_create_table() will not be called if the
    scaling driver does not export a frequency table to cpufreq.  Use the
    same fence on tear down.
    
    Signed-off-by: Dirk Brandewie <dirk.j.brandewie@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index a2dee4cedf41..2fd779eb1ed1 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -179,6 +179,10 @@ static void cpufreq_stats_free_table(unsigned int cpu)
 static void cpufreq_stats_free_sysfs(unsigned int cpu)
 {
 	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
+
+	if (!cpufreq_frequency_get_table(cpu))
+		return;
+
 	if (policy && !policy_is_shared(policy)) {
 		pr_debug("%s: Free sysfs stat\n", __func__);
 		sysfs_remove_group(&policy->kobj, &stats_attr_group);

commit df18e504aa5db8e7263c91e153c27c6f895da3c7
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Feb 4 11:38:52 2013 +0000

    cpufreq / stats: Get rid of CPUFREQ_STATDEVICE_ATTR
    
    Macro "CPUFREQ_STATDEVICE_ATTR" is defined local to cpufreq_stats.c file and is
    almost a copy of the generic version present in cpufreq.h file. Lets use the
    generic version instead.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 572124c6e36b..a2dee4cedf41 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -24,12 +24,6 @@
 
 static spinlock_t cpufreq_stats_lock;
 
-#define CPUFREQ_STATDEVICE_ATTR(_name, _mode, _show) \
-static struct freq_attr _attr_##_name = {\
-	.attr = {.name = __stringify(_name), .mode = _mode, }, \
-	.show = _show,\
-};
-
 struct cpufreq_stats {
 	unsigned int cpu;
 	unsigned int total_trans;
@@ -136,17 +130,17 @@ static ssize_t show_trans_table(struct cpufreq_policy *policy, char *buf)
 		return PAGE_SIZE;
 	return len;
 }
-CPUFREQ_STATDEVICE_ATTR(trans_table, 0444, show_trans_table);
+cpufreq_freq_attr_ro(trans_table);
 #endif
 
-CPUFREQ_STATDEVICE_ATTR(total_trans, 0444, show_total_trans);
-CPUFREQ_STATDEVICE_ATTR(time_in_state, 0444, show_time_in_state);
+cpufreq_freq_attr_ro(total_trans);
+cpufreq_freq_attr_ro(time_in_state);
 
 static struct attribute *default_attrs[] = {
-	&_attr_total_trans.attr,
-	&_attr_time_in_state.attr,
+	&total_trans.attr,
+	&time_in_state.attr,
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
-	&_attr_trans_table.attr,
+	&trans_table.attr,
 #endif
 	NULL
 };

commit 2624f90c16413990ecb0414400174a066319a9f5
Author: Fabio Baltieri <fabio.baltieri@linaro.org>
Date:   Thu Jan 31 09:44:40 2013 +0000

    cpufreq: governors: implement generic policy_is_shared
    
    Implement a generic helper function policy_is_shared() to replace the
    current dbs_sw_coordinated_cpus() at cpufreq level, so that it can be
    used by code other than cpufreq governors.
    
    Suggested-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Fabio Baltieri <fabio.baltieri@linaro.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index beef6b54382b..572124c6e36b 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -185,7 +185,7 @@ static void cpufreq_stats_free_table(unsigned int cpu)
 static void cpufreq_stats_free_sysfs(unsigned int cpu)
 {
 	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
-	if (policy && (cpumask_weight(policy->cpus) == 1)) {
+	if (policy && !policy_is_shared(policy)) {
 		pr_debug("%s: Free sysfs stat\n", __func__);
 		sysfs_remove_group(&policy->kobj, &stats_attr_group);
 	}

commit b8eed8af94f9203e0cc39245ea335f4b8dc1ed31
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jan 14 13:23:03 2013 +0000

    cpufreq: Simplify __cpufreq_remove_dev()
    
    __cpufreq_remove_dev() is called on multiple occasions: cpufreq_driver
    unregister and cpu removals.
    
    Current implementation of this routine is overly complex without much need. If
    the cpu to be removed is the policy->cpu, we remove the policy first and add all
    other cpus again from policy->cpus and then finally call __cpufreq_remove_dev()
    again to remove the cpu to be deleted. Haahhhh..
    
    There exist a simple solution to removal of a cpu:
    - Simply use the old policy structure
    - update its fields like: policy->cpu, etc.
    - notify any users of cpufreq, which depend on changing policy->cpu
    
    Hence this patch, which tries to implement the above theory. It is tested well
    by myself on ARM big.LITTLE TC2 SoC, which has 5 cores (2 A15 and 3 A7). Both
    A15's share same struct policy and all A7's share same policy structure.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 9d7732b81044..beef6b54382b 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -170,11 +170,13 @@ static int freq_table_get_index(struct cpufreq_stats *stat, unsigned int freq)
 static void cpufreq_stats_free_table(unsigned int cpu)
 {
 	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, cpu);
+
 	if (stat) {
+		pr_debug("%s: Free stat table\n", __func__);
 		kfree(stat->time_in_state);
 		kfree(stat);
+		per_cpu(cpufreq_stats_table, cpu) = NULL;
 	}
-	per_cpu(cpufreq_stats_table, cpu) = NULL;
 }
 
 /* must be called early in the CPU removal sequence (before
@@ -183,8 +185,10 @@ static void cpufreq_stats_free_table(unsigned int cpu)
 static void cpufreq_stats_free_sysfs(unsigned int cpu)
 {
 	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
-	if (policy && policy->cpu == cpu)
+	if (policy && (cpumask_weight(policy->cpus) == 1)) {
+		pr_debug("%s: Free sysfs stat\n", __func__);
 		sysfs_remove_group(&policy->kobj, &stats_attr_group);
+	}
 	if (policy)
 		cpufreq_cpu_put(policy);
 }
@@ -262,6 +266,19 @@ static int cpufreq_stats_create_table(struct cpufreq_policy *policy,
 	return ret;
 }
 
+static void cpufreq_stats_update_policy_cpu(struct cpufreq_policy *policy)
+{
+	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table,
+			policy->last_cpu);
+
+	pr_debug("Updating stats_table for new_cpu %u from last_cpu %u\n",
+			policy->cpu, policy->last_cpu);
+	per_cpu(cpufreq_stats_table, policy->cpu) = per_cpu(cpufreq_stats_table,
+			policy->last_cpu);
+	per_cpu(cpufreq_stats_table, policy->last_cpu) = NULL;
+	stat->cpu = policy->cpu;
+}
+
 static int cpufreq_stat_notifier_policy(struct notifier_block *nb,
 		unsigned long val, void *data)
 {
@@ -269,6 +286,12 @@ static int cpufreq_stat_notifier_policy(struct notifier_block *nb,
 	struct cpufreq_policy *policy = data;
 	struct cpufreq_frequency_table *table;
 	unsigned int cpu = policy->cpu;
+
+	if (val == CPUFREQ_UPDATE_POLICY_CPU) {
+		cpufreq_stats_update_policy_cpu(policy);
+		return 0;
+	}
+
 	if (val != CPUFREQ_NOTIFY)
 		return 0;
 	table = cpufreq_frequency_get_table(cpu);

commit 56836fb4dab8fe906b934b231b04c33c180f8da5
Author: Konstantin Khlebnikov <khlebnikov@openvz.org>
Date:   Sat Dec 15 00:22:02 2012 +0100

    cpufreq / stats: fix race between stats allocation and first usage
    
    This patch forces complete struct cpufreq_stats allocation for all cpus before
    registering CPUFREQ_TRANSITION_NOTIFIER notifier, otherwise in some conditions
    cpufreq_stat_notifier_trans() can be called in the middle of stats allocation,
    in this case cpufreq_stats_table already exists, but stat->freq_table is NULL.
    
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@openvz.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index e40e50809644..9d7732b81044 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -364,18 +364,21 @@ static int __init cpufreq_stats_init(void)
 	if (ret)
 		return ret;
 
+	register_hotcpu_notifier(&cpufreq_stat_cpu_notifier);
+	for_each_online_cpu(cpu)
+		cpufreq_update_policy(cpu);
+
 	ret = cpufreq_register_notifier(&notifier_trans_block,
 				CPUFREQ_TRANSITION_NOTIFIER);
 	if (ret) {
 		cpufreq_unregister_notifier(&notifier_policy_block,
 				CPUFREQ_POLICY_NOTIFIER);
+		unregister_hotcpu_notifier(&cpufreq_stat_cpu_notifier);
+		for_each_online_cpu(cpu)
+			cpufreq_stats_free_table(cpu);
 		return ret;
 	}
 
-	register_hotcpu_notifier(&cpufreq_stat_cpu_notifier);
-	for_each_online_cpu(cpu) {
-		cpufreq_update_policy(cpu);
-	}
 	return 0;
 }
 static void __exit cpufreq_stats_exit(void)

commit 1e7586a18a2ab69a160837c0a4be31f7147cfb5e
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Oct 26 00:51:21 2012 +0200

    cpufreq: Fix sparse warnings by updating cputime64_t to u64
    
    There were few sparse warnings due to mismatch of type on function arguments.
    Two types were used u64 and cputime64_t. Both are actually u64, so use u64 only.
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 399831690fed..e40e50809644 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -37,7 +37,7 @@ struct cpufreq_stats {
 	unsigned int max_state;
 	unsigned int state_num;
 	unsigned int last_index;
-	cputime64_t *time_in_state;
+	u64 *time_in_state;
 	unsigned int *freq_table;
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 	unsigned int *trans_table;
@@ -223,7 +223,7 @@ static int cpufreq_stats_create_table(struct cpufreq_policy *policy,
 		count++;
 	}
 
-	alloc_size = count * sizeof(int) + count * sizeof(cputime64_t);
+	alloc_size = count * sizeof(int) + count * sizeof(u64);
 
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 	alloc_size += count * count * sizeof(int);

commit e37736777254ce1abc85493a5cacbefe5983b896
Author: Tu, Xiaobing <xiaobing.tu@intel.com>
Date:   Tue Oct 23 01:03:00 2012 +0200

    Fix memory leak in cpufreq stats.
    
    When system enters sleep, non-boot CPUs will be disabled.
    Cpufreq stats sysfs is created when the CPU is up, but it is not
    freed when the CPU is going down. This will cause memory leak.
    
    Signed-off-by: xiaobing tu <xiaobing.tu@intel.com>
    Signed-off-by: guifang tang <guifang.tang@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index b40ee1403be9..399831690fed 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -328,6 +328,7 @@ static int __cpuinit cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 		cpufreq_update_policy(cpu);
 		break;
 	case CPU_DOWN_PREPARE:
+	case CPU_DOWN_PREPARE_FROZEN:
 		cpufreq_stats_free_sysfs(cpu);
 		break;
 	case CPU_DEAD:

commit 7affca3537d74365128e477b40c529d6f2fe86c8
Merge: 356b95424cfb ff4b8a57f0aa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 7 12:03:30 2012 -0800

    Merge branch 'driver-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    * 'driver-core-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (73 commits)
      arm: fix up some samsung merge sysdev conversion problems
      firmware: Fix an oops on reading fw_priv->fw in sysfs loading file
      Drivers:hv: Fix a bug in vmbus_driver_unregister()
      driver core: remove __must_check from device_create_file
      debugfs: add missing #ifdef HAS_IOMEM
      arm: time.h: remove device.h #include
      driver-core: remove sysdev.h usage.
      clockevents: remove sysdev.h
      arm: convert sysdev_class to a regular subsystem
      arm: leds: convert sysdev_class to a regular subsystem
      kobject: remove kset_find_obj_hinted()
      m86k: gpio - convert sysdev_class to a regular subsystem
      mips: txx9_sram - convert sysdev_class to a regular subsystem
      mips: 7segled - convert sysdev_class to a regular subsystem
      sh: dma - convert sysdev_class to a regular subsystem
      sh: intc - convert sysdev_class to a regular subsystem
      power: suspend - convert sysdev_class to a regular subsystem
      power: qe_ic - convert sysdev_class to a regular subsystem
      power: cmm - convert sysdev_class to a regular subsystem
      s390: time - convert sysdev_class to a regular subsystem
      ...
    
    Fix up conflicts with 'struct sysdev' removal from various platform
    drivers that got changed:
     - arch/arm/mach-exynos/cpu.c
     - arch/arm/mach-exynos/irq-eint.c
     - arch/arm/mach-s3c64xx/common.c
     - arch/arm/mach-s3c64xx/cpu.c
     - arch/arm/mach-s5p64x0/cpu.c
     - arch/arm/mach-s5pv210/common.c
     - arch/arm/plat-samsung/include/plat/cpu.h
     - arch/powerpc/kernel/sysfs.c
    and fix up cpu_is_hotpluggable() as per Greg in include/linux/cpu.h

commit 8a25a2fd126c621f44f3aeaef80d51f00fc11639
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Dec 21 14:29:42 2011 -0800

    cpu: convert 'cpu' and 'machinecheck' sysdev_class to a regular subsystem
    
    This moves the 'cpu sysdev_class' over to a regular 'cpu' subsystem
    and converts the devices to regular devices. The sysdev drivers are
    implemented as subsystem interfaces now.
    
    After all sysdev classes are ported to regular driver core entities, the
    sysdev implementation will be entirely removed from the kernel.
    
    Userspace relies on events and generic sysfs subsystem infrastructure
    from sysdev devices, which are made available with this conversion.
    
    Cc: Haavard Skinnemoen <hskinnemoen@gmail.com>
    Cc: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Borislav Petkov <bp@amd64.org>
    Cc: Tigran Aivazian <tigran@aivazian.fsnet.co.uk>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Zhang Rui <rui.zhang@intel.com>
    Cc: Dave Jones <davej@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arjan van de Ven <arjan@linux.intel.com>
    Cc: "Rafael J. Wysocki" <rjw@sisk.pl>
    Cc: "Srivatsa S. Bhat" <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index c5072a91e848..390380a8cfc9 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -11,7 +11,6 @@
 
 #include <linux/kernel.h>
 #include <linux/slab.h>
-#include <linux/sysdev.h>
 #include <linux/cpu.h>
 #include <linux/sysfs.h>
 #include <linux/cpufreq.h>

commit 648616343cdbe904c585a6c12e323d3b3c72e46f
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Thu Dec 15 14:56:09 2011 +0100

    [S390] cputime: add sparse checking and cleanup
    
    Make cputime_t and cputime64_t nocast to enable sparse checking to
    detect incorrect use of cputime. Drop the cputime macros for simple
    scalar operations. The conversion macros are still needed.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index c5072a91e848..2a508edd768b 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -61,9 +61,8 @@ static int cpufreq_stats_update(unsigned int cpu)
 	spin_lock(&cpufreq_stats_lock);
 	stat = per_cpu(cpufreq_stats_table, cpu);
 	if (stat->time_in_state)
-		stat->time_in_state[stat->last_index] =
-			cputime64_add(stat->time_in_state[stat->last_index],
-				      cputime_sub(cur_time, stat->last_time));
+		stat->time_in_state[stat->last_index] +=
+			cur_time - stat->last_time;
 	stat->last_time = cur_time;
 	spin_unlock(&cpufreq_stats_lock);
 	return 0;

commit 5c720d37bf5c2864cd7e834afff88321d6e4d97d
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri May 27 13:23:32 2011 -0400

    cpufreq: cpufreq_stats.c is a module, and should include module.h
    
    So that we can clean up the header files and not be relying
    on implicit includes from device.h ---> module.h
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index faf7c5217848..c5072a91e848 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -15,6 +15,7 @@
 #include <linux/cpu.h>
 #include <linux/sysfs.h>
 #include <linux/cpufreq.h>
+#include <linux/module.h>
 #include <linux/jiffies.h>
 #include <linux/percpu.h>
 #include <linux/kobject.h>

commit 46a310b80bc2c9ccc019649c9da91194cbc10944
Author: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date:   Thu Jun 16 15:36:38 2011 -0400

    [CPUFREQ] Don't set stat->last_index to -1 if the pol->cur has incorrect value.
    
    If the driver submitted an non-existing pol>cur value (say it
    used the default initialized value of zero), when the cpufreq
    stats tries to setup its initial values it incorrectly sets
    stat->last_index to -1 (or 0xfffff...). And cpufreq_stats_update
    tries to update at that index location and fails.
    
    This can be caused by:
    
    stat->last_index = freq_table_get_index(stat, policy->cur);
    
    not finding the appropiate frequency in the table (b/c the policy->cur
    is wrong) and we end up crashing. The fix however is
    concentrated in the 'cpufreq_stats_update' as the last_index
    (and old_index) are updated there. Which means it can reset
    the last_index to -1 again and on the next iteration cause a crash.
    
    Without this patch, the following crash is observed:
    
    powernow-k8: Found 1 AMD Athlon(tm) 64 Processor 3700+ (1 cpu cores) (version 2.20.00)
    powernow-k8: fid 0x2 (1000 MHz), vid 0x12
    powernow-k8: fid 0xa (1800 MHz), vid 0xa
    powernow-k8: fid 0xc (2000 MHz), vid 0x8
    powernow-k8: fid 0xe (2200 MHz), vid 0x8
    Marking TSC unstable due to cpufreq changes
    powernow-k8: fid trans failed, fid 0x2, curr 0x0
    BUG: unable to handle kernel paging request at ffff880807e07b78
    IP: [<ffffffff81479163>] cpufreq_stats_update+0x46/0x5b
    .. snip..
    Pid: 1, comm: swapper Not tainted 3.0.0-rc2 #45 MICRO-STAR INTERNATIONAL CO., LTD MS-7094/MS-7094
    ..snip..
    Call Trace:
     [<ffffffff81479248>] cpufreq_stat_notifier_trans+0x48/0x7c
     [<ffffffff81095d68>] notifier_call_chain+0x32/0x5e
     [<ffffffff81095e6b>] __srcu_notifier_call_chain+0x47/0x63
     [<ffffffff81095e96>] srcu_notifier_call_chain+0xf/0x11
     [<ffffffff81477e7a>] cpufreq_notify_transition+0x111/0x134
     [<ffffffff8147b0d4>] powernowk8_target+0x53b/0x617
     [<ffffffff8147723a>] __cpufreq_driver_target+0x2e/0x30
     [<ffffffff8147a127>] cpufreq_governor_dbs+0x339/0x356
     [<ffffffff81477394>] __cpufreq_governor+0xa8/0xe9
     [<ffffffff81477525>] __cpufreq_set_policy+0x132/0x13e
     [<ffffffff8147848d>] cpufreq_add_dev_interface+0x272/0x28c
    
    Reported-by: Tobias Diedrich <ranma+xen@tdiedrich.de>
    Tested-by: Tobias Diedrich <ranma+xen@tdiedrich.de>
    Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 853f92d23ddb..faf7c5217848 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -298,11 +298,13 @@ static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
 	old_index = stat->last_index;
 	new_index = freq_table_get_index(stat, freq->new);
 
-	cpufreq_stats_update(freq->cpu);
-	if (old_index == new_index)
+	/* We can't do stat->time_in_state[-1]= .. */
+	if (old_index == -1 || new_index == -1)
 		return 0;
 
-	if (old_index == -1 || new_index == -1)
+	cpufreq_stats_update(freq->cpu);
+
+	if (old_index == new_index)
 		return 0;
 
 	spin_lock(&cpufreq_stats_lock);

commit 13f067537f34456443f61c950cd6dc37d1d5f3ee
Author: Dave Jones <davej@redhat.com>
Date:   Sun Jun 12 16:35:28 2011 -0400

    [CPUFREQ] Remove cpufreq_stats sysfs entries on module unload.
    
    cpufreq_stats leaves behind its sysfs entries, which causes a panic
    when something stumbled across them.
    (Discovered by unloading cpufreq_stats while powertop was loaded).
    
    Signed-off-by: Dave Jones <davej@redhat.com>
    Cc: stable@kernel.org

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index b60a4c263686..853f92d23ddb 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -387,6 +387,7 @@ static void __exit cpufreq_stats_exit(void)
 	unregister_hotcpu_notifier(&cpufreq_stat_cpu_notifier);
 	for_each_online_cpu(cpu) {
 		cpufreq_stats_free_table(cpu);
+		cpufreq_stats_free_sysfs(cpu);
 	}
 }
 

commit 469057d587a9de2cd6087d71a008b908e785a5b6
Author: Karthigan Srinivasan <karthigan.srinivasan@hp.com>
Date:   Fri Apr 1 17:34:47 2011 -0500

    [CPUFREQ] cpufreq_stats.c: Fixed brace coding style issue
    
    Fixed brace coding style issue.
    
    Signed-off-by: Karthigan Srinivasan <karthigan.srinivasan@hp.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 4f1b8de2c9f3..b60a4c263686 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -338,8 +338,7 @@ static int __cpuinit cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 }
 
 /* priority=1 so this will get called before cpufreq_remove_dev */
-static struct notifier_block cpufreq_stat_cpu_notifier __refdata =
-{
+static struct notifier_block cpufreq_stat_cpu_notifier __refdata = {
 	.notifier_call = cpufreq_stat_cpu_callback,
 	.priority = 1,
 };

commit 98586ed8b8878e10691203687e89a42fa3355300
Author: steven finney <Steven.Finney@palm.com>
Date:   Mon May 2 11:29:17 2011 -0700

    [CPUFREQ] Fix memory leak in cpufreq_stat
    
    When a CPU is taken offline in an SMP system, cpufreq_remove_dev()
    nulls out the per-cpu policy before cpufreq_stats_free_table() can
    make use of it.  cpufreq_stats_free_table() then skips the
    call to sysfs_remove_group(), leaving about 100 bytes of sysfs-related
    memory unclaimed each time a CPU-removal occurs. Break up
    cpu_stats_free_table into sysfs and table portions, and
    call the sysfs portion early.
    
    Signed-off-by: Steven Finney <steven.finney@palm.com>
    Signed-off-by: Dave Jones <davej@redhat.com>
    Cc: stable@kernel.org

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 00d73fc8e4e2..4f1b8de2c9f3 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -165,17 +165,27 @@ static int freq_table_get_index(struct cpufreq_stats *stat, unsigned int freq)
 	return -1;
 }
 
+/* should be called late in the CPU removal sequence so that the stats
+ * memory is still available in case someone tries to use it.
+ */
 static void cpufreq_stats_free_table(unsigned int cpu)
 {
 	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, cpu);
-	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
-	if (policy && policy->cpu == cpu)
-		sysfs_remove_group(&policy->kobj, &stats_attr_group);
 	if (stat) {
 		kfree(stat->time_in_state);
 		kfree(stat);
 	}
 	per_cpu(cpufreq_stats_table, cpu) = NULL;
+}
+
+/* must be called early in the CPU removal sequence (before
+ * cpufreq_remove_dev) so that policy is still valid.
+ */
+static void cpufreq_stats_free_sysfs(unsigned int cpu)
+{
+	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
+	if (policy && policy->cpu == cpu)
+		sysfs_remove_group(&policy->kobj, &stats_attr_group);
 	if (policy)
 		cpufreq_cpu_put(policy);
 }
@@ -316,6 +326,9 @@ static int __cpuinit cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 	case CPU_ONLINE_FROZEN:
 		cpufreq_update_policy(cpu);
 		break;
+	case CPU_DOWN_PREPARE:
+		cpufreq_stats_free_sysfs(cpu);
+		break;
 	case CPU_DEAD:
 	case CPU_DEAD_FROZEN:
 		cpufreq_stats_free_table(cpu);
@@ -324,9 +337,11 @@ static int __cpuinit cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 	return NOTIFY_OK;
 }
 
+/* priority=1 so this will get called before cpufreq_remove_dev */
 static struct notifier_block cpufreq_stat_cpu_notifier __refdata =
 {
 	.notifier_call = cpufreq_stat_cpu_callback,
+	.priority = 1,
 };
 
 static struct notifier_block notifier_policy_block = {

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 5a62d678dd19..00d73fc8e4e2 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -10,6 +10,7 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/slab.h>
 #include <linux/sysdev.h>
 #include <linux/cpu.h>
 #include <linux/sysfs.h>

commit 0a829c5afde8e9e9c33a3a5c231b04dcf253337d
Author: Dave Jones <davej@redhat.com>
Date:   Sun Jan 18 01:49:04 2009 -0500

    [CPUFREQ] checkpatch cleanups for cpufreq_stats
    
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index c0ff97d375d7..5a62d678dd19 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -2,7 +2,7 @@
  *  drivers/cpufreq/cpufreq_stats.c
  *
  *  Copyright (C) 2003-2004 Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>.
- *	      (C) 2004 Zou Nan hai <nanhai.zou@intel.com>.
+ *  (C) 2004 Zou Nan hai <nanhai.zou@intel.com>.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -23,7 +23,7 @@
 
 static spinlock_t cpufreq_stats_lock;
 
-#define CPUFREQ_STATDEVICE_ATTR(_name,_mode,_show) \
+#define CPUFREQ_STATDEVICE_ATTR(_name, _mode, _show) \
 static struct freq_attr _attr_##_name = {\
 	.attr = {.name = __stringify(_name), .mode = _mode, }, \
 	.show = _show,\
@@ -50,8 +50,7 @@ struct cpufreq_stats_attribute {
 	ssize_t(*show) (struct cpufreq_stats *, char *);
 };
 
-static int
-cpufreq_stats_update (unsigned int cpu)
+static int cpufreq_stats_update(unsigned int cpu)
 {
 	struct cpufreq_stats *stat;
 	unsigned long long cur_time;
@@ -68,8 +67,7 @@ cpufreq_stats_update (unsigned int cpu)
 	return 0;
 }
 
-static ssize_t
-show_total_trans(struct cpufreq_policy *policy, char *buf)
+static ssize_t show_total_trans(struct cpufreq_policy *policy, char *buf)
 {
 	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, policy->cpu);
 	if (!stat)
@@ -78,8 +76,7 @@ show_total_trans(struct cpufreq_policy *policy, char *buf)
 			per_cpu(cpufreq_stats_table, stat->cpu)->total_trans);
 }
 
-static ssize_t
-show_time_in_state(struct cpufreq_policy *policy, char *buf)
+static ssize_t show_time_in_state(struct cpufreq_policy *policy, char *buf)
 {
 	ssize_t len = 0;
 	int i;
@@ -89,14 +86,14 @@ show_time_in_state(struct cpufreq_policy *policy, char *buf)
 	cpufreq_stats_update(stat->cpu);
 	for (i = 0; i < stat->state_num; i++) {
 		len += sprintf(buf + len, "%u %llu\n", stat->freq_table[i],
-			(unsigned long long)cputime64_to_clock_t(stat->time_in_state[i]));
+			(unsigned long long)
+			cputime64_to_clock_t(stat->time_in_state[i]));
 	}
 	return len;
 }
 
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
-static ssize_t
-show_trans_table(struct cpufreq_policy *policy, char *buf)
+static ssize_t show_trans_table(struct cpufreq_policy *policy, char *buf)
 {
 	ssize_t len = 0;
 	int i, j;
@@ -139,11 +136,11 @@ show_trans_table(struct cpufreq_policy *policy, char *buf)
 		return PAGE_SIZE;
 	return len;
 }
-CPUFREQ_STATDEVICE_ATTR(trans_table,0444,show_trans_table);
+CPUFREQ_STATDEVICE_ATTR(trans_table, 0444, show_trans_table);
 #endif
 
-CPUFREQ_STATDEVICE_ATTR(total_trans,0444,show_total_trans);
-CPUFREQ_STATDEVICE_ATTR(time_in_state,0444,show_time_in_state);
+CPUFREQ_STATDEVICE_ATTR(total_trans, 0444, show_total_trans);
+CPUFREQ_STATDEVICE_ATTR(time_in_state, 0444, show_time_in_state);
 
 static struct attribute *default_attrs[] = {
 	&_attr_total_trans.attr,
@@ -158,8 +155,7 @@ static struct attribute_group stats_attr_group = {
 	.name = "stats"
 };
 
-static int
-freq_table_get_index(struct cpufreq_stats *stat, unsigned int freq)
+static int freq_table_get_index(struct cpufreq_stats *stat, unsigned int freq)
 {
 	int index;
 	for (index = 0; index < stat->max_state; index++)
@@ -183,8 +179,7 @@ static void cpufreq_stats_free_table(unsigned int cpu)
 		cpufreq_cpu_put(policy);
 }
 
-static int
-cpufreq_stats_create_table (struct cpufreq_policy *policy,
+static int cpufreq_stats_create_table(struct cpufreq_policy *policy,
 		struct cpufreq_frequency_table *table)
 {
 	unsigned int i, j, count = 0, ret = 0;
@@ -194,7 +189,8 @@ cpufreq_stats_create_table (struct cpufreq_policy *policy,
 	unsigned int cpu = policy->cpu;
 	if (per_cpu(cpufreq_stats_table, cpu))
 		return -EBUSY;
-	if ((stat = kzalloc(sizeof(struct cpufreq_stats), GFP_KERNEL)) == NULL)
+	stat = kzalloc(sizeof(struct cpufreq_stats), GFP_KERNEL);
+	if ((stat) == NULL)
 		return -ENOMEM;
 
 	data = cpufreq_cpu_get(cpu);
@@ -203,13 +199,14 @@ cpufreq_stats_create_table (struct cpufreq_policy *policy,
 		goto error_get_fail;
 	}
 
-	if ((ret = sysfs_create_group(&data->kobj, &stats_attr_group)))
+	ret = sysfs_create_group(&data->kobj, &stats_attr_group);
+	if (ret)
 		goto error_out;
 
 	stat->cpu = cpu;
 	per_cpu(cpufreq_stats_table, cpu) = stat;
 
-	for (i=0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
+	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
 		unsigned int freq = table[i].frequency;
 		if (freq == CPUFREQ_ENTRY_INVALID)
 			continue;
@@ -255,9 +252,8 @@ cpufreq_stats_create_table (struct cpufreq_policy *policy,
 	return ret;
 }
 
-static int
-cpufreq_stat_notifier_policy (struct notifier_block *nb, unsigned long val,
-		void *data)
+static int cpufreq_stat_notifier_policy(struct notifier_block *nb,
+		unsigned long val, void *data)
 {
 	int ret;
 	struct cpufreq_policy *policy = data;
@@ -268,14 +264,14 @@ cpufreq_stat_notifier_policy (struct notifier_block *nb, unsigned long val,
 	table = cpufreq_frequency_get_table(cpu);
 	if (!table)
 		return 0;
-	if ((ret = cpufreq_stats_create_table(policy, table)))
+	ret = cpufreq_stats_create_table(policy, table);
+	if (ret)
 		return ret;
 	return 0;
 }
 
-static int
-cpufreq_stat_notifier_trans (struct notifier_block *nb, unsigned long val,
-		void *data)
+static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
+		unsigned long val, void *data)
 {
 	struct cpufreq_freqs *freq = data;
 	struct cpufreq_stats *stat;
@@ -340,19 +336,20 @@ static struct notifier_block notifier_trans_block = {
 	.notifier_call = cpufreq_stat_notifier_trans
 };
 
-static int
-__init cpufreq_stats_init(void)
+static int __init cpufreq_stats_init(void)
 {
 	int ret;
 	unsigned int cpu;
 
 	spin_lock_init(&cpufreq_stats_lock);
-	if ((ret = cpufreq_register_notifier(&notifier_policy_block,
-				CPUFREQ_POLICY_NOTIFIER)))
+	ret = cpufreq_register_notifier(&notifier_policy_block,
+				CPUFREQ_POLICY_NOTIFIER);
+	if (ret)
 		return ret;
 
-	if ((ret = cpufreq_register_notifier(&notifier_trans_block,
-				CPUFREQ_TRANSITION_NOTIFIER))) {
+	ret = cpufreq_register_notifier(&notifier_trans_block,
+				CPUFREQ_TRANSITION_NOTIFIER);
+	if (ret) {
 		cpufreq_unregister_notifier(&notifier_policy_block,
 				CPUFREQ_POLICY_NOTIFIER);
 		return ret;
@@ -364,8 +361,7 @@ __init cpufreq_stats_init(void)
 	}
 	return 0;
 }
-static void
-__exit cpufreq_stats_exit(void)
+static void __exit cpufreq_stats_exit(void)
 {
 	unsigned int cpu;
 
@@ -379,10 +375,10 @@ __exit cpufreq_stats_exit(void)
 	}
 }
 
-MODULE_AUTHOR ("Zou Nan hai <nanhai.zou@intel.com>");
-MODULE_DESCRIPTION ("'cpufreq_stats' - A driver to export cpufreq stats "
+MODULE_AUTHOR("Zou Nan hai <nanhai.zou@intel.com>");
+MODULE_DESCRIPTION("'cpufreq_stats' - A driver to export cpufreq stats "
 				"through sysfs filesystem");
-MODULE_LICENSE ("GPL");
+MODULE_LICENSE("GPL");
 
 module_init(cpufreq_stats_init);
 module_exit(cpufreq_stats_exit);

commit 7a6aedfac98c6d54ecf97ca1ffb1e6a1f3d26aea
Author: Mike Travis <travis@sgi.com>
Date:   Tue Mar 25 15:06:53 2008 -0700

    [CPUFREQ] change cpu freq arrays to per_cpu variables
    
    Change cpufreq_policy and cpufreq_governor pointer tables
    from arrays to per_cpu variables in the cpufreq subsystem.
    
    Also some minor complaints from checkpatch.pl fixed.
    
    Based on:
            git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git
            git://git.kernel.org/pub/scm/linux/kernel/git/x86/linux-2.6-x86.git
    
    Signed-off-by: Mike Travis <travis@sgi.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index ae70d63a8b26..c0ff97d375d7 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -43,7 +43,7 @@ struct cpufreq_stats {
 #endif
 };
 
-static struct cpufreq_stats *cpufreq_stats_table[NR_CPUS];
+static DEFINE_PER_CPU(struct cpufreq_stats *, cpufreq_stats_table);
 
 struct cpufreq_stats_attribute {
 	struct attribute attr;
@@ -58,7 +58,7 @@ cpufreq_stats_update (unsigned int cpu)
 
 	cur_time = get_jiffies_64();
 	spin_lock(&cpufreq_stats_lock);
-	stat = cpufreq_stats_table[cpu];
+	stat = per_cpu(cpufreq_stats_table, cpu);
 	if (stat->time_in_state)
 		stat->time_in_state[stat->last_index] =
 			cputime64_add(stat->time_in_state[stat->last_index],
@@ -71,11 +71,11 @@ cpufreq_stats_update (unsigned int cpu)
 static ssize_t
 show_total_trans(struct cpufreq_policy *policy, char *buf)
 {
-	struct cpufreq_stats *stat = cpufreq_stats_table[policy->cpu];
+	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, policy->cpu);
 	if (!stat)
 		return 0;
 	return sprintf(buf, "%d\n",
-			cpufreq_stats_table[stat->cpu]->total_trans);
+			per_cpu(cpufreq_stats_table, stat->cpu)->total_trans);
 }
 
 static ssize_t
@@ -83,7 +83,7 @@ show_time_in_state(struct cpufreq_policy *policy, char *buf)
 {
 	ssize_t len = 0;
 	int i;
-	struct cpufreq_stats *stat = cpufreq_stats_table[policy->cpu];
+	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, policy->cpu);
 	if (!stat)
 		return 0;
 	cpufreq_stats_update(stat->cpu);
@@ -101,7 +101,7 @@ show_trans_table(struct cpufreq_policy *policy, char *buf)
 	ssize_t len = 0;
 	int i, j;
 
-	struct cpufreq_stats *stat = cpufreq_stats_table[policy->cpu];
+	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, policy->cpu);
 	if (!stat)
 		return 0;
 	cpufreq_stats_update(stat->cpu);
@@ -170,7 +170,7 @@ freq_table_get_index(struct cpufreq_stats *stat, unsigned int freq)
 
 static void cpufreq_stats_free_table(unsigned int cpu)
 {
-	struct cpufreq_stats *stat = cpufreq_stats_table[cpu];
+	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table, cpu);
 	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
 	if (policy && policy->cpu == cpu)
 		sysfs_remove_group(&policy->kobj, &stats_attr_group);
@@ -178,7 +178,7 @@ static void cpufreq_stats_free_table(unsigned int cpu)
 		kfree(stat->time_in_state);
 		kfree(stat);
 	}
-	cpufreq_stats_table[cpu] = NULL;
+	per_cpu(cpufreq_stats_table, cpu) = NULL;
 	if (policy)
 		cpufreq_cpu_put(policy);
 }
@@ -192,7 +192,7 @@ cpufreq_stats_create_table (struct cpufreq_policy *policy,
 	struct cpufreq_policy *data;
 	unsigned int alloc_size;
 	unsigned int cpu = policy->cpu;
-	if (cpufreq_stats_table[cpu])
+	if (per_cpu(cpufreq_stats_table, cpu))
 		return -EBUSY;
 	if ((stat = kzalloc(sizeof(struct cpufreq_stats), GFP_KERNEL)) == NULL)
 		return -ENOMEM;
@@ -207,7 +207,7 @@ cpufreq_stats_create_table (struct cpufreq_policy *policy,
 		goto error_out;
 
 	stat->cpu = cpu;
-	cpufreq_stats_table[cpu] = stat;
+	per_cpu(cpufreq_stats_table, cpu) = stat;
 
 	for (i=0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
 		unsigned int freq = table[i].frequency;
@@ -251,7 +251,7 @@ cpufreq_stats_create_table (struct cpufreq_policy *policy,
 	cpufreq_cpu_put(data);
 error_get_fail:
 	kfree(stat);
-	cpufreq_stats_table[cpu] = NULL;
+	per_cpu(cpufreq_stats_table, cpu) = NULL;
 	return ret;
 }
 
@@ -284,7 +284,7 @@ cpufreq_stat_notifier_trans (struct notifier_block *nb, unsigned long val,
 	if (val != CPUFREQ_POSTCHANGE)
 		return 0;
 
-	stat = cpufreq_stats_table[freq->cpu];
+	stat = per_cpu(cpufreq_stats_table, freq->cpu);
 	if (!stat)
 		return 0;
 

commit 6501faf8c1bbaa51dc493f3681df016d2ebce833
Author: Shaohua Li <shaohua.li@intel.com>
Date:   Sun Apr 27 13:46:56 2008 -0700

    [CPUFREQ] state info wrong after resume
    
    Sometimes old_index != stat->last_index, see cpufreq_update_policy, bios can
    change cpu setting in resume.  In my test, after resume cpu is in lowest
    speed, but the stat info shows cpu is in full speed.  This patch makes the
    stat info correct after a resume.
    
    Signed-off-by: Shaohua Li <shaohua.li@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index ef09e069433b..ae70d63a8b26 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -288,7 +288,7 @@ cpufreq_stat_notifier_trans (struct notifier_block *nb, unsigned long val,
 	if (!stat)
 		return 0;
 
-	old_index = freq_table_get_index(stat, freq->old);
+	old_index = stat->last_index;
 	new_index = freq_table_get_index(stat, freq->new);
 
 	cpufreq_stats_update(freq->cpu);

commit 25aca347d49ffc38aa3b7e63ce9b90df7f8b79c8
Author: Cesar Eduardo Barros <cesarb@cesarb.net>
Date:   Sat Feb 16 08:41:25 2008 -0200

    [CPUFREQ] fix show_trans_table
    
    Fix show_trans_table when it overflows PAGE_SIZE.
    
    * Not all snprintf calls were protected against being passed a negative
    length.
    * When show_trans_table overflows, len might be > PAGE_SIZE. In that case,
    returns PAGE_SIZE.
    
    Signed-off-by: Cesar Eduardo Barros <cesarb@cesarb.net>
    Signed-off-by: Dave Jones <davej@codemonkey.org.uk>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 070421a5480e..ef09e069433b 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -114,7 +114,7 @@ show_trans_table(struct cpufreq_policy *policy, char *buf)
 				stat->freq_table[i]);
 	}
 	if (len >= PAGE_SIZE)
-		return len;
+		return PAGE_SIZE;
 
 	len += snprintf(buf + len, PAGE_SIZE - len, "\n");
 
@@ -131,8 +131,12 @@ show_trans_table(struct cpufreq_policy *policy, char *buf)
 			len += snprintf(buf + len, PAGE_SIZE - len, "%9u ",
 					stat->trans_table[i*stat->max_state+j]);
 		}
+		if (len >= PAGE_SIZE)
+			break;
 		len += snprintf(buf + len, PAGE_SIZE - len, "\n");
 	}
+	if (len >= PAGE_SIZE)
+		return PAGE_SIZE;
 	return len;
 }
 CPUFREQ_STATDEVICE_ATTR(trans_table,0444,show_trans_table);

commit f6ebef30e21638417f8f5443ba393d63a0c27e2b
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sun Feb 17 13:22:52 2008 +0100

    [CPUFREQ] fix section mismatch warnings
    
    Fix the following warnings:
    WARNING: vmlinux.o(.text+0xfe6711): Section mismatch in reference from the function cpufreq_unregister_driver() to the variable .cpuinit.data:cpufreq_cpu_notifier
    WARNING: vmlinux.o(.text+0xfe68af): Section mismatch in reference from the function cpufreq_register_driver() to the variable .cpuinit.data:cpufreq_cpu_notifier
    WARNING: vmlinux.o(.exit.text+0xc4fa): Section mismatch in reference from the function cpufreq_stats_exit() to the variable .cpuinit.data:cpufreq_stat_cpu_notifier
    
    The warnings were casued by references to unregister_hotcpu_notifier()
    from normal functions or exit functions.
    This is flagged by modpost as a potential error because
    it does not know that for the non HOTPLUG_CPU
    scenario the unregister_hotcpu_notifier() is a nop.
    Silence the warning by replacing the __initdata
    annotation with a __refdata annotation.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Dave Jones <davej@codemonkey.org.uk>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 1b8312b02006..070421a5480e 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -323,7 +323,7 @@ static int __cpuinit cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 	return NOTIFY_OK;
 }
 
-static struct notifier_block cpufreq_stat_cpu_notifier __cpuinitdata =
+static struct notifier_block cpufreq_stat_cpu_notifier __refdata =
 {
 	.notifier_call = cpufreq_stat_cpu_callback,
 };

commit a33234735b2bcfb23cf1facb1f0d8656b8edab8f
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Dec 17 16:20:03 2007 -0800

    drivers/cpufreq/cpufreq_stats.c section fix
    
    cpufreq_stats_free_table() mustn't be __cpuexit since it's called by the
    __cpuinit cpufreq_stat_cpu_callback().
    
    This patch fixes the following section mismatch reported by
    Chris Clayton:
    
    WARNING: vmlinux.o(.init.text+0x143dd): Section mismatch: reference to .exit.text:cpufreq_stats_free_table (between 'cpufreq_stat_cpu_callback' and 'cpufreq_stats_init')
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Cc: Chris Clayton <chris2553@googlemail.com>
    Acked-by: Dave Jones <davej@codemonkey.org.uk>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 8a45d0f93e26..1b8312b02006 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -164,7 +164,7 @@ freq_table_get_index(struct cpufreq_stats *stat, unsigned int freq)
 	return -1;
 }
 
-static void __cpuexit cpufreq_stats_free_table(unsigned int cpu)
+static void cpufreq_stats_free_table(unsigned int cpu)
 {
 	struct cpufreq_stats *stat = cpufreq_stats_table[cpu];
 	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);

commit 55395ae72b6e5ae614d28df74158c47454652583
Author: Satyam Sharma <satyam@infradead.org>
Date:   Tue Oct 2 13:28:15 2007 -0700

    [CPUFREQ] cpufreq_stats: misc cpuinit section annotations
    
    * Stop referencing the callback directly from the __init and __exit
      functions of this driver, and instead explicitly call
      cpufreq_update_policy() et al. This enables the callback function
      to be marked as __cpuinit (and the notifier_block __cpuinitdata),
      thereby saving space when HOTPLUG_CPU=n. This also enables us to
      use other tricks to replace __cpuinit{data} in future.
    
    * cpufreq_stats_free_table() is only called from __cpuinit or __exit
      marked functions, making it an ideal candidate for __cpuexit.
    
    * Fix missing space in the module description
    
    Signed-off-by: Satyam Sharma <satyam@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 917b9bab9ccb..8a45d0f93e26 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -164,8 +164,7 @@ freq_table_get_index(struct cpufreq_stats *stat, unsigned int freq)
 	return -1;
 }
 
-static void
-cpufreq_stats_free_table (unsigned int cpu)
+static void __cpuexit cpufreq_stats_free_table(unsigned int cpu)
 {
 	struct cpufreq_stats *stat = cpufreq_stats_table[cpu];
 	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
@@ -305,8 +304,9 @@ cpufreq_stat_notifier_trans (struct notifier_block *nb, unsigned long val,
 	return 0;
 }
 
-static int cpufreq_stat_cpu_callback(struct notifier_block *nfb,
-					unsigned long action, void *hcpu)
+static int __cpuinit cpufreq_stat_cpu_callback(struct notifier_block *nfb,
+					       unsigned long action,
+					       void *hcpu)
 {
 	unsigned int cpu = (unsigned long)hcpu;
 
@@ -323,7 +323,7 @@ static int cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 	return NOTIFY_OK;
 }
 
-static struct notifier_block cpufreq_stat_cpu_notifier =
+static struct notifier_block cpufreq_stat_cpu_notifier __cpuinitdata =
 {
 	.notifier_call = cpufreq_stat_cpu_callback,
 };
@@ -356,8 +356,7 @@ __init cpufreq_stats_init(void)
 
 	register_hotcpu_notifier(&cpufreq_stat_cpu_notifier);
 	for_each_online_cpu(cpu) {
-		cpufreq_stat_cpu_callback(&cpufreq_stat_cpu_notifier,
-				CPU_ONLINE, (void *)(long)cpu);
+		cpufreq_update_policy(cpu);
 	}
 	return 0;
 }
@@ -372,13 +371,12 @@ __exit cpufreq_stats_exit(void)
 			CPUFREQ_TRANSITION_NOTIFIER);
 	unregister_hotcpu_notifier(&cpufreq_stat_cpu_notifier);
 	for_each_online_cpu(cpu) {
-		cpufreq_stat_cpu_callback(&cpufreq_stat_cpu_notifier,
-						CPU_DEAD, (void *)(long)cpu);
+		cpufreq_stats_free_table(cpu);
 	}
 }
 
 MODULE_AUTHOR ("Zou Nan hai <nanhai.zou@intel.com>");
-MODULE_DESCRIPTION ("'cpufreq_stats' - A driver to export cpufreq stats"
+MODULE_DESCRIPTION ("'cpufreq_stats' - A driver to export cpufreq stats "
 				"through sysfs filesystem");
 MODULE_LICENSE ("GPL");
 

commit 7b595756ec1f49e0049a9e01a1298d53a7faaa15
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Jun 14 03:45:17 2007 +0900

    sysfs: kill unnecessary attribute->owner
    
    sysfs is now completely out of driver/module lifetime game.  After
    deletion, a sysfs node doesn't access anything outside sysfs proper,
    so there's no reason to hold onto the attribute owners.  Note that
    often the wrong modules were accounted for as owners leading to
    accessing removed modules.
    
    This patch kills now unnecessary attribute->owner.  Note that with
    this change, userland holding a sysfs node does not prevent the
    backing module from being unloaded.
    
    For more info regarding lifetime rule cleanup, please read the
    following message.
    
      http://article.gmane.org/gmane.linux.kernel/510293
    
    (tweaked by Greg to not delete the field just yet, to make it easier to
    merge things properly.)
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index d2f0cbd8b8f3..917b9bab9ccb 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -25,8 +25,7 @@ static spinlock_t cpufreq_stats_lock;
 
 #define CPUFREQ_STATDEVICE_ATTR(_name,_mode,_show) \
 static struct freq_attr _attr_##_name = {\
-	.attr = {.name = __stringify(_name), .owner = THIS_MODULE, \
-		.mode = _mode, }, \
+	.attr = {.name = __stringify(_name), .mode = _mode, }, \
 	.show = _show,\
 };
 

commit 8bb7844286fb8c9fce6f65d8288aeb09d03a5e0d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Wed May 9 02:35:10 2007 -0700

    Add suspend-related notifications for CPU hotplug
    
    Since nonboot CPUs are now disabled after tasks and devices have been
    frozen and the CPU hotplug infrastructure is used for this purpose, we need
    special CPU hotplug notifications that will help the CPU-hotplug-aware
    subsystems distinguish normal CPU hotplug events from CPU hotplug events
    related to a system-wide suspend or resume operation in progress.  This
    patch introduces such notifications and causes them to be used during
    suspend and resume transitions.  It also changes all of the
    CPU-hotplug-aware subsystems to take these notifications into consideration
    (for now they are handled in the same way as the corresponding "normal"
    ones).
    
    [oleg@tv-sign.ru: cleanups]
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Gautham R Shenoy <ego@in.ibm.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Oleg Nesterov <oleg@tv-sign.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index d1c7cac9316c..d2f0cbd8b8f3 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -313,9 +313,11 @@ static int cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 
 	switch (action) {
 	case CPU_ONLINE:
+	case CPU_ONLINE_FROZEN:
 		cpufreq_update_policy(cpu);
 		break;
 	case CPU_DEAD:
+	case CPU_DEAD_FROZEN:
 		cpufreq_stats_free_table(cpu);
 		break;
 	}

commit c120069779e3e35917c15393cf2847fa79811eb6
Author: Dave Jones <davej@redhat.com>
Date:   Mon Feb 5 16:12:43 2007 -0800

    [CPUFREQ] Remove hotplug cpu crap
    
    The hotplug CPU locking in cpufreq is horrendous.  No-one seems to care
    enough to fix it, so just remove it so that the 99.9% of the real world
    users of this code can use cpufreq without being bothered by warnings.
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 91ad342a6051..d1c7cac9316c 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -370,12 +370,10 @@ __exit cpufreq_stats_exit(void)
 	cpufreq_unregister_notifier(&notifier_trans_block,
 			CPUFREQ_TRANSITION_NOTIFIER);
 	unregister_hotcpu_notifier(&cpufreq_stat_cpu_notifier);
-	lock_cpu_hotplug();
 	for_each_online_cpu(cpu) {
 		cpufreq_stat_cpu_callback(&cpufreq_stat_cpu_notifier,
 						CPU_DEAD, (void *)(long)cpu);
 	}
-	unlock_cpu_hotplug();
 }
 
 MODULE_AUTHOR ("Zou Nan hai <nanhai.zou@intel.com>");

commit 8edc59d939ad233c24385fb67a62bd39db532901
Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
Date:   Tue Dec 19 12:58:55 2006 -0800

    [CPUFREQ] Bug fix for acpi-cpufreq and cpufreq_stats oops on frequency change notification
    
    Fixes the oops in cpufreq_stats with acpi_cpufreq driver.  The issue was
    that the frequency was reported as 0 in acpi-cpufreq.c.  The bug is due to
    different indicies for freq_table and ACPI perf table.
    
    Also adds a check in cpufreq_stats to check for error return from
    freq_table_get_index() and avoid using the error return value.
    
    Patch fixes the issue reported at
    http://www.ussg.iu.edu/hypermail/linux/kernel/0611.2/0629.html
    and also other similar issue here
    http://bugme.osdl.org/show_bug.cgi?id=7383 comment 53
    
    Signed-off-by: Dhaval Giani <dhaval.giani@gmail.com>
    Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 6742b1adf2c8..91ad342a6051 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -285,6 +285,7 @@ cpufreq_stat_notifier_trans (struct notifier_block *nb, unsigned long val,
 	stat = cpufreq_stats_table[freq->cpu];
 	if (!stat)
 		return 0;
+
 	old_index = freq_table_get_index(stat, freq->old);
 	new_index = freq_table_get_index(stat, freq->new);
 
@@ -292,6 +293,9 @@ cpufreq_stat_notifier_trans (struct notifier_block *nb, unsigned long val,
 	if (old_index == new_index)
 		return 0;
 
+	if (old_index == -1 || new_index == -1)
+		return 0;
+
 	spin_lock(&cpufreq_stats_lock);
 	stat->last_index = new_index;
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS

commit e08f5f5bb5dfaaa28d69ffe37eb774533297657f
Author: Gautham R Shenoy <ego@in.ibm.com>
Date:   Thu Oct 26 16:20:58 2006 +0530

    [CPUFREQ] Fix coding style issues in cpufreq.
    
    Clean up cpufreq subsystem to fix coding style issues and to improve
    the readability.
    
    Signed-off-by: Gautham R Shenoy <ego@in.ibm.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index c2ecc599dc5f..6742b1adf2c8 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -351,8 +351,8 @@ __init cpufreq_stats_init(void)
 
 	register_hotcpu_notifier(&cpufreq_stat_cpu_notifier);
 	for_each_online_cpu(cpu) {
-		cpufreq_stat_cpu_callback(&cpufreq_stat_cpu_notifier, CPU_ONLINE,
-			(void *)(long)cpu);
+		cpufreq_stat_cpu_callback(&cpufreq_stat_cpu_notifier,
+				CPU_ONLINE, (void *)(long)cpu);
 	}
 	return 0;
 }
@@ -368,14 +368,15 @@ __exit cpufreq_stats_exit(void)
 	unregister_hotcpu_notifier(&cpufreq_stat_cpu_notifier);
 	lock_cpu_hotplug();
 	for_each_online_cpu(cpu) {
-		cpufreq_stat_cpu_callback(&cpufreq_stat_cpu_notifier, CPU_DEAD,
-			(void *)(long)cpu);
+		cpufreq_stat_cpu_callback(&cpufreq_stat_cpu_notifier,
+						CPU_DEAD, (void *)(long)cpu);
 	}
 	unlock_cpu_hotplug();
 }
 
 MODULE_AUTHOR ("Zou Nan hai <nanhai.zou@intel.com>");
-MODULE_DESCRIPTION ("'cpufreq_stats' - A driver to export cpufreq stats through sysfs filesystem");
+MODULE_DESCRIPTION ("'cpufreq_stats' - A driver to export cpufreq stats"
+				"through sysfs filesystem");
 MODULE_LICENSE ("GPL");
 
 module_init(cpufreq_stats_init);

commit ddad65df0048e210c93640b59b3bad12701febb6
Author: Dave Jones <davej@redhat.com>
Date:   Fri Sep 22 19:15:23 2006 -0400

    [CPUFREQ] Fix some more CPU hotplug locking.
    
    Lukewarm IQ detected in hotplug locking
    BUG: warning at kernel/cpu.c:38/lock_cpu_hotplug()
    [<b0134a42>] lock_cpu_hotplug+0x42/0x65
    [<b02f8af1>] cpufreq_update_policy+0x25/0xad
    [<b0358756>] kprobe_flush_task+0x18/0x40
    [<b0355aab>] schedule+0x63f/0x68b
    [<b01377c2>] __link_module+0x0/0x1f
    [<b0119e7d>] __cond_resched+0x16/0x34
    [<b03560bf>] cond_resched+0x26/0x31
    [<b0355b0e>] wait_for_completion+0x17/0xb1
    [<f965c547>] cpufreq_stat_cpu_callback+0x13/0x20 [cpufreq_stats]
    [<f9670074>] cpufreq_stats_init+0x74/0x8b [cpufreq_stats]
    [<b0137872>] sys_init_module+0x91/0x174
    [<b0102c81>] sysenter_past_esp+0x56/0x79
    
    As there are other places that call cpufreq_update_policy without
    the hotplug lock, it seems better to keep the hotplug locking
    at the lower level for the time being until this is revamped.
    
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 25eee5394201..c2ecc599dc5f 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -350,12 +350,10 @@ __init cpufreq_stats_init(void)
 	}
 
 	register_hotcpu_notifier(&cpufreq_stat_cpu_notifier);
-	lock_cpu_hotplug();
 	for_each_online_cpu(cpu) {
 		cpufreq_stat_cpu_callback(&cpufreq_stat_cpu_notifier, CPU_ONLINE,
 			(void *)(long)cpu);
 	}
-	unlock_cpu_hotplug();
 	return 0;
 }
 static void

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 145061b8472a..25eee5394201 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -9,7 +9,6 @@
  * published by the Free Software Foundation.
  */
 
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/sysdev.h>
 #include <linux/cpu.h>

commit 65edc68c345cbe21d0b0375c3452a3ed5e322868
Author: Chandra Seetharaman <sekharan@us.ibm.com>
Date:   Tue Jun 27 02:54:08 2006 -0700

    [PATCH] cpu hotplug: make [un]register_cpu_notifier init time only
    
    CPUs come online only at init time (unless CONFIG_HOTPLUG_CPU is defined).
    So, cpu_notifier functionality need to be available only at init time.
    
    This patch makes register_cpu_notifier() available only at init time, unless
    CONFIG_HOTPLUG_CPU is defined.
    
    This patch exports register_cpu_notifier() and unregister_cpu_notifier() only
    if CONFIG_HOTPLUG_CPU is defined.
    
    Signed-off-by: Chandra Seetharaman <sekharan@us.ibm.com>
    Cc: Ashok Raj <ashok.raj@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index c576c0b3f452..145061b8472a 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -350,7 +350,7 @@ __init cpufreq_stats_init(void)
 		return ret;
 	}
 
-	register_cpu_notifier(&cpufreq_stat_cpu_notifier);
+	register_hotcpu_notifier(&cpufreq_stat_cpu_notifier);
 	lock_cpu_hotplug();
 	for_each_online_cpu(cpu) {
 		cpufreq_stat_cpu_callback(&cpufreq_stat_cpu_notifier, CPU_ONLINE,
@@ -368,7 +368,7 @@ __exit cpufreq_stats_exit(void)
 			CPUFREQ_POLICY_NOTIFIER);
 	cpufreq_unregister_notifier(&notifier_trans_block,
 			CPUFREQ_TRANSITION_NOTIFIER);
-	unregister_cpu_notifier(&cpufreq_stat_cpu_notifier);
+	unregister_hotcpu_notifier(&cpufreq_stat_cpu_notifier);
 	lock_cpu_hotplug();
 	for_each_online_cpu(cpu) {
 		cpufreq_stat_cpu_callback(&cpufreq_stat_cpu_notifier, CPU_DEAD,

commit 511e9ee17099c6ebe315c0524b8b482d4767ab3d
Author: Dave Jones <davej@redhat.com>
Date:   Tue May 30 17:57:14 2006 -0400

    [CPUFREQ] CodingStyle nits in cpufreq_stats.c
    
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 9694b6ed3268..c576c0b3f452 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -74,7 +74,7 @@ static ssize_t
 show_total_trans(struct cpufreq_policy *policy, char *buf)
 {
 	struct cpufreq_stats *stat = cpufreq_stats_table[policy->cpu];
-	if(!stat)
+	if (!stat)
 		return 0;
 	return sprintf(buf, "%d\n",
 			cpufreq_stats_table[stat->cpu]->total_trans);
@@ -86,7 +86,7 @@ show_time_in_state(struct cpufreq_policy *policy, char *buf)
 	ssize_t len = 0;
 	int i;
 	struct cpufreq_stats *stat = cpufreq_stats_table[policy->cpu];
-	if(!stat)
+	if (!stat)
 		return 0;
 	cpufreq_stats_update(stat->cpu);
 	for (i = 0; i < stat->state_num; i++) {
@@ -104,7 +104,7 @@ show_trans_table(struct cpufreq_policy *policy, char *buf)
 	int i, j;
 
 	struct cpufreq_stats *stat = cpufreq_stats_table[policy->cpu];
-	if(!stat)
+	if (!stat)
 		return 0;
 	cpufreq_stats_update(stat->cpu);
 	len += snprintf(buf + len, PAGE_SIZE - len, "   From  :    To\n");

commit bb1a813d3c49e57814958d2d52b5bb299204032e
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Sat Mar 11 19:22:53 2006 +0100

    [PATCH] cpufreq: fix section mismatch warnings
    
    cpufreq are the only remaining bit to be solved for me to have a modpost
    clean build for sparc64 - so I took one more look at it.
    changelog entry:
    
    Fix section mismatch warnings in cpufreq:
    WARNING: drivers/cpufreq/cpufreq_stats.o - Section mismatch: reference to .init.text: from .data between 'cpufreq_stat_cpu_notifier' (at offset 0xa8) and 'notifier_policy_block'
    WARNING: drivers/cpufreq/cpufreq_stats.o - Section mismatch: reference to .init.text: from .exit.text after 'cleanup_module' (at offset 0x30)
    
    The culprint is the function: cpufreq_stat_cpu_callback
    It is marked __cpuinit which get's redefined to __init in case
    HOTPLUG_CPU is not enabled as per. init.h:
    
    #ifdef CONFIG_HOTPLUG_CPU
    #define __cpuinit
    #else
    #define __cpuinit       __init
    #endif
    
    $> grep HOTPLUG .config
    CONFIG_HOTPLUG=y
    
    But cpufreq_stat_cpu_callback() is used in:
    __exit cpufreq_stats_exit()
    static struct notifier_block cpufreq_stat_cpu_notifier
    
    cpufreq_stat_cpu_notifier is again used in:
    __init cpufreq_stats_init()
    __exit cpufreq_stats_exit()
    
    So in both cases used from both __init and __exit context.
    Only solution seems to drop __cpuinit tag.
    
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index c25bdb7aec51..9694b6ed3268 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -303,7 +303,7 @@ cpufreq_stat_notifier_trans (struct notifier_block *nb, unsigned long val,
 	return 0;
 }
 
-static int __cpuinit cpufreq_stat_cpu_callback(struct notifier_block *nfb,
+static int cpufreq_stat_cpu_callback(struct notifier_block *nfb,
 					unsigned long action, void *hcpu)
 {
 	unsigned int cpu = (unsigned long)hcpu;

commit 32ee8c3e470d86588b51dc42ed01e85c5fa0f180
Author: Dave Jones <davej@redhat.com>
Date:   Tue Feb 28 00:43:23 2006 -0500

    [CPUFREQ] Lots of whitespace & CodingStyle cleanup.
    
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 0bddb8e694d9..c25bdb7aec51 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -2,7 +2,7 @@
  *  drivers/cpufreq/cpufreq_stats.c
  *
  *  Copyright (C) 2003-2004 Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>.
- *  	      (C) 2004 Zou Nan hai <nanhai.zou@intel.com>.
+ *	      (C) 2004 Zou Nan hai <nanhai.zou@intel.com>.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -90,7 +90,7 @@ show_time_in_state(struct cpufreq_policy *policy, char *buf)
 		return 0;
 	cpufreq_stats_update(stat->cpu);
 	for (i = 0; i < stat->state_num; i++) {
-		len += sprintf(buf + len, "%u %llu\n", stat->freq_table[i], 
+		len += sprintf(buf + len, "%u %llu\n", stat->freq_table[i],
 			(unsigned long long)cputime64_to_clock_t(stat->time_in_state[i]));
 	}
 	return len;
@@ -171,7 +171,7 @@ cpufreq_stats_free_table (unsigned int cpu)
 {
 	struct cpufreq_stats *stat = cpufreq_stats_table[cpu];
 	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
-	if (policy && policy->cpu == cpu)	
+	if (policy && policy->cpu == cpu)
 		sysfs_remove_group(&policy->kobj, &stats_attr_group);
 	if (stat) {
 		kfree(stat->time_in_state);

commit dad2ad82c5f058367df79de022bd12d36afcd065
Merge: 7079060f3e86 b7fb358c7c36
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Mon Nov 7 13:28:20 2005 -0800

    Merge master.kernel.org:/pub/scm/linux/kernel/git/davej/cpufreq

commit b7fb358c7c36a14927d5523ea674e69f90c51d1d
Author: Dave Jones <davej@redhat.com>
Date:   Tue Nov 1 23:13:45 2005 -0800

    [CPUFREQ] Fix up compile of cpufreq_stats
    
    Whoops, I lost a hunk of the last patch somehow.
    
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 19b4c3e7c390..7ddf714c4d43 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -247,6 +247,7 @@ cpufreq_stats_create_table (struct cpufreq_policy *policy,
 	return 0;
 error_out:
 	cpufreq_cpu_put(data);
+error_get_fail:
 	kfree(stat);
 	cpufreq_stats_table[cpu] = NULL;
 	return ret;

commit c32b6b8e524d2c337767d312814484d9289550cf
Author: Ashok Raj <ashok.raj@intel.com>
Date:   Sun Oct 30 14:59:54 2005 -0800

    [PATCH] create and destroy cpufreq sysfs entries based on cpu notifiers
    
    cpufreq entries in sysfs should only be populated when CPU is online state.
     When we either boot with maxcpus=x and then boot the other cpus by echoing
    to sysfs online file, these entries should be created and destroyed when
    CPU_DEAD is notified.  Same treatement as cache entries under sysfs.
    
    We place the processor in the lowest frequency, so hw managed P-State
    transitions can still work on the other threads to save power.
    
    Primary goal was to just make these directories appear/disapper dynamically.
    
    There is one in this patch i had to do, which i really dont like myself but
    probably best if someone handling the cpufreq infrastructure could give
    this code right treatment if this is not acceptable.  I guess its probably
    good for the first cut.
    
    - Converting lock_cpu_hotplug()/unlock_cpu_hotplug() to disable/enable preempt.
      The locking was smack in the middle of the notification path, when the
      hotplug is already holding the lock. I tried another solution to avoid this
      so avoid taking locks if we know we are from notification path. The solution
      was getting very ugly and i decided this was probably good for this iteration
      until someone who understands cpufreq could do a better job than me.
    
    (akpm: export cpucontrol to GPL modules: drivers/cpufreq/cpufreq_stats.c now
    does lock_cpu_hotplug())
    
    Signed-off-by: Ashok Raj <ashok.raj@intel.com>
    Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Cc: Dave Jones <davej@codemonkey.org.uk>
    Cc: Zwane Mwaikambo <zwane@holomorphy.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 741b6b191e6a..3597f25d5efa 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -19,6 +19,7 @@
 #include <linux/percpu.h>
 #include <linux/kobject.h>
 #include <linux/spinlock.h>
+#include <linux/notifier.h>
 #include <asm/cputime.h>
 
 static spinlock_t cpufreq_stats_lock;
@@ -298,6 +299,27 @@ cpufreq_stat_notifier_trans (struct notifier_block *nb, unsigned long val,
 	return 0;
 }
 
+static int __cpuinit cpufreq_stat_cpu_callback(struct notifier_block *nfb,
+					unsigned long action, void *hcpu)
+{
+	unsigned int cpu = (unsigned long)hcpu;
+
+	switch (action) {
+	case CPU_ONLINE:
+		cpufreq_update_policy(cpu);
+		break;
+	case CPU_DEAD:
+		cpufreq_stats_free_table(cpu);
+		break;
+	}
+	return NOTIFY_OK;
+}
+
+static struct notifier_block cpufreq_stat_cpu_notifier =
+{
+	.notifier_call = cpufreq_stat_cpu_callback,
+};
+
 static struct notifier_block notifier_policy_block = {
 	.notifier_call = cpufreq_stat_notifier_policy
 };
@@ -311,6 +333,7 @@ __init cpufreq_stats_init(void)
 {
 	int ret;
 	unsigned int cpu;
+
 	spin_lock_init(&cpufreq_stats_lock);
 	if ((ret = cpufreq_register_notifier(&notifier_policy_block,
 				CPUFREQ_POLICY_NOTIFIER)))
@@ -323,20 +346,31 @@ __init cpufreq_stats_init(void)
 		return ret;
 	}
 
-	for_each_cpu(cpu)
-		cpufreq_update_policy(cpu);
+	register_cpu_notifier(&cpufreq_stat_cpu_notifier);
+	lock_cpu_hotplug();
+	for_each_online_cpu(cpu) {
+		cpufreq_stat_cpu_callback(&cpufreq_stat_cpu_notifier, CPU_ONLINE,
+			(void *)(long)cpu);
+	}
+	unlock_cpu_hotplug();
 	return 0;
 }
 static void
 __exit cpufreq_stats_exit(void)
 {
 	unsigned int cpu;
+
 	cpufreq_unregister_notifier(&notifier_policy_block,
 			CPUFREQ_POLICY_NOTIFIER);
 	cpufreq_unregister_notifier(&notifier_trans_block,
 			CPUFREQ_TRANSITION_NOTIFIER);
-	for_each_cpu(cpu)
-		cpufreq_stats_free_table(cpu);
+	unregister_cpu_notifier(&cpufreq_stat_cpu_notifier);
+	lock_cpu_hotplug();
+	for_each_online_cpu(cpu) {
+		cpufreq_stat_cpu_callback(&cpufreq_stat_cpu_notifier, CPU_DEAD,
+			(void *)(long)cpu);
+	}
+	unlock_cpu_hotplug();
 }
 
 MODULE_AUTHOR ("Zou Nan hai <nanhai.zou@intel.com>");

commit bc7b26fd7ca5e0c6e769d3886c022f0a98fd88ec
Author: Dave Jones <davej@redhat.com>
Date:   Thu Oct 27 16:02:06 2005 -0700

    [CPUFREQ] Check return value of cpufreq_cpu_get in cpufreq_stats
    
    This fixes an issue found in drivers/cpufreq/cpufreq_stats.c by Coverity.
    
    Error reported:
    CID: 2642
    Checker: NULL_RETURNS (help)
    File: /export2/p4-coverity/mc2/linux26/drivers/cpufreq/cpufreq_stats.c
    Function: cpufreq_stats_create_table
    Description: Dereferencing NULL value "data"
    
    Patch description:
     The return of cpufreq_cpu_get can be NULL, check return code and return
     -EINVAL if it is NULL.
    
    Signed-off-by: Jayachandran C. <c.jayachandran at gmail.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index ff16a87125d9..19b4c3e7c390 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -196,6 +196,11 @@ cpufreq_stats_create_table (struct cpufreq_policy *policy,
 		return -ENOMEM;
 
 	data = cpufreq_cpu_get(cpu);
+	if (data == NULL) {
+		ret = -EINVAL;
+		goto error_get_fail;
+	}
+
 	if ((ret = sysfs_create_group(&data->kobj, &stats_attr_group)))
 		goto error_out;
 

commit e98df50c5200ae3c748d69002a8827afc9d2eae2
Author: Dave Jones <davej@redhat.com>
Date:   Thu Oct 20 15:17:43 2005 -0700

    [CPUFREQ] kzalloc conversions for cpufreq core.
    
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 741b6b191e6a..ff16a87125d9 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -192,9 +192,8 @@ cpufreq_stats_create_table (struct cpufreq_policy *policy,
 	unsigned int cpu = policy->cpu;
 	if (cpufreq_stats_table[cpu])
 		return -EBUSY;
-	if ((stat = kmalloc(sizeof(struct cpufreq_stats), GFP_KERNEL)) == NULL)
+	if ((stat = kzalloc(sizeof(struct cpufreq_stats), GFP_KERNEL)) == NULL)
 		return -ENOMEM;
-	memset(stat, 0, sizeof (struct cpufreq_stats));
 
 	data = cpufreq_cpu_get(cpu);
 	if ((ret = sysfs_create_group(&data->kobj, &stats_attr_group)))
@@ -216,12 +215,11 @@ cpufreq_stats_create_table (struct cpufreq_policy *policy,
 	alloc_size += count * count * sizeof(int);
 #endif
 	stat->max_state = count;
-	stat->time_in_state = kmalloc(alloc_size, GFP_KERNEL);
+	stat->time_in_state = kzalloc(alloc_size, GFP_KERNEL);
 	if (!stat->time_in_state) {
 		ret = -ENOMEM;
 		goto error_out;
 	}
-	memset(stat->time_in_state, 0, alloc_size);
 	stat->freq_table = (unsigned int *)(stat->time_in_state + count);
 
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS

commit 58f1df25403988b73d7129fcd2c4d4c24017f1af
Author: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
Date:   Wed May 25 14:46:50 2005 -0700

    [PATCH] cpufreq-stats driver updates
    
    Changes to the cpufreq stats driver:
    * Changes the way P-state transition table looks in /sysfs providing more
      clear output
    * Changes the time unit in the output from HZ to clock_t
    
    Signed-off-by: Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
    Signed-off-by: Dave Jones <davej@redhat.com>

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index 2084593937c6..741b6b191e6a 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -19,6 +19,7 @@
 #include <linux/percpu.h>
 #include <linux/kobject.h>
 #include <linux/spinlock.h>
+#include <asm/cputime.h>
 
 static spinlock_t cpufreq_stats_lock;
 
@@ -29,20 +30,14 @@ static struct freq_attr _attr_##_name = {\
 	.show = _show,\
 };
 
-static unsigned long
-delta_time(unsigned long old, unsigned long new)
-{
-	return (old > new) ? (old - new): (new + ~old + 1);
-}
-
 struct cpufreq_stats {
 	unsigned int cpu;
 	unsigned int total_trans;
-	unsigned long long last_time;
+	unsigned long long  last_time;
 	unsigned int max_state;
 	unsigned int state_num;
 	unsigned int last_index;
-	unsigned long long *time_in_state;
+	cputime64_t *time_in_state;
 	unsigned int *freq_table;
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 	unsigned int *trans_table;
@@ -60,12 +55,16 @@ static int
 cpufreq_stats_update (unsigned int cpu)
 {
 	struct cpufreq_stats *stat;
+	unsigned long long cur_time;
+
+	cur_time = get_jiffies_64();
 	spin_lock(&cpufreq_stats_lock);
 	stat = cpufreq_stats_table[cpu];
 	if (stat->time_in_state)
-		stat->time_in_state[stat->last_index] +=
-			delta_time(stat->last_time, jiffies);
-	stat->last_time = jiffies;
+		stat->time_in_state[stat->last_index] =
+			cputime64_add(stat->time_in_state[stat->last_index],
+				      cputime_sub(cur_time, stat->last_time));
+	stat->last_time = cur_time;
 	spin_unlock(&cpufreq_stats_lock);
 	return 0;
 }
@@ -90,8 +89,8 @@ show_time_in_state(struct cpufreq_policy *policy, char *buf)
 		return 0;
 	cpufreq_stats_update(stat->cpu);
 	for (i = 0; i < stat->state_num; i++) {
-		len += sprintf(buf + len, "%u %llu\n",
-			stat->freq_table[i], stat->time_in_state[i]);
+		len += sprintf(buf + len, "%u %llu\n", stat->freq_table[i], 
+			(unsigned long long)cputime64_to_clock_t(stat->time_in_state[i]));
 	}
 	return len;
 }
@@ -107,16 +106,30 @@ show_trans_table(struct cpufreq_policy *policy, char *buf)
 	if(!stat)
 		return 0;
 	cpufreq_stats_update(stat->cpu);
+	len += snprintf(buf + len, PAGE_SIZE - len, "   From  :    To\n");
+	len += snprintf(buf + len, PAGE_SIZE - len, "         : ");
+	for (i = 0; i < stat->state_num; i++) {
+		if (len >= PAGE_SIZE)
+			break;
+		len += snprintf(buf + len, PAGE_SIZE - len, "%9u ",
+				stat->freq_table[i]);
+	}
+	if (len >= PAGE_SIZE)
+		return len;
+
+	len += snprintf(buf + len, PAGE_SIZE - len, "\n");
+
 	for (i = 0; i < stat->state_num; i++) {
 		if (len >= PAGE_SIZE)
 			break;
-		len += snprintf(buf + len, PAGE_SIZE - len, "%9u:\t",
+
+		len += snprintf(buf + len, PAGE_SIZE - len, "%9u: ",
 				stat->freq_table[i]);
 
 		for (j = 0; j < stat->state_num; j++)   {
 			if (len >= PAGE_SIZE)
 				break;
-			len += snprintf(buf + len, PAGE_SIZE - len, "%u\t",
+			len += snprintf(buf + len, PAGE_SIZE - len, "%9u ",
 					stat->trans_table[i*stat->max_state+j]);
 		}
 		len += snprintf(buf + len, PAGE_SIZE - len, "\n");
@@ -197,7 +210,7 @@ cpufreq_stats_create_table (struct cpufreq_policy *policy,
 		count++;
 	}
 
-	alloc_size = count * sizeof(int) + count * sizeof(long long);
+	alloc_size = count * sizeof(int) + count * sizeof(cputime64_t);
 
 #ifdef CONFIG_CPU_FREQ_STAT_DETAILS
 	alloc_size += count * count * sizeof(int);
@@ -224,7 +237,7 @@ cpufreq_stats_create_table (struct cpufreq_policy *policy,
 	}
 	stat->state_num = j;
 	spin_lock(&cpufreq_stats_lock);
-	stat->last_time = jiffies;
+	stat->last_time = get_jiffies_64();
 	stat->last_index = freq_table_get_index(stat, policy->cur);
 	spin_unlock(&cpufreq_stats_lock);
 	cpufreq_cpu_put(data);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
new file mode 100644
index 000000000000..2084593937c6
--- /dev/null
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -0,0 +1,334 @@
+/*
+ *  drivers/cpufreq/cpufreq_stats.c
+ *
+ *  Copyright (C) 2003-2004 Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>.
+ *  	      (C) 2004 Zou Nan hai <nanhai.zou@intel.com>.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sysdev.h>
+#include <linux/cpu.h>
+#include <linux/sysfs.h>
+#include <linux/cpufreq.h>
+#include <linux/jiffies.h>
+#include <linux/percpu.h>
+#include <linux/kobject.h>
+#include <linux/spinlock.h>
+
+static spinlock_t cpufreq_stats_lock;
+
+#define CPUFREQ_STATDEVICE_ATTR(_name,_mode,_show) \
+static struct freq_attr _attr_##_name = {\
+	.attr = {.name = __stringify(_name), .owner = THIS_MODULE, \
+		.mode = _mode, }, \
+	.show = _show,\
+};
+
+static unsigned long
+delta_time(unsigned long old, unsigned long new)
+{
+	return (old > new) ? (old - new): (new + ~old + 1);
+}
+
+struct cpufreq_stats {
+	unsigned int cpu;
+	unsigned int total_trans;
+	unsigned long long last_time;
+	unsigned int max_state;
+	unsigned int state_num;
+	unsigned int last_index;
+	unsigned long long *time_in_state;
+	unsigned int *freq_table;
+#ifdef CONFIG_CPU_FREQ_STAT_DETAILS
+	unsigned int *trans_table;
+#endif
+};
+
+static struct cpufreq_stats *cpufreq_stats_table[NR_CPUS];
+
+struct cpufreq_stats_attribute {
+	struct attribute attr;
+	ssize_t(*show) (struct cpufreq_stats *, char *);
+};
+
+static int
+cpufreq_stats_update (unsigned int cpu)
+{
+	struct cpufreq_stats *stat;
+	spin_lock(&cpufreq_stats_lock);
+	stat = cpufreq_stats_table[cpu];
+	if (stat->time_in_state)
+		stat->time_in_state[stat->last_index] +=
+			delta_time(stat->last_time, jiffies);
+	stat->last_time = jiffies;
+	spin_unlock(&cpufreq_stats_lock);
+	return 0;
+}
+
+static ssize_t
+show_total_trans(struct cpufreq_policy *policy, char *buf)
+{
+	struct cpufreq_stats *stat = cpufreq_stats_table[policy->cpu];
+	if(!stat)
+		return 0;
+	return sprintf(buf, "%d\n",
+			cpufreq_stats_table[stat->cpu]->total_trans);
+}
+
+static ssize_t
+show_time_in_state(struct cpufreq_policy *policy, char *buf)
+{
+	ssize_t len = 0;
+	int i;
+	struct cpufreq_stats *stat = cpufreq_stats_table[policy->cpu];
+	if(!stat)
+		return 0;
+	cpufreq_stats_update(stat->cpu);
+	for (i = 0; i < stat->state_num; i++) {
+		len += sprintf(buf + len, "%u %llu\n",
+			stat->freq_table[i], stat->time_in_state[i]);
+	}
+	return len;
+}
+
+#ifdef CONFIG_CPU_FREQ_STAT_DETAILS
+static ssize_t
+show_trans_table(struct cpufreq_policy *policy, char *buf)
+{
+	ssize_t len = 0;
+	int i, j;
+
+	struct cpufreq_stats *stat = cpufreq_stats_table[policy->cpu];
+	if(!stat)
+		return 0;
+	cpufreq_stats_update(stat->cpu);
+	for (i = 0; i < stat->state_num; i++) {
+		if (len >= PAGE_SIZE)
+			break;
+		len += snprintf(buf + len, PAGE_SIZE - len, "%9u:\t",
+				stat->freq_table[i]);
+
+		for (j = 0; j < stat->state_num; j++)   {
+			if (len >= PAGE_SIZE)
+				break;
+			len += snprintf(buf + len, PAGE_SIZE - len, "%u\t",
+					stat->trans_table[i*stat->max_state+j]);
+		}
+		len += snprintf(buf + len, PAGE_SIZE - len, "\n");
+	}
+	return len;
+}
+CPUFREQ_STATDEVICE_ATTR(trans_table,0444,show_trans_table);
+#endif
+
+CPUFREQ_STATDEVICE_ATTR(total_trans,0444,show_total_trans);
+CPUFREQ_STATDEVICE_ATTR(time_in_state,0444,show_time_in_state);
+
+static struct attribute *default_attrs[] = {
+	&_attr_total_trans.attr,
+	&_attr_time_in_state.attr,
+#ifdef CONFIG_CPU_FREQ_STAT_DETAILS
+	&_attr_trans_table.attr,
+#endif
+	NULL
+};
+static struct attribute_group stats_attr_group = {
+	.attrs = default_attrs,
+	.name = "stats"
+};
+
+static int
+freq_table_get_index(struct cpufreq_stats *stat, unsigned int freq)
+{
+	int index;
+	for (index = 0; index < stat->max_state; index++)
+		if (stat->freq_table[index] == freq)
+			return index;
+	return -1;
+}
+
+static void
+cpufreq_stats_free_table (unsigned int cpu)
+{
+	struct cpufreq_stats *stat = cpufreq_stats_table[cpu];
+	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
+	if (policy && policy->cpu == cpu)	
+		sysfs_remove_group(&policy->kobj, &stats_attr_group);
+	if (stat) {
+		kfree(stat->time_in_state);
+		kfree(stat);
+	}
+	cpufreq_stats_table[cpu] = NULL;
+	if (policy)
+		cpufreq_cpu_put(policy);
+}
+
+static int
+cpufreq_stats_create_table (struct cpufreq_policy *policy,
+		struct cpufreq_frequency_table *table)
+{
+	unsigned int i, j, count = 0, ret = 0;
+	struct cpufreq_stats *stat;
+	struct cpufreq_policy *data;
+	unsigned int alloc_size;
+	unsigned int cpu = policy->cpu;
+	if (cpufreq_stats_table[cpu])
+		return -EBUSY;
+	if ((stat = kmalloc(sizeof(struct cpufreq_stats), GFP_KERNEL)) == NULL)
+		return -ENOMEM;
+	memset(stat, 0, sizeof (struct cpufreq_stats));
+
+	data = cpufreq_cpu_get(cpu);
+	if ((ret = sysfs_create_group(&data->kobj, &stats_attr_group)))
+		goto error_out;
+
+	stat->cpu = cpu;
+	cpufreq_stats_table[cpu] = stat;
+
+	for (i=0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
+		unsigned int freq = table[i].frequency;
+		if (freq == CPUFREQ_ENTRY_INVALID)
+			continue;
+		count++;
+	}
+
+	alloc_size = count * sizeof(int) + count * sizeof(long long);
+
+#ifdef CONFIG_CPU_FREQ_STAT_DETAILS
+	alloc_size += count * count * sizeof(int);
+#endif
+	stat->max_state = count;
+	stat->time_in_state = kmalloc(alloc_size, GFP_KERNEL);
+	if (!stat->time_in_state) {
+		ret = -ENOMEM;
+		goto error_out;
+	}
+	memset(stat->time_in_state, 0, alloc_size);
+	stat->freq_table = (unsigned int *)(stat->time_in_state + count);
+
+#ifdef CONFIG_CPU_FREQ_STAT_DETAILS
+	stat->trans_table = stat->freq_table + count;
+#endif
+	j = 0;
+	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {
+		unsigned int freq = table[i].frequency;
+		if (freq == CPUFREQ_ENTRY_INVALID)
+			continue;
+		if (freq_table_get_index(stat, freq) == -1)
+			stat->freq_table[j++] = freq;
+	}
+	stat->state_num = j;
+	spin_lock(&cpufreq_stats_lock);
+	stat->last_time = jiffies;
+	stat->last_index = freq_table_get_index(stat, policy->cur);
+	spin_unlock(&cpufreq_stats_lock);
+	cpufreq_cpu_put(data);
+	return 0;
+error_out:
+	cpufreq_cpu_put(data);
+	kfree(stat);
+	cpufreq_stats_table[cpu] = NULL;
+	return ret;
+}
+
+static int
+cpufreq_stat_notifier_policy (struct notifier_block *nb, unsigned long val,
+		void *data)
+{
+	int ret;
+	struct cpufreq_policy *policy = data;
+	struct cpufreq_frequency_table *table;
+	unsigned int cpu = policy->cpu;
+	if (val != CPUFREQ_NOTIFY)
+		return 0;
+	table = cpufreq_frequency_get_table(cpu);
+	if (!table)
+		return 0;
+	if ((ret = cpufreq_stats_create_table(policy, table)))
+		return ret;
+	return 0;
+}
+
+static int
+cpufreq_stat_notifier_trans (struct notifier_block *nb, unsigned long val,
+		void *data)
+{
+	struct cpufreq_freqs *freq = data;
+	struct cpufreq_stats *stat;
+	int old_index, new_index;
+
+	if (val != CPUFREQ_POSTCHANGE)
+		return 0;
+
+	stat = cpufreq_stats_table[freq->cpu];
+	if (!stat)
+		return 0;
+	old_index = freq_table_get_index(stat, freq->old);
+	new_index = freq_table_get_index(stat, freq->new);
+
+	cpufreq_stats_update(freq->cpu);
+	if (old_index == new_index)
+		return 0;
+
+	spin_lock(&cpufreq_stats_lock);
+	stat->last_index = new_index;
+#ifdef CONFIG_CPU_FREQ_STAT_DETAILS
+	stat->trans_table[old_index * stat->max_state + new_index]++;
+#endif
+	stat->total_trans++;
+	spin_unlock(&cpufreq_stats_lock);
+	return 0;
+}
+
+static struct notifier_block notifier_policy_block = {
+	.notifier_call = cpufreq_stat_notifier_policy
+};
+
+static struct notifier_block notifier_trans_block = {
+	.notifier_call = cpufreq_stat_notifier_trans
+};
+
+static int
+__init cpufreq_stats_init(void)
+{
+	int ret;
+	unsigned int cpu;
+	spin_lock_init(&cpufreq_stats_lock);
+	if ((ret = cpufreq_register_notifier(&notifier_policy_block,
+				CPUFREQ_POLICY_NOTIFIER)))
+		return ret;
+
+	if ((ret = cpufreq_register_notifier(&notifier_trans_block,
+				CPUFREQ_TRANSITION_NOTIFIER))) {
+		cpufreq_unregister_notifier(&notifier_policy_block,
+				CPUFREQ_POLICY_NOTIFIER);
+		return ret;
+	}
+
+	for_each_cpu(cpu)
+		cpufreq_update_policy(cpu);
+	return 0;
+}
+static void
+__exit cpufreq_stats_exit(void)
+{
+	unsigned int cpu;
+	cpufreq_unregister_notifier(&notifier_policy_block,
+			CPUFREQ_POLICY_NOTIFIER);
+	cpufreq_unregister_notifier(&notifier_trans_block,
+			CPUFREQ_TRANSITION_NOTIFIER);
+	for_each_cpu(cpu)
+		cpufreq_stats_free_table(cpu);
+}
+
+MODULE_AUTHOR ("Zou Nan hai <nanhai.zou@intel.com>");
+MODULE_DESCRIPTION ("'cpufreq_stats' - A driver to export cpufreq stats through sysfs filesystem");
+MODULE_LICENSE ("GPL");
+
+module_init(cpufreq_stats_init);
+module_exit(cpufreq_stats_exit);
