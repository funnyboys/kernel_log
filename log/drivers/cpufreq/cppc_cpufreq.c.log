commit 54e74df5d76dea824c7c0c9d1b97150bf9b33793
Author: Xiongfeng Wang <wangxiongfeng2@huawei.com>
Date:   Sat May 30 10:08:31 2020 +0800

    cpufreq: CPPC: add SW BOOST support
    
    To add SW BOOST support for CPPC, we need to get the max frequency of
    boost mode and non-boost mode. ACPI spec 6.2 section 8.4.7.1 describes
    the following two CPC registers.
    
    "Highest performance is the absolute maximum performance an individual
    processor may reach, assuming ideal conditions. This performance level
    may not be sustainable for long durations, and may only be achievable if
    other platform components are in a specific state; for example, it may
    require other processors be in an idle state.
    
    Nominal Performance is the maximum sustained performance level of the
    processor, assuming ideal operating conditions. In absence of an
    external constraint (power, thermal, etc.) this is the performance level
    the platform is expected to be able to maintain continuously. All
    processors are expected to be able to sustain their nominal performance
    state simultaneously."
    
    To add SW BOOST support for CPPC, we can use Highest Performance as the
    max performance in boost mode and Nominal Performance as the max
    performance in non-boost mode. If the Highest Performance is greater
    than the Nominal Performance, we assume SW BOOST is supported.
    
    The current CPPC driver does not support SW BOOST and use 'Highest
    Performance' as the max performance the CPU can achieve. 'Nominal
    Performance' is used to convert 'performance' to 'frequency'. That
    means, if firmware enable boost and provide a value for Highest
    Performance which is greater than Nominal Performance, boost feature is
    enabled by default.
    
    Because SW BOOST is disabled by default, so, after this patch, boost
    feature is disabled by default even if boost is enabled by firmware.
    
    Signed-off-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Suggested-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    [ rjw: Subject ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index bda0b2406fba..257d726a4456 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -37,6 +37,7 @@
  * requested etc.
  */
 static struct cppc_cpudata **all_cpu_data;
+static bool boost_supported;
 
 struct cppc_workaround_oem_info {
 	char oem_id[ACPI_OEM_ID_SIZE + 1];
@@ -310,7 +311,7 @@ static int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)
 	 * Section 8.4.7.1.1.5 of ACPI 6.1 spec)
 	 */
 	policy->min = cppc_cpufreq_perf_to_khz(cpu, cpu->perf_caps.lowest_nonlinear_perf);
-	policy->max = cppc_cpufreq_perf_to_khz(cpu, cpu->perf_caps.highest_perf);
+	policy->max = cppc_cpufreq_perf_to_khz(cpu, cpu->perf_caps.nominal_perf);
 
 	/*
 	 * Set cpuinfo.min_freq to Lowest to make the full range of performance
@@ -318,7 +319,7 @@ static int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)
 	 * nonlinear perf
 	 */
 	policy->cpuinfo.min_freq = cppc_cpufreq_perf_to_khz(cpu, cpu->perf_caps.lowest_perf);
-	policy->cpuinfo.max_freq = cppc_cpufreq_perf_to_khz(cpu, cpu->perf_caps.highest_perf);
+	policy->cpuinfo.max_freq = cppc_cpufreq_perf_to_khz(cpu, cpu->perf_caps.nominal_perf);
 
 	policy->transition_delay_us = cppc_cpufreq_get_transition_delay_us(cpu_num);
 	policy->shared_type = cpu->shared_type;
@@ -343,6 +344,13 @@ static int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)
 
 	cpu->cur_policy = policy;
 
+	/*
+	 * If 'highest_perf' is greater than 'nominal_perf', we assume CPU Boost
+	 * is supported.
+	 */
+	if (cpu->perf_caps.highest_perf > cpu->perf_caps.nominal_perf)
+		boost_supported = true;
+
 	/* Set policy->cur to max now. The governors will adjust later. */
 	policy->cur = cppc_cpufreq_perf_to_khz(cpu,
 					cpu->perf_caps.highest_perf);
@@ -410,6 +418,32 @@ static unsigned int cppc_cpufreq_get_rate(unsigned int cpunum)
 	return cppc_get_rate_from_fbctrs(cpu, fb_ctrs_t0, fb_ctrs_t1);
 }
 
+static int cppc_cpufreq_set_boost(struct cpufreq_policy *policy, int state)
+{
+	struct cppc_cpudata *cpudata;
+	int ret;
+
+	if (!boost_supported) {
+		pr_err("BOOST not supported by CPU or firmware\n");
+		return -EINVAL;
+	}
+
+	cpudata = all_cpu_data[policy->cpu];
+	if (state)
+		policy->max = cppc_cpufreq_perf_to_khz(cpudata,
+					cpudata->perf_caps.highest_perf);
+	else
+		policy->max = cppc_cpufreq_perf_to_khz(cpudata,
+					cpudata->perf_caps.nominal_perf);
+	policy->cpuinfo.max_freq = policy->max;
+
+	ret = freq_qos_update_request(policy->max_freq_req, policy->max);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
 static struct cpufreq_driver cppc_cpufreq_driver = {
 	.flags = CPUFREQ_CONST_LOOPS,
 	.verify = cppc_verify_policy,
@@ -417,6 +451,7 @@ static struct cpufreq_driver cppc_cpufreq_driver = {
 	.get = cppc_cpufreq_get_rate,
 	.init = cppc_cpufreq_cpu_init,
 	.stop_cpu = cppc_cpufreq_stop_cpu,
+	.set_boost = cppc_cpufreq_set_boost,
 	.name = "cppc_cpufreq",
 };
 

commit 1e4f63aecb53e48468661e922fc2fa3b83e55722
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Sun Jan 26 23:40:11 2020 +0100

    cpufreq: Avoid creating excessively large stack frames
    
    In the process of modifying a cpufreq policy, the cpufreq core makes
    a copy of it including all of the internals which is stored on the
    CPU stack.  Because struct cpufreq_policy is relatively large, this
    may cause the size of the stack frame to exceed the 2 KB limit and
    so the GCC complains when -Wframe-larger-than= is used.
    
    In fact, it is not necessary to copy the entire policy structure
    in order to modify it, however.
    
    First, because cpufreq_set_policy() obtains the min and max policy
    limits from frequency QoS now, it is not necessary to pass the limits
    to it from the callers.  The only things that need to be passed to it
    from there are the new governor pointer or (if there is a built-in
    governor in the driver) the "policy" value representing the governor
    choice.  They both can be passed as individual arguments, though, so
    make cpufreq_set_policy() take them this way and rework its callers
    accordingly.  This avoids making copies of cpufreq policies in the
    callers of cpufreq_set_policy().
    
    Second, cpufreq_set_policy() still needs to pass the new policy
    data to the ->verify() callback of the cpufreq driver whose task
    is to sanitize the min and max policy limits.  It still does not
    need to make a full copy of struct cpufreq_policy for this purpose,
    but it needs to pass a few items from it to the driver in case they
    are needed (different drivers have different needs in that respect
    and all of them have to be covered).  For this reason, introduce
    struct cpufreq_policy_data to hold copies of the members of
    struct cpufreq_policy used by the existing ->verify() driver
    callbacks and pass a pointer to a temporary structure of that
    type to ->verify() (instead of passing a pointer to full struct
    cpufreq_policy to it).
    
    While at it, notice that intel_pstate and longrun don't really need
    to verify the "policy" value in struct cpufreq_policy, so drop those
    check from them to avoid copying "policy" into struct
    cpufreq_policy_data (which allows it to be slightly smaller).
    
    Also while at it fix up white space in a couple of places and make
    cpufreq_set_policy() static (as it can be so).
    
    Fixes: 3000ce3c52f8 ("cpufreq: Use per-policy frequency QoS")
    Link: https://lore.kernel.org/linux-pm/CAMuHMdX6-jb1W8uC2_237m8ctCpsnGp=JCxqt8pCWVqNXHmkVg@mail.gmail.com
    Reported-by: kbuild test robot <lkp@intel.com>
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index a06777c35fc0..bda0b2406fba 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -221,7 +221,7 @@ static int cppc_cpufreq_set_target(struct cpufreq_policy *policy,
 	return ret;
 }
 
-static int cppc_verify_policy(struct cpufreq_policy *policy)
+static int cppc_verify_policy(struct cpufreq_policy_data *policy)
 {
 	cpufreq_verify_within_cpu_limits(policy);
 	return 0;

commit 80e8b1e59f0399b94a6088bcb9477bd798cc5eba
Author: Hanjun Guo <guohanjun@huawei.com>
Date:   Tue Dec 24 09:56:30 2019 +0800

    cpufreq: CPPC: put ACPI table after using it
    
    Put the ACPI table to release the table mapping after using it
    successfully.
    
    Signed-off-by: Hanjun Guo <guohanjun@huawei.com>
    [ rjw: Subject & changelog ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index d0ca3007b4f2..a06777c35fc0 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -98,6 +98,8 @@ static void cppc_check_hisi_workaround(void)
 			break;
 		}
 	}
+
+	acpi_put_table(tbl);
 }
 
 /* Callback function used to retrieve the max frequency from DMI */

commit c740237937c039c06e9cda32b9a37dde8b0d1e63
Author: Hanjun Guo <guohanjun@huawei.com>
Date:   Tue Dec 24 09:56:29 2019 +0800

    cpufreq : CPPC: Break out if HiSilicon CPPC workaround is matched
    
    Bail out if we match the OEM information, to save some possible
    extra iteration.
    
    Also update the code to fix minor coding style issue.
    
    Signed-off-by: Hanjun Guo <guohanjun@huawei.com>
    [ rjw: Subject ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index 8d8da763adc5..d0ca3007b4f2 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -39,7 +39,7 @@
 static struct cppc_cpudata **all_cpu_data;
 
 struct cppc_workaround_oem_info {
-	char oem_id[ACPI_OEM_ID_SIZE +1];
+	char oem_id[ACPI_OEM_ID_SIZE + 1];
 	char oem_table_id[ACPI_OEM_TABLE_ID_SIZE + 1];
 	u32 oem_revision;
 };
@@ -93,8 +93,10 @@ static void cppc_check_hisi_workaround(void)
 	for (i = 0; i < ARRAY_SIZE(wa_info); i++) {
 		if (!memcmp(wa_info[i].oem_id, tbl->oem_id, ACPI_OEM_ID_SIZE) &&
 		    !memcmp(wa_info[i].oem_table_id, tbl->oem_table_id, ACPI_OEM_TABLE_ID_SIZE) &&
-		    wa_info[i].oem_revision == tbl->oem_revision)
+		    wa_info[i].oem_revision == tbl->oem_revision) {
 			apply_hisi_workaround = true;
+			break;
+		}
 	}
 }
 

commit b886d83c5b621abc84ff9616f14c529be3f6b147
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:55 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 441
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 of the license
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 315 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190115.503150771@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index 2ae978d27e61..8d8da763adc5 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * CPPC (Collaborative Processor Performance Control) driver for
  * interfacing with the CPUfreq layer and governors. See
@@ -5,11 +6,6 @@
  *
  * (C) Copyright 2014, 2015 Linaro Ltd.
  * Author: Ashwin Chaugule <ashwin.chaugule@linaro.org>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; version 2
- * of the License.
  */
 
 #define pr_fmt(fmt)	"CPPC Cpufreq:"	fmt

commit 6c8d750f9784cef32a8cffdad74c8a351b4ca3a6
Author: Xiongfeng Wang <wangxiongfeng2@huawei.com>
Date:   Sun Feb 17 11:54:15 2019 +0800

    cpufreq / cppc: Work around for Hisilicon CPPC cpufreq
    
    Hisilicon chips do not support delivered performance counter register
    and reference performance counter register. But the platform can
    calculate the real performance using its own method. We reuse the
    desired performance register to store the real performance calculated by
    the platform. After the platform finished the frequency adjust, it gets
    the real performance and writes it into desired performance register. Os
    can use it to calculate the real frequency.
    
    Signed-off-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    [ rjw: Drop unnecessary braces ]
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index fd25c21cee72..2ae978d27e61 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -42,6 +42,66 @@
  */
 static struct cppc_cpudata **all_cpu_data;
 
+struct cppc_workaround_oem_info {
+	char oem_id[ACPI_OEM_ID_SIZE +1];
+	char oem_table_id[ACPI_OEM_TABLE_ID_SIZE + 1];
+	u32 oem_revision;
+};
+
+static bool apply_hisi_workaround;
+
+static struct cppc_workaround_oem_info wa_info[] = {
+	{
+		.oem_id		= "HISI  ",
+		.oem_table_id	= "HIP07   ",
+		.oem_revision	= 0,
+	}, {
+		.oem_id		= "HISI  ",
+		.oem_table_id	= "HIP08   ",
+		.oem_revision	= 0,
+	}
+};
+
+static unsigned int cppc_cpufreq_perf_to_khz(struct cppc_cpudata *cpu,
+					unsigned int perf);
+
+/*
+ * HISI platform does not support delivered performance counter and
+ * reference performance counter. It can calculate the performance using the
+ * platform specific mechanism. We reuse the desired performance register to
+ * store the real performance calculated by the platform.
+ */
+static unsigned int hisi_cppc_cpufreq_get_rate(unsigned int cpunum)
+{
+	struct cppc_cpudata *cpudata = all_cpu_data[cpunum];
+	u64 desired_perf;
+	int ret;
+
+	ret = cppc_get_desired_perf(cpunum, &desired_perf);
+	if (ret < 0)
+		return -EIO;
+
+	return cppc_cpufreq_perf_to_khz(cpudata, desired_perf);
+}
+
+static void cppc_check_hisi_workaround(void)
+{
+	struct acpi_table_header *tbl;
+	acpi_status status = AE_OK;
+	int i;
+
+	status = acpi_get_table(ACPI_SIG_PCCT, 0, &tbl);
+	if (ACPI_FAILURE(status) || !tbl)
+		return;
+
+	for (i = 0; i < ARRAY_SIZE(wa_info); i++) {
+		if (!memcmp(wa_info[i].oem_id, tbl->oem_id, ACPI_OEM_ID_SIZE) &&
+		    !memcmp(wa_info[i].oem_table_id, tbl->oem_table_id, ACPI_OEM_TABLE_ID_SIZE) &&
+		    wa_info[i].oem_revision == tbl->oem_revision)
+			apply_hisi_workaround = true;
+	}
+}
+
 /* Callback function used to retrieve the max frequency from DMI */
 static void cppc_find_dmi_mhz(const struct dmi_header *dm, void *private)
 {
@@ -334,6 +394,9 @@ static unsigned int cppc_cpufreq_get_rate(unsigned int cpunum)
 	struct cppc_cpudata *cpu = all_cpu_data[cpunum];
 	int ret;
 
+	if (apply_hisi_workaround)
+		return hisi_cppc_cpufreq_get_rate(cpunum);
+
 	ret = cppc_get_perf_ctrs(cpunum, &fb_ctrs_t0);
 	if (ret)
 		return ret;
@@ -386,6 +449,8 @@ static int __init cppc_cpufreq_init(void)
 		goto out;
 	}
 
+	cppc_check_hisi_workaround();
+
 	ret = cpufreq_register_driver(&cppc_cpufreq_driver);
 	if (ret)
 		goto out;

commit 8ff3c22688ff3616ee53c5c54b3ee66a73326175
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Tue Oct 2 15:34:57 2018 -0700

    cpufreq / CPPC: Mark acpi_ids as used
    
    Clang warns:
    
    drivers/cpufreq/cppc_cpufreq.c:431:36: warning: variable 'cppc_acpi_ids'
    is not needed and will not be emitted [-Wunneeded-internal-declaration]
    static const struct acpi_device_id cppc_acpi_ids[] = {
                                       ^
    1 warning generated.
    
    Mark the definition as used so that Clang understands we don't want this
    warning while not inhibiting Clang's dead code elimination from removing
    the unreferenced internal symbol when moving the data it contains to the
    globally available symbol via MODULE_DEVICE_TABLE.
    
    $ nm -S drivers/cpufreq/cppc_cpufreq.o | grep acpi | tail -1
    0000000000000000 0000000000000040 R __mod_acpi__cppc_acpi_ids_device_table
    
    Suggested-by: Nick Desaulniers <ndesaulniers@google.com>
    Reviewed-by: Nick Desaulniers <ndesaulniers@google.com>
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index 30f302149730..fd25c21cee72 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -428,7 +428,7 @@ MODULE_LICENSE("GPL");
 
 late_initcall(cppc_cpufreq_init);
 
-static const struct acpi_device_id cppc_acpi_ids[] = {
+static const struct acpi_device_id cppc_acpi_ids[] __used = {
 	{ACPI_PROCESSOR_DEVICE_HID, },
 	{}
 };

commit 33477d84c26bbfa626da2c032e567a90dd70a528
Author: George Cherian <george.cherian@cavium.com>
Date:   Wed Jul 11 23:07:55 2018 -0700

    cpufreq / CPPC: Add cpuinfo_cur_freq support for CPPC
    
    Per Section 8.4.7.1.3 of ACPI 6.2, the platform provides performance
    feedback via set of performance counters. To determine the actual
    performance level delivered over time, OSPM may read a set of
    performance counters from the Reference Performance Counter Register
    and the Delivered Performance Counter Register.
    
    OSPM calculates the delivered performance over a given time period by
    taking a beginning and ending snapshot of both the reference and
    delivered performance counters, and calculating:
    
    delivered_perf = reference_perf X (delta of delivered_perf counter / delta of reference_perf counter).
    
    Implement the above and hook this up to the cpufreq->get method.
    
    Signed-off-by: George Cherian <george.cherian@cavium.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Prashanth Prakash <pprakash@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index a9d3eec32795..30f302149730 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -296,10 +296,62 @@ static int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)
 	return ret;
 }
 
+static inline u64 get_delta(u64 t1, u64 t0)
+{
+	if (t1 > t0 || t0 > ~(u32)0)
+		return t1 - t0;
+
+	return (u32)t1 - (u32)t0;
+}
+
+static int cppc_get_rate_from_fbctrs(struct cppc_cpudata *cpu,
+				     struct cppc_perf_fb_ctrs fb_ctrs_t0,
+				     struct cppc_perf_fb_ctrs fb_ctrs_t1)
+{
+	u64 delta_reference, delta_delivered;
+	u64 reference_perf, delivered_perf;
+
+	reference_perf = fb_ctrs_t0.reference_perf;
+
+	delta_reference = get_delta(fb_ctrs_t1.reference,
+				    fb_ctrs_t0.reference);
+	delta_delivered = get_delta(fb_ctrs_t1.delivered,
+				    fb_ctrs_t0.delivered);
+
+	/* Check to avoid divide-by zero */
+	if (delta_reference || delta_delivered)
+		delivered_perf = (reference_perf * delta_delivered) /
+					delta_reference;
+	else
+		delivered_perf = cpu->perf_ctrls.desired_perf;
+
+	return cppc_cpufreq_perf_to_khz(cpu, delivered_perf);
+}
+
+static unsigned int cppc_cpufreq_get_rate(unsigned int cpunum)
+{
+	struct cppc_perf_fb_ctrs fb_ctrs_t0 = {0}, fb_ctrs_t1 = {0};
+	struct cppc_cpudata *cpu = all_cpu_data[cpunum];
+	int ret;
+
+	ret = cppc_get_perf_ctrs(cpunum, &fb_ctrs_t0);
+	if (ret)
+		return ret;
+
+	udelay(2); /* 2usec delay between sampling */
+
+	ret = cppc_get_perf_ctrs(cpunum, &fb_ctrs_t1);
+	if (ret)
+		return ret;
+
+	return cppc_get_rate_from_fbctrs(cpu, fb_ctrs_t0, fb_ctrs_t1);
+}
+
 static struct cpufreq_driver cppc_cpufreq_driver = {
 	.flags = CPUFREQ_CONST_LOOPS,
 	.verify = cppc_verify_policy,
 	.target = cppc_cpufreq_set_target,
+	.get = cppc_cpufreq_get_rate,
 	.init = cppc_cpufreq_cpu_init,
 	.stop_cpu = cppc_cpufreq_stop_cpu,
 	.name = "cppc_cpufreq",

commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:03:40 2018 -0700

    treewide: kzalloc() -> kcalloc()
    
    The kzalloc() function has a 2-factor argument form, kcalloc(). This
    patch replaces cases of:
    
            kzalloc(a * b, gfp)
    
    with:
            kcalloc(a * b, gfp)
    
    as well as handling cases of:
    
            kzalloc(a * b * c, gfp)
    
    with:
    
            kzalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kzalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kzalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kzalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kzalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kzalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kzalloc
    + kcalloc
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kzalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(sizeof(THING) * C2, ...)
    |
      kzalloc(sizeof(TYPE) * C2, ...)
    |
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(C1 * C2, ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index 3464580ac3ca..a9d3eec32795 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -313,7 +313,8 @@ static int __init cppc_cpufreq_init(void)
 	if (acpi_disabled)
 		return -ENODEV;
 
-	all_cpu_data = kzalloc(sizeof(void *) * num_possible_cpus(), GFP_KERNEL);
+	all_cpu_data = kcalloc(num_possible_cpus(), sizeof(void *),
+			       GFP_KERNEL);
 	if (!all_cpu_data)
 		return -ENOMEM;
 

commit 6c128e798f5b481c22cd3f7a8d5df16f1a77ea7e
Merge: ba609f7f21e4 8f8027c5f935 63fab6977a1f ec625a37c10c 91ea5b1dd3ae
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 4 10:43:34 2018 +0200

    Merge branches 'acpi-cppc', 'acpi-misc', 'acpi-battery' and 'acpi-ac'
    
    * acpi-cppc:
      mailbox: PCC: erroneous error message when parsing ACPI PCCT
      ACPI / CPPC: Fix invalid PCC channel status errors
      ACPI / CPPC: Document CPPC sysfs interface
      cpufreq / CPPC: Support for CPPC v3
      ACPI / CPPC: Check for valid PCC subspace only if PCC is used
      ACPI / CPPC: Add support for CPPC v3
    
    * acpi-misc:
      ACPI: Add missing prototype_for arch_post_acpi_subsys_init()
      ACPI: add missing newline to printk
    
    * acpi-battery:
      ACPI / battery: Add quirk to avoid checking for PMIC with native driver
      ACPI / battery: Ignore AC state in handle_discharging on systems where it is broken
      ACPI / battery: Add handling for devices which wrongly report discharging state
      ACPI / battery: Remove initializer for unused ident dmi_system_id
      ACPI / AC: Remove initializer for unused ident dmi_system_id
    
    * acpi-ac:
      ACPI / AC: Add quirk to avoid checking for PMIC with native driver

commit d4f3388afd488ed15368fa7413b8bd6d1f98bb1d
Author: Prashanth Prakash <pprakash@codeaurora.org>
Date:   Fri Apr 27 11:35:27 2018 -0600

    cpufreq / CPPC: Set platform specific transition_delay_us
    
    Add support to specify platform specific transition_delay_us instead
    of using the transition delay derived from PCC.
    
    With commit 3d41386d556d (cpufreq: CPPC: Use transition_delay_us
    depending transition_latency) we are setting transition_delay_us
    directly and not applying the LATENCY_MULTIPLIER. Because of that,
    on Qualcomm Centriq we can end up with a very high rate of frequency
    change requests when using the schedutil governor (default
    rate_limit_us=10 compared to an earlier value of 10000).
    
    The PCC subspace describes the rate at which the platform can accept
    commands on the CPPC's PCC channel. This includes read and write
    command on the PCC channel that can be used for reasons other than
    frequency transitions. Moreover the same PCC subspace can be used by
    multiple freq domains and deriving transition_delay_us from it as we
    do now can be sub-optimal.
    
    Moreover if a platform does not use PCC for desired_perf register then
    there is no way to compute the transition latency or the delay_us.
    
    CPPC does not have a standard defined mechanism to get the transition
    rate or the latency at the moment.
    
    Given the above limitations, it is simpler to have a platform specific
    transition_delay_us and rely on PCC derived value only if a platform
    specific value is not available.
    
    Signed-off-by: Prashanth Prakash <pprakash@codeaurora.org>
    Cc: 4.14+ <stable@vger.kernel.org> # 4.14+
    Fixes: 3d41386d556d (cpufreq: CPPC: Use transition_delay_us depending transition_latency)
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index bc5fc1630876..b15115a48775 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -126,6 +126,49 @@ static void cppc_cpufreq_stop_cpu(struct cpufreq_policy *policy)
 				cpu->perf_caps.lowest_perf, cpu_num, ret);
 }
 
+/*
+ * The PCC subspace describes the rate at which platform can accept commands
+ * on the shared PCC channel (including READs which do not count towards freq
+ * trasition requests), so ideally we need to use the PCC values as a fallback
+ * if we don't have a platform specific transition_delay_us
+ */
+#ifdef CONFIG_ARM64
+#include <asm/cputype.h>
+
+static unsigned int cppc_cpufreq_get_transition_delay_us(int cpu)
+{
+	unsigned long implementor = read_cpuid_implementor();
+	unsigned long part_num = read_cpuid_part_number();
+	unsigned int delay_us = 0;
+
+	switch (implementor) {
+	case ARM_CPU_IMP_QCOM:
+		switch (part_num) {
+		case QCOM_CPU_PART_FALKOR_V1:
+		case QCOM_CPU_PART_FALKOR:
+			delay_us = 10000;
+			break;
+		default:
+			delay_us = cppc_get_transition_latency(cpu) / NSEC_PER_USEC;
+			break;
+		}
+		break;
+	default:
+		delay_us = cppc_get_transition_latency(cpu) / NSEC_PER_USEC;
+		break;
+	}
+
+	return delay_us;
+}
+
+#else
+
+static unsigned int cppc_cpufreq_get_transition_delay_us(int cpu)
+{
+	return cppc_get_transition_latency(cpu) / NSEC_PER_USEC;
+}
+#endif
+
 static int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)
 {
 	struct cppc_cpudata *cpu;
@@ -162,8 +205,7 @@ static int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)
 		cpu->perf_caps.highest_perf;
 	policy->cpuinfo.max_freq = cppc_dmi_max_khz;
 
-	policy->transition_delay_us = cppc_get_transition_latency(cpu_num) /
-		NSEC_PER_USEC;
+	policy->transition_delay_us = cppc_cpufreq_get_transition_delay_us(cpu_num);
 	policy->shared_type = cpu->shared_type;
 
 	if (policy->shared_type == CPUFREQ_SHARED_TYPE_ANY) {

commit 256f19d212f260c955a90a0efc7753e11b18e34c
Author: Prashanth Prakash <pprakash@codeaurora.org>
Date:   Wed Apr 4 12:14:52 2018 -0600

    cpufreq / CPPC: Support for CPPC v3
    
    Use CPPC v3 entries to convert the abstract processor performance to
    processor frequency in KHz.
    
    Signed-off-by: Prashanth Prakash <pprakash@codeaurora.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index bc5fc1630876..e67e94b0ec14 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -42,9 +42,6 @@
  */
 static struct cppc_cpudata **all_cpu_data;
 
-/* Capture the max KHz from DMI */
-static u64 cppc_dmi_max_khz;
-
 /* Callback function used to retrieve the max frequency from DMI */
 static void cppc_find_dmi_mhz(const struct dmi_header *dm, void *private)
 {
@@ -75,6 +72,64 @@ static u64 cppc_get_dmi_max_khz(void)
 	return (1000 * mhz);
 }
 
+/*
+ * If CPPC lowest_freq and nominal_freq registers are exposed then we can
+ * use them to convert perf to freq and vice versa
+ *
+ * If the perf/freq point lies between Nominal and Lowest, we can treat
+ * (Low perf, Low freq) and (Nom Perf, Nom freq) as 2D co-ordinates of a line
+ * and extrapolate the rest
+ * For perf/freq > Nominal, we use the ratio perf:freq at Nominal for conversion
+ */
+static unsigned int cppc_cpufreq_perf_to_khz(struct cppc_cpudata *cpu,
+					unsigned int perf)
+{
+	static u64 max_khz;
+	struct cppc_perf_caps *caps = &cpu->perf_caps;
+	u64 mul, div;
+
+	if (caps->lowest_freq && caps->nominal_freq) {
+		if (perf >= caps->nominal_perf) {
+			mul = caps->nominal_freq;
+			div = caps->nominal_perf;
+		} else {
+			mul = caps->nominal_freq - caps->lowest_freq;
+			div = caps->nominal_perf - caps->lowest_perf;
+		}
+	} else {
+		if (!max_khz)
+			max_khz = cppc_get_dmi_max_khz();
+		mul = max_khz;
+		div = cpu->perf_caps.highest_perf;
+	}
+	return (u64)perf * mul / div;
+}
+
+static unsigned int cppc_cpufreq_khz_to_perf(struct cppc_cpudata *cpu,
+					unsigned int freq)
+{
+	static u64 max_khz;
+	struct cppc_perf_caps *caps = &cpu->perf_caps;
+	u64  mul, div;
+
+	if (caps->lowest_freq && caps->nominal_freq) {
+		if (freq >= caps->nominal_freq) {
+			mul = caps->nominal_perf;
+			div = caps->nominal_freq;
+		} else {
+			mul = caps->lowest_perf;
+			div = caps->lowest_freq;
+		}
+	} else {
+		if (!max_khz)
+			max_khz = cppc_get_dmi_max_khz();
+		mul = cpu->perf_caps.highest_perf;
+		div = max_khz;
+	}
+
+	return (u64)freq * mul / div;
+}
+
 static int cppc_cpufreq_set_target(struct cpufreq_policy *policy,
 		unsigned int target_freq,
 		unsigned int relation)
@@ -86,7 +141,7 @@ static int cppc_cpufreq_set_target(struct cpufreq_policy *policy,
 
 	cpu = all_cpu_data[policy->cpu];
 
-	desired_perf = (u64)target_freq * cpu->perf_caps.highest_perf / cppc_dmi_max_khz;
+	desired_perf = cppc_cpufreq_khz_to_perf(cpu, target_freq);
 	/* Return if it is exactly the same perf */
 	if (desired_perf == cpu->perf_ctrls.desired_perf)
 		return ret;
@@ -143,24 +198,24 @@ static int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)
 		return ret;
 	}
 
-	cppc_dmi_max_khz = cppc_get_dmi_max_khz();
+	/* Convert the lowest and nominal freq from MHz to KHz */
+	cpu->perf_caps.lowest_freq *= 1000;
+	cpu->perf_caps.nominal_freq *= 1000;
 
 	/*
 	 * Set min to lowest nonlinear perf to avoid any efficiency penalty (see
 	 * Section 8.4.7.1.1.5 of ACPI 6.1 spec)
 	 */
-	policy->min = cpu->perf_caps.lowest_nonlinear_perf * cppc_dmi_max_khz /
-		cpu->perf_caps.highest_perf;
-	policy->max = cppc_dmi_max_khz;
+	policy->min = cppc_cpufreq_perf_to_khz(cpu, cpu->perf_caps.lowest_nonlinear_perf);
+	policy->max = cppc_cpufreq_perf_to_khz(cpu, cpu->perf_caps.highest_perf);
 
 	/*
 	 * Set cpuinfo.min_freq to Lowest to make the full range of performance
 	 * available if userspace wants to use any perf between lowest & lowest
 	 * nonlinear perf
 	 */
-	policy->cpuinfo.min_freq = cpu->perf_caps.lowest_perf * cppc_dmi_max_khz /
-		cpu->perf_caps.highest_perf;
-	policy->cpuinfo.max_freq = cppc_dmi_max_khz;
+	policy->cpuinfo.min_freq = cppc_cpufreq_perf_to_khz(cpu, cpu->perf_caps.lowest_perf);
+	policy->cpuinfo.max_freq = cppc_cpufreq_perf_to_khz(cpu, cpu->perf_caps.highest_perf);
 
 	policy->transition_delay_us = cppc_get_transition_latency(cpu_num) /
 		NSEC_PER_USEC;
@@ -187,7 +242,8 @@ static int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)
 	cpu->cur_policy = policy;
 
 	/* Set policy->cur to max now. The governors will adjust later. */
-	policy->cur = cppc_dmi_max_khz;
+	policy->cur = cppc_cpufreq_perf_to_khz(cpu,
+					cpu->perf_caps.highest_perf);
 	cpu->perf_ctrls.desired_perf = cpu->perf_caps.highest_perf;
 
 	ret = cppc_set_perf(cpu_num, &cpu->perf_ctrls);

commit 8913315e9459b146e5888ab5138e10daa061b885
Author: Shunyong Yang <shunyong.yang@hxt-semitech.com>
Date:   Fri Apr 6 10:43:49 2018 +0800

    cpufreq: CPPC: Initialize shared perf capabilities of CPUs
    
    When multiple CPUs are related in one cpufreq policy, the first online
    CPU will be chosen by default to handle cpufreq operations. Let's take
    cpu0 and cpu1 as an example.
    
    When cpu0 is offline, policy->cpu will be shifted to cpu1. cpu1's perf
    capabilities should be initialized. Otherwise, perf capabilities are 0s
    and speed change can not take effect.
    
    This patch copies perf capabilities of the first online CPU to other
    shared CPUs when policy shared type is CPUFREQ_SHARED_TYPE_ANY.
    
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Shunyong Yang <shunyong.yang@hxt-semitech.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index 38f65c371139..bc5fc1630876 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -166,9 +166,19 @@ static int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)
 		NSEC_PER_USEC;
 	policy->shared_type = cpu->shared_type;
 
-	if (policy->shared_type == CPUFREQ_SHARED_TYPE_ANY)
+	if (policy->shared_type == CPUFREQ_SHARED_TYPE_ANY) {
+		int i;
+
 		cpumask_copy(policy->cpus, cpu->shared_cpu_map);
-	else if (policy->shared_type == CPUFREQ_SHARED_TYPE_ALL) {
+
+		for_each_cpu(i, policy->cpus) {
+			if (unlikely(i == policy->cpu))
+				continue;
+
+			memcpy(&all_cpu_data[i]->perf_caps, &cpu->perf_caps,
+			       sizeof(cpu->perf_caps));
+		}
+	} else if (policy->shared_type == CPUFREQ_SHARED_TYPE_ALL) {
 		/* Support only SW_ANY for now. */
 		pr_debug("Unsupported CPU co-ord type\n");
 		return -EFAULT;

commit b8b10bc2015cd91350aac68447377c8410a48865
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Apr 2 12:50:53 2018 +0530

    cpufreq: CPPC: Don't set transition_latency
    
    Now that the driver has started to set transition_delay_us directly,
    there is no need to set transition_latency along with it, as it is not
    used by the cpufreq core.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index 8300a9fcb80c..38f65c371139 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -162,7 +162,6 @@ static int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)
 		cpu->perf_caps.highest_perf;
 	policy->cpuinfo.max_freq = cppc_dmi_max_khz;
 
-	policy->cpuinfo.transition_latency = cppc_get_transition_latency(cpu_num);
 	policy->transition_delay_us = cppc_get_transition_latency(cpu_num) /
 		NSEC_PER_USEC;
 	policy->shared_type = cpu->shared_type;

commit 3d41386d556db9f720e00de3e11e45f39cb5071c
Author: George Cherian <george.cherian@cavium.com>
Date:   Fri Mar 23 03:30:31 2018 -0700

    cpufreq: CPPC: Use transition_delay_us depending transition_latency
    
    With commit e948bc8fbee0 (cpufreq: Cap the default transition delay
    value to 10 ms)  the cpufreq was not honouring the delay passed via
    ACPI (PCCT). Due to which on ARM based platforms using CPPC the
    cpufreq governor tries to change the frequency of CPUs faster than
    expected.
    
    This leads to continuous error messages like the following.
    " ACPI CPPC: PCC check channel failed. Status=0 "
    
    Earlier (without above commit) the default transition delay was
    taken form the value passed from PCCT. Use the same value provided
    by PCCT to set the transition_delay_us.
    
    Fixes: e948bc8fbee0 (cpufreq: Cap the default transition delay value to 10 ms)
    Signed-off-by: George Cherian <george.cherian@cavium.com>
    Cc: 4.14+ <stable@vger.kernel.org> # 4.14+
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index 8f7b21a4d537..8300a9fcb80c 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -20,6 +20,7 @@
 #include <linux/cpu.h>
 #include <linux/cpufreq.h>
 #include <linux/dmi.h>
+#include <linux/time.h>
 #include <linux/vmalloc.h>
 
 #include <asm/unaligned.h>
@@ -162,6 +163,8 @@ static int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)
 	policy->cpuinfo.max_freq = cppc_dmi_max_khz;
 
 	policy->cpuinfo.transition_latency = cppc_get_transition_latency(cpu_num);
+	policy->transition_delay_us = cppc_get_transition_latency(cpu_num) /
+		NSEC_PER_USEC;
 	policy->shared_type = cpu->shared_type;
 
 	if (policy->shared_type == CPUFREQ_SHARED_TYPE_ANY)

commit 55b55abc17f238c61921360e61dde90dd9a326d1
Author: Chunyu Hu <chuhu@redhat.com>
Date:   Mon Mar 5 13:40:38 2018 +0800

    cpufreq: cppc_cpufreq: Fix cppc_cpufreq_init() failure path
    
    Kmemleak reported the below leak. When cppc_cpufreq_init went into
    failure path, the cpu mask is not freed. After fix, this report is
    gone. And to avaoid potential NULL pointer reference, check the cpu
    value first.
    
    unreferenced object 0xffff800fd5ea4880 (size 128):
      comm "swapper/0", pid 1, jiffies 4294939510 (age 668.680s)
      hex dump (first 32 bytes):
        00 00 00 00 20 00 00 00 00 00 00 00 00 00 00 00  .... ...........
        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
      backtrace:
        [<ffff0000082c4ae4>] __kmalloc_node+0x278/0x634
        [<ffff0000088f4a74>] alloc_cpumask_var_node+0x28/0x60
        [<ffff0000088f4af0>] zalloc_cpumask_var+0x14/0x1c
        [<ffff000008d20254>] cppc_cpufreq_init+0xd0/0x19c
        [<ffff000008083828>] do_one_initcall+0xec/0x15c
        [<ffff000008cd1018>] kernel_init_freeable+0x1f4/0x2a4
        [<ffff0000089099b0>] kernel_init+0x18/0x10c
        [<ffff000008084d50>] ret_from_fork+0x10/0x18
        [<ffffffffffffffff>] 0xffffffffffffffff
    
    Signed-off-by: Chunyu Hu <chuhu@redhat.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index a1c3025f9df7..8f7b21a4d537 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -230,8 +230,13 @@ static int __init cppc_cpufreq_init(void)
 	return ret;
 
 out:
-	for_each_possible_cpu(i)
-		kfree(all_cpu_data[i]);
+	for_each_possible_cpu(i) {
+		cpu = all_cpu_data[i];
+		if (!cpu)
+			break;
+		free_cpumask_var(cpu->shared_cpu_map);
+		kfree(cpu);
+	}
 
 	kfree(all_cpu_data);
 	return -ENODEV;

commit b20a3f3d8a3516dcde2d1fb130169f336bc93023
Author: Sudeep Holla <Sudeep.Holla@arm.com>
Date:   Thu Aug 10 15:58:57 2017 +0100

    cpufreq: remove setting of policy->cpu in policy->cpus during init
    
    policy->cpu is copied into policy->cpus in cpufreq_online() before
    calling into cpufreq_driver->init(). So there's no need to set the
    same in the individual driver init() functions again.
    
    This patch removes the redundant setting of policy->cpu in policy->cpus
    in intel_pstate and cppc drivers.
    
    Reported-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index 10be285c9055..a1c3025f9df7 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -172,7 +172,6 @@ static int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)
 		return -EFAULT;
 	}
 
-	cpumask_set_cpu(policy->cpu, policy->cpus);
 	cpu->cur_policy = policy;
 
 	/* Set policy->cur to max now. The governors will adjust later. */

commit 73808d0fd26b3d3f0f44cc7c469ad1d3c1b570b8
Author: Prakash, Prashanth <pprakash@codeaurora.org>
Date:   Thu May 11 16:39:44 2017 -0600

    cpufreq / CPPC: Initialize policy->min to lowest nonlinear performance
    
    Description of Lowest Perfomance in ACPI 6.1 specification states:
    "Lowest Performance is the absolute lowest performance level of
    the platform. Selecting a performance level lower than the lowest
    nonlinear performance level may actually cause an efficiency penalty,
    but should reduce the instantaneous power consumption of the processor.
    In traditional terms, this represents the T-state range of performance
    levels."
    
    Set the default value of policy->min to Lowest Nonlinear Performance
    to avoid any potential efficiency penalty.
    
    Signed-off-by: Prashanth Prakash <pprakash@codeaurora.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alexey Klimov <alexey.klimov@arm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index e82bb3c30b92..10be285c9055 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -144,10 +144,23 @@ static int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)
 
 	cppc_dmi_max_khz = cppc_get_dmi_max_khz();
 
-	policy->min = cpu->perf_caps.lowest_perf * cppc_dmi_max_khz / cpu->perf_caps.highest_perf;
+	/*
+	 * Set min to lowest nonlinear perf to avoid any efficiency penalty (see
+	 * Section 8.4.7.1.1.5 of ACPI 6.1 spec)
+	 */
+	policy->min = cpu->perf_caps.lowest_nonlinear_perf * cppc_dmi_max_khz /
+		cpu->perf_caps.highest_perf;
 	policy->max = cppc_dmi_max_khz;
-	policy->cpuinfo.min_freq = policy->min;
-	policy->cpuinfo.max_freq = policy->max;
+
+	/*
+	 * Set cpuinfo.min_freq to Lowest to make the full range of performance
+	 * available if userspace wants to use any perf between lowest & lowest
+	 * nonlinear perf
+	 */
+	policy->cpuinfo.min_freq = cpu->perf_caps.lowest_perf * cppc_dmi_max_khz /
+		cpu->perf_caps.highest_perf;
+	policy->cpuinfo.max_freq = cppc_dmi_max_khz;
+
 	policy->cpuinfo.transition_latency = cppc_get_transition_latency(cpu_num);
 	policy->shared_type = cpu->shared_type;
 

commit 974f86498ed28d86575cd2327bd83e53abd872da
Author: Prakash, Prashanth <pprakash@codeaurora.org>
Date:   Fri Oct 14 12:00:23 2016 -0600

    cpufreq / CPPC: Add MODULE_DEVICE_TABLE for cppc_cpufreq driver
    
    MODULE_DEVICE_TABLE is added so that CPPC cpufreq module can be
    automatically loaded when we have a acpi processor device with
    "ACPI0007" hid.
    
    Signed-off-by: Prashanth Prakash <pprakash@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index 4852d9efe74e..e82bb3c30b92 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -247,3 +247,10 @@ MODULE_DESCRIPTION("CPUFreq driver based on the ACPI CPPC v5.0+ spec");
 MODULE_LICENSE("GPL");
 
 late_initcall(cppc_cpufreq_init);
+
+static const struct acpi_device_id cppc_acpi_ids[] = {
+	{ACPI_PROCESSOR_DEVICE_HID, },
+	{}
+};
+
+MODULE_DEVICE_TABLE(acpi, cppc_acpi_ids);

commit ef98988ba369da88bab8a4d457407e71bbe160fa
Merge: f34d3606f76a 383731d98e76
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 14 12:46:13 2016 -0700

    Merge tag 'pm-extra-4.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more power management updates from Rafael Wysocki:
     "This includes a couple of fixes for cpufreq regressions introduced in
      4.8, a rework of the intel_pstate algorithm used on Atom processors
      (that took some time to test) plus a fix and a couple of cleanups in
      that driver, a CPPC cpufreq driver fix, and a some devfreq fixes and
      cleanups (core and exynos-nocp).
    
      Specifics:
    
       - Fix two cpufreq regressions causing undesirable changes in behavior
         to appear (one in the core and one in the conservative governor)
         introduced during the 4.8 cycle (Aaro Koskinen, Rafael Wysocki).
    
       - Fix the way the intel_pstate driver accesses MSRs related to the
         hardware-managed P-states (HWP) feature during the initialization
         which currently is unsafe and may cause the processor to generate a
         general protection fault (Srinivas Pandruvada).
    
       - Rework the intel_pstate's P-state selection algorithm used on Atom
         processors to avoid known problems with the current one and to make
         the computation more straightforward, which also happens to improve
         performance in multiple benchmarks a bit (Rafael Wysocki).
    
       - Improve two comments in the intel_pstate driver (Rafael Wysocki).
    
       - Fix the desired performance computation in the CPPC cpufreq driver
         (Hoan Tran).
    
       - Fix the devfreq core to avoid printing misleading error messages in
         some cases (Tobias Jakobi).
    
       - Fix the error code path in devfreq_add_device() to use proper
         locking around list modifications (Axel Lin).
    
       - Fix a build failure and remove a couple of redundant updates of
         variables in the exynos-nocp devfreq driver (Axel Lin)"
    
    * tag 'pm-extra-4.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      cpufreq: CPPC: Correct desired_perf calculation
      cpufreq: conservative: Fix next frequency selection
      cpufreq: skip invalid entries when searching the frequency
      cpufreq: intel_pstate: Fix struct pstate_adjust_policy kerneldoc
      cpufreq: intel_pstate: Proportional algorithm for Atom
      PM / devfreq: Skip status update on uninitialized previous_freq
      PM / devfreq: Add proper locking around list_del()
      PM / devfreq: exynos-nocp: Remove redundant code
      PM / devfreq: exynos-nocp: Select REGMAP_MMIO
      cpufreq: intel_pstate: Clarify comment in get_target_pstate_use_performance()
      cpufreq: intel_pstate: Fix unsafe HWP MSR access

commit c197d758036d8c77923ae3f88571cf198283107e
Author: Hoan Tran <hotran@apm.com>
Date:   Thu Oct 13 10:33:35 2016 -0700

    cpufreq: CPPC: Correct desired_perf calculation
    
    The desired_perf is an abstract performance number. Its value should
    be in the range of [lowest perf, highest perf] of CPPC.
    The correct calculation is
      desired_perf = freq * cppc_highest_perf / cppc_dmi_max_khz
    
    And cppc_cpufreq_set_target() returns if desired_perf is exactly
    the same with the old perf.
    
    Signed-off-by: Hoan Tran <hotran@apm.com>
    Reviewed-by: Prashanth Prakash <pprakash@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index 99db4227ae38..f7e98fc077c1 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -80,11 +80,17 @@ static int cppc_cpufreq_set_target(struct cpufreq_policy *policy,
 {
 	struct cpudata *cpu;
 	struct cpufreq_freqs freqs;
+	u32 desired_perf;
 	int ret = 0;
 
 	cpu = all_cpu_data[policy->cpu];
 
-	cpu->perf_ctrls.desired_perf = (u64)target_freq * policy->max / cppc_dmi_max_khz;
+	desired_perf = (u64)target_freq * cpu->perf_caps.highest_perf / cppc_dmi_max_khz;
+	/* Return if it is exactly the same perf */
+	if (desired_perf == cpu->perf_ctrls.desired_perf)
+		return ret;
+
+	cpu->perf_ctrls.desired_perf = desired_perf;
 	freqs.old = policy->cur;
 	freqs.new = target_freq;
 

commit 72d39926f098b0c4ad95e1461595a8d6d403c14d
Merge: 72ec94560d7e 8c4b172123c0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 3 10:11:58 2016 -0700

    Merge tag 'acpi-4.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull ACPI updates from Rafael Wysocki:
     "First off, the ACPICA code in the kernel is updated to upstream
      revision 20160831 that brings in a few bug fixes and cleanups. In
      particular, it is possible to mask GPEs now (and the sysfs interface
      for GPE control is fixed on top of that), problems related to the
      table loading mechanism are fixed and all code related to FADT version
      2 (which has never been part of the ACPI specification) is dropped.
    
      On the new features front, there is a new watchdog driver based on the
      ACPI WDAT (ACPI Watchdog Action Table), needed on some platforms to
      replace the iTCO watchdog that doesn't work there, and some UART
      devices get new definitions of built-in properties (to be accessed via
      the generic device properties API).
    
      Also, included is a fix for an ACPI-related PCI resorces allocation
      issue and a few problems in the EC driver and in the button and
      battery drivers are fixed.
    
      In addition to that, the ACPI CPPC library is updated to make batching
      of requests sent over the PCC channel possible (which reduces the PCC
      usage overhead substantially in some cases) and to support functional
      fixed hardware (FFH) type of CPPC registers access (which will allow
      CPPC to be used on x86 too in the future).
    
      As usual, there are some assorted fixes and cleanups too.
    
      Specifics:
    
       - Update of the ACPICA code in the kernel to upstream revision
         20160831 with the following major changes:
    
          * New mechanism for GPE masking.
          * Fixes for issues related to the LoadTable operator and table
            loading.
          * Fixes for issues related to so-called module-level code (MLC),
            that is AML that doesn't belong to any methods.
          * Change of the return value of the _OSI method to reflect the
            Windows behavior.
          * GAS (Generic Address Structure) support fix related to 32-bit
            FADT addresses.
          * Elimination of unnecessary FADT version 2 support.
          * ACPI tools fixes and cleanups.
    
         From Bob Moore, Lv Zheng, and Jung-uk Kim.
    
       - ACPI sysfs interface updates to fix GPE handling (on top of the new
         GPE masking mechanism in ACPICA) and issues related to table
         loading (Lv Zheng).
    
       - New watchdog driver based on the ACPI WDAT (ACPI Watchdog Action
         Table), needed on some platforms to replace the iTCO watchdog that
         doesn't work there and related updates of the intel_pmc_ipc,
         i2c/i801 and MFD/lcp_ich drivers (Mika Westerberg).
    
       - Driver core fix to prevent it from leaking secondary fwnode objects
         during device removal (Lukas Wunner).
    
       - New definitions of built-in properties for UART in ACPI-based x86
         SoC drivers and a 8250_dw driver quirk for the APM X-Gene SoC
         (Heikki Krogerus).
    
       - New device ID for the Vulcan SPI controller and constification of
         local strucures in the AMD SoC (APD) ACPI driver (Kamlakant Patel,
         Julia Lawall).
    
       - Fix for a bug causing the allocation of PCI resorces to fail if
         ACPI-enumerated child platform devices are registered below the PCI
         devices in question (Mika Westerberg).
    
       - Change of the default polarity for PCI legacy IRQs to high on
         systems booting wth ACPI on platforms with a GIC interrupt
         controller model fixing the discrepancy between the specification
         and HW behavior (Lorenzo Pieralisi).
    
       - Fixes for the handling of system suspend/resume in the ACPI EC
         driver and update of that driver to make it cope with the cases
         when the EC device defined in the ECDT has to be used throughout
         the entire system life cycle (Lv Zheng).
    
       - Update of the ACPI CPPC library to allow it to batch requests sent
         over the PCC channel (to reduce overhead), to support the fixed
         functional hardware (FFH) CPPC registers access type, to notify the
         mailbox framework about TX completions when the interrupt flag is
         set for the PCC mailbox, and to support HW-Reduced Communication
         Subspace type 2 (Ashwin Chaugule, Prashanth Prakash, Srinivas
         Pandruvada, Hoan Tran).
    
       - ACPI button driver fix and documentation update related to the
         handling of laptop lids (Lv Zheng).
    
       - ACPI battery driver initialization fix (Carlos Garnacho).
    
       - ACPI GPIO enumeration documentation update (Mika Westerberg).
    
       - Assorted updates of the core ACPI bus type code (Lukas Wunner, Lv
         Zheng).
    
       - Assorted cleanups of the ACPI table parsing code and the
         x86-specific ACPI code (Al Stone).
    
       - Fixes for assorted ACPI-related issues found in linux-next (Wei
         Yongjun)"
    
    * tag 'acpi-4.9-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (98 commits)
      ACPI / documentation: Use recommended name in GPIO property names
      watchdog: wdat_wdt: Fix warning for using 0 as NULL
      watchdog: wdat_wdt: fix return value check in wdat_wdt_probe()
      platform/x86: intel_pmc_ipc: Do not create iTCO watchdog when WDAT table exists
      i2c: i801: Do not create iTCO watchdog when WDAT table exists
      mfd: lpc_ich: Do not create iTCO watchdog when WDAT table exists
      ACPI / bus: Adjust ACPI subsystem initialization for new table loading mode
      ACPICA: Parser: Fix a regression in LoadTable support
      ACPICA: Tables: Fix "UNLOAD" code path lock issues
      ACPI / watchdog: Add support for WDAT hardware watchdog
      ACPI / platform: Pay attention to parent device's resources
      PCI: Add pci_find_resource()
      ACPI / CPPC: Support PCC with interrupt flag
      ACPI / sysfs: Update sysfs signature handling code
      ACPI / sysfs: Fix an issue for LoadTable opcode
      ACPICA: Tables: Fix a regression in acpi_tb_find_table()
      ACPI / tables: Remove duplicated include from tables.c
      ACPI / APD: constify local structures
      x86: ACPI: make variable names clearer in acpi_parse_madt_lapic_entries()
      x86: ACPI: remove extraneous white space after semicolon
      ...

commit f89f4147f76f91bfff6f32890fc34148178f144d
Author: Hoan Tran <hotran@apm.com>
Date:   Wed Sep 14 16:08:28 2016 -0700

    cpufreq: CPPC: Avoid overflow when calculating desired_perf
    
    This patch fixes overflow issue when calculating the desired_perf.
    
    Fixes: ad38677df44b (cpufreq: CPPC: Force reporting values in KHz to fix user space interface)
    Signed-off-by: Hoan Tran <hotran@apm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index 6debc189a9c9..99db4227ae38 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -84,7 +84,7 @@ static int cppc_cpufreq_set_target(struct cpufreq_policy *policy,
 
 	cpu = all_cpu_data[policy->cpu];
 
-	cpu->perf_ctrls.desired_perf = target_freq * policy->max / cppc_dmi_max_khz;
+	cpu->perf_ctrls.desired_perf = (u64)target_freq * policy->max / cppc_dmi_max_khz;
 	freqs.old = policy->cur;
 	freqs.new = target_freq;
 

commit ad38677df44b67e0f5b6c4d31e9c2734abde8ed9
Author: Al Stone <ahs3@redhat.com>
Date:   Wed Jul 20 15:10:04 2016 -0600

    cpufreq: CPPC: Force reporting values in KHz to fix user space interface
    
    When CPPC is being used by ACPI on arm64, user space tools such as
    cpupower report CPU frequency values from sysfs that are incorrect.
    
    What the driver was doing was reporting the values given by ACPI tables
    in whatever scale was used to provide them.  However, the ACPI spec
    defines the CPPC values as unitless abstract numbers.  Internal kernel
    structures such as struct perf_cap, in contrast, expect these values
    to be in KHz.  When these struct values get reported via sysfs, the
    user space tools also assume they are in KHz, causing them to report
    incorrect values (for example, reporting a CPU frequency of 1MHz when
    it should be 1.8GHz).
    
    The downside is that this approach has some assumptions:
    
       (1) It relies on SMBIOS3 being used, *and* that the Max Frequency
       value for a processor is set to a non-zero value.
    
       (2) It assumes that all processors run at the same speed, or that
       the CPPC values have all been scaled to reflect relative speed.
       This patch retrieves the largest CPU Max Frequency from a type 4 DMI
       record that it can find.  This may not be an issue, however, as a
       sampling of DMI data on x86 and arm64 indicates there is often only
       one such record regardless.  Since CPPC is relatively new, it is
       unclear if the ACPI ASL will always be written to reflect any sort
       of relative performance of processors of differing speeds.
    
       (3) It assumes that performance and frequency both scale linearly.
    
    For arm64 servers, this may be sufficient, but it does rely on
    firmware values being set correctly.  Hence, other approaches will
    be considered in the future.
    
    This has been tested on three arm64 servers, with and without DMI, with
    and without CPPC support.
    
    Signed-off-by: Al Stone <ahs3@redhat.com>
    Signed-off-by: Prashanth Prakash <pprakash@codeaurora.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index 8882b8e2ecd0..6debc189a9c9 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -19,10 +19,19 @@
 #include <linux/delay.h>
 #include <linux/cpu.h>
 #include <linux/cpufreq.h>
+#include <linux/dmi.h>
 #include <linux/vmalloc.h>
 
+#include <asm/unaligned.h>
+
 #include <acpi/cppc_acpi.h>
 
+/* Minimum struct length needed for the DMI processor entry we want */
+#define DMI_ENTRY_PROCESSOR_MIN_LENGTH	48
+
+/* Offest in the DMI processor structure for the max frequency */
+#define DMI_PROCESSOR_MAX_SPEED  0x14
+
 /*
  * These structs contain information parsed from per CPU
  * ACPI _CPC structures.
@@ -32,6 +41,39 @@
  */
 static struct cpudata **all_cpu_data;
 
+/* Capture the max KHz from DMI */
+static u64 cppc_dmi_max_khz;
+
+/* Callback function used to retrieve the max frequency from DMI */
+static void cppc_find_dmi_mhz(const struct dmi_header *dm, void *private)
+{
+	const u8 *dmi_data = (const u8 *)dm;
+	u16 *mhz = (u16 *)private;
+
+	if (dm->type == DMI_ENTRY_PROCESSOR &&
+	    dm->length >= DMI_ENTRY_PROCESSOR_MIN_LENGTH) {
+		u16 val = (u16)get_unaligned((const u16 *)
+				(dmi_data + DMI_PROCESSOR_MAX_SPEED));
+		*mhz = val > *mhz ? val : *mhz;
+	}
+}
+
+/* Look up the max frequency in DMI */
+static u64 cppc_get_dmi_max_khz(void)
+{
+	u16 mhz = 0;
+
+	dmi_walk(cppc_find_dmi_mhz, &mhz);
+
+	/*
+	 * Real stupid fallback value, just in case there is no
+	 * actual value set.
+	 */
+	mhz = mhz ? mhz : 1;
+
+	return (1000 * mhz);
+}
+
 static int cppc_cpufreq_set_target(struct cpufreq_policy *policy,
 		unsigned int target_freq,
 		unsigned int relation)
@@ -42,7 +84,7 @@ static int cppc_cpufreq_set_target(struct cpufreq_policy *policy,
 
 	cpu = all_cpu_data[policy->cpu];
 
-	cpu->perf_ctrls.desired_perf = target_freq;
+	cpu->perf_ctrls.desired_perf = target_freq * policy->max / cppc_dmi_max_khz;
 	freqs.old = policy->cur;
 	freqs.new = target_freq;
 
@@ -94,8 +136,10 @@ static int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)
 		return ret;
 	}
 
-	policy->min = cpu->perf_caps.lowest_perf;
-	policy->max = cpu->perf_caps.highest_perf;
+	cppc_dmi_max_khz = cppc_get_dmi_max_khz();
+
+	policy->min = cpu->perf_caps.lowest_perf * cppc_dmi_max_khz / cpu->perf_caps.highest_perf;
+	policy->max = cppc_dmi_max_khz;
 	policy->cpuinfo.min_freq = policy->min;
 	policy->cpuinfo.max_freq = policy->max;
 	policy->shared_type = cpu->shared_type;
@@ -112,7 +156,8 @@ static int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)
 	cpu->cur_policy = policy;
 
 	/* Set policy->cur to max now. The governors will adjust later. */
-	policy->cur = cpu->perf_ctrls.desired_perf = cpu->perf_caps.highest_perf;
+	policy->cur = cppc_dmi_max_khz;
+	cpu->perf_ctrls.desired_perf = cpu->perf_caps.highest_perf;
 
 	ret = cppc_set_perf(cpu_num, &cpu->perf_ctrls);
 	if (ret)

commit 41dd64038970139c562d07ee7ff4e41245611b4a
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Thu Sep 1 13:37:11 2016 -0700

    ACPI / CPPC: Add prefix cppc to cpudata structure name
    
    Since struct cpudata is defined in a header file, add prefix cppc_ to
    make it not a generic name. Otherwise it causes compile issue in locally
    define structure with the same name.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index e6a33596dea3..6588ec567d93 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -30,13 +30,13 @@
  * performance capabilities, desired performance level
  * requested etc.
  */
-static struct cpudata **all_cpu_data;
+static struct cppc_cpudata **all_cpu_data;
 
 static int cppc_cpufreq_set_target(struct cpufreq_policy *policy,
 		unsigned int target_freq,
 		unsigned int relation)
 {
-	struct cpudata *cpu;
+	struct cppc_cpudata *cpu;
 	struct cpufreq_freqs freqs;
 	int ret = 0;
 
@@ -66,7 +66,7 @@ static int cppc_verify_policy(struct cpufreq_policy *policy)
 static void cppc_cpufreq_stop_cpu(struct cpufreq_policy *policy)
 {
 	int cpu_num = policy->cpu;
-	struct cpudata *cpu = all_cpu_data[cpu_num];
+	struct cppc_cpudata *cpu = all_cpu_data[cpu_num];
 	int ret;
 
 	cpu->perf_ctrls.desired_perf = cpu->perf_caps.lowest_perf;
@@ -79,7 +79,7 @@ static void cppc_cpufreq_stop_cpu(struct cpufreq_policy *policy)
 
 static int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)
 {
-	struct cpudata *cpu;
+	struct cppc_cpudata *cpu;
 	unsigned int cpu_num = policy->cpu;
 	int ret = 0;
 
@@ -135,7 +135,7 @@ static struct cpufreq_driver cppc_cpufreq_driver = {
 static int __init cppc_cpufreq_init(void)
 {
 	int i, ret = 0;
-	struct cpudata *cpu;
+	struct cppc_cpudata *cpu;
 
 	if (acpi_disabled)
 		return -ENODEV;
@@ -145,7 +145,7 @@ static int __init cppc_cpufreq_init(void)
 		return -ENOMEM;
 
 	for_each_possible_cpu(i) {
-		all_cpu_data[i] = kzalloc(sizeof(struct cpudata), GFP_KERNEL);
+		all_cpu_data[i] = kzalloc(sizeof(struct cppc_cpudata), GFP_KERNEL);
 		if (!all_cpu_data[i])
 			goto out;
 
@@ -176,7 +176,7 @@ static int __init cppc_cpufreq_init(void)
 
 static void __exit cppc_cpufreq_exit(void)
 {
-	struct cpudata *cpu;
+	struct cppc_cpudata *cpu;
 	int i;
 
 	cpufreq_unregister_driver(&cppc_cpufreq_driver);

commit be8b88d7d9877114172b32817d8eb3e85d3d8f99
Author: Prakash, Prashanth <pprakash@codeaurora.org>
Date:   Tue Aug 16 14:39:41 2016 -0600

    ACPI / CPPC: set a non-zero value for transition_latency
    
    Compute the expected transition latency for frequency transitions
    using the values from the PCCT tables when the desired perf
    register is in PCC.
    
    Signed-off-by: Prashanth Prakash <pprakash@codeaurora.org>
    Reviewed-by: Alexey Klimov <alexey.klimov@arm.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index 8882b8e2ecd0..e6a33596dea3 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -98,6 +98,7 @@ static int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)
 	policy->max = cpu->perf_caps.highest_perf;
 	policy->cpuinfo.min_freq = policy->min;
 	policy->cpuinfo.max_freq = policy->max;
+	policy->cpuinfo.transition_latency = cppc_get_transition_latency(cpu_num);
 	policy->shared_type = cpu->shared_type;
 
 	if (policy->shared_type == CPUFREQ_SHARED_TYPE_ANY)

commit a29a1e76781d112014761ba106ab03e097cc4492
Author: Ashwin Chaugule <ashwin.chaugule@linaro.org>
Date:   Thu Apr 14 20:45:53 2016 -0400

    cpufreq: ACPI / CPPC: Add module support for cppc_cpufreq driver
    
    Add a function to cleanup at module exit and export
    appropriate GPL string to enable moduler support
    for the cppc_cpufreq driver.
    
    Reported-by: Srinivas Pandruvada <srinivas.pandruvada@intel.com>
    Signed-off-by: Ashwin Chaugule <ashwin.chaugule@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index 7c0bdfb1a2ca..8882b8e2ecd0 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -173,4 +173,25 @@ static int __init cppc_cpufreq_init(void)
 	return -ENODEV;
 }
 
+static void __exit cppc_cpufreq_exit(void)
+{
+	struct cpudata *cpu;
+	int i;
+
+	cpufreq_unregister_driver(&cppc_cpufreq_driver);
+
+	for_each_possible_cpu(i) {
+		cpu = all_cpu_data[i];
+		free_cpumask_var(cpu->shared_cpu_map);
+		kfree(cpu);
+	}
+
+	kfree(all_cpu_data);
+}
+
+module_exit(cppc_cpufreq_exit);
+MODULE_AUTHOR("Ashwin Chaugule");
+MODULE_DESCRIPTION("CPUFreq driver based on the ACPI CPPC v5.0+ spec");
+MODULE_LICENSE("GPL");
+
 late_initcall(cppc_cpufreq_init);

commit 9dc17917733f5a53ef970ac95a48d2dfb7dc7202
Author: Ashwin Chaugule <ashwin.chaugule@linaro.org>
Date:   Thu Nov 19 10:40:07 2015 -0500

    cpufreq: CPPC: Initialize and check CPUFreq CPU co-ord type correctly
    
    The CPU policy struct indicates the co-ordination type
    for all CPUs of a common freq domain. Initialize it
    correctly using the CPU specific data gathered from
    CPPC ACPI lib via acpi_get_psd_map().
    
    The PSD object is optional, so the cpu->shared_type
    can also be 0. So instead of assuming any value other
    than SW_ANY(0xFD) is unsupported, explictly check
    if shared_type is SW_ALL and then bail.
    
    Signed-off-by: Ashwin Chaugule <ashwin.chaugule@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index e8cb334094b0..7c0bdfb1a2ca 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -98,10 +98,11 @@ static int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)
 	policy->max = cpu->perf_caps.highest_perf;
 	policy->cpuinfo.min_freq = policy->min;
 	policy->cpuinfo.max_freq = policy->max;
+	policy->shared_type = cpu->shared_type;
 
 	if (policy->shared_type == CPUFREQ_SHARED_TYPE_ANY)
 		cpumask_copy(policy->cpus, cpu->shared_cpu_map);
-	else {
+	else if (policy->shared_type == CPUFREQ_SHARED_TYPE_ALL) {
 		/* Support only SW_ANY for now. */
 		pr_debug("Unsupported CPU co-ord type\n");
 		return -EFAULT;

commit efb2d3be53e4343ab6495729b3ec9ffb95261035
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Nov 5 21:10:29 2015 +0100

    cpufreq: CPPC: Delete an unnecessary check before the function call kfree()
    
    The kfree() function tests whether its argument is NULL and then
    returns immediately. Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index 93c219fab850..e8cb334094b0 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -166,8 +166,7 @@ static int __init cppc_cpufreq_init(void)
 
 out:
 	for_each_possible_cpu(i)
-		if (all_cpu_data[i])
-			kfree(all_cpu_data[i]);
+		kfree(all_cpu_data[i]);
 
 	kfree(all_cpu_data);
 	return -ENODEV;

commit 5477fb3bd1e8e43299761850318fe0057172a24a
Author: Ashwin Chaugule <ashwin.chaugule@linaro.org>
Date:   Fri Oct 2 10:04:01 2015 -0400

    ACPI / CPPC: Add a CPUFreq driver for use with CPPC
    
    This driver utilizes the methods introduced in a previous
    patch titled - "ACPI: Introduce CPU performance controls using CPPC"
    and enables usage with existing CPUFreq governors.
    
    Signed-off-by: Ashwin Chaugule <ashwin.chaugule@linaro.org>
    Reviewed-by: Al Stone <al.stone@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
new file mode 100644
index 000000000000..93c219fab850
--- /dev/null
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -0,0 +1,176 @@
+/*
+ * CPPC (Collaborative Processor Performance Control) driver for
+ * interfacing with the CPUfreq layer and governors. See
+ * cppc_acpi.c for CPPC specific methods.
+ *
+ * (C) Copyright 2014, 2015 Linaro Ltd.
+ * Author: Ashwin Chaugule <ashwin.chaugule@linaro.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#define pr_fmt(fmt)	"CPPC Cpufreq:"	fmt
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/cpu.h>
+#include <linux/cpufreq.h>
+#include <linux/vmalloc.h>
+
+#include <acpi/cppc_acpi.h>
+
+/*
+ * These structs contain information parsed from per CPU
+ * ACPI _CPC structures.
+ * e.g. For each CPU the highest, lowest supported
+ * performance capabilities, desired performance level
+ * requested etc.
+ */
+static struct cpudata **all_cpu_data;
+
+static int cppc_cpufreq_set_target(struct cpufreq_policy *policy,
+		unsigned int target_freq,
+		unsigned int relation)
+{
+	struct cpudata *cpu;
+	struct cpufreq_freqs freqs;
+	int ret = 0;
+
+	cpu = all_cpu_data[policy->cpu];
+
+	cpu->perf_ctrls.desired_perf = target_freq;
+	freqs.old = policy->cur;
+	freqs.new = target_freq;
+
+	cpufreq_freq_transition_begin(policy, &freqs);
+	ret = cppc_set_perf(cpu->cpu, &cpu->perf_ctrls);
+	cpufreq_freq_transition_end(policy, &freqs, ret != 0);
+
+	if (ret)
+		pr_debug("Failed to set target on CPU:%d. ret:%d\n",
+				cpu->cpu, ret);
+
+	return ret;
+}
+
+static int cppc_verify_policy(struct cpufreq_policy *policy)
+{
+	cpufreq_verify_within_cpu_limits(policy);
+	return 0;
+}
+
+static void cppc_cpufreq_stop_cpu(struct cpufreq_policy *policy)
+{
+	int cpu_num = policy->cpu;
+	struct cpudata *cpu = all_cpu_data[cpu_num];
+	int ret;
+
+	cpu->perf_ctrls.desired_perf = cpu->perf_caps.lowest_perf;
+
+	ret = cppc_set_perf(cpu_num, &cpu->perf_ctrls);
+	if (ret)
+		pr_debug("Err setting perf value:%d on CPU:%d. ret:%d\n",
+				cpu->perf_caps.lowest_perf, cpu_num, ret);
+}
+
+static int cppc_cpufreq_cpu_init(struct cpufreq_policy *policy)
+{
+	struct cpudata *cpu;
+	unsigned int cpu_num = policy->cpu;
+	int ret = 0;
+
+	cpu = all_cpu_data[policy->cpu];
+
+	cpu->cpu = cpu_num;
+	ret = cppc_get_perf_caps(policy->cpu, &cpu->perf_caps);
+
+	if (ret) {
+		pr_debug("Err reading CPU%d perf capabilities. ret:%d\n",
+				cpu_num, ret);
+		return ret;
+	}
+
+	policy->min = cpu->perf_caps.lowest_perf;
+	policy->max = cpu->perf_caps.highest_perf;
+	policy->cpuinfo.min_freq = policy->min;
+	policy->cpuinfo.max_freq = policy->max;
+
+	if (policy->shared_type == CPUFREQ_SHARED_TYPE_ANY)
+		cpumask_copy(policy->cpus, cpu->shared_cpu_map);
+	else {
+		/* Support only SW_ANY for now. */
+		pr_debug("Unsupported CPU co-ord type\n");
+		return -EFAULT;
+	}
+
+	cpumask_set_cpu(policy->cpu, policy->cpus);
+	cpu->cur_policy = policy;
+
+	/* Set policy->cur to max now. The governors will adjust later. */
+	policy->cur = cpu->perf_ctrls.desired_perf = cpu->perf_caps.highest_perf;
+
+	ret = cppc_set_perf(cpu_num, &cpu->perf_ctrls);
+	if (ret)
+		pr_debug("Err setting perf value:%d on CPU:%d. ret:%d\n",
+				cpu->perf_caps.highest_perf, cpu_num, ret);
+
+	return ret;
+}
+
+static struct cpufreq_driver cppc_cpufreq_driver = {
+	.flags = CPUFREQ_CONST_LOOPS,
+	.verify = cppc_verify_policy,
+	.target = cppc_cpufreq_set_target,
+	.init = cppc_cpufreq_cpu_init,
+	.stop_cpu = cppc_cpufreq_stop_cpu,
+	.name = "cppc_cpufreq",
+};
+
+static int __init cppc_cpufreq_init(void)
+{
+	int i, ret = 0;
+	struct cpudata *cpu;
+
+	if (acpi_disabled)
+		return -ENODEV;
+
+	all_cpu_data = kzalloc(sizeof(void *) * num_possible_cpus(), GFP_KERNEL);
+	if (!all_cpu_data)
+		return -ENOMEM;
+
+	for_each_possible_cpu(i) {
+		all_cpu_data[i] = kzalloc(sizeof(struct cpudata), GFP_KERNEL);
+		if (!all_cpu_data[i])
+			goto out;
+
+		cpu = all_cpu_data[i];
+		if (!zalloc_cpumask_var(&cpu->shared_cpu_map, GFP_KERNEL))
+			goto out;
+	}
+
+	ret = acpi_get_psd_map(all_cpu_data);
+	if (ret) {
+		pr_debug("Error parsing PSD data. Aborting cpufreq registration.\n");
+		goto out;
+	}
+
+	ret = cpufreq_register_driver(&cppc_cpufreq_driver);
+	if (ret)
+		goto out;
+
+	return ret;
+
+out:
+	for_each_possible_cpu(i)
+		if (all_cpu_data[i])
+			kfree(all_cpu_data[i]);
+
+	kfree(all_cpu_data);
+	return -ENODEV;
+}
+
+late_initcall(cppc_cpufreq_init);
