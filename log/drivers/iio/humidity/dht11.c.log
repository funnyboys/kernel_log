commit f335fa7034d5444de53f22824afce52924d95253
Author: Kent Gustavsson <kent@minoris.se>
Date:   Sat Jan 4 19:19:29 2020 +0100

    iio: humidity: dht11 remove TODO since it doesn't make sense
    
    DHT11 isn't addressable and will trigger temperature measurement on any
    data sent on the bus.
    
    Signed-off-by: Kent Gustavsson <kent@minoris.se>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index b459600e1a33..d05c6fdb758b 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -174,7 +174,6 @@ static irqreturn_t dht11_handle_irq(int irq, void *data)
 	struct iio_dev *iio = data;
 	struct dht11 *dht11 = iio_priv(iio);
 
-	/* TODO: Consider making the handler safe for IRQ sharing */
 	if (dht11->num_edges < DHT11_EDGES_PER_READ && dht11->num_edges >= 0) {
 		dht11->edges[dht11->num_edges].ts = ktime_get_boottime_ns();
 		dht11->edges[dht11->num_edges++].value =

commit e786741ff1b52769b044b7f4407f39cd13ee5d2d
Merge: 97ff4ca46d32 5d1532482943
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 11 15:36:02 2019 -0700

    Merge tag 'staging-5.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging and IIO driver updates from Greg KH:
     "Here is the big Staging and IIO driver update for 5.3-rc1.
    
      Lots of new IIO drivers are in here, along with loads of tiny staging
      driver cleanups and fixes. Overall we almost break even with the same
      lines added as removed.
    
      Full details are in the shortlog, they are too large to list here.
    
      All of these changes have been in linux-next for a while with no
      reported issues"
    
    * tag 'staging-5.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (608 commits)
      staging: kpc2000: simplify comparison to NULL in fileops.c
      staging: kpc2000: simplify comparison to NULL in dma.c
      staging: kpc2000: simplify comparison to NULL in kpc2000_spi.c
      staging: rtl8723bs: hal: remove redundant assignment to packetType
      staging: rtl8723bs: Change return type of hal_btcoex_IsBtDisabled()
      staging: rtl8723bs: Remove rtw_btcoex_DisplayBtCoexInfo()
      staging: rtl8723bs: Remove function rtw_btcoex_GetDBG()
      staging: rtl8723bs: Remove function rtw_btcoex_SetDBG()
      staging: rtl8723bs: Remove rtw_btcoex_IsBTCoexCtrlAMPDUSize()
      staging: rtl8723bs: Remove rtw_btcoex_BtInfoNotify()
      staging: rtl8723bs: Remove rtw_btcoex_ScanNotify()
      staging: rtl8723bs: Remove rtw_btcoex_SetSingleAntPath()
      staging: rtl8723bs: Remove rtw_btcoex_SetPGAntNum()
      staging: rtl8192e: remove redundant initialization of rtstatus
      staging: rtl8723bs: Remove rtw_btcoex_GetRaMask()
      staging: rtl8723bs: Remove rtw_btcoex_SetChipType()
      staging: rtl8723bs: Remove rtw_btcoex_ConnectNotify()
      staging: rtl8723bs: Remove rtw_btcoex_SetBTCoexist()
      staging: rtl8723bs: Remove rtw_btcoex_IsBtDisabled()
      staging: rtl8723bs: Remove rtw_btcoex_IsBtControlLps()
      ...

commit c55cc97a252488a8e2a9181c1c36713cad69ee18
Merge: 003e6cc3a22d 208a68c8393d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jul 1 10:58:13 2019 +0200

    Merge tag 'iio-for-5.3b' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-next
    
    Jonathan writes:
    
    Second set of IIO device support, features, cleanups and minor fixes for 5.3.
    
    A few bits for the counters subsystem mixed in here as well.
    There are some late breaking fixes as well, which aren't so urgent
    they can't wait for the merge window.
    
    New Device Support
    * adf4371
      - New driver + bindings.
      - Support the adf4372 PLL. Mostly ID and bindings.
    * ad8366 (note includes rework of driver needed to allow support for these).
      - Support the ADL5240 variable gain amplifier (VGA).
      - Support the ADA4961 digital gain amplifier (DGA).
    * dps310
      - New driver, in several parts from different authors for this temp
        and pressure sensor.
      - Includes errata workaround for a temperature reading issue.
    * stk3310
      - Support the stk3335, mostly ID.
    
    Features and cleanups
    * core
      - drop error handling on debugfs registration.
      - harden by making sure we don't overrun iio_chan_info_postfix.
    * docs
      - convert remaining docs to rst. At somepoint we'll fit these few
        into the main IIO docs.
      - improve sampling_frequency_available docs but explaining the
        range form.
    * ad_sigma_delta
      - Drop a pointless goto.
    * ad2s1210
      - Drop pointless platform data null check seeing as we don't actually
        use platform data anymore.
    * ad7124
      - Relax limitation on channel numbers to allow pseudo different channels.
      - Support control of whether the input is buffered via DT.
      - Use dynamic allocation for channel configuration to make it easier
        to support new devices.
      - YAML binding conversion.
    * ad7150
      - Comment tidy up.
      - Consistent and simple if (ret) handling of i2c errors.
      - FIELD_GET and GENMASK.
      - Ternary rather than !!(condition) for readability.
      - Use macros to avoid repetition of channel definitions.
    * ad7606
      - Add software channel config (rather that pin controlled)
      - Refactor to simplify addition of new part in future.
    * ad7746
      - of_deivce_id table.
    * ad7780
      - MAINTAINERS entry
      - YAML DT bindings.
    * ad8366
      - Stop using core mlock in favour of well scoped local lock.
      - SPDX + copyright date update.
    * ad9834
      - of_device_id table
    * adf4371
      - Add support for output stage muting before lock on has occured.
    * adis library
      - MAINTAINERS entry to reflect that this now Alexandru's problem ;)
    * adis162xx:
      - Fix a slightly incorrect set of comments and print statements on
        minimum supported voltage.
    * adis16203
      - of_device_id table.
    * adis16240
      - Add of_device_id table (in two parts as first patch only used it for
        MODULE_DEVICE_TABLE.)
    * adt7316-spi
      - of_device_id table
    * adxl372
      - YAML DT binding conversion.
      - Cleanup use of buffer callback functions (precursor to core rework).
    * bh1710
      - Simplify getting the i2c adapter from the client.
    * dht11
      - Mote to newer GPIO consumer interface.
    * kxcjk-1013.c
      - Add binding for sensor in display of some ultrabooks after userspace
        tools updated for it not be a problem to report two similar sensors.
    * imx7d
      - drop unused variables.
      - white space
      - define instead of variable for clock frequency that is fixed.
      - drop pointless error message.
    * messon_saradc
      - SPDX
    * sps30
      - MAINTAINERS entry
      - YAML binding conversion.
    * st_accel
      - Tidy up ordering in various buffer related callbacks. This is
        part of a long running effort to simplify the core code.
    * stm32-dfsdm:
      - Manage the resolution cleanly in triggerd modes.
      - Add fast mode support which allows more flexible filter choices.
      - Add a comment on the reason for a 16 bit record when technically
        not 'required'.
    * st_lsm6dsx
      - Embed device name in the sensor_settings struct as i3c doesn't
        have a convenient name field to use for this.
    * xilinx-adc
      - Relax constraints on supported platforms to reflect that this
        can used with FPGAs on PCIe cards and hence many architectures.
    * counters/ftm-quaddec
      - Fix some formatting io MODULE_AUTHOR
      - MAINTAINERS entry
    
    Fixes
    * tools
      - fix incorrect handling of 32 bit channels.
    * sca3000
      - Potential endian bug that is unlikely to bite anyone (be64 host
        seems unlikely for this old part).
    * stm32-adc
      - Add vdda-supply. On some boards it needs to be turned on to supply
        the ADC.  DT bindings included.
    * stm32-dfsdm
      - Fix output resolution to work with filter orders other than 3.
      - Fix output datatype as it's signed and previously claimed not to be.
    
    * tag 'iio-for-5.3b' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio: (68 commits)
      iio: iio-utils: Fix possible incorrect mask calculation
      iio: frequency: adf4371: Add support for output stage mute
      dt-bindings: iio: frequency: Add ADF4372 PLL documentation
      iio: frequency: adf4371: Add support for ADF4372 PLL
      dt-bindings: iio: adc: Add buffered input property
      Convert AD7124 bindings documentation to YAML format.
      iio: adc: ad7124: Shift to dynamic allocation for channel configuration
      iio: adc: ad7124: Add buffered input support
      iio: adc: ad7124: Remove input number limitation
      MAINTAINERS: add ADIS IMU driver library entry
      iio: adis162xx: fix low-power docs & reports
      counter/ftm-quaddec: Add missing '>' in MODULE_AUTHOR
      iio: core: no need to check return value of debugfs_create functions
      docs: iio: convert to ReST
      iio: adc: stm32-adc: add missing vdda-supply
      dt-bindings: iio: adc: stm32: add missing vdda supply
      iio: adc: stm32-dfsdm: add comment for 16 bits record
      iio: adc: stm32-dfsdm: add fast mode support
      iio: adc: stm32-dfsdm: manage data resolution in trigger mode
      iio: adc: stm32-dfsdm: fix data type
      ...

commit 9285ec4c8b61d4930a575081abeba2cd4f449a74
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Fri Jun 21 22:32:48 2019 +0200

    timekeeping: Use proper clock specifier names in functions
    
    This makes boot uniformly boottime and tai uniformly clocktai, to
    address the remaining oversights.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Link: https://lkml.kernel.org/r/20190621203249.3909-2-Jason@zx2c4.com

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index c8159205c77d..4e22b3c3e488 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -149,7 +149,7 @@ static int dht11_decode(struct dht11 *dht11, int offset)
 		return -EIO;
 	}
 
-	dht11->timestamp = ktime_get_boot_ns();
+	dht11->timestamp = ktime_get_boottime_ns();
 	if (hum_int < 4) {  /* DHT22: 100000 = (3*256+232)*100 */
 		dht11->temperature = (((temp_int & 0x7f) << 8) + temp_dec) *
 					((temp_int & 0x80) ? -100 : 100);
@@ -177,7 +177,7 @@ static irqreturn_t dht11_handle_irq(int irq, void *data)
 
 	/* TODO: Consider making the handler safe for IRQ sharing */
 	if (dht11->num_edges < DHT11_EDGES_PER_READ && dht11->num_edges >= 0) {
-		dht11->edges[dht11->num_edges].ts = ktime_get_boot_ns();
+		dht11->edges[dht11->num_edges].ts = ktime_get_boottime_ns();
 		dht11->edges[dht11->num_edges++].value =
 						gpio_get_value(dht11->gpio);
 
@@ -196,7 +196,7 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 	int ret, timeres, offset;
 
 	mutex_lock(&dht11->lock);
-	if (dht11->timestamp + DHT11_DATA_VALID_TIME < ktime_get_boot_ns()) {
+	if (dht11->timestamp + DHT11_DATA_VALID_TIME < ktime_get_boottime_ns()) {
 		timeres = ktime_get_resolution_ns();
 		dev_dbg(dht11->dev, "current timeresolution: %dns\n", timeres);
 		if (timeres > DHT11_MIN_TIMERES) {
@@ -322,7 +322,7 @@ static int dht11_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
-	dht11->timestamp = ktime_get_boot_ns() - DHT11_DATA_VALID_TIME - 1;
+	dht11->timestamp = ktime_get_boottime_ns() - DHT11_DATA_VALID_TIME - 1;
 	dht11->num_edges = -1;
 
 	platform_set_drvdata(pdev, iio);

commit 7e8b817e5978fdaabba37ab1d2ddb062a4c9abbb
Author: Shobhit Kukreti <shobhitkukreti@gmail.com>
Date:   Mon Jun 10 20:55:57 2019 -0700

    iio: humidity: Replace older GPIO APIs with GPIO Consumer APIs for the dht11 sensor
    
    The dht11 driver uses a single gpio to make measurements. It was
    using the older global gpio numberspace. The patch replaces the
    old gpio api with the new gpio descriptor based api.
    
    Removed header files "linux/gpio.h" and "linux/of_gpio.h"
    
    Signed-off-by: Shobhit Kukreti <shobhitkukreti@gmail.com>
    Acked-by: Harald Geyer <harald@ccbib.org>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index 1a9f8f4ffb88..08573df2a8c6 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -31,8 +31,7 @@
 #include <linux/completion.h>
 #include <linux/mutex.h>
 #include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/of_gpio.h>
+#include <linux/gpio/consumer.h>
 #include <linux/timekeeping.h>
 
 #include <linux/iio/iio.h>
@@ -81,7 +80,7 @@
 struct dht11 {
 	struct device			*dev;
 
-	int				gpio;
+	struct gpio_desc		*gpiod;
 	int				irq;
 
 	struct completion		completion;
@@ -188,7 +187,7 @@ static irqreturn_t dht11_handle_irq(int irq, void *data)
 	if (dht11->num_edges < DHT11_EDGES_PER_READ && dht11->num_edges >= 0) {
 		dht11->edges[dht11->num_edges].ts = ktime_get_boot_ns();
 		dht11->edges[dht11->num_edges++].value =
-						gpio_get_value(dht11->gpio);
+						gpiod_get_value(dht11->gpiod);
 
 		if (dht11->num_edges >= DHT11_EDGES_PER_READ)
 			complete(&dht11->completion);
@@ -226,12 +225,12 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 		reinit_completion(&dht11->completion);
 
 		dht11->num_edges = 0;
-		ret = gpio_direction_output(dht11->gpio, 0);
+		ret = gpiod_direction_output(dht11->gpiod, 0);
 		if (ret)
 			goto err;
 		usleep_range(DHT11_START_TRANSMISSION_MIN,
 			     DHT11_START_TRANSMISSION_MAX);
-		ret = gpio_direction_input(dht11->gpio);
+		ret = gpiod_direction_input(dht11->gpiod);
 		if (ret)
 			goto err;
 
@@ -303,10 +302,8 @@ MODULE_DEVICE_TABLE(of, dht11_dt_ids);
 static int dht11_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
-	struct device_node *node = dev->of_node;
 	struct dht11 *dht11;
 	struct iio_dev *iio;
-	int ret;
 
 	iio = devm_iio_device_alloc(dev, sizeof(*dht11));
 	if (!iio) {
@@ -316,18 +313,13 @@ static int dht11_probe(struct platform_device *pdev)
 
 	dht11 = iio_priv(iio);
 	dht11->dev = dev;
+	dht11->gpiod = devm_gpiod_get(dev, NULL, GPIOD_IN);
+	if (IS_ERR(dht11->gpiod))
+		return PTR_ERR(dht11->gpiod);
 
-	ret = of_get_gpio(node, 0);
-	if (ret < 0)
-		return ret;
-	dht11->gpio = ret;
-	ret = devm_gpio_request_one(dev, dht11->gpio, GPIOF_IN, pdev->name);
-	if (ret)
-		return ret;
-
-	dht11->irq = gpio_to_irq(dht11->gpio);
+	dht11->irq = gpiod_to_irq(dht11->gpiod);
 	if (dht11->irq < 0) {
-		dev_err(dev, "GPIO %d has no interrupt\n", dht11->gpio);
+		dev_err(dev, "GPIO %d has no interrupt\n", desc_to_gpio(dht11->gpiod));
 		return -EINVAL;
 	}
 

commit c942fddf8793b2013be8c901b47d0a8dc02bf99f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:06 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 157
    
    Based on 3 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [kishon] [vijay] [abraham]
      [i] [kishon]@[ti] [com] this program is distributed in the hope that
      it will be useful but without any warranty without even the implied
      warranty of merchantability or fitness for a particular purpose see
      the gnu general public license for more details
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version [author] [graeme] [gregory]
      [gg]@[slimlogic] [co] [uk] [author] [kishon] [vijay] [abraham] [i]
      [kishon]@[ti] [com] [based] [on] [twl6030]_[usb] [c] [author] [hema]
      [hk] [hemahk]@[ti] [com] this program is distributed in the hope
      that it will be useful but without any warranty without even the
      implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1105 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.202006027@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index 1a9f8f4ffb88..c8159205c77d 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -1,17 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * DHT11/DHT22 bit banging GPIO driver
  *
  * Copyright (c) Harald Geyer <harald@ccbib.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
  */
 
 #include <linux/err.h>

commit a6bffb6920d16fb2ef4ba072fac5b64b36b1c254
Author: Harald Geyer <harald@ccbib.org>
Date:   Sun Feb 11 11:09:40 2018 +0000

    iio: dht11: Improve detection of sensor type
    
    The old code was based on a DHT11 datasheet which specifies a measurement
    range of 20%-90% RH. Turns out the sensor actually reports values outside
    this range, so we should support it as far as possible.
    
    Reported-by: Edward Attfield <edward@attfield.ca>
    Signed-off-by: Harald Geyer <harald@ccbib.org>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index df6bab40d6fa..1a9f8f4ffb88 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -159,7 +159,7 @@ static int dht11_decode(struct dht11 *dht11, int offset)
 	}
 
 	dht11->timestamp = ktime_get_boot_ns();
-	if (hum_int < 20) {  /* DHT22 */
+	if (hum_int < 4) {  /* DHT22: 100000 = (3*256+232)*100 */
 		dht11->temperature = (((temp_int & 0x7f) << 8) + temp_dec) *
 					((temp_int & 0x80) ? -100 : 100);
 		dht11->humidity = ((hum_int << 8) + hum_dec) * 100;

commit 13a8c6c2a1138309dcf7744cb4db7aea54d8085a
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sun Jul 23 17:25:58 2017 +0100

    iio:humidity: drop assign iio_info.driver_module and iio_trigger_ops.owner
    
    The equivalent of both of these are now done via macro magic when
    the relevant register calls are made.  The actual structure
    elements will shortly go away.
    
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index 2a22ad920333..df6bab40d6fa 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -284,7 +284,6 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 }
 
 static const struct iio_info dht11_iio_info = {
-	.driver_module		= THIS_MODULE,
 	.read_raw		= dht11_read_raw,
 };
 

commit 5c113b5e0082e90d2e1c7b12e96a7b8cf0623e27
Author: John Brooks <john@fastquake.com>
Date:   Wed Jan 18 21:50:39 2017 +0000

    iio: dht11: Use usleep_range instead of msleep for start signal
    
    The DHT22 (AM2302) datasheet specifies that the LOW start pulse should not
    exceed 20ms. However, observations with an oscilloscope of an RPi Model 2B
    (rev 1.1) communicating with a DHT22 sensor showed that the driver was
    consistently sending start pulses longer than 20ms:
    
    Kernel 4.7.10-v7+ (n=132):
        Minimum pulse length: 20.20ms
        Maximum:              29.84ms
        Mean:                 24.96ms
        StDev:                2.82ms
        Sensor response rate: 100%
        Read success rate:    76%
    
    On kernel 4.8, the start pulse was so long that the sensor would not even
    respond 97% of the time:
    
    Kernel 4.8.16-v7+ (n=100):
        Minimum pulse length: 30.4ms
        Maximum:              74.4ms
        Mean:                 39.3ms
        StDev:                10.2ms
        Sensor response rate: 3%
        Read success rate:    3%
    
    The driver would return ETIMEDOUT and write log messages like this:
    
    [   51.430987] dht11 dht11@0: Only 1 signal edges detected
    [   66.311019] dht11 dht11@0: Only 0 signal edges detected
    
    Replacing msleep(18) with usleep_range(18000, 20000) made the pulse length
    sane again and restored responsiveness:
    
    Kernel 4.8.16-v7+ with usleep_range (n=123):
        Minimum pulse length: 18.16ms
        Maximum:              20.20ms
        Mean:                 19.85ms
        StDev:                0.51ms
        Sensor response rate: 100%
        Read success rate:    84%
    
    Cc: stable@vger.kernel.org
    Signed-off-by: John Brooks <john@fastquake.com>
    Reviewed-by: Harald Geyer <harald@ccbib.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index 9c47bc98f3ac..2a22ad920333 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -71,7 +71,8 @@
  * a) select an implementation using busy loop polling on those systems
  * b) use the checksum to do some probabilistic decoding
  */
-#define DHT11_START_TRANSMISSION	18  /* ms */
+#define DHT11_START_TRANSMISSION_MIN	18000  /* us */
+#define DHT11_START_TRANSMISSION_MAX	20000  /* us */
 #define DHT11_MIN_TIMERES	34000  /* ns */
 #define DHT11_THRESHOLD		49000  /* ns */
 #define DHT11_AMBIG_LOW		23000  /* ns */
@@ -228,7 +229,8 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 		ret = gpio_direction_output(dht11->gpio, 0);
 		if (ret)
 			goto err;
-		msleep(DHT11_START_TRANSMISSION);
+		usleep_range(DHT11_START_TRANSMISSION_MIN,
+			     DHT11_START_TRANSMISSION_MAX);
 		ret = gpio_direction_input(dht11->gpio);
 		if (ret)
 			goto err;

commit ab4b6496a26f87ceff95ee6c0449e6ac2de2f2e4
Author: Harald Geyer <harald@ccbib.org>
Date:   Sun Jan 17 16:13:31 2016 +0000

    iio: dht11: Improve logging
    
    * Unify log messages
    * Add more DEBUG messages
    
    Apparently this driver is working unreliably on some platforms that I can't
    test. Therefore I want an easy way for bug reporters to provide useful
    information without making the driver too chatty by default.
    
    Signed-off-by: Harald Geyer <harald@ccbib.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index 20b500da94db..9c47bc98f3ac 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -96,6 +96,24 @@ struct dht11 {
 	struct {s64 ts; int value; }	edges[DHT11_EDGES_PER_READ];
 };
 
+#ifdef CONFIG_DYNAMIC_DEBUG
+/*
+ * dht11_edges_print: show the data as actually received by the
+ *                    driver.
+ */
+static void dht11_edges_print(struct dht11 *dht11)
+{
+	int i;
+
+	dev_dbg(dht11->dev, "%d edges detected:\n", dht11->num_edges);
+	for (i = 1; i < dht11->num_edges; ++i) {
+		dev_dbg(dht11->dev, "%d: %lld ns %s\n", i,
+			dht11->edges[i].ts - dht11->edges[i - 1].ts,
+			dht11->edges[i - 1].value ? "high" : "low");
+	}
+}
+#endif /* CONFIG_DYNAMIC_DEBUG */
+
 static unsigned char dht11_decode_byte(char *bits)
 {
 	unsigned char ret = 0;
@@ -119,8 +137,12 @@ static int dht11_decode(struct dht11 *dht11, int offset)
 	for (i = 0; i < DHT11_BITS_PER_READ; ++i) {
 		t = dht11->edges[offset + 2 * i + 2].ts -
 			dht11->edges[offset + 2 * i + 1].ts;
-		if (!dht11->edges[offset + 2 * i + 1].value)
-			return -EIO;  /* lost synchronisation */
+		if (!dht11->edges[offset + 2 * i + 1].value) {
+			dev_dbg(dht11->dev,
+				"lost synchronisation at edge %d\n",
+				offset + 2 * i + 1);
+			return -EIO;
+		}
 		bits[i] = t > DHT11_THRESHOLD;
 	}
 
@@ -130,8 +152,10 @@ static int dht11_decode(struct dht11 *dht11, int offset)
 	temp_dec = dht11_decode_byte(&bits[24]);
 	checksum = dht11_decode_byte(&bits[32]);
 
-	if (((hum_int + hum_dec + temp_int + temp_dec) & 0xff) != checksum)
+	if (((hum_int + hum_dec + temp_int + temp_dec) & 0xff) != checksum) {
+		dev_dbg(dht11->dev, "invalid checksum\n");
 		return -EIO;
+	}
 
 	dht11->timestamp = ktime_get_boot_ns();
 	if (hum_int < 20) {  /* DHT22 */
@@ -182,6 +206,7 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 	mutex_lock(&dht11->lock);
 	if (dht11->timestamp + DHT11_DATA_VALID_TIME < ktime_get_boot_ns()) {
 		timeres = ktime_get_resolution_ns();
+		dev_dbg(dht11->dev, "current timeresolution: %dns\n", timeres);
 		if (timeres > DHT11_MIN_TIMERES) {
 			dev_err(dht11->dev, "timeresolution %dns too low\n",
 				timeres);
@@ -219,10 +244,13 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 
 		free_irq(dht11->irq, iio_dev);
 
+#ifdef CONFIG_DYNAMIC_DEBUG
+		dht11_edges_print(dht11);
+#endif
+
 		if (ret == 0 && dht11->num_edges < DHT11_EDGES_PER_READ - 1) {
-			dev_err(&iio_dev->dev,
-				"Only %d signal edges detected\n",
-					dht11->num_edges);
+			dev_err(dht11->dev, "Only %d signal edges detected\n",
+				dht11->num_edges);
 			ret = -ETIMEDOUT;
 		}
 		if (ret < 0)

commit 5ba907a949562cd4839b0170a13dda6841055e70
Merge: abb4f8addf1d 388f7b1d6e8c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Feb 7 17:34:04 2016 -0800

    Merge 4.5-rc3 into staging-next
    
    We want the upstream staging fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 17a2f46c3d8877fe2a0b6ff391d1df30e67892a6
Author: Abhilash Jindal <klock.android@gmail.com>
Date:   Wed Jan 27 17:46:02 2016 -0500

    iio: dht11: Use boottime
    
    Wall time obtained from ktime_get_real_ns is susceptible to sudden jumps due to
    user setting the time or due to NTP.  Boot time is constantly increasing time
    better suited for comparing two timestamps.
    
    Signed-off-by: Abhilash Jindal <klock.android@gmail.com>
    Reviewed-by: Harald Geyer <harald@ccbib.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index 1165b1c4f9d6..cfc5a051ab9f 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -117,7 +117,7 @@ static int dht11_decode(struct dht11 *dht11, int offset, int timeres)
 	if (((hum_int + hum_dec + temp_int + temp_dec) & 0xff) != checksum)
 		return -EIO;
 
-	dht11->timestamp = ktime_get_real_ns();
+	dht11->timestamp = ktime_get_boot_ns();
 	if (hum_int < 20) {  /* DHT22 */
 		dht11->temperature = (((temp_int & 0x7f) << 8) + temp_dec) *
 					((temp_int & 0x80) ? -100 : 100);
@@ -145,7 +145,7 @@ static irqreturn_t dht11_handle_irq(int irq, void *data)
 
 	/* TODO: Consider making the handler safe for IRQ sharing */
 	if (dht11->num_edges < DHT11_EDGES_PER_READ && dht11->num_edges >= 0) {
-		dht11->edges[dht11->num_edges].ts = ktime_get_real_ns();
+		dht11->edges[dht11->num_edges].ts = ktime_get_boot_ns();
 		dht11->edges[dht11->num_edges++].value =
 						gpio_get_value(dht11->gpio);
 
@@ -164,7 +164,7 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 	int ret, timeres;
 
 	mutex_lock(&dht11->lock);
-	if (dht11->timestamp + DHT11_DATA_VALID_TIME < ktime_get_real_ns()) {
+	if (dht11->timestamp + DHT11_DATA_VALID_TIME < ktime_get_boot_ns()) {
 		timeres = ktime_get_resolution_ns();
 		if (DHT11_DATA_BIT_HIGH < 2 * timeres) {
 			dev_err(dht11->dev, "timeresolution %dns too low\n",
@@ -279,7 +279,7 @@ static int dht11_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
-	dht11->timestamp = ktime_get_real_ns() - DHT11_DATA_VALID_TIME - 1;
+	dht11->timestamp = ktime_get_boot_ns() - DHT11_DATA_VALID_TIME - 1;
 	dht11->num_edges = -1;
 
 	platform_set_drvdata(pdev, iio);

commit 155a57593d38cf7153c01cc037373462aa1e1cc1
Author: Harald Geyer <harald@ccbib.org>
Date:   Sun Jan 17 16:13:30 2016 +0000

    iio: dht11: Simplify decoding algorithm
    
    The new algorithm uses a 'one size fits em all' threshold, which should
    be easier to understand and debug. I believe there are no regressions
    compared to the old adaptive threshold algorithm. I don't remember why
    I chose the old algorithm when I initially wrote the driver.
    
    Signed-off-by: Harald Geyer <harald@ccbib.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index 1ca284aaacfc..96185f8fad88 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -50,12 +50,32 @@
 #define DHT11_EDGES_PER_READ (2 * DHT11_BITS_PER_READ + \
 			      DHT11_EDGES_PREAMBLE + 1)
 
-/* Data transmission timing (nano seconds) */
+/*
+ * Data transmission timing:
+ * Data bits are encoded as pulse length (high time) on the data line.
+ * 0-bit: 22-30uS -- typically 26uS (AM2302)
+ * 1-bit: 68-75uS -- typically 70uS (AM2302)
+ * The acutal timings also depend on the properties of the cable, with
+ * longer cables typically making pulses shorter.
+ *
+ * Our decoding depends on the time resolution of the system:
+ * timeres > 34uS ... don't know what a 1-tick pulse is
+ * 34uS > timeres > 30uS ... no problem (30kHz and 32kHz clocks)
+ * 30uS > timeres > 23uS ... don't know what a 2-tick pulse is
+ * timeres < 23uS ... no problem
+ *
+ * Luckily clocks in the 33-44kHz range are quite uncommon, so we can
+ * support most systems if the threshold for decoding a pulse as 1-bit
+ * is chosen carefully. If somebody really wants to support clocks around
+ * 40kHz, where this driver is most unreliable, there are two options.
+ * a) select an implementation using busy loop polling on those systems
+ * b) use the checksum to do some probabilistic decoding
+ */
 #define DHT11_START_TRANSMISSION	18  /* ms */
-#define DHT11_SENSOR_RESPONSE	80000
-#define DHT11_START_BIT		50000
-#define DHT11_DATA_BIT_LOW	27000
-#define DHT11_DATA_BIT_HIGH	70000
+#define DHT11_MIN_TIMERES	34000  /* ns */
+#define DHT11_THRESHOLD		49000  /* ns */
+#define DHT11_AMBIG_LOW		23000  /* ns */
+#define DHT11_AMBIG_HIGH	30000  /* ns */
 
 struct dht11 {
 	struct device			*dev;
@@ -76,43 +96,39 @@ struct dht11 {
 	struct {s64 ts; int value; }	edges[DHT11_EDGES_PER_READ];
 };
 
-static unsigned char dht11_decode_byte(int *timing, int threshold)
+static unsigned char dht11_decode_byte(char *bits)
 {
 	unsigned char ret = 0;
 	int i;
 
 	for (i = 0; i < 8; ++i) {
 		ret <<= 1;
-		if (timing[i] >= threshold)
+		if (bits[i])
 			++ret;
 	}
 
 	return ret;
 }
 
-static int dht11_decode(struct dht11 *dht11, int offset, int timeres)
+static int dht11_decode(struct dht11 *dht11, int offset)
 {
-	int i, t, timing[DHT11_BITS_PER_READ], threshold;
+	int i, t;
+	char bits[DHT11_BITS_PER_READ];
 	unsigned char temp_int, temp_dec, hum_int, hum_dec, checksum;
 
-	threshold = DHT11_DATA_BIT_HIGH / timeres;
-	if (DHT11_DATA_BIT_LOW / timeres + 1 >= threshold)
-		pr_err("dht11: WARNING: decoding ambiguous\n");
-
-	/* scale down with timeres and check validity */
 	for (i = 0; i < DHT11_BITS_PER_READ; ++i) {
 		t = dht11->edges[offset + 2 * i + 2].ts -
 			dht11->edges[offset + 2 * i + 1].ts;
 		if (!dht11->edges[offset + 2 * i + 1].value)
 			return -EIO;  /* lost synchronisation */
-		timing[i] = t / timeres;
+		bits[i] = t > DHT11_THRESHOLD;
 	}
 
-	hum_int = dht11_decode_byte(timing, threshold);
-	hum_dec = dht11_decode_byte(&timing[8], threshold);
-	temp_int = dht11_decode_byte(&timing[16], threshold);
-	temp_dec = dht11_decode_byte(&timing[24], threshold);
-	checksum = dht11_decode_byte(&timing[32], threshold);
+	hum_int = dht11_decode_byte(bits);
+	hum_dec = dht11_decode_byte(&bits[8]);
+	temp_int = dht11_decode_byte(&bits[16]);
+	temp_dec = dht11_decode_byte(&bits[24]);
+	checksum = dht11_decode_byte(&bits[32]);
 
 	if (((hum_int + hum_dec + temp_int + temp_dec) & 0xff) != checksum)
 		return -EIO;
@@ -166,7 +182,7 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 	mutex_lock(&dht11->lock);
 	if (dht11->timestamp + DHT11_DATA_VALID_TIME < ktime_get_real_ns()) {
 		timeres = ktime_get_resolution_ns();
-		if (DHT11_DATA_BIT_HIGH < 2 * timeres) {
+		if (timeres > DHT11_MIN_TIMERES) {
 			dev_err(dht11->dev, "timeresolution %dns too low\n",
 				timeres);
 			/* In theory a better clock could become available
@@ -176,6 +192,10 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 			ret = -EAGAIN;
 			goto err;
 		}
+		if (timeres > DHT11_AMBIG_LOW && timeres < DHT11_AMBIG_HIGH)
+			dev_warn(dht11->dev,
+				 "timeresolution: %dns - decoding ambiguous\n",
+				 timeres);
 
 		reinit_completion(&dht11->completion);
 
@@ -211,7 +231,7 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 		offset = DHT11_EDGES_PREAMBLE +
 				dht11->num_edges - DHT11_EDGES_PER_READ;
 		for (; offset >= 0; --offset) {
-			ret = dht11_decode(dht11, offset, timeres);
+			ret = dht11_decode(dht11, offset);
 			if (!ret)
 				break;
 		}

commit 22acc120a141ce0a3b6e98799d15970ef687bc70
Author: Harald Geyer <harald@ccbib.org>
Date:   Sun Jan 17 16:13:29 2016 +0000

    iio: dht11: Improve reliability - be more tolerant about missing start bits
    
    Instead of guessing where the data starts, we now just try to decode from
    every possible start position. This causes no additional overhead if we
    properly received the full preamble and only costs a few extra CPU cycles
    in the case where the preamble is corrupted. This is much more efficient
    than to return an error to userspace and start over again.
    
    Signed-off-by: Harald Geyer <harald@ccbib.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index 1165b1c4f9d6..1ca284aaacfc 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -161,7 +161,7 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 			int *val, int *val2, long m)
 {
 	struct dht11 *dht11 = iio_priv(iio_dev);
-	int ret, timeres;
+	int ret, timeres, offset;
 
 	mutex_lock(&dht11->lock);
 	if (dht11->timestamp + DHT11_DATA_VALID_TIME < ktime_get_real_ns()) {
@@ -208,11 +208,14 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 		if (ret < 0)
 			goto err;
 
-		ret = dht11_decode(dht11,
-				   dht11->num_edges == DHT11_EDGES_PER_READ ?
-					DHT11_EDGES_PREAMBLE :
-					DHT11_EDGES_PREAMBLE - 2,
-				timeres);
+		offset = DHT11_EDGES_PREAMBLE +
+				dht11->num_edges - DHT11_EDGES_PER_READ;
+		for (; offset >= 0; --offset) {
+			ret = dht11_decode(dht11, offset, timeres);
+			if (!ret)
+				break;
+		}
+
 		if (ret)
 			goto err;
 	}

commit 081d974031bafb204d64de3e82f398daf1d0b899
Author: Harald Geyer <harald@ccbib.org>
Date:   Tue Jul 7 13:39:31 2015 +0000

    iio: dht11: Use new function ktime_get_resolution_ns()
    
    This cleans up the most ugly workaround in this driver. There are no
    functional changes yet in the decoding algorithm, but we improve the
    following things:
     * Get rid of spurious warning messages on systems with fast HRTIMER.
     * If the clock is not fast enough for decoding to work, we give
       up immediately.
     * In that case we return EAGAIN instead of EIO, so it's easier to
       discriminate causes of failure.
    
    Returning EAGAIN is somewhat controversial: It's technically correct
    as a faster clock might become available. OTOH once all clocks are
    enabled this is a permanent error. There is no ECLOCKTOOSLOW error
    code.
    
    Signed-off-by: Harald Geyer <harald@ccbib.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index 91976e06f1c6..1165b1c4f9d6 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -33,6 +33,7 @@
 #include <linux/delay.h>
 #include <linux/gpio.h>
 #include <linux/of_gpio.h>
+#include <linux/timekeeping.h>
 
 #include <linux/iio/iio.h>
 
@@ -89,23 +90,11 @@ static unsigned char dht11_decode_byte(int *timing, int threshold)
 	return ret;
 }
 
-static int dht11_decode(struct dht11 *dht11, int offset)
+static int dht11_decode(struct dht11 *dht11, int offset, int timeres)
 {
-	int i, t, timing[DHT11_BITS_PER_READ], threshold,
-		timeres = DHT11_SENSOR_RESPONSE;
+	int i, t, timing[DHT11_BITS_PER_READ], threshold;
 	unsigned char temp_int, temp_dec, hum_int, hum_dec, checksum;
 
-	/* Calculate timestamp resolution */
-	for (i = 1; i < dht11->num_edges; ++i) {
-		t = dht11->edges[i].ts - dht11->edges[i - 1].ts;
-		if (t > 0 && t < timeres)
-			timeres = t;
-	}
-	if (2 * timeres > DHT11_DATA_BIT_HIGH) {
-		pr_err("dht11: timeresolution %d too bad for decoding\n",
-		       timeres);
-		return -EIO;
-	}
 	threshold = DHT11_DATA_BIT_HIGH / timeres;
 	if (DHT11_DATA_BIT_LOW / timeres + 1 >= threshold)
 		pr_err("dht11: WARNING: decoding ambiguous\n");
@@ -128,7 +117,7 @@ static int dht11_decode(struct dht11 *dht11, int offset)
 	if (((hum_int + hum_dec + temp_int + temp_dec) & 0xff) != checksum)
 		return -EIO;
 
-	dht11->timestamp = iio_get_time_ns();
+	dht11->timestamp = ktime_get_real_ns();
 	if (hum_int < 20) {  /* DHT22 */
 		dht11->temperature = (((temp_int & 0x7f) << 8) + temp_dec) *
 					((temp_int & 0x80) ? -100 : 100);
@@ -156,7 +145,7 @@ static irqreturn_t dht11_handle_irq(int irq, void *data)
 
 	/* TODO: Consider making the handler safe for IRQ sharing */
 	if (dht11->num_edges < DHT11_EDGES_PER_READ && dht11->num_edges >= 0) {
-		dht11->edges[dht11->num_edges].ts = iio_get_time_ns();
+		dht11->edges[dht11->num_edges].ts = ktime_get_real_ns();
 		dht11->edges[dht11->num_edges++].value =
 						gpio_get_value(dht11->gpio);
 
@@ -172,10 +161,22 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 			int *val, int *val2, long m)
 {
 	struct dht11 *dht11 = iio_priv(iio_dev);
-	int ret;
+	int ret, timeres;
 
 	mutex_lock(&dht11->lock);
-	if (dht11->timestamp + DHT11_DATA_VALID_TIME < iio_get_time_ns()) {
+	if (dht11->timestamp + DHT11_DATA_VALID_TIME < ktime_get_real_ns()) {
+		timeres = ktime_get_resolution_ns();
+		if (DHT11_DATA_BIT_HIGH < 2 * timeres) {
+			dev_err(dht11->dev, "timeresolution %dns too low\n",
+				timeres);
+			/* In theory a better clock could become available
+			 * at some point ... and there is no error code
+			 * that really fits better.
+			 */
+			ret = -EAGAIN;
+			goto err;
+		}
+
 		reinit_completion(&dht11->completion);
 
 		dht11->num_edges = 0;
@@ -210,7 +211,8 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 		ret = dht11_decode(dht11,
 				   dht11->num_edges == DHT11_EDGES_PER_READ ?
 					DHT11_EDGES_PREAMBLE :
-					DHT11_EDGES_PREAMBLE - 2);
+					DHT11_EDGES_PREAMBLE - 2,
+				timeres);
 		if (ret)
 			goto err;
 	}
@@ -277,7 +279,7 @@ static int dht11_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
-	dht11->timestamp = iio_get_time_ns() - DHT11_DATA_VALID_TIME - 1;
+	dht11->timestamp = ktime_get_real_ns() - DHT11_DATA_VALID_TIME - 1;
 	dht11->num_edges = -1;
 
 	platform_set_drvdata(pdev, iio);

commit 5fbb0bc466b7b43036b1dd8c9e9166ca9e69e07a
Author: Harald Geyer <harald@ccbib.org>
Date:   Tue Jul 7 13:39:30 2015 +0000

    iio: dht11: avoid multiple assignments to make checkpatch.pl --strict happy
    
    We just do the assignments in two steps.
    
    Signed-off-by: Harald Geyer <harald@ccbib.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index bb5ad57ed2a2..91976e06f1c6 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -263,9 +263,10 @@ static int dht11_probe(struct platform_device *pdev)
 	dht11 = iio_priv(iio);
 	dht11->dev = dev;
 
-	dht11->gpio = ret = of_get_gpio(node, 0);
+	ret = of_get_gpio(node, 0);
 	if (ret < 0)
 		return ret;
+	dht11->gpio = ret;
 	ret = devm_gpio_request_one(dev, dht11->gpio, GPIOF_IN, pdev->name);
 	if (ret)
 		return ret;

commit a7126003b6dd47c0088d952734379ef471156c5f
Author: Harald Geyer <harald@ccbib.org>
Date:   Tue Jul 7 13:39:29 2015 +0000

    iio: dht11: add comment to make checkpatch.pl --strict happy
    
    Explain why the driver needs a mutex.
    
    Signed-off-by: Harald Geyer <harald@ccbib.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index 343d26af1dd8..bb5ad57ed2a2 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -63,6 +63,7 @@ struct dht11 {
 	int				irq;
 
 	struct completion		completion;
+	/* The iio sysfs interface doesn't prevent concurrent reads: */
 	struct mutex			lock;
 
 	s64				timestamp;

commit 889c5e9b668670c91dcd3a8f2b15a0b2086f4827
Author: Harald Geyer <harald@ccbib.org>
Date:   Tue Jul 7 13:39:28 2015 +0000

    iio: dht11: whitespace changes to make checkpatch.pl --strict happy
    
    * add spaces around binary operators in cases where it reduces readability
    * align multiline statements around opening parenthesis
    
    Reported-by: Hartmut Knaack <knaack.h@gmx.de>
            in Message-ID: <55919E72.3010807@gmx.de>
    
    Signed-off-by: Harald Geyer <harald@ccbib.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index 7d79a1ac5f5f..343d26af1dd8 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -46,7 +46,8 @@
  * Note that when reading the sensor actually 84 edges are detected, but
  * since the last edge is not significant, we only store 83:
  */
-#define DHT11_EDGES_PER_READ (2*DHT11_BITS_PER_READ + DHT11_EDGES_PREAMBLE + 1)
+#define DHT11_EDGES_PER_READ (2 * DHT11_BITS_PER_READ + \
+			      DHT11_EDGES_PREAMBLE + 1)
 
 /* Data transmission timing (nano seconds) */
 #define DHT11_START_TRANSMISSION	18  /* ms */
@@ -95,24 +96,24 @@ static int dht11_decode(struct dht11 *dht11, int offset)
 
 	/* Calculate timestamp resolution */
 	for (i = 1; i < dht11->num_edges; ++i) {
-		t = dht11->edges[i].ts - dht11->edges[i-1].ts;
+		t = dht11->edges[i].ts - dht11->edges[i - 1].ts;
 		if (t > 0 && t < timeres)
 			timeres = t;
 	}
-	if (2*timeres > DHT11_DATA_BIT_HIGH) {
+	if (2 * timeres > DHT11_DATA_BIT_HIGH) {
 		pr_err("dht11: timeresolution %d too bad for decoding\n",
-			timeres);
+		       timeres);
 		return -EIO;
 	}
 	threshold = DHT11_DATA_BIT_HIGH / timeres;
-	if (DHT11_DATA_BIT_LOW/timeres + 1 >= threshold)
+	if (DHT11_DATA_BIT_LOW / timeres + 1 >= threshold)
 		pr_err("dht11: WARNING: decoding ambiguous\n");
 
 	/* scale down with timeres and check validity */
 	for (i = 0; i < DHT11_BITS_PER_READ; ++i) {
-		t = dht11->edges[offset + 2*i + 2].ts -
-			dht11->edges[offset + 2*i + 1].ts;
-		if (!dht11->edges[offset + 2*i + 1].value)
+		t = dht11->edges[offset + 2 * i + 2].ts -
+			dht11->edges[offset + 2 * i + 1].ts;
+		if (!dht11->edges[offset + 2 * i + 1].value)
 			return -EIO;  /* lost synchronisation */
 		timing[i] = t / timeres;
 	}
@@ -166,7 +167,7 @@ static irqreturn_t dht11_handle_irq(int irq, void *data)
 }
 
 static int dht11_read_raw(struct iio_dev *iio_dev,
-			const struct iio_chan_spec *chan,
+			  const struct iio_chan_spec *chan,
 			int *val, int *val2, long m)
 {
 	struct dht11 *dht11 = iio_priv(iio_dev);
@@ -192,13 +193,13 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 			goto err;
 
 		ret = wait_for_completion_killable_timeout(&dht11->completion,
-								 HZ);
+							   HZ);
 
 		free_irq(dht11->irq, iio_dev);
 
 		if (ret == 0 && dht11->num_edges < DHT11_EDGES_PER_READ - 1) {
 			dev_err(&iio_dev->dev,
-					"Only %d signal edges detected\n",
+				"Only %d signal edges detected\n",
 					dht11->num_edges);
 			ret = -ETIMEDOUT;
 		}
@@ -206,7 +207,7 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 			goto err;
 
 		ret = dht11_decode(dht11,
-				dht11->num_edges == DHT11_EDGES_PER_READ ?
+				   dht11->num_edges == DHT11_EDGES_PER_READ ?
 					DHT11_EDGES_PREAMBLE :
 					DHT11_EDGES_PREAMBLE - 2);
 		if (ret)

commit 94e65519abde01cbffb9c538a4598f6a50bc86d1
Author: Richard Weinberger <richard@nod.at>
Date:   Wed Jan 7 13:22:49 2015 +0100

    iio: dht11: IRQ fixes
    
    Since setting irq-enabled GPIOs into output state is not supported
    by all GPIO controllers, we need to disable the irq while requesting
    sensor data. As side effect we lose a tiny bit of functionality:
    Some wiring problems can't be concluded from log messages anymore.
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Harald Geyer <harald@ccbib.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index 7717f5c3395b..7d79a1ac5f5f 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -40,8 +40,12 @@
 
 #define DHT11_DATA_VALID_TIME	2000000000  /* 2s in ns */
 
-#define DHT11_EDGES_PREAMBLE 4
+#define DHT11_EDGES_PREAMBLE 2
 #define DHT11_BITS_PER_READ 40
+/*
+ * Note that when reading the sensor actually 84 edges are detected, but
+ * since the last edge is not significant, we only store 83:
+ */
 #define DHT11_EDGES_PER_READ (2*DHT11_BITS_PER_READ + DHT11_EDGES_PREAMBLE + 1)
 
 /* Data transmission timing (nano seconds) */
@@ -140,6 +144,27 @@ static int dht11_decode(struct dht11 *dht11, int offset)
 	return 0;
 }
 
+/*
+ * IRQ handler called on GPIO edges
+ */
+static irqreturn_t dht11_handle_irq(int irq, void *data)
+{
+	struct iio_dev *iio = data;
+	struct dht11 *dht11 = iio_priv(iio);
+
+	/* TODO: Consider making the handler safe for IRQ sharing */
+	if (dht11->num_edges < DHT11_EDGES_PER_READ && dht11->num_edges >= 0) {
+		dht11->edges[dht11->num_edges].ts = iio_get_time_ns();
+		dht11->edges[dht11->num_edges++].value =
+						gpio_get_value(dht11->gpio);
+
+		if (dht11->num_edges >= DHT11_EDGES_PER_READ)
+			complete(&dht11->completion);
+	}
+
+	return IRQ_HANDLED;
+}
+
 static int dht11_read_raw(struct iio_dev *iio_dev,
 			const struct iio_chan_spec *chan,
 			int *val, int *val2, long m)
@@ -160,8 +185,17 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 		if (ret)
 			goto err;
 
+		ret = request_irq(dht11->irq, dht11_handle_irq,
+				  IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+				  iio_dev->name, iio_dev);
+		if (ret)
+			goto err;
+
 		ret = wait_for_completion_killable_timeout(&dht11->completion,
 								 HZ);
+
+		free_irq(dht11->irq, iio_dev);
+
 		if (ret == 0 && dht11->num_edges < DHT11_EDGES_PER_READ - 1) {
 			dev_err(&iio_dev->dev,
 					"Only %d signal edges detected\n",
@@ -197,27 +231,6 @@ static const struct iio_info dht11_iio_info = {
 	.read_raw		= dht11_read_raw,
 };
 
-/*
- * IRQ handler called on GPIO edges
-*/
-static irqreturn_t dht11_handle_irq(int irq, void *data)
-{
-	struct iio_dev *iio = data;
-	struct dht11 *dht11 = iio_priv(iio);
-
-	/* TODO: Consider making the handler safe for IRQ sharing */
-	if (dht11->num_edges < DHT11_EDGES_PER_READ && dht11->num_edges >= 0) {
-		dht11->edges[dht11->num_edges].ts = iio_get_time_ns();
-		dht11->edges[dht11->num_edges++].value =
-						gpio_get_value(dht11->gpio);
-
-		if (dht11->num_edges >= DHT11_EDGES_PER_READ)
-			complete(&dht11->completion);
-	}
-
-	return IRQ_HANDLED;
-}
-
 static const struct iio_chan_spec dht11_chan_spec[] = {
 	{ .type = IIO_TEMP,
 		.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED), },
@@ -260,11 +273,6 @@ static int dht11_probe(struct platform_device *pdev)
 		dev_err(dev, "GPIO %d has no interrupt\n", dht11->gpio);
 		return -EINVAL;
 	}
-	ret = devm_request_irq(dev, dht11->irq, dht11_handle_irq,
-				IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
-				pdev->name, iio);
-	if (ret)
-		return ret;
 
 	dht11->timestamp = iio_get_time_ns() - DHT11_DATA_VALID_TIME - 1;
 	dht11->num_edges = -1;

commit 004bc530341a40536494431cf665504f8ee70266
Author: Richard Weinberger <richard@nod.at>
Date:   Wed Jan 7 13:18:23 2015 +0100

    iio: dht11: Add locking
    
    Make sure that the read function is not interrupted...
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Acked-by: Harald Geyer <harald@ccbib.org>
    Reviewed-by: Sanjeev Sharma <sanjeev_sharma@mentor.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index f546ecae90f1..7717f5c3395b 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -29,6 +29,7 @@
 #include <linux/wait.h>
 #include <linux/bitops.h>
 #include <linux/completion.h>
+#include <linux/mutex.h>
 #include <linux/delay.h>
 #include <linux/gpio.h>
 #include <linux/of_gpio.h>
@@ -57,6 +58,7 @@ struct dht11 {
 	int				irq;
 
 	struct completion		completion;
+	struct mutex			lock;
 
 	s64				timestamp;
 	int				temperature;
@@ -145,6 +147,7 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 	struct dht11 *dht11 = iio_priv(iio_dev);
 	int ret;
 
+	mutex_lock(&dht11->lock);
 	if (dht11->timestamp + DHT11_DATA_VALID_TIME < iio_get_time_ns()) {
 		reinit_completion(&dht11->completion);
 
@@ -185,6 +188,7 @@ static int dht11_read_raw(struct iio_dev *iio_dev,
 		ret = -EINVAL;
 err:
 	dht11->num_edges = -1;
+	mutex_unlock(&dht11->lock);
 	return ret;
 }
 
@@ -268,6 +272,7 @@ static int dht11_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, iio);
 
 	init_completion(&dht11->completion);
+	mutex_init(&dht11->lock);
 	iio->name = pdev->name;
 	iio->dev.parent = &pdev->dev;
 	iio->info = &dht11_iio_info;

commit ddc25bdd2b7f34667111714fafc9c04f6ad97fee
Author: Richard Weinberger <richard@nod.at>
Date:   Wed Jan 7 13:15:22 2015 +0100

    iio: dht11: Fix out-of-bounds read
    
    As we access i-1 we must not start with i=0.
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Acked-by: Hartmut Knaack <knaack.h@gmx.de>
    Acked-by: Harald Geyer <harald@ccbib.org>
    Reviewed-by: Sanjeev Sharma <sanjeev_sharma@mentor.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index 623c145d8a97..f546ecae90f1 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -88,7 +88,7 @@ static int dht11_decode(struct dht11 *dht11, int offset)
 	unsigned char temp_int, temp_dec, hum_int, hum_dec, checksum;
 
 	/* Calculate timestamp resolution */
-	for (i = 0; i < dht11->num_edges; ++i) {
+	for (i = 1; i < dht11->num_edges; ++i) {
 		t = dht11->edges[i].ts - dht11->edges[i-1].ts;
 		if (t > 0 && t < timeres)
 			timeres = t;

commit 81816affeacfa360bfefabba774774e95f3dcc12
Author: Sanjeev Sharma <sanjeev_sharma@mentor.com>
Date:   Wed Aug 20 10:32:00 2014 +0100

    iio: remove .owner field for driver using module_platform_driver
    
    This patch removes the .owner field for drivers which use the
    platform_driver_register api because this is overriden in
    _platform_driver_register.
    
    Signed-off-by: Sanjeev Sharma <Sanjeev_Sharma@mentor.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
index d8771f546bf2..623c145d8a97 100644
--- a/drivers/iio/humidity/dht11.c
+++ b/drivers/iio/humidity/dht11.c
@@ -281,7 +281,6 @@ static int dht11_probe(struct platform_device *pdev)
 static struct platform_driver dht11_driver = {
 	.driver = {
 		.name	= DRIVER_NAME,
-		.owner	= THIS_MODULE,
 		.of_match_table = dht11_dt_ids,
 	},
 	.probe  = dht11_probe,

commit 091a121b04547fab2045951aff6219318ede0560
Author: Harald Geyer <harald@ccbib.org>
Date:   Sun Dec 1 15:04:00 2013 +0000

    iio: Add new driver dht11
    
    This driver handles DHT11 and DHT22 sensors.
    
    Signed-off-by: Harald Geyer <harald@ccbib.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/humidity/dht11.c b/drivers/iio/humidity/dht11.c
new file mode 100644
index 000000000000..d8771f546bf2
--- /dev/null
+++ b/drivers/iio/humidity/dht11.c
@@ -0,0 +1,294 @@
+/*
+ * DHT11/DHT22 bit banging GPIO driver
+ *
+ * Copyright (c) Harald Geyer <harald@ccbib.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/printk.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/sysfs.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/wait.h>
+#include <linux/bitops.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+
+#include <linux/iio/iio.h>
+
+#define DRIVER_NAME	"dht11"
+
+#define DHT11_DATA_VALID_TIME	2000000000  /* 2s in ns */
+
+#define DHT11_EDGES_PREAMBLE 4
+#define DHT11_BITS_PER_READ 40
+#define DHT11_EDGES_PER_READ (2*DHT11_BITS_PER_READ + DHT11_EDGES_PREAMBLE + 1)
+
+/* Data transmission timing (nano seconds) */
+#define DHT11_START_TRANSMISSION	18  /* ms */
+#define DHT11_SENSOR_RESPONSE	80000
+#define DHT11_START_BIT		50000
+#define DHT11_DATA_BIT_LOW	27000
+#define DHT11_DATA_BIT_HIGH	70000
+
+struct dht11 {
+	struct device			*dev;
+
+	int				gpio;
+	int				irq;
+
+	struct completion		completion;
+
+	s64				timestamp;
+	int				temperature;
+	int				humidity;
+
+	/* num_edges: -1 means "no transmission in progress" */
+	int				num_edges;
+	struct {s64 ts; int value; }	edges[DHT11_EDGES_PER_READ];
+};
+
+static unsigned char dht11_decode_byte(int *timing, int threshold)
+{
+	unsigned char ret = 0;
+	int i;
+
+	for (i = 0; i < 8; ++i) {
+		ret <<= 1;
+		if (timing[i] >= threshold)
+			++ret;
+	}
+
+	return ret;
+}
+
+static int dht11_decode(struct dht11 *dht11, int offset)
+{
+	int i, t, timing[DHT11_BITS_PER_READ], threshold,
+		timeres = DHT11_SENSOR_RESPONSE;
+	unsigned char temp_int, temp_dec, hum_int, hum_dec, checksum;
+
+	/* Calculate timestamp resolution */
+	for (i = 0; i < dht11->num_edges; ++i) {
+		t = dht11->edges[i].ts - dht11->edges[i-1].ts;
+		if (t > 0 && t < timeres)
+			timeres = t;
+	}
+	if (2*timeres > DHT11_DATA_BIT_HIGH) {
+		pr_err("dht11: timeresolution %d too bad for decoding\n",
+			timeres);
+		return -EIO;
+	}
+	threshold = DHT11_DATA_BIT_HIGH / timeres;
+	if (DHT11_DATA_BIT_LOW/timeres + 1 >= threshold)
+		pr_err("dht11: WARNING: decoding ambiguous\n");
+
+	/* scale down with timeres and check validity */
+	for (i = 0; i < DHT11_BITS_PER_READ; ++i) {
+		t = dht11->edges[offset + 2*i + 2].ts -
+			dht11->edges[offset + 2*i + 1].ts;
+		if (!dht11->edges[offset + 2*i + 1].value)
+			return -EIO;  /* lost synchronisation */
+		timing[i] = t / timeres;
+	}
+
+	hum_int = dht11_decode_byte(timing, threshold);
+	hum_dec = dht11_decode_byte(&timing[8], threshold);
+	temp_int = dht11_decode_byte(&timing[16], threshold);
+	temp_dec = dht11_decode_byte(&timing[24], threshold);
+	checksum = dht11_decode_byte(&timing[32], threshold);
+
+	if (((hum_int + hum_dec + temp_int + temp_dec) & 0xff) != checksum)
+		return -EIO;
+
+	dht11->timestamp = iio_get_time_ns();
+	if (hum_int < 20) {  /* DHT22 */
+		dht11->temperature = (((temp_int & 0x7f) << 8) + temp_dec) *
+					((temp_int & 0x80) ? -100 : 100);
+		dht11->humidity = ((hum_int << 8) + hum_dec) * 100;
+	} else if (temp_dec == 0 && hum_dec == 0) {  /* DHT11 */
+		dht11->temperature = temp_int * 1000;
+		dht11->humidity = hum_int * 1000;
+	} else {
+		dev_err(dht11->dev,
+			"Don't know how to decode data: %d %d %d %d\n",
+			hum_int, hum_dec, temp_int, temp_dec);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int dht11_read_raw(struct iio_dev *iio_dev,
+			const struct iio_chan_spec *chan,
+			int *val, int *val2, long m)
+{
+	struct dht11 *dht11 = iio_priv(iio_dev);
+	int ret;
+
+	if (dht11->timestamp + DHT11_DATA_VALID_TIME < iio_get_time_ns()) {
+		reinit_completion(&dht11->completion);
+
+		dht11->num_edges = 0;
+		ret = gpio_direction_output(dht11->gpio, 0);
+		if (ret)
+			goto err;
+		msleep(DHT11_START_TRANSMISSION);
+		ret = gpio_direction_input(dht11->gpio);
+		if (ret)
+			goto err;
+
+		ret = wait_for_completion_killable_timeout(&dht11->completion,
+								 HZ);
+		if (ret == 0 && dht11->num_edges < DHT11_EDGES_PER_READ - 1) {
+			dev_err(&iio_dev->dev,
+					"Only %d signal edges detected\n",
+					dht11->num_edges);
+			ret = -ETIMEDOUT;
+		}
+		if (ret < 0)
+			goto err;
+
+		ret = dht11_decode(dht11,
+				dht11->num_edges == DHT11_EDGES_PER_READ ?
+					DHT11_EDGES_PREAMBLE :
+					DHT11_EDGES_PREAMBLE - 2);
+		if (ret)
+			goto err;
+	}
+
+	ret = IIO_VAL_INT;
+	if (chan->type == IIO_TEMP)
+		*val = dht11->temperature;
+	else if (chan->type == IIO_HUMIDITYRELATIVE)
+		*val = dht11->humidity;
+	else
+		ret = -EINVAL;
+err:
+	dht11->num_edges = -1;
+	return ret;
+}
+
+static const struct iio_info dht11_iio_info = {
+	.driver_module		= THIS_MODULE,
+	.read_raw		= dht11_read_raw,
+};
+
+/*
+ * IRQ handler called on GPIO edges
+*/
+static irqreturn_t dht11_handle_irq(int irq, void *data)
+{
+	struct iio_dev *iio = data;
+	struct dht11 *dht11 = iio_priv(iio);
+
+	/* TODO: Consider making the handler safe for IRQ sharing */
+	if (dht11->num_edges < DHT11_EDGES_PER_READ && dht11->num_edges >= 0) {
+		dht11->edges[dht11->num_edges].ts = iio_get_time_ns();
+		dht11->edges[dht11->num_edges++].value =
+						gpio_get_value(dht11->gpio);
+
+		if (dht11->num_edges >= DHT11_EDGES_PER_READ)
+			complete(&dht11->completion);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static const struct iio_chan_spec dht11_chan_spec[] = {
+	{ .type = IIO_TEMP,
+		.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED), },
+	{ .type = IIO_HUMIDITYRELATIVE,
+		.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED), }
+};
+
+static const struct of_device_id dht11_dt_ids[] = {
+	{ .compatible = "dht11", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, dht11_dt_ids);
+
+static int dht11_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *node = dev->of_node;
+	struct dht11 *dht11;
+	struct iio_dev *iio;
+	int ret;
+
+	iio = devm_iio_device_alloc(dev, sizeof(*dht11));
+	if (!iio) {
+		dev_err(dev, "Failed to allocate IIO device\n");
+		return -ENOMEM;
+	}
+
+	dht11 = iio_priv(iio);
+	dht11->dev = dev;
+
+	dht11->gpio = ret = of_get_gpio(node, 0);
+	if (ret < 0)
+		return ret;
+	ret = devm_gpio_request_one(dev, dht11->gpio, GPIOF_IN, pdev->name);
+	if (ret)
+		return ret;
+
+	dht11->irq = gpio_to_irq(dht11->gpio);
+	if (dht11->irq < 0) {
+		dev_err(dev, "GPIO %d has no interrupt\n", dht11->gpio);
+		return -EINVAL;
+	}
+	ret = devm_request_irq(dev, dht11->irq, dht11_handle_irq,
+				IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+				pdev->name, iio);
+	if (ret)
+		return ret;
+
+	dht11->timestamp = iio_get_time_ns() - DHT11_DATA_VALID_TIME - 1;
+	dht11->num_edges = -1;
+
+	platform_set_drvdata(pdev, iio);
+
+	init_completion(&dht11->completion);
+	iio->name = pdev->name;
+	iio->dev.parent = &pdev->dev;
+	iio->info = &dht11_iio_info;
+	iio->modes = INDIO_DIRECT_MODE;
+	iio->channels = dht11_chan_spec;
+	iio->num_channels = ARRAY_SIZE(dht11_chan_spec);
+
+	return devm_iio_device_register(dev, iio);
+}
+
+static struct platform_driver dht11_driver = {
+	.driver = {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = dht11_dt_ids,
+	},
+	.probe  = dht11_probe,
+};
+
+module_platform_driver(dht11_driver);
+
+MODULE_AUTHOR("Harald Geyer <harald@ccbib.org>");
+MODULE_DESCRIPTION("DHT11 humidity/temperature sensor driver");
+MODULE_LICENSE("GPL v2");
