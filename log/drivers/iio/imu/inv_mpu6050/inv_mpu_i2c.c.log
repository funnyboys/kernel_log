commit fb3f7ab7736d22aae8282a1d56f3187ecf9cb66f
Author: Nishant Malpani <nish.malpani25@gmail.com>
Date:   Sun Mar 22 22:53:11 2020 +0530

    iio: imu: inv_mpu6050_i2c: Use vsprintf extension %pe for symbolic error name
    
    Utilize %pe format specifier from vsprintf while printing error logs
    with dev_err(). Discards the use of unnecessary explicit casting and
    prints symbolic error name which might prove to be convenient during
    debugging.
    
    Signed-off-by: Nishant Malpani <nish.malpani25@gmail.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index 6993d3b87bb0..28cfae1e61cf 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -122,8 +122,8 @@ static int inv_mpu_probe(struct i2c_client *client,
 
 	regmap = devm_regmap_init_i2c(client, &inv_mpu_regmap_config);
 	if (IS_ERR(regmap)) {
-		dev_err(&client->dev, "Failed to register i2c regmap %d\n",
-			(int)PTR_ERR(regmap));
+		dev_err(&client->dev, "Failed to register i2c regmap: %pe\n",
+			regmap);
 		return PTR_ERR(regmap);
 	}
 

commit a3aaf7770a8887cedf216becc5392e481ee1fcaa
Author: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
Date:   Wed Feb 19 15:39:48 2020 +0100

    iio: imu: inv_mpu6050: set power on/off only once during all init
    
    This way there is no need anymore to export the power function to
    i2c and spi modules.
    Bus setup is done inside init when power is on and the result is
    now checked.
    
    Signed-off-by: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index 24df880248f2..6993d3b87bb0 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -78,22 +78,13 @@ static int inv_mpu_i2c_aux_setup(struct iio_dev *indio_dev)
 
 	/* enable i2c bypass when using i2c auxiliary bus */
 	if (inv_mpu_i2c_aux_bus(dev)) {
-		ret = inv_mpu6050_set_power_itg(st, true);
-		if (ret)
-			return ret;
 		ret = regmap_write(st->map, st->reg->int_pin_cfg,
 				   st->irq_mask | INV_MPU6050_BIT_BYPASS_EN);
 		if (ret)
-			goto error;
-		ret = inv_mpu6050_set_power_itg(st, false);
-		if (ret)
-			goto error;
+			return ret;
 	}
 
 	return 0;
-error:
-	inv_mpu6050_set_power_itg(st, false);
-	return ret;
 }
 
 /**

commit ddfd781dc4d851e5cfc114b64219d05796f0e809
Author: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
Date:   Wed Feb 19 15:39:46 2020 +0100

    iio: imu: inv_mpu6050: enable i2c aux mux bypass only once
    
    i2c auxiliary mux is done by analog switches. You do not need to
    set them for every i2c transfer.
    Just set i2c bypass bit at init and do noting in i2c de/select.
    
    Signed-off-by: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index 1363d3776523..24df880248f2 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -20,38 +20,6 @@ static const struct regmap_config inv_mpu_regmap_config = {
 
 static int inv_mpu6050_select_bypass(struct i2c_mux_core *muxc, u32 chan_id)
 {
-	struct iio_dev *indio_dev = i2c_mux_priv(muxc);
-	struct inv_mpu6050_state *st = iio_priv(indio_dev);
-	int ret;
-
-	mutex_lock(&st->lock);
-
-	ret = inv_mpu6050_set_power_itg(st, true);
-	if (ret)
-		goto error_unlock;
-
-	ret = regmap_write(st->map, st->reg->int_pin_cfg,
-			   st->irq_mask | INV_MPU6050_BIT_BYPASS_EN);
-
-error_unlock:
-	mutex_unlock(&st->lock);
-
-	return ret;
-}
-
-static int inv_mpu6050_deselect_bypass(struct i2c_mux_core *muxc, u32 chan_id)
-{
-	struct iio_dev *indio_dev = i2c_mux_priv(muxc);
-	struct inv_mpu6050_state *st = iio_priv(indio_dev);
-
-	mutex_lock(&st->lock);
-
-	/* It doesn't really matter if any of the calls fail */
-	regmap_write(st->map, st->reg->int_pin_cfg, st->irq_mask);
-	inv_mpu6050_set_power_itg(st, false);
-
-	mutex_unlock(&st->lock);
-
 	return 0;
 }
 
@@ -79,19 +47,20 @@ static bool inv_mpu_i2c_aux_bus(struct device *dev)
 	}
 }
 
-/*
- * MPU9xxx magnetometer support requires to disable i2c auxiliary bus support.
- * To ensure backward compatibility with existing setups, do not disable
- * i2c auxiliary bus if it used.
- * Check for i2c-gate node in devicetree and set magnetometer disabled.
- * Only MPU6500 is supported by ACPI, no need to check.
- */
-static int inv_mpu_magn_disable(struct iio_dev *indio_dev)
+static int inv_mpu_i2c_aux_setup(struct iio_dev *indio_dev)
 {
 	struct inv_mpu6050_state *st = iio_priv(indio_dev);
 	struct device *dev = indio_dev->dev.parent;
 	struct device_node *mux_node;
+	int ret;
 
+	/*
+	 * MPU9xxx magnetometer support requires to disable i2c auxiliary bus.
+	 * To ensure backward compatibility with existing setups, do not disable
+	 * i2c auxiliary bus if it used.
+	 * Check for i2c-gate node in devicetree and set magnetometer disabled.
+	 * Only MPU6500 is supported by ACPI, no need to check.
+	 */
 	switch (st->chip_type) {
 	case INV_MPU9150:
 	case INV_MPU9250:
@@ -107,7 +76,24 @@ static int inv_mpu_magn_disable(struct iio_dev *indio_dev)
 		break;
 	}
 
+	/* enable i2c bypass when using i2c auxiliary bus */
+	if (inv_mpu_i2c_aux_bus(dev)) {
+		ret = inv_mpu6050_set_power_itg(st, true);
+		if (ret)
+			return ret;
+		ret = regmap_write(st->map, st->reg->int_pin_cfg,
+				   st->irq_mask | INV_MPU6050_BIT_BYPASS_EN);
+		if (ret)
+			goto error;
+		ret = inv_mpu6050_set_power_itg(st, false);
+		if (ret)
+			goto error;
+	}
+
 	return 0;
+error:
+	inv_mpu6050_set_power_itg(st, false);
+	return ret;
 }
 
 /**
@@ -151,7 +137,7 @@ static int inv_mpu_probe(struct i2c_client *client,
 	}
 
 	result = inv_mpu_core_probe(regmap, client->irq, name,
-				    inv_mpu_magn_disable, chip_type);
+				    inv_mpu_i2c_aux_setup, chip_type);
 	if (result < 0)
 		return result;
 
@@ -160,8 +146,7 @@ static int inv_mpu_probe(struct i2c_client *client,
 		/* declare i2c auxiliary bus */
 		st->muxc = i2c_mux_alloc(client->adapter, &client->dev,
 					 1, 0, I2C_MUX_LOCKED | I2C_MUX_GATE,
-					 inv_mpu6050_select_bypass,
-					 inv_mpu6050_deselect_bypass);
+					 inv_mpu6050_select_bypass, NULL);
 		if (!st->muxc)
 			return -ENOMEM;
 		st->muxc->priv = dev_get_drvdata(&client->dev);

commit 8abce87d39912e57ade3c141049ffa2eea85846b
Author: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
Date:   Thu Feb 6 11:31:03 2020 +0100

    iio: imu: inv_mpu6050: add support of ICM20690
    
    Same generation as ICM20602 but different registers.
    
    Signed-off-by: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index cd0eeb5dc7f6..1363d3776523 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -208,6 +208,7 @@ static const struct i2c_device_id inv_mpu_id[] = {
 	{"icm20609", INV_ICM20609},
 	{"icm20689", INV_ICM20689},
 	{"icm20602", INV_ICM20602},
+	{"icm20690", INV_ICM20690},
 	{"iam20680", INV_IAM20680},
 	{}
 };
@@ -255,6 +256,10 @@ static const struct of_device_id inv_of_match[] = {
 		.compatible = "invensense,icm20602",
 		.data = (void *)INV_ICM20602
 	},
+	{
+		.compatible = "invensense,icm20690",
+		.data = (void *)INV_ICM20690
+	},
 	{
 		.compatible = "invensense,iam20680",
 		.data = (void *)INV_IAM20680

commit d31f74e60804cba1d7b265708b820e524e574611
Author: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
Date:   Thu Feb 6 11:31:02 2020 +0100

    iio: imu: inv_mpu6050: add support of IAM20680
    
    Automotive certified IMU, similar to ICM20608.
    
    Signed-off-by: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index dd054e21216a..cd0eeb5dc7f6 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -64,6 +64,7 @@ static bool inv_mpu_i2c_aux_bus(struct device *dev)
 	case INV_ICM20609:
 	case INV_ICM20689:
 	case INV_ICM20602:
+	case INV_IAM20680:
 		/* no i2c auxiliary bus on the chip */
 		return false;
 	case INV_MPU9150:
@@ -207,6 +208,7 @@ static const struct i2c_device_id inv_mpu_id[] = {
 	{"icm20609", INV_ICM20609},
 	{"icm20689", INV_ICM20689},
 	{"icm20602", INV_ICM20602},
+	{"iam20680", INV_IAM20680},
 	{}
 };
 
@@ -253,6 +255,10 @@ static const struct of_device_id inv_of_match[] = {
 		.compatible = "invensense,icm20602",
 		.data = (void *)INV_ICM20602
 	},
+	{
+		.compatible = "invensense,iam20680",
+		.data = (void *)INV_IAM20680
+	},
 	{ }
 };
 MODULE_DEVICE_TABLE(of, inv_of_match);

commit 23db8d6959314568b243fd2bc76bee50136afa4c
Author: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
Date:   Thu Feb 6 11:31:01 2020 +0100

    iio: imu: inv_mpu6050: add support of ICM20609 & ICM20689
    
    They are similar to ICM20608 chip.
    
    Signed-off-by: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index 49e9aa777ba4..dd054e21216a 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -61,6 +61,8 @@ static bool inv_mpu_i2c_aux_bus(struct device *dev)
 
 	switch (st->chip_type) {
 	case INV_ICM20608:
+	case INV_ICM20609:
+	case INV_ICM20689:
 	case INV_ICM20602:
 		/* no i2c auxiliary bus on the chip */
 		return false;
@@ -202,6 +204,8 @@ static const struct i2c_device_id inv_mpu_id[] = {
 	{"mpu9250", INV_MPU9250},
 	{"mpu9255", INV_MPU9255},
 	{"icm20608", INV_ICM20608},
+	{"icm20609", INV_ICM20609},
+	{"icm20689", INV_ICM20689},
 	{"icm20602", INV_ICM20602},
 	{}
 };
@@ -237,6 +241,14 @@ static const struct of_device_id inv_of_match[] = {
 		.compatible = "invensense,icm20608",
 		.data = (void *)INV_ICM20608
 	},
+	{
+		.compatible = "invensense,icm20609",
+		.data = (void *)INV_ICM20609
+	},
+	{
+		.compatible = "invensense,icm20689",
+		.data = (void *)INV_ICM20689
+	},
 	{
 		.compatible = "invensense,icm20602",
 		.data = (void *)INV_ICM20602

commit 4235cc30c906a4ddc59e9aa3db2e06d3faffcb3a
Author: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
Date:   Thu Feb 6 11:31:00 2020 +0100

    iio: imu: inv_mpu6050: cleanup of/acpi support
    
    Use device_get_match_data for using of and acpi tables.
    In spi support add missing mpu6515 and of match table.
    Reorganize Kconfig to display chips grouped by generations.
    
    Signed-off-by: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index f47a28b4be23..49e9aa777ba4 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -10,6 +10,7 @@
 #include <linux/iio/iio.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
+#include <linux/property.h>
 #include "inv_mpu_iio.h"
 
 static const struct regmap_config inv_mpu_regmap_config = {
@@ -54,20 +55,6 @@ static int inv_mpu6050_deselect_bypass(struct i2c_mux_core *muxc, u32 chan_id)
 	return 0;
 }
 
-static const char *inv_mpu_match_acpi_device(struct device *dev,
-					     enum inv_devices *chip_id)
-{
-	const struct acpi_device_id *id;
-
-	id = acpi_match_device(dev->driver->acpi_match_table, dev);
-	if (!id)
-		return NULL;
-
-	*chip_id = (int)id->driver_data;
-
-	return dev_name(dev);
-}
-
 static bool inv_mpu_i2c_aux_bus(struct device *dev)
 {
 	struct inv_mpu6050_state *st = iio_priv(dev_get_drvdata(dev));
@@ -130,6 +117,7 @@ static int inv_mpu_magn_disable(struct iio_dev *indio_dev)
 static int inv_mpu_probe(struct i2c_client *client,
 			 const struct i2c_device_id *id)
 {
+	const void *match;
 	struct inv_mpu6050_state *st;
 	int result;
 	enum inv_devices chip_type;
@@ -140,18 +128,14 @@ static int inv_mpu_probe(struct i2c_client *client,
 				     I2C_FUNC_SMBUS_I2C_BLOCK))
 		return -EOPNOTSUPP;
 
-	if (client->dev.of_node) {
-		chip_type = (enum inv_devices)
-			of_device_get_match_data(&client->dev);
+	match = device_get_match_data(&client->dev);
+	if (match) {
+		chip_type = (enum inv_devices)match;
 		name = client->name;
 	} else if (id) {
 		chip_type = (enum inv_devices)
 			id->driver_data;
 		name = id->name;
-	} else if (ACPI_HANDLE(&client->dev)) {
-		name = inv_mpu_match_acpi_device(&client->dev, &chip_type);
-		if (!name)
-			return -ENODEV;
 	} else {
 		return -ENOSYS;
 	}

commit a2587eb032f1679dd695b9e5113bcb6b52e46e0a
Author: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
Date:   Fri Nov 15 15:06:22 2019 +0100

    iio: imu: inv_mpu6050: add support of MPU9150 magnetometer
    
    Add support for driving MPU9150 magnetometer (AK8975) from mpu.
    
    Signed-off-by: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index 389cc8505e0e..f47a28b4be23 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -77,6 +77,7 @@ static bool inv_mpu_i2c_aux_bus(struct device *dev)
 	case INV_ICM20602:
 		/* no i2c auxiliary bus on the chip */
 		return false;
+	case INV_MPU9150:
 	case INV_MPU9250:
 	case INV_MPU9255:
 		if (st->magn_disabled)
@@ -102,6 +103,7 @@ static int inv_mpu_magn_disable(struct iio_dev *indio_dev)
 	struct device_node *mux_node;
 
 	switch (st->chip_type) {
+	case INV_MPU9150:
 	case INV_MPU9250:
 	case INV_MPU9255:
 		mux_node = of_get_child_by_name(dev->of_node, "i2c-gate");

commit ca4a649694bb159b221eb0cfecec46838473b536
Author: Jean-Baptiste Maneyrol <JManeyrol@invensense.com>
Date:   Mon Sep 16 09:41:58 2019 +0000

    iio: imu: inv_mpu6050: disable i2c mux for MPU925x
    
    Disable i2c mux for supported 9xxx chips. This is a
    pre-requesite for controling 9xxx magnetometer using the
    i2c master of the chip.
    
    Check in device-tree that there is no i2c-gate device declared
    for ensuring backward compatibility with existing setups.
    
    Signed-off-by: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index 4b8b5a87398c..389cc8505e0e 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -68,6 +68,56 @@ static const char *inv_mpu_match_acpi_device(struct device *dev,
 	return dev_name(dev);
 }
 
+static bool inv_mpu_i2c_aux_bus(struct device *dev)
+{
+	struct inv_mpu6050_state *st = iio_priv(dev_get_drvdata(dev));
+
+	switch (st->chip_type) {
+	case INV_ICM20608:
+	case INV_ICM20602:
+		/* no i2c auxiliary bus on the chip */
+		return false;
+	case INV_MPU9250:
+	case INV_MPU9255:
+		if (st->magn_disabled)
+			return true;
+		else
+			return false;
+	default:
+		return true;
+	}
+}
+
+/*
+ * MPU9xxx magnetometer support requires to disable i2c auxiliary bus support.
+ * To ensure backward compatibility with existing setups, do not disable
+ * i2c auxiliary bus if it used.
+ * Check for i2c-gate node in devicetree and set magnetometer disabled.
+ * Only MPU6500 is supported by ACPI, no need to check.
+ */
+static int inv_mpu_magn_disable(struct iio_dev *indio_dev)
+{
+	struct inv_mpu6050_state *st = iio_priv(indio_dev);
+	struct device *dev = indio_dev->dev.parent;
+	struct device_node *mux_node;
+
+	switch (st->chip_type) {
+	case INV_MPU9250:
+	case INV_MPU9255:
+		mux_node = of_get_child_by_name(dev->of_node, "i2c-gate");
+		if (mux_node != NULL) {
+			st->magn_disabled = true;
+			dev_warn(dev, "disable internal use of magnetometer\n");
+		}
+		of_node_put(mux_node);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
 /**
  *  inv_mpu_probe() - probe function.
  *  @client:          i2c client.
@@ -112,17 +162,12 @@ static int inv_mpu_probe(struct i2c_client *client,
 	}
 
 	result = inv_mpu_core_probe(regmap, client->irq, name,
-				    NULL, chip_type);
+				    inv_mpu_magn_disable, chip_type);
 	if (result < 0)
 		return result;
 
 	st = iio_priv(dev_get_drvdata(&client->dev));
-	switch (st->chip_type) {
-	case INV_ICM20608:
-	case INV_ICM20602:
-		/* no i2c auxiliary bus on the chip */
-		break;
-	default:
+	if (inv_mpu_i2c_aux_bus(&client->dev)) {
 		/* declare i2c auxiliary bus */
 		st->muxc = i2c_mux_alloc(client->adapter, &client->dev,
 					 1, 0, I2C_MUX_LOCKED | I2C_MUX_GATE,
@@ -137,7 +182,6 @@ static int inv_mpu_probe(struct i2c_client *client,
 		result = inv_mpu_acpi_create_mux_client(client);
 		if (result)
 			goto out_del_mux;
-		break;
 	}
 
 	return 0;

commit 9c92ab61914157664a2fbdf926df0eb937838e45
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:56 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 282
    
    Based on 1 normalized pattern(s):
    
      this software is licensed under the terms of the gnu general public
      license version 2 as published by the free software foundation and
      may be copied distributed and modified under those terms this
      program is distributed in the hope that it will be useful but
      without any warranty without even the implied warranty of
      merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 285 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.642774971@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index e46eb4ddea21..4b8b5a87398c 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -1,14 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
 * Copyright (C) 2012 Invensense, Inc.
-*
-* This software is licensed under the terms of the GNU General Public
-* License version 2, as published by the Free Software Foundation, and
-* may be copied, distributed, and modified under those terms.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
 */
 
 #include <linux/acpi.h>

commit 22904bdff97839960bd98b3452a583b1daee628b
Author: Randolph Maaßen <gaireg@gaireg.de>
Date:   Mon Jan 28 19:50:03 2019 +0100

    iio: imu: mpu6050: Add support for the ICM 20602 IMU
    
    The Invensense ICM-20602 is a 6-axis MotionTracking device that
    combines a 3-axis gyroscope and an 3-axis accelerometer. It is very
    similar to the ICM-20608 imu which is already supported by the mpu6050
    driver. The main difference is that the ICM-20602 has the i2c bus
    disable bit in a separate register.
    
    Signed-off-by: Randolph Maaßen <gaireg@gaireg.de>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index dd758e3d403d..e46eb4ddea21 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -127,6 +127,7 @@ static int inv_mpu_probe(struct i2c_client *client,
 	st = iio_priv(dev_get_drvdata(&client->dev));
 	switch (st->chip_type) {
 	case INV_ICM20608:
+	case INV_ICM20602:
 		/* no i2c auxiliary bus on the chip */
 		break;
 	default:
@@ -179,6 +180,7 @@ static const struct i2c_device_id inv_mpu_id[] = {
 	{"mpu9250", INV_MPU9250},
 	{"mpu9255", INV_MPU9255},
 	{"icm20608", INV_ICM20608},
+	{"icm20602", INV_ICM20602},
 	{}
 };
 
@@ -213,6 +215,10 @@ static const struct of_device_id inv_of_match[] = {
 		.compatible = "invensense,icm20608",
 		.data = (void *)INV_ICM20608
 	},
+	{
+		.compatible = "invensense,icm20602",
+		.data = (void *)INV_ICM20602
+	},
 	{ }
 };
 MODULE_DEVICE_TABLE(of, inv_of_match);

commit de8df0b9c38d8f232f0df03220ff540a54eaf73d
Author: Brian Masney <masneyb@onstation.org>
Date:   Tue Jul 10 21:09:30 2018 -0400

    iio: imu: mpu6050: add support for 6515 variant
    
    This patch adds support for the MPU 6515 variant. Confirmed that the
    driver functions correctly on a LG Nexus 5 (hammerhead) phone.
    
    Signed-off-by: Brian Masney <masneyb@onstation.org>
    Signed-off-by: Jonathan Marek <jonathan@marek.ca>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index 495409d56207..dd758e3d403d 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -174,6 +174,7 @@ static int inv_mpu_remove(struct i2c_client *client)
 static const struct i2c_device_id inv_mpu_id[] = {
 	{"mpu6050", INV_MPU6050},
 	{"mpu6500", INV_MPU6500},
+	{"mpu6515", INV_MPU6515},
 	{"mpu9150", INV_MPU9150},
 	{"mpu9250", INV_MPU9250},
 	{"mpu9255", INV_MPU9255},
@@ -192,6 +193,10 @@ static const struct of_device_id inv_of_match[] = {
 		.compatible = "invensense,mpu6500",
 		.data = (void *)INV_MPU6500
 	},
+	{
+		.compatible = "invensense,mpu6515",
+		.data = (void *)INV_MPU6515
+	},
 	{
 		.compatible = "invensense,mpu9150",
 		.data = (void *)INV_MPU9150

commit d8b40181464c2c81a1a62ceef798ef9108dd3f39
Author: Martin Kelly <mkelly@xevo.com>
Date:   Tue May 1 10:56:41 2018 -0700

    iio: imu: inv_mpu6050: minor wording fixes
    
    Just some minor grammar/spelling fixes of things I noticed while reading
    the code.
    
    Signed-off-by: Martin Kelly <mkelly@xevo.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index f11ae29d0fa2..495409d56207 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -53,7 +53,7 @@ static int inv_mpu6050_deselect_bypass(struct i2c_mux_core *muxc, u32 chan_id)
 
 	mutex_lock(&st->lock);
 
-	/* It doesn't really mattter, if any of the calls fails */
+	/* It doesn't really matter if any of the calls fail */
 	regmap_write(st->map, st->reg->int_pin_cfg, st->irq_mask);
 	inv_mpu6050_set_power_itg(st, false);
 

commit 3b37c41f0e56aff080d7a5a7f2adae34faa5a325
Author: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
Date:   Mon Apr 30 12:14:08 2018 +0200

    iio: imu: inv_mpu6050: use i2c mux only for chip with i2c aux bus
    
    icm20608 does not have i2c aux bus, so it does not make sense to
    allocate an i2c mux for this chip.
    
    Signed-off-by: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index 90fdc5eaef53..f11ae29d0fa2 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -125,20 +125,27 @@ static int inv_mpu_probe(struct i2c_client *client,
 		return result;
 
 	st = iio_priv(dev_get_drvdata(&client->dev));
-	st->muxc = i2c_mux_alloc(client->adapter, &client->dev,
-				 1, 0, I2C_MUX_LOCKED | I2C_MUX_GATE,
-				 inv_mpu6050_select_bypass,
-				 inv_mpu6050_deselect_bypass);
-	if (!st->muxc)
-		return -ENOMEM;
-	st->muxc->priv = dev_get_drvdata(&client->dev);
-	result = i2c_mux_add_adapter(st->muxc, 0, 0, 0);
-	if (result)
-		return result;
-
-	result = inv_mpu_acpi_create_mux_client(client);
-	if (result)
-		goto out_del_mux;
+	switch (st->chip_type) {
+	case INV_ICM20608:
+		/* no i2c auxiliary bus on the chip */
+		break;
+	default:
+		/* declare i2c auxiliary bus */
+		st->muxc = i2c_mux_alloc(client->adapter, &client->dev,
+					 1, 0, I2C_MUX_LOCKED | I2C_MUX_GATE,
+					 inv_mpu6050_select_bypass,
+					 inv_mpu6050_deselect_bypass);
+		if (!st->muxc)
+			return -ENOMEM;
+		st->muxc->priv = dev_get_drvdata(&client->dev);
+		result = i2c_mux_add_adapter(st->muxc, 0, 0, 0);
+		if (result)
+			return result;
+		result = inv_mpu_acpi_create_mux_client(client);
+		if (result)
+			goto out_del_mux;
+		break;
+	}
 
 	return 0;
 
@@ -152,8 +159,10 @@ static int inv_mpu_remove(struct i2c_client *client)
 	struct iio_dev *indio_dev = i2c_get_clientdata(client);
 	struct inv_mpu6050_state *st = iio_priv(indio_dev);
 
-	inv_mpu_acpi_delete_mux_client(client);
-	i2c_mux_del_adapters(st->muxc);
+	if (st->muxc) {
+		inv_mpu_acpi_delete_mux_client(client);
+		i2c_mux_del_adapters(st->muxc);
+	}
 
 	return 0;
 }

commit 57f1677bd7629792d58915cfe15e09eef2e22c84
Author: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
Date:   Mon Apr 23 12:33:31 2018 +0200

    iio: imu: inv_mpu6050: use devm_* at init and delete remove
    
    Use devm_* for iio_triggered_buffer_setup, iio_device_register,
    iio_trigger_register. Delete unneeded inv_mpu6050_remove_trigger,
    inv_mpu_core_remove, and inv_mpu_remove for spi driver.
    
    Signed-off-by: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index 27e777c58bbe..90fdc5eaef53 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -129,14 +129,12 @@ static int inv_mpu_probe(struct i2c_client *client,
 				 1, 0, I2C_MUX_LOCKED | I2C_MUX_GATE,
 				 inv_mpu6050_select_bypass,
 				 inv_mpu6050_deselect_bypass);
-	if (!st->muxc) {
-		result = -ENOMEM;
-		goto out_unreg_device;
-	}
+	if (!st->muxc)
+		return -ENOMEM;
 	st->muxc->priv = dev_get_drvdata(&client->dev);
 	result = i2c_mux_add_adapter(st->muxc, 0, 0, 0);
 	if (result)
-		goto out_unreg_device;
+		return result;
 
 	result = inv_mpu_acpi_create_mux_client(client);
 	if (result)
@@ -146,8 +144,6 @@ static int inv_mpu_probe(struct i2c_client *client,
 
 out_del_mux:
 	i2c_mux_del_adapters(st->muxc);
-out_unreg_device:
-	inv_mpu_core_remove(&client->dev);
 	return result;
 }
 
@@ -159,7 +155,7 @@ static int inv_mpu_remove(struct i2c_client *client)
 	inv_mpu_acpi_delete_mux_client(client);
 	i2c_mux_del_adapters(st->muxc);
 
-	return inv_mpu_core_remove(&client->dev);
+	return 0;
 }
 
 /*

commit 5ec6486daa98ba4bb18542116db7d867986c0ebe
Author: Martin Kelly <mkelly@xevo.com>
Date:   Fri Apr 20 09:54:00 2018 -0700

    iio:imu: inv_mpu6050: support more interrupt types
    
    Currently, we support only rising edge interrupts, and in fact we assume
    that the interrupt we're given is rising edge (and things won't work if
    it's not). However, the device supports rising edge, falling edge, level
    low, and level high interrupts.
    
    Empirically, on my system, switching to level interrupts has fixed a
    problem I had with significant (~40%) interrupt loss with edge
    interrupts. This issue is likely related to the SoC I'm using (Allwinner
    H3), but being able to switch the interrupt type is still a very useful
    workaround.
    
    I tested this with each interrupt type and verified correct behavior in
    a logic analyzer.
    
    Add support for these interrupt types while also eliminating the error
    case of the device tree and driver using different interrupt types.
    
    Signed-off-by: Martin Kelly <mkelly@xevo.com>
    Acked-by: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index eca34b9ed838..27e777c58bbe 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -38,8 +38,7 @@ static int inv_mpu6050_select_bypass(struct i2c_mux_core *muxc, u32 chan_id)
 		goto error_unlock;
 
 	ret = regmap_write(st->map, st->reg->int_pin_cfg,
-			   INV_MPU6050_INT_PIN_CFG |
-			   INV_MPU6050_BIT_BYPASS_EN);
+			   st->irq_mask | INV_MPU6050_BIT_BYPASS_EN);
 
 error_unlock:
 	mutex_unlock(&st->lock);
@@ -55,7 +54,7 @@ static int inv_mpu6050_deselect_bypass(struct i2c_mux_core *muxc, u32 chan_id)
 	mutex_lock(&st->lock);
 
 	/* It doesn't really mattter, if any of the calls fails */
-	regmap_write(st->map, st->reg->int_pin_cfg, INV_MPU6050_INT_PIN_CFG);
+	regmap_write(st->map, st->reg->int_pin_cfg, st->irq_mask);
 	inv_mpu6050_set_power_itg(st, false);
 
 	mutex_unlock(&st->lock);

commit 17623d9a2310213648e7b563b44eb680d49e0524
Author: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
Date:   Tue Apr 17 09:19:40 2018 +0200

    iio: imu: inv_mpu6050: use set_power_itg function in i2c mux
    
    Set power function is rewritten manually inside i2c mux select.
    Better use the already identical existing function.
    
    Signed-off-by: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index f70e7b9ef663..eca34b9ed838 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -29,25 +29,19 @@ static int inv_mpu6050_select_bypass(struct i2c_mux_core *muxc, u32 chan_id)
 {
 	struct iio_dev *indio_dev = i2c_mux_priv(muxc);
 	struct inv_mpu6050_state *st = iio_priv(indio_dev);
-	int ret = 0;
+	int ret;
 
-	/* Use the same mutex which was used everywhere to protect power-op */
 	mutex_lock(&st->lock);
-	if (!st->powerup_count) {
-		ret = regmap_write(st->map, st->reg->pwr_mgmt_1, 0);
-		if (ret)
-			goto write_error;
 
-		usleep_range(INV_MPU6050_REG_UP_TIME_MIN,
-			     INV_MPU6050_REG_UP_TIME_MAX);
-	}
-	if (!ret) {
-		st->powerup_count++;
-		ret = regmap_write(st->map, st->reg->int_pin_cfg,
-				   INV_MPU6050_INT_PIN_CFG |
-				   INV_MPU6050_BIT_BYPASS_EN);
-	}
-write_error:
+	ret = inv_mpu6050_set_power_itg(st, true);
+	if (ret)
+		goto error_unlock;
+
+	ret = regmap_write(st->map, st->reg->int_pin_cfg,
+			   INV_MPU6050_INT_PIN_CFG |
+			   INV_MPU6050_BIT_BYPASS_EN);
+
+error_unlock:
 	mutex_unlock(&st->lock);
 
 	return ret;
@@ -59,12 +53,11 @@ static int inv_mpu6050_deselect_bypass(struct i2c_mux_core *muxc, u32 chan_id)
 	struct inv_mpu6050_state *st = iio_priv(indio_dev);
 
 	mutex_lock(&st->lock);
+
 	/* It doesn't really mattter, if any of the calls fails */
 	regmap_write(st->map, st->reg->int_pin_cfg, INV_MPU6050_INT_PIN_CFG);
-	st->powerup_count--;
-	if (!st->powerup_count)
-		regmap_write(st->map, st->reg->pwr_mgmt_1,
-			     INV_MPU6050_BIT_SLEEP);
+	inv_mpu6050_set_power_itg(st, false);
+
 	mutex_unlock(&st->lock);
 
 	return 0;

commit 685cc61b07c599a5d352cc63b21d6a4cbcebaed6
Author: Douglas Fischer <fischerdouglasc@gmail.com>
Date:   Mon Apr 2 18:42:00 2018 -0400

    iio: imu: Add mpu9255 support to mpu6050 driver
    
    Added support for the mpu9255 IMU to the mpu6050 driver. The
    register map is the same as the other chips; the only driver
    difference is the compatible string and the WHOAMI register
    value.
    
    Signed-off-by: Douglas Fischer <fischerdouglasc@gmail.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index fcd7a92b6cf8..f70e7b9ef663 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -179,6 +179,7 @@ static const struct i2c_device_id inv_mpu_id[] = {
 	{"mpu6500", INV_MPU6500},
 	{"mpu9150", INV_MPU9150},
 	{"mpu9250", INV_MPU9250},
+	{"mpu9255", INV_MPU9255},
 	{"icm20608", INV_ICM20608},
 	{}
 };
@@ -202,6 +203,10 @@ static const struct of_device_id inv_of_match[] = {
 		.compatible = "invensense,mpu9250",
 		.data = (void *)INV_MPU9250
 	},
+	{
+		.compatible = "invensense,mpu9255",
+		.data = (void *)INV_MPU9255
+	},
 	{
 		.compatible = "invensense,icm20608",
 		.data = (void *)INV_ICM20608

commit 68cd6e5b206b21ff5226c806c55fd8c718d5bde5
Author: Jean-Baptiste Maneyrol <JManeyrol@invensense.com>
Date:   Wed Jun 7 13:41:42 2017 +0000

    iio: imu: inv_mpu6050: fix lock issues by using our own mutex
    
    There are several locks issues when using buffer and direct polling
    data at the same time. Use our own mutex for managing locking and
    block simultaneous use of buffer and direct polling by using
    iio_device_{claim/release}_direct_mode. This makes chip_config
    enable bit obsolete, so delete it.
    
    Signed-off-by: Jean-Baptiste Maneyrol <jmaneyrol@invensense.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index 64b5f5b92200..fcd7a92b6cf8 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -32,7 +32,7 @@ static int inv_mpu6050_select_bypass(struct i2c_mux_core *muxc, u32 chan_id)
 	int ret = 0;
 
 	/* Use the same mutex which was used everywhere to protect power-op */
-	mutex_lock(&indio_dev->mlock);
+	mutex_lock(&st->lock);
 	if (!st->powerup_count) {
 		ret = regmap_write(st->map, st->reg->pwr_mgmt_1, 0);
 		if (ret)
@@ -48,7 +48,7 @@ static int inv_mpu6050_select_bypass(struct i2c_mux_core *muxc, u32 chan_id)
 				   INV_MPU6050_BIT_BYPASS_EN);
 	}
 write_error:
-	mutex_unlock(&indio_dev->mlock);
+	mutex_unlock(&st->lock);
 
 	return ret;
 }
@@ -58,14 +58,14 @@ static int inv_mpu6050_deselect_bypass(struct i2c_mux_core *muxc, u32 chan_id)
 	struct iio_dev *indio_dev = i2c_mux_priv(muxc);
 	struct inv_mpu6050_state *st = iio_priv(indio_dev);
 
-	mutex_lock(&indio_dev->mlock);
+	mutex_lock(&st->lock);
 	/* It doesn't really mattter, if any of the calls fails */
 	regmap_write(st->map, st->reg->int_pin_cfg, INV_MPU6050_INT_PIN_CFG);
 	st->powerup_count--;
 	if (!st->powerup_count)
 		regmap_write(st->map, st->reg->pwr_mgmt_1,
 			     INV_MPU6050_BIT_SLEEP);
-	mutex_unlock(&indio_dev->mlock);
+	mutex_unlock(&st->lock);
 
 	return 0;
 }

commit 0c8f492dd7ddf0dd381fa63b76066c0966d8dd73
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sun Mar 26 12:11:00 2017 +0100

    iio:imu:mpu6050 add explicit mpu9250 support
    
    The mpu9250 is a SIP containing an mpu6500 and an ak8975.  If this was all
    there was too it there would be no need for explicit handling in the driver.
    Arguably the bindings would also only reflect the presence of an mpu6500 with
    the ak8975 hanging off it, as the kernel doesn't care that they are in one
    package.
    
    However, the WHOAMI value changes as well so best to add explicit support.
    
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index a8e6330cb906..64b5f5b92200 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -178,6 +178,7 @@ static const struct i2c_device_id inv_mpu_id[] = {
 	{"mpu6050", INV_MPU6050},
 	{"mpu6500", INV_MPU6500},
 	{"mpu9150", INV_MPU9150},
+	{"mpu9250", INV_MPU9250},
 	{"icm20608", INV_ICM20608},
 	{}
 };
@@ -197,6 +198,10 @@ static const struct of_device_id inv_of_match[] = {
 		.compatible = "invensense,mpu9150",
 		.data = (void *)INV_MPU9150
 	},
+	{
+		.compatible = "invensense,mpu9250",
+		.data = (void *)INV_MPU9250
+	},
 	{
 		.compatible = "invensense,icm20608",
 		.data = (void *)INV_ICM20608

commit 34591a162fa053896e491e3b5f0c8192259fa4f9
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Wed Mar 15 01:44:56 2017 -0300

    iio: imu: inv_mpu6050: Add OF device ID table
    
    The driver doesn't have a struct of_device_id table but supported devices
    are registered via Device Trees. This is working on the assumption that a
    I2C device registered via OF will always match a legacy I2C device ID and
    that the MODALIAS reported will always be of the form i2c:<device>.
    
    But this could change in the future so the correct approach is to have an
    OF device ID table if the devices are registered via OF.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index 2c3f8964a3ea..a8e6330cb906 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -17,6 +17,7 @@
 #include <linux/i2c.h>
 #include <linux/iio/iio.h>
 #include <linux/module.h>
+#include <linux/of_device.h>
 #include "inv_mpu_iio.h"
 
 static const struct regmap_config inv_mpu_regmap_config = {
@@ -69,7 +70,8 @@ static int inv_mpu6050_deselect_bypass(struct i2c_mux_core *muxc, u32 chan_id)
 	return 0;
 }
 
-static const char *inv_mpu_match_acpi_device(struct device *dev, int *chip_id)
+static const char *inv_mpu_match_acpi_device(struct device *dev,
+					     enum inv_devices *chip_id)
 {
 	const struct acpi_device_id *id;
 
@@ -93,7 +95,8 @@ static int inv_mpu_probe(struct i2c_client *client,
 			 const struct i2c_device_id *id)
 {
 	struct inv_mpu6050_state *st;
-	int result, chip_type;
+	int result;
+	enum inv_devices chip_type;
 	struct regmap *regmap;
 	const char *name;
 
@@ -101,8 +104,13 @@ static int inv_mpu_probe(struct i2c_client *client,
 				     I2C_FUNC_SMBUS_I2C_BLOCK))
 		return -EOPNOTSUPP;
 
-	if (id) {
-		chip_type = (int)id->driver_data;
+	if (client->dev.of_node) {
+		chip_type = (enum inv_devices)
+			of_device_get_match_data(&client->dev);
+		name = client->name;
+	} else if (id) {
+		chip_type = (enum inv_devices)
+			id->driver_data;
 		name = id->name;
 	} else if (ACPI_HANDLE(&client->dev)) {
 		name = inv_mpu_match_acpi_device(&client->dev, &chip_type);
@@ -176,6 +184,27 @@ static const struct i2c_device_id inv_mpu_id[] = {
 
 MODULE_DEVICE_TABLE(i2c, inv_mpu_id);
 
+static const struct of_device_id inv_of_match[] = {
+	{
+		.compatible = "invensense,mpu6050",
+		.data = (void *)INV_MPU6050
+	},
+	{
+		.compatible = "invensense,mpu6500",
+		.data = (void *)INV_MPU6500
+	},
+	{
+		.compatible = "invensense,mpu9150",
+		.data = (void *)INV_MPU9150
+	},
+	{
+		.compatible = "invensense,icm20608",
+		.data = (void *)INV_ICM20608
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(of, inv_of_match);
+
 static const struct acpi_device_id inv_acpi_match[] = {
 	{"INVN6500", INV_MPU6500},
 	{ },
@@ -188,6 +217,7 @@ static struct i2c_driver inv_mpu_driver = {
 	.remove		=	inv_mpu_remove,
 	.id_table	=	inv_mpu_id,
 	.driver = {
+		.of_match_table = inv_of_match,
 		.acpi_match_table = ACPI_PTR(inv_acpi_match),
 		.name	=	"inv-mpu6050-i2c",
 		.pm     =       &inv_mpu_pmops,

commit 08f3ffce6e8068577b75d8aa3b35a1b8a0c9eb22
Author: Peter Rosin <peda@axentia.se>
Date:   Wed Aug 31 10:02:40 2016 +0200

    iio: imu: inv_mpu6050: inform the i2c mux core about how it is used
    
    The i2c mux core can then take appropriate action depending on if it is
    used for an actual i2c mux, or for an arbitrator or gate. In this case
    it is used as a gate.
    
    This will make devicetree bindings simpler when they are eventually
    added.
    
    Signed-off-by: Peter Rosin <peda@axentia.se>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index 19580d1db597..2c3f8964a3ea 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -126,7 +126,7 @@ static int inv_mpu_probe(struct i2c_client *client,
 
 	st = iio_priv(dev_get_drvdata(&client->dev));
 	st->muxc = i2c_mux_alloc(client->adapter, &client->dev,
-				 1, 0, I2C_MUX_LOCKED,
+				 1, 0, I2C_MUX_LOCKED | I2C_MUX_GATE,
 				 inv_mpu6050_select_bypass,
 				 inv_mpu6050_deselect_bypass);
 	if (!st->muxc) {

commit 468c5620d094e9ead2a0b6802d3c490b4fb6ed03
Author: Gregor Boirie <gregor.boirie@parrot.com>
Date:   Thu Jun 30 19:06:34 2016 +0200

    iio:imu:mpu6050: icm20608 initial support
    
    Introduce support for Invense ICM20608 IMU, a 6-axis motion tracking device
    that combines a 3-axis gyroscope and a 3-axis accelerometer:
    http://www.invensense.com/products/motion-tracking/6-axis/icm-20608-2
    
    Signed-off-by: Gregor Boirie <gregor.boirie@parrot.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index e1fd7fa53e3b..19580d1db597 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -170,6 +170,7 @@ static const struct i2c_device_id inv_mpu_id[] = {
 	{"mpu6050", INV_MPU6050},
 	{"mpu6500", INV_MPU6500},
 	{"mpu9150", INV_MPU9150},
+	{"icm20608", INV_ICM20608},
 	{}
 };
 

commit 2f37dd131c5d3a2eac21cd5baf80658b1b02a8ac
Merge: 3aa2fc1667ac ffc83a79b44e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 20 22:20:48 2016 -0700

    Merge tag 'staging-4.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging and IIO driver updates from Greg KH:
     "Here's the big staging and iio driver update for 4.7-rc1.
    
      I think we almost broke even with this release, only adding a few more
      lines than we removed, which isn't bad overall given that there's a
      bunch of new iio drivers added.
    
      The Lustre developers seem to have woken up from their sleep and have
      been doing a great job in cleaning up the code and pruning unused or
      old cruft, the filesystem is almost readable :)
    
      Other than that, just a lot of basic coding style cleanups in the
      churn.  All have been in linux-next for a while with no reported
      issues"
    
    * tag 'staging-4.7-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (938 commits)
      Staging: emxx_udc: emxx_udc: fixed coding style issue
      staging/gdm724x: fix "alignment should match open parenthesis" issues
      staging/gdm724x: Fix avoid CamelCase
      staging: unisys: rename misleading var ii with frag
      staging: unisys: visorhba: switch success handling to error handling
      staging: unisys: visorhba: main path needs to flow down the left margin
      staging: unisys: visorinput: handle_locking_key() simplifications
      staging: unisys: visorhba: fail gracefully for thread creation failures
      staging: unisys: visornic: comment restructuring and removing bad diction
      staging: unisys: fix format string %Lx to %llx for u64
      staging: unisys: remove unused struct members
      staging: unisys: visorchannel: correct variable misspelling
      staging: unisys: visorhba: replace functionlike macro with function
      staging: dgnc: Need to check for NULL of ch
      staging: dgnc: remove redundant condition check
      staging: dgnc: fix 'line over 80 characters'
      staging: dgnc: clean up the dgnc_get_modem_info()
      staging: lustre: lnet: enable configuration per NI interface
      staging: lustre: o2iblnd: properly set ibr_why
      staging: lustre: o2iblnd: remove last of kiblnd_tunables_fini
      ...

commit 78975f23cba0cd195db01cdbd6eb48138a655890
Merge: feaa7cb5c594 73e8b0528346
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 19 17:48:12 2016 -0700

    Merge branch 'i2c/for-4.7' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux
    
    Pull i2c updates from Wolfram Sang:
    
     - Peter Rosin did some major rework on the locking of i2c muxes by
       seperating parent-locked muxes and mux-locked muxes.
    
       This avoids deadlocks/workarounds when the mux itself needs i2c
       commands for muxing.  And as a side-effect, other workarounds in the
       media layer could be eliminated.  Also, Peter stepped up as the i2c
       mux maintainer and will keep an eye on these changes.
    
     - major updates to the octeon driver
    
     - add a helper to the core to generate the address+rw_bit octal and
       make drivers use it
    
     - quite a bunch of driver updates
    
    * 'i2c/for-4.7' of git://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux: (84 commits)
      i2c: rcar: add DMA support
      i2c: st: Implement bus clear
      i2c: only check scl functions when using generic recovery
      i2c: algo-bit: declare i2c_bit_quirk_no_clk_stretch as static
      i2c: tegra: disable clock before returning error
      [media] rtl2832: regmap is aware of lockdep, drop local locking hack
      [media] rtl2832_sdr: get rid of empty regmap wrappers
      [media] rtl2832: change the i2c gate to be mux-locked
      [media] si2168: change the i2c gate to be mux-locked
      iio: imu: inv_mpu6050: change the i2c gate to be mux-locked
      i2c: mux: document i2c muxes and elaborate on parent-/mux-locked muxes
      i2c: mux: relax locking of the top i2c adapter during mux-locked muxing
      i2c: muxes always lock the parent adapter
      i2c: allow adapter drivers to override the adapter locking
      i2c: uniphier: add "\n" at the end of error log
      i2c: mv64xxx: remove CONFIG_HAVE_CLK conditionals
      i2c: mv64xxx: use clk_{prepare_enable,disable_unprepare}
      i2c: mv64xxx: handle probe deferral for the clock
      i2c: mv64xxx: enable the driver on ARCH_MVEBU
      i2c: octeon: Add workaround for broken irqs on CN3860
      ...

commit 1ffcfaf19597ad26797aac3ab42d8ba6e548ef0a
Author: Peter Rosin <peda@axentia.se>
Date:   Wed May 4 22:15:31 2016 +0200

    iio: imu: inv_mpu6050: change the i2c gate to be mux-locked
    
    The root i2c adapter lock is then no longer held by the i2c mux during
    accesses behind the i2c gate, and such accesses need to take that lock
    just like any other ordinary i2c accesses do.
    
    So, declare the i2c gate mux-locked, and zap the code that makes the
    unlocked i2c accesses and just use ordinary regmap_write accesses.
    
    This also happens to fix the deadlock described in
    http://patchwork.ozlabs.org/patch/584776/ authored by
    Adriana Reus <adriana.reus@intel.com> and submitted by
    Daniel Baluta <daniel.baluta@intel.com>
    
    ----------8<----------
    iio: imu: inv_mpu6050: Fix deadlock between i2c adapter lock and mpu lock
    
    This deadlock occurs if the accel/gyro and the sensor on the auxiliary
    I2C (in my setup it's an ak8975) are working at the same time.
    
    Scenario:
    
          T1                                        T2
         ====                                      ====
    inv_mpu6050_read_fifo                  aux sensor op (eg. ak8975_read_raw)
            |                                     |
    mutex_lock(&indio_dev->mlock)           i2c_transfer
            |                                     |
    i2c transaction                         i2c adapter lock
            |                                     |
    i2c adapter lock                        i2c_mux_master_xfer
                                                  |
                                            inv_mpu6050_select_bypass
                                                  |
                                            mutex_lock(&indio_dev->mlock)
    
    When we operate on an mpu sensor the order of locking is mpu lock
    followed by the i2c adapter lock. However, when we operate the auxiliary
    sensor the order of locking is the other way around.
    
    ...
    ----------8<----------
    
    The reason this patch fixes the deadlock is that T2 does not grab the
    i2c adapter lock until the very end (and grabs the newfangled i2c mux
    lock where it previously grabbed the i2c adapter lock).
    
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Acked-by: Daniel Baluta <daniel.baluta@intel.com>
    Tested-by: Crestez Dan Leonard <leonard.crestez@intel.com>
    Signed-off-by: Peter Rosin <peda@axentia.se>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index 3a078df84224..e25f7ef7f0ea 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -24,45 +24,16 @@ static const struct regmap_config inv_mpu_regmap_config = {
 	.val_bits = 8,
 };
 
-/*
- * The i2c read/write needs to happen in unlocked mode. As the parent
- * adapter is common. If we use locked versions, it will fail as
- * the mux adapter will lock the parent i2c adapter, while calling
- * select/deselect functions.
- */
-static int inv_mpu6050_write_reg_unlocked(struct i2c_client *client,
-					  u8 reg, u8 d)
-{
-	int ret;
-	u8 buf[2] = {reg, d};
-	struct i2c_msg msg[1] = {
-		{
-			.addr = client->addr,
-			.flags = 0,
-			.len = sizeof(buf),
-			.buf = buf,
-		}
-	};
-
-	ret = __i2c_transfer(client->adapter, msg, 1);
-	if (ret != 1)
-		return ret;
-
-	return 0;
-}
-
 static int inv_mpu6050_select_bypass(struct i2c_mux_core *muxc, u32 chan_id)
 {
-	struct i2c_client *client = i2c_mux_priv(muxc);
-	struct iio_dev *indio_dev = dev_get_drvdata(&client->dev);
+	struct iio_dev *indio_dev = i2c_mux_priv(muxc);
 	struct inv_mpu6050_state *st = iio_priv(indio_dev);
 	int ret = 0;
 
 	/* Use the same mutex which was used everywhere to protect power-op */
 	mutex_lock(&indio_dev->mlock);
 	if (!st->powerup_count) {
-		ret = inv_mpu6050_write_reg_unlocked(client,
-						     st->reg->pwr_mgmt_1, 0);
+		ret = regmap_write(st->map, st->reg->pwr_mgmt_1, 0);
 		if (ret)
 			goto write_error;
 
@@ -71,10 +42,9 @@ static int inv_mpu6050_select_bypass(struct i2c_mux_core *muxc, u32 chan_id)
 	}
 	if (!ret) {
 		st->powerup_count++;
-		ret = inv_mpu6050_write_reg_unlocked(client,
-						     st->reg->int_pin_cfg,
-						     INV_MPU6050_INT_PIN_CFG |
-						     INV_MPU6050_BIT_BYPASS_EN);
+		ret = regmap_write(st->map, st->reg->int_pin_cfg,
+				   INV_MPU6050_INT_PIN_CFG |
+				   INV_MPU6050_BIT_BYPASS_EN);
 	}
 write_error:
 	mutex_unlock(&indio_dev->mlock);
@@ -84,18 +54,16 @@ static int inv_mpu6050_select_bypass(struct i2c_mux_core *muxc, u32 chan_id)
 
 static int inv_mpu6050_deselect_bypass(struct i2c_mux_core *muxc, u32 chan_id)
 {
-	struct i2c_client *client = i2c_mux_priv(muxc);
-	struct iio_dev *indio_dev = dev_get_drvdata(&client->dev);
+	struct iio_dev *indio_dev = i2c_mux_priv(muxc);
 	struct inv_mpu6050_state *st = iio_priv(indio_dev);
 
 	mutex_lock(&indio_dev->mlock);
 	/* It doesn't really mattter, if any of the calls fails */
-	inv_mpu6050_write_reg_unlocked(client, st->reg->int_pin_cfg,
-				       INV_MPU6050_INT_PIN_CFG);
+	regmap_write(st->map, st->reg->int_pin_cfg, INV_MPU6050_INT_PIN_CFG);
 	st->powerup_count--;
 	if (!st->powerup_count)
-		inv_mpu6050_write_reg_unlocked(client, st->reg->pwr_mgmt_1,
-					       INV_MPU6050_BIT_SLEEP);
+		regmap_write(st->map, st->reg->pwr_mgmt_1,
+			     INV_MPU6050_BIT_SLEEP);
 	mutex_unlock(&indio_dev->mlock);
 
 	return 0;
@@ -134,7 +102,7 @@ static int inv_mpu_probe(struct i2c_client *client,
 
 	st = iio_priv(dev_get_drvdata(&client->dev));
 	st->muxc = i2c_mux_alloc(client->adapter, &client->dev,
-				 1, 0, 0,
+				 1, 0, I2C_MUX_LOCKED,
 				 inv_mpu6050_select_bypass,
 				 inv_mpu6050_deselect_bypass);
 	if (!st->muxc) {

commit 393dbe4e18dd5b17b3952c7d36ac88f61ec40924
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Thu Mar 17 18:32:44 2016 +0200

    iio: imu: mpu6050: Fix name/chip_id when using ACPI
    
    When using ACPI, id is NULL and the current code automatically
    defaults name to NULL and chip id to 0. We should instead use
    the data provided in the ACPI device table.
    
    Fixes: c816d9e7a57b ("iio: imu: mpu6050: fix possible NULL dereferences")
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Reviewed-By: Matt Ranostay <matt.ranostay@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index d0c0e20c7122..5ee4e0dc093e 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -104,6 +104,19 @@ static int inv_mpu6050_deselect_bypass(struct i2c_adapter *adap,
 	return 0;
 }
 
+static const char *inv_mpu_match_acpi_device(struct device *dev, int *chip_id)
+{
+	const struct acpi_device_id *id;
+
+	id = acpi_match_device(dev->driver->acpi_match_table, dev);
+	if (!id)
+		return NULL;
+
+	*chip_id = (int)id->driver_data;
+
+	return dev_name(dev);
+}
+
 /**
  *  inv_mpu_probe() - probe function.
  *  @client:          i2c client.
@@ -115,15 +128,25 @@ static int inv_mpu_probe(struct i2c_client *client,
 			 const struct i2c_device_id *id)
 {
 	struct inv_mpu6050_state *st;
-	int result;
-	const char *name = id ? id->name : NULL;
-	const int chip_type = id ? id->driver_data : 0;
+	int result, chip_type;
 	struct regmap *regmap;
+	const char *name;
 
 	if (!i2c_check_functionality(client->adapter,
 				     I2C_FUNC_SMBUS_I2C_BLOCK))
 		return -EOPNOTSUPP;
 
+	if (id) {
+		chip_type = (int)id->driver_data;
+		name = id->name;
+	} else if (ACPI_HANDLE(&client->dev)) {
+		name = inv_mpu_match_acpi_device(&client->dev, &chip_type);
+		if (!name)
+			return -ENODEV;
+	} else {
+		return -ENOSYS;
+	}
+
 	regmap = devm_regmap_init_i2c(client, &inv_mpu_regmap_config);
 	if (IS_ERR(regmap)) {
 		dev_err(&client->dev, "Failed to register i2c regmap %d\n",

commit 140afdd9626cdaaf54223e82931213de785c7c94
Author: Matt Ranostay <matt.ranostay@intel.com>
Date:   Wed Mar 2 19:18:12 2016 -0800

    iio: imu: mpu6050: fix possible NULL dereferences
    
    Fix possible null dereferencing of i2c and spi driver data.
    
    Signed-off-by: Matt Ranostay <matt.ranostay@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index f581256d9d4c..d0c0e20c7122 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -117,6 +117,7 @@ static int inv_mpu_probe(struct i2c_client *client,
 	struct inv_mpu6050_state *st;
 	int result;
 	const char *name = id ? id->name : NULL;
+	const int chip_type = id ? id->driver_data : 0;
 	struct regmap *regmap;
 
 	if (!i2c_check_functionality(client->adapter,
@@ -131,7 +132,7 @@ static int inv_mpu_probe(struct i2c_client *client,
 	}
 
 	result = inv_mpu_core_probe(regmap, client->irq, name,
-				    NULL, id->driver_data);
+				    NULL, chip_type);
 	if (result < 0)
 		return result;
 

commit fbced0e9465152d628ece5fd0d11de4e7a1f5ce5
Author: Crestez Dan Leonard <leonard.crestez@intel.com>
Date:   Wed Apr 20 16:15:13 2016 +0300

    iio: inv_mpu6050: Add explicit support for MPU9150
    
    This device is a package containing a MPU6050-like sensor and an AK8975
    magnetometer. The magnetometer component is supported by the existing
    ak8975 driver.
    
    This patch also rephrases the Kconfig descriptions.
    
    Signed-off-by: Crestez Dan Leonard <leonard.crestez@intel.com>
    Acked-by: Ge Gao <ggao@invensense.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index bb1a7b1462f5..1a424a6561de 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -202,6 +202,7 @@ static int inv_mpu_remove(struct i2c_client *client)
 static const struct i2c_device_id inv_mpu_id[] = {
 	{"mpu6050", INV_MPU6050},
 	{"mpu6500", INV_MPU6500},
+	{"mpu9150", INV_MPU9150},
 	{}
 };
 

commit aadd3076db9d37a593dca1f16b35a87e0bd59005
Author: Crestez Dan Leonard <leonard.crestez@intel.com>
Date:   Wed Apr 20 16:15:09 2016 +0300

    iio: inv_mpu6050: Cleanup hw_info mapping
    
    The hw_info array was indexed by enum inv_devices chip_type despite the
    fact that the enumeration had more members than the array and was
    ordered differently.
    
    The patch cleans this up and adds explicit chip_types to i2c/spi/acpi
    IDs. It also adds some stricter checks inside the driver core.
    
    This happened to work so far because the differences between the
    supported models are very minor.
    
    Signed-off-by: Crestez Dan Leonard <leonard.crestez@intel.com>
    Acked-by: Ge Gao <ggao@invensense.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index 5ee4e0dc093e..bb1a7b1462f5 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -208,7 +208,7 @@ static const struct i2c_device_id inv_mpu_id[] = {
 MODULE_DEVICE_TABLE(i2c, inv_mpu_id);
 
 static const struct acpi_device_id inv_acpi_match[] = {
-	{"INVN6500", 0},
+	{"INVN6500", INV_MPU6500},
 	{ },
 };
 

commit 51f97f6dd73d9349f8e6a1d36ac5f7371d275fb3
Author: Peter Rosin <peda@axentia.se>
Date:   Wed Apr 20 08:40:49 2016 +0200

    iio: imu: inv_mpu6050: convert to use an explicit i2c mux core
    
    Allocate an explicit i2c mux core to handle parent and child adapters
    etc. Update the select/deselect ops to be in terms of the i2c mux core
    instead of the child adapter.
    
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Tested-by: Crestez Dan Leonard <leonard.crestez@intel.com>
    Signed-off-by: Peter Rosin <peda@axentia.se>
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index f581256d9d4c..3a078df84224 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -15,7 +15,6 @@
 #include <linux/delay.h>
 #include <linux/err.h>
 #include <linux/i2c.h>
-#include <linux/i2c-mux.h>
 #include <linux/iio/iio.h>
 #include <linux/module.h>
 #include "inv_mpu_iio.h"
@@ -52,10 +51,9 @@ static int inv_mpu6050_write_reg_unlocked(struct i2c_client *client,
 	return 0;
 }
 
-static int inv_mpu6050_select_bypass(struct i2c_adapter *adap, void *mux_priv,
-				     u32 chan_id)
+static int inv_mpu6050_select_bypass(struct i2c_mux_core *muxc, u32 chan_id)
 {
-	struct i2c_client *client = mux_priv;
+	struct i2c_client *client = i2c_mux_priv(muxc);
 	struct iio_dev *indio_dev = dev_get_drvdata(&client->dev);
 	struct inv_mpu6050_state *st = iio_priv(indio_dev);
 	int ret = 0;
@@ -84,10 +82,9 @@ static int inv_mpu6050_select_bypass(struct i2c_adapter *adap, void *mux_priv,
 	return ret;
 }
 
-static int inv_mpu6050_deselect_bypass(struct i2c_adapter *adap,
-				       void *mux_priv, u32 chan_id)
+static int inv_mpu6050_deselect_bypass(struct i2c_mux_core *muxc, u32 chan_id)
 {
-	struct i2c_client *client = mux_priv;
+	struct i2c_client *client = i2c_mux_priv(muxc);
 	struct iio_dev *indio_dev = dev_get_drvdata(&client->dev);
 	struct inv_mpu6050_state *st = iio_priv(indio_dev);
 
@@ -136,16 +133,18 @@ static int inv_mpu_probe(struct i2c_client *client,
 		return result;
 
 	st = iio_priv(dev_get_drvdata(&client->dev));
-	st->mux_adapter = i2c_add_mux_adapter(client->adapter,
-					      &client->dev,
-					      client,
-					      0, 0, 0,
-					      inv_mpu6050_select_bypass,
-					      inv_mpu6050_deselect_bypass);
-	if (!st->mux_adapter) {
-		result = -ENODEV;
+	st->muxc = i2c_mux_alloc(client->adapter, &client->dev,
+				 1, 0, 0,
+				 inv_mpu6050_select_bypass,
+				 inv_mpu6050_deselect_bypass);
+	if (!st->muxc) {
+		result = -ENOMEM;
 		goto out_unreg_device;
 	}
+	st->muxc->priv = dev_get_drvdata(&client->dev);
+	result = i2c_mux_add_adapter(st->muxc, 0, 0, 0);
+	if (result)
+		goto out_unreg_device;
 
 	result = inv_mpu_acpi_create_mux_client(client);
 	if (result)
@@ -154,7 +153,7 @@ static int inv_mpu_probe(struct i2c_client *client,
 	return 0;
 
 out_del_mux:
-	i2c_del_mux_adapter(st->mux_adapter);
+	i2c_mux_del_adapters(st->muxc);
 out_unreg_device:
 	inv_mpu_core_remove(&client->dev);
 	return result;
@@ -166,7 +165,7 @@ static int inv_mpu_remove(struct i2c_client *client)
 	struct inv_mpu6050_state *st = iio_priv(indio_dev);
 
 	inv_mpu_acpi_delete_mux_client(client);
-	i2c_del_mux_adapter(st->mux_adapter);
+	i2c_mux_del_adapters(st->muxc);
 
 	return inv_mpu_core_remove(&client->dev);
 }

commit 718ba46e5f4e21e45141bf55fd4cccd4b3ba9939
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Thu Mar 17 18:32:44 2016 +0200

    iio: imu: mpu6050: Fix name/chip_id when using ACPI
    
    When using ACPI, id is NULL and the current code automatically
    defaults name to NULL and chip id to 0. We should instead use
    the data provided in the ACPI device table.
    
    Fixes: c816d9e7a57b ("iio: imu: mpu6050: fix possible NULL dereferences")
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Reviewed-By: Matt Ranostay <matt.ranostay@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index d0c0e20c7122..5ee4e0dc093e 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -104,6 +104,19 @@ static int inv_mpu6050_deselect_bypass(struct i2c_adapter *adap,
 	return 0;
 }
 
+static const char *inv_mpu_match_acpi_device(struct device *dev, int *chip_id)
+{
+	const struct acpi_device_id *id;
+
+	id = acpi_match_device(dev->driver->acpi_match_table, dev);
+	if (!id)
+		return NULL;
+
+	*chip_id = (int)id->driver_data;
+
+	return dev_name(dev);
+}
+
 /**
  *  inv_mpu_probe() - probe function.
  *  @client:          i2c client.
@@ -115,15 +128,25 @@ static int inv_mpu_probe(struct i2c_client *client,
 			 const struct i2c_device_id *id)
 {
 	struct inv_mpu6050_state *st;
-	int result;
-	const char *name = id ? id->name : NULL;
-	const int chip_type = id ? id->driver_data : 0;
+	int result, chip_type;
 	struct regmap *regmap;
+	const char *name;
 
 	if (!i2c_check_functionality(client->adapter,
 				     I2C_FUNC_SMBUS_I2C_BLOCK))
 		return -EOPNOTSUPP;
 
+	if (id) {
+		chip_type = (int)id->driver_data;
+		name = id->name;
+	} else if (ACPI_HANDLE(&client->dev)) {
+		name = inv_mpu_match_acpi_device(&client->dev, &chip_type);
+		if (!name)
+			return -ENODEV;
+	} else {
+		return -ENOSYS;
+	}
+
 	regmap = devm_regmap_init_i2c(client, &inv_mpu_regmap_config);
 	if (IS_ERR(regmap)) {
 		dev_err(&client->dev, "Failed to register i2c regmap %d\n",

commit c816d9e7a57bd436b2cff8f48b0e8cff128f05db
Author: Matt Ranostay <matt.ranostay@intel.com>
Date:   Wed Mar 2 19:18:12 2016 -0800

    iio: imu: mpu6050: fix possible NULL dereferences
    
    Fix possible null dereferencing of i2c and spi driver data.
    
    Signed-off-by: Matt Ranostay <matt.ranostay@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index f581256d9d4c..d0c0e20c7122 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -117,6 +117,7 @@ static int inv_mpu_probe(struct i2c_client *client,
 	struct inv_mpu6050_state *st;
 	int result;
 	const char *name = id ? id->name : NULL;
+	const int chip_type = id ? id->driver_data : 0;
 	struct regmap *regmap;
 
 	if (!i2c_check_functionality(client->adapter,
@@ -131,7 +132,7 @@ static int inv_mpu_probe(struct i2c_client *client,
 	}
 
 	result = inv_mpu_core_probe(regmap, client->irq, name,
-				    NULL, id->driver_data);
+				    NULL, chip_type);
 	if (result < 0)
 		return result;
 

commit f8d9d3b434cd50f7a0a3f0c383736af5e724c34c
Author: Matt Ranostay <mranostay@gmail.com>
Date:   Fri Feb 26 22:13:49 2016 -0800

    iio: convert to common i2c_check_functionality() return value
    
    Previously most drivers that used a i2c_check_functionality() check
    condition required various error codes on failure. This patchset
    converts to a standard of -EOPNOTSUPP
    
    Signed-off-by: Matt Ranostay <mranostay@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index e6247c3508af..f581256d9d4c 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -121,7 +121,7 @@ static int inv_mpu_probe(struct i2c_client *client,
 
 	if (!i2c_check_functionality(client->adapter,
 				     I2C_FUNC_SMBUS_I2C_BLOCK))
-		return -ENOSYS;
+		return -EOPNOTSUPP;
 
 	regmap = devm_regmap_init_i2c(client, &inv_mpu_regmap_config);
 	if (IS_ERR(regmap)) {

commit 33da559f861b9942404c1ad93691d5fe473e0348
Author: Matt Ranostay <matt.ranostay@intel.com>
Date:   Mon Feb 22 13:39:11 2016 -0800

    iio: imu: mpu6050: add mpu6500 register settings
    
    Signed-off-by: Matt Ranostay <matt.ranostay@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index 8d2b74eaa8b6..e6247c3508af 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -130,7 +130,8 @@ static int inv_mpu_probe(struct i2c_client *client,
 		return PTR_ERR(regmap);
 	}
 
-	result = inv_mpu_core_probe(regmap, client->irq, name, NULL);
+	result = inv_mpu_core_probe(regmap, client->irq, name,
+				    NULL, id->driver_data);
 	if (result < 0)
 		return result;
 

commit 8f356be3fe098385e7a79ce893114ddcf8ad7d78
Author: Matt Ranostay <matt.ranostay@intel.com>
Date:   Mon Feb 22 13:39:08 2016 -0800

    iio: imu: mpu6050: fix INV_MPU6050_REG_UP_TIME delay
    
    replace msleep(INV_MPU6050_REG_UP_TIME) with usleep_range calls
    due to fact the wait time is under 20 milliseconds.
    
    Signed-off-by: Matt Ranostay <matt.ranostay@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index 71bdaa33cd05..8d2b74eaa8b6 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -68,7 +68,8 @@ static int inv_mpu6050_select_bypass(struct i2c_adapter *adap, void *mux_priv,
 		if (ret)
 			goto write_error;
 
-		msleep(INV_MPU6050_REG_UP_TIME);
+		usleep_range(INV_MPU6050_REG_UP_TIME_MIN,
+			     INV_MPU6050_REG_UP_TIME_MAX);
 	}
 	if (!ret) {
 		st->powerup_count++;

commit fc0dccdda105be0026aa99271a42d06d20427641
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Thu Feb 18 17:53:12 2016 +0200

    iio: imu: inv_mpu6050: Fix alignment with open parenthesis
    
    This makes code consistent around inv_mpu6050 driver and
    fixes the following checkpatch.pl warning:
    CHECK: Alignment should match open parenthesis
    
    Note that there were few cases were it was not possible to
    fix this due to making the line too long, but we can live with that.
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index af400dd892a9..71bdaa33cd05 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -111,7 +111,7 @@ static int inv_mpu6050_deselect_bypass(struct i2c_adapter *adap,
  *  Returns 0 on success, a negative error code otherwise.
  */
 static int inv_mpu_probe(struct i2c_client *client,
-	const struct i2c_device_id *id)
+			 const struct i2c_device_id *id)
 {
 	struct inv_mpu6050_state *st;
 	int result;

commit fd64df16f40e367c393bf372fb67017301d701c2
Author: Adriana Reus <adriana.reus@intel.com>
Date:   Fri Feb 12 13:44:45 2016 +0200

    iio: imu: inv_mpu6050: Add SPI support for MPU6000
    
    The only difference between the MPU6000 and the
    MPU6050 is that the first also supports SPI.
    Add SPI driver for this chip.
    
    Signed-off-by: Adriana Reus <adriana.reus@intel.com>
    Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
index eeaf969fbaef..af400dd892a9 100644
--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -129,7 +129,7 @@ static int inv_mpu_probe(struct i2c_client *client,
 		return PTR_ERR(regmap);
 	}
 
-	result = inv_mpu_core_probe(regmap, client->irq, name);
+	result = inv_mpu_core_probe(regmap, client->irq, name, NULL);
 	if (result < 0)
 		return result;
 

commit b3eea8dacfb758baa0fe78e0cf24d5e5d288c5fe
Author: Adriana Reus <adriana.reus@intel.com>
Date:   Fri Feb 12 13:44:44 2016 +0200

    iio: imu: inv_mpu6050: Separate driver into core and i2c functionality.
    
    Separate this driver into core and i2c functionality.
    This is in preparation for adding spi support.
    
    Signed-off-by: Adriana Reus <adriana.reus@intel.com>
    Reviewed-by: Lucas De Marchi <lucas.demarchi@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
new file mode 100644
index 000000000000..eeaf969fbaef
--- /dev/null
+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_i2c.c
@@ -0,0 +1,206 @@
+/*
+* Copyright (C) 2012 Invensense, Inc.
+*
+* This software is licensed under the terms of the GNU General Public
+* License version 2, as published by the Free Software Foundation, and
+* may be copied, distributed, and modified under those terms.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*/
+
+#include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/i2c-mux.h>
+#include <linux/iio/iio.h>
+#include <linux/module.h>
+#include "inv_mpu_iio.h"
+
+static const struct regmap_config inv_mpu_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+};
+
+/*
+ * The i2c read/write needs to happen in unlocked mode. As the parent
+ * adapter is common. If we use locked versions, it will fail as
+ * the mux adapter will lock the parent i2c adapter, while calling
+ * select/deselect functions.
+ */
+static int inv_mpu6050_write_reg_unlocked(struct i2c_client *client,
+					  u8 reg, u8 d)
+{
+	int ret;
+	u8 buf[2] = {reg, d};
+	struct i2c_msg msg[1] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = sizeof(buf),
+			.buf = buf,
+		}
+	};
+
+	ret = __i2c_transfer(client->adapter, msg, 1);
+	if (ret != 1)
+		return ret;
+
+	return 0;
+}
+
+static int inv_mpu6050_select_bypass(struct i2c_adapter *adap, void *mux_priv,
+				     u32 chan_id)
+{
+	struct i2c_client *client = mux_priv;
+	struct iio_dev *indio_dev = dev_get_drvdata(&client->dev);
+	struct inv_mpu6050_state *st = iio_priv(indio_dev);
+	int ret = 0;
+
+	/* Use the same mutex which was used everywhere to protect power-op */
+	mutex_lock(&indio_dev->mlock);
+	if (!st->powerup_count) {
+		ret = inv_mpu6050_write_reg_unlocked(client,
+						     st->reg->pwr_mgmt_1, 0);
+		if (ret)
+			goto write_error;
+
+		msleep(INV_MPU6050_REG_UP_TIME);
+	}
+	if (!ret) {
+		st->powerup_count++;
+		ret = inv_mpu6050_write_reg_unlocked(client,
+						     st->reg->int_pin_cfg,
+						     INV_MPU6050_INT_PIN_CFG |
+						     INV_MPU6050_BIT_BYPASS_EN);
+	}
+write_error:
+	mutex_unlock(&indio_dev->mlock);
+
+	return ret;
+}
+
+static int inv_mpu6050_deselect_bypass(struct i2c_adapter *adap,
+				       void *mux_priv, u32 chan_id)
+{
+	struct i2c_client *client = mux_priv;
+	struct iio_dev *indio_dev = dev_get_drvdata(&client->dev);
+	struct inv_mpu6050_state *st = iio_priv(indio_dev);
+
+	mutex_lock(&indio_dev->mlock);
+	/* It doesn't really mattter, if any of the calls fails */
+	inv_mpu6050_write_reg_unlocked(client, st->reg->int_pin_cfg,
+				       INV_MPU6050_INT_PIN_CFG);
+	st->powerup_count--;
+	if (!st->powerup_count)
+		inv_mpu6050_write_reg_unlocked(client, st->reg->pwr_mgmt_1,
+					       INV_MPU6050_BIT_SLEEP);
+	mutex_unlock(&indio_dev->mlock);
+
+	return 0;
+}
+
+/**
+ *  inv_mpu_probe() - probe function.
+ *  @client:          i2c client.
+ *  @id:              i2c device id.
+ *
+ *  Returns 0 on success, a negative error code otherwise.
+ */
+static int inv_mpu_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct inv_mpu6050_state *st;
+	int result;
+	const char *name = id ? id->name : NULL;
+	struct regmap *regmap;
+
+	if (!i2c_check_functionality(client->adapter,
+				     I2C_FUNC_SMBUS_I2C_BLOCK))
+		return -ENOSYS;
+
+	regmap = devm_regmap_init_i2c(client, &inv_mpu_regmap_config);
+	if (IS_ERR(regmap)) {
+		dev_err(&client->dev, "Failed to register i2c regmap %d\n",
+			(int)PTR_ERR(regmap));
+		return PTR_ERR(regmap);
+	}
+
+	result = inv_mpu_core_probe(regmap, client->irq, name);
+	if (result < 0)
+		return result;
+
+	st = iio_priv(dev_get_drvdata(&client->dev));
+	st->mux_adapter = i2c_add_mux_adapter(client->adapter,
+					      &client->dev,
+					      client,
+					      0, 0, 0,
+					      inv_mpu6050_select_bypass,
+					      inv_mpu6050_deselect_bypass);
+	if (!st->mux_adapter) {
+		result = -ENODEV;
+		goto out_unreg_device;
+	}
+
+	result = inv_mpu_acpi_create_mux_client(client);
+	if (result)
+		goto out_del_mux;
+
+	return 0;
+
+out_del_mux:
+	i2c_del_mux_adapter(st->mux_adapter);
+out_unreg_device:
+	inv_mpu_core_remove(&client->dev);
+	return result;
+}
+
+static int inv_mpu_remove(struct i2c_client *client)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(client);
+	struct inv_mpu6050_state *st = iio_priv(indio_dev);
+
+	inv_mpu_acpi_delete_mux_client(client);
+	i2c_del_mux_adapter(st->mux_adapter);
+
+	return inv_mpu_core_remove(&client->dev);
+}
+
+/*
+ * device id table is used to identify what device can be
+ * supported by this driver
+ */
+static const struct i2c_device_id inv_mpu_id[] = {
+	{"mpu6050", INV_MPU6050},
+	{"mpu6500", INV_MPU6500},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, inv_mpu_id);
+
+static const struct acpi_device_id inv_acpi_match[] = {
+	{"INVN6500", 0},
+	{ },
+};
+
+MODULE_DEVICE_TABLE(acpi, inv_acpi_match);
+
+static struct i2c_driver inv_mpu_driver = {
+	.probe		=	inv_mpu_probe,
+	.remove		=	inv_mpu_remove,
+	.id_table	=	inv_mpu_id,
+	.driver = {
+		.acpi_match_table = ACPI_PTR(inv_acpi_match),
+		.name	=	"inv-mpu6050-i2c",
+		.pm     =       &inv_mpu_pmops,
+	},
+};
+
+module_i2c_driver(inv_mpu_driver);
+
+MODULE_AUTHOR("Invensense Corporation");
+MODULE_DESCRIPTION("Invensense device MPU6050 driver");
+MODULE_LICENSE("GPL");
