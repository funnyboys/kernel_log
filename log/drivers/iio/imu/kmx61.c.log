commit 36edc93958e06dfc15b61d1cfa7f33929bc26fe4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:44 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 330
    
    Based on 1 normalized pattern(s):
    
      this file is subject to the terms and conditions of version 2 of the
      gnu general public license see the file copying in the main
      directory of this archive for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 55 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.108941081@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index 44b3f5397343..e67466100aff 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -1,14 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * KMX61 - Kionix 6-axis Accelerometer/Magnetometer
  *
  * Copyright (c) 2014, Intel Corporation.
  *
- * This file is subject to the terms and conditions of version 2 of
- * the GNU General Public License.  See the file COPYING in the main
- * directory of this archive for more details.
- *
  * IIO driver for KMX61 (7-bit I2C slave address 0x0E or 0x0F).
- *
  */
 
 #include <linux/module.h>

commit 79978a9bd02b0c2fcf6e8485dcb5ef7ee34f1adb
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sun Jul 23 17:25:59 2017 +0100

    iio:imu: drop assign iio_info.driver_module and iio_trigger_ops.owner
    
    The equivalent of both of these are now done via macro magic when
    the relevant register calls are made.  The actual structure
    elements will shortly go away.
    
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index 2e7dd5754a56..44b3f5397343 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -1003,7 +1003,6 @@ static int kmx61_mag_validate_trigger(struct iio_dev *indio_dev,
 }
 
 static const struct iio_info kmx61_acc_info = {
-	.driver_module		= THIS_MODULE,
 	.read_raw		= kmx61_read_raw,
 	.write_raw		= kmx61_write_raw,
 	.attrs			= &kmx61_acc_attribute_group,
@@ -1015,7 +1014,6 @@ static const struct iio_info kmx61_acc_info = {
 };
 
 static const struct iio_info kmx61_mag_info = {
-	.driver_module		= THIS_MODULE,
 	.read_raw		= kmx61_read_raw,
 	.write_raw		= kmx61_write_raw,
 	.attrs			= &kmx61_mag_attribute_group,
@@ -1087,7 +1085,6 @@ static int kmx61_trig_try_reenable(struct iio_trigger *trig)
 static const struct iio_trigger_ops kmx61_trigger_ops = {
 	.set_trigger_state = kmx61_data_rdy_trigger_set_state,
 	.try_reenable = kmx61_trig_try_reenable,
-	.owner = THIS_MODULE,
 };
 
 static irqreturn_t kmx61_event_handler(int irq, void *private)

commit b1532909decca12e0527473870cec1d57677f916
Author: Irina Tirdea <irina.tirdea@intel.com>
Date:   Thu Mar 24 11:08:38 2016 +0200

    iio: remove unused gpio consumer.h include
    
    GPIO handling code has been removed from the drivers (since
    this is now handled by the ACPI core) in commit 0f0796509c07 ("iio:
    remove gpio interrupt probing from drivers that use a single interrupt").
    
    Remove the include for linux/gpio/consumer.h since it is no longer
    used.
    
    Signed-off-by: Irina Tirdea <irina.tirdea@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index e5306b4e020e..2e7dd5754a56 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -14,7 +14,6 @@
 #include <linux/module.h>
 #include <linux/i2c.h>
 #include <linux/acpi.h>
-#include <linux/gpio/consumer.h>
 #include <linux/interrupt.h>
 #include <linux/pm.h>
 #include <linux/pm_runtime.h>

commit 7d0ead5c3f00a0652fa4436f0d2dd05e9f2de140
Author: Adriana Reus <adriana.reus@intel.com>
Date:   Thu Nov 5 16:25:29 2015 +0200

    iio: Reconcile operation order between iio_register/unregister and pm functions
    
    At probe, runtime pm should be setup before registering the sysfs interface so
    that all the power attributes are accurate and functional when registering.
    Also, when removing the device we should unregister first to make sure
    that the interfaces that may result in wakeups are no longer available.
    
    Fix this behaviour for the following drivers: bmc150, bmg160, kmx61,
    kxcj-1013, mma9551, mma9553, rpr0521.
    
    Signed-off-by: Adriana Reus <adriana.reus@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index dbf5e9936635..e5306b4e020e 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -1390,6 +1390,14 @@ static int kmx61_probe(struct i2c_client *client,
 		}
 	}
 
+	ret = pm_runtime_set_active(&client->dev);
+	if (ret < 0)
+		goto err_buffer_cleanup_mag;
+
+	pm_runtime_enable(&client->dev);
+	pm_runtime_set_autosuspend_delay(&client->dev, KMX61_SLEEP_DELAY_MS);
+	pm_runtime_use_autosuspend(&client->dev);
+
 	ret = iio_device_register(data->acc_indio_dev);
 	if (ret < 0) {
 		dev_err(&client->dev, "Failed to register acc iio device\n");
@@ -1402,18 +1410,8 @@ static int kmx61_probe(struct i2c_client *client,
 		goto err_iio_unregister_acc;
 	}
 
-	ret = pm_runtime_set_active(&client->dev);
-	if (ret < 0)
-		goto err_iio_unregister_mag;
-
-	pm_runtime_enable(&client->dev);
-	pm_runtime_set_autosuspend_delay(&client->dev, KMX61_SLEEP_DELAY_MS);
-	pm_runtime_use_autosuspend(&client->dev);
-
 	return 0;
 
-err_iio_unregister_mag:
-	iio_device_unregister(data->mag_indio_dev);
 err_iio_unregister_acc:
 	iio_device_unregister(data->acc_indio_dev);
 err_buffer_cleanup_mag:
@@ -1437,13 +1435,13 @@ static int kmx61_remove(struct i2c_client *client)
 {
 	struct kmx61_data *data = i2c_get_clientdata(client);
 
+	iio_device_unregister(data->acc_indio_dev);
+	iio_device_unregister(data->mag_indio_dev);
+
 	pm_runtime_disable(&client->dev);
 	pm_runtime_set_suspended(&client->dev);
 	pm_runtime_put_noidle(&client->dev);
 
-	iio_device_unregister(data->acc_indio_dev);
-	iio_device_unregister(data->mag_indio_dev);
-
 	if (client->irq > 0) {
 		iio_triggered_buffer_cleanup(data->acc_indio_dev);
 		iio_triggered_buffer_cleanup(data->mag_indio_dev);

commit 0f0796509c07c1c7b77671c05b2955beb245e367
Author: Octavian Purdila <octavian.purdila@intel.com>
Date:   Wed Sep 23 12:02:01 2015 +0300

    iio: remove gpio interrupt probing from drivers that use a single interrupt
    
    Commit 845c877009cf014b ("i2c / ACPI: Assign IRQ for devices that have
    GpioInt automatically") automatically assigns the first ACPI GPIO
    interrupt in client->irq, so we can remove the probing code from
    drivers that use only one interrupt.
    
    Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index 82cdf5090fa7..dbf5e9936635 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -27,7 +27,6 @@
 #include <linux/iio/trigger_consumer.h>
 
 #define KMX61_DRV_NAME "kmx61"
-#define KMX61_GPIO_NAME "kmx61_int"
 #define KMX61_IRQ_NAME "kmx61_event"
 
 #define KMX61_REG_WHO_AM_I	0x00
@@ -1243,30 +1242,6 @@ static const char *kmx61_match_acpi_device(struct device *dev)
 	return dev_name(dev);
 }
 
-static int kmx61_gpio_probe(struct i2c_client *client, struct kmx61_data *data)
-{
-	struct device *dev;
-	struct gpio_desc *gpio;
-	int ret;
-
-	if (!client)
-		return -EINVAL;
-
-	dev = &client->dev;
-
-	/* data ready gpio interrupt pin */
-	gpio = devm_gpiod_get_index(dev, KMX61_GPIO_NAME, 0, GPIOD_IN);
-	if (IS_ERR(gpio)) {
-		dev_err(dev, "acpi gpio get index failed\n");
-		return PTR_ERR(gpio);
-	}
-
-	ret = gpiod_to_irq(gpio);
-
-	dev_dbg(dev, "GPIO resource, no:%d irq:%d\n", desc_to_gpio(gpio), ret);
-	return ret;
-}
-
 static struct iio_dev *kmx61_indiodev_setup(struct kmx61_data *data,
 					    const struct iio_info *info,
 					    const struct iio_chan_spec *chan,
@@ -1360,9 +1335,6 @@ static int kmx61_probe(struct i2c_client *client,
 	if (ret < 0)
 		return ret;
 
-	if (client->irq < 0)
-		client->irq = kmx61_gpio_probe(client, data);
-
 	if (client->irq > 0) {
 		ret = devm_request_threaded_irq(&client->dev, client->irq,
 						kmx61_data_rdy_trig_poll,

commit c176becd81843426eb8ab3b03aeeb19e387345fe
Author: Octavian Purdila <octavian.purdila@intel.com>
Date:   Fri Jun 5 16:59:42 2015 +0300

    iio: fix drivers that consider 0 as a valid IRQ in client->irq
    
    Since patch "i2c / ACPI: Use 0 to indicate that device does not have
    interrupt assigned" [1], 0 is not a valid i2c client irq anymore, so
    change all driver's checks accordingly.
    
    The same issue occurs when the device is instantiated via device tree
    with no IRQ, or from the i2c sysfs interface, even before the patch
    above.
    
    [1] http://lkml.kernel.org/g/<1430908148-201129-3-git-send-email-mika.westerberg@linux.intel.com>
    
    Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
    Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index 462a010628cd..82cdf5090fa7 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -1363,7 +1363,7 @@ static int kmx61_probe(struct i2c_client *client,
 	if (client->irq < 0)
 		client->irq = kmx61_gpio_probe(client, data);
 
-	if (client->irq >= 0) {
+	if (client->irq > 0) {
 		ret = devm_request_threaded_irq(&client->dev, client->irq,
 						kmx61_data_rdy_trig_poll,
 						kmx61_event_handler,
@@ -1445,10 +1445,10 @@ static int kmx61_probe(struct i2c_client *client,
 err_iio_unregister_acc:
 	iio_device_unregister(data->acc_indio_dev);
 err_buffer_cleanup_mag:
-	if (client->irq >= 0)
+	if (client->irq > 0)
 		iio_triggered_buffer_cleanup(data->mag_indio_dev);
 err_buffer_cleanup_acc:
-	if (client->irq >= 0)
+	if (client->irq > 0)
 		iio_triggered_buffer_cleanup(data->acc_indio_dev);
 err_trigger_unregister_motion:
 	iio_trigger_unregister(data->motion_trig);
@@ -1472,7 +1472,7 @@ static int kmx61_remove(struct i2c_client *client)
 	iio_device_unregister(data->acc_indio_dev);
 	iio_device_unregister(data->mag_indio_dev);
 
-	if (client->irq >= 0) {
+	if (client->irq > 0) {
 		iio_triggered_buffer_cleanup(data->acc_indio_dev);
 		iio_triggered_buffer_cleanup(data->mag_indio_dev);
 		iio_trigger_unregister(data->acc_dready_trig);

commit c610f7f772aa06ae2bd8e5ace87cde4d90f70198
Merge: f9541f8239a5 f22e6e847115
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Apr 7 11:03:02 2015 +0200

    Merge 4.0-rc7 into staging-next
    
    We want those fixes (iio primarily) into the -next branch to help with
    merge and testing issues.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 70dddeee8945a0e62525a278ae7b91778f82f765
Author: Octavian Purdila <octavian.purdila@intel.com>
Date:   Mon Mar 2 21:03:05 2015 +0200

    iio: fix drivers that check buffer->scan_mask
    
    If the in-kernel push interface is used we may have a different masks
    on the device buffer and the kernel buffer and in this case the device
    should generate data for the reunion of the buffers, which is
    available at indio_dev->active_scan_mask.
    
    Compiled tested only except for bmc150-accel which was tested at
    runtime with the hardware.
    
    Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index 5cc3692acf37..b3a36376c719 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -1227,7 +1227,7 @@ static irqreturn_t kmx61_trigger_handler(int irq, void *p)
 		base = KMX61_MAG_XOUT_L;
 
 	mutex_lock(&data->lock);
-	for_each_set_bit(bit, indio_dev->buffer->scan_mask,
+	for_each_set_bit(bit, indio_dev->active_scan_mask,
 			 indio_dev->masklength) {
 		ret = kmx61_read_measurement(data, base, bit);
 		if (ret < 0) {

commit b457f53a2afa7de3cecdec1772fbd522b98afc49
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Feb 18 13:47:11 2015 +0100

    iio: improve usage of gpiod API
    
    Since 39b2bbe3d715 (gpio: add flags argument to gpiod_get*() functions)
    which appeared in v3.17-rc1, the gpiod_get* functions take an additional
    parameter that allows to specify direction and initial value for
    outputs.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Alexandre Courbot <acourbot@nvidia.com>
    Reviewed-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index 32e5f96a6477..75ab70100015 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -1255,16 +1255,12 @@ static int kmx61_gpio_probe(struct i2c_client *client, struct kmx61_data *data)
 	dev = &client->dev;
 
 	/* data ready gpio interrupt pin */
-	gpio = devm_gpiod_get_index(dev, KMX61_GPIO_NAME, 0);
+	gpio = devm_gpiod_get_index(dev, KMX61_GPIO_NAME, 0, GPIOD_IN);
 	if (IS_ERR(gpio)) {
 		dev_err(dev, "acpi gpio get index failed\n");
 		return PTR_ERR(gpio);
 	}
 
-	ret = gpiod_direction_input(gpio);
-	if (ret)
-		return ret;
-
 	ret = gpiod_to_irq(gpio);
 
 	dev_dbg(dev, "GPIO resource, no:%d irq:%d\n", desc_to_gpio(gpio), ret);

commit a36385a2613c0755164ec53e8b7a42d4d11f65b9
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Mon Jan 5 11:21:42 2015 +0200

    iio: imu: kmx61: Drop odr_bits from kmx61_samp_freq_table
    
    odr_bits values are between 0 and 11, so we can use the index
    in kmx61_samp_freq_table instead of odr_bits structure member.
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Reviewed-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index 5cc3692acf37..32e5f96a6477 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -169,19 +169,18 @@ static const u16 kmx61_uscale_table[] = {9582, 19163, 38326};
 static const struct {
 	int val;
 	int val2;
-	u8 odr_bits;
-} kmx61_samp_freq_table[] = { {12, 500000, 0x00},
-			{25, 0, 0x01},
-			{50, 0, 0x02},
-			{100, 0, 0x03},
-			{200, 0, 0x04},
-			{400, 0, 0x05},
-			{800, 0, 0x06},
-			{1600, 0, 0x07},
-			{0, 781000, 0x08},
-			{1, 563000, 0x09},
-			{3, 125000, 0x0A},
-			{6, 250000, 0x0B} };
+} kmx61_samp_freq_table[] = { {12, 500000},
+			{25, 0},
+			{50, 0},
+			{100, 0},
+			{200, 0},
+			{400, 0},
+			{800, 0},
+			{1600, 0},
+			{0, 781000},
+			{1, 563000},
+			{3, 125000},
+			{6, 250000} };
 
 static const struct {
 	int val;
@@ -302,24 +301,10 @@ static int kmx61_convert_freq_to_bit(int val, int val2)
 	for (i = 0; i < ARRAY_SIZE(kmx61_samp_freq_table); i++)
 		if (val == kmx61_samp_freq_table[i].val &&
 		    val2 == kmx61_samp_freq_table[i].val2)
-			return kmx61_samp_freq_table[i].odr_bits;
-	return -EINVAL;
-}
-
-static int kmx61_convert_bit_to_freq(u8 odr_bits, int *val, int *val2)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(kmx61_samp_freq_table); i++)
-		if (odr_bits == kmx61_samp_freq_table[i].odr_bits) {
-			*val = kmx61_samp_freq_table[i].val;
-			*val2 = kmx61_samp_freq_table[i].val2;
-			return 0;
-		}
+			return i;
 	return -EINVAL;
 }
 
-
 static int kmx61_convert_wake_up_odr_to_bit(int val, int val2)
 {
 	int i;
@@ -478,7 +463,7 @@ static int kmx61_set_odr(struct kmx61_data *data, int val, int val2, u8 device)
 
 static int kmx61_get_odr(struct kmx61_data *data, int *val, int *val2,
 			 u8 device)
-{	int i;
+{
 	u8 lodr_bits;
 
 	if (device & KMX61_ACC)
@@ -490,13 +475,13 @@ static int kmx61_get_odr(struct kmx61_data *data, int *val, int *val2,
 	else
 		return -EINVAL;
 
-	for (i = 0; i < ARRAY_SIZE(kmx61_samp_freq_table); i++)
-		if (lodr_bits == kmx61_samp_freq_table[i].odr_bits) {
-			*val = kmx61_samp_freq_table[i].val;
-			*val2 = kmx61_samp_freq_table[i].val2;
-			return 0;
-		}
-	return -EINVAL;
+	if (lodr_bits >= ARRAY_SIZE(kmx61_samp_freq_table))
+		return -EINVAL;
+
+	*val = kmx61_samp_freq_table[lodr_bits].val;
+	*val2 = kmx61_samp_freq_table[lodr_bits].val2;
+
+	return 0;
 }
 
 static int kmx61_set_range(struct kmx61_data *data, u8 range)
@@ -580,8 +565,11 @@ static int kmx61_chip_init(struct kmx61_data *data)
 	}
 	data->odr_bits = ret;
 
-	/* set output data rate for wake up (motion detection) function */
-	ret = kmx61_convert_bit_to_freq(data->odr_bits, &val, &val2);
+	/*
+	 * set output data rate for wake up (motion detection) function
+	 * to match data rate for accelerometer sampling
+	 */
+	ret = kmx61_get_odr(data, &val, &val2, KMX61_ACC);
 	if (ret < 0)
 		return ret;
 

commit df1fad80dfa0a7644b525c4a0dd8f2be21f57358
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Fri Jan 9 11:39:30 2015 +0200

    iio kmx61 / PM: Replace CONFIG_PM_RUNTIME with CONFIG_PM
    
    After commit b2b49ccbdd54 (PM: Kconfig: Set PM_RUNTIME if PM_SLEEP is
    selected) PM_RUNTIME is always set if PM is set, so #ifdef blocks
    depending on CONFIG_PM_RUNTIME may now be changed to depend on
    CONFIG_PM.
    
    Replace CONFIG_PM_RUNTIME with CONFIG_PM everywhere under
    drivers/iio/imu/kmx61.c
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index b60b22d25615..5cc3692acf37 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -747,7 +747,7 @@ static int kmx61_setup_any_motion_interrupt(struct kmx61_data *data,
  */
 static int kmx61_set_power_state(struct kmx61_data *data, bool on, u8 device)
 {
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
 	int ret;
 
 	if (device & KMX61_ACC) {
@@ -1531,7 +1531,7 @@ static int kmx61_resume(struct device *dev)
 }
 #endif
 
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
 static int kmx61_runtime_suspend(struct device *dev)
 {
 	struct kmx61_data *data = i2c_get_clientdata(to_i2c_client(dev));

commit 6a191c7025f80c328156a358871f5d947f443aa9
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Tue Dec 23 15:22:33 2014 +0200

    iio: imu: kmx61: Use correct base when reading data
    
    We have two IIO devices and we need to adjust the base
    when reading data.
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Reviewed-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index 1f7c3f1f4dfd..b60b22d25615 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -1218,12 +1218,18 @@ static irqreturn_t kmx61_trigger_handler(int irq, void *p)
 	struct iio_dev *indio_dev = pf->indio_dev;
 	struct kmx61_data *data = kmx61_get_data(indio_dev);
 	int bit, ret, i = 0;
+	u8 base;
 	s16 buffer[8];
 
+	if (indio_dev == data->acc_indio_dev)
+		base = KMX61_ACC_XOUT_L;
+	else
+		base = KMX61_MAG_XOUT_L;
+
 	mutex_lock(&data->lock);
 	for_each_set_bit(bit, indio_dev->buffer->scan_mask,
 			 indio_dev->masklength) {
-		ret = kmx61_read_measurement(data, KMX61_ACC_XOUT_L, bit);
+		ret = kmx61_read_measurement(data, base, bit);
 		if (ret < 0) {
 			mutex_unlock(&data->lock);
 			goto err;

commit ea04d2965874ca5753e756b335449c5322a85733
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Tue Dec 23 15:22:31 2014 +0200

    iio: imu: kmx61: Remove unnecessary REG_INS1 read
    
    Useful in the debugging phase, not needed now.
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Acked-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index 578e3dd944c9..1f7c3f1f4dfd 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -1192,8 +1192,6 @@ static irqreturn_t kmx61_event_handler(int irq, void *private)
 	if (ret < 0)
 		dev_err(&data->client->dev, "Error reading reg_inl\n");
 
-	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INS1);
-
 	return IRQ_HANDLED;
 }
 

commit dbdd0e2dd9981eafe33687d0b2d089c5285ea22b
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Tue Dec 23 15:22:30 2014 +0200

    iio: imu: kmx61: Fix device initialization when setting trigger state
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Acked-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index a70a3ef91793..578e3dd944c9 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -1053,8 +1053,7 @@ static int kmx61_data_rdy_trigger_set_state(struct iio_trigger *trig,
 		goto err_unlock;
 	}
 
-
-	if (data->acc_dready_trig == trig || data->motion_trig)
+	if (data->acc_dready_trig == trig || data->motion_trig == trig)
 		device = KMX61_ACC;
 	else
 		device = KMX61_MAG;

commit d4a4ae04d236a01a8648648a0e11777250ab2974
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Tue Dec 23 15:22:29 2014 +0200

    iio: imu: kmx61: Use false instead of 0 for ev_enable_state
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Acked-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index 777b7f68591c..a70a3ef91793 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -972,7 +972,7 @@ static int kmx61_write_event_config(struct iio_dev *indio_dev,
 	mutex_lock(&data->lock);
 
 	if (!state && data->motion_trig_on) {
-		data->ev_enable_state = 0;
+		data->ev_enable_state = false;
 		goto err_unlock;
 	}
 

commit 0475c68544ddcb72905e35cb8c050c523020e2c7
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Tue Dec 23 15:22:28 2014 +0200

    iio: imu: kmx61: Drop unused device parameter
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Reviewed-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index bf3468b982a0..777b7f68591c 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -681,7 +681,7 @@ static int kmx61_chip_update_thresholds(struct kmx61_data *data)
 }
 
 static int kmx61_setup_any_motion_interrupt(struct kmx61_data *data,
-					    bool status, u8 device)
+					    bool status)
 {
 	u8 mode;
 	int ret;
@@ -980,7 +980,7 @@ static int kmx61_write_event_config(struct iio_dev *indio_dev,
 	if (ret < 0)
 		goto err_unlock;
 
-	ret = kmx61_setup_any_motion_interrupt(data, state, KMX61_ACC);
+	ret = kmx61_setup_any_motion_interrupt(data, state);
 	if (ret < 0) {
 		kmx61_set_power_state(data, false, KMX61_ACC);
 		goto err_unlock;
@@ -1066,7 +1066,7 @@ static int kmx61_data_rdy_trigger_set_state(struct iio_trigger *trig,
 	if (data->acc_dready_trig == trig || data->mag_dready_trig == trig)
 		ret = kmx61_setup_new_data_interrupt(data, state, device);
 	else
-		ret = kmx61_setup_any_motion_interrupt(data, state, KMX61_ACC);
+		ret = kmx61_setup_any_motion_interrupt(data, state);
 	if (ret < 0) {
 		kmx61_set_power_state(data, false, device);
 		goto err_unlock;

commit dfb12edea5577243d4ea64d93a32f575e8b1cc4c
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Tue Dec 23 15:22:27 2014 +0200

    iio: imu: kmx61: Fixup parameters alignment
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Acked-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index 137c1d52b98e..bf3468b982a0 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -924,11 +924,11 @@ static int kmx61_read_event(struct iio_dev *indio_dev,
 }
 
 static int kmx61_write_event(struct iio_dev *indio_dev,
-			    const struct iio_chan_spec *chan,
-			    enum iio_event_type type,
-			    enum iio_event_direction dir,
-			    enum iio_event_info info,
-			    int val, int val2)
+			     const struct iio_chan_spec *chan,
+			     enum iio_event_type type,
+			     enum iio_event_direction dir,
+			     enum iio_event_info info,
+			     int val, int val2)
 {
 	struct kmx61_data *data = kmx61_get_data(indio_dev);
 
@@ -958,10 +958,10 @@ static int kmx61_read_event_config(struct iio_dev *indio_dev,
 }
 
 static int kmx61_write_event_config(struct iio_dev *indio_dev,
-				   const struct iio_chan_spec *chan,
-				   enum iio_event_type type,
-				   enum iio_event_direction dir,
-				   int state)
+				    const struct iio_chan_spec *chan,
+				    enum iio_event_type type,
+				    enum iio_event_direction dir,
+				    int state)
 {
 	struct kmx61_data *data = kmx61_get_data(indio_dev);
 	int ret = 0;

commit 28ff344e1d0a08d60149b859d47e1610fa5b622b
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Tue Dec 23 15:22:26 2014 +0200

    iio: imu: kmx61: Enhance error handling
    
    This fixes parts of kmx61 error handling to make code easier to read and to be
    more consistent with IIO coding conventions:
            * prefer as single point for error handling instead of duplicating code
            for each function
            * directly return a value from a case branch instead of breaking
            * fix error message for writing REG_CTRL1
    
    Also, add separate error paths for kmx61_trigger_setup/iio_triggered_buffer_setup
    calls.
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index 6eaecb95c2d0..137c1d52b98e 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -656,11 +656,7 @@ static int kmx61_setup_new_data_interrupt(struct kmx61_data *data,
 		return ret;
 	}
 
-	ret = kmx61_set_mode(data, mode, KMX61_ACC | KMX61_MAG, true);
-	if (ret)
-		return ret;
-
-	return 0;
+	return kmx61_set_mode(data, mode, KMX61_ACC | KMX61_MAG, true);
 }
 
 static int kmx61_chip_update_thresholds(struct kmx61_data *data)
@@ -678,12 +674,10 @@ static int kmx61_chip_update_thresholds(struct kmx61_data *data)
 	ret = i2c_smbus_write_byte_data(data->client,
 					KMX61_REG_WUF_THRESH,
 					data->wake_thresh);
-	if (ret < 0) {
+	if (ret < 0)
 		dev_err(&data->client->dev, "Error writing reg_wuf_thresh\n");
-		return ret;
-	}
 
-	return 0;
+	return ret;
 }
 
 static int kmx61_setup_any_motion_interrupt(struct kmx61_data *data,
@@ -737,11 +731,7 @@ static int kmx61_setup_any_motion_interrupt(struct kmx61_data *data,
 		return ret;
 	}
 	mode |= KMX61_ACT_STBY_BIT;
-	ret = kmx61_set_mode(data, mode, KMX61_ACC | KMX61_MAG, true);
-	if (ret)
-		return ret;
-
-	return 0;
+	return kmx61_set_mode(data, mode, KMX61_ACC | KMX61_MAG, true);
 }
 
 /**
@@ -924,15 +914,13 @@ static int kmx61_read_event(struct iio_dev *indio_dev,
 	switch (info) {
 	case IIO_EV_INFO_VALUE:
 		*val = data->wake_thresh;
-		break;
+		return IIO_VAL_INT;
 	case IIO_EV_INFO_PERIOD:
 		*val = data->wake_duration;
-		break;
+		return IIO_VAL_INT;
 	default:
 		return -EINVAL;
 	}
-
-	return IIO_VAL_INT;
 }
 
 static int kmx61_write_event(struct iio_dev *indio_dev,
@@ -950,15 +938,13 @@ static int kmx61_write_event(struct iio_dev *indio_dev,
 	switch (info) {
 	case IIO_EV_INFO_VALUE:
 		data->wake_thresh = val;
-		break;
+		return IIO_VAL_INT;
 	case IIO_EV_INFO_PERIOD:
 		data->wake_duration = val;
-		break;
+		return IIO_VAL_INT;
 	default:
 		return -EINVAL;
 	}
-
-	return IIO_VAL_INT;
 }
 
 static int kmx61_read_event_config(struct iio_dev *indio_dev,
@@ -978,7 +964,7 @@ static int kmx61_write_event_config(struct iio_dev *indio_dev,
 				   int state)
 {
 	struct kmx61_data *data = kmx61_get_data(indio_dev);
-	int ret;
+	int ret = 0;
 
 	if (state && data->ev_enable_state)
 		return 0;
@@ -987,27 +973,25 @@ static int kmx61_write_event_config(struct iio_dev *indio_dev,
 
 	if (!state && data->motion_trig_on) {
 		data->ev_enable_state = 0;
-		mutex_unlock(&data->lock);
-		return 0;
+		goto err_unlock;
 	}
 
 	ret = kmx61_set_power_state(data, state, KMX61_ACC);
-	if (ret < 0) {
-		mutex_unlock(&data->lock);
-		return ret;
-	}
+	if (ret < 0)
+		goto err_unlock;
 
 	ret = kmx61_setup_any_motion_interrupt(data, state, KMX61_ACC);
 	if (ret < 0) {
 		kmx61_set_power_state(data, false, KMX61_ACC);
-		mutex_unlock(&data->lock);
-		return ret;
+		goto err_unlock;
 	}
 
 	data->ev_enable_state = state;
+
+err_unlock:
 	mutex_unlock(&data->lock);
 
-	return 0;
+	return ret;
 }
 
 static int kmx61_acc_validate_trigger(struct iio_dev *indio_dev,
@@ -1066,8 +1050,7 @@ static int kmx61_data_rdy_trigger_set_state(struct iio_trigger *trig,
 
 	if (!state && data->ev_enable_state && data->motion_trig_on) {
 		data->motion_trig_on = false;
-		mutex_unlock(&data->lock);
-		return 0;
+		goto err_unlock;
 	}
 
 
@@ -1077,10 +1060,8 @@ static int kmx61_data_rdy_trigger_set_state(struct iio_trigger *trig,
 		device = KMX61_MAG;
 
 	ret = kmx61_set_power_state(data, state, device);
-	if (ret < 0) {
-		mutex_unlock(&data->lock);
-		return ret;
-	}
+	if (ret < 0)
+		goto err_unlock;
 
 	if (data->acc_dready_trig == trig || data->mag_dready_trig == trig)
 		ret = kmx61_setup_new_data_interrupt(data, state, device);
@@ -1088,8 +1069,7 @@ static int kmx61_data_rdy_trigger_set_state(struct iio_trigger *trig,
 		ret = kmx61_setup_any_motion_interrupt(data, state, KMX61_ACC);
 	if (ret < 0) {
 		kmx61_set_power_state(data, false, device);
-		mutex_unlock(&data->lock);
-		return ret;
+		goto err_unlock;
 	}
 
 	if (data->acc_dready_trig == trig)
@@ -1098,10 +1078,10 @@ static int kmx61_data_rdy_trigger_set_state(struct iio_trigger *trig,
 		data->mag_dready_trig_on = state;
 	else
 		data->motion_trig_on = state;
-
+err_unlock:
 	mutex_unlock(&data->lock);
 
-	return 0;
+	return ret;
 }
 
 static int kmx61_trig_try_reenable(struct iio_trigger *trig)
@@ -1207,7 +1187,7 @@ static irqreturn_t kmx61_event_handler(int irq, void *private)
 	ret |= KMX61_REG_CTRL1_BIT_RES;
 	ret = i2c_smbus_write_byte_data(data->client, KMX61_REG_CTRL1, ret);
 	if (ret < 0)
-		dev_err(&data->client->dev, "Error reading reg_ctrl1\n");
+		dev_err(&data->client->dev, "Error writing reg_ctrl1\n");
 
 	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INL);
 	if (ret < 0)
@@ -1409,15 +1389,17 @@ static int kmx61_probe(struct i2c_client *client,
 		data->acc_dready_trig =
 			kmx61_trigger_setup(data, data->acc_indio_dev,
 					    "dready");
-		if (IS_ERR(data->acc_dready_trig))
-			return PTR_ERR(data->acc_dready_trig);
+		if (IS_ERR(data->acc_dready_trig)) {
+			ret = PTR_ERR(data->acc_dready_trig);
+			goto err_chip_uninit;
+		}
 
 		data->mag_dready_trig =
 			kmx61_trigger_setup(data, data->mag_indio_dev,
 					    "dready");
 		if (IS_ERR(data->mag_dready_trig)) {
 			ret = PTR_ERR(data->mag_dready_trig);
-			goto err_trigger_unregister;
+			goto err_trigger_unregister_acc_dready;
 		}
 
 		data->motion_trig =
@@ -1425,7 +1407,7 @@ static int kmx61_probe(struct i2c_client *client,
 					    "any-motion");
 		if (IS_ERR(data->motion_trig)) {
 			ret = PTR_ERR(data->motion_trig);
-			goto err_trigger_unregister;
+			goto err_trigger_unregister_mag_dready;
 		}
 
 		ret = iio_triggered_buffer_setup(data->acc_indio_dev,
@@ -1435,7 +1417,7 @@ static int kmx61_probe(struct i2c_client *client,
 		if (ret < 0) {
 			dev_err(&data->client->dev,
 				"Failed to setup acc triggered buffer\n");
-			goto err_trigger_unregister;
+			goto err_trigger_unregister_motion;
 		}
 
 		ret = iio_triggered_buffer_setup(data->mag_indio_dev,
@@ -1445,14 +1427,14 @@ static int kmx61_probe(struct i2c_client *client,
 		if (ret < 0) {
 			dev_err(&data->client->dev,
 				"Failed to setup mag triggered buffer\n");
-			goto err_trigger_unregister;
+			goto err_buffer_cleanup_acc;
 		}
 	}
 
 	ret = iio_device_register(data->acc_indio_dev);
 	if (ret < 0) {
 		dev_err(&client->dev, "Failed to register acc iio device\n");
-		goto err_buffer_cleanup;
+		goto err_buffer_cleanup_mag;
 	}
 
 	ret = iio_device_register(data->mag_indio_dev);
@@ -1475,18 +1457,18 @@ static int kmx61_probe(struct i2c_client *client,
 	iio_device_unregister(data->mag_indio_dev);
 err_iio_unregister_acc:
 	iio_device_unregister(data->acc_indio_dev);
-err_buffer_cleanup:
-	if (client->irq >= 0) {
-		iio_triggered_buffer_cleanup(data->acc_indio_dev);
+err_buffer_cleanup_mag:
+	if (client->irq >= 0)
 		iio_triggered_buffer_cleanup(data->mag_indio_dev);
-	}
-err_trigger_unregister:
-	if (data->acc_dready_trig)
-		iio_trigger_unregister(data->acc_dready_trig);
-	if (data->mag_dready_trig)
-		iio_trigger_unregister(data->mag_dready_trig);
-	if (data->motion_trig)
-		iio_trigger_unregister(data->motion_trig);
+err_buffer_cleanup_acc:
+	if (client->irq >= 0)
+		iio_triggered_buffer_cleanup(data->acc_indio_dev);
+err_trigger_unregister_motion:
+	iio_trigger_unregister(data->motion_trig);
+err_trigger_unregister_mag_dready:
+	iio_trigger_unregister(data->mag_dready_trig);
+err_trigger_unregister_acc_dready:
+	iio_trigger_unregister(data->acc_dready_trig);
 err_chip_uninit:
 	kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);
 	return ret;

commit a3da4fa301ae60aac688ca320fb8b46a053d6d25
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Tue Dec 23 15:22:25 2014 +0200

    iio: imu: kmx61: Don't ignore kmx61_set_power_state errors
    
    ..except while in an error handler, where there is nothing
    to be done anyway.
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Reviewed-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index 52c943d50bef..6eaecb95c2d0 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -830,7 +830,12 @@ static int kmx61_read_raw(struct iio_dev *indio_dev,
 		}
 		mutex_lock(&data->lock);
 
-		kmx61_set_power_state(data, true, chan->address);
+		ret = kmx61_set_power_state(data, true, chan->address);
+		if (ret) {
+			mutex_unlock(&data->lock);
+			return ret;
+		}
+
 		ret = kmx61_read_measurement(data, base_reg, chan->scan_index);
 		if (ret < 0) {
 			kmx61_set_power_state(data, false, chan->address);
@@ -839,9 +844,11 @@ static int kmx61_read_raw(struct iio_dev *indio_dev,
 		}
 		*val = sign_extend32(ret >> chan->scan_type.shift,
 				     chan->scan_type.realbits - 1);
-		kmx61_set_power_state(data, false, chan->address);
+		ret = kmx61_set_power_state(data, false, chan->address);
 
 		mutex_unlock(&data->lock);
+		if (ret)
+			return ret;
 		return IIO_VAL_INT;
 	case IIO_CHAN_INFO_SCALE:
 		switch (chan->type) {

commit 4e8439779ef613135049cea77f50cf58ccc44255
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Tue Dec 23 15:22:24 2014 +0200

    iio: imu: kmx61: Save odr_bits for later use
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Reviewed-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index 9b32f012ca0f..52c943d50bef 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -465,6 +465,8 @@ static int kmx61_set_odr(struct kmx61_data *data, int val, int val2, u8 device)
 	if (ret < 0)
 		return ret;
 
+	data->odr_bits = odr_bits;
+
 	if (device & KMX61_ACC) {
 		ret = kmx61_set_wake_up_odr(data, val, val2);
 		if (ret)

commit ebd163660675534dd5f27c8d3fa426b8253a98f4
Author: kbuild test robot <fengguang.wu@intel.com>
Date:   Sat Dec 13 00:28:52 2014 +0800

    iio: imu: kmx61: kmx61_set_wake_up_odr() can be static
    
    drivers/iio/imu/kmx61.c:422:5: sparse: symbol 'kmx61_set_wake_up_odr' was not declared. Should it be static?
    
    Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
    Reviewed-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index bda9c40c020b..9b32f012ca0f 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -419,7 +419,7 @@ static int kmx61_get_mode(struct kmx61_data *data, u8 *mode, u8 device)
 	return 0;
 }
 
-int kmx61_set_wake_up_odr(struct kmx61_data *data, int val, int val2)
+static int kmx61_set_wake_up_odr(struct kmx61_data *data, int val, int val2)
 {
 	int ret, odr_bits;
 

commit fd3ae7a9f21c2a51a1d220bc7a7c3b45ab5e6ad1
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Wed Dec 3 15:31:53 2014 +0200

    iio: imu: kmx61: Add support for any motion trigger
    
    We use WUFE (Wake Up from Sleep Engine) and BTSE (Back to Sleep Engine)
    to detect general motion input.
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index b8080fc54a76..bda9c40c020b 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -20,6 +20,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/sysfs.h>
+#include <linux/iio/events.h>
 #include <linux/iio/trigger.h>
 #include <linux/iio/buffer.h>
 #include <linux/iio/triggered_buffer.h>
@@ -30,6 +31,8 @@
 #define KMX61_IRQ_NAME "kmx61_event"
 
 #define KMX61_REG_WHO_AM_I	0x00
+#define KMX61_REG_INS1		0x01
+#define KMX61_REG_INS2		0x02
 
 /*
  * three 16-bit accelerometer output registers for X/Y/Z axis
@@ -63,20 +66,36 @@
 #define KMX61_REG_INL		0x28
 #define KMX61_REG_STBY		0x29
 #define KMX61_REG_CTRL1		0x2A
+#define KMX61_REG_CTRL2		0x2B
 #define KMX61_REG_ODCNTL	0x2C
 #define KMX61_REG_INC1		0x2D
 
+#define KMX61_REG_WUF_THRESH	0x3D
+#define KMX61_REG_WUF_TIMER	0x3E
+
 #define KMX61_ACC_STBY_BIT	BIT(0)
 #define KMX61_MAG_STBY_BIT	BIT(1)
 #define KMX61_ACT_STBY_BIT	BIT(7)
 
 #define KMX61_ALL_STBY		(KMX61_ACC_STBY_BIT | KMX61_MAG_STBY_BIT)
 
+#define KMX61_REG_INS1_BIT_WUFS		BIT(1)
+
+#define KMX61_REG_INS2_BIT_ZP		BIT(0)
+#define KMX61_REG_INS2_BIT_ZN		BIT(1)
+#define KMX61_REG_INS2_BIT_YP		BIT(2)
+#define KMX61_REG_INS2_BIT_YN		BIT(3)
+#define KMX61_REG_INS2_BIT_XP		BIT(4)
+#define KMX61_REG_INS2_BIT_XN		BIT(5)
+
 #define KMX61_REG_CTRL1_GSEL_MASK	0x03
 
 #define KMX61_REG_CTRL1_BIT_RES		BIT(4)
 #define KMX61_REG_CTRL1_BIT_DRDYE	BIT(5)
+#define KMX61_REG_CTRL1_BIT_WUFE	BIT(6)
+#define KMX61_REG_CTRL1_BIT_BTSE	BIT(7)
 
+#define KMX61_REG_INC1_BIT_WUFS		BIT(0)
 #define KMX61_REG_INC1_BIT_DRDYM	BIT(1)
 #define KMX61_REG_INC1_BIT_DRDYA	BIT(2)
 #define KMX61_REG_INC1_BIT_IEN		BIT(5)
@@ -86,6 +105,11 @@
 #define KMX61_ACC_ODR_MASK	0x0F
 #define KMX61_MAG_ODR_MASK	0xF0
 
+#define KMX61_OWUF_MASK		0x7
+
+#define KMX61_DEFAULT_WAKE_THRESH	1
+#define KMX61_DEFAULT_WAKE_DURATION	1
+
 #define KMX61_SLEEP_DELAY_MS	2000
 
 #define KMX61_CHIP_ID		0x12
@@ -111,11 +135,16 @@ struct kmx61_data {
 	/* config bits */
 	u8 range;
 	u8 odr_bits;
+	u8 wake_thresh;
+	u8 wake_duration;
 
 	/* accelerometer specific data */
 	struct iio_dev *acc_indio_dev;
 	struct iio_trigger *acc_dready_trig;
+	struct iio_trigger *motion_trig;
 	bool acc_dready_trig_on;
+	bool motion_trig_on;
+	bool ev_enable_state;
 
 	/* magnetometer specific data */
 	struct iio_dev *mag_indio_dev;
@@ -154,6 +183,23 @@ static const struct {
 			{3, 125000, 0x0A},
 			{6, 250000, 0x0B} };
 
+static const struct {
+	int val;
+	int val2;
+	int odr_bits;
+} kmx61_wake_up_odr_table[] = { {0, 781000, 0x00},
+				 {1, 563000, 0x01},
+				 {3, 125000, 0x02},
+				 {6, 250000, 0x03},
+				 {12, 500000, 0x04},
+				 {25, 0, 0x05},
+				 {50, 0, 0x06},
+				 {100, 0, 0x06},
+				 {200, 0, 0x06},
+				 {400, 0, 0x06},
+				 {800, 0, 0x06},
+				 {1600, 0, 0x06} };
+
 static IIO_CONST_ATTR(accel_scale_available, "0.009582 0.019163 0.038326");
 static IIO_CONST_ATTR(magn_scale_available, "0.001465");
 static IIO_CONST_ATTR_SAMP_FREQ_AVAIL(
@@ -179,6 +225,14 @@ static const struct attribute_group kmx61_mag_attribute_group = {
 	.attrs = kmx61_mag_attributes,
 };
 
+static const struct iio_event_spec kmx61_event = {
+	.type = IIO_EV_TYPE_THRESH,
+	.dir = IIO_EV_DIR_EITHER,
+	.mask_separate = BIT(IIO_EV_INFO_VALUE) |
+			 BIT(IIO_EV_INFO_ENABLE) |
+			 BIT(IIO_EV_INFO_PERIOD),
+};
+
 #define KMX61_ACC_CHAN(_axis) { \
 	.type = IIO_ACCEL, \
 	.modified = 1, \
@@ -195,6 +249,8 @@ static const struct attribute_group kmx61_mag_attribute_group = {
 		.shift = 4, \
 		.endianness = IIO_LE, \
 	}, \
+	.event_spec = &kmx61_event, \
+	.num_event_specs = 1 \
 }
 
 #define KMX61_MAG_CHAN(_axis) { \
@@ -250,6 +306,31 @@ static int kmx61_convert_freq_to_bit(int val, int val2)
 	return -EINVAL;
 }
 
+static int kmx61_convert_bit_to_freq(u8 odr_bits, int *val, int *val2)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(kmx61_samp_freq_table); i++)
+		if (odr_bits == kmx61_samp_freq_table[i].odr_bits) {
+			*val = kmx61_samp_freq_table[i].val;
+			*val2 = kmx61_samp_freq_table[i].val2;
+			return 0;
+		}
+	return -EINVAL;
+}
+
+
+static int kmx61_convert_wake_up_odr_to_bit(int val, int val2)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(kmx61_wake_up_odr_table); ++i)
+		if (kmx61_wake_up_odr_table[i].val == val &&
+			kmx61_wake_up_odr_table[i].val2 == val2)
+				return kmx61_wake_up_odr_table[i].odr_bits;
+	return -EINVAL;
+}
+
 /**
  * kmx61_set_mode() - set KMX61 device operating mode
  * @data - kmx61 device private data pointer
@@ -338,6 +419,21 @@ static int kmx61_get_mode(struct kmx61_data *data, u8 *mode, u8 device)
 	return 0;
 }
 
+int kmx61_set_wake_up_odr(struct kmx61_data *data, int val, int val2)
+{
+	int ret, odr_bits;
+
+	odr_bits = kmx61_convert_wake_up_odr_to_bit(val, val2);
+	if (odr_bits < 0)
+		return odr_bits;
+
+	ret = i2c_smbus_write_byte_data(data->client, KMX61_REG_CTRL2,
+					odr_bits);
+	if (ret < 0)
+		dev_err(&data->client->dev, "Error writing reg_ctrl2\n");
+	return ret;
+}
+
 static int kmx61_set_odr(struct kmx61_data *data, int val, int val2, u8 device)
 {
 	int ret;
@@ -369,6 +465,12 @@ static int kmx61_set_odr(struct kmx61_data *data, int val, int val2, u8 device)
 	if (ret < 0)
 		return ret;
 
+	if (device & KMX61_ACC) {
+		ret = kmx61_set_wake_up_odr(data, val, val2);
+		if (ret)
+			return ret;
+	}
+
 	return kmx61_set_mode(data, mode, KMX61_ACC | KMX61_MAG, true);
 }
 
@@ -449,7 +551,7 @@ static int kmx61_set_scale(struct kmx61_data *data, u16 uscale)
 
 static int kmx61_chip_init(struct kmx61_data *data)
 {
-	int ret;
+	int ret, val, val2;
 
 	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_WHO_AM_I);
 	if (ret < 0) {
@@ -476,11 +578,23 @@ static int kmx61_chip_init(struct kmx61_data *data)
 	}
 	data->odr_bits = ret;
 
+	/* set output data rate for wake up (motion detection) function */
+	ret = kmx61_convert_bit_to_freq(data->odr_bits, &val, &val2);
+	if (ret < 0)
+		return ret;
+
+	ret = kmx61_set_wake_up_odr(data, val, val2);
+	if (ret < 0)
+		return ret;
+
 	/* set acc/magn to OPERATION mode */
 	ret = kmx61_set_mode(data, 0, KMX61_ACC | KMX61_MAG, true);
 	if (ret < 0)
 		return ret;
 
+	data->wake_thresh = KMX61_DEFAULT_WAKE_THRESH;
+	data->wake_duration = KMX61_DEFAULT_WAKE_DURATION;
+
 	return 0;
 }
 
@@ -547,6 +661,87 @@ static int kmx61_setup_new_data_interrupt(struct kmx61_data *data,
 	return 0;
 }
 
+static int kmx61_chip_update_thresholds(struct kmx61_data *data)
+{
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(data->client,
+					KMX61_REG_WUF_TIMER,
+					data->wake_duration);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Errow writing reg_wuf_timer\n");
+		return ret;
+	}
+
+	ret = i2c_smbus_write_byte_data(data->client,
+					KMX61_REG_WUF_THRESH,
+					data->wake_thresh);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error writing reg_wuf_thresh\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int kmx61_setup_any_motion_interrupt(struct kmx61_data *data,
+					    bool status, u8 device)
+{
+	u8 mode;
+	int ret;
+
+	ret = kmx61_get_mode(data, &mode, KMX61_ACC | KMX61_MAG);
+	if (ret < 0)
+		return ret;
+
+	ret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);
+	if (ret < 0)
+		return ret;
+
+	ret = kmx61_chip_update_thresholds(data);
+	if (ret < 0)
+		return ret;
+
+	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INC1);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error reading reg_inc1\n");
+		return ret;
+	}
+	if (status)
+		ret |= (KMX61_REG_INC1_BIT_IEN | KMX61_REG_INC1_BIT_WUFS);
+	else
+		ret &= ~(KMX61_REG_INC1_BIT_IEN | KMX61_REG_INC1_BIT_WUFS);
+
+	ret = i2c_smbus_write_byte_data(data->client, KMX61_REG_INC1, ret);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error writing reg_inc1\n");
+		return ret;
+	}
+
+	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_CTRL1);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error reading reg_ctrl1\n");
+		return ret;
+	}
+
+	if (status)
+		ret |= KMX61_REG_CTRL1_BIT_WUFE | KMX61_REG_CTRL1_BIT_BTSE;
+	else
+		ret &= ~(KMX61_REG_CTRL1_BIT_WUFE | KMX61_REG_CTRL1_BIT_BTSE);
+
+	ret = i2c_smbus_write_byte_data(data->client, KMX61_REG_CTRL1, ret);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error writing reg_ctrl1\n");
+		return ret;
+	}
+	mode |= KMX61_ACT_STBY_BIT;
+	ret = kmx61_set_mode(data, mode, KMX61_ACC | KMX61_MAG, true);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
 /**
  * kmx61_set_power_state() - set power state for kmx61 @device
  * @data - kmx61 device private pointer
@@ -707,12 +902,111 @@ static int kmx61_write_raw(struct iio_dev *indio_dev,
 	}
 }
 
+static int kmx61_read_event(struct iio_dev *indio_dev,
+			    const struct iio_chan_spec *chan,
+			    enum iio_event_type type,
+			    enum iio_event_direction dir,
+			    enum iio_event_info info,
+			    int *val, int *val2)
+{
+	struct kmx61_data *data = kmx61_get_data(indio_dev);
+
+	*val2 = 0;
+	switch (info) {
+	case IIO_EV_INFO_VALUE:
+		*val = data->wake_thresh;
+		break;
+	case IIO_EV_INFO_PERIOD:
+		*val = data->wake_duration;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return IIO_VAL_INT;
+}
+
+static int kmx61_write_event(struct iio_dev *indio_dev,
+			    const struct iio_chan_spec *chan,
+			    enum iio_event_type type,
+			    enum iio_event_direction dir,
+			    enum iio_event_info info,
+			    int val, int val2)
+{
+	struct kmx61_data *data = kmx61_get_data(indio_dev);
+
+	if (data->ev_enable_state)
+		return -EBUSY;
+
+	switch (info) {
+	case IIO_EV_INFO_VALUE:
+		data->wake_thresh = val;
+		break;
+	case IIO_EV_INFO_PERIOD:
+		data->wake_duration = val;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return IIO_VAL_INT;
+}
+
+static int kmx61_read_event_config(struct iio_dev *indio_dev,
+				   const struct iio_chan_spec *chan,
+				   enum iio_event_type type,
+				   enum iio_event_direction dir)
+{
+	struct kmx61_data *data = kmx61_get_data(indio_dev);
+
+	return data->ev_enable_state;
+}
+
+static int kmx61_write_event_config(struct iio_dev *indio_dev,
+				   const struct iio_chan_spec *chan,
+				   enum iio_event_type type,
+				   enum iio_event_direction dir,
+				   int state)
+{
+	struct kmx61_data *data = kmx61_get_data(indio_dev);
+	int ret;
+
+	if (state && data->ev_enable_state)
+		return 0;
+
+	mutex_lock(&data->lock);
+
+	if (!state && data->motion_trig_on) {
+		data->ev_enable_state = 0;
+		mutex_unlock(&data->lock);
+		return 0;
+	}
+
+	ret = kmx61_set_power_state(data, state, KMX61_ACC);
+	if (ret < 0) {
+		mutex_unlock(&data->lock);
+		return ret;
+	}
+
+	ret = kmx61_setup_any_motion_interrupt(data, state, KMX61_ACC);
+	if (ret < 0) {
+		kmx61_set_power_state(data, false, KMX61_ACC);
+		mutex_unlock(&data->lock);
+		return ret;
+	}
+
+	data->ev_enable_state = state;
+	mutex_unlock(&data->lock);
+
+	return 0;
+}
+
 static int kmx61_acc_validate_trigger(struct iio_dev *indio_dev,
 				      struct iio_trigger *trig)
 {
 	struct kmx61_data *data = kmx61_get_data(indio_dev);
 
-	if (data->acc_dready_trig != trig)
+	if (data->acc_dready_trig != trig && data->motion_trig != trig)
 		return -EINVAL;
 
 	return 0;
@@ -734,6 +1028,10 @@ static const struct iio_info kmx61_acc_info = {
 	.read_raw		= kmx61_read_raw,
 	.write_raw		= kmx61_write_raw,
 	.attrs			= &kmx61_acc_attribute_group,
+	.read_event_value	= kmx61_read_event,
+	.write_event_value	= kmx61_write_event,
+	.read_event_config	= kmx61_read_event_config,
+	.write_event_config	= kmx61_write_event_config,
 	.validate_trigger	= kmx61_acc_validate_trigger,
 };
 
@@ -753,11 +1051,18 @@ static int kmx61_data_rdy_trigger_set_state(struct iio_trigger *trig,
 	u8 device;
 
 	struct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);
-	struct kmx61_data *data = iio_priv(indio_dev);
+	struct kmx61_data *data = kmx61_get_data(indio_dev);
 
 	mutex_lock(&data->lock);
 
-	if (data->acc_dready_trig == trig)
+	if (!state && data->ev_enable_state && data->motion_trig_on) {
+		data->motion_trig_on = false;
+		mutex_unlock(&data->lock);
+		return 0;
+	}
+
+
+	if (data->acc_dready_trig == trig || data->motion_trig)
 		device = KMX61_ACC;
 	else
 		device = KMX61_MAG;
@@ -768,7 +1073,10 @@ static int kmx61_data_rdy_trigger_set_state(struct iio_trigger *trig,
 		return ret;
 	}
 
-	ret = kmx61_setup_new_data_interrupt(data, state, device);
+	if (data->acc_dready_trig == trig || data->mag_dready_trig == trig)
+		ret = kmx61_setup_new_data_interrupt(data, state, device);
+	else
+		ret = kmx61_setup_any_motion_interrupt(data, state, KMX61_ACC);
 	if (ret < 0) {
 		kmx61_set_power_state(data, false, device);
 		mutex_unlock(&data->lock);
@@ -777,8 +1085,10 @@ static int kmx61_data_rdy_trigger_set_state(struct iio_trigger *trig,
 
 	if (data->acc_dready_trig == trig)
 		data->acc_dready_trig_on = state;
-	else
+	else if (data->mag_dready_trig == trig)
 		data->mag_dready_trig_on = state;
+	else
+		data->motion_trig_on = state;
 
 	mutex_unlock(&data->lock);
 
@@ -806,6 +1116,99 @@ static const struct iio_trigger_ops kmx61_trigger_ops = {
 	.owner = THIS_MODULE,
 };
 
+static irqreturn_t kmx61_event_handler(int irq, void *private)
+{
+	struct kmx61_data *data = private;
+	struct iio_dev *indio_dev = data->acc_indio_dev;
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INS1);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error reading reg_ins1\n");
+		goto ack_intr;
+	}
+
+	if (ret & KMX61_REG_INS1_BIT_WUFS) {
+		ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INS2);
+		if (ret < 0) {
+			dev_err(&data->client->dev, "Error reading reg_ins2\n");
+			goto ack_intr;
+		}
+
+		if (ret & KMX61_REG_INS2_BIT_XN)
+			iio_push_event(indio_dev,
+				       IIO_MOD_EVENT_CODE(IIO_ACCEL,
+				       0,
+				       IIO_MOD_X,
+				       IIO_EV_TYPE_THRESH,
+				       IIO_EV_DIR_FALLING),
+				       0);
+
+		if (ret & KMX61_REG_INS2_BIT_XP)
+			iio_push_event(indio_dev,
+				       IIO_MOD_EVENT_CODE(IIO_ACCEL,
+				       0,
+				       IIO_MOD_X,
+				       IIO_EV_TYPE_THRESH,
+				       IIO_EV_DIR_RISING),
+				       0);
+
+		if (ret & KMX61_REG_INS2_BIT_YN)
+			iio_push_event(indio_dev,
+				       IIO_MOD_EVENT_CODE(IIO_ACCEL,
+				       0,
+				       IIO_MOD_Y,
+				       IIO_EV_TYPE_THRESH,
+				       IIO_EV_DIR_FALLING),
+				       0);
+
+		if (ret & KMX61_REG_INS2_BIT_YP)
+			iio_push_event(indio_dev,
+				       IIO_MOD_EVENT_CODE(IIO_ACCEL,
+				       0,
+				       IIO_MOD_Y,
+				       IIO_EV_TYPE_THRESH,
+				       IIO_EV_DIR_RISING),
+				       0);
+
+		if (ret & KMX61_REG_INS2_BIT_ZN)
+			iio_push_event(indio_dev,
+				       IIO_MOD_EVENT_CODE(IIO_ACCEL,
+				       0,
+				       IIO_MOD_Z,
+				       IIO_EV_TYPE_THRESH,
+				       IIO_EV_DIR_FALLING),
+				       0);
+
+		if (ret & KMX61_REG_INS2_BIT_ZP)
+			iio_push_event(indio_dev,
+				       IIO_MOD_EVENT_CODE(IIO_ACCEL,
+				       0,
+				       IIO_MOD_Z,
+				       IIO_EV_TYPE_THRESH,
+				       IIO_EV_DIR_RISING),
+				       0);
+	}
+
+ack_intr:
+	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_CTRL1);
+	if (ret < 0)
+		dev_err(&data->client->dev, "Error reading reg_ctrl1\n");
+
+	ret |= KMX61_REG_CTRL1_BIT_RES;
+	ret = i2c_smbus_write_byte_data(data->client, KMX61_REG_CTRL1, ret);
+	if (ret < 0)
+		dev_err(&data->client->dev, "Error reading reg_ctrl1\n");
+
+	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INL);
+	if (ret < 0)
+		dev_err(&data->client->dev, "Error reading reg_inl\n");
+
+	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INS1);
+
+	return IRQ_HANDLED;
+}
+
 static irqreturn_t kmx61_data_rdy_trig_poll(int irq, void *private)
 {
 	struct kmx61_data *data = private;
@@ -815,6 +1218,11 @@ static irqreturn_t kmx61_data_rdy_trig_poll(int irq, void *private)
 	if (data->mag_dready_trig_on)
 		iio_trigger_poll(data->mag_dready_trig);
 
+	if (data->motion_trig_on)
+		iio_trigger_poll(data->motion_trig);
+
+	if (data->ev_enable_state)
+		return IRQ_WAKE_THREAD;
 	return IRQ_HANDLED;
 }
 
@@ -982,7 +1390,7 @@ static int kmx61_probe(struct i2c_client *client,
 	if (client->irq >= 0) {
 		ret = devm_request_threaded_irq(&client->dev, client->irq,
 						kmx61_data_rdy_trig_poll,
-						NULL,
+						kmx61_event_handler,
 						IRQF_TRIGGER_RISING,
 						KMX61_IRQ_NAME,
 						data);
@@ -1003,6 +1411,14 @@ static int kmx61_probe(struct i2c_client *client,
 			goto err_trigger_unregister;
 		}
 
+		data->motion_trig =
+			kmx61_trigger_setup(data, data->acc_indio_dev,
+					    "any-motion");
+		if (IS_ERR(data->motion_trig)) {
+			ret = PTR_ERR(data->motion_trig);
+			goto err_trigger_unregister;
+		}
+
 		ret = iio_triggered_buffer_setup(data->acc_indio_dev,
 						 &iio_pollfunc_store_time,
 						 kmx61_trigger_handler,
@@ -1060,6 +1476,8 @@ static int kmx61_probe(struct i2c_client *client,
 		iio_trigger_unregister(data->acc_dready_trig);
 	if (data->mag_dready_trig)
 		iio_trigger_unregister(data->mag_dready_trig);
+	if (data->motion_trig)
+		iio_trigger_unregister(data->motion_trig);
 err_chip_uninit:
 	kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);
 	return ret;
@@ -1081,6 +1499,7 @@ static int kmx61_remove(struct i2c_client *client)
 		iio_triggered_buffer_cleanup(data->mag_indio_dev);
 		iio_trigger_unregister(data->acc_dready_trig);
 		iio_trigger_unregister(data->mag_dready_trig);
+		iio_trigger_unregister(data->motion_trig);
 	}
 
 	mutex_lock(&data->lock);

commit c3a23ecc0901f624b681bbfbc4829766c5aa3070
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Wed Dec 3 15:31:52 2014 +0200

    iio: imu: kmx61: Add support for data ready triggers
    
    This creates a data ready trigger per IIO device.
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index 98d58e1b6c6b..b8080fc54a76 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -20,9 +20,14 @@
 #include <linux/pm_runtime.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/sysfs.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/triggered_buffer.h>
+#include <linux/iio/trigger_consumer.h>
 
 #define KMX61_DRV_NAME "kmx61"
 #define KMX61_GPIO_NAME "kmx61_int"
+#define KMX61_IRQ_NAME "kmx61_event"
 
 #define KMX61_REG_WHO_AM_I	0x00
 
@@ -55,9 +60,11 @@
 #define KMX61_MAG_ZOUT_L	0x16
 #define KMX61_MAG_ZOUT_H	0x17
 
+#define KMX61_REG_INL		0x28
 #define KMX61_REG_STBY		0x29
 #define KMX61_REG_CTRL1		0x2A
 #define KMX61_REG_ODCNTL	0x2C
+#define KMX61_REG_INC1		0x2D
 
 #define KMX61_ACC_STBY_BIT	BIT(0)
 #define KMX61_MAG_STBY_BIT	BIT(1)
@@ -67,6 +74,13 @@
 
 #define KMX61_REG_CTRL1_GSEL_MASK	0x03
 
+#define KMX61_REG_CTRL1_BIT_RES		BIT(4)
+#define KMX61_REG_CTRL1_BIT_DRDYE	BIT(5)
+
+#define KMX61_REG_INC1_BIT_DRDYM	BIT(1)
+#define KMX61_REG_INC1_BIT_DRDYA	BIT(2)
+#define KMX61_REG_INC1_BIT_IEN		BIT(5)
+
 #define KMX61_ACC_ODR_SHIFT	0
 #define KMX61_MAG_ODR_SHIFT	4
 #define KMX61_ACC_ODR_MASK	0x0F
@@ -100,9 +114,13 @@ struct kmx61_data {
 
 	/* accelerometer specific data */
 	struct iio_dev *acc_indio_dev;
+	struct iio_trigger *acc_dready_trig;
+	bool acc_dready_trig_on;
 
 	/* magnetometer specific data */
 	struct iio_dev *mag_indio_dev;
+	struct iio_trigger *mag_dready_trig;
+	bool mag_dready_trig_on;
 };
 
 enum kmx61_range {
@@ -466,6 +484,69 @@ static int kmx61_chip_init(struct kmx61_data *data)
 	return 0;
 }
 
+static int kmx61_setup_new_data_interrupt(struct kmx61_data *data,
+					  bool status, u8 device)
+{
+	u8 mode;
+	int ret;
+
+	ret = kmx61_get_mode(data, &mode, KMX61_ACC | KMX61_MAG);
+	if (ret < 0)
+		return ret;
+
+	ret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);
+	if (ret < 0)
+		return ret;
+
+	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INC1);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error reading reg_ctrl1\n");
+		return ret;
+	}
+
+	if (status) {
+		ret |= KMX61_REG_INC1_BIT_IEN;
+		if (device & KMX61_ACC)
+			ret |= KMX61_REG_INC1_BIT_DRDYA;
+		if (device & KMX61_MAG)
+			ret |=  KMX61_REG_INC1_BIT_DRDYM;
+	} else {
+		ret &= ~KMX61_REG_INC1_BIT_IEN;
+		if (device & KMX61_ACC)
+			ret &= ~KMX61_REG_INC1_BIT_DRDYA;
+		if (device & KMX61_MAG)
+			ret &= ~KMX61_REG_INC1_BIT_DRDYM;
+	}
+	ret = i2c_smbus_write_byte_data(data->client, KMX61_REG_INC1, ret);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error writing reg_int_ctrl1\n");
+		return ret;
+	}
+
+	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_CTRL1);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error reading reg_ctrl1\n");
+		return ret;
+	}
+
+	if (status)
+		ret |= KMX61_REG_CTRL1_BIT_DRDYE;
+	else
+		ret &= ~KMX61_REG_CTRL1_BIT_DRDYE;
+
+	ret = i2c_smbus_write_byte_data(data->client, KMX61_REG_CTRL1, ret);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error writing reg_ctrl1\n");
+		return ret;
+	}
+
+	ret = kmx61_set_mode(data, mode, KMX61_ACC | KMX61_MAG, true);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
 /**
  * kmx61_set_power_state() - set power state for kmx61 @device
  * @data - kmx61 device private pointer
@@ -626,11 +707,34 @@ static int kmx61_write_raw(struct iio_dev *indio_dev,
 	}
 }
 
+static int kmx61_acc_validate_trigger(struct iio_dev *indio_dev,
+				      struct iio_trigger *trig)
+{
+	struct kmx61_data *data = kmx61_get_data(indio_dev);
+
+	if (data->acc_dready_trig != trig)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int kmx61_mag_validate_trigger(struct iio_dev *indio_dev,
+				      struct iio_trigger *trig)
+{
+	struct kmx61_data *data = kmx61_get_data(indio_dev);
+
+	if (data->mag_dready_trig != trig)
+		return -EINVAL;
+
+	return 0;
+}
+
 static const struct iio_info kmx61_acc_info = {
 	.driver_module		= THIS_MODULE,
 	.read_raw		= kmx61_read_raw,
 	.write_raw		= kmx61_write_raw,
 	.attrs			= &kmx61_acc_attribute_group,
+	.validate_trigger	= kmx61_acc_validate_trigger,
 };
 
 static const struct iio_info kmx61_mag_info = {
@@ -638,8 +742,109 @@ static const struct iio_info kmx61_mag_info = {
 	.read_raw		= kmx61_read_raw,
 	.write_raw		= kmx61_write_raw,
 	.attrs			= &kmx61_mag_attribute_group,
+	.validate_trigger	= kmx61_mag_validate_trigger,
+};
+
+
+static int kmx61_data_rdy_trigger_set_state(struct iio_trigger *trig,
+					    bool state)
+{
+	int ret = 0;
+	u8 device;
+
+	struct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);
+	struct kmx61_data *data = iio_priv(indio_dev);
+
+	mutex_lock(&data->lock);
+
+	if (data->acc_dready_trig == trig)
+		device = KMX61_ACC;
+	else
+		device = KMX61_MAG;
+
+	ret = kmx61_set_power_state(data, state, device);
+	if (ret < 0) {
+		mutex_unlock(&data->lock);
+		return ret;
+	}
+
+	ret = kmx61_setup_new_data_interrupt(data, state, device);
+	if (ret < 0) {
+		kmx61_set_power_state(data, false, device);
+		mutex_unlock(&data->lock);
+		return ret;
+	}
+
+	if (data->acc_dready_trig == trig)
+		data->acc_dready_trig_on = state;
+	else
+		data->mag_dready_trig_on = state;
+
+	mutex_unlock(&data->lock);
+
+	return 0;
+}
+
+static int kmx61_trig_try_reenable(struct iio_trigger *trig)
+{
+	struct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);
+	struct kmx61_data *data = kmx61_get_data(indio_dev);
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_INL);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error reading reg_inl\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct iio_trigger_ops kmx61_trigger_ops = {
+	.set_trigger_state = kmx61_data_rdy_trigger_set_state,
+	.try_reenable = kmx61_trig_try_reenable,
+	.owner = THIS_MODULE,
 };
 
+static irqreturn_t kmx61_data_rdy_trig_poll(int irq, void *private)
+{
+	struct kmx61_data *data = private;
+
+	if (data->acc_dready_trig_on)
+		iio_trigger_poll(data->acc_dready_trig);
+	if (data->mag_dready_trig_on)
+		iio_trigger_poll(data->mag_dready_trig);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t kmx61_trigger_handler(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct kmx61_data *data = kmx61_get_data(indio_dev);
+	int bit, ret, i = 0;
+	s16 buffer[8];
+
+	mutex_lock(&data->lock);
+	for_each_set_bit(bit, indio_dev->buffer->scan_mask,
+			 indio_dev->masklength) {
+		ret = kmx61_read_measurement(data, KMX61_ACC_XOUT_L, bit);
+		if (ret < 0) {
+			mutex_unlock(&data->lock);
+			goto err;
+		}
+		buffer[i++] = ret;
+	}
+	mutex_unlock(&data->lock);
+
+	iio_push_to_buffers(indio_dev, buffer);
+err:
+	iio_trigger_notify_done(indio_dev->trig);
+
+	return IRQ_HANDLED;
+}
+
 static const char *kmx61_match_acpi_device(struct device *dev)
 {
 	const struct acpi_device_id *id;
@@ -702,6 +907,32 @@ static struct iio_dev *kmx61_indiodev_setup(struct kmx61_data *data,
 	return indio_dev;
 }
 
+static struct iio_trigger *kmx61_trigger_setup(struct kmx61_data *data,
+					       struct iio_dev *indio_dev,
+					       const char *tag)
+{
+	struct iio_trigger *trig;
+	int ret;
+
+	trig = devm_iio_trigger_alloc(&data->client->dev,
+				      "%s-%s-dev%d",
+				      indio_dev->name,
+				      tag,
+				      indio_dev->id);
+	if (!trig)
+		return ERR_PTR(-ENOMEM);
+
+	trig->dev.parent = &data->client->dev;
+	trig->ops = &kmx61_trigger_ops;
+	iio_trigger_set_drvdata(trig, indio_dev);
+
+	ret = iio_trigger_register(trig);
+	if (ret)
+		return ERR_PTR(ret);
+
+	return trig;
+}
+
 static int kmx61_probe(struct i2c_client *client,
 		       const struct i2c_device_id *id)
 {
@@ -748,10 +979,55 @@ static int kmx61_probe(struct i2c_client *client,
 	if (client->irq < 0)
 		client->irq = kmx61_gpio_probe(client, data);
 
+	if (client->irq >= 0) {
+		ret = devm_request_threaded_irq(&client->dev, client->irq,
+						kmx61_data_rdy_trig_poll,
+						NULL,
+						IRQF_TRIGGER_RISING,
+						KMX61_IRQ_NAME,
+						data);
+		if (ret)
+			goto err_chip_uninit;
+
+		data->acc_dready_trig =
+			kmx61_trigger_setup(data, data->acc_indio_dev,
+					    "dready");
+		if (IS_ERR(data->acc_dready_trig))
+			return PTR_ERR(data->acc_dready_trig);
+
+		data->mag_dready_trig =
+			kmx61_trigger_setup(data, data->mag_indio_dev,
+					    "dready");
+		if (IS_ERR(data->mag_dready_trig)) {
+			ret = PTR_ERR(data->mag_dready_trig);
+			goto err_trigger_unregister;
+		}
+
+		ret = iio_triggered_buffer_setup(data->acc_indio_dev,
+						 &iio_pollfunc_store_time,
+						 kmx61_trigger_handler,
+						 NULL);
+		if (ret < 0) {
+			dev_err(&data->client->dev,
+				"Failed to setup acc triggered buffer\n");
+			goto err_trigger_unregister;
+		}
+
+		ret = iio_triggered_buffer_setup(data->mag_indio_dev,
+						 &iio_pollfunc_store_time,
+						 kmx61_trigger_handler,
+						 NULL);
+		if (ret < 0) {
+			dev_err(&data->client->dev,
+				"Failed to setup mag triggered buffer\n");
+			goto err_trigger_unregister;
+		}
+	}
+
 	ret = iio_device_register(data->acc_indio_dev);
 	if (ret < 0) {
 		dev_err(&client->dev, "Failed to register acc iio device\n");
-		goto err_chip_uninit;
+		goto err_buffer_cleanup;
 	}
 
 	ret = iio_device_register(data->mag_indio_dev);
@@ -774,6 +1050,16 @@ static int kmx61_probe(struct i2c_client *client,
 	iio_device_unregister(data->mag_indio_dev);
 err_iio_unregister_acc:
 	iio_device_unregister(data->acc_indio_dev);
+err_buffer_cleanup:
+	if (client->irq >= 0) {
+		iio_triggered_buffer_cleanup(data->acc_indio_dev);
+		iio_triggered_buffer_cleanup(data->mag_indio_dev);
+	}
+err_trigger_unregister:
+	if (data->acc_dready_trig)
+		iio_trigger_unregister(data->acc_dready_trig);
+	if (data->mag_dready_trig)
+		iio_trigger_unregister(data->mag_dready_trig);
 err_chip_uninit:
 	kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);
 	return ret;
@@ -790,6 +1076,13 @@ static int kmx61_remove(struct i2c_client *client)
 	iio_device_unregister(data->acc_indio_dev);
 	iio_device_unregister(data->mag_indio_dev);
 
+	if (client->irq >= 0) {
+		iio_triggered_buffer_cleanup(data->acc_indio_dev);
+		iio_triggered_buffer_cleanup(data->mag_indio_dev);
+		iio_trigger_unregister(data->acc_dready_trig);
+		iio_trigger_unregister(data->mag_dready_trig);
+	}
+
 	mutex_lock(&data->lock);
 	kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);
 	mutex_unlock(&data->lock);

commit 3b9c40e604ee61e69a8aff6e1a426a6250ff4361
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Wed Dec 3 15:31:51 2014 +0200

    iio: imu: kmx61: Add PM sleep support
    
    Per sensor state (ACTIVE/STANDBY) is saved in driver's
    private data (acc_stby/mag_stby) and restored when
    resume is called.
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index f3007dd664fc..98d58e1b6c6b 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -16,6 +16,7 @@
 #include <linux/acpi.h>
 #include <linux/gpio/consumer.h>
 #include <linux/interrupt.h>
+#include <linux/pm.h>
 #include <linux/pm_runtime.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/sysfs.h>
@@ -796,6 +797,33 @@ static int kmx61_remove(struct i2c_client *client)
 	return 0;
 }
 
+#ifdef CONFIG_PM_SLEEP
+static int kmx61_suspend(struct device *dev)
+{
+	int ret;
+	struct kmx61_data *data = i2c_get_clientdata(to_i2c_client(dev));
+
+	mutex_lock(&data->lock);
+	ret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG,
+			     false);
+	mutex_unlock(&data->lock);
+
+	return ret;
+}
+
+static int kmx61_resume(struct device *dev)
+{
+	u8 stby = 0;
+	struct kmx61_data *data = i2c_get_clientdata(to_i2c_client(dev));
+
+	if (data->acc_stby)
+		stby |= KMX61_ACC_STBY_BIT;
+	if (data->mag_stby)
+		stby |= KMX61_MAG_STBY_BIT;
+
+	return kmx61_set_mode(data, stby, KMX61_ACC | KMX61_MAG, true);
+}
+#endif
 
 #ifdef CONFIG_PM_RUNTIME
 static int kmx61_runtime_suspend(struct device *dev)
@@ -825,6 +853,7 @@ static int kmx61_runtime_resume(struct device *dev)
 #endif
 
 static const struct dev_pm_ops kmx61_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(kmx61_suspend, kmx61_resume)
 	SET_RUNTIME_PM_OPS(kmx61_runtime_suspend, kmx61_runtime_resume, NULL)
 };
 

commit aff8609addd00efa3d907f3523823693f95686fd
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Wed Dec 3 15:31:50 2014 +0200

    iio: imu: kmx61: Add PM runtime support
    
    By default both sensors are ACTIVE, in this way the driver
    will work even if CONFIG_PM_RUNTIME is not selected.
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index efb2f8b450c1..f3007dd664fc 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -15,6 +15,8 @@
 #include <linux/i2c.h>
 #include <linux/acpi.h>
 #include <linux/gpio/consumer.h>
+#include <linux/interrupt.h>
+#include <linux/pm_runtime.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/sysfs.h>
 
@@ -69,6 +71,8 @@
 #define KMX61_ACC_ODR_MASK	0x0F
 #define KMX61_MAG_ODR_MASK	0xF0
 
+#define KMX61_SLEEP_DELAY_MS	2000
+
 #define KMX61_CHIP_ID		0x12
 
 /* KMX61 devices */
@@ -85,6 +89,10 @@ struct kmx61_data {
 	bool acc_stby;
 	bool mag_stby;
 
+	/* power state */
+	bool acc_ps;
+	bool mag_ps;
+
 	/* config bits */
 	u8 range;
 	u8 odr_bits;
@@ -457,6 +465,58 @@ static int kmx61_chip_init(struct kmx61_data *data)
 	return 0;
 }
 
+/**
+ * kmx61_set_power_state() - set power state for kmx61 @device
+ * @data - kmx61 device private pointer
+ * @on - power state to be set for @device
+ * @device - bitmask indicating device for which @on state needs to be set
+ *
+ * Notice that when ACC power state needs to be set to ON and MAG is in
+ * OPERATION then we know that kmx61_runtime_resume was already called
+ * so we must set ACC OPERATION mode here. The same happens when MAG power
+ * state needs to be set to ON and ACC is in OPERATION.
+ */
+static int kmx61_set_power_state(struct kmx61_data *data, bool on, u8 device)
+{
+#ifdef CONFIG_PM_RUNTIME
+	int ret;
+
+	if (device & KMX61_ACC) {
+		if (on && !data->acc_ps && !data->mag_stby) {
+			ret = kmx61_set_mode(data, 0, KMX61_ACC, true);
+			if (ret < 0)
+				return ret;
+		}
+		data->acc_ps = on;
+	}
+	if (device & KMX61_MAG) {
+		if (on && !data->mag_ps && !data->acc_stby) {
+			ret = kmx61_set_mode(data, 0, KMX61_MAG, true);
+			if (ret < 0)
+				return ret;
+		}
+		data->mag_ps = on;
+	}
+
+	if (on) {
+		ret = pm_runtime_get_sync(&data->client->dev);
+	} else {
+		pm_runtime_mark_last_busy(&data->client->dev);
+		ret = pm_runtime_put_autosuspend(&data->client->dev);
+	}
+	if (ret < 0) {
+		dev_err(&data->client->dev,
+			"Failed: kmx61_set_power_state for %d, ret %d\n",
+			on, ret);
+		if (on)
+			pm_runtime_put_noidle(&data->client->dev);
+
+		return ret;
+	}
+#endif
+	return 0;
+}
+
 static int kmx61_read_measurement(struct kmx61_data *data, u8 base, u8 offset)
 {
 	int ret;
@@ -491,13 +551,16 @@ static int kmx61_read_raw(struct iio_dev *indio_dev,
 		}
 		mutex_lock(&data->lock);
 
+		kmx61_set_power_state(data, true, chan->address);
 		ret = kmx61_read_measurement(data, base_reg, chan->scan_index);
 		if (ret < 0) {
+			kmx61_set_power_state(data, false, chan->address);
 			mutex_unlock(&data->lock);
 			return ret;
 		}
 		*val = sign_extend32(ret >> chan->scan_type.shift,
 				     chan->scan_type.realbits - 1);
+		kmx61_set_power_state(data, false, chan->address);
 
 		mutex_unlock(&data->lock);
 		return IIO_VAL_INT;
@@ -693,12 +756,22 @@ static int kmx61_probe(struct i2c_client *client,
 	ret = iio_device_register(data->mag_indio_dev);
 	if (ret < 0) {
 		dev_err(&client->dev, "Failed to register mag iio device\n");
-		goto err_iio_unregister;
+		goto err_iio_unregister_acc;
 	}
 
+	ret = pm_runtime_set_active(&client->dev);
+	if (ret < 0)
+		goto err_iio_unregister_mag;
+
+	pm_runtime_enable(&client->dev);
+	pm_runtime_set_autosuspend_delay(&client->dev, KMX61_SLEEP_DELAY_MS);
+	pm_runtime_use_autosuspend(&client->dev);
+
 	return 0;
 
-err_iio_unregister:
+err_iio_unregister_mag:
+	iio_device_unregister(data->mag_indio_dev);
+err_iio_unregister_acc:
 	iio_device_unregister(data->acc_indio_dev);
 err_chip_uninit:
 	kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);
@@ -709,6 +782,10 @@ static int kmx61_remove(struct i2c_client *client)
 {
 	struct kmx61_data *data = i2c_get_clientdata(client);
 
+	pm_runtime_disable(&client->dev);
+	pm_runtime_set_suspended(&client->dev);
+	pm_runtime_put_noidle(&client->dev);
+
 	iio_device_unregister(data->acc_indio_dev);
 	iio_device_unregister(data->mag_indio_dev);
 
@@ -719,6 +796,38 @@ static int kmx61_remove(struct i2c_client *client)
 	return 0;
 }
 
+
+#ifdef CONFIG_PM_RUNTIME
+static int kmx61_runtime_suspend(struct device *dev)
+{
+	struct kmx61_data *data = i2c_get_clientdata(to_i2c_client(dev));
+	int ret;
+
+	mutex_lock(&data->lock);
+	ret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);
+	mutex_unlock(&data->lock);
+
+	return ret;
+}
+
+static int kmx61_runtime_resume(struct device *dev)
+{
+	struct kmx61_data *data = i2c_get_clientdata(to_i2c_client(dev));
+	u8 stby = 0;
+
+	if (!data->acc_ps)
+		stby |= KMX61_ACC_STBY_BIT;
+	if (!data->mag_ps)
+		stby |= KMX61_MAG_STBY_BIT;
+
+	return kmx61_set_mode(data, stby, KMX61_ACC | KMX61_MAG, true);
+}
+#endif
+
+static const struct dev_pm_ops kmx61_pm_ops = {
+	SET_RUNTIME_PM_OPS(kmx61_runtime_suspend, kmx61_runtime_resume, NULL)
+};
+
 static const struct acpi_device_id kmx61_acpi_match[] = {
 	{"KMX61021", 0},
 	{}
@@ -737,6 +846,7 @@ static struct i2c_driver kmx61_driver = {
 	.driver = {
 		.name = KMX61_DRV_NAME,
 		.acpi_match_table = ACPI_PTR(kmx61_acpi_match),
+		.pm = &kmx61_pm_ops,
 	},
 	.probe		= kmx61_probe,
 	.remove		= kmx61_remove,

commit b25862c577979659020f3575838d366f480ec3bf
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Wed Dec 3 15:31:49 2014 +0200

    iio: imu: kmx61: Add acpi support
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
index 5231d8f3b167..efb2f8b450c1 100644
--- a/drivers/iio/imu/kmx61.c
+++ b/drivers/iio/imu/kmx61.c
@@ -13,10 +13,13 @@
 
 #include <linux/module.h>
 #include <linux/i2c.h>
+#include <linux/acpi.h>
+#include <linux/gpio/consumer.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/sysfs.h>
 
 #define KMX61_DRV_NAME "kmx61"
+#define KMX61_GPIO_NAME "kmx61_int"
 
 #define KMX61_REG_WHO_AM_I	0x00
 
@@ -573,6 +576,44 @@ static const struct iio_info kmx61_mag_info = {
 	.attrs			= &kmx61_mag_attribute_group,
 };
 
+static const char *kmx61_match_acpi_device(struct device *dev)
+{
+	const struct acpi_device_id *id;
+
+	id = acpi_match_device(dev->driver->acpi_match_table, dev);
+	if (!id)
+		return NULL;
+	return dev_name(dev);
+}
+
+static int kmx61_gpio_probe(struct i2c_client *client, struct kmx61_data *data)
+{
+	struct device *dev;
+	struct gpio_desc *gpio;
+	int ret;
+
+	if (!client)
+		return -EINVAL;
+
+	dev = &client->dev;
+
+	/* data ready gpio interrupt pin */
+	gpio = devm_gpiod_get_index(dev, KMX61_GPIO_NAME, 0);
+	if (IS_ERR(gpio)) {
+		dev_err(dev, "acpi gpio get index failed\n");
+		return PTR_ERR(gpio);
+	}
+
+	ret = gpiod_direction_input(gpio);
+	if (ret)
+		return ret;
+
+	ret = gpiod_to_irq(gpio);
+
+	dev_dbg(dev, "GPIO resource, no:%d irq:%d\n", desc_to_gpio(gpio), ret);
+	return ret;
+}
+
 static struct iio_dev *kmx61_indiodev_setup(struct kmx61_data *data,
 					    const struct iio_info *info,
 					    const struct iio_chan_spec *chan,
@@ -613,6 +654,13 @@ static int kmx61_probe(struct i2c_client *client,
 
 	mutex_init(&data->lock);
 
+	if (id)
+		name = id->name;
+	else if (ACPI_HANDLE(&client->dev))
+		name = kmx61_match_acpi_device(&client->dev);
+	else
+		return -ENODEV;
+
 	data->acc_indio_dev =
 		kmx61_indiodev_setup(data, &kmx61_acc_info,
 				     kmx61_acc_channels,
@@ -633,6 +681,9 @@ static int kmx61_probe(struct i2c_client *client,
 	if (ret < 0)
 		return ret;
 
+	if (client->irq < 0)
+		client->irq = kmx61_gpio_probe(client, data);
+
 	ret = iio_device_register(data->acc_indio_dev);
 	if (ret < 0) {
 		dev_err(&client->dev, "Failed to register acc iio device\n");
@@ -668,6 +719,13 @@ static int kmx61_remove(struct i2c_client *client)
 	return 0;
 }
 
+static const struct acpi_device_id kmx61_acpi_match[] = {
+	{"KMX61021", 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(acpi, kmx61_acpi_match);
+
 static const struct i2c_device_id kmx61_id[] = {
 	{"kmx611021", 0},
 	{}
@@ -678,6 +736,7 @@ MODULE_DEVICE_TABLE(i2c, kmx61_id);
 static struct i2c_driver kmx61_driver = {
 	.driver = {
 		.name = KMX61_DRV_NAME,
+		.acpi_match_table = ACPI_PTR(kmx61_acpi_match),
 	},
 	.probe		= kmx61_probe,
 	.remove		= kmx61_remove,

commit 20ffac278ebd64ad031149628560f47990910dd7
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Wed Dec 3 15:31:48 2014 +0200

    iio: imu: Add support for Kionix KMX61 sensor
    
    Minimal implementation for KMX61 6-axis accelerometer/magnetometer. It exports
    raw accel/magn readings together with scale and sampling frequency.
    
    This driver uses two IIO devices one for accelerometer and one for magnetometer.
    
    Datasheet will be available at:
    http://www.kionix.com/6-axis-accelerometer-magnetometer/kmx61
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
new file mode 100644
index 000000000000..5231d8f3b167
--- /dev/null
+++ b/drivers/iio/imu/kmx61.c
@@ -0,0 +1,691 @@
+/*
+ * KMX61 - Kionix 6-axis Accelerometer/Magnetometer
+ *
+ * Copyright (c) 2014, Intel Corporation.
+ *
+ * This file is subject to the terms and conditions of version 2 of
+ * the GNU General Public License.  See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ * IIO driver for KMX61 (7-bit I2C slave address 0x0E or 0x0F).
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+
+#define KMX61_DRV_NAME "kmx61"
+
+#define KMX61_REG_WHO_AM_I	0x00
+
+/*
+ * three 16-bit accelerometer output registers for X/Y/Z axis
+ * we use only XOUT_L as a base register, all other addresses
+ * can be obtained by applying an offset and are provided here
+ * only for clarity.
+ */
+#define KMX61_ACC_XOUT_L	0x0A
+#define KMX61_ACC_XOUT_H	0x0B
+#define KMX61_ACC_YOUT_L	0x0C
+#define KMX61_ACC_YOUT_H	0x0D
+#define KMX61_ACC_ZOUT_L	0x0E
+#define KMX61_ACC_ZOUT_H	0x0F
+
+/*
+ * one 16-bit temperature output register
+ */
+#define KMX61_TEMP_L		0x10
+#define KMX61_TEMP_H		0x11
+
+/*
+ * three 16-bit magnetometer output registers for X/Y/Z axis
+ */
+#define KMX61_MAG_XOUT_L	0x12
+#define KMX61_MAG_XOUT_H	0x13
+#define KMX61_MAG_YOUT_L	0x14
+#define KMX61_MAG_YOUT_H	0x15
+#define KMX61_MAG_ZOUT_L	0x16
+#define KMX61_MAG_ZOUT_H	0x17
+
+#define KMX61_REG_STBY		0x29
+#define KMX61_REG_CTRL1		0x2A
+#define KMX61_REG_ODCNTL	0x2C
+
+#define KMX61_ACC_STBY_BIT	BIT(0)
+#define KMX61_MAG_STBY_BIT	BIT(1)
+#define KMX61_ACT_STBY_BIT	BIT(7)
+
+#define KMX61_ALL_STBY		(KMX61_ACC_STBY_BIT | KMX61_MAG_STBY_BIT)
+
+#define KMX61_REG_CTRL1_GSEL_MASK	0x03
+
+#define KMX61_ACC_ODR_SHIFT	0
+#define KMX61_MAG_ODR_SHIFT	4
+#define KMX61_ACC_ODR_MASK	0x0F
+#define KMX61_MAG_ODR_MASK	0xF0
+
+#define KMX61_CHIP_ID		0x12
+
+/* KMX61 devices */
+#define KMX61_ACC	0x01
+#define KMX61_MAG	0x02
+
+struct kmx61_data {
+	struct i2c_client *client;
+
+	/* serialize access to non-atomic ops, e.g set_mode */
+	struct mutex lock;
+
+	/* standby state */
+	bool acc_stby;
+	bool mag_stby;
+
+	/* config bits */
+	u8 range;
+	u8 odr_bits;
+
+	/* accelerometer specific data */
+	struct iio_dev *acc_indio_dev;
+
+	/* magnetometer specific data */
+	struct iio_dev *mag_indio_dev;
+};
+
+enum kmx61_range {
+	KMX61_RANGE_2G,
+	KMX61_RANGE_4G,
+	KMX61_RANGE_8G,
+};
+
+enum kmx61_axis {
+	KMX61_AXIS_X,
+	KMX61_AXIS_Y,
+	KMX61_AXIS_Z,
+};
+
+static const u16 kmx61_uscale_table[] = {9582, 19163, 38326};
+
+static const struct {
+	int val;
+	int val2;
+	u8 odr_bits;
+} kmx61_samp_freq_table[] = { {12, 500000, 0x00},
+			{25, 0, 0x01},
+			{50, 0, 0x02},
+			{100, 0, 0x03},
+			{200, 0, 0x04},
+			{400, 0, 0x05},
+			{800, 0, 0x06},
+			{1600, 0, 0x07},
+			{0, 781000, 0x08},
+			{1, 563000, 0x09},
+			{3, 125000, 0x0A},
+			{6, 250000, 0x0B} };
+
+static IIO_CONST_ATTR(accel_scale_available, "0.009582 0.019163 0.038326");
+static IIO_CONST_ATTR(magn_scale_available, "0.001465");
+static IIO_CONST_ATTR_SAMP_FREQ_AVAIL(
+	"0.781000 1.563000 3.125000 6.250000 12.500000 25 50 100 200 400 800");
+
+static struct attribute *kmx61_acc_attributes[] = {
+	&iio_const_attr_accel_scale_available.dev_attr.attr,
+	&iio_const_attr_sampling_frequency_available.dev_attr.attr,
+	NULL,
+};
+
+static struct attribute *kmx61_mag_attributes[] = {
+	&iio_const_attr_magn_scale_available.dev_attr.attr,
+	&iio_const_attr_sampling_frequency_available.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group kmx61_acc_attribute_group = {
+	.attrs = kmx61_acc_attributes,
+};
+
+static const struct attribute_group kmx61_mag_attribute_group = {
+	.attrs = kmx61_mag_attributes,
+};
+
+#define KMX61_ACC_CHAN(_axis) { \
+	.type = IIO_ACCEL, \
+	.modified = 1, \
+	.channel2 = IIO_MOD_ ## _axis, \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \
+	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) | \
+				BIT(IIO_CHAN_INFO_SAMP_FREQ), \
+	.address = KMX61_ACC, \
+	.scan_index = KMX61_AXIS_ ## _axis, \
+	.scan_type = { \
+		.sign = 's', \
+		.realbits = 12, \
+		.storagebits = 16, \
+		.shift = 4, \
+		.endianness = IIO_LE, \
+	}, \
+}
+
+#define KMX61_MAG_CHAN(_axis) { \
+	.type = IIO_MAGN, \
+	.modified = 1, \
+	.channel2 = IIO_MOD_ ## _axis, \
+	.address = KMX61_MAG, \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \
+	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) | \
+				BIT(IIO_CHAN_INFO_SAMP_FREQ), \
+	.scan_index = KMX61_AXIS_ ## _axis, \
+	.scan_type = { \
+		.sign = 's', \
+		.realbits = 14, \
+		.storagebits = 16, \
+		.shift = 2, \
+		.endianness = IIO_LE, \
+	}, \
+}
+
+static const struct iio_chan_spec kmx61_acc_channels[] = {
+	KMX61_ACC_CHAN(X),
+	KMX61_ACC_CHAN(Y),
+	KMX61_ACC_CHAN(Z),
+};
+
+static const struct iio_chan_spec kmx61_mag_channels[] = {
+	KMX61_MAG_CHAN(X),
+	KMX61_MAG_CHAN(Y),
+	KMX61_MAG_CHAN(Z),
+};
+
+static void kmx61_set_data(struct iio_dev *indio_dev, struct kmx61_data *data)
+{
+	struct kmx61_data **priv = iio_priv(indio_dev);
+
+	*priv = data;
+}
+
+static struct kmx61_data *kmx61_get_data(struct iio_dev *indio_dev)
+{
+	return *(struct kmx61_data **)iio_priv(indio_dev);
+}
+
+static int kmx61_convert_freq_to_bit(int val, int val2)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(kmx61_samp_freq_table); i++)
+		if (val == kmx61_samp_freq_table[i].val &&
+		    val2 == kmx61_samp_freq_table[i].val2)
+			return kmx61_samp_freq_table[i].odr_bits;
+	return -EINVAL;
+}
+
+/**
+ * kmx61_set_mode() - set KMX61 device operating mode
+ * @data - kmx61 device private data pointer
+ * @mode - bitmask, indicating operating mode for @device
+ * @device - bitmask, indicating device for which @mode needs to be set
+ * @update - update stby bits stored in device's private  @data
+ *
+ * For each sensor (accelerometer/magnetometer) there are two operating modes
+ * STANDBY and OPERATION. Neither accel nor magn can be disabled independently
+ * if they are both enabled. Internal sensors state is saved in acc_stby and
+ * mag_stby members of driver's private @data.
+ */
+static int kmx61_set_mode(struct kmx61_data *data, u8 mode, u8 device,
+			  bool update)
+{
+	int ret;
+	int acc_stby = -1, mag_stby = -1;
+
+	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_STBY);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error reading reg_stby\n");
+		return ret;
+	}
+	if (device & KMX61_ACC) {
+		if (mode & KMX61_ACC_STBY_BIT) {
+			ret |= KMX61_ACC_STBY_BIT;
+			acc_stby = 1;
+		} else {
+			ret &= ~KMX61_ACC_STBY_BIT;
+			acc_stby = 0;
+		}
+	}
+
+	if (device & KMX61_MAG) {
+		if (mode & KMX61_MAG_STBY_BIT) {
+			ret |= KMX61_MAG_STBY_BIT;
+			mag_stby = 1;
+		} else {
+			ret &= ~KMX61_MAG_STBY_BIT;
+			mag_stby = 0;
+		}
+	}
+
+	if (mode & KMX61_ACT_STBY_BIT)
+		ret |= KMX61_ACT_STBY_BIT;
+
+	ret = i2c_smbus_write_byte_data(data->client, KMX61_REG_STBY, ret);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error writing reg_stby\n");
+		return ret;
+	}
+
+	if (acc_stby != -1 && update)
+		data->acc_stby = acc_stby;
+	if (mag_stby != -1 && update)
+		data->mag_stby = mag_stby;
+
+	return 0;
+}
+
+static int kmx61_get_mode(struct kmx61_data *data, u8 *mode, u8 device)
+{
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_STBY);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error reading reg_stby\n");
+		return ret;
+	}
+	*mode = 0;
+
+	if (device & KMX61_ACC) {
+		if (ret & KMX61_ACC_STBY_BIT)
+			*mode |= KMX61_ACC_STBY_BIT;
+		else
+			*mode &= ~KMX61_ACC_STBY_BIT;
+	}
+
+	if (device & KMX61_MAG) {
+		if (ret & KMX61_MAG_STBY_BIT)
+			*mode |= KMX61_MAG_STBY_BIT;
+		else
+			*mode &= ~KMX61_MAG_STBY_BIT;
+	}
+
+	return 0;
+}
+
+static int kmx61_set_odr(struct kmx61_data *data, int val, int val2, u8 device)
+{
+	int ret;
+	u8 mode;
+	int lodr_bits, odr_bits;
+
+	ret = kmx61_get_mode(data, &mode, KMX61_ACC | KMX61_MAG);
+	if (ret < 0)
+		return ret;
+
+	lodr_bits = kmx61_convert_freq_to_bit(val, val2);
+	if (lodr_bits < 0)
+		return lodr_bits;
+
+	/* To change ODR, accel and magn must be in STDBY */
+	ret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG,
+			     true);
+	if (ret < 0)
+		return ret;
+
+	odr_bits = 0;
+	if (device & KMX61_ACC)
+		odr_bits |= lodr_bits << KMX61_ACC_ODR_SHIFT;
+	if (device & KMX61_MAG)
+		odr_bits |= lodr_bits << KMX61_MAG_ODR_SHIFT;
+
+	ret = i2c_smbus_write_byte_data(data->client, KMX61_REG_ODCNTL,
+					odr_bits);
+	if (ret < 0)
+		return ret;
+
+	return kmx61_set_mode(data, mode, KMX61_ACC | KMX61_MAG, true);
+}
+
+static int kmx61_get_odr(struct kmx61_data *data, int *val, int *val2,
+			 u8 device)
+{	int i;
+	u8 lodr_bits;
+
+	if (device & KMX61_ACC)
+		lodr_bits = (data->odr_bits >> KMX61_ACC_ODR_SHIFT) &
+			     KMX61_ACC_ODR_MASK;
+	else if (device & KMX61_MAG)
+		lodr_bits = (data->odr_bits >> KMX61_MAG_ODR_SHIFT) &
+			     KMX61_MAG_ODR_MASK;
+	else
+		return -EINVAL;
+
+	for (i = 0; i < ARRAY_SIZE(kmx61_samp_freq_table); i++)
+		if (lodr_bits == kmx61_samp_freq_table[i].odr_bits) {
+			*val = kmx61_samp_freq_table[i].val;
+			*val2 = kmx61_samp_freq_table[i].val2;
+			return 0;
+		}
+	return -EINVAL;
+}
+
+static int kmx61_set_range(struct kmx61_data *data, u8 range)
+{
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_CTRL1);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error reading reg_ctrl1\n");
+		return ret;
+	}
+
+	ret &= ~KMX61_REG_CTRL1_GSEL_MASK;
+	ret |= range & KMX61_REG_CTRL1_GSEL_MASK;
+
+	ret = i2c_smbus_write_byte_data(data->client, KMX61_REG_CTRL1, ret);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error writing reg_ctrl1\n");
+		return ret;
+	}
+
+	data->range = range;
+
+	return 0;
+}
+
+static int kmx61_set_scale(struct kmx61_data *data, u16 uscale)
+{
+	int ret, i;
+	u8  mode;
+
+	for (i = 0; i < ARRAY_SIZE(kmx61_uscale_table); i++) {
+		if (kmx61_uscale_table[i] == uscale) {
+			ret = kmx61_get_mode(data, &mode,
+					     KMX61_ACC | KMX61_MAG);
+			if (ret < 0)
+				return ret;
+
+			ret = kmx61_set_mode(data, KMX61_ALL_STBY,
+					     KMX61_ACC | KMX61_MAG, true);
+			if (ret < 0)
+				return ret;
+
+			ret = kmx61_set_range(data, i);
+			if (ret < 0)
+				return ret;
+
+			return  kmx61_set_mode(data, mode,
+					       KMX61_ACC | KMX61_MAG, true);
+		}
+	}
+	return -EINVAL;
+}
+
+static int kmx61_chip_init(struct kmx61_data *data)
+{
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_WHO_AM_I);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error reading who_am_i\n");
+		return ret;
+	}
+
+	if (ret != KMX61_CHIP_ID) {
+		dev_err(&data->client->dev,
+			"Wrong chip id, got %x expected %x\n",
+			 ret, KMX61_CHIP_ID);
+		return -EINVAL;
+	}
+
+	/* set accel 12bit, 4g range */
+	ret = kmx61_set_range(data, KMX61_RANGE_4G);
+	if (ret < 0)
+		return ret;
+
+	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_ODCNTL);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error reading reg_odcntl\n");
+		return ret;
+	}
+	data->odr_bits = ret;
+
+	/* set acc/magn to OPERATION mode */
+	ret = kmx61_set_mode(data, 0, KMX61_ACC | KMX61_MAG, true);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int kmx61_read_measurement(struct kmx61_data *data, u8 base, u8 offset)
+{
+	int ret;
+	u8 reg = base + offset * 2;
+
+	ret = i2c_smbus_read_word_data(data->client, reg);
+	if (ret < 0)
+		dev_err(&data->client->dev, "failed to read reg at %x\n", reg);
+
+	return ret;
+}
+
+static int kmx61_read_raw(struct iio_dev *indio_dev,
+			  struct iio_chan_spec const *chan, int *val,
+			  int *val2, long mask)
+{
+	int ret;
+	u8 base_reg;
+	struct kmx61_data *data = kmx61_get_data(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		switch (chan->type) {
+		case IIO_ACCEL:
+			base_reg = KMX61_ACC_XOUT_L;
+			break;
+		case IIO_MAGN:
+			base_reg = KMX61_MAG_XOUT_L;
+			break;
+		default:
+			return -EINVAL;
+		}
+		mutex_lock(&data->lock);
+
+		ret = kmx61_read_measurement(data, base_reg, chan->scan_index);
+		if (ret < 0) {
+			mutex_unlock(&data->lock);
+			return ret;
+		}
+		*val = sign_extend32(ret >> chan->scan_type.shift,
+				     chan->scan_type.realbits - 1);
+
+		mutex_unlock(&data->lock);
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		switch (chan->type) {
+		case IIO_ACCEL:
+			*val = 0;
+			*val2 = kmx61_uscale_table[data->range];
+			return IIO_VAL_INT_PLUS_MICRO;
+		case IIO_MAGN:
+			/* 14 bits res, 1465 microGauss per magn count */
+			*val = 0;
+			*val2 = 1465;
+			return IIO_VAL_INT_PLUS_MICRO;
+		default:
+			return -EINVAL;
+		}
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		if (chan->type != IIO_ACCEL && chan->type != IIO_MAGN)
+			return -EINVAL;
+
+		mutex_lock(&data->lock);
+		ret = kmx61_get_odr(data, val, val2, chan->address);
+		mutex_unlock(&data->lock);
+		if (ret)
+			return -EINVAL;
+		return IIO_VAL_INT_PLUS_MICRO;
+	}
+	return -EINVAL;
+}
+
+static int kmx61_write_raw(struct iio_dev *indio_dev,
+			   struct iio_chan_spec const *chan, int val,
+			   int val2, long mask)
+{
+	int ret;
+	struct kmx61_data *data = kmx61_get_data(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		if (chan->type != IIO_ACCEL && chan->type != IIO_MAGN)
+			return -EINVAL;
+
+		mutex_lock(&data->lock);
+		ret = kmx61_set_odr(data, val, val2, chan->address);
+		mutex_unlock(&data->lock);
+		return ret;
+	case IIO_CHAN_INFO_SCALE:
+		switch (chan->type) {
+		case IIO_ACCEL:
+			if (val != 0)
+				return -EINVAL;
+			mutex_lock(&data->lock);
+			ret = kmx61_set_scale(data, val2);
+			mutex_unlock(&data->lock);
+			return ret;
+		default:
+			return -EINVAL;
+		}
+	default:
+		return -EINVAL;
+	}
+}
+
+static const struct iio_info kmx61_acc_info = {
+	.driver_module		= THIS_MODULE,
+	.read_raw		= kmx61_read_raw,
+	.write_raw		= kmx61_write_raw,
+	.attrs			= &kmx61_acc_attribute_group,
+};
+
+static const struct iio_info kmx61_mag_info = {
+	.driver_module		= THIS_MODULE,
+	.read_raw		= kmx61_read_raw,
+	.write_raw		= kmx61_write_raw,
+	.attrs			= &kmx61_mag_attribute_group,
+};
+
+static struct iio_dev *kmx61_indiodev_setup(struct kmx61_data *data,
+					    const struct iio_info *info,
+					    const struct iio_chan_spec *chan,
+					    int num_channels,
+					    const char *name)
+{
+	struct iio_dev *indio_dev;
+
+	indio_dev = devm_iio_device_alloc(&data->client->dev, sizeof(data));
+	if (!indio_dev)
+		return ERR_PTR(-ENOMEM);
+
+	kmx61_set_data(indio_dev, data);
+
+	indio_dev->dev.parent = &data->client->dev;
+	indio_dev->channels = chan;
+	indio_dev->num_channels = num_channels;
+	indio_dev->name = name;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->info = info;
+
+	return indio_dev;
+}
+
+static int kmx61_probe(struct i2c_client *client,
+		       const struct i2c_device_id *id)
+{
+	int ret;
+	struct kmx61_data *data;
+	const char *name = NULL;
+
+	data = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, data);
+	data->client = client;
+
+	mutex_init(&data->lock);
+
+	data->acc_indio_dev =
+		kmx61_indiodev_setup(data, &kmx61_acc_info,
+				     kmx61_acc_channels,
+				     ARRAY_SIZE(kmx61_acc_channels),
+				     name);
+	if (IS_ERR(data->acc_indio_dev))
+		return PTR_ERR(data->acc_indio_dev);
+
+	data->mag_indio_dev =
+		kmx61_indiodev_setup(data, &kmx61_mag_info,
+				     kmx61_mag_channels,
+				     ARRAY_SIZE(kmx61_mag_channels),
+				     name);
+	if (IS_ERR(data->mag_indio_dev))
+		return PTR_ERR(data->mag_indio_dev);
+
+	ret = kmx61_chip_init(data);
+	if (ret < 0)
+		return ret;
+
+	ret = iio_device_register(data->acc_indio_dev);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed to register acc iio device\n");
+		goto err_chip_uninit;
+	}
+
+	ret = iio_device_register(data->mag_indio_dev);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed to register mag iio device\n");
+		goto err_iio_unregister;
+	}
+
+	return 0;
+
+err_iio_unregister:
+	iio_device_unregister(data->acc_indio_dev);
+err_chip_uninit:
+	kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);
+	return ret;
+}
+
+static int kmx61_remove(struct i2c_client *client)
+{
+	struct kmx61_data *data = i2c_get_clientdata(client);
+
+	iio_device_unregister(data->acc_indio_dev);
+	iio_device_unregister(data->mag_indio_dev);
+
+	mutex_lock(&data->lock);
+	kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);
+	mutex_unlock(&data->lock);
+
+	return 0;
+}
+
+static const struct i2c_device_id kmx61_id[] = {
+	{"kmx611021", 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, kmx61_id);
+
+static struct i2c_driver kmx61_driver = {
+	.driver = {
+		.name = KMX61_DRV_NAME,
+	},
+	.probe		= kmx61_probe,
+	.remove		= kmx61_remove,
+	.id_table	= kmx61_id,
+};
+
+module_i2c_driver(kmx61_driver);
+
+MODULE_AUTHOR("Daniel Baluta <daniel.baluta@intel.com>");
+MODULE_DESCRIPTION("KMX61 accelerometer/magnetometer driver");
+MODULE_LICENSE("GPL v2");

commit 3909a0713e19e75410c3ae2ea7dd1242af78b026
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Fri Dec 12 13:30:04 2014 +0000

    Revert "iio: imu: Add support for Kionix KMX61 sensor"
    
    The two halves of this part can run largely independently.  Hence
    a version 4 of this patch followed that reorganized things completely.
    
    This reverts commit d7d787d29148cde12958c2e3765ad3a55dc55eaf.

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
deleted file mode 100644
index f68b3ef1a575..000000000000
--- a/drivers/iio/imu/kmx61.c
+++ /dev/null
@@ -1,766 +0,0 @@
-/*
- * KMX61 - Kionix 6-axis Accelerometer/Magnetometer
- *
- * Copyright (c) 2014, Intel Corporation.
- *
- * This file is subject to the terms and conditions of version 2 of
- * the GNU General Public License.  See the file COPYING in the main
- * directory of this archive for more details.
- *
- * IIO driver for KMX61 (7-bit I2C slave address 0x0E or 0x0F).
- *
- * TODO: buffer, interrupt, thresholds, acpi, temperature sensor
- *
- */
-
-#include <linux/module.h>
-#include <linux/i2c.h>
-#include <linux/pm.h>
-#include <linux/pm_runtime.h>
-#include <linux/iio/iio.h>
-#include <linux/iio/sysfs.h>
-
-#define KMX61_DRV_NAME "kmx61"
-
-#define KMX61_REG_WHO_AM_I	0x00
-
-/*
- * three 16-bit accelerometer output registers for X/Y/Z axis
- * we use only XOUT_L as a base register, all other addresses
- * can be obtained by applying an offset and are provided here
- * only for clarity.
- */
-#define KMX61_ACC_XOUT_L	0x0A
-#define KMX61_ACC_XOUT_H	0x0B
-#define KMX61_ACC_YOUT_L	0x0C
-#define KMX61_ACC_YOUT_H	0x0D
-#define KMX61_ACC_ZOUT_L	0x0E
-#define KMX61_ACC_ZOUT_H	0x0F
-
-/*
- * one 16-bit temperature output register
- */
-#define KMX61_TEMP_L		0x10
-#define KMX61_TEMP_H		0x11
-
-/*
- * three 16-bit magnetometer output registers for X/Y/Z axis
- */
-#define KMX61_MAG_XOUT_L	0x12
-#define KMX61_MAG_XOUT_H	0x13
-#define KMX61_MAG_YOUT_L	0x14
-#define KMX61_MAG_YOUT_H	0x15
-#define KMX61_MAG_ZOUT_L	0x16
-#define KMX61_MAG_ZOUT_H	0x17
-
-#define KMX61_REG_ODCNTL	0x2C
-#define KMX61_REG_STBY		0x29
-#define KMX61_REG_CTRL1		0x2A
-
-#define KMX61_ACC_STBY_BIT	BIT(0)
-#define KMX61_MAG_STBY_BIT	BIT(1)
-#define KMX61_ACT_STBY_BIT	BIT(7)
-
-#define KMX61_ALL_STBY		(KMX61_ACC_STBY_BIT | KMX61_MAG_STBY_BIT)
-
-#define KMX61_REG_CTRL1_GSEL0_SHIFT	0
-#define KMX61_REG_CTRL1_GSEL1_SHIFT	1
-#define KMX61_REG_CTRL1_GSEL0_MASK	0x01
-#define KMX61_REG_CTRL1_GSEL1_MASK	0x02
-
-#define KMX61_REG_CTRL1_BIT_RES		BIT(4)
-
-#define KMX61_ACC_ODR_SHIFT	0
-#define KMX61_MAG_ODR_SHIFT	4
-#define KMX61_ACC_ODR_MASK	0x0F
-#define KMX61_MAG_ODR_MASK	0xF0
-
-#define KMX61_SLEEP_DELAY_MS	2000
-
-#define KMX61_CHIP_ID		0x12
-
-struct kmx61_data {
-	struct i2c_client *client;
-
-	/* serialize access to non-atomic ops, e.g set_mode */
-	struct mutex lock;
-	u8 range;
-	u8 odr_bits;
-
-	/* standby state */
-	u8 acc_stby;
-	u8 mag_stby;
-
-	/* power state */
-	bool acc_ps;
-	bool mag_ps;
-};
-
-enum kmx61_range {
-	KMX61_RANGE_2G,
-	KMX61_RANGE_4G,
-	KMX61_RANGE_8G,
-};
-
-enum kmx61_scan {
-	KMX61_SCAN_ACC_X,
-	KMX61_SCAN_ACC_Y,
-	KMX61_SCAN_ACC_Z,
-	KMX61_SCAN_TEMP,
-	KMX61_SCAN_MAG_X,
-	KMX61_SCAN_MAG_Y,
-	KMX61_SCAN_MAG_Z,
-};
-
-static const struct {
-	u16 uscale;
-	u8 gsel0;
-	u8 gsel1;
-} kmx61_scale_table[] = {
-	{9582, 0, 0},
-	{19163, 1, 0},
-	{38326, 0, 1},
-};
-
-/* KMX61 devices */
-#define KMX61_ACC	0x01
-#define KMX61_MAG	0x02
-
-static const struct {
-	int val;
-	int val2;
-	u8 odr_bits;
-} kmx61_samp_freq_table[] = { {12, 500000, 0x00},
-			{25, 0, 0x01},
-			{50, 0, 0x02},
-			{100, 0, 0x03},
-			{200, 0, 0x04},
-			{400, 0, 0x05},
-			{800, 0, 0x06},
-			{1600, 0, 0x07},
-			{0, 781000, 0x08},
-			{1, 563000, 0x09},
-			{3, 125000, 0x0A},
-			{6, 250000, 0x0B} };
-
-static IIO_CONST_ATTR(accel_scale_available, "0.009582 0.019163 0.038326");
-static IIO_CONST_ATTR(magn_scale_available, "0.001465");
-static IIO_CONST_ATTR_SAMP_FREQ_AVAIL(
-	"0.781000 1.563000 3.125000 6.250000 12.500000 25 50 100 200 400 800");
-
-static struct attribute *kmx61_attributes[] = {
-	&iio_const_attr_accel_scale_available.dev_attr.attr,
-	&iio_const_attr_magn_scale_available.dev_attr.attr,
-	&iio_const_attr_sampling_frequency_available.dev_attr.attr,
-	NULL,
-};
-
-static const struct attribute_group kmx61_attribute_group = {
-	.attrs = kmx61_attributes,
-};
-
-#define KMX61_ACC_CHAN(_axis, _index) { \
-	.type = IIO_ACCEL, \
-	.modified = 1, \
-	.channel2 = IIO_MOD_ ## _axis, \
-	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \
-	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) | \
-				BIT(IIO_CHAN_INFO_SAMP_FREQ), \
-	.address = KMX61_ACC, \
-	.scan_index = _index, \
-	.scan_type = { \
-		.sign = 's', \
-		.realbits = 12, \
-		.storagebits = 16, \
-		.shift = 4, \
-		.endianness = IIO_LE, \
-	}, \
-}
-
-#define KMX61_MAG_CHAN(_axis, _index) { \
-	.type = IIO_MAGN, \
-	.modified = 1, \
-	.channel2 = IIO_MOD_ ## _axis, \
-	.address = KMX61_MAG, \
-	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \
-	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) | \
-				BIT(IIO_CHAN_INFO_SAMP_FREQ), \
-	.scan_index = _index, \
-	.scan_type = { \
-		.sign = 's', \
-		.realbits = 14, \
-		.storagebits = 16, \
-		.shift = 2, \
-		.endianness = IIO_LE, \
-	}, \
-}
-
-static const struct iio_chan_spec kmx61_channels[] = {
-	KMX61_ACC_CHAN(X, KMX61_SCAN_ACC_X),
-	KMX61_ACC_CHAN(Y, KMX61_SCAN_ACC_Y),
-	KMX61_ACC_CHAN(Z, KMX61_SCAN_ACC_Z),
-	KMX61_MAG_CHAN(X, KMX61_SCAN_MAG_X),
-	KMX61_MAG_CHAN(Y, KMX61_SCAN_MAG_Y),
-	KMX61_MAG_CHAN(Z, KMX61_SCAN_MAG_Z),
-};
-
-static int kmx61_convert_freq_to_bit(int val, int val2)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(kmx61_samp_freq_table); i++)
-		if (val == kmx61_samp_freq_table[i].val &&
-		    val2 == kmx61_samp_freq_table[i].val2)
-			return kmx61_samp_freq_table[i].odr_bits;
-	return -EINVAL;
-}
-/**
- * kmx61_set_mode() - set KMX61 device operating mode
- * @data - kmx61 device private data pointer
- * @mode - bitmask, indicating operating mode for @device
- * @device - bitmask, indicating device for which @mode needs to be set
- * @update - update stby bits stored in device's private  @data
- *
- * For each sensor (accelerometer/magnetometer) there are two operating modes
- * STANDBY and OPERATION. Neither accel nor magn can be disabled independently
- * if they are both enabled. Internal sensors state is saved in acc_stby and
- * mag_stby members of driver's private @data.
- */
-static int kmx61_set_mode(struct kmx61_data *data, u8 mode, u8 device,
-			  bool update)
-{
-	int ret;
-	int acc_stby = -1, mag_stby = -1;
-
-	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_STBY);
-	if (ret < 0) {
-		dev_err(&data->client->dev, "Error reading reg_stby\n");
-		return ret;
-	}
-	if (device & KMX61_ACC) {
-		if (mode & KMX61_ACC_STBY_BIT) {
-			ret |= KMX61_ACC_STBY_BIT;
-			acc_stby = 1;
-		} else {
-			ret &= ~KMX61_ACC_STBY_BIT;
-			acc_stby = 0;
-		}
-	}
-
-	if (device & KMX61_MAG) {
-		if (mode & KMX61_MAG_STBY_BIT) {
-			ret |= KMX61_MAG_STBY_BIT;
-			mag_stby = 1;
-		} else {
-			ret &= ~KMX61_MAG_STBY_BIT;
-			mag_stby = 0;
-		}
-	}
-
-	ret = i2c_smbus_write_byte_data(data->client, KMX61_REG_STBY, ret);
-	if (ret < 0) {
-		dev_err(&data->client->dev, "Error writing reg_stby\n");
-		return ret;
-	}
-
-	if (acc_stby != -1 && update)
-		data->acc_stby = !!acc_stby;
-	if (mag_stby != -1 && update)
-		data->mag_stby = !!mag_stby;
-
-	return ret;
-}
-
-static int kmx61_get_mode(struct kmx61_data *data, u8 *mode, u8 device)
-{
-	int ret;
-
-	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_STBY);
-	if (ret < 0) {
-		dev_err(&data->client->dev, "Error reading reg_stby\n");
-		return ret;
-	}
-	*mode = 0;
-
-	if (device & KMX61_ACC) {
-		if (ret & KMX61_ACC_STBY_BIT)
-			*mode |= KMX61_ACC_STBY_BIT;
-		else
-			*mode &= ~KMX61_ACC_STBY_BIT;
-	}
-
-	if (device & KMX61_MAG) {
-		if (ret & KMX61_MAG_STBY_BIT)
-			*mode |= KMX61_MAG_STBY_BIT;
-		else
-			*mode &= ~KMX61_MAG_STBY_BIT;
-	}
-
-	return 0;
-}
-
-static int kmx61_set_odr(struct kmx61_data *data, int val, int val2, u8 device)
-{
-	int ret;
-	u8 mode;
-	int lodr_bits, odr_bits;
-
-	ret = kmx61_get_mode(data, &mode, KMX61_ACC | KMX61_MAG);
-	if (ret < 0)
-		return ret;
-
-	lodr_bits = kmx61_convert_freq_to_bit(val, val2);
-	if (lodr_bits < 0)
-		return lodr_bits;
-
-	/* To change ODR, accel and magn must be in STDBY */
-	ret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG,
-			     true);
-	if (ret < 0)
-		return ret;
-
-	odr_bits = 0;
-	if (device & KMX61_ACC)
-		odr_bits |= lodr_bits;
-	if (device & KMX61_MAG)
-		odr_bits |= (lodr_bits << KMX61_MAG_ODR_SHIFT);
-
-	ret = i2c_smbus_write_byte_data(data->client, KMX61_REG_ODCNTL,
-					odr_bits);
-	if (ret < 0)
-		return ret;
-
-	ret = kmx61_set_mode(data, mode, KMX61_ACC | KMX61_MAG, true);
-	if (ret < 0)
-		return ret;
-
-	data->odr_bits = lodr_bits;
-
-	return 0;
-}
-
-static
-int kmx61_get_odr(struct kmx61_data *data, int *val, int *val2, u8 device)
-{	int i;
-	u8 lodr_bits;
-
-	if (device & KMX61_ACC)
-		lodr_bits = (data->odr_bits >> KMX61_ACC_ODR_SHIFT) &
-			     KMX61_ACC_ODR_MASK;
-	else if (device & KMX61_MAG)
-		lodr_bits = (data->odr_bits >> KMX61_MAG_ODR_SHIFT) &
-			     KMX61_MAG_ODR_MASK;
-	else
-		return -EINVAL;
-
-	for (i = 0; i < ARRAY_SIZE(kmx61_samp_freq_table); i++)
-		if (lodr_bits == kmx61_samp_freq_table[i].odr_bits) {
-			*val = kmx61_samp_freq_table[i].val;
-			*val2 = kmx61_samp_freq_table[i].val2;
-			return 0;
-		}
-	return -EINVAL;
-}
-
-static int kmx61_set_range(struct kmx61_data *data, int range)
-{
-	int ret;
-
-	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_CTRL1);
-	if (ret < 0) {
-		dev_err(&data->client->dev, "Error reading reg_ctrl1\n");
-		return ret;
-	}
-
-	ret &= ~(KMX61_REG_CTRL1_GSEL0_MASK | KMX61_REG_CTRL1_GSEL1_MASK);
-	ret |= kmx61_scale_table[range].gsel0 << KMX61_REG_CTRL1_GSEL0_SHIFT;
-	ret |= kmx61_scale_table[range].gsel1 << KMX61_REG_CTRL1_GSEL1_SHIFT;
-
-	ret = i2c_smbus_write_byte_data(data->client, KMX61_REG_CTRL1, ret);
-	if (ret < 0) {
-		dev_err(&data->client->dev, "Error writing reg_ctrl1\n");
-		return ret;
-	}
-
-	data->range = range;
-
-	return 0;
-}
-
-static int kmx61_set_scale(struct kmx61_data *data, int uscale)
-{
-	int ret, i;
-	u8  mode;
-
-	for (i = 0; i < ARRAY_SIZE(kmx61_scale_table); i++) {
-		if (kmx61_scale_table[i].uscale == uscale) {
-			ret = kmx61_get_mode(data, &mode,
-					     KMX61_ACC | KMX61_MAG);
-			if (ret < 0)
-				return ret;
-
-			ret = kmx61_set_mode(data, KMX61_ALL_STBY,
-					     KMX61_ACC | KMX61_MAG, true);
-			if (ret < 0)
-				return ret;
-
-			ret = kmx61_set_range(data, i);
-			if (ret < 0)
-				return ret;
-
-			return  kmx61_set_mode(data, mode,
-					       KMX61_ACC | KMX61_MAG, true);
-		}
-	}
-	return -EINVAL;
-}
-
-static int kmx61_chip_init(struct kmx61_data *data)
-{
-	int ret;
-
-	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_WHO_AM_I);
-	if (ret < 0) {
-		dev_err(&data->client->dev, "Error reading who_am_i\n");
-		return ret;
-	}
-
-	if (ret != KMX61_CHIP_ID) {
-		dev_err(&data->client->dev,
-			"Wrong chip id, got %x expected %x\n",
-			 ret, KMX61_CHIP_ID);
-		return -EINVAL;
-	}
-
-	/* set accel 12bit, 4g range */
-	ret = kmx61_set_range(data, KMX61_RANGE_4G);
-	if (ret < 0)
-		return ret;
-
-	/* set acc/magn to OPERATION mode */
-	ret = kmx61_set_mode(data, 0, KMX61_ACC | KMX61_MAG, true);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-/**
- * kmx61_set_power_state() - set power state for kmx61 @device
- * @data - kmx61 device private pointer
- * @on - power state to be set for @device
- * @device - bitmask indicating device for which @on state needs to be set
- *
- * Notice that when ACC power state needs to be set to ON and MAG is in
- * OPERATION then we know that kmx61_runtime_resume was already called
- * so we must set ACC OPERATION mode here. The same happens when MAG power
- * state needs to be set to ON and ACC is in OPERATION.
- */
-static int kmx61_set_power_state(struct kmx61_data *data, bool on, u8 device)
-{
-#ifdef CONFIG_PM_RUNTIME
-	int ret;
-
-	if (device & KMX61_ACC) {
-		if (on && !data->acc_ps && !data->mag_stby)
-			kmx61_set_mode(data, 0, KMX61_ACC, true);
-		data->acc_ps = on;
-	}
-	if (device & KMX61_MAG) {
-		if (on && !data->mag_ps && !data->acc_stby)
-			kmx61_set_mode(data, 0, KMX61_MAG, true);
-		data->mag_ps = on;
-	}
-
-	if (on) {
-		ret = pm_runtime_get_sync(&data->client->dev);
-	} else {
-		pm_runtime_mark_last_busy(&data->client->dev);
-		ret = pm_runtime_put_autosuspend(&data->client->dev);
-	}
-	if (ret < 0) {
-		dev_err(&data->client->dev,
-			"Failed: kmx61_set_power_state for %d, ret %d\n",
-			on, ret);
-		return ret;
-	}
-#endif
-	return 0;
-}
-
-static int kmx61_read_measurement(struct kmx61_data *data, int base, int offset)
-{
-	int ret;
-	u8 reg = base + offset * 2;
-
-	ret = i2c_smbus_read_word_data(data->client, reg);
-	if (ret < 0) {
-		dev_err(&data->client->dev, "failed to read reg at %x\n", reg);
-		return ret;
-	}
-
-	return ret;
-}
-
-static int kmx61_read_raw(struct iio_dev *indio_dev,
-			      struct iio_chan_spec const *chan, int *val,
-			      int *val2, long mask)
-{
-	struct kmx61_data *data = iio_priv(indio_dev);
-	int ret;
-	u8 base_reg;
-
-	switch (mask) {
-	case IIO_CHAN_INFO_RAW:
-		switch (chan->type) {
-		case IIO_ACCEL:
-		case IIO_MAGN:
-			base_reg = KMX61_ACC_XOUT_L;
-			break;
-		default:
-			return -EINVAL;
-		}
-		mutex_lock(&data->lock);
-
-		kmx61_set_power_state(data, true, chan->address);
-		ret = kmx61_read_measurement(data, base_reg, chan->scan_index);
-		if (ret < 0) {
-			kmx61_set_power_state(data, false, chan->address);
-			mutex_unlock(&data->lock);
-			return ret;
-		}
-		*val = sign_extend32(ret >> chan->scan_type.shift,
-				     chan->scan_type.realbits - 1);
-		kmx61_set_power_state(data, false, chan->address);
-
-		mutex_unlock(&data->lock);
-		return IIO_VAL_INT;
-	case IIO_CHAN_INFO_SCALE:
-		switch (chan->type) {
-		case IIO_ACCEL:
-			*val = 0;
-			*val2 = kmx61_scale_table[data->range].uscale;
-			return IIO_VAL_INT_PLUS_MICRO;
-		case IIO_MAGN:
-			/* 14 bits res, 1465 microGauss per magn count */
-			*val = 0;
-			*val2 = 1465;
-			return IIO_VAL_INT_PLUS_MICRO;
-		default:
-			return -EINVAL;
-		}
-	case IIO_CHAN_INFO_SAMP_FREQ:
-		if (chan->type != IIO_ACCEL && chan->type != IIO_MAGN)
-			return -EINVAL;
-
-		mutex_lock(&data->lock);
-		ret = kmx61_get_odr(data, val, val2, chan->address);
-		mutex_unlock(&data->lock);
-		if (ret)
-			return -EINVAL;
-		return IIO_VAL_INT_PLUS_MICRO;
-	}
-	return -EINVAL;
-}
-
-static int kmx61_write_raw(struct iio_dev *indio_dev,
-			       struct iio_chan_spec const *chan, int val,
-			       int val2, long mask)
-{
-	struct kmx61_data *data = iio_priv(indio_dev);
-	int ret;
-
-	switch (mask) {
-	case IIO_CHAN_INFO_SAMP_FREQ:
-		if (chan->type != IIO_ACCEL && chan->type != IIO_MAGN)
-			return -EINVAL;
-
-		mutex_lock(&data->lock);
-		ret = kmx61_set_odr(data, val, val2, chan->address);
-		mutex_unlock(&data->lock);
-		return ret;
-	case IIO_CHAN_INFO_SCALE:
-		switch (chan->type) {
-		case IIO_ACCEL:
-			if (val != 0)
-				return -EINVAL;
-			mutex_lock(&data->lock);
-			ret = kmx61_set_scale(data, val2);
-			mutex_unlock(&data->lock);
-			return ret;
-		default:
-			return -EINVAL;
-		}
-		return ret;
-	default:
-		return -EINVAL;
-	}
-	return ret;
-}
-
-static const struct iio_info kmx61_info = {
-	.driver_module		= THIS_MODULE,
-	.read_raw		= kmx61_read_raw,
-	.write_raw		= kmx61_write_raw,
-	.attrs			= &kmx61_attribute_group,
-};
-
-static int kmx61_probe(struct i2c_client *client,
-		       const struct i2c_device_id *id)
-{
-	struct kmx61_data *data;
-	struct iio_dev *indio_dev;
-	int ret;
-	const char *name = NULL;
-
-	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));
-	if (!indio_dev)
-		return -ENOMEM;
-
-	data = iio_priv(indio_dev);
-	i2c_set_clientdata(client, indio_dev);
-	data->client = client;
-
-	if (id)
-		name = id->name;
-
-	indio_dev->dev.parent = &client->dev;
-	indio_dev->channels = kmx61_channels;
-	indio_dev->num_channels = ARRAY_SIZE(kmx61_channels);
-	indio_dev->name = name;
-	indio_dev->modes = INDIO_DIRECT_MODE;
-	indio_dev->info = &kmx61_info;
-
-	mutex_init(&data->lock);
-
-	ret = kmx61_chip_init(data);
-	if (ret < 0)
-		return ret;
-
-	ret = iio_device_register(indio_dev);
-	if (ret < 0) {
-		dev_err(&client->dev, "Failed to register iio device\n");
-		goto err_iio_device_register;
-	}
-
-	ret = pm_runtime_set_active(&client->dev);
-	if (ret < 0)
-		goto err_pm_runtime_set_active;
-
-	pm_runtime_enable(&client->dev);
-	pm_runtime_set_autosuspend_delay(&client->dev, KMX61_SLEEP_DELAY_MS);
-	pm_runtime_use_autosuspend(&client->dev);
-
-	return 0;
-
-err_pm_runtime_set_active:
-	iio_device_unregister(indio_dev);
-err_iio_device_register:
-	kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);
-	return ret;
-}
-
-static int kmx61_remove(struct i2c_client *client)
-{
-	struct iio_dev *indio_dev = i2c_get_clientdata(client);
-	struct kmx61_data *data = iio_priv(indio_dev);
-	int ret;
-
-	pm_runtime_disable(&client->dev);
-	pm_runtime_set_suspended(&client->dev);
-	pm_runtime_put_noidle(&client->dev);
-
-	iio_device_unregister(indio_dev);
-
-	mutex_lock(&data->lock);
-	ret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);
-	mutex_unlock(&data->lock);
-
-	return ret;
-}
-
-#ifdef CONFIG_PM_SLEEP
-static int kmx61_suspend(struct device *dev)
-{
-	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
-	struct kmx61_data *data = iio_priv(indio_dev);
-	int ret;
-
-	mutex_lock(&data->lock);
-	ret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG,
-			     false);
-	mutex_unlock(&data->lock);
-
-	return ret;
-}
-
-static int kmx61_resume(struct device *dev)
-{
-	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
-	struct kmx61_data *data = iio_priv(indio_dev);
-	u8 stby = 0;
-
-	if (data->acc_stby)
-		stby |= KMX61_ACC_STBY_BIT;
-	if (data->mag_stby)
-		stby |= KMX61_MAG_STBY_BIT;
-
-	return kmx61_set_mode(data, stby, KMX61_ACC | KMX61_MAG, true);
-}
-#endif
-
-#ifdef CONFIG_PM_RUNTIME
-static int kmx61_runtime_suspend(struct device *dev)
-{
-	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
-	struct kmx61_data *data = iio_priv(indio_dev);
-	int ret;
-
-	mutex_lock(&data->lock);
-	ret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);
-	mutex_unlock(&data->lock);
-
-	return ret;
-}
-
-static int kmx61_runtime_resume(struct device *dev)
-{
-	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
-	struct kmx61_data *data = iio_priv(indio_dev);
-	u8 stby = 0;
-
-	if (!data->acc_ps)
-		stby |= KMX61_ACC_STBY_BIT;
-	if (!data->mag_ps)
-		stby |= KMX61_MAG_STBY_BIT;
-
-	return kmx61_set_mode(data, stby, KMX61_ACC | KMX61_MAG, true);
-}
-#endif
-
-static const struct dev_pm_ops kmx61_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(kmx61_suspend, kmx61_resume)
-	SET_RUNTIME_PM_OPS(kmx61_runtime_suspend, kmx61_runtime_resume, NULL)
-};
-
-static const struct i2c_device_id kmx61_id[] = {
-	{"kmx611021", 0},
-	{}
-};
-
-MODULE_DEVICE_TABLE(i2c, kmx61_id);
-
-static struct i2c_driver kmx61_driver = {
-	.driver = {
-		.name = KMX61_DRV_NAME,
-		.pm = &kmx61_pm_ops,
-	},
-	.probe		= kmx61_probe,
-	.remove		= kmx61_remove,
-	.id_table	= kmx61_id,
-};
-
-module_i2c_driver(kmx61_driver);
-
-MODULE_AUTHOR("Daniel Baluta <daniel.baluta@intel.com>");
-MODULE_DESCRIPTION("KMX61 accelerometer/magnetometer driver");
-MODULE_LICENSE("GPL v2");

commit d7d787d29148cde12958c2e3765ad3a55dc55eaf
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Tue Nov 18 18:47:55 2014 +0200

    iio: imu: Add support for Kionix KMX61 sensor
    
    Minimal implementation for KMX61 6-axis accelerometer/magnetometer. It exports
    raw accel/magn readings together with scale and sampling frequency.
    
    Datasheet will be available at:
    http://www.kionix.com/6-axis-accelerometer-magnetometer/kmx61
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/kmx61.c b/drivers/iio/imu/kmx61.c
new file mode 100644
index 000000000000..f68b3ef1a575
--- /dev/null
+++ b/drivers/iio/imu/kmx61.c
@@ -0,0 +1,766 @@
+/*
+ * KMX61 - Kionix 6-axis Accelerometer/Magnetometer
+ *
+ * Copyright (c) 2014, Intel Corporation.
+ *
+ * This file is subject to the terms and conditions of version 2 of
+ * the GNU General Public License.  See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ * IIO driver for KMX61 (7-bit I2C slave address 0x0E or 0x0F).
+ *
+ * TODO: buffer, interrupt, thresholds, acpi, temperature sensor
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/pm.h>
+#include <linux/pm_runtime.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+
+#define KMX61_DRV_NAME "kmx61"
+
+#define KMX61_REG_WHO_AM_I	0x00
+
+/*
+ * three 16-bit accelerometer output registers for X/Y/Z axis
+ * we use only XOUT_L as a base register, all other addresses
+ * can be obtained by applying an offset and are provided here
+ * only for clarity.
+ */
+#define KMX61_ACC_XOUT_L	0x0A
+#define KMX61_ACC_XOUT_H	0x0B
+#define KMX61_ACC_YOUT_L	0x0C
+#define KMX61_ACC_YOUT_H	0x0D
+#define KMX61_ACC_ZOUT_L	0x0E
+#define KMX61_ACC_ZOUT_H	0x0F
+
+/*
+ * one 16-bit temperature output register
+ */
+#define KMX61_TEMP_L		0x10
+#define KMX61_TEMP_H		0x11
+
+/*
+ * three 16-bit magnetometer output registers for X/Y/Z axis
+ */
+#define KMX61_MAG_XOUT_L	0x12
+#define KMX61_MAG_XOUT_H	0x13
+#define KMX61_MAG_YOUT_L	0x14
+#define KMX61_MAG_YOUT_H	0x15
+#define KMX61_MAG_ZOUT_L	0x16
+#define KMX61_MAG_ZOUT_H	0x17
+
+#define KMX61_REG_ODCNTL	0x2C
+#define KMX61_REG_STBY		0x29
+#define KMX61_REG_CTRL1		0x2A
+
+#define KMX61_ACC_STBY_BIT	BIT(0)
+#define KMX61_MAG_STBY_BIT	BIT(1)
+#define KMX61_ACT_STBY_BIT	BIT(7)
+
+#define KMX61_ALL_STBY		(KMX61_ACC_STBY_BIT | KMX61_MAG_STBY_BIT)
+
+#define KMX61_REG_CTRL1_GSEL0_SHIFT	0
+#define KMX61_REG_CTRL1_GSEL1_SHIFT	1
+#define KMX61_REG_CTRL1_GSEL0_MASK	0x01
+#define KMX61_REG_CTRL1_GSEL1_MASK	0x02
+
+#define KMX61_REG_CTRL1_BIT_RES		BIT(4)
+
+#define KMX61_ACC_ODR_SHIFT	0
+#define KMX61_MAG_ODR_SHIFT	4
+#define KMX61_ACC_ODR_MASK	0x0F
+#define KMX61_MAG_ODR_MASK	0xF0
+
+#define KMX61_SLEEP_DELAY_MS	2000
+
+#define KMX61_CHIP_ID		0x12
+
+struct kmx61_data {
+	struct i2c_client *client;
+
+	/* serialize access to non-atomic ops, e.g set_mode */
+	struct mutex lock;
+	u8 range;
+	u8 odr_bits;
+
+	/* standby state */
+	u8 acc_stby;
+	u8 mag_stby;
+
+	/* power state */
+	bool acc_ps;
+	bool mag_ps;
+};
+
+enum kmx61_range {
+	KMX61_RANGE_2G,
+	KMX61_RANGE_4G,
+	KMX61_RANGE_8G,
+};
+
+enum kmx61_scan {
+	KMX61_SCAN_ACC_X,
+	KMX61_SCAN_ACC_Y,
+	KMX61_SCAN_ACC_Z,
+	KMX61_SCAN_TEMP,
+	KMX61_SCAN_MAG_X,
+	KMX61_SCAN_MAG_Y,
+	KMX61_SCAN_MAG_Z,
+};
+
+static const struct {
+	u16 uscale;
+	u8 gsel0;
+	u8 gsel1;
+} kmx61_scale_table[] = {
+	{9582, 0, 0},
+	{19163, 1, 0},
+	{38326, 0, 1},
+};
+
+/* KMX61 devices */
+#define KMX61_ACC	0x01
+#define KMX61_MAG	0x02
+
+static const struct {
+	int val;
+	int val2;
+	u8 odr_bits;
+} kmx61_samp_freq_table[] = { {12, 500000, 0x00},
+			{25, 0, 0x01},
+			{50, 0, 0x02},
+			{100, 0, 0x03},
+			{200, 0, 0x04},
+			{400, 0, 0x05},
+			{800, 0, 0x06},
+			{1600, 0, 0x07},
+			{0, 781000, 0x08},
+			{1, 563000, 0x09},
+			{3, 125000, 0x0A},
+			{6, 250000, 0x0B} };
+
+static IIO_CONST_ATTR(accel_scale_available, "0.009582 0.019163 0.038326");
+static IIO_CONST_ATTR(magn_scale_available, "0.001465");
+static IIO_CONST_ATTR_SAMP_FREQ_AVAIL(
+	"0.781000 1.563000 3.125000 6.250000 12.500000 25 50 100 200 400 800");
+
+static struct attribute *kmx61_attributes[] = {
+	&iio_const_attr_accel_scale_available.dev_attr.attr,
+	&iio_const_attr_magn_scale_available.dev_attr.attr,
+	&iio_const_attr_sampling_frequency_available.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group kmx61_attribute_group = {
+	.attrs = kmx61_attributes,
+};
+
+#define KMX61_ACC_CHAN(_axis, _index) { \
+	.type = IIO_ACCEL, \
+	.modified = 1, \
+	.channel2 = IIO_MOD_ ## _axis, \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \
+	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) | \
+				BIT(IIO_CHAN_INFO_SAMP_FREQ), \
+	.address = KMX61_ACC, \
+	.scan_index = _index, \
+	.scan_type = { \
+		.sign = 's', \
+		.realbits = 12, \
+		.storagebits = 16, \
+		.shift = 4, \
+		.endianness = IIO_LE, \
+	}, \
+}
+
+#define KMX61_MAG_CHAN(_axis, _index) { \
+	.type = IIO_MAGN, \
+	.modified = 1, \
+	.channel2 = IIO_MOD_ ## _axis, \
+	.address = KMX61_MAG, \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \
+	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) | \
+				BIT(IIO_CHAN_INFO_SAMP_FREQ), \
+	.scan_index = _index, \
+	.scan_type = { \
+		.sign = 's', \
+		.realbits = 14, \
+		.storagebits = 16, \
+		.shift = 2, \
+		.endianness = IIO_LE, \
+	}, \
+}
+
+static const struct iio_chan_spec kmx61_channels[] = {
+	KMX61_ACC_CHAN(X, KMX61_SCAN_ACC_X),
+	KMX61_ACC_CHAN(Y, KMX61_SCAN_ACC_Y),
+	KMX61_ACC_CHAN(Z, KMX61_SCAN_ACC_Z),
+	KMX61_MAG_CHAN(X, KMX61_SCAN_MAG_X),
+	KMX61_MAG_CHAN(Y, KMX61_SCAN_MAG_Y),
+	KMX61_MAG_CHAN(Z, KMX61_SCAN_MAG_Z),
+};
+
+static int kmx61_convert_freq_to_bit(int val, int val2)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(kmx61_samp_freq_table); i++)
+		if (val == kmx61_samp_freq_table[i].val &&
+		    val2 == kmx61_samp_freq_table[i].val2)
+			return kmx61_samp_freq_table[i].odr_bits;
+	return -EINVAL;
+}
+/**
+ * kmx61_set_mode() - set KMX61 device operating mode
+ * @data - kmx61 device private data pointer
+ * @mode - bitmask, indicating operating mode for @device
+ * @device - bitmask, indicating device for which @mode needs to be set
+ * @update - update stby bits stored in device's private  @data
+ *
+ * For each sensor (accelerometer/magnetometer) there are two operating modes
+ * STANDBY and OPERATION. Neither accel nor magn can be disabled independently
+ * if they are both enabled. Internal sensors state is saved in acc_stby and
+ * mag_stby members of driver's private @data.
+ */
+static int kmx61_set_mode(struct kmx61_data *data, u8 mode, u8 device,
+			  bool update)
+{
+	int ret;
+	int acc_stby = -1, mag_stby = -1;
+
+	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_STBY);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error reading reg_stby\n");
+		return ret;
+	}
+	if (device & KMX61_ACC) {
+		if (mode & KMX61_ACC_STBY_BIT) {
+			ret |= KMX61_ACC_STBY_BIT;
+			acc_stby = 1;
+		} else {
+			ret &= ~KMX61_ACC_STBY_BIT;
+			acc_stby = 0;
+		}
+	}
+
+	if (device & KMX61_MAG) {
+		if (mode & KMX61_MAG_STBY_BIT) {
+			ret |= KMX61_MAG_STBY_BIT;
+			mag_stby = 1;
+		} else {
+			ret &= ~KMX61_MAG_STBY_BIT;
+			mag_stby = 0;
+		}
+	}
+
+	ret = i2c_smbus_write_byte_data(data->client, KMX61_REG_STBY, ret);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error writing reg_stby\n");
+		return ret;
+	}
+
+	if (acc_stby != -1 && update)
+		data->acc_stby = !!acc_stby;
+	if (mag_stby != -1 && update)
+		data->mag_stby = !!mag_stby;
+
+	return ret;
+}
+
+static int kmx61_get_mode(struct kmx61_data *data, u8 *mode, u8 device)
+{
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_STBY);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error reading reg_stby\n");
+		return ret;
+	}
+	*mode = 0;
+
+	if (device & KMX61_ACC) {
+		if (ret & KMX61_ACC_STBY_BIT)
+			*mode |= KMX61_ACC_STBY_BIT;
+		else
+			*mode &= ~KMX61_ACC_STBY_BIT;
+	}
+
+	if (device & KMX61_MAG) {
+		if (ret & KMX61_MAG_STBY_BIT)
+			*mode |= KMX61_MAG_STBY_BIT;
+		else
+			*mode &= ~KMX61_MAG_STBY_BIT;
+	}
+
+	return 0;
+}
+
+static int kmx61_set_odr(struct kmx61_data *data, int val, int val2, u8 device)
+{
+	int ret;
+	u8 mode;
+	int lodr_bits, odr_bits;
+
+	ret = kmx61_get_mode(data, &mode, KMX61_ACC | KMX61_MAG);
+	if (ret < 0)
+		return ret;
+
+	lodr_bits = kmx61_convert_freq_to_bit(val, val2);
+	if (lodr_bits < 0)
+		return lodr_bits;
+
+	/* To change ODR, accel and magn must be in STDBY */
+	ret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG,
+			     true);
+	if (ret < 0)
+		return ret;
+
+	odr_bits = 0;
+	if (device & KMX61_ACC)
+		odr_bits |= lodr_bits;
+	if (device & KMX61_MAG)
+		odr_bits |= (lodr_bits << KMX61_MAG_ODR_SHIFT);
+
+	ret = i2c_smbus_write_byte_data(data->client, KMX61_REG_ODCNTL,
+					odr_bits);
+	if (ret < 0)
+		return ret;
+
+	ret = kmx61_set_mode(data, mode, KMX61_ACC | KMX61_MAG, true);
+	if (ret < 0)
+		return ret;
+
+	data->odr_bits = lodr_bits;
+
+	return 0;
+}
+
+static
+int kmx61_get_odr(struct kmx61_data *data, int *val, int *val2, u8 device)
+{	int i;
+	u8 lodr_bits;
+
+	if (device & KMX61_ACC)
+		lodr_bits = (data->odr_bits >> KMX61_ACC_ODR_SHIFT) &
+			     KMX61_ACC_ODR_MASK;
+	else if (device & KMX61_MAG)
+		lodr_bits = (data->odr_bits >> KMX61_MAG_ODR_SHIFT) &
+			     KMX61_MAG_ODR_MASK;
+	else
+		return -EINVAL;
+
+	for (i = 0; i < ARRAY_SIZE(kmx61_samp_freq_table); i++)
+		if (lodr_bits == kmx61_samp_freq_table[i].odr_bits) {
+			*val = kmx61_samp_freq_table[i].val;
+			*val2 = kmx61_samp_freq_table[i].val2;
+			return 0;
+		}
+	return -EINVAL;
+}
+
+static int kmx61_set_range(struct kmx61_data *data, int range)
+{
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_CTRL1);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error reading reg_ctrl1\n");
+		return ret;
+	}
+
+	ret &= ~(KMX61_REG_CTRL1_GSEL0_MASK | KMX61_REG_CTRL1_GSEL1_MASK);
+	ret |= kmx61_scale_table[range].gsel0 << KMX61_REG_CTRL1_GSEL0_SHIFT;
+	ret |= kmx61_scale_table[range].gsel1 << KMX61_REG_CTRL1_GSEL1_SHIFT;
+
+	ret = i2c_smbus_write_byte_data(data->client, KMX61_REG_CTRL1, ret);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error writing reg_ctrl1\n");
+		return ret;
+	}
+
+	data->range = range;
+
+	return 0;
+}
+
+static int kmx61_set_scale(struct kmx61_data *data, int uscale)
+{
+	int ret, i;
+	u8  mode;
+
+	for (i = 0; i < ARRAY_SIZE(kmx61_scale_table); i++) {
+		if (kmx61_scale_table[i].uscale == uscale) {
+			ret = kmx61_get_mode(data, &mode,
+					     KMX61_ACC | KMX61_MAG);
+			if (ret < 0)
+				return ret;
+
+			ret = kmx61_set_mode(data, KMX61_ALL_STBY,
+					     KMX61_ACC | KMX61_MAG, true);
+			if (ret < 0)
+				return ret;
+
+			ret = kmx61_set_range(data, i);
+			if (ret < 0)
+				return ret;
+
+			return  kmx61_set_mode(data, mode,
+					       KMX61_ACC | KMX61_MAG, true);
+		}
+	}
+	return -EINVAL;
+}
+
+static int kmx61_chip_init(struct kmx61_data *data)
+{
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(data->client, KMX61_REG_WHO_AM_I);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error reading who_am_i\n");
+		return ret;
+	}
+
+	if (ret != KMX61_CHIP_ID) {
+		dev_err(&data->client->dev,
+			"Wrong chip id, got %x expected %x\n",
+			 ret, KMX61_CHIP_ID);
+		return -EINVAL;
+	}
+
+	/* set accel 12bit, 4g range */
+	ret = kmx61_set_range(data, KMX61_RANGE_4G);
+	if (ret < 0)
+		return ret;
+
+	/* set acc/magn to OPERATION mode */
+	ret = kmx61_set_mode(data, 0, KMX61_ACC | KMX61_MAG, true);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+/**
+ * kmx61_set_power_state() - set power state for kmx61 @device
+ * @data - kmx61 device private pointer
+ * @on - power state to be set for @device
+ * @device - bitmask indicating device for which @on state needs to be set
+ *
+ * Notice that when ACC power state needs to be set to ON and MAG is in
+ * OPERATION then we know that kmx61_runtime_resume was already called
+ * so we must set ACC OPERATION mode here. The same happens when MAG power
+ * state needs to be set to ON and ACC is in OPERATION.
+ */
+static int kmx61_set_power_state(struct kmx61_data *data, bool on, u8 device)
+{
+#ifdef CONFIG_PM_RUNTIME
+	int ret;
+
+	if (device & KMX61_ACC) {
+		if (on && !data->acc_ps && !data->mag_stby)
+			kmx61_set_mode(data, 0, KMX61_ACC, true);
+		data->acc_ps = on;
+	}
+	if (device & KMX61_MAG) {
+		if (on && !data->mag_ps && !data->acc_stby)
+			kmx61_set_mode(data, 0, KMX61_MAG, true);
+		data->mag_ps = on;
+	}
+
+	if (on) {
+		ret = pm_runtime_get_sync(&data->client->dev);
+	} else {
+		pm_runtime_mark_last_busy(&data->client->dev);
+		ret = pm_runtime_put_autosuspend(&data->client->dev);
+	}
+	if (ret < 0) {
+		dev_err(&data->client->dev,
+			"Failed: kmx61_set_power_state for %d, ret %d\n",
+			on, ret);
+		return ret;
+	}
+#endif
+	return 0;
+}
+
+static int kmx61_read_measurement(struct kmx61_data *data, int base, int offset)
+{
+	int ret;
+	u8 reg = base + offset * 2;
+
+	ret = i2c_smbus_read_word_data(data->client, reg);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "failed to read reg at %x\n", reg);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int kmx61_read_raw(struct iio_dev *indio_dev,
+			      struct iio_chan_spec const *chan, int *val,
+			      int *val2, long mask)
+{
+	struct kmx61_data *data = iio_priv(indio_dev);
+	int ret;
+	u8 base_reg;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		switch (chan->type) {
+		case IIO_ACCEL:
+		case IIO_MAGN:
+			base_reg = KMX61_ACC_XOUT_L;
+			break;
+		default:
+			return -EINVAL;
+		}
+		mutex_lock(&data->lock);
+
+		kmx61_set_power_state(data, true, chan->address);
+		ret = kmx61_read_measurement(data, base_reg, chan->scan_index);
+		if (ret < 0) {
+			kmx61_set_power_state(data, false, chan->address);
+			mutex_unlock(&data->lock);
+			return ret;
+		}
+		*val = sign_extend32(ret >> chan->scan_type.shift,
+				     chan->scan_type.realbits - 1);
+		kmx61_set_power_state(data, false, chan->address);
+
+		mutex_unlock(&data->lock);
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		switch (chan->type) {
+		case IIO_ACCEL:
+			*val = 0;
+			*val2 = kmx61_scale_table[data->range].uscale;
+			return IIO_VAL_INT_PLUS_MICRO;
+		case IIO_MAGN:
+			/* 14 bits res, 1465 microGauss per magn count */
+			*val = 0;
+			*val2 = 1465;
+			return IIO_VAL_INT_PLUS_MICRO;
+		default:
+			return -EINVAL;
+		}
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		if (chan->type != IIO_ACCEL && chan->type != IIO_MAGN)
+			return -EINVAL;
+
+		mutex_lock(&data->lock);
+		ret = kmx61_get_odr(data, val, val2, chan->address);
+		mutex_unlock(&data->lock);
+		if (ret)
+			return -EINVAL;
+		return IIO_VAL_INT_PLUS_MICRO;
+	}
+	return -EINVAL;
+}
+
+static int kmx61_write_raw(struct iio_dev *indio_dev,
+			       struct iio_chan_spec const *chan, int val,
+			       int val2, long mask)
+{
+	struct kmx61_data *data = iio_priv(indio_dev);
+	int ret;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		if (chan->type != IIO_ACCEL && chan->type != IIO_MAGN)
+			return -EINVAL;
+
+		mutex_lock(&data->lock);
+		ret = kmx61_set_odr(data, val, val2, chan->address);
+		mutex_unlock(&data->lock);
+		return ret;
+	case IIO_CHAN_INFO_SCALE:
+		switch (chan->type) {
+		case IIO_ACCEL:
+			if (val != 0)
+				return -EINVAL;
+			mutex_lock(&data->lock);
+			ret = kmx61_set_scale(data, val2);
+			mutex_unlock(&data->lock);
+			return ret;
+		default:
+			return -EINVAL;
+		}
+		return ret;
+	default:
+		return -EINVAL;
+	}
+	return ret;
+}
+
+static const struct iio_info kmx61_info = {
+	.driver_module		= THIS_MODULE,
+	.read_raw		= kmx61_read_raw,
+	.write_raw		= kmx61_write_raw,
+	.attrs			= &kmx61_attribute_group,
+};
+
+static int kmx61_probe(struct i2c_client *client,
+		       const struct i2c_device_id *id)
+{
+	struct kmx61_data *data;
+	struct iio_dev *indio_dev;
+	int ret;
+	const char *name = NULL;
+
+	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));
+	if (!indio_dev)
+		return -ENOMEM;
+
+	data = iio_priv(indio_dev);
+	i2c_set_clientdata(client, indio_dev);
+	data->client = client;
+
+	if (id)
+		name = id->name;
+
+	indio_dev->dev.parent = &client->dev;
+	indio_dev->channels = kmx61_channels;
+	indio_dev->num_channels = ARRAY_SIZE(kmx61_channels);
+	indio_dev->name = name;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->info = &kmx61_info;
+
+	mutex_init(&data->lock);
+
+	ret = kmx61_chip_init(data);
+	if (ret < 0)
+		return ret;
+
+	ret = iio_device_register(indio_dev);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed to register iio device\n");
+		goto err_iio_device_register;
+	}
+
+	ret = pm_runtime_set_active(&client->dev);
+	if (ret < 0)
+		goto err_pm_runtime_set_active;
+
+	pm_runtime_enable(&client->dev);
+	pm_runtime_set_autosuspend_delay(&client->dev, KMX61_SLEEP_DELAY_MS);
+	pm_runtime_use_autosuspend(&client->dev);
+
+	return 0;
+
+err_pm_runtime_set_active:
+	iio_device_unregister(indio_dev);
+err_iio_device_register:
+	kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);
+	return ret;
+}
+
+static int kmx61_remove(struct i2c_client *client)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(client);
+	struct kmx61_data *data = iio_priv(indio_dev);
+	int ret;
+
+	pm_runtime_disable(&client->dev);
+	pm_runtime_set_suspended(&client->dev);
+	pm_runtime_put_noidle(&client->dev);
+
+	iio_device_unregister(indio_dev);
+
+	mutex_lock(&data->lock);
+	ret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);
+	mutex_unlock(&data->lock);
+
+	return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int kmx61_suspend(struct device *dev)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
+	struct kmx61_data *data = iio_priv(indio_dev);
+	int ret;
+
+	mutex_lock(&data->lock);
+	ret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG,
+			     false);
+	mutex_unlock(&data->lock);
+
+	return ret;
+}
+
+static int kmx61_resume(struct device *dev)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
+	struct kmx61_data *data = iio_priv(indio_dev);
+	u8 stby = 0;
+
+	if (data->acc_stby)
+		stby |= KMX61_ACC_STBY_BIT;
+	if (data->mag_stby)
+		stby |= KMX61_MAG_STBY_BIT;
+
+	return kmx61_set_mode(data, stby, KMX61_ACC | KMX61_MAG, true);
+}
+#endif
+
+#ifdef CONFIG_PM_RUNTIME
+static int kmx61_runtime_suspend(struct device *dev)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
+	struct kmx61_data *data = iio_priv(indio_dev);
+	int ret;
+
+	mutex_lock(&data->lock);
+	ret = kmx61_set_mode(data, KMX61_ALL_STBY, KMX61_ACC | KMX61_MAG, true);
+	mutex_unlock(&data->lock);
+
+	return ret;
+}
+
+static int kmx61_runtime_resume(struct device *dev)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
+	struct kmx61_data *data = iio_priv(indio_dev);
+	u8 stby = 0;
+
+	if (!data->acc_ps)
+		stby |= KMX61_ACC_STBY_BIT;
+	if (!data->mag_ps)
+		stby |= KMX61_MAG_STBY_BIT;
+
+	return kmx61_set_mode(data, stby, KMX61_ACC | KMX61_MAG, true);
+}
+#endif
+
+static const struct dev_pm_ops kmx61_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(kmx61_suspend, kmx61_resume)
+	SET_RUNTIME_PM_OPS(kmx61_runtime_suspend, kmx61_runtime_resume, NULL)
+};
+
+static const struct i2c_device_id kmx61_id[] = {
+	{"kmx611021", 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, kmx61_id);
+
+static struct i2c_driver kmx61_driver = {
+	.driver = {
+		.name = KMX61_DRV_NAME,
+		.pm = &kmx61_pm_ops,
+	},
+	.probe		= kmx61_probe,
+	.remove		= kmx61_remove,
+	.id_table	= kmx61_id,
+};
+
+module_i2c_driver(kmx61_driver);
+
+MODULE_AUTHOR("Daniel Baluta <daniel.baluta@intel.com>");
+MODULE_DESCRIPTION("KMX61 accelerometer/magnetometer driver");
+MODULE_LICENSE("GPL v2");
