commit 84e5ddd5c46ea3bf0cad670da32028994cad5936
Author: Robert Jones <rjones@gateworks.com>
Date:   Mon Oct 14 11:49:21 2019 -0700

    iio: imu: Add support for the FXOS8700 IMU
    
    FXOS8700CQ is a small, low-power, 3-axis linear accelerometer and 3-axis
    magnetometer combined into a single package. The device features a
    selectable I2C or point-to-point SPI serial interface with 14-bit
    accelerometer and 16-bit magnetometer ADC resolution along with
    smart-embedded functions.
    
    FXOS8700CQ has dynamically selectable accelerationfull-scale ranges of
    ±2 g/±4 g/±8 g and a fixed magnetic measurement range of ±1200 μT.
    Output data rates (ODR) from 1.563 Hz to 800 Hz are selectable by the user
    for each sensor. Interleaved magnetic and acceleration data is available
    at ODR rates of up to 400 Hz. FXOS8700CQ is available in a plastic QFN
    package and it is guaranteed to operate over the extended temperature
    range of –40 °C to +85 °C.
    
    TODO: Trigger and IRQ configuration support
    
    Datasheet:
      http://cache.freescale.com/files/sensors/doc/data_sheet/FXOS8700CQ.pdf
    
    Signed-off-by: Robert Jones <rjones@gateworks.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/fxos8700_i2c.c b/drivers/iio/imu/fxos8700_i2c.c
new file mode 100644
index 000000000000..3ceb76366313
--- /dev/null
+++ b/drivers/iio/imu/fxos8700_i2c.c
@@ -0,0 +1,71 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * FXOS8700 - NXP IMU, I2C bits
+ *
+ * 7-bit I2C slave address determined by SA1 and SA0 logic level
+ * inputs represented in the following table:
+ *      SA1  |  SA0  |  Slave Address
+ *      0    |  0    |  0x1E
+ *      0    |  1    |  0x1D
+ *      1    |  0    |  0x1C
+ *      1    |  1    |  0x1F
+ */
+#include <linux/acpi.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/regmap.h>
+
+#include "fxos8700.h"
+
+static int fxos8700_i2c_probe(struct i2c_client *client,
+			      const struct i2c_device_id *id)
+{
+	struct regmap *regmap;
+	const char *name = NULL;
+
+	regmap = devm_regmap_init_i2c(client, &fxos8700_regmap_config);
+	if (IS_ERR(regmap)) {
+		dev_err(&client->dev, "Failed to register i2c regmap %d\n",
+			(int)PTR_ERR(regmap));
+		return PTR_ERR(regmap);
+	}
+
+	if (id)
+		name = id->name;
+
+	return fxos8700_core_probe(&client->dev, regmap, name, false);
+}
+
+static const struct i2c_device_id fxos8700_i2c_id[] = {
+	{"fxos8700", 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, fxos8700_i2c_id);
+
+static const struct acpi_device_id fxos8700_acpi_match[] = {
+	{"FXOS8700", 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, fxos8700_acpi_match);
+
+static const struct of_device_id fxos8700_of_match[] = {
+	{ .compatible = "nxp,fxos8700" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, fxos8700_of_match);
+
+static struct i2c_driver fxos8700_i2c_driver = {
+	.driver = {
+		.name                   = "fxos8700_i2c",
+		.acpi_match_table       = ACPI_PTR(fxos8700_acpi_match),
+		.of_match_table         = fxos8700_of_match,
+	},
+	.probe          = fxos8700_i2c_probe,
+	.id_table       = fxos8700_i2c_id,
+};
+module_i2c_driver(fxos8700_i2c_driver);
+
+MODULE_AUTHOR("Robert Jones <rjones@gateworks.com>");
+MODULE_DESCRIPTION("FXOS8700 I2C driver");
+MODULE_LICENSE("GPL v2");
