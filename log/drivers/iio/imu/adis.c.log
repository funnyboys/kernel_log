commit b9c5eec725d67b548e4dfdc406d6ca2c6d30d1c2
Author: Nuno Sá <nuno.sa@analog.com>
Date:   Mon Apr 13 10:24:42 2020 +0200

    iio: adis: Add adis_update_bits() APIs
    
    This patch adds a `regmap_update_bits()` like API to the ADIS library.
    It provides locked and unlocked variant.
    
    Signed-off-by: Nuno Sá <nuno.sa@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index 2e7d0d337f8f..c539dfa3b8d3 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -223,6 +223,31 @@ int __adis_read_reg(struct adis *adis, unsigned int reg,
 	return ret;
 }
 EXPORT_SYMBOL_GPL(__adis_read_reg);
+/**
+ * __adis_update_bits_base() - ADIS Update bits function - Unlocked version
+ * @adis: The adis device
+ * @reg: The address of the lower of the two registers
+ * @mask: Bitmask to change
+ * @val: Value to be written
+ * @size: Size of the register to update
+ *
+ * Updates the desired bits of @reg in accordance with @mask and @val.
+ */
+int __adis_update_bits_base(struct adis *adis, unsigned int reg, const u32 mask,
+			    const u32 val, u8 size)
+{
+	int ret;
+	u32 __val;
+
+	ret = __adis_read_reg(adis, reg, &__val, size);
+	if (ret)
+		return ret;
+
+	__val = (__val & ~mask) | (val & mask);
+
+	return __adis_write_reg(adis, reg, __val, size);
+}
+EXPORT_SYMBOL_GPL(__adis_update_bits_base);
 
 #ifdef CONFIG_DEBUG_FS
 

commit 97f1755ee227f6bef186e1d2166e50097c7f7e4f
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Fri Apr 10 19:12:24 2020 +0200

    iio: imu: adis: Add a missing '\n' in a log message
    
    Message logged by 'dev_xxx()' or 'pr_xxx()' should end with a '\n'.
    
    Fixes: 1fd456702692 ("iio: imu: adis: add support product ID check in adis_initial_startup")
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index a8afd01de4f3..2e7d0d337f8f 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -419,7 +419,7 @@ int __adis_initial_startup(struct adis *adis)
 
 	if (prod_id != adis->data->prod_id)
 		dev_warn(&adis->spi->dev,
-			 "Device ID(%u) and product ID(%u) do not match.",
+			 "Device ID(%u) and product ID(%u) do not match.\n",
 			 adis->data->prod_id, prod_id);
 
 	return 0;

commit 1fd4567026926d01a94a74d0543e324fc794aa73
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Mon Feb 10 15:26:04 2020 +0200

    iio: imu: adis: add support product ID check in adis_initial_startup
    
    Each driver/chip that wants to validate it's product id, can now
    specify a 'prod_id_reg' and an expected 'prod_id' value.
    The 'prod_id' value is intentionally left 0 (uninitialized). There aren't
    (yet) any product IDs with value 0; this enforces that both 'prod_id_reg'
    and 'prod_id' are specified.
    
    At the very least, this routine validates that the SPI connection to the
    ADIS chip[s] works well.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index 0bd6e32cf577..a8afd01de4f3 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -373,6 +373,10 @@ static int adis_self_test(struct adis *adis)
  * via GPIOLIB. If no pin is configured a SW reset will be performed.
  * The RST pin for the ADIS devices should be configured as ACTIVE_LOW.
  *
+ * After the self-test operation is performed, the function will also check
+ * that the product ID is as expected. This assumes that drivers providing
+ * 'prod_id_reg' will also provide the 'prod_id'.
+ *
  * Returns 0 if the device is operational, a negative error code otherwise.
  *
  * This function should be called early on in the device initialization sequence
@@ -382,6 +386,7 @@ int __adis_initial_startup(struct adis *adis)
 {
 	const struct adis_timeout *timeouts = adis->data->timeouts;
 	struct gpio_desc *gpio;
+	uint16_t prod_id;
 	int ret;
 
 	/* check if the device has rst pin low */
@@ -401,7 +406,23 @@ int __adis_initial_startup(struct adis *adis)
 			return ret;
 	}
 
-	return adis_self_test(adis);
+	ret = adis_self_test(adis);
+	if (ret)
+		return ret;
+
+	if (!adis->data->prod_id_reg)
+		return 0;
+
+	ret = adis_read_reg_16(adis, adis->data->prod_id_reg, &prod_id);
+	if (ret)
+		return ret;
+
+	if (prod_id != adis->data->prod_id)
+		dev_warn(&adis->spi->dev,
+			 "Device ID(%u) and product ID(%u) do not match.",
+			 adis->data->prod_id, prod_id);
+
+	return 0;
 }
 EXPORT_SYMBOL_GPL(__adis_initial_startup);
 

commit ecb010d441088c447785a1249e69003437f96c9c
Author: Nuno Sá <nuno.sa@analog.com>
Date:   Mon Feb 10 15:26:03 2020 +0200

    iio: imu: adis: Refactor adis_initial_startup
    
    All the ADIS devices perform, at the beginning, a self test to make sure
    the device is in a sane state. Previously, the logic was that the self-test
    was performed in adis_initial_startup() and if that failed a reset was done
    and then a self-test was attempted again.
    
    This change unifies the reset mechanism under the adis_initial_startup()
    call. A HW reset will be done if  GPIO is configured, or a SW reset
    otherwise. This should make sure that the chip is in a sane state for
    self-test. Once the reset is done, the self-test operation will be
    performed. If anything goes wrong with self-test, the driver should just
    bail/error-out (i.e. no second attempt). The chip would likely not be a in
    a sane state state if the self-test fails after a reset.
    
    Signed-off-by: Nuno Sá <nuno.sa@analog.com>
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index f7845a90f376..0bd6e32cf577 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -7,6 +7,7 @@
  */
 
 #include <linux/delay.h>
+#include <linux/gpio/consumer.h>
 #include <linux/mutex.h>
 #include <linux/device.h>
 #include <linux/kernel.h>
@@ -368,6 +369,10 @@ static int adis_self_test(struct adis *adis)
  * __adis_initial_startup() - Device initial setup
  * @adis: The adis device
  *
+ * The function performs a HW reset via a reset pin that should be specified
+ * via GPIOLIB. If no pin is configured a SW reset will be performed.
+ * The RST pin for the ADIS devices should be configured as ACTIVE_LOW.
+ *
  * Returns 0 if the device is operational, a negative error code otherwise.
  *
  * This function should be called early on in the device initialization sequence
@@ -375,18 +380,28 @@ static int adis_self_test(struct adis *adis)
  */
 int __adis_initial_startup(struct adis *adis)
 {
+	const struct adis_timeout *timeouts = adis->data->timeouts;
+	struct gpio_desc *gpio;
 	int ret;
 
-	ret = adis_self_test(adis);
-	if (ret) {
-		dev_err(&adis->spi->dev, "Self-test failed, trying reset.\n");
-		__adis_reset(adis);
-		ret = adis_self_test(adis);
+	/* check if the device has rst pin low */
+	gpio = devm_gpiod_get_optional(&adis->spi->dev, "reset", GPIOD_ASIS);
+	if (IS_ERR(gpio))
+		return PTR_ERR(gpio);
+
+	if (gpio) {
+		gpiod_set_value_cansleep(gpio, 1);
+		msleep(10);
+		/* bring device out of reset */
+		gpiod_set_value_cansleep(gpio, 0);
+		msleep(timeouts->reset_ms);
+	} else {
+		ret = __adis_reset(adis);
 		if (ret)
-			dev_err(&adis->spi->dev, "Second self-test failed, giving up.\n");
+			return ret;
 	}
 
-	return ret;
+	return adis_self_test(adis);
 }
 EXPORT_SYMBOL_GPL(__adis_initial_startup);
 

commit fdcf6bbb4ed388844e74810e117ac87db1347f3a
Author: Nuno Sá <nuno.sa@analog.com>
Date:   Mon Feb 10 15:26:02 2020 +0200

    iio: imu: adis: Add self_test_reg variable
    
    This patch adds a dedicated self_test_reg variable. This is also a step
    to let new drivers make use of `adis_initial_startup()`. Some devices
    use MSG_CTRL reg to request a self_test command while others use the
    GLOB_CMD register.
    
    Signed-off-by: Nuno Sá <nuno.sa@analog.com>
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index e4897dad34ab..f7845a90f376 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -346,8 +346,8 @@ static int adis_self_test(struct adis *adis)
 	int ret;
 	const struct adis_timeout *timeouts = adis->data->timeouts;
 
-	ret = __adis_write_reg_16(adis, adis->data->msc_ctrl_reg,
-			adis->data->self_test_mask);
+	ret = __adis_write_reg_16(adis, adis->data->self_test_reg,
+				  adis->data->self_test_mask);
 	if (ret) {
 		dev_err(&adis->spi->dev, "Failed to initiate self test: %d\n",
 			ret);
@@ -359,7 +359,7 @@ static int adis_self_test(struct adis *adis)
 	ret = __adis_check_status(adis);
 
 	if (adis->data->self_test_no_autoclear)
-		__adis_write_reg_16(adis, adis->data->msc_ctrl_reg, 0x00);
+		__adis_write_reg_16(adis, adis->data->self_test_reg, 0x00);
 
 	return ret;
 }

commit 3f17ada8f38c57b6c81d41db6d911932b280d5b5
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Mon Feb 10 15:26:01 2020 +0200

    iio: imu: adis: add unlocked __adis_initial_startup()
    
    This change splits the __adis_initial_startup() away from
    adis_initial_startup(). The unlocked version can be used in certain calls
    during probe, where races won't happen since the ADIS driver may not be
    registered yet with IIO.
    
    Signed-off-by: Nuno Sá <nuno.sa@analog.com>
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index 022bb54fb748..e4897dad34ab 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -365,7 +365,7 @@ static int adis_self_test(struct adis *adis)
 }
 
 /**
- * adis_inital_startup() - Performs device self-test
+ * __adis_initial_startup() - Device initial setup
  * @adis: The adis device
  *
  * Returns 0 if the device is operational, a negative error code otherwise.
@@ -373,28 +373,22 @@ static int adis_self_test(struct adis *adis)
  * This function should be called early on in the device initialization sequence
  * to ensure that the device is in a sane and known state and that it is usable.
  */
-int adis_initial_startup(struct adis *adis)
+int __adis_initial_startup(struct adis *adis)
 {
 	int ret;
 
-	mutex_lock(&adis->state_lock);
-
 	ret = adis_self_test(adis);
 	if (ret) {
 		dev_err(&adis->spi->dev, "Self-test failed, trying reset.\n");
 		__adis_reset(adis);
 		ret = adis_self_test(adis);
-		if (ret) {
+		if (ret)
 			dev_err(&adis->spi->dev, "Second self-test failed, giving up.\n");
-			goto out_unlock;
-		}
 	}
 
-out_unlock:
-	mutex_unlock(&adis->state_lock);
 	return ret;
 }
-EXPORT_SYMBOL_GPL(adis_initial_startup);
+EXPORT_SYMBOL_GPL(__adis_initial_startup);
 
 /**
  * adis_single_conversion() - Performs a single sample conversion

commit a4e6f40c77afe6e6a0076c4bcf7cbf68406a7d9f
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Tue Dec 10 16:07:55 2019 +0200

    iio: imu: adis: use new `delay` structure for SPI transfer delays
    
    In a recent change to the SPI subsystem [1], a new `delay` struct was added
    to replace the `delay_usecs`. This change replaces the current `delay_usecs`
    with `delay` for this driver.
    
    The `spi_transfer_delay_exec()` function [in the SPI framework] makes sure
    that both `delay_usecs` & `delay` are used (in this order to preserve
    backwards compatibility).
    
    [1] commit bebcfd272df6485 ("spi: introduce `delay` field for
    `spi_transfer` + spi_transfer_delay_exec()")
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index 8f0867495ef5..022bb54fb748 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -45,7 +45,8 @@ int __adis_write_reg(struct adis *adis, unsigned int reg,
 			.bits_per_word = 8,
 			.len = 2,
 			.cs_change = 1,
-			.delay_usecs = adis->data->write_delay,
+			.delay.value = adis->data->write_delay,
+			.delay.unit = SPI_DELAY_UNIT_USECS,
 			.cs_change_delay.value = adis->data->cs_change_delay,
 			.cs_change_delay.unit = SPI_DELAY_UNIT_USECS,
 		}, {
@@ -53,7 +54,8 @@ int __adis_write_reg(struct adis *adis, unsigned int reg,
 			.bits_per_word = 8,
 			.len = 2,
 			.cs_change = 1,
-			.delay_usecs = adis->data->write_delay,
+			.delay.value = adis->data->write_delay,
+			.delay.unit = SPI_DELAY_UNIT_USECS,
 			.cs_change_delay.value = adis->data->cs_change_delay,
 			.cs_change_delay.unit = SPI_DELAY_UNIT_USECS,
 		}, {
@@ -61,19 +63,22 @@ int __adis_write_reg(struct adis *adis, unsigned int reg,
 			.bits_per_word = 8,
 			.len = 2,
 			.cs_change = 1,
-			.delay_usecs = adis->data->write_delay,
+			.delay.value = adis->data->write_delay,
+			.delay.unit = SPI_DELAY_UNIT_USECS,
 			.cs_change_delay.value = adis->data->cs_change_delay,
 			.cs_change_delay.unit = SPI_DELAY_UNIT_USECS,
 		}, {
 			.tx_buf = adis->tx + 6,
 			.bits_per_word = 8,
 			.len = 2,
-			.delay_usecs = adis->data->write_delay,
+			.delay.value = adis->data->write_delay,
+			.delay.unit = SPI_DELAY_UNIT_USECS,
 		}, {
 			.tx_buf = adis->tx + 8,
 			.bits_per_word = 8,
 			.len = 2,
-			.delay_usecs = adis->data->write_delay,
+			.delay.value = adis->data->write_delay,
+			.delay.unit = SPI_DELAY_UNIT_USECS,
 		},
 	};
 
@@ -140,7 +145,8 @@ int __adis_read_reg(struct adis *adis, unsigned int reg,
 			.bits_per_word = 8,
 			.len = 2,
 			.cs_change = 1,
-			.delay_usecs = adis->data->write_delay,
+			.delay.value = adis->data->write_delay,
+			.delay.unit = SPI_DELAY_UNIT_USECS,
 			.cs_change_delay.value = adis->data->cs_change_delay,
 			.cs_change_delay.unit = SPI_DELAY_UNIT_USECS,
 		}, {
@@ -148,7 +154,8 @@ int __adis_read_reg(struct adis *adis, unsigned int reg,
 			.bits_per_word = 8,
 			.len = 2,
 			.cs_change = 1,
-			.delay_usecs = adis->data->read_delay,
+			.delay.value = adis->data->read_delay,
+			.delay.unit = SPI_DELAY_UNIT_USECS,
 			.cs_change_delay.value = adis->data->cs_change_delay,
 			.cs_change_delay.unit = SPI_DELAY_UNIT_USECS,
 		}, {
@@ -157,14 +164,16 @@ int __adis_read_reg(struct adis *adis, unsigned int reg,
 			.bits_per_word = 8,
 			.len = 2,
 			.cs_change = 1,
-			.delay_usecs = adis->data->read_delay,
+			.delay.value = adis->data->read_delay,
+			.delay.unit = SPI_DELAY_UNIT_USECS,
 			.cs_change_delay.value = adis->data->cs_change_delay,
 			.cs_change_delay.unit = SPI_DELAY_UNIT_USECS,
 		}, {
 			.rx_buf = adis->rx + 2,
 			.bits_per_word = 8,
 			.len = 2,
-			.delay_usecs = adis->data->read_delay,
+			.delay.value = adis->data->read_delay,
+			.delay.unit = SPI_DELAY_UNIT_USECS,
 		},
 	};
 

commit 380b107bbf9449ddea0637cefe65a6cbf7b6ca84
Author: Nuno Sá <nuno.sa@analog.com>
Date:   Tue Jan 7 13:17:04 2020 +0200

    iio: adis: Introduce timeouts structure
    
    The adis library only allows to define a `startup_delay` which for some
    devices is enough. However, other devices define different timeouts with
    significantly different timings which could lead to devices to not wait
    enough time or to wait a lot more than necessary (which is not
    efficient). This patch introduces a new timeout struct that must be
    passed into `adis_init()`. There are mainly, for now, three timeouts
    used. This is also an introductory patch with the goal of refactoring
    `adis_initial_startup()`. New driver's (eg: adis16480, adis16460) are
    replicating code for the device initial setup. With some changes (being
    this the first one) we can pass this to `adis_initial_startup()`.
    
    Signed-off-by: Nuno Sá <nuno.sa@analog.com>
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index 9ba4a7c8e7ad..8f0867495ef5 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -317,19 +317,25 @@ EXPORT_SYMBOL_GPL(__adis_check_status);
 int __adis_reset(struct adis *adis)
 {
 	int ret;
+	const struct adis_timeout *timeouts = adis->data->timeouts;
 
 	ret = __adis_write_reg_8(adis, adis->data->glob_cmd_reg,
 			ADIS_GLOB_CMD_SW_RESET);
-	if (ret)
+	if (ret) {
 		dev_err(&adis->spi->dev, "Failed to reset device: %d\n", ret);
+		return ret;
+	}
 
-	return ret;
+	msleep(timeouts->sw_reset_ms);
+
+	return 0;
 }
 EXPORT_SYMBOL_GPL(__adis_reset);
 
 static int adis_self_test(struct adis *adis)
 {
 	int ret;
+	const struct adis_timeout *timeouts = adis->data->timeouts;
 
 	ret = __adis_write_reg_16(adis, adis->data->msc_ctrl_reg,
 			adis->data->self_test_mask);
@@ -339,7 +345,7 @@ static int adis_self_test(struct adis *adis)
 		return ret;
 	}
 
-	msleep(adis->data->startup_delay);
+	msleep(timeouts->self_test_ms);
 
 	ret = __adis_check_status(adis);
 
@@ -368,7 +374,6 @@ int adis_initial_startup(struct adis *adis)
 	if (ret) {
 		dev_err(&adis->spi->dev, "Self-test failed, trying reset.\n");
 		__adis_reset(adis);
-		msleep(adis->data->startup_delay);
 		ret = adis_self_test(adis);
 		if (ret) {
 			dev_err(&adis->spi->dev, "Second self-test failed, giving up.\n");
@@ -444,6 +449,11 @@ EXPORT_SYMBOL_GPL(adis_single_conversion);
 int adis_init(struct adis *adis, struct iio_dev *indio_dev,
 	struct spi_device *spi, const struct adis_data *data)
 {
+	if (!data || !data->timeouts) {
+		dev_err(&spi->dev, "No config data or timeouts not defined!\n");
+		return -EINVAL;
+	}
+
 	mutex_init(&adis->state_lock);
 	adis->spi = spi;
 	adis->data = data;

commit 821f7ce79fd1ef2bf96a1b93521d8800abd24a1f
Merge: 0469fc6a1a87 c1d1c4a62db5
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jan 10 10:44:00 2020 +0100

    Merge tag 'iio-for-5.6a' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-next
    
    Jonathan writes:
    
    First set of new device support, features and cleanups for IIO in the 5.6 cycle
    
    New device support
    
    * ad7091r5 ADC
      - New driver with follow up patch adding scale and vref support.
      - DT bindings
    * ad7923
      - Support for ad7908, ad7918 and ad7928 added to driver.
    * bma180
      - Support the BMA254 accelerometer. Required fairly substantial rework
        to allow for small differences between this an existing parts.
    * bma400 accelerometer
      - New driver with follow up patch for regulator support.
      - DT bindings.
    * asc dlhl60d
      - New driver support this range of pressure and temperature sensors.
      - DT bindings.
    * ltc2496 ADC
      - New driver to support this ADC.
      - Split the existing LTC2497 driver generic component out and reuse.
      - DT bindings.
    * parallax ping
      - New driver supporting ultrasonic and laser tof distance sensors.
      - Bindings for these sensors.
    
    New features
    
    * core
      - New char type for read_raw returns, used for thermocouple types.
      - Rename read_first_n callback to read.   The reasons behind the original
        naming are lost to the mists of time.
    * ad799x
      - Allow pm_ops to disable device completely allowing regulator power down.
    * bma180
      - Enable basic regulator support.
    * dmaengine buffer
      - Report platform data alignment requirements via new ABI.
    * max31856
      - Add option to set mains filter rejection frequency and document
        new in_temp_filter_notch_center_frequency ABI.
      - Add support for configuring HW averaging (oversampling ratio)
      - Add runtime configuration of thermocouple type and document new ABI.
    * maxim-thermocouple
      - Add read only access to thermocouple type using new ABI, includes
        adding more specific compatibles to reflect which variant of the
        chip is being used.
    * mpu6050
      - Provide option to support the PMU9150 in package magnetometer directly
        rather than via auxiliary bus.
    * stm32_adc
      - Add overrun interrupt checks to detect if this happens.
    * st_lsm6dsx
      - Enable the sensor-hub support for lsm6dsm. Includes various reworks to
        allow this.
    
    Cleanups and minor fixes
    
    * Subsystem wide
      - Tidy up indentation in Kconfig and fix alphabetical order of AD7091R5.
      - Drop linux/gpio.h and linux/of_gpio.h from drivers that don't use them.
    * ad7266
      - Convert to GPIO descriptors.
    * ad7303
      - Avoid a dance with checking if the regulator is supplied by just
        using the optional request interface.
    * ad7887
      - Simplify channel specification assignment to enable adding more devices.
    * ad7923
      - Drop some unused and largely pointless defines of BOB_N==N variety.
      - Tidy up checkpatch warnings.
      - Add missing of_device_id table.
    * adf4350
      - Convert to GPIO descriptors.
    * ak8975
      - Convert to GPIO descriptors.
    * ADIS library and drivers
      - Expand scope of txrx_lock to cover all state and rename as state_lock
      - Add unlocked read / write to allow grouping of consecutive calls under
        single lock / unlock.
      - Add unlocked check_status, reset to allow grouping under single
        lock / unlock.
      - Remove remaining uses of core mlock for local state protection.
        mlock should never be used directly as it protects tightly defined
        core IIO device management state.
    * adis16240
      - Enforce only supported SPI mode on driver load + add DT binding doc.
    * atlas-ph-sensor
      - Rename to atlas-sensor given it now covers things beyond ph sensors.
    * bma180
      - Use local dev variable to tidy up code.
      - Use c99 style explicity .member assignment to make driver more readable.
    * bmp280
      - Drop ACPI support. No evidence this was used and appropriate ID is not
        registered.
      - Allow ACPI to bind device via PRP0001
    * dmaengine buffer
      - Use dma_request_chan instead of dma_request_slave_channel_reason as that
        ABI is going away.
      - Add module info to avoid tainting the kernel.
    * hts221
      - Avoid magic number defines when only used to fill structure elements
        that are self describing.
    * lm3533
      - Drop a stray semicolon.
    * max9611
      - Cleanup enum handling to be more resilient to future changes.
    * mpu6050
      - Delete MPU9150 from supported SPI devices as doesn't provide SPI.
      - Select I2C_MUX again after kbuild issue fixed elsewhere.
    * stm32-timer
      - Drop an unnecessary register update.
    * ssp_sensors
      - Convert to GPIO descriptors.
    * st_sensors
      - drop !CONFIG_ACPI defines as ACPI_PTR() will stop them being used
        anyway.
      - Make default platform data structures __maybe_unsued.
      - Fill in some missing kernel-doc function parameters.
    * st_lsm6dsx
      - white space fixes.
      - Mark some constants that aren't always used as __maybe_unused.
      - Drop of ID table guards as they just pervent use under ACPI.
      - Switch to device properties to allow ACPI usage.
    * st_uvis25
      - Drop acpi.h include as no ACPI APIs used.
    * ti-ads1015
      - Drop legacy platform data as no one seems to be using it.
      - Use the device property API instead of OF specific.
    * ti-ads7950
      - typo fix in error message.
    
    * tag 'iio-for-5.6a' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio: (99 commits)
      iio: accel: bma180: BMA254 support
      iio: pressure: bmp280: Allow device to be enumerated from ACPI
      iio: pressure: bmp280: Drop ACPI support
      dt-bindings: iio: adc: convert sd modulator to json-schema
      iio: buffer: rename 'read_first_n' callback to 'read'
      iio: buffer-dmaengine: Report buffer length requirements
      bindings: iio: pressure: Add documentation for dlh driver
      dt-bindings: Add asc vendor
      iio: pressure: Add driver for DLH pressure sensors
      iio: buffer-dmaengine: Add module information
      iio: accel: bma180: Use explicit member assignment
      iio: accel: bma180: Basic regulator support
      iio: accel: bma180: Add dev helper variable
      iio: imu: st_lsm6dsx: enable sensor-hub support for lsm6dsm
      iio: imu: st_lsm6dsx: rename st_lsm6dsx_shub_read_reg in st_lsm6dsx_shub_read_output
      iio: imu: st_lsm6dsx: check if shub_output reg is located in primary page
      iio: imu: st_lsm6dsx: check if pull_up is located in primary page
      iio: imu: st_lsm6dsx: check if master_enable is located in primary page
      iio: imu: st_lsm6dsx: export max num of slave devices in st_lsm6dsx_shub_settings
      iio: light: remove unneeded semicolon
      ...

commit 0dd09bc02c1bad55e92306ca83b38b3cf48b9f40
Merge: 8f56e4ebe05c 0f6f8749872e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Nov 27 10:57:52 2019 -0800

    Merge tag 'staging-5.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging / iio updates from Greg KH:
     "Here is the big staging and iio set of patches for the 5.5-rc1
      release.
    
      It's the usual huge collection of cleanup patches all over the
      drivers/staging/ area, along with a new staging driver, and a bunch of
      new IIO drivers as well.
    
      Full details are in the shortlog, but all of these have been in
      linux-next for a long time with no reported issues"
    
    * tag 'staging-5.5-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (548 commits)
      staging: vchiq: Have vchiq_dump_* functions return an error code
      staging: vchiq: Refactor indentation in vchiq_dump_* functions
      staging: fwserial: Fix Kconfig indentation (seven spaces)
      staging: vchiq_dump: Replace min with min_t
      staging: vchiq: Fix block comment format in vchiq_dump()
      staging: octeon: indent with tabs instead of spaces
      staging: comedi: usbduxfast: usbduxfast_ai_cmdtest rounding error
      staging: most: core: remove sysfs attr remove_link
      staging: vc04: Fix Kconfig indentation
      staging: pi433: Fix Kconfig indentation
      staging: nvec: Fix Kconfig indentation
      staging: most: Fix Kconfig indentation
      staging: fwserial: Fix Kconfig indentation
      staging: fbtft: Fix Kconfig indentation
      fbtft: Drop OF dependency
      fbtft: Make use of device property API
      fbtft: Drop useless #ifdef CONFIG_OF and dead code
      fbtft: Describe function parameters in kernel-doc
      fbtft: Make sure string is NULL terminated
      staging: rtl8723bs: remove set but not used variable 'change', 'pos'
      ...

commit c5485a5d6a5f7d00ca4aba6698526c5ae3f2a1a2
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Fri Nov 22 15:24:17 2019 +0200

    iio: imu: adis: group single conversion under a single state lock
    
    The single conversion function does a series of reads + writes. This change
    extends the use of the state_lock for the entire set of operations.
    Previously, indio_dev's mlock was used. This change also removes the use of
    this lock.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index 10b8922fd51b..c53f3ed3cb97 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -404,15 +404,15 @@ int adis_single_conversion(struct iio_dev *indio_dev,
 	unsigned int uval;
 	int ret;
 
-	mutex_lock(&indio_dev->mlock);
+	mutex_lock(&adis->state_lock);
 
-	ret = adis_read_reg(adis, chan->address, &uval,
+	ret = __adis_read_reg(adis, chan->address, &uval,
 			chan->scan_type.storagebits / 8);
 	if (ret)
 		goto err_unlock;
 
 	if (uval & error_mask) {
-		ret = adis_check_status(adis);
+		ret = __adis_check_status(adis);
 		if (ret)
 			goto err_unlock;
 	}
@@ -424,7 +424,7 @@ int adis_single_conversion(struct iio_dev *indio_dev,
 
 	ret = IIO_VAL_INT;
 err_unlock:
-	mutex_unlock(&indio_dev->mlock);
+	mutex_unlock(&adis->state_lock);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(adis_single_conversion);

commit cb5a07f1f15cc3fd7e12bfdd48ba0e9fb585ea5e
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Fri Nov 22 15:24:16 2019 +0200

    iio: imu: adis: protect initial startup routine with state lock
    
    The initial startup routine is called by some ADIS drivers during probe,
    and before registering with IIO. Normally, userspace should not be able to
    do any access to the device (as there shouldn't be any available).
    
    This change extends the state lock to the entire initial-startup routine.
    Behaviourally nothing should change, but this should make the library
    function a bit more robust.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index 615f174f0e6e..10b8922fd51b 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -331,7 +331,7 @@ static int adis_self_test(struct adis *adis)
 {
 	int ret;
 
-	ret = adis_write_reg_16(adis, adis->data->msc_ctrl_reg,
+	ret = __adis_write_reg_16(adis, adis->data->msc_ctrl_reg,
 			adis->data->self_test_mask);
 	if (ret) {
 		dev_err(&adis->spi->dev, "Failed to initiate self test: %d\n",
@@ -341,10 +341,10 @@ static int adis_self_test(struct adis *adis)
 
 	msleep(adis->data->startup_delay);
 
-	ret = adis_check_status(adis);
+	ret = __adis_check_status(adis);
 
 	if (adis->data->self_test_no_autoclear)
-		adis_write_reg_16(adis, adis->data->msc_ctrl_reg, 0x00);
+		__adis_write_reg_16(adis, adis->data->msc_ctrl_reg, 0x00);
 
 	return ret;
 }
@@ -362,19 +362,23 @@ int adis_initial_startup(struct adis *adis)
 {
 	int ret;
 
+	mutex_lock(&adis->state_lock);
+
 	ret = adis_self_test(adis);
 	if (ret) {
 		dev_err(&adis->spi->dev, "Self-test failed, trying reset.\n");
-		adis_reset(adis);
+		__adis_reset(adis);
 		msleep(adis->data->startup_delay);
 		ret = adis_self_test(adis);
 		if (ret) {
 			dev_err(&adis->spi->dev, "Second self-test failed, giving up.\n");
-			return ret;
+			goto out_unlock;
 		}
 	}
 
-	return 0;
+out_unlock:
+	mutex_unlock(&adis->state_lock);
+	return ret;
 }
 EXPORT_SYMBOL_GPL(adis_initial_startup);
 

commit 762ab093cbe26451175a5a63ea06c971bf973525
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Fri Nov 22 15:24:15 2019 +0200

    iio: imu: adis: create an unlocked version of adis_reset()
    
    The reset routine may also be important to be protected by the state-lock
    and grouped with other operations, so create an unlocked version, so that
    this can be done.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index b63d6e6f5415..615f174f0e6e 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -309,23 +309,23 @@ int __adis_check_status(struct adis *adis)
 EXPORT_SYMBOL_GPL(__adis_check_status);
 
 /**
- * adis_reset() - Reset the device
+ * __adis_reset() - Reset the device (unlocked version)
  * @adis: The adis device
  *
  * Returns 0 on success, a negative error code otherwise
  */
-int adis_reset(struct adis *adis)
+int __adis_reset(struct adis *adis)
 {
 	int ret;
 
-	ret = adis_write_reg_8(adis, adis->data->glob_cmd_reg,
+	ret = __adis_write_reg_8(adis, adis->data->glob_cmd_reg,
 			ADIS_GLOB_CMD_SW_RESET);
 	if (ret)
 		dev_err(&adis->spi->dev, "Failed to reset device: %d\n", ret);
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(adis_reset);
+EXPORT_SYMBOL_GPL(__adis_reset);
 
 static int adis_self_test(struct adis *adis)
 {

commit 6a4d6a7d6588d8c15501542da786ebff6602475c
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Fri Nov 22 15:24:14 2019 +0200

    iio: imu: adis: create an unlocked version of adis_check_status()
    
    This one also gets re-used in certain operations, so it makes sense to
    have an unlocked version of this to group it with other
    reads/writes/operations to have a single lock for the whole state change.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index 5cf7a15be6ee..b63d6e6f5415 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -277,18 +277,18 @@ int adis_enable_irq(struct adis *adis, bool enable)
 EXPORT_SYMBOL(adis_enable_irq);
 
 /**
- * adis_check_status() - Check the device for error conditions
+ * __adis_check_status() - Check the device for error conditions (unlocked)
  * @adis: The adis device
  *
  * Returns 0 on success, a negative error code otherwise
  */
-int adis_check_status(struct adis *adis)
+int __adis_check_status(struct adis *adis)
 {
 	uint16_t status;
 	int ret;
 	int i;
 
-	ret = adis_read_reg_16(adis, adis->data->diag_stat_reg, &status);
+	ret = __adis_read_reg_16(adis, adis->data->diag_stat_reg, &status);
 	if (ret)
 		return ret;
 
@@ -306,7 +306,7 @@ int adis_check_status(struct adis *adis)
 
 	return -EIO;
 }
-EXPORT_SYMBOL_GPL(adis_check_status);
+EXPORT_SYMBOL_GPL(__adis_check_status);
 
 /**
  * adis_reset() - Reset the device

commit 100bfa38c8cb81ccbbd17ee4f0c1164f455f6039
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Fri Nov 22 15:24:13 2019 +0200

    iio: imu: adis[16480]: group RW into a single lock in adis_enable_irq()
    
    The adis_enable_irq() does a read & a write. This change keeps a lock for
    the duration of both operations vs for each op.
    
    The change is also needed in adis16480, since that has it's own
    implementation for adis_enable_irq().
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index 2f518e6c727d..5cf7a15be6ee 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -250,12 +250,16 @@ int adis_enable_irq(struct adis *adis, bool enable)
 	int ret = 0;
 	uint16_t msc;
 
-	if (adis->data->enable_irq)
-		return adis->data->enable_irq(adis, enable);
+	mutex_lock(&adis->state_lock);
 
-	ret = adis_read_reg_16(adis, adis->data->msc_ctrl_reg, &msc);
+	if (adis->data->enable_irq) {
+		ret = adis->data->enable_irq(adis, enable);
+		goto out_unlock;
+	}
+
+	ret = __adis_read_reg_16(adis, adis->data->msc_ctrl_reg, &msc);
 	if (ret)
-		goto error_ret;
+		goto out_unlock;
 
 	msc |= ADIS_MSC_CTRL_DATA_RDY_POL_HIGH;
 	msc &= ~ADIS_MSC_CTRL_DATA_RDY_DIO2;
@@ -264,9 +268,10 @@ int adis_enable_irq(struct adis *adis, bool enable)
 	else
 		msc &= ~ADIS_MSC_CTRL_DATA_RDY_EN;
 
-	ret = adis_write_reg_16(adis, adis->data->msc_ctrl_reg, msc);
+	ret = __adis_write_reg_16(adis, adis->data->msc_ctrl_reg, msc);
 
-error_ret:
+out_unlock:
+	mutex_unlock(&adis->state_lock);
 	return ret;
 }
 EXPORT_SYMBOL(adis_enable_irq);

commit 770d465619423a946248018ea39ed9a74c8f2ff4
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Fri Nov 22 15:24:12 2019 +0200

    iio: imu: adis: add unlocked read/write function versions
    
    This will allow more flexible control to group reads & writes into a single
    lock (particularly the state_lock).
    
    The end-goal is to remove the indio_dev->mlock usage, and the simplest fix
    would have been to just add another lock, which would not be a good idea on
    the long-run.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index db562fec79b2..2f518e6c727d 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -26,7 +26,14 @@
 #define ADIS_MSC_CTRL_DATA_RDY_DIO2	BIT(0)
 #define ADIS_GLOB_CMD_SW_RESET		BIT(7)
 
-int adis_write_reg(struct adis *adis, unsigned int reg,
+/**
+ * __adis_write_reg() - write N bytes to register (unlocked version)
+ * @adis: The adis device
+ * @reg: The address of the lower of the two registers
+ * @value: The value to write to device (up to 4 bytes)
+ * @size: The size of the @value (in bytes)
+ */
+int __adis_write_reg(struct adis *adis, unsigned int reg,
 	unsigned int value, unsigned int size)
 {
 	unsigned int page = reg / ADIS_PAGE_SIZE;
@@ -70,8 +77,6 @@ int adis_write_reg(struct adis *adis, unsigned int reg,
 		},
 	};
 
-	mutex_lock(&adis->state_lock);
-
 	spi_message_init(&msg);
 
 	if (adis->current_page != page) {
@@ -96,8 +101,7 @@ int adis_write_reg(struct adis *adis, unsigned int reg,
 		adis->tx[3] = value & 0xff;
 		break;
 	default:
-		ret = -EINVAL;
-		goto out_unlock;
+		return -EINVAL;
 	}
 
 	xfers[size].cs_change = 0;
@@ -113,20 +117,18 @@ int adis_write_reg(struct adis *adis, unsigned int reg,
 		adis->current_page = page;
 	}
 
-out_unlock:
-	mutex_unlock(&adis->state_lock);
-
 	return ret;
 }
-EXPORT_SYMBOL_GPL(adis_write_reg);
+EXPORT_SYMBOL_GPL(__adis_write_reg);
 
 /**
- * adis_read_reg() - read 2 bytes from a 16-bit register
+ * __adis_read_reg() - read N bytes from register (unlocked version)
  * @adis: The adis device
  * @reg: The address of the lower of the two registers
  * @val: The value read back from the device
+ * @size: The size of the @val buffer
  */
-int adis_read_reg(struct adis *adis, unsigned int reg,
+int __adis_read_reg(struct adis *adis, unsigned int reg,
 	unsigned int *val, unsigned int size)
 {
 	unsigned int page = reg / ADIS_PAGE_SIZE;
@@ -166,7 +168,6 @@ int adis_read_reg(struct adis *adis, unsigned int reg,
 		},
 	};
 
-	mutex_lock(&adis->state_lock);
 	spi_message_init(&msg);
 
 	if (adis->current_page != page) {
@@ -188,15 +189,14 @@ int adis_read_reg(struct adis *adis, unsigned int reg,
 		spi_message_add_tail(&xfers[3], &msg);
 		break;
 	default:
-		ret = -EINVAL;
-		goto out_unlock;
+		return -EINVAL;
 	}
 
 	ret = spi_sync(adis->spi, &msg);
 	if (ret) {
 		dev_err(&adis->spi->dev, "Failed to read register 0x%02X: %d\n",
 				reg, ret);
-		goto out_unlock;
+		return ret;
 	} else {
 		adis->current_page = page;
 	}
@@ -210,12 +210,9 @@ int adis_read_reg(struct adis *adis, unsigned int reg,
 		break;
 	}
 
-out_unlock:
-	mutex_unlock(&adis->state_lock);
-
 	return ret;
 }
-EXPORT_SYMBOL_GPL(adis_read_reg);
+EXPORT_SYMBOL_GPL(__adis_read_reg);
 
 #ifdef CONFIG_DEBUG_FS
 

commit 6a9afcb198b4de323485c0ee94ff09f653012d4b
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Fri Nov 22 15:24:11 2019 +0200

    iio: imu: adis: rename txrx_lock -> state_lock
    
    The lock can be extended a bit to protect other elements that are not
    particular to just TX/RX. Another idea would have been to just add a new
    `state_lock`, but that would mean 2 locks which would be redundant, and
    probably cause more potential for dead-locks.
    
    What will be done in the next patches, will be to add some unlocked
    versions for read/write_reg functions.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index 85de565a4e80..db562fec79b2 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -70,7 +70,7 @@ int adis_write_reg(struct adis *adis, unsigned int reg,
 		},
 	};
 
-	mutex_lock(&adis->txrx_lock);
+	mutex_lock(&adis->state_lock);
 
 	spi_message_init(&msg);
 
@@ -114,7 +114,7 @@ int adis_write_reg(struct adis *adis, unsigned int reg,
 	}
 
 out_unlock:
-	mutex_unlock(&adis->txrx_lock);
+	mutex_unlock(&adis->state_lock);
 
 	return ret;
 }
@@ -166,7 +166,7 @@ int adis_read_reg(struct adis *adis, unsigned int reg,
 		},
 	};
 
-	mutex_lock(&adis->txrx_lock);
+	mutex_lock(&adis->state_lock);
 	spi_message_init(&msg);
 
 	if (adis->current_page != page) {
@@ -211,7 +211,7 @@ int adis_read_reg(struct adis *adis, unsigned int reg,
 	}
 
 out_unlock:
-	mutex_unlock(&adis->txrx_lock);
+	mutex_unlock(&adis->state_lock);
 
 	return ret;
 }
@@ -438,7 +438,7 @@ EXPORT_SYMBOL_GPL(adis_single_conversion);
 int adis_init(struct adis *adis, struct iio_dev *indio_dev,
 	struct spi_device *spi, const struct adis_data *data)
 {
-	mutex_init(&adis->txrx_lock);
+	mutex_init(&adis->state_lock);
 	adis->spi = spi;
 	adis->data = data;
 	iio_device_set_drvdata(indio_dev, adis);

commit 38262c01ead40f2b061e8b7e6abe254b538d856c
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Fri Nov 1 11:35:04 2019 +0200

    iio: imu: adis: assign read val in debugfs hook only if op successful
    
    This was also caught by the `-Wmaybe-uninitialized` warning, which
    (ironically as-is) it makes quite a lot of sense to do for this.
    
    The code that actually calls this function will fail to copy on
    the uninitialized value.   Hence, patch does not need to go into stable.
    
    Fixes: 78026a6fde8f7 ("iio:imu:adis: Add debugfs register access support")
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index dc2f9e061d98..85de565a4e80 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -229,7 +229,8 @@ int adis_debugfs_reg_access(struct iio_dev *indio_dev,
 		int ret;
 
 		ret = adis_read_reg_16(adis, reg, &val16);
-		*readval = val16;
+		if (ret == 0)
+			*readval = val16;
 
 		return ret;
 	} else {

commit 6a39ab3b195c125d3fe49d0b0b613c2e1dbbc5a2
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Fri Nov 1 11:35:00 2019 +0200

    iio: imu: adis: check ret val for non-zero vs less-than-zero
    
    The ADIS library functions return zero on success, and negative values for
    error. Positive values aren't returned, but we only care about the success
    value (which is zero).
    
    This change is mostly needed so that the compiler won't make any inferences
    about some about values being potentially un-initialized. This only
    triggers after making some functions inline, because the compiler can
    better follow return paths.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index 1631c255deab..dc2f9e061d98 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -286,7 +286,7 @@ int adis_check_status(struct adis *adis)
 	int i;
 
 	ret = adis_read_reg_16(adis, adis->data->diag_stat_reg, &status);
-	if (ret < 0)
+	if (ret)
 		return ret;
 
 	status &= adis->data->status_error_mask;

commit 329f0dac4cad9fa4b1439a88180d91bcb5c4eaf8
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Sep 26 13:51:31 2019 +0300

    spi: make `cs_change_delay` the first user of the `spi_delay` logic
    
    Since the logic for `spi_delay` struct + `spi_delay_exec()` has been copied
    from the `cs_change_delay` logic, it's natural to make this delay, the
    first user.
    
    The `cs_change_delay` logic requires that the default remain 10 uS, in case
    it is unspecified/unconfigured. So, there is some special handling needed
    to do that.
    
    The ADIS library is one of the few users of the new `cs_change_delay`
    parameter for an spi_transfer.
    
    The introduction of the `spi_delay` struct, requires that the users of of
    `cs_change_delay` get an update. This change also updates the ADIS library.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Link: https://lore.kernel.org/r/20190926105147.7839-4-alexandru.ardelean@analog.com
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index 1631c255deab..2cd2cc2316c6 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -39,24 +39,24 @@ int adis_write_reg(struct adis *adis, unsigned int reg,
 			.len = 2,
 			.cs_change = 1,
 			.delay_usecs = adis->data->write_delay,
-			.cs_change_delay = adis->data->cs_change_delay,
-			.cs_change_delay_unit = SPI_DELAY_UNIT_USECS,
+			.cs_change_delay.value = adis->data->cs_change_delay,
+			.cs_change_delay.unit = SPI_DELAY_UNIT_USECS,
 		}, {
 			.tx_buf = adis->tx + 2,
 			.bits_per_word = 8,
 			.len = 2,
 			.cs_change = 1,
 			.delay_usecs = adis->data->write_delay,
-			.cs_change_delay = adis->data->cs_change_delay,
-			.cs_change_delay_unit = SPI_DELAY_UNIT_USECS,
+			.cs_change_delay.value = adis->data->cs_change_delay,
+			.cs_change_delay.unit = SPI_DELAY_UNIT_USECS,
 		}, {
 			.tx_buf = adis->tx + 4,
 			.bits_per_word = 8,
 			.len = 2,
 			.cs_change = 1,
 			.delay_usecs = adis->data->write_delay,
-			.cs_change_delay = adis->data->cs_change_delay,
-			.cs_change_delay_unit = SPI_DELAY_UNIT_USECS,
+			.cs_change_delay.value = adis->data->cs_change_delay,
+			.cs_change_delay.unit = SPI_DELAY_UNIT_USECS,
 		}, {
 			.tx_buf = adis->tx + 6,
 			.bits_per_word = 8,
@@ -139,16 +139,16 @@ int adis_read_reg(struct adis *adis, unsigned int reg,
 			.len = 2,
 			.cs_change = 1,
 			.delay_usecs = adis->data->write_delay,
-			.cs_change_delay = adis->data->cs_change_delay,
-			.cs_change_delay_unit = SPI_DELAY_UNIT_USECS,
+			.cs_change_delay.value = adis->data->cs_change_delay,
+			.cs_change_delay.unit = SPI_DELAY_UNIT_USECS,
 		}, {
 			.tx_buf = adis->tx + 2,
 			.bits_per_word = 8,
 			.len = 2,
 			.cs_change = 1,
 			.delay_usecs = adis->data->read_delay,
-			.cs_change_delay = adis->data->cs_change_delay,
-			.cs_change_delay_unit = SPI_DELAY_UNIT_USECS,
+			.cs_change_delay.value = adis->data->cs_change_delay,
+			.cs_change_delay.unit = SPI_DELAY_UNIT_USECS,
 		}, {
 			.tx_buf = adis->tx + 4,
 			.rx_buf = adis->rx,
@@ -156,8 +156,8 @@ int adis_read_reg(struct adis *adis, unsigned int reg,
 			.len = 2,
 			.cs_change = 1,
 			.delay_usecs = adis->data->read_delay,
-			.cs_change_delay = adis->data->cs_change_delay,
-			.cs_change_delay_unit = SPI_DELAY_UNIT_USECS,
+			.cs_change_delay.value = adis->data->cs_change_delay,
+			.cs_change_delay.unit = SPI_DELAY_UNIT_USECS,
 		}, {
 			.rx_buf = adis->rx + 2,
 			.bits_per_word = 8,

commit dca39af8831e65adc13e0f9f8bdca3a746185072
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Tue Jul 23 10:36:38 2019 +0300

    iio: imu: adis: Add support for SPI transfer cs_change_delay
    
    The ADIS16460 requires a higher delay before the next transfer. Since the
    SPI framework supports configuring the delay before the next transfer, this
    driver will become the first user of it.
    
    The support for this functionality in ADIS16460 requires an addition to the
    ADIS lib to support the `cs_change_delay` functionality from the SPI
    subsystem.
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index 30281e91dbf9..1631c255deab 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -39,18 +39,24 @@ int adis_write_reg(struct adis *adis, unsigned int reg,
 			.len = 2,
 			.cs_change = 1,
 			.delay_usecs = adis->data->write_delay,
+			.cs_change_delay = adis->data->cs_change_delay,
+			.cs_change_delay_unit = SPI_DELAY_UNIT_USECS,
 		}, {
 			.tx_buf = adis->tx + 2,
 			.bits_per_word = 8,
 			.len = 2,
 			.cs_change = 1,
 			.delay_usecs = adis->data->write_delay,
+			.cs_change_delay = adis->data->cs_change_delay,
+			.cs_change_delay_unit = SPI_DELAY_UNIT_USECS,
 		}, {
 			.tx_buf = adis->tx + 4,
 			.bits_per_word = 8,
 			.len = 2,
 			.cs_change = 1,
 			.delay_usecs = adis->data->write_delay,
+			.cs_change_delay = adis->data->cs_change_delay,
+			.cs_change_delay_unit = SPI_DELAY_UNIT_USECS,
 		}, {
 			.tx_buf = adis->tx + 6,
 			.bits_per_word = 8,
@@ -133,12 +139,16 @@ int adis_read_reg(struct adis *adis, unsigned int reg,
 			.len = 2,
 			.cs_change = 1,
 			.delay_usecs = adis->data->write_delay,
+			.cs_change_delay = adis->data->cs_change_delay,
+			.cs_change_delay_unit = SPI_DELAY_UNIT_USECS,
 		}, {
 			.tx_buf = adis->tx + 2,
 			.bits_per_word = 8,
 			.len = 2,
 			.cs_change = 1,
 			.delay_usecs = adis->data->read_delay,
+			.cs_change_delay = adis->data->cs_change_delay,
+			.cs_change_delay_unit = SPI_DELAY_UNIT_USECS,
 		}, {
 			.tx_buf = adis->tx + 4,
 			.rx_buf = adis->rx,
@@ -146,6 +156,8 @@ int adis_read_reg(struct adis *adis, unsigned int reg,
 			.len = 2,
 			.cs_change = 1,
 			.delay_usecs = adis->data->read_delay,
+			.cs_change_delay = adis->data->cs_change_delay,
+			.cs_change_delay_unit = SPI_DELAY_UNIT_USECS,
 		}, {
 			.rx_buf = adis->rx + 2,
 			.bits_per_word = 8,

commit 80503b23b23b5b2228d8750b786eb182f2fa28d2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 24 12:04:09 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 149
    
    Based on 1 normalized pattern(s):
    
      licensed under the gpl 2 or later
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 82 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190524100845.150836982@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index c771ae6803a9..30281e91dbf9 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -1,10 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Common library for ADIS16XXX devices
  *
  * Copyright 2012 Analog Devices Inc.
  *   Author: Lars-Peter Clausen <lars@metafoo.de>
- *
- * Licensed under the GPL-2 or later.
  */
 
 #include <linux/delay.h>

commit 82d65f9d552818b7e56c85edaaf6c3d2b104d07d
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Tue Jul 3 14:35:50 2018 -0500

    iio:imu:adis: Mark expected switch fall-throughs
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases
    where we are expecting to fall through.
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index ad6f91d06185..c771ae6803a9 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -81,9 +81,11 @@ int adis_write_reg(struct adis *adis, unsigned int reg,
 		adis->tx[9] = (value >> 24) & 0xff;
 		adis->tx[6] = ADIS_WRITE_REG(reg + 2);
 		adis->tx[7] = (value >> 16) & 0xff;
+		/* fall through */
 	case 2:
 		adis->tx[4] = ADIS_WRITE_REG(reg + 1);
 		adis->tx[5] = (value >> 8) & 0xff;
+		/* fall through */
 	case 1:
 		adis->tx[2] = ADIS_WRITE_REG(reg);
 		adis->tx[3] = value & 0xff;
@@ -167,6 +169,7 @@ int adis_read_reg(struct adis *adis, unsigned int reg,
 		adis->tx[2] = ADIS_READ_REG(reg + 2);
 		adis->tx[3] = 0;
 		spi_message_add_tail(&xfers[1], &msg);
+		/* fall through */
 	case 2:
 		adis->tx[4] = ADIS_READ_REG(reg);
 		adis->tx[5] = 0;

commit af8a41271b56f6d79cb4d7c7f3ca688a2d97a801
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Fri Apr 15 16:59:38 2016 +0200

    iio:adis: Add support for manual self-test flag clear
    
    Some variants of the devices from the ADIS family don't auto-clear the
    self-test bit after the self-test has completed. Instead we have to
    manually clear. Add support for this to the ADIS library.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index 911255d41c1a..ad6f91d06185 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -324,7 +324,12 @@ static int adis_self_test(struct adis *adis)
 
 	msleep(adis->data->startup_delay);
 
-	return adis_check_status(adis);
+	ret = adis_check_status(adis);
+
+	if (adis->data->self_test_no_autoclear)
+		adis_write_reg_16(adis, adis->data->msc_ctrl_reg, 0x00);
+
+	return ret;
 }
 
 /**

commit 2f3abe6cbb6c963ac790b40936b6761c9f0497b4
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Nov 20 13:36:00 2012 +0000

    iio:imu: Add support for the ADIS16480 and similar IMUs
    
    This patch adds support for the ADIS16375, ADIS16480, ADIS16485, ADIS16488 6
    degree to 10 degree of freedom IMUs.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index c4ea04ffa60e..911255d41c1a 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -238,6 +238,9 @@ int adis_enable_irq(struct adis *adis, bool enable)
 	int ret = 0;
 	uint16_t msc;
 
+	if (adis->data->enable_irq)
+		return adis->data->enable_irq(adis, enable);
+
 	ret = adis_read_reg_16(adis, adis->data->msc_ctrl_reg, &msc);
 	if (ret)
 		goto error_ret;

commit 484a0bf091c93c379e6524a17bb037c33c898e01
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Nov 20 13:36:00 2012 +0000

    iio:imu:adis: Add paging support
    
    Some of the newer generation devices from the ADIS16XXX series have more
    registers than what can be supported with the current register addressing
    scheme. These devices implement register paging to support a larger register
    range. Each page is 128 registers large and the currently active page can be
    selected via register 0x00 in each page. This patch implements transparent
    paging inside the common adis library. The register read/write interface stays
    the same and when a register is accessed the library automatically switches to
    the correct page if it is not already selected. The page number is encoded in
    the upper bits of the register number, e.g. register 0x5 of page 1 is 0x85.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index 280a49584adf..c4ea04ffa60e 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -30,6 +30,7 @@
 int adis_write_reg(struct adis *adis, unsigned int reg,
 	unsigned int value, unsigned int size)
 {
+	unsigned int page = reg / ADIS_PAGE_SIZE;
 	int ret, i;
 	struct spi_message msg;
 	struct spi_transfer xfers[] = {
@@ -56,39 +57,53 @@ int adis_write_reg(struct adis *adis, unsigned int reg,
 			.bits_per_word = 8,
 			.len = 2,
 			.delay_usecs = adis->data->write_delay,
+		}, {
+			.tx_buf = adis->tx + 8,
+			.bits_per_word = 8,
+			.len = 2,
+			.delay_usecs = adis->data->write_delay,
 		},
 	};
 
 	mutex_lock(&adis->txrx_lock);
 
 	spi_message_init(&msg);
+
+	if (adis->current_page != page) {
+		adis->tx[0] = ADIS_WRITE_REG(ADIS_REG_PAGE_ID);
+		adis->tx[1] = page;
+		spi_message_add_tail(&xfers[0], &msg);
+	}
+
 	switch (size) {
 	case 4:
-		adis->tx[6] = ADIS_WRITE_REG(reg + 3);
-		adis->tx[7] = (value >> 24) & 0xff;
-		adis->tx[4] = ADIS_WRITE_REG(reg + 2);
-		adis->tx[5] = (value >> 16) & 0xff;
+		adis->tx[8] = ADIS_WRITE_REG(reg + 3);
+		adis->tx[9] = (value >> 24) & 0xff;
+		adis->tx[6] = ADIS_WRITE_REG(reg + 2);
+		adis->tx[7] = (value >> 16) & 0xff;
 	case 2:
-		adis->tx[2] = ADIS_WRITE_REG(reg + 1);
-		adis->tx[3] = (value >> 8) & 0xff;
+		adis->tx[4] = ADIS_WRITE_REG(reg + 1);
+		adis->tx[5] = (value >> 8) & 0xff;
 	case 1:
-		adis->tx[0] = ADIS_WRITE_REG(reg);
-		adis->tx[1] = value & 0xff;
+		adis->tx[2] = ADIS_WRITE_REG(reg);
+		adis->tx[3] = value & 0xff;
 		break;
 	default:
 		ret = -EINVAL;
 		goto out_unlock;
 	}
 
-	xfers[size - 1].cs_change = 0;
+	xfers[size].cs_change = 0;
 
-	for (i = 0; i < size; i++)
+	for (i = 1; i <= size; i++)
 		spi_message_add_tail(&xfers[i], &msg);
 
 	ret = spi_sync(adis->spi, &msg);
 	if (ret) {
 		dev_err(&adis->spi->dev, "Failed to write register 0x%02X: %d\n",
 				reg, ret);
+	} else {
+		adis->current_page = page;
 	}
 
 out_unlock:
@@ -107,6 +122,7 @@ EXPORT_SYMBOL_GPL(adis_write_reg);
 int adis_read_reg(struct adis *adis, unsigned int reg,
 	unsigned int *val, unsigned int size)
 {
+	unsigned int page = reg / ADIS_PAGE_SIZE;
 	struct spi_message msg;
 	int ret;
 	struct spi_transfer xfers[] = {
@@ -115,9 +131,15 @@ int adis_read_reg(struct adis *adis, unsigned int reg,
 			.bits_per_word = 8,
 			.len = 2,
 			.cs_change = 1,
-			.delay_usecs = adis->data->read_delay,
+			.delay_usecs = adis->data->write_delay,
 		}, {
 			.tx_buf = adis->tx + 2,
+			.bits_per_word = 8,
+			.len = 2,
+			.cs_change = 1,
+			.delay_usecs = adis->data->read_delay,
+		}, {
+			.tx_buf = adis->tx + 4,
 			.rx_buf = adis->rx,
 			.bits_per_word = 8,
 			.len = 2,
@@ -134,16 +156,22 @@ int adis_read_reg(struct adis *adis, unsigned int reg,
 	mutex_lock(&adis->txrx_lock);
 	spi_message_init(&msg);
 
+	if (adis->current_page != page) {
+		adis->tx[0] = ADIS_WRITE_REG(ADIS_REG_PAGE_ID);
+		adis->tx[1] = page;
+		spi_message_add_tail(&xfers[0], &msg);
+	}
+
 	switch (size) {
 	case 4:
-		adis->tx[0] = ADIS_READ_REG(reg + 2);
-		adis->tx[1] = 0;
-		spi_message_add_tail(&xfers[0], &msg);
-	case 2:
-		adis->tx[2] = ADIS_READ_REG(reg);
+		adis->tx[2] = ADIS_READ_REG(reg + 2);
 		adis->tx[3] = 0;
 		spi_message_add_tail(&xfers[1], &msg);
+	case 2:
+		adis->tx[4] = ADIS_READ_REG(reg);
+		adis->tx[5] = 0;
 		spi_message_add_tail(&xfers[2], &msg);
+		spi_message_add_tail(&xfers[3], &msg);
 		break;
 	default:
 		ret = -EINVAL;
@@ -155,6 +183,8 @@ int adis_read_reg(struct adis *adis, unsigned int reg,
 		dev_err(&adis->spi->dev, "Failed to read register 0x%02X: %d\n",
 				reg, ret);
 		goto out_unlock;
+	} else {
+		adis->current_page = page;
 	}
 
 	switch (size) {
@@ -390,6 +420,14 @@ int adis_init(struct adis *adis, struct iio_dev *indio_dev,
 	adis->data = data;
 	iio_device_set_drvdata(indio_dev, adis);
 
+	if (data->has_paging) {
+		/* Need to set the page before first read/write */
+		adis->current_page = -1;
+	} else {
+		/* Page will always be 0 */
+		adis->current_page = 0;
+	}
+
 	return adis_enable_irq(adis, false);
 }
 EXPORT_SYMBOL_GPL(adis_init);

commit 57a1228a06b7a5939a8b0078a92b44fa30855bcb
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Nov 20 13:36:00 2012 +0000

    iio:imu:adis: Add support for 32bit registers
    
    Some of the newer generation devices from the ADIS16XXX family have 32bit wide
    register which spans two 16bit wide registers. This patch adds support for
    reading and writing a 32bit wide register.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index 28d4df2fe76a..280a49584adf 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -27,36 +27,10 @@
 #define ADIS_MSC_CTRL_DATA_RDY_DIO2	BIT(0)
 #define ADIS_GLOB_CMD_SW_RESET		BIT(7)
 
-/**
- * adis_write_reg_8() - Write single byte to a register
- * @adis: The adis device
- * @reg: The address of the register to be written
- * @val: The value to write
- */
-int adis_write_reg_8(struct adis *adis, unsigned int reg, uint8_t val)
-{
-	int ret;
-
-	mutex_lock(&adis->txrx_lock);
-	adis->tx[0] = ADIS_WRITE_REG(reg);
-	adis->tx[1] = val;
-
-	ret = spi_write(adis->spi, adis->tx, 2);
-	mutex_unlock(&adis->txrx_lock);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(adis_write_reg_8);
-
-/**
- * adis_write_reg_16() - Write 2 bytes to a pair of registers
- * @adis: The adis device
- * @reg: The address of the lower of the two registers
- * @val: Value to be written
- */
-int adis_write_reg_16(struct adis *adis, unsigned int reg, uint16_t value)
+int adis_write_reg(struct adis *adis, unsigned int reg,
+	unsigned int value, unsigned int size)
 {
-	int ret;
+	int ret, i;
 	struct spi_message msg;
 	struct spi_transfer xfers[] = {
 		{
@@ -69,33 +43,69 @@ int adis_write_reg_16(struct adis *adis, unsigned int reg, uint16_t value)
 			.tx_buf = adis->tx + 2,
 			.bits_per_word = 8,
 			.len = 2,
+			.cs_change = 1,
+			.delay_usecs = adis->data->write_delay,
+		}, {
+			.tx_buf = adis->tx + 4,
+			.bits_per_word = 8,
+			.len = 2,
+			.cs_change = 1,
+			.delay_usecs = adis->data->write_delay,
+		}, {
+			.tx_buf = adis->tx + 6,
+			.bits_per_word = 8,
+			.len = 2,
 			.delay_usecs = adis->data->write_delay,
 		},
 	};
 
 	mutex_lock(&adis->txrx_lock);
-	adis->tx[0] = ADIS_WRITE_REG(reg);
-	adis->tx[1] = value & 0xff;
-	adis->tx[2] = ADIS_WRITE_REG(reg + 1);
-	adis->tx[3] = (value >> 8) & 0xff;
 
 	spi_message_init(&msg);
-	spi_message_add_tail(&xfers[0], &msg);
-	spi_message_add_tail(&xfers[1], &msg);
+	switch (size) {
+	case 4:
+		adis->tx[6] = ADIS_WRITE_REG(reg + 3);
+		adis->tx[7] = (value >> 24) & 0xff;
+		adis->tx[4] = ADIS_WRITE_REG(reg + 2);
+		adis->tx[5] = (value >> 16) & 0xff;
+	case 2:
+		adis->tx[2] = ADIS_WRITE_REG(reg + 1);
+		adis->tx[3] = (value >> 8) & 0xff;
+	case 1:
+		adis->tx[0] = ADIS_WRITE_REG(reg);
+		adis->tx[1] = value & 0xff;
+		break;
+	default:
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+
+	xfers[size - 1].cs_change = 0;
+
+	for (i = 0; i < size; i++)
+		spi_message_add_tail(&xfers[i], &msg);
+
 	ret = spi_sync(adis->spi, &msg);
+	if (ret) {
+		dev_err(&adis->spi->dev, "Failed to write register 0x%02X: %d\n",
+				reg, ret);
+	}
+
+out_unlock:
 	mutex_unlock(&adis->txrx_lock);
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(adis_write_reg_16);
+EXPORT_SYMBOL_GPL(adis_write_reg);
 
 /**
- * adis_read_reg_16() - read 2 bytes from a 16-bit register
+ * adis_read_reg() - read 2 bytes from a 16-bit register
  * @adis: The adis device
  * @reg: The address of the lower of the two registers
  * @val: The value read back from the device
  */
-int adis_read_reg_16(struct adis *adis, unsigned int reg, uint16_t *val)
+int adis_read_reg(struct adis *adis, unsigned int reg,
+	unsigned int *val, unsigned int size)
 {
 	struct spi_message msg;
 	int ret;
@@ -107,33 +117,61 @@ int adis_read_reg_16(struct adis *adis, unsigned int reg, uint16_t *val)
 			.cs_change = 1,
 			.delay_usecs = adis->data->read_delay,
 		}, {
+			.tx_buf = adis->tx + 2,
 			.rx_buf = adis->rx,
 			.bits_per_word = 8,
 			.len = 2,
+			.cs_change = 1,
+			.delay_usecs = adis->data->read_delay,
+		}, {
+			.rx_buf = adis->rx + 2,
+			.bits_per_word = 8,
+			.len = 2,
 			.delay_usecs = adis->data->read_delay,
 		},
 	};
 
 	mutex_lock(&adis->txrx_lock);
-	adis->tx[0] = ADIS_READ_REG(reg);
-	adis->tx[1] = 0;
-
 	spi_message_init(&msg);
-	spi_message_add_tail(&xfers[0], &msg);
-	spi_message_add_tail(&xfers[1], &msg);
+
+	switch (size) {
+	case 4:
+		adis->tx[0] = ADIS_READ_REG(reg + 2);
+		adis->tx[1] = 0;
+		spi_message_add_tail(&xfers[0], &msg);
+	case 2:
+		adis->tx[2] = ADIS_READ_REG(reg);
+		adis->tx[3] = 0;
+		spi_message_add_tail(&xfers[1], &msg);
+		spi_message_add_tail(&xfers[2], &msg);
+		break;
+	default:
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+
 	ret = spi_sync(adis->spi, &msg);
 	if (ret) {
-		dev_err(&adis->spi->dev, "Failed to read 16 bit register 0x%02X: %d\n",
+		dev_err(&adis->spi->dev, "Failed to read register 0x%02X: %d\n",
 				reg, ret);
-		goto error_ret;
+		goto out_unlock;
 	}
-	*val = get_unaligned_be16(adis->rx);
 
-error_ret:
+	switch (size) {
+	case 4:
+		*val = get_unaligned_be32(adis->rx);
+		break;
+	case 2:
+		*val = get_unaligned_be16(adis->rx + 2);
+		break;
+	}
+
+out_unlock:
 	mutex_unlock(&adis->txrx_lock);
+
 	return ret;
 }
-EXPORT_SYMBOL_GPL(adis_read_reg_16);
+EXPORT_SYMBOL_GPL(adis_read_reg);
 
 #ifdef CONFIG_DEBUG_FS
 
@@ -304,25 +342,26 @@ int adis_single_conversion(struct iio_dev *indio_dev,
 	const struct iio_chan_spec *chan, unsigned int error_mask, int *val)
 {
 	struct adis *adis = iio_device_get_drvdata(indio_dev);
-	uint16_t val16;
+	unsigned int uval;
 	int ret;
 
 	mutex_lock(&indio_dev->mlock);
 
-	ret = adis_read_reg_16(adis, chan->address, &val16);
+	ret = adis_read_reg(adis, chan->address, &uval,
+			chan->scan_type.storagebits / 8);
 	if (ret)
 		goto err_unlock;
 
-	if (val16 & error_mask) {
+	if (uval & error_mask) {
 		ret = adis_check_status(adis);
 		if (ret)
 			goto err_unlock;
 	}
 
 	if (chan->scan_type.sign == 's')
-		*val = sign_extend32(val16, chan->scan_type.realbits - 1);
+		*val = sign_extend32(uval, chan->scan_type.realbits - 1);
 	else
-		*val = val16 & ((1 << chan->scan_type.realbits) - 1);
+		*val = uval & ((1 << chan->scan_type.realbits) - 1);
 
 	ret = IIO_VAL_INT;
 err_unlock:

commit 78026a6fde8f7b0ca77c059da11f476d69dfde3b
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Nov 20 13:36:00 2012 +0000

    iio:imu:adis: Add debugfs register access support
    
    Provide a IIO debugfs register access function for the ADIS library. This
    function can be used by individual drivers to allow raw register access via
    debugfs.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
index 8259b774078f..28d4df2fe76a 100644
--- a/drivers/iio/imu/adis.c
+++ b/drivers/iio/imu/adis.c
@@ -135,6 +135,29 @@ int adis_read_reg_16(struct adis *adis, unsigned int reg, uint16_t *val)
 }
 EXPORT_SYMBOL_GPL(adis_read_reg_16);
 
+#ifdef CONFIG_DEBUG_FS
+
+int adis_debugfs_reg_access(struct iio_dev *indio_dev,
+	unsigned int reg, unsigned int writeval, unsigned int *readval)
+{
+	struct adis *adis = iio_device_get_drvdata(indio_dev);
+
+	if (readval) {
+		uint16_t val16;
+		int ret;
+
+		ret = adis_read_reg_16(adis, reg, &val16);
+		*readval = val16;
+
+		return ret;
+	} else {
+		return adis_write_reg_16(adis, reg, writeval);
+	}
+}
+EXPORT_SYMBOL(adis_debugfs_reg_access);
+
+#endif
+
 /**
  * adis_enable_irq() - Enable or disable data ready IRQ
  * @adis: The adis device

commit ec04cb048d79cd778c06e28f34395a46d774800d
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Nov 13 13:28:00 2012 +0000

    staging:iio: Move adis library out of staging
    
    Now that the adis library no longer depends on the sw_ring buffer implementation
    we can move it out of staging.
    
    While we are at it also sort the entries in the iio Kconfig and Makefile to be
    in alphabetical order.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/imu/adis.c b/drivers/iio/imu/adis.c
new file mode 100644
index 000000000000..8259b774078f
--- /dev/null
+++ b/drivers/iio/imu/adis.c
@@ -0,0 +1,337 @@
+/*
+ * Common library for ADIS16XXX devices
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *   Author: Lars-Peter Clausen <lars@metafoo.de>
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <linux/delay.h>
+#include <linux/mutex.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/spi/spi.h>
+#include <linux/slab.h>
+#include <linux/sysfs.h>
+#include <linux/module.h>
+#include <asm/unaligned.h>
+
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/imu/adis.h>
+
+#define ADIS_MSC_CTRL_DATA_RDY_EN	BIT(2)
+#define ADIS_MSC_CTRL_DATA_RDY_POL_HIGH	BIT(1)
+#define ADIS_MSC_CTRL_DATA_RDY_DIO2	BIT(0)
+#define ADIS_GLOB_CMD_SW_RESET		BIT(7)
+
+/**
+ * adis_write_reg_8() - Write single byte to a register
+ * @adis: The adis device
+ * @reg: The address of the register to be written
+ * @val: The value to write
+ */
+int adis_write_reg_8(struct adis *adis, unsigned int reg, uint8_t val)
+{
+	int ret;
+
+	mutex_lock(&adis->txrx_lock);
+	adis->tx[0] = ADIS_WRITE_REG(reg);
+	adis->tx[1] = val;
+
+	ret = spi_write(adis->spi, adis->tx, 2);
+	mutex_unlock(&adis->txrx_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(adis_write_reg_8);
+
+/**
+ * adis_write_reg_16() - Write 2 bytes to a pair of registers
+ * @adis: The adis device
+ * @reg: The address of the lower of the two registers
+ * @val: Value to be written
+ */
+int adis_write_reg_16(struct adis *adis, unsigned int reg, uint16_t value)
+{
+	int ret;
+	struct spi_message msg;
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = adis->tx,
+			.bits_per_word = 8,
+			.len = 2,
+			.cs_change = 1,
+			.delay_usecs = adis->data->write_delay,
+		}, {
+			.tx_buf = adis->tx + 2,
+			.bits_per_word = 8,
+			.len = 2,
+			.delay_usecs = adis->data->write_delay,
+		},
+	};
+
+	mutex_lock(&adis->txrx_lock);
+	adis->tx[0] = ADIS_WRITE_REG(reg);
+	adis->tx[1] = value & 0xff;
+	adis->tx[2] = ADIS_WRITE_REG(reg + 1);
+	adis->tx[3] = (value >> 8) & 0xff;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+	ret = spi_sync(adis->spi, &msg);
+	mutex_unlock(&adis->txrx_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(adis_write_reg_16);
+
+/**
+ * adis_read_reg_16() - read 2 bytes from a 16-bit register
+ * @adis: The adis device
+ * @reg: The address of the lower of the two registers
+ * @val: The value read back from the device
+ */
+int adis_read_reg_16(struct adis *adis, unsigned int reg, uint16_t *val)
+{
+	struct spi_message msg;
+	int ret;
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = adis->tx,
+			.bits_per_word = 8,
+			.len = 2,
+			.cs_change = 1,
+			.delay_usecs = adis->data->read_delay,
+		}, {
+			.rx_buf = adis->rx,
+			.bits_per_word = 8,
+			.len = 2,
+			.delay_usecs = adis->data->read_delay,
+		},
+	};
+
+	mutex_lock(&adis->txrx_lock);
+	adis->tx[0] = ADIS_READ_REG(reg);
+	adis->tx[1] = 0;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+	ret = spi_sync(adis->spi, &msg);
+	if (ret) {
+		dev_err(&adis->spi->dev, "Failed to read 16 bit register 0x%02X: %d\n",
+				reg, ret);
+		goto error_ret;
+	}
+	*val = get_unaligned_be16(adis->rx);
+
+error_ret:
+	mutex_unlock(&adis->txrx_lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(adis_read_reg_16);
+
+/**
+ * adis_enable_irq() - Enable or disable data ready IRQ
+ * @adis: The adis device
+ * @enable: Whether to enable the IRQ
+ *
+ * Returns 0 on success, negative error code otherwise
+ */
+int adis_enable_irq(struct adis *adis, bool enable)
+{
+	int ret = 0;
+	uint16_t msc;
+
+	ret = adis_read_reg_16(adis, adis->data->msc_ctrl_reg, &msc);
+	if (ret)
+		goto error_ret;
+
+	msc |= ADIS_MSC_CTRL_DATA_RDY_POL_HIGH;
+	msc &= ~ADIS_MSC_CTRL_DATA_RDY_DIO2;
+	if (enable)
+		msc |= ADIS_MSC_CTRL_DATA_RDY_EN;
+	else
+		msc &= ~ADIS_MSC_CTRL_DATA_RDY_EN;
+
+	ret = adis_write_reg_16(adis, adis->data->msc_ctrl_reg, msc);
+
+error_ret:
+	return ret;
+}
+EXPORT_SYMBOL(adis_enable_irq);
+
+/**
+ * adis_check_status() - Check the device for error conditions
+ * @adis: The adis device
+ *
+ * Returns 0 on success, a negative error code otherwise
+ */
+int adis_check_status(struct adis *adis)
+{
+	uint16_t status;
+	int ret;
+	int i;
+
+	ret = adis_read_reg_16(adis, adis->data->diag_stat_reg, &status);
+	if (ret < 0)
+		return ret;
+
+	status &= adis->data->status_error_mask;
+
+	if (status == 0)
+		return 0;
+
+	for (i = 0; i < 16; ++i) {
+		if (status & BIT(i)) {
+			dev_err(&adis->spi->dev, "%s.\n",
+				adis->data->status_error_msgs[i]);
+		}
+	}
+
+	return -EIO;
+}
+EXPORT_SYMBOL_GPL(adis_check_status);
+
+/**
+ * adis_reset() - Reset the device
+ * @adis: The adis device
+ *
+ * Returns 0 on success, a negative error code otherwise
+ */
+int adis_reset(struct adis *adis)
+{
+	int ret;
+
+	ret = adis_write_reg_8(adis, adis->data->glob_cmd_reg,
+			ADIS_GLOB_CMD_SW_RESET);
+	if (ret)
+		dev_err(&adis->spi->dev, "Failed to reset device: %d\n", ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(adis_reset);
+
+static int adis_self_test(struct adis *adis)
+{
+	int ret;
+
+	ret = adis_write_reg_16(adis, adis->data->msc_ctrl_reg,
+			adis->data->self_test_mask);
+	if (ret) {
+		dev_err(&adis->spi->dev, "Failed to initiate self test: %d\n",
+			ret);
+		return ret;
+	}
+
+	msleep(adis->data->startup_delay);
+
+	return adis_check_status(adis);
+}
+
+/**
+ * adis_inital_startup() - Performs device self-test
+ * @adis: The adis device
+ *
+ * Returns 0 if the device is operational, a negative error code otherwise.
+ *
+ * This function should be called early on in the device initialization sequence
+ * to ensure that the device is in a sane and known state and that it is usable.
+ */
+int adis_initial_startup(struct adis *adis)
+{
+	int ret;
+
+	ret = adis_self_test(adis);
+	if (ret) {
+		dev_err(&adis->spi->dev, "Self-test failed, trying reset.\n");
+		adis_reset(adis);
+		msleep(adis->data->startup_delay);
+		ret = adis_self_test(adis);
+		if (ret) {
+			dev_err(&adis->spi->dev, "Second self-test failed, giving up.\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(adis_initial_startup);
+
+/**
+ * adis_single_conversion() - Performs a single sample conversion
+ * @indio_dev: The IIO device
+ * @chan: The IIO channel
+ * @error_mask: Mask for the error bit
+ * @val: Result of the conversion
+ *
+ * Returns IIO_VAL_INT on success, a negative error code otherwise.
+ *
+ * The function performs a single conversion on a given channel and post
+ * processes the value accordingly to the channel spec. If a error_mask is given
+ * the function will check if the mask is set in the returned raw value. If it
+ * is set the function will perform a self-check. If the device does not report
+ * a error bit in the channels raw value set error_mask to 0.
+ */
+int adis_single_conversion(struct iio_dev *indio_dev,
+	const struct iio_chan_spec *chan, unsigned int error_mask, int *val)
+{
+	struct adis *adis = iio_device_get_drvdata(indio_dev);
+	uint16_t val16;
+	int ret;
+
+	mutex_lock(&indio_dev->mlock);
+
+	ret = adis_read_reg_16(adis, chan->address, &val16);
+	if (ret)
+		goto err_unlock;
+
+	if (val16 & error_mask) {
+		ret = adis_check_status(adis);
+		if (ret)
+			goto err_unlock;
+	}
+
+	if (chan->scan_type.sign == 's')
+		*val = sign_extend32(val16, chan->scan_type.realbits - 1);
+	else
+		*val = val16 & ((1 << chan->scan_type.realbits) - 1);
+
+	ret = IIO_VAL_INT;
+err_unlock:
+	mutex_unlock(&indio_dev->mlock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(adis_single_conversion);
+
+/**
+ * adis_init() - Initialize adis device structure
+ * @adis:	The adis device
+ * @indio_dev:	The iio device
+ * @spi:	The spi device
+ * @data:	Chip specific data
+ *
+ * Returns 0 on success, a negative error code otherwise.
+ *
+ * This function must be called, before any other adis helper function may be
+ * called.
+ */
+int adis_init(struct adis *adis, struct iio_dev *indio_dev,
+	struct spi_device *spi, const struct adis_data *data)
+{
+	mutex_init(&adis->txrx_lock);
+	adis->spi = spi;
+	adis->data = data;
+	iio_device_set_drvdata(indio_dev, adis);
+
+	return adis_enable_irq(adis, false);
+}
+EXPORT_SYMBOL_GPL(adis_init);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Lars-Peter Clausen <lars@metafoo.de>");
+MODULE_DESCRIPTION("Common library code for ADIS16XXX devices");
