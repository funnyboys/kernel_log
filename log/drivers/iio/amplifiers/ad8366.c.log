commit cc74a38d85fe295468e73452ca892e6d760dc33e
Author: Sergiu Cuciurean <sergiu.cuciurean@analog.com>
Date:   Fri Feb 21 18:18:26 2020 +0200

    iio: amplifiers: ad8366: add support for HMC1119 Attenuator
    
    This change adds support for the HMC1119 Silicon Digial Attenuator. The
    HMC1119 is a broadband, highly accurate, 7-bit digital attenuator,
    operating from 0.1 GHz to 6.0 GHz with 31.5 dB attenuation control range
    in 0.25 dB steps.
    
    Link: https://www.analog.com/media/en/technical-documentation/data-sheets/hmc1119.pdf
    
    Signed-off-by: Sergiu Cuciurean <sergiu.cuciurean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/amplifiers/ad8366.c b/drivers/iio/amplifiers/ad8366.c
index 95972ab60f42..62167b87caea 100644
--- a/drivers/iio/amplifiers/ad8366.c
+++ b/drivers/iio/amplifiers/ad8366.c
@@ -5,6 +5,7 @@
  *   AD8366 Dual-Digital Variable Gain Amplifier (VGA)
  *   ADA4961 BiCMOS RF Digital Gain Amplifier (DGA)
  *   ADL5240 Digitally controlled variable gain amplifier (VGA)
+ *   HMC1119 0.25 dB LSB, 7-Bit, Silicon Digital Attenuator
  *
  * Copyright 2012-2019 Analog Devices Inc.
  */
@@ -27,6 +28,7 @@ enum ad8366_type {
 	ID_AD8366,
 	ID_ADA4961,
 	ID_ADL5240,
+	ID_HMC1119,
 };
 
 struct ad8366_info {
@@ -62,6 +64,10 @@ static struct ad8366_info ad8366_infos[] = {
 		.gain_min = -11500,
 		.gain_max = 20000,
 	},
+	[ID_HMC1119] = {
+		.gain_min = -31750,
+		.gain_max = 0,
+	},
 };
 
 static int ad8366_write(struct iio_dev *indio_dev,
@@ -84,6 +90,9 @@ static int ad8366_write(struct iio_dev *indio_dev,
 	case ID_ADL5240:
 		st->data[0] = (ch_a & 0x3F);
 		break;
+	case ID_HMC1119:
+		st->data[0] = ch_a;
+		break;
 	}
 
 	ret = spi_write(st->spi, st->data, indio_dev->num_channels);
@@ -118,6 +127,9 @@ static int ad8366_read_raw(struct iio_dev *indio_dev,
 		case ID_ADL5240:
 			gain = 20000 - 31500 + code * 500;
 			break;
+		case ID_HMC1119:
+			gain = -1 * code * 250;
+			break;
 		}
 
 		/* Values in dB */
@@ -164,6 +176,9 @@ static int ad8366_write_raw(struct iio_dev *indio_dev,
 	case ID_ADL5240:
 		code = ((gain - 500 - 20000) / 500) & 0x3F;
 		break;
+	case ID_HMC1119:
+		code = (abs(gain) / 250) & 0x7F;
+		break;
 	}
 
 	mutex_lock(&st->lock);
@@ -246,6 +261,7 @@ static int ad8366_probe(struct spi_device *spi)
 		break;
 	case ID_ADA4961:
 	case ID_ADL5240:
+	case ID_HMC1119:
 		st->reset_gpio = devm_gpiod_get(&spi->dev, "reset",
 			GPIOD_OUT_HIGH);
 		indio_dev->channels = ada4961_channels;
@@ -298,6 +314,7 @@ static const struct spi_device_id ad8366_id[] = {
 	{"ad8366",  ID_AD8366},
 	{"ada4961", ID_ADA4961},
 	{"adl5240", ID_ADL5240},
+	{"hmc1119", ID_HMC1119},
 	{}
 };
 MODULE_DEVICE_TABLE(spi, ad8366_id);

commit 0cc97f2e46e0b374bbf7efc30bad638d8974cf1e
Author: Beniamin Bia <beniamin.bia@analog.com>
Date:   Thu Feb 6 17:11:46 2020 +0200

    iio: amplifiers: ad8366: Add write_raw_get_fmt function
    
    This patch add write_raw_get_fmt function to specify conversion for
    hardware gain.
    
    Signed-off-by: Beniamin Bia <beniamin.bia@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/amplifiers/ad8366.c b/drivers/iio/amplifiers/ad8366.c
index 0176d3d8cc9c..95972ab60f42 100644
--- a/drivers/iio/amplifiers/ad8366.c
+++ b/drivers/iio/amplifiers/ad8366.c
@@ -180,9 +180,22 @@ static int ad8366_write_raw(struct iio_dev *indio_dev,
 	return ret;
 }
 
+static int ad8366_write_raw_get_fmt(struct iio_dev *indio_dev,
+				    struct iio_chan_spec const *chan,
+				    long mask)
+{
+	switch (mask) {
+	case IIO_CHAN_INFO_HARDWAREGAIN:
+		return IIO_VAL_INT_PLUS_MICRO_DB;
+	default:
+		return -EINVAL;
+	}
+}
+
 static const struct iio_info ad8366_info = {
 	.read_raw = &ad8366_read_raw,
 	.write_raw = &ad8366_write_raw,
+	.write_raw_get_fmt = &ad8366_write_raw_get_fmt,
 };
 
 #define AD8366_CHAN(_channel) {				\

commit 075da9cd6aa503e05c86f2bbd29b539d1b145644
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu May 30 16:18:12 2019 +0300

    iio: amplifiers: ad8366: Add support for ADL5240 VGA
    
    The ADL5240 is a high performance, digitally controlled variable gain
    amplifier (VGA) operating from 100 MHz to 4000 MHz. The VGA integrates a
    high performance, 20 dB gain, internally matched amplifier (AMP) with a
    6-bit digital step attenuator (DSA) that has a gain control range of
    31.5 dB in 0.5 dB steps with Â±0.25 dB step accuracy.
    
    Datasheet link:
      https://www.analog.com/media/en/technical-documentation/data-sheets/adl5240.pdf
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/amplifiers/ad8366.c b/drivers/iio/amplifiers/ad8366.c
index 0a9883e8eb2e..0176d3d8cc9c 100644
--- a/drivers/iio/amplifiers/ad8366.c
+++ b/drivers/iio/amplifiers/ad8366.c
@@ -4,6 +4,7 @@
  * This driver supports the following gain amplifiers:
  *   AD8366 Dual-Digital Variable Gain Amplifier (VGA)
  *   ADA4961 BiCMOS RF Digital Gain Amplifier (DGA)
+ *   ADL5240 Digitally controlled variable gain amplifier (VGA)
  *
  * Copyright 2012-2019 Analog Devices Inc.
  */
@@ -25,6 +26,7 @@
 enum ad8366_type {
 	ID_AD8366,
 	ID_ADA4961,
+	ID_ADL5240,
 };
 
 struct ad8366_info {
@@ -56,6 +58,10 @@ static struct ad8366_info ad8366_infos[] = {
 		.gain_min = -6000,
 		.gain_max = 15000,
 	},
+	[ID_ADL5240] = {
+		.gain_min = -11500,
+		.gain_max = 20000,
+	},
 };
 
 static int ad8366_write(struct iio_dev *indio_dev,
@@ -75,6 +81,9 @@ static int ad8366_write(struct iio_dev *indio_dev,
 	case ID_ADA4961:
 		st->data[0] = ch_a & 0x1F;
 		break;
+	case ID_ADL5240:
+		st->data[0] = (ch_a & 0x3F);
+		break;
 	}
 
 	ret = spi_write(st->spi, st->data, indio_dev->num_channels);
@@ -106,6 +115,9 @@ static int ad8366_read_raw(struct iio_dev *indio_dev,
 		case ID_ADA4961:
 			gain = 15000 - code * 1000;
 			break;
+		case ID_ADL5240:
+			gain = 20000 - 31500 + code * 500;
+			break;
 		}
 
 		/* Values in dB */
@@ -149,6 +161,9 @@ static int ad8366_write_raw(struct iio_dev *indio_dev,
 	case ID_ADA4961:
 		code = (15000 - gain) / 1000;
 		break;
+	case ID_ADL5240:
+		code = ((gain - 500 - 20000) / 500) & 0x3F;
+		break;
 	}
 
 	mutex_lock(&st->lock);
@@ -217,6 +232,7 @@ static int ad8366_probe(struct spi_device *spi)
 		indio_dev->num_channels = ARRAY_SIZE(ad8366_channels);
 		break;
 	case ID_ADA4961:
+	case ID_ADL5240:
 		st->reset_gpio = devm_gpiod_get(&spi->dev, "reset",
 			GPIOD_OUT_HIGH);
 		indio_dev->channels = ada4961_channels;
@@ -268,6 +284,7 @@ static int ad8366_remove(struct spi_device *spi)
 static const struct spi_device_id ad8366_id[] = {
 	{"ad8366",  ID_AD8366},
 	{"ada4961", ID_ADA4961},
+	{"adl5240", ID_ADL5240},
 	{}
 };
 MODULE_DEVICE_TABLE(spi, ad8366_id);

commit cee211f4e5a0f70ee0c202e9a5fc8eac0b9b4945
Author: Paul Cercueil <paul.cercueil@analog.com>
Date:   Thu May 30 16:18:11 2019 +0300

    iio: amplifiers: ad8366: Add support for the ADA4961 DGA
    
    This change adds support for the ADA4961 BiCMOS RF Digital Gain Amplifier,
    (DGA), which is optimized for driving heavy loads out 2.0 GHz and beyond.
    The device typically achieves -90 dBc IMD3 performance at 500 MHz and
    -85  dBc at 1.5 GHz.
    
    Datasheet link:
     http://www.analog.com/media/en/technical-documentation/data-sheets/ADA4961.pdf
    
    This change re-uses the existing ad8366 driver, as most logic is similar.
    Also, this chip has a reset pin which is initialized during probe.
    
    Signed-off-by: Paul Cercueil <paul.cercueil@analog.com>
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/amplifiers/ad8366.c b/drivers/iio/amplifiers/ad8366.c
index 1beda6409301..0a9883e8eb2e 100644
--- a/drivers/iio/amplifiers/ad8366.c
+++ b/drivers/iio/amplifiers/ad8366.c
@@ -1,6 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
- * AD8366 SPI Dual-Digital Variable Gain Amplifier (VGA)
+ * AD8366 and similar Gain Amplifiers
+ * This driver supports the following gain amplifiers:
+ *   AD8366 Dual-Digital Variable Gain Amplifier (VGA)
+ *   ADA4961 BiCMOS RF Digital Gain Amplifier (DGA)
  *
  * Copyright 2012-2019 Analog Devices Inc.
  */
@@ -11,6 +14,7 @@
 #include <linux/sysfs.h>
 #include <linux/spi/spi.h>
 #include <linux/regulator/consumer.h>
+#include <linux/gpio/consumer.h>
 #include <linux/err.h>
 #include <linux/module.h>
 #include <linux/bitrev.h>
@@ -20,6 +24,7 @@
 
 enum ad8366_type {
 	ID_AD8366,
+	ID_ADA4961,
 };
 
 struct ad8366_info {
@@ -31,6 +36,7 @@ struct ad8366_state {
 	struct spi_device	*spi;
 	struct regulator	*reg;
 	struct mutex            lock; /* protect sensor state */
+	struct gpio_desc	*reset_gpio;
 	unsigned char		ch[2];
 	enum ad8366_type	type;
 	struct ad8366_info	*info;
@@ -46,6 +52,10 @@ static struct ad8366_info ad8366_infos[] = {
 		.gain_min = 4500,
 		.gain_max = 20500,
 	},
+	[ID_ADA4961] = {
+		.gain_min = -6000,
+		.gain_max = 15000,
+	},
 };
 
 static int ad8366_write(struct iio_dev *indio_dev,
@@ -62,6 +72,9 @@ static int ad8366_write(struct iio_dev *indio_dev,
 		st->data[0] = ch_b >> 4;
 		st->data[1] = (ch_b << 4) | (ch_a >> 2);
 		break;
+	case ID_ADA4961:
+		st->data[0] = ch_a & 0x1F;
+		break;
 	}
 
 	ret = spi_write(st->spi, st->data, indio_dev->num_channels);
@@ -90,6 +103,9 @@ static int ad8366_read_raw(struct iio_dev *indio_dev,
 		case ID_AD8366:
 			gain = code * 253 + 4500;
 			break;
+		case ID_ADA4961:
+			gain = 15000 - code * 1000;
+			break;
 		}
 
 		/* Values in dB */
@@ -130,6 +146,9 @@ static int ad8366_write_raw(struct iio_dev *indio_dev,
 	case ID_AD8366:
 		code = (gain - 4500) / 253;
 		break;
+	case ID_ADA4961:
+		code = (15000 - gain) / 1000;
+		break;
 	}
 
 	mutex_lock(&st->lock);
@@ -164,6 +183,10 @@ static const struct iio_chan_spec ad8366_channels[] = {
 	AD8366_CHAN(1),
 };
 
+static const struct iio_chan_spec ada4961_channels[] = {
+	AD8366_CHAN(0),
+};
+
 static int ad8366_probe(struct spi_device *spi)
 {
 	struct iio_dev *indio_dev;
@@ -193,6 +216,12 @@ static int ad8366_probe(struct spi_device *spi)
 		indio_dev->channels = ad8366_channels;
 		indio_dev->num_channels = ARRAY_SIZE(ad8366_channels);
 		break;
+	case ID_ADA4961:
+		st->reset_gpio = devm_gpiod_get(&spi->dev, "reset",
+			GPIOD_OUT_HIGH);
+		indio_dev->channels = ada4961_channels;
+		indio_dev->num_channels = ARRAY_SIZE(ada4961_channels);
+		break;
 	default:
 		dev_err(&spi->dev, "Invalid device ID\n");
 		ret = -EINVAL;
@@ -238,6 +267,7 @@ static int ad8366_remove(struct spi_device *spi)
 
 static const struct spi_device_id ad8366_id[] = {
 	{"ad8366",  ID_AD8366},
+	{"ada4961", ID_ADA4961},
 	{}
 };
 MODULE_DEVICE_TABLE(spi, ad8366_id);
@@ -254,5 +284,5 @@ static struct spi_driver ad8366_driver = {
 module_spi_driver(ad8366_driver);
 
 MODULE_AUTHOR("Michael Hennerich <michael.hennerich@analog.com>");
-MODULE_DESCRIPTION("Analog Devices AD8366 VGA");
+MODULE_DESCRIPTION("Analog Devices AD8366 and similar Gain Amplifiers");
 MODULE_LICENSE("GPL v2");

commit 11ab555a6d3b0ecbb51076af79e625303bfa61de
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu May 30 16:18:10 2019 +0300

    iio: amplifiers: ad8366: rework driver to allow other chips
    
    The SPI gain amplifiers are simple devices, with 1 or 2 channels, to which
    are read-from/written-to.
    
    The gain computation in ad8366_write_raw() has been updated to compute gain
    in dB for negative values.
    
    This driver will be extended to support other chips as well.
    To do that, this rework handles the AD8366 device as a special-case (via
    switch-statements). This will make things easier when adding new chips.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/amplifiers/ad8366.c b/drivers/iio/amplifiers/ad8366.c
index 24ff5475d9f2..1beda6409301 100644
--- a/drivers/iio/amplifiers/ad8366.c
+++ b/drivers/iio/amplifiers/ad8366.c
@@ -18,11 +18,22 @@
 #include <linux/iio/iio.h>
 #include <linux/iio/sysfs.h>
 
+enum ad8366_type {
+	ID_AD8366,
+};
+
+struct ad8366_info {
+	int gain_min;
+	int gain_max;
+};
+
 struct ad8366_state {
 	struct spi_device	*spi;
 	struct regulator	*reg;
 	struct mutex            lock; /* protect sensor state */
 	unsigned char		ch[2];
+	enum ad8366_type	type;
+	struct ad8366_info	*info;
 	/*
 	 * DMA (thus cache coherency maintenance) requires the
 	 * transfer buffers to live in their own cache lines.
@@ -30,19 +41,30 @@ struct ad8366_state {
 	unsigned char		data[2] ____cacheline_aligned;
 };
 
+static struct ad8366_info ad8366_infos[] = {
+	[ID_AD8366] = {
+		.gain_min = 4500,
+		.gain_max = 20500,
+	},
+};
+
 static int ad8366_write(struct iio_dev *indio_dev,
 			unsigned char ch_a, unsigned char ch_b)
 {
 	struct ad8366_state *st = iio_priv(indio_dev);
 	int ret;
 
-	ch_a = bitrev8(ch_a & 0x3F);
-	ch_b = bitrev8(ch_b & 0x3F);
+	switch (st->type) {
+	case ID_AD8366:
+		ch_a = bitrev8(ch_a & 0x3F);
+		ch_b = bitrev8(ch_b & 0x3F);
 
-	st->data[0] = ch_b >> 4;
-	st->data[1] = (ch_b << 4) | (ch_a >> 2);
+		st->data[0] = ch_b >> 4;
+		st->data[1] = (ch_b << 4) | (ch_a >> 2);
+		break;
+	}
 
-	ret = spi_write(st->spi, st->data, ARRAY_SIZE(st->data));
+	ret = spi_write(st->spi, st->data, indio_dev->num_channels);
 	if (ret < 0)
 		dev_err(&indio_dev->dev, "write failed (%d)", ret);
 
@@ -57,17 +79,22 @@ static int ad8366_read_raw(struct iio_dev *indio_dev,
 {
 	struct ad8366_state *st = iio_priv(indio_dev);
 	int ret;
-	unsigned code;
+	int code, gain = 0;
 
 	mutex_lock(&st->lock);
 	switch (m) {
 	case IIO_CHAN_INFO_HARDWAREGAIN:
 		code = st->ch[chan->channel];
 
+		switch (st->type) {
+		case ID_AD8366:
+			gain = code * 253 + 4500;
+			break;
+		}
+
 		/* Values in dB */
-		code = code * 253 + 4500;
-		*val = code / 1000;
-		*val2 = (code % 1000) * 1000;
+		*val = gain / 1000;
+		*val2 = (gain % 1000) * 1000;
 
 		ret = IIO_VAL_INT_PLUS_MICRO_DB;
 		break;
@@ -86,19 +113,24 @@ static int ad8366_write_raw(struct iio_dev *indio_dev,
 			    long mask)
 {
 	struct ad8366_state *st = iio_priv(indio_dev);
-	unsigned code;
+	struct ad8366_info *inf = st->info;
+	int code = 0, gain;
 	int ret;
 
-	if (val < 0 || val2 < 0)
-		return -EINVAL;
-
 	/* Values in dB */
-	code = (((u8)val * 1000) + ((u32)val2 / 1000));
+	if (val < 0)
+		gain = (val * 1000) - (val2 / 1000);
+	else
+		gain = (val * 1000) + (val2 / 1000);
 
-	if (code > 20500 || code < 4500)
+	if (gain > inf->gain_max || gain < inf->gain_min)
 		return -EINVAL;
 
-	code = (code - 4500) / 253;
+	switch (st->type) {
+	case ID_AD8366:
+		code = (gain - 4500) / 253;
+		break;
+	}
 
 	mutex_lock(&st->lock);
 	switch (mask) {
@@ -154,13 +186,24 @@ static int ad8366_probe(struct spi_device *spi)
 	spi_set_drvdata(spi, indio_dev);
 	mutex_init(&st->lock);
 	st->spi = spi;
+	st->type = spi_get_device_id(spi)->driver_data;
+
+	switch (st->type) {
+	case ID_AD8366:
+		indio_dev->channels = ad8366_channels;
+		indio_dev->num_channels = ARRAY_SIZE(ad8366_channels);
+		break;
+	default:
+		dev_err(&spi->dev, "Invalid device ID\n");
+		ret = -EINVAL;
+		goto error_disable_reg;
+	}
 
+	st->info = &ad8366_infos[st->type];
 	indio_dev->dev.parent = &spi->dev;
 	indio_dev->name = spi_get_device_id(spi)->name;
 	indio_dev->info = &ad8366_info;
 	indio_dev->modes = INDIO_DIRECT_MODE;
-	indio_dev->channels = ad8366_channels;
-	indio_dev->num_channels = ARRAY_SIZE(ad8366_channels);
 
 	ret = ad8366_write(indio_dev, 0 , 0);
 	if (ret < 0)
@@ -194,7 +237,7 @@ static int ad8366_remove(struct spi_device *spi)
 }
 
 static const struct spi_device_id ad8366_id[] = {
-	{"ad8366", 0},
+	{"ad8366",  ID_AD8366},
 	{}
 };
 MODULE_DEVICE_TABLE(spi, ad8366_id);

commit dbcf6b5d2625b904f13810b168773b05d891204b
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu May 30 16:18:09 2019 +0300

    iio: amplifiers: ad8366: use own lock to guard state
    
    This driver is still using iio_dev's mlock to guard against inconsistent
    state. This has been discouraged for some time.
    
    This change switches to using it's own mutex, defined on the state struct.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/amplifiers/ad8366.c b/drivers/iio/amplifiers/ad8366.c
index 82ac15914ff3..24ff5475d9f2 100644
--- a/drivers/iio/amplifiers/ad8366.c
+++ b/drivers/iio/amplifiers/ad8366.c
@@ -21,6 +21,7 @@
 struct ad8366_state {
 	struct spi_device	*spi;
 	struct regulator	*reg;
+	struct mutex            lock; /* protect sensor state */
 	unsigned char		ch[2];
 	/*
 	 * DMA (thus cache coherency maintenance) requires the
@@ -58,7 +59,7 @@ static int ad8366_read_raw(struct iio_dev *indio_dev,
 	int ret;
 	unsigned code;
 
-	mutex_lock(&indio_dev->mlock);
+	mutex_lock(&st->lock);
 	switch (m) {
 	case IIO_CHAN_INFO_HARDWAREGAIN:
 		code = st->ch[chan->channel];
@@ -73,7 +74,7 @@ static int ad8366_read_raw(struct iio_dev *indio_dev,
 	default:
 		ret = -EINVAL;
 	}
-	mutex_unlock(&indio_dev->mlock);
+	mutex_unlock(&st->lock);
 
 	return ret;
 };
@@ -99,7 +100,7 @@ static int ad8366_write_raw(struct iio_dev *indio_dev,
 
 	code = (code - 4500) / 253;
 
-	mutex_lock(&indio_dev->mlock);
+	mutex_lock(&st->lock);
 	switch (mask) {
 	case IIO_CHAN_INFO_HARDWAREGAIN:
 		st->ch[chan->channel] = code;
@@ -108,7 +109,7 @@ static int ad8366_write_raw(struct iio_dev *indio_dev,
 	default:
 		ret = -EINVAL;
 	}
-	mutex_unlock(&indio_dev->mlock);
+	mutex_unlock(&st->lock);
 
 	return ret;
 }
@@ -151,6 +152,7 @@ static int ad8366_probe(struct spi_device *spi)
 	}
 
 	spi_set_drvdata(spi, indio_dev);
+	mutex_init(&st->lock);
 	st->spi = spi;
 
 	indio_dev->dev.parent = &spi->dev;

commit 38ffa3a34cb04c378c32c04337d0b98247a04012
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu May 30 16:18:08 2019 +0300

    iio: amplifiers: update license information
    
    Use the new `SPDX-License-Identifier` tag to specify the license.
    For ad8366, also update copyright years in the header part.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/amplifiers/ad8366.c b/drivers/iio/amplifiers/ad8366.c
index 4b76b61ba4be..82ac15914ff3 100644
--- a/drivers/iio/amplifiers/ad8366.c
+++ b/drivers/iio/amplifiers/ad8366.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * AD8366 SPI Dual-Digital Variable Gain Amplifier (VGA)
  *
- * Copyright 2012 Analog Devices Inc.
- *
- * Licensed under the GPL-2.
+ * Copyright 2012-2019 Analog Devices Inc.
  */
 
 #include <linux/device.h>

commit 9920ed25eccc9b494926be5372ba745db83481ab
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Tue Aug 14 13:23:17 2018 +0200

    drivers: iio: Update MODULE AUTHOR email address
    
    no functional changes
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/amplifiers/ad8366.c b/drivers/iio/amplifiers/ad8366.c
index 0138337aedd1..4b76b61ba4be 100644
--- a/drivers/iio/amplifiers/ad8366.c
+++ b/drivers/iio/amplifiers/ad8366.c
@@ -209,6 +209,6 @@ static struct spi_driver ad8366_driver = {
 
 module_spi_driver(ad8366_driver);
 
-MODULE_AUTHOR("Michael Hennerich <hennerich@blackfin.uclinux.org>");
+MODULE_AUTHOR("Michael Hennerich <michael.hennerich@analog.com>");
 MODULE_DESCRIPTION("Analog Devices AD8366 VGA");
 MODULE_LICENSE("GPL v2");

commit 2636d005758928c2884ac610589f383c73919bcf
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Mon May 21 09:40:05 2018 +0300

    iio: amplifiers: ad8366: move channel init before iio_device_register()
    
    Otherwise a race condition can occur, where userspace can start operations
    before the channels have been properly initialized.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/amplifiers/ad8366.c b/drivers/iio/amplifiers/ad8366.c
index 43667866321e..0138337aedd1 100644
--- a/drivers/iio/amplifiers/ad8366.c
+++ b/drivers/iio/amplifiers/ad8366.c
@@ -161,12 +161,14 @@ static int ad8366_probe(struct spi_device *spi)
 	indio_dev->channels = ad8366_channels;
 	indio_dev->num_channels = ARRAY_SIZE(ad8366_channels);
 
+	ret = ad8366_write(indio_dev, 0 , 0);
+	if (ret < 0)
+		goto error_disable_reg;
+
 	ret = iio_device_register(indio_dev);
 	if (ret)
 		goto error_disable_reg;
 
-	ad8366_write(indio_dev, 0, 0);
-
 	return 0;
 
 error_disable_reg:

commit 727929797f71b6cc32c685a27ff3189740af09dc
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sun Jul 23 17:25:49 2017 +0100

    iio:amplifiers:ad8366 drop assign iio_info.driver_module and iio_trigger_ops.owner
    
    The equivalent of both of these are now done via macro magic when
    the relevant register calls are made.  The actual structure
    elements will shortly go away.
    
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>

diff --git a/drivers/iio/amplifiers/ad8366.c b/drivers/iio/amplifiers/ad8366.c
index 102c7174da5b..43667866321e 100644
--- a/drivers/iio/amplifiers/ad8366.c
+++ b/drivers/iio/amplifiers/ad8366.c
@@ -117,7 +117,6 @@ static int ad8366_write_raw(struct iio_dev *indio_dev,
 static const struct iio_info ad8366_info = {
 	.read_raw = &ad8366_read_raw,
 	.write_raw = &ad8366_write_raw,
-	.driver_module = THIS_MODULE,
 };
 
 #define AD8366_CHAN(_channel) {				\

commit 75f5db39ff14ed95056f2cca3ad98c3cae97170c
Merge: 52787e91bf53 c70efb851531
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 5 13:15:12 2015 -0800

    Merge tag 'spi-v4.4' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi
    
    Pull spi updates from Mark Brown:
     "Quite a lot of activity in SPI this cycle, almost all of it in drivers
      with a few minor improvements and tweaks in the core.
    
       - Updates to pxa2xx to support Intel Broxton and multiple chip selects.
       - Support for big endian in the bcm63xx driver.
       - Multiple slave support for the mt8173
       - New driver for the auxiliary SPI controller in bcm2835 SoCs.
       - Support for Layerscale SoCs in the Freescale DSPI driver"
    
    * tag 'spi-v4.4' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi: (87 commits)
      spi: pxa2xx: Rework self-initiated platform data creation for non-ACPI
      spi: pxa2xx: Add support for Intel Broxton
      spi: pxa2xx: Detect number of enabled Intel LPSS SPI chip select signals
      spi: pxa2xx: Add output control for multiple Intel LPSS chip selects
      spi: pxa2xx: Use LPSS prefix for defines that are Intel LPSS specific
      spi: Add DSPI support for layerscape family
      spi: ti-qspi: improve ->remove() callback
      spi/spi-xilinx: Fix race condition on last word read
      spi: Drop owner assignment from spi_drivers
      spi: Add THIS_MODULE to spi_driver in SPI core
      spi: Setup the master controller driver before setting the chipselect
      spi: dw: replace magic constant by DW_SPI_DR
      spi: mediatek: mt8173 spi multiple devices support
      spi: mediatek: handle controller_data in mtk_spi_setup
      spi: mediatek: remove mtk_spi_config
      spi: mediatek: Update document devicetree bindings to support multiple devices
      spi: fix kernel-doc warnings about missing return desc in spi.c
      spi: fix kernel-doc warnings about missing return desc in spi.h
      spi: pxa2xx: Align a few defines
      spi: pxa2xx: Save other reg_cs_ctrl bits when configuring chip select
      ...

commit 3821a065f5672c430a088ae68b4da2a2d2b34106
Author: Andrew F. Davis <afd@ti.com>
Date:   Fri Oct 23 08:59:11 2015 -0500

    spi: Drop owner assignment from spi_drivers
    
    An spi_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/iio/amplifiers/ad8366.c b/drivers/iio/amplifiers/ad8366.c
index c0d364ebaea8..6da31e4dbdd4 100644
--- a/drivers/iio/amplifiers/ad8366.c
+++ b/drivers/iio/amplifiers/ad8366.c
@@ -199,7 +199,6 @@ static const struct spi_device_id ad8366_id[] = {
 static struct spi_driver ad8366_driver = {
 	.driver = {
 		.name	= KBUILD_MODNAME,
-		.owner	= THIS_MODULE,
 	},
 	.probe		= ad8366_probe,
 	.remove		= ad8366_remove,

commit ed199a11bdfd2957e46984b77a1e1f0927dc9fa0
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Thu Aug 20 09:07:14 2015 +0200

    iio: Export SPI module alias information in missing drivers
    
    The SPI core always reports the MODALIAS uevent as "spi:<modalias>"
    regardless of the mechanism that was used to register the device
    (i.e: OF or board code) and the table that is used later to match
    the driver with the device (i.e: SPI id table or OF match table).
    
    So drivers needs to export the SPI id table and this be built into
    the module or udev won't have the necessary information to autoload
    the needed driver module when the device is added.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Acked-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/amplifiers/ad8366.c b/drivers/iio/amplifiers/ad8366.c
index c0d364ebaea8..32b82a2dc894 100644
--- a/drivers/iio/amplifiers/ad8366.c
+++ b/drivers/iio/amplifiers/ad8366.c
@@ -195,6 +195,7 @@ static const struct spi_device_id ad8366_id[] = {
 	{"ad8366", 0},
 	{}
 };
+MODULE_DEVICE_TABLE(spi, ad8366_id);
 
 static struct spi_driver ad8366_driver = {
 	.driver = {

commit ff6f46295d81fab7ef7379761ea87ba71cc13fce
Author: Roberta Dobrescu <roberta.dobrescu@gmail.com>
Date:   Tue Dec 30 20:45:44 2014 +0200

    iio: amplifiers: ad8366: Use right order for type specification
    
    This patch fixes the following checkpatch.pl warning:
    WARNING: type 'char unsigned' should be specified in [[un]signed]
    [short|int|long|long long] order
    
    Signed-off-by: Roberta Dobrescu <roberta.dobrescu@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/amplifiers/ad8366.c b/drivers/iio/amplifiers/ad8366.c
index fce25a0ac372..c0d364ebaea8 100644
--- a/drivers/iio/amplifiers/ad8366.c
+++ b/drivers/iio/amplifiers/ad8366.c
@@ -31,7 +31,7 @@ struct ad8366_state {
 };
 
 static int ad8366_write(struct iio_dev *indio_dev,
-			unsigned char ch_a, char unsigned ch_b)
+			unsigned char ch_a, unsigned char ch_b)
 {
 	struct ad8366_state *st = iio_priv(indio_dev);
 	int ret;

commit c5878d9dbb959538d09faf9ad5f359e645de4d95
Author: Roberta Dobrescu <roberta.dobrescu@gmail.com>
Date:   Tue Dec 30 20:45:43 2014 +0200

    iio: amplifiers: ad8366: Remove space before ','
    
    This patch fixes the following checkpatch.pl error:
    ERROR: space prohibited before that ',' (ctx:WxW)
    
    Signed-off-by: Roberta Dobrescu <roberta.dobrescu@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/amplifiers/ad8366.c b/drivers/iio/amplifiers/ad8366.c
index ba6f6a91dfff..fce25a0ac372 100644
--- a/drivers/iio/amplifiers/ad8366.c
+++ b/drivers/iio/amplifiers/ad8366.c
@@ -166,7 +166,7 @@ static int ad8366_probe(struct spi_device *spi)
 	if (ret)
 		goto error_disable_reg;
 
-	ad8366_write(indio_dev, 0 , 0);
+	ad8366_write(indio_dev, 0, 0);
 
 	return 0;
 

commit d3789c3ee2e2b7e8c9b6043e9e8715d6d1e80299
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Tue Sep 24 12:49:00 2013 +0100

    iio: amplifiers: ad8366: Remove regulator_put
    
    Since devm_regulator_get is used, regulator_put should not be
    used. Remove it.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/amplifiers/ad8366.c b/drivers/iio/amplifiers/ad8366.c
index d0a79a4bce1c..ba6f6a91dfff 100644
--- a/drivers/iio/amplifiers/ad8366.c
+++ b/drivers/iio/amplifiers/ad8366.c
@@ -185,10 +185,8 @@ static int ad8366_remove(struct spi_device *spi)
 
 	iio_device_unregister(indio_dev);
 
-	if (!IS_ERR(reg)) {
+	if (!IS_ERR(reg))
 		regulator_disable(reg);
-		regulator_put(reg);
-	}
 
 	return 0;
 }

commit 36db8c72169489eedca06fe308b1643256d8c4fe
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Tue Jul 30 07:24:00 2013 +0100

    iio: amplifiers: ad8366: Use devm_* APIs
    
    devm_* APIs are device managed and make code simpler.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Cc: Michael Hennerich <hennerich@blackfin.uclinux.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/amplifiers/ad8366.c b/drivers/iio/amplifiers/ad8366.c
index d354554b51b3..d0a79a4bce1c 100644
--- a/drivers/iio/amplifiers/ad8366.c
+++ b/drivers/iio/amplifiers/ad8366.c
@@ -139,17 +139,17 @@ static int ad8366_probe(struct spi_device *spi)
 	struct ad8366_state *st;
 	int ret;
 
-	indio_dev = iio_device_alloc(sizeof(*st));
+	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
 	if (indio_dev == NULL)
 		return -ENOMEM;
 
 	st = iio_priv(indio_dev);
 
-	st->reg = regulator_get(&spi->dev, "vcc");
+	st->reg = devm_regulator_get(&spi->dev, "vcc");
 	if (!IS_ERR(st->reg)) {
 		ret = regulator_enable(st->reg);
 		if (ret)
-			goto error_put_reg;
+			return ret;
 	}
 
 	spi_set_drvdata(spi, indio_dev);
@@ -173,11 +173,6 @@ static int ad8366_probe(struct spi_device *spi)
 error_disable_reg:
 	if (!IS_ERR(st->reg))
 		regulator_disable(st->reg);
-error_put_reg:
-	if (!IS_ERR(st->reg))
-		regulator_put(st->reg);
-
-	iio_device_free(indio_dev);
 
 	return ret;
 }
@@ -195,8 +190,6 @@ static int ad8366_remove(struct spi_device *spi)
 		regulator_put(reg);
 	}
 
-	iio_device_free(indio_dev);
-
 	return 0;
 }
 

commit b34ec6f34797a91eb87a016ecdff1a52a566b711
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Wed Feb 27 19:08:08 2013 +0000

    iio:amplifiers:ad8366 move to info_mask_(shared_by_type/separate)
    
    The original info_mask is going away in favour of the broken out versions.
    
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Acked-by: Michael Hennerich <michael.hennerich@analog.com>

diff --git a/drivers/iio/amplifiers/ad8366.c b/drivers/iio/amplifiers/ad8366.c
index d6c0af23a2a7..d354554b51b3 100644
--- a/drivers/iio/amplifiers/ad8366.c
+++ b/drivers/iio/amplifiers/ad8366.c
@@ -125,7 +125,7 @@ static const struct iio_info ad8366_info = {
 	.output = 1,					\
 	.indexed = 1,					\
 	.channel = _channel,				\
-	.info_mask = IIO_CHAN_INFO_HARDWAREGAIN_SEPARATE_BIT,\
+	.info_mask_separate = BIT(IIO_CHAN_INFO_HARDWAREGAIN),\
 }
 
 static const struct iio_chan_spec ad8366_channels[] = {

commit fc52692c49969ec72595766929b9f54ac402da34
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:21:43 2012 -0800

    Drivers: iio: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, and __devexit
    from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/iio/amplifiers/ad8366.c b/drivers/iio/amplifiers/ad8366.c
index d8281cdbfc4a..d6c0af23a2a7 100644
--- a/drivers/iio/amplifiers/ad8366.c
+++ b/drivers/iio/amplifiers/ad8366.c
@@ -133,7 +133,7 @@ static const struct iio_chan_spec ad8366_channels[] = {
 	AD8366_CHAN(1),
 };
 
-static int __devinit ad8366_probe(struct spi_device *spi)
+static int ad8366_probe(struct spi_device *spi)
 {
 	struct iio_dev *indio_dev;
 	struct ad8366_state *st;
@@ -182,7 +182,7 @@ static int __devinit ad8366_probe(struct spi_device *spi)
 	return ret;
 }
 
-static int __devexit ad8366_remove(struct spi_device *spi)
+static int ad8366_remove(struct spi_device *spi)
 {
 	struct iio_dev *indio_dev = spi_get_drvdata(spi);
 	struct ad8366_state *st = iio_priv(indio_dev);
@@ -211,7 +211,7 @@ static struct spi_driver ad8366_driver = {
 		.owner	= THIS_MODULE,
 	},
 	.probe		= ad8366_probe,
-	.remove		= __devexit_p(ad8366_remove),
+	.remove		= ad8366_remove,
 	.id_table	= ad8366_id,
 };
 

commit e71d42e03c60d215bde295d2b986bbc96878c7d6
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Fri May 11 11:36:54 2012 +0200

    iio: amplifiers: New driver for AD8366 Dual-Digital Variable Gain Amplifier
    
    Changes since V1:
    
    Apply review feedback:
            Introduce and use IIO_CHAN_INFO_HARDWAREGAIN
            Introduce and use Use IIO_VAL_INT_PLUS_MICRO_DB
    
    Modify out of staging include paths.
    Convert to new iio core API naming.
    
    Changes since V2:
    
    more sanity checking in write_raw
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/iio/amplifiers/ad8366.c b/drivers/iio/amplifiers/ad8366.c
new file mode 100644
index 000000000000..d8281cdbfc4a
--- /dev/null
+++ b/drivers/iio/amplifiers/ad8366.c
@@ -0,0 +1,222 @@
+/*
+ * AD8366 SPI Dual-Digital Variable Gain Amplifier (VGA)
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/sysfs.h>
+#include <linux/spi/spi.h>
+#include <linux/regulator/consumer.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/bitrev.h>
+
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+
+struct ad8366_state {
+	struct spi_device	*spi;
+	struct regulator	*reg;
+	unsigned char		ch[2];
+	/*
+	 * DMA (thus cache coherency maintenance) requires the
+	 * transfer buffers to live in their own cache lines.
+	 */
+	unsigned char		data[2] ____cacheline_aligned;
+};
+
+static int ad8366_write(struct iio_dev *indio_dev,
+			unsigned char ch_a, char unsigned ch_b)
+{
+	struct ad8366_state *st = iio_priv(indio_dev);
+	int ret;
+
+	ch_a = bitrev8(ch_a & 0x3F);
+	ch_b = bitrev8(ch_b & 0x3F);
+
+	st->data[0] = ch_b >> 4;
+	st->data[1] = (ch_b << 4) | (ch_a >> 2);
+
+	ret = spi_write(st->spi, st->data, ARRAY_SIZE(st->data));
+	if (ret < 0)
+		dev_err(&indio_dev->dev, "write failed (%d)", ret);
+
+	return ret;
+}
+
+static int ad8366_read_raw(struct iio_dev *indio_dev,
+			   struct iio_chan_spec const *chan,
+			   int *val,
+			   int *val2,
+			   long m)
+{
+	struct ad8366_state *st = iio_priv(indio_dev);
+	int ret;
+	unsigned code;
+
+	mutex_lock(&indio_dev->mlock);
+	switch (m) {
+	case IIO_CHAN_INFO_HARDWAREGAIN:
+		code = st->ch[chan->channel];
+
+		/* Values in dB */
+		code = code * 253 + 4500;
+		*val = code / 1000;
+		*val2 = (code % 1000) * 1000;
+
+		ret = IIO_VAL_INT_PLUS_MICRO_DB;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	mutex_unlock(&indio_dev->mlock);
+
+	return ret;
+};
+
+static int ad8366_write_raw(struct iio_dev *indio_dev,
+			    struct iio_chan_spec const *chan,
+			    int val,
+			    int val2,
+			    long mask)
+{
+	struct ad8366_state *st = iio_priv(indio_dev);
+	unsigned code;
+	int ret;
+
+	if (val < 0 || val2 < 0)
+		return -EINVAL;
+
+	/* Values in dB */
+	code = (((u8)val * 1000) + ((u32)val2 / 1000));
+
+	if (code > 20500 || code < 4500)
+		return -EINVAL;
+
+	code = (code - 4500) / 253;
+
+	mutex_lock(&indio_dev->mlock);
+	switch (mask) {
+	case IIO_CHAN_INFO_HARDWAREGAIN:
+		st->ch[chan->channel] = code;
+		ret = ad8366_write(indio_dev, st->ch[0], st->ch[1]);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	mutex_unlock(&indio_dev->mlock);
+
+	return ret;
+}
+
+static const struct iio_info ad8366_info = {
+	.read_raw = &ad8366_read_raw,
+	.write_raw = &ad8366_write_raw,
+	.driver_module = THIS_MODULE,
+};
+
+#define AD8366_CHAN(_channel) {				\
+	.type = IIO_VOLTAGE,				\
+	.output = 1,					\
+	.indexed = 1,					\
+	.channel = _channel,				\
+	.info_mask = IIO_CHAN_INFO_HARDWAREGAIN_SEPARATE_BIT,\
+}
+
+static const struct iio_chan_spec ad8366_channels[] = {
+	AD8366_CHAN(0),
+	AD8366_CHAN(1),
+};
+
+static int __devinit ad8366_probe(struct spi_device *spi)
+{
+	struct iio_dev *indio_dev;
+	struct ad8366_state *st;
+	int ret;
+
+	indio_dev = iio_device_alloc(sizeof(*st));
+	if (indio_dev == NULL)
+		return -ENOMEM;
+
+	st = iio_priv(indio_dev);
+
+	st->reg = regulator_get(&spi->dev, "vcc");
+	if (!IS_ERR(st->reg)) {
+		ret = regulator_enable(st->reg);
+		if (ret)
+			goto error_put_reg;
+	}
+
+	spi_set_drvdata(spi, indio_dev);
+	st->spi = spi;
+
+	indio_dev->dev.parent = &spi->dev;
+	indio_dev->name = spi_get_device_id(spi)->name;
+	indio_dev->info = &ad8366_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->channels = ad8366_channels;
+	indio_dev->num_channels = ARRAY_SIZE(ad8366_channels);
+
+	ret = iio_device_register(indio_dev);
+	if (ret)
+		goto error_disable_reg;
+
+	ad8366_write(indio_dev, 0 , 0);
+
+	return 0;
+
+error_disable_reg:
+	if (!IS_ERR(st->reg))
+		regulator_disable(st->reg);
+error_put_reg:
+	if (!IS_ERR(st->reg))
+		regulator_put(st->reg);
+
+	iio_device_free(indio_dev);
+
+	return ret;
+}
+
+static int __devexit ad8366_remove(struct spi_device *spi)
+{
+	struct iio_dev *indio_dev = spi_get_drvdata(spi);
+	struct ad8366_state *st = iio_priv(indio_dev);
+	struct regulator *reg = st->reg;
+
+	iio_device_unregister(indio_dev);
+
+	if (!IS_ERR(reg)) {
+		regulator_disable(reg);
+		regulator_put(reg);
+	}
+
+	iio_device_free(indio_dev);
+
+	return 0;
+}
+
+static const struct spi_device_id ad8366_id[] = {
+	{"ad8366", 0},
+	{}
+};
+
+static struct spi_driver ad8366_driver = {
+	.driver = {
+		.name	= KBUILD_MODNAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= ad8366_probe,
+	.remove		= __devexit_p(ad8366_remove),
+	.id_table	= ad8366_id,
+};
+
+module_spi_driver(ad8366_driver);
+
+MODULE_AUTHOR("Michael Hennerich <hennerich@blackfin.uclinux.org>");
+MODULE_DESCRIPTION("Analog Devices AD8366 VGA");
+MODULE_LICENSE("GPL v2");
