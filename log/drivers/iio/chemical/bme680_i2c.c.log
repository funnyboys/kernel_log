commit 73f3bc6da506711302bb67572440eb84b1ec4a2c
Author: Mike Looijmans <mike.looijmans@topic.nl>
Date:   Wed Mar 6 08:31:48 2019 +0100

    iio:chemical:bme680: Fix SPI read interface
    
    The SPI interface implementation was completely broken.
    
    When using the SPI interface, there are only 7 address bits, the upper bit
    is controlled by a page select register. The core needs access to both
    ranges, so implement register read/write for both regions. The regmap
    paging functionality didn't agree with a register that needs to be read
    and modified, so I implemented a custom paging algorithm.
    
    This fixes that the device wouldn't even probe in SPI mode.
    
    The SPI interface then isn't different from I2C, merged them into the core,
    and the I2C/SPI named registers are no longer needed.
    
    Implemented register value caching for the registers to reduce the I2C/SPI
    data transfers considerably.
    
    The calibration set reads as all zeroes until some undefined point in time,
    and I couldn't determine what makes it valid. The datasheet mentions these
    registers but does not provide any hints on when they become valid, and they
    aren't even enumerated in the memory map. So check the calibration and
    retry reading it from the device after each measurement until it provides
    something valid.
    
    Despite the size this is suitable for a stable backport given that
    it seems the SPI support never worked.
    
    Signed-off-by: Mike Looijmans <mike.looijmans@topic.nl>
    Fixes: 1b3bd8592780 ("iio: chemical: Add support for Bosch BME680 sensor");
    Cc: <Stable@vger.kernel.org>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/chemical/bme680_i2c.c b/drivers/iio/chemical/bme680_i2c.c
index b2f805b6b36a..de9c9e3d23ea 100644
--- a/drivers/iio/chemical/bme680_i2c.c
+++ b/drivers/iio/chemical/bme680_i2c.c
@@ -23,8 +23,6 @@ static int bme680_i2c_probe(struct i2c_client *client,
 {
 	struct regmap *regmap;
 	const char *name = NULL;
-	unsigned int val;
-	int ret;
 
 	regmap = devm_regmap_init_i2c(client, &bme680_regmap_config);
 	if (IS_ERR(regmap)) {
@@ -33,25 +31,6 @@ static int bme680_i2c_probe(struct i2c_client *client,
 		return PTR_ERR(regmap);
 	}
 
-	ret = regmap_write(regmap, BME680_REG_SOFT_RESET_I2C,
-			   BME680_CMD_SOFTRESET);
-	if (ret < 0) {
-		dev_err(&client->dev, "Failed to reset chip\n");
-		return ret;
-	}
-
-	ret = regmap_read(regmap, BME680_REG_CHIP_I2C_ID, &val);
-	if (ret < 0) {
-		dev_err(&client->dev, "Error reading I2C chip ID\n");
-		return ret;
-	}
-
-	if (val != BME680_CHIP_ID_VAL) {
-		dev_err(&client->dev, "Wrong chip ID, got %x expected %x\n",
-				val, BME680_CHIP_ID_VAL);
-		return -ENODEV;
-	}
-
 	if (id)
 		name = id->name;
 

commit f7da884578212f10fd200e48f4e4c56f78e513d6
Author: Sebastien Bourdelin <sebastien.bourdelin@gmail.com>
Date:   Mon Jan 14 15:19:13 2019 -0500

    iio: chemical: bme680: Add device-tree support
    
    This commit allow the driver to work with device-tree.
    
    Signed-off-by: Sebastien Bourdelin <sebastien.bourdelin@gmail.com>
    Acked-by: Himanshu Jha <himanshujha199640@gmail.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/chemical/bme680_i2c.c b/drivers/iio/chemical/bme680_i2c.c
index 06d4be539d2e..b2f805b6b36a 100644
--- a/drivers/iio/chemical/bme680_i2c.c
+++ b/drivers/iio/chemical/bme680_i2c.c
@@ -70,10 +70,17 @@ static const struct acpi_device_id bme680_acpi_match[] = {
 };
 MODULE_DEVICE_TABLE(acpi, bme680_acpi_match);
 
+static const struct of_device_id bme680_of_i2c_match[] = {
+	{ .compatible = "bosch,bme680", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, bme680_of_i2c_match);
+
 static struct i2c_driver bme680_i2c_driver = {
 	.driver = {
 		.name			= "bme680_i2c",
 		.acpi_match_table       = ACPI_PTR(bme680_acpi_match),
+		.of_match_table		= bme680_of_i2c_match,
 	},
 	.probe = bme680_i2c_probe,
 	.id_table = bme680_i2c_id,

commit 1b3bd8592780c87c5eddabbe98666b086bbaee36
Author: Himanshu Jha <himanshujha199640@gmail.com>
Date:   Thu Jul 26 17:05:10 2018 +0530

    iio: chemical: Add support for Bosch BME680 sensor
    
    Bosch BME680 is a 4-in-1 sensor with temperature, pressure, humidity
    and gas sensing capability. It supports both I2C and SPI communication
    protocol for effective data communication.
    
    The device supports two modes:
    
    1. Sleep mode
    2. Forced mode
    
    The measurements only takes place when forced mode is triggered and a
    single TPHG cycle is performed by the sensor. The sensor automatically
    goes to sleep after afterwards.
    
    The device has various calibration constants/parameters programmed into
    devices' non-volatile memory(NVM) during production and can't be altered
    by the user. These constants are used in the compensation functions to
    get the required compensated readings along with the raw data. The
    compensation functions/algorithms are provided by Bosch Sensortec GmbH
    via their API[1]. As these don't change during the measurement cycle,
    therefore we read and store them at the probe. The default configs
    supplied by Bosch are also set at probe.
    
    0-day tested with build success.
    
    GSoC-2018: https://summerofcode.withgoogle.com/projects/#6691473790074880
    Mentor: Daniel Baluta
    [1] https://github.com/BoschSensortec/BME680_driver
    Datasheet:
    https://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST-BME680-DS001-00.pdf
    
    Note from Jonathan: The compensation functions are 'interesting' and
    could do with a tidy up in future.  However, they work so we can leave that
    for another day.
    
    Cc: Daniel Baluta <daniel.baluta@nxp.com>
    Signed-off-by: Himanshu Jha <himanshujha199640@gmail.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/chemical/bme680_i2c.c b/drivers/iio/chemical/bme680_i2c.c
new file mode 100644
index 000000000000..06d4be539d2e
--- /dev/null
+++ b/drivers/iio/chemical/bme680_i2c.c
@@ -0,0 +1,85 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * BME680 - I2C Driver
+ *
+ * Copyright (C) 2018 Himanshu Jha <himanshujha199640@gmail.com>
+ *
+ * 7-Bit I2C slave address is:
+ *	- 0x76 if SDO is pulled to GND
+ *	- 0x77 if SDO is pulled to VDDIO
+ *
+ * Note: SDO pin cannot be left floating otherwise I2C address
+ *	 will be undefined.
+ */
+#include <linux/acpi.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+
+#include "bme680.h"
+
+static int bme680_i2c_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	struct regmap *regmap;
+	const char *name = NULL;
+	unsigned int val;
+	int ret;
+
+	regmap = devm_regmap_init_i2c(client, &bme680_regmap_config);
+	if (IS_ERR(regmap)) {
+		dev_err(&client->dev, "Failed to register i2c regmap %d\n",
+				(int)PTR_ERR(regmap));
+		return PTR_ERR(regmap);
+	}
+
+	ret = regmap_write(regmap, BME680_REG_SOFT_RESET_I2C,
+			   BME680_CMD_SOFTRESET);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed to reset chip\n");
+		return ret;
+	}
+
+	ret = regmap_read(regmap, BME680_REG_CHIP_I2C_ID, &val);
+	if (ret < 0) {
+		dev_err(&client->dev, "Error reading I2C chip ID\n");
+		return ret;
+	}
+
+	if (val != BME680_CHIP_ID_VAL) {
+		dev_err(&client->dev, "Wrong chip ID, got %x expected %x\n",
+				val, BME680_CHIP_ID_VAL);
+		return -ENODEV;
+	}
+
+	if (id)
+		name = id->name;
+
+	return bme680_core_probe(&client->dev, regmap, name);
+}
+
+static const struct i2c_device_id bme680_i2c_id[] = {
+	{"bme680", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, bme680_i2c_id);
+
+static const struct acpi_device_id bme680_acpi_match[] = {
+	{"BME0680", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(acpi, bme680_acpi_match);
+
+static struct i2c_driver bme680_i2c_driver = {
+	.driver = {
+		.name			= "bme680_i2c",
+		.acpi_match_table       = ACPI_PTR(bme680_acpi_match),
+	},
+	.probe = bme680_i2c_probe,
+	.id_table = bme680_i2c_id,
+};
+module_i2c_driver(bme680_i2c_driver);
+
+MODULE_AUTHOR("Himanshu Jha <himanshujha199640@gmail.com>");
+MODULE_DESCRIPTION("BME680 I2C driver");
+MODULE_LICENSE("GPL v2");
