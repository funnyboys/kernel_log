commit fc1f75a0347aecc8b967c8c154564f520d6f4412
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Feb 27 15:52:25 2020 +0200

    iio: inkern: drop devm_iio_channel_release{_all} API calls
    
    It's unused so far, so it can be removed. Also makes sense to remove it
    to discourage weird uses of this call during review.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 5a8351c9a426..ede99e0d5371 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -360,18 +360,6 @@ static void devm_iio_channel_free(struct device *dev, void *res)
 	iio_channel_release(channel);
 }
 
-static int devm_iio_channel_match(struct device *dev, void *res, void *data)
-{
-	struct iio_channel **r = res;
-
-	if (!r || !*r) {
-		WARN_ON(!r || !*r);
-		return 0;
-	}
-
-	return *r == data;
-}
-
 struct iio_channel *devm_iio_channel_get(struct device *dev,
 					 const char *channel_name)
 {
@@ -394,13 +382,6 @@ struct iio_channel *devm_iio_channel_get(struct device *dev,
 }
 EXPORT_SYMBOL_GPL(devm_iio_channel_get);
 
-void devm_iio_channel_release(struct device *dev, struct iio_channel *channel)
-{
-	WARN_ON(devres_release(dev, devm_iio_channel_free,
-			       devm_iio_channel_match, channel));
-}
-EXPORT_SYMBOL_GPL(devm_iio_channel_release);
-
 struct iio_channel *iio_channel_get_all(struct device *dev)
 {
 	const char *name;
@@ -514,14 +495,6 @@ struct iio_channel *devm_iio_channel_get_all(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(devm_iio_channel_get_all);
 
-void devm_iio_channel_release_all(struct device *dev,
-				  struct iio_channel *channels)
-{
-	WARN_ON(devres_release(dev, devm_iio_channel_free_all,
-			       devm_iio_channel_match, channels));
-}
-EXPORT_SYMBOL_GPL(devm_iio_channel_release_all);
-
 static int iio_channel_read(struct iio_channel *chan, int *val, int *val2,
 	enum iio_chan_info_enum info)
 {

commit f632a8170a6b667ee4e3f552087588f0fe13c4bb
Merge: ef8f3d48afd6 c33d442328f5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jul 12 12:24:03 2019 -0700

    Merge tag 'driver-core-5.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core and debugfs updates from Greg KH:
     "Here is the "big" driver core and debugfs changes for 5.3-rc1
    
      It's a lot of different patches, all across the tree due to some api
      changes and lots of debugfs cleanups.
    
      Other than the debugfs cleanups, in this set of changes we have:
    
       - bus iteration function cleanups
    
       - scripts/get_abi.pl tool to display and parse Documentation/ABI
         entries in a simple way
    
       - cleanups to Documenatation/ABI/ entries to make them parse easier
         due to typos and other minor things
    
       - default_attrs use for some ktype users
    
       - driver model documentation file conversions to .rst
    
       - compressed firmware file loading
    
       - deferred probe fixes
    
      All of these have been in linux-next for a while, with a bunch of
      merge issues that Stephen has been patient with me for"
    
    * tag 'driver-core-5.3-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (102 commits)
      debugfs: make error message a bit more verbose
      orangefs: fix build warning from debugfs cleanup patch
      ubifs: fix build warning after debugfs cleanup patch
      driver: core: Allow subsystems to continue deferring probe
      drivers: base: cacheinfo: Ensure cpu hotplug work is done before Intel RDT
      arch_topology: Remove error messages on out-of-memory conditions
      lib: notifier-error-inject: no need to check return value of debugfs_create functions
      swiotlb: no need to check return value of debugfs_create functions
      ceph: no need to check return value of debugfs_create functions
      sunrpc: no need to check return value of debugfs_create functions
      ubifs: no need to check return value of debugfs_create functions
      orangefs: no need to check return value of debugfs_create functions
      nfsd: no need to check return value of debugfs_create functions
      lib: 842: no need to check return value of debugfs_create functions
      debugfs: provide pr_fmt() macro
      debugfs: log errors when something goes wrong
      drivers: s390/cio: Fix compilation warning about const qualifiers
      drivers: Add generic helper to match by of_node
      driver_find_device: Unify the match function with class_find_device()
      bus_find_device: Unify the match callback with class_find_device
      ...

commit 418e3ea157efb0eb2c6dd412a8d5f052477c7f5a
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Fri Jun 14 18:53:59 2019 +0100

    bus_find_device: Unify the match callback with class_find_device
    
    There is an arbitrary difference between the prototypes of
    bus_find_device() and class_find_device() preventing their callers
    from passing the same pair of data and match() arguments to both of
    them, which is the const qualifier used in the prototype of
    class_find_device().  If that qualifier is also used in the
    bus_find_device() prototype, it will be possible to pass the same
    match() callback function to both bus_find_device() and
    class_find_device(), which will allow some optimizations to be made in
    order to avoid code duplication going forward.  Also with that, constify
    the "data" parameter as it is passed as a const to the match function.
    
    For this reason, change the prototype of bus_find_device() to match
    the prototype of class_find_device() and adjust its callers to use the
    const qualifier in accordance with the new prototype of it.
    
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Andreas Noever <andreas.noever@gmail.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Corey Minyard <minyard@acm.org>
    Cc: Christian Borntraeger <borntraeger@de.ibm.com>
    Cc: David Kershner <david.kershner@unisys.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Felipe Balbi <balbi@kernel.org>
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Grygorii Strashko <grygorii.strashko@ti.com>
    Cc: Harald Freudenberger <freude@linux.ibm.com>
    Cc: Hartmut Knaack <knaack.h@gmx.de>
    Cc: Heiko Stuebner <heiko@sntech.de>
    Cc: Jason Gunthorpe <jgg@ziepe.ca>
    Cc: Jonathan Cameron <jic23@kernel.org>
    Cc: "James E.J. Bottomley" <jejb@linux.ibm.com>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Mark Brown <broonie@kernel.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michael Jamet <michael.jamet@intel.com>
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: Peter Oberparleiter <oberpar@linux.ibm.com>
    Cc: Sebastian Ott <sebott@linux.ibm.com>
    Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Cc: Yehezkel Bernat <YehezkelShB@gmail.com>
    Cc: rafael@kernel.org
    Acked-by: Corey Minyard <minyard@acm.org>
    Acked-by: David Kershner <david.kershner@unisys.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de> # for the I2C parts
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 4a5eff3f18bc..c46fb59d92cb 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -93,7 +93,7 @@ static const struct iio_chan_spec
 
 #ifdef CONFIG_OF
 
-static int iio_dev_node_match(struct device *dev, void *data)
+static int iio_dev_node_match(struct device *dev, const void *data)
 {
 	return dev->of_node == data && dev->type == &iio_device_type;
 }

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 4a5eff3f18bc..2fb2314548e9 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -1,10 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* The industrial I/O core in kernel channel mapping
  *
  * Copyright (c) 2011 Jonathan Cameron
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published by
- * the Free Software Foundation.
  */
 #include <linux/err.h>
 #include <linux/export.h>

commit 89388ca4955fe2f70936488723c9bb74099f37a3
Author: Artur Rojek <contact@artur-rojek.eu>
Date:   Sat Mar 23 18:28:07 2019 +0100

    iio: inkern: Convert iio_read_avail_channel_raw into a wrapper
    
    Convert "iio_read_avail_channel_raw" over to a wrapper around
    "iio_read_avail_channel_attribute".
    
    With the introduction of "iio_read_avail_channel_attribute",
    the necessity of having a separate call to read raw channel values
    became redundant.
    
    Signed-off-by: Artur Rojek <contact@artur-rojek.eu>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index f19dbde3c945..4a5eff3f18bc 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -759,16 +759,8 @@ int iio_read_avail_channel_raw(struct iio_channel *chan,
 	int ret;
 	int type;
 
-	mutex_lock(&chan->indio_dev->info_exist_lock);
-	if (!chan->indio_dev->info) {
-		ret = -ENODEV;
-		goto err_unlock;
-	}
-
-	ret = iio_channel_read_avail(chan,
-				     vals, &type, length, IIO_CHAN_INFO_RAW);
-err_unlock:
-	mutex_unlock(&chan->indio_dev->info_exist_lock);
+	ret = iio_read_avail_channel_attribute(chan, vals, &type, length,
+					 IIO_CHAN_INFO_RAW);
 
 	if (ret >= 0 && type != IIO_VAL_INT)
 		/* raw values are assumed to be IIO_VAL_INT */

commit 9f421096a16e75d22e69f766206f1bb0dc8fcf90
Author: Artur Rojek <contact@artur-rojek.eu>
Date:   Sat Mar 23 18:28:06 2019 +0100

    iio: inkern: API for reading available iio channel attribute values
    
    Extend the inkern API with a function for reading available
    attribute values of iio channels.
    
    Signed-off-by: Artur Rojek <contact@artur-rojek.eu>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 06ca3f7fcc44..f19dbde3c945 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -733,6 +733,26 @@ static int iio_channel_read_avail(struct iio_channel *chan,
 						 vals, type, length, info);
 }
 
+int iio_read_avail_channel_attribute(struct iio_channel *chan,
+				     const int **vals, int *type, int *length,
+				     enum iio_chan_info_enum attribute)
+{
+	int ret;
+
+	mutex_lock(&chan->indio_dev->info_exist_lock);
+	if (!chan->indio_dev->info) {
+		ret = -ENODEV;
+		goto err_unlock;
+	}
+
+	ret = iio_channel_read_avail(chan, vals, type, length, attribute);
+err_unlock:
+	mutex_unlock(&chan->indio_dev->info_exist_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(iio_read_avail_channel_attribute);
+
 int iio_read_avail_channel_raw(struct iio_channel *chan,
 			       const int **vals, int *length)
 {

commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:03:40 2018 -0700

    treewide: kzalloc() -> kcalloc()
    
    The kzalloc() function has a 2-factor argument form, kcalloc(). This
    patch replaces cases of:
    
            kzalloc(a * b, gfp)
    
    with:
            kcalloc(a * b, gfp)
    
    as well as handling cases of:
    
            kzalloc(a * b * c, gfp)
    
    with:
    
            kzalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kzalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kzalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kzalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kzalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kzalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kzalloc
    + kcalloc
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kzalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(sizeof(THING) * C2, ...)
    |
      kzalloc(sizeof(TYPE) * C2, ...)
    |
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(C1 * C2, ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index ec98790e2a28..06ca3f7fcc44 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -436,7 +436,7 @@ struct iio_channel *iio_channel_get_all(struct device *dev)
 	}
 
 	/* NULL terminated array to save passing size */
-	chans = kzalloc(sizeof(*chans)*(nummaps + 1), GFP_KERNEL);
+	chans = kcalloc(nummaps + 1, sizeof(*chans), GFP_KERNEL);
 	if (chans == NULL) {
 		ret = -ENOMEM;
 		goto error_ret;

commit 34739a213dbb85c8d775de42d52358255059c257
Author: Arnaud Pouliquen <arnaud.pouliquen@st.com>
Date:   Wed Jan 10 11:13:06 2018 +0100

    IIO: inkern: API for manipulating channel attributes
    
    Extend the inkern API with functions for reading and writing
    attribute of iio channels.
    
    Signed-off-by: Arnaud Pouliquen <arnaud.pouliquen@st.com>
    Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 069defcc6d9b..ec98790e2a28 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -664,9 +664,8 @@ int iio_convert_raw_to_processed(struct iio_channel *chan, int raw,
 }
 EXPORT_SYMBOL_GPL(iio_convert_raw_to_processed);
 
-static int iio_read_channel_attribute(struct iio_channel *chan,
-				      int *val, int *val2,
-				      enum iio_chan_info_enum attribute)
+int iio_read_channel_attribute(struct iio_channel *chan, int *val, int *val2,
+			       enum iio_chan_info_enum attribute)
 {
 	int ret;
 
@@ -682,6 +681,7 @@ static int iio_read_channel_attribute(struct iio_channel *chan,
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(iio_read_channel_attribute);
 
 int iio_read_channel_offset(struct iio_channel *chan, int *val, int *val2)
 {
@@ -850,7 +850,8 @@ static int iio_channel_write(struct iio_channel *chan, int val, int val2,
 						chan->channel, val, val2, info);
 }
 
-int iio_write_channel_raw(struct iio_channel *chan, int val)
+int iio_write_channel_attribute(struct iio_channel *chan, int val, int val2,
+				enum iio_chan_info_enum attribute)
 {
 	int ret;
 
@@ -860,12 +861,18 @@ int iio_write_channel_raw(struct iio_channel *chan, int val)
 		goto err_unlock;
 	}
 
-	ret = iio_channel_write(chan, val, 0, IIO_CHAN_INFO_RAW);
+	ret = iio_channel_write(chan, val, val2, attribute);
 err_unlock:
 	mutex_unlock(&chan->indio_dev->info_exist_lock);
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(iio_write_channel_attribute);
+
+int iio_write_channel_raw(struct iio_channel *chan, int val)
+{
+	return iio_write_channel_attribute(chan, val, 0, IIO_CHAN_INFO_RAW);
+}
 EXPORT_SYMBOL_GPL(iio_write_channel_raw);
 
 unsigned int iio_get_channel_ext_info_count(struct iio_channel *chan)

commit 98c2f10d2366ec7128c254c775d4e6969a705ecd
Merge: a29e24907208 f3f0ae16f0ce
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jul 27 21:29:49 2017 -0700

    Merge tag 'iio-for-4.14a' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-next
    
    Jonathan writes:
    
    First round of IIO new device support, features and cleanups for the 4.14 cycle.
    
    4 completely new drivers in this set and plenty of other stuff.
    
    One ABI change due to a silly mistake a long time back. Hopefully no
    one will notice.  It effects the numerical order of consumer device
    channels which was the reverse of the obvious.  It's going the slow
    way to allow us some margin to spot if we have broken userspace or
    not (seems unlikely)
    
    New Device Support
    * ccs811
      - new driver for the Volatile Organic Compounds (VOC) sensor.
    * dln2 adc
      - new driver for the ADC on this flexible usb board.
    * EP93xx
      - new driver for this Cirrus logic SoC ADC.
    * ltc2471
      - new ADC driver support the ltc2471 and ltc2473
    * st_accel
      - add trivial table entries to support H3LIS331DL, LIS331DL, LIS3LV02DL.
    * st_gyro
      - add L3GD20H support (again) having fixed the various things that were
        broken in the first try.  Includes devicetree binding.
    * stm32 dac
      - add support for the DACs in the STM32F4 series
    
    Features
    * Documentation
      - add missing power attribute documentation to the ABI docs.
    * at91-sama5d2
      - add hardware trigger and buffered capture support with bindings.
      - suspend and resume functionality.
    * bmc150
      - support for the BOSC0200 ACPI device id seen on some tablets.
    * hdc100x
      - devicetree bindings
      - document supported devices
      - match table and device ids.
    * hts221
      - support active low interrupts (with bindings)
      - open drain mode with bindings.
    * htu21
      - OF match table and bindings.
    * lsm6dsx
      - open drain mode with bindings
    * ltc2497
      - add support for board file based consumer mapping.
    * ms5367
      - OF match table and bindings.
    * mt7622
      - binding document and OF match table.
      - suspend and resume support.
    * rpr0521
      - triggered buffer support.
    * tsys01
      - OF match table and bindings.
    
    Cleanups and minor fixes
    * core
      - fix ordering of IIO channels to entry numbers when using
        iio_map_array_register rather than reversing them.
      - use the new %pOF format specifier rather than full name for the
        device tree nodes.
    * ad7280a
      - fix potential issue with macro argument reuse.
    * ad7766
      - drop a pointless NULL value check as it's done in the gpiod code.
    * adis16400
      - unsigned -> unsigned int.
    * at91 adc
      - make some init data static to reduce code size.
    * at91-sama5d2 ADC
      - make some init data static to reduce code size.
    * da311
      - make some init data static to reduce code size.
    * hid-sensor-rotation
      - drop an unnecessary static.
    * hts221
      - refactor the write_with_mask code.
      - move the BDU configuration to probe time as there is no reason for it
        to change.
      - avoid overwriting reserved data during power-down.  This is a fix, but
        the infrastructure need was too invasive to send it to mainline except
        in a merge window.  It's not a regression as it was always wrong.
      - avoid reconfigure the sampling frequency multiple times by just
        doing it in the write_raw function directly.
      - refactor the power_on/off calls into a set_enable.
      - move the dry-enable logic into trig_set_state as that is the only
        place it was used.
    * ina219
      - fix polling of ina226 conversion ready flag.
    * imx7d
      - add vendor name in kconfig for consistency with similar parts.
    * mcp3422
      - Change initial channel to 0 as it feels more logical.
      - Check for some errors in probe.
    * meson-saradc
      - add a check of of_match_device return value.
    * mpu3050
      - allow open drain for any interrupt type.
    * rockchip adc
      - add check on of_match_device return value.
    * sca3000
      - drop a trailing whitespace.
    * stm32 adc
      - make array stm32h7_adc_ckmodes_spec static.
    * stm32 dac
      - fix an error message.
    * stm32 timers
      - fix clock name in docs to match reality after changes.
    * st_accel
      - explicit OF table (spi).
      - add missing entries to OF table (i2c).
      - rename of_device_id table to drop the part name.
      - adding missing lis3l02dq entry to bindings.
      - rename H3LIS331DL_DRIVER_NAME to line up with similar entries in driver.
    * st_gyro
      - explicit OF table (spi).
    * st_magn
      - explicit OF table (spi).
      - enable multiread for lis3mdl.
    * st_pressure
      - explicit OF table (spi).
    * st_sensors common.
      - move st_sensors_of_i2c_probe and rename to make it available for spi
      drivers.
    * tsc3472
      - don't write an extra byte when writing the ATIME register.
      - add a link to the datasheet.
    * tsl2x7x - continued staging cleanups
      - add of_match_table.
      - drop redundant power_state sysfs attribute.
      - drop wrapper tsl2x7x_i2c_read.
      - clean up i2c calls made in tsl2x7x_als_calibrate.
      - refactor the read and write _event_value callbacks to handle additional
        elements.
      - use usleep_range instead of mdelay.
      - check return value from tsl2x7x_invoke_change.
    * zpa2326
      - add some newline to the end of logging macros.

commit 3921db46a8c5bc256c5956a04ad49cbbeac28e7d
Author: Rob Herring <robh@kernel.org>
Date:   Tue Jul 18 16:43:08 2017 -0500

    iio: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Jonathan Cameron <jic23@kernel.org>
    Cc: Hartmut Knaack <knaack.h@gmx.de>
    Cc: Lars-Peter Clausen <lars@metafoo.de>
    Cc: Peter Meerwald-Stadler <pmeerw@pmeerw.net>
    Cc: Carlo Caione <carlo@caione.org>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: linux-iio@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-amlogic@lists.infradead.org
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 487bf6b75172..6c69da942321 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -205,8 +205,8 @@ static struct iio_channel *of_iio_channel_get_by_name(struct device_node *np,
 		if (!IS_ERR(chan) || PTR_ERR(chan) == -EPROBE_DEFER)
 			break;
 		else if (name && index >= 0) {
-			pr_err("ERROR: could not get IIO channel %s:%s(%i)\n",
-				np->full_name, name ? name : "", index);
+			pr_err("ERROR: could not get IIO channel %pOF:%s(%i)\n",
+				np, name ? name : "", index);
 			return NULL;
 		}
 

commit bc4b2a518f20508d866b55b5ea2739f3ced18cb6
Author: Gaurav Gupta <gauragup@cisco.com>
Date:   Tue Jun 27 09:46:01 2017 -0700

    iio: core: Fix mapping of iio channels to entry numbers
    
    When adding maps to the list, they were added using list_add, which adds
    them in LIFO order. When parsing using iio_channel_get_all(), these
    elements are hence returned in reverse order. As a result, the iio_hwmon
    mapping maps the first entry to the last channel and so on.
    
    Signed-off-by: Gaurav Gupta <gauragup@cisco.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index a3941bade6a7..487bf6b75172 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -44,7 +44,7 @@ int iio_map_array_register(struct iio_dev *indio_dev, struct iio_map *maps)
 		}
 		mapi->map = &maps[i];
 		mapi->indio_dev = indio_dev;
-		list_add(&mapi->l, &iio_map_list);
+		list_add_tail(&mapi->l, &iio_map_list);
 		i++;
 	}
 error_ret:

commit f4dd029ee0b92b77769a1ac6dce03e829e74763e
Merge: 974668417b74 cbbdc6082917
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 3 20:55:59 2017 -0700

    Merge tag 'char-misc-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc
    
    Pull char/misc updates from Greg KH:
     "Here is the "big" char/misc driver patchset for 4.13-rc1.
    
      Lots of stuff in here, a large thunderbolt update, w1 driver header
      reorg, the new mux driver subsystem, google firmware driver updates,
      and a raft of other smaller things. Full details in the shortlog.
    
      All of these have been in linux-next for a while with the only
      reported issue being a merge problem with this tree and the jc-docs
      tree in the w1 documentation area"
    
    * tag 'char-misc-4.13-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc: (147 commits)
      misc: apds990x: Use sysfs_match_string() helper
      mei: drop unreachable code in mei_start
      mei: validate the message header only in first fragment.
      DocBook: w1: Update W1 file locations and names in DocBook
      mux: adg792a: always require I2C support
      nvmem: rockchip-efuse: add support for rk322x-efuse
      nvmem: core: add locking to nvmem_find_cell
      nvmem: core: Call put_device() in nvmem_unregister()
      nvmem: core: fix leaks on registration errors
      nvmem: correct Broadcom OTP controller driver writes
      w1: Add subsystem kernel public interface
      drivers/fsi: Add module license to core driver
      drivers/fsi: Use asynchronous slave mode
      drivers/fsi: Add hub master support
      drivers/fsi: Add SCOM FSI client device driver
      drivers/fsi/gpio: Add tracepoints for GPIO master
      drivers/fsi: Add GPIO based FSI master
      drivers/fsi: Document FSI master sysfs files in ABI
      drivers/fsi: Add error handling for slave
      drivers/fsi: Add tracepoints for low-level operations
      ...

commit 8a848e754956dcbc35cd2fcf417f66dafa020c9e
Author: Peter Rosin <peda@axentia.se>
Date:   Sun May 14 21:51:08 2017 +0200

    iio: inkern: api for manipulating ext_info of iio channels
    
    Extend the inkern api with functions for reading and writing ext_info
    of iio channels.
    
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Peter Rosin <peda@axentia.se>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 7a13535dc3e9..8292ad4435ea 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -869,3 +869,63 @@ int iio_write_channel_raw(struct iio_channel *chan, int val)
 	return ret;
 }
 EXPORT_SYMBOL_GPL(iio_write_channel_raw);
+
+unsigned int iio_get_channel_ext_info_count(struct iio_channel *chan)
+{
+	const struct iio_chan_spec_ext_info *ext_info;
+	unsigned int i = 0;
+
+	if (!chan->channel->ext_info)
+		return i;
+
+	for (ext_info = chan->channel->ext_info; ext_info->name; ext_info++)
+		++i;
+
+	return i;
+}
+EXPORT_SYMBOL_GPL(iio_get_channel_ext_info_count);
+
+static const struct iio_chan_spec_ext_info *iio_lookup_ext_info(
+						const struct iio_channel *chan,
+						const char *attr)
+{
+	const struct iio_chan_spec_ext_info *ext_info;
+
+	if (!chan->channel->ext_info)
+		return NULL;
+
+	for (ext_info = chan->channel->ext_info; ext_info->name; ++ext_info) {
+		if (!strcmp(attr, ext_info->name))
+			return ext_info;
+	}
+
+	return NULL;
+}
+
+ssize_t iio_read_channel_ext_info(struct iio_channel *chan,
+				  const char *attr, char *buf)
+{
+	const struct iio_chan_spec_ext_info *ext_info;
+
+	ext_info = iio_lookup_ext_info(chan, attr);
+	if (!ext_info)
+		return -EINVAL;
+
+	return ext_info->read(chan->indio_dev, ext_info->private,
+			      chan->channel, buf);
+}
+EXPORT_SYMBOL_GPL(iio_read_channel_ext_info);
+
+ssize_t iio_write_channel_ext_info(struct iio_channel *chan, const char *attr,
+				   const char *buf, size_t len)
+{
+	const struct iio_chan_spec_ext_info *ext_info;
+
+	ext_info = iio_lookup_ext_info(chan, attr);
+	if (!ext_info)
+		return -EINVAL;
+
+	return ext_info->write(chan->indio_dev, ext_info->private,
+			       chan->channel, buf, len);
+}
+EXPORT_SYMBOL_GPL(iio_write_channel_ext_info);

commit c773f70015f6f07f4abe93b486da7f53fde6e878
Author: Peter Rosin <peda@axentia.se>
Date:   Thu Apr 20 23:01:57 2017 +0200

    iio: inkern: fix a static checker error
    
    Avoid this smatch error:
    drivers/iio/inkern.c:751 iio_read_avail_channel_raw() error: double unlock 'mutex:&chan->indio_dev->info_exist_lock'
    
    Fixes: 00c5f80c2fad ("iio: inkern: add helpers to query available values from channels")
    Signed-off-by: Peter Rosin <peda@axentia.se>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 7a13535dc3e9..a3941bade6a7 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -750,11 +750,9 @@ int iio_read_avail_channel_raw(struct iio_channel *chan,
 err_unlock:
 	mutex_unlock(&chan->indio_dev->info_exist_lock);
 
-	if (ret >= 0 && type != IIO_VAL_INT) {
+	if (ret >= 0 && type != IIO_VAL_INT)
 		/* raw values are assumed to be IIO_VAL_INT */
 		ret = -EINVAL;
-		goto err_unlock;
-	}
 
 	return ret;
 }

commit adc8ec5ff183d09ae7a9d2dd31125401d302ba63
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Jan 11 11:48:39 2017 +0100

    iio: inkern: pass through raw values if no scaling
    
    When a consumer calls iio_read_channel_processed() the IIO core
    tries to apply scaling to the value, but if the channel only
    supports reading raw values, we should return that raw value
    to the cosumer instead of an error.
    
    This is what userspace is expected to do with sensors only
    providing raw values so the kernel should do the same, so as to
    avoid adding scaling boilerplate to drivers for hardware that
    actually return processed values from raw reads.
    
    A sensor not providing a scale, but providing a _raw attribute
    could be valid if for example the scale is the default of 1,
    but an offset needs to be applied to convert to the _processed
    form.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index b0f4630a163f..7a13535dc3e9 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -601,8 +601,14 @@ static int iio_convert_raw_to_processed_unlocked(struct iio_channel *chan,
 
 	scale_type = iio_channel_read(chan, &scale_val, &scale_val2,
 					IIO_CHAN_INFO_SCALE);
-	if (scale_type < 0)
-		return scale_type;
+	if (scale_type < 0) {
+		/*
+		 * Just pass raw values as processed if no scaling is
+		 * available.
+		 */
+		*processed = raw;
+		return 0;
+	}
 
 	switch (scale_type) {
 	case IIO_VAL_INT:

commit 00c5f80c2fad5368cd5bfa6c9d90e75a9041ac16
Author: Peter Rosin <peda@axentia.se>
Date:   Tue Nov 8 12:58:52 2016 +0100

    iio: inkern: add helpers to query available values from channels
    
    Specifically a helper for reading the available maximum raw value of a
    channel and a helper for forwarding read_avail requests for raw values
    from one iio driver to an iio channel that is consumed.
    
    These rather specific helpers are in turn built with generic helpers
    making it easy to build more helpers for available values as needed.
    
    Signed-off-by: Peter Rosin <peda@axentia.se>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 29df11572858..b0f4630a163f 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -716,6 +716,110 @@ int iio_read_channel_scale(struct iio_channel *chan, int *val, int *val2)
 }
 EXPORT_SYMBOL_GPL(iio_read_channel_scale);
 
+static int iio_channel_read_avail(struct iio_channel *chan,
+				  const int **vals, int *type, int *length,
+				  enum iio_chan_info_enum info)
+{
+	if (!iio_channel_has_available(chan->channel, info))
+		return -EINVAL;
+
+	return chan->indio_dev->info->read_avail(chan->indio_dev, chan->channel,
+						 vals, type, length, info);
+}
+
+int iio_read_avail_channel_raw(struct iio_channel *chan,
+			       const int **vals, int *length)
+{
+	int ret;
+	int type;
+
+	mutex_lock(&chan->indio_dev->info_exist_lock);
+	if (!chan->indio_dev->info) {
+		ret = -ENODEV;
+		goto err_unlock;
+	}
+
+	ret = iio_channel_read_avail(chan,
+				     vals, &type, length, IIO_CHAN_INFO_RAW);
+err_unlock:
+	mutex_unlock(&chan->indio_dev->info_exist_lock);
+
+	if (ret >= 0 && type != IIO_VAL_INT) {
+		/* raw values are assumed to be IIO_VAL_INT */
+		ret = -EINVAL;
+		goto err_unlock;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(iio_read_avail_channel_raw);
+
+static int iio_channel_read_max(struct iio_channel *chan,
+				int *val, int *val2, int *type,
+				enum iio_chan_info_enum info)
+{
+	int unused;
+	const int *vals;
+	int length;
+	int ret;
+
+	if (!val2)
+		val2 = &unused;
+
+	ret = iio_channel_read_avail(chan, &vals, type, &length, info);
+	switch (ret) {
+	case IIO_AVAIL_RANGE:
+		switch (*type) {
+		case IIO_VAL_INT:
+			*val = vals[2];
+			break;
+		default:
+			*val = vals[4];
+			*val2 = vals[5];
+		}
+		return 0;
+
+	case IIO_AVAIL_LIST:
+		if (length <= 0)
+			return -EINVAL;
+		switch (*type) {
+		case IIO_VAL_INT:
+			*val = vals[--length];
+			while (length) {
+				if (vals[--length] > *val)
+					*val = vals[length];
+			}
+			break;
+		default:
+			/* FIXME: learn about max for other iio values */
+			return -EINVAL;
+		}
+		return 0;
+
+	default:
+		return ret;
+	}
+}
+
+int iio_read_max_channel_raw(struct iio_channel *chan, int *val)
+{
+	int ret;
+	int type;
+
+	mutex_lock(&chan->indio_dev->info_exist_lock);
+	if (!chan->indio_dev->info) {
+		ret = -ENODEV;
+		goto err_unlock;
+	}
+
+	ret = iio_channel_read_max(chan, val, NULL, &type, IIO_CHAN_INFO_RAW);
+err_unlock:
+	mutex_unlock(&chan->indio_dev->info_exist_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(iio_read_max_channel_raw);
+
 int iio_get_channel_type(struct iio_channel *chan, enum iio_chan_type *type)
 {
 	int ret = 0;

commit 0023e67dd8951737588b8af0469446df3ec52afe
Author: Matt Ranostay <mranostay@gmail.com>
Date:   Fri Sep 23 23:04:07 2016 -0700

    iio: inkern: add iio_read_channel_offset helper
    
    Allow access to underlying channel IIO_CHAN_INFO_OFFSET from a consumer.
    
    Signed-off-by: Matt Ranostay <matt@ranostay.consulting>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index c4757e6367e7..29df11572858 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -658,6 +658,31 @@ int iio_convert_raw_to_processed(struct iio_channel *chan, int raw,
 }
 EXPORT_SYMBOL_GPL(iio_convert_raw_to_processed);
 
+static int iio_read_channel_attribute(struct iio_channel *chan,
+				      int *val, int *val2,
+				      enum iio_chan_info_enum attribute)
+{
+	int ret;
+
+	mutex_lock(&chan->indio_dev->info_exist_lock);
+	if (chan->indio_dev->info == NULL) {
+		ret = -ENODEV;
+		goto err_unlock;
+	}
+
+	ret = iio_channel_read(chan, val, val2, attribute);
+err_unlock:
+	mutex_unlock(&chan->indio_dev->info_exist_lock);
+
+	return ret;
+}
+
+int iio_read_channel_offset(struct iio_channel *chan, int *val, int *val2)
+{
+	return iio_read_channel_attribute(chan, val, val2, IIO_CHAN_INFO_OFFSET);
+}
+EXPORT_SYMBOL_GPL(iio_read_channel_offset);
+
 int iio_read_channel_processed(struct iio_channel *chan, int *val)
 {
 	int ret;
@@ -687,19 +712,7 @@ EXPORT_SYMBOL_GPL(iio_read_channel_processed);
 
 int iio_read_channel_scale(struct iio_channel *chan, int *val, int *val2)
 {
-	int ret;
-
-	mutex_lock(&chan->indio_dev->info_exist_lock);
-	if (chan->indio_dev->info == NULL) {
-		ret = -ENODEV;
-		goto err_unlock;
-	}
-
-	ret = iio_channel_read(chan, val, val2, IIO_CHAN_INFO_SCALE);
-err_unlock:
-	mutex_unlock(&chan->indio_dev->info_exist_lock);
-
-	return ret;
+	return iio_read_channel_attribute(chan, val, val2, IIO_CHAN_INFO_SCALE);
 }
 EXPORT_SYMBOL_GPL(iio_read_channel_scale);
 

commit efc2c0133f198bc65593a67015af358919b0c48f
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Wed Apr 6 16:01:07 2016 +0530

    iio: core: Add devm_ APIs for iio_channel_{get,release}_all
    
    Some of kernel driver uses the IIO framework to get the sensor
    value via ADC or IIO HW driver. The client driver get iio channel
    by iio_channel_get_all() and release it by calling
    iio_channel_release_all().
    
    Add resource managed version (devm_*) of these APIs so that if client
    calls the devm_iio_channel_get_all() then it need not to release it
    explicitly, it can be done by managed device framework when driver
    get un-binded.
    
    This reduces the code in error path and also need of .remove callback in
    some cases.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 9fd8934c1887..c4757e6367e7 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -489,6 +489,42 @@ void iio_channel_release_all(struct iio_channel *channels)
 }
 EXPORT_SYMBOL_GPL(iio_channel_release_all);
 
+static void devm_iio_channel_free_all(struct device *dev, void *res)
+{
+	struct iio_channel *channels = *(struct iio_channel **)res;
+
+	iio_channel_release_all(channels);
+}
+
+struct iio_channel *devm_iio_channel_get_all(struct device *dev)
+{
+	struct iio_channel **ptr, *channels;
+
+	ptr = devres_alloc(devm_iio_channel_free_all, sizeof(*ptr), GFP_KERNEL);
+	if (!ptr)
+		return ERR_PTR(-ENOMEM);
+
+	channels = iio_channel_get_all(dev);
+	if (IS_ERR(channels)) {
+		devres_free(ptr);
+		return channels;
+	}
+
+	*ptr = channels;
+	devres_add(dev, ptr);
+
+	return channels;
+}
+EXPORT_SYMBOL_GPL(devm_iio_channel_get_all);
+
+void devm_iio_channel_release_all(struct device *dev,
+				  struct iio_channel *channels)
+{
+	WARN_ON(devres_release(dev, devm_iio_channel_free_all,
+			       devm_iio_channel_match, channels));
+}
+EXPORT_SYMBOL_GPL(devm_iio_channel_release_all);
+
 static int iio_channel_read(struct iio_channel *chan, int *val, int *val2,
 	enum iio_chan_info_enum info)
 {

commit 8bf872d8d261feefcdf67027522e3f717cad2bfe
Author: Laxman Dewangan <ldewangan@nvidia.com>
Date:   Wed Apr 6 16:01:06 2016 +0530

    iio: core: Add devm_ APIs for iio_channel_{get,release}
    
    Some of kernel driver uses the IIO framework to get the sensor
    value via ADC or IIO HW driver. The client driver get iio channel
    by iio_channel_get() and release it by calling iio_channel_release().
    
    Add resource managed version (devm_*) of these APIs so that if client
    calls the devm_iio_channel_get() then it need not to release it explicitly,
    it can be done by managed device framework when driver get un-binded.
    
    This reduces the code in error path and also need of .remove callback in
    some cases.
    
    Signed-off-by: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 2fc7928f401d..9fd8934c1887 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -356,6 +356,54 @@ void iio_channel_release(struct iio_channel *channel)
 }
 EXPORT_SYMBOL_GPL(iio_channel_release);
 
+static void devm_iio_channel_free(struct device *dev, void *res)
+{
+	struct iio_channel *channel = *(struct iio_channel **)res;
+
+	iio_channel_release(channel);
+}
+
+static int devm_iio_channel_match(struct device *dev, void *res, void *data)
+{
+	struct iio_channel **r = res;
+
+	if (!r || !*r) {
+		WARN_ON(!r || !*r);
+		return 0;
+	}
+
+	return *r == data;
+}
+
+struct iio_channel *devm_iio_channel_get(struct device *dev,
+					 const char *channel_name)
+{
+	struct iio_channel **ptr, *channel;
+
+	ptr = devres_alloc(devm_iio_channel_free, sizeof(*ptr), GFP_KERNEL);
+	if (!ptr)
+		return ERR_PTR(-ENOMEM);
+
+	channel = iio_channel_get(dev, channel_name);
+	if (IS_ERR(channel)) {
+		devres_free(ptr);
+		return channel;
+	}
+
+	*ptr = channel;
+	devres_add(dev, ptr);
+
+	return channel;
+}
+EXPORT_SYMBOL_GPL(devm_iio_channel_get);
+
+void devm_iio_channel_release(struct device *dev, struct iio_channel *channel)
+{
+	WARN_ON(devres_release(dev, devm_iio_channel_free,
+			       devm_iio_channel_match, channel));
+}
+EXPORT_SYMBOL_GPL(devm_iio_channel_release);
+
 struct iio_channel *iio_channel_get_all(struct device *dev)
 {
 	const char *name;

commit fc0b81704f0458c20793e82a3c094a215833dcfe
Author: Slawomir Stepien <sst@poczta.fm>
Date:   Thu Apr 14 21:36:34 2016 +0200

    iio: inkern: add a missing space before if
    
    This fixes the error reported by checkpatch.pl:
    
    ERROR: space required before the open parenthesis '('
    
    Signed-off-by: Slawomir Stepien <sst@poczta.fm>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 734a0042de0c..2fc7928f401d 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -452,7 +452,7 @@ static int iio_channel_read(struct iio_channel *chan, int *val, int *val2,
 	if (val2 == NULL)
 		val2 = &unused;
 
-	if(!iio_channel_has_info(chan->channel, info))
+	if (!iio_channel_has_info(chan->channel, info))
 		return -EINVAL;
 
 	if (chan->indio_dev->info->read_raw_multi) {

commit 48436e82fd2925a42293f670f3570b5c855c90c1
Merge: 8d9b39c6499b 7e1da86339f2
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Feb 1 13:07:38 2016 -0800

    Merge tag 'iio-fixes-for-4.5a' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-linus
    
    Jonathan writes:
    
    First set of IIO fixes for the 4.5 cycle.
    
    This set comprises those not dependent on patches in the 4.5 merge cycle.
    A second set will follow shortly with ones that are.
    
    * core in kernel interfaces
      - fix a possible NULL dereference that is a theoretical possibility
        via odd usage of iio_channel_release. Pretty much a hardening of
        the interface, but observed in the wild with the twl4030_charger
        driver.
    * acpi-als
      - report the data as processed as it is in lux.  This fixes a wrong
        use of the IIO ABI.  However, old _raw version retained to avoid
        breaking any userspace in the wild that is relying on that (none
        known but it doesn't hurt us much to retain it)
    * ade7753
      - fix some error handling to avoid use of unitialized data.
    * ltr501
      - use a signed return type for ltr501_match_samp_freq so as to allow
        returning of an error code.
    * mcp4725
      - set name field of struct iio_dev to ensure the sysfs name attribute
        doesn't give NULL.
    * mpl115
      - temperature offset sign is wrong.
    * stk8ba50
      - IIO_TRIGGER dependency added
    * ti_am335x_adc
      - Label buffer as a software buffer. It's actually a hybrid of a
        true hardware buffer feeding a kfifo, but the meaning of these fields
        has changed a little recently and in this case it should be labeled
        a software buffer ensure it is allowed to use the kfifo.
    * vf610_adc
      - HAS_IOMEM dependency

commit d81dac3c1c5295c61b15293074ac2bd3254e1875
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Jan 26 12:25:21 2016 +0300

    iio: inkern: fix a NULL dereference on error
    
    In twl4030_bci_probe() there are some failure paths where we call
    iio_channel_release() with a NULL pointer.  (Apparently, that driver can
    opperate without a valid channel pointer).  Let's fix it by adding a
    NULL check in iio_channel_release().
    
    Fixes: 2202e1fc5a29 ('drivers: power: twl4030_charger: fix link problems when building as module')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: <Stable@vger.kernel.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index c8bad3cf891d..217e9306aa0f 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -351,6 +351,8 @@ EXPORT_SYMBOL_GPL(iio_channel_get);
 
 void iio_channel_release(struct iio_channel *channel)
 {
+	if (!channel)
+		return;
 	iio_device_put(channel->indio_dev);
 	kfree(channel);
 }

commit c34c18195d30aa3b95f5ae1b4349875c45fdb8e4
Author: Anshul Garg <aksgarg1989@gmail.com>
Date:   Tue Dec 8 09:45:56 2015 -0800

    iio/inkern.c Use list_for_each_entry_safe
    
    Use list_for_each_entry_safe instead of list_for_each_safe
    and list_entry call.
    
    Signed-off-by: Anshul Garg <aksgarg1989@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index c8bad3cf891d..80fbbfd76faf 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -61,12 +61,10 @@ EXPORT_SYMBOL_GPL(iio_map_array_register);
 int iio_map_array_unregister(struct iio_dev *indio_dev)
 {
 	int ret = -ENODEV;
-	struct iio_map_internal *mapi;
-	struct list_head *pos, *tmp;
+	struct iio_map_internal *mapi, *next;
 
 	mutex_lock(&iio_map_list_lock);
-	list_for_each_safe(pos, tmp, &iio_map_list) {
-		mapi = list_entry(pos, struct iio_map_internal, l);
+	list_for_each_entry_safe(mapi, next, &iio_map_list, l) {
 		if (indio_dev == mapi->indio_dev) {
 			list_del(&mapi->l);
 			kfree(mapi);

commit 6e49557b316e8db983a6d40d18e88ab0ba8571ef
Merge: e60088575bcb df1fad80dfa0
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jan 21 10:13:37 2015 +0800

    Merge tag 'iio-for-3.20a_take2' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-testing
    
    Jonathan writes:
    
    First round of IIO new drivers, cleanups and functionality for the 3.20 cycle take 2
    
    Updated pull request with Daniel's fix on top for the power management
    Kconfig changes that had snuck in since last update of the IIO tree
    worked it's way through from mainline.
    
    Original pull message
    
    New device support
    * jsa1212 proxmity / ambient light sensor
    * SM08500 supported added to the kxcjk-1013 accelerometer driver
    * KMX61 Accelerometer/Magnetometer.  This took a somewhat rocky path
      being first merged, then reverted for a rewrite after a discussion of
      how to support additional functionality and finally being merged prior
      to some last reviews coming in, with resultant follow up patches.
    * Freescale mma9551l driver (minor follow up warning supression patch).
    * Semtech SX9500 proximity device driver.
    * ak8975 gains support for ak09911 and ak09912 and drop the standalone driver
      for the ak09911.
    
    New functionality
     * Dummy driver gains some virtual registers making it more flexible.
     * IIO_ACTIVITY channel types, with modifiers running, walking etc.  This is
       to support on chip motion clasifiers.  As such it is in the form of a
       confidence percentage.  The only devices so far only do binary decisions
       but this gives us room when other devices give more nuanced clasification.
     * IIO_EV_DIR_NONE type for events where there is no obvious direction.
       First case is step detection.
     * IIO_STEPS channel type for pedometers.
     * ENABLE mask element used to control turning on counting types such as
       the pedometer that need a 'start point'.
     * INSTANCE event type to support things that happen once.
     * info element for height calibration (used in various motion estimation
       algorithms). Note heigh tof use
     * dummy driver demonstration of the use of all the new bits above.
     * event monitor support for the new events.
     * inv_mpu6050 gains an i2c mux to allow bypassing the device to access
       additional devices connected on the other side of it.  Note that in
       Windows these are handled by firmware on the device and not exposed
       directly.
     * inv_mpu6050 gains ACPI enumeration.
     * inkern interface gains iio_write_channel_raw to allow in kernel users
       of DAC functionality via a simple wrapper.
     * Document input current readings in the ABI docs.
     * Add an error message when we get an out of range error in device tree
       processing for the in kernel interfaces.  Basically a device tree debugging
       aid.
     * Add a sanity check that a scan index for a channel is unique during
       registration.  There to help catch bugs as this should never happen
       in a bug free driver.
    
    Cleanups and fixlets
    
     A rework of buffer registration from Lars - a precursor to some other
     upcoming new stuff (a few patches from others rolled in here as well).
     * Ensure all drivers register the same channels for the device and buffer.
     * Move buffer registration into the core rather than using the old
       two step approach.  Now we have simple ways of using a unified set channels
       for both without requiring channels be exposed by both interface, this
       removes a fair bit of boilerplate.
     * Stop sca3000 and ad5933 (both in staging) enabling buffer channels by
       default. It has long be convention in IIO to startup with no channels
       enabled and leave it up to userspace to say what goes in the buffer.
       Getting rid of these allows us to drop export of iio_scan_mask_set.
     * Drop get_bytes_per_datum from iio_buffer_access_funcs as not been used
       for a while.
     * Allocate standard buffer attributes in the core rather than in every
       driver with a buffer.
     * Make the length attribute read only when a driver is not able to set
       the length.
     * Drop the get_length callback for buffers as it is already available in
       struct iio_buffer.
     * Drop an unused arguement form iio_kfifo_allocate and add devm allocator
       for it.
     * some kconfig entries gain anotation with the resulting module name.
     * Fix a resulting compile issue in dummy driver due to a stub taking
       wrong parameters as a result of the above rework.
     * Fix an off by 2 error in copying the core assigned buffer attributes.
    
    Other cleanups,
     * Trivial space before comma fixups.
     * ak8975 fixlets - none critical.  Rework to allow more device support.
     * Drop unnecessary sizeof(u8) calls.
     * bmp280 - refactor the compensation code to reduce copy operations and
       code length.  A second patch futher optimized this and performed some
       other minor cleanups.
     * kxcjk-1013 - various power control cleanups to avoid unnecessary enable
       / disable of device.  Make sure it is only controlled at all if CONFIG_PM
       is enabled.  Also som cleanups of error paths.
     * Small cleanups in adf4530 driver - pointless message and unnecessary braces.
     * Clarifiy the proximity ABI docs to make it clear it should get bigger
       as we move futher away.
     * Drop a misleading comment form industrialio-core.c
     * Trivial white space cleanups.
     * sca3000 looses an unused debug function.
     * Fix char unsigned ordering in ad8366
     * Increase the sleep time in ad9523 to make it predictable (value didn't
       really matter so make it more than 20 msecs)
     * mxs-lradc touchscreen property cleanups in device tree are fixed to ensure
       the meet all the 'interesting' documentation.
     * A couple of cleanups for the staging ad5933 driver to avoid unnecessary
       conversion to a processed temperature vlaue in kernel and remove
       platform data form the state structure as not needed after probe.
     * Fix a wrong scale factor in the docs.
    
    Misc
     * Add IIO include files to the maintainers entry.

commit 8ecb55b849b74dff026681b41266970072b207dd
Merge: b7392d2247cf 65de7654d39c
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jan 8 17:59:04 2015 -0800

    Merge tag 'iio-fixes-for-3.19a' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-linus
    
    Jonathan writes:
    
    First round of IIO fixes for the 3.19 cycle.
    
    * ad799x fix ad7991/ad7995/ad7999 setup as they do not have a configuration
      register to write to.  It is written during the convesion sequence. As
      such we don't want to write to it at other times.
    * Fix iio_channel_read utility function to return to ensure it is apparent
      if the relevant element is not there. This avoids using a wrong value
      if some channels have the element and others do not.

commit 1f202725b70c3d6dc736904a0d1b77a5faed6690
Author: Stefan Wahren <stefan.wahren@i2se.com>
Date:   Thu Jan 1 18:13:24 2015 +0000

    iio: inkern: add out of range error message
    
    If the DT contains an invalid channel specifier then the probe of
    iio_hwmon fails with the following message:
    
    iio_hwmon: probe of iio_hwmon failed with error -22
    
    So it's better to print out the relevant channel specifier in
    error case to locate the problem.
    
    Signed-off-by: Stefan Wahren <stefan.wahren@i2se.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 21655fd1465c..2800b80ea990 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -116,8 +116,11 @@ static int __of_iio_simple_xlate(struct iio_dev *indio_dev,
 	if (!iiospec->args_count)
 		return 0;
 
-	if (iiospec->args[0] >= indio_dev->num_channels)
+	if (iiospec->args[0] >= indio_dev->num_channels) {
+		dev_err(&indio_dev->dev, "invalid channel index %u\n",
+			iiospec->args[0]);
 		return -EINVAL;
+	}
 
 	return iiospec->args[0];
 }

commit 65de7654d39c70c2b942f801cea01590cf7e3458
Author: Fabien Proriol <fabien.proriol@jdsu.com>
Date:   Thu Jan 1 12:46:48 2015 +0000

    iio: iio: Fix iio_channel_read return if channel havn't info
    
    When xilinx-xadc is used with hwmon driver to read voltage, offset used
    for temperature is always applied whatever the channel.
    
    iio_channel_read must return an error to avoid offset for channel
    without IIO_CHAN_INFO_OFFSET property.
    
    Signed-off-by: Fabien Proriol <fabien.proriol@jdsu.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index f0846108d006..d33590e89337 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -426,6 +426,9 @@ static int iio_channel_read(struct iio_channel *chan, int *val, int *val2,
 	if (val2 == NULL)
 		val2 = &unused;
 
+	if(!iio_channel_has_info(chan->channel, info))
+		return -EINVAL;
+
 	if (chan->indio_dev->info->read_raw_multi) {
 		ret = chan->indio_dev->info->read_raw_multi(chan->indio_dev,
 					chan->channel, INDIO_MAX_RAW_ELEMENTS,

commit f9380e7123863a4cb0627d940533be954a0a15df
Author: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
Date:   Thu Nov 27 01:42:45 2014 +0300

    iio: inkern: add iio_write_channel_raw
    
    Introduce API for easy in-kernel setting of DAC values.
    
    Signed-off-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 866fe904cba2..21655fd1465c 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -631,3 +631,28 @@ int iio_get_channel_type(struct iio_channel *chan, enum iio_chan_type *type)
 	return ret;
 }
 EXPORT_SYMBOL_GPL(iio_get_channel_type);
+
+static int iio_channel_write(struct iio_channel *chan, int val, int val2,
+			     enum iio_chan_info_enum info)
+{
+	return chan->indio_dev->info->write_raw(chan->indio_dev,
+						chan->channel, val, val2, info);
+}
+
+int iio_write_channel_raw(struct iio_channel *chan, int val)
+{
+	int ret;
+
+	mutex_lock(&chan->indio_dev->info_exist_lock);
+	if (chan->indio_dev->info == NULL) {
+		ret = -ENODEV;
+		goto err_unlock;
+	}
+
+	ret = iio_channel_write(chan, val, 0, IIO_CHAN_INFO_RAW);
+err_unlock:
+	mutex_unlock(&chan->indio_dev->info_exist_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(iio_write_channel_raw);

commit be61a0d78449f53519905640ac3a9f24c197cbaf
Merge: 7be921a226dc 4e4cd14e7cbe
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 5 11:42:48 2014 -0800

    Merge tag 'iio-for-3.19a' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-next
    
    Jonathan writes:
    
    First round of new drivers, features and cleanups for IIO in the 3.19 cycle.
    
    New drivers / supported parts
    * rockchip - rk3066-tsadc variant
    * si7020 humidity and temperature sensor
    * mcp320x - add mcp3001, mcp3002, mcp3004, mcp3008, mcp3201, mcp3202
    * bmp280 pressure and temperature sensor
    * Qualcomm SPMI PMIC current ADC driver
    * Exynos_adc - support exynos7
    
    New features
    * vf610-adc - add temperature sensor support
    * Documentation of current attributes, scaled pressure, offset and
      scaled humidity, RGBC intensity gain factor and scale applied to
      differential voltage channels.
    * Bring iio_event_monitor up to date with newer modifiers.
    * Add of_xlate function to allow for complex channel mappings from the
      device tree.
    * Add -g parameter to generic_buffer example to allow for devices with
      directly fed (no trigger) buffers.
    * Move exynos driver over to syscon for PMU register access.
    
    Cleanups, fixes for new drivers
    * lis3l02dq drop an unneeded else.
    * st sensors - renam st_sensors to st_sensor_settings (for clarity)
    * st sensors - drop an unused parameter from all the probe utility
      functions.
    * vf610 better error handling and tidy up.
    * si7020 - cleanups following merge
    * as3935 - drop some unnecessary semicolons.
    * bmp280 - fix the pressure calculation.

commit acd8256723f286b7217801fbed24503f8565b91e
Author: Ivan T. Ivanov <iivanov@mm-sol.com>
Date:   Wed Oct 22 18:29:43 2014 +0300

    iio: inkern: Add of_xlate function to struct iio_info
    
    When #iio-cells is greater than '0', the driver could provide
    a custom of_xlate function that reads the *args* and returns
    the appropriate index in registered IIO channels array.
    
    Add simple translation function, suitable for the most 1:1
    mapped channels in IIO chips, and use it when driver did not
    provide custom implementation.
    
    Signed-off-by: Ivan T. Ivanov <iivanov@mm-sol.com>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index c7497009d60a..0cc505d98686 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -100,6 +100,28 @@ static int iio_dev_node_match(struct device *dev, void *data)
 	return dev->of_node == data && dev->type == &iio_device_type;
 }
 
+/**
+ * __of_iio_simple_xlate - translate iiospec to the IIO channel index
+ * @indio_dev:	pointer to the iio_dev structure
+ * @iiospec:	IIO specifier as found in the device tree
+ *
+ * This is simple translation function, suitable for the most 1:1 mapped
+ * channels in IIO chips. This function performs only one sanity check:
+ * whether IIO index is less than num_channels (that is specified in the
+ * iio_dev).
+ */
+static int __of_iio_simple_xlate(struct iio_dev *indio_dev,
+				const struct of_phandle_args *iiospec)
+{
+	if (!iiospec->args_count)
+		return 0;
+
+	if (iiospec->args[0] >= indio_dev->num_channels)
+		return -EINVAL;
+
+	return iiospec->args[0];
+}
+
 static int __of_iio_channel_get(struct iio_channel *channel,
 				struct device_node *np, int index)
 {
@@ -122,18 +144,19 @@ static int __of_iio_channel_get(struct iio_channel *channel,
 
 	indio_dev = dev_to_iio_dev(idev);
 	channel->indio_dev = indio_dev;
-	index = iiospec.args_count ? iiospec.args[0] : 0;
-	if (index >= indio_dev->num_channels) {
-		err = -EINVAL;
+	if (indio_dev->info->of_xlate)
+		index = indio_dev->info->of_xlate(indio_dev, &iiospec);
+	else
+		index = __of_iio_simple_xlate(indio_dev, &iiospec);
+	if (index < 0)
 		goto err_put;
-	}
 	channel->channel = &indio_dev->channels[index];
 
 	return 0;
 
 err_put:
 	iio_device_put(indio_dev);
-	return err;
+	return index;
 }
 
 static struct iio_channel *of_iio_channel_get(struct device_node *np, int index)

commit 872687f626e033b4ddfaec1e410057cfc6636d77
Author: Johannes Pointner <johannes.pointner@gmail.com>
Date:   Mon Aug 25 09:04:00 2014 +0100

    iio:inkern: fix overwritten -EPROBE_DEFER in of_iio_channel_get_by_name
    
    Fixes: a2c12493ed7e ('iio: of_iio_channel_get_by_name() returns non-null pointers for error legs')
    
    which improperly assumes that of_iio_channel_get_by_name must always
    return NULL and thus now hides -EPROBE_DEFER.
    
    Signed-off-by: Johannes Pointner <johannes.pointner@br-automation.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Cc: Stable@vger.kernel.org

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index c7497009d60a..f0846108d006 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -178,7 +178,7 @@ static struct iio_channel *of_iio_channel_get_by_name(struct device_node *np,
 			index = of_property_match_string(np, "io-channel-names",
 							 name);
 		chan = of_iio_channel_get(np, index);
-		if (!IS_ERR(chan))
+		if (!IS_ERR(chan) || PTR_ERR(chan) == -EPROBE_DEFER)
 			break;
 		else if (name && index >= 0) {
 			pr_err("ERROR: could not get IIO channel %s:%s(%i)\n",

commit a2c12493ed7e63a18cef33a71686d12ffcd6600e
Author: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
Date:   Thu Nov 6 12:11:00 2014 +0000

    iio: of_iio_channel_get_by_name() returns non-null pointers for error legs
    
    Currently in the inkern.c code for IIO framework, the function
    of_iio_channel_get_by_name() will return a non-NULL pointer when
    it cannot find a channel using of_iio_channel_get() and when it
    tries to search for 'io-channel-ranges' property and fails. This
    is incorrect behaviour as the function which calls this expects
    a NULL pointer for failure. This patch rectifies the issue.
    
    Signed-off-by: Adam Thomson <Adam.Thomson.Opensource@diasemi.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Cc: Stable@vger.kernel.org

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index d833d55052ea..c7497009d60a 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -183,7 +183,7 @@ static struct iio_channel *of_iio_channel_get_by_name(struct device_node *np,
 		else if (name && index >= 0) {
 			pr_err("ERROR: could not get IIO channel %s:%s(%i)\n",
 				np->full_name, name ? name : "", index);
-			return chan;
+			return NULL;
 		}
 
 		/*
@@ -193,8 +193,9 @@ static struct iio_channel *of_iio_channel_get_by_name(struct device_node *np,
 		 */
 		np = np->parent;
 		if (np && !of_get_property(np, "io-channel-ranges", NULL))
-			break;
+			return NULL;
 	}
+
 	return chan;
 }
 
@@ -317,6 +318,7 @@ struct iio_channel *iio_channel_get(struct device *dev,
 		if (channel != NULL)
 			return channel;
 	}
+
 	return iio_channel_get_sys(name, channel_name);
 }
 EXPORT_SYMBOL_GPL(iio_channel_get);

commit 9fbfb4b37ed23f71aa9484484266381c6c6964cb
Author: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
Date:   Tue Apr 29 00:51:00 2014 +0100

    IIO: core: Introduce read_raw_multi
    
    This callback is introduced to overcome some limitations of existing
    read_raw callback. The functionality of both existing read_raw and
    read_raw_multi is similar, both are used to request values from the
    device. The current read_raw callback allows only two return values.
    The new read_raw_multi allows returning multiple values. Instead of
    passing just address of val and val2, it passes length and pointer
    to values. Depending on the type and length of passed buffer, iio
    client drivers can return multiple values.
    
    Signed-off-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index adeba5a0ecf7..d833d55052ea 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -417,12 +417,24 @@ static int iio_channel_read(struct iio_channel *chan, int *val, int *val2,
 	enum iio_chan_info_enum info)
 {
 	int unused;
+	int vals[INDIO_MAX_RAW_ELEMENTS];
+	int ret;
+	int val_len = 2;
 
 	if (val2 == NULL)
 		val2 = &unused;
 
-	return chan->indio_dev->info->read_raw(chan->indio_dev, chan->channel,
-						val, val2, info);
+	if (chan->indio_dev->info->read_raw_multi) {
+		ret = chan->indio_dev->info->read_raw_multi(chan->indio_dev,
+					chan->channel, INDIO_MAX_RAW_ELEMENTS,
+					vals, &val_len, info);
+		*val = vals[0];
+		*val2 = vals[1];
+	} else
+		ret = chan->indio_dev->info->read_raw(chan->indio_dev,
+					chan->channel, val, val2, info);
+
+	return ret;
 }
 
 int iio_read_channel_raw(struct iio_channel *chan, int *val)

commit 476d4af22cec8a9ebc90137712e5ab7070b7379d
Author: Sebastian Reichel <sre@debian.org>
Date:   Fri Oct 3 17:25:00 2014 +0100

    iio: inkern: add iio_read_channel_average_raw
    
    Add iio_read_channel_average_raw to support reading
    averaged raw values in consumer drivers.
    
    Signed-off-by: Sebastian Reichel <sre@debian.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 0cf5f8e06cfc..adeba5a0ecf7 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -443,6 +443,24 @@ int iio_read_channel_raw(struct iio_channel *chan, int *val)
 }
 EXPORT_SYMBOL_GPL(iio_read_channel_raw);
 
+int iio_read_channel_average_raw(struct iio_channel *chan, int *val)
+{
+	int ret;
+
+	mutex_lock(&chan->indio_dev->info_exist_lock);
+	if (chan->indio_dev->info == NULL) {
+		ret = -ENODEV;
+		goto err_unlock;
+	}
+
+	ret = iio_channel_read(chan, val, NULL, IIO_CHAN_INFO_AVERAGE_RAW);
+err_unlock:
+	mutex_unlock(&chan->indio_dev->info_exist_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(iio_read_channel_average_raw);
+
 static int iio_convert_raw_to_processed_unlocked(struct iio_channel *chan,
 	int raw, int *processed, unsigned int scale)
 {

commit f91d1b63a4e096d3023aaaafec9d9d3aff25997f
Author: Alexandre Belloni <alexandre.belloni@free-electrons.com>
Date:   Mon Jul 1 17:40:00 2013 +0100

    iio: inkern: fix iio_convert_raw_to_processed_unlocked
    
    When reading IIO_CHAN_INFO_OFFSET, the return value of iio_channel_read() for
    success will be IIO_VAL*, checking for 0 is not correct.
    
    Without this fix the offset applied by iio drivers will be ignored when
    converting a raw value to one in appropriate base units (e.g mV) in
    a IIO client drivers that use iio_convert_raw_to_processed including
    iio-hwmon.
    
    Cc: <stable@vger.kernel.org> # 3.10.x
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 98ddc323add0..0cf5f8e06cfc 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -451,7 +451,7 @@ static int iio_convert_raw_to_processed_unlocked(struct iio_channel *chan,
 	int ret;
 
 	ret = iio_channel_read(chan, &offset, NULL, IIO_CHAN_INFO_OFFSET);
-	if (ret == 0)
+	if (ret >= 0)
 		raw64 += offset;
 
 	scale_type = iio_channel_read(chan, &scale_val, &scale_val2,

commit 6c5d4c96f979611f0165dc825af9e1cea8dd35b9
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Mon Jun 3 09:04:00 2013 +0100

    iio:inkern: Fix typo/bug in convert raw to processed.
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index dca4eed7b034..98ddc323add0 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -450,7 +450,7 @@ static int iio_convert_raw_to_processed_unlocked(struct iio_channel *chan,
 	s64 raw64 = raw;
 	int ret;
 
-	ret = iio_channel_read(chan, &offset, NULL, IIO_CHAN_INFO_SCALE);
+	ret = iio_channel_read(chan, &offset, NULL, IIO_CHAN_INFO_OFFSET);
 	if (ret == 0)
 		raw64 += offset;
 

commit e916b80d2b1988e985abc0a1c85eca5b96c61f48
Author: Joe Perches <joe@perches.com>
Date:   Tue Jun 4 15:44:00 2013 +0100

    inkern: iio_device_put after incorrect return/goto
    
    The code uses
    
        return foo;
        goto err_type;
    
    when instead the form should have been
    
        ret = foo;
        goto err_type;
    
    Here this causes a useful iio_device_put to be skipped.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 795d100b4c36..dca4eed7b034 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -124,7 +124,7 @@ static int __of_iio_channel_get(struct iio_channel *channel,
 	channel->indio_dev = indio_dev;
 	index = iiospec.args_count ? iiospec.args[0] : 0;
 	if (index >= indio_dev->num_channels) {
-		return -EINVAL;
+		err = -EINVAL;
 		goto err_put;
 	}
 	channel->channel = &indio_dev->channels[index];

commit 17d82b47a215ded05ee3fb8d93b7c1269dbe0083
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Thu Feb 7 17:09:00 2013 +0000

    iio: Add OF support
    
    Provide bindings and parse OF data during initialization.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index b289915b8469..795d100b4c36 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -10,6 +10,7 @@
 #include <linux/export.h>
 #include <linux/slab.h>
 #include <linux/mutex.h>
+#include <linux/of.h>
 
 #include <linux/iio/iio.h>
 #include "iio_core.h"
@@ -92,6 +93,164 @@ static const struct iio_chan_spec
 	return chan;
 }
 
+#ifdef CONFIG_OF
+
+static int iio_dev_node_match(struct device *dev, void *data)
+{
+	return dev->of_node == data && dev->type == &iio_device_type;
+}
+
+static int __of_iio_channel_get(struct iio_channel *channel,
+				struct device_node *np, int index)
+{
+	struct device *idev;
+	struct iio_dev *indio_dev;
+	int err;
+	struct of_phandle_args iiospec;
+
+	err = of_parse_phandle_with_args(np, "io-channels",
+					 "#io-channel-cells",
+					 index, &iiospec);
+	if (err)
+		return err;
+
+	idev = bus_find_device(&iio_bus_type, NULL, iiospec.np,
+			       iio_dev_node_match);
+	of_node_put(iiospec.np);
+	if (idev == NULL)
+		return -EPROBE_DEFER;
+
+	indio_dev = dev_to_iio_dev(idev);
+	channel->indio_dev = indio_dev;
+	index = iiospec.args_count ? iiospec.args[0] : 0;
+	if (index >= indio_dev->num_channels) {
+		return -EINVAL;
+		goto err_put;
+	}
+	channel->channel = &indio_dev->channels[index];
+
+	return 0;
+
+err_put:
+	iio_device_put(indio_dev);
+	return err;
+}
+
+static struct iio_channel *of_iio_channel_get(struct device_node *np, int index)
+{
+	struct iio_channel *channel;
+	int err;
+
+	if (index < 0)
+		return ERR_PTR(-EINVAL);
+
+	channel = kzalloc(sizeof(*channel), GFP_KERNEL);
+	if (channel == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	err = __of_iio_channel_get(channel, np, index);
+	if (err)
+		goto err_free_channel;
+
+	return channel;
+
+err_free_channel:
+	kfree(channel);
+	return ERR_PTR(err);
+}
+
+static struct iio_channel *of_iio_channel_get_by_name(struct device_node *np,
+						      const char *name)
+{
+	struct iio_channel *chan = NULL;
+
+	/* Walk up the tree of devices looking for a matching iio channel */
+	while (np) {
+		int index = 0;
+
+		/*
+		 * For named iio channels, first look up the name in the
+		 * "io-channel-names" property.  If it cannot be found, the
+		 * index will be an error code, and of_iio_channel_get()
+		 * will fail.
+		 */
+		if (name)
+			index = of_property_match_string(np, "io-channel-names",
+							 name);
+		chan = of_iio_channel_get(np, index);
+		if (!IS_ERR(chan))
+			break;
+		else if (name && index >= 0) {
+			pr_err("ERROR: could not get IIO channel %s:%s(%i)\n",
+				np->full_name, name ? name : "", index);
+			return chan;
+		}
+
+		/*
+		 * No matching IIO channel found on this node.
+		 * If the parent node has a "io-channel-ranges" property,
+		 * then we can try one of its channels.
+		 */
+		np = np->parent;
+		if (np && !of_get_property(np, "io-channel-ranges", NULL))
+			break;
+	}
+	return chan;
+}
+
+static struct iio_channel *of_iio_channel_get_all(struct device *dev)
+{
+	struct iio_channel *chans;
+	int i, mapind, nummaps = 0;
+	int ret;
+
+	do {
+		ret = of_parse_phandle_with_args(dev->of_node,
+						 "io-channels",
+						 "#io-channel-cells",
+						 nummaps, NULL);
+		if (ret < 0)
+			break;
+	} while (++nummaps);
+
+	if (nummaps == 0)	/* no error, return NULL to search map table */
+		return NULL;
+
+	/* NULL terminated array to save passing size */
+	chans = kcalloc(nummaps + 1, sizeof(*chans), GFP_KERNEL);
+	if (chans == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	/* Search for OF matches */
+	for (mapind = 0; mapind < nummaps; mapind++) {
+		ret = __of_iio_channel_get(&chans[mapind], dev->of_node,
+					   mapind);
+		if (ret)
+			goto error_free_chans;
+	}
+	return chans;
+
+error_free_chans:
+	for (i = 0; i < mapind; i++)
+		iio_device_put(chans[i].indio_dev);
+	kfree(chans);
+	return ERR_PTR(ret);
+}
+
+#else /* CONFIG_OF */
+
+static inline struct iio_channel *
+of_iio_channel_get_by_name(struct device_node *np, const char *name)
+{
+	return NULL;
+}
+
+static inline struct iio_channel *of_iio_channel_get_all(struct device *dev)
+{
+	return NULL;
+}
+
+#endif /* CONFIG_OF */
 
 static struct iio_channel *iio_channel_get_sys(const char *name,
 					       const char *channel_name)
@@ -150,7 +309,14 @@ struct iio_channel *iio_channel_get(struct device *dev,
 				    const char *channel_name)
 {
 	const char *name = dev ? dev_name(dev) : NULL;
+	struct iio_channel *channel;
 
+	if (dev) {
+		channel = of_iio_channel_get_by_name(dev->of_node,
+						     channel_name);
+		if (channel != NULL)
+			return channel;
+	}
 	return iio_channel_get_sys(name, channel_name);
 }
 EXPORT_SYMBOL_GPL(iio_channel_get);
@@ -173,6 +339,11 @@ struct iio_channel *iio_channel_get_all(struct device *dev)
 
 	if (dev == NULL)
 		return ERR_PTR(-EINVAL);
+
+	chans = of_iio_channel_get_all(dev);
+	if (chans)
+		return chans;
+
 	name = dev_name(dev);
 
 	mutex_lock(&iio_map_list_lock);

commit 5aa57f0a655276f62683c0cc714cd6328d98e08a
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Mon Feb 4 20:26:00 2013 +0000

    iio: Update iio_channel_get API to use consumer device pointer as argument
    
    For iio_channel_get to work with OF based configurations, it needs the
    consumer device pointer instead of the consumer device name as argument.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Anton Vorontsov <anton@enomsg.org>
    Acked-by: Chanwoo Choi <cw00.choi@samsung.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index c42aba6817e8..b289915b8469 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -93,7 +93,8 @@ static const struct iio_chan_spec
 }
 
 
-struct iio_channel *iio_channel_get(const char *name, const char *channel_name)
+static struct iio_channel *iio_channel_get_sys(const char *name,
+					       const char *channel_name)
 {
 	struct iio_map_internal *c_i = NULL, *c = NULL;
 	struct iio_channel *channel;
@@ -144,6 +145,14 @@ struct iio_channel *iio_channel_get(const char *name, const char *channel_name)
 	iio_device_put(c->indio_dev);
 	return ERR_PTR(err);
 }
+
+struct iio_channel *iio_channel_get(struct device *dev,
+				    const char *channel_name)
+{
+	const char *name = dev ? dev_name(dev) : NULL;
+
+	return iio_channel_get_sys(name, channel_name);
+}
 EXPORT_SYMBOL_GPL(iio_channel_get);
 
 void iio_channel_release(struct iio_channel *channel)

commit 6cb2afd7c0abb93bd9dc6d36b858b1e312e2407d
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Thu Jan 31 21:43:00 2013 +0000

    iio: Simplify iio_map_array_unregister API
    
    Instead of requiring the map to unregister, simply unregister all map entries
    associated with the given iio device. This simplifies map removal and also works
    for maps generated through devicetree.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 58d0ffe856b6..c42aba6817e8 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -54,39 +54,25 @@ int iio_map_array_register(struct iio_dev *indio_dev, struct iio_map *maps)
 EXPORT_SYMBOL_GPL(iio_map_array_register);
 
 
-/* Assumes the exact same array (e.g. memory locations)
- * used at unregistration as used at registration rather than
- * more complex checking of contents.
+/*
+ * Remove all map entries associated with the given iio device
  */
-int iio_map_array_unregister(struct iio_dev *indio_dev,
-			     struct iio_map *maps)
+int iio_map_array_unregister(struct iio_dev *indio_dev)
 {
-	int i = 0, ret = 0;
-	bool found_it;
+	int ret = -ENODEV;
 	struct iio_map_internal *mapi;
-
-	if (maps == NULL)
-		return 0;
+	struct list_head *pos, *tmp;
 
 	mutex_lock(&iio_map_list_lock);
-	while (maps[i].consumer_dev_name != NULL) {
-		found_it = false;
-		list_for_each_entry(mapi, &iio_map_list, l)
-			if (&maps[i] == mapi->map) {
-				list_del(&mapi->l);
-				kfree(mapi);
-				found_it = true;
-				break;
-			}
-		if (!found_it) {
-			ret = -ENODEV;
-			goto error_ret;
+	list_for_each_safe(pos, tmp, &iio_map_list) {
+		mapi = list_entry(pos, struct iio_map_internal, l);
+		if (indio_dev == mapi->indio_dev) {
+			list_del(&mapi->l);
+			kfree(mapi);
+			ret = 0;
 		}
-		i++;
 	}
-error_ret:
 	mutex_unlock(&iio_map_list_lock);
-
 	return ret;
 }
 EXPORT_SYMBOL_GPL(iio_map_array_unregister);

commit ca7d98dbd7db6aa8bc4b08e26be1249436d21af3
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Thu Jan 31 21:43:00 2013 +0000

    iio: Update iio_channel_get_all and iio_channel_get_all_cb API
    
    Pass device pointer instead of device name as parameter to iio_channel_get_all
    and iio_channel_get_all_cb. This will enable us to use OF information to
    retrieve consumer channel information.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index d55e98fb300e..58d0ffe856b6 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -167,16 +167,18 @@ void iio_channel_release(struct iio_channel *channel)
 }
 EXPORT_SYMBOL_GPL(iio_channel_release);
 
-struct iio_channel *iio_channel_get_all(const char *name)
+struct iio_channel *iio_channel_get_all(struct device *dev)
 {
+	const char *name;
 	struct iio_channel *chans;
 	struct iio_map_internal *c = NULL;
 	int nummaps = 0;
 	int mapind = 0;
 	int i, ret;
 
-	if (name == NULL)
+	if (dev == NULL)
 		return ERR_PTR(-EINVAL);
+	name = dev_name(dev);
 
 	mutex_lock(&iio_map_list_lock);
 	/* first count the matching maps */

commit 0464415dd21785aa8e8b12dbc939fcb5ca52f464
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sat Jun 30 20:06:00 2012 +0100

    staging:iio:in kernel users: Add a data field for channel specific info.
    
    Used to allow information about a given channel mapping to be passed
    through from board files to the consumer drivers.
    
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index b394621d362c..d55e98fb300e 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -203,6 +203,7 @@ struct iio_channel *iio_channel_get_all(const char *name)
 		if (name && strcmp(name, c->map->consumer_dev_name) != 0)
 			continue;
 		chans[mapind].indio_dev = c->indio_dev;
+		chans[mapind].data = c->map->consumer_data;
 		chans[mapind].channel =
 			iio_chan_spec_from_name(chans[mapind].indio_dev,
 						c->map->adc_channel_label);

commit 103d9fb907058e4eb052f4f7302d1b07eb6a7792
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Oct 16 17:29:00 2012 +0100

    iio: Add a logarithmic fractional value type
    
    For ADCs or DACs the denominator for fractional types often is a power of two.
    In this case we can use a shift operation instead of the rather expensive 64 bit
    division. This patch adds a new fractional type which expects the denominator to
    be specified as the log2 of the actual denominator. E.g. for ADCs and DACs this
    will usually be the number of significant bits.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 5230a33886c0..b394621d362c 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -314,6 +314,9 @@ static int iio_convert_raw_to_processed_unlocked(struct iio_channel *chan,
 		*processed = div_s64(raw64 * (s64)scale_val * scale,
 				     scale_val2);
 		break;
+	case IIO_VAL_FRACTIONAL_LOG2:
+		*processed = (raw64 * (s64)scale_val * scale) >> scale_val2;
+		break;
 	default:
 		return -EINVAL;
 	}

commit 7737fa6d1ea3385428bd36a0dddcb33c526f7d74
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Oct 18 15:43:00 2012 +0100

    iio: Don't compare boolean values to true/false
    
    Fixes the following warnings from coccicheck:
            drivers/iio/inkern.c:81:6-14: WARNING: Comparison to bool
            drivers/iio/dac/ad5686.c:191:5-11: WARNING: Comparison to bool
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index f2b78d4fe457..5230a33886c0 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -78,7 +78,7 @@ int iio_map_array_unregister(struct iio_dev *indio_dev,
 				found_it = true;
 				break;
 			}
-		if (found_it == false) {
+		if (!found_it) {
 			ret = -ENODEV;
 			goto error_ret;
 		}

commit 3183bac16f537503eb3177773781d6d3059ad7b1
Author: Kim, Milo <Milo.Kim@ti.com>
Date:   Tue Sep 18 05:56:00 2012 +0100

    iio: inkern: clean up error return code
    
     When the IIO consumer tries to get specific IIO channel,
     few error cases can be happened.
     (a) Memory allocation failure
     (b) No matched ADC channel error
     (c) Invalid input arguments
     This patch enables cleaning up error handling in case of (a) and (b).
    
     In error handling code,
     (a): the reference count of the IIO device should be decreased.
     (b): the allocated memory should be freed with restoring the reference count.
     Therefore iio_deivce_put() is called in both cases.
     This can be handled in the last error statement.
    
     Additionally, integer variable is used for stating each error case explicitly.
     Then, the error returns as ERR_PTR() with this value.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index e38f41464fe4..f2b78d4fe457 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -111,6 +111,7 @@ struct iio_channel *iio_channel_get(const char *name, const char *channel_name)
 {
 	struct iio_map_internal *c_i = NULL, *c = NULL;
 	struct iio_channel *channel;
+	int err;
 
 	if (name == NULL && channel_name == NULL)
 		return ERR_PTR(-ENODEV);
@@ -131,8 +132,10 @@ struct iio_channel *iio_channel_get(const char *name, const char *channel_name)
 		return ERR_PTR(-ENODEV);
 
 	channel = kzalloc(sizeof(*channel), GFP_KERNEL);
-	if (channel == NULL)
+	if (channel == NULL) {
+		err = -ENOMEM;
 		goto error_no_mem;
+	}
 
 	channel->indio_dev = c->indio_dev;
 
@@ -141,19 +144,19 @@ struct iio_channel *iio_channel_get(const char *name, const char *channel_name)
 			iio_chan_spec_from_name(channel->indio_dev,
 						c->map->adc_channel_label);
 
-		if (channel->channel == NULL)
+		if (channel->channel == NULL) {
+			err = -EINVAL;
 			goto error_no_chan;
+		}
 	}
 
 	return channel;
 
 error_no_chan:
-	iio_device_put(c->indio_dev);
 	kfree(channel);
-	return ERR_PTR(-EINVAL);
 error_no_mem:
 	iio_device_put(c->indio_dev);
-	return ERR_PTR(-ENOMEM);
+	return ERR_PTR(err);
 }
 EXPORT_SYMBOL_GPL(iio_channel_get);
 

commit 801c4b5ca373c4cfe78912616d68e1f7fd84110c
Author: Kim, Milo <Milo.Kim@ti.com>
Date:   Tue Sep 18 05:55:00 2012 +0100

    iio: inkern: put the IIO device when it fails to allocate memory
    
     The reference count of the IIO device is increased if the IIO map has
     matched consumer name.
     After then, it tries to allocate the iio_channel which is used by the consumer.
     If it fails to allocate memory, the reference count should be decreased.
    
     This patch enables restoring the reference count of the IIO device.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 25b00761005a..e38f41464fe4 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -132,7 +132,7 @@ struct iio_channel *iio_channel_get(const char *name, const char *channel_name)
 
 	channel = kzalloc(sizeof(*channel), GFP_KERNEL);
 	if (channel == NULL)
-		return ERR_PTR(-ENOMEM);
+		goto error_no_mem;
 
 	channel->indio_dev = c->indio_dev;
 
@@ -151,6 +151,9 @@ struct iio_channel *iio_channel_get(const char *name, const char *channel_name)
 	iio_device_put(c->indio_dev);
 	kfree(channel);
 	return ERR_PTR(-EINVAL);
+error_no_mem:
+	iio_device_put(c->indio_dev);
+	return ERR_PTR(-ENOMEM);
 }
 EXPORT_SYMBOL_GPL(iio_channel_get);
 

commit 48e44ce0f8810b530fc83a4f5eb67149280d9b82
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Sep 17 13:17:00 2012 +0100

    iio:inkern: Add function to read the processed value
    
    Add a function to read a processed value from a channel. The function will first
    attempt to read the IIO_CHAN_INFO_PROCESSED attribute. If that fails it will
    read the IIO_CHAN_INFO_RAW attribute and convert the result from a raw value to
    a processed value.
    
    The patch also introduces a function to convert raw value to a processed value
    and exports it, in case a user needs or wants to do the conversion by itself.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index d539e1e297ba..25b00761005a 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -238,9 +238,21 @@ void iio_channel_release_all(struct iio_channel *channels)
 }
 EXPORT_SYMBOL_GPL(iio_channel_release_all);
 
+static int iio_channel_read(struct iio_channel *chan, int *val, int *val2,
+	enum iio_chan_info_enum info)
+{
+	int unused;
+
+	if (val2 == NULL)
+		val2 = &unused;
+
+	return chan->indio_dev->info->read_raw(chan->indio_dev, chan->channel,
+						val, val2, info);
+}
+
 int iio_read_channel_raw(struct iio_channel *chan, int *val)
 {
-	int val2, ret;
+	int ret;
 
 	mutex_lock(&chan->indio_dev->info_exist_lock);
 	if (chan->indio_dev->info == NULL) {
@@ -248,10 +260,7 @@ int iio_read_channel_raw(struct iio_channel *chan, int *val)
 		goto err_unlock;
 	}
 
-	ret = chan->indio_dev->info->read_raw(chan->indio_dev,
-					      chan->channel,
-					      val, &val2,
-					      IIO_CHAN_INFO_RAW);
+	ret = iio_channel_read(chan, val, NULL, IIO_CHAN_INFO_RAW);
 err_unlock:
 	mutex_unlock(&chan->indio_dev->info_exist_lock);
 
@@ -259,6 +268,100 @@ int iio_read_channel_raw(struct iio_channel *chan, int *val)
 }
 EXPORT_SYMBOL_GPL(iio_read_channel_raw);
 
+static int iio_convert_raw_to_processed_unlocked(struct iio_channel *chan,
+	int raw, int *processed, unsigned int scale)
+{
+	int scale_type, scale_val, scale_val2, offset;
+	s64 raw64 = raw;
+	int ret;
+
+	ret = iio_channel_read(chan, &offset, NULL, IIO_CHAN_INFO_SCALE);
+	if (ret == 0)
+		raw64 += offset;
+
+	scale_type = iio_channel_read(chan, &scale_val, &scale_val2,
+					IIO_CHAN_INFO_SCALE);
+	if (scale_type < 0)
+		return scale_type;
+
+	switch (scale_type) {
+	case IIO_VAL_INT:
+		*processed = raw64 * scale_val;
+		break;
+	case IIO_VAL_INT_PLUS_MICRO:
+		if (scale_val2 < 0)
+			*processed = -raw64 * scale_val;
+		else
+			*processed = raw64 * scale_val;
+		*processed += div_s64(raw64 * (s64)scale_val2 * scale,
+				      1000000LL);
+		break;
+	case IIO_VAL_INT_PLUS_NANO:
+		if (scale_val2 < 0)
+			*processed = -raw64 * scale_val;
+		else
+			*processed = raw64 * scale_val;
+		*processed += div_s64(raw64 * (s64)scale_val2 * scale,
+				      1000000000LL);
+		break;
+	case IIO_VAL_FRACTIONAL:
+		*processed = div_s64(raw64 * (s64)scale_val * scale,
+				     scale_val2);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int iio_convert_raw_to_processed(struct iio_channel *chan, int raw,
+	int *processed, unsigned int scale)
+{
+	int ret;
+
+	mutex_lock(&chan->indio_dev->info_exist_lock);
+	if (chan->indio_dev->info == NULL) {
+		ret = -ENODEV;
+		goto err_unlock;
+	}
+
+	ret = iio_convert_raw_to_processed_unlocked(chan, raw, processed,
+							scale);
+err_unlock:
+	mutex_unlock(&chan->indio_dev->info_exist_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(iio_convert_raw_to_processed);
+
+int iio_read_channel_processed(struct iio_channel *chan, int *val)
+{
+	int ret;
+
+	mutex_lock(&chan->indio_dev->info_exist_lock);
+	if (chan->indio_dev->info == NULL) {
+		ret = -ENODEV;
+		goto err_unlock;
+	}
+
+	if (iio_channel_has_info(chan->channel, IIO_CHAN_INFO_PROCESSED)) {
+		ret = iio_channel_read(chan, val, NULL,
+				       IIO_CHAN_INFO_PROCESSED);
+	} else {
+		ret = iio_channel_read(chan, val, NULL, IIO_CHAN_INFO_RAW);
+		if (ret < 0)
+			goto err_unlock;
+		ret = iio_convert_raw_to_processed_unlocked(chan, *val, val, 1);
+	}
+
+err_unlock:
+	mutex_unlock(&chan->indio_dev->info_exist_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(iio_read_channel_processed);
+
 int iio_read_channel_scale(struct iio_channel *chan, int *val, int *val2)
 {
 	int ret;
@@ -269,10 +372,7 @@ int iio_read_channel_scale(struct iio_channel *chan, int *val, int *val2)
 		goto err_unlock;
 	}
 
-	ret = chan->indio_dev->info->read_raw(chan->indio_dev,
-					      chan->channel,
-					      val, val2,
-					      IIO_CHAN_INFO_SCALE);
+	ret = iio_channel_read(chan, val, val2, IIO_CHAN_INFO_SCALE);
 err_unlock:
 	mutex_unlock(&chan->indio_dev->info_exist_lock);
 

commit b2b79ffa40d7ae40115631660ff8b6da3cf989b6
Author: Kim, Milo <Milo.Kim@ti.com>
Date:   Mon Sep 17 09:44:00 2012 +0100

    iio: inkern: add error case in iio_channel_get()
    
     The datasheet name is defined in the IIO driver.
     On the other hand, the adc_channel_label is configured in
     the platform side.
     If the datasheet name is not matched with any adc_channel_label,
     the iio_channel_get() should be returned as error for preventing
     invalid channel data access.
    
     This can be handled either way.
     (a) checking null data when using it : in the xxx_read_raw()
     or
     (b) error returns when the channel is requested : this patch
    
     The IIO consumer can't use the channel with invalid channel spec.
     Therefore case (b) is more reasonable.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 028c657f8da3..d539e1e297ba 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -136,12 +136,21 @@ struct iio_channel *iio_channel_get(const char *name, const char *channel_name)
 
 	channel->indio_dev = c->indio_dev;
 
-	if (c->map->adc_channel_label)
+	if (c->map->adc_channel_label) {
 		channel->channel =
 			iio_chan_spec_from_name(channel->indio_dev,
 						c->map->adc_channel_label);
 
+		if (channel->channel == NULL)
+			goto error_no_chan;
+	}
+
 	return channel;
+
+error_no_chan:
+	iio_device_put(c->indio_dev);
+	kfree(channel);
+	return ERR_PTR(-EINVAL);
 }
 EXPORT_SYMBOL_GPL(iio_channel_get);
 

commit 2cc412b513f70ce914a3554a34917f7585a16f04
Author: Kim, Milo <Milo.Kim@ti.com>
Date:   Fri Sep 14 02:24:00 2012 +0100

    iio: inkern: allocate zeroed memory
    
     Use kzalloc() rather than kmalloc() for initializing the iio_channel structure.
     This patch enables the iio_dev and iio_chan_spec are set to NULL.
     This may prevent the page fault problem because the pointer of iio_chan_spec
     is initialized as NULL.
    
     The iio_chan_spec is updated only in case that the IIO map has
     specific channel label.
     When the map has no ADC channel label, then the value of iio_chan_spec
     remains as invalid pointer.
     To prevent this problem, the pointer should be initialized as NULL.
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index a14e55dd8ddc..028c657f8da3 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -130,7 +130,7 @@ struct iio_channel *iio_channel_get(const char *name, const char *channel_name)
 	if (c == NULL)
 		return ERR_PTR(-ENODEV);
 
-	channel = kmalloc(sizeof(*channel), GFP_KERNEL);
+	channel = kzalloc(sizeof(*channel), GFP_KERNEL);
 	if (channel == NULL)
 		return ERR_PTR(-ENOMEM);
 

commit d965a8bc0cf56e0b2448b9aed6afe9066bc2616d
Author: Kim, Milo <Milo.Kim@ti.com>
Date:   Thu Aug 16 08:39:00 2012 +0100

    iio: use IIO_CHAN_INFO_RAW rather than 0
    
    (a) For better readability, replace 0 with IIO_CHAN_INFO_RAW.
    (b) Make same line-format as other apis()
        : iio_read_channel_scale() and iio_read_channel_offset()
    
    Signed-off-by: Milo(Woogyom) Kim <milo.kim@ti.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index b5afc2ff34fd..a14e55dd8ddc 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -239,8 +239,10 @@ int iio_read_channel_raw(struct iio_channel *chan, int *val)
 		goto err_unlock;
 	}
 
-	ret = chan->indio_dev->info->read_raw(chan->indio_dev, chan->channel,
-					      val, &val2, 0);
+	ret = chan->indio_dev->info->read_raw(chan->indio_dev,
+					      chan->channel,
+					      val, &val2,
+					      IIO_CHAN_INFO_RAW);
 err_unlock:
 	mutex_unlock(&chan->indio_dev->info_exist_lock);
 

commit e59b9afecf7ddf52d31d24e800b473f19c23cfe0
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Jul 11 07:34:00 2012 +0100

    iio: double unlock on error path
    
    We should be holding the mutex when we goto error_free_chans.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index e2aded04996b..b5afc2ff34fd 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -198,11 +198,12 @@ struct iio_channel *iio_channel_get_all(const char *name)
 		iio_device_get(chans[mapind].indio_dev);
 		mapind++;
 	}
-	mutex_unlock(&iio_map_list_lock);
 	if (mapind == 0) {
 		ret = -ENODEV;
 		goto error_free_chans;
 	}
+	mutex_unlock(&iio_map_list_lock);
+
 	return chans;
 
 error_free_chans:

commit 7b7627410e2c211f24787f61e6419e16d259aa13
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sat Jun 30 13:55:23 2012 +0100

    iio: Fix inkern remove incorrect put of device
    
    The device_get is after this point so on error we should not be
    removing it.
    
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 9a46ca61ef02..e2aded04996b 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -193,7 +193,6 @@ struct iio_channel *iio_channel_get_all(const char *name)
 						c->map->adc_channel_label);
 		if (chans[mapind].channel == NULL) {
 			ret = -EINVAL;
-			iio_device_put(chans[mapind].indio_dev);
 			goto error_free_chans;
 		}
 		iio_device_get(chans[mapind].indio_dev);

commit 314be14bb89369b2164125b0ec3b24d85b407b62
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Tue May 1 21:04:24 2012 +0100

    iio: Rename _st_ functions to loose the bit that meant the staging version.
    
    These were originally introduced when the plan was to have parallel
    IIO cores in and out of staging with a slow move between them.
    Now we have reached the point where the whole core has moved,
    they need clearing up!
    
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index d4760bd1e9b1..9a46ca61ef02 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -92,8 +92,7 @@ int iio_map_array_unregister(struct iio_dev *indio_dev,
 EXPORT_SYMBOL_GPL(iio_map_array_unregister);
 
 static const struct iio_chan_spec
-*iio_chan_spec_from_name(const struct iio_dev *indio_dev,
-			 const char *name)
+*iio_chan_spec_from_name(const struct iio_dev *indio_dev, const char *name)
 {
 	int i;
 	const struct iio_chan_spec *chan = NULL;
@@ -108,8 +107,7 @@ static const struct iio_chan_spec
 }
 
 
-struct iio_channel *iio_st_channel_get(const char *name,
-				       const char *channel_name)
+struct iio_channel *iio_channel_get(const char *name, const char *channel_name)
 {
 	struct iio_map_internal *c_i = NULL, *c = NULL;
 	struct iio_channel *channel;
@@ -145,16 +143,16 @@ struct iio_channel *iio_st_channel_get(const char *name,
 
 	return channel;
 }
-EXPORT_SYMBOL_GPL(iio_st_channel_get);
+EXPORT_SYMBOL_GPL(iio_channel_get);
 
-void iio_st_channel_release(struct iio_channel *channel)
+void iio_channel_release(struct iio_channel *channel)
 {
 	iio_device_put(channel->indio_dev);
 	kfree(channel);
 }
-EXPORT_SYMBOL_GPL(iio_st_channel_release);
+EXPORT_SYMBOL_GPL(iio_channel_release);
 
-struct iio_channel *iio_st_channel_get_all(const char *name)
+struct iio_channel *iio_channel_get_all(const char *name)
 {
 	struct iio_channel *chans;
 	struct iio_map_internal *c = NULL;
@@ -217,9 +215,9 @@ struct iio_channel *iio_st_channel_get_all(const char *name)
 
 	return ERR_PTR(ret);
 }
-EXPORT_SYMBOL_GPL(iio_st_channel_get_all);
+EXPORT_SYMBOL_GPL(iio_channel_get_all);
 
-void iio_st_channel_release_all(struct iio_channel *channels)
+void iio_channel_release_all(struct iio_channel *channels)
 {
 	struct iio_channel *chan = &channels[0];
 
@@ -229,9 +227,9 @@ void iio_st_channel_release_all(struct iio_channel *channels)
 	}
 	kfree(channels);
 }
-EXPORT_SYMBOL_GPL(iio_st_channel_release_all);
+EXPORT_SYMBOL_GPL(iio_channel_release_all);
 
-int iio_st_read_channel_raw(struct iio_channel *chan, int *val)
+int iio_read_channel_raw(struct iio_channel *chan, int *val)
 {
 	int val2, ret;
 
@@ -248,9 +246,9 @@ int iio_st_read_channel_raw(struct iio_channel *chan, int *val)
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(iio_st_read_channel_raw);
+EXPORT_SYMBOL_GPL(iio_read_channel_raw);
 
-int iio_st_read_channel_scale(struct iio_channel *chan, int *val, int *val2)
+int iio_read_channel_scale(struct iio_channel *chan, int *val, int *val2)
 {
 	int ret;
 
@@ -269,10 +267,9 @@ int iio_st_read_channel_scale(struct iio_channel *chan, int *val, int *val2)
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(iio_st_read_channel_scale);
+EXPORT_SYMBOL_GPL(iio_read_channel_scale);
 
-int iio_st_get_channel_type(struct iio_channel *chan,
-			    enum iio_chan_type *type)
+int iio_get_channel_type(struct iio_channel *chan, enum iio_chan_type *type)
 {
 	int ret = 0;
 	/* Need to verify underlying driver has not gone away */
@@ -289,4 +286,4 @@ int iio_st_get_channel_type(struct iio_channel *chan,
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(iio_st_get_channel_type);
+EXPORT_SYMBOL_GPL(iio_get_channel_type);

commit 1875ffd218ddafd78f0f8e78198c137cef97fd8a
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Jun 4 10:50:03 2012 +0200

    iio:inkern: Use iio_device_{get,put}
    
    Use iio_device_get and iio_device_put instead of open-coding it.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 922645893dc8..d4760bd1e9b1 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -125,7 +125,7 @@ struct iio_channel *iio_st_channel_get(const char *name,
 		     strcmp(channel_name, c_i->map->consumer_channel) != 0))
 			continue;
 		c = c_i;
-		get_device(&c->indio_dev->dev);
+		iio_device_get(c->indio_dev);
 		break;
 	}
 	mutex_unlock(&iio_map_list_lock);
@@ -149,7 +149,7 @@ EXPORT_SYMBOL_GPL(iio_st_channel_get);
 
 void iio_st_channel_release(struct iio_channel *channel)
 {
-	put_device(&channel->indio_dev->dev);
+	iio_device_put(channel->indio_dev);
 	kfree(channel);
 }
 EXPORT_SYMBOL_GPL(iio_st_channel_release);
@@ -195,10 +195,10 @@ struct iio_channel *iio_st_channel_get_all(const char *name)
 						c->map->adc_channel_label);
 		if (chans[mapind].channel == NULL) {
 			ret = -EINVAL;
-			put_device(&chans[mapind].indio_dev->dev);
+			iio_device_put(chans[mapind].indio_dev);
 			goto error_free_chans;
 		}
-		get_device(&chans[mapind].indio_dev->dev);
+		iio_device_get(chans[mapind].indio_dev);
 		mapind++;
 	}
 	mutex_unlock(&iio_map_list_lock);
@@ -210,8 +210,7 @@ struct iio_channel *iio_st_channel_get_all(const char *name)
 
 error_free_chans:
 	for (i = 0; i < nummaps; i++)
-		if (chans[i].indio_dev)
-			put_device(&chans[i].indio_dev->dev);
+		iio_device_put(chans[i].indio_dev);
 	kfree(chans);
 error_ret:
 	mutex_unlock(&iio_map_list_lock);
@@ -225,7 +224,7 @@ void iio_st_channel_release_all(struct iio_channel *channels)
 	struct iio_channel *chan = &channels[0];
 
 	while (chan->indio_dev) {
-		put_device(&chan->indio_dev->dev);
+		iio_device_put(chan->indio_dev);
 		chan++;
 	}
 	kfree(channels);

commit d210267741fb2a8b6d741d9040703683a39087f4
Merge: 69964ea4c7b6 5bb196ad29c5
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed May 2 11:48:07 2012 -0700

    Merge 3.4-rc5 into staging-next
    
    This resolves the conflict in:
            drivers/staging/vt6656/ioctl.c
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit a980e046098b0a40eaff5e4e7fcde6cf035b7c06
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Wed Apr 25 15:54:59 2012 +0100

    IIO: Move the core files to drivers/iio
    
    Take the core support + the kfifo buffer implentation out of
    staging.  Whilst we are far from done in improving this subsystem
    it is now at a stage where the userspae interfaces (provided by
    the core) can be considered stable.
    
    Drivers will follow over a longer time scale.
    
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
new file mode 100644
index 000000000000..22ddf62b107c
--- /dev/null
+++ b/drivers/iio/inkern.c
@@ -0,0 +1,292 @@
+/* The industrial I/O core in kernel channel mapping
+ *
+ * Copyright (c) 2011 Jonathan Cameron
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+#include <linux/err.h>
+#include <linux/export.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+
+#include <linux/iio/iio.h>
+#include "iio_core.h"
+#include <linux/iio/machine.h>
+#include <linux/iio/driver.h>
+#include <linux/iio/consumer.h>
+
+struct iio_map_internal {
+	struct iio_dev *indio_dev;
+	struct iio_map *map;
+	struct list_head l;
+};
+
+static LIST_HEAD(iio_map_list);
+static DEFINE_MUTEX(iio_map_list_lock);
+
+int iio_map_array_register(struct iio_dev *indio_dev, struct iio_map *maps)
+{
+	int i = 0, ret = 0;
+	struct iio_map_internal *mapi;
+
+	if (maps == NULL)
+		return 0;
+
+	mutex_lock(&iio_map_list_lock);
+	while (maps[i].consumer_dev_name != NULL) {
+		mapi = kzalloc(sizeof(*mapi), GFP_KERNEL);
+		if (mapi == NULL) {
+			ret = -ENOMEM;
+			goto error_ret;
+		}
+		mapi->map = &maps[i];
+		mapi->indio_dev = indio_dev;
+		list_add(&mapi->l, &iio_map_list);
+		i++;
+	}
+error_ret:
+	mutex_unlock(&iio_map_list_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(iio_map_array_register);
+
+
+/* Assumes the exact same array (e.g. memory locations)
+ * used at unregistration as used at registration rather than
+ * more complex checking of contents.
+ */
+int iio_map_array_unregister(struct iio_dev *indio_dev,
+			     struct iio_map *maps)
+{
+	int i = 0, ret = 0;
+	bool found_it;
+	struct iio_map_internal *mapi;
+
+	if (maps == NULL)
+		return 0;
+
+	mutex_lock(&iio_map_list_lock);
+	while (maps[i].consumer_dev_name != NULL) {
+		found_it = false;
+		list_for_each_entry(mapi, &iio_map_list, l)
+			if (&maps[i] == mapi->map) {
+				list_del(&mapi->l);
+				kfree(mapi);
+				found_it = true;
+				break;
+			}
+		if (found_it == false) {
+			ret = -ENODEV;
+			goto error_ret;
+		}
+	}
+error_ret:
+	mutex_unlock(&iio_map_list_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(iio_map_array_unregister);
+
+static const struct iio_chan_spec
+*iio_chan_spec_from_name(const struct iio_dev *indio_dev,
+			 const char *name)
+{
+	int i;
+	const struct iio_chan_spec *chan = NULL;
+
+	for (i = 0; i < indio_dev->num_channels; i++)
+		if (indio_dev->channels[i].datasheet_name &&
+		    strcmp(name, indio_dev->channels[i].datasheet_name) == 0) {
+			chan = &indio_dev->channels[i];
+			break;
+		}
+	return chan;
+}
+
+
+struct iio_channel *iio_st_channel_get(const char *name,
+				       const char *channel_name)
+{
+	struct iio_map_internal *c_i = NULL, *c = NULL;
+	struct iio_channel *channel;
+
+	if (name == NULL && channel_name == NULL)
+		return ERR_PTR(-ENODEV);
+
+	/* first find matching entry the channel map */
+	mutex_lock(&iio_map_list_lock);
+	list_for_each_entry(c_i, &iio_map_list, l) {
+		if ((name && strcmp(name, c_i->map->consumer_dev_name) != 0) ||
+		    (channel_name &&
+		     strcmp(channel_name, c_i->map->consumer_channel) != 0))
+			continue;
+		c = c_i;
+		get_device(&c->indio_dev->dev);
+		break;
+	}
+	mutex_unlock(&iio_map_list_lock);
+	if (c == NULL)
+		return ERR_PTR(-ENODEV);
+
+	channel = kmalloc(sizeof(*channel), GFP_KERNEL);
+	if (channel == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	channel->indio_dev = c->indio_dev;
+
+	if (c->map->adc_channel_label)
+		channel->channel =
+			iio_chan_spec_from_name(channel->indio_dev,
+						c->map->adc_channel_label);
+
+	return channel;
+}
+EXPORT_SYMBOL_GPL(iio_st_channel_get);
+
+void iio_st_channel_release(struct iio_channel *channel)
+{
+	put_device(&channel->indio_dev->dev);
+	kfree(channel);
+}
+EXPORT_SYMBOL_GPL(iio_st_channel_release);
+
+struct iio_channel *iio_st_channel_get_all(const char *name)
+{
+	struct iio_channel *chans;
+	struct iio_map_internal *c = NULL;
+	int nummaps = 0;
+	int mapind = 0;
+	int i, ret;
+
+	if (name == NULL)
+		return ERR_PTR(-EINVAL);
+
+	mutex_lock(&iio_map_list_lock);
+	/* first count the matching maps */
+	list_for_each_entry(c, &iio_map_list, l)
+		if (name && strcmp(name, c->map->consumer_dev_name) != 0)
+			continue;
+		else
+			nummaps++;
+
+	if (nummaps == 0) {
+		ret = -ENODEV;
+		goto error_ret;
+	}
+
+	/* NULL terminated array to save passing size */
+	chans = kzalloc(sizeof(*chans)*(nummaps + 1), GFP_KERNEL);
+	if (chans == NULL) {
+		ret = -ENOMEM;
+		goto error_ret;
+	}
+
+	/* for each map fill in the chans element */
+	list_for_each_entry(c, &iio_map_list, l) {
+		if (name && strcmp(name, c->map->consumer_dev_name) != 0)
+			continue;
+		chans[mapind].indio_dev = c->indio_dev;
+		chans[mapind].channel =
+			iio_chan_spec_from_name(chans[mapind].indio_dev,
+						c->map->adc_channel_label);
+		if (chans[mapind].channel == NULL) {
+			ret = -EINVAL;
+			put_device(&chans[mapind].indio_dev->dev);
+			goto error_free_chans;
+		}
+		get_device(&chans[mapind].indio_dev->dev);
+		mapind++;
+	}
+	mutex_unlock(&iio_map_list_lock);
+	if (mapind == 0) {
+		ret = -ENODEV;
+		goto error_free_chans;
+	}
+	return chans;
+
+error_free_chans:
+	for (i = 0; i < nummaps; i++)
+		if (chans[i].indio_dev)
+			put_device(&chans[i].indio_dev->dev);
+	kfree(chans);
+error_ret:
+	mutex_unlock(&iio_map_list_lock);
+
+	return ERR_PTR(ret);
+}
+EXPORT_SYMBOL_GPL(iio_st_channel_get_all);
+
+void iio_st_channel_release_all(struct iio_channel *channels)
+{
+	struct iio_channel *chan = &channels[0];
+
+	while (chan->indio_dev) {
+		put_device(&chan->indio_dev->dev);
+		chan++;
+	}
+	kfree(channels);
+}
+EXPORT_SYMBOL_GPL(iio_st_channel_release_all);
+
+int iio_st_read_channel_raw(struct iio_channel *chan, int *val)
+{
+	int val2, ret;
+
+	mutex_lock(&chan->indio_dev->info_exist_lock);
+	if (chan->indio_dev->info == NULL) {
+		ret = -ENODEV;
+		goto err_unlock;
+	}
+
+	ret = chan->indio_dev->info->read_raw(chan->indio_dev, chan->channel,
+					      val, &val2, 0);
+err_unlock:
+	mutex_unlock(&chan->indio_dev->info_exist_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(iio_st_read_channel_raw);
+
+int iio_st_read_channel_scale(struct iio_channel *chan, int *val, int *val2)
+{
+	int ret;
+
+	mutex_lock(&chan->indio_dev->info_exist_lock);
+	if (chan->indio_dev->info == NULL) {
+		ret = -ENODEV;
+		goto err_unlock;
+	}
+
+	ret = chan->indio_dev->info->read_raw(chan->indio_dev,
+					      chan->channel,
+					      val, val2,
+					      IIO_CHAN_INFO_SCALE);
+err_unlock:
+	mutex_unlock(&chan->indio_dev->info_exist_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(iio_st_read_channel_scale);
+
+int iio_st_get_channel_type(struct iio_channel *chan,
+			    enum iio_chan_type *type)
+{
+	int ret = 0;
+	/* Need to verify underlying driver has not gone away */
+
+	mutex_lock(&chan->indio_dev->info_exist_lock);
+	if (chan->indio_dev->info == NULL) {
+		ret = -ENODEV;
+		goto err_unlock;
+	}
+
+	*type = chan->channel->type;
+err_unlock:
+	mutex_unlock(&chan->indio_dev->info_exist_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(iio_st_get_channel_type);
