commit 6562793b55c58b6b1dcb9cd581c7905afc25e89f
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Fri Mar 27 15:34:40 2020 -0700

    iio: cros_ec: Expose hwfifo_timeout
    
    Expose EC minimal interrupt period through buffer/hwfifo_timeout:
    - Maximal timeout is limited to 65s.
    - When timeout for all sensors is set to 0, EC will not send events,
      even if the sensor sampling rate is greater than 0.
    
    Rename frequency to sampling_frequency to match IIO ABI.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>

diff --git a/drivers/iio/light/cros_ec_light_prox.c b/drivers/iio/light/cros_ec_light_prox.c
index e10b35de4c2f..2198b50909ed 100644
--- a/drivers/iio/light/cros_ec_light_prox.c
+++ b/drivers/iio/light/cros_ec_light_prox.c
@@ -183,6 +183,8 @@ static int cros_ec_light_prox_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
+	iio_buffer_set_attrs(indio_dev->buffer, cros_ec_sensor_fifo_attributes);
+
 	indio_dev->info = &cros_ec_light_prox_info;
 	state = iio_priv(indio_dev);
 	state->core.type = state->core.resp->info.type;
@@ -191,8 +193,7 @@ static int cros_ec_light_prox_probe(struct platform_device *pdev)
 
 	/* Common part */
 	channel->info_mask_shared_by_all =
-		BIT(IIO_CHAN_INFO_SAMP_FREQ) |
-		BIT(IIO_CHAN_INFO_FREQUENCY);
+		BIT(IIO_CHAN_INFO_SAMP_FREQ);
 	channel->info_mask_shared_by_all_available =
 		BIT(IIO_CHAN_INFO_SAMP_FREQ);
 	channel->scan_type.realbits = CROS_EC_SENSOR_BITS;

commit 2861be4ca9125ee1b7c49895948ca4236449a7fe
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Fri Mar 27 15:34:39 2020 -0700

    iio: cros_ec: Remove pm function
    
    Since cros_ec_sensorhub is shutting down the FIFO when the device
    suspends, no need to slow down the EC sampling period rate.
    
    It was necesseary to do that before command CMD_FIFO_INT_ENABLE was
    introduced, but now all supported chromebooks have it.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>

diff --git a/drivers/iio/light/cros_ec_light_prox.c b/drivers/iio/light/cros_ec_light_prox.c
index 03c951ff4a3c..e10b35de4c2f 100644
--- a/drivers/iio/light/cros_ec_light_prox.c
+++ b/drivers/iio/light/cros_ec_light_prox.c
@@ -255,7 +255,6 @@ MODULE_DEVICE_TABLE(platform, cros_ec_light_prox_ids);
 static struct platform_driver cros_ec_light_prox_platform_driver = {
 	.driver = {
 		.name	= "cros-ec-light-prox",
-		.pm	= &cros_ec_sensors_pm_ops,
 	},
 	.probe		= cros_ec_light_prox_probe,
 	.id_table	= cros_ec_light_prox_ids,

commit aa984f1ba4a477c8ea39d2fa975a4f8de8a126e9
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Fri Mar 27 15:34:38 2020 -0700

    iio: cros_ec: Register to cros_ec_sensorhub when EC supports FIFO
    
    When EC supports FIFO, each IIO device registers a callback, to put
    samples in the buffer when they arrives from the FIFO.
    
    When no FIFO, the user space app needs to call trigger_new, or better
    register a high precision timer.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>

diff --git a/drivers/iio/light/cros_ec_light_prox.c b/drivers/iio/light/cros_ec_light_prox.c
index 7a838e2956f4..03c951ff4a3c 100644
--- a/drivers/iio/light/cros_ec_light_prox.c
+++ b/drivers/iio/light/cros_ec_light_prox.c
@@ -177,7 +177,9 @@ static int cros_ec_light_prox_probe(struct platform_device *pdev)
 	if (!indio_dev)
 		return -ENOMEM;
 
-	ret = cros_ec_sensors_core_init(pdev, indio_dev, true);
+	ret = cros_ec_sensors_core_init(pdev, indio_dev, true,
+					cros_ec_sensors_capture,
+					cros_ec_sensors_push_data);
 	if (ret)
 		return ret;
 
@@ -236,11 +238,6 @@ static int cros_ec_light_prox_probe(struct platform_device *pdev)
 
 	state->core.read_ec_sensors_data = cros_ec_sensors_read_cmd;
 
-	ret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,
-					      cros_ec_sensors_capture, NULL);
-	if (ret)
-		return ret;
-
 	return devm_iio_device_register(dev, indio_dev);
 }
 

commit 11f1eabee0ba0aafe023ad92d1e3c29d0a96683e
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Tue Dec 3 15:50:18 2019 +0100

    cros_ec: treewide: Remove 'include/linux/mfd/cros_ec.h'
    
    This header file now only includes the cros_ec_dev struct, however, is the
    'include/linux/platform_data/cros_ec_proto.h' who contains the definition of
    all the Chrome OS EC related structs. There is no reason to have a
    separate include for this struct so move to the place where other
    structs are defined. That way, we can remove the include itself, but also
    simplify the common pattern
    
        #include <linux/mfd/cros_ec.h>
        #include <linux/platform_data/cros_ec_proto.h>
    
    for a single include
    
        #include <linux/platform_data/cros_ec_proto.h>
    
    The changes to remove the cros_ec.h include were generated with the
    following shell script:
    
        git grep -l "<linux/mfd/cros_ec.h>" | xargs sed -i '/<linux\/mfd\/cros_ec.h>/d'
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Acked-by: Sebastian Reichel <sre@kernel.org>
    Acked-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>

diff --git a/drivers/iio/light/cros_ec_light_prox.c b/drivers/iio/light/cros_ec_light_prox.c
index d85a391e50c5..7a838e2956f4 100644
--- a/drivers/iio/light/cros_ec_light_prox.c
+++ b/drivers/iio/light/cros_ec_light_prox.c
@@ -14,7 +14,6 @@
 #include <linux/iio/triggered_buffer.h>
 #include <linux/iio/trigger_consumer.h>
 #include <linux/kernel.h>
-#include <linux/mfd/cros_ec.h>
 #include <linux/module.h>
 #include <linux/platform_data/cros_ec_commands.h>
 #include <linux/platform_data/cros_ec_proto.h>

commit d60ac88a62df71cb12b2d60d2dae5658fb4eab43
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Tue Nov 19 13:45:45 2019 +0100

    mfd / platform / iio: cros_ec: Register sensor through sensorhub
    
    Remove the duplicated code in MFD, since MFD just registers cros-ec-sensorhub
    if at least one sensor is present.
    
    Change IIO cros-ec driver to get the pointer to the cros-ec-dev through
    cros-ec-sensorhub.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>

diff --git a/drivers/iio/light/cros_ec_light_prox.c b/drivers/iio/light/cros_ec_light_prox.c
index c5263b563fc1..d85a391e50c5 100644
--- a/drivers/iio/light/cros_ec_light_prox.c
+++ b/drivers/iio/light/cros_ec_light_prox.c
@@ -169,17 +169,11 @@ static const struct iio_info cros_ec_light_prox_info = {
 static int cros_ec_light_prox_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
-	struct cros_ec_dev *ec_dev = dev_get_drvdata(dev->parent);
 	struct iio_dev *indio_dev;
 	struct cros_ec_light_prox_state *state;
 	struct iio_chan_spec *channel;
 	int ret;
 
-	if (!ec_dev || !ec_dev->ec_dev) {
-		dev_warn(dev, "No CROS EC device found.\n");
-		return -EINVAL;
-	}
-
 	indio_dev = devm_iio_device_alloc(dev, sizeof(*state));
 	if (!indio_dev)
 		return -ENOMEM;

commit 32b90daf5cafdda62b1ce62d0b7445fa9107babf
Merge: c6cfaf4f86d9 4c1fde5077dc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 19 14:14:28 2019 -0700

    Merge tag 'tag-chrome-platform-for-v5.4' of git://git.kernel.org/pub/scm/linux/kernel/git/chrome-platform/linux
    
    Pull chrome platform updates from Benson Leung:
     "CrOS EC / MFD Migration:
        - Move cros_ec core driver from mfd into chrome platform.
    
      Wilco EC:
        - Add batt_ppid_info command to Wilco telemetry driver.
    
      CrOS EC:
        - cros_ec_rpmsg : Add support to inform EC of suspend/resume status
        - cros_ec_rpmsg : Fix race condition on probe failed
        - cros_ec_chardev : Add a poll handler to receive MKBP events
    
      Misc:
        - bugfixes in cros_usbpd_logger and cros_ec_ishtp"
    
    * tag 'tag-chrome-platform-for-v5.4' of git://git.kernel.org/pub/scm/linux/kernel/git/chrome-platform/linux:
      platform/chrome: cros_usbpd_logger: null check create_singlethread_workqueue
      platform/chrome: cros_ec_chardev: Add a poll handler to receive MKBP events
      platform/chrome: cros_ec_rpmsg: Fix race with host command when probe failed
      platform/chrome: chromeos_tbmc: Report wake events
      mfd: cros_ec: Use mfd_add_hotplug_devices() helper
      mfd: cros_ec: Add convenience struct to define autodetectable CrOS EC subdevices
      mfd: cros_ec: Add convenience struct to define dedicated CrOS EC MCUs
      mfd: cros_ec: Use kzalloc and cros_ec_cmd_xfer_status helper
      mfd / platform: cros_ec: Reorganize platform and mfd includes
      mfd / platform: cros_ec: Rename config to a better name
      mfd: cros_ec: Switch to use the new cros-ec-chardev driver
      mfd / platform: cros_ec: Miscellaneous character device to talk with the EC
      mfd / platform: cros_ec: Move cros-ec core driver out from MFD
      mfd / platform: cros_ec: Handle chained ECs as platform devices
      platform/chrome: cros_ec_rpmsg: Add host command AP sleep state support
      platform/chrome: chromeos_laptop: drop checks of NULL-safe functions
      platform/chrome: wilco_ec: Add batt_ppid_info command to telemetry driver

commit 840d9f131f65b021e0a73f3371f3194897dba6ad
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Mon Sep 2 11:53:05 2019 +0200

    mfd / platform: cros_ec: Reorganize platform and mfd includes
    
    There is a bit of mess between cros-ec mfd includes and platform
    includes. For example, we have a linux/mfd/cros_ec.h include that
    exports the interface implemented in platform/chrome/cros_ec_proto.c. Or
    we have a linux/mfd/cros_ec_commands.h file that is non related to the
    multifunction device (in the sense that is not exporting any function of
    the mfd device). This causes crossed includes between mfd and
    platform/chrome subsystems and makes the code difficult to read, apart
    from creating 'curious' situations where a platform/chrome driver includes
    a linux/mfd/cros_ec.h file just to get the exported functions that are
    implemented in another platform/chrome driver.
    
    In order to have a better separation on what the cros-ec multifunction
    driver does and what the cros-ec core provides move and rework the
    affected includes doing:
    
     - Move cros_ec_commands.h to include/linux/platform_data/cros_ec_commands.h
     - Get rid of the parts that are implemented in the platform/chrome/cros_ec_proto.c
       driver from include/linux/mfd/cros_ec.h to a new file
       include/linux/platform_data/cros_ec_proto.h
     - Update all the drivers with the new includes, so
       - Drivers that only need to know about the protocol include
         - linux/platform_data/cros_ec_proto.h
         - linux/platform_data/cros_ec_commands.h
       - Drivers that need to know about the cros-ec mfd device also include
         - linux/mfd/cros_ec.h
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Acked-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Acked-by: Chanwoo Choi <cw00.choi@samsung.com>
    Reviewed-by: Gwendal Grignou <gwendal@chromium.org>
    Tested-by: Gwendal Grignou <gwendal@chromium.org>
    Series changes: 3
    - Fix dereferencing pointer to incomplete type 'struct cros_ec_dev' (lkp)
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/iio/light/cros_ec_light_prox.c b/drivers/iio/light/cros_ec_light_prox.c
index 308ee6ff2e22..437e0eae9178 100644
--- a/drivers/iio/light/cros_ec_light_prox.c
+++ b/drivers/iio/light/cros_ec_light_prox.c
@@ -15,8 +15,9 @@
 #include <linux/iio/trigger_consumer.h>
 #include <linux/kernel.h>
 #include <linux/mfd/cros_ec.h>
-#include <linux/mfd/cros_ec_commands.h>
 #include <linux/module.h>
+#include <linux/platform_data/cros_ec_commands.h>
+#include <linux/platform_data/cros_ec_proto.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 

commit ae7b02ad2f32d39d1434655f346c04a16c1aa703
Author: Fabien Lahoudere <fabien.lahoudere@collabora.com>
Date:   Tue Jul 16 11:11:06 2019 +0200

    iio: common: cros_ec_sensors: Expose cros_ec_sensors frequency range via iio sysfs
    
    Embedded controller return minimum and maximum frequencies, unfortunately
    we have no way to know the step for all available frequencies.
    Even if not complete, we can return a list of known values using the
    standard read_avail callback (IIO_CHAN_INFO_SAMP_FREQ) to provide them to
    userland.
    
    Now cros_ec_* sensors provides frequencies values in sysfs like this:
    "0 min max". 0 is always true to disable the sensor.
    
    Default frequencies are provided for earlier protocol.
    
    Signed-off-by: Nick Vaccaro <nvaccaro@chromium.org>
    Signed-off-by: Fabien Lahoudere <fabien.lahoudere@collabora.com>
    [rebased on top of iio/testing and solved conflicts]
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/light/cros_ec_light_prox.c b/drivers/iio/light/cros_ec_light_prox.c
index 965f346d7d64..44313a009928 100644
--- a/drivers/iio/light/cros_ec_light_prox.c
+++ b/drivers/iio/light/cros_ec_light_prox.c
@@ -162,6 +162,7 @@ static int cros_ec_light_prox_write(struct iio_dev *indio_dev,
 static const struct iio_info cros_ec_light_prox_info = {
 	.read_raw = &cros_ec_light_prox_read,
 	.write_raw = &cros_ec_light_prox_write,
+	.read_avail = &cros_ec_sensors_core_read_avail,
 };
 
 static int cros_ec_light_prox_probe(struct platform_device *pdev)
@@ -196,6 +197,8 @@ static int cros_ec_light_prox_probe(struct platform_device *pdev)
 	channel->info_mask_shared_by_all =
 		BIT(IIO_CHAN_INFO_SAMP_FREQ) |
 		BIT(IIO_CHAN_INFO_FREQUENCY);
+	channel->info_mask_shared_by_all_available =
+		BIT(IIO_CHAN_INFO_SAMP_FREQ);
 	channel->scan_type.realbits = CROS_EC_SENSOR_BITS;
 	channel->scan_type.storagebits = CROS_EC_SENSOR_BITS;
 	channel->scan_type.shift = 0;

commit f53199c0bc62657f7bc253b5dfc9f3d81ed2ca28
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Thu Jul 18 15:22:37 2019 -0700

    iio: cros_ec: Remove replacing error code with -EIO
    
    Due to an API misread, error code can be different for -EIO when reading
    a sysfs entry. Return the error reported by the cros_ec stack.
    
    Check the proper error message (protocol error, not supported) is
    reported when there is an error returned by the EC stack.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/light/cros_ec_light_prox.c b/drivers/iio/light/cros_ec_light_prox.c
index b81746a99f1f..965f346d7d64 100644
--- a/drivers/iio/light/cros_ec_light_prox.c
+++ b/drivers/iio/light/cros_ec_light_prox.c
@@ -42,7 +42,7 @@ static int cros_ec_light_prox_read(struct iio_dev *indio_dev,
 	struct cros_ec_light_prox_state *st = iio_priv(indio_dev);
 	u16 data = 0;
 	s64 val64;
-	int ret = IIO_VAL_INT;
+	int ret;
 	int idx = chan->scan_index;
 
 	mutex_lock(&st->core.cmd_lock);
@@ -50,23 +50,22 @@ static int cros_ec_light_prox_read(struct iio_dev *indio_dev,
 	switch (mask) {
 	case IIO_CHAN_INFO_RAW:
 		if (chan->type == IIO_PROXIMITY) {
-			if (cros_ec_sensors_read_cmd(indio_dev, 1 << idx,
-						     (s16 *)&data) < 0) {
-				ret = -EIO;
+			ret = cros_ec_sensors_read_cmd(indio_dev, 1 << idx,
+						     (s16 *)&data);
+			if (ret)
 				break;
-			}
 			*val = data;
+			ret = IIO_VAL_INT;
 		} else {
 			ret = -EINVAL;
 		}
 		break;
 	case IIO_CHAN_INFO_PROCESSED:
 		if (chan->type == IIO_LIGHT) {
-			if (cros_ec_sensors_read_cmd(indio_dev, 1 << idx,
-						     (s16 *)&data) < 0) {
-				ret = -EIO;
+			ret = cros_ec_sensors_read_cmd(indio_dev, 1 << idx,
+						     (s16 *)&data);
+			if (ret)
 				break;
-			}
 			/*
 			 * The data coming from the light sensor is
 			 * pre-processed and represents the ambient light
@@ -82,16 +81,16 @@ static int cros_ec_light_prox_read(struct iio_dev *indio_dev,
 		st->core.param.cmd = MOTIONSENSE_CMD_SENSOR_OFFSET;
 		st->core.param.sensor_offset.flags = 0;
 
-		if (cros_ec_motion_send_host_cmd(&st->core, 0)) {
-			ret = -EIO;
+		ret = cros_ec_motion_send_host_cmd(&st->core, 0);
+		if (ret)
 			break;
-		}
 
 		/* Save values */
 		st->core.calib[0].offset =
 			st->core.resp->sensor_offset.offset[0];
 
 		*val = st->core.calib[idx].offset;
+		ret = IIO_VAL_INT;
 		break;
 	case IIO_CHAN_INFO_CALIBSCALE:
 		/*
@@ -102,10 +101,9 @@ static int cros_ec_light_prox_read(struct iio_dev *indio_dev,
 		st->core.param.cmd = MOTIONSENSE_CMD_SENSOR_RANGE;
 		st->core.param.sensor_range.data = EC_MOTION_SENSE_NO_VALUE;
 
-		if (cros_ec_motion_send_host_cmd(&st->core, 0)) {
-			ret = -EIO;
+		ret = cros_ec_motion_send_host_cmd(&st->core, 0);
+		if (ret)
 			break;
-		}
 
 		val64 = st->core.resp->sensor_range.ret;
 		*val = val64 >> 16;
@@ -128,7 +126,7 @@ static int cros_ec_light_prox_write(struct iio_dev *indio_dev,
 			       int val, int val2, long mask)
 {
 	struct cros_ec_light_prox_state *st = iio_priv(indio_dev);
-	int ret = 0;
+	int ret;
 	int idx = chan->scan_index;
 
 	mutex_lock(&st->core.cmd_lock);
@@ -143,14 +141,12 @@ static int cros_ec_light_prox_write(struct iio_dev *indio_dev,
 			st->core.calib[0].offset;
 		st->core.param.sensor_offset.temp =
 					EC_MOTION_SENSE_INVALID_CALIB_TEMP;
-		if (cros_ec_motion_send_host_cmd(&st->core, 0))
-			ret = -EIO;
+		ret = cros_ec_motion_send_host_cmd(&st->core, 0);
 		break;
 	case IIO_CHAN_INFO_CALIBSCALE:
 		st->core.param.cmd = MOTIONSENSE_CMD_SENSOR_RANGE;
 		st->core.param.sensor_range.data = (val << 16) | (val2 / 100);
-		if (cros_ec_motion_send_host_cmd(&st->core, 0))
-			ret = -EIO;
+		ret = cros_ec_motion_send_host_cmd(&st->core, 0);
 		break;
 	default:
 		ret = cros_ec_sensors_core_write(&st->core, chan, val, val2,

commit ed1f2e85da79274f3dc4092953f1359eb732f0c6
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Thu Jul 18 16:28:24 2019 -0700

    iio: cros_ec: Add calibscale for 3d MEMS
    
    Add calibration scale support to accel, gyro and magnetometer.
    
    Check on eve with current firmware, check reading calibscale returns 1.0,
    check with newer firmware values are applied.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/light/cros_ec_light_prox.c b/drivers/iio/light/cros_ec_light_prox.c
index 308ee6ff2e22..b81746a99f1f 100644
--- a/drivers/iio/light/cros_ec_light_prox.c
+++ b/drivers/iio/light/cros_ec_light_prox.c
@@ -88,9 +88,10 @@ static int cros_ec_light_prox_read(struct iio_dev *indio_dev,
 		}
 
 		/* Save values */
-		st->core.calib[0] = st->core.resp->sensor_offset.offset[0];
+		st->core.calib[0].offset =
+			st->core.resp->sensor_offset.offset[0];
 
-		*val = st->core.calib[idx];
+		*val = st->core.calib[idx].offset;
 		break;
 	case IIO_CHAN_INFO_CALIBSCALE:
 		/*
@@ -134,11 +135,12 @@ static int cros_ec_light_prox_write(struct iio_dev *indio_dev,
 
 	switch (mask) {
 	case IIO_CHAN_INFO_CALIBBIAS:
-		st->core.calib[idx] = val;
+		st->core.calib[idx].offset = val;
 		/* Send to EC for each axis, even if not complete */
 		st->core.param.cmd = MOTIONSENSE_CMD_SENSOR_OFFSET;
 		st->core.param.sensor_offset.flags = MOTION_SENSE_SET_OFFSET;
-		st->core.param.sensor_offset.offset[0] = st->core.calib[0];
+		st->core.param.sensor_offset.offset[0] =
+			st->core.calib[0].offset;
 		st->core.param.sensor_offset.temp =
 					EC_MOTION_SENSE_INVALID_CALIB_TEMP;
 		if (cros_ec_motion_send_host_cmd(&st->core, 0))
@@ -205,8 +207,6 @@ static int cros_ec_light_prox_probe(struct platform_device *pdev)
 	channel->ext_info = cros_ec_sensors_ext_info;
 	channel->scan_type.sign = 'u';
 
-	state->core.calib[0] = 0;
-
 	/* Sensor specific */
 	switch (state->core.type) {
 	case MOTIONSENSE_TYPE_LIGHT:

commit 37aa055c417211913240c36aa394edb6266d5ca1
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Wed Mar 13 12:41:20 2019 +0100

    iio: cros_ec: Switch to SPDX identifier.
    
    Adopt the SPDX license identifier headers to ease license compliance
    management. Also fix MODULE_LICENSE for cros_ec_accel_legacy to match
    the SPDX and boiler plate license.
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/light/cros_ec_light_prox.c b/drivers/iio/light/cros_ec_light_prox.c
index 7bb3078217b3..308ee6ff2e22 100644
--- a/drivers/iio/light/cros_ec_light_prox.c
+++ b/drivers/iio/light/cros_ec_light_prox.c
@@ -1,16 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * cros_ec_light_prox - Driver for light and prox sensors behing CrosEC.
  *
  * Copyright (C) 2017 Google, Inc
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include <linux/device.h>

commit b921d928a31c78b083a34140204f2ad183bcc083
Author: Guenter Roeck <groeck@chromium.org>
Date:   Wed Mar 13 12:40:32 2019 +0100

    iio: cros_ec: Drop unnecessary include files
    
    The cros_ec sensors drivers do not call any sysfs functions
    or use any sysfs defines, and thus do not need to include
    linux/sysfs.h. Also, some cros_ec drivers include linux/delay.h
    and is not used.
    
    Signed-off-by: Guenter Roeck <groeck@chromium.org>
    [remove linux/delay.h]
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/light/cros_ec_light_prox.c b/drivers/iio/light/cros_ec_light_prox.c
index fd1609e975ab..7bb3078217b3 100644
--- a/drivers/iio/light/cros_ec_light_prox.c
+++ b/drivers/iio/light/cros_ec_light_prox.c
@@ -13,7 +13,6 @@
  * GNU General Public License for more details.
  */
 
-#include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/iio/buffer.h>
 #include <linux/iio/common/cros_ec_sensors_core.h>
@@ -28,7 +27,6 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
-#include <linux/sysfs.h>
 
 /*
  * We only represent one entry for light or proximity. EC is merging different

commit 5a0b8cb46624cc17fda676d6ae44fb72504f0ad9
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Tue Mar 13 14:23:28 2018 -0700

    iio: cros_ec: Move cros_ec_sensors_core.h in /include
    
    Similar to other common iio frameworks, move cros_ec_sensors_core.h from
    drivers/iio/common/cros_ec_sensors/ to include/linux/iio/common.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/light/cros_ec_light_prox.c b/drivers/iio/light/cros_ec_light_prox.c
index 8e8a0e7f78d1..fd1609e975ab 100644
--- a/drivers/iio/light/cros_ec_light_prox.c
+++ b/drivers/iio/light/cros_ec_light_prox.c
@@ -16,6 +16,7 @@
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/iio/buffer.h>
+#include <linux/iio/common/cros_ec_sensors_core.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/kfifo_buf.h>
 #include <linux/iio/trigger.h>
@@ -29,8 +30,6 @@
 #include <linux/slab.h>
 #include <linux/sysfs.h>
 
-#include "../common/cros_ec_sensors/cros_ec_sensors_core.h"
-
 /*
  * We only represent one entry for light or proximity. EC is merging different
  * light sensors to return the what the eye would see. For proximity, we

commit 0dad1eceeb9c7497e7e2a592900ddac79b128c56
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Wed Feb 21 16:11:09 2018 +0100

    iio: cros_ec: Relax sampling frequency before suspending
    
    If an application set a tight sampling frequency, given the interrupt
    use is a wakeup source, suspend will not happen: the kernel will receive
    a wake up interrupt and will cancel the suspend process.
    
    Given cros_ec sensors type is non wake up, this patch adds prepare and
    complete callbacks to set 1s sampling period just before suspend. This
    ensures the sensor hub will not be a source of interrupt during the
    suspend process.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/light/cros_ec_light_prox.c b/drivers/iio/light/cros_ec_light_prox.c
index acfad4aeb27a..8e8a0e7f78d1 100644
--- a/drivers/iio/light/cros_ec_light_prox.c
+++ b/drivers/iio/light/cros_ec_light_prox.c
@@ -276,6 +276,7 @@ MODULE_DEVICE_TABLE(platform, cros_ec_light_prox_ids);
 static struct platform_driver cros_ec_light_prox_platform_driver = {
 	.driver = {
 		.name	= "cros-ec-light-prox",
+		.pm	= &cros_ec_sensors_pm_ops,
 	},
 	.probe		= cros_ec_light_prox_probe,
 	.id_table	= cros_ec_light_prox_ids,

commit 5f045af0b5dcdeba2776f0123bb33aba57f7b265
Author: Paolo Cretaro <paolocretaro@gmail.com>
Date:   Sun Nov 19 01:57:45 2017 +0100

    iio: cros_ec: Remove unused variables
    
    Fix gcc warnings about variable 'ec_device' being set but not used
    in these files:
    common/cros_ec_sensors/cros_ec_sensors.c:194:25
    light/cros_ec_light_prox.c:184:25
    
    Signed-off-by: Paolo Cretaro <paolocretaro@gmail.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/light/cros_ec_light_prox.c b/drivers/iio/light/cros_ec_light_prox.c
index b2a46b390d5c..acfad4aeb27a 100644
--- a/drivers/iio/light/cros_ec_light_prox.c
+++ b/drivers/iio/light/cros_ec_light_prox.c
@@ -181,7 +181,6 @@ static int cros_ec_light_prox_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct cros_ec_dev *ec_dev = dev_get_drvdata(dev->parent);
-	struct cros_ec_device *ec_device;
 	struct iio_dev *indio_dev;
 	struct cros_ec_light_prox_state *state;
 	struct iio_chan_spec *channel;
@@ -191,7 +190,6 @@ static int cros_ec_light_prox_probe(struct platform_device *pdev)
 		dev_warn(dev, "No CROS EC device found.\n");
 		return -EINVAL;
 	}
-	ec_device = ec_dev->ec_dev;
 
 	indio_dev = devm_iio_device_alloc(dev, sizeof(*state));
 	if (!indio_dev)

commit 4166b47c2b4ae38496a6871b3560677705f8edea
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sun Jul 23 17:26:00 2017 +0100

    iio:light: drop assign iio_info.driver_module and iio_trigger_ops.owner
    
    The equivalent of both of these are now done via macro magic when
    the relevant register calls are made.  The actual structure
    elements will shortly go away.
    
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>

diff --git a/drivers/iio/light/cros_ec_light_prox.c b/drivers/iio/light/cros_ec_light_prox.c
index 721722376fd0..b2a46b390d5c 100644
--- a/drivers/iio/light/cros_ec_light_prox.c
+++ b/drivers/iio/light/cros_ec_light_prox.c
@@ -175,7 +175,6 @@ static int cros_ec_light_prox_write(struct iio_dev *indio_dev,
 static const struct iio_info cros_ec_light_prox_info = {
 	.read_raw = &cros_ec_light_prox_read,
 	.write_raw = &cros_ec_light_prox_write,
-	.driver_module = THIS_MODULE,
 };
 
 static int cros_ec_light_prox_probe(struct platform_device *pdev)

commit 48458b0c196c6d6224aac5e1178a561e89011724
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Mon Jan 30 18:07:53 2017 +0100

    iio: cros_ec_light_prox: add ChromeOS EC Light and Proximity Sensors
    
    Handle Light and Proximity sensors presented by the ChromeOS EC Sensor hub.
    Creates an IIO device for each functions.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Signed-off-by: Guenter Roeck <groeck@chromium.org>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/light/cros_ec_light_prox.c b/drivers/iio/light/cros_ec_light_prox.c
new file mode 100644
index 000000000000..721722376fd0
--- /dev/null
+++ b/drivers/iio/light/cros_ec_light_prox.c
@@ -0,0 +1,289 @@
+/*
+ * cros_ec_light_prox - Driver for light and prox sensors behing CrosEC.
+ *
+ * Copyright (C) 2017 Google, Inc
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/kfifo_buf.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/triggered_buffer.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/kernel.h>
+#include <linux/mfd/cros_ec.h>
+#include <linux/mfd/cros_ec_commands.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/sysfs.h>
+
+#include "../common/cros_ec_sensors/cros_ec_sensors_core.h"
+
+/*
+ * We only represent one entry for light or proximity. EC is merging different
+ * light sensors to return the what the eye would see. For proximity, we
+ * currently support only one light source.
+ */
+#define CROS_EC_LIGHT_PROX_MAX_CHANNELS (1 + 1)
+
+/* State data for ec_sensors iio driver. */
+struct cros_ec_light_prox_state {
+	/* Shared by all sensors */
+	struct cros_ec_sensors_core_state core;
+
+	struct iio_chan_spec channels[CROS_EC_LIGHT_PROX_MAX_CHANNELS];
+};
+
+static int cros_ec_light_prox_read(struct iio_dev *indio_dev,
+				   struct iio_chan_spec const *chan,
+				   int *val, int *val2, long mask)
+{
+	struct cros_ec_light_prox_state *st = iio_priv(indio_dev);
+	u16 data = 0;
+	s64 val64;
+	int ret = IIO_VAL_INT;
+	int idx = chan->scan_index;
+
+	mutex_lock(&st->core.cmd_lock);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		if (chan->type == IIO_PROXIMITY) {
+			if (cros_ec_sensors_read_cmd(indio_dev, 1 << idx,
+						     (s16 *)&data) < 0) {
+				ret = -EIO;
+				break;
+			}
+			*val = data;
+		} else {
+			ret = -EINVAL;
+		}
+		break;
+	case IIO_CHAN_INFO_PROCESSED:
+		if (chan->type == IIO_LIGHT) {
+			if (cros_ec_sensors_read_cmd(indio_dev, 1 << idx,
+						     (s16 *)&data) < 0) {
+				ret = -EIO;
+				break;
+			}
+			/*
+			 * The data coming from the light sensor is
+			 * pre-processed and represents the ambient light
+			 * illuminance reading expressed in lux.
+			 */
+			*val = data;
+			ret = IIO_VAL_INT;
+		} else {
+			ret = -EINVAL;
+		}
+		break;
+	case IIO_CHAN_INFO_CALIBBIAS:
+		st->core.param.cmd = MOTIONSENSE_CMD_SENSOR_OFFSET;
+		st->core.param.sensor_offset.flags = 0;
+
+		if (cros_ec_motion_send_host_cmd(&st->core, 0)) {
+			ret = -EIO;
+			break;
+		}
+
+		/* Save values */
+		st->core.calib[0] = st->core.resp->sensor_offset.offset[0];
+
+		*val = st->core.calib[idx];
+		break;
+	case IIO_CHAN_INFO_CALIBSCALE:
+		/*
+		 * RANGE is used for calibration
+		 * scale is a number x.y, where x is coded on 16 bits,
+		 * y coded on 16 bits, between 0 and 9999.
+		 */
+		st->core.param.cmd = MOTIONSENSE_CMD_SENSOR_RANGE;
+		st->core.param.sensor_range.data = EC_MOTION_SENSE_NO_VALUE;
+
+		if (cros_ec_motion_send_host_cmd(&st->core, 0)) {
+			ret = -EIO;
+			break;
+		}
+
+		val64 = st->core.resp->sensor_range.ret;
+		*val = val64 >> 16;
+		*val2 = (val64 & 0xffff) * 100;
+		ret = IIO_VAL_INT_PLUS_MICRO;
+		break;
+	default:
+		ret = cros_ec_sensors_core_read(&st->core, chan, val, val2,
+						mask);
+		break;
+	}
+
+	mutex_unlock(&st->core.cmd_lock);
+
+	return ret;
+}
+
+static int cros_ec_light_prox_write(struct iio_dev *indio_dev,
+			       struct iio_chan_spec const *chan,
+			       int val, int val2, long mask)
+{
+	struct cros_ec_light_prox_state *st = iio_priv(indio_dev);
+	int ret = 0;
+	int idx = chan->scan_index;
+
+	mutex_lock(&st->core.cmd_lock);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_CALIBBIAS:
+		st->core.calib[idx] = val;
+		/* Send to EC for each axis, even if not complete */
+		st->core.param.cmd = MOTIONSENSE_CMD_SENSOR_OFFSET;
+		st->core.param.sensor_offset.flags = MOTION_SENSE_SET_OFFSET;
+		st->core.param.sensor_offset.offset[0] = st->core.calib[0];
+		st->core.param.sensor_offset.temp =
+					EC_MOTION_SENSE_INVALID_CALIB_TEMP;
+		if (cros_ec_motion_send_host_cmd(&st->core, 0))
+			ret = -EIO;
+		break;
+	case IIO_CHAN_INFO_CALIBSCALE:
+		st->core.param.cmd = MOTIONSENSE_CMD_SENSOR_RANGE;
+		st->core.param.sensor_range.data = (val << 16) | (val2 / 100);
+		if (cros_ec_motion_send_host_cmd(&st->core, 0))
+			ret = -EIO;
+		break;
+	default:
+		ret = cros_ec_sensors_core_write(&st->core, chan, val, val2,
+						 mask);
+		break;
+	}
+
+	mutex_unlock(&st->core.cmd_lock);
+
+	return ret;
+}
+
+static const struct iio_info cros_ec_light_prox_info = {
+	.read_raw = &cros_ec_light_prox_read,
+	.write_raw = &cros_ec_light_prox_write,
+	.driver_module = THIS_MODULE,
+};
+
+static int cros_ec_light_prox_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct cros_ec_dev *ec_dev = dev_get_drvdata(dev->parent);
+	struct cros_ec_device *ec_device;
+	struct iio_dev *indio_dev;
+	struct cros_ec_light_prox_state *state;
+	struct iio_chan_spec *channel;
+	int ret;
+
+	if (!ec_dev || !ec_dev->ec_dev) {
+		dev_warn(dev, "No CROS EC device found.\n");
+		return -EINVAL;
+	}
+	ec_device = ec_dev->ec_dev;
+
+	indio_dev = devm_iio_device_alloc(dev, sizeof(*state));
+	if (!indio_dev)
+		return -ENOMEM;
+
+	ret = cros_ec_sensors_core_init(pdev, indio_dev, true);
+	if (ret)
+		return ret;
+
+	indio_dev->info = &cros_ec_light_prox_info;
+	state = iio_priv(indio_dev);
+	state->core.type = state->core.resp->info.type;
+	state->core.loc = state->core.resp->info.location;
+	channel = state->channels;
+
+	/* Common part */
+	channel->info_mask_shared_by_all =
+		BIT(IIO_CHAN_INFO_SAMP_FREQ) |
+		BIT(IIO_CHAN_INFO_FREQUENCY);
+	channel->scan_type.realbits = CROS_EC_SENSOR_BITS;
+	channel->scan_type.storagebits = CROS_EC_SENSOR_BITS;
+	channel->scan_type.shift = 0;
+	channel->scan_index = 0;
+	channel->ext_info = cros_ec_sensors_ext_info;
+	channel->scan_type.sign = 'u';
+
+	state->core.calib[0] = 0;
+
+	/* Sensor specific */
+	switch (state->core.type) {
+	case MOTIONSENSE_TYPE_LIGHT:
+		channel->type = IIO_LIGHT;
+		channel->info_mask_separate =
+			BIT(IIO_CHAN_INFO_PROCESSED) |
+			BIT(IIO_CHAN_INFO_CALIBBIAS) |
+			BIT(IIO_CHAN_INFO_CALIBSCALE);
+		break;
+	case MOTIONSENSE_TYPE_PROX:
+		channel->type = IIO_PROXIMITY;
+		channel->info_mask_separate =
+			BIT(IIO_CHAN_INFO_RAW) |
+			BIT(IIO_CHAN_INFO_CALIBBIAS) |
+			BIT(IIO_CHAN_INFO_CALIBSCALE);
+		break;
+	default:
+		dev_warn(dev, "Unknown motion sensor\n");
+		return -EINVAL;
+	}
+
+	/* Timestamp */
+	channel++;
+	channel->type = IIO_TIMESTAMP;
+	channel->channel = -1;
+	channel->scan_index = 1;
+	channel->scan_type.sign = 's';
+	channel->scan_type.realbits = 64;
+	channel->scan_type.storagebits = 64;
+
+	indio_dev->channels = state->channels;
+
+	indio_dev->num_channels = CROS_EC_LIGHT_PROX_MAX_CHANNELS;
+
+	state->core.read_ec_sensors_data = cros_ec_sensors_read_cmd;
+
+	ret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,
+					      cros_ec_sensors_capture, NULL);
+	if (ret)
+		return ret;
+
+	return devm_iio_device_register(dev, indio_dev);
+}
+
+static const struct platform_device_id cros_ec_light_prox_ids[] = {
+	{
+		.name = "cros-ec-prox",
+	},
+	{
+		.name = "cros-ec-light",
+	},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(platform, cros_ec_light_prox_ids);
+
+static struct platform_driver cros_ec_light_prox_platform_driver = {
+	.driver = {
+		.name	= "cros-ec-light-prox",
+	},
+	.probe		= cros_ec_light_prox_probe,
+	.id_table	= cros_ec_light_prox_ids,
+};
+module_platform_driver(cros_ec_light_prox_platform_driver);
+
+MODULE_DESCRIPTION("ChromeOS EC light/proximity sensors driver");
+MODULE_LICENSE("GPL v2");
