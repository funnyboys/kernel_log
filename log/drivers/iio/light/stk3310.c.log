commit c3a686070670d9efad9a4af354ca88031cd7e7f9
Author: Luca Weiss <luca@z3ntu.xyz>
Date:   Wed Jul 3 20:05:59 2019 +0200

    iio: light: stk3310: Add device tree support
    
    Add device tree support for the stk33xx family of ambient light sensors.
    
    Tested-by: Martijn Braam <martijn@brixit.nl>
    Signed-off-by: Luca Weiss <luca@z3ntu.xyz>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
index b955183edfe8..185c24a75ae6 100644
--- a/drivers/iio/light/stk3310.c
+++ b/drivers/iio/light/stk3310.c
@@ -679,9 +679,18 @@ static const struct acpi_device_id stk3310_acpi_id[] = {
 
 MODULE_DEVICE_TABLE(acpi, stk3310_acpi_id);
 
+static const struct of_device_id stk3310_of_match[] = {
+	{ .compatible = "sensortek,stk3310", },
+	{ .compatible = "sensortek,stk3311", },
+	{ .compatible = "sensortek,stk3335", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, stk3310_of_match);
+
 static struct i2c_driver stk3310_driver = {
 	.driver = {
 		.name = "stk3310",
+		.of_match_table = stk3310_of_match,
 		.pm = STK3310_PM_OPS,
 		.acpi_match_table = ACPI_PTR(stk3310_acpi_id),
 	},

commit c55cc97a252488a8e2a9181c1c36713cad69ee18
Merge: 003e6cc3a22d 208a68c8393d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jul 1 10:58:13 2019 +0200

    Merge tag 'iio-for-5.3b' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-next
    
    Jonathan writes:
    
    Second set of IIO device support, features, cleanups and minor fixes for 5.3.
    
    A few bits for the counters subsystem mixed in here as well.
    There are some late breaking fixes as well, which aren't so urgent
    they can't wait for the merge window.
    
    New Device Support
    * adf4371
      - New driver + bindings.
      - Support the adf4372 PLL. Mostly ID and bindings.
    * ad8366 (note includes rework of driver needed to allow support for these).
      - Support the ADL5240 variable gain amplifier (VGA).
      - Support the ADA4961 digital gain amplifier (DGA).
    * dps310
      - New driver, in several parts from different authors for this temp
        and pressure sensor.
      - Includes errata workaround for a temperature reading issue.
    * stk3310
      - Support the stk3335, mostly ID.
    
    Features and cleanups
    * core
      - drop error handling on debugfs registration.
      - harden by making sure we don't overrun iio_chan_info_postfix.
    * docs
      - convert remaining docs to rst. At somepoint we'll fit these few
        into the main IIO docs.
      - improve sampling_frequency_available docs but explaining the
        range form.
    * ad_sigma_delta
      - Drop a pointless goto.
    * ad2s1210
      - Drop pointless platform data null check seeing as we don't actually
        use platform data anymore.
    * ad7124
      - Relax limitation on channel numbers to allow pseudo different channels.
      - Support control of whether the input is buffered via DT.
      - Use dynamic allocation for channel configuration to make it easier
        to support new devices.
      - YAML binding conversion.
    * ad7150
      - Comment tidy up.
      - Consistent and simple if (ret) handling of i2c errors.
      - FIELD_GET and GENMASK.
      - Ternary rather than !!(condition) for readability.
      - Use macros to avoid repetition of channel definitions.
    * ad7606
      - Add software channel config (rather that pin controlled)
      - Refactor to simplify addition of new part in future.
    * ad7746
      - of_deivce_id table.
    * ad7780
      - MAINTAINERS entry
      - YAML DT bindings.
    * ad8366
      - Stop using core mlock in favour of well scoped local lock.
      - SPDX + copyright date update.
    * ad9834
      - of_device_id table
    * adf4371
      - Add support for output stage muting before lock on has occured.
    * adis library
      - MAINTAINERS entry to reflect that this now Alexandru's problem ;)
    * adis162xx:
      - Fix a slightly incorrect set of comments and print statements on
        minimum supported voltage.
    * adis16203
      - of_device_id table.
    * adis16240
      - Add of_device_id table (in two parts as first patch only used it for
        MODULE_DEVICE_TABLE.)
    * adt7316-spi
      - of_device_id table
    * adxl372
      - YAML DT binding conversion.
      - Cleanup use of buffer callback functions (precursor to core rework).
    * bh1710
      - Simplify getting the i2c adapter from the client.
    * dht11
      - Mote to newer GPIO consumer interface.
    * kxcjk-1013.c
      - Add binding for sensor in display of some ultrabooks after userspace
        tools updated for it not be a problem to report two similar sensors.
    * imx7d
      - drop unused variables.
      - white space
      - define instead of variable for clock frequency that is fixed.
      - drop pointless error message.
    * messon_saradc
      - SPDX
    * sps30
      - MAINTAINERS entry
      - YAML binding conversion.
    * st_accel
      - Tidy up ordering in various buffer related callbacks. This is
        part of a long running effort to simplify the core code.
    * stm32-dfsdm:
      - Manage the resolution cleanly in triggerd modes.
      - Add fast mode support which allows more flexible filter choices.
      - Add a comment on the reason for a 16 bit record when technically
        not 'required'.
    * st_lsm6dsx
      - Embed device name in the sensor_settings struct as i3c doesn't
        have a convenient name field to use for this.
    * xilinx-adc
      - Relax constraints on supported platforms to reflect that this
        can used with FPGAs on PCIe cards and hence many architectures.
    * counters/ftm-quaddec
      - Fix some formatting io MODULE_AUTHOR
      - MAINTAINERS entry
    
    Fixes
    * tools
      - fix incorrect handling of 32 bit channels.
    * sca3000
      - Potential endian bug that is unlikely to bite anyone (be64 host
        seems unlikely for this old part).
    * stm32-adc
      - Add vdda-supply. On some boards it needs to be turned on to supply
        the ADC.  DT bindings included.
    * stm32-dfsdm
      - Fix output resolution to work with filter orders other than 3.
      - Fix output datatype as it's signed and previously claimed not to be.
    
    * tag 'iio-for-5.3b' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio: (68 commits)
      iio: iio-utils: Fix possible incorrect mask calculation
      iio: frequency: adf4371: Add support for output stage mute
      dt-bindings: iio: frequency: Add ADF4372 PLL documentation
      iio: frequency: adf4371: Add support for ADF4372 PLL
      dt-bindings: iio: adc: Add buffered input property
      Convert AD7124 bindings documentation to YAML format.
      iio: adc: ad7124: Shift to dynamic allocation for channel configuration
      iio: adc: ad7124: Add buffered input support
      iio: adc: ad7124: Remove input number limitation
      MAINTAINERS: add ADIS IMU driver library entry
      iio: adis162xx: fix low-power docs & reports
      counter/ftm-quaddec: Add missing '>' in MODULE_AUTHOR
      iio: core: no need to check return value of debugfs_create functions
      docs: iio: convert to ReST
      iio: adc: stm32-adc: add missing vdda-supply
      dt-bindings: iio: adc: stm32: add missing vdda supply
      iio: adc: stm32-dfsdm: add comment for 16 bits record
      iio: adc: stm32-dfsdm: add fast mode support
      iio: adc: stm32-dfsdm: manage data resolution in trigger mode
      iio: adc: stm32-dfsdm: fix data type
      ...

commit 677f16813a9245d02247d1379c8c535e361b7d0b
Author: Martijn Braam <martijn@brixit.nl>
Date:   Mon Jun 3 21:20:39 2019 +0200

    iio: light: stk3310: Add support for stk3335
    
    The stk3335 light/proximity sensor is similar to the stk3310 and stk3311
    sensors and works with the stk3310 driver.
    
    Signed-off-by: Martijn Braam <martijn@brixit.nl>
    Signed-off-by: Luca Weiss <luca@z3ntu.xyz>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
index 6e2a169da950..a25cc35f334e 100644
--- a/drivers/iio/light/stk3310.c
+++ b/drivers/iio/light/stk3310.c
@@ -40,6 +40,7 @@
 
 #define STK3310_CHIP_ID_VAL			0x13
 #define STK3311_CHIP_ID_VAL			0x1D
+#define STK3335_CHIP_ID_VAL			0x51
 #define STK3310_PSINT_EN			0x01
 #define STK3310_PS_MAX_VAL			0xFFFF
 
@@ -454,7 +455,8 @@ static int stk3310_init(struct iio_dev *indio_dev)
 		return ret;
 
 	if (chipid != STK3310_CHIP_ID_VAL &&
-	    chipid != STK3311_CHIP_ID_VAL) {
+	    chipid != STK3311_CHIP_ID_VAL &&
+	    chipid != STK3335_CHIP_ID_VAL) {
 		dev_err(&client->dev, "invalid chip id: 0x%x\n", chipid);
 		return -ENODEV;
 	}
@@ -666,6 +668,7 @@ static SIMPLE_DEV_PM_OPS(stk3310_pm_ops, stk3310_suspend, stk3310_resume);
 static const struct i2c_device_id stk3310_i2c_id[] = {
 	{"STK3310", 0},
 	{"STK3311", 0},
+	{"STK3335", 0},
 	{}
 };
 MODULE_DEVICE_TABLE(i2c, stk3310_i2c_id);
@@ -673,6 +676,7 @@ MODULE_DEVICE_TABLE(i2c, stk3310_i2c_id);
 static const struct acpi_device_id stk3310_acpi_id[] = {
 	{"STK3310", 0},
 	{"STK3311", 0},
+	{"STK3335", 0},
 	{}
 };
 

commit 36edc93958e06dfc15b61d1cfa7f33929bc26fe4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:44 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 330
    
    Based on 1 normalized pattern(s):
    
      this file is subject to the terms and conditions of version 2 of the
      gnu general public license see the file copying in the main
      directory of this archive for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 55 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.108941081@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
index 6e2a169da950..eff7ac9ae669 100644
--- a/drivers/iio/light/stk3310.c
+++ b/drivers/iio/light/stk3310.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /**
  * Sensortek STK3310/STK3311 Ambient Light and Proximity Sensor
  *
  * Copyright (c) 2015, Intel Corporation.
  *
- * This file is subject to the terms and conditions of version 2 of
- * the GNU General Public License. See the file COPYING in the main
- * directory of this archive for more details.
- *
  * IIO driver for STK3310/STK3311. 7-bit I2C address: 0x48.
  */
 

commit 4166b47c2b4ae38496a6871b3560677705f8edea
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sun Jul 23 17:26:00 2017 +0100

    iio:light: drop assign iio_info.driver_module and iio_trigger_ops.owner
    
    The equivalent of both of these are now done via macro magic when
    the relevant register calls are made.  The actual structure
    elements will shortly go away.
    
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>

diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
index 45cf8b0a4363..6e2a169da950 100644
--- a/drivers/iio/light/stk3310.c
+++ b/drivers/iio/light/stk3310.c
@@ -409,7 +409,6 @@ static int stk3310_write_raw(struct iio_dev *indio_dev,
 }
 
 static const struct iio_info stk3310_info = {
-	.driver_module		= THIS_MODULE,
 	.read_raw		= stk3310_read_raw,
 	.write_raw		= stk3310_write_raw,
 	.attrs			= &stk3310_attribute_group,

commit bc2b7dab629a51e8beb5fda4222c62a23b729f26
Author: Gregor Boirie <gregor.boirie@parrot.com>
Date:   Wed Mar 9 19:05:49 2016 +0100

    iio:core: timestamping clock selection support
    
    Adds a new per-device sysfs attribute "current_timestamp_clock" to allow
    userspace to select a particular POSIX clock for buffered samples and
    events timestamping.
    
    Following clocks, as listed in clock_gettime(2), are supported:
    CLOCK_REALTIME, CLOCK_MONOTONIC, CLOCK_MONOTONIC_RAW,
    CLOCK_REALTIME_COARSE, CLOCK_MONOTONIC_COARSE, CLOCK_BOOTTIME and
    CLOCK_TAI.
    
    Signed-off-by: Gregor Boirie <gregor.boirie@parrot.com>
    Acked-by: Sanchayan Maity <maitysanchayan@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
index 9e847f8f4f0c..45cf8b0a4363 100644
--- a/drivers/iio/light/stk3310.c
+++ b/drivers/iio/light/stk3310.c
@@ -528,7 +528,7 @@ static irqreturn_t stk3310_irq_handler(int irq, void *private)
 	struct iio_dev *indio_dev = private;
 	struct stk3310_data *data = iio_priv(indio_dev);
 
-	data->timestamp = iio_get_time_ns();
+	data->timestamp = iio_get_time_ns(indio_dev);
 
 	return IRQ_WAKE_THREAD;
 }

commit b1532909decca12e0527473870cec1d57677f916
Author: Irina Tirdea <irina.tirdea@intel.com>
Date:   Thu Mar 24 11:08:38 2016 +0200

    iio: remove unused gpio consumer.h include
    
    GPIO handling code has been removed from the drivers (since
    this is now handled by the ACPI core) in commit 0f0796509c07 ("iio:
    remove gpio interrupt probing from drivers that use a single interrupt").
    
    Remove the include for linux/gpio/consumer.h since it is no longer
    used.
    
    Signed-off-by: Irina Tirdea <irina.tirdea@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
index 42d334ba612e..9e847f8f4f0c 100644
--- a/drivers/iio/light/stk3310.c
+++ b/drivers/iio/light/stk3310.c
@@ -16,7 +16,6 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/regmap.h>
-#include <linux/gpio/consumer.h>
 #include <linux/iio/events.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/sysfs.h>

commit 0f0796509c07c1c7b77671c05b2955beb245e367
Author: Octavian Purdila <octavian.purdila@intel.com>
Date:   Wed Sep 23 12:02:01 2015 +0300

    iio: remove gpio interrupt probing from drivers that use a single interrupt
    
    Commit 845c877009cf014b ("i2c / ACPI: Assign IRQ for devices that have
    GpioInt automatically") automatically assigns the first ACPI GPIO
    interrupt in client->irq, so we can remove the probing code from
    drivers that use only one interrupt.
    
    Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
index f45b06bcf6ae..42d334ba612e 100644
--- a/drivers/iio/light/stk3310.c
+++ b/drivers/iio/light/stk3310.c
@@ -47,7 +47,6 @@
 #define STK3310_DRIVER_NAME			"stk3310"
 #define STK3310_REGMAP_NAME			"stk3310_regmap"
 #define STK3310_EVENT				"stk3310_event"
-#define STK3310_GPIO				"stk3310_gpio"
 
 #define STK3310_SCALE_AVAILABLE			"6.4 1.6 0.4 0.1"
 
@@ -477,30 +476,6 @@ static int stk3310_init(struct iio_dev *indio_dev)
 	return ret;
 }
 
-static int stk3310_gpio_probe(struct i2c_client *client)
-{
-	struct device *dev;
-	struct gpio_desc *gpio;
-	int ret;
-
-	if (!client)
-		return -EINVAL;
-
-	dev = &client->dev;
-
-	/* gpio interrupt pin */
-	gpio = devm_gpiod_get_index(dev, STK3310_GPIO, 0, GPIOD_IN);
-	if (IS_ERR(gpio)) {
-		dev_err(dev, "acpi gpio get index failed\n");
-		return PTR_ERR(gpio);
-	}
-
-	ret = gpiod_to_irq(gpio);
-	dev_dbg(dev, "GPIO resource, no:%d irq:%d\n", desc_to_gpio(gpio), ret);
-
-	return ret;
-}
-
 static bool stk3310_is_volatile_reg(struct device *dev, unsigned int reg)
 {
 	switch (reg) {
@@ -624,14 +599,6 @@ static int stk3310_probe(struct i2c_client *client,
 	if (ret < 0)
 		return ret;
 
-	if (client->irq < 0) {
-		client->irq = stk3310_gpio_probe(client);
-		if (client->irq < 0) {
-			ret = client->irq;
-			goto err_standby;
-		}
-	}
-
 	if (client->irq > 0) {
 		ret = devm_request_threaded_irq(&client->dev, client->irq,
 						stk3310_irq_handler,

commit 6839c1b0700a79375639528985a0ec0fbd58cf9a
Author: Octavian Purdila <octavian.purdila@intel.com>
Date:   Wed Sep 23 12:02:00 2015 +0300

    iio: fix drivers that use 0 as a valid IRQ in client->irq (part 2)
    
    Since commit dab472eb931bc291 ("i2c / ACPI: Use 0 to indicate that
    device does not have interrupt assigned") 0 is not a valid i2c
    client irq anymore, so change all driver's checks accordingly.
    
    The same issue occurs when the device is instantiated via device tree
    with no IRQ, or from the i2c sysfs interface, even before the patch
    above.
    
    Signed-off-by: Octavian Purdila <octavian.purdila@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
index 013b21779db9..f45b06bcf6ae 100644
--- a/drivers/iio/light/stk3310.c
+++ b/drivers/iio/light/stk3310.c
@@ -632,7 +632,7 @@ static int stk3310_probe(struct i2c_client *client,
 		}
 	}
 
-	if (client->irq >= 0) {
+	if (client->irq > 0) {
 		ret = devm_request_threaded_irq(&client->dev, client->irq,
 						stk3310_irq_handler,
 						stk3310_irq_event_handler,

commit 9f827d8099e76a4a2fb99faa88ee7859459f2360
Merge: 99207b80bbf6 1d2f1e084b73
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Sep 30 03:37:48 2015 +0200

    Merge tag 'iio-for-4.4a' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-next
    
    Jonathan writes:
    
    First round of new driver, new functionality and cleanups for IIO in the 4.4 cycle
    
    New device support
    * APDS9960 ALS + proximity driver
    * bmg160 SPI devices.
    * HDC100x humidity sensors
    * Holt HI-8435 threshold detector
    * mma8453Q accelerometer added to the mma8452 driver
    * mma86452FC and mma8653FC accelerometers added to the mma8452 driver
    * mxc4005 accelerometer
    * PulsedLight LIDAR
    * SensorTech VZ89x volatile organic compound sensor
    * UPISEMI uS5182d ALS and proximity sensors
    
    New core functionality
    * triggered events - use triggers to check for changes in threshold type
      detectors on devices with out interrupt support.  First user is the holt
      comparator.
    * chemical concentration and resistance channel types.
    
    New driver functionality
    * vf610
      - buffer support.
      - followup coccinelle warning fix.
    
    Core rework
    * buffers
      - break out callback buffer to own module.
      - move buffer implementations to a new subdirectory
    * percolate the error code form iio_event_getfd out to userspace
      rather than giving a missleading error later on.
    
    Cleanups
    * adddac drivers
      - use BIT macro where appropriate.
    * meter drivers
      - use BIT macro where appropriate.
    
    * ad7303
     - add an OF match table to line up with the binding docs.
    * adc128s052
      - add an OF match table to line up with the binding docs.
    * adf4350
      - add an OF match table to line up with the binding docs
    * as3935
      - add an OF match table to line up with the binding docs.
    * berlin2-adc
      - use GENMASK and BIT for masks
      - prevent attempting to sample multiple channels at once by moving a
        mutex scop
      - coding style cleanups
    * bmg150_magn
      - kconfig sort order was wrong - fix it.
    * bmg160
      - use i2c regmap and drop all uses of i2c_client
      - separate i2c and core driver
    * cc10001_adc
      - kconfig sort order was wrong - fix it.
    * evgen (dummy driver helper module)
      - move interrupt generation to irq_work to reduce differences between
        the dummy driver and real hardware drivers.
    * hmc5843
      - set the name dynamically rather than to a fixed value for one of the
        suported parts.
      - export module alias information to allow autoprobing of module.
    * lpc32xx
      - on failure to get resource or irq return -ENXIO as uppose to -EBUSY
    * max1027
      - set .of_match_table to actually allow OF style matching.
    * max5821
      - add MODULE_DEVICE_TABLE for OF table.
    * mma8452
      - refactor to separate out chip specific data.
      - add freefall / motion interrupt source for devices that do their
        interrupts slightly differently.
      - update copywrite notice.
      - leave naming of events directory in sysfs to the core
    * mcp320x
      - set .of_match_table so that it can be use for OF style matching.
    * mlx90614
      - Implement filter configuration (note the datasheet changed as a result
        of the driver reviews to include the values we needed ;)
    * opt3001
      - drop .owner field as assigned by platform driver core.
    * si7020
      - replace a bitmask on the humidity values with a more correct range
        check.
    * stk310
      - improved error handling.
      - use BIT macro where appropriate and use the resulting defines
        instead of magic numbers in the code.
      - fix indentation
    * st-sensors
      - add debugfs register read hook
    * tsl4531
      - fix error handling in check_id
    * twl6030
      - fix module autoload for OF
    * iio-trig-sysfs
      - document add and remove attribute
    * trigger in staging
      - code alignment fixes.
      - braces on both branches of if statement if needed for one.
    * xilinx-xadc
      - push interrupts into hardirq context as there isn't much in them
        any more and it avoids breaking PREEMPT_RT builds due to the use
        of a spinlock between the hardirq and the thread.
    
    Tools
    * event-monitor
      - report unsupported events.  We keep expanding what can come from drivers
        so give a helpful error if one turns up in an out of date userspace
        program.
    * generic-buffer
      - helpful message about needing to enable a channel to start the buffer.

commit 8d2faea672606827c2018143ec7d88c760f2d6de
Merge: 02cf1da2548d 01e2dae99177
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 4 10:07:45 2015 -0700

    Merge tag 'gpio-v4.3-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio
    
    Pull GPIO updates from Linus Walleij:
     "This is the bulk of GPIO changes for the v4.3 kernel cycle.
    
      There is quite a lot going on in the GPIO subsystem this merge window,
      so the main matter is decribed below.
    
      The hits in other subsystems when making the GPIO flags optional are
      all ACKed by their respective subsystem maintainers.
    
      Core changes:
    
       - Root out the wrapper devm_gpiod_get() and gpiod_get() etc versions
         of the descriptor calls that did not use the flags argument on the
         end.  This was around for too long and eventually Uwe Kleine-König
         took the time to clean it out and the last users are removed along
         with the macros in this tag.  In several cases the use of flags
         simplifies the code.  For this reason we have (ACKed) patches
         hitting in DRM, IIO, media, NFC, USB+PHY up until we hammer in the
         nail with removing the macros.
    
       - Add a fat document describing how much ready-made GPIO stuff we
         have i the kernel to discourage people from reinventing a square
         wheel in userspace, as so often happens.
    
       - Create a separate lockdep class for each instance of a GPIO IRQ
         chip instead of using one class for all chips, as the current code
         will not work with systems with several GPIO chips doing lockdep
         debugging.
    
       - Protect against driver unloading also when a GPIO line is only used
         as IRQ for the GPIOLIB_IRQCHIP helpers.
    
       - If the GPIO chip has no designated owner, assign the parent device
         driver owner as owner.
    
       - Consolidation of chained IRQ handler install/remove replacing all
         call sites where irq_set_handler_data() and
         irq_set_chained_handler() were done in succession with a combined
         call to irq_set_chained_handler_and_data().
    
         This series was created by Thomas Gleixner after the problem was
         observed by Russell King.
    
       - Tglx also made another series of patches switching
         __irq_set_handler_locked() for irq_set_handler_locked() which is
         way cleaner.
    
       - Tglx and Jiang Liu wrote a good bunch of patches to make use of
         irq_desc_get_xxx() accessors and avoid looking up irq_descs from
         IRQ numbers.  The goal is to get rid of the irq number from the
         handlers in the IRQ flow which is nice.
    
       - Rob Herring killed off the set_irq_flags() for all GPIO drivers.
         This was an ARM specific function that is replaced with the generic
         irq_modify_status() where special flags are actually needed.
    
       - When an OF node has a pin range for its GPIOs, return -EPROBE_DEFER
         if the pin controller isn't available.  Pretty logical, yet needed
         to be fixed.
    
       - If a driver using GPIOLIB_IRQCHIP has its own irq_*_resources call
         back, then call these instead of the defaults provided by the
         GPIOLIB.
    
       - Fix an undocumented ABI hole: named GPIOs were not properly
         documented.
    
      Driver improvements:
    
       - Add get_direction() support to the generic GPIO driver, it's
         strange that we didn't have that before.
    
       - Make it possible to have input-only GPIO chips using the generic
         GPIO driver.
    
       - Clean out platform data support from the Emma Mobile (EM) driver
    
       - Finegrained runtime PM support for the RCAR driver.
    
       - Support r8a7795 (R-car H3) in the RCAR driver.
    
       - Support interrupts on GPIOs 16 thru 31 in the DaVinci driver.
    
       - Some consolidation and new support in the MPC8xxx driver, we now
         support MPC5125.
    
       - Preempt-RT-friendly patches: the OMAP, MPC8xxx, drivers uses raw
         spinlocks making it work better with the realime patches.
    
       - Interrupt support for the EXTRAXFS GPIO driver.
    
       - Make the ETRAXFS GPIO driver support also ARTPEC-3.
    
       - Interrupt and wakeup support for the BRCMSTB driver, also for
         wakeup from S5 cold boot.
    
       - Mask MXC IRQs during suspend.
    
       - Improve OMAP2 GPIO set_debounce() to work according to spec.
    
       - The VF610 driver handles IRQs properly.
    
      New drivers:
    
       - ZTE ZX GPIO driver"
    
    * tag 'gpio-v4.3-1' of git://git.kernel.org/pub/scm/linux/kernel/git/linusw/linux-gpio: (87 commits)
      Revert "gpio: extraxfs: fix returnvar.cocci warnings"
      gpio: tc3589x: use static container helper
      gpio: xlp: fix error return code
      gpio: vf610: handle level IRQ's properly
      gpio: max732x: Fix error handling in probe()
      gpio: omap: fix clk_prepare/unprepare usage
      gpio: omap: protect regs access in omap_gpio_irq_handler
      gpio: omap: fix omap2_set_gpio_debounce
      gpio: omap: switch to use platform_get_irq
      gpio: omap: remove wrong irq_domain_remove usage in probe
      gpiolib: add description for gpio irqchip fields in struct gpio_chip
      gpio: extraxfs: fix returnvar.cocci warnings
      gpiolib: irqchip: use different lockdep class for each gpio irqchip
      gpio/grgpio: fix deadlock in grgpio_irq_unmap()
      Documentation: gpio: consumer: describe active low property
      gpio: mxc: fix section mismatch warning
      gpio/mxc: mask gpio interrupts in suspend
      gpio: omap: Fix missing raw locks conversion
      gpio: brcmstb: support wakeup from S5 cold boot
      gpio: brcmstb: Add interrupt and wakeup source support
      ...

commit 5f6f02cd49d61e9856ff2c337578316a1a1b3f88
Merge: 3afa129a9de0 cbfe8fa6cd67
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Aug 13 14:42:55 2015 +0200

    Merge tag 'v4.2-rc4' into devel
    
    Linux 4.2-rc4

commit 5b958f110f8b11f9bb6c62e713b83768b1375f31
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Thu Jul 9 23:51:33 2015 +0200

    iio:light:stk3310: adjust indentation
    
    Adjust some indentation issues as spotted by checkpatch.pl --strict
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Reviewed-by: Tiberiu Breana <tiberiu.a.breana@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
index e5e0b045ebc2..25c6a715545a 100644
--- a/drivers/iio/light/stk3310.c
+++ b/drivers/iio/light/stk3310.c
@@ -385,7 +385,7 @@ static int stk3310_write_raw(struct iio_dev *indio_dev,
 			ret = regmap_field_write(data->reg_ps_it, index);
 		if (ret < 0)
 			dev_err(&data->client->dev,
-					"sensor configuration failed\n");
+				"sensor configuration failed\n");
 		mutex_unlock(&data->lock);
 		return ret;
 
@@ -402,7 +402,7 @@ static int stk3310_write_raw(struct iio_dev *indio_dev,
 			ret = regmap_field_write(data->reg_ps_gain, index);
 		if (ret < 0)
 			dev_err(&data->client->dev,
-					"sensor configuration failed\n");
+				"sensor configuration failed\n");
 		mutex_unlock(&data->lock);
 		return ret;
 	}
@@ -645,7 +645,7 @@ static int stk3310_probe(struct i2c_client *client,
 						STK3310_EVENT, indio_dev);
 		if (ret < 0) {
 			dev_err(&client->dev, "request irq %d failed\n",
-					client->irq);
+				client->irq);
 			goto err_standby;
 		}
 	}

commit 952c3aa3fb5538aa5026980cfdedb3d38829b67e
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Thu Jul 9 23:51:32 2015 +0200

    iio:light:stk3310: use correct names and type for state
    
    Indicate the bit number of predefined states, make use of these names and
    change the state type in _resume to u8 to avoid type casting.
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Reviewed-by: Tiberiu Breana <tiberiu.a.breana@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
index 09f2f6a30b79..e5e0b045ebc2 100644
--- a/drivers/iio/light/stk3310.c
+++ b/drivers/iio/light/stk3310.c
@@ -35,8 +35,8 @@
 #define STK3310_REG_ID				0x3E
 #define STK3310_MAX_REG				0x80
 
-#define STK3310_STATE_EN_PS			0x01
-#define STK3310_STATE_EN_ALS			0x02
+#define STK3310_STATE_EN_PS			BIT(0)
+#define STK3310_STATE_EN_ALS			BIT(1)
 #define STK3310_STATE_STANDBY			0x00
 
 #define STK3310_CHIP_ID_VAL			0x13
@@ -436,8 +436,8 @@ static int stk3310_set_state(struct stk3310_data *data, u8 state)
 		dev_err(&client->dev, "failed to change sensor state\n");
 	} else if (state != STK3310_STATE_STANDBY) {
 		/* Don't reset the 'enabled' flags if we're going in standby */
-		data->ps_enabled  = !!(state & 0x01);
-		data->als_enabled = !!(state & 0x02);
+		data->ps_enabled  = !!(state & STK3310_STATE_EN_PS);
+		data->als_enabled = !!(state & STK3310_STATE_EN_ALS);
 	}
 	mutex_unlock(&data->lock);
 
@@ -683,7 +683,7 @@ static int stk3310_suspend(struct device *dev)
 
 static int stk3310_resume(struct device *dev)
 {
-	int state = 0;
+	u8 state = 0;
 	struct stk3310_data *data;
 
 	data = iio_priv(i2c_get_clientdata(to_i2c_client(dev)));

commit 7c7a9eeaa335df03d692ad65e0767020ad1be374
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Thu Jul 9 23:51:31 2015 +0200

    iio:light:stk3310: add more error handling
    
    Check for the following error cases:
      * lower boundary for val in _write_event
      * return value of regmap_(field_)read
      * possible values for chan->type
      * return value of stk3310_gpio_probe
    
    Also add an error path in _probe to put the sensor back into stand-by mode
    in case of serious errors.
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
index f101bb5bddc7..09f2f6a30b79 100644
--- a/drivers/iio/light/stk3310.c
+++ b/drivers/iio/light/stk3310.c
@@ -241,8 +241,11 @@ static int stk3310_write_event(struct iio_dev *indio_dev,
 	struct stk3310_data *data = iio_priv(indio_dev);
 	struct i2c_client *client = data->client;
 
-	regmap_field_read(data->reg_ps_gain, &index);
-	if (val > stk3310_ps_max[index])
+	ret = regmap_field_read(data->reg_ps_gain, &index);
+	if (ret < 0)
+		return ret;
+
+	if (val < 0 || val > stk3310_ps_max[index])
 		return -EINVAL;
 
 	if (dir == IIO_EV_DIR_RISING)
@@ -266,9 +269,12 @@ static int stk3310_read_event_config(struct iio_dev *indio_dev,
 				     enum iio_event_direction dir)
 {
 	unsigned int event_val;
+	int ret;
 	struct stk3310_data *data = iio_priv(indio_dev);
 
-	regmap_field_read(data->reg_int_ps, &event_val);
+	ret = regmap_field_read(data->reg_int_ps, &event_val);
+	if (ret < 0)
+		return ret;
 
 	return event_val;
 }
@@ -307,14 +313,16 @@ static int stk3310_read_raw(struct iio_dev *indio_dev,
 	struct stk3310_data *data = iio_priv(indio_dev);
 	struct i2c_client *client = data->client;
 
+	if (chan->type != IIO_LIGHT && chan->type != IIO_PROXIMITY)
+		return -EINVAL;
+
 	switch (mask) {
 	case IIO_CHAN_INFO_RAW:
 		if (chan->type == IIO_LIGHT)
 			reg = STK3310_REG_ALS_DATA_MSB;
-		else if (chan->type == IIO_PROXIMITY)
-			reg = STK3310_REG_PS_DATA_MSB;
 		else
-			return -EINVAL;
+			reg = STK3310_REG_PS_DATA_MSB;
+
 		mutex_lock(&data->lock);
 		ret = regmap_bulk_read(data->regmap, reg, &buf, 2);
 		if (ret < 0) {
@@ -327,17 +335,23 @@ static int stk3310_read_raw(struct iio_dev *indio_dev,
 		return IIO_VAL_INT;
 	case IIO_CHAN_INFO_INT_TIME:
 		if (chan->type == IIO_LIGHT)
-			regmap_field_read(data->reg_als_it, &index);
+			ret = regmap_field_read(data->reg_als_it, &index);
 		else
-			regmap_field_read(data->reg_ps_it, &index);
+			ret = regmap_field_read(data->reg_ps_it, &index);
+		if (ret < 0)
+			return ret;
+
 		*val = stk3310_it_table[index][0];
 		*val2 = stk3310_it_table[index][1];
 		return IIO_VAL_INT_PLUS_MICRO;
 	case IIO_CHAN_INFO_SCALE:
 		if (chan->type == IIO_LIGHT)
-			regmap_field_read(data->reg_als_gain, &index);
+			ret = regmap_field_read(data->reg_als_gain, &index);
 		else
-			regmap_field_read(data->reg_ps_gain, &index);
+			ret = regmap_field_read(data->reg_ps_gain, &index);
+		if (ret < 0)
+			return ret;
+
 		*val = stk3310_scale_table[index][0];
 		*val2 = stk3310_scale_table[index][1];
 		return IIO_VAL_INT_PLUS_MICRO;
@@ -354,6 +368,9 @@ static int stk3310_write_raw(struct iio_dev *indio_dev,
 	int index;
 	struct stk3310_data *data = iio_priv(indio_dev);
 
+	if (chan->type != IIO_LIGHT && chan->type != IIO_PROXIMITY)
+		return -EINVAL;
+
 	switch (mask) {
 	case IIO_CHAN_INFO_INT_TIME:
 		index = stk3310_get_index(stk3310_it_table,
@@ -435,7 +452,10 @@ static int stk3310_init(struct iio_dev *indio_dev)
 	struct stk3310_data *data = iio_priv(indio_dev);
 	struct i2c_client *client = data->client;
 
-	regmap_read(data->regmap, STK3310_REG_ID, &chipid);
+	ret = regmap_read(data->regmap, STK3310_REG_ID, &chipid);
+	if (ret < 0)
+		return ret;
+
 	if (chipid != STK3310_CHIP_ID_VAL &&
 	    chipid != STK3311_CHIP_ID_VAL) {
 		dev_err(&client->dev, "invalid chip id: 0x%x\n", chipid);
@@ -608,8 +628,13 @@ static int stk3310_probe(struct i2c_client *client,
 	if (ret < 0)
 		return ret;
 
-	if (client->irq < 0)
+	if (client->irq < 0) {
 		client->irq = stk3310_gpio_probe(client);
+		if (client->irq < 0) {
+			ret = client->irq;
+			goto err_standby;
+		}
+	}
 
 	if (client->irq >= 0) {
 		ret = devm_request_threaded_irq(&client->dev, client->irq,
@@ -618,17 +643,23 @@ static int stk3310_probe(struct i2c_client *client,
 						IRQF_TRIGGER_FALLING |
 						IRQF_ONESHOT,
 						STK3310_EVENT, indio_dev);
-		if (ret < 0)
+		if (ret < 0) {
 			dev_err(&client->dev, "request irq %d failed\n",
 					client->irq);
+			goto err_standby;
+		}
 	}
 
 	ret = iio_device_register(indio_dev);
 	if (ret < 0) {
 		dev_err(&client->dev, "device_register failed\n");
-		stk3310_set_state(data, STK3310_STATE_STANDBY);
+		goto err_standby;
 	}
 
+	return 0;
+
+err_standby:
+	stk3310_set_state(data, STK3310_STATE_STANDBY);
 	return ret;
 }
 

commit 1c46ae0af6df0bbde66c5e868563be57f18a27b4
Merge: a73e99cb67e7 41d903c00051
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Aug 12 12:43:41 2015 -0700

    Merge tag 'iio-for-4.3b-2' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-next
    
    Jonathan writes:
    
    Second set of new device support, features and cleanup for the 4.3 cycle.
    Take 2 also includes a fix set that was too late for the 4.2 cycle.
    
    As we had a lot of tools and docs work in this set, I have broken those
    out into their own categories in this description.
    
    Fixes from the pull request '4th set of IIO fixes for the 4.2 cycle'.
    * Poll functions for both event chardev and the buffer one were returning
      negative error codes (via a positive value).
    * A recent change to lsiio adding some error handling that was wrong and
      stopped the tool working.
    * bmg160 was missing some dependencies in Kconfig
    * berlin2-adc had a misshandled register (wrote a value rather than a bitmap)
    
    New device support
    * TI opt3001 light sensor
    * TXC PA12 ALS and proximity sensor.
    * mcp3301 ADC support (in mcp320x driver)
    * ST lsm303agr accelerometer and magnetometer drivers (plus some st-sensors
      common support to allow different WHOAMI register addresses, devices with
      fixed scale and allow interrupt equiped magnetometers).
    * ADIS16305, ADIS16367, ADIS16445IMUs (in the adis16400 driver)
    * ADIS16266 gyro (in the adis16260 driver)
    * ADIS16137 gyro (in the adis16136 driver)
    
    New functionality
    * mmc35240 DT bindings.
    * Inverse unit conversion macros to aid handing of values written to sysfs
      attributes.
    
    Core cleanup
    * Forward declaration of struct iio_trigger to avoid a compile warning.
    
    Driver cleanup / fixes
    * mxs-lradc
      - Clarify which parts are supported.
      - Fix spelling erorrs.
      - Missing/extra includes
      - reorder includes
      - add datasheet name listings for all usable channels (to allow them
        to be bound by name from consumer drivers)
    * acpi-als - add some function prefixes as per general iio style.
    * bmc150_magn - replace a magic value with the existing define.
    * vf610 - determine possible sample frequencies taking into account the
      electrical characteristics (defining a minimum sample time)
    * dht11
      - whitespace
      - additional docs
      - avoid mulitple assignments in one line
      - Use the new funciton ktime_get_resolution_ns to cleanup a nasty trick
        previously used for timing.
    * Fix all drivers that consider 0 a valid IRQ for historical reasons.
    * Export I2C module alias info where previously missing (to allow autoprobing)
    * Export OF module alias info where previously missing.
    * mmc35240 - switch some variables into arrays to improve readability.
    * mlx90614 - define some magic numbers for readability.
    * bmc150_magn
      - expand area locked by a mutex to cover all the use of the
        data->buffer.
      - use descriptive naming for a mask instead of a magic value.
    * berin2-adc
      - pass up an error code rather that a generic error
      - constify the iio_chan_spec
      - some other little tidy ups.
    * stk8312
      - fix a dependency on triggered buffers in kconfig
      - add a check for invalid attribute values
      - improve error handling by returning error codes where possible and
        return immediately where relevant
      - rework macro defs to use GENMASK etc
      - change some variable types to reduce unnecessary casting
      - clean up code style
      - drop a local buffer copy for bulk reads and use the one in data->buffer
         instead.
    * adis16400 - the adis16448 gyroscope scale was wrong.
    * adis16480 - some more wrong scales for various parts.
    * adis16300 - has an undocumented product id and serial number registers so
      use them.
    * iio_simple_dummy - fix some wrong code indentation.
    * bmc150-accel - use the chip ID to detect the chip present rather than
      verifying the expected part was there.  This was in response to a wrong
      ACPI entry on the WinBook TW100.
    * mma8452
      - fix _get_hp_filter_index
      - drop a double include
      - pass up an error code rather than rewriting it
      - range check input values to attribute writes
      - register defs tidy up using GENMASK and reordering them to be easier to
        follow.
      - various coding style cleanups
      - put the Kconfig entry in the write place (alphabetically).
    
    Tools related
    * Tools cleanup - drop an explicity NULL comparison, some unnecessary braces,
      use the ARRAY_SIZE macro, send error messages to stderr instead of dropping
      them in the middle of normal output.
    * Fix tools to allow that scale and offset attributes are optional.
    * More tools fixes including allowing true 32bit data (previously an overflow
      prevented more than 31bits)
    * Drop a stray header guard that ended up in a c file.
    * Make calc_digits static as it isn't exported or in the header.
    * Set ci_array pointer to NULL after free as a protection against non safe
      usage of the tools core code.  Also convert a double pointer to a single
      one as the extra level of indirection was unnecessary.
    
    Docs
    * DocBook introduction by Daniel Baluta.  Glad we are beginning to
      draw together some more introductory docs to suplement the various
      tools / examples.
    * Drop bytes_per_datum sysfs attribute docs as it no longer exists.
    * A whole load of missing / fixing of kernel-doc for the core of IIO.
    * Document the trigger name sysfs attribute in the ABI docs.
    * Minor typos in the ABI docs related to power down modes.

commit 58e446fcc69436988fdab4a81981f44193f064f7
Author: Javier Martinez Canillas <javier@osg.samsung.com>
Date:   Thu Jul 30 18:18:28 2015 +0200

    iio: Export I2C module alias information in missing drivers
    
    The I2C core always reports the MODALIAS uevent as "i2c:<client name"
    regardless if the driver was matched using the I2C id_table or the
    of_match_table. So the driver needs to export the I2C table and this
    be built into the module or udev won't have the necessary information
    to auto load the correct module when the device is added.
    
    Signed-off-by: Javier Martinez Canillas <javier@osg.samsung.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
index fee4297d7c8f..d26b931730ee 100644
--- a/drivers/iio/light/stk3310.c
+++ b/drivers/iio/light/stk3310.c
@@ -695,6 +695,7 @@ static const struct i2c_device_id stk3310_i2c_id[] = {
 	{"STK3311", 0},
 	{}
 };
+MODULE_DEVICE_TABLE(i2c, stk3310_i2c_id);
 
 static const struct acpi_device_id stk3310_acpi_id[] = {
 	{"STK3310", 0},

commit 423ad0c405d87868bd1ab19e8b503e6a41c86caf
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Thu Jul 9 23:51:30 2015 +0200

    iio:light:stk3310: make endianness independent of host
    
    Data is stored in the device in be16 format. Make use of be16_to_cpu and
    cpu_to_be16 to have correct endianness on any host architecture.
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Reviewed-by: Tiberiu Breana <tiberiu.a.breana@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
index e7e6e5a2b1f8..11a027adc204 100644
--- a/drivers/iio/light/stk3310.c
+++ b/drivers/iio/light/stk3310.c
@@ -200,7 +200,7 @@ static int stk3310_read_event(struct iio_dev *indio_dev,
 			      int *val, int *val2)
 {
 	u8 reg;
-	u16 buf;
+	__be16 buf;
 	int ret;
 	struct stk3310_data *data = iio_priv(indio_dev);
 
@@ -222,7 +222,7 @@ static int stk3310_read_event(struct iio_dev *indio_dev,
 		dev_err(&data->client->dev, "register read failed\n");
 		return ret;
 	}
-	*val = swab16(buf);
+	*val = be16_to_cpu(buf);
 
 	return IIO_VAL_INT;
 }
@@ -235,7 +235,7 @@ static int stk3310_write_event(struct iio_dev *indio_dev,
 			       int val, int val2)
 {
 	u8 reg;
-	u16 buf;
+	__be16 buf;
 	int ret;
 	unsigned int index;
 	struct stk3310_data *data = iio_priv(indio_dev);
@@ -252,7 +252,7 @@ static int stk3310_write_event(struct iio_dev *indio_dev,
 	else
 		return -EINVAL;
 
-	buf = swab16(val);
+	buf = cpu_to_be16(val);
 	ret = regmap_bulk_write(data->regmap, reg, &buf, 2);
 	if (ret < 0)
 		dev_err(&client->dev, "failed to set PS threshold!\n");
@@ -301,7 +301,7 @@ static int stk3310_read_raw(struct iio_dev *indio_dev,
 			    int *val, int *val2, long mask)
 {
 	u8 reg;
-	u16 buf;
+	__be16 buf;
 	int ret;
 	unsigned int index;
 	struct stk3310_data *data = iio_priv(indio_dev);
@@ -322,7 +322,7 @@ static int stk3310_read_raw(struct iio_dev *indio_dev,
 			mutex_unlock(&data->lock);
 			return ret;
 		}
-		*val = swab16(buf);
+		*val = be16_to_cpu(buf);
 		mutex_unlock(&data->lock);
 		return IIO_VAL_INT;
 	case IIO_CHAN_INFO_INT_TIME:

commit 037e966f2d63896129220112644f32962af6d115
Author: Hartmut Knaack <knaack.h@gmx.de>
Date:   Thu Jul 9 23:51:29 2015 +0200

    iio:light:stk3310: move device register to end of probe
    
    iio_device_register should be the last operation during probe. Therefor
    move up interrupt setup code and while at it, change the check for invalid
    values of client->irq to be smaller than zero.
    Fixes: 3dd477acbdd1 ("iio: light: Add threshold interrupt support for STK3310")
    
    As the device_register makes the userspace interfaces of the device available
    it is possible for requests to come in before the probe sequence has finished.
    This can lead to unhandled interrupts and similar.
    
    Signed-off-by: Hartmut Knaack <knaack.h@gmx.de>
    Reviewed-by: Tiberiu Breana <tiberiu.a.breana@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
index c1a218236be5..e7e6e5a2b1f8 100644
--- a/drivers/iio/light/stk3310.c
+++ b/drivers/iio/light/stk3310.c
@@ -608,13 +608,7 @@ static int stk3310_probe(struct i2c_client *client,
 	if (ret < 0)
 		return ret;
 
-	ret = iio_device_register(indio_dev);
-	if (ret < 0) {
-		dev_err(&client->dev, "device_register failed\n");
-		stk3310_set_state(data, STK3310_STATE_STANDBY);
-	}
-
-	if (client->irq <= 0)
+	if (client->irq < 0)
 		client->irq = stk3310_gpio_probe(client);
 
 	if (client->irq >= 0) {
@@ -629,6 +623,12 @@ static int stk3310_probe(struct i2c_client *client,
 					client->irq);
 	}
 
+	ret = iio_device_register(indio_dev);
+	if (ret < 0) {
+		dev_err(&client->dev, "device_register failed\n");
+		stk3310_set_state(data, STK3310_STATE_STANDBY);
+	}
+
 	return ret;
 }
 

commit 0f16fc8bb38156c842f6976ddbdf4f266e893a1b
Author: Tiberiu Breana <tiberiu.a.breana@intel.com>
Date:   Wed Jul 1 15:32:00 2015 +0300

    iio: light: STK3310: un-invert proximity values
    
    In accordance with the recent proximity ABI changes,
    STK3310's proximity readings should be un-inversed
    in order to return low values for far-away objects
    and high values for close ones.
    
    As consequences of this change, iio event directions
    have been switched and maximum proximity sensor
    reference values have also been adjusted in accordance
    with the real readings.
    
    Signed-off-by: Tiberiu Breana <tiberiu.a.breana@intel.com>
    Acked-by: Hartmut Knaack <knaack.h@gmx.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
index fee4297d7c8f..c1a218236be5 100644
--- a/drivers/iio/light/stk3310.c
+++ b/drivers/iio/light/stk3310.c
@@ -43,7 +43,6 @@
 #define STK3311_CHIP_ID_VAL			0x1D
 #define STK3310_PSINT_EN			0x01
 #define STK3310_PS_MAX_VAL			0xFFFF
-#define STK3310_THRESH_MAX			0xFFFF
 
 #define STK3310_DRIVER_NAME			"stk3310"
 #define STK3310_REGMAP_NAME			"stk3310_regmap"
@@ -84,15 +83,13 @@ static const struct reg_field stk3310_reg_field_flag_psint =
 				REG_FIELD(STK3310_REG_FLAG, 4, 4);
 static const struct reg_field stk3310_reg_field_flag_nf =
 				REG_FIELD(STK3310_REG_FLAG, 0, 0);
-/*
- * Maximum PS values with regard to scale. Used to export the 'inverse'
- * PS value (high values for far objects, low values for near objects).
- */
+
+/* Estimate maximum proximity values with regard to measurement scale. */
 static const int stk3310_ps_max[4] = {
-	STK3310_PS_MAX_VAL / 64,
-	STK3310_PS_MAX_VAL / 16,
-	STK3310_PS_MAX_VAL /  4,
-	STK3310_PS_MAX_VAL,
+	STK3310_PS_MAX_VAL / 640,
+	STK3310_PS_MAX_VAL / 160,
+	STK3310_PS_MAX_VAL /  40,
+	STK3310_PS_MAX_VAL /  10
 };
 
 static const int stk3310_scale_table[][2] = {
@@ -128,14 +125,14 @@ static const struct iio_event_spec stk3310_events[] = {
 	/* Proximity event */
 	{
 		.type = IIO_EV_TYPE_THRESH,
-		.dir = IIO_EV_DIR_FALLING,
+		.dir = IIO_EV_DIR_RISING,
 		.mask_separate = BIT(IIO_EV_INFO_VALUE) |
 				 BIT(IIO_EV_INFO_ENABLE),
 	},
 	/* Out-of-proximity event */
 	{
 		.type = IIO_EV_TYPE_THRESH,
-		.dir = IIO_EV_DIR_RISING,
+		.dir = IIO_EV_DIR_FALLING,
 		.mask_separate = BIT(IIO_EV_INFO_VALUE) |
 				 BIT(IIO_EV_INFO_ENABLE),
 	},
@@ -205,23 +202,16 @@ static int stk3310_read_event(struct iio_dev *indio_dev,
 	u8 reg;
 	u16 buf;
 	int ret;
-	unsigned int index;
 	struct stk3310_data *data = iio_priv(indio_dev);
 
 	if (info != IIO_EV_INFO_VALUE)
 		return -EINVAL;
 
-	/*
-	 * Only proximity interrupts are implemented at the moment.
-	 * Since we're inverting proximity values, the sensor's 'high'
-	 * threshold will become our 'low' threshold, associated with
-	 * 'near' events. Similarly, the sensor's 'low' threshold will
-	 * be our 'high' threshold, associated with 'far' events.
-	 */
+	/* Only proximity interrupts are implemented at the moment. */
 	if (dir == IIO_EV_DIR_RISING)
-		reg = STK3310_REG_THDL_PS;
-	else if (dir == IIO_EV_DIR_FALLING)
 		reg = STK3310_REG_THDH_PS;
+	else if (dir == IIO_EV_DIR_FALLING)
+		reg = STK3310_REG_THDL_PS;
 	else
 		return -EINVAL;
 
@@ -232,8 +222,7 @@ static int stk3310_read_event(struct iio_dev *indio_dev,
 		dev_err(&data->client->dev, "register read failed\n");
 		return ret;
 	}
-	regmap_field_read(data->reg_ps_gain, &index);
-	*val = swab16(stk3310_ps_max[index] - buf);
+	*val = swab16(buf);
 
 	return IIO_VAL_INT;
 }
@@ -257,13 +246,13 @@ static int stk3310_write_event(struct iio_dev *indio_dev,
 		return -EINVAL;
 
 	if (dir == IIO_EV_DIR_RISING)
-		reg = STK3310_REG_THDL_PS;
-	else if (dir == IIO_EV_DIR_FALLING)
 		reg = STK3310_REG_THDH_PS;
+	else if (dir == IIO_EV_DIR_FALLING)
+		reg = STK3310_REG_THDL_PS;
 	else
 		return -EINVAL;
 
-	buf = swab16(stk3310_ps_max[index] - val);
+	buf = swab16(val);
 	ret = regmap_bulk_write(data->regmap, reg, &buf, 2);
 	if (ret < 0)
 		dev_err(&client->dev, "failed to set PS threshold!\n");
@@ -334,14 +323,6 @@ static int stk3310_read_raw(struct iio_dev *indio_dev,
 			return ret;
 		}
 		*val = swab16(buf);
-		if (chan->type == IIO_PROXIMITY) {
-			/*
-			 * Invert the proximity data so we return low values
-			 * for close objects and high values for far ones.
-			 */
-			regmap_field_read(data->reg_ps_gain, &index);
-			*val = stk3310_ps_max[index] - *val;
-		}
 		mutex_unlock(&data->lock);
 		return IIO_VAL_INT;
 	case IIO_CHAN_INFO_INT_TIME:
@@ -581,8 +562,8 @@ static irqreturn_t stk3310_irq_event_handler(int irq, void *private)
 	}
 	event = IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 1,
 				     IIO_EV_TYPE_THRESH,
-				     (dir ? IIO_EV_DIR_RISING :
-					    IIO_EV_DIR_FALLING));
+				     (dir ? IIO_EV_DIR_FALLING :
+					    IIO_EV_DIR_RISING));
 	iio_push_event(indio_dev, event, data->timestamp);
 
 	/* Reset the interrupt flag */

commit 7d4eb6f2110d9a9f9fe8d39eabddadbd35eb12b2
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Fri Jun 12 09:04:55 2015 +0200

    iio: light: stk3310: use flags argument of devm_gpiod_get
    
    Since 39b2bbe3d715 (gpio: add flags argument to gpiod_get*() functions)
    which appeared in v3.17-rc1, the gpiod_get* functions take an additional
    parameter that allows to specify direction and initial value for output.
    
    Simplify driver accordingly. Furthermore this is one caller less that
    stops us making the flags argument to gpiod_get*() mandatory.
    
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>

diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
index fee4297d7c8f..84c77d42a2c6 100644
--- a/drivers/iio/light/stk3310.c
+++ b/drivers/iio/light/stk3310.c
@@ -488,16 +488,12 @@ static int stk3310_gpio_probe(struct i2c_client *client)
 	dev = &client->dev;
 
 	/* gpio interrupt pin */
-	gpio = devm_gpiod_get_index(dev, STK3310_GPIO, 0);
+	gpio = devm_gpiod_get_index(dev, STK3310_GPIO, 0, GPIOD_IN);
 	if (IS_ERR(gpio)) {
 		dev_err(dev, "acpi gpio get index failed\n");
 		return PTR_ERR(gpio);
 	}
 
-	ret = gpiod_direction_input(gpio);
-	if (ret)
-		return ret;
-
 	ret = gpiod_to_irq(gpio);
 	dev_dbg(dev, "GPIO resource, no:%d irq:%d\n", desc_to_gpio(gpio), ret);
 

commit ed6e75c7dc5627c7251002936577052ae73ac2db
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed May 27 11:24:25 2015 +0300

    iio: light: signedness bug in stk3310_write_raw()
    
    "index" needs to be signed for the error handling to work.
    
    Fixes: be9e6229d676 ('iio: light: Add support for Sensortek STK3310')
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
index e79b9d89b024..fee4297d7c8f 100644
--- a/drivers/iio/light/stk3310.c
+++ b/drivers/iio/light/stk3310.c
@@ -370,7 +370,7 @@ static int stk3310_write_raw(struct iio_dev *indio_dev,
 			     int val, int val2, long mask)
 {
 	int ret;
-	unsigned int index;
+	int index;
 	struct stk3310_data *data = iio_priv(indio_dev);
 
 	switch (mask) {

commit 3dd477acbdd1f147f432a742afc5521168341461
Author: Tiberiu Breana <tiberiu.a.breana@intel.com>
Date:   Mon Apr 27 18:34:01 2015 +0300

    iio: light: Add threshold interrupt support for STK3310
    
    Added interrupt support for proximity threshold events
    to the stk3310 driver.
    
    Signed-off-by: Tiberiu Breana <tiberiu.a.breana@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
index 0f8c450fc4a2..e79b9d89b024 100644
--- a/drivers/iio/light/stk3310.c
+++ b/drivers/iio/light/stk3310.c
@@ -12,15 +12,22 @@
 
 #include <linux/acpi.h>
 #include <linux/i2c.h>
+#include <linux/interrupt.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/regmap.h>
+#include <linux/gpio/consumer.h>
+#include <linux/iio/events.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/sysfs.h>
 
 #define STK3310_REG_STATE			0x00
 #define STK3310_REG_PSCTRL			0x01
 #define STK3310_REG_ALSCTRL			0x02
+#define STK3310_REG_INT				0x04
+#define STK3310_REG_THDH_PS			0x06
+#define STK3310_REG_THDL_PS			0x08
+#define STK3310_REG_FLAG			0x10
 #define STK3310_REG_PS_DATA_MSB			0x11
 #define STK3310_REG_PS_DATA_LSB			0x12
 #define STK3310_REG_ALS_DATA_MSB		0x13
@@ -34,10 +41,14 @@
 
 #define STK3310_CHIP_ID_VAL			0x13
 #define STK3311_CHIP_ID_VAL			0x1D
+#define STK3310_PSINT_EN			0x01
 #define STK3310_PS_MAX_VAL			0xFFFF
+#define STK3310_THRESH_MAX			0xFFFF
 
 #define STK3310_DRIVER_NAME			"stk3310"
 #define STK3310_REGMAP_NAME			"stk3310_regmap"
+#define STK3310_EVENT				"stk3310_event"
+#define STK3310_GPIO				"stk3310_gpio"
 
 #define STK3310_SCALE_AVAILABLE			"6.4 1.6 0.4 0.1"
 
@@ -67,7 +78,12 @@ static const struct reg_field stk3310_reg_field_als_it =
 				REG_FIELD(STK3310_REG_ALSCTRL, 0, 3);
 static const struct reg_field stk3310_reg_field_ps_it =
 				REG_FIELD(STK3310_REG_PSCTRL, 0, 3);
-
+static const struct reg_field stk3310_reg_field_int_ps =
+				REG_FIELD(STK3310_REG_INT, 0, 2);
+static const struct reg_field stk3310_reg_field_flag_psint =
+				REG_FIELD(STK3310_REG_FLAG, 4, 4);
+static const struct reg_field stk3310_reg_field_flag_nf =
+				REG_FIELD(STK3310_REG_FLAG, 0, 0);
 /*
  * Maximum PS values with regard to scale. Used to export the 'inverse'
  * PS value (high values for far objects, low values for near objects).
@@ -96,12 +112,33 @@ struct stk3310_data {
 	struct mutex lock;
 	bool als_enabled;
 	bool ps_enabled;
+	u64 timestamp;
 	struct regmap *regmap;
 	struct regmap_field *reg_state;
 	struct regmap_field *reg_als_gain;
 	struct regmap_field *reg_ps_gain;
 	struct regmap_field *reg_als_it;
 	struct regmap_field *reg_ps_it;
+	struct regmap_field *reg_int_ps;
+	struct regmap_field *reg_flag_psint;
+	struct regmap_field *reg_flag_nf;
+};
+
+static const struct iio_event_spec stk3310_events[] = {
+	/* Proximity event */
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_FALLING,
+		.mask_separate = BIT(IIO_EV_INFO_VALUE) |
+				 BIT(IIO_EV_INFO_ENABLE),
+	},
+	/* Out-of-proximity event */
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_RISING,
+		.mask_separate = BIT(IIO_EV_INFO_VALUE) |
+				 BIT(IIO_EV_INFO_ENABLE),
+	},
 };
 
 static const struct iio_chan_spec stk3310_channels[] = {
@@ -118,6 +155,8 @@ static const struct iio_chan_spec stk3310_channels[] = {
 			BIT(IIO_CHAN_INFO_RAW) |
 			BIT(IIO_CHAN_INFO_SCALE) |
 			BIT(IIO_CHAN_INFO_INT_TIME),
+		.event_spec = stk3310_events,
+		.num_event_specs = ARRAY_SIZE(stk3310_events),
 	}
 };
 
@@ -156,6 +195,118 @@ static int stk3310_get_index(const int table[][2], int table_size,
 	return -EINVAL;
 }
 
+static int stk3310_read_event(struct iio_dev *indio_dev,
+			      const struct iio_chan_spec *chan,
+			      enum iio_event_type type,
+			      enum iio_event_direction dir,
+			      enum iio_event_info info,
+			      int *val, int *val2)
+{
+	u8 reg;
+	u16 buf;
+	int ret;
+	unsigned int index;
+	struct stk3310_data *data = iio_priv(indio_dev);
+
+	if (info != IIO_EV_INFO_VALUE)
+		return -EINVAL;
+
+	/*
+	 * Only proximity interrupts are implemented at the moment.
+	 * Since we're inverting proximity values, the sensor's 'high'
+	 * threshold will become our 'low' threshold, associated with
+	 * 'near' events. Similarly, the sensor's 'low' threshold will
+	 * be our 'high' threshold, associated with 'far' events.
+	 */
+	if (dir == IIO_EV_DIR_RISING)
+		reg = STK3310_REG_THDL_PS;
+	else if (dir == IIO_EV_DIR_FALLING)
+		reg = STK3310_REG_THDH_PS;
+	else
+		return -EINVAL;
+
+	mutex_lock(&data->lock);
+	ret = regmap_bulk_read(data->regmap, reg, &buf, 2);
+	mutex_unlock(&data->lock);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "register read failed\n");
+		return ret;
+	}
+	regmap_field_read(data->reg_ps_gain, &index);
+	*val = swab16(stk3310_ps_max[index] - buf);
+
+	return IIO_VAL_INT;
+}
+
+static int stk3310_write_event(struct iio_dev *indio_dev,
+			       const struct iio_chan_spec *chan,
+			       enum iio_event_type type,
+			       enum iio_event_direction dir,
+			       enum iio_event_info info,
+			       int val, int val2)
+{
+	u8 reg;
+	u16 buf;
+	int ret;
+	unsigned int index;
+	struct stk3310_data *data = iio_priv(indio_dev);
+	struct i2c_client *client = data->client;
+
+	regmap_field_read(data->reg_ps_gain, &index);
+	if (val > stk3310_ps_max[index])
+		return -EINVAL;
+
+	if (dir == IIO_EV_DIR_RISING)
+		reg = STK3310_REG_THDL_PS;
+	else if (dir == IIO_EV_DIR_FALLING)
+		reg = STK3310_REG_THDH_PS;
+	else
+		return -EINVAL;
+
+	buf = swab16(stk3310_ps_max[index] - val);
+	ret = regmap_bulk_write(data->regmap, reg, &buf, 2);
+	if (ret < 0)
+		dev_err(&client->dev, "failed to set PS threshold!\n");
+
+	return ret;
+}
+
+static int stk3310_read_event_config(struct iio_dev *indio_dev,
+				     const struct iio_chan_spec *chan,
+				     enum iio_event_type type,
+				     enum iio_event_direction dir)
+{
+	unsigned int event_val;
+	struct stk3310_data *data = iio_priv(indio_dev);
+
+	regmap_field_read(data->reg_int_ps, &event_val);
+
+	return event_val;
+}
+
+static int stk3310_write_event_config(struct iio_dev *indio_dev,
+				      const struct iio_chan_spec *chan,
+				      enum iio_event_type type,
+				      enum iio_event_direction dir,
+				      int state)
+{
+	int ret;
+	struct stk3310_data *data = iio_priv(indio_dev);
+	struct i2c_client *client = data->client;
+
+	if (state < 0 || state > 7)
+		return -EINVAL;
+
+	/* Set INT_PS value */
+	mutex_lock(&data->lock);
+	ret = regmap_field_write(data->reg_int_ps, state);
+	if (ret < 0)
+		dev_err(&client->dev, "failed to set interrupt mode\n");
+	mutex_unlock(&data->lock);
+
+	return ret;
+}
+
 static int stk3310_read_raw(struct iio_dev *indio_dev,
 			    struct iio_chan_spec const *chan,
 			    int *val, int *val2, long mask)
@@ -266,6 +417,10 @@ static const struct iio_info stk3310_info = {
 	.read_raw		= stk3310_read_raw,
 	.write_raw		= stk3310_write_raw,
 	.attrs			= &stk3310_attribute_group,
+	.read_event_value	= stk3310_read_event,
+	.write_event_value	= stk3310_write_event,
+	.read_event_config	= stk3310_read_event_config,
+	.write_event_config	= stk3310_write_event_config,
 };
 
 static int stk3310_set_state(struct stk3310_data *data, u8 state)
@@ -308,8 +463,43 @@ static int stk3310_init(struct iio_dev *indio_dev)
 
 	state = STK3310_STATE_EN_ALS | STK3310_STATE_EN_PS;
 	ret = stk3310_set_state(data, state);
-	if (ret < 0)
+	if (ret < 0) {
 		dev_err(&client->dev, "failed to enable sensor");
+		return ret;
+	}
+
+	/* Enable PS interrupts */
+	ret = regmap_field_write(data->reg_int_ps, STK3310_PSINT_EN);
+	if (ret < 0)
+		dev_err(&client->dev, "failed to enable interrupts!\n");
+
+	return ret;
+}
+
+static int stk3310_gpio_probe(struct i2c_client *client)
+{
+	struct device *dev;
+	struct gpio_desc *gpio;
+	int ret;
+
+	if (!client)
+		return -EINVAL;
+
+	dev = &client->dev;
+
+	/* gpio interrupt pin */
+	gpio = devm_gpiod_get_index(dev, STK3310_GPIO, 0);
+	if (IS_ERR(gpio)) {
+		dev_err(dev, "acpi gpio get index failed\n");
+		return PTR_ERR(gpio);
+	}
+
+	ret = gpiod_direction_input(gpio);
+	if (ret)
+		return ret;
+
+	ret = gpiod_to_irq(gpio);
+	dev_dbg(dev, "GPIO resource, no:%d irq:%d\n", desc_to_gpio(gpio), ret);
 
 	return ret;
 }
@@ -321,6 +511,7 @@ static bool stk3310_is_volatile_reg(struct device *dev, unsigned int reg)
 	case STK3310_REG_ALS_DATA_LSB:
 	case STK3310_REG_PS_DATA_LSB:
 	case STK3310_REG_PS_DATA_MSB:
+	case STK3310_REG_FLAG:
 		return true;
 	default:
 		return false;
@@ -354,10 +545,55 @@ static int stk3310_regmap_init(struct stk3310_data *data)
 	STK3310_REGFIELD(ps_gain);
 	STK3310_REGFIELD(als_it);
 	STK3310_REGFIELD(ps_it);
+	STK3310_REGFIELD(int_ps);
+	STK3310_REGFIELD(flag_psint);
+	STK3310_REGFIELD(flag_nf);
 
 	return 0;
 }
 
+static irqreturn_t stk3310_irq_handler(int irq, void *private)
+{
+	struct iio_dev *indio_dev = private;
+	struct stk3310_data *data = iio_priv(indio_dev);
+
+	data->timestamp = iio_get_time_ns();
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t stk3310_irq_event_handler(int irq, void *private)
+{
+	int ret;
+	unsigned int dir;
+	u64 event;
+
+	struct iio_dev *indio_dev = private;
+	struct stk3310_data *data = iio_priv(indio_dev);
+
+	/* Read FLAG_NF to figure out what threshold has been met. */
+	mutex_lock(&data->lock);
+	ret = regmap_field_read(data->reg_flag_nf, &dir);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "register read failed\n");
+		mutex_unlock(&data->lock);
+		return ret;
+	}
+	event = IIO_UNMOD_EVENT_CODE(IIO_PROXIMITY, 1,
+				     IIO_EV_TYPE_THRESH,
+				     (dir ? IIO_EV_DIR_RISING :
+					    IIO_EV_DIR_FALLING));
+	iio_push_event(indio_dev, event, data->timestamp);
+
+	/* Reset the interrupt flag */
+	ret = regmap_field_write(data->reg_flag_psint, 0);
+	if (ret < 0)
+		dev_err(&data->client->dev, "failed to reset interrupts\n");
+	mutex_unlock(&data->lock);
+
+	return IRQ_HANDLED;
+}
+
 static int stk3310_probe(struct i2c_client *client,
 			 const struct i2c_device_id *id)
 {
@@ -397,6 +633,21 @@ static int stk3310_probe(struct i2c_client *client,
 		stk3310_set_state(data, STK3310_STATE_STANDBY);
 	}
 
+	if (client->irq <= 0)
+		client->irq = stk3310_gpio_probe(client);
+
+	if (client->irq >= 0) {
+		ret = devm_request_threaded_irq(&client->dev, client->irq,
+						stk3310_irq_handler,
+						stk3310_irq_event_handler,
+						IRQF_TRIGGER_FALLING |
+						IRQF_ONESHOT,
+						STK3310_EVENT, indio_dev);
+		if (ret < 0)
+			dev_err(&client->dev, "request irq %d failed\n",
+					client->irq);
+	}
+
 	return ret;
 }
 

commit be9e6229d67696f94c2f2331a2e207beff9bfc7f
Author: Tiberiu Breana <tiberiu.a.breana@intel.com>
Date:   Mon Apr 27 18:34:00 2015 +0300

    iio: light: Add support for Sensortek STK3310
    
    Minimal implementation of an IIO driver for the Sensortek
    STK3310 ambient light and proximity sensor. The STK3311
    model is also supported.
    
    Includes:
    - ACPI support;
    - read_raw and write_raw;
    - reading and setting configuration parameters for gain/scale
      and integration time for both ALS and PS.
    - power management
    
    Signed-off-by: Tiberiu Breana <tiberiu.a.breana@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/light/stk3310.c b/drivers/iio/light/stk3310.c
new file mode 100644
index 000000000000..0f8c450fc4a2
--- /dev/null
+++ b/drivers/iio/light/stk3310.c
@@ -0,0 +1,471 @@
+/**
+ * Sensortek STK3310/STK3311 Ambient Light and Proximity Sensor
+ *
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This file is subject to the terms and conditions of version 2 of
+ * the GNU General Public License. See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ * IIO driver for STK3310/STK3311. 7-bit I2C address: 0x48.
+ */
+
+#include <linux/acpi.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+
+#define STK3310_REG_STATE			0x00
+#define STK3310_REG_PSCTRL			0x01
+#define STK3310_REG_ALSCTRL			0x02
+#define STK3310_REG_PS_DATA_MSB			0x11
+#define STK3310_REG_PS_DATA_LSB			0x12
+#define STK3310_REG_ALS_DATA_MSB		0x13
+#define STK3310_REG_ALS_DATA_LSB		0x14
+#define STK3310_REG_ID				0x3E
+#define STK3310_MAX_REG				0x80
+
+#define STK3310_STATE_EN_PS			0x01
+#define STK3310_STATE_EN_ALS			0x02
+#define STK3310_STATE_STANDBY			0x00
+
+#define STK3310_CHIP_ID_VAL			0x13
+#define STK3311_CHIP_ID_VAL			0x1D
+#define STK3310_PS_MAX_VAL			0xFFFF
+
+#define STK3310_DRIVER_NAME			"stk3310"
+#define STK3310_REGMAP_NAME			"stk3310_regmap"
+
+#define STK3310_SCALE_AVAILABLE			"6.4 1.6 0.4 0.1"
+
+#define STK3310_IT_AVAILABLE \
+	"0.000185 0.000370 0.000741 0.001480 0.002960 0.005920 0.011840 " \
+	"0.023680 0.047360 0.094720 0.189440 0.378880 0.757760 1.515520 " \
+	"3.031040 6.062080"
+
+#define STK3310_REGFIELD(name)						    \
+	do {								    \
+		data->reg_##name =					    \
+			devm_regmap_field_alloc(&client->dev, regmap,	    \
+				stk3310_reg_field_##name);		    \
+		if (IS_ERR(data->reg_##name)) {				    \
+			dev_err(&client->dev, "reg field alloc failed.\n"); \
+			return PTR_ERR(data->reg_##name);		    \
+		}							    \
+	} while (0)
+
+static const struct reg_field stk3310_reg_field_state =
+				REG_FIELD(STK3310_REG_STATE, 0, 2);
+static const struct reg_field stk3310_reg_field_als_gain =
+				REG_FIELD(STK3310_REG_ALSCTRL, 4, 5);
+static const struct reg_field stk3310_reg_field_ps_gain =
+				REG_FIELD(STK3310_REG_PSCTRL, 4, 5);
+static const struct reg_field stk3310_reg_field_als_it =
+				REG_FIELD(STK3310_REG_ALSCTRL, 0, 3);
+static const struct reg_field stk3310_reg_field_ps_it =
+				REG_FIELD(STK3310_REG_PSCTRL, 0, 3);
+
+/*
+ * Maximum PS values with regard to scale. Used to export the 'inverse'
+ * PS value (high values for far objects, low values for near objects).
+ */
+static const int stk3310_ps_max[4] = {
+	STK3310_PS_MAX_VAL / 64,
+	STK3310_PS_MAX_VAL / 16,
+	STK3310_PS_MAX_VAL /  4,
+	STK3310_PS_MAX_VAL,
+};
+
+static const int stk3310_scale_table[][2] = {
+	{6, 400000}, {1, 600000}, {0, 400000}, {0, 100000}
+};
+
+/* Integration time in seconds, microseconds */
+static const int stk3310_it_table[][2] = {
+	{0, 185},	{0, 370},	{0, 741},	{0, 1480},
+	{0, 2960},	{0, 5920},	{0, 11840},	{0, 23680},
+	{0, 47360},	{0, 94720},	{0, 189440},	{0, 378880},
+	{0, 757760},	{1, 515520},	{3, 31040},	{6, 62080},
+};
+
+struct stk3310_data {
+	struct i2c_client *client;
+	struct mutex lock;
+	bool als_enabled;
+	bool ps_enabled;
+	struct regmap *regmap;
+	struct regmap_field *reg_state;
+	struct regmap_field *reg_als_gain;
+	struct regmap_field *reg_ps_gain;
+	struct regmap_field *reg_als_it;
+	struct regmap_field *reg_ps_it;
+};
+
+static const struct iio_chan_spec stk3310_channels[] = {
+	{
+		.type = IIO_LIGHT,
+		.info_mask_separate =
+			BIT(IIO_CHAN_INFO_RAW) |
+			BIT(IIO_CHAN_INFO_SCALE) |
+			BIT(IIO_CHAN_INFO_INT_TIME),
+	},
+	{
+		.type = IIO_PROXIMITY,
+		.info_mask_separate =
+			BIT(IIO_CHAN_INFO_RAW) |
+			BIT(IIO_CHAN_INFO_SCALE) |
+			BIT(IIO_CHAN_INFO_INT_TIME),
+	}
+};
+
+static IIO_CONST_ATTR(in_illuminance_scale_available, STK3310_SCALE_AVAILABLE);
+
+static IIO_CONST_ATTR(in_proximity_scale_available, STK3310_SCALE_AVAILABLE);
+
+static IIO_CONST_ATTR(in_illuminance_integration_time_available,
+		      STK3310_IT_AVAILABLE);
+
+static IIO_CONST_ATTR(in_proximity_integration_time_available,
+		      STK3310_IT_AVAILABLE);
+
+static struct attribute *stk3310_attributes[] = {
+	&iio_const_attr_in_illuminance_scale_available.dev_attr.attr,
+	&iio_const_attr_in_proximity_scale_available.dev_attr.attr,
+	&iio_const_attr_in_illuminance_integration_time_available.dev_attr.attr,
+	&iio_const_attr_in_proximity_integration_time_available.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group stk3310_attribute_group = {
+	.attrs = stk3310_attributes
+};
+
+static int stk3310_get_index(const int table[][2], int table_size,
+			     int val, int val2)
+{
+	int i;
+
+	for (i = 0; i < table_size; i++) {
+		if (val == table[i][0] && val2 == table[i][1])
+			return i;
+	}
+
+	return -EINVAL;
+}
+
+static int stk3310_read_raw(struct iio_dev *indio_dev,
+			    struct iio_chan_spec const *chan,
+			    int *val, int *val2, long mask)
+{
+	u8 reg;
+	u16 buf;
+	int ret;
+	unsigned int index;
+	struct stk3310_data *data = iio_priv(indio_dev);
+	struct i2c_client *client = data->client;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		if (chan->type == IIO_LIGHT)
+			reg = STK3310_REG_ALS_DATA_MSB;
+		else if (chan->type == IIO_PROXIMITY)
+			reg = STK3310_REG_PS_DATA_MSB;
+		else
+			return -EINVAL;
+		mutex_lock(&data->lock);
+		ret = regmap_bulk_read(data->regmap, reg, &buf, 2);
+		if (ret < 0) {
+			dev_err(&client->dev, "register read failed\n");
+			mutex_unlock(&data->lock);
+			return ret;
+		}
+		*val = swab16(buf);
+		if (chan->type == IIO_PROXIMITY) {
+			/*
+			 * Invert the proximity data so we return low values
+			 * for close objects and high values for far ones.
+			 */
+			regmap_field_read(data->reg_ps_gain, &index);
+			*val = stk3310_ps_max[index] - *val;
+		}
+		mutex_unlock(&data->lock);
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_INT_TIME:
+		if (chan->type == IIO_LIGHT)
+			regmap_field_read(data->reg_als_it, &index);
+		else
+			regmap_field_read(data->reg_ps_it, &index);
+		*val = stk3310_it_table[index][0];
+		*val2 = stk3310_it_table[index][1];
+		return IIO_VAL_INT_PLUS_MICRO;
+	case IIO_CHAN_INFO_SCALE:
+		if (chan->type == IIO_LIGHT)
+			regmap_field_read(data->reg_als_gain, &index);
+		else
+			regmap_field_read(data->reg_ps_gain, &index);
+		*val = stk3310_scale_table[index][0];
+		*val2 = stk3310_scale_table[index][1];
+		return IIO_VAL_INT_PLUS_MICRO;
+	}
+
+	return -EINVAL;
+}
+
+static int stk3310_write_raw(struct iio_dev *indio_dev,
+			     struct iio_chan_spec const *chan,
+			     int val, int val2, long mask)
+{
+	int ret;
+	unsigned int index;
+	struct stk3310_data *data = iio_priv(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_INT_TIME:
+		index = stk3310_get_index(stk3310_it_table,
+					  ARRAY_SIZE(stk3310_it_table),
+					  val, val2);
+		if (index < 0)
+			return -EINVAL;
+		mutex_lock(&data->lock);
+		if (chan->type == IIO_LIGHT)
+			ret = regmap_field_write(data->reg_als_it, index);
+		else
+			ret = regmap_field_write(data->reg_ps_it, index);
+		if (ret < 0)
+			dev_err(&data->client->dev,
+					"sensor configuration failed\n");
+		mutex_unlock(&data->lock);
+		return ret;
+
+	case IIO_CHAN_INFO_SCALE:
+		index = stk3310_get_index(stk3310_scale_table,
+					  ARRAY_SIZE(stk3310_scale_table),
+					  val, val2);
+		if (index < 0)
+			return -EINVAL;
+		mutex_lock(&data->lock);
+		if (chan->type == IIO_LIGHT)
+			ret = regmap_field_write(data->reg_als_gain, index);
+		else
+			ret = regmap_field_write(data->reg_ps_gain, index);
+		if (ret < 0)
+			dev_err(&data->client->dev,
+					"sensor configuration failed\n");
+		mutex_unlock(&data->lock);
+		return ret;
+	}
+
+	return -EINVAL;
+}
+
+static const struct iio_info stk3310_info = {
+	.driver_module		= THIS_MODULE,
+	.read_raw		= stk3310_read_raw,
+	.write_raw		= stk3310_write_raw,
+	.attrs			= &stk3310_attribute_group,
+};
+
+static int stk3310_set_state(struct stk3310_data *data, u8 state)
+{
+	int ret;
+	struct i2c_client *client = data->client;
+
+	/* 3-bit state; 0b100 is not supported. */
+	if (state > 7 || state == 4)
+		return -EINVAL;
+
+	mutex_lock(&data->lock);
+	ret = regmap_field_write(data->reg_state, state);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to change sensor state\n");
+	} else if (state != STK3310_STATE_STANDBY) {
+		/* Don't reset the 'enabled' flags if we're going in standby */
+		data->ps_enabled  = !!(state & 0x01);
+		data->als_enabled = !!(state & 0x02);
+	}
+	mutex_unlock(&data->lock);
+
+	return ret;
+}
+
+static int stk3310_init(struct iio_dev *indio_dev)
+{
+	int ret;
+	int chipid;
+	u8 state;
+	struct stk3310_data *data = iio_priv(indio_dev);
+	struct i2c_client *client = data->client;
+
+	regmap_read(data->regmap, STK3310_REG_ID, &chipid);
+	if (chipid != STK3310_CHIP_ID_VAL &&
+	    chipid != STK3311_CHIP_ID_VAL) {
+		dev_err(&client->dev, "invalid chip id: 0x%x\n", chipid);
+		return -ENODEV;
+	}
+
+	state = STK3310_STATE_EN_ALS | STK3310_STATE_EN_PS;
+	ret = stk3310_set_state(data, state);
+	if (ret < 0)
+		dev_err(&client->dev, "failed to enable sensor");
+
+	return ret;
+}
+
+static bool stk3310_is_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case STK3310_REG_ALS_DATA_MSB:
+	case STK3310_REG_ALS_DATA_LSB:
+	case STK3310_REG_PS_DATA_LSB:
+	case STK3310_REG_PS_DATA_MSB:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static struct regmap_config stk3310_regmap_config = {
+	.name = STK3310_REGMAP_NAME,
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = STK3310_MAX_REG,
+	.cache_type = REGCACHE_RBTREE,
+	.volatile_reg = stk3310_is_volatile_reg,
+};
+
+static int stk3310_regmap_init(struct stk3310_data *data)
+{
+	struct regmap *regmap;
+	struct i2c_client *client;
+
+	client = data->client;
+	regmap = devm_regmap_init_i2c(client, &stk3310_regmap_config);
+	if (IS_ERR(regmap)) {
+		dev_err(&client->dev, "regmap initialization failed.\n");
+		return PTR_ERR(regmap);
+	}
+	data->regmap = regmap;
+
+	STK3310_REGFIELD(state);
+	STK3310_REGFIELD(als_gain);
+	STK3310_REGFIELD(ps_gain);
+	STK3310_REGFIELD(als_it);
+	STK3310_REGFIELD(ps_it);
+
+	return 0;
+}
+
+static int stk3310_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	int ret;
+	struct iio_dev *indio_dev;
+	struct stk3310_data *data;
+
+	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));
+	if (!indio_dev) {
+		dev_err(&client->dev, "iio allocation failed!\n");
+		return -ENOMEM;
+	}
+
+	data = iio_priv(indio_dev);
+	data->client = client;
+	i2c_set_clientdata(client, indio_dev);
+	mutex_init(&data->lock);
+
+	ret = stk3310_regmap_init(data);
+	if (ret < 0)
+		return ret;
+
+	indio_dev->dev.parent = &client->dev;
+	indio_dev->info = &stk3310_info;
+	indio_dev->name = STK3310_DRIVER_NAME;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->channels = stk3310_channels;
+	indio_dev->num_channels = ARRAY_SIZE(stk3310_channels);
+
+	ret = stk3310_init(indio_dev);
+	if (ret < 0)
+		return ret;
+
+	ret = iio_device_register(indio_dev);
+	if (ret < 0) {
+		dev_err(&client->dev, "device_register failed\n");
+		stk3310_set_state(data, STK3310_STATE_STANDBY);
+	}
+
+	return ret;
+}
+
+static int stk3310_remove(struct i2c_client *client)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(client);
+
+	iio_device_unregister(indio_dev);
+	return stk3310_set_state(iio_priv(indio_dev), STK3310_STATE_STANDBY);
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int stk3310_suspend(struct device *dev)
+{
+	struct stk3310_data *data;
+
+	data = iio_priv(i2c_get_clientdata(to_i2c_client(dev)));
+
+	return stk3310_set_state(data, STK3310_STATE_STANDBY);
+}
+
+static int stk3310_resume(struct device *dev)
+{
+	int state = 0;
+	struct stk3310_data *data;
+
+	data = iio_priv(i2c_get_clientdata(to_i2c_client(dev)));
+	if (data->ps_enabled)
+		state |= STK3310_STATE_EN_PS;
+	if (data->als_enabled)
+		state |= STK3310_STATE_EN_ALS;
+
+	return stk3310_set_state(data, state);
+}
+
+static SIMPLE_DEV_PM_OPS(stk3310_pm_ops, stk3310_suspend, stk3310_resume);
+
+#define STK3310_PM_OPS (&stk3310_pm_ops)
+#else
+#define STK3310_PM_OPS NULL
+#endif
+
+static const struct i2c_device_id stk3310_i2c_id[] = {
+	{"STK3310", 0},
+	{"STK3311", 0},
+	{}
+};
+
+static const struct acpi_device_id stk3310_acpi_id[] = {
+	{"STK3310", 0},
+	{"STK3311", 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(acpi, stk3310_acpi_id);
+
+static struct i2c_driver stk3310_driver = {
+	.driver = {
+		.name = "stk3310",
+		.pm = STK3310_PM_OPS,
+		.acpi_match_table = ACPI_PTR(stk3310_acpi_id),
+	},
+	.probe =            stk3310_probe,
+	.remove =           stk3310_remove,
+	.id_table =         stk3310_i2c_id,
+};
+
+module_i2c_driver(stk3310_driver);
+
+MODULE_AUTHOR("Tiberiu Breana <tiberiu.a.breana@intel.com>");
+MODULE_DESCRIPTION("STK3310 Ambient Light and Proximity Sensor driver");
+MODULE_LICENSE("GPL v2");
