commit 06c482605b13626e3ca3e5adf48611ebf0e883d1
Author: Jonathan Cameron <Jonathan.Cameron@huawei.com>
Date:   Sun Apr 5 19:03:20 2020 +0100

    iio:magn:mmc35240: Drop unnecessary casts of val parameter in regmap_bulk*
    
    Given the parameter is void *, casting to u8 * is unnecessary.
    
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Cc: Daniel Baluta <daniel.baluta@gmail.com>
    Reviewed-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
index 425cdd07b4e5..1787d656d009 100644
--- a/drivers/iio/magnetometer/mmc35240.c
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -239,7 +239,7 @@ static int mmc35240_init(struct mmc35240_data *data)
 		return ret;
 
 	ret = regmap_bulk_read(data->regmap, MMC35240_OTP_START_ADDR,
-			       (u8 *)otp_data, sizeof(otp_data));
+			       otp_data, sizeof(otp_data));
 	if (ret < 0)
 		return ret;
 
@@ -295,7 +295,7 @@ static int mmc35240_read_measurement(struct mmc35240_data *data, __le16 buf[3])
 	if (ret < 0)
 		return ret;
 
-	return regmap_bulk_read(data->regmap, MMC35240_REG_XOUT_L, (u8 *)buf,
+	return regmap_bulk_read(data->regmap, MMC35240_REG_XOUT_L, buf,
 				3 * sizeof(__le16));
 }
 

commit 3f2cde742632226a86b54b2f8ed9cf5c4f50638c
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Sun Jul 21 23:35:33 2019 +0200

    iio: magnetometer: mmc35240: Fix a typo in the name of a constant
    
    Everything is about mmc35240_ except MMC53240_WAIT_SET_RESET (3 and 5
    switched).
    
    This is likely a typo. Define and use MMC35240_WAIT_SET_RESET instead.
    
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
index 7de10281ad9e..425cdd07b4e5 100644
--- a/drivers/iio/magnetometer/mmc35240.c
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -53,7 +53,7 @@
 #define MMC35240_CTRL1_BW_SHIFT		0
 
 #define MMC35240_WAIT_CHARGE_PUMP	50000	/* us */
-#define MMC53240_WAIT_SET_RESET		1000	/* us */
+#define MMC35240_WAIT_SET_RESET		1000	/* us */
 
 /*
  * Memsic OTP process code piece is put here for reference:
@@ -225,7 +225,7 @@ static int mmc35240_init(struct mmc35240_data *data)
 	ret = mmc35240_hw_set(data, true);
 	if (ret < 0)
 		return ret;
-	usleep_range(MMC53240_WAIT_SET_RESET, MMC53240_WAIT_SET_RESET + 1);
+	usleep_range(MMC35240_WAIT_SET_RESET, MMC35240_WAIT_SET_RESET + 1);
 
 	ret = mmc35240_hw_set(data, false);
 	if (ret < 0)

commit 36edc93958e06dfc15b61d1cfa7f33929bc26fe4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:44 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 330
    
    Based on 1 normalized pattern(s):
    
      this file is subject to the terms and conditions of version 2 of the
      gnu general public license see the file copying in the main
      directory of this archive for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 55 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.108941081@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
index 6b640c6338c9..7de10281ad9e 100644
--- a/drivers/iio/magnetometer/mmc35240.c
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * MMC35240 - MEMSIC 3-axis Magnetic Sensor
  *
  * Copyright (c) 2015, Intel Corporation.
  *
- * This file is subject to the terms and conditions of version 2 of
- * the GNU General Public License.  See the file COPYING in the main
- * directory of this archive for more details.
- *
  * IIO driver for MMC35240 (7-bit I2C slave address 0x30).
  *
  * TODO: offset, ACPI, continuous measurement mode, PM

commit 7f307262af08e842297561ef7afd3cce248b258a
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sun Jul 23 17:26:01 2017 +0100

    iio:magnetometer: drop assign iio_info.driver_module and iio_trigger_ops.owner
    
    The equivalent of both of these are now done via macro magic when
    the relevant register calls are made.  The actual structure
    elements will shortly go away.
    
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
index 176e14a61558..6b640c6338c9 100644
--- a/drivers/iio/magnetometer/mmc35240.c
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -418,7 +418,6 @@ static int mmc35240_write_raw(struct iio_dev *indio_dev,
 }
 
 static const struct iio_info mmc35240_info = {
-	.driver_module	= THIS_MODULE,
 	.read_raw	= mmc35240_read_raw,
 	.write_raw	= mmc35240_write_raw,
 	.attrs		= &mmc35240_attribute_group,

commit 1c46ae0af6df0bbde66c5e868563be57f18a27b4
Merge: a73e99cb67e7 41d903c00051
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Aug 12 12:43:41 2015 -0700

    Merge tag 'iio-for-4.3b-2' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-next
    
    Jonathan writes:
    
    Second set of new device support, features and cleanup for the 4.3 cycle.
    Take 2 also includes a fix set that was too late for the 4.2 cycle.
    
    As we had a lot of tools and docs work in this set, I have broken those
    out into their own categories in this description.
    
    Fixes from the pull request '4th set of IIO fixes for the 4.2 cycle'.
    * Poll functions for both event chardev and the buffer one were returning
      negative error codes (via a positive value).
    * A recent change to lsiio adding some error handling that was wrong and
      stopped the tool working.
    * bmg160 was missing some dependencies in Kconfig
    * berlin2-adc had a misshandled register (wrote a value rather than a bitmap)
    
    New device support
    * TI opt3001 light sensor
    * TXC PA12 ALS and proximity sensor.
    * mcp3301 ADC support (in mcp320x driver)
    * ST lsm303agr accelerometer and magnetometer drivers (plus some st-sensors
      common support to allow different WHOAMI register addresses, devices with
      fixed scale and allow interrupt equiped magnetometers).
    * ADIS16305, ADIS16367, ADIS16445IMUs (in the adis16400 driver)
    * ADIS16266 gyro (in the adis16260 driver)
    * ADIS16137 gyro (in the adis16136 driver)
    
    New functionality
    * mmc35240 DT bindings.
    * Inverse unit conversion macros to aid handing of values written to sysfs
      attributes.
    
    Core cleanup
    * Forward declaration of struct iio_trigger to avoid a compile warning.
    
    Driver cleanup / fixes
    * mxs-lradc
      - Clarify which parts are supported.
      - Fix spelling erorrs.
      - Missing/extra includes
      - reorder includes
      - add datasheet name listings for all usable channels (to allow them
        to be bound by name from consumer drivers)
    * acpi-als - add some function prefixes as per general iio style.
    * bmc150_magn - replace a magic value with the existing define.
    * vf610 - determine possible sample frequencies taking into account the
      electrical characteristics (defining a minimum sample time)
    * dht11
      - whitespace
      - additional docs
      - avoid mulitple assignments in one line
      - Use the new funciton ktime_get_resolution_ns to cleanup a nasty trick
        previously used for timing.
    * Fix all drivers that consider 0 a valid IRQ for historical reasons.
    * Export I2C module alias info where previously missing (to allow autoprobing)
    * Export OF module alias info where previously missing.
    * mmc35240 - switch some variables into arrays to improve readability.
    * mlx90614 - define some magic numbers for readability.
    * bmc150_magn
      - expand area locked by a mutex to cover all the use of the
        data->buffer.
      - use descriptive naming for a mask instead of a magic value.
    * berin2-adc
      - pass up an error code rather that a generic error
      - constify the iio_chan_spec
      - some other little tidy ups.
    * stk8312
      - fix a dependency on triggered buffers in kconfig
      - add a check for invalid attribute values
      - improve error handling by returning error codes where possible and
        return immediately where relevant
      - rework macro defs to use GENMASK etc
      - change some variable types to reduce unnecessary casting
      - clean up code style
      - drop a local buffer copy for bulk reads and use the one in data->buffer
         instead.
    * adis16400 - the adis16448 gyroscope scale was wrong.
    * adis16480 - some more wrong scales for various parts.
    * adis16300 - has an undocumented product id and serial number registers so
      use them.
    * iio_simple_dummy - fix some wrong code indentation.
    * bmc150-accel - use the chip ID to detect the chip present rather than
      verifying the expected part was there.  This was in response to a wrong
      ACPI entry on the WinBook TW100.
    * mma8452
      - fix _get_hp_filter_index
      - drop a double include
      - pass up an error code rather than rewriting it
      - range check input values to attribute writes
      - register defs tidy up using GENMASK and reordering them to be easier to
        follow.
      - various coding style cleanups
      - put the Kconfig entry in the write place (alphabetically).
    
    Tools related
    * Tools cleanup - drop an explicity NULL comparison, some unnecessary braces,
      use the ARRAY_SIZE macro, send error messages to stderr instead of dropping
      them in the middle of normal output.
    * Fix tools to allow that scale and offset attributes are optional.
    * More tools fixes including allowing true 32bit data (previously an overflow
      prevented more than 31bits)
    * Drop a stray header guard that ended up in a c file.
    * Make calc_digits static as it isn't exported or in the header.
    * Set ci_array pointer to NULL after free as a protection against non safe
      usage of the tools core code.  Also convert a double pointer to a single
      one as the extra level of indirection was unnecessary.
    
    Docs
    * DocBook introduction by Daniel Baluta.  Glad we are beginning to
      draw together some more introductory docs to suplement the various
      tools / examples.
    * Drop bytes_per_datum sysfs attribute docs as it no longer exists.
    * A whole load of missing / fixing of kernel-doc for the core of IIO.
    * Document the trigger name sysfs attribute in the ABI docs.
    * Minor typos in the ABI docs related to power down modes.

commit 9e35d366a1e8bd710fbebcf9af90d3fafbc55e36
Author: Teodora Baluta <teodora.baluta@intel.com>
Date:   Fri Jul 31 17:27:24 2015 +0300

    iio: mmc35240: minor change to improve code readibility
    
    This patch changes two variables to arrays to improve code readibility.
    
    Signed-off-by: Teodora Baluta <teodora.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
index 9bc542daa732..fa4ccd070e56 100644
--- a/drivers/iio/magnetometer/mmc35240.c
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -308,31 +308,31 @@ static int mmc35240_read_measurement(struct mmc35240_data *data, __le16 buf[3])
 static int mmc35240_raw_to_mgauss(struct mmc35240_data *data, int index,
 				  __le16 buf[], int *val)
 {
-	int raw_x, raw_y, raw_z;
-	int sens_x, sens_y, sens_z;
+	int raw[3];
+	int sens[3];
 	int nfo;
 
-	raw_x = le16_to_cpu(buf[AXIS_X]);
-	raw_y = le16_to_cpu(buf[AXIS_Y]);
-	raw_z = le16_to_cpu(buf[AXIS_Z]);
+	raw[AXIS_X] = le16_to_cpu(buf[AXIS_X]);
+	raw[AXIS_Y] = le16_to_cpu(buf[AXIS_Y]);
+	raw[AXIS_Z] = le16_to_cpu(buf[AXIS_Z]);
 
-	sens_x = mmc35240_props_table[data->res].sens[AXIS_X];
-	sens_y = mmc35240_props_table[data->res].sens[AXIS_Y];
-	sens_z = mmc35240_props_table[data->res].sens[AXIS_Z];
+	sens[AXIS_X] = mmc35240_props_table[data->res].sens[AXIS_X];
+	sens[AXIS_Y] = mmc35240_props_table[data->res].sens[AXIS_Y];
+	sens[AXIS_Z] = mmc35240_props_table[data->res].sens[AXIS_Z];
 
 	nfo = mmc35240_props_table[data->res].nfo;
 
 	switch (index) {
 	case AXIS_X:
-		*val = (raw_x - nfo) * 1000 / sens_x;
+		*val = (raw[AXIS_X] - nfo) * 1000 / sens[AXIS_X];
 		break;
 	case AXIS_Y:
-		*val = (raw_y - nfo) * 1000 / sens_y -
-			(raw_z - nfo)  * 1000 / sens_z;
+		*val = (raw[AXIS_Y] - nfo) * 1000 / sens[AXIS_Y] -
+			(raw[AXIS_Z] - nfo)  * 1000 / sens[AXIS_Z];
 		break;
 	case AXIS_Z:
-		*val = (raw_y - nfo) * 1000 / sens_y +
-			(raw_z - nfo) * 1000 / sens_z;
+		*val = (raw[AXIS_Y] - nfo) * 1000 / sens[AXIS_Y] +
+			(raw[AXIS_Z] - nfo) * 1000 / sens[AXIS_Z];
 		break;
 	default:
 		return -EINVAL;

commit 354c879dbd9393ac411049f968474f2bf6c2a495
Author: Viorel Suman <viorel.suman@intel.com>
Date:   Tue Jul 14 17:56:54 2015 +0300

    iio: magnetometer: mmc35240: fix SET/RESET sequence
    
    The RESET operation invoked in the last instance will align
    in the natural way all 3 axis and the chip top view.
    
    Without this, north and south are swapped.
    
    Signed-off-by: Viorel Suman <viorel.suman@intel.com>
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
index e9dfa0e26826..706ebfd6297f 100644
--- a/drivers/iio/magnetometer/mmc35240.c
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -222,14 +222,15 @@ static int mmc35240_init(struct mmc35240_data *data)
 
 	/*
 	 * make sure we restore sensor characteristics, by doing
-	 * a RESET/SET sequence
+	 * a SET/RESET sequence, the axis polarity being naturally
+	 * aligned after RESET
 	 */
-	ret = mmc35240_hw_set(data, false);
+	ret = mmc35240_hw_set(data, true);
 	if (ret < 0)
 		return ret;
 	usleep_range(MMC53240_WAIT_SET_RESET, MMC53240_WAIT_SET_RESET + 1);
 
-	ret = mmc35240_hw_set(data, true);
+	ret = mmc35240_hw_set(data, false);
 	if (ret < 0)
 		return ret;
 

commit 3ceaa2c207ccf6933affc8358c0a04beb93e9aa7
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Tue Jul 14 17:56:53 2015 +0300

    iio: magnetometer: mmc35240: Fix SET/RESET mask
    
    This fixes setting the SET/RESET bit in the REG_CTRL0
    register.
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
index 36a4b53e618b..e9dfa0e26826 100644
--- a/drivers/iio/magnetometer/mmc35240.c
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -202,8 +202,8 @@ static int mmc35240_hw_set(struct mmc35240_data *data, bool set)
 		coil_bit = MMC35240_CTRL0_RESET_BIT;
 
 	return regmap_update_bits(data->regmap, MMC35240_REG_CTRL0,
-				  MMC35240_CTRL0_REFILL_BIT,
-				  coil_bit);
+				  coil_bit, coil_bit);
+
 }
 
 static int mmc35240_init(struct mmc35240_data *data)

commit 8b14821a5c45e3472082c60723ca54cf2fe9c2f3
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Tue Jul 14 17:56:52 2015 +0300

    iio: magnetometer: mmc35240: Fix crash in pm suspend
    
    We must set i2c client private data at probe in order to
    correctly retrieve it in pm suspend/resume, preventing
    the following crash:
    
    [ 321.790582] PM: Syncing filesystems ... done.
    [ 322.364440] PM: Preparing system for mem sleep
    [ 322.400047] PM: Entering mem sleep
    [ 322.462178] BUG: unable to handle kernel NULL pointer dereference at 0000036c
    [ 322.469119] IP: [<80e0b3d2>] mmc35240_suspend+0x12/0x30
    [ 322.474291] *pdpt = 000000002fd6f001 *pde = 0000000000000000
    [ 322.479967] Oops: 0000 1 PREEMPT SMP
    [ 322.496516] task: a86d0df0 ti: a8766000 task.ti: a8766000
    [ 322.570744] Call Trace:
    [ 322.573217] [<80c0d2d1>] pm_generic_suspend+0x21/0x30
    [ 322.578284] [<80d042ab>] i2c_device_pm_suspend+0x1b/0x30
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
index d927397a6ef7..36a4b53e618b 100644
--- a/drivers/iio/magnetometer/mmc35240.c
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -503,6 +503,7 @@ static int mmc35240_probe(struct i2c_client *client,
 	}
 
 	data = iio_priv(indio_dev);
+	i2c_set_clientdata(client, indio_dev);
 	data->client = client;
 	data->regmap = regmap;
 	data->res = MMC35240_16_BITS_SLOW;

commit c99389ad3d80eeef0d0980a17e07f41822bda687
Author: Teodora Baluta <teodora.baluta@intel.com>
Date:   Mon Jun 29 15:44:50 2015 +0300

    iio: magnetometer: mmc35240: fix available sampling frequencies
    
    Fix the sampling frequencies according to the datasheet (page 8). The
    datasheet specifies the following available frequencies for continuous
    mode: 1.5 Hz, 13 Hz, 25 Hz, and 50 Hz.
    
    Also fix comments about the ODR to comply with datasheet.
    
    Signed-off-by: Teodora Baluta <teodora.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
index 7a2ea71c659a..d927397a6ef7 100644
--- a/drivers/iio/magnetometer/mmc35240.c
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -84,10 +84,10 @@
 #define MMC35240_OTP_START_ADDR		0x1B
 
 enum mmc35240_resolution {
-	MMC35240_16_BITS_SLOW = 0, /* 100 Hz */
-	MMC35240_16_BITS_FAST,     /* 200 Hz */
-	MMC35240_14_BITS,          /* 333 Hz */
-	MMC35240_12_BITS,          /* 666 Hz */
+	MMC35240_16_BITS_SLOW = 0, /* 7.92 ms */
+	MMC35240_16_BITS_FAST,     /* 4.08 ms */
+	MMC35240_14_BITS,          /* 2.16 ms */
+	MMC35240_12_BITS,          /* 1.20 ms */
 };
 
 enum mmc35240_axis {
@@ -100,22 +100,22 @@ static const struct {
 	int sens[3]; /* sensitivity per X, Y, Z axis */
 	int nfo; /* null field output */
 } mmc35240_props_table[] = {
-	/* 16 bits, 100Hz ODR */
+	/* 16 bits, 125Hz ODR */
 	{
 		{1024, 1024, 1024},
 		32768,
 	},
-	/* 16 bits, 200Hz ODR */
+	/* 16 bits, 250Hz ODR */
 	{
 		{1024, 1024, 770},
 		32768,
 	},
-	/* 14 bits, 333Hz ODR */
+	/* 14 bits, 450Hz ODR */
 	{
 		{256, 256, 193},
 		8192,
 	},
-	/* 12 bits, 666Hz ODR */
+	/* 12 bits, 800Hz ODR */
 	{
 		{64, 64, 48},
 		2048,
@@ -133,9 +133,15 @@ struct mmc35240_data {
 	int axis_scale[3];
 };
 
-static const int mmc35240_samp_freq[] = {100, 200, 333, 666};
+static const struct {
+	int val;
+	int val2;
+} mmc35240_samp_freq[] = { {1, 500000},
+			   {13, 0},
+			   {25, 0},
+			   {50, 0} };
 
-static IIO_CONST_ATTR_SAMP_FREQ_AVAIL("100 200 333 666");
+static IIO_CONST_ATTR_SAMP_FREQ_AVAIL("1.5 13 25 50");
 
 #define MMC35240_CHANNEL(_axis) { \
 	.type = IIO_MAGN, \
@@ -168,7 +174,8 @@ static int mmc35240_get_samp_freq_index(struct mmc35240_data *data,
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(mmc35240_samp_freq); i++)
-		if (mmc35240_samp_freq[i] == val)
+		if (mmc35240_samp_freq[i].val == val &&
+		    mmc35240_samp_freq[i].val2 == val2)
 			return i;
 	return -EINVAL;
 }
@@ -378,9 +385,9 @@ static int mmc35240_read_raw(struct iio_dev *indio_dev,
 		if (i < 0 || i >= ARRAY_SIZE(mmc35240_samp_freq))
 			return -EINVAL;
 
-		*val = mmc35240_samp_freq[i];
-		*val2 = 0;
-		return IIO_VAL_INT;
+		*val = mmc35240_samp_freq[i].val;
+		*val2 = mmc35240_samp_freq[i].val2;
+		return IIO_VAL_INT_PLUS_MICRO;
 	default:
 		return -EINVAL;
 	}

commit 7dbf1ea8aade8c3b2759acc96e5e709016e6ae28
Author: Jandy Gou <qingsong.gou@ck-telecom.com>
Date:   Fri Jul 17 16:34:35 2015 +0800

    iio: magnetometer: mmc35240: Add DT binding
    
    Signed-off-by: Jandy Gou <qingsong.gou@ck-telecom.com>
    Acked-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
index 7a2ea71c659a..9bc542daa732 100644
--- a/drivers/iio/magnetometer/mmc35240.c
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -550,6 +550,12 @@ static const struct dev_pm_ops mmc35240_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(mmc35240_suspend, mmc35240_resume)
 };
 
+static const struct of_device_id mmc35240_of_match[] = {
+	{ .compatible = "memsic,mmc35240", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, mmc35240_of_match);
+
 static const struct acpi_device_id mmc35240_acpi_match[] = {
 	{"MMC35240", 0},
 	{ },
@@ -565,6 +571,7 @@ MODULE_DEVICE_TABLE(i2c, mmc35240_id);
 static struct i2c_driver mmc35240_driver = {
 	.driver = {
 		.name = MMC35240_DRV_NAME,
+		.of_match_table = mmc35240_of_match,
 		.pm = &mmc35240_pm_ops,
 		.acpi_match_table = ACPI_PTR(mmc35240_acpi_match),
 	},

commit 4892688d7004c004765a51976087a8f51ce3586d
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Fri Jun 5 14:03:15 2015 +0300

    iio: magnetometer: mmc35240: Add compensation for raw values
    
    This patch adds compensation formula to raw readings, borrowed
    from Memsic's input driver.
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
index b2ab58ea15f0..7a2ea71c659a 100644
--- a/drivers/iio/magnetometer/mmc35240.c
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -58,6 +58,31 @@
 #define MMC35240_WAIT_CHARGE_PUMP	50000	/* us */
 #define MMC53240_WAIT_SET_RESET		1000	/* us */
 
+/*
+ * Memsic OTP process code piece is put here for reference:
+ *
+ * #define OTP_CONVERT(REG)  ((float)((REG) >=32 ? (32 - (REG)) : (REG)) * 0.006
+ * 1) For X axis, the COEFFICIENT is always 1.
+ * 2) For Y axis, the COEFFICIENT is as below:
+ *    f_OTP_matrix[4] = OTP_CONVERT(((reg_data[1] & 0x03) << 4) |
+ *                                   (reg_data[2] >> 4)) + 1.0;
+ * 3) For Z axis, the COEFFICIENT is as below:
+ *    f_OTP_matrix[8] = (OTP_CONVERT(reg_data[3] & 0x3f) + 1) * 1.35;
+ * We implemented the OTP logic into driver.
+ */
+
+/* scale = 1000 here for Y otp */
+#define MMC35240_OTP_CONVERT_Y(REG) (((REG) >= 32 ? (32 - (REG)) : (REG)) * 6)
+
+/* 0.6 * 1.35 = 0.81, scale 10000 for Z otp */
+#define MMC35240_OTP_CONVERT_Z(REG) (((REG) >= 32 ? (32 - (REG)) : (REG)) * 81)
+
+#define MMC35240_X_COEFF(x)	(x)
+#define MMC35240_Y_COEFF(y)	(y + 1000)
+#define MMC35240_Z_COEFF(z)	(z + 13500)
+
+#define MMC35240_OTP_START_ADDR		0x1B
+
 enum mmc35240_resolution {
 	MMC35240_16_BITS_SLOW = 0, /* 100 Hz */
 	MMC35240_16_BITS_FAST,     /* 200 Hz */
@@ -102,6 +127,10 @@ struct mmc35240_data {
 	struct mutex mutex;
 	struct regmap *regmap;
 	enum mmc35240_resolution res;
+
+	/* OTP compensation */
+	int axis_coef[3];
+	int axis_scale[3];
 };
 
 static const int mmc35240_samp_freq[] = {100, 200, 333, 666};
@@ -172,8 +201,9 @@ static int mmc35240_hw_set(struct mmc35240_data *data, bool set)
 
 static int mmc35240_init(struct mmc35240_data *data)
 {
-	int ret;
+	int ret, y_convert, z_convert;
 	unsigned int reg_id;
+	u8 otp_data[6];
 
 	ret = regmap_read(data->regmap, MMC35240_REG_ID, &reg_id);
 	if (ret < 0) {
@@ -197,9 +227,30 @@ static int mmc35240_init(struct mmc35240_data *data)
 		return ret;
 
 	/* set default sampling frequency */
-	return regmap_update_bits(data->regmap, MMC35240_REG_CTRL1,
-				  MMC35240_CTRL1_BW_MASK,
-				  data->res << MMC35240_CTRL1_BW_SHIFT);
+	ret = regmap_update_bits(data->regmap, MMC35240_REG_CTRL1,
+				 MMC35240_CTRL1_BW_MASK,
+				 data->res << MMC35240_CTRL1_BW_SHIFT);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_bulk_read(data->regmap, MMC35240_OTP_START_ADDR,
+			       (u8 *)otp_data, sizeof(otp_data));
+	if (ret < 0)
+		return ret;
+
+	y_convert = MMC35240_OTP_CONVERT_Y(((otp_data[1] & 0x03) << 4) |
+					   (otp_data[2] >> 4));
+	z_convert = MMC35240_OTP_CONVERT_Z(otp_data[3] & 0x3f);
+
+	data->axis_coef[0] = MMC35240_X_COEFF(1);
+	data->axis_coef[1] = MMC35240_Y_COEFF(y_convert);
+	data->axis_coef[2] = MMC35240_Z_COEFF(z_convert);
+
+	data->axis_scale[0] = 1;
+	data->axis_scale[1] = 1000;
+	data->axis_scale[2] = 10000;
+
+	return 0;
 }
 
 static int mmc35240_take_measurement(struct mmc35240_data *data)
@@ -286,6 +337,9 @@ static int mmc35240_raw_to_mgauss(struct mmc35240_data *data, int index,
 	default:
 		return -EINVAL;
 	}
+	/* apply OTP compensation */
+	*val = (*val) * data->axis_coef[index] / data->axis_scale[index];
+
 	return 0;
 }
 

commit 6b90da4b58b39a80f490479953aa2563c3c41a6d
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Fri Jun 5 14:03:14 2015 +0300

    iio: magnetometer: mmc35240: Fix sensitivity on z-axis
    
    Datasheet says (Page 2) that typical value for sensitivity
    for 16 bits mode on Z-axis is 770. Anyhow, looking at the
    input driver provided by Memsic the value for MMC35240 is
    1024.
    
    Also, testing shows that using 1024 for Z-axis senzitivity
    offers better results.
    
    Fixes: abeb6b1e7b ("iio: magnetometer: Add support for MEMSIC MMC35240")
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
index 7fdf906b94c9..b2ab58ea15f0 100644
--- a/drivers/iio/magnetometer/mmc35240.c
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -77,7 +77,7 @@ static const struct {
 } mmc35240_props_table[] = {
 	/* 16 bits, 100Hz ODR */
 	{
-		{1024, 1024, 770},
+		{1024, 1024, 1024},
 		32768,
 	},
 	/* 16 bits, 200Hz ODR */

commit 787f55c4d1842e5fb037a81bca9bd9d9fdfd46fe
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Fri Jun 5 14:03:13 2015 +0300

    iio: magnetometer: mmc35240: Use a smaller sleep value
    
    According to datasheet, Page 8, minimum wait time to complete
    measurement is 10ms. Adjusting this value will increase the
    userspace polling rate.
    
    Fixes: abeb6b1e7b ("iio: magnetometer: Add support for MEMSIC MMC35240")
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
index 146ae6613537..7fdf906b94c9 100644
--- a/drivers/iio/magnetometer/mmc35240.c
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -219,7 +219,8 @@ static int mmc35240_take_measurement(struct mmc35240_data *data)
 			return ret;
 		if (reg_status & MMC35240_STATUS_MEAS_DONE_BIT)
 			break;
-		msleep(20);
+		/* minimum wait time to complete measurement is 10 ms */
+		usleep_range(10000, 11000);
 	}
 
 	if (tries < 0) {

commit c2890547a035e019df646be5d56adc0ee1b0a327
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Fri Jun 5 14:03:12 2015 +0300

    iio: magnetometer: mmc35240: Fix broken processed value
    
    The current computation for fractional part of the magnetic
    field is broken. This patch fixes it by taking a different
    approach. We expose the raw reading in milli Gauss (to avoid
    rounding errors) with a scale of 0.001.
    
    Thus the final computation is done in userspace where floating
    point operation are more relaxed.
    
    Fixes: abeb6b1e7b ("iio: magnetometer: Add support for MEMSIC MMC35240")
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
index 78da0d15c8eb..146ae6613537 100644
--- a/drivers/iio/magnetometer/mmc35240.c
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -113,8 +113,9 @@ static IIO_CONST_ATTR_SAMP_FREQ_AVAIL("100 200 333 666");
 	.modified = 1, \
 	.channel2 = IIO_MOD_ ## _axis, \
 	.address = AXIS_ ## _axis, \
-	.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED), \
-	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SAMP_FREQ), \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \
+	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \
+			BIT(IIO_CHAN_INFO_SCALE), \
 }
 
 static const struct iio_chan_spec mmc35240_channels[] = {
@@ -241,9 +242,19 @@ static int mmc35240_read_measurement(struct mmc35240_data *data, __le16 buf[3])
 				3 * sizeof(__le16));
 }
 
-static int mmc35240_raw_to_gauss(struct mmc35240_data *data, int index,
-				 __le16 buf[],
-				 int *val, int *val2)
+/**
+ * mmc35240_raw_to_mgauss - convert raw readings to milli gauss. Also apply
+			    compensation for output value.
+ *
+ * @data: device private data
+ * @index: axis index for which we want the conversion
+ * @buf: raw data to be converted, 2 bytes in little endian format
+ * @val: compensated output reading (unit is milli gauss)
+ *
+ * Returns: 0 in case of success, -EINVAL when @index is not valid
+ */
+static int mmc35240_raw_to_mgauss(struct mmc35240_data *data, int index,
+				  __le16 buf[], int *val)
 {
 	int raw_x, raw_y, raw_z;
 	int sens_x, sens_y, sens_z;
@@ -261,18 +272,15 @@ static int mmc35240_raw_to_gauss(struct mmc35240_data *data, int index,
 
 	switch (index) {
 	case AXIS_X:
-		*val = (raw_x - nfo) / sens_x;
-		*val2 = ((raw_x - nfo) % sens_x) * 1000000;
+		*val = (raw_x - nfo) * 1000 / sens_x;
 		break;
 	case AXIS_Y:
-		*val = (raw_y - nfo) / sens_y - (raw_z - nfo) / sens_z;
-		*val2 = (((raw_y - nfo) % sens_y - (raw_z - nfo) % sens_z))
-			* 1000000;
+		*val = (raw_y - nfo) * 1000 / sens_y -
+			(raw_z - nfo)  * 1000 / sens_z;
 		break;
 	case AXIS_Z:
-		*val = (raw_y - nfo) / sens_y + (raw_z - nfo) / sens_z;
-		*val2 = (((raw_y - nfo) % sens_y + (raw_z - nfo) % sens_z))
-			* 1000000;
+		*val = (raw_y - nfo) * 1000 / sens_y +
+			(raw_z - nfo) * 1000 / sens_z;
 		break;
 	default:
 		return -EINVAL;
@@ -290,16 +298,19 @@ static int mmc35240_read_raw(struct iio_dev *indio_dev,
 	__le16 buf[3];
 
 	switch (mask) {
-	case IIO_CHAN_INFO_PROCESSED:
+	case IIO_CHAN_INFO_RAW:
 		mutex_lock(&data->mutex);
 		ret = mmc35240_read_measurement(data, buf);
 		mutex_unlock(&data->mutex);
 		if (ret < 0)
 			return ret;
-		ret = mmc35240_raw_to_gauss(data, chan->address,
-					    buf, val, val2);
+		ret = mmc35240_raw_to_mgauss(data, chan->address, buf, val);
 		if (ret < 0)
 			return ret;
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		*val = 0;
+		*val2 = 1000;
 		return IIO_VAL_INT_PLUS_MICRO;
 	case IIO_CHAN_INFO_SAMP_FREQ:
 		mutex_lock(&data->mutex);

commit bd35a214f56158d11e46c4a9d8436139f58e7099
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Fri Jun 5 14:03:11 2015 +0300

    iio: magnetometer: mmc35240: NULL terminate attribute array
    
    This avoid nasty crashes when registering the IIO device.
    
    Fixes: abeb6b1e7b ("iio: magnetometer: Add support for MEMSIC MMC35240")
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
index d8cf5a6f9291..78da0d15c8eb 100644
--- a/drivers/iio/magnetometer/mmc35240.c
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -125,6 +125,7 @@ static const struct iio_chan_spec mmc35240_channels[] = {
 
 static struct attribute *mmc35240_attributes[] = {
 	&iio_const_attr_sampling_frequency_available.dev_attr.attr,
+	NULL
 };
 
 static const struct attribute_group mmc35240_attribute_group = {

commit a52ffebcf19afea27588abe75828f9d300e08f3d
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Fri Jun 5 14:03:10 2015 +0300

    iio: magnetometer: mmc35240: i2c device name should be lower case
    
    This is the standard convention for i2c device name and
    also this is the name used in some Intel platforms DT
    files.
    
    Fixes: abeb6b1e7b ("iio: magnetometer: Add support for MEMSIC MMC35240")
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
index c71392cf1370..d8cf5a6f9291 100644
--- a/drivers/iio/magnetometer/mmc35240.c
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -490,7 +490,7 @@ static const struct acpi_device_id mmc35240_acpi_match[] = {
 MODULE_DEVICE_TABLE(acpi, mmc35240_acpi_match);
 
 static const struct i2c_device_id mmc35240_id[] = {
-	{"MMC35240", 0},
+	{"mmc35240", 0},
 	{}
 };
 MODULE_DEVICE_TABLE(i2c, mmc35240_id);

commit 5517547bf44731621338c1a4047196a49c790719
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed May 27 11:20:52 2015 +0300

    iio: magnetometer: correct a harmless off by one check
    
    The line before limits i to 0-3 so the existing code works fine but the
    check is still off by one and >= is intended instead of >.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
index aa6e25d3bfc3..c71392cf1370 100644
--- a/drivers/iio/magnetometer/mmc35240.c
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -308,7 +308,7 @@ static int mmc35240_read_raw(struct iio_dev *indio_dev,
 			return ret;
 
 		i = (reg & MMC35240_CTRL1_BW_MASK) >> MMC35240_CTRL1_BW_SHIFT;
-		if (i < 0 || i > ARRAY_SIZE(mmc35240_samp_freq))
+		if (i < 0 || i >= ARRAY_SIZE(mmc35240_samp_freq))
 			return -EINVAL;
 
 		*val = mmc35240_samp_freq[i];

commit d11715f087e0c0608de8ec030ca260892e8b8739
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Fri Apr 24 18:58:32 2015 +0300

    iio: magnetometer: Add ACPI support for MMC35240
    
    We assume that ACPI device tables use MMC35240 to
    identify MEMSIC's 3 axis magnetic sensor.
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
index 0c7d64c41575..aa6e25d3bfc3 100644
--- a/drivers/iio/magnetometer/mmc35240.c
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -17,6 +17,7 @@
 #include <linux/i2c.h>
 #include <linux/delay.h>
 #include <linux/regmap.h>
+#include <linux/acpi.h>
 #include <linux/pm.h>
 
 #include <linux/iio/iio.h>
@@ -482,6 +483,12 @@ static const struct dev_pm_ops mmc35240_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(mmc35240_suspend, mmc35240_resume)
 };
 
+static const struct acpi_device_id mmc35240_acpi_match[] = {
+	{"MMC35240", 0},
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, mmc35240_acpi_match);
+
 static const struct i2c_device_id mmc35240_id[] = {
 	{"MMC35240", 0},
 	{}
@@ -492,6 +499,7 @@ static struct i2c_driver mmc35240_driver = {
 	.driver = {
 		.name = MMC35240_DRV_NAME,
 		.pm = &mmc35240_pm_ops,
+		.acpi_match_table = ACPI_PTR(mmc35240_acpi_match),
 	},
 	.probe		= mmc35240_probe,
 	.id_table	= mmc35240_id,

commit 553a776b790816161cd334647eae2093fd126e36
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Fri Apr 24 18:58:31 2015 +0300

    iio: magnetometer: mmc35240: Add PM sleep support
    
    We rely on regmap to save the state of the registers at suspend,
    and then we do an explicit sync at resume.
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
index 46728006bbdb..0c7d64c41575 100644
--- a/drivers/iio/magnetometer/mmc35240.c
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -17,6 +17,7 @@
 #include <linux/i2c.h>
 #include <linux/delay.h>
 #include <linux/regmap.h>
+#include <linux/pm.h>
 
 #include <linux/iio/iio.h>
 #include <linux/iio/sysfs.h>
@@ -448,6 +449,39 @@ static int mmc35240_probe(struct i2c_client *client,
 	return devm_iio_device_register(&client->dev, indio_dev);
 }
 
+#ifdef CONFIG_PM_SLEEP
+static int mmc35240_suspend(struct device *dev)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
+	struct mmc35240_data *data = iio_priv(indio_dev);
+
+	regcache_cache_only(data->regmap, true);
+
+	return 0;
+}
+
+static int mmc35240_resume(struct device *dev)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));
+	struct mmc35240_data *data = iio_priv(indio_dev);
+	int ret;
+
+	regcache_mark_dirty(data->regmap);
+	ret = regcache_sync_region(data->regmap, MMC35240_REG_CTRL0,
+				   MMC35240_REG_CTRL1);
+	if (ret < 0)
+		dev_err(dev, "Failed to restore control registers\n");
+
+	regcache_cache_only(data->regmap, false);
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops mmc35240_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(mmc35240_suspend, mmc35240_resume)
+};
+
 static const struct i2c_device_id mmc35240_id[] = {
 	{"MMC35240", 0},
 	{}
@@ -457,6 +491,7 @@ MODULE_DEVICE_TABLE(i2c, mmc35240_id);
 static struct i2c_driver mmc35240_driver = {
 	.driver = {
 		.name = MMC35240_DRV_NAME,
+		.pm = &mmc35240_pm_ops,
 	},
 	.probe		= mmc35240_probe,
 	.id_table	= mmc35240_id,

commit abeb6b1e7bbffb3dbcd918827673feafecc378d1
Author: Daniel Baluta <daniel.baluta@intel.com>
Date:   Fri Apr 24 18:58:30 2015 +0300

    iio: magnetometer: Add support for MEMSIC MMC35240 sensor
    
    Minimal implementation for MMC35240 3-axis magnetometer
    sensor. It provides processed readings and possiblity to change
    the sampling frequency.
    
    Signed-off-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/mmc35240.c b/drivers/iio/magnetometer/mmc35240.c
new file mode 100644
index 000000000000..46728006bbdb
--- /dev/null
+++ b/drivers/iio/magnetometer/mmc35240.c
@@ -0,0 +1,469 @@
+/*
+ * MMC35240 - MEMSIC 3-axis Magnetic Sensor
+ *
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This file is subject to the terms and conditions of version 2 of
+ * the GNU General Public License.  See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ * IIO driver for MMC35240 (7-bit I2C slave address 0x30).
+ *
+ * TODO: offset, ACPI, continuous measurement mode, PM
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/regmap.h>
+
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+
+#define MMC35240_DRV_NAME "mmc35240"
+#define MMC35240_REGMAP_NAME "mmc35240_regmap"
+
+#define MMC35240_REG_XOUT_L	0x00
+#define MMC35240_REG_XOUT_H	0x01
+#define MMC35240_REG_YOUT_L	0x02
+#define MMC35240_REG_YOUT_H	0x03
+#define MMC35240_REG_ZOUT_L	0x04
+#define MMC35240_REG_ZOUT_H	0x05
+
+#define MMC35240_REG_STATUS	0x06
+#define MMC35240_REG_CTRL0	0x07
+#define MMC35240_REG_CTRL1	0x08
+
+#define MMC35240_REG_ID		0x20
+
+#define MMC35240_STATUS_MEAS_DONE_BIT	BIT(0)
+
+#define MMC35240_CTRL0_REFILL_BIT	BIT(7)
+#define MMC35240_CTRL0_RESET_BIT	BIT(6)
+#define MMC35240_CTRL0_SET_BIT		BIT(5)
+#define MMC35240_CTRL0_CMM_BIT		BIT(1)
+#define MMC35240_CTRL0_TM_BIT		BIT(0)
+
+/* output resolution bits */
+#define MMC35240_CTRL1_BW0_BIT		BIT(0)
+#define MMC35240_CTRL1_BW1_BIT		BIT(1)
+
+#define MMC35240_CTRL1_BW_MASK	 (MMC35240_CTRL1_BW0_BIT | \
+		 MMC35240_CTRL1_BW1_BIT)
+#define MMC35240_CTRL1_BW_SHIFT		0
+
+#define MMC35240_WAIT_CHARGE_PUMP	50000	/* us */
+#define MMC53240_WAIT_SET_RESET		1000	/* us */
+
+enum mmc35240_resolution {
+	MMC35240_16_BITS_SLOW = 0, /* 100 Hz */
+	MMC35240_16_BITS_FAST,     /* 200 Hz */
+	MMC35240_14_BITS,          /* 333 Hz */
+	MMC35240_12_BITS,          /* 666 Hz */
+};
+
+enum mmc35240_axis {
+	AXIS_X = 0,
+	AXIS_Y,
+	AXIS_Z,
+};
+
+static const struct {
+	int sens[3]; /* sensitivity per X, Y, Z axis */
+	int nfo; /* null field output */
+} mmc35240_props_table[] = {
+	/* 16 bits, 100Hz ODR */
+	{
+		{1024, 1024, 770},
+		32768,
+	},
+	/* 16 bits, 200Hz ODR */
+	{
+		{1024, 1024, 770},
+		32768,
+	},
+	/* 14 bits, 333Hz ODR */
+	{
+		{256, 256, 193},
+		8192,
+	},
+	/* 12 bits, 666Hz ODR */
+	{
+		{64, 64, 48},
+		2048,
+	},
+};
+
+struct mmc35240_data {
+	struct i2c_client *client;
+	struct mutex mutex;
+	struct regmap *regmap;
+	enum mmc35240_resolution res;
+};
+
+static const int mmc35240_samp_freq[] = {100, 200, 333, 666};
+
+static IIO_CONST_ATTR_SAMP_FREQ_AVAIL("100 200 333 666");
+
+#define MMC35240_CHANNEL(_axis) { \
+	.type = IIO_MAGN, \
+	.modified = 1, \
+	.channel2 = IIO_MOD_ ## _axis, \
+	.address = AXIS_ ## _axis, \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED), \
+	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SAMP_FREQ), \
+}
+
+static const struct iio_chan_spec mmc35240_channels[] = {
+	MMC35240_CHANNEL(X),
+	MMC35240_CHANNEL(Y),
+	MMC35240_CHANNEL(Z),
+};
+
+static struct attribute *mmc35240_attributes[] = {
+	&iio_const_attr_sampling_frequency_available.dev_attr.attr,
+};
+
+static const struct attribute_group mmc35240_attribute_group = {
+	.attrs = mmc35240_attributes,
+};
+
+static int mmc35240_get_samp_freq_index(struct mmc35240_data *data,
+					int val, int val2)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mmc35240_samp_freq); i++)
+		if (mmc35240_samp_freq[i] == val)
+			return i;
+	return -EINVAL;
+}
+
+static int mmc35240_hw_set(struct mmc35240_data *data, bool set)
+{
+	int ret;
+	u8 coil_bit;
+
+	/*
+	 * Recharge the capacitor at VCAP pin, requested to be issued
+	 * before a SET/RESET command.
+	 */
+	ret = regmap_update_bits(data->regmap, MMC35240_REG_CTRL0,
+				 MMC35240_CTRL0_REFILL_BIT,
+				 MMC35240_CTRL0_REFILL_BIT);
+	if (ret < 0)
+		return ret;
+	usleep_range(MMC35240_WAIT_CHARGE_PUMP, MMC35240_WAIT_CHARGE_PUMP + 1);
+
+	if (set)
+		coil_bit = MMC35240_CTRL0_SET_BIT;
+	else
+		coil_bit = MMC35240_CTRL0_RESET_BIT;
+
+	return regmap_update_bits(data->regmap, MMC35240_REG_CTRL0,
+				  MMC35240_CTRL0_REFILL_BIT,
+				  coil_bit);
+}
+
+static int mmc35240_init(struct mmc35240_data *data)
+{
+	int ret;
+	unsigned int reg_id;
+
+	ret = regmap_read(data->regmap, MMC35240_REG_ID, &reg_id);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "Error reading product id\n");
+		return ret;
+	}
+
+	dev_dbg(&data->client->dev, "MMC35240 chip id %x\n", reg_id);
+
+	/*
+	 * make sure we restore sensor characteristics, by doing
+	 * a RESET/SET sequence
+	 */
+	ret = mmc35240_hw_set(data, false);
+	if (ret < 0)
+		return ret;
+	usleep_range(MMC53240_WAIT_SET_RESET, MMC53240_WAIT_SET_RESET + 1);
+
+	ret = mmc35240_hw_set(data, true);
+	if (ret < 0)
+		return ret;
+
+	/* set default sampling frequency */
+	return regmap_update_bits(data->regmap, MMC35240_REG_CTRL1,
+				  MMC35240_CTRL1_BW_MASK,
+				  data->res << MMC35240_CTRL1_BW_SHIFT);
+}
+
+static int mmc35240_take_measurement(struct mmc35240_data *data)
+{
+	int ret, tries = 100;
+	unsigned int reg_status;
+
+	ret = regmap_write(data->regmap, MMC35240_REG_CTRL0,
+			   MMC35240_CTRL0_TM_BIT);
+	if (ret < 0)
+		return ret;
+
+	while (tries-- > 0) {
+		ret = regmap_read(data->regmap, MMC35240_REG_STATUS,
+				  &reg_status);
+		if (ret < 0)
+			return ret;
+		if (reg_status & MMC35240_STATUS_MEAS_DONE_BIT)
+			break;
+		msleep(20);
+	}
+
+	if (tries < 0) {
+		dev_err(&data->client->dev, "data not ready\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int mmc35240_read_measurement(struct mmc35240_data *data, __le16 buf[3])
+{
+	int ret;
+
+	ret = mmc35240_take_measurement(data);
+	if (ret < 0)
+		return ret;
+
+	return regmap_bulk_read(data->regmap, MMC35240_REG_XOUT_L, (u8 *)buf,
+				3 * sizeof(__le16));
+}
+
+static int mmc35240_raw_to_gauss(struct mmc35240_data *data, int index,
+				 __le16 buf[],
+				 int *val, int *val2)
+{
+	int raw_x, raw_y, raw_z;
+	int sens_x, sens_y, sens_z;
+	int nfo;
+
+	raw_x = le16_to_cpu(buf[AXIS_X]);
+	raw_y = le16_to_cpu(buf[AXIS_Y]);
+	raw_z = le16_to_cpu(buf[AXIS_Z]);
+
+	sens_x = mmc35240_props_table[data->res].sens[AXIS_X];
+	sens_y = mmc35240_props_table[data->res].sens[AXIS_Y];
+	sens_z = mmc35240_props_table[data->res].sens[AXIS_Z];
+
+	nfo = mmc35240_props_table[data->res].nfo;
+
+	switch (index) {
+	case AXIS_X:
+		*val = (raw_x - nfo) / sens_x;
+		*val2 = ((raw_x - nfo) % sens_x) * 1000000;
+		break;
+	case AXIS_Y:
+		*val = (raw_y - nfo) / sens_y - (raw_z - nfo) / sens_z;
+		*val2 = (((raw_y - nfo) % sens_y - (raw_z - nfo) % sens_z))
+			* 1000000;
+		break;
+	case AXIS_Z:
+		*val = (raw_y - nfo) / sens_y + (raw_z - nfo) / sens_z;
+		*val2 = (((raw_y - nfo) % sens_y + (raw_z - nfo) % sens_z))
+			* 1000000;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int mmc35240_read_raw(struct iio_dev *indio_dev,
+			     struct iio_chan_spec const *chan, int *val,
+			     int *val2, long mask)
+{
+	struct mmc35240_data *data = iio_priv(indio_dev);
+	int ret, i;
+	unsigned int reg;
+	__le16 buf[3];
+
+	switch (mask) {
+	case IIO_CHAN_INFO_PROCESSED:
+		mutex_lock(&data->mutex);
+		ret = mmc35240_read_measurement(data, buf);
+		mutex_unlock(&data->mutex);
+		if (ret < 0)
+			return ret;
+		ret = mmc35240_raw_to_gauss(data, chan->address,
+					    buf, val, val2);
+		if (ret < 0)
+			return ret;
+		return IIO_VAL_INT_PLUS_MICRO;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		mutex_lock(&data->mutex);
+		ret = regmap_read(data->regmap, MMC35240_REG_CTRL1, &reg);
+		mutex_unlock(&data->mutex);
+		if (ret < 0)
+			return ret;
+
+		i = (reg & MMC35240_CTRL1_BW_MASK) >> MMC35240_CTRL1_BW_SHIFT;
+		if (i < 0 || i > ARRAY_SIZE(mmc35240_samp_freq))
+			return -EINVAL;
+
+		*val = mmc35240_samp_freq[i];
+		*val2 = 0;
+		return IIO_VAL_INT;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int mmc35240_write_raw(struct iio_dev *indio_dev,
+			      struct iio_chan_spec const *chan, int val,
+			      int val2, long mask)
+{
+	struct mmc35240_data *data = iio_priv(indio_dev);
+	int i, ret;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		i = mmc35240_get_samp_freq_index(data, val, val2);
+		if (i < 0)
+			return -EINVAL;
+		mutex_lock(&data->mutex);
+		ret = regmap_update_bits(data->regmap, MMC35240_REG_CTRL1,
+					 MMC35240_CTRL1_BW_MASK,
+					 i << MMC35240_CTRL1_BW_SHIFT);
+		mutex_unlock(&data->mutex);
+		return ret;
+	default:
+		return -EINVAL;
+	}
+}
+
+static const struct iio_info mmc35240_info = {
+	.driver_module	= THIS_MODULE,
+	.read_raw	= mmc35240_read_raw,
+	.write_raw	= mmc35240_write_raw,
+	.attrs		= &mmc35240_attribute_group,
+};
+
+static bool mmc35240_is_writeable_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MMC35240_REG_CTRL0:
+	case MMC35240_REG_CTRL1:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool mmc35240_is_readable_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MMC35240_REG_XOUT_L:
+	case MMC35240_REG_XOUT_H:
+	case MMC35240_REG_YOUT_L:
+	case MMC35240_REG_YOUT_H:
+	case MMC35240_REG_ZOUT_L:
+	case MMC35240_REG_ZOUT_H:
+	case MMC35240_REG_STATUS:
+	case MMC35240_REG_ID:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool mmc35240_is_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MMC35240_REG_CTRL0:
+	case MMC35240_REG_CTRL1:
+		return false;
+	default:
+		return true;
+	}
+}
+
+static struct reg_default mmc35240_reg_defaults[] = {
+	{ MMC35240_REG_CTRL0,  0x00 },
+	{ MMC35240_REG_CTRL1,  0x00 },
+};
+
+static const struct regmap_config mmc35240_regmap_config = {
+	.name = MMC35240_REGMAP_NAME,
+
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.max_register = MMC35240_REG_ID,
+	.cache_type = REGCACHE_FLAT,
+
+	.writeable_reg = mmc35240_is_writeable_reg,
+	.readable_reg = mmc35240_is_readable_reg,
+	.volatile_reg = mmc35240_is_volatile_reg,
+
+	.reg_defaults = mmc35240_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(mmc35240_reg_defaults),
+};
+
+static int mmc35240_probe(struct i2c_client *client,
+			  const struct i2c_device_id *id)
+{
+	struct mmc35240_data *data;
+	struct iio_dev *indio_dev;
+	struct regmap *regmap;
+	int ret;
+
+	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));
+	if (!indio_dev)
+		return -ENOMEM;
+
+	regmap = devm_regmap_init_i2c(client, &mmc35240_regmap_config);
+	if (IS_ERR(regmap)) {
+		dev_err(&client->dev, "regmap initialization failed\n");
+		return PTR_ERR(regmap);
+	}
+
+	data = iio_priv(indio_dev);
+	data->client = client;
+	data->regmap = regmap;
+	data->res = MMC35240_16_BITS_SLOW;
+
+	mutex_init(&data->mutex);
+
+	indio_dev->dev.parent = &client->dev;
+	indio_dev->info = &mmc35240_info;
+	indio_dev->name = MMC35240_DRV_NAME;
+	indio_dev->channels = mmc35240_channels;
+	indio_dev->num_channels = ARRAY_SIZE(mmc35240_channels);
+	indio_dev->modes = INDIO_DIRECT_MODE;
+
+	ret = mmc35240_init(data);
+	if (ret < 0) {
+		dev_err(&client->dev, "mmc35240 chip init failed\n");
+		return ret;
+	}
+	return devm_iio_device_register(&client->dev, indio_dev);
+}
+
+static const struct i2c_device_id mmc35240_id[] = {
+	{"MMC35240", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, mmc35240_id);
+
+static struct i2c_driver mmc35240_driver = {
+	.driver = {
+		.name = MMC35240_DRV_NAME,
+	},
+	.probe		= mmc35240_probe,
+	.id_table	= mmc35240_id,
+};
+
+module_i2c_driver(mmc35240_driver);
+
+MODULE_AUTHOR("Daniel Baluta <daniel.baluta@intel.com>");
+MODULE_DESCRIPTION("MEMSIC MMC35240 magnetic sensor driver");
+MODULE_LICENSE("GPL v2");
