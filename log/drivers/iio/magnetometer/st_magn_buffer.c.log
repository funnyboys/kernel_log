commit e031d5f558f1535968df1ecae8d734b84c17f78d
Author: Denis Ciocca <denis.ciocca@st.com>
Date:   Mon Aug 5 11:57:11 2019 -0700

    iio:st_sensors: remove buffer allocation at each buffer enable
    
    This patch is removing the buffer allocation at each buffer enable.
    We just allocate enough memory in the main structure during probe
    to cover maximum size needed (that anyway is pretty small) [16bytes].
    
    Signed-off-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_buffer.c b/drivers/iio/magnetometer/st_magn_buffer.c
index 658d627dad8e..bb425c167a96 100644
--- a/drivers/iio/magnetometer/st_magn_buffer.c
+++ b/drivers/iio/magnetometer/st_magn_buffer.c
@@ -31,17 +31,11 @@ int st_magn_trig_set_state(struct iio_trigger *trig, bool state)
 
 static int st_magn_buffer_postenable(struct iio_dev *indio_dev)
 {
-	struct st_sensor_data *mdata = iio_priv(indio_dev);
 	int err;
 
-	mdata->buffer_data = kmalloc(indio_dev->scan_bytes,
-				     GFP_DMA | GFP_KERNEL);
-	if (!mdata->buffer_data)
-		return -ENOMEM;
-
 	err = iio_triggered_buffer_postenable(indio_dev);
 	if (err < 0)
-		goto st_magn_free_buffer;
+		return err;
 
 	err = st_sensors_set_enable(indio_dev, true);
 	if (err < 0)
@@ -51,14 +45,11 @@ static int st_magn_buffer_postenable(struct iio_dev *indio_dev)
 
 st_magn_buffer_predisable:
 	iio_triggered_buffer_predisable(indio_dev);
-st_magn_free_buffer:
-	kfree(mdata->buffer_data);
 	return err;
 }
 
 static int st_magn_buffer_predisable(struct iio_dev *indio_dev)
 {
-	struct st_sensor_data *mdata = iio_priv(indio_dev);
 	int err, err2;
 
 	err = st_sensors_set_enable(indio_dev, false);
@@ -67,7 +58,6 @@ static int st_magn_buffer_predisable(struct iio_dev *indio_dev)
 	if (!err)
 		err = err2;
 
-	kfree(mdata->buffer_data);
 	return err;
 }
 

commit 6ee19af415c55f8fee565613a2fa7892030ca9ac
Author: Denis Ciocca <denis.ciocca@st.com>
Date:   Wed Jul 31 14:48:59 2019 -0700

    iio:magn: preenable/postenable/predisable fixup for ST magn buffer
    
    This patch is trying to cleanup for good the buffers operation functions.
    Let's rename the goto label using operation to perform and not
    where it fails.
    
    Not stable material as not fixing a 'bug' but rather bringing the
    driver in line with general 'patterns' to allow a subsystem wide
    cleanup.
    
    Signed-off-by: Denis Ciocca <denis.ciocca@st.com>
    Reviewed-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_buffer.c b/drivers/iio/magnetometer/st_magn_buffer.c
index 9dba93539a99..658d627dad8e 100644
--- a/drivers/iio/magnetometer/st_magn_buffer.c
+++ b/drivers/iio/magnetometer/st_magn_buffer.c
@@ -31,40 +31,42 @@ int st_magn_trig_set_state(struct iio_trigger *trig, bool state)
 
 static int st_magn_buffer_postenable(struct iio_dev *indio_dev)
 {
-	int err;
 	struct st_sensor_data *mdata = iio_priv(indio_dev);
+	int err;
 
 	mdata->buffer_data = kmalloc(indio_dev->scan_bytes,
 				     GFP_DMA | GFP_KERNEL);
-	if (mdata->buffer_data == NULL) {
-		err = -ENOMEM;
-		goto allocate_memory_error;
-	}
+	if (!mdata->buffer_data)
+		return -ENOMEM;
 
 	err = iio_triggered_buffer_postenable(indio_dev);
 	if (err < 0)
-		goto st_magn_buffer_postenable_error;
+		goto st_magn_free_buffer;
+
+	err = st_sensors_set_enable(indio_dev, true);
+	if (err < 0)
+		goto st_magn_buffer_predisable;
 
-	return st_sensors_set_enable(indio_dev, true);
+	return 0;
 
-st_magn_buffer_postenable_error:
+st_magn_buffer_predisable:
+	iio_triggered_buffer_predisable(indio_dev);
+st_magn_free_buffer:
 	kfree(mdata->buffer_data);
-allocate_memory_error:
 	return err;
 }
 
 static int st_magn_buffer_predisable(struct iio_dev *indio_dev)
 {
-	int err;
 	struct st_sensor_data *mdata = iio_priv(indio_dev);
+	int err, err2;
 
 	err = st_sensors_set_enable(indio_dev, false);
-	if (err < 0)
-		goto st_magn_buffer_predisable_error;
 
-	err = iio_triggered_buffer_predisable(indio_dev);
+	err2 = iio_triggered_buffer_predisable(indio_dev);
+	if (!err)
+		err = err2;
 
-st_magn_buffer_predisable_error:
 	kfree(mdata->buffer_data);
 	return err;
 }

commit 062809ef7733209312562e87cefc84a470430929
Author: Denis Ciocca <denis.ciocca@st.com>
Date:   Thu Jul 18 15:53:53 2019 -0700

    iio: make st_sensors drivers use regmap
    
    This patch is meant to replace the i2c/spi transfer functions with
    regmap. SPI framework requires DMA safe buffers so let's add GFP_DMA
    flag for memory allocation used by bulk_read functions.
    
    Signed-off-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_buffer.c b/drivers/iio/magnetometer/st_magn_buffer.c
index 11d7806655bc..9dba93539a99 100644
--- a/drivers/iio/magnetometer/st_magn_buffer.c
+++ b/drivers/iio/magnetometer/st_magn_buffer.c
@@ -34,7 +34,8 @@ static int st_magn_buffer_postenable(struct iio_dev *indio_dev)
 	int err;
 	struct st_sensor_data *mdata = iio_priv(indio_dev);
 
-	mdata->buffer_data = kmalloc(indio_dev->scan_bytes, GFP_KERNEL);
+	mdata->buffer_data = kmalloc(indio_dev->scan_bytes,
+				     GFP_DMA | GFP_KERNEL);
 	if (mdata->buffer_data == NULL) {
 		err = -ENOMEM;
 		goto allocate_memory_error;

commit fda8d26e61fc518499ddc78ae74ec1aaa89c4134
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:06 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 177
    
    Based on 1 normalized pattern(s):
    
      licensed under the gpl 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 135 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170026.071193225@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/iio/magnetometer/st_magn_buffer.c b/drivers/iio/magnetometer/st_magn_buffer.c
index 37ab30566464..11d7806655bc 100644
--- a/drivers/iio/magnetometer/st_magn_buffer.c
+++ b/drivers/iio/magnetometer/st_magn_buffer.c
@@ -1,11 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * STMicroelectronics magnetometers driver
  *
  * Copyright 2012-2013 STMicroelectronics Inc.
  *
  * Denis Ciocca <denis.ciocca@st.com>
- *
- * Licensed under the GPL-2.
  */
 
 #include <linux/module.h>

commit fe5192ac81ad0d4dfe1395d11f393f0513c15f7f
Author: Martin Kelly <martin@martingkelly.com>
Date:   Sun Oct 28 20:18:53 2018 -0700

    iio:st_magn: Fix enable device after trigger
    
    Currently, we enable the device before we enable the device trigger. At
    high frequencies, this can cause interrupts that don't yet have a poll
    function associated with them and are thus treated as spurious. At high
    frequencies with level interrupts, this can even cause an interrupt storm
    of repeated spurious interrupts (~100,000 on my Beagleboard with the
    LSM9DS1 magnetometer). If these repeat too much, the interrupt will get
    disabled and the device will stop functioning.
    
    To prevent these problems, enable the device prior to enabling the device
    trigger, and disable the divec prior to disabling the trigger. This means
    there's no window of time during which the device creates interrupts but we
    have no trigger to answer them.
    
    Fixes: 90efe055629 ("iio: st_sensors: harden interrupt handling")
    Signed-off-by: Martin Kelly <martin@martingkelly.com>
    Tested-by: Denis Ciocca <denis.ciocca@st.com>
    Cc: <Stable@vger.kernel.org>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_buffer.c b/drivers/iio/magnetometer/st_magn_buffer.c
index 0a9e8fadfa9d..37ab30566464 100644
--- a/drivers/iio/magnetometer/st_magn_buffer.c
+++ b/drivers/iio/magnetometer/st_magn_buffer.c
@@ -30,11 +30,6 @@ int st_magn_trig_set_state(struct iio_trigger *trig, bool state)
 	return st_sensors_set_dataready_irq(indio_dev, state);
 }
 
-static int st_magn_buffer_preenable(struct iio_dev *indio_dev)
-{
-	return st_sensors_set_enable(indio_dev, true);
-}
-
 static int st_magn_buffer_postenable(struct iio_dev *indio_dev)
 {
 	int err;
@@ -50,7 +45,7 @@ static int st_magn_buffer_postenable(struct iio_dev *indio_dev)
 	if (err < 0)
 		goto st_magn_buffer_postenable_error;
 
-	return err;
+	return st_sensors_set_enable(indio_dev, true);
 
 st_magn_buffer_postenable_error:
 	kfree(mdata->buffer_data);
@@ -63,11 +58,11 @@ static int st_magn_buffer_predisable(struct iio_dev *indio_dev)
 	int err;
 	struct st_sensor_data *mdata = iio_priv(indio_dev);
 
-	err = iio_triggered_buffer_predisable(indio_dev);
+	err = st_sensors_set_enable(indio_dev, false);
 	if (err < 0)
 		goto st_magn_buffer_predisable_error;
 
-	err = st_sensors_set_enable(indio_dev, false);
+	err = iio_triggered_buffer_predisable(indio_dev);
 
 st_magn_buffer_predisable_error:
 	kfree(mdata->buffer_data);
@@ -75,7 +70,6 @@ static int st_magn_buffer_predisable(struct iio_dev *indio_dev)
 }
 
 static const struct iio_buffer_setup_ops st_magn_buffer_setup_ops = {
-	.preenable = &st_magn_buffer_preenable,
 	.postenable = &st_magn_buffer_postenable,
 	.predisable = &st_magn_buffer_predisable,
 };

commit 65925b65ed98ffdb277cf5ea1af45731dac0b30b
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sat May 21 20:43:16 2016 +0200

    iio: st_sensors: switch to a threaded interrupt
    
    commit 98ad8b41f58dff6b30713d7f09ae3834b8df7ded
    ("iio: st_sensors: verify interrupt event to status") caused
    a regression when reading ST sensors from a HRTimer trigger
    rather than the intrinsic interrupts: the HRTimer may
    trigger faster than the sensor provides new values, and
    as the check against new values available as a cause of
    the interrupt trigger was done in the poll function,
    this would bail out of the HRTimer interrupt with
    IRQ_NONE.
    
    So clearly we need to only check the new values available
    from the proper interrupt handler and not from the poll
    function, which should rather just read the raw values
    from the registers, put them into the buffer and be happy.
    
    To achieve this: switch the ST Sensors over to using a true
    threaded interrupt handler.
    
    In the interrupt thread, check if new values are available,
    else yield to the (potential) next device on the same
    interrupt line to check the registers. If the interrupt
    was ours, proceed to poll the values.
    
    Instead of relying on iio_trigger_generic_data_rdy_poll() as
    a top half to wake up the thread that polls the sensor for
    new data, have the thread call iio_trigger_poll_chained()
    after determining that is is the proper source of the
    interrupt. This is modelled on drivers/iio/accel/mma8452.c
    which is already using a properly threaded interrupt handler.
    
    In order to get the same precision in timestamps as
    previously, where samples would be timestamped in the
    poll function pf->timestamp when calling
    iio_trigger_generic_data_rdy_poll() we introduce a
    local timestamp in the sensor data, set it in the top half
    (fastpath) of the interrupt handler and provide that to the
    core when calling iio_push_to_buffers_with_timestamp().
    
    Additionally: if the active scanmask is not set for the
    sensor no IRQs should be enabled and we need to bail out
    with IRQ_NONE. This can happen if spurious IRQs fire when
    installing the threaded interrupt handler.
    
    Tested with hard interrupt triggers on LIS331DL, then also
    tested with hrtimers on the same sensor by creating a 75Hz
    HRTimer and using it to poll the sensor.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Giuseppe Barba <giuseppe.barba@st.com>
    Cc: Denis Ciocca <denis.ciocca@st.com>
    Reported-by: Crestez Dan Leonard <cdleonard@gmail.com>
    Tested-by: Crestez Dan Leonard <cdleonard@gmail.com>
    Tested-by: Jonathan Cameron <jic23@kernel.org>
    Fixes: 97865fe41322 ("iio: st_sensors: verify interrupt event to status")
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_buffer.c b/drivers/iio/magnetometer/st_magn_buffer.c
index ecd3bd0a9769..0a9e8fadfa9d 100644
--- a/drivers/iio/magnetometer/st_magn_buffer.c
+++ b/drivers/iio/magnetometer/st_magn_buffer.c
@@ -82,7 +82,7 @@ static const struct iio_buffer_setup_ops st_magn_buffer_setup_ops = {
 
 int st_magn_allocate_ring(struct iio_dev *indio_dev)
 {
-	return iio_triggered_buffer_setup(indio_dev, &iio_pollfunc_store_time,
+	return iio_triggered_buffer_setup(indio_dev, NULL,
 		&st_sensors_trigger_handler, &st_magn_buffer_setup_ops);
 }
 

commit 74f5683f35fe6feae33b96815c1d40f13468d614
Author: Giuseppe Barba <giuseppe.barba@st.com>
Date:   Tue Jul 21 10:35:43 2015 +0200

    iio: st_magn: Add irq trigger handling
    
    Add irq trigger handling for magnetometer also
    
    Signed-off-by: Giuseppe Barba <giuseppe.barba@st.com>
    Acked-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_buffer.c b/drivers/iio/magnetometer/st_magn_buffer.c
index bf427dc0d226..ecd3bd0a9769 100644
--- a/drivers/iio/magnetometer/st_magn_buffer.c
+++ b/drivers/iio/magnetometer/st_magn_buffer.c
@@ -23,6 +23,13 @@
 #include <linux/iio/common/st_sensors.h>
 #include "st_magn.h"
 
+int st_magn_trig_set_state(struct iio_trigger *trig, bool state)
+{
+	struct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);
+
+	return st_sensors_set_dataready_irq(indio_dev, state);
+}
+
 static int st_magn_buffer_preenable(struct iio_dev *indio_dev)
 {
 	return st_sensors_set_enable(indio_dev, true);

commit bbc1751d2417ccd126fc5215621c58c7467d8eed
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Oct 14 17:49:00 2013 +0100

    iio:st_magn: Remove redundant call to iio_sw_buffer_preenable().
    
    The equivalent of iio_sw_buffer_preenable() is now done in the IIO buffer core,
    so there is no need to do this from the driver anymore.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Cc: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_buffer.c b/drivers/iio/magnetometer/st_magn_buffer.c
index 708857bdb47d..bf427dc0d226 100644
--- a/drivers/iio/magnetometer/st_magn_buffer.c
+++ b/drivers/iio/magnetometer/st_magn_buffer.c
@@ -25,16 +25,7 @@
 
 static int st_magn_buffer_preenable(struct iio_dev *indio_dev)
 {
-	int err;
-
-	err = st_sensors_set_enable(indio_dev, true);
-	if (err < 0)
-		goto st_magn_set_enable_error;
-
-	err = iio_sw_buffer_preenable(indio_dev);
-
-st_magn_set_enable_error:
-	return err;
+	return st_sensors_set_enable(indio_dev, true);
 }
 
 static int st_magn_buffer_postenable(struct iio_dev *indio_dev)

commit 872e79add7561645b130fba63aa7ca12098a9361
Author: Denis Ciocca <denis.ciocca@gmail.com>
Date:   Fri Jan 25 23:44:00 2013 +0000

    iio:magnetometer: Add STMicroelectronics magnetometers driver
    
    This patch adds a generic magnetometer driver for STMicroelectronics
    magnetometers, currently it supports:
    LSM303DLHC, LSM303DLM, LIS3MDL.
    
    Signed-off-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_buffer.c b/drivers/iio/magnetometer/st_magn_buffer.c
new file mode 100644
index 000000000000..708857bdb47d
--- /dev/null
+++ b/drivers/iio/magnetometer/st_magn_buffer.c
@@ -0,0 +1,98 @@
+/*
+ * STMicroelectronics magnetometers driver
+ *
+ * Copyright 2012-2013 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/stat.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/triggered_buffer.h>
+
+#include <linux/iio/common/st_sensors.h>
+#include "st_magn.h"
+
+static int st_magn_buffer_preenable(struct iio_dev *indio_dev)
+{
+	int err;
+
+	err = st_sensors_set_enable(indio_dev, true);
+	if (err < 0)
+		goto st_magn_set_enable_error;
+
+	err = iio_sw_buffer_preenable(indio_dev);
+
+st_magn_set_enable_error:
+	return err;
+}
+
+static int st_magn_buffer_postenable(struct iio_dev *indio_dev)
+{
+	int err;
+	struct st_sensor_data *mdata = iio_priv(indio_dev);
+
+	mdata->buffer_data = kmalloc(indio_dev->scan_bytes, GFP_KERNEL);
+	if (mdata->buffer_data == NULL) {
+		err = -ENOMEM;
+		goto allocate_memory_error;
+	}
+
+	err = iio_triggered_buffer_postenable(indio_dev);
+	if (err < 0)
+		goto st_magn_buffer_postenable_error;
+
+	return err;
+
+st_magn_buffer_postenable_error:
+	kfree(mdata->buffer_data);
+allocate_memory_error:
+	return err;
+}
+
+static int st_magn_buffer_predisable(struct iio_dev *indio_dev)
+{
+	int err;
+	struct st_sensor_data *mdata = iio_priv(indio_dev);
+
+	err = iio_triggered_buffer_predisable(indio_dev);
+	if (err < 0)
+		goto st_magn_buffer_predisable_error;
+
+	err = st_sensors_set_enable(indio_dev, false);
+
+st_magn_buffer_predisable_error:
+	kfree(mdata->buffer_data);
+	return err;
+}
+
+static const struct iio_buffer_setup_ops st_magn_buffer_setup_ops = {
+	.preenable = &st_magn_buffer_preenable,
+	.postenable = &st_magn_buffer_postenable,
+	.predisable = &st_magn_buffer_predisable,
+};
+
+int st_magn_allocate_ring(struct iio_dev *indio_dev)
+{
+	return iio_triggered_buffer_setup(indio_dev, &iio_pollfunc_store_time,
+		&st_sensors_trigger_handler, &st_magn_buffer_setup_ops);
+}
+
+void st_magn_deallocate_ring(struct iio_dev *indio_dev)
+{
+	iio_triggered_buffer_cleanup(indio_dev);
+}
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics magnetometers buffer");
+MODULE_LICENSE("GPL v2");
