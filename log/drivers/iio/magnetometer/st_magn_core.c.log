commit 1f38527d5878401611a0082e2926c9625e2331cf
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Mar 13 12:49:50 2020 +0200

    iio: st_sensors: Drop unneeded explicit castings
    
    In few places the unnecessary explicit castings are being used.
    Drop them for good.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index e68184a93a6d..79de721e6015 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -506,8 +506,7 @@ int st_magn_common_probe(struct iio_dev *indio_dev)
 	indio_dev->channels = mdata->sensor_settings->ch;
 	indio_dev->num_channels = ST_SENSORS_NUMBER_ALL_CHANNELS;
 
-	mdata->current_fullscale = (struct st_sensor_fullscale_avl *)
-					&mdata->sensor_settings->fs.fs_avl[0];
+	mdata->current_fullscale = &mdata->sensor_settings->fs.fs_avl[0];
 	mdata->odr = mdata->sensor_settings->odr.odr_avl[0].hz;
 
 	err = st_sensors_init_sensor(indio_dev, NULL);

commit 12737476e0992bde3e14e2df2fedf43a117abf71
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Oct 23 10:47:02 2019 +0200

    iio: st: Drop GPIO include
    
    None of the ST sensor drivers use any symbols from
    <linux/gpio.h>, just drop the include from all of them.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index a3a268ee2896..e68184a93a6d 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -14,7 +14,6 @@
 #include <linux/types.h>
 #include <linux/interrupt.h>
 #include <linux/i2c.h>
-#include <linux/gpio.h>
 #include <linux/irq.h>
 #include <linux/delay.h>
 #include <linux/iio/iio.h>

commit 9cd15d521a3adcb687a0f9a312e32caaa94f44c2
Author: Denis Ciocca <denis.ciocca@st.com>
Date:   Fri Aug 2 10:59:13 2019 -0700

    iio: remove get_irq_data_ready() function pointer and use IRQ number directly
    
    Not even sure why it was there since the beginning. Just use IRQ
    number in the sensor_data struct.
    
    Signed-off-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 804353a483c7..a3a268ee2896 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -490,7 +490,6 @@ EXPORT_SYMBOL(st_magn_get_settings);
 int st_magn_common_probe(struct iio_dev *indio_dev)
 {
 	struct st_sensor_data *mdata = iio_priv(indio_dev);
-	int irq = mdata->get_irq_data_ready(indio_dev);
 	int err;
 
 	indio_dev->modes = INDIO_DIRECT_MODE;
@@ -520,7 +519,7 @@ int st_magn_common_probe(struct iio_dev *indio_dev)
 	if (err < 0)
 		goto st_magn_power_off;
 
-	if (irq > 0) {
+	if (mdata->irq > 0) {
 		err = st_sensors_allocate_trigger(indio_dev,
 						ST_MAGN_TRIGGER_OPS);
 		if (err < 0)
@@ -537,7 +536,7 @@ int st_magn_common_probe(struct iio_dev *indio_dev)
 	return 0;
 
 st_magn_device_register_error:
-	if (irq > 0)
+	if (mdata->irq > 0)
 		st_sensors_deallocate_trigger(indio_dev);
 st_magn_probe_trigger_error:
 	st_magn_deallocate_ring(indio_dev);
@@ -555,7 +554,7 @@ void st_magn_common_remove(struct iio_dev *indio_dev)
 	st_sensors_power_disable(indio_dev);
 
 	iio_device_unregister(indio_dev);
-	if (mdata->get_irq_data_ready(indio_dev) > 0)
+	if (mdata->irq > 0)
 		st_sensors_deallocate_trigger(indio_dev);
 
 	st_magn_deallocate_ring(indio_dev);

commit 062809ef7733209312562e87cefc84a470430929
Author: Denis Ciocca <denis.ciocca@st.com>
Date:   Thu Jul 18 15:53:53 2019 -0700

    iio: make st_sensors drivers use regmap
    
    This patch is meant to replace the i2c/spi transfer functions with
    regmap. SPI framework requires DMA safe buffers so let's add GFP_DMA
    flag for memory allocation used by bulk_read functions.
    
    Signed-off-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 3f313aefece6..804353a483c7 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -12,7 +12,6 @@
 #include <linux/slab.h>
 #include <linux/errno.h>
 #include <linux/types.h>
-#include <linux/mutex.h>
 #include <linux/interrupt.h>
 #include <linux/i2c.h>
 #include <linux/gpio.h>
@@ -496,7 +495,6 @@ int st_magn_common_probe(struct iio_dev *indio_dev)
 
 	indio_dev->modes = INDIO_DIRECT_MODE;
 	indio_dev->info = &magn_info;
-	mutex_init(&mdata->tb.buf_lock);
 
 	err = st_sensors_power_enable(indio_dev);
 	if (err)
@@ -507,7 +505,6 @@ int st_magn_common_probe(struct iio_dev *indio_dev)
 		goto st_magn_power_off;
 
 	mdata->num_data_channels = ST_MAGN_NUMBER_DATA_CHANNELS;
-	mdata->multiread_bit = mdata->sensor_settings->multi_read_bit;
 	indio_dev->channels = mdata->sensor_settings->ch;
 	indio_dev->num_channels = ST_SENSORS_NUMBER_ALL_CHANNELS;
 

commit 1ecd245e0eb23d1c3803474eba75589743d0d1fe
Author: Denis Ciocca <denis.ciocca@st.com>
Date:   Thu Jul 18 15:53:52 2019 -0700

    iio: move 3-wire spi initialization to st_sensors_spi
    
    Some devices need to be configured with special bit in order to
    use spi 3-wire. This was done during device identification phase.
    Instead, let's move this part as spi specific.
    Doing this the check_device_support function becomes a simple
    device id check, so let's rename it.
    
    Signed-off-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 43a49a52c81a..3f313aefece6 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -502,9 +502,7 @@ int st_magn_common_probe(struct iio_dev *indio_dev)
 	if (err)
 		return err;
 
-	err = st_sensors_check_device_support(indio_dev,
-					ARRAY_SIZE(st_magn_sensors_settings),
-					st_magn_sensors_settings);
+	err = st_sensors_verify_id(indio_dev);
 	if (err < 0)
 		goto st_magn_power_off;
 

commit aa4e75c85076c056d944b92ed94b76277430d263
Author: Denis Ciocca <denis.ciocca@st.com>
Date:   Thu Jul 18 15:53:46 2019 -0700

    iio:magn: introduce st_magn_get_settings() function
    
    The function is introduced to retrieve magn device settings. It will be
    used by probe in order to configure regmap.
    
    Signed-off-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 2f7a1dbcdeb3..43a49a52c81a 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -470,6 +470,24 @@ static const struct iio_trigger_ops st_magn_trigger_ops = {
 #define ST_MAGN_TRIGGER_OPS NULL
 #endif
 
+/*
+ * st_magn_get_settings() - get sensor settings from device name
+ * @name: device name buffer reference.
+ *
+ * Return: valid reference on success, NULL otherwise.
+ */
+const struct st_sensor_settings *st_magn_get_settings(const char *name)
+{
+	int index = st_sensors_get_settings_index(name,
+					st_magn_sensors_settings,
+					ARRAY_SIZE(st_magn_sensors_settings));
+	if (index < 0)
+		return NULL;
+
+	return &st_magn_sensors_settings[index];
+}
+EXPORT_SYMBOL(st_magn_get_settings);
+
 int st_magn_common_probe(struct iio_dev *indio_dev)
 {
 	struct st_sensor_data *mdata = iio_priv(indio_dev);

commit fda8d26e61fc518499ddc78ae74ec1aaa89c4134
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:06 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 177
    
    Based on 1 normalized pattern(s):
    
      licensed under the gpl 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 135 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170026.071193225@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 5d056bdb3b37..2f7a1dbcdeb3 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -1,11 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * STMicroelectronics magnetometers driver
  *
  * Copyright 2012-2013 STMicroelectronics Inc.
  *
  * Denis Ciocca <denis.ciocca@st.com>
- *
- * Licensed under the GPL-2.
  */
 
 #include <linux/kernel.h>

commit 2eb4c9f2a5d7893e3bed451216ec248a3ce44ed2
Author: Martin Kelly <martin@martingkelly.com>
Date:   Thu Oct 25 19:38:11 2018 -0700

    iio:magnetometer: st_magn: add BDU settings
    
    LIS3MDL and LSM9DS1 are missing BDU settings in their register maps, so add
    them. I don't have a LIS3MDL sensor to test, but this works correctly on
    the LSM9DS1, which has the same register map.
    
    Signed-off-by: Martin Kelly <martin@martingkelly.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 45c074e0d5b2..5d056bdb3b37 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -316,6 +316,10 @@ static const struct st_sensor_settings st_magn_sensors_settings[] = {
 				},
 			},
 		},
+		.bdu = {
+			.addr = 0x24,
+			.mask = 0x40,
+		},
 		.drdy_irq = {
 			/* drdy line is routed drdy pin */
 			.stat_drdy = {

commit 0d92aa2c272faea47cd5e9acb482acdb9eed2c1d
Author: Martin Kelly <martin@martingkelly.com>
Date:   Thu Oct 25 19:38:10 2018 -0700

    iio:magnetometer: st_magn: add LSM9DS1 support
    
    Update the sensor settings to support the LSM9DS1 sensor. Although the
    LSM9DS1 accelerometer and gyroscope are coupled together to use the same
    FIFO, the magnetometer is separate and can be cleanly supported without
    refactoring the existing driver.
    
    Signed-off-by: Martin Kelly <martin@martingkelly.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 880c11c7f1cb..45c074e0d5b2 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -267,6 +267,7 @@ static const struct st_sensor_settings st_magn_sensors_settings[] = {
 		.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,
 		.sensors_supported = {
 			[0] = LIS3MDL_MAGN_DEV_NAME,
+			[1] = LSM9DS1_MAGN_DEV_NAME,
 		},
 		.ch = (struct iio_chan_spec *)st_magn_2_16bit_channels,
 		.odr = {

commit 2019738cc8e3d552e8ec426b42b2e1f53782f459
Author: Martin Kelly <martin@martingkelly.com>
Date:   Mon Oct 15 20:27:09 2018 -0700

    iio: st_sensors: miscellaneous cleanup
    
    Miscellaneous cleanup to fix minor consistency, grammar, and spelling
    issues.
    
    Signed-off-by: Martin Kelly <martin@martingkelly.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 72f6d1335a04..880c11c7f1cb 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -29,9 +29,9 @@
 #define ST_MAGN_NUMBER_DATA_CHANNELS		3
 
 /* DEFAULT VALUE FOR SENSORS */
-#define ST_MAGN_DEFAULT_OUT_X_H_ADDR		0X03
-#define ST_MAGN_DEFAULT_OUT_Y_H_ADDR		0X07
-#define ST_MAGN_DEFAULT_OUT_Z_H_ADDR		0X05
+#define ST_MAGN_DEFAULT_OUT_X_H_ADDR		0x03
+#define ST_MAGN_DEFAULT_OUT_Y_H_ADDR		0x07
+#define ST_MAGN_DEFAULT_OUT_Z_H_ADDR		0x05
 
 /* FULLSCALE */
 #define ST_MAGN_FS_AVL_1300MG			1300

commit 9915c19056cb2923d36c2f048467aa26491eed82
Author: Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>
Date:   Sun Sep 17 17:20:46 2017 +0200

    iio: magnetometer: st_magn: add SPI-3wire support to LIS3MDL
    
    Add SPI Serial Interface Mode (SIM) register information to
    LIS3MDL magn sensor
    
    Signed-off-by: Lorenzo Bianconi <lorenzo.bianconi@st.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 8745686f233c..72f6d1335a04 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -322,6 +322,10 @@ static const struct st_sensor_settings st_magn_sensors_settings[] = {
 				.mask = 0x07,
 			},
 		},
+		.sim = {
+			.addr = 0x22,
+			.value = BIT(2),
+		},
 		.multi_read_bit = true,
 		.bootime = 2,
 	},

commit 75d4c6d2e15d4455dfd5995c27e6e6ad6f214e39
Author: Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>
Date:   Wed Aug 30 13:50:40 2017 +0200

    iio: st_sensors: decouple irq1 configuration parameters from the irq2 ones
    
    Separate data-ready configuration parameters for INT1 and INT2 pins in
    st_sensor_data_ready_irq data structure. That change will be use to
    properly support LIS2DW12 accel sensor.
    
    Signed-off-by: Lorenzo Bianconi <lorenzo.bianconi@st.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index ace72c57f53c..8745686f233c 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -362,8 +362,10 @@ static const struct st_sensor_settings st_magn_sensors_settings[] = {
 			.mask = 0x10,
 		},
 		.drdy_irq = {
-			.addr = 0x62,
-			.mask_int1 = 0x01,
+			.int1 = {
+				.addr = 0x62,
+				.mask = 0x01,
+			},
 			.stat_drdy = {
 				.addr = 0x67,
 				.mask = 0x07,

commit e72a060151e5bb673af24993665e270fc4f674a7
Author: Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>
Date:   Wed Aug 30 13:50:39 2017 +0200

    iio: st_sensors: add register mask for status register
    
    Introduce register mask for data-ready status register since
    pressure sensors (e.g. LPS22HB) export just two channels
    (BIT(0) and BIT(1)) and BIT(2) is marked reserved while in
    st_sensors_new_samples_available() value read from status register
    is masked using 0x7.
    Moreover do not mask status register using active_scan_mask since
    now status value is properly masked and if the result is not zero the
    interrupt has to be consumed by the driver. This fix an issue on LPS25H
    and LPS331AP where channel definition is swapped respect to status
    register.
    Furthermore that change allows to properly support new devices
    (e.g LIS2DW12) that report just ZYXDA (data-ready) field in status register
    to figure out if the interrupt has been generated by the device.
    
    Fixes: 97865fe41322 (iio: st_sensors: verify interrupt event to status)
    Signed-off-by: Lorenzo Bianconi <lorenzo.bianconi@st.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 703de313c418..ace72c57f53c 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -317,7 +317,10 @@ static const struct st_sensor_settings st_magn_sensors_settings[] = {
 		},
 		.drdy_irq = {
 			/* drdy line is routed drdy pin */
-			.addr_stat_drdy = ST_SENSORS_DEFAULT_STAT_ADDR,
+			.stat_drdy = {
+				.addr = ST_SENSORS_DEFAULT_STAT_ADDR,
+				.mask = 0x07,
+			},
 		},
 		.multi_read_bit = true,
 		.bootime = 2,
@@ -361,7 +364,10 @@ static const struct st_sensor_settings st_magn_sensors_settings[] = {
 		.drdy_irq = {
 			.addr = 0x62,
 			.mask_int1 = 0x01,
-			.addr_stat_drdy = 0x67,
+			.stat_drdy = {
+				.addr = 0x67,
+				.mask = 0x07,
+			},
 		},
 		.multi_read_bit = false,
 		.bootime = 2,

commit 1236d6bb6e19fc72ffc6bbcdeb1bfefe450e54ee
Merge: 750b1a6894ec 8a5776a5f498
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Oct 9 09:02:35 2017 +0200

    Merge 4.14-rc4 into staging-next
    
    We want the staging/iio fixes in here as well to handle merge issues.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 069f0e0c06b7dda71185bd27b3787868cf353f44
Merge: 821797e06903 a6786847407f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Sep 25 12:56:37 2017 +0200

    Merge tag 'iio-for-4.15a' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-next
    
    Jonathan writes:
    
    Round one of new device support, features and cleanup for IIO in the 4.15 cycle.
    
    Note there is a misc driver drop in here given we have support
    in IIO and the feeling is no one will care.
    
    A large part of this series is a boiler plate removal series avoiding
    the need to explicitly provide THIS_MODULE in various locations.
    It's very dull but touches all drivers.
    
    New device support
    * ad5446
      - add ids to support compatible parts DAC081S101, DAC101S101,
        DAC121S101.
      - add the dac7512 id and drop the misc driver as feeling is no
        one is using it (was introduced for a board that is long obsolete)
    * mt6577
      - add bindings for mt2712 which is fully compatible with other
        supported parts.
    * st_pressure
      - add support for LPS33HW and LPS35HW with bindings (ids mostly).
    
    New features
    * ccs811
      - Add support for the data ready trigger.
    * mma8452
      - remove artifical restriction on supporting multiple event types
        at the same time.
    * tcs3472
      - support out of threshold events
    
    Core and tree wide cleanup
    * Use macro magic to remove the need to provide THIS_MODULE as part of
      struct iio_info or struct iio_trigger_ops.  This is similar to
      work done in a number of other subsystems (e.g. i2c, spi).
    
      All drivers are fixed and then the fields in these structures are
      removed.
    
      This will cause build failures for out of tree drivers and any
      new drivers that cross with this work going into the kernel.
    
      Note mostly done with a coccinelle patch, included in the series
      on the mailing list but not merged as the fields no longer exist
      in the structures so the any hold outs will cause a build failure.
    
    Cleanups
    * ads1015
      - avoid writing config register when it doesn't change.
      - add 10% to conversion wait time as it seems it is sometimes
        a little small.
    * ade7753
      - replace use of core mlock with a local lock.  This is part of a
        long term effort to make the use of mlock opaque and single
        purpose.
    * ade7759
      - expand the use of buf_lock to cover previous mlock cases.  This
        is a slightly nicer solution to the same issue as in ade7753.
    * cros_ec
      - drop an unused variable
    * inv_mpu6050
      - add a missing break in a switch for consistency - not actual
        bug,
      - make some local arrays static to save on object code size.
    * max5481
      - drop manual setting of the spi module owner as handled by the
        spi core.
    * max5487
      - drop manual setting of the spi module owner as handled by the
        spi core.
    * max9611
      - drop explicit setting of the i2c module owner as handled by
        the i2c core.
    * mcp320x
      - speed up reads on single channel devices,
      - drop unused of_device_id data elements,
      - document the struct mcp320x,
      - improve binding docs to reflect restrictions on spi setup and
        to make it explicit that the reference regulator is needed.
    * mma8452
      - symbolic to octal permissions,
      - unsigned to unsigned int.
    * st_lsm6dsx
      - avoid setting odr values multiple times,
      - drop config of LIR as it is only ever set to the existing
        defaults,
      - drop rounding configuration as it only ever matches the defaults.
    * ti-ads8688
      - drop manual setting of the spi module owner as handled by the
        spi core.
    * tsl2x7x
      - constify the i2c_device_id,
      - cleanup limit checks to avoid static checker warnings (and generally
        have nicer code).

commit b2e312061c5e9f533c44487862dc405094bf250a
Merge: ec14121931a2 f790923f1461
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Sep 25 10:58:22 2017 +0200

    Merge tag 'iio-fixes-for-4.14a' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-linus
    
    Jonathan writes:
    
    First round of IIO fixes for the 4.14 cycle
    
    Note this includes fixes from recent merge window.  As such the tree
    is based on top of a prior staging/staging-next tree.
    
    * iio core
      - return and error for a failed read_reg debugfs call rather than
        eating the error.
    * ad7192
      - Use the dedicated reset function in the ad_sigma_delta library
        instead of an spi transfer with the data on the stack which
        could cause problems with DMA.
    * ad7793
      - Implement a dedicate reset function in the ad_sigma_delta library
        and use it to correctly reset this part.
    * bme280
      - ctrl_reg write must occur after any register writes
      for updates to take effect.
    * mcp320x
      - negative voltage readout was broken.
      - Fix an oops on module unload due to spi_set_drvdata not being called
        in probe.
    * st_magn
      - Fix the data ready line configuration for the lis3mdl. It is not
        configurable so the st_magn core was assuming it didn't exist
        and so wasn't consuming interrupts resulting in an unhandled
        interrupt.
    * stm32-adc
      - off by one error on max channels checking.
    * stm32-timer
      - preset should not be buffered - reorganising register writes avoids
      this.
      - fix a corner case in which write preset goes wrong when a timer is
      used first as a trigger then as a counter with preset. Odd case but
      you never know.
    * ti-ads1015
      - Fix setting of comparator polarity by fixing bitfield definition.
    * twl4030
      - Error path handling fix to cleanup in event of regulator
        registration failure.
      - Disable the vusb3v1 regulator correctly in error handling
      - Don't paper over a regulator enable failure.

commit c65e3d6ef4bfdc4c8460509f08507cf7dc026974
Author: Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>
Date:   Tue Aug 29 13:45:11 2017 +0200

    iio: magnetometer: st_magn: fix drdy line configuration for LIS3MDL
    
    Data-ready line in LIS3MDL is routed to drdy pin and it is not possible
    to select a different INT pin. st_sensors_set_dataready_irq() assumes
    that if drdy int address is not exported in register map, irq trigger
    is not supported by the sensor and hw_irq_trigger is always false.
    Based on this configuration st_sensors_irq_thread does not consume
    generated interrupt causing an unhandled irq.
    Fix this taking into account status register address in
    st_sensors_set_dataready_irq()
    
    Fixes: 90efe0556292 (iio: st_sensors: harden interrupt handling)
    Signed-off-by: Lorenzo Bianconi <lorenzo.bianconi@st.com>
    Cc: <Stable@vger.kernel.org>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 703e77008652..2e36d746f5bc 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -315,6 +315,10 @@ static const struct st_sensor_settings st_magn_sensors_settings[] = {
 				},
 			},
 		},
+		.drdy_irq = {
+			/* drdy line is routed drdy pin */
+			.addr_stat_drdy = ST_SENSORS_DEFAULT_STAT_ADDR,
+		},
 		.multi_read_bit = true,
 		.bootime = 2,
 	},

commit 8439a69e72888daa7d2667980efaf20d8bbe7b20
Merge: b9920ca3b537 cc4a41fe5541
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Aug 28 15:26:48 2017 +0200

    Merge 4.13-rc7 into staging-next
    
    We want the staging and iio fixes in here to handle the merge issues.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7f307262af08e842297561ef7afd3cce248b258a
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sun Jul 23 17:26:01 2017 +0100

    iio:magnetometer: drop assign iio_info.driver_module and iio_trigger_ops.owner
    
    The equivalent of both of these are now done via macro magic when
    the relevant register calls are made.  The actual structure
    elements will shortly go away.
    
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 703e77008652..83fdd7230917 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -436,7 +436,6 @@ static const struct attribute_group st_magn_attribute_group = {
 };
 
 static const struct iio_info magn_info = {
-	.driver_module = THIS_MODULE,
 	.attrs = &st_magn_attribute_group,
 	.read_raw = &st_magn_read_raw,
 	.write_raw = &st_magn_write_raw,
@@ -445,7 +444,6 @@ static const struct iio_info magn_info = {
 
 #ifdef CONFIG_IIO_TRIGGER
 static const struct iio_trigger_ops st_magn_trigger_ops = {
-	.owner = THIS_MODULE,
 	.set_trigger_state = ST_MAGN_TRIGGER_SET_STATE,
 	.validate_device = st_sensors_validate_device,
 };

commit 8b35a5f87a73842601cd376e0f5b9b25831390f4
Author: Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>
Date:   Wed Aug 16 19:02:51 2017 +0200

    iio: magnetometer: st_magn: remove ihl property for LSM303AGR
    
    Remove IRQ active low support for LSM303AGR since the sensor does not
    support that capability for data-ready line
    
    Fixes: a9fd053b56c6 (iio: st_sensors: support active-low interrupts)
    Signed-off-by: Lorenzo Bianconi <lorenzo.bianconi@st.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: <Stable@vger.kernel.org>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index c11f0da86e74..c38563699984 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -356,8 +356,6 @@ static const struct st_sensor_settings st_magn_sensors_settings[] = {
 		.drdy_irq = {
 			.addr = 0x62,
 			.mask_int1 = 0x01,
-			.addr_ihl = 0x63,
-			.mask_ihl = 0x04,
 			.addr_stat_drdy = 0x67,
 		},
 		.multi_read_bit = false,

commit 541ee9b24fca587f510fe1bc58508d5cf40707af
Author: Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>
Date:   Wed Aug 16 19:02:50 2017 +0200

    iio: magnetometer: st_magn: fix status register address for LSM303AGR
    
    Fixes: 97865fe41322 (iio: st_sensors: verify interrupt event to status)
    Signed-off-by: Lorenzo Bianconi <lorenzo.bianconi@st.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: <Stable@vger.kernel.org>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 8e1b0861fbe4..c11f0da86e74 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -358,7 +358,7 @@ static const struct st_sensor_settings st_magn_sensors_settings[] = {
 			.mask_int1 = 0x01,
 			.addr_ihl = 0x63,
 			.mask_ihl = 0x04,
-			.addr_stat_drdy = ST_SENSORS_DEFAULT_STAT_ADDR,
+			.addr_stat_drdy = 0x67,
 		},
 		.multi_read_bit = false,
 		.bootime = 2,

commit d0b7fea58ab91d6363430cbc00b1d1e1b1996552
Author: Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>
Date:   Wed Aug 16 19:02:52 2017 +0200

    iio: magnetometer: add support to LIS2MDL
    
    add support to STMicroelectronics LIS2MDL magnetometer in
    st_magn framework
    
    http://www.st.com/resource/en/datasheet/lis2mdl.pdf
    Signed-off-by: Lorenzo Bianconi <lorenzo.bianconi@st.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 3573636bad8e..703e77008652 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -323,6 +323,7 @@ static const struct st_sensor_settings st_magn_sensors_settings[] = {
 		.wai_addr = 0x4f,
 		.sensors_supported = {
 			[0] = LSM303AGR_MAGN_DEV_NAME,
+			[1] = LIS2MDL_MAGN_DEV_NAME,
 		},
 		.ch = (struct iio_chan_spec *)st_magn_3_16bit_channels,
 		.odr = {

commit 13718564167da80b6169809185b4c5a32497d0c1
Author: Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>
Date:   Tue Jun 20 19:42:45 2017 +0200

    iio: magnetometer: st_magn_core: enable multiread by default for LIS3MDL
    
    Enable multiread by default for LIS3MDL since using I2C interface
    the subaddr Msb is used to automatically increase the slave address
    during multiple data read/write. In the same way, using SPI interface,
    bit 1 in register address is used to enable auto-increment of the slave
    address in multiple read/write.
    
    Fixes: 872e79add756 (iio:magn: Add STMicroelectronics magn driver)
    Signed-off-by: Lorenzo Bianconi <lorenzo.bianconi@st.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 8e1b0861fbe4..3573636bad8e 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -315,7 +315,7 @@ static const struct st_sensor_settings st_magn_sensors_settings[] = {
 				},
 			},
 		},
-		.multi_read_bit = false,
+		.multi_read_bit = true,
 		.bootime = 2,
 	},
 	{

commit 57d035545165a354a52f5d16d46efbb318a2fff4
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Nov 9 16:09:59 2016 +0100

    iio: magn: st_magn: inline per-sensor data
    
    We have #defines for all the individual sensor registers and
    value/mask pairs #defined at the top of the file and used at
    exactly one spot.
    
    This is usually good if the #defines give a meaning to the
    opaque magic numbers.
    
    However in this case, the semantic meaning is inherent in the
    name of the C99-addressable fields, and that means duplication
    of information, and only makes the code hard to maintain since
    you every time have to add a new #define AND update the site
    where it is to be used.
    
    Get rid of the #defines and just open code the values into the
    appropriate struct elements. Make sure to explicitly address
    the .hz and .value fields in the st_sensor_odr_avl struct
    so that the meaning of all values is clear.
    
    This patch is purely syntactic should have no semantic effect.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 3e1f06b2224c..8e1b0861fbe4 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -46,139 +46,12 @@
 #define ST_MAGN_FS_AVL_15000MG			15000
 #define ST_MAGN_FS_AVL_16000MG			16000
 
-/* CUSTOM VALUES FOR SENSOR 0 */
-#define ST_MAGN_0_ODR_ADDR			0x00
-#define ST_MAGN_0_ODR_MASK			0x1c
-#define ST_MAGN_0_ODR_AVL_1HZ_VAL		0x00
-#define ST_MAGN_0_ODR_AVL_2HZ_VAL		0x01
-#define ST_MAGN_0_ODR_AVL_3HZ_VAL		0x02
-#define ST_MAGN_0_ODR_AVL_8HZ_VAL		0x03
-#define ST_MAGN_0_ODR_AVL_15HZ_VAL		0x04
-#define ST_MAGN_0_ODR_AVL_30HZ_VAL		0x05
-#define ST_MAGN_0_ODR_AVL_75HZ_VAL		0x06
-#define ST_MAGN_0_ODR_AVL_220HZ_VAL		0x07
-#define ST_MAGN_0_PW_ADDR			0x02
-#define ST_MAGN_0_PW_MASK			0x03
-#define ST_MAGN_0_PW_ON				0x00
-#define ST_MAGN_0_PW_OFF			0x03
-#define ST_MAGN_0_FS_ADDR			0x01
-#define ST_MAGN_0_FS_MASK			0xe0
-#define ST_MAGN_0_FS_AVL_1300_VAL		0x01
-#define ST_MAGN_0_FS_AVL_1900_VAL		0x02
-#define ST_MAGN_0_FS_AVL_2500_VAL		0x03
-#define ST_MAGN_0_FS_AVL_4000_VAL		0x04
-#define ST_MAGN_0_FS_AVL_4700_VAL		0x05
-#define ST_MAGN_0_FS_AVL_5600_VAL		0x06
-#define ST_MAGN_0_FS_AVL_8100_VAL		0x07
-#define ST_MAGN_0_FS_AVL_1300_GAIN_XY		1100
-#define ST_MAGN_0_FS_AVL_1900_GAIN_XY		855
-#define ST_MAGN_0_FS_AVL_2500_GAIN_XY		670
-#define ST_MAGN_0_FS_AVL_4000_GAIN_XY		450
-#define ST_MAGN_0_FS_AVL_4700_GAIN_XY		400
-#define ST_MAGN_0_FS_AVL_5600_GAIN_XY		330
-#define ST_MAGN_0_FS_AVL_8100_GAIN_XY		230
-#define ST_MAGN_0_FS_AVL_1300_GAIN_Z		980
-#define ST_MAGN_0_FS_AVL_1900_GAIN_Z		760
-#define ST_MAGN_0_FS_AVL_2500_GAIN_Z		600
-#define ST_MAGN_0_FS_AVL_4000_GAIN_Z		400
-#define ST_MAGN_0_FS_AVL_4700_GAIN_Z		355
-#define ST_MAGN_0_FS_AVL_5600_GAIN_Z		295
-#define ST_MAGN_0_FS_AVL_8100_GAIN_Z		205
-#define ST_MAGN_0_MULTIREAD_BIT			false
-
-/* CUSTOM VALUES FOR SENSOR 1 */
-#define ST_MAGN_1_WAI_EXP			0x3c
-#define ST_MAGN_1_ODR_ADDR			0x00
-#define ST_MAGN_1_ODR_MASK			0x1c
-#define ST_MAGN_1_ODR_AVL_1HZ_VAL		0x00
-#define ST_MAGN_1_ODR_AVL_2HZ_VAL		0x01
-#define ST_MAGN_1_ODR_AVL_3HZ_VAL		0x02
-#define ST_MAGN_1_ODR_AVL_8HZ_VAL		0x03
-#define ST_MAGN_1_ODR_AVL_15HZ_VAL		0x04
-#define ST_MAGN_1_ODR_AVL_30HZ_VAL		0x05
-#define ST_MAGN_1_ODR_AVL_75HZ_VAL		0x06
-#define ST_MAGN_1_ODR_AVL_220HZ_VAL		0x07
-#define ST_MAGN_1_PW_ADDR			0x02
-#define ST_MAGN_1_PW_MASK			0x03
-#define ST_MAGN_1_PW_ON				0x00
-#define ST_MAGN_1_PW_OFF			0x03
-#define ST_MAGN_1_FS_ADDR			0x01
-#define ST_MAGN_1_FS_MASK			0xe0
-#define ST_MAGN_1_FS_AVL_1300_VAL		0x01
-#define ST_MAGN_1_FS_AVL_1900_VAL		0x02
-#define ST_MAGN_1_FS_AVL_2500_VAL		0x03
-#define ST_MAGN_1_FS_AVL_4000_VAL		0x04
-#define ST_MAGN_1_FS_AVL_4700_VAL		0x05
-#define ST_MAGN_1_FS_AVL_5600_VAL		0x06
-#define ST_MAGN_1_FS_AVL_8100_VAL		0x07
-#define ST_MAGN_1_FS_AVL_1300_GAIN_XY		909
-#define ST_MAGN_1_FS_AVL_1900_GAIN_XY		1169
-#define ST_MAGN_1_FS_AVL_2500_GAIN_XY		1492
-#define ST_MAGN_1_FS_AVL_4000_GAIN_XY		2222
-#define ST_MAGN_1_FS_AVL_4700_GAIN_XY		2500
-#define ST_MAGN_1_FS_AVL_5600_GAIN_XY		3030
-#define ST_MAGN_1_FS_AVL_8100_GAIN_XY		4347
-#define ST_MAGN_1_FS_AVL_1300_GAIN_Z		1020
-#define ST_MAGN_1_FS_AVL_1900_GAIN_Z		1315
-#define ST_MAGN_1_FS_AVL_2500_GAIN_Z		1666
-#define ST_MAGN_1_FS_AVL_4000_GAIN_Z		2500
-#define ST_MAGN_1_FS_AVL_4700_GAIN_Z		2816
-#define ST_MAGN_1_FS_AVL_5600_GAIN_Z		3389
-#define ST_MAGN_1_FS_AVL_8100_GAIN_Z		4878
-#define ST_MAGN_1_MULTIREAD_BIT			false
-
-/* CUSTOM VALUES FOR SENSOR 2 */
-#define ST_MAGN_2_WAI_EXP			0x3d
-#define ST_MAGN_2_ODR_ADDR			0x20
-#define ST_MAGN_2_ODR_MASK			0x1c
-#define ST_MAGN_2_ODR_AVL_1HZ_VAL		0x00
-#define ST_MAGN_2_ODR_AVL_2HZ_VAL		0x01
-#define ST_MAGN_2_ODR_AVL_3HZ_VAL		0x02
-#define ST_MAGN_2_ODR_AVL_5HZ_VAL		0x03
-#define ST_MAGN_2_ODR_AVL_10HZ_VAL		0x04
-#define ST_MAGN_2_ODR_AVL_20HZ_VAL		0x05
-#define ST_MAGN_2_ODR_AVL_40HZ_VAL		0x06
-#define ST_MAGN_2_ODR_AVL_80HZ_VAL		0x07
-#define ST_MAGN_2_PW_ADDR			0x22
-#define ST_MAGN_2_PW_MASK			0x03
-#define ST_MAGN_2_PW_ON				0x00
-#define ST_MAGN_2_PW_OFF			0x03
-#define ST_MAGN_2_FS_ADDR			0x21
-#define ST_MAGN_2_FS_MASK			0x60
-#define ST_MAGN_2_FS_AVL_4000_VAL		0x00
-#define ST_MAGN_2_FS_AVL_8000_VAL		0x01
-#define ST_MAGN_2_FS_AVL_12000_VAL		0x02
-#define ST_MAGN_2_FS_AVL_16000_VAL		0x03
-#define ST_MAGN_2_FS_AVL_4000_GAIN		146
-#define ST_MAGN_2_FS_AVL_8000_GAIN		292
-#define ST_MAGN_2_FS_AVL_12000_GAIN		438
-#define ST_MAGN_2_FS_AVL_16000_GAIN		584
-#define ST_MAGN_2_MULTIREAD_BIT			false
+/* Special L addresses for Sensor 2 */
 #define ST_MAGN_2_OUT_X_L_ADDR			0x28
 #define ST_MAGN_2_OUT_Y_L_ADDR			0x2a
 #define ST_MAGN_2_OUT_Z_L_ADDR			0x2c
 
-/* CUSTOM VALUES FOR SENSOR 3 */
-#define ST_MAGN_3_WAI_ADDR			0x4f
-#define ST_MAGN_3_WAI_EXP			0x40
-#define ST_MAGN_3_ODR_ADDR			0x60
-#define ST_MAGN_3_ODR_MASK			0x0c
-#define ST_MAGN_3_ODR_AVL_10HZ_VAL		0x00
-#define ST_MAGN_3_ODR_AVL_20HZ_VAL		0x01
-#define ST_MAGN_3_ODR_AVL_50HZ_VAL		0x02
-#define ST_MAGN_3_ODR_AVL_100HZ_VAL		0x03
-#define ST_MAGN_3_PW_ADDR			0x60
-#define ST_MAGN_3_PW_MASK			0x03
-#define ST_MAGN_3_PW_ON				0x00
-#define ST_MAGN_3_PW_OFF			0x03
-#define ST_MAGN_3_BDU_ADDR			0x62
-#define ST_MAGN_3_BDU_MASK			0x10
-#define ST_MAGN_3_DRDY_IRQ_ADDR			0x62
-#define ST_MAGN_3_DRDY_INT_MASK			0x01
-#define ST_MAGN_3_IHL_IRQ_ADDR			0x63
-#define ST_MAGN_3_IHL_IRQ_MASK			0x04
-#define ST_MAGN_3_FS_AVL_15000_GAIN		1500
-#define ST_MAGN_3_MULTIREAD_BIT			false
+/* Special L addresses for sensor 3 */
 #define ST_MAGN_3_OUT_X_L_ADDR			0x68
 #define ST_MAGN_3_OUT_Y_L_ADDR			0x6a
 #define ST_MAGN_3_OUT_Z_L_ADDR			0x6c
@@ -240,77 +113,78 @@ static const struct st_sensor_settings st_magn_sensors_settings[] = {
 		},
 		.ch = (struct iio_chan_spec *)st_magn_16bit_channels,
 		.odr = {
-			.addr = ST_MAGN_0_ODR_ADDR,
-			.mask = ST_MAGN_0_ODR_MASK,
+			.addr = 0x00,
+			.mask = 0x1c,
 			.odr_avl = {
-				{ 1, ST_MAGN_0_ODR_AVL_1HZ_VAL, },
-				{ 2, ST_MAGN_0_ODR_AVL_2HZ_VAL, },
-				{ 3, ST_MAGN_0_ODR_AVL_3HZ_VAL, },
-				{ 8, ST_MAGN_0_ODR_AVL_8HZ_VAL, },
-				{ 15, ST_MAGN_0_ODR_AVL_15HZ_VAL, },
-				{ 30, ST_MAGN_0_ODR_AVL_30HZ_VAL, },
-				{ 75, ST_MAGN_0_ODR_AVL_75HZ_VAL, },
+				{ .hz = 1, .value = 0x00 },
+				{ .hz = 2, .value = 0x01 },
+				{ .hz = 3, .value = 0x02 },
+				{ .hz = 8, .value = 0x03 },
+				{ .hz = 15, .value = 0x04 },
+				{ .hz = 30, .value = 0x05 },
+				{ .hz = 75, .value = 0x06 },
+				/* 220 Hz, 0x07 reportedly exist */
 			},
 		},
 		.pw = {
-			.addr = ST_MAGN_0_PW_ADDR,
-			.mask = ST_MAGN_0_PW_MASK,
-			.value_on = ST_MAGN_0_PW_ON,
-			.value_off = ST_MAGN_0_PW_OFF,
+			.addr = 0x02,
+			.mask = 0x03,
+			.value_on = 0x00,
+			.value_off = 0x03,
 		},
 		.fs = {
-			.addr = ST_MAGN_0_FS_ADDR,
-			.mask = ST_MAGN_0_FS_MASK,
+			.addr = 0x01,
+			.mask = 0xe0,
 			.fs_avl = {
 				[0] = {
 					.num = ST_MAGN_FS_AVL_1300MG,
-					.value = ST_MAGN_0_FS_AVL_1300_VAL,
-					.gain = ST_MAGN_0_FS_AVL_1300_GAIN_XY,
-					.gain2 = ST_MAGN_0_FS_AVL_1300_GAIN_Z,
+					.value = 0x01,
+					.gain = 1100,
+					.gain2 = 980,
 				},
 				[1] = {
 					.num = ST_MAGN_FS_AVL_1900MG,
-					.value = ST_MAGN_0_FS_AVL_1900_VAL,
-					.gain = ST_MAGN_0_FS_AVL_1900_GAIN_XY,
-					.gain2 = ST_MAGN_0_FS_AVL_1900_GAIN_Z,
+					.value = 0x02,
+					.gain = 855,
+					.gain2 = 760,
 				},
 				[2] = {
 					.num = ST_MAGN_FS_AVL_2500MG,
-					.value = ST_MAGN_0_FS_AVL_2500_VAL,
-					.gain = ST_MAGN_0_FS_AVL_2500_GAIN_XY,
-					.gain2 = ST_MAGN_0_FS_AVL_2500_GAIN_Z,
+					.value = 0x03,
+					.gain = 670,
+					.gain2 = 600,
 				},
 				[3] = {
 					.num = ST_MAGN_FS_AVL_4000MG,
-					.value = ST_MAGN_0_FS_AVL_4000_VAL,
-					.gain = ST_MAGN_0_FS_AVL_4000_GAIN_XY,
-					.gain2 = ST_MAGN_0_FS_AVL_4000_GAIN_Z,
+					.value = 0x04,
+					.gain = 450,
+					.gain2 = 400,
 				},
 				[4] = {
 					.num = ST_MAGN_FS_AVL_4700MG,
-					.value = ST_MAGN_0_FS_AVL_4700_VAL,
-					.gain = ST_MAGN_0_FS_AVL_4700_GAIN_XY,
-					.gain2 = ST_MAGN_0_FS_AVL_4700_GAIN_Z,
+					.value = 0x05,
+					.gain = 400,
+					.gain2 = 355,
 				},
 				[5] = {
 					.num = ST_MAGN_FS_AVL_5600MG,
-					.value = ST_MAGN_0_FS_AVL_5600_VAL,
-					.gain = ST_MAGN_0_FS_AVL_5600_GAIN_XY,
-					.gain2 = ST_MAGN_0_FS_AVL_5600_GAIN_Z,
+					.value = 0x06,
+					.gain = 330,
+					.gain2 = 295,
 				},
 				[6] = {
 					.num = ST_MAGN_FS_AVL_8100MG,
-					.value = ST_MAGN_0_FS_AVL_8100_VAL,
-					.gain = ST_MAGN_0_FS_AVL_8100_GAIN_XY,
-					.gain2 = ST_MAGN_0_FS_AVL_8100_GAIN_Z,
+					.value = 0x07,
+					.gain = 230,
+					.gain2 = 205,
 				},
 			},
 		},
-		.multi_read_bit = ST_MAGN_0_MULTIREAD_BIT,
+		.multi_read_bit = false,
 		.bootime = 2,
 	},
 	{
-		.wai = ST_MAGN_1_WAI_EXP,
+		.wai = 0x3c,
 		.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,
 		.sensors_supported = {
 			[0] = LSM303DLHC_MAGN_DEV_NAME,
@@ -318,175 +192,175 @@ static const struct st_sensor_settings st_magn_sensors_settings[] = {
 		},
 		.ch = (struct iio_chan_spec *)st_magn_16bit_channels,
 		.odr = {
-			.addr = ST_MAGN_1_ODR_ADDR,
-			.mask = ST_MAGN_1_ODR_MASK,
+			.addr = 0x00,
+			.mask = 0x1c,
 			.odr_avl = {
-				{ 1, ST_MAGN_1_ODR_AVL_1HZ_VAL, },
-				{ 2, ST_MAGN_1_ODR_AVL_2HZ_VAL, },
-				{ 3, ST_MAGN_1_ODR_AVL_3HZ_VAL, },
-				{ 8, ST_MAGN_1_ODR_AVL_8HZ_VAL, },
-				{ 15, ST_MAGN_1_ODR_AVL_15HZ_VAL, },
-				{ 30, ST_MAGN_1_ODR_AVL_30HZ_VAL, },
-				{ 75, ST_MAGN_1_ODR_AVL_75HZ_VAL, },
-				{ 220, ST_MAGN_1_ODR_AVL_220HZ_VAL, },
+				{ .hz = 1, .value = 0x00 },
+				{ .hz = 2, .value = 0x01 },
+				{ .hz = 3, .value = 0x02 },
+				{ .hz = 8, .value = 0x03 },
+				{ .hz = 15, .value = 0x04 },
+				{ .hz = 30, .value = 0x05 },
+				{ .hz = 75, .value = 0x06 },
+				{ .hz = 220, .value = 0x07 },
 			},
 		},
 		.pw = {
-			.addr = ST_MAGN_1_PW_ADDR,
-			.mask = ST_MAGN_1_PW_MASK,
-			.value_on = ST_MAGN_1_PW_ON,
-			.value_off = ST_MAGN_1_PW_OFF,
+			.addr = 0x02,
+			.mask = 0x03,
+			.value_on = 0x00,
+			.value_off = 0x03,
 		},
 		.fs = {
-			.addr = ST_MAGN_1_FS_ADDR,
-			.mask = ST_MAGN_1_FS_MASK,
+			.addr = 0x01,
+			.mask = 0xe0,
 			.fs_avl = {
 				[0] = {
 					.num = ST_MAGN_FS_AVL_1300MG,
-					.value = ST_MAGN_1_FS_AVL_1300_VAL,
-					.gain = ST_MAGN_1_FS_AVL_1300_GAIN_XY,
-					.gain2 = ST_MAGN_1_FS_AVL_1300_GAIN_Z,
+					.value = 0x01,
+					.gain = 909,
+					.gain2 = 1020,
 				},
 				[1] = {
 					.num = ST_MAGN_FS_AVL_1900MG,
-					.value = ST_MAGN_1_FS_AVL_1900_VAL,
-					.gain = ST_MAGN_1_FS_AVL_1900_GAIN_XY,
-					.gain2 = ST_MAGN_1_FS_AVL_1900_GAIN_Z,
+					.value = 0x02,
+					.gain = 1169,
+					.gain2 = 1315,
 				},
 				[2] = {
 					.num = ST_MAGN_FS_AVL_2500MG,
-					.value = ST_MAGN_1_FS_AVL_2500_VAL,
-					.gain = ST_MAGN_1_FS_AVL_2500_GAIN_XY,
-					.gain2 = ST_MAGN_1_FS_AVL_2500_GAIN_Z,
+					.value = 0x03,
+					.gain = 1492,
+					.gain2 = 1666,
 				},
 				[3] = {
 					.num = ST_MAGN_FS_AVL_4000MG,
-					.value = ST_MAGN_1_FS_AVL_4000_VAL,
-					.gain = ST_MAGN_1_FS_AVL_4000_GAIN_XY,
-					.gain2 = ST_MAGN_1_FS_AVL_4000_GAIN_Z,
+					.value = 0x04,
+					.gain = 2222,
+					.gain2 = 2500,
 				},
 				[4] = {
 					.num = ST_MAGN_FS_AVL_4700MG,
-					.value = ST_MAGN_1_FS_AVL_4700_VAL,
-					.gain = ST_MAGN_1_FS_AVL_4700_GAIN_XY,
-					.gain2 = ST_MAGN_1_FS_AVL_4700_GAIN_Z,
+					.value = 0x05,
+					.gain = 2500,
+					.gain2 = 2816,
 				},
 				[5] = {
 					.num = ST_MAGN_FS_AVL_5600MG,
-					.value = ST_MAGN_1_FS_AVL_5600_VAL,
-					.gain = ST_MAGN_1_FS_AVL_5600_GAIN_XY,
-					.gain2 = ST_MAGN_1_FS_AVL_5600_GAIN_Z,
+					.value = 0x06,
+					.gain = 3030,
+					.gain2 = 3389,
 				},
 				[6] = {
 					.num = ST_MAGN_FS_AVL_8100MG,
-					.value = ST_MAGN_1_FS_AVL_8100_VAL,
-					.gain = ST_MAGN_1_FS_AVL_8100_GAIN_XY,
-					.gain2 = ST_MAGN_1_FS_AVL_8100_GAIN_Z,
+					.value = 0x07,
+					.gain = 4347,
+					.gain2 = 4878,
 				},
 			},
 		},
-		.multi_read_bit = ST_MAGN_1_MULTIREAD_BIT,
+		.multi_read_bit = false,
 		.bootime = 2,
 	},
 	{
-		.wai = ST_MAGN_2_WAI_EXP,
+		.wai = 0x3d,
 		.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,
 		.sensors_supported = {
 			[0] = LIS3MDL_MAGN_DEV_NAME,
 		},
 		.ch = (struct iio_chan_spec *)st_magn_2_16bit_channels,
 		.odr = {
-			.addr = ST_MAGN_2_ODR_ADDR,
-			.mask = ST_MAGN_2_ODR_MASK,
+			.addr = 0x20,
+			.mask = 0x1c,
 			.odr_avl = {
-				{ 1, ST_MAGN_2_ODR_AVL_1HZ_VAL, },
-				{ 2, ST_MAGN_2_ODR_AVL_2HZ_VAL, },
-				{ 3, ST_MAGN_2_ODR_AVL_3HZ_VAL, },
-				{ 5, ST_MAGN_2_ODR_AVL_5HZ_VAL, },
-				{ 10, ST_MAGN_2_ODR_AVL_10HZ_VAL, },
-				{ 20, ST_MAGN_2_ODR_AVL_20HZ_VAL, },
-				{ 40, ST_MAGN_2_ODR_AVL_40HZ_VAL, },
-				{ 80, ST_MAGN_2_ODR_AVL_80HZ_VAL, },
+				{ .hz = 1, .value = 0x00 },
+				{ .hz = 2, .value = 0x01 },
+				{ .hz = 3, .value = 0x02 },
+				{ .hz = 5, .value = 0x03 },
+				{ .hz = 10, .value = 0x04 },
+				{ .hz = 20, .value = 0x05 },
+				{ .hz = 40, .value = 0x06 },
+				{ .hz = 80, .value = 0x07 },
 			},
 		},
 		.pw = {
-			.addr = ST_MAGN_2_PW_ADDR,
-			.mask = ST_MAGN_2_PW_MASK,
-			.value_on = ST_MAGN_2_PW_ON,
-			.value_off = ST_MAGN_2_PW_OFF,
+			.addr = 0x22,
+			.mask = 0x03,
+			.value_on = 0x00,
+			.value_off = 0x03,
 		},
 		.fs = {
-			.addr = ST_MAGN_2_FS_ADDR,
-			.mask = ST_MAGN_2_FS_MASK,
+			.addr = 0x21,
+			.mask = 0x60,
 			.fs_avl = {
 				[0] = {
 					.num = ST_MAGN_FS_AVL_4000MG,
-					.value = ST_MAGN_2_FS_AVL_4000_VAL,
-					.gain = ST_MAGN_2_FS_AVL_4000_GAIN,
+					.value = 0x00,
+					.gain = 146,
 				},
 				[1] = {
 					.num = ST_MAGN_FS_AVL_8000MG,
-					.value = ST_MAGN_2_FS_AVL_8000_VAL,
-					.gain = ST_MAGN_2_FS_AVL_8000_GAIN,
+					.value = 0x01,
+					.gain = 292,
 				},
 				[2] = {
 					.num = ST_MAGN_FS_AVL_12000MG,
-					.value = ST_MAGN_2_FS_AVL_12000_VAL,
-					.gain = ST_MAGN_2_FS_AVL_12000_GAIN,
+					.value = 0x02,
+					.gain = 438,
 				},
 				[3] = {
 					.num = ST_MAGN_FS_AVL_16000MG,
-					.value = ST_MAGN_2_FS_AVL_16000_VAL,
-					.gain = ST_MAGN_2_FS_AVL_16000_GAIN,
+					.value = 0x03,
+					.gain = 584,
 				},
 			},
 		},
-		.multi_read_bit = ST_MAGN_2_MULTIREAD_BIT,
+		.multi_read_bit = false,
 		.bootime = 2,
 	},
 	{
-		.wai = ST_MAGN_3_WAI_EXP,
-		.wai_addr = ST_MAGN_3_WAI_ADDR,
+		.wai = 0x40,
+		.wai_addr = 0x4f,
 		.sensors_supported = {
 			[0] = LSM303AGR_MAGN_DEV_NAME,
 		},
 		.ch = (struct iio_chan_spec *)st_magn_3_16bit_channels,
 		.odr = {
-			.addr = ST_MAGN_3_ODR_ADDR,
-			.mask = ST_MAGN_3_ODR_MASK,
+			.addr = 0x60,
+			.mask = 0x0c,
 			.odr_avl = {
-				{ 10, ST_MAGN_3_ODR_AVL_10HZ_VAL, },
-				{ 20, ST_MAGN_3_ODR_AVL_20HZ_VAL, },
-				{ 50, ST_MAGN_3_ODR_AVL_50HZ_VAL, },
-				{ 100, ST_MAGN_3_ODR_AVL_100HZ_VAL, },
+				{ .hz = 10, .value = 0x00 },
+				{ .hz = 20, .value = 0x01 },
+				{ .hz = 50, .value = 0x02 },
+				{ .hz = 100, .value = 0x03 },
 			},
 		},
 		.pw = {
-			.addr = ST_MAGN_3_PW_ADDR,
-			.mask = ST_MAGN_3_PW_MASK,
-			.value_on = ST_MAGN_3_PW_ON,
-			.value_off = ST_MAGN_3_PW_OFF,
+			.addr = 0x60,
+			.mask = 0x03,
+			.value_on = 0x00,
+			.value_off = 0x03,
 		},
 		.fs = {
 			.fs_avl = {
 				[0] = {
 					.num = ST_MAGN_FS_AVL_15000MG,
-					.gain = ST_MAGN_3_FS_AVL_15000_GAIN,
+					.gain = 1500,
 				},
 			},
 		},
 		.bdu = {
-			.addr = ST_MAGN_3_BDU_ADDR,
-			.mask = ST_MAGN_3_BDU_MASK,
+			.addr = 0x62,
+			.mask = 0x10,
 		},
 		.drdy_irq = {
-			.addr = ST_MAGN_3_DRDY_IRQ_ADDR,
-			.mask_int1 = ST_MAGN_3_DRDY_INT_MASK,
-			.addr_ihl = ST_MAGN_3_IHL_IRQ_ADDR,
-			.mask_ihl = ST_MAGN_3_IHL_IRQ_MASK,
+			.addr = 0x62,
+			.mask_int1 = 0x01,
+			.addr_ihl = 0x63,
+			.mask_ihl = 0x04,
 			.addr_stat_drdy = ST_SENSORS_DEFAULT_STAT_ADDR,
 		},
-		.multi_read_bit = ST_MAGN_3_MULTIREAD_BIT,
+		.multi_read_bit = false,
 		.bootime = 2,
 	},
 };

commit af52739b922f656eb1f39016fabaabe4baeda2e2
Merge: 25ed6a5e9780 33688abb2802
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jun 20 08:25:44 2016 -0700

    Merge 4.7-rc4 into staging-next
    
    We want the fixes in here, and we can resolve a merge issue in
    drivers/iio/industrialio-trigger.c
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 65925b65ed98ffdb277cf5ea1af45731dac0b30b
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sat May 21 20:43:16 2016 +0200

    iio: st_sensors: switch to a threaded interrupt
    
    commit 98ad8b41f58dff6b30713d7f09ae3834b8df7ded
    ("iio: st_sensors: verify interrupt event to status") caused
    a regression when reading ST sensors from a HRTimer trigger
    rather than the intrinsic interrupts: the HRTimer may
    trigger faster than the sensor provides new values, and
    as the check against new values available as a cause of
    the interrupt trigger was done in the poll function,
    this would bail out of the HRTimer interrupt with
    IRQ_NONE.
    
    So clearly we need to only check the new values available
    from the proper interrupt handler and not from the poll
    function, which should rather just read the raw values
    from the registers, put them into the buffer and be happy.
    
    To achieve this: switch the ST Sensors over to using a true
    threaded interrupt handler.
    
    In the interrupt thread, check if new values are available,
    else yield to the (potential) next device on the same
    interrupt line to check the registers. If the interrupt
    was ours, proceed to poll the values.
    
    Instead of relying on iio_trigger_generic_data_rdy_poll() as
    a top half to wake up the thread that polls the sensor for
    new data, have the thread call iio_trigger_poll_chained()
    after determining that is is the proper source of the
    interrupt. This is modelled on drivers/iio/accel/mma8452.c
    which is already using a properly threaded interrupt handler.
    
    In order to get the same precision in timestamps as
    previously, where samples would be timestamped in the
    poll function pf->timestamp when calling
    iio_trigger_generic_data_rdy_poll() we introduce a
    local timestamp in the sensor data, set it in the top half
    (fastpath) of the interrupt handler and provide that to the
    core when calling iio_push_to_buffers_with_timestamp().
    
    Additionally: if the active scanmask is not set for the
    sensor no IRQs should be enabled and we need to bail out
    with IRQ_NONE. This can happen if spurious IRQs fire when
    installing the threaded interrupt handler.
    
    Tested with hard interrupt triggers on LIS331DL, then also
    tested with hrtimers on the same sensor by creating a 75Hz
    HRTimer and using it to poll the sensor.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Giuseppe Barba <giuseppe.barba@st.com>
    Cc: Denis Ciocca <denis.ciocca@st.com>
    Reported-by: Crestez Dan Leonard <cdleonard@gmail.com>
    Tested-by: Crestez Dan Leonard <cdleonard@gmail.com>
    Tested-by: Jonathan Cameron <jic23@kernel.org>
    Fixes: 97865fe41322 ("iio: st_sensors: verify interrupt event to status")
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 62036d2a9956..8250fc322c56 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -572,6 +572,7 @@ static const struct iio_info magn_info = {
 static const struct iio_trigger_ops st_magn_trigger_ops = {
 	.owner = THIS_MODULE,
 	.set_trigger_state = ST_MAGN_TRIGGER_SET_STATE,
+	.validate_device = st_sensors_validate_device,
 };
 #define ST_MAGN_TRIGGER_OPS (&st_magn_trigger_ops)
 #else

commit 14f295c846063c4f1812b09427195cee522aa006
Author: Gregor Boirie <gregor.boirie@parrot.com>
Date:   Tue Apr 19 11:18:40 2016 +0200

    iio:st_sensors: fix power regulator usage
    
    Ensure failure to enable power regulators is properly handled.
    
    Signed-off-by: Gregor Boirie <gregor.boirie@parrot.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 62036d2a9956..7c94adc3ff1d 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -588,13 +588,15 @@ int st_magn_common_probe(struct iio_dev *indio_dev)
 	indio_dev->info = &magn_info;
 	mutex_init(&mdata->tb.buf_lock);
 
-	st_sensors_power_enable(indio_dev);
+	err = st_sensors_power_enable(indio_dev);
+	if (err)
+		return err;
 
 	err = st_sensors_check_device_support(indio_dev,
 					ARRAY_SIZE(st_magn_sensors_settings),
 					st_magn_sensors_settings);
 	if (err < 0)
-		return err;
+		goto st_magn_power_off;
 
 	mdata->num_data_channels = ST_MAGN_NUMBER_DATA_CHANNELS;
 	mdata->multiread_bit = mdata->sensor_settings->multi_read_bit;
@@ -607,11 +609,11 @@ int st_magn_common_probe(struct iio_dev *indio_dev)
 
 	err = st_sensors_init_sensor(indio_dev, NULL);
 	if (err < 0)
-		return err;
+		goto st_magn_power_off;
 
 	err = st_magn_allocate_ring(indio_dev);
 	if (err < 0)
-		return err;
+		goto st_magn_power_off;
 
 	if (irq > 0) {
 		err = st_sensors_allocate_trigger(indio_dev,
@@ -634,6 +636,8 @@ int st_magn_common_probe(struct iio_dev *indio_dev)
 		st_sensors_deallocate_trigger(indio_dev);
 st_magn_probe_trigger_error:
 	st_magn_deallocate_ring(indio_dev);
+st_magn_power_off:
+	st_sensors_power_disable(indio_dev);
 
 	return err;
 }

commit 97865fe41322d83dac4373fe0a0de5b1a1b318c5
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Mar 24 14:18:05 2016 +0100

    iio: st_sensors: verify interrupt event to status
    
    This makes all ST sensor drivers check that they actually have
    new data available for the requested channel(s) before claiming
    an IRQ, by reading the status register (which is conveniently
    the same for all ST sensors) and check that the channel has new
    data before proceeding to read it and fill the buffer.
    
    This way sensors can share an interrupt line: it can be flaged
    as shared and then the sensor that did not fire will return
    NO_IRQ, and the sensor that fired will handle the IRQ and
    return IRQ_HANDLED.
    
    Cc: Giuseppe Barba <giuseppe.barba@st.com>
    Cc: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 501f858df413..62036d2a9956 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -484,6 +484,7 @@ static const struct st_sensor_settings st_magn_sensors_settings[] = {
 			.mask_int1 = ST_MAGN_3_DRDY_INT_MASK,
 			.addr_ihl = ST_MAGN_3_IHL_IRQ_ADDR,
 			.mask_ihl = ST_MAGN_3_IHL_IRQ_MASK,
+			.addr_stat_drdy = ST_SENSORS_DEFAULT_STAT_ADDR,
 		},
 		.multi_read_bit = ST_MAGN_3_MULTIREAD_BIT,
 		.bootime = 2,

commit a9fd053b56c6bb14972ab7a19da0b575fe4c5d66
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Nov 19 10:15:17 2015 +0100

    iio: st_sensors: support active-low interrupts
    
    Most ST MEMS Sensors that support interrupts can also handle sending
    an active low interrupt, i.e. going from high to low on data ready
    (or other interrupt) and thus triggering on a falling edge to the
    interrupt controller.
    
    Set up logic to inspect the interrupt line we get for a sensor: if
    it is triggering on rising edge, leave everything alone, but if it
    triggers on falling edges, set up active low, and if unsupported
    configurations appear: warn with errors and reconfigure the interrupt
    to a rising edge, which all interrupt generating sensors support.
    
    Create a local header for st_sensors_core.h to share functions
    between the sensor core and the trigger setup code.
    
    Cc: Giuseppe Barba <giuseppe.barba@st.com>
    Cc: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index b27f0146647b..501f858df413 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -175,6 +175,8 @@
 #define ST_MAGN_3_BDU_MASK			0x10
 #define ST_MAGN_3_DRDY_IRQ_ADDR			0x62
 #define ST_MAGN_3_DRDY_INT_MASK			0x01
+#define ST_MAGN_3_IHL_IRQ_ADDR			0x63
+#define ST_MAGN_3_IHL_IRQ_MASK			0x04
 #define ST_MAGN_3_FS_AVL_15000_GAIN		1500
 #define ST_MAGN_3_MULTIREAD_BIT			false
 #define ST_MAGN_3_OUT_X_L_ADDR			0x68
@@ -480,6 +482,8 @@ static const struct st_sensor_settings st_magn_sensors_settings[] = {
 		.drdy_irq = {
 			.addr = ST_MAGN_3_DRDY_IRQ_ADDR,
 			.mask_int1 = ST_MAGN_3_DRDY_INT_MASK,
+			.addr_ihl = ST_MAGN_3_IHL_IRQ_ADDR,
+			.mask_ihl = ST_MAGN_3_IHL_IRQ_MASK,
 		},
 		.multi_read_bit = ST_MAGN_3_MULTIREAD_BIT,
 		.bootime = 2,

commit a0175b9c76f59c1f5706f986d690e27ba06363dd
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Aug 12 10:22:41 2015 +0200

    iio: st_sensors: add debugfs register read hook
    
    This adds a debugfs hook to read/write registers in the ST
    sensors using debugfs. Proved to be awesome help when trying
    to debug why IRQs do not arrive.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index f8dc4b85d70c..b27f0146647b 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -560,6 +560,7 @@ static const struct iio_info magn_info = {
 	.attrs = &st_magn_attribute_group,
 	.read_raw = &st_magn_read_raw,
 	.write_raw = &st_magn_write_raw,
+	.debugfs_reg_access = &st_sensors_debugfs_reg_access,
 };
 
 #ifdef CONFIG_IIO_TRIGGER

commit 1e9676a8474b657b6a793f0abff2205783a1ce6f
Author: Giuseppe Barba <giuseppe.barba@st.com>
Date:   Tue Jul 21 10:35:45 2015 +0200

    iio: st-magn: add support for lsm303agr magnetometer
    
    This adds support for the lsm303agr magnetometer.
    
    Signed-off-by: Giuseppe Barba <giuseppe.barba@st.com>
    Acked-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 4c0cef865517..f8dc4b85d70c 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -43,6 +43,7 @@
 #define ST_MAGN_FS_AVL_8000MG			8000
 #define ST_MAGN_FS_AVL_8100MG			8100
 #define ST_MAGN_FS_AVL_12000MG			12000
+#define ST_MAGN_FS_AVL_15000MG			15000
 #define ST_MAGN_FS_AVL_16000MG			16000
 
 /* CUSTOM VALUES FOR SENSOR 0 */
@@ -157,6 +158,29 @@
 #define ST_MAGN_2_OUT_Y_L_ADDR			0x2a
 #define ST_MAGN_2_OUT_Z_L_ADDR			0x2c
 
+/* CUSTOM VALUES FOR SENSOR 3 */
+#define ST_MAGN_3_WAI_ADDR			0x4f
+#define ST_MAGN_3_WAI_EXP			0x40
+#define ST_MAGN_3_ODR_ADDR			0x60
+#define ST_MAGN_3_ODR_MASK			0x0c
+#define ST_MAGN_3_ODR_AVL_10HZ_VAL		0x00
+#define ST_MAGN_3_ODR_AVL_20HZ_VAL		0x01
+#define ST_MAGN_3_ODR_AVL_50HZ_VAL		0x02
+#define ST_MAGN_3_ODR_AVL_100HZ_VAL		0x03
+#define ST_MAGN_3_PW_ADDR			0x60
+#define ST_MAGN_3_PW_MASK			0x03
+#define ST_MAGN_3_PW_ON				0x00
+#define ST_MAGN_3_PW_OFF			0x03
+#define ST_MAGN_3_BDU_ADDR			0x62
+#define ST_MAGN_3_BDU_MASK			0x10
+#define ST_MAGN_3_DRDY_IRQ_ADDR			0x62
+#define ST_MAGN_3_DRDY_INT_MASK			0x01
+#define ST_MAGN_3_FS_AVL_15000_GAIN		1500
+#define ST_MAGN_3_MULTIREAD_BIT			false
+#define ST_MAGN_3_OUT_X_L_ADDR			0x68
+#define ST_MAGN_3_OUT_Y_L_ADDR			0x6a
+#define ST_MAGN_3_OUT_Z_L_ADDR			0x6c
+
 static const struct iio_chan_spec st_magn_16bit_channels[] = {
 	ST_SENSORS_LSM_CHANNELS(IIO_MAGN,
 			BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),
@@ -189,6 +213,22 @@ static const struct iio_chan_spec st_magn_2_16bit_channels[] = {
 	IIO_CHAN_SOFT_TIMESTAMP(3)
 };
 
+static const struct iio_chan_spec st_magn_3_16bit_channels[] = {
+	ST_SENSORS_LSM_CHANNELS(IIO_MAGN,
+			BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),
+			ST_SENSORS_SCAN_X, 1, IIO_MOD_X, 's', IIO_LE, 16, 16,
+			ST_MAGN_3_OUT_X_L_ADDR),
+	ST_SENSORS_LSM_CHANNELS(IIO_MAGN,
+			BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),
+			ST_SENSORS_SCAN_Y, 1, IIO_MOD_Y, 's', IIO_LE, 16, 16,
+			ST_MAGN_3_OUT_Y_L_ADDR),
+	ST_SENSORS_LSM_CHANNELS(IIO_MAGN,
+			BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),
+			ST_SENSORS_SCAN_Z, 1, IIO_MOD_Z, 's', IIO_LE, 16, 16,
+			ST_MAGN_3_OUT_Z_L_ADDR),
+	IIO_CHAN_SOFT_TIMESTAMP(3)
+};
+
 static const struct st_sensor_settings st_magn_sensors_settings[] = {
 	{
 		.wai = 0, /* This sensor has no valid WhoAmI report 0 */
@@ -402,6 +442,48 @@ static const struct st_sensor_settings st_magn_sensors_settings[] = {
 		.multi_read_bit = ST_MAGN_2_MULTIREAD_BIT,
 		.bootime = 2,
 	},
+	{
+		.wai = ST_MAGN_3_WAI_EXP,
+		.wai_addr = ST_MAGN_3_WAI_ADDR,
+		.sensors_supported = {
+			[0] = LSM303AGR_MAGN_DEV_NAME,
+		},
+		.ch = (struct iio_chan_spec *)st_magn_3_16bit_channels,
+		.odr = {
+			.addr = ST_MAGN_3_ODR_ADDR,
+			.mask = ST_MAGN_3_ODR_MASK,
+			.odr_avl = {
+				{ 10, ST_MAGN_3_ODR_AVL_10HZ_VAL, },
+				{ 20, ST_MAGN_3_ODR_AVL_20HZ_VAL, },
+				{ 50, ST_MAGN_3_ODR_AVL_50HZ_VAL, },
+				{ 100, ST_MAGN_3_ODR_AVL_100HZ_VAL, },
+			},
+		},
+		.pw = {
+			.addr = ST_MAGN_3_PW_ADDR,
+			.mask = ST_MAGN_3_PW_MASK,
+			.value_on = ST_MAGN_3_PW_ON,
+			.value_off = ST_MAGN_3_PW_OFF,
+		},
+		.fs = {
+			.fs_avl = {
+				[0] = {
+					.num = ST_MAGN_FS_AVL_15000MG,
+					.gain = ST_MAGN_3_FS_AVL_15000_GAIN,
+				},
+			},
+		},
+		.bdu = {
+			.addr = ST_MAGN_3_BDU_ADDR,
+			.mask = ST_MAGN_3_BDU_MASK,
+		},
+		.drdy_irq = {
+			.addr = ST_MAGN_3_DRDY_IRQ_ADDR,
+			.mask_int1 = ST_MAGN_3_DRDY_INT_MASK,
+		},
+		.multi_read_bit = ST_MAGN_3_MULTIREAD_BIT,
+		.bootime = 2,
+	},
 };
 
 static int st_magn_read_raw(struct iio_dev *indio_dev,

commit 74f5683f35fe6feae33b96815c1d40f13468d614
Author: Giuseppe Barba <giuseppe.barba@st.com>
Date:   Tue Jul 21 10:35:43 2015 +0200

    iio: st_magn: Add irq trigger handling
    
    Add irq trigger handling for magnetometer also
    
    Signed-off-by: Giuseppe Barba <giuseppe.barba@st.com>
    Acked-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 8d7d3a172874..4c0cef865517 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -480,6 +480,16 @@ static const struct iio_info magn_info = {
 	.write_raw = &st_magn_write_raw,
 };
 
+#ifdef CONFIG_IIO_TRIGGER
+static const struct iio_trigger_ops st_magn_trigger_ops = {
+	.owner = THIS_MODULE,
+	.set_trigger_state = ST_MAGN_TRIGGER_SET_STATE,
+};
+#define ST_MAGN_TRIGGER_OPS (&st_magn_trigger_ops)
+#else
+#define ST_MAGN_TRIGGER_OPS NULL
+#endif
+
 int st_magn_common_probe(struct iio_dev *indio_dev)
 {
 	struct st_sensor_data *mdata = iio_priv(indio_dev);
@@ -516,7 +526,8 @@ int st_magn_common_probe(struct iio_dev *indio_dev)
 		return err;
 
 	if (irq > 0) {
-		err = st_sensors_allocate_trigger(indio_dev, NULL);
+		err = st_sensors_allocate_trigger(indio_dev,
+						ST_MAGN_TRIGGER_OPS);
 		if (err < 0)
 			goto st_magn_probe_trigger_error;
 	}

commit bc27381edbeb654d819b7e1464091c456a0d3e64
Author: Giuseppe Barba <giuseppe.barba@st.com>
Date:   Tue Jul 21 10:35:41 2015 +0200

    iio: st-sensors: add configuration for WhoAmI address
    
    This patch permits to configure the WhoAmI register address
    because some device could have not a standard address for
    this register.
    
    Signed-off-by: Giuseppe Barba <giuseppe.barba@st.com>
    Reviewed-by: Denis Ciocca <denis.ciocca@st.com>
    Acked-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index b4bcfb790f49..8d7d3a172874 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -192,6 +192,7 @@ static const struct iio_chan_spec st_magn_2_16bit_channels[] = {
 static const struct st_sensor_settings st_magn_sensors_settings[] = {
 	{
 		.wai = 0, /* This sensor has no valid WhoAmI report 0 */
+		.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,
 		.sensors_supported = {
 			[0] = LSM303DLH_MAGN_DEV_NAME,
 		},
@@ -268,6 +269,7 @@ static const struct st_sensor_settings st_magn_sensors_settings[] = {
 	},
 	{
 		.wai = ST_MAGN_1_WAI_EXP,
+		.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,
 		.sensors_supported = {
 			[0] = LSM303DLHC_MAGN_DEV_NAME,
 			[1] = LSM303DLM_MAGN_DEV_NAME,
@@ -346,6 +348,7 @@ static const struct st_sensor_settings st_magn_sensors_settings[] = {
 	},
 	{
 		.wai = ST_MAGN_2_WAI_EXP,
+		.wai_addr = ST_SENSORS_DEFAULT_WAI_ADDRESS,
 		.sensors_supported = {
 			[0] = LIS3MDL_MAGN_DEV_NAME,
 		},

commit 936a0cd52aa5d024c583e36e2f21bf6ec2e527e4
Merge: 36bf51acc89d e26081808eda
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 18 13:52:44 2015 -0700

    Merge 4.1-rc4 into staging-next
    
    We want the fixes in here for testing and merge issues.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1038a6872802bb4a07f627162ff989bf49e2e5cc
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Apr 30 15:15:50 2015 +0200

    iio: magnetometer: support for lsm303dlh
    
    The LSM303DLH accelerometer/magnetometer has a different
    device identification method than using register 0x0f, instead
    three registers contain a magic value. We rely on WhoAmI
    to be zero for this variant.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 8ade473f99fe..73574d912e7c 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -45,6 +45,46 @@
 #define ST_MAGN_FS_AVL_12000MG			12000
 #define ST_MAGN_FS_AVL_16000MG			16000
 
+/* CUSTOM VALUES FOR SENSOR 0 */
+#define ST_MAGN_0_ODR_ADDR			0x00
+#define ST_MAGN_0_ODR_MASK			0x1c
+#define ST_MAGN_0_ODR_AVL_1HZ_VAL		0x00
+#define ST_MAGN_0_ODR_AVL_2HZ_VAL		0x01
+#define ST_MAGN_0_ODR_AVL_3HZ_VAL		0x02
+#define ST_MAGN_0_ODR_AVL_8HZ_VAL		0x03
+#define ST_MAGN_0_ODR_AVL_15HZ_VAL		0x04
+#define ST_MAGN_0_ODR_AVL_30HZ_VAL		0x05
+#define ST_MAGN_0_ODR_AVL_75HZ_VAL		0x06
+#define ST_MAGN_0_ODR_AVL_220HZ_VAL		0x07
+#define ST_MAGN_0_PW_ADDR			0x02
+#define ST_MAGN_0_PW_MASK			0x03
+#define ST_MAGN_0_PW_ON				0x00
+#define ST_MAGN_0_PW_OFF			0x03
+#define ST_MAGN_0_FS_ADDR			0x01
+#define ST_MAGN_0_FS_MASK			0xe0
+#define ST_MAGN_0_FS_AVL_1300_VAL		0x01
+#define ST_MAGN_0_FS_AVL_1900_VAL		0x02
+#define ST_MAGN_0_FS_AVL_2500_VAL		0x03
+#define ST_MAGN_0_FS_AVL_4000_VAL		0x04
+#define ST_MAGN_0_FS_AVL_4700_VAL		0x05
+#define ST_MAGN_0_FS_AVL_5600_VAL		0x06
+#define ST_MAGN_0_FS_AVL_8100_VAL		0x07
+#define ST_MAGN_0_FS_AVL_1300_GAIN_XY		1100
+#define ST_MAGN_0_FS_AVL_1900_GAIN_XY		855
+#define ST_MAGN_0_FS_AVL_2500_GAIN_XY		670
+#define ST_MAGN_0_FS_AVL_4000_GAIN_XY		450
+#define ST_MAGN_0_FS_AVL_4700_GAIN_XY		400
+#define ST_MAGN_0_FS_AVL_5600_GAIN_XY		330
+#define ST_MAGN_0_FS_AVL_8100_GAIN_XY		230
+#define ST_MAGN_0_FS_AVL_1300_GAIN_Z		980
+#define ST_MAGN_0_FS_AVL_1900_GAIN_Z		760
+#define ST_MAGN_0_FS_AVL_2500_GAIN_Z		600
+#define ST_MAGN_0_FS_AVL_4000_GAIN_Z		400
+#define ST_MAGN_0_FS_AVL_4700_GAIN_Z		355
+#define ST_MAGN_0_FS_AVL_5600_GAIN_Z		295
+#define ST_MAGN_0_FS_AVL_8100_GAIN_Z		205
+#define ST_MAGN_0_MULTIREAD_BIT			false
+
 /* CUSTOM VALUES FOR SENSOR 1 */
 #define ST_MAGN_1_WAI_EXP			0x3c
 #define ST_MAGN_1_ODR_ADDR			0x00
@@ -150,6 +190,82 @@ static const struct iio_chan_spec st_magn_2_16bit_channels[] = {
 };
 
 static const struct st_sensor_settings st_magn_sensors_settings[] = {
+	{
+		.wai = 0, /* This sensor has no valid WhoAmI report 0 */
+		.sensors_supported = {
+			[0] = LSM303DLH_MAGN_DEV_NAME,
+		},
+		.ch = (struct iio_chan_spec *)st_magn_16bit_channels,
+		.odr = {
+			.addr = ST_MAGN_0_ODR_ADDR,
+			.mask = ST_MAGN_0_ODR_MASK,
+			.odr_avl = {
+				{ 1, ST_MAGN_0_ODR_AVL_1HZ_VAL, },
+				{ 2, ST_MAGN_0_ODR_AVL_2HZ_VAL, },
+				{ 3, ST_MAGN_0_ODR_AVL_3HZ_VAL, },
+				{ 8, ST_MAGN_0_ODR_AVL_8HZ_VAL, },
+				{ 15, ST_MAGN_0_ODR_AVL_15HZ_VAL, },
+				{ 30, ST_MAGN_0_ODR_AVL_30HZ_VAL, },
+				{ 75, ST_MAGN_0_ODR_AVL_75HZ_VAL, },
+			},
+		},
+		.pw = {
+			.addr = ST_MAGN_0_PW_ADDR,
+			.mask = ST_MAGN_0_PW_MASK,
+			.value_on = ST_MAGN_0_PW_ON,
+			.value_off = ST_MAGN_0_PW_OFF,
+		},
+		.fs = {
+			.addr = ST_MAGN_0_FS_ADDR,
+			.mask = ST_MAGN_0_FS_MASK,
+			.fs_avl = {
+				[0] = {
+					.num = ST_MAGN_FS_AVL_1300MG,
+					.value = ST_MAGN_0_FS_AVL_1300_VAL,
+					.gain = ST_MAGN_0_FS_AVL_1300_GAIN_XY,
+					.gain2 = ST_MAGN_0_FS_AVL_1300_GAIN_Z,
+				},
+				[1] = {
+					.num = ST_MAGN_FS_AVL_1900MG,
+					.value = ST_MAGN_0_FS_AVL_1900_VAL,
+					.gain = ST_MAGN_0_FS_AVL_1900_GAIN_XY,
+					.gain2 = ST_MAGN_0_FS_AVL_1900_GAIN_Z,
+				},
+				[2] = {
+					.num = ST_MAGN_FS_AVL_2500MG,
+					.value = ST_MAGN_0_FS_AVL_2500_VAL,
+					.gain = ST_MAGN_0_FS_AVL_2500_GAIN_XY,
+					.gain2 = ST_MAGN_0_FS_AVL_2500_GAIN_Z,
+				},
+				[3] = {
+					.num = ST_MAGN_FS_AVL_4000MG,
+					.value = ST_MAGN_0_FS_AVL_4000_VAL,
+					.gain = ST_MAGN_0_FS_AVL_4000_GAIN_XY,
+					.gain2 = ST_MAGN_0_FS_AVL_4000_GAIN_Z,
+				},
+				[4] = {
+					.num = ST_MAGN_FS_AVL_4700MG,
+					.value = ST_MAGN_0_FS_AVL_4700_VAL,
+					.gain = ST_MAGN_0_FS_AVL_4700_GAIN_XY,
+					.gain2 = ST_MAGN_0_FS_AVL_4700_GAIN_Z,
+				},
+				[5] = {
+					.num = ST_MAGN_FS_AVL_5600MG,
+					.value = ST_MAGN_0_FS_AVL_5600_VAL,
+					.gain = ST_MAGN_0_FS_AVL_5600_GAIN_XY,
+					.gain2 = ST_MAGN_0_FS_AVL_5600_GAIN_Z,
+				},
+				[6] = {
+					.num = ST_MAGN_FS_AVL_8100MG,
+					.value = ST_MAGN_0_FS_AVL_8100_VAL,
+					.gain = ST_MAGN_0_FS_AVL_8100_GAIN_XY,
+					.gain2 = ST_MAGN_0_FS_AVL_8100_GAIN_Z,
+				},
+			},
+		},
+		.multi_read_bit = ST_MAGN_0_MULTIREAD_BIT,
+		.bootime = 2,
+	},
 	{
 		.wai = ST_MAGN_1_WAI_EXP,
 		.sensors_supported = {

commit 8e71c04f863a1754f21b27fb8ecb773d680a0a80
Author: Alban Bedel <alban.bedel@avionic-design.de>
Date:   Mon Apr 20 13:57:18 2015 +0200

    iio:st_sensors: Fix oops when probing SPI devices
    
    In SPI mode the transfer buffer is locked with a mutex. However this
    mutex is only initilized after the probe, but some transfer needs to
    be done in the probe.
    
    To fix this bug we move the mutex initialization at the beginning of
    the device probe.
    
    Signed-off-by: Alban Bedel <alban.bedel@avionic-design.de>
    Acked-by: Denis Ciocca <denis.ciocca@st.com>
    Cc: <Stable@vger.kernel.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 8ade473f99fe..2e56f812a644 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -369,6 +369,7 @@ int st_magn_common_probe(struct iio_dev *indio_dev)
 
 	indio_dev->modes = INDIO_DIRECT_MODE;
 	indio_dev->info = &magn_info;
+	mutex_init(&mdata->tb.buf_lock);
 
 	st_sensors_power_enable(indio_dev);
 

commit be61a0d78449f53519905640ac3a9f24c197cbaf
Merge: 7be921a226dc 4e4cd14e7cbe
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 5 11:42:48 2014 -0800

    Merge tag 'iio-for-3.19a' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-next
    
    Jonathan writes:
    
    First round of new drivers, features and cleanups for IIO in the 3.19 cycle.
    
    New drivers / supported parts
    * rockchip - rk3066-tsadc variant
    * si7020 humidity and temperature sensor
    * mcp320x - add mcp3001, mcp3002, mcp3004, mcp3008, mcp3201, mcp3202
    * bmp280 pressure and temperature sensor
    * Qualcomm SPMI PMIC current ADC driver
    * Exynos_adc - support exynos7
    
    New features
    * vf610-adc - add temperature sensor support
    * Documentation of current attributes, scaled pressure, offset and
      scaled humidity, RGBC intensity gain factor and scale applied to
      differential voltage channels.
    * Bring iio_event_monitor up to date with newer modifiers.
    * Add of_xlate function to allow for complex channel mappings from the
      device tree.
    * Add -g parameter to generic_buffer example to allow for devices with
      directly fed (no trigger) buffers.
    * Move exynos driver over to syscon for PMU register access.
    
    Cleanups, fixes for new drivers
    * lis3l02dq drop an unneeded else.
    * st sensors - renam st_sensors to st_sensor_settings (for clarity)
    * st sensors - drop an unused parameter from all the probe utility
      functions.
    * vf610 better error handling and tidy up.
    * si7020 - cleanups following merge
    * as3935 - drop some unnecessary semicolons.
    * bmp280 - fix the pressure calculation.

commit 2109eb4c0c7d21669ae2ad0cda90c438b5470bf3
Author: Denis CIOCCA <denis.ciocca@st.com>
Date:   Fri Oct 3 17:35:38 2014 +0200

    iio:magnetometer: Removed unnecessary parameter on common_probe function
    
    Signed-off-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index b65405fada45..1f3c1b7be78f 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -353,8 +353,7 @@ static const struct iio_info magn_info = {
 	.write_raw = &st_magn_write_raw,
 };
 
-int st_magn_common_probe(struct iio_dev *indio_dev,
-					struct st_sensors_platform_data *pdata)
+int st_magn_common_probe(struct iio_dev *indio_dev)
 {
 	struct st_sensor_data *mdata = iio_priv(indio_dev);
 	int irq = mdata->get_irq_data_ready(indio_dev);
@@ -380,7 +379,7 @@ int st_magn_common_probe(struct iio_dev *indio_dev,
 					&mdata->sensor_settings->fs.fs_avl[0];
 	mdata->odr = mdata->sensor_settings->odr.odr_avl[0].hz;
 
-	err = st_sensors_init_sensor(indio_dev, pdata);
+	err = st_sensors_init_sensor(indio_dev, NULL);
 	if (err < 0)
 		return err;
 

commit a7ee8839daf21c4a3ca439733e7bed25f32e7954
Author: Denis CIOCCA <denis.ciocca@st.com>
Date:   Fri Oct 3 17:35:35 2014 +0200

    iio:imu: changed structure name from st_sensors to st_sensor_settings
    
    This patch change structure name and related variables names.
    
    Signed-off-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index a4b64130ac2f..b65405fada45 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -146,7 +146,7 @@ static const struct iio_chan_spec st_magn_2_16bit_channels[] = {
 	IIO_CHAN_SOFT_TIMESTAMP(3)
 };
 
-static const struct st_sensors st_magn_sensors[] = {
+static const struct st_sensor_settings st_magn_sensors_settings[] = {
 	{
 		.wai = ST_MAGN_1_WAI_EXP,
 		.sensors_supported = {
@@ -366,18 +366,19 @@ int st_magn_common_probe(struct iio_dev *indio_dev,
 	st_sensors_power_enable(indio_dev);
 
 	err = st_sensors_check_device_support(indio_dev,
-				ARRAY_SIZE(st_magn_sensors), st_magn_sensors);
+					ARRAY_SIZE(st_magn_sensors_settings),
+					st_magn_sensors_settings);
 	if (err < 0)
 		return err;
 
 	mdata->num_data_channels = ST_MAGN_NUMBER_DATA_CHANNELS;
-	mdata->multiread_bit = mdata->sensor->multi_read_bit;
-	indio_dev->channels = mdata->sensor->ch;
+	mdata->multiread_bit = mdata->sensor_settings->multi_read_bit;
+	indio_dev->channels = mdata->sensor_settings->ch;
 	indio_dev->num_channels = ST_SENSORS_NUMBER_ALL_CHANNELS;
 
 	mdata->current_fullscale = (struct st_sensor_fullscale_avl *)
-						&mdata->sensor->fs.fs_avl[0];
-	mdata->odr = mdata->sensor->odr.odr_avl[0].hz;
+					&mdata->sensor_settings->fs.fs_avl[0];
+	mdata->odr = mdata->sensor_settings->odr.odr_avl[0].hz;
 
 	err = st_sensors_init_sensor(indio_dev, pdata);
 	if (err < 0)

commit a31d0928999fbf33b3a6042e8bcb7b7f7e07d094
Author: Denis CIOCCA <denis.ciocca@st.com>
Date:   Thu Oct 9 13:55:00 2014 +0100

    iio:magnetometer: bugfix magnetometers gain values
    
    This patch fix gains values. The first driver was designed using
    engineering samples, in mass production the values are changed.
    
    Signed-off-by: Denis Ciocca <denis.ciocca@st.com>
    Cc: Stable@vger.kernel.org
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index a4b64130ac2f..68cae86dbd29 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -42,7 +42,8 @@
 #define ST_MAGN_FS_AVL_5600MG			5600
 #define ST_MAGN_FS_AVL_8000MG			8000
 #define ST_MAGN_FS_AVL_8100MG			8100
-#define ST_MAGN_FS_AVL_10000MG			10000
+#define ST_MAGN_FS_AVL_12000MG			12000
+#define ST_MAGN_FS_AVL_16000MG			16000
 
 /* CUSTOM VALUES FOR SENSOR 1 */
 #define ST_MAGN_1_WAI_EXP			0x3c
@@ -69,20 +70,20 @@
 #define ST_MAGN_1_FS_AVL_4700_VAL		0x05
 #define ST_MAGN_1_FS_AVL_5600_VAL		0x06
 #define ST_MAGN_1_FS_AVL_8100_VAL		0x07
-#define ST_MAGN_1_FS_AVL_1300_GAIN_XY		1100
-#define ST_MAGN_1_FS_AVL_1900_GAIN_XY		855
-#define ST_MAGN_1_FS_AVL_2500_GAIN_XY		670
-#define ST_MAGN_1_FS_AVL_4000_GAIN_XY		450
-#define ST_MAGN_1_FS_AVL_4700_GAIN_XY		400
-#define ST_MAGN_1_FS_AVL_5600_GAIN_XY		330
-#define ST_MAGN_1_FS_AVL_8100_GAIN_XY		230
-#define ST_MAGN_1_FS_AVL_1300_GAIN_Z		980
-#define ST_MAGN_1_FS_AVL_1900_GAIN_Z		760
-#define ST_MAGN_1_FS_AVL_2500_GAIN_Z		600
-#define ST_MAGN_1_FS_AVL_4000_GAIN_Z		400
-#define ST_MAGN_1_FS_AVL_4700_GAIN_Z		355
-#define ST_MAGN_1_FS_AVL_5600_GAIN_Z		295
-#define ST_MAGN_1_FS_AVL_8100_GAIN_Z		205
+#define ST_MAGN_1_FS_AVL_1300_GAIN_XY		909
+#define ST_MAGN_1_FS_AVL_1900_GAIN_XY		1169
+#define ST_MAGN_1_FS_AVL_2500_GAIN_XY		1492
+#define ST_MAGN_1_FS_AVL_4000_GAIN_XY		2222
+#define ST_MAGN_1_FS_AVL_4700_GAIN_XY		2500
+#define ST_MAGN_1_FS_AVL_5600_GAIN_XY		3030
+#define ST_MAGN_1_FS_AVL_8100_GAIN_XY		4347
+#define ST_MAGN_1_FS_AVL_1300_GAIN_Z		1020
+#define ST_MAGN_1_FS_AVL_1900_GAIN_Z		1315
+#define ST_MAGN_1_FS_AVL_2500_GAIN_Z		1666
+#define ST_MAGN_1_FS_AVL_4000_GAIN_Z		2500
+#define ST_MAGN_1_FS_AVL_4700_GAIN_Z		2816
+#define ST_MAGN_1_FS_AVL_5600_GAIN_Z		3389
+#define ST_MAGN_1_FS_AVL_8100_GAIN_Z		4878
 #define ST_MAGN_1_MULTIREAD_BIT			false
 
 /* CUSTOM VALUES FOR SENSOR 2 */
@@ -105,10 +106,12 @@
 #define ST_MAGN_2_FS_MASK			0x60
 #define ST_MAGN_2_FS_AVL_4000_VAL		0x00
 #define ST_MAGN_2_FS_AVL_8000_VAL		0x01
-#define ST_MAGN_2_FS_AVL_10000_VAL		0x02
-#define ST_MAGN_2_FS_AVL_4000_GAIN		430
-#define ST_MAGN_2_FS_AVL_8000_GAIN		230
-#define ST_MAGN_2_FS_AVL_10000_GAIN		230
+#define ST_MAGN_2_FS_AVL_12000_VAL		0x02
+#define ST_MAGN_2_FS_AVL_16000_VAL		0x03
+#define ST_MAGN_2_FS_AVL_4000_GAIN		146
+#define ST_MAGN_2_FS_AVL_8000_GAIN		292
+#define ST_MAGN_2_FS_AVL_12000_GAIN		438
+#define ST_MAGN_2_FS_AVL_16000_GAIN		584
 #define ST_MAGN_2_MULTIREAD_BIT			false
 #define ST_MAGN_2_OUT_X_L_ADDR			0x28
 #define ST_MAGN_2_OUT_Y_L_ADDR			0x2a
@@ -266,9 +269,14 @@ static const struct st_sensors st_magn_sensors[] = {
 					.gain = ST_MAGN_2_FS_AVL_8000_GAIN,
 				},
 				[2] = {
-					.num = ST_MAGN_FS_AVL_10000MG,
-					.value = ST_MAGN_2_FS_AVL_10000_VAL,
-					.gain = ST_MAGN_2_FS_AVL_10000_GAIN,
+					.num = ST_MAGN_FS_AVL_12000MG,
+					.value = ST_MAGN_2_FS_AVL_12000_VAL,
+					.gain = ST_MAGN_2_FS_AVL_12000_GAIN,
+				},
+				[3] = {
+					.num = ST_MAGN_FS_AVL_16000MG,
+					.value = ST_MAGN_2_FS_AVL_16000_VAL,
+					.gain = ST_MAGN_2_FS_AVL_16000_GAIN,
 				},
 			},
 		},

commit 2d239c9e92087d5f4f667371ae350db9f76e3191
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sun Jun 22 20:59:00 2014 +0100

    iio:st sensors: remove custom sampling frequence attribute in favour of core support.
    
    This allows in kernel client drivers to access this
    
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Cc: Denis Ciocca <denis.ciocca@st.com>
    Reviewed-by: Hartmut Knaack <knaack.h@gmx.de>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 240a21dd0c61..a4b64130ac2f 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -299,6 +299,9 @@ static int st_magn_read_raw(struct iio_dev *indio_dev,
 		else
 			*val2 = mdata->current_fullscale->gain;
 		return IIO_VAL_INT_PLUS_MICRO;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*val = mdata->odr;
+		return IIO_VAL_INT;
 	default:
 		return -EINVAL;
 	}
@@ -316,6 +319,13 @@ static int st_magn_write_raw(struct iio_dev *indio_dev,
 	case IIO_CHAN_INFO_SCALE:
 		err = st_sensors_set_fullscale_by_gain(indio_dev, val2);
 		break;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		if (val2)
+			return -EINVAL;
+		mutex_lock(&indio_dev->mlock);
+		err = st_sensors_set_odr(indio_dev, val);
+		mutex_unlock(&indio_dev->mlock);
+		return err;
 	default:
 		err = -EINVAL;
 	}
@@ -323,14 +333,12 @@ static int st_magn_write_raw(struct iio_dev *indio_dev,
 	return err;
 }
 
-static ST_SENSOR_DEV_ATTR_SAMP_FREQ();
 static ST_SENSORS_DEV_ATTR_SAMP_FREQ_AVAIL();
 static ST_SENSORS_DEV_ATTR_SCALE_AVAIL(in_magn_scale_available);
 
 static struct attribute *st_magn_attributes[] = {
 	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
 	&iio_dev_attr_in_magn_scale_available.dev_attr.attr,
-	&iio_dev_attr_sampling_frequency.dev_attr.attr,
 	NULL,
 };
 

commit ea7e586bdd331fd6fba2b6f9fd3777928c2814d8
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sun Apr 13 20:08:00 2014 +0100

    iio: st_sensors: move regulator retrieveal to core
    
    Currently the pressure sensor has code to retrieve and enable two
    regulators for Vdd and Vdd IO, but actually these voltage inputs
    are found on all of these ST sensors, so move the regulator
    handling to the core and make sure all the ST sensors call these
    functions on probe() and remove() to enable/disable power.
    
    Here also mover over to obtaining the regulator from the *parent*
    device of the IIO device, as the IIO device is created on-the-fly
    in this very subsystem it very unlikely evert have any regulators
    attached to it whatsoever. It is much more likely that the parent
    is a platform device, possibly instantiated from a device tree,
    which in turn have Vdd and Vdd IO supplied assigned to it.
    
    Cc: Lee Jones <lee.jones@linaro.org>
    Cc: Denis CIOCCA <denis.ciocca@st.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 8e33a7682d33..240a21dd0c61 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -355,6 +355,8 @@ int st_magn_common_probe(struct iio_dev *indio_dev,
 	indio_dev->modes = INDIO_DIRECT_MODE;
 	indio_dev->info = &magn_info;
 
+	st_sensors_power_enable(indio_dev);
+
 	err = st_sensors_check_device_support(indio_dev,
 				ARRAY_SIZE(st_magn_sensors), st_magn_sensors);
 	if (err < 0)
@@ -406,6 +408,8 @@ void st_magn_common_remove(struct iio_dev *indio_dev)
 {
 	struct st_sensor_data *mdata = iio_priv(indio_dev);
 
+	st_sensors_power_disable(indio_dev);
+
 	iio_device_unregister(indio_dev);
 	if (mdata->get_irq_data_ready(indio_dev) > 0)
 		st_sensors_deallocate_trigger(indio_dev);

commit 4f544ced19b3d300ac11414b68a676a2c42f6d06
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Sun Apr 13 20:08:00 2014 +0100

    iio: st_sensors: announce registered sensors
    
    It is pretty helpful to know already from dmesg that a certain
    device is successfully registered, instead of having to browse
    sysfs to see if it's actually there.
    
    Cc: Lee Jones <lee.jones@linaro.org>
    Cc: Denis CIOCCA <denis.ciocca@st.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 52bbcfa1e077..8e33a7682d33 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -387,6 +387,9 @@ int st_magn_common_probe(struct iio_dev *indio_dev,
 	if (err)
 		goto st_magn_device_register_error;
 
+	dev_info(&indio_dev->dev, "registered magnetometer %s\n",
+		 indio_dev->name);
+
 	return 0;
 
 st_magn_device_register_error:

commit 02ab343f3b497421793cb4c9725587f9052f7078
Merge: eb3e6ae96056 d0e639c9e06d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Oct 6 17:22:43 2013 -0700

    Merge 3.12-rc4 into staging-next
    
    We want the staging fixes in this branch as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 512690daa6cc6dec0a4f776a0f0f3d729b029cf9
Author: Denis CIOCCA <denis.ciocca@st.com>
Date:   Tue Sep 24 15:51:00 2013 +0100

    iio:magnetometer: Bugfix magnetometer default output registers
    
    Signed-off-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index e8d2849cc81d..cab3bc7494a2 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -29,9 +29,9 @@
 #define ST_MAGN_NUMBER_DATA_CHANNELS		3
 
 /* DEFAULT VALUE FOR SENSORS */
-#define ST_MAGN_DEFAULT_OUT_X_L_ADDR		0X04
-#define ST_MAGN_DEFAULT_OUT_Y_L_ADDR		0X08
-#define ST_MAGN_DEFAULT_OUT_Z_L_ADDR		0X06
+#define ST_MAGN_DEFAULT_OUT_X_H_ADDR		0X03
+#define ST_MAGN_DEFAULT_OUT_Y_H_ADDR		0X07
+#define ST_MAGN_DEFAULT_OUT_Z_H_ADDR		0X05
 
 /* FULLSCALE */
 #define ST_MAGN_FS_AVL_1300MG			1300
@@ -117,16 +117,16 @@
 static const struct iio_chan_spec st_magn_16bit_channels[] = {
 	ST_SENSORS_LSM_CHANNELS(IIO_MAGN,
 			BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),
-			ST_SENSORS_SCAN_X, 1, IIO_MOD_X, 's', IIO_LE, 16, 16,
-			ST_MAGN_DEFAULT_OUT_X_L_ADDR),
+			ST_SENSORS_SCAN_X, 1, IIO_MOD_X, 's', IIO_BE, 16, 16,
+			ST_MAGN_DEFAULT_OUT_X_H_ADDR),
 	ST_SENSORS_LSM_CHANNELS(IIO_MAGN,
 			BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),
-			ST_SENSORS_SCAN_Y, 1, IIO_MOD_Y, 's', IIO_LE, 16, 16,
-			ST_MAGN_DEFAULT_OUT_Y_L_ADDR),
+			ST_SENSORS_SCAN_Y, 1, IIO_MOD_Y, 's', IIO_BE, 16, 16,
+			ST_MAGN_DEFAULT_OUT_Y_H_ADDR),
 	ST_SENSORS_LSM_CHANNELS(IIO_MAGN,
 			BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),
-			ST_SENSORS_SCAN_Z, 1, IIO_MOD_Z, 's', IIO_LE, 16, 16,
-			ST_MAGN_DEFAULT_OUT_Z_L_ADDR),
+			ST_SENSORS_SCAN_Z, 1, IIO_MOD_Z, 's', IIO_BE, 16, 16,
+			ST_MAGN_DEFAULT_OUT_Z_H_ADDR),
 	IIO_CHAN_SOFT_TIMESTAMP(3)
 };
 

commit f60b12b02ec8d9057863423c6d7b27169638e1d9
Author: Denis CIOCCA <denis.ciocca@st.com>
Date:   Wed Sep 18 10:00:00 2013 +0100

    iio:magn: Register buffer also without specific trigger
    
    This patch fix buffer registration that allows to use generic IIO trigger.
    
    Signed-off-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 729c71af9400..82461eff995a 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -373,10 +373,11 @@ int st_magn_common_probe(struct iio_dev *indio_dev,
 	if (err < 0)
 		return err;
 
+	err = st_magn_allocate_ring(indio_dev);
+	if (err < 0)
+		return err;
+
 	if (irq > 0) {
-		err = st_magn_allocate_ring(indio_dev);
-		if (err < 0)
-			return err;
 		err = st_sensors_allocate_trigger(indio_dev, NULL);
 		if (err < 0)
 			goto st_magn_probe_trigger_error;
@@ -392,8 +393,7 @@ int st_magn_common_probe(struct iio_dev *indio_dev,
 	if (irq > 0)
 		st_sensors_deallocate_trigger(indio_dev);
 st_magn_probe_trigger_error:
-	if (irq > 0)
-		st_magn_deallocate_ring(indio_dev);
+	st_magn_deallocate_ring(indio_dev);
 
 	return err;
 }
@@ -404,10 +404,10 @@ void st_magn_common_remove(struct iio_dev *indio_dev)
 	struct st_sensor_data *mdata = iio_priv(indio_dev);
 
 	iio_device_unregister(indio_dev);
-	if (mdata->get_irq_data_ready(indio_dev) > 0) {
+	if (mdata->get_irq_data_ready(indio_dev) > 0)
 		st_sensors_deallocate_trigger(indio_dev);
-		st_magn_deallocate_ring(indio_dev);
-	}
+
+	st_magn_deallocate_ring(indio_dev);
 }
 EXPORT_SYMBOL(st_magn_common_remove);
 

commit 267a29b957cb28725aef7b9b2ea4c219caefb3b7
Author: Lee Jones <lee.jones@linaro.org>
Date:   Mon Sep 16 17:02:00 2013 +0100

    iio: magn-core: st: Clean up error handling in probe()
    
    Reduce the amount of those unnecessary goto calls, as in most cases
    we can simply return immediately. We also only call for the IRQ number
    once and use that value throughout.
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index e8d2849cc81d..729c71af9400 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -348,8 +348,9 @@ static const struct iio_info magn_info = {
 int st_magn_common_probe(struct iio_dev *indio_dev,
 					struct st_sensors_platform_data *pdata)
 {
-	int err;
 	struct st_sensor_data *mdata = iio_priv(indio_dev);
+	int irq = mdata->get_irq_data_ready(indio_dev);
+	int err;
 
 	indio_dev->modes = INDIO_DIRECT_MODE;
 	indio_dev->info = &magn_info;
@@ -357,7 +358,7 @@ int st_magn_common_probe(struct iio_dev *indio_dev,
 	err = st_sensors_check_device_support(indio_dev,
 				ARRAY_SIZE(st_magn_sensors), st_magn_sensors);
 	if (err < 0)
-		goto st_magn_common_probe_error;
+		return err;
 
 	mdata->num_data_channels = ST_MAGN_NUMBER_DATA_CHANNELS;
 	mdata->multiread_bit = mdata->sensor->multi_read_bit;
@@ -370,12 +371,12 @@ int st_magn_common_probe(struct iio_dev *indio_dev,
 
 	err = st_sensors_init_sensor(indio_dev, pdata);
 	if (err < 0)
-		goto st_magn_common_probe_error;
+		return err;
 
-	if (mdata->get_irq_data_ready(indio_dev) > 0) {
+	if (irq > 0) {
 		err = st_magn_allocate_ring(indio_dev);
 		if (err < 0)
-			goto st_magn_common_probe_error;
+			return err;
 		err = st_sensors_allocate_trigger(indio_dev, NULL);
 		if (err < 0)
 			goto st_magn_probe_trigger_error;
@@ -385,15 +386,15 @@ int st_magn_common_probe(struct iio_dev *indio_dev,
 	if (err)
 		goto st_magn_device_register_error;
 
-	return err;
+	return 0;
 
 st_magn_device_register_error:
-	if (mdata->get_irq_data_ready(indio_dev) > 0)
+	if (irq > 0)
 		st_sensors_deallocate_trigger(indio_dev);
 st_magn_probe_trigger_error:
-	if (mdata->get_irq_data_ready(indio_dev) > 0)
+	if (irq > 0)
 		st_magn_deallocate_ring(indio_dev);
-st_magn_common_probe_error:
+
 	return err;
 }
 EXPORT_SYMBOL(st_magn_common_probe);

commit 7fc5ad7e97a690ccd05ad2556c1bfb687692f215
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Fri Aug 2 11:08:00 2013 +0100

    iio: magnetometer: st_magn: Use devm_iio_device_alloc
    
    Using devm_iio_device_alloc makes code simpler.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Cc: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 7cd784f522e5..e8d2849cc81d 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -407,7 +407,6 @@ void st_magn_common_remove(struct iio_dev *indio_dev)
 		st_sensors_deallocate_trigger(indio_dev);
 		st_magn_deallocate_ring(indio_dev);
 	}
-	iio_device_free(indio_dev);
 }
 EXPORT_SYMBOL(st_magn_common_remove);
 

commit 23cde4d65cc7d11e2048d2b240cdf13927ac50d0
Author: Denis CIOCCA <denis.ciocca@st.com>
Date:   Wed Jun 19 09:28:00 2013 +0100

    iio: Added ST-sensors platform data to select the DRDY interrupt pin
    
    This patch add support to redirect the DRDY interrupt on INT1 or INT2
    on accelerometer and pressure sensors.
    
    Signed-off-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index ebfe8f11a0c2..7cd784f522e5 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -345,7 +345,8 @@ static const struct iio_info magn_info = {
 	.write_raw = &st_magn_write_raw,
 };
 
-int st_magn_common_probe(struct iio_dev *indio_dev)
+int st_magn_common_probe(struct iio_dev *indio_dev,
+					struct st_sensors_platform_data *pdata)
 {
 	int err;
 	struct st_sensor_data *mdata = iio_priv(indio_dev);
@@ -367,7 +368,7 @@ int st_magn_common_probe(struct iio_dev *indio_dev)
 						&mdata->sensor->fs.fs_avl[0];
 	mdata->odr = mdata->sensor->odr.odr_avl[0].hz;
 
-	err = st_sensors_init_sensor(indio_dev);
+	err = st_sensors_init_sensor(indio_dev, pdata);
 	if (err < 0)
 		goto st_magn_common_probe_error;
 

commit 607a568ab69c5ac345a286267a27294888f8bb5f
Author: Denis CIOCCA <denis.ciocca@st.com>
Date:   Mon Jun 3 15:58:00 2013 +0100

    iio:common: Removed stuff macros, added num_data_channels on st_sensors struct and added support on one-shot sysfs reads to 3 byte channel
    
    This patch introduce num_data_channels variable on st_sensors struct
    to manage different type of channels (size or number) in
    st_sensors_get_buffer_element function.
    Removed ST_SENSORS_NUMBER_DATA_CHANNELS and ST_SENSORS_BYTE_FOR_CHANNEL
    and used struct iio_chan_spec const *ch to catch data.
    Added 3 byte channel data support on one-shot reads.
    
    Signed-off-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 715d61681df3..ebfe8f11a0c2 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -26,6 +26,8 @@
 #include <linux/iio/common/st_sensors.h>
 #include "st_magn.h"
 
+#define ST_MAGN_NUMBER_DATA_CHANNELS		3
+
 /* DEFAULT VALUE FOR SENSORS */
 #define ST_MAGN_DEFAULT_OUT_X_L_ADDR		0X04
 #define ST_MAGN_DEFAULT_OUT_Y_L_ADDR		0X08
@@ -356,6 +358,7 @@ int st_magn_common_probe(struct iio_dev *indio_dev)
 	if (err < 0)
 		goto st_magn_common_probe_error;
 
+	mdata->num_data_channels = ST_MAGN_NUMBER_DATA_CHANNELS;
 	mdata->multiread_bit = mdata->sensor->multi_read_bit;
 	indio_dev->channels = mdata->sensor->ch;
 	indio_dev->num_channels = ST_SENSORS_NUMBER_ALL_CHANNELS;

commit 762011d6193f8b9af9b491ded87dde3221d0600a
Author: Denis CIOCCA <denis.ciocca@st.com>
Date:   Mon Jun 3 15:58:00 2013 +0100

    iio:common: ST_SENSORS_LSM_CHANNELS macro changed
    
    Signed-off-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index 16f0d6df239f..715d61681df3 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -113,22 +113,34 @@
 #define ST_MAGN_2_OUT_Z_L_ADDR			0x2c
 
 static const struct iio_chan_spec st_magn_16bit_channels[] = {
-	ST_SENSORS_LSM_CHANNELS(IIO_MAGN, ST_SENSORS_SCAN_X, IIO_MOD_X, IIO_LE,
-		ST_SENSORS_DEFAULT_16_REALBITS, ST_MAGN_DEFAULT_OUT_X_L_ADDR),
-	ST_SENSORS_LSM_CHANNELS(IIO_MAGN, ST_SENSORS_SCAN_Y, IIO_MOD_Y, IIO_LE,
-		ST_SENSORS_DEFAULT_16_REALBITS, ST_MAGN_DEFAULT_OUT_Y_L_ADDR),
-	ST_SENSORS_LSM_CHANNELS(IIO_MAGN, ST_SENSORS_SCAN_Z, IIO_MOD_Z, IIO_LE,
-		ST_SENSORS_DEFAULT_16_REALBITS, ST_MAGN_DEFAULT_OUT_Z_L_ADDR),
+	ST_SENSORS_LSM_CHANNELS(IIO_MAGN,
+			BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),
+			ST_SENSORS_SCAN_X, 1, IIO_MOD_X, 's', IIO_LE, 16, 16,
+			ST_MAGN_DEFAULT_OUT_X_L_ADDR),
+	ST_SENSORS_LSM_CHANNELS(IIO_MAGN,
+			BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),
+			ST_SENSORS_SCAN_Y, 1, IIO_MOD_Y, 's', IIO_LE, 16, 16,
+			ST_MAGN_DEFAULT_OUT_Y_L_ADDR),
+	ST_SENSORS_LSM_CHANNELS(IIO_MAGN,
+			BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),
+			ST_SENSORS_SCAN_Z, 1, IIO_MOD_Z, 's', IIO_LE, 16, 16,
+			ST_MAGN_DEFAULT_OUT_Z_L_ADDR),
 	IIO_CHAN_SOFT_TIMESTAMP(3)
 };
 
 static const struct iio_chan_spec st_magn_2_16bit_channels[] = {
-	ST_SENSORS_LSM_CHANNELS(IIO_MAGN, ST_SENSORS_SCAN_X, IIO_MOD_X, IIO_LE,
-		ST_SENSORS_DEFAULT_16_REALBITS, ST_MAGN_2_OUT_X_L_ADDR),
-	ST_SENSORS_LSM_CHANNELS(IIO_MAGN, ST_SENSORS_SCAN_Y, IIO_MOD_Y, IIO_LE,
-		ST_SENSORS_DEFAULT_16_REALBITS, ST_MAGN_2_OUT_Y_L_ADDR),
-	ST_SENSORS_LSM_CHANNELS(IIO_MAGN, ST_SENSORS_SCAN_Z, IIO_MOD_Z, IIO_LE,
-		ST_SENSORS_DEFAULT_16_REALBITS, ST_MAGN_2_OUT_Z_L_ADDR),
+	ST_SENSORS_LSM_CHANNELS(IIO_MAGN,
+			BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),
+			ST_SENSORS_SCAN_X, 1, IIO_MOD_X, 's', IIO_LE, 16, 16,
+			ST_MAGN_2_OUT_X_L_ADDR),
+	ST_SENSORS_LSM_CHANNELS(IIO_MAGN,
+			BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),
+			ST_SENSORS_SCAN_Y, 1, IIO_MOD_Y, 's', IIO_LE, 16, 16,
+			ST_MAGN_2_OUT_Y_L_ADDR),
+	ST_SENSORS_LSM_CHANNELS(IIO_MAGN,
+			BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE),
+			ST_SENSORS_SCAN_Z, 1, IIO_MOD_Z, 's', IIO_LE, 16, 16,
+			ST_MAGN_2_OUT_Z_L_ADDR),
 	IIO_CHAN_SOFT_TIMESTAMP(3)
 };
 

commit 8ce4a56a52bf566659768a9e46e759e7cd5f33d9
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sat Feb 9 10:49:00 2013 +0000

    iio:st_sensors fix build when !CONFIG_IIO_TRIGGER
    
    Partly a case of removing unused headers and partly a case
    of ifdefing out the iio_trigger_ops structures.  This has
    come about because of an 'unusual' separation of code in this
    driver.
    
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Reported-by: Randy Dunlap <rdunlap@infradead.org>
    Acked-by: Denis Ciocca <denis.ciocca@st.com>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
index a69fbe19fc8e..16f0d6df239f 100644
--- a/drivers/iio/magnetometer/st_magn_core.c
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -21,7 +21,6 @@
 #include <linux/delay.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/sysfs.h>
-#include <linux/iio/trigger_consumer.h>
 #include <linux/iio/buffer.h>
 
 #include <linux/iio/common/st_sensors.h>

commit 872e79add7561645b130fba63aa7ca12098a9361
Author: Denis Ciocca <denis.ciocca@gmail.com>
Date:   Fri Jan 25 23:44:00 2013 +0000

    iio:magnetometer: Add STMicroelectronics magnetometers driver
    
    This patch adds a generic magnetometer driver for STMicroelectronics
    magnetometers, currently it supports:
    LSM303DLHC, LSM303DLM, LIS3MDL.
    
    Signed-off-by: Denis Ciocca <denis.ciocca@st.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c
new file mode 100644
index 000000000000..a69fbe19fc8e
--- /dev/null
+++ b/drivers/iio/magnetometer/st_magn_core.c
@@ -0,0 +1,401 @@
+/*
+ * STMicroelectronics magnetometers driver
+ *
+ * Copyright 2012-2013 STMicroelectronics Inc.
+ *
+ * Denis Ciocca <denis.ciocca@st.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/buffer.h>
+
+#include <linux/iio/common/st_sensors.h>
+#include "st_magn.h"
+
+/* DEFAULT VALUE FOR SENSORS */
+#define ST_MAGN_DEFAULT_OUT_X_L_ADDR		0X04
+#define ST_MAGN_DEFAULT_OUT_Y_L_ADDR		0X08
+#define ST_MAGN_DEFAULT_OUT_Z_L_ADDR		0X06
+
+/* FULLSCALE */
+#define ST_MAGN_FS_AVL_1300MG			1300
+#define ST_MAGN_FS_AVL_1900MG			1900
+#define ST_MAGN_FS_AVL_2500MG			2500
+#define ST_MAGN_FS_AVL_4000MG			4000
+#define ST_MAGN_FS_AVL_4700MG			4700
+#define ST_MAGN_FS_AVL_5600MG			5600
+#define ST_MAGN_FS_AVL_8000MG			8000
+#define ST_MAGN_FS_AVL_8100MG			8100
+#define ST_MAGN_FS_AVL_10000MG			10000
+
+/* CUSTOM VALUES FOR SENSOR 1 */
+#define ST_MAGN_1_WAI_EXP			0x3c
+#define ST_MAGN_1_ODR_ADDR			0x00
+#define ST_MAGN_1_ODR_MASK			0x1c
+#define ST_MAGN_1_ODR_AVL_1HZ_VAL		0x00
+#define ST_MAGN_1_ODR_AVL_2HZ_VAL		0x01
+#define ST_MAGN_1_ODR_AVL_3HZ_VAL		0x02
+#define ST_MAGN_1_ODR_AVL_8HZ_VAL		0x03
+#define ST_MAGN_1_ODR_AVL_15HZ_VAL		0x04
+#define ST_MAGN_1_ODR_AVL_30HZ_VAL		0x05
+#define ST_MAGN_1_ODR_AVL_75HZ_VAL		0x06
+#define ST_MAGN_1_ODR_AVL_220HZ_VAL		0x07
+#define ST_MAGN_1_PW_ADDR			0x02
+#define ST_MAGN_1_PW_MASK			0x03
+#define ST_MAGN_1_PW_ON				0x00
+#define ST_MAGN_1_PW_OFF			0x03
+#define ST_MAGN_1_FS_ADDR			0x01
+#define ST_MAGN_1_FS_MASK			0xe0
+#define ST_MAGN_1_FS_AVL_1300_VAL		0x01
+#define ST_MAGN_1_FS_AVL_1900_VAL		0x02
+#define ST_MAGN_1_FS_AVL_2500_VAL		0x03
+#define ST_MAGN_1_FS_AVL_4000_VAL		0x04
+#define ST_MAGN_1_FS_AVL_4700_VAL		0x05
+#define ST_MAGN_1_FS_AVL_5600_VAL		0x06
+#define ST_MAGN_1_FS_AVL_8100_VAL		0x07
+#define ST_MAGN_1_FS_AVL_1300_GAIN_XY		1100
+#define ST_MAGN_1_FS_AVL_1900_GAIN_XY		855
+#define ST_MAGN_1_FS_AVL_2500_GAIN_XY		670
+#define ST_MAGN_1_FS_AVL_4000_GAIN_XY		450
+#define ST_MAGN_1_FS_AVL_4700_GAIN_XY		400
+#define ST_MAGN_1_FS_AVL_5600_GAIN_XY		330
+#define ST_MAGN_1_FS_AVL_8100_GAIN_XY		230
+#define ST_MAGN_1_FS_AVL_1300_GAIN_Z		980
+#define ST_MAGN_1_FS_AVL_1900_GAIN_Z		760
+#define ST_MAGN_1_FS_AVL_2500_GAIN_Z		600
+#define ST_MAGN_1_FS_AVL_4000_GAIN_Z		400
+#define ST_MAGN_1_FS_AVL_4700_GAIN_Z		355
+#define ST_MAGN_1_FS_AVL_5600_GAIN_Z		295
+#define ST_MAGN_1_FS_AVL_8100_GAIN_Z		205
+#define ST_MAGN_1_MULTIREAD_BIT			false
+
+/* CUSTOM VALUES FOR SENSOR 2 */
+#define ST_MAGN_2_WAI_EXP			0x3d
+#define ST_MAGN_2_ODR_ADDR			0x20
+#define ST_MAGN_2_ODR_MASK			0x1c
+#define ST_MAGN_2_ODR_AVL_1HZ_VAL		0x00
+#define ST_MAGN_2_ODR_AVL_2HZ_VAL		0x01
+#define ST_MAGN_2_ODR_AVL_3HZ_VAL		0x02
+#define ST_MAGN_2_ODR_AVL_5HZ_VAL		0x03
+#define ST_MAGN_2_ODR_AVL_10HZ_VAL		0x04
+#define ST_MAGN_2_ODR_AVL_20HZ_VAL		0x05
+#define ST_MAGN_2_ODR_AVL_40HZ_VAL		0x06
+#define ST_MAGN_2_ODR_AVL_80HZ_VAL		0x07
+#define ST_MAGN_2_PW_ADDR			0x22
+#define ST_MAGN_2_PW_MASK			0x03
+#define ST_MAGN_2_PW_ON				0x00
+#define ST_MAGN_2_PW_OFF			0x03
+#define ST_MAGN_2_FS_ADDR			0x21
+#define ST_MAGN_2_FS_MASK			0x60
+#define ST_MAGN_2_FS_AVL_4000_VAL		0x00
+#define ST_MAGN_2_FS_AVL_8000_VAL		0x01
+#define ST_MAGN_2_FS_AVL_10000_VAL		0x02
+#define ST_MAGN_2_FS_AVL_4000_GAIN		430
+#define ST_MAGN_2_FS_AVL_8000_GAIN		230
+#define ST_MAGN_2_FS_AVL_10000_GAIN		230
+#define ST_MAGN_2_MULTIREAD_BIT			false
+#define ST_MAGN_2_OUT_X_L_ADDR			0x28
+#define ST_MAGN_2_OUT_Y_L_ADDR			0x2a
+#define ST_MAGN_2_OUT_Z_L_ADDR			0x2c
+
+static const struct iio_chan_spec st_magn_16bit_channels[] = {
+	ST_SENSORS_LSM_CHANNELS(IIO_MAGN, ST_SENSORS_SCAN_X, IIO_MOD_X, IIO_LE,
+		ST_SENSORS_DEFAULT_16_REALBITS, ST_MAGN_DEFAULT_OUT_X_L_ADDR),
+	ST_SENSORS_LSM_CHANNELS(IIO_MAGN, ST_SENSORS_SCAN_Y, IIO_MOD_Y, IIO_LE,
+		ST_SENSORS_DEFAULT_16_REALBITS, ST_MAGN_DEFAULT_OUT_Y_L_ADDR),
+	ST_SENSORS_LSM_CHANNELS(IIO_MAGN, ST_SENSORS_SCAN_Z, IIO_MOD_Z, IIO_LE,
+		ST_SENSORS_DEFAULT_16_REALBITS, ST_MAGN_DEFAULT_OUT_Z_L_ADDR),
+	IIO_CHAN_SOFT_TIMESTAMP(3)
+};
+
+static const struct iio_chan_spec st_magn_2_16bit_channels[] = {
+	ST_SENSORS_LSM_CHANNELS(IIO_MAGN, ST_SENSORS_SCAN_X, IIO_MOD_X, IIO_LE,
+		ST_SENSORS_DEFAULT_16_REALBITS, ST_MAGN_2_OUT_X_L_ADDR),
+	ST_SENSORS_LSM_CHANNELS(IIO_MAGN, ST_SENSORS_SCAN_Y, IIO_MOD_Y, IIO_LE,
+		ST_SENSORS_DEFAULT_16_REALBITS, ST_MAGN_2_OUT_Y_L_ADDR),
+	ST_SENSORS_LSM_CHANNELS(IIO_MAGN, ST_SENSORS_SCAN_Z, IIO_MOD_Z, IIO_LE,
+		ST_SENSORS_DEFAULT_16_REALBITS, ST_MAGN_2_OUT_Z_L_ADDR),
+	IIO_CHAN_SOFT_TIMESTAMP(3)
+};
+
+static const struct st_sensors st_magn_sensors[] = {
+	{
+		.wai = ST_MAGN_1_WAI_EXP,
+		.sensors_supported = {
+			[0] = LSM303DLHC_MAGN_DEV_NAME,
+			[1] = LSM303DLM_MAGN_DEV_NAME,
+		},
+		.ch = (struct iio_chan_spec *)st_magn_16bit_channels,
+		.odr = {
+			.addr = ST_MAGN_1_ODR_ADDR,
+			.mask = ST_MAGN_1_ODR_MASK,
+			.odr_avl = {
+				{ 1, ST_MAGN_1_ODR_AVL_1HZ_VAL, },
+				{ 2, ST_MAGN_1_ODR_AVL_2HZ_VAL, },
+				{ 3, ST_MAGN_1_ODR_AVL_3HZ_VAL, },
+				{ 8, ST_MAGN_1_ODR_AVL_8HZ_VAL, },
+				{ 15, ST_MAGN_1_ODR_AVL_15HZ_VAL, },
+				{ 30, ST_MAGN_1_ODR_AVL_30HZ_VAL, },
+				{ 75, ST_MAGN_1_ODR_AVL_75HZ_VAL, },
+				{ 220, ST_MAGN_1_ODR_AVL_220HZ_VAL, },
+			},
+		},
+		.pw = {
+			.addr = ST_MAGN_1_PW_ADDR,
+			.mask = ST_MAGN_1_PW_MASK,
+			.value_on = ST_MAGN_1_PW_ON,
+			.value_off = ST_MAGN_1_PW_OFF,
+		},
+		.fs = {
+			.addr = ST_MAGN_1_FS_ADDR,
+			.mask = ST_MAGN_1_FS_MASK,
+			.fs_avl = {
+				[0] = {
+					.num = ST_MAGN_FS_AVL_1300MG,
+					.value = ST_MAGN_1_FS_AVL_1300_VAL,
+					.gain = ST_MAGN_1_FS_AVL_1300_GAIN_XY,
+					.gain2 = ST_MAGN_1_FS_AVL_1300_GAIN_Z,
+				},
+				[1] = {
+					.num = ST_MAGN_FS_AVL_1900MG,
+					.value = ST_MAGN_1_FS_AVL_1900_VAL,
+					.gain = ST_MAGN_1_FS_AVL_1900_GAIN_XY,
+					.gain2 = ST_MAGN_1_FS_AVL_1900_GAIN_Z,
+				},
+				[2] = {
+					.num = ST_MAGN_FS_AVL_2500MG,
+					.value = ST_MAGN_1_FS_AVL_2500_VAL,
+					.gain = ST_MAGN_1_FS_AVL_2500_GAIN_XY,
+					.gain2 = ST_MAGN_1_FS_AVL_2500_GAIN_Z,
+				},
+				[3] = {
+					.num = ST_MAGN_FS_AVL_4000MG,
+					.value = ST_MAGN_1_FS_AVL_4000_VAL,
+					.gain = ST_MAGN_1_FS_AVL_4000_GAIN_XY,
+					.gain2 = ST_MAGN_1_FS_AVL_4000_GAIN_Z,
+				},
+				[4] = {
+					.num = ST_MAGN_FS_AVL_4700MG,
+					.value = ST_MAGN_1_FS_AVL_4700_VAL,
+					.gain = ST_MAGN_1_FS_AVL_4700_GAIN_XY,
+					.gain2 = ST_MAGN_1_FS_AVL_4700_GAIN_Z,
+				},
+				[5] = {
+					.num = ST_MAGN_FS_AVL_5600MG,
+					.value = ST_MAGN_1_FS_AVL_5600_VAL,
+					.gain = ST_MAGN_1_FS_AVL_5600_GAIN_XY,
+					.gain2 = ST_MAGN_1_FS_AVL_5600_GAIN_Z,
+				},
+				[6] = {
+					.num = ST_MAGN_FS_AVL_8100MG,
+					.value = ST_MAGN_1_FS_AVL_8100_VAL,
+					.gain = ST_MAGN_1_FS_AVL_8100_GAIN_XY,
+					.gain2 = ST_MAGN_1_FS_AVL_8100_GAIN_Z,
+				},
+			},
+		},
+		.multi_read_bit = ST_MAGN_1_MULTIREAD_BIT,
+		.bootime = 2,
+	},
+	{
+		.wai = ST_MAGN_2_WAI_EXP,
+		.sensors_supported = {
+			[0] = LIS3MDL_MAGN_DEV_NAME,
+		},
+		.ch = (struct iio_chan_spec *)st_magn_2_16bit_channels,
+		.odr = {
+			.addr = ST_MAGN_2_ODR_ADDR,
+			.mask = ST_MAGN_2_ODR_MASK,
+			.odr_avl = {
+				{ 1, ST_MAGN_2_ODR_AVL_1HZ_VAL, },
+				{ 2, ST_MAGN_2_ODR_AVL_2HZ_VAL, },
+				{ 3, ST_MAGN_2_ODR_AVL_3HZ_VAL, },
+				{ 5, ST_MAGN_2_ODR_AVL_5HZ_VAL, },
+				{ 10, ST_MAGN_2_ODR_AVL_10HZ_VAL, },
+				{ 20, ST_MAGN_2_ODR_AVL_20HZ_VAL, },
+				{ 40, ST_MAGN_2_ODR_AVL_40HZ_VAL, },
+				{ 80, ST_MAGN_2_ODR_AVL_80HZ_VAL, },
+			},
+		},
+		.pw = {
+			.addr = ST_MAGN_2_PW_ADDR,
+			.mask = ST_MAGN_2_PW_MASK,
+			.value_on = ST_MAGN_2_PW_ON,
+			.value_off = ST_MAGN_2_PW_OFF,
+		},
+		.fs = {
+			.addr = ST_MAGN_2_FS_ADDR,
+			.mask = ST_MAGN_2_FS_MASK,
+			.fs_avl = {
+				[0] = {
+					.num = ST_MAGN_FS_AVL_4000MG,
+					.value = ST_MAGN_2_FS_AVL_4000_VAL,
+					.gain = ST_MAGN_2_FS_AVL_4000_GAIN,
+				},
+				[1] = {
+					.num = ST_MAGN_FS_AVL_8000MG,
+					.value = ST_MAGN_2_FS_AVL_8000_VAL,
+					.gain = ST_MAGN_2_FS_AVL_8000_GAIN,
+				},
+				[2] = {
+					.num = ST_MAGN_FS_AVL_10000MG,
+					.value = ST_MAGN_2_FS_AVL_10000_VAL,
+					.gain = ST_MAGN_2_FS_AVL_10000_GAIN,
+				},
+			},
+		},
+		.multi_read_bit = ST_MAGN_2_MULTIREAD_BIT,
+		.bootime = 2,
+	},
+};
+
+static int st_magn_read_raw(struct iio_dev *indio_dev,
+			struct iio_chan_spec const *ch, int *val,
+							int *val2, long mask)
+{
+	int err;
+	struct st_sensor_data *mdata = iio_priv(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		err = st_sensors_read_info_raw(indio_dev, ch, val);
+		if (err < 0)
+			goto read_error;
+
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		*val = 0;
+		if ((ch->scan_index == ST_SENSORS_SCAN_Z) &&
+					(mdata->current_fullscale->gain2 != 0))
+			*val2 = mdata->current_fullscale->gain2;
+		else
+			*val2 = mdata->current_fullscale->gain;
+		return IIO_VAL_INT_PLUS_MICRO;
+	default:
+		return -EINVAL;
+	}
+
+read_error:
+	return err;
+}
+
+static int st_magn_write_raw(struct iio_dev *indio_dev,
+		struct iio_chan_spec const *chan, int val, int val2, long mask)
+{
+	int err;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		err = st_sensors_set_fullscale_by_gain(indio_dev, val2);
+		break;
+	default:
+		err = -EINVAL;
+	}
+
+	return err;
+}
+
+static ST_SENSOR_DEV_ATTR_SAMP_FREQ();
+static ST_SENSORS_DEV_ATTR_SAMP_FREQ_AVAIL();
+static ST_SENSORS_DEV_ATTR_SCALE_AVAIL(in_magn_scale_available);
+
+static struct attribute *st_magn_attributes[] = {
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_in_magn_scale_available.dev_attr.attr,
+	&iio_dev_attr_sampling_frequency.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_magn_attribute_group = {
+	.attrs = st_magn_attributes,
+};
+
+static const struct iio_info magn_info = {
+	.driver_module = THIS_MODULE,
+	.attrs = &st_magn_attribute_group,
+	.read_raw = &st_magn_read_raw,
+	.write_raw = &st_magn_write_raw,
+};
+
+int st_magn_common_probe(struct iio_dev *indio_dev)
+{
+	int err;
+	struct st_sensor_data *mdata = iio_priv(indio_dev);
+
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->info = &magn_info;
+
+	err = st_sensors_check_device_support(indio_dev,
+				ARRAY_SIZE(st_magn_sensors), st_magn_sensors);
+	if (err < 0)
+		goto st_magn_common_probe_error;
+
+	mdata->multiread_bit = mdata->sensor->multi_read_bit;
+	indio_dev->channels = mdata->sensor->ch;
+	indio_dev->num_channels = ST_SENSORS_NUMBER_ALL_CHANNELS;
+
+	mdata->current_fullscale = (struct st_sensor_fullscale_avl *)
+						&mdata->sensor->fs.fs_avl[0];
+	mdata->odr = mdata->sensor->odr.odr_avl[0].hz;
+
+	err = st_sensors_init_sensor(indio_dev);
+	if (err < 0)
+		goto st_magn_common_probe_error;
+
+	if (mdata->get_irq_data_ready(indio_dev) > 0) {
+		err = st_magn_allocate_ring(indio_dev);
+		if (err < 0)
+			goto st_magn_common_probe_error;
+		err = st_sensors_allocate_trigger(indio_dev, NULL);
+		if (err < 0)
+			goto st_magn_probe_trigger_error;
+	}
+
+	err = iio_device_register(indio_dev);
+	if (err)
+		goto st_magn_device_register_error;
+
+	return err;
+
+st_magn_device_register_error:
+	if (mdata->get_irq_data_ready(indio_dev) > 0)
+		st_sensors_deallocate_trigger(indio_dev);
+st_magn_probe_trigger_error:
+	if (mdata->get_irq_data_ready(indio_dev) > 0)
+		st_magn_deallocate_ring(indio_dev);
+st_magn_common_probe_error:
+	return err;
+}
+EXPORT_SYMBOL(st_magn_common_probe);
+
+void st_magn_common_remove(struct iio_dev *indio_dev)
+{
+	struct st_sensor_data *mdata = iio_priv(indio_dev);
+
+	iio_device_unregister(indio_dev);
+	if (mdata->get_irq_data_ready(indio_dev) > 0) {
+		st_sensors_deallocate_trigger(indio_dev);
+		st_magn_deallocate_ring(indio_dev);
+	}
+	iio_device_free(indio_dev);
+}
+EXPORT_SYMBOL(st_magn_common_remove);
+
+MODULE_AUTHOR("Denis Ciocca <denis.ciocca@st.com>");
+MODULE_DESCRIPTION("STMicroelectronics magnetometers driver");
+MODULE_LICENSE("GPL v2");
