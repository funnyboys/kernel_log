commit 6562793b55c58b6b1dcb9cd581c7905afc25e89f
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Fri Mar 27 15:34:40 2020 -0700

    iio: cros_ec: Expose hwfifo_timeout
    
    Expose EC minimal interrupt period through buffer/hwfifo_timeout:
    - Maximal timeout is limited to 65s.
    - When timeout for all sensors is set to 0, EC will not send events,
      even if the sensor sampling rate is greater than 0.
    
    Rename frequency to sampling_frequency to match IIO ABI.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>

diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
index fad21a90bc7e..a66941fdb385 100644
--- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
+++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
@@ -236,6 +236,8 @@ static int cros_ec_sensors_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
+	iio_buffer_set_attrs(indio_dev->buffer, cros_ec_sensor_fifo_attributes);
+
 	indio_dev->info = &ec_sensors_info;
 	state = iio_priv(indio_dev);
 	for (channel = state->channels, i = CROS_EC_SENSOR_X;
@@ -247,7 +249,6 @@ static int cros_ec_sensors_probe(struct platform_device *pdev)
 			BIT(IIO_CHAN_INFO_CALIBSCALE);
 		channel->info_mask_shared_by_all =
 			BIT(IIO_CHAN_INFO_SCALE) |
-			BIT(IIO_CHAN_INFO_FREQUENCY) |
 			BIT(IIO_CHAN_INFO_SAMP_FREQ);
 		channel->info_mask_shared_by_all_available =
 			BIT(IIO_CHAN_INFO_SAMP_FREQ);

commit 2861be4ca9125ee1b7c49895948ca4236449a7fe
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Fri Mar 27 15:34:39 2020 -0700

    iio: cros_ec: Remove pm function
    
    Since cros_ec_sensorhub is shutting down the FIFO when the device
    suspends, no need to slow down the EC sampling period rate.
    
    It was necesseary to do that before command CMD_FIFO_INT_ENABLE was
    introduced, but now all supported chromebooks have it.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>

diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
index 711134d67dde..fad21a90bc7e 100644
--- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
+++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
@@ -314,7 +314,6 @@ MODULE_DEVICE_TABLE(platform, cros_ec_sensors_ids);
 static struct platform_driver cros_ec_sensors_platform_driver = {
 	.driver = {
 		.name	= "cros-ec-sensors",
-		.pm	= &cros_ec_sensors_pm_ops,
 	},
 	.probe		= cros_ec_sensors_probe,
 	.id_table	= cros_ec_sensors_ids,

commit aa984f1ba4a477c8ea39d2fa975a4f8de8a126e9
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Fri Mar 27 15:34:38 2020 -0700

    iio: cros_ec: Register to cros_ec_sensorhub when EC supports FIFO
    
    When EC supports FIFO, each IIO device registers a callback, to put
    samples in the buffer when they arrives from the FIFO.
    
    When no FIFO, the user space app needs to call trigger_new, or better
    register a high precision timer.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Reviewed-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>

diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
index 576e45faafaf..711134d67dde 100644
--- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
+++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
@@ -230,7 +230,9 @@ static int cros_ec_sensors_probe(struct platform_device *pdev)
 	if (!indio_dev)
 		return -ENOMEM;
 
-	ret = cros_ec_sensors_core_init(pdev, indio_dev, true);
+	ret = cros_ec_sensors_core_init(pdev, indio_dev, true,
+					cros_ec_sensors_capture,
+					cros_ec_sensors_push_data);
 	if (ret)
 		return ret;
 
@@ -292,11 +294,6 @@ static int cros_ec_sensors_probe(struct platform_device *pdev)
 	else
 		state->core.read_ec_sensors_data = cros_ec_sensors_read_cmd;
 
-	ret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,
-			cros_ec_sensors_capture, NULL);
-	if (ret)
-		return ret;
-
 	return devm_iio_device_register(dev, indio_dev);
 }
 

commit 11f1eabee0ba0aafe023ad92d1e3c29d0a96683e
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Tue Dec 3 15:50:18 2019 +0100

    cros_ec: treewide: Remove 'include/linux/mfd/cros_ec.h'
    
    This header file now only includes the cros_ec_dev struct, however, is the
    'include/linux/platform_data/cros_ec_proto.h' who contains the definition of
    all the Chrome OS EC related structs. There is no reason to have a
    separate include for this struct so move to the place where other
    structs are defined. That way, we can remove the include itself, but also
    simplify the common pattern
    
        #include <linux/mfd/cros_ec.h>
        #include <linux/platform_data/cros_ec_proto.h>
    
    for a single include
    
        #include <linux/platform_data/cros_ec_proto.h>
    
    The changes to remove the cros_ec.h include were generated with the
    following shell script:
    
        git grep -l "<linux/mfd/cros_ec.h>" | xargs sed -i '/<linux\/mfd\/cros_ec.h>/d'
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Acked-by: Sebastian Reichel <sre@kernel.org>
    Acked-by: Hans Verkuil <hverkuil-cisco@xs4all.nl>

diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
index 7dce04473467..576e45faafaf 100644
--- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
+++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
@@ -16,7 +16,6 @@
 #include <linux/iio/trigger_consumer.h>
 #include <linux/iio/triggered_buffer.h>
 #include <linux/kernel.h>
-#include <linux/mfd/cros_ec.h>
 #include <linux/module.h>
 #include <linux/platform_data/cros_ec_commands.h>
 #include <linux/platform_data/cros_ec_proto.h>

commit d60ac88a62df71cb12b2d60d2dae5658fb4eab43
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Tue Nov 19 13:45:45 2019 +0100

    mfd / platform / iio: cros_ec: Register sensor through sensorhub
    
    Remove the duplicated code in MFD, since MFD just registers cros-ec-sensorhub
    if at least one sensor is present.
    
    Change IIO cros-ec driver to get the pointer to the cros-ec-dev through
    cros-ec-sensorhub.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Acked-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>

diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
index a6987726eeb8..7dce04473467 100644
--- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
+++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
@@ -222,17 +222,11 @@ static const struct iio_info ec_sensors_info = {
 static int cros_ec_sensors_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
-	struct cros_ec_dev *ec_dev = dev_get_drvdata(dev->parent);
 	struct iio_dev *indio_dev;
 	struct cros_ec_sensors_state *state;
 	struct iio_chan_spec *channel;
 	int ret, i;
 
-	if (!ec_dev || !ec_dev->ec_dev) {
-		dev_warn(&pdev->dev, "No CROS EC device found.\n");
-		return -EINVAL;
-	}
-
 	indio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*state));
 	if (!indio_dev)
 		return -ENOMEM;

commit 32b90daf5cafdda62b1ce62d0b7445fa9107babf
Merge: c6cfaf4f86d9 4c1fde5077dc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 19 14:14:28 2019 -0700

    Merge tag 'tag-chrome-platform-for-v5.4' of git://git.kernel.org/pub/scm/linux/kernel/git/chrome-platform/linux
    
    Pull chrome platform updates from Benson Leung:
     "CrOS EC / MFD Migration:
        - Move cros_ec core driver from mfd into chrome platform.
    
      Wilco EC:
        - Add batt_ppid_info command to Wilco telemetry driver.
    
      CrOS EC:
        - cros_ec_rpmsg : Add support to inform EC of suspend/resume status
        - cros_ec_rpmsg : Fix race condition on probe failed
        - cros_ec_chardev : Add a poll handler to receive MKBP events
    
      Misc:
        - bugfixes in cros_usbpd_logger and cros_ec_ishtp"
    
    * tag 'tag-chrome-platform-for-v5.4' of git://git.kernel.org/pub/scm/linux/kernel/git/chrome-platform/linux:
      platform/chrome: cros_usbpd_logger: null check create_singlethread_workqueue
      platform/chrome: cros_ec_chardev: Add a poll handler to receive MKBP events
      platform/chrome: cros_ec_rpmsg: Fix race with host command when probe failed
      platform/chrome: chromeos_tbmc: Report wake events
      mfd: cros_ec: Use mfd_add_hotplug_devices() helper
      mfd: cros_ec: Add convenience struct to define autodetectable CrOS EC subdevices
      mfd: cros_ec: Add convenience struct to define dedicated CrOS EC MCUs
      mfd: cros_ec: Use kzalloc and cros_ec_cmd_xfer_status helper
      mfd / platform: cros_ec: Reorganize platform and mfd includes
      mfd / platform: cros_ec: Rename config to a better name
      mfd: cros_ec: Switch to use the new cros-ec-chardev driver
      mfd / platform: cros_ec: Miscellaneous character device to talk with the EC
      mfd / platform: cros_ec: Move cros-ec core driver out from MFD
      mfd / platform: cros_ec: Handle chained ECs as platform devices
      platform/chrome: cros_ec_rpmsg: Add host command AP sleep state support
      platform/chrome: chromeos_laptop: drop checks of NULL-safe functions
      platform/chrome: wilco_ec: Add batt_ppid_info command to telemetry driver

commit 840d9f131f65b021e0a73f3371f3194897dba6ad
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Mon Sep 2 11:53:05 2019 +0200

    mfd / platform: cros_ec: Reorganize platform and mfd includes
    
    There is a bit of mess between cros-ec mfd includes and platform
    includes. For example, we have a linux/mfd/cros_ec.h include that
    exports the interface implemented in platform/chrome/cros_ec_proto.c. Or
    we have a linux/mfd/cros_ec_commands.h file that is non related to the
    multifunction device (in the sense that is not exporting any function of
    the mfd device). This causes crossed includes between mfd and
    platform/chrome subsystems and makes the code difficult to read, apart
    from creating 'curious' situations where a platform/chrome driver includes
    a linux/mfd/cros_ec.h file just to get the exported functions that are
    implemented in another platform/chrome driver.
    
    In order to have a better separation on what the cros-ec multifunction
    driver does and what the cros-ec core provides move and rework the
    affected includes doing:
    
     - Move cros_ec_commands.h to include/linux/platform_data/cros_ec_commands.h
     - Get rid of the parts that are implemented in the platform/chrome/cros_ec_proto.c
       driver from include/linux/mfd/cros_ec.h to a new file
       include/linux/platform_data/cros_ec_proto.h
     - Update all the drivers with the new includes, so
       - Drivers that only need to know about the protocol include
         - linux/platform_data/cros_ec_proto.h
         - linux/platform_data/cros_ec_commands.h
       - Drivers that need to know about the cros-ec mfd device also include
         - linux/mfd/cros_ec.h
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Mark Brown <broonie@kernel.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Acked-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Acked-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Sebastian Reichel <sebastian.reichel@collabora.com>
    Acked-by: Chanwoo Choi <cw00.choi@samsung.com>
    Reviewed-by: Gwendal Grignou <gwendal@chromium.org>
    Tested-by: Gwendal Grignou <gwendal@chromium.org>
    Series changes: 3
    - Fix dereferencing pointer to incomplete type 'struct cros_ec_dev' (lkp)
    Signed-off-by: Lee Jones <lee.jones@linaro.org>

diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
index 17af4e0fd5f8..40dc24ff0ee5 100644
--- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
+++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
@@ -17,8 +17,9 @@
 #include <linux/iio/triggered_buffer.h>
 #include <linux/kernel.h>
 #include <linux/mfd/cros_ec.h>
-#include <linux/mfd/cros_ec_commands.h>
 #include <linux/module.h>
+#include <linux/platform_data/cros_ec_commands.h>
+#include <linux/platform_data/cros_ec_proto.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 

commit ae7b02ad2f32d39d1434655f346c04a16c1aa703
Author: Fabien Lahoudere <fabien.lahoudere@collabora.com>
Date:   Tue Jul 16 11:11:06 2019 +0200

    iio: common: cros_ec_sensors: Expose cros_ec_sensors frequency range via iio sysfs
    
    Embedded controller return minimum and maximum frequencies, unfortunately
    we have no way to know the step for all available frequencies.
    Even if not complete, we can return a list of known values using the
    standard read_avail callback (IIO_CHAN_INFO_SAMP_FREQ) to provide them to
    userland.
    
    Now cros_ec_* sensors provides frequencies values in sysfs like this:
    "0 min max". 0 is always true to disable the sensor.
    
    Default frequencies are provided for earlier protocol.
    
    Signed-off-by: Nick Vaccaro <nvaccaro@chromium.org>
    Signed-off-by: Fabien Lahoudere <fabien.lahoudere@collabora.com>
    [rebased on top of iio/testing and solved conflicts]
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
index 2af09606c438..6a4919cd83c3 100644
--- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
+++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
@@ -215,6 +215,7 @@ static int cros_ec_sensors_write(struct iio_dev *indio_dev,
 static const struct iio_info ec_sensors_info = {
 	.read_raw = &cros_ec_sensors_read,
 	.write_raw = &cros_ec_sensors_write,
+	.read_avail = &cros_ec_sensors_core_read_avail,
 };
 
 static int cros_ec_sensors_probe(struct platform_device *pdev)
@@ -252,6 +253,8 @@ static int cros_ec_sensors_probe(struct platform_device *pdev)
 			BIT(IIO_CHAN_INFO_SCALE) |
 			BIT(IIO_CHAN_INFO_FREQUENCY) |
 			BIT(IIO_CHAN_INFO_SAMP_FREQ);
+		channel->info_mask_shared_by_all_available =
+			BIT(IIO_CHAN_INFO_SAMP_FREQ);
 		channel->scan_type.realbits = CROS_EC_SENSOR_BITS;
 		channel->scan_type.storagebits = CROS_EC_SENSOR_BITS;
 		channel->scan_index = i;

commit ed1f2e85da79274f3dc4092953f1359eb732f0c6
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Thu Jul 18 16:28:24 2019 -0700

    iio: cros_ec: Add calibscale for 3d MEMS
    
    Add calibration scale support to accel, gyro and magnetometer.
    
    Check on eve with current firmware, check reading calibscale returns 1.0,
    check with newer firmware values are applied.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
index 17af4e0fd5f8..2af09606c438 100644
--- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
+++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
@@ -63,10 +63,35 @@ static int cros_ec_sensors_read(struct iio_dev *indio_dev,
 
 		/* Save values */
 		for (i = CROS_EC_SENSOR_X; i < CROS_EC_SENSOR_MAX_AXIS; i++)
-			st->core.calib[i] =
+			st->core.calib[i].offset =
 				st->core.resp->sensor_offset.offset[i];
 		ret = IIO_VAL_INT;
-		*val = st->core.calib[idx];
+		*val = st->core.calib[idx].offset;
+		break;
+	case IIO_CHAN_INFO_CALIBSCALE:
+		st->core.param.cmd = MOTIONSENSE_CMD_SENSOR_SCALE;
+		st->core.param.sensor_offset.flags = 0;
+
+		ret = cros_ec_motion_send_host_cmd(&st->core, 0);
+		if (ret == -EPROTO) {
+			/* Reading calibscale is not supported on older EC. */
+			*val = 1;
+			*val2 = 0;
+			ret = IIO_VAL_INT_PLUS_MICRO;
+			break;
+		} else if (ret) {
+			break;
+		}
+
+		/* Save values */
+		for (i = CROS_EC_SENSOR_X; i < CROS_EC_SENSOR_MAX_AXIS; i++)
+			st->core.calib[i].scale =
+				st->core.resp->sensor_scale.scale[i];
+
+		*val = st->core.calib[idx].scale >> 15;
+		*val2 = ((st->core.calib[idx].scale & 0x7FFF) * 1000000LL) /
+			MOTION_SENSE_DEFAULT_SCALE;
+		ret = IIO_VAL_INT_PLUS_MICRO;
 		break;
 	case IIO_CHAN_INFO_SCALE:
 		st->core.param.cmd = MOTIONSENSE_CMD_SENSOR_RANGE;
@@ -134,7 +159,7 @@ static int cros_ec_sensors_write(struct iio_dev *indio_dev,
 
 	switch (mask) {
 	case IIO_CHAN_INFO_CALIBBIAS:
-		st->core.calib[idx] = val;
+		st->core.calib[idx].offset = val;
 
 		/* Send to EC for each axis, even if not complete */
 		st->core.param.cmd = MOTIONSENSE_CMD_SENSOR_OFFSET;
@@ -142,10 +167,25 @@ static int cros_ec_sensors_write(struct iio_dev *indio_dev,
 			MOTION_SENSE_SET_OFFSET;
 		for (i = CROS_EC_SENSOR_X; i < CROS_EC_SENSOR_MAX_AXIS; i++)
 			st->core.param.sensor_offset.offset[i] =
-				st->core.calib[i];
+				st->core.calib[i].offset;
 		st->core.param.sensor_offset.temp =
 			EC_MOTION_SENSE_INVALID_CALIB_TEMP;
 
+		ret = cros_ec_motion_send_host_cmd(&st->core, 0);
+		break;
+	case IIO_CHAN_INFO_CALIBSCALE:
+		st->core.calib[idx].scale = val;
+		/* Send to EC for each axis, even if not complete */
+
+		st->core.param.cmd = MOTIONSENSE_CMD_SENSOR_SCALE;
+		st->core.param.sensor_offset.flags =
+			MOTION_SENSE_SET_OFFSET;
+		for (i = CROS_EC_SENSOR_X; i < CROS_EC_SENSOR_MAX_AXIS; i++)
+			st->core.param.sensor_scale.scale[i] =
+				st->core.calib[i].scale;
+		st->core.param.sensor_scale.temp =
+			EC_MOTION_SENSE_INVALID_CALIB_TEMP;
+
 		ret = cros_ec_motion_send_host_cmd(&st->core, 0);
 		break;
 	case IIO_CHAN_INFO_SCALE:
@@ -206,7 +246,8 @@ static int cros_ec_sensors_probe(struct platform_device *pdev)
 		/* Common part */
 		channel->info_mask_separate =
 			BIT(IIO_CHAN_INFO_RAW) |
-			BIT(IIO_CHAN_INFO_CALIBBIAS);
+			BIT(IIO_CHAN_INFO_CALIBBIAS) |
+			BIT(IIO_CHAN_INFO_CALIBSCALE);
 		channel->info_mask_shared_by_all =
 			BIT(IIO_CHAN_INFO_SCALE) |
 			BIT(IIO_CHAN_INFO_FREQUENCY) |

commit 817de6b85914a3dda72b971c074d4d342965fba0
Merge: 7dc7967fc39a 085b7755808a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Apr 21 23:18:44 2019 +0200

    Merge 5.1-rc6 into staging-next
    
    We want the fixes in here as well as this resolves an iio driver merge
    issue.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 37aa055c417211913240c36aa394edb6266d5ca1
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Wed Mar 13 12:41:20 2019 +0100

    iio: cros_ec: Switch to SPDX identifier.
    
    Adopt the SPDX license identifier headers to ease license compliance
    management. Also fix MODULE_LICENSE for cros_ec_accel_legacy to match
    the SPDX and boiler plate license.
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
index b233a0d0909c..2dafe49aeafd 100644
--- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
+++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
@@ -1,17 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * cros_ec_sensors - Driver for Chrome OS Embedded Controller sensors.
  *
  * Copyright (C) 2016 Google, Inc
  *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  * This driver uses the cros-ec interface to communicate with the Chrome OS
  * EC about sensors data. Data access is presented through iio sysfs.
  */

commit b921d928a31c78b083a34140204f2ad183bcc083
Author: Guenter Roeck <groeck@chromium.org>
Date:   Wed Mar 13 12:40:32 2019 +0100

    iio: cros_ec: Drop unnecessary include files
    
    The cros_ec sensors drivers do not call any sysfs functions
    or use any sysfs defines, and thus do not need to include
    linux/sysfs.h. Also, some cros_ec drivers include linux/delay.h
    and is not used.
    
    Signed-off-by: Guenter Roeck <groeck@chromium.org>
    [remove linux/delay.h]
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
index 89cb0066a6e0..b233a0d0909c 100644
--- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
+++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
@@ -16,7 +16,6 @@
  * EC about sensors data. Data access is presented through iio sysfs.
  */
 
-#include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/iio/buffer.h>
 #include <linux/iio/common/cros_ec_sensors_core.h>
@@ -30,7 +29,6 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
-#include <linux/sysfs.h>
 
 #define CROS_EC_SENSORS_MAX_CHANNELS 4
 

commit 3d02d7082e5823598090530c3988a35f69689943
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Wed Mar 13 12:40:02 2019 +0100

    iio: cros_ec: Fix the maths for gyro scale calculation
    
    Calculation did not use IIO_DEGREE_TO_RAD and implemented a variant to
    avoid precision loss as we aim a nano value. The offset added to avoid
    rounding error, though, doesn't give us a close result to the expected
    value. E.g.
    
    For 1000dps, the result should be:
    
        (1000 * pi ) / 180 >> 15 ~= 0.000532632218
    
    But with current calculation we get
    
        $ cat scale
        0.000547890
    
    Fix the calculation by just doing the maths involved for a nano value
    
       val * pi * 10e12 / (180 * 2^15)
    
    so we get a closer result.
    
        $ cat scale
        0.000532632
    
    Fixes: c14dca07a31d ("iio: cros_ec_sensors: add ChromeOS EC Contiguous Sensors driver")
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Cc: <Stable@vger.kernel.org>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
index 89cb0066a6e0..8d76afb87d87 100644
--- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
+++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
@@ -103,9 +103,10 @@ static int cros_ec_sensors_read(struct iio_dev *indio_dev,
 			 * Do not use IIO_DEGREE_TO_RAD to avoid precision
 			 * loss. Round to the nearest integer.
 			 */
-			*val = div_s64(val64 * 314159 + 9000000ULL, 1000);
-			*val2 = 18000 << (CROS_EC_SENSOR_BITS - 1);
-			ret = IIO_VAL_FRACTIONAL;
+			*val = 0;
+			*val2 = div_s64(val64 * 3141592653ULL,
+					180 << (CROS_EC_SENSOR_BITS - 1));
+			ret = IIO_VAL_INT_PLUS_NANO;
 			break;
 		case MOTIONSENSE_TYPE_MAG:
 			/*

commit 5a0b8cb46624cc17fda676d6ae44fb72504f0ad9
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Tue Mar 13 14:23:28 2018 -0700

    iio: cros_ec: Move cros_ec_sensors_core.h in /include
    
    Similar to other common iio frameworks, move cros_ec_sensors_core.h from
    drivers/iio/common/cros_ec_sensors/ to include/linux/iio/common.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
index 705cb3e72663..89cb0066a6e0 100644
--- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
+++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
@@ -19,6 +19,7 @@
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/iio/buffer.h>
+#include <linux/iio/common/cros_ec_sensors_core.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/kfifo_buf.h>
 #include <linux/iio/trigger_consumer.h>
@@ -31,8 +32,6 @@
 #include <linux/slab.h>
 #include <linux/sysfs.h>
 
-#include "cros_ec_sensors_core.h"
-
 #define CROS_EC_SENSORS_MAX_CHANNELS 4
 
 /* State data for ec_sensors iio driver. */

commit 0dad1eceeb9c7497e7e2a592900ddac79b128c56
Author: Gwendal Grignou <gwendal@chromium.org>
Date:   Wed Feb 21 16:11:09 2018 +0100

    iio: cros_ec: Relax sampling frequency before suspending
    
    If an application set a tight sampling frequency, given the interrupt
    use is a wakeup source, suspend will not happen: the kernel will receive
    a wake up interrupt and will cancel the suspend process.
    
    Given cros_ec sensors type is non wake up, this patch adds prepare and
    complete callbacks to set 1s sampling period just before suspend. This
    ensures the sensor hub will not be a source of interrupt during the
    suspend process.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
index 7d30c59da3e2..705cb3e72663 100644
--- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
+++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
@@ -289,6 +289,7 @@ MODULE_DEVICE_TABLE(platform, cros_ec_sensors_ids);
 static struct platform_driver cros_ec_sensors_platform_driver = {
 	.driver = {
 		.name	= "cros-ec-sensors",
+		.pm	= &cros_ec_sensors_pm_ops,
 	},
 	.probe		= cros_ec_sensors_probe,
 	.id_table	= cros_ec_sensors_ids,

commit 5f045af0b5dcdeba2776f0123bb33aba57f7b265
Author: Paolo Cretaro <paolocretaro@gmail.com>
Date:   Sun Nov 19 01:57:45 2017 +0100

    iio: cros_ec: Remove unused variables
    
    Fix gcc warnings about variable 'ec_device' being set but not used
    in these files:
    common/cros_ec_sensors/cros_ec_sensors.c:194:25
    light/cros_ec_light_prox.c:184:25
    
    Signed-off-by: Paolo Cretaro <paolocretaro@gmail.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
index ed8063f2da99..7d30c59da3e2 100644
--- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
+++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
@@ -191,7 +191,6 @@ static int cros_ec_sensors_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct cros_ec_dev *ec_dev = dev_get_drvdata(dev->parent);
-	struct cros_ec_device *ec_device;
 	struct iio_dev *indio_dev;
 	struct cros_ec_sensors_state *state;
 	struct iio_chan_spec *channel;
@@ -201,7 +200,6 @@ static int cros_ec_sensors_probe(struct platform_device *pdev)
 		dev_warn(&pdev->dev, "No CROS EC device found.\n");
 		return -EINVAL;
 	}
-	ec_device = ec_dev->ec_dev;
 
 	indio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*state));
 	if (!indio_dev)

commit d177f6af48e494143e374bbc91bad922442a28d2
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sun Jul 23 17:25:51 2017 +0100

    iio:common: drop assign iio_info.driver_module and iio_trigger_ops.owner
    
    The equivalent of both of these are now done via macro magic when
    the relevant register calls are made.  The actual structure
    elements will shortly go away.
    
    Clearly this set jumps across multiple areas, but inherently it
    can't be grouped like the other sets in this series so I've done
    all the stuff in the common directory together.
    
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>

diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
index 38e8783e4b05..ed8063f2da99 100644
--- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
+++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
@@ -185,7 +185,6 @@ static int cros_ec_sensors_write(struct iio_dev *indio_dev,
 static const struct iio_info ec_sensors_info = {
 	.read_raw = &cros_ec_sensors_read,
 	.write_raw = &cros_ec_sensors_write,
-	.driver_module = THIS_MODULE,
 };
 
 static int cros_ec_sensors_probe(struct platform_device *pdev)

commit f78a8236c6502760705399dfa42e22ab11aa1e6b
Merge: 6cb3d05f3030 39da7c509acf
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Apr 10 15:21:55 2017 +0200

    Merge 4.11-rc6 into staging-next
    
    We want the staging and iio fixes in here to handle merging easier.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 754434c445dafe79d55304a698c231ecbcc046d7
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Fri Mar 24 18:44:03 2017 +0100

    iio: cros_ec_sensors: Use devm to setup the triggered buffer.
    
    Use resourced managed function devm_iio_triggered_buffer_setup
    to make error path simpler and be able to get rid of the remove
    function.
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
index d6c372bb433b..cbf6288ad174 100644
--- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
+++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
@@ -267,31 +267,12 @@ static int cros_ec_sensors_probe(struct platform_device *pdev)
 	else
 		state->core.read_ec_sensors_data = cros_ec_sensors_read_cmd;
 
-	ret = iio_triggered_buffer_setup(indio_dev, NULL,
-					 cros_ec_sensors_capture, NULL);
+	ret = devm_iio_triggered_buffer_setup(dev, indio_dev, NULL,
+			cros_ec_sensors_capture, NULL);
 	if (ret)
 		return ret;
 
-	ret = iio_device_register(indio_dev);
-	if (ret)
-		goto error_uninit_buffer;
-
-	return 0;
-
-error_uninit_buffer:
-	iio_triggered_buffer_cleanup(indio_dev);
-
-	return ret;
-}
-
-static int cros_ec_sensors_remove(struct platform_device *pdev)
-{
-	struct iio_dev *indio_dev = platform_get_drvdata(pdev);
-
-	iio_device_unregister(indio_dev);
-	iio_triggered_buffer_cleanup(indio_dev);
-
-	return 0;
+	return devm_iio_device_register(dev, indio_dev);
 }
 
 static const struct platform_device_id cros_ec_sensors_ids[] = {
@@ -313,7 +294,6 @@ static struct platform_driver cros_ec_sensors_platform_driver = {
 		.name	= "cros-ec-sensors",
 	},
 	.probe		= cros_ec_sensors_probe,
-	.remove		= cros_ec_sensors_remove,
 	.id_table	= cros_ec_sensors_ids,
 };
 module_platform_driver(cros_ec_sensors_platform_driver);

commit a096926ed4532eac38d4ec92aaba8c7f2149d89a
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Fri Mar 24 18:44:02 2017 +0100

    iio: cros_ec_sensors: Fix return value to get raw and calibbias data.
    
    The cros_ec_sensors_read function must return the type of value on all
    cases. This was always true except for RAW and CALIBBIAS data which
    returned an error or 0. This patch just fixes the mistake I introduced
    when submitting the series.
    
    Fixes: commit c14dca07a31d (iio: cros_ec_sensors: add ChromeOS EC
    Contiguous Sensors driver)
    
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
index d6c372bb433b..c17596f7ed2c 100644
--- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
+++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
@@ -61,7 +61,7 @@ static int cros_ec_sensors_read(struct iio_dev *indio_dev,
 		ret = st->core.read_ec_sensors_data(indio_dev, 1 << idx, &data);
 		if (ret < 0)
 			break;
-
+		ret = IIO_VAL_INT;
 		*val = data;
 		break;
 	case IIO_CHAN_INFO_CALIBBIAS:
@@ -76,7 +76,7 @@ static int cros_ec_sensors_read(struct iio_dev *indio_dev,
 		for (i = CROS_EC_SENSOR_X; i < CROS_EC_SENSOR_MAX_AXIS; i++)
 			st->core.calib[i] =
 				st->core.resp->sensor_offset.offset[i];
-
+		ret = IIO_VAL_INT;
 		*val = st->core.calib[idx];
 		break;
 	case IIO_CHAN_INFO_SCALE:

commit 5668bfdd90cd7b330aa25a5ff853b55dc224d13d
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Mon Aug 1 11:54:38 2016 +0200

    platform/chrome: cros_ec_dev - Register cros-ec sensors
    
    Check whether the ChromeOS Embedded Controller is a sensor hub and in
    such case issue a command to get the number of sensors and register them
    all.
    
    Signed-off-by: Gwendal Grignou <gwendal@chromium.org>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Reviewed-by: Guenter Roeck <groeck@chromium.org>
    Acked-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
index 48edeba35b83..d6c372bb433b 100644
--- a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
+++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
@@ -51,7 +51,7 @@ static int cros_ec_sensors_read(struct iio_dev *indio_dev,
 	s16 data = 0;
 	s64 val64;
 	int i;
-	int ret = IIO_VAL_INT;
+	int ret;
 	int idx = chan->scan_index;
 
 	mutex_lock(&st->core.cmd_lock);
@@ -137,7 +137,7 @@ static int cros_ec_sensors_write(struct iio_dev *indio_dev,
 {
 	struct cros_ec_sensors_state *st = iio_priv(indio_dev);
 	int i;
-	int ret = 0;
+	int ret;
 	int idx = chan->scan_index;
 
 	mutex_lock(&st->core.cmd_lock);

commit c14dca07a31dac8bd91aa818df62fb3bf1d846c5
Author: Enric Balletbo i Serra <enric.balletbo@collabora.com>
Date:   Mon Aug 1 11:54:36 2016 +0200

    iio: cros_ec_sensors: add ChromeOS EC Contiguous Sensors driver
    
    Handle 3d contiguous sensors like Accelerometers, Gyroscope and
    Magnetometer that are presented by the ChromeOS EC Sensor hub.
    
    Signed-off-by: Guenter Roeck <groeck@chromium.org>
    Signed-off-by: Enric Balletbo i Serra <enric.balletbo@collabora.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
new file mode 100644
index 000000000000..48edeba35b83
--- /dev/null
+++ b/drivers/iio/common/cros_ec_sensors/cros_ec_sensors.c
@@ -0,0 +1,322 @@
+/*
+ * cros_ec_sensors - Driver for Chrome OS Embedded Controller sensors.
+ *
+ * Copyright (C) 2016 Google, Inc
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * This driver uses the cros-ec interface to communicate with the Chrome OS
+ * EC about sensors data. Data access is presented through iio sysfs.
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/kfifo_buf.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/triggered_buffer.h>
+#include <linux/kernel.h>
+#include <linux/mfd/cros_ec.h>
+#include <linux/mfd/cros_ec_commands.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/sysfs.h>
+
+#include "cros_ec_sensors_core.h"
+
+#define CROS_EC_SENSORS_MAX_CHANNELS 4
+
+/* State data for ec_sensors iio driver. */
+struct cros_ec_sensors_state {
+	/* Shared by all sensors */
+	struct cros_ec_sensors_core_state core;
+
+	struct iio_chan_spec channels[CROS_EC_SENSORS_MAX_CHANNELS];
+};
+
+static int cros_ec_sensors_read(struct iio_dev *indio_dev,
+			  struct iio_chan_spec const *chan,
+			  int *val, int *val2, long mask)
+{
+	struct cros_ec_sensors_state *st = iio_priv(indio_dev);
+	s16 data = 0;
+	s64 val64;
+	int i;
+	int ret = IIO_VAL_INT;
+	int idx = chan->scan_index;
+
+	mutex_lock(&st->core.cmd_lock);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		ret = st->core.read_ec_sensors_data(indio_dev, 1 << idx, &data);
+		if (ret < 0)
+			break;
+
+		*val = data;
+		break;
+	case IIO_CHAN_INFO_CALIBBIAS:
+		st->core.param.cmd = MOTIONSENSE_CMD_SENSOR_OFFSET;
+		st->core.param.sensor_offset.flags = 0;
+
+		ret = cros_ec_motion_send_host_cmd(&st->core, 0);
+		if (ret < 0)
+			break;
+
+		/* Save values */
+		for (i = CROS_EC_SENSOR_X; i < CROS_EC_SENSOR_MAX_AXIS; i++)
+			st->core.calib[i] =
+				st->core.resp->sensor_offset.offset[i];
+
+		*val = st->core.calib[idx];
+		break;
+	case IIO_CHAN_INFO_SCALE:
+		st->core.param.cmd = MOTIONSENSE_CMD_SENSOR_RANGE;
+		st->core.param.sensor_range.data = EC_MOTION_SENSE_NO_VALUE;
+
+		ret = cros_ec_motion_send_host_cmd(&st->core, 0);
+		if (ret < 0)
+			break;
+
+		val64 = st->core.resp->sensor_range.ret;
+		switch (st->core.type) {
+		case MOTIONSENSE_TYPE_ACCEL:
+			/*
+			 * EC returns data in g, iio exepects m/s^2.
+			 * Do not use IIO_G_TO_M_S_2 to avoid precision loss.
+			 */
+			*val = div_s64(val64 * 980665, 10);
+			*val2 = 10000 << (CROS_EC_SENSOR_BITS - 1);
+			ret = IIO_VAL_FRACTIONAL;
+			break;
+		case MOTIONSENSE_TYPE_GYRO:
+			/*
+			 * EC returns data in dps, iio expects rad/s.
+			 * Do not use IIO_DEGREE_TO_RAD to avoid precision
+			 * loss. Round to the nearest integer.
+			 */
+			*val = div_s64(val64 * 314159 + 9000000ULL, 1000);
+			*val2 = 18000 << (CROS_EC_SENSOR_BITS - 1);
+			ret = IIO_VAL_FRACTIONAL;
+			break;
+		case MOTIONSENSE_TYPE_MAG:
+			/*
+			 * EC returns data in 16LSB / uT,
+			 * iio expects Gauss
+			 */
+			*val = val64;
+			*val2 = 100 << (CROS_EC_SENSOR_BITS - 1);
+			ret = IIO_VAL_FRACTIONAL;
+			break;
+		default:
+			ret = -EINVAL;
+		}
+		break;
+	default:
+		ret = cros_ec_sensors_core_read(&st->core, chan, val, val2,
+						mask);
+		break;
+	}
+	mutex_unlock(&st->core.cmd_lock);
+
+	return ret;
+}
+
+static int cros_ec_sensors_write(struct iio_dev *indio_dev,
+			       struct iio_chan_spec const *chan,
+			       int val, int val2, long mask)
+{
+	struct cros_ec_sensors_state *st = iio_priv(indio_dev);
+	int i;
+	int ret = 0;
+	int idx = chan->scan_index;
+
+	mutex_lock(&st->core.cmd_lock);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_CALIBBIAS:
+		st->core.calib[idx] = val;
+
+		/* Send to EC for each axis, even if not complete */
+		st->core.param.cmd = MOTIONSENSE_CMD_SENSOR_OFFSET;
+		st->core.param.sensor_offset.flags =
+			MOTION_SENSE_SET_OFFSET;
+		for (i = CROS_EC_SENSOR_X; i < CROS_EC_SENSOR_MAX_AXIS; i++)
+			st->core.param.sensor_offset.offset[i] =
+				st->core.calib[i];
+		st->core.param.sensor_offset.temp =
+			EC_MOTION_SENSE_INVALID_CALIB_TEMP;
+
+		ret = cros_ec_motion_send_host_cmd(&st->core, 0);
+		break;
+	case IIO_CHAN_INFO_SCALE:
+		if (st->core.type == MOTIONSENSE_TYPE_MAG) {
+			ret = -EINVAL;
+			break;
+		}
+		st->core.param.cmd = MOTIONSENSE_CMD_SENSOR_RANGE;
+		st->core.param.sensor_range.data = val;
+
+		/* Always roundup, so caller gets at least what it asks for. */
+		st->core.param.sensor_range.roundup = 1;
+
+		ret = cros_ec_motion_send_host_cmd(&st->core, 0);
+		break;
+	default:
+		ret = cros_ec_sensors_core_write(
+				&st->core, chan, val, val2, mask);
+		break;
+	}
+
+	mutex_unlock(&st->core.cmd_lock);
+
+	return ret;
+}
+
+static const struct iio_info ec_sensors_info = {
+	.read_raw = &cros_ec_sensors_read,
+	.write_raw = &cros_ec_sensors_write,
+	.driver_module = THIS_MODULE,
+};
+
+static int cros_ec_sensors_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct cros_ec_dev *ec_dev = dev_get_drvdata(dev->parent);
+	struct cros_ec_device *ec_device;
+	struct iio_dev *indio_dev;
+	struct cros_ec_sensors_state *state;
+	struct iio_chan_spec *channel;
+	int ret, i;
+
+	if (!ec_dev || !ec_dev->ec_dev) {
+		dev_warn(&pdev->dev, "No CROS EC device found.\n");
+		return -EINVAL;
+	}
+	ec_device = ec_dev->ec_dev;
+
+	indio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*state));
+	if (!indio_dev)
+		return -ENOMEM;
+
+	ret = cros_ec_sensors_core_init(pdev, indio_dev, true);
+	if (ret)
+		return ret;
+
+	indio_dev->info = &ec_sensors_info;
+	state = iio_priv(indio_dev);
+	for (channel = state->channels, i = CROS_EC_SENSOR_X;
+	     i < CROS_EC_SENSOR_MAX_AXIS; i++, channel++) {
+		/* Common part */
+		channel->info_mask_separate =
+			BIT(IIO_CHAN_INFO_RAW) |
+			BIT(IIO_CHAN_INFO_CALIBBIAS);
+		channel->info_mask_shared_by_all =
+			BIT(IIO_CHAN_INFO_SCALE) |
+			BIT(IIO_CHAN_INFO_FREQUENCY) |
+			BIT(IIO_CHAN_INFO_SAMP_FREQ);
+		channel->scan_type.realbits = CROS_EC_SENSOR_BITS;
+		channel->scan_type.storagebits = CROS_EC_SENSOR_BITS;
+		channel->scan_index = i;
+		channel->ext_info = cros_ec_sensors_ext_info;
+		channel->modified = 1;
+		channel->channel2 = IIO_MOD_X + i;
+		channel->scan_type.sign = 's';
+
+		/* Sensor specific */
+		switch (state->core.type) {
+		case MOTIONSENSE_TYPE_ACCEL:
+			channel->type = IIO_ACCEL;
+			break;
+		case MOTIONSENSE_TYPE_GYRO:
+			channel->type = IIO_ANGL_VEL;
+			break;
+		case MOTIONSENSE_TYPE_MAG:
+			channel->type = IIO_MAGN;
+			break;
+		default:
+			dev_err(&pdev->dev, "Unknown motion sensor\n");
+			return -EINVAL;
+		}
+	}
+
+	/* Timestamp */
+	channel->type = IIO_TIMESTAMP;
+	channel->channel = -1;
+	channel->scan_index = CROS_EC_SENSOR_MAX_AXIS;
+	channel->scan_type.sign = 's';
+	channel->scan_type.realbits = 64;
+	channel->scan_type.storagebits = 64;
+
+	indio_dev->channels = state->channels;
+	indio_dev->num_channels = CROS_EC_SENSORS_MAX_CHANNELS;
+
+	/* There is only enough room for accel and gyro in the io space */
+	if ((state->core.ec->cmd_readmem != NULL) &&
+	    (state->core.type != MOTIONSENSE_TYPE_MAG))
+		state->core.read_ec_sensors_data = cros_ec_sensors_read_lpc;
+	else
+		state->core.read_ec_sensors_data = cros_ec_sensors_read_cmd;
+
+	ret = iio_triggered_buffer_setup(indio_dev, NULL,
+					 cros_ec_sensors_capture, NULL);
+	if (ret)
+		return ret;
+
+	ret = iio_device_register(indio_dev);
+	if (ret)
+		goto error_uninit_buffer;
+
+	return 0;
+
+error_uninit_buffer:
+	iio_triggered_buffer_cleanup(indio_dev);
+
+	return ret;
+}
+
+static int cros_ec_sensors_remove(struct platform_device *pdev)
+{
+	struct iio_dev *indio_dev = platform_get_drvdata(pdev);
+
+	iio_device_unregister(indio_dev);
+	iio_triggered_buffer_cleanup(indio_dev);
+
+	return 0;
+}
+
+static const struct platform_device_id cros_ec_sensors_ids[] = {
+	{
+		.name = "cros-ec-accel",
+	},
+	{
+		.name = "cros-ec-gyro",
+	},
+	{
+		.name = "cros-ec-mag",
+	},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(platform, cros_ec_sensors_ids);
+
+static struct platform_driver cros_ec_sensors_platform_driver = {
+	.driver = {
+		.name	= "cros-ec-sensors",
+	},
+	.probe		= cros_ec_sensors_probe,
+	.remove		= cros_ec_sensors_remove,
+	.id_table	= cros_ec_sensors_ids,
+};
+module_platform_driver(cros_ec_sensors_platform_driver);
+
+MODULE_DESCRIPTION("ChromeOS EC 3-axis sensors driver");
+MODULE_LICENSE("GPL v2");
