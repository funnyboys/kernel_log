commit 5f0ea0f5a63c6f6f4d9cdc458b0c5da5edfcb705
Author: Sergiu Cuciurean <sergiu.cuciurean@analog.com>
Date:   Thu Feb 27 14:25:15 2020 +0200

    iio: adc: max1118: Use new structure for SPI transfer delays
    
    In a recent change to the SPI subsystem [1], a new `delay` struct was added
    to replace the `delay_usecs`. This change replaces the current
    `delay_usecs` with `delay` for this driver.
    
    The `spi_transfer_delay_exec()` function [in the SPI framework] makes sure
    that both `delay_usecs` & `delay` are used (in this order to preserve
    backwards compatibility).
    
    [1] commit bebcfd272df6 ("spi: introduce `delay` field for
    `spi_transfer` + spi_transfer_delay_exec()")
    
    Signed-off-by: Sergiu Cuciurean <sergiu.cuciurean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/adc/max1118.c b/drivers/iio/adc/max1118.c
index 3b6f3b9a6c5b..0c5d7aaf6826 100644
--- a/drivers/iio/adc/max1118.c
+++ b/drivers/iio/adc/max1118.c
@@ -71,7 +71,10 @@ static int max1118_read(struct spi_device *spi, int channel)
 		 */
 		{
 			.len = 0,
-			.delay_usecs = 1,	/* > CNVST Low Time 100 ns */
+			.delay = {	/* > CNVST Low Time 100 ns */
+				.value = 1,
+				.unit = SPI_DELAY_UNIT_USECS
+			},
 			.cs_change = 1,
 		},
 		/*
@@ -81,7 +84,10 @@ static int max1118_read(struct spi_device *spi, int channel)
 		 */
 		{
 			.len = 0,
-			.delay_usecs = 8,
+			.delay = {
+				.value = 8,
+				.unit = SPI_DELAY_UNIT_USECS
+			},
 		},
 		{
 			.rx_buf = &adc->data,

commit 36edc93958e06dfc15b61d1cfa7f33929bc26fe4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:44 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 330
    
    Based on 1 normalized pattern(s):
    
      this file is subject to the terms and conditions of version 2 of the
      gnu general public license see the file copying in the main
      directory of this archive for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 55 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.108941081@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/iio/adc/max1118.c b/drivers/iio/adc/max1118.c
index 49db9e9ae625..3b6f3b9a6c5b 100644
--- a/drivers/iio/adc/max1118.c
+++ b/drivers/iio/adc/max1118.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * MAX1117/MAX1118/MAX1119 8-bit, dual-channel ADCs driver
  *
  * Copyright (c) 2017 Akinobu Mita <akinobu.mita@gmail.com>
  *
- * This file is subject to the terms and conditions of version 2 of
- * the GNU General Public License.  See the file COPYING in the main
- * directory of this archive for more details.
- *
  * Datasheet: https://datasheets.maximintegrated.com/en/ds/MAX1117-MAX1119.pdf
  *
  * SPI interface connections

commit 52b31bcc9372f2925f4898d179c655687c4aa179
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sun Jul 23 17:25:47 2017 +0100

    iio:adc: drop assign iio_info.driver_module and iio_trigger_ops.owner
    
    The equivalent of both of these are now done via macro magic when
    the relevant register calls are made.  The actual structure
    elements will shortly go away.
    
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>

diff --git a/drivers/iio/adc/max1118.c b/drivers/iio/adc/max1118.c
index 2e9648a078c4..49db9e9ae625 100644
--- a/drivers/iio/adc/max1118.c
+++ b/drivers/iio/adc/max1118.c
@@ -155,7 +155,6 @@ static int max1118_read_raw(struct iio_dev *indio_dev,
 
 static const struct iio_info max1118_info = {
 	.read_raw = max1118_read_raw,
-	.driver_module = THIS_MODULE,
 };
 
 static irqreturn_t max1118_trigger_handler(int irq, void *p)

commit a9e9c7153e96ee7f2777b3d5d99a23bf74dcaa21
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Wed Mar 29 01:34:48 2017 +0900

    iio: adc: add max1117/max1118/max1119 ADC driver
    
    This adds max1117/max1118/max1119 8-bit, dual-channel ADC driver.
    
    This new driver uses the zero length spi_transfers with the cs_change
    flag set and/or the non-zero delay_usecs.
    
    1. The zero length transfer with the spi_transfer.cs_change set is
    required in order to select CH1.  The chip select line must be brought
    high and low again without transfer.
    
    2. The zero length transfer with the spi_transfer.delay_usecs > 0 is
    required for waiting the conversion to be complete.  The conversion
    begins with the falling edge of the chip select.  During the conversion
    process, SCLK is ignored.
    
    These two usages are unusual.  But the spi controller drivers that use
    a default implementation of transfer_one_message() are likely to work.
    (I've tested this adc driver with spi-omap2-mcspi and spi-xilinx)
    
    On the other hand, some spi controller drivers that have their own
    transfer_one_message() may not work.  But at least for the zero length
    transfer with delay_usecs > 0, I'm proposing a new testcase for the
    spi-loopback-test that can test whether the delay_usecs setting has
    taken effect.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: Jonathan Cameron <jic23@kernel.org>
    Cc: Hartmut Knaack <knaack.h@gmx.de>
    Cc: Lars-Peter Clausen <lars@metafoo.de>
    Cc: Peter Meerwald-Stadler <pmeerw@pmeerw.net>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Mark Rutland <mark.rutland@arm.com>
    Cc: Mark Brown <broonie@kernel.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/adc/max1118.c b/drivers/iio/adc/max1118.c
new file mode 100644
index 000000000000..2e9648a078c4
--- /dev/null
+++ b/drivers/iio/adc/max1118.c
@@ -0,0 +1,307 @@
+/*
+ * MAX1117/MAX1118/MAX1119 8-bit, dual-channel ADCs driver
+ *
+ * Copyright (c) 2017 Akinobu Mita <akinobu.mita@gmail.com>
+ *
+ * This file is subject to the terms and conditions of version 2 of
+ * the GNU General Public License.  See the file COPYING in the main
+ * directory of this archive for more details.
+ *
+ * Datasheet: https://datasheets.maximintegrated.com/en/ds/MAX1117-MAX1119.pdf
+ *
+ * SPI interface connections
+ *
+ * SPI                MAXIM
+ * Master  Direction  MAX1117/8/9
+ * ------  ---------  -----------
+ * nCS        -->     CNVST
+ * SCK        -->     SCLK
+ * MISO       <--     DOUT
+ * ------  ---------  -----------
+ */
+
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/triggered_buffer.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/regulator/consumer.h>
+
+enum max1118_id {
+	max1117,
+	max1118,
+	max1119,
+};
+
+struct max1118 {
+	struct spi_device *spi;
+	struct mutex lock;
+	struct regulator *reg;
+
+	u8 data ____cacheline_aligned;
+};
+
+#define MAX1118_CHANNEL(ch)						\
+	{								\
+		.type = IIO_VOLTAGE,					\
+		.indexed = 1,						\
+		.channel = (ch),					\
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),		\
+		.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),	\
+		.scan_index = ch,					\
+		.scan_type = {						\
+			.sign = 'u',					\
+			.realbits = 8,					\
+			.storagebits = 8,				\
+		},							\
+	}
+
+static const struct iio_chan_spec max1118_channels[] = {
+	MAX1118_CHANNEL(0),
+	MAX1118_CHANNEL(1),
+	IIO_CHAN_SOFT_TIMESTAMP(2),
+};
+
+static int max1118_read(struct spi_device *spi, int channel)
+{
+	struct iio_dev *indio_dev = spi_get_drvdata(spi);
+	struct max1118 *adc = iio_priv(indio_dev);
+	struct spi_transfer xfers[] = {
+		/*
+		 * To select CH1 for conversion, CNVST pin must be brought high
+		 * and low for a second time.
+		 */
+		{
+			.len = 0,
+			.delay_usecs = 1,	/* > CNVST Low Time 100 ns */
+			.cs_change = 1,
+		},
+		/*
+		 * The acquisition interval begins with the falling edge of
+		 * CNVST.  The total acquisition and conversion process takes
+		 * <7.5us.
+		 */
+		{
+			.len = 0,
+			.delay_usecs = 8,
+		},
+		{
+			.rx_buf = &adc->data,
+			.len = 1,
+		},
+	};
+	int ret;
+
+	if (channel == 0)
+		ret = spi_sync_transfer(spi, xfers + 1, 2);
+	else
+		ret = spi_sync_transfer(spi, xfers, 3);
+
+	if (ret)
+		return ret;
+
+	return adc->data;
+}
+
+static int max1118_get_vref_mV(struct spi_device *spi)
+{
+	struct iio_dev *indio_dev = spi_get_drvdata(spi);
+	struct max1118 *adc = iio_priv(indio_dev);
+	const struct spi_device_id *id = spi_get_device_id(spi);
+	int vref_uV;
+
+	switch (id->driver_data) {
+	case max1117:
+		return 2048;
+	case max1119:
+		return 4096;
+	case max1118:
+		vref_uV = regulator_get_voltage(adc->reg);
+		if (vref_uV < 0)
+			return vref_uV;
+		return vref_uV / 1000;
+	}
+
+	return -ENODEV;
+}
+
+static int max1118_read_raw(struct iio_dev *indio_dev,
+			struct iio_chan_spec const *chan,
+			int *val, int *val2, long mask)
+{
+	struct max1118 *adc = iio_priv(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		mutex_lock(&adc->lock);
+		*val = max1118_read(adc->spi, chan->channel);
+		mutex_unlock(&adc->lock);
+		if (*val < 0)
+			return *val;
+
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		*val = max1118_get_vref_mV(adc->spi);
+		if (*val < 0)
+			return *val;
+		*val2 = 8;
+
+		return IIO_VAL_FRACTIONAL_LOG2;
+	}
+
+	return -EINVAL;
+}
+
+static const struct iio_info max1118_info = {
+	.read_raw = max1118_read_raw,
+	.driver_module = THIS_MODULE,
+};
+
+static irqreturn_t max1118_trigger_handler(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct max1118 *adc = iio_priv(indio_dev);
+	u8 data[16] = { }; /* 2x 8-bit ADC data + padding + 8 bytes timestamp */
+	int scan_index;
+	int i = 0;
+
+	mutex_lock(&adc->lock);
+
+	for_each_set_bit(scan_index, indio_dev->active_scan_mask,
+			indio_dev->masklength) {
+		const struct iio_chan_spec *scan_chan =
+				&indio_dev->channels[scan_index];
+		int ret = max1118_read(adc->spi, scan_chan->channel);
+
+		if (ret < 0) {
+			dev_warn(&adc->spi->dev,
+				"failed to get conversion data\n");
+			goto out;
+		}
+
+		data[i] = ret;
+		i++;
+	}
+	iio_push_to_buffers_with_timestamp(indio_dev, data,
+					   iio_get_time_ns(indio_dev));
+out:
+	mutex_unlock(&adc->lock);
+
+	iio_trigger_notify_done(indio_dev->trig);
+
+	return IRQ_HANDLED;
+}
+
+static int max1118_probe(struct spi_device *spi)
+{
+	struct iio_dev *indio_dev;
+	struct max1118 *adc;
+	const struct spi_device_id *id = spi_get_device_id(spi);
+	int ret;
+
+	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*adc));
+	if (!indio_dev)
+		return -ENOMEM;
+
+	adc = iio_priv(indio_dev);
+	adc->spi = spi;
+	mutex_init(&adc->lock);
+
+	if (id->driver_data == max1118) {
+		adc->reg = devm_regulator_get(&spi->dev, "vref");
+		if (IS_ERR(adc->reg)) {
+			dev_err(&spi->dev, "failed to get vref regulator\n");
+			return PTR_ERR(adc->reg);
+		}
+		ret = regulator_enable(adc->reg);
+		if (ret)
+			return ret;
+	}
+
+	spi_set_drvdata(spi, indio_dev);
+
+	indio_dev->name = spi_get_device_id(spi)->name;
+	indio_dev->dev.parent = &spi->dev;
+	indio_dev->info = &max1118_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->channels = max1118_channels;
+	indio_dev->num_channels = ARRAY_SIZE(max1118_channels);
+
+	/*
+	 * To reinitiate a conversion on CH0, it is necessary to allow for a
+	 * conversion to be complete and all of the data to be read out.  Once
+	 * a conversion has been completed, the MAX1117/MAX1118/MAX1119 will go
+	 * into AutoShutdown mode until the next conversion is initiated.
+	 */
+	max1118_read(spi, 0);
+
+	ret = iio_triggered_buffer_setup(indio_dev, NULL,
+					max1118_trigger_handler, NULL);
+	if (ret)
+		goto err_reg_disable;
+
+	ret = iio_device_register(indio_dev);
+	if (ret)
+		goto err_buffer_cleanup;
+
+	return 0;
+
+err_buffer_cleanup:
+	iio_triggered_buffer_cleanup(indio_dev);
+err_reg_disable:
+	if (id->driver_data == max1118)
+		regulator_disable(adc->reg);
+
+	return ret;
+}
+
+static int max1118_remove(struct spi_device *spi)
+{
+	struct iio_dev *indio_dev = spi_get_drvdata(spi);
+	struct max1118 *adc = iio_priv(indio_dev);
+	const struct spi_device_id *id = spi_get_device_id(spi);
+
+	iio_device_unregister(indio_dev);
+	iio_triggered_buffer_cleanup(indio_dev);
+	if (id->driver_data == max1118)
+		return regulator_disable(adc->reg);
+
+	return 0;
+}
+
+static const struct spi_device_id max1118_id[] = {
+	{ "max1117", max1117 },
+	{ "max1118", max1118 },
+	{ "max1119", max1119 },
+	{}
+};
+MODULE_DEVICE_TABLE(spi, max1118_id);
+
+#ifdef CONFIG_OF
+
+static const struct of_device_id max1118_dt_ids[] = {
+	{ .compatible = "maxim,max1117" },
+	{ .compatible = "maxim,max1118" },
+	{ .compatible = "maxim,max1119" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, max1118_dt_ids);
+
+#endif
+
+static struct spi_driver max1118_spi_driver = {
+	.driver = {
+		.name = "max1118",
+		.of_match_table = of_match_ptr(max1118_dt_ids),
+	},
+	.probe = max1118_probe,
+	.remove = max1118_remove,
+	.id_table = max1118_id,
+};
+module_spi_driver(max1118_spi_driver);
+
+MODULE_AUTHOR("Akinobu Mita <akinobu.mita@gmail.com>");
+MODULE_DESCRIPTION("MAXIM MAX1117/MAX1118/MAX1119 ADCs driver");
+MODULE_LICENSE("GPL v2");
