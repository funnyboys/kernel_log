commit 5750ebab14907f05aa9904ef2f3c1bb8dcb1fd2b
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Dec 2 10:38:06 2019 +0100

    iio: ad7266: Convert to use GPIO descriptors
    
    The AD7266 have no in-tree users making use of the platform
    data mechanism to pass address GPIO lines when not using
    a fixed address, so we can easily convert this to use
    GPIO descriptors instead of the platform data integers
    currently passed.
    
    Lowercase the labels "ad0".."ad2" as this will make a better
    fit for platform descriptions like device tree that prefer
    lowercase names such as "ad0-gpios" rather than "AD0-gpios".
    
    Board files and other static users of this device can pass
    the same GPIO descriptors using machine descriptor
    tables if need be.
    
    Cc: Alison Schofield <amsfield22@gmail.com>
    Cc: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index c31b8eabb894..c8524f098883 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -11,7 +11,7 @@
 #include <linux/spi/spi.h>
 #include <linux/regulator/consumer.h>
 #include <linux/err.h>
-#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
 #include <linux/module.h>
 
 #include <linux/interrupt.h>
@@ -34,7 +34,7 @@ struct ad7266_state {
 	enum ad7266_range	range;
 	enum ad7266_mode	mode;
 	bool			fixed_addr;
-	struct gpio		gpios[3];
+	struct gpio_desc	*gpios[3];
 
 	/*
 	 * DMA (thus cache coherency maintenance) requires the
@@ -117,7 +117,7 @@ static void ad7266_select_input(struct ad7266_state *st, unsigned int nr)
 	}
 
 	for (i = 0; i < 3; ++i)
-		gpio_set_value(st->gpios[i].gpio, (bool)(nr & BIT(i)));
+		gpiod_set_value(st->gpios[i], (bool)(nr & BIT(i)));
 }
 
 static int ad7266_update_scan_mode(struct iio_dev *indio_dev,
@@ -376,7 +376,7 @@ static void ad7266_init_channels(struct iio_dev *indio_dev)
 }
 
 static const char * const ad7266_gpio_labels[] = {
-	"AD0", "AD1", "AD2",
+	"ad0", "ad1", "ad2",
 };
 
 static int ad7266_probe(struct spi_device *spi)
@@ -419,14 +419,14 @@ static int ad7266_probe(struct spi_device *spi)
 
 		if (!st->fixed_addr) {
 			for (i = 0; i < ARRAY_SIZE(st->gpios); ++i) {
-				st->gpios[i].gpio = pdata->addr_gpios[i];
-				st->gpios[i].flags = GPIOF_OUT_INIT_LOW;
-				st->gpios[i].label = ad7266_gpio_labels[i];
+				st->gpios[i] = devm_gpiod_get(&spi->dev,
+						      ad7266_gpio_labels[i],
+						      GPIOD_OUT_LOW);
+				if (IS_ERR(st->gpios[i])) {
+					ret = PTR_ERR(st->gpios[i]);
+					goto error_disable_reg;
+				}
 			}
-			ret = gpio_request_array(st->gpios,
-				ARRAY_SIZE(st->gpios));
-			if (ret)
-				goto error_disable_reg;
 		}
 	} else {
 		st->fixed_addr = true;
@@ -465,7 +465,7 @@ static int ad7266_probe(struct spi_device *spi)
 	ret = iio_triggered_buffer_setup(indio_dev, &iio_pollfunc_store_time,
 		&ad7266_trigger_handler, &iio_triggered_buffer_setup_ops);
 	if (ret)
-		goto error_free_gpios;
+		goto error_disable_reg;
 
 	ret = iio_device_register(indio_dev);
 	if (ret)
@@ -475,9 +475,6 @@ static int ad7266_probe(struct spi_device *spi)
 
 error_buffer_cleanup:
 	iio_triggered_buffer_cleanup(indio_dev);
-error_free_gpios:
-	if (!st->fixed_addr)
-		gpio_free_array(st->gpios, ARRAY_SIZE(st->gpios));
 error_disable_reg:
 	if (!IS_ERR(st->reg))
 		regulator_disable(st->reg);
@@ -492,8 +489,6 @@ static int ad7266_remove(struct spi_device *spi)
 
 	iio_device_unregister(indio_dev);
 	iio_triggered_buffer_cleanup(indio_dev);
-	if (!st->fixed_addr)
-		gpio_free_array(st->gpios, ARRAY_SIZE(st->gpios));
 	if (!IS_ERR(st->reg))
 		regulator_disable(st->reg);
 

commit fda8d26e61fc518499ddc78ae74ec1aaa89c4134
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:06 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 177
    
    Based on 1 normalized pattern(s):
    
      licensed under the gpl 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 135 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170026.071193225@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index 605eb5e7e829..c31b8eabb894 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * AD7266/65 SPI ADC driver
  *
  * Copyright 2012 Analog Devices Inc.
- *
- * Licensed under the GPL-2.
  */
 
 #include <linux/device.h>

commit 52b31bcc9372f2925f4898d179c655687c4aa179
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sun Jul 23 17:25:47 2017 +0100

    iio:adc: drop assign iio_info.driver_module and iio_trigger_ops.owner
    
    The equivalent of both of these are now done via macro magic when
    the relevant register calls are made.  The actual structure
    elements will shortly go away.
    
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index b8d5cfd57ec4..605eb5e7e829 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -280,7 +280,6 @@ static AD7266_DECLARE_DIFF_CHANNELS_FIXED(u, 'u');
 static const struct iio_info ad7266_info = {
 	.read_raw = &ad7266_read_raw,
 	.update_scan_mode = &ad7266_update_scan_mode,
-	.driver_module = THIS_MODULE,
 };
 
 static const unsigned long ad7266_available_scan_masks[] = {

commit fbe84bd4803eb6c96376af5530ce69e1db873b5f
Author: Crt Mori <cmo@melexis.com>
Date:   Mon Sep 5 11:14:49 2016 +0200

    iio: devm_regulator_get_optional never returns NULL
    
    This patch is inspired by a comment of Jonathan Cameron on patch of
    Linus Walleij commit aeb55fff3891834e07a3144159a7298a19696af8 ("iio:
    st_sensors: fetch and enable regulators unconditionally"). Because
    changes made in this patch are actually reference generators they should
    be using devm_regulator_get_optional, but if they do not explicitly set
    the reference to NULL they should not be using IS_ERR_OR_NULL, but
    simple IS_ERR check.
    
    Suggested-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Crt Mori <cmo@melexis.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index c0f6a98fd9bd..b8d5cfd57ec4 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -481,7 +481,7 @@ static int ad7266_probe(struct spi_device *spi)
 	if (!st->fixed_addr)
 		gpio_free_array(st->gpios, ARRAY_SIZE(st->gpios));
 error_disable_reg:
-	if (!IS_ERR_OR_NULL(st->reg))
+	if (!IS_ERR(st->reg))
 		regulator_disable(st->reg);
 
 	return ret;
@@ -496,7 +496,7 @@ static int ad7266_remove(struct spi_device *spi)
 	iio_triggered_buffer_cleanup(indio_dev);
 	if (!st->fixed_addr)
 		gpio_free_array(st->gpios, ARRAY_SIZE(st->gpios));
-	if (!IS_ERR_OR_NULL(st->reg))
+	if (!IS_ERR(st->reg))
 		regulator_disable(st->reg);
 
 	return 0;

commit 6c71ee3b6157fdbde5c839405b593876d3687eb9
Merge: 7813029a509c 0ddfd857130d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jul 14 12:05:29 2016 +0900

    Merge tag 'iio-for-4.8c' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-next
    
    Jonathan writes:
    
    Third set of IIO new device support, features and cleanups for the 4.8 cycle.
    
    New core features
    - Selection of the clock source for IIO timestamps.  This is done per device
      as it makes little sense to have events in one timebase and data timestamped
      on another.  Biggest reason for this is that we currently use a clock
      source which is non monotonic which can result in 'interesting' data sets.
      (Includes export for get_monotonic_corse64 which Thomas Gleixner didn't mind
       in an earlier version.)
    - MAINTAINERS add the git tree to the list for IIO.
    
    New device support + a kind of indirect staging graduation.
    * Broadcom iproc-static-adc
      - new driver
    * mcp4531
      - support for MCP454x, MCP456x, MCP464x and MCP466x potentiometers
    * mpu6050
      - support the IC20608 6 axis motion tracking device
    * st-sensors
      - support the lis3l02dq + drop the lis3l02dq driver from staging.
      The general purpose driver is missing event support, but good to get
      rid of this driver which was rather long in the tooth.
    
    New driver features
    * ak8975
      - Add vid regulator support and refactor handling in general.
      - Allow a delay after enabling regulators.
      - Runtime and system PM.
    * bmg160
      - filter frequency control support.
    * bmp280
      - SPI device support.
      - EOC interrupt support for the BMP085
      - power management support.
      - supply regulator support.
      - reset gpio support
      - dt bindings for reset gpio and regulators.
      - of table to support device tree registration
    * max1363
      - Device tree bindings.
    * mcp4531
      - Device tree bindings.
    * st-pressure
      - temperature channels as part of triggered buffer (previously not due
      probably to alignment issues - see below).
      - lps22hb open drain interrupt support.
      - lps22hb temperature channel support
    
    Cleanups and reworkings.
    * numerous ADC drivers
      - ensure the iio_dev->dev.of_node is set to the parent dev.of_node so
      as to allow client bindings to find the device.
    * ak8975
      - Fix incorrect handling of missing regulator
      - make sure power is down and remove.
    * bmp280
      - read the calibration data only once as it doesn't change.
    * isl29125
      - Use a few macros to make code a touch more readable.
    * mma8452
      - fix a memory leak on error.
      - drop an unecessary bit of return value handling.
    * potentiometer kconfig
      - typo fix.
    * st-pressure
      - drop some uninformative default assignments of elements of the channel
      array structure (aids readability).
    * st-sensors
      - Harden interrupt handling considerably.  These are actually all using
      level interrupts, but at least two known boards have them wired to
      edge only interrupt chips.  Hence a slightly interesting bit of handling
      is needed in which we first allow for the easy option (level triggered) and
      secondly check the status registers before reenabling edge interrupts and
      fall back to a tight loop in the thread until we successfully clear the
      interrupt.  No harm is done if we never succeed in doing so.  It's an odd
      patch that has been through a lot of revisions to reach a consensus on how
      to handle what is basically broken hardware (which the previous defaults
      allowed to kind of work).
      - Fix alignment to defined storagebytes boundaries.
      - Ensure alignment of power of 2 byte boundaries.  This has always in theory
      been part of the ABI of IIO, but we missed a few that snuck in that need
      fixing.  The effect was minor as they were only followed by timestamp
      channels which were correctly aligned,
      - Add some docs to explain the gain calculations.

commit 7813029a509c0c92a5b16d846defaa50a2d3d7f1
Merge: 3c9a6793bde1 a99cde438de0
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jul 4 08:15:03 2016 -0700

    Merge 4.7-rc6 into staging-next
    
    We want the staging fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b541eaff4917a7429cd0e83cb3962383276db357
Author: Matt Ranostay <mranostay@gmail.com>
Date:   Sat Jul 2 17:26:33 2016 -0700

    iio: adc: add missing of_node references to iio_dev
    
    Adding missing indio_dev->dev.of_node references to allow iio consumers
    to access the device channels.
    
    Signed-off-by: Matt Ranostay <mranostay@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index 01240aeeeab0..e527bb6f8f03 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -437,6 +437,7 @@ static int ad7266_probe(struct spi_device *spi)
 	st->spi = spi;
 
 	indio_dev->dev.parent = &spi->dev;
+	indio_dev->dev.of_node = spi->dev.of_node;
 	indio_dev->name = spi_get_device_id(spi)->name;
 	indio_dev->modes = INDIO_DIRECT_MODE;
 	indio_dev->info = &ad7266_info;

commit 68b356eb3d9f5e38910fb62e22a78e2a18d544ae
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Jun 20 13:53:34 2016 +0100

    iio:ad7266: Fix probe deferral for vref
    
    Currently the ad7266 driver treats any failure to get vref as though the
    regulator were not present but this means that if probe deferral is
    triggered the driver will act as though the regulator were not present.
    Instead only use the internal reference if we explicitly got -ENODEV which
    is what is returned for absent regulators.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: <Stable@vger.kernel.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index 655b36b4e9cb..2123f0ac2e2a 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -408,6 +408,9 @@ static int ad7266_probe(struct spi_device *spi)
 
 		st->vref_mv = ret / 1000;
 	} else {
+		/* Any other error indicates that the regulator does exist */
+		if (PTR_ERR(st->reg) != -ENODEV)
+			return PTR_ERR(st->reg);
 		/* Use internal reference */
 		st->vref_mv = 2500;
 	}

commit e5511c816e5ac4909bdd38e85ac344e2b9b8e984
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Jun 20 13:53:33 2016 +0100

    iio:ad7266: Fix support for optional regulators
    
    The ad7266 driver attempts to support deciding between the use of internal
    and external power supplies by checking to see if an error is returned when
    requesting the regulator. This doesn't work with the current code since the
    driver uses a normal regulator_get() which is for non-optional supplies
    and so assumes that if a regulator is not provided by the platform then
    this is a bug in the platform integration and so substitutes a dummy
    regulator. Use regulator_get_optional() instead which indicates to the
    framework that the regulator may be absent and provides a dummy regulator
    instead.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: <Stable@vger.kernel.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index 835d45db258f..655b36b4e9cb 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -396,7 +396,7 @@ static int ad7266_probe(struct spi_device *spi)
 
 	st = iio_priv(indio_dev);
 
-	st->reg = devm_regulator_get(&spi->dev, "vref");
+	st->reg = devm_regulator_get_optional(&spi->dev, "vref");
 	if (!IS_ERR(st->reg)) {
 		ret = regulator_enable(st->reg);
 		if (ret)

commit 6b7f4e25f3309f106a5c7ff42c8231494cf285d3
Author: Mark Brown <broonie@kernel.org>
Date:   Mon Jun 20 13:53:32 2016 +0100

    iio:ad7266: Fix broken regulator error handling
    
    All regulator_get() variants return either a pointer to a regulator or an
    ERR_PTR() so testing for NULL makes no sense and may lead to bugs if we
    use NULL as a valid regulator. Fix this by using IS_ERR() as expected.
    
    Signed-off-by: Mark Brown <broonie@kernel.org>
    Cc: <Stable@vger.kernel.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index 21e19b60e2b9..835d45db258f 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -397,7 +397,7 @@ static int ad7266_probe(struct spi_device *spi)
 	st = iio_priv(indio_dev);
 
 	st->reg = devm_regulator_get(&spi->dev, "vref");
-	if (!IS_ERR_OR_NULL(st->reg)) {
+	if (!IS_ERR(st->reg)) {
 		ret = regulator_enable(st->reg);
 		if (ret)
 			return ret;

commit c70df20e31595cf696c8b4f50fc7d82b69f3dd5c
Author: Alison Schofield <amsfield22@gmail.com>
Date:   Tue May 24 12:16:23 2016 -0700

    iio: adc: ad7266: claim direct mode during sensor read
    
    Driver was checking for direct mode but not locking it down.
    Use iio_device_claim_direct_mode() to guarantee device stays
    in direct mode.
    
    Signed-off-by: Alison Schofield <amsfield22@gmail.com>
    Acked-by: Daniel Baluta <daniel.baluta@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index 21e19b60e2b9..01240aeeeab0 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -154,12 +154,11 @@ static int ad7266_read_raw(struct iio_dev *indio_dev,
 
 	switch (m) {
 	case IIO_CHAN_INFO_RAW:
-		if (iio_buffer_enabled(indio_dev))
-			return -EBUSY;
-
-		ret = ad7266_read_single(st, val, chan->address);
+		ret = iio_device_claim_direct_mode(indio_dev);
 		if (ret)
 			return ret;
+		ret = ad7266_read_single(st, val, chan->address);
+		iio_device_release_direct_mode(indio_dev);
 
 		*val = (*val >> 2) & 0xfff;
 		if (chan->scan_type.sign == 's')

commit 3821a065f5672c430a088ae68b4da2a2d2b34106
Author: Andrew F. Davis <afd@ti.com>
Date:   Fri Oct 23 08:59:11 2015 -0500

    spi: Drop owner assignment from spi_drivers
    
    An spi_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index 70f78c3062a7..21e19b60e2b9 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -509,7 +509,6 @@ MODULE_DEVICE_TABLE(spi, ad7266_id);
 static struct spi_driver ad7266_driver = {
 	.driver = {
 		.name	= "ad7266",
-		.owner	= THIS_MODULE,
 	},
 	.probe		= ad7266_probe,
 	.remove		= ad7266_remove,

commit 54e018da3141dbb41f3578d48be575087339710f
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Nov 25 12:42:00 2013 +0000

    iio:ad7266: Mark transfer buffer as __be16
    
    Fixes the following warnings from sparse:
            drivers/iio/adc/ad7266.c:140:16: warning: cast to restricted __be16
            drivers/iio/adc/ad7266.c:140:16: warning: cast to restricted __be16
            drivers/iio/adc/ad7266.c:140:16: warning: cast to restricted __be16
            drivers/iio/adc/ad7266.c:140:16: warning: cast to restricted __be16
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index 58e945594c7b..70f78c3062a7 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -43,19 +43,22 @@ struct ad7266_state {
 	 * The buffer needs to be large enough to hold two samples (4 bytes) and
 	 * the naturally aligned timestamp (8 bytes).
 	 */
-	uint8_t data[ALIGN(4, sizeof(s64)) + sizeof(s64)] ____cacheline_aligned;
+	struct {
+		__be16 sample[2];
+		s64 timestamp;
+	} data ____cacheline_aligned;
 };
 
 static int ad7266_wakeup(struct ad7266_state *st)
 {
 	/* Any read with >= 2 bytes will wake the device */
-	return spi_read(st->spi, st->data, 2);
+	return spi_read(st->spi, &st->data.sample[0], 2);
 }
 
 static int ad7266_powerdown(struct ad7266_state *st)
 {
 	/* Any read with < 2 bytes will powerdown the device */
-	return spi_read(st->spi, st->data, 1);
+	return spi_read(st->spi, &st->data.sample[0], 1);
 }
 
 static int ad7266_preenable(struct iio_dev *indio_dev)
@@ -84,9 +87,9 @@ static irqreturn_t ad7266_trigger_handler(int irq, void *p)
 	struct ad7266_state *st = iio_priv(indio_dev);
 	int ret;
 
-	ret = spi_read(st->spi, st->data, 4);
+	ret = spi_read(st->spi, st->data.sample, 4);
 	if (ret == 0) {
-		iio_push_to_buffers_with_timestamp(indio_dev, st->data,
+		iio_push_to_buffers_with_timestamp(indio_dev, &st->data,
 			    pf->timestamp);
 	}
 
@@ -137,7 +140,7 @@ static int ad7266_read_single(struct ad7266_state *st, int *val,
 	ad7266_select_input(st, address);
 
 	ret = spi_sync(st->spi, &st->single_msg);
-	*val = be16_to_cpu(st->data[address % 2]);
+	*val = be16_to_cpu(st->data.sample[address % 2]);
 
 	return ret;
 }
@@ -442,15 +445,15 @@ static int ad7266_probe(struct spi_device *spi)
 	ad7266_init_channels(indio_dev);
 
 	/* wakeup */
-	st->single_xfer[0].rx_buf = &st->data;
+	st->single_xfer[0].rx_buf = &st->data.sample[0];
 	st->single_xfer[0].len = 2;
 	st->single_xfer[0].cs_change = 1;
 	/* conversion */
-	st->single_xfer[1].rx_buf = &st->data;
+	st->single_xfer[1].rx_buf = st->data.sample;
 	st->single_xfer[1].len = 4;
 	st->single_xfer[1].cs_change = 1;
 	/* powerdown */
-	st->single_xfer[2].tx_buf = &st->data;
+	st->single_xfer[2].tx_buf = &st->data.sample[0];
 	st->single_xfer[2].len = 1;
 
 	spi_message_init(&st->single_msg);

commit 06e1b542bb06a84bb536d9865c6547422cc240b5
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Oct 14 17:49:00 2013 +0100

    iio:ad7266: Remove redundant call to iio_sw_preenable()
    
    The equivalent of iio_sw_buffer_preenable() is now done in the IIO buffer core,
    so there is no need to do this from the driver anymore.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index f5723cbd2032..58e945594c7b 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -61,17 +61,7 @@ static int ad7266_powerdown(struct ad7266_state *st)
 static int ad7266_preenable(struct iio_dev *indio_dev)
 {
 	struct ad7266_state *st = iio_priv(indio_dev);
-	int ret;
-
-	ret = ad7266_wakeup(st);
-	if (ret)
-		return ret;
-
-	ret = iio_sw_buffer_preenable(indio_dev);
-	if (ret)
-		ad7266_powerdown(st);
-
-	return ret;
+	return ad7266_wakeup(st);
 }
 
 static int ad7266_postdisable(struct iio_dev *indio_dev)

commit 2ebc39c0bbb30d6f06c3fe65c458e546db275f6d
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Sep 28 10:31:00 2013 +0100

    iio:ad7266: Report scale as fractional value
    
    Move the complexity of calculating the fixed point scale to the core.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index 656aa3e102f2..f5723cbd2032 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -27,7 +27,7 @@
 struct ad7266_state {
 	struct spi_device	*spi;
 	struct regulator	*reg;
-	unsigned long		vref_uv;
+	unsigned long		vref_mv;
 
 	struct spi_transfer	single_xfer[3];
 	struct spi_message	single_msg;
@@ -156,7 +156,7 @@ static int ad7266_read_raw(struct iio_dev *indio_dev,
 	struct iio_chan_spec const *chan, int *val, int *val2, long m)
 {
 	struct ad7266_state *st = iio_priv(indio_dev);
-	unsigned long scale_uv;
+	unsigned long scale_mv;
 	int ret;
 
 	switch (m) {
@@ -174,16 +174,15 @@ static int ad7266_read_raw(struct iio_dev *indio_dev,
 
 		return IIO_VAL_INT;
 	case IIO_CHAN_INFO_SCALE:
-		scale_uv = (st->vref_uv * 100);
+		scale_mv = st->vref_mv;
 		if (st->mode == AD7266_MODE_DIFF)
-			scale_uv *= 2;
+			scale_mv *= 2;
 		if (st->range == AD7266_RANGE_2VREF)
-			scale_uv *= 2;
+			scale_mv *= 2;
 
-		scale_uv >>= chan->scan_type.realbits;
-		*val =  scale_uv / 100000;
-		*val2 = (scale_uv % 100000) * 10;
-		return IIO_VAL_INT_PLUS_MICRO;
+		*val = scale_mv;
+		*val2 = chan->scan_type.realbits;
+		return IIO_VAL_FRACTIONAL_LOG2;
 	case IIO_CHAN_INFO_OFFSET:
 		if (st->range == AD7266_RANGE_2VREF &&
 			st->mode != AD7266_MODE_DIFF)
@@ -414,10 +413,10 @@ static int ad7266_probe(struct spi_device *spi)
 		if (ret < 0)
 			goto error_disable_reg;
 
-		st->vref_uv = ret;
+		st->vref_mv = ret / 1000;
 	} else {
 		/* Use internal reference */
-		st->vref_uv = 2500000;
+		st->vref_mv = 2500;
 	}
 
 	if (pdata) {

commit fce8abfda40a764f4662ee354c1646ec78061371
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Sep 19 13:59:00 2013 +0100

    iio:ad7266: Use iio_push_to_buffers_with_timestamp()
    
    Makes the code a bit shorter and less ugly.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index c304966a4f60..656aa3e102f2 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -96,9 +96,8 @@ static irqreturn_t ad7266_trigger_handler(int irq, void *p)
 
 	ret = spi_read(st->spi, st->data, 4);
 	if (ret == 0) {
-		if (indio_dev->scan_timestamp)
-			((s64 *)st->data)[1] = pf->timestamp;
-		iio_push_to_buffers(indio_dev, st->data);
+		iio_push_to_buffers_with_timestamp(indio_dev, st->data,
+			    pf->timestamp);
 	}
 
 	iio_trigger_notify_done(indio_dev->trig);

commit 2bdb3afcecff232b8670648755a222494d00981d
Author: Peter Meerwald <pmeerw@pmeerw.net>
Date:   Tue Sep 17 22:33:00 2013 +0100

    iio: Make available scan_masks const in ad7266
    
    Signed-off-by: Peter Meerwald <pmeerw@pmeerw.net>
    Acked-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index 5bfed2398b70..c304966a4f60 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -293,7 +293,7 @@ static const struct iio_info ad7266_info = {
 	.driver_module = THIS_MODULE,
 };
 
-static unsigned long ad7266_available_scan_masks[] = {
+static const unsigned long ad7266_available_scan_masks[] = {
 	0x003,
 	0x00c,
 	0x030,
@@ -303,14 +303,14 @@ static unsigned long ad7266_available_scan_masks[] = {
 	0x000,
 };
 
-static unsigned long ad7266_available_scan_masks_diff[] = {
+static const unsigned long ad7266_available_scan_masks_diff[] = {
 	0x003,
 	0x00c,
 	0x030,
 	0x000,
 };
 
-static unsigned long ad7266_available_scan_masks_fixed[] = {
+static const unsigned long ad7266_available_scan_masks_fixed[] = {
 	0x003,
 	0x000,
 };
@@ -318,7 +318,7 @@ static unsigned long ad7266_available_scan_masks_fixed[] = {
 struct ad7266_chan_info {
 	const struct iio_chan_spec *channels;
 	unsigned int num_channels;
-	unsigned long *scan_masks;
+	const unsigned long *scan_masks;
 };
 
 #define AD7266_CHAN_INFO_INDEX(_differential, _signed, _fixed) \

commit 8c60c7e75de79fe429afea3c7300d010c091bc4e
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sun Sep 15 17:50:00 2013 +0100

    iio: Remove unnecessary casts for iio_push_to_buffers()
    
    Now that iio_push_to_buffers() takes a void pointer for the data parameter we
    can remove those casts to u8*.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index 371731df1634..5bfed2398b70 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -98,7 +98,7 @@ static irqreturn_t ad7266_trigger_handler(int irq, void *p)
 	if (ret == 0) {
 		if (indio_dev->scan_timestamp)
 			((s64 *)st->data)[1] = pf->timestamp;
-		iio_push_to_buffers(indio_dev, (u8 *)st->data);
+		iio_push_to_buffers(indio_dev, st->data);
 	}
 
 	iio_trigger_notify_done(indio_dev->trig);

commit ded4fef934768adee9d31f15831513d7d76c360b
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Tue Jul 23 07:50:00 2013 +0100

    iio: adc: ad7266: Use devm_* APIs
    
    devm_* APIs are device managed and make code simpler.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Acked-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index c2744a75c3b0..371731df1634 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -399,17 +399,17 @@ static int ad7266_probe(struct spi_device *spi)
 	unsigned int i;
 	int ret;
 
-	indio_dev = iio_device_alloc(sizeof(*st));
+	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
 	if (indio_dev == NULL)
 		return -ENOMEM;
 
 	st = iio_priv(indio_dev);
 
-	st->reg = regulator_get(&spi->dev, "vref");
+	st->reg = devm_regulator_get(&spi->dev, "vref");
 	if (!IS_ERR_OR_NULL(st->reg)) {
 		ret = regulator_enable(st->reg);
 		if (ret)
-			goto error_put_reg;
+			return ret;
 
 		ret = regulator_get_voltage(st->reg);
 		if (ret < 0)
@@ -489,11 +489,6 @@ static int ad7266_probe(struct spi_device *spi)
 error_disable_reg:
 	if (!IS_ERR_OR_NULL(st->reg))
 		regulator_disable(st->reg);
-error_put_reg:
-	if (!IS_ERR_OR_NULL(st->reg))
-		regulator_put(st->reg);
-
-	iio_device_free(indio_dev);
 
 	return ret;
 }
@@ -507,11 +502,8 @@ static int ad7266_remove(struct spi_device *spi)
 	iio_triggered_buffer_cleanup(indio_dev);
 	if (!st->fixed_addr)
 		gpio_free_array(st->gpios, ARRAY_SIZE(st->gpios));
-	if (!IS_ERR_OR_NULL(st->reg)) {
+	if (!IS_ERR_OR_NULL(st->reg))
 		regulator_disable(st->reg);
-		regulator_put(st->reg);
-	}
-	iio_device_free(indio_dev);
 
 	return 0;
 }

commit 3234ac7e6a96046bd2c996ed93cf843057c3e627
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Wed Feb 27 19:04:03 2013 +0000

    iio:adc:ad7266 move to info_mask_(shared_by_type/separate)
    
    The original info_mask is going away in favour of the broken out versions.
    
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Acked-by: Lars-Peter Clausen <lars@metafoo.de>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index bbad9b94cd75..c2744a75c3b0 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -201,9 +201,9 @@ static int ad7266_read_raw(struct iio_dev *indio_dev,
 	.indexed = 1,					\
 	.channel = (_chan),				\
 	.address = (_chan),				\
-	.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT	\
-		| IIO_CHAN_INFO_SCALE_SHARED_BIT	\
-		| IIO_CHAN_INFO_OFFSET_SHARED_BIT,	\
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),	\
+	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) \
+		| BIT(IIO_CHAN_INFO_OFFSET),			\
 	.scan_index = (_chan),				\
 	.scan_type = {					\
 		.sign = (_sign),			\
@@ -249,9 +249,9 @@ static AD7266_DECLARE_SINGLE_ENDED_CHANNELS_FIXED(s, 's');
 	.channel = (_chan) * 2,				\
 	.channel2 = (_chan) * 2 + 1,			\
 	.address = (_chan),				\
-	.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT	\
-		| IIO_CHAN_INFO_SCALE_SHARED_BIT	\
-		| IIO_CHAN_INFO_OFFSET_SHARED_BIT,	\
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),	\
+	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE)	\
+		| BIT(IIO_CHAN_INFO_OFFSET),			\
 	.scan_index = (_chan),				\
 	.scan_type = {					\
 		.sign = _sign,			\

commit b87fc3e6e2e972556af94c55b7e015232598a1aa
Merge: 46fed0a57cd2 397c60668aa5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 14 09:08:38 2013 -0800

    Merge tag 'staging-3.8-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging fixes from Greg Kroah-Hartman:
     "Here are a number of small fixes to staging drivers for your 3.8-rc3
      tree.
    
      Well, the omapdrm fixes aren't really "small" but they were waiting on
      a number of other drm patches to go in through the drm tree, and got
      delayed by my vacation over the holidays.  They are totally
      self-contained, everyone involved have acked them, and they fix issues
      that people have been having with the driver.
    
      Other than that one, it's a bunch of tiny bugfixes for a number of
      reported issues.
    
      Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>"
    
    * tag 'staging-3.8-rc3' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (36 commits)
      staging: zram: fix invalid memory references during disk write
      staging: tidspbridge: use prepare/unprepare on dsp clocks
      staging: tidspbridge: Fix build breakage due to splitting CM functions.
      staging: comedi: comedi_test: fix race when cancelling command
      staging: comedi: Kconfig: COMEDI_NI_AT_A2150 should select COMEDI_FC
      staging: comedi: prevent auto-unconfig of manually configured devices
      staging: comedi: fix minimum AO period for NI 625x and NI 628x
      staging: vme_pio2: fix oops on module unloading
      staging: speakup: avoid out-of-range access in synth_add()
      staging: speakup: avoid out-of-range access in synth_init()
      staging: rtl8192e: Fix failure to check pci_map_single()
      staging: rtl8187se: Fix failure to check pci_map_single()
      staging: drm/imx: fix double free bug in error path
      staging: drm/imx: several bug fixes
      staging: drm/imx: check return value of ipu_reset()
      staging: drm/omap: fix flags in dma buf exporting
      staging: drm/omap: use omapdss low level API
      staging/fwserial: Update TODO file per reviewer comments
      staging/fwserial: Limit tx/rx to 1394-2008 spec maximum
      staging/fwserial: Refine Kconfig help text
      ...

commit fc52692c49969ec72595766929b9f54ac402da34
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:21:43 2012 -0800

    Drivers: iio: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, and __devexit
    from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index a6f4fc5f8201..4a5f639bc684 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -367,7 +367,7 @@ static const struct ad7266_chan_info ad7266_chan_infos[] = {
 	},
 };
 
-static void __devinit ad7266_init_channels(struct iio_dev *indio_dev)
+static void ad7266_init_channels(struct iio_dev *indio_dev)
 {
 	struct ad7266_state *st = iio_priv(indio_dev);
 	bool is_differential, is_signed;
@@ -391,7 +391,7 @@ static const char * const ad7266_gpio_labels[] = {
 	"AD0", "AD1", "AD2",
 };
 
-static int __devinit ad7266_probe(struct spi_device *spi)
+static int ad7266_probe(struct spi_device *spi)
 {
 	struct ad7266_platform_data *pdata = spi->dev.platform_data;
 	struct iio_dev *indio_dev;
@@ -494,7 +494,7 @@ static int __devinit ad7266_probe(struct spi_device *spi)
 	return ret;
 }
 
-static int __devexit ad7266_remove(struct spi_device *spi)
+static int ad7266_remove(struct spi_device *spi)
 {
 	struct iio_dev *indio_dev = spi_get_drvdata(spi);
 	struct ad7266_state *st = iio_priv(indio_dev);
@@ -525,7 +525,7 @@ static struct spi_driver ad7266_driver = {
 		.owner	= THIS_MODULE,
 	},
 	.probe		= ad7266_probe,
-	.remove		= __devexit_p(ad7266_remove),
+	.remove		= ad7266_remove,
 	.id_table	= ad7266_id,
 };
 module_spi_driver(ad7266_driver);

commit 36ce0c1c3ab7ea54fa6c2b3a0803c7ab0adcefbf
Author: Axel Lin <axel.lin@ingics.com>
Date:   Fri Dec 14 07:47:00 2012 +0000

    iio: adc: ad7266: Don't set error code to st->vref_uv
    
    regulator_get_voltage() may return negative error code.
    Add error checking to avoid setting error code to st->vref_uv.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Acked-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index a6f4fc5f8201..e36107dc30b9 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -411,7 +411,11 @@ static int __devinit ad7266_probe(struct spi_device *spi)
 		if (ret)
 			goto error_put_reg;
 
-		st->vref_uv = regulator_get_voltage(st->reg);
+		ret = regulator_get_voltage(st->reg);
+		if (ret < 0)
+			goto error_disable_reg;
+
+		st->vref_uv = ret;
 	} else {
 		/* Use internal reference */
 		st->vref_uv = 2500000;

commit 84b36ce5f79c01f792c623f14e92ed86cdccb42f
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sat Jun 30 20:06:00 2012 +0100

    staging:iio: Add support for multiple buffers
    
    Route all buffer writes through the demux.
    Addition or removal of a buffer results in tear down and
    setup of all the buffers for a given device.
    
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Tested-by: srinivas pandruvada <srinivas.pandruvada@intel.com>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index b11f214779a2..a6f4fc5f8201 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -91,7 +91,6 @@ static irqreturn_t ad7266_trigger_handler(int irq, void *p)
 {
 	struct iio_poll_func *pf = p;
 	struct iio_dev *indio_dev = pf->indio_dev;
-	struct iio_buffer *buffer = indio_dev->buffer;
 	struct ad7266_state *st = iio_priv(indio_dev);
 	int ret;
 
@@ -99,7 +98,7 @@ static irqreturn_t ad7266_trigger_handler(int irq, void *p)
 	if (ret == 0) {
 		if (indio_dev->scan_timestamp)
 			((s64 *)st->data)[1] = pf->timestamp;
-		iio_push_to_buffer(buffer, (u8 *)st->data);
+		iio_push_to_buffers(indio_dev, (u8 *)st->data);
 	}
 
 	iio_trigger_notify_done(indio_dev->trig);

commit ce56ade6ae74e604a4b5d6ea5b1d58960fa8e7aa
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Sep 4 13:38:00 2012 +0100

    iio: Drop timestamp parameter from buffer store_to callback
    
    Drop timestamp parameter from buffer store_to callback and subsequently from
    iio_push_to_buffer. The timestamp parameter is unused and it seems likely that
    it will stay unused in the future, so it should be safe to remove it.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
index 5c3f1ba5a06d..b11f214779a2 100644
--- a/drivers/iio/adc/ad7266.c
+++ b/drivers/iio/adc/ad7266.c
@@ -99,7 +99,7 @@ static irqreturn_t ad7266_trigger_handler(int irq, void *p)
 	if (ret == 0) {
 		if (indio_dev->scan_timestamp)
 			((s64 *)st->data)[1] = pf->timestamp;
-		iio_push_to_buffer(buffer, (u8 *)st->data, pf->timestamp);
+		iio_push_to_buffer(buffer, (u8 *)st->data);
 	}
 
 	iio_trigger_notify_done(indio_dev->trig);

commit 8ec4cf5303e03941fa5fd91bbb9c85bd4ae88c47
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Jun 25 14:52:49 2012 +0200

    iio:adc: Add AD7265/AD7266 support
    
    This patch adds support for the Analog Devices AD7265 and AD7266
    Analog-to-Digital converters.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/iio/adc/ad7266.c b/drivers/iio/adc/ad7266.c
new file mode 100644
index 000000000000..5c3f1ba5a06d
--- /dev/null
+++ b/drivers/iio/adc/ad7266.c
@@ -0,0 +1,536 @@
+/*
+ * AD7266/65 SPI ADC driver
+ *
+ * Copyright 2012 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/regulator/consumer.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+
+#include <linux/interrupt.h>
+
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/triggered_buffer.h>
+
+#include <linux/platform_data/ad7266.h>
+
+struct ad7266_state {
+	struct spi_device	*spi;
+	struct regulator	*reg;
+	unsigned long		vref_uv;
+
+	struct spi_transfer	single_xfer[3];
+	struct spi_message	single_msg;
+
+	enum ad7266_range	range;
+	enum ad7266_mode	mode;
+	bool			fixed_addr;
+	struct gpio		gpios[3];
+
+	/*
+	 * DMA (thus cache coherency maintenance) requires the
+	 * transfer buffers to live in their own cache lines.
+	 * The buffer needs to be large enough to hold two samples (4 bytes) and
+	 * the naturally aligned timestamp (8 bytes).
+	 */
+	uint8_t data[ALIGN(4, sizeof(s64)) + sizeof(s64)] ____cacheline_aligned;
+};
+
+static int ad7266_wakeup(struct ad7266_state *st)
+{
+	/* Any read with >= 2 bytes will wake the device */
+	return spi_read(st->spi, st->data, 2);
+}
+
+static int ad7266_powerdown(struct ad7266_state *st)
+{
+	/* Any read with < 2 bytes will powerdown the device */
+	return spi_read(st->spi, st->data, 1);
+}
+
+static int ad7266_preenable(struct iio_dev *indio_dev)
+{
+	struct ad7266_state *st = iio_priv(indio_dev);
+	int ret;
+
+	ret = ad7266_wakeup(st);
+	if (ret)
+		return ret;
+
+	ret = iio_sw_buffer_preenable(indio_dev);
+	if (ret)
+		ad7266_powerdown(st);
+
+	return ret;
+}
+
+static int ad7266_postdisable(struct iio_dev *indio_dev)
+{
+	struct ad7266_state *st = iio_priv(indio_dev);
+	return ad7266_powerdown(st);
+}
+
+static const struct iio_buffer_setup_ops iio_triggered_buffer_setup_ops = {
+	.preenable = &ad7266_preenable,
+	.postenable = &iio_triggered_buffer_postenable,
+	.predisable = &iio_triggered_buffer_predisable,
+	.postdisable = &ad7266_postdisable,
+};
+
+static irqreturn_t ad7266_trigger_handler(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct iio_buffer *buffer = indio_dev->buffer;
+	struct ad7266_state *st = iio_priv(indio_dev);
+	int ret;
+
+	ret = spi_read(st->spi, st->data, 4);
+	if (ret == 0) {
+		if (indio_dev->scan_timestamp)
+			((s64 *)st->data)[1] = pf->timestamp;
+		iio_push_to_buffer(buffer, (u8 *)st->data, pf->timestamp);
+	}
+
+	iio_trigger_notify_done(indio_dev->trig);
+
+	return IRQ_HANDLED;
+}
+
+static void ad7266_select_input(struct ad7266_state *st, unsigned int nr)
+{
+	unsigned int i;
+
+	if (st->fixed_addr)
+		return;
+
+	switch (st->mode) {
+	case AD7266_MODE_SINGLE_ENDED:
+		nr >>= 1;
+		break;
+	case AD7266_MODE_PSEUDO_DIFF:
+		nr |= 1;
+		break;
+	case AD7266_MODE_DIFF:
+		nr &= ~1;
+		break;
+	}
+
+	for (i = 0; i < 3; ++i)
+		gpio_set_value(st->gpios[i].gpio, (bool)(nr & BIT(i)));
+}
+
+static int ad7266_update_scan_mode(struct iio_dev *indio_dev,
+	const unsigned long *scan_mask)
+{
+	struct ad7266_state *st = iio_priv(indio_dev);
+	unsigned int nr = find_first_bit(scan_mask, indio_dev->masklength);
+
+	ad7266_select_input(st, nr);
+
+	return 0;
+}
+
+static int ad7266_read_single(struct ad7266_state *st, int *val,
+	unsigned int address)
+{
+	int ret;
+
+	ad7266_select_input(st, address);
+
+	ret = spi_sync(st->spi, &st->single_msg);
+	*val = be16_to_cpu(st->data[address % 2]);
+
+	return ret;
+}
+
+static int ad7266_read_raw(struct iio_dev *indio_dev,
+	struct iio_chan_spec const *chan, int *val, int *val2, long m)
+{
+	struct ad7266_state *st = iio_priv(indio_dev);
+	unsigned long scale_uv;
+	int ret;
+
+	switch (m) {
+	case IIO_CHAN_INFO_RAW:
+		if (iio_buffer_enabled(indio_dev))
+			return -EBUSY;
+
+		ret = ad7266_read_single(st, val, chan->address);
+		if (ret)
+			return ret;
+
+		*val = (*val >> 2) & 0xfff;
+		if (chan->scan_type.sign == 's')
+			*val = sign_extend32(*val, 11);
+
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		scale_uv = (st->vref_uv * 100);
+		if (st->mode == AD7266_MODE_DIFF)
+			scale_uv *= 2;
+		if (st->range == AD7266_RANGE_2VREF)
+			scale_uv *= 2;
+
+		scale_uv >>= chan->scan_type.realbits;
+		*val =  scale_uv / 100000;
+		*val2 = (scale_uv % 100000) * 10;
+		return IIO_VAL_INT_PLUS_MICRO;
+	case IIO_CHAN_INFO_OFFSET:
+		if (st->range == AD7266_RANGE_2VREF &&
+			st->mode != AD7266_MODE_DIFF)
+			*val = 2048;
+		else
+			*val = 0;
+		return IIO_VAL_INT;
+	}
+	return -EINVAL;
+}
+
+#define AD7266_CHAN(_chan, _sign) {			\
+	.type = IIO_VOLTAGE,				\
+	.indexed = 1,					\
+	.channel = (_chan),				\
+	.address = (_chan),				\
+	.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT	\
+		| IIO_CHAN_INFO_SCALE_SHARED_BIT	\
+		| IIO_CHAN_INFO_OFFSET_SHARED_BIT,	\
+	.scan_index = (_chan),				\
+	.scan_type = {					\
+		.sign = (_sign),			\
+		.realbits = 12,				\
+		.storagebits = 16,			\
+		.shift = 2,				\
+		.endianness = IIO_BE,			\
+	},						\
+}
+
+#define AD7266_DECLARE_SINGLE_ENDED_CHANNELS(_name, _sign) \
+const struct iio_chan_spec ad7266_channels_##_name[] = { \
+	AD7266_CHAN(0, (_sign)), \
+	AD7266_CHAN(1, (_sign)), \
+	AD7266_CHAN(2, (_sign)), \
+	AD7266_CHAN(3, (_sign)), \
+	AD7266_CHAN(4, (_sign)), \
+	AD7266_CHAN(5, (_sign)), \
+	AD7266_CHAN(6, (_sign)), \
+	AD7266_CHAN(7, (_sign)), \
+	AD7266_CHAN(8, (_sign)), \
+	AD7266_CHAN(9, (_sign)), \
+	AD7266_CHAN(10, (_sign)), \
+	AD7266_CHAN(11, (_sign)), \
+	IIO_CHAN_SOFT_TIMESTAMP(13), \
+}
+
+#define AD7266_DECLARE_SINGLE_ENDED_CHANNELS_FIXED(_name, _sign) \
+const struct iio_chan_spec ad7266_channels_##_name##_fixed[] = { \
+	AD7266_CHAN(0, (_sign)), \
+	AD7266_CHAN(1, (_sign)), \
+	IIO_CHAN_SOFT_TIMESTAMP(2), \
+}
+
+static AD7266_DECLARE_SINGLE_ENDED_CHANNELS(u, 'u');
+static AD7266_DECLARE_SINGLE_ENDED_CHANNELS(s, 's');
+static AD7266_DECLARE_SINGLE_ENDED_CHANNELS_FIXED(u, 'u');
+static AD7266_DECLARE_SINGLE_ENDED_CHANNELS_FIXED(s, 's');
+
+#define AD7266_CHAN_DIFF(_chan, _sign) {			\
+	.type = IIO_VOLTAGE,				\
+	.indexed = 1,					\
+	.channel = (_chan) * 2,				\
+	.channel2 = (_chan) * 2 + 1,			\
+	.address = (_chan),				\
+	.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT	\
+		| IIO_CHAN_INFO_SCALE_SHARED_BIT	\
+		| IIO_CHAN_INFO_OFFSET_SHARED_BIT,	\
+	.scan_index = (_chan),				\
+	.scan_type = {					\
+		.sign = _sign,			\
+		.realbits = 12,				\
+		.storagebits = 16,			\
+		.shift = 2,				\
+		.endianness = IIO_BE,			\
+	},						\
+	.differential = 1,				\
+}
+
+#define AD7266_DECLARE_DIFF_CHANNELS(_name, _sign) \
+const struct iio_chan_spec ad7266_channels_diff_##_name[] = { \
+	AD7266_CHAN_DIFF(0, (_sign)), \
+	AD7266_CHAN_DIFF(1, (_sign)), \
+	AD7266_CHAN_DIFF(2, (_sign)), \
+	AD7266_CHAN_DIFF(3, (_sign)), \
+	AD7266_CHAN_DIFF(4, (_sign)), \
+	AD7266_CHAN_DIFF(5, (_sign)), \
+	IIO_CHAN_SOFT_TIMESTAMP(6), \
+}
+
+static AD7266_DECLARE_DIFF_CHANNELS(s, 's');
+static AD7266_DECLARE_DIFF_CHANNELS(u, 'u');
+
+#define AD7266_DECLARE_DIFF_CHANNELS_FIXED(_name, _sign) \
+const struct iio_chan_spec ad7266_channels_diff_fixed_##_name[] = { \
+	AD7266_CHAN_DIFF(0, (_sign)), \
+	AD7266_CHAN_DIFF(1, (_sign)), \
+	IIO_CHAN_SOFT_TIMESTAMP(2), \
+}
+
+static AD7266_DECLARE_DIFF_CHANNELS_FIXED(s, 's');
+static AD7266_DECLARE_DIFF_CHANNELS_FIXED(u, 'u');
+
+static const struct iio_info ad7266_info = {
+	.read_raw = &ad7266_read_raw,
+	.update_scan_mode = &ad7266_update_scan_mode,
+	.driver_module = THIS_MODULE,
+};
+
+static unsigned long ad7266_available_scan_masks[] = {
+	0x003,
+	0x00c,
+	0x030,
+	0x0c0,
+	0x300,
+	0xc00,
+	0x000,
+};
+
+static unsigned long ad7266_available_scan_masks_diff[] = {
+	0x003,
+	0x00c,
+	0x030,
+	0x000,
+};
+
+static unsigned long ad7266_available_scan_masks_fixed[] = {
+	0x003,
+	0x000,
+};
+
+struct ad7266_chan_info {
+	const struct iio_chan_spec *channels;
+	unsigned int num_channels;
+	unsigned long *scan_masks;
+};
+
+#define AD7266_CHAN_INFO_INDEX(_differential, _signed, _fixed) \
+	(((_differential) << 2) | ((_signed) << 1) | ((_fixed) << 0))
+
+static const struct ad7266_chan_info ad7266_chan_infos[] = {
+	[AD7266_CHAN_INFO_INDEX(0, 0, 0)] = {
+		.channels = ad7266_channels_u,
+		.num_channels = ARRAY_SIZE(ad7266_channels_u),
+		.scan_masks = ad7266_available_scan_masks,
+	},
+	[AD7266_CHAN_INFO_INDEX(0, 0, 1)] = {
+		.channels = ad7266_channels_u_fixed,
+		.num_channels = ARRAY_SIZE(ad7266_channels_u_fixed),
+		.scan_masks = ad7266_available_scan_masks_fixed,
+	},
+	[AD7266_CHAN_INFO_INDEX(0, 1, 0)] = {
+		.channels = ad7266_channels_s,
+		.num_channels = ARRAY_SIZE(ad7266_channels_s),
+		.scan_masks = ad7266_available_scan_masks,
+	},
+	[AD7266_CHAN_INFO_INDEX(0, 1, 1)] = {
+		.channels = ad7266_channels_s_fixed,
+		.num_channels = ARRAY_SIZE(ad7266_channels_s_fixed),
+		.scan_masks = ad7266_available_scan_masks_fixed,
+	},
+	[AD7266_CHAN_INFO_INDEX(1, 0, 0)] = {
+		.channels = ad7266_channels_diff_u,
+		.num_channels = ARRAY_SIZE(ad7266_channels_diff_u),
+		.scan_masks = ad7266_available_scan_masks_diff,
+	},
+	[AD7266_CHAN_INFO_INDEX(1, 0, 1)] = {
+		.channels = ad7266_channels_diff_fixed_u,
+		.num_channels = ARRAY_SIZE(ad7266_channels_diff_fixed_u),
+		.scan_masks = ad7266_available_scan_masks_fixed,
+	},
+	[AD7266_CHAN_INFO_INDEX(1, 1, 0)] = {
+		.channels = ad7266_channels_diff_s,
+		.num_channels = ARRAY_SIZE(ad7266_channels_diff_s),
+		.scan_masks = ad7266_available_scan_masks_diff,
+	},
+	[AD7266_CHAN_INFO_INDEX(1, 1, 1)] = {
+		.channels = ad7266_channels_diff_fixed_s,
+		.num_channels = ARRAY_SIZE(ad7266_channels_diff_fixed_s),
+		.scan_masks = ad7266_available_scan_masks_fixed,
+	},
+};
+
+static void __devinit ad7266_init_channels(struct iio_dev *indio_dev)
+{
+	struct ad7266_state *st = iio_priv(indio_dev);
+	bool is_differential, is_signed;
+	const struct ad7266_chan_info *chan_info;
+	int i;
+
+	is_differential = st->mode != AD7266_MODE_SINGLE_ENDED;
+	is_signed = (st->range == AD7266_RANGE_2VREF) |
+		    (st->mode == AD7266_MODE_DIFF);
+
+	i = AD7266_CHAN_INFO_INDEX(is_differential, is_signed, st->fixed_addr);
+	chan_info = &ad7266_chan_infos[i];
+
+	indio_dev->channels = chan_info->channels;
+	indio_dev->num_channels = chan_info->num_channels;
+	indio_dev->available_scan_masks = chan_info->scan_masks;
+	indio_dev->masklength = chan_info->num_channels - 1;
+}
+
+static const char * const ad7266_gpio_labels[] = {
+	"AD0", "AD1", "AD2",
+};
+
+static int __devinit ad7266_probe(struct spi_device *spi)
+{
+	struct ad7266_platform_data *pdata = spi->dev.platform_data;
+	struct iio_dev *indio_dev;
+	struct ad7266_state *st;
+	unsigned int i;
+	int ret;
+
+	indio_dev = iio_device_alloc(sizeof(*st));
+	if (indio_dev == NULL)
+		return -ENOMEM;
+
+	st = iio_priv(indio_dev);
+
+	st->reg = regulator_get(&spi->dev, "vref");
+	if (!IS_ERR_OR_NULL(st->reg)) {
+		ret = regulator_enable(st->reg);
+		if (ret)
+			goto error_put_reg;
+
+		st->vref_uv = regulator_get_voltage(st->reg);
+	} else {
+		/* Use internal reference */
+		st->vref_uv = 2500000;
+	}
+
+	if (pdata) {
+		st->fixed_addr = pdata->fixed_addr;
+		st->mode = pdata->mode;
+		st->range = pdata->range;
+
+		if (!st->fixed_addr) {
+			for (i = 0; i < ARRAY_SIZE(st->gpios); ++i) {
+				st->gpios[i].gpio = pdata->addr_gpios[i];
+				st->gpios[i].flags = GPIOF_OUT_INIT_LOW;
+				st->gpios[i].label = ad7266_gpio_labels[i];
+			}
+			ret = gpio_request_array(st->gpios,
+				ARRAY_SIZE(st->gpios));
+			if (ret)
+				goto error_disable_reg;
+		}
+	} else {
+		st->fixed_addr = true;
+		st->range = AD7266_RANGE_VREF;
+		st->mode = AD7266_MODE_DIFF;
+	}
+
+	spi_set_drvdata(spi, indio_dev);
+	st->spi = spi;
+
+	indio_dev->dev.parent = &spi->dev;
+	indio_dev->name = spi_get_device_id(spi)->name;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->info = &ad7266_info;
+
+	ad7266_init_channels(indio_dev);
+
+	/* wakeup */
+	st->single_xfer[0].rx_buf = &st->data;
+	st->single_xfer[0].len = 2;
+	st->single_xfer[0].cs_change = 1;
+	/* conversion */
+	st->single_xfer[1].rx_buf = &st->data;
+	st->single_xfer[1].len = 4;
+	st->single_xfer[1].cs_change = 1;
+	/* powerdown */
+	st->single_xfer[2].tx_buf = &st->data;
+	st->single_xfer[2].len = 1;
+
+	spi_message_init(&st->single_msg);
+	spi_message_add_tail(&st->single_xfer[0], &st->single_msg);
+	spi_message_add_tail(&st->single_xfer[1], &st->single_msg);
+	spi_message_add_tail(&st->single_xfer[2], &st->single_msg);
+
+	ret = iio_triggered_buffer_setup(indio_dev, &iio_pollfunc_store_time,
+		&ad7266_trigger_handler, &iio_triggered_buffer_setup_ops);
+	if (ret)
+		goto error_free_gpios;
+
+	ret = iio_device_register(indio_dev);
+	if (ret)
+		goto error_buffer_cleanup;
+
+	return 0;
+
+error_buffer_cleanup:
+	iio_triggered_buffer_cleanup(indio_dev);
+error_free_gpios:
+	if (!st->fixed_addr)
+		gpio_free_array(st->gpios, ARRAY_SIZE(st->gpios));
+error_disable_reg:
+	if (!IS_ERR_OR_NULL(st->reg))
+		regulator_disable(st->reg);
+error_put_reg:
+	if (!IS_ERR_OR_NULL(st->reg))
+		regulator_put(st->reg);
+
+	iio_device_free(indio_dev);
+
+	return ret;
+}
+
+static int __devexit ad7266_remove(struct spi_device *spi)
+{
+	struct iio_dev *indio_dev = spi_get_drvdata(spi);
+	struct ad7266_state *st = iio_priv(indio_dev);
+
+	iio_device_unregister(indio_dev);
+	iio_triggered_buffer_cleanup(indio_dev);
+	if (!st->fixed_addr)
+		gpio_free_array(st->gpios, ARRAY_SIZE(st->gpios));
+	if (!IS_ERR_OR_NULL(st->reg)) {
+		regulator_disable(st->reg);
+		regulator_put(st->reg);
+	}
+	iio_device_free(indio_dev);
+
+	return 0;
+}
+
+static const struct spi_device_id ad7266_id[] = {
+	{"ad7265", 0},
+	{"ad7266", 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, ad7266_id);
+
+static struct spi_driver ad7266_driver = {
+	.driver = {
+		.name	= "ad7266",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= ad7266_probe,
+	.remove		= __devexit_p(ad7266_remove),
+	.id_table	= ad7266_id,
+};
+module_spi_driver(ad7266_driver);
+
+MODULE_AUTHOR("Lars-Peter Clausen <lars@metafoo.de>");
+MODULE_DESCRIPTION("Analog Devices AD7266/65 ADC");
+MODULE_LICENSE("GPL v2");
