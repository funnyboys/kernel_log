commit 6d8ef2472410c8ab004729a71ec829a224699a08
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Sat Oct 29 10:01:41 2016 -0200

    edac: move EDAC device definitions to drivers/edac/edac_device.h
    
    The edac_core.h header contain data structures and function
    definitions for both EDAC MC and EDAC device.
    
    Let's move the devices ones to a separate header file, as part
    of a header reorganization.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 93da1a45c716..0e7ea3591b78 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -1,7 +1,7 @@
 /*
  * file for managing the edac_device subsystem of devices for EDAC
  *
- * (C) 2007 SoftwareBitMaker 
+ * (C) 2007 SoftwareBitMaker
  *
  * This file may be distributed under the terms of the
  * GNU General Public License.
@@ -15,7 +15,7 @@
 #include <linux/slab.h>
 #include <linux/edac.h>
 
-#include "edac_core.h"
+#include "edac_device.h"
 #include "edac_module.h"
 
 #define EDAC_DEVICE_SYMLINK	"device"

commit d4538000ca4354a2c07cdd31ce994af7d23e24d6
Author: Borislav Petkov <bp@suse.de>
Date:   Mon Nov 30 14:20:41 2015 +0100

    EDAC: Remove edac_get_sysfs_subsys() error handling
    
    It cannot fail now. We either load EDAC core after having successfully
    initialized edac_subsys or we don't.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 170527165374..93da1a45c716 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -237,11 +237,6 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 
 	/* get the /sys/devices/system/edac reference */
 	edac_subsys = edac_get_sysfs_subsys();
-	if (edac_subsys == NULL) {
-		edac_dbg(1, "no edac_subsys error\n");
-		err = -ENODEV;
-		goto err_out;
-	}
 
 	/* Point to the 'edac_subsys' this instance 'reports' to */
 	edac_dev->edac_subsys = edac_subsys;

commit 733476cf207faf574b132523ff2aee78b488ed6b
Author: Borislav Petkov <bp@suse.de>
Date:   Fri Nov 27 11:40:43 2015 +0100

    EDAC: Rip out the edac_subsys reference counting
    
    This was really dumb - reference counting for the main EDAC sysfs
    object. While we could've simply registered it as the first thing in the
    module init path and then hand it around to what needs it.
    
    Do that and rip out all the code around it, thus simplifying the whole
    handling significantly.
    
    Move the edac_subsys node back to edac_module.c.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index fb68a06ad683..170527165374 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -256,7 +256,7 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 
 	if (!try_module_get(edac_dev->owner)) {
 		err = -ENODEV;
-		goto err_mod_get;
+		goto err_out;
 	}
 
 	/* register */
@@ -282,9 +282,6 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 err_kobj_reg:
 	module_put(edac_dev->owner);
 
-err_mod_get:
-	edac_put_sysfs_subsys();
-
 err_out:
 	return err;
 }
@@ -306,7 +303,6 @@ void edac_device_unregister_sysfs_main_kobj(struct edac_device_ctl_info *dev)
 	 *   b) 'kfree' the memory
 	 */
 	kobject_put(&dev->kobj);
-	edac_put_sysfs_subsys();
 }
 
 /* edac_dev -> instance information */

commit 956b9ba156dbfdb9cede2b2927ddf8be2233b3a7
Author: Joe Perches <joe@perches.com>
Date:   Sun Apr 29 17:08:39 2012 -0300

    edac: Convert debugfX to edac_dbg(X,
    
    Use a more common debugging style.
    
    Remove __FILE__ uses, add missing newlines,
    coalesce formats and align arguments.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 1cee83ec35fe..fb68a06ad683 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -202,7 +202,7 @@ static void edac_device_ctrl_master_release(struct kobject *kobj)
 {
 	struct edac_device_ctl_info *edac_dev = to_edacdev(kobj);
 
-	debugf4("control index=%d\n", edac_dev->dev_idx);
+	edac_dbg(4, "control index=%d\n", edac_dev->dev_idx);
 
 	/* decrement the EDAC CORE module ref count */
 	module_put(edac_dev->owner);
@@ -233,12 +233,12 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 	struct bus_type *edac_subsys;
 	int err;
 
-	debugf1("\n");
+	edac_dbg(1, "\n");
 
 	/* get the /sys/devices/system/edac reference */
 	edac_subsys = edac_get_sysfs_subsys();
 	if (edac_subsys == NULL) {
-		debugf1("no edac_subsys error\n");
+		edac_dbg(1, "no edac_subsys error\n");
 		err = -ENODEV;
 		goto err_out;
 	}
@@ -264,8 +264,8 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 				   &edac_subsys->dev_root->kobj,
 				   "%s", edac_dev->name);
 	if (err) {
-		debugf1("Failed to register '.../edac/%s'\n",
-			edac_dev->name);
+		edac_dbg(1, "Failed to register '.../edac/%s'\n",
+			 edac_dev->name);
 		goto err_kobj_reg;
 	}
 	kobject_uevent(&edac_dev->kobj, KOBJ_ADD);
@@ -274,8 +274,7 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 	 * edac_device_unregister_sysfs_main_kobj() must be used
 	 */
 
-	debugf4("Registered '.../edac/%s' kobject\n",
-		edac_dev->name);
+	edac_dbg(4, "Registered '.../edac/%s' kobject\n", edac_dev->name);
 
 	return 0;
 
@@ -296,9 +295,8 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
  */
 void edac_device_unregister_sysfs_main_kobj(struct edac_device_ctl_info *dev)
 {
-	debugf0("\n");
-	debugf4("name of kobject is: %s\n",
-		kobject_name(&dev->kobj));
+	edac_dbg(0, "\n");
+	edac_dbg(4, "name of kobject is: %s\n", kobject_name(&dev->kobj));
 
 	/*
 	 * Unregister the edac device's kobject and
@@ -336,7 +334,7 @@ static void edac_device_ctrl_instance_release(struct kobject *kobj)
 {
 	struct edac_device_instance *instance;
 
-	debugf1("\n");
+	edac_dbg(1, "\n");
 
 	/* map from this kobj to the main control struct
 	 * and then dec the main kobj count
@@ -442,7 +440,7 @@ static void edac_device_ctrl_block_release(struct kobject *kobj)
 {
 	struct edac_device_block *block;
 
-	debugf1("\n");
+	edac_dbg(1, "\n");
 
 	/* get the container of the kobj */
 	block = to_block(kobj);
@@ -524,10 +522,10 @@ static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
 	struct edac_dev_sysfs_block_attribute *sysfs_attrib;
 	struct kobject *main_kobj;
 
-	debugf4("Instance '%s' inst_p=%p  block '%s'  block_p=%p\n",
-		instance->name, instance, block->name, block);
-	debugf4("block kobj=%p  block kobj->parent=%p\n",
-		&block->kobj, &block->kobj.parent);
+	edac_dbg(4, "Instance '%s' inst_p=%p  block '%s'  block_p=%p\n",
+		 instance->name, instance, block->name, block);
+	edac_dbg(4, "block kobj=%p  block kobj->parent=%p\n",
+		 &block->kobj, &block->kobj.parent);
 
 	/* init this block's kobject */
 	memset(&block->kobj, 0, sizeof(struct kobject));
@@ -546,8 +544,7 @@ static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
 				   &instance->kobj,
 				   "%s", block->name);
 	if (err) {
-		debugf1("Failed to register instance '%s'\n",
-			block->name);
+		edac_dbg(1, "Failed to register instance '%s'\n", block->name);
 		kobject_put(main_kobj);
 		err = -ENODEV;
 		goto err_out;
@@ -560,10 +557,9 @@ static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
 	if (sysfs_attrib && block->nr_attribs) {
 		for (i = 0; i < block->nr_attribs; i++, sysfs_attrib++) {
 
-			debugf4("creating block attrib='%s' "
-				"attrib->%p to kobj=%p\n",
-				sysfs_attrib->attr.name,
-				sysfs_attrib, &block->kobj);
+			edac_dbg(4, "creating block attrib='%s' attrib->%p to kobj=%p\n",
+				 sysfs_attrib->attr.name,
+				 sysfs_attrib, &block->kobj);
 
 			/* Create each block_attribute file */
 			err = sysfs_create_file(&block->kobj,
@@ -646,14 +642,14 @@ static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
 	err = kobject_init_and_add(&instance->kobj, &ktype_instance_ctrl,
 				   &edac_dev->kobj, "%s", instance->name);
 	if (err != 0) {
-		debugf2("Failed to register instance '%s'\n",
-			instance->name);
+		edac_dbg(2, "Failed to register instance '%s'\n",
+			 instance->name);
 		kobject_put(main_kobj);
 		goto err_out;
 	}
 
-	debugf4("now register '%d' blocks for instance %d\n",
-		instance->nr_blocks, idx);
+	edac_dbg(4, "now register '%d' blocks for instance %d\n",
+		 instance->nr_blocks, idx);
 
 	/* register all blocks of this instance */
 	for (i = 0; i < instance->nr_blocks; i++) {
@@ -669,8 +665,8 @@ static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
 	}
 	kobject_uevent(&instance->kobj, KOBJ_ADD);
 
-	debugf4("Registered instance %d '%s' kobject\n",
-		idx, instance->name);
+	edac_dbg(4, "Registered instance %d '%s' kobject\n",
+		 idx, instance->name);
 
 	return 0;
 
@@ -714,7 +710,7 @@ static int edac_device_create_instances(struct edac_device_ctl_info *edac_dev)
 	int i, j;
 	int err;
 
-	debugf0("\n");
+	edac_dbg(0, "\n");
 
 	/* iterate over creation of the instances */
 	for (i = 0; i < edac_dev->nr_instances; i++) {
@@ -816,12 +812,12 @@ int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
 	int err;
 	struct kobject *edac_kobj = &edac_dev->kobj;
 
-	debugf0("idx=%d\n", edac_dev->dev_idx);
+	edac_dbg(0, "idx=%d\n", edac_dev->dev_idx);
 
 	/*  go create any main attributes callers wants */
 	err = edac_device_add_main_sysfs_attributes(edac_dev);
 	if (err) {
-		debugf0("failed to add sysfs attribs\n");
+		edac_dbg(0, "failed to add sysfs attribs\n");
 		goto err_out;
 	}
 
@@ -831,8 +827,7 @@ int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
 	err = sysfs_create_link(edac_kobj,
 				&edac_dev->dev->kobj, EDAC_DEVICE_SYMLINK);
 	if (err) {
-		debugf0("sysfs_create_link() returned err= %d\n",
-			err);
+		edac_dbg(0, "sysfs_create_link() returned err= %d\n", err);
 		goto err_remove_main_attribs;
 	}
 
@@ -842,14 +837,13 @@ int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
 	 */
 	err = edac_device_create_instances(edac_dev);
 	if (err) {
-		debugf0("edac_device_create_instances() "
-			"returned err= %d\n", err);
+		edac_dbg(0, "edac_device_create_instances() returned err= %d\n",
+			 err);
 		goto err_remove_link;
 	}
 
 
-	debugf4("create-instances done, idx=%d\n",
-		edac_dev->dev_idx);
+	edac_dbg(4, "create-instances done, idx=%d\n", edac_dev->dev_idx);
 
 	return 0;
 
@@ -872,7 +866,7 @@ int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
  */
 void edac_device_remove_sysfs(struct edac_device_ctl_info *edac_dev)
 {
-	debugf0("\n");
+	edac_dbg(0, "\n");
 
 	/* remove any main attributes for this device */
 	edac_device_remove_main_sysfs_attributes(edac_dev);

commit dd23cd6eb1f59ba722a6e6aa228adff7c01404de
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sun Apr 29 11:59:14 2012 -0300

    edac: Don't add __func__ or __FILE__ for debugf[0-9] msgs
    
    The debug macro already adds that. Most of the work here was
    made by this small script:
    
    $f .=$_ while (<>);
    
    $f =~ s/(debugf[0-9]\s*\(\s*)__FILE__\s*": /\1"/g;
    $f =~ s/(debugf[0-9]\s*\(\s*)__FILE__\s*/\1/g;
    $f =~ s/(debugf[0-9]\s*\(\s*)__FILE__\s*"MC: /\1"/g;
    
    $f =~ s/(debugf[0-9]\s*\(\")\%s[\:\,\(\)]*\s*([^\"]*\s*[^\)]+)__func__\s*\,\s*/\1\2/g;
    $f =~ s/(debugf[0-9]\s*\(\")\%s[\:\,\(\)]*\s*([^\"]*\s*[^\)]+),\s*__func__\s*\)/\1\2)/g;
    $f =~ s/(debugf[0-9]\s*\(\"MC\:\s*)\%s[\:\,\(\)]*\s*([^\"]*\s*[^\)]+)__func__\s*\,\s*/\1\2/g;
    $f =~ s/(debugf[0-9]\s*\(\"MC\:\s*)\%s[\:\,\(\)]*\s*([^\"]*\s*[^\)]+),\s*__func__\s*\)/\1\2)/g;
    
    $f =~ s/\"MC\: \\n\"/"MC:\\n"/g;
    
    print $f;
    
    After running the script, manual cleanups were done to fix it the remaining
    places.
    
    While here, removed the __LINE__ on most places, as it doesn't actually give
    useful info on most places.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index b4ea185ccebf..1cee83ec35fe 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -202,7 +202,7 @@ static void edac_device_ctrl_master_release(struct kobject *kobj)
 {
 	struct edac_device_ctl_info *edac_dev = to_edacdev(kobj);
 
-	debugf4("%s() control index=%d\n", __func__, edac_dev->dev_idx);
+	debugf4("control index=%d\n", edac_dev->dev_idx);
 
 	/* decrement the EDAC CORE module ref count */
 	module_put(edac_dev->owner);
@@ -233,12 +233,12 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 	struct bus_type *edac_subsys;
 	int err;
 
-	debugf1("%s()\n", __func__);
+	debugf1("\n");
 
 	/* get the /sys/devices/system/edac reference */
 	edac_subsys = edac_get_sysfs_subsys();
 	if (edac_subsys == NULL) {
-		debugf1("%s() no edac_subsys error\n", __func__);
+		debugf1("no edac_subsys error\n");
 		err = -ENODEV;
 		goto err_out;
 	}
@@ -264,8 +264,8 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 				   &edac_subsys->dev_root->kobj,
 				   "%s", edac_dev->name);
 	if (err) {
-		debugf1("%s()Failed to register '.../edac/%s'\n",
-			__func__, edac_dev->name);
+		debugf1("Failed to register '.../edac/%s'\n",
+			edac_dev->name);
 		goto err_kobj_reg;
 	}
 	kobject_uevent(&edac_dev->kobj, KOBJ_ADD);
@@ -274,8 +274,8 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 	 * edac_device_unregister_sysfs_main_kobj() must be used
 	 */
 
-	debugf4("%s() Registered '.../edac/%s' kobject\n",
-		__func__, edac_dev->name);
+	debugf4("Registered '.../edac/%s' kobject\n",
+		edac_dev->name);
 
 	return 0;
 
@@ -296,9 +296,9 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
  */
 void edac_device_unregister_sysfs_main_kobj(struct edac_device_ctl_info *dev)
 {
-	debugf0("%s()\n", __func__);
-	debugf4("%s() name of kobject is: %s\n",
-		__func__, kobject_name(&dev->kobj));
+	debugf0("\n");
+	debugf4("name of kobject is: %s\n",
+		kobject_name(&dev->kobj));
 
 	/*
 	 * Unregister the edac device's kobject and
@@ -336,7 +336,7 @@ static void edac_device_ctrl_instance_release(struct kobject *kobj)
 {
 	struct edac_device_instance *instance;
 
-	debugf1("%s()\n", __func__);
+	debugf1("\n");
 
 	/* map from this kobj to the main control struct
 	 * and then dec the main kobj count
@@ -442,7 +442,7 @@ static void edac_device_ctrl_block_release(struct kobject *kobj)
 {
 	struct edac_device_block *block;
 
-	debugf1("%s()\n", __func__);
+	debugf1("\n");
 
 	/* get the container of the kobj */
 	block = to_block(kobj);
@@ -524,10 +524,10 @@ static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
 	struct edac_dev_sysfs_block_attribute *sysfs_attrib;
 	struct kobject *main_kobj;
 
-	debugf4("%s() Instance '%s' inst_p=%p  block '%s'  block_p=%p\n",
-		__func__, instance->name, instance, block->name, block);
-	debugf4("%s() block kobj=%p  block kobj->parent=%p\n",
-		__func__, &block->kobj, &block->kobj.parent);
+	debugf4("Instance '%s' inst_p=%p  block '%s'  block_p=%p\n",
+		instance->name, instance, block->name, block);
+	debugf4("block kobj=%p  block kobj->parent=%p\n",
+		&block->kobj, &block->kobj.parent);
 
 	/* init this block's kobject */
 	memset(&block->kobj, 0, sizeof(struct kobject));
@@ -546,8 +546,8 @@ static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
 				   &instance->kobj,
 				   "%s", block->name);
 	if (err) {
-		debugf1("%s() Failed to register instance '%s'\n",
-			__func__, block->name);
+		debugf1("Failed to register instance '%s'\n",
+			block->name);
 		kobject_put(main_kobj);
 		err = -ENODEV;
 		goto err_out;
@@ -560,9 +560,8 @@ static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
 	if (sysfs_attrib && block->nr_attribs) {
 		for (i = 0; i < block->nr_attribs; i++, sysfs_attrib++) {
 
-			debugf4("%s() creating block attrib='%s' "
+			debugf4("creating block attrib='%s' "
 				"attrib->%p to kobj=%p\n",
-				__func__,
 				sysfs_attrib->attr.name,
 				sysfs_attrib, &block->kobj);
 
@@ -647,14 +646,14 @@ static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
 	err = kobject_init_and_add(&instance->kobj, &ktype_instance_ctrl,
 				   &edac_dev->kobj, "%s", instance->name);
 	if (err != 0) {
-		debugf2("%s() Failed to register instance '%s'\n",
-			__func__, instance->name);
+		debugf2("Failed to register instance '%s'\n",
+			instance->name);
 		kobject_put(main_kobj);
 		goto err_out;
 	}
 
-	debugf4("%s() now register '%d' blocks for instance %d\n",
-		__func__, instance->nr_blocks, idx);
+	debugf4("now register '%d' blocks for instance %d\n",
+		instance->nr_blocks, idx);
 
 	/* register all blocks of this instance */
 	for (i = 0; i < instance->nr_blocks; i++) {
@@ -670,8 +669,8 @@ static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
 	}
 	kobject_uevent(&instance->kobj, KOBJ_ADD);
 
-	debugf4("%s() Registered instance %d '%s' kobject\n",
-		__func__, idx, instance->name);
+	debugf4("Registered instance %d '%s' kobject\n",
+		idx, instance->name);
 
 	return 0;
 
@@ -715,7 +714,7 @@ static int edac_device_create_instances(struct edac_device_ctl_info *edac_dev)
 	int i, j;
 	int err;
 
-	debugf0("%s()\n", __func__);
+	debugf0("\n");
 
 	/* iterate over creation of the instances */
 	for (i = 0; i < edac_dev->nr_instances; i++) {
@@ -817,12 +816,12 @@ int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
 	int err;
 	struct kobject *edac_kobj = &edac_dev->kobj;
 
-	debugf0("%s() idx=%d\n", __func__, edac_dev->dev_idx);
+	debugf0("idx=%d\n", edac_dev->dev_idx);
 
 	/*  go create any main attributes callers wants */
 	err = edac_device_add_main_sysfs_attributes(edac_dev);
 	if (err) {
-		debugf0("%s() failed to add sysfs attribs\n", __func__);
+		debugf0("failed to add sysfs attribs\n");
 		goto err_out;
 	}
 
@@ -832,8 +831,8 @@ int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
 	err = sysfs_create_link(edac_kobj,
 				&edac_dev->dev->kobj, EDAC_DEVICE_SYMLINK);
 	if (err) {
-		debugf0("%s() sysfs_create_link() returned err= %d\n",
-			__func__, err);
+		debugf0("sysfs_create_link() returned err= %d\n",
+			err);
 		goto err_remove_main_attribs;
 	}
 
@@ -843,14 +842,14 @@ int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
 	 */
 	err = edac_device_create_instances(edac_dev);
 	if (err) {
-		debugf0("%s() edac_device_create_instances() "
-			"returned err= %d\n", __func__, err);
+		debugf0("edac_device_create_instances() "
+			"returned err= %d\n", err);
 		goto err_remove_link;
 	}
 
 
-	debugf4("%s() create-instances done, idx=%d\n",
-		__func__, edac_dev->dev_idx);
+	debugf4("create-instances done, idx=%d\n",
+		edac_dev->dev_idx);
 
 	return 0;
 
@@ -873,7 +872,7 @@ int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
  */
 void edac_device_remove_sysfs(struct edac_device_ctl_info *edac_dev)
 {
-	debugf0("%s()\n", __func__);
+	debugf0("\n");
 
 	/* remove any main attributes for this device */
 	edac_device_remove_main_sysfs_attributes(edac_dev);

commit fe5ff8b84c8b03348a2f64ea9d884348faec2217
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Dec 14 15:21:07 2011 -0800

    edac: convert sysdev_class to a regular subsystem
    
    After all sysdev classes are ported to regular driver core entities, the
    sysdev implementation will be entirely removed from the kernel.
    
    Cc: Doug Thompson <dougthompson@xmission.com>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Lucas De Marchi <lucas.demarchi@profusion.mobi>
    Cc: Borislav Petkov <borislav.petkov@amd.com>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 86649df00285..b4ea185ccebf 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -1,5 +1,5 @@
 /*
- * file for managing the edac_device class of devices for EDAC
+ * file for managing the edac_device subsystem of devices for EDAC
  *
  * (C) 2007 SoftwareBitMaker 
  *
@@ -230,21 +230,21 @@ static struct kobj_type ktype_device_ctrl = {
  */
 int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 {
-	struct sysdev_class *edac_class;
+	struct bus_type *edac_subsys;
 	int err;
 
 	debugf1("%s()\n", __func__);
 
 	/* get the /sys/devices/system/edac reference */
-	edac_class = edac_get_sysfs_class();
-	if (edac_class == NULL) {
-		debugf1("%s() no edac_class error\n", __func__);
+	edac_subsys = edac_get_sysfs_subsys();
+	if (edac_subsys == NULL) {
+		debugf1("%s() no edac_subsys error\n", __func__);
 		err = -ENODEV;
 		goto err_out;
 	}
 
-	/* Point to the 'edac_class' this instance 'reports' to */
-	edac_dev->edac_class = edac_class;
+	/* Point to the 'edac_subsys' this instance 'reports' to */
+	edac_dev->edac_subsys = edac_subsys;
 
 	/* Init the devices's kobject */
 	memset(&edac_dev->kobj, 0, sizeof(struct kobject));
@@ -261,7 +261,7 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 
 	/* register */
 	err = kobject_init_and_add(&edac_dev->kobj, &ktype_device_ctrl,
-				   &edac_class->kset.kobj,
+				   &edac_subsys->dev_root->kobj,
 				   "%s", edac_dev->name);
 	if (err) {
 		debugf1("%s()Failed to register '.../edac/%s'\n",
@@ -284,7 +284,7 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 	module_put(edac_dev->owner);
 
 err_mod_get:
-	edac_put_sysfs_class();
+	edac_put_sysfs_subsys();
 
 err_out:
 	return err;
@@ -308,7 +308,7 @@ void edac_device_unregister_sysfs_main_kobj(struct edac_device_ctl_info *dev)
 	 *   b) 'kfree' the memory
 	 */
 	kobject_put(&dev->kobj);
-	edac_put_sysfs_class();
+	edac_put_sysfs_subsys();
 }
 
 /* edac_dev -> instance information */

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 400de071cabc..86649df00285 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -533,7 +533,7 @@ static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
 	memset(&block->kobj, 0, sizeof(struct kobject));
 
 	/* bump the main kobject's reference count for this controller
-	 * and this instance is dependant on the main
+	 * and this instance is dependent on the main
 	 */
 	main_kobj = kobject_get(&edac_dev->kobj);
 	if (!main_kobj) {
@@ -635,7 +635,7 @@ static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
 	instance->ctl = edac_dev;
 
 	/* bump the main kobject's reference count for this controller
-	 * and this instance is dependant on the main
+	 * and this instance is dependent on the main
 	 */
 	main_kobj = kobject_get(&edac_dev->kobj);
 	if (!main_kobj) {

commit 229aebb873e29726b91e076161649cf45154b0bf
Merge: 8de547e18244 50a23e6eec6f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Oct 24 13:41:39 2010 -0700

    Merge branch 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    * 'for-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (39 commits)
      Update broken web addresses in arch directory.
      Update broken web addresses in the kernel.
      Revert "drivers/usb: Remove unnecessary return's from void functions" for musb gadget
      Revert "Fix typo: configuation => configuration" partially
      ida: document IDA_BITMAP_LONGS calculation
      ext2: fix a typo on comment in ext2/inode.c
      drivers/scsi: Remove unnecessary casts of private_data
      drivers/s390: Remove unnecessary casts of private_data
      net/sunrpc/rpc_pipe.c: Remove unnecessary casts of private_data
      drivers/infiniband: Remove unnecessary casts of private_data
      drivers/gpu/drm: Remove unnecessary casts of private_data
      kernel/pm_qos_params.c: Remove unnecessary casts of private_data
      fs/ecryptfs: Remove unnecessary casts of private_data
      fs/seq_file.c: Remove unnecessary casts of private_data
      arm: uengine.c: remove C99 comments
      arm: scoop.c: remove C99 comments
      Fix typo configue => configure in comments
      Fix typo: configuation => configuration
      Fix typo interrest[ing|ed] => interest[ing|ed]
      Fix various typos of valid in comments
      ...
    
    Fix up trivial conflicts in:
            drivers/char/ipmi/ipmi_si_intf.c
            drivers/usb/gadget/rndis.c
            net/irda/irnet/irnet_ppp.c

commit 30e1f7a8122145f44f45c95366e27b6bb0b08428
Author: Borislav Petkov <borislav.petkov@amd.com>
Date:   Thu Sep 2 17:26:48 2010 +0200

    EDAC: Export edac sysfs class to users.
    
    Move toplevel sysfs class to the stub and make it available to
    non-modularized code too. Add proper refcounting of its users and move
    the registration functionality into the reference counting routines.
    
    Signed-off-by: Borislav Petkov <borislav.petkov@amd.com>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 070968178a24..2941dca91aae 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -13,6 +13,7 @@
 #include <linux/ctype.h>
 #include <linux/module.h>
 #include <linux/slab.h>
+#include <linux/edac.h>
 
 #include "edac_core.h"
 #include "edac_module.h"
@@ -235,7 +236,7 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 	debugf1("%s()\n", __func__);
 
 	/* get the /sys/devices/system/edac reference */
-	edac_class = edac_get_edac_class();
+	edac_class = edac_get_sysfs_class();
 	if (edac_class == NULL) {
 		debugf1("%s() no edac_class error\n", __func__);
 		err = -ENODEV;
@@ -255,7 +256,7 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 
 	if (!try_module_get(edac_dev->owner)) {
 		err = -ENODEV;
-		goto err_out;
+		goto err_mod_get;
 	}
 
 	/* register */
@@ -282,6 +283,9 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 err_kobj_reg:
 	module_put(edac_dev->owner);
 
+err_mod_get:
+	edac_put_sysfs_class();
+
 err_out:
 	return err;
 }
@@ -290,12 +294,11 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
  * edac_device_unregister_sysfs_main_kobj:
  *	the '..../edac/<name>' kobject
  */
-void edac_device_unregister_sysfs_main_kobj(
-					struct edac_device_ctl_info *edac_dev)
+void edac_device_unregister_sysfs_main_kobj(struct edac_device_ctl_info *dev)
 {
 	debugf0("%s()\n", __func__);
 	debugf4("%s() name of kobject is: %s\n",
-		__func__, kobject_name(&edac_dev->kobj));
+		__func__, kobject_name(&dev->kobj));
 
 	/*
 	 * Unregister the edac device's kobject and
@@ -304,7 +307,8 @@ void edac_device_unregister_sysfs_main_kobj(
 	 *   a) module_put() this module
 	 *   b) 'kfree' the memory
 	 */
-	kobject_put(&edac_dev->kobj);
+	kobject_put(&dev->kobj);
+	edac_put_sysfs_class();
 }
 
 /* edac_dev -> instance information */

commit 631dd1a885b6d7e9f6f51b4e5b311c2bb04c323c
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon Oct 18 11:03:14 2010 +0200

    Update broken web addresses in the kernel.
    
    The patch below updates broken web addresses in the kernel
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Cc: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Finn Thain <fthain@telegraphics.com.au>
    Cc: Randy Dunlap <rdunlap@xenotime.net>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Dimitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Mike Frysinger <vapier.adi@gmail.com>
    Acked-by: Ben Pfaff <blp@cs.stanford.edu>
    Acked-by: Hans J. Koch <hjk@linutronix.de>
    Reviewed-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 070968178a24..413f0dfbbf75 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -1,7 +1,7 @@
 /*
  * file for managing the edac_device class of devices for EDAC
  *
- * (C) 2007 SoftwareBitMaker (http://www.softwarebitmaker.com)
+ * (C) 2007 SoftwareBitMaker 
  *
  * This file may be distributed under the terms of the
  * GNU General Public License.

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 5fdedbc0f545..070968178a24 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -12,6 +12,7 @@
 
 #include <linux/ctype.h>
 #include <linux/module.h>
+#include <linux/slab.h>
 
 #include "edac_core.h"
 #include "edac_module.h"

commit 52cf25d0ab7f78eeecc59ac652ed5090f69b619e
Author: Emese Revfy <re.emese@gmail.com>
Date:   Tue Jan 19 02:58:23 2010 +0100

    Driver core: Constify struct sysfs_ops in struct kobj_type
    
    Constify struct sysfs_ops.
    
    This is part of the ops structure constification
    effort started by Arjan van de Ven et al.
    
    Benefits of this constification:
    
     * prevents modification of data that is shared
       (referenced) by many other structure instances
       at runtime
    
     * detects/prevents accidental (but not intentional)
       modification attempts on archs that enforce
       read-only kernel data at runtime
    
     * potentially better optimized code as the compiler
       can assume that the const data cannot be changed
    
     * the compiler/linker move const data into .rodata
       and therefore exclude them from false sharing
    
    Signed-off-by: Emese Revfy <re.emese@gmail.com>
    Acked-by: David Teigland <teigland@redhat.com>
    Acked-by: Matt Domsch <Matt_Domsch@dell.com>
    Acked-by: Maciej Sosnowski <maciej.sosnowski@intel.com>
    Acked-by: Hans J. Koch <hjk@linutronix.de>
    Acked-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Acked-by: Jens Axboe <jens.axboe@oracle.com>
    Acked-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 53764577035f..5fdedbc0f545 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -137,7 +137,7 @@ static ssize_t edac_dev_ctl_info_store(struct kobject *kobj,
 }
 
 /* edac_dev file operations for an 'ctl_info' */
-static struct sysfs_ops device_ctl_info_ops = {
+static const struct sysfs_ops device_ctl_info_ops = {
 	.show = edac_dev_ctl_info_show,
 	.store = edac_dev_ctl_info_store
 };
@@ -373,7 +373,7 @@ static ssize_t edac_dev_instance_store(struct kobject *kobj,
 }
 
 /* edac_dev file operations for an 'instance' */
-static struct sysfs_ops device_instance_ops = {
+static const struct sysfs_ops device_instance_ops = {
 	.show = edac_dev_instance_show,
 	.store = edac_dev_instance_store
 };
@@ -476,7 +476,7 @@ static ssize_t edac_dev_block_store(struct kobject *kobj,
 }
 
 /* edac_dev file operations for a 'block' */
-static struct sysfs_ops device_block_ops = {
+static const struct sysfs_ops device_block_ops = {
 	.show = edac_dev_block_show,
 	.store = edac_dev_block_store
 };

commit c10997f6575f476ff38442fa18fd4a0d80345f9d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Dec 20 08:13:05 2007 -0800

    Kobject: convert drivers/* from kobject_unregister() to kobject_put()
    
    There is no need for kobject_unregister() anymore, thanks to Kay's
    kobject cleanup changes, so replace all instances of it with
    kobject_put().
    
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 10e5b19a3e3b..53764577035f 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -303,7 +303,7 @@ void edac_device_unregister_sysfs_main_kobj(
 	 *   a) module_put() this module
 	 *   b) 'kfree' the memory
 	 */
-	kobject_unregister(&edac_dev->kobj);
+	kobject_put(&edac_dev->kobj);
 }
 
 /* edac_dev -> instance information */
@@ -574,7 +574,7 @@ static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
 
 	/* Error unwind stack */
 err_on_attrib:
-	kobject_unregister(&block->kobj);
+	kobject_put(&block->kobj);
 
 err_out:
 	return err;
@@ -605,7 +605,7 @@ static void edac_device_delete_block(struct edac_device_ctl_info *edac_dev,
 	/* unregister this block's kobject, SEE:
 	 *	edac_device_ctrl_block_release() callback operation
 	 */
-	kobject_unregister(&block->kobj);
+	kobject_put(&block->kobj);
 }
 
 /* instance ctor/dtor code */
@@ -672,7 +672,7 @@ static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
 
 	/* error unwind stack */
 err_release_instance_kobj:
-	kobject_unregister(&instance->kobj);
+	kobject_put(&instance->kobj);
 
 err_out:
 	return err;
@@ -697,7 +697,7 @@ static void edac_device_delete_instance(struct edac_device_ctl_info *edac_dev,
 	/* unregister this instance's kobject, SEE:
 	 *	edac_device_ctrl_instance_release() for callback operation
 	 */
-	kobject_unregister(&instance->kobj);
+	kobject_put(&instance->kobj);
 }
 
 /*

commit b2ed215a3338b8b16187be8d136153054118a41e
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Dec 17 15:54:39 2007 -0400

    Kobject: change drivers/edac to use kobject_init_and_add
    
    Stop using kobject_register, as this way we can control the sending of
    the uevent properly, after everything is properly initialized.
    
    Acked-by: Doug Thompson <dougthompson@xmission.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 70b837f23c43..10e5b19a3e3b 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -246,16 +246,6 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 
 	/* Init the devices's kobject */
 	memset(&edac_dev->kobj, 0, sizeof(struct kobject));
-	edac_dev->kobj.ktype = &ktype_device_ctrl;
-
-	/* set this new device under the edac_class kobject */
-	edac_dev->kobj.parent = &edac_class->kset.kobj;
-
-	/* generate sysfs "..../edac/<name>"   */
-	debugf4("%s() set name of kobject to: %s\n", __func__, edac_dev->name);
-	err = kobject_set_name(&edac_dev->kobj, "%s", edac_dev->name);
-	if (err)
-		goto err_out;
 
 	/* Record which module 'owns' this control structure
 	 * and bump the ref count of the module
@@ -268,12 +258,15 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 	}
 
 	/* register */
-	err = kobject_register(&edac_dev->kobj);
+	err = kobject_init_and_add(&edac_dev->kobj, &ktype_device_ctrl,
+				   &edac_class->kset.kobj,
+				   "%s", edac_dev->name);
 	if (err) {
 		debugf1("%s()Failed to register '.../edac/%s'\n",
 			__func__, edac_dev->name);
 		goto err_kobj_reg;
 	}
+	kobject_uevent(&edac_dev->kobj, KOBJ_ADD);
 
 	/* At this point, to 'free' the control struct,
 	 * edac_device_unregister_sysfs_main_kobj() must be used
@@ -533,12 +526,6 @@ static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
 
 	/* init this block's kobject */
 	memset(&block->kobj, 0, sizeof(struct kobject));
-	block->kobj.parent = &instance->kobj;
-	block->kobj.ktype = &ktype_block_ctrl;
-
-	err = kobject_set_name(&block->kobj, "%s", block->name);
-	if (err)
-		return err;
 
 	/* bump the main kobject's reference count for this controller
 	 * and this instance is dependant on the main
@@ -550,7 +537,9 @@ static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
 	}
 
 	/* Add this block's kobject */
-	err = kobject_register(&block->kobj);
+	err = kobject_init_and_add(&block->kobj, &ktype_block_ctrl,
+				   &instance->kobj,
+				   "%s", block->name);
 	if (err) {
 		debugf1("%s() Failed to register instance '%s'\n",
 			__func__, block->name);
@@ -579,6 +568,7 @@ static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
 				goto err_on_attrib;
 		}
 	}
+	kobject_uevent(&block->kobj, KOBJ_ADD);
 
 	return 0;
 
@@ -637,15 +627,8 @@ static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
 	/* Init the instance's kobject */
 	memset(&instance->kobj, 0, sizeof(struct kobject));
 
-	/* set this new device under the edac_device main kobject */
-	instance->kobj.parent = &edac_dev->kobj;
-	instance->kobj.ktype = &ktype_instance_ctrl;
 	instance->ctl = edac_dev;
 
-	err = kobject_set_name(&instance->kobj, "%s", instance->name);
-	if (err)
-		goto err_out;
-
 	/* bump the main kobject's reference count for this controller
 	 * and this instance is dependant on the main
 	 */
@@ -655,8 +638,9 @@ static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
 		goto err_out;
 	}
 
-	/* Formally register this instance's kobject */
-	err = kobject_register(&instance->kobj);
+	/* Formally register this instance's kobject under the edac_device */
+	err = kobject_init_and_add(&instance->kobj, &ktype_instance_ctrl,
+				   &edac_dev->kobj, "%s", instance->name);
 	if (err != 0) {
 		debugf2("%s() Failed to register instance '%s'\n",
 			__func__, instance->name);
@@ -679,6 +663,7 @@ static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
 			goto err_release_instance_kobj;
 		}
 	}
+	kobject_uevent(&instance->kobj, KOBJ_ADD);
 
 	debugf4("%s() Registered instance %d '%s' kobject\n",
 		__func__, idx, instance->name);

commit b2a4ac0c2860b27670bce99e8c9c281bf431c272
Author: Doug Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:33 2007 -0700

    drivers/edac: fix edac_device sysfs corner case bug
    
    Some simple fixes to properly reference counter values from the block
    attribute level of edac_device objects.  Properly sequencing the array pointer
    was added, resulting in correct identification of block level attributes from
    their base class functions.
    
    Added more verbose debug statement for event tracking.
    
    Also during some corner testing, found a bug in the store/show sequence
    of operations for the block attribute/controls management.
    
    An old intermediate structure for 'blocks' was still in the processing
    pipeline.  This patch removes that old structure and correctly utilizes the
    new struct edac_dev_sysfs_block_attribute for passing control from the sysfs
    to the low level store/show function of the edac driver.
    
    Now the proper kobj pointer to passed downward to the store/show
    functions.
    
    Signed-off-by: Doug Thompson <dougthompson@xmission.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 52769ae69bd2..70b837f23c43 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -200,7 +200,7 @@ static void edac_device_ctrl_master_release(struct kobject *kobj)
 {
 	struct edac_device_ctl_info *edac_dev = to_edacdev(kobj);
 
-	debugf1("%s() control index=%d\n", __func__, edac_dev->dev_idx);
+	debugf4("%s() control index=%d\n", __func__, edac_dev->dev_idx);
 
 	/* decrement the EDAC CORE module ref count */
 	module_put(edac_dev->owner);
@@ -252,7 +252,7 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 	edac_dev->kobj.parent = &edac_class->kset.kobj;
 
 	/* generate sysfs "..../edac/<name>"   */
-	debugf1("%s() set name of kobject to: %s\n", __func__, edac_dev->name);
+	debugf4("%s() set name of kobject to: %s\n", __func__, edac_dev->name);
 	err = kobject_set_name(&edac_dev->kobj, "%s", edac_dev->name);
 	if (err)
 		goto err_out;
@@ -279,7 +279,7 @@ int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 	 * edac_device_unregister_sysfs_main_kobj() must be used
 	 */
 
-	debugf1("%s() Registered '.../edac/%s' kobject\n",
+	debugf4("%s() Registered '.../edac/%s' kobject\n",
 		__func__, edac_dev->name);
 
 	return 0;
@@ -300,7 +300,7 @@ void edac_device_unregister_sysfs_main_kobj(
 					struct edac_device_ctl_info *edac_dev)
 {
 	debugf0("%s()\n", __func__);
-	debugf1("%s() name of kobject is: %s\n",
+	debugf4("%s() name of kobject is: %s\n",
 		__func__, kobject_name(&edac_dev->kobj));
 
 	/*
@@ -416,22 +416,29 @@ static struct kobj_type ktype_instance_ctrl = {
 
 /* edac_dev -> instance -> block information */
 
+#define to_block(k) container_of(k, struct edac_device_block, kobj)
+#define to_block_attr(a) \
+	container_of(a, struct edac_dev_sysfs_block_attribute, attr)
+
 /*
  * Set of low-level block attribute show functions
  */
-static ssize_t block_ue_count_show(struct edac_device_block *block, char *data)
+static ssize_t block_ue_count_show(struct kobject *kobj,
+					struct attribute *attr, char *data)
 {
+	struct edac_device_block *block = to_block(kobj);
+
 	return sprintf(data, "%u\n", block->counters.ue_count);
 }
 
-static ssize_t block_ce_count_show(struct edac_device_block *block, char *data)
+static ssize_t block_ce_count_show(struct kobject *kobj,
+					struct attribute *attr, char *data)
 {
+	struct edac_device_block *block = to_block(kobj);
+
 	return sprintf(data, "%u\n", block->counters.ce_count);
 }
 
-#define to_block(k) container_of(k, struct edac_device_block, kobj)
-#define to_block_attr(a) container_of(a,struct block_attribute,attr)
-
 /* DEVICE block kobject release() function */
 static void edac_device_ctrl_block_release(struct kobject *kobj)
 {
@@ -448,22 +455,16 @@ static void edac_device_ctrl_block_release(struct kobject *kobj)
 	kobject_put(&block->instance->ctl->kobj);
 }
 
-/* block specific attribute structure */
-struct block_attribute {
-	struct attribute attr;
-	 ssize_t(*show) (struct edac_device_block *, char *);
-	 ssize_t(*store) (struct edac_device_block *, const char *, size_t);
-};
 
 /* Function to 'show' fields from the edac_dev 'block' structure */
 static ssize_t edac_dev_block_show(struct kobject *kobj,
 				struct attribute *attr, char *buffer)
 {
-	struct edac_device_block *block = to_block(kobj);
-	struct block_attribute *block_attr = to_block_attr(attr);
+	struct edac_dev_sysfs_block_attribute *block_attr =
+						to_block_attr(attr);
 
 	if (block_attr->show)
-		return block_attr->show(block, buffer);
+		return block_attr->show(kobj, attr, buffer);
 	return -EIO;
 }
 
@@ -472,11 +473,12 @@ static ssize_t edac_dev_block_store(struct kobject *kobj,
 				struct attribute *attr,
 				const char *buffer, size_t count)
 {
-	struct edac_device_block *block = to_block(kobj);
-	struct block_attribute *block_attr = to_block_attr(attr);
+	struct edac_dev_sysfs_block_attribute *block_attr;
+
+	block_attr = to_block_attr(attr);
 
 	if (block_attr->store)
-		return block_attr->store(block, buffer, count);
+		return block_attr->store(kobj, attr, buffer, count);
 	return -EIO;
 }
 
@@ -487,7 +489,7 @@ static struct sysfs_ops device_block_ops = {
 };
 
 #define BLOCK_ATTR(_name,_mode,_show,_store)        \
-static struct block_attribute attr_block_##_name = {                       \
+static struct edac_dev_sysfs_block_attribute attr_block_##_name = {	\
 	.attr = {.name = __stringify(_name), .mode = _mode },   \
 	.show   = _show,                                        \
 	.store  = _store,                                       \
@@ -497,7 +499,7 @@ BLOCK_ATTR(ce_count, S_IRUGO, block_ce_count_show, NULL);
 BLOCK_ATTR(ue_count, S_IRUGO, block_ue_count_show, NULL);
 
 /* list of edac_dev 'block' attributes */
-static struct block_attribute *device_block_attr[] = {
+static struct edac_dev_sysfs_block_attribute *device_block_attr[] = {
 	&attr_block_ce_count,
 	&attr_block_ue_count,
 	NULL,
@@ -524,14 +526,15 @@ static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
 	struct edac_dev_sysfs_block_attribute *sysfs_attrib;
 	struct kobject *main_kobj;
 
-	debugf1("%s() Instance '%s' block '%s'\n",
-		__func__, instance->name, block->name);
+	debugf4("%s() Instance '%s' inst_p=%p  block '%s'  block_p=%p\n",
+		__func__, instance->name, instance, block->name, block);
+	debugf4("%s() block kobj=%p  block kobj->parent=%p\n",
+		__func__, &block->kobj, &block->kobj.parent);
 
 	/* init this block's kobject */
 	memset(&block->kobj, 0, sizeof(struct kobject));
 	block->kobj.parent = &instance->kobj;
 	block->kobj.ktype = &ktype_block_ctrl;
-	block->instance = instance;
 
 	err = kobject_set_name(&block->kobj, "%s", block->name);
 	if (err)
@@ -560,14 +563,20 @@ static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
 	 * to the block kobject
 	 */
 	sysfs_attrib = block->block_attributes;
-	if (sysfs_attrib) {
-		for (i = 0; i < block->nr_attribs; i++) {
+	if (sysfs_attrib && block->nr_attribs) {
+		for (i = 0; i < block->nr_attribs; i++, sysfs_attrib++) {
+
+			debugf4("%s() creating block attrib='%s' "
+				"attrib->%p to kobj=%p\n",
+				__func__,
+				sysfs_attrib->attr.name,
+				sysfs_attrib, &block->kobj);
+
+			/* Create each block_attribute file */
 			err = sysfs_create_file(&block->kobj,
-				(struct attribute *) sysfs_attrib);
+				&sysfs_attrib->attr);
 			if (err)
 				goto err_on_attrib;
-
-			sysfs_attrib++;
 		}
 	}
 
@@ -595,7 +604,9 @@ static void edac_device_delete_block(struct edac_device_ctl_info *edac_dev,
 	 */
 	sysfs_attrib = block->block_attributes;
 	if (sysfs_attrib && block->nr_attribs) {
-		for (i = 0; i < block->nr_attribs; i++) {
+		for (i = 0; i < block->nr_attribs; i++, sysfs_attrib++) {
+
+			/* remove each block_attrib file */
 			sysfs_remove_file(&block->kobj,
 				(struct attribute *) sysfs_attrib);
 		}
@@ -653,7 +664,7 @@ static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
 		goto err_out;
 	}
 
-	debugf1("%s() now register '%d' blocks for instance %d\n",
+	debugf4("%s() now register '%d' blocks for instance %d\n",
 		__func__, instance->nr_blocks, idx);
 
 	/* register all blocks of this instance */
@@ -669,7 +680,7 @@ static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
 		}
 	}
 
-	debugf1("%s() Registered instance %d '%s' kobject\n",
+	debugf4("%s() Registered instance %d '%s' kobject\n",
 		__func__, idx, instance->name);
 
 	return 0;
@@ -848,7 +859,7 @@ int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
 	}
 
 
-	debugf0("%s() calling create-instances, idx=%d\n",
+	debugf4("%s() create-instances done, idx=%d\n",
 		__func__, edac_dev->dev_idx);
 
 	return 0;

commit 1c3631ff1f805cb72644fcde02b7c58950f21cd5
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:29 2007 -0700

    drivers/edac: fix edac_device sysfs completion code
    
    With feedback, this patch corrects operation of the kobject release operation
    on kobjects, attributes and controls for the edac_device.
    
    Cc: Alan Cox alan@lxorguk.ukuu.org.uk
    Signed-off-by: Doug Thompson <dougthompson@xmission.com>
    Acked-by: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 235b4c79355d..52769ae69bd2 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -1,7 +1,8 @@
 /*
  * file for managing the edac_device class of devices for EDAC
  *
- * (C) 2007 SoftwareBitMaker(http://www.softwarebitmaker.com)
+ * (C) 2007 SoftwareBitMaker (http://www.softwarebitmaker.com)
+ *
  * This file may be distributed under the terms of the
  * GNU General Public License.
  *
@@ -10,6 +11,7 @@
  */
 
 #include <linux/ctype.h>
+#include <linux/module.h>
 
 #include "edac_core.h"
 #include "edac_module.h"
@@ -19,7 +21,6 @@
 #define to_edacdev(k) container_of(k, struct edac_device_ctl_info, kobj)
 #define to_edacdev_attr(a) container_of(a, struct edacdev_attribute, attr)
 
-/************************** edac_device sysfs code and data **************/
 
 /*
  * Set of edac_device_ctl_info attribute store/show functions
@@ -103,8 +104,8 @@ static ssize_t edac_device_ctl_poll_msec_store(struct edac_device_ctl_info
 /* edac_device_ctl_info specific attribute structure */
 struct ctl_info_attribute {
 	struct attribute attr;
-	 ssize_t(*show) (struct edac_device_ctl_info *, char *);
-	 ssize_t(*store) (struct edac_device_ctl_info *, const char *, size_t);
+	ssize_t(*show) (struct edac_device_ctl_info *, char *);
+	ssize_t(*store) (struct edac_device_ctl_info *, const char *, size_t);
 };
 
 #define to_ctl_info(k) container_of(k, struct edac_device_ctl_info, kobj)
@@ -168,45 +169,76 @@ static struct ctl_info_attribute *device_ctrl_attr[] = {
 	NULL,
 };
 
-/* Main DEVICE kobject release() function */
+/*
+ * edac_device_ctrl_master_release
+ *
+ *	called when the reference count for the 'main' kobj
+ *	for a edac_device control struct reaches zero
+ *
+ *	Reference count model:
+ *		One 'main' kobject for each control structure allocated.
+ *		That main kobj is initially set to one AND
+ *		the reference count for the EDAC 'core' module is
+ *		bumped by one, thus added 'keep in memory' dependency.
+ *
+ *		Each new internal kobj (in instances and blocks) then
+ *		bumps the 'main' kobject.
+ *
+ *		When they are released their release functions decrement
+ *		the 'main' kobj.
+ *
+ *		When the main kobj reaches zero (0) then THIS function
+ *		is called which then decrements the EDAC 'core' module.
+ *		When the module reference count reaches zero then the
+ *		module no longer has dependency on keeping the release
+ *		function code in memory and module can be unloaded.
+ *
+ *		This will support several control objects as well, each
+ *		with its own 'main' kobj.
+ */
 static void edac_device_ctrl_master_release(struct kobject *kobj)
 {
-	struct edac_device_ctl_info *edac_dev;
+	struct edac_device_ctl_info *edac_dev = to_edacdev(kobj);
 
-	edac_dev = to_edacdev(kobj);
+	debugf1("%s() control index=%d\n", __func__, edac_dev->dev_idx);
 
-	debugf1("%s()\n", __func__);
-	complete(&edac_dev->kobj_complete);
+	/* decrement the EDAC CORE module ref count */
+	module_put(edac_dev->owner);
+
+	/* free the control struct containing the 'main' kobj
+	 * passed in to this routine
+	 */
+	kfree(edac_dev);
 }
 
+/* ktype for the main (master) kobject */
 static struct kobj_type ktype_device_ctrl = {
 	.release = edac_device_ctrl_master_release,
 	.sysfs_ops = &device_ctl_info_ops,
 	.default_attrs = (struct attribute **)device_ctrl_attr,
 };
 
-/**************** edac_device main kobj ctor/dtor code *********************/
-
 /*
- * edac_device_register_main_kobj
+ * edac_device_register_sysfs_main_kobj
  *
  *	perform the high level setup for the new edac_device instance
  *
  * Return:  0 SUCCESS
  *         !0 FAILURE
  */
-static int edac_device_register_main_kobj(struct edac_device_ctl_info *edac_dev)
+int edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)
 {
-	int err = 0;
 	struct sysdev_class *edac_class;
+	int err;
 
 	debugf1("%s()\n", __func__);
 
 	/* get the /sys/devices/system/edac reference */
 	edac_class = edac_get_edac_class();
 	if (edac_class == NULL) {
-		debugf1("%s() no edac_class error=%d\n", __func__, err);
-		return err;
+		debugf1("%s() no edac_class error\n", __func__);
+		err = -ENODEV;
+		goto err_out;
 	}
 
 	/* Point to the 'edac_class' this instance 'reports' to */
@@ -223,42 +255,65 @@ static int edac_device_register_main_kobj(struct edac_device_ctl_info *edac_dev)
 	debugf1("%s() set name of kobject to: %s\n", __func__, edac_dev->name);
 	err = kobject_set_name(&edac_dev->kobj, "%s", edac_dev->name);
 	if (err)
-		return err;
+		goto err_out;
+
+	/* Record which module 'owns' this control structure
+	 * and bump the ref count of the module
+	 */
+	edac_dev->owner = THIS_MODULE;
+
+	if (!try_module_get(edac_dev->owner)) {
+		err = -ENODEV;
+		goto err_out;
+	}
+
+	/* register */
 	err = kobject_register(&edac_dev->kobj);
 	if (err) {
 		debugf1("%s()Failed to register '.../edac/%s'\n",
 			__func__, edac_dev->name);
-		return err;
+		goto err_kobj_reg;
 	}
 
+	/* At this point, to 'free' the control struct,
+	 * edac_device_unregister_sysfs_main_kobj() must be used
+	 */
+
 	debugf1("%s() Registered '.../edac/%s' kobject\n",
 		__func__, edac_dev->name);
 
 	return 0;
+
+	/* Error exit stack */
+err_kobj_reg:
+	module_put(edac_dev->owner);
+
+err_out:
+	return err;
 }
 
 /*
- * edac_device_unregister_main_kobj:
+ * edac_device_unregister_sysfs_main_kobj:
  *	the '..../edac/<name>' kobject
  */
-static void edac_device_unregister_main_kobj(struct edac_device_ctl_info
-					*edac_dev)
+void edac_device_unregister_sysfs_main_kobj(
+					struct edac_device_ctl_info *edac_dev)
 {
 	debugf0("%s()\n", __func__);
 	debugf1("%s() name of kobject is: %s\n",
 		__func__, kobject_name(&edac_dev->kobj));
 
-	init_completion(&edac_dev->kobj_complete);
-
 	/*
 	 * Unregister the edac device's kobject and
-	 * wait for reference count to reach 0.
+	 * allow for reference count to reach 0 at which point
+	 * the callback will be called to:
+	 *   a) module_put() this module
+	 *   b) 'kfree' the memory
 	 */
 	kobject_unregister(&edac_dev->kobj);
-	wait_for_completion(&edac_dev->kobj_complete);
 }
 
-/*************** edac_dev -> instance information ***********/
+/* edac_dev -> instance information */
 
 /*
  * Set of low-level instance attribute show functions
@@ -285,8 +340,11 @@ static void edac_device_ctrl_instance_release(struct kobject *kobj)
 
 	debugf1("%s()\n", __func__);
 
+	/* map from this kobj to the main control struct
+	 * and then dec the main kobj count
+	 */
 	instance = to_instance(kobj);
-	complete(&instance->kobj_complete);
+	kobject_put(&instance->ctl->kobj);
 }
 
 /* instance specific attribute structure */
@@ -356,7 +414,7 @@ static struct kobj_type ktype_instance_ctrl = {
 	.default_attrs = (struct attribute **)device_instance_attr,
 };
 
-/*************** edac_dev -> instance -> block information *********/
+/* edac_dev -> instance -> block information */
 
 /*
  * Set of low-level block attribute show functions
@@ -381,8 +439,13 @@ static void edac_device_ctrl_block_release(struct kobject *kobj)
 
 	debugf1("%s()\n", __func__);
 
+	/* get the container of the kobj */
 	block = to_block(kobj);
-	complete(&block->kobj_complete);
+
+	/* map from 'block kobj' to 'block->instance->controller->main_kobj'
+	 * now 'release' the block kobject
+	 */
+	kobject_put(&block->instance->ctl->kobj);
 }
 
 /* block specific attribute structure */
@@ -447,49 +510,60 @@ static struct kobj_type ktype_block_ctrl = {
 	.default_attrs = (struct attribute **)device_block_attr,
 };
 
-/************** block ctor/dtor  code ************/
+/* block ctor/dtor  code */
 
 /*
  * edac_device_create_block
  */
 static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
 				struct edac_device_instance *instance,
-				int idx)
+				struct edac_device_block *block)
 {
 	int i;
 	int err;
-	struct edac_device_block *block;
 	struct edac_dev_sysfs_block_attribute *sysfs_attrib;
+	struct kobject *main_kobj;
 
-	block = &instance->blocks[idx];
-
-	debugf1("%s() Instance '%s' block[%d] '%s'\n",
-		__func__, instance->name, idx, block->name);
+	debugf1("%s() Instance '%s' block '%s'\n",
+		__func__, instance->name, block->name);
 
 	/* init this block's kobject */
 	memset(&block->kobj, 0, sizeof(struct kobject));
 	block->kobj.parent = &instance->kobj;
 	block->kobj.ktype = &ktype_block_ctrl;
+	block->instance = instance;
 
 	err = kobject_set_name(&block->kobj, "%s", block->name);
 	if (err)
 		return err;
 
+	/* bump the main kobject's reference count for this controller
+	 * and this instance is dependant on the main
+	 */
+	main_kobj = kobject_get(&edac_dev->kobj);
+	if (!main_kobj) {
+		err = -ENODEV;
+		goto err_out;
+	}
+
+	/* Add this block's kobject */
 	err = kobject_register(&block->kobj);
 	if (err) {
-		debugf1("%s()Failed to register instance '%s'\n",
+		debugf1("%s() Failed to register instance '%s'\n",
 			__func__, block->name);
-		return err;
+		kobject_put(main_kobj);
+		err = -ENODEV;
+		goto err_out;
 	}
 
 	/* If there are driver level block attributes, then added them
 	 * to the block kobject
 	 */
 	sysfs_attrib = block->block_attributes;
-	if (sysfs_attrib != NULL) {
+	if (sysfs_attrib) {
 		for (i = 0; i < block->nr_attribs; i++) {
 			err = sysfs_create_file(&block->kobj,
-				(struct attribute *) &sysfs_attrib[i]);
+				(struct attribute *) sysfs_attrib);
 			if (err)
 				goto err_on_attrib;
 
@@ -499,30 +573,41 @@ static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
 
 	return 0;
 
+	/* Error unwind stack */
 err_on_attrib:
 	kobject_unregister(&block->kobj);
 
+err_out:
 	return err;
 }
 
 /*
- * edac_device_delete_block(edac_dev,j);
+ * edac_device_delete_block(edac_dev,block);
  */
 static void edac_device_delete_block(struct edac_device_ctl_info *edac_dev,
-				struct edac_device_instance *instance,
-				int idx)
+				struct edac_device_block *block)
 {
-	struct edac_device_block *block;
+	struct edac_dev_sysfs_block_attribute *sysfs_attrib;
+	int i;
 
-	block = &instance->blocks[idx];
+	/* if this block has 'attributes' then we need to iterate over the list
+	 * and 'remove' the attributes on this block
+	 */
+	sysfs_attrib = block->block_attributes;
+	if (sysfs_attrib && block->nr_attribs) {
+		for (i = 0; i < block->nr_attribs; i++) {
+			sysfs_remove_file(&block->kobj,
+				(struct attribute *) sysfs_attrib);
+		}
+	}
 
-	/* unregister this block's kobject */
-	init_completion(&block->kobj_complete);
+	/* unregister this block's kobject, SEE:
+	 *	edac_device_ctrl_block_release() callback operation
+	 */
 	kobject_unregister(&block->kobj);
-	wait_for_completion(&block->kobj_complete);
 }
 
-/************** instance ctor/dtor  code ************/
+/* instance ctor/dtor code */
 
 /*
  * edac_device_create_instance
@@ -534,6 +619,7 @@ static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
 	int i, j;
 	int err;
 	struct edac_device_instance *instance;
+	struct kobject *main_kobj;
 
 	instance = &edac_dev->instances[idx];
 
@@ -543,16 +629,28 @@ static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
 	/* set this new device under the edac_device main kobject */
 	instance->kobj.parent = &edac_dev->kobj;
 	instance->kobj.ktype = &ktype_instance_ctrl;
+	instance->ctl = edac_dev;
 
 	err = kobject_set_name(&instance->kobj, "%s", instance->name);
 	if (err)
-		return err;
+		goto err_out;
+
+	/* bump the main kobject's reference count for this controller
+	 * and this instance is dependant on the main
+	 */
+	main_kobj = kobject_get(&edac_dev->kobj);
+	if (!main_kobj) {
+		err = -ENODEV;
+		goto err_out;
+	}
 
+	/* Formally register this instance's kobject */
 	err = kobject_register(&instance->kobj);
 	if (err != 0) {
 		debugf2("%s() Failed to register instance '%s'\n",
 			__func__, instance->name);
-		return err;
+		kobject_put(main_kobj);
+		goto err_out;
 	}
 
 	debugf1("%s() now register '%d' blocks for instance %d\n",
@@ -560,11 +658,14 @@ static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
 
 	/* register all blocks of this instance */
 	for (i = 0; i < instance->nr_blocks; i++) {
-		err = edac_device_create_block(edac_dev, instance, i);
+		err = edac_device_create_block(edac_dev, instance,
+						&instance->blocks[i]);
 		if (err) {
+			/* If any fail, remove all previous ones */
 			for (j = 0; j < i; j++)
-				edac_device_delete_block(edac_dev, instance, j);
-			return err;
+				edac_device_delete_block(edac_dev,
+							&instance->blocks[j]);
+			goto err_release_instance_kobj;
 		}
 	}
 
@@ -572,6 +673,13 @@ static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
 		__func__, idx, instance->name);
 
 	return 0;
+
+	/* error unwind stack */
+err_release_instance_kobj:
+	kobject_unregister(&instance->kobj);
+
+err_out:
+	return err;
 }
 
 /*
@@ -581,19 +689,19 @@ static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
 static void edac_device_delete_instance(struct edac_device_ctl_info *edac_dev,
 					int idx)
 {
-	int i;
 	struct edac_device_instance *instance;
+	int i;
 
 	instance = &edac_dev->instances[idx];
 
 	/* unregister all blocks in this instance */
 	for (i = 0; i < instance->nr_blocks; i++)
-		edac_device_delete_block(edac_dev, instance, i);
+		edac_device_delete_block(edac_dev, &instance->blocks[i]);
 
-	/* unregister this instance's kobject */
-	init_completion(&instance->kobj_complete);
+	/* unregister this instance's kobject, SEE:
+	 *	edac_device_ctrl_instance_release() for callback operation
+	 */
 	kobject_unregister(&instance->kobj);
-	wait_for_completion(&instance->kobj_complete);
 }
 
 /*
@@ -635,39 +743,69 @@ static void edac_device_delete_instances(struct edac_device_ctl_info *edac_dev)
 		edac_device_delete_instance(edac_dev, i);
 }
 
-/******************* edac_dev sysfs ctor/dtor  code *************/
+/* edac_dev sysfs ctor/dtor  code */
 
 /*
- * edac_device_add_sysfs_attributes
+ * edac_device_add_main_sysfs_attributes
  *	add some attributes to this instance's main kobject
  */
-static int edac_device_add_sysfs_attributes(
+static int edac_device_add_main_sysfs_attributes(
 			struct edac_device_ctl_info *edac_dev)
 {
-	int err;
 	struct edac_dev_sysfs_attribute *sysfs_attrib;
+	int err = 0;
 
-	/* point to the start of the array and iterate over it
-	 * adding each attribute listed to this mci instance's kobject
-	 */
 	sysfs_attrib = edac_dev->sysfs_attributes;
-
-	while (sysfs_attrib->attr.name != NULL) {
-		err = sysfs_create_file(&edac_dev->kobj,
+	if (sysfs_attrib) {
+		/* iterate over the array and create an attribute for each
+		 * entry in the list
+		 */
+		while (sysfs_attrib->attr.name != NULL) {
+			err = sysfs_create_file(&edac_dev->kobj,
 				(struct attribute*) sysfs_attrib);
-		if (err)
-			return err;
+			if (err)
+				goto err_out;
 
-		sysfs_attrib++;
+			sysfs_attrib++;
+		}
 	}
 
-	return 0;
+err_out:
+	return err;
+}
+
+/*
+ * edac_device_remove_main_sysfs_attributes
+ *	remove any attributes to this instance's main kobject
+ */
+static void edac_device_remove_main_sysfs_attributes(
+			struct edac_device_ctl_info *edac_dev)
+{
+	struct edac_dev_sysfs_attribute *sysfs_attrib;
+
+	/* if there are main attributes, defined, remove them. First,
+	 * point to the start of the array and iterate over it
+	 * removing each attribute listed from this device's instance's kobject
+	 */
+	sysfs_attrib = edac_dev->sysfs_attributes;
+	if (sysfs_attrib) {
+		while (sysfs_attrib->attr.name != NULL) {
+			sysfs_remove_file(&edac_dev->kobj,
+					(struct attribute *) sysfs_attrib);
+			sysfs_attrib++;
+		}
+	}
 }
 
 /*
  * edac_device_create_sysfs() Constructor
  *
- * Create a new edac_device kobject instance,
+ * accept a created edac_device control structure
+ * and 'export' it to sysfs. The 'main' kobj should already have been
+ * created. 'instance' and 'block' kobjects should be registered
+ * along with any 'block' attributes from the low driver. In addition,
+ * the main attributes (if any) are connected to the main kobject of
+ * the control structure.
  *
  * Return:
  *	0	Success
@@ -678,23 +816,13 @@ int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
 	int err;
 	struct kobject *edac_kobj = &edac_dev->kobj;
 
-	/* register this instance's main kobj with the edac class kobj */
-	err = edac_device_register_main_kobj(edac_dev);
-	if (err)
-		return err;
-
 	debugf0("%s() idx=%d\n", __func__, edac_dev->dev_idx);
 
-	/* If the low level driver requests some sysfs entries
-	 * then go create them here
-	 */
-	if (edac_dev->sysfs_attributes != NULL) {
-		err = edac_device_add_sysfs_attributes(edac_dev);
-		if (err) {
-			debugf0("%s() failed to add sysfs attribs\n",
-				__func__);
-			goto err_unreg_object;
-		}
+	/*  go create any main attributes callers wants */
+	err = edac_device_add_main_sysfs_attributes(edac_dev);
+	if (err) {
+		debugf0("%s() failed to add sysfs attribs\n", __func__);
+		goto err_out;
 	}
 
 	/* create a symlink from the edac device
@@ -705,16 +833,23 @@ int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
 	if (err) {
 		debugf0("%s() sysfs_create_link() returned err= %d\n",
 			__func__, err);
-		goto err_unreg_object;
+		goto err_remove_main_attribs;
 	}
 
-	debugf0("%s() calling create-instances, idx=%d\n",
-		__func__, edac_dev->dev_idx);
-
-	/* Create the first level instance directories */
+	/* Create the first level instance directories
+	 * In turn, the nested blocks beneath the instances will
+	 * be registered as well
+	 */
 	err = edac_device_create_instances(edac_dev);
-	if (err)
+	if (err) {
+		debugf0("%s() edac_device_create_instances() "
+			"returned err= %d\n", __func__, err);
 		goto err_remove_link;
+	}
+
+
+	debugf0("%s() calling create-instances, idx=%d\n",
+		__func__, edac_dev->dev_idx);
 
 	return 0;
 
@@ -723,26 +858,28 @@ int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
 	/* remove the sym link */
 	sysfs_remove_link(&edac_dev->kobj, EDAC_DEVICE_SYMLINK);
 
-err_unreg_object:
-	edac_device_unregister_main_kobj(edac_dev);
+err_remove_main_attribs:
+	edac_device_remove_main_sysfs_attributes(edac_dev);
 
+err_out:
 	return err;
 }
 
 /*
  * edac_device_remove_sysfs() destructor
  *
- * remove a edac_device instance
+ * given an edac_device struct, tear down the kobject resources
  */
 void edac_device_remove_sysfs(struct edac_device_ctl_info *edac_dev)
 {
 	debugf0("%s()\n", __func__);
 
-	edac_device_delete_instances(edac_dev);
+	/* remove any main attributes for this device */
+	edac_device_remove_main_sysfs_attributes(edac_dev);
 
-	/* remove the sym link */
+	/* remove the device sym link */
 	sysfs_remove_link(&edac_dev->kobj, EDAC_DEVICE_SYMLINK);
 
-	/* unregister the instance's main kobj */
-	edac_device_unregister_main_kobj(edac_dev);
+	/* walk the instance/block kobject tree, deconstructing it */
+	edac_device_delete_instances(edac_dev);
 }

commit fd309a9d8e63e9176759d00630b65d772ae06e0c
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:25 2007 -0700

    drivers/edac: fix leaf sysfs attribute
    
    This patch fixes and enhances the driver level set of sysfs attributes that
    can be added to the 'block' level of an edac_device type of driver.
    
    There is a controller information structure, which contains one or more
    instances of device.  Each instance will have one or more blocks of device
    specific counters.  This patch fixes the ability to have more detailed
    attributes/controls for each of the 'blocks', providing for the addition of
    controls/attributes from the low level driver to user space via sysfs.
    
    Cc: Alan Cox alan@lxorguk.ukuu.org.uk
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 7a233e6e2b36..235b4c79355d 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -456,8 +456,10 @@ static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
 				struct edac_device_instance *instance,
 				int idx)
 {
+	int i;
 	int err;
 	struct edac_device_block *block;
+	struct edac_dev_sysfs_block_attribute *sysfs_attrib;
 
 	block = &instance->blocks[idx];
 
@@ -480,7 +482,27 @@ static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
 		return err;
 	}
 
+	/* If there are driver level block attributes, then added them
+	 * to the block kobject
+	 */
+	sysfs_attrib = block->block_attributes;
+	if (sysfs_attrib != NULL) {
+		for (i = 0; i < block->nr_attribs; i++) {
+			err = sysfs_create_file(&block->kobj,
+				(struct attribute *) &sysfs_attrib[i]);
+			if (err)
+				goto err_on_attrib;
+
+			sysfs_attrib++;
+		}
+	}
+
 	return 0;
+
+err_on_attrib:
+	kobject_unregister(&block->kobj);
+
+	return err;
 }
 
 /*

commit 52490c8d07680a7ecc3c1a70a16841455d37e96a
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:20 2007 -0700

    drivers/edac: edac_device code tidying
    
    For the file edac_device.c perform some coding style enhancements
    Add some function header comments
    Made for better readability commands
    
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 5bf7cbab27d4..7a233e6e2b36 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -292,8 +292,8 @@ static void edac_device_ctrl_instance_release(struct kobject *kobj)
 /* instance specific attribute structure */
 struct instance_attribute {
 	struct attribute attr;
-	 ssize_t(*show) (struct edac_device_instance *, char *);
-	 ssize_t(*store) (struct edac_device_instance *, const char *, size_t);
+	ssize_t(*show) (struct edac_device_instance *, char *);
+	ssize_t(*store) (struct edac_device_instance *, const char *, size_t);
 };
 
 /* Function to 'show' fields from the edac_dev 'instance' structure */
@@ -540,9 +540,8 @@ static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
 	for (i = 0; i < instance->nr_blocks; i++) {
 		err = edac_device_create_block(edac_dev, instance, i);
 		if (err) {
-			for (j = 0; j < i; j++) {
+			for (j = 0; j < i; j++)
 				edac_device_delete_block(edac_dev, instance, j);
-			}
 			return err;
 		}
 	}
@@ -566,9 +565,8 @@ static void edac_device_delete_instance(struct edac_device_ctl_info *edac_dev,
 	instance = &edac_dev->instances[idx];
 
 	/* unregister all blocks in this instance */
-	for (i = 0; i < instance->nr_blocks; i++) {
+	for (i = 0; i < instance->nr_blocks; i++)
 		edac_device_delete_block(edac_dev, instance, i);
-	}
 
 	/* unregister this instance's kobject */
 	init_completion(&instance->kobj_complete);
@@ -593,9 +591,8 @@ static int edac_device_create_instances(struct edac_device_ctl_info *edac_dev)
 		err = edac_device_create_instance(edac_dev, i);
 		if (err) {
 			/* unwind previous instances on error */
-			for (j = 0; j < i; j++) {
+			for (j = 0; j < i; j++)
 				edac_device_delete_instance(edac_dev, j);
-			}
 			return err;
 		}
 	}
@@ -612,9 +609,8 @@ static void edac_device_delete_instances(struct edac_device_ctl_info *edac_dev)
 	int i;
 
 	/* iterate over creation of the instances */
-	for (i = 0; i < edac_dev->nr_instances; i++) {
+	for (i = 0; i < edac_dev->nr_instances; i++)
 		edac_device_delete_instance(edac_dev, i);
-	}
 }
 
 /******************* edac_dev sysfs ctor/dtor  code *************/
@@ -637,9 +633,8 @@ static int edac_device_add_sysfs_attributes(
 	while (sysfs_attrib->attr.name != NULL) {
 		err = sysfs_create_file(&edac_dev->kobj,
 				(struct attribute*) sysfs_attrib);
-		if (err) {
+		if (err)
 			return err;
-		}
 
 		sysfs_attrib++;
 	}
@@ -696,9 +691,8 @@ int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
 
 	/* Create the first level instance directories */
 	err = edac_device_create_instances(edac_dev);
-	if (err) {
+	if (err)
 		goto err_remove_link;
-	}
 
 	return 0;
 

commit 052dfb45ccb5ea354a426b52556bcfee75b9d2f5
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:13 2007 -0700

    drivers/edac: cleanup spaces-gotos after Lindent messup
    
    This patch fixes some remnant spaces inserted by the use of Lindent.
    Seems Lindent adds some spaces when it shoulded. These have been fixed.
    In addition, goto targets have issues, these have been fixed
    in this patch.
    
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 32b2a8e53dc7..5bf7cbab27d4 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -27,14 +27,14 @@
 
 /* 'log_ue' */
 static ssize_t edac_device_ctl_log_ue_show(struct edac_device_ctl_info
-					   *ctl_info, char *data)
+					*ctl_info, char *data)
 {
 	return sprintf(data, "%u\n", ctl_info->log_ue);
 }
 
 static ssize_t edac_device_ctl_log_ue_store(struct edac_device_ctl_info
-					    *ctl_info, const char *data,
-					    size_t count)
+					*ctl_info, const char *data,
+					size_t count)
 {
 	/* if parameter is zero, turn off flag, if non-zero turn on flag */
 	ctl_info->log_ue = (simple_strtoul(data, NULL, 0) != 0);
@@ -44,14 +44,14 @@ static ssize_t edac_device_ctl_log_ue_store(struct edac_device_ctl_info
 
 /* 'log_ce' */
 static ssize_t edac_device_ctl_log_ce_show(struct edac_device_ctl_info
-					   *ctl_info, char *data)
+					*ctl_info, char *data)
 {
 	return sprintf(data, "%u\n", ctl_info->log_ce);
 }
 
 static ssize_t edac_device_ctl_log_ce_store(struct edac_device_ctl_info
-					    *ctl_info, const char *data,
-					    size_t count)
+					*ctl_info, const char *data,
+					size_t count)
 {
 	/* if parameter is zero, turn off flag, if non-zero turn on flag */
 	ctl_info->log_ce = (simple_strtoul(data, NULL, 0) != 0);
@@ -78,14 +78,14 @@ static ssize_t edac_device_ctl_panic_on_ue_store(struct edac_device_ctl_info
 
 /* 'poll_msec' show and store functions*/
 static ssize_t edac_device_ctl_poll_msec_show(struct edac_device_ctl_info
-					      *ctl_info, char *data)
+					*ctl_info, char *data)
 {
 	return sprintf(data, "%u\n", ctl_info->poll_msec);
 }
 
 static ssize_t edac_device_ctl_poll_msec_store(struct edac_device_ctl_info
-					       *ctl_info, const char *data,
-					       size_t count)
+					*ctl_info, const char *data,
+					size_t count)
 {
 	unsigned long value;
 
@@ -112,7 +112,7 @@ struct ctl_info_attribute {
 
 /* Function to 'show' fields from the edac_dev 'ctl_info' structure */
 static ssize_t edac_dev_ctl_info_show(struct kobject *kobj,
-				      struct attribute *attr, char *buffer)
+				struct attribute *attr, char *buffer)
 {
 	struct edac_device_ctl_info *edac_dev = to_ctl_info(kobj);
 	struct ctl_info_attribute *ctl_info_attr = to_ctl_info_attr(attr);
@@ -124,8 +124,8 @@ static ssize_t edac_dev_ctl_info_show(struct kobject *kobj,
 
 /* Function to 'store' fields into the edac_dev 'ctl_info' structure */
 static ssize_t edac_dev_ctl_info_store(struct kobject *kobj,
-				       struct attribute *attr,
-				       const char *buffer, size_t count)
+				struct attribute *attr,
+				const char *buffer, size_t count)
 {
 	struct edac_device_ctl_info *edac_dev = to_ctl_info(kobj);
 	struct ctl_info_attribute *ctl_info_attr = to_ctl_info_attr(attr);
@@ -143,21 +143,21 @@ static struct sysfs_ops device_ctl_info_ops = {
 
 #define CTL_INFO_ATTR(_name,_mode,_show,_store)        \
 static struct ctl_info_attribute attr_ctl_info_##_name = {      \
-        .attr = {.name = __stringify(_name), .mode = _mode },   \
-        .show   = _show,                                        \
-        .store  = _store,                                       \
+	.attr = {.name = __stringify(_name), .mode = _mode },   \
+	.show   = _show,                                        \
+	.store  = _store,                                       \
 };
 
 /* Declare the various ctl_info attributes here and their respective ops */
 CTL_INFO_ATTR(log_ue, S_IRUGO | S_IWUSR,
-	      edac_device_ctl_log_ue_show, edac_device_ctl_log_ue_store);
+	edac_device_ctl_log_ue_show, edac_device_ctl_log_ue_store);
 CTL_INFO_ATTR(log_ce, S_IRUGO | S_IWUSR,
-	      edac_device_ctl_log_ce_show, edac_device_ctl_log_ce_store);
+	edac_device_ctl_log_ce_show, edac_device_ctl_log_ce_store);
 CTL_INFO_ATTR(panic_on_ue, S_IRUGO | S_IWUSR,
-	      edac_device_ctl_panic_on_ue_show,
-	      edac_device_ctl_panic_on_ue_store);
+	edac_device_ctl_panic_on_ue_show,
+	edac_device_ctl_panic_on_ue_store);
 CTL_INFO_ATTR(poll_msec, S_IRUGO | S_IWUSR,
-	      edac_device_ctl_poll_msec_show, edac_device_ctl_poll_msec_store);
+	edac_device_ctl_poll_msec_show, edac_device_ctl_poll_msec_store);
 
 /* Base Attributes of the EDAC_DEVICE ECC object */
 static struct ctl_info_attribute *device_ctrl_attr[] = {
@@ -242,7 +242,7 @@ static int edac_device_register_main_kobj(struct edac_device_ctl_info *edac_dev)
  *	the '..../edac/<name>' kobject
  */
 static void edac_device_unregister_main_kobj(struct edac_device_ctl_info
-					     *edac_dev)
+					*edac_dev)
 {
 	debugf0("%s()\n", __func__);
 	debugf1("%s() name of kobject is: %s\n",
@@ -264,13 +264,13 @@ static void edac_device_unregister_main_kobj(struct edac_device_ctl_info
  * Set of low-level instance attribute show functions
  */
 static ssize_t instance_ue_count_show(struct edac_device_instance *instance,
-				      char *data)
+				char *data)
 {
 	return sprintf(data, "%u\n", instance->counters.ue_count);
 }
 
 static ssize_t instance_ce_count_show(struct edac_device_instance *instance,
-				      char *data)
+				char *data)
 {
 	return sprintf(data, "%u\n", instance->counters.ce_count);
 }
@@ -298,7 +298,7 @@ struct instance_attribute {
 
 /* Function to 'show' fields from the edac_dev 'instance' structure */
 static ssize_t edac_dev_instance_show(struct kobject *kobj,
-				      struct attribute *attr, char *buffer)
+				struct attribute *attr, char *buffer)
 {
 	struct edac_device_instance *instance = to_instance(kobj);
 	struct instance_attribute *instance_attr = to_instance_attr(attr);
@@ -310,8 +310,8 @@ static ssize_t edac_dev_instance_show(struct kobject *kobj,
 
 /* Function to 'store' fields into the edac_dev 'instance' structure */
 static ssize_t edac_dev_instance_store(struct kobject *kobj,
-				       struct attribute *attr,
-				       const char *buffer, size_t count)
+				struct attribute *attr,
+				const char *buffer, size_t count)
 {
 	struct edac_device_instance *instance = to_instance(kobj);
 	struct instance_attribute *instance_attr = to_instance_attr(attr);
@@ -329,9 +329,9 @@ static struct sysfs_ops device_instance_ops = {
 
 #define INSTANCE_ATTR(_name,_mode,_show,_store)        \
 static struct instance_attribute attr_instance_##_name = {      \
-        .attr = {.name = __stringify(_name), .mode = _mode },   \
-        .show   = _show,                                        \
-        .store  = _store,                                       \
+	.attr = {.name = __stringify(_name), .mode = _mode },   \
+	.show   = _show,                                        \
+	.store  = _store,                                       \
 };
 
 /*
@@ -394,7 +394,7 @@ struct block_attribute {
 
 /* Function to 'show' fields from the edac_dev 'block' structure */
 static ssize_t edac_dev_block_show(struct kobject *kobj,
-				   struct attribute *attr, char *buffer)
+				struct attribute *attr, char *buffer)
 {
 	struct edac_device_block *block = to_block(kobj);
 	struct block_attribute *block_attr = to_block_attr(attr);
@@ -406,8 +406,8 @@ static ssize_t edac_dev_block_show(struct kobject *kobj,
 
 /* Function to 'store' fields into the edac_dev 'block' structure */
 static ssize_t edac_dev_block_store(struct kobject *kobj,
-				    struct attribute *attr,
-				    const char *buffer, size_t count)
+				struct attribute *attr,
+				const char *buffer, size_t count)
 {
 	struct edac_device_block *block = to_block(kobj);
 	struct block_attribute *block_attr = to_block_attr(attr);
@@ -425,9 +425,9 @@ static struct sysfs_ops device_block_ops = {
 
 #define BLOCK_ATTR(_name,_mode,_show,_store)        \
 static struct block_attribute attr_block_##_name = {                       \
-        .attr = {.name = __stringify(_name), .mode = _mode },   \
-        .show   = _show,                                        \
-        .store  = _store,                                       \
+	.attr = {.name = __stringify(_name), .mode = _mode },   \
+	.show   = _show,                                        \
+	.store  = _store,                                       \
 };
 
 BLOCK_ATTR(ce_count, S_IRUGO, block_ce_count_show, NULL);
@@ -453,8 +453,8 @@ static struct kobj_type ktype_block_ctrl = {
  * edac_device_create_block
  */
 static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
-				    struct edac_device_instance *instance,
-				    int idx)
+				struct edac_device_instance *instance,
+				int idx)
 {
 	int err;
 	struct edac_device_block *block;
@@ -487,8 +487,8 @@ static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
  * edac_device_delete_block(edac_dev,j);
  */
 static void edac_device_delete_block(struct edac_device_ctl_info *edac_dev,
-				     struct edac_device_instance *instance,
-				     int idx)
+				struct edac_device_instance *instance,
+				int idx)
 {
 	struct edac_device_block *block;
 
@@ -507,7 +507,7 @@ static void edac_device_delete_block(struct edac_device_ctl_info *edac_dev,
  *	create just one instance of an edac_device 'instance'
  */
 static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
-				       int idx)
+				int idx)
 {
 	int i, j;
 	int err;
@@ -627,22 +627,22 @@ static int edac_device_add_sysfs_attributes(
 			struct edac_device_ctl_info *edac_dev)
 {
 	int err;
-        struct edac_dev_sysfs_attribute *sysfs_attrib;
-
-        /* point to the start of the array and iterate over it
-         * adding each attribute listed to this mci instance's kobject
-         */
-        sysfs_attrib = edac_dev->sysfs_attributes;
-
-        while (sysfs_attrib->attr.name != NULL) {
-                err = sysfs_create_file(&edac_dev->kobj,
-                                        (struct attribute*) sysfs_attrib);
-                if (err) {
-                        return err;
-                }
-
-                sysfs_attrib++;
-        }
+	struct edac_dev_sysfs_attribute *sysfs_attrib;
+
+	/* point to the start of the array and iterate over it
+	 * adding each attribute listed to this mci instance's kobject
+	 */
+	sysfs_attrib = edac_dev->sysfs_attributes;
+
+	while (sysfs_attrib->attr.name != NULL) {
+		err = sysfs_create_file(&edac_dev->kobj,
+				(struct attribute*) sysfs_attrib);
+		if (err) {
+			return err;
+		}
+
+		sysfs_attrib++;
+	}
 
 	return 0;
 }

commit 42a8e397a80c277afb2aeb22232bc70114035bb1
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:10 2007 -0700

    drivers/edac: add device sysfs attributes
    
    Added new controls for the edac_device and edac_mc sysfs folder.
    These can be initialized by the low level driver to provide misc
    controls into the low level driver for its use
    
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 849d569dd2ce..32b2a8e53dc7 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -9,8 +9,6 @@
  *
  */
 
-#include <linux/module.h>
-#include <linux/sysdev.h>
 #include <linux/ctype.h>
 
 #include "edac_core.h"
@@ -621,6 +619,34 @@ static void edac_device_delete_instances(struct edac_device_ctl_info *edac_dev)
 
 /******************* edac_dev sysfs ctor/dtor  code *************/
 
+/*
+ * edac_device_add_sysfs_attributes
+ *	add some attributes to this instance's main kobject
+ */
+static int edac_device_add_sysfs_attributes(
+			struct edac_device_ctl_info *edac_dev)
+{
+	int err;
+        struct edac_dev_sysfs_attribute *sysfs_attrib;
+
+        /* point to the start of the array and iterate over it
+         * adding each attribute listed to this mci instance's kobject
+         */
+        sysfs_attrib = edac_dev->sysfs_attributes;
+
+        while (sysfs_attrib->attr.name != NULL) {
+                err = sysfs_create_file(&edac_dev->kobj,
+                                        (struct attribute*) sysfs_attrib);
+                if (err) {
+                        return err;
+                }
+
+                sysfs_attrib++;
+        }
+
+	return 0;
+}
+
 /*
  * edac_device_create_sysfs() Constructor
  *
@@ -642,6 +668,18 @@ int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
 
 	debugf0("%s() idx=%d\n", __func__, edac_dev->dev_idx);
 
+	/* If the low level driver requests some sysfs entries
+	 * then go create them here
+	 */
+	if (edac_dev->sysfs_attributes != NULL) {
+		err = edac_device_add_sysfs_attributes(edac_dev);
+		if (err) {
+			debugf0("%s() failed to add sysfs attribs\n",
+				__func__);
+			goto err_unreg_object;
+		}
+	}
+
 	/* create a symlink from the edac device
 	 * to the platform 'device' being used for this
 	 */
@@ -650,7 +688,7 @@ int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
 	if (err) {
 		debugf0("%s() sysfs_create_link() returned err= %d\n",
 			__func__, err);
-		return err;
+		goto err_unreg_object;
 	}
 
 	debugf0("%s() calling create-instances, idx=%d\n",
@@ -659,14 +697,17 @@ int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
 	/* Create the first level instance directories */
 	err = edac_device_create_instances(edac_dev);
 	if (err) {
-		goto error0;
+		goto err_remove_link;
 	}
 
 	return 0;
 
 	/* Error unwind stack */
+err_remove_link:
+	/* remove the sym link */
+	sysfs_remove_link(&edac_dev->kobj, EDAC_DEVICE_SYMLINK);
 
-      error0:
+err_unreg_object:
 	edac_device_unregister_main_kobj(edac_dev);
 
 	return err;

commit 542b25881a6ae1bf0804d4d39bf8b4d2cfc25e42
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:01 2007 -0700

    drivers/edac: edac_device sysfs cleanup
    
    Removal of some old dead and disabled code from the edac_device sysfs code
    
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index 69305e637810..849d569dd2ce 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -21,113 +21,6 @@
 #define to_edacdev(k) container_of(k, struct edac_device_ctl_info, kobj)
 #define to_edacdev_attr(a) container_of(a, struct edacdev_attribute, attr)
 
-#ifdef DKT
-
-static ssize_t edac_dev_ue_count_show(struct edac_device_ctl_info *edac_dev,
-				      char *data)
-{
-	return sprintf(data, "%d\n", edac_dev->ue_count);
-}
-
-static ssize_t edac_dev_ce_count_show(struct edac_device_ctl_info *edac_dev,
-				      char *data)
-{
-	return sprintf(data, "%d\n", edac_dev->ce_count);
-}
-
-static ssize_t edac_dev_seconds_show(struct edac_device_ctl_info *edac_dev,
-				     char *data)
-{
-	return sprintf(data, "%ld\n", (jiffies - edac_dev->start_time) / HZ);
-}
-
-static ssize_t edac_dev_ctl_name_show(struct edac_device_ctl_info *edac_dev,
-				      char *data)
-{
-	return sprintf(data, "%s\n", edac_dev->ctl_name);
-}
-
-struct edacdev_attribute {
-	struct attribute attr;
-	 ssize_t(*show) (struct edac_device_ctl_info *, char *);
-	 ssize_t(*store) (struct edac_device_ctl_info *, const char *, size_t);
-};
-
-/* EDAC DEVICE show/store functions for top most object */
-static ssize_t edacdev_show(struct kobject *kobj, struct attribute *attr,
-			    char *buffer)
-{
-	struct edac_device_ctl_info *edac_dev = to_edacdev(kobj);
-	struct edacdev_attribute *edacdev_attr = to_edacdev_attr(attr);
-
-	if (edacdev_attr->show)
-		return edacdev_attr->show(edac_dev, buffer);
-
-	return -EIO;
-}
-
-static ssize_t edacdev_store(struct kobject *kobj, struct attribute *attr,
-			     const char *buffer, size_t count)
-{
-	struct edac_device_ctl_info *edac_dev = to_edacdev(kobj);
-	struct edacdev_attribute *edacdev_attr = to_edacdev_attr(attr);
-
-	if (edacdev_attr->store)
-		return edacdev_attr->store(edac_dev, buffer, count);
-
-	return -EIO;
-}
-
-static struct sysfs_ops edac_dev_ops = {
-	.show = edacdev_show,
-	.store = edacdev_store
-};
-
-#define EDACDEV_ATTR(_name,_mode,_show,_store)			\
-static struct edacdev_attribute edac_dev_attr_##_name = {			\
-	.attr = {.name = __stringify(_name), .mode = _mode },	\
-	.show   = _show,					\
-	.store  = _store,					\
-};
-
-/* default Control file */
-EDACDEV_ATTR(reset_counters, S_IWUSR, NULL, edac_dev_reset_counters_store);
-
-/* default Attribute files */
-EDACDEV_ATTR(mc_name, S_IRUGO, edac_dev_ctl_name_show, NULL);
-EDACDEV_ATTR(seconds_since_reset, S_IRUGO, edac_dev_seconds_show, NULL);
-EDACDEV_ATTR(ue_count, S_IRUGO, edac_dev_ue_count_show, NULL);
-EDACDEV_ATTR(ce_count, S_IRUGO, edac_dev_ce_count_show, NULL);
-
-static struct edacdev_attribute *edacdev_attr[] = {
-	&edacdev_attr_reset_counters,
-	&edacdev_attr_mc_name,
-	&edacdev_attr_seconds_since_reset,
-	&edacdev_attr_ue_count,
-	&edacdev_attr_ce_count,
-	NULL
-};
-
-/*
- * Release of a Edac Device controlling instance
- */
-static void edac_dev_instance_release(struct kobject *kobj)
-{
-	struct edac_device_ctl_info *edac_dev;
-
-	edac_dev = to_edacdev(kobj);
-	debugf0("%s() idx=%d\n", __func__, edac_dev->dev_idx);
-	complete(&edac_dev->kobj_complete);
-}
-
-static struct kobj_type ktype_device = {
-	.release = edac_dev_instance_release,
-	.sysfs_ops = &edacdev_ops,
-	.default_attrs = (struct attribute **)edacdev_attr,
-};
-
-#endif
-
 /************************** edac_device sysfs code and data **************/
 
 /*

commit 079708b9173595bf74b31b14c36e946359ae6c7e
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:49:58 2007 -0700

    drivers/edac: core Lindent cleanup
    
    Run the EDAC CORE files through Lindent for cleanup
    
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Dave Jiang <djiang@mvista.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
index afb190502646..69305e637810 100644
--- a/drivers/edac/edac_device_sysfs.c
+++ b/drivers/edac/edac_device_sysfs.c
@@ -16,7 +16,6 @@
 #include "edac_core.h"
 #include "edac_module.h"
 
-
 #define EDAC_DEVICE_SYMLINK	"device"
 
 #define to_edacdev(k) container_of(k, struct edac_device_ctl_info, kobj)
@@ -25,43 +24,41 @@
 #ifdef DKT
 
 static ssize_t edac_dev_ue_count_show(struct edac_device_ctl_info *edac_dev,
-					char *data)
+				      char *data)
 {
-	return sprintf(data,"%d\n", edac_dev->ue_count);
+	return sprintf(data, "%d\n", edac_dev->ue_count);
 }
 
 static ssize_t edac_dev_ce_count_show(struct edac_device_ctl_info *edac_dev,
-					char *data)
+				      char *data)
 {
-	return sprintf(data,"%d\n", edac_dev->ce_count);
+	return sprintf(data, "%d\n", edac_dev->ce_count);
 }
 
 static ssize_t edac_dev_seconds_show(struct edac_device_ctl_info *edac_dev,
-					char *data)
+				     char *data)
 {
-	return sprintf(data,"%ld\n", (jiffies - edac_dev->start_time) / HZ);
+	return sprintf(data, "%ld\n", (jiffies - edac_dev->start_time) / HZ);
 }
 
 static ssize_t edac_dev_ctl_name_show(struct edac_device_ctl_info *edac_dev,
-					char *data)
+				      char *data)
 {
-	return sprintf(data,"%s\n", edac_dev->ctl_name);
+	return sprintf(data, "%s\n", edac_dev->ctl_name);
 }
 
-
 struct edacdev_attribute {
 	struct attribute attr;
-	ssize_t (*show)(struct edac_device_ctl_info *,char *);
-	ssize_t (*store)(struct edac_device_ctl_info *, const char *,size_t);
+	 ssize_t(*show) (struct edac_device_ctl_info *, char *);
+	 ssize_t(*store) (struct edac_device_ctl_info *, const char *, size_t);
 };
 
-
 /* EDAC DEVICE show/store functions for top most object */
 static ssize_t edacdev_show(struct kobject *kobj, struct attribute *attr,
-		char *buffer)
+			    char *buffer)
 {
 	struct edac_device_ctl_info *edac_dev = to_edacdev(kobj);
-	struct edacdev_attribute * edacdev_attr = to_edacdev_attr(attr);
+	struct edacdev_attribute *edacdev_attr = to_edacdev_attr(attr);
 
 	if (edacdev_attr->show)
 		return edacdev_attr->show(edac_dev, buffer);
@@ -70,10 +67,10 @@ static ssize_t edacdev_show(struct kobject *kobj, struct attribute *attr,
 }
 
 static ssize_t edacdev_store(struct kobject *kobj, struct attribute *attr,
-		const char *buffer, size_t count)
+			     const char *buffer, size_t count)
 {
 	struct edac_device_ctl_info *edac_dev = to_edacdev(kobj);
-	struct edacdev_attribute * edacdev_attr = to_edacdev_attr(attr);
+	struct edacdev_attribute *edacdev_attr = to_edacdev_attr(attr);
 
 	if (edacdev_attr->store)
 		return edacdev_attr->store(edac_dev, buffer, count);
@@ -94,14 +91,13 @@ static struct edacdev_attribute edac_dev_attr_##_name = {			\
 };
 
 /* default Control file */
-EDACDEV_ATTR(reset_counters,S_IWUSR,NULL,edac_dev_reset_counters_store);
+EDACDEV_ATTR(reset_counters, S_IWUSR, NULL, edac_dev_reset_counters_store);
 
 /* default Attribute files */
-EDACDEV_ATTR(mc_name,S_IRUGO,edac_dev_ctl_name_show,NULL);
-EDACDEV_ATTR(seconds_since_reset,S_IRUGO,edac_dev_seconds_show,NULL);
-EDACDEV_ATTR(ue_count,S_IRUGO,edac_dev_ue_count_show,NULL);
-EDACDEV_ATTR(ce_count,S_IRUGO,edac_dev_ce_count_show,NULL);
-
+EDACDEV_ATTR(mc_name, S_IRUGO, edac_dev_ctl_name_show, NULL);
+EDACDEV_ATTR(seconds_since_reset, S_IRUGO, edac_dev_seconds_show, NULL);
+EDACDEV_ATTR(ue_count, S_IRUGO, edac_dev_ue_count_show, NULL);
+EDACDEV_ATTR(ce_count, S_IRUGO, edac_dev_ce_count_show, NULL);
 
 static struct edacdev_attribute *edacdev_attr[] = {
 	&edacdev_attr_reset_counters,
@@ -127,7 +123,7 @@ static void edac_dev_instance_release(struct kobject *kobj)
 static struct kobj_type ktype_device = {
 	.release = edac_dev_instance_release,
 	.sysfs_ops = &edacdev_ops,
-	.default_attrs = (struct attribute **) edacdev_attr,
+	.default_attrs = (struct attribute **)edacdev_attr,
 };
 
 #endif
@@ -139,67 +135,66 @@ static struct kobj_type ktype_device = {
  */
 
 /* 'log_ue' */
-static ssize_t edac_device_ctl_log_ue_show(
-		struct edac_device_ctl_info *ctl_info, char *data)
+static ssize_t edac_device_ctl_log_ue_show(struct edac_device_ctl_info
+					   *ctl_info, char *data)
 {
-        return sprintf(data,"%u\n", ctl_info->log_ue);
+	return sprintf(data, "%u\n", ctl_info->log_ue);
 }
 
-static ssize_t edac_device_ctl_log_ue_store(
-		struct edac_device_ctl_info *ctl_info,
-			const char *data,size_t count)
+static ssize_t edac_device_ctl_log_ue_store(struct edac_device_ctl_info
+					    *ctl_info, const char *data,
+					    size_t count)
 {
 	/* if parameter is zero, turn off flag, if non-zero turn on flag */
-	ctl_info->log_ue = (simple_strtoul(data,NULL,0) != 0);
+	ctl_info->log_ue = (simple_strtoul(data, NULL, 0) != 0);
 
-        return count;
+	return count;
 }
 
 /* 'log_ce' */
-static ssize_t edac_device_ctl_log_ce_show(
-		struct edac_device_ctl_info *ctl_info,char *data)
+static ssize_t edac_device_ctl_log_ce_show(struct edac_device_ctl_info
+					   *ctl_info, char *data)
 {
-        return sprintf(data,"%u\n", ctl_info->log_ce);
+	return sprintf(data, "%u\n", ctl_info->log_ce);
 }
 
-static ssize_t edac_device_ctl_log_ce_store(
-		struct edac_device_ctl_info *ctl_info,
-			const char *data,size_t count)
+static ssize_t edac_device_ctl_log_ce_store(struct edac_device_ctl_info
+					    *ctl_info, const char *data,
+					    size_t count)
 {
 	/* if parameter is zero, turn off flag, if non-zero turn on flag */
-	ctl_info->log_ce = (simple_strtoul(data,NULL,0) != 0);
+	ctl_info->log_ce = (simple_strtoul(data, NULL, 0) != 0);
 
-        return count;
+	return count;
 }
 
-
 /* 'panic_on_ue' */
-static ssize_t edac_device_ctl_panic_on_ue_show(
-		struct edac_device_ctl_info *ctl_info, char *data)
+static ssize_t edac_device_ctl_panic_on_ue_show(struct edac_device_ctl_info
+						*ctl_info, char *data)
 {
-        return sprintf(data,"%u\n", ctl_info->panic_on_ue);
+	return sprintf(data, "%u\n", ctl_info->panic_on_ue);
 }
 
-static ssize_t edac_device_ctl_panic_on_ue_store(
-		struct edac_device_ctl_info *ctl_info,
-			const char *data,size_t count)
+static ssize_t edac_device_ctl_panic_on_ue_store(struct edac_device_ctl_info
+						 *ctl_info, const char *data,
+						 size_t count)
 {
 	/* if parameter is zero, turn off flag, if non-zero turn on flag */
-	ctl_info->panic_on_ue = (simple_strtoul(data,NULL,0) != 0);
+	ctl_info->panic_on_ue = (simple_strtoul(data, NULL, 0) != 0);
 
 	return count;
 }
 
 /* 'poll_msec' show and store functions*/
-static ssize_t edac_device_ctl_poll_msec_show(
-		struct edac_device_ctl_info *ctl_info, char *data)
+static ssize_t edac_device_ctl_poll_msec_show(struct edac_device_ctl_info
+					      *ctl_info, char *data)
 {
-        return sprintf(data,"%u\n", ctl_info->poll_msec);
+	return sprintf(data, "%u\n", ctl_info->poll_msec);
 }
 
-static ssize_t edac_device_ctl_poll_msec_store(
-		struct edac_device_ctl_info *ctl_info,
-		const char *data,size_t count)
+static ssize_t edac_device_ctl_poll_msec_store(struct edac_device_ctl_info
+					       *ctl_info, const char *data,
+					       size_t count)
 {
 	unsigned long value;
 
@@ -208,18 +203,17 @@ static ssize_t edac_device_ctl_poll_msec_store(
 	 * Then cancel last outstanding delay for the work request
 	 * and set a new one.
 	 */
-	value = simple_strtoul(data,NULL,0);
-	edac_device_reset_delay_period(ctl_info,value);
+	value = simple_strtoul(data, NULL, 0);
+	edac_device_reset_delay_period(ctl_info, value);
 
-        return count;
+	return count;
 }
 
-
 /* edac_device_ctl_info specific attribute structure */
 struct ctl_info_attribute {
-        struct attribute attr;
-        ssize_t (*show)(struct edac_device_ctl_info *,char *);
-        ssize_t (*store)(struct edac_device_ctl_info *,const char *,size_t);
+	struct attribute attr;
+	 ssize_t(*show) (struct edac_device_ctl_info *, char *);
+	 ssize_t(*store) (struct edac_device_ctl_info *, const char *, size_t);
 };
 
 #define to_ctl_info(k) container_of(k, struct edac_device_ctl_info, kobj)
@@ -227,34 +221,33 @@ struct ctl_info_attribute {
 
 /* Function to 'show' fields from the edac_dev 'ctl_info' structure */
 static ssize_t edac_dev_ctl_info_show(struct kobject *kobj,
-                        struct attribute *attr,
-                        char *buffer)
+				      struct attribute *attr, char *buffer)
 {
-        struct edac_device_ctl_info *edac_dev = to_ctl_info(kobj);
-        struct ctl_info_attribute *ctl_info_attr = to_ctl_info_attr(attr);
+	struct edac_device_ctl_info *edac_dev = to_ctl_info(kobj);
+	struct ctl_info_attribute *ctl_info_attr = to_ctl_info_attr(attr);
 
-        if (ctl_info_attr->show)
-                return ctl_info_attr->show(edac_dev,buffer);
-        return -EIO;
+	if (ctl_info_attr->show)
+		return ctl_info_attr->show(edac_dev, buffer);
+	return -EIO;
 }
 
 /* Function to 'store' fields into the edac_dev 'ctl_info' structure */
 static ssize_t edac_dev_ctl_info_store(struct kobject *kobj,
-                        struct attribute *attr,
-                	const char *buffer, size_t count)
+				       struct attribute *attr,
+				       const char *buffer, size_t count)
 {
-        struct edac_device_ctl_info *edac_dev = to_ctl_info(kobj);
-        struct ctl_info_attribute *ctl_info_attr = to_ctl_info_attr(attr);
+	struct edac_device_ctl_info *edac_dev = to_ctl_info(kobj);
+	struct ctl_info_attribute *ctl_info_attr = to_ctl_info_attr(attr);
 
-        if (ctl_info_attr->store)
-                return ctl_info_attr->store(edac_dev, buffer, count);
-        return -EIO;
+	if (ctl_info_attr->store)
+		return ctl_info_attr->store(edac_dev, buffer, count);
+	return -EIO;
 }
 
 /* edac_dev file operations for an 'ctl_info' */
 static struct sysfs_ops device_ctl_info_ops = {
-	.show   = edac_dev_ctl_info_show,
-	.store  = edac_dev_ctl_info_store
+	.show = edac_dev_ctl_info_show,
+	.store = edac_dev_ctl_info_store
 };
 
 #define CTL_INFO_ATTR(_name,_mode,_show,_store)        \
@@ -264,21 +257,16 @@ static struct ctl_info_attribute attr_ctl_info_##_name = {      \
         .store  = _store,                                       \
 };
 
-
 /* Declare the various ctl_info attributes here and their respective ops */
-CTL_INFO_ATTR(log_ue,S_IRUGO|S_IWUSR,
-		edac_device_ctl_log_ue_show,
-		edac_device_ctl_log_ue_store);
-CTL_INFO_ATTR(log_ce,S_IRUGO|S_IWUSR,
-		edac_device_ctl_log_ce_show,
-		edac_device_ctl_log_ce_store);
-CTL_INFO_ATTR(panic_on_ue,S_IRUGO|S_IWUSR,
-		edac_device_ctl_panic_on_ue_show,
-		edac_device_ctl_panic_on_ue_store);
-CTL_INFO_ATTR(poll_msec,S_IRUGO|S_IWUSR,
-		edac_device_ctl_poll_msec_show,
-		edac_device_ctl_poll_msec_store);
-
+CTL_INFO_ATTR(log_ue, S_IRUGO | S_IWUSR,
+	      edac_device_ctl_log_ue_show, edac_device_ctl_log_ue_store);
+CTL_INFO_ATTR(log_ce, S_IRUGO | S_IWUSR,
+	      edac_device_ctl_log_ce_show, edac_device_ctl_log_ce_store);
+CTL_INFO_ATTR(panic_on_ue, S_IRUGO | S_IWUSR,
+	      edac_device_ctl_panic_on_ue_show,
+	      edac_device_ctl_panic_on_ue_store);
+CTL_INFO_ATTR(poll_msec, S_IRUGO | S_IWUSR,
+	      edac_device_ctl_poll_msec_show, edac_device_ctl_poll_msec_store);
 
 /* Base Attributes of the EDAC_DEVICE ECC object */
 static struct ctl_info_attribute *device_ctrl_attr[] = {
@@ -303,10 +291,9 @@ static void edac_device_ctrl_master_release(struct kobject *kobj)
 static struct kobj_type ktype_device_ctrl = {
 	.release = edac_device_ctrl_master_release,
 	.sysfs_ops = &device_ctl_info_ops,
-	.default_attrs = (struct attribute **) device_ctrl_attr,
+	.default_attrs = (struct attribute **)device_ctrl_attr,
 };
 
-
 /**************** edac_device main kobj ctor/dtor code *********************/
 
 /*
@@ -317,41 +304,39 @@ static struct kobj_type ktype_device_ctrl = {
  * Return:  0 SUCCESS
  *         !0 FAILURE
  */
-static int edac_device_register_main_kobj(
-		struct edac_device_ctl_info *edac_dev)
+static int edac_device_register_main_kobj(struct edac_device_ctl_info *edac_dev)
 {
 	int err = 0;
 	struct sysdev_class *edac_class;
 
 	debugf1("%s()\n", __func__);
 
-        /* get the /sys/devices/system/edac reference */
-        edac_class = edac_get_edac_class();
-        if (edac_class == NULL) {
-                debugf1("%s() no edac_class error=%d\n", __func__, err);
-                return err;
-        }
+	/* get the /sys/devices/system/edac reference */
+	edac_class = edac_get_edac_class();
+	if (edac_class == NULL) {
+		debugf1("%s() no edac_class error=%d\n", __func__, err);
+		return err;
+	}
 
 	/* Point to the 'edac_class' this instance 'reports' to */
 	edac_dev->edac_class = edac_class;
 
 	/* Init the devices's kobject */
-	memset(&edac_dev->kobj, 0, sizeof (struct kobject));
+	memset(&edac_dev->kobj, 0, sizeof(struct kobject));
 	edac_dev->kobj.ktype = &ktype_device_ctrl;
 
 	/* set this new device under the edac_class kobject */
 	edac_dev->kobj.parent = &edac_class->kset.kobj;
 
 	/* generate sysfs "..../edac/<name>"   */
-	debugf1("%s() set name of kobject to: %s\n",
-		__func__, edac_dev->name);
-	err = kobject_set_name(&edac_dev->kobj,"%s",edac_dev->name);
+	debugf1("%s() set name of kobject to: %s\n", __func__, edac_dev->name);
+	err = kobject_set_name(&edac_dev->kobj, "%s", edac_dev->name);
 	if (err)
 		return err;
 	err = kobject_register(&edac_dev->kobj);
 	if (err) {
 		debugf1("%s()Failed to register '.../edac/%s'\n",
-			__func__,edac_dev->name);
+			__func__, edac_dev->name);
 		return err;
 	}
 
@@ -365,8 +350,8 @@ static int edac_device_register_main_kobj(
  * edac_device_unregister_main_kobj:
  *	the '..../edac/<name>' kobject
  */
-static void edac_device_unregister_main_kobj(
-			struct edac_device_ctl_info *edac_dev)
+static void edac_device_unregister_main_kobj(struct edac_device_ctl_info
+					     *edac_dev)
 {
 	debugf0("%s()\n", __func__);
 	debugf1("%s() name of kobject is: %s\n",
@@ -382,26 +367,23 @@ static void edac_device_unregister_main_kobj(
 	wait_for_completion(&edac_dev->kobj_complete);
 }
 
-
 /*************** edac_dev -> instance information ***********/
 
 /*
  * Set of low-level instance attribute show functions
  */
-static ssize_t instance_ue_count_show(
-		struct edac_device_instance *instance, char *data)
+static ssize_t instance_ue_count_show(struct edac_device_instance *instance,
+				      char *data)
 {
-        return sprintf(data,"%u\n", instance->counters.ue_count);
+	return sprintf(data, "%u\n", instance->counters.ue_count);
 }
 
-static ssize_t instance_ce_count_show(
-		struct edac_device_instance *instance, char *data)
+static ssize_t instance_ce_count_show(struct edac_device_instance *instance,
+				      char *data)
 {
-        return sprintf(data,"%u\n", instance->counters.ce_count);
+	return sprintf(data, "%u\n", instance->counters.ce_count);
 }
 
-
-
 #define to_instance(k) container_of(k, struct edac_device_instance, kobj)
 #define to_instance_attr(a) container_of(a,struct instance_attribute,attr)
 
@@ -416,48 +398,42 @@ static void edac_device_ctrl_instance_release(struct kobject *kobj)
 	complete(&instance->kobj_complete);
 }
 
-
 /* instance specific attribute structure */
 struct instance_attribute {
-        struct attribute attr;
-        ssize_t (*show)(struct edac_device_instance *,char *);
-        ssize_t (*store)(struct edac_device_instance *,const char *,size_t);
+	struct attribute attr;
+	 ssize_t(*show) (struct edac_device_instance *, char *);
+	 ssize_t(*store) (struct edac_device_instance *, const char *, size_t);
 };
 
-
 /* Function to 'show' fields from the edac_dev 'instance' structure */
 static ssize_t edac_dev_instance_show(struct kobject *kobj,
-                        struct attribute *attr,
-                        char *buffer)
+				      struct attribute *attr, char *buffer)
 {
-        struct edac_device_instance *instance = to_instance(kobj);
-        struct instance_attribute *instance_attr = to_instance_attr(attr);
+	struct edac_device_instance *instance = to_instance(kobj);
+	struct instance_attribute *instance_attr = to_instance_attr(attr);
 
-        if (instance_attr->show)
-                return instance_attr->show(instance,buffer);
-        return -EIO;
+	if (instance_attr->show)
+		return instance_attr->show(instance, buffer);
+	return -EIO;
 }
 
-
 /* Function to 'store' fields into the edac_dev 'instance' structure */
 static ssize_t edac_dev_instance_store(struct kobject *kobj,
-                        struct attribute *attr,
-                	const char *buffer, size_t count)
+				       struct attribute *attr,
+				       const char *buffer, size_t count)
 {
-        struct edac_device_instance *instance = to_instance(kobj);
-        struct instance_attribute *instance_attr = to_instance_attr(attr);
+	struct edac_device_instance *instance = to_instance(kobj);
+	struct instance_attribute *instance_attr = to_instance_attr(attr);
 
-        if (instance_attr->store)
-                return instance_attr->store(instance, buffer, count);
-        return -EIO;
+	if (instance_attr->store)
+		return instance_attr->store(instance, buffer, count);
+	return -EIO;
 }
 
-
-
 /* edac_dev file operations for an 'instance' */
 static struct sysfs_ops device_instance_ops = {
-	.show   = edac_dev_instance_show,
-	.store  = edac_dev_instance_store
+	.show = edac_dev_instance_show,
+	.store = edac_dev_instance_store
 };
 
 #define INSTANCE_ATTR(_name,_mode,_show,_store)        \
@@ -472,8 +448,8 @@ static struct instance_attribute attr_instance_##_name = {      \
  *	Each contains a pointer to a show and an optional set
  *	function pointer that does the low level output/input
  */
-INSTANCE_ATTR(ce_count,S_IRUGO,instance_ce_count_show,NULL);
-INSTANCE_ATTR(ue_count,S_IRUGO,instance_ue_count_show,NULL);
+INSTANCE_ATTR(ce_count, S_IRUGO, instance_ce_count_show, NULL);
+INSTANCE_ATTR(ue_count, S_IRUGO, instance_ue_count_show, NULL);
 
 /* list of edac_dev 'instance' attributes */
 static struct instance_attribute *device_instance_attr[] = {
@@ -486,29 +462,24 @@ static struct instance_attribute *device_instance_attr[] = {
 static struct kobj_type ktype_instance_ctrl = {
 	.release = edac_device_ctrl_instance_release,
 	.sysfs_ops = &device_instance_ops,
-	.default_attrs = (struct attribute **) device_instance_attr,
+	.default_attrs = (struct attribute **)device_instance_attr,
 };
 
-
 /*************** edac_dev -> instance -> block information *********/
 
 /*
  * Set of low-level block attribute show functions
  */
-static ssize_t block_ue_count_show(
-		struct edac_device_block *block, char *data)
+static ssize_t block_ue_count_show(struct edac_device_block *block, char *data)
 {
-        return sprintf(data,"%u\n", block->counters.ue_count);
+	return sprintf(data, "%u\n", block->counters.ue_count);
 }
 
-static ssize_t block_ce_count_show(
-		struct edac_device_block *block, char *data)
+static ssize_t block_ce_count_show(struct edac_device_block *block, char *data)
 {
-        return sprintf(data,"%u\n", block->counters.ce_count);
+	return sprintf(data, "%u\n", block->counters.ce_count);
 }
 
-
-
 #define to_block(k) container_of(k, struct edac_device_block, kobj)
 #define to_block_attr(a) container_of(a,struct block_attribute,attr)
 
@@ -525,46 +496,42 @@ static void edac_device_ctrl_block_release(struct kobject *kobj)
 
 /* block specific attribute structure */
 struct block_attribute {
-        struct attribute attr;
-        ssize_t (*show)(struct edac_device_block *,char *);
-        ssize_t (*store)(struct edac_device_block *,const char *,size_t);
+	struct attribute attr;
+	 ssize_t(*show) (struct edac_device_block *, char *);
+	 ssize_t(*store) (struct edac_device_block *, const char *, size_t);
 };
 
 /* Function to 'show' fields from the edac_dev 'block' structure */
 static ssize_t edac_dev_block_show(struct kobject *kobj,
-                        struct attribute *attr,
-                        char *buffer)
+				   struct attribute *attr, char *buffer)
 {
-        struct edac_device_block *block = to_block(kobj);
-        struct block_attribute *block_attr = to_block_attr(attr);
+	struct edac_device_block *block = to_block(kobj);
+	struct block_attribute *block_attr = to_block_attr(attr);
 
-        if (block_attr->show)
-                return block_attr->show(block,buffer);
-        return -EIO;
+	if (block_attr->show)
+		return block_attr->show(block, buffer);
+	return -EIO;
 }
 
-
 /* Function to 'store' fields into the edac_dev 'block' structure */
 static ssize_t edac_dev_block_store(struct kobject *kobj,
-                        struct attribute *attr,
-                	const char *buffer, size_t count)
+				    struct attribute *attr,
+				    const char *buffer, size_t count)
 {
-        struct edac_device_block *block = to_block(kobj);
-        struct block_attribute *block_attr = to_block_attr(attr);
+	struct edac_device_block *block = to_block(kobj);
+	struct block_attribute *block_attr = to_block_attr(attr);
 
-        if (block_attr->store)
-                return block_attr->store(block, buffer, count);
-        return -EIO;
+	if (block_attr->store)
+		return block_attr->store(block, buffer, count);
+	return -EIO;
 }
 
-
 /* edac_dev file operations for a 'block' */
 static struct sysfs_ops device_block_ops = {
-	.show   = edac_dev_block_show,
-	.store  = edac_dev_block_store
+	.show = edac_dev_block_show,
+	.store = edac_dev_block_store
 };
 
-
 #define BLOCK_ATTR(_name,_mode,_show,_store)        \
 static struct block_attribute attr_block_##_name = {                       \
         .attr = {.name = __stringify(_name), .mode = _mode },   \
@@ -572,9 +539,8 @@ static struct block_attribute attr_block_##_name = {                       \
         .store  = _store,                                       \
 };
 
-BLOCK_ATTR(ce_count,S_IRUGO,block_ce_count_show,NULL);
-BLOCK_ATTR(ue_count,S_IRUGO,block_ue_count_show,NULL);
-
+BLOCK_ATTR(ce_count, S_IRUGO, block_ce_count_show, NULL);
+BLOCK_ATTR(ue_count, S_IRUGO, block_ue_count_show, NULL);
 
 /* list of edac_dev 'block' attributes */
 static struct block_attribute *device_block_attr[] = {
@@ -587,19 +553,17 @@ static struct block_attribute *device_block_attr[] = {
 static struct kobj_type ktype_block_ctrl = {
 	.release = edac_device_ctrl_block_release,
 	.sysfs_ops = &device_block_ops,
-	.default_attrs = (struct attribute **) device_block_attr,
+	.default_attrs = (struct attribute **)device_block_attr,
 };
 
-
 /************** block ctor/dtor  code ************/
 
 /*
  * edac_device_create_block
  */
-static int edac_device_create_block(
-		struct edac_device_ctl_info *edac_dev,
-		struct edac_device_instance *instance,
-		int idx)
+static int edac_device_create_block(struct edac_device_ctl_info *edac_dev,
+				    struct edac_device_instance *instance,
+				    int idx)
 {
 	int err;
 	struct edac_device_block *block;
@@ -607,21 +571,21 @@ static int edac_device_create_block(
 	block = &instance->blocks[idx];
 
 	debugf1("%s() Instance '%s' block[%d] '%s'\n",
-		__func__,instance->name, idx, block->name);
+		__func__, instance->name, idx, block->name);
 
 	/* init this block's kobject */
-	memset(&block->kobj, 0, sizeof (struct kobject));
+	memset(&block->kobj, 0, sizeof(struct kobject));
 	block->kobj.parent = &instance->kobj;
 	block->kobj.ktype = &ktype_block_ctrl;
 
-	err = kobject_set_name(&block->kobj,"%s",block->name);
+	err = kobject_set_name(&block->kobj, "%s", block->name);
 	if (err)
 		return err;
 
 	err = kobject_register(&block->kobj);
 	if (err) {
 		debugf1("%s()Failed to register instance '%s'\n",
-			__func__,block->name);
+			__func__, block->name);
 		return err;
 	}
 
@@ -631,10 +595,9 @@ static int edac_device_create_block(
 /*
  * edac_device_delete_block(edac_dev,j);
  */
-static void edac_device_delete_block(
-		struct edac_device_ctl_info *edac_dev,
-		struct edac_device_instance *instance,
-		int idx)
+static void edac_device_delete_block(struct edac_device_ctl_info *edac_dev,
+				     struct edac_device_instance *instance,
+				     int idx)
 {
 	struct edac_device_block *block;
 
@@ -652,8 +615,8 @@ static void edac_device_delete_block(
  * edac_device_create_instance
  *	create just one instance of an edac_device 'instance'
  */
-static int edac_device_create_instance(
-		struct edac_device_ctl_info *edac_dev, int idx)
+static int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,
+				       int idx)
 {
 	int i, j;
 	int err;
@@ -662,32 +625,32 @@ static int edac_device_create_instance(
 	instance = &edac_dev->instances[idx];
 
 	/* Init the instance's kobject */
-	memset(&instance->kobj, 0, sizeof (struct kobject));
+	memset(&instance->kobj, 0, sizeof(struct kobject));
 
 	/* set this new device under the edac_device main kobject */
 	instance->kobj.parent = &edac_dev->kobj;
 	instance->kobj.ktype = &ktype_instance_ctrl;
 
-	err = kobject_set_name(&instance->kobj,"%s",instance->name);
+	err = kobject_set_name(&instance->kobj, "%s", instance->name);
 	if (err)
 		return err;
 
 	err = kobject_register(&instance->kobj);
 	if (err != 0) {
 		debugf2("%s() Failed to register instance '%s'\n",
-			__func__,instance->name);
+			__func__, instance->name);
 		return err;
 	}
 
 	debugf1("%s() now register '%d' blocks for instance %d\n",
-			__func__,instance->nr_blocks,idx);
+		__func__, instance->nr_blocks, idx);
 
 	/* register all blocks of this instance */
-	for (i = 0; i < instance->nr_blocks; i++ ) {
-		err = edac_device_create_block(edac_dev,instance,i);
+	for (i = 0; i < instance->nr_blocks; i++) {
+		err = edac_device_create_block(edac_dev, instance, i);
 		if (err) {
 			for (j = 0; j < i; j++) {
-				edac_device_delete_block(edac_dev,instance,j);
+				edac_device_delete_block(edac_dev, instance, j);
 			}
 			return err;
 		}
@@ -703,8 +666,8 @@ static int edac_device_create_instance(
  * edac_device_remove_instance
  *	remove an edac_device instance
  */
-static void edac_device_delete_instance(
-		struct edac_device_ctl_info *edac_dev, int idx)
+static void edac_device_delete_instance(struct edac_device_ctl_info *edac_dev,
+					int idx)
 {
 	int i;
 	struct edac_device_instance *instance;
@@ -713,7 +676,7 @@ static void edac_device_delete_instance(
 
 	/* unregister all blocks in this instance */
 	for (i = 0; i < instance->nr_blocks; i++) {
-		edac_device_delete_block(edac_dev,instance,i);
+		edac_device_delete_block(edac_dev, instance, i);
 	}
 
 	/* unregister this instance's kobject */
@@ -735,12 +698,12 @@ static int edac_device_create_instances(struct edac_device_ctl_info *edac_dev)
 	debugf0("%s()\n", __func__);
 
 	/* iterate over creation of the instances */
-	for (i = 0; i < edac_dev->nr_instances; i++ ) {
-		err = edac_device_create_instance(edac_dev,i);
+	for (i = 0; i < edac_dev->nr_instances; i++) {
+		err = edac_device_create_instance(edac_dev, i);
 		if (err) {
 			/* unwind previous instances on error */
 			for (j = 0; j < i; j++) {
-				edac_device_delete_instance(edac_dev,j);
+				edac_device_delete_instance(edac_dev, j);
 			}
 			return err;
 		}
@@ -758,8 +721,8 @@ static void edac_device_delete_instances(struct edac_device_ctl_info *edac_dev)
 	int i;
 
 	/* iterate over creation of the instances */
-	for (i = 0; i < edac_dev->nr_instances; i++ ) {
-		edac_device_delete_instance(edac_dev,i);
+	for (i = 0; i < edac_dev->nr_instances; i++) {
+		edac_device_delete_instance(edac_dev, i);
 	}
 }
 
@@ -777,7 +740,7 @@ static void edac_device_delete_instances(struct edac_device_ctl_info *edac_dev)
 int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
 {
 	int err;
-	struct kobject *edac_kobj=&edac_dev->kobj;
+	struct kobject *edac_kobj = &edac_dev->kobj;
 
 	/* register this instance's main kobj with the edac class kobj */
 	err = edac_device_register_main_kobj(edac_dev);
@@ -790,8 +753,7 @@ int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
 	 * to the platform 'device' being used for this
 	 */
 	err = sysfs_create_link(edac_kobj,
-				&edac_dev->dev->kobj,
-				EDAC_DEVICE_SYMLINK);
+				&edac_dev->dev->kobj, EDAC_DEVICE_SYMLINK);
 	if (err) {
 		debugf0("%s() sysfs_create_link() returned err= %d\n",
 			__func__, err);
@@ -811,7 +773,7 @@ int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
 
 	/* Error unwind stack */
 
-error0:
+      error0:
 	edac_device_unregister_main_kobj(edac_dev);
 
 	return err;
@@ -834,4 +796,3 @@ void edac_device_remove_sysfs(struct edac_device_ctl_info *edac_dev)
 	/* unregister the instance's main kobj */
 	edac_device_unregister_main_kobj(edac_dev);
 }
-

commit e27e3dac651771fe3250f6305dee277bce29fc5d
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:49:36 2007 -0700

    drivers/edac: add edac_device class
    
    This patch adds the new 'class' of object to be managed, named: 'edac_device'.
    
    As a peer of the 'edac_mc' class of object, it provides a non-memory centric
    view of an ERROR DETECTING device in hardware. It provides a sysfs interface
    and an abstraction for varioius EDAC type devices.
    
    Multiple 'instances' within the class are possible, with each 'instance'
    able to have multiple 'blocks', and each 'block' having 'attributes'.
    
    At the 'block' level there are the 'ce_count' and 'ue_count' fields
    which the device driver can update and/or call edac_device_handle_XX()
    functions. At each higher level are additional 'total' count fields,
    which are a summation of counts below that level.
    
    This 'edac_device' has been used to capture and present ECC errors
    which are found in a a L1 and L2 system on a per CORE/CPU basis.
    
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device_sysfs.c b/drivers/edac/edac_device_sysfs.c
new file mode 100644
index 000000000000..afb190502646
--- /dev/null
+++ b/drivers/edac/edac_device_sysfs.c
@@ -0,0 +1,837 @@
+/*
+ * file for managing the edac_device class of devices for EDAC
+ *
+ * (C) 2007 SoftwareBitMaker(http://www.softwarebitmaker.com)
+ * This file may be distributed under the terms of the
+ * GNU General Public License.
+ *
+ * Written Doug Thompson <norsk5@xmission.com>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/sysdev.h>
+#include <linux/ctype.h>
+
+#include "edac_core.h"
+#include "edac_module.h"
+
+
+#define EDAC_DEVICE_SYMLINK	"device"
+
+#define to_edacdev(k) container_of(k, struct edac_device_ctl_info, kobj)
+#define to_edacdev_attr(a) container_of(a, struct edacdev_attribute, attr)
+
+#ifdef DKT
+
+static ssize_t edac_dev_ue_count_show(struct edac_device_ctl_info *edac_dev,
+					char *data)
+{
+	return sprintf(data,"%d\n", edac_dev->ue_count);
+}
+
+static ssize_t edac_dev_ce_count_show(struct edac_device_ctl_info *edac_dev,
+					char *data)
+{
+	return sprintf(data,"%d\n", edac_dev->ce_count);
+}
+
+static ssize_t edac_dev_seconds_show(struct edac_device_ctl_info *edac_dev,
+					char *data)
+{
+	return sprintf(data,"%ld\n", (jiffies - edac_dev->start_time) / HZ);
+}
+
+static ssize_t edac_dev_ctl_name_show(struct edac_device_ctl_info *edac_dev,
+					char *data)
+{
+	return sprintf(data,"%s\n", edac_dev->ctl_name);
+}
+
+
+struct edacdev_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct edac_device_ctl_info *,char *);
+	ssize_t (*store)(struct edac_device_ctl_info *, const char *,size_t);
+};
+
+
+/* EDAC DEVICE show/store functions for top most object */
+static ssize_t edacdev_show(struct kobject *kobj, struct attribute *attr,
+		char *buffer)
+{
+	struct edac_device_ctl_info *edac_dev = to_edacdev(kobj);
+	struct edacdev_attribute * edacdev_attr = to_edacdev_attr(attr);
+
+	if (edacdev_attr->show)
+		return edacdev_attr->show(edac_dev, buffer);
+
+	return -EIO;
+}
+
+static ssize_t edacdev_store(struct kobject *kobj, struct attribute *attr,
+		const char *buffer, size_t count)
+{
+	struct edac_device_ctl_info *edac_dev = to_edacdev(kobj);
+	struct edacdev_attribute * edacdev_attr = to_edacdev_attr(attr);
+
+	if (edacdev_attr->store)
+		return edacdev_attr->store(edac_dev, buffer, count);
+
+	return -EIO;
+}
+
+static struct sysfs_ops edac_dev_ops = {
+	.show = edacdev_show,
+	.store = edacdev_store
+};
+
+#define EDACDEV_ATTR(_name,_mode,_show,_store)			\
+static struct edacdev_attribute edac_dev_attr_##_name = {			\
+	.attr = {.name = __stringify(_name), .mode = _mode },	\
+	.show   = _show,					\
+	.store  = _store,					\
+};
+
+/* default Control file */
+EDACDEV_ATTR(reset_counters,S_IWUSR,NULL,edac_dev_reset_counters_store);
+
+/* default Attribute files */
+EDACDEV_ATTR(mc_name,S_IRUGO,edac_dev_ctl_name_show,NULL);
+EDACDEV_ATTR(seconds_since_reset,S_IRUGO,edac_dev_seconds_show,NULL);
+EDACDEV_ATTR(ue_count,S_IRUGO,edac_dev_ue_count_show,NULL);
+EDACDEV_ATTR(ce_count,S_IRUGO,edac_dev_ce_count_show,NULL);
+
+
+static struct edacdev_attribute *edacdev_attr[] = {
+	&edacdev_attr_reset_counters,
+	&edacdev_attr_mc_name,
+	&edacdev_attr_seconds_since_reset,
+	&edacdev_attr_ue_count,
+	&edacdev_attr_ce_count,
+	NULL
+};
+
+/*
+ * Release of a Edac Device controlling instance
+ */
+static void edac_dev_instance_release(struct kobject *kobj)
+{
+	struct edac_device_ctl_info *edac_dev;
+
+	edac_dev = to_edacdev(kobj);
+	debugf0("%s() idx=%d\n", __func__, edac_dev->dev_idx);
+	complete(&edac_dev->kobj_complete);
+}
+
+static struct kobj_type ktype_device = {
+	.release = edac_dev_instance_release,
+	.sysfs_ops = &edacdev_ops,
+	.default_attrs = (struct attribute **) edacdev_attr,
+};
+
+#endif
+
+/************************** edac_device sysfs code and data **************/
+
+/*
+ * Set of edac_device_ctl_info attribute store/show functions
+ */
+
+/* 'log_ue' */
+static ssize_t edac_device_ctl_log_ue_show(
+		struct edac_device_ctl_info *ctl_info, char *data)
+{
+        return sprintf(data,"%u\n", ctl_info->log_ue);
+}
+
+static ssize_t edac_device_ctl_log_ue_store(
+		struct edac_device_ctl_info *ctl_info,
+			const char *data,size_t count)
+{
+	/* if parameter is zero, turn off flag, if non-zero turn on flag */
+	ctl_info->log_ue = (simple_strtoul(data,NULL,0) != 0);
+
+        return count;
+}
+
+/* 'log_ce' */
+static ssize_t edac_device_ctl_log_ce_show(
+		struct edac_device_ctl_info *ctl_info,char *data)
+{
+        return sprintf(data,"%u\n", ctl_info->log_ce);
+}
+
+static ssize_t edac_device_ctl_log_ce_store(
+		struct edac_device_ctl_info *ctl_info,
+			const char *data,size_t count)
+{
+	/* if parameter is zero, turn off flag, if non-zero turn on flag */
+	ctl_info->log_ce = (simple_strtoul(data,NULL,0) != 0);
+
+        return count;
+}
+
+
+/* 'panic_on_ue' */
+static ssize_t edac_device_ctl_panic_on_ue_show(
+		struct edac_device_ctl_info *ctl_info, char *data)
+{
+        return sprintf(data,"%u\n", ctl_info->panic_on_ue);
+}
+
+static ssize_t edac_device_ctl_panic_on_ue_store(
+		struct edac_device_ctl_info *ctl_info,
+			const char *data,size_t count)
+{
+	/* if parameter is zero, turn off flag, if non-zero turn on flag */
+	ctl_info->panic_on_ue = (simple_strtoul(data,NULL,0) != 0);
+
+	return count;
+}
+
+/* 'poll_msec' show and store functions*/
+static ssize_t edac_device_ctl_poll_msec_show(
+		struct edac_device_ctl_info *ctl_info, char *data)
+{
+        return sprintf(data,"%u\n", ctl_info->poll_msec);
+}
+
+static ssize_t edac_device_ctl_poll_msec_store(
+		struct edac_device_ctl_info *ctl_info,
+		const char *data,size_t count)
+{
+	unsigned long value;
+
+	/* get the value and enforce that it is non-zero, must be at least
+	 * one millisecond for the delay period, between scans
+	 * Then cancel last outstanding delay for the work request
+	 * and set a new one.
+	 */
+	value = simple_strtoul(data,NULL,0);
+	edac_device_reset_delay_period(ctl_info,value);
+
+        return count;
+}
+
+
+/* edac_device_ctl_info specific attribute structure */
+struct ctl_info_attribute {
+        struct attribute attr;
+        ssize_t (*show)(struct edac_device_ctl_info *,char *);
+        ssize_t (*store)(struct edac_device_ctl_info *,const char *,size_t);
+};
+
+#define to_ctl_info(k) container_of(k, struct edac_device_ctl_info, kobj)
+#define to_ctl_info_attr(a) container_of(a,struct ctl_info_attribute,attr)
+
+/* Function to 'show' fields from the edac_dev 'ctl_info' structure */
+static ssize_t edac_dev_ctl_info_show(struct kobject *kobj,
+                        struct attribute *attr,
+                        char *buffer)
+{
+        struct edac_device_ctl_info *edac_dev = to_ctl_info(kobj);
+        struct ctl_info_attribute *ctl_info_attr = to_ctl_info_attr(attr);
+
+        if (ctl_info_attr->show)
+                return ctl_info_attr->show(edac_dev,buffer);
+        return -EIO;
+}
+
+/* Function to 'store' fields into the edac_dev 'ctl_info' structure */
+static ssize_t edac_dev_ctl_info_store(struct kobject *kobj,
+                        struct attribute *attr,
+                	const char *buffer, size_t count)
+{
+        struct edac_device_ctl_info *edac_dev = to_ctl_info(kobj);
+        struct ctl_info_attribute *ctl_info_attr = to_ctl_info_attr(attr);
+
+        if (ctl_info_attr->store)
+                return ctl_info_attr->store(edac_dev, buffer, count);
+        return -EIO;
+}
+
+/* edac_dev file operations for an 'ctl_info' */
+static struct sysfs_ops device_ctl_info_ops = {
+	.show   = edac_dev_ctl_info_show,
+	.store  = edac_dev_ctl_info_store
+};
+
+#define CTL_INFO_ATTR(_name,_mode,_show,_store)        \
+static struct ctl_info_attribute attr_ctl_info_##_name = {      \
+        .attr = {.name = __stringify(_name), .mode = _mode },   \
+        .show   = _show,                                        \
+        .store  = _store,                                       \
+};
+
+
+/* Declare the various ctl_info attributes here and their respective ops */
+CTL_INFO_ATTR(log_ue,S_IRUGO|S_IWUSR,
+		edac_device_ctl_log_ue_show,
+		edac_device_ctl_log_ue_store);
+CTL_INFO_ATTR(log_ce,S_IRUGO|S_IWUSR,
+		edac_device_ctl_log_ce_show,
+		edac_device_ctl_log_ce_store);
+CTL_INFO_ATTR(panic_on_ue,S_IRUGO|S_IWUSR,
+		edac_device_ctl_panic_on_ue_show,
+		edac_device_ctl_panic_on_ue_store);
+CTL_INFO_ATTR(poll_msec,S_IRUGO|S_IWUSR,
+		edac_device_ctl_poll_msec_show,
+		edac_device_ctl_poll_msec_store);
+
+
+/* Base Attributes of the EDAC_DEVICE ECC object */
+static struct ctl_info_attribute *device_ctrl_attr[] = {
+	&attr_ctl_info_panic_on_ue,
+	&attr_ctl_info_log_ue,
+	&attr_ctl_info_log_ce,
+	&attr_ctl_info_poll_msec,
+	NULL,
+};
+
+/* Main DEVICE kobject release() function */
+static void edac_device_ctrl_master_release(struct kobject *kobj)
+{
+	struct edac_device_ctl_info *edac_dev;
+
+	edac_dev = to_edacdev(kobj);
+
+	debugf1("%s()\n", __func__);
+	complete(&edac_dev->kobj_complete);
+}
+
+static struct kobj_type ktype_device_ctrl = {
+	.release = edac_device_ctrl_master_release,
+	.sysfs_ops = &device_ctl_info_ops,
+	.default_attrs = (struct attribute **) device_ctrl_attr,
+};
+
+
+/**************** edac_device main kobj ctor/dtor code *********************/
+
+/*
+ * edac_device_register_main_kobj
+ *
+ *	perform the high level setup for the new edac_device instance
+ *
+ * Return:  0 SUCCESS
+ *         !0 FAILURE
+ */
+static int edac_device_register_main_kobj(
+		struct edac_device_ctl_info *edac_dev)
+{
+	int err = 0;
+	struct sysdev_class *edac_class;
+
+	debugf1("%s()\n", __func__);
+
+        /* get the /sys/devices/system/edac reference */
+        edac_class = edac_get_edac_class();
+        if (edac_class == NULL) {
+                debugf1("%s() no edac_class error=%d\n", __func__, err);
+                return err;
+        }
+
+	/* Point to the 'edac_class' this instance 'reports' to */
+	edac_dev->edac_class = edac_class;
+
+	/* Init the devices's kobject */
+	memset(&edac_dev->kobj, 0, sizeof (struct kobject));
+	edac_dev->kobj.ktype = &ktype_device_ctrl;
+
+	/* set this new device under the edac_class kobject */
+	edac_dev->kobj.parent = &edac_class->kset.kobj;
+
+	/* generate sysfs "..../edac/<name>"   */
+	debugf1("%s() set name of kobject to: %s\n",
+		__func__, edac_dev->name);
+	err = kobject_set_name(&edac_dev->kobj,"%s",edac_dev->name);
+	if (err)
+		return err;
+	err = kobject_register(&edac_dev->kobj);
+	if (err) {
+		debugf1("%s()Failed to register '.../edac/%s'\n",
+			__func__,edac_dev->name);
+		return err;
+	}
+
+	debugf1("%s() Registered '.../edac/%s' kobject\n",
+		__func__, edac_dev->name);
+
+	return 0;
+}
+
+/*
+ * edac_device_unregister_main_kobj:
+ *	the '..../edac/<name>' kobject
+ */
+static void edac_device_unregister_main_kobj(
+			struct edac_device_ctl_info *edac_dev)
+{
+	debugf0("%s()\n", __func__);
+	debugf1("%s() name of kobject is: %s\n",
+		__func__, kobject_name(&edac_dev->kobj));
+
+	init_completion(&edac_dev->kobj_complete);
+
+	/*
+	 * Unregister the edac device's kobject and
+	 * wait for reference count to reach 0.
+	 */
+	kobject_unregister(&edac_dev->kobj);
+	wait_for_completion(&edac_dev->kobj_complete);
+}
+
+
+/*************** edac_dev -> instance information ***********/
+
+/*
+ * Set of low-level instance attribute show functions
+ */
+static ssize_t instance_ue_count_show(
+		struct edac_device_instance *instance, char *data)
+{
+        return sprintf(data,"%u\n", instance->counters.ue_count);
+}
+
+static ssize_t instance_ce_count_show(
+		struct edac_device_instance *instance, char *data)
+{
+        return sprintf(data,"%u\n", instance->counters.ce_count);
+}
+
+
+
+#define to_instance(k) container_of(k, struct edac_device_instance, kobj)
+#define to_instance_attr(a) container_of(a,struct instance_attribute,attr)
+
+/* DEVICE instance kobject release() function */
+static void edac_device_ctrl_instance_release(struct kobject *kobj)
+{
+	struct edac_device_instance *instance;
+
+	debugf1("%s()\n", __func__);
+
+	instance = to_instance(kobj);
+	complete(&instance->kobj_complete);
+}
+
+
+/* instance specific attribute structure */
+struct instance_attribute {
+        struct attribute attr;
+        ssize_t (*show)(struct edac_device_instance *,char *);
+        ssize_t (*store)(struct edac_device_instance *,const char *,size_t);
+};
+
+
+/* Function to 'show' fields from the edac_dev 'instance' structure */
+static ssize_t edac_dev_instance_show(struct kobject *kobj,
+                        struct attribute *attr,
+                        char *buffer)
+{
+        struct edac_device_instance *instance = to_instance(kobj);
+        struct instance_attribute *instance_attr = to_instance_attr(attr);
+
+        if (instance_attr->show)
+                return instance_attr->show(instance,buffer);
+        return -EIO;
+}
+
+
+/* Function to 'store' fields into the edac_dev 'instance' structure */
+static ssize_t edac_dev_instance_store(struct kobject *kobj,
+                        struct attribute *attr,
+                	const char *buffer, size_t count)
+{
+        struct edac_device_instance *instance = to_instance(kobj);
+        struct instance_attribute *instance_attr = to_instance_attr(attr);
+
+        if (instance_attr->store)
+                return instance_attr->store(instance, buffer, count);
+        return -EIO;
+}
+
+
+
+/* edac_dev file operations for an 'instance' */
+static struct sysfs_ops device_instance_ops = {
+	.show   = edac_dev_instance_show,
+	.store  = edac_dev_instance_store
+};
+
+#define INSTANCE_ATTR(_name,_mode,_show,_store)        \
+static struct instance_attribute attr_instance_##_name = {      \
+        .attr = {.name = __stringify(_name), .mode = _mode },   \
+        .show   = _show,                                        \
+        .store  = _store,                                       \
+};
+
+/*
+ * Define attributes visible for the edac_device instance object
+ *	Each contains a pointer to a show and an optional set
+ *	function pointer that does the low level output/input
+ */
+INSTANCE_ATTR(ce_count,S_IRUGO,instance_ce_count_show,NULL);
+INSTANCE_ATTR(ue_count,S_IRUGO,instance_ue_count_show,NULL);
+
+/* list of edac_dev 'instance' attributes */
+static struct instance_attribute *device_instance_attr[] = {
+	&attr_instance_ce_count,
+	&attr_instance_ue_count,
+	NULL,
+};
+
+/* The 'ktype' for each edac_dev 'instance' */
+static struct kobj_type ktype_instance_ctrl = {
+	.release = edac_device_ctrl_instance_release,
+	.sysfs_ops = &device_instance_ops,
+	.default_attrs = (struct attribute **) device_instance_attr,
+};
+
+
+/*************** edac_dev -> instance -> block information *********/
+
+/*
+ * Set of low-level block attribute show functions
+ */
+static ssize_t block_ue_count_show(
+		struct edac_device_block *block, char *data)
+{
+        return sprintf(data,"%u\n", block->counters.ue_count);
+}
+
+static ssize_t block_ce_count_show(
+		struct edac_device_block *block, char *data)
+{
+        return sprintf(data,"%u\n", block->counters.ce_count);
+}
+
+
+
+#define to_block(k) container_of(k, struct edac_device_block, kobj)
+#define to_block_attr(a) container_of(a,struct block_attribute,attr)
+
+/* DEVICE block kobject release() function */
+static void edac_device_ctrl_block_release(struct kobject *kobj)
+{
+	struct edac_device_block *block;
+
+	debugf1("%s()\n", __func__);
+
+	block = to_block(kobj);
+	complete(&block->kobj_complete);
+}
+
+/* block specific attribute structure */
+struct block_attribute {
+        struct attribute attr;
+        ssize_t (*show)(struct edac_device_block *,char *);
+        ssize_t (*store)(struct edac_device_block *,const char *,size_t);
+};
+
+/* Function to 'show' fields from the edac_dev 'block' structure */
+static ssize_t edac_dev_block_show(struct kobject *kobj,
+                        struct attribute *attr,
+                        char *buffer)
+{
+        struct edac_device_block *block = to_block(kobj);
+        struct block_attribute *block_attr = to_block_attr(attr);
+
+        if (block_attr->show)
+                return block_attr->show(block,buffer);
+        return -EIO;
+}
+
+
+/* Function to 'store' fields into the edac_dev 'block' structure */
+static ssize_t edac_dev_block_store(struct kobject *kobj,
+                        struct attribute *attr,
+                	const char *buffer, size_t count)
+{
+        struct edac_device_block *block = to_block(kobj);
+        struct block_attribute *block_attr = to_block_attr(attr);
+
+        if (block_attr->store)
+                return block_attr->store(block, buffer, count);
+        return -EIO;
+}
+
+
+/* edac_dev file operations for a 'block' */
+static struct sysfs_ops device_block_ops = {
+	.show   = edac_dev_block_show,
+	.store  = edac_dev_block_store
+};
+
+
+#define BLOCK_ATTR(_name,_mode,_show,_store)        \
+static struct block_attribute attr_block_##_name = {                       \
+        .attr = {.name = __stringify(_name), .mode = _mode },   \
+        .show   = _show,                                        \
+        .store  = _store,                                       \
+};
+
+BLOCK_ATTR(ce_count,S_IRUGO,block_ce_count_show,NULL);
+BLOCK_ATTR(ue_count,S_IRUGO,block_ue_count_show,NULL);
+
+
+/* list of edac_dev 'block' attributes */
+static struct block_attribute *device_block_attr[] = {
+	&attr_block_ce_count,
+	&attr_block_ue_count,
+	NULL,
+};
+
+/* The 'ktype' for each edac_dev 'block' */
+static struct kobj_type ktype_block_ctrl = {
+	.release = edac_device_ctrl_block_release,
+	.sysfs_ops = &device_block_ops,
+	.default_attrs = (struct attribute **) device_block_attr,
+};
+
+
+/************** block ctor/dtor  code ************/
+
+/*
+ * edac_device_create_block
+ */
+static int edac_device_create_block(
+		struct edac_device_ctl_info *edac_dev,
+		struct edac_device_instance *instance,
+		int idx)
+{
+	int err;
+	struct edac_device_block *block;
+
+	block = &instance->blocks[idx];
+
+	debugf1("%s() Instance '%s' block[%d] '%s'\n",
+		__func__,instance->name, idx, block->name);
+
+	/* init this block's kobject */
+	memset(&block->kobj, 0, sizeof (struct kobject));
+	block->kobj.parent = &instance->kobj;
+	block->kobj.ktype = &ktype_block_ctrl;
+
+	err = kobject_set_name(&block->kobj,"%s",block->name);
+	if (err)
+		return err;
+
+	err = kobject_register(&block->kobj);
+	if (err) {
+		debugf1("%s()Failed to register instance '%s'\n",
+			__func__,block->name);
+		return err;
+	}
+
+	return 0;
+}
+
+/*
+ * edac_device_delete_block(edac_dev,j);
+ */
+static void edac_device_delete_block(
+		struct edac_device_ctl_info *edac_dev,
+		struct edac_device_instance *instance,
+		int idx)
+{
+	struct edac_device_block *block;
+
+	block = &instance->blocks[idx];
+
+	/* unregister this block's kobject */
+	init_completion(&block->kobj_complete);
+	kobject_unregister(&block->kobj);
+	wait_for_completion(&block->kobj_complete);
+}
+
+/************** instance ctor/dtor  code ************/
+
+/*
+ * edac_device_create_instance
+ *	create just one instance of an edac_device 'instance'
+ */
+static int edac_device_create_instance(
+		struct edac_device_ctl_info *edac_dev, int idx)
+{
+	int i, j;
+	int err;
+	struct edac_device_instance *instance;
+
+	instance = &edac_dev->instances[idx];
+
+	/* Init the instance's kobject */
+	memset(&instance->kobj, 0, sizeof (struct kobject));
+
+	/* set this new device under the edac_device main kobject */
+	instance->kobj.parent = &edac_dev->kobj;
+	instance->kobj.ktype = &ktype_instance_ctrl;
+
+	err = kobject_set_name(&instance->kobj,"%s",instance->name);
+	if (err)
+		return err;
+
+	err = kobject_register(&instance->kobj);
+	if (err != 0) {
+		debugf2("%s() Failed to register instance '%s'\n",
+			__func__,instance->name);
+		return err;
+	}
+
+	debugf1("%s() now register '%d' blocks for instance %d\n",
+			__func__,instance->nr_blocks,idx);
+
+	/* register all blocks of this instance */
+	for (i = 0; i < instance->nr_blocks; i++ ) {
+		err = edac_device_create_block(edac_dev,instance,i);
+		if (err) {
+			for (j = 0; j < i; j++) {
+				edac_device_delete_block(edac_dev,instance,j);
+			}
+			return err;
+		}
+	}
+
+	debugf1("%s() Registered instance %d '%s' kobject\n",
+		__func__, idx, instance->name);
+
+	return 0;
+}
+
+/*
+ * edac_device_remove_instance
+ *	remove an edac_device instance
+ */
+static void edac_device_delete_instance(
+		struct edac_device_ctl_info *edac_dev, int idx)
+{
+	int i;
+	struct edac_device_instance *instance;
+
+	instance = &edac_dev->instances[idx];
+
+	/* unregister all blocks in this instance */
+	for (i = 0; i < instance->nr_blocks; i++) {
+		edac_device_delete_block(edac_dev,instance,i);
+	}
+
+	/* unregister this instance's kobject */
+	init_completion(&instance->kobj_complete);
+	kobject_unregister(&instance->kobj);
+	wait_for_completion(&instance->kobj_complete);
+}
+
+/*
+ * edac_device_create_instances
+ *	create the first level of 'instances' for this device
+ *	(ie  'cache' might have 'cache0', 'cache1', 'cache2', etc
+ */
+static int edac_device_create_instances(struct edac_device_ctl_info *edac_dev)
+{
+	int i, j;
+	int err;
+
+	debugf0("%s()\n", __func__);
+
+	/* iterate over creation of the instances */
+	for (i = 0; i < edac_dev->nr_instances; i++ ) {
+		err = edac_device_create_instance(edac_dev,i);
+		if (err) {
+			/* unwind previous instances on error */
+			for (j = 0; j < i; j++) {
+				edac_device_delete_instance(edac_dev,j);
+			}
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * edac_device_delete_instances(edac_dev);
+ *	unregister all the kobjects of the instances
+ */
+static void edac_device_delete_instances(struct edac_device_ctl_info *edac_dev)
+{
+	int i;
+
+	/* iterate over creation of the instances */
+	for (i = 0; i < edac_dev->nr_instances; i++ ) {
+		edac_device_delete_instance(edac_dev,i);
+	}
+}
+
+/******************* edac_dev sysfs ctor/dtor  code *************/
+
+/*
+ * edac_device_create_sysfs() Constructor
+ *
+ * Create a new edac_device kobject instance,
+ *
+ * Return:
+ *	0	Success
+ *	!0	Failure
+ */
+int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)
+{
+	int err;
+	struct kobject *edac_kobj=&edac_dev->kobj;
+
+	/* register this instance's main kobj with the edac class kobj */
+	err = edac_device_register_main_kobj(edac_dev);
+	if (err)
+		return err;
+
+	debugf0("%s() idx=%d\n", __func__, edac_dev->dev_idx);
+
+	/* create a symlink from the edac device
+	 * to the platform 'device' being used for this
+	 */
+	err = sysfs_create_link(edac_kobj,
+				&edac_dev->dev->kobj,
+				EDAC_DEVICE_SYMLINK);
+	if (err) {
+		debugf0("%s() sysfs_create_link() returned err= %d\n",
+			__func__, err);
+		return err;
+	}
+
+	debugf0("%s() calling create-instances, idx=%d\n",
+		__func__, edac_dev->dev_idx);
+
+	/* Create the first level instance directories */
+	err = edac_device_create_instances(edac_dev);
+	if (err) {
+		goto error0;
+	}
+
+	return 0;
+
+	/* Error unwind stack */
+
+error0:
+	edac_device_unregister_main_kobj(edac_dev);
+
+	return err;
+}
+
+/*
+ * edac_device_remove_sysfs() destructor
+ *
+ * remove a edac_device instance
+ */
+void edac_device_remove_sysfs(struct edac_device_ctl_info *edac_dev)
+{
+	debugf0("%s()\n", __func__);
+
+	edac_device_delete_instances(edac_dev);
+
+	/* remove the sym link */
+	sysfs_remove_link(&edac_dev->kobj, EDAC_DEVICE_SYMLINK);
+
+	/* unregister the instance's main kobj */
+	edac_device_unregister_main_kobj(edac_dev);
+}
+
