commit bc9ad9e40dbc4c8874e806345df393a9cfeadad3
Author: Robert Richter <rrichter@marvell.com>
Date:   Wed Nov 6 09:33:02 2019 +0000

    EDAC: Replace EDAC_DIMM_PTR() macro with edac_get_dimm() function
    
    The EDAC_DIMM_PTR() macro takes 3 arguments from struct mem_ctl_info.
    Clean up this interface to only pass the mci struct and replace this
    macro with a new function edac_get_dimm().
    
    Also introduce an edac_get_dimm_by_index() function for later use.
    This allows it to get a DIMM pointer only by a given index. This can
    be useful if the DIMM's position within the layers of the memory
    controller or the exact size of the layers are unknown.
    
    Small style changes made for some hunks after applying the semantic
    patch.
    
    Semantic patch used:
    
    @@ expression mci, a, b,c; @@
    
    -EDAC_DIMM_PTR(mci->layers, mci->dimms, mci->n_layers, a, b, c)
    +edac_get_dimm(mci, a, b, c)
    
     [ bp: Touchups. ]
    
    Signed-off-by: Robert Richter <rrichter@marvell.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: "linux-edac@vger.kernel.org" <linux-edac@vger.kernel.org>
    Cc: James Morse <james.morse@arm.com>
    Cc: Jason Baron <jbaron@akamai.com>
    Cc: Qiuxu Zhuo <qiuxu.zhuo@intel.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Link: https://lkml.kernel.org/r/20191106093239.25517-2-rrichter@marvell.com

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 447d357c7a67..2e9bbe56cde9 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -794,8 +794,7 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 			for (ch = 0; ch < max_channel; ch++) {
 				int channel = to_channel(ch, branch);
 
-				dimm = EDAC_DIMM_PTR(mci->layers, mci->dimms,
-					       mci->n_layers, branch, ch, slot);
+				dimm = edac_get_dimm(mci, branch, ch, slot);
 
 				dinfo = &pvt->dimm_info[slot][channel];
 

commit 48356e0d57783eec766bef60c88553ee53740b3c
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Fri Sep 13 11:03:23 2019 -0300

    EDAC: i7300_edac: fix a kernel-doc syntax
    
    The declaration of the kerneldoc entry is wrong, causing this
    warning:
    
            drivers/edac/i7300_edac.c:824: warning: Function parameter or member 'mir_no' not described in 'decode_mir'
    
    Acked-by: Borislav Petkov <bp@alien8.de>
    Acked-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 3d4bd3bf317c..447d357c7a67 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -817,7 +817,7 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 
 /**
  * decode_mir() - Decodes Memory Interleave Register (MIR) info
- * @int mir_no: number of the MIR register to decode
+ * @mir_no: number of the MIR register to decode
  * @mir: array with the MIR data cached on the driver
  */
 static void decode_mir(int mir_no, u16 mir[MAX_MIR])

commit 9f95c8d5f84ae3e56f8fcfde2f2a2fd4326d7db6
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Fri Sep 13 11:01:01 2019 -0300

    EDAC: i7300_edac: rename a kernel-doc var description
    
    One var was renamed, but the associated kernel-doc markup still
    points to the old name.
    
    Acked-by: Borislav Petkov <bp@alien8.de>
    Acked-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 7bf910d54d11..3d4bd3bf317c 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -580,7 +580,7 @@ static void i7300_enable_error_reporting(struct mem_ctl_info *mci)
  * @ch: Channel number within the branch (0 or 1)
  * @branch: Branch number (0 or 1)
  * @dinfo: Pointer to DIMM info where dimm size is stored
- * @p_csrow: Pointer to the struct csrow_info that corresponds to that element
+ * @dimm: Pointer to the struct dimm_info that corresponds to that element
  */
 static int decode_mtr(struct i7300_pvt *pvt,
 		      int slot, int ch, int branch,

commit 122375508ba37bdb0a99bf9c78f54500368aad2a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:19 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 172
    
    Based on 1 normalized pattern(s):
    
      this file may be distributed under the terms of the gnu general
      public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 9 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.395589349@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 6b5a554ba8e4..7bf910d54d11 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -1,9 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Intel 7300 class Memory Controllers kernel module (Clarksboro)
  *
- * This file may be distributed under the terms of the
- * GNU General Public License version 2 only.
- *
  * Copyright (c) 2010 by:
  *	 Mauro Carvalho Chehab
  *

commit c54182ec0e157988f0cafd1e8d37b68ab4210f87
Author: Borislav Petkov <bp@suse.de>
Date:   Thu Jun 29 12:00:05 2017 +0200

    EDAC: Get rid of mci->mod_ver
    
    It is a write-only variable so get rid of it.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Robert Richter <rric@kernel.org>
    Acked-by: Michal Simek <michal.simek@xilinx.com>
    Acked-by: Thor Thayer <thor.thayer@linux.intel.com>
    Acked-by: Tony Luck <tony.luck@intel.com>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: Tim Small <tim@buttersideup.com>
    Cc: Ranganathan Desikan <ravi@jetztechnologies.com>
    Cc: "Arvind R." <arvino55@gmail.com>
    Cc: Jason Baron <jbaron@akamai.com>
    Cc: "SÃ¶ren Brinkmann" <soren.brinkmann@xilinx.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: David Daney <david.daney@cavium.com>
    Cc: Loc Ho <lho@apm.com>
    Cc: linux-edac@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-mips@linux-mips.org

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index e391f5a716be..6b5a554ba8e4 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -1077,7 +1077,6 @@ static int i7300_init_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	mci->edac_ctl_cap = EDAC_FLAG_NONE;
 	mci->edac_cap = EDAC_FLAG_NONE;
 	mci->mod_name = "i7300_edac.c";
-	mci->mod_ver = I7300_REVISION;
 	mci->ctl_name = i7300_devs[0].ctl_name;
 	mci->dev_name = pci_name(pdev);
 	mci->ctl_page_to_phys = NULL;

commit 58fb24cb95562da6e54763463464d168ec5a1caa
Author: Borislav Petkov <bp@suse.de>
Date:   Wed Jan 25 16:08:27 2017 +0100

    EDAC, i7300: Test for the second channel properly
    
    REDMEMB[17] is the ECC_Locator bit, which, when set, identifies the
    CS[3:2] as the simbols in error. And thus the second channel.
    
    The macro computing it was wrong so get rid of it (it was used at one
    place only) and get rid of the conditional too. Generates better code
    this way anyway.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reported-by: David Binderman <dcb314@hotmail.com>
    Reviewed-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 0a912bf6de00..e391f5a716be 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -304,7 +304,6 @@ static const char *ferr_global_lo_name[] = {
 #define REDMEMA		0xdc
 
 #define REDMEMB		0x7c
-  #define IS_SECOND_CH(v)	((v) * (1 << 17))
 
 #define RECMEMA		0xe0
   #define RECMEMA_BANK(v)	(((v) >> 12) & 7)
@@ -483,8 +482,9 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 		pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
 				     REDMEMB, &value);
 		channel = (branch << 1);
-		if (IS_SECOND_CH(value))
-			channel++;
+
+		/* Second channel ? */
+		channel += !!(value & BIT(17));
 
 		/* Clear the error bit */
 		pci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,

commit 78d88e8a3d738f1ce508cd24b525d2e6cdfda1c1
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Sat Oct 29 15:16:34 2016 -0200

    edac: rename edac_core.h to edac_mc.h
    
    Now, all left at edac_core.h are at drivers/edac/edac_mc.c,
    so rename it to edac_mc.h.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index dcac982fdc7a..0a912bf6de00 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -26,7 +26,7 @@
 #include <linux/edac.h>
 #include <linux/mmzone.h>
 
-#include "edac_core.h"
+#include "edac_module.h"
 
 /*
  * Alter this version for the I7300 module when modifications are made

commit c897df0e2dbc81bcc09c11425658d69830825364
Merge: 1e9c4d490209 0414855fdc4a
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Tue Mar 11 06:55:49 2014 -0300

    Merge tag 'v3.14-rc5' into patchwork
    
    Linux 3.14-rc5
    
    * tag 'v3.14-rc5': (1117 commits)
      Linux 3.14-rc5
      drm/vmwgfx: avoid null pointer dereference at failure paths
      drm/vmwgfx: Make sure backing mobs are cleared when allocated. Update driver date.
      drm/vmwgfx: Remove some unused surface formats
      MAINTAINERS: add maintainer entry for Armada DRM driver
      arm64: Fix !CONFIG_SMP kernel build
      arm64: mm: Add double logical invert to pte accessors
      dm cache: fix truncation bug when mapping I/O to >2TB fast device
      perf tools: Fix strict alias issue for find_first_bit
      powerpc/powernv: Fix indirect XSCOM unmangling
      powerpc/powernv: Fix opal_xscom_{read,write} prototype
      powerpc/powernv: Refactor PHB diag-data dump
      powerpc/powernv: Dump PHB diag-data immediately
      powerpc: Increase stack redzone for 64-bit userspace to 512 bytes
      powerpc/ftrace: bugfix for test_24bit_addr
      powerpc/crashdump : Fix page frame number check in copy_oldmem_page
      powerpc/le: Ensure that the 'stop-self' RTAS token is handled correctly
      kvm, vmx: Really fix lazy FPU on nested guest
      perf tools: fix BFD detection on opensuse
      drm/radeon: enable speaker allocation setup on dce3.2
      ...

commit 75135da0d68419ef8a925f4c1d5f63d8046e314d
Author: Jean Delvare <jdelvare@suse.de>
Date:   Tue Feb 25 09:43:13 2014 +0100

    i7300_edac: Fix device reference count
    
    pci_get_device() decrements the reference count of "from" (last
    argument) so when we break off the loop successfully we have only one
    device reference - and we don't know which device we have. If we want
    a reference to each device, we must take them explicitly and let
    the pci_get_device() walk complete to avoid duplicate references.
    
    This is serious, as over-putting device references will cause
    the device to eventually disappear. Without this fix, the kernel
    crashes after a few insmod/rmmod cycles.
    
    Tested on an Intel S7000FC4UR system with a 7300 chipset.
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Link: http://lkml.kernel.org/r/20140224111656.09bbb7ed@endymion.delvare
    Cc: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Cc: Doug Thompson <dougthompson@xmission.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index d63f4798f7d0..57e96a3350f0 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -943,33 +943,35 @@ static int i7300_get_devices(struct mem_ctl_info *mci)
 
 	/* Attempt to 'get' the MCH register we want */
 	pdev = NULL;
-	while (!pvt->pci_dev_16_1_fsb_addr_map ||
-	       !pvt->pci_dev_16_2_fsb_err_regs) {
-		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
-				      PCI_DEVICE_ID_INTEL_I7300_MCH_ERR, pdev);
-		if (!pdev) {
-			/* End of list, leave */
-			i7300_printk(KERN_ERR,
-				"'system address,Process Bus' "
-				"device not found:"
-				"vendor 0x%x device 0x%x ERR funcs "
-				"(broken BIOS?)\n",
-				PCI_VENDOR_ID_INTEL,
-				PCI_DEVICE_ID_INTEL_I7300_MCH_ERR);
-			goto error;
-		}
-
+	while ((pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
+				      PCI_DEVICE_ID_INTEL_I7300_MCH_ERR,
+				      pdev))) {
 		/* Store device 16 funcs 1 and 2 */
 		switch (PCI_FUNC(pdev->devfn)) {
 		case 1:
-			pvt->pci_dev_16_1_fsb_addr_map = pdev;
+			if (!pvt->pci_dev_16_1_fsb_addr_map)
+				pvt->pci_dev_16_1_fsb_addr_map =
+							pci_dev_get(pdev);
 			break;
 		case 2:
-			pvt->pci_dev_16_2_fsb_err_regs = pdev;
+			if (!pvt->pci_dev_16_2_fsb_err_regs)
+				pvt->pci_dev_16_2_fsb_err_regs =
+							pci_dev_get(pdev);
 			break;
 		}
 	}
 
+	if (!pvt->pci_dev_16_1_fsb_addr_map ||
+	    !pvt->pci_dev_16_2_fsb_err_regs) {
+		/* At least one device was not found */
+		i7300_printk(KERN_ERR,
+			"'system address,Process Bus' device not found:"
+			"vendor 0x%x device 0x%x ERR funcs (broken BIOS?)\n",
+			PCI_VENDOR_ID_INTEL,
+			PCI_DEVICE_ID_INTEL_I7300_MCH_ERR);
+		goto error;
+	}
+
 	edac_dbg(1, "System Address, processor bus- PCI Bus ID: %s  %x:%x\n",
 		 pci_name(pvt->pci_dev_16_0_fsb_ctlr),
 		 pvt->pci_dev_16_0_fsb_ctlr->vendor,

commit 37e59f876bc710d67a30b660826a5e83e07101ce
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Fri Feb 7 08:03:07 2014 -0200

    [media, edac] Change my email address
    
    There are several left overs with my old email address.
    Remove their occurrences and add myself at CREDITS, to
    allow people to be able to reach me on my new addresses.
    
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index d63f4798f7d0..aea80a5e2bba 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -5,7 +5,7 @@
  * GNU General Public License version 2 only.
  *
  * Copyright (c) 2010 by:
- *	 Mauro Carvalho Chehab <mchehab@redhat.com>
+ *	 Mauro Carvalho Chehab
  *
  * Red Hat Inc. http://www.redhat.com
  *
@@ -1207,7 +1207,7 @@ module_init(i7300_init);
 module_exit(i7300_exit);
 
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Mauro Carvalho Chehab <mchehab@redhat.com>");
+MODULE_AUTHOR("Mauro Carvalho Chehab");
 MODULE_AUTHOR("Red Hat Inc. (http://www.redhat.com)");
 MODULE_DESCRIPTION("MC Driver for Intel I7300 memory controllers - "
 		   I7300_REVISION);

commit ba935f40979b32924824759111ed95d35469c5fa
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Fri Dec 6 10:23:08 2013 +0100

    EDAC: Remove DEFINE_PCI_DEVICE_TABLE macro
    
    Currently, there is no other bus that has something like this macro for
    their device ids. Thus, DEFINE_PCI_DEVICE_TABLE macro should be removed.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Link: http://lkml.kernel.org/r/001c01ceefb3$5724d860$056e8920$%han@samsung.com
    [ Boris: swap commit message with better one. ]
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 9004c64b169e..d63f4798f7d0 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -1160,7 +1160,7 @@ static void i7300_remove_one(struct pci_dev *pdev)
  *
  * Has only 8086:360c PCI ID
  */
-static DEFINE_PCI_DEVICE_TABLE(i7300_pci_tbl) = {
+static const struct pci_device_id i7300_pci_tbl[] = {
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I7300_MCH_ERR)},
 	{0,}			/* 0 terminated list. */
 };

commit 33ad41263da5df8ac55d4010a015063ff88712e8
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Mar 13 22:56:33 2013 -0300

    i7300_edac: Fix memory detection in single mode
    
    When the machine is on single mode, only branch 0 channel 0
    is valid. However, the code is not honouring it:
    
    [ 1952.639341] EDAC DEBUG: i7300_get_mc_regs: Memory controller operating on single mode
    ...
    [ 1952.639351] EDAC DEBUG: i7300_init_csrows:           AMB-present CH0 = 0x1:
    [ 1952.639353] EDAC DEBUG: i7300_init_csrows:           AMB-present CH1 = 0x0:
    [ 1952.639355] EDAC DEBUG: i7300_init_csrows:           AMB-present CH2 = 0x0:
    [ 1952.639358] EDAC DEBUG: i7300_init_csrows:           AMB-present CH3 = 0x0:
    ...
    [ 1952.639360] EDAC DEBUG: decode_mtr:  MTR0 CH0: DIMMs are Present (mtr)
    [ 1952.639362] EDAC DEBUG: decode_mtr:          WIDTH: x8
    [ 1952.639363] EDAC DEBUG: decode_mtr:          ELECTRICAL THROTTLING is enabled
    [ 1952.639364] EDAC DEBUG: decode_mtr:          NUMBANK: 4 bank(s)
    [ 1952.639366] EDAC DEBUG: decode_mtr:          NUMRANK: single
    [ 1952.639367] EDAC DEBUG: decode_mtr:          NUMROW: 16,384 - 14 rows
    [ 1952.639368] EDAC DEBUG: decode_mtr:          NUMCOL: 1,024 - 10 columns
    [ 1952.639370] EDAC DEBUG: decode_mtr:          SIZE: 512 MB
    [ 1952.639371] EDAC DEBUG: decode_mtr:          ECC code is 8-byte-over-32-byte SECDED+ code
    [ 1952.639373] EDAC DEBUG: decode_mtr:          Scrub algorithm for x8 is on enhanced mode
    [ 1952.639374] EDAC DEBUG: decode_mtr:  MTR0 CH1: DIMMs are Present (mtr)
    [ 1952.639376] EDAC DEBUG: decode_mtr:          WIDTH: x8
    [ 1952.639377] EDAC DEBUG: decode_mtr:          ELECTRICAL THROTTLING is enabled
    [ 1952.639379] EDAC DEBUG: decode_mtr:          NUMBANK: 4 bank(s)
    [ 1952.639380] EDAC DEBUG: decode_mtr:          NUMRANK: single
    [ 1952.639381] EDAC DEBUG: decode_mtr:          NUMROW: 16,384 - 14 rows
    [ 1952.639383] EDAC DEBUG: decode_mtr:          NUMCOL: 1,024 - 10 columns
    [ 1952.639384] EDAC DEBUG: decode_mtr:          SIZE: 512 MB
    [ 1952.639385] EDAC DEBUG: decode_mtr:          ECC code is 8-byte-over-32-byte SECDED+ code
    [ 1952.639387] EDAC DEBUG: decode_mtr:          Scrub algorithm for x8 is on enhanced mode
    ...
    [ 1952.639449] EDAC DEBUG: print_dimm_size:               channel 0 | channel 1 | channel 2 | channel 3 |
    [ 1952.639451] EDAC DEBUG: print_dimm_size: -------------------------------------------------------------
    [ 1952.639453] EDAC DEBUG: print_dimm_size: csrow/SLOT 0   512 MB   |  512 MB   |    0 MB   |    0 MB   |
    [ 1952.639456] EDAC DEBUG: print_dimm_size: csrow/SLOT 1     0 MB   |    0 MB   |    0 MB   |    0 MB   |
    [ 1952.639458] EDAC DEBUG: print_dimm_size: csrow/SLOT 2     0 MB   |    0 MB   |    0 MB   |    0 MB   |
    [ 1952.639460] EDAC DEBUG: print_dimm_size: csrow/SLOT 3     0 MB   |    0 MB   |    0 MB   |    0 MB   |
    [ 1952.639462] EDAC DEBUG: print_dimm_size: csrow/SLOT 4     0 MB   |    0 MB   |    0 MB   |    0 MB   |
    [ 1952.639464] EDAC DEBUG: print_dimm_size: csrow/SLOT 5     0 MB   |    0 MB   |    0 MB   |    0 MB   |
    [ 1952.639466] EDAC DEBUG: print_dimm_size: csrow/SLOT 6     0 MB   |    0 MB   |    0 MB   |    0 MB   |
    [ 1952.639468] EDAC DEBUG: print_dimm_size: csrow/SLOT 7     0 MB   |    0 MB   |    0 MB   |    0 MB   |
    [ 1952.639470] EDAC DEBUG: print_dimm_size: -------------------------------------------------------------
    
    Instead of detecting a single memory at channel 0, it is showing
    twice the memory.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 087c27bc5d42..9004c64b169e 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -750,15 +750,23 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 	struct i7300_dimm_info *dinfo;
 	int rc = -ENODEV;
 	int mtr;
-	int ch, branch, slot, channel;
+	int ch, branch, slot, channel, max_channel, max_branch;
 	struct dimm_info *dimm;
 
 	pvt = mci->pvt_info;
 
 	edac_dbg(2, "Memory Technology Registers:\n");
 
+	if (IS_SINGLE_MODE(pvt->mc_settings_a)) {
+		max_branch = 1;
+		max_channel = 1;
+	} else {
+		max_branch = MAX_BRANCHES;
+		max_channel = MAX_CH_PER_BRANCH;
+	}
+
 	/* Get the AMB present registers for the four channels */
-	for (branch = 0; branch < MAX_BRANCHES; branch++) {
+	for (branch = 0; branch < max_branch; branch++) {
 		/* Read and dump branch 0's MTRs */
 		channel = to_channel(0, branch);
 		pci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],
@@ -767,6 +775,9 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 		edac_dbg(2, "\t\tAMB-present CH%d = 0x%x:\n",
 			 channel, pvt->ambpresent[channel]);
 
+		if (max_channel == 1)
+			continue;
+
 		channel = to_channel(1, branch);
 		pci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],
 				     AMBPRESENT_1,
@@ -778,11 +789,11 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 	/* Get the set of MTR[0-7] regs by each branch */
 	for (slot = 0; slot < MAX_SLOTS; slot++) {
 		int where = mtr_regs[slot];
-		for (branch = 0; branch < MAX_BRANCHES; branch++) {
+		for (branch = 0; branch < max_branch; branch++) {
 			pci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],
 					where,
 					&pvt->mtr[slot][branch]);
-			for (ch = 0; ch < MAX_CH_PER_BRANCH; ch++) {
+			for (ch = 0; ch < max_channel; ch++) {
 				int channel = to_channel(ch, branch);
 
 				dimm = EDAC_DIMM_PTR(mci->layers, mci->dimms,

commit 9b3c6e85c2cfa731cf67d5a8c49f7d8c60ec0b04
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:23:51 2012 -0800

    Drivers: edac: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, and __devexit
    from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Doug Thompson <dougthompson@xmission.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: Jason Uhlenkott <juhlenko@akamai.com>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Tim Small <tim@buttersideup.com>
    Cc: Ranganathan Desikan <ravi@jetztechnologies.com>
    Cc: "Arvind R." <arvino55@gmail.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: David Daney <david.daney@cavium.com>
    Cc: Egor Martovetsky <egor@pasemi.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 9d669cd43618..087c27bc5d42 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -923,7 +923,7 @@ static void i7300_put_devices(struct mem_ctl_info *mci)
  *    Device 21 function 0:		PCI_DEVICE_ID_INTEL_I7300_MCH_FB0
  *    Device 22 function 0:		PCI_DEVICE_ID_INTEL_I7300_MCH_FB1
  */
-static int __devinit i7300_get_devices(struct mem_ctl_info *mci)
+static int i7300_get_devices(struct mem_ctl_info *mci)
 {
 	struct i7300_pvt *pvt;
 	struct pci_dev *pdev;
@@ -1008,8 +1008,7 @@ static int __devinit i7300_get_devices(struct mem_ctl_info *mci)
  * @pdev: struct pci_dev pointer
  * @id: struct pci_device_id pointer - currently unused
  */
-static int __devinit i7300_init_one(struct pci_dev *pdev,
-				    const struct pci_device_id *id)
+static int i7300_init_one(struct pci_dev *pdev, const struct pci_device_id *id)
 {
 	struct mem_ctl_info *mci;
 	struct edac_mc_layer layers[3];
@@ -1122,7 +1121,7 @@ static int __devinit i7300_init_one(struct pci_dev *pdev,
  * i7300_remove_one() - Remove the driver
  * @pdev: struct pci_dev pointer
  */
-static void __devexit i7300_remove_one(struct pci_dev *pdev)
+static void i7300_remove_one(struct pci_dev *pdev)
 {
 	struct mem_ctl_info *mci;
 	char *tmp;
@@ -1163,7 +1162,7 @@ MODULE_DEVICE_TABLE(pci, i7300_pci_tbl);
 static struct pci_driver i7300_driver = {
 	.name = "i7300_edac",
 	.probe = i7300_init_one,
-	.remove = __devexit_p(i7300_remove_one),
+	.remove = i7300_remove_one,
 	.id_table = i7300_pci_tbl,
 };
 

commit 7e06b7a3333f5c7a0cec12aff20d39c5c87c0795
Author: Jean Delvare <jdelvare@suse.de>
Date:   Thu Oct 18 15:54:45 2012 +0200

    i7300_edac: Fix error flag testing
    
    * Right-shift the values in GET_FBD_FAT_IDX and GET_FBD_NF_IDX, so
      that the callers get the result they expect.
    * Fix definition of FERR_FAT_FBD_ERR_MASK.
    * Call GET_FBD_NF_IDX, not GET_FBD_FAT_IDX, when operating on
      register FERR_NF_FBD. We were lucky they have the same definition.
    
    This fixes kernel bug #44131:
    https://bugzilla.kernel.org/show_bug.cgi?id=44131
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Doug Thompson <dougthompson@xmission.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index a09d0667f72a..9d669cd43618 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -197,8 +197,8 @@ static const char *ferr_fat_fbd_name[] = {
 	[0]  = "Memory Write error on non-redundant retry or "
 	       "FBD configuration Write error on retry",
 };
-#define GET_FBD_FAT_IDX(fbderr)	(fbderr & (3 << 28))
-#define FERR_FAT_FBD_ERR_MASK ((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3))
+#define GET_FBD_FAT_IDX(fbderr)	(((fbderr) >> 28) & 3)
+#define FERR_FAT_FBD_ERR_MASK ((1 << 0) | (1 << 1) | (1 << 2) | (1 << 22))
 
 #define FERR_NF_FBD	0xa0
 static const char *ferr_nf_fbd_name[] = {
@@ -225,7 +225,7 @@ static const char *ferr_nf_fbd_name[] = {
 	[1]  = "Aliased Uncorrectable Non-Mirrored Demand Data ECC",
 	[0]  = "Uncorrectable Data ECC on Replay",
 };
-#define GET_FBD_NF_IDX(fbderr)	(fbderr & (3 << 28))
+#define GET_FBD_NF_IDX(fbderr)	(((fbderr) >> 28) & 3)
 #define FERR_NF_FBD_ERR_MASK ((1 << 24) | (1 << 23) | (1 << 22) | (1 << 21) |\
 			      (1 << 18) | (1 << 17) | (1 << 16) | (1 << 15) |\
 			      (1 << 14) | (1 << 13) | (1 << 11) | (1 << 10) |\
@@ -464,7 +464,7 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 		errnum = find_first_bit(&errors,
 					ARRAY_SIZE(ferr_nf_fbd_name));
 		specific = GET_ERR_FROM_TABLE(ferr_nf_fbd_name, errnum);
-		branch = (GET_FBD_FAT_IDX(error_reg) == 2) ? 1 : 0;
+		branch = (GET_FBD_NF_IDX(error_reg) == 2) ? 1 : 0;
 
 		pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
 			REDMEMA, &syndrome);

commit 9eb07a7fb8a90ee39fa9d5489afc0330cfcfbea7
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 4 13:27:43 2012 -0300

    edac: edac_mc_handle_error(): add an error_count parameter
    
    In order to avoid loosing error events, it is desirable to group
    error events together and generate a single trace for several identical
    errors.
    
    The trace API already allows reporting multiple errors. Change the
    handle_error function to also allow that.
    
    The changes at the drivers were made by this small script:
    
            $file .=$_ while (<>);
            $file =~ s/(edac_mc_handle_error)\s*\(([^\,]+)\,([^\,]+)\,/$1($2,$3, 1,/g;
            print $file;
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 4a8835fd12bd..a09d0667f72a 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -449,7 +449,7 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 			 "Bank=%d RAS=%d CAS=%d Err=0x%lx (%s))",
 			 bank, ras, cas, errors, specific);
 
-		edac_mc_handle_error(HW_EVENT_ERR_FATAL, mci, 0, 0, 0,
+		edac_mc_handle_error(HW_EVENT_ERR_FATAL, mci, 1, 0, 0, 0,
 				     branch, -1, rank,
 				     is_wr ? "Write error" : "Read error",
 				     pvt->tmp_prt_buffer);
@@ -495,7 +495,7 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 			 "DRAM-Bank=%d RAS=%d CAS=%d, Err=0x%lx (%s))",
 			 bank, ras, cas, errors, specific);
 
-		edac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 0, 0,
+		edac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1, 0, 0,
 				     syndrome,
 				     branch >> 1, channel % 2, rank,
 				     is_wr ? "Write error" : "Read error",

commit 03f7eae80f4b913929be84e0c883ee98196fd6ff
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 4 11:29:25 2012 -0300

    edac: remove arch-specific parameter for the error handler
    
    Remove the arch-dependent parameter, as it were not used,
    as the MCE tracepoint weren't implemented. It probably doesn't
    make sense to have an MCE-specific tracepoint, as this will
    cost more bytes at the tracepoint, and tracepoint is not free.
    
    The changes at the EDAC drivers were done by this small perl script:
    
            $file .=$_ while (<>);
            $file =~ s/(edac_mc_handle_error)\s*\(([^\;]+)\,([^\,\)]+)\s*\)/$1($2)/g;
            print $file;
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 738b8919194f..4a8835fd12bd 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -452,7 +452,7 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 		edac_mc_handle_error(HW_EVENT_ERR_FATAL, mci, 0, 0, 0,
 				     branch, -1, rank,
 				     is_wr ? "Write error" : "Read error",
-				     pvt->tmp_prt_buffer, NULL);
+				     pvt->tmp_prt_buffer);
 
 	}
 
@@ -499,7 +499,7 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 				     syndrome,
 				     branch >> 1, channel % 2, rank,
 				     is_wr ? "Write error" : "Read error",
-				     pvt->tmp_prt_buffer, NULL);
+				     pvt->tmp_prt_buffer);
 	}
 	return;
 }

commit 956b9ba156dbfdb9cede2b2927ddf8be2233b3a7
Author: Joe Perches <joe@perches.com>
Date:   Sun Apr 29 17:08:39 2012 -0300

    edac: Convert debugfX to edac_dbg(X,
    
    Use a more common debugging style.
    
    Remove __FILE__ uses, add missing newlines,
    coalesce formats and align arguments.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 7eca688f7885..738b8919194f 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -596,9 +596,8 @@ static int decode_mtr(struct i7300_pvt *pvt,
 	mtr = pvt->mtr[slot][branch];
 	ans = MTR_DIMMS_PRESENT(mtr) ? 1 : 0;
 
-	debugf2("\tMTR%d CH%d: DIMMs are %s (mtr)\n",
-		slot, channel,
-		ans ? "Present" : "NOT Present");
+	edac_dbg(2, "\tMTR%d CH%d: DIMMs are %sPresent (mtr)\n",
+		 slot, channel, ans ? "" : "NOT ");
 
 	/* Determine if there is a DIMM present in this DIMM slot */
 	if (!ans)
@@ -620,24 +619,25 @@ static int decode_mtr(struct i7300_pvt *pvt,
 
 	dinfo->megabytes = 1 << addrBits;
 
-	debugf2("\t\tWIDTH: x%d\n", MTR_DRAM_WIDTH(mtr));
-
-	debugf2("\t\tELECTRICAL THROTTLING is %s\n",
-		MTR_DIMMS_ETHROTTLE(mtr) ? "enabled" : "disabled");
-
-	debugf2("\t\tNUMBANK: %d bank(s)\n", MTR_DRAM_BANKS(mtr));
-	debugf2("\t\tNUMRANK: %s\n", MTR_DIMM_RANKS(mtr) ? "double" : "single");
-	debugf2("\t\tNUMROW: %s\n",
-		MTR_DIMM_ROWS(mtr) == 0 ? "8,192 - 13 rows" :
-		MTR_DIMM_ROWS(mtr) == 1 ? "16,384 - 14 rows" :
-		MTR_DIMM_ROWS(mtr) == 2 ? "32,768 - 15 rows" :
-		"65,536 - 16 rows");
-	debugf2("\t\tNUMCOL: %s\n",
-		MTR_DIMM_COLS(mtr) == 0 ? "1,024 - 10 columns" :
-		MTR_DIMM_COLS(mtr) == 1 ? "2,048 - 11 columns" :
-		MTR_DIMM_COLS(mtr) == 2 ? "4,096 - 12 columns" :
-		"reserved");
-	debugf2("\t\tSIZE: %d MB\n", dinfo->megabytes);
+	edac_dbg(2, "\t\tWIDTH: x%d\n", MTR_DRAM_WIDTH(mtr));
+
+	edac_dbg(2, "\t\tELECTRICAL THROTTLING is %s\n",
+		 MTR_DIMMS_ETHROTTLE(mtr) ? "enabled" : "disabled");
+
+	edac_dbg(2, "\t\tNUMBANK: %d bank(s)\n", MTR_DRAM_BANKS(mtr));
+	edac_dbg(2, "\t\tNUMRANK: %s\n",
+		 MTR_DIMM_RANKS(mtr) ? "double" : "single");
+	edac_dbg(2, "\t\tNUMROW: %s\n",
+		 MTR_DIMM_ROWS(mtr) == 0 ? "8,192 - 13 rows" :
+		 MTR_DIMM_ROWS(mtr) == 1 ? "16,384 - 14 rows" :
+		 MTR_DIMM_ROWS(mtr) == 2 ? "32,768 - 15 rows" :
+		 "65,536 - 16 rows");
+	edac_dbg(2, "\t\tNUMCOL: %s\n",
+		 MTR_DIMM_COLS(mtr) == 0 ? "1,024 - 10 columns" :
+		 MTR_DIMM_COLS(mtr) == 1 ? "2,048 - 11 columns" :
+		 MTR_DIMM_COLS(mtr) == 2 ? "4,096 - 12 columns" :
+		 "reserved");
+	edac_dbg(2, "\t\tSIZE: %d MB\n", dinfo->megabytes);
 
 	/*
 	 * The type of error detection actually depends of the
@@ -653,9 +653,9 @@ static int decode_mtr(struct i7300_pvt *pvt,
 	dimm->mtype = MEM_FB_DDR2;
 	if (IS_SINGLE_MODE(pvt->mc_settings_a)) {
 		dimm->edac_mode = EDAC_SECDED;
-		debugf2("\t\tECC code is 8-byte-over-32-byte SECDED+ code\n");
+		edac_dbg(2, "\t\tECC code is 8-byte-over-32-byte SECDED+ code\n");
 	} else {
-		debugf2("\t\tECC code is on Lockstep mode\n");
+		edac_dbg(2, "\t\tECC code is on Lockstep mode\n");
 		if (MTR_DRAM_WIDTH(mtr) == 8)
 			dimm->edac_mode = EDAC_S8ECD8ED;
 		else
@@ -664,9 +664,9 @@ static int decode_mtr(struct i7300_pvt *pvt,
 
 	/* ask what device type on this row */
 	if (MTR_DRAM_WIDTH(mtr) == 8) {
-		debugf2("\t\tScrub algorithm for x8 is on %s mode\n",
-			IS_SCRBALGO_ENHANCED(pvt->mc_settings) ?
-					    "enhanced" : "normal");
+		edac_dbg(2, "\t\tScrub algorithm for x8 is on %s mode\n",
+			 IS_SCRBALGO_ENHANCED(pvt->mc_settings) ?
+			 "enhanced" : "normal");
 
 		dimm->dtype = DEV_X8;
 	} else
@@ -700,14 +700,14 @@ static void print_dimm_size(struct i7300_pvt *pvt)
 		p += n;
 		space -= n;
 	}
-	debugf2("%s\n", pvt->tmp_prt_buffer);
+	edac_dbg(2, "%s\n", pvt->tmp_prt_buffer);
 	p = pvt->tmp_prt_buffer;
 	space = PAGE_SIZE;
 	n = snprintf(p, space, "-------------------------------"
 			       "------------------------------");
 	p += n;
 	space -= n;
-	debugf2("%s\n", pvt->tmp_prt_buffer);
+	edac_dbg(2, "%s\n", pvt->tmp_prt_buffer);
 	p = pvt->tmp_prt_buffer;
 	space = PAGE_SIZE;
 
@@ -723,7 +723,7 @@ static void print_dimm_size(struct i7300_pvt *pvt)
 			space -= n;
 		}
 
-		debugf2("%s\n", pvt->tmp_prt_buffer);
+		edac_dbg(2, "%s\n", pvt->tmp_prt_buffer);
 		p = pvt->tmp_prt_buffer;
 		space = PAGE_SIZE;
 	}
@@ -732,7 +732,7 @@ static void print_dimm_size(struct i7300_pvt *pvt)
 			       "------------------------------");
 	p += n;
 	space -= n;
-	debugf2("%s\n", pvt->tmp_prt_buffer);
+	edac_dbg(2, "%s\n", pvt->tmp_prt_buffer);
 	p = pvt->tmp_prt_buffer;
 	space = PAGE_SIZE;
 #endif
@@ -755,7 +755,7 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 
 	pvt = mci->pvt_info;
 
-	debugf2("Memory Technology Registers:\n");
+	edac_dbg(2, "Memory Technology Registers:\n");
 
 	/* Get the AMB present registers for the four channels */
 	for (branch = 0; branch < MAX_BRANCHES; branch++) {
@@ -764,15 +764,15 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 		pci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],
 				     AMBPRESENT_0,
 				&pvt->ambpresent[channel]);
-		debugf2("\t\tAMB-present CH%d = 0x%x:\n",
-			channel, pvt->ambpresent[channel]);
+		edac_dbg(2, "\t\tAMB-present CH%d = 0x%x:\n",
+			 channel, pvt->ambpresent[channel]);
 
 		channel = to_channel(1, branch);
 		pci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],
 				     AMBPRESENT_1,
 				&pvt->ambpresent[channel]);
-		debugf2("\t\tAMB-present CH%d = 0x%x:\n",
-			channel, pvt->ambpresent[channel]);
+		edac_dbg(2, "\t\tAMB-present CH%d = 0x%x:\n",
+			 channel, pvt->ambpresent[channel]);
 	}
 
 	/* Get the set of MTR[0-7] regs by each branch */
@@ -814,12 +814,11 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 static void decode_mir(int mir_no, u16 mir[MAX_MIR])
 {
 	if (mir[mir_no] & 3)
-		debugf2("MIR%d: limit= 0x%x Branch(es) that participate:"
-			" %s %s\n",
-			mir_no,
-			(mir[mir_no] >> 4) & 0xfff,
-			(mir[mir_no] & 1) ? "B0" : "",
-			(mir[mir_no] & 2) ? "B1" : "");
+		edac_dbg(2, "MIR%d: limit= 0x%x Branch(es) that participate: %s %s\n",
+			 mir_no,
+			 (mir[mir_no] >> 4) & 0xfff,
+			 (mir[mir_no] & 1) ? "B0" : "",
+			 (mir[mir_no] & 2) ? "B1" : "");
 }
 
 /**
@@ -839,17 +838,17 @@ static int i7300_get_mc_regs(struct mem_ctl_info *mci)
 	pci_read_config_dword(pvt->pci_dev_16_0_fsb_ctlr, AMBASE,
 			(u32 *) &pvt->ambase);
 
-	debugf2("AMBASE= 0x%lx\n", (long unsigned int)pvt->ambase);
+	edac_dbg(2, "AMBASE= 0x%lx\n", (long unsigned int)pvt->ambase);
 
 	/* Get the Branch Map regs */
 	pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, TOLM, &pvt->tolm);
 	pvt->tolm >>= 12;
-	debugf2("TOLM (number of 256M regions) =%u (0x%x)\n", pvt->tolm,
-		pvt->tolm);
+	edac_dbg(2, "TOLM (number of 256M regions) =%u (0x%x)\n",
+		 pvt->tolm, pvt->tolm);
 
 	actual_tolm = (u32) ((1000l * pvt->tolm) >> (30 - 28));
-	debugf2("Actual TOLM byte addr=%u.%03u GB (0x%x)\n",
-		actual_tolm/1000, actual_tolm % 1000, pvt->tolm << 28);
+	edac_dbg(2, "Actual TOLM byte addr=%u.%03u GB (0x%x)\n",
+		 actual_tolm/1000, actual_tolm % 1000, pvt->tolm << 28);
 
 	/* Get memory controller settings */
 	pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map, MC_SETTINGS,
@@ -858,15 +857,15 @@ static int i7300_get_mc_regs(struct mem_ctl_info *mci)
 			     &pvt->mc_settings_a);
 
 	if (IS_SINGLE_MODE(pvt->mc_settings_a))
-		debugf0("Memory controller operating on single mode\n");
+		edac_dbg(0, "Memory controller operating on single mode\n");
 	else
-		debugf0("Memory controller operating on %s mode\n",
-		IS_MIRRORED(pvt->mc_settings) ? "mirrored" : "non-mirrored");
+		edac_dbg(0, "Memory controller operating on %smirrored mode\n",
+			 IS_MIRRORED(pvt->mc_settings) ? "" : "non-");
 
-	debugf0("Error detection is %s\n",
-		IS_ECC_ENABLED(pvt->mc_settings) ? "enabled" : "disabled");
-	debugf0("Retry is %s\n",
-		IS_RETRY_ENABLED(pvt->mc_settings) ? "enabled" : "disabled");
+	edac_dbg(0, "Error detection is %s\n",
+		 IS_ECC_ENABLED(pvt->mc_settings) ? "enabled" : "disabled");
+	edac_dbg(0, "Retry is %s\n",
+		 IS_RETRY_ENABLED(pvt->mc_settings) ? "enabled" : "disabled");
 
 	/* Get Memory Interleave Range registers */
 	pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR0,
@@ -960,18 +959,18 @@ static int __devinit i7300_get_devices(struct mem_ctl_info *mci)
 		}
 	}
 
-	debugf1("System Address, processor bus- PCI Bus ID: %s  %x:%x\n",
-		pci_name(pvt->pci_dev_16_0_fsb_ctlr),
-		pvt->pci_dev_16_0_fsb_ctlr->vendor,
-		pvt->pci_dev_16_0_fsb_ctlr->device);
-	debugf1("Branchmap, control and errors - PCI Bus ID: %s  %x:%x\n",
-		pci_name(pvt->pci_dev_16_1_fsb_addr_map),
-		pvt->pci_dev_16_1_fsb_addr_map->vendor,
-		pvt->pci_dev_16_1_fsb_addr_map->device);
-	debugf1("FSB Error Regs - PCI Bus ID: %s  %x:%x\n",
-		pci_name(pvt->pci_dev_16_2_fsb_err_regs),
-		pvt->pci_dev_16_2_fsb_err_regs->vendor,
-		pvt->pci_dev_16_2_fsb_err_regs->device);
+	edac_dbg(1, "System Address, processor bus- PCI Bus ID: %s  %x:%x\n",
+		 pci_name(pvt->pci_dev_16_0_fsb_ctlr),
+		 pvt->pci_dev_16_0_fsb_ctlr->vendor,
+		 pvt->pci_dev_16_0_fsb_ctlr->device);
+	edac_dbg(1, "Branchmap, control and errors - PCI Bus ID: %s  %x:%x\n",
+		 pci_name(pvt->pci_dev_16_1_fsb_addr_map),
+		 pvt->pci_dev_16_1_fsb_addr_map->vendor,
+		 pvt->pci_dev_16_1_fsb_addr_map->device);
+	edac_dbg(1, "FSB Error Regs - PCI Bus ID: %s  %x:%x\n",
+		 pci_name(pvt->pci_dev_16_2_fsb_err_regs),
+		 pvt->pci_dev_16_2_fsb_err_regs->vendor,
+		 pvt->pci_dev_16_2_fsb_err_regs->device);
 
 	pvt->pci_dev_2x_0_fbd_branch[0] = pci_get_device(PCI_VENDOR_ID_INTEL,
 					    PCI_DEVICE_ID_INTEL_I7300_MCH_FB0,
@@ -1022,9 +1021,9 @@ static int __devinit i7300_init_one(struct pci_dev *pdev,
 	if (rc == -EIO)
 		return rc;
 
-	debugf0("MC: pdev bus %u dev=0x%x fn=0x%x\n",
-		pdev->bus->number,
-		PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
+	edac_dbg(0, "MC: pdev bus %u dev=0x%x fn=0x%x\n",
+		 pdev->bus->number,
+		 PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
 
 	/* We only are looking for func 0 of the set */
 	if (PCI_FUNC(pdev->devfn) != 0)
@@ -1044,7 +1043,7 @@ static int __devinit i7300_init_one(struct pci_dev *pdev,
 	if (mci == NULL)
 		return -ENOMEM;
 
-	debugf0("MC: mci = %p\n", mci);
+	edac_dbg(0, "MC: mci = %p\n", mci);
 
 	mci->pdev = &pdev->dev;	/* record ptr  to the generic device */
 
@@ -1077,18 +1076,16 @@ static int __devinit i7300_init_one(struct pci_dev *pdev,
 	/* initialize the MC control structure 'csrows' table
 	 * with the mapping and control information */
 	if (i7300_get_mc_regs(mci)) {
-		debugf0("MC: Setting mci->edac_cap to EDAC_FLAG_NONE\n"
-			"    because i7300_init_csrows() returned nonzero "
-			"value\n");
+		edac_dbg(0, "MC: Setting mci->edac_cap to EDAC_FLAG_NONE because i7300_init_csrows() returned nonzero value\n");
 		mci->edac_cap = EDAC_FLAG_NONE;	/* no csrows found */
 	} else {
-		debugf1("MC: Enable error reporting now\n");
+		edac_dbg(1, "MC: Enable error reporting now\n");
 		i7300_enable_error_reporting(mci);
 	}
 
 	/* add this new MC control structure to EDAC's list of MCs */
 	if (edac_mc_add_mc(mci)) {
-		debugf0("MC: failed edac_mc_add_mc()\n");
+		edac_dbg(0, "MC: failed edac_mc_add_mc()\n");
 		/* FIXME: perhaps some code should go here that disables error
 		 * reporting if we just enabled it
 		 */
@@ -1130,7 +1127,7 @@ static void __devexit i7300_remove_one(struct pci_dev *pdev)
 	struct mem_ctl_info *mci;
 	char *tmp;
 
-	debugf0("\n");
+	edac_dbg(0, "\n");
 
 	if (i7300_pci)
 		edac_pci_release_generic_ctl(i7300_pci);
@@ -1177,7 +1174,7 @@ static int __init i7300_init(void)
 {
 	int pci_rc;
 
-	debugf2("\n");
+	edac_dbg(2, "\n");
 
 	/* Ensure that the OPSTATE is set correctly for POLL or NMI */
 	opstate_init();
@@ -1192,7 +1189,7 @@ static int __init i7300_init(void)
  */
 static void __exit i7300_exit(void)
 {
-	debugf2("\n");
+	edac_dbg(2, "\n");
 	pci_unregister_driver(&i7300_driver);
 }
 

commit 7e881856eee8b889b76cd1d8e04ce2fc79b72099
Author: Joe Perches <joe@perches.com>
Date:   Sat Apr 28 16:41:46 2012 -0300

    edac: Use more normal debugging macro style
    
    Convert macros to a simpler style and enforce appropriate
    format checking when not CONFIG_EDAC_DEBUG.
    
    Use fmt and __VA_ARGS__, neaten macros.
    
    Move some string arrays to the debugfx uses and remove the
    now unnecessary CONFIG_EDAC_DEBUG variable block definitions.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 20435ee47077..7eca688f7885 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -182,24 +182,6 @@ static const u16 mtr_regs[MAX_SLOTS] = {
 #define MTR_DIMM_COLS(mtr)		((mtr) & 0x3)
 #define MTR_DIMM_COLS_ADDR_BITS(mtr)	(MTR_DIMM_COLS(mtr) + 10)
 
-#ifdef CONFIG_EDAC_DEBUG
-/* MTR NUMROW */
-static const char *numrow_toString[] = {
-	"8,192 - 13 rows",
-	"16,384 - 14 rows",
-	"32,768 - 15 rows",
-	"65,536 - 16 rows"
-};
-
-/* MTR NUMCOL */
-static const char *numcol_toString[] = {
-	"1,024 - 10 columns",
-	"2,048 - 11 columns",
-	"4,096 - 12 columns",
-	"reserved"
-};
-#endif
-
 /************************************************
  * i7300 Register definitions for error detection
  ************************************************/
@@ -645,8 +627,16 @@ static int decode_mtr(struct i7300_pvt *pvt,
 
 	debugf2("\t\tNUMBANK: %d bank(s)\n", MTR_DRAM_BANKS(mtr));
 	debugf2("\t\tNUMRANK: %s\n", MTR_DIMM_RANKS(mtr) ? "double" : "single");
-	debugf2("\t\tNUMROW: %s\n", numrow_toString[MTR_DIMM_ROWS(mtr)]);
-	debugf2("\t\tNUMCOL: %s\n", numcol_toString[MTR_DIMM_COLS(mtr)]);
+	debugf2("\t\tNUMROW: %s\n",
+		MTR_DIMM_ROWS(mtr) == 0 ? "8,192 - 13 rows" :
+		MTR_DIMM_ROWS(mtr) == 1 ? "16,384 - 14 rows" :
+		MTR_DIMM_ROWS(mtr) == 2 ? "32,768 - 15 rows" :
+		"65,536 - 16 rows");
+	debugf2("\t\tNUMCOL: %s\n",
+		MTR_DIMM_COLS(mtr) == 0 ? "1,024 - 10 columns" :
+		MTR_DIMM_COLS(mtr) == 1 ? "2,048 - 11 columns" :
+		MTR_DIMM_COLS(mtr) == 2 ? "4,096 - 12 columns" :
+		"reserved");
 	debugf2("\t\tSIZE: %d MB\n", dinfo->megabytes);
 
 	/*

commit dd23cd6eb1f59ba722a6e6aa228adff7c01404de
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sun Apr 29 11:59:14 2012 -0300

    edac: Don't add __func__ or __FILE__ for debugf[0-9] msgs
    
    The debug macro already adds that. Most of the work here was
    made by this small script:
    
    $f .=$_ while (<>);
    
    $f =~ s/(debugf[0-9]\s*\(\s*)__FILE__\s*": /\1"/g;
    $f =~ s/(debugf[0-9]\s*\(\s*)__FILE__\s*/\1/g;
    $f =~ s/(debugf[0-9]\s*\(\s*)__FILE__\s*"MC: /\1"/g;
    
    $f =~ s/(debugf[0-9]\s*\(\")\%s[\:\,\(\)]*\s*([^\"]*\s*[^\)]+)__func__\s*\,\s*/\1\2/g;
    $f =~ s/(debugf[0-9]\s*\(\")\%s[\:\,\(\)]*\s*([^\"]*\s*[^\)]+),\s*__func__\s*\)/\1\2)/g;
    $f =~ s/(debugf[0-9]\s*\(\"MC\:\s*)\%s[\:\,\(\)]*\s*([^\"]*\s*[^\)]+)__func__\s*\,\s*/\1\2/g;
    $f =~ s/(debugf[0-9]\s*\(\"MC\:\s*)\%s[\:\,\(\)]*\s*([^\"]*\s*[^\)]+),\s*__func__\s*\)/\1\2)/g;
    
    $f =~ s/\"MC\: \\n\"/"MC:\\n"/g;
    
    print $f;
    
    After running the script, manual cleanups were done to fix it the remaining
    places.
    
    While here, removed the __LINE__ on most places, as it doesn't actually give
    useful info on most places.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index db84456e65d9..20435ee47077 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -1032,8 +1032,7 @@ static int __devinit i7300_init_one(struct pci_dev *pdev,
 	if (rc == -EIO)
 		return rc;
 
-	debugf0("MC: " __FILE__ ": %s(), pdev bus %u dev=0x%x fn=0x%x\n",
-		__func__,
+	debugf0("MC: pdev bus %u dev=0x%x fn=0x%x\n",
 		pdev->bus->number,
 		PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
 
@@ -1055,7 +1054,7 @@ static int __devinit i7300_init_one(struct pci_dev *pdev,
 	if (mci == NULL)
 		return -ENOMEM;
 
-	debugf0("MC: " __FILE__ ": %s(): mci = %p\n", __func__, mci);
+	debugf0("MC: mci = %p\n", mci);
 
 	mci->pdev = &pdev->dev;	/* record ptr  to the generic device */
 
@@ -1099,8 +1098,7 @@ static int __devinit i7300_init_one(struct pci_dev *pdev,
 
 	/* add this new MC control structure to EDAC's list of MCs */
 	if (edac_mc_add_mc(mci)) {
-		debugf0("MC: " __FILE__
-			": %s(): failed edac_mc_add_mc()\n", __func__);
+		debugf0("MC: failed edac_mc_add_mc()\n");
 		/* FIXME: perhaps some code should go here that disables error
 		 * reporting if we just enabled it
 		 */
@@ -1142,7 +1140,7 @@ static void __devexit i7300_remove_one(struct pci_dev *pdev)
 	struct mem_ctl_info *mci;
 	char *tmp;
 
-	debugf0(__FILE__ ": %s()\n", __func__);
+	debugf0("\n");
 
 	if (i7300_pci)
 		edac_pci_release_generic_ctl(i7300_pci);
@@ -1189,7 +1187,7 @@ static int __init i7300_init(void)
 {
 	int pci_rc;
 
-	debugf2("MC: " __FILE__ ": %s()\n", __func__);
+	debugf2("\n");
 
 	/* Ensure that the OPSTATE is set correctly for POLL or NMI */
 	opstate_init();
@@ -1204,7 +1202,7 @@ static int __init i7300_init(void)
  */
 static void __exit i7300_exit(void)
 {
-	debugf2("MC: " __FILE__ ": %s()\n", __func__);
+	debugf2("\n");
 	pci_unregister_driver(&i7300_driver);
 }
 

commit fd687502dc8037aa5a4b84c570ada971106574ee
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Mar 16 07:44:18 2012 -0300

    edac: Rename the parent dev to pdev
    
    As EDAC doesn't use struct device itself, it created a parent dev
    pointer called as "pdev".  Now that we'll be converting it to use
    struct device, instead of struct devsys, this needs to be fixed.
    
    No functional changes.
    
    Reviewed-by: Aristeu Rozanski <arozansk@redhat.com>
    Acked-by: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Doug Thompson <norsk5@yahoo.com>
    Cc: Borislav Petkov <borislav.petkov@amd.com>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: Jason Uhlenkott <juhlenko@akamai.com>
    Cc: Tim Small <tim@buttersideup.com>
    Cc: Ranganathan Desikan <ravi@jetztechnologies.com>
    Cc: "Arvind R." <arvino55@gmail.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Egor Martovetsky <egor@pasemi.com>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Joe Perches <joe@perches.com>
    Cc: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Hitoshi Mitake <h.mitake@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: "Niklas SÃ¶derlund" <niklas.soderlund@ericsson.com>
    Cc: Shaohui Xie <Shaohui.Xie@freescale.com>
    Cc: Josh Boyer <jwboyer@gmail.com>
    Cc: linuxppc-dev@lists.ozlabs.org
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 97c22fd650ee..db84456e65d9 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -1057,7 +1057,7 @@ static int __devinit i7300_init_one(struct pci_dev *pdev,
 
 	debugf0("MC: " __FILE__ ": %s(): mci = %p\n", __func__, mci);
 
-	mci->dev = &pdev->dev;	/* record ptr  to the generic device */
+	mci->pdev = &pdev->dev;	/* record ptr  to the generic device */
 
 	pvt = mci->pvt_info;
 	pvt->pci_dev_16_0_fsb_ctlr = pdev;	/* Record this device in our private */

commit ca0907b9e413bb1d1f3ea123b663535b74928846
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed May 2 14:37:00 2012 -0300

    edac: Remove the legacy EDAC ABI
    
    Now that all drivers got converted to use the new ABI, we can
    drop the old one.
    
    Acked-by: Chris Metcalf <cmetcalf@tilera.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index c2cf9771692a..97c22fd650ee 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -1051,8 +1051,7 @@ static int __devinit i7300_init_one(struct pci_dev *pdev,
 	layers[2].type = EDAC_MC_LAYER_SLOT;
 	layers[2].size = MAX_SLOTS;
 	layers[2].is_virt_csrow = true;
-	mci = new_edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(*pvt));
-
+	mci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(*pvt));
 	if (mci == NULL)
 		return -ENOMEM;
 

commit 70e2a8379b6e704b2e8cdfcf151954171c36e779
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Apr 16 15:10:05 2012 -0300

    i7300_edac: convert driver to use the new edac ABI
    
    The legacy edac ABI is going to be removed. Port the driver to use
    and benefit from the new API functionality.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index d6f3a2d0f70a..c2cf9771692a 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -464,17 +464,14 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 				FERR_FAT_FBD, error_reg);
 
 		snprintf(pvt->tmp_prt_buffer, PAGE_SIZE,
-			"FATAL (Branch=%d DRAM-Bank=%d %s "
-			"RAS=%d CAS=%d Err=0x%lx (%s))",
-			branch, bank,
-			is_wr ? "RDWR" : "RD",
-			ras, cas,
-			errors, specific);
-
-		/* Call the helper to output message */
-		edac_mc_handle_fbd_ue(mci, rank, branch << 1,
-				      (branch << 1) + 1,
-				      pvt->tmp_prt_buffer);
+			 "Bank=%d RAS=%d CAS=%d Err=0x%lx (%s))",
+			 bank, ras, cas, errors, specific);
+
+		edac_mc_handle_error(HW_EVENT_ERR_FATAL, mci, 0, 0, 0,
+				     branch, -1, rank,
+				     is_wr ? "Write error" : "Read error",
+				     pvt->tmp_prt_buffer, NULL);
+
 	}
 
 	/* read in the 1st NON-FATAL error register */
@@ -513,23 +510,14 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 
 		/* Form out message */
 		snprintf(pvt->tmp_prt_buffer, PAGE_SIZE,
-			"Corrected error (Branch=%d, Channel %d), "
-			" DRAM-Bank=%d %s "
-			"RAS=%d CAS=%d, CE Err=0x%lx, Syndrome=0x%08x(%s))",
-			branch, channel,
-			bank,
-			is_wr ? "RDWR" : "RD",
-			ras, cas,
-			errors, syndrome, specific);
-
-		/*
-		 * Call the helper to output message
-		 * NOTE: Errors are reported per-branch, and not per-channel
-		 *	 Currently, we don't know how to identify the right
-		 *	 channel.
-		 */
-		edac_mc_handle_fbd_ce(mci, rank, channel,
-				      pvt->tmp_prt_buffer);
+			 "DRAM-Bank=%d RAS=%d CAS=%d, Err=0x%lx (%s))",
+			 bank, ras, cas, errors, specific);
+
+		edac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 0, 0,
+				     syndrome,
+				     branch >> 1, channel % 2, rank,
+				     is_wr ? "Write error" : "Read error",
+				     pvt->tmp_prt_buffer, NULL);
 	}
 	return;
 }
@@ -807,9 +795,10 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 			for (ch = 0; ch < MAX_CH_PER_BRANCH; ch++) {
 				int channel = to_channel(ch, branch);
 
-				dinfo = &pvt->dimm_info[slot][channel];
+				dimm = EDAC_DIMM_PTR(mci->layers, mci->dimms,
+					       mci->n_layers, branch, ch, slot);
 
-				dimm = mci->csrows[slot].channels[branch * MAX_CH_PER_BRANCH + ch].dimm;
+				dinfo = &pvt->dimm_info[slot][channel];
 
 				mtr = decode_mtr(pvt, slot, ch, branch,
 						 dinfo, dimm);
@@ -1034,10 +1023,8 @@ static int __devinit i7300_init_one(struct pci_dev *pdev,
 				    const struct pci_device_id *id)
 {
 	struct mem_ctl_info *mci;
+	struct edac_mc_layer layers[3];
 	struct i7300_pvt *pvt;
-	int num_channels;
-	int num_dimms_per_channel;
-	int num_csrows;
 	int rc;
 
 	/* wake up device */
@@ -1054,22 +1041,17 @@ static int __devinit i7300_init_one(struct pci_dev *pdev,
 	if (PCI_FUNC(pdev->devfn) != 0)
 		return -ENODEV;
 
-	/* As we don't have a motherboard identification routine to determine
-	 * actual number of slots/dimms per channel, we thus utilize the
-	 * resource as specified by the chipset. Thus, we might have
-	 * have more DIMMs per channel than actually on the mobo, but this
-	 * allows the driver to support up to the chipset max, without
-	 * some fancy mobo determination.
-	 */
-	num_dimms_per_channel = MAX_SLOTS;
-	num_channels = MAX_CHANNELS;
-	num_csrows = MAX_SLOTS * MAX_CHANNELS;
-
-	debugf0("MC: %s(): Number of - Channels= %d  DIMMS= %d  CSROWS= %d\n",
-		__func__, num_channels, num_dimms_per_channel, num_csrows);
-
 	/* allocate a new MC control structure */
-	mci = edac_mc_alloc(sizeof(*pvt), num_csrows, num_channels, 0);
+	layers[0].type = EDAC_MC_LAYER_BRANCH;
+	layers[0].size = MAX_BRANCHES;
+	layers[0].is_virt_csrow = false;
+	layers[1].type = EDAC_MC_LAYER_CHANNEL;
+	layers[1].size = MAX_CH_PER_BRANCH;
+	layers[1].is_virt_csrow = true;
+	layers[2].type = EDAC_MC_LAYER_SLOT;
+	layers[2].size = MAX_SLOTS;
+	layers[2].is_virt_csrow = true;
+	mci = new_edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(*pvt));
 
 	if (mci == NULL)
 		return -ENOMEM;

commit a895bf8b1e1ea4c032a8fa8a09475a2ce09fe77a
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Jan 28 09:09:38 2012 -0300

    edac: move nr_pages to dimm struct
    
    The number of pages is a dimm property. Move it to the dimm struct.
    
    After this change, it is possible to add sysfs nodes for the DIMM's that
    will properly represent the DIMM stick properties, including its size.
    
    A TODO fix here is to properly represent dual-rank/quad-rank DIMMs when
    the memory controller represents the memory via chip select rows.
    
    Reviewed-by: Aristeu Rozanski <arozansk@redhat.com>
    Acked-by: Borislav Petkov <borislav.petkov@amd.com>
    Acked-by: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Doug Thompson <norsk5@yahoo.com>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: Jason Uhlenkott <juhlenko@akamai.com>
    Cc: Tim Small <tim@buttersideup.com>
    Cc: Ranganathan Desikan <ravi@jetztechnologies.com>
    Cc: "Arvind R." <arvino55@gmail.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Egor Martovetsky <egor@pasemi.com>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Joe Perches <joe@perches.com>
    Cc: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Hitoshi Mitake <h.mitake@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: "Niklas SÃ¶derlund" <niklas.soderlund@ericsson.com>
    Cc: Shaohui Xie <Shaohui.Xie@freescale.com>
    Cc: Josh Boyer <jwboyer@gmail.com>
    Cc: linuxppc-dev@lists.ozlabs.org
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index d4153d6cfe30..d6f3a2d0f70a 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -617,9 +617,7 @@ static void i7300_enable_error_reporting(struct mem_ctl_info *mci)
 static int decode_mtr(struct i7300_pvt *pvt,
 		      int slot, int ch, int branch,
 		      struct i7300_dimm_info *dinfo,
-		      struct csrow_info *p_csrow,
-		      struct dimm_info *dimm,
-		      u32 *nr_pages)
+		      struct dimm_info *dimm)
 {
 	int mtr, ans, addrBits, channel;
 
@@ -651,7 +649,6 @@ static int decode_mtr(struct i7300_pvt *pvt,
 	addrBits -= 3;	/* 8 bits per bytes */
 
 	dinfo->megabytes = 1 << addrBits;
-	*nr_pages = dinfo->megabytes << 8;
 
 	debugf2("\t\tWIDTH: x%d\n", MTR_DRAM_WIDTH(mtr));
 
@@ -664,8 +661,6 @@ static int decode_mtr(struct i7300_pvt *pvt,
 	debugf2("\t\tNUMCOL: %s\n", numcol_toString[MTR_DIMM_COLS(mtr)]);
 	debugf2("\t\tSIZE: %d MB\n", dinfo->megabytes);
 
-	p_csrow->csrow_idx = slot;
-
 	/*
 	 * The type of error detection actually depends of the
 	 * mode of operation. When it is just one single memory chip, at
@@ -675,6 +670,7 @@ static int decode_mtr(struct i7300_pvt *pvt,
 	 * See datasheet Sections 7.3.6 to 7.3.8
 	 */
 
+	dimm->nr_pages = MiB_TO_PAGES(dinfo->megabytes);
 	dimm->grain = 8;
 	dimm->mtype = MEM_FB_DDR2;
 	if (IS_SINGLE_MODE(pvt->mc_settings_a)) {
@@ -774,11 +770,9 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 {
 	struct i7300_pvt *pvt;
 	struct i7300_dimm_info *dinfo;
-	struct csrow_info *p_csrow;
 	int rc = -ENODEV;
 	int mtr;
 	int ch, branch, slot, channel;
-	u32 nr_pages;
 	struct dimm_info *dimm;
 
 	pvt = mci->pvt_info;
@@ -804,7 +798,6 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 	}
 
 	/* Get the set of MTR[0-7] regs by each branch */
-	nr_pages = 0;
 	for (slot = 0; slot < MAX_SLOTS; slot++) {
 		int where = mtr_regs[slot];
 		for (branch = 0; branch < MAX_BRANCHES; branch++) {
@@ -815,21 +808,18 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 				int channel = to_channel(ch, branch);
 
 				dinfo = &pvt->dimm_info[slot][channel];
-				p_csrow = &mci->csrows[slot];
 
-				dimm = p_csrow->channels[branch * MAX_CH_PER_BRANCH + ch].dimm;
+				dimm = mci->csrows[slot].channels[branch * MAX_CH_PER_BRANCH + ch].dimm;
 
 				mtr = decode_mtr(pvt, slot, ch, branch,
-						 dinfo, p_csrow, dimm,
-						 &nr_pages);
+						 dinfo, dimm);
+
 				/* if no DIMMS on this row, continue */
 				if (!MTR_DIMMS_PRESENT(mtr))
 					continue;
 
-				/* Update per_csrow memory count */
-				p_csrow->nr_pages += nr_pages;
-
 				rc = 0;
+
 			}
 		}
 	}

commit 5e2af0c09e60d11dd8297e259a9ca2b3d92d2cf4
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Jan 27 21:20:32 2012 -0300

    edac: Don't initialize csrow's first_page & friends when not needed
    
    Almost all edac drivers initialize csrow_info->first_page,
    csrow_info->last_page and csrow_info->page_mask. Those vars are
    used inside the EDAC core, in order to calculate the csrow affected
    by an error, by using the routine edac_mc_find_csrow_by_page().
    
    However, very few drivers actually use it:
            e752x_edac.c
            e7xxx_edac.c
            i3000_edac.c
            i82443bxgx_edac.c
            i82860_edac.c
            i82875p_edac.c
            i82975x_edac.c
            r82600_edac.c
    
    There also a few other drivers that have their own calculus
    formula internally using those vars.
    
    All the others are just wasting time by initializing those
    data.
    
    While initializing data without using them won't cause any troubles, as
    those information is stored at the wrong place (at csrows structure), it
    is better to remove what is unused, in order to simplify the next patch.
    
    Reviewed-by: Aristeu Rozanski <arozansk@redhat.com>
    Acked-by: Borislav Petkov <borislav.petkov@amd.com>
    Acked-by: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Doug Thompson <norsk5@yahoo.com>
    Cc: Hitoshi Mitake <h.mitake@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: "Niklas SÃ¶derlund" <niklas.soderlund@ericsson.com>
    Cc: Josh Boyer <jwboyer@gmail.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 4bfcb3da3f01..d4153d6cfe30 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -778,7 +778,7 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 	int rc = -ENODEV;
 	int mtr;
 	int ch, branch, slot, channel;
-	u32 last_page = 0, nr_pages;
+	u32 nr_pages;
 	struct dimm_info *dimm;
 
 	pvt = mci->pvt_info;
@@ -828,9 +828,6 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 
 				/* Update per_csrow memory count */
 				p_csrow->nr_pages += nr_pages;
-				p_csrow->first_page = last_page;
-				last_page += nr_pages;
-				p_csrow->last_page = last_page;
 
 				rc = 0;
 			}

commit 084a4fccef39ac7abb039511f32380f28d0b67e6
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Jan 27 18:38:08 2012 -0300

    edac: move dimm properties to struct dimm_info
    
    On systems based on chip select rows, all channels need to use memories
    with the same properties, otherwise the memories on channels A and B
    won't be recognized.
    
    However, such assumption is not true for all types of memory
    controllers.
    
    Controllers for FB-DIMM's don't have such requirements.
    
    Also, modern Intel controllers seem to be capable of handling such
    differences.
    
    So, we need to get rid of storing the DIMM information into a per-csrow
    data, storing it, instead at the right place.
    
    The first step is to move grain, mtype, dtype and edac_mode to the
    per-dimm struct.
    
    Reviewed-by: Aristeu Rozanski <arozansk@redhat.com>
    Reviewed-by: Borislav Petkov <borislav.petkov@amd.com>
    Acked-by: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Doug Thompson <norsk5@yahoo.com>
    Cc: Borislav Petkov <borislav.petkov@amd.com>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: Jason Uhlenkott <juhlenko@akamai.com>
    Cc: Tim Small <tim@buttersideup.com>
    Cc: Ranganathan Desikan <ravi@jetztechnologies.com>
    Cc: "Arvind R." <arvino55@gmail.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Egor Martovetsky <egor@pasemi.com>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Joe Perches <joe@perches.com>
    Cc: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Hitoshi Mitake <h.mitake@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: James Bottomley <James.Bottomley@parallels.com>
    Cc: "Niklas SÃ¶derlund" <niklas.soderlund@ericsson.com>
    Cc: Shaohui Xie <Shaohui.Xie@freescale.com>
    Cc: Josh Boyer <jwboyer@gmail.com>
    Cc: Mike Williams <mike@mikebwilliams.com>
    Cc: linuxppc-dev@lists.ozlabs.org
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 3bafa3bca148..4bfcb3da3f01 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -618,6 +618,7 @@ static int decode_mtr(struct i7300_pvt *pvt,
 		      int slot, int ch, int branch,
 		      struct i7300_dimm_info *dinfo,
 		      struct csrow_info *p_csrow,
+		      struct dimm_info *dimm,
 		      u32 *nr_pages)
 {
 	int mtr, ans, addrBits, channel;
@@ -663,10 +664,7 @@ static int decode_mtr(struct i7300_pvt *pvt,
 	debugf2("\t\tNUMCOL: %s\n", numcol_toString[MTR_DIMM_COLS(mtr)]);
 	debugf2("\t\tSIZE: %d MB\n", dinfo->megabytes);
 
-	p_csrow->grain = 8;
-	p_csrow->mtype = MEM_FB_DDR2;
 	p_csrow->csrow_idx = slot;
-	p_csrow->page_mask = 0;
 
 	/*
 	 * The type of error detection actually depends of the
@@ -677,15 +675,17 @@ static int decode_mtr(struct i7300_pvt *pvt,
 	 * See datasheet Sections 7.3.6 to 7.3.8
 	 */
 
+	dimm->grain = 8;
+	dimm->mtype = MEM_FB_DDR2;
 	if (IS_SINGLE_MODE(pvt->mc_settings_a)) {
-		p_csrow->edac_mode = EDAC_SECDED;
+		dimm->edac_mode = EDAC_SECDED;
 		debugf2("\t\tECC code is 8-byte-over-32-byte SECDED+ code\n");
 	} else {
 		debugf2("\t\tECC code is on Lockstep mode\n");
 		if (MTR_DRAM_WIDTH(mtr) == 8)
-			p_csrow->edac_mode = EDAC_S8ECD8ED;
+			dimm->edac_mode = EDAC_S8ECD8ED;
 		else
-			p_csrow->edac_mode = EDAC_S4ECD4ED;
+			dimm->edac_mode = EDAC_S4ECD4ED;
 	}
 
 	/* ask what device type on this row */
@@ -694,9 +694,9 @@ static int decode_mtr(struct i7300_pvt *pvt,
 			IS_SCRBALGO_ENHANCED(pvt->mc_settings) ?
 					    "enhanced" : "normal");
 
-		p_csrow->dtype = DEV_X8;
+		dimm->dtype = DEV_X8;
 	} else
-		p_csrow->dtype = DEV_X4;
+		dimm->dtype = DEV_X4;
 
 	return mtr;
 }
@@ -779,6 +779,7 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 	int mtr;
 	int ch, branch, slot, channel;
 	u32 last_page = 0, nr_pages;
+	struct dimm_info *dimm;
 
 	pvt = mci->pvt_info;
 
@@ -803,20 +804,24 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 	}
 
 	/* Get the set of MTR[0-7] regs by each branch */
+	nr_pages = 0;
 	for (slot = 0; slot < MAX_SLOTS; slot++) {
 		int where = mtr_regs[slot];
 		for (branch = 0; branch < MAX_BRANCHES; branch++) {
 			pci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],
 					where,
 					&pvt->mtr[slot][branch]);
-			for (ch = 0; ch < MAX_BRANCHES; ch++) {
+			for (ch = 0; ch < MAX_CH_PER_BRANCH; ch++) {
 				int channel = to_channel(ch, branch);
 
 				dinfo = &pvt->dimm_info[slot][channel];
 				p_csrow = &mci->csrows[slot];
 
+				dimm = p_csrow->channels[branch * MAX_CH_PER_BRANCH + ch].dimm;
+
 				mtr = decode_mtr(pvt, slot, ch, branch,
-						 dinfo, p_csrow, &nr_pages);
+						 dinfo, p_csrow, dimm,
+						 &nr_pages);
 				/* if no DIMMS on this row, continue */
 				if (!MTR_DIMMS_PRESENT(mtr))
 					continue;

commit 36c46f31df910b092aaaed27c7c616bb8e2302a1
Author: Lionel Debroux <lionel_debroux@yahoo.fr>
Date:   Mon Feb 27 07:41:47 2012 +0100

    EDAC: Make pci_device_id tables __devinitconst.
    
    These const tables are currently marked __devinitdata, but
    Documentation/PCI/pci.txt says:
    
    "o The ID table array should be marked __devinitconst; this is done
    automatically if the table is declared with DEFINE_PCI_DEVICE_TABLE()."
    
    So use DEFINE_PCI_DEVICE_TABLE(x).
    
    Based on PaX and earlier work by Andi Kleen.
    
    Signed-off-by: Lionel Debroux <lionel_debroux@yahoo.fr>
    Signed-off-by: Borislav Petkov <borislav.petkov@amd.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 6104dba380b6..3bafa3bca148 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -1192,7 +1192,7 @@ static void __devexit i7300_remove_one(struct pci_dev *pdev)
  *
  * Has only 8086:360c PCI ID
  */
-static const struct pci_device_id i7300_pci_tbl[] __devinitdata = {
+static DEFINE_PCI_DEVICE_TABLE(i7300_pci_tbl) = {
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I7300_MCH_ERR)},
 	{0,}			/* 0 terminated list. */
 };

commit 5f032119d6f1cc48d0d1a28b8014f270ca4c4e47
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 13 14:09:11 2011 -0300

    i7300_edac: Fix error cleanup logic
    
    The error cleanup logic was broken. Due to that, one error is generated for
    every error polling.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index a76fe8366b68..6104dba380b6 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -372,7 +372,7 @@ static const char *get_err_from_table(const char *table[], int size, int pos)
 static void i7300_process_error_global(struct mem_ctl_info *mci)
 {
 	struct i7300_pvt *pvt;
-	u32 errnum, value;
+	u32 errnum, error_reg;
 	unsigned long errors;
 	const char *specific;
 	bool is_fatal;
@@ -381,9 +381,9 @@ static void i7300_process_error_global(struct mem_ctl_info *mci)
 
 	/* read in the 1st FATAL error register */
 	pci_read_config_dword(pvt->pci_dev_16_2_fsb_err_regs,
-			      FERR_GLOBAL_HI, &value);
-	if (unlikely(value)) {
-		errors = value;
+			      FERR_GLOBAL_HI, &error_reg);
+	if (unlikely(error_reg)) {
+		errors = error_reg;
 		errnum = find_first_bit(&errors,
 					ARRAY_SIZE(ferr_global_hi_name));
 		specific = GET_ERR_FROM_TABLE(ferr_global_hi_name, errnum);
@@ -391,15 +391,15 @@ static void i7300_process_error_global(struct mem_ctl_info *mci)
 
 		/* Clear the error bit */
 		pci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,
-				       FERR_GLOBAL_HI, value);
+				       FERR_GLOBAL_HI, error_reg);
 
 		goto error_global;
 	}
 
 	pci_read_config_dword(pvt->pci_dev_16_2_fsb_err_regs,
-			      FERR_GLOBAL_LO, &value);
-	if (unlikely(value)) {
-		errors = value;
+			      FERR_GLOBAL_LO, &error_reg);
+	if (unlikely(error_reg)) {
+		errors = error_reg;
 		errnum = find_first_bit(&errors,
 					ARRAY_SIZE(ferr_global_lo_name));
 		specific = GET_ERR_FROM_TABLE(ferr_global_lo_name, errnum);
@@ -407,7 +407,7 @@ static void i7300_process_error_global(struct mem_ctl_info *mci)
 
 		/* Clear the error bit */
 		pci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,
-				       FERR_GLOBAL_LO, value);
+				       FERR_GLOBAL_LO, error_reg);
 
 		goto error_global;
 	}
@@ -427,7 +427,7 @@ static void i7300_process_error_global(struct mem_ctl_info *mci)
 static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 {
 	struct i7300_pvt *pvt;
-	u32 errnum, value;
+	u32 errnum, value, error_reg;
 	u16 val16;
 	unsigned branch, channel, bank, rank, cas, ras;
 	u32 syndrome;
@@ -440,14 +440,14 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 
 	/* read in the 1st FATAL error register */
 	pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
-			      FERR_FAT_FBD, &value);
-	if (unlikely(value & FERR_FAT_FBD_ERR_MASK)) {
-		errors = value & FERR_FAT_FBD_ERR_MASK ;
+			      FERR_FAT_FBD, &error_reg);
+	if (unlikely(error_reg & FERR_FAT_FBD_ERR_MASK)) {
+		errors = error_reg & FERR_FAT_FBD_ERR_MASK ;
 		errnum = find_first_bit(&errors,
 					ARRAY_SIZE(ferr_fat_fbd_name));
 		specific = GET_ERR_FROM_TABLE(ferr_fat_fbd_name, errnum);
+		branch = (GET_FBD_FAT_IDX(error_reg) == 2) ? 1 : 0;
 
-		branch = (GET_FBD_FAT_IDX(value) == 2) ? 1 : 0;
 		pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map,
 				     NRECMEMA, &val16);
 		bank = NRECMEMA_BANK(val16);
@@ -455,11 +455,14 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 
 		pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
 				NRECMEMB, &value);
-
 		is_wr = NRECMEMB_IS_WR(value);
 		cas = NRECMEMB_CAS(value);
 		ras = NRECMEMB_RAS(value);
 
+		/* Clean the error register */
+		pci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
+				FERR_FAT_FBD, error_reg);
+
 		snprintf(pvt->tmp_prt_buffer, PAGE_SIZE,
 			"FATAL (Branch=%d DRAM-Bank=%d %s "
 			"RAS=%d CAS=%d Err=0x%lx (%s))",
@@ -476,21 +479,17 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 
 	/* read in the 1st NON-FATAL error register */
 	pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
-			      FERR_NF_FBD, &value);
-	if (unlikely(value & FERR_NF_FBD_ERR_MASK)) {
-		errors = value & FERR_NF_FBD_ERR_MASK;
+			      FERR_NF_FBD, &error_reg);
+	if (unlikely(error_reg & FERR_NF_FBD_ERR_MASK)) {
+		errors = error_reg & FERR_NF_FBD_ERR_MASK;
 		errnum = find_first_bit(&errors,
 					ARRAY_SIZE(ferr_nf_fbd_name));
 		specific = GET_ERR_FROM_TABLE(ferr_nf_fbd_name, errnum);
-
-		/* Clear the error bit */
-		pci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,
-				       FERR_GLOBAL_LO, value);
+		branch = (GET_FBD_FAT_IDX(error_reg) == 2) ? 1 : 0;
 
 		pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
 			REDMEMA, &syndrome);
 
-		branch = (GET_FBD_FAT_IDX(value) == 2) ? 1 : 0;
 		pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map,
 				     RECMEMA, &val16);
 		bank = RECMEMA_BANK(val16);
@@ -498,18 +497,20 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 
 		pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
 				RECMEMB, &value);
-
 		is_wr = RECMEMB_IS_WR(value);
 		cas = RECMEMB_CAS(value);
 		ras = RECMEMB_RAS(value);
 
 		pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
 				     REDMEMB, &value);
-
 		channel = (branch << 1);
 		if (IS_SECOND_CH(value))
 			channel++;
 
+		/* Clear the error bit */
+		pci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
+				FERR_NF_FBD, error_reg);
+
 		/* Form out message */
 		snprintf(pvt->tmp_prt_buffer, PAGE_SIZE,
 			"Corrected error (Branch=%d, Channel %d), "

commit b7c2f036284452627d793af981877817b37d4351
Merge: 14587a2a2544 8d2c50e3b65c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 26 13:19:00 2011 -0700

    Merge branch 'trivial' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild-2.6
    
    * 'trivial' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild-2.6:
      gfs2: Drop __TIME__ usage
      isdn/diva: Drop __TIME__ usage
      atm: Drop __TIME__ usage
      dlm: Drop __TIME__ usage
      wan/pc300: Drop __TIME__ usage
      parport: Drop __TIME__ usage
      hdlcdrv: Drop __TIME__ usage
      baycom: Drop __TIME__ usage
      pmcraid: Drop __DATE__ usage
      edac: Drop __DATE__ usage
      rio: Drop __DATE__ usage
      scsi/wd33c93: Drop __TIME__ usage
      scsi/in2000: Drop __TIME__ usage
      aacraid: Drop __TIME__ usage
      media/cx231xx: Drop __TIME__ usage
      media/radio-maxiradio: Drop __TIME__ usage
      nozomi: Drop __TIME__ usage
      cyclades: Drop __TIME__ usage

commit 152ba3942276c2a240703669ae4a3099e0a79451
Author: Michal Marek <mmarek@suse.cz>
Date:   Fri Apr 1 12:41:20 2011 +0200

    edac: Drop __DATE__ usage
    
    The kernel already prints its build timestamp during boot, no need to
    repeat it in random drivers and produce different object files each
    time.
    
    Cc: Doug Thompson <dougthompson@xmission.com>
    Cc: bluesmoke-devel@lists.sourceforge.net
    Cc: linux-edac@vger.kernel.org
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 76d1f576cdc8..ff320c0b9cac 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -31,7 +31,7 @@
 /*
  * Alter this version for the I7300 module when modifications are made
  */
-#define I7300_REVISION    " Ver: 1.0.0 " __DATE__
+#define I7300_REVISION    " Ver: 1.0.0"
 
 #define EDAC_MOD_STR      "i7300_edac"
 

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 76d1f576cdc8..363cc1602944 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -1065,7 +1065,7 @@ static int __devinit i7300_init_one(struct pci_dev *pdev,
 	 * actual number of slots/dimms per channel, we thus utilize the
 	 * resource as specified by the chipset. Thus, we might have
 	 * have more DIMMs per channel than actually on the mobo, but this
-	 * allows the driver to support upto the chipset max, without
+	 * allows the driver to support up to the chipset max, without
 	 * some fancy mobo determination.
 	 */
 	num_dimms_per_channel = MAX_SLOTS;

commit 42b16b3fbb5ee4555f5dee6220f3ccaa6e1ebe47
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Mon Jan 17 00:09:38 2011 +0100

    Kill off warning: âinlineâ is not at beginning of declaration
    
    Fix a bunch of
            warning: âinlineâ is not at beginning of declaration
    messages when building a 'make allyesconfig' kernel with -Wextra.
    
    These warnings are trivial to kill, yet rather annoying when building with
    -Wextra.
    The more we can cut down on pointless crap like this the better (IMHO).
    
    A previous patch to do this for a 'allnoconfig' build has already been
    merged. This just takes the cleanup a little further.
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 05523b504271..76d1f576cdc8 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -162,7 +162,7 @@ static struct edac_pci_ctl_info *i7300_pci;
 #define AMBPRESENT_0	0x64
 #define AMBPRESENT_1	0x66
 
-const static u16 mtr_regs[MAX_SLOTS] = {
+static const u16 mtr_regs[MAX_SLOTS] = {
 	0x80, 0x84, 0x88, 0x8c,
 	0x82, 0x86, 0x8a, 0x8e
 };

commit e6649cc62949f1ed473bf1131fa425cfe72d3f64
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Sep 24 11:53:52 2010 -0300

    i7300_edac: Properly initialize per-csrow memory size
    
    Due to the current edac-core limits, we cannot represent a per-channel
    memory size, for FB-DIMM drivers. So, we need to sum-up all values
    for each slot, in order to properly represent the total amount of
    memory found by the i7300 driver.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 38d9cb8fad7c..05523b504271 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -617,7 +617,7 @@ static int decode_mtr(struct i7300_pvt *pvt,
 		      int slot, int ch, int branch,
 		      struct i7300_dimm_info *dinfo,
 		      struct csrow_info *p_csrow,
-		      u32 *last_page)
+		      u32 *nr_pages)
 {
 	int mtr, ans, addrBits, channel;
 
@@ -649,6 +649,7 @@ static int decode_mtr(struct i7300_pvt *pvt,
 	addrBits -= 3;	/* 8 bits per bytes */
 
 	dinfo->megabytes = 1 << addrBits;
+	*nr_pages = dinfo->megabytes << 8;
 
 	debugf2("\t\tWIDTH: x%d\n", MTR_DRAM_WIDTH(mtr));
 
@@ -662,12 +663,8 @@ static int decode_mtr(struct i7300_pvt *pvt,
 	debugf2("\t\tSIZE: %d MB\n", dinfo->megabytes);
 
 	p_csrow->grain = 8;
-	p_csrow->nr_pages = dinfo->megabytes << 8;
 	p_csrow->mtype = MEM_FB_DDR2;
 	p_csrow->csrow_idx = slot;
-	p_csrow->first_page = *last_page;
-	*last_page += p_csrow->nr_pages;
-	p_csrow->last_page = *last_page;
 	p_csrow->page_mask = 0;
 
 	/*
@@ -780,7 +777,7 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 	int rc = -ENODEV;
 	int mtr;
 	int ch, branch, slot, channel;
-	u32 last_page = 0;
+	u32 last_page = 0, nr_pages;
 
 	pvt = mci->pvt_info;
 
@@ -818,11 +815,17 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 				p_csrow = &mci->csrows[slot];
 
 				mtr = decode_mtr(pvt, slot, ch, branch,
-						 dinfo, p_csrow, &last_page);
+						 dinfo, p_csrow, &nr_pages);
 				/* if no DIMMS on this row, continue */
 				if (!MTR_DIMMS_PRESENT(mtr))
 					continue;
 
+				/* Update per_csrow memory count */
+				p_csrow->nr_pages += nr_pages;
+				p_csrow->first_page = last_page;
+				last_page += nr_pages;
+				p_csrow->last_page = last_page;
+
 				rc = 0;
 			}
 		}

commit 1aa4a7b6b082adbfa704988dd098bc96b8837d5a
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Sep 24 11:29:02 2010 -0300

    V4L/DVB: i7300_edac: better initialize page counts
    
    It is still somewhat fake, as the pages may not be on this exact order,
    and may even be used in mirror mode, but this is a best guess than the
    other random fake values.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 38920c0b5fbb..38d9cb8fad7c 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -616,7 +616,8 @@ static void i7300_enable_error_reporting(struct mem_ctl_info *mci)
 static int decode_mtr(struct i7300_pvt *pvt,
 		      int slot, int ch, int branch,
 		      struct i7300_dimm_info *dinfo,
-		      struct csrow_info *p_csrow)
+		      struct csrow_info *p_csrow,
+		      u32 *last_page)
 {
 	int mtr, ans, addrBits, channel;
 
@@ -663,6 +664,11 @@ static int decode_mtr(struct i7300_pvt *pvt,
 	p_csrow->grain = 8;
 	p_csrow->nr_pages = dinfo->megabytes << 8;
 	p_csrow->mtype = MEM_FB_DDR2;
+	p_csrow->csrow_idx = slot;
+	p_csrow->first_page = *last_page;
+	*last_page += p_csrow->nr_pages;
+	p_csrow->last_page = *last_page;
+	p_csrow->page_mask = 0;
 
 	/*
 	 * The type of error detection actually depends of the
@@ -774,6 +780,7 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 	int rc = -ENODEV;
 	int mtr;
 	int ch, branch, slot, channel;
+	u32 last_page = 0;
 
 	pvt = mci->pvt_info;
 
@@ -811,18 +818,11 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 				p_csrow = &mci->csrows[slot];
 
 				mtr = decode_mtr(pvt, slot, ch, branch,
-							dinfo, p_csrow);
+						 dinfo, p_csrow, &last_page);
 				/* if no DIMMS on this row, continue */
 				if (!MTR_DIMMS_PRESENT(mtr))
 					continue;
 
-				p_csrow->csrow_idx = slot;
-
-				/* FAKE OUT VALUES, FIXME */
-				p_csrow->first_page = 0 + slot * 20;
-				p_csrow->last_page = 9 + slot * 20;
-				p_csrow->page_mask = 0xfff;
-
 				rc = 0;
 			}
 		}

commit 9c6f6b65d25aa7fe890377a92ea049c8e20da906
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 27 17:43:43 2010 -0300

    i7300-edac: CodingStyle cleanup
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index a2a9ad499b6b..38920c0b5fbb 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -104,7 +104,7 @@ struct i7300_pvt {
 
 	u16 mir[MAX_MIR];			/* Memory Interleave Reg*/
 
-	u16 mtr[MAX_SLOTS][MAX_BRANCHES];		/* Memory Technlogy Reg */
+	u16 mtr[MAX_SLOTS][MAX_BRANCHES];	/* Memory Technlogy Reg */
 	u16 ambpresent[MAX_CHANNELS];		/* AMB present regs */
 
 	/* DIMM information matrix, allocating architecture maximums */
@@ -162,7 +162,7 @@ static struct edac_pci_ctl_info *i7300_pci;
 #define AMBPRESENT_0	0x64
 #define AMBPRESENT_1	0x66
 
-const static u16 mtr_regs [MAX_SLOTS] = {
+const static u16 mtr_regs[MAX_SLOTS] = {
 	0x80, 0x84, 0x88, 0x8c,
 	0x82, 0x86, 0x8a, 0x8e
 };
@@ -726,7 +726,7 @@ static void print_dimm_size(struct i7300_pvt *pvt)
 	p = pvt->tmp_prt_buffer;
 	space = PAGE_SIZE;
 	n = snprintf(p, space, "-------------------------------"
-		               "------------------------------");
+			       "------------------------------");
 	p += n;
 	space -= n;
 	debugf2("%s\n", pvt->tmp_prt_buffer);
@@ -751,7 +751,7 @@ static void print_dimm_size(struct i7300_pvt *pvt)
 	}
 
 	n = snprintf(p, space, "-------------------------------"
-		               "------------------------------");
+			       "------------------------------");
 	p += n;
 	space -= n;
 	debugf2("%s\n", pvt->tmp_prt_buffer);
@@ -783,13 +783,15 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 	for (branch = 0; branch < MAX_BRANCHES; branch++) {
 		/* Read and dump branch 0's MTRs */
 		channel = to_channel(0, branch);
-		pci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch], AMBPRESENT_0,
+		pci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],
+				     AMBPRESENT_0,
 				&pvt->ambpresent[channel]);
 		debugf2("\t\tAMB-present CH%d = 0x%x:\n",
 			channel, pvt->ambpresent[channel]);
 
 		channel = to_channel(1, branch);
-		pci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch], AMBPRESENT_1,
+		pci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],
+				     AMBPRESENT_1,
 				&pvt->ambpresent[channel]);
 		debugf2("\t\tAMB-present CH%d = 0x%x:\n",
 			channel, pvt->ambpresent[channel]);
@@ -837,11 +839,12 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 static void decode_mir(int mir_no, u16 mir[MAX_MIR])
 {
 	if (mir[mir_no] & 3)
-		debugf2("MIR%d: limit= 0x%x Branch(es) that participate: %s %s\n",
+		debugf2("MIR%d: limit= 0x%x Branch(es) that participate:"
+			" %s %s\n",
 			mir_no,
 			(mir[mir_no] >> 4) & 0xfff,
 			(mir[mir_no] & 1) ? "B0" : "",
-			(mir[mir_no] & 2) ? "B1": "");
+			(mir[mir_no] & 2) ? "B1" : "");
 }
 
 /**
@@ -891,9 +894,12 @@ static int i7300_get_mc_regs(struct mem_ctl_info *mci)
 		IS_RETRY_ENABLED(pvt->mc_settings) ? "enabled" : "disabled");
 
 	/* Get Memory Interleave Range registers */
-	pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR0, &pvt->mir[0]);
-	pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR1, &pvt->mir[1]);
-	pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR2, &pvt->mir[2]);
+	pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR0,
+			     &pvt->mir[0]);
+	pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR1,
+			     &pvt->mir[1]);
+	pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR2,
+			     &pvt->mir[2]);
 
 	/* Decode the MIR regs */
 	for (i = 0; i < MAX_MIR; i++)
@@ -952,7 +958,8 @@ static int __devinit i7300_get_devices(struct mem_ctl_info *mci)
 
 	/* Attempt to 'get' the MCH register we want */
 	pdev = NULL;
-	while (!pvt->pci_dev_16_1_fsb_addr_map || !pvt->pci_dev_16_2_fsb_err_regs) {
+	while (!pvt->pci_dev_16_1_fsb_addr_map ||
+	       !pvt->pci_dev_16_2_fsb_err_regs) {
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_I7300_MCH_ERR, pdev);
 		if (!pdev) {
@@ -980,16 +987,19 @@ static int __devinit i7300_get_devices(struct mem_ctl_info *mci)
 
 	debugf1("System Address, processor bus- PCI Bus ID: %s  %x:%x\n",
 		pci_name(pvt->pci_dev_16_0_fsb_ctlr),
-		pvt->pci_dev_16_0_fsb_ctlr->vendor, pvt->pci_dev_16_0_fsb_ctlr->device);
+		pvt->pci_dev_16_0_fsb_ctlr->vendor,
+		pvt->pci_dev_16_0_fsb_ctlr->device);
 	debugf1("Branchmap, control and errors - PCI Bus ID: %s  %x:%x\n",
 		pci_name(pvt->pci_dev_16_1_fsb_addr_map),
-		pvt->pci_dev_16_1_fsb_addr_map->vendor, pvt->pci_dev_16_1_fsb_addr_map->device);
+		pvt->pci_dev_16_1_fsb_addr_map->vendor,
+		pvt->pci_dev_16_1_fsb_addr_map->device);
 	debugf1("FSB Error Regs - PCI Bus ID: %s  %x:%x\n",
 		pci_name(pvt->pci_dev_16_2_fsb_err_regs),
-		pvt->pci_dev_16_2_fsb_err_regs->vendor, pvt->pci_dev_16_2_fsb_err_regs->device);
+		pvt->pci_dev_16_2_fsb_err_regs->vendor,
+		pvt->pci_dev_16_2_fsb_err_regs->device);
 
 	pvt->pci_dev_2x_0_fbd_branch[0] = pci_get_device(PCI_VENDOR_ID_INTEL,
-				            PCI_DEVICE_ID_INTEL_I7300_MCH_FB0,
+					    PCI_DEVICE_ID_INTEL_I7300_MCH_FB0,
 					    NULL);
 	if (!pvt->pci_dev_2x_0_fbd_branch[0]) {
 		i7300_printk(KERN_ERR,

commit d091a6eb177dd3da8f55f8fd73c5b80db0e1656f
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 27 17:28:50 2010 -0300

    i7300_edac: Improve comments
    
    This is basically a cleanup patch, improving the comments for each
    function.
    
    While here, do a few cleanups.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 6278209fec07..a2a9ad499b6b 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -121,14 +121,6 @@ static struct edac_pci_ctl_info *i7300_pci;
  * i7300 Register definitions for memory enumeration
  ***************************************************/
 
-/*
- * I7300 devices:
- * All 3 functions of Device 16 (0,1,2) share the SAME DID and
- * uses PCI_DEVICE_ID_INTEL_I7300_MCH_ERR for device 16 (0,1,2).
- * PCI_DEVICE_ID_INTEL_I7300_MCH_FB0 is used for device 21 (0,1)
- * and PCI_DEVICE_ID_INTEL_I7300_MCH_FB1 is used for device 21 (0,1).
- */
-
 /*
  * Device 16,
  * Function 0: System Address (not documented)
@@ -345,9 +337,24 @@ static const char *ferr_global_lo_name[] = {
  * i7300 Functions related to error detection
  ********************************************/
 
-const char *get_err_from_table(const char *table[], int size, int pos)
+/**
+ * get_err_from_table() - Gets the error message from a table
+ * @table:	table name (array of char *)
+ * @size:	number of elements at the table
+ * @pos:	position of the element to be returned
+ *
+ * This is a small routine that gets the pos-th element of a table. If the
+ * element doesn't exist (or it is empty), it returns "reserved".
+ * Instead of calling it directly, the better is to call via the macro
+ * GET_ERR_FROM_TABLE(), that automatically checks the table size via
+ * ARRAY_SIZE() macro
+ */
+static const char *get_err_from_table(const char *table[], int size, int pos)
 {
-	if (pos >= size)
+	if (unlikely(pos >= size))
+		return "Reserved";
+
+	if (unlikely(!table[pos]))
 		return "Reserved";
 
 	return table[pos];
@@ -356,10 +363,11 @@ const char *get_err_from_table(const char *table[], int size, int pos)
 #define GET_ERR_FROM_TABLE(table, pos)				\
 	get_err_from_table(table, ARRAY_SIZE(table), pos)
 
-/*
- *	i7300_process_error_global Retrieve the hardware error information from
- *				the hardware and cache it in the 'info'
- *				structure
+/**
+ * i7300_process_error_global() - Retrieve the hardware error information from
+ *				  the hardware global error registers and
+ *				  sends it to dmesg
+ * @mci: struct mem_ctl_info pointer
  */
 static void i7300_process_error_global(struct mem_ctl_info *mci)
 {
@@ -410,10 +418,11 @@ static void i7300_process_error_global(struct mem_ctl_info *mci)
 			is_fatal ? "Fatal" : "NOT fatal", specific);
 }
 
-/*
- *	i7300_process_fbd_error Retrieve the hardware error information from
- *				the hardware and cache it in the 'info'
- *				structure
+/**
+ * i7300_process_fbd_error() - Retrieve the hardware error information from
+ *			       the FBD error registers and sends it via
+ *			       EDAC error API calls
+ * @mci: struct mem_ctl_info pointer
  */
 static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 {
@@ -524,10 +533,9 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 	return;
 }
 
-/*
- *	i7300_check_error Retrieve the hardware error information from
- *				the hardware and cache it in the 'info'
- *				structure
+/**
+ * i7300_check_error() - Calls the error checking subroutines
+ * @mci: struct mem_ctl_info pointer
  */
 static void i7300_check_error(struct mem_ctl_info *mci)
 {
@@ -535,11 +543,9 @@ static void i7300_check_error(struct mem_ctl_info *mci)
 	i7300_process_fbd_error(mci);
 };
 
-/*
- *	i7300_clear_error	Retrieve any error from the hardware
- *				but do NOT process that error.
- *				Used for 'clearing' out of previous errors
- *				Called by the Core module.
+/**
+ * i7300_clear_error() - Clears the error registers
+ * @mci: struct mem_ctl_info pointer
  */
 static void i7300_clear_error(struct mem_ctl_info *mci)
 {
@@ -573,9 +579,10 @@ static void i7300_clear_error(struct mem_ctl_info *mci)
 			      FERR_NF_FBD, value);
 }
 
-/*
- *	i7300_enable_error_reporting
- *			Turn on the memory reporting features of the hardware
+/**
+ * i7300_enable_error_reporting() - Enable the memory reporting logic at the
+ *				    hardware
+ * @mci: struct mem_ctl_info pointer
  */
 static void i7300_enable_error_reporting(struct mem_ctl_info *mci)
 {
@@ -597,10 +604,14 @@ static void i7300_enable_error_reporting(struct mem_ctl_info *mci)
  * i7300 Functions related to memory enumberation
  ************************************************/
 
-/*
- * determine_mtr(pvt, csrow, channel)
- *
- * return the proper MTR register as determine by the csrow and desired channel
+/**
+ * decode_mtr() - Decodes the MTR descriptor, filling the edac structs
+ * @pvt: pointer to the private data struct used by i7300 driver
+ * @slot: DIMM slot (0 to 7)
+ * @ch: Channel number within the branch (0 or 1)
+ * @branch: Branch number (0 or 1)
+ * @dinfo: Pointer to DIMM info where dimm size is stored
+ * @p_csrow: Pointer to the struct csrow_info that corresponds to that element
  */
 static int decode_mtr(struct i7300_pvt *pvt,
 		      int slot, int ch, int branch,
@@ -619,14 +630,8 @@ static int decode_mtr(struct i7300_pvt *pvt,
 		ans ? "Present" : "NOT Present");
 
 	/* Determine if there is a DIMM present in this DIMM slot */
-
-#if 0
-	if (!amb_present || !ans)
-		return 0;
-#else
 	if (!ans)
 		return 0;
-#endif
 
 	/* Start with the number of bits for a Bank
 	* on the DRAM */
@@ -692,14 +697,15 @@ static int decode_mtr(struct i7300_pvt *pvt,
 	return mtr;
 }
 
-/*
- *	print_dimm_size
+/**
+ * print_dimm_size() - Prints dump of the memory organization
+ * @pvt: pointer to the private data struct used by i7300 driver
  *
- *	also will output a DIMM matrix map, if debug is enabled, for viewing
- *	how the DIMMs are populated
+ * Useful for debug. If debug is disabled, this routine do nothing
  */
 static void print_dimm_size(struct i7300_pvt *pvt)
 {
+#ifdef CONFIG_EDAC_DEBUG
 	struct i7300_dimm_info *dinfo;
 	char *p;
 	int space, n;
@@ -751,30 +757,26 @@ static void print_dimm_size(struct i7300_pvt *pvt)
 	debugf2("%s\n", pvt->tmp_prt_buffer);
 	p = pvt->tmp_prt_buffer;
 	space = PAGE_SIZE;
+#endif
 }
 
-/*
- *	i7300_init_csrows	Initialize the 'csrows' table within
- *				the mci control	structure with the
- *				addressing of memory.
- *
- *	return:
- *		0	success
- *		1	no actual memory found on this MC
+/**
+ * i7300_init_csrows() - Initialize the 'csrows' table within
+ *			 the mci control structure with the
+ *			 addressing of memory.
+ * @mci: struct mem_ctl_info pointer
  */
 static int i7300_init_csrows(struct mem_ctl_info *mci)
 {
 	struct i7300_pvt *pvt;
 	struct i7300_dimm_info *dinfo;
 	struct csrow_info *p_csrow;
-	int empty;
+	int rc = -ENODEV;
 	int mtr;
 	int ch, branch, slot, channel;
 
 	pvt = mci->pvt_info;
 
-	empty = 1;		/* Assume NO memory */
-
 	debugf2("Memory Technology Registers:\n");
 
 	/* Get the AMB present registers for the four channels */
@@ -819,14 +821,19 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 				p_csrow->last_page = 9 + slot * 20;
 				p_csrow->page_mask = 0xfff;
 
-				empty = 0;
+				rc = 0;
 			}
 		}
 	}
 
-	return empty;
+	return rc;
 }
 
+/**
+ * decode_mir() - Decodes Memory Interleave Register (MIR) info
+ * @int mir_no: number of the MIR register to decode
+ * @mir: array with the MIR data cached on the driver
+ */
 static void decode_mir(int mir_no, u16 mir[MAX_MIR])
 {
 	if (mir[mir_no] & 3)
@@ -837,11 +844,11 @@ static void decode_mir(int mir_no, u16 mir[MAX_MIR])
 			(mir[mir_no] & 2) ? "B1": "");
 }
 
-/*
- *	i7300_get_mc_regs	read in the necessary registers and
- *				cache locally
+/**
+ * i7300_get_mc_regs() - Get the contents of the MC enumeration registers
+ * @mci: struct mem_ctl_info pointer
  *
- *			Fills in the private data members
+ * Data read is cached internally for its usage when needed
  */
 static int i7300_get_mc_regs(struct mem_ctl_info *mci)
 {
@@ -907,9 +914,9 @@ static int i7300_get_mc_regs(struct mem_ctl_info *mci)
  * i7300 Functions related to device probe/release
  *************************************************/
 
-/*
- *	i7300_put_devices	'put' all the devices that we have
- *				reserved via 'get'
+/**
+ * i7300_put_devices() - Release the PCI devices
+ * @mci: struct mem_ctl_info pointer
  */
 static void i7300_put_devices(struct mem_ctl_info *mci)
 {
@@ -925,13 +932,18 @@ static void i7300_put_devices(struct mem_ctl_info *mci)
 	pci_dev_put(pvt->pci_dev_16_1_fsb_addr_map);
 }
 
-/*
- *	i7300_get_devices	Find and perform 'get' operation on the MCH's
- *			device/functions we want to reference for this driver
+/**
+ * i7300_get_devices() - Find and perform 'get' operation on the MCH's
+ *			 device/functions we want to reference for this driver
+ * @mci: struct mem_ctl_info pointer
  *
- *			Need to 'get' device 16 func 1 and func 2
+ * Access and prepare the several devices for usage:
+ * I7300 devices used by this driver:
+ *    Device 16, functions 0,1 and 2:	PCI_DEVICE_ID_INTEL_I7300_MCH_ERR
+ *    Device 21 function 0:		PCI_DEVICE_ID_INTEL_I7300_MCH_FB0
+ *    Device 22 function 0:		PCI_DEVICE_ID_INTEL_I7300_MCH_FB1
  */
-static int i7300_get_devices(struct mem_ctl_info *mci, int dev_idx)
+static int __devinit i7300_get_devices(struct mem_ctl_info *mci)
 {
 	struct i7300_pvt *pvt;
 	struct pci_dev *pdev;
@@ -1007,23 +1019,25 @@ static int i7300_get_devices(struct mem_ctl_info *mci, int dev_idx)
 	return -ENODEV;
 }
 
-/*
- *	i7300_probe1	Probe for ONE instance of device to see if it is
- *			present.
- *	return:
- *		0 for FOUND a device
- *		< 0 for error code
+/**
+ * i7300_init_one() - Probe for one instance of the device
+ * @pdev: struct pci_dev pointer
+ * @id: struct pci_device_id pointer - currently unused
  */
-static int i7300_probe1(struct pci_dev *pdev, int dev_idx)
+static int __devinit i7300_init_one(struct pci_dev *pdev,
+				    const struct pci_device_id *id)
 {
 	struct mem_ctl_info *mci;
 	struct i7300_pvt *pvt;
 	int num_channels;
 	int num_dimms_per_channel;
 	int num_csrows;
+	int rc;
 
-	if (dev_idx >= ARRAY_SIZE(i7300_devs))
-		return -EINVAL;
+	/* wake up device */
+	rc = pci_enable_device(pdev);
+	if (rc == -EIO)
+		return rc;
 
 	debugf0("MC: " __FILE__ ": %s(), pdev bus %u dev=0x%x fn=0x%x\n",
 		__func__,
@@ -1068,7 +1082,7 @@ static int i7300_probe1(struct pci_dev *pdev, int dev_idx)
 	}
 
 	/* 'get' the pci devices we want to reserve for our use */
-	if (i7300_get_devices(mci, dev_idx))
+	if (i7300_get_devices(mci))
 		goto fail0;
 
 	mci->mc_idx = 0;
@@ -1077,7 +1091,7 @@ static int i7300_probe1(struct pci_dev *pdev, int dev_idx)
 	mci->edac_cap = EDAC_FLAG_NONE;
 	mci->mod_name = "i7300_edac.c";
 	mci->mod_ver = I7300_REVISION;
-	mci->ctl_name = i7300_devs[dev_idx].ctl_name;
+	mci->ctl_name = i7300_devs[0].ctl_name;
 	mci->dev_name = pci_name(pdev);
 	mci->ctl_page_to_phys = NULL;
 
@@ -1132,32 +1146,9 @@ static int i7300_probe1(struct pci_dev *pdev, int dev_idx)
 	return -ENODEV;
 }
 
-/*
- *	i7300_init_one	constructor for one instance of device
- *
- * 	returns:
- *		negative on error
- *		count (>= 0)
- */
-static int __devinit i7300_init_one(struct pci_dev *pdev,
-				const struct pci_device_id *id)
-{
-	int rc;
-
-	debugf0("MC: " __FILE__ ": %s()\n", __func__);
-
-	/* wake up device */
-	rc = pci_enable_device(pdev);
-	if (rc == -EIO)
-		return rc;
-
-	/* now probe and enable the device */
-	return i7300_probe1(pdev, id->driver_data);
-}
-
-/*
- *	i7300_remove_one	destructor for one instance of device
- *
+/**
+ * i7300_remove_one() - Remove the driver
+ * @pdev: struct pci_dev pointer
  */
 static void __devexit i7300_remove_one(struct pci_dev *pdev)
 {
@@ -1183,9 +1174,9 @@ static void __devexit i7300_remove_one(struct pci_dev *pdev)
 }
 
 /*
- *	pci_device_id	table for which devices we are looking for
+ * pci_device_id: table for which devices we are looking for
  *
- *	The "E500P" device is the first device supported.
+ * Has only 8086:360c PCI ID
  */
 static const struct pci_device_id i7300_pci_tbl[] __devinitdata = {
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I7300_MCH_ERR)},
@@ -1195,8 +1186,7 @@ static const struct pci_device_id i7300_pci_tbl[] __devinitdata = {
 MODULE_DEVICE_TABLE(pci, i7300_pci_tbl);
 
 /*
- *	i7300_driver	pci_driver structure for this module
- *
+ * i7300_driver: pci_driver structure for this module
  */
 static struct pci_driver i7300_driver = {
 	.name = "i7300_edac",
@@ -1205,9 +1195,8 @@ static struct pci_driver i7300_driver = {
 	.id_table = i7300_pci_tbl,
 };
 
-/*
- *	i7300_init		Module entry function
- *			Try to initialize this module for its devices
+/**
+ * i7300_init() - Registers the driver
  */
 static int __init i7300_init(void)
 {
@@ -1223,9 +1212,8 @@ static int __init i7300_init(void)
 	return (pci_rc < 0) ? pci_rc : 0;
 }
 
-/*
- *	i7300_exit()	Module exit function
- *			Unregister the driver
+/**
+ * i7300_init() - Unregisters the driver
  */
 static void __exit i7300_exit(void)
 {

commit b4552aceb37ef953db14b9851bd4ededabc3c77b
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 27 16:43:01 2010 -0300

    i7300_edac: Cleanup: reorganize the file contents
    
    This change should do no functional change. It just rearranges the
    contents of the c file, in order to make easier to understand and
    maintain it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index a85a8e5163b7..6278209fec07 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -41,6 +41,10 @@
 #define i7300_mc_printk(mci, level, fmt, arg...) \
 	edac_mc_chipset_printk(mci, level, "i7300", fmt, ##arg)
 
+/***********************************************
+ * i7300 Limit constants Structs and static vars
+ ***********************************************/
+
 /*
  * Memory topology is organized as:
  *	Branch 0 - 2 channels: channels 0 and 1 (FDB0 PCI dev 21.0)
@@ -67,18 +71,64 @@
 #define to_csrow(slot, ch, branch)					\
 		(to_channel(ch, branch) | ((slot) << 2))
 
+/* Device name and register DID (Device ID) */
+struct i7300_dev_info {
+	const char *ctl_name;	/* name for this device */
+	u16 fsb_mapping_errors;	/* DID for the branchmap,control */
+};
+
+/* Table of devices attributes supported by this driver */
+static const struct i7300_dev_info i7300_devs[] = {
+	{
+		.ctl_name = "I7300",
+		.fsb_mapping_errors = PCI_DEVICE_ID_INTEL_I7300_MCH_ERR,
+	},
+};
+
+struct i7300_dimm_info {
+	int megabytes;		/* size, 0 means not present  */
+};
+
+/* driver private data structure */
+struct i7300_pvt {
+	struct pci_dev *pci_dev_16_0_fsb_ctlr;		/* 16.0 */
+	struct pci_dev *pci_dev_16_1_fsb_addr_map;	/* 16.1 */
+	struct pci_dev *pci_dev_16_2_fsb_err_regs;	/* 16.2 */
+	struct pci_dev *pci_dev_2x_0_fbd_branch[MAX_BRANCHES];	/* 21.0  and 22.0 */
+
+	u16 tolm;				/* top of low memory */
+	u64 ambase;				/* AMB BAR */
+
+	u32 mc_settings;			/* Report several settings */
+	u32 mc_settings_a;
+
+	u16 mir[MAX_MIR];			/* Memory Interleave Reg*/
+
+	u16 mtr[MAX_SLOTS][MAX_BRANCHES];		/* Memory Technlogy Reg */
+	u16 ambpresent[MAX_CHANNELS];		/* AMB present regs */
+
+	/* DIMM information matrix, allocating architecture maximums */
+	struct i7300_dimm_info dimm_info[MAX_SLOTS][MAX_CHANNELS];
+
+	/* Temporary buffer for use when preparing error messages */
+	char *tmp_prt_buffer;
+};
+
+/* FIXME: Why do we need to have this static? */
+static struct edac_pci_ctl_info *i7300_pci;
+
+/***************************************************
+ * i7300 Register definitions for memory enumeration
+ ***************************************************/
+
 /*
- * I7300 devices
+ * I7300 devices:
  * All 3 functions of Device 16 (0,1,2) share the SAME DID and
- * uses PCI_DEVICE_ID_INTEL_I7300_MCH_ERR for device 16 (0,1,2),
- * PCI_DEVICE_ID_INTEL_I7300_MCH_FB0 and PCI_DEVICE_ID_INTEL_I7300_MCH_FB1
- * for device 21 (0,1).
+ * uses PCI_DEVICE_ID_INTEL_I7300_MCH_ERR for device 16 (0,1,2).
+ * PCI_DEVICE_ID_INTEL_I7300_MCH_FB0 is used for device 21 (0,1)
+ * and PCI_DEVICE_ID_INTEL_I7300_MCH_FB1 is used for device 21 (0,1).
  */
 
-/****************************************************
- * i7300 Register definitions for memory enumberation
- ****************************************************/
-
 /*
  * Device 16,
  * Function 0: System Address (not documented)
@@ -125,7 +175,8 @@ const static u16 mtr_regs [MAX_SLOTS] = {
 	0x82, 0x86, 0x8a, 0x8e
 };
 
-/* Defines to extract the vaious fields from the
+/*
+ * Defines to extract the vaious fields from the
  *	MTRx - Memory Technology Registers
  */
 #define MTR_DIMMS_PRESENT(mtr)		((mtr) & (1 << 8))
@@ -290,53 +341,6 @@ static const char *ferr_global_lo_name[] = {
   #define RECMEMB_CAS(v)	(((v) >> 16) & 0x1fff)
   #define RECMEMB_RAS(v)	((v) & 0xffff)
 
-
-/* Device name and register DID (Device ID) */
-struct i7300_dev_info {
-	const char *ctl_name;	/* name for this device */
-	u16 fsb_mapping_errors;	/* DID for the branchmap,control */
-};
-
-/* Table of devices attributes supported by this driver */
-static const struct i7300_dev_info i7300_devs[] = {
-	{
-		.ctl_name = "I7300",
-		.fsb_mapping_errors = PCI_DEVICE_ID_INTEL_I7300_MCH_ERR,
-	},
-};
-
-struct i7300_dimm_info {
-	int megabytes;		/* size, 0 means not present  */
-};
-
-/* driver private data structure */
-struct i7300_pvt {
-	struct pci_dev *pci_dev_16_0_fsb_ctlr;		/* 16.0 */
-	struct pci_dev *pci_dev_16_1_fsb_addr_map;	/* 16.1 */
-	struct pci_dev *pci_dev_16_2_fsb_err_regs;	/* 16.2 */
-	struct pci_dev *pci_dev_2x_0_fbd_branch[MAX_BRANCHES];	/* 21.0  and 22.0 */
-
-	u16 tolm;				/* top of low memory */
-	u64 ambase;				/* AMB BAR */
-
-	u32 mc_settings;			/* Report several settings */
-	u32 mc_settings_a;
-
-	u16 mir[MAX_MIR];			/* Memory Interleave Reg*/
-
-	u16 mtr[MAX_SLOTS][MAX_BRANCHES];		/* Memory Technlogy Reg */
-	u16 ambpresent[MAX_CHANNELS];		/* AMB present regs */
-
-	/* DIMM information matrix, allocating architecture maximums */
-	struct i7300_dimm_info dimm_info[MAX_SLOTS][MAX_CHANNELS];
-
-	/* Temporary buffer for use when preparing error messages */
-	char *tmp_prt_buffer;
-};
-
-/* FIXME: Why do we need to have this static? */
-static struct edac_pci_ctl_info *i7300_pci;
-
 /********************************************
  * i7300 Functions related to error detection
  ********************************************/

commit 37b69cf91c2c6e60856ad1ac4c37ccb2005ebbd3
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 27 15:44:43 2010 -0300

    i7300_edac: Properly detect channel on CE errors
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index a06db65e1fef..a85a8e5163b7 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -101,7 +101,6 @@
   #define IS_SINGLE_MODE(mca)		((mca) & (1 << 14))
 
 #define TOLM			0x6C
-#define REDMEMB			0x7C
 
 #define MIR0			0x80
 #define MIR1			0x84
@@ -279,6 +278,9 @@ static const char *ferr_global_lo_name[] = {
 
 #define REDMEMA		0xdc
 
+#define REDMEMB		0x7c
+  #define IS_SECOND_CH(v)	((v) * (1 << 17))
+
 #define RECMEMA		0xe0
   #define RECMEMA_BANK(v)	(((v) >> 12) & 7)
   #define RECMEMA_RANK(v)	(((v) >> 8) & 15)
@@ -414,7 +416,7 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 	struct i7300_pvt *pvt;
 	u32 errnum, value;
 	u16 val16;
-	unsigned branch, bank, rank, cas, ras;
+	unsigned branch, channel, bank, rank, cas, ras;
 	u32 syndrome;
 
 	unsigned long errors;
@@ -488,12 +490,19 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 		cas = RECMEMB_CAS(value);
 		ras = RECMEMB_RAS(value);
 
+		pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
+				     REDMEMB, &value);
+
+		channel = (branch << 1);
+		if (IS_SECOND_CH(value))
+			channel++;
+
 		/* Form out message */
 		snprintf(pvt->tmp_prt_buffer, PAGE_SIZE,
-			"Corrected error (Branch=%d (channel %d or %d), "
+			"Corrected error (Branch=%d, Channel %d), "
 			" DRAM-Bank=%d %s "
 			"RAS=%d CAS=%d, CE Err=0x%lx, Syndrome=0x%08x(%s))",
-			branch, branch << 1, (branch << 1) + 1,
+			branch, channel,
 			bank,
 			is_wr ? "RDWR" : "RD",
 			ras, cas,
@@ -505,7 +514,7 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 		 *	 Currently, we don't know how to identify the right
 		 *	 channel.
 		 */
-		edac_mc_handle_fbd_ce(mci, rank, branch << 1,
+		edac_mc_handle_fbd_ce(mci, rank, channel,
 				      pvt->tmp_prt_buffer);
 	}
 	return;

commit 32f9472613b30791d8cb5a953791cf4647166744
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 27 12:13:05 2010 -0300

    i7300_edac: enrich FBD error info for corrected errors
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index e33c9900e269..a06db65e1fef 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -277,6 +277,17 @@ static const char *ferr_global_lo_name[] = {
   #define NRECMEMB_CAS(v)	(((v) >> 16) & 0x1fff)
   #define NRECMEMB_RAS(v)	((v) & 0xffff)
 
+#define REDMEMA		0xdc
+
+#define RECMEMA		0xe0
+  #define RECMEMA_BANK(v)	(((v) >> 12) & 7)
+  #define RECMEMA_RANK(v)	(((v) >> 8) & 15)
+
+#define RECMEMB		0xe4
+  #define RECMEMB_IS_WR(v)	((v) & (1 << 31))
+  #define RECMEMB_CAS(v)	(((v) >> 16) & 0x1fff)
+  #define RECMEMB_RAS(v)	((v) & 0xffff)
+
 
 /* Device name and register DID (Device ID) */
 struct i7300_dev_info {
@@ -403,10 +414,12 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 	struct i7300_pvt *pvt;
 	u32 errnum, value;
 	u16 val16;
-	int branch, bank, rank, cas, ras;
+	unsigned branch, bank, rank, cas, ras;
+	u32 syndrome;
+
 	unsigned long errors;
 	const char *specific;
-	bool is_fatal, is_wr;
+	bool is_wr;
 
 	pvt = mci->pvt_info;
 
@@ -418,7 +431,6 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 		errnum = find_first_bit(&errors,
 					ARRAY_SIZE(ferr_fat_fbd_name));
 		specific = GET_ERR_FROM_TABLE(ferr_fat_fbd_name, errnum);
-		is_fatal = 1;
 
 		branch = (GET_FBD_FAT_IDX(value) == 2) ? 1 : 0;
 		pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map,
@@ -436,7 +448,7 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 		snprintf(pvt->tmp_prt_buffer, PAGE_SIZE,
 			"FATAL (Branch=%d DRAM-Bank=%d %s "
 			"RAS=%d CAS=%d Err=0x%lx (%s))",
-			branch >> 1, bank,
+			branch, bank,
 			is_wr ? "RDWR" : "RD",
 			ras, cas,
 			errors, specific);
@@ -445,7 +457,6 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 		edac_mc_handle_fbd_ue(mci, rank, branch << 1,
 				      (branch << 1) + 1,
 				      pvt->tmp_prt_buffer);
-		return;
 	}
 
 	/* read in the 1st NON-FATAL error register */
@@ -456,20 +467,48 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 		errnum = find_first_bit(&errors,
 					ARRAY_SIZE(ferr_nf_fbd_name));
 		specific = GET_ERR_FROM_TABLE(ferr_nf_fbd_name, errnum);
-		is_fatal = 0;
 
 		/* Clear the error bit */
 		pci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,
 				       FERR_GLOBAL_LO, value);
 
-		goto error_fbd;
-	}
-	return;
+		pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
+			REDMEMA, &syndrome);
 
-error_fbd:
+		branch = (GET_FBD_FAT_IDX(value) == 2) ? 1 : 0;
+		pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map,
+				     RECMEMA, &val16);
+		bank = RECMEMA_BANK(val16);
+		rank = RECMEMA_RANK(val16);
 
-	i7300_mc_printk(mci, KERN_EMERG, "%s FBD error on branch %d: %s\n",
-			is_fatal ? "Fatal" : "NOT fatal", branch, specific);
+		pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
+				RECMEMB, &value);
+
+		is_wr = RECMEMB_IS_WR(value);
+		cas = RECMEMB_CAS(value);
+		ras = RECMEMB_RAS(value);
+
+		/* Form out message */
+		snprintf(pvt->tmp_prt_buffer, PAGE_SIZE,
+			"Corrected error (Branch=%d (channel %d or %d), "
+			" DRAM-Bank=%d %s "
+			"RAS=%d CAS=%d, CE Err=0x%lx, Syndrome=0x%08x(%s))",
+			branch, branch << 1, (branch << 1) + 1,
+			bank,
+			is_wr ? "RDWR" : "RD",
+			ras, cas,
+			errors, syndrome, specific);
+
+		/*
+		 * Call the helper to output message
+		 * NOTE: Errors are reported per-branch, and not per-channel
+		 *	 Currently, we don't know how to identify the right
+		 *	 channel.
+		 */
+		edac_mc_handle_fbd_ce(mci, rank, branch << 1,
+				      pvt->tmp_prt_buffer);
+	}
+	return;
 }
 
 /*

commit 8199d8cc65787bfd83abbfb69d9de1b51e027c41
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 27 11:51:48 2010 -0300

    i7300_edac: enrich FBD error info for fatal errors
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 4c239ce6986b..e33c9900e269 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -268,6 +268,16 @@ static const char *ferr_global_lo_name[] = {
 };
 #define ferr_global_lo_is_fatal(errno)	((errno < 16) ? 0 : 1)
 
+#define NRECMEMA	0xbe
+  #define NRECMEMA_BANK(v)	(((v) >> 12) & 7)
+  #define NRECMEMA_RANK(v)	(((v) >> 8) & 15)
+
+#define NRECMEMB	0xc0
+  #define NRECMEMB_IS_WR(v)	((v) & (1 << 31))
+  #define NRECMEMB_CAS(v)	(((v) >> 16) & 0x1fff)
+  #define NRECMEMB_RAS(v)	((v) & 0xffff)
+
+
 /* Device name and register DID (Device ID) */
 struct i7300_dev_info {
 	const char *ctl_name;	/* name for this device */
@@ -392,10 +402,11 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 {
 	struct i7300_pvt *pvt;
 	u32 errnum, value;
-	int branch;
+	u16 val16;
+	int branch, bank, rank, cas, ras;
 	unsigned long errors;
 	const char *specific;
-	bool is_fatal;
+	bool is_fatal, is_wr;
 
 	pvt = mci->pvt_info;
 
@@ -410,8 +421,31 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 		is_fatal = 1;
 
 		branch = (GET_FBD_FAT_IDX(value) == 2) ? 1 : 0;
-
-		goto error_fbd;
+		pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map,
+				     NRECMEMA, &val16);
+		bank = NRECMEMA_BANK(val16);
+		rank = NRECMEMA_RANK(val16);
+
+		pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
+				NRECMEMB, &value);
+
+		is_wr = NRECMEMB_IS_WR(value);
+		cas = NRECMEMB_CAS(value);
+		ras = NRECMEMB_RAS(value);
+
+		snprintf(pvt->tmp_prt_buffer, PAGE_SIZE,
+			"FATAL (Branch=%d DRAM-Bank=%d %s "
+			"RAS=%d CAS=%d Err=0x%lx (%s))",
+			branch >> 1, bank,
+			is_wr ? "RDWR" : "RD",
+			ras, cas,
+			errors, specific);
+
+		/* Call the helper to output message */
+		edac_mc_handle_fbd_ue(mci, rank, branch << 1,
+				      (branch << 1) + 1,
+				      pvt->tmp_prt_buffer);
+		return;
 	}
 
 	/* read in the 1st NON-FATAL error register */
@@ -433,6 +467,7 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 	return;
 
 error_fbd:
+
 	i7300_mc_printk(mci, KERN_EMERG, "%s FBD error on branch %d: %s\n",
 			is_fatal ? "Fatal" : "NOT fatal", branch, specific);
 }

commit 85580ea4f72ce08e4d9140a3bb22806185a0bba9
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 27 11:36:23 2010 -0300

    i7300_edac: pre-allocate a buffer used to prepare err messages
    
    Instead of dynamically allocating a buffer for it where needed,
    just allocate it once. As we'll use the same buffer also during
    fatal and non-fatal errors, is is very risky to dynamically allocate
    it during an error.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index a4f47fda078d..4c239ce6986b 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -306,6 +306,9 @@ struct i7300_pvt {
 
 	/* DIMM information matrix, allocating architecture maximums */
 	struct i7300_dimm_info dimm_info[MAX_SLOTS][MAX_CHANNELS];
+
+	/* Temporary buffer for use when preparing error messages */
+	char *tmp_prt_buffer;
 };
 
 /* FIXME: Why do we need to have this static? */
@@ -611,17 +614,12 @@ static int decode_mtr(struct i7300_pvt *pvt,
 static void print_dimm_size(struct i7300_pvt *pvt)
 {
 	struct i7300_dimm_info *dinfo;
-	char *p, *mem_buffer;
+	char *p;
 	int space, n;
 	int channel, slot;
 
 	space = PAGE_SIZE;
-	mem_buffer = p = kmalloc(space, GFP_KERNEL);
-	if (p == NULL) {
-		i7300_printk(KERN_ERR, "MC: %s:%s() kmalloc() failed\n",
-			__FILE__, __func__);
-		return;
-	}
+	p = pvt->tmp_prt_buffer;
 
 	n = snprintf(p, space, "              ");
 	p += n;
@@ -631,15 +629,15 @@ static void print_dimm_size(struct i7300_pvt *pvt)
 		p += n;
 		space -= n;
 	}
-	debugf2("%s\n", mem_buffer);
-	p = mem_buffer;
+	debugf2("%s\n", pvt->tmp_prt_buffer);
+	p = pvt->tmp_prt_buffer;
 	space = PAGE_SIZE;
 	n = snprintf(p, space, "-------------------------------"
 		               "------------------------------");
 	p += n;
 	space -= n;
-	debugf2("%s\n", mem_buffer);
-	p = mem_buffer;
+	debugf2("%s\n", pvt->tmp_prt_buffer);
+	p = pvt->tmp_prt_buffer;
 	space = PAGE_SIZE;
 
 	for (slot = 0; slot < MAX_SLOTS; slot++) {
@@ -654,8 +652,8 @@ static void print_dimm_size(struct i7300_pvt *pvt)
 			space -= n;
 		}
 
-		debugf2("%s\n", mem_buffer);
-		p = mem_buffer;
+		debugf2("%s\n", pvt->tmp_prt_buffer);
+		p = pvt->tmp_prt_buffer;
 		space = PAGE_SIZE;
 	}
 
@@ -663,11 +661,9 @@ static void print_dimm_size(struct i7300_pvt *pvt)
 		               "------------------------------");
 	p += n;
 	space -= n;
-	debugf2("%s\n", mem_buffer);
-	p = mem_buffer;
+	debugf2("%s\n", pvt->tmp_prt_buffer);
+	p = pvt->tmp_prt_buffer;
 	space = PAGE_SIZE;
-
-	kfree(mem_buffer);
 }
 
 /*
@@ -978,6 +974,12 @@ static int i7300_probe1(struct pci_dev *pdev, int dev_idx)
 	pvt = mci->pvt_info;
 	pvt->pci_dev_16_0_fsb_ctlr = pdev;	/* Record this device in our private */
 
+	pvt->tmp_prt_buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!pvt->tmp_prt_buffer) {
+		edac_mc_free(mci);
+		return -ENOMEM;
+	}
+
 	/* 'get' the pci devices we want to reserve for our use */
 	if (i7300_get_devices(mci, dev_idx))
 		goto fail0;
@@ -1038,6 +1040,7 @@ static int i7300_probe1(struct pci_dev *pdev, int dev_idx)
 	i7300_put_devices(mci);
 
 fail0:
+	kfree(pvt->tmp_prt_buffer);
 	edac_mc_free(mci);
 	return -ENODEV;
 }
@@ -1072,6 +1075,7 @@ static int __devinit i7300_init_one(struct pci_dev *pdev,
 static void __devexit i7300_remove_one(struct pci_dev *pdev)
 {
 	struct mem_ctl_info *mci;
+	char *tmp;
 
 	debugf0(__FILE__ ": %s()\n", __func__);
 
@@ -1082,9 +1086,12 @@ static void __devexit i7300_remove_one(struct pci_dev *pdev)
 	if (!mci)
 		return;
 
+	tmp = ((struct i7300_pvt *)mci->pvt_info)->tmp_prt_buffer;
+
 	/* retrieve references to resources, and free those resources */
 	i7300_put_devices(mci);
 
+	kfree(tmp);
 	edac_mc_free(mci);
 }
 

commit 28c2ce7c8b275a8e6950bacb2dbad70b36a2996b
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 27 11:20:38 2010 -0300

    i7300_edac: Fix MTR x4/x8 detection logic
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 218d463fb1a8..a4f47fda078d 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -583,14 +583,14 @@ static int decode_mtr(struct i7300_pvt *pvt,
 		debugf2("\t\tECC code is 8-byte-over-32-byte SECDED+ code\n");
 	} else {
 		debugf2("\t\tECC code is on Lockstep mode\n");
-		if (MTR_DRAM_WIDTH(mtr))
+		if (MTR_DRAM_WIDTH(mtr) == 8)
 			p_csrow->edac_mode = EDAC_S8ECD8ED;
 		else
 			p_csrow->edac_mode = EDAC_S4ECD4ED;
 	}
 
 	/* ask what device type on this row */
-	if (MTR_DRAM_WIDTH(mtr)) {
+	if (MTR_DRAM_WIDTH(mtr) == 8) {
 		debugf2("\t\tScrub algorithm for x8 is on %s mode\n",
 			IS_SCRBALGO_ENHANCED(pvt->mc_settings) ?
 					    "enhanced" : "normal");

commit 3b330f67581db4f5301438cc0d9499f13314542d
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 27 10:39:35 2010 -0300

    i7300_edac: Make the debug messages coherent with the others
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 3ae8fae74e5e..218d463fb1a8 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -580,9 +580,9 @@ static int decode_mtr(struct i7300_pvt *pvt,
 
 	if (IS_SINGLE_MODE(pvt->mc_settings_a)) {
 		p_csrow->edac_mode = EDAC_SECDED;
-		debugf0("ECC code is 8-byte-over-32-byte SECDED+ code\n");
+		debugf2("\t\tECC code is 8-byte-over-32-byte SECDED+ code\n");
 	} else {
-		debugf0("ECC code is on Lockstep mode\n");
+		debugf2("\t\tECC code is on Lockstep mode\n");
 		if (MTR_DRAM_WIDTH(mtr))
 			p_csrow->edac_mode = EDAC_S8ECD8ED;
 		else
@@ -591,7 +591,7 @@ static int decode_mtr(struct i7300_pvt *pvt,
 
 	/* ask what device type on this row */
 	if (MTR_DRAM_WIDTH(mtr)) {
-		debugf0("Scrub algorithm for x8 is on %s mode\n",
+		debugf2("\t\tScrub algorithm for x8 is on %s mode\n",
 			IS_SCRBALGO_ENHANCED(pvt->mc_settings) ?
 					    "enhanced" : "normal");
 

commit f42774224860d7c3f7c06559f98b681197999f9e
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 27 10:33:25 2010 -0300

    i7300_edac: Cleanup: remove get_error_info logic
    
    As the error logic in this driver came from i5400 driver, it
    were using one function to get errors, and another to display.
    Let's make it simpler and avoid doing it into two steps.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 3b6da20de4e5..3ae8fae74e5e 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -315,10 +315,6 @@ static struct edac_pci_ctl_info *i7300_pci;
  * i7300 Functions related to error detection
  ********************************************/
 
-struct i7300_error_info {
-	int dummy;	/* FIXME */
-};
-
 const char *get_err_from_table(const char *table[], int size, int pos)
 {
 	if (pos >= size)
@@ -330,23 +326,12 @@ const char *get_err_from_table(const char *table[], int size, int pos)
 #define GET_ERR_FROM_TABLE(table, pos)				\
 	get_err_from_table(table, ARRAY_SIZE(table), pos)
 
-/*
- *	i7300_get_error_info	Retrieve the hardware error information from
- *				the hardware and cache it in the 'info'
- *				structure
- */
-static void i7300_get_error_info(struct mem_ctl_info *mci,
-				 struct i7300_error_info *info)
-{
-}
-
 /*
  *	i7300_process_error_global Retrieve the hardware error information from
  *				the hardware and cache it in the 'info'
  *				structure
  */
-static void i7300_process_error_global(struct mem_ctl_info *mci,
-				 struct i7300_error_info *info)
+static void i7300_process_error_global(struct mem_ctl_info *mci)
 {
 	struct i7300_pvt *pvt;
 	u32 errnum, value;
@@ -400,8 +385,7 @@ static void i7300_process_error_global(struct mem_ctl_info *mci,
  *				the hardware and cache it in the 'info'
  *				structure
  */
-static void i7300_process_fbd_error(struct mem_ctl_info *mci,
-				    struct i7300_error_info *info)
+static void i7300_process_fbd_error(struct mem_ctl_info *mci)
 {
 	struct i7300_pvt *pvt;
 	u32 errnum, value;
@@ -451,15 +435,14 @@ static void i7300_process_fbd_error(struct mem_ctl_info *mci,
 }
 
 /*
- *	i7300_process_error_info Retrieve the hardware error information from
+ *	i7300_check_error Retrieve the hardware error information from
  *				the hardware and cache it in the 'info'
  *				structure
  */
-static void i7300_process_error_info(struct mem_ctl_info *mci,
-				 struct i7300_error_info *info)
+static void i7300_check_error(struct mem_ctl_info *mci)
 {
-	i7300_process_error_global(mci, info);
-	i7300_process_fbd_error(mci, info);
+	i7300_process_error_global(mci);
+	i7300_process_fbd_error(mci);
 };
 
 /*
@@ -500,19 +483,6 @@ static void i7300_clear_error(struct mem_ctl_info *mci)
 			      FERR_NF_FBD, value);
 }
 
-/*
- *	i7300_check_error	Retrieve and process errors reported by the
- *				hardware. Called by the Core module.
- */
-static void i7300_check_error(struct mem_ctl_info *mci)
-{
-	struct i7300_error_info info;
-	debugf4("MC%d: " __FILE__ ": %s()\n", mci->mc_idx, __func__);
-
-	i7300_get_error_info(mci, &info);
-	i7300_process_error_info(mci, &info);
-}
-
 /*
  *	i7300_enable_error_reporting
  *			Turn on the memory reporting features of the hardware

commit e43276050927c7dfc45b1e2f090b94f72f87c052
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 27 10:30:18 2010 -0300

    i7300_edac: Add a code to cleanup error registers
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 728f9b0ab62c..3b6da20de4e5 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -470,9 +470,34 @@ static void i7300_process_error_info(struct mem_ctl_info *mci,
  */
 static void i7300_clear_error(struct mem_ctl_info *mci)
 {
-	struct i7300_error_info info;
+	struct i7300_pvt *pvt = mci->pvt_info;
+	u32 value;
+	/*
+	 * All error values are RWC - we need to read and write 1 to the
+	 * bit that we want to cleanup
+	 */
 
-	i7300_get_error_info(mci, &info);
+	/* Clear global error registers */
+	pci_read_config_dword(pvt->pci_dev_16_2_fsb_err_regs,
+			      FERR_GLOBAL_HI, &value);
+	pci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,
+			      FERR_GLOBAL_HI, value);
+
+	pci_read_config_dword(pvt->pci_dev_16_2_fsb_err_regs,
+			      FERR_GLOBAL_LO, &value);
+	pci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,
+			      FERR_GLOBAL_LO, value);
+
+	/* Clear FBD error registers */
+	pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
+			      FERR_FAT_FBD, &value);
+	pci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
+			      FERR_FAT_FBD, value);
+
+	pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
+			      FERR_NF_FBD, &value);
+	pci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
+			      FERR_NF_FBD, value);
 }
 
 /*

commit 57021918aa9c310524d7e9754506e4e8272b4c0e
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 27 10:22:36 2010 -0300

    i7300_edac: Add support for reporting FBD errors
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index b5152256967f..728f9b0ab62c 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -161,6 +161,63 @@ static const char *numcol_toString[] = {
 /************************************************
  * i7300 Register definitions for error detection
  ************************************************/
+
+/*
+ * Device 16.1: FBD Error Registers
+ */
+#define FERR_FAT_FBD	0x98
+static const char *ferr_fat_fbd_name[] = {
+	[22] = "Non-Redundant Fast Reset Timeout",
+	[2]  = ">Tmid Thermal event with intelligent throttling disabled",
+	[1]  = "Memory or FBD configuration CRC read error",
+	[0]  = "Memory Write error on non-redundant retry or "
+	       "FBD configuration Write error on retry",
+};
+#define GET_FBD_FAT_IDX(fbderr)	(fbderr & (3 << 28))
+#define FERR_FAT_FBD_ERR_MASK ((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3))
+
+#define FERR_NF_FBD	0xa0
+static const char *ferr_nf_fbd_name[] = {
+	[24] = "DIMM-Spare Copy Completed",
+	[23] = "DIMM-Spare Copy Initiated",
+	[22] = "Redundant Fast Reset Timeout",
+	[21] = "Memory Write error on redundant retry",
+	[18] = "SPD protocol Error",
+	[17] = "FBD Northbound parity error on FBD Sync Status",
+	[16] = "Correctable Patrol Data ECC",
+	[15] = "Correctable Resilver- or Spare-Copy Data ECC",
+	[14] = "Correctable Mirrored Demand Data ECC",
+	[13] = "Correctable Non-Mirrored Demand Data ECC",
+	[11] = "Memory or FBD configuration CRC read error",
+	[10] = "FBD Configuration Write error on first attempt",
+	[9]  = "Memory Write error on first attempt",
+	[8]  = "Non-Aliased Uncorrectable Patrol Data ECC",
+	[7]  = "Non-Aliased Uncorrectable Resilver- or Spare-Copy Data ECC",
+	[6]  = "Non-Aliased Uncorrectable Mirrored Demand Data ECC",
+	[5]  = "Non-Aliased Uncorrectable Non-Mirrored Demand Data ECC",
+	[4]  = "Aliased Uncorrectable Patrol Data ECC",
+	[3]  = "Aliased Uncorrectable Resilver- or Spare-Copy Data ECC",
+	[2]  = "Aliased Uncorrectable Mirrored Demand Data ECC",
+	[1]  = "Aliased Uncorrectable Non-Mirrored Demand Data ECC",
+	[0]  = "Uncorrectable Data ECC on Replay",
+};
+#define GET_FBD_NF_IDX(fbderr)	(fbderr & (3 << 28))
+#define FERR_NF_FBD_ERR_MASK ((1 << 24) | (1 << 23) | (1 << 22) | (1 << 21) |\
+			      (1 << 18) | (1 << 17) | (1 << 16) | (1 << 15) |\
+			      (1 << 14) | (1 << 13) | (1 << 11) | (1 << 10) |\
+			      (1 << 9)  | (1 << 8)  | (1 << 7)  | (1 << 6)  |\
+			      (1 << 5)  | (1 << 4)  | (1 << 3)  | (1 << 2)  |\
+			      (1 << 1)  | (1 << 0))
+
+#define EMASK_FBD	0xa8
+#define EMASK_FBD_ERR_MASK ((1 << 27) | (1 << 26) | (1 << 25) | (1 << 24) |\
+			    (1 << 22) | (1 << 21) | (1 << 20) | (1 << 19) |\
+			    (1 << 18) | (1 << 17) | (1 << 16) | (1 << 14) |\
+			    (1 << 13) | (1 << 12) | (1 << 11) | (1 << 10) |\
+			    (1 << 9)  | (1 << 8)  | (1 << 7)  | (1 << 6)  |\
+			    (1 << 5)  | (1 << 4)  | (1 << 3)  | (1 << 2)  |\
+			    (1 << 1)  | (1 << 0))
+
 /*
  * Device 16.2: Global Error Registers
  */
@@ -338,6 +395,61 @@ static void i7300_process_error_global(struct mem_ctl_info *mci,
 			is_fatal ? "Fatal" : "NOT fatal", specific);
 }
 
+/*
+ *	i7300_process_fbd_error Retrieve the hardware error information from
+ *				the hardware and cache it in the 'info'
+ *				structure
+ */
+static void i7300_process_fbd_error(struct mem_ctl_info *mci,
+				    struct i7300_error_info *info)
+{
+	struct i7300_pvt *pvt;
+	u32 errnum, value;
+	int branch;
+	unsigned long errors;
+	const char *specific;
+	bool is_fatal;
+
+	pvt = mci->pvt_info;
+
+	/* read in the 1st FATAL error register */
+	pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
+			      FERR_FAT_FBD, &value);
+	if (unlikely(value & FERR_FAT_FBD_ERR_MASK)) {
+		errors = value & FERR_FAT_FBD_ERR_MASK ;
+		errnum = find_first_bit(&errors,
+					ARRAY_SIZE(ferr_fat_fbd_name));
+		specific = GET_ERR_FROM_TABLE(ferr_fat_fbd_name, errnum);
+		is_fatal = 1;
+
+		branch = (GET_FBD_FAT_IDX(value) == 2) ? 1 : 0;
+
+		goto error_fbd;
+	}
+
+	/* read in the 1st NON-FATAL error register */
+	pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
+			      FERR_NF_FBD, &value);
+	if (unlikely(value & FERR_NF_FBD_ERR_MASK)) {
+		errors = value & FERR_NF_FBD_ERR_MASK;
+		errnum = find_first_bit(&errors,
+					ARRAY_SIZE(ferr_nf_fbd_name));
+		specific = GET_ERR_FROM_TABLE(ferr_nf_fbd_name, errnum);
+		is_fatal = 0;
+
+		/* Clear the error bit */
+		pci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,
+				       FERR_GLOBAL_LO, value);
+
+		goto error_fbd;
+	}
+	return;
+
+error_fbd:
+	i7300_mc_printk(mci, KERN_EMERG, "%s FBD error on branch %d: %s\n",
+			is_fatal ? "Fatal" : "NOT fatal", branch, specific);
+}
+
 /*
  *	i7300_process_error_info Retrieve the hardware error information from
  *				the hardware and cache it in the 'info'
@@ -347,6 +459,7 @@ static void i7300_process_error_info(struct mem_ctl_info *mci,
 				 struct i7300_error_info *info)
 {
 	i7300_process_error_global(mci, info);
+	i7300_process_fbd_error(mci, info);
 };
 
 /*
@@ -381,6 +494,18 @@ static void i7300_check_error(struct mem_ctl_info *mci)
  */
 static void i7300_enable_error_reporting(struct mem_ctl_info *mci)
 {
+	struct i7300_pvt *pvt = mci->pvt_info;
+	u32 fbd_error_mask;
+
+	/* Read the FBD Error Mask Register */
+	pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
+			      EMASK_FBD, &fbd_error_mask);
+
+	/* Enable with a '0' */
+	fbd_error_mask &= ~(EMASK_FBD_ERR_MASK);
+
+	pci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
+			       EMASK_FBD, fbd_error_mask);
 }
 
 /************************************************

commit 15154c57c62494292f43df9133a7b370cbbf1ecb
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 27 09:16:06 2010 -0300

    i7300_edac: Properly detect the type of error correction
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index a88742abf1f4..b5152256967f 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -450,14 +450,24 @@ static int decode_mtr(struct i7300_pvt *pvt,
 	p_csrow->mtype = MEM_FB_DDR2;
 
 	/*
-	 * FIXME: the type of error detection actually depends of the
+	 * The type of error detection actually depends of the
 	 * mode of operation. When it is just one single memory chip, at
-	 * socket 0, channel 0, it uses  8-byte-over-32-byte SECDED+ code.
-	 * In normal or mirrored mode, it uses Single Device Data correction,
+	 * socket 0, channel 0, it uses 8-byte-over-32-byte SECDED+ code.
+	 * In normal or mirrored mode, it uses Lockstep mode,
 	 * with the possibility of using an extended algorithm for x8 memories
 	 * See datasheet Sections 7.3.6 to 7.3.8
 	 */
-	p_csrow->edac_mode = EDAC_S8ECD8ED;
+
+	if (IS_SINGLE_MODE(pvt->mc_settings_a)) {
+		p_csrow->edac_mode = EDAC_SECDED;
+		debugf0("ECC code is 8-byte-over-32-byte SECDED+ code\n");
+	} else {
+		debugf0("ECC code is on Lockstep mode\n");
+		if (MTR_DRAM_WIDTH(mtr))
+			p_csrow->edac_mode = EDAC_S8ECD8ED;
+		else
+			p_csrow->edac_mode = EDAC_S4ECD4ED;
+	}
 
 	/* ask what device type on this row */
 	if (MTR_DRAM_WIDTH(mtr)) {

commit bb81a21637f84e2192bf327575645a7843c70cdb
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 27 09:04:11 2010 -0300

    i7300_edac: Detect if the device is on single mode
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 27088af79672..a88742abf1f4 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -92,12 +92,13 @@
 
 	/* OFFSETS for Function 1 */
 #define MC_SETTINGS		0x40
+  #define IS_MIRRORED(mc)		((mc) & (1 << 16))
+  #define IS_ECC_ENABLED(mc)		((mc) & (1 << 5))
+  #define IS_RETRY_ENABLED(mc)		((mc) & (1 << 31))
+  #define IS_SCRBALGO_ENHANCED(mc)	((mc) & (1 << 8))
 
-#define IS_MIRRORED(mc)			((mc) & (1 << 16))
-#define IS_ECC_ENABLED(mc)		((mc) & (1 << 5))
-#define IS_RETRY_ENABLED(mc)		((mc) & (1 << 31))
-#define IS_SCRBALGO_ENHANCED(mc)	((mc) & (1 << 8))
-
+#define MC_SETTINGS_A		0x58
+  #define IS_SINGLE_MODE(mca)		((mca) & (1 << 14))
 
 #define TOLM			0x6C
 #define REDMEMB			0x7C
@@ -237,9 +238,11 @@ struct i7300_pvt {
 
 	u16 tolm;				/* top of low memory */
 	u64 ambase;				/* AMB BAR */
-	u32 mc_settings;
 
-	u16 mir[MAX_MIR];
+	u32 mc_settings;			/* Report several settings */
+	u32 mc_settings_a;
+
+	u16 mir[MAX_MIR];			/* Memory Interleave Reg*/
 
 	u16 mtr[MAX_SLOTS][MAX_BRANCHES];		/* Memory Technlogy Reg */
 	u16 ambpresent[MAX_CHANNELS];		/* AMB present regs */
@@ -653,9 +656,15 @@ static int i7300_get_mc_regs(struct mem_ctl_info *mci)
 	/* Get memory controller settings */
 	pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map, MC_SETTINGS,
 			     &pvt->mc_settings);
+	pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map, MC_SETTINGS_A,
+			     &pvt->mc_settings_a);
 
-	debugf0("Memory controller operating on %s mode\n",
+	if (IS_SINGLE_MODE(pvt->mc_settings_a))
+		debugf0("Memory controller operating on single mode\n");
+	else
+		debugf0("Memory controller operating on %s mode\n",
 		IS_MIRRORED(pvt->mc_settings) ? "mirrored" : "non-mirrored");
+
 	debugf0("Error detection is %s\n",
 		IS_ECC_ENABLED(pvt->mc_settings) ? "enabled" : "disabled");
 	debugf0("Retry is %s\n",

commit d7de2bdb0e15c594aefbc71d899c4684a5ce6559
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 27 08:56:48 2010 -0300

    i7300_edac: Adds detection for enhanced scrub mode on x8
    
    While here, do some cleanup by adding some macros to check
    for device features.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index f2f171d0356a..27088af79672 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -93,6 +93,12 @@
 	/* OFFSETS for Function 1 */
 #define MC_SETTINGS		0x40
 
+#define IS_MIRRORED(mc)			((mc) & (1 << 16))
+#define IS_ECC_ENABLED(mc)		((mc) & (1 << 5))
+#define IS_RETRY_ENABLED(mc)		((mc) & (1 << 31))
+#define IS_SCRBALGO_ENHANCED(mc)	((mc) & (1 << 8))
+
+
 #define TOLM			0x6C
 #define REDMEMB			0x7C
 
@@ -451,9 +457,13 @@ static int decode_mtr(struct i7300_pvt *pvt,
 	p_csrow->edac_mode = EDAC_S8ECD8ED;
 
 	/* ask what device type on this row */
-	if (MTR_DRAM_WIDTH(mtr))
+	if (MTR_DRAM_WIDTH(mtr)) {
+		debugf0("Scrub algorithm for x8 is on %s mode\n",
+			IS_SCRBALGO_ENHANCED(pvt->mc_settings) ?
+					    "enhanced" : "normal");
+
 		p_csrow->dtype = DEV_X8;
-	else
+	} else
 		p_csrow->dtype = DEV_X4;
 
 	return mtr;
@@ -643,10 +653,13 @@ static int i7300_get_mc_regs(struct mem_ctl_info *mci)
 	/* Get memory controller settings */
 	pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map, MC_SETTINGS,
 			     &pvt->mc_settings);
+
 	debugf0("Memory controller operating on %s mode\n",
-		pvt->mc_settings & (1 << 16)? "mirrored" : "non-mirrored");
+		IS_MIRRORED(pvt->mc_settings) ? "mirrored" : "non-mirrored");
 	debugf0("Error detection is %s\n",
-		pvt->mc_settings & (1 << 5)? "enabled" : "disabled");
+		IS_ECC_ENABLED(pvt->mc_settings) ? "enabled" : "disabled");
+	debugf0("Retry is %s\n",
+		IS_RETRY_ENABLED(pvt->mc_settings) ? "enabled" : "disabled");
 
 	/* Get Memory Interleave Range registers */
 	pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR0, &pvt->mir[0]);

commit 86002324cf8809c72858741ab20bb7a855654b4c
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 27 00:46:57 2010 -0300

    i7300_edac: Clear the error bit after reading
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index e617b4f79dd8..f2f171d0356a 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -299,6 +299,11 @@ static void i7300_process_error_global(struct mem_ctl_info *mci,
 					ARRAY_SIZE(ferr_global_hi_name));
 		specific = GET_ERR_FROM_TABLE(ferr_global_hi_name, errnum);
 		is_fatal = ferr_global_hi_is_fatal(errnum);
+
+		/* Clear the error bit */
+		pci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,
+				       FERR_GLOBAL_HI, value);
+
 		goto error_global;
 	}
 
@@ -310,6 +315,11 @@ static void i7300_process_error_global(struct mem_ctl_info *mci,
 					ARRAY_SIZE(ferr_global_lo_name));
 		specific = GET_ERR_FROM_TABLE(ferr_global_lo_name, errnum);
 		is_fatal = ferr_global_lo_is_fatal(errnum);
+
+		/* Clear the error bit */
+		pci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,
+				       FERR_GLOBAL_LO, value);
+
 		goto error_global;
 	}
 	return;

commit 5de6e07ed75ee29a302f50e149339ca747131121
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 27 00:16:12 2010 -0300

    i7300_edac: Add error detection code for global errors
    
    There's no mention at the datasheet about how to enable global error
    reporting. So, I'm assuming that those errors are always enabled.
    Maybe I'm plain wrong about that ;)
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 3e60dbaa0e7e..e617b4f79dd8 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -158,8 +158,17 @@ static const char *numcol_toString[] = {
  * Device 16.2: Global Error Registers
  */
 
+#define FERR_GLOBAL_HI	0x48
+static const char *ferr_global_hi_name[] = {
+	[3] = "FSB 3 Fatal Error",
+	[2] = "FSB 2 Fatal Error",
+	[1] = "FSB 1 Fatal Error",
+	[0] = "FSB 0 Fatal Error",
+};
+#define ferr_global_hi_is_fatal(errno)	1
+
 #define FERR_GLOBAL_LO	0x40
-static const char *ferr_global_name[] = {
+static const char *ferr_global_lo_name[] = {
 	[31] = "Internal MCH Fatal Error",
 	[30] = "Intel QuickData Technology Device Fatal Error",
 	[29] = "FSB1 Fatal Error",
@@ -193,190 +202,7 @@ static const char *ferr_global_name[] = {
 	[1]  = "PCI Express Device 1 Non-Fatal Error",
 	[0]  = "ESI Non-Fatal Error",
 };
-
-#define NERR_GLOBAL	0x44
-static const char *nerr_global_name[] = {
-	[31] = "Internal MCH Fatal Error",
-	[30] = "Intel QuickData Technology Device Fatal Error",
-	[29] = "FSB1 Fatal Error",
-	[28] = "FSB0 Fatal Error",
-	[27] = "FSB2 Fatal Error",
-	[26] = "FSB3 Fatal Error",
-	[25] = "Reserved",
-	[24] = "FBD Channel 0,1,2 or 3 Fatal Error",
-	[23] = "PCI Express Device 7 Fatal Error",
-	[22] = "PCI Express Device 6 Fatal Error",
-	[21] = "PCI Express Device 5 Fatal Error",
-	[20] = "PCI Express Device 4 Fatal Error",
-	[19] = "PCI Express Device 3 Fatal Error",
-	[18] = "PCI Express Device 2 Fatal Error",
-	[17] = "PCI Express Device 1 Fatal Error",
-	[16] = "ESI Fatal Error",
-	[15] = "Internal MCH Non-Fatal Error",
-	[14] = "Intel QuickData Technology Device Non Fatal Error",
-	[13] = "FSB1 Non-Fatal Error",
-	[12] = "FSB0 Non-Fatal Error",
-	[11] = "FSB2 Non-Fatal Error",
-	[10] = "FSB3 Non-Fatal Error",
-	[9] = "Reserved",
-	[8] = "FBD Channel 0,1, 2 or 3 Non-Fatal Error",
-	[7] = "PCI Express Device 7 Non-Fatal Error",
-	[6] = "PCI Express Device 6 Non-Fatal Error",
-	[5] = "PCI Express Device 5 Non-Fatal Error",
-	[4] = "PCI Express Device 4 Non-Fatal Error",
-	[3] = "PCI Express Device 3 Non-Fatal Error",
-	[2] = "PCI Express Device 2 Non-Fatal Error",
-	[1] = "PCI Express Device 1 Non-Fatal Error",
-	[0] = "ESI Non-Fatal Error",
-};
-
-#if 0
-
-/*
- * Error indicator bits and masks
- * Error masks are according with Table 5-17 of i7300 datasheet
- */
-
-enum error_mask {
-	EMASK_M1  = 1<<0,  /* Memory Write error on non-redundant retry */
-	EMASK_M2  = 1<<1,  /* Memory or FB-DIMM configuration CRC read error */
-	EMASK_M3  = 1<<2,  /* Reserved */
-	EMASK_M4  = 1<<3,  /* Uncorrectable Data ECC on Replay */
-	EMASK_M5  = 1<<4,  /* Aliased Uncorrectable Non-Mirrored Demand Data ECC */
-	EMASK_M6  = 1<<5,  /* Unsupported on i7300 */
-	EMASK_M7  = 1<<6,  /* Aliased Uncorrectable Resilver- or Spare-Copy Data ECC */
-	EMASK_M8  = 1<<7,  /* Aliased Uncorrectable Patrol Data ECC */
-	EMASK_M9  = 1<<8,  /* Non-Aliased Uncorrectable Non-Mirrored Demand Data ECC */
-	EMASK_M10 = 1<<9,  /* Unsupported on i7300 */
-	EMASK_M11 = 1<<10, /* Non-Aliased Uncorrectable Resilver- or Spare-Copy Data ECC  */
-	EMASK_M12 = 1<<11, /* Non-Aliased Uncorrectable Patrol Data ECC */
-	EMASK_M13 = 1<<12, /* Memory Write error on first attempt */
-	EMASK_M14 = 1<<13, /* FB-DIMM Configuration Write error on first attempt */
-	EMASK_M15 = 1<<14, /* Memory or FB-DIMM configuration CRC read error */
-	EMASK_M16 = 1<<15, /* Channel Failed-Over Occurred */
-	EMASK_M17 = 1<<16, /* Correctable Non-Mirrored Demand Data ECC */
-	EMASK_M18 = 1<<17, /* Unsupported on i7300 */
-	EMASK_M19 = 1<<18, /* Correctable Resilver- or Spare-Copy Data ECC */
-	EMASK_M20 = 1<<19, /* Correctable Patrol Data ECC */
-	EMASK_M21 = 1<<20, /* FB-DIMM Northbound parity error on FB-DIMM Sync Status */
-	EMASK_M22 = 1<<21, /* SPD protocol Error */
-	EMASK_M23 = 1<<22, /* Non-Redundant Fast Reset Timeout */
-	EMASK_M24 = 1<<23, /* Refresh error */
-	EMASK_M25 = 1<<24, /* Memory Write error on redundant retry */
-	EMASK_M26 = 1<<25, /* Redundant Fast Reset Timeout */
-	EMASK_M27 = 1<<26, /* Correctable Counter Threshold Exceeded */
-	EMASK_M28 = 1<<27, /* DIMM-Spare Copy Completed */
-	EMASK_M29 = 1<<28, /* DIMM-Isolation Completed */
-};
-
-/*
- * Names to translate bit error into something useful
- */
-static const char *error_name[] = {
-	[0]  = "Memory Write error on non-redundant retry",
-	[1]  = "Memory or FB-DIMM configuration CRC read error",
-	/* Reserved */
-	[3]  = "Uncorrectable Data ECC on Replay",
-	[4]  = "Aliased Uncorrectable Non-Mirrored Demand Data ECC",
-	/* M6 Unsupported on i7300 */
-	[6]  = "Aliased Uncorrectable Resilver- or Spare-Copy Data ECC",
-	[7]  = "Aliased Uncorrectable Patrol Data ECC",
-	[8]  = "Non-Aliased Uncorrectable Non-Mirrored Demand Data ECC",
-	/* M10 Unsupported on i7300 */
-	[10] = "Non-Aliased Uncorrectable Resilver- or Spare-Copy Data ECC",
-	[11] = "Non-Aliased Uncorrectable Patrol Data ECC",
-	[12] = "Memory Write error on first attempt",
-	[13] = "FB-DIMM Configuration Write error on first attempt",
-	[14] = "Memory or FB-DIMM configuration CRC read error",
-	[15] = "Channel Failed-Over Occurred",
-	[16] = "Correctable Non-Mirrored Demand Data ECC",
-	/* M18 Unsupported on i7300 */
-	[18] = "Correctable Resilver- or Spare-Copy Data ECC",
-	[19] = "Correctable Patrol Data ECC",
-	[20] = "FB-DIMM Northbound parity error on FB-DIMM Sync Status",
-	[21] = "SPD protocol Error",
-	[22] = "Non-Redundant Fast Reset Timeout",
-	[23] = "Refresh error",
-	[24] = "Memory Write error on redundant retry",
-	[25] = "Redundant Fast Reset Timeout",
-	[26] = "Correctable Counter Threshold Exceeded",
-	[27] = "DIMM-Spare Copy Completed",
-	[28] = "DIMM-Isolation Completed",
-};
-
-/* Fatal errors */
-#define ERROR_FAT_MASK		(EMASK_M1 | \
-				 EMASK_M2 | \
-				 EMASK_M23)
-
-/* Correctable errors */
-#define ERROR_NF_CORRECTABLE	(EMASK_M27 | \
-				 EMASK_M20 | \
-				 EMASK_M19 | \
-				 EMASK_M18 | \
-				 EMASK_M17 | \
-				 EMASK_M16)
-#define ERROR_NF_DIMM_SPARE	(EMASK_M29 | \
-				 EMASK_M28)
-#define ERROR_NF_SPD_PROTOCOL	(EMASK_M22)
-#define ERROR_NF_NORTH_CRC	(EMASK_M21)
-
-/* Recoverable errors */
-#define ERROR_NF_RECOVERABLE	(EMASK_M26 | \
-				 EMASK_M25 | \
-				 EMASK_M24 | \
-				 EMASK_M15 | \
-				 EMASK_M14 | \
-				 EMASK_M13 | \
-				 EMASK_M12 | \
-				 EMASK_M11 | \
-				 EMASK_M9  | \
-				 EMASK_M8  | \
-				 EMASK_M7  | \
-				 EMASK_M5)
-
-/* uncorrectable errors */
-#define ERROR_NF_UNCORRECTABLE	(EMASK_M4)
-
-/* mask to all non-fatal errors */
-#define ERROR_NF_MASK		(ERROR_NF_CORRECTABLE   | \
-				 ERROR_NF_UNCORRECTABLE | \
-				 ERROR_NF_RECOVERABLE   | \
-				 ERROR_NF_DIMM_SPARE    | \
-				 ERROR_NF_SPD_PROTOCOL  | \
-				 ERROR_NF_NORTH_CRC)
-
-/*
- * Define error masks for the several registers
- */
-
-/* Enable all fatal and non fatal errors */
-#define ENABLE_EMASK_ALL	(ERROR_FAT_MASK | ERROR_NF_MASK)
-
-/* mask for fatal error registers */
-#define FERR_FAT_MASK ERROR_FAT_MASK
-
-/* masks for non-fatal error register */
-static inline int to_nf_mask(unsigned int mask)
-{
-	return (mask & EMASK_M29) | (mask >> 3);
-};
-
-static inline int from_nf_ferr(unsigned int mask)
-{
-	return (mask & EMASK_M29) |		/* Bit 28 */
-	       (mask & ((1 << 28) - 1) << 3);	/* Bits 0 to 27 */
-};
-
-#define FERR_NF_MASK		to_nf_mask(ERROR_NF_MASK)
-#define FERR_NF_CORRECTABLE	to_nf_mask(ERROR_NF_CORRECTABLE)
-#define FERR_NF_DIMM_SPARE	to_nf_mask(ERROR_NF_DIMM_SPARE)
-#define FERR_NF_SPD_PROTOCOL	to_nf_mask(ERROR_NF_SPD_PROTOCOL)
-#define FERR_NF_NORTH_CRC	to_nf_mask(ERROR_NF_NORTH_CRC)
-#define FERR_NF_RECOVERABLE	to_nf_mask(ERROR_NF_RECOVERABLE)
-#define FERR_NF_UNCORRECTABLE	to_nf_mask(ERROR_NF_UNCORRECTABLE)
-
-#endif
+#define ferr_global_lo_is_fatal(errno)	((errno < 16) ? 0 : 1)
 
 /* Device name and register DID (Device ID) */
 struct i7300_dev_info {
@@ -416,85 +242,28 @@ struct i7300_pvt {
 	struct i7300_dimm_info dimm_info[MAX_SLOTS][MAX_CHANNELS];
 };
 
-#if 0
-/* I7300 MCH error information retrieved from Hardware */
-struct i7300_error_info {
-	/* These registers are always read from the MC */
-	u32 ferr_fat_fbd;	/* First Errors Fatal */
-	u32 nerr_fat_fbd;	/* Next Errors Fatal */
-	u32 ferr_nf_fbd;	/* First Errors Non-Fatal */
-	u32 nerr_nf_fbd;	/* Next Errors Non-Fatal */
-
-	/* These registers are input ONLY if there was a Recoverable Error */
-	u32 redmemb;		/* Recoverable Mem Data Error log B */
-	u16 recmema;		/* Recoverable Mem Error log A */
-	u32 recmemb;		/* Recoverable Mem Error log B */
-
-	/* These registers are input ONLY if there was a Non-Rec Error */
-	u16 nrecmema;		/* Non-Recoverable Mem log A */
-	u16 nrecmemb;		/* Non-Recoverable Mem log B */
-
-};
-#endif
-
 /* FIXME: Why do we need to have this static? */
 static struct edac_pci_ctl_info *i7300_pci;
 
+/********************************************
+ * i7300 Functions related to error detection
+ ********************************************/
 
-#if 0
-/* note that nrec_rdwr changed from NRECMEMA to NRECMEMB between the 5000 and
-   5400 better to use an inline function than a macro in this case */
-static inline int nrec_bank(struct i7300_error_info *info)
-{
-	return ((info->nrecmema) >> 12) & 0x7;
-}
-static inline int nrec_rank(struct i7300_error_info *info)
-{
-	return ((info->nrecmema) >> 8) & 0xf;
-}
-static inline int nrec_buf_id(struct i7300_error_info *info)
-{
-	return ((info->nrecmema)) & 0xff;
-}
-static inline int nrec_rdwr(struct i7300_error_info *info)
-{
-	return (info->nrecmemb) >> 31;
-}
-/* This applies to both NREC and REC string so it can be used with nrec_rdwr
-   and rec_rdwr */
-static inline const char *rdwr_str(int rdwr)
-{
-	return rdwr ? "Write" : "Read";
-}
-static inline int nrec_cas(struct i7300_error_info *info)
-{
-	return ((info->nrecmemb) >> 16) & 0x1fff;
-}
-static inline int nrec_ras(struct i7300_error_info *info)
-{
-	return (info->nrecmemb) & 0xffff;
-}
-static inline int rec_bank(struct i7300_error_info *info)
-{
-	return ((info->recmema) >> 12) & 0x7;
-}
-static inline int rec_rank(struct i7300_error_info *info)
-{
-	return ((info->recmema) >> 8) & 0xf;
-}
-static inline int rec_rdwr(struct i7300_error_info *info)
-{
-	return (info->recmemb) >> 31;
-}
-static inline int rec_cas(struct i7300_error_info *info)
-{
-	return ((info->recmemb) >> 16) & 0x1fff;
-}
-static inline int rec_ras(struct i7300_error_info *info)
+struct i7300_error_info {
+	int dummy;	/* FIXME */
+};
+
+const char *get_err_from_table(const char *table[], int size, int pos)
 {
-	return (info->recmemb) & 0xffff;
+	if (pos >= size)
+		return "Reserved";
+
+	return table[pos];
 }
 
+#define GET_ERR_FROM_TABLE(table, pos)				\
+	get_err_from_table(table, ARRAY_SIZE(table), pos)
+
 /*
  *	i7300_get_error_info	Retrieve the hardware error information from
  *				the hardware and cache it in the 'info'
@@ -503,234 +272,63 @@ static inline int rec_ras(struct i7300_error_info *info)
 static void i7300_get_error_info(struct mem_ctl_info *mci,
 				 struct i7300_error_info *info)
 {
-	struct i7300_pvt *pvt;
-	u32 value;
-
-	pvt = mci->pvt_info;
-
-	/* read in the 1st FATAL error register */
-	pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map, FERR_FAT_FBD, &value);
-
-	/* Mask only the bits that the doc says are valid
-	 */
-	value &= (FERR_FAT_FBDCHAN | FERR_FAT_MASK);
-
-	/* If there is an error, then read in the
-	   NEXT FATAL error register and the Memory Error Log Register A
-	 */
-	if (value & FERR_FAT_MASK) {
-		info->ferr_fat_fbd = value;
-
-		/* harvest the various error data we need */
-		pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
-				NERR_FAT_FBD, &info->nerr_fat_fbd);
-		pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map,
-				NRECMEMA, &info->nrecmema);
-		pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map,
-				NRECMEMB, &info->nrecmemb);
-
-		/* Clear the error bits, by writing them back */
-		pci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
-				FERR_FAT_FBD, value);
-	} else {
-		info->ferr_fat_fbd = 0;
-		info->nerr_fat_fbd = 0;
-		info->nrecmema = 0;
-		info->nrecmemb = 0;
-	}
-
-	/* read in the 1st NON-FATAL error register */
-	pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map, FERR_NF_FBD, &value);
-
-	/* If there is an error, then read in the 1st NON-FATAL error
-	 * register as well */
-	if (value & FERR_NF_MASK) {
-		info->ferr_nf_fbd = value;
-
-		/* harvest the various error data we need */
-		pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
-				NERR_NF_FBD, &info->nerr_nf_fbd);
-		pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map,
-				RECMEMA, &info->recmema);
-		pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
-				RECMEMB, &info->recmemb);
-		pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
-				REDMEMB, &info->redmemb);
-
-		/* Clear the error bits, by writing them back */
-		pci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
-				FERR_NF_FBD, value);
-	} else {
-		info->ferr_nf_fbd = 0;
-		info->nerr_nf_fbd = 0;
-		info->recmema = 0;
-		info->recmemb = 0;
-		info->redmemb = 0;
-	}
 }
 
 /*
- * i7300_proccess_non_recoverable_info(struct mem_ctl_info *mci,
- * 					struct i7300_error_info *info,
- * 					int handle_errors);
- *
- *	handle the Intel FATAL and unrecoverable errors, if any
- */
-static void i7300_proccess_non_recoverable_info(struct mem_ctl_info *mci,
-				    struct i7300_error_info *info,
-				    unsigned long allErrors)
-{
-	char msg[EDAC_MC_LABEL_LEN + 1 + 90 + 80];
-	int branch;
-	int channel;
-	int bank;
-	int buf_id;
-	int rank;
-	int rdwr;
-	int ras, cas;
-	int errnum;
-	char *type = NULL;
-
-	if (!allErrors)
-		return;		/* if no error, return now */
-
-	if (allErrors &  ERROR_FAT_MASK)
-		type = "FATAL";
-	else if (allErrors & FERR_NF_UNCORRECTABLE)
-		type = "NON-FATAL uncorrected";
-	else
-		type = "NON-FATAL recoverable";
-
-	/* ONLY ONE of the possible error bits will be set, as per the docs */
-
-	branch = extract_fbdchan_indx(info->ferr_fat_fbd);
-	channel = branch;
-
-	/* Use the NON-Recoverable macros to extract data */
-	bank = nrec_bank(info);
-	rank = nrec_rank(info);
-	buf_id = nrec_buf_id(info);
-	rdwr = nrec_rdwr(info);
-	ras = nrec_ras(info);
-	cas = nrec_cas(info);
-
-	debugf0("\t\tCSROW= %d  Channels= %d,%d  (Branch= %d "
-		"DRAM Bank= %d Buffer ID = %d rdwr= %s ras= %d cas= %d)\n",
-		rank, channel, channel + 1, branch >> 1, bank,
-		buf_id, rdwr_str(rdwr), ras, cas);
-
-	/* Only 1 bit will be on */
-	errnum = find_first_bit(&allErrors, ARRAY_SIZE(error_name));
-
-	/* Form out message */
-	snprintf(msg, sizeof(msg),
-		 "%s (Branch=%d DRAM-Bank=%d Buffer ID = %d RDWR=%s "
-		 "RAS=%d CAS=%d %s Err=0x%lx (%s))",
-		 type, branch >> 1, bank, buf_id, rdwr_str(rdwr), ras, cas,
-		 type, allErrors, error_name[errnum]);
-
-	/* Call the helper to output message */
-	edac_mc_handle_fbd_ue(mci, rank, channel, channel + 1, msg);
-}
-
-/*
- * i7300_process_fatal_error_info(struct mem_ctl_info *mci,
- * 				struct i7300_error_info *info,
- * 				int handle_errors);
- *
- *	handle the Intel NON-FATAL errors, if any
+ *	i7300_process_error_global Retrieve the hardware error information from
+ *				the hardware and cache it in the 'info'
+ *				structure
  */
-static void i7300_process_nonfatal_error_info(struct mem_ctl_info *mci,
-					struct i7300_error_info *info)
+static void i7300_process_error_global(struct mem_ctl_info *mci,
+				 struct i7300_error_info *info)
 {
-	char msg[EDAC_MC_LABEL_LEN + 1 + 90 + 80];
-	unsigned long allErrors;
-	int branch;
-	int channel;
-	int bank;
-	int rank;
-	int rdwr;
-	int ras, cas;
-	int errnum;
-
-	/* mask off the Error bits that are possible */
-	allErrors = from_nf_ferr(info->ferr_nf_fbd & FERR_NF_MASK);
-	if (!allErrors)
-		return;		/* if no error, return now */
-
-	/* ONLY ONE of the possible error bits will be set, as per the docs */
-
-	if (allErrors & (ERROR_NF_UNCORRECTABLE | ERROR_NF_RECOVERABLE)) {
-		i7300_proccess_non_recoverable_info(mci, info, allErrors);
-		return;
-	}
-
-	/* Correctable errors */
-	if (allErrors & ERROR_NF_CORRECTABLE) {
-		debugf0("\tCorrected bits= 0x%lx\n", allErrors);
-
-		branch = extract_fbdchan_indx(info->ferr_nf_fbd);
-
-		channel = 0;
-		if (REC_ECC_LOCATOR_ODD(info->redmemb))
-			channel = 1;
-
-		/* Convert channel to be based from zero, instead of
-		 * from branch base of 0 */
-		channel += branch;
-
-		bank = rec_bank(info);
-		rank = rec_rank(info);
-		rdwr = rec_rdwr(info);
-		ras = rec_ras(info);
-		cas = rec_cas(info);
-
-		/* Only 1 bit will be on */
-		errnum = find_first_bit(&allErrors, ARRAY_SIZE(error_name));
-
-		debugf0("\t\tCSROW= %d Channel= %d  (Branch %d "
-			"DRAM Bank= %d rdwr= %s ras= %d cas= %d)\n",
-			rank, channel, branch >> 1, bank,
-			rdwr_str(rdwr), ras, cas);
-
-		/* Form out message */
-		snprintf(msg, sizeof(msg),
-			 "Corrected error (Branch=%d DRAM-Bank=%d RDWR=%s "
-			 "RAS=%d CAS=%d, CE Err=0x%lx (%s))",
-			 branch >> 1, bank, rdwr_str(rdwr), ras, cas,
-			 allErrors, error_name[errnum]);
+	struct i7300_pvt *pvt;
+	u32 errnum, value;
+	unsigned long errors;
+	const char *specific;
+	bool is_fatal;
 
-		/* Call the helper to output message */
-		edac_mc_handle_fbd_ce(mci, rank, channel, msg);
+	pvt = mci->pvt_info;
 
-		return;
+	/* read in the 1st FATAL error register */
+	pci_read_config_dword(pvt->pci_dev_16_2_fsb_err_regs,
+			      FERR_GLOBAL_HI, &value);
+	if (unlikely(value)) {
+		errors = value;
+		errnum = find_first_bit(&errors,
+					ARRAY_SIZE(ferr_global_hi_name));
+		specific = GET_ERR_FROM_TABLE(ferr_global_hi_name, errnum);
+		is_fatal = ferr_global_hi_is_fatal(errnum);
+		goto error_global;
 	}
 
-	/* Miscelaneous errors */
-	errnum = find_first_bit(&allErrors, ARRAY_SIZE(error_name));
-
-	branch = extract_fbdchan_indx(info->ferr_nf_fbd);
+	pci_read_config_dword(pvt->pci_dev_16_2_fsb_err_regs,
+			      FERR_GLOBAL_LO, &value);
+	if (unlikely(value)) {
+		errors = value;
+		errnum = find_first_bit(&errors,
+					ARRAY_SIZE(ferr_global_lo_name));
+		specific = GET_ERR_FROM_TABLE(ferr_global_lo_name, errnum);
+		is_fatal = ferr_global_lo_is_fatal(errnum);
+		goto error_global;
+	}
+	return;
 
-	i7300_mc_printk(mci, KERN_EMERG,
-			"Non-Fatal misc error (Branch=%d Err=%#lx (%s))",
-			branch >> 1, allErrors, error_name[errnum]);
+error_global:
+	i7300_mc_printk(mci, KERN_EMERG, "%s misc error: %s\n",
+			is_fatal ? "Fatal" : "NOT fatal", specific);
 }
 
 /*
- *	i7300_process_error_info	Process the error info that is
- *	in the 'info' structure, previously retrieved from hardware
+ *	i7300_process_error_info Retrieve the hardware error information from
+ *				the hardware and cache it in the 'info'
+ *				structure
  */
 static void i7300_process_error_info(struct mem_ctl_info *mci,
-				struct i7300_error_info *info)
-{	u32 allErrors;
-
-	/* First handle any fatal errors that occurred */
-	allErrors = (info->ferr_fat_fbd & FERR_FAT_MASK);
-	i7300_proccess_non_recoverable_info(mci, info, allErrors);
-
-	/* now handle any non-fatal errors that occurred */
-	i7300_process_nonfatal_error_info(mci, info);
-}
+				 struct i7300_error_info *info)
+{
+	i7300_process_error_global(mci, info);
+};
 
 /*
  *	i7300_clear_error	Retrieve any error from the hardware
@@ -753,6 +351,7 @@ static void i7300_check_error(struct mem_ctl_info *mci)
 {
 	struct i7300_error_info info;
 	debugf4("MC%d: " __FILE__ ": %s()\n", mci->mc_idx, __func__);
+
 	i7300_get_error_info(mci, &info);
 	i7300_process_error_info(mci, &info);
 }
@@ -763,22 +362,11 @@ static void i7300_check_error(struct mem_ctl_info *mci)
  */
 static void i7300_enable_error_reporting(struct mem_ctl_info *mci)
 {
-	struct i7300_pvt *pvt;
-	u32 fbd_error_mask;
-
-	pvt = mci->pvt_info;
-
-	/* Read the FBD Error Mask Register */
-	pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map, EMASK_FBD,
-			&fbd_error_mask);
-
-	/* Enable with a '0' */
-	fbd_error_mask &= ~(ENABLE_EMASK_ALL);
-
-	pci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map, EMASK_FBD,
-			fbd_error_mask);
 }
-#endif
+
+/************************************************
+ * i7300 Functions related to memory enumberation
+ ************************************************/
 
 /*
  * determine_mtr(pvt, csrow, channel)
@@ -1070,6 +658,10 @@ static int i7300_get_mc_regs(struct mem_ctl_info *mci)
 	return 0;
 }
 
+/*************************************************
+ * i7300 Functions related to device probe/release
+ *************************************************/
+
 /*
  *	i7300_put_devices	'put' all the devices that we have
  *				reserved via 'get'
@@ -1238,10 +830,8 @@ static int i7300_probe1(struct pci_dev *pdev, int dev_idx)
 	mci->dev_name = pci_name(pdev);
 	mci->ctl_page_to_phys = NULL;
 
-#if 0
 	/* Set the function pointer to an actual operation function */
 	mci->edac_check = i7300_check_error;
-#endif
 
 	/* initialize the MC control structure 'csrows' table
 	 * with the mapping and control information */
@@ -1251,10 +841,8 @@ static int i7300_probe1(struct pci_dev *pdev, int dev_idx)
 			"value\n");
 		mci->edac_cap = EDAC_FLAG_NONE;	/* no csrows found */
 	} else {
-#if 0
 		debugf1("MC: Enable error reporting now\n");
 		i7300_enable_error_reporting(mci);
-#endif
 	}
 
 	/* add this new MC control structure to EDAC's list of MCs */
@@ -1267,9 +855,7 @@ static int i7300_probe1(struct pci_dev *pdev, int dev_idx)
 		goto fail1;
 	}
 
-#if 0
 	i7300_clear_error(mci);
-#endif
 
 	/* allocating generic PCI control info */
 	i7300_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);

commit 3e57eef64c53d4a45790fb7bb60a4ee6bf2bad30
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Aug 26 23:38:11 2010 -0300

    i7300_edac: Better name PCI devices
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 36265e21fef2..3e60dbaa0e7e 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -398,10 +398,10 @@ struct i7300_dimm_info {
 
 /* driver private data structure */
 struct i7300_pvt {
-	struct pci_dev *system_address;		/* 16.0 */
-	struct pci_dev *branchmap_werrors;	/* 16.1 */
-	struct pci_dev *fsb_error_regs;		/* 16.2 */
-	struct pci_dev *branch_pci[MAX_BRANCHES];	/* 21.0  and 22.0 */
+	struct pci_dev *pci_dev_16_0_fsb_ctlr;		/* 16.0 */
+	struct pci_dev *pci_dev_16_1_fsb_addr_map;	/* 16.1 */
+	struct pci_dev *pci_dev_16_2_fsb_err_regs;	/* 16.2 */
+	struct pci_dev *pci_dev_2x_0_fbd_branch[MAX_BRANCHES];	/* 21.0  and 22.0 */
 
 	u16 tolm;				/* top of low memory */
 	u64 ambase;				/* AMB BAR */
@@ -509,7 +509,7 @@ static void i7300_get_error_info(struct mem_ctl_info *mci,
 	pvt = mci->pvt_info;
 
 	/* read in the 1st FATAL error register */
-	pci_read_config_dword(pvt->branchmap_werrors, FERR_FAT_FBD, &value);
+	pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map, FERR_FAT_FBD, &value);
 
 	/* Mask only the bits that the doc says are valid
 	 */
@@ -522,15 +522,15 @@ static void i7300_get_error_info(struct mem_ctl_info *mci,
 		info->ferr_fat_fbd = value;
 
 		/* harvest the various error data we need */
-		pci_read_config_dword(pvt->branchmap_werrors,
+		pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
 				NERR_FAT_FBD, &info->nerr_fat_fbd);
-		pci_read_config_word(pvt->branchmap_werrors,
+		pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map,
 				NRECMEMA, &info->nrecmema);
-		pci_read_config_word(pvt->branchmap_werrors,
+		pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map,
 				NRECMEMB, &info->nrecmemb);
 
 		/* Clear the error bits, by writing them back */
-		pci_write_config_dword(pvt->branchmap_werrors,
+		pci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
 				FERR_FAT_FBD, value);
 	} else {
 		info->ferr_fat_fbd = 0;
@@ -540,7 +540,7 @@ static void i7300_get_error_info(struct mem_ctl_info *mci,
 	}
 
 	/* read in the 1st NON-FATAL error register */
-	pci_read_config_dword(pvt->branchmap_werrors, FERR_NF_FBD, &value);
+	pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map, FERR_NF_FBD, &value);
 
 	/* If there is an error, then read in the 1st NON-FATAL error
 	 * register as well */
@@ -548,17 +548,17 @@ static void i7300_get_error_info(struct mem_ctl_info *mci,
 		info->ferr_nf_fbd = value;
 
 		/* harvest the various error data we need */
-		pci_read_config_dword(pvt->branchmap_werrors,
+		pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
 				NERR_NF_FBD, &info->nerr_nf_fbd);
-		pci_read_config_word(pvt->branchmap_werrors,
+		pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map,
 				RECMEMA, &info->recmema);
-		pci_read_config_dword(pvt->branchmap_werrors,
+		pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
 				RECMEMB, &info->recmemb);
-		pci_read_config_dword(pvt->branchmap_werrors,
+		pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
 				REDMEMB, &info->redmemb);
 
 		/* Clear the error bits, by writing them back */
-		pci_write_config_dword(pvt->branchmap_werrors,
+		pci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,
 				FERR_NF_FBD, value);
 	} else {
 		info->ferr_nf_fbd = 0;
@@ -769,13 +769,13 @@ static void i7300_enable_error_reporting(struct mem_ctl_info *mci)
 	pvt = mci->pvt_info;
 
 	/* Read the FBD Error Mask Register */
-	pci_read_config_dword(pvt->branchmap_werrors, EMASK_FBD,
+	pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map, EMASK_FBD,
 			&fbd_error_mask);
 
 	/* Enable with a '0' */
 	fbd_error_mask &= ~(ENABLE_EMASK_ALL);
 
-	pci_write_config_dword(pvt->branchmap_werrors, EMASK_FBD,
+	pci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map, EMASK_FBD,
 			fbd_error_mask);
 }
 #endif
@@ -957,13 +957,13 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 	for (branch = 0; branch < MAX_BRANCHES; branch++) {
 		/* Read and dump branch 0's MTRs */
 		channel = to_channel(0, branch);
-		pci_read_config_word(pvt->branch_pci[branch], AMBPRESENT_0,
+		pci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch], AMBPRESENT_0,
 				&pvt->ambpresent[channel]);
 		debugf2("\t\tAMB-present CH%d = 0x%x:\n",
 			channel, pvt->ambpresent[channel]);
 
 		channel = to_channel(1, branch);
-		pci_read_config_word(pvt->branch_pci[branch], AMBPRESENT_1,
+		pci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch], AMBPRESENT_1,
 				&pvt->ambpresent[channel]);
 		debugf2("\t\tAMB-present CH%d = 0x%x:\n",
 			channel, pvt->ambpresent[channel]);
@@ -973,7 +973,7 @@ static int i7300_init_csrows(struct mem_ctl_info *mci)
 	for (slot = 0; slot < MAX_SLOTS; slot++) {
 		int where = mtr_regs[slot];
 		for (branch = 0; branch < MAX_BRANCHES; branch++) {
-			pci_read_config_word(pvt->branch_pci[branch],
+			pci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],
 					where,
 					&pvt->mtr[slot][branch]);
 			for (ch = 0; ch < MAX_BRANCHES; ch++) {
@@ -1027,13 +1027,13 @@ static int i7300_get_mc_regs(struct mem_ctl_info *mci)
 
 	pvt = mci->pvt_info;
 
-	pci_read_config_dword(pvt->system_address, AMBASE,
+	pci_read_config_dword(pvt->pci_dev_16_0_fsb_ctlr, AMBASE,
 			(u32 *) &pvt->ambase);
 
 	debugf2("AMBASE= 0x%lx\n", (long unsigned int)pvt->ambase);
 
 	/* Get the Branch Map regs */
-	pci_read_config_word(pvt->branchmap_werrors, TOLM, &pvt->tolm);
+	pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, TOLM, &pvt->tolm);
 	pvt->tolm >>= 12;
 	debugf2("TOLM (number of 256M regions) =%u (0x%x)\n", pvt->tolm,
 		pvt->tolm);
@@ -1043,7 +1043,7 @@ static int i7300_get_mc_regs(struct mem_ctl_info *mci)
 		actual_tolm/1000, actual_tolm % 1000, pvt->tolm << 28);
 
 	/* Get memory controller settings */
-	pci_read_config_dword(pvt->branchmap_werrors, MC_SETTINGS,
+	pci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map, MC_SETTINGS,
 			     &pvt->mc_settings);
 	debugf0("Memory controller operating on %s mode\n",
 		pvt->mc_settings & (1 << 16)? "mirrored" : "non-mirrored");
@@ -1051,9 +1051,9 @@ static int i7300_get_mc_regs(struct mem_ctl_info *mci)
 		pvt->mc_settings & (1 << 5)? "enabled" : "disabled");
 
 	/* Get Memory Interleave Range registers */
-	pci_read_config_word(pvt->branchmap_werrors, MIR0, &pvt->mir[0]);
-	pci_read_config_word(pvt->branchmap_werrors, MIR1, &pvt->mir[1]);
-	pci_read_config_word(pvt->branchmap_werrors, MIR2, &pvt->mir[2]);
+	pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR0, &pvt->mir[0]);
+	pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR1, &pvt->mir[1]);
+	pci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR2, &pvt->mir[2]);
 
 	/* Decode the MIR regs */
 	for (i = 0; i < MAX_MIR; i++)
@@ -1083,9 +1083,9 @@ static void i7300_put_devices(struct mem_ctl_info *mci)
 
 	/* Decrement usage count for devices */
 	for (branch = 0; branch < MAX_CH_PER_BRANCH; branch++)
-		pci_dev_put(pvt->branch_pci[branch]);
-	pci_dev_put(pvt->fsb_error_regs);
-	pci_dev_put(pvt->branchmap_werrors);
+		pci_dev_put(pvt->pci_dev_2x_0_fbd_branch[branch]);
+	pci_dev_put(pvt->pci_dev_16_2_fsb_err_regs);
+	pci_dev_put(pvt->pci_dev_16_1_fsb_addr_map);
 }
 
 /*
@@ -1103,7 +1103,7 @@ static int i7300_get_devices(struct mem_ctl_info *mci, int dev_idx)
 
 	/* Attempt to 'get' the MCH register we want */
 	pdev = NULL;
-	while (!pvt->branchmap_werrors || !pvt->fsb_error_regs) {
+	while (!pvt->pci_dev_16_1_fsb_addr_map || !pvt->pci_dev_16_2_fsb_err_regs) {
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_I7300_MCH_ERR, pdev);
 		if (!pdev) {
@@ -1121,28 +1121,28 @@ static int i7300_get_devices(struct mem_ctl_info *mci, int dev_idx)
 		/* Store device 16 funcs 1 and 2 */
 		switch (PCI_FUNC(pdev->devfn)) {
 		case 1:
-			pvt->branchmap_werrors = pdev;
+			pvt->pci_dev_16_1_fsb_addr_map = pdev;
 			break;
 		case 2:
-			pvt->fsb_error_regs = pdev;
+			pvt->pci_dev_16_2_fsb_err_regs = pdev;
 			break;
 		}
 	}
 
 	debugf1("System Address, processor bus- PCI Bus ID: %s  %x:%x\n",
-		pci_name(pvt->system_address),
-		pvt->system_address->vendor, pvt->system_address->device);
+		pci_name(pvt->pci_dev_16_0_fsb_ctlr),
+		pvt->pci_dev_16_0_fsb_ctlr->vendor, pvt->pci_dev_16_0_fsb_ctlr->device);
 	debugf1("Branchmap, control and errors - PCI Bus ID: %s  %x:%x\n",
-		pci_name(pvt->branchmap_werrors),
-		pvt->branchmap_werrors->vendor, pvt->branchmap_werrors->device);
+		pci_name(pvt->pci_dev_16_1_fsb_addr_map),
+		pvt->pci_dev_16_1_fsb_addr_map->vendor, pvt->pci_dev_16_1_fsb_addr_map->device);
 	debugf1("FSB Error Regs - PCI Bus ID: %s  %x:%x\n",
-		pci_name(pvt->fsb_error_regs),
-		pvt->fsb_error_regs->vendor, pvt->fsb_error_regs->device);
+		pci_name(pvt->pci_dev_16_2_fsb_err_regs),
+		pvt->pci_dev_16_2_fsb_err_regs->vendor, pvt->pci_dev_16_2_fsb_err_regs->device);
 
-	pvt->branch_pci[0] = pci_get_device(PCI_VENDOR_ID_INTEL,
+	pvt->pci_dev_2x_0_fbd_branch[0] = pci_get_device(PCI_VENDOR_ID_INTEL,
 				            PCI_DEVICE_ID_INTEL_I7300_MCH_FB0,
 					    NULL);
-	if (!pvt->branch_pci[0]) {
+	if (!pvt->pci_dev_2x_0_fbd_branch[0]) {
 		i7300_printk(KERN_ERR,
 			"MC: 'BRANCH 0' device not found:"
 			"vendor 0x%x device 0x%x Func 0 (broken BIOS?)\n",
@@ -1150,10 +1150,10 @@ static int i7300_get_devices(struct mem_ctl_info *mci, int dev_idx)
 		goto error;
 	}
 
-	pvt->branch_pci[1] = pci_get_device(PCI_VENDOR_ID_INTEL,
+	pvt->pci_dev_2x_0_fbd_branch[1] = pci_get_device(PCI_VENDOR_ID_INTEL,
 					    PCI_DEVICE_ID_INTEL_I7300_MCH_FB1,
 					    NULL);
-	if (!pvt->branch_pci[1]) {
+	if (!pvt->pci_dev_2x_0_fbd_branch[1]) {
 		i7300_printk(KERN_ERR,
 			"MC: 'BRANCH 1' device not found:"
 			"vendor 0x%x device 0x%x Func 0 "
@@ -1222,7 +1222,7 @@ static int i7300_probe1(struct pci_dev *pdev, int dev_idx)
 	mci->dev = &pdev->dev;	/* record ptr  to the generic device */
 
 	pvt = mci->pvt_info;
-	pvt->system_address = pdev;	/* Record this device in our private */
+	pvt->pci_dev_16_0_fsb_ctlr = pdev;	/* Record this device in our private */
 
 	/* 'get' the pci devices we want to reserve for our use */
 	if (i7300_get_devices(mci, dev_idx))

commit 116389ed21e4ad88f65e7ec5ed6ca224acb89115
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Aug 26 23:19:54 2010 -0300

    i7300_edac: Add a FIXME note about the error correction type
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index 7e035b6d0d0f..36265e21fef2 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -841,6 +841,15 @@ static int decode_mtr(struct i7300_pvt *pvt,
 	p_csrow->grain = 8;
 	p_csrow->nr_pages = dinfo->megabytes << 8;
 	p_csrow->mtype = MEM_FB_DDR2;
+
+	/*
+	 * FIXME: the type of error detection actually depends of the
+	 * mode of operation. When it is just one single memory chip, at
+	 * socket 0, channel 0, it uses  8-byte-over-32-byte SECDED+ code.
+	 * In normal or mirrored mode, it uses Single Device Data correction,
+	 * with the possibility of using an extended algorithm for x8 memories
+	 * See datasheet Sections 7.3.6 to 7.3.8
+	 */
 	p_csrow->edac_mode = EDAC_S8ECD8ED;
 
 	/* ask what device type on this row */

commit c3af2eaf7a3257f7b44165ec487215574c47fd32
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Aug 26 19:54:51 2010 -0300

    i7300_edac: add global error registers
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index db194b6b3e42..7e035b6d0d0f 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -50,7 +50,7 @@
  *	Except on Single Channel mode of operation
  *		just slot 0/channel0 filled on this mode
  *	On normal operation mode, the two channels on a branch should be
-		filled together for the same SLOT#
+ *		filled together for the same SLOT#
  * When in mirrored mode, Branch 1 replicate memory at Branch 0, so, the four
  *		channels on both branches should be filled
  */
@@ -67,16 +67,22 @@
 #define to_csrow(slot, ch, branch)					\
 		(to_channel(ch, branch) | ((slot) << 2))
 
-
-/* Device 16,
- * Function 0: System Address (not documented)
- * Function 1: Memory Branch Map, Control, Errors Register
- * Function 2: FSB Error Registers
- *
+/*
+ * I7300 devices
  * All 3 functions of Device 16 (0,1,2) share the SAME DID and
  * uses PCI_DEVICE_ID_INTEL_I7300_MCH_ERR for device 16 (0,1,2),
  * PCI_DEVICE_ID_INTEL_I7300_MCH_FB0 and PCI_DEVICE_ID_INTEL_I7300_MCH_FB1
  * for device 21 (0,1).
+ */
+
+/****************************************************
+ * i7300 Register definitions for memory enumberation
+ ****************************************************/
+
+/*
+ * Device 16,
+ * Function 0: System Address (not documented)
+ * Function 1: Memory Branch Map, Control, Errors Register
  */
 
 	/* OFFSETS for Function 0 */
@@ -94,50 +100,6 @@
 #define MIR1			0x84
 #define MIR2			0x88
 
-#if 0
-#define		AMIR0			0x8c
-#define		AMIR1			0x90
-#define		AMIR2			0x94
-
-/*TODO: double check it */
-#define			REC_ECC_LOCATOR_ODD(x)	((x) & 0x3fe00) /* bits [17:9] indicate ODD, [8:0]  indicate EVEN */
-
-	/* Fatal error registers */
-#define		FERR_FAT_FBD		0x98
-
-/*TODO: double check it */
-#define			FERR_FAT_FBDCHAN (3<<28)	/* channel index where the highest-order error occurred */
-
-#define		NERR_FAT_FBD		0x9c
-#define		FERR_NF_FBD		0xa0
-
-	/* Non-fatal error register */
-#define		NERR_NF_FBD		0xa4
-
-	/* Enable error mask */
-#define		EMASK_FBD		0xa8
-
-#define		ERR0_FBD		0xac
-#define		ERR1_FBD		0xb0
-#define		ERR2_FBD		0xb4
-#define		MCERR_FBD		0xb8
-
-#endif
-
-/* TODO: Dev 16 fn1 allows memory error injection - offsets 0x100-0x10b */
-
-	/* TODO: OFFSETS for Device 16 Function 2 */
-
-/*
- * Device 21,
- * Function 0: Memory Map Branch 0
- *
- * Device 22,
- * Function 0: Memory Map Branch 1
- */
-
-	/* OFFSETS for Function 0 */
-
 /*
  * Note: Other Intel EDAC drivers use AMBPRESENT to identify if the available
  * memory. From datasheet item 7.3.1 (FB-DIMM technology & organization), it
@@ -171,37 +133,6 @@ const static u16 mtr_regs [MAX_SLOTS] = {
 #define MTR_DIMM_COLS(mtr)		((mtr) & 0x3)
 #define MTR_DIMM_COLS_ADDR_BITS(mtr)	(MTR_DIMM_COLS(mtr) + 10)
 
-#if 0
-	/* OFFSETS for Function 1 */
-
-/* TODO */
-#define NRECFGLOG		0x74
-#define RECFGLOG		0x78
-#define NRECMEMA		0xbe
-#define NRECMEMB		0xc0
-#define NRECFB_DIMMA		0xc4
-#define NRECFB_DIMMB		0xc8
-#define NRECFB_DIMMC		0xcc
-#define NRECFB_DIMMD		0xd0
-#define NRECFB_DIMME		0xd4
-#define NRECFB_DIMMF		0xd8
-#define REDMEMA			0xdC
-#define RECMEMA			0xf0
-#define RECMEMB			0xf4
-#define RECFB_DIMMA		0xf8
-#define RECFB_DIMMB		0xec
-#define RECFB_DIMMC		0xf0
-#define RECFB_DIMMD		0xf4
-#define RECFB_DIMME		0xf8
-#define RECFB_DIMMF		0xfC
-
-/* This applies to FERR_NF_FB-DIMM as well as FERR_FAT_FB-DIMM */
-static inline int extract_fbdchan_indx(u32 x)
-{
-	return (x>>28) & 0x3;
-}
-#endif
-
 #ifdef CONFIG_EDAC_DEBUG
 /* MTR NUMROW */
 static const char *numrow_toString[] = {
@@ -220,6 +151,85 @@ static const char *numcol_toString[] = {
 };
 #endif
 
+/************************************************
+ * i7300 Register definitions for error detection
+ ************************************************/
+/*
+ * Device 16.2: Global Error Registers
+ */
+
+#define FERR_GLOBAL_LO	0x40
+static const char *ferr_global_name[] = {
+	[31] = "Internal MCH Fatal Error",
+	[30] = "Intel QuickData Technology Device Fatal Error",
+	[29] = "FSB1 Fatal Error",
+	[28] = "FSB0 Fatal Error",
+	[27] = "FBD Channel 3 Fatal Error",
+	[26] = "FBD Channel 2 Fatal Error",
+	[25] = "FBD Channel 1 Fatal Error",
+	[24] = "FBD Channel 0 Fatal Error",
+	[23] = "PCI Express Device 7Fatal Error",
+	[22] = "PCI Express Device 6 Fatal Error",
+	[21] = "PCI Express Device 5 Fatal Error",
+	[20] = "PCI Express Device 4 Fatal Error",
+	[19] = "PCI Express Device 3 Fatal Error",
+	[18] = "PCI Express Device 2 Fatal Error",
+	[17] = "PCI Express Device 1 Fatal Error",
+	[16] = "ESI Fatal Error",
+	[15] = "Internal MCH Non-Fatal Error",
+	[14] = "Intel QuickData Technology Device Non Fatal Error",
+	[13] = "FSB1 Non-Fatal Error",
+	[12] = "FSB 0 Non-Fatal Error",
+	[11] = "FBD Channel 3 Non-Fatal Error",
+	[10] = "FBD Channel 2 Non-Fatal Error",
+	[9]  = "FBD Channel 1 Non-Fatal Error",
+	[8]  = "FBD Channel 0 Non-Fatal Error",
+	[7]  = "PCI Express Device 7 Non-Fatal Error",
+	[6]  = "PCI Express Device 6 Non-Fatal Error",
+	[5]  = "PCI Express Device 5 Non-Fatal Error",
+	[4]  = "PCI Express Device 4 Non-Fatal Error",
+	[3]  = "PCI Express Device 3 Non-Fatal Error",
+	[2]  = "PCI Express Device 2 Non-Fatal Error",
+	[1]  = "PCI Express Device 1 Non-Fatal Error",
+	[0]  = "ESI Non-Fatal Error",
+};
+
+#define NERR_GLOBAL	0x44
+static const char *nerr_global_name[] = {
+	[31] = "Internal MCH Fatal Error",
+	[30] = "Intel QuickData Technology Device Fatal Error",
+	[29] = "FSB1 Fatal Error",
+	[28] = "FSB0 Fatal Error",
+	[27] = "FSB2 Fatal Error",
+	[26] = "FSB3 Fatal Error",
+	[25] = "Reserved",
+	[24] = "FBD Channel 0,1,2 or 3 Fatal Error",
+	[23] = "PCI Express Device 7 Fatal Error",
+	[22] = "PCI Express Device 6 Fatal Error",
+	[21] = "PCI Express Device 5 Fatal Error",
+	[20] = "PCI Express Device 4 Fatal Error",
+	[19] = "PCI Express Device 3 Fatal Error",
+	[18] = "PCI Express Device 2 Fatal Error",
+	[17] = "PCI Express Device 1 Fatal Error",
+	[16] = "ESI Fatal Error",
+	[15] = "Internal MCH Non-Fatal Error",
+	[14] = "Intel QuickData Technology Device Non Fatal Error",
+	[13] = "FSB1 Non-Fatal Error",
+	[12] = "FSB0 Non-Fatal Error",
+	[11] = "FSB2 Non-Fatal Error",
+	[10] = "FSB3 Non-Fatal Error",
+	[9] = "Reserved",
+	[8] = "FBD Channel 0,1, 2 or 3 Non-Fatal Error",
+	[7] = "PCI Express Device 7 Non-Fatal Error",
+	[6] = "PCI Express Device 6 Non-Fatal Error",
+	[5] = "PCI Express Device 5 Non-Fatal Error",
+	[4] = "PCI Express Device 4 Non-Fatal Error",
+	[3] = "PCI Express Device 3 Non-Fatal Error",
+	[2] = "PCI Express Device 2 Non-Fatal Error",
+	[1] = "PCI Express Device 1 Non-Fatal Error",
+	[0] = "ESI Non-Fatal Error",
+};
+
 #if 0
 
 /*

commit af3d8831e7e2036cd453c852d206b892b19c8820
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Aug 26 20:58:45 2010 -0300

    i7300_edac: display info if ECC is enabled or not
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
index eb3f30e96ee3..db194b6b3e42 100644
--- a/drivers/edac/i7300_edac.c
+++ b/drivers/edac/i7300_edac.c
@@ -80,17 +80,19 @@
  */
 
 	/* OFFSETS for Function 0 */
-#define		AMBASE			0x48 /* AMB Mem Mapped Reg Region Base */
-#define		MAXCH			0x56 /* Max Channel Number */
-#define		MAXDIMMPERCH		0x57 /* Max DIMM PER Channel Number */
+#define AMBASE			0x48 /* AMB Mem Mapped Reg Region Base */
+#define MAXCH			0x56 /* Max Channel Number */
+#define MAXDIMMPERCH		0x57 /* Max DIMM PER Channel Number */
 
 	/* OFFSETS for Function 1 */
-#define		TOLM			0x6C
-#define		REDMEMB			0x7C
+#define MC_SETTINGS		0x40
 
-#define		MIR0			0x80
-#define		MIR1			0x84
-#define		MIR2			0x88
+#define TOLM			0x6C
+#define REDMEMB			0x7C
+
+#define MIR0			0x80
+#define MIR1			0x84
+#define MIR2			0x88
 
 #if 0
 #define		AMIR0			0x8c
@@ -393,6 +395,7 @@ struct i7300_pvt {
 
 	u16 tolm;				/* top of low memory */
 	u64 ambase;				/* AMB BAR */
+	u32 mc_settings;
 
 	u16 mir[MAX_MIR];
 
@@ -1020,6 +1023,15 @@ static int i7300_get_mc_regs(struct mem_ctl_info *mci)
 	debugf2("Actual TOLM byte addr=%u.%03u GB (0x%x)\n",
 		actual_tolm/1000, actual_tolm % 1000, pvt->tolm << 28);
 
+	/* Get memory controller settings */
+	pci_read_config_dword(pvt->branchmap_werrors, MC_SETTINGS,
+			     &pvt->mc_settings);
+	debugf0("Memory controller operating on %s mode\n",
+		pvt->mc_settings & (1 << 16)? "mirrored" : "non-mirrored");
+	debugf0("Error detection is %s\n",
+		pvt->mc_settings & (1 << 5)? "enabled" : "disabled");
+
+	/* Get Memory Interleave Range registers */
 	pci_read_config_word(pvt->branchmap_werrors, MIR0, &pvt->mir[0]);
 	pci_read_config_word(pvt->branchmap_werrors, MIR1, &pvt->mir[1]);
 	pci_read_config_word(pvt->branchmap_werrors, MIR2, &pvt->mir[2]);

commit fcaf780b2ad352edaeb1d1c07a6da053266b1eed
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue Aug 24 23:22:57 2010 -0300

    i7300_edac: start a driver for i7300 chipset (Clarksboro)
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c
new file mode 100644
index 000000000000..eb3f30e96ee3
--- /dev/null
+++ b/drivers/edac/i7300_edac.c
@@ -0,0 +1,1373 @@
+/*
+ * Intel 7300 class Memory Controllers kernel module (Clarksboro)
+ *
+ * This file may be distributed under the terms of the
+ * GNU General Public License version 2 only.
+ *
+ * Copyright (c) 2010 by:
+ *	 Mauro Carvalho Chehab <mchehab@redhat.com>
+ *
+ * Red Hat Inc. http://www.redhat.com
+ *
+ * Intel 7300 Chipset Memory Controller Hub (MCH) - Datasheet
+ *	http://www.intel.com/Assets/PDF/datasheet/318082.pdf
+ *
+ * TODO: The chipset allow checking for PCI Express errors also. Currently,
+ *	 the driver covers only memory error errors
+ *
+ * This driver uses "csrows" EDAC attribute to represent DIMM slot#
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+#include <linux/slab.h>
+#include <linux/edac.h>
+#include <linux/mmzone.h>
+
+#include "edac_core.h"
+
+/*
+ * Alter this version for the I7300 module when modifications are made
+ */
+#define I7300_REVISION    " Ver: 1.0.0 " __DATE__
+
+#define EDAC_MOD_STR      "i7300_edac"
+
+#define i7300_printk(level, fmt, arg...) \
+	edac_printk(level, "i7300", fmt, ##arg)
+
+#define i7300_mc_printk(mci, level, fmt, arg...) \
+	edac_mc_chipset_printk(mci, level, "i7300", fmt, ##arg)
+
+/*
+ * Memory topology is organized as:
+ *	Branch 0 - 2 channels: channels 0 and 1 (FDB0 PCI dev 21.0)
+ *	Branch 1 - 2 channels: channels 2 and 3 (FDB1 PCI dev 22.0)
+ * Each channel can have to 8 DIMM sets (called as SLOTS)
+ * Slots should generally be filled in pairs
+ *	Except on Single Channel mode of operation
+ *		just slot 0/channel0 filled on this mode
+ *	On normal operation mode, the two channels on a branch should be
+		filled together for the same SLOT#
+ * When in mirrored mode, Branch 1 replicate memory at Branch 0, so, the four
+ *		channels on both branches should be filled
+ */
+
+/* Limits for i7300 */
+#define MAX_SLOTS		8
+#define MAX_BRANCHES		2
+#define MAX_CH_PER_BRANCH	2
+#define MAX_CHANNELS		(MAX_CH_PER_BRANCH * MAX_BRANCHES)
+#define MAX_MIR			3
+
+#define to_channel(ch, branch)	((((branch)) << 1) | (ch))
+
+#define to_csrow(slot, ch, branch)					\
+		(to_channel(ch, branch) | ((slot) << 2))
+
+
+/* Device 16,
+ * Function 0: System Address (not documented)
+ * Function 1: Memory Branch Map, Control, Errors Register
+ * Function 2: FSB Error Registers
+ *
+ * All 3 functions of Device 16 (0,1,2) share the SAME DID and
+ * uses PCI_DEVICE_ID_INTEL_I7300_MCH_ERR for device 16 (0,1,2),
+ * PCI_DEVICE_ID_INTEL_I7300_MCH_FB0 and PCI_DEVICE_ID_INTEL_I7300_MCH_FB1
+ * for device 21 (0,1).
+ */
+
+	/* OFFSETS for Function 0 */
+#define		AMBASE			0x48 /* AMB Mem Mapped Reg Region Base */
+#define		MAXCH			0x56 /* Max Channel Number */
+#define		MAXDIMMPERCH		0x57 /* Max DIMM PER Channel Number */
+
+	/* OFFSETS for Function 1 */
+#define		TOLM			0x6C
+#define		REDMEMB			0x7C
+
+#define		MIR0			0x80
+#define		MIR1			0x84
+#define		MIR2			0x88
+
+#if 0
+#define		AMIR0			0x8c
+#define		AMIR1			0x90
+#define		AMIR2			0x94
+
+/*TODO: double check it */
+#define			REC_ECC_LOCATOR_ODD(x)	((x) & 0x3fe00) /* bits [17:9] indicate ODD, [8:0]  indicate EVEN */
+
+	/* Fatal error registers */
+#define		FERR_FAT_FBD		0x98
+
+/*TODO: double check it */
+#define			FERR_FAT_FBDCHAN (3<<28)	/* channel index where the highest-order error occurred */
+
+#define		NERR_FAT_FBD		0x9c
+#define		FERR_NF_FBD		0xa0
+
+	/* Non-fatal error register */
+#define		NERR_NF_FBD		0xa4
+
+	/* Enable error mask */
+#define		EMASK_FBD		0xa8
+
+#define		ERR0_FBD		0xac
+#define		ERR1_FBD		0xb0
+#define		ERR2_FBD		0xb4
+#define		MCERR_FBD		0xb8
+
+#endif
+
+/* TODO: Dev 16 fn1 allows memory error injection - offsets 0x100-0x10b */
+
+	/* TODO: OFFSETS for Device 16 Function 2 */
+
+/*
+ * Device 21,
+ * Function 0: Memory Map Branch 0
+ *
+ * Device 22,
+ * Function 0: Memory Map Branch 1
+ */
+
+	/* OFFSETS for Function 0 */
+
+/*
+ * Note: Other Intel EDAC drivers use AMBPRESENT to identify if the available
+ * memory. From datasheet item 7.3.1 (FB-DIMM technology & organization), it
+ * seems that we cannot use this information directly for the same usage.
+ * Each memory slot may have up to 2 AMB interfaces, one for income and another
+ * for outcome interface to the next slot.
+ * For now, the driver just stores the AMB present registers, but rely only at
+ * the MTR info to detect memory.
+ * Datasheet is also not clear about how to map each AMBPRESENT registers to
+ * one of the 4 available channels.
+ */
+#define AMBPRESENT_0	0x64
+#define AMBPRESENT_1	0x66
+
+const static u16 mtr_regs [MAX_SLOTS] = {
+	0x80, 0x84, 0x88, 0x8c,
+	0x82, 0x86, 0x8a, 0x8e
+};
+
+/* Defines to extract the vaious fields from the
+ *	MTRx - Memory Technology Registers
+ */
+#define MTR_DIMMS_PRESENT(mtr)		((mtr) & (1 << 8))
+#define MTR_DIMMS_ETHROTTLE(mtr)	((mtr) & (1 << 7))
+#define MTR_DRAM_WIDTH(mtr)		(((mtr) & (1 << 6)) ? 8 : 4)
+#define MTR_DRAM_BANKS(mtr)		(((mtr) & (1 << 5)) ? 8 : 4)
+#define MTR_DIMM_RANKS(mtr)		(((mtr) & (1 << 4)) ? 1 : 0)
+#define MTR_DIMM_ROWS(mtr)		(((mtr) >> 2) & 0x3)
+#define MTR_DRAM_BANKS_ADDR_BITS	2
+#define MTR_DIMM_ROWS_ADDR_BITS(mtr)	(MTR_DIMM_ROWS(mtr) + 13)
+#define MTR_DIMM_COLS(mtr)		((mtr) & 0x3)
+#define MTR_DIMM_COLS_ADDR_BITS(mtr)	(MTR_DIMM_COLS(mtr) + 10)
+
+#if 0
+	/* OFFSETS for Function 1 */
+
+/* TODO */
+#define NRECFGLOG		0x74
+#define RECFGLOG		0x78
+#define NRECMEMA		0xbe
+#define NRECMEMB		0xc0
+#define NRECFB_DIMMA		0xc4
+#define NRECFB_DIMMB		0xc8
+#define NRECFB_DIMMC		0xcc
+#define NRECFB_DIMMD		0xd0
+#define NRECFB_DIMME		0xd4
+#define NRECFB_DIMMF		0xd8
+#define REDMEMA			0xdC
+#define RECMEMA			0xf0
+#define RECMEMB			0xf4
+#define RECFB_DIMMA		0xf8
+#define RECFB_DIMMB		0xec
+#define RECFB_DIMMC		0xf0
+#define RECFB_DIMMD		0xf4
+#define RECFB_DIMME		0xf8
+#define RECFB_DIMMF		0xfC
+
+/* This applies to FERR_NF_FB-DIMM as well as FERR_FAT_FB-DIMM */
+static inline int extract_fbdchan_indx(u32 x)
+{
+	return (x>>28) & 0x3;
+}
+#endif
+
+#ifdef CONFIG_EDAC_DEBUG
+/* MTR NUMROW */
+static const char *numrow_toString[] = {
+	"8,192 - 13 rows",
+	"16,384 - 14 rows",
+	"32,768 - 15 rows",
+	"65,536 - 16 rows"
+};
+
+/* MTR NUMCOL */
+static const char *numcol_toString[] = {
+	"1,024 - 10 columns",
+	"2,048 - 11 columns",
+	"4,096 - 12 columns",
+	"reserved"
+};
+#endif
+
+#if 0
+
+/*
+ * Error indicator bits and masks
+ * Error masks are according with Table 5-17 of i7300 datasheet
+ */
+
+enum error_mask {
+	EMASK_M1  = 1<<0,  /* Memory Write error on non-redundant retry */
+	EMASK_M2  = 1<<1,  /* Memory or FB-DIMM configuration CRC read error */
+	EMASK_M3  = 1<<2,  /* Reserved */
+	EMASK_M4  = 1<<3,  /* Uncorrectable Data ECC on Replay */
+	EMASK_M5  = 1<<4,  /* Aliased Uncorrectable Non-Mirrored Demand Data ECC */
+	EMASK_M6  = 1<<5,  /* Unsupported on i7300 */
+	EMASK_M7  = 1<<6,  /* Aliased Uncorrectable Resilver- or Spare-Copy Data ECC */
+	EMASK_M8  = 1<<7,  /* Aliased Uncorrectable Patrol Data ECC */
+	EMASK_M9  = 1<<8,  /* Non-Aliased Uncorrectable Non-Mirrored Demand Data ECC */
+	EMASK_M10 = 1<<9,  /* Unsupported on i7300 */
+	EMASK_M11 = 1<<10, /* Non-Aliased Uncorrectable Resilver- or Spare-Copy Data ECC  */
+	EMASK_M12 = 1<<11, /* Non-Aliased Uncorrectable Patrol Data ECC */
+	EMASK_M13 = 1<<12, /* Memory Write error on first attempt */
+	EMASK_M14 = 1<<13, /* FB-DIMM Configuration Write error on first attempt */
+	EMASK_M15 = 1<<14, /* Memory or FB-DIMM configuration CRC read error */
+	EMASK_M16 = 1<<15, /* Channel Failed-Over Occurred */
+	EMASK_M17 = 1<<16, /* Correctable Non-Mirrored Demand Data ECC */
+	EMASK_M18 = 1<<17, /* Unsupported on i7300 */
+	EMASK_M19 = 1<<18, /* Correctable Resilver- or Spare-Copy Data ECC */
+	EMASK_M20 = 1<<19, /* Correctable Patrol Data ECC */
+	EMASK_M21 = 1<<20, /* FB-DIMM Northbound parity error on FB-DIMM Sync Status */
+	EMASK_M22 = 1<<21, /* SPD protocol Error */
+	EMASK_M23 = 1<<22, /* Non-Redundant Fast Reset Timeout */
+	EMASK_M24 = 1<<23, /* Refresh error */
+	EMASK_M25 = 1<<24, /* Memory Write error on redundant retry */
+	EMASK_M26 = 1<<25, /* Redundant Fast Reset Timeout */
+	EMASK_M27 = 1<<26, /* Correctable Counter Threshold Exceeded */
+	EMASK_M28 = 1<<27, /* DIMM-Spare Copy Completed */
+	EMASK_M29 = 1<<28, /* DIMM-Isolation Completed */
+};
+
+/*
+ * Names to translate bit error into something useful
+ */
+static const char *error_name[] = {
+	[0]  = "Memory Write error on non-redundant retry",
+	[1]  = "Memory or FB-DIMM configuration CRC read error",
+	/* Reserved */
+	[3]  = "Uncorrectable Data ECC on Replay",
+	[4]  = "Aliased Uncorrectable Non-Mirrored Demand Data ECC",
+	/* M6 Unsupported on i7300 */
+	[6]  = "Aliased Uncorrectable Resilver- or Spare-Copy Data ECC",
+	[7]  = "Aliased Uncorrectable Patrol Data ECC",
+	[8]  = "Non-Aliased Uncorrectable Non-Mirrored Demand Data ECC",
+	/* M10 Unsupported on i7300 */
+	[10] = "Non-Aliased Uncorrectable Resilver- or Spare-Copy Data ECC",
+	[11] = "Non-Aliased Uncorrectable Patrol Data ECC",
+	[12] = "Memory Write error on first attempt",
+	[13] = "FB-DIMM Configuration Write error on first attempt",
+	[14] = "Memory or FB-DIMM configuration CRC read error",
+	[15] = "Channel Failed-Over Occurred",
+	[16] = "Correctable Non-Mirrored Demand Data ECC",
+	/* M18 Unsupported on i7300 */
+	[18] = "Correctable Resilver- or Spare-Copy Data ECC",
+	[19] = "Correctable Patrol Data ECC",
+	[20] = "FB-DIMM Northbound parity error on FB-DIMM Sync Status",
+	[21] = "SPD protocol Error",
+	[22] = "Non-Redundant Fast Reset Timeout",
+	[23] = "Refresh error",
+	[24] = "Memory Write error on redundant retry",
+	[25] = "Redundant Fast Reset Timeout",
+	[26] = "Correctable Counter Threshold Exceeded",
+	[27] = "DIMM-Spare Copy Completed",
+	[28] = "DIMM-Isolation Completed",
+};
+
+/* Fatal errors */
+#define ERROR_FAT_MASK		(EMASK_M1 | \
+				 EMASK_M2 | \
+				 EMASK_M23)
+
+/* Correctable errors */
+#define ERROR_NF_CORRECTABLE	(EMASK_M27 | \
+				 EMASK_M20 | \
+				 EMASK_M19 | \
+				 EMASK_M18 | \
+				 EMASK_M17 | \
+				 EMASK_M16)
+#define ERROR_NF_DIMM_SPARE	(EMASK_M29 | \
+				 EMASK_M28)
+#define ERROR_NF_SPD_PROTOCOL	(EMASK_M22)
+#define ERROR_NF_NORTH_CRC	(EMASK_M21)
+
+/* Recoverable errors */
+#define ERROR_NF_RECOVERABLE	(EMASK_M26 | \
+				 EMASK_M25 | \
+				 EMASK_M24 | \
+				 EMASK_M15 | \
+				 EMASK_M14 | \
+				 EMASK_M13 | \
+				 EMASK_M12 | \
+				 EMASK_M11 | \
+				 EMASK_M9  | \
+				 EMASK_M8  | \
+				 EMASK_M7  | \
+				 EMASK_M5)
+
+/* uncorrectable errors */
+#define ERROR_NF_UNCORRECTABLE	(EMASK_M4)
+
+/* mask to all non-fatal errors */
+#define ERROR_NF_MASK		(ERROR_NF_CORRECTABLE   | \
+				 ERROR_NF_UNCORRECTABLE | \
+				 ERROR_NF_RECOVERABLE   | \
+				 ERROR_NF_DIMM_SPARE    | \
+				 ERROR_NF_SPD_PROTOCOL  | \
+				 ERROR_NF_NORTH_CRC)
+
+/*
+ * Define error masks for the several registers
+ */
+
+/* Enable all fatal and non fatal errors */
+#define ENABLE_EMASK_ALL	(ERROR_FAT_MASK | ERROR_NF_MASK)
+
+/* mask for fatal error registers */
+#define FERR_FAT_MASK ERROR_FAT_MASK
+
+/* masks for non-fatal error register */
+static inline int to_nf_mask(unsigned int mask)
+{
+	return (mask & EMASK_M29) | (mask >> 3);
+};
+
+static inline int from_nf_ferr(unsigned int mask)
+{
+	return (mask & EMASK_M29) |		/* Bit 28 */
+	       (mask & ((1 << 28) - 1) << 3);	/* Bits 0 to 27 */
+};
+
+#define FERR_NF_MASK		to_nf_mask(ERROR_NF_MASK)
+#define FERR_NF_CORRECTABLE	to_nf_mask(ERROR_NF_CORRECTABLE)
+#define FERR_NF_DIMM_SPARE	to_nf_mask(ERROR_NF_DIMM_SPARE)
+#define FERR_NF_SPD_PROTOCOL	to_nf_mask(ERROR_NF_SPD_PROTOCOL)
+#define FERR_NF_NORTH_CRC	to_nf_mask(ERROR_NF_NORTH_CRC)
+#define FERR_NF_RECOVERABLE	to_nf_mask(ERROR_NF_RECOVERABLE)
+#define FERR_NF_UNCORRECTABLE	to_nf_mask(ERROR_NF_UNCORRECTABLE)
+
+#endif
+
+/* Device name and register DID (Device ID) */
+struct i7300_dev_info {
+	const char *ctl_name;	/* name for this device */
+	u16 fsb_mapping_errors;	/* DID for the branchmap,control */
+};
+
+/* Table of devices attributes supported by this driver */
+static const struct i7300_dev_info i7300_devs[] = {
+	{
+		.ctl_name = "I7300",
+		.fsb_mapping_errors = PCI_DEVICE_ID_INTEL_I7300_MCH_ERR,
+	},
+};
+
+struct i7300_dimm_info {
+	int megabytes;		/* size, 0 means not present  */
+};
+
+/* driver private data structure */
+struct i7300_pvt {
+	struct pci_dev *system_address;		/* 16.0 */
+	struct pci_dev *branchmap_werrors;	/* 16.1 */
+	struct pci_dev *fsb_error_regs;		/* 16.2 */
+	struct pci_dev *branch_pci[MAX_BRANCHES];	/* 21.0  and 22.0 */
+
+	u16 tolm;				/* top of low memory */
+	u64 ambase;				/* AMB BAR */
+
+	u16 mir[MAX_MIR];
+
+	u16 mtr[MAX_SLOTS][MAX_BRANCHES];		/* Memory Technlogy Reg */
+	u16 ambpresent[MAX_CHANNELS];		/* AMB present regs */
+
+	/* DIMM information matrix, allocating architecture maximums */
+	struct i7300_dimm_info dimm_info[MAX_SLOTS][MAX_CHANNELS];
+};
+
+#if 0
+/* I7300 MCH error information retrieved from Hardware */
+struct i7300_error_info {
+	/* These registers are always read from the MC */
+	u32 ferr_fat_fbd;	/* First Errors Fatal */
+	u32 nerr_fat_fbd;	/* Next Errors Fatal */
+	u32 ferr_nf_fbd;	/* First Errors Non-Fatal */
+	u32 nerr_nf_fbd;	/* Next Errors Non-Fatal */
+
+	/* These registers are input ONLY if there was a Recoverable Error */
+	u32 redmemb;		/* Recoverable Mem Data Error log B */
+	u16 recmema;		/* Recoverable Mem Error log A */
+	u32 recmemb;		/* Recoverable Mem Error log B */
+
+	/* These registers are input ONLY if there was a Non-Rec Error */
+	u16 nrecmema;		/* Non-Recoverable Mem log A */
+	u16 nrecmemb;		/* Non-Recoverable Mem log B */
+
+};
+#endif
+
+/* FIXME: Why do we need to have this static? */
+static struct edac_pci_ctl_info *i7300_pci;
+
+
+#if 0
+/* note that nrec_rdwr changed from NRECMEMA to NRECMEMB between the 5000 and
+   5400 better to use an inline function than a macro in this case */
+static inline int nrec_bank(struct i7300_error_info *info)
+{
+	return ((info->nrecmema) >> 12) & 0x7;
+}
+static inline int nrec_rank(struct i7300_error_info *info)
+{
+	return ((info->nrecmema) >> 8) & 0xf;
+}
+static inline int nrec_buf_id(struct i7300_error_info *info)
+{
+	return ((info->nrecmema)) & 0xff;
+}
+static inline int nrec_rdwr(struct i7300_error_info *info)
+{
+	return (info->nrecmemb) >> 31;
+}
+/* This applies to both NREC and REC string so it can be used with nrec_rdwr
+   and rec_rdwr */
+static inline const char *rdwr_str(int rdwr)
+{
+	return rdwr ? "Write" : "Read";
+}
+static inline int nrec_cas(struct i7300_error_info *info)
+{
+	return ((info->nrecmemb) >> 16) & 0x1fff;
+}
+static inline int nrec_ras(struct i7300_error_info *info)
+{
+	return (info->nrecmemb) & 0xffff;
+}
+static inline int rec_bank(struct i7300_error_info *info)
+{
+	return ((info->recmema) >> 12) & 0x7;
+}
+static inline int rec_rank(struct i7300_error_info *info)
+{
+	return ((info->recmema) >> 8) & 0xf;
+}
+static inline int rec_rdwr(struct i7300_error_info *info)
+{
+	return (info->recmemb) >> 31;
+}
+static inline int rec_cas(struct i7300_error_info *info)
+{
+	return ((info->recmemb) >> 16) & 0x1fff;
+}
+static inline int rec_ras(struct i7300_error_info *info)
+{
+	return (info->recmemb) & 0xffff;
+}
+
+/*
+ *	i7300_get_error_info	Retrieve the hardware error information from
+ *				the hardware and cache it in the 'info'
+ *				structure
+ */
+static void i7300_get_error_info(struct mem_ctl_info *mci,
+				 struct i7300_error_info *info)
+{
+	struct i7300_pvt *pvt;
+	u32 value;
+
+	pvt = mci->pvt_info;
+
+	/* read in the 1st FATAL error register */
+	pci_read_config_dword(pvt->branchmap_werrors, FERR_FAT_FBD, &value);
+
+	/* Mask only the bits that the doc says are valid
+	 */
+	value &= (FERR_FAT_FBDCHAN | FERR_FAT_MASK);
+
+	/* If there is an error, then read in the
+	   NEXT FATAL error register and the Memory Error Log Register A
+	 */
+	if (value & FERR_FAT_MASK) {
+		info->ferr_fat_fbd = value;
+
+		/* harvest the various error data we need */
+		pci_read_config_dword(pvt->branchmap_werrors,
+				NERR_FAT_FBD, &info->nerr_fat_fbd);
+		pci_read_config_word(pvt->branchmap_werrors,
+				NRECMEMA, &info->nrecmema);
+		pci_read_config_word(pvt->branchmap_werrors,
+				NRECMEMB, &info->nrecmemb);
+
+		/* Clear the error bits, by writing them back */
+		pci_write_config_dword(pvt->branchmap_werrors,
+				FERR_FAT_FBD, value);
+	} else {
+		info->ferr_fat_fbd = 0;
+		info->nerr_fat_fbd = 0;
+		info->nrecmema = 0;
+		info->nrecmemb = 0;
+	}
+
+	/* read in the 1st NON-FATAL error register */
+	pci_read_config_dword(pvt->branchmap_werrors, FERR_NF_FBD, &value);
+
+	/* If there is an error, then read in the 1st NON-FATAL error
+	 * register as well */
+	if (value & FERR_NF_MASK) {
+		info->ferr_nf_fbd = value;
+
+		/* harvest the various error data we need */
+		pci_read_config_dword(pvt->branchmap_werrors,
+				NERR_NF_FBD, &info->nerr_nf_fbd);
+		pci_read_config_word(pvt->branchmap_werrors,
+				RECMEMA, &info->recmema);
+		pci_read_config_dword(pvt->branchmap_werrors,
+				RECMEMB, &info->recmemb);
+		pci_read_config_dword(pvt->branchmap_werrors,
+				REDMEMB, &info->redmemb);
+
+		/* Clear the error bits, by writing them back */
+		pci_write_config_dword(pvt->branchmap_werrors,
+				FERR_NF_FBD, value);
+	} else {
+		info->ferr_nf_fbd = 0;
+		info->nerr_nf_fbd = 0;
+		info->recmema = 0;
+		info->recmemb = 0;
+		info->redmemb = 0;
+	}
+}
+
+/*
+ * i7300_proccess_non_recoverable_info(struct mem_ctl_info *mci,
+ * 					struct i7300_error_info *info,
+ * 					int handle_errors);
+ *
+ *	handle the Intel FATAL and unrecoverable errors, if any
+ */
+static void i7300_proccess_non_recoverable_info(struct mem_ctl_info *mci,
+				    struct i7300_error_info *info,
+				    unsigned long allErrors)
+{
+	char msg[EDAC_MC_LABEL_LEN + 1 + 90 + 80];
+	int branch;
+	int channel;
+	int bank;
+	int buf_id;
+	int rank;
+	int rdwr;
+	int ras, cas;
+	int errnum;
+	char *type = NULL;
+
+	if (!allErrors)
+		return;		/* if no error, return now */
+
+	if (allErrors &  ERROR_FAT_MASK)
+		type = "FATAL";
+	else if (allErrors & FERR_NF_UNCORRECTABLE)
+		type = "NON-FATAL uncorrected";
+	else
+		type = "NON-FATAL recoverable";
+
+	/* ONLY ONE of the possible error bits will be set, as per the docs */
+
+	branch = extract_fbdchan_indx(info->ferr_fat_fbd);
+	channel = branch;
+
+	/* Use the NON-Recoverable macros to extract data */
+	bank = nrec_bank(info);
+	rank = nrec_rank(info);
+	buf_id = nrec_buf_id(info);
+	rdwr = nrec_rdwr(info);
+	ras = nrec_ras(info);
+	cas = nrec_cas(info);
+
+	debugf0("\t\tCSROW= %d  Channels= %d,%d  (Branch= %d "
+		"DRAM Bank= %d Buffer ID = %d rdwr= %s ras= %d cas= %d)\n",
+		rank, channel, channel + 1, branch >> 1, bank,
+		buf_id, rdwr_str(rdwr), ras, cas);
+
+	/* Only 1 bit will be on */
+	errnum = find_first_bit(&allErrors, ARRAY_SIZE(error_name));
+
+	/* Form out message */
+	snprintf(msg, sizeof(msg),
+		 "%s (Branch=%d DRAM-Bank=%d Buffer ID = %d RDWR=%s "
+		 "RAS=%d CAS=%d %s Err=0x%lx (%s))",
+		 type, branch >> 1, bank, buf_id, rdwr_str(rdwr), ras, cas,
+		 type, allErrors, error_name[errnum]);
+
+	/* Call the helper to output message */
+	edac_mc_handle_fbd_ue(mci, rank, channel, channel + 1, msg);
+}
+
+/*
+ * i7300_process_fatal_error_info(struct mem_ctl_info *mci,
+ * 				struct i7300_error_info *info,
+ * 				int handle_errors);
+ *
+ *	handle the Intel NON-FATAL errors, if any
+ */
+static void i7300_process_nonfatal_error_info(struct mem_ctl_info *mci,
+					struct i7300_error_info *info)
+{
+	char msg[EDAC_MC_LABEL_LEN + 1 + 90 + 80];
+	unsigned long allErrors;
+	int branch;
+	int channel;
+	int bank;
+	int rank;
+	int rdwr;
+	int ras, cas;
+	int errnum;
+
+	/* mask off the Error bits that are possible */
+	allErrors = from_nf_ferr(info->ferr_nf_fbd & FERR_NF_MASK);
+	if (!allErrors)
+		return;		/* if no error, return now */
+
+	/* ONLY ONE of the possible error bits will be set, as per the docs */
+
+	if (allErrors & (ERROR_NF_UNCORRECTABLE | ERROR_NF_RECOVERABLE)) {
+		i7300_proccess_non_recoverable_info(mci, info, allErrors);
+		return;
+	}
+
+	/* Correctable errors */
+	if (allErrors & ERROR_NF_CORRECTABLE) {
+		debugf0("\tCorrected bits= 0x%lx\n", allErrors);
+
+		branch = extract_fbdchan_indx(info->ferr_nf_fbd);
+
+		channel = 0;
+		if (REC_ECC_LOCATOR_ODD(info->redmemb))
+			channel = 1;
+
+		/* Convert channel to be based from zero, instead of
+		 * from branch base of 0 */
+		channel += branch;
+
+		bank = rec_bank(info);
+		rank = rec_rank(info);
+		rdwr = rec_rdwr(info);
+		ras = rec_ras(info);
+		cas = rec_cas(info);
+
+		/* Only 1 bit will be on */
+		errnum = find_first_bit(&allErrors, ARRAY_SIZE(error_name));
+
+		debugf0("\t\tCSROW= %d Channel= %d  (Branch %d "
+			"DRAM Bank= %d rdwr= %s ras= %d cas= %d)\n",
+			rank, channel, branch >> 1, bank,
+			rdwr_str(rdwr), ras, cas);
+
+		/* Form out message */
+		snprintf(msg, sizeof(msg),
+			 "Corrected error (Branch=%d DRAM-Bank=%d RDWR=%s "
+			 "RAS=%d CAS=%d, CE Err=0x%lx (%s))",
+			 branch >> 1, bank, rdwr_str(rdwr), ras, cas,
+			 allErrors, error_name[errnum]);
+
+		/* Call the helper to output message */
+		edac_mc_handle_fbd_ce(mci, rank, channel, msg);
+
+		return;
+	}
+
+	/* Miscelaneous errors */
+	errnum = find_first_bit(&allErrors, ARRAY_SIZE(error_name));
+
+	branch = extract_fbdchan_indx(info->ferr_nf_fbd);
+
+	i7300_mc_printk(mci, KERN_EMERG,
+			"Non-Fatal misc error (Branch=%d Err=%#lx (%s))",
+			branch >> 1, allErrors, error_name[errnum]);
+}
+
+/*
+ *	i7300_process_error_info	Process the error info that is
+ *	in the 'info' structure, previously retrieved from hardware
+ */
+static void i7300_process_error_info(struct mem_ctl_info *mci,
+				struct i7300_error_info *info)
+{	u32 allErrors;
+
+	/* First handle any fatal errors that occurred */
+	allErrors = (info->ferr_fat_fbd & FERR_FAT_MASK);
+	i7300_proccess_non_recoverable_info(mci, info, allErrors);
+
+	/* now handle any non-fatal errors that occurred */
+	i7300_process_nonfatal_error_info(mci, info);
+}
+
+/*
+ *	i7300_clear_error	Retrieve any error from the hardware
+ *				but do NOT process that error.
+ *				Used for 'clearing' out of previous errors
+ *				Called by the Core module.
+ */
+static void i7300_clear_error(struct mem_ctl_info *mci)
+{
+	struct i7300_error_info info;
+
+	i7300_get_error_info(mci, &info);
+}
+
+/*
+ *	i7300_check_error	Retrieve and process errors reported by the
+ *				hardware. Called by the Core module.
+ */
+static void i7300_check_error(struct mem_ctl_info *mci)
+{
+	struct i7300_error_info info;
+	debugf4("MC%d: " __FILE__ ": %s()\n", mci->mc_idx, __func__);
+	i7300_get_error_info(mci, &info);
+	i7300_process_error_info(mci, &info);
+}
+
+/*
+ *	i7300_enable_error_reporting
+ *			Turn on the memory reporting features of the hardware
+ */
+static void i7300_enable_error_reporting(struct mem_ctl_info *mci)
+{
+	struct i7300_pvt *pvt;
+	u32 fbd_error_mask;
+
+	pvt = mci->pvt_info;
+
+	/* Read the FBD Error Mask Register */
+	pci_read_config_dword(pvt->branchmap_werrors, EMASK_FBD,
+			&fbd_error_mask);
+
+	/* Enable with a '0' */
+	fbd_error_mask &= ~(ENABLE_EMASK_ALL);
+
+	pci_write_config_dword(pvt->branchmap_werrors, EMASK_FBD,
+			fbd_error_mask);
+}
+#endif
+
+/*
+ * determine_mtr(pvt, csrow, channel)
+ *
+ * return the proper MTR register as determine by the csrow and desired channel
+ */
+static int decode_mtr(struct i7300_pvt *pvt,
+		      int slot, int ch, int branch,
+		      struct i7300_dimm_info *dinfo,
+		      struct csrow_info *p_csrow)
+{
+	int mtr, ans, addrBits, channel;
+
+	channel = to_channel(ch, branch);
+
+	mtr = pvt->mtr[slot][branch];
+	ans = MTR_DIMMS_PRESENT(mtr) ? 1 : 0;
+
+	debugf2("\tMTR%d CH%d: DIMMs are %s (mtr)\n",
+		slot, channel,
+		ans ? "Present" : "NOT Present");
+
+	/* Determine if there is a DIMM present in this DIMM slot */
+
+#if 0
+	if (!amb_present || !ans)
+		return 0;
+#else
+	if (!ans)
+		return 0;
+#endif
+
+	/* Start with the number of bits for a Bank
+	* on the DRAM */
+	addrBits = MTR_DRAM_BANKS_ADDR_BITS;
+	/* Add thenumber of ROW bits */
+	addrBits += MTR_DIMM_ROWS_ADDR_BITS(mtr);
+	/* add the number of COLUMN bits */
+	addrBits += MTR_DIMM_COLS_ADDR_BITS(mtr);
+	/* add the number of RANK bits */
+	addrBits += MTR_DIMM_RANKS(mtr);
+
+	addrBits += 6;	/* add 64 bits per DIMM */
+	addrBits -= 20;	/* divide by 2^^20 */
+	addrBits -= 3;	/* 8 bits per bytes */
+
+	dinfo->megabytes = 1 << addrBits;
+
+	debugf2("\t\tWIDTH: x%d\n", MTR_DRAM_WIDTH(mtr));
+
+	debugf2("\t\tELECTRICAL THROTTLING is %s\n",
+		MTR_DIMMS_ETHROTTLE(mtr) ? "enabled" : "disabled");
+
+	debugf2("\t\tNUMBANK: %d bank(s)\n", MTR_DRAM_BANKS(mtr));
+	debugf2("\t\tNUMRANK: %s\n", MTR_DIMM_RANKS(mtr) ? "double" : "single");
+	debugf2("\t\tNUMROW: %s\n", numrow_toString[MTR_DIMM_ROWS(mtr)]);
+	debugf2("\t\tNUMCOL: %s\n", numcol_toString[MTR_DIMM_COLS(mtr)]);
+	debugf2("\t\tSIZE: %d MB\n", dinfo->megabytes);
+
+	p_csrow->grain = 8;
+	p_csrow->nr_pages = dinfo->megabytes << 8;
+	p_csrow->mtype = MEM_FB_DDR2;
+	p_csrow->edac_mode = EDAC_S8ECD8ED;
+
+	/* ask what device type on this row */
+	if (MTR_DRAM_WIDTH(mtr))
+		p_csrow->dtype = DEV_X8;
+	else
+		p_csrow->dtype = DEV_X4;
+
+	return mtr;
+}
+
+/*
+ *	print_dimm_size
+ *
+ *	also will output a DIMM matrix map, if debug is enabled, for viewing
+ *	how the DIMMs are populated
+ */
+static void print_dimm_size(struct i7300_pvt *pvt)
+{
+	struct i7300_dimm_info *dinfo;
+	char *p, *mem_buffer;
+	int space, n;
+	int channel, slot;
+
+	space = PAGE_SIZE;
+	mem_buffer = p = kmalloc(space, GFP_KERNEL);
+	if (p == NULL) {
+		i7300_printk(KERN_ERR, "MC: %s:%s() kmalloc() failed\n",
+			__FILE__, __func__);
+		return;
+	}
+
+	n = snprintf(p, space, "              ");
+	p += n;
+	space -= n;
+	for (channel = 0; channel < MAX_CHANNELS; channel++) {
+		n = snprintf(p, space, "channel %d | ", channel);
+		p += n;
+		space -= n;
+	}
+	debugf2("%s\n", mem_buffer);
+	p = mem_buffer;
+	space = PAGE_SIZE;
+	n = snprintf(p, space, "-------------------------------"
+		               "------------------------------");
+	p += n;
+	space -= n;
+	debugf2("%s\n", mem_buffer);
+	p = mem_buffer;
+	space = PAGE_SIZE;
+
+	for (slot = 0; slot < MAX_SLOTS; slot++) {
+		n = snprintf(p, space, "csrow/SLOT %d  ", slot);
+		p += n;
+		space -= n;
+
+		for (channel = 0; channel < MAX_CHANNELS; channel++) {
+			dinfo = &pvt->dimm_info[slot][channel];
+			n = snprintf(p, space, "%4d MB   | ", dinfo->megabytes);
+			p += n;
+			space -= n;
+		}
+
+		debugf2("%s\n", mem_buffer);
+		p = mem_buffer;
+		space = PAGE_SIZE;
+	}
+
+	n = snprintf(p, space, "-------------------------------"
+		               "------------------------------");
+	p += n;
+	space -= n;
+	debugf2("%s\n", mem_buffer);
+	p = mem_buffer;
+	space = PAGE_SIZE;
+
+	kfree(mem_buffer);
+}
+
+/*
+ *	i7300_init_csrows	Initialize the 'csrows' table within
+ *				the mci control	structure with the
+ *				addressing of memory.
+ *
+ *	return:
+ *		0	success
+ *		1	no actual memory found on this MC
+ */
+static int i7300_init_csrows(struct mem_ctl_info *mci)
+{
+	struct i7300_pvt *pvt;
+	struct i7300_dimm_info *dinfo;
+	struct csrow_info *p_csrow;
+	int empty;
+	int mtr;
+	int ch, branch, slot, channel;
+
+	pvt = mci->pvt_info;
+
+	empty = 1;		/* Assume NO memory */
+
+	debugf2("Memory Technology Registers:\n");
+
+	/* Get the AMB present registers for the four channels */
+	for (branch = 0; branch < MAX_BRANCHES; branch++) {
+		/* Read and dump branch 0's MTRs */
+		channel = to_channel(0, branch);
+		pci_read_config_word(pvt->branch_pci[branch], AMBPRESENT_0,
+				&pvt->ambpresent[channel]);
+		debugf2("\t\tAMB-present CH%d = 0x%x:\n",
+			channel, pvt->ambpresent[channel]);
+
+		channel = to_channel(1, branch);
+		pci_read_config_word(pvt->branch_pci[branch], AMBPRESENT_1,
+				&pvt->ambpresent[channel]);
+		debugf2("\t\tAMB-present CH%d = 0x%x:\n",
+			channel, pvt->ambpresent[channel]);
+	}
+
+	/* Get the set of MTR[0-7] regs by each branch */
+	for (slot = 0; slot < MAX_SLOTS; slot++) {
+		int where = mtr_regs[slot];
+		for (branch = 0; branch < MAX_BRANCHES; branch++) {
+			pci_read_config_word(pvt->branch_pci[branch],
+					where,
+					&pvt->mtr[slot][branch]);
+			for (ch = 0; ch < MAX_BRANCHES; ch++) {
+				int channel = to_channel(ch, branch);
+
+				dinfo = &pvt->dimm_info[slot][channel];
+				p_csrow = &mci->csrows[slot];
+
+				mtr = decode_mtr(pvt, slot, ch, branch,
+							dinfo, p_csrow);
+				/* if no DIMMS on this row, continue */
+				if (!MTR_DIMMS_PRESENT(mtr))
+					continue;
+
+				p_csrow->csrow_idx = slot;
+
+				/* FAKE OUT VALUES, FIXME */
+				p_csrow->first_page = 0 + slot * 20;
+				p_csrow->last_page = 9 + slot * 20;
+				p_csrow->page_mask = 0xfff;
+
+				empty = 0;
+			}
+		}
+	}
+
+	return empty;
+}
+
+static void decode_mir(int mir_no, u16 mir[MAX_MIR])
+{
+	if (mir[mir_no] & 3)
+		debugf2("MIR%d: limit= 0x%x Branch(es) that participate: %s %s\n",
+			mir_no,
+			(mir[mir_no] >> 4) & 0xfff,
+			(mir[mir_no] & 1) ? "B0" : "",
+			(mir[mir_no] & 2) ? "B1": "");
+}
+
+/*
+ *	i7300_get_mc_regs	read in the necessary registers and
+ *				cache locally
+ *
+ *			Fills in the private data members
+ */
+static int i7300_get_mc_regs(struct mem_ctl_info *mci)
+{
+	struct i7300_pvt *pvt;
+	u32 actual_tolm;
+	int i, rc;
+
+	pvt = mci->pvt_info;
+
+	pci_read_config_dword(pvt->system_address, AMBASE,
+			(u32 *) &pvt->ambase);
+
+	debugf2("AMBASE= 0x%lx\n", (long unsigned int)pvt->ambase);
+
+	/* Get the Branch Map regs */
+	pci_read_config_word(pvt->branchmap_werrors, TOLM, &pvt->tolm);
+	pvt->tolm >>= 12;
+	debugf2("TOLM (number of 256M regions) =%u (0x%x)\n", pvt->tolm,
+		pvt->tolm);
+
+	actual_tolm = (u32) ((1000l * pvt->tolm) >> (30 - 28));
+	debugf2("Actual TOLM byte addr=%u.%03u GB (0x%x)\n",
+		actual_tolm/1000, actual_tolm % 1000, pvt->tolm << 28);
+
+	pci_read_config_word(pvt->branchmap_werrors, MIR0, &pvt->mir[0]);
+	pci_read_config_word(pvt->branchmap_werrors, MIR1, &pvt->mir[1]);
+	pci_read_config_word(pvt->branchmap_werrors, MIR2, &pvt->mir[2]);
+
+	/* Decode the MIR regs */
+	for (i = 0; i < MAX_MIR; i++)
+		decode_mir(i, pvt->mir);
+
+	rc = i7300_init_csrows(mci);
+	if (rc < 0)
+		return rc;
+
+	/* Go and determine the size of each DIMM and place in an
+	 * orderly matrix */
+	print_dimm_size(pvt);
+
+	return 0;
+}
+
+/*
+ *	i7300_put_devices	'put' all the devices that we have
+ *				reserved via 'get'
+ */
+static void i7300_put_devices(struct mem_ctl_info *mci)
+{
+	struct i7300_pvt *pvt;
+	int branch;
+
+	pvt = mci->pvt_info;
+
+	/* Decrement usage count for devices */
+	for (branch = 0; branch < MAX_CH_PER_BRANCH; branch++)
+		pci_dev_put(pvt->branch_pci[branch]);
+	pci_dev_put(pvt->fsb_error_regs);
+	pci_dev_put(pvt->branchmap_werrors);
+}
+
+/*
+ *	i7300_get_devices	Find and perform 'get' operation on the MCH's
+ *			device/functions we want to reference for this driver
+ *
+ *			Need to 'get' device 16 func 1 and func 2
+ */
+static int i7300_get_devices(struct mem_ctl_info *mci, int dev_idx)
+{
+	struct i7300_pvt *pvt;
+	struct pci_dev *pdev;
+
+	pvt = mci->pvt_info;
+
+	/* Attempt to 'get' the MCH register we want */
+	pdev = NULL;
+	while (!pvt->branchmap_werrors || !pvt->fsb_error_regs) {
+		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
+				      PCI_DEVICE_ID_INTEL_I7300_MCH_ERR, pdev);
+		if (!pdev) {
+			/* End of list, leave */
+			i7300_printk(KERN_ERR,
+				"'system address,Process Bus' "
+				"device not found:"
+				"vendor 0x%x device 0x%x ERR funcs "
+				"(broken BIOS?)\n",
+				PCI_VENDOR_ID_INTEL,
+				PCI_DEVICE_ID_INTEL_I7300_MCH_ERR);
+			goto error;
+		}
+
+		/* Store device 16 funcs 1 and 2 */
+		switch (PCI_FUNC(pdev->devfn)) {
+		case 1:
+			pvt->branchmap_werrors = pdev;
+			break;
+		case 2:
+			pvt->fsb_error_regs = pdev;
+			break;
+		}
+	}
+
+	debugf1("System Address, processor bus- PCI Bus ID: %s  %x:%x\n",
+		pci_name(pvt->system_address),
+		pvt->system_address->vendor, pvt->system_address->device);
+	debugf1("Branchmap, control and errors - PCI Bus ID: %s  %x:%x\n",
+		pci_name(pvt->branchmap_werrors),
+		pvt->branchmap_werrors->vendor, pvt->branchmap_werrors->device);
+	debugf1("FSB Error Regs - PCI Bus ID: %s  %x:%x\n",
+		pci_name(pvt->fsb_error_regs),
+		pvt->fsb_error_regs->vendor, pvt->fsb_error_regs->device);
+
+	pvt->branch_pci[0] = pci_get_device(PCI_VENDOR_ID_INTEL,
+				            PCI_DEVICE_ID_INTEL_I7300_MCH_FB0,
+					    NULL);
+	if (!pvt->branch_pci[0]) {
+		i7300_printk(KERN_ERR,
+			"MC: 'BRANCH 0' device not found:"
+			"vendor 0x%x device 0x%x Func 0 (broken BIOS?)\n",
+			PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I7300_MCH_FB0);
+		goto error;
+	}
+
+	pvt->branch_pci[1] = pci_get_device(PCI_VENDOR_ID_INTEL,
+					    PCI_DEVICE_ID_INTEL_I7300_MCH_FB1,
+					    NULL);
+	if (!pvt->branch_pci[1]) {
+		i7300_printk(KERN_ERR,
+			"MC: 'BRANCH 1' device not found:"
+			"vendor 0x%x device 0x%x Func 0 "
+			"(broken BIOS?)\n",
+			PCI_VENDOR_ID_INTEL,
+			PCI_DEVICE_ID_INTEL_I7300_MCH_FB1);
+		goto error;
+	}
+
+	return 0;
+
+error:
+	i7300_put_devices(mci);
+	return -ENODEV;
+}
+
+/*
+ *	i7300_probe1	Probe for ONE instance of device to see if it is
+ *			present.
+ *	return:
+ *		0 for FOUND a device
+ *		< 0 for error code
+ */
+static int i7300_probe1(struct pci_dev *pdev, int dev_idx)
+{
+	struct mem_ctl_info *mci;
+	struct i7300_pvt *pvt;
+	int num_channels;
+	int num_dimms_per_channel;
+	int num_csrows;
+
+	if (dev_idx >= ARRAY_SIZE(i7300_devs))
+		return -EINVAL;
+
+	debugf0("MC: " __FILE__ ": %s(), pdev bus %u dev=0x%x fn=0x%x\n",
+		__func__,
+		pdev->bus->number,
+		PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
+
+	/* We only are looking for func 0 of the set */
+	if (PCI_FUNC(pdev->devfn) != 0)
+		return -ENODEV;
+
+	/* As we don't have a motherboard identification routine to determine
+	 * actual number of slots/dimms per channel, we thus utilize the
+	 * resource as specified by the chipset. Thus, we might have
+	 * have more DIMMs per channel than actually on the mobo, but this
+	 * allows the driver to support upto the chipset max, without
+	 * some fancy mobo determination.
+	 */
+	num_dimms_per_channel = MAX_SLOTS;
+	num_channels = MAX_CHANNELS;
+	num_csrows = MAX_SLOTS * MAX_CHANNELS;
+
+	debugf0("MC: %s(): Number of - Channels= %d  DIMMS= %d  CSROWS= %d\n",
+		__func__, num_channels, num_dimms_per_channel, num_csrows);
+
+	/* allocate a new MC control structure */
+	mci = edac_mc_alloc(sizeof(*pvt), num_csrows, num_channels, 0);
+
+	if (mci == NULL)
+		return -ENOMEM;
+
+	debugf0("MC: " __FILE__ ": %s(): mci = %p\n", __func__, mci);
+
+	mci->dev = &pdev->dev;	/* record ptr  to the generic device */
+
+	pvt = mci->pvt_info;
+	pvt->system_address = pdev;	/* Record this device in our private */
+
+	/* 'get' the pci devices we want to reserve for our use */
+	if (i7300_get_devices(mci, dev_idx))
+		goto fail0;
+
+	mci->mc_idx = 0;
+	mci->mtype_cap = MEM_FLAG_FB_DDR2;
+	mci->edac_ctl_cap = EDAC_FLAG_NONE;
+	mci->edac_cap = EDAC_FLAG_NONE;
+	mci->mod_name = "i7300_edac.c";
+	mci->mod_ver = I7300_REVISION;
+	mci->ctl_name = i7300_devs[dev_idx].ctl_name;
+	mci->dev_name = pci_name(pdev);
+	mci->ctl_page_to_phys = NULL;
+
+#if 0
+	/* Set the function pointer to an actual operation function */
+	mci->edac_check = i7300_check_error;
+#endif
+
+	/* initialize the MC control structure 'csrows' table
+	 * with the mapping and control information */
+	if (i7300_get_mc_regs(mci)) {
+		debugf0("MC: Setting mci->edac_cap to EDAC_FLAG_NONE\n"
+			"    because i7300_init_csrows() returned nonzero "
+			"value\n");
+		mci->edac_cap = EDAC_FLAG_NONE;	/* no csrows found */
+	} else {
+#if 0
+		debugf1("MC: Enable error reporting now\n");
+		i7300_enable_error_reporting(mci);
+#endif
+	}
+
+	/* add this new MC control structure to EDAC's list of MCs */
+	if (edac_mc_add_mc(mci)) {
+		debugf0("MC: " __FILE__
+			": %s(): failed edac_mc_add_mc()\n", __func__);
+		/* FIXME: perhaps some code should go here that disables error
+		 * reporting if we just enabled it
+		 */
+		goto fail1;
+	}
+
+#if 0
+	i7300_clear_error(mci);
+#endif
+
+	/* allocating generic PCI control info */
+	i7300_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);
+	if (!i7300_pci) {
+		printk(KERN_WARNING
+			"%s(): Unable to create PCI control\n",
+			__func__);
+		printk(KERN_WARNING
+			"%s(): PCI error report via EDAC not setup\n",
+			__func__);
+	}
+
+	return 0;
+
+	/* Error exit unwinding stack */
+fail1:
+
+	i7300_put_devices(mci);
+
+fail0:
+	edac_mc_free(mci);
+	return -ENODEV;
+}
+
+/*
+ *	i7300_init_one	constructor for one instance of device
+ *
+ * 	returns:
+ *		negative on error
+ *		count (>= 0)
+ */
+static int __devinit i7300_init_one(struct pci_dev *pdev,
+				const struct pci_device_id *id)
+{
+	int rc;
+
+	debugf0("MC: " __FILE__ ": %s()\n", __func__);
+
+	/* wake up device */
+	rc = pci_enable_device(pdev);
+	if (rc == -EIO)
+		return rc;
+
+	/* now probe and enable the device */
+	return i7300_probe1(pdev, id->driver_data);
+}
+
+/*
+ *	i7300_remove_one	destructor for one instance of device
+ *
+ */
+static void __devexit i7300_remove_one(struct pci_dev *pdev)
+{
+	struct mem_ctl_info *mci;
+
+	debugf0(__FILE__ ": %s()\n", __func__);
+
+	if (i7300_pci)
+		edac_pci_release_generic_ctl(i7300_pci);
+
+	mci = edac_mc_del_mc(&pdev->dev);
+	if (!mci)
+		return;
+
+	/* retrieve references to resources, and free those resources */
+	i7300_put_devices(mci);
+
+	edac_mc_free(mci);
+}
+
+/*
+ *	pci_device_id	table for which devices we are looking for
+ *
+ *	The "E500P" device is the first device supported.
+ */
+static const struct pci_device_id i7300_pci_tbl[] __devinitdata = {
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I7300_MCH_ERR)},
+	{0,}			/* 0 terminated list. */
+};
+
+MODULE_DEVICE_TABLE(pci, i7300_pci_tbl);
+
+/*
+ *	i7300_driver	pci_driver structure for this module
+ *
+ */
+static struct pci_driver i7300_driver = {
+	.name = "i7300_edac",
+	.probe = i7300_init_one,
+	.remove = __devexit_p(i7300_remove_one),
+	.id_table = i7300_pci_tbl,
+};
+
+/*
+ *	i7300_init		Module entry function
+ *			Try to initialize this module for its devices
+ */
+static int __init i7300_init(void)
+{
+	int pci_rc;
+
+	debugf2("MC: " __FILE__ ": %s()\n", __func__);
+
+	/* Ensure that the OPSTATE is set correctly for POLL or NMI */
+	opstate_init();
+
+	pci_rc = pci_register_driver(&i7300_driver);
+
+	return (pci_rc < 0) ? pci_rc : 0;
+}
+
+/*
+ *	i7300_exit()	Module exit function
+ *			Unregister the driver
+ */
+static void __exit i7300_exit(void)
+{
+	debugf2("MC: " __FILE__ ": %s()\n", __func__);
+	pci_unregister_driver(&i7300_driver);
+}
+
+module_init(i7300_init);
+module_exit(i7300_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Mauro Carvalho Chehab <mchehab@redhat.com>");
+MODULE_AUTHOR("Red Hat Inc. (http://www.redhat.com)");
+MODULE_DESCRIPTION("MC Driver for Intel I7300 memory controllers - "
+		   I7300_REVISION);
+
+module_param(edac_op_state, int, 0444);
+MODULE_PARM_DESC(edac_op_state, "EDAC Error Reporting state: 0=Poll,1=NMI");
