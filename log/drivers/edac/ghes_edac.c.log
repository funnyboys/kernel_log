commit 67792cf9583c7816667c6b90007b5840f1b471f4
Author: Robert Richter <rrichter@marvell.com>
Date:   Thu Jan 23 09:03:02 2020 +0000

    EDAC/mc: Remove enable_per_layer_report function argument
    
    Many functions carry the enable_per_layer_report argument. This is a
    bool value indicating the error information contains some location
    data where the error occurred. This can easily being determined by
    checking the pos[] array for values. Negative values indicate there is
    no location available. So if the top layer is negative, the error
    location is unknown.
    
    Just check if the top layer is negative and remove
    enable_per_layer_report as function argument and also from struct
    edac_raw_error_desc.
    
     [ bp: Reflow comments to 80 columns, while at it. ]
    
    Signed-off-by: Robert Richter <rrichter@marvell.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Aristeu Rozanski <aris@redhat.com>
    Link: https://lkml.kernel.org/r/20200123090210.26933-8-rrichter@marvell.com

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index bef8a428c429..cb3dab56a875 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -355,11 +355,8 @@ void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
 				     mem_err->mem_dev_handle);
 
 		index = get_dimm_smbios_index(mci, mem_err->mem_dev_handle);
-		if (index >= 0) {
+		if (index >= 0)
 			e->top_layer = index;
-			e->enable_per_layer_report = true;
-		}
-
 	}
 	if (p > e->location)
 		*(p - 1) = '\0';

commit 91b327f6728b0c4dfa089f11a474789854baa0b1
Author: Robert Richter <rrichter@marvell.com>
Date:   Thu Jan 23 09:02:56 2020 +0000

    EDAC/mc: Determine mci pointer from the error descriptor
    
    Each struct mci has its own error descriptor. Create a function
    error_desc_to_mci() to determine the corresponding mci from an
    error descriptor. This removes @mci from the parameter list of
    edac_raw_mc_handle_error() as the mci pointer does not need to be passed
    any longer.
    
     [ bp: Massage commit message. ]
    
    Signed-off-by: Robert Richter <rrichter@marvell.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Acked-by: Aristeu Rozanski <aris@redhat.com>
    Link: https://lkml.kernel.org/r/20200123090210.26933-5-rrichter@marvell.com

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 7c3e5264a41e..bef8a428c429 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -441,7 +441,7 @@ void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
 	if (p > pvt->other_detail)
 		*(p - 1) = '\0';
 
-	edac_raw_mc_handle_error(mci, e);
+	edac_raw_mc_handle_error(e);
 
 unlock:
 	spin_unlock_irqrestore(&ghes_lock, flags);

commit 672ef0e5684048a00aeb923b10131275ea688543
Author: Robert Richter <rrichter@marvell.com>
Date:   Thu Jan 23 09:02:54 2020 +0000

    EDAC: Store error type in struct edac_raw_error_desc
    
    Store the error type in struct edac_raw_error_desc. This makes the
    type parameter of edac_raw_mc_handle_error() obsolete.
    
    [ kernel-doc typo ]
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Robert Richter <rrichter@marvell.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Mauro Carvalho Chehab <mchehab@kernel.org>
    Acked-by: Aristeu Rozanski <aris@redhat.com>
    Link: https://lkml.kernel.org/r/20200123090210.26933-4-rrichter@marvell.com

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index b99080d8a10c..7c3e5264a41e 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -201,7 +201,6 @@ static void ghes_edac_dmidecode(const struct dmi_header *dh, void *arg)
 
 void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
 {
-	enum hw_event_mc_err_type type;
 	struct edac_raw_error_desc *e;
 	struct mem_ctl_info *mci;
 	struct ghes_edac_pvt *pvt;
@@ -240,17 +239,17 @@ void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
 
 	switch (sev) {
 	case GHES_SEV_CORRECTED:
-		type = HW_EVENT_ERR_CORRECTED;
+		e->type = HW_EVENT_ERR_CORRECTED;
 		break;
 	case GHES_SEV_RECOVERABLE:
-		type = HW_EVENT_ERR_UNCORRECTED;
+		e->type = HW_EVENT_ERR_UNCORRECTED;
 		break;
 	case GHES_SEV_PANIC:
-		type = HW_EVENT_ERR_FATAL;
+		e->type = HW_EVENT_ERR_FATAL;
 		break;
 	default:
 	case GHES_SEV_NO:
-		type = HW_EVENT_ERR_INFO;
+		e->type = HW_EVENT_ERR_INFO;
 	}
 
 	edac_dbg(1, "error validation_bits: 0x%08llx\n",
@@ -442,7 +441,7 @@ void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
 	if (p > pvt->other_detail)
 		*(p - 1) = '\0';
 
-	edac_raw_mc_handle_error(type, mci, e);
+	edac_raw_mc_handle_error(mci, e);
 
 unlock:
 	spin_unlock_irqrestore(&ghes_lock, flags);

commit 16214bd9e43a31683a7073664b000029bba00354
Author: Robert Richter <rrichter@marvell.com>
Date:   Thu Nov 21 21:36:57 2019 +0000

    EDAC/ghes: Do not warn when incrementing refcount on 0
    
    The following warning from the refcount framework is seen during ghes
    initialization:
    
      EDAC MC0: Giving out device to module ghes_edac.c controller ghes_edac: DEV ghes (INTERRUPT)
      ------------[ cut here ]------------
      refcount_t: increment on 0; use-after-free.
      WARNING: CPU: 36 PID: 1 at lib/refcount.c:156 refcount_inc_checked
     [...]
      Call trace:
       refcount_inc_checked
       ghes_edac_register
       ghes_probe
       ...
    
    It warns if the refcount is incremented from zero. This warning is
    reasonable as a kernel object is typically created with a refcount of
    one and freed once the refcount is zero. Afterwards the object would be
    "used-after-free".
    
    For GHES, the refcount is initialized with zero, and that is why this
    message is seen when initializing the first instance. However, whenever
    the refcount is zero, the device will be allocated and registered. Since
    the ghes_reg_mutex protects the refcount and serializes allocation and
    freeing of ghes devices, a use-after-free cannot happen here.
    
    Instead of using refcount_inc() for the first instance, use
    refcount_set(). This can be used here because the refcount is zero at
    this point and can not change due to its protection by the mutex.
    
    Fixes: 23f61b9fc5cc ("EDAC/ghes: Fix locking and memory barrier issues")
    Reported-by: John Garry <john.garry@huawei.com>
    Signed-off-by: Robert Richter <rrichter@marvell.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Tested-by: John Garry <john.garry@huawei.com>
    Cc: <huangming23@huawei.com>
    Cc: James Morse <james.morse@arm.com>
    Cc: <linuxarm@huawei.com>
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: <tanxiaofei@huawei.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: <wanghuiqiang@huawei.com>
    Link: https://lkml.kernel.org/r/20191121213628.21244-1-rrichter@marvell.com

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 47f4e7f90ef0..b99080d8a10c 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -556,8 +556,8 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 	ghes_pvt = pvt;
 	spin_unlock_irqrestore(&ghes_lock, flags);
 
-	/* only increment on success */
-	refcount_inc(&ghes_refcount);
+	/* only set on success */
+	refcount_set(&ghes_refcount, 1);
 
 unlock:
 	mutex_unlock(&ghes_reg_mutex);

commit 787d899914aae1c8cdb467931cfd7c369ef8d37b
Author: Robert Richter <rrichter@marvell.com>
Date:   Wed Nov 6 09:33:27 2019 +0000

    EDAC: Unify the mc_event tracepoint call
    
    The code in ghes_edac.c and edac_mc.c for grain_bits calculation and
    calling trace_mc_event() is now the same. Move it to a single location
    in edac_raw_mc_handle_error().
    
    The only difference is the missing IS_ENABLED(CONFIG_RAS) switch, but
    this is needed for ghes too.
    
    Signed-off-by: Robert Richter <rrichter@marvell.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Cc: "linux-edac@vger.kernel.org" <linux-edac@vger.kernel.org>
    Cc: James Morse <james.morse@arm.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Link: https://lkml.kernel.org/r/20191106093239.25517-13-rrichter@marvell.com

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 1fd782c73a35..47f4e7f90ef0 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -207,7 +207,6 @@ void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
 	struct ghes_edac_pvt *pvt;
 	unsigned long flags;
 	char *p;
-	u8 grain_bits;
 
 	/*
 	 * We can do the locking below because GHES defers error processing
@@ -443,18 +442,6 @@ void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
 	if (p > pvt->other_detail)
 		*(p - 1) = '\0';
 
-	/* Sanity-check driver-supplied grain value. */
-	if (WARN_ON_ONCE(!e->grain))
-		e->grain = 1;
-
-	grain_bits = fls_long(e->grain - 1);
-
-	/* Generate the trace event */
-	trace_mc_event(type, e->msg, e->label, e->error_count,
-		       mci->mc_idx, e->top_layer, e->mid_layer, e->low_layer,
-		       (e->page_frame_number << PAGE_SHIFT) | e->offset_in_page,
-		       grain_bits, e->syndrome, e->other_detail);
-
 	edac_raw_mc_handle_error(type, mci, e);
 
 unlock:

commit 501eb40d2b85ae70a617a3b46dbb519fb9c76532
Author: Robert Richter <rrichter@marvell.com>
Date:   Wed Nov 6 09:33:25 2019 +0000

    EDAC/ghes: Remove intermediate buffer pvt->detail_location
    
    detail_location[] is used to collect two location strings so they can
    be passed as one to trace_mc_event(). Instead of having an extra copy
    step, assemble the location string in other_detail[] from the
    beginning.
    
    Using other_detail[] to call trace_mc_event() is now the same as in
    edac_mc.c and code can be unified.
    
    Signed-off-by: Robert Richter <rrichter@marvell.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: James Morse <james.morse@arm.com>
    Reviewed-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Cc: "linux-edac@vger.kernel.org" <linux-edac@vger.kernel.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Link: https://lkml.kernel.org/r/20191106093239.25517-12-rrichter@marvell.com

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index e24fbbac5556..1fd782c73a35 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -21,8 +21,7 @@ struct ghes_edac_pvt {
 	struct mem_ctl_info *mci;
 
 	/* Buffers for the error handling routine */
-	char detail_location[240];
-	char other_detail[160];
+	char other_detail[400];
 	char msg[80];
 };
 
@@ -369,6 +368,8 @@ void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
 
 	/* All other fields are mapped on e->other_detail */
 	p = pvt->other_detail;
+	p += snprintf(p, sizeof(pvt->other_detail),
+		"APEI location: %s ", e->location);
 	if (mem_err->validation_bits & CPER_MEM_VALID_ERROR_STATUS) {
 		u64 status = mem_err->error_status;
 
@@ -449,12 +450,10 @@ void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
 	grain_bits = fls_long(e->grain - 1);
 
 	/* Generate the trace event */
-	snprintf(pvt->detail_location, sizeof(pvt->detail_location),
-		 "APEI location: %s %s", e->location, e->other_detail);
 	trace_mc_event(type, e->msg, e->label, e->error_count,
 		       mci->mc_idx, e->top_layer, e->mid_layer, e->low_layer,
 		       (e->page_frame_number << PAGE_SHIFT) | e->offset_in_page,
-		       grain_bits, e->syndrome, pvt->detail_location);
+		       grain_bits, e->syndrome, e->other_detail);
 
 	edac_raw_mc_handle_error(type, mci, e);
 

commit 7088e29e0423d3195e09079b4f849ec4837e5a75
Author: Robert Richter <rrichter@marvell.com>
Date:   Wed Nov 6 09:33:23 2019 +0000

    EDAC/ghes: Fix grain calculation
    
    The current code to convert a physical address mask to a grain
    (defined as granularity in bytes) is:
    
            e->grain = ~(mem_err->physical_addr_mask & ~PAGE_MASK);
    
    This is broken in several ways:
    
    1) It calculates to wrong grain values. E.g., a physical address mask
    of ~0xfff should give a grain of 0x1000. Without considering
    PAGE_MASK, there is an off-by-one. Things are worse when also
    filtering it with ~PAGE_MASK. This will calculate to a grain with the
    upper bits set. In the example it even calculates to ~0.
    
    2) The grain does not depend on and is unrelated to the kernel's
    page-size. The page-size only matters when unmapping memory in
    memory_failure(). Smaller grains are wrongly rounded up to the
    page-size, on architectures with a configurable page-size (e.g. arm64)
    this could round up to the even bigger page-size of the hypervisor.
    
    Fix this with:
    
            e->grain = ~mem_err->physical_addr_mask + 1;
    
    The grain_bits are defined as:
    
            grain = 1 << grain_bits;
    
    Change also the grain_bits calculation accordingly, it is the same
    formula as in edac_mc.c now and the code can be unified.
    
    The value in ->physical_addr_mask coming from firmware is assumed to
    be contiguous, but this is not sanity-checked. However, in case the
    mask is non-contiguous, a conversion to grain_bits effectively
    converts the grain bit mask to a power of 2 by rounding it up.
    
    Suggested-by: James Morse <james.morse@arm.com>
    Signed-off-by: Robert Richter <rrichter@marvell.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Cc: "linux-edac@vger.kernel.org" <linux-edac@vger.kernel.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Link: https://lkml.kernel.org/r/20191106093239.25517-11-rrichter@marvell.com

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 5dc53d3512ae..e24fbbac5556 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -230,6 +230,7 @@ void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
 	/* Cleans the error report buffer */
 	memset(e, 0, sizeof (*e));
 	e->error_count = 1;
+	e->grain = 1;
 	strcpy(e->label, "unknown label");
 	e->msg = pvt->msg;
 	e->other_detail = pvt->other_detail;
@@ -325,7 +326,7 @@ void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
 
 	/* Error grain */
 	if (mem_err->validation_bits & CPER_MEM_VALID_PA_MASK)
-		e->grain = ~(mem_err->physical_addr_mask & ~PAGE_MASK);
+		e->grain = ~mem_err->physical_addr_mask + 1;
 
 	/* Memory error location, mapped on e->location */
 	p = e->location;
@@ -441,8 +442,13 @@ void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
 	if (p > pvt->other_detail)
 		*(p - 1) = '\0';
 
+	/* Sanity-check driver-supplied grain value. */
+	if (WARN_ON_ONCE(!e->grain))
+		e->grain = 1;
+
+	grain_bits = fls_long(e->grain - 1);
+
 	/* Generate the trace event */
-	grain_bits = fls_long(e->grain);
 	snprintf(pvt->detail_location, sizeof(pvt->detail_location),
 		 "APEI location: %s %s", e->location, e->other_detail);
 	trace_mc_event(type, e->msg, e->label, e->error_count,

commit 7c1049317042a37638788bb8a892dbd75b742655
Author: Robert Richter <rrichter@marvell.com>
Date:   Wed Nov 6 09:33:20 2019 +0000

    EDAC/ghes: Use standard kernel macros for page calculations
    
    Use standard macros for page calculations.
    
    Signed-off-by: Robert Richter <rrichter@marvell.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: James Morse <james.morse@arm.com>
    Reviewed-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Cc: "linux-edac@vger.kernel.org" <linux-edac@vger.kernel.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Link: https://lkml.kernel.org/r/20191106093239.25517-10-rrichter@marvell.com

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index fbc8b1de3ddd..5dc53d3512ae 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -319,8 +319,8 @@ void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
 
 	/* Error address */
 	if (mem_err->validation_bits & CPER_MEM_VALID_PA) {
-		e->page_frame_number = mem_err->physical_addr >> PAGE_SHIFT;
-		e->offset_in_page = mem_err->physical_addr & ~PAGE_MASK;
+		e->page_frame_number = PHYS_PFN(mem_err->physical_addr);
+		e->offset_in_page = offset_in_page(mem_err->physical_addr);
 	}
 
 	/* Error grain */

commit c498afaf7df87f44e7cb383c135baec52b5259be
Author: Robert Richter <rrichter@marvell.com>
Date:   Wed Nov 6 09:33:07 2019 +0000

    EDAC: Introduce an mci_for_each_dimm() iterator
    
    Introduce an mci_for_each_dimm() iterator. It returns a pointer to
    a struct dimm_info. This makes the declaration and use of an index
    obsolete and avoids access to internal data of struct mci (direct array
    access etc).
    
     [ bp: push the struct dimm_info *dimm; declaration into the
       CONFIG_EDAC_DEBUG block. ]
    
    Signed-off-by: Robert Richter <rrichter@marvell.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Cc: "linux-edac@vger.kernel.org" <linux-edac@vger.kernel.org>
    Cc: James Morse <james.morse@arm.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Link: https://lkml.kernel.org/r/20191106093239.25517-4-rrichter@marvell.com

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 2275d6bf6bc5..fbc8b1de3ddd 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -90,12 +90,13 @@ static void ghes_edac_count_dimms(const struct dmi_header *dh, void *arg)
 
 static int get_dimm_smbios_index(struct mem_ctl_info *mci, u16 handle)
 {
-	int i;
+	struct dimm_info *dimm;
 
-	for (i = 0; i < mci->tot_dimms; i++) {
-		if (mci->dimms[i]->smbios_handle == handle)
-			return i;
+	mci_for_each_dimm(mci, dimm) {
+		if (dimm->smbios_handle == handle)
+			return dimm->idx;
 	}
+
 	return -1;
 }
 

commit bc9ad9e40dbc4c8874e806345df393a9cfeadad3
Author: Robert Richter <rrichter@marvell.com>
Date:   Wed Nov 6 09:33:02 2019 +0000

    EDAC: Replace EDAC_DIMM_PTR() macro with edac_get_dimm() function
    
    The EDAC_DIMM_PTR() macro takes 3 arguments from struct mem_ctl_info.
    Clean up this interface to only pass the mci struct and replace this
    macro with a new function edac_get_dimm().
    
    Also introduce an edac_get_dimm_by_index() function for later use.
    This allows it to get a DIMM pointer only by a given index. This can
    be useful if the DIMM's position within the layers of the memory
    controller or the exact size of the layers are unknown.
    
    Small style changes made for some hunks after applying the semantic
    patch.
    
    Semantic patch used:
    
    @@ expression mci, a, b,c; @@
    
    -EDAC_DIMM_PTR(mci->layers, mci->dimms, mci->n_layers, a, b, c)
    +edac_get_dimm(mci, a, b, c)
    
     [ bp: Touchups. ]
    
    Signed-off-by: Robert Richter <rrichter@marvell.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: "linux-edac@vger.kernel.org" <linux-edac@vger.kernel.org>
    Cc: James Morse <james.morse@arm.com>
    Cc: Jason Baron <jbaron@akamai.com>
    Cc: Qiuxu Zhuo <qiuxu.zhuo@intel.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Link: https://lkml.kernel.org/r/20191106093239.25517-2-rrichter@marvell.com

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index f6f6a688c009..2275d6bf6bc5 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -106,9 +106,7 @@ static void ghes_edac_dmidecode(const struct dmi_header *dh, void *arg)
 
 	if (dh->type == DMI_ENTRY_MEM_DEVICE) {
 		struct memdev_dmi_entry *entry = (struct memdev_dmi_entry *)dh;
-		struct dimm_info *dimm = EDAC_DIMM_PTR(mci->layers, mci->dimms,
-						       mci->n_layers,
-						       dimm_fill->count, 0, 0);
+		struct dimm_info *dimm = edac_get_dimm(mci, dimm_fill->count, 0, 0);
 		u16 rdr_mask = BIT(7) | BIT(13);
 
 		if (entry->size == 0xffff) {
@@ -544,8 +542,7 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 		dimm_fill.mci = mci;
 		dmi_walk(ghes_edac_dmidecode, &dimm_fill);
 	} else {
-		struct dimm_info *dimm = EDAC_DIMM_PTR(mci->layers, mci->dimms,
-						       mci->n_layers, 0, 0, 0);
+		struct dimm_info *dimm = edac_get_dimm(mci, 0, 0, 0);
 
 		dimm->nr_pages = 1;
 		dimm->grain = 128;

commit 23f61b9fc5cc10d87f66e50518707eec2a0fbda1
Author: Robert Richter <rrichter@marvell.com>
Date:   Tue Nov 5 20:07:51 2019 +0000

    EDAC/ghes: Fix locking and memory barrier issues
    
    The ghes registration and refcount is broken in several ways:
    
     * ghes_edac_register() returns with success for a 2nd instance
       even if a first instance's registration is still running. This is
       not correct as the first instance may fail later. A subsequent
       registration may not finish before the first. Parallel registrations
       must be avoided.
    
     * The refcount was increased even if a registration failed. This
       leads to stale counters preventing the device from being released.
    
     * The ghes refcount may not be decremented properly on unregistration.
       Always decrement the refcount once ghes_edac_unregister() is called to
       keep the refcount sane.
    
     * The ghes_pvt pointer is handed to the irq handler before registration
       finished.
    
     * The mci structure could be freed while the irq handler is running.
    
    Fix this by adding a mutex to ghes_edac_register(). This mutex
    serializes instances to register and unregister. The refcount is only
    increased if the registration succeeded. This makes sure the refcount is
    in a consistent state after registering or unregistering a device.
    
    Note: A spinlock cannot be used here as the code section may sleep.
    
    The ghes_pvt is protected by ghes_lock now. This ensures the pointer is
    not updated before registration was finished or while the irq handler is
    running. It is unset before unregistering the device including necessary
    (implicit) memory barriers making the changes visible to other CPUs.
    Thus, the device can not be used anymore by an interrupt.
    
    Also, rename ghes_init to ghes_refcount for better readability and
    switch to refcount API.
    
    A refcount is needed because there can be multiple GHES structures being
    defined (see ACPI 6.3 specification, 18.3.2.7 Generic Hardware Error
    Source, "Some platforms may describe multiple Generic Hardware Error
    Source structures with different notification types, ...").
    
    Another approach to use the mci's device refcount (get_device()) and
    have a release function does not work here. A release function will be
    called only for device_release() with the last put_device() call. The
    device must be deleted *before* that with device_del(). This is only
    possible by maintaining an own refcount.
    
     [ bp: touchups. ]
    
    Fixes: 0fe5f281f749 ("EDAC, ghes: Model a single, logical memory controller")
    Fixes: 1e72e673b9d1 ("EDAC/ghes: Fix Use after free in ghes_edac remove path")
    Co-developed-by: James Morse <james.morse@arm.com>
    Signed-off-by: James Morse <james.morse@arm.com>
    Co-developed-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Robert Richter <rrichter@marvell.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: "linux-edac@vger.kernel.org" <linux-edac@vger.kernel.org>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Link: https://lkml.kernel.org/r/20191105200732.3053-1-rrichter@marvell.com

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 0bb62857ffb2..f6f6a688c009 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -26,9 +26,18 @@ struct ghes_edac_pvt {
 	char msg[80];
 };
 
-static atomic_t ghes_init = ATOMIC_INIT(0);
+static refcount_t ghes_refcount = REFCOUNT_INIT(0);
+
+/*
+ * Access to ghes_pvt must be protected by ghes_lock. The spinlock
+ * also provides the necessary (implicit) memory barrier for the SMP
+ * case to make the pointer visible on another CPU.
+ */
 static struct ghes_edac_pvt *ghes_pvt;
 
+/* GHES registration mutex */
+static DEFINE_MUTEX(ghes_reg_mutex);
+
 /*
  * Sync with other, potentially concurrent callers of
  * ghes_edac_report_mem_error(). We don't know what the
@@ -79,9 +88,8 @@ static void ghes_edac_count_dimms(const struct dmi_header *dh, void *arg)
 		(*num_dimm)++;
 }
 
-static int get_dimm_smbios_index(u16 handle)
+static int get_dimm_smbios_index(struct mem_ctl_info *mci, u16 handle)
 {
-	struct mem_ctl_info *mci = ghes_pvt->mci;
 	int i;
 
 	for (i = 0; i < mci->tot_dimms; i++) {
@@ -198,14 +206,11 @@ void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
 	enum hw_event_mc_err_type type;
 	struct edac_raw_error_desc *e;
 	struct mem_ctl_info *mci;
-	struct ghes_edac_pvt *pvt = ghes_pvt;
+	struct ghes_edac_pvt *pvt;
 	unsigned long flags;
 	char *p;
 	u8 grain_bits;
 
-	if (!pvt)
-		return;
-
 	/*
 	 * We can do the locking below because GHES defers error processing
 	 * from NMI to IRQ context. Whenever that changes, we'd at least
@@ -216,6 +221,10 @@ void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
 
 	spin_lock_irqsave(&ghes_lock, flags);
 
+	pvt = ghes_pvt;
+	if (!pvt)
+		goto unlock;
+
 	mci = pvt->mci;
 	e = &mci->error_desc;
 
@@ -348,7 +357,7 @@ void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
 			p += sprintf(p, "DIMM DMI handle: 0x%.4x ",
 				     mem_err->mem_dev_handle);
 
-		index = get_dimm_smbios_index(mem_err->mem_dev_handle);
+		index = get_dimm_smbios_index(mci, mem_err->mem_dev_handle);
 		if (index >= 0) {
 			e->top_layer = index;
 			e->enable_per_layer_report = true;
@@ -443,6 +452,8 @@ void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
 		       grain_bits, e->syndrome, pvt->detail_location);
 
 	edac_raw_mc_handle_error(type, mci, e);
+
+unlock:
 	spin_unlock_irqrestore(&ghes_lock, flags);
 }
 
@@ -457,10 +468,12 @@ static struct acpi_platform_list plat_list[] = {
 int ghes_edac_register(struct ghes *ghes, struct device *dev)
 {
 	bool fake = false;
-	int rc, num_dimm = 0;
+	int rc = 0, num_dimm = 0;
 	struct mem_ctl_info *mci;
+	struct ghes_edac_pvt *pvt;
 	struct edac_mc_layer layers[1];
 	struct ghes_edac_dimm_fill dimm_fill;
+	unsigned long flags;
 	int idx = -1;
 
 	if (IS_ENABLED(CONFIG_X86)) {
@@ -472,11 +485,14 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 		idx = 0;
 	}
 
+	/* finish another registration/unregistration instance first */
+	mutex_lock(&ghes_reg_mutex);
+
 	/*
 	 * We have only one logical memory controller to which all DIMMs belong.
 	 */
-	if (atomic_inc_return(&ghes_init) > 1)
-		return 0;
+	if (refcount_inc_not_zero(&ghes_refcount))
+		goto unlock;
 
 	/* Get the number of DIMMs */
 	dmi_walk(ghes_edac_count_dimms, &num_dimm);
@@ -494,12 +510,13 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 	mci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(struct ghes_edac_pvt));
 	if (!mci) {
 		pr_info("Can't allocate memory for EDAC data\n");
-		return -ENOMEM;
+		rc = -ENOMEM;
+		goto unlock;
 	}
 
-	ghes_pvt	= mci->pvt_info;
-	ghes_pvt->ghes	= ghes;
-	ghes_pvt->mci	= mci;
+	pvt		= mci->pvt_info;
+	pvt->ghes	= ghes;
+	pvt->mci	= mci;
 
 	mci->pdev = dev;
 	mci->mtype_cap = MEM_FLAG_EMPTY;
@@ -541,23 +558,48 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 	if (rc < 0) {
 		pr_info("Can't register at EDAC core\n");
 		edac_mc_free(mci);
-		return -ENODEV;
+		rc = -ENODEV;
+		goto unlock;
 	}
-	return 0;
+
+	spin_lock_irqsave(&ghes_lock, flags);
+	ghes_pvt = pvt;
+	spin_unlock_irqrestore(&ghes_lock, flags);
+
+	/* only increment on success */
+	refcount_inc(&ghes_refcount);
+
+unlock:
+	mutex_unlock(&ghes_reg_mutex);
+
+	return rc;
 }
 
 void ghes_edac_unregister(struct ghes *ghes)
 {
 	struct mem_ctl_info *mci;
+	unsigned long flags;
 
-	if (!ghes_pvt)
-		return;
+	mutex_lock(&ghes_reg_mutex);
 
-	if (atomic_dec_return(&ghes_init))
-		return;
+	if (!refcount_dec_and_test(&ghes_refcount))
+		goto unlock;
 
-	mci = ghes_pvt->mci;
+	/*
+	 * Wait for the irq handler being finished.
+	 */
+	spin_lock_irqsave(&ghes_lock, flags);
+	mci = ghes_pvt ? ghes_pvt->mci : NULL;
 	ghes_pvt = NULL;
-	edac_mc_del_mc(mci->pdev);
-	edac_mc_free(mci);
+	spin_unlock_irqrestore(&ghes_lock, flags);
+
+	if (!mci)
+		goto unlock;
+
+	mci = edac_mc_del_mc(mci->pdev);
+	if (mci)
+		edac_mc_free(mci);
+
+unlock:
+	mutex_unlock(&ghes_reg_mutex);
 }

commit 1e72e673b9d102ff2e8333e74b3308d012ddf75b
Author: James Morse <james.morse@arm.com>
Date:   Mon Oct 14 18:19:18 2019 +0100

    EDAC/ghes: Fix Use after free in ghes_edac remove path
    
    ghes_edac models a single logical memory controller, and uses a global
    ghes_init variable to ensure only the first ghes_edac_register() will
    do anything.
    
    ghes_edac is registered the first time a GHES entry in the HEST is
    probed. There may be multiple entries, so subsequent attempts to
    register ghes_edac are silently ignored as the work has already been
    done.
    
    When a GHES entry is unregistered, it calls ghes_edac_unregister(),
    which free()s the memory behind the global variables in ghes_edac.
    
    But there may be multiple GHES entries, the next call to
    ghes_edac_unregister() will dereference the free()d memory, and attempt
    to free it a second time.
    
    This may also be triggered on a platform with one GHES entry, if the
    driver is unbound/re-bound and unbound. The re-bind step will do
    nothing because of ghes_init, the second unbind will then do the same
    work as the first.
    
    Doing the unregister work on the first call is unsafe, as another
    CPU may be processing a notification in ghes_edac_report_mem_error(),
    using the memory we are about to free.
    
    ghes_init is already half of the reference counting. We only need
    to do the register work for the first call, and the unregister work
    for the last. Add the unregister check.
    
    This means we no longer free ghes_edac's memory while there are
    GHES entries that may receive a notification.
    
    This was detected by KASAN and DEBUG_TEST_DRIVER_REMOVE.
    
     [ bp: merge into a single patch. ]
    
    Fixes: 0fe5f281f749 ("EDAC, ghes: Model a single, logical memory controller")
    Reported-by: John Garry <john.garry@huawei.com>
    Signed-off-by: James Morse <james.morse@arm.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: Robert Richter <rrichter@marvell.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: <stable@vger.kernel.org>
    Link: https://lkml.kernel.org/r/20191014171919.85044-2-james.morse@arm.com
    Link: https://lkml.kernel.org/r/304df85b-8b56-b77e-1a11-aa23769f2e7c@huawei.com

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index d413a0bdc9ad..0bb62857ffb2 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -553,7 +553,11 @@ void ghes_edac_unregister(struct ghes *ghes)
 	if (!ghes_pvt)
 		return;
 
+	if (atomic_dec_return(&ghes_init))
+		return;
+
 	mci = ghes_pvt->mci;
+	ghes_pvt = NULL;
 	edac_mc_del_mc(mci->pdev);
 	edac_mc_free(mci);
 }

commit d55c79ac86f78fce3c224bda2b383edf96bb6438
Author: Robert Richter <rrichter@marvell.com>
Date:   Mon Sep 2 12:33:41 2019 +0000

    EDAC: Prefer 'unsigned int' to bare use of 'unsigned'
    
    Use of 'unsigned int' instead of bare use of 'unsigned'. Fix this for
    edac_mc*, ghes and the i5100 driver as reported by checkpatch.pl.
    
    While at it, struct member dev_ch_attribute->channel is always used as
    unsigned int. Change type to unsigned int to avoid type casts.
    
     [ bp: Massage. ]
    
    Signed-off-by: Robert Richter <rrichter@marvell.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: "linux-edac@vger.kernel.org" <linux-edac@vger.kernel.org>
    Cc: James Morse <james.morse@arm.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Link: https://lkml.kernel.org/r/20190902123216.9809-2-rrichter@marvell.com

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 7f19f1c672c3..d413a0bdc9ad 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -68,7 +68,7 @@ struct memdev_dmi_entry {
 
 struct ghes_edac_dimm_fill {
 	struct mem_ctl_info *mci;
-	unsigned count;
+	unsigned int count;
 };
 
 static void ghes_edac_count_dimms(const struct dmi_header *dh, void *arg)

commit 122375508ba37bdb0a99bf9c78f54500368aad2a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:19 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 172
    
    Based on 1 normalized pattern(s):
    
      this file may be distributed under the terms of the gnu general
      public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 9 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.395589349@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 49396bf6ad88..7f19f1c672c3 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -1,9 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * GHES/EDAC Linux driver
  *
- * This file may be distributed under the terms of the GNU General Public
- * License version 2.
- *
  * Copyright (c) 2013 by Mauro Carvalho Chehab
  *
  * Red Hat Inc. http://www.redhat.com

commit c798c88f3962ddff89c7aa818986caeecd46ab4c
Author: Fan Wu <wufan@codeaurora.org>
Date:   Wed Sep 19 01:59:00 2018 +0000

    EDAC, ghes: Use CPER module handles to locate DIMMs
    
    Use SMBIOS module handle type 17, on platforms which provide valid
    ones, to locate the corresponding DIMM and thus have per-DIMM error
    counter updates.
    
    Signed-off-by: Fan Wu <wufan@codeaurora.org>
    [ Massage commit message. ]
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Tyler Baicar <baicar.tyler@gmail.com>
    Reviewed-by: James Morse <james.morse@arm.com>
    Tested-by: Toshi Kani <toshi.kani@hpe.com>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: baicar.tyler@gmail.com
    Cc: john.garry@huawei.com
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Cc: shiju.jose@huawei.com
    Cc: tanxiaofei@huawei.com
    Cc: wanghuiqiang@huawei.com
    Link: http://lkml.kernel.org/r/1537322340-1860-1-git-send-email-wufan@codeaurora.org

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 473aeec4b1da..49396bf6ad88 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -81,6 +81,18 @@ static void ghes_edac_count_dimms(const struct dmi_header *dh, void *arg)
 		(*num_dimm)++;
 }
 
+static int get_dimm_smbios_index(u16 handle)
+{
+	struct mem_ctl_info *mci = ghes_pvt->mci;
+	int i;
+
+	for (i = 0; i < mci->tot_dimms; i++) {
+		if (mci->dimms[i]->smbios_handle == handle)
+			return i;
+	}
+	return -1;
+}
+
 static void ghes_edac_dmidecode(const struct dmi_header *dh, void *arg)
 {
 	struct ghes_edac_dimm_fill *dimm_fill = arg;
@@ -177,6 +189,8 @@ static void ghes_edac_dmidecode(const struct dmi_header *dh, void *arg)
 				entry->total_width, entry->data_width);
 		}
 
+		dimm->smbios_handle = entry->handle;
+
 		dimm_fill->count++;
 	}
 }
@@ -327,12 +341,21 @@ void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
 		p += sprintf(p, "bit_pos:%d ", mem_err->bit_pos);
 	if (mem_err->validation_bits & CPER_MEM_VALID_MODULE_HANDLE) {
 		const char *bank = NULL, *device = NULL;
+		int index = -1;
+
 		dmi_memdev_name(mem_err->mem_dev_handle, &bank, &device);
 		if (bank != NULL && device != NULL)
 			p += sprintf(p, "DIMM location:%s %s ", bank, device);
 		else
 			p += sprintf(p, "DIMM DMI handle: 0x%.4x ",
 				     mem_err->mem_dev_handle);
+
+		index = get_dimm_smbios_index(mem_err->mem_dev_handle);
+		if (index >= 0) {
+			e->top_layer = index;
+			e->enable_per_layer_report = true;
+		}
+
 	}
 	if (p > e->location)
 		*(p - 1) = '\0';

commit eaa3a1d46cfdbf1af50311e7a22f5d38c0418b56
Author: Borislav Petkov <bp@suse.de>
Date:   Fri May 18 13:13:31 2018 +0200

    EDAC, ghes: Make platform-based whitelisting x86-only
    
    ARM machines all have DMI tables so if they request hw error reporting
    through GHES, then the driver should be able to detect DIMMs and report
    errors successfully (famous last words :)).
    
    Make the platform-based list x86-specific so that ghes_edac can load on
    ARM.
    
    Reported-by: Qiang Zheng <zhengqiang10@huawei.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: James Morse <james.morse@arm.com>
    Tested-by: James Morse <james.morse@arm.com>
    Tested-by: Qiang Zheng <zhengqiang10@huawei.com>
    Link: https://lkml.kernel.org/r/1526039543-180996-1-git-send-email-zhengqiang10@huawei.com

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 863fbf3db29f..473aeec4b1da 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -440,12 +440,16 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 	struct mem_ctl_info *mci;
 	struct edac_mc_layer layers[1];
 	struct ghes_edac_dimm_fill dimm_fill;
-	int idx;
+	int idx = -1;
 
-	/* Check if safe to enable on this system */
-	idx = acpi_match_platform_list(plat_list);
-	if (!force_load && idx < 0)
-		return -ENODEV;
+	if (IS_ENABLED(CONFIG_X86)) {
+		/* Check if safe to enable on this system */
+		idx = acpi_match_platform_list(plat_list);
+		if (!force_load && idx < 0)
+			return -ENODEV;
+	} else {
+		idx = 0;
+	}
 
 	/*
 	 * We have only one logical memory controller to which all DIMMs belong.

commit a0671c39ddf4ebe464dc49da7e48860ff4135920
Author: Borislav Petkov <bp@suse.de>
Date:   Sat May 12 14:32:43 2018 +0200

    EDAC, ghes: Use BIT() macro
    
    ... for improved readability. Also, add a local mask variable for the
    same reason.
    
    No functional changes.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Toshi Kani <toshi.kani@hpe.com>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index cb8f2704ffb0..863fbf3db29f 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -91,6 +91,7 @@ static void ghes_edac_dmidecode(const struct dmi_header *dh, void *arg)
 		struct dimm_info *dimm = EDAC_DIMM_PTR(mci->layers, mci->dimms,
 						       mci->n_layers,
 						       dimm_fill->count, 0, 0);
+		u16 rdr_mask = BIT(7) | BIT(13);
 
 		if (entry->size == 0xffff) {
 			pr_info("Can't get DIMM%i size\n",
@@ -99,22 +100,21 @@ static void ghes_edac_dmidecode(const struct dmi_header *dh, void *arg)
 		} else if (entry->size == 0x7fff) {
 			dimm->nr_pages = MiB_TO_PAGES(entry->extended_size);
 		} else {
-			if (entry->size & 1 << 15)
-				dimm->nr_pages = MiB_TO_PAGES((entry->size &
-							       0x7fff) << 10);
+			if (entry->size & BIT(15))
+				dimm->nr_pages = MiB_TO_PAGES((entry->size & 0x7fff) << 10);
 			else
 				dimm->nr_pages = MiB_TO_PAGES(entry->size);
 		}
 
 		switch (entry->memory_type) {
 		case 0x12:
-			if (entry->type_detail & 1 << 13)
+			if (entry->type_detail & BIT(13))
 				dimm->mtype = MEM_RDDR;
 			else
 				dimm->mtype = MEM_DDR;
 			break;
 		case 0x13:
-			if (entry->type_detail & 1 << 13)
+			if (entry->type_detail & BIT(13))
 				dimm->mtype = MEM_RDDR2;
 			else
 				dimm->mtype = MEM_DDR2;
@@ -123,30 +123,29 @@ static void ghes_edac_dmidecode(const struct dmi_header *dh, void *arg)
 			dimm->mtype = MEM_FB_DDR2;
 			break;
 		case 0x18:
-			if (entry->type_detail & 1 << 12)
+			if (entry->type_detail & BIT(12))
 				dimm->mtype = MEM_NVDIMM;
-			else if (entry->type_detail & 1 << 13)
+			else if (entry->type_detail & BIT(13))
 				dimm->mtype = MEM_RDDR3;
 			else
 				dimm->mtype = MEM_DDR3;
 			break;
 		case 0x1a:
-			if (entry->type_detail & 1 << 12)
+			if (entry->type_detail & BIT(12))
 				dimm->mtype = MEM_NVDIMM;
-			else if (entry->type_detail & 1 << 13)
+			else if (entry->type_detail & BIT(13))
 				dimm->mtype = MEM_RDDR4;
 			else
 				dimm->mtype = MEM_DDR4;
 			break;
 		default:
-			if (entry->type_detail & 1 << 6)
+			if (entry->type_detail & BIT(6))
 				dimm->mtype = MEM_RMBS;
-			else if ((entry->type_detail & ((1 << 7) | (1 << 13)))
-				 == ((1 << 7) | (1 << 13)))
+			else if ((entry->type_detail & rdr_mask) == rdr_mask)
 				dimm->mtype = MEM_RDR;
-			else if (entry->type_detail & 1 << 7)
+			else if (entry->type_detail & BIT(7))
 				dimm->mtype = MEM_SDR;
-			else if (entry->type_detail & 1 << 9)
+			else if (entry->type_detail & BIT(9))
 				dimm->mtype = MEM_EDO;
 			else
 				dimm->mtype = MEM_UNKNOWN;

commit ad0d73b324dbc9e5b987fbda08ceb523fbeb0a9f
Author: Toshi Kani <toshi.kani@hpe.com>
Date:   Wed May 9 16:20:30 2018 -0600

    EDAC, ghes: Add DDR4 and NVDIMM memory types
    
    The ghes_edac driver obtains memory type from SMBIOS type 17, but it
    does not recognize DDR4 and NVDIMM types.
    
    Add support of DDR4 and NVDIMM types. NVDIMM type is denoted by memory
    type DDR3/4 and non-volatile.
    
    Reported-by: Robert Elliott <elliott@hpe.com>
    Signed-off-by: Toshi Kani <toshi.kani@hpe.com>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Link: http://lkml.kernel.org/r/20180509222030.9299-1-toshi.kani@hpe.com
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index b9bea77b3de8..cb8f2704ffb0 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -123,11 +123,21 @@ static void ghes_edac_dmidecode(const struct dmi_header *dh, void *arg)
 			dimm->mtype = MEM_FB_DDR2;
 			break;
 		case 0x18:
-			if (entry->type_detail & 1 << 13)
+			if (entry->type_detail & 1 << 12)
+				dimm->mtype = MEM_NVDIMM;
+			else if (entry->type_detail & 1 << 13)
 				dimm->mtype = MEM_RDDR3;
 			else
 				dimm->mtype = MEM_DDR3;
 			break;
+		case 0x1a:
+			if (entry->type_detail & 1 << 12)
+				dimm->mtype = MEM_NVDIMM;
+			else if (entry->type_detail & 1 << 13)
+				dimm->mtype = MEM_RDDR4;
+			else
+				dimm->mtype = MEM_DDR4;
+			break;
 		default:
 			if (entry->type_detail & 1 << 6)
 				dimm->mtype = MEM_RMBS;

commit 305d0e006a1736fbfec25e7a2d1e813694f82ed0
Author: Alexandru Gagniuc <mr.nuke.me@gmail.com>
Date:   Mon Apr 30 16:33:50 2018 -0500

    EDAC, ghes: Remove unused argument to ghes_edac_report_mem_error()
    
    The use of the @ghes argument was removed in a previous commit, but
    function signature was not updated to reflect this.
    
    Signed-off-by: Alexandru Gagniuc <mr.nuke.me@gmail.com>
    Acked-by: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: linux-acpi@vger.kernel.org
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Link: http://lkml.kernel.org/r/20180430213358.8319-1-mr.nuke.me@gmail.com
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 758744038d93..b9bea77b3de8 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -172,8 +172,7 @@ static void ghes_edac_dmidecode(const struct dmi_header *dh, void *arg)
 	}
 }
 
-void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
-				struct cper_sec_mem_err *mem_err)
+void ghes_edac_report_mem_error(int sev, struct cper_sec_mem_err *mem_err)
 {
 	enum hw_event_mc_err_type type;
 	struct edac_raw_error_desc *e;

commit a66bdf5d11b0ba8e473ef90ba7e0e6399b5fc825
Author: Sughosh Ganu <sughosh.ganu@arm.com>
Date:   Thu Apr 26 15:46:49 2018 +0530

    EDAC, ghes: Add a null pointer check in ghes_edac_unregister()
    
    Add a null check for ghes_pvt, before dereferencing it. The pointer
    could still be null in case the return path is taken before initialising
    ghes_pvt in the registration function.
    
    Reviewed-by: Toshi Kani <toshi.kani@hpe.com>
    Signed-off-by: Sughosh Ganu <sughosh.ganu@arm.com>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Cc: lkml <linux-kernel@vger.kernel.org>
    Link: http://lkml.kernel.org/r/1524737809-24475-1-git-send-email-sughosh.ganu@arm.com
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 7fdbfe871f5c..758744038d93 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -517,6 +517,9 @@ void ghes_edac_unregister(struct ghes *ghes)
 {
 	struct mem_ctl_info *mci;
 
+	if (!ghes_pvt)
+		return;
+
 	mci = ghes_pvt->mci;
 	edac_mc_del_mc(mci->pdev);
 	edac_mc_free(mci);

commit cc7f3f132658289b6661ab8294ab08a9d32ea026
Author: Borislav Petkov <bp@suse.de>
Date:   Mon Apr 23 14:16:46 2018 +0200

    ghes, EDAC: Fix ghes_edac registration
    
    Tony reported seeing
    
      "Internal error: Can't find EDAC structure"
    
    when injecting correctable errors due to the fact that ghes_edac would
    still load even if the whitelist won't hit. Drop the pr_err() in
    ghes_edac_report_mem_error() for now due to the hacky way how ghes_edac
    depends on ghes.c.
    
    While at it, make ghes_edac_register() return an error if it doesn't hit
    in the whitelist as it is the only sensible thing to do in that
    situation.
    
    Furthermore, move the call to it to happen last in ghes_probe() so that
    GHES initializing properly does not depend on ghes_edac init at all
    as latter is only reporting errors and not required for GHES's proper
    functioning.
    
    Reviewed-by: Toshi Kani <toshi.kani@hpe.com>
    Tested-by: Sughosh Ganu <sughosh.ganu@arm.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Tony Luck <tony.luck@intel.com>
    Link: https://lkml.kernel.org/r/20180420182015.zao3olss4tvvlxki@agluck-desk

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 68b6ee18bea6..7fdbfe871f5c 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -183,10 +183,8 @@ void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
 	char *p;
 	u8 grain_bits;
 
-	if (!pvt) {
-		pr_err("Internal error: Can't find EDAC structure\n");
+	if (!pvt)
 		return;
-	}
 
 	/*
 	 * We can do the locking below because GHES defers error processing
@@ -439,7 +437,7 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 	/* Check if safe to enable on this system */
 	idx = acpi_match_platform_list(plat_list);
 	if (!force_load && idx < 0)
-		return 0;
+		return -ENODEV;
 
 	/*
 	 * We have only one logical memory controller to which all DIMMs belong.

commit 5deed6b6a479ad5851d7ead6412dc6faa84a694e
Author: Toshi Kani <toshi.kani@hpe.com>
Date:   Wed Aug 23 16:54:45 2017 -0600

    EDAC, ghes: Add platform check
    
    The ghes_edac driver was introduced in 2013 [1], but it has not been
    enabled by any distro yet. This driver obtains error info from firmware
    interfaces (APEI), which are not properly implemented on many platforms,
    as the driver says on load:
    
      This EDAC driver relies on BIOS to enumerate memory and get error
      reports. Unfortunately, not all BIOSes reflect the memory layout
      correctly. So, the end result of using this driver varies from vendor
      to vendor. If you find incorrect reports, please contact your hardware
      vendor to correct its BIOS.
    
    To get out from this situation, add a platform check to selectively
    enable the driver on platforms that are known to have proper APEI
    firmware implementation.
    
    "ghes_edac.force_load=1" skips this platform check.
    
    [1]: https://lkml.kernel.org/r/cover.1360931635.git.mchehab@redhat.com
    
    Signed-off-by: Toshi Kani <toshi.kani@hpe.com>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: linux-acpi@vger.kernel.org
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Link: http://lkml.kernel.org/r/20170823225447.15608-4-toshi.kani@hpe.com
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 8d904df75ad8..68b6ee18bea6 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -38,6 +38,10 @@ static struct ghes_edac_pvt *ghes_pvt;
  */
 static DEFINE_SPINLOCK(ghes_lock);
 
+/* "ghes_edac.force_load=1" skips the platform check */
+static bool __read_mostly force_load;
+module_param(force_load, bool, 0);
+
 /* Memory Device - Type 17 of SMBIOS spec */
 struct memdev_dmi_entry {
 	u8 type;
@@ -415,6 +419,14 @@ void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
 	spin_unlock_irqrestore(&ghes_lock, flags);
 }
 
+/*
+ * Known systems that are safe to enable this module.
+ */
+static struct acpi_platform_list plat_list[] = {
+	{"HPE   ", "Server  ", 0, ACPI_SIG_FADT, all_versions},
+	{ } /* End */
+};
+
 int ghes_edac_register(struct ghes *ghes, struct device *dev)
 {
 	bool fake = false;
@@ -422,6 +434,12 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 	struct mem_ctl_info *mci;
 	struct edac_mc_layer layers[1];
 	struct ghes_edac_dimm_fill dimm_fill;
+	int idx;
+
+	/* Check if safe to enable on this system */
+	idx = acpi_match_platform_list(plat_list);
+	if (!force_load && idx < 0)
+		return 0;
 
 	/*
 	 * We have only one logical memory controller to which all DIMMs belong.
@@ -460,17 +478,17 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 	mci->ctl_name = "ghes_edac";
 	mci->dev_name = "ghes";
 
-	if (!fake) {
+	if (fake) {
+		pr_info("This system has a very crappy BIOS: It doesn't even list the DIMMS.\n");
+		pr_info("Its SMBIOS info is wrong. It is doubtful that the error report would\n");
+		pr_info("work on such system. Use this driver with caution\n");
+	} else if (idx < 0) {
 		pr_info("This EDAC driver relies on BIOS to enumerate memory and get error reports.\n");
 		pr_info("Unfortunately, not all BIOSes reflect the memory layout correctly.\n");
 		pr_info("So, the end result of using this driver varies from vendor to vendor.\n");
 		pr_info("If you find incorrect reports, please contact your hardware vendor\n");
 		pr_info("to correct its BIOS.\n");
 		pr_info("This system has %d DIMM sockets.\n", num_dimm);
-	} else {
-		pr_info("This system has a very crappy BIOS: It doesn't even list the DIMMS.\n");
-		pr_info("Its SMBIOS info is wrong. It is doubtful that the error report would\n");
-		pr_info("work on such system. Use this driver with caution\n");
 	}
 
 	if (!fake) {

commit 0fe5f281f749f1d4e462a282ef8ba76407a11fd1
Author: Borislav Petkov <bp@suse.de>
Date:   Wed Aug 16 10:33:44 2017 +0200

    EDAC, ghes: Model a single, logical memory controller
    
    We're enumerating the DIMMs through a DMI walk and since we can't get
    any more detailed topological information about which DIMMs belong to
    which memory controller, convert it to a single, logical controller
    which contains all the DIMMs.
    
    The error reporting path from GHES ghes_edac_report_mem_error() doesn't
    get called in NMI context but add a warning about it to catch any
    changes in the future as if so, our locking scheme will be insufficient
    then.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 8acdf29cf3a4..8d904df75ad8 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -28,10 +28,15 @@ struct ghes_edac_pvt {
 	char msg[80];
 };
 
-static LIST_HEAD(ghes_reglist);
-static DEFINE_MUTEX(ghes_edac_lock);
-static int ghes_edac_mc_num;
+static atomic_t ghes_init = ATOMIC_INIT(0);
+static struct ghes_edac_pvt *ghes_pvt;
 
+/*
+ * Sync with other, potentially concurrent callers of
+ * ghes_edac_report_mem_error(). We don't know what the
+ * "inventive" firmware would do.
+ */
+static DEFINE_SPINLOCK(ghes_lock);
 
 /* Memory Device - Type 17 of SMBIOS spec */
 struct memdev_dmi_entry {
@@ -169,18 +174,26 @@ void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
 	enum hw_event_mc_err_type type;
 	struct edac_raw_error_desc *e;
 	struct mem_ctl_info *mci;
-	struct ghes_edac_pvt *pvt = NULL;
+	struct ghes_edac_pvt *pvt = ghes_pvt;
+	unsigned long flags;
 	char *p;
 	u8 grain_bits;
 
-	list_for_each_entry(pvt, &ghes_reglist, list) {
-		if (ghes == pvt->ghes)
-			break;
-	}
 	if (!pvt) {
 		pr_err("Internal error: Can't find EDAC structure\n");
 		return;
 	}
+
+	/*
+	 * We can do the locking below because GHES defers error processing
+	 * from NMI to IRQ context. Whenever that changes, we'd at least
+	 * know.
+	 */
+	if (WARN_ON_ONCE(in_nmi()))
+		return;
+
+	spin_lock_irqsave(&ghes_lock, flags);
+
 	mci = pvt->mci;
 	e = &mci->error_desc;
 
@@ -398,8 +411,8 @@ void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
 		       (e->page_frame_number << PAGE_SHIFT) | e->offset_in_page,
 		       grain_bits, e->syndrome, pvt->detail_location);
 
-	/* Report the error via EDAC API */
 	edac_raw_mc_handle_error(type, mci, e);
+	spin_unlock_irqrestore(&ghes_lock, flags);
 }
 
 int ghes_edac_register(struct ghes *ghes, struct device *dev)
@@ -408,9 +421,14 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 	int rc, num_dimm = 0;
 	struct mem_ctl_info *mci;
 	struct edac_mc_layer layers[1];
-	struct ghes_edac_pvt *pvt;
 	struct ghes_edac_dimm_fill dimm_fill;
 
+	/*
+	 * We have only one logical memory controller to which all DIMMs belong.
+	 */
+	if (atomic_inc_return(&ghes_init) > 1)
+		return 0;
+
 	/* Get the number of DIMMs */
 	dmi_walk(ghes_edac_count_dimms, &num_dimm);
 
@@ -424,26 +442,17 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 	layers[0].size = num_dimm;
 	layers[0].is_virt_csrow = true;
 
-	/*
-	 * We need to serialize edac_mc_alloc() and edac_mc_add_mc(),
-	 * to avoid duplicated memory controller numbers
-	 */
-	mutex_lock(&ghes_edac_lock);
-	mci = edac_mc_alloc(ghes_edac_mc_num, ARRAY_SIZE(layers), layers,
-			    sizeof(*pvt));
+	mci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(struct ghes_edac_pvt));
 	if (!mci) {
 		pr_info("Can't allocate memory for EDAC data\n");
-		mutex_unlock(&ghes_edac_lock);
 		return -ENOMEM;
 	}
 
-	pvt = mci->pvt_info;
-	memset(pvt, 0, sizeof(*pvt));
-	list_add_tail(&pvt->list, &ghes_reglist);
-	pvt->ghes = ghes;
-	pvt->mci  = mci;
-	mci->pdev = dev;
+	ghes_pvt	= mci->pvt_info;
+	ghes_pvt->ghes	= ghes;
+	ghes_pvt->mci	= mci;
 
+	mci->pdev = dev;
 	mci->mtype_cap = MEM_FLAG_EMPTY;
 	mci->edac_ctl_cap = EDAC_FLAG_NONE;
 	mci->edac_cap = EDAC_FLAG_NONE;
@@ -451,36 +460,23 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 	mci->ctl_name = "ghes_edac";
 	mci->dev_name = "ghes";
 
-	if (!ghes_edac_mc_num) {
-		if (!fake) {
-			pr_info("This EDAC driver relies on BIOS to enumerate memory and get error reports.\n");
-			pr_info("Unfortunately, not all BIOSes reflect the memory layout correctly.\n");
-			pr_info("So, the end result of using this driver varies from vendor to vendor.\n");
-			pr_info("If you find incorrect reports, please contact your hardware vendor\n");
-			pr_info("to correct its BIOS.\n");
-			pr_info("This system has %d DIMM sockets.\n",
-				num_dimm);
-		} else {
-			pr_info("This system has a very crappy BIOS: It doesn't even list the DIMMS.\n");
-			pr_info("Its SMBIOS info is wrong. It is doubtful that the error report would\n");
-			pr_info("work on such system. Use this driver with caution\n");
-		}
+	if (!fake) {
+		pr_info("This EDAC driver relies on BIOS to enumerate memory and get error reports.\n");
+		pr_info("Unfortunately, not all BIOSes reflect the memory layout correctly.\n");
+		pr_info("So, the end result of using this driver varies from vendor to vendor.\n");
+		pr_info("If you find incorrect reports, please contact your hardware vendor\n");
+		pr_info("to correct its BIOS.\n");
+		pr_info("This system has %d DIMM sockets.\n", num_dimm);
+	} else {
+		pr_info("This system has a very crappy BIOS: It doesn't even list the DIMMS.\n");
+		pr_info("Its SMBIOS info is wrong. It is doubtful that the error report would\n");
+		pr_info("work on such system. Use this driver with caution\n");
 	}
 
 	if (!fake) {
-		/*
-		 * Fill DIMM info from DMI for the memory controller #0
-		 *
-		 * Keep it in blank for the other memory controllers, as
-		 * there's no reliable way to properly credit each DIMM to
-		 * the memory controller, as different BIOSes fill the
-		 * DMI bank location fields on different ways
-		 */
-		if (!ghes_edac_mc_num) {
-			dimm_fill.count = 0;
-			dimm_fill.mci = mci;
-			dmi_walk(ghes_edac_dmidecode, &dimm_fill);
-		}
+		dimm_fill.count = 0;
+		dimm_fill.mci = mci;
+		dmi_walk(ghes_edac_dmidecode, &dimm_fill);
 	} else {
 		struct dimm_info *dimm = EDAC_DIMM_PTR(mci->layers, mci->dimms,
 						       mci->n_layers, 0, 0, 0);
@@ -496,26 +492,16 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 	if (rc < 0) {
 		pr_info("Can't register at EDAC core\n");
 		edac_mc_free(mci);
-		mutex_unlock(&ghes_edac_lock);
 		return -ENODEV;
 	}
-
-	ghes_edac_mc_num++;
-	mutex_unlock(&ghes_edac_lock);
 	return 0;
 }
 
 void ghes_edac_unregister(struct ghes *ghes)
 {
 	struct mem_ctl_info *mci;
-	struct ghes_edac_pvt *pvt, *tmp;
-
-	list_for_each_entry_safe(pvt, tmp, &ghes_reglist, list) {
-		if (ghes == pvt->ghes) {
-			mci = pvt->mci;
-			edac_mc_del_mc(mci->pdev);
-			edac_mc_free(mci);
-			list_del(&pvt->list);
-		}
-	}
+
+	mci = ghes_pvt->mci;
+	edac_mc_del_mc(mci->pdev);
+	edac_mc_free(mci);
 }

commit c9c8b4d6d0259ac914309f8fbcef022792c99a89
Author: Borislav Petkov <bp@suse.de>
Date:   Wed Aug 16 19:41:52 2017 +0200

    EDAC, ghes: Remove symbol exports
    
    They're called from builtin code so no need for the exports.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 6f80eb65c26c..8acdf29cf3a4 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -401,7 +401,6 @@ void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
 	/* Report the error via EDAC API */
 	edac_raw_mc_handle_error(type, mci, e);
 }
-EXPORT_SYMBOL_GPL(ghes_edac_report_mem_error);
 
 int ghes_edac_register(struct ghes *ghes, struct device *dev)
 {
@@ -505,7 +504,6 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 	mutex_unlock(&ghes_edac_lock);
 	return 0;
 }
-EXPORT_SYMBOL_GPL(ghes_edac_register);
 
 void ghes_edac_unregister(struct ghes *ghes)
 {
@@ -521,4 +519,3 @@ void ghes_edac_unregister(struct ghes *ghes)
 		}
 	}
 }
-EXPORT_SYMBOL_GPL(ghes_edac_unregister);

commit c54182ec0e157988f0cafd1e8d37b68ab4210f87
Author: Borislav Petkov <bp@suse.de>
Date:   Thu Jun 29 12:00:05 2017 +0200

    EDAC: Get rid of mci->mod_ver
    
    It is a write-only variable so get rid of it.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Robert Richter <rric@kernel.org>
    Acked-by: Michal Simek <michal.simek@xilinx.com>
    Acked-by: Thor Thayer <thor.thayer@linux.intel.com>
    Acked-by: Tony Luck <tony.luck@intel.com>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: Tim Small <tim@buttersideup.com>
    Cc: Ranganathan Desikan <ravi@jetztechnologies.com>
    Cc: "Arvind R." <arvino55@gmail.com>
    Cc: Jason Baron <jbaron@akamai.com>
    Cc: "Sören Brinkmann" <soren.brinkmann@xilinx.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: David Daney <david.daney@cavium.com>
    Cc: Loc Ho <lho@apm.com>
    Cc: linux-edac@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-mips@linux-mips.org

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 4e61a6229dd2..6f80eb65c26c 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -17,8 +17,6 @@
 #include "edac_module.h"
 #include <ras/ras_event.h>
 
-#define GHES_EDAC_REVISION " Ver: 1.0.0"
-
 struct ghes_edac_pvt {
 	struct list_head list;
 	struct ghes *ghes;
@@ -451,7 +449,6 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 	mci->edac_ctl_cap = EDAC_FLAG_NONE;
 	mci->edac_cap = EDAC_FLAG_NONE;
 	mci->mod_name = "ghes_edac.c";
-	mci->mod_ver = GHES_EDAC_REVISION;
 	mci->ctl_name = "ghes_edac";
 	mci->dev_name = "ghes";
 

commit 78d88e8a3d738f1ce508cd24b525d2e6cdfda1c1
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Sat Oct 29 15:16:34 2016 -0200

    edac: rename edac_core.h to edac_mc.h
    
    Now, all left at edac_core.h are at drivers/edac/edac_mc.c,
    so rename it to edac_mc.h.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index e3fa4390f846..4e61a6229dd2 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -14,7 +14,7 @@
 #include <acpi/ghes.h>
 #include <linux/edac.h>
 #include <linux/dmi.h>
-#include "edac_core.h"
+#include "edac_module.h"
 #include <ras/ras_event.h>
 
 #define GHES_EDAC_REVISION " Ver: 1.0.0"

commit 990995bad13c2bcf074f87236d1a6c5e09bd5eff
Author: Tan Xiaojun <tanxiaojun@huawei.com>
Date:   Tue Oct 20 19:45:38 2015 +0800

    EDAC: Fix PAGES_TO_MiB macro misuse
    
    The PAGES_TO_MiB macro is used for unit conversion but the
    trace_mc_event() tracepoint expects a page address. Fix that.
    
    Signed-off-by: Tan Xiaojun <tanxiaojun@huawei.com>
    Cc: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Link: http://lkml.kernel.org/r/1445341538-24271-1-git-send-email-tanxiaojun@huawei.com
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index b1e451242108..e3fa4390f846 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -397,7 +397,7 @@ void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
 		 "APEI location: %s %s", e->location, e->other_detail);
 	trace_mc_event(type, e->msg, e->label, e->error_count,
 		       mci->mc_idx, e->top_layer, e->mid_layer, e->low_layer,
-		       PAGES_TO_MiB(e->page_frame_number) | e->offset_in_page,
+		       (e->page_frame_number << PAGE_SHIFT) | e->offset_in_page,
 		       grain_bits, e->syndrome, pvt->detail_location);
 
 	/* Report the error via EDAC API */

commit 58a9c251c9a1a2f2154e40a9fe7bb81857761b24
Author: Aravind Gopalakrishnan <Aravind.Gopalakrishnan@amd.com>
Date:   Wed Sep 16 15:53:29 2015 -0500

    EDAC, ghes_edac: Remove redundant memory_type array
    
    We already have edac_mem_types[] that enumerates the different kinds of
    memory. So, use that and remove the redundant memory_type[] array here.
    
    Signed-off-by: Aravind Gopalakrishnan <Aravind.Gopalakrishnan@amd.com>
    Cc: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Link: http://lkml.kernel.org/r/1442436811-23382-2-git-send-email-Aravind.Gopalakrishnan@amd.com
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index b24681998740..b1e451242108 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -66,26 +66,6 @@ struct ghes_edac_dimm_fill {
 	unsigned count;
 };
 
-char *memory_type[] = {
-	[MEM_EMPTY] = "EMPTY",
-	[MEM_RESERVED] = "RESERVED",
-	[MEM_UNKNOWN] = "UNKNOWN",
-	[MEM_FPM] = "FPM",
-	[MEM_EDO] = "EDO",
-	[MEM_BEDO] = "BEDO",
-	[MEM_SDR] = "SDR",
-	[MEM_RDR] = "RDR",
-	[MEM_DDR] = "DDR",
-	[MEM_RDDR] = "RDDR",
-	[MEM_RMBS] = "RMBS",
-	[MEM_DDR2] = "DDR2",
-	[MEM_FB_DDR2] = "FB_DDR2",
-	[MEM_RDDR2] = "RDDR2",
-	[MEM_XDR] = "XDR",
-	[MEM_DDR3] = "DDR3",
-	[MEM_RDDR3] = "RDDR3",
-};
-
 static void ghes_edac_count_dimms(const struct dmi_header *dh, void *arg)
 {
 	int *num_dimm = arg;
@@ -173,7 +153,7 @@ static void ghes_edac_dmidecode(const struct dmi_header *dh, void *arg)
 
 		if (dimm->nr_pages) {
 			edac_dbg(1, "DIMM%i: %s size = %d MB%s\n",
-				dimm_fill->count, memory_type[dimm->mtype],
+				dimm_fill->count, edac_mem_types[dimm->mtype],
 				PAGES_TO_MiB(dimm->nr_pages),
 				(dimm->edac_mode != EDAC_NONE) ? "(ECC)" : "");
 			edac_dbg(2, "\ttype %d, detail 0x%02x, width %d(total %d)\n",

commit 665aa8cdc499b9aeea6532e682a58ca34b7f94e6
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Aug 1 11:25:14 2014 +0300

    ghes_edac: Use snprintf() to silence a static checker warning
    
    My static checker complains because the "e->location" has up to 256
    characters but we are copying it into the "pvt->detail_location" which
    only has space for 240 characters.  That's not counting the surrounding
    text and the "e->other_detail" string which can be over 80 characters
    long.
    
    I am not familiar with this code but presumably it normally works.
    Let's add a limit though for safety.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Link: http://lkml.kernel.org/r/20140801082514.GD28869@mwanda
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 8399b4e16fe0..b24681998740 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -413,8 +413,8 @@ void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
 
 	/* Generate the trace event */
 	grain_bits = fls_long(e->grain);
-	sprintf(pvt->detail_location, "APEI location: %s %s",
-		e->location, e->other_detail);
+	snprintf(pvt->detail_location, sizeof(pvt->detail_location),
+		 "APEI location: %s %s", e->location, e->other_detail);
 	trace_mc_event(type, e->msg, e->label, e->error_count,
 		       mci->mc_idx, e->top_layer, e->mid_layer, e->low_layer,
 		       PAGES_TO_MiB(e->page_frame_number) | e->offset_in_page,

commit 37e59f876bc710d67a30b660826a5e83e07101ce
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Fri Feb 7 08:03:07 2014 -0200

    [media, edac] Change my email address
    
    There are several left overs with my old email address.
    Remove their occurrences and add myself at CREDITS, to
    allow people to be able to reach me on my new addresses.
    
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index d5a98a45c062..8399b4e16fe0 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -4,7 +4,7 @@
  * This file may be distributed under the terms of the GNU General Public
  * License version 2.
  *
- * Copyright (c) 2013 by Mauro Carvalho Chehab <mchehab@redhat.com>
+ * Copyright (c) 2013 by Mauro Carvalho Chehab
  *
  * Red Hat Inc. http://www.redhat.com
  */

commit 56507694de3453076d73e0e9813349586ee67e59
Author: Chen, Gong <gong.chen@linux.intel.com>
Date:   Fri Oct 18 14:30:38 2013 -0700

    EDAC, GHES: Update ghes error record info
    
    In latest UEFI spec(by now it's 2.4) there are some new
    fields for memory error reporting. Add these new fields for
    ghes_edac interface.
    
    Signed-off-by: Chen, Gong <gong.chen@linux.intel.com>
    Cc: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 0ad797b9db65..d5a98a45c062 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -314,6 +314,8 @@ void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
 		p += sprintf(p, "card:%d ", mem_err->card);
 	if (mem_err->validation_bits & CPER_MEM_VALID_MODULE)
 		p += sprintf(p, "module:%d ", mem_err->module);
+	if (mem_err->validation_bits & CPER_MEM_VALID_RANK_NUMBER)
+		p += sprintf(p, "rank:%d ", mem_err->rank);
 	if (mem_err->validation_bits & CPER_MEM_VALID_BANK)
 		p += sprintf(p, "bank:%d ", mem_err->bank);
 	if (mem_err->validation_bits & CPER_MEM_VALID_ROW)
@@ -322,6 +324,15 @@ void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
 		p += sprintf(p, "col:%d ", mem_err->column);
 	if (mem_err->validation_bits & CPER_MEM_VALID_BIT_POSITION)
 		p += sprintf(p, "bit_pos:%d ", mem_err->bit_pos);
+	if (mem_err->validation_bits & CPER_MEM_VALID_MODULE_HANDLE) {
+		const char *bank = NULL, *device = NULL;
+		dmi_memdev_name(mem_err->mem_dev_handle, &bank, &device);
+		if (bank != NULL && device != NULL)
+			p += sprintf(p, "DIMM location:%s %s ", bank, device);
+		else
+			p += sprintf(p, "DIMM DMI handle: 0x%.4x ",
+				     mem_err->mem_dev_handle);
+	}
 	if (p > e->location)
 		*(p - 1) = '\0';
 

commit 147de14772ed897727dba7353916b02d1e0f17f4
Author: Chen, Gong <gong.chen@linux.intel.com>
Date:   Fri Oct 18 14:30:13 2013 -0700

    ACPI, APEI, CPER: Add UEFI 2.4 support for memory error
    
    In latest UEFI spec(by now it is 2.4) memory error definition
    for CPER (UEFI 2.4 Appendix N Common Platform Error Record)
    adds some new fields. These fields help people to locate
    memory error to an actual DIMM location.
    
    Original-author: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Chen, Gong <gong.chen@linux.intel.com>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Acked-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index bb534670ec02..0ad797b9db65 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -297,15 +297,14 @@ void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
 	}
 
 	/* Error address */
-	if (mem_err->validation_bits & CPER_MEM_VALID_PHYSICAL_ADDRESS) {
+	if (mem_err->validation_bits & CPER_MEM_VALID_PA) {
 		e->page_frame_number = mem_err->physical_addr >> PAGE_SHIFT;
 		e->offset_in_page = mem_err->physical_addr & ~PAGE_MASK;
 	}
 
 	/* Error grain */
-	if (mem_err->validation_bits & CPER_MEM_VALID_PHYSICAL_ADDRESS_MASK) {
+	if (mem_err->validation_bits & CPER_MEM_VALID_PA_MASK)
 		e->grain = ~(mem_err->physical_addr_mask & ~PAGE_MASK);
-	}
 
 	/* Memory error location, mapped on e->location */
 	p = e->location;

commit 5dae92a718570e6a942e0b882e53d25cab03b40f
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Tue Feb 26 16:39:14 2013 +0800

    ghes_edac: fix to use list_for_each_entry_safe() when delete list items
    
    Since we will remove items off the list using list_del() we need
    to use a safe version of the list_for_each_entry() macro aptly named
    list_for_each_entry_safe().
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 636dcf18d5b6..bb534670ec02 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -523,9 +523,9 @@ EXPORT_SYMBOL_GPL(ghes_edac_register);
 void ghes_edac_unregister(struct ghes *ghes)
 {
 	struct mem_ctl_info *mci;
-	struct ghes_edac_pvt *pvt;
+	struct ghes_edac_pvt *pvt, *tmp;
 
-	list_for_each_entry(pvt, &ghes_reglist, list) {
+	list_for_each_entry_safe(pvt, tmp, &ghes_reglist, list) {
 		if (ghes == pvt->ghes) {
 			mci = pvt->mci;
 			edac_mc_del_mc(mci->pdev);

commit 8ae8f50ad8979bb670598ff92eebea611b799f10
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue Feb 19 21:35:41 2013 -0300

    ghes_edac: Fix RAS tracing
    
    With the current version of CPER, there's no way to associate an
    error with the memory error. So, the error location in EDAC
    layers is unused.
    
    As CPER has its own idea about memory architectural layers, just
    output whatever is there inside the driver's detail at the RAS
    tracepoint.
    
    The EDAC location keeps untouched, in the case that, in some future,
    we could actually map the error into the dimm labels.
    
    Now, the error message:
    
    [   72.396625] {1}[Hardware Error]: Hardware error from APEI Generic Hardware Error Source: 0
    [   72.396627] {1}[Hardware Error]: APEI generic hardware error status
    [   72.396628] {1}[Hardware Error]: severity: 2, corrected
    [   72.396630] {1}[Hardware Error]: section: 0, severity: 2, corrected
    [   72.396632] {1}[Hardware Error]: flags: 0x01
    [   72.396634] {1}[Hardware Error]: primary
    [   72.396635] {1}[Hardware Error]: section_type: memory error
    [   72.396637] {1}[Hardware Error]: error_status: 0x0000000000000400
    [   72.396638] {1}[Hardware Error]: node: 3
    [   72.396639] {1}[Hardware Error]: card: 0
    [   72.396640] {1}[Hardware Error]: module: 0
    [   72.396641] {1}[Hardware Error]: device: 0
    [   72.396643] {1}[Hardware Error]: error_type: 18, unknown
    [   72.396666] EDAC MC0: 1 CE reserved error (18) on unknown label (node:3 card:0 module:0 page:0x0 offset:0x0 grain:0 syndrome:0x0 - status(0x0000000000000400): Storage error in DRAM memory)
    
    Is properly represented on the trace event:
    
         kworker/0:2-584   [000] ....    72.396657: mc_event: 1 Corrected error: reserved error (18) on unknown label (mc:0 location:-1:-1:-1 address:0x00000000 grain:1 syndrome:0x00000000 APEI location: node:3 card:0 module:0 status(0x0000000000000400): Storage error in DRAM memory)
    
    Tested on a 4 sockets E5-4650 Sandy Bridge machine.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 1bde45141073..636dcf18d5b6 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -15,6 +15,7 @@
 #include <linux/edac.h>
 #include <linux/dmi.h>
 #include "edac_core.h"
+#include <ras/ras_event.h>
 
 #define GHES_EDAC_REVISION " Ver: 1.0.0"
 
@@ -24,6 +25,7 @@ struct ghes_edac_pvt {
 	struct mem_ctl_info *mci;
 
 	/* Buffers for the error handling routine */
+	char detail_location[240];
 	char other_detail[160];
 	char msg[80];
 };
@@ -191,6 +193,7 @@ void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
 	struct mem_ctl_info *mci;
 	struct ghes_edac_pvt *pvt = NULL;
 	char *p;
+	u8 grain_bits;
 
 	list_for_each_entry(pvt, &ghes_reglist, list) {
 		if (ghes == pvt->ghes)
@@ -398,6 +401,16 @@ void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
 	if (p > pvt->other_detail)
 		*(p - 1) = '\0';
 
+	/* Generate the trace event */
+	grain_bits = fls_long(e->grain);
+	sprintf(pvt->detail_location, "APEI location: %s %s",
+		e->location, e->other_detail);
+	trace_mc_event(type, e->msg, e->label, e->error_count,
+		       mci->mc_idx, e->top_layer, e->mid_layer, e->low_layer,
+		       PAGES_TO_MiB(e->page_frame_number) | e->offset_in_page,
+		       grain_bits, e->syndrome, pvt->detail_location);
+
+	/* Report the error via EDAC API */
 	edac_raw_mc_handle_error(type, mci, e);
 }
 EXPORT_SYMBOL_GPL(ghes_edac_report_mem_error);

commit 689c9cd8128f13bf9843a3e133423f5e3e0ce4aa
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue Feb 19 19:24:12 2013 -0300

    ghes_edac: Make it compliant with UEFI spec 2.3.1
    
    The UEFI spec defines the memory error types ans the bits that
    validate each field on the memory error record, at
    Appendix N om items N.2.5 (Memory Error Section) and
    N.2.11 (Error Status). Make the error description compliant with
    it, only showing the valid fields.
    
    The EDAC error log is now properly reporting the error:
    
    [  281.556854] mce: [Hardware Error]: Machine check events logged
    [  281.557042] {2}[Hardware Error]: Hardware error from APEI Generic Hardware Error Source: 0
    [  281.557044] {2}[Hardware Error]: APEI generic hardware error status
    [  281.557046] {2}[Hardware Error]: severity: 2, corrected
    [  281.557048] {2}[Hardware Error]: section: 0, severity: 2, corrected
    [  281.557050] {2}[Hardware Error]: flags: 0x01
    [  281.557052] {2}[Hardware Error]: primary
    [  281.557053] {2}[Hardware Error]: section_type: memory error
    [  281.557055] {2}[Hardware Error]: error_status: 0x0000000000000400
    [  281.557056] {2}[Hardware Error]: node: 3
    [  281.557057] {2}[Hardware Error]: card: 0
    [  281.557058] {2}[Hardware Error]: module: 1
    [  281.557059] {2}[Hardware Error]: device: 0
    [  281.557061] {2}[Hardware Error]: error_type: 18, unknown
    [  281.557067] EDAC DEBUG: ghes_edac_report_mem_error: error validation_bits: 0x000040b9
    [  281.557084] EDAC MC0: 1 CE reserved error (18) on unknown label (node:3 card:0 module:1 page:0x0 offset:0x0 grain:0 syndrome:0x0 - status(0x0000000000000400): Storage error in DRAM memory)
    
    Tested on a 4 CPUs E5-4650 Sandy Bridge machine.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index b4acc4f2074d..1bde45141073 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -22,6 +22,10 @@ struct ghes_edac_pvt {
 	struct list_head list;
 	struct ghes *ghes;
 	struct mem_ctl_info *mci;
+
+	/* Buffers for the error handling routine */
+	char other_detail[160];
+	char msg[80];
 };
 
 static LIST_HEAD(ghes_reglist);
@@ -186,6 +190,7 @@ void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
 	struct edac_raw_error_desc *e;
 	struct mem_ctl_info *mci;
 	struct ghes_edac_pvt *pvt = NULL;
+	char *p;
 
 	list_for_each_entry(pvt, &ghes_reglist, list) {
 		if (ghes == pvt->ghes)
@@ -201,15 +206,14 @@ void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
 	/* Cleans the error report buffer */
 	memset(e, 0, sizeof (*e));
 	e->error_count = 1;
-	e->msg = "APEI";
-	strcpy(e->label, "unknown");
-	e->other_detail = "";
-
-	if (mem_err->validation_bits & CPER_MEM_VALID_PHYSICAL_ADDRESS) {
-		e->page_frame_number = mem_err->physical_addr >> PAGE_SHIFT;
-		e->offset_in_page = mem_err->physical_addr & ~PAGE_MASK;
-		e->grain = ~(mem_err->physical_addr_mask & ~PAGE_MASK);
-	}
+	strcpy(e->label, "unknown label");
+	e->msg = pvt->msg;
+	e->other_detail = pvt->other_detail;
+	e->top_layer = -1;
+	e->mid_layer = -1;
+	e->low_layer = -1;
+	*pvt->other_detail = '\0';
+	*pvt->msg = '\0';
 
 	switch (sev) {
 	case GHES_SEV_CORRECTED:
@@ -226,12 +230,173 @@ void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
 		type = HW_EVENT_ERR_INFO;
 	}
 
-	sprintf(e->location,
-		"node:%d card:%d module:%d bank:%d device:%d row: %d column:%d bit_pos:%d",
-		mem_err->node, mem_err->card, mem_err->module,
-		mem_err->bank, mem_err->device, mem_err->row, mem_err->column,
-		mem_err->bit_pos);
-	edac_dbg(3, "error at location %s\n", e->location);
+	edac_dbg(1, "error validation_bits: 0x%08llx\n",
+		 (long long)mem_err->validation_bits);
+
+	/* Error type, mapped on e->msg */
+	if (mem_err->validation_bits & CPER_MEM_VALID_ERROR_TYPE) {
+		p = pvt->msg;
+		switch (mem_err->error_type) {
+		case 0:
+			p += sprintf(p, "Unknown");
+			break;
+		case 1:
+			p += sprintf(p, "No error");
+			break;
+		case 2:
+			p += sprintf(p, "Single-bit ECC");
+			break;
+		case 3:
+			p += sprintf(p, "Multi-bit ECC");
+			break;
+		case 4:
+			p += sprintf(p, "Single-symbol ChipKill ECC");
+			break;
+		case 5:
+			p += sprintf(p, "Multi-symbol ChipKill ECC");
+			break;
+		case 6:
+			p += sprintf(p, "Master abort");
+			break;
+		case 7:
+			p += sprintf(p, "Target abort");
+			break;
+		case 8:
+			p += sprintf(p, "Parity Error");
+			break;
+		case 9:
+			p += sprintf(p, "Watchdog timeout");
+			break;
+		case 10:
+			p += sprintf(p, "Invalid address");
+			break;
+		case 11:
+			p += sprintf(p, "Mirror Broken");
+			break;
+		case 12:
+			p += sprintf(p, "Memory Sparing");
+			break;
+		case 13:
+			p += sprintf(p, "Scrub corrected error");
+			break;
+		case 14:
+			p += sprintf(p, "Scrub uncorrected error");
+			break;
+		case 15:
+			p += sprintf(p, "Physical Memory Map-out event");
+			break;
+		default:
+			p += sprintf(p, "reserved error (%d)",
+				     mem_err->error_type);
+		}
+	} else {
+		strcpy(pvt->msg, "unknown error");
+	}
+
+	/* Error address */
+	if (mem_err->validation_bits & CPER_MEM_VALID_PHYSICAL_ADDRESS) {
+		e->page_frame_number = mem_err->physical_addr >> PAGE_SHIFT;
+		e->offset_in_page = mem_err->physical_addr & ~PAGE_MASK;
+	}
+
+	/* Error grain */
+	if (mem_err->validation_bits & CPER_MEM_VALID_PHYSICAL_ADDRESS_MASK) {
+		e->grain = ~(mem_err->physical_addr_mask & ~PAGE_MASK);
+	}
+
+	/* Memory error location, mapped on e->location */
+	p = e->location;
+	if (mem_err->validation_bits & CPER_MEM_VALID_NODE)
+		p += sprintf(p, "node:%d ", mem_err->node);
+	if (mem_err->validation_bits & CPER_MEM_VALID_CARD)
+		p += sprintf(p, "card:%d ", mem_err->card);
+	if (mem_err->validation_bits & CPER_MEM_VALID_MODULE)
+		p += sprintf(p, "module:%d ", mem_err->module);
+	if (mem_err->validation_bits & CPER_MEM_VALID_BANK)
+		p += sprintf(p, "bank:%d ", mem_err->bank);
+	if (mem_err->validation_bits & CPER_MEM_VALID_ROW)
+		p += sprintf(p, "row:%d ", mem_err->row);
+	if (mem_err->validation_bits & CPER_MEM_VALID_COLUMN)
+		p += sprintf(p, "col:%d ", mem_err->column);
+	if (mem_err->validation_bits & CPER_MEM_VALID_BIT_POSITION)
+		p += sprintf(p, "bit_pos:%d ", mem_err->bit_pos);
+	if (p > e->location)
+		*(p - 1) = '\0';
+
+	/* All other fields are mapped on e->other_detail */
+	p = pvt->other_detail;
+	if (mem_err->validation_bits & CPER_MEM_VALID_ERROR_STATUS) {
+		u64 status = mem_err->error_status;
+
+		p += sprintf(p, "status(0x%016llx): ", (long long)status);
+		switch ((status >> 8) & 0xff) {
+		case 1:
+			p += sprintf(p, "Error detected internal to the component ");
+			break;
+		case 16:
+			p += sprintf(p, "Error detected in the bus ");
+			break;
+		case 4:
+			p += sprintf(p, "Storage error in DRAM memory ");
+			break;
+		case 5:
+			p += sprintf(p, "Storage error in TLB ");
+			break;
+		case 6:
+			p += sprintf(p, "Storage error in cache ");
+			break;
+		case 7:
+			p += sprintf(p, "Error in one or more functional units ");
+			break;
+		case 8:
+			p += sprintf(p, "component failed self test ");
+			break;
+		case 9:
+			p += sprintf(p, "Overflow or undervalue of internal queue ");
+			break;
+		case 17:
+			p += sprintf(p, "Virtual address not found on IO-TLB or IO-PDIR ");
+			break;
+		case 18:
+			p += sprintf(p, "Improper access error ");
+			break;
+		case 19:
+			p += sprintf(p, "Access to a memory address which is not mapped to any component ");
+			break;
+		case 20:
+			p += sprintf(p, "Loss of Lockstep ");
+			break;
+		case 21:
+			p += sprintf(p, "Response not associated with a request ");
+			break;
+		case 22:
+			p += sprintf(p, "Bus parity error - must also set the A, C, or D Bits ");
+			break;
+		case 23:
+			p += sprintf(p, "Detection of a PATH_ERROR ");
+			break;
+		case 25:
+			p += sprintf(p, "Bus operation timeout ");
+			break;
+		case 26:
+			p += sprintf(p, "A read was issued to data that has been poisoned ");
+			break;
+		default:
+			p += sprintf(p, "reserved ");
+			break;
+		}
+	}
+	if (mem_err->validation_bits & CPER_MEM_VALID_REQUESTOR_ID)
+		p += sprintf(p, "requestorID: 0x%016llx ",
+			     (long long)mem_err->requestor_id);
+	if (mem_err->validation_bits & CPER_MEM_VALID_RESPONDER_ID)
+		p += sprintf(p, "responderID: 0x%016llx ",
+			     (long long)mem_err->responder_id);
+	if (mem_err->validation_bits & CPER_MEM_VALID_TARGET_ID)
+		p += sprintf(p, "targetID: 0x%016llx ",
+			     (long long)mem_err->responder_id);
+	if (p > pvt->other_detail)
+		*(p - 1) = '\0';
 
 	edac_raw_mc_handle_error(type, mci, e);
 }

commit d2a6856614fd34e36352146307a5655efbdbc14d
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Feb 15 09:06:38 2013 -0300

    ghes_edac: Improve driver's printk messages
    
    Provide a better infrastructure for printk's inside the driver:
            - use edac_dbg() for debug messages;
            - standardize the usage of pr_info();
            - provide warning about the risk of relying on this
              driver.
    
    While here, changes the size of a fake memory to 1 page. This is
    as good or as bad as 1000 pages, but it is easier for userspace to
    detect, as I don't expect that any machine implementing GHES would
    provide just 1 page available ;)
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    
    Conflicts:
            drivers/edac/ghes_edac.c

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index fb866804820c..b4acc4f2074d 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -9,12 +9,13 @@
  * Red Hat Inc. http://www.redhat.com
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <acpi/ghes.h>
 #include <linux/edac.h>
 #include <linux/dmi.h>
 #include "edac_core.h"
 
-#define GHES_PFX   "ghes_edac: "
 #define GHES_EDAC_REVISION " Ver: 1.0.0"
 
 struct ghes_edac_pvt {
@@ -27,6 +28,7 @@ static LIST_HEAD(ghes_reglist);
 static DEFINE_MUTEX(ghes_edac_lock);
 static int ghes_edac_mc_num;
 
+
 /* Memory Device - Type 17 of SMBIOS spec */
 struct memdev_dmi_entry {
 	u8 type;
@@ -98,7 +100,8 @@ static void ghes_edac_dmidecode(const struct dmi_header *dh, void *arg)
 						       dimm_fill->count, 0, 0);
 
 		if (entry->size == 0xffff) {
-			pr_info(GHES_PFX "Can't get dimm size\n");
+			pr_info("Can't get DIMM%i size\n",
+				dimm_fill->count);
 			dimm->nr_pages = MiB_TO_PAGES(32);/* Unknown */
 		} else if (entry->size == 0x7fff) {
 			dimm->nr_pages = MiB_TO_PAGES(entry->extended_size);
@@ -163,11 +166,11 @@ static void ghes_edac_dmidecode(const struct dmi_header *dh, void *arg)
 		 */
 
 		if (dimm->nr_pages) {
-			pr_info(GHES_PFX "DIMM%i: %s size = %d MB%s\n",
+			edac_dbg(1, "DIMM%i: %s size = %d MB%s\n",
 				dimm_fill->count, memory_type[dimm->mtype],
 				PAGES_TO_MiB(dimm->nr_pages),
 				(dimm->edac_mode != EDAC_NONE) ? "(ECC)" : "");
-			pr_info(GHES_PFX "\ttype %d, detail 0x%02x, width %d(total %d)\n",
+			edac_dbg(2, "\ttype %d, detail 0x%02x, width %d(total %d)\n",
 				entry->memory_type, entry->type_detail,
 				entry->total_width, entry->data_width);
 		}
@@ -261,12 +264,10 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 	 * to avoid duplicated memory controller numbers
 	 */
 	mutex_lock(&ghes_edac_lock);
-	pr_info("ghes_edac#%d: allocating space for %d dimms\n",
-		ghes_edac_mc_num, num_dimm);
 	mci = edac_mc_alloc(ghes_edac_mc_num, ARRAY_SIZE(layers), layers,
 			    sizeof(*pvt));
 	if (!mci) {
-		pr_info(GHES_PFX "Can't allocate memory for EDAC data\n");
+		pr_info("Can't allocate memory for EDAC data\n");
 		mutex_unlock(&ghes_edac_lock);
 		return -ENOMEM;
 	}
@@ -286,6 +287,22 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 	mci->ctl_name = "ghes_edac";
 	mci->dev_name = "ghes";
 
+	if (!ghes_edac_mc_num) {
+		if (!fake) {
+			pr_info("This EDAC driver relies on BIOS to enumerate memory and get error reports.\n");
+			pr_info("Unfortunately, not all BIOSes reflect the memory layout correctly.\n");
+			pr_info("So, the end result of using this driver varies from vendor to vendor.\n");
+			pr_info("If you find incorrect reports, please contact your hardware vendor\n");
+			pr_info("to correct its BIOS.\n");
+			pr_info("This system has %d DIMM sockets.\n",
+				num_dimm);
+		} else {
+			pr_info("This system has a very crappy BIOS: It doesn't even list the DIMMS.\n");
+			pr_info("Its SMBIOS info is wrong. It is doubtful that the error report would\n");
+			pr_info("work on such system. Use this driver with caution\n");
+		}
+	}
+
 	if (!fake) {
 		/*
 		 * Fill DIMM info from DMI for the memory controller #0
@@ -304,8 +321,7 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 		struct dimm_info *dimm = EDAC_DIMM_PTR(mci->layers, mci->dimms,
 						       mci->n_layers, 0, 0, 0);
 
-		pr_info(GHES_PFX "Crappy BIOS detected. Faking DIMM EDAC data\n");
-		dimm->nr_pages = 1000;
+		dimm->nr_pages = 1;
 		dimm->grain = 128;
 		dimm->mtype = MEM_UNKNOWN;
 		dimm->dtype = DEV_UNKNOWN;
@@ -314,7 +330,7 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 
 	rc = edac_mc_add_mc(mci);
 	if (rc < 0) {
-		pr_info(GHES_PFX "Can't register at EDAC core\n");
+		pr_info("Can't register at EDAC core\n");
 		edac_mc_free(mci);
 		mutex_unlock(&ghes_edac_lock);
 		return -ENODEV;

commit 5ee726db521fddf991f261e5c45e04a7d2bf1bc1
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Feb 15 08:45:00 2013 -0300

    ghes_edac: Don't credit the same memory dimm twice
    
    On my tests on a 4xE5-4650 CPU's system, the GHES
    EDAC driver is called twice. As the SMBIOS DMI enumeration
    call will seek for the entire DIMM sockets in the system, on
    this machine, equipped with 128 GB of RAM, the memory is
    displayed twice:
    
              +-----------------------+
              |    mc0    |    mc1    |
    ----------+-----------------------+
    memory45: |  8192 MB  |  8192 MB  |
    memory44: |     0 MB  |     0 MB  |
    ----------+-----------------------+
    memory43: |     0 MB  |     0 MB  |
    memory42: |  8192 MB  |  8192 MB  |
    ----------+-----------------------+
    memory41: |     0 MB  |     0 MB  |
    memory40: |     0 MB  |     0 MB  |
    ----------+-----------------------+
    memory39: |  8192 MB  |  8192 MB  |
    memory38: |     0 MB  |     0 MB  |
    ----------+-----------------------+
    memory37: |     0 MB  |     0 MB  |
    memory36: |  8192 MB  |  8192 MB  |
    ----------+-----------------------+
    memory35: |     0 MB  |     0 MB  |
    memory34: |     0 MB  |     0 MB  |
    ----------+-----------------------+
    memory33: |  8192 MB  |  8192 MB  |
    memory32: |     0 MB  |     0 MB  |
    ----------+-----------------------+
    memory31: |     0 MB  |     0 MB  |
    memory30: |  8192 MB  |  8192 MB  |
    ----------+-----------------------+
    memory29: |     0 MB  |     0 MB  |
    memory28: |     0 MB  |     0 MB  |
    ----------+-----------------------+
    memory27: |  8192 MB  |  8192 MB  |
    memory26: |     0 MB  |     0 MB  |
    ----------+-----------------------+
    memory25: |     0 MB  |     0 MB  |
    memory24: |  8192 MB  |  8192 MB  |
    ----------+-----------------------+
    memory23: |     0 MB  |     0 MB  |
    memory22: |     0 MB  |     0 MB  |
    ----------+-----------------------+
    memory21: |  8192 MB  |  8192 MB  |
    memory20: |     0 MB  |     0 MB  |
    ----------+-----------------------+
    memory19: |     0 MB  |     0 MB  |
    memory18: |  8192 MB  |  8192 MB  |
    ----------+-----------------------+
    memory17: |     0 MB  |     0 MB  |
    memory16: |     0 MB  |     0 MB  |
    ----------+-----------------------+
    memory15: |  8192 MB  |  8192 MB  |
    memory14: |     0 MB  |     0 MB  |
    ----------+-----------------------+
    memory13: |     0 MB  |     0 MB  |
    memory12: |  8192 MB  |  8192 MB  |
    ----------+-----------------------+
    memory11: |     0 MB  |     0 MB  |
    memory10: |     0 MB  |     0 MB  |
    ----------+-----------------------+
    memory9:  |  8192 MB  |  8192 MB  |
    memory8:  |     0 MB  |     0 MB  |
    ----------+-----------------------+
    memory7:  |     0 MB  |     0 MB  |
    memory6:  |  8192 MB  |  8192 MB  |
    ----------+-----------------------+
    memory5:  |     0 MB  |     0 MB  |
    memory4:  |     0 MB  |     0 MB  |
    ----------+-----------------------+
    memory3:  |  8192 MB  |  8192 MB  |
    memory2:  |     0 MB  |     0 MB  |
    ----------+-----------------------+
    memory1:  |     0 MB  |     0 MB  |
    memory0:  |  8192 MB  |  8192 MB  |
    ----------+-----------------------+
    
    Total sum of 256 GB.
    
    As there's no reliable way to credit DIMMS to the right memory
    controller, just put everything on memory controller 0 (with should
    always exist).
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 22ac29e4733f..fb866804820c 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -287,10 +287,19 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 	mci->dev_name = "ghes";
 
 	if (!fake) {
-		/* Fill DIMM info from DMI */
-		dimm_fill.count = 0;
-		dimm_fill.mci = mci;
-		dmi_walk(ghes_edac_dmidecode, &dimm_fill);
+		/*
+		 * Fill DIMM info from DMI for the memory controller #0
+		 *
+		 * Keep it in blank for the other memory controllers, as
+		 * there's no reliable way to properly credit each DIMM to
+		 * the memory controller, as different BIOSes fill the
+		 * DMI bank location fields on different ways
+		 */
+		if (!ghes_edac_mc_num) {
+			dimm_fill.count = 0;
+			dimm_fill.mci = mci;
+			dmi_walk(ghes_edac_dmidecode, &dimm_fill);
+		}
 	} else {
 		struct dimm_info *dimm = EDAC_DIMM_PTR(mci->layers, mci->dimms,
 						       mci->n_layers, 0, 0, 0);

commit 32fa1f53c2daf9f55f17ff883b4297f86095b09c
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Feb 14 09:11:08 2013 -0300

    ghes_edac: do a better job of filling EDAC DIMM info
    
    Instead of just faking a random value for the DIMM data, get
    the information that it is available via DMI table.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index 0853f450d2c1..22ac29e4733f 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -11,6 +11,7 @@
 
 #include <acpi/ghes.h>
 #include <linux/edac.h>
+#include <linux/dmi.h>
 #include "edac_core.h"
 
 #define GHES_PFX   "ghes_edac: "
@@ -26,6 +27,155 @@ static LIST_HEAD(ghes_reglist);
 static DEFINE_MUTEX(ghes_edac_lock);
 static int ghes_edac_mc_num;
 
+/* Memory Device - Type 17 of SMBIOS spec */
+struct memdev_dmi_entry {
+	u8 type;
+	u8 length;
+	u16 handle;
+	u16 phys_mem_array_handle;
+	u16 mem_err_info_handle;
+	u16 total_width;
+	u16 data_width;
+	u16 size;
+	u8 form_factor;
+	u8 device_set;
+	u8 device_locator;
+	u8 bank_locator;
+	u8 memory_type;
+	u16 type_detail;
+	u16 speed;
+	u8 manufacturer;
+	u8 serial_number;
+	u8 asset_tag;
+	u8 part_number;
+	u8 attributes;
+	u32 extended_size;
+	u16 conf_mem_clk_speed;
+} __attribute__((__packed__));
+
+struct ghes_edac_dimm_fill {
+	struct mem_ctl_info *mci;
+	unsigned count;
+};
+
+char *memory_type[] = {
+	[MEM_EMPTY] = "EMPTY",
+	[MEM_RESERVED] = "RESERVED",
+	[MEM_UNKNOWN] = "UNKNOWN",
+	[MEM_FPM] = "FPM",
+	[MEM_EDO] = "EDO",
+	[MEM_BEDO] = "BEDO",
+	[MEM_SDR] = "SDR",
+	[MEM_RDR] = "RDR",
+	[MEM_DDR] = "DDR",
+	[MEM_RDDR] = "RDDR",
+	[MEM_RMBS] = "RMBS",
+	[MEM_DDR2] = "DDR2",
+	[MEM_FB_DDR2] = "FB_DDR2",
+	[MEM_RDDR2] = "RDDR2",
+	[MEM_XDR] = "XDR",
+	[MEM_DDR3] = "DDR3",
+	[MEM_RDDR3] = "RDDR3",
+};
+
+static void ghes_edac_count_dimms(const struct dmi_header *dh, void *arg)
+{
+	int *num_dimm = arg;
+
+	if (dh->type == DMI_ENTRY_MEM_DEVICE)
+		(*num_dimm)++;
+}
+
+static void ghes_edac_dmidecode(const struct dmi_header *dh, void *arg)
+{
+	struct ghes_edac_dimm_fill *dimm_fill = arg;
+	struct mem_ctl_info *mci = dimm_fill->mci;
+
+	if (dh->type == DMI_ENTRY_MEM_DEVICE) {
+		struct memdev_dmi_entry *entry = (struct memdev_dmi_entry *)dh;
+		struct dimm_info *dimm = EDAC_DIMM_PTR(mci->layers, mci->dimms,
+						       mci->n_layers,
+						       dimm_fill->count, 0, 0);
+
+		if (entry->size == 0xffff) {
+			pr_info(GHES_PFX "Can't get dimm size\n");
+			dimm->nr_pages = MiB_TO_PAGES(32);/* Unknown */
+		} else if (entry->size == 0x7fff) {
+			dimm->nr_pages = MiB_TO_PAGES(entry->extended_size);
+		} else {
+			if (entry->size & 1 << 15)
+				dimm->nr_pages = MiB_TO_PAGES((entry->size &
+							       0x7fff) << 10);
+			else
+				dimm->nr_pages = MiB_TO_PAGES(entry->size);
+		}
+
+		switch (entry->memory_type) {
+		case 0x12:
+			if (entry->type_detail & 1 << 13)
+				dimm->mtype = MEM_RDDR;
+			else
+				dimm->mtype = MEM_DDR;
+			break;
+		case 0x13:
+			if (entry->type_detail & 1 << 13)
+				dimm->mtype = MEM_RDDR2;
+			else
+				dimm->mtype = MEM_DDR2;
+			break;
+		case 0x14:
+			dimm->mtype = MEM_FB_DDR2;
+			break;
+		case 0x18:
+			if (entry->type_detail & 1 << 13)
+				dimm->mtype = MEM_RDDR3;
+			else
+				dimm->mtype = MEM_DDR3;
+			break;
+		default:
+			if (entry->type_detail & 1 << 6)
+				dimm->mtype = MEM_RMBS;
+			else if ((entry->type_detail & ((1 << 7) | (1 << 13)))
+				 == ((1 << 7) | (1 << 13)))
+				dimm->mtype = MEM_RDR;
+			else if (entry->type_detail & 1 << 7)
+				dimm->mtype = MEM_SDR;
+			else if (entry->type_detail & 1 << 9)
+				dimm->mtype = MEM_EDO;
+			else
+				dimm->mtype = MEM_UNKNOWN;
+		}
+
+		/*
+		 * Actually, we can only detect if the memory has bits for
+		 * checksum or not
+		 */
+		if (entry->total_width == entry->data_width)
+			dimm->edac_mode = EDAC_NONE;
+		else
+			dimm->edac_mode = EDAC_SECDED;
+
+		dimm->dtype = DEV_UNKNOWN;
+		dimm->grain = 128;		/* Likely, worse case */
+
+		/*
+		 * FIXME: It shouldn't be hard to also fill the DIMM labels
+		 */
+
+		if (dimm->nr_pages) {
+			pr_info(GHES_PFX "DIMM%i: %s size = %d MB%s\n",
+				dimm_fill->count, memory_type[dimm->mtype],
+				PAGES_TO_MiB(dimm->nr_pages),
+				(dimm->edac_mode != EDAC_NONE) ? "(ECC)" : "");
+			pr_info(GHES_PFX "\ttype %d, detail 0x%02x, width %d(total %d)\n",
+				entry->memory_type, entry->type_detail,
+				entry->total_width, entry->data_width);
+		}
+
+		dimm_fill->count++;
+	}
+}
+
 void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
 				struct cper_sec_mem_err *mem_err)
 {
@@ -86,15 +236,24 @@ EXPORT_SYMBOL_GPL(ghes_edac_report_mem_error);
 
 int ghes_edac_register(struct ghes *ghes, struct device *dev)
 {
-	int rc;
+	bool fake = false;
+	int rc, num_dimm = 0;
 	struct mem_ctl_info *mci;
 	struct edac_mc_layer layers[1];
-	struct csrow_info *csrow;
-	struct dimm_info *dimm;
 	struct ghes_edac_pvt *pvt;
+	struct ghes_edac_dimm_fill dimm_fill;
+
+	/* Get the number of DIMMs */
+	dmi_walk(ghes_edac_count_dimms, &num_dimm);
+
+	/* Check if we've got a bogus BIOS */
+	if (num_dimm == 0) {
+		fake = true;
+		num_dimm = 1;
+	}
 
 	layers[0].type = EDAC_MC_LAYER_ALL_MEM;
-	layers[0].size = 1;
+	layers[0].size = num_dimm;
 	layers[0].is_virt_csrow = true;
 
 	/*
@@ -102,6 +261,8 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 	 * to avoid duplicated memory controller numbers
 	 */
 	mutex_lock(&ghes_edac_lock);
+	pr_info("ghes_edac#%d: allocating space for %d dimms\n",
+		ghes_edac_mc_num, num_dimm);
 	mci = edac_mc_alloc(ghes_edac_mc_num, ARRAY_SIZE(layers), layers,
 			    sizeof(*pvt));
 	if (!mci) {
@@ -125,15 +286,22 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 	mci->ctl_name = "ghes_edac";
 	mci->dev_name = "ghes";
 
-	csrow = mci->csrows[0];
-	dimm = csrow->channels[0]->dimm;
+	if (!fake) {
+		/* Fill DIMM info from DMI */
+		dimm_fill.count = 0;
+		dimm_fill.mci = mci;
+		dmi_walk(ghes_edac_dmidecode, &dimm_fill);
+	} else {
+		struct dimm_info *dimm = EDAC_DIMM_PTR(mci->layers, mci->dimms,
+						       mci->n_layers, 0, 0, 0);
 
-	/* FIXME: FAKE DATA */
-	dimm->nr_pages = 1000;
-	dimm->grain = 128;
-	dimm->mtype = MEM_UNKNOWN;
-	dimm->dtype = DEV_UNKNOWN;
-	dimm->edac_mode = EDAC_SECDED;
+		pr_info(GHES_PFX "Crappy BIOS detected. Faking DIMM EDAC data\n");
+		dimm->nr_pages = 1000;
+		dimm->grain = 128;
+		dimm->mtype = MEM_UNKNOWN;
+		dimm->dtype = DEV_UNKNOWN;
+		dimm->edac_mode = EDAC_SECDED;
+	}
 
 	rc = edac_mc_add_mc(mci);
 	if (rc < 0) {

commit f04c62a7036a4b8490b224a9ad1be4378a3acf4d
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Feb 15 06:36:27 2013 -0300

    ghes_edac: add support for reporting errors via EDAC
    
    Now that the EDAC core is capable of just forward the errors via
    the userspace API, add a report mechanism for the GHES errors.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
index d8e54b496e0f..0853f450d2c1 100644
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@ -27,8 +27,60 @@ static DEFINE_MUTEX(ghes_edac_lock);
 static int ghes_edac_mc_num;
 
 void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
-                               struct cper_sec_mem_err *mem_err)
+				struct cper_sec_mem_err *mem_err)
 {
+	enum hw_event_mc_err_type type;
+	struct edac_raw_error_desc *e;
+	struct mem_ctl_info *mci;
+	struct ghes_edac_pvt *pvt = NULL;
+
+	list_for_each_entry(pvt, &ghes_reglist, list) {
+		if (ghes == pvt->ghes)
+			break;
+	}
+	if (!pvt) {
+		pr_err("Internal error: Can't find EDAC structure\n");
+		return;
+	}
+	mci = pvt->mci;
+	e = &mci->error_desc;
+
+	/* Cleans the error report buffer */
+	memset(e, 0, sizeof (*e));
+	e->error_count = 1;
+	e->msg = "APEI";
+	strcpy(e->label, "unknown");
+	e->other_detail = "";
+
+	if (mem_err->validation_bits & CPER_MEM_VALID_PHYSICAL_ADDRESS) {
+		e->page_frame_number = mem_err->physical_addr >> PAGE_SHIFT;
+		e->offset_in_page = mem_err->physical_addr & ~PAGE_MASK;
+		e->grain = ~(mem_err->physical_addr_mask & ~PAGE_MASK);
+	}
+
+	switch (sev) {
+	case GHES_SEV_CORRECTED:
+		type = HW_EVENT_ERR_CORRECTED;
+		break;
+	case GHES_SEV_RECOVERABLE:
+		type = HW_EVENT_ERR_UNCORRECTED;
+		break;
+	case GHES_SEV_PANIC:
+		type = HW_EVENT_ERR_FATAL;
+		break;
+	default:
+	case GHES_SEV_NO:
+		type = HW_EVENT_ERR_INFO;
+	}
+
+	sprintf(e->location,
+		"node:%d card:%d module:%d bank:%d device:%d row: %d column:%d bit_pos:%d",
+		mem_err->node, mem_err->card, mem_err->module,
+		mem_err->bank, mem_err->device, mem_err->row, mem_err->column,
+		mem_err->bit_pos);
+	edac_dbg(3, "error at location %s\n", e->location);
+
+	edac_raw_mc_handle_error(type, mci, e);
 }
 EXPORT_SYMBOL_GPL(ghes_edac_report_mem_error);
 
@@ -60,7 +112,7 @@ int ghes_edac_register(struct ghes *ghes, struct device *dev)
 
 	pvt = mci->pvt_info;
 	memset(pvt, 0, sizeof(*pvt));
-        list_add_tail(&pvt->list, &ghes_reglist);
+	list_add_tail(&pvt->list, &ghes_reglist);
 	pvt->ghes = ghes;
 	pvt->mci  = mci;
 	mci->pdev = dev;

commit 77c5f5d2f212e1963063e427fc57c44bf6eae9fb
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Feb 15 06:11:57 2013 -0300

    ghes_edac: Register at EDAC core the BIOS report
    
    Register GHES at EDAC MC core, in order to avoid other
    drivers to also handle errors and mangle with error data.
    
    The edac core will warrant that just one driver will be used,
    so the first one to register (BIOS first) will be the one that
    will be reporting the hardware errors.
    
    For now, the EDAC driver does nothing but to register at the
    EDAC core, preventing the hardware-driven mechanism to
    interfere with GHES.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/ghes_edac.c b/drivers/edac/ghes_edac.c
new file mode 100644
index 000000000000..d8e54b496e0f
--- /dev/null
+++ b/drivers/edac/ghes_edac.c
@@ -0,0 +1,114 @@
+/*
+ * GHES/EDAC Linux driver
+ *
+ * This file may be distributed under the terms of the GNU General Public
+ * License version 2.
+ *
+ * Copyright (c) 2013 by Mauro Carvalho Chehab <mchehab@redhat.com>
+ *
+ * Red Hat Inc. http://www.redhat.com
+ */
+
+#include <acpi/ghes.h>
+#include <linux/edac.h>
+#include "edac_core.h"
+
+#define GHES_PFX   "ghes_edac: "
+#define GHES_EDAC_REVISION " Ver: 1.0.0"
+
+struct ghes_edac_pvt {
+	struct list_head list;
+	struct ghes *ghes;
+	struct mem_ctl_info *mci;
+};
+
+static LIST_HEAD(ghes_reglist);
+static DEFINE_MUTEX(ghes_edac_lock);
+static int ghes_edac_mc_num;
+
+void ghes_edac_report_mem_error(struct ghes *ghes, int sev,
+                               struct cper_sec_mem_err *mem_err)
+{
+}
+EXPORT_SYMBOL_GPL(ghes_edac_report_mem_error);
+
+int ghes_edac_register(struct ghes *ghes, struct device *dev)
+{
+	int rc;
+	struct mem_ctl_info *mci;
+	struct edac_mc_layer layers[1];
+	struct csrow_info *csrow;
+	struct dimm_info *dimm;
+	struct ghes_edac_pvt *pvt;
+
+	layers[0].type = EDAC_MC_LAYER_ALL_MEM;
+	layers[0].size = 1;
+	layers[0].is_virt_csrow = true;
+
+	/*
+	 * We need to serialize edac_mc_alloc() and edac_mc_add_mc(),
+	 * to avoid duplicated memory controller numbers
+	 */
+	mutex_lock(&ghes_edac_lock);
+	mci = edac_mc_alloc(ghes_edac_mc_num, ARRAY_SIZE(layers), layers,
+			    sizeof(*pvt));
+	if (!mci) {
+		pr_info(GHES_PFX "Can't allocate memory for EDAC data\n");
+		mutex_unlock(&ghes_edac_lock);
+		return -ENOMEM;
+	}
+
+	pvt = mci->pvt_info;
+	memset(pvt, 0, sizeof(*pvt));
+        list_add_tail(&pvt->list, &ghes_reglist);
+	pvt->ghes = ghes;
+	pvt->mci  = mci;
+	mci->pdev = dev;
+
+	mci->mtype_cap = MEM_FLAG_EMPTY;
+	mci->edac_ctl_cap = EDAC_FLAG_NONE;
+	mci->edac_cap = EDAC_FLAG_NONE;
+	mci->mod_name = "ghes_edac.c";
+	mci->mod_ver = GHES_EDAC_REVISION;
+	mci->ctl_name = "ghes_edac";
+	mci->dev_name = "ghes";
+
+	csrow = mci->csrows[0];
+	dimm = csrow->channels[0]->dimm;
+
+	/* FIXME: FAKE DATA */
+	dimm->nr_pages = 1000;
+	dimm->grain = 128;
+	dimm->mtype = MEM_UNKNOWN;
+	dimm->dtype = DEV_UNKNOWN;
+	dimm->edac_mode = EDAC_SECDED;
+
+	rc = edac_mc_add_mc(mci);
+	if (rc < 0) {
+		pr_info(GHES_PFX "Can't register at EDAC core\n");
+		edac_mc_free(mci);
+		mutex_unlock(&ghes_edac_lock);
+		return -ENODEV;
+	}
+
+	ghes_edac_mc_num++;
+	mutex_unlock(&ghes_edac_lock);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ghes_edac_register);
+
+void ghes_edac_unregister(struct ghes *ghes)
+{
+	struct mem_ctl_info *mci;
+	struct ghes_edac_pvt *pvt;
+
+	list_for_each_entry(pvt, &ghes_reglist, list) {
+		if (ghes == pvt->ghes) {
+			mci = pvt->mci;
+			edac_mc_del_mc(mci->pdev);
+			edac_mc_free(mci);
+			list_del(&pvt->list);
+		}
+	}
+}
+EXPORT_SYMBOL_GPL(ghes_edac_unregister);
