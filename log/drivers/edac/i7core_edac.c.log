commit 23ba710a0864108910c7531dc4c73ef65eca5568
Author: Tony Luck <tony.luck@intel.com>
Date:   Fri Feb 14 14:27:17 2020 -0800

    x86/mce: Fix all mce notifiers to update the mce->kflags bitmask
    
    If the handler took any action to log or deal with the error, set a bit
    in mce->kflags so that the default handler on the end of the machine
    check chain can see what has been done.
    
    Get rid of NOTIFY_STOP returns. Make the EDAC and dev-mcelog handlers
    skip over errors already processed by CEC.
    
    Signed-off-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Tested-by: Tony Luck <tony.luck@intel.com>
    Link: https://lkml.kernel.org/r/20200214222720.13168-5-tony.luck@intel.com

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index b3135b208f9a..5860ca41185c 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1815,7 +1815,7 @@ static int i7core_mce_check_error(struct notifier_block *nb, unsigned long val,
 	struct mem_ctl_info *mci;
 
 	i7_dev = get_i7core_dev(mce->socketid);
-	if (!i7_dev)
+	if (!i7_dev || (mce->kflags & MCE_HANDLED_CEC))
 		return NOTIFY_DONE;
 
 	mci = i7_dev->mci;
@@ -1834,7 +1834,8 @@ static int i7core_mce_check_error(struct notifier_block *nb, unsigned long val,
 	i7core_check_error(mci, mce);
 
 	/* Advise mcelog that the errors were handled */
-	return NOTIFY_STOP;
+	mce->kflags |= MCE_HANDLED_EDAC;
+	return NOTIFY_OK;
 }
 
 static struct notifier_block i7_mce_dec = {

commit bc9ad9e40dbc4c8874e806345df393a9cfeadad3
Author: Robert Richter <rrichter@marvell.com>
Date:   Wed Nov 6 09:33:02 2019 +0000

    EDAC: Replace EDAC_DIMM_PTR() macro with edac_get_dimm() function
    
    The EDAC_DIMM_PTR() macro takes 3 arguments from struct mem_ctl_info.
    Clean up this interface to only pass the mci struct and replace this
    macro with a new function edac_get_dimm().
    
    Also introduce an edac_get_dimm_by_index() function for later use.
    This allows it to get a DIMM pointer only by a given index. This can
    be useful if the DIMM's position within the layers of the memory
    controller or the exact size of the layers are unknown.
    
    Small style changes made for some hunks after applying the semantic
    patch.
    
    Semantic patch used:
    
    @@ expression mci, a, b,c; @@
    
    -EDAC_DIMM_PTR(mci->layers, mci->dimms, mci->n_layers, a, b, c)
    +edac_get_dimm(mci, a, b, c)
    
     [ bp: Touchups. ]
    
    Signed-off-by: Robert Richter <rrichter@marvell.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: "linux-edac@vger.kernel.org" <linux-edac@vger.kernel.org>
    Cc: James Morse <james.morse@arm.com>
    Cc: Jason Baron <jbaron@akamai.com>
    Cc: Qiuxu Zhuo <qiuxu.zhuo@intel.com>
    Cc: Tero Kristo <t-kristo@ti.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Link: https://lkml.kernel.org/r/20191106093239.25517-2-rrichter@marvell.com

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index a71cca6eeb33..b3135b208f9a 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -585,8 +585,7 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 			if (!DIMM_PRESENT(dimm_dod[j]))
 				continue;
 
-			dimm = EDAC_DIMM_PTR(mci->layers, mci->dimms, mci->n_layers,
-				       i, j, 0);
+			dimm = edac_get_dimm(mci, i, j, 0);
 			banks = numbank(MC_DOD_NUMBANK(dimm_dod[j]));
 			ranks = numrank(MC_DOD_NUMRANK(dimm_dod[j]));
 			rows = numrow(MC_DOD_NUMROW(dimm_dod[j]));

commit 122375508ba37bdb0a99bf9c78f54500368aad2a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:19 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 172
    
    Based on 1 normalized pattern(s):
    
      this file may be distributed under the terms of the gnu general
      public license version 2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 9 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.395589349@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 40297550313a..a71cca6eeb33 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* Intel i7 core/Nehalem Memory Controller kernel module
  *
  * This driver supports the memory controllers found on the Intel
@@ -5,9 +6,6 @@
  * Xeon 55xx and Xeon 56xx also known as Nehalem, Nehalem-EP, Lynnfield
  * and Westmere-EP.
  *
- * This file may be distributed under the terms of the
- * GNU General Public License version 2 only.
- *
  * Copyright (c) 2009-2010 by:
  *	 Mauro Carvalho Chehab
  *

commit 1722bc0e8c2f6f798948ade79c6678e15656a3e5
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Nov 9 13:37:57 2018 +0000

    EDAC: Fix indentation issues in several EDAC drivers
    
    Replace spaces with tabs and insert missing indentation.
    
     [ bp: Rewrite commit message. ]
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    CC: "Arvind R." <arvino55@gmail.com>
    CC: Mark Gross <mark.gross@intel.com>
    CC: Mauro Carvalho Chehab <mchehab@kernel.org>
    CC: Ranganathan Desikan <ravi@jetztechnologies.com>
    CC: kernel-janitors@vger.kernel.org
    CC: linux-edac <linux-edac@vger.kernel.org>
    Link: http://lkml.kernel.org/r/20181109133757.21471-1-colin.king@canonical.com

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 9ef448fef12f..40297550313a 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -724,7 +724,7 @@ static ssize_t i7core_inject_type_store(struct device *dev,
 					const char *data, size_t count)
 {
 	struct mem_ctl_info *mci = to_mci(dev);
-struct i7core_pvt *pvt = mci->pvt_info;
+	struct i7core_pvt *pvt = mci->pvt_info;
 	unsigned long value;
 	int rc;
 

commit 432de7fd7630c84ad24f1c2acd1e3bb4ce3741ca
Author: Tony Luck <tony.luck@intel.com>
Date:   Fri Sep 28 14:39:34 2018 -0700

    EDAC, {i7core,sb,skx}_edac: Fix uncorrected error counting
    
    The count of errors is picked up from bits 52:38 of the machine check
    bank status register. But this is the count of *corrected* errors. If an
    uncorrected error is being logged, the h/w sets this field to 0. Which
    means that when edac_mc_handle_error() is called, the EDAC core will
    carefully add zero to the appropriate uncorrected error counts.
    
    Signed-off-by: Tony Luck <tony.luck@intel.com>
    [ Massage commit message. ]
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: stable@vger.kernel.org
    Cc: Aristeu Rozanski <aris@redhat.com>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: Qiuxu Zhuo <qiuxu.zhuo@intel.com>
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Link: http://lkml.kernel.org/r/20180928213934.19890-1-tony.luck@intel.com

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 943aab62dea1..9ef448fef12f 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1711,6 +1711,7 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 	u32 errnum = find_first_bit(&error, 32);
 
 	if (uncorrected_error) {
+		core_err_cnt = 1;
 		if (ripv)
 			tp_event = HW_EVENT_ERR_FATAL;
 		else

commit 0751736905710e20130e70f33cb40014af0e922e
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Tue Sep 25 02:04:03 2018 +0000

    EDAC, i7core: Remove set but not used variable pvt
    
    Remove the unused local variable pvt:
    
      drivers/edac/i7core_edac.c: In function 'i7core_mce_check_error':
      drivers/edac/i7core_edac.c:1818:21: warning: variable 'pvt' set but not used \
              [-Wunused-but-set-variable]
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Link: http://lkml.kernel.org/r/1537841043-108267-1-git-send-email-yuehaibing@huawei.com

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index bd65f573e381..943aab62dea1 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1815,14 +1815,12 @@ static int i7core_mce_check_error(struct notifier_block *nb, unsigned long val,
 	struct mce *mce = (struct mce *)data;
 	struct i7core_dev *i7_dev;
 	struct mem_ctl_info *mci;
-	struct i7core_pvt *pvt;
 
 	i7_dev = get_i7core_dev(mce->socketid);
 	if (!i7_dev)
 		return NOTIFY_DONE;
 
 	mci = i7_dev->mci;
-	pvt = mci->pvt_info;
 
 	/*
 	 * Just let mcelog handle it if the error is

commit 6f6da136046294a1e8d2944336eb97412751f653
Author: Qiuxu Zhuo <qiuxu.zhuo@intel.com>
Date:   Tue Sep 18 17:34:33 2018 -0700

    EDAC: Correct DIMM capacity unit symbol
    
    The {i3200|i7core|sb|skx}_edac drivers show DIMM capacity using the
    wrong unit symbol: 'Mb' - megabit. Fix them by replacing 'Mb' with
    'MiB' - mebibyte.
    
    [Tony: These are all "edac_dbg()" messages, so this won't break scripts
           that parse console logs.]
    
    Signed-off-by: Qiuxu Zhuo <qiuxu.zhuo@intel.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Aristeu Rozanski <aris@redhat.com>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: linux-edac@vger.kernel.org
    Link: https://lkml.kernel.org/r/20180919003433.16475-1-tony.luck@intel.com

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 8e120bf60624..bd65f573e381 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -597,7 +597,7 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 			/* DDR3 has 8 I/O banks */
 			size = (rows * cols * banks * ranks) >> (20 - 3);
 
-			edac_dbg(0, "\tdimm %d %d Mb offset: %x, bank: %d, rank: %d, row: %#x, col: %#x\n",
+			edac_dbg(0, "\tdimm %d %d MiB offset: %x, bank: %d, rank: %d, row: %#x, col: %#x\n",
 				 j, size,
 				 RANKOFFSET(dimm_dod[j]),
 				 banks, ranks, rows, cols);

commit 6c974d4dfafe5e9ee754f2a6fba0eb1864f1649e
Author: Johan Hovold <johan@kernel.org>
Date:   Tue Jun 12 14:43:35 2018 +0200

    EDAC, i7core: Fix memleaks and use-after-free on probe and remove
    
    Make sure to free and deregister the addrmatch and chancounts devices
    allocated during probe in all error paths. Also fix use-after-free in a
    probe error path and in the remove success path where the devices were
    being put before before deregistration.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Fixes: 356f0a30860d ("i7core_edac: change the mem allocation scheme to make Documentation/kobject.txt happy")
    Link: http://lkml.kernel.org/r/20180612124335.6420-2-johan@kernel.org
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 8ed4dd9c571b..8e120bf60624 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1177,15 +1177,14 @@ static int i7core_create_sysfs_devices(struct mem_ctl_info *mci)
 
 	rc = device_add(pvt->addrmatch_dev);
 	if (rc < 0)
-		return rc;
+		goto err_put_addrmatch;
 
 	if (!pvt->is_registered) {
 		pvt->chancounts_dev = kzalloc(sizeof(*pvt->chancounts_dev),
 					      GFP_KERNEL);
 		if (!pvt->chancounts_dev) {
-			put_device(pvt->addrmatch_dev);
-			device_del(pvt->addrmatch_dev);
-			return -ENOMEM;
+			rc = -ENOMEM;
+			goto err_del_addrmatch;
 		}
 
 		pvt->chancounts_dev->type = &all_channel_counts_type;
@@ -1199,9 +1198,18 @@ static int i7core_create_sysfs_devices(struct mem_ctl_info *mci)
 
 		rc = device_add(pvt->chancounts_dev);
 		if (rc < 0)
-			return rc;
+			goto err_put_chancounts;
 	}
 	return 0;
+
+err_put_chancounts:
+	put_device(pvt->chancounts_dev);
+err_del_addrmatch:
+	device_del(pvt->addrmatch_dev);
+err_put_addrmatch:
+	put_device(pvt->addrmatch_dev);
+
+	return rc;
 }
 
 static void i7core_delete_sysfs_devices(struct mem_ctl_info *mci)
@@ -1211,11 +1219,11 @@ static void i7core_delete_sysfs_devices(struct mem_ctl_info *mci)
 	edac_dbg(1, "\n");
 
 	if (!pvt->is_registered) {
-		put_device(pvt->chancounts_dev);
 		device_del(pvt->chancounts_dev);
+		put_device(pvt->chancounts_dev);
 	}
-	put_device(pvt->addrmatch_dev);
 	device_del(pvt->addrmatch_dev);
+	put_device(pvt->addrmatch_dev);
 }
 
 /****************************************************************************

commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:03:40 2018 -0700

    treewide: kzalloc() -> kcalloc()
    
    The kzalloc() function has a 2-factor argument form, kcalloc(). This
    patch replaces cases of:
    
            kzalloc(a * b, gfp)
    
    with:
            kcalloc(a * b, gfp)
    
    as well as handling cases of:
    
            kzalloc(a * b * c, gfp)
    
    with:
    
            kzalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kzalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kzalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kzalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kzalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kzalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kzalloc
    + kcalloc
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kzalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(sizeof(THING) * C2, ...)
    |
      kzalloc(sizeof(TYPE) * C2, ...)
    |
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(C1 * C2, ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 4d0ea3563d47..8ed4dd9c571b 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -461,7 +461,7 @@ static struct i7core_dev *alloc_i7core_dev(u8 socket,
 	if (!i7core_dev)
 		return NULL;
 
-	i7core_dev->pdev = kzalloc(sizeof(*i7core_dev->pdev) * table->n_devs,
+	i7core_dev->pdev = kcalloc(table->n_devs, sizeof(*i7core_dev->pdev),
 				   GFP_KERNEL);
 	if (!i7core_dev->pdev) {
 		kfree(i7core_dev);

commit 83e548bea4e7ffd8321072c760aaae2e758ef104
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri May 4 12:38:04 2018 +0100

    EDAC, i7core: Fix spelling mistake: "redundacy" -> "redundancy"
    
    Trivial fix to spelling mistake in err string.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: kernel-janitors@vger.kernel.org
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Link: http://lkml.kernel.org/r/20180504113804.17103-1-colin.king@canonical.com
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 8c5540160a23..4d0ea3563d47 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1743,7 +1743,7 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 		err = "write parity error";
 		break;
 	case 19:
-		err = "redundacy loss";
+		err = "redundancy loss";
 		break;
 	case 20:
 		err = "reserved";

commit 75f029c3a83f3e7a1d0d928efa4fe47dd6a8a9eb
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Thu Sep 21 12:16:56 2017 +0200

    EDAC: Handle return value of kasprintf()
    
    kasprintf() can fail and we must check its return value.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Cc: linux-edac@vger.kernel.org
    [ Merged into a single patch, small formatting fixups. ]
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index c16c3b931b3d..8c5540160a23 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -2159,8 +2159,13 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 	mci->edac_ctl_cap = EDAC_FLAG_NONE;
 	mci->edac_cap = EDAC_FLAG_NONE;
 	mci->mod_name = "i7core_edac.c";
-	mci->ctl_name = kasprintf(GFP_KERNEL, "i7 core #%d",
-				  i7core_dev->socket);
+
+	mci->ctl_name = kasprintf(GFP_KERNEL, "i7 core #%d", i7core_dev->socket);
+	if (!mci->ctl_name) {
+		rc = -ENOMEM;
+		goto fail1;
+	}
+
 	mci->dev_name = pci_name(i7core_dev->pdev[0]);
 	mci->ctl_page_to_phys = NULL;
 
@@ -2214,6 +2219,8 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 
 fail0:
 	kfree(mci->ctl_name);
+
+fail1:
 	edac_mc_free(mci);
 	i7core_dev->mci = NULL;
 	return rc;

commit b2b3e7362ee7014ad9c40c925a4c27a690dbdd77
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 19 13:52:12 2017 +0530

    EDAC: Make device_type const
    
    Make these const as they are only stored in the type field of a device
    structure, which is const.
    
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Link: http://lkml.kernel.org/r/1503130946-2854-2-git-send-email-bhumirks@gmail.com
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index d36cc8498084..c16c3b931b3d 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1094,7 +1094,7 @@ static void addrmatch_release(struct device *device)
 	kfree(device);
 }
 
-static struct device_type addrmatch_type = {
+static const struct device_type addrmatch_type = {
 	.groups		= addrmatch_groups,
 	.release	= addrmatch_release,
 };
@@ -1125,7 +1125,7 @@ static void all_channel_counts_release(struct device *device)
 	kfree(device);
 }
 
-static struct device_type all_channel_counts_type = {
+static const struct device_type all_channel_counts_type = {
 	.groups		= all_channel_counts_groups,
 	.release	= all_channel_counts_release,
 };

commit c54182ec0e157988f0cafd1e8d37b68ab4210f87
Author: Borislav Petkov <bp@suse.de>
Date:   Thu Jun 29 12:00:05 2017 +0200

    EDAC: Get rid of mci->mod_ver
    
    It is a write-only variable so get rid of it.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Robert Richter <rric@kernel.org>
    Acked-by: Michal Simek <michal.simek@xilinx.com>
    Acked-by: Thor Thayer <thor.thayer@linux.intel.com>
    Acked-by: Tony Luck <tony.luck@intel.com>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: Tim Small <tim@buttersideup.com>
    Cc: Ranganathan Desikan <ravi@jetztechnologies.com>
    Cc: "Arvind R." <arvino55@gmail.com>
    Cc: Jason Baron <jbaron@akamai.com>
    Cc: "Sören Brinkmann" <soren.brinkmann@xilinx.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: David Daney <david.daney@cavium.com>
    Cc: Loc Ho <lho@apm.com>
    Cc: linux-edac@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-mips@linux-mips.org

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index ba0fa112996f..d36cc8498084 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -2159,7 +2159,6 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 	mci->edac_ctl_cap = EDAC_FLAG_NONE;
 	mci->edac_cap = EDAC_FLAG_NONE;
 	mci->mod_name = "i7core_edac.c";
-	mci->mod_ver = I7CORE_REVISION;
 	mci->ctl_name = kasprintf(GFP_KERNEL, "i7 core #%d",
 				  i7core_dev->socket);
 	mci->dev_name = pci_name(i7core_dev->pdev[0]);

commit 1c18be5a4e3ecbb40fbee015711aea6cc6467417
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Mon Jul 17 10:20:25 2017 +0200

    EDAC: Constify attribute_group structures
    
    attribute_groups are not supposed to change at runtime. All functions
    working with attribute_groups provided by <linux/sysfs.h> work with
    const attribute_group. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    CC: linux-edac@vger.kernel.org
    Link: http://lkml.kernel.org/r/776cb8265509054abd01b0b551624cc0da3b88e7.1499078335.git.arvind.yadav.cs@gmail.com
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 75ad847593b7..ba0fa112996f 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1079,7 +1079,7 @@ static struct attribute *i7core_addrmatch_attrs[] = {
 	NULL
 };
 
-static struct attribute_group addrmatch_grp = {
+static const struct attribute_group addrmatch_grp = {
 	.attrs	= i7core_addrmatch_attrs,
 };
 
@@ -1110,7 +1110,7 @@ static struct attribute *i7core_udimm_counters_attrs[] = {
 	NULL
 };
 
-static struct attribute_group all_channel_counts_grp = {
+static const struct attribute_group all_channel_counts_grp = {
 	.attrs	= i7core_udimm_counters_attrs,
 };
 

commit 9026cc82b632ed1a859935c82ed8ad65f27f2781
Author: Borislav Petkov <bp@suse.de>
Date:   Mon Jan 23 19:35:14 2017 +0100

    x86/ras, EDAC, acpi: Assign MCE notifier handlers a priority
    
    Assign all notifiers on the MCE decode chain a priority so that they get
    called in the correct order.
    
    Suggested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Yazen Ghannam <Yazen.Ghannam@amd.com>
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Link: http://lkml.kernel.org/r/20170123183514.13356-10-bp@alien8.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 69b5adead0ad..75ad847593b7 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1835,6 +1835,7 @@ static int i7core_mce_check_error(struct notifier_block *nb, unsigned long val,
 
 static struct notifier_block i7_mce_dec = {
 	.notifier_call	= i7core_mce_check_error,
+	.priority	= MCE_PRIO_EDAC,
 };
 
 struct memdev_dmi_entry {

commit 78d88e8a3d738f1ce508cd24b525d2e6cdfda1c1
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Sat Oct 29 15:16:34 2016 -0200

    edac: rename edac_core.h to edac_mc.h
    
    Now, all left at edac_core.h are at drivers/edac/edac_mc.c,
    so rename it to edac_mc.h.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 8a68a5e943ea..69b5adead0ad 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -39,7 +39,7 @@
 #include <asm/processor.h>
 #include <asm/div64.h>
 
-#include "edac_core.h"
+#include "edac_module.h"
 
 /* Static vars */
 static LIST_HEAD(i7core_edac_list);

commit 1cc3880a3c99f1be73f9024bd9db6248ffdcec70
Merge: 490e142209da 3f37a36b6282
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 16 18:44:39 2016 -0700

    Merge tag 'edac_for_4.7' of git://git.kernel.org/pub/scm/linux/kernel/git/bp/bp
    
    Pull EDAC updates from Borislav Petkov:
     "It was pretty busy in EDAC land this time:
    
       - Altera Arria10 L2 cache and On-Chip RAM ECC handling (Thor Thayer)
    
       - Remove ad-hoc buffering of MCE records in sb_edac and i7core_edac
         (Tony Luck)
    
       - Do not register sb_edac with pci_register_driver() (Tony Luck)
    
       - Add support for Skylake to ie31200_edac (Jason Baron)
    
       - Do not register amd64_edac with pci_register_driver() (Borislav
         Petkov)
    
      ... plus the usual round of cleanups and fixes all over the place"
    
    * tag 'edac_for_4.7' of git://git.kernel.org/pub/scm/linux/kernel/git/bp/bp: (25 commits)
      EDAC, amd64_edac: Drop pci_register_driver() use
      EDAC, ie31200_edac: Add Skylake support
      EDAC, sb_edac: Use cpu family/model in driver detection
      EDAC, i7core: Remove double buffering of error records
      EDAC, amd64_edac: Issue driver banner only on success
      ARM: socfpga: Initialize Arria10 OCRAM ECC on startup
      EDAC: Increment correct counter in edac_inc_ue_error()
      EDAC, sb_edac: Remove double buffering of error records
      EDAC: Fix used after kfree() error in edac_unregister_sysfs()
      EDAC, altera: Avoid unused function warnings
      EDAC, altera: Remove useless casts
      ARM: socfpga: Enable Arria10 OCRAM ECC on startup
      EDAC, altera: Add Arria10 OCRAM ECC support
      Documentation: dt: socfpga: Add Altera Arria10 OCRAM binding
      EDAC, altera: Make OCRAM ECC dependency check generic
      EDAC, altera: Add register offset for ECC Enable
      EDAC, altera: Extract error inject operations to a struct fops
      ARM: socfpga: Enable Arria10 L2 cache ECC on startup
      EDAC, altera: Add Arria10 L2 Cache ECC handling
      Documentation, dt, socfpga: Add Altera Arria10 L2 cache binding
      ...

commit 5359534505c74841dbb2c6baf41db1a395acd34d
Author: Tony Luck <tony.luck@intel.com>
Date:   Thu Apr 28 07:52:11 2016 -0700

    EDAC, i7core: Remove double buffering of error records
    
    In the bad old days the functions from x86_mce_decoder_chain could be
    called in machine check context. So we used to carefully copy them and
    defer processing until later. But in
    
      f29a7aff4bd60 ("x86/mce: Avoid potential deadlock due to printk() in MCE context")
    
    we switched the logging code to save the record in a genpool, and call
    the functions that registered to be notified later from a work queue.
    
    So drop all the double buffering and do all the work we want to do as
    soon as i7core_mce_check_error() is called.
    
    Signed-off-by: Tony Luck <tony.luck@intel.com>
    Acked-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Link: http://lkml.kernel.org/r/29ab2c370915c6e132fc5d88e7b72cb834bedbfe.1461855008.git.tony.luck@intel.com
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 01087a38da22..60e0bb53e9c9 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -271,16 +271,6 @@ struct i7core_pvt {
 
 	bool		is_registered, enable_scrub;
 
-	/* Fifo double buffers */
-	struct mce		mce_entry[MCE_LOG_LEN];
-	struct mce		mce_outentry[MCE_LOG_LEN];
-
-	/* Fifo in/out counters */
-	unsigned		mce_in, mce_out;
-
-	/* Count indicator to show errors not got */
-	unsigned		mce_overrun;
-
 	/* DCLK Frequency used for computing scrub rate */
 	int			dclk_freq;
 
@@ -1792,56 +1782,15 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
  *	i7core_check_error	Retrieve and process errors reported by the
  *				hardware. Called by the Core module.
  */
-static void i7core_check_error(struct mem_ctl_info *mci)
+static void i7core_check_error(struct mem_ctl_info *mci, struct mce *m)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
-	int i;
-	unsigned count = 0;
-	struct mce *m;
 
-	/*
-	 * MCE first step: Copy all mce errors into a temporary buffer
-	 * We use a double buffering here, to reduce the risk of
-	 * losing an error.
-	 */
-	smp_rmb();
-	count = (pvt->mce_out + MCE_LOG_LEN - pvt->mce_in)
-		% MCE_LOG_LEN;
-	if (!count)
-		goto check_ce_error;
-
-	m = pvt->mce_outentry;
-	if (pvt->mce_in + count > MCE_LOG_LEN) {
-		unsigned l = MCE_LOG_LEN - pvt->mce_in;
-
-		memcpy(m, &pvt->mce_entry[pvt->mce_in], sizeof(*m) * l);
-		smp_wmb();
-		pvt->mce_in = 0;
-		count -= l;
-		m += l;
-	}
-	memcpy(m, &pvt->mce_entry[pvt->mce_in], sizeof(*m) * count);
-	smp_wmb();
-	pvt->mce_in += count;
-
-	smp_rmb();
-	if (pvt->mce_overrun) {
-		i7core_printk(KERN_ERR, "Lost %d memory errors\n",
-			      pvt->mce_overrun);
-		smp_wmb();
-		pvt->mce_overrun = 0;
-	}
-
-	/*
-	 * MCE second step: parse errors and display
-	 */
-	for (i = 0; i < count; i++)
-		i7core_mce_output_error(mci, &pvt->mce_outentry[i]);
+	i7core_mce_output_error(mci, m);
 
 	/*
 	 * Now, let's increment CE error counts
 	 */
-check_ce_error:
 	if (!pvt->is_registered)
 		i7core_udimm_check_mc_ecc_err(mci);
 	else
@@ -1849,12 +1798,8 @@ static void i7core_check_error(struct mem_ctl_info *mci)
 }
 
 /*
- * i7core_mce_check_error	Replicates mcelog routine to get errors
- *				This routine simply queues mcelog errors, and
- *				return. The error itself should be handled later
- *				by i7core_check_error.
- * WARNING: As this routine should be called at NMI time, extra care should
- * be taken to avoid deadlocks, and to be as fast as possible.
+ * Check that logging is enabled and that this is the right type
+ * of error for us to handle.
  */
 static int i7core_mce_check_error(struct notifier_block *nb, unsigned long val,
 				  void *data)
@@ -1882,21 +1827,7 @@ static int i7core_mce_check_error(struct notifier_block *nb, unsigned long val,
 	if (mce->bank != 8)
 		return NOTIFY_DONE;
 
-	smp_rmb();
-	if ((pvt->mce_out + 1) % MCE_LOG_LEN == pvt->mce_in) {
-		smp_wmb();
-		pvt->mce_overrun++;
-		return NOTIFY_DONE;
-	}
-
-	/* Copy memory error at the ringbuffer */
-	memcpy(&pvt->mce_entry[pvt->mce_out], mce, sizeof(*mce));
-	smp_wmb();
-	pvt->mce_out = (pvt->mce_out + 1) % MCE_LOG_LEN;
-
-	/* Handle fatal errors immediately */
-	if (mce->mcgstatus & 1)
-		i7core_check_error(mci);
+	i7core_check_error(mci, mce);
 
 	/* Advise mcelog that the errors were handled */
 	return NOTIFY_STOP;
@@ -2243,8 +2174,6 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 	get_dimm_config(mci);
 	/* record ptr to the generic device */
 	mci->pdev = &i7core_dev->pdev[0]->dev;
-	/* Set the function pointer to an actual operation function */
-	mci->edac_check = i7core_check_error;
 
 	/* Enable scrubrate setting */
 	if (pvt->enable_scrub)

commit c4fc1956fa31003bfbe4f597e359d751568e2954
Author: Tony Luck <tony.luck@intel.com>
Date:   Fri Apr 29 15:42:25 2016 +0200

    EDAC: i7core, sb_edac: Don't return NOTIFY_BAD from mce_decoder callback
    
    Both of these drivers can return NOTIFY_BAD, but this terminates
    processing other callbacks that were registered later on the chain.
    Since the driver did nothing to log the error it seems wrong to prevent
    other interested parties from seeing it. E.g. neither of them had even
    bothered to check the type of the error to see if it was a memory error
    before the return NOTIFY_BAD.
    
    Signed-off-by: Tony Luck <tony.luck@intel.com>
    Acked-by: Aristeu Rozanski <aris@redhat.com>
    Acked-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Cc: <stable@vger.kernel.org>
    Link: http://lkml.kernel.org/r/72937355dd92318d2630979666063f8a2853495b.1461864507.git.tony.luck@intel.com
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 01087a38da22..792bdae2b91d 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1866,7 +1866,7 @@ static int i7core_mce_check_error(struct notifier_block *nb, unsigned long val,
 
 	i7_dev = get_i7core_dev(mce->socketid);
 	if (!i7_dev)
-		return NOTIFY_BAD;
+		return NOTIFY_DONE;
 
 	mci = i7_dev->mci;
 	pvt = mci->pvt_info;

commit 2eace188f6ba54078db0bc055bb161a99877f2d3
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 4 11:48:55 2015 +0100

    EDAC: i7core: Use static attribute groups for sysfs entries
    
    ... instead of manual device_create_file() and device_remove_file()
    calls.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    [ Add NULL terminator to i7core_dev_attrs[] caught by the build robot. ]
    Reported-by: Huang Ying <ying.huang@intel.com>
    Link: http://lkml.kernel.org/r/1423046938-18111-6-git-send-email-tiwai@suse.de
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 5da90ded54b6..01087a38da22 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1157,24 +1157,21 @@ static DEVICE_ATTR(inject_eccmask, S_IRUGO | S_IWUSR,
 static DEVICE_ATTR(inject_enable, S_IRUGO | S_IWUSR,
 		   i7core_inject_enable_show, i7core_inject_enable_store);
 
+static struct attribute *i7core_dev_attrs[] = {
+	&dev_attr_inject_section.attr,
+	&dev_attr_inject_type.attr,
+	&dev_attr_inject_eccmask.attr,
+	&dev_attr_inject_enable.attr,
+	NULL
+};
+
+ATTRIBUTE_GROUPS(i7core_dev);
+
 static int i7core_create_sysfs_devices(struct mem_ctl_info *mci)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	int rc;
 
-	rc = device_create_file(&mci->dev, &dev_attr_inject_section);
-	if (rc < 0)
-		return rc;
-	rc = device_create_file(&mci->dev, &dev_attr_inject_type);
-	if (rc < 0)
-		return rc;
-	rc = device_create_file(&mci->dev, &dev_attr_inject_eccmask);
-	if (rc < 0)
-		return rc;
-	rc = device_create_file(&mci->dev, &dev_attr_inject_enable);
-	if (rc < 0)
-		return rc;
-
 	pvt->addrmatch_dev = kzalloc(sizeof(*pvt->addrmatch_dev), GFP_KERNEL);
 	if (!pvt->addrmatch_dev)
 		return -ENOMEM;
@@ -1223,11 +1220,6 @@ static void i7core_delete_sysfs_devices(struct mem_ctl_info *mci)
 
 	edac_dbg(1, "\n");
 
-	device_remove_file(&mci->dev, &dev_attr_inject_section);
-	device_remove_file(&mci->dev, &dev_attr_inject_type);
-	device_remove_file(&mci->dev, &dev_attr_inject_eccmask);
-	device_remove_file(&mci->dev, &dev_attr_inject_enable);
-
 	if (!pvt->is_registered) {
 		put_device(pvt->chancounts_dev);
 		device_del(pvt->chancounts_dev);
@@ -2259,7 +2251,7 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 		enable_sdram_scrub_setting(mci);
 
 	/* add this new MC control structure to EDAC's list of MCs */
-	if (unlikely(edac_mc_add_mc(mci))) {
+	if (unlikely(edac_mc_add_mc_with_groups(mci, i7core_dev_groups))) {
 		edac_dbg(0, "MC: failed edac_mc_add_mc()\n");
 		/* FIXME: perhaps some code should go here that disables error
 		 * reporting if we just enabled it

commit e97d7e38162dc305b4734a316ca758a2bbd1fa6e
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 4 11:48:54 2015 +0100

    EDAC: i7core: Return proper error codes for kzalloc() errors
    
    ... instead of possibly uninitialized return value.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Link: http://lkml.kernel.org/r/1423046938-18111-5-git-send-email-tiwai@suse.de
    [ Add a commit message, albeit a small one. ]
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 9cd0b301f81b..5da90ded54b6 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1177,7 +1177,7 @@ static int i7core_create_sysfs_devices(struct mem_ctl_info *mci)
 
 	pvt->addrmatch_dev = kzalloc(sizeof(*pvt->addrmatch_dev), GFP_KERNEL);
 	if (!pvt->addrmatch_dev)
-		return rc;
+		return -ENOMEM;
 
 	pvt->addrmatch_dev->type = &addrmatch_type;
 	pvt->addrmatch_dev->bus = mci->dev.bus;
@@ -1198,7 +1198,7 @@ static int i7core_create_sysfs_devices(struct mem_ctl_info *mci)
 		if (!pvt->chancounts_dev) {
 			put_device(pvt->addrmatch_dev);
 			device_del(pvt->addrmatch_dev);
-			return rc;
+			return -ENOMEM;
 		}
 
 		pvt->chancounts_dev->type = &all_channel_counts_type;

commit 3c83e61e67256e0bb08c46cc2db43b58fd617251
Merge: 4a4389abdd98 a83b93a74804
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 4 09:50:07 2014 -0700

    Merge branch 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media
    
    Pull media updates from Mauro Carvalho Chehab:
     "The main set of series of patches for media subsystem, including:
       - document RC sysfs class
       - added an API to setup scancode to allow waking up systems using the
         Remote Controller
       - add API for SDR devices.  Drivers are still on staging
       - some API improvements for getting EDID data from media
         inputs/outputs
       - new DVB frontend driver for drx-j (ATSC)
       - one driver (it913x/it9137) got removed, in favor of an improvement
         on another driver (af9035)
       - added a skeleton V4L2 PCI driver at documentation
       - added a dual flash driver (lm3646)
       - added a new IR driver (img-ir)
       - added an IR scancode decoder for the Sharp protocol
       - some improvements at the usbtv driver, to allow its core to be
         reused.
       - added a new SDR driver (rtl2832u_sdr)
       - added a new tuner driver (msi001)
       - several improvements at em28xx driver to fix PM support, device
         removal and to split the V4L2 specific bits into a separate
         sub-driver
       - one driver got converted to videobuf2 (s2255drv)
       - the e4000 tuner driver now follows an improved binding model
       - some fixes at V4L2 compat32 code
       - several fixes and enhancements at videobuf2 code
       - some cleanups at V4L2 API documentation
       - usual driver enhancements, new board additions and misc fixups"
    
    [ NOTE! This merge effective drops commit 4329b93b283c ("of: Reduce
      indentation in of_graph_get_next_endpoint").
    
      The of_graph_get_next_endpoint() function was moved and renamed by
      commit fd9fdb78a9bf ("[media] of: move graph helpers from
      drivers/media/v4l2-core to drivers/of").  It was originally called
      v4l2_of_get_next_endpoint() and lived in the file
      drivers/media/v4l2-core/v4l2-of.c.
    
      In that original location, it was then fixed to support empty port
      nodes by commit b9db140c1e46 ("[media] v4l: of: Support empty port
      nodes"), and that commit clashes badly with the dropped "Reduce
      intendation" commit.  I had to choose one or the other, and decided
      that the "Support empty port nodes" commit was more important ]
    
    * 'v4l_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-media: (426 commits)
      [media] em28xx-dvb: fix PCTV 461e tuner I2C binding
      Revert "[media] em28xx-dvb: fix PCTV 461e tuner I2C binding"
      [media] em28xx: fix PCTV 290e LNA oops
      [media] em28xx-dvb: fix PCTV 461e tuner I2C binding
      [media] m88ds3103: fix bug on .set_tone()
      [media] saa7134: fix WARN_ON during resume
      [media] v4l2-dv-timings: add module name, description, license
      [media] videodev2.h: add parenthesis around macro arguments
      [media] saa6752hs: depends on CRC32
      [media] si4713: fix Kconfig dependencies
      [media] Sensoray 2255 uses videobuf2
      [media] adv7180: free an interrupt on failure paths in init_device()
      [media] e4000: make VIDEO_V4L2 dependency optional
      [media] af9033: Don't export functions for the hardware filter
      [media] af9035: use af9033 PID filters
      [media] af9033: implement PID filter
      [media] rtl2832_sdr: do not use dynamic stack allocation
      [media] e4000: fix 32-bit build error
      [media] em28xx-audio: make sure audio is unmuted on open()
      [media] DocBook media: v4l2_format_sdr was renamed to v4l2_sdr_format
      ...

commit 62ff577fa2fec87edbf26f53e87210ba726d4d44
Merge: 26f31fb93604 85a8885bd0e0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 1 13:54:00 2014 -0700

    Merge tag 'edac_for_3.15' of git://git.kernel.org/pub/scm/linux/kernel/git/bp/bp
    
    Pull EDAC updates from Borislav Petkov:
     "A bunch of EDAC updates all over the place:
    
       - Support for new AMD models, along with more graceful fallback for
         unsupported hw.
    
       - Bunch of fixes from SUSE accumulated from bug reports
    
       - Misc other fixes and cleanups"
    
    * tag 'edac_for_3.15' of git://git.kernel.org/pub/scm/linux/kernel/git/bp/bp:
      amd64_edac: Add support for newer F16h models
      i7core_edac: Drop unused variable
      i82875p_edac: Drop redundant call to pci_get_device()
      amd8111_edac: Fix leaks in probe error paths
      e752x_edac: Drop pvt->bridge_ck
      MCE, AMD: Fix decoding module loading on unsupported hw
      i5100_edac: Remove an unneeded condition in i5100_init_csrows()
      sb_edac: Degrade log level for device registration
      amd64_edac: Fix logic to determine channel for F15 M30h processors
      edac/85xx: Remove deprecated IRQF_DISABLED
      i3200_edac: Add a missing pci_disable_device() on the exit path
      i5400_edac: Disable device when unloading module
      e752x_edac: Simplify call to pci_get_device()

commit c897df0e2dbc81bcc09c11425658d69830825364
Merge: 1e9c4d490209 0414855fdc4a
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Tue Mar 11 06:55:49 2014 -0300

    Merge tag 'v3.14-rc5' into patchwork
    
    Linux 3.14-rc5
    
    * tag 'v3.14-rc5': (1117 commits)
      Linux 3.14-rc5
      drm/vmwgfx: avoid null pointer dereference at failure paths
      drm/vmwgfx: Make sure backing mobs are cleared when allocated. Update driver date.
      drm/vmwgfx: Remove some unused surface formats
      MAINTAINERS: add maintainer entry for Armada DRM driver
      arm64: Fix !CONFIG_SMP kernel build
      arm64: mm: Add double logical invert to pte accessors
      dm cache: fix truncation bug when mapping I/O to >2TB fast device
      perf tools: Fix strict alias issue for find_first_bit
      powerpc/powernv: Fix indirect XSCOM unmangling
      powerpc/powernv: Fix opal_xscom_{read,write} prototype
      powerpc/powernv: Refactor PHB diag-data dump
      powerpc/powernv: Dump PHB diag-data immediately
      powerpc: Increase stack redzone for 64-bit userspace to 512 bytes
      powerpc/ftrace: bugfix for test_24bit_addr
      powerpc/crashdump : Fix page frame number check in copy_oldmem_page
      powerpc/le: Ensure that the 'stop-self' RTAS token is handled correctly
      kvm, vmx: Really fix lazy FPU on nested guest
      perf tools: fix BFD detection on opensuse
      drm/radeon: enable speaker allocation setup on dce3.2
      ...

commit f118920baf5994dfa8a5a66322892731480a8207
Author: Jean Delvare <jdelvare@suse.de>
Date:   Mon Feb 24 17:13:58 2014 +0100

    i7core_edac: Drop unused variable
    
    Fix the following warning:
    
    drivers/edac/i7core_edac.c: In function "core_mce_output_error":
    drivers/edac/i7core_edac.c:1711:8: warning: variable "type" set but not used [-Wunused-but-set-variable]
      char *type, *optype, *err;
            ^
    According to Mauro, type can just be dropped, as tp_event now maps if
    the error is corrected, uncorrected non-fatal or uncorrected fatal
    one.
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Link: http://lkml.kernel.org/r/20140224171358.692d7e5a@endymion.delvare
    Acked-by: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Cc: Doug Thompson <dougthompson@xmission.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 87533ca7752e..cc6a51074225 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1703,7 +1703,7 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 				    const struct mce *m)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
-	char *type, *optype, *err;
+	char *optype, *err;
 	enum hw_event_mc_err_type tp_event;
 	unsigned long error = m->status & 0x1ff0000l;
 	bool uncorrected_error = m->mcgstatus & 1ll << 61;
@@ -1716,15 +1716,11 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 	u32 errnum = find_first_bit(&error, 32);
 
 	if (uncorrected_error) {
-		if (ripv) {
-			type = "FATAL";
+		if (ripv)
 			tp_event = HW_EVENT_ERR_FATAL;
-		} else {
-			type = "NON_FATAL";
+		else
 			tp_event = HW_EVENT_ERR_UNCORRECTED;
-		}
 	} else {
-		type = "CORRECTED";
 		tp_event = HW_EVENT_ERR_CORRECTED;
 	}
 

commit c0f5eeed0f4cef4f05b74883a7160e7edde58b6a
Author: Jean Delvare <jdelvare@suse.de>
Date:   Mon Feb 24 09:39:27 2014 +0100

    i7core_edac: Fix PCI device reference count
    
    The reference count changes done by pci_get_device can be a little
    misleading when the usage diverges from the most common scheme. The
    reference count of the device passed as the last parameter is always
    decreased, even if the function returns no new device. So if we are
    going to try alternative device IDs, we must manually increment the
    device reference count before each retry. If we don't, we end up
    decreasing the reference count, and after a few modprobe/rmmod cycles
    the PCI devices will vanish.
    
    In other words and as Alan put it: without this fix the EDAC code
    corrupts the PCI device list.
    
    This fixes kernel bug #50491:
    https://bugzilla.kernel.org/show_bug.cgi?id=50491
    
    Signed-off-by: Jean Delvare <jdelvare@suse.de>
    Link: http://lkml.kernel.org/r/20140224093927.7659dd9d@endymion.delvare
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    Cc: Mauro Carvalho Chehab <m.chehab@samsung.com>
    Cc: Doug Thompson <dougthompson@xmission.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 87533ca7752e..d871275196f6 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1334,14 +1334,19 @@ static int i7core_get_onedevice(struct pci_dev **prev,
 	 * is at addr 8086:2c40, instead of 8086:2c41. So, we need
 	 * to probe for the alternate address in case of failure
 	 */
-	if (dev_descr->dev_id == PCI_DEVICE_ID_INTEL_I7_NONCORE && !pdev)
+	if (dev_descr->dev_id == PCI_DEVICE_ID_INTEL_I7_NONCORE && !pdev) {
+		pci_dev_get(*prev);	/* pci_get_device will put it */
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_I7_NONCORE_ALT, *prev);
+	}
 
-	if (dev_descr->dev_id == PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE && !pdev)
+	if (dev_descr->dev_id == PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE &&
+	    !pdev) {
+		pci_dev_get(*prev);	/* pci_get_device will put it */
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_ALT,
 				      *prev);
+	}
 
 	if (!pdev) {
 		if (*prev) {

commit 37e59f876bc710d67a30b660826a5e83e07101ce
Author: Mauro Carvalho Chehab <m.chehab@samsung.com>
Date:   Fri Feb 7 08:03:07 2014 -0200

    [media, edac] Change my email address
    
    There are several left overs with my old email address.
    Remove their occurrences and add myself at CREDITS, to
    allow people to be able to reach me on my new addresses.
    
    Signed-off-by: Mauro Carvalho Chehab <m.chehab@samsung.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 87533ca7752e..40a228da4547 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -9,7 +9,7 @@
  * GNU General Public License version 2 only.
  *
  * Copyright (c) 2009-2010 by:
- *	 Mauro Carvalho Chehab <mchehab@redhat.com>
+ *	 Mauro Carvalho Chehab
  *
  * Red Hat Inc. http://www.redhat.com
  *
@@ -2456,7 +2456,7 @@ module_init(i7core_init);
 module_exit(i7core_exit);
 
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Mauro Carvalho Chehab <mchehab@redhat.com>");
+MODULE_AUTHOR("Mauro Carvalho Chehab");
 MODULE_AUTHOR("Red Hat Inc. (http://www.redhat.com)");
 MODULE_DESCRIPTION("MC Driver for Intel i7 Core memory controllers - "
 		   I7CORE_REVISION);

commit ba935f40979b32924824759111ed95d35469c5fa
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Fri Dec 6 10:23:08 2013 +0100

    EDAC: Remove DEFINE_PCI_DEVICE_TABLE macro
    
    Currently, there is no other bus that has something like this macro for
    their device ids. Thus, DEFINE_PCI_DEVICE_TABLE macro should be removed.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Link: http://lkml.kernel.org/r/001c01ceefb3$5724d860$056e8920$%han@samsung.com
    [ Boris: swap commit message with better one. ]
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 80a963d64e58..87533ca7752e 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -394,7 +394,7 @@ static const struct pci_id_table pci_dev_table[] = {
 /*
  *	pci_device_id	table for which devices we are looking for
  */
-static DEFINE_PCI_DEVICE_TABLE(i7core_pci_tbl) = {
+static const struct pci_device_id i7core_pci_tbl[] = {
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_X58_HUB_MGMT)},
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_LYNNFIELD_QPI_LINK0)},
 	{0,}			/* 0 terminated list. */

commit c7f62fc87bb4f3ee7f21fed959795de2bd415ccf
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Sat Jun 1 16:08:22 2013 +0900

    EDAC: Replace strict_strtoul() with kstrtoul()
    
    The usage of strict_strtoul() is not preferred, because strict_strtoul()
    is obsolete. Thus, kstrtoul() should be used.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 0ec3e95a12cd..80a963d64e58 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -704,7 +704,7 @@ static ssize_t i7core_inject_section_store(struct device *dev,
 	if (pvt->inject.enable)
 		disable_inject(mci);
 
-	rc = strict_strtoul(data, 10, &value);
+	rc = kstrtoul(data, 10, &value);
 	if ((rc < 0) || (value > 3))
 		return -EIO;
 
@@ -741,7 +741,7 @@ struct i7core_pvt *pvt = mci->pvt_info;
 	if (pvt->inject.enable)
 		disable_inject(mci);
 
-	rc = strict_strtoul(data, 10, &value);
+	rc = kstrtoul(data, 10, &value);
 	if ((rc < 0) || (value > 7))
 		return -EIO;
 
@@ -781,7 +781,7 @@ static ssize_t i7core_inject_eccmask_store(struct device *dev,
 	if (pvt->inject.enable)
 		disable_inject(mci);
 
-	rc = strict_strtoul(data, 10, &value);
+	rc = kstrtoul(data, 10, &value);
 	if (rc < 0)
 		return -EIO;
 
@@ -830,7 +830,7 @@ static ssize_t i7core_inject_store_##param(			\
 	if (!strcasecmp(data, "any") || !strcasecmp(data, "any\n"))\
 		value = -1;					\
 	else {							\
-		rc = strict_strtoul(data, 10, &value);		\
+		rc = kstrtoul(data, 10, &value);		\
 		if ((rc < 0) || (value >= limit))		\
 			return -EIO;				\
 	}							\
@@ -934,7 +934,7 @@ static ssize_t i7core_inject_enable_store(struct device *dev,
 	if (!pvt->pci_ch[pvt->inject.channel][0])
 		return 0;
 
-	rc = strict_strtoul(data, 10, &enable);
+	rc = kstrtoul(data, 10, &enable);
 	if ((rc < 0))
 		return 0;
 

commit 1339730e73f14673ad55bddda119982504633da9
Merge: 1c069100c1f5 836dc9e3fbba
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Feb 20 15:45:52 2013 -0300

    Merge tag 'v3.8-rc7' into next
    
    Linux 3.8-rc7
    
    * tag 'v3.8-rc7': (12052 commits)
      Linux 3.8-rc7
      net: sctp: sctp_endpoint_free: zero out secret key data
      net: sctp: sctp_setsockopt_auth_key: use kzfree instead of kfree
      atm/iphase: rename fregt_t -> ffreg_t
      ARM: 7641/1: memory: fix broken mmap by ensuring TASK_UNMAPPED_BASE is aligned
      ARM: DMA mapping: fix bad atomic test
      ARM: realview: ensure that we have sufficient IRQs available
      ARM: GIC: fix GIC cpumask initialization
      net: usb: fix regression from FLAG_NOARP code
      l2tp: dont play with skb->truesize
      net: sctp: sctp_auth_key_put: use kzfree instead of kfree
      netback: correct netbk_tx_err to handle wrap around.
      xen/netback: free already allocated memory on failure in xen_netbk_get_requests
      xen/netback: don't leak pages on failure in xen_netbk_tx_check_gop.
      xen/netback: shutdown the ring if it contains garbage.
      drm/ttm: fix fence locking in ttm_buffer_object_transfer, 2nd try
      virtio_console: Don't access uninitialized data.
      net: qmi_wwan: add more Huawei devices, including E320
      net: cdc_ncm: add another Huawei vendor specific device
      ipv6/ip6_gre: fix error case handling in ip6gre_tunnel_xmit()
      ...

commit 9b3c6e85c2cfa731cf67d5a8c49f7d8c60ec0b04
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:23:51 2012 -0800

    Drivers: edac: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, and __devexit
    from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Doug Thompson <dougthompson@xmission.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: Jason Uhlenkott <juhlenko@akamai.com>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Tim Small <tim@buttersideup.com>
    Cc: Ranganathan Desikan <ravi@jetztechnologies.com>
    Cc: "Arvind R." <arvino55@gmail.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: David Daney <david.daney@cavium.com>
    Cc: Egor Martovetsky <egor@pasemi.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 10c8c00d6469..e213d030b0dd 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -2305,8 +2305,7 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
  *		< 0 for error code
  */
 
-static int __devinit i7core_probe(struct pci_dev *pdev,
-				  const struct pci_device_id *id)
+static int i7core_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 {
 	int rc, count = 0;
 	struct i7core_dev *i7core_dev;
@@ -2368,7 +2367,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
  *	i7core_remove	destructor for one instance of device
  *
  */
-static void __devexit i7core_remove(struct pci_dev *pdev)
+static void i7core_remove(struct pci_dev *pdev)
 {
 	struct i7core_dev *i7core_dev;
 
@@ -2409,7 +2408,7 @@ MODULE_DEVICE_TABLE(pci, i7core_pci_tbl);
 static struct pci_driver i7core_driver = {
 	.name     = "i7core_edac",
 	.probe    = i7core_probe,
-	.remove   = __devexit_p(i7core_remove),
+	.remove   = i7core_remove,
 	.id_table = i7core_pci_tbl,
 };
 

commit c31d34fe92e9d0b146907d7294269ee03e1b403f
Author: Niklas Söderlund <niso@kth.se>
Date:   Sun Jan 29 23:04:32 2012 +0100

    i7core_edac: fix erroneous size of static array
    
    Remove size from lookup arrays and mark them as const.
    
    Reviewed-by: Jesper Juhl <jj@chaosbits.net>
    Signed-off-by: Niklas Söderlund <niso@kth.se>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 10c8c00d6469..ad5f934c95d3 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -420,21 +420,21 @@ static inline int numdimms(u32 dimms)
 
 static inline int numrank(u32 rank)
 {
-	static int ranks[4] = { 1, 2, 4, -EINVAL };
+	static const int ranks[] = { 1, 2, 4, -EINVAL };
 
 	return ranks[rank & 0x3];
 }
 
 static inline int numbank(u32 bank)
 {
-	static int banks[4] = { 4, 8, 16, -EINVAL };
+	static const int banks[] = { 4, 8, 16, -EINVAL };
 
 	return banks[bank & 0x3];
 }
 
 static inline int numrow(u32 row)
 {
-	static int rows[8] = {
+	static const int rows[] = {
 		1 << 12, 1 << 13, 1 << 14, 1 << 15,
 		1 << 16, -EINVAL, -EINVAL, -EINVAL,
 	};
@@ -444,7 +444,7 @@ static inline int numrow(u32 row)
 
 static inline int numcol(u32 col)
 {
-	static int cols[8] = {
+	static const int cols[] = {
 		1 << 10, 1 << 11, 1 << 12, -EINVAL,
 	};
 	return cols[col & 0x3];

commit 42709efb3a47524c6252e1bdc85e205f7bc356fb
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Tue Oct 16 09:02:27 2012 -0400

    i7core_edac: fix panic when accessing sysfs files
    
    The i7core_edac addrmatch_dev and chancounts_dev have sysfs files
    associated with them.  The sysfs files, however, are coded so that the
    parent device is is the mci device.  This is incorrect and the mci struct
    should be obtained through the addrmatch_dev and chancounts_dev device's
    private data field which is populated in i7core_create_sysfs_devices().
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 3672101023bd..10c8c00d6469 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -816,7 +816,7 @@ static ssize_t i7core_inject_store_##param(			\
 	struct device_attribute *mattr,				\
 	const char *data, size_t count)				\
 {								\
-	struct mem_ctl_info *mci = to_mci(dev);			\
+	struct mem_ctl_info *mci = dev_get_drvdata(dev);	\
 	struct i7core_pvt *pvt;					\
 	long value;						\
 	int rc;							\
@@ -845,7 +845,7 @@ static ssize_t i7core_inject_show_##param(			\
 	struct device_attribute *mattr,				\
 	char *data)						\
 {								\
-	struct mem_ctl_info *mci = to_mci(dev);			\
+	struct mem_ctl_info *mci = dev_get_drvdata(dev);	\
 	struct i7core_pvt *pvt;					\
 								\
 	pvt = mci->pvt_info;					\
@@ -1052,7 +1052,7 @@ static ssize_t i7core_show_counter_##param(			\
 	struct device_attribute *mattr,				\
 	char *data)						\
 {								\
-	struct mem_ctl_info *mci = to_mci(dev);			\
+	struct mem_ctl_info *mci = dev_get_drvdata(dev);	\
 	struct i7core_pvt *pvt = mci->pvt_info;			\
 								\
 	edac_dbg(1, "\n");					\

commit c2078e4c9120e7b38b1a02cd9fc6dd4f792110bf
Merge: 73bcc49959e4 f58d0dee07fe
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sun Jul 29 21:11:05 2012 -0300

    Merge branch 'devel'
    
    * devel: (33 commits)
      edac i5000, i5400: fix pointer math in i5000_get_mc_regs()
      edac: allow specifying the error count with fake_inject
      edac: add support for Calxeda highbank L2 cache ecc
      edac: add support for Calxeda highbank memory controller
      edac: create top-level debugfs directory
      sb_edac: properly handle error count
      i7core_edac: properly handle error count
      edac: edac_mc_handle_error(): add an error_count parameter
      edac: remove arch-specific parameter for the error handler
      amd64_edac: Don't pass driver name as an error parameter
      edac_mc: check for allocation failure in edac_mc_alloc()
      edac: Increase version to 3.0.0
      edac_mc: Cleanup per-dimm_info debug messages
      edac: Convert debugfX to edac_dbg(X,
      edac: Use more normal debugging macro style
      edac: Don't add __func__ or __FILE__ for debugf[0-9] msgs
      Edac: Add ABI Documentation for the new device nodes
      edac: move documentation ABI to ABI/testing/sysfs-devices-edac
      i7core_edac: change the mem allocation scheme to make Documentation/kobject.txt happy
      edac: change the mem allocation scheme to make Documentation/kobject.txt happy
      ...

commit 00d18339276d35bc6b7ae6ae1a64ebf2242b89f6
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 4 13:38:52 2012 -0300

    i7core_edac: properly handle error count
    
    Instead of generating a burst of errors or reporting the error
    count via driver-specific details, use the new way provided by
    edac_mc_handle_error.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index a95686e22416..a3c9a37b4cc1 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1536,18 +1536,6 @@ static int mci_bind_devs(struct mem_ctl_info *mci,
 /****************************************************************************
 			Error check routines
  ****************************************************************************/
-static void i7core_rdimm_update_errcount(struct mem_ctl_info *mci,
-				      const int chan,
-				      const int dimm,
-				      const int add)
-{
-	int i;
-
-	for (i = 0; i < add; i++) {
-		edac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1, 0, 0, 0,
-				     chan, dimm, -1, "error", "");
-	}
-}
 
 static void i7core_rdimm_update_ce_count(struct mem_ctl_info *mci,
 					 const int chan,
@@ -1586,12 +1574,17 @@ static void i7core_rdimm_update_ce_count(struct mem_ctl_info *mci,
 
 	/*updated the edac core */
 	if (add0 != 0)
-		i7core_rdimm_update_errcount(mci, chan, 0, add0);
+		edac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, add0,
+				     0, 0, 0,
+				     chan, 0, -1, "error", "");
 	if (add1 != 0)
-		i7core_rdimm_update_errcount(mci, chan, 1, add1);
+		edac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, add1,
+				     0, 0, 0,
+				     chan, 1, -1, "error", "");
 	if (add2 != 0)
-		i7core_rdimm_update_errcount(mci, chan, 2, add2);
-
+		edac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, add2,
+				     0, 0, 0,
+				     chan, 2, -1, "error", "");
 }
 
 static void i7core_rdimm_check_mc_ecc_err(struct mem_ctl_info *mci)
@@ -1710,7 +1703,7 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 				    const struct mce *m)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
-	char *type, *optype, *err, msg[80];
+	char *type, *optype, *err;
 	enum hw_event_mc_err_type tp_event;
 	unsigned long error = m->status & 0x1ff0000l;
 	bool uncorrected_error = m->mcgstatus & 1ll << 61;
@@ -1788,20 +1781,18 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 		err = "unknown";
 	}
 
-	snprintf(msg, sizeof(msg), "count=%d %s", core_err_cnt, optype);
-
 	/*
 	 * Call the helper to output message
 	 * FIXME: what to do if core_err_cnt > 1? Currently, it generates
 	 * only one event
 	 */
 	if (uncorrected_error || !pvt->is_registered)
-		edac_mc_handle_error(tp_event, mci, 1,
+		edac_mc_handle_error(tp_event, mci, core_err_cnt,
 				     m->addr >> PAGE_SHIFT,
 				     m->addr & ~PAGE_MASK,
 				     syndrome,
 				     channel, dimm, -1,
-				     err, msg);
+				     err, optype);
 }
 
 /*

commit 9eb07a7fb8a90ee39fa9d5489afc0330cfcfbea7
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 4 13:27:43 2012 -0300

    edac: edac_mc_handle_error(): add an error_count parameter
    
    In order to avoid loosing error events, it is desirable to group
    error events together and generate a single trace for several identical
    errors.
    
    The trace API already allows reporting multiple errors. Change the
    handle_error function to also allow that.
    
    The changes at the drivers were made by this small script:
    
            $file .=$_ while (<>);
            $file =~ s/(edac_mc_handle_error)\s*\(([^\,]+)\,([^\,]+)\,/$1($2,$3, 1,/g;
            print $file;
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index aba8d5190330..a95686e22416 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1544,7 +1544,7 @@ static void i7core_rdimm_update_errcount(struct mem_ctl_info *mci,
 	int i;
 
 	for (i = 0; i < add; i++) {
-		edac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 0, 0, 0,
+		edac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1, 0, 0, 0,
 				     chan, dimm, -1, "error", "");
 	}
 }
@@ -1796,7 +1796,7 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 	 * only one event
 	 */
 	if (uncorrected_error || !pvt->is_registered)
-		edac_mc_handle_error(tp_event, mci,
+		edac_mc_handle_error(tp_event, mci, 1,
 				     m->addr >> PAGE_SHIFT,
 				     m->addr & ~PAGE_MASK,
 				     syndrome,

commit 03f7eae80f4b913929be84e0c883ee98196fd6ff
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 4 11:29:25 2012 -0300

    edac: remove arch-specific parameter for the error handler
    
    Remove the arch-dependent parameter, as it were not used,
    as the MCE tracepoint weren't implemented. It probably doesn't
    make sense to have an MCE-specific tracepoint, as this will
    cost more bytes at the tracepoint, and tracepoint is not free.
    
    The changes at the EDAC drivers were done by this small perl script:
    
            $file .=$_ while (<>);
            $file =~ s/(edac_mc_handle_error)\s*\(([^\;]+)\,([^\,\)]+)\s*\)/$1($2)/g;
            print $file;
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 0899d7da7248..aba8d5190330 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1545,7 +1545,7 @@ static void i7core_rdimm_update_errcount(struct mem_ctl_info *mci,
 
 	for (i = 0; i < add; i++) {
 		edac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 0, 0, 0,
-				     chan, dimm, -1, "error", "", NULL);
+				     chan, dimm, -1, "error", "");
 	}
 }
 
@@ -1801,7 +1801,7 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 				     m->addr & ~PAGE_MASK,
 				     syndrome,
 				     channel, dimm, -1,
-				     err, msg, m);
+				     err, msg);
 }
 
 /*

commit 956b9ba156dbfdb9cede2b2927ddf8be2233b3a7
Author: Joe Perches <joe@perches.com>
Date:   Sun Apr 29 17:08:39 2012 -0300

    edac: Convert debugfX to edac_dbg(X,
    
    Use a more common debugging style.
    
    Remove __FILE__ uses, add missing newlines,
    coalesce formats and align arguments.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index f851a433d620..0899d7da7248 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -516,29 +516,28 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 	pci_read_config_dword(pdev, MC_MAX_DOD, &pvt->info.max_dod);
 	pci_read_config_dword(pdev, MC_CHANNEL_MAPPER, &pvt->info.ch_map);
 
-	debugf0("QPI %d control=0x%08x status=0x%08x dod=0x%08x map=0x%08x\n",
-		pvt->i7core_dev->socket, pvt->info.mc_control, pvt->info.mc_status,
-		pvt->info.max_dod, pvt->info.ch_map);
+	edac_dbg(0, "QPI %d control=0x%08x status=0x%08x dod=0x%08x map=0x%08x\n",
+		 pvt->i7core_dev->socket, pvt->info.mc_control,
+		 pvt->info.mc_status, pvt->info.max_dod, pvt->info.ch_map);
 
 	if (ECC_ENABLED(pvt)) {
-		debugf0("ECC enabled with x%d SDCC\n", ECCx8(pvt) ? 8 : 4);
+		edac_dbg(0, "ECC enabled with x%d SDCC\n", ECCx8(pvt) ? 8 : 4);
 		if (ECCx8(pvt))
 			mode = EDAC_S8ECD8ED;
 		else
 			mode = EDAC_S4ECD4ED;
 	} else {
-		debugf0("ECC disabled\n");
+		edac_dbg(0, "ECC disabled\n");
 		mode = EDAC_NONE;
 	}
 
 	/* FIXME: need to handle the error codes */
-	debugf0("DOD Max limits: DIMMS: %d, %d-ranked, %d-banked "
-		"x%x x 0x%x\n",
-		numdimms(pvt->info.max_dod),
-		numrank(pvt->info.max_dod >> 2),
-		numbank(pvt->info.max_dod >> 4),
-		numrow(pvt->info.max_dod >> 6),
-		numcol(pvt->info.max_dod >> 9));
+	edac_dbg(0, "DOD Max limits: DIMMS: %d, %d-ranked, %d-banked x%x x 0x%x\n",
+		 numdimms(pvt->info.max_dod),
+		 numrank(pvt->info.max_dod >> 2),
+		 numbank(pvt->info.max_dod >> 4),
+		 numrow(pvt->info.max_dod >> 6),
+		 numcol(pvt->info.max_dod >> 9));
 
 	for (i = 0; i < NUM_CHANS; i++) {
 		u32 data, dimm_dod[3], value[8];
@@ -547,11 +546,11 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 			continue;
 
 		if (!CH_ACTIVE(pvt, i)) {
-			debugf0("Channel %i is not active\n", i);
+			edac_dbg(0, "Channel %i is not active\n", i);
 			continue;
 		}
 		if (CH_DISABLED(pvt, i)) {
-			debugf0("Channel %i is disabled\n", i);
+			edac_dbg(0, "Channel %i is disabled\n", i);
 			continue;
 		}
 
@@ -582,15 +581,14 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 		pci_read_config_dword(pvt->pci_ch[i][1],
 				MC_DOD_CH_DIMM2, &dimm_dod[2]);
 
-		debugf0("Ch%d phy rd%d, wr%d (0x%08x): "
-			"%s%s%s%cDIMMs\n",
-			i,
-			RDLCH(pvt->info.ch_map, i), WRLCH(pvt->info.ch_map, i),
-			data,
-			pvt->channel[i].is_3dimms_present ? "3DIMMS " : "",
-			pvt->channel[i].is_3dimms_present ? "SINGLE_4R " : "",
-			pvt->channel[i].has_4rank ? "HAS_4R " : "",
-			(data & REGISTERED_DIMM) ? 'R' : 'U');
+		edac_dbg(0, "Ch%d phy rd%d, wr%d (0x%08x): %s%s%s%cDIMMs\n",
+			 i,
+			 RDLCH(pvt->info.ch_map, i), WRLCH(pvt->info.ch_map, i),
+			 data,
+			 pvt->channel[i].is_3dimms_present ? "3DIMMS " : "",
+			 pvt->channel[i].is_3dimms_present ? "SINGLE_4R " : "",
+			 pvt->channel[i].has_4rank ? "HAS_4R " : "",
+			 (data & REGISTERED_DIMM) ? 'R' : 'U');
 
 		for (j = 0; j < 3; j++) {
 			u32 banks, ranks, rows, cols;
@@ -609,11 +607,10 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 			/* DDR3 has 8 I/O banks */
 			size = (rows * cols * banks * ranks) >> (20 - 3);
 
-			debugf0("\tdimm %d %d Mb offset: %x, "
-				"bank: %d, rank: %d, row: %#x, col: %#x\n",
-				j, size,
-				RANKOFFSET(dimm_dod[j]),
-				banks, ranks, rows, cols);
+			edac_dbg(0, "\tdimm %d %d Mb offset: %x, bank: %d, rank: %d, row: %#x, col: %#x\n",
+				 j, size,
+				 RANKOFFSET(dimm_dod[j]),
+				 banks, ranks, rows, cols);
 
 			npages = MiB_TO_PAGES(size);
 
@@ -649,12 +646,12 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 		pci_read_config_dword(pdev, MC_SAG_CH_5, &value[5]);
 		pci_read_config_dword(pdev, MC_SAG_CH_6, &value[6]);
 		pci_read_config_dword(pdev, MC_SAG_CH_7, &value[7]);
-		debugf1("\t[%i] DIVBY3\tREMOVED\tOFFSET\n", i);
+		edac_dbg(1, "\t[%i] DIVBY3\tREMOVED\tOFFSET\n", i);
 		for (j = 0; j < 8; j++)
-			debugf1("\t\t%#x\t%#x\t%#x\n",
-				(value[j] >> 27) & 0x1,
-				(value[j] >> 24) & 0x7,
-				(value[j] & ((1 << 24) - 1)));
+			edac_dbg(1, "\t\t%#x\t%#x\t%#x\n",
+				 (value[j] >> 27) & 0x1,
+				 (value[j] >> 24) & 0x7,
+				 (value[j] & ((1 << 24) - 1)));
 	}
 
 	return 0;
@@ -824,7 +821,7 @@ static ssize_t i7core_inject_store_##param(			\
 	long value;						\
 	int rc;							\
 								\
-	debugf1("\n");				\
+	edac_dbg(1, "\n");					\
 	pvt = mci->pvt_info;					\
 								\
 	if (pvt->inject.enable)					\
@@ -852,7 +849,7 @@ static ssize_t i7core_inject_show_##param(			\
 	struct i7core_pvt *pvt;					\
 								\
 	pvt = mci->pvt_info;					\
-	debugf1("pvt=%p\n", pvt);		\
+	edac_dbg(1, "pvt=%p\n", pvt);				\
 	if (pvt->inject.param < 0)				\
 		return sprintf(data, "any\n");			\
 	else							\
@@ -883,9 +880,9 @@ static int write_and_test(struct pci_dev *dev, const int where, const u32 val)
 	u32 read;
 	int count;
 
-	debugf0("setting pci %02x:%02x.%x reg=%02x value=%08x\n",
-		dev->bus->number, PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn),
-		where, val);
+	edac_dbg(0, "setting pci %02x:%02x.%x reg=%02x value=%08x\n",
+		 dev->bus->number, PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn),
+		 where, val);
 
 	for (count = 0; count < 10; count++) {
 		if (count)
@@ -1020,9 +1017,8 @@ static ssize_t i7core_inject_enable_store(struct device *dev,
 	pci_write_config_dword(pvt->pci_noncore,
 			       MC_CFG_CONTROL, 8);
 
-	debugf0("Error inject addr match 0x%016llx, ecc 0x%08x,"
-		" inject 0x%08x\n",
-		mask, pvt->inject.eccmask, injectmask);
+	edac_dbg(0, "Error inject addr match 0x%016llx, ecc 0x%08x, inject 0x%08x\n",
+		 mask, pvt->inject.eccmask, injectmask);
 
 
 	return count;
@@ -1042,7 +1038,7 @@ static ssize_t i7core_inject_enable_show(struct device *dev,
 	pci_read_config_dword(pvt->pci_ch[pvt->inject.channel][0],
 			       MC_CHANNEL_ERROR_INJECT, &injectmask);
 
-	debugf0("Inject error read: 0x%018x\n", injectmask);
+	edac_dbg(0, "Inject error read: 0x%018x\n", injectmask);
 
 	if (injectmask & 0x0c)
 		pvt->inject.enable = 1;
@@ -1059,7 +1055,7 @@ static ssize_t i7core_show_counter_##param(			\
 	struct mem_ctl_info *mci = to_mci(dev);			\
 	struct i7core_pvt *pvt = mci->pvt_info;			\
 								\
-	debugf1("\n");				\
+	edac_dbg(1, "\n");					\
 	if (!pvt->ce_count_available || (pvt->is_registered))	\
 		return sprintf(data, "data unavailable\n");	\
 	return sprintf(data, "%lu\n",				\
@@ -1104,7 +1100,7 @@ static const struct attribute_group *addrmatch_groups[] = {
 
 static void addrmatch_release(struct device *device)
 {
-	debugf1("Releasing device %s\n", dev_name(device));
+	edac_dbg(1, "Releasing device %s\n", dev_name(device));
 	kfree(device);
 }
 
@@ -1135,7 +1131,7 @@ static const struct attribute_group *all_channel_counts_groups[] = {
 
 static void all_channel_counts_release(struct device *device)
 {
-	debugf1("Releasing device %s\n", dev_name(device));
+	edac_dbg(1, "Releasing device %s\n", dev_name(device));
 	kfree(device);
 }
 
@@ -1190,7 +1186,7 @@ static int i7core_create_sysfs_devices(struct mem_ctl_info *mci)
 	dev_set_name(pvt->addrmatch_dev, "inject_addrmatch");
 	dev_set_drvdata(pvt->addrmatch_dev, mci);
 
-	debugf1("creating %s\n", dev_name(pvt->addrmatch_dev));
+	edac_dbg(1, "creating %s\n", dev_name(pvt->addrmatch_dev));
 
 	rc = device_add(pvt->addrmatch_dev);
 	if (rc < 0)
@@ -1212,7 +1208,7 @@ static int i7core_create_sysfs_devices(struct mem_ctl_info *mci)
 		dev_set_name(pvt->chancounts_dev, "all_channel_counts");
 		dev_set_drvdata(pvt->chancounts_dev, mci);
 
-		debugf1("creating %s\n", dev_name(pvt->chancounts_dev));
+		edac_dbg(1, "creating %s\n", dev_name(pvt->chancounts_dev));
 
 		rc = device_add(pvt->chancounts_dev);
 		if (rc < 0)
@@ -1225,7 +1221,7 @@ static void i7core_delete_sysfs_devices(struct mem_ctl_info *mci)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 
-	debugf1("\n");
+	edac_dbg(1, "\n");
 
 	device_remove_file(&mci->dev, &dev_attr_inject_section);
 	device_remove_file(&mci->dev, &dev_attr_inject_type);
@@ -1252,14 +1248,14 @@ static void i7core_put_devices(struct i7core_dev *i7core_dev)
 {
 	int i;
 
-	debugf0("\n");
+	edac_dbg(0, "\n");
 	for (i = 0; i < i7core_dev->n_devs; i++) {
 		struct pci_dev *pdev = i7core_dev->pdev[i];
 		if (!pdev)
 			continue;
-		debugf0("Removing dev %02x:%02x.%d\n",
-			pdev->bus->number,
-			PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
+		edac_dbg(0, "Removing dev %02x:%02x.%d\n",
+			 pdev->bus->number,
+			 PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
 		pci_dev_put(pdev);
 	}
 }
@@ -1302,12 +1298,12 @@ static unsigned i7core_pci_lastbus(void)
 
 	while ((b = pci_find_next_bus(b)) != NULL) {
 		bus = b->number;
-		debugf0("Found bus %d\n", bus);
+		edac_dbg(0, "Found bus %d\n", bus);
 		if (bus > last_bus)
 			last_bus = bus;
 	}
 
-	debugf0("Last bus %d\n", last_bus);
+	edac_dbg(0, "Last bus %d\n", last_bus);
 
 	return last_bus;
 }
@@ -1414,10 +1410,10 @@ static int i7core_get_onedevice(struct pci_dev **prev,
 		return -ENODEV;
 	}
 
-	debugf0("Detected socket %d dev %02x:%02x.%d PCI ID %04x:%04x\n",
-		socket, bus, dev_descr->dev,
-		dev_descr->func,
-		PCI_VENDOR_ID_INTEL, dev_descr->dev_id);
+	edac_dbg(0, "Detected socket %d dev %02x:%02x.%d PCI ID %04x:%04x\n",
+		 socket, bus, dev_descr->dev,
+		 dev_descr->func,
+		 PCI_VENDOR_ID_INTEL, dev_descr->dev_id);
 
 	/*
 	 * As stated on drivers/pci/search.c, the reference count for
@@ -1515,13 +1511,13 @@ static int mci_bind_devs(struct mem_ctl_info *mci,
 				family = "unknown";
 				pvt->enable_scrub = false;
 			}
-			debugf0("Detected a processor type %s\n", family);
+			edac_dbg(0, "Detected a processor type %s\n", family);
 		} else
 			goto error;
 
-		debugf0("Associated fn %d.%d, dev = %p, socket %d\n",
-			PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),
-			pdev, i7core_dev->socket);
+		edac_dbg(0, "Associated fn %d.%d, dev = %p, socket %d\n",
+			 PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),
+			 pdev, i7core_dev->socket);
 
 		if (PCI_SLOT(pdev->devfn) == 3 &&
 			PCI_FUNC(pdev->devfn) == 2)
@@ -1618,8 +1614,8 @@ static void i7core_rdimm_check_mc_ecc_err(struct mem_ctl_info *mci)
 	pci_read_config_dword(pvt->pci_mcr[2], MC_COR_ECC_CNT_5,
 								&rcv[2][1]);
 	for (i = 0 ; i < 3; i++) {
-		debugf3("MC_COR_ECC_CNT%d = 0x%x; MC_COR_ECC_CNT%d = 0x%x\n",
-			(i * 2), rcv[i][0], (i * 2) + 1, rcv[i][1]);
+		edac_dbg(3, "MC_COR_ECC_CNT%d = 0x%x; MC_COR_ECC_CNT%d = 0x%x\n",
+			 (i * 2), rcv[i][0], (i * 2) + 1, rcv[i][1]);
 		/*if the channel has 3 dimms*/
 		if (pvt->channel[i].dimms > 2) {
 			new0 = DIMM_BOT_COR_ERR(rcv[i][0]);
@@ -1650,7 +1646,7 @@ static void i7core_udimm_check_mc_ecc_err(struct mem_ctl_info *mci)
 	int new0, new1, new2;
 
 	if (!pvt->pci_mcr[4]) {
-		debugf0("MCR registers not found\n");
+		edac_dbg(0, "MCR registers not found\n");
 		return;
 	}
 
@@ -2188,7 +2184,7 @@ static void i7core_unregister_mci(struct i7core_dev *i7core_dev)
 	struct i7core_pvt *pvt;
 
 	if (unlikely(!mci || !mci->pvt_info)) {
-		debugf0("MC: dev = %p\n", &i7core_dev->pdev[0]->dev);
+		edac_dbg(0, "MC: dev = %p\n", &i7core_dev->pdev[0]->dev);
 
 		i7core_printk(KERN_ERR, "Couldn't find mci handler\n");
 		return;
@@ -2196,7 +2192,7 @@ static void i7core_unregister_mci(struct i7core_dev *i7core_dev)
 
 	pvt = mci->pvt_info;
 
-	debugf0("MC: mci = %p, dev = %p\n", mci, &i7core_dev->pdev[0]->dev);
+	edac_dbg(0, "MC: mci = %p, dev = %p\n", mci, &i7core_dev->pdev[0]->dev);
 
 	/* Disable scrubrate setting */
 	if (pvt->enable_scrub)
@@ -2211,7 +2207,7 @@ static void i7core_unregister_mci(struct i7core_dev *i7core_dev)
 	i7core_delete_sysfs_devices(mci);
 	edac_mc_del_mc(mci->pdev);
 
-	debugf1("%s: free mci struct\n", mci->ctl_name);
+	edac_dbg(1, "%s: free mci struct\n", mci->ctl_name);
 	kfree(mci->ctl_name);
 	edac_mc_free(mci);
 	i7core_dev->mci = NULL;
@@ -2237,7 +2233,7 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 	if (unlikely(!mci))
 		return -ENOMEM;
 
-	debugf0("MC: mci = %p, dev = %p\n", mci, &i7core_dev->pdev[0]->dev);
+	edac_dbg(0, "MC: mci = %p, dev = %p\n", mci, &i7core_dev->pdev[0]->dev);
 
 	pvt = mci->pvt_info;
 	memset(pvt, 0, sizeof(*pvt));
@@ -2280,7 +2276,7 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 
 	/* add this new MC control structure to EDAC's list of MCs */
 	if (unlikely(edac_mc_add_mc(mci))) {
-		debugf0("MC: failed edac_mc_add_mc()\n");
+		edac_dbg(0, "MC: failed edac_mc_add_mc()\n");
 		/* FIXME: perhaps some code should go here that disables error
 		 * reporting if we just enabled it
 		 */
@@ -2289,7 +2285,7 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 		goto fail0;
 	}
 	if (i7core_create_sysfs_devices(mci)) {
-		debugf0("MC: failed to create sysfs nodes\n");
+		edac_dbg(0, "MC: failed to create sysfs nodes\n");
 		edac_mc_del_mc(mci->pdev);
 		rc = -EINVAL;
 		goto fail0;
@@ -2395,7 +2391,7 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 {
 	struct i7core_dev *i7core_dev;
 
-	debugf0("\n");
+	edac_dbg(0, "\n");
 
 	/*
 	 * we have a trouble here: pdev value for removal will be wrong, since
@@ -2444,7 +2440,7 @@ static int __init i7core_init(void)
 {
 	int pci_rc;
 
-	debugf2("\n");
+	edac_dbg(2, "\n");
 
 	/* Ensure that the OPSTATE is set correctly for POLL or NMI */
 	opstate_init();
@@ -2469,7 +2465,7 @@ static int __init i7core_init(void)
  */
 static void __exit i7core_exit(void)
 {
-	debugf2("\n");
+	edac_dbg(2, "\n");
 	pci_unregister_driver(&i7core_driver);
 }
 

commit dd23cd6eb1f59ba722a6e6aa228adff7c01404de
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sun Apr 29 11:59:14 2012 -0300

    edac: Don't add __func__ or __FILE__ for debugf[0-9] msgs
    
    The debug macro already adds that. Most of the work here was
    made by this small script:
    
    $f .=$_ while (<>);
    
    $f =~ s/(debugf[0-9]\s*\(\s*)__FILE__\s*": /\1"/g;
    $f =~ s/(debugf[0-9]\s*\(\s*)__FILE__\s*/\1/g;
    $f =~ s/(debugf[0-9]\s*\(\s*)__FILE__\s*"MC: /\1"/g;
    
    $f =~ s/(debugf[0-9]\s*\(\")\%s[\:\,\(\)]*\s*([^\"]*\s*[^\)]+)__func__\s*\,\s*/\1\2/g;
    $f =~ s/(debugf[0-9]\s*\(\")\%s[\:\,\(\)]*\s*([^\"]*\s*[^\)]+),\s*__func__\s*\)/\1\2)/g;
    $f =~ s/(debugf[0-9]\s*\(\"MC\:\s*)\%s[\:\,\(\)]*\s*([^\"]*\s*[^\)]+)__func__\s*\,\s*/\1\2/g;
    $f =~ s/(debugf[0-9]\s*\(\"MC\:\s*)\%s[\:\,\(\)]*\s*([^\"]*\s*[^\)]+),\s*__func__\s*\)/\1\2)/g;
    
    $f =~ s/\"MC\: \\n\"/"MC:\\n"/g;
    
    print $f;
    
    After running the script, manual cleanups were done to fix it the remaining
    places.
    
    While here, removed the __LINE__ on most places, as it doesn't actually give
    useful info on most places.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index c29944fbb7d8..f851a433d620 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -824,7 +824,7 @@ static ssize_t i7core_inject_store_##param(			\
 	long value;						\
 	int rc;							\
 								\
-	debugf1("%s()\n", __func__);				\
+	debugf1("\n");				\
 	pvt = mci->pvt_info;					\
 								\
 	if (pvt->inject.enable)					\
@@ -852,7 +852,7 @@ static ssize_t i7core_inject_show_##param(			\
 	struct i7core_pvt *pvt;					\
 								\
 	pvt = mci->pvt_info;					\
-	debugf1("%s() pvt=%p\n", __func__, pvt);		\
+	debugf1("pvt=%p\n", pvt);		\
 	if (pvt->inject.param < 0)				\
 		return sprintf(data, "any\n");			\
 	else							\
@@ -1059,7 +1059,7 @@ static ssize_t i7core_show_counter_##param(			\
 	struct mem_ctl_info *mci = to_mci(dev);			\
 	struct i7core_pvt *pvt = mci->pvt_info;			\
 								\
-	debugf1("%s()\n", __func__);				\
+	debugf1("\n");				\
 	if (!pvt->ce_count_available || (pvt->is_registered))	\
 		return sprintf(data, "data unavailable\n");	\
 	return sprintf(data, "%lu\n",				\
@@ -1190,8 +1190,7 @@ static int i7core_create_sysfs_devices(struct mem_ctl_info *mci)
 	dev_set_name(pvt->addrmatch_dev, "inject_addrmatch");
 	dev_set_drvdata(pvt->addrmatch_dev, mci);
 
-	debugf1("%s(): creating %s\n", __func__,
-		dev_name(pvt->addrmatch_dev));
+	debugf1("creating %s\n", dev_name(pvt->addrmatch_dev));
 
 	rc = device_add(pvt->addrmatch_dev);
 	if (rc < 0)
@@ -1213,8 +1212,7 @@ static int i7core_create_sysfs_devices(struct mem_ctl_info *mci)
 		dev_set_name(pvt->chancounts_dev, "all_channel_counts");
 		dev_set_drvdata(pvt->chancounts_dev, mci);
 
-		debugf1("%s(): creating %s\n", __func__,
-			dev_name(pvt->chancounts_dev));
+		debugf1("creating %s\n", dev_name(pvt->chancounts_dev));
 
 		rc = device_add(pvt->chancounts_dev);
 		if (rc < 0)
@@ -1254,7 +1252,7 @@ static void i7core_put_devices(struct i7core_dev *i7core_dev)
 {
 	int i;
 
-	debugf0(__FILE__ ": %s()\n", __func__);
+	debugf0("\n");
 	for (i = 0; i < i7core_dev->n_devs; i++) {
 		struct pci_dev *pdev = i7core_dev->pdev[i];
 		if (!pdev)
@@ -1652,7 +1650,7 @@ static void i7core_udimm_check_mc_ecc_err(struct mem_ctl_info *mci)
 	int new0, new1, new2;
 
 	if (!pvt->pci_mcr[4]) {
-		debugf0("%s MCR registers not found\n", __func__);
+		debugf0("MCR registers not found\n");
 		return;
 	}
 
@@ -2190,8 +2188,7 @@ static void i7core_unregister_mci(struct i7core_dev *i7core_dev)
 	struct i7core_pvt *pvt;
 
 	if (unlikely(!mci || !mci->pvt_info)) {
-		debugf0("MC: " __FILE__ ": %s(): dev = %p\n",
-			__func__, &i7core_dev->pdev[0]->dev);
+		debugf0("MC: dev = %p\n", &i7core_dev->pdev[0]->dev);
 
 		i7core_printk(KERN_ERR, "Couldn't find mci handler\n");
 		return;
@@ -2199,8 +2196,7 @@ static void i7core_unregister_mci(struct i7core_dev *i7core_dev)
 
 	pvt = mci->pvt_info;
 
-	debugf0("MC: " __FILE__ ": %s(): mci = %p, dev = %p\n",
-		__func__, mci, &i7core_dev->pdev[0]->dev);
+	debugf0("MC: mci = %p, dev = %p\n", mci, &i7core_dev->pdev[0]->dev);
 
 	/* Disable scrubrate setting */
 	if (pvt->enable_scrub)
@@ -2241,8 +2237,7 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 	if (unlikely(!mci))
 		return -ENOMEM;
 
-	debugf0("MC: " __FILE__ ": %s(): mci = %p, dev = %p\n",
-		__func__, mci, &i7core_dev->pdev[0]->dev);
+	debugf0("MC: mci = %p, dev = %p\n", mci, &i7core_dev->pdev[0]->dev);
 
 	pvt = mci->pvt_info;
 	memset(pvt, 0, sizeof(*pvt));
@@ -2285,8 +2280,7 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 
 	/* add this new MC control structure to EDAC's list of MCs */
 	if (unlikely(edac_mc_add_mc(mci))) {
-		debugf0("MC: " __FILE__
-			": %s(): failed edac_mc_add_mc()\n", __func__);
+		debugf0("MC: failed edac_mc_add_mc()\n");
 		/* FIXME: perhaps some code should go here that disables error
 		 * reporting if we just enabled it
 		 */
@@ -2295,8 +2289,7 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 		goto fail0;
 	}
 	if (i7core_create_sysfs_devices(mci)) {
-		debugf0("MC: " __FILE__
-			": %s(): failed to create sysfs nodes\n", __func__);
+		debugf0("MC: failed to create sysfs nodes\n");
 		edac_mc_del_mc(mci->pdev);
 		rc = -EINVAL;
 		goto fail0;
@@ -2402,7 +2395,7 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 {
 	struct i7core_dev *i7core_dev;
 
-	debugf0(__FILE__ ": %s()\n", __func__);
+	debugf0("\n");
 
 	/*
 	 * we have a trouble here: pdev value for removal will be wrong, since
@@ -2451,7 +2444,7 @@ static int __init i7core_init(void)
 {
 	int pci_rc;
 
-	debugf2("MC: " __FILE__ ": %s()\n", __func__);
+	debugf2("\n");
 
 	/* Ensure that the OPSTATE is set correctly for POLL or NMI */
 	opstate_init();
@@ -2476,7 +2469,7 @@ static int __init i7core_init(void)
  */
 static void __exit i7core_exit(void)
 {
-	debugf2("MC: " __FILE__ ": %s()\n", __func__);
+	debugf2("\n");
 	pci_unregister_driver(&i7core_driver);
 }
 

commit 356f0a30860d44de7ac021708caa0c8bd5688dbe
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Mar 30 16:10:51 2012 -0300

    i7core_edac: change the mem allocation scheme to make Documentation/kobject.txt happy
    
    Kernel kobjects have rigid rules: each container object should be
    dynamically allocated, and can't be allocated into a single kmalloc.
    
    EDAC never obeyed this rule: it has a single malloc function that
    allocates all needed data into a single kzalloc.
    
    As this is not accepted anymore, change the allocation schema of the
    EDAC *_info structs to enforce this Kernel standard.
    
    Cc: Aristeu Rozanski <arozansk@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index ab3b84b906b9..c29944fbb7d8 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -248,7 +248,7 @@ struct i7core_dev {
 };
 
 struct i7core_pvt {
-	struct device addrmatch_dev, chancounts_dev;
+	struct device *addrmatch_dev, *chancounts_dev;
 
 	struct pci_dev	*pci_noncore;
 	struct pci_dev	*pci_mcr[MAX_MCR_FUNC + 1];
@@ -1105,6 +1105,7 @@ static const struct attribute_group *addrmatch_groups[] = {
 static void addrmatch_release(struct device *device)
 {
 	debugf1("Releasing device %s\n", dev_name(device));
+	kfree(device);
 }
 
 static struct device_type addrmatch_type = {
@@ -1135,6 +1136,7 @@ static const struct attribute_group *all_channel_counts_groups[] = {
 static void all_channel_counts_release(struct device *device)
 {
 	debugf1("Releasing device %s\n", dev_name(device));
+	kfree(device);
 }
 
 static struct device_type all_channel_counts_type = {
@@ -1177,32 +1179,44 @@ static int i7core_create_sysfs_devices(struct mem_ctl_info *mci)
 	if (rc < 0)
 		return rc;
 
-	pvt->addrmatch_dev.type = &addrmatch_type;
-	pvt->addrmatch_dev.bus = mci->dev.bus;
-	device_initialize(&pvt->addrmatch_dev);
-	pvt->addrmatch_dev.parent = &mci->dev;
-	dev_set_name(&pvt->addrmatch_dev, "inject_addrmatch");
-	dev_set_drvdata(&pvt->addrmatch_dev, mci);
+	pvt->addrmatch_dev = kzalloc(sizeof(*pvt->addrmatch_dev), GFP_KERNEL);
+	if (!pvt->addrmatch_dev)
+		return rc;
+
+	pvt->addrmatch_dev->type = &addrmatch_type;
+	pvt->addrmatch_dev->bus = mci->dev.bus;
+	device_initialize(pvt->addrmatch_dev);
+	pvt->addrmatch_dev->parent = &mci->dev;
+	dev_set_name(pvt->addrmatch_dev, "inject_addrmatch");
+	dev_set_drvdata(pvt->addrmatch_dev, mci);
 
 	debugf1("%s(): creating %s\n", __func__,
-		dev_name(&pvt->addrmatch_dev));
+		dev_name(pvt->addrmatch_dev));
 
-	rc = device_add(&pvt->addrmatch_dev);
+	rc = device_add(pvt->addrmatch_dev);
 	if (rc < 0)
 		return rc;
 
 	if (!pvt->is_registered) {
-		pvt->chancounts_dev.type = &all_channel_counts_type;
-		pvt->chancounts_dev.bus = mci->dev.bus;
-		device_initialize(&pvt->chancounts_dev);
-		pvt->chancounts_dev.parent = &mci->dev;
-		dev_set_name(&pvt->chancounts_dev, "all_channel_counts");
-		dev_set_drvdata(&pvt->chancounts_dev, mci);
+		pvt->chancounts_dev = kzalloc(sizeof(*pvt->chancounts_dev),
+					      GFP_KERNEL);
+		if (!pvt->chancounts_dev) {
+			put_device(pvt->addrmatch_dev);
+			device_del(pvt->addrmatch_dev);
+			return rc;
+		}
+
+		pvt->chancounts_dev->type = &all_channel_counts_type;
+		pvt->chancounts_dev->bus = mci->dev.bus;
+		device_initialize(pvt->chancounts_dev);
+		pvt->chancounts_dev->parent = &mci->dev;
+		dev_set_name(pvt->chancounts_dev, "all_channel_counts");
+		dev_set_drvdata(pvt->chancounts_dev, mci);
 
 		debugf1("%s(): creating %s\n", __func__,
-			dev_name(&pvt->chancounts_dev));
+			dev_name(pvt->chancounts_dev));
 
-		rc = device_add(&pvt->chancounts_dev);
+		rc = device_add(pvt->chancounts_dev);
 		if (rc < 0)
 			return rc;
 	}
@@ -1221,11 +1235,11 @@ static void i7core_delete_sysfs_devices(struct mem_ctl_info *mci)
 	device_remove_file(&mci->dev, &dev_attr_inject_enable);
 
 	if (!pvt->is_registered) {
-		put_device(&pvt->chancounts_dev);
-		device_del(&pvt->chancounts_dev);
+		put_device(pvt->chancounts_dev);
+		device_del(pvt->chancounts_dev);
 	}
-	put_device(&pvt->addrmatch_dev);
-	device_del(&pvt->addrmatch_dev);
+	put_device(pvt->addrmatch_dev);
+	device_del(pvt->addrmatch_dev);
 }
 
 /****************************************************************************

commit 5c4cdb5ae72988ef93f72ad6f46be0e4eea5be8d
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Mar 21 11:08:06 2012 -0300

    i7core_edac: convert it to use struct device
    
    Instead of relying on a complex logic inside the edac core to create
    a "device tree-like" sysfs struct, just use device_add.
    
    Reviewed-by: Aristeu Rozanski <arozansk@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 598d215f7bd5..ab3b84b906b9 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -248,6 +248,8 @@ struct i7core_dev {
 };
 
 struct i7core_pvt {
+	struct device addrmatch_dev, chancounts_dev;
+
 	struct pci_dev	*pci_noncore;
 	struct pci_dev	*pci_mcr[MAX_MCR_FUNC + 1];
 	struct pci_dev	*pci_ch[NUM_CHANS][MAX_CHAN_FUNC + 1];
@@ -662,6 +664,8 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 			Error insertion routines
  ****************************************************************************/
 
+#define to_mci(k) container_of(k, struct mem_ctl_info, dev)
+
 /* The i7core has independent error injection features per channel.
    However, to have a simpler code, we don't allow enabling error injection
    on more than one channel.
@@ -691,9 +695,11 @@ static int disable_inject(const struct mem_ctl_info *mci)
  *	bit 0 - refers to the lower 32-byte half cacheline
  *	bit 1 - refers to the upper 32-byte half cacheline
  */
-static ssize_t i7core_inject_section_store(struct mem_ctl_info *mci,
+static ssize_t i7core_inject_section_store(struct device *dev,
+					   struct device_attribute *mattr,
 					   const char *data, size_t count)
 {
+	struct mem_ctl_info *mci = to_mci(dev);
 	struct i7core_pvt *pvt = mci->pvt_info;
 	unsigned long value;
 	int rc;
@@ -709,9 +715,11 @@ static ssize_t i7core_inject_section_store(struct mem_ctl_info *mci,
 	return count;
 }
 
-static ssize_t i7core_inject_section_show(struct mem_ctl_info *mci,
-					      char *data)
+static ssize_t i7core_inject_section_show(struct device *dev,
+					  struct device_attribute *mattr,
+					  char *data)
 {
+	struct mem_ctl_info *mci = to_mci(dev);
 	struct i7core_pvt *pvt = mci->pvt_info;
 	return sprintf(data, "0x%08x\n", pvt->inject.section);
 }
@@ -724,10 +732,12 @@ static ssize_t i7core_inject_section_show(struct mem_ctl_info *mci,
  *	bit 1 - inject ECC error
  *	bit 2 - inject parity error
  */
-static ssize_t i7core_inject_type_store(struct mem_ctl_info *mci,
+static ssize_t i7core_inject_type_store(struct device *dev,
+					struct device_attribute *mattr,
 					const char *data, size_t count)
 {
-	struct i7core_pvt *pvt = mci->pvt_info;
+	struct mem_ctl_info *mci = to_mci(dev);
+struct i7core_pvt *pvt = mci->pvt_info;
 	unsigned long value;
 	int rc;
 
@@ -742,10 +752,13 @@ static ssize_t i7core_inject_type_store(struct mem_ctl_info *mci,
 	return count;
 }
 
-static ssize_t i7core_inject_type_show(struct mem_ctl_info *mci,
-					      char *data)
+static ssize_t i7core_inject_type_show(struct device *dev,
+				       struct device_attribute *mattr,
+				       char *data)
 {
+	struct mem_ctl_info *mci = to_mci(dev);
 	struct i7core_pvt *pvt = mci->pvt_info;
+
 	return sprintf(data, "0x%08x\n", pvt->inject.type);
 }
 
@@ -759,9 +772,11 @@ static ssize_t i7core_inject_type_show(struct mem_ctl_info *mci,
  *   23:16 and 31:24). Flipping bits in two symbol pairs will cause an
  *   uncorrectable error to be injected.
  */
-static ssize_t i7core_inject_eccmask_store(struct mem_ctl_info *mci,
-					const char *data, size_t count)
+static ssize_t i7core_inject_eccmask_store(struct device *dev,
+					   struct device_attribute *mattr,
+					   const char *data, size_t count)
 {
+	struct mem_ctl_info *mci = to_mci(dev);
 	struct i7core_pvt *pvt = mci->pvt_info;
 	unsigned long value;
 	int rc;
@@ -777,10 +792,13 @@ static ssize_t i7core_inject_eccmask_store(struct mem_ctl_info *mci,
 	return count;
 }
 
-static ssize_t i7core_inject_eccmask_show(struct mem_ctl_info *mci,
-					      char *data)
+static ssize_t i7core_inject_eccmask_show(struct device *dev,
+					  struct device_attribute *mattr,
+					  char *data)
 {
+	struct mem_ctl_info *mci = to_mci(dev);
 	struct i7core_pvt *pvt = mci->pvt_info;
+
 	return sprintf(data, "0x%08x\n", pvt->inject.eccmask);
 }
 
@@ -797,9 +815,11 @@ static ssize_t i7core_inject_eccmask_show(struct mem_ctl_info *mci,
 
 #define DECLARE_ADDR_MATCH(param, limit)			\
 static ssize_t i7core_inject_store_##param(			\
-		struct mem_ctl_info *mci,			\
-		const char *data, size_t count)			\
+	struct device *dev,					\
+	struct device_attribute *mattr,				\
+	const char *data, size_t count)				\
 {								\
+	struct mem_ctl_info *mci = to_mci(dev);			\
 	struct i7core_pvt *pvt;					\
 	long value;						\
 	int rc;							\
@@ -824,9 +844,11 @@ static ssize_t i7core_inject_store_##param(			\
 }								\
 								\
 static ssize_t i7core_inject_show_##param(			\
-		struct mem_ctl_info *mci,			\
-		char *data)					\
+	struct device *dev,					\
+	struct device_attribute *mattr,				\
+	char *data)						\
 {								\
+	struct mem_ctl_info *mci = to_mci(dev);			\
 	struct i7core_pvt *pvt;					\
 								\
 	pvt = mci->pvt_info;					\
@@ -838,14 +860,9 @@ static ssize_t i7core_inject_show_##param(			\
 }
 
 #define ATTR_ADDR_MATCH(param)					\
-	{							\
-		.attr = {					\
-			.name = #param,				\
-			.mode = (S_IRUGO | S_IWUSR)		\
-		},						\
-		.show  = i7core_inject_show_##param,		\
-		.store = i7core_inject_store_##param,		\
-	}
+	static DEVICE_ATTR(param, S_IRUGO | S_IWUSR,		\
+		    i7core_inject_show_##param,			\
+		    i7core_inject_store_##param)
 
 DECLARE_ADDR_MATCH(channel, 3);
 DECLARE_ADDR_MATCH(dimm, 3);
@@ -854,6 +871,13 @@ DECLARE_ADDR_MATCH(bank, 32);
 DECLARE_ADDR_MATCH(page, 0x10000);
 DECLARE_ADDR_MATCH(col, 0x4000);
 
+ATTR_ADDR_MATCH(channel);
+ATTR_ADDR_MATCH(dimm);
+ATTR_ADDR_MATCH(rank);
+ATTR_ADDR_MATCH(bank);
+ATTR_ADDR_MATCH(page);
+ATTR_ADDR_MATCH(col);
+
 static int write_and_test(struct pci_dev *dev, const int where, const u32 val)
 {
 	u32 read;
@@ -899,9 +923,11 @@ static int write_and_test(struct pci_dev *dev, const int where, const u32 val)
  *    is reliable enough to check if the MC is using the
  *    three channels. However, this is not clear at the datasheet.
  */
-static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
-				       const char *data, size_t count)
+static ssize_t i7core_inject_enable_store(struct device *dev,
+					  struct device_attribute *mattr,
+					  const char *data, size_t count)
 {
+	struct mem_ctl_info *mci = to_mci(dev);
 	struct i7core_pvt *pvt = mci->pvt_info;
 	u32 injectmask;
 	u64 mask = 0;
@@ -1002,9 +1028,11 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 	return count;
 }
 
-static ssize_t i7core_inject_enable_show(struct mem_ctl_info *mci,
-					char *data)
+static ssize_t i7core_inject_enable_show(struct device *dev,
+					 struct device_attribute *mattr,
+					 char *data)
 {
+	struct mem_ctl_info *mci = to_mci(dev);
 	struct i7core_pvt *pvt = mci->pvt_info;
 	u32 injectmask;
 
@@ -1024,12 +1052,14 @@ static ssize_t i7core_inject_enable_show(struct mem_ctl_info *mci,
 
 #define DECLARE_COUNTER(param)					\
 static ssize_t i7core_show_counter_##param(			\
-		struct mem_ctl_info *mci,			\
-		char *data)					\
+	struct device *dev,					\
+	struct device_attribute *mattr,				\
+	char *data)						\
 {								\
+	struct mem_ctl_info *mci = to_mci(dev);			\
 	struct i7core_pvt *pvt = mci->pvt_info;			\
 								\
-	debugf1("%s() \n", __func__);				\
+	debugf1("%s()\n", __func__);				\
 	if (!pvt->ce_count_available || (pvt->is_registered))	\
 		return sprintf(data, "data unavailable\n");	\
 	return sprintf(data, "%lu\n",				\
@@ -1037,121 +1067,167 @@ static ssize_t i7core_show_counter_##param(			\
 }
 
 #define ATTR_COUNTER(param)					\
-	{							\
-		.attr = {					\
-			.name = __stringify(udimm##param),	\
-			.mode = (S_IRUGO | S_IWUSR)		\
-		},						\
-		.show  = i7core_show_counter_##param		\
-	}
+	static DEVICE_ATTR(udimm##param, S_IRUGO | S_IWUSR,	\
+		    i7core_show_counter_##param,		\
+		    NULL)
 
 DECLARE_COUNTER(0);
 DECLARE_COUNTER(1);
 DECLARE_COUNTER(2);
 
+ATTR_COUNTER(0);
+ATTR_COUNTER(1);
+ATTR_COUNTER(2);
+
 /*
- * Sysfs struct
+ * inject_addrmatch device sysfs struct
  */
 
-static const struct mcidev_sysfs_attribute i7core_addrmatch_attrs[] = {
-	ATTR_ADDR_MATCH(channel),
-	ATTR_ADDR_MATCH(dimm),
-	ATTR_ADDR_MATCH(rank),
-	ATTR_ADDR_MATCH(bank),
-	ATTR_ADDR_MATCH(page),
-	ATTR_ADDR_MATCH(col),
-	{ } /* End of list */
+static struct attribute *i7core_addrmatch_attrs[] = {
+	&dev_attr_channel.attr,
+	&dev_attr_dimm.attr,
+	&dev_attr_rank.attr,
+	&dev_attr_bank.attr,
+	&dev_attr_page.attr,
+	&dev_attr_col.attr,
+	NULL
 };
 
-static const struct mcidev_sysfs_group i7core_inject_addrmatch = {
-	.name  = "inject_addrmatch",
-	.mcidev_attr = i7core_addrmatch_attrs,
+static struct attribute_group addrmatch_grp = {
+	.attrs	= i7core_addrmatch_attrs,
 };
 
-static const struct mcidev_sysfs_attribute i7core_udimm_counters_attrs[] = {
-	ATTR_COUNTER(0),
-	ATTR_COUNTER(1),
-	ATTR_COUNTER(2),
-	{ .attr = { .name = NULL } }
+static const struct attribute_group *addrmatch_groups[] = {
+	&addrmatch_grp,
+	NULL
 };
 
-static const struct mcidev_sysfs_group i7core_udimm_counters = {
-	.name  = "all_channel_counts",
-	.mcidev_attr = i7core_udimm_counters_attrs,
+static void addrmatch_release(struct device *device)
+{
+	debugf1("Releasing device %s\n", dev_name(device));
+}
+
+static struct device_type addrmatch_type = {
+	.groups		= addrmatch_groups,
+	.release	= addrmatch_release,
 };
 
-static const struct mcidev_sysfs_attribute i7core_sysfs_rdimm_attrs[] = {
-	{
-		.attr = {
-			.name = "inject_section",
-			.mode = (S_IRUGO | S_IWUSR)
-		},
-		.show  = i7core_inject_section_show,
-		.store = i7core_inject_section_store,
-	}, {
-		.attr = {
-			.name = "inject_type",
-			.mode = (S_IRUGO | S_IWUSR)
-		},
-		.show  = i7core_inject_type_show,
-		.store = i7core_inject_type_store,
-	}, {
-		.attr = {
-			.name = "inject_eccmask",
-			.mode = (S_IRUGO | S_IWUSR)
-		},
-		.show  = i7core_inject_eccmask_show,
-		.store = i7core_inject_eccmask_store,
-	}, {
-		.grp = &i7core_inject_addrmatch,
-	}, {
-		.attr = {
-			.name = "inject_enable",
-			.mode = (S_IRUGO | S_IWUSR)
-		},
-		.show  = i7core_inject_enable_show,
-		.store = i7core_inject_enable_store,
-	},
-	{ }	/* End of list */
+/*
+ * all_channel_counts sysfs struct
+ */
+
+static struct attribute *i7core_udimm_counters_attrs[] = {
+	&dev_attr_udimm0.attr,
+	&dev_attr_udimm1.attr,
+	&dev_attr_udimm2.attr,
+	NULL
+};
+
+static struct attribute_group all_channel_counts_grp = {
+	.attrs	= i7core_udimm_counters_attrs,
 };
 
-static const struct mcidev_sysfs_attribute i7core_sysfs_udimm_attrs[] = {
-	{
-		.attr = {
-			.name = "inject_section",
-			.mode = (S_IRUGO | S_IWUSR)
-		},
-		.show  = i7core_inject_section_show,
-		.store = i7core_inject_section_store,
-	}, {
-		.attr = {
-			.name = "inject_type",
-			.mode = (S_IRUGO | S_IWUSR)
-		},
-		.show  = i7core_inject_type_show,
-		.store = i7core_inject_type_store,
-	}, {
-		.attr = {
-			.name = "inject_eccmask",
-			.mode = (S_IRUGO | S_IWUSR)
-		},
-		.show  = i7core_inject_eccmask_show,
-		.store = i7core_inject_eccmask_store,
-	}, {
-		.grp = &i7core_inject_addrmatch,
-	}, {
-		.attr = {
-			.name = "inject_enable",
-			.mode = (S_IRUGO | S_IWUSR)
-		},
-		.show  = i7core_inject_enable_show,
-		.store = i7core_inject_enable_store,
-	}, {
-		.grp = &i7core_udimm_counters,
-	},
-	{ }	/* End of list */
+static const struct attribute_group *all_channel_counts_groups[] = {
+	&all_channel_counts_grp,
+	NULL
 };
 
+static void all_channel_counts_release(struct device *device)
+{
+	debugf1("Releasing device %s\n", dev_name(device));
+}
+
+static struct device_type all_channel_counts_type = {
+	.groups		= all_channel_counts_groups,
+	.release	= all_channel_counts_release,
+};
+
+/*
+ * inject sysfs attributes
+ */
+
+static DEVICE_ATTR(inject_section, S_IRUGO | S_IWUSR,
+		   i7core_inject_section_show, i7core_inject_section_store);
+
+static DEVICE_ATTR(inject_type, S_IRUGO | S_IWUSR,
+		   i7core_inject_type_show, i7core_inject_type_store);
+
+
+static DEVICE_ATTR(inject_eccmask, S_IRUGO | S_IWUSR,
+		   i7core_inject_eccmask_show, i7core_inject_eccmask_store);
+
+static DEVICE_ATTR(inject_enable, S_IRUGO | S_IWUSR,
+		   i7core_inject_enable_show, i7core_inject_enable_store);
+
+static int i7core_create_sysfs_devices(struct mem_ctl_info *mci)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	int rc;
+
+	rc = device_create_file(&mci->dev, &dev_attr_inject_section);
+	if (rc < 0)
+		return rc;
+	rc = device_create_file(&mci->dev, &dev_attr_inject_type);
+	if (rc < 0)
+		return rc;
+	rc = device_create_file(&mci->dev, &dev_attr_inject_eccmask);
+	if (rc < 0)
+		return rc;
+	rc = device_create_file(&mci->dev, &dev_attr_inject_enable);
+	if (rc < 0)
+		return rc;
+
+	pvt->addrmatch_dev.type = &addrmatch_type;
+	pvt->addrmatch_dev.bus = mci->dev.bus;
+	device_initialize(&pvt->addrmatch_dev);
+	pvt->addrmatch_dev.parent = &mci->dev;
+	dev_set_name(&pvt->addrmatch_dev, "inject_addrmatch");
+	dev_set_drvdata(&pvt->addrmatch_dev, mci);
+
+	debugf1("%s(): creating %s\n", __func__,
+		dev_name(&pvt->addrmatch_dev));
+
+	rc = device_add(&pvt->addrmatch_dev);
+	if (rc < 0)
+		return rc;
+
+	if (!pvt->is_registered) {
+		pvt->chancounts_dev.type = &all_channel_counts_type;
+		pvt->chancounts_dev.bus = mci->dev.bus;
+		device_initialize(&pvt->chancounts_dev);
+		pvt->chancounts_dev.parent = &mci->dev;
+		dev_set_name(&pvt->chancounts_dev, "all_channel_counts");
+		dev_set_drvdata(&pvt->chancounts_dev, mci);
+
+		debugf1("%s(): creating %s\n", __func__,
+			dev_name(&pvt->chancounts_dev));
+
+		rc = device_add(&pvt->chancounts_dev);
+		if (rc < 0)
+			return rc;
+	}
+	return 0;
+}
+
+static void i7core_delete_sysfs_devices(struct mem_ctl_info *mci)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+
+	debugf1("\n");
+
+	device_remove_file(&mci->dev, &dev_attr_inject_section);
+	device_remove_file(&mci->dev, &dev_attr_inject_type);
+	device_remove_file(&mci->dev, &dev_attr_inject_eccmask);
+	device_remove_file(&mci->dev, &dev_attr_inject_enable);
+
+	if (!pvt->is_registered) {
+		put_device(&pvt->chancounts_dev);
+		device_del(&pvt->chancounts_dev);
+	}
+	put_device(&pvt->addrmatch_dev);
+	device_del(&pvt->addrmatch_dev);
+}
+
 /****************************************************************************
 	Device initialization routines: put/get, init/exit
  ****************************************************************************/
@@ -2122,6 +2198,7 @@ static void i7core_unregister_mci(struct i7core_dev *i7core_dev)
 	i7core_pci_ctl_release(pvt);
 
 	/* Remove MC sysfs nodes */
+	i7core_delete_sysfs_devices(mci);
 	edac_mc_del_mc(mci->pdev);
 
 	debugf1("%s: free mci struct\n", mci->ctl_name);
@@ -2180,10 +2257,6 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 	if (unlikely(rc < 0))
 		goto fail0;
 
-	if (pvt->is_registered)
-		mci->mc_driver_sysfs_attributes = i7core_sysfs_rdimm_attrs;
-	else
-		mci->mc_driver_sysfs_attributes = i7core_sysfs_udimm_attrs;
 
 	/* Get dimm basic config */
 	get_dimm_config(mci);
@@ -2207,6 +2280,13 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 		rc = -EINVAL;
 		goto fail0;
 	}
+	if (i7core_create_sysfs_devices(mci)) {
+		debugf0("MC: " __FILE__
+			": %s(): failed to create sysfs nodes\n", __func__);
+		edac_mc_del_mc(mci->pdev);
+		rc = -EINVAL;
+		goto fail0;
+	}
 
 	/* Default error mask is any memory */
 	pvt->inject.channel = 0;

commit fd687502dc8037aa5a4b84c570ada971106574ee
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Mar 16 07:44:18 2012 -0300

    edac: Rename the parent dev to pdev
    
    As EDAC doesn't use struct device itself, it created a parent dev
    pointer called as "pdev".  Now that we'll be converting it to use
    struct device, instead of struct devsys, this needs to be fixed.
    
    No functional changes.
    
    Reviewed-by: Aristeu Rozanski <arozansk@redhat.com>
    Acked-by: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Doug Thompson <norsk5@yahoo.com>
    Cc: Borislav Petkov <borislav.petkov@amd.com>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: Jason Uhlenkott <juhlenko@akamai.com>
    Cc: Tim Small <tim@buttersideup.com>
    Cc: Ranganathan Desikan <ravi@jetztechnologies.com>
    Cc: "Arvind R." <arvino55@gmail.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Egor Martovetsky <egor@pasemi.com>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Joe Perches <joe@perches.com>
    Cc: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Hitoshi Mitake <h.mitake@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: "Niklas Söderlund" <niklas.soderlund@ericsson.com>
    Cc: Shaohui Xie <Shaohui.Xie@freescale.com>
    Cc: Josh Boyer <jwboyer@gmail.com>
    Cc: linuxppc-dev@lists.ozlabs.org
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index c05e1ada7a3d..598d215f7bd5 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -2122,7 +2122,7 @@ static void i7core_unregister_mci(struct i7core_dev *i7core_dev)
 	i7core_pci_ctl_release(pvt);
 
 	/* Remove MC sysfs nodes */
-	edac_mc_del_mc(mci->dev);
+	edac_mc_del_mc(mci->pdev);
 
 	debugf1("%s: free mci struct\n", mci->ctl_name);
 	kfree(mci->ctl_name);
@@ -2188,7 +2188,7 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 	/* Get dimm basic config */
 	get_dimm_config(mci);
 	/* record ptr to the generic device */
-	mci->dev = &i7core_dev->pdev[0]->dev;
+	mci->pdev = &i7core_dev->pdev[0]->dev;
 	/* Set the function pointer to an actual operation function */
 	mci->edac_check = i7core_check_error;
 

commit e35fca4791fcdd43dc1fd769797df40c562ab491
Author: Chen Gong <gong.chen@linux.intel.com>
Date:   Tue May 8 20:40:12 2012 -0300

    edac: avoid mce decoding crash after edac driver unloaded
    
    Some edac drivers register themselves as mce decoders via
    notifier_chain. But in current notifier_chain implementation logic,
    it doesn't accept same notifier registered twice. If so, it will be
    wrong when adding/removing the element from the list. For example,
    on one SandyBridge platform, remove module sb_edac and then trigger
    one error, it will hit oops because it has no mce decoder registered
    but related notifier_chain still points to an invalid callback
    function. Here is an example:
    
    Call Trace:
     [<ffffffff8150ef6a>] atomic_notifier_call_chain+0x1a/0x20
     [<ffffffff8102b936>] mce_log+0x46/0x180
     [<ffffffff8102eaea>] apei_mce_report_mem_error+0x4a/0x60
     [<ffffffff812e19d2>] ghes_do_proc+0x192/0x210
     [<ffffffff812e2066>] ghes_proc+0x46/0x70
     [<ffffffff812e20d8>] ghes_notify_sci+0x48/0x80
     [<ffffffff8150ef05>] notifier_call_chain+0x55/0x80
     [<ffffffff81076f1a>] __blocking_notifier_call_chain+0x5a/0x80
     [<ffffffff812aea11>] ? acpi_os_wait_events_complete+0x23/0x23
     [<ffffffff81076f56>] blocking_notifier_call_chain+0x16/0x20
     [<ffffffff812ddc4d>] acpi_hed_notify+0x19/0x1b
     [<ffffffff812b16bd>] acpi_device_notify+0x19/0x1b
     [<ffffffff812beb38>] acpi_ev_notify_dispatch+0x67/0x7f
     [<ffffffff812aea3a>] acpi_os_execute_deferred+0x29/0x36
     [<ffffffff81069dc2>] process_one_work+0x132/0x450
     [<ffffffff8106bbcb>] worker_thread+0x17b/0x3c0
     [<ffffffff8106ba50>] ? manage_workers+0x120/0x120
     [<ffffffff81070aee>] kthread+0x9e/0xb0
     [<ffffffff81514724>] kernel_thread_helper+0x4/0x10
     [<ffffffff81070a50>] ? kthread_freezable_should_stop+0x70/0x70
     [<ffffffff81514720>] ? gs_change+0x13/0x13
    Code: f3 49 89 d4 45 85 ed 4d 89 c6 48 8b 0f 74 48 48 85 c9 75 17 eb 41
    0f 1f 80 00 00 00 00 41 83 ed 01 4c 89 f9 74 22 4d 85 ff 74 1d <4c> 8b
    79 08 4c 89 e2 48 89 de 48 89 cf ff 11 4d 85 f6 74 04 41
    RIP  [<ffffffff8150eef6>] notifier_call_chain+0x46/0x80
     RSP <ffff88042868fb20>
    CR2: ffffffffa01af838
    ---[ end trace 0100930068e73e6f ]---
    BUG: unable to handle kernel paging request at fffffffffffffff8
    IP: [<ffffffff810705b0>] kthread_data+0x10/0x20
    PGD 1a0d067 PUD 1a0e067 PMD 0
    Oops: 0000 [#2] SMP
    
    Only i7core_edac and sb_edac have such issues because they have more
    than one memory controller which means they have to register mce
    decoder many times.
    
    Cc: <stable@vger.kernel.org> # 3.2 and upper
    Signed-off-by: Chen Gong <gong.chen@linux.intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index d27778f65a5d..a499c7ed820a 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1814,12 +1814,6 @@ static int i7core_mce_check_error(struct notifier_block *nb, unsigned long val,
 	if (mce->bank != 8)
 		return NOTIFY_DONE;
 
-#ifdef CONFIG_SMP
-	/* Only handle if it is the right mc controller */
-	if (mce->socketid != pvt->i7core_dev->socket)
-		return NOTIFY_DONE;
-#endif
-
 	smp_rmb();
 	if ((pvt->mce_out + 1) % MCE_LOG_LEN == pvt->mce_in) {
 		smp_wmb();
@@ -2116,8 +2110,6 @@ static void i7core_unregister_mci(struct i7core_dev *i7core_dev)
 	if (pvt->enable_scrub)
 		disable_sdram_scrub_setting(mci);
 
-	mce_unregister_decode_chain(&i7_mce_dec);
-
 	/* Disable EDAC polling */
 	i7core_pci_ctl_release(pvt);
 
@@ -2222,8 +2214,6 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 	/* DCLK for scrub rate setting */
 	pvt->dclk_freq = get_dclk_freq();
 
-	mce_register_decode_chain(&i7_mce_dec);
-
 	return 0;
 
 fail0:
@@ -2367,8 +2357,10 @@ static int __init i7core_init(void)
 
 	pci_rc = pci_register_driver(&i7core_driver);
 
-	if (pci_rc >= 0)
+	if (pci_rc >= 0) {
+		mce_register_decode_chain(&i7_mce_dec);
 		return 0;
+	}
 
 	i7core_printk(KERN_ERR, "Failed to register device with error %d.\n",
 		      pci_rc);
@@ -2384,6 +2376,7 @@ static void __exit i7core_exit(void)
 {
 	debugf2("MC: " __FILE__ ": %s()\n", __func__);
 	pci_unregister_driver(&i7core_driver);
+	mce_unregister_decode_chain(&i7_mce_dec);
 }
 
 module_init(i7core_init);

commit 87a5af24e54857e7b15c1f1b0468512ee65c94e3
Merge: 7e5b2db77b05 0bf09e829dd4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 29 18:32:37 2012 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-edac
    
    Pull EDAC internal API changes from Mauro Carvalho Chehab:
     "This changeset is the first part of a series of patches that fixes the
      EDAC sybsystem.  On this set, it changes the Kernel EDAC API in order
      to properly represent the Intel i3/i5/i7, Xeon 3xxx/5xxx/7xxx, and
      Intel E5-xxxx memory controllers.
    
      The EDAC core used to assume that:
    
           - the DRAM chip select pin is directly accessed by the memory
             controller
    
           - when multiple channels are used, they're all filled with the
             same type of memory.
    
      None of the above premises is true on Intel memory controllers since
      2002, when RAMBUS and FB-DIMMs were introduced, and Advanced Memory
      Buffer or by some similar technologies hides the direct access to the
      DRAM pins.
    
      So, the existing drivers for those chipsets had to lie to the EDAC
      core, in general telling that just one channel is filled.  That
      produces some hard to understand error messages like:
    
           EDAC MC0: CE row 3, channel 0, label "DIMM1": 1 Unknown error(s): memory read error on FATAL area : cpu=0 Err=0008:00c2 (ch=2), addr = 0xad1f73480 => socket=0, Channel=0(mask=2), rank=1
    
      The location information there (row3 channel 0) is completely bogus:
      it has no physical meaning, and are just some random values that the
      driver uses to talk with the EDAC core.  The error actually happened
      at CPU socket 0, channel 0, slot 1, but this is not reported anywhere,
      as the EDAC core doesn't know anything about the memory layout.  So,
      only advanced users that know how the EDAC driver works and that tests
      their systems to see how DIMMs are mapped can actually benefit for
      such error logs.
    
      This patch series fixes the error report logic, in order to allow the
      EDAC to expose the memory architecture used by them to the EDAC core.
      So, as the EDAC core now understands how the memory is organized, it
      can provide an useful report:
    
           EDAC MC0: CE memory read error on DIMM1 (channel:0 slot:1 page:0x364b1b offset:0x600 grain:32 syndrome:0x0 - count:1 area:DRAM err_code:0001:0090 socket:0 channel_mask:1 rank:4)
    
      The location of the DIMM where the error happened is reported by "MC0"
      (cpu socket #0), at "channel:0 slot:1" location, and matches the
      physical location of the DIMM.
    
      There are two remaining issues not covered by this patch series:
    
           - The EDAC sysfs API will still report bogus values.  So,
             userspace tools like edac-utils will still use the bogus data;
    
           - Add a new tracepoint-based way to get the binary information
             about the errors.
    
      Those are on a second series of patches (also at -next), but will
      probably miss the train for 3.5, due to the slow review process."
    
    Fix up trivial conflict (due to spelling correction of removed code) in
    drivers/edac/edac_device.c
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-edac: (42 commits)
      i7core: fix ranks information at the per-channel struct
      i5000: Fix the fatal error handling
      i5100_edac: Fix a warning when compiled with 32 bits
      i82975x_edac: Test nr_pages earlier to save a few CPU cycles
      e752x_edac: provide more info about how DIMMS/ranks are mapped
      i5000_edac: Fix the logic that retrieves memory information
      i5400_edac: improve debug messages to better represent the filled memory
      edac: Cleanup the logs for i7core and sb edac drivers
      edac: Initialize the dimm label with the known information
      edac: Remove the legacy EDAC ABI
      x38_edac: convert driver to use the new edac ABI
      tile_edac: convert driver to use the new edac ABI
      sb_edac: convert driver to use the new edac ABI
      r82600_edac: convert driver to use the new edac ABI
      ppc4xx_edac: convert driver to use the new edac ABI
      pasemi_edac: convert driver to use the new edac ABI
      mv64x60_edac: convert driver to use the new edac ABI
      mpc85xx_edac: convert driver to use the new edac ABI
      i82975x_edac: convert driver to use the new edac ABI
      i82875p_edac: convert driver to use the new edac ABI
      ...

commit 0bf09e829dd4b07227ed5a8bc4ac85752a044458
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Apr 26 11:47:29 2012 -0300

    i7core: fix ranks information at the per-channel struct
    
    There is a flag at the per-channel struct that indicates if there are
    any 4R dimm on it. The way the presence of this flag were reported
    is not ok, as it might give the false idea that the channel were filled
    with 2R memories:
    
    [  580.588701] EDAC DEBUG: get_dimm_config: Ch1 phy rd1, wr1 (0x063f7431): 2 ranks, UDIMMs
    [  580.588704] EDAC DEBUG: get_dimm_config:     dimm 0 1024 Mb offset: 0, bank: 8, rank: 1, row: 0x4000, col: 0x400
    
    (in this case, just one 1R memory is filled on channel 1)
    
    So, use a better way to represent the per-channel ranks information.
    After the patch, it will show:
    
    [ 2002.233978] EDAC DEBUG: get_dimm_config: Ch0 phy rd0, wr0 (0x063f7431): UDIMMs
    [ 2002.233982] EDAC DEBUG: get_dimm_config:     dimm 0 1024 Mb offset: 0, bank: 8, rank: 1, row: 0x4000, col: 0x400
    [ 2002.233988] EDAC DEBUG: get_dimm_config:     dimm 1 1024 Mb offset: 4, bank: 8, rank: 1, row: 0x4000, col: 0x400
    
    (in this case, there isn't any 4R memories)
    
    Reported-by: Borislav Petkov <borislav.petkov@amd.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 2aacd951d41c..c05e1ada7a3d 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -221,7 +221,9 @@ struct i7core_inject {
 };
 
 struct i7core_channel {
-	u32		ranks;
+	bool		is_3dimms_present;
+	bool		is_single_4rank;
+	bool		has_4rank;
 	u32		dimms;
 };
 
@@ -555,21 +557,20 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 		pci_read_config_dword(pvt->pci_ch[i][0],
 				MC_CHANNEL_DIMM_INIT_PARAMS, &data);
 
-		pvt->channel[i].ranks = (data & QUAD_RANK_PRESENT) ?
-						4 : 2;
+
+		if (data & THREE_DIMMS_PRESENT)
+			pvt->channel[i].is_3dimms_present = true;
+
+		if (data & SINGLE_QUAD_RANK_PRESENT)
+			pvt->channel[i].is_single_4rank = true;
+
+		if (data & QUAD_RANK_PRESENT)
+			pvt->channel[i].has_4rank = true;
 
 		if (data & REGISTERED_DIMM)
 			mtype = MEM_RDDR3;
 		else
 			mtype = MEM_DDR3;
-#if 0
-		if (data & THREE_DIMMS_PRESENT)
-			pvt->channel[i].dimms = 3;
-		else if (data & SINGLE_QUAD_RANK_PRESENT)
-			pvt->channel[i].dimms = 1;
-		else
-			pvt->channel[i].dimms = 2;
-#endif
 
 		/* Devices 4-6 function 1 */
 		pci_read_config_dword(pvt->pci_ch[i][1],
@@ -580,11 +581,13 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 				MC_DOD_CH_DIMM2, &dimm_dod[2]);
 
 		debugf0("Ch%d phy rd%d, wr%d (0x%08x): "
-			"%d ranks, %cDIMMs\n",
+			"%s%s%s%cDIMMs\n",
 			i,
 			RDLCH(pvt->info.ch_map, i), WRLCH(pvt->info.ch_map, i),
 			data,
-			pvt->channel[i].ranks,
+			pvt->channel[i].is_3dimms_present ? "3DIMMS " : "",
+			pvt->channel[i].is_3dimms_present ? "SINGLE_4R " : "",
+			pvt->channel[i].has_4rank ? "HAS_4R " : "",
 			(data & REGISTERED_DIMM) ? 'R' : 'U');
 
 		for (j = 0; j < 3; j++) {

commit e17a2f42a484562be48128c5b8dc9f7291e8c902
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri May 11 11:41:45 2012 -0300

    edac: Cleanup the logs for i7core and sb edac drivers
    
    Remove some information that it is duplicated at the MCE log,
    and don't have much usage for the error. Those data will be
    added again, when creating a trace function that outputs both
    memory errors and MCE fields.
    
    Cc: Aristeu Rozanski <arozansk@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 6d89c78a9b7a..2aacd951d41c 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1623,7 +1623,7 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 				    const struct mce *m)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
-	char *type, *optype, *err, *msg;
+	char *type, *optype, *err, msg[80];
 	enum hw_event_mc_err_type tp_event;
 	unsigned long error = m->status & 0x1ff0000l;
 	bool uncorrected_error = m->mcgstatus & 1ll << 61;
@@ -1701,10 +1701,7 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 		err = "unknown";
 	}
 
-	msg = kasprintf(GFP_ATOMIC,
-		"addr=0x%08llx cpu=%d count=%d Err=%08llx:%08llx (%s: %s))\n",
-		(long long) m->addr, m->cpu, core_err_cnt,
-		(long long)m->status, (long long)m->misc, optype, err);
+	snprintf(msg, sizeof(msg), "count=%d %s", core_err_cnt, optype);
 
 	/*
 	 * Call the helper to output message
@@ -1718,8 +1715,6 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 				     syndrome,
 				     channel, dimm, -1,
 				     err, msg, m);
-
-	kfree(msg);
 }
 
 /*

commit ca0907b9e413bb1d1f3ea123b663535b74928846
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed May 2 14:37:00 2012 -0300

    edac: Remove the legacy EDAC ABI
    
    Now that all drivers got converted to use the new ABI, we can
    drop the old one.
    
    Acked-by: Chris Metcalf <cmetcalf@tilera.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index bc2c04550b8b..6d89c78a9b7a 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -2147,7 +2147,7 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 	layers[1].type = EDAC_MC_LAYER_SLOT;
 	layers[1].size = MAX_DIMMS;
 	layers[1].is_virt_csrow = true;
-	mci = new_edac_mc_alloc(i7core_dev->socket, ARRAY_SIZE(layers), layers,
+	mci = edac_mc_alloc(i7core_dev->socket, ARRAY_SIZE(layers), layers,
 			    sizeof(*pvt));
 	if (unlikely(!mci))
 		return -ENOMEM;

commit 0975c16f4fa901403708a0d3f19b33a726b10326
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Apr 16 15:10:12 2012 -0300

    i7core_edac: convert driver to use the new edac ABI
    
    The legacy edac ABI is going to be removed. Port the driver to use
    and benefit from the new API functionality.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 0e3cc34bcc22..bc2c04550b8b 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -257,7 +257,6 @@ struct i7core_pvt {
 	struct i7core_channel	channel[NUM_CHANS];
 
 	int		ce_count_available;
-	int 		csrow_map[NUM_CHANS][MAX_DIMMS];
 
 			/* ECC corrected errors counts per udimm */
 	unsigned long	udimm_ce_count[MAX_DIMMS];
@@ -492,113 +491,12 @@ static void free_i7core_dev(struct i7core_dev *i7core_dev)
 /****************************************************************************
 			Memory check routines
  ****************************************************************************/
-static struct pci_dev *get_pdev_slot_func(u8 socket, unsigned slot,
-					  unsigned func)
-{
-	struct i7core_dev *i7core_dev = get_i7core_dev(socket);
-	int i;
-
-	if (!i7core_dev)
-		return NULL;
-
-	for (i = 0; i < i7core_dev->n_devs; i++) {
-		if (!i7core_dev->pdev[i])
-			continue;
-
-		if (PCI_SLOT(i7core_dev->pdev[i]->devfn) == slot &&
-		    PCI_FUNC(i7core_dev->pdev[i]->devfn) == func) {
-			return i7core_dev->pdev[i];
-		}
-	}
-
-	return NULL;
-}
-
-/**
- * i7core_get_active_channels() - gets the number of channels and csrows
- * @socket:	Quick Path Interconnect socket
- * @channels:	Number of channels that will be returned
- * @csrows:	Number of csrows found
- *
- * Since EDAC core needs to know in advance the number of available channels
- * and csrows, in order to allocate memory for csrows/channels, it is needed
- * to run two similar steps. At the first step, implemented on this function,
- * it checks the number of csrows/channels present at one socket.
- * this is used in order to properly allocate the size of mci components.
- *
- * It should be noticed that none of the current available datasheets explain
- * or even mention how csrows are seen by the memory controller. So, we need
- * to add a fake description for csrows.
- * So, this driver is attributing one DIMM memory for one csrow.
- */
-static int i7core_get_active_channels(const u8 socket, unsigned *channels,
-				      unsigned *csrows)
-{
-	struct pci_dev *pdev = NULL;
-	int i, j;
-	u32 status, control;
-
-	*channels = 0;
-	*csrows = 0;
-
-	pdev = get_pdev_slot_func(socket, 3, 0);
-	if (!pdev) {
-		i7core_printk(KERN_ERR, "Couldn't find socket %d fn 3.0!!!\n",
-			      socket);
-		return -ENODEV;
-	}
-
-	/* Device 3 function 0 reads */
-	pci_read_config_dword(pdev, MC_STATUS, &status);
-	pci_read_config_dword(pdev, MC_CONTROL, &control);
-
-	for (i = 0; i < NUM_CHANS; i++) {
-		u32 dimm_dod[3];
-		/* Check if the channel is active */
-		if (!(control & (1 << (8 + i))))
-			continue;
-
-		/* Check if the channel is disabled */
-		if (status & (1 << i))
-			continue;
-
-		pdev = get_pdev_slot_func(socket, i + 4, 1);
-		if (!pdev) {
-			i7core_printk(KERN_ERR, "Couldn't find socket %d "
-						"fn %d.%d!!!\n",
-						socket, i + 4, 1);
-			return -ENODEV;
-		}
-		/* Devices 4-6 function 1 */
-		pci_read_config_dword(pdev,
-				MC_DOD_CH_DIMM0, &dimm_dod[0]);
-		pci_read_config_dword(pdev,
-				MC_DOD_CH_DIMM1, &dimm_dod[1]);
-		pci_read_config_dword(pdev,
-				MC_DOD_CH_DIMM2, &dimm_dod[2]);
-
-		(*channels)++;
-
-		for (j = 0; j < 3; j++) {
-			if (!DIMM_PRESENT(dimm_dod[j]))
-				continue;
-			(*csrows)++;
-		}
-	}
-
-	debugf0("Number of active channels on socket %d: %d\n",
-		socket, *channels);
-
-	return 0;
-}
 
 static int get_dimm_config(struct mem_ctl_info *mci)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
-	struct csrow_info *csr;
 	struct pci_dev *pdev;
 	int i, j;
-	int csrow = 0;
 	enum edac_type mode;
 	enum mem_type mtype;
 	struct dimm_info *dimm;
@@ -696,6 +594,8 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 			if (!DIMM_PRESENT(dimm_dod[j]))
 				continue;
 
+			dimm = EDAC_DIMM_PTR(mci->layers, mci->dimms, mci->n_layers,
+				       i, j, 0);
 			banks = numbank(MC_DOD_NUMBANK(dimm_dod[j]));
 			ranks = numrank(MC_DOD_NUMRANK(dimm_dod[j]));
 			rows = numrow(MC_DOD_NUMROW(dimm_dod[j]));
@@ -704,8 +604,6 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 			/* DDR3 has 8 I/O banks */
 			size = (rows * cols * banks * ranks) >> (20 - 3);
 
-			pvt->channel[i].dimms++;
-
 			debugf0("\tdimm %d %d Mb offset: %x, "
 				"bank: %d, rank: %d, row: %#x, col: %#x\n",
 				j, size,
@@ -714,11 +612,6 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 
 			npages = MiB_TO_PAGES(size);
 
-			csr = &mci->csrows[csrow];
-
-			pvt->csrow_map[i][j] = csrow;
-
-			dimm = csr->channels[0].dimm;
 			dimm->nr_pages = npages;
 
 			switch (banks) {
@@ -741,7 +634,6 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 			dimm->grain = 8;
 			dimm->edac_mode = mode;
 			dimm->mtype = mtype;
-			csrow++;
 		}
 
 		pci_read_config_dword(pdev, MC_SAG_CH_0, &value[0]);
@@ -1557,22 +1449,16 @@ static int mci_bind_devs(struct mem_ctl_info *mci,
 /****************************************************************************
 			Error check routines
  ****************************************************************************/
-static void i7core_rdimm_update_csrow(struct mem_ctl_info *mci,
+static void i7core_rdimm_update_errcount(struct mem_ctl_info *mci,
 				      const int chan,
 				      const int dimm,
 				      const int add)
 {
-	char *msg;
-	struct i7core_pvt *pvt = mci->pvt_info;
-	int row = pvt->csrow_map[chan][dimm], i;
+	int i;
 
 	for (i = 0; i < add; i++) {
-		msg = kasprintf(GFP_KERNEL, "Corrected error "
-				"(Socket=%d channel=%d dimm=%d)",
-				pvt->i7core_dev->socket, chan, dimm);
-
-		edac_mc_handle_fbd_ce(mci, row, 0, msg);
-		kfree (msg);
+		edac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 0, 0, 0,
+				     chan, dimm, -1, "error", "", NULL);
 	}
 }
 
@@ -1613,11 +1499,11 @@ static void i7core_rdimm_update_ce_count(struct mem_ctl_info *mci,
 
 	/*updated the edac core */
 	if (add0 != 0)
-		i7core_rdimm_update_csrow(mci, chan, 0, add0);
+		i7core_rdimm_update_errcount(mci, chan, 0, add0);
 	if (add1 != 0)
-		i7core_rdimm_update_csrow(mci, chan, 1, add1);
+		i7core_rdimm_update_errcount(mci, chan, 1, add1);
 	if (add2 != 0)
-		i7core_rdimm_update_csrow(mci, chan, 2, add2);
+		i7core_rdimm_update_errcount(mci, chan, 2, add2);
 
 }
 
@@ -1738,19 +1624,29 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	char *type, *optype, *err, *msg;
+	enum hw_event_mc_err_type tp_event;
 	unsigned long error = m->status & 0x1ff0000l;
+	bool uncorrected_error = m->mcgstatus & 1ll << 61;
+	bool ripv = m->mcgstatus & 1;
 	u32 optypenum = (m->status >> 4) & 0x07;
 	u32 core_err_cnt = (m->status >> 38) & 0x7fff;
 	u32 dimm = (m->misc >> 16) & 0x3;
 	u32 channel = (m->misc >> 18) & 0x3;
 	u32 syndrome = m->misc >> 32;
 	u32 errnum = find_first_bit(&error, 32);
-	int csrow;
 
-	if (m->mcgstatus & 1)
-		type = "FATAL";
-	else
-		type = "NON_FATAL";
+	if (uncorrected_error) {
+		if (ripv) {
+			type = "FATAL";
+			tp_event = HW_EVENT_ERR_FATAL;
+		} else {
+			type = "NON_FATAL";
+			tp_event = HW_EVENT_ERR_UNCORRECTED;
+		}
+	} else {
+		type = "CORRECTED";
+		tp_event = HW_EVENT_ERR_CORRECTED;
+	}
 
 	switch (optypenum) {
 	case 0:
@@ -1805,25 +1701,23 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 		err = "unknown";
 	}
 
-	/* FIXME: should convert addr into bank and rank information */
 	msg = kasprintf(GFP_ATOMIC,
-		"%s (addr = 0x%08llx, cpu=%d, Dimm=%d, Channel=%d, "
-		"syndrome=0x%08x, count=%d, Err=%08llx:%08llx (%s: %s))\n",
-		type, (long long) m->addr, m->cpu, dimm, channel,
-		syndrome, core_err_cnt, (long long)m->status,
-		(long long)m->misc, optype, err);
+		"addr=0x%08llx cpu=%d count=%d Err=%08llx:%08llx (%s: %s))\n",
+		(long long) m->addr, m->cpu, core_err_cnt,
+		(long long)m->status, (long long)m->misc, optype, err);
 
-	debugf0("%s", msg);
-
-	csrow = pvt->csrow_map[channel][dimm];
-
-	/* Call the helper to output message */
-	if (m->mcgstatus & 1)
-		edac_mc_handle_fbd_ue(mci, csrow, 0,
-				0 /* FIXME: should be channel here */, msg);
-	else if (!pvt->is_registered)
-		edac_mc_handle_fbd_ce(mci, csrow,
-				0 /* FIXME: should be channel here */, msg);
+	/*
+	 * Call the helper to output message
+	 * FIXME: what to do if core_err_cnt > 1? Currently, it generates
+	 * only one event
+	 */
+	if (uncorrected_error || !pvt->is_registered)
+		edac_mc_handle_error(tp_event, mci,
+				     m->addr >> PAGE_SHIFT,
+				     m->addr & ~PAGE_MASK,
+				     syndrome,
+				     channel, dimm, -1,
+				     err, msg, m);
 
 	kfree(msg);
 }
@@ -2242,15 +2136,19 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 {
 	struct mem_ctl_info *mci;
 	struct i7core_pvt *pvt;
-	int rc, channels, csrows;
-
-	/* Check the number of active and not disabled channels */
-	rc = i7core_get_active_channels(i7core_dev->socket, &channels, &csrows);
-	if (unlikely(rc < 0))
-		return rc;
+	int rc;
+	struct edac_mc_layer layers[2];
 
 	/* allocate a new MC control structure */
-	mci = edac_mc_alloc(sizeof(*pvt), csrows, channels, i7core_dev->socket);
+
+	layers[0].type = EDAC_MC_LAYER_CHANNEL;
+	layers[0].size = NUM_CHANS;
+	layers[0].is_virt_csrow = false;
+	layers[1].type = EDAC_MC_LAYER_SLOT;
+	layers[1].size = MAX_DIMMS;
+	layers[1].is_virt_csrow = true;
+	mci = new_edac_mc_alloc(i7core_dev->socket, ARRAY_SIZE(layers), layers,
+			    sizeof(*pvt));
 	if (unlikely(!mci))
 		return -ENOMEM;
 

commit a895bf8b1e1ea4c032a8fa8a09475a2ce09fe77a
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Jan 28 09:09:38 2012 -0300

    edac: move nr_pages to dimm struct
    
    The number of pages is a dimm property. Move it to the dimm struct.
    
    After this change, it is possible to add sysfs nodes for the DIMM's that
    will properly represent the DIMM stick properties, including its size.
    
    A TODO fix here is to properly represent dual-rank/quad-rank DIMMs when
    the memory controller represents the memory via chip select rows.
    
    Reviewed-by: Aristeu Rozanski <arozansk@redhat.com>
    Acked-by: Borislav Petkov <borislav.petkov@amd.com>
    Acked-by: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Doug Thompson <norsk5@yahoo.com>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: Jason Uhlenkott <juhlenko@akamai.com>
    Cc: Tim Small <tim@buttersideup.com>
    Cc: Ranganathan Desikan <ravi@jetztechnologies.com>
    Cc: "Arvind R." <arvino55@gmail.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Egor Martovetsky <egor@pasemi.com>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Joe Perches <joe@perches.com>
    Cc: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Hitoshi Mitake <h.mitake@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: "Niklas Söderlund" <niklas.soderlund@ericsson.com>
    Cc: Shaohui Xie <Shaohui.Xie@freescale.com>
    Cc: Josh Boyer <jwboyer@gmail.com>
    Cc: linuxppc-dev@lists.ozlabs.org
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 76c957c525fb..0e3cc34bcc22 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -715,17 +715,12 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 			npages = MiB_TO_PAGES(size);
 
 			csr = &mci->csrows[csrow];
-			csr->nr_pages = npages;
-
-			csr->csrow_idx = csrow;
-			csr->nr_channels = 1;
-
-			csr->channels[0].chan_idx = i;
-			csr->channels[0].ce_count = 0;
 
 			pvt->csrow_map[i][j] = csrow;
 
 			dimm = csr->channels[0].dimm;
+			dimm->nr_pages = npages;
+
 			switch (banks) {
 			case 4:
 				dimm->dtype = DEV_X4;
@@ -746,6 +741,7 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 			dimm->grain = 8;
 			dimm->edac_mode = mode;
 			dimm->mtype = mtype;
+			csrow++;
 		}
 
 		pci_read_config_dword(pdev, MC_SAG_CH_0, &value[0]);

commit 5e2af0c09e60d11dd8297e259a9ca2b3d92d2cf4
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Jan 27 21:20:32 2012 -0300

    edac: Don't initialize csrow's first_page & friends when not needed
    
    Almost all edac drivers initialize csrow_info->first_page,
    csrow_info->last_page and csrow_info->page_mask. Those vars are
    used inside the EDAC core, in order to calculate the csrow affected
    by an error, by using the routine edac_mc_find_csrow_by_page().
    
    However, very few drivers actually use it:
            e752x_edac.c
            e7xxx_edac.c
            i3000_edac.c
            i82443bxgx_edac.c
            i82860_edac.c
            i82875p_edac.c
            i82975x_edac.c
            r82600_edac.c
    
    There also a few other drivers that have their own calculus
    formula internally using those vars.
    
    All the others are just wasting time by initializing those
    data.
    
    While initializing data without using them won't cause any troubles, as
    those information is stored at the wrong place (at csrows structure), it
    is better to remove what is unused, in order to simplify the next patch.
    
    Reviewed-by: Aristeu Rozanski <arozansk@redhat.com>
    Acked-by: Borislav Petkov <borislav.petkov@amd.com>
    Acked-by: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Doug Thompson <norsk5@yahoo.com>
    Cc: Hitoshi Mitake <h.mitake@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: "Niklas Söderlund" <niklas.soderlund@ericsson.com>
    Cc: Josh Boyer <jwboyer@gmail.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 5449bd40a739..76c957c525fb 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -599,7 +599,6 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 	struct pci_dev *pdev;
 	int i, j;
 	int csrow = 0;
-	unsigned long last_page = 0;
 	enum edac_type mode;
 	enum mem_type mtype;
 	struct dimm_info *dimm;
@@ -716,12 +715,8 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 			npages = MiB_TO_PAGES(size);
 
 			csr = &mci->csrows[csrow];
-			csr->first_page = last_page + 1;
-			last_page += npages;
-			csr->last_page = last_page;
 			csr->nr_pages = npages;
 
-			csr->page_mask = 0;
 			csr->csrow_idx = csrow;
 			csr->nr_channels = 1;
 

commit 084a4fccef39ac7abb039511f32380f28d0b67e6
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Jan 27 18:38:08 2012 -0300

    edac: move dimm properties to struct dimm_info
    
    On systems based on chip select rows, all channels need to use memories
    with the same properties, otherwise the memories on channels A and B
    won't be recognized.
    
    However, such assumption is not true for all types of memory
    controllers.
    
    Controllers for FB-DIMM's don't have such requirements.
    
    Also, modern Intel controllers seem to be capable of handling such
    differences.
    
    So, we need to get rid of storing the DIMM information into a per-csrow
    data, storing it, instead at the right place.
    
    The first step is to move grain, mtype, dtype and edac_mode to the
    per-dimm struct.
    
    Reviewed-by: Aristeu Rozanski <arozansk@redhat.com>
    Reviewed-by: Borislav Petkov <borislav.petkov@amd.com>
    Acked-by: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Doug Thompson <norsk5@yahoo.com>
    Cc: Borislav Petkov <borislav.petkov@amd.com>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: Jason Uhlenkott <juhlenko@akamai.com>
    Cc: Tim Small <tim@buttersideup.com>
    Cc: Ranganathan Desikan <ravi@jetztechnologies.com>
    Cc: "Arvind R." <arvino55@gmail.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Egor Martovetsky <egor@pasemi.com>
    Cc: Michal Marek <mmarek@suse.cz>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Joe Perches <joe@perches.com>
    Cc: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Hitoshi Mitake <h.mitake@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: James Bottomley <James.Bottomley@parallels.com>
    Cc: "Niklas Söderlund" <niklas.soderlund@ericsson.com>
    Cc: Shaohui Xie <Shaohui.Xie@freescale.com>
    Cc: Josh Boyer <jwboyer@gmail.com>
    Cc: Mike Williams <mike@mikebwilliams.com>
    Cc: linuxppc-dev@lists.ozlabs.org
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index df0acf02667a..5449bd40a739 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -592,7 +592,7 @@ static int i7core_get_active_channels(const u8 socket, unsigned *channels,
 	return 0;
 }
 
-static int get_dimm_config(const struct mem_ctl_info *mci)
+static int get_dimm_config(struct mem_ctl_info *mci)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	struct csrow_info *csr;
@@ -602,6 +602,7 @@ static int get_dimm_config(const struct mem_ctl_info *mci)
 	unsigned long last_page = 0;
 	enum edac_type mode;
 	enum mem_type mtype;
+	struct dimm_info *dimm;
 
 	/* Get data from the MC register, function 0 */
 	pdev = pvt->pci_mcr[0];
@@ -721,7 +722,6 @@ static int get_dimm_config(const struct mem_ctl_info *mci)
 			csr->nr_pages = npages;
 
 			csr->page_mask = 0;
-			csr->grain = 8;
 			csr->csrow_idx = csrow;
 			csr->nr_channels = 1;
 
@@ -730,28 +730,27 @@ static int get_dimm_config(const struct mem_ctl_info *mci)
 
 			pvt->csrow_map[i][j] = csrow;
 
+			dimm = csr->channels[0].dimm;
 			switch (banks) {
 			case 4:
-				csr->dtype = DEV_X4;
+				dimm->dtype = DEV_X4;
 				break;
 			case 8:
-				csr->dtype = DEV_X8;
+				dimm->dtype = DEV_X8;
 				break;
 			case 16:
-				csr->dtype = DEV_X16;
+				dimm->dtype = DEV_X16;
 				break;
 			default:
-				csr->dtype = DEV_UNKNOWN;
+				dimm->dtype = DEV_UNKNOWN;
 			}
 
-			csr->edac_mode = mode;
-			csr->mtype = mtype;
-			snprintf(csr->channels[0].dimm->label,
-					sizeof(csr->channels[0].dimm->label),
-					"CPU#%uChannel#%u_DIMM#%u",
-					pvt->i7core_dev->socket, i, j);
-
-			csrow++;
+			snprintf(dimm->label, sizeof(dimm->label),
+				 "CPU#%uChannel#%u_DIMM#%u",
+				 pvt->i7core_dev->socket, i, j);
+			dimm->grain = 8;
+			dimm->edac_mode = mode;
+			dimm->mtype = mtype;
 		}
 
 		pci_read_config_dword(pdev, MC_SAG_CH_0, &value[0]);

commit a7d7d2e1a07e3811dc49af2962c940fd8bbb6c8f
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Jan 27 14:12:32 2012 -0300

    edac: Create a dimm struct and move the labels into it
    
    The way a DIMM is currently represented implies that they're
    linked into a per-csrow struct. However, some drivers don't see
    csrows, as they're ridden behind some chip like the AMB's
    on FBDIMM's, for example.
    
    This forced drivers to fake^Wvirtualize a csrow struct, and to create
    a mess under csrow/channel original's concept.
    
    Move the DIMM labels into a per-DIMM struct, and add there
    the real location of the socket, in terms of csrow/channel.
    Latter patches will modify the location to properly represent the
    memory architecture.
    
    All other drivers will use a per-csrow type of location.
    Some of those drivers will require a latter conversion, as
    they also fake the csrows internally.
    
    TODO: While this patch doesn't change the existing behavior, on
    csrows-based memory controllers, a csrow/channel pair points to a memory
    rank. There's a known bug at the EDAC core that allows having different
    labels for the same DIMM, if it has more than one rank. A latter patch
    is need to merge the several ranks for a DIMM into the same dimm_info
    struct, in order to avoid having different labels for the same DIMM.
    
    The edac_mc_alloc() will now contain a per-dimm initialization loop that
    will be changed by latter patches in order to match other types of
    memory architectures.
    
    Reviewed-by: Aristeu Rozanski <arozansk@redhat.com>
    Reviewed-by: Borislav Petkov <borislav.petkov@amd.com>
    Cc: Doug Thompson <norsk5@yahoo.com>
    Cc: Ranganathan Desikan <ravi@jetztechnologies.com>
    Cc: "Arvind R." <arvino55@gmail.com>
    Cc: "Niklas Söderlund" <niklas.soderlund@ericsson.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 85226ccf5290..df0acf02667a 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -746,8 +746,8 @@ static int get_dimm_config(const struct mem_ctl_info *mci)
 
 			csr->edac_mode = mode;
 			csr->mtype = mtype;
-			snprintf(csr->channels[0].label,
-					sizeof(csr->channels[0].label),
+			snprintf(csr->channels[0].dimm->label,
+					sizeof(csr->channels[0].dimm->label),
 					"CPU#%uChannel#%u_DIMM#%u",
 					pvt->i7core_dev->socket, i, j);
 

commit 15ed103a98008d85f20956e0e29c2cae78051efe
Author: David Mackey <tdmackey@twitter.com>
Date:   Tue Apr 17 11:30:52 2012 -0700

    edac: Fix spelling errors.
    
    Signed-off-by: David Mackey <tdmackey@twitter.com>
    Signed-off-by: Vinson Lee <vlee@twitter.com>
    Acked-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 85226ccf5290..7f1dfcc4e597 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -90,7 +90,7 @@ MODULE_PARM_DESC(use_pci_fixup, "Enable PCI fixup to seek for hidden devices");
 #define MC_MAX_DOD	0x64
 
 /*
- * OFFSETS for Device 3 Function 4, as inicated on Xeon 5500 datasheet:
+ * OFFSETS for Device 3 Function 4, as indicated on Xeon 5500 datasheet:
  * http://www.arrownac.com/manufacturers/intel/s/nehalem/5500-datasheet-v2.pdf
  */
 
@@ -101,7 +101,7 @@ MODULE_PARM_DESC(use_pci_fixup, "Enable PCI fixup to seek for hidden devices");
   #define DIMM1_COR_ERR(r)			(((r) >> 16) & 0x7fff)
   #define DIMM0_COR_ERR(r)			((r) & 0x7fff)
 
-/* OFFSETS for Device 3 Function 2, as inicated on Xeon 5500 datasheet */
+/* OFFSETS for Device 3 Function 2, as indicated on Xeon 5500 datasheet */
 #define MC_SSRCONTROL		0x48
   #define SSR_MODE_DISABLE	0x00
   #define SSR_MODE_ENABLE	0x01
@@ -398,7 +398,7 @@ static DEFINE_PCI_DEVICE_TABLE(i7core_pci_tbl) = {
 };
 
 /****************************************************************************
-			Anciliary status routines
+			Ancillary status routines
  ****************************************************************************/
 
 	/* MC_CONTROL bits */
@@ -1361,7 +1361,7 @@ static int i7core_get_onedevice(struct pci_dev **prev,
 			      dev_descr->dev_id, *prev);
 
 	/*
-	 * On Xeon 55xx, the Intel Quckpath Arch Generic Non-core regs
+	 * On Xeon 55xx, the Intel QuickPath Arch Generic Non-core regs
 	 * is at addr 8086:2c40, instead of 8086:2c41. So, we need
 	 * to probe for the alternate address in case of failure
 	 */
@@ -2132,7 +2132,7 @@ static int set_sdram_scrub_rate(struct mem_ctl_info *mci, u32 new_bw)
 
 /*
  * get_sdram_scrub_rate		This routine convert current scrub rate value
- *				into byte/sec bandwidth accourding to
+ *				into byte/sec bandwidth according to
  *				SCRUBINTERVAL formula found in datasheet.
  */
 static int get_sdram_scrub_rate(struct mem_ctl_info *mci)

commit 36c46f31df910b092aaaed27c7c616bb8e2302a1
Author: Lionel Debroux <lionel_debroux@yahoo.fr>
Date:   Mon Feb 27 07:41:47 2012 +0100

    EDAC: Make pci_device_id tables __devinitconst.
    
    These const tables are currently marked __devinitdata, but
    Documentation/PCI/pci.txt says:
    
    "o The ID table array should be marked __devinitconst; this is done
    automatically if the table is declared with DEFINE_PCI_DEVICE_TABLE()."
    
    So use DEFINE_PCI_DEVICE_TABLE(x).
    
    Based on PaX and earlier work by Andi Kleen.
    
    Signed-off-by: Lionel Debroux <lionel_debroux@yahoo.fr>
    Signed-off-by: Borislav Petkov <borislav.petkov@amd.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 8568d9b61875..85226ccf5290 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -391,7 +391,7 @@ static const struct pci_id_table pci_dev_table[] = {
 /*
  *	pci_device_id	table for which devices we are looking for
  */
-static const struct pci_device_id i7core_pci_tbl[] __devinitdata = {
+static DEFINE_PCI_DEVICE_TABLE(i7core_pci_tbl) = {
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_X58_HUB_MGMT)},
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_LYNNFIELD_QPI_LINK0)},
 	{0,}			/* 0 terminated list. */

commit 3653ada5d3e173489b3a466305687cb5c44b2ab1
Author: Borislav Petkov <borislav.petkov@amd.com>
Date:   Sun Dec 4 15:12:09 2011 +0100

    x86, mce: Add wrappers for registering on the decode chain
    
    No functionality change, this is done so that in a follow-on patch all
    queued-up MCEs can be decoded after registering on the chain.
    
    Signed-off-by: Borislav Petkov <borislav.petkov@amd.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 70ad8923f1d7..8568d9b61875 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -2234,7 +2234,7 @@ static void i7core_unregister_mci(struct i7core_dev *i7core_dev)
 	if (pvt->enable_scrub)
 		disable_sdram_scrub_setting(mci);
 
-	atomic_notifier_chain_unregister(&x86_mce_decoder_chain, &i7_mce_dec);
+	mce_unregister_decode_chain(&i7_mce_dec);
 
 	/* Disable EDAC polling */
 	i7core_pci_ctl_release(pvt);
@@ -2336,7 +2336,7 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 	/* DCLK for scrub rate setting */
 	pvt->dclk_freq = get_dclk_freq();
 
-	atomic_notifier_chain_register(&x86_mce_decoder_chain, &i7_mce_dec);
+	mce_register_decode_chain(&i7_mce_dec);
 
 	return 0;
 

commit 767ba4a52a6de7ea2875a8af79bf11452a2a0c44
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Sep 16 13:37:29 2011 -0300

    i7core_edac: Initialize memory name with cpu, channel, bank
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 51d251c32901..70ad8923f1d7 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -746,6 +746,10 @@ static int get_dimm_config(const struct mem_ctl_info *mci)
 
 			csr->edac_mode = mode;
 			csr->mtype = mtype;
+			snprintf(csr->channels[0].label,
+					sizeof(csr->channels[0].label),
+					"CPU#%uChannel#%u_DIMM#%u",
+					pvt->i7core_dev->socket, i, j);
 
 			csrow++;
 		}

commit 4fad8098bc3cc9dfe711b10b07df821ea30e6879
Author: Sedat Dilek <sedat.dilek@googlemail.com>
Date:   Wed Sep 21 23:44:52 2011 -0300

    i7core_edac: Fix compilation on 32 bits arch
    
    on i386:
            ERROR: "__udivdi3" [drivers/edac/i7core_edac.ko] undefined!\
    
    In both get_sdram_scrub_rate() and set_sdram_scrub_rate()
    
    Reported-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 7cb68decf57d..51d251c32901 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -37,6 +37,7 @@
 #include <linux/smp.h>
 #include <asm/mce.h>
 #include <asm/processor.h>
+#include <asm/div64.h>
 
 #include "edac_core.h"
 
@@ -2102,7 +2103,8 @@ static int set_sdram_scrub_rate(struct mem_ctl_info *mci, u32 new_bw)
 		 * program the corresponding register value.
 		 */
 		scrub_interval = (unsigned long long)freq_dclk_mhz *
-			cache_line_size * 1000000 / new_bw;
+			cache_line_size * 1000000;
+		do_div(scrub_interval, new_bw);
 
 		if (!scrub_interval || scrub_interval > SCRUBINTERVAL_MASK)
 			return -EINVAL;
@@ -2153,7 +2155,8 @@ static int get_sdram_scrub_rate(struct mem_ctl_info *mci)
 
 	/* Calculate scrub rate value into byte/sec bandwidth */
 	scrub_rate =  (unsigned long long)freq_dclk_mhz *
-		1000000 * cache_line_size / scrubval;
+		1000000 * cache_line_size;
+	do_div(scrub_rate, scrubval);
 	return (int)scrub_rate;
 }
 

commit 535e9c78e1a80946283cecc742b687b3a5ff5109
Author: Nils Carlson <nils.carlson@ericsson.com>
Date:   Mon Aug 8 06:21:26 2011 -0300

    i7core_edac: scrubbing fixups
    
    Get a more reliable DCLK value from DMI, name the SCRUBINTERVAL mask
    and guard against potential overflow in the scrub rate computations.
    
    Signed-off-by: Nils Carlson <nils.carlson@ericsson.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 6ae7795dea86..7cb68decf57d 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -31,6 +31,7 @@
 #include <linux/pci_ids.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
+#include <linux/dmi.h>
 #include <linux/edac.h>
 #include <linux/mmzone.h>
 #include <linux/smp.h>
@@ -107,6 +108,7 @@ MODULE_PARM_DESC(use_pci_fixup, "Enable PCI fixup to seek for hidden devices");
 
 #define MC_SCRUB_CONTROL	0x4c
   #define STARTSCRUB		(1 << 24)
+  #define SCRUBINTERVAL_MASK    0xffffff
 
 #define MC_COR_ECC_CNT_0	0x80
 #define MC_COR_ECC_CNT_1	0x84
@@ -275,6 +277,9 @@ struct i7core_pvt {
 	/* Count indicator to show errors not got */
 	unsigned		mce_overrun;
 
+	/* DCLK Frequency used for computing scrub rate */
+	int			dclk_freq;
+
 	/* Struct to control EDAC polling */
 	struct edac_pci_ctl_info *i7core_pci;
 };
@@ -1952,6 +1957,112 @@ static struct notifier_block i7_mce_dec = {
 	.notifier_call	= i7core_mce_check_error,
 };
 
+struct memdev_dmi_entry {
+	u8 type;
+	u8 length;
+	u16 handle;
+	u16 phys_mem_array_handle;
+	u16 mem_err_info_handle;
+	u16 total_width;
+	u16 data_width;
+	u16 size;
+	u8 form;
+	u8 device_set;
+	u8 device_locator;
+	u8 bank_locator;
+	u8 memory_type;
+	u16 type_detail;
+	u16 speed;
+	u8 manufacturer;
+	u8 serial_number;
+	u8 asset_tag;
+	u8 part_number;
+	u8 attributes;
+	u32 extended_size;
+	u16 conf_mem_clk_speed;
+} __attribute__((__packed__));
+
+
+/*
+ * Decode the DRAM Clock Frequency, be paranoid, make sure that all
+ * memory devices show the same speed, and if they don't then consider
+ * all speeds to be invalid.
+ */
+static void decode_dclk(const struct dmi_header *dh, void *_dclk_freq)
+{
+	int *dclk_freq = _dclk_freq;
+	u16 dmi_mem_clk_speed;
+
+	if (*dclk_freq == -1)
+		return;
+
+	if (dh->type == DMI_ENTRY_MEM_DEVICE) {
+		struct memdev_dmi_entry *memdev_dmi_entry =
+			(struct memdev_dmi_entry *)dh;
+		unsigned long conf_mem_clk_speed_offset =
+			(unsigned long)&memdev_dmi_entry->conf_mem_clk_speed -
+			(unsigned long)&memdev_dmi_entry->type;
+		unsigned long speed_offset =
+			(unsigned long)&memdev_dmi_entry->speed -
+			(unsigned long)&memdev_dmi_entry->type;
+
+		/* Check that a DIMM is present */
+		if (memdev_dmi_entry->size == 0)
+			return;
+
+		/*
+		 * Pick the configured speed if it's available, otherwise
+		 * pick the DIMM speed, or we don't have a speed.
+		 */
+		if (memdev_dmi_entry->length > conf_mem_clk_speed_offset) {
+			dmi_mem_clk_speed =
+				memdev_dmi_entry->conf_mem_clk_speed;
+		} else if (memdev_dmi_entry->length > speed_offset) {
+			dmi_mem_clk_speed = memdev_dmi_entry->speed;
+		} else {
+			*dclk_freq = -1;
+			return;
+		}
+
+		if (*dclk_freq == 0) {
+			/* First pass, speed was 0 */
+			if (dmi_mem_clk_speed > 0) {
+				/* Set speed if a valid speed is read */
+				*dclk_freq = dmi_mem_clk_speed;
+			} else {
+				/* Otherwise we don't have a valid speed */
+				*dclk_freq = -1;
+			}
+		} else if (*dclk_freq > 0 &&
+			   *dclk_freq != dmi_mem_clk_speed) {
+			/*
+			 * If we have a speed, check that all DIMMS are the same
+			 * speed, otherwise set the speed as invalid.
+			 */
+			*dclk_freq = -1;
+		}
+	}
+}
+
+/*
+ * The default DCLK frequency is used as a fallback if we
+ * fail to find anything reliable in the DMI. The value
+ * is taken straight from the datasheet.
+ */
+#define DEFAULT_DCLK_FREQ 800
+
+static int get_dclk_freq(void)
+{
+	int dclk_freq = 0;
+
+	dmi_walk(decode_dclk, (void *)&dclk_freq);
+
+	if (dclk_freq < 1)
+		return DEFAULT_DCLK_FREQ;
+
+	return dclk_freq;
+}
+
 /*
  * set_sdram_scrub_rate		This routine sets byte/sec bandwidth scrub rate
  *				to hardware according to SCRUBINTERVAL formula
@@ -1961,8 +2072,6 @@ static int set_sdram_scrub_rate(struct mem_ctl_info *mci, u32 new_bw)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	struct pci_dev *pdev;
-	const u32 cache_line_size = 64;
-	const u32 freq_dclk = 800*1000000;
 	u32 dw_scrub;
 	u32 dw_ssr;
 
@@ -1977,18 +2086,28 @@ static int set_sdram_scrub_rate(struct mem_ctl_info *mci, u32 new_bw)
 		/* Prepare to disable petrol scrub */
 		dw_scrub &= ~STARTSCRUB;
 		/* Stop the patrol scrub engine */
-		write_and_test(pdev, MC_SCRUB_CONTROL, dw_scrub & ~0x00ffffff);
+		write_and_test(pdev, MC_SCRUB_CONTROL,
+			       dw_scrub & ~SCRUBINTERVAL_MASK);
 
 		/* Get current status of scrub rate and set bit to disable */
 		pci_read_config_dword(pdev, MC_SSRCONTROL, &dw_ssr);
 		dw_ssr &= ~SSR_MODE_MASK;
 		dw_ssr |= SSR_MODE_DISABLE;
 	} else {
+		const int cache_line_size = 64;
+		const u32 freq_dclk_mhz = pvt->dclk_freq;
+		unsigned long long scrub_interval;
 		/*
 		 * Translate the desired scrub rate to a register value and
-		 * program the cooresponding register value.
+		 * program the corresponding register value.
 		 */
-		dw_scrub = 0x00ffffff & (cache_line_size * freq_dclk / new_bw);
+		scrub_interval = (unsigned long long)freq_dclk_mhz *
+			cache_line_size * 1000000 / new_bw;
+
+		if (!scrub_interval || scrub_interval > SCRUBINTERVAL_MASK)
+			return -EINVAL;
+
+		dw_scrub = SCRUBINTERVAL_MASK & scrub_interval;
 
 		/* Start the patrol scrub engine */
 		pci_write_config_dword(pdev, MC_SCRUB_CONTROL,
@@ -2015,7 +2134,8 @@ static int get_sdram_scrub_rate(struct mem_ctl_info *mci)
 	struct i7core_pvt *pvt = mci->pvt_info;
 	struct pci_dev *pdev;
 	const u32 cache_line_size = 64;
-	const u32 freq_dclk = 800*1000000;
+	const u32 freq_dclk_mhz = pvt->dclk_freq;
+	unsigned long long scrub_rate;
 	u32 scrubval;
 
 	/* Get data from the MC register, function 2 */
@@ -2027,12 +2147,14 @@ static int get_sdram_scrub_rate(struct mem_ctl_info *mci)
 	pci_read_config_dword(pdev, MC_SCRUB_CONTROL, &scrubval);
 
 	/* Mask highest 8-bits to 0 */
-	scrubval &=  0x00ffffff;
+	scrubval &=  SCRUBINTERVAL_MASK;
 	if (!scrubval)
 		return 0;
 
 	/* Calculate scrub rate value into byte/sec bandwidth */
-	return 0xffffffff & (cache_line_size * freq_dclk / (u64) scrubval);
+	scrub_rate =  (unsigned long long)freq_dclk_mhz *
+		1000000 * cache_line_size / scrubval;
+	return (int)scrub_rate;
 }
 
 static void enable_sdram_scrub_setting(struct mem_ctl_info *mci)
@@ -2204,6 +2326,9 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 	/* allocating generic PCI control info */
 	i7core_pci_ctl_create(pvt);
 
+	/* DCLK for scrub rate setting */
+	pvt->dclk_freq = get_dclk_freq();
+
 	atomic_notifier_chain_register(&x86_mce_decoder_chain, &i7_mce_dec);
 
 	return 0;

commit 4055759145b421537207ed0d034041f1774ab41d
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue Nov 30 08:14:30 2010 -0200

    i7core_edac: return -ENODEV if no MC is found
    
    Nehalem-EX uses a different memory controller. However, as the
    memory controller is not visible on some Nehalem/Nehalem-EP, we
    need to indirectly probe via a X58 PCI device. The same devices
    are found on (some) Nehalem-EX. So, on those machines, the
    probe routine needs to return -ENODEV, as the actual Memory
    Controller registers won't be detected.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 304f550ed8d4..6ae7795dea86 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -2226,7 +2226,7 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 static int __devinit i7core_probe(struct pci_dev *pdev,
 				  const struct pci_device_id *id)
 {
-	int rc;
+	int rc, count = 0;
 	struct i7core_dev *i7core_dev;
 
 	/* get the pci devices we want to reserve for our use */
@@ -2246,12 +2246,28 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 		goto fail0;
 
 	list_for_each_entry(i7core_dev, &i7core_edac_list, list) {
+		count++;
 		rc = i7core_register_mci(i7core_dev);
 		if (unlikely(rc < 0))
 			goto fail1;
 	}
 
-	i7core_printk(KERN_INFO, "Driver loaded.\n");
+	/*
+	 * Nehalem-EX uses a different memory controller. However, as the
+	 * memory controller is not visible on some Nehalem/Nehalem-EP, we
+	 * need to indirectly probe via a X58 PCI device. The same devices
+	 * are found on (some) Nehalem-EX. So, on those machines, the
+	 * probe routine needs to return -ENODEV, as the actual Memory
+	 * Controller registers won't be detected.
+	 */
+	if (!count) {
+		rc = -ENODEV;
+		goto fail1;
+	}
+
+	i7core_printk(KERN_INFO,
+		      "Driver loaded, %d memory controller(s) found.\n",
+		      count);
 
 	mutex_unlock(&i7core_edac_lock);
 	return 0;

commit f9902f24fc2d6bcc836622aa70e77f7f9dfb30a9
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Aug 21 09:42:05 2010 -0300

    i7core_edac: use edac's own way to print errors
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 0bddc27362c1..304f550ed8d4 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -2068,7 +2068,8 @@ static void i7core_pci_ctl_create(struct i7core_pvt *pvt)
 						&pvt->i7core_dev->pdev[0]->dev,
 						EDAC_MOD_STR);
 	if (unlikely(!pvt->i7core_pci))
-		pr_warn("Unable to setup PCI error report via EDAC\n");
+		i7core_printk(KERN_WARNING,
+			      "Unable to setup PCI error report via EDAC\n");
 }
 
 static void i7core_pci_ctl_release(struct i7core_pvt *pvt)

commit 4140c54266365e4267a2dbc5765101bba3b42896
Author: Borislav Petkov <borislav.petkov@amd.com>
Date:   Mon Jul 18 11:24:46 2011 -0300

    i7core_edac: Drop the edac_mce facility
    
    Remove edac_mce pieces and use the normal MCE decoder notifier chain by
    retaining the same functionality with considerably less code.
    
    Signed-off-by: Borislav Petkov <borislav.petkov@amd.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 764207ed6d44..0bddc27362c1 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -33,8 +33,8 @@
 #include <linux/delay.h>
 #include <linux/edac.h>
 #include <linux/mmzone.h>
-#include <linux/edac_mce.h>
 #include <linux/smp.h>
+#include <asm/mce.h>
 #include <asm/processor.h>
 
 #include "edac_core.h"
@@ -265,9 +265,6 @@ struct i7core_pvt {
 
 	bool		is_registered, enable_scrub;
 
-	/* mcelog glue */
-	struct edac_mce		edac_mce;
-
 	/* Fifo double buffers */
 	struct mce		mce_entry[MCE_LOG_LEN];
 	struct mce		mce_outentry[MCE_LOG_LEN];
@@ -1899,33 +1896,43 @@ static void i7core_check_error(struct mem_ctl_info *mci)
  * WARNING: As this routine should be called at NMI time, extra care should
  * be taken to avoid deadlocks, and to be as fast as possible.
  */
-static int i7core_mce_check_error(void *priv, struct mce *mce)
+static int i7core_mce_check_error(struct notifier_block *nb, unsigned long val,
+				  void *data)
 {
-	struct mem_ctl_info *mci = priv;
-	struct i7core_pvt *pvt = mci->pvt_info;
+	struct mce *mce = (struct mce *)data;
+	struct i7core_dev *i7_dev;
+	struct mem_ctl_info *mci;
+	struct i7core_pvt *pvt;
+
+	i7_dev = get_i7core_dev(mce->socketid);
+	if (!i7_dev)
+		return NOTIFY_BAD;
+
+	mci = i7_dev->mci;
+	pvt = mci->pvt_info;
 
 	/*
 	 * Just let mcelog handle it if the error is
 	 * outside the memory controller
 	 */
 	if (((mce->status & 0xffff) >> 7) != 1)
-		return 0;
+		return NOTIFY_DONE;
 
 	/* Bank 8 registers are the only ones that we know how to handle */
 	if (mce->bank != 8)
-		return 0;
+		return NOTIFY_DONE;
 
 #ifdef CONFIG_SMP
 	/* Only handle if it is the right mc controller */
 	if (mce->socketid != pvt->i7core_dev->socket)
-		return 0;
+		return NOTIFY_DONE;
 #endif
 
 	smp_rmb();
 	if ((pvt->mce_out + 1) % MCE_LOG_LEN == pvt->mce_in) {
 		smp_wmb();
 		pvt->mce_overrun++;
-		return 0;
+		return NOTIFY_DONE;
 	}
 
 	/* Copy memory error at the ringbuffer */
@@ -1938,9 +1945,13 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 		i7core_check_error(mci);
 
 	/* Advise mcelog that the errors were handled */
-	return 1;
+	return NOTIFY_STOP;
 }
 
+static struct notifier_block i7_mce_dec = {
+	.notifier_call	= i7core_mce_check_error,
+};
+
 /*
  * set_sdram_scrub_rate		This routine sets byte/sec bandwidth scrub rate
  *				to hardware according to SCRUBINTERVAL formula
@@ -2093,8 +2104,7 @@ static void i7core_unregister_mci(struct i7core_dev *i7core_dev)
 	if (pvt->enable_scrub)
 		disable_sdram_scrub_setting(mci);
 
-	/* Disable MCE NMI handler */
-	edac_mce_unregister(&pvt->edac_mce);
+	atomic_notifier_chain_unregister(&x86_mce_decoder_chain, &i7_mce_dec);
 
 	/* Disable EDAC polling */
 	i7core_pci_ctl_release(pvt);
@@ -2193,21 +2203,10 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 	/* allocating generic PCI control info */
 	i7core_pci_ctl_create(pvt);
 
-	/* Registers on edac_mce in order to receive memory errors */
-	pvt->edac_mce.priv = mci;
-	pvt->edac_mce.check_error = i7core_mce_check_error;
-	rc = edac_mce_register(&pvt->edac_mce);
-	if (unlikely(rc < 0)) {
-		debugf0("MC: " __FILE__
-			": %s(): failed edac_mce_register()\n", __func__);
-		goto fail1;
-	}
+	atomic_notifier_chain_register(&x86_mce_decoder_chain, &i7_mce_dec);
 
 	return 0;
 
-fail1:
-	i7core_pci_ctl_release(pvt);
-	edac_mc_del_mc(mci->dev);
 fail0:
 	kfree(mci->ctl_name);
 	edac_mc_free(mci);

commit 5034086b72e4e2d42f0db4b4ebb0fe0129ebdeae
Author: Thomas Renninger <trenn@suse.de>
Date:   Wed Jun 22 05:40:06 2011 -0300

    EDAC i7core: Use mce socketid for better compatibility
    
    mce->socketid and cpu_data(mce->cpu).phys_proc_id are the same,
    compare with mce_setup (in mce.c):
            m->cpu = m->extcpu = smp_processor_id();
            ...
            m->socketid = cpu_data(m->extcpu).phys_proc_id;
    
    This makes it easier for example for XEN patches to hook into
    the MCE subsystem.
    Compile tested on x86_64.
    
    Signed-off-by: Thomas Renninger <trenn@suse.de>
    CC: JBeulich@novell.com
    CC: linux-edac@vger.kernel.org
    CC: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index aeb01f42ffef..764207ed6d44 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1917,7 +1917,7 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 
 #ifdef CONFIG_SMP
 	/* Only handle if it is the right mc controller */
-	if (cpu_data(mce->cpu).phys_proc_id != pvt->i7core_dev->socket)
+	if (mce->socketid != pvt->i7core_dev->socket)
 		return 0;
 #endif
 

commit 27100db0e0d381d24b6f3cb1a4f439996e7c00c8
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Aug 4 21:35:27 2011 -0300

    i7core_edac: Don't enable memory scrubbing for Xeon 35xx
    
    Xeon 35xx doesn't mention memory scrub. It seems that only Xeon 55xx
    and above supports it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 0c02486cf57a..aeb01f42ffef 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -263,7 +263,7 @@ struct i7core_pvt {
 	unsigned long	rdimm_ce_count[NUM_CHANS][MAX_DIMMS];
 	int		rdimm_last_ce_count[NUM_CHANS][MAX_DIMMS];
 
-	unsigned int	is_registered;
+	bool		is_registered, enable_scrub;
 
 	/* mcelog glue */
 	struct edac_mce		edac_mce;
@@ -1487,8 +1487,10 @@ static int mci_bind_devs(struct mem_ctl_info *mci,
 	struct i7core_pvt *pvt = mci->pvt_info;
 	struct pci_dev *pdev;
 	int i, func, slot;
+	char *family;
 
-	pvt->is_registered = 0;
+	pvt->is_registered = false;
+	pvt->enable_scrub  = false;
 	for (i = 0; i < i7core_dev->n_devs; i++) {
 		pdev = i7core_dev->pdev[i];
 		if (!pdev)
@@ -1504,9 +1506,37 @@ static int mci_bind_devs(struct mem_ctl_info *mci,
 			if (unlikely(func > MAX_CHAN_FUNC))
 				goto error;
 			pvt->pci_ch[slot - 4][func] = pdev;
-		} else if (!slot && !func)
+		} else if (!slot && !func) {
 			pvt->pci_noncore = pdev;
-		else
+
+			/* Detect the processor family */
+			switch (pdev->device) {
+			case PCI_DEVICE_ID_INTEL_I7_NONCORE:
+				family = "Xeon 35xx/ i7core";
+				pvt->enable_scrub = false;
+				break;
+			case PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_ALT:
+				family = "i7-800/i5-700";
+				pvt->enable_scrub = false;
+				break;
+			case PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE:
+				family = "Xeon 34xx";
+				pvt->enable_scrub = false;
+				break;
+			case PCI_DEVICE_ID_INTEL_I7_NONCORE_ALT:
+				family = "Xeon 55xx";
+				pvt->enable_scrub = true;
+				break;
+			case PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_REV2:
+				family = "Xeon 56xx / i7-900";
+				pvt->enable_scrub = true;
+				break;
+			default:
+				family = "unknown";
+				pvt->enable_scrub = false;
+			}
+			debugf0("Detected a processor type %s\n", family);
+		} else
 			goto error;
 
 		debugf0("Associated fn %d.%d, dev = %p, socket %d\n",
@@ -1515,7 +1545,7 @@ static int mci_bind_devs(struct mem_ctl_info *mci,
 
 		if (PCI_SLOT(pdev->devfn) == 3 &&
 			PCI_FUNC(pdev->devfn) == 2)
-			pvt->is_registered = 1;
+			pvt->is_registered = true;
 	}
 
 	return 0;
@@ -2060,7 +2090,8 @@ static void i7core_unregister_mci(struct i7core_dev *i7core_dev)
 		__func__, mci, &i7core_dev->pdev[0]->dev);
 
 	/* Disable scrubrate setting */
-	disable_sdram_scrub_setting(mci);
+	if (pvt->enable_scrub)
+		disable_sdram_scrub_setting(mci);
 
 	/* Disable MCE NMI handler */
 	edac_mce_unregister(&pvt->edac_mce);
@@ -2136,7 +2167,8 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 	mci->edac_check = i7core_check_error;
 
 	/* Enable scrubrate setting */
-	enable_sdram_scrub_setting(mci);
+	if (pvt->enable_scrub)
+		enable_sdram_scrub_setting(mci);
 
 	/* add this new MC control structure to EDAC's list of MCs */
 	if (unlikely(edac_mc_add_mc(mci))) {

commit e8b6a1271035e621d1c4b22403c697b5c969728c
Author: Samuel Gabrielsson <samuel.gabrielsson@gmail.com>
Date:   Wed Mar 30 10:21:23 2011 -0300

    i7core_edac: Add scrubbing support
    
    Add scrubbing support to i7core_edac, tested on intel Xeon L5638.
    
    Signed-off-by: Samuel Gabrielsson <samuel.gabrielsson@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index c64ba267902f..0c02486cf57a 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -78,6 +78,8 @@ MODULE_PARM_DESC(use_pci_fixup, "Enable PCI fixup to seek for hidden devices");
 	/* OFFSETS for Device 0 Function 0 */
 
 #define MC_CFG_CONTROL	0x90
+  #define MC_CFG_UNLOCK		0x02
+  #define MC_CFG_LOCK		0x00
 
 	/* OFFSETS for Device 3 Function 0 */
 
@@ -98,6 +100,14 @@ MODULE_PARM_DESC(use_pci_fixup, "Enable PCI fixup to seek for hidden devices");
   #define DIMM0_COR_ERR(r)			((r) & 0x7fff)
 
 /* OFFSETS for Device 3 Function 2, as inicated on Xeon 5500 datasheet */
+#define MC_SSRCONTROL		0x48
+  #define SSR_MODE_DISABLE	0x00
+  #define SSR_MODE_ENABLE	0x01
+  #define SSR_MODE_MASK		0x03
+
+#define MC_SCRUB_CONTROL	0x4c
+  #define STARTSCRUB		(1 << 24)
+
 #define MC_COR_ECC_CNT_0	0x80
 #define MC_COR_ECC_CNT_1	0x84
 #define MC_COR_ECC_CNT_2	0x88
@@ -1901,6 +1911,116 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 	return 1;
 }
 
+/*
+ * set_sdram_scrub_rate		This routine sets byte/sec bandwidth scrub rate
+ *				to hardware according to SCRUBINTERVAL formula
+ *				found in datasheet.
+ */
+static int set_sdram_scrub_rate(struct mem_ctl_info *mci, u32 new_bw)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	struct pci_dev *pdev;
+	const u32 cache_line_size = 64;
+	const u32 freq_dclk = 800*1000000;
+	u32 dw_scrub;
+	u32 dw_ssr;
+
+	/* Get data from the MC register, function 2 */
+	pdev = pvt->pci_mcr[2];
+	if (!pdev)
+		return -ENODEV;
+
+	pci_read_config_dword(pdev, MC_SCRUB_CONTROL, &dw_scrub);
+
+	if (new_bw == 0) {
+		/* Prepare to disable petrol scrub */
+		dw_scrub &= ~STARTSCRUB;
+		/* Stop the patrol scrub engine */
+		write_and_test(pdev, MC_SCRUB_CONTROL, dw_scrub & ~0x00ffffff);
+
+		/* Get current status of scrub rate and set bit to disable */
+		pci_read_config_dword(pdev, MC_SSRCONTROL, &dw_ssr);
+		dw_ssr &= ~SSR_MODE_MASK;
+		dw_ssr |= SSR_MODE_DISABLE;
+	} else {
+		/*
+		 * Translate the desired scrub rate to a register value and
+		 * program the cooresponding register value.
+		 */
+		dw_scrub = 0x00ffffff & (cache_line_size * freq_dclk / new_bw);
+
+		/* Start the patrol scrub engine */
+		pci_write_config_dword(pdev, MC_SCRUB_CONTROL,
+				       STARTSCRUB | dw_scrub);
+
+		/* Get current status of scrub rate and set bit to enable */
+		pci_read_config_dword(pdev, MC_SSRCONTROL, &dw_ssr);
+		dw_ssr &= ~SSR_MODE_MASK;
+		dw_ssr |= SSR_MODE_ENABLE;
+	}
+	/* Disable or enable scrubbing */
+	pci_write_config_dword(pdev, MC_SSRCONTROL, dw_ssr);
+
+	return new_bw;
+}
+
+/*
+ * get_sdram_scrub_rate		This routine convert current scrub rate value
+ *				into byte/sec bandwidth accourding to
+ *				SCRUBINTERVAL formula found in datasheet.
+ */
+static int get_sdram_scrub_rate(struct mem_ctl_info *mci)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	struct pci_dev *pdev;
+	const u32 cache_line_size = 64;
+	const u32 freq_dclk = 800*1000000;
+	u32 scrubval;
+
+	/* Get data from the MC register, function 2 */
+	pdev = pvt->pci_mcr[2];
+	if (!pdev)
+		return -ENODEV;
+
+	/* Get current scrub control data */
+	pci_read_config_dword(pdev, MC_SCRUB_CONTROL, &scrubval);
+
+	/* Mask highest 8-bits to 0 */
+	scrubval &=  0x00ffffff;
+	if (!scrubval)
+		return 0;
+
+	/* Calculate scrub rate value into byte/sec bandwidth */
+	return 0xffffffff & (cache_line_size * freq_dclk / (u64) scrubval);
+}
+
+static void enable_sdram_scrub_setting(struct mem_ctl_info *mci)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	u32 pci_lock;
+
+	/* Unlock writes to pci registers */
+	pci_read_config_dword(pvt->pci_noncore, MC_CFG_CONTROL, &pci_lock);
+	pci_lock &= ~0x3;
+	pci_write_config_dword(pvt->pci_noncore, MC_CFG_CONTROL,
+			       pci_lock | MC_CFG_UNLOCK);
+
+	mci->set_sdram_scrub_rate = set_sdram_scrub_rate;
+	mci->get_sdram_scrub_rate = get_sdram_scrub_rate;
+}
+
+static void disable_sdram_scrub_setting(struct mem_ctl_info *mci)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	u32 pci_lock;
+
+	/* Lock writes to pci registers */
+	pci_read_config_dword(pvt->pci_noncore, MC_CFG_CONTROL, &pci_lock);
+	pci_lock &= ~0x3;
+	pci_write_config_dword(pvt->pci_noncore, MC_CFG_CONTROL,
+			       pci_lock | MC_CFG_LOCK);
+}
+
 static void i7core_pci_ctl_create(struct i7core_pvt *pvt)
 {
 	pvt->i7core_pci = edac_pci_create_generic_ctl(
@@ -1939,6 +2059,9 @@ static void i7core_unregister_mci(struct i7core_dev *i7core_dev)
 	debugf0("MC: " __FILE__ ": %s(): mci = %p, dev = %p\n",
 		__func__, mci, &i7core_dev->pdev[0]->dev);
 
+	/* Disable scrubrate setting */
+	disable_sdram_scrub_setting(mci);
+
 	/* Disable MCE NMI handler */
 	edac_mce_unregister(&pvt->edac_mce);
 
@@ -2012,6 +2135,9 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 	/* Set the function pointer to an actual operation function */
 	mci->edac_check = i7core_check_error;
 
+	/* Enable scrubrate setting */
+	enable_sdram_scrub_setting(mci);
+
 	/* add this new MC control structure to EDAC's list of MCs */
 	if (unlikely(edac_mc_add_mc(mci))) {
 		debugf0("MC: " __FILE__

commit 224e871f36e1f9edddb0dfecbb84ff9765af3eb4
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Mar 17 17:02:59 2011 -0300

    i7core_edac: Fix oops when trying to inject errors
    
    Error injection needs the pci device 0:0. So, we need to revert
    this changeset: 79daef2099a02fed35747c23bad22f30441133ea.
    
    Tests need to be made to be sure that refcount won't be wrong
    as noticed before.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 35a0ff527357..c64ba267902f 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -281,8 +281,7 @@ static const struct pci_id_descr pci_dev_descr_i7core_nehalem[] = {
 		/* Memory controller */
 	{ PCI_DESCR(3, 0, PCI_DEVICE_ID_INTEL_I7_MCR)     },
 	{ PCI_DESCR(3, 1, PCI_DEVICE_ID_INTEL_I7_MC_TAD)  },
-
-		/* Exists only for RDIMM */
+			/* Exists only for RDIMM */
 	{ PCI_DESCR(3, 2, PCI_DEVICE_ID_INTEL_I7_MC_RAS), .optional = 1  },
 	{ PCI_DESCR(3, 4, PCI_DEVICE_ID_INTEL_I7_MC_TEST) },
 
@@ -303,6 +302,16 @@ static const struct pci_id_descr pci_dev_descr_i7core_nehalem[] = {
 	{ PCI_DESCR(6, 1, PCI_DEVICE_ID_INTEL_I7_MC_CH2_ADDR) },
 	{ PCI_DESCR(6, 2, PCI_DEVICE_ID_INTEL_I7_MC_CH2_RANK) },
 	{ PCI_DESCR(6, 3, PCI_DEVICE_ID_INTEL_I7_MC_CH2_TC)   },
+
+		/* Generic Non-core registers */
+	/*
+	 * This is the PCI device on i7core and on Xeon 35xx (8086:2c41)
+	 * On Xeon 55xx, however, it has a different id (8086:2c40). So,
+	 * the probing code needs to test for the other address in case of
+	 * failure of this one
+	 */
+	{ PCI_DESCR(0, 0, PCI_DEVICE_ID_INTEL_I7_NONCORE)  },
+
 };
 
 static const struct pci_id_descr pci_dev_descr_lynnfield[] = {
@@ -319,6 +328,12 @@ static const struct pci_id_descr pci_dev_descr_lynnfield[] = {
 	{ PCI_DESCR( 5, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_ADDR) },
 	{ PCI_DESCR( 5, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_RANK) },
 	{ PCI_DESCR( 5, 3, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_TC)   },
+
+	/*
+	 * This is the PCI device has an alternate address on some
+	 * processors like Core i7 860
+	 */
+	{ PCI_DESCR( 0, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE)     },
 };
 
 static const struct pci_id_descr pci_dev_descr_i7core_westmere[] = {
@@ -346,6 +361,10 @@ static const struct pci_id_descr pci_dev_descr_i7core_westmere[] = {
 	{ PCI_DESCR(6, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH2_ADDR_REV2) },
 	{ PCI_DESCR(6, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH2_RANK_REV2) },
 	{ PCI_DESCR(6, 3, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH2_TC_REV2)   },
+
+		/* Generic Non-core registers */
+	{ PCI_DESCR(0, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_REV2)  },
+
 };
 
 #define PCI_ID_TABLE_ENTRY(A) { .descr=A, .n_devs = ARRAY_SIZE(A) }
@@ -1324,6 +1343,20 @@ static int i7core_get_onedevice(struct pci_dev **prev,
 	pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 			      dev_descr->dev_id, *prev);
 
+	/*
+	 * On Xeon 55xx, the Intel Quckpath Arch Generic Non-core regs
+	 * is at addr 8086:2c40, instead of 8086:2c41. So, we need
+	 * to probe for the alternate address in case of failure
+	 */
+	if (dev_descr->dev_id == PCI_DEVICE_ID_INTEL_I7_NONCORE && !pdev)
+		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
+				      PCI_DEVICE_ID_INTEL_I7_NONCORE_ALT, *prev);
+
+	if (dev_descr->dev_id == PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE && !pdev)
+		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
+				      PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_ALT,
+				      *prev);
+
 	if (!pdev) {
 		if (*prev) {
 			*prev = pdev;

commit 80b8ce89ebb145d91fd2ef1a1e9610aee1613109
Author: David Sterba <dsterba@suse.cz>
Date:   Mon Dec 27 15:39:12 2010 +0000

    i7core_edac: fix misuse of logical operation in place of bitop
    
    CC: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: David Sterba <dsterba@suse.cz>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index f6cf448d69b4..35a0ff527357 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -731,7 +731,7 @@ static int get_dimm_config(const struct mem_ctl_info *mci)
 			debugf1("\t\t%#x\t%#x\t%#x\n",
 				(value[j] >> 27) & 0x1,
 				(value[j] >> 24) & 0x7,
-				(value[j] && ((1 << 24) - 1)));
+				(value[j] & ((1 << 24) - 1)));
 	}
 
 	return 0;

commit 8cf2d2399ab60842f55598bc1b00fd15503b9950
Author: Mathias Krause <minipli@googlemail.com>
Date:   Thu Aug 18 09:17:00 2011 +0200

    i7core_edac: fixed typo in error count calculation
    
    Based on a patch from the PaX Team, found during a clang analysis pass.
    
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: PaX Team <pageexec@freemail.hu>
    Cc: stable@kernel.org [v2.6.35+]
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 04f1e7ce02b1..f6cf448d69b4 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1670,7 +1670,7 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 	char *type, *optype, *err, *msg;
 	unsigned long error = m->status & 0x1ff0000l;
 	u32 optypenum = (m->status >> 4) & 0x07;
-	u32 core_err_cnt = (m->status >> 38) && 0x7fff;
+	u32 core_err_cnt = (m->status >> 38) & 0x7fff;
 	u32 dimm = (m->misc >> 16) & 0x3;
 	u32 channel = (m->misc >> 18) & 0x3;
 	u32 syndrome = m->misc >> 32;

commit b7c2f036284452627d793af981877817b37d4351
Merge: 14587a2a2544 8d2c50e3b65c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 26 13:19:00 2011 -0700

    Merge branch 'trivial' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild-2.6
    
    * 'trivial' of git://git.kernel.org/pub/scm/linux/kernel/git/mmarek/kbuild-2.6:
      gfs2: Drop __TIME__ usage
      isdn/diva: Drop __TIME__ usage
      atm: Drop __TIME__ usage
      dlm: Drop __TIME__ usage
      wan/pc300: Drop __TIME__ usage
      parport: Drop __TIME__ usage
      hdlcdrv: Drop __TIME__ usage
      baycom: Drop __TIME__ usage
      pmcraid: Drop __DATE__ usage
      edac: Drop __DATE__ usage
      rio: Drop __DATE__ usage
      scsi/wd33c93: Drop __TIME__ usage
      scsi/in2000: Drop __TIME__ usage
      aacraid: Drop __TIME__ usage
      media/cx231xx: Drop __TIME__ usage
      media/radio-maxiradio: Drop __TIME__ usage
      nozomi: Drop __TIME__ usage
      cyclades: Drop __TIME__ usage

commit 152ba3942276c2a240703669ae4a3099e0a79451
Author: Michal Marek <mmarek@suse.cz>
Date:   Fri Apr 1 12:41:20 2011 +0200

    edac: Drop __DATE__ usage
    
    The kernel already prints its build timestamp during boot, no need to
    repeat it in random drivers and produce different object files each
    time.
    
    Cc: Doug Thompson <dougthompson@xmission.com>
    Cc: bluesmoke-devel@lists.sourceforge.net
    Cc: linux-edac@vger.kernel.org
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Michal Marek <mmarek@suse.cz>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 81154ab296b6..3f320ba5445f 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -59,7 +59,7 @@ MODULE_PARM_DESC(use_pci_fixup, "Enable PCI fixup to seek for hidden devices");
 /*
  * Alter this version for the module when modifications are made
  */
-#define I7CORE_REVISION    " Ver: 1.0.0 " __DATE__
+#define I7CORE_REVISION    " Ver: 1.0.0"
 #define EDAC_MOD_STR      "i7core_edac"
 
 /*

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 81154ab296b6..465cbc25149f 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1772,7 +1772,7 @@ static void i7core_check_error(struct mem_ctl_info *mci)
 	/*
 	 * MCE first step: Copy all mce errors into a temporary buffer
 	 * We use a double buffering here, to reduce the risk of
-	 * loosing an error.
+	 * losing an error.
 	 */
 	smp_rmb();
 	count = (pvt->mce_out + MCE_LOG_LEN - pvt->mce_in)

commit e7bf068aa3208d73e9dea817f6d975071ddd4336
Author: David Sterba <dsterba@suse.cz>
Date:   Mon Dec 27 16:51:15 2010 +0100

    i7core_edac: fix typos in comments
    
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 362861c15779..81154ab296b6 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1,6 +1,6 @@
 /* Intel i7 core/Nehalem Memory Controller kernel module
  *
- * This driver supports yhe memory controllers found on the Intel
+ * This driver supports the memory controllers found on the Intel
  * processor families i7core, i7core 7xx/8xx, i5core, Xeon 35xx,
  * Xeon 55xx and Xeon 56xx also known as Nehalem, Nehalem-EP, Lynnfield
  * and Westmere-EP.
@@ -1271,7 +1271,7 @@ static void __init i7core_xeon_pci_fixup(const struct pci_id_table *table)
 	int i;
 
 	/*
-	 * On Xeon 55xx, the Intel Quckpath Arch Generic Non-core pci buses
+	 * On Xeon 55xx, the Intel Quick Path Arch Generic Non-core pci buses
 	 * aren't announced by acpi. So, we need to use a legacy scan probing
 	 * to detect them
 	 */
@@ -1864,7 +1864,7 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 	if (mce->mcgstatus & 1)
 		i7core_check_error(mci);
 
-	/* Advice mcelog that the error were handled */
+	/* Advise mcelog that the errors were handled */
 	return 1;
 }
 

commit 76a7bd81130646459dfded1845e0d511488a6afa
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sun Oct 24 11:36:19 2010 -0200

    i7core_edac: return -ENODEV when devices were already probed
    
    Due to the nature of i7core, we need to probe and attach all PCI
    devices used by this driver during the first time probe is called.
    However, PCI core will call the probe routine one time for each CPU
    socket. If we return -EINVAL to those calls, it would seem that the
    driver fails, when, in fact, there's no more devices left to initialize.
    
    Changing the return code to -ENODEV solves this issue.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index e3404b2bbaa2..362861c15779 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -2046,7 +2046,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	 */
 	if (unlikely(probed >= 1)) {
 		mutex_unlock(&i7core_edac_lock);
-		return -EINVAL;
+		return -ENODEV;
 	}
 	probed++;
 

commit 3c52cc57ccd5c99441368d5e66be36681ce90e72
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sun Oct 24 11:12:28 2010 -0200

    i7core_edac: properly terminate pci_dev_table
    
    At pci_xeon_fixup(), it waits for a null-terminated table, while at
    i7core_get_all_devices, it just do a for 0..ARRAY_SIZE. As other tables
    are zero-terminated, change it to be terminate with 0 as well, and fixes
    a bug where it may be running out of the table elements.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 71f4dc699abe..e3404b2bbaa2 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -353,6 +353,7 @@ static const struct pci_id_table pci_dev_table[] = {
 	PCI_ID_TABLE_ENTRY(pci_dev_descr_i7core_nehalem),
 	PCI_ID_TABLE_ENTRY(pci_dev_descr_lynnfield),
 	PCI_ID_TABLE_ENTRY(pci_dev_descr_i7core_westmere),
+	{0,}			/* 0 terminated list. */
 };
 
 /*
@@ -1409,14 +1410,13 @@ static int i7core_get_onedevice(struct pci_dev **prev,
 
 static int i7core_get_all_devices(void)
 {
-	int i, j, rc, last_bus;
+	int i, rc, last_bus;
 	struct pci_dev *pdev = NULL;
-	const struct pci_id_table *table;
+	const struct pci_id_table *table = pci_dev_table;
 
 	last_bus = i7core_pci_lastbus();
 
-	for (j = 0; j < ARRAY_SIZE(pci_dev_table); j++) {
-		table = &pci_dev_table[j];
+	while (table && table->descr) {
 		for (i = 0; i < table->n_devs; i++) {
 			pdev = NULL;
 			do {
@@ -1432,6 +1432,7 @@ static int i7core_get_all_devices(void)
 				}
 			} while (pdev);
 		}
+		table++;
 	}
 
 	return 0;

commit a3e1541637f2096ab31af311c53eaeb0853650d3
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Aug 21 08:52:41 2010 -0300

    i7core_edac: Avoid PCI refcount to reach zero on successive load/reload
    
    That's a nasty bug that took me a lot of time to track, and whose
    solution took just one line to solve. The best fragrances and the worse
    poisons are shipped on the smalest bottles.
    
    The drivers/pci/quick.c implements the pci_get_device function. The normal
    behavior is that you call it, the function returns you a pdev pointer
    and increment pdev->kobj.kref.refcount of the pci device. However,
    if you want to keep searching an object, you need to pass the previous
    pdev function to the search.
    
    When you use a not null pointer to pdev "from" field, pci_get_device
    will decrement pdev->kobj.kref.refcount, assuming that the driver won't
    be using the previous pdev.
    
    The solution is simple: we just need to call pci_dev_get() manually,
    for the pdev's that the driver will actually use.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 9868796f4871..71f4dc699abe 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1395,6 +1395,13 @@ static int i7core_get_onedevice(struct pci_dev **prev,
 		dev_descr->func,
 		PCI_VENDOR_ID_INTEL, dev_descr->dev_id);
 
+	/*
+	 * As stated on drivers/pci/search.c, the reference count for
+	 * @from is always decremented if it is not %NULL. So, as we need
+	 * to get all devices up to null, we need to do a get for the device
+	 */
+	pci_dev_get(pdev);
+
 	*prev = pdev;
 
 	return 0;

commit 79daef2099a02fed35747c23bad22f30441133ea
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Aug 21 01:03:52 2010 -0300

    i7core_edac: Fix refcount error at PCI devices
    
    Probably due to a bug or some testing logic at PCI level, device
    refcount for <bus>:00.0 device is decremented at the end of the
    pci_get_device, made by i7core_get_all_devices(). The fact is that
    the first versions of the driver relied on those devices to probe
    for Nehalem, but the current versions don't use it at all.
    
    So, let's just remove those devices from the driver, making it simpler
    and fixing the bug.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index d55f74a6cd49..9868796f4871 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -281,7 +281,8 @@ static const struct pci_id_descr pci_dev_descr_i7core_nehalem[] = {
 		/* Memory controller */
 	{ PCI_DESCR(3, 0, PCI_DEVICE_ID_INTEL_I7_MCR)     },
 	{ PCI_DESCR(3, 1, PCI_DEVICE_ID_INTEL_I7_MC_TAD)  },
-			/* Exists only for RDIMM */
+
+		/* Exists only for RDIMM */
 	{ PCI_DESCR(3, 2, PCI_DEVICE_ID_INTEL_I7_MC_RAS), .optional = 1  },
 	{ PCI_DESCR(3, 4, PCI_DEVICE_ID_INTEL_I7_MC_TEST) },
 
@@ -302,16 +303,6 @@ static const struct pci_id_descr pci_dev_descr_i7core_nehalem[] = {
 	{ PCI_DESCR(6, 1, PCI_DEVICE_ID_INTEL_I7_MC_CH2_ADDR) },
 	{ PCI_DESCR(6, 2, PCI_DEVICE_ID_INTEL_I7_MC_CH2_RANK) },
 	{ PCI_DESCR(6, 3, PCI_DEVICE_ID_INTEL_I7_MC_CH2_TC)   },
-
-		/* Generic Non-core registers */
-	/*
-	 * This is the PCI device on i7core and on Xeon 35xx (8086:2c41)
-	 * On Xeon 55xx, however, it has a different id (8086:2c40). So,
-	 * the probing code needs to test for the other address in case of
-	 * failure of this one
-	 */
-	{ PCI_DESCR(0, 0, PCI_DEVICE_ID_INTEL_I7_NONCORE)  },
-
 };
 
 static const struct pci_id_descr pci_dev_descr_lynnfield[] = {
@@ -328,12 +319,6 @@ static const struct pci_id_descr pci_dev_descr_lynnfield[] = {
 	{ PCI_DESCR( 5, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_ADDR) },
 	{ PCI_DESCR( 5, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_RANK) },
 	{ PCI_DESCR( 5, 3, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_TC)   },
-
-	/*
-	 * This is the PCI device has an alternate address on some
-	 * processors like Core i7 860
-	 */
-	{ PCI_DESCR( 0, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE)     },
 };
 
 static const struct pci_id_descr pci_dev_descr_i7core_westmere[] = {
@@ -361,10 +346,6 @@ static const struct pci_id_descr pci_dev_descr_i7core_westmere[] = {
 	{ PCI_DESCR(6, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH2_ADDR_REV2) },
 	{ PCI_DESCR(6, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH2_RANK_REV2) },
 	{ PCI_DESCR(6, 3, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH2_TC_REV2)   },
-
-		/* Generic Non-core registers */
-	{ PCI_DESCR(0, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_REV2)  },
-
 };
 
 #define PCI_ID_TABLE_ENTRY(A) { .descr=A, .n_devs = ARRAY_SIZE(A) }
@@ -1342,20 +1323,6 @@ static int i7core_get_onedevice(struct pci_dev **prev,
 	pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 			      dev_descr->dev_id, *prev);
 
-	/*
-	 * On Xeon 55xx, the Intel Quckpath Arch Generic Non-core regs
-	 * is at addr 8086:2c40, instead of 8086:2c41. So, we need
-	 * to probe for the alternate address in case of failure
-	 */
-	if (dev_descr->dev_id == PCI_DEVICE_ID_INTEL_I7_NONCORE && !pdev)
-		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
-				      PCI_DEVICE_ID_INTEL_I7_NONCORE_ALT, *prev);
-
-	if (dev_descr->dev_id == PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE && !pdev)
-		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
-				      PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_ALT,
-				      *prev);
-
 	if (!pdev) {
 		if (*prev) {
 			*prev = pdev;

commit 88ef5ea9767b0c7bfb4b477e1857629fe8fa2983
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 20 15:39:38 2010 -0300

    i7core_edac: it is safe to i7core_unregister_mci() when mci=NULL
    
    i7core_unregister_mci() checks internally when mci=NULL. There's no
    need to test it outside.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 915835339d7c..d55f74a6cd49 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -2091,10 +2091,9 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	return 0;
 
 fail1:
-	list_for_each_entry(i7core_dev, &i7core_edac_list, list) {
-		if (i7core_dev->mci)
-			i7core_unregister_mci(i7core_dev);
-	}
+	list_for_each_entry(i7core_dev, &i7core_edac_list, list)
+		i7core_unregister_mci(i7core_dev);
+
 	i7core_put_all_devices();
 fail0:
 	mutex_unlock(&i7core_edac_lock);
@@ -2126,10 +2125,8 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 		return;
 	}
 
-	list_for_each_entry(i7core_dev, &i7core_edac_list, list) {
-		if (i7core_dev->mci)
-			i7core_unregister_mci(i7core_dev);
-	}
+	list_for_each_entry(i7core_dev, &i7core_edac_list, list)
+		i7core_unregister_mci(i7core_dev);
 
 	/* Release PCI resources */
 	i7core_put_all_devices();

commit 6d37d240f2ff411c4d58bbbddefbda73a227d40c
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Aug 20 12:48:26 2010 -0300

    i7core_edac: Fix an oops at i7core probe
    
    changeset c91d57ba9ce5b5c93a7077e2f72510eb1f9131c4 moved the init
    of the priv pointer to the end of the probe routine. However, we need
    them before that, otherwise, we hit an OOPS:
    
    [   67.743453] EDAC DEBUG: mci_bind_devs: Associated fn 0.0, dev = ffff88011b46e000, socket 0
    [   67.751861] BUG: unable to handle kernel NULL pointer dereference at 0000000000000010
    [   67.759685] IP: [<ffffffffa017e484>] i7core_probe+0x979/0x130c [i7core_edac]
    [   67.766721] PGD 10bd38067 PUD 10bd37067 PMD 0
    [   67.771178] Oops: 0000 [#1] SMP
    [   67.774414] last sysfs file: /sys/devices/system/cpu/cpu1/cache/index2/shared_cpu_map
    [   67.782213] CPU 1
    [   67.784042] Modules linked in: i7core_edac(+) edac_core cpufreq_ondemand binfmt_misc dm_multipath video output pci_slot snd_hda_codd
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 4a12961c5ef6..915835339d7c 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1968,6 +1968,10 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 	pvt = mci->pvt_info;
 	memset(pvt, 0, sizeof(*pvt));
 
+	/* Associates i7core_dev and mci for future usage */
+	pvt->i7core_dev = i7core_dev;
+	i7core_dev->mci = mci;
+
 	/*
 	 * FIXME: how to handle RDDR3 at MCI level? It is possible to have
 	 * Mixed RDDR3/UDDR3 with Nehalem, provided that they are on different
@@ -2033,10 +2037,6 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 		goto fail1;
 	}
 
-	/* Associates i7core_dev and mci for future usage */
-	pvt->i7core_dev = i7core_dev;
-	i7core_dev->mci = mci;
-
 	return 0;
 
 fail1:

commit 21b6806a8cbda694eb1bed8d5b60bd7c322ad343
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Fri Aug 20 04:33:10 2010 -0300

    i7core_edac: Remove unused member channels in i7core_pvt
    
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index b466f803db12..4a12961c5ef6 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -243,8 +243,6 @@ struct i7core_pvt {
 	struct i7core_inject	inject;
 	struct i7core_channel	channel[NUM_CHANS];
 
-	int		channels; /* Number of active channels */
-
 	int		ce_count_available;
 	int 		csrow_map[NUM_CHANS][MAX_DIMMS];
 

commit 2e5185f7ff2b26206889d7ebb09ddc4c59b656a4
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Fri Aug 20 04:32:56 2010 -0300

    i7core_edac: Remove unused arg csrow from get_dimm_config
    
    A local is enough.
    
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 795df30000a1..b466f803db12 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -580,12 +580,13 @@ static int i7core_get_active_channels(const u8 socket, unsigned *channels,
 	return 0;
 }
 
-static int get_dimm_config(const struct mem_ctl_info *mci, int *csrow)
+static int get_dimm_config(const struct mem_ctl_info *mci)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	struct csrow_info *csr;
 	struct pci_dev *pdev;
 	int i, j;
+	int csrow = 0;
 	unsigned long last_page = 0;
 	enum edac_type mode;
 	enum mem_type mtype;
@@ -701,7 +702,7 @@ static int get_dimm_config(const struct mem_ctl_info *mci, int *csrow)
 
 			npages = MiB_TO_PAGES(size);
 
-			csr = &mci->csrows[*csrow];
+			csr = &mci->csrows[csrow];
 			csr->first_page = last_page + 1;
 			last_page += npages;
 			csr->last_page = last_page;
@@ -709,13 +710,13 @@ static int get_dimm_config(const struct mem_ctl_info *mci, int *csrow)
 
 			csr->page_mask = 0;
 			csr->grain = 8;
-			csr->csrow_idx = *csrow;
+			csr->csrow_idx = csrow;
 			csr->nr_channels = 1;
 
 			csr->channels[0].chan_idx = i;
 			csr->channels[0].ce_count = 0;
 
-			pvt->csrow_map[i][j] = *csrow;
+			pvt->csrow_map[i][j] = csrow;
 
 			switch (banks) {
 			case 4:
@@ -734,7 +735,7 @@ static int get_dimm_config(const struct mem_ctl_info *mci, int *csrow)
 			csr->edac_mode = mode;
 			csr->mtype = mtype;
 
-			(*csrow)++;
+			csrow++;
 		}
 
 		pci_read_config_dword(pdev, MC_SAG_CH_0, &value[0]);
@@ -1951,7 +1952,6 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 {
 	struct mem_ctl_info *mci;
 	struct i7core_pvt *pvt;
-	int csrow = 0;
 	int rc, channels, csrows;
 
 	/* Check the number of active and not disabled channels */
@@ -1996,7 +1996,7 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev)
 		mci->mc_driver_sysfs_attributes = i7core_sysfs_udimm_attrs;
 
 	/* Get dimm basic config */
-	get_dimm_config(mci, &csrow);
+	get_dimm_config(mci);
 	/* record ptr to the generic device */
 	mci->dev = &i7core_dev->pdev[0]->dev;
 	/* Set the function pointer to an actual operation function */

commit aace42831aa46f210bf3b0d8f1527092cc37eaad
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Fri Aug 20 04:32:45 2010 -0300

    i7core_edac: Reduce args of i7core_register_mci
    
    We can check the number of channels in i7core_register_mci.
    
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 7164707ed99e..795df30000a1 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1947,17 +1947,20 @@ static void i7core_unregister_mci(struct i7core_dev *i7core_dev)
 	i7core_dev->mci = NULL;
 }
 
-static int i7core_register_mci(struct i7core_dev *i7core_dev,
-			       const int num_channels, const int num_csrows)
+static int i7core_register_mci(struct i7core_dev *i7core_dev)
 {
 	struct mem_ctl_info *mci;
 	struct i7core_pvt *pvt;
 	int csrow = 0;
-	int rc;
+	int rc, channels, csrows;
+
+	/* Check the number of active and not disabled channels */
+	rc = i7core_get_active_channels(i7core_dev->socket, &channels, &csrows);
+	if (unlikely(rc < 0))
+		return rc;
 
 	/* allocate a new MC control structure */
-	mci = edac_mc_alloc(sizeof(*pvt), num_csrows, num_channels,
-			    i7core_dev->socket);
+	mci = edac_mc_alloc(sizeof(*pvt), csrows, channels, i7core_dev->socket);
 	if (unlikely(!mci))
 		return -ENOMEM;
 
@@ -2079,16 +2082,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 		goto fail0;
 
 	list_for_each_entry(i7core_dev, &i7core_edac_list, list) {
-		int channels;
-		int csrows;
-
-		/* Check the number of active and not disabled channels */
-		rc = i7core_get_active_channels(i7core_dev->socket,
-						&channels, &csrows);
-		if (unlikely(rc < 0))
-			goto fail1;
-
-		rc = i7core_register_mci(i7core_dev, channels, csrows);
+		rc = i7core_register_mci(i7core_dev);
 		if (unlikely(rc < 0))
 			goto fail1;
 	}

commit 1c6edbbe2529684859ff8e34a19e34fe9894a3b7
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Fri Aug 20 04:32:33 2010 -0300

    i7core_edac: Introduce i7core_unregister_mci
    
    In i7core_probe, when setup of mci for 2nd or later socket failed,
    we should cleanup prepared mci for 1st socket or so before "put" of
    all devices.
    
    So let have i7core_unregister_mci that can be shared between here
    and i7core_remove.
    
    While here fix a typo "hanler".
    
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 7ee5034100b9..7164707ed99e 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1471,10 +1471,6 @@ static int mci_bind_devs(struct mem_ctl_info *mci,
 	struct pci_dev *pdev;
 	int i, func, slot;
 
-	/* Associates i7core_dev and mci for future usage */
-	pvt->i7core_dev = i7core_dev;
-	i7core_dev->mci = mci;
-
 	pvt->is_registered = 0;
 	for (i = 0; i < i7core_dev->n_devs; i++) {
 		pdev = i7core_dev->pdev[i];
@@ -1918,6 +1914,39 @@ static void i7core_pci_ctl_release(struct i7core_pvt *pvt)
 	pvt->i7core_pci = NULL;
 }
 
+static void i7core_unregister_mci(struct i7core_dev *i7core_dev)
+{
+	struct mem_ctl_info *mci = i7core_dev->mci;
+	struct i7core_pvt *pvt;
+
+	if (unlikely(!mci || !mci->pvt_info)) {
+		debugf0("MC: " __FILE__ ": %s(): dev = %p\n",
+			__func__, &i7core_dev->pdev[0]->dev);
+
+		i7core_printk(KERN_ERR, "Couldn't find mci handler\n");
+		return;
+	}
+
+	pvt = mci->pvt_info;
+
+	debugf0("MC: " __FILE__ ": %s(): mci = %p, dev = %p\n",
+		__func__, mci, &i7core_dev->pdev[0]->dev);
+
+	/* Disable MCE NMI handler */
+	edac_mce_unregister(&pvt->edac_mce);
+
+	/* Disable EDAC polling */
+	i7core_pci_ctl_release(pvt);
+
+	/* Remove MC sysfs nodes */
+	edac_mc_del_mc(mci->dev);
+
+	debugf1("%s: free mci struct\n", mci->ctl_name);
+	kfree(mci->ctl_name);
+	edac_mc_free(mci);
+	i7core_dev->mci = NULL;
+}
+
 static int i7core_register_mci(struct i7core_dev *i7core_dev,
 			       const int num_channels, const int num_csrows)
 {
@@ -2003,6 +2032,10 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 		goto fail1;
 	}
 
+	/* Associates i7core_dev and mci for future usage */
+	pvt->i7core_dev = i7core_dev;
+	i7core_dev->mci = mci;
+
 	return 0;
 
 fail1:
@@ -2011,6 +2044,7 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 fail0:
 	kfree(mci->ctl_name);
 	edac_mc_free(mci);
+	i7core_dev->mci = NULL;
 	return rc;
 }
 
@@ -2065,6 +2099,10 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	return 0;
 
 fail1:
+	list_for_each_entry(i7core_dev, &i7core_edac_list, list) {
+		if (i7core_dev->mci)
+			i7core_unregister_mci(i7core_dev);
+	}
 	i7core_put_all_devices();
 fail0:
 	mutex_unlock(&i7core_edac_lock);
@@ -2077,9 +2115,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
  */
 static void __devexit i7core_remove(struct pci_dev *pdev)
 {
-	struct mem_ctl_info *mci;
 	struct i7core_dev *i7core_dev;
-	struct i7core_pvt *pvt;
 
 	debugf0(__FILE__ ": %s()\n", __func__);
 
@@ -2099,32 +2135,8 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 	}
 
 	list_for_each_entry(i7core_dev, &i7core_edac_list, list) {
-		mci = i7core_dev->mci;
-		if (unlikely(!mci || !mci->pvt_info)) {
-			debugf0("MC: " __FILE__ ": %s(): dev = %p\n",
-				__func__, &i7core_dev->pdev[0]->dev);
-
-				i7core_printk(KERN_ERR,
-				      "Couldn't find mci hanler\n");
-		} else {
-			pvt = mci->pvt_info;
-
-			debugf0("MC: " __FILE__ ": %s(): mci = %p, dev = %p\n",
-				__func__, mci, &i7core_dev->pdev[0]->dev);
-
-			/* Disable MCE NMI handler */
-			edac_mce_unregister(&pvt->edac_mce);
-
-			/* Disable EDAC polling */
-			i7core_pci_ctl_release(pvt);
-
-			/* Remove MC sysfs nodes */
-			edac_mc_del_mc(mci->dev);
-
-			debugf1("%s: free mci struct\n", mci->ctl_name);
-			kfree(mci->ctl_name);
-			edac_mc_free(mci);
-		}
+		if (i7core_dev->mci)
+			i7core_unregister_mci(i7core_dev);
 	}
 
 	/* Release PCI resources */

commit 73589c80cd0dab94db50800c4834a8d8522cd54f
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Fri Aug 20 04:32:05 2010 -0300

    i7core_edac: Use saved pointers
    
    We already have saved pointers.  Use shorter ones.
    
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 472fa375f1eb..7ee5034100b9 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -2099,7 +2099,7 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 	}
 
 	list_for_each_entry(i7core_dev, &i7core_edac_list, list) {
-		mci = find_mci_by_dev(&i7core_dev->pdev[0]->dev);
+		mci = i7core_dev->mci;
 		if (unlikely(!mci || !mci->pvt_info)) {
 			debugf0("MC: " __FILE__ ": %s(): dev = %p\n",
 				__func__, &i7core_dev->pdev[0]->dev);
@@ -2108,7 +2108,6 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 				      "Couldn't find mci hanler\n");
 		} else {
 			pvt = mci->pvt_info;
-			i7core_dev = pvt->i7core_dev;
 
 			debugf0("MC: " __FILE__ ": %s(): mci = %p, dev = %p\n",
 				__func__, mci, &i7core_dev->pdev[0]->dev);
@@ -2120,7 +2119,7 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 			i7core_pci_ctl_release(pvt);
 
 			/* Remove MC sysfs nodes */
-			edac_mc_del_mc(&i7core_dev->pdev[0]->dev);
+			edac_mc_del_mc(mci->dev);
 
 			debugf1("%s: free mci struct\n", mci->ctl_name);
 			kfree(mci->ctl_name);

commit 71fe01706d631513bdbd73381f4b76dacea5cf77
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Fri Aug 20 04:29:47 2010 -0300

    i7core_edac: Check probe counter in i7core_remove
    
    Prevent i7core_remove from running multiple times.
    Otherwise value proved will be negative and something will be wrong.
    
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 2e2db3c083ed..472fa375f1eb 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -2092,6 +2092,12 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 	 */
 
 	mutex_lock(&i7core_edac_lock);
+
+	if (unlikely(!probed)) {
+		mutex_unlock(&i7core_edac_lock);
+		return;
+	}
+
 	list_for_each_entry(i7core_dev, &i7core_edac_list, list) {
 		mci = find_mci_by_dev(&i7core_dev->pdev[0]->dev);
 		if (unlikely(!mci || !mci->pvt_info)) {

commit 2896637b86243c39a4f08d15388dcc06130fff29
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Fri Aug 20 04:28:51 2010 -0300

    i7core_edac: Call pci_dev_put() when alloc_i7core_dev()  failed
    
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 3542e8c0a63f..2e2db3c083ed 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1384,8 +1384,10 @@ static int i7core_get_onedevice(struct pci_dev **prev,
 	i7core_dev = get_i7core_dev(socket);
 	if (!i7core_dev) {
 		i7core_dev = alloc_i7core_dev(socket, table);
-		if (!i7core_dev)
+		if (!i7core_dev) {
+			pci_dev_put(pdev);
 			return -ENOMEM;
+		}
 	}
 
 	if (i7core_dev->pdev[devno]) {

commit 628c5ddfb08094a5ef9186dc866d09bfcac105c9
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Fri Aug 20 04:28:40 2010 -0300

    i7core_edac: Fix error path of i7core_register_mci
    
    Release resources properly.
    
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 6bebf4d73f48..3542e8c0a63f 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1954,7 +1954,7 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 	/* Store pci devices at mci for faster access */
 	rc = mci_bind_devs(mci, i7core_dev);
 	if (unlikely(rc < 0))
-		goto fail;
+		goto fail0;
 
 	if (pvt->is_registered)
 		mci->mc_driver_sysfs_attributes = i7core_sysfs_rdimm_attrs;
@@ -1977,7 +1977,7 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 		 */
 
 		rc = -EINVAL;
-		goto fail;
+		goto fail0;
 	}
 
 	/* Default error mask is any memory */
@@ -1998,11 +1998,17 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 	if (unlikely(rc < 0)) {
 		debugf0("MC: " __FILE__
 			": %s(): failed edac_mce_register()\n", __func__);
+		goto fail1;
 	}
 
-fail:
-	if (rc < 0)
-		edac_mc_free(mci);
+	return 0;
+
+fail1:
+	i7core_pci_ctl_release(pvt);
+	edac_mc_del_mc(mci->dev);
+fail0:
+	kfree(mci->ctl_name);
+	edac_mc_free(mci);
 	return rc;
 }
 

commit 5939813b9c4270d0f46375c3cad64226bb1fcd62
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Fri Aug 20 04:28:25 2010 -0300

    i7core_edac: Fix order of lines in i7core_register_mci
    
    The flag is_registered is not initialized until mci_bind_devs()
    is called.  Refer it properly.
    
    The mci->dev and mci->edac_check is required in edac_mc_add_mc(),
    so prepare them just before the call.
    
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 19faeffac9dc..6bebf4d73f48 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1933,9 +1933,6 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 	debugf0("MC: " __FILE__ ": %s(): mci = %p, dev = %p\n",
 		__func__, mci, &i7core_dev->pdev[0]->dev);
 
-	/* record ptr to the generic device */
-	mci->dev = &i7core_dev->pdev[0]->dev;
-
 	pvt = mci->pvt_info;
 	memset(pvt, 0, sizeof(*pvt));
 
@@ -1954,21 +1951,22 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 	mci->dev_name = pci_name(i7core_dev->pdev[0]);
 	mci->ctl_page_to_phys = NULL;
 
-	if (pvt->is_registered)
-		mci->mc_driver_sysfs_attributes = i7core_sysfs_rdimm_attrs;
-	else
-		mci->mc_driver_sysfs_attributes = i7core_sysfs_udimm_attrs;
-
-	/* Set the function pointer to an actual operation function */
-	mci->edac_check = i7core_check_error;
-
 	/* Store pci devices at mci for faster access */
 	rc = mci_bind_devs(mci, i7core_dev);
 	if (unlikely(rc < 0))
 		goto fail;
 
+	if (pvt->is_registered)
+		mci->mc_driver_sysfs_attributes = i7core_sysfs_rdimm_attrs;
+	else
+		mci->mc_driver_sysfs_attributes = i7core_sysfs_udimm_attrs;
+
 	/* Get dimm basic config */
 	get_dimm_config(mci, &csrow);
+	/* record ptr to the generic device */
+	mci->dev = &i7core_dev->pdev[0]->dev;
+	/* Set the function pointer to an actual operation function */
+	mci->edac_check = i7core_check_error;
 
 	/* add this new MC control structure to EDAC's list of MCs */
 	if (unlikely(edac_mc_add_mc(mci))) {

commit 64c10f6e0e6b4473b97c29c574e9517f93bedaec
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Fri Aug 20 04:28:14 2010 -0300

    i7core_edac: Always do get/put for all devices
    
    We already do 'get' for all sockets at once. So do 'put' in the
    same way.
    
    And let args of the 'get' function to void since it handles
    only the single, static and known size table pci_dev_table[].
    
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index a5cbea5abd62..19faeffac9dc 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1255,7 +1255,7 @@ static const struct mcidev_sysfs_attribute i7core_sysfs_udimm_attrs[] = {
  ****************************************************************************/
 
 /*
- *	i7core_put_devices	'put' all the devices that we have
+ *	i7core_put_all_devices	'put' all the devices that we have
  *				reserved via 'get'
  */
 static void i7core_put_devices(struct i7core_dev *i7core_dev)
@@ -1323,7 +1323,7 @@ static unsigned i7core_pci_lastbus(void)
 }
 
 /*
- *	i7core_get_devices	Find and perform 'get' operation on the MCH's
+ *	i7core_get_all_devices	Find and perform 'get' operation on the MCH's
  *			device/functions we want to reference for this driver
  *
  *			Need to 'get' device 16 func 1 and func 2
@@ -1432,14 +1432,16 @@ static int i7core_get_onedevice(struct pci_dev **prev,
 	return 0;
 }
 
-static int i7core_get_devices(const struct pci_id_table *table)
+static int i7core_get_all_devices(void)
 {
-	int i, rc, last_bus;
+	int i, j, rc, last_bus;
 	struct pci_dev *pdev = NULL;
+	const struct pci_id_table *table;
 
 	last_bus = i7core_pci_lastbus();
 
-	while (table && table->descr) {
+	for (j = 0; j < ARRAY_SIZE(pci_dev_table); j++) {
+		table = &pci_dev_table[j];
 		for (i = 0; i < table->n_devs; i++) {
 			pdev = NULL;
 			do {
@@ -1455,7 +1457,6 @@ static int i7core_get_devices(const struct pci_id_table *table)
 				}
 			} while (pdev);
 		}
-		table++;
 	}
 
 	return 0;
@@ -2033,7 +2034,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	}
 	probed++;
 
-	rc = i7core_get_devices(pci_dev_table);
+	rc = i7core_get_all_devices();
 	if (unlikely(rc < 0))
 		goto fail0;
 
@@ -2071,7 +2072,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 static void __devexit i7core_remove(struct pci_dev *pdev)
 {
 	struct mem_ctl_info *mci;
-	struct i7core_dev *i7core_dev, *tmp;
+	struct i7core_dev *i7core_dev;
 	struct i7core_pvt *pvt;
 
 	debugf0(__FILE__ ": %s()\n", __func__);
@@ -2085,7 +2086,7 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 	 */
 
 	mutex_lock(&i7core_edac_lock);
-	list_for_each_entry_safe(i7core_dev, tmp, &i7core_edac_list, list) {
+	list_for_each_entry(i7core_dev, &i7core_edac_list, list) {
 		mci = find_mci_by_dev(&i7core_dev->pdev[0]->dev);
 		if (unlikely(!mci || !mci->pvt_info)) {
 			debugf0("MC: " __FILE__ ": %s(): dev = %p\n",
@@ -2112,12 +2113,12 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 			debugf1("%s: free mci struct\n", mci->ctl_name);
 			kfree(mci->ctl_name);
 			edac_mc_free(mci);
-
-			/* Release PCI resources */
-			i7core_put_devices(i7core_dev);
-			free_i7core_dev(i7core_dev);
 		}
 	}
+
+	/* Release PCI resources */
+	i7core_put_all_devices();
+
 	probed--;
 
 	mutex_unlock(&i7core_edac_lock);

commit a3aa0a4ab56e825e2ec236974d478d1dcebf41a9
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Fri Aug 20 04:25:18 2010 -0300

    i7core_edac: Introduce i7core_pci_ctl_create/release
    
    Have a couple of method.
    while here sort out lines in the i7core_register_mci() a bit.
    
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index e1cbbbad466e..a5cbea5abd62 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1895,6 +1895,26 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 	return 1;
 }
 
+static void i7core_pci_ctl_create(struct i7core_pvt *pvt)
+{
+	pvt->i7core_pci = edac_pci_create_generic_ctl(
+						&pvt->i7core_dev->pdev[0]->dev,
+						EDAC_MOD_STR);
+	if (unlikely(!pvt->i7core_pci))
+		pr_warn("Unable to setup PCI error report via EDAC\n");
+}
+
+static void i7core_pci_ctl_release(struct i7core_pvt *pvt)
+{
+	if (likely(pvt->i7core_pci))
+		edac_pci_release_generic_ctl(pvt->i7core_pci);
+	else
+		i7core_printk(KERN_ERR,
+				"Couldn't find mem_ctl_info for socket %d\n",
+				pvt->i7core_dev->socket);
+	pvt->i7core_pci = NULL;
+}
+
 static int i7core_register_mci(struct i7core_dev *i7core_dev,
 			       const int num_channels, const int num_csrows)
 {
@@ -1969,22 +1989,12 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 	pvt->inject.page = -1;
 	pvt->inject.col = -1;
 
+	/* allocating generic PCI control info */
+	i7core_pci_ctl_create(pvt);
+
 	/* Registers on edac_mce in order to receive memory errors */
 	pvt->edac_mce.priv = mci;
 	pvt->edac_mce.check_error = i7core_mce_check_error;
-
-	/* allocating generic PCI control info */
-	pvt->i7core_pci = edac_pci_create_generic_ctl(&i7core_dev->pdev[0]->dev,
-						 EDAC_MOD_STR);
-	if (unlikely(!pvt->i7core_pci)) {
-		printk(KERN_WARNING
-			"%s(): Unable to create PCI control\n",
-			__func__);
-		printk(KERN_WARNING
-			"%s(): PCI error report via EDAC not setup\n",
-			__func__);
-	}
-
 	rc = edac_mce_register(&pvt->edac_mce);
 	if (unlikely(rc < 0)) {
 		debugf0("MC: " __FILE__
@@ -2094,13 +2104,7 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 			edac_mce_unregister(&pvt->edac_mce);
 
 			/* Disable EDAC polling */
-			if (likely(pvt->i7core_pci))
-				edac_pci_release_generic_ctl(pvt->i7core_pci);
-			else
-				i7core_printk(KERN_ERR,
-					      "Couldn't find mem_ctl_info for socket %d\n",
-					      i7core_dev->socket);
-			pvt->i7core_pci = NULL;
+			i7core_pci_ctl_release(pvt);
 
 			/* Remove MC sysfs nodes */
 			edac_mc_del_mc(&i7core_dev->pdev[0]->dev);

commit 2aa9be448dab7433c685b634a4049289cb1913d3
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Fri Aug 20 04:25:00 2010 -0300

    i7core_edac: Introduce free_i7core_dev
    
    Have a method to make a couple with alloc_i7core_dev() previously
    introduced.  Using in pair will help proper resource handling.
    
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index c4fa112271e5..e1cbbbad466e 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -470,6 +470,13 @@ static struct i7core_dev *alloc_i7core_dev(u8 socket,
 	return i7core_dev;
 }
 
+static void free_i7core_dev(struct i7core_dev *i7core_dev)
+{
+	list_del(&i7core_dev->list);
+	kfree(i7core_dev->pdev);
+	kfree(i7core_dev);
+}
+
 /****************************************************************************
 			Memory check routines
  ****************************************************************************/
@@ -1265,7 +1272,6 @@ static void i7core_put_devices(struct i7core_dev *i7core_dev)
 			PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
 		pci_dev_put(pdev);
 	}
-	kfree(i7core_dev->pdev);
 }
 
 static void i7core_put_all_devices(void)
@@ -1274,8 +1280,7 @@ static void i7core_put_all_devices(void)
 
 	list_for_each_entry_safe(i7core_dev, tmp, &i7core_edac_list, list) {
 		i7core_put_devices(i7core_dev);
-		list_del(&i7core_dev->list);
-		kfree(i7core_dev);
+		free_i7core_dev(i7core_dev);
 	}
 }
 
@@ -2106,8 +2111,7 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 
 			/* Release PCI resources */
 			i7core_put_devices(i7core_dev);
-			list_del(&i7core_dev->list);
-			kfree(i7core_dev);
+			free_i7core_dev(i7core_dev);
 		}
 	}
 	probed--;

commit 848b2f7ed6db4d3a83201187159665cc57725d9f
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Fri Aug 20 04:24:44 2010 -0300

    i7core_edac: Introduce alloc_i7core_dev
    
    It's nice to have a method for a single purpose.
    
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 567ee18d9d3f..c4fa112271e5 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -447,6 +447,29 @@ static struct i7core_dev *get_i7core_dev(u8 socket)
 	return NULL;
 }
 
+static struct i7core_dev *alloc_i7core_dev(u8 socket,
+					   const struct pci_id_table *table)
+{
+	struct i7core_dev *i7core_dev;
+
+	i7core_dev = kzalloc(sizeof(*i7core_dev), GFP_KERNEL);
+	if (!i7core_dev)
+		return NULL;
+
+	i7core_dev->pdev = kzalloc(sizeof(*i7core_dev->pdev) * table->n_devs,
+				   GFP_KERNEL);
+	if (!i7core_dev->pdev) {
+		kfree(i7core_dev);
+		return NULL;
+	}
+
+	i7core_dev->socket = socket;
+	i7core_dev->n_devs = table->n_devs;
+	list_add_tail(&i7core_dev->list, &i7core_edac_list);
+
+	return i7core_dev;
+}
+
 /****************************************************************************
 			Memory check routines
  ****************************************************************************/
@@ -1355,18 +1378,9 @@ static int i7core_get_onedevice(struct pci_dev **prev,
 
 	i7core_dev = get_i7core_dev(socket);
 	if (!i7core_dev) {
-		i7core_dev = kzalloc(sizeof(*i7core_dev), GFP_KERNEL);
+		i7core_dev = alloc_i7core_dev(socket, table);
 		if (!i7core_dev)
 			return -ENOMEM;
-		i7core_dev->pdev = kzalloc(sizeof(*i7core_dev->pdev)
-						* table->n_devs, GFP_KERNEL);
-		if (!i7core_dev->pdev) {
-			kfree(i7core_dev);
-			return -ENOMEM;
-		}
-		i7core_dev->socket = socket;
-		i7core_dev->n_devs = table->n_devs;
-		list_add_tail(&i7core_dev->list, &i7core_edac_list);
 	}
 
 	if (i7core_dev->pdev[devno]) {

commit b197cba071ec8a171fbaaaf82d119315a6f6cb0b
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Fri Aug 20 04:24:31 2010 -0300

    i7core_edac: Reduce args of i7core_get_onedevice
    
    Since we need to pass the index of the entry, pass the table itself
    instead of passing individual members of the table.
    
    While here make it static.
    
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index d64ac2ccc0bc..567ee18d9d3f 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1300,12 +1300,13 @@ static unsigned i7core_pci_lastbus(void)
  *
  *			Need to 'get' device 16 func 1 and func 2
  */
-int i7core_get_onedevice(struct pci_dev **prev, const int devno,
-			 const struct pci_id_descr *dev_descr,
-			 const unsigned n_devs,
-			 const unsigned last_bus)
+static int i7core_get_onedevice(struct pci_dev **prev,
+				const struct pci_id_table *table,
+				const unsigned devno,
+				const unsigned last_bus)
 {
 	struct i7core_dev *i7core_dev;
+	const struct pci_id_descr *dev_descr = &table->descr[devno];
 
 	struct pci_dev *pdev = NULL;
 	u8 bus = 0;
@@ -1357,14 +1358,14 @@ int i7core_get_onedevice(struct pci_dev **prev, const int devno,
 		i7core_dev = kzalloc(sizeof(*i7core_dev), GFP_KERNEL);
 		if (!i7core_dev)
 			return -ENOMEM;
-		i7core_dev->pdev = kzalloc(sizeof(*i7core_dev->pdev) * n_devs,
-					   GFP_KERNEL);
+		i7core_dev->pdev = kzalloc(sizeof(*i7core_dev->pdev)
+						* table->n_devs, GFP_KERNEL);
 		if (!i7core_dev->pdev) {
 			kfree(i7core_dev);
 			return -ENOMEM;
 		}
 		i7core_dev->socket = socket;
-		i7core_dev->n_devs = n_devs;
+		i7core_dev->n_devs = table->n_devs;
 		list_add_tail(&i7core_dev->list, &i7core_edac_list);
 	}
 
@@ -1416,18 +1417,14 @@ static int i7core_get_devices(const struct pci_id_table *table)
 {
 	int i, rc, last_bus;
 	struct pci_dev *pdev = NULL;
-	const struct pci_id_descr *dev_descr;
 
 	last_bus = i7core_pci_lastbus();
 
 	while (table && table->descr) {
-		dev_descr = table->descr;
 		for (i = 0; i < table->n_devs; i++) {
 			pdev = NULL;
 			do {
-				rc = i7core_get_onedevice(&pdev, i,
-							  &dev_descr[i],
-							  table->n_devs,
+				rc = i7core_get_onedevice(&pdev, table, i,
 							  last_bus);
 				if (rc < 0) {
 					if (i == 0) {

commit 45b7c981aeeb456d4b0c04f15d551f3e515bf20e
Author: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
Date:   Fri Aug 20 04:24:18 2010 -0300

    i7core_edac: Fix the logic in i7core_remove()
    
    commit 47251b4d960bdfa648b0d06dbc6d445f41cb3906 have changed
    the logic for unexplained reasons.  It looks strange that it
    can release i7core_dev without calling i7core_put_devices()
    that releases i7core_dev->pdev.
    
    Fix the part.
    
    Signed-off-by: Hidetoshi Seto <seto.hidetoshi@jp.fujitsu.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index a76a4c067858..d64ac2ccc0bc 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -2095,9 +2095,9 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 
 			/* Release PCI resources */
 			i7core_put_devices(i7core_dev);
+			list_del(&i7core_dev->list);
+			kfree(i7core_dev);
 		}
-		list_del(&i7core_dev->list);
-		kfree(i7core_dev);
 	}
 	probed--;
 

commit 54a08ab153cf38a08ccce7544d58c819ad02dd18
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Aug 19 15:51:00 2010 -0300

    i7core_edac: Don't do the legacy PCI probe by default
    
    The legacy PCI probe sometimes cause hangs. Better to have it
    disabled by default, and have a parameter to enable it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 8e789a2e35d6..a76a4c067858 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -44,6 +44,9 @@ static LIST_HEAD(i7core_edac_list);
 static DEFINE_MUTEX(i7core_edac_lock);
 static int probed;
 
+static int use_pci_fixup;
+module_param(use_pci_fixup, int, 0444);
+MODULE_PARM_DESC(use_pci_fixup, "Enable PCI fixup to seek for hidden devices");
 /*
  * This is used for Nehalem-EP and Nehalem-EX devices, where the non-core
  * registers start at bus 255, and are not reported by BIOS.
@@ -1257,6 +1260,7 @@ static void __init i7core_xeon_pci_fixup(const struct pci_id_table *table)
 {
 	struct pci_dev *pdev = NULL;
 	int i;
+
 	/*
 	 * On Xeon 55xx, the Intel Quckpath Arch Generic Non-core pci buses
 	 * aren't announced by acpi. So, we need to use a legacy scan probing
@@ -2126,7 +2130,8 @@ static int __init i7core_init(void)
 	/* Ensure that the OPSTATE is set correctly for POLL or NMI */
 	opstate_init();
 
-	i7core_xeon_pci_fixup(pci_dev_table);
+	if (use_pci_fixup)
+		i7core_xeon_pci_fixup(pci_dev_table);
 
 	pci_rc = pci_register_driver(&i7core_driver);
 

commit accf74fff36315a31dc7319dae2927af06e9296f
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Aug 16 18:34:37 2010 -0300

    i7core_edac: don't use a freed mci struct
    
    This is a nasty bug. Since kobject count will be reduced by zero by
    edac_mc_del_mc(), and this triggers the kobj release method, the
    mci memory will be freed automatically. So, all we have left is ctl_name,
    as shown by enabling debug:
    
    [   80.822186] EDAC DEBUG: in drivers/edac/edac_mc_sysfs.c, line at 1020: edac_remove_sysfs_mci_device()  remove_link
    [   80.832590] EDAC DEBUG: in drivers/edac/edac_mc_sysfs.c, line at 1024: edac_remove_sysfs_mci_device()  remove_mci_instance
    [   80.843776] EDAC DEBUG: in drivers/edac/edac_mc_sysfs.c, line at 640: edac_mci_control_release() mci instance idx=0 releasing
    [   80.855163] EDAC MC: Removed device 0 for i7core_edac.c i7 core #0: DEV 0000:3f:03.0
    [   80.862936] EDAC DEBUG: in drivers/edac/i7core_edac.c, line at 2089: (null): free structs
    [   80.871134] EDAC DEBUG: in drivers/edac/edac_mc.c, line at 238: edac_mc_free()
    [   80.878379] EDAC DEBUG: in drivers/edac/edac_mc_sysfs.c, line at 726: edac_mc_unregister_sysfs_main_kobj()
    [   80.888043] EDAC DEBUG: in drivers/edac/i7core_edac.c, line at 1232: drivers/edac/i7core_edac.c: i7core_put_devices()
    
    Also, kfree(mci) shouldn't happen at the kobj.release, as it happens
    when edac_remove_sysfs_mci_device() is called, but the logic is:
            edac_remove_sysfs_mci_device(mci);
            edac_printk(KERN_INFO, EDAC_MC,
                    "Removed device %d for %s %s: DEV %s\n", mci->mc_idx,
                    mci->mod_name, mci->ctl_name, edac_dev_name(mci));
    So, as the edac_printk() needs the mci struct, this generates an OOPS.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index b0559973c66f..8e789a2e35d6 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -2085,8 +2085,7 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 			/* Remove MC sysfs nodes */
 			edac_mc_del_mc(&i7core_dev->pdev[0]->dev);
 
-			/* Free data */
-			debugf1("%s: free structs\n");
+			debugf1("%s: free mci struct\n", mci->ctl_name);
 			kfree(mci->ctl_name);
 			edac_mc_free(mci);
 

commit bbc560ae677c0f4d7ff8404a21409c99f35b297b
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Aug 16 18:22:43 2010 -0300

    edac_core: Print debug messages at release calls
    
    This is important to track a nasty bug at the free logic.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 11c61b4d8149..b0559973c66f 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -2086,6 +2086,7 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 			edac_mc_del_mc(&i7core_dev->pdev[0]->dev);
 
 			/* Free data */
+			debugf1("%s: free structs\n");
 			kfree(mci->ctl_name);
 			edac_mc_free(mci);
 

commit 39300e7143f8ef81b07cee3d8b86880bc4311ea0
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Aug 11 23:40:15 2010 -0300

    i7core_edac: explicitly remove PCI devices from the devices list
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index e5aa06e6389e..11c61b4d8149 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1240,16 +1240,17 @@ static void i7core_put_devices(struct i7core_dev *i7core_dev)
 		pci_dev_put(pdev);
 	}
 	kfree(i7core_dev->pdev);
-	list_del(&i7core_dev->list);
-	kfree(i7core_dev);
 }
 
 static void i7core_put_all_devices(void)
 {
 	struct i7core_dev *i7core_dev, *tmp;
 
-	list_for_each_entry_safe(i7core_dev, tmp, &i7core_edac_list, list)
+	list_for_each_entry_safe(i7core_dev, tmp, &i7core_edac_list, list) {
 		i7core_put_devices(i7core_dev);
+		list_del(&i7core_dev->list);
+		kfree(i7core_dev);
+	}
 }
 
 static void __init i7core_xeon_pci_fixup(const struct pci_id_table *table)
@@ -1438,7 +1439,6 @@ static int i7core_get_devices(const struct pci_id_table *table)
 	}
 
 	return 0;
-	return 0;
 }
 
 static int mci_bind_devs(struct mem_ctl_info *mci,
@@ -2092,6 +2092,8 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 			/* Release PCI resources */
 			i7core_put_devices(i7core_dev);
 		}
+		list_del(&i7core_dev->list);
+		kfree(i7core_dev);
 	}
 	probed--;
 

commit 41ba6c10586dfab632725cd532677ae5ae460e3e
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Aug 11 00:58:11 2010 -0300

    i7core_edac: MCE NMI handling should stop first
    
    Otherwise, a NMI may happen causing a race condition and a panic.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index d2b2ed8915fd..e5aa06e6389e 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -2070,6 +2070,10 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 			debugf0("MC: " __FILE__ ": %s(): mci = %p, dev = %p\n",
 				__func__, mci, &i7core_dev->pdev[0]->dev);
 
+			/* Disable MCE NMI handler */
+			edac_mce_unregister(&pvt->edac_mce);
+
+			/* Disable EDAC polling */
 			if (likely(pvt->i7core_pci))
 				edac_pci_release_generic_ctl(pvt->i7core_pci);
 			else
@@ -2078,11 +2082,14 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 					      i7core_dev->socket);
 			pvt->i7core_pci = NULL;
 
+			/* Remove MC sysfs nodes */
 			edac_mc_del_mc(&i7core_dev->pdev[0]->dev);
 
-			edac_mce_unregister(&pvt->edac_mce);
+			/* Free data */
 			kfree(mci->ctl_name);
 			edac_mc_free(mci);
+
+			/* Release PCI resources */
 			i7core_put_devices(i7core_dev);
 		}
 	}

commit 6ee7dd504490f3dc25cfe1c9be5b6e8895f89a92
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue Aug 10 23:24:16 2010 -0300

    i7core_edac: Initialize all priv vars before start polling
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index a05f166d8917..d2b2ed8915fd 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1941,18 +1941,6 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 		goto fail;
 	}
 
-	/* allocating generic PCI control info */
-	pvt->i7core_pci = edac_pci_create_generic_ctl(&i7core_dev->pdev[0]->dev,
-						 EDAC_MOD_STR);
-	if (unlikely(!pvt->i7core_pci)) {
-		printk(KERN_WARNING
-			"%s(): Unable to create PCI control\n",
-			__func__);
-		printk(KERN_WARNING
-			"%s(): PCI error report via EDAC not setup\n",
-			__func__);
-	}
-
 	/* Default error mask is any memory */
 	pvt->inject.channel = 0;
 	pvt->inject.dimm = -1;
@@ -1965,6 +1953,18 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 	pvt->edac_mce.priv = mci;
 	pvt->edac_mce.check_error = i7core_mce_check_error;
 
+	/* allocating generic PCI control info */
+	pvt->i7core_pci = edac_pci_create_generic_ctl(&i7core_dev->pdev[0]->dev,
+						 EDAC_MOD_STR);
+	if (unlikely(!pvt->i7core_pci)) {
+		printk(KERN_WARNING
+			"%s(): Unable to create PCI control\n",
+			__func__);
+		printk(KERN_WARNING
+			"%s(): PCI error report via EDAC not setup\n",
+			__func__);
+	}
+
 	rc = edac_mce_register(&pvt->edac_mce);
 	if (unlikely(rc < 0)) {
 		debugf0("MC: " __FILE__

commit 3cfd01468b98360ede8cc8849d14e586253d290c
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue Aug 10 23:23:46 2010 -0300

    i7core_edac: Improve debug to seek for register/remove errors
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 36b4e1422838..a05f166d8917 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1889,7 +1889,8 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 	if (unlikely(!mci))
 		return -ENOMEM;
 
-	debugf0("MC: " __FILE__ ": %s(): mci = %p\n", __func__, mci);
+	debugf0("MC: " __FILE__ ": %s(): mci = %p, dev = %p\n",
+		__func__, mci, &i7core_dev->pdev[0]->dev);
 
 	/* record ptr to the generic device */
 	mci->dev = &i7core_dev->pdev[0]->dev;
@@ -2057,12 +2058,18 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 	list_for_each_entry_safe(i7core_dev, tmp, &i7core_edac_list, list) {
 		mci = find_mci_by_dev(&i7core_dev->pdev[0]->dev);
 		if (unlikely(!mci || !mci->pvt_info)) {
-			i7core_printk(KERN_ERR,
+			debugf0("MC: " __FILE__ ": %s(): dev = %p\n",
+				__func__, &i7core_dev->pdev[0]->dev);
+
+				i7core_printk(KERN_ERR,
 				      "Couldn't find mci hanler\n");
 		} else {
 			pvt = mci->pvt_info;
 			i7core_dev = pvt->i7core_dev;
 
+			debugf0("MC: " __FILE__ ": %s(): mci = %p, dev = %p\n",
+				__func__, mci, &i7core_dev->pdev[0]->dev);
+
 			if (likely(pvt->i7core_pci))
 				edac_pci_release_generic_ctl(pvt->i7core_pci);
 			else

commit e9144601d364d5b81f3e63949337f8507eb58dca
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue Aug 10 20:26:35 2010 -0300

    i7core_edac: move #if PAGE_SHIFT to edac_core.h
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 5d15daaec8b8..36b4e1422838 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -666,11 +666,7 @@ static int get_dimm_config(const struct mem_ctl_info *mci, int *csrow)
 				RANKOFFSET(dimm_dod[j]),
 				banks, ranks, rows, cols);
 
-#if PAGE_SHIFT > 20
-			npages = size >> (PAGE_SHIFT - 20);
-#else
-			npages = size << (20 - PAGE_SHIFT);
-#endif
+			npages = MiB_TO_PAGES(size);
 
 			csr = &mci->csrows[*csrow];
 			csr->first_page = last_page + 1;

commit 1288c18f48d9bf373dbed6b688cde36dc970b1ed
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue Aug 10 18:57:01 2010 -0300

    i7core_edac: Properly mark const static vars as such
    
    There are two groups of sysfs attributes: one for rdimm and another
    for udimm. Instead of changing dynamically the unique static struct
    for handling udimm's, declare two vars and make them constant.
    
    This avoids the risk of having two or more memory controllers, each
    needing a different set of attributes.
    
    While here, use const on all places where it is applicable.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    
    edac_core: use const for constant sysfs arguments
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 4c1dcc1f562e..5d15daaec8b8 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -217,8 +217,8 @@ struct pci_id_descr {
 };
 
 struct pci_id_table {
-	struct pci_id_descr	*descr;
-	int			n_devs;
+	const struct pci_id_descr	*descr;
+	int				n_devs;
 };
 
 struct i7core_dev {
@@ -276,7 +276,7 @@ struct i7core_pvt {
 	.func = (function),			\
 	.dev_id = (device_id)
 
-struct pci_id_descr pci_dev_descr_i7core_nehalem[] = {
+static const struct pci_id_descr pci_dev_descr_i7core_nehalem[] = {
 		/* Memory controller */
 	{ PCI_DESCR(3, 0, PCI_DEVICE_ID_INTEL_I7_MCR)     },
 	{ PCI_DESCR(3, 1, PCI_DEVICE_ID_INTEL_I7_MC_TAD)  },
@@ -313,7 +313,7 @@ struct pci_id_descr pci_dev_descr_i7core_nehalem[] = {
 
 };
 
-struct pci_id_descr pci_dev_descr_lynnfield[] = {
+static const struct pci_id_descr pci_dev_descr_lynnfield[] = {
 	{ PCI_DESCR( 3, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_MCR)         },
 	{ PCI_DESCR( 3, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_TAD)      },
 	{ PCI_DESCR( 3, 4, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_TEST)     },
@@ -335,7 +335,7 @@ struct pci_id_descr pci_dev_descr_lynnfield[] = {
 	{ PCI_DESCR( 0, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE)     },
 };
 
-struct pci_id_descr pci_dev_descr_i7core_westmere[] = {
+static const struct pci_id_descr pci_dev_descr_i7core_westmere[] = {
 		/* Memory controller */
 	{ PCI_DESCR(3, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_MCR_REV2)     },
 	{ PCI_DESCR(3, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_TAD_REV2)  },
@@ -366,8 +366,8 @@ struct pci_id_descr pci_dev_descr_i7core_westmere[] = {
 
 };
 
-#define PCI_ID_TABLE_ENTRY(A) { A, ARRAY_SIZE(A) }
-struct pci_id_table pci_dev_table[] = {
+#define PCI_ID_TABLE_ENTRY(A) { .descr=A, .n_devs = ARRAY_SIZE(A) }
+static const struct pci_id_table pci_dev_table[] = {
 	PCI_ID_TABLE_ENTRY(pci_dev_descr_i7core_nehalem),
 	PCI_ID_TABLE_ENTRY(pci_dev_descr_lynnfield),
 	PCI_ID_TABLE_ENTRY(pci_dev_descr_i7core_westmere),
@@ -486,7 +486,7 @@ static struct pci_dev *get_pdev_slot_func(u8 socket, unsigned slot,
  * to add a fake description for csrows.
  * So, this driver is attributing one DIMM memory for one csrow.
  */
-static int i7core_get_active_channels(u8 socket, unsigned *channels,
+static int i7core_get_active_channels(const u8 socket, unsigned *channels,
 				      unsigned *csrows)
 {
 	struct pci_dev *pdev = NULL;
@@ -547,7 +547,7 @@ static int i7core_get_active_channels(u8 socket, unsigned *channels,
 	return 0;
 }
 
-static int get_dimm_config(struct mem_ctl_info *mci, int *csrow)
+static int get_dimm_config(const struct mem_ctl_info *mci, int *csrow)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	struct csrow_info *csr;
@@ -738,7 +738,7 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow)
    we're disabling error injection on all write calls to the sysfs nodes that
    controls the error code injection.
  */
-static int disable_inject(struct mem_ctl_info *mci)
+static int disable_inject(const struct mem_ctl_info *mci)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 
@@ -923,7 +923,7 @@ DECLARE_ADDR_MATCH(bank, 32);
 DECLARE_ADDR_MATCH(page, 0x10000);
 DECLARE_ADDR_MATCH(col, 0x4000);
 
-static int write_and_test(struct pci_dev *dev, int where, u32 val)
+static int write_and_test(struct pci_dev *dev, const int where, const u32 val)
 {
 	u32 read;
 	int count;
@@ -1122,35 +1122,34 @@ DECLARE_COUNTER(2);
  * Sysfs struct
  */
 
-
-static struct mcidev_sysfs_attribute i7core_addrmatch_attrs[] = {
+static const struct mcidev_sysfs_attribute i7core_addrmatch_attrs[] = {
 	ATTR_ADDR_MATCH(channel),
 	ATTR_ADDR_MATCH(dimm),
 	ATTR_ADDR_MATCH(rank),
 	ATTR_ADDR_MATCH(bank),
 	ATTR_ADDR_MATCH(page),
 	ATTR_ADDR_MATCH(col),
-	{ .attr = { .name = NULL } }
+	{ } /* End of list */
 };
 
-static struct mcidev_sysfs_group i7core_inject_addrmatch = {
+static const struct mcidev_sysfs_group i7core_inject_addrmatch = {
 	.name  = "inject_addrmatch",
 	.mcidev_attr = i7core_addrmatch_attrs,
 };
 
-static struct mcidev_sysfs_attribute i7core_udimm_counters_attrs[] = {
+static const struct mcidev_sysfs_attribute i7core_udimm_counters_attrs[] = {
 	ATTR_COUNTER(0),
 	ATTR_COUNTER(1),
 	ATTR_COUNTER(2),
 	{ .attr = { .name = NULL } }
 };
 
-static struct mcidev_sysfs_group i7core_udimm_counters = {
+static const struct mcidev_sysfs_group i7core_udimm_counters = {
 	.name  = "all_channel_counts",
 	.mcidev_attr = i7core_udimm_counters_attrs,
 };
 
-static struct mcidev_sysfs_attribute i7core_sysfs_attrs[] = {
+static const struct mcidev_sysfs_attribute i7core_sysfs_rdimm_attrs[] = {
 	{
 		.attr = {
 			.name = "inject_section",
@@ -1182,8 +1181,44 @@ static struct mcidev_sysfs_attribute i7core_sysfs_attrs[] = {
 		.show  = i7core_inject_enable_show,
 		.store = i7core_inject_enable_store,
 	},
-	{ .attr = { .name = NULL } },	/* Reserved for udimm counters */
-	{ .attr = { .name = NULL } }
+	{ }	/* End of list */
+};
+
+static const struct mcidev_sysfs_attribute i7core_sysfs_udimm_attrs[] = {
+	{
+		.attr = {
+			.name = "inject_section",
+			.mode = (S_IRUGO | S_IWUSR)
+		},
+		.show  = i7core_inject_section_show,
+		.store = i7core_inject_section_store,
+	}, {
+		.attr = {
+			.name = "inject_type",
+			.mode = (S_IRUGO | S_IWUSR)
+		},
+		.show  = i7core_inject_type_show,
+		.store = i7core_inject_type_store,
+	}, {
+		.attr = {
+			.name = "inject_eccmask",
+			.mode = (S_IRUGO | S_IWUSR)
+		},
+		.show  = i7core_inject_eccmask_show,
+		.store = i7core_inject_eccmask_store,
+	}, {
+		.grp = &i7core_inject_addrmatch,
+	}, {
+		.attr = {
+			.name = "inject_enable",
+			.mode = (S_IRUGO | S_IWUSR)
+		},
+		.show  = i7core_inject_enable_show,
+		.store = i7core_inject_enable_store,
+	}, {
+		.grp = &i7core_udimm_counters,
+	},
+	{ }	/* End of list */
 };
 
 /****************************************************************************
@@ -1221,7 +1256,7 @@ static void i7core_put_all_devices(void)
 		i7core_put_devices(i7core_dev);
 }
 
-static void __init i7core_xeon_pci_fixup(struct pci_id_table *table)
+static void __init i7core_xeon_pci_fixup(const struct pci_id_table *table)
 {
 	struct pci_dev *pdev = NULL;
 	int i;
@@ -1264,9 +1299,10 @@ static unsigned i7core_pci_lastbus(void)
  *
  *			Need to 'get' device 16 func 1 and func 2
  */
-int i7core_get_onedevice(struct pci_dev **prev, int devno,
-			 struct pci_id_descr *dev_descr, unsigned n_devs,
-			 unsigned last_bus)
+int i7core_get_onedevice(struct pci_dev **prev, const int devno,
+			 const struct pci_id_descr *dev_descr,
+			 const unsigned n_devs,
+			 const unsigned last_bus)
 {
 	struct i7core_dev *i7core_dev;
 
@@ -1375,11 +1411,11 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno,
 	return 0;
 }
 
-static int i7core_get_devices(struct pci_id_table *table)
+static int i7core_get_devices(const struct pci_id_table *table)
 {
 	int i, rc, last_bus;
 	struct pci_dev *pdev = NULL;
-	struct pci_id_descr *dev_descr;
+	const struct pci_id_descr *dev_descr;
 
 	last_bus = i7core_pci_lastbus();
 
@@ -1450,15 +1486,6 @@ static int mci_bind_devs(struct mem_ctl_info *mci,
 			pvt->is_registered = 1;
 	}
 
-	/*
-	 * Add extra nodes to count errors on udimm
-	 * For registered memory, this is not needed, since the counters
-	 * are already displayed at the standard locations
-	 */
-	if (!pvt->is_registered)
-		i7core_sysfs_attrs[ARRAY_SIZE(i7core_sysfs_attrs)-2].grp =
-			&i7core_udimm_counters;
-
 	return 0;
 
 error:
@@ -1472,7 +1499,9 @@ static int mci_bind_devs(struct mem_ctl_info *mci,
 			Error check routines
  ****************************************************************************/
 static void i7core_rdimm_update_csrow(struct mem_ctl_info *mci,
-					 int chan, int dimm, int add)
+				      const int chan,
+				      const int dimm,
+				      const int add)
 {
 	char *msg;
 	struct i7core_pvt *pvt = mci->pvt_info;
@@ -1489,7 +1518,10 @@ static void i7core_rdimm_update_csrow(struct mem_ctl_info *mci,
 }
 
 static void i7core_rdimm_update_ce_count(struct mem_ctl_info *mci,
-			int chan, int new0, int new1, int new2)
+					 const int chan,
+					 const int new0,
+					 const int new1,
+					 const int new2)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	int add0 = 0, add1 = 0, add2 = 0;
@@ -1643,7 +1675,7 @@ static void i7core_udimm_check_mc_ecc_err(struct mem_ctl_info *mci)
  * fields
  */
 static void i7core_mce_output_error(struct mem_ctl_info *mci,
-				    struct mce *m)
+				    const struct mce *m)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	char *type, *optype, *err, *msg;
@@ -1848,7 +1880,7 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 }
 
 static int i7core_register_mci(struct i7core_dev *i7core_dev,
-			       int num_channels, int num_csrows)
+			       const int num_channels, const int num_csrows)
 {
 	struct mem_ctl_info *mci;
 	struct i7core_pvt *pvt;
@@ -1883,7 +1915,12 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 				  i7core_dev->socket);
 	mci->dev_name = pci_name(i7core_dev->pdev[0]);
 	mci->ctl_page_to_phys = NULL;
-	mci->mc_driver_sysfs_attributes = i7core_sysfs_attrs;
+
+	if (pvt->is_registered)
+		mci->mc_driver_sysfs_attributes = i7core_sysfs_rdimm_attrs;
+	else
+		mci->mc_driver_sysfs_attributes = i7core_sysfs_udimm_attrs;
+
 	/* Set the function pointer to an actual operation function */
 	mci->edac_check = i7core_check_error;
 

commit 18c29002f95bc2f67c1c78d7fc7932843aa66657
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue Aug 10 18:33:27 2010 -0300

    i7core_edac: move static vars to the beginning of the file
    
    While here, don't initialize probed with 0.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 414182719640..4c1dcc1f562e 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -39,6 +39,11 @@
 
 #include "edac_core.h"
 
+/* Static vars */
+static LIST_HEAD(i7core_edac_list);
+static DEFINE_MUTEX(i7core_edac_lock);
+static int probed;
+
 /*
  * This is used for Nehalem-EP and Nehalem-EX devices, where the non-core
  * registers start at bus 255, and are not reported by BIOS.
@@ -266,10 +271,6 @@ struct i7core_pvt {
 	struct edac_pci_ctl_info *i7core_pci;
 };
 
-/* Static vars */
-static LIST_HEAD(i7core_edac_list);
-static DEFINE_MUTEX(i7core_edac_lock);
-
 #define PCI_DESCR(device, function, device_id)	\
 	.dev = (device),			\
 	.func = (function),			\
@@ -1950,8 +1951,6 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
  *		< 0 for error code
  */
 
-static int probed = 0;
-
 static int __devinit i7core_probe(struct pci_dev *pdev,
 				  const struct pci_device_id *id)
 {

commit 939747bd680eb09bb98792b17a5bfd2f525afe9d
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue Aug 10 11:22:01 2010 -0300

    i7core_edac: Be sure that the edac pci handler will be properly released
    
    With multi-sockets, more than one edac pci handler is enabled. Be sure to
    un-register all instances.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 0fd5b85a0f75..414182719640 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -261,6 +261,9 @@ struct i7core_pvt {
 
 	/* Count indicator to show errors not got */
 	unsigned		mce_overrun;
+
+	/* Struct to control EDAC polling */
+	struct edac_pci_ctl_info *i7core_pci;
 };
 
 /* Static vars */
@@ -378,8 +381,6 @@ static const struct pci_device_id i7core_pci_tbl[] __devinitdata = {
 	{0,}			/* 0 terminated list. */
 };
 
-static struct edac_pci_ctl_info *i7core_pci;
-
 /****************************************************************************
 			Anciliary status routines
  ****************************************************************************/
@@ -1906,9 +1907,9 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 	}
 
 	/* allocating generic PCI control info */
-	i7core_pci = edac_pci_create_generic_ctl(&i7core_dev->pdev[0]->dev,
+	pvt->i7core_pci = edac_pci_create_generic_ctl(&i7core_dev->pdev[0]->dev,
 						 EDAC_MOD_STR);
-	if (unlikely(!i7core_pci)) {
+	if (unlikely(!pvt->i7core_pci)) {
 		printk(KERN_WARNING
 			"%s(): Unable to create PCI control\n",
 			__func__);
@@ -2008,12 +2009,10 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 {
 	struct mem_ctl_info *mci;
 	struct i7core_dev *i7core_dev, *tmp;
+	struct i7core_pvt *pvt;
 
 	debugf0(__FILE__ ": %s()\n", __func__);
 
-	if (i7core_pci)
-		edac_pci_release_generic_ctl(i7core_pci);
-
 	/*
 	 * we have a trouble here: pdev value for removal will be wrong, since
 	 * it will point to the X58 register used to detect that the machine
@@ -2024,19 +2023,28 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 
 	mutex_lock(&i7core_edac_lock);
 	list_for_each_entry_safe(i7core_dev, tmp, &i7core_edac_list, list) {
-		mci = edac_mc_del_mc(&i7core_dev->pdev[0]->dev);
-		if (mci) {
-			struct i7core_pvt *pvt = mci->pvt_info;
-
+		mci = find_mci_by_dev(&i7core_dev->pdev[0]->dev);
+		if (unlikely(!mci || !mci->pvt_info)) {
+			i7core_printk(KERN_ERR,
+				      "Couldn't find mci hanler\n");
+		} else {
+			pvt = mci->pvt_info;
 			i7core_dev = pvt->i7core_dev;
+
+			if (likely(pvt->i7core_pci))
+				edac_pci_release_generic_ctl(pvt->i7core_pci);
+			else
+				i7core_printk(KERN_ERR,
+					      "Couldn't find mem_ctl_info for socket %d\n",
+					      i7core_dev->socket);
+			pvt->i7core_pci = NULL;
+
+			edac_mc_del_mc(&i7core_dev->pdev[0]->dev);
+
 			edac_mce_unregister(&pvt->edac_mce);
 			kfree(mci->ctl_name);
 			edac_mc_free(mci);
 			i7core_put_devices(i7core_dev);
-		} else {
-			i7core_printk(KERN_ERR,
-				      "Couldn't find mci for socket %d\n",
-				      i7core_dev->socket);
 		}
 	}
 	probed--;

commit 64aab720bdf8771214a7c88872bd8e3194c2d279
Author: Marcin Slusarz <marcin.slusarz@gmail.com>
Date:   Thu Sep 30 15:15:30 2010 -0700

    i7core_edac: fix panic in udimm sysfs attributes registration
    
    Array of udimm sysfs attributes was not ended with NULL marker, leading to
    dereference of random memory.
    
      EDAC DEBUG: edac_create_mci_instance_attributes: edac_create_mci_instance_attributes() file udimm0
      EDAC DEBUG: edac_create_mci_instance_attributes: edac_create_mci_instance_attributes() file udimm1
      EDAC DEBUG: edac_create_mci_instance_attributes: edac_create_mci_instance_attributes() file udimm2
      BUG: unable to handle kernel NULL pointer dereference at 00000000000001a4
      IP: [<ffffffff81330b36>] edac_create_mci_instance_attributes+0x148/0x1f1
      Pid: 1, comm: swapper Not tainted 2.6.36-rc3-nv+ #483 P6T SE/System Product Name
      RIP: 0010:[<ffffffff81330b36>]  [<ffffffff81330b36>] edac_create_mci_instance_attributes+0x148/0x1f1
      (...)
      Call Trace:
       [<ffffffff81330b86>] edac_create_mci_instance_attributes+0x198/0x1f1
       [<ffffffff81330c9a>] edac_create_sysfs_mci_device+0xbb/0x2b2
       [<ffffffff8132f533>] edac_mc_add_mc+0x46b/0x557
       [<ffffffff81428901>] i7core_probe+0xccf/0xec0
      RIP  [<ffffffff81330b36>] edac_create_mci_instance_attributes+0x148/0x1f1
      ---[ end trace 20de320855b81d78 ]---
      Kernel panic - not syncing: Attempted to kill init!
    
    Signed-off-by: Marcin Slusarz <marcin.slusarz@gmail.com>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Acked-by: Doug Thompson <dougthompson@xmission.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index e0187d16dd7c..0fd5b85a0f75 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1140,6 +1140,7 @@ static struct mcidev_sysfs_attribute i7core_udimm_counters_attrs[] = {
 	ATTR_COUNTER(0),
 	ATTR_COUNTER(1),
 	ATTR_COUNTER(2),
+	{ .attr = { .name = NULL } }
 };
 
 static struct mcidev_sysfs_group i7core_udimm_counters = {

commit ab08937400eabe862f58974ad031a86c4ea2903a
Author: Daniel J Blueman <daniel.blueman@gmail.com>
Date:   Fri Jul 23 23:16:52 2010 +0100

    quiesce EDAC initialisation on desktop/mobile i7
    
    Don't print failure to detect Core i7 EDAC facilities to the console at
    boot time, most often occurring on Core i7 desktops and laptops.
    
    Signed-off-by: Daniel J Blueman <daniel.blueman@gmail.com>
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index cc9357da0e34..e0187d16dd7c 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1300,7 +1300,7 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno,
 		if (devno == 0)
 			return -ENODEV;
 
-		i7core_printk(KERN_ERR,
+		i7core_printk(KERN_INFO,
 			"Device not found: dev %02x.%d PCI ID %04x:%04x\n",
 			dev_descr->dev, dev_descr->func,
 			PCI_VENDOR_ID_INTEL, dev_descr->dev_id);

commit 2d95d8158b5ab51339f8482c98c01469c45ff6d7
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Jun 30 01:42:21 2010 -0300

    i7core_edac: Avoid doing multiple probes for the same card
    
    As Nehalem/Nehalem-EP/Westmere devices uses several devices for the same
    functionality (memory controller), the default way of proping devices doesn't
    work. So, instead of a per-device probe, all devices should be probed at once.
    
    This means that we should block any new attempt of probe, otherwise, it will
    try to register the same device several times.
    
    Acked-by: Doug Thompson <dougthompson@xmission.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index d7c76800988e..cc9357da0e34 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1947,21 +1947,26 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
  *		0 for FOUND a device
  *		< 0 for error code
  */
+
+static int probed = 0;
+
 static int __devinit i7core_probe(struct pci_dev *pdev,
 				  const struct pci_device_id *id)
 {
-	int dev_idx = id->driver_data;
 	int rc;
 	struct i7core_dev *i7core_dev;
 
+	/* get the pci devices we want to reserve for our use */
+	mutex_lock(&i7core_edac_lock);
+
 	/*
 	 * All memory controllers are allocated at the first pass.
 	 */
-	if (unlikely(dev_idx >= 1))
+	if (unlikely(probed >= 1)) {
+		mutex_unlock(&i7core_edac_lock);
 		return -EINVAL;
-
-	/* get the pci devices we want to reserve for our use */
-	mutex_lock(&i7core_edac_lock);
+	}
+	probed++;
 
 	rc = i7core_get_devices(pci_dev_table);
 	if (unlikely(rc < 0))
@@ -2033,6 +2038,8 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 				      i7core_dev->socket);
 		}
 	}
+	probed--;
+
 	mutex_unlock(&i7core_edac_lock);
 }
 

commit bda142890e6bdd9b1115715e50b0276ea4b9978a
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Jun 30 01:41:35 2010 -0300

    i7core_edac: Properly discover the first QPI device
    
    On Nehalem/Nehalem-EP/Westmere, the first QPI device is the last PCI bus.
    The last bus is generally at 0x3f or 0xff, but there are also other systems
    using different setups. For example, HP Z800 has 0x7f as the last bus.
    
    This patch adds a logic to discover the last bus, dynamically detecting it
    at runtime.
    
    Acked-by: Doug Thompson <dougthompson@xmission.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 6b8b7b41ec5f..d7c76800988e 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1233,10 +1233,28 @@ static void __init i7core_xeon_pci_fixup(struct pci_id_table *table)
 			for (i = 0; i < MAX_SOCKET_BUSES; i++)
 				pcibios_scan_specific_bus(255-i);
 		}
+		pci_dev_put(pdev);
 		table++;
 	}
 }
 
+static unsigned i7core_pci_lastbus(void)
+{
+	int last_bus = 0, bus;
+	struct pci_bus *b = NULL;
+
+	while ((b = pci_find_next_bus(b)) != NULL) {
+		bus = b->number;
+		debugf0("Found bus %d\n", bus);
+		if (bus > last_bus)
+			last_bus = bus;
+	}
+
+	debugf0("Last bus %d\n", last_bus);
+
+	return last_bus;
+}
+
 /*
  *	i7core_get_devices	Find and perform 'get' operation on the MCH's
  *			device/functions we want to reference for this driver
@@ -1244,7 +1262,8 @@ static void __init i7core_xeon_pci_fixup(struct pci_id_table *table)
  *			Need to 'get' device 16 func 1 and func 2
  */
 int i7core_get_onedevice(struct pci_dev **prev, int devno,
-			 struct pci_id_descr *dev_descr, unsigned n_devs)
+			 struct pci_id_descr *dev_descr, unsigned n_devs,
+			 unsigned last_bus)
 {
 	struct i7core_dev *i7core_dev;
 
@@ -1291,10 +1310,7 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno,
 	}
 	bus = pdev->bus->number;
 
-	if (bus == 0x3f)
-		socket = 0;
-	else
-		socket = 255 - bus;
+	socket = last_bus - bus;
 
 	i7core_dev = get_i7core_dev(socket);
 	if (!i7core_dev) {
@@ -1358,17 +1374,21 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno,
 
 static int i7core_get_devices(struct pci_id_table *table)
 {
-	int i, rc;
+	int i, rc, last_bus;
 	struct pci_dev *pdev = NULL;
 	struct pci_id_descr *dev_descr;
 
+	last_bus = i7core_pci_lastbus();
+
 	while (table && table->descr) {
 		dev_descr = table->descr;
 		for (i = 0; i < table->n_devs; i++) {
 			pdev = NULL;
 			do {
-				rc = i7core_get_onedevice(&pdev, i, &dev_descr[i],
-							  table->n_devs);
+				rc = i7core_get_onedevice(&pdev, i,
+							  &dev_descr[i],
+							  table->n_devs,
+							  last_bus);
 				if (rc < 0) {
 					if (i == 0) {
 						i = table->n_devs;

commit 52707f918cca231f8461d45e78a60014795f20d9
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue May 18 20:43:52 2010 -0300

    i7core_edac: Better describe the supported devices
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 8d63b0046480..6b8b7b41ec5f 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1,9 +1,14 @@
-/* Intel 7 core  Memory Controller kernel module (Nehalem)
+/* Intel i7 core/Nehalem Memory Controller kernel module
+ *
+ * This driver supports yhe memory controllers found on the Intel
+ * processor families i7core, i7core 7xx/8xx, i5core, Xeon 35xx,
+ * Xeon 55xx and Xeon 56xx also known as Nehalem, Nehalem-EP, Lynnfield
+ * and Westmere-EP.
  *
  * This file may be distributed under the terms of the
  * GNU General Public License version 2 only.
  *
- * Copyright (c) 2009 by:
+ * Copyright (c) 2009-2010 by:
  *	 Mauro Carvalho Chehab <mchehab@redhat.com>
  *
  * Red Hat Inc. http://www.redhat.com

commit bd9e19ca46b54fa85141c4d20afd668379d94c81
Author: Vernon Mauery <vernux@us.ibm.com>
Date:   Tue May 18 19:02:50 2010 -0300

    Add support for Westmere to i7core_edac driver
    
    This adds new PCI IDs for the Westmere's memory controller
    devices and modifies the i7core_edac driver to be able to
    probe both Nehalem and Westmere processors.
    
    Signed-off-by: Vernon Mauery <vernux@us.ibm.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 3e2b5379bc05..8d63b0046480 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -206,6 +206,11 @@ struct pci_id_descr {
 	int			optional;
 };
 
+struct pci_id_table {
+	struct pci_id_descr	*descr;
+	int			n_devs;
+};
+
 struct i7core_dev {
 	struct list_head	list;
 	u8			socket;
@@ -262,7 +267,7 @@ static DEFINE_MUTEX(i7core_edac_lock);
 	.func = (function),			\
 	.dev_id = (device_id)
 
-struct pci_id_descr pci_dev_descr_i7core[] = {
+struct pci_id_descr pci_dev_descr_i7core_nehalem[] = {
 		/* Memory controller */
 	{ PCI_DESCR(3, 0, PCI_DEVICE_ID_INTEL_I7_MCR)     },
 	{ PCI_DESCR(3, 1, PCI_DEVICE_ID_INTEL_I7_MC_TAD)  },
@@ -321,6 +326,44 @@ struct pci_id_descr pci_dev_descr_lynnfield[] = {
 	{ PCI_DESCR( 0, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE)     },
 };
 
+struct pci_id_descr pci_dev_descr_i7core_westmere[] = {
+		/* Memory controller */
+	{ PCI_DESCR(3, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_MCR_REV2)     },
+	{ PCI_DESCR(3, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_TAD_REV2)  },
+			/* Exists only for RDIMM */
+	{ PCI_DESCR(3, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_RAS_REV2), .optional = 1  },
+	{ PCI_DESCR(3, 4, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_TEST_REV2) },
+
+		/* Channel 0 */
+	{ PCI_DESCR(4, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_CTRL_REV2) },
+	{ PCI_DESCR(4, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_ADDR_REV2) },
+	{ PCI_DESCR(4, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_RANK_REV2) },
+	{ PCI_DESCR(4, 3, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_TC_REV2)   },
+
+		/* Channel 1 */
+	{ PCI_DESCR(5, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_CTRL_REV2) },
+	{ PCI_DESCR(5, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_ADDR_REV2) },
+	{ PCI_DESCR(5, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_RANK_REV2) },
+	{ PCI_DESCR(5, 3, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_TC_REV2)   },
+
+		/* Channel 2 */
+	{ PCI_DESCR(6, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH2_CTRL_REV2) },
+	{ PCI_DESCR(6, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH2_ADDR_REV2) },
+	{ PCI_DESCR(6, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH2_RANK_REV2) },
+	{ PCI_DESCR(6, 3, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH2_TC_REV2)   },
+
+		/* Generic Non-core registers */
+	{ PCI_DESCR(0, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_REV2)  },
+
+};
+
+#define PCI_ID_TABLE_ENTRY(A) { A, ARRAY_SIZE(A) }
+struct pci_id_table pci_dev_table[] = {
+	PCI_ID_TABLE_ENTRY(pci_dev_descr_i7core_nehalem),
+	PCI_ID_TABLE_ENTRY(pci_dev_descr_lynnfield),
+	PCI_ID_TABLE_ENTRY(pci_dev_descr_i7core_westmere),
+};
+
 /*
  *	pci_device_id	table for which devices we are looking for
  */
@@ -1170,7 +1213,7 @@ static void i7core_put_all_devices(void)
 		i7core_put_devices(i7core_dev);
 }
 
-static void __init i7core_xeon_pci_fixup(int dev_id)
+static void __init i7core_xeon_pci_fixup(struct pci_id_table *table)
 {
 	struct pci_dev *pdev = NULL;
 	int i;
@@ -1179,10 +1222,13 @@ static void __init i7core_xeon_pci_fixup(int dev_id)
 	 * aren't announced by acpi. So, we need to use a legacy scan probing
 	 * to detect them
 	 */
-	pdev = pci_get_device(PCI_VENDOR_ID_INTEL, dev_id, NULL);
-	if (unlikely(!pdev)) {
-		for (i = 0; i < MAX_SOCKET_BUSES; i++)
-			pcibios_scan_specific_bus(255-i);
+	while (table && table->descr) {
+		pdev = pci_get_device(PCI_VENDOR_ID_INTEL, table->descr[0].dev_id, NULL);
+		if (unlikely(!pdev)) {
+			for (i = 0; i < MAX_SOCKET_BUSES; i++)
+				pcibios_scan_specific_bus(255-i);
+		}
+		table++;
 	}
 }
 
@@ -1213,15 +1259,10 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno,
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_I7_NONCORE_ALT, *prev);
 
-	if (dev_descr->dev_id == PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE && !pdev) {
+	if (dev_descr->dev_id == PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE && !pdev)
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_ALT,
 				      *prev);
-		if (!pdev)
-			pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
-					      PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_REV2,
-					      *prev);
-	}
 
 	if (!pdev) {
 		if (*prev) {
@@ -1232,6 +1273,9 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno,
 		if (dev_descr->optional)
 			return 0;
 
+		if (devno == 0)
+			return -ENODEV;
+
 		i7core_printk(KERN_ERR,
 			"Device not found: dev %02x.%d PCI ID %04x:%04x\n",
 			dev_descr->dev, dev_descr->func,
@@ -1307,24 +1351,34 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno,
 	return 0;
 }
 
-static int i7core_get_devices(struct pci_id_descr dev_descr[], unsigned n_devs)
+static int i7core_get_devices(struct pci_id_table *table)
 {
 	int i, rc;
 	struct pci_dev *pdev = NULL;
-
-	for (i = 0; i < n_devs; i++) {
-		pdev = NULL;
-		do {
-			rc = i7core_get_onedevice(&pdev, i, &dev_descr[i],
-						  n_devs);
-			if (rc < 0) {
-				i7core_put_all_devices();
-				return -ENODEV;
-			}
-		} while (pdev);
+	struct pci_id_descr *dev_descr;
+
+	while (table && table->descr) {
+		dev_descr = table->descr;
+		for (i = 0; i < table->n_devs; i++) {
+			pdev = NULL;
+			do {
+				rc = i7core_get_onedevice(&pdev, i, &dev_descr[i],
+							  table->n_devs);
+				if (rc < 0) {
+					if (i == 0) {
+						i = table->n_devs;
+						break;
+					}
+					i7core_put_all_devices();
+					return -ENODEV;
+				}
+			} while (pdev);
+		}
+		table++;
 	}
 
 	return 0;
+	return 0;
 }
 
 static int mci_bind_devs(struct mem_ctl_info *mci,
@@ -1884,18 +1938,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	/* get the pci devices we want to reserve for our use */
 	mutex_lock(&i7core_edac_lock);
 
-	if (pdev->device == PCI_DEVICE_ID_INTEL_LYNNFIELD_QPI_LINK0) {
-		printk(KERN_INFO "i7core_edac: detected a "
-				 "Lynnfield processor\n");
-		rc = i7core_get_devices(pci_dev_descr_lynnfield,
-					ARRAY_SIZE(pci_dev_descr_lynnfield));
-	} else {
-		printk(KERN_INFO "i7core_edac: detected a "
-				 "Nehalem/Nehalem-EP processor\n");
-		rc = i7core_get_devices(pci_dev_descr_i7core,
-					ARRAY_SIZE(pci_dev_descr_i7core));
-	}
-
+	rc = i7core_get_devices(pci_dev_table);
 	if (unlikely(rc < 0))
 		goto fail0;
 
@@ -1994,7 +2037,7 @@ static int __init i7core_init(void)
 	/* Ensure that the OPSTATE is set correctly for POLL or NMI */
 	opstate_init();
 
-	i7core_xeon_pci_fixup(pci_dev_descr_i7core[0].dev_id);
+	i7core_xeon_pci_fixup(pci_dev_table);
 
 	pci_rc = pci_register_driver(&i7core_driver);
 

commit d4d1ef4515cca074d5bbe1c63420822d6b20fe63
Author: Tony Luck <tony.luck@intel.com>
Date:   Tue May 18 10:53:25 2010 -0300

    i7core_edac: don't free on success
    
    Signed-off-by: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 82acfbd01779..3e2b5379bc05 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1856,7 +1856,8 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 	}
 
 fail:
-	edac_mc_free(mci);
+	if (rc < 0)
+		edac_mc_free(mci);
 	return rc;
 }
 

commit ac1ececea995fd77c8da6a1299674f22991cecaa
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Tue May 18 13:00:31 2010 -0300

    i7core_edac: Add support for X5670
    
    As reported by Vernon Mauery <vernux@us.ibm.com>, X5670 (Westmere-EP) uses a
    different register for one of the uncore PCI devices. Add support for
    it.
    
    Those are the PCI ID's on this new chipset:
    
    fe:00.0 0600: 8086:2c70 (rev 02)
    fe:00.1 0600: 8086:2d81 (rev 02)
    fe:02.0 0600: 8086:2d90 (rev 02)
    fe:02.1 0600: 8086:2d91 (rev 02)
    fe:02.2 0600: 8086:2d92 (rev 02)
    fe:02.3 0600: 8086:2d93 (rev 02)
    fe:02.4 0600: 8086:2d94 (rev 02)
    fe:02.5 0600: 8086:2d95 (rev 02)
    fe:03.0 0600: 8086:2d98 (rev 02)
    fe:03.1 0600: 8086:2d99 (rev 02)
    fe:03.2 0600: 8086:2d9a (rev 02)
    fe:03.4 0600: 8086:2d9c (rev 02)
    fe:04.0 0600: 8086:2da0 (rev 02)
    fe:04.1 0600: 8086:2da1 (rev 02)
    fe:04.2 0600: 8086:2da2 (rev 02)
    fe:04.3 0600: 8086:2da3 (rev 02)
    fe:05.0 0600: 8086:2da8 (rev 02)
    fe:05.1 0600: 8086:2da9 (rev 02)
    fe:05.2 0600: 8086:2daa (rev 02)
    fe:05.3 0600: 8086:2dab (rev 02)
    fe:06.0 0600: 8086:2db0 (rev 02)
    fe:06.1 0600: 8086:2db1 (rev 02)
    fe:06.2 0600: 8086:2db2 (rev 02)
    fe:06.3 0600: 8086:2db3 (rev 02)
    (as usual, the same PCI devices repeat at ff: bus)
    
    The PCI device 8086:2c70 is shown as:
    
    fe:00.0 Host bridge: Intel Corporation QuickPath Architecture Generic
    Non-core Registers (rev 02)
    
    So, for this device to be recognized, it is only a matter of adding this
    new PCI ID to the driver.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index cd51709c4d89..82acfbd01779 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1213,10 +1213,15 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno,
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_I7_NONCORE_ALT, *prev);
 
-	if (dev_descr->dev_id == PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE && !pdev)
+	if (dev_descr->dev_id == PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE && !pdev) {
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_ALT,
 				      *prev);
+		if (!pdev)
+			pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
+					      PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_REV2,
+					      *prev);
+	}
 
 	if (!pdev) {
 		if (*prev) {

commit 8a311e179e52d122ac203d8e88014284c18ca8ab
Author: Vernon Mauery <vernux@us.ibm.com>
Date:   Fri Apr 16 19:40:19 2010 -0300

    Always call i7core_[ur]dimm_check_mc_ecc_err
    
    This fixes an error in function i7core_check_error
    
    In commit ca9c90ba09ca3c9799319f46a56f397afbf617c2 which converts the
    driver to use double buffering, there is a change in the logic.  Before,
    if mce_count was zero, it skipped over a couple of statements and
    finished out with a call to the *check_mc_ecc_err function.  The current
    code checks to see if mce_count is 0 and then exits.
    
    This change reverts the behavior back to the original where if there are
    no errors to report, we skip to the end and call the *check_mc_ecc_err
    function.
    
    This fix allows the driver to work again on my Nehalem based blades
    again.
    
    Signed-off-by: Vernon Mauery <vernux@us.ibm.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 8e93df637bca..cd51709c4d89 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1670,7 +1670,7 @@ static void i7core_check_error(struct mem_ctl_info *mci)
 	count = (pvt->mce_out + MCE_LOG_LEN - pvt->mce_in)
 		% MCE_LOG_LEN;
 	if (!count)
-		return;
+		goto check_ce_error;
 
 	m = pvt->mce_outentry;
 	if (pvt->mce_in + count > MCE_LOG_LEN) {
@@ -1703,6 +1703,7 @@ static void i7core_check_error(struct mem_ctl_info *mci)
 	/*
 	 * Now, let's increment CE error counts
 	 */
+check_ce_error:
 	if (!pvt->is_registered)
 		i7core_udimm_check_mc_ecc_err(mci);
 	else

commit 2a6fae326713ec84f307c045f6b497d4afaeb1d4
Author: Alexander Beregalov <a.beregalov@gmail.com>
Date:   Thu Jan 7 23:27:30 2010 -0300

    i7core_edac: fix memory leak of i7core_dev
    
    Free already allocated i7core_dev.
    
    Signed-off-by: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 37ade251e9e2..8e93df637bca 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1249,8 +1249,10 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno,
 			return -ENOMEM;
 		i7core_dev->pdev = kzalloc(sizeof(*i7core_dev->pdev) * n_devs,
 					   GFP_KERNEL);
-		if (!i7core_dev->pdev)
+		if (!i7core_dev->pdev) {
+			kfree(i7core_dev);
 			return -ENOMEM;
+		}
 		i7core_dev->socket = socket;
 		i7core_dev->n_devs = n_devs;
 		list_add_tail(&i7core_dev->list, &i7core_edac_list);

commit 71753e0141a220ecbf9c71a66e0a8acce9705fb5
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Wed Dec 9 16:55:15 2009 -0300

    EDAC: add __init to i7core_xeon_pci_fixup
    
    It's called only from an __init function and is the only user
    of pcibios_scan_specific_bus which will be marked as __devinit in
    the next patch.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 4d6ecf1291b8..37ade251e9e2 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1170,7 +1170,7 @@ static void i7core_put_all_devices(void)
 		i7core_put_devices(i7core_dev);
 }
 
-static void i7core_xeon_pci_fixup(int dev_id)
+static void __init i7core_xeon_pci_fixup(int dev_id)
 {
 	struct pci_dev *pdev = NULL;
 	int i;

commit 508fa179f8e0da5d7241e12ad1562b96f291e800
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Oct 14 13:44:37 2009 -0300

    i7core_edac: Fix wrong device id for channel 1 devices
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index d3f5c016c5eb..4d6ecf1291b8 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -309,10 +309,10 @@ struct pci_id_descr pci_dev_descr_lynnfield[] = {
 	{ PCI_DESCR( 4, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_RANK) },
 	{ PCI_DESCR( 4, 3, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_TC)   },
 
-	{ PCI_DESCR( 4, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_CTRL) },
-	{ PCI_DESCR( 4, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_ADDR) },
-	{ PCI_DESCR( 4, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_RANK) },
-	{ PCI_DESCR( 4, 3, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_TC)   },
+	{ PCI_DESCR( 5, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_CTRL) },
+	{ PCI_DESCR( 5, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_ADDR) },
+	{ PCI_DESCR( 5, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_RANK) },
+	{ PCI_DESCR( 5, 3, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_TC)   },
 
 	/*
 	 * This is the PCI device has an alternate address on some

commit f05da2f7855b3b88a831ca79e037245872549ec0
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Oct 14 13:31:06 2009 -0300

    i7core: add support for Lynnfield alternate address
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index e525d571cb25..d3f5c016c5eb 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -314,6 +314,10 @@ struct pci_id_descr pci_dev_descr_lynnfield[] = {
 	{ PCI_DESCR( 4, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_RANK) },
 	{ PCI_DESCR( 4, 3, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_TC)   },
 
+	/*
+	 * This is the PCI device has an alternate address on some
+	 * processors like Core i7 860
+	 */
 	{ PCI_DESCR( 0, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE)     },
 };
 
@@ -322,7 +326,7 @@ struct pci_id_descr pci_dev_descr_lynnfield[] = {
  */
 static const struct pci_device_id i7core_pci_tbl[] __devinitdata = {
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_X58_HUB_MGMT)},
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_LYNNFIELD_QPI_LINK0)},
 	{0,}			/* 0 terminated list. */
 };
 
@@ -1209,6 +1213,11 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno,
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_I7_NONCORE_ALT, *prev);
 
+	if (dev_descr->dev_id == PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE && !pdev)
+		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
+				      PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_ALT,
+				      *prev);
+
 	if (!pdev) {
 		if (*prev) {
 			*prev = pdev;
@@ -1866,7 +1875,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	/* get the pci devices we want to reserve for our use */
 	mutex_lock(&i7core_edac_lock);
 
-	if (pdev->device == PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE) {
+	if (pdev->device == PCI_DEVICE_ID_INTEL_LYNNFIELD_QPI_LINK0) {
 		printk(KERN_INFO "i7core_edac: detected a "
 				 "Lynnfield processor\n");
 		rc = i7core_get_devices(pci_dev_descr_lynnfield,

commit 52a2e4fc3712d12888decd386d78ad526078a1fa
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Oct 14 11:21:58 2009 -0300

    i7core_edac: Add initial support for Lynnfield
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index e944b63d9f06..e525d571cb25 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -299,11 +299,30 @@ struct pci_id_descr pci_dev_descr_i7core[] = {
 
 };
 
+struct pci_id_descr pci_dev_descr_lynnfield[] = {
+	{ PCI_DESCR( 3, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_MCR)         },
+	{ PCI_DESCR( 3, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_TAD)      },
+	{ PCI_DESCR( 3, 4, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_TEST)     },
+
+	{ PCI_DESCR( 4, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_CTRL) },
+	{ PCI_DESCR( 4, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_ADDR) },
+	{ PCI_DESCR( 4, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_RANK) },
+	{ PCI_DESCR( 4, 3, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_TC)   },
+
+	{ PCI_DESCR( 4, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_CTRL) },
+	{ PCI_DESCR( 4, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_ADDR) },
+	{ PCI_DESCR( 4, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_RANK) },
+	{ PCI_DESCR( 4, 3, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_TC)   },
+
+	{ PCI_DESCR( 0, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE)     },
+};
+
 /*
  *	pci_device_id	table for which devices we are looking for
  */
 static const struct pci_device_id i7core_pci_tbl[] __devinitdata = {
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_X58_HUB_MGMT)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE)},
 	{0,}			/* 0 terminated list. */
 };
 
@@ -522,6 +541,9 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow)
 	for (i = 0; i < NUM_CHANS; i++) {
 		u32 data, dimm_dod[3], value[8];
 
+		if (!pvt->pci_ch[i][0])
+			continue;
+
 		if (!CH_ACTIVE(pvt, i)) {
 			debugf0("Channel %i is not active\n", i);
 			continue;
@@ -1001,6 +1023,9 @@ static ssize_t i7core_inject_enable_show(struct mem_ctl_info *mci,
 	struct i7core_pvt *pvt = mci->pvt_info;
 	u32 injectmask;
 
+	if (!pvt->pci_ch[pvt->inject.channel][0])
+		return 0;
+
 	pci_read_config_dword(pvt->pci_ch[pvt->inject.channel][0],
 			       MC_CHANNEL_ERROR_INJECT, &injectmask);
 
@@ -1841,8 +1866,18 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	/* get the pci devices we want to reserve for our use */
 	mutex_lock(&i7core_edac_lock);
 
-	rc = i7core_get_devices(pci_dev_descr_i7core,
-				ARRAY_SIZE(pci_dev_descr_i7core));
+	if (pdev->device == PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE) {
+		printk(KERN_INFO "i7core_edac: detected a "
+				 "Lynnfield processor\n");
+		rc = i7core_get_devices(pci_dev_descr_lynnfield,
+					ARRAY_SIZE(pci_dev_descr_lynnfield));
+	} else {
+		printk(KERN_INFO "i7core_edac: detected a "
+				 "Nehalem/Nehalem-EP processor\n");
+		rc = i7core_get_devices(pci_dev_descr_i7core,
+					ARRAY_SIZE(pci_dev_descr_i7core));
+	}
+
 	if (unlikely(rc < 0))
 		goto fail0;
 

commit 3b918c12df4f624140456d6c6f982bada8e1f095
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Sun Nov 8 01:36:40 2009 -0200

    edac: fix i7core build
    
    Fix build warning (missing header file) and
    build error when CONFIG_SMP=n.
    
    drivers/edac/i7core_edac.c:860: error: implicit declaration of function 'msleep'
    drivers/edac/i7core_edac.c:1700: error: 'struct cpuinfo_x86' has no member named 'phys_proc_id'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index bd7c727030a3..e944b63d9f06 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -25,6 +25,7 @@
 #include <linux/pci.h>
 #include <linux/pci_ids.h>
 #include <linux/slab.h>
+#include <linux/delay.h>
 #include <linux/edac.h>
 #include <linux/mmzone.h>
 #include <linux/edac_mce.h>
@@ -1696,9 +1697,11 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 	if (mce->bank != 8)
 		return 0;
 
+#ifdef CONFIG_SMP
 	/* Only handle if it is the right mc controller */
 	if (cpu_data(mce->cpu).phys_proc_id != pvt->i7core_dev->socket)
 		return 0;
+#endif
 
 	smp_rmb();
 	if ((pvt->mce_out + 1) % MCE_LOG_LEN == pvt->mce_in) {

commit 486dd09f129da01cd02b212ba48dce987488b860
Author: Alan Cox <alan@linux.intel.com>
Date:   Sun Nov 8 01:34:27 2009 -0200

    edac: i7core_edac produces undefined behaviour on 32bit
    
    Fix the shifts up
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Acked-by: Doug Thompson <dougthompson@xmission.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index b6fce2e38e3d..bd7c727030a3 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -916,41 +916,41 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 
 	/* Sets pvt->inject.dimm mask */
 	if (pvt->inject.dimm < 0)
-		mask |= 1L << 41;
+		mask |= 1LL << 41;
 	else {
 		if (pvt->channel[pvt->inject.channel].dimms > 2)
-			mask |= (pvt->inject.dimm & 0x3L) << 35;
+			mask |= (pvt->inject.dimm & 0x3LL) << 35;
 		else
-			mask |= (pvt->inject.dimm & 0x1L) << 36;
+			mask |= (pvt->inject.dimm & 0x1LL) << 36;
 	}
 
 	/* Sets pvt->inject.rank mask */
 	if (pvt->inject.rank < 0)
-		mask |= 1L << 40;
+		mask |= 1LL << 40;
 	else {
 		if (pvt->channel[pvt->inject.channel].dimms > 2)
-			mask |= (pvt->inject.rank & 0x1L) << 34;
+			mask |= (pvt->inject.rank & 0x1LL) << 34;
 		else
-			mask |= (pvt->inject.rank & 0x3L) << 34;
+			mask |= (pvt->inject.rank & 0x3LL) << 34;
 	}
 
 	/* Sets pvt->inject.bank mask */
 	if (pvt->inject.bank < 0)
-		mask |= 1L << 39;
+		mask |= 1LL << 39;
 	else
-		mask |= (pvt->inject.bank & 0x15L) << 30;
+		mask |= (pvt->inject.bank & 0x15LL) << 30;
 
 	/* Sets pvt->inject.page mask */
 	if (pvt->inject.page < 0)
-		mask |= 1L << 38;
+		mask |= 1LL << 38;
 	else
-		mask |= (pvt->inject.page & 0xffffL) << 14;
+		mask |= (pvt->inject.page & 0xffff) << 14;
 
 	/* Sets pvt->inject.column mask */
 	if (pvt->inject.col < 0)
-		mask |= 1L << 37;
+		mask |= 1LL << 37;
 	else
-		mask |= (pvt->inject.col & 0x3fffL);
+		mask |= (pvt->inject.col & 0x3fff);
 
 	/*
 	 * bit    0: REPEAT_EN

commit de06eeef5809a69ff4daaae2bd63977e5404553d
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Oct 14 08:02:40 2009 -0300

    i7core_edac: Use a more generic approach for probing PCI devices
    
    Currently, only one PCI set of tables is allowed. This prevents using
    the driver for other devices like Lynnfield, with have a different
    set of PCI ID's.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index bb538dfbdc6c..b6fce2e38e3d 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -202,12 +202,14 @@ struct pci_id_descr {
 	int			dev;
 	int			func;
 	int 			dev_id;
+	int			optional;
 };
 
 struct i7core_dev {
 	struct list_head	list;
 	u8			socket;
 	struct pci_dev		**pdev;
+	int			n_devs;
 	struct mem_ctl_info	*mci;
 };
 
@@ -259,11 +261,12 @@ static DEFINE_MUTEX(i7core_edac_lock);
 	.func = (function),			\
 	.dev_id = (device_id)
 
-struct pci_id_descr pci_dev_descr[] = {
+struct pci_id_descr pci_dev_descr_i7core[] = {
 		/* Memory controller */
 	{ PCI_DESCR(3, 0, PCI_DEVICE_ID_INTEL_I7_MCR)     },
 	{ PCI_DESCR(3, 1, PCI_DEVICE_ID_INTEL_I7_MC_TAD)  },
-	{ PCI_DESCR(3, 2, PCI_DEVICE_ID_INTEL_I7_MC_RAS)  }, /* if RDIMM */
+			/* Exists only for RDIMM */
+	{ PCI_DESCR(3, 2, PCI_DEVICE_ID_INTEL_I7_MC_RAS), .optional = 1  },
 	{ PCI_DESCR(3, 4, PCI_DEVICE_ID_INTEL_I7_MC_TEST) },
 
 		/* Channel 0 */
@@ -294,7 +297,6 @@ struct pci_id_descr pci_dev_descr[] = {
 	{ PCI_DESCR(0, 0, PCI_DEVICE_ID_INTEL_I7_NONCORE)  },
 
 };
-#define N_DEVS ARRAY_SIZE(pci_dev_descr)
 
 /*
  *	pci_device_id	table for which devices we are looking for
@@ -380,7 +382,7 @@ static struct pci_dev *get_pdev_slot_func(u8 socket, unsigned slot,
 	if (!i7core_dev)
 		return NULL;
 
-	for (i = 0; i < N_DEVS; i++) {
+	for (i = 0; i < i7core_dev->n_devs; i++) {
 		if (!i7core_dev->pdev[i])
 			continue;
 
@@ -1116,7 +1118,7 @@ static void i7core_put_devices(struct i7core_dev *i7core_dev)
 	int i;
 
 	debugf0(__FILE__ ": %s()\n", __func__);
-	for (i = 0; i < N_DEVS; i++) {
+	for (i = 0; i < i7core_dev->n_devs; i++) {
 		struct pci_dev *pdev = i7core_dev->pdev[i];
 		if (!pdev)
 			continue;
@@ -1138,7 +1140,7 @@ static void i7core_put_all_devices(void)
 		i7core_put_devices(i7core_dev);
 }
 
-static void i7core_xeon_pci_fixup(void)
+static void i7core_xeon_pci_fixup(int dev_id)
 {
 	struct pci_dev *pdev = NULL;
 	int i;
@@ -1147,8 +1149,7 @@ static void i7core_xeon_pci_fixup(void)
 	 * aren't announced by acpi. So, we need to use a legacy scan probing
 	 * to detect them
 	 */
-	pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
-			      pci_dev_descr[0].dev_id, NULL);
+	pdev = pci_get_device(PCI_VENDOR_ID_INTEL, dev_id, NULL);
 	if (unlikely(!pdev)) {
 		for (i = 0; i < MAX_SOCKET_BUSES; i++)
 			pcibios_scan_specific_bus(255-i);
@@ -1161,7 +1162,8 @@ static void i7core_xeon_pci_fixup(void)
  *
  *			Need to 'get' device 16 func 1 and func 2
  */
-int i7core_get_onedevice(struct pci_dev **prev, int devno)
+int i7core_get_onedevice(struct pci_dev **prev, int devno,
+			 struct pci_id_descr *dev_descr, unsigned n_devs)
 {
 	struct i7core_dev *i7core_dev;
 
@@ -1170,14 +1172,14 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno)
 	u8 socket = 0;
 
 	pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
-			      pci_dev_descr[devno].dev_id, *prev);
+			      dev_descr->dev_id, *prev);
 
 	/*
 	 * On Xeon 55xx, the Intel Quckpath Arch Generic Non-core regs
 	 * is at addr 8086:2c40, instead of 8086:2c41. So, we need
 	 * to probe for the alternate address in case of failure
 	 */
-	if (pci_dev_descr[devno].dev_id == PCI_DEVICE_ID_INTEL_I7_NONCORE && !pdev)
+	if (dev_descr->dev_id == PCI_DEVICE_ID_INTEL_I7_NONCORE && !pdev)
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_I7_NONCORE_ALT, *prev);
 
@@ -1187,19 +1189,13 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno)
 			return 0;
 		}
 
-		/*
-		 * Dev 3 function 2 only exists on chips with RDIMMs
-		 * so, it is ok to not found it
-		 */
-		if ((pci_dev_descr[devno].dev == 3) && (pci_dev_descr[devno].func == 2)) {
-			*prev = pdev;
+		if (dev_descr->optional)
 			return 0;
-		}
 
 		i7core_printk(KERN_ERR,
 			"Device not found: dev %02x.%d PCI ID %04x:%04x\n",
-			pci_dev_descr[devno].dev, pci_dev_descr[devno].func,
-			PCI_VENDOR_ID_INTEL, pci_dev_descr[devno].dev_id);
+			dev_descr->dev, dev_descr->func,
+			PCI_VENDOR_ID_INTEL, dev_descr->dev_id);
 
 		/* End of list, leave */
 		return -ENODEV;
@@ -1216,11 +1212,12 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno)
 		i7core_dev = kzalloc(sizeof(*i7core_dev), GFP_KERNEL);
 		if (!i7core_dev)
 			return -ENOMEM;
-		i7core_dev->pdev = kzalloc(sizeof(*i7core_dev->pdev) * N_DEVS,
+		i7core_dev->pdev = kzalloc(sizeof(*i7core_dev->pdev) * n_devs,
 					   GFP_KERNEL);
 		if (!i7core_dev->pdev)
 			return -ENOMEM;
 		i7core_dev->socket = socket;
+		i7core_dev->n_devs = n_devs;
 		list_add_tail(&i7core_dev->list, &i7core_edac_list);
 	}
 
@@ -1228,8 +1225,8 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno)
 		i7core_printk(KERN_ERR,
 			"Duplicated device for "
 			"dev %02x:%02x.%d PCI ID %04x:%04x\n",
-			bus, pci_dev_descr[devno].dev, pci_dev_descr[devno].func,
-			PCI_VENDOR_ID_INTEL, pci_dev_descr[devno].dev_id);
+			bus, dev_descr->dev, dev_descr->func,
+			PCI_VENDOR_ID_INTEL, dev_descr->dev_id);
 		pci_dev_put(pdev);
 		return -ENODEV;
 	}
@@ -1237,14 +1234,14 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno)
 	i7core_dev->pdev[devno] = pdev;
 
 	/* Sanity check */
-	if (unlikely(PCI_SLOT(pdev->devfn) != pci_dev_descr[devno].dev ||
-			PCI_FUNC(pdev->devfn) != pci_dev_descr[devno].func)) {
+	if (unlikely(PCI_SLOT(pdev->devfn) != dev_descr->dev ||
+			PCI_FUNC(pdev->devfn) != dev_descr->func)) {
 		i7core_printk(KERN_ERR,
 			"Device PCI ID %04x:%04x "
 			"has dev %02x:%02x.%d instead of dev %02x:%02x.%d\n",
-			PCI_VENDOR_ID_INTEL, pci_dev_descr[devno].dev_id,
+			PCI_VENDOR_ID_INTEL, dev_descr->dev_id,
 			bus, PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),
-			bus, pci_dev_descr[devno].dev, pci_dev_descr[devno].func);
+			bus, dev_descr->dev, dev_descr->func);
 		return -ENODEV;
 	}
 
@@ -1253,30 +1250,32 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno)
 		i7core_printk(KERN_ERR,
 			"Couldn't enable "
 			"dev %02x:%02x.%d PCI ID %04x:%04x\n",
-			bus, pci_dev_descr[devno].dev, pci_dev_descr[devno].func,
-			PCI_VENDOR_ID_INTEL, pci_dev_descr[devno].dev_id);
+			bus, dev_descr->dev, dev_descr->func,
+			PCI_VENDOR_ID_INTEL, dev_descr->dev_id);
 		return -ENODEV;
 	}
 
 	debugf0("Detected socket %d dev %02x:%02x.%d PCI ID %04x:%04x\n",
-		socket, bus, pci_dev_descr[devno].dev,
-		pci_dev_descr[devno].func,
-		PCI_VENDOR_ID_INTEL, pci_dev_descr[devno].dev_id);
+		socket, bus, dev_descr->dev,
+		dev_descr->func,
+		PCI_VENDOR_ID_INTEL, dev_descr->dev_id);
 
 	*prev = pdev;
 
 	return 0;
 }
 
-static int i7core_get_devices(void)
+static int i7core_get_devices(struct pci_id_descr dev_descr[], unsigned n_devs)
 {
-	int i;
+	int i, rc;
 	struct pci_dev *pdev = NULL;
 
-	for (i = 0; i < N_DEVS; i++) {
+	for (i = 0; i < n_devs; i++) {
 		pdev = NULL;
 		do {
-			if (i7core_get_onedevice(&pdev, i) < 0) {
+			rc = i7core_get_onedevice(&pdev, i, &dev_descr[i],
+						  n_devs);
+			if (rc < 0) {
 				i7core_put_all_devices();
 				return -ENODEV;
 			}
@@ -1298,7 +1297,7 @@ static int mci_bind_devs(struct mem_ctl_info *mci,
 	i7core_dev->mci = mci;
 
 	pvt->is_registered = 0;
-	for (i = 0; i < N_DEVS; i++) {
+	for (i = 0; i < i7core_dev->n_devs; i++) {
 		pdev = i7core_dev->pdev[i];
 		if (!pdev)
 			continue;
@@ -1838,7 +1837,9 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 
 	/* get the pci devices we want to reserve for our use */
 	mutex_lock(&i7core_edac_lock);
-	rc = i7core_get_devices();
+
+	rc = i7core_get_devices(pci_dev_descr_i7core,
+				ARRAY_SIZE(pci_dev_descr_i7core));
 	if (unlikely(rc < 0))
 		goto fail0;
 
@@ -1937,7 +1938,7 @@ static int __init i7core_init(void)
 	/* Ensure that the OPSTATE is set correctly for POLL or NMI */
 	opstate_init();
 
-	i7core_xeon_pci_fixup();
+	i7core_xeon_pci_fixup(pci_dev_descr_i7core[0].dev_id);
 
 	pci_rc = pci_register_driver(&i7core_driver);
 

commit fd3826549db7f73d22b9c9abb80e01effb95c2ba
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Oct 14 06:07:07 2009 -0300

    i7core_edac: PCI device is called NONCORE, instead of NOCORE
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index c2857f60ae6a..bb538dfbdc6c 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -291,7 +291,7 @@ struct pci_id_descr pci_dev_descr[] = {
 	 * the probing code needs to test for the other address in case of
 	 * failure of this one
 	 */
-	{ PCI_DESCR(0, 0, PCI_DEVICE_ID_INTEL_I7_NOCORE)  },
+	{ PCI_DESCR(0, 0, PCI_DEVICE_ID_INTEL_I7_NONCORE)  },
 
 };
 #define N_DEVS ARRAY_SIZE(pci_dev_descr)
@@ -1177,9 +1177,9 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno)
 	 * is at addr 8086:2c40, instead of 8086:2c41. So, we need
 	 * to probe for the alternate address in case of failure
 	 */
-	if (pci_dev_descr[devno].dev_id == PCI_DEVICE_ID_INTEL_I7_NOCORE && !pdev)
+	if (pci_dev_descr[devno].dev_id == PCI_DEVICE_ID_INTEL_I7_NONCORE && !pdev)
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
-				      PCI_DEVICE_ID_INTEL_I7_NOCORE_ALT, *prev);
+				      PCI_DEVICE_ID_INTEL_I7_NONCORE_ALT, *prev);
 
 	if (!pdev) {
 		if (*prev) {

commit 321ece4dda32f52d4a28d6eb11f2ca2a5c93c191
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Oct 8 13:11:08 2009 -0300

    i7core_edac: Fix ringbuffer maxsize
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 59ec44175560..c2857f60ae6a 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1631,14 +1631,14 @@ static void i7core_check_error(struct mem_ctl_info *mci)
 	 * loosing an error.
 	 */
 	smp_rmb();
-	count = (pvt->mce_out + sizeof(mce_entry) - pvt->mce_in)
-		% sizeof(mce_entry);
+	count = (pvt->mce_out + MCE_LOG_LEN - pvt->mce_in)
+		% MCE_LOG_LEN;
 	if (!count)
 		return;
 
 	m = pvt->mce_outentry;
-	if (pvt->mce_in + count > sizeof(mce_entry)) {
-		unsigned l = sizeof(mce_entry) - pvt->mce_in;
+	if (pvt->mce_in + count > MCE_LOG_LEN) {
+		unsigned l = MCE_LOG_LEN - pvt->mce_in;
 
 		memcpy(m, &pvt->mce_entry[pvt->mce_in], sizeof(*m) * l);
 		smp_wmb();
@@ -1702,7 +1702,7 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 		return 0;
 
 	smp_rmb();
-	if ((pvt->mce_out + 1) % sizeof(mce_entry) == pvt->mce_in) {
+	if ((pvt->mce_out + 1) % MCE_LOG_LEN == pvt->mce_in) {
 		smp_wmb();
 		pvt->mce_overrun++;
 		return 0;
@@ -1711,7 +1711,7 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 	/* Copy memory error at the ringbuffer */
 	memcpy(&pvt->mce_entry[pvt->mce_out], mce, sizeof(*mce));
 	smp_wmb();
-	pvt->mce_out = (pvt->mce_out + 1) % sizeof(mce_entry);
+	pvt->mce_out = (pvt->mce_out + 1) % MCE_LOG_LEN;
 
 	/* Handle fatal errors immediately */
 	if (mce->mcgstatus & 1)

commit 6e103be1c7c4adb50f25aaf1f1e8f828833c1719
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Oct 5 09:40:09 2009 -0300

    i7core_edac: First store, then increment
    
    Fix ringbuffer store logic.
    
    While here, add a few comments to the code and remove the undesired
    printk that could otherwise be called during NMI time.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 477b62a74dbf..59ec44175560 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1678,6 +1678,8 @@ static void i7core_check_error(struct mem_ctl_info *mci)
  *				This routine simply queues mcelog errors, and
  *				return. The error itself should be handled later
  *				by i7core_check_error.
+ * WARNING: As this routine should be called at NMI time, extra care should
+ * be taken to avoid deadlocks, and to be as fast as possible.
  */
 static int i7core_mce_check_error(void *priv, struct mce *mce)
 {
@@ -1696,13 +1698,8 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 		return 0;
 
 	/* Only handle if it is the right mc controller */
-	if (cpu_data(mce->cpu).phys_proc_id != pvt->i7core_dev->socket) {
-		debugf0("mc%d: ignoring mce log for socket %d. "
-			"Another mc should get it.\n",
-			pvt->i7core_dev->socket,
-			cpu_data(mce->cpu).phys_proc_id);
+	if (cpu_data(mce->cpu).phys_proc_id != pvt->i7core_dev->socket)
 		return 0;
-	}
 
 	smp_rmb();
 	if ((pvt->mce_out + 1) % sizeof(mce_entry) == pvt->mce_in) {
@@ -1710,9 +1707,11 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 		pvt->mce_overrun++;
 		return 0;
 	}
+
+	/* Copy memory error at the ringbuffer */
+	memcpy(&pvt->mce_entry[pvt->mce_out], mce, sizeof(*mce));
 	smp_wmb();
 	pvt->mce_out = (pvt->mce_out + 1) % sizeof(mce_entry);
-	memcpy(&pvt->mce_entry[pvt->mce_out], mce, sizeof(*mce));
 
 	/* Handle fatal errors immediately */
 	if (mce->mcgstatus & 1)

commit 4f87fad1d32fcdda448f9eb430c9c234a1939ece
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sun Oct 4 11:54:56 2009 -0300

    i7core_edac: Better parse "any" addrmask
    
    Instead of accepting just "any", accept also "any\n"
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 94aeca011ac4..477b62a74dbf 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -800,7 +800,7 @@ static ssize_t i7core_inject_store_##param(			\
 	if (pvt->inject.enable)					\
 		disable_inject(mci);				\
 								\
-	if (!strcasecmp(data, "any"))				\
+	if (!strcasecmp(data, "any") || !strcasecmp(data, "any\n"))\
 		value = -1;					\
 	else {							\
 		rc = strict_strtoul(data, 10, &value);		\

commit ca9c90ba09ca3c9799319f46a56f397afbf617c2
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sun Oct 4 10:15:40 2009 -0300

    i7core_edac: Use a lockless ringbuffer
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 97f6d1759c99..94aeca011ac4 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -28,7 +28,6 @@
 #include <linux/edac.h>
 #include <linux/mmzone.h>
 #include <linux/edac_mce.h>
-#include <linux/spinlock.h>
 #include <linux/smp.h>
 #include <asm/processor.h>
 
@@ -239,9 +238,16 @@ struct i7core_pvt {
 
 	/* mcelog glue */
 	struct edac_mce		edac_mce;
+
+	/* Fifo double buffers */
 	struct mce		mce_entry[MCE_LOG_LEN];
-	unsigned		mce_count;
-	spinlock_t		mce_lock;
+	struct mce		mce_outentry[MCE_LOG_LEN];
+
+	/* Fifo in/out counters */
+	unsigned		mce_in, mce_out;
+
+	/* Count indicator to show errors not got */
+	unsigned		mce_overrun;
 };
 
 /* Static vars */
@@ -1617,30 +1623,50 @@ static void i7core_check_error(struct mem_ctl_info *mci)
 	struct i7core_pvt *pvt = mci->pvt_info;
 	int i;
 	unsigned count = 0;
-	struct mce *m = NULL;
-	unsigned long flags;
+	struct mce *m;
 
-	/* Copy all mce errors into a temporary buffer */
-	spin_lock_irqsave(&pvt->mce_lock, flags);
-	if (pvt->mce_count) {
-		m = kmalloc(sizeof(*m) * pvt->mce_count, GFP_ATOMIC);
+	/*
+	 * MCE first step: Copy all mce errors into a temporary buffer
+	 * We use a double buffering here, to reduce the risk of
+	 * loosing an error.
+	 */
+	smp_rmb();
+	count = (pvt->mce_out + sizeof(mce_entry) - pvt->mce_in)
+		% sizeof(mce_entry);
+	if (!count)
+		return;
 
-		if (m) {
-			count = pvt->mce_count;
-			memcpy(m, &pvt->mce_entry, sizeof(*m) * count);
-		}
-		pvt->mce_count = 0;
-	}
+	m = pvt->mce_outentry;
+	if (pvt->mce_in + count > sizeof(mce_entry)) {
+		unsigned l = sizeof(mce_entry) - pvt->mce_in;
 
-	spin_unlock_irqrestore(&pvt->mce_lock, flags);
+		memcpy(m, &pvt->mce_entry[pvt->mce_in], sizeof(*m) * l);
+		smp_wmb();
+		pvt->mce_in = 0;
+		count -= l;
+		m += l;
+	}
+	memcpy(m, &pvt->mce_entry[pvt->mce_in], sizeof(*m) * count);
+	smp_wmb();
+	pvt->mce_in += count;
+
+	smp_rmb();
+	if (pvt->mce_overrun) {
+		i7core_printk(KERN_ERR, "Lost %d memory errors\n",
+			      pvt->mce_overrun);
+		smp_wmb();
+		pvt->mce_overrun = 0;
+	}
 
-	/* proccess mcelog errors */
+	/*
+	 * MCE second step: parse errors and display
+	 */
 	for (i = 0; i < count; i++)
-		i7core_mce_output_error(mci, &m[i]);
+		i7core_mce_output_error(mci, &pvt->mce_outentry[i]);
 
-	kfree(m);
-
-	/* check memory count errors */
+	/*
+	 * Now, let's increment CE error counts
+	 */
 	if (!pvt->is_registered)
 		i7core_udimm_check_mc_ecc_err(mci);
 	else
@@ -1657,7 +1683,6 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 {
 	struct mem_ctl_info *mci = priv;
 	struct i7core_pvt *pvt = mci->pvt_info;
-	unsigned long flags;
 
 	/*
 	 * Just let mcelog handle it if the error is
@@ -1679,12 +1704,15 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 		return 0;
 	}
 
-	spin_lock_irqsave(&pvt->mce_lock, flags);
-	if (pvt->mce_count < MCE_LOG_LEN) {
-		memcpy(&pvt->mce_entry[pvt->mce_count], mce, sizeof(*mce));
-		pvt->mce_count++;
+	smp_rmb();
+	if ((pvt->mce_out + 1) % sizeof(mce_entry) == pvt->mce_in) {
+		smp_wmb();
+		pvt->mce_overrun++;
+		return 0;
 	}
-	spin_unlock_irqrestore(&pvt->mce_lock, flags);
+	smp_wmb();
+	pvt->mce_out = (pvt->mce_out + 1) % sizeof(mce_entry);
+	memcpy(&pvt->mce_entry[pvt->mce_out], mce, sizeof(*mce));
 
 	/* Handle fatal errors immediately */
 	if (mce->mcgstatus & 1)
@@ -1777,7 +1805,6 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 	/* Registers on edac_mce in order to receive memory errors */
 	pvt->edac_mce.priv = mci;
 	pvt->edac_mce.check_error = i7core_mce_check_error;
-	spin_lock_init(&pvt->mce_lock);
 
 	rc = edac_mce_register(&pvt->edac_mce);
 	if (unlikely(rc < 0)) {

commit f338d736910edf00e8426ee4322cfda585268d50
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Sep 24 17:25:43 2009 -0300

    i7core_edac: Convert UDIMM error counters into a proper sysfs group
    
    Instead of displaying 3 values at the same var, break it into 3
    different sysfs nodes:
    
    /sys/devices/system/edac/mc/mc0/all_channel_counts/udimm0
    /sys/devices/system/edac/mc/mc0/all_channel_counts/udimm1
    /sys/devices/system/edac/mc/mc0/all_channel_counts/udimm2
    
    For registered dimms, however, the error counters are already being
    displayed at:
            /sys/devices/system/edac/mc/mc0/csrow*/ce_count
    
    So, there's no need to add any extra sysfs nodes.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index e013004745de..97f6d1759c99 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1003,38 +1003,32 @@ static ssize_t i7core_inject_enable_show(struct mem_ctl_info *mci,
 	return sprintf(data, "%d\n", pvt->inject.enable);
 }
 
-static ssize_t i7core_ce_regs_show(struct mem_ctl_info *mci, char *data)
-{
-	unsigned i, count, total = 0;
-	struct i7core_pvt *pvt = mci->pvt_info;
+#define DECLARE_COUNTER(param)					\
+static ssize_t i7core_show_counter_##param(			\
+		struct mem_ctl_info *mci,			\
+		char *data)					\
+{								\
+	struct i7core_pvt *pvt = mci->pvt_info;			\
+								\
+	debugf1("%s() \n", __func__);				\
+	if (!pvt->ce_count_available || (pvt->is_registered))	\
+		return sprintf(data, "data unavailable\n");	\
+	return sprintf(data, "%lu\n",				\
+			pvt->udimm_ce_count[param]);		\
+}
 
-	if (!pvt->ce_count_available) {
-		count = sprintf(data, "data unavailable\n");
-		return 0;
-	}
-	if (!pvt->is_registered) {
-		count = sprintf(data, "all channels "
-				"UDIMM0: %lu UDIMM1: %lu UDIMM2: %lu\n",
-				pvt->udimm_ce_count[0],
-				pvt->udimm_ce_count[1],
-				pvt->udimm_ce_count[2]);
-		data  += count;
-		total += count;
-	} else {
-		for (i = 0; i < NUM_CHANS; i++) {
-			count = sprintf(data, "channel %d RDIMM0: %lu "
-					"RDIMM1: %lu RDIMM2: %lu\n",
-					i,
-					pvt->rdimm_ce_count[i][0],
-					pvt->rdimm_ce_count[i][1],
-					pvt->rdimm_ce_count[i][2]);
-			data  += count;
-			total += count;
-		}
+#define ATTR_COUNTER(param)					\
+	{							\
+		.attr = {					\
+			.name = __stringify(udimm##param),	\
+			.mode = (S_IRUGO | S_IWUSR)		\
+		},						\
+		.show  = i7core_show_counter_##param		\
 	}
 
-	return total;
-}
+DECLARE_COUNTER(0);
+DECLARE_COUNTER(1);
+DECLARE_COUNTER(2);
 
 /*
  * Sysfs struct
@@ -1051,12 +1045,22 @@ static struct mcidev_sysfs_attribute i7core_addrmatch_attrs[] = {
 	{ .attr = { .name = NULL } }
 };
 
-
 static struct mcidev_sysfs_group i7core_inject_addrmatch = {
 	.name  = "inject_addrmatch",
 	.mcidev_attr = i7core_addrmatch_attrs,
 };
 
+static struct mcidev_sysfs_attribute i7core_udimm_counters_attrs[] = {
+	ATTR_COUNTER(0),
+	ATTR_COUNTER(1),
+	ATTR_COUNTER(2),
+};
+
+static struct mcidev_sysfs_group i7core_udimm_counters = {
+	.name  = "all_channel_counts",
+	.mcidev_attr = i7core_udimm_counters_attrs,
+};
+
 static struct mcidev_sysfs_attribute i7core_sysfs_attrs[] = {
 	{
 		.attr = {
@@ -1088,14 +1092,8 @@ static struct mcidev_sysfs_attribute i7core_sysfs_attrs[] = {
 		},
 		.show  = i7core_inject_enable_show,
 		.store = i7core_inject_enable_store,
-	}, {
-		.attr = {
-			.name = "corrected_error_counts",
-			.mode = (S_IRUGO | S_IWUSR)
-		},
-		.show  = i7core_ce_regs_show,
-		.store = NULL,
 	},
+	{ .attr = { .name = NULL } },	/* Reserved for udimm counters */
 	{ .attr = { .name = NULL } }
 };
 
@@ -1323,6 +1321,15 @@ static int mci_bind_devs(struct mem_ctl_info *mci,
 			pvt->is_registered = 1;
 	}
 
+	/*
+	 * Add extra nodes to count errors on udimm
+	 * For registered memory, this is not needed, since the counters
+	 * are already displayed at the standard locations
+	 */
+	if (!pvt->is_registered)
+		i7core_sysfs_attrs[ARRAY_SIZE(i7core_sysfs_attrs)-2].grp =
+			&i7core_udimm_counters;
+
 	return 0;
 
 error:

commit cc301b3ae3f615fe243f023e68e22b8298a6f883
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Sep 24 16:23:42 2009 -0300

    edac: store/show methods for device groups weren't working
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index afa5281e8df9..e013004745de 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -784,10 +784,13 @@ static ssize_t i7core_inject_store_##param(			\
 		struct mem_ctl_info *mci,			\
 		const char *data, size_t count)			\
 {								\
-	struct i7core_pvt *pvt = mci->pvt_info;			\
+	struct i7core_pvt *pvt;					\
 	long value;						\
 	int rc;							\
 								\
+	debugf1("%s()\n", __func__);				\
+	pvt = mci->pvt_info;					\
+								\
 	if (pvt->inject.enable)					\
 		disable_inject(mci);				\
 								\
@@ -808,7 +811,10 @@ static ssize_t i7core_inject_show_##param(			\
 		struct mem_ctl_info *mci,			\
 		char *data)					\
 {								\
-	struct i7core_pvt *pvt = mci->pvt_info;			\
+	struct i7core_pvt *pvt;					\
+								\
+	pvt = mci->pvt_info;					\
+	debugf1("%s() pvt=%p\n", __func__, pvt);		\
 	if (pvt->inject.param < 0)				\
 		return sprintf(data, "any\n");			\
 	else							\

commit a5538e531fc1e00ac7185dcfcebf33c37b5d742e
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Sep 23 18:56:47 2009 -0300

    i7core_edac: Add support for sysfs addrmatch group
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 0478cc85e920..afa5281e8df9 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -778,105 +778,59 @@ static ssize_t i7core_inject_eccmask_show(struct mem_ctl_info *mci,
  *   23:16 and 31:24). Flipping bits in two symbol pairs will cause an
  *   uncorrectable error to be injected.
  */
-static ssize_t i7core_inject_addrmatch_store(struct mem_ctl_info *mci,
-					const char *data, size_t count)
-{
-	struct i7core_pvt *pvt = mci->pvt_info;
-	char *cmd, *val;
-	long value;
-	int rc;
-
-	if (pvt->inject.enable)
-		disable_inject(mci);
-
-	do {
-		cmd = strsep((char **) &data, ":");
-		if (!cmd)
-			break;
-		val = strsep((char **) &data, " \n\t");
-		if (!val)
-			return cmd - data;
-
-		if (!strcasecmp(val, "any"))
-			value = -1;
-		else {
-			rc = strict_strtol(val, 10, &value);
-			if ((rc < 0) || (value < 0))
-				return cmd - data;
-		}
-
-		if (!strcasecmp(cmd, "channel")) {
-			if (value < 3)
-				pvt->inject.channel = value;
-			else
-				return cmd - data;
-		} else if (!strcasecmp(cmd, "dimm")) {
-			if (value < 3)
-				pvt->inject.dimm = value;
-			else
-				return cmd - data;
-		} else if (!strcasecmp(cmd, "rank")) {
-			if (value < 4)
-				pvt->inject.rank = value;
-			else
-				return cmd - data;
-		} else if (!strcasecmp(cmd, "bank")) {
-			if (value < 32)
-				pvt->inject.bank = value;
-			else
-				return cmd - data;
-		} else if (!strcasecmp(cmd, "page")) {
-			if (value <= 0xffff)
-				pvt->inject.page = value;
-			else
-				return cmd - data;
-		} else if (!strcasecmp(cmd, "col") ||
-			   !strcasecmp(cmd, "column")) {
-			if (value <= 0x3fff)
-				pvt->inject.col = value;
-			else
-				return cmd - data;
-		}
-	} while (1);
 
-	return count;
+#define DECLARE_ADDR_MATCH(param, limit)			\
+static ssize_t i7core_inject_store_##param(			\
+		struct mem_ctl_info *mci,			\
+		const char *data, size_t count)			\
+{								\
+	struct i7core_pvt *pvt = mci->pvt_info;			\
+	long value;						\
+	int rc;							\
+								\
+	if (pvt->inject.enable)					\
+		disable_inject(mci);				\
+								\
+	if (!strcasecmp(data, "any"))				\
+		value = -1;					\
+	else {							\
+		rc = strict_strtoul(data, 10, &value);		\
+		if ((rc < 0) || (value >= limit))		\
+			return -EIO;				\
+	}							\
+								\
+	pvt->inject.param = value;				\
+								\
+	return count;						\
+}								\
+								\
+static ssize_t i7core_inject_show_##param(			\
+		struct mem_ctl_info *mci,			\
+		char *data)					\
+{								\
+	struct i7core_pvt *pvt = mci->pvt_info;			\
+	if (pvt->inject.param < 0)				\
+		return sprintf(data, "any\n");			\
+	else							\
+		return sprintf(data, "%d\n", pvt->inject.param);\
 }
 
-static ssize_t i7core_inject_addrmatch_show(struct mem_ctl_info *mci,
-					      char *data)
-{
-	struct i7core_pvt *pvt = mci->pvt_info;
-	char channel[4], dimm[4], bank[4], rank[4], page[7], col[7];
-
-	if (pvt->inject.channel < 0)
-		sprintf(channel, "any");
-	else
-		sprintf(channel, "%d", pvt->inject.channel);
-	if (pvt->inject.dimm < 0)
-		sprintf(dimm, "any");
-	else
-		sprintf(dimm, "%d", pvt->inject.dimm);
-	if (pvt->inject.bank < 0)
-		sprintf(bank, "any");
-	else
-		sprintf(bank, "%d", pvt->inject.bank);
-	if (pvt->inject.rank < 0)
-		sprintf(rank, "any");
-	else
-		sprintf(rank, "%d", pvt->inject.rank);
-	if (pvt->inject.page < 0)
-		sprintf(page, "any");
-	else
-		sprintf(page, "0x%04x", pvt->inject.page);
-	if (pvt->inject.col < 0)
-		sprintf(col, "any");
-	else
-		sprintf(col, "0x%04x", pvt->inject.col);
+#define ATTR_ADDR_MATCH(param)					\
+	{							\
+		.attr = {					\
+			.name = #param,				\
+			.mode = (S_IRUGO | S_IWUSR)		\
+		},						\
+		.show  = i7core_inject_show_##param,		\
+		.store = i7core_inject_store_##param,		\
+	}
 
-	return sprintf(data, "channel: %s\ndimm: %s\nbank: %s\n"
-			     "rank: %s\npage: %s\ncolumn: %s\n",
-		       channel, dimm, bank, rank, page, col);
-}
+DECLARE_ADDR_MATCH(channel, 3);
+DECLARE_ADDR_MATCH(dimm, 3);
+DECLARE_ADDR_MATCH(rank, 4);
+DECLARE_ADDR_MATCH(bank, 32);
+DECLARE_ADDR_MATCH(page, 0x10000);
+DECLARE_ADDR_MATCH(col, 0x4000);
 
 static int write_and_test(struct pci_dev *dev, int where, u32 val)
 {
@@ -1079,7 +1033,25 @@ static ssize_t i7core_ce_regs_show(struct mem_ctl_info *mci, char *data)
 /*
  * Sysfs struct
  */
-static struct mcidev_sysfs_attribute i7core_inj_attrs[] = {
+
+
+static struct mcidev_sysfs_attribute i7core_addrmatch_attrs[] = {
+	ATTR_ADDR_MATCH(channel),
+	ATTR_ADDR_MATCH(dimm),
+	ATTR_ADDR_MATCH(rank),
+	ATTR_ADDR_MATCH(bank),
+	ATTR_ADDR_MATCH(page),
+	ATTR_ADDR_MATCH(col),
+	{ .attr = { .name = NULL } }
+};
+
+
+static struct mcidev_sysfs_group i7core_inject_addrmatch = {
+	.name  = "inject_addrmatch",
+	.mcidev_attr = i7core_addrmatch_attrs,
+};
+
+static struct mcidev_sysfs_attribute i7core_sysfs_attrs[] = {
 	{
 		.attr = {
 			.name = "inject_section",
@@ -1102,12 +1074,7 @@ static struct mcidev_sysfs_attribute i7core_inj_attrs[] = {
 		.show  = i7core_inject_eccmask_show,
 		.store = i7core_inject_eccmask_store,
 	}, {
-		.attr = {
-			.name = "inject_addrmatch",
-			.mode = (S_IRUGO | S_IWUSR)
-		},
-		.show  = i7core_inject_addrmatch_show,
-		.store = i7core_inject_addrmatch_store,
+		.grp = &i7core_inject_addrmatch,
 	}, {
 		.attr = {
 			.name = "inject_enable",
@@ -1750,7 +1717,7 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 				  i7core_dev->socket);
 	mci->dev_name = pci_name(i7core_dev->pdev[0]);
 	mci->ctl_page_to_phys = NULL;
-	mci->mc_driver_sysfs_attributes = i7core_inj_attrs;
+	mci->mc_driver_sysfs_attributes = i7core_sysfs_attrs;
 	/* Set the function pointer to an actual operation function */
 	mci->edac_check = i7core_check_error;
 

commit 4af91889e02c9933823ca8c62fc6f05dfd15f3bd
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Sep 24 09:58:26 2009 -0300

    i7core_edac: Avoid printing a warning when debug is disabled
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 2e4b0abf9d43..0478cc85e920 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -471,7 +471,6 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow)
 	struct csrow_info *csr;
 	struct pci_dev *pdev;
 	int i, j;
-	u8 socket = pvt->i7core_dev->socket;
 	unsigned long last_page = 0;
 	enum edac_type mode;
 	enum mem_type mtype;
@@ -488,7 +487,7 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow)
 	pci_read_config_dword(pdev, MC_CHANNEL_MAPPER, &pvt->info.ch_map);
 
 	debugf0("QPI %d control=0x%08x status=0x%08x dod=0x%08x map=0x%08x\n",
-		socket, pvt->info.mc_control, pvt->info.mc_status,
+		pvt->i7core_dev->socket, pvt->info.mc_control, pvt->info.mc_status,
 		pvt->info.max_dod, pvt->info.ch_map);
 
 	if (ECC_ENABLED(pvt)) {

commit 4253868034221db6e42dbbb61e0305fe1757f8da
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Sep 24 09:59:13 2009 -0300

    i7core_edac: We need to use list_for_each_entry_safe to avoid errors
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index c3fec5de3e51..2e4b0abf9d43 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1124,6 +1124,7 @@ static struct mcidev_sysfs_attribute i7core_inj_attrs[] = {
 		.show  = i7core_ce_regs_show,
 		.store = NULL,
 	},
+	{ .attr = { .name = NULL } }
 };
 
 /****************************************************************************
@@ -1155,9 +1156,9 @@ static void i7core_put_devices(struct i7core_dev *i7core_dev)
 
 static void i7core_put_all_devices(void)
 {
-	struct i7core_dev *i7core_dev;
+	struct i7core_dev *i7core_dev, *tmp;
 
-	list_for_each_entry(i7core_dev, &i7core_edac_list, list)
+	list_for_each_entry_safe(i7core_dev, tmp, &i7core_edac_list, list)
 		i7core_put_devices(i7core_dev);
 }
 

commit 22e6bcbdcf9279321dbe646c5a234b816db12881
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Sep 5 23:06:50 2009 -0300

    i7core_edac: change remove module strategy
    
    The old remove module stragegy didn't work on devices with multiple
    cores, since only one PCI device is used to open all mc's, due to
    Nehalem nature.
    
    Also, it were based at pdev value. However, this doesn't point to the
    pci device used at mci->dev.
    
    So, instead, it unregisters all devices at once, deleting them from the
    device list.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 391348bf93d2..c3fec5de3e51 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1138,11 +1138,18 @@ static void i7core_put_devices(struct i7core_dev *i7core_dev)
 {
 	int i;
 
-	for (i = 0; i < N_DEVS; i++)
-		pci_dev_put(i7core_dev->pdev[i]);
-
-	list_del(&i7core_dev->list);
+	debugf0(__FILE__ ": %s()\n", __func__);
+	for (i = 0; i < N_DEVS; i++) {
+		struct pci_dev *pdev = i7core_dev->pdev[i];
+		if (!pdev)
+			continue;
+		debugf0("Removing dev %02x:%02x.%d\n",
+			pdev->bus->number,
+			PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
+		pci_dev_put(pdev);
+	}
 	kfree(i7core_dev->pdev);
+	list_del(&i7core_dev->list);
 	kfree(i7core_dev);
 }
 
@@ -1863,31 +1870,39 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 static void __devexit i7core_remove(struct pci_dev *pdev)
 {
 	struct mem_ctl_info *mci;
-	struct i7core_pvt *pvt;
-	struct i7core_dev *i7core_dev;
+	struct i7core_dev *i7core_dev, *tmp;
 
 	debugf0(__FILE__ ": %s()\n", __func__);
 
 	if (i7core_pci)
 		edac_pci_release_generic_ctl(i7core_pci);
 
+	/*
+	 * we have a trouble here: pdev value for removal will be wrong, since
+	 * it will point to the X58 register used to detect that the machine
+	 * is a Nehalem or upper design. However, due to the way several PCI
+	 * devices are grouped together to provide MC functionality, we need
+	 * to use a different method for releasing the devices
+	 */
 
-	mci = edac_mc_del_mc(&pdev->dev);
-	if (!mci)
-		return;
-
-	/* Unregisters on edac_mce in order to receive memory errors */
-	pvt = mci->pvt_info;
-	i7core_dev = pvt->i7core_dev;
-	edac_mce_unregister(&pvt->edac_mce);
-
-	/* retrieve references to resources, and free those resources */
 	mutex_lock(&i7core_edac_lock);
-	i7core_put_devices(i7core_dev);
+	list_for_each_entry_safe(i7core_dev, tmp, &i7core_edac_list, list) {
+		mci = edac_mc_del_mc(&i7core_dev->pdev[0]->dev);
+		if (mci) {
+			struct i7core_pvt *pvt = mci->pvt_info;
+
+			i7core_dev = pvt->i7core_dev;
+			edac_mce_unregister(&pvt->edac_mce);
+			kfree(mci->ctl_name);
+			edac_mc_free(mci);
+			i7core_put_devices(i7core_dev);
+		} else {
+			i7core_printk(KERN_ERR,
+				      "Couldn't find mci for socket %d\n",
+				      i7core_dev->socket);
+		}
+	}
 	mutex_unlock(&i7core_edac_lock);
-
-	kfree(mci->ctl_name);
-	edac_mc_free(mci);
 }
 
 MODULE_DEVICE_TABLE(pci, i7core_pci_tbl);

commit 0f062792b48dc8389fb18cbfb9318625886644c7
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Sep 5 12:16:19 2009 -0300

    i7core_edac: remove static counter for max sockets
    
    The number of sockets is now fully dynamic. Get rid of this obsolete
    var.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index c2266f820b0f..391348bf93d2 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -247,7 +247,6 @@ struct i7core_pvt {
 /* Static vars */
 static LIST_HEAD(i7core_edac_list);
 static DEFINE_MUTEX(i7core_edac_lock);
-static u8 max_num_sockets;
 
 #define PCI_DESCR(device, function, device_id)	\
 	.dev = (device),			\

commit 13d6e9b653e6f714024c67287c7d7eac54d8417b
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Sep 5 12:15:20 2009 -0300

    i7core_edac: at remove, don't remove all pci devices at once
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 821e8a1a09cf..c2266f820b0f 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1135,22 +1135,24 @@ static struct mcidev_sysfs_attribute i7core_inj_attrs[] = {
  *	i7core_put_devices	'put' all the devices that we have
  *				reserved via 'get'
  */
-static void i7core_put_devices(void)
+static void i7core_put_devices(struct i7core_dev *i7core_dev)
 {
-	int i, j;
+	int i;
 
-	for (i = 0; i < max_num_sockets; i++) {
-		struct i7core_dev *i7core_dev = get_i7core_dev(i);
-		if (!i7core_dev)
-			continue;
+	for (i = 0; i < N_DEVS; i++)
+		pci_dev_put(i7core_dev->pdev[i]);
 
-		for (j = 0; j < N_DEVS; j++)
-			pci_dev_put(i7core_dev->pdev[j]);
+	list_del(&i7core_dev->list);
+	kfree(i7core_dev->pdev);
+	kfree(i7core_dev);
+}
 
-		list_del(&i7core_dev->list);
-		kfree(i7core_dev->pdev);
-		kfree(i7core_dev);
-	}
+static void i7core_put_all_devices(void)
+{
+	struct i7core_dev *i7core_dev;
+
+	list_for_each_entry(i7core_dev, &i7core_edac_list, list)
+		i7core_put_devices(i7core_dev);
 }
 
 static void i7core_xeon_pci_fixup(void)
@@ -1292,7 +1294,7 @@ static int i7core_get_devices(void)
 		pdev = NULL;
 		do {
 			if (i7core_get_onedevice(&pdev, i) < 0) {
-				i7core_put_devices();
+				i7core_put_all_devices();
 				return -ENODEV;
 			}
 		} while (pdev);
@@ -1849,7 +1851,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	return 0;
 
 fail1:
-	i7core_put_devices();
+	i7core_put_all_devices();
 fail0:
 	mutex_unlock(&i7core_edac_lock);
 	return rc;
@@ -1863,6 +1865,7 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 {
 	struct mem_ctl_info *mci;
 	struct i7core_pvt *pvt;
+	struct i7core_dev *i7core_dev;
 
 	debugf0(__FILE__ ": %s()\n", __func__);
 
@@ -1876,13 +1879,12 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 
 	/* Unregisters on edac_mce in order to receive memory errors */
 	pvt = mci->pvt_info;
+	i7core_dev = pvt->i7core_dev;
 	edac_mce_unregister(&pvt->edac_mce);
 
 	/* retrieve references to resources, and free those resources */
 	mutex_lock(&i7core_edac_lock);
-
-	/* FIXME: This should put the devices only for this mci!!! */
-	i7core_put_devices();
+	i7core_put_devices(i7core_dev);
 	mutex_unlock(&i7core_edac_lock);
 
 	kfree(mci->ctl_name);

commit d88b85072fa7d406f54c30ceeabcd37e5a2ec21a
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Sep 5 05:10:31 2009 -0300

    i7core_edac: Fix a bug when printing error counts with RDIMMs
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 2c30493eae0f..821e8a1a09cf 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1054,13 +1054,15 @@ static ssize_t i7core_ce_regs_show(struct mem_ctl_info *mci, char *data)
 		count = sprintf(data, "data unavailable\n");
 		return 0;
 	}
-	if (!pvt->is_registered)
+	if (!pvt->is_registered) {
 		count = sprintf(data, "all channels "
 				"UDIMM0: %lu UDIMM1: %lu UDIMM2: %lu\n",
 				pvt->udimm_ce_count[0],
 				pvt->udimm_ce_count[1],
 				pvt->udimm_ce_count[2]);
-	else
+		data  += count;
+		total += count;
+	} else {
 		for (i = 0; i < NUM_CHANS; i++) {
 			count = sprintf(data, "channel %d RDIMM0: %lu "
 					"RDIMM1: %lu RDIMM2: %lu\n",
@@ -1068,9 +1070,10 @@ static ssize_t i7core_ce_regs_show(struct mem_ctl_info *mci, char *data)
 					pvt->rdimm_ce_count[i][0],
 					pvt->rdimm_ce_count[i][1],
 					pvt->rdimm_ce_count[i][2]);
-				}
-	data  += count;
-	total += count;
+			data  += count;
+			total += count;
+		}
+	}
 
 	return total;
 }

commit d4c277957f4e8e6f2b626e2661cbbf9c76782e36
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Sep 5 04:12:02 2009 -0300

    i7core_edac: a few fixes for multiple mc's
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 335d9ed02c45..2c30493eae0f 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1270,11 +1270,10 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno)
 		return -ENODEV;
 	}
 
-	i7core_printk(KERN_INFO,
-			"Registered socket %d "
-			"dev %02x:%02x.%d PCI ID %04x:%04x\n",
-			socket, bus, pci_dev_descr[devno].dev, pci_dev_descr[devno].func,
-			PCI_VENDOR_ID_INTEL, pci_dev_descr[devno].dev_id);
+	debugf0("Detected socket %d dev %02x:%02x.%d PCI ID %04x:%04x\n",
+		socket, bus, pci_dev_descr[devno].dev,
+		pci_dev_descr[devno].func,
+		PCI_VENDOR_ID_INTEL, pci_dev_descr[devno].dev_id);
 
 	*prev = pdev;
 
@@ -1713,7 +1712,8 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 	int rc;
 
 	/* allocate a new MC control structure */
-	mci = edac_mc_alloc(sizeof(*pvt), num_csrows, num_channels, 0);
+	mci = edac_mc_alloc(sizeof(*pvt), num_csrows, num_channels,
+			    i7core_dev->socket);
 	if (unlikely(!mci))
 		return -ENOMEM;
 
@@ -1724,7 +1724,6 @@ static int i7core_register_mci(struct i7core_dev *i7core_dev,
 
 	pvt = mci->pvt_info;
 	memset(pvt, 0, sizeof(*pvt));
-	mci->mc_idx = 0;
 
 	/*
 	 * FIXME: how to handle RDDR3 at MCI level? It is possible to have
@@ -1815,7 +1814,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	struct i7core_dev *i7core_dev;
 
 	/*
-	 * FIXME: All memory controllers are allocated at the first pass.
+	 * All memory controllers are allocated at the first pass.
 	 */
 	if (unlikely(dev_idx >= 1))
 		return -EINVAL;
@@ -1836,7 +1835,9 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 		if (unlikely(rc < 0))
 			goto fail1;
 
-		i7core_register_mci(i7core_dev, channels, csrows);
+		rc = i7core_register_mci(i7core_dev, channels, csrows);
+		if (unlikely(rc < 0))
+			goto fail1;
 	}
 
 	i7core_printk(KERN_INFO, "Driver loaded.\n");
@@ -1876,6 +1877,8 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 
 	/* retrieve references to resources, and free those resources */
 	mutex_lock(&i7core_edac_lock);
+
+	/* FIXME: This should put the devices only for this mci!!! */
 	i7core_put_devices();
 	mutex_unlock(&i7core_edac_lock);
 

commit 6c6aa3afdba2460cb668d4cb65c74dfa8eb43449
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Sep 5 03:27:04 2009 -0300

    i7core_edac: sanity check: print a warning if a mcelog is ignored
    
    In thesis, the other mc controller should handle it.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 5bc316b8e805..335d9ed02c45 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1681,8 +1681,13 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 		return 0;
 
 	/* Only handle if it is the right mc controller */
-	if (cpu_data(mce->cpu).phys_proc_id != pvt->i7core_dev->socket)
+	if (cpu_data(mce->cpu).phys_proc_id != pvt->i7core_dev->socket) {
+		debugf0("mc%d: ignoring mce log for socket %d. "
+			"Another mc should get it.\n",
+			pvt->i7core_dev->socket,
+			cpu_data(mce->cpu).phys_proc_id);
 		return 0;
+	}
 
 	spin_lock_irqsave(&pvt->mce_lock, flags);
 	if (pvt->mce_count < MCE_LOG_LEN) {

commit f47429494fd50c0b7396fe3f8a26ea638b47c5ba
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Sep 5 02:35:08 2009 -0300

    i7core_edac: create one mc per socket/QPI
    
    Instead of creating just one memory controller, create one per socket
    (e. g. per Quick Link Path Interconnect).
    
    This better reflects the Nehalem architecture.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 7bcb5993b501..5bc316b8e805 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -29,10 +29,20 @@
 #include <linux/mmzone.h>
 #include <linux/edac_mce.h>
 #include <linux/spinlock.h>
+#include <linux/smp.h>
 #include <asm/processor.h>
 
 #include "edac_core.h"
 
+/*
+ * This is used for Nehalem-EP and Nehalem-EX devices, where the non-core
+ * registers start at bus 255, and are not reported by BIOS.
+ * We currently find devices with only 2 sockets. In order to support more QPI
+ * Quick Path Interconnect, just increment this number.
+ */
+#define MAX_SOCKET_BUSES	2
+
+
 /*
  * Alter this version for the module when modifications are made
  */
@@ -162,7 +172,6 @@
 
 #define NUM_CHANS 3
 #define MAX_DIMMS 3		/* Max DIMMS per channel */
-#define NUM_SOCKETS 2		/* Max number of MC sockets */
 #define MAX_MCR_FUNC  4
 #define MAX_CHAN_FUNC 3
 
@@ -177,7 +186,6 @@ struct i7core_info {
 struct i7core_inject {
 	int	enable;
 
-	u8	socket;
 	u32	section;
 	u32	type;
 	u32	eccmask;
@@ -197,29 +205,37 @@ struct pci_id_descr {
 	int 			dev_id;
 };
 
+struct i7core_dev {
+	struct list_head	list;
+	u8			socket;
+	struct pci_dev		**pdev;
+	struct mem_ctl_info	*mci;
+};
+
 struct i7core_pvt {
-	struct pci_dev	*pci_noncore[NUM_SOCKETS];
-	struct pci_dev	*pci_mcr[NUM_SOCKETS][MAX_MCR_FUNC + 1];
-	struct pci_dev	*pci_ch[NUM_SOCKETS][NUM_CHANS][MAX_CHAN_FUNC + 1];
+	struct pci_dev	*pci_noncore;
+	struct pci_dev	*pci_mcr[MAX_MCR_FUNC + 1];
+	struct pci_dev	*pci_ch[NUM_CHANS][MAX_CHAN_FUNC + 1];
+
+	struct i7core_dev *i7core_dev;
 
 	struct i7core_info	info;
 	struct i7core_inject	inject;
-	struct i7core_channel	channel[NUM_SOCKETS][NUM_CHANS];
+	struct i7core_channel	channel[NUM_CHANS];
 
-	int			sockets; /* Number of sockets */
-	int			channels; /* Number of active channels */
+	int		channels; /* Number of active channels */
 
-	int		ce_count_available[NUM_SOCKETS];
-	int 		csrow_map[NUM_SOCKETS][NUM_CHANS][MAX_DIMMS];
+	int		ce_count_available;
+	int 		csrow_map[NUM_CHANS][MAX_DIMMS];
 
 			/* ECC corrected errors counts per udimm */
-	unsigned long	udimm_ce_count[NUM_SOCKETS][MAX_DIMMS];
-	int		udimm_last_ce_count[NUM_SOCKETS][MAX_DIMMS];
+	unsigned long	udimm_ce_count[MAX_DIMMS];
+	int		udimm_last_ce_count[MAX_DIMMS];
 			/* ECC corrected errors counts per rdimm */
-	unsigned long	rdimm_ce_count[NUM_SOCKETS][NUM_CHANS][MAX_DIMMS];
-	int		rdimm_last_ce_count[NUM_SOCKETS][NUM_CHANS][MAX_DIMMS];
+	unsigned long	rdimm_ce_count[NUM_CHANS][MAX_DIMMS];
+	int		rdimm_last_ce_count[NUM_CHANS][MAX_DIMMS];
 
-	unsigned int	is_registered[NUM_SOCKETS];
+	unsigned int	is_registered;
 
 	/* mcelog glue */
 	struct edac_mce		edac_mce;
@@ -228,22 +244,10 @@ struct i7core_pvt {
 	spinlock_t		mce_lock;
 };
 
-struct i7core_dev {
-	struct list_head           list;
-
-	int socket;
-	struct pci_dev **pdev;
-};
-
 /* Static vars */
 static LIST_HEAD(i7core_edac_list);
 static DEFINE_MUTEX(i7core_edac_lock);
-
-/* Device name and register DID (Device ID) */
-struct i7core_dev_info {
-	const char *ctl_name;	/* name for this device */
-	u16 fsb_mapping_errors;	/* DID for the branchmap,control */
-};
+static u8 max_num_sockets;
 
 #define PCI_DESCR(device, function, device_id)	\
 	.dev = (device),			\
@@ -295,15 +299,6 @@ static const struct pci_device_id i7core_pci_tbl[] __devinitdata = {
 	{0,}			/* 0 terminated list. */
 };
 
-
-/* Table of devices attributes supported by this driver */
-static const struct i7core_dev_info i7core_probe_devs[] = {
-	{
-		.ctl_name = "i7 Core",
-		.fsb_mapping_errors = PCI_DEVICE_ID_INTEL_I7_MCR,
-	},
-};
-
 static struct edac_pci_ctl_info *i7core_pci;
 
 /****************************************************************************
@@ -356,7 +351,7 @@ static inline int numcol(u32 col)
 	return cols[col & 0x3];
 }
 
-static struct i7core_dev *get_i7core_dev(int socket)
+static struct i7core_dev *get_i7core_dev(u8 socket)
 {
 	struct i7core_dev *i7core_dev;
 
@@ -471,18 +466,19 @@ static int i7core_get_active_channels(u8 socket, unsigned *channels,
 	return 0;
 }
 
-static int get_dimm_config(struct mem_ctl_info *mci, int *csrow, u8 socket)
+static int get_dimm_config(struct mem_ctl_info *mci, int *csrow)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	struct csrow_info *csr;
 	struct pci_dev *pdev;
 	int i, j;
+	u8 socket = pvt->i7core_dev->socket;
 	unsigned long last_page = 0;
 	enum edac_type mode;
 	enum mem_type mtype;
 
 	/* Get data from the MC register, function 0 */
-	pdev = pvt->pci_mcr[socket][0];
+	pdev = pvt->pci_mcr[0];
 	if (!pdev)
 		return -ENODEV;
 
@@ -529,10 +525,10 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow, u8 socket)
 		}
 
 		/* Devices 4-6 function 0 */
-		pci_read_config_dword(pvt->pci_ch[socket][i][0],
+		pci_read_config_dword(pvt->pci_ch[i][0],
 				MC_CHANNEL_DIMM_INIT_PARAMS, &data);
 
-		pvt->channel[socket][i].ranks = (data & QUAD_RANK_PRESENT) ?
+		pvt->channel[i].ranks = (data & QUAD_RANK_PRESENT) ?
 						4 : 2;
 
 		if (data & REGISTERED_DIMM)
@@ -549,11 +545,11 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow, u8 socket)
 #endif
 
 		/* Devices 4-6 function 1 */
-		pci_read_config_dword(pvt->pci_ch[socket][i][1],
+		pci_read_config_dword(pvt->pci_ch[i][1],
 				MC_DOD_CH_DIMM0, &dimm_dod[0]);
-		pci_read_config_dword(pvt->pci_ch[socket][i][1],
+		pci_read_config_dword(pvt->pci_ch[i][1],
 				MC_DOD_CH_DIMM1, &dimm_dod[1]);
-		pci_read_config_dword(pvt->pci_ch[socket][i][1],
+		pci_read_config_dword(pvt->pci_ch[i][1],
 				MC_DOD_CH_DIMM2, &dimm_dod[2]);
 
 		debugf0("Ch%d phy rd%d, wr%d (0x%08x): "
@@ -561,7 +557,7 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow, u8 socket)
 			i,
 			RDLCH(pvt->info.ch_map, i), WRLCH(pvt->info.ch_map, i),
 			data,
-			pvt->channel[socket][i].ranks,
+			pvt->channel[i].ranks,
 			(data & REGISTERED_DIMM) ? 'R' : 'U');
 
 		for (j = 0; j < 3; j++) {
@@ -579,7 +575,7 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow, u8 socket)
 			/* DDR3 has 8 I/O banks */
 			size = (rows * cols * banks * ranks) >> (20 - 3);
 
-			pvt->channel[socket][i].dimms++;
+			pvt->channel[i].dimms++;
 
 			debugf0("\tdimm %d %d Mb offset: %x, "
 				"bank: %d, rank: %d, row: %#x, col: %#x\n",
@@ -607,7 +603,7 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow, u8 socket)
 			csr->channels[0].chan_idx = i;
 			csr->channels[0].ce_count = 0;
 
-			pvt->csrow_map[socket][i][j] = *csrow;
+			pvt->csrow_map[i][j] = *csrow;
 
 			switch (banks) {
 			case 4:
@@ -665,42 +661,15 @@ static int disable_inject(struct mem_ctl_info *mci)
 
 	pvt->inject.enable = 0;
 
-	if (!pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0])
+	if (!pvt->pci_ch[pvt->inject.channel][0])
 		return -ENODEV;
 
-	pci_write_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
+	pci_write_config_dword(pvt->pci_ch[pvt->inject.channel][0],
 				MC_CHANNEL_ERROR_INJECT, 0);
 
 	return 0;
 }
 
-/*
- * i7core inject inject.socket
- *
- *	accept and store error injection inject.socket value
- */
-static ssize_t i7core_inject_socket_store(struct mem_ctl_info *mci,
-					   const char *data, size_t count)
-{
-	struct i7core_pvt *pvt = mci->pvt_info;
-	unsigned long value;
-	int rc;
-
-	rc = strict_strtoul(data, 10, &value);
-	if ((rc < 0) || (value >= pvt->sockets))
-		return -EIO;
-
-	pvt->inject.socket = (u32) value;
-	return count;
-}
-
-static ssize_t i7core_inject_socket_show(struct mem_ctl_info *mci,
-					      char *data)
-{
-	struct i7core_pvt *pvt = mci->pvt_info;
-	return sprintf(data, "%d\n", pvt->inject.socket);
-}
-
 /*
  * i7core inject inject.section
  *
@@ -965,7 +934,7 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 	int  rc;
 	long enable;
 
-	if (!pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0])
+	if (!pvt->pci_ch[pvt->inject.channel][0])
 		return 0;
 
 	rc = strict_strtoul(data, 10, &enable);
@@ -983,7 +952,7 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 	if (pvt->inject.dimm < 0)
 		mask |= 1L << 41;
 	else {
-		if (pvt->channel[pvt->inject.socket][pvt->inject.channel].dimms > 2)
+		if (pvt->channel[pvt->inject.channel].dimms > 2)
 			mask |= (pvt->inject.dimm & 0x3L) << 35;
 		else
 			mask |= (pvt->inject.dimm & 0x1L) << 36;
@@ -993,7 +962,7 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 	if (pvt->inject.rank < 0)
 		mask |= 1L << 40;
 	else {
-		if (pvt->channel[pvt->inject.socket][pvt->inject.channel].dimms > 2)
+		if (pvt->channel[pvt->inject.channel].dimms > 2)
 			mask |= (pvt->inject.rank & 0x1L) << 34;
 		else
 			mask |= (pvt->inject.rank & 0x3L) << 34;
@@ -1029,18 +998,18 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 		     (pvt->inject.type & 0x6) << (3 - 1);
 
 	/* Unlock writes to registers - this register is write only */
-	pci_write_config_dword(pvt->pci_noncore[pvt->inject.socket],
+	pci_write_config_dword(pvt->pci_noncore,
 			       MC_CFG_CONTROL, 0x2);
 
-	write_and_test(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
+	write_and_test(pvt->pci_ch[pvt->inject.channel][0],
 			       MC_CHANNEL_ADDR_MATCH, mask);
-	write_and_test(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
+	write_and_test(pvt->pci_ch[pvt->inject.channel][0],
 			       MC_CHANNEL_ADDR_MATCH + 4, mask >> 32L);
 
-	write_and_test(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
+	write_and_test(pvt->pci_ch[pvt->inject.channel][0],
 			       MC_CHANNEL_ERROR_MASK, pvt->inject.eccmask);
 
-	write_and_test(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
+	write_and_test(pvt->pci_ch[pvt->inject.channel][0],
 			       MC_CHANNEL_ERROR_INJECT, injectmask);
 
 	/*
@@ -1048,7 +1017,7 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 	 * Without writing 8 to this register, errors aren't injected. Not sure
 	 * why.
 	 */
-	pci_write_config_dword(pvt->pci_noncore[pvt->inject.socket],
+	pci_write_config_dword(pvt->pci_noncore,
 			       MC_CFG_CONTROL, 8);
 
 	debugf0("Error inject addr match 0x%016llx, ecc 0x%08x,"
@@ -1065,7 +1034,7 @@ static ssize_t i7core_inject_enable_show(struct mem_ctl_info *mci,
 	struct i7core_pvt *pvt = mci->pvt_info;
 	u32 injectmask;
 
-	pci_read_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
+	pci_read_config_dword(pvt->pci_ch[pvt->inject.channel][0],
 			       MC_CHANNEL_ERROR_INJECT, &injectmask);
 
 	debugf0("Inject error read: 0x%018x\n", injectmask);
@@ -1078,34 +1047,30 @@ static ssize_t i7core_inject_enable_show(struct mem_ctl_info *mci,
 
 static ssize_t i7core_ce_regs_show(struct mem_ctl_info *mci, char *data)
 {
-	unsigned i, j, count, total = 0;
+	unsigned i, count, total = 0;
 	struct i7core_pvt *pvt = mci->pvt_info;
 
-	for (i = 0; i < pvt->sockets; i++) {
-		if (!pvt->ce_count_available[i]) {
-			count = sprintf(data, "socket 0 data unavailable\n");
-			continue;
-		}
-		if (!pvt->is_registered[i])
-			count = sprintf(data, "socket %d, dimm0: %lu\n"
-					      "dimm1: %lu\ndimm2: %lu\n",
-					i,
-					pvt->udimm_ce_count[i][0],
-					pvt->udimm_ce_count[i][1],
-					pvt->udimm_ce_count[i][2]);
-		else
-			for (j = 0; j < NUM_CHANS; j++) {
-				count = sprintf(data, "socket %d, channel %d "
-						"RDIMM0: %lu "
-						"RDIMM1: %lu RDIMM2: %lu\n",
-						i, j,
-						pvt->rdimm_ce_count[i][j][0],
-						pvt->rdimm_ce_count[i][j][1],
-						pvt->rdimm_ce_count[i][j][2]);
-					}
-		data  += count;
-		total += count;
+	if (!pvt->ce_count_available) {
+		count = sprintf(data, "data unavailable\n");
+		return 0;
 	}
+	if (!pvt->is_registered)
+		count = sprintf(data, "all channels "
+				"UDIMM0: %lu UDIMM1: %lu UDIMM2: %lu\n",
+				pvt->udimm_ce_count[0],
+				pvt->udimm_ce_count[1],
+				pvt->udimm_ce_count[2]);
+	else
+		for (i = 0; i < NUM_CHANS; i++) {
+			count = sprintf(data, "channel %d RDIMM0: %lu "
+					"RDIMM1: %lu RDIMM2: %lu\n",
+					i,
+					pvt->rdimm_ce_count[i][0],
+					pvt->rdimm_ce_count[i][1],
+					pvt->rdimm_ce_count[i][2]);
+				}
+	data  += count;
+	total += count;
 
 	return total;
 }
@@ -1115,13 +1080,6 @@ static ssize_t i7core_ce_regs_show(struct mem_ctl_info *mci, char *data)
  */
 static struct mcidev_sysfs_attribute i7core_inj_attrs[] = {
 	{
-		.attr = {
-			.name = "inject_socket",
-			.mode = (S_IRUGO | S_IWUSR)
-		},
-		.show  = i7core_inject_socket_show,
-		.store = i7core_inject_socket_store,
-	}, {
 		.attr = {
 			.name = "inject_section",
 			.mode = (S_IRUGO | S_IWUSR)
@@ -1178,7 +1136,7 @@ static void i7core_put_devices(void)
 {
 	int i, j;
 
-	for (i = 0; i < NUM_SOCKETS; i++) {
+	for (i = 0; i < max_num_sockets; i++) {
 		struct i7core_dev *i7core_dev = get_i7core_dev(i);
 		if (!i7core_dev)
 			continue;
@@ -1204,7 +1162,7 @@ static void i7core_xeon_pci_fixup(void)
 	pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 			      pci_dev_descr[0].dev_id, NULL);
 	if (unlikely(!pdev)) {
-		for (i = 0; i < NUM_SOCKETS; i ++)
+		for (i = 0; i < MAX_SOCKET_BUSES; i++)
 			pcibios_scan_specific_bus(255-i);
 	}
 }
@@ -1323,13 +1281,11 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno)
 	return 0;
 }
 
-static int i7core_get_devices(u8 *sockets)
+static int i7core_get_devices(void)
 {
 	int i;
 	struct pci_dev *pdev = NULL;
-	struct i7core_dev *i7core_dev = NULL;
 
-	*sockets = 0;
 	for (i = 0; i < N_DEVS; i++) {
 		pdev = NULL;
 		do {
@@ -1340,55 +1296,48 @@ static int i7core_get_devices(u8 *sockets)
 		} while (pdev);
 	}
 
-	list_for_each_entry(i7core_dev, &i7core_edac_list, list) {
-		if (i7core_dev->socket + 1 > *sockets)
-			*sockets = i7core_dev->socket + 1;
-	}
-
 	return 0;
 }
 
-static int mci_bind_devs(struct mem_ctl_info *mci)
+static int mci_bind_devs(struct mem_ctl_info *mci,
+			 struct i7core_dev *i7core_dev)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	struct pci_dev *pdev;
-	int i, j, func, slot;
+	int i, func, slot;
 
-	for (i = 0; i < pvt->sockets; i++) {
-		struct i7core_dev *i7core_dev = get_i7core_dev(i);
+	/* Associates i7core_dev and mci for future usage */
+	pvt->i7core_dev = i7core_dev;
+	i7core_dev->mci = mci;
 
-		if (!i7core_dev)
+	pvt->is_registered = 0;
+	for (i = 0; i < N_DEVS; i++) {
+		pdev = i7core_dev->pdev[i];
+		if (!pdev)
 			continue;
 
-		pvt->is_registered[i] = 0;
-		for (j = 0; j < N_DEVS; j++) {
-			pdev = i7core_dev->pdev[j];
-			if (!pdev)
-				continue;
-
-			func = PCI_FUNC(pdev->devfn);
-			slot = PCI_SLOT(pdev->devfn);
-			if (slot == 3) {
-				if (unlikely(func > MAX_MCR_FUNC))
-					goto error;
-				pvt->pci_mcr[i][func] = pdev;
-			} else if (likely(slot >= 4 && slot < 4 + NUM_CHANS)) {
-				if (unlikely(func > MAX_CHAN_FUNC))
-					goto error;
-				pvt->pci_ch[i][slot - 4][func] = pdev;
-			} else if (!slot && !func)
-				pvt->pci_noncore[i] = pdev;
-			else
+		func = PCI_FUNC(pdev->devfn);
+		slot = PCI_SLOT(pdev->devfn);
+		if (slot == 3) {
+			if (unlikely(func > MAX_MCR_FUNC))
+				goto error;
+			pvt->pci_mcr[func] = pdev;
+		} else if (likely(slot >= 4 && slot < 4 + NUM_CHANS)) {
+			if (unlikely(func > MAX_CHAN_FUNC))
 				goto error;
+			pvt->pci_ch[slot - 4][func] = pdev;
+		} else if (!slot && !func)
+			pvt->pci_noncore = pdev;
+		else
+			goto error;
 
-			debugf0("Associated fn %d.%d, dev = %p, socket %d\n",
-				PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),
-				pdev, i);
+		debugf0("Associated fn %d.%d, dev = %p, socket %d\n",
+			PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),
+			pdev, i7core_dev->socket);
 
-			if (PCI_SLOT(pdev->devfn) == 3 &&
-			   PCI_FUNC(pdev->devfn) == 2)
-				pvt->is_registered[i] = 1;
-		}
+		if (PCI_SLOT(pdev->devfn) == 3 &&
+			PCI_FUNC(pdev->devfn) == 2)
+			pvt->is_registered = 1;
 	}
 
 	return 0;
@@ -1403,17 +1352,17 @@ static int mci_bind_devs(struct mem_ctl_info *mci)
 /****************************************************************************
 			Error check routines
  ****************************************************************************/
-static void i7core_rdimm_update_csrow(struct mem_ctl_info *mci, int socket,
+static void i7core_rdimm_update_csrow(struct mem_ctl_info *mci,
 					 int chan, int dimm, int add)
 {
 	char *msg;
 	struct i7core_pvt *pvt = mci->pvt_info;
-	int row = pvt->csrow_map[socket][chan][dimm], i;
+	int row = pvt->csrow_map[chan][dimm], i;
 
 	for (i = 0; i < add; i++) {
 		msg = kasprintf(GFP_KERNEL, "Corrected error "
-				"(Socket=%d channel=%d dimm=%d",
-				socket, chan, dimm);
+				"(Socket=%d channel=%d dimm=%d)",
+				pvt->i7core_dev->socket, chan, dimm);
 
 		edac_mc_handle_fbd_ce(mci, row, 0, msg);
 		kfree (msg);
@@ -1421,71 +1370,71 @@ static void i7core_rdimm_update_csrow(struct mem_ctl_info *mci, int socket,
 }
 
 static void i7core_rdimm_update_ce_count(struct mem_ctl_info *mci,
-			int socket, int chan, int new0, int new1, int new2)
+			int chan, int new0, int new1, int new2)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	int add0 = 0, add1 = 0, add2 = 0;
 	/* Updates CE counters if it is not the first time here */
-	if (pvt->ce_count_available[socket]) {
+	if (pvt->ce_count_available) {
 		/* Updates CE counters */
 
-		add2 = new2 - pvt->rdimm_last_ce_count[socket][chan][2];
-		add1 = new1 - pvt->rdimm_last_ce_count[socket][chan][1];
-		add0 = new0 - pvt->rdimm_last_ce_count[socket][chan][0];
+		add2 = new2 - pvt->rdimm_last_ce_count[chan][2];
+		add1 = new1 - pvt->rdimm_last_ce_count[chan][1];
+		add0 = new0 - pvt->rdimm_last_ce_count[chan][0];
 
 		if (add2 < 0)
 			add2 += 0x7fff;
-		pvt->rdimm_ce_count[socket][chan][2] += add2;
+		pvt->rdimm_ce_count[chan][2] += add2;
 
 		if (add1 < 0)
 			add1 += 0x7fff;
-		pvt->rdimm_ce_count[socket][chan][1] += add1;
+		pvt->rdimm_ce_count[chan][1] += add1;
 
 		if (add0 < 0)
 			add0 += 0x7fff;
-		pvt->rdimm_ce_count[socket][chan][0] += add0;
+		pvt->rdimm_ce_count[chan][0] += add0;
 	} else
-		pvt->ce_count_available[socket] = 1;
+		pvt->ce_count_available = 1;
 
 	/* Store the new values */
-	pvt->rdimm_last_ce_count[socket][chan][2] = new2;
-	pvt->rdimm_last_ce_count[socket][chan][1] = new1;
-	pvt->rdimm_last_ce_count[socket][chan][0] = new0;
+	pvt->rdimm_last_ce_count[chan][2] = new2;
+	pvt->rdimm_last_ce_count[chan][1] = new1;
+	pvt->rdimm_last_ce_count[chan][0] = new0;
 
 	/*updated the edac core */
 	if (add0 != 0)
-		i7core_rdimm_update_csrow(mci, socket, chan, 0, add0);
+		i7core_rdimm_update_csrow(mci, chan, 0, add0);
 	if (add1 != 0)
-		i7core_rdimm_update_csrow(mci, socket, chan, 1, add1);
+		i7core_rdimm_update_csrow(mci, chan, 1, add1);
 	if (add2 != 0)
-		i7core_rdimm_update_csrow(mci, socket, chan, 2, add2);
+		i7core_rdimm_update_csrow(mci, chan, 2, add2);
 
 }
 
-static void i7core_rdimm_check_mc_ecc_err(struct mem_ctl_info *mci, u8 socket)
+static void i7core_rdimm_check_mc_ecc_err(struct mem_ctl_info *mci)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	u32 rcv[3][2];
 	int i, new0, new1, new2;
 
 	/*Read DEV 3: FUN 2:  MC_COR_ECC_CNT regs directly*/
-	pci_read_config_dword(pvt->pci_mcr[socket][2], MC_COR_ECC_CNT_0,
+	pci_read_config_dword(pvt->pci_mcr[2], MC_COR_ECC_CNT_0,
 								&rcv[0][0]);
-	pci_read_config_dword(pvt->pci_mcr[socket][2], MC_COR_ECC_CNT_1,
+	pci_read_config_dword(pvt->pci_mcr[2], MC_COR_ECC_CNT_1,
 								&rcv[0][1]);
-	pci_read_config_dword(pvt->pci_mcr[socket][2], MC_COR_ECC_CNT_2,
+	pci_read_config_dword(pvt->pci_mcr[2], MC_COR_ECC_CNT_2,
 								&rcv[1][0]);
-	pci_read_config_dword(pvt->pci_mcr[socket][2], MC_COR_ECC_CNT_3,
+	pci_read_config_dword(pvt->pci_mcr[2], MC_COR_ECC_CNT_3,
 								&rcv[1][1]);
-	pci_read_config_dword(pvt->pci_mcr[socket][2], MC_COR_ECC_CNT_4,
+	pci_read_config_dword(pvt->pci_mcr[2], MC_COR_ECC_CNT_4,
 								&rcv[2][0]);
-	pci_read_config_dword(pvt->pci_mcr[socket][2], MC_COR_ECC_CNT_5,
+	pci_read_config_dword(pvt->pci_mcr[2], MC_COR_ECC_CNT_5,
 								&rcv[2][1]);
 	for (i = 0 ; i < 3; i++) {
 		debugf3("MC_COR_ECC_CNT%d = 0x%x; MC_COR_ECC_CNT%d = 0x%x\n",
 			(i * 2), rcv[i][0], (i * 2) + 1, rcv[i][1]);
 		/*if the channel has 3 dimms*/
-		if (pvt->channel[socket][i].dimms > 2) {
+		if (pvt->channel[i].dimms > 2) {
 			new0 = DIMM_BOT_COR_ERR(rcv[i][0]);
 			new1 = DIMM_TOP_COR_ERR(rcv[i][0]);
 			new2 = DIMM_BOT_COR_ERR(rcv[i][1]);
@@ -1497,7 +1446,7 @@ static void i7core_rdimm_check_mc_ecc_err(struct mem_ctl_info *mci, u8 socket)
 			new2 = 0;
 		}
 
-		i7core_rdimm_update_ce_count(mci, socket, i, new0, new1, new2);
+		i7core_rdimm_update_ce_count(mci, i, new0, new1, new2);
 	}
 }
 
@@ -1507,20 +1456,20 @@ static void i7core_rdimm_check_mc_ecc_err(struct mem_ctl_info *mci, u8 socket)
  * also available at:
  * 	http://www.arrownac.com/manufacturers/intel/s/nehalem/5500-datasheet-v2.pdf
  */
-static void i7core_udimm_check_mc_ecc_err(struct mem_ctl_info *mci, u8 socket)
+static void i7core_udimm_check_mc_ecc_err(struct mem_ctl_info *mci)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	u32 rcv1, rcv0;
 	int new0, new1, new2;
 
-	if (!pvt->pci_mcr[socket][4]) {
+	if (!pvt->pci_mcr[4]) {
 		debugf0("%s MCR registers not found\n", __func__);
 		return;
 	}
 
 	/* Corrected test errors */
-	pci_read_config_dword(pvt->pci_mcr[socket][4], MC_TEST_ERR_RCV1, &rcv1);
-	pci_read_config_dword(pvt->pci_mcr[socket][4], MC_TEST_ERR_RCV0, &rcv0);
+	pci_read_config_dword(pvt->pci_mcr[4], MC_TEST_ERR_RCV1, &rcv1);
+	pci_read_config_dword(pvt->pci_mcr[4], MC_TEST_ERR_RCV0, &rcv0);
 
 	/* Store the new values */
 	new2 = DIMM2_COR_ERR(rcv1);
@@ -1528,37 +1477,37 @@ static void i7core_udimm_check_mc_ecc_err(struct mem_ctl_info *mci, u8 socket)
 	new0 = DIMM0_COR_ERR(rcv0);
 
 	/* Updates CE counters if it is not the first time here */
-	if (pvt->ce_count_available[socket]) {
+	if (pvt->ce_count_available) {
 		/* Updates CE counters */
 		int add0, add1, add2;
 
-		add2 = new2 - pvt->udimm_last_ce_count[socket][2];
-		add1 = new1 - pvt->udimm_last_ce_count[socket][1];
-		add0 = new0 - pvt->udimm_last_ce_count[socket][0];
+		add2 = new2 - pvt->udimm_last_ce_count[2];
+		add1 = new1 - pvt->udimm_last_ce_count[1];
+		add0 = new0 - pvt->udimm_last_ce_count[0];
 
 		if (add2 < 0)
 			add2 += 0x7fff;
-		pvt->udimm_ce_count[socket][2] += add2;
+		pvt->udimm_ce_count[2] += add2;
 
 		if (add1 < 0)
 			add1 += 0x7fff;
-		pvt->udimm_ce_count[socket][1] += add1;
+		pvt->udimm_ce_count[1] += add1;
 
 		if (add0 < 0)
 			add0 += 0x7fff;
-		pvt->udimm_ce_count[socket][0] += add0;
+		pvt->udimm_ce_count[0] += add0;
 
 		if (add0 | add1 | add2)
 			i7core_printk(KERN_ERR, "New Corrected error(s): "
 				      "dimm0: +%d, dimm1: +%d, dimm2 +%d\n",
 				      add0, add1, add2);
 	} else
-		pvt->ce_count_available[socket] = 1;
+		pvt->ce_count_available = 1;
 
 	/* Store the new values */
-	pvt->udimm_last_ce_count[socket][2] = new2;
-	pvt->udimm_last_ce_count[socket][1] = new1;
-	pvt->udimm_last_ce_count[socket][0] = new0;
+	pvt->udimm_last_ce_count[2] = new2;
+	pvt->udimm_last_ce_count[1] = new1;
+	pvt->udimm_last_ce_count[0] = new0;
 }
 
 /*
@@ -1587,13 +1536,6 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 	u32 syndrome = m->misc >> 32;
 	u32 errnum = find_first_bit(&error, 32);
 	int csrow;
-/* FIXME */
-//#ifdef CONFIG_SMP
-#if 0
-	u32 socket_id = per_cpu(cpu_data, cpu).phys_proc_id;
-#else
-	u32 socket_id = 0;
-#endif
 
 	if (m->mcgstatus & 1)
 		type = "FATAL";
@@ -1655,24 +1597,21 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 
 	/* FIXME: should convert addr into bank and rank information */
 	msg = kasprintf(GFP_ATOMIC,
-		"%s (addr = 0x%08llx, socket=%d, Dimm=%d, Channel=%d, "
+		"%s (addr = 0x%08llx, cpu=%d, Dimm=%d, Channel=%d, "
 		"syndrome=0x%08x, count=%d, Err=%08llx:%08llx (%s: %s))\n",
-		type, (long long) m->addr, socket_id, dimm, channel,
+		type, (long long) m->addr, m->cpu, dimm, channel,
 		syndrome, core_err_cnt, (long long)m->status,
 		(long long)m->misc, optype, err);
 
 	debugf0("%s", msg);
 
-	if (socket_id < NUM_SOCKETS)
-		csrow = pvt->csrow_map[socket_id][channel][dimm];
-	else
-		csrow = -1;
+	csrow = pvt->csrow_map[channel][dimm];
 
 	/* Call the helper to output message */
 	if (m->mcgstatus & 1)
 		edac_mc_handle_fbd_ue(mci, csrow, 0,
 				0 /* FIXME: should be channel here */, msg);
-	else if (!pvt->is_registered[socket_id])
+	else if (!pvt->is_registered)
 		edac_mc_handle_fbd_ce(mci, csrow,
 				0 /* FIXME: should be channel here */, msg);
 
@@ -1695,12 +1634,14 @@ static void i7core_check_error(struct mem_ctl_info *mci)
 	spin_lock_irqsave(&pvt->mce_lock, flags);
 	if (pvt->mce_count) {
 		m = kmalloc(sizeof(*m) * pvt->mce_count, GFP_ATOMIC);
+
 		if (m) {
 			count = pvt->mce_count;
 			memcpy(m, &pvt->mce_entry, sizeof(*m) * count);
 		}
 		pvt->mce_count = 0;
 	}
+
 	spin_unlock_irqrestore(&pvt->mce_lock, flags);
 
 	/* proccess mcelog errors */
@@ -1710,11 +1651,10 @@ static void i7core_check_error(struct mem_ctl_info *mci)
 	kfree(m);
 
 	/* check memory count errors */
-	for (i = 0; i < pvt->sockets; i++)
-		if (!pvt->is_registered[i])
-			i7core_udimm_check_mc_ecc_err(mci, i);
-		else
-			i7core_rdimm_check_mc_ecc_err(mci, i);
+	if (!pvt->is_registered)
+		i7core_udimm_check_mc_ecc_err(mci);
+	else
+		i7core_rdimm_check_mc_ecc_err(mci);
 }
 
 /*
@@ -1740,6 +1680,10 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 	if (mce->bank != 8)
 		return 0;
 
+	/* Only handle if it is the right mc controller */
+	if (cpu_data(mce->cpu).phys_proc_id != pvt->i7core_dev->socket)
+		return 0;
+
 	spin_lock_irqsave(&pvt->mce_lock, flags);
 	if (pvt->mce_count < MCE_LOG_LEN) {
 		memcpy(&pvt->mce_entry[pvt->mce_count], mce, sizeof(*mce));
@@ -1755,63 +1699,26 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 	return 1;
 }
 
-/*
- *	i7core_probe	Probe for ONE instance of device to see if it is
- *			present.
- *	return:
- *		0 for FOUND a device
- *		< 0 for error code
- */
-static int __devinit i7core_probe(struct pci_dev *pdev,
-				  const struct pci_device_id *id)
+static int i7core_register_mci(struct i7core_dev *i7core_dev,
+			       int num_channels, int num_csrows)
 {
 	struct mem_ctl_info *mci;
 	struct i7core_pvt *pvt;
-	int num_channels = 0;
-	int num_csrows = 0;
 	int csrow = 0;
-	int dev_idx = id->driver_data;
-	int rc, i;
-	u8 sockets;
-
-	/*
-	 * FIXME: All memory controllers are allocated at the first pass.
-	 */
-	if (unlikely(dev_idx >= 1))
-		return -EINVAL;
-
-	/* get the pci devices we want to reserve for our use */
-	mutex_lock(&i7core_edac_lock);
-	rc = i7core_get_devices(&sockets);
-	if (unlikely(rc < 0))
-		goto fail0;
-
-	for (i = 0; i < sockets; i++) {
-		int channels;
-		int csrows;
-
-		/* Check the number of active and not disabled channels */
-		rc = i7core_get_active_channels(i, &channels, &csrows);
-		if (unlikely(rc < 0))
-			goto fail1;
-
-		num_channels += channels;
-		num_csrows += csrows;
-	}
+	int rc;
 
 	/* allocate a new MC control structure */
 	mci = edac_mc_alloc(sizeof(*pvt), num_csrows, num_channels, 0);
-	if (unlikely(!mci)) {
-		rc = -ENOMEM;
-		goto fail1;
-	}
+	if (unlikely(!mci))
+		return -ENOMEM;
 
 	debugf0("MC: " __FILE__ ": %s(): mci = %p\n", __func__, mci);
 
-	mci->dev = &pdev->dev;	/* record ptr to the generic device */
+	/* record ptr to the generic device */
+	mci->dev = &i7core_dev->pdev[0]->dev;
+
 	pvt = mci->pvt_info;
 	memset(pvt, 0, sizeof(*pvt));
-	pvt->sockets = sockets;
 	mci->mc_idx = 0;
 
 	/*
@@ -1824,21 +1731,21 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	mci->edac_cap = EDAC_FLAG_NONE;
 	mci->mod_name = "i7core_edac.c";
 	mci->mod_ver = I7CORE_REVISION;
-	mci->ctl_name = i7core_probe_devs[dev_idx].ctl_name;
-	mci->dev_name = pci_name(pdev);
+	mci->ctl_name = kasprintf(GFP_KERNEL, "i7 core #%d",
+				  i7core_dev->socket);
+	mci->dev_name = pci_name(i7core_dev->pdev[0]);
 	mci->ctl_page_to_phys = NULL;
 	mci->mc_driver_sysfs_attributes = i7core_inj_attrs;
 	/* Set the function pointer to an actual operation function */
 	mci->edac_check = i7core_check_error;
 
 	/* Store pci devices at mci for faster access */
-	rc = mci_bind_devs(mci);
+	rc = mci_bind_devs(mci, i7core_dev);
 	if (unlikely(rc < 0))
-		goto fail2;
+		goto fail;
 
 	/* Get dimm basic config */
-	for (i = 0; i < sockets; i++)
-		get_dimm_config(mci, &csrow, i);
+	get_dimm_config(mci, &csrow);
 
 	/* add this new MC control structure to EDAC's list of MCs */
 	if (unlikely(edac_mc_add_mc(mci))) {
@@ -1849,11 +1756,12 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 		 */
 
 		rc = -EINVAL;
-		goto fail2;
+		goto fail;
 	}
 
 	/* allocating generic PCI control info */
-	i7core_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);
+	i7core_pci = edac_pci_create_generic_ctl(&i7core_dev->pdev[0]->dev,
+						 EDAC_MOD_STR);
 	if (unlikely(!i7core_pci)) {
 		printk(KERN_WARNING
 			"%s(): Unable to create PCI control\n",
@@ -1880,7 +1788,50 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	if (unlikely(rc < 0)) {
 		debugf0("MC: " __FILE__
 			": %s(): failed edac_mce_register()\n", __func__);
-		goto fail2;
+	}
+
+fail:
+	edac_mc_free(mci);
+	return rc;
+}
+
+/*
+ *	i7core_probe	Probe for ONE instance of device to see if it is
+ *			present.
+ *	return:
+ *		0 for FOUND a device
+ *		< 0 for error code
+ */
+static int __devinit i7core_probe(struct pci_dev *pdev,
+				  const struct pci_device_id *id)
+{
+	int dev_idx = id->driver_data;
+	int rc;
+	struct i7core_dev *i7core_dev;
+
+	/*
+	 * FIXME: All memory controllers are allocated at the first pass.
+	 */
+	if (unlikely(dev_idx >= 1))
+		return -EINVAL;
+
+	/* get the pci devices we want to reserve for our use */
+	mutex_lock(&i7core_edac_lock);
+	rc = i7core_get_devices();
+	if (unlikely(rc < 0))
+		goto fail0;
+
+	list_for_each_entry(i7core_dev, &i7core_edac_list, list) {
+		int channels;
+		int csrows;
+
+		/* Check the number of active and not disabled channels */
+		rc = i7core_get_active_channels(i7core_dev->socket,
+						&channels, &csrows);
+		if (unlikely(rc < 0))
+			goto fail1;
+
+		i7core_register_mci(i7core_dev, channels, csrows);
 	}
 
 	i7core_printk(KERN_INFO, "Driver loaded.\n");
@@ -1888,9 +1839,6 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	mutex_unlock(&i7core_edac_lock);
 	return 0;
 
-fail2:
-	edac_mc_free(mci);
-
 fail1:
 	i7core_put_devices();
 fail0:
@@ -1926,6 +1874,7 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 	i7core_put_devices();
 	mutex_unlock(&i7core_edac_lock);
 
+	kfree(mci->ctl_name);
 	edac_mc_free(mci);
 }
 

commit 66607706cee7b6901aa0509198f075859c93ec6a
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Sep 5 00:52:11 2009 -0300

    Dynamically allocate memory for PCI devices
    
    Instead of using a static table assuming always 2 CPU sockets, allocate
    space dynamically for Nehalem PCI devs.
    
    This patch is part of a series of patches that changes i7core_edac to
    allow more than 2 sockets and to properly report one memory controller
    per socket.

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index af222ffcfdfc..7bcb5993b501 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -192,10 +192,9 @@ struct i7core_channel {
 };
 
 struct pci_id_descr {
-	int		dev;
-	int		func;
-	int 		dev_id;
-	struct pci_dev	*pdev[NUM_SOCKETS];
+	int			dev;
+	int			func;
+	int 			dev_id;
 };
 
 struct i7core_pvt {
@@ -229,6 +228,17 @@ struct i7core_pvt {
 	spinlock_t		mce_lock;
 };
 
+struct i7core_dev {
+	struct list_head           list;
+
+	int socket;
+	struct pci_dev **pdev;
+};
+
+/* Static vars */
+static LIST_HEAD(i7core_edac_list);
+static DEFINE_MUTEX(i7core_edac_lock);
+
 /* Device name and register DID (Device ID) */
 struct i7core_dev_info {
 	const char *ctl_name;	/* name for this device */
@@ -240,7 +250,7 @@ struct i7core_dev_info {
 	.func = (function),			\
 	.dev_id = (device_id)
 
-struct pci_id_descr pci_devs[] = {
+struct pci_id_descr pci_dev_descr[] = {
 		/* Memory controller */
 	{ PCI_DESCR(3, 0, PCI_DEVICE_ID_INTEL_I7_MCR)     },
 	{ PCI_DESCR(3, 1, PCI_DEVICE_ID_INTEL_I7_MC_TAD)  },
@@ -275,11 +285,10 @@ struct pci_id_descr pci_devs[] = {
 	{ PCI_DESCR(0, 0, PCI_DEVICE_ID_INTEL_I7_NOCORE)  },
 
 };
-#define N_DEVS ARRAY_SIZE(pci_devs)
+#define N_DEVS ARRAY_SIZE(pci_dev_descr)
 
 /*
  *	pci_device_id	table for which devices we are looking for
- * This should match the first device at pci_devs table
  */
 static const struct pci_device_id i7core_pci_tbl[] __devinitdata = {
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_X58_HUB_MGMT)},
@@ -288,7 +297,7 @@ static const struct pci_device_id i7core_pci_tbl[] __devinitdata = {
 
 
 /* Table of devices attributes supported by this driver */
-static const struct i7core_dev_info i7core_devs[] = {
+static const struct i7core_dev_info i7core_probe_devs[] = {
 	{
 		.ctl_name = "i7 Core",
 		.fsb_mapping_errors = PCI_DEVICE_ID_INTEL_I7_MCR,
@@ -347,21 +356,37 @@ static inline int numcol(u32 col)
 	return cols[col & 0x3];
 }
 
+static struct i7core_dev *get_i7core_dev(int socket)
+{
+	struct i7core_dev *i7core_dev;
+
+	list_for_each_entry(i7core_dev, &i7core_edac_list, list) {
+		if (i7core_dev->socket == socket)
+			return i7core_dev;
+	}
+
+	return NULL;
+}
+
 /****************************************************************************
 			Memory check routines
  ****************************************************************************/
 static struct pci_dev *get_pdev_slot_func(u8 socket, unsigned slot,
 					  unsigned func)
 {
+	struct i7core_dev *i7core_dev = get_i7core_dev(socket);
 	int i;
 
+	if (!i7core_dev)
+		return NULL;
+
 	for (i = 0; i < N_DEVS; i++) {
-		if (!pci_devs[i].pdev[socket])
+		if (!i7core_dev->pdev[i])
 			continue;
 
-		if (PCI_SLOT(pci_devs[i].pdev[socket]->devfn) == slot &&
-		    PCI_FUNC(pci_devs[i].pdev[socket]->devfn) == func) {
-			return pci_devs[i].pdev[socket];
+		if (PCI_SLOT(i7core_dev->pdev[i]->devfn) == slot &&
+		    PCI_FUNC(i7core_dev->pdev[i]->devfn) == func) {
+			return i7core_dev->pdev[i];
 		}
 	}
 
@@ -1153,9 +1178,18 @@ static void i7core_put_devices(void)
 {
 	int i, j;
 
-	for (i = 0; i < NUM_SOCKETS; i++)
+	for (i = 0; i < NUM_SOCKETS; i++) {
+		struct i7core_dev *i7core_dev = get_i7core_dev(i);
+		if (!i7core_dev)
+			continue;
+
 		for (j = 0; j < N_DEVS; j++)
-			pci_dev_put(pci_devs[j].pdev[i]);
+			pci_dev_put(i7core_dev->pdev[j]);
+
+		list_del(&i7core_dev->list);
+		kfree(i7core_dev->pdev);
+		kfree(i7core_dev);
+	}
 }
 
 static void i7core_xeon_pci_fixup(void)
@@ -1168,7 +1202,7 @@ static void i7core_xeon_pci_fixup(void)
 	 * to detect them
 	 */
 	pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
-			      pci_devs[0].dev_id, NULL);
+			      pci_dev_descr[0].dev_id, NULL);
 	if (unlikely(!pdev)) {
 		for (i = 0; i < NUM_SOCKETS; i ++)
 			pcibios_scan_specific_bus(255-i);
@@ -1183,19 +1217,21 @@ static void i7core_xeon_pci_fixup(void)
  */
 int i7core_get_onedevice(struct pci_dev **prev, int devno)
 {
+	struct i7core_dev *i7core_dev;
+
 	struct pci_dev *pdev = NULL;
 	u8 bus = 0;
 	u8 socket = 0;
 
 	pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
-			      pci_devs[devno].dev_id, *prev);
+			      pci_dev_descr[devno].dev_id, *prev);
 
 	/*
 	 * On Xeon 55xx, the Intel Quckpath Arch Generic Non-core regs
 	 * is at addr 8086:2c40, instead of 8086:2c41. So, we need
 	 * to probe for the alternate address in case of failure
 	 */
-	if (pci_devs[devno].dev_id == PCI_DEVICE_ID_INTEL_I7_NOCORE && !pdev)
+	if (pci_dev_descr[devno].dev_id == PCI_DEVICE_ID_INTEL_I7_NOCORE && !pdev)
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 				      PCI_DEVICE_ID_INTEL_I7_NOCORE_ALT, *prev);
 
@@ -1209,15 +1245,15 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno)
 		 * Dev 3 function 2 only exists on chips with RDIMMs
 		 * so, it is ok to not found it
 		 */
-		if ((pci_devs[devno].dev == 3) && (pci_devs[devno].func == 2)) {
+		if ((pci_dev_descr[devno].dev == 3) && (pci_dev_descr[devno].func == 2)) {
 			*prev = pdev;
 			return 0;
 		}
 
 		i7core_printk(KERN_ERR,
 			"Device not found: dev %02x.%d PCI ID %04x:%04x\n",
-			pci_devs[devno].dev, pci_devs[devno].func,
-			PCI_VENDOR_ID_INTEL, pci_devs[devno].dev_id);
+			pci_dev_descr[devno].dev, pci_dev_descr[devno].func,
+			PCI_VENDOR_ID_INTEL, pci_dev_descr[devno].dev_id);
 
 		/* End of list, leave */
 		return -ENODEV;
@@ -1229,37 +1265,40 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno)
 	else
 		socket = 255 - bus;
 
-	if (socket >= NUM_SOCKETS) {
-		i7core_printk(KERN_ERR,
-			"Unexpected socket for "
-			"dev %02x:%02x.%d PCI ID %04x:%04x\n",
-			bus, pci_devs[devno].dev, pci_devs[devno].func,
-			PCI_VENDOR_ID_INTEL, pci_devs[devno].dev_id);
-		pci_dev_put(pdev);
-		return -ENODEV;
+	i7core_dev = get_i7core_dev(socket);
+	if (!i7core_dev) {
+		i7core_dev = kzalloc(sizeof(*i7core_dev), GFP_KERNEL);
+		if (!i7core_dev)
+			return -ENOMEM;
+		i7core_dev->pdev = kzalloc(sizeof(*i7core_dev->pdev) * N_DEVS,
+					   GFP_KERNEL);
+		if (!i7core_dev->pdev)
+			return -ENOMEM;
+		i7core_dev->socket = socket;
+		list_add_tail(&i7core_dev->list, &i7core_edac_list);
 	}
 
-	if (pci_devs[devno].pdev[socket]) {
+	if (i7core_dev->pdev[devno]) {
 		i7core_printk(KERN_ERR,
 			"Duplicated device for "
 			"dev %02x:%02x.%d PCI ID %04x:%04x\n",
-			bus, pci_devs[devno].dev, pci_devs[devno].func,
-			PCI_VENDOR_ID_INTEL, pci_devs[devno].dev_id);
+			bus, pci_dev_descr[devno].dev, pci_dev_descr[devno].func,
+			PCI_VENDOR_ID_INTEL, pci_dev_descr[devno].dev_id);
 		pci_dev_put(pdev);
 		return -ENODEV;
 	}
 
-	pci_devs[devno].pdev[socket] = pdev;
+	i7core_dev->pdev[devno] = pdev;
 
 	/* Sanity check */
-	if (unlikely(PCI_SLOT(pdev->devfn) != pci_devs[devno].dev ||
-			PCI_FUNC(pdev->devfn) != pci_devs[devno].func)) {
+	if (unlikely(PCI_SLOT(pdev->devfn) != pci_dev_descr[devno].dev ||
+			PCI_FUNC(pdev->devfn) != pci_dev_descr[devno].func)) {
 		i7core_printk(KERN_ERR,
 			"Device PCI ID %04x:%04x "
 			"has dev %02x:%02x.%d instead of dev %02x:%02x.%d\n",
-			PCI_VENDOR_ID_INTEL, pci_devs[devno].dev_id,
+			PCI_VENDOR_ID_INTEL, pci_dev_descr[devno].dev_id,
 			bus, PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),
-			bus, pci_devs[devno].dev, pci_devs[devno].func);
+			bus, pci_dev_descr[devno].dev, pci_dev_descr[devno].func);
 		return -ENODEV;
 	}
 
@@ -1268,27 +1307,29 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno)
 		i7core_printk(KERN_ERR,
 			"Couldn't enable "
 			"dev %02x:%02x.%d PCI ID %04x:%04x\n",
-			bus, pci_devs[devno].dev, pci_devs[devno].func,
-			PCI_VENDOR_ID_INTEL, pci_devs[devno].dev_id);
+			bus, pci_dev_descr[devno].dev, pci_dev_descr[devno].func,
+			PCI_VENDOR_ID_INTEL, pci_dev_descr[devno].dev_id);
 		return -ENODEV;
 	}
 
 	i7core_printk(KERN_INFO,
 			"Registered socket %d "
 			"dev %02x:%02x.%d PCI ID %04x:%04x\n",
-			socket, bus, pci_devs[devno].dev, pci_devs[devno].func,
-			PCI_VENDOR_ID_INTEL, pci_devs[devno].dev_id);
+			socket, bus, pci_dev_descr[devno].dev, pci_dev_descr[devno].func,
+			PCI_VENDOR_ID_INTEL, pci_dev_descr[devno].dev_id);
 
 	*prev = pdev;
 
 	return 0;
 }
 
-static int i7core_get_devices(void)
+static int i7core_get_devices(u8 *sockets)
 {
 	int i;
 	struct pci_dev *pdev = NULL;
+	struct i7core_dev *i7core_dev = NULL;
 
+	*sockets = 0;
 	for (i = 0; i < N_DEVS; i++) {
 		pdev = NULL;
 		do {
@@ -1298,6 +1339,12 @@ static int i7core_get_devices(void)
 			}
 		} while (pdev);
 	}
+
+	list_for_each_entry(i7core_dev, &i7core_edac_list, list) {
+		if (i7core_dev->socket + 1 > *sockets)
+			*sockets = i7core_dev->socket + 1;
+	}
+
 	return 0;
 }
 
@@ -1307,11 +1354,15 @@ static int mci_bind_devs(struct mem_ctl_info *mci)
 	struct pci_dev *pdev;
 	int i, j, func, slot;
 
-
 	for (i = 0; i < pvt->sockets; i++) {
+		struct i7core_dev *i7core_dev = get_i7core_dev(i);
+
+		if (!i7core_dev)
+			continue;
+
 		pvt->is_registered[i] = 0;
 		for (j = 0; j < N_DEVS; j++) {
-			pdev = pci_devs[j].pdev[i];
+			pdev = i7core_dev->pdev[j];
 			if (!pdev)
 				continue;
 
@@ -1723,20 +1774,17 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	int rc, i;
 	u8 sockets;
 
-	if (unlikely(dev_idx >= ARRAY_SIZE(i7core_devs)))
+	/*
+	 * FIXME: All memory controllers are allocated at the first pass.
+	 */
+	if (unlikely(dev_idx >= 1))
 		return -EINVAL;
 
 	/* get the pci devices we want to reserve for our use */
-	rc = i7core_get_devices();
+	mutex_lock(&i7core_edac_lock);
+	rc = i7core_get_devices(&sockets);
 	if (unlikely(rc < 0))
-		return rc;
-
-	sockets = 1;
-	for (i = NUM_SOCKETS - 1; i > 0; i--)
-		if (pci_devs[0].pdev[i]) {
-			sockets = i + 1;
-			break;
-		}
+		goto fail0;
 
 	for (i = 0; i < sockets; i++) {
 		int channels;
@@ -1745,7 +1793,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 		/* Check the number of active and not disabled channels */
 		rc = i7core_get_active_channels(i, &channels, &csrows);
 		if (unlikely(rc < 0))
-			goto fail0;
+			goto fail1;
 
 		num_channels += channels;
 		num_csrows += csrows;
@@ -1755,7 +1803,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	mci = edac_mc_alloc(sizeof(*pvt), num_csrows, num_channels, 0);
 	if (unlikely(!mci)) {
 		rc = -ENOMEM;
-		goto fail0;
+		goto fail1;
 	}
 
 	debugf0("MC: " __FILE__ ": %s(): mci = %p\n", __func__, mci);
@@ -1776,7 +1824,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	mci->edac_cap = EDAC_FLAG_NONE;
 	mci->mod_name = "i7core_edac.c";
 	mci->mod_ver = I7CORE_REVISION;
-	mci->ctl_name = i7core_devs[dev_idx].ctl_name;
+	mci->ctl_name = i7core_probe_devs[dev_idx].ctl_name;
 	mci->dev_name = pci_name(pdev);
 	mci->ctl_page_to_phys = NULL;
 	mci->mc_driver_sysfs_attributes = i7core_inj_attrs;
@@ -1786,7 +1834,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	/* Store pci devices at mci for faster access */
 	rc = mci_bind_devs(mci);
 	if (unlikely(rc < 0))
-		goto fail1;
+		goto fail2;
 
 	/* Get dimm basic config */
 	for (i = 0; i < sockets; i++)
@@ -1801,7 +1849,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 		 */
 
 		rc = -EINVAL;
-		goto fail1;
+		goto fail2;
 	}
 
 	/* allocating generic PCI control info */
@@ -1832,18 +1880,21 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	if (unlikely(rc < 0)) {
 		debugf0("MC: " __FILE__
 			": %s(): failed edac_mce_register()\n", __func__);
-		goto fail1;
+		goto fail2;
 	}
 
 	i7core_printk(KERN_INFO, "Driver loaded.\n");
 
+	mutex_unlock(&i7core_edac_lock);
 	return 0;
 
-fail1:
+fail2:
 	edac_mc_free(mci);
 
-fail0:
+fail1:
 	i7core_put_devices();
+fail0:
+	mutex_unlock(&i7core_edac_lock);
 	return rc;
 }
 
@@ -1871,7 +1922,9 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 	edac_mce_unregister(&pvt->edac_mce);
 
 	/* retrieve references to resources, and free those resources */
+	mutex_lock(&i7core_edac_lock);
 	i7core_put_devices();
+	mutex_unlock(&i7core_edac_lock);
 
 	edac_mc_free(mci);
 }

commit a55456f3446d19853af54b64b3840312f46b6ea5
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Sep 5 00:47:21 2009 -0300

    i7core: temporary workaround to allow it to compile against 2.6.30
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 76f4e6d973af..af222ffcfdfc 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1536,8 +1536,10 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 	u32 syndrome = m->misc >> 32;
 	u32 errnum = find_first_bit(&error, 32);
 	int csrow;
-#ifdef CONFIG_SMP
-	u32 socket_id = cpu_data[m->cpu].phys_proc_id;
+/* FIXME */
+//#ifdef CONFIG_SMP
+#if 0
+	u32 socket_id = per_cpu(cpu_data, cpu).phys_proc_id;
 #else
 	u32 socket_id = 0;
 #endif

commit 3a3bb4a647db4cb2468641df8da2ee9491784a9a
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Sep 3 20:17:26 2009 -0300

    i7core_edac: Improve corrected_error_counts output for RDIMM
    
    Just cosmetics. instead of showing something like:
    
    socket 0, channel 2dimm0: 1
    dimm1: 0
    dimm2: 0
    socket 1, channel 2dimm0: 0
    dimm1: 0
    dimm2: 0
    
    Show:
    
    socket 0, channel 2 RDIMM0: 1 RDIMM1: 0 RDIMM2: 0
    socket 0, channel 2 RDIMM0: 0 RDIMM1: 0 RDIMM2: 0
    
    This is more synthetic and easier to parse.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 9fe7ec762e68..76f4e6d973af 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1070,9 +1070,9 @@ static ssize_t i7core_ce_regs_show(struct mem_ctl_info *mci, char *data)
 					pvt->udimm_ce_count[i][2]);
 		else
 			for (j = 0; j < NUM_CHANS; j++) {
-				count = sprintf(data, "socket %d, channel %d"
-						"dimm0: %lu\n"
-						"dimm1: %lu\ndimm2: %lu\n",
+				count = sprintf(data, "socket %d, channel %d "
+						"RDIMM0: %lu "
+						"RDIMM1: %lu RDIMM2: %lu\n",
 						i, j,
 						pvt->rdimm_ce_count[i][j][0],
 						pvt->rdimm_ce_count[i][j][1],

commit bc2d7245ff1c5466c877a0c32a7ec9563187a032
Author: Keith Mannthey <kmannth@us.ibm.com>
Date:   Thu Sep 3 00:05:05 2009 -0300

    i7core_edac: Probe on Xeons eariler
    
    On the Xeon 55XX series cpus the pci deives are not exposed via acpi so
    we much explicitly probe them to make the usable as a Linux PCI device.
    
    This moves the detection of this state to before pci_register_driver is
    called.  Its present position was not working on my systems, the driver
    would complain about not finding a specific device.
    
    This patch allows the driver to load on my systems.
    
    Signed-off-by: Keith Mannthey <kmannth@us.ibm.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 9f4e9d7d4dbf..9fe7ec762e68 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1158,6 +1158,23 @@ static void i7core_put_devices(void)
 			pci_dev_put(pci_devs[j].pdev[i]);
 }
 
+static void i7core_xeon_pci_fixup(void)
+{
+	struct pci_dev *pdev = NULL;
+	int i;
+	/*
+	 * On Xeon 55xx, the Intel Quckpath Arch Generic Non-core pci buses
+	 * aren't announced by acpi. So, we need to use a legacy scan probing
+	 * to detect them
+	 */
+	pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
+			      pci_devs[0].dev_id, NULL);
+	if (unlikely(!pdev)) {
+		for (i = 0; i < NUM_SOCKETS; i ++)
+			pcibios_scan_specific_bus(255-i);
+	}
+}
+
 /*
  *	i7core_get_devices	Find and perform 'get' operation on the MCH's
  *			device/functions we want to reference for this driver
@@ -1173,19 +1190,6 @@ int i7core_get_onedevice(struct pci_dev **prev, int devno)
 	pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 			      pci_devs[devno].dev_id, *prev);
 
-	/*
-	 * On Xeon 55xx, the Intel Quckpath Arch Generic Non-core pci buses
-	 * aren't announced by acpi. So, we need to use a legacy scan probing
-	 * to detect them
-	 */
-	if (unlikely(!pdev && !devno && !prev)) {
-		pcibios_scan_specific_bus(254);
-		pcibios_scan_specific_bus(255);
-
-		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
-				      pci_devs[devno].dev_id, *prev);
-	}
-
 	/*
 	 * On Xeon 55xx, the Intel Quckpath Arch Generic Non-core regs
 	 * is at addr 8086:2c40, instead of 8086:2c41. So, we need
@@ -1896,6 +1900,8 @@ static int __init i7core_init(void)
 	/* Ensure that the OPSTATE is set correctly for POLL or NMI */
 	opstate_init();
 
+	i7core_xeon_pci_fixup();
+
 	pci_rc = pci_register_driver(&i7core_driver);
 
 	if (pci_rc >= 0)

commit 14d2c08343eecd13f6c6ec232c98b16762b97924
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Sep 2 23:52:36 2009 -0300

    i7core: Use registered memories per processor
    
    Instead of assuming that the entire machine has either registered or
    unregistered memories, do it at CPU socket based.
    
    While here, fix a bug at i7core_mce_output_error(), where the we're
    using m->cpu directly as if it would represent a socket. Instead, the
    proper socket_id is given by cpu_data[m->cpu].phys_proc_id.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    ---

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 4758c208f39a..9f4e9d7d4dbf 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -29,6 +29,7 @@
 #include <linux/mmzone.h>
 #include <linux/edac_mce.h>
 #include <linux/spinlock.h>
+#include <asm/processor.h>
 
 #include "edac_core.h"
 
@@ -206,8 +207,6 @@ struct i7core_pvt {
 	struct i7core_inject	inject;
 	struct i7core_channel	channel[NUM_SOCKETS][NUM_CHANS];
 
-	unsigned int	is_registered:1; /* true if all memories are RDIMMs */
-
 	int			sockets; /* Number of sockets */
 	int			channels; /* Number of active channels */
 
@@ -221,6 +220,8 @@ struct i7core_pvt {
 	unsigned long	rdimm_ce_count[NUM_SOCKETS][NUM_CHANS][MAX_DIMMS];
 	int		rdimm_last_ce_count[NUM_SOCKETS][NUM_CHANS][MAX_DIMMS];
 
+	unsigned int	is_registered[NUM_SOCKETS];
+
 	/* mcelog glue */
 	struct edac_mce		edac_mce;
 	struct mce		mce_entry[MCE_LOG_LEN];
@@ -490,8 +491,6 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow, u8 socket)
 		numrow(pvt->info.max_dod >> 6),
 		numcol(pvt->info.max_dod >> 9));
 
-	pvt->is_registered = 1;
-
 	for (i = 0; i < NUM_CHANS; i++) {
 		u32 data, dimm_dod[3], value[8];
 
@@ -513,14 +512,8 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow, u8 socket)
 
 		if (data & REGISTERED_DIMM)
 			mtype = MEM_RDDR3;
-		else {
+		else
 			mtype = MEM_DDR3;
-			/*
-			 * FIXME: Currently, the driver will use dev 3:2
-			 * counter registers only if all memories are registered
-			 */
-			pvt->is_registered = 0;
-		}
 #if 0
 		if (data & THREE_DIMMS_PRESENT)
 			pvt->channel[i].dimms = 3;
@@ -1068,7 +1061,7 @@ static ssize_t i7core_ce_regs_show(struct mem_ctl_info *mci, char *data)
 			count = sprintf(data, "socket 0 data unavailable\n");
 			continue;
 		}
-		if (!pvt->is_registered)
+		if (!pvt->is_registered[i])
 			count = sprintf(data, "socket %d, dimm0: %lu\n"
 					      "dimm1: %lu\ndimm2: %lu\n",
 					i,
@@ -1310,7 +1303,9 @@ static int mci_bind_devs(struct mem_ctl_info *mci)
 	struct pci_dev *pdev;
 	int i, j, func, slot;
 
+
 	for (i = 0; i < pvt->sockets; i++) {
+		pvt->is_registered[i] = 0;
 		for (j = 0; j < N_DEVS; j++) {
 			pdev = pci_devs[j].pdev[i];
 			if (!pdev)
@@ -1334,6 +1329,10 @@ static int mci_bind_devs(struct mem_ctl_info *mci)
 			debugf0("Associated fn %d.%d, dev = %p, socket %d\n",
 				PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),
 				pdev, i);
+
+			if (PCI_SLOT(pdev->devfn) == 3 &&
+			   PCI_FUNC(pdev->devfn) == 2)
+				pvt->is_registered[i] = 1;
 		}
 	}
 
@@ -1533,6 +1532,11 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 	u32 syndrome = m->misc >> 32;
 	u32 errnum = find_first_bit(&error, 32);
 	int csrow;
+#ifdef CONFIG_SMP
+	u32 socket_id = cpu_data[m->cpu].phys_proc_id;
+#else
+	u32 socket_id = 0;
+#endif
 
 	if (m->mcgstatus & 1)
 		type = "FATAL";
@@ -1596,19 +1600,22 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 	msg = kasprintf(GFP_ATOMIC,
 		"%s (addr = 0x%08llx, socket=%d, Dimm=%d, Channel=%d, "
 		"syndrome=0x%08x, count=%d, Err=%08llx:%08llx (%s: %s))\n",
-		type, (long long) m->addr, m->cpu, dimm, channel,
+		type, (long long) m->addr, socket_id, dimm, channel,
 		syndrome, core_err_cnt, (long long)m->status,
 		(long long)m->misc, optype, err);
 
 	debugf0("%s", msg);
 
-	csrow = pvt->csrow_map[m->cpu][channel][dimm];
+	if (socket_id < NUM_SOCKETS)
+		csrow = pvt->csrow_map[socket_id][channel][dimm];
+	else
+		csrow = -1;
 
 	/* Call the helper to output message */
 	if (m->mcgstatus & 1)
 		edac_mc_handle_fbd_ue(mci, csrow, 0,
 				0 /* FIXME: should be channel here */, msg);
-	else if (!pvt->is_registered)
+	else if (!pvt->is_registered[socket_id])
 		edac_mc_handle_fbd_ce(mci, csrow,
 				0 /* FIXME: should be channel here */, msg);
 
@@ -1647,7 +1654,7 @@ static void i7core_check_error(struct mem_ctl_info *mci)
 
 	/* check memory count errors */
 	for (i = 0; i < pvt->sockets; i++)
-		if (!pvt->is_registered)
+		if (!pvt->is_registered[i])
 			i7core_udimm_check_mc_ecc_err(mci, i);
 		else
 			i7core_rdimm_check_mc_ecc_err(mci, i);

commit b4e8f0b6eaa1e99f1a64e539466a8ee2fb521d62
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Sep 2 23:49:59 2009 -0300

    i7core_edac: Use Device 3 function 2 to report errors with RDIMM's
    
    Nehalem and upper chipsets provide an special device that has corrected memory
    error counters detected with registered dimms. This device is only seen if
    there are registered memories plugged.
    
    After this patch, on a machine fully equiped with RDIMM's, it will use the
    Device 3 function 2 to count corrected errors instead on relying at mcelog.
    
    For unregistered DIMMs, it will keep the old behavior, counting errors
    via mcelog.
    
    This patch were developed together with Keith Mannthey <kmannth@us.ibm.com>
    
    Signed-off-by: Keith Mannthey <kmannth@us.ibm.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 87d5695f5fb0..4758c208f39a 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -73,6 +73,18 @@
   #define DIMM1_COR_ERR(r)			(((r) >> 16) & 0x7fff)
   #define DIMM0_COR_ERR(r)			((r) & 0x7fff)
 
+/* OFFSETS for Device 3 Function 2, as inicated on Xeon 5500 datasheet */
+#define MC_COR_ECC_CNT_0	0x80
+#define MC_COR_ECC_CNT_1	0x84
+#define MC_COR_ECC_CNT_2	0x88
+#define MC_COR_ECC_CNT_3	0x8c
+#define MC_COR_ECC_CNT_4	0x90
+#define MC_COR_ECC_CNT_5	0x94
+
+#define DIMM_TOP_COR_ERR(r)			(((r) >> 16) & 0x7fff)
+#define DIMM_BOT_COR_ERR(r)			((r) & 0x7fff)
+
+
 	/* OFFSETS for Devices 4,5 and 6 Function 0 */
 
 #define MC_CHANNEL_DIMM_INIT_PARAMS 0x58
@@ -194,13 +206,20 @@ struct i7core_pvt {
 	struct i7core_inject	inject;
 	struct i7core_channel	channel[NUM_SOCKETS][NUM_CHANS];
 
+	unsigned int	is_registered:1; /* true if all memories are RDIMMs */
+
 	int			sockets; /* Number of sockets */
 	int			channels; /* Number of active channels */
 
 	int		ce_count_available[NUM_SOCKETS];
-			/* ECC corrected errors counts per dimm */
-	unsigned long	ce_count[NUM_SOCKETS][MAX_DIMMS];
-	int		last_ce_count[NUM_SOCKETS][MAX_DIMMS];
+	int 		csrow_map[NUM_SOCKETS][NUM_CHANS][MAX_DIMMS];
+
+			/* ECC corrected errors counts per udimm */
+	unsigned long	udimm_ce_count[NUM_SOCKETS][MAX_DIMMS];
+	int		udimm_last_ce_count[NUM_SOCKETS][MAX_DIMMS];
+			/* ECC corrected errors counts per rdimm */
+	unsigned long	rdimm_ce_count[NUM_SOCKETS][NUM_CHANS][MAX_DIMMS];
+	int		rdimm_last_ce_count[NUM_SOCKETS][NUM_CHANS][MAX_DIMMS];
 
 	/* mcelog glue */
 	struct edac_mce		edac_mce;
@@ -471,6 +490,8 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow, u8 socket)
 		numrow(pvt->info.max_dod >> 6),
 		numcol(pvt->info.max_dod >> 9));
 
+	pvt->is_registered = 1;
+
 	for (i = 0; i < NUM_CHANS; i++) {
 		u32 data, dimm_dod[3], value[8];
 
@@ -492,8 +513,14 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow, u8 socket)
 
 		if (data & REGISTERED_DIMM)
 			mtype = MEM_RDDR3;
-		else
+		else {
 			mtype = MEM_DDR3;
+			/*
+			 * FIXME: Currently, the driver will use dev 3:2
+			 * counter registers only if all memories are registered
+			 */
+			pvt->is_registered = 0;
+		}
 #if 0
 		if (data & THREE_DIMMS_PRESENT)
 			pvt->channel[i].dimms = 3;
@@ -562,6 +589,8 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow, u8 socket)
 			csr->channels[0].chan_idx = i;
 			csr->channels[0].ce_count = 0;
 
+			pvt->csrow_map[socket][i][j] = *csrow;
+
 			switch (banks) {
 			case 4:
 				csr->dtype = DEV_X4;
@@ -1031,19 +1060,31 @@ static ssize_t i7core_inject_enable_show(struct mem_ctl_info *mci,
 
 static ssize_t i7core_ce_regs_show(struct mem_ctl_info *mci, char *data)
 {
-	unsigned i, count, total = 0;
+	unsigned i, j, count, total = 0;
 	struct i7core_pvt *pvt = mci->pvt_info;
 
 	for (i = 0; i < pvt->sockets; i++) {
-		if (!pvt->ce_count_available[i])
+		if (!pvt->ce_count_available[i]) {
 			count = sprintf(data, "socket 0 data unavailable\n");
-		else
+			continue;
+		}
+		if (!pvt->is_registered)
 			count = sprintf(data, "socket %d, dimm0: %lu\n"
 					      "dimm1: %lu\ndimm2: %lu\n",
 					i,
-					pvt->ce_count[i][0],
-					pvt->ce_count[i][1],
-					pvt->ce_count[i][2]);
+					pvt->udimm_ce_count[i][0],
+					pvt->udimm_ce_count[i][1],
+					pvt->udimm_ce_count[i][2]);
+		else
+			for (j = 0; j < NUM_CHANS; j++) {
+				count = sprintf(data, "socket %d, channel %d"
+						"dimm0: %lu\n"
+						"dimm1: %lu\ndimm2: %lu\n",
+						i, j,
+						pvt->rdimm_ce_count[i][j][0],
+						pvt->rdimm_ce_count[i][j][1],
+						pvt->rdimm_ce_count[i][j][2]);
+					}
 		data  += count;
 		total += count;
 	}
@@ -1308,6 +1349,103 @@ static int mci_bind_devs(struct mem_ctl_info *mci)
 /****************************************************************************
 			Error check routines
  ****************************************************************************/
+static void i7core_rdimm_update_csrow(struct mem_ctl_info *mci, int socket,
+					 int chan, int dimm, int add)
+{
+	char *msg;
+	struct i7core_pvt *pvt = mci->pvt_info;
+	int row = pvt->csrow_map[socket][chan][dimm], i;
+
+	for (i = 0; i < add; i++) {
+		msg = kasprintf(GFP_KERNEL, "Corrected error "
+				"(Socket=%d channel=%d dimm=%d",
+				socket, chan, dimm);
+
+		edac_mc_handle_fbd_ce(mci, row, 0, msg);
+		kfree (msg);
+	}
+}
+
+static void i7core_rdimm_update_ce_count(struct mem_ctl_info *mci,
+			int socket, int chan, int new0, int new1, int new2)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	int add0 = 0, add1 = 0, add2 = 0;
+	/* Updates CE counters if it is not the first time here */
+	if (pvt->ce_count_available[socket]) {
+		/* Updates CE counters */
+
+		add2 = new2 - pvt->rdimm_last_ce_count[socket][chan][2];
+		add1 = new1 - pvt->rdimm_last_ce_count[socket][chan][1];
+		add0 = new0 - pvt->rdimm_last_ce_count[socket][chan][0];
+
+		if (add2 < 0)
+			add2 += 0x7fff;
+		pvt->rdimm_ce_count[socket][chan][2] += add2;
+
+		if (add1 < 0)
+			add1 += 0x7fff;
+		pvt->rdimm_ce_count[socket][chan][1] += add1;
+
+		if (add0 < 0)
+			add0 += 0x7fff;
+		pvt->rdimm_ce_count[socket][chan][0] += add0;
+	} else
+		pvt->ce_count_available[socket] = 1;
+
+	/* Store the new values */
+	pvt->rdimm_last_ce_count[socket][chan][2] = new2;
+	pvt->rdimm_last_ce_count[socket][chan][1] = new1;
+	pvt->rdimm_last_ce_count[socket][chan][0] = new0;
+
+	/*updated the edac core */
+	if (add0 != 0)
+		i7core_rdimm_update_csrow(mci, socket, chan, 0, add0);
+	if (add1 != 0)
+		i7core_rdimm_update_csrow(mci, socket, chan, 1, add1);
+	if (add2 != 0)
+		i7core_rdimm_update_csrow(mci, socket, chan, 2, add2);
+
+}
+
+static void i7core_rdimm_check_mc_ecc_err(struct mem_ctl_info *mci, u8 socket)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	u32 rcv[3][2];
+	int i, new0, new1, new2;
+
+	/*Read DEV 3: FUN 2:  MC_COR_ECC_CNT regs directly*/
+	pci_read_config_dword(pvt->pci_mcr[socket][2], MC_COR_ECC_CNT_0,
+								&rcv[0][0]);
+	pci_read_config_dword(pvt->pci_mcr[socket][2], MC_COR_ECC_CNT_1,
+								&rcv[0][1]);
+	pci_read_config_dword(pvt->pci_mcr[socket][2], MC_COR_ECC_CNT_2,
+								&rcv[1][0]);
+	pci_read_config_dword(pvt->pci_mcr[socket][2], MC_COR_ECC_CNT_3,
+								&rcv[1][1]);
+	pci_read_config_dword(pvt->pci_mcr[socket][2], MC_COR_ECC_CNT_4,
+								&rcv[2][0]);
+	pci_read_config_dword(pvt->pci_mcr[socket][2], MC_COR_ECC_CNT_5,
+								&rcv[2][1]);
+	for (i = 0 ; i < 3; i++) {
+		debugf3("MC_COR_ECC_CNT%d = 0x%x; MC_COR_ECC_CNT%d = 0x%x\n",
+			(i * 2), rcv[i][0], (i * 2) + 1, rcv[i][1]);
+		/*if the channel has 3 dimms*/
+		if (pvt->channel[socket][i].dimms > 2) {
+			new0 = DIMM_BOT_COR_ERR(rcv[i][0]);
+			new1 = DIMM_TOP_COR_ERR(rcv[i][0]);
+			new2 = DIMM_BOT_COR_ERR(rcv[i][1]);
+		} else {
+			new0 = DIMM_TOP_COR_ERR(rcv[i][0]) +
+					DIMM_BOT_COR_ERR(rcv[i][0]);
+			new1 = DIMM_TOP_COR_ERR(rcv[i][1]) +
+					DIMM_BOT_COR_ERR(rcv[i][1]);
+			new2 = 0;
+		}
+
+		i7core_rdimm_update_ce_count(mci, socket, i, new0, new1, new2);
+	}
+}
 
 /* This function is based on the device 3 function 4 registers as described on:
  * Intel Xeon Processor 5500 Series Datasheet Volume 2
@@ -1315,7 +1453,7 @@ static int mci_bind_devs(struct mem_ctl_info *mci)
  * also available at:
  * 	http://www.arrownac.com/manufacturers/intel/s/nehalem/5500-datasheet-v2.pdf
  */
-static void check_mc_test_err(struct mem_ctl_info *mci, u8 socket)
+static void i7core_udimm_check_mc_ecc_err(struct mem_ctl_info *mci, u8 socket)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	u32 rcv1, rcv0;
@@ -1326,7 +1464,7 @@ static void check_mc_test_err(struct mem_ctl_info *mci, u8 socket)
 		return;
 	}
 
-	/* Corrected error reads */
+	/* Corrected test errors */
 	pci_read_config_dword(pvt->pci_mcr[socket][4], MC_TEST_ERR_RCV1, &rcv1);
 	pci_read_config_dword(pvt->pci_mcr[socket][4], MC_TEST_ERR_RCV0, &rcv0);
 
@@ -1335,39 +1473,38 @@ static void check_mc_test_err(struct mem_ctl_info *mci, u8 socket)
 	new1 = DIMM1_COR_ERR(rcv0);
 	new0 = DIMM0_COR_ERR(rcv0);
 
-#if 0
-	debugf2("%s CE rcv1=0x%08x rcv0=0x%08x, %d %d %d\n",
-		(pvt->ce_count_available ? "UPDATE" : "READ"),
-		rcv1, rcv0, new0, new1, new2);
-#endif
-
 	/* Updates CE counters if it is not the first time here */
 	if (pvt->ce_count_available[socket]) {
 		/* Updates CE counters */
 		int add0, add1, add2;
 
-		add2 = new2 - pvt->last_ce_count[socket][2];
-		add1 = new1 - pvt->last_ce_count[socket][1];
-		add0 = new0 - pvt->last_ce_count[socket][0];
+		add2 = new2 - pvt->udimm_last_ce_count[socket][2];
+		add1 = new1 - pvt->udimm_last_ce_count[socket][1];
+		add0 = new0 - pvt->udimm_last_ce_count[socket][0];
 
 		if (add2 < 0)
 			add2 += 0x7fff;
-		pvt->ce_count[socket][2] += add2;
+		pvt->udimm_ce_count[socket][2] += add2;
 
 		if (add1 < 0)
 			add1 += 0x7fff;
-		pvt->ce_count[socket][1] += add1;
+		pvt->udimm_ce_count[socket][1] += add1;
 
 		if (add0 < 0)
 			add0 += 0x7fff;
-		pvt->ce_count[socket][0] += add0;
+		pvt->udimm_ce_count[socket][0] += add0;
+
+		if (add0 | add1 | add2)
+			i7core_printk(KERN_ERR, "New Corrected error(s): "
+				      "dimm0: +%d, dimm1: +%d, dimm2 +%d\n",
+				      add0, add1, add2);
 	} else
 		pvt->ce_count_available[socket] = 1;
 
 	/* Store the new values */
-	pvt->last_ce_count[socket][2] = new2;
-	pvt->last_ce_count[socket][1] = new1;
-	pvt->last_ce_count[socket][0] = new0;
+	pvt->udimm_last_ce_count[socket][2] = new2;
+	pvt->udimm_last_ce_count[socket][1] = new1;
+	pvt->udimm_last_ce_count[socket][0] = new0;
 }
 
 /*
@@ -1386,6 +1523,7 @@ static void check_mc_test_err(struct mem_ctl_info *mci, u8 socket)
 static void i7core_mce_output_error(struct mem_ctl_info *mci,
 				    struct mce *m)
 {
+	struct i7core_pvt *pvt = mci->pvt_info;
 	char *type, *optype, *err, *msg;
 	unsigned long error = m->status & 0x1ff0000l;
 	u32 optypenum = (m->status >> 4) & 0x07;
@@ -1394,6 +1532,7 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 	u32 channel = (m->misc >> 18) & 0x3;
 	u32 syndrome = m->misc >> 32;
 	u32 errnum = find_first_bit(&error, 32);
+	int csrow;
 
 	if (m->mcgstatus & 1)
 		type = "FATAL";
@@ -1463,9 +1602,15 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 
 	debugf0("%s", msg);
 
+	csrow = pvt->csrow_map[m->cpu][channel][dimm];
+
 	/* Call the helper to output message */
-	edac_mc_handle_fbd_ue(mci, 0 /* FIXME: should be rank here */,
-			      0, 0 /* FIXME: should be channel here */, msg);
+	if (m->mcgstatus & 1)
+		edac_mc_handle_fbd_ue(mci, csrow, 0,
+				0 /* FIXME: should be channel here */, msg);
+	else if (!pvt->is_registered)
+		edac_mc_handle_fbd_ce(mci, csrow,
+				0 /* FIXME: should be channel here */, msg);
 
 	kfree(msg);
 }
@@ -1502,7 +1647,10 @@ static void i7core_check_error(struct mem_ctl_info *mci)
 
 	/* check memory count errors */
 	for (i = 0; i < pvt->sockets; i++)
-		check_mc_test_err(mci, i);
+		if (!pvt->is_registered)
+			i7core_udimm_check_mc_ecc_err(mci, i);
+		else
+			i7core_rdimm_check_mc_ecc_err(mci, i);
 }
 
 /*

commit 61053fdedb2080dadc18dc37abbba90d2e74bc03
Author: Keith Mannthey <kmannth@us.ibm.com>
Date:   Wed Sep 2 23:46:59 2009 -0300

    i7core_edac: Fix ecc enable shift
    
    From: Keith Mannthey <kmannth@us.ibm.com>
    
    Simple correction to a shift value.
    ECC_ENABLED is bit 4 of MC_STATUS, Dev 3 Fun 0 Offset 0x4c
    
    This correctly identifies the state of the ECC at the machine.
    
    Signed-off-by: Keith Mannthey <kmannth@us.ibm.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 26205e2efecf..87d5695f5fb0 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -286,7 +286,7 @@ static struct edac_pci_ctl_info *i7core_pci;
 #define ECCx8(pvt)		((pvt)->info.mc_control & (1 << 1))
 
 	/* MC_STATUS bits */
-#define ECC_ENABLED(pvt)	((pvt)->info.mc_status & (1 << 3))
+#define ECC_ENABLED(pvt)	((pvt)->info.mc_status & (1 << 4))
 #define CH_DISABLED(pvt, ch)	((pvt)->info.mc_status & (1 << ch))
 
 	/* MC_MAX_DOD read functions */

commit 3ef288a98307adc9d3f83321b26281567f348ec6
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Sep 2 23:43:33 2009 -0300

    i7core_edac: Print an error message if pci register fails
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 86037a601b54..26205e2efecf 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1743,7 +1743,13 @@ static int __init i7core_init(void)
 
 	pci_rc = pci_register_driver(&i7core_driver);
 
-	return (pci_rc < 0) ? pci_rc : 0;
+	if (pci_rc >= 0)
+		return 0;
+
+	i7core_printk(KERN_ERR, "Failed to register device with error %d.\n",
+		      pci_rc);
+
+	return pci_rc;
 }
 
 /*

commit b990538a78ea84e89551ccaddf182beb5e16e6d2
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Aug 5 21:36:35 2009 -0300

    i7core_edac: CodingSyle fixes/cleanups
    
    No functional changes.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index f16aac253654..86037a601b54 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -38,10 +38,6 @@
 #define I7CORE_REVISION    " Ver: 1.0.0 " __DATE__
 #define EDAC_MOD_STR      "i7core_edac"
 
-/* HACK: temporary, just to enable all logs, for now */
-#undef debugf0
-#define debugf0(fmt, arg...)  edac_printk(KERN_INFO, "i7core", fmt, ##arg)
-
 /*
  * Debug macros
  */
@@ -105,6 +101,7 @@
   #define REPEAT_EN		0x01
 
 	/* OFFSETS for Devices 4,5 and 6 Function 1 */
+
 #define MC_DOD_CH_DIMM0		0x48
 #define MC_DOD_CH_DIMM1		0x4c
 #define MC_DOD_CH_DIMM2		0x50
@@ -227,7 +224,7 @@ struct pci_id_descr pci_devs[] = {
 		/* Memory controller */
 	{ PCI_DESCR(3, 0, PCI_DEVICE_ID_INTEL_I7_MCR)     },
 	{ PCI_DESCR(3, 1, PCI_DEVICE_ID_INTEL_I7_MC_TAD)  },
-	{ PCI_DESCR(3, 2, PCI_DEVICE_ID_INTEL_I7_MC_RAS)  }, /* if RDIMM is supported */
+	{ PCI_DESCR(3, 2, PCI_DEVICE_ID_INTEL_I7_MC_RAS)  }, /* if RDIMM */
 	{ PCI_DESCR(3, 4, PCI_DEVICE_ID_INTEL_I7_MC_TEST) },
 
 		/* Channel 0 */
@@ -878,7 +875,7 @@ static int write_and_test(struct pci_dev *dev, int where, u32 val)
 
 	for (count = 0; count < 10; count++) {
 		if (count)
-			msleep (100);
+			msleep(100);
 		pci_write_config_dword(dev, where, val);
 		pci_read_config_dword(dev, where, &read);
 
@@ -894,7 +891,6 @@ static int write_and_test(struct pci_dev *dev, int where, u32 val)
 	return -EINVAL;
 }
 
-
 /*
  * This routine prepares the Memory Controller for error injection.
  * The error will be injected when some process tries to write to the
@@ -1326,7 +1322,7 @@ static void check_mc_test_err(struct mem_ctl_info *mci, u8 socket)
 	int new0, new1, new2;
 
 	if (!pvt->pci_mcr[socket][4]) {
-		debugf0("%s MCR registers not found\n",__func__);
+		debugf0("%s MCR registers not found\n", __func__);
 		return;
 	}
 
@@ -1405,24 +1401,24 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 		type = "NON_FATAL";
 
 	switch (optypenum) {
-		case 0:
-			optype = "generic undef request";
-			break;
-		case 1:
-			optype = "read error";
-			break;
-		case 2:
-			optype = "write error";
-			break;
-		case 3:
-			optype = "addr/cmd error";
-			break;
-		case 4:
-			optype = "scrubbing error";
-			break;
-		default:
-			optype = "reserved";
-			break;
+	case 0:
+		optype = "generic undef request";
+		break;
+	case 1:
+		optype = "read error";
+		break;
+	case 2:
+		optype = "write error";
+		break;
+	case 3:
+		optype = "addr/cmd error";
+		break;
+	case 4:
+		optype = "scrubbing error";
+		break;
+	default:
+		optype = "reserved";
+		break;
 	}
 
 	switch (errnum) {
@@ -1672,7 +1668,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	spin_lock_init(&pvt->mce_lock);
 
 	rc = edac_mce_register(&pvt->edac_mce);
-	if (unlikely (rc < 0)) {
+	if (unlikely(rc < 0)) {
 		debugf0("MC: " __FILE__
 			": %s(): failed edac_mce_register()\n", __func__);
 		goto fail1;

commit 4157d9f55435331deef01ba8a9a47f248c042fb2
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Aug 5 20:27:15 2009 -0300

    i7core_edac: fix error injection
    
    There were two stupid error injection bugs introduced by wrong
    cut-and-paste: one at socket store, and another at the error inject
    register. The last one were causing the code to not work at all.
    
    While here, adds debug messages to allow seeing what registers are being
    set while sending error injection.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index ab9d26ec19d7..f16aac253654 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -625,7 +625,7 @@ static int disable_inject(struct mem_ctl_info *mci)
 		return -ENODEV;
 
 	pci_write_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
-				MC_CHANNEL_ERROR_MASK, 0);
+				MC_CHANNEL_ERROR_INJECT, 0);
 
 	return 0;
 }
@@ -646,7 +646,7 @@ static ssize_t i7core_inject_socket_store(struct mem_ctl_info *mci,
 	if ((rc < 0) || (value >= pvt->sockets))
 		return -EIO;
 
-	pvt->inject.section = (u32) value;
+	pvt->inject.socket = (u32) value;
 	return count;
 }
 
@@ -872,6 +872,10 @@ static int write_and_test(struct pci_dev *dev, int where, u32 val)
 	u32 read;
 	int count;
 
+	debugf0("setting pci %02x:%02x.%x reg=%02x value=%08x\n",
+		dev->bus->number, PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn),
+		where, val);
+
 	for (count = 0; count < 10; count++) {
 		if (count)
 			msleep (100);
@@ -882,8 +886,10 @@ static int write_and_test(struct pci_dev *dev, int where, u32 val)
 			return 0;
 	}
 
-	debugf0("Error Injection Register 0x%02x: Tried to write 0x%08x, "
-		"but read: 0x%08x\n", where, val, read);
+	i7core_printk(KERN_ERR, "Error during set pci %02x:%02x.%x reg=%02x "
+		"write=%08x. Read=%08x\n",
+		dev->bus->number, PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn),
+		where, val, read);
 
 	return -EINVAL;
 }
@@ -983,15 +989,6 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 	pci_write_config_dword(pvt->pci_noncore[pvt->inject.socket],
 			       MC_CFG_CONTROL, 0x2);
 
-#if 0
-	/* Zeroes error count registers */
-	pci_write_config_dword(pvt->pci_mcr[pvt->inject.socket][4],
-			       MC_TEST_ERR_RCV1, 0);
-	pci_write_config_dword(pvt->pci_mcr[pvt->inject.socket][4],
-			       MC_TEST_ERR_RCV0, 0);
-	pvt->ce_count_available[pvt->inject.socket] = 0;
-#endif
-
 	write_and_test(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
 			       MC_CHANNEL_ADDR_MATCH, mask);
 	write_and_test(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
@@ -1001,7 +998,7 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 			       MC_CHANNEL_ERROR_MASK, pvt->inject.eccmask);
 
 	write_and_test(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
-			       MC_CHANNEL_ERROR_MASK, injectmask);
+			       MC_CHANNEL_ERROR_INJECT, injectmask);
 
 	/*
 	 * This is something undocumented, based on my tests
@@ -1026,7 +1023,7 @@ static ssize_t i7core_inject_enable_show(struct mem_ctl_info *mci,
 	u32 injectmask;
 
 	pci_read_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
-			       MC_CHANNEL_ERROR_MASK, &injectmask);
+			       MC_CHANNEL_ERROR_INJECT, &injectmask);
 
 	debugf0("Inject error read: 0x%018x\n", injectmask);
 

commit 2068def56c09f2b24e6de04a1b84757a0fb07947
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Aug 5 19:28:27 2009 -0300

    i7core_edac: fix error codes for sysfs error injection interface
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 72859e87aeb2..ab9d26ec19d7 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -644,7 +644,7 @@ static ssize_t i7core_inject_socket_store(struct mem_ctl_info *mci,
 
 	rc = strict_strtoul(data, 10, &value);
 	if ((rc < 0) || (value >= pvt->sockets))
-		return 0;
+		return -EIO;
 
 	pvt->inject.section = (u32) value;
 	return count;
@@ -676,7 +676,7 @@ static ssize_t i7core_inject_section_store(struct mem_ctl_info *mci,
 
 	rc = strict_strtoul(data, 10, &value);
 	if ((rc < 0) || (value > 3))
-		return 0;
+		return -EIO;
 
 	pvt->inject.section = (u32) value;
 	return count;
@@ -709,7 +709,7 @@ static ssize_t i7core_inject_type_store(struct mem_ctl_info *mci,
 
 	rc = strict_strtoul(data, 10, &value);
 	if ((rc < 0) || (value > 7))
-		return 0;
+		return -EIO;
 
 	pvt->inject.type = (u32) value;
 	return count;
@@ -744,7 +744,7 @@ static ssize_t i7core_inject_eccmask_store(struct mem_ctl_info *mci,
 
 	rc = strict_strtoul(data, 10, &value);
 	if (rc < 0)
-		return 0;
+		return -EIO;
 
 	pvt->inject.eccmask = (u32) value;
 	return count;

commit 276b824c3095b09e8cb76f5709f56e9c6818ae85
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Jul 22 21:45:50 2009 -0300

    i7core_edac: some fixes at error injection code
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 86af14840b88..72859e87aeb2 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -32,9 +32,6 @@
 
 #include "edac_core.h"
 
-/* To use the new pci_[read/write]_config_qword instead of two dword */
-#define USE_QWORD 0
-
 /*
  * Alter this version for the module when modifications are made
  */
@@ -473,7 +470,7 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow, u8 socket)
 		"x%x x 0x%x\n",
 		numdimms(pvt->info.max_dod),
 		numrank(pvt->info.max_dod >> 2),
-		numbank(pvt->info.max_dod >> 4));
+		numbank(pvt->info.max_dod >> 4),
 		numrow(pvt->info.max_dod >> 6),
 		numcol(pvt->info.max_dod >> 9));
 
@@ -646,7 +643,7 @@ static ssize_t i7core_inject_socket_store(struct mem_ctl_info *mci,
 	int rc;
 
 	rc = strict_strtoul(data, 10, &value);
-	if ((rc < 0) || (value > pvt->sockets))
+	if ((rc < 0) || (value >= pvt->sockets))
 		return 0;
 
 	pvt->inject.section = (u32) value;
@@ -803,7 +800,7 @@ static ssize_t i7core_inject_addrmatch_store(struct mem_ctl_info *mci,
 			else
 				return cmd - data;
 		} else if (!strcasecmp(cmd, "dimm")) {
-			if (value < 4)
+			if (value < 3)
 				pvt->inject.dimm = value;
 			else
 				return cmd - data;
@@ -813,7 +810,7 @@ static ssize_t i7core_inject_addrmatch_store(struct mem_ctl_info *mci,
 			else
 				return cmd - data;
 		} else if (!strcasecmp(cmd, "bank")) {
-			if (value < 4)
+			if (value < 32)
 				pvt->inject.bank = value;
 			else
 				return cmd - data;
@@ -870,6 +867,28 @@ static ssize_t i7core_inject_addrmatch_show(struct mem_ctl_info *mci,
 		       channel, dimm, bank, rank, page, col);
 }
 
+static int write_and_test(struct pci_dev *dev, int where, u32 val)
+{
+	u32 read;
+	int count;
+
+	for (count = 0; count < 10; count++) {
+		if (count)
+			msleep (100);
+		pci_write_config_dword(dev, where, val);
+		pci_read_config_dword(dev, where, &read);
+
+		if (read == val)
+			return 0;
+	}
+
+	debugf0("Error Injection Register 0x%02x: Tried to write 0x%08x, "
+		"but read: 0x%08x\n", where, val, read);
+
+	return -EINVAL;
+}
+
+
 /*
  * This routine prepares the Memory Controller for error injection.
  * The error will be injected when some process tries to write to the
@@ -949,70 +968,49 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 	else
 		mask |= (pvt->inject.col & 0x3fffL);
 
-	/* Unlock writes to registers */
+	/*
+	 * bit    0: REPEAT_EN
+	 * bits 1-2: MASK_HALF_CACHELINE
+	 * bit    3: INJECT_ECC
+	 * bit    4: INJECT_ADDR_PARITY
+	 */
+
+	injectmask = (pvt->inject.type & 1) |
+		     (pvt->inject.section & 0x3) << 1 |
+		     (pvt->inject.type & 0x6) << (3 - 1);
+
+	/* Unlock writes to registers - this register is write only */
 	pci_write_config_dword(pvt->pci_noncore[pvt->inject.socket],
 			       MC_CFG_CONTROL, 0x2);
-	msleep(100);
 
+#if 0
 	/* Zeroes error count registers */
 	pci_write_config_dword(pvt->pci_mcr[pvt->inject.socket][4],
 			       MC_TEST_ERR_RCV1, 0);
 	pci_write_config_dword(pvt->pci_mcr[pvt->inject.socket][4],
 			       MC_TEST_ERR_RCV0, 0);
 	pvt->ce_count_available[pvt->inject.socket] = 0;
+#endif
 
-
-#if USE_QWORD
-	pci_write_config_qword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
+	write_and_test(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
 			       MC_CHANNEL_ADDR_MATCH, mask);
-#else
-	pci_write_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
-			       MC_CHANNEL_ADDR_MATCH, mask);
-	pci_write_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
+	write_and_test(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
 			       MC_CHANNEL_ADDR_MATCH + 4, mask >> 32L);
-#endif
 
-#if 1
-#if USE_QWORD
-	u64 rdmask;
-	pci_read_config_qword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
-			       MC_CHANNEL_ADDR_MATCH, &rdmask);
-	debugf0("Inject addr match write 0x%016llx, read: 0x%016llx\n",
-		mask, rdmask);
-#else
-	u32 rdmask1, rdmask2;
-
-	pci_read_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
-			       MC_CHANNEL_ADDR_MATCH, &rdmask1);
-	pci_read_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
-			       MC_CHANNEL_ADDR_MATCH + 4, &rdmask2);
-
-	debugf0("Inject addr match write 0x%016llx, read: 0x%08x 0x%08x\n",
-		mask, rdmask1, rdmask2);
-#endif
-#endif
-
-	pci_write_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
+	write_and_test(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
 			       MC_CHANNEL_ERROR_MASK, pvt->inject.eccmask);
 
+	write_and_test(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
+			       MC_CHANNEL_ERROR_MASK, injectmask);
+
 	/*
-	 * bit    0: REPEAT_EN
-	 * bits 1-2: MASK_HALF_CACHELINE
-	 * bit    3: INJECT_ECC
-	 * bit    4: INJECT_ADDR_PARITY
+	 * This is something undocumented, based on my tests
+	 * Without writing 8 to this register, errors aren't injected. Not sure
+	 * why.
 	 */
+	pci_write_config_dword(pvt->pci_noncore[pvt->inject.socket],
+			       MC_CFG_CONTROL, 8);
 
-	injectmask = (pvt->inject.type & 1) |
-		     (pvt->inject.section & 0x3) << 1 |
-		     (pvt->inject.type & 0x6) << (3 - 1);
-
-	pci_write_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
-			       MC_CHANNEL_ERROR_MASK, injectmask);
-
-#if 0
-	/* lock writes to registers */
-	pci_write_config_dword(pvt->pci_noncore, MC_CFG_CONTROL, 0);
-#endif
 	debugf0("Error inject addr match 0x%016llx, ecc 0x%08x,"
 		" inject 0x%08x\n",
 		mask, pvt->inject.eccmask, injectmask);

commit 17cb7b0cf78c14913c5410eff2ce03e1d9c8d958
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jul 20 18:48:18 2009 -0300

    i7core_edac: Some cleanups at displayed info
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index fd00e0299ca1..86af14840b88 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -453,8 +453,8 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow, u8 socket)
 	pci_read_config_dword(pdev, MC_MAX_DOD, &pvt->info.max_dod);
 	pci_read_config_dword(pdev, MC_CHANNEL_MAPPER, &pvt->info.ch_map);
 
-	debugf0("MC control=0x%08x status=0x%08x dod=0x%08x map=0x%08x\n",
-		pvt->info.mc_control, pvt->info.mc_status,
+	debugf0("QPI %d control=0x%08x status=0x%08x dod=0x%08x map=0x%08x\n",
+		socket, pvt->info.mc_control, pvt->info.mc_status,
 		pvt->info.max_dod, pvt->info.ch_map);
 
 	if (ECC_ENABLED(pvt)) {
@@ -469,16 +469,14 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow, u8 socket)
 	}
 
 	/* FIXME: need to handle the error codes */
-	debugf0("DOD Max limits: DIMMS: %d, %d-ranked, %d-banked\n",
+	debugf0("DOD Max limits: DIMMS: %d, %d-ranked, %d-banked "
+		"x%x x 0x%x\n",
 		numdimms(pvt->info.max_dod),
 		numrank(pvt->info.max_dod >> 2),
 		numbank(pvt->info.max_dod >> 4));
-	debugf0("DOD Max rows x colums = 0x%x x 0x%x\n",
 		numrow(pvt->info.max_dod >> 6),
 		numcol(pvt->info.max_dod >> 9));
 
-	debugf0("Memory channel configuration:\n");
-
 	for (i = 0; i < NUM_CHANS; i++) {
 		u32 data, dimm_dod[3], value[8];
 
@@ -544,10 +542,9 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow, u8 socket)
 
 			pvt->channel[socket][i].dimms++;
 
-			debugf0("\tdimm %d (0x%08x) %d Mb offset: %x, "
-				"numbank: %d,\n\t\t"
-				"numrank: %d, numrow: %#x, numcol: %#x\n",
-				j, dimm_dod[j], size,
+			debugf0("\tdimm %d %d Mb offset: %x, "
+				"bank: %d, rank: %d, row: %#x, col: %#x\n",
+				j, size,
 				RANKOFFSET(dimm_dod[j]),
 				banks, ranks, rows, cols);
 
@@ -599,9 +596,9 @@ static int get_dimm_config(struct mem_ctl_info *mci, int *csrow, u8 socket)
 		pci_read_config_dword(pdev, MC_SAG_CH_5, &value[5]);
 		pci_read_config_dword(pdev, MC_SAG_CH_6, &value[6]);
 		pci_read_config_dword(pdev, MC_SAG_CH_7, &value[7]);
-		debugf0("\t[%i] DIVBY3\tREMOVED\tOFFSET\n", i);
+		debugf1("\t[%i] DIVBY3\tREMOVED\tOFFSET\n", i);
 		for (j = 0; j < 8; j++)
-			debugf0("\t\t%#x\t%#x\t%#x\n",
+			debugf1("\t\t%#x\t%#x\t%#x\n",
 				(value[j] >> 27) & 0x1,
 				(value[j] >> 24) & 0x7,
 				(value[j] && ((1 << 24) - 1)));

commit 086271a0374bf0b9ce033aac9fb60530c421ad65
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Jul 18 12:22:28 2009 -0300

    i7core: remove some uneeded noisy debug messages
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 5695413c2879..fd00e0299ca1 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1494,8 +1494,6 @@ static void i7core_check_error(struct mem_ctl_info *mci)
 	struct mce *m = NULL;
 	unsigned long flags;
 
-	debugf0(__FILE__ ": %s()\n", __func__);
-
 	/* Copy all mce errors into a temporary buffer */
 	spin_lock_irqsave(&pvt->mce_lock, flags);
 	if (pvt->mce_count) {
@@ -1531,8 +1529,6 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 	struct i7core_pvt *pvt = mci->pvt_info;
 	unsigned long flags;
 
-	debugf0(__FILE__ ": %s()\n", __func__);
-
 	/*
 	 * Just let mcelog handle it if the error is
 	 * outside the memory controller

commit 3a7dde7fcd0dd50df33e0e7070d4947551d767fc
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Jul 18 12:20:04 2009 -0300

    i7core: add socket info at the debug msg
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index bf0374062e3d..5695413c2879 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1467,9 +1467,9 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 
 	/* FIXME: should convert addr into bank and rank information */
 	msg = kasprintf(GFP_ATOMIC,
-		"%s (addr = 0x%08llx, Dimm=%d, Channel=%d, "
+		"%s (addr = 0x%08llx, socket=%d, Dimm=%d, Channel=%d, "
 		"syndrome=0x%08x, count=%d, Err=%08llx:%08llx (%s: %s))\n",
-		type, (long long) m->addr, dimm, channel,
+		type, (long long) m->addr, m->cpu, dimm, channel,
 		syndrome, core_err_cnt, (long long)m->status,
 		(long long)m->misc, optype, err);
 

commit ec6df24c15822e671801eeeb53758e14f3b28381
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Jul 18 10:44:30 2009 -0300

    i7core: better document i7core_get_active_channels()
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 79636b58ec52..bf0374062e3d 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -333,7 +333,6 @@ static inline int numcol(u32 col)
 	return cols[col & 0x3];
 }
 
-
 /****************************************************************************
 			Memory check routines
  ****************************************************************************/
@@ -355,6 +354,23 @@ static struct pci_dev *get_pdev_slot_func(u8 socket, unsigned slot,
 	return NULL;
 }
 
+/**
+ * i7core_get_active_channels() - gets the number of channels and csrows
+ * @socket:	Quick Path Interconnect socket
+ * @channels:	Number of channels that will be returned
+ * @csrows:	Number of csrows found
+ *
+ * Since EDAC core needs to know in advance the number of available channels
+ * and csrows, in order to allocate memory for csrows/channels, it is needed
+ * to run two similar steps. At the first step, implemented on this function,
+ * it checks the number of csrows/channels present at one socket.
+ * this is used in order to properly allocate the size of mci components.
+ *
+ * It should be noticed that none of the current available datasheets explain
+ * or even mention how csrows are seen by the memory controller. So, we need
+ * to add a fake description for csrows.
+ * So, this driver is attributing one DIMM memory for one csrow.
+ */
 static int i7core_get_active_channels(u8 socket, unsigned *channels,
 				      unsigned *csrows)
 {

commit c77720b9544d8825ff5b9546d0ee038cfa4d4eb2
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sat Jul 18 10:43:08 2009 -0300

    i7core: fix get_devices routine for Xeon55xx
    
    i7core_get_devices() were preparet to get just the first found device of each type.
    Due to that, on Xeon 55xx, only socket 1 were retrived.
    
    Rework i7core_get_devices() to clean it and to properly support Xeon 55xx.
    
    While here, fix a small typo.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 9f39d3d5502e..79636b58ec52 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -410,7 +410,7 @@ static int i7core_get_active_channels(u8 socket, unsigned *channels,
 		}
 	}
 
-	debugf0("Number of active channels on socked %d: %d\n",
+	debugf0("Number of active channels on socket %d: %d\n",
 		socket, *channels);
 
 	return 0;
@@ -1126,107 +1126,137 @@ static void i7core_put_devices(void)
  *
  *			Need to 'get' device 16 func 1 and func 2
  */
-static int i7core_get_devices(void)
+int i7core_get_onedevice(struct pci_dev **prev, int devno)
 {
-	int rc, i;
 	struct pci_dev *pdev = NULL;
 	u8 bus = 0;
 	u8 socket = 0;
 
-	for (i = 0; i < N_DEVS; i++) {
+	pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
+			      pci_devs[devno].dev_id, *prev);
+
+	/*
+	 * On Xeon 55xx, the Intel Quckpath Arch Generic Non-core pci buses
+	 * aren't announced by acpi. So, we need to use a legacy scan probing
+	 * to detect them
+	 */
+	if (unlikely(!pdev && !devno && !prev)) {
+		pcibios_scan_specific_bus(254);
+		pcibios_scan_specific_bus(255);
+
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
-					pci_devs[i].dev_id, NULL);
+				      pci_devs[devno].dev_id, *prev);
+	}
 
-		if (!pdev && !i) {
-			pcibios_scan_specific_bus(254);
-			pcibios_scan_specific_bus(255);
+	/*
+	 * On Xeon 55xx, the Intel Quckpath Arch Generic Non-core regs
+	 * is at addr 8086:2c40, instead of 8086:2c41. So, we need
+	 * to probe for the alternate address in case of failure
+	 */
+	if (pci_devs[devno].dev_id == PCI_DEVICE_ID_INTEL_I7_NOCORE && !pdev)
+		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
+				      PCI_DEVICE_ID_INTEL_I7_NOCORE_ALT, *prev);
 
-			pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
-						pci_devs[i].dev_id, NULL);
+	if (!pdev) {
+		if (*prev) {
+			*prev = pdev;
+			return 0;
 		}
 
 		/*
-		 * On Xeon 55xx, the Intel Quckpath Arch Generic Non-core regs
-		 * is at addr 8086:2c40, instead of 8086:2c41. So, we need
-		 * to probe for the alternate address in case of failure
+		 * Dev 3 function 2 only exists on chips with RDIMMs
+		 * so, it is ok to not found it
 		 */
-		if (pci_devs[i].dev_id == PCI_DEVICE_ID_INTEL_I7_NOCORE
-								    && !pdev)
-			pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
-				PCI_DEVICE_ID_INTEL_I7_NOCORE_ALT, NULL);
+		if ((pci_devs[devno].dev == 3) && (pci_devs[devno].func == 2)) {
+			*prev = pdev;
+			return 0;
+		}
 
-		if (likely(pdev)) {
-			bus = pdev->bus->number;
+		i7core_printk(KERN_ERR,
+			"Device not found: dev %02x.%d PCI ID %04x:%04x\n",
+			pci_devs[devno].dev, pci_devs[devno].func,
+			PCI_VENDOR_ID_INTEL, pci_devs[devno].dev_id);
 
-			if (bus == 0x3f)
-				socket = 0;
-			else
-				socket = 255 - bus;
+		/* End of list, leave */
+		return -ENODEV;
+	}
+	bus = pdev->bus->number;
 
-			if (socket >= NUM_SOCKETS) {
-				i7core_printk(KERN_ERR,
-					"Found unexpected socket for "
-					"dev %02x:%02x.%d PCI ID %04x:%04x\n",
-					bus, pci_devs[i].dev, pci_devs[i].func,
-					PCI_VENDOR_ID_INTEL, pci_devs[i].dev_id);
+	if (bus == 0x3f)
+		socket = 0;
+	else
+		socket = 255 - bus;
+
+	if (socket >= NUM_SOCKETS) {
+		i7core_printk(KERN_ERR,
+			"Unexpected socket for "
+			"dev %02x:%02x.%d PCI ID %04x:%04x\n",
+			bus, pci_devs[devno].dev, pci_devs[devno].func,
+			PCI_VENDOR_ID_INTEL, pci_devs[devno].dev_id);
+		pci_dev_put(pdev);
+		return -ENODEV;
+	}
 
-				rc = -ENODEV;
-				goto error;
-			}
+	if (pci_devs[devno].pdev[socket]) {
+		i7core_printk(KERN_ERR,
+			"Duplicated device for "
+			"dev %02x:%02x.%d PCI ID %04x:%04x\n",
+			bus, pci_devs[devno].dev, pci_devs[devno].func,
+			PCI_VENDOR_ID_INTEL, pci_devs[devno].dev_id);
+		pci_dev_put(pdev);
+		return -ENODEV;
+	}
 
-			pci_devs[i].pdev[socket] = pdev;
-		} else {
-			i7core_printk(KERN_ERR,
-				"Device not found: "
-				"dev %02x:%02x.%d PCI ID %04x:%04x\n",
-				bus, pci_devs[i].dev, pci_devs[i].func,
-				PCI_VENDOR_ID_INTEL, pci_devs[i].dev_id);
+	pci_devs[devno].pdev[socket] = pdev;
+
+	/* Sanity check */
+	if (unlikely(PCI_SLOT(pdev->devfn) != pci_devs[devno].dev ||
+			PCI_FUNC(pdev->devfn) != pci_devs[devno].func)) {
+		i7core_printk(KERN_ERR,
+			"Device PCI ID %04x:%04x "
+			"has dev %02x:%02x.%d instead of dev %02x:%02x.%d\n",
+			PCI_VENDOR_ID_INTEL, pci_devs[devno].dev_id,
+			bus, PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),
+			bus, pci_devs[devno].dev, pci_devs[devno].func);
+		return -ENODEV;
+	}
 
-			/* Dev 3 function 2 only exists on chips with RDIMMs */
-			if ((pci_devs[i].dev == 3) && (pci_devs[i].func == 2))
-				continue;
+	/* Be sure that the device is enabled */
+	if (unlikely(pci_enable_device(pdev) < 0)) {
+		i7core_printk(KERN_ERR,
+			"Couldn't enable "
+			"dev %02x:%02x.%d PCI ID %04x:%04x\n",
+			bus, pci_devs[devno].dev, pci_devs[devno].func,
+			PCI_VENDOR_ID_INTEL, pci_devs[devno].dev_id);
+		return -ENODEV;
+	}
 
-			/* End of list, leave */
-			rc = -ENODEV;
-			goto error;
-		}
+	i7core_printk(KERN_INFO,
+			"Registered socket %d "
+			"dev %02x:%02x.%d PCI ID %04x:%04x\n",
+			socket, bus, pci_devs[devno].dev, pci_devs[devno].func,
+			PCI_VENDOR_ID_INTEL, pci_devs[devno].dev_id);
 
-		/* Sanity check */
-		if (unlikely(PCI_SLOT(pdev->devfn) != pci_devs[i].dev ||
-			     PCI_FUNC(pdev->devfn) != pci_devs[i].func)) {
-			i7core_printk(KERN_ERR,
-				"Device PCI ID %04x:%04x "
-				"has fn %d.%d instead of fn %d.%d\n",
-				PCI_VENDOR_ID_INTEL, pci_devs[i].dev_id,
-				PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),
-				pci_devs[i].dev, pci_devs[i].func);
-			rc = -EINVAL;
-			goto error;
-		}
+	*prev = pdev;
 
-		/* Be sure that the device is enabled */
-		rc = pci_enable_device(pdev);
-		if (unlikely(rc < 0)) {
-			i7core_printk(KERN_ERR,
-				"Couldn't enable PCI ID %04x:%04x "
-				"fn %d.%d\n",
-				PCI_VENDOR_ID_INTEL, pci_devs[i].dev_id,
-				PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
-			goto error;
-		}
+	return 0;
+}
 
-		i7core_printk(KERN_INFO,
-				"Registered socket %d "
-				"dev %02x:%02x.%d PCI ID %04x:%04x\n",
-				socket, bus, pci_devs[i].dev, pci_devs[i].func,
-				PCI_VENDOR_ID_INTEL, pci_devs[i].dev_id);
-	}
+static int i7core_get_devices(void)
+{
+	int i;
+	struct pci_dev *pdev = NULL;
 
+	for (i = 0; i < N_DEVS; i++) {
+		pdev = NULL;
+		do {
+			if (i7core_get_onedevice(&pdev, i) < 0) {
+				i7core_put_devices();
+				return -ENODEV;
+			}
+		} while (pdev);
+	}
 	return 0;
-
-error:
-	i7core_put_devices();
-	return -EINVAL;
 }
 
 static int mci_bind_devs(struct mem_ctl_info *mci)

commit a639539fa28531924c6b5e0f3963cc63d060947d
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Jul 17 10:54:23 2009 -0300

    i7core: enrich error information based on memory transaction type
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 08149d5addff..9f39d3d5502e 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1352,9 +1352,9 @@ static void check_mc_test_err(struct mem_ctl_info *mci, u8 socket)
 static void i7core_mce_output_error(struct mem_ctl_info *mci,
 				    struct mce *m)
 {
-	char *type;
-	char *err, *msg;
+	char *type, *optype, *err, *msg;
 	unsigned long error = m->status & 0x1ff0000l;
+	u32 optypenum = (m->status >> 4) & 0x07;
 	u32 core_err_cnt = (m->status >> 38) && 0x7fff;
 	u32 dimm = (m->misc >> 16) & 0x3;
 	u32 channel = (m->misc >> 18) & 0x3;
@@ -1366,6 +1366,27 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 	else
 		type = "NON_FATAL";
 
+	switch (optypenum) {
+		case 0:
+			optype = "generic undef request";
+			break;
+		case 1:
+			optype = "read error";
+			break;
+		case 2:
+			optype = "write error";
+			break;
+		case 3:
+			optype = "addr/cmd error";
+			break;
+		case 4:
+			optype = "scrubbing error";
+			break;
+		default:
+			optype = "reserved";
+			break;
+	}
+
 	switch (errnum) {
 	case 16:
 		err = "read ECC error";
@@ -1400,10 +1421,11 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 
 	/* FIXME: should convert addr into bank and rank information */
 	msg = kasprintf(GFP_ATOMIC,
-		"%s (addr = 0x%08llx Dimm=%d, Channel=%d, "
-		"syndrome=0x%08x, count=%d Err=%d (%s))\n",
+		"%s (addr = 0x%08llx, Dimm=%d, Channel=%d, "
+		"syndrome=0x%08x, count=%d, Err=%08llx:%08llx (%s: %s))\n",
 		type, (long long) m->addr, dimm, channel,
-		syndrome, core_err_cnt,errnum, err);
+		syndrome, core_err_cnt, (long long)m->status,
+		(long long)m->misc, optype, err);
 
 	debugf0("%s", msg);
 

commit c5d34528696acadc40d2ba7601dbf35d65b74ad5
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Jul 17 10:28:15 2009 -0300

    i7core: check if the memory error is fatal or non-fatal
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index e2f6dfdca841..08149d5addff 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1352,7 +1352,7 @@ static void check_mc_test_err(struct mem_ctl_info *mci, u8 socket)
 static void i7core_mce_output_error(struct mem_ctl_info *mci,
 				    struct mce *m)
 {
-	char *type="NON-FATAL";
+	char *type;
 	char *err, *msg;
 	unsigned long error = m->status & 0x1ff0000l;
 	u32 core_err_cnt = (m->status >> 38) && 0x7fff;
@@ -1361,6 +1361,11 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 	u32 syndrome = m->misc >> 32;
 	u32 errnum = find_first_bit(&error, 32);
 
+	if (m->mcgstatus & 1)
+		type = "FATAL";
+	else
+		type = "NON_FATAL";
+
 	switch (errnum) {
 	case 16:
 		err = "read ECC error";
@@ -1454,7 +1459,8 @@ static void i7core_check_error(struct mem_ctl_info *mci)
  */
 static int i7core_mce_check_error(void *priv, struct mce *mce)
 {
-	struct i7core_pvt *pvt = priv;
+	struct mem_ctl_info *mci = priv;
+	struct i7core_pvt *pvt = mci->pvt_info;
 	unsigned long flags;
 
 	debugf0(__FILE__ ": %s()\n", __func__);
@@ -1477,6 +1483,10 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 	}
 	spin_unlock_irqrestore(&pvt->mce_lock, flags);
 
+	/* Handle fatal errors immediately */
+	if (mce->mcgstatus & 1)
+		i7core_check_error(mci);
+
 	/* Advice mcelog that the error were handled */
 	return 1;
 }
@@ -1601,7 +1611,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	pvt->inject.col = -1;
 
 	/* Registers on edac_mce in order to receive memory errors */
-	pvt->edac_mce.priv = pvt;
+	pvt->edac_mce.priv = mci;
 	pvt->edac_mce.check_error = i7core_mce_check_error;
 	spin_lock_init(&pvt->mce_lock);
 

commit 310cbb7284fab9fc9cbb6bb893e51c414e15bba3
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Jul 17 00:09:10 2009 -0300

    i7core: fix probing on Xeon55xx
    
    Xeon55xx fails to probe with this error message:
    
    EDAC DEBUG: in drivers/edac/i7core_edac.c, line at 1660: MC: drivers/edac/i7core_edac.c: i7core_init()
    EDAC i7core: Device not found: dev 00:00.0 PCI ID 8086:2c41
    i7core_edac: probe of 0000:00:14.0 failed with error -22
    
    This is due to the fact that, on Xeon35xx (and i7core), device 00.0 has
    PCI ID 8086:2c40.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 67822976992e..e2f6dfdca841 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -227,9 +227,6 @@ struct i7core_dev_info {
 	.dev_id = (device_id)
 
 struct pci_id_descr pci_devs[] = {
-		/* Generic Non-core registers */
-	{ PCI_DESCR(0, 0, PCI_DEVICE_ID_INTEL_I7_NOCORE)  },
-
 		/* Memory controller */
 	{ PCI_DESCR(3, 0, PCI_DEVICE_ID_INTEL_I7_MCR)     },
 	{ PCI_DESCR(3, 1, PCI_DEVICE_ID_INTEL_I7_MC_TAD)  },
@@ -253,6 +250,16 @@ struct pci_id_descr pci_devs[] = {
 	{ PCI_DESCR(6, 1, PCI_DEVICE_ID_INTEL_I7_MC_CH2_ADDR) },
 	{ PCI_DESCR(6, 2, PCI_DEVICE_ID_INTEL_I7_MC_CH2_RANK) },
 	{ PCI_DESCR(6, 3, PCI_DEVICE_ID_INTEL_I7_MC_CH2_TC)   },
+
+		/* Generic Non-core registers */
+	/*
+	 * This is the PCI device on i7core and on Xeon 35xx (8086:2c41)
+	 * On Xeon 55xx, however, it has a different id (8086:2c40). So,
+	 * the probing code needs to test for the other address in case of
+	 * failure of this one
+	 */
+	{ PCI_DESCR(0, 0, PCI_DEVICE_ID_INTEL_I7_NOCORE)  },
+
 };
 #define N_DEVS ARRAY_SIZE(pci_devs)
 
@@ -1138,6 +1145,16 @@ static int i7core_get_devices(void)
 						pci_devs[i].dev_id, NULL);
 		}
 
+		/*
+		 * On Xeon 55xx, the Intel Quckpath Arch Generic Non-core regs
+		 * is at addr 8086:2c40, instead of 8086:2c41. So, we need
+		 * to probe for the alternate address in case of failure
+		 */
+		if (pci_devs[i].dev_id == PCI_DEVICE_ID_INTEL_I7_NOCORE
+								    && !pdev)
+			pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
+				PCI_DEVICE_ID_INTEL_I7_NOCORE_ALT, NULL);
+
 		if (likely(pdev)) {
 			bus = pdev->bus->number;
 

commit f237fcf2b7560be33386255042dc11167ca486d5
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Jul 15 19:53:24 2009 -0300

    i7core_edac: some fixes at memory error parser
    
    m->bank is not related to the memory bank but, instead, to the MCA Error
    register bank. Fix it accordingly. While here, improves the comments for
    Nehalem bank.
    
    A later fix is needed, in order to get bank/rank information from MCA
    error log.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 4397a3171c62..67822976992e 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1322,12 +1322,13 @@ static void check_mc_test_err(struct mem_ctl_info *mci, u8 socket)
 /*
  * According with tables E-11 and E-12 of chapter E.3.3 of Intel 64 and IA-32
  * Architectures Software Developer’s Manual Volume 3B.
- * The MCA registers are the following ones:
+ * Nehalem are defined as family 0x06, model 0x1a
+ *
+ * The MCA registers used here are the following ones:
  *     struct mce field	MCA Register
- *     m->status	MSR_IA32_MC0_STATUS
- *     m->addr		MSR_IA32_MC0_ADDR
- *     m->misc		MSR_IA32_MC0_MISC
- *     m->mcgstatus	MSR_IA32_MCG_STATUS
+ *     m->status	MSR_IA32_MC8_STATUS
+ *     m->addr		MSR_IA32_MC8_ADDR
+ *     m->misc		MSR_IA32_MC8_MISC
  * In the case of Nehalem, the error information is masked at .status and .misc
  * fields
  */
@@ -1375,10 +1376,11 @@ static void i7core_mce_output_error(struct mem_ctl_info *mci,
 		err = "unknown";
 	}
 
+	/* FIXME: should convert addr into bank and rank information */
 	msg = kasprintf(GFP_ATOMIC,
-		"%s (addr = 0x%08llx Bank=0x%08x, Dimm=%d, Channel=%d, "
-		"syndrome=0x%08x total error count=%d Err=%d (%s))\n",
-		type, (long long) m->addr, m->bank, dimm, channel,
+		"%s (addr = 0x%08llx Dimm=%d, Channel=%d, "
+		"syndrome=0x%08x, count=%d Err=%d (%s))\n",
+		type, (long long) m->addr, dimm, channel,
 		syndrome, core_err_cnt,errnum, err);
 
 	debugf0("%s", msg);
@@ -1447,6 +1449,10 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 	if (((mce->status & 0xffff) >> 7) != 1)
 		return 0;
 
+	/* Bank 8 registers are the only ones that we know how to handle */
+	if (mce->bank != 8)
+		return 0;
+
 	spin_lock_irqsave(&pvt->mce_lock, flags);
 	if (pvt->mce_count < MCE_LOG_LEN) {
 		memcpy(&pvt->mce_entry[pvt->mce_count], mce, sizeof(*mce));

commit 8a2f118e3a023a4e8cbe56a6e51f7b78fa8c76a0
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Jul 15 19:01:08 2009 -0300

    i7core_edac: decode mcelog error and send it via edac interface
    
    Enriches mcelog error by using the encoded information at MCE status and
    misc registers (IA32_MCx_STATUS, IA32_MCx_MISC).
    
    Some fixes are still needed here, in order to properly fill the EDAC
    fields.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index a93ebdf9c121..4397a3171c62 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -1319,33 +1319,75 @@ static void check_mc_test_err(struct mem_ctl_info *mci, u8 socket)
 	pvt->last_ce_count[socket][0] = new0;
 }
 
+/*
+ * According with tables E-11 and E-12 of chapter E.3.3 of Intel 64 and IA-32
+ * Architectures Software Developer’s Manual Volume 3B.
+ * The MCA registers are the following ones:
+ *     struct mce field	MCA Register
+ *     m->status	MSR_IA32_MC0_STATUS
+ *     m->addr		MSR_IA32_MC0_ADDR
+ *     m->misc		MSR_IA32_MC0_MISC
+ *     m->mcgstatus	MSR_IA32_MCG_STATUS
+ * In the case of Nehalem, the error information is masked at .status and .misc
+ * fields
+ */
 static void i7core_mce_output_error(struct mem_ctl_info *mci,
 				    struct mce *m)
 {
-	debugf0("CPU %d: Machine Check Exception: %16Lx"
-		"Bank %d: %016Lx\n",
-		m->cpu, m->mcgstatus, m->bank, m->status);
-	if (m->ip) {
-		debugf0("RIP%s %02x:<%016Lx>\n",
-			!(m->mcgstatus & MCG_STATUS_EIPV) ? " !INEXACT!" : "",
-			m->cs, m->ip);
+	char *type="NON-FATAL";
+	char *err, *msg;
+	unsigned long error = m->status & 0x1ff0000l;
+	u32 core_err_cnt = (m->status >> 38) && 0x7fff;
+	u32 dimm = (m->misc >> 16) & 0x3;
+	u32 channel = (m->misc >> 18) & 0x3;
+	u32 syndrome = m->misc >> 32;
+	u32 errnum = find_first_bit(&error, 32);
+
+	switch (errnum) {
+	case 16:
+		err = "read ECC error";
+		break;
+	case 17:
+		err = "RAS ECC error";
+		break;
+	case 18:
+		err = "write parity error";
+		break;
+	case 19:
+		err = "redundacy loss";
+		break;
+	case 20:
+		err = "reserved";
+		break;
+	case 21:
+		err = "memory range error";
+		break;
+	case 22:
+		err = "RTID out of range";
+		break;
+	case 23:
+		err = "address parity error";
+		break;
+	case 24:
+		err = "byte enable parity error";
+		break;
+	default:
+		err = "unknown";
 	}
-	printk(KERN_EMERG "TSC %llx ", m->tsc);
-	if (m->addr)
-		printk("ADDR %llx ", m->addr);
-	if (m->misc)
-		printk("MISC %llx ", m->misc);
 
-#if 0
-	snprintf(msg, sizeof(msg),
-		"%s (Branch=%d DRAM-Bank=%d Buffer ID = %d RDWR=%s "
-		"RAS=%d CAS=%d %s Err=0x%lx (%s))",
-		type, branch >> 1, bank, buf_id, rdwr_str(rdwr), ras, cas,
-		type, allErrors, error_name[errnum]);
+	msg = kasprintf(GFP_ATOMIC,
+		"%s (addr = 0x%08llx Bank=0x%08x, Dimm=%d, Channel=%d, "
+		"syndrome=0x%08x total error count=%d Err=%d (%s))\n",
+		type, (long long) m->addr, m->bank, dimm, channel,
+		syndrome, core_err_cnt,errnum, err);
+
+	debugf0("%s", msg);
 
 	/* Call the helper to output message */
-	edac_mc_handle_fbd_ue(mci, rank, channel, channel + 1, msg);
-#endif
+	edac_mc_handle_fbd_ue(mci, 0 /* FIXME: should be rank here */,
+			      0, 0 /* FIXME: should be channel here */, msg);
+
+	kfree(msg);
 }
 
 /*
@@ -1398,6 +1440,13 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 
 	debugf0(__FILE__ ": %s()\n", __func__);
 
+	/*
+	 * Just let mcelog handle it if the error is
+	 * outside the memory controller
+	 */
+	if (((mce->status & 0xffff) >> 7) != 1)
+		return 0;
+
 	spin_lock_irqsave(&pvt->mce_lock, flags);
 	if (pvt->mce_count < MCE_LOG_LEN) {
 		memcpy(&pvt->mce_entry[pvt->mce_count], mce, sizeof(*mce));
@@ -1406,8 +1455,7 @@ static int i7core_mce_check_error(void *priv, struct mce *mce)
 	spin_unlock_irqrestore(&pvt->mce_lock, flags);
 
 	/* Advice mcelog that the error were handled */
-//	return 1;
-	return 0; // Let's duplicate the log
+	return 1;
 }
 
 /*

commit ba6c5c62eeb877da638e43f1282f778432142eec
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Jul 15 09:02:32 2009 -0300

    i7core_edac: maps all sockets as if ther are one MC controller
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 69eacc1b50d7..a93ebdf9c121 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -409,12 +409,12 @@ static int i7core_get_active_channels(u8 socket, unsigned *channels,
 	return 0;
 }
 
-static int get_dimm_config(struct mem_ctl_info *mci, u8 socket)
+static int get_dimm_config(struct mem_ctl_info *mci, int *csrow, u8 socket)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	struct csrow_info *csr;
 	struct pci_dev *pdev;
-	int i, j, csrow = 0;
+	int i, j;
 	unsigned long last_page = 0;
 	enum edac_type mode;
 	enum mem_type mtype;
@@ -534,7 +534,7 @@ static int get_dimm_config(struct mem_ctl_info *mci, u8 socket)
 			npages = size << (20 - PAGE_SHIFT);
 #endif
 
-			csr = &mci->csrows[csrow];
+			csr = &mci->csrows[*csrow];
 			csr->first_page = last_page + 1;
 			last_page += npages;
 			csr->last_page = last_page;
@@ -542,7 +542,7 @@ static int get_dimm_config(struct mem_ctl_info *mci, u8 socket)
 
 			csr->page_mask = 0;
 			csr->grain = 8;
-			csr->csrow_idx = csrow;
+			csr->csrow_idx = *csrow;
 			csr->nr_channels = 1;
 
 			csr->channels[0].chan_idx = i;
@@ -565,7 +565,7 @@ static int get_dimm_config(struct mem_ctl_info *mci, u8 socket)
 			csr->edac_mode = mode;
 			csr->mtype = mtype;
 
-			csrow++;
+			(*csrow)++;
 		}
 
 		pci_read_config_dword(pdev, MC_SAG_CH_0, &value[0]);
@@ -1424,6 +1424,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	struct i7core_pvt *pvt;
 	int num_channels = 0;
 	int num_csrows = 0;
+	int csrow = 0;
 	int dev_idx = id->driver_data;
 	int rc, i;
 	u8 sockets;
@@ -1495,7 +1496,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 
 	/* Get dimm basic config */
 	for (i = 0; i < sockets; i++)
-		get_dimm_config(mci, i);
+		get_dimm_config(mci, &csrow, i);
 
 	/* add this new MC control structure to EDAC's list of MCs */
 	if (unlikely(edac_mc_add_mc(mci))) {

commit 67166af4abc11d9c0deb497ebe0b562f69c71942
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Wed Jul 15 06:56:23 2009 -0300

    i7core_edac: add support for more than one MC socket
    
    Some Nehalem architectures have more than one MC socket. Socket 0 is
    located at bus 255.
    
    Currently, it is using up to 2 sockets, but increasing it to a larger
    number is just a matter of increasing MAX_SOCKETS definition.
    
    This seems to be required for properly support of Xeon 55xx.
    
    Still needs testing with Xeon 55xx.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index eec0c13c0205..69eacc1b50d7 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -155,6 +155,7 @@
 
 #define NUM_CHANS 3
 #define MAX_DIMMS 3		/* Max DIMMS per channel */
+#define NUM_SOCKETS 2		/* Max number of MC sockets */
 #define MAX_MCR_FUNC  4
 #define MAX_CHAN_FUNC 3
 
@@ -169,6 +170,7 @@ struct i7core_info {
 struct i7core_inject {
 	int	enable;
 
+	u8	socket;
 	u32	section;
 	u32	type;
 	u32	eccmask;
@@ -186,21 +188,25 @@ struct pci_id_descr {
 	int		dev;
 	int		func;
 	int 		dev_id;
-	struct pci_dev	*pdev;
+	struct pci_dev	*pdev[NUM_SOCKETS];
 };
 
 struct i7core_pvt {
-	struct pci_dev		*pci_noncore;
-	struct pci_dev		*pci_mcr[MAX_MCR_FUNC + 1];
-	struct pci_dev		*pci_ch[NUM_CHANS][MAX_CHAN_FUNC + 1];
+	struct pci_dev	*pci_noncore[NUM_SOCKETS];
+	struct pci_dev	*pci_mcr[NUM_SOCKETS][MAX_MCR_FUNC + 1];
+	struct pci_dev	*pci_ch[NUM_SOCKETS][NUM_CHANS][MAX_CHAN_FUNC + 1];
+
 	struct i7core_info	info;
 	struct i7core_inject	inject;
-	struct i7core_channel	channel[NUM_CHANS];
+	struct i7core_channel	channel[NUM_SOCKETS][NUM_CHANS];
+
+	int			sockets; /* Number of sockets */
 	int			channels; /* Number of active channels */
 
-	int		ce_count_available;
-	unsigned long	ce_count[MAX_DIMMS];	/* ECC corrected errors counts per dimm */
-	int		last_ce_count[MAX_DIMMS];
+	int		ce_count_available[NUM_SOCKETS];
+			/* ECC corrected errors counts per dimm */
+	unsigned long	ce_count[NUM_SOCKETS][MAX_DIMMS];
+	int		last_ce_count[NUM_SOCKETS][MAX_DIMMS];
 
 	/* mcelog glue */
 	struct edac_mce		edac_mce;
@@ -324,24 +330,26 @@ static inline int numcol(u32 col)
 /****************************************************************************
 			Memory check routines
  ****************************************************************************/
-static struct pci_dev *get_pdev_slot_func(int slot, int func)
+static struct pci_dev *get_pdev_slot_func(u8 socket, unsigned slot,
+					  unsigned func)
 {
 	int i;
 
 	for (i = 0; i < N_DEVS; i++) {
-		if (!pci_devs[i].pdev)
+		if (!pci_devs[i].pdev[socket])
 			continue;
 
-		if (PCI_SLOT(pci_devs[i].pdev->devfn) == slot &&
-		    PCI_FUNC(pci_devs[i].pdev->devfn) == func) {
-			return pci_devs[i].pdev;
+		if (PCI_SLOT(pci_devs[i].pdev[socket]->devfn) == slot &&
+		    PCI_FUNC(pci_devs[i].pdev[socket]->devfn) == func) {
+			return pci_devs[i].pdev[socket];
 		}
 	}
 
 	return NULL;
 }
 
-static int i7core_get_active_channels(int *channels, int *csrows)
+static int i7core_get_active_channels(u8 socket, unsigned *channels,
+				      unsigned *csrows)
 {
 	struct pci_dev *pdev = NULL;
 	int i, j;
@@ -350,9 +358,10 @@ static int i7core_get_active_channels(int *channels, int *csrows)
 	*channels = 0;
 	*csrows = 0;
 
-	pdev = get_pdev_slot_func(3, 0);
+	pdev = get_pdev_slot_func(socket, 3, 0);
 	if (!pdev) {
-		i7core_printk(KERN_ERR, "Couldn't find fn 3.0!!!\n");
+		i7core_printk(KERN_ERR, "Couldn't find socket %d fn 3.0!!!\n",
+			      socket);
 		return -ENODEV;
 	}
 
@@ -370,10 +379,11 @@ static int i7core_get_active_channels(int *channels, int *csrows)
 		if (status & (1 << i))
 			continue;
 
-		pdev = get_pdev_slot_func(i + 4, 1);
+		pdev = get_pdev_slot_func(socket, i + 4, 1);
 		if (!pdev) {
-			i7core_printk(KERN_ERR, "Couldn't find fn %d.%d!!!\n",
-				      i + 4, 1);
+			i7core_printk(KERN_ERR, "Couldn't find socket %d "
+						"fn %d.%d!!!\n",
+						socket, i + 4, 1);
 			return -ENODEV;
 		}
 		/* Devices 4-6 function 1 */
@@ -393,12 +403,13 @@ static int i7core_get_active_channels(int *channels, int *csrows)
 		}
 	}
 
-	debugf0("Number of active channels: %d\n", *channels);
+	debugf0("Number of active channels on socked %d: %d\n",
+		socket, *channels);
 
 	return 0;
 }
 
-static int get_dimm_config(struct mem_ctl_info *mci)
+static int get_dimm_config(struct mem_ctl_info *mci, u8 socket)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	struct csrow_info *csr;
@@ -409,7 +420,7 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 	enum mem_type mtype;
 
 	/* Get data from the MC register, function 0 */
-	pdev = pvt->pci_mcr[0];
+	pdev = pvt->pci_mcr[socket][0];
 	if (!pdev)
 		return -ENODEV;
 
@@ -458,10 +469,11 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 		}
 
 		/* Devices 4-6 function 0 */
-		pci_read_config_dword(pvt->pci_ch[i][0],
+		pci_read_config_dword(pvt->pci_ch[socket][i][0],
 				MC_CHANNEL_DIMM_INIT_PARAMS, &data);
 
-		pvt->channel[i].ranks = (data & QUAD_RANK_PRESENT) ? 4 : 2;
+		pvt->channel[socket][i].ranks = (data & QUAD_RANK_PRESENT) ?
+						4 : 2;
 
 		if (data & REGISTERED_DIMM)
 			mtype = MEM_RDDR3;
@@ -477,11 +489,11 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 #endif
 
 		/* Devices 4-6 function 1 */
-		pci_read_config_dword(pvt->pci_ch[i][1],
+		pci_read_config_dword(pvt->pci_ch[socket][i][1],
 				MC_DOD_CH_DIMM0, &dimm_dod[0]);
-		pci_read_config_dword(pvt->pci_ch[i][1],
+		pci_read_config_dword(pvt->pci_ch[socket][i][1],
 				MC_DOD_CH_DIMM1, &dimm_dod[1]);
-		pci_read_config_dword(pvt->pci_ch[i][1],
+		pci_read_config_dword(pvt->pci_ch[socket][i][1],
 				MC_DOD_CH_DIMM2, &dimm_dod[2]);
 
 		debugf0("Ch%d phy rd%d, wr%d (0x%08x): "
@@ -489,7 +501,7 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 			i,
 			RDLCH(pvt->info.ch_map, i), WRLCH(pvt->info.ch_map, i),
 			data,
-			pvt->channel[i].ranks,
+			pvt->channel[socket][i].ranks,
 			(data & REGISTERED_DIMM) ? 'R' : 'U');
 
 		for (j = 0; j < 3; j++) {
@@ -507,7 +519,7 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 			/* DDR3 has 8 I/O banks */
 			size = (rows * cols * banks * ranks) >> (20 - 3);
 
-			pvt->channel[i].dimms++;
+			pvt->channel[socket][i].dimms++;
 
 			debugf0("\tdimm %d (0x%08x) %d Mb offset: %x, "
 				"numbank: %d,\n\t\t"
@@ -592,15 +604,42 @@ static int disable_inject(struct mem_ctl_info *mci)
 
 	pvt->inject.enable = 0;
 
-	if (!pvt->pci_ch[pvt->inject.channel][0])
+	if (!pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0])
 		return -ENODEV;
 
-	pci_write_config_dword(pvt->pci_ch[pvt->inject.channel][0],
+	pci_write_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
 				MC_CHANNEL_ERROR_MASK, 0);
 
 	return 0;
 }
 
+/*
+ * i7core inject inject.socket
+ *
+ *	accept and store error injection inject.socket value
+ */
+static ssize_t i7core_inject_socket_store(struct mem_ctl_info *mci,
+					   const char *data, size_t count)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	unsigned long value;
+	int rc;
+
+	rc = strict_strtoul(data, 10, &value);
+	if ((rc < 0) || (value > pvt->sockets))
+		return 0;
+
+	pvt->inject.section = (u32) value;
+	return count;
+}
+
+static ssize_t i7core_inject_socket_show(struct mem_ctl_info *mci,
+					      char *data)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	return sprintf(data, "%d\n", pvt->inject.socket);
+}
+
 /*
  * i7core inject inject.section
  *
@@ -838,7 +877,7 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 	int  rc;
 	long enable;
 
-	if (!pvt->pci_ch[pvt->inject.channel][0])
+	if (!pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0])
 		return 0;
 
 	rc = strict_strtoul(data, 10, &enable);
@@ -856,7 +895,7 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 	if (pvt->inject.dimm < 0)
 		mask |= 1L << 41;
 	else {
-		if (pvt->channel[pvt->inject.channel].dimms > 2)
+		if (pvt->channel[pvt->inject.socket][pvt->inject.channel].dimms > 2)
 			mask |= (pvt->inject.dimm & 0x3L) << 35;
 		else
 			mask |= (pvt->inject.dimm & 0x1L) << 36;
@@ -866,7 +905,7 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 	if (pvt->inject.rank < 0)
 		mask |= 1L << 40;
 	else {
-		if (pvt->channel[pvt->inject.channel].dimms > 2)
+		if (pvt->channel[pvt->inject.socket][pvt->inject.channel].dimms > 2)
 			mask |= (pvt->inject.rank & 0x1L) << 34;
 		else
 			mask |= (pvt->inject.rank & 0x3L) << 34;
@@ -891,38 +930,41 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 		mask |= (pvt->inject.col & 0x3fffL);
 
 	/* Unlock writes to registers */
-	pci_write_config_dword(pvt->pci_noncore, MC_CFG_CONTROL, 0x2);
+	pci_write_config_dword(pvt->pci_noncore[pvt->inject.socket],
+			       MC_CFG_CONTROL, 0x2);
 	msleep(100);
 
 	/* Zeroes error count registers */
-	pci_write_config_dword(pvt->pci_mcr[4], MC_TEST_ERR_RCV1, 0);
-	pci_write_config_dword(pvt->pci_mcr[4], MC_TEST_ERR_RCV0, 0);
-	pvt->ce_count_available = 0;
+	pci_write_config_dword(pvt->pci_mcr[pvt->inject.socket][4],
+			       MC_TEST_ERR_RCV1, 0);
+	pci_write_config_dword(pvt->pci_mcr[pvt->inject.socket][4],
+			       MC_TEST_ERR_RCV0, 0);
+	pvt->ce_count_available[pvt->inject.socket] = 0;
 
 
 #if USE_QWORD
-	pci_write_config_qword(pvt->pci_ch[pvt->inject.channel][0],
+	pci_write_config_qword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
 			       MC_CHANNEL_ADDR_MATCH, mask);
 #else
-	pci_write_config_dword(pvt->pci_ch[pvt->inject.channel][0],
+	pci_write_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
 			       MC_CHANNEL_ADDR_MATCH, mask);
-	pci_write_config_dword(pvt->pci_ch[pvt->inject.channel][0],
+	pci_write_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
 			       MC_CHANNEL_ADDR_MATCH + 4, mask >> 32L);
 #endif
 
 #if 1
 #if USE_QWORD
 	u64 rdmask;
-	pci_read_config_qword(pvt->pci_ch[pvt->inject.channel][0],
+	pci_read_config_qword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
 			       MC_CHANNEL_ADDR_MATCH, &rdmask);
 	debugf0("Inject addr match write 0x%016llx, read: 0x%016llx\n",
 		mask, rdmask);
 #else
 	u32 rdmask1, rdmask2;
 
-	pci_read_config_dword(pvt->pci_ch[pvt->inject.channel][0],
+	pci_read_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
 			       MC_CHANNEL_ADDR_MATCH, &rdmask1);
-	pci_read_config_dword(pvt->pci_ch[pvt->inject.channel][0],
+	pci_read_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
 			       MC_CHANNEL_ADDR_MATCH + 4, &rdmask2);
 
 	debugf0("Inject addr match write 0x%016llx, read: 0x%08x 0x%08x\n",
@@ -930,7 +972,7 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 #endif
 #endif
 
-	pci_write_config_dword(pvt->pci_ch[pvt->inject.channel][0],
+	pci_write_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
 			       MC_CHANNEL_ERROR_MASK, pvt->inject.eccmask);
 
 	/*
@@ -944,7 +986,7 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 		     (pvt->inject.section & 0x3) << 1 |
 		     (pvt->inject.type & 0x6) << (3 - 1);
 
-	pci_write_config_dword(pvt->pci_ch[pvt->inject.channel][0],
+	pci_write_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
 			       MC_CHANNEL_ERROR_MASK, injectmask);
 
 #if 0
@@ -965,7 +1007,7 @@ static ssize_t i7core_inject_enable_show(struct mem_ctl_info *mci,
 	struct i7core_pvt *pvt = mci->pvt_info;
 	u32 injectmask;
 
-	pci_read_config_dword(pvt->pci_ch[pvt->inject.channel][0],
+	pci_read_config_dword(pvt->pci_ch[pvt->inject.socket][pvt->inject.channel][0],
 			       MC_CHANNEL_ERROR_MASK, &injectmask);
 
 	debugf0("Inject error read: 0x%018x\n", injectmask);
@@ -978,23 +1020,38 @@ static ssize_t i7core_inject_enable_show(struct mem_ctl_info *mci,
 
 static ssize_t i7core_ce_regs_show(struct mem_ctl_info *mci, char *data)
 {
+	unsigned i, count, total = 0;
 	struct i7core_pvt *pvt = mci->pvt_info;
 
-	if (!pvt->ce_count_available)
-		return sprintf(data, "unavailable\n");
+	for (i = 0; i < pvt->sockets; i++) {
+		if (!pvt->ce_count_available[i])
+			count = sprintf(data, "socket 0 data unavailable\n");
+		else
+			count = sprintf(data, "socket %d, dimm0: %lu\n"
+					      "dimm1: %lu\ndimm2: %lu\n",
+					i,
+					pvt->ce_count[i][0],
+					pvt->ce_count[i][1],
+					pvt->ce_count[i][2]);
+		data  += count;
+		total += count;
+	}
 
-	return sprintf(data, "dimm0: %lu\ndimm1: %lu\ndimm2: %lu\n",
-			pvt->ce_count[0],
-			pvt->ce_count[1],
-			pvt->ce_count[2]);
+	return total;
 }
 
 /*
  * Sysfs struct
  */
 static struct mcidev_sysfs_attribute i7core_inj_attrs[] = {
-
 	{
+		.attr = {
+			.name = "inject_socket",
+			.mode = (S_IRUGO | S_IWUSR)
+		},
+		.show  = i7core_inject_socket_show,
+		.store = i7core_inject_socket_store,
+	}, {
 		.attr = {
 			.name = "inject_section",
 			.mode = (S_IRUGO | S_IWUSR)
@@ -1049,10 +1106,11 @@ static struct mcidev_sysfs_attribute i7core_inj_attrs[] = {
  */
 static void i7core_put_devices(void)
 {
-	int i;
+	int i, j;
 
-	for (i = 0; i < N_DEVS; i++)
-		pci_dev_put(pci_devs[i].pdev);
+	for (i = 0; i < NUM_SOCKETS; i++)
+		for (j = 0; j < N_DEVS; j++)
+			pci_dev_put(pci_devs[j].pdev[i]);
 }
 
 /*
@@ -1065,6 +1123,8 @@ static int i7core_get_devices(void)
 {
 	int rc, i;
 	struct pci_dev *pdev = NULL;
+	u8 bus = 0;
+	u8 socket = 0;
 
 	for (i = 0; i < N_DEVS; i++) {
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
@@ -1078,14 +1138,32 @@ static int i7core_get_devices(void)
 						pci_devs[i].dev_id, NULL);
 		}
 
-		if (likely(pdev))
-			pci_devs[i].pdev = pdev;
-		else {
+		if (likely(pdev)) {
+			bus = pdev->bus->number;
+
+			if (bus == 0x3f)
+				socket = 0;
+			else
+				socket = 255 - bus;
+
+			if (socket >= NUM_SOCKETS) {
+				i7core_printk(KERN_ERR,
+					"Found unexpected socket for "
+					"dev %02x:%02x.%d PCI ID %04x:%04x\n",
+					bus, pci_devs[i].dev, pci_devs[i].func,
+					PCI_VENDOR_ID_INTEL, pci_devs[i].dev_id);
+
+				rc = -ENODEV;
+				goto error;
+			}
+
+			pci_devs[i].pdev[socket] = pdev;
+		} else {
 			i7core_printk(KERN_ERR,
-				"Device not found: PCI ID %04x:%04x "
-				"(dev %d, func %d)\n",
-				PCI_VENDOR_ID_INTEL, pci_devs[i].dev_id,
-				pci_devs[i].dev, pci_devs[i].func);
+				"Device not found: "
+				"dev %02x:%02x.%d PCI ID %04x:%04x\n",
+				bus, pci_devs[i].dev, pci_devs[i].func,
+				PCI_VENDOR_ID_INTEL, pci_devs[i].dev_id);
 
 			/* Dev 3 function 2 only exists on chips with RDIMMs */
 			if ((pci_devs[i].dev == 3) && (pci_devs[i].func == 2))
@@ -1121,9 +1199,10 @@ static int i7core_get_devices(void)
 		}
 
 		i7core_printk(KERN_INFO,
-				"Registered device %0x:%0x fn %d.%d\n",
-				PCI_VENDOR_ID_INTEL, pci_devs[i].dev_id,
-				PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
+				"Registered socket %d "
+				"dev %02x:%02x.%d PCI ID %04x:%04x\n",
+				socket, bus, pci_devs[i].dev, pci_devs[i].func,
+				PCI_VENDOR_ID_INTEL, pci_devs[i].dev_id);
 	}
 
 	return 0;
@@ -1137,30 +1216,33 @@ static int mci_bind_devs(struct mem_ctl_info *mci)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	struct pci_dev *pdev;
-	int i, func, slot;
+	int i, j, func, slot;
 
-	for (i = 0; i < N_DEVS; i++) {
-		pdev = pci_devs[i].pdev;
-		if (!pdev)
-			continue;
+	for (i = 0; i < pvt->sockets; i++) {
+		for (j = 0; j < N_DEVS; j++) {
+			pdev = pci_devs[j].pdev[i];
+			if (!pdev)
+				continue;
 
-		func = PCI_FUNC(pdev->devfn);
-		slot = PCI_SLOT(pdev->devfn);
-		if (slot == 3) {
-			if (unlikely(func > MAX_MCR_FUNC))
-				goto error;
-			pvt->pci_mcr[func] = pdev;
-		} else if (likely(slot >= 4 && slot < 4 + NUM_CHANS)) {
-			if (unlikely(func > MAX_CHAN_FUNC))
+			func = PCI_FUNC(pdev->devfn);
+			slot = PCI_SLOT(pdev->devfn);
+			if (slot == 3) {
+				if (unlikely(func > MAX_MCR_FUNC))
+					goto error;
+				pvt->pci_mcr[i][func] = pdev;
+			} else if (likely(slot >= 4 && slot < 4 + NUM_CHANS)) {
+				if (unlikely(func > MAX_CHAN_FUNC))
+					goto error;
+				pvt->pci_ch[i][slot - 4][func] = pdev;
+			} else if (!slot && !func)
+				pvt->pci_noncore[i] = pdev;
+			else
 				goto error;
-			pvt->pci_ch[slot - 4][func] = pdev;
-		} else if (!slot && !func)
-			pvt->pci_noncore = pdev;
-		else
-			goto error;
 
-		debugf0("Associated fn %d.%d, dev = %p\n",
-			PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn), pdev);
+			debugf0("Associated fn %d.%d, dev = %p, socket %d\n",
+				PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),
+				pdev, i);
+		}
 	}
 
 	return 0;
@@ -1182,20 +1264,20 @@ static int mci_bind_devs(struct mem_ctl_info *mci)
  * also available at:
  * 	http://www.arrownac.com/manufacturers/intel/s/nehalem/5500-datasheet-v2.pdf
  */
-static void check_mc_test_err(struct mem_ctl_info *mci)
+static void check_mc_test_err(struct mem_ctl_info *mci, u8 socket)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	u32 rcv1, rcv0;
 	int new0, new1, new2;
 
-	if (!pvt->pci_mcr[4]) {
+	if (!pvt->pci_mcr[socket][4]) {
 		debugf0("%s MCR registers not found\n",__func__);
 		return;
 	}
 
 	/* Corrected error reads */
-	pci_read_config_dword(pvt->pci_mcr[4], MC_TEST_ERR_RCV1, &rcv1);
-	pci_read_config_dword(pvt->pci_mcr[4], MC_TEST_ERR_RCV0, &rcv0);
+	pci_read_config_dword(pvt->pci_mcr[socket][4], MC_TEST_ERR_RCV1, &rcv1);
+	pci_read_config_dword(pvt->pci_mcr[socket][4], MC_TEST_ERR_RCV0, &rcv0);
 
 	/* Store the new values */
 	new2 = DIMM2_COR_ERR(rcv1);
@@ -1209,32 +1291,32 @@ static void check_mc_test_err(struct mem_ctl_info *mci)
 #endif
 
 	/* Updates CE counters if it is not the first time here */
-	if (pvt->ce_count_available) {
+	if (pvt->ce_count_available[socket]) {
 		/* Updates CE counters */
 		int add0, add1, add2;
 
-		add2 = new2 - pvt->last_ce_count[2];
-		add1 = new1 - pvt->last_ce_count[1];
-		add0 = new0 - pvt->last_ce_count[0];
+		add2 = new2 - pvt->last_ce_count[socket][2];
+		add1 = new1 - pvt->last_ce_count[socket][1];
+		add0 = new0 - pvt->last_ce_count[socket][0];
 
 		if (add2 < 0)
 			add2 += 0x7fff;
-		pvt->ce_count[2] += add2;
+		pvt->ce_count[socket][2] += add2;
 
 		if (add1 < 0)
 			add1 += 0x7fff;
-		pvt->ce_count[1] += add1;
+		pvt->ce_count[socket][1] += add1;
 
 		if (add0 < 0)
 			add0 += 0x7fff;
-		pvt->ce_count[0] += add0;
+		pvt->ce_count[socket][0] += add0;
 	} else
-		pvt->ce_count_available = 1;
+		pvt->ce_count_available[socket] = 1;
 
 	/* Store the new values */
-	pvt->last_ce_count[2] = new2;
-	pvt->last_ce_count[1] = new1;
-	pvt->last_ce_count[0] = new0;
+	pvt->last_ce_count[socket][2] = new2;
+	pvt->last_ce_count[socket][1] = new1;
+	pvt->last_ce_count[socket][0] = new0;
 }
 
 static void i7core_mce_output_error(struct mem_ctl_info *mci,
@@ -1299,7 +1381,8 @@ static void i7core_check_error(struct mem_ctl_info *mci)
 	kfree(m);
 
 	/* check memory count errors */
-	check_mc_test_err(mci);
+	for (i = 0; i < pvt->sockets; i++)
+		check_mc_test_err(mci, i);
 }
 
 /*
@@ -1339,10 +1422,11 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 {
 	struct mem_ctl_info *mci;
 	struct i7core_pvt *pvt;
-	int num_channels;
-	int num_csrows;
+	int num_channels = 0;
+	int num_csrows = 0;
 	int dev_idx = id->driver_data;
-	int rc;
+	int rc, i;
+	u8 sockets;
 
 	if (unlikely(dev_idx >= ARRAY_SIZE(i7core_devs)))
 		return -EINVAL;
@@ -1352,10 +1436,25 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	if (unlikely(rc < 0))
 		return rc;
 
-	/* Check the number of active and not disabled channels */
-	rc = i7core_get_active_channels(&num_channels, &num_csrows);
-	if (unlikely(rc < 0))
-		goto fail0;
+	sockets = 1;
+	for (i = NUM_SOCKETS - 1; i > 0; i--)
+		if (pci_devs[0].pdev[i]) {
+			sockets = i + 1;
+			break;
+		}
+
+	for (i = 0; i < sockets; i++) {
+		int channels;
+		int csrows;
+
+		/* Check the number of active and not disabled channels */
+		rc = i7core_get_active_channels(i, &channels, &csrows);
+		if (unlikely(rc < 0))
+			goto fail0;
+
+		num_channels += channels;
+		num_csrows += csrows;
+	}
 
 	/* allocate a new MC control structure */
 	mci = edac_mc_alloc(sizeof(*pvt), num_csrows, num_channels, 0);
@@ -1367,11 +1466,11 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	debugf0("MC: " __FILE__ ": %s(): mci = %p\n", __func__, mci);
 
 	mci->dev = &pdev->dev;	/* record ptr to the generic device */
-
 	pvt = mci->pvt_info;
 	memset(pvt, 0, sizeof(*pvt));
-
+	pvt->sockets = sockets;
 	mci->mc_idx = 0;
+
 	/*
 	 * FIXME: how to handle RDDR3 at MCI level? It is possible to have
 	 * Mixed RDDR3/UDDR3 with Nehalem, provided that they are on different
@@ -1395,7 +1494,8 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 		goto fail1;
 
 	/* Get dimm basic config */
-	get_dimm_config(mci);
+	for (i = 0; i < sockets; i++)
+		get_dimm_config(mci, i);
 
 	/* add this new MC control structure to EDAC's list of MCs */
 	if (unlikely(edac_mc_add_mc(mci))) {

commit d1fd4fb69eeeb7db0693df58b9116db498d5bfe1
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Fri Jul 10 18:39:53 2009 -0300

    i7core_edac: Add a code to probe Xeon 55xx bus
    
    This code changes the detection procedure of i7core_edac. Instead of
    directly probing for MC registers, it probes for another register found
    on Nehalem. If found, it tries to pick the first MC PCI BUS. This should
    work fine with Xeon 35xx, but, on Xeon 55xx, this is at bus 254 and 255
    that are not properly detected by the non-legacy PCI methods.
    
    The new detection code scans specifically at buses 254 and 255 for the
    Xeon 55xx devices.
    
    This code has not tested yet. After working, a change at the code will
    be needed, since the i7core is not yet ready for working with 2 sets of
    MC.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 26cd5c924d56..eec0c13c0205 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -221,15 +221,15 @@ struct i7core_dev_info {
 	.dev_id = (device_id)
 
 struct pci_id_descr pci_devs[] = {
+		/* Generic Non-core registers */
+	{ PCI_DESCR(0, 0, PCI_DEVICE_ID_INTEL_I7_NOCORE)  },
+
 		/* Memory controller */
 	{ PCI_DESCR(3, 0, PCI_DEVICE_ID_INTEL_I7_MCR)     },
 	{ PCI_DESCR(3, 1, PCI_DEVICE_ID_INTEL_I7_MC_TAD)  },
 	{ PCI_DESCR(3, 2, PCI_DEVICE_ID_INTEL_I7_MC_RAS)  }, /* if RDIMM is supported */
 	{ PCI_DESCR(3, 4, PCI_DEVICE_ID_INTEL_I7_MC_TEST) },
 
-		/* Generic Non-core registers */
-	{ PCI_DESCR(0, 0, PCI_DEVICE_ID_INTEL_I7_NOCORE)  },
-
 		/* Channel 0 */
 	{ PCI_DESCR(4, 0, PCI_DEVICE_ID_INTEL_I7_MC_CH0_CTRL) },
 	{ PCI_DESCR(4, 1, PCI_DEVICE_ID_INTEL_I7_MC_CH0_ADDR) },
@@ -255,7 +255,7 @@ struct pci_id_descr pci_devs[] = {
  * This should match the first device at pci_devs table
  */
 static const struct pci_device_id i7core_pci_tbl[] __devinitdata = {
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I7_MCR)},
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_X58_HUB_MGMT)},
 	{0,}			/* 0 terminated list. */
 };
 
@@ -1069,6 +1069,15 @@ static int i7core_get_devices(void)
 	for (i = 0; i < N_DEVS; i++) {
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 					pci_devs[i].dev_id, NULL);
+
+		if (!pdev && !i) {
+			pcibios_scan_specific_bus(254);
+			pcibios_scan_specific_bus(255);
+
+			pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
+						pci_devs[i].dev_id, NULL);
+		}
+
 		if (likely(pdev))
 			pci_devs[i].pdev = pdev;
 		else {

commit e9bd2e73793bf0f7fcd8f94b532bb8f5c5b44171
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Jul 9 22:14:35 2009 -0300

    i7core_edac: Adds write unlock to MC registers
    
    The public Intel Xeon 5500 volume 2 datasheet describes, on page 53,
    session 2.6.7 a register that can lock/unlock Memory Controller the
    configuration register, called MC_CFG_CONTROL.
    
    Adds support for it in the hope that software error injection would
    work. With my tests with Xeon 35xx, there's still something missing.
    With a program that does sequencial bit writes at dev 0.0, sometimes, it
    produces error injection, after unblocking the MC_CFG_CONTROL (and,
    sometimes, it just locks my testing machine).
    
    I'll try later to discover by trial and error what's the register that
    solves this issue on Xeon 35xx.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 3c7bb5f405f6..26cd5c924d56 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -33,7 +33,7 @@
 #include "edac_core.h"
 
 /* To use the new pci_[read/write]_config_qword instead of two dword */
-#define USE_QWORD 1
+#define USE_QWORD 0
 
 /*
  * Alter this version for the module when modifications are made
@@ -58,6 +58,10 @@
  * i7core Memory Controller Registers
  */
 
+	/* OFFSETS for Device 0 Function 0 */
+
+#define MC_CFG_CONTROL	0x90
+
 	/* OFFSETS for Device 3 Function 0 */
 
 #define MC_CONTROL	0x48
@@ -186,6 +190,7 @@ struct pci_id_descr {
 };
 
 struct i7core_pvt {
+	struct pci_dev		*pci_noncore;
 	struct pci_dev		*pci_mcr[MAX_MCR_FUNC + 1];
 	struct pci_dev		*pci_ch[NUM_CHANS][MAX_CHAN_FUNC + 1];
 	struct i7core_info	info;
@@ -222,6 +227,9 @@ struct pci_id_descr pci_devs[] = {
 	{ PCI_DESCR(3, 2, PCI_DEVICE_ID_INTEL_I7_MC_RAS)  }, /* if RDIMM is supported */
 	{ PCI_DESCR(3, 4, PCI_DEVICE_ID_INTEL_I7_MC_TEST) },
 
+		/* Generic Non-core registers */
+	{ PCI_DESCR(0, 0, PCI_DEVICE_ID_INTEL_I7_NOCORE)  },
+
 		/* Channel 0 */
 	{ PCI_DESCR(4, 0, PCI_DEVICE_ID_INTEL_I7_MC_CH0_CTRL) },
 	{ PCI_DESCR(4, 1, PCI_DEVICE_ID_INTEL_I7_MC_CH0_ADDR) },
@@ -882,6 +890,16 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 	else
 		mask |= (pvt->inject.col & 0x3fffL);
 
+	/* Unlock writes to registers */
+	pci_write_config_dword(pvt->pci_noncore, MC_CFG_CONTROL, 0x2);
+	msleep(100);
+
+	/* Zeroes error count registers */
+	pci_write_config_dword(pvt->pci_mcr[4], MC_TEST_ERR_RCV1, 0);
+	pci_write_config_dword(pvt->pci_mcr[4], MC_TEST_ERR_RCV0, 0);
+	pvt->ce_count_available = 0;
+
+
 #if USE_QWORD
 	pci_write_config_qword(pvt->pci_ch[pvt->inject.channel][0],
 			       MC_CHANNEL_ADDR_MATCH, mask);
@@ -929,12 +947,15 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 	pci_write_config_dword(pvt->pci_ch[pvt->inject.channel][0],
 			       MC_CHANNEL_ERROR_MASK, injectmask);
 
+#if 0
+	/* lock writes to registers */
+	pci_write_config_dword(pvt->pci_noncore, MC_CFG_CONTROL, 0);
+#endif
 	debugf0("Error inject addr match 0x%016llx, ecc 0x%08x,"
 		" inject 0x%08x\n",
 		mask, pvt->inject.eccmask, injectmask);
 
 
-
 	return count;
 }
 
@@ -1124,12 +1145,15 @@ static int mci_bind_devs(struct mem_ctl_info *mci)
 			if (unlikely(func > MAX_CHAN_FUNC))
 				goto error;
 			pvt->pci_ch[slot - 4][func] = pdev;
-		} else
+		} else if (!slot && !func)
+			pvt->pci_noncore = pdev;
+		else
 			goto error;
 
 		debugf0("Associated fn %d.%d, dev = %p\n",
 			PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn), pdev);
 	}
+
 	return 0;
 
 error:

commit d5381642ab01b084787925acdf26b5524d434476
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Thu Jul 9 22:06:41 2009 -0300

    i7core_edac: Add edac_mce glue
    
    Adds a glue code to allow i7core to work with mcelog. With the glue,
    i7core registers itself on edac_mce. At mce, when an error is detected,
    it calls all registered drivers (in this case, i7core), for EDAC error
    handling.
    
    TODO: It currently just prints the MCE error log using about the same
          format as mce panic messages. The error message should be enhanced
          with mcelog userspace info and converted into the proper EDAC format,
          to feed the EDAC error counts.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 914914759690..3c7bb5f405f6 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -27,6 +27,8 @@
 #include <linux/slab.h>
 #include <linux/edac.h>
 #include <linux/mmzone.h>
+#include <linux/edac_mce.h>
+#include <linux/spinlock.h>
 
 #include "edac_core.h"
 
@@ -195,6 +197,11 @@ struct i7core_pvt {
 	unsigned long	ce_count[MAX_DIMMS];	/* ECC corrected errors counts per dimm */
 	int		last_ce_count[MAX_DIMMS];
 
+	/* mcelog glue */
+	struct edac_mce		edac_mce;
+	struct mce		mce_entry[MCE_LOG_LEN];
+	unsigned		mce_count;
+	spinlock_t		mce_lock;
 };
 
 /* Device name and register DID (Device ID) */
@@ -900,7 +907,7 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 	pci_read_config_dword(pvt->pci_ch[pvt->inject.channel][0],
 			       MC_CHANNEL_ADDR_MATCH + 4, &rdmask2);
 
-	debugf0("Inject addr match write 0x%016llx, read: 0x%08x%08x\n",
+	debugf0("Inject addr match write 0x%016llx, read: 0x%08x 0x%08x\n",
 		mask, rdmask1, rdmask2);
 #endif
 #endif
@@ -1162,9 +1169,11 @@ static void check_mc_test_err(struct mem_ctl_info *mci)
 	new1 = DIMM1_COR_ERR(rcv0);
 	new0 = DIMM0_COR_ERR(rcv0);
 
+#if 0
 	debugf2("%s CE rcv1=0x%08x rcv0=0x%08x, %d %d %d\n",
 		(pvt->ce_count_available ? "UPDATE" : "READ"),
 		rcv1, rcv0, new0, new1, new2);
+#endif
 
 	/* Updates CE counters if it is not the first time here */
 	if (pvt->ce_count_available) {
@@ -1195,15 +1204,96 @@ static void check_mc_test_err(struct mem_ctl_info *mci)
 	pvt->last_ce_count[0] = new0;
 }
 
+static void i7core_mce_output_error(struct mem_ctl_info *mci,
+				    struct mce *m)
+{
+	debugf0("CPU %d: Machine Check Exception: %16Lx"
+		"Bank %d: %016Lx\n",
+		m->cpu, m->mcgstatus, m->bank, m->status);
+	if (m->ip) {
+		debugf0("RIP%s %02x:<%016Lx>\n",
+			!(m->mcgstatus & MCG_STATUS_EIPV) ? " !INEXACT!" : "",
+			m->cs, m->ip);
+	}
+	printk(KERN_EMERG "TSC %llx ", m->tsc);
+	if (m->addr)
+		printk("ADDR %llx ", m->addr);
+	if (m->misc)
+		printk("MISC %llx ", m->misc);
+
+#if 0
+	snprintf(msg, sizeof(msg),
+		"%s (Branch=%d DRAM-Bank=%d Buffer ID = %d RDWR=%s "
+		"RAS=%d CAS=%d %s Err=0x%lx (%s))",
+		type, branch >> 1, bank, buf_id, rdwr_str(rdwr), ras, cas,
+		type, allErrors, error_name[errnum]);
+
+	/* Call the helper to output message */
+	edac_mc_handle_fbd_ue(mci, rank, channel, channel + 1, msg);
+#endif
+}
+
 /*
  *	i7core_check_error	Retrieve and process errors reported by the
  *				hardware. Called by the Core module.
  */
 static void i7core_check_error(struct mem_ctl_info *mci)
 {
+	struct i7core_pvt *pvt = mci->pvt_info;
+	int i;
+	unsigned count = 0;
+	struct mce *m = NULL;
+	unsigned long flags;
+
+	debugf0(__FILE__ ": %s()\n", __func__);
+
+	/* Copy all mce errors into a temporary buffer */
+	spin_lock_irqsave(&pvt->mce_lock, flags);
+	if (pvt->mce_count) {
+		m = kmalloc(sizeof(*m) * pvt->mce_count, GFP_ATOMIC);
+		if (m) {
+			count = pvt->mce_count;
+			memcpy(m, &pvt->mce_entry, sizeof(*m) * count);
+		}
+		pvt->mce_count = 0;
+	}
+	spin_unlock_irqrestore(&pvt->mce_lock, flags);
+
+	/* proccess mcelog errors */
+	for (i = 0; i < count; i++)
+		i7core_mce_output_error(mci, &m[i]);
+
+	kfree(m);
+
+	/* check memory count errors */
 	check_mc_test_err(mci);
 }
 
+/*
+ * i7core_mce_check_error	Replicates mcelog routine to get errors
+ *				This routine simply queues mcelog errors, and
+ *				return. The error itself should be handled later
+ *				by i7core_check_error.
+ */
+static int i7core_mce_check_error(void *priv, struct mce *mce)
+{
+	struct i7core_pvt *pvt = priv;
+	unsigned long flags;
+
+	debugf0(__FILE__ ": %s()\n", __func__);
+
+	spin_lock_irqsave(&pvt->mce_lock, flags);
+	if (pvt->mce_count < MCE_LOG_LEN) {
+		memcpy(&pvt->mce_entry[pvt->mce_count], mce, sizeof(*mce));
+		pvt->mce_count++;
+	}
+	spin_unlock_irqrestore(&pvt->mce_lock, flags);
+
+	/* Advice mcelog that the error were handled */
+//	return 1;
+	return 0; // Let's duplicate the log
+}
+
 /*
  *	i7core_probe	Probe for ONE instance of device to see if it is
  *			present.
@@ -1305,6 +1395,18 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	pvt->inject.page = -1;
 	pvt->inject.col = -1;
 
+	/* Registers on edac_mce in order to receive memory errors */
+	pvt->edac_mce.priv = pvt;
+	pvt->edac_mce.check_error = i7core_mce_check_error;
+	spin_lock_init(&pvt->mce_lock);
+
+	rc = edac_mce_register(&pvt->edac_mce);
+	if (unlikely (rc < 0)) {
+		debugf0("MC: " __FILE__
+			": %s(): failed edac_mce_register()\n", __func__);
+		goto fail1;
+	}
+
 	i7core_printk(KERN_INFO, "Driver loaded.\n");
 
 	return 0;
@@ -1324,17 +1426,22 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 static void __devexit i7core_remove(struct pci_dev *pdev)
 {
 	struct mem_ctl_info *mci;
+	struct i7core_pvt *pvt;
 
 	debugf0(__FILE__ ": %s()\n", __func__);
 
 	if (i7core_pci)
 		edac_pci_release_generic_ctl(i7core_pci);
 
-	mci = edac_mc_del_mc(&pdev->dev);
 
+	mci = edac_mc_del_mc(&pdev->dev);
 	if (!mci)
 		return;
 
+	/* Unregisters on edac_mce in order to receive memory errors */
+	pvt = mci->pvt_info;
+	edac_mce_unregister(&pvt->edac_mce);
+
 	/* retrieve references to resources, and free those resources */
 	i7core_put_devices();
 

commit 41fcb7feed70d8076f1591664314ca172fcdff7b
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 22 22:48:31 2009 -0300

    i7core_edac: CodingStyle fixes
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index e0a3b217c52b..914914759690 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -113,7 +113,7 @@
   #define MC_DOD_NUMBANK(x)		(((x) & MC_DOD_NUMBANK_MASK) >> 7)
   #define MC_DOD_NUMRANK_MASK		((1 << 6) | (1 << 5))
   #define MC_DOD_NUMRANK(x)		(((x) & MC_DOD_NUMRANK_MASK) >> 5)
-  #define MC_DOD_NUMROW_MASK		((1 << 4) | (1 << 3)| (1 << 2))
+  #define MC_DOD_NUMROW_MASK		((1 << 4) | (1 << 3) | (1 << 2))
   #define MC_DOD_NUMROW(x)		(((x) & MC_DOD_NUMROW_MASK) >> 2)
   #define MC_DOD_NUMCOL_MASK		3
   #define MC_DOD_NUMCOL(x)		((x) & MC_DOD_NUMCOL_MASK)
@@ -352,9 +352,8 @@ static int i7core_get_active_channels(int *channels, int *csrows)
 			continue;
 
 		/* Check if the channel is disabled */
-		if (status & (1 << i)) {
+		if (status & (1 << i))
 			continue;
-		}
 
 		pdev = get_pdev_slot_func(i + 4, 1);
 		if (!pdev) {
@@ -410,7 +409,7 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 		pvt->info.max_dod, pvt->info.ch_map);
 
 	if (ECC_ENABLED(pvt)) {
-		debugf0("ECC enabled with x%d SDCC\n", ECCx8(pvt) ?8:4);
+		debugf0("ECC enabled with x%d SDCC\n", ECCx8(pvt) ? 8 : 4);
 		if (ECCx8(pvt))
 			mode = EDAC_S8ECD8ED;
 		else
@@ -447,7 +446,7 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 		pci_read_config_dword(pvt->pci_ch[i][0],
 				MC_CHANNEL_DIMM_INIT_PARAMS, &data);
 
-		pvt->channel[i].ranks = (data & QUAD_RANK_PRESENT)? 4 : 2;
+		pvt->channel[i].ranks = (data & QUAD_RANK_PRESENT) ? 4 : 2;
 
 		if (data & REGISTERED_DIMM)
 			mtype = MEM_RDDR3;
@@ -476,7 +475,7 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 			RDLCH(pvt->info.ch_map, i), WRLCH(pvt->info.ch_map, i),
 			data,
 			pvt->channel[i].ranks,
-			(data & REGISTERED_DIMM)? 'R' : 'U');
+			(data & REGISTERED_DIMM) ? 'R' : 'U');
 
 		for (j = 0; j < 3; j++) {
 			u32 banks, ranks, rows, cols;
@@ -550,9 +549,9 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 		pci_read_config_dword(pdev, MC_SAG_CH_5, &value[5]);
 		pci_read_config_dword(pdev, MC_SAG_CH_6, &value[6]);
 		pci_read_config_dword(pdev, MC_SAG_CH_7, &value[7]);
-		printk("\t[%i] DIVBY3\tREMOVED\tOFFSET\n", i);
+		debugf0("\t[%i] DIVBY3\tREMOVED\tOFFSET\n", i);
 		for (j = 0; j < 8; j++)
-			printk("\t\t%#x\t%#x\t%#x\n",
+			debugf0("\t\t%#x\t%#x\t%#x\n",
 				(value[j] >> 27) & 0x1,
 				(value[j] >> 24) & 0x7,
 				(value[j] && ((1 << 24) - 1)));
@@ -602,7 +601,7 @@ static ssize_t i7core_inject_section_store(struct mem_ctl_info *mci,
 	int rc;
 
 	if (pvt->inject.enable)
-		 disable_inject(mci);
+		disable_inject(mci);
 
 	rc = strict_strtoul(data, 10, &value);
 	if ((rc < 0) || (value > 3))
@@ -635,7 +634,7 @@ static ssize_t i7core_inject_type_store(struct mem_ctl_info *mci,
 	int rc;
 
 	if (pvt->inject.enable)
-		 disable_inject(mci);
+		disable_inject(mci);
 
 	rc = strict_strtoul(data, 10, &value);
 	if ((rc < 0) || (value > 7))
@@ -670,7 +669,7 @@ static ssize_t i7core_inject_eccmask_store(struct mem_ctl_info *mci,
 	int rc;
 
 	if (pvt->inject.enable)
-		 disable_inject(mci);
+		disable_inject(mci);
 
 	rc = strict_strtoul(data, 10, &value);
 	if (rc < 0)
@@ -706,7 +705,7 @@ static ssize_t i7core_inject_addrmatch_store(struct mem_ctl_info *mci,
 	int rc;
 
 	if (pvt->inject.enable)
-		 disable_inject(mci);
+		disable_inject(mci);
 
 	do {
 		cmd = strsep((char **) &data, ":");
@@ -716,7 +715,7 @@ static ssize_t i7core_inject_addrmatch_store(struct mem_ctl_info *mci,
 		if (!val)
 			return cmd - data;
 
-		if (!strcasecmp(val,"any"))
+		if (!strcasecmp(val, "any"))
 			value = -1;
 		else {
 			rc = strict_strtol(val, 10, &value);
@@ -724,33 +723,33 @@ static ssize_t i7core_inject_addrmatch_store(struct mem_ctl_info *mci,
 				return cmd - data;
 		}
 
-		if (!strcasecmp(cmd,"channel")) {
+		if (!strcasecmp(cmd, "channel")) {
 			if (value < 3)
 				pvt->inject.channel = value;
 			else
 				return cmd - data;
-		} else if (!strcasecmp(cmd,"dimm")) {
+		} else if (!strcasecmp(cmd, "dimm")) {
 			if (value < 4)
 				pvt->inject.dimm = value;
 			else
 				return cmd - data;
-		} else if (!strcasecmp(cmd,"rank")) {
+		} else if (!strcasecmp(cmd, "rank")) {
 			if (value < 4)
 				pvt->inject.rank = value;
 			else
 				return cmd - data;
-		} else if (!strcasecmp(cmd,"bank")) {
+		} else if (!strcasecmp(cmd, "bank")) {
 			if (value < 4)
 				pvt->inject.bank = value;
 			else
 				return cmd - data;
-		} else if (!strcasecmp(cmd,"page")) {
+		} else if (!strcasecmp(cmd, "page")) {
 			if (value <= 0xffff)
 				pvt->inject.page = value;
 			else
 				return cmd - data;
-		} else if (!strcasecmp(cmd,"col") ||
-			   !strcasecmp(cmd,"column")) {
+		} else if (!strcasecmp(cmd, "col") ||
+			   !strcasecmp(cmd, "column")) {
 			if (value <= 0x3fff)
 				pvt->inject.col = value;
 			else
@@ -923,7 +922,8 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 	pci_write_config_dword(pvt->pci_ch[pvt->inject.channel][0],
 			       MC_CHANNEL_ERROR_MASK, injectmask);
 
-	debugf0("Error inject addr match 0x%016llx, ecc 0x%08x, inject 0x%08x\n",
+	debugf0("Error inject addr match 0x%016llx, ecc 0x%08x,"
+		" inject 0x%08x\n",
 		mask, pvt->inject.eccmask, injectmask);
 
 
@@ -1048,7 +1048,7 @@ static int i7core_get_devices(void)
 				"Device not found: PCI ID %04x:%04x "
 				"(dev %d, func %d)\n",
 				PCI_VENDOR_ID_INTEL, pci_devs[i].dev_id,
-				pci_devs[i].dev,pci_devs[i].func);
+				pci_devs[i].dev, pci_devs[i].func);
 
 			/* Dev 3 function 2 only exists on chips with RDIMMs */
 			if ((pci_devs[i].dev == 3) && (pci_devs[i].func == 2))
@@ -1231,12 +1231,12 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 
 	/* Check the number of active and not disabled channels */
 	rc = i7core_get_active_channels(&num_channels, &num_csrows);
-	if (unlikely (rc < 0))
+	if (unlikely(rc < 0))
 		goto fail0;
 
 	/* allocate a new MC control structure */
 	mci = edac_mc_alloc(sizeof(*pvt), num_csrows, num_channels, 0);
-	if (unlikely (!mci)) {
+	if (unlikely(!mci)) {
 		rc = -ENOMEM;
 		goto fail0;
 	}
@@ -1249,7 +1249,12 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	memset(pvt, 0, sizeof(*pvt));
 
 	mci->mc_idx = 0;
-	mci->mtype_cap = MEM_FLAG_DDR3;		/* FIXME: how to handle RDDR3? */
+	/*
+	 * FIXME: how to handle RDDR3 at MCI level? It is possible to have
+	 * Mixed RDDR3/UDDR3 with Nehalem, provided that they are on different
+	 * memory channels
+	 */
+	mci->mtype_cap = MEM_FLAG_DDR3;
 	mci->edac_ctl_cap = EDAC_FLAG_NONE;
 	mci->edac_cap = EDAC_FLAG_NONE;
 	mci->mod_name = "i7core_edac.c";
@@ -1263,7 +1268,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 
 	/* Store pci devices at mci for faster access */
 	rc = mci_bind_devs(mci);
-	if (unlikely (rc < 0))
+	if (unlikely(rc < 0))
 		goto fail1;
 
 	/* Get dimm basic config */
@@ -1283,7 +1288,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 
 	/* allocating generic PCI control info */
 	i7core_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);
-	if (unlikely (!i7core_pci)) {
+	if (unlikely(!i7core_pci)) {
 		printk(KERN_WARNING
 			"%s(): Unable to create PCI control\n",
 			__func__);

commit eb94fc402f1592dfe847b245d9109c11a99a2ea1
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 22 22:48:31 2009 -0300

    i7core_edac: fill csrows edac sysfs info
    
    csrows is still fake, since we can't identify its representation with
    Nehalem registers.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 772219fa10be..e0a3b217c52b 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -309,25 +309,33 @@ static inline int numcol(u32 col)
 /****************************************************************************
 			Memory check routines
  ****************************************************************************/
-static int i7core_get_active_channels(int *channels)
+static struct pci_dev *get_pdev_slot_func(int slot, int func)
 {
-	struct pci_dev *pdev = NULL;
 	int i;
-	u32 status, control;
-
-	*channels = 0;
 
 	for (i = 0; i < N_DEVS; i++) {
 		if (!pci_devs[i].pdev)
 			continue;
 
-		if (PCI_SLOT(pci_devs[i].pdev->devfn) == 3 &&
-		    PCI_FUNC(pci_devs[i].pdev->devfn) == 0) {
-			pdev = pci_devs[i].pdev;
-			break;
+		if (PCI_SLOT(pci_devs[i].pdev->devfn) == slot &&
+		    PCI_FUNC(pci_devs[i].pdev->devfn) == func) {
+			return pci_devs[i].pdev;
 		}
 	}
 
+	return NULL;
+}
+
+static int i7core_get_active_channels(int *channels, int *csrows)
+{
+	struct pci_dev *pdev = NULL;
+	int i, j;
+	u32 status, control;
+
+	*channels = 0;
+	*csrows = 0;
+
+	pdev = get_pdev_slot_func(3, 0);
 	if (!pdev) {
 		i7core_printk(KERN_ERR, "Couldn't find fn 3.0!!!\n");
 		return -ENODEV;
@@ -338,6 +346,7 @@ static int i7core_get_active_channels(int *channels)
 	pci_read_config_dword(pdev, MC_CONTROL, &control);
 
 	for (i = 0; i < NUM_CHANS; i++) {
+		u32 dimm_dod[3];
 		/* Check if the channel is active */
 		if (!(control & (1 << (8 + i))))
 			continue;
@@ -347,7 +356,27 @@ static int i7core_get_active_channels(int *channels)
 			continue;
 		}
 
+		pdev = get_pdev_slot_func(i + 4, 1);
+		if (!pdev) {
+			i7core_printk(KERN_ERR, "Couldn't find fn %d.%d!!!\n",
+				      i + 4, 1);
+			return -ENODEV;
+		}
+		/* Devices 4-6 function 1 */
+		pci_read_config_dword(pdev,
+				MC_DOD_CH_DIMM0, &dimm_dod[0]);
+		pci_read_config_dword(pdev,
+				MC_DOD_CH_DIMM1, &dimm_dod[1]);
+		pci_read_config_dword(pdev,
+				MC_DOD_CH_DIMM2, &dimm_dod[2]);
+
 		(*channels)++;
+
+		for (j = 0; j < 3; j++) {
+			if (!DIMM_PRESENT(dimm_dod[j]))
+				continue;
+			(*csrows)++;
+		}
 	}
 
 	debugf0("Number of active channels: %d\n", *channels);
@@ -473,7 +502,11 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 				RANKOFFSET(dimm_dod[j]),
 				banks, ranks, rows, cols);
 
-			npages = cols * rows; /* FIXME */
+#if PAGE_SHIFT > 20
+			npages = size >> (PAGE_SHIFT - 20);
+#else
+			npages = size << (20 - PAGE_SHIFT);
+#endif
 
 			csr = &mci->csrows[csrow];
 			csr->first_page = last_page + 1;
@@ -482,8 +515,12 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 			csr->nr_pages = npages;
 
 			csr->page_mask = 0;
-			csr->grain = 0;
+			csr->grain = 8;
 			csr->csrow_idx = csrow;
+			csr->nr_channels = 1;
+
+			csr->channels[0].chan_idx = i;
+			csr->channels[0].ce_count = 0;
 
 			switch (banks) {
 			case 4:
@@ -1179,7 +1216,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 {
 	struct mem_ctl_info *mci;
 	struct i7core_pvt *pvt;
-	int num_channels = 0;
+	int num_channels;
 	int num_csrows;
 	int dev_idx = id->driver_data;
 	int rc;
@@ -1193,13 +1230,10 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 		return rc;
 
 	/* Check the number of active and not disabled channels */
-	rc = i7core_get_active_channels(&num_channels);
+	rc = i7core_get_active_channels(&num_channels, &num_csrows);
 	if (unlikely (rc < 0))
 		goto fail0;
 
-	/* FIXME: we currently don't know the number of csrows */
-	num_csrows = num_channels;
-
 	/* allocate a new MC control structure */
 	mci = edac_mc_alloc(sizeof(*pvt), num_csrows, num_channels, 0);
 	if (unlikely (!mci)) {

commit 5566cb7c91ba4ff4447278bb27896b4a2bb7d18a
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 22 22:48:31 2009 -0300

    i7core_edac: Memory info fixes and preparation for properly filling cswrow data
    
    Now, memory size is properly displayed:
    
        EDAC i7core: DOD Max limits: DIMMS: 2, 1-ranked, 8-banked
        EDAC i7core: DOD Max rows x colums = 0x4000 x 0x400
        EDAC i7core: Memory channel configuration:
        EDAC i7core: Ch0 phy rd0, wr0 (0x063f7c31): 2 ranks, UDIMMs
        EDAC i7core:    dimm 0 (0x00000288) 1024 Mb offset: 0, numbank: 8,
                        numrank: 1, numrow: 0x4000, numcol: 0x400
        EDAC i7core:    dimm 1 (0x00001288) 1024 Mb offset: 4, numbank: 8,
                        numrank: 1, numrow: 0x4000, numcol: 0x400
        EDAC i7core: Ch1 phy rd1, wr1 (0x063f7c31): 2 ranks, UDIMMs
        EDAC i7core:    dimm 0 (0x00000288) 1024 Mb offset: 0, numbank: 8,
                        numrank: 1, numrow: 0x4000, numcol: 0x400
        EDAC i7core: Ch2 phy rd3, wr3 (0x063f7c31): 2 ranks, UDIMMs
        EDAC i7core:    dimm 0 (0x00000288) 1024 Mb offset: 0, numbank: 8,
                        numrank: 1, numrow: 0x4000, numcol: 0x400
    
    Still, as the way to retrieve csrows info is not known, it does a
    mapping of what's available to csrows basic unit at edac core.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 483cca2e543b..772219fa10be 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -113,8 +113,8 @@
   #define MC_DOD_NUMBANK(x)		(((x) & MC_DOD_NUMBANK_MASK) >> 7)
   #define MC_DOD_NUMRANK_MASK		((1 << 6) | (1 << 5))
   #define MC_DOD_NUMRANK(x)		(((x) & MC_DOD_NUMRANK_MASK) >> 5)
-  #define MC_DOD_NUMROW_MASK		((1 << 4) | (1 << 3))
-  #define MC_DOD_NUMROW(x)		(((x) & MC_DOD_NUMROW_MASK) >> 3)
+  #define MC_DOD_NUMROW_MASK		((1 << 4) | (1 << 3)| (1 << 2))
+  #define MC_DOD_NUMROW(x)		(((x) & MC_DOD_NUMROW_MASK) >> 2)
   #define MC_DOD_NUMCOL_MASK		3
   #define MC_DOD_NUMCOL(x)		((x) & MC_DOD_NUMCOL_MASK)
 
@@ -361,6 +361,7 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 	struct csrow_info *csr;
 	struct pci_dev *pdev;
 	int i, j, csrow = 0;
+	unsigned long last_page = 0;
 	enum edac_type mode;
 	enum mem_type mtype;
 
@@ -380,7 +381,7 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 		pvt->info.max_dod, pvt->info.ch_map);
 
 	if (ECC_ENABLED(pvt)) {
-		debugf0("ECC enabled with x%d SDCC\n", ECCx8(pvt)?8:4);
+		debugf0("ECC enabled with x%d SDCC\n", ECCx8(pvt) ?8:4);
 		if (ECCx8(pvt))
 			mode = EDAC_S8ECD8ED;
 		else
@@ -450,6 +451,7 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 
 		for (j = 0; j < 3; j++) {
 			u32 banks, ranks, rows, cols;
+			u32 size, npages;
 
 			if (!DIMM_PRESENT(dimm_dod[j]))
 				continue;
@@ -459,19 +461,27 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 			rows = numrow(MC_DOD_NUMROW(dimm_dod[j]));
 			cols = numcol(MC_DOD_NUMCOL(dimm_dod[j]));
 
+			/* DDR3 has 8 I/O banks */
+			size = (rows * cols * banks * ranks) >> (20 - 3);
+
 			pvt->channel[i].dimms++;
 
-			debugf0("\tdimm %d offset: %x, numbank: %#x, "
-				"numrank: %#x, numrow: %#x, numcol: %#x\n",
-				j,
+			debugf0("\tdimm %d (0x%08x) %d Mb offset: %x, "
+				"numbank: %d,\n\t\t"
+				"numrank: %d, numrow: %#x, numcol: %#x\n",
+				j, dimm_dod[j], size,
 				RANKOFFSET(dimm_dod[j]),
 				banks, ranks, rows, cols);
 
+			npages = cols * rows; /* FIXME */
+
 			csr = &mci->csrows[csrow];
-			csr->first_page = 0;
-			csr->last_page = 0;
+			csr->first_page = last_page + 1;
+			last_page += npages;
+			csr->last_page = last_page;
+			csr->nr_pages = npages;
+
 			csr->page_mask = 0;
-			csr->nr_pages = 0;
 			csr->grain = 0;
 			csr->csrow_idx = csrow;
 

commit 854d3349973a7c47bd989794037f526b74af20c4
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 22 22:48:30 2009 -0300

    i7core_edac: Get more info about the memory DIMMs
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index a6e798349e93..483cca2e543b 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -109,14 +109,14 @@
   #define RANKOFFSET(x)		((x & RANKOFFSET_MASK) >> 10)
   #define DIMM_PRESENT_MASK	(1 << 9)
   #define DIMM_PRESENT(x)	(((x) & DIMM_PRESENT_MASK) >> 9)
-  #define NUMBANK_MASK		((1 << 8) | (1 << 7))
-  #define NUMBANK(x)		(((x) & NUMBANK_MASK) >> 7)
-  #define NUMRANK_MASK		((1 << 6) | (1 << 5))
-  #define NUMRANK(x)		(((x) & NUMRANK_MASK) >> 5)
-  #define NUMROW_MASK		((1 << 4) | (1 << 3))
-  #define NUMROW(x)		(((x) & NUMROW_MASK) >> 3)
-  #define NUMCOL_MASK		3
-  #define NUMCOL(x)		((x) & NUMCOL_MASK)
+  #define MC_DOD_NUMBANK_MASK		((1 << 8) | (1 << 7))
+  #define MC_DOD_NUMBANK(x)		(((x) & MC_DOD_NUMBANK_MASK) >> 7)
+  #define MC_DOD_NUMRANK_MASK		((1 << 6) | (1 << 5))
+  #define MC_DOD_NUMRANK(x)		(((x) & MC_DOD_NUMRANK_MASK) >> 5)
+  #define MC_DOD_NUMROW_MASK		((1 << 4) | (1 << 3))
+  #define MC_DOD_NUMROW(x)		(((x) & MC_DOD_NUMROW_MASK) >> 3)
+  #define MC_DOD_NUMCOL_MASK		3
+  #define MC_DOD_NUMCOL(x)		((x) & MC_DOD_NUMCOL_MASK)
 
 #define MC_RANK_PRESENT		0x7c
 
@@ -268,41 +268,41 @@ static struct edac_pci_ctl_info *i7core_pci;
 #define CH_DISABLED(pvt, ch)	((pvt)->info.mc_status & (1 << ch))
 
 	/* MC_MAX_DOD read functions */
-static inline int maxnumdimms(struct i7core_pvt *pvt)
+static inline int numdimms(u32 dimms)
 {
-	return (pvt->info.max_dod & 0x3) + 1;
+	return (dimms & 0x3) + 1;
 }
 
-static inline int maxnumrank(struct i7core_pvt *pvt)
+static inline int numrank(u32 rank)
 {
 	static int ranks[4] = { 1, 2, 4, -EINVAL };
 
-	return ranks[(pvt->info.max_dod >> 2) & 0x3];
+	return ranks[rank & 0x3];
 }
 
-static inline int maxnumbank(struct i7core_pvt *pvt)
+static inline int numbank(u32 bank)
 {
 	static int banks[4] = { 4, 8, 16, -EINVAL };
 
-	return banks[(pvt->info.max_dod >> 4) & 0x3];
+	return banks[bank & 0x3];
 }
 
-static inline int maxnumrow(struct i7core_pvt *pvt)
+static inline int numrow(u32 row)
 {
 	static int rows[8] = {
 		1 << 12, 1 << 13, 1 << 14, 1 << 15,
 		1 << 16, -EINVAL, -EINVAL, -EINVAL,
 	};
 
-	return rows[((pvt->info.max_dod >> 6) & 0x7)];
+	return rows[row & 0x7];
 }
 
-static inline int maxnumcol(struct i7core_pvt *pvt)
+static inline int numcol(u32 col)
 {
 	static int cols[8] = {
 		1 << 10, 1 << 11, 1 << 12, -EINVAL,
 	};
-	return cols[((pvt->info.max_dod >> 9) & 0x3) << 12];
+	return cols[col & 0x3];
 }
 
 
@@ -359,10 +359,13 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	struct csrow_info *csr;
-	struct pci_dev *pdev = pvt->pci_mcr[0];
+	struct pci_dev *pdev;
 	int i, j, csrow = 0;
 	enum edac_type mode;
+	enum mem_type mtype;
 
+	/* Get data from the MC register, function 0 */
+	pdev = pvt->pci_mcr[0];
 	if (!pdev)
 		return -ENODEV;
 
@@ -388,15 +391,18 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 	}
 
 	/* FIXME: need to handle the error codes */
-	debugf0("DOD Maximum limits: DIMMS: %d, %d-ranked, %d-banked\n",
-		maxnumdimms(pvt), maxnumrank(pvt), maxnumbank(pvt));
-	debugf0("DOD Maximum rows x colums = 0x%x x 0x%x\n",
-		maxnumrow(pvt), maxnumcol(pvt));
+	debugf0("DOD Max limits: DIMMS: %d, %d-ranked, %d-banked\n",
+		numdimms(pvt->info.max_dod),
+		numrank(pvt->info.max_dod >> 2),
+		numbank(pvt->info.max_dod >> 4));
+	debugf0("DOD Max rows x colums = 0x%x x 0x%x\n",
+		numrow(pvt->info.max_dod >> 6),
+		numcol(pvt->info.max_dod >> 9));
 
 	debugf0("Memory channel configuration:\n");
 
 	for (i = 0; i < NUM_CHANS; i++) {
-		u32 data, value[8];
+		u32 data, dimm_dod[3], value[8];
 
 		if (!CH_ACTIVE(pvt, i)) {
 			debugf0("Channel %i is not active\n", i);
@@ -413,58 +419,96 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 
 		pvt->channel[i].ranks = (data & QUAD_RANK_PRESENT)? 4 : 2;
 
+		if (data & REGISTERED_DIMM)
+			mtype = MEM_RDDR3;
+		else
+			mtype = MEM_DDR3;
+#if 0
 		if (data & THREE_DIMMS_PRESENT)
 			pvt->channel[i].dimms = 3;
 		else if (data & SINGLE_QUAD_RANK_PRESENT)
 			pvt->channel[i].dimms = 1;
 		else
 			pvt->channel[i].dimms = 2;
+#endif
+
+		/* Devices 4-6 function 1 */
+		pci_read_config_dword(pvt->pci_ch[i][1],
+				MC_DOD_CH_DIMM0, &dimm_dod[0]);
+		pci_read_config_dword(pvt->pci_ch[i][1],
+				MC_DOD_CH_DIMM1, &dimm_dod[1]);
+		pci_read_config_dword(pvt->pci_ch[i][1],
+				MC_DOD_CH_DIMM2, &dimm_dod[2]);
 
 		debugf0("Ch%d phy rd%d, wr%d (0x%08x): "
-			"%d ranks, %d %cDIMMs, offset = %d\n\t"
-			"present: %i, numbank: %#x, numrank: %#x, "
-			"numrow: %#x, numcol: %#x\n",
+			"%d ranks, %cDIMMs\n",
 			i,
 			RDLCH(pvt->info.ch_map, i), WRLCH(pvt->info.ch_map, i),
 			data,
-			pvt->channel[i].ranks, pvt->channel[i].dimms,
-			(data & REGISTERED_DIMM)? 'R' : 'U',
-			RANKOFFSET(data),
-			DIMM_PRESENT(data),
-			NUMBANK(data), NUMRANK(data),
-			NUMROW(data), NUMCOL(data));
-
-			pci_read_config_dword(pdev, MC_SAG_CH_0, &value[0]);
-			pci_read_config_dword(pdev, MC_SAG_CH_1, &value[1]);
-			pci_read_config_dword(pdev, MC_SAG_CH_2, &value[2]);
-			pci_read_config_dword(pdev, MC_SAG_CH_3, &value[3]);
-			pci_read_config_dword(pdev, MC_SAG_CH_4, &value[4]);
-			pci_read_config_dword(pdev, MC_SAG_CH_5, &value[5]);
-			pci_read_config_dword(pdev, MC_SAG_CH_6, &value[6]);
-			pci_read_config_dword(pdev, MC_SAG_CH_7, &value[7]);
-			printk("\t[%i] DIVBY3\tREMOVED\tOFFSET\n", i);
-			for (j = 0; j < 8; j++)
-				printk("\t\t%#x\t%#x\t%#x\n",
-					(value[j] >> 27) & 0x1,
-					(value[j] >> 24) & 0x7,
-					(value[j] && ((1 << 24) - 1)));
-
-		csr = &mci->csrows[csrow];
-		csr->first_page = 0;
-		csr->last_page = 0;
-		csr->page_mask = 0;
-		csr->nr_pages = 0;
-		csr->grain = 0;
-		csr->csrow_idx = csrow;
-		csr->dtype = DEV_X8;	/* FIXME: check this */
+			pvt->channel[i].ranks,
+			(data & REGISTERED_DIMM)? 'R' : 'U');
 
-		if (data & REGISTERED_DIMM)
-			csr->mtype = MEM_RDDR3;
-		else
-			csr->mtype = MEM_DDR3;
-		csr->edac_mode = mode;
+		for (j = 0; j < 3; j++) {
+			u32 banks, ranks, rows, cols;
+
+			if (!DIMM_PRESENT(dimm_dod[j]))
+				continue;
+
+			banks = numbank(MC_DOD_NUMBANK(dimm_dod[j]));
+			ranks = numrank(MC_DOD_NUMRANK(dimm_dod[j]));
+			rows = numrow(MC_DOD_NUMROW(dimm_dod[j]));
+			cols = numcol(MC_DOD_NUMCOL(dimm_dod[j]));
+
+			pvt->channel[i].dimms++;
+
+			debugf0("\tdimm %d offset: %x, numbank: %#x, "
+				"numrank: %#x, numrow: %#x, numcol: %#x\n",
+				j,
+				RANKOFFSET(dimm_dod[j]),
+				banks, ranks, rows, cols);
+
+			csr = &mci->csrows[csrow];
+			csr->first_page = 0;
+			csr->last_page = 0;
+			csr->page_mask = 0;
+			csr->nr_pages = 0;
+			csr->grain = 0;
+			csr->csrow_idx = csrow;
+
+			switch (banks) {
+			case 4:
+				csr->dtype = DEV_X4;
+				break;
+			case 8:
+				csr->dtype = DEV_X8;
+				break;
+			case 16:
+				csr->dtype = DEV_X16;
+				break;
+			default:
+				csr->dtype = DEV_UNKNOWN;
+			}
+
+			csr->edac_mode = mode;
+			csr->mtype = mtype;
+
+			csrow++;
+		}
 
-		csrow++;
+		pci_read_config_dword(pdev, MC_SAG_CH_0, &value[0]);
+		pci_read_config_dword(pdev, MC_SAG_CH_1, &value[1]);
+		pci_read_config_dword(pdev, MC_SAG_CH_2, &value[2]);
+		pci_read_config_dword(pdev, MC_SAG_CH_3, &value[3]);
+		pci_read_config_dword(pdev, MC_SAG_CH_4, &value[4]);
+		pci_read_config_dword(pdev, MC_SAG_CH_5, &value[5]);
+		pci_read_config_dword(pdev, MC_SAG_CH_6, &value[6]);
+		pci_read_config_dword(pdev, MC_SAG_CH_7, &value[7]);
+		printk("\t[%i] DIVBY3\tREMOVED\tOFFSET\n", i);
+		for (j = 0; j < 8; j++)
+			printk("\t\t%#x\t%#x\t%#x\n",
+				(value[j] >> 27) & 0x1,
+				(value[j] >> 24) & 0x7,
+				(value[j] && ((1 << 24) - 1)));
 	}
 
 	return 0;

commit 7dd6953c5fecc44d264710e1fa158d0038215b63
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 22 22:48:30 2009 -0300

    i7core_edac: Add more information about each active dimm
    
    Thanks-to: Aristeu Rozanski <aris@redhat.com> for part of the code
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 62ae472c4e27..a6e798349e93 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -359,21 +359,18 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 	struct csrow_info *csr;
-	int i, csrow = 0;
+	struct pci_dev *pdev = pvt->pci_mcr[0];
+	int i, j, csrow = 0;
 	enum edac_type mode;
 
-	if (!pvt->pci_mcr[0])
+	if (!pdev)
 		return -ENODEV;
 
 	/* Device 3 function 0 reads */
-	pci_read_config_dword(pvt->pci_mcr[0], MC_CONTROL,
-					       &pvt->info.mc_control);
-	pci_read_config_dword(pvt->pci_mcr[0], MC_STATUS,
-					       &pvt->info.mc_status);
-	pci_read_config_dword(pvt->pci_mcr[0], MC_MAX_DOD,
-					       &pvt->info.max_dod);
-	pci_read_config_dword(pvt->pci_mcr[0], MC_CHANNEL_MAPPER,
-					       &pvt->info.ch_map);
+	pci_read_config_dword(pdev, MC_CONTROL, &pvt->info.mc_control);
+	pci_read_config_dword(pdev, MC_STATUS, &pvt->info.mc_status);
+	pci_read_config_dword(pdev, MC_MAX_DOD, &pvt->info.max_dod);
+	pci_read_config_dword(pdev, MC_CHANNEL_MAPPER, &pvt->info.ch_map);
 
 	debugf0("MC control=0x%08x status=0x%08x dod=0x%08x map=0x%08x\n",
 		pvt->info.mc_control, pvt->info.mc_status,
@@ -399,7 +396,7 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 	debugf0("Memory channel configuration:\n");
 
 	for (i = 0; i < NUM_CHANS; i++) {
-		u32 data;
+		u32 data, value[8];
 
 		if (!CH_ACTIVE(pvt, i)) {
 			debugf0("Channel %i is not active\n", i);
@@ -424,13 +421,33 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 			pvt->channel[i].dimms = 2;
 
 		debugf0("Ch%d phy rd%d, wr%d (0x%08x): "
-			"%d ranks, %d %cDIMMs, offset = %d\n",
+			"%d ranks, %d %cDIMMs, offset = %d\n\t"
+			"present: %i, numbank: %#x, numrank: %#x, "
+			"numrow: %#x, numcol: %#x\n",
 			i,
 			RDLCH(pvt->info.ch_map, i), WRLCH(pvt->info.ch_map, i),
 			data,
 			pvt->channel[i].ranks, pvt->channel[i].dimms,
 			(data & REGISTERED_DIMM)? 'R' : 'U',
-			RANKOFFSET(data));
+			RANKOFFSET(data),
+			DIMM_PRESENT(data),
+			NUMBANK(data), NUMRANK(data),
+			NUMROW(data), NUMCOL(data));
+
+			pci_read_config_dword(pdev, MC_SAG_CH_0, &value[0]);
+			pci_read_config_dword(pdev, MC_SAG_CH_1, &value[1]);
+			pci_read_config_dword(pdev, MC_SAG_CH_2, &value[2]);
+			pci_read_config_dword(pdev, MC_SAG_CH_3, &value[3]);
+			pci_read_config_dword(pdev, MC_SAG_CH_4, &value[4]);
+			pci_read_config_dword(pdev, MC_SAG_CH_5, &value[5]);
+			pci_read_config_dword(pdev, MC_SAG_CH_6, &value[6]);
+			pci_read_config_dword(pdev, MC_SAG_CH_7, &value[7]);
+			printk("\t[%i] DIVBY3\tREMOVED\tOFFSET\n", i);
+			for (j = 0; j < 8; j++)
+				printk("\t\t%#x\t%#x\t%#x\n",
+					(value[j] >> 27) & 0x1,
+					(value[j] >> 24) & 0x7,
+					(value[j] && ((1 << 24) - 1)));
 
 		csr = &mci->csrows[csrow];
 		csr->first_page = 0;

commit b7c761512c5412eb30be567a0640060cccfc372f
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 22 22:48:30 2009 -0300

    i7core_edac: Improve error handling
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 556a150e645b..62ae472c4e27 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -328,8 +328,10 @@ static int i7core_get_active_channels(int *channels)
 		}
 	}
 
-	if (!pdev)
+	if (!pdev) {
+		i7core_printk(KERN_ERR, "Couldn't find fn 3.0!!!\n");
 		return -ENODEV;
+	}
 
 	/* Device 3 function 0 reads */
 	pci_read_config_dword(pdev, MC_STATUS, &status);
@@ -1109,16 +1111,19 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	int num_channels = 0;
 	int num_csrows;
 	int dev_idx = id->driver_data;
+	int rc;
 
 	if (unlikely(dev_idx >= ARRAY_SIZE(i7core_devs)))
 		return -EINVAL;
 
 	/* get the pci devices we want to reserve for our use */
-	if (unlikely(i7core_get_devices() < 0))
-		return -ENODEV;
+	rc = i7core_get_devices();
+	if (unlikely(rc < 0))
+		return rc;
 
 	/* Check the number of active and not disabled channels */
-	if (unlikely (i7core_get_active_channels(&num_channels)) < 0)
+	rc = i7core_get_active_channels(&num_channels);
+	if (unlikely (rc < 0))
 		goto fail0;
 
 	/* FIXME: we currently don't know the number of csrows */
@@ -1126,8 +1131,10 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 
 	/* allocate a new MC control structure */
 	mci = edac_mc_alloc(sizeof(*pvt), num_csrows, num_channels, 0);
-	if (unlikely (!mci))
-		return -ENOMEM;
+	if (unlikely (!mci)) {
+		rc = -ENOMEM;
+		goto fail0;
+	}
 
 	debugf0("MC: " __FILE__ ": %s(): mci = %p\n", __func__, mci);
 
@@ -1150,19 +1157,22 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	mci->edac_check = i7core_check_error;
 
 	/* Store pci devices at mci for faster access */
-	if (unlikely (mci_bind_devs(mci)) < 0)
+	rc = mci_bind_devs(mci);
+	if (unlikely (rc < 0))
 		goto fail1;
 
 	/* Get dimm basic config */
 	get_dimm_config(mci);
 
 	/* add this new MC control structure to EDAC's list of MCs */
-	if (unlikely(edac_mc_add_mc(mci)) < 0) {
+	if (unlikely(edac_mc_add_mc(mci))) {
 		debugf0("MC: " __FILE__
 			": %s(): failed edac_mc_add_mc()\n", __func__);
 		/* FIXME: perhaps some code should go here that disables error
 		 * reporting if we just enabled it
 		 */
+
+		rc = -EINVAL;
 		goto fail1;
 	}
 
@@ -1190,11 +1200,11 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	return 0;
 
 fail1:
-	i7core_put_devices();
+	edac_mc_free(mci);
 
 fail0:
-	edac_mc_free(mci);
-	return -ENODEV;
+	i7core_put_devices();
+	return rc;
 }
 
 /*

commit 1c6fed808f1ccd0804786e87f6b2c907dcd730fa
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 22 22:48:30 2009 -0300

    i7core_edac: Properly fill struct csrow_info
    
    Thanks-to: Aristeu Rozanski <aris@redhat.com> for part of the code
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index bfa462f6fa0e..556a150e645b 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -348,13 +348,17 @@ static int i7core_get_active_channels(int *channels)
 		(*channels)++;
 	}
 
+	debugf0("Number of active channels: %d\n", *channels);
+
 	return 0;
 }
 
 static int get_dimm_config(struct mem_ctl_info *mci)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
-	int i;
+	struct csrow_info *csr;
+	int i, csrow = 0;
+	enum edac_type mode;
 
 	if (!pvt->pci_mcr[0])
 		return -ENODEV;
@@ -365,7 +369,7 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 	pci_read_config_dword(pvt->pci_mcr[0], MC_STATUS,
 					       &pvt->info.mc_status);
 	pci_read_config_dword(pvt->pci_mcr[0], MC_MAX_DOD,
-				               &pvt->info.max_dod);
+					       &pvt->info.max_dod);
 	pci_read_config_dword(pvt->pci_mcr[0], MC_CHANNEL_MAPPER,
 					       &pvt->info.ch_map);
 
@@ -373,10 +377,16 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 		pvt->info.mc_control, pvt->info.mc_status,
 		pvt->info.max_dod, pvt->info.ch_map);
 
-	if (ECC_ENABLED(pvt))
+	if (ECC_ENABLED(pvt)) {
 		debugf0("ECC enabled with x%d SDCC\n", ECCx8(pvt)?8:4);
-	else
+		if (ECCx8(pvt))
+			mode = EDAC_S8ECD8ED;
+		else
+			mode = EDAC_S4ECD4ED;
+	} else {
 		debugf0("ECC disabled\n");
+		mode = EDAC_NONE;
+	}
 
 	/* FIXME: need to handle the error codes */
 	debugf0("DOD Maximum limits: DIMMS: %d, %d-ranked, %d-banked\n",
@@ -411,13 +421,31 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 		else
 			pvt->channel[i].dimms = 2;
 
-		debugf0("Ch%d (0x%08x): rd ch %d, wr ch %d, "
-			"%d ranks, %d %cDIMMs\n",
-			i, data,
-			RDLCH(pvt->info.ch_map, i),
-			WRLCH(pvt->info.ch_map, i),
+		debugf0("Ch%d phy rd%d, wr%d (0x%08x): "
+			"%d ranks, %d %cDIMMs, offset = %d\n",
+			i,
+			RDLCH(pvt->info.ch_map, i), WRLCH(pvt->info.ch_map, i),
+			data,
 			pvt->channel[i].ranks, pvt->channel[i].dimms,
-			(data & REGISTERED_DIMM)? 'R' : 'U' );
+			(data & REGISTERED_DIMM)? 'R' : 'U',
+			RANKOFFSET(data));
+
+		csr = &mci->csrows[csrow];
+		csr->first_page = 0;
+		csr->last_page = 0;
+		csr->page_mask = 0;
+		csr->nr_pages = 0;
+		csr->grain = 0;
+		csr->csrow_idx = csrow;
+		csr->dtype = DEV_X8;	/* FIXME: check this */
+
+		if (data & REGISTERED_DIMM)
+			csr->mtype = MEM_RDDR3;
+		else
+			csr->mtype = MEM_DDR3;
+		csr->edac_mode = mode;
+
+		csrow++;
 	}
 
 	return 0;

commit ef708b53b98f2b53d9686a9f8f0b8d437952c295
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 22 22:48:30 2009 -0300

    i7core_edac: Add additional tests for error detection
    
    Properly check the number of channels and improve probing error detection
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index b5dbc2b83961..bfa462f6fa0e 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -189,6 +189,7 @@ struct i7core_pvt {
 	struct i7core_info	info;
 	struct i7core_inject	inject;
 	struct i7core_channel	channel[NUM_CHANS];
+	int			channels; /* Number of active channels */
 
 	int		ce_count_available;
 	unsigned long	ce_count[MAX_DIMMS];	/* ECC corrected errors counts per dimm */
@@ -259,12 +260,12 @@ static struct edac_pci_ctl_info *i7core_pci;
  ****************************************************************************/
 
 	/* MC_CONTROL bits */
-#define CH_ACTIVE(pvt, ch)	((pvt)->info.mc_control & 1 << (8 + ch))
-#define ECCx8(pvt)		((pvt)->info.mc_control & 1 << 1)
+#define CH_ACTIVE(pvt, ch)	((pvt)->info.mc_control & (1 << (8 + ch)))
+#define ECCx8(pvt)		((pvt)->info.mc_control & (1 << 1))
 
 	/* MC_STATUS bits */
-#define ECC_ENABLED(pvt)	((pvt)->info.mc_status & 1 << 3)
-#define CH_DISABLED(pvt, ch)	((pvt)->info.mc_status & 1 << ch)
+#define ECC_ENABLED(pvt)	((pvt)->info.mc_status & (1 << 3))
+#define CH_DISABLED(pvt, ch)	((pvt)->info.mc_status & (1 << ch))
 
 	/* MC_MAX_DOD read functions */
 static inline int maxnumdimms(struct i7core_pvt *pvt)
@@ -308,6 +309,48 @@ static inline int maxnumcol(struct i7core_pvt *pvt)
 /****************************************************************************
 			Memory check routines
  ****************************************************************************/
+static int i7core_get_active_channels(int *channels)
+{
+	struct pci_dev *pdev = NULL;
+	int i;
+	u32 status, control;
+
+	*channels = 0;
+
+	for (i = 0; i < N_DEVS; i++) {
+		if (!pci_devs[i].pdev)
+			continue;
+
+		if (PCI_SLOT(pci_devs[i].pdev->devfn) == 3 &&
+		    PCI_FUNC(pci_devs[i].pdev->devfn) == 0) {
+			pdev = pci_devs[i].pdev;
+			break;
+		}
+	}
+
+	if (!pdev)
+		return -ENODEV;
+
+	/* Device 3 function 0 reads */
+	pci_read_config_dword(pdev, MC_STATUS, &status);
+	pci_read_config_dword(pdev, MC_CONTROL, &control);
+
+	for (i = 0; i < NUM_CHANS; i++) {
+		/* Check if the channel is active */
+		if (!(control & (1 << (8 + i))))
+			continue;
+
+		/* Check if the channel is disabled */
+		if (status & (1 << i)) {
+			continue;
+		}
+
+		(*channels)++;
+	}
+
+	return 0;
+}
+
 static int get_dimm_config(struct mem_ctl_info *mci)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
@@ -852,69 +895,103 @@ static void i7core_put_devices(void)
  *
  *			Need to 'get' device 16 func 1 and func 2
  */
-static int i7core_get_devices(struct mem_ctl_info *mci, struct pci_dev *mcidev)
+static int i7core_get_devices(void)
 {
-	struct i7core_pvt *pvt = mci->pvt_info;
-	int rc, i,func;
+	int rc, i;
 	struct pci_dev *pdev = NULL;
 
-	pvt = mci->pvt_info;
-	memset(pvt, 0, sizeof(*pvt));
-
 	for (i = 0; i < N_DEVS; i++) {
 		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
 					pci_devs[i].dev_id, NULL);
-		if (!pdev) {
-			/* End of list, leave */
+		if (likely(pdev))
+			pci_devs[i].pdev = pdev;
+		else {
 			i7core_printk(KERN_ERR,
 				"Device not found: PCI ID %04x:%04x "
 				"(dev %d, func %d)\n",
 				PCI_VENDOR_ID_INTEL, pci_devs[i].dev_id,
 				pci_devs[i].dev,pci_devs[i].func);
+
+			/* Dev 3 function 2 only exists on chips with RDIMMs */
 			if ((pci_devs[i].dev == 3) && (pci_devs[i].func == 2))
-				continue; /* Only on chips with RDIMMs */
-			else
-				i7core_put_devices();
+				continue;
+
+			/* End of list, leave */
+			rc = -ENODEV;
+			goto error;
 		}
-		pci_devs[i].pdev = pdev;
 
-		rc = pci_enable_device(pdev);
-		if (rc < 0) {
+		/* Sanity check */
+		if (unlikely(PCI_SLOT(pdev->devfn) != pci_devs[i].dev ||
+			     PCI_FUNC(pdev->devfn) != pci_devs[i].func)) {
 			i7core_printk(KERN_ERR,
-				"Couldn't enable PCI ID %04x:%04x "
-				"(dev %d, func %d)\n",
+				"Device PCI ID %04x:%04x "
+				"has fn %d.%d instead of fn %d.%d\n",
 				PCI_VENDOR_ID_INTEL, pci_devs[i].dev_id,
+				PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),
 				pci_devs[i].dev, pci_devs[i].func);
-			i7core_put_devices();
-			return rc;
+			rc = -EINVAL;
+			goto error;
 		}
-		/* Sanity check */
-		if (PCI_FUNC(pdev->devfn) != pci_devs[i].func) {
+
+		/* Be sure that the device is enabled */
+		rc = pci_enable_device(pdev);
+		if (unlikely(rc < 0)) {
 			i7core_printk(KERN_ERR,
-				"Device PCI ID %04x:%04x "
-				"has function %d instead of %d\n",
+				"Couldn't enable PCI ID %04x:%04x "
+				"fn %d.%d\n",
 				PCI_VENDOR_ID_INTEL, pci_devs[i].dev_id,
-				PCI_FUNC(pdev->devfn), pci_devs[i].func);
-			i7core_put_devices();
-			return -EINVAL;
+				PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
+			goto error;
 		}
 
 		i7core_printk(KERN_INFO,
-				"Registered device %0x:%0x fn=%0x %0x\n",
+				"Registered device %0x:%0x fn %d.%d\n",
 				PCI_VENDOR_ID_INTEL, pci_devs[i].dev_id,
 				PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
+	}
+
+	return 0;
+
+error:
+	i7core_put_devices();
+	return -EINVAL;
+}
+
+static int mci_bind_devs(struct mem_ctl_info *mci)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	struct pci_dev *pdev;
+	int i, func, slot;
+
+	for (i = 0; i < N_DEVS; i++) {
+		pdev = pci_devs[i].pdev;
+		if (!pdev)
+			continue;
 
 		func = PCI_FUNC(pdev->devfn);
-		if (pci_devs[i].dev < 4) {
+		slot = PCI_SLOT(pdev->devfn);
+		if (slot == 3) {
+			if (unlikely(func > MAX_MCR_FUNC))
+				goto error;
 			pvt->pci_mcr[func] = pdev;
-		} else {
-			pvt->pci_ch[pci_devs[i].dev - 4][func] = pdev;
-		}
+		} else if (likely(slot >= 4 && slot < 4 + NUM_CHANS)) {
+			if (unlikely(func > MAX_CHAN_FUNC))
+				goto error;
+			pvt->pci_ch[slot - 4][func] = pdev;
+		} else
+			goto error;
+
+		debugf0("Associated fn %d.%d, dev = %p\n",
+			PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn), pdev);
 	}
-
-	i7core_printk(KERN_INFO, "Driver loaded.\n");
-
 	return 0;
+
+error:
+	i7core_printk(KERN_ERR, "Device %d, function %d "
+		      "is out of the expected range\n",
+		      slot, func);
+	return -EINVAL;
 }
 
 /****************************************************************************
@@ -1001,41 +1078,38 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 {
 	struct mem_ctl_info *mci;
 	struct i7core_pvt *pvt;
-	int num_channels;
+	int num_channels = 0;
 	int num_csrows;
-	int num_dimms_per_channel;
 	int dev_idx = id->driver_data;
 
-	if (dev_idx >= ARRAY_SIZE(i7core_devs))
+	if (unlikely(dev_idx >= ARRAY_SIZE(i7core_devs)))
 		return -EINVAL;
 
-	num_channels = NUM_CHANS;
+	/* get the pci devices we want to reserve for our use */
+	if (unlikely(i7core_get_devices() < 0))
+		return -ENODEV;
+
+	/* Check the number of active and not disabled channels */
+	if (unlikely (i7core_get_active_channels(&num_channels)) < 0)
+		goto fail0;
 
-	/* FIXME: FAKE data, since we currently don't now how to get this */
-	num_dimms_per_channel = 4;
-	num_csrows = num_dimms_per_channel;
+	/* FIXME: we currently don't know the number of csrows */
+	num_csrows = num_channels;
 
 	/* allocate a new MC control structure */
 	mci = edac_mc_alloc(sizeof(*pvt), num_csrows, num_channels, 0);
-	if (mci == NULL)
+	if (unlikely (!mci))
 		return -ENOMEM;
 
 	debugf0("MC: " __FILE__ ": %s(): mci = %p\n", __func__, mci);
 
-	/* 'get' the pci devices we want to reserve for our use */
-	if (i7core_get_devices(mci, pdev))
-		goto fail0;
-
 	mci->dev = &pdev->dev;	/* record ptr to the generic device */
 
 	pvt = mci->pvt_info;
-
-//	pvt->system_address = pdev;	/* Record this device in our private */
-//	pvt->maxch = num_channels;
-//	pvt->maxdimmperch = num_dimms_per_channel;
+	memset(pvt, 0, sizeof(*pvt));
 
 	mci->mc_idx = 0;
-	mci->mtype_cap = MEM_FLAG_FB_DDR2;	/* FIXME: it uses DDR3 */
+	mci->mtype_cap = MEM_FLAG_DDR3;		/* FIXME: how to handle RDDR3? */
 	mci->edac_ctl_cap = EDAC_FLAG_NONE;
 	mci->edac_cap = EDAC_FLAG_NONE;
 	mci->mod_name = "i7core_edac.c";
@@ -1044,12 +1118,18 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	mci->dev_name = pci_name(pdev);
 	mci->ctl_page_to_phys = NULL;
 	mci->mc_driver_sysfs_attributes = i7core_inj_attrs;
-
 	/* Set the function pointer to an actual operation function */
 	mci->edac_check = i7core_check_error;
 
+	/* Store pci devices at mci for faster access */
+	if (unlikely (mci_bind_devs(mci)) < 0)
+		goto fail1;
+
+	/* Get dimm basic config */
+	get_dimm_config(mci);
+
 	/* add this new MC control structure to EDAC's list of MCs */
-	if (edac_mc_add_mc(mci)) {
+	if (unlikely(edac_mc_add_mc(mci)) < 0) {
 		debugf0("MC: " __FILE__
 			": %s(): failed edac_mc_add_mc()\n", __func__);
 		/* FIXME: perhaps some code should go here that disables error
@@ -1060,7 +1140,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 
 	/* allocating generic PCI control info */
 	i7core_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);
-	if (!i7core_pci) {
+	if (unlikely (!i7core_pci)) {
 		printk(KERN_WARNING
 			"%s(): Unable to create PCI control\n",
 			__func__);
@@ -1070,15 +1150,14 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	}
 
 	/* Default error mask is any memory */
-	pvt->inject.channel = -1;
+	pvt->inject.channel = 0;
 	pvt->inject.dimm = -1;
 	pvt->inject.rank = -1;
 	pvt->inject.bank = -1;
 	pvt->inject.page = -1;
 	pvt->inject.col = -1;
 
-	/* Get dimm basic config */
-	get_dimm_config(mci);
+	i7core_printk(KERN_INFO, "Driver loaded.\n");
 
 	return 0;
 

commit 442305b152778f07504e9fdf64815d4841279bbe
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 22 22:48:29 2009 -0300

    i7core_edac: Add a memory check routine, based on device 3 function 4
    
    This function appears only on Xeon 5500 datasheet. Yet, testing with a
    Xeon 3503 showed that this is also implemented on other Nehalem
    processors.
    
    At the first read, MC_TEST_ERR_RCV1 and MC_TEST_ERR_RCV0 can contain any
    value. Modify CE error logic to update the error count only after the
    second read.
    
    An alternative approach would be to do a write at rcv0 and rcv1
    registers, but it seemed better to keep they untouched, since BIOS might
    eventually assume that they are exclusive for their usage.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 190596af601a..b5dbc2b83961 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -62,6 +62,18 @@
 #define MC_STATUS	0x4c
 #define MC_MAX_DOD	0x64
 
+/*
+ * OFFSETS for Device 3 Function 4, as inicated on Xeon 5500 datasheet:
+ * http://www.arrownac.com/manufacturers/intel/s/nehalem/5500-datasheet-v2.pdf
+ */
+
+#define MC_TEST_ERR_RCV1	0x60
+  #define DIMM2_COR_ERR(r)			((r) & 0x7fff)
+
+#define MC_TEST_ERR_RCV0	0x64
+  #define DIMM1_COR_ERR(r)			(((r) >> 16) & 0x7fff)
+  #define DIMM0_COR_ERR(r)			((r) & 0x7fff)
+
 	/* OFFSETS for Devices 4,5 and 6 Function 0 */
 
 #define MC_CHANNEL_DIMM_INIT_PARAMS 0x58
@@ -136,8 +148,9 @@
  */
 
 #define NUM_CHANS 3
-#define NUM_MCR_FUNCS  4
-#define NUM_CHAN_FUNCS 3
+#define MAX_DIMMS 3		/* Max DIMMS per channel */
+#define MAX_MCR_FUNC  4
+#define MAX_CHAN_FUNC 3
 
 struct i7core_info {
 	u32	mc_control;
@@ -159,8 +172,8 @@ struct i7core_inject {
 };
 
 struct i7core_channel {
-	u32 ranks;
-	u32 dimms;
+	u32		ranks;
+	u32		dimms;
 };
 
 struct pci_id_descr {
@@ -171,11 +184,16 @@ struct pci_id_descr {
 };
 
 struct i7core_pvt {
-	struct pci_dev		*pci_mcr[NUM_MCR_FUNCS];
-	struct pci_dev		*pci_ch[NUM_CHANS][NUM_CHAN_FUNCS];
+	struct pci_dev		*pci_mcr[MAX_MCR_FUNC + 1];
+	struct pci_dev		*pci_ch[NUM_CHANS][MAX_CHAN_FUNC + 1];
 	struct i7core_info	info;
 	struct i7core_inject	inject;
 	struct i7core_channel	channel[NUM_CHANS];
+
+	int		ce_count_available;
+	unsigned long	ce_count[MAX_DIMMS];	/* ECC corrected errors counts per dimm */
+	int		last_ce_count[MAX_DIMMS];
+
 };
 
 /* Device name and register DID (Device ID) */
@@ -749,6 +767,19 @@ static ssize_t i7core_inject_enable_show(struct mem_ctl_info *mci,
 	return sprintf(data, "%d\n", pvt->inject.enable);
 }
 
+static ssize_t i7core_ce_regs_show(struct mem_ctl_info *mci, char *data)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+
+	if (!pvt->ce_count_available)
+		return sprintf(data, "unavailable\n");
+
+	return sprintf(data, "dimm0: %lu\ndimm1: %lu\ndimm2: %lu\n",
+			pvt->ce_count[0],
+			pvt->ce_count[1],
+			pvt->ce_count[2]);
+}
+
 /*
  * Sysfs struct
  */
@@ -789,6 +820,13 @@ static struct mcidev_sysfs_attribute i7core_inj_attrs[] = {
 		},
 		.show  = i7core_inject_enable_show,
 		.store = i7core_inject_enable_store,
+	}, {
+		.attr = {
+			.name = "corrected_error_counts",
+			.mode = (S_IRUGO | S_IWUSR)
+		},
+		.show  = i7core_ce_regs_show,
+		.store = NULL,
 	},
 };
 
@@ -879,13 +917,76 @@ static int i7core_get_devices(struct mem_ctl_info *mci, struct pci_dev *mcidev)
 	return 0;
 }
 
+/****************************************************************************
+			Error check routines
+ ****************************************************************************/
+
+/* This function is based on the device 3 function 4 registers as described on:
+ * Intel Xeon Processor 5500 Series Datasheet Volume 2
+ *	http://www.intel.com/Assets/PDF/datasheet/321322.pdf
+ * also available at:
+ * 	http://www.arrownac.com/manufacturers/intel/s/nehalem/5500-datasheet-v2.pdf
+ */
+static void check_mc_test_err(struct mem_ctl_info *mci)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	u32 rcv1, rcv0;
+	int new0, new1, new2;
+
+	if (!pvt->pci_mcr[4]) {
+		debugf0("%s MCR registers not found\n",__func__);
+		return;
+	}
+
+	/* Corrected error reads */
+	pci_read_config_dword(pvt->pci_mcr[4], MC_TEST_ERR_RCV1, &rcv1);
+	pci_read_config_dword(pvt->pci_mcr[4], MC_TEST_ERR_RCV0, &rcv0);
+
+	/* Store the new values */
+	new2 = DIMM2_COR_ERR(rcv1);
+	new1 = DIMM1_COR_ERR(rcv0);
+	new0 = DIMM0_COR_ERR(rcv0);
+
+	debugf2("%s CE rcv1=0x%08x rcv0=0x%08x, %d %d %d\n",
+		(pvt->ce_count_available ? "UPDATE" : "READ"),
+		rcv1, rcv0, new0, new1, new2);
+
+	/* Updates CE counters if it is not the first time here */
+	if (pvt->ce_count_available) {
+		/* Updates CE counters */
+		int add0, add1, add2;
+
+		add2 = new2 - pvt->last_ce_count[2];
+		add1 = new1 - pvt->last_ce_count[1];
+		add0 = new0 - pvt->last_ce_count[0];
+
+		if (add2 < 0)
+			add2 += 0x7fff;
+		pvt->ce_count[2] += add2;
+
+		if (add1 < 0)
+			add1 += 0x7fff;
+		pvt->ce_count[1] += add1;
+
+		if (add0 < 0)
+			add0 += 0x7fff;
+		pvt->ce_count[0] += add0;
+	} else
+		pvt->ce_count_available = 1;
+
+	/* Store the new values */
+	pvt->last_ce_count[2] = new2;
+	pvt->last_ce_count[1] = new1;
+	pvt->last_ce_count[0] = new0;
+}
+
 /*
  *	i7core_check_error	Retrieve and process errors reported by the
  *				hardware. Called by the Core module.
  */
 static void i7core_check_error(struct mem_ctl_info *mci)
 {
-	/* FIXME: need a real code here */
+	check_mc_test_err(mci);
 }
 
 /*

commit 87d1d272ba25a1863e40ebb1df4bc0eed7a8fd11
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 22 22:48:29 2009 -0300

    i7core_edac: need mci->edac_check, otherwise module removal doesn't work
    
    There are some locking troubles with edac_core: if you don't declare an
    edac_check, module may suffer from soft lock.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 0c17db673065..190596af601a 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -879,6 +879,15 @@ static int i7core_get_devices(struct mem_ctl_info *mci, struct pci_dev *mcidev)
 	return 0;
 }
 
+/*
+ *	i7core_check_error	Retrieve and process errors reported by the
+ *				hardware. Called by the Core module.
+ */
+static void i7core_check_error(struct mem_ctl_info *mci)
+{
+	/* FIXME: need a real code here */
+}
+
 /*
  *	i7core_probe	Probe for ONE instance of device to see if it is
  *			present.
@@ -912,8 +921,11 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 
 	debugf0("MC: " __FILE__ ": %s(): mci = %p\n", __func__, mci);
 
+	/* 'get' the pci devices we want to reserve for our use */
+	if (i7core_get_devices(mci, pdev))
+		goto fail0;
+
 	mci->dev = &pdev->dev;	/* record ptr to the generic device */
-	dev_set_drvdata(mci->dev, mci);
 
 	pvt = mci->pvt_info;
 
@@ -932,9 +944,8 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	mci->ctl_page_to_phys = NULL;
 	mci->mc_driver_sysfs_attributes = i7core_inj_attrs;
 
-	/* 'get' the pci devices we want to reserve for our use */
-	if (i7core_get_devices(mci, pdev))
-		goto fail0;
+	/* Set the function pointer to an actual operation function */
+	mci->edac_check = i7core_check_error;
 
 	/* add this new MC control structure to EDAC's list of MCs */
 	if (edac_mc_add_mc(mci)) {
@@ -992,6 +1003,7 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 		edac_pci_release_generic_ctl(i7core_pci);
 
 	mci = edac_mc_del_mc(&pdev->dev);
+
 	if (!mci)
 		return;
 

commit 7b029d03c36e5b06e067884aaefcee2c1c62efc7
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 22 22:48:29 2009 -0300

    i7core_edac: A few fixes at error injection code
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 09a0998e1c3f..0c17db673065 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -30,6 +30,8 @@
 
 #include "edac_core.h"
 
+/* To use the new pci_[read/write]_config_qword instead of two dword */
+#define USE_QWORD 1
 
 /*
  * Alter this version for the module when modifications are made
@@ -639,44 +641,71 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 
 	/* Sets pvt->inject.dimm mask */
 	if (pvt->inject.dimm < 0)
-		mask |= 1l << 41;
+		mask |= 1L << 41;
 	else {
 		if (pvt->channel[pvt->inject.channel].dimms > 2)
-			mask |= (pvt->inject.dimm & 0x3l) << 35;
+			mask |= (pvt->inject.dimm & 0x3L) << 35;
 		else
-			mask |= (pvt->inject.dimm & 0x1l) << 36;
+			mask |= (pvt->inject.dimm & 0x1L) << 36;
 	}
 
 	/* Sets pvt->inject.rank mask */
 	if (pvt->inject.rank < 0)
-		mask |= 1l << 40;
+		mask |= 1L << 40;
 	else {
 		if (pvt->channel[pvt->inject.channel].dimms > 2)
-			mask |= (pvt->inject.rank & 0x1l) << 34;
+			mask |= (pvt->inject.rank & 0x1L) << 34;
 		else
-			mask |= (pvt->inject.rank & 0x3l) << 34;
+			mask |= (pvt->inject.rank & 0x3L) << 34;
 	}
 
 	/* Sets pvt->inject.bank mask */
 	if (pvt->inject.bank < 0)
-		mask |= 1l << 39;
+		mask |= 1L << 39;
 	else
-		mask |= (pvt->inject.bank & 0x15l) << 30;
+		mask |= (pvt->inject.bank & 0x15L) << 30;
 
 	/* Sets pvt->inject.page mask */
 	if (pvt->inject.page < 0)
-		mask |= 1l << 38;
+		mask |= 1L << 38;
 	else
-		mask |= (pvt->inject.page & 0xffffl) << 14;
+		mask |= (pvt->inject.page & 0xffffL) << 14;
 
 	/* Sets pvt->inject.column mask */
 	if (pvt->inject.col < 0)
-		mask |= 1l << 37;
+		mask |= 1L << 37;
 	else
-		mask |= (pvt->inject.col & 0x3fffl);
+		mask |= (pvt->inject.col & 0x3fffL);
 
+#if USE_QWORD
 	pci_write_config_qword(pvt->pci_ch[pvt->inject.channel][0],
 			       MC_CHANNEL_ADDR_MATCH, mask);
+#else
+	pci_write_config_dword(pvt->pci_ch[pvt->inject.channel][0],
+			       MC_CHANNEL_ADDR_MATCH, mask);
+	pci_write_config_dword(pvt->pci_ch[pvt->inject.channel][0],
+			       MC_CHANNEL_ADDR_MATCH + 4, mask >> 32L);
+#endif
+
+#if 1
+#if USE_QWORD
+	u64 rdmask;
+	pci_read_config_qword(pvt->pci_ch[pvt->inject.channel][0],
+			       MC_CHANNEL_ADDR_MATCH, &rdmask);
+	debugf0("Inject addr match write 0x%016llx, read: 0x%016llx\n",
+		mask, rdmask);
+#else
+	u32 rdmask1, rdmask2;
+
+	pci_read_config_dword(pvt->pci_ch[pvt->inject.channel][0],
+			       MC_CHANNEL_ADDR_MATCH, &rdmask1);
+	pci_read_config_dword(pvt->pci_ch[pvt->inject.channel][0],
+			       MC_CHANNEL_ADDR_MATCH + 4, &rdmask2);
+
+	debugf0("Inject addr match write 0x%016llx, read: 0x%08x%08x\n",
+		mask, rdmask1, rdmask2);
+#endif
+#endif
 
 	pci_write_config_dword(pvt->pci_ch[pvt->inject.channel][0],
 			       MC_CHANNEL_ERROR_MASK, pvt->inject.eccmask);
@@ -688,17 +717,18 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 	 * bit    4: INJECT_ADDR_PARITY
 	 */
 
-	injectmask = (pvt->inject.type & 1) &&
-		     (pvt->inject.section & 0x3) << 1 &&
+	injectmask = (pvt->inject.type & 1) |
+		     (pvt->inject.section & 0x3) << 1 |
 		     (pvt->inject.type & 0x6) << (3 - 1);
 
 	pci_write_config_dword(pvt->pci_ch[pvt->inject.channel][0],
 			       MC_CHANNEL_ERROR_MASK, injectmask);
 
-
 	debugf0("Error inject addr match 0x%016llx, ecc 0x%08x, inject 0x%08x\n",
 		mask, pvt->inject.eccmask, injectmask);
 
+
+
 	return count;
 }
 
@@ -706,6 +736,16 @@ static ssize_t i7core_inject_enable_show(struct mem_ctl_info *mci,
 					char *data)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
+	u32 injectmask;
+
+	pci_read_config_dword(pvt->pci_ch[pvt->inject.channel][0],
+			       MC_CHANNEL_ERROR_MASK, &injectmask);
+
+	debugf0("Inject error read: 0x%018x\n", injectmask);
+
+	if (injectmask & 0x0c)
+		pvt->inject.enable = 1;
+
 	return sprintf(data, "%d\n", pvt->inject.enable);
 }
 

commit f122a89222510e8f57e8e0b9b5cdd3ec8863fe4c
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 22 22:48:29 2009 -0300

    i7core_edac: Show read/write virtual/physical channel association
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 79aa84eaa12d..09a0998e1c3f 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -68,6 +68,10 @@
   #define QUAD_RANK_PRESENT		(1 << 22)
   #define REGISTERED_DIMM		(1 << 15)
 
+#define MC_CHANNEL_MAPPER	0x60
+  #define RDLCH(r, ch)		((((r) >> (3 + (ch * 6))) & 0x07) - 1)
+  #define WRLCH(r, ch)		((((r) >> (ch * 6)) & 0x07) - 1)
+
 #define MC_CHANNEL_RANK_PRESENT 0x7c
   #define RANK_PRESENT_MASK		0xffff
 
@@ -100,6 +104,8 @@
   #define NUMCOL_MASK		3
   #define NUMCOL(x)		((x) & NUMCOL_MASK)
 
+#define MC_RANK_PRESENT		0x7c
+
 #define MC_SAG_CH_0	0x80
 #define MC_SAG_CH_1	0x84
 #define MC_SAG_CH_2	0x88
@@ -135,6 +141,7 @@ struct i7core_info {
 	u32	mc_control;
 	u32	mc_status;
 	u32	max_dod;
+	u32	ch_map;
 };
 
 
@@ -289,9 +296,19 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 	if (!pvt->pci_mcr[0])
 		return -ENODEV;
 
-	pci_read_config_dword(pvt->pci_mcr[0], MC_CONTROL, &pvt->info.mc_control);
-	pci_read_config_dword(pvt->pci_mcr[0], MC_STATUS, &pvt->info.mc_status);
-	pci_read_config_dword(pvt->pci_mcr[0], MC_MAX_DOD, &pvt->info.max_dod);
+	/* Device 3 function 0 reads */
+	pci_read_config_dword(pvt->pci_mcr[0], MC_CONTROL,
+					       &pvt->info.mc_control);
+	pci_read_config_dword(pvt->pci_mcr[0], MC_STATUS,
+					       &pvt->info.mc_status);
+	pci_read_config_dword(pvt->pci_mcr[0], MC_MAX_DOD,
+				               &pvt->info.max_dod);
+	pci_read_config_dword(pvt->pci_mcr[0], MC_CHANNEL_MAPPER,
+					       &pvt->info.ch_map);
+
+	debugf0("MC control=0x%08x status=0x%08x dod=0x%08x map=0x%08x\n",
+		pvt->info.mc_control, pvt->info.mc_status,
+		pvt->info.max_dod, pvt->info.ch_map);
 
 	if (ECC_ENABLED(pvt))
 		debugf0("ECC enabled with x%d SDCC\n", ECCx8(pvt)?8:4);
@@ -318,6 +335,7 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 			continue;
 		}
 
+		/* Devices 4-6 function 0 */
 		pci_read_config_dword(pvt->pci_ch[i][0],
 				MC_CHANNEL_DIMM_INIT_PARAMS, &data);
 
@@ -330,10 +348,13 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 		else
 			pvt->channel[i].dimms = 2;
 
-		debugf0("Channel %d (0x%08x): %d ranks, %d dimms "
-			"(%sregistered)\n", i, data,
+		debugf0("Ch%d (0x%08x): rd ch %d, wr ch %d, "
+			"%d ranks, %d %cDIMMs\n",
+			i, data,
+			RDLCH(pvt->info.ch_map, i),
+			WRLCH(pvt->info.ch_map, i),
 			pvt->channel[i].ranks, pvt->channel[i].dimms,
-			(data & REGISTERED_DIMM)? "" : "un" );
+			(data & REGISTERED_DIMM)? 'R' : 'U' );
 	}
 
 	return 0;

commit 8f331907578623f90a134261a559fa3249142caa
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 22 22:48:29 2009 -0300

    i7core_edac: Registers all supported MC functions
    
    Now, it will try to register on all supported Memory Controller
    functions.
    
    It should be noticed that dev3, function 2 is present only on chips with
    Registered DIMM's, according to the datasheet. So, the driver doesn't
    return -ENODEV is all functions but this one were successfully
    registered and enabled:
    
        EDAC i7core: Registered device 8086:2c18 fn=3 0
        EDAC i7core: Registered device 8086:2c19 fn=3 1
        EDAC i7core: Device not found: PCI ID 8086:2c1a (dev 3, func 2)
        EDAC i7core: Registered device 8086:2c1c fn=3 4
        EDAC i7core: Registered device 8086:2c20 fn=4 0
        EDAC i7core: Registered device 8086:2c21 fn=4 1
        EDAC i7core: Registered device 8086:2c22 fn=4 2
        EDAC i7core: Registered device 8086:2c23 fn=4 3
        EDAC i7core: Registered device 8086:2c28 fn=5 0
        EDAC i7core: Registered device 8086:2c29 fn=5 1
        EDAC i7core: Registered device 8086:2c2a fn=5 2
        EDAC i7core: Registered device 8086:2c2b fn=5 3
        EDAC i7core: Registered device 8086:2c30 fn=6 0
        EDAC i7core: Registered device 8086:2c31 fn=6 1
        EDAC i7core: Registered device 8086:2c32 fn=6 2
        EDAC i7core: Registered device 8086:2c33 fn=6 3
        EDAC i7core: Driver loaded.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index da40730bf9c9..79aa84eaa12d 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -128,7 +128,8 @@
  */
 
 #define NUM_CHANS 3
-#define NUM_FUNCS 1
+#define NUM_MCR_FUNCS  4
+#define NUM_CHAN_FUNCS 3
 
 struct i7core_info {
 	u32	mc_control;
@@ -153,9 +154,16 @@ struct i7core_channel {
 	u32 dimms;
 };
 
+struct pci_id_descr {
+	int		dev;
+	int		func;
+	int 		dev_id;
+	struct pci_dev	*pdev;
+};
+
 struct i7core_pvt {
-	struct pci_dev		*pci_mcr;	/* Dev 3:0 */
-	struct pci_dev		*pci_ch[NUM_CHANS][NUM_FUNCS];
+	struct pci_dev		*pci_mcr[NUM_MCR_FUNCS];
+	struct pci_dev		*pci_ch[NUM_CHANS][NUM_CHAN_FUNCS];
 	struct i7core_info	info;
 	struct i7core_inject	inject;
 	struct i7core_channel	channel[NUM_CHANS];
@@ -167,11 +175,47 @@ struct i7core_dev_info {
 	u16 fsb_mapping_errors;	/* DID for the branchmap,control */
 };
 
-static int chan_pci_ids[NUM_CHANS] = {
-	PCI_DEVICE_ID_INTEL_I7_MC_CH0_CTRL,	/* Dev 4 */
-	PCI_DEVICE_ID_INTEL_I7_MC_CH1_CTRL,	/* Dev 5 */
-	PCI_DEVICE_ID_INTEL_I7_MC_CH2_CTRL,	/* Dev 6 */
+#define PCI_DESCR(device, function, device_id)	\
+	.dev = (device),			\
+	.func = (function),			\
+	.dev_id = (device_id)
+
+struct pci_id_descr pci_devs[] = {
+		/* Memory controller */
+	{ PCI_DESCR(3, 0, PCI_DEVICE_ID_INTEL_I7_MCR)     },
+	{ PCI_DESCR(3, 1, PCI_DEVICE_ID_INTEL_I7_MC_TAD)  },
+	{ PCI_DESCR(3, 2, PCI_DEVICE_ID_INTEL_I7_MC_RAS)  }, /* if RDIMM is supported */
+	{ PCI_DESCR(3, 4, PCI_DEVICE_ID_INTEL_I7_MC_TEST) },
+
+		/* Channel 0 */
+	{ PCI_DESCR(4, 0, PCI_DEVICE_ID_INTEL_I7_MC_CH0_CTRL) },
+	{ PCI_DESCR(4, 1, PCI_DEVICE_ID_INTEL_I7_MC_CH0_ADDR) },
+	{ PCI_DESCR(4, 2, PCI_DEVICE_ID_INTEL_I7_MC_CH0_RANK) },
+	{ PCI_DESCR(4, 3, PCI_DEVICE_ID_INTEL_I7_MC_CH0_TC)   },
+
+		/* Channel 1 */
+	{ PCI_DESCR(5, 0, PCI_DEVICE_ID_INTEL_I7_MC_CH1_CTRL) },
+	{ PCI_DESCR(5, 1, PCI_DEVICE_ID_INTEL_I7_MC_CH1_ADDR) },
+	{ PCI_DESCR(5, 2, PCI_DEVICE_ID_INTEL_I7_MC_CH1_RANK) },
+	{ PCI_DESCR(5, 3, PCI_DEVICE_ID_INTEL_I7_MC_CH1_TC)   },
+
+		/* Channel 2 */
+	{ PCI_DESCR(6, 0, PCI_DEVICE_ID_INTEL_I7_MC_CH2_CTRL) },
+	{ PCI_DESCR(6, 1, PCI_DEVICE_ID_INTEL_I7_MC_CH2_ADDR) },
+	{ PCI_DESCR(6, 2, PCI_DEVICE_ID_INTEL_I7_MC_CH2_RANK) },
+	{ PCI_DESCR(6, 3, PCI_DEVICE_ID_INTEL_I7_MC_CH2_TC)   },
 };
+#define N_DEVS ARRAY_SIZE(pci_devs)
+
+/*
+ *	pci_device_id	table for which devices we are looking for
+ * This should match the first device at pci_devs table
+ */
+static const struct pci_device_id i7core_pci_tbl[] __devinitdata = {
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I7_MCR)},
+	{0,}			/* 0 terminated list. */
+};
+
 
 /* Table of devices attributes supported by this driver */
 static const struct i7core_dev_info i7core_devs[] = {
@@ -242,9 +286,12 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 	struct i7core_pvt *pvt = mci->pvt_info;
 	int i;
 
-	pci_read_config_dword(pvt->pci_mcr, MC_CONTROL, &pvt->info.mc_control);
-	pci_read_config_dword(pvt->pci_mcr, MC_STATUS, &pvt->info.mc_status);
-	pci_read_config_dword(pvt->pci_mcr, MC_MAX_DOD, &pvt->info.max_dod);
+	if (!pvt->pci_mcr[0])
+		return -ENODEV;
+
+	pci_read_config_dword(pvt->pci_mcr[0], MC_CONTROL, &pvt->info.mc_control);
+	pci_read_config_dword(pvt->pci_mcr[0], MC_STATUS, &pvt->info.mc_status);
+	pci_read_config_dword(pvt->pci_mcr[0], MC_MAX_DOD, &pvt->info.max_dod);
 
 	if (ECC_ENABLED(pvt))
 		debugf0("ECC enabled with x%d SDCC\n", ECCx8(pvt)?8:4);
@@ -303,14 +350,19 @@ static int get_dimm_config(struct mem_ctl_info *mci)
    we're disabling error injection on all write calls to the sysfs nodes that
    controls the error code injection.
  */
-static void disable_inject(struct mem_ctl_info *mci)
+static int disable_inject(struct mem_ctl_info *mci)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
 
 	pvt->inject.enable = 0;
 
+	if (!pvt->pci_ch[pvt->inject.channel][0])
+		return -ENODEV;
+
 	pci_write_config_dword(pvt->pci_ch[pvt->inject.channel][0],
 				MC_CHANNEL_ERROR_MASK, 0);
+
+	return 0;
 }
 
 /*
@@ -550,6 +602,9 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 	int  rc;
 	long enable;
 
+	if (!pvt->pci_ch[pvt->inject.channel][0])
+		return 0;
+
 	rc = strict_strtoul(data, 10, &enable);
 	if ((rc < 0))
 		return 0;
@@ -684,17 +739,12 @@ static struct mcidev_sysfs_attribute i7core_inj_attrs[] = {
  *	i7core_put_devices	'put' all the devices that we have
  *				reserved via 'get'
  */
-static void i7core_put_devices(struct mem_ctl_info *mci)
+static void i7core_put_devices(void)
 {
-	struct i7core_pvt *pvt = mci->pvt_info;
-	int i, n;
-
-	pci_dev_put(pvt->pci_mcr);
+	int i;
 
-	/* Release all PCI device functions at MTR channel controllers */
-	for (i = 0; i < NUM_CHANS; i++)
-		for (n = 0; n < NUM_FUNCS; n++)
-			pci_dev_put(pvt->pci_ch[i][n]);
+	for (i = 0; i < N_DEVS; i++)
+		pci_dev_put(pci_devs[i].pdev);
 }
 
 /*
@@ -703,50 +753,67 @@ static void i7core_put_devices(struct mem_ctl_info *mci)
  *
  *			Need to 'get' device 16 func 1 and func 2
  */
-static int i7core_get_devices(struct mem_ctl_info *mci, int dev_idx)
+static int i7core_get_devices(struct mem_ctl_info *mci, struct pci_dev *mcidev)
 {
-	struct i7core_pvt *pvt;
-	struct pci_dev *pdev;
-	int i, n, func;
+	struct i7core_pvt *pvt = mci->pvt_info;
+	int rc, i,func;
+	struct pci_dev *pdev = NULL;
 
 	pvt = mci->pvt_info;
 	memset(pvt, 0, sizeof(*pvt));
 
-	pdev = pci_get_device(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I7_MCR,
-			      NULL);
-	if (!pdev) {
-		i7core_printk(KERN_ERR,
-			"Couldn't get PCI ID %04x:%04x function 0\n",
-			PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I7_MCR);
-		return -ENODEV;
-	}
-	pvt->pci_mcr=pdev;
+	for (i = 0; i < N_DEVS; i++) {
+		pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
+					pci_devs[i].dev_id, NULL);
+		if (!pdev) {
+			/* End of list, leave */
+			i7core_printk(KERN_ERR,
+				"Device not found: PCI ID %04x:%04x "
+				"(dev %d, func %d)\n",
+				PCI_VENDOR_ID_INTEL, pci_devs[i].dev_id,
+				pci_devs[i].dev,pci_devs[i].func);
+			if ((pci_devs[i].dev == 3) && (pci_devs[i].func == 2))
+				continue; /* Only on chips with RDIMMs */
+			else
+				i7core_put_devices();
+		}
+		pci_devs[i].pdev = pdev;
+
+		rc = pci_enable_device(pdev);
+		if (rc < 0) {
+			i7core_printk(KERN_ERR,
+				"Couldn't enable PCI ID %04x:%04x "
+				"(dev %d, func %d)\n",
+				PCI_VENDOR_ID_INTEL, pci_devs[i].dev_id,
+				pci_devs[i].dev, pci_devs[i].func);
+			i7core_put_devices();
+			return rc;
+		}
+		/* Sanity check */
+		if (PCI_FUNC(pdev->devfn) != pci_devs[i].func) {
+			i7core_printk(KERN_ERR,
+				"Device PCI ID %04x:%04x "
+				"has function %d instead of %d\n",
+				PCI_VENDOR_ID_INTEL, pci_devs[i].dev_id,
+				PCI_FUNC(pdev->devfn), pci_devs[i].func);
+			i7core_put_devices();
+			return -EINVAL;
+		}
 
-	/* Retrieve all needed functions at MTR channel controllers */
-	for (i = 0; i < NUM_CHANS; i++) {
-		pdev = NULL;
-		for (n = 0; n < NUM_FUNCS; n++) {
-			pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
-					      chan_pci_ids[i], pdev);
-			if (!pdev) {
-				/* End of list, leave */
-				i7core_printk(KERN_ERR,
-					"Device not found: PCI ID %04x:%04x "
-					"found only %d functions "
-					"(broken BIOS?)\n",
-					PCI_VENDOR_ID_INTEL,
-					chan_pci_ids[i], n);
-				i7core_put_devices(mci);
-				return -ENODEV;
-			}
-			func = PCI_FUNC(pdev->devfn);
-			pvt->pci_ch[i][func] = pdev;
+		i7core_printk(KERN_INFO,
+				"Registered device %0x:%0x fn=%0x %0x\n",
+				PCI_VENDOR_ID_INTEL, pci_devs[i].dev_id,
+				PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
+
+		func = PCI_FUNC(pdev->devfn);
+		if (pci_devs[i].dev < 4) {
+			pvt->pci_mcr[func] = pdev;
+		} else {
+			pvt->pci_ch[pci_devs[i].dev - 4][func] = pdev;
 		}
 	}
-	i7core_printk(KERN_INFO, "Driver loaded.\n");
 
-	/* Get dimm basic config */
-	get_dimm_config(mci);
+	i7core_printk(KERN_INFO, "Driver loaded.\n");
 
 	return 0;
 }
@@ -763,7 +830,6 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 {
 	struct mem_ctl_info *mci;
 	struct i7core_pvt *pvt;
-	int rc;
 	int num_channels;
 	int num_csrows;
 	int num_dimms_per_channel;
@@ -772,20 +838,6 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	if (dev_idx >= ARRAY_SIZE(i7core_devs))
 		return -EINVAL;
 
-	/* wake up device */
-	rc = pci_enable_device(pdev);
-	if (rc == -EIO)
-		return rc;
-
-	debugf0("MC: " __FILE__ ": %s(), pdev bus %u dev=0x%x fn=0x%x\n",
-		__func__,
-		pdev->bus->number,
-		PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
-
-	/* We only are looking for func 0 of the set */
-	if (PCI_FUNC(pdev->devfn) != 0)
-		return -ENODEV;
-
 	num_channels = NUM_CHANS;
 
 	/* FIXME: FAKE data, since we currently don't now how to get this */
@@ -808,10 +860,6 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 //	pvt->maxch = num_channels;
 //	pvt->maxdimmperch = num_dimms_per_channel;
 
-	/* 'get' the pci devices we want to reserve for our use */
-	if (i7core_get_devices(mci, dev_idx))
-		goto fail0;
-
 	mci->mc_idx = 0;
 	mci->mtype_cap = MEM_FLAG_FB_DDR2;	/* FIXME: it uses DDR3 */
 	mci->edac_ctl_cap = EDAC_FLAG_NONE;
@@ -823,6 +871,10 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	mci->ctl_page_to_phys = NULL;
 	mci->mc_driver_sysfs_attributes = i7core_inj_attrs;
 
+	/* 'get' the pci devices we want to reserve for our use */
+	if (i7core_get_devices(mci, pdev))
+		goto fail0;
+
 	/* add this new MC control structure to EDAC's list of MCs */
 	if (edac_mc_add_mc(mci)) {
 		debugf0("MC: " __FILE__
@@ -852,10 +904,13 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	pvt->inject.page = -1;
 	pvt->inject.col = -1;
 
+	/* Get dimm basic config */
+	get_dimm_config(mci);
+
 	return 0;
 
 fail1:
-	i7core_put_devices(mci);
+	i7core_put_devices();
 
 fail0:
 	edac_mc_free(mci);
@@ -880,21 +935,11 @@ static void __devexit i7core_remove(struct pci_dev *pdev)
 		return;
 
 	/* retrieve references to resources, and free those resources */
-	i7core_put_devices(mci);
+	i7core_put_devices();
 
 	edac_mc_free(mci);
 }
 
-/*
- *	pci_device_id	table for which devices we are looking for
- *
- *	The "E500P" device is the first device supported.
- */
-static const struct pci_device_id i7core_pci_tbl[] __devinitdata = {
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I7_MCR)},
-	{0,}			/* 0 terminated list. */
-};
-
 MODULE_DEVICE_TABLE(pci, i7core_pci_tbl);
 
 /*

commit 0b2b7b7ec06ce615acd11374bf9a512e166dabb0
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 22 22:48:29 2009 -0300

    i7core_edac: Add more status functions to EDAC driver
    
    This patch were co-authored with Aristeu Rozanski.
    
    Signed-off-by: Aristeu Sergio <arozansk@redhat.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index b590f8468693..da40730bf9c9 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -62,6 +62,15 @@
 
 	/* OFFSETS for Devices 4,5 and 6 Function 0 */
 
+#define MC_CHANNEL_DIMM_INIT_PARAMS 0x58
+  #define THREE_DIMMS_PRESENT		(1 << 24)
+  #define SINGLE_QUAD_RANK_PRESENT	(1 << 23)
+  #define QUAD_RANK_PRESENT		(1 << 22)
+  #define REGISTERED_DIMM		(1 << 15)
+
+#define MC_CHANNEL_RANK_PRESENT 0x7c
+  #define RANK_PRESENT_MASK		0xffff
+
 #define MC_CHANNEL_ADDR_MATCH	0xf0
 #define MC_CHANNEL_ERROR_MASK	0xf8
 #define MC_CHANNEL_ERROR_INJECT	0xfc
@@ -74,6 +83,46 @@
   #define NO_MASK_CACHELINE	0x00
   #define REPEAT_EN		0x01
 
+	/* OFFSETS for Devices 4,5 and 6 Function 1 */
+#define MC_DOD_CH_DIMM0		0x48
+#define MC_DOD_CH_DIMM1		0x4c
+#define MC_DOD_CH_DIMM2		0x50
+  #define RANKOFFSET_MASK	((1 << 12) | (1 << 11) | (1 << 10))
+  #define RANKOFFSET(x)		((x & RANKOFFSET_MASK) >> 10)
+  #define DIMM_PRESENT_MASK	(1 << 9)
+  #define DIMM_PRESENT(x)	(((x) & DIMM_PRESENT_MASK) >> 9)
+  #define NUMBANK_MASK		((1 << 8) | (1 << 7))
+  #define NUMBANK(x)		(((x) & NUMBANK_MASK) >> 7)
+  #define NUMRANK_MASK		((1 << 6) | (1 << 5))
+  #define NUMRANK(x)		(((x) & NUMRANK_MASK) >> 5)
+  #define NUMROW_MASK		((1 << 4) | (1 << 3))
+  #define NUMROW(x)		(((x) & NUMROW_MASK) >> 3)
+  #define NUMCOL_MASK		3
+  #define NUMCOL(x)		((x) & NUMCOL_MASK)
+
+#define MC_SAG_CH_0	0x80
+#define MC_SAG_CH_1	0x84
+#define MC_SAG_CH_2	0x88
+#define MC_SAG_CH_3	0x8c
+#define MC_SAG_CH_4	0x90
+#define MC_SAG_CH_5	0x94
+#define MC_SAG_CH_6	0x98
+#define MC_SAG_CH_7	0x9c
+
+#define MC_RIR_LIMIT_CH_0	0x40
+#define MC_RIR_LIMIT_CH_1	0x44
+#define MC_RIR_LIMIT_CH_2	0x48
+#define MC_RIR_LIMIT_CH_3	0x4C
+#define MC_RIR_LIMIT_CH_4	0x50
+#define MC_RIR_LIMIT_CH_5	0x54
+#define MC_RIR_LIMIT_CH_6	0x58
+#define MC_RIR_LIMIT_CH_7	0x5C
+#define MC_RIR_LIMIT_MASK	((1 << 10) - 1)
+
+#define MC_RIR_WAY_CH		0x80
+  #define MC_RIR_WAY_OFFSET_MASK	(((1 << 14) - 1) & ~0x7)
+  #define MC_RIR_WAY_RANK_MASK		0x7
+
 /*
  * i7core structs
  */
@@ -99,11 +148,17 @@ struct i7core_inject {
 	int channel, dimm, rank, bank, page, col;
 };
 
+struct i7core_channel {
+	u32 ranks;
+	u32 dimms;
+};
+
 struct i7core_pvt {
 	struct pci_dev		*pci_mcr;	/* Dev 3:0 */
 	struct pci_dev		*pci_ch[NUM_CHANS][NUM_FUNCS];
 	struct i7core_info	info;
 	struct i7core_inject	inject;
+	struct i7core_channel	channel[NUM_CHANS];
 };
 
 /* Device name and register DID (Device ID) */
@@ -133,16 +188,12 @@ static struct edac_pci_ctl_info *i7core_pci;
  ****************************************************************************/
 
 	/* MC_CONTROL bits */
-#define CH2_ACTIVE(pvt)		((pvt)->info.mc_control & 1 << 10)
-#define CH1_ACTIVE(pvt)		((pvt)->info.mc_control & 1 << 9)
-#define CH0_ACTIVE(pvt)		((pvt)->info.mc_control & 1 << 8)
+#define CH_ACTIVE(pvt, ch)	((pvt)->info.mc_control & 1 << (8 + ch))
 #define ECCx8(pvt)		((pvt)->info.mc_control & 1 << 1)
 
 	/* MC_STATUS bits */
 #define ECC_ENABLED(pvt)	((pvt)->info.mc_status & 1 << 3)
-#define CH2_DISABLED(pvt)	((pvt)->info.mc_status & 1 << 2)
-#define CH1_DISABLED(pvt)	((pvt)->info.mc_status & 1 << 1)
-#define CH0_DISABLED(pvt)	((pvt)->info.mc_status & 1 << 0)
+#define CH_DISABLED(pvt, ch)	((pvt)->info.mc_status & 1 << ch)
 
 	/* MC_MAX_DOD read functions */
 static inline int maxnumdimms(struct i7core_pvt *pvt)
@@ -189,19 +240,12 @@ static inline int maxnumcol(struct i7core_pvt *pvt)
 static int get_dimm_config(struct mem_ctl_info *mci)
 {
 	struct i7core_pvt *pvt = mci->pvt_info;
+	int i;
 
 	pci_read_config_dword(pvt->pci_mcr, MC_CONTROL, &pvt->info.mc_control);
 	pci_read_config_dword(pvt->pci_mcr, MC_STATUS, &pvt->info.mc_status);
 	pci_read_config_dword(pvt->pci_mcr, MC_MAX_DOD, &pvt->info.max_dod);
 
-	debugf0("Channels  active [%c][%c][%c] - enabled [%c][%c][%c]\n",
-		CH0_ACTIVE(pvt)?'0':'-',
-		CH1_ACTIVE(pvt)?'1':'-',
-		CH2_ACTIVE(pvt)?'2':'-',
-		CH0_DISABLED(pvt)?'-':'0',
-		CH1_DISABLED(pvt)?'-':'1',
-		CH2_DISABLED(pvt)?'-':'2');
-
 	if (ECC_ENABLED(pvt))
 		debugf0("ECC enabled with x%d SDCC\n", ECCx8(pvt)?8:4);
 	else
@@ -213,6 +257,38 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 	debugf0("DOD Maximum rows x colums = 0x%x x 0x%x\n",
 		maxnumrow(pvt), maxnumcol(pvt));
 
+	debugf0("Memory channel configuration:\n");
+
+	for (i = 0; i < NUM_CHANS; i++) {
+		u32 data;
+
+		if (!CH_ACTIVE(pvt, i)) {
+			debugf0("Channel %i is not active\n", i);
+			continue;
+		}
+		if (CH_DISABLED(pvt, i)) {
+			debugf0("Channel %i is disabled\n", i);
+			continue;
+		}
+
+		pci_read_config_dword(pvt->pci_ch[i][0],
+				MC_CHANNEL_DIMM_INIT_PARAMS, &data);
+
+		pvt->channel[i].ranks = (data & QUAD_RANK_PRESENT)? 4 : 2;
+
+		if (data & THREE_DIMMS_PRESENT)
+			pvt->channel[i].dimms = 3;
+		else if (data & SINGLE_QUAD_RANK_PRESENT)
+			pvt->channel[i].dimms = 1;
+		else
+			pvt->channel[i].dimms = 2;
+
+		debugf0("Channel %d (0x%08x): %d ranks, %d dimms "
+			"(%sregistered)\n", i, data,
+			pvt->channel[i].ranks, pvt->channel[i].dimms,
+			(data & REGISTERED_DIMM)? "" : "un" );
+	}
+
 	return 0;
 }
 
@@ -489,7 +565,7 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 	if (pvt->inject.dimm < 0)
 		mask |= 1l << 41;
 	else {
-		if (maxnumdimms(pvt) > 2)
+		if (pvt->channel[pvt->inject.channel].dimms > 2)
 			mask |= (pvt->inject.dimm & 0x3l) << 35;
 		else
 			mask |= (pvt->inject.dimm & 0x1l) << 36;
@@ -499,7 +575,7 @@ static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
 	if (pvt->inject.rank < 0)
 		mask |= 1l << 40;
 	else {
-		if (maxnumdimms(pvt) > 2)
+		if (pvt->channel[pvt->inject.channel].dimms > 2)
 			mask |= (pvt->inject.rank & 0x1l) << 34;
 		else
 			mask |= (pvt->inject.rank & 0x3l) << 34;
@@ -646,9 +722,6 @@ static int i7core_get_devices(struct mem_ctl_info *mci, int dev_idx)
 	}
 	pvt->pci_mcr=pdev;
 
-	/* Get dimm basic config */
-	get_dimm_config(mci);
-
 	/* Retrieve all needed functions at MTR channel controllers */
 	for (i = 0; i < NUM_CHANS; i++) {
 		pdev = NULL;
@@ -672,6 +745,9 @@ static int i7core_get_devices(struct mem_ctl_info *mci, int dev_idx)
 	}
 	i7core_printk(KERN_INFO, "Driver loaded.\n");
 
+	/* Get dimm basic config */
+	get_dimm_config(mci);
+
 	return 0;
 }
 

commit 194a40feabb7cab38911a357c86e968e98024281
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 22 22:48:28 2009 -0300

    i7core_edac: Add error insertion code for Nehalem
    
    Implements set_inject_error() with the low-level code needed to inject
    memory errors at Nehalem, and adds some sysfs nodes to allow error injection
    
    The next patch will add an API for error injection.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 7ecf15e66a3f..b590f8468693 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -20,7 +20,6 @@
  * 	http://www.arrownac.com/manufacturers/intel/s/nehalem/5500-datasheet-v2.pdf
  */
 
-
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/pci.h>
@@ -64,12 +63,16 @@
 	/* OFFSETS for Devices 4,5 and 6 Function 0 */
 
 #define MC_CHANNEL_ADDR_MATCH	0xf0
-
-#define MC_MASK_DIMM	(1 << 41)
-#define MC_MASK_RANK	(1 << 40)
-#define MC_MASK_BANK	(1 << 39)
-#define MC_MASK_PAGE	(1 << 38)
-#define MC_MASK_COL	(1 << 37)
+#define MC_CHANNEL_ERROR_MASK	0xf8
+#define MC_CHANNEL_ERROR_INJECT	0xfc
+  #define INJECT_ADDR_PARITY	0x10
+  #define INJECT_ECC		0x08
+  #define MASK_CACHELINE	0x06
+  #define MASK_FULL_CACHELINE	0x06
+  #define MASK_MSB32_CACHELINE	0x04
+  #define MASK_LSB32_CACHELINE	0x02
+  #define NO_MASK_CACHELINE	0x00
+  #define REPEAT_EN		0x01
 
 /*
  * i7core structs
@@ -84,10 +87,23 @@ struct i7core_info {
 	u32	max_dod;
 };
 
+
+struct i7core_inject {
+	int	enable;
+
+	u32	section;
+	u32	type;
+	u32	eccmask;
+
+	/* Error address mask */
+	int channel, dimm, rank, bank, page, col;
+};
+
 struct i7core_pvt {
 	struct pci_dev		*pci_mcr;	/* Dev 3:0 */
 	struct pci_dev		*pci_ch[NUM_CHANS][NUM_FUNCS];
 	struct i7core_info	info;
+	struct i7core_inject	inject;
 };
 
 /* Device name and register DID (Device ID) */
@@ -166,6 +182,7 @@ static inline int maxnumcol(struct i7core_pvt *pvt)
 	return cols[((pvt->info.max_dod >> 9) & 0x3) << 12];
 }
 
+
 /****************************************************************************
 			Memory check routines
  ****************************************************************************/
@@ -199,6 +216,390 @@ static int get_dimm_config(struct mem_ctl_info *mci)
 	return 0;
 }
 
+/****************************************************************************
+			Error insertion routines
+ ****************************************************************************/
+
+/* The i7core has independent error injection features per channel.
+   However, to have a simpler code, we don't allow enabling error injection
+   on more than one channel.
+   Also, since a change at an inject parameter will be applied only at enable,
+   we're disabling error injection on all write calls to the sysfs nodes that
+   controls the error code injection.
+ */
+static void disable_inject(struct mem_ctl_info *mci)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+
+	pvt->inject.enable = 0;
+
+	pci_write_config_dword(pvt->pci_ch[pvt->inject.channel][0],
+				MC_CHANNEL_ERROR_MASK, 0);
+}
+
+/*
+ * i7core inject inject.section
+ *
+ *	accept and store error injection inject.section value
+ *	bit 0 - refers to the lower 32-byte half cacheline
+ *	bit 1 - refers to the upper 32-byte half cacheline
+ */
+static ssize_t i7core_inject_section_store(struct mem_ctl_info *mci,
+					   const char *data, size_t count)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	unsigned long value;
+	int rc;
+
+	if (pvt->inject.enable)
+		 disable_inject(mci);
+
+	rc = strict_strtoul(data, 10, &value);
+	if ((rc < 0) || (value > 3))
+		return 0;
+
+	pvt->inject.section = (u32) value;
+	return count;
+}
+
+static ssize_t i7core_inject_section_show(struct mem_ctl_info *mci,
+					      char *data)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	return sprintf(data, "0x%08x\n", pvt->inject.section);
+}
+
+/*
+ * i7core inject.type
+ *
+ *	accept and store error injection inject.section value
+ *	bit 0 - repeat enable - Enable error repetition
+ *	bit 1 - inject ECC error
+ *	bit 2 - inject parity error
+ */
+static ssize_t i7core_inject_type_store(struct mem_ctl_info *mci,
+					const char *data, size_t count)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	unsigned long value;
+	int rc;
+
+	if (pvt->inject.enable)
+		 disable_inject(mci);
+
+	rc = strict_strtoul(data, 10, &value);
+	if ((rc < 0) || (value > 7))
+		return 0;
+
+	pvt->inject.type = (u32) value;
+	return count;
+}
+
+static ssize_t i7core_inject_type_show(struct mem_ctl_info *mci,
+					      char *data)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	return sprintf(data, "0x%08x\n", pvt->inject.type);
+}
+
+/*
+ * i7core_inject_inject.eccmask_store
+ *
+ * The type of error (UE/CE) will depend on the inject.eccmask value:
+ *   Any bits set to a 1 will flip the corresponding ECC bit
+ *   Correctable errors can be injected by flipping 1 bit or the bits within
+ *   a symbol pair (2 consecutive aligned 8-bit pairs - i.e. 7:0 and 15:8 or
+ *   23:16 and 31:24). Flipping bits in two symbol pairs will cause an
+ *   uncorrectable error to be injected.
+ */
+static ssize_t i7core_inject_eccmask_store(struct mem_ctl_info *mci,
+					const char *data, size_t count)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	unsigned long value;
+	int rc;
+
+	if (pvt->inject.enable)
+		 disable_inject(mci);
+
+	rc = strict_strtoul(data, 10, &value);
+	if (rc < 0)
+		return 0;
+
+	pvt->inject.eccmask = (u32) value;
+	return count;
+}
+
+static ssize_t i7core_inject_eccmask_show(struct mem_ctl_info *mci,
+					      char *data)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	return sprintf(data, "0x%08x\n", pvt->inject.eccmask);
+}
+
+/*
+ * i7core_addrmatch
+ *
+ * The type of error (UE/CE) will depend on the inject.eccmask value:
+ *   Any bits set to a 1 will flip the corresponding ECC bit
+ *   Correctable errors can be injected by flipping 1 bit or the bits within
+ *   a symbol pair (2 consecutive aligned 8-bit pairs - i.e. 7:0 and 15:8 or
+ *   23:16 and 31:24). Flipping bits in two symbol pairs will cause an
+ *   uncorrectable error to be injected.
+ */
+static ssize_t i7core_inject_addrmatch_store(struct mem_ctl_info *mci,
+					const char *data, size_t count)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	char *cmd, *val;
+	long value;
+	int rc;
+
+	if (pvt->inject.enable)
+		 disable_inject(mci);
+
+	do {
+		cmd = strsep((char **) &data, ":");
+		if (!cmd)
+			break;
+		val = strsep((char **) &data, " \n\t");
+		if (!val)
+			return cmd - data;
+
+		if (!strcasecmp(val,"any"))
+			value = -1;
+		else {
+			rc = strict_strtol(val, 10, &value);
+			if ((rc < 0) || (value < 0))
+				return cmd - data;
+		}
+
+		if (!strcasecmp(cmd,"channel")) {
+			if (value < 3)
+				pvt->inject.channel = value;
+			else
+				return cmd - data;
+		} else if (!strcasecmp(cmd,"dimm")) {
+			if (value < 4)
+				pvt->inject.dimm = value;
+			else
+				return cmd - data;
+		} else if (!strcasecmp(cmd,"rank")) {
+			if (value < 4)
+				pvt->inject.rank = value;
+			else
+				return cmd - data;
+		} else if (!strcasecmp(cmd,"bank")) {
+			if (value < 4)
+				pvt->inject.bank = value;
+			else
+				return cmd - data;
+		} else if (!strcasecmp(cmd,"page")) {
+			if (value <= 0xffff)
+				pvt->inject.page = value;
+			else
+				return cmd - data;
+		} else if (!strcasecmp(cmd,"col") ||
+			   !strcasecmp(cmd,"column")) {
+			if (value <= 0x3fff)
+				pvt->inject.col = value;
+			else
+				return cmd - data;
+		}
+	} while (1);
+
+	return count;
+}
+
+static ssize_t i7core_inject_addrmatch_show(struct mem_ctl_info *mci,
+					      char *data)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	char channel[4], dimm[4], bank[4], rank[4], page[7], col[7];
+
+	if (pvt->inject.channel < 0)
+		sprintf(channel, "any");
+	else
+		sprintf(channel, "%d", pvt->inject.channel);
+	if (pvt->inject.dimm < 0)
+		sprintf(dimm, "any");
+	else
+		sprintf(dimm, "%d", pvt->inject.dimm);
+	if (pvt->inject.bank < 0)
+		sprintf(bank, "any");
+	else
+		sprintf(bank, "%d", pvt->inject.bank);
+	if (pvt->inject.rank < 0)
+		sprintf(rank, "any");
+	else
+		sprintf(rank, "%d", pvt->inject.rank);
+	if (pvt->inject.page < 0)
+		sprintf(page, "any");
+	else
+		sprintf(page, "0x%04x", pvt->inject.page);
+	if (pvt->inject.col < 0)
+		sprintf(col, "any");
+	else
+		sprintf(col, "0x%04x", pvt->inject.col);
+
+	return sprintf(data, "channel: %s\ndimm: %s\nbank: %s\n"
+			     "rank: %s\npage: %s\ncolumn: %s\n",
+		       channel, dimm, bank, rank, page, col);
+}
+
+/*
+ * This routine prepares the Memory Controller for error injection.
+ * The error will be injected when some process tries to write to the
+ * memory that matches the given criteria.
+ * The criteria can be set in terms of a mask where dimm, rank, bank, page
+ * and col can be specified.
+ * A -1 value for any of the mask items will make the MCU to ignore
+ * that matching criteria for error injection.
+ *
+ * It should be noticed that the error will only happen after a write operation
+ * on a memory that matches the condition. if REPEAT_EN is not enabled at
+ * inject mask, then it will produce just one error. Otherwise, it will repeat
+ * until the injectmask would be cleaned.
+ *
+ * FIXME: This routine assumes that MAXNUMDIMMS value of MC_MAX_DOD
+ *    is reliable enough to check if the MC is using the
+ *    three channels. However, this is not clear at the datasheet.
+ */
+static ssize_t i7core_inject_enable_store(struct mem_ctl_info *mci,
+				       const char *data, size_t count)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	u32 injectmask;
+	u64 mask = 0;
+	int  rc;
+	long enable;
+
+	rc = strict_strtoul(data, 10, &enable);
+	if ((rc < 0))
+		return 0;
+
+	if (enable) {
+		pvt->inject.enable = 1;
+	} else {
+		disable_inject(mci);
+		return count;
+	}
+
+	/* Sets pvt->inject.dimm mask */
+	if (pvt->inject.dimm < 0)
+		mask |= 1l << 41;
+	else {
+		if (maxnumdimms(pvt) > 2)
+			mask |= (pvt->inject.dimm & 0x3l) << 35;
+		else
+			mask |= (pvt->inject.dimm & 0x1l) << 36;
+	}
+
+	/* Sets pvt->inject.rank mask */
+	if (pvt->inject.rank < 0)
+		mask |= 1l << 40;
+	else {
+		if (maxnumdimms(pvt) > 2)
+			mask |= (pvt->inject.rank & 0x1l) << 34;
+		else
+			mask |= (pvt->inject.rank & 0x3l) << 34;
+	}
+
+	/* Sets pvt->inject.bank mask */
+	if (pvt->inject.bank < 0)
+		mask |= 1l << 39;
+	else
+		mask |= (pvt->inject.bank & 0x15l) << 30;
+
+	/* Sets pvt->inject.page mask */
+	if (pvt->inject.page < 0)
+		mask |= 1l << 38;
+	else
+		mask |= (pvt->inject.page & 0xffffl) << 14;
+
+	/* Sets pvt->inject.column mask */
+	if (pvt->inject.col < 0)
+		mask |= 1l << 37;
+	else
+		mask |= (pvt->inject.col & 0x3fffl);
+
+	pci_write_config_qword(pvt->pci_ch[pvt->inject.channel][0],
+			       MC_CHANNEL_ADDR_MATCH, mask);
+
+	pci_write_config_dword(pvt->pci_ch[pvt->inject.channel][0],
+			       MC_CHANNEL_ERROR_MASK, pvt->inject.eccmask);
+
+	/*
+	 * bit    0: REPEAT_EN
+	 * bits 1-2: MASK_HALF_CACHELINE
+	 * bit    3: INJECT_ECC
+	 * bit    4: INJECT_ADDR_PARITY
+	 */
+
+	injectmask = (pvt->inject.type & 1) &&
+		     (pvt->inject.section & 0x3) << 1 &&
+		     (pvt->inject.type & 0x6) << (3 - 1);
+
+	pci_write_config_dword(pvt->pci_ch[pvt->inject.channel][0],
+			       MC_CHANNEL_ERROR_MASK, injectmask);
+
+
+	debugf0("Error inject addr match 0x%016llx, ecc 0x%08x, inject 0x%08x\n",
+		mask, pvt->inject.eccmask, injectmask);
+
+	return count;
+}
+
+static ssize_t i7core_inject_enable_show(struct mem_ctl_info *mci,
+					char *data)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	return sprintf(data, "%d\n", pvt->inject.enable);
+}
+
+/*
+ * Sysfs struct
+ */
+static struct mcidev_sysfs_attribute i7core_inj_attrs[] = {
+
+	{
+		.attr = {
+			.name = "inject_section",
+			.mode = (S_IRUGO | S_IWUSR)
+		},
+		.show  = i7core_inject_section_show,
+		.store = i7core_inject_section_store,
+	}, {
+		.attr = {
+			.name = "inject_type",
+			.mode = (S_IRUGO | S_IWUSR)
+		},
+		.show  = i7core_inject_type_show,
+		.store = i7core_inject_type_store,
+	}, {
+		.attr = {
+			.name = "inject_eccmask",
+			.mode = (S_IRUGO | S_IWUSR)
+		},
+		.show  = i7core_inject_eccmask_show,
+		.store = i7core_inject_eccmask_store,
+	}, {
+		.attr = {
+			.name = "inject_addrmatch",
+			.mode = (S_IRUGO | S_IWUSR)
+		},
+		.show  = i7core_inject_addrmatch_show,
+		.store = i7core_inject_addrmatch_store,
+	}, {
+		.attr = {
+			.name = "inject_enable",
+			.mode = (S_IRUGO | S_IWUSR)
+		},
+		.show  = i7core_inject_enable_show,
+		.store = i7core_inject_enable_store,
+	},
+};
+
 /****************************************************************************
 	Device initialization routines: put/get, init/exit
  ****************************************************************************/
@@ -322,10 +723,11 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 
 	debugf0("MC: " __FILE__ ": %s(): mci = %p\n", __func__, mci);
 
-	mci->dev = &pdev->dev;	/* record ptr  to the generic device */
+	mci->dev = &pdev->dev;	/* record ptr to the generic device */
 	dev_set_drvdata(mci->dev, mci);
 
 	pvt = mci->pvt_info;
+
 //	pvt->system_address = pdev;	/* Record this device in our private */
 //	pvt->maxch = num_channels;
 //	pvt->maxdimmperch = num_dimms_per_channel;
@@ -343,6 +745,7 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 	mci->ctl_name = i7core_devs[dev_idx].ctl_name;
 	mci->dev_name = pci_name(pdev);
 	mci->ctl_page_to_phys = NULL;
+	mci->mc_driver_sysfs_attributes = i7core_inj_attrs;
 
 	/* add this new MC control structure to EDAC's list of MCs */
 	if (edac_mc_add_mc(mci)) {
@@ -365,6 +768,14 @@ static int __devinit i7core_probe(struct pci_dev *pdev,
 			__func__);
 	}
 
+	/* Default error mask is any memory */
+	pvt->inject.channel = -1;
+	pvt->inject.dimm = -1;
+	pvt->inject.rank = -1;
+	pvt->inject.bank = -1;
+	pvt->inject.page = -1;
+	pvt->inject.col = -1;
+
 	return 0;
 
 fail1:

commit a0c36a1f0fbab42590dab3c13c10fa7d20e6c2cd
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Jun 22 22:41:15 2009 -0300

    i7core_edac: Add an EDAC memory controller driver for Nehalem chipsets
    
    This driver is meant to support i7 core/i7core extreme desktop
    processors and Xeon 35xx/55xx series with integrated memory controller.
    It is likely that it can be expanded in the future to work with other
    processor series based at the same Memory Controller design.
    
    For now, it has just a few MCH status reads.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
new file mode 100644
index 000000000000..7ecf15e66a3f
--- /dev/null
+++ b/drivers/edac/i7core_edac.c
@@ -0,0 +1,462 @@
+/* Intel 7 core  Memory Controller kernel module (Nehalem)
+ *
+ * This file may be distributed under the terms of the
+ * GNU General Public License version 2 only.
+ *
+ * Copyright (c) 2009 by:
+ *	 Mauro Carvalho Chehab <mchehab@redhat.com>
+ *
+ * Red Hat Inc. http://www.redhat.com
+ *
+ * Forked and adapted from the i5400_edac driver
+ *
+ * Based on the following public Intel datasheets:
+ * Intel Core i7 Processor Extreme Edition and Intel Core i7 Processor
+ * Datasheet, Volume 2:
+ *	http://download.intel.com/design/processor/datashts/320835.pdf
+ * Intel Xeon Processor 5500 Series Datasheet Volume 2
+ *	http://www.intel.com/Assets/PDF/datasheet/321322.pdf
+ * also available at:
+ * 	http://www.arrownac.com/manufacturers/intel/s/nehalem/5500-datasheet-v2.pdf
+ */
+
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/pci_ids.h>
+#include <linux/slab.h>
+#include <linux/edac.h>
+#include <linux/mmzone.h>
+
+#include "edac_core.h"
+
+
+/*
+ * Alter this version for the module when modifications are made
+ */
+#define I7CORE_REVISION    " Ver: 1.0.0 " __DATE__
+#define EDAC_MOD_STR      "i7core_edac"
+
+/* HACK: temporary, just to enable all logs, for now */
+#undef debugf0
+#define debugf0(fmt, arg...)  edac_printk(KERN_INFO, "i7core", fmt, ##arg)
+
+/*
+ * Debug macros
+ */
+#define i7core_printk(level, fmt, arg...)			\
+	edac_printk(level, "i7core", fmt, ##arg)
+
+#define i7core_mc_printk(mci, level, fmt, arg...)		\
+	edac_mc_chipset_printk(mci, level, "i7core", fmt, ##arg)
+
+/*
+ * i7core Memory Controller Registers
+ */
+
+	/* OFFSETS for Device 3 Function 0 */
+
+#define MC_CONTROL	0x48
+#define MC_STATUS	0x4c
+#define MC_MAX_DOD	0x64
+
+	/* OFFSETS for Devices 4,5 and 6 Function 0 */
+
+#define MC_CHANNEL_ADDR_MATCH	0xf0
+
+#define MC_MASK_DIMM	(1 << 41)
+#define MC_MASK_RANK	(1 << 40)
+#define MC_MASK_BANK	(1 << 39)
+#define MC_MASK_PAGE	(1 << 38)
+#define MC_MASK_COL	(1 << 37)
+
+/*
+ * i7core structs
+ */
+
+#define NUM_CHANS 3
+#define NUM_FUNCS 1
+
+struct i7core_info {
+	u32	mc_control;
+	u32	mc_status;
+	u32	max_dod;
+};
+
+struct i7core_pvt {
+	struct pci_dev		*pci_mcr;	/* Dev 3:0 */
+	struct pci_dev		*pci_ch[NUM_CHANS][NUM_FUNCS];
+	struct i7core_info	info;
+};
+
+/* Device name and register DID (Device ID) */
+struct i7core_dev_info {
+	const char *ctl_name;	/* name for this device */
+	u16 fsb_mapping_errors;	/* DID for the branchmap,control */
+};
+
+static int chan_pci_ids[NUM_CHANS] = {
+	PCI_DEVICE_ID_INTEL_I7_MC_CH0_CTRL,	/* Dev 4 */
+	PCI_DEVICE_ID_INTEL_I7_MC_CH1_CTRL,	/* Dev 5 */
+	PCI_DEVICE_ID_INTEL_I7_MC_CH2_CTRL,	/* Dev 6 */
+};
+
+/* Table of devices attributes supported by this driver */
+static const struct i7core_dev_info i7core_devs[] = {
+	{
+		.ctl_name = "i7 Core",
+		.fsb_mapping_errors = PCI_DEVICE_ID_INTEL_I7_MCR,
+	},
+};
+
+static struct edac_pci_ctl_info *i7core_pci;
+
+/****************************************************************************
+			Anciliary status routines
+ ****************************************************************************/
+
+	/* MC_CONTROL bits */
+#define CH2_ACTIVE(pvt)		((pvt)->info.mc_control & 1 << 10)
+#define CH1_ACTIVE(pvt)		((pvt)->info.mc_control & 1 << 9)
+#define CH0_ACTIVE(pvt)		((pvt)->info.mc_control & 1 << 8)
+#define ECCx8(pvt)		((pvt)->info.mc_control & 1 << 1)
+
+	/* MC_STATUS bits */
+#define ECC_ENABLED(pvt)	((pvt)->info.mc_status & 1 << 3)
+#define CH2_DISABLED(pvt)	((pvt)->info.mc_status & 1 << 2)
+#define CH1_DISABLED(pvt)	((pvt)->info.mc_status & 1 << 1)
+#define CH0_DISABLED(pvt)	((pvt)->info.mc_status & 1 << 0)
+
+	/* MC_MAX_DOD read functions */
+static inline int maxnumdimms(struct i7core_pvt *pvt)
+{
+	return (pvt->info.max_dod & 0x3) + 1;
+}
+
+static inline int maxnumrank(struct i7core_pvt *pvt)
+{
+	static int ranks[4] = { 1, 2, 4, -EINVAL };
+
+	return ranks[(pvt->info.max_dod >> 2) & 0x3];
+}
+
+static inline int maxnumbank(struct i7core_pvt *pvt)
+{
+	static int banks[4] = { 4, 8, 16, -EINVAL };
+
+	return banks[(pvt->info.max_dod >> 4) & 0x3];
+}
+
+static inline int maxnumrow(struct i7core_pvt *pvt)
+{
+	static int rows[8] = {
+		1 << 12, 1 << 13, 1 << 14, 1 << 15,
+		1 << 16, -EINVAL, -EINVAL, -EINVAL,
+	};
+
+	return rows[((pvt->info.max_dod >> 6) & 0x7)];
+}
+
+static inline int maxnumcol(struct i7core_pvt *pvt)
+{
+	static int cols[8] = {
+		1 << 10, 1 << 11, 1 << 12, -EINVAL,
+	};
+	return cols[((pvt->info.max_dod >> 9) & 0x3) << 12];
+}
+
+/****************************************************************************
+			Memory check routines
+ ****************************************************************************/
+static int get_dimm_config(struct mem_ctl_info *mci)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+
+	pci_read_config_dword(pvt->pci_mcr, MC_CONTROL, &pvt->info.mc_control);
+	pci_read_config_dword(pvt->pci_mcr, MC_STATUS, &pvt->info.mc_status);
+	pci_read_config_dword(pvt->pci_mcr, MC_MAX_DOD, &pvt->info.max_dod);
+
+	debugf0("Channels  active [%c][%c][%c] - enabled [%c][%c][%c]\n",
+		CH0_ACTIVE(pvt)?'0':'-',
+		CH1_ACTIVE(pvt)?'1':'-',
+		CH2_ACTIVE(pvt)?'2':'-',
+		CH0_DISABLED(pvt)?'-':'0',
+		CH1_DISABLED(pvt)?'-':'1',
+		CH2_DISABLED(pvt)?'-':'2');
+
+	if (ECC_ENABLED(pvt))
+		debugf0("ECC enabled with x%d SDCC\n", ECCx8(pvt)?8:4);
+	else
+		debugf0("ECC disabled\n");
+
+	/* FIXME: need to handle the error codes */
+	debugf0("DOD Maximum limits: DIMMS: %d, %d-ranked, %d-banked\n",
+		maxnumdimms(pvt), maxnumrank(pvt), maxnumbank(pvt));
+	debugf0("DOD Maximum rows x colums = 0x%x x 0x%x\n",
+		maxnumrow(pvt), maxnumcol(pvt));
+
+	return 0;
+}
+
+/****************************************************************************
+	Device initialization routines: put/get, init/exit
+ ****************************************************************************/
+
+/*
+ *	i7core_put_devices	'put' all the devices that we have
+ *				reserved via 'get'
+ */
+static void i7core_put_devices(struct mem_ctl_info *mci)
+{
+	struct i7core_pvt *pvt = mci->pvt_info;
+	int i, n;
+
+	pci_dev_put(pvt->pci_mcr);
+
+	/* Release all PCI device functions at MTR channel controllers */
+	for (i = 0; i < NUM_CHANS; i++)
+		for (n = 0; n < NUM_FUNCS; n++)
+			pci_dev_put(pvt->pci_ch[i][n]);
+}
+
+/*
+ *	i7core_get_devices	Find and perform 'get' operation on the MCH's
+ *			device/functions we want to reference for this driver
+ *
+ *			Need to 'get' device 16 func 1 and func 2
+ */
+static int i7core_get_devices(struct mem_ctl_info *mci, int dev_idx)
+{
+	struct i7core_pvt *pvt;
+	struct pci_dev *pdev;
+	int i, n, func;
+
+	pvt = mci->pvt_info;
+	memset(pvt, 0, sizeof(*pvt));
+
+	pdev = pci_get_device(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I7_MCR,
+			      NULL);
+	if (!pdev) {
+		i7core_printk(KERN_ERR,
+			"Couldn't get PCI ID %04x:%04x function 0\n",
+			PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I7_MCR);
+		return -ENODEV;
+	}
+	pvt->pci_mcr=pdev;
+
+	/* Get dimm basic config */
+	get_dimm_config(mci);
+
+	/* Retrieve all needed functions at MTR channel controllers */
+	for (i = 0; i < NUM_CHANS; i++) {
+		pdev = NULL;
+		for (n = 0; n < NUM_FUNCS; n++) {
+			pdev = pci_get_device(PCI_VENDOR_ID_INTEL,
+					      chan_pci_ids[i], pdev);
+			if (!pdev) {
+				/* End of list, leave */
+				i7core_printk(KERN_ERR,
+					"Device not found: PCI ID %04x:%04x "
+					"found only %d functions "
+					"(broken BIOS?)\n",
+					PCI_VENDOR_ID_INTEL,
+					chan_pci_ids[i], n);
+				i7core_put_devices(mci);
+				return -ENODEV;
+			}
+			func = PCI_FUNC(pdev->devfn);
+			pvt->pci_ch[i][func] = pdev;
+		}
+	}
+	i7core_printk(KERN_INFO, "Driver loaded.\n");
+
+	return 0;
+}
+
+/*
+ *	i7core_probe	Probe for ONE instance of device to see if it is
+ *			present.
+ *	return:
+ *		0 for FOUND a device
+ *		< 0 for error code
+ */
+static int __devinit i7core_probe(struct pci_dev *pdev,
+				  const struct pci_device_id *id)
+{
+	struct mem_ctl_info *mci;
+	struct i7core_pvt *pvt;
+	int rc;
+	int num_channels;
+	int num_csrows;
+	int num_dimms_per_channel;
+	int dev_idx = id->driver_data;
+
+	if (dev_idx >= ARRAY_SIZE(i7core_devs))
+		return -EINVAL;
+
+	/* wake up device */
+	rc = pci_enable_device(pdev);
+	if (rc == -EIO)
+		return rc;
+
+	debugf0("MC: " __FILE__ ": %s(), pdev bus %u dev=0x%x fn=0x%x\n",
+		__func__,
+		pdev->bus->number,
+		PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));
+
+	/* We only are looking for func 0 of the set */
+	if (PCI_FUNC(pdev->devfn) != 0)
+		return -ENODEV;
+
+	num_channels = NUM_CHANS;
+
+	/* FIXME: FAKE data, since we currently don't now how to get this */
+	num_dimms_per_channel = 4;
+	num_csrows = num_dimms_per_channel;
+
+	/* allocate a new MC control structure */
+	mci = edac_mc_alloc(sizeof(*pvt), num_csrows, num_channels, 0);
+	if (mci == NULL)
+		return -ENOMEM;
+
+	debugf0("MC: " __FILE__ ": %s(): mci = %p\n", __func__, mci);
+
+	mci->dev = &pdev->dev;	/* record ptr  to the generic device */
+	dev_set_drvdata(mci->dev, mci);
+
+	pvt = mci->pvt_info;
+//	pvt->system_address = pdev;	/* Record this device in our private */
+//	pvt->maxch = num_channels;
+//	pvt->maxdimmperch = num_dimms_per_channel;
+
+	/* 'get' the pci devices we want to reserve for our use */
+	if (i7core_get_devices(mci, dev_idx))
+		goto fail0;
+
+	mci->mc_idx = 0;
+	mci->mtype_cap = MEM_FLAG_FB_DDR2;	/* FIXME: it uses DDR3 */
+	mci->edac_ctl_cap = EDAC_FLAG_NONE;
+	mci->edac_cap = EDAC_FLAG_NONE;
+	mci->mod_name = "i7core_edac.c";
+	mci->mod_ver = I7CORE_REVISION;
+	mci->ctl_name = i7core_devs[dev_idx].ctl_name;
+	mci->dev_name = pci_name(pdev);
+	mci->ctl_page_to_phys = NULL;
+
+	/* add this new MC control structure to EDAC's list of MCs */
+	if (edac_mc_add_mc(mci)) {
+		debugf0("MC: " __FILE__
+			": %s(): failed edac_mc_add_mc()\n", __func__);
+		/* FIXME: perhaps some code should go here that disables error
+		 * reporting if we just enabled it
+		 */
+		goto fail1;
+	}
+
+	/* allocating generic PCI control info */
+	i7core_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);
+	if (!i7core_pci) {
+		printk(KERN_WARNING
+			"%s(): Unable to create PCI control\n",
+			__func__);
+		printk(KERN_WARNING
+			"%s(): PCI error report via EDAC not setup\n",
+			__func__);
+	}
+
+	return 0;
+
+fail1:
+	i7core_put_devices(mci);
+
+fail0:
+	edac_mc_free(mci);
+	return -ENODEV;
+}
+
+/*
+ *	i7core_remove	destructor for one instance of device
+ *
+ */
+static void __devexit i7core_remove(struct pci_dev *pdev)
+{
+	struct mem_ctl_info *mci;
+
+	debugf0(__FILE__ ": %s()\n", __func__);
+
+	if (i7core_pci)
+		edac_pci_release_generic_ctl(i7core_pci);
+
+	mci = edac_mc_del_mc(&pdev->dev);
+	if (!mci)
+		return;
+
+	/* retrieve references to resources, and free those resources */
+	i7core_put_devices(mci);
+
+	edac_mc_free(mci);
+}
+
+/*
+ *	pci_device_id	table for which devices we are looking for
+ *
+ *	The "E500P" device is the first device supported.
+ */
+static const struct pci_device_id i7core_pci_tbl[] __devinitdata = {
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I7_MCR)},
+	{0,}			/* 0 terminated list. */
+};
+
+MODULE_DEVICE_TABLE(pci, i7core_pci_tbl);
+
+/*
+ *	i7core_driver	pci_driver structure for this module
+ *
+ */
+static struct pci_driver i7core_driver = {
+	.name     = "i7core_edac",
+	.probe    = i7core_probe,
+	.remove   = __devexit_p(i7core_remove),
+	.id_table = i7core_pci_tbl,
+};
+
+/*
+ *	i7core_init		Module entry function
+ *			Try to initialize this module for its devices
+ */
+static int __init i7core_init(void)
+{
+	int pci_rc;
+
+	debugf2("MC: " __FILE__ ": %s()\n", __func__);
+
+	/* Ensure that the OPSTATE is set correctly for POLL or NMI */
+	opstate_init();
+
+	pci_rc = pci_register_driver(&i7core_driver);
+
+	return (pci_rc < 0) ? pci_rc : 0;
+}
+
+/*
+ *	i7core_exit()	Module exit function
+ *			Unregister the driver
+ */
+static void __exit i7core_exit(void)
+{
+	debugf2("MC: " __FILE__ ": %s()\n", __func__);
+	pci_unregister_driver(&i7core_driver);
+}
+
+module_init(i7core_init);
+module_exit(i7core_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Mauro Carvalho Chehab <mchehab@redhat.com>");
+MODULE_AUTHOR("Red Hat Inc. (http://www.redhat.com)");
+MODULE_DESCRIPTION("MC Driver for Intel i7 Core memory controllers - "
+		   I7CORE_REVISION);
+
+module_param(edac_op_state, int, 0444);
+MODULE_PARM_DESC(edac_op_state, "EDAC Error Reporting state: 0=Poll,1=NMI");
