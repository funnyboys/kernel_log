commit 9816b4af4351bf9d33c2e635b6f14327823a9c2a
Author: Hanna Hawa <hhhawa@amazon.com>
Date:   Mon Sep 23 20:17:40 2019 +0100

    EDAC/device: Rework error logging API
    
    Make the main workhorse the "count" functions which can log a @count
    of errors. Have the current APIs edac_device_handle_{ce,ue}() call
    the _count() variants and this way keep the exported symbols number
    unchanged.
    
     [ bp: Rewrite. ]
    
    Signed-off-by: Hanna Hawa <hhhawa@amazon.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: benh@amazon.com
    Cc: dwmw@amazon.co.uk
    Cc: hanochu@amazon.com
    Cc: James Morse <james.morse@arm.com>
    Cc: jonnyc@amazon.com
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: ronenk@amazon.com
    Cc: talel@amazon.com
    Cc: Tony Luck <tony.luck@intel.com>
    Link: https://lkml.kernel.org/r/20190923191741.29322-2-hhhawa@amazon.com

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 65cf2b9355c4..8c4d947fb848 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -555,12 +555,16 @@ static inline int edac_device_get_panic_on_ue(struct edac_device_ctl_info
 	return edac_dev->panic_on_ue;
 }
 
-void edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,
-			int inst_nr, int block_nr, const char *msg)
+void edac_device_handle_ce_count(struct edac_device_ctl_info *edac_dev,
+				 unsigned int count, int inst_nr, int block_nr,
+				 const char *msg)
 {
 	struct edac_device_instance *instance;
 	struct edac_device_block *block = NULL;
 
+	if (!count)
+		return;
+
 	if ((inst_nr >= edac_dev->nr_instances) || (inst_nr < 0)) {
 		edac_device_printk(edac_dev, KERN_ERR,
 				"INTERNAL ERROR: 'instance' out of range "
@@ -582,27 +586,31 @@ void edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,
 
 	if (instance->nr_blocks > 0) {
 		block = instance->blocks + block_nr;
-		block->counters.ce_count++;
+		block->counters.ce_count += count;
 	}
 
 	/* Propagate the count up the 'totals' tree */
-	instance->counters.ce_count++;
-	edac_dev->counters.ce_count++;
+	instance->counters.ce_count += count;
+	edac_dev->counters.ce_count += count;
 
 	if (edac_device_get_log_ce(edac_dev))
 		edac_device_printk(edac_dev, KERN_WARNING,
-				"CE: %s instance: %s block: %s '%s'\n",
-				edac_dev->ctl_name, instance->name,
-				block ? block->name : "N/A", msg);
+				   "CE: %s instance: %s block: %s count: %d '%s'\n",
+				   edac_dev->ctl_name, instance->name,
+				   block ? block->name : "N/A", count, msg);
 }
-EXPORT_SYMBOL_GPL(edac_device_handle_ce);
+EXPORT_SYMBOL_GPL(edac_device_handle_ce_count);
 
-void edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,
-			int inst_nr, int block_nr, const char *msg)
+void edac_device_handle_ue_count(struct edac_device_ctl_info *edac_dev,
+				 unsigned int count, int inst_nr, int block_nr,
+				 const char *msg)
 {
 	struct edac_device_instance *instance;
 	struct edac_device_block *block = NULL;
 
+	if (!count)
+		return;
+
 	if ((inst_nr >= edac_dev->nr_instances) || (inst_nr < 0)) {
 		edac_device_printk(edac_dev, KERN_ERR,
 				"INTERNAL ERROR: 'instance' out of range "
@@ -624,22 +632,22 @@ void edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,
 
 	if (instance->nr_blocks > 0) {
 		block = instance->blocks + block_nr;
-		block->counters.ue_count++;
+		block->counters.ue_count += count;
 	}
 
 	/* Propagate the count up the 'totals' tree */
-	instance->counters.ue_count++;
-	edac_dev->counters.ue_count++;
+	instance->counters.ue_count += count;
+	edac_dev->counters.ue_count += count;
 
 	if (edac_device_get_log_ue(edac_dev))
 		edac_device_printk(edac_dev, KERN_EMERG,
-				"UE: %s instance: %s block: %s '%s'\n",
-				edac_dev->ctl_name, instance->name,
-				block ? block->name : "N/A", msg);
+				   "UE: %s instance: %s block: %s count: %d '%s'\n",
+				   edac_dev->ctl_name, instance->name,
+				   block ? block->name : "N/A", count, msg);
 
 	if (edac_device_get_panic_on_ue(edac_dev))
-		panic("EDAC %s: UE instance: %s block %s '%s'\n",
-			edac_dev->ctl_name, instance->name,
-			block ? block->name : "N/A", msg);
+		panic("EDAC %s: UE instance: %s block %s count: %d '%s'\n",
+		      edac_dev->ctl_name, instance->name,
+		      block ? block->name : "N/A", count, msg);
 }
-EXPORT_SYMBOL_GPL(edac_device_handle_ue);
+EXPORT_SYMBOL_GPL(edac_device_handle_ue_count);

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index de4d5d08af9e..65cf2b9355c4 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -13,7 +13,7 @@
  */
 
 #include <asm/page.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <linux/ctype.h>
 #include <linux/highmem.h>
 #include <linux/init.h>

commit 5336f75499bbb293910b3502b3c4a4f9ab9ff078
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Wed Oct 26 16:01:47 2016 -0200

    edac: move documentation from edac_device to edac_core.h
    
    Several functions are documented at edac_device.c.
    
    As we'll be including edac_core.h at drivers-api book, move those,
    in order for the kernel-doc markups be part of the API
    documentation book.
    
    As several of those kernel-doc macros are not in the right format,
    fix them.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 046ab7794fc2..de4d5d08af9e 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -47,21 +47,6 @@ static void edac_device_dump_device(struct edac_device_ctl_info *edac_dev)
 }
 #endif				/* CONFIG_EDAC_DEBUG */
 
-
-/*
- * edac_device_alloc_ctl_info()
- *	Allocate a new edac device control info structure
- *
- *	The control structure is allocated in complete chunk
- *	from the OS. It is in turn sub allocated to the
- *	various objects that compose the structure
- *
- *	The structure has a 'nr_instance' array within itself.
- *	Each instance represents a major component
- *		Example:  L1 cache and L2 cache are 2 instance components
- *
- *	Within each instance is an array of 'nr_blocks' blockoffsets
- */
 struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	unsigned sz_private,
 	char *edac_device_name, unsigned nr_instances,
@@ -241,11 +226,6 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 }
 EXPORT_SYMBOL_GPL(edac_device_alloc_ctl_info);
 
-/*
- * edac_device_free_ctl_info()
- *	frees the memory allocated by the edac_device_alloc_ctl_info()
- *	function
- */
 void edac_device_free_ctl_info(struct edac_device_ctl_info *ctl_info)
 {
 	edac_device_unregister_sysfs_main_kobj(ctl_info);
@@ -457,12 +437,6 @@ void edac_device_reset_delay_period(struct edac_device_ctl_info *edac_dev,
 	edac_mod_work(&edac_dev->work, jiffs);
 }
 
-/*
- * edac_device_alloc_index: Allocate a unique device index number
- *
- * Return:
- *	allocated index number
- */
 int edac_device_alloc_index(void)
 {
 	static atomic_t device_indexes = ATOMIC_INIT(0);
@@ -471,17 +445,6 @@ int edac_device_alloc_index(void)
 }
 EXPORT_SYMBOL_GPL(edac_device_alloc_index);
 
-/**
- * edac_device_add_device: Insert the 'edac_dev' structure into the
- * edac_device global list and create sysfs entries associated with
- * edac_device structure.
- * @edac_device: pointer to the edac_device structure to be added to the list
- * 'edac_device' structure.
- *
- * Return:
- *	0	Success
- *	!0	Failure
- */
 int edac_device_add_device(struct edac_device_ctl_info *edac_dev)
 {
 	edac_dbg(0, "\n");
@@ -538,19 +501,6 @@ int edac_device_add_device(struct edac_device_ctl_info *edac_dev)
 }
 EXPORT_SYMBOL_GPL(edac_device_add_device);
 
-/**
- * edac_device_del_device:
- *	Remove sysfs entries for specified edac_device structure and
- *	then remove edac_device structure from global list
- *
- * @dev:
- *	Pointer to 'struct device' representing edac_device
- *	structure to remove.
- *
- * Return:
- *	Pointer to removed edac_device structure,
- *	OR NULL if device not found.
- */
 struct edac_device_ctl_info *edac_device_del_device(struct device *dev)
 {
 	struct edac_device_ctl_info *edac_dev;
@@ -605,10 +555,6 @@ static inline int edac_device_get_panic_on_ue(struct edac_device_ctl_info
 	return edac_dev->panic_on_ue;
 }
 
-/*
- * edac_device_handle_ce
- *	perform a common output and handling of an 'edac_dev' CE event
- */
 void edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,
 			int inst_nr, int block_nr, const char *msg)
 {
@@ -651,10 +597,6 @@ void edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,
 }
 EXPORT_SYMBOL_GPL(edac_device_handle_ce);
 
-/*
- * edac_device_handle_ue
- *	perform a common output and handling of an 'edac_dev' UE event
- */
 void edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,
 			int inst_nr, int block_nr, const char *msg)
 {

commit 6d8ef2472410c8ab004729a71ec829a224699a08
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Sat Oct 29 10:01:41 2016 -0200

    edac: move EDAC device definitions to drivers/edac/edac_device.h
    
    The edac_core.h header contain data structures and function
    definitions for both EDAC MC and EDAC device.
    
    Let's move the devices ones to a separate header file, as part
    of a header reorganization.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index a97900333e2d..046ab7794fc2 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -12,23 +12,20 @@
  * 19 Jan 2007
  */
 
+#include <asm/page.h>
+#include <asm/uaccess.h>
+#include <linux/ctype.h>
+#include <linux/highmem.h>
+#include <linux/init.h>
+#include <linux/jiffies.h>
 #include <linux/module.h>
-#include <linux/types.h>
+#include <linux/slab.h>
 #include <linux/smp.h>
-#include <linux/init.h>
+#include <linux/spinlock.h>
 #include <linux/sysctl.h>
-#include <linux/highmem.h>
 #include <linux/timer.h>
-#include <linux/slab.h>
-#include <linux/jiffies.h>
-#include <linux/spinlock.h>
-#include <linux/list.h>
-#include <linux/ctype.h>
-#include <linux/workqueue.h>
-#include <asm/uaccess.h>
-#include <asm/page.h>
 
-#include "edac_core.h"
+#include "edac_device.h"
 #include "edac_module.h"
 
 /* lock for the list: 'edac_device_list', manipulation of this list

commit c4cf3b454ecaa222aad9017932bd3b9c9325d931
Author: Borislav Petkov <bp@suse.de>
Date:   Mon Nov 30 19:02:01 2015 +0100

    EDAC: Rework workqueue handling
    
    Hide the EDAC workqueue pointer in a separate compilation unit and add
    accessors for the workqueue manipulations needed.
    
    Remove edac_pci_reset_delay_period() which wasn't used by anything. It
    seems it got added without a user with
    
      91b99041c1d5 ("drivers/edac: updated PCI monitoring")
    
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 455a64b67521..a97900333e2d 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -390,11 +390,9 @@ static void edac_device_workq_function(struct work_struct *work_req)
 	 * between integral seconds
 	 */
 	if (edac_dev->poll_msec == 1000)
-		queue_delayed_work(edac_workqueue, &edac_dev->work,
-				round_jiffies_relative(edac_dev->delay));
+		edac_queue_work(&edac_dev->work, round_jiffies_relative(edac_dev->delay));
 	else
-		queue_delayed_work(edac_workqueue, &edac_dev->work,
-				edac_dev->delay);
+		edac_queue_work(&edac_dev->work, edac_dev->delay);
 }
 
 /*
@@ -422,11 +420,9 @@ static void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
 	 * to fire together on the 1 second exactly
 	 */
 	if (edac_dev->poll_msec == 1000)
-		queue_delayed_work(edac_workqueue, &edac_dev->work,
-				round_jiffies_relative(edac_dev->delay));
+		edac_queue_work(&edac_dev->work, round_jiffies_relative(edac_dev->delay));
 	else
-		queue_delayed_work(edac_workqueue, &edac_dev->work,
-				edac_dev->delay);
+		edac_queue_work(&edac_dev->work, edac_dev->delay);
 }
 
 /*
@@ -440,8 +436,7 @@ static void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev)
 
 	edac_dev->op_state = OP_OFFLINE;
 
-	cancel_delayed_work_sync(&edac_dev->work);
-	flush_workqueue(edac_workqueue);
+	edac_stop_work(&edac_dev->work);
 }
 
 /*
@@ -454,16 +449,15 @@ static void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev)
 void edac_device_reset_delay_period(struct edac_device_ctl_info *edac_dev,
 					unsigned long value)
 {
-	/* cancel the current workq request, without the mutex lock */
-	edac_device_workq_teardown(edac_dev);
+	unsigned long jiffs = msecs_to_jiffies(value);
 
-	/* acquire the mutex before doing the workq setup */
-	mutex_lock(&device_ctls_mutex);
+	if (value == 1000)
+		jiffs = round_jiffies_relative(value);
 
-	/* restart the workq request, with new delay value */
-	edac_device_workq_setup(edac_dev, value);
+	edac_dev->poll_msec = value;
+	edac_dev->delay	    = jiffs;
 
-	mutex_unlock(&device_ctls_mutex);
+	edac_mod_work(&edac_dev->work, jiffs);
 }
 
 /*

commit e136fa016f2f06ca6e00d4f99894b4424f3f2a5c
Author: Borislav Petkov <bp@suse.de>
Date:   Mon Nov 30 15:07:28 2015 +0100

    EDAC: Make edac_device workqueue setup/teardown functions static
    
    They're not used anywhere else.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 53587377e672..455a64b67521 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -402,8 +402,8 @@ static void edac_device_workq_function(struct work_struct *work_req)
  *	initialize a workq item for this edac_device instance
  *	passing in the new delay period in msec
  */
-void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
-				unsigned msec)
+static void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
+				    unsigned msec)
 {
 	edac_dbg(0, "\n");
 
@@ -433,7 +433,7 @@ void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
  * edac_device_workq_teardown
  *	stop the workq processing on this edac_dev
  */
-void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev)
+static void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev)
 {
 	if (!edac_dev->edac_check)
 		return;

commit fcd5c4dd8201595d4c598c9cca5e54760277d687
Author: Borislav Petkov <bp@suse.de>
Date:   Fri Nov 27 10:38:38 2015 +0100

    EDAC: Robustify workqueues destruction
    
    EDAC workqueue destruction is really fragile. We cancel delayed work
    but if it is still running and requeues itself, we still go ahead and
    destroy the workqueue and the queued work explodes when workqueue core
    attempts to run it.
    
    Make the destruction more robust by switching op_state to offline so
    that requeuing stops. Cancel any pending work *synchronously* too.
    
      EDAC i7core: Driver loaded.
      general protection fault: 0000 [#1] SMP
      CPU 12
      Modules linked in:
      Supported: Yes
      Pid: 0, comm: kworker/0:1 Tainted: G          IE   3.0.101-0-default #1 HP ProLiant DL380 G7
      RIP: 0010:[<ffffffff8107dcd7>]  [<ffffffff8107dcd7>] __queue_work+0x17/0x3f0
      < ... regs ...>
      Process kworker/0:1 (pid: 0, threadinfo ffff88019def6000, task ffff88019def4600)
      Stack:
       ...
      Call Trace:
       call_timer_fn
       run_timer_softirq
       __do_softirq
       call_softirq
       do_softirq
       irq_exit
       smp_apic_timer_interrupt
       apic_timer_interrupt
       intel_idle
       cpuidle_idle_call
       cpu_idle
      Code: ...
      RIP  __queue_work
       RSP <...>
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: <stable@vger.kernel.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 592af5f0cf39..53587377e672 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -435,16 +435,13 @@ void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
  */
 void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev)
 {
-	int status;
-
 	if (!edac_dev->edac_check)
 		return;
 
-	status = cancel_delayed_work(&edac_dev->work);
-	if (status == 0) {
-		/* workq instance might be running, wait for it */
-		flush_workqueue(edac_workqueue);
-	}
+	edac_dev->op_state = OP_OFFLINE;
+
+	cancel_delayed_work_sync(&edac_dev->work);
+	flush_workqueue(edac_workqueue);
 }
 
 /*

commit 881f0fcef9993992c24f5b649a3fb67fd4208f8f
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Mon Dec 30 12:14:12 2013 -0800

    EDAC: Don't try to cancel workqueue when it's never setup
    
    We only setup a workqueue for edac devices that use the polling
    method. We still try to cancel the workqueue if an edac_device
    uses the irq method though. This causes a warning from debug
    objects when we remove an edac device:
    
    WARNING: CPU: 0 PID: 56 at lib/debugobjects.c:260 debug_print_object+0x98/0xc0()
    ODEBUG: assert_init not available (active state 0) object type: timer_list hint: stub_timer+0x0/0x28
    Modules linked in: krait_edac(-)
    CPU: 0 PID: 56 Comm: rmmod Not tainted 3.12.0-rc2-00035-g15292a0 #69
    (unwind_backtrace+0x0/0x144)
    (show_stack+0x20/0x24)
    (dump_stack+0x74/0xb4)
    (warn_slowpath_common+0x78/0x9c)
    (warn_slowpath_fmt+0x40/0x48)
    (debug_print_object+0x98/0xc0)
    (debug_object_assert_init+0xdc/0xec)
    (del_timer+0x24/0x7c)
    (try_to_grab_pending+0xc0/0x1b0)
    (cancel_delayed_work+0x2c/0xa0)
    (edac_device_workq_teardown+0x1c/0x38)
    (edac_device_del_device+0xb8/0xe4)
    (krait_edac_remove+0x50/0x70 [krait_edac])
    (platform_drv_remove+0x24/0x28)
    (__device_release_driver+0x68/0xc0)
    (driver_detach+0xc4/0xc8)
    (bus_remove_driver+0xac/0x114)
    (driver_unregister+0x38/0x58)
    (platform_driver_unregister+0x1c/0x20)
    (krait_edac_driver_exit+0x14/0x1c [krait_edac])
    (SyS_delete_module+0x178/0x2b4)
    
    Fix it by skipping the workqueue teardown for such devices.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Link: http://lkml.kernel.org/r/1388434457-4194-2-git-send-email-sboyd@codeaurora.org
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 102674346035..592af5f0cf39 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -437,6 +437,9 @@ void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev)
 {
 	int status;
 
+	if (!edac_dev->edac_check)
+		return;
+
 	status = cancel_delayed_work(&edac_dev->work);
 	if (status == 0) {
 		/* workq instance might be running, wait for it */

commit 7270a6085a20a9c6aecb0be8c70510702118dc71
Author: Robert Richter <robert.richter@linaro.org>
Date:   Thu Oct 10 18:22:36 2013 +0200

    edac: Unify reporting of device info for device, mc and pci
    
    Log messages slightly differ between edac subsystems. Unifying it.
    
    Signed-off-by: Robert Richter <robert.richter@linaro.org>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Robert Richter <rric@kernel.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 211021dfec73..102674346035 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -530,12 +530,9 @@ int edac_device_add_device(struct edac_device_ctl_info *edac_dev)
 
 	/* Report action taken */
 	edac_device_printk(edac_dev, KERN_INFO,
-				"Giving out device to module '%s' controller "
-				"'%s': DEV '%s' (%s)\n",
-				edac_dev->mod_name,
-				edac_dev->ctl_name,
-				edac_dev_name(edac_dev),
-				edac_op_state_to_string(edac_dev->op_state));
+		"Giving out device to module %s controller %s: DEV %s (%s)\n",
+		edac_dev->mod_name, edac_dev->ctl_name, edac_dev->dev_name,
+		edac_op_state_to_string(edac_dev->op_state));
 
 	mutex_unlock(&device_ctls_mutex);
 	return 0;

commit c2078e4c9120e7b38b1a02cd9fc6dd4f792110bf
Merge: 73bcc49959e4 f58d0dee07fe
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sun Jul 29 21:11:05 2012 -0300

    Merge branch 'devel'
    
    * devel: (33 commits)
      edac i5000, i5400: fix pointer math in i5000_get_mc_regs()
      edac: allow specifying the error count with fake_inject
      edac: add support for Calxeda highbank L2 cache ecc
      edac: add support for Calxeda highbank memory controller
      edac: create top-level debugfs directory
      sb_edac: properly handle error count
      i7core_edac: properly handle error count
      edac: edac_mc_handle_error(): add an error_count parameter
      edac: remove arch-specific parameter for the error handler
      amd64_edac: Don't pass driver name as an error parameter
      edac_mc: check for allocation failure in edac_mc_alloc()
      edac: Increase version to 3.0.0
      edac_mc: Cleanup per-dimm_info debug messages
      edac: Convert debugfX to edac_dbg(X,
      edac: Use more normal debugging macro style
      edac: Don't add __func__ or __FILE__ for debugf[0-9] msgs
      Edac: Add ABI Documentation for the new device nodes
      edac: move documentation ABI to ABI/testing/sysfs-devices-edac
      i7core_edac: change the mem allocation scheme to make Documentation/kobject.txt happy
      edac: change the mem allocation scheme to make Documentation/kobject.txt happy
      ...

commit 956b9ba156dbfdb9cede2b2927ddf8be2233b3a7
Author: Joe Perches <joe@perches.com>
Date:   Sun Apr 29 17:08:39 2012 -0300

    edac: Convert debugfX to edac_dbg(X,
    
    Use a more common debugging style.
    
    Remove __FILE__ uses, add missing newlines,
    coalesce formats and align arguments.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index ed46949f25cf..9523e76191f2 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -40,12 +40,13 @@ static LIST_HEAD(edac_device_list);
 #ifdef CONFIG_EDAC_DEBUG
 static void edac_device_dump_device(struct edac_device_ctl_info *edac_dev)
 {
-	debugf3("\tedac_dev = %p dev_idx=%d \n", edac_dev, edac_dev->dev_idx);
-	debugf4("\tedac_dev->edac_check = %p\n", edac_dev->edac_check);
-	debugf3("\tdev = %p\n", edac_dev->dev);
-	debugf3("\tmod_name:ctl_name = %s:%s\n",
-		edac_dev->mod_name, edac_dev->ctl_name);
-	debugf3("\tpvt_info = %p\n\n", edac_dev->pvt_info);
+	edac_dbg(3, "\tedac_dev = %p dev_idx=%d\n",
+		 edac_dev, edac_dev->dev_idx);
+	edac_dbg(4, "\tedac_dev->edac_check = %p\n", edac_dev->edac_check);
+	edac_dbg(3, "\tdev = %p\n", edac_dev->dev);
+	edac_dbg(3, "\tmod_name:ctl_name = %s:%s\n",
+		 edac_dev->mod_name, edac_dev->ctl_name);
+	edac_dbg(3, "\tpvt_info = %p\n\n", edac_dev->pvt_info);
 }
 #endif				/* CONFIG_EDAC_DEBUG */
 
@@ -82,8 +83,7 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	void *pvt, *p;
 	int err;
 
-	debugf4("instances=%d blocks=%d\n",
-		nr_instances, nr_blocks);
+	edac_dbg(4, "instances=%d blocks=%d\n", nr_instances, nr_blocks);
 
 	/* Calculate the size of memory we need to allocate AND
 	 * determine the offsets of the various item arrays
@@ -156,8 +156,8 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	/* Name of this edac device */
 	snprintf(dev_ctl->name,sizeof(dev_ctl->name),"%s",edac_device_name);
 
-	debugf4("edac_dev=%p next after end=%p\n",
-		dev_ctl, pvt + sz_private );
+	edac_dbg(4, "edac_dev=%p next after end=%p\n",
+		 dev_ctl, pvt + sz_private);
 
 	/* Initialize every Instance */
 	for (instance = 0; instance < nr_instances; instance++) {
@@ -178,10 +178,8 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 			snprintf(blk->name, sizeof(blk->name),
 				 "%s%d", edac_block_name, block+offset_value);
 
-			debugf4("instance=%d inst_p=%p block=#%d "
-				"block_p=%p name='%s'\n",
-				instance, inst, block,
-				blk, blk->name);
+			edac_dbg(4, "instance=%d inst_p=%p block=#%d block_p=%p name='%s'\n",
+				 instance, inst, block, blk, blk->name);
 
 			/* if there are NO attributes OR no attribute pointer
 			 * then continue on to next block iteration
@@ -194,8 +192,8 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 			attrib_p = &dev_attrib[block*nr_instances*nr_attrib];
 			blk->block_attributes = attrib_p;
 
-			debugf4("THIS BLOCK_ATTRIB=%p\n",
-				blk->block_attributes);
+			edac_dbg(4, "THIS BLOCK_ATTRIB=%p\n",
+				 blk->block_attributes);
 
 			/* Initialize every user specified attribute in this
 			 * block with the data the caller passed in
@@ -214,11 +212,10 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 
 				attrib->block = blk;	/* up link */
 
-				debugf4("alloc-attrib=%p attrib_name='%s' "
-					"attrib-spec=%p spec-name=%s\n",
-					attrib, attrib->attr.name,
-					&attrib_spec[attr],
-					attrib_spec[attr].attr.name
+				edac_dbg(4, "alloc-attrib=%p attrib_name='%s' attrib-spec=%p spec-name=%s\n",
+					 attrib, attrib->attr.name,
+					 &attrib_spec[attr],
+					 attrib_spec[attr].attr.name
 					);
 			}
 		}
@@ -273,7 +270,7 @@ static struct edac_device_ctl_info *find_edac_device_by_dev(struct device *dev)
 	struct edac_device_ctl_info *edac_dev;
 	struct list_head *item;
 
-	debugf0("\n");
+	edac_dbg(0, "\n");
 
 	list_for_each(item, &edac_device_list) {
 		edac_dev = list_entry(item, struct edac_device_ctl_info, link);
@@ -408,7 +405,7 @@ static void edac_device_workq_function(struct work_struct *work_req)
 void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
 				unsigned msec)
 {
-	debugf0("\n");
+	edac_dbg(0, "\n");
 
 	/* take the arg 'msec' and set it into the control structure
 	 * to used in the time period calculation
@@ -496,7 +493,7 @@ EXPORT_SYMBOL_GPL(edac_device_alloc_index);
  */
 int edac_device_add_device(struct edac_device_ctl_info *edac_dev)
 {
-	debugf0("\n");
+	edac_dbg(0, "\n");
 
 #ifdef CONFIG_EDAC_DEBUG
 	if (edac_debug_level >= 3)
@@ -570,7 +567,7 @@ struct edac_device_ctl_info *edac_device_del_device(struct device *dev)
 {
 	struct edac_device_ctl_info *edac_dev;
 
-	debugf0("\n");
+	edac_dbg(0, "\n");
 
 	mutex_lock(&device_ctls_mutex);
 

commit dd23cd6eb1f59ba722a6e6aa228adff7c01404de
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Sun Apr 29 11:59:14 2012 -0300

    edac: Don't add __func__ or __FILE__ for debugf[0-9] msgs
    
    The debug macro already adds that. Most of the work here was
    made by this small script:
    
    $f .=$_ while (<>);
    
    $f =~ s/(debugf[0-9]\s*\(\s*)__FILE__\s*": /\1"/g;
    $f =~ s/(debugf[0-9]\s*\(\s*)__FILE__\s*/\1/g;
    $f =~ s/(debugf[0-9]\s*\(\s*)__FILE__\s*"MC: /\1"/g;
    
    $f =~ s/(debugf[0-9]\s*\(\")\%s[\:\,\(\)]*\s*([^\"]*\s*[^\)]+)__func__\s*\,\s*/\1\2/g;
    $f =~ s/(debugf[0-9]\s*\(\")\%s[\:\,\(\)]*\s*([^\"]*\s*[^\)]+),\s*__func__\s*\)/\1\2)/g;
    $f =~ s/(debugf[0-9]\s*\(\"MC\:\s*)\%s[\:\,\(\)]*\s*([^\"]*\s*[^\)]+)__func__\s*\,\s*/\1\2/g;
    $f =~ s/(debugf[0-9]\s*\(\"MC\:\s*)\%s[\:\,\(\)]*\s*([^\"]*\s*[^\)]+),\s*__func__\s*\)/\1\2)/g;
    
    $f =~ s/\"MC\: \\n\"/"MC:\\n"/g;
    
    print $f;
    
    After running the script, manual cleanups were done to fix it the remaining
    places.
    
    While here, removed the __LINE__ on most places, as it doesn't actually give
    useful info on most places.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index cb397d9437d1..ed46949f25cf 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -82,8 +82,8 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	void *pvt, *p;
 	int err;
 
-	debugf4("%s() instances=%d blocks=%d\n",
-		__func__, nr_instances, nr_blocks);
+	debugf4("instances=%d blocks=%d\n",
+		nr_instances, nr_blocks);
 
 	/* Calculate the size of memory we need to allocate AND
 	 * determine the offsets of the various item arrays
@@ -156,8 +156,8 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	/* Name of this edac device */
 	snprintf(dev_ctl->name,sizeof(dev_ctl->name),"%s",edac_device_name);
 
-	debugf4("%s() edac_dev=%p next after end=%p\n",
-		__func__, dev_ctl, pvt + sz_private );
+	debugf4("edac_dev=%p next after end=%p\n",
+		dev_ctl, pvt + sz_private );
 
 	/* Initialize every Instance */
 	for (instance = 0; instance < nr_instances; instance++) {
@@ -178,9 +178,9 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 			snprintf(blk->name, sizeof(blk->name),
 				 "%s%d", edac_block_name, block+offset_value);
 
-			debugf4("%s() instance=%d inst_p=%p block=#%d "
+			debugf4("instance=%d inst_p=%p block=#%d "
 				"block_p=%p name='%s'\n",
-				__func__, instance, inst, block,
+				instance, inst, block,
 				blk, blk->name);
 
 			/* if there are NO attributes OR no attribute pointer
@@ -194,8 +194,8 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 			attrib_p = &dev_attrib[block*nr_instances*nr_attrib];
 			blk->block_attributes = attrib_p;
 
-			debugf4("%s() THIS BLOCK_ATTRIB=%p\n",
-				__func__, blk->block_attributes);
+			debugf4("THIS BLOCK_ATTRIB=%p\n",
+				blk->block_attributes);
 
 			/* Initialize every user specified attribute in this
 			 * block with the data the caller passed in
@@ -214,9 +214,9 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 
 				attrib->block = blk;	/* up link */
 
-				debugf4("%s() alloc-attrib=%p attrib_name='%s' "
+				debugf4("alloc-attrib=%p attrib_name='%s' "
 					"attrib-spec=%p spec-name=%s\n",
-					__func__, attrib, attrib->attr.name,
+					attrib, attrib->attr.name,
 					&attrib_spec[attr],
 					attrib_spec[attr].attr.name
 					);
@@ -273,7 +273,7 @@ static struct edac_device_ctl_info *find_edac_device_by_dev(struct device *dev)
 	struct edac_device_ctl_info *edac_dev;
 	struct list_head *item;
 
-	debugf0("%s()\n", __func__);
+	debugf0("\n");
 
 	list_for_each(item, &edac_device_list) {
 		edac_dev = list_entry(item, struct edac_device_ctl_info, link);
@@ -408,7 +408,7 @@ static void edac_device_workq_function(struct work_struct *work_req)
 void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
 				unsigned msec)
 {
-	debugf0("%s()\n", __func__);
+	debugf0("\n");
 
 	/* take the arg 'msec' and set it into the control structure
 	 * to used in the time period calculation
@@ -496,7 +496,7 @@ EXPORT_SYMBOL_GPL(edac_device_alloc_index);
  */
 int edac_device_add_device(struct edac_device_ctl_info *edac_dev)
 {
-	debugf0("%s()\n", __func__);
+	debugf0("\n");
 
 #ifdef CONFIG_EDAC_DEBUG
 	if (edac_debug_level >= 3)
@@ -570,7 +570,7 @@ struct edac_device_ctl_info *edac_device_del_device(struct device *dev)
 {
 	struct edac_device_ctl_info *edac_dev;
 
-	debugf0("%s()\n", __func__);
+	debugf0("\n");
 
 	mutex_lock(&device_ctls_mutex);
 

commit 87a5af24e54857e7b15c1f1b0468512ee65c94e3
Merge: 7e5b2db77b05 0bf09e829dd4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue May 29 18:32:37 2012 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-edac
    
    Pull EDAC internal API changes from Mauro Carvalho Chehab:
     "This changeset is the first part of a series of patches that fixes the
      EDAC sybsystem.  On this set, it changes the Kernel EDAC API in order
      to properly represent the Intel i3/i5/i7, Xeon 3xxx/5xxx/7xxx, and
      Intel E5-xxxx memory controllers.
    
      The EDAC core used to assume that:
    
           - the DRAM chip select pin is directly accessed by the memory
             controller
    
           - when multiple channels are used, they're all filled with the
             same type of memory.
    
      None of the above premises is true on Intel memory controllers since
      2002, when RAMBUS and FB-DIMMs were introduced, and Advanced Memory
      Buffer or by some similar technologies hides the direct access to the
      DRAM pins.
    
      So, the existing drivers for those chipsets had to lie to the EDAC
      core, in general telling that just one channel is filled.  That
      produces some hard to understand error messages like:
    
           EDAC MC0: CE row 3, channel 0, label "DIMM1": 1 Unknown error(s): memory read error on FATAL area : cpu=0 Err=0008:00c2 (ch=2), addr = 0xad1f73480 => socket=0, Channel=0(mask=2), rank=1
    
      The location information there (row3 channel 0) is completely bogus:
      it has no physical meaning, and are just some random values that the
      driver uses to talk with the EDAC core.  The error actually happened
      at CPU socket 0, channel 0, slot 1, but this is not reported anywhere,
      as the EDAC core doesn't know anything about the memory layout.  So,
      only advanced users that know how the EDAC driver works and that tests
      their systems to see how DIMMs are mapped can actually benefit for
      such error logs.
    
      This patch series fixes the error report logic, in order to allow the
      EDAC to expose the memory architecture used by them to the EDAC core.
      So, as the EDAC core now understands how the memory is organized, it
      can provide an useful report:
    
           EDAC MC0: CE memory read error on DIMM1 (channel:0 slot:1 page:0x364b1b offset:0x600 grain:32 syndrome:0x0 - count:1 area:DRAM err_code:0001:0090 socket:0 channel_mask:1 rank:4)
    
      The location of the DIMM where the error happened is reported by "MC0"
      (cpu socket #0), at "channel:0 slot:1" location, and matches the
      physical location of the DIMM.
    
      There are two remaining issues not covered by this patch series:
    
           - The EDAC sysfs API will still report bogus values.  So,
             userspace tools like edac-utils will still use the bogus data;
    
           - Add a new tracepoint-based way to get the binary information
             about the errors.
    
      Those are on a second series of patches (also at -next), but will
      probably miss the train for 3.5, due to the slow review process."
    
    Fix up trivial conflict (due to spelling correction of removed code) in
    drivers/edac/edac_device.c
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/mchehab/linux-edac: (42 commits)
      i7core: fix ranks information at the per-channel struct
      i5000: Fix the fatal error handling
      i5100_edac: Fix a warning when compiled with 32 bits
      i82975x_edac: Test nr_pages earlier to save a few CPU cycles
      e752x_edac: provide more info about how DIMMS/ranks are mapped
      i5000_edac: Fix the logic that retrieves memory information
      i5400_edac: improve debug messages to better represent the filled memory
      edac: Cleanup the logs for i7core and sb edac drivers
      edac: Initialize the dimm label with the known information
      edac: Remove the legacy EDAC ABI
      x38_edac: convert driver to use the new edac ABI
      tile_edac: convert driver to use the new edac ABI
      sb_edac: convert driver to use the new edac ABI
      r82600_edac: convert driver to use the new edac ABI
      ppc4xx_edac: convert driver to use the new edac ABI
      pasemi_edac: convert driver to use the new edac ABI
      mv64x60_edac: convert driver to use the new edac ABI
      mpc85xx_edac: convert driver to use the new edac ABI
      i82975x_edac: convert driver to use the new edac ABI
      i82875p_edac: convert driver to use the new edac ABI
      ...

commit 93e4fe64ece4eccf0ff4ac69bceb389290b8ab7c
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Apr 16 10:18:12 2012 -0300

    edac: rewrite edac_align_ptr()
    
    The edac_align_ptr() function is used to prepare data for a single
    memory allocation kzalloc() call. It counts how many bytes are needed
    by some data structure.
    
    Using it as-is is not that trivial, as the quantity of memory elements
    reserved is not there, but, instead, it is on a next call.
    
    In order to avoid mistakes when using it, move the number of allocated
    elements into it, making easier to use it.
    
    Reviewed-by: Borislav Petkov <bp@amd64.org>
    Cc: Aristeu Rozanski <arozansk@redhat.com>
    Cc: Doug Thompson <norsk5@yahoo.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 4b154593343a..cb397d9437d1 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -79,7 +79,7 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	unsigned total_size;
 	unsigned count;
 	unsigned instance, block, attr;
-	void *pvt;
+	void *pvt, *p;
 	int err;
 
 	debugf4("%s() instances=%d blocks=%d\n",
@@ -92,35 +92,30 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	 * to be at least as stringent as what the compiler would
 	 * provide if we could simply hardcode everything into a single struct.
 	 */
-	dev_ctl = (struct edac_device_ctl_info *)NULL;
+	p = NULL;
+	dev_ctl = edac_align_ptr(&p, sizeof(*dev_ctl), 1);
 
 	/* Calc the 'end' offset past end of ONE ctl_info structure
 	 * which will become the start of the 'instance' array
 	 */
-	dev_inst = edac_align_ptr(&dev_ctl[1], sizeof(*dev_inst));
+	dev_inst = edac_align_ptr(&p, sizeof(*dev_inst), nr_instances);
 
 	/* Calc the 'end' offset past the instance array within the ctl_info
 	 * which will become the start of the block array
 	 */
-	dev_blk = edac_align_ptr(&dev_inst[nr_instances], sizeof(*dev_blk));
+	count = nr_instances * nr_blocks;
+	dev_blk = edac_align_ptr(&p, sizeof(*dev_blk), count);
 
 	/* Calc the 'end' offset past the dev_blk array
 	 * which will become the start of the attrib array, if any.
 	 */
-	count = nr_instances * nr_blocks;
-	dev_attrib = edac_align_ptr(&dev_blk[count], sizeof(*dev_attrib));
-
-	/* Check for case of when an attribute array is specified */
-	if (nr_attrib > 0) {
-		/* calc how many nr_attrib we need */
+	/* calc how many nr_attrib we need */
+	if (nr_attrib > 0)
 		count *= nr_attrib;
+	dev_attrib = edac_align_ptr(&p, sizeof(*dev_attrib), count);
 
-		/* Calc the 'end' offset past the attributes array */
-		pvt = edac_align_ptr(&dev_attrib[count], sz_private);
-	} else {
-		/* no attribute array specificed */
-		pvt = edac_align_ptr(dev_attrib, sz_private);
-	}
+	/* Calc the 'end' offset past the attributes array */
+	pvt = edac_align_ptr(&p, sz_private, 1);
 
 	/* 'pvt' now points to where the private data area is.
 	 * At this point 'pvt' (like dev_inst,dev_blk and dev_attrib)

commit f70d4a95edc7da87f39cd8b603ba131df2c198ed
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Tue May 22 10:56:21 2012 +0200

    edac, mips: don't change code that has been removed in edac/mips tree
    
    This is a partial revert of
    
            15ed103a9800 ("edac: Fix spelling errors")
            6997991ab0db ("mips: Fix printk typos in arc/mips")
    
    which change code that doesn't exist any more in edac/mips trees.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index da4a1f11939f..45b8f4bdd773 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -367,7 +367,7 @@ static void del_edac_device_from_global_list(struct edac_device_ctl_info
  *	structure, that needs to be polled for possible error events.
  *
  *	This operation is to acquire the list mutex lock
- *	(thus preventing insertion or deletion)
+ *	(thus preventing insertation or deletion)
  *	and then call the device's poll function IFF this device is
  *	running polled and there is a poll function defined.
  */

commit 15ed103a98008d85f20956e0e29c2cae78051efe
Author: David Mackey <tdmackey@twitter.com>
Date:   Tue Apr 17 11:30:52 2012 -0700

    edac: Fix spelling errors.
    
    Signed-off-by: David Mackey <tdmackey@twitter.com>
    Signed-off-by: Vinson Lee <vlee@twitter.com>
    Acked-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 4b154593343a..da4a1f11939f 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -56,7 +56,7 @@ static void edac_device_dump_device(struct edac_device_ctl_info *edac_dev)
  *
  *	The control structure is allocated in complete chunk
  *	from the OS. It is in turn sub allocated to the
- *	various objects that compose the struture
+ *	various objects that compose the structure
  *
  *	The structure has a 'nr_instance' array within itself.
  *	Each instance represents a major component
@@ -118,7 +118,7 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 		/* Calc the 'end' offset past the attributes array */
 		pvt = edac_align_ptr(&dev_attrib[count], sz_private);
 	} else {
-		/* no attribute array specificed */
+		/* no attribute array specified */
 		pvt = edac_align_ptr(dev_attrib, sz_private);
 	}
 
@@ -367,7 +367,7 @@ static void del_edac_device_from_global_list(struct edac_device_ctl_info
  *	structure, that needs to be polled for possible error events.
  *
  *	This operation is to acquire the list mutex lock
- *	(thus preventing insertation or deletion)
+ *	(thus preventing insertion or deletion)
  *	and then call the device's poll function IFF this device is
  *	running polled and there is a poll function defined.
  */
@@ -394,7 +394,7 @@ static void edac_device_workq_function(struct work_struct *work_req)
 
 	/* Reschedule the workq for the next time period to start again
 	 * if the number of msec is for 1 sec, then adjust to the next
-	 * whole one second to save timers fireing all over the period
+	 * whole one second to save timers firing all over the period
 	 * between integral seconds
 	 */
 	if (edac_dev->poll_msec == 1000)
@@ -563,7 +563,7 @@ EXPORT_SYMBOL_GPL(edac_device_add_device);
  *	Remove sysfs entries for specified edac_device structure and
  *	then remove edac_device structure from global list
  *
- * @pdev:
+ * @dev:
  *	Pointer to 'struct device' representing edac_device
  *	structure to remove.
  *

commit fe5ff8b84c8b03348a2f64ea9d884348faec2217
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Dec 14 15:21:07 2011 -0800

    edac: convert sysdev_class to a regular subsystem
    
    After all sysdev classes are ported to regular driver core entities, the
    sysdev implementation will be entirely removed from the kernel.
    
    Cc: Doug Thompson <dougthompson@xmission.com>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Lucas De Marchi <lucas.demarchi@profusion.mobi>
    Cc: Borislav Petkov <borislav.petkov@amd.com>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index c3f67437afb6..4b154593343a 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -23,7 +23,6 @@
 #include <linux/jiffies.h>
 #include <linux/spinlock.h>
 #include <linux/list.h>
-#include <linux/sysdev.h>
 #include <linux/ctype.h>
 #include <linux/workqueue.h>
 #include <asm/uaccess.h>

commit e2e77098764636456ba7092a8b3b3b34b2a8e8d8
Author: Lai Jiangshan <laijs@cn.fujitsu.com>
Date:   Thu May 26 16:25:58 2011 -0700

    edac,rcu: use synchronize_rcu() instead of call_rcu()+rcu_barrier()
    
    synchronize_rcu() does the stuff as needed.
    
    Signed-off-by: Lai Jiangshan <laijs@cn.fujitsu.com>
    Cc: Doug Thompson <dougthompson@xmission.com>
    Cc: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index a7408cf86f37..c3f67437afb6 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -345,31 +345,19 @@ static int add_edac_dev_to_global_list(struct edac_device_ctl_info *edac_dev)
 	return 1;
 }
 
-/*
- * complete_edac_device_list_del
- *
- *	callback function when reference count is zero
- */
-static void complete_edac_device_list_del(struct rcu_head *head)
-{
-	struct edac_device_ctl_info *edac_dev;
-
-	edac_dev = container_of(head, struct edac_device_ctl_info, rcu);
-	INIT_LIST_HEAD(&edac_dev->link);
-}
-
 /*
  * del_edac_device_from_global_list
- *
- *	remove the RCU, setup for a callback call,
- *	then wait for the callback to occur
  */
 static void del_edac_device_from_global_list(struct edac_device_ctl_info
 						*edac_device)
 {
 	list_del_rcu(&edac_device->link);
-	call_rcu(&edac_device->rcu, complete_edac_device_list_del);
-	rcu_barrier();
+
+	/* these are for safe removal of devices from global list while
+	 * NMI handlers may be traversing list
+	 */
+	synchronize_rcu();
+	INIT_LIST_HEAD(&edac_device->link);
 }
 
 /*

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index d5e13c94714f..a7408cf86f37 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -672,7 +672,7 @@ void edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,
 		block->counters.ce_count++;
 	}
 
-	/* Propogate the count up the 'totals' tree */
+	/* Propagate the count up the 'totals' tree */
 	instance->counters.ce_count++;
 	edac_dev->counters.ce_count++;
 
@@ -718,7 +718,7 @@ void edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,
 		block->counters.ue_count++;
 	}
 
-	/* Propogate the count up the 'totals' tree */
+	/* Propagate the count up the 'totals' tree */
 	instance->counters.ue_count++;
 	edac_dev->counters.ue_count++;
 

commit 458e5ff13e1bed050990d97e9aa55bcdafc951a7
Author: Jesper Dangaard Brouer <hawk@comx.dk>
Date:   Wed Sep 23 15:57:29 2009 -0700

    edac: core: remove completion-wait for complete with rcu_barrier
    
    Module edac_core.ko uses call_rcu() callbacks in edac_device.c, edac_mc.c
    and edac_pci.c.
    
    They all use a wait_for_completion() scheme, but this scheme it not 100%
    safe on multiple CPUs.  See the _rcu_barrier() implementation which
    explains why extra precausion is needed.
    
    The patch adds a comment about rcu_barrier() and as a precausion calls
    rcu_barrier().  A maintainer needs to look at removing the
    wait_for_completion code.
    
    [dougthompson@xmission.com: remove the wait_for_completion code]
    Signed-off-by Jesper Dangaard Brouer <hawk@comx.dk>
    Signed-off-by: Doug Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index b02a6a69a8f0..d5e13c94714f 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -356,7 +356,6 @@ static void complete_edac_device_list_del(struct rcu_head *head)
 
 	edac_dev = container_of(head, struct edac_device_ctl_info, rcu);
 	INIT_LIST_HEAD(&edac_dev->link);
-	complete(&edac_dev->removal_complete);
 }
 
 /*
@@ -369,10 +368,8 @@ static void del_edac_device_from_global_list(struct edac_device_ctl_info
 						*edac_device)
 {
 	list_del_rcu(&edac_device->link);
-
-	init_completion(&edac_device->removal_complete);
 	call_rcu(&edac_device->rcu, complete_edac_device_list_del);
-	wait_for_completion(&edac_device->removal_complete);
+	rcu_barrier();
 }
 
 /*

commit 1dc9b70d7d48abd8a5c6f83021f38992f3b5a77f
Author: Harry Ciao <qingtao.cao@windriver.com>
Date:   Wed Jun 17 16:27:59 2009 -0700

    edac: add edac_device_alloc_index()
    
    Add edac_device_alloc_index(), because for MAPLE platform there may
    exist several EDAC driver modules that could make use of
    edac_device_ctl_info structure at the same time. The index allocation
    for these structures should be taken care of by EDAC core.
    
    [akpm@linux-foundation.org: cleanups]
    Signed-off-by: Harry Ciao <qingtao.cao@windriver.com>
    Cc: Doug Thompson <norsk5@yahoo.com>
    Cc: Michael Ellerman <michael@ellerman.id.au>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Kumar Gala <galak@gate.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index a7d2c717d033..b02a6a69a8f0 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -490,6 +490,20 @@ void edac_device_reset_delay_period(struct edac_device_ctl_info *edac_dev,
 	mutex_unlock(&device_ctls_mutex);
 }
 
+/*
+ * edac_device_alloc_index: Allocate a unique device index number
+ *
+ * Return:
+ *	allocated index number
+ */
+int edac_device_alloc_index(void)
+{
+	static atomic_t device_indexes = ATOMIC_INIT(0);
+
+	return atomic_inc_return(&device_indexes) - 1;
+}
+EXPORT_SYMBOL_GPL(edac_device_alloc_index);
+
 /**
  * edac_device_add_device: Insert the 'edac_dev' structure into the
  * edac_device global list and create sysfs entries associated with

commit fbeb4384748abb78531bbe1e80d627412a0abcfa
Author: Jean Delvare <khali@linux-fr.org>
Date:   Mon Apr 13 14:40:21 2009 -0700

    edac: use to_delayed_work()
    
    The edac-core driver includes code which assumes that the work_struct
    which is included in every delayed_work is the first member of that
    structure.  This is currently the case but might change in the future, so
    use to_delayed_work() instead, which doesn't make such an assumption.
    
    linux-2.6.30-rc1 has the to_delayed_work() function that will allow this
    patch to work
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Doug Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index ca9113e1c106..a7d2c717d033 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -389,7 +389,7 @@ static void del_edac_device_from_global_list(struct edac_device_ctl_info
  */
 static void edac_device_workq_function(struct work_struct *work_req)
 {
-	struct delayed_work *d_work = (struct delayed_work *)work_req;
+	struct delayed_work *d_work = to_delayed_work(work_req);
 	struct edac_device_ctl_info *edac_dev = to_edac_device_ctl_work(d_work);
 
 	mutex_lock(&device_ctls_mutex);

commit 281efb17d88a91dc3b879bb1d49e3a66daf48797
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Jan 6 14:42:57 2009 -0800

    edac: struct device: replace bus_id with dev_name(), dev_set_name()
    
    This patch is part of a larger patch series which will remove the "char
    bus_id[20]" name string from struct device.  The device name is managed in
    the kobject anyway, and without any size limitation, and just needlessly
    copied into "struct device".
    
    [akpm@linux-foundation.org: coding-style fixes]
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Acked-by: Doug Thompson <dougthompson@xmission.com>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 4041e9143283..ca9113e1c106 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -333,7 +333,7 @@ static int add_edac_dev_to_global_list(struct edac_device_ctl_info *edac_dev)
 fail0:
 	edac_printk(KERN_WARNING, EDAC_MC,
 			"%s (%s) %s %s already assigned %d\n",
-			rover->dev->bus_id, edac_dev_name(rover),
+			dev_name(rover->dev), edac_dev_name(rover),
 			rover->mod_name, rover->ctl_name, rover->dev_idx);
 	return 1;
 

commit d519c8d9ccb7956e61a55ce3a0fd6a25f42cbb33
Author: Harry Ciao <qingtao.cao@windriver.com>
Date:   Tue Dec 23 13:57:16 2008 -0800

    edac: fix edac core deadlock when removing a device
    
    When deleting an edac device, we have to wait for its edac_dev.work to be
    completed before deleting the whole edac_dev structure.  Since we have no
    idea which work in current edac_poller's workqueue is the work we are
    conerned about, we wait for all work in the edac_poller's workqueue to be
    proceseed.  This is done via flush_cpu_workqueue() which inserts a
    wq_barrier into the tail of the workqueue and then sleeping on the
    completion of this wq_barrier.  The edac_poller will wake up sleepers when
    it is found.
    
    EDAC core creates only one kernel worker thread, edac_poller, to run the
    works of all current edac devices.  They share the same callback function
    of edac_device_workq_function(), which would grab the mutex of
    device_ctls_mutex first before it checks the device.  This is exactly
    where edac_poller and rmmod would have a great chance to deadlock.
    
    In below call trace of rmmod > ... >
    edac_device_del_device >
    edac_device_workq_teardown > flush_workqueue > flush_cpu_workqueue,
    
    device_ctls_mutex would have already been grabbed by
    edac_device_del_device().  So, on one hand rmmod would sleep on the
    completion of a wq_barrier, holding device_ctls_mutex; on the other hand
    edac_poller would be blocked on the same mutex when it's running any one
    of works of existing edac evices(Note, this edac_dev.work is likely to be
    totally irrelevant to the one that is being removed right now)and never
    would have a chance to run the work of above wq_barrier to wake rmmod up.
    
    edac_device_workq_teardown() should not be called within the critical
    region of device_ctls_mutex.  Just like is done in edac_pci_del_device()
    and edac_mc_del_mc(), where edac_pci_workq_teardown() and
    edac_mc_workq_teardown() are called after related mutex are released.
    
    Moreover, an edac_dev.work should check first if it is being removed.  If
    this is the case, then it should bail out immediately.  Since not all of
    existing edac devices are to be removed, this "shutting flag" should be
    contained to edac device being removed.  The current edac_dev.op_state can
    be used to serve this purpose.
    
    The original deadlock problem and the solution have been witnessed and
    tested on actual hardware.  Without the solution, rmmod an edac driver
    would result in below deadlock:
    
    root@localhost:/root> rmmod mv64x60_edac
    EDAC DEBUG: mv64x60_dma_err_remove()
    EDAC DEBUG: edac_device_del_device()
    EDAC DEBUG: find_edac_device_by_dev()
    
    (hang for a moment)
    
    INFO: task edac-poller:2030 blocked for more than 120 seconds.
    "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    edac-poller   D 00000000     0  2030      2
    Call Trace:
    [df159dc0] [c0071e3c] free_hot_cold_page+0x17c/0x304 (unreliable)
    [df159e80] [c000a024] __switch_to+0x6c/0xa0
    [df159ea0] [c03587d8] schedule+0x2f4/0x4d8
    [df159f00] [c03598a8] __mutex_lock_slowpath+0xa0/0x174
    [df159f40] [e1030434] edac_device_workq_function+0x28/0xd8 [edac_core]
    [df159f60] [c003beb4] run_workqueue+0x114/0x218
    [df159f90] [c003c674] worker_thread+0x5c/0xc8
    [df159fd0] [c004106c] kthread+0x5c/0xa0
    [df159ff0] [c0013538] original_kernel_thread+0x44/0x60
    INFO: task rmmod:2062 blocked for more than 120 seconds.
    "echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    rmmod         D 0ff2c9fc     0  2062   1839
    Call Trace:
    [df119c00] [c0437a74] 0xc0437a74 (unreliable)
    [df119cc0] [c000a024] __switch_to+0x6c/0xa0
    [df119ce0] [c03587d8] schedule+0x2f4/0x4d8
    [df119d40] [c03591dc] schedule_timeout+0xb0/0xf4
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 5fcd3d89c75d..4041e9143283 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -394,6 +394,12 @@ static void edac_device_workq_function(struct work_struct *work_req)
 
 	mutex_lock(&device_ctls_mutex);
 
+	/* If we are being removed, bail out immediately */
+	if (edac_dev->op_state == OP_OFFLINE) {
+		mutex_unlock(&device_ctls_mutex);
+		return;
+	}
+
 	/* Only poll controllers that are running polled and have a check */
 	if ((edac_dev->op_state == OP_RUNNING_POLL) &&
 		(edac_dev->edac_check != NULL)) {
@@ -585,14 +591,14 @@ struct edac_device_ctl_info *edac_device_del_device(struct device *dev)
 	/* mark this instance as OFFLINE */
 	edac_dev->op_state = OP_OFFLINE;
 
-	/* clear workq processing on this instance */
-	edac_device_workq_teardown(edac_dev);
-
 	/* deregister from global list */
 	del_edac_device_from_global_list(edac_dev);
 
 	mutex_unlock(&device_ctls_mutex);
 
+	/* clear workq processing on this instance */
+	edac_device_workq_teardown(edac_dev);
+
 	/* Tear down the sysfs entries for this instance */
 	edac_device_remove_sysfs(edac_dev);
 

commit 17aa7e034416e3080bc57a786d09ba0a4a044561
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Mon May 5 13:54:19 2008 +1000

    dev_name introduction fall out fix
    
    Commit 06916639e2fed9ee475efef2747a1b7429f8fe76 ("driver-core: add
    dev_name() to help transition away from using bus_id") added a static
    inline dev_name() and used it in dev_printk.
    
    Unfortunately, drivers/edac/edac_core.h defines a macro called
    dev_name().  Rename the latter.
    
    Diagnosis by Tony Breeds and Michael Ellerman.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Doug Thompson <dougthompson@xmission.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 63372fa7ecfe..5fcd3d89c75d 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -333,7 +333,7 @@ static int add_edac_dev_to_global_list(struct edac_device_ctl_info *edac_dev)
 fail0:
 	edac_printk(KERN_WARNING, EDAC_MC,
 			"%s (%s) %s %s already assigned %d\n",
-			rover->dev->bus_id, dev_name(rover),
+			rover->dev->bus_id, edac_dev_name(rover),
 			rover->mod_name, rover->ctl_name, rover->dev_idx);
 	return 1;
 
@@ -538,7 +538,7 @@ int edac_device_add_device(struct edac_device_ctl_info *edac_dev)
 				"'%s': DEV '%s' (%s)\n",
 				edac_dev->mod_name,
 				edac_dev->ctl_name,
-				dev_name(edac_dev),
+				edac_dev_name(edac_dev),
 				edac_op_state_to_string(edac_dev->op_state));
 
 	mutex_unlock(&device_ctls_mutex);
@@ -599,7 +599,7 @@ struct edac_device_ctl_info *edac_device_del_device(struct device *dev)
 	edac_printk(KERN_INFO, EDAC_MC,
 		"Removed device %d for %s %s: DEV %s\n",
 		edac_dev->dev_idx,
-		edac_dev->mod_name, edac_dev->ctl_name, dev_name(edac_dev));
+		edac_dev->mod_name, edac_dev->ctl_name, edac_dev_name(edac_dev));
 
 	return edac_dev;
 }

commit 1a45027d1afd7e85254b5ef8535e93ce3d588cf4
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Apr 29 01:03:18 2008 -0700

    edac: remove unneeded functions and add static accessor
    
    Collection of patches, merged into one, from Adrian that do the following:
    
    1) This patch makes the following needlessly global functions static:
    - edac_pci_get_log_pe()
    - edac_pci_get_log_npe()
    - edac_pci_get_panic_on_pe()
    - edac_pci_unregister_sysfs_instance_kobj()
    - edac_pci_main_kobj_setup()
    
    2) Remove unneeded function edac_device_find()
    
    3) Added #if 0 around function  edac_pci_find()
    
    4) make the needlessly global edac_pci_generic_check() static
    
    5) Removed function edac_check_mc_devices()
    
    Doug Thompson modified Adrian's patches, to bettern represent
    the direction of EDAC, and make them one patch.
    
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Doug Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index c559bf543422..63372fa7ecfe 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -375,37 +375,6 @@ static void del_edac_device_from_global_list(struct edac_device_ctl_info
 	wait_for_completion(&edac_device->removal_complete);
 }
 
-/**
- * edac_device_find
- *	Search for a edac_device_ctl_info structure whose index is 'idx'.
- *
- * If found, return a pointer to the structure.
- * Else return NULL.
- *
- * Caller must hold device_ctls_mutex.
- */
-struct edac_device_ctl_info *edac_device_find(int idx)
-{
-	struct list_head *item;
-	struct edac_device_ctl_info *edac_dev;
-
-	/* Iterate over list, looking for exact match of ID */
-	list_for_each(item, &edac_device_list) {
-		edac_dev = list_entry(item, struct edac_device_ctl_info, link);
-
-		if (edac_dev->dev_idx >= idx) {
-			if (edac_dev->dev_idx == idx)
-				return edac_dev;
-
-			/* not on list, so terminate early */
-			break;
-		}
-	}
-
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(edac_device_find);
-
 /*
  * edac_device_workq_function
  *	performs the operation scheduled by a workq request

commit ff6ac2a616c85d1215899ffda815e29b699cbd3a
Author: Robert P. J. Day <rpjday@crashcourse.ca>
Date:   Tue Apr 29 01:03:17 2008 -0700

    edac: use the shorter LIST_HEAD for brevity
    
    Signed-off-by: Robert P. J. Day <rpjday@crashcourse.ca>
    Acked-by: Doug Thompson <norsk5@yahoo.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index b9552bc03dea..c559bf543422 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -36,7 +36,7 @@
  * is protected by the 'device_ctls_mutex' lock
  */
 static DEFINE_MUTEX(device_ctls_mutex);
-static struct list_head edac_device_list = LIST_HEAD_INIT(edac_device_list);
+static LIST_HEAD(edac_device_list);
 
 #ifdef CONFIG_EDAC_DEBUG
 static void edac_device_dump_device(struct edac_device_ctl_info *edac_dev)

commit c2ae24cfd1969a28e76641807026a3bbc11c5f31
Author: Anton Blanchard <anton@samba.org>
Date:   Thu Feb 7 00:14:51 2008 -0800

    drivers-edac: use round_jiffies_relative
    
    When rounding a relative timeout we need to use round_jiffies_relative().
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Acked-by: Arjan van de Ven <arjan@linux.intel.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk
    Signed-off-by: Doug Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 55d14d008dd6..b9552bc03dea 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -440,7 +440,7 @@ static void edac_device_workq_function(struct work_struct *work_req)
 	 */
 	if (edac_dev->poll_msec == 1000)
 		queue_delayed_work(edac_workqueue, &edac_dev->work,
-				round_jiffies(edac_dev->delay));
+				round_jiffies_relative(edac_dev->delay));
 	else
 		queue_delayed_work(edac_workqueue, &edac_dev->work,
 				edac_dev->delay);
@@ -472,7 +472,7 @@ void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
 	 */
 	if (edac_dev->poll_msec == 1000)
 		queue_delayed_work(edac_workqueue, &edac_dev->work,
-				round_jiffies(edac_dev->delay));
+				round_jiffies_relative(edac_dev->delay));
 	else
 		queue_delayed_work(edac_workqueue, &edac_dev->work,
 				edac_dev->delay);

commit 56e61a9c5fe7b799504b125c278b56cc2c42670f
Author: Doug Thompson <dougthompson@xmission.com>
Date:   Thu Feb 7 00:14:51 2008 -0800

    drivers-edac: turn on edac device error logging
    
    ENABLE the 'logging' of CE and UE events for the EDAC_DEVICE class of error
    harvester in EDAC
    
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk
    Signed-off-by: Doug Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index f3690a697cf9..55d14d008dd6 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -155,6 +155,10 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	dev_ctl->instances = dev_inst;
 	dev_ctl->pvt_info = pvt;
 
+	/* Default logging of CEs and UEs */
+	dev_ctl->log_ce = 1;
+	dev_ctl->log_ue = 1;
+
 	/* Name of this edac device */
 	snprintf(dev_ctl->name,sizeof(dev_ctl->name),"%s",edac_device_name);
 

commit b2a4ac0c2860b27670bce99e8c9c281bf431c272
Author: Doug Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:33 2007 -0700

    drivers/edac: fix edac_device sysfs corner case bug
    
    Some simple fixes to properly reference counter values from the block
    attribute level of edac_device objects.  Properly sequencing the array pointer
    was added, resulting in correct identification of block level attributes from
    their base class functions.
    
    Added more verbose debug statement for event tracking.
    
    Also during some corner testing, found a bug in the store/show sequence
    of operations for the block attribute/controls management.
    
    An old intermediate structure for 'blocks' was still in the processing
    pipeline.  This patch removes that old structure and correctly utilizes the
    new struct edac_dev_sysfs_block_attribute for passing control from the sysfs
    to the low level store/show function of the edac driver.
    
    Now the proper kobj pointer to passed downward to the store/show
    functions.
    
    Signed-off-by: Doug Thompson <dougthompson@xmission.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 7e3723768aca..f3690a697cf9 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -83,7 +83,7 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	void *pvt;
 	int err;
 
-	debugf1("%s() instances=%d blocks=%d\n",
+	debugf4("%s() instances=%d blocks=%d\n",
 		__func__, nr_instances, nr_blocks);
 
 	/* Calculate the size of memory we need to allocate AND
@@ -158,6 +158,9 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	/* Name of this edac device */
 	snprintf(dev_ctl->name,sizeof(dev_ctl->name),"%s",edac_device_name);
 
+	debugf4("%s() edac_dev=%p next after end=%p\n",
+		__func__, dev_ctl, pvt + sz_private );
+
 	/* Initialize every Instance */
 	for (instance = 0; instance < nr_instances; instance++) {
 		inst = &dev_inst[instance];
@@ -177,8 +180,10 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 			snprintf(blk->name, sizeof(blk->name),
 				 "%s%d", edac_block_name, block+offset_value);
 
-			debugf1("%s() instance=%d block=%d name=%s\n",
-				__func__, instance, block, blk->name);
+			debugf4("%s() instance=%d inst_p=%p block=#%d "
+				"block_p=%p name='%s'\n",
+				__func__, instance, inst, block,
+				blk, blk->name);
 
 			/* if there are NO attributes OR no attribute pointer
 			 * then continue on to next block iteration
@@ -191,20 +196,32 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 			attrib_p = &dev_attrib[block*nr_instances*nr_attrib];
 			blk->block_attributes = attrib_p;
 
+			debugf4("%s() THIS BLOCK_ATTRIB=%p\n",
+				__func__, blk->block_attributes);
+
 			/* Initialize every user specified attribute in this
 			 * block with the data the caller passed in
+			 * Each block gets its own copy of pointers,
+			 * and its unique 'value'
 			 */
 			for (attr = 0; attr < nr_attrib; attr++) {
 				attrib = &attrib_p[attr];
-				attrib->attr = attrib_spec->attr;
-				attrib->show = attrib_spec->show;
-				attrib->store = attrib_spec->store;
-
-				/* up reference this block */
-				attrib->block = blk;
 
-				/* bump the attrib_spec */
-				attrib_spec++;
+				/* populate the unique per attrib
+				 * with the code pointers and info
+				 */
+				attrib->attr = attrib_spec[attr].attr;
+				attrib->show = attrib_spec[attr].show;
+				attrib->store = attrib_spec[attr].store;
+
+				attrib->block = blk;	/* up link */
+
+				debugf4("%s() alloc-attrib=%p attrib_name='%s' "
+					"attrib-spec=%p spec-name=%s\n",
+					__func__, attrib, attrib->attr.name,
+					&attrib_spec[attr],
+					attrib_spec[attr].attr.name
+					);
 			}
 		}
 	}
@@ -258,7 +275,7 @@ static struct edac_device_ctl_info *find_edac_device_by_dev(struct device *dev)
 	struct edac_device_ctl_info *edac_dev;
 	struct list_head *item;
 
-	debugf3("%s()\n", __func__);
+	debugf0("%s()\n", __func__);
 
 	list_for_each(item, &edac_device_list) {
 		edac_dev = list_entry(item, struct edac_device_ctl_info, link);
@@ -402,7 +419,6 @@ static void edac_device_workq_function(struct work_struct *work_req)
 	struct delayed_work *d_work = (struct delayed_work *)work_req;
 	struct edac_device_ctl_info *edac_dev = to_edac_device_ctl_work(d_work);
 
-	//debugf0("%s() here and running\n", __func__);
 	mutex_lock(&device_ctls_mutex);
 
 	/* Only poll controllers that are running polled and have a check */
@@ -582,7 +598,7 @@ struct edac_device_ctl_info *edac_device_del_device(struct device *dev)
 {
 	struct edac_device_ctl_info *edac_dev;
 
-	debugf0("MC: %s()\n", __func__);
+	debugf0("%s()\n", __func__);
 
 	mutex_lock(&device_ctls_mutex);
 

commit bf52fa4a26567bfbf5b1d30f84cf0226e61d26cd
Author: Doug Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:30 2007 -0700

    drivers/edac: fix workq reset deadlock
    
    Fix mutex locking deadlock on the device controller linked list.  Was calling
    a lock then a function that could call the same lock.  Moved the cancel workq
    function to outside the lock
    
    Added some short circuit logic in the workq code
    
    Added comments of description
    
    Code tidying
    
    Signed-off-by: Doug Thompson <dougthompson@xmission.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Oleg Nesterov <oleg@tv-sign.ru>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 173f4ba0f7c8..7e3723768aca 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -32,7 +32,9 @@
 #include "edac_core.h"
 #include "edac_module.h"
 
-/* lock to memory controller's control array 'edac_device_list' */
+/* lock for the list: 'edac_device_list', manipulation of this list
+ * is protected by the 'device_ctls_mutex' lock
+ */
 static DEFINE_MUTEX(device_ctls_mutex);
 static struct list_head edac_device_list = LIST_HEAD_INIT(edac_device_list);
 
@@ -386,6 +388,14 @@ EXPORT_SYMBOL_GPL(edac_device_find);
 /*
  * edac_device_workq_function
  *	performs the operation scheduled by a workq request
+ *
+ *	this workq is embedded within an edac_device_ctl_info
+ *	structure, that needs to be polled for possible error events.
+ *
+ *	This operation is to acquire the list mutex lock
+ *	(thus preventing insertation or deletion)
+ *	and then call the device's poll function IFF this device is
+ *	running polled and there is a poll function defined.
  */
 static void edac_device_workq_function(struct work_struct *work_req)
 {
@@ -403,8 +413,17 @@ static void edac_device_workq_function(struct work_struct *work_req)
 
 	mutex_unlock(&device_ctls_mutex);
 
-	/* Reschedule */
-	queue_delayed_work(edac_workqueue, &edac_dev->work, edac_dev->delay);
+	/* Reschedule the workq for the next time period to start again
+	 * if the number of msec is for 1 sec, then adjust to the next
+	 * whole one second to save timers fireing all over the period
+	 * between integral seconds
+	 */
+	if (edac_dev->poll_msec == 1000)
+		queue_delayed_work(edac_workqueue, &edac_dev->work,
+				round_jiffies(edac_dev->delay));
+	else
+		queue_delayed_work(edac_workqueue, &edac_dev->work,
+				edac_dev->delay);
 }
 
 /*
@@ -417,11 +436,26 @@ void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
 {
 	debugf0("%s()\n", __func__);
 
+	/* take the arg 'msec' and set it into the control structure
+	 * to used in the time period calculation
+	 * then calc the number of jiffies that represents
+	 */
 	edac_dev->poll_msec = msec;
-	edac_dev->delay = msecs_to_jiffies(msec);	/* Calc delay jiffies */
+	edac_dev->delay = msecs_to_jiffies(msec);
 
 	INIT_DELAYED_WORK(&edac_dev->work, edac_device_workq_function);
-	queue_delayed_work(edac_workqueue, &edac_dev->work, edac_dev->delay);
+
+	/* optimize here for the 1 second case, which will be normal value, to
+	 * fire ON the 1 second time event. This helps reduce all sorts of
+	 * timers firing on sub-second basis, while they are happy
+	 * to fire together on the 1 second exactly
+	 */
+	if (edac_dev->poll_msec == 1000)
+		queue_delayed_work(edac_workqueue, &edac_dev->work,
+				round_jiffies(edac_dev->delay));
+	else
+		queue_delayed_work(edac_workqueue, &edac_dev->work,
+				edac_dev->delay);
 }
 
 /*
@@ -441,16 +475,20 @@ void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev)
 
 /*
  * edac_device_reset_delay_period
+ *
+ *	need to stop any outstanding workq queued up at this time
+ *	because we will be resetting the sleep time.
+ *	Then restart the workq on the new delay
  */
-
 void edac_device_reset_delay_period(struct edac_device_ctl_info *edac_dev,
 					unsigned long value)
 {
-	mutex_lock(&device_ctls_mutex);
-
-	/* cancel the current workq request */
+	/* cancel the current workq request, without the mutex lock */
 	edac_device_workq_teardown(edac_dev);
 
+	/* acquire the mutex before doing the workq setup */
+	mutex_lock(&device_ctls_mutex);
+
 	/* restart the workq request, with new delay value */
 	edac_device_workq_setup(edac_dev, value);
 

commit 1c3631ff1f805cb72644fcde02b7c58950f21cd5
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:29 2007 -0700

    drivers/edac: fix edac_device sysfs completion code
    
    With feedback, this patch corrects operation of the kobject release operation
    on kobjects, attributes and controls for the edac_device.
    
    Cc: Alan Cox alan@lxorguk.ukuu.org.uk
    Signed-off-by: Doug Thompson <dougthompson@xmission.com>
    Acked-by: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 6020da68cbef..173f4ba0f7c8 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -48,6 +48,7 @@ static void edac_device_dump_device(struct edac_device_ctl_info *edac_dev)
 }
 #endif				/* CONFIG_EDAC_DEBUG */
 
+
 /*
  * edac_device_alloc_ctl_info()
  *	Allocate a new edac device control info structure
@@ -78,6 +79,7 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	unsigned count;
 	unsigned instance, block, attr;
 	void *pvt;
+	int err;
 
 	debugf1("%s() instances=%d blocks=%d\n",
 		__func__, nr_instances, nr_blocks);
@@ -208,6 +210,22 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	/* Mark this instance as merely ALLOCATED */
 	dev_ctl->op_state = OP_ALLOC;
 
+	/*
+	 * Initialize the 'root' kobj for the edac_device controller
+	 */
+	err = edac_device_register_sysfs_main_kobj(dev_ctl);
+	if (err) {
+		kfree(dev_ctl);
+		return NULL;
+	}
+
+	/* at this point, the root kobj is valid, and in order to
+	 * 'free' the object, then the function:
+	 *	edac_device_unregister_sysfs_main_kobj() must be called
+	 * which will perform kobj unregistration and the actual free
+	 * will occur during the kobject callback operation
+	 */
+
 	return dev_ctl;
 }
 EXPORT_SYMBOL_GPL(edac_device_alloc_ctl_info);
@@ -219,7 +237,7 @@ EXPORT_SYMBOL_GPL(edac_device_alloc_ctl_info);
  */
 void edac_device_free_ctl_info(struct edac_device_ctl_info *ctl_info)
 {
-	kfree(ctl_info);
+	edac_device_unregister_sysfs_main_kobj(ctl_info);
 }
 EXPORT_SYMBOL_GPL(edac_device_free_ctl_info);
 
@@ -315,22 +333,23 @@ static void complete_edac_device_list_del(struct rcu_head *head)
 
 	edac_dev = container_of(head, struct edac_device_ctl_info, rcu);
 	INIT_LIST_HEAD(&edac_dev->link);
-	complete(&edac_dev->complete);
+	complete(&edac_dev->removal_complete);
 }
 
 /*
  * del_edac_device_from_global_list
  *
- *	remove the RCU, setup for a callback call, then wait for the
- *	callback to occur
+ *	remove the RCU, setup for a callback call,
+ *	then wait for the callback to occur
  */
 static void del_edac_device_from_global_list(struct edac_device_ctl_info
 						*edac_device)
 {
 	list_del_rcu(&edac_device->link);
-	init_completion(&edac_device->complete);
+
+	init_completion(&edac_device->removal_complete);
 	call_rcu(&edac_device->rcu, complete_edac_device_list_del);
-	wait_for_completion(&edac_device->complete);
+	wait_for_completion(&edac_device->removal_complete);
 }
 
 /**
@@ -542,14 +561,14 @@ struct edac_device_ctl_info *edac_device_del_device(struct device *dev)
 	/* clear workq processing on this instance */
 	edac_device_workq_teardown(edac_dev);
 
-	/* Tear down the sysfs entries for this instance */
-	edac_device_remove_sysfs(edac_dev);
-
 	/* deregister from global list */
 	del_edac_device_from_global_list(edac_dev);
 
 	mutex_unlock(&device_ctls_mutex);
 
+	/* Tear down the sysfs entries for this instance */
+	edac_device_remove_sysfs(edac_dev);
+
 	edac_printk(KERN_INFO, EDAC_MC,
 		"Removed device %d for %s %s: DEV %s\n",
 		edac_dev->dev_idx,

commit d45e7823baf655ced91c7987fb4ba9aae990ad6d
Author: Doug Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:27 2007 -0700

    drivers/edac: fix edac_device init apis
    
    Refactoring of sysfs code necessitated the refactoring of the
    edac_device_alloc() and edac_device_add_device() apis, of moving the index
    value to the alloc() function.  This patch alters the in tree drivers to
    utilize this new api signature.
    
    Having the index value performed later created a chicken-and-the-egg issue.
    Moving it to the alloc() function allows for creating the necessary sysfs
    entries with the proper index number
    
    Cc: Alan Cox alan@lxorguk.ukuu.org.uk
    Signed-off-by: Doug Thompson <dougthompson@xmission.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 8264e3728c79..6020da68cbef 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -67,7 +67,8 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	char *edac_device_name, unsigned nr_instances,
 	char *edac_block_name, unsigned nr_blocks,
 	unsigned offset_value,		/* zero, 1, or other based offset */
-	struct edac_dev_sysfs_block_attribute *attrib_spec, unsigned nr_attrib)
+	struct edac_dev_sysfs_block_attribute *attrib_spec, unsigned nr_attrib,
+	int device_index)
 {
 	struct edac_device_ctl_info *dev_ctl;
 	struct edac_device_instance *dev_inst, *inst;
@@ -145,6 +146,7 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	pvt = sz_private ? (((char *)dev_ctl) + ((unsigned long)pvt)) : NULL;
 
 	/* Begin storing the information into the control info structure */
+	dev_ctl->dev_idx = device_index;
 	dev_ctl->nr_instances = nr_instances;
 	dev_ctl->instances = dev_inst;
 	dev_ctl->pvt_info = pvt;
@@ -441,18 +443,16 @@ void edac_device_reset_delay_period(struct edac_device_ctl_info *edac_dev,
  * edac_device global list and create sysfs entries associated with
  * edac_device structure.
  * @edac_device: pointer to the edac_device structure to be added to the list
- * @edac_idx: A unique numeric identifier to be assigned to the
  * 'edac_device' structure.
  *
  * Return:
  *	0	Success
  *	!0	Failure
  */
-int edac_device_add_device(struct edac_device_ctl_info *edac_dev, int edac_idx)
+int edac_device_add_device(struct edac_device_ctl_info *edac_dev)
 {
 	debugf0("%s()\n", __func__);
 
-	edac_dev->dev_idx = edac_idx;
 #ifdef CONFIG_EDAC_DEBUG
 	if (edac_debug_level >= 3)
 		edac_device_dump_device(edac_dev);

commit fd309a9d8e63e9176759d00630b65d772ae06e0c
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:25 2007 -0700

    drivers/edac: fix leaf sysfs attribute
    
    This patch fixes and enhances the driver level set of sysfs attributes that
    can be added to the 'block' level of an edac_device type of driver.
    
    There is a controller information structure, which contains one or more
    instances of device.  Each instance will have one or more blocks of device
    specific counters.  This patch fixes the ability to have more detailed
    attributes/controls for each of the 'blocks', providing for the addition of
    controls/attributes from the low level driver to user space via sysfs.
    
    Cc: Alan Cox alan@lxorguk.ukuu.org.uk
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index b53e8d51d9a5..8264e3728c79 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -67,12 +67,12 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	char *edac_device_name, unsigned nr_instances,
 	char *edac_block_name, unsigned nr_blocks,
 	unsigned offset_value,		/* zero, 1, or other based offset */
-	struct edac_attrib_spec *attrib_spec, unsigned nr_attribs)
+	struct edac_dev_sysfs_block_attribute *attrib_spec, unsigned nr_attrib)
 {
 	struct edac_device_ctl_info *dev_ctl;
 	struct edac_device_instance *dev_inst, *inst;
 	struct edac_device_block *dev_blk, *blk_p, *blk;
-	struct edac_attrib *dev_attrib, *attrib_p, *attrib;
+	struct edac_dev_sysfs_block_attribute *dev_attrib, *attrib_p, *attrib;
 	unsigned total_size;
 	unsigned count;
 	unsigned instance, block, attr;
@@ -81,29 +81,47 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	debugf1("%s() instances=%d blocks=%d\n",
 		__func__, nr_instances, nr_blocks);
 
-	/* Figure out the offsets of the various items from the start of an
-	 * ctl_info structure.  We want the alignment of each item
+	/* Calculate the size of memory we need to allocate AND
+	 * determine the offsets of the various item arrays
+	 * (instance,block,attrib) from the start of an  allocated structure.
+	 * We want the alignment of each item  (instance,block,attrib)
 	 * to be at least as stringent as what the compiler would
 	 * provide if we could simply hardcode everything into a single struct.
 	 */
 	dev_ctl = (struct edac_device_ctl_info *)NULL;
 
-	/* Calc the 'end' offset past the ctl_info structure */
+	/* Calc the 'end' offset past end of ONE ctl_info structure
+	 * which will become the start of the 'instance' array
+	 */
 	dev_inst = edac_align_ptr(&dev_ctl[1], sizeof(*dev_inst));
 
-	/* Calc the 'end' offset past the instance array */
+	/* Calc the 'end' offset past the instance array within the ctl_info
+	 * which will become the start of the block array
+	 */
 	dev_blk = edac_align_ptr(&dev_inst[nr_instances], sizeof(*dev_blk));
 
-	/* Calc the 'end' offset past the dev_blk array */
+	/* Calc the 'end' offset past the dev_blk array
+	 * which will become the start of the attrib array, if any.
+	 */
 	count = nr_instances * nr_blocks;
 	dev_attrib = edac_align_ptr(&dev_blk[count], sizeof(*dev_attrib));
 
-	/* Check for case of NO attributes specified */
-	if (nr_attribs > 0)
-		count *= nr_attribs;
+	/* Check for case of when an attribute array is specified */
+	if (nr_attrib > 0) {
+		/* calc how many nr_attrib we need */
+		count *= nr_attrib;
 
-	/* Calc the 'end' offset past the attributes array */
-	pvt = edac_align_ptr(&dev_attrib[count], sz_private);
+		/* Calc the 'end' offset past the attributes array */
+		pvt = edac_align_ptr(&dev_attrib[count], sz_private);
+	} else {
+		/* no attribute array specificed */
+		pvt = edac_align_ptr(dev_attrib, sz_private);
+	}
+
+	/* 'pvt' now points to where the private data area is.
+	 * At this point 'pvt' (like dev_inst,dev_blk and dev_attrib)
+	 * is baselined at ZERO
+	 */
 	total_size = ((unsigned long)pvt) + sz_private;
 
 	/* Allocate the amount of memory for the set of control structures */
@@ -111,17 +129,22 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	if (dev_ctl == NULL)
 		return NULL;
 
-	/* Adjust pointers so they point within the memory we just allocated
-	 * rather than an imaginary chunk of memory located at address 0.
+	/* Adjust pointers so they point within the actual memory we
+	 * just allocated rather than an imaginary chunk of memory
+	 * located at address 0.
+	 * 'dev_ctl' points to REAL memory, while the others are
+	 * ZERO based and thus need to be adjusted to point within
+	 * the allocated memory.
 	 */
 	dev_inst = (struct edac_device_instance *)
 		(((char *)dev_ctl) + ((unsigned long)dev_inst));
 	dev_blk = (struct edac_device_block *)
 		(((char *)dev_ctl) + ((unsigned long)dev_blk));
-	dev_attrib = (struct edac_attrib *)
+	dev_attrib = (struct edac_dev_sysfs_block_attribute *)
 		(((char *)dev_ctl) + ((unsigned long)dev_attrib));
 	pvt = sz_private ? (((char *)dev_ctl) + ((unsigned long)pvt)) : NULL;
 
+	/* Begin storing the information into the control info structure */
 	dev_ctl->nr_instances = nr_instances;
 	dev_ctl->instances = dev_inst;
 	dev_ctl->pvt_info = pvt;
@@ -145,28 +168,37 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 		for (block = 0; block < nr_blocks; block++) {
 			blk = &blk_p[block];
 			blk->instance = inst;
-			blk->nr_attribs = nr_attribs;
-			attrib_p = &dev_attrib[block * nr_attribs];
-			blk->attribs = attrib_p;
 			snprintf(blk->name, sizeof(blk->name),
 				 "%s%d", edac_block_name, block+offset_value);
 
 			debugf1("%s() instance=%d block=%d name=%s\n",
 				__func__, instance, block, blk->name);
 
-			if (attrib_spec != NULL) {
-				/* when there is an attrib_spec passed int then
-				 * Initialize every attrib of each block
-				 */
-				for (attr = 0; attr < nr_attribs; attr++) {
-					attrib = &attrib_p[attr];
-					attrib->block = blk;
-
-					/* Link each attribute to the caller's
-					 * spec entry, for name and type
-					 */
-					attrib->spec = &attrib_spec[attr];
-				}
+			/* if there are NO attributes OR no attribute pointer
+			 * then continue on to next block iteration
+			 */
+			if ((nr_attrib == 0) || (attrib_spec == NULL))
+				continue;
+
+			/* setup the attribute array for this block */
+			blk->nr_attribs = nr_attrib;
+			attrib_p = &dev_attrib[block*nr_instances*nr_attrib];
+			blk->block_attributes = attrib_p;
+
+			/* Initialize every user specified attribute in this
+			 * block with the data the caller passed in
+			 */
+			for (attr = 0; attr < nr_attrib; attr++) {
+				attrib = &attrib_p[attr];
+				attrib->attr = attrib_spec->attr;
+				attrib->show = attrib_spec->show;
+				attrib->store = attrib_spec->store;
+
+				/* up reference this block */
+				attrib->block = blk;
+
+				/* bump the attrib_spec */
+				attrib_spec++;
 			}
 		}
 	}

commit 0ca84761faeb9d49301d45b39859411c7a124690
Author: Doug Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:22 2007 -0700

    drivers/edac: fix edac_device semaphore to mutex
    
    A previous patch changed the edac_mc src file from semaphore usage to mutex
    This patch changes the edac_device src file as well, from semaphore use to
    mutex operation.
    
    Use a mutex primitive for mutex operations, as it does not require a
    semaphore
    
    Cc: Alan Cox alan@lxorguk.ukuu.org.uk
    Signed-off-by: Doug Thompson <dougthompson@xmission.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 1d2eb20304f6..b53e8d51d9a5 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -33,7 +33,7 @@
 #include "edac_module.h"
 
 /* lock to memory controller's control array 'edac_device_list' */
-static DECLARE_MUTEX(device_ctls_mutex);
+static DEFINE_MUTEX(device_ctls_mutex);
 static struct list_head edac_device_list = LIST_HEAD_INIT(edac_device_list);
 
 #ifdef CONFIG_EDAC_DEBUG
@@ -340,7 +340,7 @@ static void edac_device_workq_function(struct work_struct *work_req)
 	struct edac_device_ctl_info *edac_dev = to_edac_device_ctl_work(d_work);
 
 	//debugf0("%s() here and running\n", __func__);
-	down(&device_ctls_mutex);
+	mutex_lock(&device_ctls_mutex);
 
 	/* Only poll controllers that are running polled and have a check */
 	if ((edac_dev->op_state == OP_RUNNING_POLL) &&
@@ -348,7 +348,7 @@ static void edac_device_workq_function(struct work_struct *work_req)
 			edac_dev->edac_check(edac_dev);
 	}
 
-	up(&device_ctls_mutex);
+	mutex_unlock(&device_ctls_mutex);
 
 	/* Reschedule */
 	queue_delayed_work(edac_workqueue, &edac_dev->work, edac_dev->delay);
@@ -393,7 +393,7 @@ void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev)
 void edac_device_reset_delay_period(struct edac_device_ctl_info *edac_dev,
 					unsigned long value)
 {
-	down(&device_ctls_mutex);
+	mutex_lock(&device_ctls_mutex);
 
 	/* cancel the current workq request */
 	edac_device_workq_teardown(edac_dev);
@@ -401,7 +401,7 @@ void edac_device_reset_delay_period(struct edac_device_ctl_info *edac_dev,
 	/* restart the workq request, with new delay value */
 	edac_device_workq_setup(edac_dev, value);
 
-	up(&device_ctls_mutex);
+	mutex_unlock(&device_ctls_mutex);
 }
 
 /**
@@ -425,7 +425,7 @@ int edac_device_add_device(struct edac_device_ctl_info *edac_dev, int edac_idx)
 	if (edac_debug_level >= 3)
 		edac_device_dump_device(edac_dev);
 #endif
-	down(&device_ctls_mutex);
+	mutex_lock(&device_ctls_mutex);
 
 	if (add_edac_dev_to_global_list(edac_dev))
 		goto fail0;
@@ -463,7 +463,7 @@ int edac_device_add_device(struct edac_device_ctl_info *edac_dev, int edac_idx)
 				dev_name(edac_dev),
 				edac_op_state_to_string(edac_dev->op_state));
 
-	up(&device_ctls_mutex);
+	mutex_unlock(&device_ctls_mutex);
 	return 0;
 
 fail1:
@@ -471,7 +471,7 @@ int edac_device_add_device(struct edac_device_ctl_info *edac_dev, int edac_idx)
 	del_edac_device_from_global_list(edac_dev);
 
 fail0:
-	up(&device_ctls_mutex);
+	mutex_unlock(&device_ctls_mutex);
 	return 1;
 }
 EXPORT_SYMBOL_GPL(edac_device_add_device);
@@ -495,12 +495,12 @@ struct edac_device_ctl_info *edac_device_del_device(struct device *dev)
 
 	debugf0("MC: %s()\n", __func__);
 
-	down(&device_ctls_mutex);
+	mutex_lock(&device_ctls_mutex);
 
 	/* Find the structure on the list, if not there, then leave */
 	edac_dev = find_edac_device_by_dev(dev);
 	if (edac_dev == NULL) {
-		up(&device_ctls_mutex);
+		mutex_unlock(&device_ctls_mutex);
 		return NULL;
 	}
 
@@ -516,7 +516,7 @@ struct edac_device_ctl_info *edac_device_del_device(struct device *dev)
 	/* deregister from global list */
 	del_edac_device_from_global_list(edac_dev);
 
-	up(&device_ctls_mutex);
+	mutex_unlock(&device_ctls_mutex);
 
 	edac_printk(KERN_INFO, EDAC_MC,
 		"Removed device %d for %s %s: DEV %s\n",

commit 494d0d55bcc7ef94c744a59779327e45a27f7801
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:21 2007 -0700

    drivers/edac: mod edac_opt_state_to_string function
    
    Refactored the function edac_op_state_toString() to be edac_op_state_to_string()
    for consistent style, and its callers
    
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index d60f5df87af5..1d2eb20304f6 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -461,7 +461,7 @@ int edac_device_add_device(struct edac_device_ctl_info *edac_dev, int edac_idx)
 				edac_dev->mod_name,
 				edac_dev->ctl_name,
 				dev_name(edac_dev),
-				edac_op_state_toString(edac_dev->op_state));
+				edac_op_state_to_string(edac_dev->op_state));
 
 	up(&device_ctls_mutex);
 	return 0;

commit 7391c6dcab3094610cb99bbd559beaa282582eac
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:21 2007 -0700

    drivers/edac: mod edac_align_ptr function
    
    Refactor the edac_align_ptr() function to reduce the noise of casting the
    aligned pointer to the various types of data objects and modified its callers
    to its new signature
    
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 3ccadda3e723..d60f5df87af5 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -89,17 +89,14 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	dev_ctl = (struct edac_device_ctl_info *)NULL;
 
 	/* Calc the 'end' offset past the ctl_info structure */
-	dev_inst = (struct edac_device_instance *)
-		edac_align_ptr(&dev_ctl[1], sizeof(*dev_inst));
+	dev_inst = edac_align_ptr(&dev_ctl[1], sizeof(*dev_inst));
 
 	/* Calc the 'end' offset past the instance array */
-	dev_blk = (struct edac_device_block *)
-		edac_align_ptr(&dev_inst[nr_instances], sizeof(*dev_blk));
+	dev_blk = edac_align_ptr(&dev_inst[nr_instances], sizeof(*dev_blk));
 
 	/* Calc the 'end' offset past the dev_blk array */
 	count = nr_instances * nr_blocks;
-	dev_attrib = (struct edac_attrib *)
-		edac_align_ptr(&dev_blk[count], sizeof(*dev_attrib));
+	dev_attrib = edac_align_ptr(&dev_blk[count], sizeof(*dev_attrib));
 
 	/* Check for case of NO attributes specified */
 	if (nr_attribs > 0)

commit 52490c8d07680a7ecc3c1a70a16841455d37e96a
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:20 2007 -0700

    drivers/edac: edac_device code tidying
    
    For the file edac_device.c perform some coding style enhancements
    Add some function header comments
    Made for better readability commands
    
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 258e146efcbd..3ccadda3e723 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -20,6 +20,7 @@
 #include <linux/highmem.h>
 #include <linux/timer.h>
 #include <linux/slab.h>
+#include <linux/jiffies.h>
 #include <linux/spinlock.h>
 #include <linux/list.h>
 #include <linux/sysdev.h>
@@ -31,20 +32,10 @@
 #include "edac_core.h"
 #include "edac_module.h"
 
-/* lock to memory controller's control array */
+/* lock to memory controller's control array 'edac_device_list' */
 static DECLARE_MUTEX(device_ctls_mutex);
 static struct list_head edac_device_list = LIST_HEAD_INIT(edac_device_list);
 
-static inline void lock_device_list(void)
-{
-	down(&device_ctls_mutex);
-}
-
-static inline void unlock_device_list(void)
-{
-	up(&device_ctls_mutex);
-}
-
 #ifdef CONFIG_EDAC_DEBUG
 static void edac_device_dump_device(struct edac_device_ctl_info *edac_dev)
 {
@@ -58,20 +49,25 @@ static void edac_device_dump_device(struct edac_device_ctl_info *edac_dev)
 #endif				/* CONFIG_EDAC_DEBUG */
 
 /*
- * The alloc() and free() functions for the 'edac_device' control info
- * structure. A MC driver will allocate one of these for each edac_device
- * it is going to control/register with the EDAC CORE.
+ * edac_device_alloc_ctl_info()
+ *	Allocate a new edac device control info structure
+ *
+ *	The control structure is allocated in complete chunk
+ *	from the OS. It is in turn sub allocated to the
+ *	various objects that compose the struture
+ *
+ *	The structure has a 'nr_instance' array within itself.
+ *	Each instance represents a major component
+ *		Example:  L1 cache and L2 cache are 2 instance components
+ *
+ *	Within each instance is an array of 'nr_blocks' blockoffsets
  */
 struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	unsigned sz_private,
-	char *edac_device_name,
-	unsigned nr_instances,
-	char *edac_block_name,
-	unsigned nr_blocks,
-	unsigned offset_value,
-	struct edac_attrib_spec
-	*attrib_spec,
-	unsigned nr_attribs)
+	char *edac_device_name, unsigned nr_instances,
+	char *edac_block_name, unsigned nr_blocks,
+	unsigned offset_value,		/* zero, 1, or other based offset */
+	struct edac_attrib_spec *attrib_spec, unsigned nr_attribs)
 {
 	struct edac_device_ctl_info *dev_ctl;
 	struct edac_device_instance *dev_inst, *inst;
@@ -90,7 +86,7 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	 * to be at least as stringent as what the compiler would
 	 * provide if we could simply hardcode everything into a single struct.
 	 */
-	dev_ctl = (struct edac_device_ctl_info *)0;
+	dev_ctl = (struct edac_device_ctl_info *)NULL;
 
 	/* Calc the 'end' offset past the ctl_info structure */
 	dev_inst = (struct edac_device_instance *)
@@ -114,7 +110,8 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	total_size = ((unsigned long)pvt) + sz_private;
 
 	/* Allocate the amount of memory for the set of control structures */
-	if ((dev_ctl = kmalloc(total_size, GFP_KERNEL)) == NULL)
+	dev_ctl = kzalloc(total_size, GFP_KERNEL);
+	if (dev_ctl == NULL)
 		return NULL;
 
 	/* Adjust pointers so they point within the memory we just allocated
@@ -128,14 +125,12 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 		(((char *)dev_ctl) + ((unsigned long)dev_attrib));
 	pvt = sz_private ? (((char *)dev_ctl) + ((unsigned long)pvt)) : NULL;
 
-	memset(dev_ctl, 0, total_size);	/* clear all fields */
 	dev_ctl->nr_instances = nr_instances;
 	dev_ctl->instances = dev_inst;
 	dev_ctl->pvt_info = pvt;
 
-	/* Name of this edac device, ensure null terminated */
-	snprintf(dev_ctl->name, sizeof(dev_ctl->name), "%s", edac_device_name);
-	dev_ctl->name[sizeof(dev_ctl->name) - 1] = '\0';
+	/* Name of this edac device */
+	snprintf(dev_ctl->name,sizeof(dev_ctl->name),"%s",edac_device_name);
 
 	/* Initialize every Instance */
 	for (instance = 0; instance < nr_instances; instance++) {
@@ -148,7 +143,6 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 		/* name of this instance */
 		snprintf(inst->name, sizeof(inst->name),
 			 "%s%u", edac_device_name, instance);
-		inst->name[sizeof(inst->name) - 1] = '\0';
 
 		/* Initialize every block in each instance */
 		for (block = 0; block < nr_blocks; block++) {
@@ -159,7 +153,6 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 			blk->attribs = attrib_p;
 			snprintf(blk->name, sizeof(blk->name),
 				 "%s%d", edac_block_name, block+offset_value);
-			blk->name[sizeof(blk->name) - 1] = '\0';
 
 			debugf1("%s() instance=%d block=%d name=%s\n",
 				__func__, instance, block, blk->name);
@@ -186,7 +179,6 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 
 	return dev_ctl;
 }
-
 EXPORT_SYMBOL_GPL(edac_device_alloc_ctl_info);
 
 /*
@@ -198,12 +190,17 @@ void edac_device_free_ctl_info(struct edac_device_ctl_info *ctl_info)
 {
 	kfree(ctl_info);
 }
-
 EXPORT_SYMBOL_GPL(edac_device_free_ctl_info);
 
 /*
  * find_edac_device_by_dev
  *	scans the edac_device list for a specific 'struct device *'
+ *
+ *	lock to be held prior to call:	device_ctls_mutex
+ *
+ *	Return:
+ *		pointer to control structure managing 'dev'
+ *		NULL if not found on list
  */
 static struct edac_device_ctl_info *find_edac_device_by_dev(struct device *dev)
 {
@@ -226,6 +223,9 @@ static struct edac_device_ctl_info *find_edac_device_by_dev(struct device *dev)
  * add_edac_dev_to_global_list
  *	Before calling this function, caller must
  *	assign a unique value to edac_dev->dev_idx.
+ *
+ *	lock to be held prior to call:	device_ctls_mutex
+ *
  *	Return:
  *		0 on success
  *		1 on failure.
@@ -238,7 +238,8 @@ static int add_edac_dev_to_global_list(struct edac_device_ctl_info *edac_dev)
 	insert_before = &edac_device_list;
 
 	/* Determine if already on the list */
-	if (unlikely((rover = find_edac_device_by_dev(edac_dev->dev)) != NULL))
+	rover = find_edac_device_by_dev(edac_dev->dev);
+	if (unlikely(rover != NULL))
 		goto fail0;
 
 	/* Insert in ascending order by 'dev_idx', so find position */
@@ -274,6 +275,8 @@ static int add_edac_dev_to_global_list(struct edac_device_ctl_info *edac_dev)
 
 /*
  * complete_edac_device_list_del
+ *
+ *	callback function when reference count is zero
  */
 static void complete_edac_device_list_del(struct rcu_head *head)
 {
@@ -286,6 +289,9 @@ static void complete_edac_device_list_del(struct rcu_head *head)
 
 /*
  * del_edac_device_from_global_list
+ *
+ *	remove the RCU, setup for a callback call, then wait for the
+ *	callback to occur
  */
 static void del_edac_device_from_global_list(struct edac_device_ctl_info
 						*edac_device)
@@ -325,8 +331,7 @@ struct edac_device_ctl_info *edac_device_find(int idx)
 
 	return NULL;
 }
-
-EXPORT_SYMBOL(edac_device_find);
+EXPORT_SYMBOL_GPL(edac_device_find);
 
 /*
  * edac_device_workq_function
@@ -338,7 +343,7 @@ static void edac_device_workq_function(struct work_struct *work_req)
 	struct edac_device_ctl_info *edac_dev = to_edac_device_ctl_work(d_work);
 
 	//debugf0("%s() here and running\n", __func__);
-	lock_device_list();
+	down(&device_ctls_mutex);
 
 	/* Only poll controllers that are running polled and have a check */
 	if ((edac_dev->op_state == OP_RUNNING_POLL) &&
@@ -346,7 +351,7 @@ static void edac_device_workq_function(struct work_struct *work_req)
 			edac_dev->edac_check(edac_dev);
 	}
 
-	unlock_device_list();
+	up(&device_ctls_mutex);
 
 	/* Reschedule */
 	queue_delayed_work(edac_workqueue, &edac_dev->work, edac_dev->delay);
@@ -363,7 +368,7 @@ void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
 	debugf0("%s()\n", __func__);
 
 	edac_dev->poll_msec = msec;
-	edac_calc_delay(edac_dev);	/* Calc delay jiffies */
+	edac_dev->delay = msecs_to_jiffies(msec);	/* Calc delay jiffies */
 
 	INIT_DELAYED_WORK(&edac_dev->work, edac_device_workq_function);
 	queue_delayed_work(edac_workqueue, &edac_dev->work, edac_dev->delay);
@@ -391,7 +396,7 @@ void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev)
 void edac_device_reset_delay_period(struct edac_device_ctl_info *edac_dev,
 					unsigned long value)
 {
-	lock_device_list();
+	down(&device_ctls_mutex);
 
 	/* cancel the current workq request */
 	edac_device_workq_teardown(edac_dev);
@@ -399,7 +404,7 @@ void edac_device_reset_delay_period(struct edac_device_ctl_info *edac_dev,
 	/* restart the workq request, with new delay value */
 	edac_device_workq_setup(edac_dev, value);
 
-	unlock_device_list();
+	up(&device_ctls_mutex);
 }
 
 /**
@@ -423,7 +428,7 @@ int edac_device_add_device(struct edac_device_ctl_info *edac_dev, int edac_idx)
 	if (edac_debug_level >= 3)
 		edac_device_dump_device(edac_dev);
 #endif
-	lock_device_list();
+	down(&device_ctls_mutex);
 
 	if (add_edac_dev_to_global_list(edac_dev))
 		goto fail0;
@@ -461,7 +466,7 @@ int edac_device_add_device(struct edac_device_ctl_info *edac_dev, int edac_idx)
 				dev_name(edac_dev),
 				edac_op_state_toString(edac_dev->op_state));
 
-	unlock_device_list();
+	up(&device_ctls_mutex);
 	return 0;
 
 fail1:
@@ -469,10 +474,9 @@ int edac_device_add_device(struct edac_device_ctl_info *edac_dev, int edac_idx)
 	del_edac_device_from_global_list(edac_dev);
 
 fail0:
-	unlock_device_list();
+	up(&device_ctls_mutex);
 	return 1;
 }
-
 EXPORT_SYMBOL_GPL(edac_device_add_device);
 
 /**
@@ -494,10 +498,12 @@ struct edac_device_ctl_info *edac_device_del_device(struct device *dev)
 
 	debugf0("MC: %s()\n", __func__);
 
-	lock_device_list();
+	down(&device_ctls_mutex);
 
-	if ((edac_dev = find_edac_device_by_dev(dev)) == NULL) {
-		unlock_device_list();
+	/* Find the structure on the list, if not there, then leave */
+	edac_dev = find_edac_device_by_dev(dev);
+	if (edac_dev == NULL) {
+		up(&device_ctls_mutex);
 		return NULL;
 	}
 
@@ -513,7 +519,7 @@ struct edac_device_ctl_info *edac_device_del_device(struct device *dev)
 	/* deregister from global list */
 	del_edac_device_from_global_list(edac_dev);
 
-	unlock_device_list();
+	up(&device_ctls_mutex);
 
 	edac_printk(KERN_INFO, EDAC_MC,
 		"Removed device %d for %s %s: DEV %s\n",
@@ -522,7 +528,6 @@ struct edac_device_ctl_info *edac_device_del_device(struct device *dev)
 
 	return edac_dev;
 }
-
 EXPORT_SYMBOL_GPL(edac_device_del_device);
 
 static inline int edac_device_get_log_ce(struct edac_device_ctl_info *edac_dev)
@@ -585,7 +590,6 @@ void edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,
 				edac_dev->ctl_name, instance->name,
 				block ? block->name : "N/A", msg);
 }
-
 EXPORT_SYMBOL_GPL(edac_device_handle_ce);
 
 /*
@@ -637,5 +641,4 @@ void edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,
 			edac_dev->ctl_name, instance->name,
 			block ? block->name : "N/A", msg);
 }
-
 EXPORT_SYMBOL_GPL(edac_device_handle_ue);

commit 052dfb45ccb5ea354a426b52556bcfee75b9d2f5
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:13 2007 -0700

    drivers/edac: cleanup spaces-gotos after Lindent messup
    
    This patch fixes some remnant spaces inserted by the use of Lindent.
    Seems Lindent adds some spaces when it shoulded. These have been fixed.
    In addition, goto targets have issues, these have been fixed
    in this patch.
    
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index dfdfc4bbeba8..258e146efcbd 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -94,16 +94,16 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 
 	/* Calc the 'end' offset past the ctl_info structure */
 	dev_inst = (struct edac_device_instance *)
-	    edac_align_ptr(&dev_ctl[1], sizeof(*dev_inst));
+		edac_align_ptr(&dev_ctl[1], sizeof(*dev_inst));
 
 	/* Calc the 'end' offset past the instance array */
 	dev_blk = (struct edac_device_block *)
-	    edac_align_ptr(&dev_inst[nr_instances], sizeof(*dev_blk));
+		edac_align_ptr(&dev_inst[nr_instances], sizeof(*dev_blk));
 
 	/* Calc the 'end' offset past the dev_blk array */
 	count = nr_instances * nr_blocks;
 	dev_attrib = (struct edac_attrib *)
-	    edac_align_ptr(&dev_blk[count], sizeof(*dev_attrib));
+		edac_align_ptr(&dev_blk[count], sizeof(*dev_attrib));
 
 	/* Check for case of NO attributes specified */
 	if (nr_attribs > 0)
@@ -121,11 +121,11 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	 * rather than an imaginary chunk of memory located at address 0.
 	 */
 	dev_inst = (struct edac_device_instance *)
-	    (((char *)dev_ctl) + ((unsigned long)dev_inst));
+		(((char *)dev_ctl) + ((unsigned long)dev_inst));
 	dev_blk = (struct edac_device_block *)
-	    (((char *)dev_ctl) + ((unsigned long)dev_blk));
+		(((char *)dev_ctl) + ((unsigned long)dev_blk));
 	dev_attrib = (struct edac_attrib *)
-	    (((char *)dev_ctl) + ((unsigned long)dev_attrib));
+		(((char *)dev_ctl) + ((unsigned long)dev_attrib));
 	pvt = sz_private ? (((char *)dev_ctl) + ((unsigned long)pvt)) : NULL;
 
 	memset(dev_ctl, 0, total_size);	/* clear all fields */
@@ -257,18 +257,18 @@ static int add_edac_dev_to_global_list(struct edac_device_ctl_info *edac_dev)
 	list_add_tail_rcu(&edac_dev->link, insert_before);
 	return 0;
 
-      fail0:
+fail0:
 	edac_printk(KERN_WARNING, EDAC_MC,
-		    "%s (%s) %s %s already assigned %d\n",
-		    rover->dev->bus_id, dev_name(rover),
-		    rover->mod_name, rover->ctl_name, rover->dev_idx);
+			"%s (%s) %s %s already assigned %d\n",
+			rover->dev->bus_id, dev_name(rover),
+			rover->mod_name, rover->ctl_name, rover->dev_idx);
 	return 1;
 
-      fail1:
+fail1:
 	edac_printk(KERN_WARNING, EDAC_MC,
-		    "bug in low-level driver: attempt to assign\n"
-		    "    duplicate dev_idx %d in %s()\n", rover->dev_idx,
-		    __func__);
+			"bug in low-level driver: attempt to assign\n"
+			"    duplicate dev_idx %d in %s()\n", rover->dev_idx,
+			__func__);
 	return 1;
 }
 
@@ -288,7 +288,7 @@ static void complete_edac_device_list_del(struct rcu_head *head)
  * del_edac_device_from_global_list
  */
 static void del_edac_device_from_global_list(struct edac_device_ctl_info
-					     *edac_device)
+						*edac_device)
 {
 	list_del_rcu(&edac_device->link);
 	init_completion(&edac_device->complete);
@@ -342,8 +342,8 @@ static void edac_device_workq_function(struct work_struct *work_req)
 
 	/* Only poll controllers that are running polled and have a check */
 	if ((edac_dev->op_state == OP_RUNNING_POLL) &&
-	    (edac_dev->edac_check != NULL)) {
-		edac_dev->edac_check(edac_dev);
+		(edac_dev->edac_check != NULL)) {
+			edac_dev->edac_check(edac_dev);
 	}
 
 	unlock_device_list();
@@ -358,7 +358,7 @@ static void edac_device_workq_function(struct work_struct *work_req)
  *	passing in the new delay period in msec
  */
 void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
-			     unsigned msec)
+				unsigned msec)
 {
 	debugf0("%s()\n", __func__);
 
@@ -389,7 +389,7 @@ void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev)
  */
 
 void edac_device_reset_delay_period(struct edac_device_ctl_info *edac_dev,
-				    unsigned long value)
+					unsigned long value)
 {
 	lock_device_list();
 
@@ -434,7 +434,7 @@ int edac_device_add_device(struct edac_device_ctl_info *edac_dev, int edac_idx)
 	/* create this instance's sysfs entries */
 	if (edac_device_create_sysfs(edac_dev)) {
 		edac_device_printk(edac_dev, KERN_WARNING,
-				   "failed to create sysfs device\n");
+					"failed to create sysfs device\n");
 		goto fail1;
 	}
 
@@ -454,21 +454,21 @@ int edac_device_add_device(struct edac_device_ctl_info *edac_dev, int edac_idx)
 
 	/* Report action taken */
 	edac_device_printk(edac_dev, KERN_INFO,
-			   "Giving out device to module '%s' controller '%s': DEV '%s' (%s)\n",
-			   edac_dev->mod_name,
-			   edac_dev->ctl_name,
-			   dev_name(edac_dev),
-			   edac_op_state_toString(edac_dev->op_state)
-	    );
+				"Giving out device to module '%s' controller "
+				"'%s': DEV '%s' (%s)\n",
+				edac_dev->mod_name,
+				edac_dev->ctl_name,
+				dev_name(edac_dev),
+				edac_op_state_toString(edac_dev->op_state));
 
 	unlock_device_list();
 	return 0;
 
-      fail1:
+fail1:
 	/* Some error, so remove the entry from the lsit */
 	del_edac_device_from_global_list(edac_dev);
 
-      fail0:
+fail0:
 	unlock_device_list();
 	return 1;
 }
@@ -516,9 +516,9 @@ struct edac_device_ctl_info *edac_device_del_device(struct device *dev)
 	unlock_device_list();
 
 	edac_printk(KERN_INFO, EDAC_MC,
-		    "Removed device %d for %s %s: DEV %s\n",
-		    edac_dev->dev_idx,
-		    edac_dev->mod_name, edac_dev->ctl_name, dev_name(edac_dev));
+		"Removed device %d for %s %s: DEV %s\n",
+		edac_dev->dev_idx,
+		edac_dev->mod_name, edac_dev->ctl_name, dev_name(edac_dev));
 
 	return edac_dev;
 }
@@ -536,7 +536,7 @@ static inline int edac_device_get_log_ue(struct edac_device_ctl_info *edac_dev)
 }
 
 static inline int edac_device_get_panic_on_ue(struct edac_device_ctl_info
-					      *edac_dev)
+					*edac_dev)
 {
 	return edac_dev->panic_on_ue;
 }
@@ -546,16 +546,16 @@ static inline int edac_device_get_panic_on_ue(struct edac_device_ctl_info
  *	perform a common output and handling of an 'edac_dev' CE event
  */
 void edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,
-			   int inst_nr, int block_nr, const char *msg)
+			int inst_nr, int block_nr, const char *msg)
 {
 	struct edac_device_instance *instance;
 	struct edac_device_block *block = NULL;
 
 	if ((inst_nr >= edac_dev->nr_instances) || (inst_nr < 0)) {
 		edac_device_printk(edac_dev, KERN_ERR,
-				   "INTERNAL ERROR: 'instance' out of range "
-				   "(%d >= %d)\n", inst_nr,
-				   edac_dev->nr_instances);
+				"INTERNAL ERROR: 'instance' out of range "
+				"(%d >= %d)\n", inst_nr,
+				edac_dev->nr_instances);
 		return;
 	}
 
@@ -563,9 +563,10 @@ void edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,
 
 	if ((block_nr >= instance->nr_blocks) || (block_nr < 0)) {
 		edac_device_printk(edac_dev, KERN_ERR,
-				   "INTERNAL ERROR: instance %d 'block' out of range "
-				   "(%d >= %d)\n", inst_nr, block_nr,
-				   instance->nr_blocks);
+				"INTERNAL ERROR: instance %d 'block' "
+				"out of range (%d >= %d)\n",
+				inst_nr, block_nr,
+				instance->nr_blocks);
 		return;
 	}
 
@@ -580,9 +581,9 @@ void edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,
 
 	if (edac_device_get_log_ce(edac_dev))
 		edac_device_printk(edac_dev, KERN_WARNING,
-				   "CE: %s instance: %s block: %s '%s'\n",
-				   edac_dev->ctl_name, instance->name,
-				   block ? block->name : "N/A", msg);
+				"CE: %s instance: %s block: %s '%s'\n",
+				edac_dev->ctl_name, instance->name,
+				block ? block->name : "N/A", msg);
 }
 
 EXPORT_SYMBOL_GPL(edac_device_handle_ce);
@@ -592,16 +593,16 @@ EXPORT_SYMBOL_GPL(edac_device_handle_ce);
  *	perform a common output and handling of an 'edac_dev' UE event
  */
 void edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,
-			   int inst_nr, int block_nr, const char *msg)
+			int inst_nr, int block_nr, const char *msg)
 {
 	struct edac_device_instance *instance;
 	struct edac_device_block *block = NULL;
 
 	if ((inst_nr >= edac_dev->nr_instances) || (inst_nr < 0)) {
 		edac_device_printk(edac_dev, KERN_ERR,
-				   "INTERNAL ERROR: 'instance' out of range "
-				   "(%d >= %d)\n", inst_nr,
-				   edac_dev->nr_instances);
+				"INTERNAL ERROR: 'instance' out of range "
+				"(%d >= %d)\n", inst_nr,
+				edac_dev->nr_instances);
 		return;
 	}
 
@@ -609,9 +610,10 @@ void edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,
 
 	if ((block_nr >= instance->nr_blocks) || (block_nr < 0)) {
 		edac_device_printk(edac_dev, KERN_ERR,
-				   "INTERNAL ERROR: instance %d 'block' out of range "
-				   "(%d >= %d)\n", inst_nr, block_nr,
-				   instance->nr_blocks);
+				"INTERNAL ERROR: instance %d 'block' "
+				"out of range (%d >= %d)\n",
+				inst_nr, block_nr,
+				instance->nr_blocks);
 		return;
 	}
 
@@ -626,14 +628,14 @@ void edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,
 
 	if (edac_device_get_log_ue(edac_dev))
 		edac_device_printk(edac_dev, KERN_EMERG,
-				   "UE: %s instance: %s block: %s '%s'\n",
-				   edac_dev->ctl_name, instance->name,
-				   block ? block->name : "N/A", msg);
+				"UE: %s instance: %s block: %s '%s'\n",
+				edac_dev->ctl_name, instance->name,
+				block ? block->name : "N/A", msg);
 
 	if (edac_device_get_panic_on_ue(edac_dev))
 		panic("EDAC %s: UE instance: %s block %s '%s'\n",
-		      edac_dev->ctl_name, instance->name,
-		      block ? block->name : "N/A", msg);
+			edac_dev->ctl_name, instance->name,
+			block ? block->name : "N/A", msg);
 }
 
 EXPORT_SYMBOL_GPL(edac_device_handle_ue);

commit d391a7b8147d12b0e5141fb65829856fb0c289dc
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:11 2007 -0700

    drivers/edac: device output clenaup
    
    The error handling output strings needed to be refactored for better
    displaying of the error informaton.
    
    Also needed to added offset_value for output as well
    
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 26807af2c5e7..dfdfc4bbeba8 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -158,7 +158,7 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 			attrib_p = &dev_attrib[block * nr_attribs];
 			blk->attribs = attrib_p;
 			snprintf(blk->name, sizeof(blk->name),
-				 "%s%d", edac_block_name, block + 1);
+				 "%s%d", edac_block_name, block+offset_value);
 			blk->name[sizeof(blk->name) - 1] = '\0';
 
 			debugf1("%s() instance=%d block=%d name=%s\n",
@@ -580,7 +580,7 @@ void edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,
 
 	if (edac_device_get_log_ce(edac_dev))
 		edac_device_printk(edac_dev, KERN_WARNING,
-				   "CE ctl: %s, instance: %s, block: %s: %s\n",
+				   "CE: %s instance: %s block: %s '%s'\n",
 				   edac_dev->ctl_name, instance->name,
 				   block ? block->name : "N/A", msg);
 }
@@ -626,12 +626,12 @@ void edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,
 
 	if (edac_device_get_log_ue(edac_dev))
 		edac_device_printk(edac_dev, KERN_EMERG,
-				   "UE ctl: %s, instance: %s, block: %s: %s\n",
+				   "UE: %s instance: %s block: %s '%s'\n",
 				   edac_dev->ctl_name, instance->name,
 				   block ? block->name : "N/A", msg);
 
 	if (edac_device_get_panic_on_ue(edac_dev))
-		panic("EDAC %s: UE instance: %s, block %s: %s\n",
+		panic("EDAC %s: UE instance: %s block %s '%s'\n",
 		      edac_dev->ctl_name, instance->name,
 		      block ? block->name : "N/A", msg);
 }

commit 86aa8cb7bc47fe786df073246055d69d98e6330a
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:01 2007 -0700

    drivers/edac: cleanup workq ifdefs
    
    The origin of this code comes from patches at sourceforge, that
    allow EDAC to be updated to various kernels. With kernel version 2.6.20 a
    new workq system was installed, thus the patches needed to be modified
    based on the kernel version. For submitting to the latest kernel.org
    those #ifdefs are removed
    
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 4ce978b72d34..26807af2c5e7 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -332,17 +332,10 @@ EXPORT_SYMBOL(edac_device_find);
  * edac_device_workq_function
  *	performs the operation scheduled by a workq request
  */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 static void edac_device_workq_function(struct work_struct *work_req)
 {
 	struct delayed_work *d_work = (struct delayed_work *)work_req;
 	struct edac_device_ctl_info *edac_dev = to_edac_device_ctl_work(d_work);
-#else
-static void edac_device_workq_function(void *ptr)
-{
-	struct edac_device_ctl_info *edac_dev =
-	    (struct edac_device_ctl_info *)ptr;
-#endif
 
 	//debugf0("%s() here and running\n", __func__);
 	lock_device_list();
@@ -372,11 +365,7 @@ void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
 	edac_dev->poll_msec = msec;
 	edac_calc_delay(edac_dev);	/* Calc delay jiffies */
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 	INIT_DELAYED_WORK(&edac_dev->work, edac_device_workq_function);
-#else
-	INIT_WORK(&edac_dev->work, edac_device_workq_function, edac_dev);
-#endif
 	queue_delayed_work(edac_workqueue, &edac_dev->work, edac_dev->delay);
 }
 

commit 079708b9173595bf74b31b14c36e946359ae6c7e
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:49:58 2007 -0700

    drivers/edac: core Lindent cleanup
    
    Run the EDAC CORE files through Lindent for cleanup
    
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Dave Jiang <djiang@mvista.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 3db8effa1fd0..4ce978b72d34 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -35,7 +35,6 @@
 static DECLARE_MUTEX(device_ctls_mutex);
 static struct list_head edac_device_list = LIST_HEAD_INIT(edac_device_list);
 
-
 static inline void lock_device_list(void)
 {
 	down(&device_ctls_mutex);
@@ -46,18 +45,17 @@ static inline void unlock_device_list(void)
 	up(&device_ctls_mutex);
 }
 
-
 #ifdef CONFIG_EDAC_DEBUG
 static void edac_device_dump_device(struct edac_device_ctl_info *edac_dev)
 {
-	debugf3("\tedac_dev = %p dev_idx=%d \n", edac_dev,edac_dev->dev_idx);
+	debugf3("\tedac_dev = %p dev_idx=%d \n", edac_dev, edac_dev->dev_idx);
 	debugf4("\tedac_dev->edac_check = %p\n", edac_dev->edac_check);
 	debugf3("\tdev = %p\n", edac_dev->dev);
 	debugf3("\tmod_name:ctl_name = %s:%s\n",
 		edac_dev->mod_name, edac_dev->ctl_name);
 	debugf3("\tpvt_info = %p\n\n", edac_dev->pvt_info);
 }
-#endif  /* CONFIG_EDAC_DEBUG */
+#endif				/* CONFIG_EDAC_DEBUG */
 
 /*
  * The alloc() and free() functions for the 'edac_device' control info
@@ -71,7 +69,8 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	char *edac_block_name,
 	unsigned nr_blocks,
 	unsigned offset_value,
-	struct edac_attrib_spec *attrib_spec,
+	struct edac_attrib_spec
+	*attrib_spec,
 	unsigned nr_attribs)
 {
 	struct edac_device_ctl_info *dev_ctl;
@@ -84,35 +83,35 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	void *pvt;
 
 	debugf1("%s() instances=%d blocks=%d\n",
-		__func__,nr_instances,nr_blocks);
+		__func__, nr_instances, nr_blocks);
 
 	/* Figure out the offsets of the various items from the start of an
 	 * ctl_info structure.  We want the alignment of each item
 	 * to be at least as stringent as what the compiler would
 	 * provide if we could simply hardcode everything into a single struct.
 	 */
-	dev_ctl = (struct edac_device_ctl_info *) 0;
+	dev_ctl = (struct edac_device_ctl_info *)0;
 
 	/* Calc the 'end' offset past the ctl_info structure */
 	dev_inst = (struct edac_device_instance *)
-			edac_align_ptr(&dev_ctl[1],sizeof(*dev_inst));
+	    edac_align_ptr(&dev_ctl[1], sizeof(*dev_inst));
 
 	/* Calc the 'end' offset past the instance array */
 	dev_blk = (struct edac_device_block *)
-			edac_align_ptr(&dev_inst[nr_instances],sizeof(*dev_blk));
+	    edac_align_ptr(&dev_inst[nr_instances], sizeof(*dev_blk));
 
 	/* Calc the 'end' offset past the dev_blk array */
 	count = nr_instances * nr_blocks;
 	dev_attrib = (struct edac_attrib *)
-			edac_align_ptr(&dev_blk[count],sizeof(*dev_attrib));
+	    edac_align_ptr(&dev_blk[count], sizeof(*dev_attrib));
 
 	/* Check for case of NO attributes specified */
 	if (nr_attribs > 0)
 		count *= nr_attribs;
 
 	/* Calc the 'end' offset past the attributes array */
-	pvt = edac_align_ptr(&dev_attrib[count],sz_private);
-	total_size = ((unsigned long) pvt) + sz_private;
+	pvt = edac_align_ptr(&dev_attrib[count], sz_private);
+	total_size = ((unsigned long)pvt) + sz_private;
 
 	/* Allocate the amount of memory for the set of control structures */
 	if ((dev_ctl = kmalloc(total_size, GFP_KERNEL)) == NULL)
@@ -122,22 +121,21 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 	 * rather than an imaginary chunk of memory located at address 0.
 	 */
 	dev_inst = (struct edac_device_instance *)
-			(((char *) dev_ctl) + ((unsigned long) dev_inst));
+	    (((char *)dev_ctl) + ((unsigned long)dev_inst));
 	dev_blk = (struct edac_device_block *)
-			(((char *) dev_ctl) + ((unsigned long) dev_blk));
+	    (((char *)dev_ctl) + ((unsigned long)dev_blk));
 	dev_attrib = (struct edac_attrib *)
-			(((char *) dev_ctl) + ((unsigned long) dev_attrib));
-	pvt = sz_private ?
-			(((char *) dev_ctl) + ((unsigned long) pvt)) : NULL;
+	    (((char *)dev_ctl) + ((unsigned long)dev_attrib));
+	pvt = sz_private ? (((char *)dev_ctl) + ((unsigned long)pvt)) : NULL;
 
-	memset(dev_ctl, 0, total_size);		/* clear all fields */
+	memset(dev_ctl, 0, total_size);	/* clear all fields */
 	dev_ctl->nr_instances = nr_instances;
 	dev_ctl->instances = dev_inst;
 	dev_ctl->pvt_info = pvt;
 
 	/* Name of this edac device, ensure null terminated */
-	snprintf(dev_ctl->name,sizeof(dev_ctl->name),"%s", edac_device_name);
-	dev_ctl->name[sizeof(dev_ctl->name)-1] = '\0';
+	snprintf(dev_ctl->name, sizeof(dev_ctl->name), "%s", edac_device_name);
+	dev_ctl->name[sizeof(dev_ctl->name) - 1] = '\0';
 
 	/* Initialize every Instance */
 	for (instance = 0; instance < nr_instances; instance++) {
@@ -149,24 +147,22 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 
 		/* name of this instance */
 		snprintf(inst->name, sizeof(inst->name),
-			"%s%u", edac_device_name, instance);
-		inst->name[sizeof(inst->name)-1] = '\0';
+			 "%s%u", edac_device_name, instance);
+		inst->name[sizeof(inst->name) - 1] = '\0';
 
 		/* Initialize every block in each instance */
-		for (		block = 0;
-				block < nr_blocks;
-				block++) {
+		for (block = 0; block < nr_blocks; block++) {
 			blk = &blk_p[block];
 			blk->instance = inst;
 			blk->nr_attribs = nr_attribs;
 			attrib_p = &dev_attrib[block * nr_attribs];
 			blk->attribs = attrib_p;
 			snprintf(blk->name, sizeof(blk->name),
-				"%s%d", edac_block_name,block+1);
-			blk->name[sizeof(blk->name)-1] = '\0';
+				 "%s%d", edac_block_name, block + 1);
+			blk->name[sizeof(blk->name) - 1] = '\0';
 
 			debugf1("%s() instance=%d block=%d name=%s\n",
-				__func__, instance,block,blk->name);
+				__func__, instance, block, blk->name);
 
 			if (attrib_spec != NULL) {
 				/* when there is an attrib_spec passed int then
@@ -178,7 +174,7 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 
 					/* Link each attribute to the caller's
 					 * spec entry, for name and type
-				 	 */
+					 */
 					attrib->spec = &attrib_spec[attr];
 				}
 			}
@@ -190,6 +186,7 @@ struct edac_device_ctl_info *edac_device_alloc_ctl_info(
 
 	return dev_ctl;
 }
+
 EXPORT_SYMBOL_GPL(edac_device_alloc_ctl_info);
 
 /*
@@ -197,19 +194,18 @@ EXPORT_SYMBOL_GPL(edac_device_alloc_ctl_info);
  *	frees the memory allocated by the edac_device_alloc_ctl_info()
  *	function
  */
-void edac_device_free_ctl_info( struct edac_device_ctl_info *ctl_info) {
+void edac_device_free_ctl_info(struct edac_device_ctl_info *ctl_info)
+{
 	kfree(ctl_info);
 }
-EXPORT_SYMBOL_GPL(edac_device_free_ctl_info);
-
 
+EXPORT_SYMBOL_GPL(edac_device_free_ctl_info);
 
 /*
  * find_edac_device_by_dev
  *	scans the edac_device list for a specific 'struct device *'
  */
-static struct edac_device_ctl_info *
-find_edac_device_by_dev(struct device *dev)
+static struct edac_device_ctl_info *find_edac_device_by_dev(struct device *dev)
 {
 	struct edac_device_ctl_info *edac_dev;
 	struct list_head *item;
@@ -234,7 +230,7 @@ find_edac_device_by_dev(struct device *dev)
  *		0 on success
  *		1 on failure.
  */
-static int add_edac_dev_to_global_list (struct edac_device_ctl_info *edac_dev)
+static int add_edac_dev_to_global_list(struct edac_device_ctl_info *edac_dev)
 {
 	struct list_head *item, *insert_before;
 	struct edac_device_ctl_info *rover;
@@ -261,17 +257,18 @@ static int add_edac_dev_to_global_list (struct edac_device_ctl_info *edac_dev)
 	list_add_tail_rcu(&edac_dev->link, insert_before);
 	return 0;
 
-fail0:
+      fail0:
 	edac_printk(KERN_WARNING, EDAC_MC,
-		"%s (%s) %s %s already assigned %d\n",
-		rover->dev->bus_id, dev_name(rover),
-		rover->mod_name, rover->ctl_name, rover->dev_idx);
+		    "%s (%s) %s %s already assigned %d\n",
+		    rover->dev->bus_id, dev_name(rover),
+		    rover->mod_name, rover->ctl_name, rover->dev_idx);
 	return 1;
 
-fail1:
+      fail1:
 	edac_printk(KERN_WARNING, EDAC_MC,
-		"bug in low-level driver: attempt to assign\n"
-		"    duplicate dev_idx %d in %s()\n", rover->dev_idx, __func__);
+		    "bug in low-level driver: attempt to assign\n"
+		    "    duplicate dev_idx %d in %s()\n", rover->dev_idx,
+		    __func__);
 	return 1;
 }
 
@@ -290,8 +287,8 @@ static void complete_edac_device_list_del(struct rcu_head *head)
 /*
  * del_edac_device_from_global_list
  */
-static void del_edac_device_from_global_list(
-			struct edac_device_ctl_info *edac_device)
+static void del_edac_device_from_global_list(struct edac_device_ctl_info
+					     *edac_device)
 {
 	list_del_rcu(&edac_device->link);
 	init_completion(&edac_device->complete);
@@ -308,7 +305,7 @@ static void del_edac_device_from_global_list(
  *
  * Caller must hold device_ctls_mutex.
  */
-struct edac_device_ctl_info * edac_device_find(int idx)
+struct edac_device_ctl_info *edac_device_find(int idx)
 {
 	struct list_head *item;
 	struct edac_device_ctl_info *edac_dev;
@@ -328,8 +325,8 @@ struct edac_device_ctl_info * edac_device_find(int idx)
 
 	return NULL;
 }
-EXPORT_SYMBOL(edac_device_find);
 
+EXPORT_SYMBOL(edac_device_find);
 
 /*
  * edac_device_workq_function
@@ -338,14 +335,13 @@ EXPORT_SYMBOL(edac_device_find);
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
 static void edac_device_workq_function(struct work_struct *work_req)
 {
-	struct delayed_work *d_work = (struct delayed_work*) work_req;
-	struct edac_device_ctl_info *edac_dev =
-		to_edac_device_ctl_work(d_work);
+	struct delayed_work *d_work = (struct delayed_work *)work_req;
+	struct edac_device_ctl_info *edac_dev = to_edac_device_ctl_work(d_work);
 #else
 static void edac_device_workq_function(void *ptr)
 {
 	struct edac_device_ctl_info *edac_dev =
-		(struct edac_device_ctl_info *) ptr;
+	    (struct edac_device_ctl_info *)ptr;
 #endif
 
 	//debugf0("%s() here and running\n", __func__);
@@ -353,14 +349,14 @@ static void edac_device_workq_function(void *ptr)
 
 	/* Only poll controllers that are running polled and have a check */
 	if ((edac_dev->op_state == OP_RUNNING_POLL) &&
-					(edac_dev->edac_check != NULL)) {
+	    (edac_dev->edac_check != NULL)) {
 		edac_dev->edac_check(edac_dev);
 	}
 
 	unlock_device_list();
 
 	/* Reschedule */
-	queue_delayed_work(edac_workqueue,&edac_dev->work, edac_dev->delay);
+	queue_delayed_work(edac_workqueue, &edac_dev->work, edac_dev->delay);
 }
 
 /*
@@ -369,7 +365,7 @@ static void edac_device_workq_function(void *ptr)
  *	passing in the new delay period in msec
  */
 void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
-		unsigned msec)
+			     unsigned msec)
 {
 	debugf0("%s()\n", __func__);
 
@@ -403,9 +399,8 @@ void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev)
  * edac_device_reset_delay_period
  */
 
-void edac_device_reset_delay_period(
-		struct edac_device_ctl_info *edac_dev,
-		unsigned long value)
+void edac_device_reset_delay_period(struct edac_device_ctl_info *edac_dev,
+				    unsigned long value)
 {
 	lock_device_list();
 
@@ -450,7 +445,7 @@ int edac_device_add_device(struct edac_device_ctl_info *edac_dev, int edac_idx)
 	/* create this instance's sysfs entries */
 	if (edac_device_create_sysfs(edac_dev)) {
 		edac_device_printk(edac_dev, KERN_WARNING,
-			"failed to create sysfs device\n");
+				   "failed to create sysfs device\n");
 		goto fail1;
 	}
 
@@ -468,27 +463,27 @@ int edac_device_add_device(struct edac_device_ctl_info *edac_dev, int edac_idx)
 		edac_dev->op_state = OP_RUNNING_INTERRUPT;
 	}
 
-
 	/* Report action taken */
 	edac_device_printk(edac_dev, KERN_INFO,
-		"Giving out device to module '%s' controller '%s': DEV '%s' (%s)\n",
-		edac_dev->mod_name,
-		edac_dev->ctl_name,
-		dev_name(edac_dev),
-		edac_op_state_toString(edac_dev->op_state)
-		);
+			   "Giving out device to module '%s' controller '%s': DEV '%s' (%s)\n",
+			   edac_dev->mod_name,
+			   edac_dev->ctl_name,
+			   dev_name(edac_dev),
+			   edac_op_state_toString(edac_dev->op_state)
+	    );
 
 	unlock_device_list();
 	return 0;
 
-fail1:
+      fail1:
 	/* Some error, so remove the entry from the lsit */
 	del_edac_device_from_global_list(edac_dev);
 
-fail0:
+      fail0:
 	unlock_device_list();
 	return 1;
 }
+
 EXPORT_SYMBOL_GPL(edac_device_add_device);
 
 /**
@@ -504,7 +499,7 @@ EXPORT_SYMBOL_GPL(edac_device_add_device);
  *	Pointer to removed edac_device structure,
  *	OR NULL if device not found.
  */
-struct edac_device_ctl_info * edac_device_del_device(struct device *dev)
+struct edac_device_ctl_info *edac_device_del_device(struct device *dev)
 {
 	struct edac_device_ctl_info *edac_dev;
 
@@ -532,16 +527,14 @@ struct edac_device_ctl_info * edac_device_del_device(struct device *dev)
 	unlock_device_list();
 
 	edac_printk(KERN_INFO, EDAC_MC,
-		"Removed device %d for %s %s: DEV %s\n",
-		edac_dev->dev_idx,
-		edac_dev->mod_name,
-		edac_dev->ctl_name,
-		dev_name(edac_dev));
+		    "Removed device %d for %s %s: DEV %s\n",
+		    edac_dev->dev_idx,
+		    edac_dev->mod_name, edac_dev->ctl_name, dev_name(edac_dev));
 
 	return edac_dev;
 }
-EXPORT_SYMBOL_GPL(edac_device_del_device);
 
+EXPORT_SYMBOL_GPL(edac_device_del_device);
 
 static inline int edac_device_get_log_ce(struct edac_device_ctl_info *edac_dev)
 {
@@ -553,8 +546,8 @@ static inline int edac_device_get_log_ue(struct edac_device_ctl_info *edac_dev)
 	return edac_dev->log_ue;
 }
 
-static inline int edac_device_get_panic_on_ue(
-		struct edac_device_ctl_info *edac_dev)
+static inline int edac_device_get_panic_on_ue(struct edac_device_ctl_info
+					      *edac_dev)
 {
 	return edac_dev->panic_on_ue;
 }
@@ -564,15 +557,16 @@ static inline int edac_device_get_panic_on_ue(
  *	perform a common output and handling of an 'edac_dev' CE event
  */
 void edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,
-		int inst_nr, int block_nr, const char *msg)
+			   int inst_nr, int block_nr, const char *msg)
 {
 	struct edac_device_instance *instance;
 	struct edac_device_block *block = NULL;
 
 	if ((inst_nr >= edac_dev->nr_instances) || (inst_nr < 0)) {
 		edac_device_printk(edac_dev, KERN_ERR,
-			"INTERNAL ERROR: 'instance' out of range "
-			"(%d >= %d)\n", inst_nr, edac_dev->nr_instances);
+				   "INTERNAL ERROR: 'instance' out of range "
+				   "(%d >= %d)\n", inst_nr,
+				   edac_dev->nr_instances);
 		return;
 	}
 
@@ -580,8 +574,9 @@ void edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,
 
 	if ((block_nr >= instance->nr_blocks) || (block_nr < 0)) {
 		edac_device_printk(edac_dev, KERN_ERR,
-			"INTERNAL ERROR: instance %d 'block' out of range "
-			"(%d >= %d)\n", inst_nr, block_nr, instance->nr_blocks);
+				   "INTERNAL ERROR: instance %d 'block' out of range "
+				   "(%d >= %d)\n", inst_nr, block_nr,
+				   instance->nr_blocks);
 		return;
 	}
 
@@ -596,10 +591,11 @@ void edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,
 
 	if (edac_device_get_log_ce(edac_dev))
 		edac_device_printk(edac_dev, KERN_WARNING,
-		"CE ctl: %s, instance: %s, block: %s: %s\n",
-		edac_dev->ctl_name, instance->name,
-		block ? block->name : "N/A", msg);
+				   "CE ctl: %s, instance: %s, block: %s: %s\n",
+				   edac_dev->ctl_name, instance->name,
+				   block ? block->name : "N/A", msg);
 }
+
 EXPORT_SYMBOL_GPL(edac_device_handle_ce);
 
 /*
@@ -607,15 +603,16 @@ EXPORT_SYMBOL_GPL(edac_device_handle_ce);
  *	perform a common output and handling of an 'edac_dev' UE event
  */
 void edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,
-		int inst_nr, int block_nr, const char *msg)
+			   int inst_nr, int block_nr, const char *msg)
 {
 	struct edac_device_instance *instance;
 	struct edac_device_block *block = NULL;
 
 	if ((inst_nr >= edac_dev->nr_instances) || (inst_nr < 0)) {
 		edac_device_printk(edac_dev, KERN_ERR,
-			"INTERNAL ERROR: 'instance' out of range "
-			"(%d >= %d)\n", inst_nr, edac_dev->nr_instances);
+				   "INTERNAL ERROR: 'instance' out of range "
+				   "(%d >= %d)\n", inst_nr,
+				   edac_dev->nr_instances);
 		return;
 	}
 
@@ -623,8 +620,9 @@ void edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,
 
 	if ((block_nr >= instance->nr_blocks) || (block_nr < 0)) {
 		edac_device_printk(edac_dev, KERN_ERR,
-			"INTERNAL ERROR: instance %d 'block' out of range "
-			"(%d >= %d)\n", inst_nr, block_nr, instance->nr_blocks);
+				   "INTERNAL ERROR: instance %d 'block' out of range "
+				   "(%d >= %d)\n", inst_nr, block_nr,
+				   instance->nr_blocks);
 		return;
 	}
 
@@ -639,14 +637,14 @@ void edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,
 
 	if (edac_device_get_log_ue(edac_dev))
 		edac_device_printk(edac_dev, KERN_EMERG,
-		"UE ctl: %s, instance: %s, block: %s: %s\n",
-		edac_dev->ctl_name, instance->name,
-		block ? block->name : "N/A", msg);
+				   "UE ctl: %s, instance: %s, block: %s: %s\n",
+				   edac_dev->ctl_name, instance->name,
+				   block ? block->name : "N/A", msg);
 
 	if (edac_device_get_panic_on_ue(edac_dev))
 		panic("EDAC %s: UE instance: %s, block %s: %s\n",
-			edac_dev->ctl_name, instance->name,
-			block ? block->name : "N/A", msg);
+		      edac_dev->ctl_name, instance->name,
+		      block ? block->name : "N/A", msg);
 }
-EXPORT_SYMBOL_GPL(edac_device_handle_ue);
 
+EXPORT_SYMBOL_GPL(edac_device_handle_ue);

commit 91b99041c1d577ded1da599ddc28cec2e07253cf
Author: Dave Jiang <djiang@mvista.com>
Date:   Thu Jul 19 01:49:52 2007 -0700

    drivers/edac: updated PCI monitoring
    
    Moving PCI to a per-instance device model
    
    This should include the correct sysfs setup as well. Please review.
    
    Signed-off-by: Dave Jiang <djiang@mvista.com>
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 3f4c8a28154a..3db8effa1fd0 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -418,27 +418,6 @@ void edac_device_reset_delay_period(
 	unlock_device_list();
 }
 
-/*
- * edac_op_state_toString(edac_dev)
- */
-static char *edac_op_state_toString(struct edac_device_ctl_info *edac_dev)
-{
-	int opstate = edac_dev->op_state;
-
-	if (opstate == OP_RUNNING_POLL)
-		return "POLLED";
-	else if (opstate == OP_RUNNING_INTERRUPT)
-		return "INTERRUPT";
-	else if (opstate == OP_RUNNING_POLL_INTR)
-		return "POLL-INTR";
-	else if (opstate == OP_ALLOC)
-		return "ALLOC";
-	else if (opstate == OP_OFFLINE)
-		return "OFFLINE";
-
-	return "UNKNOWN";
-}
-
 /**
  * edac_device_add_device: Insert the 'edac_dev' structure into the
  * edac_device global list and create sysfs entries associated with
@@ -496,7 +475,7 @@ int edac_device_add_device(struct edac_device_ctl_info *edac_dev, int edac_idx)
 		edac_dev->mod_name,
 		edac_dev->ctl_name,
 		dev_name(edac_dev),
-		edac_op_state_toString(edac_dev)
+		edac_op_state_toString(edac_dev->op_state)
 		);
 
 	unlock_device_list();

commit 81d87cb13e367bb804bf44889ae0de7369705d6c
Author: Dave Jiang <djiang@mvista.com>
Date:   Thu Jul 19 01:49:52 2007 -0700

    drivers/edac: mod MC to use workq instead of kthread
    
    Move the memory controller object to work queue based implementation from the
    kernel thread based.
    
    Signed-off-by: Dave Jiang <djiang@mvista.com>
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 52db1b14fff5..3f4c8a28154a 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -332,17 +332,17 @@ EXPORT_SYMBOL(edac_device_find);
 
 
 /*
- * edac_workq_function
+ * edac_device_workq_function
  *	performs the operation scheduled by a workq request
  */
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
-static void edac_workq_function(struct work_struct *work_req)
+static void edac_device_workq_function(struct work_struct *work_req)
 {
 	struct delayed_work *d_work = (struct delayed_work*) work_req;
 	struct edac_device_ctl_info *edac_dev =
 		to_edac_device_ctl_work(d_work);
 #else
-static void edac_workq_function(void *ptr)
+static void edac_device_workq_function(void *ptr)
 {
 	struct edac_device_ctl_info *edac_dev =
 		(struct edac_device_ctl_info *) ptr;
@@ -364,30 +364,31 @@ static void edac_workq_function(void *ptr)
 }
 
 /*
- * edac_workq_setup
+ * edac_device_workq_setup
  *	initialize a workq item for this edac_device instance
  *	passing in the new delay period in msec
  */
-void edac_workq_setup(struct edac_device_ctl_info *edac_dev, unsigned msec)
+void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
+		unsigned msec)
 {
 	debugf0("%s()\n", __func__);
 
 	edac_dev->poll_msec = msec;
-	edac_device_calc_delay(edac_dev);	/* Calc delay jiffies */
+	edac_calc_delay(edac_dev);	/* Calc delay jiffies */
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
-	INIT_DELAYED_WORK(&edac_dev->work,edac_workq_function);
+	INIT_DELAYED_WORK(&edac_dev->work, edac_device_workq_function);
 #else
-	INIT_WORK(&edac_dev->work,edac_workq_function,edac_dev);
+	INIT_WORK(&edac_dev->work, edac_device_workq_function, edac_dev);
 #endif
-	queue_delayed_work(edac_workqueue,&edac_dev->work, edac_dev->delay);
+	queue_delayed_work(edac_workqueue, &edac_dev->work, edac_dev->delay);
 }
 
 /*
- * edac_workq_teardown
+ * edac_device_workq_teardown
  *	stop the workq processing on this edac_dev
  */
-void edac_workq_teardown(struct edac_device_ctl_info *edac_dev)
+void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev)
 {
 	int status;
 
@@ -409,10 +410,10 @@ void edac_device_reset_delay_period(
 	lock_device_list();
 
 	/* cancel the current workq request */
-	edac_workq_teardown(edac_dev);
+	edac_device_workq_teardown(edac_dev);
 
 	/* restart the workq request, with new delay value */
-	edac_workq_setup(edac_dev, value);
+	edac_device_workq_setup(edac_dev, value);
 
 	unlock_device_list();
 }
@@ -479,8 +480,11 @@ int edac_device_add_device(struct edac_device_ctl_info *edac_dev, int edac_idx)
 		/* This instance is NOW RUNNING */
 		edac_dev->op_state = OP_RUNNING_POLL;
 
-		/* enable workq processing on this instance, default = 1000 msec */
-		edac_workq_setup(edac_dev, 1000);
+		/*
+		 * enable workq processing on this instance,
+		 * default = 1000 msec
+		 */
+		edac_device_workq_setup(edac_dev, 1000);
 	} else {
 		edac_dev->op_state = OP_RUNNING_INTERRUPT;
 	}
@@ -538,7 +542,7 @@ struct edac_device_ctl_info * edac_device_del_device(struct device *dev)
 	edac_dev->op_state = OP_OFFLINE;
 
 	/* clear workq processing on this instance */
-	edac_workq_teardown(edac_dev);
+	edac_device_workq_teardown(edac_dev);
 
 	/* Tear down the sysfs entries for this instance */
 	edac_device_remove_sysfs(edac_dev);

commit c4192705fec85219086231a1c0fa61e8776e2c3b
Author: Dave Jiang <djiang@mvista.com>
Date:   Thu Jul 19 01:49:47 2007 -0700

    drivers/edac: add dev_name getter function
    
    Move dev_name() macro to a more generic interface since it's not possible
    to determine whether a device is pci, platform, or of_device easily.
    
    Now each low level driver sets the name into the control structure, and
    the EDAC core references the control structure for the information.
    
    Better abstraction.
    
    Signed-off-by: Dave Jiang <djiang@mvista.com>
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index c579c498cc75..52db1b14fff5 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -264,7 +264,7 @@ static int add_edac_dev_to_global_list (struct edac_device_ctl_info *edac_dev)
 fail0:
 	edac_printk(KERN_WARNING, EDAC_MC,
 		"%s (%s) %s %s already assigned %d\n",
-		rover->dev->bus_id, dev_name(rover->dev),
+		rover->dev->bus_id, dev_name(rover),
 		rover->mod_name, rover->ctl_name, rover->dev_idx);
 	return 1;
 
@@ -491,7 +491,7 @@ int edac_device_add_device(struct edac_device_ctl_info *edac_dev, int edac_idx)
 		"Giving out device to module '%s' controller '%s': DEV '%s' (%s)\n",
 		edac_dev->mod_name,
 		edac_dev->ctl_name,
-		dev_name(edac_dev->dev),
+		dev_name(edac_dev),
 		edac_op_state_toString(edac_dev)
 		);
 
@@ -553,7 +553,7 @@ struct edac_device_ctl_info * edac_device_del_device(struct device *dev)
 		edac_dev->dev_idx,
 		edac_dev->mod_name,
 		edac_dev->ctl_name,
-		dev_name(edac_dev->dev));
+		dev_name(edac_dev));
 
 	return edac_dev;
 }

commit e27e3dac651771fe3250f6305dee277bce29fc5d
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:49:36 2007 -0700

    drivers/edac: add edac_device class
    
    This patch adds the new 'class' of object to be managed, named: 'edac_device'.
    
    As a peer of the 'edac_mc' class of object, it provides a non-memory centric
    view of an ERROR DETECTING device in hardware. It provides a sysfs interface
    and an abstraction for varioius EDAC type devices.
    
    Multiple 'instances' within the class are possible, with each 'instance'
    able to have multiple 'blocks', and each 'block' having 'attributes'.
    
    At the 'block' level there are the 'ce_count' and 'ue_count' fields
    which the device driver can update and/or call edac_device_handle_XX()
    functions. At each higher level are additional 'total' count fields,
    which are a summation of counts below that level.
    
    This 'edac_device' has been used to capture and present ECC errors
    which are found in a a L1 and L2 system on a per CORE/CPU basis.
    
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
new file mode 100644
index 000000000000..c579c498cc75
--- /dev/null
+++ b/drivers/edac/edac_device.c
@@ -0,0 +1,669 @@
+
+/*
+ * edac_device.c
+ * (C) 2007 www.douglaskthompson.com
+ *
+ * This file may be distributed under the terms of the
+ * GNU General Public License.
+ *
+ * Written by Doug Thompson <norsk5@xmission.com>
+ *
+ * edac_device API implementation
+ * 19 Jan 2007
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/smp.h>
+#include <linux/init.h>
+#include <linux/sysctl.h>
+#include <linux/highmem.h>
+#include <linux/timer.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <linux/sysdev.h>
+#include <linux/ctype.h>
+#include <linux/workqueue.h>
+#include <asm/uaccess.h>
+#include <asm/page.h>
+
+#include "edac_core.h"
+#include "edac_module.h"
+
+/* lock to memory controller's control array */
+static DECLARE_MUTEX(device_ctls_mutex);
+static struct list_head edac_device_list = LIST_HEAD_INIT(edac_device_list);
+
+
+static inline void lock_device_list(void)
+{
+	down(&device_ctls_mutex);
+}
+
+static inline void unlock_device_list(void)
+{
+	up(&device_ctls_mutex);
+}
+
+
+#ifdef CONFIG_EDAC_DEBUG
+static void edac_device_dump_device(struct edac_device_ctl_info *edac_dev)
+{
+	debugf3("\tedac_dev = %p dev_idx=%d \n", edac_dev,edac_dev->dev_idx);
+	debugf4("\tedac_dev->edac_check = %p\n", edac_dev->edac_check);
+	debugf3("\tdev = %p\n", edac_dev->dev);
+	debugf3("\tmod_name:ctl_name = %s:%s\n",
+		edac_dev->mod_name, edac_dev->ctl_name);
+	debugf3("\tpvt_info = %p\n\n", edac_dev->pvt_info);
+}
+#endif  /* CONFIG_EDAC_DEBUG */
+
+/*
+ * The alloc() and free() functions for the 'edac_device' control info
+ * structure. A MC driver will allocate one of these for each edac_device
+ * it is going to control/register with the EDAC CORE.
+ */
+struct edac_device_ctl_info *edac_device_alloc_ctl_info(
+	unsigned sz_private,
+	char *edac_device_name,
+	unsigned nr_instances,
+	char *edac_block_name,
+	unsigned nr_blocks,
+	unsigned offset_value,
+	struct edac_attrib_spec *attrib_spec,
+	unsigned nr_attribs)
+{
+	struct edac_device_ctl_info *dev_ctl;
+	struct edac_device_instance *dev_inst, *inst;
+	struct edac_device_block *dev_blk, *blk_p, *blk;
+	struct edac_attrib *dev_attrib, *attrib_p, *attrib;
+	unsigned total_size;
+	unsigned count;
+	unsigned instance, block, attr;
+	void *pvt;
+
+	debugf1("%s() instances=%d blocks=%d\n",
+		__func__,nr_instances,nr_blocks);
+
+	/* Figure out the offsets of the various items from the start of an
+	 * ctl_info structure.  We want the alignment of each item
+	 * to be at least as stringent as what the compiler would
+	 * provide if we could simply hardcode everything into a single struct.
+	 */
+	dev_ctl = (struct edac_device_ctl_info *) 0;
+
+	/* Calc the 'end' offset past the ctl_info structure */
+	dev_inst = (struct edac_device_instance *)
+			edac_align_ptr(&dev_ctl[1],sizeof(*dev_inst));
+
+	/* Calc the 'end' offset past the instance array */
+	dev_blk = (struct edac_device_block *)
+			edac_align_ptr(&dev_inst[nr_instances],sizeof(*dev_blk));
+
+	/* Calc the 'end' offset past the dev_blk array */
+	count = nr_instances * nr_blocks;
+	dev_attrib = (struct edac_attrib *)
+			edac_align_ptr(&dev_blk[count],sizeof(*dev_attrib));
+
+	/* Check for case of NO attributes specified */
+	if (nr_attribs > 0)
+		count *= nr_attribs;
+
+	/* Calc the 'end' offset past the attributes array */
+	pvt = edac_align_ptr(&dev_attrib[count],sz_private);
+	total_size = ((unsigned long) pvt) + sz_private;
+
+	/* Allocate the amount of memory for the set of control structures */
+	if ((dev_ctl = kmalloc(total_size, GFP_KERNEL)) == NULL)
+		return NULL;
+
+	/* Adjust pointers so they point within the memory we just allocated
+	 * rather than an imaginary chunk of memory located at address 0.
+	 */
+	dev_inst = (struct edac_device_instance *)
+			(((char *) dev_ctl) + ((unsigned long) dev_inst));
+	dev_blk = (struct edac_device_block *)
+			(((char *) dev_ctl) + ((unsigned long) dev_blk));
+	dev_attrib = (struct edac_attrib *)
+			(((char *) dev_ctl) + ((unsigned long) dev_attrib));
+	pvt = sz_private ?
+			(((char *) dev_ctl) + ((unsigned long) pvt)) : NULL;
+
+	memset(dev_ctl, 0, total_size);		/* clear all fields */
+	dev_ctl->nr_instances = nr_instances;
+	dev_ctl->instances = dev_inst;
+	dev_ctl->pvt_info = pvt;
+
+	/* Name of this edac device, ensure null terminated */
+	snprintf(dev_ctl->name,sizeof(dev_ctl->name),"%s", edac_device_name);
+	dev_ctl->name[sizeof(dev_ctl->name)-1] = '\0';
+
+	/* Initialize every Instance */
+	for (instance = 0; instance < nr_instances; instance++) {
+		inst = &dev_inst[instance];
+		inst->ctl = dev_ctl;
+		inst->nr_blocks = nr_blocks;
+		blk_p = &dev_blk[instance * nr_blocks];
+		inst->blocks = blk_p;
+
+		/* name of this instance */
+		snprintf(inst->name, sizeof(inst->name),
+			"%s%u", edac_device_name, instance);
+		inst->name[sizeof(inst->name)-1] = '\0';
+
+		/* Initialize every block in each instance */
+		for (		block = 0;
+				block < nr_blocks;
+				block++) {
+			blk = &blk_p[block];
+			blk->instance = inst;
+			blk->nr_attribs = nr_attribs;
+			attrib_p = &dev_attrib[block * nr_attribs];
+			blk->attribs = attrib_p;
+			snprintf(blk->name, sizeof(blk->name),
+				"%s%d", edac_block_name,block+1);
+			blk->name[sizeof(blk->name)-1] = '\0';
+
+			debugf1("%s() instance=%d block=%d name=%s\n",
+				__func__, instance,block,blk->name);
+
+			if (attrib_spec != NULL) {
+				/* when there is an attrib_spec passed int then
+				 * Initialize every attrib of each block
+				 */
+				for (attr = 0; attr < nr_attribs; attr++) {
+					attrib = &attrib_p[attr];
+					attrib->block = blk;
+
+					/* Link each attribute to the caller's
+					 * spec entry, for name and type
+				 	 */
+					attrib->spec = &attrib_spec[attr];
+				}
+			}
+		}
+	}
+
+	/* Mark this instance as merely ALLOCATED */
+	dev_ctl->op_state = OP_ALLOC;
+
+	return dev_ctl;
+}
+EXPORT_SYMBOL_GPL(edac_device_alloc_ctl_info);
+
+/*
+ * edac_device_free_ctl_info()
+ *	frees the memory allocated by the edac_device_alloc_ctl_info()
+ *	function
+ */
+void edac_device_free_ctl_info( struct edac_device_ctl_info *ctl_info) {
+	kfree(ctl_info);
+}
+EXPORT_SYMBOL_GPL(edac_device_free_ctl_info);
+
+
+
+/*
+ * find_edac_device_by_dev
+ *	scans the edac_device list for a specific 'struct device *'
+ */
+static struct edac_device_ctl_info *
+find_edac_device_by_dev(struct device *dev)
+{
+	struct edac_device_ctl_info *edac_dev;
+	struct list_head *item;
+
+	debugf3("%s()\n", __func__);
+
+	list_for_each(item, &edac_device_list) {
+		edac_dev = list_entry(item, struct edac_device_ctl_info, link);
+
+		if (edac_dev->dev == dev)
+			return edac_dev;
+	}
+
+	return NULL;
+}
+
+/*
+ * add_edac_dev_to_global_list
+ *	Before calling this function, caller must
+ *	assign a unique value to edac_dev->dev_idx.
+ *	Return:
+ *		0 on success
+ *		1 on failure.
+ */
+static int add_edac_dev_to_global_list (struct edac_device_ctl_info *edac_dev)
+{
+	struct list_head *item, *insert_before;
+	struct edac_device_ctl_info *rover;
+
+	insert_before = &edac_device_list;
+
+	/* Determine if already on the list */
+	if (unlikely((rover = find_edac_device_by_dev(edac_dev->dev)) != NULL))
+		goto fail0;
+
+	/* Insert in ascending order by 'dev_idx', so find position */
+	list_for_each(item, &edac_device_list) {
+		rover = list_entry(item, struct edac_device_ctl_info, link);
+
+		if (rover->dev_idx >= edac_dev->dev_idx) {
+			if (unlikely(rover->dev_idx == edac_dev->dev_idx))
+				goto fail1;
+
+			insert_before = item;
+			break;
+		}
+	}
+
+	list_add_tail_rcu(&edac_dev->link, insert_before);
+	return 0;
+
+fail0:
+	edac_printk(KERN_WARNING, EDAC_MC,
+		"%s (%s) %s %s already assigned %d\n",
+		rover->dev->bus_id, dev_name(rover->dev),
+		rover->mod_name, rover->ctl_name, rover->dev_idx);
+	return 1;
+
+fail1:
+	edac_printk(KERN_WARNING, EDAC_MC,
+		"bug in low-level driver: attempt to assign\n"
+		"    duplicate dev_idx %d in %s()\n", rover->dev_idx, __func__);
+	return 1;
+}
+
+/*
+ * complete_edac_device_list_del
+ */
+static void complete_edac_device_list_del(struct rcu_head *head)
+{
+	struct edac_device_ctl_info *edac_dev;
+
+	edac_dev = container_of(head, struct edac_device_ctl_info, rcu);
+	INIT_LIST_HEAD(&edac_dev->link);
+	complete(&edac_dev->complete);
+}
+
+/*
+ * del_edac_device_from_global_list
+ */
+static void del_edac_device_from_global_list(
+			struct edac_device_ctl_info *edac_device)
+{
+	list_del_rcu(&edac_device->link);
+	init_completion(&edac_device->complete);
+	call_rcu(&edac_device->rcu, complete_edac_device_list_del);
+	wait_for_completion(&edac_device->complete);
+}
+
+/**
+ * edac_device_find
+ *	Search for a edac_device_ctl_info structure whose index is 'idx'.
+ *
+ * If found, return a pointer to the structure.
+ * Else return NULL.
+ *
+ * Caller must hold device_ctls_mutex.
+ */
+struct edac_device_ctl_info * edac_device_find(int idx)
+{
+	struct list_head *item;
+	struct edac_device_ctl_info *edac_dev;
+
+	/* Iterate over list, looking for exact match of ID */
+	list_for_each(item, &edac_device_list) {
+		edac_dev = list_entry(item, struct edac_device_ctl_info, link);
+
+		if (edac_dev->dev_idx >= idx) {
+			if (edac_dev->dev_idx == idx)
+				return edac_dev;
+
+			/* not on list, so terminate early */
+			break;
+		}
+	}
+
+	return NULL;
+}
+EXPORT_SYMBOL(edac_device_find);
+
+
+/*
+ * edac_workq_function
+ *	performs the operation scheduled by a workq request
+ */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
+static void edac_workq_function(struct work_struct *work_req)
+{
+	struct delayed_work *d_work = (struct delayed_work*) work_req;
+	struct edac_device_ctl_info *edac_dev =
+		to_edac_device_ctl_work(d_work);
+#else
+static void edac_workq_function(void *ptr)
+{
+	struct edac_device_ctl_info *edac_dev =
+		(struct edac_device_ctl_info *) ptr;
+#endif
+
+	//debugf0("%s() here and running\n", __func__);
+	lock_device_list();
+
+	/* Only poll controllers that are running polled and have a check */
+	if ((edac_dev->op_state == OP_RUNNING_POLL) &&
+					(edac_dev->edac_check != NULL)) {
+		edac_dev->edac_check(edac_dev);
+	}
+
+	unlock_device_list();
+
+	/* Reschedule */
+	queue_delayed_work(edac_workqueue,&edac_dev->work, edac_dev->delay);
+}
+
+/*
+ * edac_workq_setup
+ *	initialize a workq item for this edac_device instance
+ *	passing in the new delay period in msec
+ */
+void edac_workq_setup(struct edac_device_ctl_info *edac_dev, unsigned msec)
+{
+	debugf0("%s()\n", __func__);
+
+	edac_dev->poll_msec = msec;
+	edac_device_calc_delay(edac_dev);	/* Calc delay jiffies */
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
+	INIT_DELAYED_WORK(&edac_dev->work,edac_workq_function);
+#else
+	INIT_WORK(&edac_dev->work,edac_workq_function,edac_dev);
+#endif
+	queue_delayed_work(edac_workqueue,&edac_dev->work, edac_dev->delay);
+}
+
+/*
+ * edac_workq_teardown
+ *	stop the workq processing on this edac_dev
+ */
+void edac_workq_teardown(struct edac_device_ctl_info *edac_dev)
+{
+	int status;
+
+	status = cancel_delayed_work(&edac_dev->work);
+	if (status == 0) {
+		/* workq instance might be running, wait for it */
+		flush_workqueue(edac_workqueue);
+	}
+}
+
+/*
+ * edac_device_reset_delay_period
+ */
+
+void edac_device_reset_delay_period(
+		struct edac_device_ctl_info *edac_dev,
+		unsigned long value)
+{
+	lock_device_list();
+
+	/* cancel the current workq request */
+	edac_workq_teardown(edac_dev);
+
+	/* restart the workq request, with new delay value */
+	edac_workq_setup(edac_dev, value);
+
+	unlock_device_list();
+}
+
+/*
+ * edac_op_state_toString(edac_dev)
+ */
+static char *edac_op_state_toString(struct edac_device_ctl_info *edac_dev)
+{
+	int opstate = edac_dev->op_state;
+
+	if (opstate == OP_RUNNING_POLL)
+		return "POLLED";
+	else if (opstate == OP_RUNNING_INTERRUPT)
+		return "INTERRUPT";
+	else if (opstate == OP_RUNNING_POLL_INTR)
+		return "POLL-INTR";
+	else if (opstate == OP_ALLOC)
+		return "ALLOC";
+	else if (opstate == OP_OFFLINE)
+		return "OFFLINE";
+
+	return "UNKNOWN";
+}
+
+/**
+ * edac_device_add_device: Insert the 'edac_dev' structure into the
+ * edac_device global list and create sysfs entries associated with
+ * edac_device structure.
+ * @edac_device: pointer to the edac_device structure to be added to the list
+ * @edac_idx: A unique numeric identifier to be assigned to the
+ * 'edac_device' structure.
+ *
+ * Return:
+ *	0	Success
+ *	!0	Failure
+ */
+int edac_device_add_device(struct edac_device_ctl_info *edac_dev, int edac_idx)
+{
+	debugf0("%s()\n", __func__);
+
+	edac_dev->dev_idx = edac_idx;
+#ifdef CONFIG_EDAC_DEBUG
+	if (edac_debug_level >= 3)
+		edac_device_dump_device(edac_dev);
+#endif
+	lock_device_list();
+
+	if (add_edac_dev_to_global_list(edac_dev))
+		goto fail0;
+
+	/* set load time so that error rate can be tracked */
+	edac_dev->start_time = jiffies;
+
+	/* create this instance's sysfs entries */
+	if (edac_device_create_sysfs(edac_dev)) {
+		edac_device_printk(edac_dev, KERN_WARNING,
+			"failed to create sysfs device\n");
+		goto fail1;
+	}
+
+	/* If there IS a check routine, then we are running POLLED */
+	if (edac_dev->edac_check != NULL) {
+		/* This instance is NOW RUNNING */
+		edac_dev->op_state = OP_RUNNING_POLL;
+
+		/* enable workq processing on this instance, default = 1000 msec */
+		edac_workq_setup(edac_dev, 1000);
+	} else {
+		edac_dev->op_state = OP_RUNNING_INTERRUPT;
+	}
+
+
+	/* Report action taken */
+	edac_device_printk(edac_dev, KERN_INFO,
+		"Giving out device to module '%s' controller '%s': DEV '%s' (%s)\n",
+		edac_dev->mod_name,
+		edac_dev->ctl_name,
+		dev_name(edac_dev->dev),
+		edac_op_state_toString(edac_dev)
+		);
+
+	unlock_device_list();
+	return 0;
+
+fail1:
+	/* Some error, so remove the entry from the lsit */
+	del_edac_device_from_global_list(edac_dev);
+
+fail0:
+	unlock_device_list();
+	return 1;
+}
+EXPORT_SYMBOL_GPL(edac_device_add_device);
+
+/**
+ * edac_device_del_device:
+ *	Remove sysfs entries for specified edac_device structure and
+ *	then remove edac_device structure from global list
+ *
+ * @pdev:
+ *	Pointer to 'struct device' representing edac_device
+ *	structure to remove.
+ *
+ * Return:
+ *	Pointer to removed edac_device structure,
+ *	OR NULL if device not found.
+ */
+struct edac_device_ctl_info * edac_device_del_device(struct device *dev)
+{
+	struct edac_device_ctl_info *edac_dev;
+
+	debugf0("MC: %s()\n", __func__);
+
+	lock_device_list();
+
+	if ((edac_dev = find_edac_device_by_dev(dev)) == NULL) {
+		unlock_device_list();
+		return NULL;
+	}
+
+	/* mark this instance as OFFLINE */
+	edac_dev->op_state = OP_OFFLINE;
+
+	/* clear workq processing on this instance */
+	edac_workq_teardown(edac_dev);
+
+	/* Tear down the sysfs entries for this instance */
+	edac_device_remove_sysfs(edac_dev);
+
+	/* deregister from global list */
+	del_edac_device_from_global_list(edac_dev);
+
+	unlock_device_list();
+
+	edac_printk(KERN_INFO, EDAC_MC,
+		"Removed device %d for %s %s: DEV %s\n",
+		edac_dev->dev_idx,
+		edac_dev->mod_name,
+		edac_dev->ctl_name,
+		dev_name(edac_dev->dev));
+
+	return edac_dev;
+}
+EXPORT_SYMBOL_GPL(edac_device_del_device);
+
+
+static inline int edac_device_get_log_ce(struct edac_device_ctl_info *edac_dev)
+{
+	return edac_dev->log_ce;
+}
+
+static inline int edac_device_get_log_ue(struct edac_device_ctl_info *edac_dev)
+{
+	return edac_dev->log_ue;
+}
+
+static inline int edac_device_get_panic_on_ue(
+		struct edac_device_ctl_info *edac_dev)
+{
+	return edac_dev->panic_on_ue;
+}
+
+/*
+ * edac_device_handle_ce
+ *	perform a common output and handling of an 'edac_dev' CE event
+ */
+void edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,
+		int inst_nr, int block_nr, const char *msg)
+{
+	struct edac_device_instance *instance;
+	struct edac_device_block *block = NULL;
+
+	if ((inst_nr >= edac_dev->nr_instances) || (inst_nr < 0)) {
+		edac_device_printk(edac_dev, KERN_ERR,
+			"INTERNAL ERROR: 'instance' out of range "
+			"(%d >= %d)\n", inst_nr, edac_dev->nr_instances);
+		return;
+	}
+
+	instance = edac_dev->instances + inst_nr;
+
+	if ((block_nr >= instance->nr_blocks) || (block_nr < 0)) {
+		edac_device_printk(edac_dev, KERN_ERR,
+			"INTERNAL ERROR: instance %d 'block' out of range "
+			"(%d >= %d)\n", inst_nr, block_nr, instance->nr_blocks);
+		return;
+	}
+
+	if (instance->nr_blocks > 0) {
+		block = instance->blocks + block_nr;
+		block->counters.ce_count++;
+	}
+
+	/* Propogate the count up the 'totals' tree */
+	instance->counters.ce_count++;
+	edac_dev->counters.ce_count++;
+
+	if (edac_device_get_log_ce(edac_dev))
+		edac_device_printk(edac_dev, KERN_WARNING,
+		"CE ctl: %s, instance: %s, block: %s: %s\n",
+		edac_dev->ctl_name, instance->name,
+		block ? block->name : "N/A", msg);
+}
+EXPORT_SYMBOL_GPL(edac_device_handle_ce);
+
+/*
+ * edac_device_handle_ue
+ *	perform a common output and handling of an 'edac_dev' UE event
+ */
+void edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,
+		int inst_nr, int block_nr, const char *msg)
+{
+	struct edac_device_instance *instance;
+	struct edac_device_block *block = NULL;
+
+	if ((inst_nr >= edac_dev->nr_instances) || (inst_nr < 0)) {
+		edac_device_printk(edac_dev, KERN_ERR,
+			"INTERNAL ERROR: 'instance' out of range "
+			"(%d >= %d)\n", inst_nr, edac_dev->nr_instances);
+		return;
+	}
+
+	instance = edac_dev->instances + inst_nr;
+
+	if ((block_nr >= instance->nr_blocks) || (block_nr < 0)) {
+		edac_device_printk(edac_dev, KERN_ERR,
+			"INTERNAL ERROR: instance %d 'block' out of range "
+			"(%d >= %d)\n", inst_nr, block_nr, instance->nr_blocks);
+		return;
+	}
+
+	if (instance->nr_blocks > 0) {
+		block = instance->blocks + block_nr;
+		block->counters.ue_count++;
+	}
+
+	/* Propogate the count up the 'totals' tree */
+	instance->counters.ue_count++;
+	edac_dev->counters.ue_count++;
+
+	if (edac_device_get_log_ue(edac_dev))
+		edac_device_printk(edac_dev, KERN_EMERG,
+		"UE ctl: %s, instance: %s, block: %s: %s\n",
+		edac_dev->ctl_name, instance->name,
+		block ? block->name : "N/A", msg);
+
+	if (edac_device_get_panic_on_ue(edac_dev))
+		panic("EDAC %s: UE instance: %s, block %s: %s\n",
+			edac_dev->ctl_name, instance->name,
+			block ? block->name : "N/A", msg);
+}
+EXPORT_SYMBOL_GPL(edac_device_handle_ue);
+
