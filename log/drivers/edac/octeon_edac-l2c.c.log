commit 78d88e8a3d738f1ce508cd24b525d2e6cdfda1c1
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Sat Oct 29 15:16:34 2016 -0200

    edac: rename edac_core.h to edac_mc.h
    
    Now, all left at edac_core.h are at drivers/edac/edac_mc.c,
    so rename it to edac_mc.h.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/edac/octeon_edac-l2c.c b/drivers/edac/octeon_edac-l2c.c
index afea7fc625cc..c33059e9b0be 100644
--- a/drivers/edac/octeon_edac-l2c.c
+++ b/drivers/edac/octeon_edac-l2c.c
@@ -16,7 +16,6 @@
 
 #include <asm/octeon/cvmx.h>
 
-#include "edac_core.h"
 #include "edac_module.h"
 
 #define EDAC_MOD_STR "octeon-l2c"

commit 75a15a7864c9e281c74a1670b10b69d1d7ff1c82
Author: Aaro Koskinen <aaro.koskinen@nokia.com>
Date:   Wed Jul 1 13:38:52 2015 +0300

    EDAC, octeon: Fix broken build due to model helper renames
    
    Commit
    
      debe6a623d3c ("MIPS: OCTEON: Update octeon-model.h code for new SoCs.")
    
    renamed some SoC model helper functions, but forgot to update the EDAC
    drivers resulting in build failures. Fix that.
    
    Cc: stable@vger.kernel.org # v4.0+
    Signed-off-by: Aaro Koskinen <aaro.koskinen@nokia.com>
    Acked-by: David Daney <david.daney@cavium.com>
    Cc: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Cc: linux-mips@linux-mips.org
    Link: http://lkml.kernel.org/r/1435747132-10954-1-git-send-email-aaro.koskinen@nokia.com
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/octeon_edac-l2c.c b/drivers/edac/octeon_edac-l2c.c
index 7e98084d3645..afea7fc625cc 100644
--- a/drivers/edac/octeon_edac-l2c.c
+++ b/drivers/edac/octeon_edac-l2c.c
@@ -151,7 +151,7 @@ static int octeon_l2c_probe(struct platform_device *pdev)
 	l2c->ctl_name = "octeon_l2c_err";
 
 
-	if (OCTEON_IS_MODEL(OCTEON_FAM_1_PLUS)) {
+	if (OCTEON_IS_OCTEON1PLUS()) {
 		union cvmx_l2t_err l2t_err;
 		union cvmx_l2d_err l2d_err;
 

commit 9b3c6e85c2cfa731cf67d5a8c49f7d8c60ec0b04
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:23:51 2012 -0800

    Drivers: edac: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, and __devexit
    from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Doug Thompson <dougthompson@xmission.com>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: Jason Uhlenkott <juhlenko@akamai.com>
    Cc: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Tim Small <tim@buttersideup.com>
    Cc: Ranganathan Desikan <ravi@jetztechnologies.com>
    Cc: "Arvind R." <arvino55@gmail.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: David Daney <david.daney@cavium.com>
    Cc: Egor Martovetsky <egor@pasemi.com>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/edac/octeon_edac-l2c.c b/drivers/edac/octeon_edac-l2c.c
index 40fde6a51ed6..7e98084d3645 100644
--- a/drivers/edac/octeon_edac-l2c.c
+++ b/drivers/edac/octeon_edac-l2c.c
@@ -131,7 +131,7 @@ static void octeon_l2c_poll_oct2(struct edac_device_ctl_info *l2c)
 		_octeon_l2c_poll_oct2(l2c, i);
 }
 
-static int __devinit octeon_l2c_probe(struct platform_device *pdev)
+static int octeon_l2c_probe(struct platform_device *pdev)
 {
 	struct edac_device_ctl_info *l2c;
 

commit e1ced09797776dfd4a2a7b04b9ee7e97ab1e64be
Author: David Daney <david.daney@cavium.com>
Date:   Thu Nov 15 13:58:59 2012 -0800

    MIPS/EDAC: Improve OCTEON EDAC support.
    
    Some initialization errors are reported with the existing OCTEON EDAC
    support patch.  Also some parts have more than one memory controller.
    
    Fix the errors and add multiple controllers if present.
    
    Signed-off-by: David Daney <david.daney@cavium.com>

diff --git a/drivers/edac/octeon_edac-l2c.c b/drivers/edac/octeon_edac-l2c.c
index 5f459aa451bf..40fde6a51ed6 100644
--- a/drivers/edac/octeon_edac-l2c.c
+++ b/drivers/edac/octeon_edac-l2c.c
@@ -3,6 +3,8 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
+ * Copyright (C) 2012 Cavium, Inc.
+ *
  * Copyright (C) 2009 Wind River Systems,
  *   written by Ralf Baechle <ralf@linux-mips.org>
  */
@@ -19,32 +21,124 @@
 
 #define EDAC_MOD_STR "octeon-l2c"
 
-static void co_l2c_poll(struct edac_device_ctl_info *l2c)
+static void octeon_l2c_poll_oct1(struct edac_device_ctl_info *l2c)
 {
-	union cvmx_l2t_err l2t_err;
+	union cvmx_l2t_err l2t_err, l2t_err_reset;
+	union cvmx_l2d_err l2d_err, l2d_err_reset;
 
+	l2t_err_reset.u64 = 0;
 	l2t_err.u64 = cvmx_read_csr(CVMX_L2T_ERR);
 	if (l2t_err.s.sec_err) {
 		edac_device_handle_ce(l2c, 0, 0,
-				      "Single bit error (corrected)");
-		l2t_err.s.sec_err = 1;		/* Reset */
-		cvmx_write_csr(CVMX_L2T_ERR, l2t_err.u64);
+				      "Tag Single bit error (corrected)");
+		l2t_err_reset.s.sec_err = 1;
 	}
 	if (l2t_err.s.ded_err) {
 		edac_device_handle_ue(l2c, 0, 0,
-				      "Double bit error (corrected)");
-		l2t_err.s.ded_err = 1;		/* Reset */
-		cvmx_write_csr(CVMX_L2T_ERR, l2t_err.u64);
+				      "Tag Double bit error (detected)");
+		l2t_err_reset.s.ded_err = 1;
+	}
+	if (l2t_err_reset.u64)
+		cvmx_write_csr(CVMX_L2T_ERR, l2t_err_reset.u64);
+
+	l2d_err_reset.u64 = 0;
+	l2d_err.u64 = cvmx_read_csr(CVMX_L2D_ERR);
+	if (l2d_err.s.sec_err) {
+		edac_device_handle_ce(l2c, 0, 1,
+				      "Data Single bit error (corrected)");
+		l2d_err_reset.s.sec_err = 1;
+	}
+	if (l2d_err.s.ded_err) {
+		edac_device_handle_ue(l2c, 0, 1,
+				      "Data Double bit error (detected)");
+		l2d_err_reset.s.ded_err = 1;
+	}
+	if (l2d_err_reset.u64)
+		cvmx_write_csr(CVMX_L2D_ERR, l2d_err_reset.u64);
+
+}
+
+static void _octeon_l2c_poll_oct2(struct edac_device_ctl_info *l2c, int tad)
+{
+	union cvmx_l2c_err_tdtx err_tdtx, err_tdtx_reset;
+	union cvmx_l2c_err_ttgx err_ttgx, err_ttgx_reset;
+	char buf1[64];
+	char buf2[80];
+
+	err_tdtx_reset.u64 = 0;
+	err_tdtx.u64 = cvmx_read_csr(CVMX_L2C_ERR_TDTX(tad));
+	if (err_tdtx.s.dbe || err_tdtx.s.sbe ||
+	    err_tdtx.s.vdbe || err_tdtx.s.vsbe)
+		snprintf(buf1, sizeof(buf1),
+			 "type:%d, syn:0x%x, way:%d",
+			 err_tdtx.s.type, err_tdtx.s.syn, err_tdtx.s.wayidx);
+
+	if (err_tdtx.s.dbe) {
+		snprintf(buf2, sizeof(buf2),
+			 "L2D Double bit error (detected):%s", buf1);
+		err_tdtx_reset.s.dbe = 1;
+		edac_device_handle_ue(l2c, tad, 1, buf2);
+	}
+	if (err_tdtx.s.sbe) {
+		snprintf(buf2, sizeof(buf2),
+			 "L2D Single bit error (corrected):%s", buf1);
+		err_tdtx_reset.s.sbe = 1;
+		edac_device_handle_ce(l2c, tad, 1, buf2);
+	}
+	if (err_tdtx.s.vdbe) {
+		snprintf(buf2, sizeof(buf2),
+			 "VBF Double bit error (detected):%s", buf1);
+		err_tdtx_reset.s.vdbe = 1;
+		edac_device_handle_ue(l2c, tad, 1, buf2);
+	}
+	if (err_tdtx.s.vsbe) {
+		snprintf(buf2, sizeof(buf2),
+			 "VBF Single bit error (corrected):%s", buf1);
+		err_tdtx_reset.s.vsbe = 1;
+		edac_device_handle_ce(l2c, tad, 1, buf2);
+	}
+	if (err_tdtx_reset.u64)
+		cvmx_write_csr(CVMX_L2C_ERR_TDTX(tad), err_tdtx_reset.u64);
+
+	err_ttgx_reset.u64 = 0;
+	err_ttgx.u64 = cvmx_read_csr(CVMX_L2C_ERR_TTGX(tad));
+
+	if (err_ttgx.s.dbe || err_ttgx.s.sbe)
+		snprintf(buf1, sizeof(buf1),
+			 "type:%d, syn:0x%x, way:%d",
+			 err_ttgx.s.type, err_ttgx.s.syn, err_ttgx.s.wayidx);
+
+	if (err_ttgx.s.dbe) {
+		snprintf(buf2, sizeof(buf2),
+			 "Tag Double bit error (detected):%s", buf1);
+		err_ttgx_reset.s.dbe = 1;
+		edac_device_handle_ue(l2c, tad, 0, buf2);
 	}
+	if (err_ttgx.s.sbe) {
+		snprintf(buf2, sizeof(buf2),
+			 "Tag Single bit error (corrected):%s", buf1);
+		err_ttgx_reset.s.sbe = 1;
+		edac_device_handle_ce(l2c, tad, 0, buf2);
+	}
+	if (err_ttgx_reset.u64)
+		cvmx_write_csr(CVMX_L2C_ERR_TTGX(tad), err_ttgx_reset.u64);
+}
+
+static void octeon_l2c_poll_oct2(struct edac_device_ctl_info *l2c)
+{
+	int i;
+	for (i = 0; i < l2c->nr_instances; i++)
+		_octeon_l2c_poll_oct2(l2c, i);
 }
 
-static int __devinit co_l2c_probe(struct platform_device *pdev)
+static int __devinit octeon_l2c_probe(struct platform_device *pdev)
 {
 	struct edac_device_ctl_info *l2c;
-	union cvmx_l2t_err l2t_err;
-	int res = 0;
 
-	l2c = edac_device_alloc_ctl_info(0, "l2c", 1, NULL, 0, 0,
+	int num_tads = OCTEON_IS_MODEL(OCTEON_CN68XX) ? 4 : 1;
+
+	/* 'Tags' are block 0, 'Data' is block 1*/
+	l2c = edac_device_alloc_ctl_info(0, "l2c", num_tads, "l2c", 2, 0,
 					 NULL, 0, edac_device_alloc_index());
 	if (!l2c)
 		return -ENOMEM;
@@ -55,29 +149,43 @@ static int __devinit co_l2c_probe(struct platform_device *pdev)
 
 	l2c->mod_name = "octeon-l2c";
 	l2c->ctl_name = "octeon_l2c_err";
-	l2c->edac_check = co_l2c_poll;
+
+
+	if (OCTEON_IS_MODEL(OCTEON_FAM_1_PLUS)) {
+		union cvmx_l2t_err l2t_err;
+		union cvmx_l2d_err l2d_err;
+
+		l2t_err.u64 = cvmx_read_csr(CVMX_L2T_ERR);
+		l2t_err.s.sec_intena = 0;	/* We poll */
+		l2t_err.s.ded_intena = 0;
+		cvmx_write_csr(CVMX_L2T_ERR, l2t_err.u64);
+
+		l2d_err.u64 = cvmx_read_csr(CVMX_L2D_ERR);
+		l2d_err.s.sec_intena = 0;	/* We poll */
+		l2d_err.s.ded_intena = 0;
+		cvmx_write_csr(CVMX_L2T_ERR, l2d_err.u64);
+
+		l2c->edac_check = octeon_l2c_poll_oct1;
+	} else {
+		/* OCTEON II */
+		l2c->edac_check = octeon_l2c_poll_oct2;
+	}
 
 	if (edac_device_add_device(l2c) > 0) {
 		pr_err("%s: edac_device_add_device() failed\n", __func__);
 		goto err;
 	}
 
-	l2t_err.u64 = cvmx_read_csr(CVMX_L2T_ERR);
-	l2t_err.s.sec_intena = 0;	/* We poll */
-	l2t_err.s.ded_intena = 0;
-	l2t_err.s.sec_err = 1;		/* Clear, just in case */
-	l2t_err.s.ded_err = 1;
-	cvmx_write_csr(CVMX_L2T_ERR, l2t_err.u64);
 
 	return 0;
 
 err:
 	edac_device_free_ctl_info(l2c);
 
-	return res;
+	return -ENXIO;
 }
 
-static int co_l2c_remove(struct platform_device *pdev)
+static int octeon_l2c_remove(struct platform_device *pdev)
 {
 	struct edac_device_ctl_info *l2c = platform_get_drvdata(pdev);
 
@@ -87,32 +195,14 @@ static int co_l2c_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static struct platform_driver co_l2c_driver = {
-	.probe = co_l2c_probe,
-	.remove = co_l2c_remove,
+static struct platform_driver octeon_l2c_driver = {
+	.probe = octeon_l2c_probe,
+	.remove = octeon_l2c_remove,
 	.driver = {
-		   .name = "co_l2c_edac",
+		   .name = "octeon_l2c_edac",
 	}
 };
-
-static int __init co_edac_init(void)
-{
-	int ret;
-
-	ret = platform_driver_register(&co_l2c_driver);
-	if (ret)
-		pr_warning(EDAC_MOD_STR " EDAC failed to register\n");
-
-	return ret;
-}
-
-static void __exit co_edac_exit(void)
-{
-	platform_driver_unregister(&co_l2c_driver);
-}
-
-module_init(co_edac_init);
-module_exit(co_edac_exit);
+module_platform_driver(octeon_l2c_driver);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Ralf Baechle <ralf@linux-mips.org>");

commit f65aad41772f6a0022e9763fe06f47604449964c
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Oct 17 00:39:09 2012 +0200

    MIPS: Cavium: Add EDAC support.
    
    Drivers for EDAC on Cavium.  Supported subsystems are:
    
     o CPU primary caches.  These are parity protected only, so only error
       reporting.
     o Second level cache - ECC protected, provides SECDED.
     o Memory: ECC / SECDEC if used with suitable DRAM modules.  The driver will
       will only initialize if ECC is enabled on a system so is safe to run on
       non-ECC memory.
     o PCI: Parity error reporting
    
    Since it is very hard to test this sort of code the implementation is very
    conservative and uses polling where possible for now.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Reviewed-by: Borislav Petkov <borislav.petkov@amd.com>

diff --git a/drivers/edac/octeon_edac-l2c.c b/drivers/edac/octeon_edac-l2c.c
new file mode 100644
index 000000000000..5f459aa451bf
--- /dev/null
+++ b/drivers/edac/octeon_edac-l2c.c
@@ -0,0 +1,118 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2009 Wind River Systems,
+ *   written by Ralf Baechle <ralf@linux-mips.org>
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/edac.h>
+
+#include <asm/octeon/cvmx.h>
+
+#include "edac_core.h"
+#include "edac_module.h"
+
+#define EDAC_MOD_STR "octeon-l2c"
+
+static void co_l2c_poll(struct edac_device_ctl_info *l2c)
+{
+	union cvmx_l2t_err l2t_err;
+
+	l2t_err.u64 = cvmx_read_csr(CVMX_L2T_ERR);
+	if (l2t_err.s.sec_err) {
+		edac_device_handle_ce(l2c, 0, 0,
+				      "Single bit error (corrected)");
+		l2t_err.s.sec_err = 1;		/* Reset */
+		cvmx_write_csr(CVMX_L2T_ERR, l2t_err.u64);
+	}
+	if (l2t_err.s.ded_err) {
+		edac_device_handle_ue(l2c, 0, 0,
+				      "Double bit error (corrected)");
+		l2t_err.s.ded_err = 1;		/* Reset */
+		cvmx_write_csr(CVMX_L2T_ERR, l2t_err.u64);
+	}
+}
+
+static int __devinit co_l2c_probe(struct platform_device *pdev)
+{
+	struct edac_device_ctl_info *l2c;
+	union cvmx_l2t_err l2t_err;
+	int res = 0;
+
+	l2c = edac_device_alloc_ctl_info(0, "l2c", 1, NULL, 0, 0,
+					 NULL, 0, edac_device_alloc_index());
+	if (!l2c)
+		return -ENOMEM;
+
+	l2c->dev = &pdev->dev;
+	platform_set_drvdata(pdev, l2c);
+	l2c->dev_name = dev_name(&pdev->dev);
+
+	l2c->mod_name = "octeon-l2c";
+	l2c->ctl_name = "octeon_l2c_err";
+	l2c->edac_check = co_l2c_poll;
+
+	if (edac_device_add_device(l2c) > 0) {
+		pr_err("%s: edac_device_add_device() failed\n", __func__);
+		goto err;
+	}
+
+	l2t_err.u64 = cvmx_read_csr(CVMX_L2T_ERR);
+	l2t_err.s.sec_intena = 0;	/* We poll */
+	l2t_err.s.ded_intena = 0;
+	l2t_err.s.sec_err = 1;		/* Clear, just in case */
+	l2t_err.s.ded_err = 1;
+	cvmx_write_csr(CVMX_L2T_ERR, l2t_err.u64);
+
+	return 0;
+
+err:
+	edac_device_free_ctl_info(l2c);
+
+	return res;
+}
+
+static int co_l2c_remove(struct platform_device *pdev)
+{
+	struct edac_device_ctl_info *l2c = platform_get_drvdata(pdev);
+
+	edac_device_del_device(&pdev->dev);
+	edac_device_free_ctl_info(l2c);
+
+	return 0;
+}
+
+static struct platform_driver co_l2c_driver = {
+	.probe = co_l2c_probe,
+	.remove = co_l2c_remove,
+	.driver = {
+		   .name = "co_l2c_edac",
+	}
+};
+
+static int __init co_edac_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&co_l2c_driver);
+	if (ret)
+		pr_warning(EDAC_MOD_STR " EDAC failed to register\n");
+
+	return ret;
+}
+
+static void __exit co_edac_exit(void)
+{
+	platform_driver_unregister(&co_l2c_driver);
+}
+
+module_init(co_edac_init);
+module_exit(co_edac_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Ralf Baechle <ralf@linux-mips.org>");
