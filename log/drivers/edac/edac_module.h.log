commit bea1bfd5b7226ac7c3f93f76be89221f33222a34
Author: Robert Richter <rrichter@marvell.com>
Date:   Wed Feb 12 13:03:40 2020 +0100

    EDAC/mc: Change mci device removal to use put_device()
    
    There are dimm and csrow devices linked to the mci device esp. to show
    up in sysfs. It must be granted that children devices are removed before
    its mci parent. Thus, the release functions must be called in the
    correct order and may not miss any child before releasing its parent. In
    the current implementation this is only granted by the correct order of
    release functions.
    
    A much better approach is to use put_device() that releases the device
    only after all users are gone. It is the recommended way to release a
    device and free its memory. The function uses the device's refcount and
    only frees it if there are no users of it anymore such as children.
    
    So implement a mci_release() function to remove mci devices, use
    put_device() to free them and early initialize the mci device right
    after its struct has been allocated.
    
    Change the release function so that it can be universally used no
    matter if the device is registered or not. Since subsequent dimm
    and csrow sysfs links are implemented as children devices, their
    refcounts will keep the parent mci device from being removed as long
    as sysfs entries exist and until all users have been unregistered in
    edac_remove_sysfs_mci_device().
    
    Remove edac_unregister_sysfs() and merge mci sysfs removal into
    edac_remove_sysfs_mci_device(). There is only a single instance now that
    removes the sysfs entries. The function can now be used in the error
    paths for cleanup.
    
    Also, create device release functions for all involved devices
    (dev->release), remove device_type release functions (dev_type->
    release) and also use dev->init_name instead of dev_set_name().
    
     [ bp: Massage commit message and comments. ]
    
    Signed-off-by: Robert Richter <rrichter@marvell.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Aristeu Rozanski <aris@redhat.com>
    Link: https://lkml.kernel.org/r/20200212120340.4764-5-rrichter@marvell.com

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 388427d378b1..aa1f91688eb8 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -28,7 +28,6 @@ void edac_mc_sysfs_exit(void);
 extern int edac_create_sysfs_mci_device(struct mem_ctl_info *mci,
 					const struct attribute_group **groups);
 extern void edac_remove_sysfs_mci_device(struct mem_ctl_info *mci);
-void edac_unregister_sysfs(struct mem_ctl_info *mci);
 extern int edac_get_log_ue(void);
 extern int edac_get_log_ce(void);
 extern int edac_get_panic_on_ue(void);

commit 0ecace04a3b8444f3ffa6f18083e98198d9b9ec6
Author: Jan Luebbe <jlu@pengutronix.de>
Date:   Fri Jul 12 05:46:56 2019 +0100

    ARM: 8892/1: EDAC: Add missing debugfs_create_x32 wrapper
    
    We already have wrappers for x8 and x16, so add the missing x32 one.
    
    Signed-off-by: Jan Luebbe <jlu@pengutronix.de>
    Reviewed-by: Borislav Petkov <bp@suse.de>
    Signed-off-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index b2f59ee76c22..388427d378b1 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -82,6 +82,8 @@ void edac_debugfs_create_x8(const char *name, umode_t mode,
 			    struct dentry *parent, u8 *value);
 void edac_debugfs_create_x16(const char *name, umode_t mode,
 			     struct dentry *parent, u16 *value);
+void edac_debugfs_create_x32(const char *name, umode_t mode,
+			     struct dentry *parent, u32 *value);
 #else
 static inline void edac_debugfs_init(void)					{ }
 static inline void edac_debugfs_exit(void)					{ }
@@ -96,6 +98,8 @@ static inline void edac_debugfs_create_x8(const char *name, umode_t mode,
 					  struct dentry *parent, u8 *value)	{ }
 static inline void edac_debugfs_create_x16(const char *name, umode_t mode,
 					   struct dentry *parent, u16 *value)	{ }
+static inline void edac_debugfs_create_x32(const char *name, umode_t mode,
+		       struct dentry *parent, u32 *value)			{ }
 #endif
 
 /*

commit d8655e7630dafa88bc37f101640e39c736399771
Author: Eiichi Tsukata <devel@etsukata.com>
Date:   Wed Jun 26 14:40:11 2019 +0900

    EDAC: Fix global-out-of-bounds write when setting edac_mc_poll_msec
    
    Commit 9da21b1509d8 ("EDAC: Poll timeout cannot be zero, p2") assumes
    edac_mc_poll_msec to be unsigned long, but the type of the variable still
    remained as int. Setting edac_mc_poll_msec can trigger out-of-bounds
    write.
    
    Reproducer:
    
      # echo 1001 > /sys/module/edac_core/parameters/edac_mc_poll_msec
    
    KASAN report:
    
      BUG: KASAN: global-out-of-bounds in edac_set_poll_msec+0x140/0x150
      Write of size 8 at addr ffffffffb91b2d00 by task bash/1996
    
      CPU: 1 PID: 1996 Comm: bash Not tainted 5.2.0-rc6+ #23
      Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-2.fc30 04/01/2014
      Call Trace:
       dump_stack+0xca/0x13e
       print_address_description.cold+0x5/0x246
       __kasan_report.cold+0x75/0x9a
       ? edac_set_poll_msec+0x140/0x150
       kasan_report+0xe/0x20
       edac_set_poll_msec+0x140/0x150
       ? dimmdev_location_show+0x30/0x30
       ? vfs_lock_file+0xe0/0xe0
       ? _raw_spin_lock+0x87/0xe0
       param_attr_store+0x1b5/0x310
       ? param_array_set+0x4f0/0x4f0
       module_attr_store+0x58/0x80
       ? module_attr_show+0x80/0x80
       sysfs_kf_write+0x13d/0x1a0
       kernfs_fop_write+0x2bc/0x460
       ? sysfs_kf_bin_read+0x270/0x270
       ? kernfs_notify+0x1f0/0x1f0
       __vfs_write+0x81/0x100
       vfs_write+0x1e1/0x560
       ksys_write+0x126/0x250
       ? __ia32_sys_read+0xb0/0xb0
       ? do_syscall_64+0x1f/0x390
       do_syscall_64+0xc1/0x390
       entry_SYSCALL_64_after_hwframe+0x49/0xbe
      RIP: 0033:0x7fa7caa5e970
      Code: 73 01 c3 48 8b 0d 28 d5 2b 00 f7 d8 64 89 01 48 83 c8 ff c3 66 0f 1f 44 00 00 83 3d 99 2d 2c 00 00 75 10 b8 01 00 00 00 04
      RSP: 002b:00007fff6acfdfe8 EFLAGS: 00000246 ORIG_RAX: 0000000000000001
      RAX: ffffffffffffffda RBX: 0000000000000005 RCX: 00007fa7caa5e970
      RDX: 0000000000000005 RSI: 0000000000e95c08 RDI: 0000000000000001
      RBP: 0000000000e95c08 R08: 00007fa7cad1e760 R09: 00007fa7cb36a700
      R10: 0000000000000073 R11: 0000000000000246 R12: 0000000000000005
      R13: 0000000000000001 R14: 00007fa7cad1d600 R15: 0000000000000005
    
      The buggy address belongs to the variable:
       edac_mc_poll_msec+0x0/0x40
    
      Memory state around the buggy address:
       ffffffffb91b2c00: 00 00 00 00 fa fa fa fa 00 00 00 00 fa fa fa fa
       ffffffffb91b2c80: 00 00 00 00 fa fa fa fa 00 00 00 00 fa fa fa fa
      >ffffffffb91b2d00: 04 fa fa fa fa fa fa fa 04 fa fa fa fa fa fa fa
                         ^
       ffffffffb91b2d80: 04 fa fa fa fa fa fa fa 00 00 00 00 00 00 00 00
       ffffffffb91b2e00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    
    Fix it by changing the type of edac_mc_poll_msec to unsigned int.
    The reason why this patch adopts unsigned int rather than unsigned long
    is msecs_to_jiffies() assumes arg to be unsigned int. We can avoid
    integer conversion bugs and unsigned int will be large enough for
    edac_mc_poll_msec.
    
    Reviewed-by: James Morse <james.morse@arm.com>
    Fixes: 9da21b1509d8 ("EDAC: Poll timeout cannot be zero, p2")
    Signed-off-by: Eiichi Tsukata <devel@etsukata.com>
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index bc4b806dc9cc..b2f59ee76c22 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -36,7 +36,7 @@ extern int edac_mc_get_log_ue(void);
 extern int edac_mc_get_log_ce(void);
 extern int edac_mc_get_panic_on_ue(void);
 extern int edac_get_poll_msec(void);
-extern int edac_mc_get_poll_msec(void);
+extern unsigned int edac_mc_get_poll_msec(void);
 
 unsigned edac_dimm_info_location(struct dimm_info *dimm, char *buf,
 				 unsigned len);

commit 40d796243478e0d072a7e637e7558c3c8216b60a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Jun 11 19:54:33 2019 +0200

    EDAC: Make edac_debugfs_create_x*() return void
    
    The return values of edac_debugfs_create_x16() and
    edac_debugfs_create_x8() are never checked (as they don't need to be),
    so no need to have them return anything, just make the functions return
    void instead.
    
    This is done with the goal of being able to change the debugfs_create_x*
    functions to also not return a value.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Link: https://lkml.kernel.org/r/20190611175433.GA5108@kroah.com

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index dd7d0b509aa3..bc4b806dc9cc 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -78,10 +78,10 @@ edac_debugfs_create_dir_at(const char *dirname, struct dentry *parent);
 struct dentry *
 edac_debugfs_create_file(const char *name, umode_t mode, struct dentry *parent,
 			 void *data, const struct file_operations *fops);
-struct dentry *
-edac_debugfs_create_x8(const char *name, umode_t mode, struct dentry *parent, u8 *value);
-struct dentry *
-edac_debugfs_create_x16(const char *name, umode_t mode, struct dentry *parent, u16 *value);
+void edac_debugfs_create_x8(const char *name, umode_t mode,
+			    struct dentry *parent, u8 *value);
+void edac_debugfs_create_x16(const char *name, umode_t mode,
+			     struct dentry *parent, u16 *value);
 #else
 static inline void edac_debugfs_init(void)					{ }
 static inline void edac_debugfs_exit(void)					{ }
@@ -92,12 +92,10 @@ edac_debugfs_create_dir_at(const char *dirname, struct dentry *parent)		{ return
 static inline struct dentry *
 edac_debugfs_create_file(const char *name, umode_t mode, struct dentry *parent,
 			 void *data, const struct file_operations *fops)	{ return NULL; }
-static inline struct dentry *
-edac_debugfs_create_x8(const char *name, umode_t mode,
-		       struct dentry *parent, u8 *value)			{ return NULL; }
-static inline struct dentry *
-edac_debugfs_create_x16(const char *name, umode_t mode,
-		       struct dentry *parent, u16 *value)			{ return NULL; }
+static inline void edac_debugfs_create_x8(const char *name, umode_t mode,
+					  struct dentry *parent, u8 *value)	{ }
+static inline void edac_debugfs_create_x16(const char *name, umode_t mode,
+					   struct dentry *parent, u16 *value)	{ }
 #endif
 
 /*

commit 912ebd99edfa1d1695083fa6d34ac878346ac66b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Jan 22 16:21:16 2019 +0100

    EDAC: Do not check return value of debugfs_create() functions
    
    When calling debugfs functions, there is no need to ever check the
    return value. The function can work or not, but the code logic should
    never do something different based on this.
    
     [ bp: Make edac_debugfs_init() return void too, while at it. ]
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: James Morse <james.morse@arm.com>
    Cc: Mauro Carvalho Chehab <mchehab@kernel.org>
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Link: https://lkml.kernel.org/r/20190122152151.16139-17-gregkh@linuxfoundation.org

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index dec88dcea036..dd7d0b509aa3 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -69,9 +69,9 @@ extern void *edac_align_ptr(void **p, unsigned size, int n_elems);
 #define edac_debugfs_remove_recursive debugfs_remove_recursive
 #define edac_debugfs_remove debugfs_remove
 #ifdef CONFIG_EDAC_DEBUG
-int edac_debugfs_init(void);
+void edac_debugfs_init(void);
 void edac_debugfs_exit(void);
-int edac_create_debugfs_nodes(struct mem_ctl_info *mci);
+void edac_create_debugfs_nodes(struct mem_ctl_info *mci);
 struct dentry *edac_debugfs_create_dir(const char *dirname);
 struct dentry *
 edac_debugfs_create_dir_at(const char *dirname, struct dentry *parent);
@@ -83,9 +83,9 @@ edac_debugfs_create_x8(const char *name, umode_t mode, struct dentry *parent, u8
 struct dentry *
 edac_debugfs_create_x16(const char *name, umode_t mode, struct dentry *parent, u16 *value);
 #else
-static inline int edac_debugfs_init(void)					{ return -ENODEV; }
+static inline void edac_debugfs_init(void)					{ }
 static inline void edac_debugfs_exit(void)					{ }
-static inline int edac_create_debugfs_nodes(struct mem_ctl_info *mci)		{ return 0; }
+static inline void edac_create_debugfs_nodes(struct mem_ctl_info *mci)		{ }
 static inline struct dentry *edac_debugfs_create_dir(const char *dirname)	{ return NULL; }
 static inline struct dentry *
 edac_debugfs_create_dir_at(const char *dirname, struct dentry *parent)		{ return NULL; }

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 014871e169cc..dec88dcea036 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 
 /*
  * edac_module.h

commit 78d88e8a3d738f1ce508cd24b525d2e6cdfda1c1
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Sat Oct 29 15:16:34 2016 -0200

    edac: rename edac_core.h to edac_mc.h
    
    Now, all left at edac_core.h are at drivers/edac/edac_mc.c,
    so rename it to edac_mc.h.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index cfaacb99c973..014871e169cc 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -10,7 +10,9 @@
 #ifndef	__EDAC_MODULE_H__
 #define	__EDAC_MODULE_H__
 
-#include "edac_core.h"
+#include "edac_mc.h"
+#include "edac_pci.h"
+#include "edac_device.h"
 
 /*
  * INTERNAL EDAC MODULE:

commit c4cf3b454ecaa222aad9017932bd3b9c9325d931
Author: Borislav Petkov <bp@suse.de>
Date:   Mon Nov 30 19:02:01 2015 +0100

    EDAC: Rework workqueue handling
    
    Hide the EDAC workqueue pointer in a separate compilation unit and add
    accessors for the workqueue manipulations needed.
    
    Remove edac_pci_reset_delay_period() which wasn't used by anything. It
    seems it got added without a user with
    
      91b99041c1d5 ("drivers/edac: updated PCI monitoring")
    
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 7388abfbf10b..cfaacb99c973 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -47,7 +47,12 @@ extern int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev);
 extern void edac_device_remove_sysfs(struct edac_device_ctl_info *edac_dev);
 
 /* edac core workqueue: single CPU mode */
-extern struct workqueue_struct *edac_workqueue;
+int edac_workqueue_setup(void);
+void edac_workqueue_teardown(void);
+bool edac_queue_work(struct delayed_work *work, unsigned long delay);
+bool edac_stop_work(struct delayed_work *work);
+bool edac_mod_work(struct delayed_work *work, unsigned long delay);
+
 extern void edac_device_reset_delay_period(struct edac_device_ctl_info
 					   *edac_dev, unsigned long value);
 extern void edac_mc_reset_delay_period(unsigned long value);

commit e136fa016f2f06ca6e00d4f99894b4424f3f2a5c
Author: Borislav Petkov <bp@suse.de>
Date:   Mon Nov 30 15:07:28 2015 +0100

    EDAC: Make edac_device workqueue setup/teardown functions static
    
    They're not used anywhere else.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index b95a48fc723d..7388abfbf10b 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -48,9 +48,6 @@ extern void edac_device_remove_sysfs(struct edac_device_ctl_info *edac_dev);
 
 /* edac core workqueue: single CPU mode */
 extern struct workqueue_struct *edac_workqueue;
-extern void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
-				    unsigned msec);
-extern void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev);
 extern void edac_device_reset_delay_period(struct edac_device_ctl_info
 					   *edac_dev, unsigned long value);
 extern void edac_mc_reset_delay_period(unsigned long value);

commit 4397bcb4fa1dd285a2c6d583d1f1cbc6bd423f97
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Sep 22 12:16:05 2015 +0200

    EDAC: Add debugfs wrappers
    
    Later patches will convert EDAC users to those.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 79a6c6e20819..b95a48fc723d 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -60,17 +60,39 @@ extern void *edac_align_ptr(void **p, unsigned size, int n_elems);
 /*
  * EDAC debugfs functions
  */
+
+#define edac_debugfs_remove_recursive debugfs_remove_recursive
+#define edac_debugfs_remove debugfs_remove
 #ifdef CONFIG_EDAC_DEBUG
 int edac_debugfs_init(void);
 void edac_debugfs_exit(void);
 int edac_create_debugfs_nodes(struct mem_ctl_info *mci);
+struct dentry *edac_debugfs_create_dir(const char *dirname);
+struct dentry *
+edac_debugfs_create_dir_at(const char *dirname, struct dentry *parent);
+struct dentry *
+edac_debugfs_create_file(const char *name, umode_t mode, struct dentry *parent,
+			 void *data, const struct file_operations *fops);
+struct dentry *
+edac_debugfs_create_x8(const char *name, umode_t mode, struct dentry *parent, u8 *value);
+struct dentry *
+edac_debugfs_create_x16(const char *name, umode_t mode, struct dentry *parent, u16 *value);
 #else
-static inline int edac_debugfs_init(void)
-{
-	return -ENODEV;
-}
-static inline void edac_debugfs_exit(void) {}
-static inline int edac_create_debugfs_nodes(struct mem_ctl_info *mci) { return 0; }
+static inline int edac_debugfs_init(void)					{ return -ENODEV; }
+static inline void edac_debugfs_exit(void)					{ }
+static inline int edac_create_debugfs_nodes(struct mem_ctl_info *mci)		{ return 0; }
+static inline struct dentry *edac_debugfs_create_dir(const char *dirname)	{ return NULL; }
+static inline struct dentry *
+edac_debugfs_create_dir_at(const char *dirname, struct dentry *parent)		{ return NULL; }
+static inline struct dentry *
+edac_debugfs_create_file(const char *name, umode_t mode, struct dentry *parent,
+			 void *data, const struct file_operations *fops)	{ return NULL; }
+static inline struct dentry *
+edac_debugfs_create_x8(const char *name, umode_t mode,
+		       struct dentry *parent, u8 *value)			{ return NULL; }
+static inline struct dentry *
+edac_debugfs_create_x16(const char *name, umode_t mode,
+		       struct dentry *parent, u16 *value)			{ return NULL; }
 #endif
 
 /*

commit 7ac8bf9bc9ba82aea763ef30671a34c6a2a39922
Author: Borislav Petkov <bp@suse.de>
Date:   Tue Sep 22 11:56:04 2015 +0200

    EDAC: Carve out debugfs functionality
    
    ... into a separate compilation unit and drop a couple of
    CONFIG_EDAC_DEBUG ifdefferies. Rename edac_create_debug_nodes() to
    edac_create_debugfs_nodes(), while at it.
    
    No functionality change.
    
    Cc: <linux-edac@vger.kernel.org>
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 26ecc52e073d..79a6c6e20819 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -63,12 +63,14 @@ extern void *edac_align_ptr(void **p, unsigned size, int n_elems);
 #ifdef CONFIG_EDAC_DEBUG
 int edac_debugfs_init(void);
 void edac_debugfs_exit(void);
+int edac_create_debugfs_nodes(struct mem_ctl_info *mci);
 #else
 static inline int edac_debugfs_init(void)
 {
 	return -ENODEV;
 }
 static inline void edac_debugfs_exit(void) {}
+static inline int edac_create_debugfs_nodes(struct mem_ctl_info *mci) { return 0; }
 #endif
 
 /*

commit 4e8d230de9c1dff8e587ae769e46fcddb3d98f1c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Wed Feb 4 11:48:52 2015 +0100

    EDAC: Allow to pass driver-specific attribute groups
    
    Add edac_mc_add_mc_with_groups() for initializing the mem_ctl_info
    object with the optional attribute groups.  This allows drivers to
    pass additional sysfs entries without manual (and racy)
    device_create_file() and co calls.
    
    edac_mc_add_mc() is kept as is, just calling edac_mc_add_with_groups()
    with NULL groups.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Link: http://lkml.kernel.org/r/1423046938-18111-3-git-send-email-tiwai@suse.de
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index f2118bfcf8df..26ecc52e073d 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -22,7 +22,8 @@
 	/* on edac_mc_sysfs.c */
 int edac_mc_sysfs_init(void);
 void edac_mc_sysfs_exit(void);
-extern int edac_create_sysfs_mci_device(struct mem_ctl_info *mci);
+extern int edac_create_sysfs_mci_device(struct mem_ctl_info *mci,
+					const struct attribute_group **groups);
 extern void edac_remove_sysfs_mci_device(struct mem_ctl_info *mci);
 void edac_unregister_sysfs(struct mem_ctl_info *mci);
 extern int edac_get_log_ue(void);

commit 9da21b1509d8aa7ab4846722817d16c72d656c91
Author: Borislav Petkov <bp@suse.de>
Date:   Mon Feb 3 15:05:13 2014 -0500

    EDAC: Poll timeout cannot be zero, p2
    
    Sanitize code even more to accept unsigned longs only and to not allow
    polling intervals below 1 second as this is unnecessary and doesn't make
    much sense anyway for polling errors.
    
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Link: http://lkml.kernel.org/r/1391457913-881-1-git-send-email-prarit@redhat.com
    Cc: Doug Thompson <dougthompson@xmission.com>
    Cc: <stable@vger.kernel.org>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 3d139c6e7fe3..f2118bfcf8df 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -52,7 +52,7 @@ extern void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
 extern void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev);
 extern void edac_device_reset_delay_period(struct edac_device_ctl_info
 					   *edac_dev, unsigned long value);
-extern void edac_mc_reset_delay_period(int value);
+extern void edac_mc_reset_delay_period(unsigned long value);
 
 extern void *edac_align_ptr(void **p, unsigned size, int n_elems);
 

commit e7930ba49e469d9ce7374a788336caf955f8d7e2
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Mon Jun 11 21:32:12 2012 -0500

    edac: create top-level debugfs directory
    
    Create a single, top-level "edac" directory for debugfs. An "mc[0-N]"
    directory is then created for each memory controller. Individual drivers
    can create additional entries such as h/w error injection control.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 62de640c8c8a..3d139c6e7fe3 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -56,6 +56,20 @@ extern void edac_mc_reset_delay_period(int value);
 
 extern void *edac_align_ptr(void **p, unsigned size, int n_elems);
 
+/*
+ * EDAC debugfs functions
+ */
+#ifdef CONFIG_EDAC_DEBUG
+int edac_debugfs_init(void);
+void edac_debugfs_exit(void);
+#else
+static inline int edac_debugfs_init(void)
+{
+	return -ENODEV;
+}
+static inline void edac_debugfs_exit(void) {}
+#endif
+
 /*
  * EDAC PCI functions
  */

commit 6e84d359b2bea5ce659b3c3e5d3003fb11bd91d5
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Apr 30 10:24:43 2012 -0300

    edac_mc: Cleanup per-dimm_info debug messages
    
    The edac_mc_alloc() routine allocates one dimm_info device for all
    possible memories, including the non-filled ones. The debug messages
    there are somewhat confusing. So, cleans them, by moving the code
    that prints the memory location to edac_mc, and using it on both
    edac_mc_sysfs and edac_mc.
    
    Also, only dumps information when DIMM/ranks are actually
    filled.
    
    After this patch, a dimm-based memory controller will print the debug
    info as:
    
    [ 1011.380027] EDAC DEBUG: edac_mc_dump_csrow: csrow->csrow_idx = 0
    [ 1011.380029] EDAC DEBUG: edac_mc_dump_csrow:   csrow = ffff8801169be000
    [ 1011.380031] EDAC DEBUG: edac_mc_dump_csrow:   csrow->first_page = 0x0
    [ 1011.380032] EDAC DEBUG: edac_mc_dump_csrow:   csrow->last_page = 0x0
    [ 1011.380034] EDAC DEBUG: edac_mc_dump_csrow:   csrow->page_mask = 0x0
    [ 1011.380035] EDAC DEBUG: edac_mc_dump_csrow:   csrow->nr_channels = 3
    [ 1011.380037] EDAC DEBUG: edac_mc_dump_csrow:   csrow->channels = ffff8801149c2840
    [ 1011.380039] EDAC DEBUG: edac_mc_dump_csrow:   csrow->mci = ffff880117426000
    [ 1011.380041] EDAC DEBUG: edac_mc_dump_channel:   channel->chan_idx = 0
    [ 1011.380042] EDAC DEBUG: edac_mc_dump_channel:     channel = ffff8801149c2860
    [ 1011.380044] EDAC DEBUG: edac_mc_dump_channel:     channel->csrow = ffff8801169be000
    [ 1011.380046] EDAC DEBUG: edac_mc_dump_channel:     channel->dimm = ffff88010fe90400
    ...
    [ 1011.380095] EDAC DEBUG: edac_mc_dump_dimm: dimm0: channel 0 slot 0 mapped as virtual row 0, chan 0
    [ 1011.380097] EDAC DEBUG: edac_mc_dump_dimm:   dimm = ffff88010fe90400
    [ 1011.380099] EDAC DEBUG: edac_mc_dump_dimm:   dimm->label = 'CPU#0Channel#0_DIMM#0'
    [ 1011.380101] EDAC DEBUG: edac_mc_dump_dimm:   dimm->nr_pages = 0x40000
    [ 1011.380103] EDAC DEBUG: edac_mc_dump_dimm:   dimm->grain = 8
    [ 1011.380104] EDAC DEBUG: edac_mc_dump_dimm:   dimm->nr_pages = 0x40000
    ...
    
    (a rank-based memory controller would print, instead of "dimm?", "rank?"
     on the above debug info)
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 1af13676e857..62de640c8c8a 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -34,6 +34,9 @@ extern int edac_mc_get_panic_on_ue(void);
 extern int edac_get_poll_msec(void);
 extern int edac_mc_get_poll_msec(void);
 
+unsigned edac_dimm_info_location(struct dimm_info *dimm, char *buf,
+				 unsigned len);
+
 	/* on edac_device.c */
 extern int edac_device_register_sysfs_main_kobj(
 				struct edac_device_ctl_info *edac_dev);

commit 7a623c039075e4ea21648d88133fafa6dcfd113d
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Apr 16 16:41:11 2012 -0300

    edac: rewrite the sysfs code to use struct device
    
    The EDAC subsystem uses the old struct sysdev approach,
    creating all nodes using the raw sysfs API. This is bad,
    as the API is deprecated.
    
    As we'll be changing the EDAC API, let's first port the existing
    code to struct device.
    
    There's one drawback on this patch: driver-specific sysfs
    nodes, used by mpc85xx_edac, amd64_edac and i7core_edac
     won't be created anymore. While it would be possible to
    also port the device-specific code, that would mix kobj with
    struct device, with is not recommended. Also, it is easier and nicer
    to move the code to the drivers, instead, as the core can get rid
    of some complex logic that just emulates what the device_add()
    and device_create_file() already does.
    
    The next patches will convert the driver-specific code to use
    the device-specific calls. Then, the remaining bits of the old
    sysfs API will be removed.
    
    NOTE: a per-MC bus is required, otherwise devices with more than
    one memory controller will hit a bug like the one below:
    
    [  819.094946] EDAC DEBUG: find_mci_by_dev: find_mci_by_dev()
    [  819.094948] EDAC DEBUG: edac_create_sysfs_mci_device: edac_create_sysfs_mci_device() idx=1
    [  819.094952] EDAC DEBUG: edac_create_sysfs_mci_device: edac_create_sysfs_mci_device(): creating device mc1
    [  819.094967] EDAC DEBUG: edac_create_sysfs_mci_device: edac_create_sysfs_mci_device creating dimm0, located at channel 0 slot 0
    [  819.094984] ------------[ cut here ]------------
    [  819.100142] WARNING: at fs/sysfs/dir.c:481 sysfs_add_one+0xc1/0xf0()
    [  819.107282] Hardware name: S2600CP
    [  819.111078] sysfs: cannot create duplicate filename '/bus/edac/devices/dimm0'
    [  819.119062] Modules linked in: sb_edac(+) edac_core ip6table_filter ip6_tables ebtable_nat ebtables ipt_MASQUERADE iptable_nat nf_nat nf_conntrack_ipv4 nf_defrag_ipv4 xt_state nf_conntrack ipt_REJECT xt_CHECKSUM iptable_mangle iptable_filter ip_tables bridge stp llc sunrpc binfmt_misc dm_mirror dm_region_hash dm_log vhost_net macvtap macvlan tun kvm microcode pcspkr iTCO_wdt iTCO_vendor_support igb i2c_i801 i2c_core sg ioatdma dca sr_mod cdrom sd_mod crc_t10dif ahci libahci isci libsas libata scsi_transport_sas scsi_mod wmi dm_mod [last unloaded: scsi_wait_scan]
    [  819.175748] Pid: 10902, comm: modprobe Not tainted 3.3.0-0.11.el7.v12.2.x86_64 #1
    [  819.184113] Call Trace:
    [  819.186868]  [<ffffffff8105adaf>] warn_slowpath_common+0x7f/0xc0
    [  819.193573]  [<ffffffff8105aea6>] warn_slowpath_fmt+0x46/0x50
    [  819.200000]  [<ffffffff811f53d1>] sysfs_add_one+0xc1/0xf0
    [  819.206025]  [<ffffffff811f5cf5>] sysfs_do_create_link+0x135/0x220
    [  819.212944]  [<ffffffff811f7023>] ? sysfs_create_group+0x13/0x20
    [  819.219656]  [<ffffffff811f5df3>] sysfs_create_link+0x13/0x20
    [  819.226109]  [<ffffffff813b04f6>] bus_add_device+0xe6/0x1b0
    [  819.232350]  [<ffffffff813ae7cb>] device_add+0x2db/0x460
    [  819.238300]  [<ffffffffa0325634>] edac_create_dimm_object+0x84/0xf0 [edac_core]
    [  819.246460]  [<ffffffffa0325e18>] edac_create_sysfs_mci_device+0xe8/0x290 [edac_core]
    [  819.255215]  [<ffffffffa0322e2a>] edac_mc_add_mc+0x5a/0x2c0 [edac_core]
    [  819.262611]  [<ffffffffa03412df>] sbridge_register_mci+0x1bc/0x279 [sb_edac]
    [  819.270493]  [<ffffffffa03417a3>] sbridge_probe+0xef/0x175 [sb_edac]
    [  819.277630]  [<ffffffff813ba4e8>] ? pm_runtime_enable+0x58/0x90
    [  819.284268]  [<ffffffff812f430c>] local_pci_probe+0x5c/0xd0
    [  819.290508]  [<ffffffff812f5ba1>] __pci_device_probe+0xf1/0x100
    [  819.297117]  [<ffffffff812f5bea>] pci_device_probe+0x3a/0x60
    [  819.303457]  [<ffffffff813b1003>] really_probe+0x73/0x270
    [  819.309496]  [<ffffffff813b138e>] driver_probe_device+0x4e/0xb0
    [  819.316104]  [<ffffffff813b149b>] __driver_attach+0xab/0xb0
    [  819.322337]  [<ffffffff813b13f0>] ? driver_probe_device+0xb0/0xb0
    [  819.329151]  [<ffffffff813af5d6>] bus_for_each_dev+0x56/0x90
    [  819.335489]  [<ffffffff813b0d7e>] driver_attach+0x1e/0x20
    [  819.341534]  [<ffffffff813b0980>] bus_add_driver+0x1b0/0x2a0
    [  819.347884]  [<ffffffffa0347000>] ? 0xffffffffa0346fff
    [  819.353641]  [<ffffffff813b19f6>] driver_register+0x76/0x140
    [  819.359980]  [<ffffffff8159f18b>] ? printk+0x51/0x53
    [  819.365524]  [<ffffffffa0347000>] ? 0xffffffffa0346fff
    [  819.371291]  [<ffffffff812f5896>] __pci_register_driver+0x56/0xd0
    [  819.378096]  [<ffffffffa0347054>] sbridge_init+0x54/0x1000 [sb_edac]
    [  819.385231]  [<ffffffff8100203f>] do_one_initcall+0x3f/0x170
    [  819.391577]  [<ffffffff810bcd2e>] sys_init_module+0xbe/0x230
    [  819.397926]  [<ffffffff815bb529>] system_call_fastpath+0x16/0x1b
    [  819.404633] ---[ end trace 1654fdd39556689f ]---
    
    This happens because the bus is not being properly initialized.
    Instead of putting the memory sub-devices inside the memory controller,
    it is putting everything under the same directory:
    
    $ tree /sys/bus/edac/
    /sys/bus/edac/
    ├── devices
    │   ├── all_channel_counts -> ../../../devices/system/edac/mc/mc0/all_channel_counts
    │   ├── csrow0 -> ../../../devices/system/edac/mc/mc0/csrow0
    │   ├── csrow1 -> ../../../devices/system/edac/mc/mc0/csrow1
    │   ├── csrow2 -> ../../../devices/system/edac/mc/mc0/csrow2
    │   ├── dimm0 -> ../../../devices/system/edac/mc/mc0/dimm0
    │   ├── dimm1 -> ../../../devices/system/edac/mc/mc0/dimm1
    │   ├── dimm3 -> ../../../devices/system/edac/mc/mc0/dimm3
    │   ├── dimm6 -> ../../../devices/system/edac/mc/mc0/dimm6
    │   ├── inject_addrmatch -> ../../../devices/system/edac/mc/mc0/inject_addrmatch
    │   ├── mc -> ../../../devices/system/edac/mc
    │   └── mc0 -> ../../../devices/system/edac/mc/mc0
    ├── drivers
    ├── drivers_autoprobe
    ├── drivers_probe
    └── uevent
    
    On a multi-memory controller system, the names "csrow%d" and "dimm%d"
    should be under "mc%d", and not at the main hierarchy level.
    
    So, we need to create a per-MC bus, in order to have its own namespace.
    
    Reviewed-by: Aristeu Rozanski <arozansk@redhat.com>
    Cc: Doug Thompson <norsk5@yahoo.com>
    Cc: Greg K H <gregkh@linuxfoundation.org>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 0ea7d14cb930..1af13676e857 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -19,12 +19,12 @@
  *
  * edac_mc objects
  */
-extern int edac_sysfs_setup_mc_kset(void);
-extern void edac_sysfs_teardown_mc_kset(void);
-extern int edac_mc_register_sysfs_main_kobj(struct mem_ctl_info *mci);
-extern void edac_mc_unregister_sysfs_main_kobj(struct mem_ctl_info *mci);
+	/* on edac_mc_sysfs.c */
+int edac_mc_sysfs_init(void);
+void edac_mc_sysfs_exit(void);
 extern int edac_create_sysfs_mci_device(struct mem_ctl_info *mci);
 extern void edac_remove_sysfs_mci_device(struct mem_ctl_info *mci);
+void edac_unregister_sysfs(struct mem_ctl_info *mci);
 extern int edac_get_log_ue(void);
 extern int edac_get_log_ce(void);
 extern int edac_get_panic_on_ue(void);
@@ -34,6 +34,7 @@ extern int edac_mc_get_panic_on_ue(void);
 extern int edac_get_poll_msec(void);
 extern int edac_mc_get_poll_msec(void);
 
+	/* on edac_device.c */
 extern int edac_device_register_sysfs_main_kobj(
 				struct edac_device_ctl_info *edac_dev);
 extern void edac_device_unregister_sysfs_main_kobj(

commit 93e4fe64ece4eccf0ff4ac69bceb389290b8ab7c
Author: Mauro Carvalho Chehab <mchehab@redhat.com>
Date:   Mon Apr 16 10:18:12 2012 -0300

    edac: rewrite edac_align_ptr()
    
    The edac_align_ptr() function is used to prepare data for a single
    memory allocation kzalloc() call. It counts how many bytes are needed
    by some data structure.
    
    Using it as-is is not that trivial, as the quantity of memory elements
    reserved is not there, but, instead, it is on a next call.
    
    In order to avoid mistakes when using it, move the number of allocated
    elements into it, making easier to use it.
    
    Reviewed-by: Borislav Petkov <bp@amd64.org>
    Cc: Aristeu Rozanski <arozansk@redhat.com>
    Cc: Doug Thompson <norsk5@yahoo.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 00f81b47a51f..0ea7d14cb930 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -50,7 +50,7 @@ extern void edac_device_reset_delay_period(struct edac_device_ctl_info
 					   *edac_dev, unsigned long value);
 extern void edac_mc_reset_delay_period(int value);
 
-extern void *edac_align_ptr(void *ptr, unsigned size);
+extern void *edac_align_ptr(void **p, unsigned size, int n_elems);
 
 /*
  * EDAC PCI functions

commit fe5ff8b84c8b03348a2f64ea9d884348faec2217
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Dec 14 15:21:07 2011 -0800

    edac: convert sysdev_class to a regular subsystem
    
    After all sysdev classes are ported to regular driver core entities, the
    sysdev implementation will be entirely removed from the kernel.
    
    Cc: Doug Thompson <dougthompson@xmission.com>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Lucas De Marchi <lucas.demarchi@profusion.mobi>
    Cc: Borislav Petkov <borislav.petkov@amd.com>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 17aabb7b90ec..00f81b47a51f 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -10,8 +10,6 @@
 #ifndef	__EDAC_MODULE_H__
 #define	__EDAC_MODULE_H__
 
-#include <linux/sysdev.h>
-
 #include "edac_core.h"
 
 /*

commit 30e1f7a8122145f44f45c95366e27b6bb0b08428
Author: Borislav Petkov <borislav.petkov@amd.com>
Date:   Thu Sep 2 17:26:48 2010 +0200

    EDAC: Export edac sysfs class to users.
    
    Move toplevel sysfs class to the stub and make it available to
    non-modularized code too. Add proper refcounting of its users and move
    the registration functionality into the reference counting routines.
    
    Signed-off-by: Borislav Petkov <borislav.petkov@amd.com>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 233d4798c3aa..17aabb7b90ec 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -42,7 +42,6 @@ extern void edac_device_unregister_sysfs_main_kobj(
 				struct edac_device_ctl_info *edac_dev);
 extern int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev);
 extern void edac_device_remove_sysfs(struct edac_device_ctl_info *edac_dev);
-extern struct sysdev_class *edac_get_edac_class(void);
 
 /* edac core workqueue: single CPU mode */
 extern struct workqueue_struct *edac_workqueue;

commit 1a45027d1afd7e85254b5ef8535e93ce3d588cf4
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Apr 29 01:03:18 2008 -0700

    edac: remove unneeded functions and add static accessor
    
    Collection of patches, merged into one, from Adrian that do the following:
    
    1) This patch makes the following needlessly global functions static:
    - edac_pci_get_log_pe()
    - edac_pci_get_log_npe()
    - edac_pci_get_panic_on_pe()
    - edac_pci_unregister_sysfs_instance_kobj()
    - edac_pci_main_kobj_setup()
    
    2) Remove unneeded function edac_device_find()
    
    3) Added #if 0 around function  edac_pci_find()
    
    4) make the needlessly global edac_pci_generic_check() static
    
    5) Removed function edac_check_mc_devices()
    
    Doug Thompson modified Adrian's patches, to bettern represent
    the direction of EDAC, and make them one patch.
    
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Doug Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index cbc419c8ebc1..233d4798c3aa 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -27,7 +27,6 @@ extern int edac_mc_register_sysfs_main_kobj(struct mem_ctl_info *mci);
 extern void edac_mc_unregister_sysfs_main_kobj(struct mem_ctl_info *mci);
 extern int edac_create_sysfs_mci_device(struct mem_ctl_info *mci);
 extern void edac_remove_sysfs_mci_device(struct mem_ctl_info *mci);
-extern void edac_check_mc_devices(void);
 extern int edac_get_log_ue(void);
 extern int edac_get_log_ce(void);
 extern int edac_get_panic_on_ue(void);

commit d4c1465b7de9686c4c5aa533b15c09ab014aab3a
Author: Doug Thompson <dougthompson@xmission.com>
Date:   Thu Jul 26 10:41:15 2007 -0700

    drivers/edac: fix edac_pci sysfs
    
    This patch fixes sysfs exit code for the EDAC PCI device in a similiar manner
    and the previous fixes for EDAC_MC and EDAC_DEVICE.
    
    It removes the old (and incorrect) completion model and uses reference counts
    on per instance kobjects and on the edac core module.
    
    This pattern was applied to the edac_mc and edac_device code, but the EDAC PCI
    code was missed.  In addition, this fixes a system hang after a low level
    driver was unloaded.  (A cleanup function was called twice, which really
    screwed things up)
    
    Cc: Greg KH <greg@kroah.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by:  Doug Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 3664ae9ccd63..cbc419c8ebc1 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -66,6 +66,10 @@ extern int edac_sysfs_pci_setup(void);
 extern void edac_sysfs_pci_teardown(void);
 extern int edac_pci_get_check_errors(void);
 extern int edac_pci_get_poll_msec(void);
+extern void edac_pci_remove_sysfs(struct edac_pci_ctl_info *pci);
+extern void edac_pci_handle_pe(struct edac_pci_ctl_info *pci, const char *msg);
+extern void edac_pci_handle_npe(struct edac_pci_ctl_info *pci,
+				const char *msg);
 #else				/* CONFIG_PCI */
 /* pre-process these away */
 #define edac_pci_do_parity_check()
@@ -74,6 +78,8 @@ extern int edac_pci_get_poll_msec(void);
 #define edac_sysfs_pci_teardown()
 #define edac_pci_get_check_errors()
 #define edac_pci_get_poll_msec()
+#define edac_pci_handle_pe()
+#define edac_pci_handle_npe()
 #endif				/* CONFIG_PCI */
 
 #endif				/* __EDAC_MODULE_H__ */

commit bce19683c17485b584b62b984d6dcf5332181588
Author: Doug Thompson <dougthompson@xmission.com>
Date:   Thu Jul 26 10:41:14 2007 -0700

    drivers/edac: fix reset edac_mc pollmsec
    
    This fixes a deadlock that could occur on a 'setup' and 'teardown' sequence of
    the workq for a edac_mc control structure instance.  A similiar fix was
    previously implemented for the edac_device code.
    
    In addition, the edac_mc device code there was missing code to allow the workq
    period valu to be altered via sysfs control.
    
    This patch adds that fix on the code, and allows for the changing of the
    period value as well.
    
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Doug Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index a2134dfc3cc6..3664ae9ccd63 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -52,6 +52,8 @@ extern void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
 extern void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev);
 extern void edac_device_reset_delay_period(struct edac_device_ctl_info
 					   *edac_dev, unsigned long value);
+extern void edac_mc_reset_delay_period(int value);
+
 extern void *edac_align_ptr(void *ptr, unsigned size);
 
 /*

commit 1c3631ff1f805cb72644fcde02b7c58950f21cd5
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:29 2007 -0700

    drivers/edac: fix edac_device sysfs completion code
    
    With feedback, this patch corrects operation of the kobject release operation
    on kobjects, attributes and controls for the edac_device.
    
    Cc: Alan Cox alan@lxorguk.ukuu.org.uk
    Signed-off-by: Doug Thompson <dougthompson@xmission.com>
    Acked-by: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 6368cc658fc6..a2134dfc3cc6 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -37,6 +37,10 @@ extern int edac_mc_get_panic_on_ue(void);
 extern int edac_get_poll_msec(void);
 extern int edac_mc_get_poll_msec(void);
 
+extern int edac_device_register_sysfs_main_kobj(
+				struct edac_device_ctl_info *edac_dev);
+extern void edac_device_unregister_sysfs_main_kobj(
+				struct edac_device_ctl_info *edac_dev);
 extern int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev);
 extern void edac_device_remove_sysfs(struct edac_device_ctl_info *edac_dev);
 extern struct sysdev_class *edac_get_edac_class(void);

commit 8096cfafbb7ad3cb1a286ae7e8086167f4ebb4b6
Author: Doug Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:27 2007 -0700

    drivers/edac: fix edac_mc sysfs completion code
    
    This patch refactors the 'releasing' of kobjects for the edac_mc type of
    device.  The correct pattern of kobject release is followed.
    
    As internal kobjs are allocated they bump a ref count on the top level kobj.
    It in turn has a module ref count on the edac_core module.  When internal
    kobjects are released, they dec the ref count on the top level kobj.  When the
    top level kobj reaches zero, it decrements the ref count on the edac_core
    object, allow it to be unloaded, as all resources have all now been released.
    
    Cc: Alan Cox alan@lxorguk.ukuu.org.uk
    Signed-off-by: Doug Thompson <dougthompson@xmission.com>
    Acked-by: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 37a08aa87d3e..6368cc658fc6 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -18,11 +18,15 @@
  * INTERNAL EDAC MODULE:
  * EDAC memory controller sysfs create/remove functions
  * and setup/teardown functions
+ *
+ * edac_mc objects
  */
+extern int edac_sysfs_setup_mc_kset(void);
+extern void edac_sysfs_teardown_mc_kset(void);
+extern int edac_mc_register_sysfs_main_kobj(struct mem_ctl_info *mci);
+extern void edac_mc_unregister_sysfs_main_kobj(struct mem_ctl_info *mci);
 extern int edac_create_sysfs_mci_device(struct mem_ctl_info *mci);
 extern void edac_remove_sysfs_mci_device(struct mem_ctl_info *mci);
-extern int edac_sysfs_memctrl_setup(void);
-extern void edac_sysfs_memctrl_teardown(void);
 extern void edac_check_mc_devices(void);
 extern int edac_get_log_ue(void);
 extern int edac_get_log_ce(void);

commit 7391c6dcab3094610cb99bbd559beaa282582eac
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:50:21 2007 -0700

    drivers/edac: mod edac_align_ptr function
    
    Refactor the edac_align_ptr() function to reduce the noise of casting the
    aligned pointer to the various types of data objects and modified its callers
    to its new signature
    
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 0869fbaa733c..37a08aa87d3e 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -44,6 +44,7 @@ extern void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
 extern void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev);
 extern void edac_device_reset_delay_period(struct edac_device_ctl_info
 					   *edac_dev, unsigned long value);
+extern void *edac_align_ptr(void *ptr, unsigned size);
 
 /*
  * EDAC PCI functions

commit 079708b9173595bf74b31b14c36e946359ae6c7e
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:49:58 2007 -0700

    drivers/edac: core Lindent cleanup
    
    Run the EDAC CORE files through Lindent for cleanup
    
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Dave Jiang <djiang@mvista.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index ffd25bdf87fc..0869fbaa733c 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -40,12 +40,10 @@ extern struct sysdev_class *edac_get_edac_class(void);
 /* edac core workqueue: single CPU mode */
 extern struct workqueue_struct *edac_workqueue;
 extern void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
-				unsigned msec);
+				    unsigned msec);
 extern void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev);
-extern void edac_device_reset_delay_period(
-			struct edac_device_ctl_info *edac_dev,
-			unsigned long value);
-
+extern void edac_device_reset_delay_period(struct edac_device_ctl_info
+					   *edac_dev, unsigned long value);
 
 /*
  * EDAC PCI functions
@@ -57,7 +55,7 @@ extern int edac_sysfs_pci_setup(void);
 extern void edac_sysfs_pci_teardown(void);
 extern int edac_pci_get_check_errors(void);
 extern int edac_pci_get_poll_msec(void);
-#else   /* CONFIG_PCI */
+#else				/* CONFIG_PCI */
 /* pre-process these away */
 #define edac_pci_do_parity_check()
 #define edac_pci_clear_parity_errors()
@@ -65,8 +63,6 @@ extern int edac_pci_get_poll_msec(void);
 #define edac_sysfs_pci_teardown()
 #define edac_pci_get_check_errors()
 #define edac_pci_get_poll_msec()
-#endif  /* CONFIG_PCI */
-
-
-#endif	/* __EDAC_MODULE_H__ */
+#endif				/* CONFIG_PCI */
 
+#endif				/* __EDAC_MODULE_H__ */

commit 4de78c6877ec21142582ac19453c2d453d1ea298
Author: Dave Jiang <djiang@mvista.com>
Date:   Thu Jul 19 01:49:54 2007 -0700

    drivers/edac: mod PCI poll names
    
    Fixup poll values for MC and PCI.
    Also make mc function names unique to mc.
    
    Signed-off-by: Dave Jiang <djiang@mvista.com>
    Signed-off-by: Douglas Thompson <dougthompson@xmissin.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 22c52e43131d..ffd25bdf87fc 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -27,6 +27,9 @@ extern void edac_check_mc_devices(void);
 extern int edac_get_log_ue(void);
 extern int edac_get_log_ce(void);
 extern int edac_get_panic_on_ue(void);
+extern int edac_mc_get_log_ue(void);
+extern int edac_mc_get_log_ce(void);
+extern int edac_mc_get_panic_on_ue(void);
 extern int edac_get_poll_msec(void);
 extern int edac_mc_get_poll_msec(void);
 
@@ -52,12 +55,16 @@ extern void edac_pci_do_parity_check(void);
 extern void edac_pci_clear_parity_errors(void);
 extern int edac_sysfs_pci_setup(void);
 extern void edac_sysfs_pci_teardown(void);
+extern int edac_pci_get_check_errors(void);
+extern int edac_pci_get_poll_msec(void);
 #else   /* CONFIG_PCI */
 /* pre-process these away */
 #define edac_pci_do_parity_check()
 #define edac_pci_clear_parity_errors()
 #define edac_sysfs_pci_setup()  (0)
 #define edac_sysfs_pci_teardown()
+#define edac_pci_get_check_errors()
+#define edac_pci_get_poll_msec()
 #endif  /* CONFIG_PCI */
 
 

commit 81d87cb13e367bb804bf44889ae0de7369705d6c
Author: Dave Jiang <djiang@mvista.com>
Date:   Thu Jul 19 01:49:52 2007 -0700

    drivers/edac: mod MC to use workq instead of kthread
    
    Move the memory controller object to work queue based implementation from the
    kernel thread based.
    
    Signed-off-by: Dave Jiang <djiang@mvista.com>
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 2758d03c3e03..22c52e43131d 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -28,6 +28,7 @@ extern int edac_get_log_ue(void);
 extern int edac_get_log_ce(void);
 extern int edac_get_panic_on_ue(void);
 extern int edac_get_poll_msec(void);
+extern int edac_mc_get_poll_msec(void);
 
 extern int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev);
 extern void edac_device_remove_sysfs(struct edac_device_ctl_info *edac_dev);
@@ -35,9 +36,9 @@ extern struct sysdev_class *edac_get_edac_class(void);
 
 /* edac core workqueue: single CPU mode */
 extern struct workqueue_struct *edac_workqueue;
-extern void edac_workq_setup(struct edac_device_ctl_info *edac_dev,
+extern void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,
 				unsigned msec);
-extern void edac_workq_teardown(struct edac_device_ctl_info *edac_dev);
+extern void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev);
 extern void edac_device_reset_delay_period(
 			struct edac_device_ctl_info *edac_dev,
 			unsigned long value);

commit e27e3dac651771fe3250f6305dee277bce29fc5d
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:49:36 2007 -0700

    drivers/edac: add edac_device class
    
    This patch adds the new 'class' of object to be managed, named: 'edac_device'.
    
    As a peer of the 'edac_mc' class of object, it provides a non-memory centric
    view of an ERROR DETECTING device in hardware. It provides a sysfs interface
    and an abstraction for varioius EDAC type devices.
    
    Multiple 'instances' within the class are possible, with each 'instance'
    able to have multiple 'blocks', and each 'block' having 'attributes'.
    
    At the 'block' level there are the 'ce_count' and 'ue_count' fields
    which the device driver can update and/or call edac_device_handle_XX()
    functions. At each higher level are additional 'total' count fields,
    which are a summation of counts below that level.
    
    This 'edac_device' has been used to capture and present ECC errors
    which are found in a a L1 and L2 system on a per CORE/CPU basis.
    
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
index 69c77f85bcd4..2758d03c3e03 100644
--- a/drivers/edac/edac_module.h
+++ b/drivers/edac/edac_module.h
@@ -33,6 +33,15 @@ extern int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev);
 extern void edac_device_remove_sysfs(struct edac_device_ctl_info *edac_dev);
 extern struct sysdev_class *edac_get_edac_class(void);
 
+/* edac core workqueue: single CPU mode */
+extern struct workqueue_struct *edac_workqueue;
+extern void edac_workq_setup(struct edac_device_ctl_info *edac_dev,
+				unsigned msec);
+extern void edac_workq_teardown(struct edac_device_ctl_info *edac_dev);
+extern void edac_device_reset_delay_period(
+			struct edac_device_ctl_info *edac_dev,
+			unsigned long value);
+
 
 /*
  * EDAC PCI functions

commit 7c9281d76c1c0b130f79d5fc021084e9749959d4
Author: Douglas Thompson <dougthompson@xmission.com>
Date:   Thu Jul 19 01:49:33 2007 -0700

    drivers/edac: split out functions to unique files
    
    This is a large patch to refactor the original EDAC module in the kernel
    and to break it up into better file granularity, such that each source
    file contains a given subsystem of the EDAC CORE.
    
    Originally, the EDAC 'core' was contained in one source file: edac_mc.c
    with it corresponding edac_mc.h file.
    
    Now, there are the following files:
    
    edac_module.c   The main module init/exit function and other overhead
    edac_mc.c       Code handling the edac_mc class of object
    edac_mc_sysfs.c Code handling for sysfs presentation
    edac_pci_sysfs.c  Code handling for PCI sysfs presentation
    edac_core.h     CORE .h include file for 'edac_mc' and 'edac_device' drivers
    edac_module.h   Internal CORE .h include file
    
    This forms a foundation upon which a later patch can create the 'edac_device'
    class of object code in a new file 'edac_device.c'.
    
    Signed-off-by: Douglas Thompson <dougthompson@xmission.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/edac/edac_module.h b/drivers/edac/edac_module.h
new file mode 100644
index 000000000000..69c77f85bcd4
--- /dev/null
+++ b/drivers/edac/edac_module.h
@@ -0,0 +1,55 @@
+
+/*
+ * edac_module.h
+ *
+ * For defining functions/data for within the EDAC_CORE module only
+ *
+ * written by doug thompson <norsk5@xmission.h>
+ */
+
+#ifndef	__EDAC_MODULE_H__
+#define	__EDAC_MODULE_H__
+
+#include <linux/sysdev.h>
+
+#include "edac_core.h"
+
+/*
+ * INTERNAL EDAC MODULE:
+ * EDAC memory controller sysfs create/remove functions
+ * and setup/teardown functions
+ */
+extern int edac_create_sysfs_mci_device(struct mem_ctl_info *mci);
+extern void edac_remove_sysfs_mci_device(struct mem_ctl_info *mci);
+extern int edac_sysfs_memctrl_setup(void);
+extern void edac_sysfs_memctrl_teardown(void);
+extern void edac_check_mc_devices(void);
+extern int edac_get_log_ue(void);
+extern int edac_get_log_ce(void);
+extern int edac_get_panic_on_ue(void);
+extern int edac_get_poll_msec(void);
+
+extern int edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev);
+extern void edac_device_remove_sysfs(struct edac_device_ctl_info *edac_dev);
+extern struct sysdev_class *edac_get_edac_class(void);
+
+
+/*
+ * EDAC PCI functions
+ */
+#ifdef	CONFIG_PCI
+extern void edac_pci_do_parity_check(void);
+extern void edac_pci_clear_parity_errors(void);
+extern int edac_sysfs_pci_setup(void);
+extern void edac_sysfs_pci_teardown(void);
+#else   /* CONFIG_PCI */
+/* pre-process these away */
+#define edac_pci_do_parity_check()
+#define edac_pci_clear_parity_errors()
+#define edac_sysfs_pci_setup()  (0)
+#define edac_sysfs_pci_teardown()
+#endif  /* CONFIG_PCI */
+
+
+#endif	/* __EDAC_MODULE_H__ */
+
