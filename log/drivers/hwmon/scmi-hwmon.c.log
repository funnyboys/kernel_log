commit 3ce17cd2b94907f6d91b81b32848044b84c97606
Author: Cristian Marussi <cristian.marussi@arm.com>
Date:   Wed Jul 15 13:13:38 2020 +0100

    hwmon: (scmi) Fix potential buffer overflow in scmi_hwmon_probe()
    
    SMATCH detected a potential buffer overflow in the manipulation of
    hwmon_attributes array inside the scmi_hwmon_probe function:
    
    drivers/hwmon/scmi-hwmon.c:226
     scmi_hwmon_probe() error: buffer overflow 'hwmon_attributes' 6 <= 9
    
    Fix it by statically declaring the size of the array as the maximum
    possible as defined by hwmon_max define.
    
    Signed-off-by: Cristian Marussi <cristian.marussi@arm.com>
    Reviewed-by: Sudeep Holla <sudeep.holla@arm.com>
    Link: https://lore.kernel.org/r/20200715121338.GA18761@e119603-lin.cambridge.arm.com
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/hwmon/scmi-hwmon.c b/drivers/hwmon/scmi-hwmon.c
index 286d3cfda7de..d421e691318b 100644
--- a/drivers/hwmon/scmi-hwmon.c
+++ b/drivers/hwmon/scmi-hwmon.c
@@ -147,7 +147,7 @@ static enum hwmon_sensor_types scmi_types[] = {
 	[ENERGY] = hwmon_energy,
 };
 
-static u32 hwmon_attributes[] = {
+static u32 hwmon_attributes[hwmon_max] = {
 	[hwmon_chip] = HWMON_C_REGISTER_TZ,
 	[hwmon_temp] = HWMON_T_INPUT | HWMON_T_LABEL,
 	[hwmon_in] = HWMON_I_INPUT | HWMON_I_LABEL,

commit b017b2791c9cd6b2e6ec28265e7da3069f25c34f
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Wed Nov 6 17:57:30 2019 +0000

    hwmon: (scmi-hwmon) Match scmi device by both name and protocol id
    
    The scmi bus now has support to match the driver with devices not only
    based on their protocol id but also based on their device name if one is
    available. This was added to cater the need to support multiple devices
    and drivers for the same protocol.
    
    Let us add the name "hwmon" to scmi_device_id table in the driver so
    that in matches only with device with the same name and protocol id
    SCMI_PROTOCOL_SENSOR. This is just for sake of completion and must
    not be used to add IIO support in parallel. Instead, if IIO support is
    added ever in future, we need to drop this hwmon driver entirely and
    use the iio->hwmon bridge to access the sensors as hwmon devices if
    needed.
    
    Cc: linux-hwmon@vger.kernel.org
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/drivers/hwmon/scmi-hwmon.c b/drivers/hwmon/scmi-hwmon.c
index 8a7732c0bef3..286d3cfda7de 100644
--- a/drivers/hwmon/scmi-hwmon.c
+++ b/drivers/hwmon/scmi-hwmon.c
@@ -259,7 +259,7 @@ static int scmi_hwmon_probe(struct scmi_device *sdev)
 }
 
 static const struct scmi_device_id scmi_id_table[] = {
-	{ SCMI_PROTOCOL_SENSOR },
+	{ SCMI_PROTOCOL_SENSOR, "hwmon" },
 	{ },
 };
 MODULE_DEVICE_TABLE(scmi, scmi_id_table);

commit 6a55331c87d86a7406d8126ae75bdd07244a91b1
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Mon Jul 8 09:40:57 2019 +0100

    firmware: arm_scmi: Drop async flag in sensor_ops->reading_get
    
    SENSOR_DESCRIPTION_GET provides attributes to indicate if the sensor
    supports asynchronous read. Ideally we should be able to read that flag
    and use asynchronous reads for any sensors with that attribute set.
    
    In order to add that support, let's drop the async flag passed to
    sensor_ops->reading_get and dynamically switch between sync and async
    flags based on the attributes as provided by the firmware.
    
    Cc: linux-hwmon@vger.kernel.org
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/drivers/hwmon/scmi-hwmon.c b/drivers/hwmon/scmi-hwmon.c
index 0c93fc5ca762..8a7732c0bef3 100644
--- a/drivers/hwmon/scmi-hwmon.c
+++ b/drivers/hwmon/scmi-hwmon.c
@@ -72,7 +72,7 @@ static int scmi_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
 	const struct scmi_handle *h = scmi_sensors->handle;
 
 	sensor = *(scmi_sensors->info[type] + channel);
-	ret = h->sensor_ops->reading_get(h, sensor->id, false, &value);
+	ret = h->sensor_ops->reading_get(h, sensor->id, &value);
 	if (ret)
 		return ret;
 

commit ac778e62634eee0685b622605b063a49edf2f2d1
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed May 8 11:46:35 2019 -0700

    hwmon: scmi: Scale values to target desired HWMON units
    
    If the SCMI firmware implementation is reporting values in a scale that
    is different from the HWMON units, we need to scale up or down the value
    according to how far apart they are.
    
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    [sudeep.holla: added check of scale = 0 for early exit in scmi_hwmon_scale]
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/drivers/hwmon/scmi-hwmon.c b/drivers/hwmon/scmi-hwmon.c
index a80183a488c5..0c93fc5ca762 100644
--- a/drivers/hwmon/scmi-hwmon.c
+++ b/drivers/hwmon/scmi-hwmon.c
@@ -18,6 +18,50 @@ struct scmi_sensors {
 	const struct scmi_sensor_info **info[hwmon_max];
 };
 
+static inline u64 __pow10(u8 x)
+{
+	u64 r = 1;
+
+	while (x--)
+		r *= 10;
+
+	return r;
+}
+
+static int scmi_hwmon_scale(const struct scmi_sensor_info *sensor, u64 *value)
+{
+	s8 scale = sensor->scale;
+	u64 f;
+
+	switch (sensor->type) {
+	case TEMPERATURE_C:
+	case VOLTAGE:
+	case CURRENT:
+		scale += 3;
+		break;
+	case POWER:
+	case ENERGY:
+		scale += 6;
+		break;
+	default:
+		break;
+	}
+
+	if (scale == 0)
+		return 0;
+
+	if (abs(scale) > 19)
+		return -E2BIG;
+
+	f = __pow10(abs(scale));
+	if (scale > 0)
+		*value *= f;
+	else
+		*value = div64_u64(*value, f);
+
+	return 0;
+}
+
 static int scmi_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
 			   u32 attr, int channel, long *val)
 {
@@ -29,6 +73,10 @@ static int scmi_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
 
 	sensor = *(scmi_sensors->info[type] + channel);
 	ret = h->sensor_ops->reading_get(h, sensor->id, false, &value);
+	if (ret)
+		return ret;
+
+	ret = scmi_hwmon_scale(sensor, &value);
 	if (!ret)
 		*val = value;
 

commit 626c4a0657a4fcd72bf1863f1226a5780810e219
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Mon Dec 10 14:02:19 2018 -0800

    hwmon: (scmi-hwmon) Replace S_<PERMS> with octal values
    
    Replace S_<PERMS> with octal values.
    
    The conversion was done automatically with coccinelle. The semantic patches
    and the scripts used to generate this commit log are available at
    https://github.com/groeck/coccinelle-patches/hwmon/.
    
    This patch does not introduce functional changes. It was verified by
    compiling the old and new files and comparing text and data sizes.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/hwmon/scmi-hwmon.c b/drivers/hwmon/scmi-hwmon.c
index 2e005edee0c9..a80183a488c5 100644
--- a/drivers/hwmon/scmi-hwmon.c
+++ b/drivers/hwmon/scmi-hwmon.c
@@ -57,7 +57,7 @@ scmi_hwmon_is_visible(const void *drvdata, enum hwmon_sensor_types type,
 
 	sensor = *(scmi_sensors->info[type] + channel);
 	if (sensor)
-		return S_IRUGO;
+		return 0444;
 
 	return 0;
 }

commit a31796c30e423f58d266df30a9bbf321fc071b30
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Sat Sep 15 17:05:07 2018 -0700

    hwmon: (scmi) Remove redundant pointer check
    
    Clang warns when the address of a pointer is used in a boolean context
    as it will always return true.
    
    drivers/hwmon/scmi-hwmon.c:59:24: warning: address of array
    'sensor->name' will always evaluate to 'true'
    [-Wpointer-bool-conversion]
            if (sensor && sensor->name)
                       ~~ ~~~~~~~~^~~~
    1 warning generated.
    
    Remove the check as it isn't doing anything currently; if validation
    of the contents of the data structure was intended by the original
    author (since this line has been present from the first version of
    this driver), it can be added in a follow-up patch.
    
    Reported-by: Nick Desaulniers <ndesaulniers@google.com>
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/hwmon/scmi-hwmon.c b/drivers/hwmon/scmi-hwmon.c
index 91976b6ca300..2e005edee0c9 100644
--- a/drivers/hwmon/scmi-hwmon.c
+++ b/drivers/hwmon/scmi-hwmon.c
@@ -56,7 +56,7 @@ scmi_hwmon_is_visible(const void *drvdata, enum hwmon_sensor_types type,
 	const struct scmi_sensors *scmi_sensors = drvdata;
 
 	sensor = *(scmi_sensors->info[type] + channel);
-	if (sensor && sensor->name)
+	if (sensor)
 		return S_IRUGO;
 
 	return 0;

commit f18a36cf3f31dce633fe2a93d0059008bb21d9f2
Author: Sudeep Holla <Sudeep.Holla@arm.com>
Date:   Fri Apr 6 16:30:47 2018 +0100

    hwmon: (scmi) handle absence of few types of sensors
    
    Currently the loop checks for non-zero count of sensors for each type
    of sensors which is completely wrong. It also results in aborting the
    registration of sensors if one or more types of sensors are completely
    not supported by the platform SCMI firmware.
    
    This patch fixes the issue by continue to loop and skiping sensor types
    that are not present.
    
    Fixes: b23688aefb8b ("hwmon: add support for sensors exported via ARM SCMI")
    Reported-by: Jim Quinlan <james.quinlan@broadcom.com>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: linux-hwmon@vger.kernel.org
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/hwmon/scmi-hwmon.c b/drivers/hwmon/scmi-hwmon.c
index 363bf56eb0f2..91976b6ca300 100644
--- a/drivers/hwmon/scmi-hwmon.c
+++ b/drivers/hwmon/scmi-hwmon.c
@@ -170,7 +170,10 @@ static int scmi_hwmon_probe(struct scmi_device *sdev)
 	scmi_chip_info.info = ptr_scmi_ci;
 	chip_info = &scmi_chip_info;
 
-	for (type = 0; type < hwmon_max && nr_count[type]; type++) {
+	for (type = 0; type < hwmon_max; type++) {
+		if (!nr_count[type])
+			continue;
+
 		scmi_hwmon_add_chan_info(scmi_hwmon_chan, dev, nr_count[type],
 					 type, hwmon_attributes[type]);
 		*ptr_scmi_ci++ = scmi_hwmon_chan++;

commit c09880cef78d0ddf149cdfeb733027a806465ba2
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Thu Mar 15 16:54:18 2018 +0000

    hwmon: (scmi) return -EINVAL when sensor information is unavailable
    
    Passing NULL pointer to PTR_ERR will result in return value of 0
    indicating success which is clearly not what it is intended here.
    
    This patch returns -EINVAL instead when the sensor information is not
    available.
    
    Fixes: b23688aefb8b ("hwmon: add support for sensors exported via ARM SCMI")
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Cc: linux-hwmon@vger.kernel.org
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/drivers/hwmon/scmi-hwmon.c b/drivers/hwmon/scmi-hwmon.c
index 32e750373ced..363bf56eb0f2 100644
--- a/drivers/hwmon/scmi-hwmon.c
+++ b/drivers/hwmon/scmi-hwmon.c
@@ -138,7 +138,7 @@ static int scmi_hwmon_probe(struct scmi_device *sdev)
 	for (i = 0; i < nr_sensors; i++) {
 		sensor = handle->sensor_ops->info_get(handle, i);
 		if (!sensor)
-			return PTR_ERR(sensor);
+			return -EINVAL;
 
 		switch (sensor->type) {
 		case TEMPERATURE_C:

commit b23688aefb8b2c5dd024c172f3143e8a99d2cf17
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Thu Jun 15 10:53:17 2017 +0100

    hwmon: add support for sensors exported via ARM SCMI
    
    Create a driver to add support for SoC sensors exported by the System
    Control Processor (SCP) via the System Control and Management Interface
    (SCMI). The supported sensor types is one of voltage, temperature,
    current, and power.
    
    The sensor labels and values provided by the SCP are exported via the
    hwmon sysfs interface.
    
    Cc: linux-hwmon@vger.kernel.org
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>

diff --git a/drivers/hwmon/scmi-hwmon.c b/drivers/hwmon/scmi-hwmon.c
new file mode 100644
index 000000000000..32e750373ced
--- /dev/null
+++ b/drivers/hwmon/scmi-hwmon.c
@@ -0,0 +1,225 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * System Control and Management Interface(SCMI) based hwmon sensor driver
+ *
+ * Copyright (C) 2018 ARM Ltd.
+ * Sudeep Holla <sudeep.holla@arm.com>
+ */
+
+#include <linux/hwmon.h>
+#include <linux/module.h>
+#include <linux/scmi_protocol.h>
+#include <linux/slab.h>
+#include <linux/sysfs.h>
+#include <linux/thermal.h>
+
+struct scmi_sensors {
+	const struct scmi_handle *handle;
+	const struct scmi_sensor_info **info[hwmon_max];
+};
+
+static int scmi_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
+			   u32 attr, int channel, long *val)
+{
+	int ret;
+	u64 value;
+	const struct scmi_sensor_info *sensor;
+	struct scmi_sensors *scmi_sensors = dev_get_drvdata(dev);
+	const struct scmi_handle *h = scmi_sensors->handle;
+
+	sensor = *(scmi_sensors->info[type] + channel);
+	ret = h->sensor_ops->reading_get(h, sensor->id, false, &value);
+	if (!ret)
+		*val = value;
+
+	return ret;
+}
+
+static int
+scmi_hwmon_read_string(struct device *dev, enum hwmon_sensor_types type,
+		       u32 attr, int channel, const char **str)
+{
+	const struct scmi_sensor_info *sensor;
+	struct scmi_sensors *scmi_sensors = dev_get_drvdata(dev);
+
+	sensor = *(scmi_sensors->info[type] + channel);
+	*str = sensor->name;
+
+	return 0;
+}
+
+static umode_t
+scmi_hwmon_is_visible(const void *drvdata, enum hwmon_sensor_types type,
+		      u32 attr, int channel)
+{
+	const struct scmi_sensor_info *sensor;
+	const struct scmi_sensors *scmi_sensors = drvdata;
+
+	sensor = *(scmi_sensors->info[type] + channel);
+	if (sensor && sensor->name)
+		return S_IRUGO;
+
+	return 0;
+}
+
+static const struct hwmon_ops scmi_hwmon_ops = {
+	.is_visible = scmi_hwmon_is_visible,
+	.read = scmi_hwmon_read,
+	.read_string = scmi_hwmon_read_string,
+};
+
+static struct hwmon_chip_info scmi_chip_info = {
+	.ops = &scmi_hwmon_ops,
+	.info = NULL,
+};
+
+static int scmi_hwmon_add_chan_info(struct hwmon_channel_info *scmi_hwmon_chan,
+				    struct device *dev, int num,
+				    enum hwmon_sensor_types type, u32 config)
+{
+	int i;
+	u32 *cfg = devm_kcalloc(dev, num + 1, sizeof(*cfg), GFP_KERNEL);
+
+	if (!cfg)
+		return -ENOMEM;
+
+	scmi_hwmon_chan->type = type;
+	scmi_hwmon_chan->config = cfg;
+	for (i = 0; i < num; i++, cfg++)
+		*cfg = config;
+
+	return 0;
+}
+
+static enum hwmon_sensor_types scmi_types[] = {
+	[TEMPERATURE_C] = hwmon_temp,
+	[VOLTAGE] = hwmon_in,
+	[CURRENT] = hwmon_curr,
+	[POWER] = hwmon_power,
+	[ENERGY] = hwmon_energy,
+};
+
+static u32 hwmon_attributes[] = {
+	[hwmon_chip] = HWMON_C_REGISTER_TZ,
+	[hwmon_temp] = HWMON_T_INPUT | HWMON_T_LABEL,
+	[hwmon_in] = HWMON_I_INPUT | HWMON_I_LABEL,
+	[hwmon_curr] = HWMON_C_INPUT | HWMON_C_LABEL,
+	[hwmon_power] = HWMON_P_INPUT | HWMON_P_LABEL,
+	[hwmon_energy] = HWMON_E_INPUT | HWMON_E_LABEL,
+};
+
+static int scmi_hwmon_probe(struct scmi_device *sdev)
+{
+	int i, idx;
+	u16 nr_sensors;
+	enum hwmon_sensor_types type;
+	struct scmi_sensors *scmi_sensors;
+	const struct scmi_sensor_info *sensor;
+	int nr_count[hwmon_max] = {0}, nr_types = 0;
+	const struct hwmon_chip_info *chip_info;
+	struct device *hwdev, *dev = &sdev->dev;
+	struct hwmon_channel_info *scmi_hwmon_chan;
+	const struct hwmon_channel_info **ptr_scmi_ci;
+	const struct scmi_handle *handle = sdev->handle;
+
+	if (!handle || !handle->sensor_ops)
+		return -ENODEV;
+
+	nr_sensors = handle->sensor_ops->count_get(handle);
+	if (!nr_sensors)
+		return -EIO;
+
+	scmi_sensors = devm_kzalloc(dev, sizeof(*scmi_sensors), GFP_KERNEL);
+	if (!scmi_sensors)
+		return -ENOMEM;
+
+	scmi_sensors->handle = handle;
+
+	for (i = 0; i < nr_sensors; i++) {
+		sensor = handle->sensor_ops->info_get(handle, i);
+		if (!sensor)
+			return PTR_ERR(sensor);
+
+		switch (sensor->type) {
+		case TEMPERATURE_C:
+		case VOLTAGE:
+		case CURRENT:
+		case POWER:
+		case ENERGY:
+			type = scmi_types[sensor->type];
+			if (!nr_count[type])
+				nr_types++;
+			nr_count[type]++;
+			break;
+		}
+	}
+
+	if (nr_count[hwmon_temp])
+		nr_count[hwmon_chip]++, nr_types++;
+
+	scmi_hwmon_chan = devm_kcalloc(dev, nr_types, sizeof(*scmi_hwmon_chan),
+				       GFP_KERNEL);
+	if (!scmi_hwmon_chan)
+		return -ENOMEM;
+
+	ptr_scmi_ci = devm_kcalloc(dev, nr_types + 1, sizeof(*ptr_scmi_ci),
+				   GFP_KERNEL);
+	if (!ptr_scmi_ci)
+		return -ENOMEM;
+
+	scmi_chip_info.info = ptr_scmi_ci;
+	chip_info = &scmi_chip_info;
+
+	for (type = 0; type < hwmon_max && nr_count[type]; type++) {
+		scmi_hwmon_add_chan_info(scmi_hwmon_chan, dev, nr_count[type],
+					 type, hwmon_attributes[type]);
+		*ptr_scmi_ci++ = scmi_hwmon_chan++;
+
+		scmi_sensors->info[type] =
+			devm_kcalloc(dev, nr_count[type],
+				     sizeof(*scmi_sensors->info), GFP_KERNEL);
+		if (!scmi_sensors->info[type])
+			return -ENOMEM;
+	}
+
+	for (i = nr_sensors - 1; i >= 0 ; i--) {
+		sensor = handle->sensor_ops->info_get(handle, i);
+		if (!sensor)
+			continue;
+
+		switch (sensor->type) {
+		case TEMPERATURE_C:
+		case VOLTAGE:
+		case CURRENT:
+		case POWER:
+		case ENERGY:
+			type = scmi_types[sensor->type];
+			idx = --nr_count[type];
+			*(scmi_sensors->info[type] + idx) = sensor;
+			break;
+		}
+	}
+
+	hwdev = devm_hwmon_device_register_with_info(dev, "scmi_sensors",
+						     scmi_sensors, chip_info,
+						     NULL);
+
+	return PTR_ERR_OR_ZERO(hwdev);
+}
+
+static const struct scmi_device_id scmi_id_table[] = {
+	{ SCMI_PROTOCOL_SENSOR },
+	{ },
+};
+MODULE_DEVICE_TABLE(scmi, scmi_id_table);
+
+static struct scmi_driver scmi_hwmon_drv = {
+	.name		= "scmi-hwmon",
+	.probe		= scmi_hwmon_probe,
+	.id_table	= scmi_id_table,
+};
+module_scmi_driver(scmi_hwmon_drv);
+
+MODULE_AUTHOR("Sudeep Holla <sudeep.holla@arm.com>");
+MODULE_DESCRIPTION("ARM SCMI HWMON interface driver");
+MODULE_LICENSE("GPL v2");
