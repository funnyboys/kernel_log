commit 7c672abc120a55f678e5571ae2ee93f06ca4d7f9
Merge: 1902314157b1 fe013f8bc160
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 17 16:22:26 2019 -0700

    Merge tag 'docs-5.4' of git://git.lwn.net/linux
    
    Pull documentation updates from Jonathan Corbet:
     "It's a somewhat calmer cycle for docs this time, as the churn of the
      mass RST conversion is happily mostly behind us.
    
       - A new document on reproducible builds.
    
       - We finally got around to zapping the documentation for hardware
         support that was removed in 2004; one doesn't want to rush these
         things.
    
       - The usual assortment of fixes, typo corrections, etc"
    
    * tag 'docs-5.4' of git://git.lwn.net/linux: (67 commits)
      Documentation: kbuild: Add document about reproducible builds
      docs: printk-formats: Stop encouraging use of unnecessary %h[xudi] and %hh[xudi]
      Documentation: Add "earlycon=sbi" to the admin guide
      doc:lock: remove reference to clever use of read-write lock
      devices.txt: improve entry for comedi (char major 98)
      docs: mtd: Update spi nor reference driver
      doc: arm64: fix grammar dtb placed in no attributes region
      Documentation: sysrq: don't recommend 'S' 'U' before 'B'
      mailmap: Update email address for Quentin Perret
      docs: ftrace: clarify when tracing is disabled by the trace file
      docs: process: fix broken link
      Documentation/arm/samsung-s3c24xx: Remove stray U+FEFF character to fix title
      Documentation/arm/sa1100/assabet: Fix 'make assabet_defconfig' command
      Documentation/arm/sa1100: Remove some obsolete documentation
      docs/zh_CN: update Chinese howto.rst for latexdocs making
      Documentation: virt: Fix broken reference to virt tree's index
      docs: Fix typo on pull requests guide
      kernel-doc: Allow anonymous enum
      Documentation: sphinx: Don't parse socket() as identifier reference
      Documentation: sphinx: Add missing comma to list of strings
      ...

commit 25d4016464778604362ea55a085048ddb48e0072
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Mon Jul 22 19:26:09 2019 +0200

    hwmon: (smm665) convert to i2c_new_dummy_device
    
    Move from i2c_new_dummy() to i2c_new_dummy_device(), so we now get an
    ERRPTR which we use in error handling.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Link: https://lore.kernel.org/r/20190722172611.3797-3-wsa+renesas@sang-engineering.com
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/hwmon/smm665.c b/drivers/hwmon/smm665.c
index d8c91c2cb8cf..6eff14fe395d 100644
--- a/drivers/hwmon/smm665.c
+++ b/drivers/hwmon/smm665.c
@@ -586,10 +586,10 @@ static int smm665_probe(struct i2c_client *client,
 
 	data->client = client;
 	data->type = id->driver_data;
-	data->cmdreg = i2c_new_dummy(adapter, (client->addr & ~SMM665_REGMASK)
+	data->cmdreg = i2c_new_dummy_device(adapter, (client->addr & ~SMM665_REGMASK)
 				     | SMM665_CMDREG_BASE);
-	if (!data->cmdreg)
-		return -ENOMEM;
+	if (IS_ERR(data->cmdreg))
+		return PTR_ERR(data->cmdreg);
 
 	switch (data->type) {
 	case smm465:

commit ccf988b66d697efcd0ceccc2398e0d9b909cd17c
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Fri Jul 26 09:51:16 2019 -0300

    docs: i2c: convert to ReST and add to driver-api bookset
    
    Convert each file at I2C subsystem, renaming them to .rst and
    adding to the driver-api book.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/drivers/hwmon/smm665.c b/drivers/hwmon/smm665.c
index d8c91c2cb8cf..9ae0dc28b9cf 100644
--- a/drivers/hwmon/smm665.c
+++ b/drivers/hwmon/smm665.c
@@ -197,7 +197,7 @@ static int smm665_read_adc(struct smm665_data *data, int adc)
 	if (rv != -ENXIO) {
 		/*
 		 * We expect ENXIO to reflect NACK
-		 * (per Documentation/i2c/fault-codes).
+		 * (per Documentation/i2c/fault-codes.rst).
 		 * Everything else is an error.
 		 */
 		dev_dbg(&client->dev,

commit b886d83c5b621abc84ff9616f14c529be3f6b147
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 1 10:08:55 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 441
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 of the license
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 315 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531190115.503150771@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwmon/smm665.c b/drivers/hwmon/smm665.c
index 627c9c3a8255..d8c91c2cb8cf 100644
--- a/drivers/hwmon/smm665.c
+++ b/drivers/hwmon/smm665.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Driver for SMM665 Power Controller / Monitor
  *
  * Copyright (C) 2010 Ericsson AB.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
  * This driver should also work for SMM465, SMM764, and SMM766, but is untested
  * for those chips. Only monitoring functionality is implemented.
  *

commit 781126a0c8debc713a07da16c790253dadb33184
Author: Axel Lin <axel.lin@ingics.com>
Date:   Wed Jul 2 20:26:32 2014 +0800

    hwmon: (smm665) Convert to devm_hwmon_device_register_with_groups
    
    Use ATTRIBUTE_GROUPS macro and devm_hwmon_device_register_with_groups() to
    simplify the code a bit.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/hwmon/smm665.c b/drivers/hwmon/smm665.c
index 4ef5802df6d8..627c9c3a8255 100644
--- a/drivers/hwmon/smm665.c
+++ b/drivers/hwmon/smm665.c
@@ -140,7 +140,7 @@ enum chips { smm465, smm665, smm665c, smm764, smm766 };
 struct smm665_data {
 	enum chips type;
 	int conversion_time;		/* ADC conversion time */
-	struct device *hwmon_dev;
+	struct i2c_client *client;
 	struct mutex update_lock;
 	bool valid;
 	unsigned long last_updated;	/* in jiffies */
@@ -239,8 +239,8 @@ static int smm665_read_adc(struct smm665_data *data, int adc)
 
 static struct smm665_data *smm665_update_device(struct device *dev)
 {
-	struct i2c_client *client = to_i2c_client(dev);
-	struct smm665_data *data = i2c_get_clientdata(client);
+	struct smm665_data *data = dev_get_drvdata(dev);
+	struct i2c_client *client = data->client;
 	struct smm665_data *ret = data;
 
 	mutex_lock(&data->update_lock);
@@ -315,32 +315,28 @@ static int smm665_convert(u16 adcval, int index)
 
 static int smm665_get_min(struct device *dev, int index)
 {
-	struct i2c_client *client = to_i2c_client(dev);
-	struct smm665_data *data = i2c_get_clientdata(client);
+	struct smm665_data *data = dev_get_drvdata(dev);
 
 	return data->alarm_min_limit[index];
 }
 
 static int smm665_get_max(struct device *dev, int index)
 {
-	struct i2c_client *client = to_i2c_client(dev);
-	struct smm665_data *data = i2c_get_clientdata(client);
+	struct smm665_data *data = dev_get_drvdata(dev);
 
 	return data->alarm_max_limit[index];
 }
 
 static int smm665_get_lcrit(struct device *dev, int index)
 {
-	struct i2c_client *client = to_i2c_client(dev);
-	struct smm665_data *data = i2c_get_clientdata(client);
+	struct smm665_data *data = dev_get_drvdata(dev);
 
 	return data->critical_min_limit[index];
 }
 
 static int smm665_get_crit(struct device *dev, int index)
 {
-	struct i2c_client *client = to_i2c_client(dev);
-	struct smm665_data *data = i2c_get_clientdata(client);
+	struct smm665_data *data = dev_get_drvdata(dev);
 
 	return data->critical_max_limit[index];
 }
@@ -486,7 +482,7 @@ SMM665_ATTR(temp1, crit_alarm, SMM665_FAULT_TEMP);
  * Finally, construct an array of pointers to members of the above objects,
  * as required for sysfs_create_group()
  */
-static struct attribute *smm665_attributes[] = {
+static struct attribute *smm665_attrs[] = {
 	&sensor_dev_attr_in1_input.dev_attr.attr,
 	&sensor_dev_attr_in1_min.dev_attr.attr,
 	&sensor_dev_attr_in1_max.dev_attr.attr,
@@ -567,15 +563,14 @@ static struct attribute *smm665_attributes[] = {
 	NULL,
 };
 
-static const struct attribute_group smm665_group = {
-	.attrs = smm665_attributes,
-};
+ATTRIBUTE_GROUPS(smm665);
 
 static int smm665_probe(struct i2c_client *client,
 			const struct i2c_device_id *id)
 {
 	struct i2c_adapter *adapter = client->adapter;
 	struct smm665_data *data;
+	struct device *hwmon_dev;
 	int i, ret;
 
 	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA
@@ -592,6 +587,7 @@ static int smm665_probe(struct i2c_client *client,
 	i2c_set_clientdata(client, data);
 	mutex_init(&data->update_lock);
 
+	data->client = client;
 	data->type = id->driver_data;
 	data->cmdreg = i2c_new_dummy(adapter, (client->addr & ~SMM665_REGMASK)
 				     | SMM665_CMDREG_BASE);
@@ -662,21 +658,16 @@ static int smm665_probe(struct i2c_client *client,
 			data->alarm_max_limit[i] = smm665_convert(val, i);
 	}
 
-	/* Register sysfs hooks */
-	ret = sysfs_create_group(&client->dev.kobj, &smm665_group);
-	if (ret)
+	hwmon_dev = devm_hwmon_device_register_with_groups(&client->dev,
+							   client->name, data,
+							   smm665_groups);
+	if (IS_ERR(hwmon_dev)) {
+		ret = PTR_ERR(hwmon_dev);
 		goto out_unregister;
-
-	data->hwmon_dev = hwmon_device_register(&client->dev);
-	if (IS_ERR(data->hwmon_dev)) {
-		ret = PTR_ERR(data->hwmon_dev);
-		goto out_remove_group;
 	}
 
 	return 0;
 
-out_remove_group:
-	sysfs_remove_group(&client->dev.kobj, &smm665_group);
 out_unregister:
 	i2c_unregister_device(data->cmdreg);
 	return ret;
@@ -687,9 +678,6 @@ static int smm665_remove(struct i2c_client *client)
 	struct smm665_data *data = i2c_get_clientdata(client);
 
 	i2c_unregister_device(data->cmdreg);
-	hwmon_device_unregister(data->hwmon_dev);
-	sysfs_remove_group(&client->dev.kobj, &smm665_group);
-
 	return 0;
 }
 

commit f44e5c5cf9303daac57be0aa01bc0e8f29f1b9bd
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Tue Feb 11 21:38:31 2014 -0800

    hwmon: (smm665): Return error from i2c_smbus_read_word_swapped
    
    There is no reason to replace one error code with another,
    and returning -1 as error code is wrong anyway.
    
    Smatch log:
    drivers/hwmon/smm665.c:225 smm665_read_adc() info: why not propagate 'rv'
    from i2c_smbus_read_word_swapped() instead of (-1)?
    
    Reviewed-by: Jean Delvare <jdelvare@suse.de>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/hwmon/smm665.c b/drivers/hwmon/smm665.c
index d9e1b7de78da..4ef5802df6d8 100644
--- a/drivers/hwmon/smm665.c
+++ b/drivers/hwmon/smm665.c
@@ -222,7 +222,7 @@ static int smm665_read_adc(struct smm665_data *data, int adc)
 	rv = i2c_smbus_read_word_swapped(client, 0);
 	if (rv < 0) {
 		dev_dbg(&client->dev, "Failed to read ADC value: error %d", rv);
-		return -1;
+		return rv;
 	}
 	/*
 	 * Validate/verify readback adc channel (in bit 11..14).

commit dcd8f39230b9f724ba4f55f14ed2bb8119204385
Author: Jean Delvare <khali@linux-fr.org>
Date:   Wed Oct 10 15:25:56 2012 +0200

    hwmon: Add missing inclusions of <linux/jiffies.h>
    
    Many hwmon drivers use jiffies but omit the inclusion of the header
    file. Fix that, and also fix one driver which was including the header
    file but didn't need it.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: Luca Tettamanti <kronos.it@gmail.com>
    Cc: Marc Hulsman <m.hulsman@tudelft.nl>
    Cc: Rudolf Marek <r.marek@assembler.cz>

diff --git a/drivers/hwmon/smm665.c b/drivers/hwmon/smm665.c
index cbc51fb30dba..d9e1b7de78da 100644
--- a/drivers/hwmon/smm665.c
+++ b/drivers/hwmon/smm665.c
@@ -24,6 +24,7 @@
 #include <linux/hwmon.h>
 #include <linux/hwmon-sysfs.h>
 #include <linux/delay.h>
+#include <linux/jiffies.h>
 
 /* Internal reference voltage (VREF, x 1000 */
 #define SMM665_VREF_ADC_X1000	1250

commit b8a5a7cebded23eb311b8db73a11ed23b4135170
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Wed Feb 22 08:56:48 2012 -0800

    hwmon: (smm665) Convert to use devm_kzalloc
    
    Marginally less code and eliminate the possibility of memory leaks.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/hwmon/smm665.c b/drivers/hwmon/smm665.c
index 5877078aaca5..cbc51fb30dba 100644
--- a/drivers/hwmon/smm665.c
+++ b/drivers/hwmon/smm665.c
@@ -584,10 +584,9 @@ static int smm665_probe(struct i2c_client *client,
 	if (i2c_smbus_read_byte_data(client, SMM665_ADOC_ENABLE) < 0)
 		return -ENODEV;
 
-	ret = -ENOMEM;
-	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	data = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);
 	if (!data)
-		goto out_return;
+		return -ENOMEM;
 
 	i2c_set_clientdata(client, data);
 	mutex_init(&data->update_lock);
@@ -596,7 +595,7 @@ static int smm665_probe(struct i2c_client *client,
 	data->cmdreg = i2c_new_dummy(adapter, (client->addr & ~SMM665_REGMASK)
 				     | SMM665_CMDREG_BASE);
 	if (!data->cmdreg)
-		goto out_kfree;
+		return -ENOMEM;
 
 	switch (data->type) {
 	case smm465:
@@ -679,9 +678,6 @@ static int smm665_probe(struct i2c_client *client,
 	sysfs_remove_group(&client->dev.kobj, &smm665_group);
 out_unregister:
 	i2c_unregister_device(data->cmdreg);
-out_kfree:
-	kfree(data);
-out_return:
 	return ret;
 }
 
@@ -693,8 +689,6 @@ static int smm665_remove(struct i2c_client *client)
 	hwmon_device_unregister(data->hwmon_dev);
 	sysfs_remove_group(&client->dev.kobj, &smm665_group);
 
-	kfree(data);
-
 	return 0;
 }
 

commit 3c22e2326015e79822837aaa44eaf15249f8af7b
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Fri Jan 20 09:34:50 2012 -0800

    hwmon: (smm665) Fix checkpatch error
    
    Fix:
    ERROR: Macros with complex values should be enclosed in parenthesis
    
    Also updated multi-line comments to follow Documentation/CodingStyle.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/hwmon/smm665.c b/drivers/hwmon/smm665.c
index 24382c735e56..5877078aaca5 100644
--- a/drivers/hwmon/smm665.c
+++ b/drivers/hwmon/smm665.c
@@ -124,9 +124,9 @@ enum chips { smm465, smm665, smm665c, smm764, smm766 };
 #define SMM665_AIN_ADC_TO_VOLTS(adc)   ((adc) * vref / 512)
 
 /* Temp Sensor */
-#define SMM665_TEMP_ADC_TO_CELSIUS(adc) ((adc) <= 511) ?		   \
+#define SMM665_TEMP_ADC_TO_CELSIUS(adc) (((adc) <= 511) ?		   \
 					 ((int)(adc) * 1000 / 4) :	   \
-					 (((int)(adc) - 0x400) * 1000 / 4)
+					 (((int)(adc) - 0x400) * 1000 / 4))
 
 #define SMM665_NUM_ADC		11
 
@@ -389,7 +389,8 @@ SMM665_SHOW(max);
 SMM665_SHOW(lcrit);
 SMM665_SHOW(crit);
 
-/* These macros are used below in constructing device attribute objects
+/*
+ * These macros are used below in constructing device attribute objects
  * for use with sysfs_create_group() to make a sysfs device file
  * for each register.
  */

commit f0967eea80ec2a19a4fe1ad27e3ff1b22c79a3c7
Author: Axel Lin <axel.lin@gmail.com>
Date:   Fri Jan 20 15:38:18 2012 +0800

    hwmon: convert drivers/hwmon/* to use module_i2c_driver()
    
    This patch converts the drivers in drivers/hwmon/* to use the
    module_i2c_driver() macro which makes the code smaller and a bit simpler.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Cc: Corentin Labbe <corentin.labbe@geomatys.fr>
    Cc: Dirk Eibach <eibach@gdsys.de>
    Cc: "Mark M. Hoffman" <mhoffman@lightlink.com>
    Cc: Steve Glendinning <steve.glendinning@smsc.com>
    Cc: Riku Voipio <riku.voipio@iki.fi>
    Cc: Guillaume Ligneul <guillaume.ligneul@gmail.com>
    Cc: David George <david.george@ska.ac.za>
    Cc: "Hans J. Koch" <hjk@hansjkoch.de>
    Cc: Marc Hulsman <m.hulsman@tudelft.nl>
    Cc: Rudolf Marek <r.marek@assembler.cz>
    Signed-off-by: Guenter Roeck <guenter.roeck@ericsson.com>

diff --git a/drivers/hwmon/smm665.c b/drivers/hwmon/smm665.c
index 1b4301f93787..24382c735e56 100644
--- a/drivers/hwmon/smm665.c
+++ b/drivers/hwmon/smm665.c
@@ -718,19 +718,8 @@ static struct i2c_driver smm665_driver = {
 	.id_table = smm665_id,
 };
 
-static int __init smm665_init(void)
-{
-	return i2c_add_driver(&smm665_driver);
-}
-
-static void __exit smm665_exit(void)
-{
-	i2c_del_driver(&smm665_driver);
-}
+module_i2c_driver(smm665_driver);
 
 MODULE_AUTHOR("Guenter Roeck");
 MODULE_DESCRIPTION("SMM665 driver");
 MODULE_LICENSE("GPL");
-
-module_init(smm665_init);
-module_exit(smm665_exit);

commit b2ae8f87f48d40b720ec011499e99bdf5c519c82
Author: Frans Meulenbroeks <fransmeulenbroeks@gmail.com>
Date:   Sun Jan 8 19:34:07 2012 +0100

    hwmon: (smm665) fix checkpatch issues
    
    fixed:
    WARNING: please, no spaces at the start of a line
    #379: FILE: smm665.c:379:
    +  static ssize_t smm665_show_##what(struct device *dev, \$
    
    Signed-off-by: Frans Meulenbroeks <fransmeulenbroeks@gmail.com>
    Signed-off-by: Guenter Roeck <guenter.roeck@ericsson.com>

diff --git a/drivers/hwmon/smm665.c b/drivers/hwmon/smm665.c
index 411638181fd8..1b4301f93787 100644
--- a/drivers/hwmon/smm665.c
+++ b/drivers/hwmon/smm665.c
@@ -376,7 +376,7 @@ static ssize_t smm665_show_input(struct device *dev,
 }
 
 #define SMM665_SHOW(what) \
-  static ssize_t smm665_show_##what(struct device *dev, \
+static ssize_t smm665_show_##what(struct device *dev, \
 				    struct device_attribute *da, char *buf) \
 { \
 	struct sensor_device_attribute *attr = to_sensor_dev_attr(da); \

commit 90f4102ce59226954edbe960b2434d8b3da5f086
Author: Jean Delvare <khali@linux-fr.org>
Date:   Fri Nov 4 12:00:47 2011 +0100

    hwmon: Use i2c_smbus_{read,write}_word_swapped
    
    Make use of the new i2c_smbus_{read,write}_word_swapped functions.
    This makes the driver code more compact and readable. It also ensures
    proper error handling.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Jonathan Cameron <jic23@cam.ac.uk>
    Acked-by: Guenter Roeck <guenter.roeck@ericsson.com>
    Cc: Dirk Eibach <eibach@gdsys.de>
    Cc: "Mark M. Hoffman" <mhoffman@lightlink.com>
    Cc: Guillaume Ligneul <guillaume.ligneul@gmail.com>

diff --git a/drivers/hwmon/smm665.c b/drivers/hwmon/smm665.c
index 425df5bccd45..411638181fd8 100644
--- a/drivers/hwmon/smm665.c
+++ b/drivers/hwmon/smm665.c
@@ -214,33 +214,26 @@ static int smm665_read_adc(struct smm665_data *data, int adc)
 	 *
 	 * Neither i2c_smbus_read_byte() nor
 	 * i2c_smbus_read_block_data() worked here,
-	 * so use i2c_smbus_read_word_data() instead.
+	 * so use i2c_smbus_read_word_swapped() instead.
 	 * We could also try to use i2c_master_recv(),
 	 * but that is not always supported.
 	 */
-	rv = i2c_smbus_read_word_data(client, 0);
+	rv = i2c_smbus_read_word_swapped(client, 0);
 	if (rv < 0) {
 		dev_dbg(&client->dev, "Failed to read ADC value: error %d", rv);
 		return -1;
 	}
 	/*
 	 * Validate/verify readback adc channel (in bit 11..14).
-	 * High byte is in lower 8 bit of rv, so only shift by 3.
 	 */
-	radc = (rv >> 3) & 0x0f;
+	radc = (rv >> 11) & 0x0f;
 	if (radc != adc) {
 		dev_dbg(&client->dev, "Unexpected RADC: Expected %d got %d",
 			adc, radc);
 		return -EIO;
 	}
-	/*
-	 * Chip replies with H/L, while SMBus expects L/H.
-	 * Thus, byte order is reversed, and we have to swap
-	 * the result.
-	 */
-	rv = swab16(rv) & SMM665_ADC_MASK;
 
-	return rv;
+	return rv & SMM665_ADC_MASK;
 }
 
 static struct smm665_data *smm665_update_device(struct device *dev)

commit 920fa1ffce48d36d7e7bc54eb38c58313bc0a667
Author: Guenter Roeck <guenter.roeck@ericsson.com>
Date:   Mon Aug 9 17:21:06 2010 -0700

    hwmon: driver for SMM665 Six-Channel Active DC Output Controller/Monitor
    
    This driver adds support for the monitoring features of the Summit
    Microelectronics SMM665 Six-Channel Active DC Output Controller/Monitor.
    
    Signed-off-by: Guenter Roeck <guenter.roeck@ericsson.com>
    Acked-by: Jonathan Cameron <jic23@cam.ac.uk>
    Cc: Jean Delvare <khali@linux-fr.org>
    Cc: Hans de Goede <hdegoede@redhat.com>
    Cc: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Cc: Samuel Ortiz <sameo@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/hwmon/smm665.c b/drivers/hwmon/smm665.c
new file mode 100644
index 000000000000..425df5bccd45
--- /dev/null
+++ b/drivers/hwmon/smm665.c
@@ -0,0 +1,743 @@
+/*
+ * Driver for SMM665 Power Controller / Monitor
+ *
+ * Copyright (C) 2010 Ericsson AB.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This driver should also work for SMM465, SMM764, and SMM766, but is untested
+ * for those chips. Only monitoring functionality is implemented.
+ *
+ * Datasheets:
+ * http://www.summitmicro.com/prod_select/summary/SMM665/SMM665B_2089_20.pdf
+ * http://www.summitmicro.com/prod_select/summary/SMM766B/SMM766B_2122.pdf
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/delay.h>
+
+/* Internal reference voltage (VREF, x 1000 */
+#define SMM665_VREF_ADC_X1000	1250
+
+/* module parameters */
+static int vref = SMM665_VREF_ADC_X1000;
+module_param(vref, int, 0);
+MODULE_PARM_DESC(vref, "Reference voltage in mV");
+
+enum chips { smm465, smm665, smm665c, smm764, smm766 };
+
+/*
+ * ADC channel addresses
+ */
+#define	SMM665_MISC16_ADC_DATA_A	0x00
+#define	SMM665_MISC16_ADC_DATA_B	0x01
+#define	SMM665_MISC16_ADC_DATA_C	0x02
+#define	SMM665_MISC16_ADC_DATA_D	0x03
+#define	SMM665_MISC16_ADC_DATA_E	0x04
+#define	SMM665_MISC16_ADC_DATA_F	0x05
+#define	SMM665_MISC16_ADC_DATA_VDD	0x06
+#define	SMM665_MISC16_ADC_DATA_12V	0x07
+#define	SMM665_MISC16_ADC_DATA_INT_TEMP	0x08
+#define	SMM665_MISC16_ADC_DATA_AIN1	0x09
+#define	SMM665_MISC16_ADC_DATA_AIN2	0x0a
+
+/*
+ * Command registers
+ */
+#define	SMM665_MISC8_CMD_STS		0x80
+#define	SMM665_MISC8_STATUS1		0x81
+#define	SMM665_MISC8_STATUSS2		0x82
+#define	SMM665_MISC8_IO_POLARITY	0x83
+#define	SMM665_MISC8_PUP_POLARITY	0x84
+#define	SMM665_MISC8_ADOC_STATUS1	0x85
+#define	SMM665_MISC8_ADOC_STATUS2	0x86
+#define	SMM665_MISC8_WRITE_PROT		0x87
+#define	SMM665_MISC8_STS_TRACK		0x88
+
+/*
+ * Configuration registers and register groups
+ */
+#define SMM665_ADOC_ENABLE		0x0d
+#define SMM665_LIMIT_BASE		0x80	/* First limit register */
+
+/*
+ * Limit register bit masks
+ */
+#define SMM665_TRIGGER_RST		0x8000
+#define SMM665_TRIGGER_HEALTHY		0x4000
+#define SMM665_TRIGGER_POWEROFF		0x2000
+#define SMM665_TRIGGER_SHUTDOWN		0x1000
+#define SMM665_ADC_MASK			0x03ff
+
+#define smm665_is_critical(lim)	((lim) & (SMM665_TRIGGER_RST \
+					| SMM665_TRIGGER_POWEROFF \
+					| SMM665_TRIGGER_SHUTDOWN))
+/*
+ * Fault register bit definitions
+ * Values are merged from status registers 1/2,
+ * with status register 1 providing the upper 8 bits.
+ */
+#define SMM665_FAULT_A		0x0001
+#define SMM665_FAULT_B		0x0002
+#define SMM665_FAULT_C		0x0004
+#define SMM665_FAULT_D		0x0008
+#define SMM665_FAULT_E		0x0010
+#define SMM665_FAULT_F		0x0020
+#define SMM665_FAULT_VDD	0x0040
+#define SMM665_FAULT_12V	0x0080
+#define SMM665_FAULT_TEMP	0x0100
+#define SMM665_FAULT_AIN1	0x0200
+#define SMM665_FAULT_AIN2	0x0400
+
+/*
+ * I2C Register addresses
+ *
+ * The configuration register needs to be the configured base register.
+ * The command/status register address is derived from it.
+ */
+#define SMM665_REGMASK		0x78
+#define SMM665_CMDREG_BASE	0x48
+#define SMM665_CONFREG_BASE	0x50
+
+/*
+ *  Equations given by chip manufacturer to calculate voltage/temperature values
+ *  vref = Reference voltage on VREF_ADC pin (module parameter)
+ *  adc  = 10bit ADC value read back from registers
+ */
+
+/* Voltage A-F and VDD */
+#define SMM665_VMON_ADC_TO_VOLTS(adc)  ((adc) * vref / 256)
+
+/* Voltage 12VIN */
+#define SMM665_12VIN_ADC_TO_VOLTS(adc) ((adc) * vref * 3 / 256)
+
+/* Voltage AIN1, AIN2 */
+#define SMM665_AIN_ADC_TO_VOLTS(adc)   ((adc) * vref / 512)
+
+/* Temp Sensor */
+#define SMM665_TEMP_ADC_TO_CELSIUS(adc) ((adc) <= 511) ?		   \
+					 ((int)(adc) * 1000 / 4) :	   \
+					 (((int)(adc) - 0x400) * 1000 / 4)
+
+#define SMM665_NUM_ADC		11
+
+/*
+ * Chip dependent ADC conversion time, in uS
+ */
+#define SMM665_ADC_WAIT_SMM665	70
+#define SMM665_ADC_WAIT_SMM766	185
+
+struct smm665_data {
+	enum chips type;
+	int conversion_time;		/* ADC conversion time */
+	struct device *hwmon_dev;
+	struct mutex update_lock;
+	bool valid;
+	unsigned long last_updated;	/* in jiffies */
+	u16 adc[SMM665_NUM_ADC];	/* adc values (raw) */
+	u16 faults;			/* fault status */
+	/* The following values are in mV */
+	int critical_min_limit[SMM665_NUM_ADC];
+	int alarm_min_limit[SMM665_NUM_ADC];
+	int critical_max_limit[SMM665_NUM_ADC];
+	int alarm_max_limit[SMM665_NUM_ADC];
+	struct i2c_client *cmdreg;
+};
+
+/*
+ * smm665_read16()
+ *
+ * Read 16 bit value from <reg>, <reg+1>. Upper 8 bits are in <reg>.
+ */
+static int smm665_read16(struct i2c_client *client, int reg)
+{
+	int rv, val;
+
+	rv = i2c_smbus_read_byte_data(client, reg);
+	if (rv < 0)
+		return rv;
+	val = rv << 8;
+	rv = i2c_smbus_read_byte_data(client, reg + 1);
+	if (rv < 0)
+		return rv;
+	val |= rv;
+	return val;
+}
+
+/*
+ * Read adc value.
+ */
+static int smm665_read_adc(struct smm665_data *data, int adc)
+{
+	struct i2c_client *client = data->cmdreg;
+	int rv;
+	int radc;
+
+	/*
+	 * Algorithm for reading ADC, per SMM665 datasheet
+	 *
+	 *  {[S][addr][W][Ack]} {[offset][Ack]} {[S][addr][R][Nack]}
+	 * [wait conversion time]
+	 *  {[S][addr][R][Ack]} {[datahi][Ack]} {[datalo][Ack][P]}
+	 *
+	 * To implement the first part of this exchange,
+	 * do a full read transaction and expect a failure/Nack.
+	 * This sets up the address pointer on the SMM665
+	 * and starts the ADC conversion.
+	 * Then do a two-byte read transaction.
+	 */
+	rv = i2c_smbus_read_byte_data(client, adc << 3);
+	if (rv != -ENXIO) {
+		/*
+		 * We expect ENXIO to reflect NACK
+		 * (per Documentation/i2c/fault-codes).
+		 * Everything else is an error.
+		 */
+		dev_dbg(&client->dev,
+			"Unexpected return code %d when setting ADC index", rv);
+		return (rv < 0) ? rv : -EIO;
+	}
+
+	udelay(data->conversion_time);
+
+	/*
+	 * Now read two bytes.
+	 *
+	 * Neither i2c_smbus_read_byte() nor
+	 * i2c_smbus_read_block_data() worked here,
+	 * so use i2c_smbus_read_word_data() instead.
+	 * We could also try to use i2c_master_recv(),
+	 * but that is not always supported.
+	 */
+	rv = i2c_smbus_read_word_data(client, 0);
+	if (rv < 0) {
+		dev_dbg(&client->dev, "Failed to read ADC value: error %d", rv);
+		return -1;
+	}
+	/*
+	 * Validate/verify readback adc channel (in bit 11..14).
+	 * High byte is in lower 8 bit of rv, so only shift by 3.
+	 */
+	radc = (rv >> 3) & 0x0f;
+	if (radc != adc) {
+		dev_dbg(&client->dev, "Unexpected RADC: Expected %d got %d",
+			adc, radc);
+		return -EIO;
+	}
+	/*
+	 * Chip replies with H/L, while SMBus expects L/H.
+	 * Thus, byte order is reversed, and we have to swap
+	 * the result.
+	 */
+	rv = swab16(rv) & SMM665_ADC_MASK;
+
+	return rv;
+}
+
+static struct smm665_data *smm665_update_device(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct smm665_data *data = i2c_get_clientdata(client);
+	struct smm665_data *ret = data;
+
+	mutex_lock(&data->update_lock);
+
+	if (time_after(jiffies, data->last_updated + HZ) || !data->valid) {
+		int i, val;
+
+		/*
+		 * read status registers
+		 */
+		val = smm665_read16(client, SMM665_MISC8_STATUS1);
+		if (unlikely(val < 0)) {
+			ret = ERR_PTR(val);
+			goto abort;
+		}
+		data->faults = val;
+
+		/* Read adc registers */
+		for (i = 0; i < SMM665_NUM_ADC; i++) {
+			val = smm665_read_adc(data, i);
+			if (unlikely(val < 0)) {
+				ret = ERR_PTR(val);
+				goto abort;
+			}
+			data->adc[i] = val;
+		}
+		data->last_updated = jiffies;
+		data->valid = 1;
+	}
+abort:
+	mutex_unlock(&data->update_lock);
+	return ret;
+}
+
+/* Return converted value from given adc */
+static int smm665_convert(u16 adcval, int index)
+{
+	int val = 0;
+
+	switch (index) {
+	case SMM665_MISC16_ADC_DATA_12V:
+		val = SMM665_12VIN_ADC_TO_VOLTS(adcval & SMM665_ADC_MASK);
+		break;
+
+	case SMM665_MISC16_ADC_DATA_VDD:
+	case SMM665_MISC16_ADC_DATA_A:
+	case SMM665_MISC16_ADC_DATA_B:
+	case SMM665_MISC16_ADC_DATA_C:
+	case SMM665_MISC16_ADC_DATA_D:
+	case SMM665_MISC16_ADC_DATA_E:
+	case SMM665_MISC16_ADC_DATA_F:
+		val = SMM665_VMON_ADC_TO_VOLTS(adcval & SMM665_ADC_MASK);
+		break;
+
+	case SMM665_MISC16_ADC_DATA_AIN1:
+	case SMM665_MISC16_ADC_DATA_AIN2:
+		val = SMM665_AIN_ADC_TO_VOLTS(adcval & SMM665_ADC_MASK);
+		break;
+
+	case SMM665_MISC16_ADC_DATA_INT_TEMP:
+		val = SMM665_TEMP_ADC_TO_CELSIUS(adcval & SMM665_ADC_MASK);
+		break;
+
+	default:
+		/* If we get here, the developer messed up */
+		WARN_ON_ONCE(1);
+		break;
+	}
+
+	return val;
+}
+
+static int smm665_get_min(struct device *dev, int index)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct smm665_data *data = i2c_get_clientdata(client);
+
+	return data->alarm_min_limit[index];
+}
+
+static int smm665_get_max(struct device *dev, int index)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct smm665_data *data = i2c_get_clientdata(client);
+
+	return data->alarm_max_limit[index];
+}
+
+static int smm665_get_lcrit(struct device *dev, int index)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct smm665_data *data = i2c_get_clientdata(client);
+
+	return data->critical_min_limit[index];
+}
+
+static int smm665_get_crit(struct device *dev, int index)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct smm665_data *data = i2c_get_clientdata(client);
+
+	return data->critical_max_limit[index];
+}
+
+static ssize_t smm665_show_crit_alarm(struct device *dev,
+				      struct device_attribute *da, char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct smm665_data *data = smm665_update_device(dev);
+	int val = 0;
+
+	if (IS_ERR(data))
+		return PTR_ERR(data);
+
+	if (data->faults & (1 << attr->index))
+		val = 1;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", val);
+}
+
+static ssize_t smm665_show_input(struct device *dev,
+				 struct device_attribute *da, char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct smm665_data *data = smm665_update_device(dev);
+	int adc = attr->index;
+	int val;
+
+	if (IS_ERR(data))
+		return PTR_ERR(data);
+
+	val = smm665_convert(data->adc[adc], adc);
+	return snprintf(buf, PAGE_SIZE, "%d\n", val);
+}
+
+#define SMM665_SHOW(what) \
+  static ssize_t smm665_show_##what(struct device *dev, \
+				    struct device_attribute *da, char *buf) \
+{ \
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da); \
+	const int val = smm665_get_##what(dev, attr->index); \
+	return snprintf(buf, PAGE_SIZE, "%d\n", val); \
+}
+
+SMM665_SHOW(min);
+SMM665_SHOW(max);
+SMM665_SHOW(lcrit);
+SMM665_SHOW(crit);
+
+/* These macros are used below in constructing device attribute objects
+ * for use with sysfs_create_group() to make a sysfs device file
+ * for each register.
+ */
+
+#define SMM665_ATTR(name, type, cmd_idx) \
+	static SENSOR_DEVICE_ATTR(name##_##type, S_IRUGO, \
+				  smm665_show_##type, NULL, cmd_idx)
+
+/* Construct a sensor_device_attribute structure for each register */
+
+/* Input voltages */
+SMM665_ATTR(in1, input, SMM665_MISC16_ADC_DATA_12V);
+SMM665_ATTR(in2, input, SMM665_MISC16_ADC_DATA_VDD);
+SMM665_ATTR(in3, input, SMM665_MISC16_ADC_DATA_A);
+SMM665_ATTR(in4, input, SMM665_MISC16_ADC_DATA_B);
+SMM665_ATTR(in5, input, SMM665_MISC16_ADC_DATA_C);
+SMM665_ATTR(in6, input, SMM665_MISC16_ADC_DATA_D);
+SMM665_ATTR(in7, input, SMM665_MISC16_ADC_DATA_E);
+SMM665_ATTR(in8, input, SMM665_MISC16_ADC_DATA_F);
+SMM665_ATTR(in9, input, SMM665_MISC16_ADC_DATA_AIN1);
+SMM665_ATTR(in10, input, SMM665_MISC16_ADC_DATA_AIN2);
+
+/* Input voltages min */
+SMM665_ATTR(in1, min, SMM665_MISC16_ADC_DATA_12V);
+SMM665_ATTR(in2, min, SMM665_MISC16_ADC_DATA_VDD);
+SMM665_ATTR(in3, min, SMM665_MISC16_ADC_DATA_A);
+SMM665_ATTR(in4, min, SMM665_MISC16_ADC_DATA_B);
+SMM665_ATTR(in5, min, SMM665_MISC16_ADC_DATA_C);
+SMM665_ATTR(in6, min, SMM665_MISC16_ADC_DATA_D);
+SMM665_ATTR(in7, min, SMM665_MISC16_ADC_DATA_E);
+SMM665_ATTR(in8, min, SMM665_MISC16_ADC_DATA_F);
+SMM665_ATTR(in9, min, SMM665_MISC16_ADC_DATA_AIN1);
+SMM665_ATTR(in10, min, SMM665_MISC16_ADC_DATA_AIN2);
+
+/* Input voltages max */
+SMM665_ATTR(in1, max, SMM665_MISC16_ADC_DATA_12V);
+SMM665_ATTR(in2, max, SMM665_MISC16_ADC_DATA_VDD);
+SMM665_ATTR(in3, max, SMM665_MISC16_ADC_DATA_A);
+SMM665_ATTR(in4, max, SMM665_MISC16_ADC_DATA_B);
+SMM665_ATTR(in5, max, SMM665_MISC16_ADC_DATA_C);
+SMM665_ATTR(in6, max, SMM665_MISC16_ADC_DATA_D);
+SMM665_ATTR(in7, max, SMM665_MISC16_ADC_DATA_E);
+SMM665_ATTR(in8, max, SMM665_MISC16_ADC_DATA_F);
+SMM665_ATTR(in9, max, SMM665_MISC16_ADC_DATA_AIN1);
+SMM665_ATTR(in10, max, SMM665_MISC16_ADC_DATA_AIN2);
+
+/* Input voltages lcrit */
+SMM665_ATTR(in1, lcrit, SMM665_MISC16_ADC_DATA_12V);
+SMM665_ATTR(in2, lcrit, SMM665_MISC16_ADC_DATA_VDD);
+SMM665_ATTR(in3, lcrit, SMM665_MISC16_ADC_DATA_A);
+SMM665_ATTR(in4, lcrit, SMM665_MISC16_ADC_DATA_B);
+SMM665_ATTR(in5, lcrit, SMM665_MISC16_ADC_DATA_C);
+SMM665_ATTR(in6, lcrit, SMM665_MISC16_ADC_DATA_D);
+SMM665_ATTR(in7, lcrit, SMM665_MISC16_ADC_DATA_E);
+SMM665_ATTR(in8, lcrit, SMM665_MISC16_ADC_DATA_F);
+SMM665_ATTR(in9, lcrit, SMM665_MISC16_ADC_DATA_AIN1);
+SMM665_ATTR(in10, lcrit, SMM665_MISC16_ADC_DATA_AIN2);
+
+/* Input voltages crit */
+SMM665_ATTR(in1, crit, SMM665_MISC16_ADC_DATA_12V);
+SMM665_ATTR(in2, crit, SMM665_MISC16_ADC_DATA_VDD);
+SMM665_ATTR(in3, crit, SMM665_MISC16_ADC_DATA_A);
+SMM665_ATTR(in4, crit, SMM665_MISC16_ADC_DATA_B);
+SMM665_ATTR(in5, crit, SMM665_MISC16_ADC_DATA_C);
+SMM665_ATTR(in6, crit, SMM665_MISC16_ADC_DATA_D);
+SMM665_ATTR(in7, crit, SMM665_MISC16_ADC_DATA_E);
+SMM665_ATTR(in8, crit, SMM665_MISC16_ADC_DATA_F);
+SMM665_ATTR(in9, crit, SMM665_MISC16_ADC_DATA_AIN1);
+SMM665_ATTR(in10, crit, SMM665_MISC16_ADC_DATA_AIN2);
+
+/* critical alarms */
+SMM665_ATTR(in1, crit_alarm, SMM665_FAULT_12V);
+SMM665_ATTR(in2, crit_alarm, SMM665_FAULT_VDD);
+SMM665_ATTR(in3, crit_alarm, SMM665_FAULT_A);
+SMM665_ATTR(in4, crit_alarm, SMM665_FAULT_B);
+SMM665_ATTR(in5, crit_alarm, SMM665_FAULT_C);
+SMM665_ATTR(in6, crit_alarm, SMM665_FAULT_D);
+SMM665_ATTR(in7, crit_alarm, SMM665_FAULT_E);
+SMM665_ATTR(in8, crit_alarm, SMM665_FAULT_F);
+SMM665_ATTR(in9, crit_alarm, SMM665_FAULT_AIN1);
+SMM665_ATTR(in10, crit_alarm, SMM665_FAULT_AIN2);
+
+/* Temperature */
+SMM665_ATTR(temp1, input, SMM665_MISC16_ADC_DATA_INT_TEMP);
+SMM665_ATTR(temp1, min, SMM665_MISC16_ADC_DATA_INT_TEMP);
+SMM665_ATTR(temp1, max, SMM665_MISC16_ADC_DATA_INT_TEMP);
+SMM665_ATTR(temp1, lcrit, SMM665_MISC16_ADC_DATA_INT_TEMP);
+SMM665_ATTR(temp1, crit, SMM665_MISC16_ADC_DATA_INT_TEMP);
+SMM665_ATTR(temp1, crit_alarm, SMM665_FAULT_TEMP);
+
+/*
+ * Finally, construct an array of pointers to members of the above objects,
+ * as required for sysfs_create_group()
+ */
+static struct attribute *smm665_attributes[] = {
+	&sensor_dev_attr_in1_input.dev_attr.attr,
+	&sensor_dev_attr_in1_min.dev_attr.attr,
+	&sensor_dev_attr_in1_max.dev_attr.attr,
+	&sensor_dev_attr_in1_lcrit.dev_attr.attr,
+	&sensor_dev_attr_in1_crit.dev_attr.attr,
+	&sensor_dev_attr_in1_crit_alarm.dev_attr.attr,
+
+	&sensor_dev_attr_in2_input.dev_attr.attr,
+	&sensor_dev_attr_in2_min.dev_attr.attr,
+	&sensor_dev_attr_in2_max.dev_attr.attr,
+	&sensor_dev_attr_in2_lcrit.dev_attr.attr,
+	&sensor_dev_attr_in2_crit.dev_attr.attr,
+	&sensor_dev_attr_in2_crit_alarm.dev_attr.attr,
+
+	&sensor_dev_attr_in3_input.dev_attr.attr,
+	&sensor_dev_attr_in3_min.dev_attr.attr,
+	&sensor_dev_attr_in3_max.dev_attr.attr,
+	&sensor_dev_attr_in3_lcrit.dev_attr.attr,
+	&sensor_dev_attr_in3_crit.dev_attr.attr,
+	&sensor_dev_attr_in3_crit_alarm.dev_attr.attr,
+
+	&sensor_dev_attr_in4_input.dev_attr.attr,
+	&sensor_dev_attr_in4_min.dev_attr.attr,
+	&sensor_dev_attr_in4_max.dev_attr.attr,
+	&sensor_dev_attr_in4_lcrit.dev_attr.attr,
+	&sensor_dev_attr_in4_crit.dev_attr.attr,
+	&sensor_dev_attr_in4_crit_alarm.dev_attr.attr,
+
+	&sensor_dev_attr_in5_input.dev_attr.attr,
+	&sensor_dev_attr_in5_min.dev_attr.attr,
+	&sensor_dev_attr_in5_max.dev_attr.attr,
+	&sensor_dev_attr_in5_lcrit.dev_attr.attr,
+	&sensor_dev_attr_in5_crit.dev_attr.attr,
+	&sensor_dev_attr_in5_crit_alarm.dev_attr.attr,
+
+	&sensor_dev_attr_in6_input.dev_attr.attr,
+	&sensor_dev_attr_in6_min.dev_attr.attr,
+	&sensor_dev_attr_in6_max.dev_attr.attr,
+	&sensor_dev_attr_in6_lcrit.dev_attr.attr,
+	&sensor_dev_attr_in6_crit.dev_attr.attr,
+	&sensor_dev_attr_in6_crit_alarm.dev_attr.attr,
+
+	&sensor_dev_attr_in7_input.dev_attr.attr,
+	&sensor_dev_attr_in7_min.dev_attr.attr,
+	&sensor_dev_attr_in7_max.dev_attr.attr,
+	&sensor_dev_attr_in7_lcrit.dev_attr.attr,
+	&sensor_dev_attr_in7_crit.dev_attr.attr,
+	&sensor_dev_attr_in7_crit_alarm.dev_attr.attr,
+
+	&sensor_dev_attr_in8_input.dev_attr.attr,
+	&sensor_dev_attr_in8_min.dev_attr.attr,
+	&sensor_dev_attr_in8_max.dev_attr.attr,
+	&sensor_dev_attr_in8_lcrit.dev_attr.attr,
+	&sensor_dev_attr_in8_crit.dev_attr.attr,
+	&sensor_dev_attr_in8_crit_alarm.dev_attr.attr,
+
+	&sensor_dev_attr_in9_input.dev_attr.attr,
+	&sensor_dev_attr_in9_min.dev_attr.attr,
+	&sensor_dev_attr_in9_max.dev_attr.attr,
+	&sensor_dev_attr_in9_lcrit.dev_attr.attr,
+	&sensor_dev_attr_in9_crit.dev_attr.attr,
+	&sensor_dev_attr_in9_crit_alarm.dev_attr.attr,
+
+	&sensor_dev_attr_in10_input.dev_attr.attr,
+	&sensor_dev_attr_in10_min.dev_attr.attr,
+	&sensor_dev_attr_in10_max.dev_attr.attr,
+	&sensor_dev_attr_in10_lcrit.dev_attr.attr,
+	&sensor_dev_attr_in10_crit.dev_attr.attr,
+	&sensor_dev_attr_in10_crit_alarm.dev_attr.attr,
+
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	&sensor_dev_attr_temp1_min.dev_attr.attr,
+	&sensor_dev_attr_temp1_max.dev_attr.attr,
+	&sensor_dev_attr_temp1_lcrit.dev_attr.attr,
+	&sensor_dev_attr_temp1_crit.dev_attr.attr,
+	&sensor_dev_attr_temp1_crit_alarm.dev_attr.attr,
+
+	NULL,
+};
+
+static const struct attribute_group smm665_group = {
+	.attrs = smm665_attributes,
+};
+
+static int smm665_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	struct smm665_data *data;
+	int i, ret;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA
+				     | I2C_FUNC_SMBUS_WORD_DATA))
+		return -ENODEV;
+
+	if (i2c_smbus_read_byte_data(client, SMM665_ADOC_ENABLE) < 0)
+		return -ENODEV;
+
+	ret = -ENOMEM;
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (!data)
+		goto out_return;
+
+	i2c_set_clientdata(client, data);
+	mutex_init(&data->update_lock);
+
+	data->type = id->driver_data;
+	data->cmdreg = i2c_new_dummy(adapter, (client->addr & ~SMM665_REGMASK)
+				     | SMM665_CMDREG_BASE);
+	if (!data->cmdreg)
+		goto out_kfree;
+
+	switch (data->type) {
+	case smm465:
+	case smm665:
+		data->conversion_time = SMM665_ADC_WAIT_SMM665;
+		break;
+	case smm665c:
+	case smm764:
+	case smm766:
+		data->conversion_time = SMM665_ADC_WAIT_SMM766;
+		break;
+	}
+
+	ret = -ENODEV;
+	if (i2c_smbus_read_byte_data(data->cmdreg, SMM665_MISC8_CMD_STS) < 0)
+		goto out_unregister;
+
+	/*
+	 * Read limits.
+	 *
+	 * Limit registers start with register SMM665_LIMIT_BASE.
+	 * Each channel uses 8 registers, providing four limit values
+	 * per channel. Each limit value requires two registers, with the
+	 * high byte in the first register and the low byte in the second
+	 * register. The first two limits are under limit values, followed
+	 * by two over limit values.
+	 *
+	 * Limit register order matches the ADC register order, so we use
+	 * ADC register defines throughout the code to index limit registers.
+	 *
+	 * We save the first retrieved value both as "critical" and "alarm"
+	 * value. The second value overwrites either the critical or the
+	 * alarm value, depending on its configuration. This ensures that both
+	 * critical and alarm values are initialized, even if both registers are
+	 * configured as critical or non-critical.
+	 */
+	for (i = 0; i < SMM665_NUM_ADC; i++) {
+		int val;
+
+		val = smm665_read16(client, SMM665_LIMIT_BASE + i * 8);
+		if (unlikely(val < 0))
+			goto out_unregister;
+		data->critical_min_limit[i] = data->alarm_min_limit[i]
+		  = smm665_convert(val, i);
+		val = smm665_read16(client, SMM665_LIMIT_BASE + i * 8 + 2);
+		if (unlikely(val < 0))
+			goto out_unregister;
+		if (smm665_is_critical(val))
+			data->critical_min_limit[i] = smm665_convert(val, i);
+		else
+			data->alarm_min_limit[i] = smm665_convert(val, i);
+		val = smm665_read16(client, SMM665_LIMIT_BASE + i * 8 + 4);
+		if (unlikely(val < 0))
+			goto out_unregister;
+		data->critical_max_limit[i] = data->alarm_max_limit[i]
+		  = smm665_convert(val, i);
+		val = smm665_read16(client, SMM665_LIMIT_BASE + i * 8 + 6);
+		if (unlikely(val < 0))
+			goto out_unregister;
+		if (smm665_is_critical(val))
+			data->critical_max_limit[i] = smm665_convert(val, i);
+		else
+			data->alarm_max_limit[i] = smm665_convert(val, i);
+	}
+
+	/* Register sysfs hooks */
+	ret = sysfs_create_group(&client->dev.kobj, &smm665_group);
+	if (ret)
+		goto out_unregister;
+
+	data->hwmon_dev = hwmon_device_register(&client->dev);
+	if (IS_ERR(data->hwmon_dev)) {
+		ret = PTR_ERR(data->hwmon_dev);
+		goto out_remove_group;
+	}
+
+	return 0;
+
+out_remove_group:
+	sysfs_remove_group(&client->dev.kobj, &smm665_group);
+out_unregister:
+	i2c_unregister_device(data->cmdreg);
+out_kfree:
+	kfree(data);
+out_return:
+	return ret;
+}
+
+static int smm665_remove(struct i2c_client *client)
+{
+	struct smm665_data *data = i2c_get_clientdata(client);
+
+	i2c_unregister_device(data->cmdreg);
+	hwmon_device_unregister(data->hwmon_dev);
+	sysfs_remove_group(&client->dev.kobj, &smm665_group);
+
+	kfree(data);
+
+	return 0;
+}
+
+static const struct i2c_device_id smm665_id[] = {
+	{"smm465", smm465},
+	{"smm665", smm665},
+	{"smm665c", smm665c},
+	{"smm764", smm764},
+	{"smm766", smm766},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, smm665_id);
+
+/* This is the driver that will be inserted */
+static struct i2c_driver smm665_driver = {
+	.driver = {
+		   .name = "smm665",
+		   },
+	.probe = smm665_probe,
+	.remove = smm665_remove,
+	.id_table = smm665_id,
+};
+
+static int __init smm665_init(void)
+{
+	return i2c_add_driver(&smm665_driver);
+}
+
+static void __exit smm665_exit(void)
+{
+	i2c_del_driver(&smm665_driver);
+}
+
+MODULE_AUTHOR("Guenter Roeck");
+MODULE_DESCRIPTION("SMM665 driver");
+MODULE_LICENSE("GPL");
+
+module_init(smm665_init);
+module_exit(smm665_exit);
