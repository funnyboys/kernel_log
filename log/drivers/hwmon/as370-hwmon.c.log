commit 09fe787051db0cf84cd9fcf041dbdd2ba416c6dc
Author: kbuild test robot <lkp@intel.com>
Date:   Tue Sep 3 06:47:52 2019 +0200

    hwmon: (as370-hwmon) fix devm_platform_ioremap_resource.cocci warnings
    
     Use devm_platform_ioremap_resource helper which wraps
     platform_get_resource() and devm_ioremap_resource() together.
    
    Generated by: scripts/coccinelle/api/devm_platform_ioremap_resource.cocci
    
    Fixes: 658e687b4218 ("hwmon: Add Synaptics AS370 PVT sensor driver")
    CC: Jisheng Zhang <Jisheng.Zhang@synaptics.com>
    Signed-off-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Julia Lawall <julia.lawall@lip6.fr>
    Reviewed-by: Jisheng Zhang <Jisheng.Zhang@synaptics.com>
    Link: https://lore.kernel.org/r/alpine.DEB.2.21.1909030646180.3228@hadrien
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/hwmon/as370-hwmon.c b/drivers/hwmon/as370-hwmon.c
index 554f03b91bfe..464244ba8d58 100644
--- a/drivers/hwmon/as370-hwmon.c
+++ b/drivers/hwmon/as370-hwmon.c
@@ -103,7 +103,6 @@ static const struct hwmon_chip_info as370_chip_info = {
 
 static int as370_hwmon_probe(struct platform_device *pdev)
 {
-	struct resource *res;
 	struct device *hwmon_dev;
 	struct as370_hwmon *hwmon;
 	struct device *dev = &pdev->dev;
@@ -112,8 +111,7 @@ static int as370_hwmon_probe(struct platform_device *pdev)
 	if (!hwmon)
 		return -ENOMEM;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	hwmon->base = devm_ioremap_resource(&pdev->dev, res);
+	hwmon->base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(hwmon->base))
 		return PTR_ERR(hwmon->base);
 

commit 7548666e6fc3c16a52171689035f181474c45117
Author: Jisheng Zhang <Jisheng.Zhang@synaptics.com>
Date:   Tue Aug 27 03:44:15 2019 +0000

    hwmon: Add Synaptics AS370 PVT sensor driver
    
    Add a new driver for Synaptics AS370 PVT sensors. Currently, only
    temperature is supported.
    
    Signed-off-by: Jisheng Zhang <Jisheng.Zhang@synaptics.com>
    Reviewed-by: Guenter Roeck <linux@roeck-us.net>
    Link: https://lore.kernel.org/r/20190827113259.4fb64a17@xhacker.debian
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/hwmon/as370-hwmon.c b/drivers/hwmon/as370-hwmon.c
new file mode 100644
index 000000000000..554f03b91bfe
--- /dev/null
+++ b/drivers/hwmon/as370-hwmon.c
@@ -0,0 +1,147 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Synaptics AS370 SoC Hardware Monitoring Driver
+ *
+ * Copyright (C) 2018 Synaptics Incorporated
+ * Author: Jisheng Zhang <jszhang@kernel.org>
+ */
+
+#include <linux/bitops.h>
+#include <linux/hwmon.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+
+#define CTRL		0x0
+#define  PD		BIT(0)
+#define  EN		BIT(1)
+#define  T_SEL		BIT(2)
+#define  V_SEL		BIT(3)
+#define  NMOS_SEL	BIT(8)
+#define  PMOS_SEL	BIT(9)
+#define STS		0x4
+#define  BN_MASK	GENMASK(11, 0)
+#define  EOC		BIT(12)
+
+struct as370_hwmon {
+	void __iomem *base;
+};
+
+static void init_pvt(struct as370_hwmon *hwmon)
+{
+	u32 val;
+	void __iomem *addr = hwmon->base + CTRL;
+
+	val = PD;
+	writel_relaxed(val, addr);
+	val |= T_SEL;
+	writel_relaxed(val, addr);
+	val |= EN;
+	writel_relaxed(val, addr);
+	val &= ~PD;
+	writel_relaxed(val, addr);
+}
+
+static int as370_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
+			    u32 attr, int channel, long *temp)
+{
+	int val;
+	struct as370_hwmon *hwmon = dev_get_drvdata(dev);
+
+	switch (attr) {
+	case hwmon_temp_input:
+		val = readl_relaxed(hwmon->base + STS) & BN_MASK;
+		*temp = DIV_ROUND_CLOSEST(val * 251802, 4096) - 85525;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static umode_t
+as370_hwmon_is_visible(const void *data, enum hwmon_sensor_types type,
+		       u32 attr, int channel)
+{
+	if (type != hwmon_temp)
+		return 0;
+
+	switch (attr) {
+	case hwmon_temp_input:
+		return 0444;
+	default:
+		return 0;
+	}
+}
+
+static const u32 as370_hwmon_temp_config[] = {
+	HWMON_T_INPUT,
+	0
+};
+
+static const struct hwmon_channel_info as370_hwmon_temp = {
+	.type = hwmon_temp,
+	.config = as370_hwmon_temp_config,
+};
+
+static const struct hwmon_channel_info *as370_hwmon_info[] = {
+	&as370_hwmon_temp,
+	NULL
+};
+
+static const struct hwmon_ops as370_hwmon_ops = {
+	.is_visible = as370_hwmon_is_visible,
+	.read = as370_hwmon_read,
+};
+
+static const struct hwmon_chip_info as370_chip_info = {
+	.ops = &as370_hwmon_ops,
+	.info = as370_hwmon_info,
+};
+
+static int as370_hwmon_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct device *hwmon_dev;
+	struct as370_hwmon *hwmon;
+	struct device *dev = &pdev->dev;
+
+	hwmon = devm_kzalloc(dev, sizeof(*hwmon), GFP_KERNEL);
+	if (!hwmon)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	hwmon->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(hwmon->base))
+		return PTR_ERR(hwmon->base);
+
+	init_pvt(hwmon);
+
+	hwmon_dev = devm_hwmon_device_register_with_info(dev,
+							 "as370",
+							 hwmon,
+							 &as370_chip_info,
+							 NULL);
+	return PTR_ERR_OR_ZERO(hwmon_dev);
+}
+
+static const struct of_device_id as370_hwmon_match[] = {
+	{ .compatible = "syna,as370-hwmon" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, as370_hwmon_match);
+
+static struct platform_driver as370_hwmon_driver = {
+	.probe = as370_hwmon_probe,
+	.driver = {
+		.name = "as370-hwmon",
+		.of_match_table = as370_hwmon_match,
+	},
+};
+module_platform_driver(as370_hwmon_driver);
+
+MODULE_AUTHOR("Jisheng Zhang<jszhang@kernel.org>");
+MODULE_DESCRIPTION("Synaptics AS370 SoC hardware monitor");
+MODULE_LICENSE("GPL v2");
