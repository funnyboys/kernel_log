commit 8f9508ebbf769268da76dcd47f210ba5218dbcd2
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Mon Jul 22 19:26:08 2019 +0200

    hwmon: (asb100) convert to i2c_new_dummy_device
    
    Move from i2c_new_dummy() to i2c_new_dummy_device(), so we now get an
    ERRPTR which we use in error handling.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Link: https://lore.kernel.org/r/20190722172611.3797-2-wsa+renesas@sang-engineering.com
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index c9fa84b25678..4c609e23a4ef 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -706,21 +706,21 @@ static int asb100_detect_subclients(struct i2c_client *client)
 		goto ERROR_SC_2;
 	}
 
-	data->lm75[0] = i2c_new_dummy(adapter, sc_addr[0]);
-	if (!data->lm75[0]) {
+	data->lm75[0] = i2c_new_dummy_device(adapter, sc_addr[0]);
+	if (IS_ERR(data->lm75[0])) {
 		dev_err(&client->dev,
 			"subclient %d registration at address 0x%x failed.\n",
 			1, sc_addr[0]);
-		err = -ENOMEM;
+		err = PTR_ERR(data->lm75[0]);
 		goto ERROR_SC_2;
 	}
 
-	data->lm75[1] = i2c_new_dummy(adapter, sc_addr[1]);
-	if (!data->lm75[1]) {
+	data->lm75[1] = i2c_new_dummy_device(adapter, sc_addr[1]);
+	if (IS_ERR(data->lm75[1])) {
 		dev_err(&client->dev,
 			"subclient %d registration at address 0x%x failed.\n",
 			2, sc_addr[1]);
-		err = -ENOMEM;
+		err = PTR_ERR(data->lm75[1]);
 		goto ERROR_SC_3;
 	}
 

commit 74ba9207e1adf1966c57450340534ae9742d00af
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 09:19:02 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 61
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      675 mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 441 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520071858.739733335@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 62e191311139..c9fa84b25678 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * asb100.c - Part of lm_sensors, Linux kernel modules for hardware
  *	      monitoring
@@ -9,20 +10,6 @@
  * Copyright (C) 1998 - 2003  Frodo Looijaard <frodol@dds.nl>,
  *			      Philip Edelbrock <phil@netroedge.com>, and
  *			      Mark Studebaker <mdsxyz123@yahoo.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 /*

commit 82e73f7f9538773705dfd8b019760884a695653f
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Thu Dec 22 13:04:36 2016 +0100

    hwmon: (asb100) use permission-specific DEVICE_ATTR variants
    
    Use DEVICE_ATTR_RO for read only attributes and DEVICE_ATTR_RW for
    read/write attributes. This simplifies the source code, improves
    readbility, and reduces the chance of inconsistencies.
    
    The conversion was done automatically using coccinelle. It was validated
    by compiling both the old and the new source code and comparing its text,
    data, and bss size.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    [groeck: Updated description]
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 272fcc837ecc..62e191311139 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -483,25 +483,25 @@ sysfs_temp(3);
 sysfs_temp(4);
 
 /* VID */
-static ssize_t show_vid(struct device *dev, struct device_attribute *attr,
-		char *buf)
+static ssize_t cpu0_vid_show(struct device *dev,
+			     struct device_attribute *attr, char *buf)
 {
 	struct asb100_data *data = asb100_update_device(dev);
 	return sprintf(buf, "%d\n", vid_from_reg(data->vid, data->vrm));
 }
 
-static DEVICE_ATTR(cpu0_vid, S_IRUGO, show_vid, NULL);
+static DEVICE_ATTR_RO(cpu0_vid);
 
 /* VRM */
-static ssize_t show_vrm(struct device *dev, struct device_attribute *attr,
+static ssize_t vrm_show(struct device *dev, struct device_attribute *attr,
 		char *buf)
 {
 	struct asb100_data *data = dev_get_drvdata(dev);
 	return sprintf(buf, "%d\n", data->vrm);
 }
 
-static ssize_t set_vrm(struct device *dev, struct device_attribute *attr,
-		const char *buf, size_t count)
+static ssize_t vrm_store(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count)
 {
 	struct asb100_data *data = dev_get_drvdata(dev);
 	unsigned long val;
@@ -519,16 +519,16 @@ static ssize_t set_vrm(struct device *dev, struct device_attribute *attr,
 }
 
 /* Alarms */
-static DEVICE_ATTR(vrm, S_IRUGO | S_IWUSR, show_vrm, set_vrm);
+static DEVICE_ATTR_RW(vrm);
 
-static ssize_t show_alarms(struct device *dev, struct device_attribute *attr,
+static ssize_t alarms_show(struct device *dev, struct device_attribute *attr,
 		char *buf)
 {
 	struct asb100_data *data = asb100_update_device(dev);
 	return sprintf(buf, "%u\n", data->alarms);
 }
 
-static DEVICE_ATTR(alarms, S_IRUGO, show_alarms, NULL);
+static DEVICE_ATTR_RO(alarms);
 
 static ssize_t show_alarm(struct device *dev, struct device_attribute *attr,
 		char *buf)
@@ -550,15 +550,15 @@ static SENSOR_DEVICE_ATTR(temp2_alarm, S_IRUGO, show_alarm, NULL, 5);
 static SENSOR_DEVICE_ATTR(temp3_alarm, S_IRUGO, show_alarm, NULL, 13);
 
 /* 1 PWM */
-static ssize_t show_pwm1(struct device *dev, struct device_attribute *attr,
+static ssize_t pwm1_show(struct device *dev, struct device_attribute *attr,
 		char *buf)
 {
 	struct asb100_data *data = asb100_update_device(dev);
 	return sprintf(buf, "%d\n", ASB100_PWM_FROM_REG(data->pwm & 0x0f));
 }
 
-static ssize_t set_pwm1(struct device *dev, struct device_attribute *attr,
-		const char *buf, size_t count)
+static ssize_t pwm1_store(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
 {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct asb100_data *data = i2c_get_clientdata(client);
@@ -577,15 +577,16 @@ static ssize_t set_pwm1(struct device *dev, struct device_attribute *attr,
 	return count;
 }
 
-static ssize_t show_pwm_enable1(struct device *dev,
+static ssize_t pwm1_enable_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	struct asb100_data *data = asb100_update_device(dev);
 	return sprintf(buf, "%d\n", (data->pwm & 0x80) ? 1 : 0);
 }
 
-static ssize_t set_pwm_enable1(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t pwm1_enable_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
 {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct asb100_data *data = i2c_get_clientdata(client);
@@ -604,9 +605,8 @@ static ssize_t set_pwm_enable1(struct device *dev,
 	return count;
 }
 
-static DEVICE_ATTR(pwm1, S_IRUGO | S_IWUSR, show_pwm1, set_pwm1);
-static DEVICE_ATTR(pwm1_enable, S_IRUGO | S_IWUSR,
-		show_pwm_enable1, set_pwm_enable1);
+static DEVICE_ATTR_RW(pwm1);
+static DEVICE_ATTR_RW(pwm1_enable);
 
 static struct attribute *asb100_attributes[] = {
 	&sensor_dev_attr_in0_input.dev_attr.attr,

commit db59ac434230c2d6c051bb314f320ad977e6841d
Author: Axel Lin <axel.lin@ingics.com>
Date:   Wed Aug 6 08:21:49 2014 +0800

    hwmon: (asb100) Fix vrm write operation
    
    vrm is an u8, so the written value needs to be limited to [0, 255].
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index f96063680e58..272fcc837ecc 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -510,6 +510,10 @@ static ssize_t set_vrm(struct device *dev, struct device_attribute *attr,
 	err = kstrtoul(buf, 10, &val);
 	if (err)
 		return err;
+
+	if (val > 255)
+		return -EINVAL;
+
 	data->vrm = val;
 	return count;
 }

commit b55f375725ff85aada394da488802b0a3cc99e88
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Thu Jan 10 10:01:24 2013 -0800

    hwmon: Fix checkpatch warning 'quoted string split across lines'
    
    Cc: Corentin Labbe <corentin.labbe@geomatys.fr>
    Cc: Mark M. Hoffman <mhoffman@lightlink.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Juerg Haefliger <juergh@gmail.com>
    Cc: Andreas Herrmann <herrmann.der.user@googlemail.com>
    Cc: Rudolf Marek <r.marek@assembler.cz>
    Cc: Jim Cromie <jim.cromie@gmail.com>
    Cc: Roger Lucas <vt8231@hiddenengine.co.uk>
    Cc: Marc Hulsman <m.hulsman@tudelft.nl>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 6ac612cabda1..f96063680e58 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -55,8 +55,8 @@ static const unsigned short normal_i2c[] = { 0x2d, I2C_CLIENT_END };
 
 static unsigned short force_subclients[4];
 module_param_array(force_subclients, short, NULL, 0);
-MODULE_PARM_DESC(force_subclients, "List of subclient addresses: "
-	"{bus, clientaddr, subclientaddr1, subclientaddr2}");
+MODULE_PARM_DESC(force_subclients,
+	"List of subclient addresses: {bus, clientaddr, subclientaddr1, subclientaddr2}");
 
 /* Voltage IN registers 0-6 */
 #define ASB100_REG_IN(nr)	(0x20 + (nr))
@@ -689,8 +689,8 @@ static int asb100_detect_subclients(struct i2c_client *client)
 		for (i = 2; i <= 3; i++) {
 			if (force_subclients[i] < 0x48 ||
 			    force_subclients[i] > 0x4f) {
-				dev_err(&client->dev, "invalid subclient "
-					"address %d; must be 0x48-0x4f\n",
+				dev_err(&client->dev,
+					"invalid subclient address %d; must be 0x48-0x4f\n",
 					force_subclients[i]);
 				err = -ENODEV;
 				goto ERROR_SC_2;
@@ -708,24 +708,27 @@ static int asb100_detect_subclients(struct i2c_client *client)
 	}
 
 	if (sc_addr[0] == sc_addr[1]) {
-		dev_err(&client->dev, "duplicate addresses 0x%x "
-				"for subclients\n", sc_addr[0]);
+		dev_err(&client->dev,
+			"duplicate addresses 0x%x for subclients\n",
+			sc_addr[0]);
 		err = -ENODEV;
 		goto ERROR_SC_2;
 	}
 
 	data->lm75[0] = i2c_new_dummy(adapter, sc_addr[0]);
 	if (!data->lm75[0]) {
-		dev_err(&client->dev, "subclient %d registration "
-			"at address 0x%x failed.\n", 1, sc_addr[0]);
+		dev_err(&client->dev,
+			"subclient %d registration at address 0x%x failed.\n",
+			1, sc_addr[0]);
 		err = -ENOMEM;
 		goto ERROR_SC_2;
 	}
 
 	data->lm75[1] = i2c_new_dummy(adapter, sc_addr[1]);
 	if (!data->lm75[1]) {
-		dev_err(&client->dev, "subclient %d registration "
-			"at address 0x%x failed.\n", 2, sc_addr[1]);
+		dev_err(&client->dev,
+			"subclient %d registration at address 0x%x failed.\n",
+			2, sc_addr[1]);
 		err = -ENOMEM;
 		goto ERROR_SC_3;
 	}

commit 2a844c148e1f714ebf42cb96e1b172ce394c36c9
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Wed Jan 9 08:09:34 2013 -0800

    hwmon: Replace SENSORS_LIMIT with clamp_val
    
    SENSORS_LIMIT and the generic clamp_val have the same functionality,
    and clamp_val is more efficient.
    
    This patch reduces text size by 9052 bytes and bss size by 11624 bytes
    for x86_64 builds.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Acked-by: George Joseph <george.joseph@fairview5.com>
    Acked-by: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 520e5bf4f76d..6ac612cabda1 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -114,7 +114,7 @@ static const u16 asb100_reg_temp_hyst[]	= {0, 0x3a, 0x153, 0x253, 0x19};
  */
 static u8 IN_TO_REG(unsigned val)
 {
-	unsigned nval = SENSORS_LIMIT(val, ASB100_IN_MIN, ASB100_IN_MAX);
+	unsigned nval = clamp_val(val, ASB100_IN_MIN, ASB100_IN_MAX);
 	return (nval + 8) / 16;
 }
 
@@ -129,8 +129,8 @@ static u8 FAN_TO_REG(long rpm, int div)
 		return 0;
 	if (rpm == 0)
 		return 255;
-	rpm = SENSORS_LIMIT(rpm, 1, 1000000);
-	return SENSORS_LIMIT((1350000 + rpm * div / 2) / (rpm * div), 1, 254);
+	rpm = clamp_val(rpm, 1, 1000000);
+	return clamp_val((1350000 + rpm * div / 2) / (rpm * div), 1, 254);
 }
 
 static int FAN_FROM_REG(u8 val, int div)
@@ -148,7 +148,7 @@ static int FAN_FROM_REG(u8 val, int div)
  */
 static u8 TEMP_TO_REG(long temp)
 {
-	int ntemp = SENSORS_LIMIT(temp, ASB100_TEMP_MIN, ASB100_TEMP_MAX);
+	int ntemp = clamp_val(temp, ASB100_TEMP_MIN, ASB100_TEMP_MAX);
 	ntemp += (ntemp < 0 ? -500 : 500);
 	return (u8)(ntemp / 1000);
 }
@@ -164,7 +164,7 @@ static int TEMP_FROM_REG(u8 reg)
  */
 static u8 ASB100_PWM_TO_REG(int pwm)
 {
-	pwm = SENSORS_LIMIT(pwm, 0, 255);
+	pwm = clamp_val(pwm, 0, 255);
 	return (u8)(pwm / 16);
 }
 

commit 4101ece3a226e68a5335dd8a15c7ab8663972b81
Author: Jean Delvare <khali@linux-fr.org>
Date:   Mon Nov 5 21:54:40 2012 +0100

    hwmon: Fix chip feature table headers
    
    These got broken by recent patches fixing checkpatch warnings in these
    drivers. The trick is that the patches themselves looked good, but the
    source files after applying them do not. That's why I am not a big fan
    of using tabs inside comments.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index a227be47149f..520e5bf4f76d 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -32,7 +32,7 @@
  * ASB100-A supports pwm1, while plain ASB100 does not.  There is no known
  * way for the driver to tell which one is there.
  *
- * Chip	#vin	#fanin	#pwm	#temp	wchipid	vendid	i2c	ISA
+ * Chip		#vin	#fanin	#pwm	#temp	wchipid	vendid	i2c	ISA
  * asb100	7	3	1	4	0x31	0x0694	yes	no
  */
 

commit 64adf39837c7cf744161b18598577cbe2467a01d
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sat Jun 2 09:58:02 2012 -0700

    hwmon: (asb100) Convert to use devm_ functions
    
    Convert to use devm_ functions to reduce code size and simplify the code.
    
    Cc: Mark M. Hoffman <mhoffman@lightlink.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 4b8814deabb1..a227be47149f 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -787,12 +787,10 @@ static int asb100_probe(struct i2c_client *client,
 	int err;
 	struct asb100_data *data;
 
-	data = kzalloc(sizeof(struct asb100_data), GFP_KERNEL);
-	if (!data) {
-		pr_debug("probe failed, kzalloc failed!\n");
-		err = -ENOMEM;
-		goto ERROR0;
-	}
+	data = devm_kzalloc(&client->dev, sizeof(struct asb100_data),
+			    GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
 
 	i2c_set_clientdata(client, data);
 	mutex_init(&data->lock);
@@ -801,7 +799,7 @@ static int asb100_probe(struct i2c_client *client,
 	/* Attach secondary lm75 clients */
 	err = asb100_detect_subclients(client);
 	if (err)
-		goto ERROR1;
+		return err;
 
 	/* Initialize the chip */
 	asb100_init_client(client);
@@ -829,9 +827,6 @@ static int asb100_probe(struct i2c_client *client,
 ERROR3:
 	i2c_unregister_device(data->lm75[1]);
 	i2c_unregister_device(data->lm75[0]);
-ERROR1:
-	kfree(data);
-ERROR0:
 	return err;
 }
 
@@ -845,8 +840,6 @@ static int asb100_remove(struct i2c_client *client)
 	i2c_unregister_device(data->lm75[1]);
 	i2c_unregister_device(data->lm75[0]);
 
-	kfree(data);
-
 	return 0;
 }
 

commit 8c103696fa59e1b810bf24a63304acd5ab585c12
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Sat Jan 14 13:20:00 2012 -0800

    hwmon: (asb100): Fix checkpatch issues
    
    Fixed:
    ERROR: code indent should use tabs where possible
    ERROR: do not use assignment in if condition
    ERROR: space prohibited after that open parenthesis '('
    ERROR: spaces required around that '<' (ctx:VxV)
    ERROR: spaces required around that '==' (ctx:VxV)
    WARNING: please, no spaces at the start of a line
    WARNING: simple_strtol is obsolete, use kstrtol instead
    WARNING: simple_strtoul is obsolete, use kstrtoul instead
    
    Modify multi-line comments to follow Documentation/CodingStyle.
    
    Not fixed (false positive):
    ERROR: Macros with multiple statements should be enclosed in a do - while loop
    
    Cc: Mark M. Hoffman <mhoffman@lightlink.com>
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 0f300c6b7f98..4b8814deabb1 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -1,40 +1,40 @@
 /*
-    asb100.c - Part of lm_sensors, Linux kernel modules for hardware
-	        monitoring
-
-    Copyright (C) 2004 Mark M. Hoffman <mhoffman@lightlink.com>
-
-	(derived from w83781d.c)
-
-    Copyright (C) 1998 - 2003  Frodo Looijaard <frodol@dds.nl>,
-    Philip Edelbrock <phil@netroedge.com>, and
-    Mark Studebaker <mdsxyz123@yahoo.com>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
+ * asb100.c - Part of lm_sensors, Linux kernel modules for hardware
+ *	      monitoring
+ *
+ * Copyright (C) 2004 Mark M. Hoffman <mhoffman@lightlink.com>
+ *
+ * (derived from w83781d.c)
+ *
+ * Copyright (C) 1998 - 2003  Frodo Looijaard <frodol@dds.nl>,
+ *			      Philip Edelbrock <phil@netroedge.com>, and
+ *			      Mark Studebaker <mdsxyz123@yahoo.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 
 /*
-    This driver supports the hardware sensor chips: Asus ASB100 and
-    ASB100-A "BACH".
-
-    ASB100-A supports pwm1, while plain ASB100 does not.  There is no known
-    way for the driver to tell which one is there.
-
-    Chip	#vin	#fanin	#pwm	#temp	wchipid	vendid	i2c	ISA
-    asb100	7	3	1	4	0x31	0x0694	yes	no
-*/
+ * This driver supports the hardware sensor chips: Asus ASB100 and
+ * ASB100-A "BACH".
+ *
+ * ASB100-A supports pwm1, while plain ASB100 does not.  There is no known
+ * way for the driver to tell which one is there.
+ *
+ * Chip	#vin	#fanin	#pwm	#temp	wchipid	vendid	i2c	ISA
+ * asb100	7	3	1	4	0x31	0x0694	yes	no
+ */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
@@ -99,15 +99,19 @@ static const u16 asb100_reg_temp_hyst[]	= {0, 0x3a, 0x153, 0x253, 0x19};
 /* bit 7 -> enable, bits 0-3 -> duty cycle */
 #define ASB100_REG_PWM1		0x59
 
-/* CONVERSIONS
-   Rounding and limit checking is only done on the TO_REG variants. */
+/*
+ * CONVERSIONS
+ * Rounding and limit checking is only done on the TO_REG variants.
+ */
 
 /* These constants are a guess, consistent w/ w83781d */
-#define ASB100_IN_MIN (   0)
-#define ASB100_IN_MAX (4080)
+#define ASB100_IN_MIN		0
+#define ASB100_IN_MAX		4080
 
-/* IN: 1/1000 V (0V to 4.08V)
-   REG: 16mV/bit */
+/*
+ * IN: 1/1000 V (0V to 4.08V)
+ * REG: 16mV/bit
+ */
 static u8 IN_TO_REG(unsigned val)
 {
 	unsigned nval = SENSORS_LIMIT(val, ASB100_IN_MIN, ASB100_IN_MAX);
@@ -131,19 +135,21 @@ static u8 FAN_TO_REG(long rpm, int div)
 
 static int FAN_FROM_REG(u8 val, int div)
 {
-	return val==0 ? -1 : val==255 ? 0 : 1350000/(val*div);
+	return val == 0 ? -1 : val == 255 ? 0 : 1350000 / (val * div);
 }
 
 /* These constants are a guess, consistent w/ w83781d */
-#define ASB100_TEMP_MIN (-128000)
-#define ASB100_TEMP_MAX ( 127000)
+#define ASB100_TEMP_MIN		-128000
+#define ASB100_TEMP_MAX		127000
 
-/* TEMP: 0.001C/bit (-128C to +127C)
-   REG: 1C/bit, two's complement */
+/*
+ * TEMP: 0.001C/bit (-128C to +127C)
+ * REG: 1C/bit, two's complement
+ */
 static u8 TEMP_TO_REG(long temp)
 {
 	int ntemp = SENSORS_LIMIT(temp, ASB100_TEMP_MIN, ASB100_TEMP_MAX);
-	ntemp += (ntemp<0 ? -500 : 500);
+	ntemp += (ntemp < 0 ? -500 : 500);
 	return (u8)(ntemp / 1000);
 }
 
@@ -152,8 +158,10 @@ static int TEMP_FROM_REG(u8 reg)
 	return (s8)reg * 1000;
 }
 
-/* PWM: 0 - 255 per sensors documentation
-   REG: (6.25% duty cycle per bit) */
+/*
+ * PWM: 0 - 255 per sensors documentation
+ * REG: (6.25% duty cycle per bit)
+ */
 static u8 ASB100_PWM_TO_REG(int pwm)
 {
 	pwm = SENSORS_LIMIT(pwm, 0, 255);
@@ -167,16 +175,20 @@ static int ASB100_PWM_FROM_REG(u8 reg)
 
 #define DIV_FROM_REG(val) (1 << (val))
 
-/* FAN DIV: 1, 2, 4, or 8 (defaults to 2)
-   REG: 0, 1, 2, or 3 (respectively) (defaults to 1) */
+/*
+ * FAN DIV: 1, 2, 4, or 8 (defaults to 2)
+ * REG: 0, 1, 2, or 3 (respectively) (defaults to 1)
+ */
 static u8 DIV_TO_REG(long val)
 {
-	return val==8 ? 3 : val==4 ? 2 : val==1 ? 0 : 1;
+	return val == 8 ? 3 : val == 4 ? 2 : val == 1 ? 0 : 1;
 }
 
-/* For each registered client, we need to keep some data in memory. That
-   data is pointed to by client->data. The structure itself is
-   dynamically allocated, at the same time the client itself is allocated. */
+/*
+ * For each registered client, we need to keep some data in memory. That
+ * data is pointed to by client->data. The structure itself is
+ * dynamically allocated, at the same time the client itself is allocated.
+ */
 struct asb100_data {
 	struct device *hwmon_dev;
 	struct mutex lock;
@@ -253,8 +265,10 @@ static ssize_t set_in_##reg(struct device *dev, struct device_attribute *attr, \
 	int nr = to_sensor_dev_attr(attr)->index; \
 	struct i2c_client *client = to_i2c_client(dev); \
 	struct asb100_data *data = i2c_get_clientdata(client); \
-	unsigned long val = simple_strtoul(buf, NULL, 10); \
- \
+	unsigned long val; \
+	int err = kstrtoul(buf, 10, &val); \
+	if (err) \
+		return err; \
 	mutex_lock(&data->update_lock); \
 	data->in_##reg[nr] = IN_TO_REG(val); \
 	asb100_write_value(client, ASB100_REG_IN_##REG(nr), \
@@ -315,7 +329,12 @@ static ssize_t set_fan_min(struct device *dev, struct device_attribute *attr,
 	int nr = to_sensor_dev_attr(attr)->index;
 	struct i2c_client *client = to_i2c_client(dev);
 	struct asb100_data *data = i2c_get_clientdata(client);
-	u32 val = simple_strtoul(buf, NULL, 10);
+	unsigned long val;
+	int err;
+
+	err = kstrtoul(buf, 10, &val);
+	if (err)
+		return err;
 
 	mutex_lock(&data->update_lock);
 	data->fan_min[nr] = FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));
@@ -324,10 +343,12 @@ static ssize_t set_fan_min(struct device *dev, struct device_attribute *attr,
 	return count;
 }
 
-/* Note: we save and restore the fan minimum here, because its value is
-   determined in part by the fan divisor.  This follows the principle of
-   least surprise; the user doesn't expect the fan minimum to change just
-   because the divisor changed. */
+/*
+ * Note: we save and restore the fan minimum here, because its value is
+ * determined in part by the fan divisor.  This follows the principle of
+ * least surprise; the user doesn't expect the fan minimum to change just
+ * because the divisor changed.
+ */
 static ssize_t set_fan_div(struct device *dev, struct device_attribute *attr,
 		const char *buf, size_t count)
 {
@@ -335,8 +356,13 @@ static ssize_t set_fan_div(struct device *dev, struct device_attribute *attr,
 	struct i2c_client *client = to_i2c_client(dev);
 	struct asb100_data *data = i2c_get_clientdata(client);
 	unsigned long min;
-	unsigned long val = simple_strtoul(buf, NULL, 10);
 	int reg;
+	unsigned long val;
+	int err;
+
+	err = kstrtoul(buf, 10, &val);
+	if (err)
+		return err;
 
 	mutex_lock(&data->update_lock);
 
@@ -421,8 +447,10 @@ static ssize_t set_##reg(struct device *dev, struct device_attribute *attr, \
 	int nr = to_sensor_dev_attr(attr)->index; \
 	struct i2c_client *client = to_i2c_client(dev); \
 	struct asb100_data *data = i2c_get_clientdata(client); \
-	long val = simple_strtol(buf, NULL, 10); \
- \
+	long val; \
+	int err = kstrtol(buf, 10, &val); \
+	if (err) \
+		return err; \
 	mutex_lock(&data->update_lock); \
 	switch (nr) { \
 	case 1: case 2: \
@@ -476,7 +504,13 @@ static ssize_t set_vrm(struct device *dev, struct device_attribute *attr,
 		const char *buf, size_t count)
 {
 	struct asb100_data *data = dev_get_drvdata(dev);
-	data->vrm = simple_strtoul(buf, NULL, 10);
+	unsigned long val;
+	int err;
+
+	err = kstrtoul(buf, 10, &val);
+	if (err)
+		return err;
+	data->vrm = val;
 	return count;
 }
 
@@ -524,7 +558,12 @@ static ssize_t set_pwm1(struct device *dev, struct device_attribute *attr,
 {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct asb100_data *data = i2c_get_clientdata(client);
-	unsigned long val = simple_strtoul(buf, NULL, 10);
+	unsigned long val;
+	int err;
+
+	err = kstrtoul(buf, 10, &val);
+	if (err)
+		return err;
 
 	mutex_lock(&data->update_lock);
 	data->pwm &= 0x80; /* keep the enable bit */
@@ -546,7 +585,12 @@ static ssize_t set_pwm_enable1(struct device *dev,
 {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct asb100_data *data = i2c_get_clientdata(client);
-	unsigned long val = simple_strtoul(buf, NULL, 10);
+	unsigned long val;
+	int err;
+
+	err = kstrtoul(buf, 10, &val);
+	if (err)
+		return err;
 
 	mutex_lock(&data->update_lock);
 	data->pwm &= 0x0f; /* keep the duty cycle bits */
@@ -768,7 +812,8 @@ static int asb100_probe(struct i2c_client *client,
 	data->fan_min[2] = asb100_read_value(client, ASB100_REG_FAN_MIN(2));
 
 	/* Register sysfs hooks */
-	if ((err = sysfs_create_group(&client->dev.kobj, &asb100_group)))
+	err = sysfs_create_group(&client->dev.kobj, &asb100_group);
+	if (err)
 		goto ERROR3;
 
 	data->hwmon_dev = hwmon_device_register(&client->dev);
@@ -805,8 +850,10 @@ static int asb100_remove(struct i2c_client *client)
 	return 0;
 }
 
-/* The SMBus locks itself, usually, but nothing may access the chip between
-   bank switches. */
+/*
+ * The SMBus locks itself, usually, but nothing may access the chip between
+ * bank switches.
+ */
 static int asb100_read_value(struct i2c_client *client, u16 reg)
 {
 	struct asb100_data *data = i2c_get_clientdata(client);

commit f0967eea80ec2a19a4fe1ad27e3ff1b22c79a3c7
Author: Axel Lin <axel.lin@gmail.com>
Date:   Fri Jan 20 15:38:18 2012 +0800

    hwmon: convert drivers/hwmon/* to use module_i2c_driver()
    
    This patch converts the drivers in drivers/hwmon/* to use the
    module_i2c_driver() macro which makes the code smaller and a bit simpler.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Cc: Corentin Labbe <corentin.labbe@geomatys.fr>
    Cc: Dirk Eibach <eibach@gdsys.de>
    Cc: "Mark M. Hoffman" <mhoffman@lightlink.com>
    Cc: Steve Glendinning <steve.glendinning@smsc.com>
    Cc: Riku Voipio <riku.voipio@iki.fi>
    Cc: Guillaume Ligneul <guillaume.ligneul@gmail.com>
    Cc: David George <david.george@ska.ac.za>
    Cc: "Hans J. Koch" <hjk@hansjkoch.de>
    Cc: Marc Hulsman <m.hulsman@tudelft.nl>
    Cc: Rudolf Marek <r.marek@assembler.cz>
    Signed-off-by: Guenter Roeck <guenter.roeck@ericsson.com>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index d7bd1f3f2a31..0f300c6b7f98 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -971,19 +971,8 @@ static struct asb100_data *asb100_update_device(struct device *dev)
 	return data;
 }
 
-static int __init asb100_init(void)
-{
-	return i2c_add_driver(&asb100_driver);
-}
-
-static void __exit asb100_exit(void)
-{
-	i2c_del_driver(&asb100_driver);
-}
+module_i2c_driver(asb100_driver);
 
 MODULE_AUTHOR("Mark M. Hoffman <mhoffman@lightlink.com>");
 MODULE_DESCRIPTION("ASB100 Bach driver");
 MODULE_LICENSE("GPL");
-
-module_init(asb100_init);
-module_exit(asb100_exit);

commit 90f4102ce59226954edbe960b2434d8b3da5f086
Author: Jean Delvare <khali@linux-fr.org>
Date:   Fri Nov 4 12:00:47 2011 +0100

    hwmon: Use i2c_smbus_{read,write}_word_swapped
    
    Make use of the new i2c_smbus_{read,write}_word_swapped functions.
    This makes the driver code more compact and readable. It also ensures
    proper error handling.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Jonathan Cameron <jic23@cam.ac.uk>
    Acked-by: Guenter Roeck <guenter.roeck@ericsson.com>
    Cc: Dirk Eibach <eibach@gdsys.de>
    Cc: "Mark M. Hoffman" <mhoffman@lightlink.com>
    Cc: Guillaume Ligneul <guillaume.ligneul@gmail.com>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index c02a052d3085..d7bd1f3f2a31 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -829,17 +829,17 @@ static int asb100_read_value(struct i2c_client *client, u16 reg)
 		/* convert from ISA to LM75 I2C addresses */
 		switch (reg & 0xff) {
 		case 0x50: /* TEMP */
-			res = swab16(i2c_smbus_read_word_data(cl, 0));
+			res = i2c_smbus_read_word_swapped(cl, 0);
 			break;
 		case 0x52: /* CONFIG */
 			res = i2c_smbus_read_byte_data(cl, 1);
 			break;
 		case 0x53: /* HYST */
-			res = swab16(i2c_smbus_read_word_data(cl, 2));
+			res = i2c_smbus_read_word_swapped(cl, 2);
 			break;
 		case 0x55: /* MAX */
 		default:
-			res = swab16(i2c_smbus_read_word_data(cl, 3));
+			res = i2c_smbus_read_word_swapped(cl, 3);
 			break;
 		}
 	}
@@ -877,10 +877,10 @@ static void asb100_write_value(struct i2c_client *client, u16 reg, u16 value)
 			i2c_smbus_write_byte_data(cl, 1, value & 0xff);
 			break;
 		case 0x53: /* HYST */
-			i2c_smbus_write_word_data(cl, 2, swab16(value));
+			i2c_smbus_write_word_swapped(cl, 2, value);
 			break;
 		case 0x55: /* MAX */
-			i2c_smbus_write_word_data(cl, 3, swab16(value));
+			i2c_smbus_write_word_swapped(cl, 3, value);
 			break;
 		}
 	}

commit 4d630e2ba59a231c8e5031cc55e16737aa59af97
Author: Joe Perches <joe@perches.com>
Date:   Wed Oct 20 06:51:29 2010 +0000

    hwmon: (asb1000) Use pr_fmt and pr_<level>
    
    Added #define pr_fmt KBUILD_MODNAME ": " fmt
    Converted printks to pr_<level>
    Coalesced any long formats
    Removed prefixes from formats
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Guenter Roeck <guenter.roeck@ericsson.com>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 7dada559b3a1..c02a052d3085 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -36,6 +36,8 @@
     asb100	7	3	1	4	0x31	0x0694	yes	no
 */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/i2c.h>
@@ -701,8 +703,7 @@ static int asb100_detect(struct i2c_client *client,
 	int val1, val2;
 
 	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
-		pr_debug("asb100.o: detect failed, "
-				"smbus byte data not supported!\n");
+		pr_debug("detect failed, smbus byte data not supported!\n");
 		return -ENODEV;
 	}
 
@@ -715,7 +716,7 @@ static int asb100_detect(struct i2c_client *client,
 			(((!(val1 & 0x80)) && (val2 != 0x94)) ||
 			/* Check for ASB100 ID (high byte ) */
 			((val1 & 0x80) && (val2 != 0x06)))) {
-		pr_debug("asb100: detect failed, bad chip id 0x%02x!\n", val2);
+		pr_debug("detect failed, bad chip id 0x%02x!\n", val2);
 		return -ENODEV;
 	}
 
@@ -744,7 +745,7 @@ static int asb100_probe(struct i2c_client *client,
 
 	data = kzalloc(sizeof(struct asb100_data), GFP_KERNEL);
 	if (!data) {
-		pr_debug("asb100.o: probe failed, kzalloc failed!\n");
+		pr_debug("probe failed, kzalloc failed!\n");
 		err = -ENOMEM;
 		goto ERROR0;
 	}

commit 1f86df49ddfd0067cce941187d57b2fd2f749a9e
Author: Jean Delvare <khali@linux-fr.org>
Date:   Mon Dec 14 21:17:26 2009 +0100

    i2c: Drop I2C_CLIENT_INSMOD_1
    
    This macro simply declares an enum, so drivers might as well declare
    it themselves.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index a92512a4a366..7dada559b3a1 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -51,9 +51,6 @@
 /* I2C addresses to scan */
 static const unsigned short normal_i2c[] = { 0x2d, I2C_CLIENT_END };
 
-/* Insmod parameters */
-I2C_CLIENT_INSMOD_1(asb100);
-
 static unsigned short force_subclients[4];
 module_param_array(force_subclients, short, NULL, 0);
 MODULE_PARM_DESC(force_subclients, "List of subclient addresses: "
@@ -216,7 +213,7 @@ static struct asb100_data *asb100_update_device(struct device *dev);
 static void asb100_init_client(struct i2c_client *client);
 
 static const struct i2c_device_id asb100_id[] = {
-	{ "asb100", asb100 },
+	{ "asb100", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(i2c, asb100_id);

commit c3813d6af177fab19e322f3114b1f64fbcf08d71
Author: Jean Delvare <khali@linux-fr.org>
Date:   Mon Dec 14 21:17:25 2009 +0100

    i2c: Get rid of struct i2c_client_address_data
    
    Struct i2c_client_address_data only contains one field at this point,
    which makes its usefulness questionable. Get rid of it and pass simple
    address lists around instead.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 507e116d5456..a92512a4a366 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -230,7 +230,7 @@ static struct i2c_driver asb100_driver = {
 	.remove		= asb100_remove,
 	.id_table	= asb100_id,
 	.detect		= asb100_detect,
-	.address_data	= &addr_data,
+	.address_list	= normal_i2c,
 };
 
 /* 7 Voltages */

commit 310ec79210d754afe51e2e4a983e846b60179abd
Author: Jean Delvare <khali@linux-fr.org>
Date:   Mon Dec 14 21:17:23 2009 +0100

    i2c: Drop the kind parameter from detect callbacks
    
    The "kind" parameter always has value -1, and nobody is using it any
    longer, so we can remove it.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Tested-by: Wolfram Sang <w.sang@pengutronix.de>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 480f80ea1fa0..507e116d5456 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -209,7 +209,7 @@ static void asb100_write_value(struct i2c_client *client, u16 reg, u16 val);
 
 static int asb100_probe(struct i2c_client *client,
 			const struct i2c_device_id *id);
-static int asb100_detect(struct i2c_client *client, int kind,
+static int asb100_detect(struct i2c_client *client,
 			 struct i2c_board_info *info);
 static int asb100_remove(struct i2c_client *client);
 static struct asb100_data *asb100_update_device(struct device *dev);
@@ -697,7 +697,7 @@ static int asb100_detect_subclients(struct i2c_client *client)
 }
 
 /* Return 0 if detection is successful, -ENODEV otherwise */
-static int asb100_detect(struct i2c_client *client, int kind,
+static int asb100_detect(struct i2c_client *client,
 			 struct i2c_board_info *info)
 {
 	struct i2c_adapter *adapter = client->adapter;

commit 52df6440a29123eed912183fe785bbe174ef14b9
Author: Jean Delvare <khali@linux-fr.org>
Date:   Wed Dec 9 20:35:57 2009 +0100

    hwmon: Clean up detect functions
    
    As kind is now hard-coded to -1, there is room for code clean-ups.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Corentin Labbe <corentin.labbe@geomatys.fr>
    Cc: "Mark M. Hoffman" <mhoffman@lightlink.com>
    Cc: Juerg Haefliger <juergh@gmail.com>
    Cc: Riku Voipio <riku.voipio@iki.fi>
    Acked-by: "Hans J. Koch" <hjk@linutronix.de>
    Cc: Rudolf Marek <r.marek@assembler.cz>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 8acf82977e7b..480f80ea1fa0 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -701,6 +701,7 @@ static int asb100_detect(struct i2c_client *client, int kind,
 			 struct i2c_board_info *info)
 {
 	struct i2c_adapter *adapter = client->adapter;
+	int val1, val2;
 
 	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
 		pr_debug("asb100.o: detect failed, "
@@ -708,50 +709,30 @@ static int asb100_detect(struct i2c_client *client, int kind,
 		return -ENODEV;
 	}
 
-	/* The chip may be stuck in some other bank than bank 0. This may
-	   make reading other information impossible. Specify a force=... or
-	   force_*=... parameter, and the chip will be reset to the right
-	   bank. */
-	if (kind < 0) {
-
-		int val1 = i2c_smbus_read_byte_data(client, ASB100_REG_BANK);
-		int val2 = i2c_smbus_read_byte_data(client, ASB100_REG_CHIPMAN);
-
-		/* If we're in bank 0 */
-		if ((!(val1 & 0x07)) &&
-				/* Check for ASB100 ID (low byte) */
-				(((!(val1 & 0x80)) && (val2 != 0x94)) ||
-				/* Check for ASB100 ID (high byte ) */
-				((val1 & 0x80) && (val2 != 0x06)))) {
-			pr_debug("asb100.o: detect failed, "
-					"bad chip id 0x%02x!\n", val2);
-			return -ENODEV;
-		}
+	val1 = i2c_smbus_read_byte_data(client, ASB100_REG_BANK);
+	val2 = i2c_smbus_read_byte_data(client, ASB100_REG_CHIPMAN);
 
-	} /* kind < 0 */
+	/* If we're in bank 0 */
+	if ((!(val1 & 0x07)) &&
+			/* Check for ASB100 ID (low byte) */
+			(((!(val1 & 0x80)) && (val2 != 0x94)) ||
+			/* Check for ASB100 ID (high byte ) */
+			((val1 & 0x80) && (val2 != 0x06)))) {
+		pr_debug("asb100: detect failed, bad chip id 0x%02x!\n", val2);
+		return -ENODEV;
+	}
 
-	/* We have either had a force parameter, or we have already detected
-	   Winbond. Put it now into bank 0 and Vendor ID High Byte */
+	/* Put it now into bank 0 and Vendor ID High Byte */
 	i2c_smbus_write_byte_data(client, ASB100_REG_BANK,
 		(i2c_smbus_read_byte_data(client, ASB100_REG_BANK) & 0x78)
 		| 0x80);
 
 	/* Determine the chip type. */
-	if (kind <= 0) {
-		int val1 = i2c_smbus_read_byte_data(client, ASB100_REG_WCHIPID);
-		int val2 = i2c_smbus_read_byte_data(client, ASB100_REG_CHIPMAN);
-
-		if ((val1 == 0x31) && (val2 == 0x06))
-			kind = asb100;
-		else {
-			if (kind == 0)
-				dev_warn(&adapter->dev, "ignoring "
-					"'force' parameter for unknown chip "
-					"at adapter %d, address 0x%02x.\n",
-					i2c_adapter_id(adapter), client->addr);
-			return -ENODEV;
-		}
-	}
+	val1 = i2c_smbus_read_byte_data(client, ASB100_REG_WCHIPID);
+	val2 = i2c_smbus_read_byte_data(client, ASB100_REG_CHIPMAN);
+
+	if (val1 != 0x31 || val2 != 0x06)
+		return -ENODEV;
 
 	strlcpy(info->type, "asb100", I2C_NAME_SIZE);
 

commit 3aed198c35567e5a721f52c0bde23167867e6af6
Author: Jean Delvare <khali@linux-fr.org>
Date:   Wed Jan 7 16:37:32 2009 +0100

    hwmon: Don't overuse I2C_CLIENT_MODULE_PARM
    
    I2C_CLIENT_MODULE_PARM is overkill for force_subclients. We really
    only use 4 out of the 48 slots, so we're better defining a custom
    variable instead. This change saves 92 bytes of data for each of the
    five drivers affected.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Cc: Wolfgang Grandegger <wg@grandegger.com>
    Acked-by: Marc Hulsman <m.hulsman@tudelft.nl>
    Cc: Mark M. Hoffman <mhoffman@lightlink.com>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 8a45a2e6ba8a..8acf82977e7b 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -53,7 +53,10 @@ static const unsigned short normal_i2c[] = { 0x2d, I2C_CLIENT_END };
 
 /* Insmod parameters */
 I2C_CLIENT_INSMOD_1(asb100);
-I2C_CLIENT_MODULE_PARM(force_subclients, "List of subclient addresses: "
+
+static unsigned short force_subclients[4];
+module_param_array(force_subclients, short, NULL, 0);
+MODULE_PARM_DESC(force_subclients, "List of subclient addresses: "
 	"{bus, clientaddr, subclientaddr1, subclientaddr2}");
 
 /* Voltage IN registers 0-6 */

commit 063675b15608dfbb8404b3a19546d579bd039d02
Author: Jean Delvare <khali@linux-fr.org>
Date:   Wed Jul 16 19:30:11 2008 +0200

    hwmon: (asb100) Convert to a new-style i2c driver
    
    The new-style asb100 driver implements the optional detect() callback
    to cover the use cases of the legacy driver.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index fe2eea4d799b..8a45a2e6ba8a 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -176,10 +176,8 @@ static u8 DIV_TO_REG(long val)
    data is pointed to by client->data. The structure itself is
    dynamically allocated, at the same time the client itself is allocated. */
 struct asb100_data {
-	struct i2c_client client;
 	struct device *hwmon_dev;
 	struct mutex lock;
-	enum chips type;
 
 	struct mutex update_lock;
 	unsigned long last_updated;	/* In jiffies */
@@ -206,18 +204,30 @@ struct asb100_data {
 static int asb100_read_value(struct i2c_client *client, u16 reg);
 static void asb100_write_value(struct i2c_client *client, u16 reg, u16 val);
 
-static int asb100_attach_adapter(struct i2c_adapter *adapter);
-static int asb100_detect(struct i2c_adapter *adapter, int address, int kind);
-static int asb100_detach_client(struct i2c_client *client);
+static int asb100_probe(struct i2c_client *client,
+			const struct i2c_device_id *id);
+static int asb100_detect(struct i2c_client *client, int kind,
+			 struct i2c_board_info *info);
+static int asb100_remove(struct i2c_client *client);
 static struct asb100_data *asb100_update_device(struct device *dev);
 static void asb100_init_client(struct i2c_client *client);
 
+static const struct i2c_device_id asb100_id[] = {
+	{ "asb100", asb100 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, asb100_id);
+
 static struct i2c_driver asb100_driver = {
+	.class		= I2C_CLASS_HWMON,
 	.driver = {
 		.name	= "asb100",
 	},
-	.attach_adapter	= asb100_attach_adapter,
-	.detach_client	= asb100_detach_client,
+	.probe		= asb100_probe,
+	.remove		= asb100_remove,
+	.id_table	= asb100_id,
+	.detect		= asb100_detect,
+	.address_data	= &addr_data,
 };
 
 /* 7 Voltages */
@@ -619,35 +629,13 @@ static const struct attribute_group asb100_group = {
 	.attrs = asb100_attributes,
 };
 
-/* This function is called when:
-	asb100_driver is inserted (when this module is loaded), for each
-		available adapter
-	when a new adapter is inserted (and asb100_driver is still present)
- */
-static int asb100_attach_adapter(struct i2c_adapter *adapter)
-{
-	if (!(adapter->class & I2C_CLASS_HWMON))
-		return 0;
-	return i2c_probe(adapter, &addr_data, asb100_detect);
-}
-
-static int asb100_detect_subclients(struct i2c_adapter *adapter, int address,
-		int kind, struct i2c_client *client)
+static int asb100_detect_subclients(struct i2c_client *client)
 {
 	int i, id, err;
+	int address = client->addr;
+	unsigned short sc_addr[2];
 	struct asb100_data *data = i2c_get_clientdata(client);
-
-	data->lm75[0] = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
-	if (!(data->lm75[0])) {
-		err = -ENOMEM;
-		goto ERROR_SC_0;
-	}
-
-	data->lm75[1] = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
-	if (!(data->lm75[1])) {
-		err = -ENOMEM;
-		goto ERROR_SC_1;
-	}
+	struct i2c_adapter *adapter = client->adapter;
 
 	id = i2c_adapter_id(adapter);
 
@@ -665,37 +653,34 @@ static int asb100_detect_subclients(struct i2c_adapter *adapter, int address,
 		asb100_write_value(client, ASB100_REG_I2C_SUBADDR,
 					(force_subclients[2] & 0x07) |
 					((force_subclients[3] & 0x07) << 4));
-		data->lm75[0]->addr = force_subclients[2];
-		data->lm75[1]->addr = force_subclients[3];
+		sc_addr[0] = force_subclients[2];
+		sc_addr[1] = force_subclients[3];
 	} else {
 		int val = asb100_read_value(client, ASB100_REG_I2C_SUBADDR);
-		data->lm75[0]->addr = 0x48 + (val & 0x07);
-		data->lm75[1]->addr = 0x48 + ((val >> 4) & 0x07);
+		sc_addr[0] = 0x48 + (val & 0x07);
+		sc_addr[1] = 0x48 + ((val >> 4) & 0x07);
 	}
 
-	if (data->lm75[0]->addr == data->lm75[1]->addr) {
+	if (sc_addr[0] == sc_addr[1]) {
 		dev_err(&client->dev, "duplicate addresses 0x%x "
-				"for subclients\n", data->lm75[0]->addr);
+				"for subclients\n", sc_addr[0]);
 		err = -ENODEV;
 		goto ERROR_SC_2;
 	}
 
-	for (i = 0; i <= 1; i++) {
-		i2c_set_clientdata(data->lm75[i], NULL);
-		data->lm75[i]->adapter = adapter;
-		data->lm75[i]->driver = &asb100_driver;
-		strlcpy(data->lm75[i]->name, "asb100 subclient", I2C_NAME_SIZE);
-	}
-
-	if ((err = i2c_attach_client(data->lm75[0]))) {
+	data->lm75[0] = i2c_new_dummy(adapter, sc_addr[0]);
+	if (!data->lm75[0]) {
 		dev_err(&client->dev, "subclient %d registration "
-			"at address 0x%x failed.\n", i, data->lm75[0]->addr);
+			"at address 0x%x failed.\n", 1, sc_addr[0]);
+		err = -ENOMEM;
 		goto ERROR_SC_2;
 	}
 
-	if ((err = i2c_attach_client(data->lm75[1]))) {
+	data->lm75[1] = i2c_new_dummy(adapter, sc_addr[1]);
+	if (!data->lm75[1]) {
 		dev_err(&client->dev, "subclient %d registration "
-			"at address 0x%x failed.\n", i, data->lm75[1]->addr);
+			"at address 0x%x failed.\n", 2, sc_addr[1]);
+		err = -ENOMEM;
 		goto ERROR_SC_3;
 	}
 
@@ -703,55 +688,31 @@ static int asb100_detect_subclients(struct i2c_adapter *adapter, int address,
 
 /* Undo inits in case of errors */
 ERROR_SC_3:
-	i2c_detach_client(data->lm75[0]);
+	i2c_unregister_device(data->lm75[0]);
 ERROR_SC_2:
-	kfree(data->lm75[1]);
-ERROR_SC_1:
-	kfree(data->lm75[0]);
-ERROR_SC_0:
 	return err;
 }
 
-static int asb100_detect(struct i2c_adapter *adapter, int address, int kind)
+/* Return 0 if detection is successful, -ENODEV otherwise */
+static int asb100_detect(struct i2c_client *client, int kind,
+			 struct i2c_board_info *info)
 {
-	int err;
-	struct i2c_client *client;
-	struct asb100_data *data;
+	struct i2c_adapter *adapter = client->adapter;
 
 	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
 		pr_debug("asb100.o: detect failed, "
 				"smbus byte data not supported!\n");
-		err = -ENODEV;
-		goto ERROR0;
+		return -ENODEV;
 	}
 
-	/* OK. For now, we presume we have a valid client. We now create the
-	   client structure, even though we cannot fill it completely yet.
-	   But it allows us to access asb100_{read,write}_value. */
-
-	if (!(data = kzalloc(sizeof(struct asb100_data), GFP_KERNEL))) {
-		pr_debug("asb100.o: detect failed, kzalloc failed!\n");
-		err = -ENOMEM;
-		goto ERROR0;
-	}
-
-	client = &data->client;
-	mutex_init(&data->lock);
-	i2c_set_clientdata(client, data);
-	client->addr = address;
-	client->adapter = adapter;
-	client->driver = &asb100_driver;
-
-	/* Now, we do the remaining detection. */
-
 	/* The chip may be stuck in some other bank than bank 0. This may
 	   make reading other information impossible. Specify a force=... or
 	   force_*=... parameter, and the chip will be reset to the right
 	   bank. */
 	if (kind < 0) {
 
-		int val1 = asb100_read_value(client, ASB100_REG_BANK);
-		int val2 = asb100_read_value(client, ASB100_REG_CHIPMAN);
+		int val1 = i2c_smbus_read_byte_data(client, ASB100_REG_BANK);
+		int val2 = i2c_smbus_read_byte_data(client, ASB100_REG_CHIPMAN);
 
 		/* If we're in bank 0 */
 		if ((!(val1 & 0x07)) &&
@@ -761,48 +722,60 @@ static int asb100_detect(struct i2c_adapter *adapter, int address, int kind)
 				((val1 & 0x80) && (val2 != 0x06)))) {
 			pr_debug("asb100.o: detect failed, "
 					"bad chip id 0x%02x!\n", val2);
-			err = -ENODEV;
-			goto ERROR1;
+			return -ENODEV;
 		}
 
 	} /* kind < 0 */
 
 	/* We have either had a force parameter, or we have already detected
 	   Winbond. Put it now into bank 0 and Vendor ID High Byte */
-	asb100_write_value(client, ASB100_REG_BANK,
-		(asb100_read_value(client, ASB100_REG_BANK) & 0x78) | 0x80);
+	i2c_smbus_write_byte_data(client, ASB100_REG_BANK,
+		(i2c_smbus_read_byte_data(client, ASB100_REG_BANK) & 0x78)
+		| 0x80);
 
 	/* Determine the chip type. */
 	if (kind <= 0) {
-		int val1 = asb100_read_value(client, ASB100_REG_WCHIPID);
-		int val2 = asb100_read_value(client, ASB100_REG_CHIPMAN);
+		int val1 = i2c_smbus_read_byte_data(client, ASB100_REG_WCHIPID);
+		int val2 = i2c_smbus_read_byte_data(client, ASB100_REG_CHIPMAN);
 
 		if ((val1 == 0x31) && (val2 == 0x06))
 			kind = asb100;
 		else {
 			if (kind == 0)
-				dev_warn(&client->dev, "ignoring "
+				dev_warn(&adapter->dev, "ignoring "
 					"'force' parameter for unknown chip "
 					"at adapter %d, address 0x%02x.\n",
-					i2c_adapter_id(adapter), address);
-			err = -ENODEV;
-			goto ERROR1;
+					i2c_adapter_id(adapter), client->addr);
+			return -ENODEV;
 		}
 	}
 
-	/* Fill in remaining client fields and put it into the global list */
-	strlcpy(client->name, "asb100", I2C_NAME_SIZE);
-	data->type = kind;
-	mutex_init(&data->update_lock);
+	strlcpy(info->type, "asb100", I2C_NAME_SIZE);
 
-	/* Tell the I2C layer a new client has arrived */
-	if ((err = i2c_attach_client(client)))
-		goto ERROR1;
+	return 0;
+}
+
+static int asb100_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	int err;
+	struct asb100_data *data;
+
+	data = kzalloc(sizeof(struct asb100_data), GFP_KERNEL);
+	if (!data) {
+		pr_debug("asb100.o: probe failed, kzalloc failed!\n");
+		err = -ENOMEM;
+		goto ERROR0;
+	}
+
+	i2c_set_clientdata(client, data);
+	mutex_init(&data->lock);
+	mutex_init(&data->update_lock);
 
 	/* Attach secondary lm75 clients */
-	if ((err = asb100_detect_subclients(adapter, address, kind,
-			client)))
-		goto ERROR2;
+	err = asb100_detect_subclients(client);
+	if (err)
+		goto ERROR1;
 
 	/* Initialize the chip */
 	asb100_init_client(client);
@@ -827,39 +800,25 @@ static int asb100_detect(struct i2c_adapter *adapter, int address, int kind)
 ERROR4:
 	sysfs_remove_group(&client->dev.kobj, &asb100_group);
 ERROR3:
-	i2c_detach_client(data->lm75[1]);
-	i2c_detach_client(data->lm75[0]);
-	kfree(data->lm75[1]);
-	kfree(data->lm75[0]);
-ERROR2:
-	i2c_detach_client(client);
+	i2c_unregister_device(data->lm75[1]);
+	i2c_unregister_device(data->lm75[0]);
 ERROR1:
 	kfree(data);
 ERROR0:
 	return err;
 }
 
-static int asb100_detach_client(struct i2c_client *client)
+static int asb100_remove(struct i2c_client *client)
 {
 	struct asb100_data *data = i2c_get_clientdata(client);
-	int err;
-
-	/* main client */
-	if (data) {
-		hwmon_device_unregister(data->hwmon_dev);
-		sysfs_remove_group(&client->dev.kobj, &asb100_group);
-	}
 
-	if ((err = i2c_detach_client(client)))
-		return err;
+	hwmon_device_unregister(data->hwmon_dev);
+	sysfs_remove_group(&client->dev.kobj, &asb100_group);
 
-	/* main client */
-	if (data)
-		kfree(data);
+	i2c_unregister_device(data->lm75[1]);
+	i2c_unregister_device(data->lm75[0]);
 
-	/* subclient */
-	else
-		kfree(client);
+	kfree(data);
 
 	return 0;
 }

commit 5d822e9bd9d866672984c6a6b613f0c11ca2543b
Author: Mark M. Hoffman <mhoffman@lightlink.com>
Date:   Tue Feb 26 08:48:49 2008 -0500

    hwmon: (asb100) Remove some dead code
    
    Acked-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Mark M. Hoffman <mhoffman@lightlink.com>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 84712a22acea..fe2eea4d799b 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -953,12 +953,8 @@ static void asb100_write_value(struct i2c_client *client, u16 reg, u16 value)
 static void asb100_init_client(struct i2c_client *client)
 {
 	struct asb100_data *data = i2c_get_clientdata(client);
-	int vid = 0;
 
-	vid = asb100_read_value(client, ASB100_REG_VID_FANDIV) & 0x0f;
-	vid |= (asb100_read_value(client, ASB100_REG_CHIPID) & 0x01) << 4;
 	data->vrm = vid_which_vrm();
-	vid = vid_from_reg(vid, data->vrm);
 
 	/* Start monitoring */
 	asb100_write_value(client, ASB100_REG_CONFIG,

commit 25e9c86d5a6d82ea45eb680fc66bf73ac5e50dff
Author: Mark M. Hoffman <mhoffman@lightlink.com>
Date:   Sun Feb 17 22:28:03 2008 -0500

    hwmon: normal_i2c arrays should be const
    
    Signed-off-by: Mark M. Hoffman <mhoffman@lightlink.com>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 950cea8d1d65..84712a22acea 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -49,7 +49,7 @@
 #include "lm75.h"
 
 /* I2C addresses to scan */
-static unsigned short normal_i2c[] = { 0x2d, I2C_CLIENT_END };
+static const unsigned short normal_i2c[] = { 0x2d, I2C_CLIENT_END };
 
 /* Insmod parameters */
 I2C_CLIENT_INSMOD_1(asb100);

commit 636866b9f0a72583d2361a897668eb19ff37ded6
Author: Jean Delvare <khali@linux-fr.org>
Date:   Thu Jan 3 23:24:24 2008 +0100

    hwmon: (asb100) Add individual alarm files
    
    The new libsensors needs these individual alarm files.
    
    I did not create alarm files for in5 and in6 as these alarms are documented
    as not working.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Hans de Goede <j.w.r.degoede@hhs.nl>
    Signed-off-by: Mark M. Hoffman <mhoffman@lightlink.com>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 407c86c20ecb..950cea8d1d65 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -480,6 +480,25 @@ static ssize_t show_alarms(struct device *dev, struct device_attribute *attr,
 
 static DEVICE_ATTR(alarms, S_IRUGO, show_alarms, NULL);
 
+static ssize_t show_alarm(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	int bitnr = to_sensor_dev_attr(attr)->index;
+	struct asb100_data *data = asb100_update_device(dev);
+	return sprintf(buf, "%u\n", (data->alarms >> bitnr) & 1);
+}
+static SENSOR_DEVICE_ATTR(in0_alarm, S_IRUGO, show_alarm, NULL, 0);
+static SENSOR_DEVICE_ATTR(in1_alarm, S_IRUGO, show_alarm, NULL, 1);
+static SENSOR_DEVICE_ATTR(in2_alarm, S_IRUGO, show_alarm, NULL, 2);
+static SENSOR_DEVICE_ATTR(in3_alarm, S_IRUGO, show_alarm, NULL, 3);
+static SENSOR_DEVICE_ATTR(in4_alarm, S_IRUGO, show_alarm, NULL, 8);
+static SENSOR_DEVICE_ATTR(fan1_alarm, S_IRUGO, show_alarm, NULL, 6);
+static SENSOR_DEVICE_ATTR(fan2_alarm, S_IRUGO, show_alarm, NULL, 7);
+static SENSOR_DEVICE_ATTR(fan3_alarm, S_IRUGO, show_alarm, NULL, 11);
+static SENSOR_DEVICE_ATTR(temp1_alarm, S_IRUGO, show_alarm, NULL, 4);
+static SENSOR_DEVICE_ATTR(temp2_alarm, S_IRUGO, show_alarm, NULL, 5);
+static SENSOR_DEVICE_ATTR(temp3_alarm, S_IRUGO, show_alarm, NULL, 13);
+
 /* 1 PWM */
 static ssize_t show_pwm1(struct device *dev, struct device_attribute *attr,
 		char *buf)
@@ -575,6 +594,18 @@ static struct attribute *asb100_attributes[] = {
 	&sensor_dev_attr_temp4_max.dev_attr.attr,
 	&sensor_dev_attr_temp4_max_hyst.dev_attr.attr,
 
+	&sensor_dev_attr_in0_alarm.dev_attr.attr,
+	&sensor_dev_attr_in1_alarm.dev_attr.attr,
+	&sensor_dev_attr_in2_alarm.dev_attr.attr,
+	&sensor_dev_attr_in3_alarm.dev_attr.attr,
+	&sensor_dev_attr_in4_alarm.dev_attr.attr,
+	&sensor_dev_attr_fan1_alarm.dev_attr.attr,
+	&sensor_dev_attr_fan2_alarm.dev_attr.attr,
+	&sensor_dev_attr_fan3_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp1_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp2_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp3_alarm.dev_attr.attr,
+
 	&dev_attr_cpu0_vid.attr,
 	&dev_attr_vrm.attr,
 	&dev_attr_alarms.attr,

commit fad33c5fdae73a75af2f8ecf69147011bd57e28c
Author: Jean Delvare <khali@linux-fr.org>
Date:   Thu Jan 3 23:21:07 2008 +0100

    hwmon: (asb100) De-macro the sysfs callbacks
    
    Use standard dynamic sysfs callbacks instead of macro-generated
    wrappers. This makes the code more readable, and the binary smaller
    (by about 12%).
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Hans de Goede <j.w.r.degoede@hhs.nl>
    Signed-off-by: Mark M. Hoffman <mhoffman@lightlink.com>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index db86bc113905..407c86c20ecb 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -40,6 +40,7 @@
 #include <linux/slab.h>
 #include <linux/i2c.h>
 #include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
 #include <linux/hwmon-vid.h>
 #include <linux/err.h>
 #include <linux/init.h>
@@ -221,8 +222,10 @@ static struct i2c_driver asb100_driver = {
 
 /* 7 Voltages */
 #define show_in_reg(reg) \
-static ssize_t show_##reg (struct device *dev, char *buf, int nr) \
+static ssize_t show_##reg(struct device *dev, struct device_attribute *attr, \
+		char *buf) \
 { \
+	int nr = to_sensor_dev_attr(attr)->index; \
 	struct asb100_data *data = asb100_update_device(dev); \
 	return sprintf(buf, "%d\n", IN_FROM_REG(data->reg[nr])); \
 }
@@ -232,9 +235,10 @@ show_in_reg(in_min)
 show_in_reg(in_max)
 
 #define set_in_reg(REG, reg) \
-static ssize_t set_in_##reg(struct device *dev, const char *buf, \
-		size_t count, int nr) \
+static ssize_t set_in_##reg(struct device *dev, struct device_attribute *attr, \
+		const char *buf, size_t count) \
 { \
+	int nr = to_sensor_dev_attr(attr)->index; \
 	struct i2c_client *client = to_i2c_client(dev); \
 	struct asb100_data *data = i2c_get_clientdata(client); \
 	unsigned long val = simple_strtoul(buf, NULL, 10); \
@@ -251,37 +255,12 @@ set_in_reg(MIN, min)
 set_in_reg(MAX, max)
 
 #define sysfs_in(offset) \
-static ssize_t \
-	show_in##offset (struct device *dev, struct device_attribute *attr, char *buf) \
-{ \
-	return show_in(dev, buf, offset); \
-} \
-static DEVICE_ATTR(in##offset##_input, S_IRUGO, \
-		show_in##offset, NULL); \
-static ssize_t \
-	show_in##offset##_min (struct device *dev, struct device_attribute *attr, char *buf) \
-{ \
-	return show_in_min(dev, buf, offset); \
-} \
-static ssize_t \
-	show_in##offset##_max (struct device *dev, struct device_attribute *attr, char *buf) \
-{ \
-	return show_in_max(dev, buf, offset); \
-} \
-static ssize_t set_in##offset##_min (struct device *dev, struct device_attribute *attr, \
-		const char *buf, size_t count) \
-{ \
-	return set_in_min(dev, buf, count, offset); \
-} \
-static ssize_t set_in##offset##_max (struct device *dev, struct device_attribute *attr, \
-		const char *buf, size_t count) \
-{ \
-	return set_in_max(dev, buf, count, offset); \
-} \
-static DEVICE_ATTR(in##offset##_min, S_IRUGO | S_IWUSR, \
-		show_in##offset##_min, set_in##offset##_min); \
-static DEVICE_ATTR(in##offset##_max, S_IRUGO | S_IWUSR, \
-		show_in##offset##_max, set_in##offset##_max);
+static SENSOR_DEVICE_ATTR(in##offset##_input, S_IRUGO, \
+		show_in, NULL, offset); \
+static SENSOR_DEVICE_ATTR(in##offset##_min, S_IRUGO | S_IWUSR, \
+		show_in_min, set_in_min, offset); \
+static SENSOR_DEVICE_ATTR(in##offset##_max, S_IRUGO | S_IWUSR, \
+		show_in_max, set_in_max, offset)
 
 sysfs_in(0);
 sysfs_in(1);
@@ -292,29 +271,36 @@ sysfs_in(5);
 sysfs_in(6);
 
 /* 3 Fans */
-static ssize_t show_fan(struct device *dev, char *buf, int nr)
+static ssize_t show_fan(struct device *dev, struct device_attribute *attr,
+		char *buf)
 {
+	int nr = to_sensor_dev_attr(attr)->index;
 	struct asb100_data *data = asb100_update_device(dev);
 	return sprintf(buf, "%d\n", FAN_FROM_REG(data->fan[nr],
 		DIV_FROM_REG(data->fan_div[nr])));
 }
 
-static ssize_t show_fan_min(struct device *dev, char *buf, int nr)
+static ssize_t show_fan_min(struct device *dev, struct device_attribute *attr,
+		char *buf)
 {
+	int nr = to_sensor_dev_attr(attr)->index;
 	struct asb100_data *data = asb100_update_device(dev);
 	return sprintf(buf, "%d\n", FAN_FROM_REG(data->fan_min[nr],
 		DIV_FROM_REG(data->fan_div[nr])));
 }
 
-static ssize_t show_fan_div(struct device *dev, char *buf, int nr)
+static ssize_t show_fan_div(struct device *dev, struct device_attribute *attr,
+		char *buf)
 {
+	int nr = to_sensor_dev_attr(attr)->index;
 	struct asb100_data *data = asb100_update_device(dev);
 	return sprintf(buf, "%d\n", DIV_FROM_REG(data->fan_div[nr]));
 }
 
-static ssize_t set_fan_min(struct device *dev, const char *buf,
-				size_t count, int nr)
+static ssize_t set_fan_min(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
 {
+	int nr = to_sensor_dev_attr(attr)->index;
 	struct i2c_client *client = to_i2c_client(dev);
 	struct asb100_data *data = i2c_get_clientdata(client);
 	u32 val = simple_strtoul(buf, NULL, 10);
@@ -330,9 +316,10 @@ static ssize_t set_fan_min(struct device *dev, const char *buf,
    determined in part by the fan divisor.  This follows the principle of
    least surprise; the user doesn't expect the fan minimum to change just
    because the divisor changed. */
-static ssize_t set_fan_div(struct device *dev, const char *buf,
-				size_t count, int nr)
+static ssize_t set_fan_div(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
 {
+	int nr = to_sensor_dev_attr(attr)->index;
 	struct i2c_client *client = to_i2c_client(dev);
 	struct asb100_data *data = i2c_get_clientdata(client);
 	unsigned long min;
@@ -375,34 +362,12 @@ static ssize_t set_fan_div(struct device *dev, const char *buf,
 }
 
 #define sysfs_fan(offset) \
-static ssize_t show_fan##offset(struct device *dev, struct device_attribute *attr, char *buf) \
-{ \
-	return show_fan(dev, buf, offset - 1); \
-} \
-static ssize_t show_fan##offset##_min(struct device *dev, struct device_attribute *attr, char *buf) \
-{ \
-	return show_fan_min(dev, buf, offset - 1); \
-} \
-static ssize_t show_fan##offset##_div(struct device *dev, struct device_attribute *attr, char *buf) \
-{ \
-	return show_fan_div(dev, buf, offset - 1); \
-} \
-static ssize_t set_fan##offset##_min(struct device *dev, struct device_attribute *attr, const char *buf, \
-					size_t count) \
-{ \
-	return set_fan_min(dev, buf, count, offset - 1); \
-} \
-static ssize_t set_fan##offset##_div(struct device *dev, struct device_attribute *attr, const char *buf, \
-					size_t count) \
-{ \
-	return set_fan_div(dev, buf, count, offset - 1); \
-} \
-static DEVICE_ATTR(fan##offset##_input, S_IRUGO, \
-		show_fan##offset, NULL); \
-static DEVICE_ATTR(fan##offset##_min, S_IRUGO | S_IWUSR, \
-		show_fan##offset##_min, set_fan##offset##_min); \
-static DEVICE_ATTR(fan##offset##_div, S_IRUGO | S_IWUSR, \
-		show_fan##offset##_div, set_fan##offset##_div);
+static SENSOR_DEVICE_ATTR(fan##offset##_input, S_IRUGO, \
+		show_fan, NULL, offset - 1); \
+static SENSOR_DEVICE_ATTR(fan##offset##_min, S_IRUGO | S_IWUSR, \
+		show_fan_min, set_fan_min, offset - 1); \
+static SENSOR_DEVICE_ATTR(fan##offset##_div, S_IRUGO | S_IWUSR, \
+		show_fan_div, set_fan_div, offset - 1)
 
 sysfs_fan(1);
 sysfs_fan(2);
@@ -425,8 +390,10 @@ static int sprintf_temp_from_reg(u16 reg, char *buf, int nr)
 }
 
 #define show_temp_reg(reg) \
-static ssize_t show_##reg(struct device *dev, char *buf, int nr) \
+static ssize_t show_##reg(struct device *dev, struct device_attribute *attr, \
+		char *buf) \
 { \
+	int nr = to_sensor_dev_attr(attr)->index; \
 	struct asb100_data *data = asb100_update_device(dev); \
 	return sprintf_temp_from_reg(data->reg[nr], buf, nr); \
 }
@@ -436,9 +403,10 @@ show_temp_reg(temp_max);
 show_temp_reg(temp_hyst);
 
 #define set_temp_reg(REG, reg) \
-static ssize_t set_##reg(struct device *dev, const char *buf, \
-			size_t count, int nr) \
+static ssize_t set_##reg(struct device *dev, struct device_attribute *attr, \
+		const char *buf, size_t count) \
 { \
+	int nr = to_sensor_dev_attr(attr)->index; \
 	struct i2c_client *client = to_i2c_client(dev); \
 	struct asb100_data *data = i2c_get_clientdata(client); \
 	long val = simple_strtol(buf, NULL, 10); \
@@ -462,33 +430,12 @@ set_temp_reg(MAX, temp_max);
 set_temp_reg(HYST, temp_hyst);
 
 #define sysfs_temp(num) \
-static ssize_t show_temp##num(struct device *dev, struct device_attribute *attr, char *buf) \
-{ \
-	return show_temp(dev, buf, num-1); \
-} \
-static DEVICE_ATTR(temp##num##_input, S_IRUGO, show_temp##num, NULL); \
-static ssize_t show_temp_max##num(struct device *dev, struct device_attribute *attr, char *buf) \
-{ \
-	return show_temp_max(dev, buf, num-1); \
-} \
-static ssize_t set_temp_max##num(struct device *dev, struct device_attribute *attr, const char *buf, \
-					size_t count) \
-{ \
-	return set_temp_max(dev, buf, count, num-1); \
-} \
-static DEVICE_ATTR(temp##num##_max, S_IRUGO | S_IWUSR, \
-		show_temp_max##num, set_temp_max##num); \
-static ssize_t show_temp_hyst##num(struct device *dev, struct device_attribute *attr, char *buf) \
-{ \
-	return show_temp_hyst(dev, buf, num-1); \
-} \
-static ssize_t set_temp_hyst##num(struct device *dev, struct device_attribute *attr, const char *buf, \
-					size_t count) \
-{ \
-	return set_temp_hyst(dev, buf, count, num-1); \
-} \
-static DEVICE_ATTR(temp##num##_max_hyst, S_IRUGO | S_IWUSR, \
-		show_temp_hyst##num, set_temp_hyst##num);
+static SENSOR_DEVICE_ATTR(temp##num##_input, S_IRUGO, \
+		show_temp, NULL, num - 1); \
+static SENSOR_DEVICE_ATTR(temp##num##_max, S_IRUGO | S_IWUSR, \
+		show_temp_max, set_temp_max, num - 1); \
+static SENSOR_DEVICE_ATTR(temp##num##_max_hyst, S_IRUGO | S_IWUSR, \
+		show_temp_hyst, set_temp_hyst, num - 1)
 
 sysfs_temp(1);
 sysfs_temp(2);
@@ -583,50 +530,50 @@ static DEVICE_ATTR(pwm1_enable, S_IRUGO | S_IWUSR,
 		show_pwm_enable1, set_pwm_enable1);
 
 static struct attribute *asb100_attributes[] = {
-	&dev_attr_in0_input.attr,
-	&dev_attr_in0_min.attr,
-	&dev_attr_in0_max.attr,
-	&dev_attr_in1_input.attr,
-	&dev_attr_in1_min.attr,
-	&dev_attr_in1_max.attr,
-	&dev_attr_in2_input.attr,
-	&dev_attr_in2_min.attr,
-	&dev_attr_in2_max.attr,
-	&dev_attr_in3_input.attr,
-	&dev_attr_in3_min.attr,
-	&dev_attr_in3_max.attr,
-	&dev_attr_in4_input.attr,
-	&dev_attr_in4_min.attr,
-	&dev_attr_in4_max.attr,
-	&dev_attr_in5_input.attr,
-	&dev_attr_in5_min.attr,
-	&dev_attr_in5_max.attr,
-	&dev_attr_in6_input.attr,
-	&dev_attr_in6_min.attr,
-	&dev_attr_in6_max.attr,
-
-	&dev_attr_fan1_input.attr,
-	&dev_attr_fan1_min.attr,
-	&dev_attr_fan1_div.attr,
-	&dev_attr_fan2_input.attr,
-	&dev_attr_fan2_min.attr,
-	&dev_attr_fan2_div.attr,
-	&dev_attr_fan3_input.attr,
-	&dev_attr_fan3_min.attr,
-	&dev_attr_fan3_div.attr,
-
-	&dev_attr_temp1_input.attr,
-	&dev_attr_temp1_max.attr,
-	&dev_attr_temp1_max_hyst.attr,
-	&dev_attr_temp2_input.attr,
-	&dev_attr_temp2_max.attr,
-	&dev_attr_temp2_max_hyst.attr,
-	&dev_attr_temp3_input.attr,
-	&dev_attr_temp3_max.attr,
-	&dev_attr_temp3_max_hyst.attr,
-	&dev_attr_temp4_input.attr,
-	&dev_attr_temp4_max.attr,
-	&dev_attr_temp4_max_hyst.attr,
+	&sensor_dev_attr_in0_input.dev_attr.attr,
+	&sensor_dev_attr_in0_min.dev_attr.attr,
+	&sensor_dev_attr_in0_max.dev_attr.attr,
+	&sensor_dev_attr_in1_input.dev_attr.attr,
+	&sensor_dev_attr_in1_min.dev_attr.attr,
+	&sensor_dev_attr_in1_max.dev_attr.attr,
+	&sensor_dev_attr_in2_input.dev_attr.attr,
+	&sensor_dev_attr_in2_min.dev_attr.attr,
+	&sensor_dev_attr_in2_max.dev_attr.attr,
+	&sensor_dev_attr_in3_input.dev_attr.attr,
+	&sensor_dev_attr_in3_min.dev_attr.attr,
+	&sensor_dev_attr_in3_max.dev_attr.attr,
+	&sensor_dev_attr_in4_input.dev_attr.attr,
+	&sensor_dev_attr_in4_min.dev_attr.attr,
+	&sensor_dev_attr_in4_max.dev_attr.attr,
+	&sensor_dev_attr_in5_input.dev_attr.attr,
+	&sensor_dev_attr_in5_min.dev_attr.attr,
+	&sensor_dev_attr_in5_max.dev_attr.attr,
+	&sensor_dev_attr_in6_input.dev_attr.attr,
+	&sensor_dev_attr_in6_min.dev_attr.attr,
+	&sensor_dev_attr_in6_max.dev_attr.attr,
+
+	&sensor_dev_attr_fan1_input.dev_attr.attr,
+	&sensor_dev_attr_fan1_min.dev_attr.attr,
+	&sensor_dev_attr_fan1_div.dev_attr.attr,
+	&sensor_dev_attr_fan2_input.dev_attr.attr,
+	&sensor_dev_attr_fan2_min.dev_attr.attr,
+	&sensor_dev_attr_fan2_div.dev_attr.attr,
+	&sensor_dev_attr_fan3_input.dev_attr.attr,
+	&sensor_dev_attr_fan3_min.dev_attr.attr,
+	&sensor_dev_attr_fan3_div.dev_attr.attr,
+
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	&sensor_dev_attr_temp1_max.dev_attr.attr,
+	&sensor_dev_attr_temp1_max_hyst.dev_attr.attr,
+	&sensor_dev_attr_temp2_input.dev_attr.attr,
+	&sensor_dev_attr_temp2_max.dev_attr.attr,
+	&sensor_dev_attr_temp2_max_hyst.dev_attr.attr,
+	&sensor_dev_attr_temp3_input.dev_attr.attr,
+	&sensor_dev_attr_temp3_max.dev_attr.attr,
+	&sensor_dev_attr_temp3_max_hyst.dev_attr.attr,
+	&sensor_dev_attr_temp4_input.dev_attr.attr,
+	&sensor_dev_attr_temp4_max.dev_attr.attr,
+	&sensor_dev_attr_temp4_max_hyst.dev_attr.attr,
 
 	&dev_attr_cpu0_vid.attr,
 	&dev_attr_vrm.attr,

commit af221931519571028c98cf7c7030dd973a524011
Author: Jean Delvare <khali@linux-fr.org>
Date:   Thu Jan 3 23:15:49 2008 +0100

    hwmon: (asb100) Various cleanups
    
    * Drop history, it's incomplete and doesn't belong there
    * Drop unused version number
    * Drop trailing spaces
    * Coding style fixes
    * Fold long lines
    * Rename new_client to client
    * Drop redundant initializations to 0
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Hans de Goede <j.w.r.degoede@hhs.nl>
    Signed-off-by: Mark M. Hoffman <mhoffman@lightlink.com>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 3f434de1d993..db86bc113905 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -47,12 +47,6 @@
 #include <linux/mutex.h>
 #include "lm75.h"
 
-/*
-	HISTORY:
-	2003-12-29	1.0.0	Ported from lm_sensors project for kernel 2.6
-*/
-#define ASB100_VERSION "1.0.0"
-
 /* I2C addresses to scan */
 static unsigned short normal_i2c[] = { 0x2d, I2C_CLIENT_END };
 
@@ -344,14 +338,14 @@ static ssize_t set_fan_div(struct device *dev, const char *buf,
 	unsigned long min;
 	unsigned long val = simple_strtoul(buf, NULL, 10);
 	int reg;
-	
+
 	mutex_lock(&data->update_lock);
 
 	min = FAN_FROM_REG(data->fan_min[nr],
 			DIV_FROM_REG(data->fan_div[nr]));
 	data->fan_div[nr] = DIV_TO_REG(val);
 
-	switch(nr) {
+	switch (nr) {
 	case 0:	/* fan 1 */
 		reg = asb100_read_value(client, ASB100_REG_VID_FANDIV);
 		reg = (reg & 0xcf) | (data->fan_div[0] << 4);
@@ -429,7 +423,7 @@ static int sprintf_temp_from_reg(u16 reg, char *buf, int nr)
 	}
 	return ret;
 }
-		 	
+
 #define show_temp_reg(reg) \
 static ssize_t show_##reg(struct device *dev, char *buf, int nr) \
 { \
@@ -502,7 +496,8 @@ sysfs_temp(3);
 sysfs_temp(4);
 
 /* VID */
-static ssize_t show_vid(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_vid(struct device *dev, struct device_attribute *attr,
+		char *buf)
 {
 	struct asb100_data *data = asb100_update_device(dev);
 	return sprintf(buf, "%d\n", vid_from_reg(data->vid, data->vrm));
@@ -511,13 +506,15 @@ static ssize_t show_vid(struct device *dev, struct device_attribute *attr, char
 static DEVICE_ATTR(cpu0_vid, S_IRUGO, show_vid, NULL);
 
 /* VRM */
-static ssize_t show_vrm(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_vrm(struct device *dev, struct device_attribute *attr,
+		char *buf)
 {
 	struct asb100_data *data = dev_get_drvdata(dev);
 	return sprintf(buf, "%d\n", data->vrm);
 }
 
-static ssize_t set_vrm(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t set_vrm(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
 {
 	struct asb100_data *data = dev_get_drvdata(dev);
 	data->vrm = simple_strtoul(buf, NULL, 10);
@@ -527,7 +524,8 @@ static ssize_t set_vrm(struct device *dev, struct device_attribute *attr, const
 /* Alarms */
 static DEVICE_ATTR(vrm, S_IRUGO | S_IWUSR, show_vrm, set_vrm);
 
-static ssize_t show_alarms(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_alarms(struct device *dev, struct device_attribute *attr,
+		char *buf)
 {
 	struct asb100_data *data = asb100_update_device(dev);
 	return sprintf(buf, "%u\n", data->alarms);
@@ -536,13 +534,15 @@ static ssize_t show_alarms(struct device *dev, struct device_attribute *attr, ch
 static DEVICE_ATTR(alarms, S_IRUGO, show_alarms, NULL);
 
 /* 1 PWM */
-static ssize_t show_pwm1(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_pwm1(struct device *dev, struct device_attribute *attr,
+		char *buf)
 {
 	struct asb100_data *data = asb100_update_device(dev);
 	return sprintf(buf, "%d\n", ASB100_PWM_FROM_REG(data->pwm & 0x0f));
 }
 
-static ssize_t set_pwm1(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t set_pwm1(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
 {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct asb100_data *data = i2c_get_clientdata(client);
@@ -556,14 +556,15 @@ static ssize_t set_pwm1(struct device *dev, struct device_attribute *attr, const
 	return count;
 }
 
-static ssize_t show_pwm_enable1(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_pwm_enable1(struct device *dev,
+		struct device_attribute *attr, char *buf)
 {
 	struct asb100_data *data = asb100_update_device(dev);
 	return sprintf(buf, "%d\n", (data->pwm & 0x80) ? 1 : 0);
 }
 
-static ssize_t set_pwm_enable1(struct device *dev, struct device_attribute *attr, const char *buf,
-				size_t count)
+static ssize_t set_pwm_enable1(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct asb100_data *data = i2c_get_clientdata(client);
@@ -653,10 +654,10 @@ static int asb100_attach_adapter(struct i2c_adapter *adapter)
 }
 
 static int asb100_detect_subclients(struct i2c_adapter *adapter, int address,
-		int kind, struct i2c_client *new_client)
+		int kind, struct i2c_client *client)
 {
 	int i, id, err;
-	struct asb100_data *data = i2c_get_clientdata(new_client);
+	struct asb100_data *data = i2c_get_clientdata(client);
 
 	data->lm75[0] = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
 	if (!(data->lm75[0])) {
@@ -676,26 +677,26 @@ static int asb100_detect_subclients(struct i2c_adapter *adapter, int address,
 		for (i = 2; i <= 3; i++) {
 			if (force_subclients[i] < 0x48 ||
 			    force_subclients[i] > 0x4f) {
-				dev_err(&new_client->dev, "invalid subclient "
+				dev_err(&client->dev, "invalid subclient "
 					"address %d; must be 0x48-0x4f\n",
 					force_subclients[i]);
 				err = -ENODEV;
 				goto ERROR_SC_2;
 			}
 		}
-		asb100_write_value(new_client, ASB100_REG_I2C_SUBADDR,
+		asb100_write_value(client, ASB100_REG_I2C_SUBADDR,
 					(force_subclients[2] & 0x07) |
-					((force_subclients[3] & 0x07) <<4));
+					((force_subclients[3] & 0x07) << 4));
 		data->lm75[0]->addr = force_subclients[2];
 		data->lm75[1]->addr = force_subclients[3];
 	} else {
-		int val = asb100_read_value(new_client, ASB100_REG_I2C_SUBADDR);
+		int val = asb100_read_value(client, ASB100_REG_I2C_SUBADDR);
 		data->lm75[0]->addr = 0x48 + (val & 0x07);
 		data->lm75[1]->addr = 0x48 + ((val >> 4) & 0x07);
 	}
 
-	if(data->lm75[0]->addr == data->lm75[1]->addr) {
-		dev_err(&new_client->dev, "duplicate addresses 0x%x "
+	if (data->lm75[0]->addr == data->lm75[1]->addr) {
+		dev_err(&client->dev, "duplicate addresses 0x%x "
 				"for subclients\n", data->lm75[0]->addr);
 		err = -ENODEV;
 		goto ERROR_SC_2;
@@ -705,18 +706,17 @@ static int asb100_detect_subclients(struct i2c_adapter *adapter, int address,
 		i2c_set_clientdata(data->lm75[i], NULL);
 		data->lm75[i]->adapter = adapter;
 		data->lm75[i]->driver = &asb100_driver;
-		data->lm75[i]->flags = 0;
 		strlcpy(data->lm75[i]->name, "asb100 subclient", I2C_NAME_SIZE);
 	}
 
 	if ((err = i2c_attach_client(data->lm75[0]))) {
-		dev_err(&new_client->dev, "subclient %d registration "
+		dev_err(&client->dev, "subclient %d registration "
 			"at address 0x%x failed.\n", i, data->lm75[0]->addr);
 		goto ERROR_SC_2;
 	}
 
 	if ((err = i2c_attach_client(data->lm75[1]))) {
-		dev_err(&new_client->dev, "subclient %d registration "
+		dev_err(&client->dev, "subclient %d registration "
 			"at address 0x%x failed.\n", i, data->lm75[1]->addr);
 		goto ERROR_SC_3;
 	}
@@ -737,7 +737,7 @@ static int asb100_detect_subclients(struct i2c_adapter *adapter, int address,
 static int asb100_detect(struct i2c_adapter *adapter, int address, int kind)
 {
 	int err;
-	struct i2c_client *new_client;
+	struct i2c_client *client;
 	struct asb100_data *data;
 
 	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
@@ -757,13 +757,12 @@ static int asb100_detect(struct i2c_adapter *adapter, int address, int kind)
 		goto ERROR0;
 	}
 
-	new_client = &data->client;
+	client = &data->client;
 	mutex_init(&data->lock);
-	i2c_set_clientdata(new_client, data);
-	new_client->addr = address;
-	new_client->adapter = adapter;
-	new_client->driver = &asb100_driver;
-	new_client->flags = 0;
+	i2c_set_clientdata(client, data);
+	client->addr = address;
+	client->adapter = adapter;
+	client->driver = &asb100_driver;
 
 	/* Now, we do the remaining detection. */
 
@@ -773,15 +772,15 @@ static int asb100_detect(struct i2c_adapter *adapter, int address, int kind)
 	   bank. */
 	if (kind < 0) {
 
-		int val1 = asb100_read_value(new_client, ASB100_REG_BANK);
-		int val2 = asb100_read_value(new_client, ASB100_REG_CHIPMAN);
+		int val1 = asb100_read_value(client, ASB100_REG_BANK);
+		int val2 = asb100_read_value(client, ASB100_REG_CHIPMAN);
 
 		/* If we're in bank 0 */
-		if ( (!(val1 & 0x07)) &&
+		if ((!(val1 & 0x07)) &&
 				/* Check for ASB100 ID (low byte) */
-				( ((!(val1 & 0x80)) && (val2 != 0x94)) ||
+				(((!(val1 & 0x80)) && (val2 != 0x94)) ||
 				/* Check for ASB100 ID (high byte ) */
-				((val1 & 0x80) && (val2 != 0x06)) ) ) {
+				((val1 & 0x80) && (val2 != 0x06)))) {
 			pr_debug("asb100.o: detect failed, "
 					"bad chip id 0x%02x!\n", val2);
 			err = -ENODEV;
@@ -792,19 +791,19 @@ static int asb100_detect(struct i2c_adapter *adapter, int address, int kind)
 
 	/* We have either had a force parameter, or we have already detected
 	   Winbond. Put it now into bank 0 and Vendor ID High Byte */
-	asb100_write_value(new_client, ASB100_REG_BANK,
-		(asb100_read_value(new_client, ASB100_REG_BANK) & 0x78) | 0x80);
+	asb100_write_value(client, ASB100_REG_BANK,
+		(asb100_read_value(client, ASB100_REG_BANK) & 0x78) | 0x80);
 
 	/* Determine the chip type. */
 	if (kind <= 0) {
-		int val1 = asb100_read_value(new_client, ASB100_REG_WCHIPID);
-		int val2 = asb100_read_value(new_client, ASB100_REG_CHIPMAN);
+		int val1 = asb100_read_value(client, ASB100_REG_WCHIPID);
+		int val2 = asb100_read_value(client, ASB100_REG_CHIPMAN);
 
 		if ((val1 == 0x31) && (val2 == 0x06))
 			kind = asb100;
 		else {
 			if (kind == 0)
-				dev_warn(&new_client->dev, "ignoring "
+				dev_warn(&client->dev, "ignoring "
 					"'force' parameter for unknown chip "
 					"at adapter %d, address 0x%02x.\n",
 					i2c_adapter_id(adapter), address);
@@ -814,34 +813,32 @@ static int asb100_detect(struct i2c_adapter *adapter, int address, int kind)
 	}
 
 	/* Fill in remaining client fields and put it into the global list */
-	strlcpy(new_client->name, "asb100", I2C_NAME_SIZE);
+	strlcpy(client->name, "asb100", I2C_NAME_SIZE);
 	data->type = kind;
-
-	data->valid = 0;
 	mutex_init(&data->update_lock);
 
 	/* Tell the I2C layer a new client has arrived */
-	if ((err = i2c_attach_client(new_client)))
+	if ((err = i2c_attach_client(client)))
 		goto ERROR1;
 
 	/* Attach secondary lm75 clients */
 	if ((err = asb100_detect_subclients(adapter, address, kind,
-			new_client)))
+			client)))
 		goto ERROR2;
 
 	/* Initialize the chip */
-	asb100_init_client(new_client);
+	asb100_init_client(client);
 
 	/* A few vars need to be filled upon startup */
-	data->fan_min[0] = asb100_read_value(new_client, ASB100_REG_FAN_MIN(0));
-	data->fan_min[1] = asb100_read_value(new_client, ASB100_REG_FAN_MIN(1));
-	data->fan_min[2] = asb100_read_value(new_client, ASB100_REG_FAN_MIN(2));
+	data->fan_min[0] = asb100_read_value(client, ASB100_REG_FAN_MIN(0));
+	data->fan_min[1] = asb100_read_value(client, ASB100_REG_FAN_MIN(1));
+	data->fan_min[2] = asb100_read_value(client, ASB100_REG_FAN_MIN(2));
 
 	/* Register sysfs hooks */
-	if ((err = sysfs_create_group(&new_client->dev.kobj, &asb100_group)))
+	if ((err = sysfs_create_group(&client->dev.kobj, &asb100_group)))
 		goto ERROR3;
 
-	data->hwmon_dev = hwmon_device_register(&new_client->dev);
+	data->hwmon_dev = hwmon_device_register(&client->dev);
 	if (IS_ERR(data->hwmon_dev)) {
 		err = PTR_ERR(data->hwmon_dev);
 		goto ERROR4;
@@ -850,14 +847,14 @@ static int asb100_detect(struct i2c_adapter *adapter, int address, int kind)
 	return 0;
 
 ERROR4:
-	sysfs_remove_group(&new_client->dev.kobj, &asb100_group);
+	sysfs_remove_group(&client->dev.kobj, &asb100_group);
 ERROR3:
 	i2c_detach_client(data->lm75[1]);
 	i2c_detach_client(data->lm75[0]);
 	kfree(data->lm75[1]);
 	kfree(data->lm75[0]);
 ERROR2:
-	i2c_detach_client(new_client);
+	i2c_detach_client(client);
 ERROR1:
 	kfree(data);
 ERROR0:
@@ -913,17 +910,17 @@ static int asb100_read_value(struct i2c_client *client, u16 reg)
 		/* convert from ISA to LM75 I2C addresses */
 		switch (reg & 0xff) {
 		case 0x50: /* TEMP */
-			res = swab16(i2c_smbus_read_word_data (cl, 0));
+			res = swab16(i2c_smbus_read_word_data(cl, 0));
 			break;
 		case 0x52: /* CONFIG */
 			res = i2c_smbus_read_byte_data(cl, 1);
 			break;
 		case 0x53: /* HYST */
-			res = swab16(i2c_smbus_read_word_data (cl, 2));
+			res = swab16(i2c_smbus_read_word_data(cl, 2));
 			break;
 		case 0x55: /* MAX */
 		default:
-			res = swab16(i2c_smbus_read_word_data (cl, 3));
+			res = swab16(i2c_smbus_read_word_data(cl, 3));
 			break;
 		}
 	}
@@ -986,7 +983,7 @@ static void asb100_init_client(struct i2c_client *client)
 	vid = vid_from_reg(vid, data->vrm);
 
 	/* Start monitoring */
-	asb100_write_value(client, ASB100_REG_CONFIG, 
+	asb100_write_value(client, ASB100_REG_CONFIG,
 		(asb100_read_value(client, ASB100_REG_CONFIG) & 0xf7) | 0x01);
 }
 
@@ -1075,4 +1072,3 @@ MODULE_LICENSE("GPL");
 
 module_init(asb100_init);
 module_exit(asb100_exit);
-

commit 8f74efe81d122c071410fd74f42879ef81439fa4
Author: Jean Delvare <khali@linux-fr.org>
Date:   Sat Dec 1 11:25:33 2007 +0100

    hwmon: VRM is not written to registers
    
    What was true of reading the VRM value is also true of writing it: not
    being a register value, it doesn't need hardware access, so we don't
    need a reference to the i2c client. This allows for a minor code
    cleanup. As gcc appears to be smart enough to simplify the generated
    code by itself, this cleanup only affects the source code, the
    generated binaries are unchanged.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Mark M. Hoffman <mhoffman@lightlink.com>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 815493b9788d..3f434de1d993 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -519,10 +519,8 @@ static ssize_t show_vrm(struct device *dev, struct device_attribute *attr, char
 
 static ssize_t set_vrm(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
-	struct i2c_client *client = to_i2c_client(dev);
-	struct asb100_data *data = i2c_get_clientdata(client);
-	unsigned long val = simple_strtoul(buf, NULL, 10);
-	data->vrm = val;
+	struct asb100_data *data = dev_get_drvdata(dev);
+	data->vrm = simple_strtoul(buf, NULL, 10);
 	return count;
 }
 

commit 7b501b1f53605bec17454dd8bbdbbf3f57a7cf32
Author: Jean Delvare <khali@linux-fr.org>
Date:   Thu Jan 3 19:44:09 2008 +0100

    hwmon: Discard useless I2C driver IDs
    
    Many I2C hwmon drivers define a driver ID but no other code references
    these, meaning that they are useless. Discard them, along with a few
    IDs which are defined but never used at all.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Mark M. Hoffman <mhoffman@lightlink.com>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 9460dba4cf74..815493b9788d 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -221,7 +221,6 @@ static struct i2c_driver asb100_driver = {
 	.driver = {
 		.name	= "asb100",
 	},
-	.id		= I2C_DRIVERID_ASB100,
 	.attach_adapter	= asb100_attach_adapter,
 	.detach_client	= asb100_detach_client,
 };

commit 90d6619a916062cb75a176aacb318d108758b4a5
Author: Jean Delvare <khali@linux-fr.org>
Date:   Mon Oct 8 18:24:35 2007 +0200

    hwmon: VRM is not read from registers
    
    The VRM value is not read from chip registers, so there's no need
    to update the device data cache before exporting the VRM value to
    user-space.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Acked-by: Hans de Goede <j.w.r.degoede@hhs.nl>
    Signed-off-by: Mark M. Hoffman <mhoffman@lightlink.com>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 745bf264bcfd..9460dba4cf74 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -514,7 +514,7 @@ static DEVICE_ATTR(cpu0_vid, S_IRUGO, show_vid, NULL);
 /* VRM */
 static ssize_t show_vrm(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct asb100_data *data = asb100_update_device(dev);
+	struct asb100_data *data = dev_get_drvdata(dev);
 	return sprintf(buf, "%d\n", data->vrm);
 }
 

commit 1beeffe43311f64df8dd0ab08ff6b1858c58363f
Author: Tony Jones <tonyj@suse.de>
Date:   Mon Aug 20 13:46:20 2007 -0700

    hwmon: Convert from class_device to device
    
    Convert from class_device to device for hwmon_device_register/unregister
    
    Signed-off-by: Tony Jones <tonyj@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Mark M. Hoffman <mhoffman@lightlink.com>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 55d92e1e27d1..745bf264bcfd 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -182,7 +182,7 @@ static u8 DIV_TO_REG(long val)
    dynamically allocated, at the same time the client itself is allocated. */
 struct asb100_data {
 	struct i2c_client client;
-	struct class_device *class_dev;
+	struct device *hwmon_dev;
 	struct mutex lock;
 	enum chips type;
 
@@ -844,9 +844,9 @@ static int asb100_detect(struct i2c_adapter *adapter, int address, int kind)
 	if ((err = sysfs_create_group(&new_client->dev.kobj, &asb100_group)))
 		goto ERROR3;
 
-	data->class_dev = hwmon_device_register(&new_client->dev);
-	if (IS_ERR(data->class_dev)) {
-		err = PTR_ERR(data->class_dev);
+	data->hwmon_dev = hwmon_device_register(&new_client->dev);
+	if (IS_ERR(data->hwmon_dev)) {
+		err = PTR_ERR(data->hwmon_dev);
 		goto ERROR4;
 	}
 
@@ -874,7 +874,7 @@ static int asb100_detach_client(struct i2c_client *client)
 
 	/* main client */
 	if (data) {
-		hwmon_device_unregister(data->class_dev);
+		hwmon_device_unregister(data->hwmon_dev);
 		sysfs_remove_group(&client->dev.kobj, &asb100_group);
 	}
 

commit 5bfedac045082a97e20d47d876071279ef984d28
Author: Christian Hohnstaedt <chohnstaedt@innominate.com>
Date:   Thu Aug 16 11:40:10 2007 +0200

    hwmon: Allow writing of negative trigger temperatures
    
    - replace differing temperature variable types by long
    - use strtol() instead of strtoul() for conversion
    
    Signed-off-by: Christian Hohnstaedt <chohnstaedt@innominate.com>
    Acked-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Mark M. Hoffman <mhoffman@lightlink.com>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 57b1c7b7ac3f..55d92e1e27d1 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -143,7 +143,7 @@ static int FAN_FROM_REG(u8 val, int div)
 
 /* TEMP: 0.001C/bit (-128C to +127C)
    REG: 1C/bit, two's complement */
-static u8 TEMP_TO_REG(int temp)
+static u8 TEMP_TO_REG(long temp)
 {
 	int ntemp = SENSORS_LIMIT(temp, ASB100_TEMP_MIN, ASB100_TEMP_MAX);
 	ntemp += (ntemp<0 ? -500 : 500);
@@ -448,7 +448,7 @@ static ssize_t set_##reg(struct device *dev, const char *buf, \
 { \
 	struct i2c_client *client = to_i2c_client(dev); \
 	struct asb100_data *data = i2c_get_clientdata(client); \
-	unsigned long val = simple_strtoul(buf, NULL, 10); \
+	long val = simple_strtol(buf, NULL, 10); \
  \
 	mutex_lock(&data->update_lock); \
 	switch (nr) { \

commit c1685f61b0a3110b701d09b84a9f9a3d4e9ef2e2
Author: Mark M. Hoffman <mhoffman@lightlink.com>
Date:   Sun Sep 24 20:59:49 2006 +0200

    hwmon: Fix unchecked return status, batch 1
    
    hwmon: Fix unchecked return status, batch 1
    
    Fix up some hwmon drivers so that they no longer ignore return status
    from device_create_file().
    
    Signed-off-by: Mark M. Hoffman <mhoffman@lightlink.com>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index facc1ccb8338..57b1c7b7ac3f 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -298,12 +298,6 @@ sysfs_in(4);
 sysfs_in(5);
 sysfs_in(6);
 
-#define device_create_file_in(client, offset) do { \
-	device_create_file(&client->dev, &dev_attr_in##offset##_input); \
-	device_create_file(&client->dev, &dev_attr_in##offset##_min); \
-	device_create_file(&client->dev, &dev_attr_in##offset##_max); \
-} while (0)
-
 /* 3 Fans */
 static ssize_t show_fan(struct device *dev, char *buf, int nr)
 {
@@ -421,12 +415,6 @@ sysfs_fan(1);
 sysfs_fan(2);
 sysfs_fan(3);
 
-#define device_create_file_fan(client, offset) do { \
-	device_create_file(&client->dev, &dev_attr_fan##offset##_input); \
-	device_create_file(&client->dev, &dev_attr_fan##offset##_min); \
-	device_create_file(&client->dev, &dev_attr_fan##offset##_div); \
-} while (0)
-
 /* 4 Temp. Sensors */
 static int sprintf_temp_from_reg(u16 reg, char *buf, int nr)
 {
@@ -515,12 +503,6 @@ sysfs_temp(3);
 sysfs_temp(4);
 
 /* VID */
-#define device_create_file_temp(client, num) do { \
-	device_create_file(&client->dev, &dev_attr_temp##num##_input); \
-	device_create_file(&client->dev, &dev_attr_temp##num##_max); \
-	device_create_file(&client->dev, &dev_attr_temp##num##_max_hyst); \
-} while (0)
-
 static ssize_t show_vid(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct asb100_data *data = asb100_update_device(dev);
@@ -528,8 +510,6 @@ static ssize_t show_vid(struct device *dev, struct device_attribute *attr, char
 }
 
 static DEVICE_ATTR(cpu0_vid, S_IRUGO, show_vid, NULL);
-#define device_create_file_vid(client) \
-device_create_file(&client->dev, &dev_attr_cpu0_vid)
 
 /* VRM */
 static ssize_t show_vrm(struct device *dev, struct device_attribute *attr, char *buf)
@@ -549,8 +529,6 @@ static ssize_t set_vrm(struct device *dev, struct device_attribute *attr, const
 
 /* Alarms */
 static DEVICE_ATTR(vrm, S_IRUGO | S_IWUSR, show_vrm, set_vrm);
-#define device_create_file_vrm(client) \
-device_create_file(&client->dev, &dev_attr_vrm);
 
 static ssize_t show_alarms(struct device *dev, struct device_attribute *attr, char *buf)
 {
@@ -559,8 +537,6 @@ static ssize_t show_alarms(struct device *dev, struct device_attribute *attr, ch
 }
 
 static DEVICE_ATTR(alarms, S_IRUGO, show_alarms, NULL);
-#define device_create_file_alarms(client) \
-device_create_file(&client->dev, &dev_attr_alarms)
 
 /* 1 PWM */
 static ssize_t show_pwm1(struct device *dev, struct device_attribute *attr, char *buf)
@@ -607,10 +583,65 @@ static ssize_t set_pwm_enable1(struct device *dev, struct device_attribute *attr
 static DEVICE_ATTR(pwm1, S_IRUGO | S_IWUSR, show_pwm1, set_pwm1);
 static DEVICE_ATTR(pwm1_enable, S_IRUGO | S_IWUSR,
 		show_pwm_enable1, set_pwm_enable1);
-#define device_create_file_pwm1(client) do { \
-	device_create_file(&new_client->dev, &dev_attr_pwm1); \
-	device_create_file(&new_client->dev, &dev_attr_pwm1_enable); \
-} while (0)
+
+static struct attribute *asb100_attributes[] = {
+	&dev_attr_in0_input.attr,
+	&dev_attr_in0_min.attr,
+	&dev_attr_in0_max.attr,
+	&dev_attr_in1_input.attr,
+	&dev_attr_in1_min.attr,
+	&dev_attr_in1_max.attr,
+	&dev_attr_in2_input.attr,
+	&dev_attr_in2_min.attr,
+	&dev_attr_in2_max.attr,
+	&dev_attr_in3_input.attr,
+	&dev_attr_in3_min.attr,
+	&dev_attr_in3_max.attr,
+	&dev_attr_in4_input.attr,
+	&dev_attr_in4_min.attr,
+	&dev_attr_in4_max.attr,
+	&dev_attr_in5_input.attr,
+	&dev_attr_in5_min.attr,
+	&dev_attr_in5_max.attr,
+	&dev_attr_in6_input.attr,
+	&dev_attr_in6_min.attr,
+	&dev_attr_in6_max.attr,
+
+	&dev_attr_fan1_input.attr,
+	&dev_attr_fan1_min.attr,
+	&dev_attr_fan1_div.attr,
+	&dev_attr_fan2_input.attr,
+	&dev_attr_fan2_min.attr,
+	&dev_attr_fan2_div.attr,
+	&dev_attr_fan3_input.attr,
+	&dev_attr_fan3_min.attr,
+	&dev_attr_fan3_div.attr,
+
+	&dev_attr_temp1_input.attr,
+	&dev_attr_temp1_max.attr,
+	&dev_attr_temp1_max_hyst.attr,
+	&dev_attr_temp2_input.attr,
+	&dev_attr_temp2_max.attr,
+	&dev_attr_temp2_max_hyst.attr,
+	&dev_attr_temp3_input.attr,
+	&dev_attr_temp3_max.attr,
+	&dev_attr_temp3_max_hyst.attr,
+	&dev_attr_temp4_input.attr,
+	&dev_attr_temp4_max.attr,
+	&dev_attr_temp4_max_hyst.attr,
+
+	&dev_attr_cpu0_vid.attr,
+	&dev_attr_vrm.attr,
+	&dev_attr_alarms.attr,
+	&dev_attr_pwm1.attr,
+	&dev_attr_pwm1_enable.attr,
+
+	NULL
+};
+
+static const struct attribute_group asb100_group = {
+	.attrs = asb100_attributes,
+};
 
 /* This function is called when:
 	asb100_driver is inserted (when this module is loaded), for each
@@ -810,38 +841,19 @@ static int asb100_detect(struct i2c_adapter *adapter, int address, int kind)
 	data->fan_min[2] = asb100_read_value(new_client, ASB100_REG_FAN_MIN(2));
 
 	/* Register sysfs hooks */
+	if ((err = sysfs_create_group(&new_client->dev.kobj, &asb100_group)))
+		goto ERROR3;
+
 	data->class_dev = hwmon_device_register(&new_client->dev);
 	if (IS_ERR(data->class_dev)) {
 		err = PTR_ERR(data->class_dev);
-		goto ERROR3;
+		goto ERROR4;
 	}
 
-	device_create_file_in(new_client, 0);
-	device_create_file_in(new_client, 1);
-	device_create_file_in(new_client, 2);
-	device_create_file_in(new_client, 3);
-	device_create_file_in(new_client, 4);
-	device_create_file_in(new_client, 5);
-	device_create_file_in(new_client, 6);
-
-	device_create_file_fan(new_client, 1);
-	device_create_file_fan(new_client, 2);
-	device_create_file_fan(new_client, 3);
-
-	device_create_file_temp(new_client, 1);
-	device_create_file_temp(new_client, 2);
-	device_create_file_temp(new_client, 3);
-	device_create_file_temp(new_client, 4);
-
-	device_create_file_vid(new_client);
-	device_create_file_vrm(new_client);
-
-	device_create_file_alarms(new_client);
-
-	device_create_file_pwm1(new_client);
-
 	return 0;
 
+ERROR4:
+	sysfs_remove_group(&new_client->dev.kobj, &asb100_group);
 ERROR3:
 	i2c_detach_client(data->lm75[1]);
 	i2c_detach_client(data->lm75[0]);
@@ -861,8 +873,10 @@ static int asb100_detach_client(struct i2c_client *client)
 	int err;
 
 	/* main client */
-	if (data)
+	if (data) {
 		hwmon_device_unregister(data->class_dev);
+		sysfs_remove_group(&client->dev.kobj, &asb100_group);
+	}
 
 	if ((err = i2c_detach_client(client)))
 		return err;

commit d6e05edc59ecd79e8badf440c0d295a979bdfa3e
Author: Andreas Mohr <andi@lisas.de>
Date:   Mon Jun 26 18:35:02 2006 +0200

    spelling fixes
    
    acquired (aquired)
    contiguous (contigious)
    successful (succesful, succesfull)
    surprise (suprise)
    whether (weather)
    some other misspellings
    
    Signed-off-by: Andreas Mohr <andi@lisas.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 65b2709f750c..facc1ccb8338 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -341,7 +341,7 @@ static ssize_t set_fan_min(struct device *dev, const char *buf,
 
 /* Note: we save and restore the fan minimum here, because its value is
    determined in part by the fan divisor.  This follows the principle of
-   least suprise; the user doesn't expect the fan minimum to change just
+   least surprise; the user doesn't expect the fan minimum to change just
    because the divisor changed. */
 static ssize_t set_fan_div(struct device *dev, const char *buf,
 				size_t count, int nr)

commit 9a61bf6300533d3b64d7ff29adfec00e596de67d
Author: Ingo Molnar <mingo@elte.hu>
Date:   Wed Jan 18 23:19:26 2006 +0100

    [PATCH] hwmon: Semaphore to mutex conversions
    
    convert drivers/hwmon/*.c semaphore use to mutexes.
    
    the conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    all affected hwmon drivers were build-tested.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index ae9de63cf2e0..65b2709f750c 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -44,6 +44,7 @@
 #include <linux/err.h>
 #include <linux/init.h>
 #include <linux/jiffies.h>
+#include <linux/mutex.h>
 #include "lm75.h"
 
 /*
@@ -182,10 +183,10 @@ static u8 DIV_TO_REG(long val)
 struct asb100_data {
 	struct i2c_client client;
 	struct class_device *class_dev;
-	struct semaphore lock;
+	struct mutex lock;
 	enum chips type;
 
-	struct semaphore update_lock;
+	struct mutex update_lock;
 	unsigned long last_updated;	/* In jiffies */
 
 	/* array of 2 pointers to subclients */
@@ -245,11 +246,11 @@ static ssize_t set_in_##reg(struct device *dev, const char *buf, \
 	struct asb100_data *data = i2c_get_clientdata(client); \
 	unsigned long val = simple_strtoul(buf, NULL, 10); \
  \
-	down(&data->update_lock); \
+	mutex_lock(&data->update_lock); \
 	data->in_##reg[nr] = IN_TO_REG(val); \
 	asb100_write_value(client, ASB100_REG_IN_##REG(nr), \
 		data->in_##reg[nr]); \
-	up(&data->update_lock); \
+	mutex_unlock(&data->update_lock); \
 	return count; \
 }
 
@@ -331,10 +332,10 @@ static ssize_t set_fan_min(struct device *dev, const char *buf,
 	struct asb100_data *data = i2c_get_clientdata(client);
 	u32 val = simple_strtoul(buf, NULL, 10);
 
-	down(&data->update_lock);
+	mutex_lock(&data->update_lock);
 	data->fan_min[nr] = FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));
 	asb100_write_value(client, ASB100_REG_FAN_MIN(nr), data->fan_min[nr]);
-	up(&data->update_lock);
+	mutex_unlock(&data->update_lock);
 	return count;
 }
 
@@ -351,7 +352,7 @@ static ssize_t set_fan_div(struct device *dev, const char *buf,
 	unsigned long val = simple_strtoul(buf, NULL, 10);
 	int reg;
 	
-	down(&data->update_lock);
+	mutex_lock(&data->update_lock);
 
 	min = FAN_FROM_REG(data->fan_min[nr],
 			DIV_FROM_REG(data->fan_div[nr]));
@@ -381,7 +382,7 @@ static ssize_t set_fan_div(struct device *dev, const char *buf,
 		FAN_TO_REG(min, DIV_FROM_REG(data->fan_div[nr]));
 	asb100_write_value(client, ASB100_REG_FAN_MIN(nr), data->fan_min[nr]);
 
-	up(&data->update_lock);
+	mutex_unlock(&data->update_lock);
 
 	return count;
 }
@@ -461,7 +462,7 @@ static ssize_t set_##reg(struct device *dev, const char *buf, \
 	struct asb100_data *data = i2c_get_clientdata(client); \
 	unsigned long val = simple_strtoul(buf, NULL, 10); \
  \
-	down(&data->update_lock); \
+	mutex_lock(&data->update_lock); \
 	switch (nr) { \
 	case 1: case 2: \
 		data->reg[nr] = LM75_TEMP_TO_REG(val); \
@@ -472,7 +473,7 @@ static ssize_t set_##reg(struct device *dev, const char *buf, \
 	} \
 	asb100_write_value(client, ASB100_REG_TEMP_##REG(nr+1), \
 			data->reg[nr]); \
-	up(&data->update_lock); \
+	mutex_unlock(&data->update_lock); \
 	return count; \
 }
 
@@ -574,11 +575,11 @@ static ssize_t set_pwm1(struct device *dev, struct device_attribute *attr, const
 	struct asb100_data *data = i2c_get_clientdata(client);
 	unsigned long val = simple_strtoul(buf, NULL, 10);
 
-	down(&data->update_lock);
+	mutex_lock(&data->update_lock);
 	data->pwm &= 0x80; /* keep the enable bit */
 	data->pwm |= (0x0f & ASB100_PWM_TO_REG(val));
 	asb100_write_value(client, ASB100_REG_PWM1, data->pwm);
-	up(&data->update_lock);
+	mutex_unlock(&data->update_lock);
 	return count;
 }
 
@@ -595,11 +596,11 @@ static ssize_t set_pwm_enable1(struct device *dev, struct device_attribute *attr
 	struct asb100_data *data = i2c_get_clientdata(client);
 	unsigned long val = simple_strtoul(buf, NULL, 10);
 
-	down(&data->update_lock);
+	mutex_lock(&data->update_lock);
 	data->pwm &= 0x0f; /* keep the duty cycle bits */
 	data->pwm |= (val ? 0x80 : 0x00);
 	asb100_write_value(client, ASB100_REG_PWM1, data->pwm);
-	up(&data->update_lock);
+	mutex_unlock(&data->update_lock);
 	return count;
 }
 
@@ -729,7 +730,7 @@ static int asb100_detect(struct i2c_adapter *adapter, int address, int kind)
 	}
 
 	new_client = &data->client;
-	init_MUTEX(&data->lock);
+	mutex_init(&data->lock);
 	i2c_set_clientdata(new_client, data);
 	new_client->addr = address;
 	new_client->adapter = adapter;
@@ -789,7 +790,7 @@ static int asb100_detect(struct i2c_adapter *adapter, int address, int kind)
 	data->type = kind;
 
 	data->valid = 0;
-	init_MUTEX(&data->update_lock);
+	mutex_init(&data->update_lock);
 
 	/* Tell the I2C layer a new client has arrived */
 	if ((err = i2c_attach_client(new_client)))
@@ -885,7 +886,7 @@ static int asb100_read_value(struct i2c_client *client, u16 reg)
 	struct i2c_client *cl;
 	int res, bank;
 
-	down(&data->lock);
+	mutex_lock(&data->lock);
 
 	bank = (reg >> 8) & 0x0f;
 	if (bank > 2)
@@ -919,7 +920,7 @@ static int asb100_read_value(struct i2c_client *client, u16 reg)
 	if (bank > 2)
 		i2c_smbus_write_byte_data(client, ASB100_REG_BANK, 0);
 
-	up(&data->lock);
+	mutex_unlock(&data->lock);
 
 	return res;
 }
@@ -930,7 +931,7 @@ static void asb100_write_value(struct i2c_client *client, u16 reg, u16 value)
 	struct i2c_client *cl;
 	int bank;
 
-	down(&data->lock);
+	mutex_lock(&data->lock);
 
 	bank = (reg >> 8) & 0x0f;
 	if (bank > 2)
@@ -960,7 +961,7 @@ static void asb100_write_value(struct i2c_client *client, u16 reg, u16 value)
 	if (bank > 2)
 		i2c_smbus_write_byte_data(client, ASB100_REG_BANK, 0);
 
-	up(&data->lock);
+	mutex_unlock(&data->lock);
 }
 
 static void asb100_init_client(struct i2c_client *client)
@@ -984,7 +985,7 @@ static struct asb100_data *asb100_update_device(struct device *dev)
 	struct asb100_data *data = i2c_get_clientdata(client);
 	int i;
 
-	down(&data->update_lock);
+	mutex_lock(&data->update_lock);
 
 	if (time_after(jiffies, data->last_updated + HZ + HZ / 2)
 		|| !data->valid) {
@@ -1042,7 +1043,7 @@ static struct asb100_data *asb100_update_device(struct device *dev)
 		dev_dbg(&client->dev, "... device update complete\n");
 	}
 
-	up(&data->update_lock);
+	mutex_unlock(&data->update_lock);
 
 	return data;
 }

commit 2b48716d1d2f2edb1e7cbc5ecf1cb2cb39373e33
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Dec 6 15:33:15 2005 -0800

    [PATCH] I2C: Remove .owner setting from i2c_driver as it's no longer needed
    
    Now that i2c_add_driver() doesn't need the module owner to be set by
    hand, we can delete it from the drivers.  This patch catches all of the
    drivers that I found in the current tree (if a driver sets the .owner by
    hand, it's not a problem, just not needed.)
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: Jean Delvare <khali@linux-fr.org>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 3068de0dc728..ae9de63cf2e0 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -218,7 +218,6 @@ static void asb100_init_client(struct i2c_client *client);
 
 static struct i2c_driver asb100_driver = {
 	.driver = {
-		.owner	= THIS_MODULE,
 		.name	= "asb100",
 	},
 	.id		= I2C_DRIVERID_ASB100,

commit cdaf79349c7d24e1d33acb6497849c9e956a33ea
Author: Laurent Riffard <laurent.riffard@free.fr>
Date:   Sat Nov 26 20:37:41 2005 +0100

    [PATCH] i2c: Drop i2c_driver.{owner,name}, 3 of 11
    
    We should use the i2c_driver.driver's .name and .owner fields
    instead of the i2c_driver's ones.
    
    This patch updates the hwmon drivers.
    
    Signed-off-by: Laurent Riffard <laurent.riffard@free.fr>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 7227f800bef9..3068de0dc728 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -217,8 +217,10 @@ static struct asb100_data *asb100_update_device(struct device *dev);
 static void asb100_init_client(struct i2c_client *client);
 
 static struct i2c_driver asb100_driver = {
-	.owner		= THIS_MODULE,
-	.name		= "asb100",
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "asb100",
+	},
 	.id		= I2C_DRIVERID_ASB100,
 	.attach_adapter	= asb100_attach_adapter,
 	.detach_client	= asb100_detach_client,

commit 8a9947552d43b0d20d5fa23ac0ba435d526be454
Author: Jean Delvare <khali@linux-fr.org>
Date:   Sat Nov 26 20:28:06 2005 +0100

    [PATCH] i2c: Drop i2c_driver.flags, 2 of 3
    
    Just about every i2c chip driver sets the I2C_DF_NOTIFY flag, so we
    can simply make it the default and drop the flag. If any driver really
    doesn't want to be notified when i2c adapters are added, that driver
    can simply omit to set .attach_adapter. This approach is also more
    robust as it prevents accidental NULL pointer dereferences.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 52c469722a65..7227f800bef9 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -220,7 +220,6 @@ static struct i2c_driver asb100_driver = {
 	.owner		= THIS_MODULE,
 	.name		= "asb100",
 	.id		= I2C_DRIVERID_ASB100,
-	.flags		= I2C_DF_NOTIFY,
 	.attach_adapter	= asb100_attach_adapter,
 	.detach_client	= asb100_detach_client,
 };

commit ba9c2e8d15da029ea3051c95e446b2d638ef02e2
Author: Deepak Saxena <dsaxena@plexity.net>
Date:   Mon Oct 17 23:08:32 2005 +0200

    [PATCH] hwmon: kzalloc conversion
    
    Use kzalloc instead of kmalloc+memset in all hardware monitoring
    drivers.
    
    Signed-off-by: Deepak Saxena <dsaxena@plexity.net>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 8e34855a6274..52c469722a65 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -629,19 +629,17 @@ static int asb100_detect_subclients(struct i2c_adapter *adapter, int address,
 	int i, id, err;
 	struct asb100_data *data = i2c_get_clientdata(new_client);
 
-	data->lm75[0] = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	data->lm75[0] = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
 	if (!(data->lm75[0])) {
 		err = -ENOMEM;
 		goto ERROR_SC_0;
 	}
-	memset(data->lm75[0], 0x00, sizeof(struct i2c_client));
 
-	data->lm75[1] = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	data->lm75[1] = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
 	if (!(data->lm75[1])) {
 		err = -ENOMEM;
 		goto ERROR_SC_1;
 	}
-	memset(data->lm75[1], 0x00, sizeof(struct i2c_client));
 
 	id = i2c_adapter_id(adapter);
 
@@ -724,12 +722,11 @@ static int asb100_detect(struct i2c_adapter *adapter, int address, int kind)
 	   client structure, even though we cannot fill it completely yet.
 	   But it allows us to access asb100_{read,write}_value. */
 
-	if (!(data = kmalloc(sizeof(struct asb100_data), GFP_KERNEL))) {
-		pr_debug("asb100.o: detect failed, kmalloc failed!\n");
+	if (!(data = kzalloc(sizeof(struct asb100_data), GFP_KERNEL))) {
+		pr_debug("asb100.o: detect failed, kzalloc failed!\n");
 		err = -ENOMEM;
 		goto ERROR0;
 	}
-	memset(data, 0, sizeof(struct asb100_data));
 
 	new_client = &data->client;
 	init_MUTEX(&data->lock);

commit 303760b44a7a142cb9f4c9df4609fb63bbda98db
Author: Jean Delvare <khali@linux-fr.org>
Date:   Sun Jul 31 21:52:01 2005 +0200

    [PATCH] hwmon: hwmon vs i2c, second round (07/11)
    
    The only part left in i2c-sensor is the VRM/VRD/VID handling code.
    This is in no way related to i2c, so it doesn't belong there. Move
    the code to hwmon, where it belongs.
    
    Note that not all hardware monitoring drivers do VRM/VRD/VID
    operations, so less drivers depend on hwmon-vid than there were
    depending on i2c-sensor.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 66b0dbd1af0e..8e34855a6274 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -39,8 +39,8 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/i2c.h>
-#include <linux/i2c-vid.h>
 #include <linux/hwmon.h>
+#include <linux/hwmon-vid.h>
 #include <linux/err.h>
 #include <linux/init.h>
 #include <linux/jiffies.h>
@@ -973,7 +973,7 @@ static void asb100_init_client(struct i2c_client *client)
 
 	vid = asb100_read_value(client, ASB100_REG_VID_FANDIV) & 0x0f;
 	vid |= (asb100_read_value(client, ASB100_REG_CHIPID) & 0x01) << 4;
-	data->vrm = i2c_which_vrm();
+	data->vrm = vid_which_vrm();
 	vid = vid_from_reg(vid, data->vrm);
 
 	/* Start monitoring */

commit f4b50261207c987913f076d867c2e154d71fd012
Author: Jean Delvare <khali@linux-fr.org>
Date:   Sun Jul 31 21:49:03 2005 +0200

    [PATCH] hwmon: hwmon vs i2c, second round (06/11)
    
    The only thing left in i2c-sensor.h are module parameter definition
    macros. It's only an extension of what i2c.h offers, and this extension
    is not sensors-specific. As a matter of fact, a few non-sensors drivers
    use them. So we better merge them in i2c.h, and get rid of i2c-sensor.h
    altogether.
    
    Signed-off-by: Jean Delvare <khali@linux-fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index a6c6c9d3fddd..66b0dbd1af0e 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -39,7 +39,6 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/i2c.h>
-#include <linux/i2c-sensor.h>
 #include <linux/i2c-vid.h>
 #include <linux/hwmon.h>
 #include <linux/err.h>
@@ -57,7 +56,7 @@
 static unsigned short normal_i2c[] = { 0x2d, I2C_CLIENT_END };
 
 /* Insmod parameters */
-SENSORS_INSMOD_1(asb100);
+I2C_CLIENT_INSMOD_1(asb100);
 I2C_CLIENT_MODULE_PARM(force_subclients, "List of subclient addresses: "
 	"{bus, clientaddr, subclientaddr1, subclientaddr2}");
 

commit 2ed2dc3c116d26fc6a9384e83d136b15cc203b6c
Author: Jean Delvare <khali@linux-fr.org>
Date:   Sun Jul 31 21:42:02 2005 +0200

    [PATCH] hwmon: hwmon vs i2c, second round (04/11)
    
    i2c_probe and i2c_detect now do the exact same thing and operate on
    the same data structure, so we can have everyone call i2c_probe.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index c6a2c94fad36..a6c6c9d3fddd 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -621,7 +621,7 @@ static int asb100_attach_adapter(struct i2c_adapter *adapter)
 {
 	if (!(adapter->class & I2C_CLASS_HWMON))
 		return 0;
-	return i2c_detect(adapter, &addr_data, asb100_detect);
+	return i2c_probe(adapter, &addr_data, asb100_detect);
 }
 
 static int asb100_detect_subclients(struct i2c_adapter *adapter, int address,

commit 7bef559455fc71f66f8573cc1aafe1dd33966c1c
Author: Jean Delvare <khali@linux-fr.org>
Date:   Wed Jul 27 22:14:49 2005 +0200

    [PATCH] I2C: refactor message in i2c_detach_client
    
    We could refactor the error message 34 different i2c drivers print if
    i2c_detach_client() fails in this function itself. Saves quite a few
    lines of code. Documentation is updated to reflect that change.
    
    Note that this patch should be applied after Rudolf Marek's w83792d
    patches.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 290f7d2ac0a8..c6a2c94fad36 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -867,11 +867,8 @@ static int asb100_detach_client(struct i2c_client *client)
 	if (data)
 		hwmon_device_unregister(data->class_dev);
 
-	if ((err = i2c_detach_client(client))) {
-		dev_err(&client->dev, "client deregistration failed; "
-			"client not detached.\n");
+	if ((err = i2c_detach_client(client)))
 		return err;
-	}
 
 	/* main client */
 	if (data)

commit 02ff982c6911de1484e13a1d765d7bd31a0f8fee
Author: Jean Delvare <khali@linux-fr.org>
Date:   Wed Jul 20 00:05:33 2005 +0200

    [PATCH] I2C: Separate non-i2c hwmon drivers from i2c-core (8/9)
    
    Kill all uses of i2c_is_isa_adapter except for the hybrid drivers (it87,
    lm78, w83781d). The i2c-isa adapter not being registered with the i2c
    core anymore, drivers don't have to fear being erroneously attached to
    it.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index d1856acf87a0..290f7d2ac0a8 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -714,14 +714,6 @@ static int asb100_detect(struct i2c_adapter *adapter, int address, int kind)
 	struct i2c_client *new_client;
 	struct asb100_data *data;
 
-	/* asb100 is SMBus only */
-	if (i2c_is_isa_adapter(adapter)) {
-		pr_debug("asb100.o: detect failed, "
-				"cannot attach to legacy adapter!\n");
-		err = -ENODEV;
-		goto ERROR0;
-	}
-
 	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
 		pr_debug("asb100.o: detect failed, "
 				"smbus byte data not supported!\n");

commit 5071860aba7fc69279ab822638ed2c2e4549f9fd
Author: Jean Delvare <khali@linux-fr.org>
Date:   Wed Jul 20 00:02:32 2005 +0200

    [PATCH] I2C: Separate non-i2c hwmon drivers from i2c-core (7/9)
    
    Kill normal_isa in header files, documentation and all chip drivers, as
    it is no more used.
    
    normal_i2c could be renamed to normal, but I decided not to do so at the
    moment, so as to limit the number of changes. This might be done later
    as part of the i2c_probe/i2c_detect merge.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 3ab7a2ddafba..d1856acf87a0 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -56,9 +56,6 @@
 /* I2C addresses to scan */
 static unsigned short normal_i2c[] = { 0x2d, I2C_CLIENT_END };
 
-/* ISA addresses to scan (none) */
-static unsigned int normal_isa[] = { I2C_CLIENT_ISA_END };
-
 /* Insmod parameters */
 SENSORS_INSMOD_1(asb100);
 I2C_CLIENT_MODULE_PARM(force_subclients, "List of subclient addresses: "

commit 943b0830cebe4711354945ed3cb44e84152aaca0
Author: Mark M. Hoffman <mhoffman@lightlink.com>
Date:   Fri Jul 15 21:39:18 2005 -0400

    [PATCH] I2C hwmon: add hwmon sysfs class to drivers
    
    This patch modifies sensors chip drivers to make use of the new
    sysfs class "hwmon".
    
    Signed-off-by: Mark M. Hoffman <mhoffman@lightlink.com>
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
index 70d996d6fe0a..3ab7a2ddafba 100644
--- a/drivers/hwmon/asb100.c
+++ b/drivers/hwmon/asb100.c
@@ -41,6 +41,8 @@
 #include <linux/i2c.h>
 #include <linux/i2c-sensor.h>
 #include <linux/i2c-vid.h>
+#include <linux/hwmon.h>
+#include <linux/err.h>
 #include <linux/init.h>
 #include <linux/jiffies.h>
 #include "lm75.h"
@@ -183,6 +185,7 @@ static u8 DIV_TO_REG(long val)
    dynamically allocated, at the same time the client itself is allocated. */
 struct asb100_data {
 	struct i2c_client client;
+	struct class_device *class_dev;
 	struct semaphore lock;
 	enum chips type;
 
@@ -821,6 +824,12 @@ static int asb100_detect(struct i2c_adapter *adapter, int address, int kind)
 	data->fan_min[2] = asb100_read_value(new_client, ASB100_REG_FAN_MIN(2));
 
 	/* Register sysfs hooks */
+	data->class_dev = hwmon_device_register(&new_client->dev);
+	if (IS_ERR(data->class_dev)) {
+		err = PTR_ERR(data->class_dev);
+		goto ERROR3;
+	}
+
 	device_create_file_in(new_client, 0);
 	device_create_file_in(new_client, 1);
 	device_create_file_in(new_client, 2);
@@ -847,6 +856,11 @@ static int asb100_detect(struct i2c_adapter *adapter, int address, int kind)
 
 	return 0;
 
+ERROR3:
+	i2c_detach_client(data->lm75[1]);
+	i2c_detach_client(data->lm75[0]);
+	kfree(data->lm75[1]);
+	kfree(data->lm75[0]);
 ERROR2:
 	i2c_detach_client(new_client);
 ERROR1:
@@ -857,21 +871,26 @@ static int asb100_detect(struct i2c_adapter *adapter, int address, int kind)
 
 static int asb100_detach_client(struct i2c_client *client)
 {
+	struct asb100_data *data = i2c_get_clientdata(client);
 	int err;
 
+	/* main client */
+	if (data)
+		hwmon_device_unregister(data->class_dev);
+
 	if ((err = i2c_detach_client(client))) {
 		dev_err(&client->dev, "client deregistration failed; "
 			"client not detached.\n");
 		return err;
 	}
 
-	if (i2c_get_clientdata(client)==NULL) {
-		/* subclients */
+	/* main client */
+	if (data)
+		kfree(data);
+
+	/* subclient */
+	else
 		kfree(client);
-	} else {
-		/* main client */
-		kfree(i2c_get_clientdata(client));
-	}
 
 	return 0;
 }

commit 8d5d45fb14680326f833295f2316a4ec5e357220
Author: Jean Delvare <khali@linux-fr.org>
Date:   Sat Jul 2 18:20:26 2005 +0200

    [PATCH] I2C: Move hwmon drivers (2/3)
    
    Part 2: Move the driver files themselves.
    
    Note that the patch "adds trailing whitespace", because it does move the
    files as-is, and some files happen to have trailing whitespace.
    
    From: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/hwmon/asb100.c b/drivers/hwmon/asb100.c
new file mode 100644
index 000000000000..70d996d6fe0a
--- /dev/null
+++ b/drivers/hwmon/asb100.c
@@ -0,0 +1,1065 @@
+/*
+    asb100.c - Part of lm_sensors, Linux kernel modules for hardware
+	        monitoring
+
+    Copyright (C) 2004 Mark M. Hoffman <mhoffman@lightlink.com>
+
+	(derived from w83781d.c)
+
+    Copyright (C) 1998 - 2003  Frodo Looijaard <frodol@dds.nl>,
+    Philip Edelbrock <phil@netroedge.com>, and
+    Mark Studebaker <mdsxyz123@yahoo.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+/*
+    This driver supports the hardware sensor chips: Asus ASB100 and
+    ASB100-A "BACH".
+
+    ASB100-A supports pwm1, while plain ASB100 does not.  There is no known
+    way for the driver to tell which one is there.
+
+    Chip	#vin	#fanin	#pwm	#temp	wchipid	vendid	i2c	ISA
+    asb100	7	3	1	4	0x31	0x0694	yes	no
+*/
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/i2c-sensor.h>
+#include <linux/i2c-vid.h>
+#include <linux/init.h>
+#include <linux/jiffies.h>
+#include "lm75.h"
+
+/*
+	HISTORY:
+	2003-12-29	1.0.0	Ported from lm_sensors project for kernel 2.6
+*/
+#define ASB100_VERSION "1.0.0"
+
+/* I2C addresses to scan */
+static unsigned short normal_i2c[] = { 0x2d, I2C_CLIENT_END };
+
+/* ISA addresses to scan (none) */
+static unsigned int normal_isa[] = { I2C_CLIENT_ISA_END };
+
+/* Insmod parameters */
+SENSORS_INSMOD_1(asb100);
+I2C_CLIENT_MODULE_PARM(force_subclients, "List of subclient addresses: "
+	"{bus, clientaddr, subclientaddr1, subclientaddr2}");
+
+/* Voltage IN registers 0-6 */
+#define ASB100_REG_IN(nr)	(0x20 + (nr))
+#define ASB100_REG_IN_MAX(nr)	(0x2b + (nr * 2))
+#define ASB100_REG_IN_MIN(nr)	(0x2c + (nr * 2))
+
+/* FAN IN registers 1-3 */
+#define ASB100_REG_FAN(nr)	(0x28 + (nr))
+#define ASB100_REG_FAN_MIN(nr)	(0x3b + (nr))
+
+/* TEMPERATURE registers 1-4 */
+static const u16 asb100_reg_temp[]	= {0, 0x27, 0x150, 0x250, 0x17};
+static const u16 asb100_reg_temp_max[]	= {0, 0x39, 0x155, 0x255, 0x18};
+static const u16 asb100_reg_temp_hyst[]	= {0, 0x3a, 0x153, 0x253, 0x19};
+
+#define ASB100_REG_TEMP(nr) (asb100_reg_temp[nr])
+#define ASB100_REG_TEMP_MAX(nr) (asb100_reg_temp_max[nr])
+#define ASB100_REG_TEMP_HYST(nr) (asb100_reg_temp_hyst[nr])
+
+#define ASB100_REG_TEMP2_CONFIG	0x0152
+#define ASB100_REG_TEMP3_CONFIG	0x0252
+
+
+#define ASB100_REG_CONFIG	0x40
+#define ASB100_REG_ALARM1	0x41
+#define ASB100_REG_ALARM2	0x42
+#define ASB100_REG_SMIM1	0x43
+#define ASB100_REG_SMIM2	0x44
+#define ASB100_REG_VID_FANDIV	0x47
+#define ASB100_REG_I2C_ADDR	0x48
+#define ASB100_REG_CHIPID	0x49
+#define ASB100_REG_I2C_SUBADDR	0x4a
+#define ASB100_REG_PIN		0x4b
+#define ASB100_REG_IRQ		0x4c
+#define ASB100_REG_BANK		0x4e
+#define ASB100_REG_CHIPMAN	0x4f
+
+#define ASB100_REG_WCHIPID	0x58
+
+/* bit 7 -> enable, bits 0-3 -> duty cycle */
+#define ASB100_REG_PWM1		0x59
+
+/* CONVERSIONS
+   Rounding and limit checking is only done on the TO_REG variants. */
+
+/* These constants are a guess, consistent w/ w83781d */
+#define ASB100_IN_MIN (   0)
+#define ASB100_IN_MAX (4080)
+
+/* IN: 1/1000 V (0V to 4.08V)
+   REG: 16mV/bit */
+static u8 IN_TO_REG(unsigned val)
+{
+	unsigned nval = SENSORS_LIMIT(val, ASB100_IN_MIN, ASB100_IN_MAX);
+	return (nval + 8) / 16;
+}
+
+static unsigned IN_FROM_REG(u8 reg)
+{
+	return reg * 16;
+}
+
+static u8 FAN_TO_REG(long rpm, int div)
+{
+	if (rpm == -1)
+		return 0;
+	if (rpm == 0)
+		return 255;
+	rpm = SENSORS_LIMIT(rpm, 1, 1000000);
+	return SENSORS_LIMIT((1350000 + rpm * div / 2) / (rpm * div), 1, 254);
+}
+
+static int FAN_FROM_REG(u8 val, int div)
+{
+	return val==0 ? -1 : val==255 ? 0 : 1350000/(val*div);
+}
+
+/* These constants are a guess, consistent w/ w83781d */
+#define ASB100_TEMP_MIN (-128000)
+#define ASB100_TEMP_MAX ( 127000)
+
+/* TEMP: 0.001C/bit (-128C to +127C)
+   REG: 1C/bit, two's complement */
+static u8 TEMP_TO_REG(int temp)
+{
+	int ntemp = SENSORS_LIMIT(temp, ASB100_TEMP_MIN, ASB100_TEMP_MAX);
+	ntemp += (ntemp<0 ? -500 : 500);
+	return (u8)(ntemp / 1000);
+}
+
+static int TEMP_FROM_REG(u8 reg)
+{
+	return (s8)reg * 1000;
+}
+
+/* PWM: 0 - 255 per sensors documentation
+   REG: (6.25% duty cycle per bit) */
+static u8 ASB100_PWM_TO_REG(int pwm)
+{
+	pwm = SENSORS_LIMIT(pwm, 0, 255);
+	return (u8)(pwm / 16);
+}
+
+static int ASB100_PWM_FROM_REG(u8 reg)
+{
+	return reg * 16;
+}
+
+#define DIV_FROM_REG(val) (1 << (val))
+
+/* FAN DIV: 1, 2, 4, or 8 (defaults to 2)
+   REG: 0, 1, 2, or 3 (respectively) (defaults to 1) */
+static u8 DIV_TO_REG(long val)
+{
+	return val==8 ? 3 : val==4 ? 2 : val==1 ? 0 : 1;
+}
+
+/* For each registered client, we need to keep some data in memory. That
+   data is pointed to by client->data. The structure itself is
+   dynamically allocated, at the same time the client itself is allocated. */
+struct asb100_data {
+	struct i2c_client client;
+	struct semaphore lock;
+	enum chips type;
+
+	struct semaphore update_lock;
+	unsigned long last_updated;	/* In jiffies */
+
+	/* array of 2 pointers to subclients */
+	struct i2c_client *lm75[2];
+
+	char valid;		/* !=0 if following fields are valid */
+	u8 in[7];		/* Register value */
+	u8 in_max[7];		/* Register value */
+	u8 in_min[7];		/* Register value */
+	u8 fan[3];		/* Register value */
+	u8 fan_min[3];		/* Register value */
+	u16 temp[4];		/* Register value (0 and 3 are u8 only) */
+	u16 temp_max[4];	/* Register value (0 and 3 are u8 only) */
+	u16 temp_hyst[4];	/* Register value (0 and 3 are u8 only) */
+	u8 fan_div[3];		/* Register encoding, right justified */
+	u8 pwm;			/* Register encoding */
+	u8 vid;			/* Register encoding, combined */
+	u32 alarms;		/* Register encoding, combined */
+	u8 vrm;
+};
+
+static int asb100_read_value(struct i2c_client *client, u16 reg);
+static void asb100_write_value(struct i2c_client *client, u16 reg, u16 val);
+
+static int asb100_attach_adapter(struct i2c_adapter *adapter);
+static int asb100_detect(struct i2c_adapter *adapter, int address, int kind);
+static int asb100_detach_client(struct i2c_client *client);
+static struct asb100_data *asb100_update_device(struct device *dev);
+static void asb100_init_client(struct i2c_client *client);
+
+static struct i2c_driver asb100_driver = {
+	.owner		= THIS_MODULE,
+	.name		= "asb100",
+	.id		= I2C_DRIVERID_ASB100,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter	= asb100_attach_adapter,
+	.detach_client	= asb100_detach_client,
+};
+
+/* 7 Voltages */
+#define show_in_reg(reg) \
+static ssize_t show_##reg (struct device *dev, char *buf, int nr) \
+{ \
+	struct asb100_data *data = asb100_update_device(dev); \
+	return sprintf(buf, "%d\n", IN_FROM_REG(data->reg[nr])); \
+}
+
+show_in_reg(in)
+show_in_reg(in_min)
+show_in_reg(in_max)
+
+#define set_in_reg(REG, reg) \
+static ssize_t set_in_##reg(struct device *dev, const char *buf, \
+		size_t count, int nr) \
+{ \
+	struct i2c_client *client = to_i2c_client(dev); \
+	struct asb100_data *data = i2c_get_clientdata(client); \
+	unsigned long val = simple_strtoul(buf, NULL, 10); \
+ \
+	down(&data->update_lock); \
+	data->in_##reg[nr] = IN_TO_REG(val); \
+	asb100_write_value(client, ASB100_REG_IN_##REG(nr), \
+		data->in_##reg[nr]); \
+	up(&data->update_lock); \
+	return count; \
+}
+
+set_in_reg(MIN, min)
+set_in_reg(MAX, max)
+
+#define sysfs_in(offset) \
+static ssize_t \
+	show_in##offset (struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	return show_in(dev, buf, offset); \
+} \
+static DEVICE_ATTR(in##offset##_input, S_IRUGO, \
+		show_in##offset, NULL); \
+static ssize_t \
+	show_in##offset##_min (struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	return show_in_min(dev, buf, offset); \
+} \
+static ssize_t \
+	show_in##offset##_max (struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	return show_in_max(dev, buf, offset); \
+} \
+static ssize_t set_in##offset##_min (struct device *dev, struct device_attribute *attr, \
+		const char *buf, size_t count) \
+{ \
+	return set_in_min(dev, buf, count, offset); \
+} \
+static ssize_t set_in##offset##_max (struct device *dev, struct device_attribute *attr, \
+		const char *buf, size_t count) \
+{ \
+	return set_in_max(dev, buf, count, offset); \
+} \
+static DEVICE_ATTR(in##offset##_min, S_IRUGO | S_IWUSR, \
+		show_in##offset##_min, set_in##offset##_min); \
+static DEVICE_ATTR(in##offset##_max, S_IRUGO | S_IWUSR, \
+		show_in##offset##_max, set_in##offset##_max);
+
+sysfs_in(0);
+sysfs_in(1);
+sysfs_in(2);
+sysfs_in(3);
+sysfs_in(4);
+sysfs_in(5);
+sysfs_in(6);
+
+#define device_create_file_in(client, offset) do { \
+	device_create_file(&client->dev, &dev_attr_in##offset##_input); \
+	device_create_file(&client->dev, &dev_attr_in##offset##_min); \
+	device_create_file(&client->dev, &dev_attr_in##offset##_max); \
+} while (0)
+
+/* 3 Fans */
+static ssize_t show_fan(struct device *dev, char *buf, int nr)
+{
+	struct asb100_data *data = asb100_update_device(dev);
+	return sprintf(buf, "%d\n", FAN_FROM_REG(data->fan[nr],
+		DIV_FROM_REG(data->fan_div[nr])));
+}
+
+static ssize_t show_fan_min(struct device *dev, char *buf, int nr)
+{
+	struct asb100_data *data = asb100_update_device(dev);
+	return sprintf(buf, "%d\n", FAN_FROM_REG(data->fan_min[nr],
+		DIV_FROM_REG(data->fan_div[nr])));
+}
+
+static ssize_t show_fan_div(struct device *dev, char *buf, int nr)
+{
+	struct asb100_data *data = asb100_update_device(dev);
+	return sprintf(buf, "%d\n", DIV_FROM_REG(data->fan_div[nr]));
+}
+
+static ssize_t set_fan_min(struct device *dev, const char *buf,
+				size_t count, int nr)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct asb100_data *data = i2c_get_clientdata(client);
+	u32 val = simple_strtoul(buf, NULL, 10);
+
+	down(&data->update_lock);
+	data->fan_min[nr] = FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));
+	asb100_write_value(client, ASB100_REG_FAN_MIN(nr), data->fan_min[nr]);
+	up(&data->update_lock);
+	return count;
+}
+
+/* Note: we save and restore the fan minimum here, because its value is
+   determined in part by the fan divisor.  This follows the principle of
+   least suprise; the user doesn't expect the fan minimum to change just
+   because the divisor changed. */
+static ssize_t set_fan_div(struct device *dev, const char *buf,
+				size_t count, int nr)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct asb100_data *data = i2c_get_clientdata(client);
+	unsigned long min;
+	unsigned long val = simple_strtoul(buf, NULL, 10);
+	int reg;
+	
+	down(&data->update_lock);
+
+	min = FAN_FROM_REG(data->fan_min[nr],
+			DIV_FROM_REG(data->fan_div[nr]));
+	data->fan_div[nr] = DIV_TO_REG(val);
+
+	switch(nr) {
+	case 0:	/* fan 1 */
+		reg = asb100_read_value(client, ASB100_REG_VID_FANDIV);
+		reg = (reg & 0xcf) | (data->fan_div[0] << 4);
+		asb100_write_value(client, ASB100_REG_VID_FANDIV, reg);
+		break;
+
+	case 1:	/* fan 2 */
+		reg = asb100_read_value(client, ASB100_REG_VID_FANDIV);
+		reg = (reg & 0x3f) | (data->fan_div[1] << 6);
+		asb100_write_value(client, ASB100_REG_VID_FANDIV, reg);
+		break;
+
+	case 2:	/* fan 3 */
+		reg = asb100_read_value(client, ASB100_REG_PIN);
+		reg = (reg & 0x3f) | (data->fan_div[2] << 6);
+		asb100_write_value(client, ASB100_REG_PIN, reg);
+		break;
+	}
+
+	data->fan_min[nr] =
+		FAN_TO_REG(min, DIV_FROM_REG(data->fan_div[nr]));
+	asb100_write_value(client, ASB100_REG_FAN_MIN(nr), data->fan_min[nr]);
+
+	up(&data->update_lock);
+
+	return count;
+}
+
+#define sysfs_fan(offset) \
+static ssize_t show_fan##offset(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	return show_fan(dev, buf, offset - 1); \
+} \
+static ssize_t show_fan##offset##_min(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	return show_fan_min(dev, buf, offset - 1); \
+} \
+static ssize_t show_fan##offset##_div(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	return show_fan_div(dev, buf, offset - 1); \
+} \
+static ssize_t set_fan##offset##_min(struct device *dev, struct device_attribute *attr, const char *buf, \
+					size_t count) \
+{ \
+	return set_fan_min(dev, buf, count, offset - 1); \
+} \
+static ssize_t set_fan##offset##_div(struct device *dev, struct device_attribute *attr, const char *buf, \
+					size_t count) \
+{ \
+	return set_fan_div(dev, buf, count, offset - 1); \
+} \
+static DEVICE_ATTR(fan##offset##_input, S_IRUGO, \
+		show_fan##offset, NULL); \
+static DEVICE_ATTR(fan##offset##_min, S_IRUGO | S_IWUSR, \
+		show_fan##offset##_min, set_fan##offset##_min); \
+static DEVICE_ATTR(fan##offset##_div, S_IRUGO | S_IWUSR, \
+		show_fan##offset##_div, set_fan##offset##_div);
+
+sysfs_fan(1);
+sysfs_fan(2);
+sysfs_fan(3);
+
+#define device_create_file_fan(client, offset) do { \
+	device_create_file(&client->dev, &dev_attr_fan##offset##_input); \
+	device_create_file(&client->dev, &dev_attr_fan##offset##_min); \
+	device_create_file(&client->dev, &dev_attr_fan##offset##_div); \
+} while (0)
+
+/* 4 Temp. Sensors */
+static int sprintf_temp_from_reg(u16 reg, char *buf, int nr)
+{
+	int ret = 0;
+
+	switch (nr) {
+	case 1: case 2:
+		ret = sprintf(buf, "%d\n", LM75_TEMP_FROM_REG(reg));
+		break;
+	case 0: case 3: default:
+		ret = sprintf(buf, "%d\n", TEMP_FROM_REG(reg));
+		break;
+	}
+	return ret;
+}
+		 	
+#define show_temp_reg(reg) \
+static ssize_t show_##reg(struct device *dev, char *buf, int nr) \
+{ \
+	struct asb100_data *data = asb100_update_device(dev); \
+	return sprintf_temp_from_reg(data->reg[nr], buf, nr); \
+}
+
+show_temp_reg(temp);
+show_temp_reg(temp_max);
+show_temp_reg(temp_hyst);
+
+#define set_temp_reg(REG, reg) \
+static ssize_t set_##reg(struct device *dev, const char *buf, \
+			size_t count, int nr) \
+{ \
+	struct i2c_client *client = to_i2c_client(dev); \
+	struct asb100_data *data = i2c_get_clientdata(client); \
+	unsigned long val = simple_strtoul(buf, NULL, 10); \
+ \
+	down(&data->update_lock); \
+	switch (nr) { \
+	case 1: case 2: \
+		data->reg[nr] = LM75_TEMP_TO_REG(val); \
+		break; \
+	case 0: case 3: default: \
+		data->reg[nr] = TEMP_TO_REG(val); \
+		break; \
+	} \
+	asb100_write_value(client, ASB100_REG_TEMP_##REG(nr+1), \
+			data->reg[nr]); \
+	up(&data->update_lock); \
+	return count; \
+}
+
+set_temp_reg(MAX, temp_max);
+set_temp_reg(HYST, temp_hyst);
+
+#define sysfs_temp(num) \
+static ssize_t show_temp##num(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	return show_temp(dev, buf, num-1); \
+} \
+static DEVICE_ATTR(temp##num##_input, S_IRUGO, show_temp##num, NULL); \
+static ssize_t show_temp_max##num(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	return show_temp_max(dev, buf, num-1); \
+} \
+static ssize_t set_temp_max##num(struct device *dev, struct device_attribute *attr, const char *buf, \
+					size_t count) \
+{ \
+	return set_temp_max(dev, buf, count, num-1); \
+} \
+static DEVICE_ATTR(temp##num##_max, S_IRUGO | S_IWUSR, \
+		show_temp_max##num, set_temp_max##num); \
+static ssize_t show_temp_hyst##num(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	return show_temp_hyst(dev, buf, num-1); \
+} \
+static ssize_t set_temp_hyst##num(struct device *dev, struct device_attribute *attr, const char *buf, \
+					size_t count) \
+{ \
+	return set_temp_hyst(dev, buf, count, num-1); \
+} \
+static DEVICE_ATTR(temp##num##_max_hyst, S_IRUGO | S_IWUSR, \
+		show_temp_hyst##num, set_temp_hyst##num);
+
+sysfs_temp(1);
+sysfs_temp(2);
+sysfs_temp(3);
+sysfs_temp(4);
+
+/* VID */
+#define device_create_file_temp(client, num) do { \
+	device_create_file(&client->dev, &dev_attr_temp##num##_input); \
+	device_create_file(&client->dev, &dev_attr_temp##num##_max); \
+	device_create_file(&client->dev, &dev_attr_temp##num##_max_hyst); \
+} while (0)
+
+static ssize_t show_vid(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct asb100_data *data = asb100_update_device(dev);
+	return sprintf(buf, "%d\n", vid_from_reg(data->vid, data->vrm));
+}
+
+static DEVICE_ATTR(cpu0_vid, S_IRUGO, show_vid, NULL);
+#define device_create_file_vid(client) \
+device_create_file(&client->dev, &dev_attr_cpu0_vid)
+
+/* VRM */
+static ssize_t show_vrm(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct asb100_data *data = asb100_update_device(dev);
+	return sprintf(buf, "%d\n", data->vrm);
+}
+
+static ssize_t set_vrm(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct asb100_data *data = i2c_get_clientdata(client);
+	unsigned long val = simple_strtoul(buf, NULL, 10);
+	data->vrm = val;
+	return count;
+}
+
+/* Alarms */
+static DEVICE_ATTR(vrm, S_IRUGO | S_IWUSR, show_vrm, set_vrm);
+#define device_create_file_vrm(client) \
+device_create_file(&client->dev, &dev_attr_vrm);
+
+static ssize_t show_alarms(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct asb100_data *data = asb100_update_device(dev);
+	return sprintf(buf, "%u\n", data->alarms);
+}
+
+static DEVICE_ATTR(alarms, S_IRUGO, show_alarms, NULL);
+#define device_create_file_alarms(client) \
+device_create_file(&client->dev, &dev_attr_alarms)
+
+/* 1 PWM */
+static ssize_t show_pwm1(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct asb100_data *data = asb100_update_device(dev);
+	return sprintf(buf, "%d\n", ASB100_PWM_FROM_REG(data->pwm & 0x0f));
+}
+
+static ssize_t set_pwm1(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct asb100_data *data = i2c_get_clientdata(client);
+	unsigned long val = simple_strtoul(buf, NULL, 10);
+
+	down(&data->update_lock);
+	data->pwm &= 0x80; /* keep the enable bit */
+	data->pwm |= (0x0f & ASB100_PWM_TO_REG(val));
+	asb100_write_value(client, ASB100_REG_PWM1, data->pwm);
+	up(&data->update_lock);
+	return count;
+}
+
+static ssize_t show_pwm_enable1(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct asb100_data *data = asb100_update_device(dev);
+	return sprintf(buf, "%d\n", (data->pwm & 0x80) ? 1 : 0);
+}
+
+static ssize_t set_pwm_enable1(struct device *dev, struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct asb100_data *data = i2c_get_clientdata(client);
+	unsigned long val = simple_strtoul(buf, NULL, 10);
+
+	down(&data->update_lock);
+	data->pwm &= 0x0f; /* keep the duty cycle bits */
+	data->pwm |= (val ? 0x80 : 0x00);
+	asb100_write_value(client, ASB100_REG_PWM1, data->pwm);
+	up(&data->update_lock);
+	return count;
+}
+
+static DEVICE_ATTR(pwm1, S_IRUGO | S_IWUSR, show_pwm1, set_pwm1);
+static DEVICE_ATTR(pwm1_enable, S_IRUGO | S_IWUSR,
+		show_pwm_enable1, set_pwm_enable1);
+#define device_create_file_pwm1(client) do { \
+	device_create_file(&new_client->dev, &dev_attr_pwm1); \
+	device_create_file(&new_client->dev, &dev_attr_pwm1_enable); \
+} while (0)
+
+/* This function is called when:
+	asb100_driver is inserted (when this module is loaded), for each
+		available adapter
+	when a new adapter is inserted (and asb100_driver is still present)
+ */
+static int asb100_attach_adapter(struct i2c_adapter *adapter)
+{
+	if (!(adapter->class & I2C_CLASS_HWMON))
+		return 0;
+	return i2c_detect(adapter, &addr_data, asb100_detect);
+}
+
+static int asb100_detect_subclients(struct i2c_adapter *adapter, int address,
+		int kind, struct i2c_client *new_client)
+{
+	int i, id, err;
+	struct asb100_data *data = i2c_get_clientdata(new_client);
+
+	data->lm75[0] = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (!(data->lm75[0])) {
+		err = -ENOMEM;
+		goto ERROR_SC_0;
+	}
+	memset(data->lm75[0], 0x00, sizeof(struct i2c_client));
+
+	data->lm75[1] = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (!(data->lm75[1])) {
+		err = -ENOMEM;
+		goto ERROR_SC_1;
+	}
+	memset(data->lm75[1], 0x00, sizeof(struct i2c_client));
+
+	id = i2c_adapter_id(adapter);
+
+	if (force_subclients[0] == id && force_subclients[1] == address) {
+		for (i = 2; i <= 3; i++) {
+			if (force_subclients[i] < 0x48 ||
+			    force_subclients[i] > 0x4f) {
+				dev_err(&new_client->dev, "invalid subclient "
+					"address %d; must be 0x48-0x4f\n",
+					force_subclients[i]);
+				err = -ENODEV;
+				goto ERROR_SC_2;
+			}
+		}
+		asb100_write_value(new_client, ASB100_REG_I2C_SUBADDR,
+					(force_subclients[2] & 0x07) |
+					((force_subclients[3] & 0x07) <<4));
+		data->lm75[0]->addr = force_subclients[2];
+		data->lm75[1]->addr = force_subclients[3];
+	} else {
+		int val = asb100_read_value(new_client, ASB100_REG_I2C_SUBADDR);
+		data->lm75[0]->addr = 0x48 + (val & 0x07);
+		data->lm75[1]->addr = 0x48 + ((val >> 4) & 0x07);
+	}
+
+	if(data->lm75[0]->addr == data->lm75[1]->addr) {
+		dev_err(&new_client->dev, "duplicate addresses 0x%x "
+				"for subclients\n", data->lm75[0]->addr);
+		err = -ENODEV;
+		goto ERROR_SC_2;
+	}
+
+	for (i = 0; i <= 1; i++) {
+		i2c_set_clientdata(data->lm75[i], NULL);
+		data->lm75[i]->adapter = adapter;
+		data->lm75[i]->driver = &asb100_driver;
+		data->lm75[i]->flags = 0;
+		strlcpy(data->lm75[i]->name, "asb100 subclient", I2C_NAME_SIZE);
+	}
+
+	if ((err = i2c_attach_client(data->lm75[0]))) {
+		dev_err(&new_client->dev, "subclient %d registration "
+			"at address 0x%x failed.\n", i, data->lm75[0]->addr);
+		goto ERROR_SC_2;
+	}
+
+	if ((err = i2c_attach_client(data->lm75[1]))) {
+		dev_err(&new_client->dev, "subclient %d registration "
+			"at address 0x%x failed.\n", i, data->lm75[1]->addr);
+		goto ERROR_SC_3;
+	}
+
+	return 0;
+
+/* Undo inits in case of errors */
+ERROR_SC_3:
+	i2c_detach_client(data->lm75[0]);
+ERROR_SC_2:
+	kfree(data->lm75[1]);
+ERROR_SC_1:
+	kfree(data->lm75[0]);
+ERROR_SC_0:
+	return err;
+}
+
+static int asb100_detect(struct i2c_adapter *adapter, int address, int kind)
+{
+	int err;
+	struct i2c_client *new_client;
+	struct asb100_data *data;
+
+	/* asb100 is SMBus only */
+	if (i2c_is_isa_adapter(adapter)) {
+		pr_debug("asb100.o: detect failed, "
+				"cannot attach to legacy adapter!\n");
+		err = -ENODEV;
+		goto ERROR0;
+	}
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+		pr_debug("asb100.o: detect failed, "
+				"smbus byte data not supported!\n");
+		err = -ENODEV;
+		goto ERROR0;
+	}
+
+	/* OK. For now, we presume we have a valid client. We now create the
+	   client structure, even though we cannot fill it completely yet.
+	   But it allows us to access asb100_{read,write}_value. */
+
+	if (!(data = kmalloc(sizeof(struct asb100_data), GFP_KERNEL))) {
+		pr_debug("asb100.o: detect failed, kmalloc failed!\n");
+		err = -ENOMEM;
+		goto ERROR0;
+	}
+	memset(data, 0, sizeof(struct asb100_data));
+
+	new_client = &data->client;
+	init_MUTEX(&data->lock);
+	i2c_set_clientdata(new_client, data);
+	new_client->addr = address;
+	new_client->adapter = adapter;
+	new_client->driver = &asb100_driver;
+	new_client->flags = 0;
+
+	/* Now, we do the remaining detection. */
+
+	/* The chip may be stuck in some other bank than bank 0. This may
+	   make reading other information impossible. Specify a force=... or
+	   force_*=... parameter, and the chip will be reset to the right
+	   bank. */
+	if (kind < 0) {
+
+		int val1 = asb100_read_value(new_client, ASB100_REG_BANK);
+		int val2 = asb100_read_value(new_client, ASB100_REG_CHIPMAN);
+
+		/* If we're in bank 0 */
+		if ( (!(val1 & 0x07)) &&
+				/* Check for ASB100 ID (low byte) */
+				( ((!(val1 & 0x80)) && (val2 != 0x94)) ||
+				/* Check for ASB100 ID (high byte ) */
+				((val1 & 0x80) && (val2 != 0x06)) ) ) {
+			pr_debug("asb100.o: detect failed, "
+					"bad chip id 0x%02x!\n", val2);
+			err = -ENODEV;
+			goto ERROR1;
+		}
+
+	} /* kind < 0 */
+
+	/* We have either had a force parameter, or we have already detected
+	   Winbond. Put it now into bank 0 and Vendor ID High Byte */
+	asb100_write_value(new_client, ASB100_REG_BANK,
+		(asb100_read_value(new_client, ASB100_REG_BANK) & 0x78) | 0x80);
+
+	/* Determine the chip type. */
+	if (kind <= 0) {
+		int val1 = asb100_read_value(new_client, ASB100_REG_WCHIPID);
+		int val2 = asb100_read_value(new_client, ASB100_REG_CHIPMAN);
+
+		if ((val1 == 0x31) && (val2 == 0x06))
+			kind = asb100;
+		else {
+			if (kind == 0)
+				dev_warn(&new_client->dev, "ignoring "
+					"'force' parameter for unknown chip "
+					"at adapter %d, address 0x%02x.\n",
+					i2c_adapter_id(adapter), address);
+			err = -ENODEV;
+			goto ERROR1;
+		}
+	}
+
+	/* Fill in remaining client fields and put it into the global list */
+	strlcpy(new_client->name, "asb100", I2C_NAME_SIZE);
+	data->type = kind;
+
+	data->valid = 0;
+	init_MUTEX(&data->update_lock);
+
+	/* Tell the I2C layer a new client has arrived */
+	if ((err = i2c_attach_client(new_client)))
+		goto ERROR1;
+
+	/* Attach secondary lm75 clients */
+	if ((err = asb100_detect_subclients(adapter, address, kind,
+			new_client)))
+		goto ERROR2;
+
+	/* Initialize the chip */
+	asb100_init_client(new_client);
+
+	/* A few vars need to be filled upon startup */
+	data->fan_min[0] = asb100_read_value(new_client, ASB100_REG_FAN_MIN(0));
+	data->fan_min[1] = asb100_read_value(new_client, ASB100_REG_FAN_MIN(1));
+	data->fan_min[2] = asb100_read_value(new_client, ASB100_REG_FAN_MIN(2));
+
+	/* Register sysfs hooks */
+	device_create_file_in(new_client, 0);
+	device_create_file_in(new_client, 1);
+	device_create_file_in(new_client, 2);
+	device_create_file_in(new_client, 3);
+	device_create_file_in(new_client, 4);
+	device_create_file_in(new_client, 5);
+	device_create_file_in(new_client, 6);
+
+	device_create_file_fan(new_client, 1);
+	device_create_file_fan(new_client, 2);
+	device_create_file_fan(new_client, 3);
+
+	device_create_file_temp(new_client, 1);
+	device_create_file_temp(new_client, 2);
+	device_create_file_temp(new_client, 3);
+	device_create_file_temp(new_client, 4);
+
+	device_create_file_vid(new_client);
+	device_create_file_vrm(new_client);
+
+	device_create_file_alarms(new_client);
+
+	device_create_file_pwm1(new_client);
+
+	return 0;
+
+ERROR2:
+	i2c_detach_client(new_client);
+ERROR1:
+	kfree(data);
+ERROR0:
+	return err;
+}
+
+static int asb100_detach_client(struct i2c_client *client)
+{
+	int err;
+
+	if ((err = i2c_detach_client(client))) {
+		dev_err(&client->dev, "client deregistration failed; "
+			"client not detached.\n");
+		return err;
+	}
+
+	if (i2c_get_clientdata(client)==NULL) {
+		/* subclients */
+		kfree(client);
+	} else {
+		/* main client */
+		kfree(i2c_get_clientdata(client));
+	}
+
+	return 0;
+}
+
+/* The SMBus locks itself, usually, but nothing may access the chip between
+   bank switches. */
+static int asb100_read_value(struct i2c_client *client, u16 reg)
+{
+	struct asb100_data *data = i2c_get_clientdata(client);
+	struct i2c_client *cl;
+	int res, bank;
+
+	down(&data->lock);
+
+	bank = (reg >> 8) & 0x0f;
+	if (bank > 2)
+		/* switch banks */
+		i2c_smbus_write_byte_data(client, ASB100_REG_BANK, bank);
+
+	if (bank == 0 || bank > 2) {
+		res = i2c_smbus_read_byte_data(client, reg & 0xff);
+	} else {
+		/* switch to subclient */
+		cl = data->lm75[bank - 1];
+
+		/* convert from ISA to LM75 I2C addresses */
+		switch (reg & 0xff) {
+		case 0x50: /* TEMP */
+			res = swab16(i2c_smbus_read_word_data (cl, 0));
+			break;
+		case 0x52: /* CONFIG */
+			res = i2c_smbus_read_byte_data(cl, 1);
+			break;
+		case 0x53: /* HYST */
+			res = swab16(i2c_smbus_read_word_data (cl, 2));
+			break;
+		case 0x55: /* MAX */
+		default:
+			res = swab16(i2c_smbus_read_word_data (cl, 3));
+			break;
+		}
+	}
+
+	if (bank > 2)
+		i2c_smbus_write_byte_data(client, ASB100_REG_BANK, 0);
+
+	up(&data->lock);
+
+	return res;
+}
+
+static void asb100_write_value(struct i2c_client *client, u16 reg, u16 value)
+{
+	struct asb100_data *data = i2c_get_clientdata(client);
+	struct i2c_client *cl;
+	int bank;
+
+	down(&data->lock);
+
+	bank = (reg >> 8) & 0x0f;
+	if (bank > 2)
+		/* switch banks */
+		i2c_smbus_write_byte_data(client, ASB100_REG_BANK, bank);
+
+	if (bank == 0 || bank > 2) {
+		i2c_smbus_write_byte_data(client, reg & 0xff, value & 0xff);
+	} else {
+		/* switch to subclient */
+		cl = data->lm75[bank - 1];
+
+		/* convert from ISA to LM75 I2C addresses */
+		switch (reg & 0xff) {
+		case 0x52: /* CONFIG */
+			i2c_smbus_write_byte_data(cl, 1, value & 0xff);
+			break;
+		case 0x53: /* HYST */
+			i2c_smbus_write_word_data(cl, 2, swab16(value));
+			break;
+		case 0x55: /* MAX */
+			i2c_smbus_write_word_data(cl, 3, swab16(value));
+			break;
+		}
+	}
+
+	if (bank > 2)
+		i2c_smbus_write_byte_data(client, ASB100_REG_BANK, 0);
+
+	up(&data->lock);
+}
+
+static void asb100_init_client(struct i2c_client *client)
+{
+	struct asb100_data *data = i2c_get_clientdata(client);
+	int vid = 0;
+
+	vid = asb100_read_value(client, ASB100_REG_VID_FANDIV) & 0x0f;
+	vid |= (asb100_read_value(client, ASB100_REG_CHIPID) & 0x01) << 4;
+	data->vrm = i2c_which_vrm();
+	vid = vid_from_reg(vid, data->vrm);
+
+	/* Start monitoring */
+	asb100_write_value(client, ASB100_REG_CONFIG, 
+		(asb100_read_value(client, ASB100_REG_CONFIG) & 0xf7) | 0x01);
+}
+
+static struct asb100_data *asb100_update_device(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct asb100_data *data = i2c_get_clientdata(client);
+	int i;
+
+	down(&data->update_lock);
+
+	if (time_after(jiffies, data->last_updated + HZ + HZ / 2)
+		|| !data->valid) {
+
+		dev_dbg(&client->dev, "starting device update...\n");
+
+		/* 7 voltage inputs */
+		for (i = 0; i < 7; i++) {
+			data->in[i] = asb100_read_value(client,
+				ASB100_REG_IN(i));
+			data->in_min[i] = asb100_read_value(client,
+				ASB100_REG_IN_MIN(i));
+			data->in_max[i] = asb100_read_value(client,
+				ASB100_REG_IN_MAX(i));
+		}
+
+		/* 3 fan inputs */
+		for (i = 0; i < 3; i++) {
+			data->fan[i] = asb100_read_value(client,
+					ASB100_REG_FAN(i));
+			data->fan_min[i] = asb100_read_value(client,
+					ASB100_REG_FAN_MIN(i));
+		}
+
+		/* 4 temperature inputs */
+		for (i = 1; i <= 4; i++) {
+			data->temp[i-1] = asb100_read_value(client,
+					ASB100_REG_TEMP(i));
+			data->temp_max[i-1] = asb100_read_value(client,
+					ASB100_REG_TEMP_MAX(i));
+			data->temp_hyst[i-1] = asb100_read_value(client,
+					ASB100_REG_TEMP_HYST(i));
+		}
+
+		/* VID and fan divisors */
+		i = asb100_read_value(client, ASB100_REG_VID_FANDIV);
+		data->vid = i & 0x0f;
+		data->vid |= (asb100_read_value(client,
+				ASB100_REG_CHIPID) & 0x01) << 4;
+		data->fan_div[0] = (i >> 4) & 0x03;
+		data->fan_div[1] = (i >> 6) & 0x03;
+		data->fan_div[2] = (asb100_read_value(client,
+				ASB100_REG_PIN) >> 6) & 0x03;
+
+		/* PWM */
+		data->pwm = asb100_read_value(client, ASB100_REG_PWM1);
+
+		/* alarms */
+		data->alarms = asb100_read_value(client, ASB100_REG_ALARM1) +
+			(asb100_read_value(client, ASB100_REG_ALARM2) << 8);
+
+		data->last_updated = jiffies;
+		data->valid = 1;
+
+		dev_dbg(&client->dev, "... device update complete\n");
+	}
+
+	up(&data->update_lock);
+
+	return data;
+}
+
+static int __init asb100_init(void)
+{
+	return i2c_add_driver(&asb100_driver);
+}
+
+static void __exit asb100_exit(void)
+{
+	i2c_del_driver(&asb100_driver);
+}
+
+MODULE_AUTHOR("Mark M. Hoffman <mhoffman@lightlink.com>");
+MODULE_DESCRIPTION("ASB100 Bach driver");
+MODULE_LICENSE("GPL");
+
+module_init(asb100_init);
+module_exit(asb100_exit);
+
