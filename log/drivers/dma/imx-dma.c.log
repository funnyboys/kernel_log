commit 7f5d7425748d1cc2dadb6966ec84363d3342b5a1
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Mon Jul 29 17:52:21 2019 -0500

    dmaengine: imx-dma: Mark expected switch fall-through
    
    Mark switch cases where we are expecting to fall through.
    
    This patch fixes the following warning (Building: arm):
    
    drivers/dma/imx-dma.c: In function ‘imxdma_xfer_desc’:
    drivers/dma/imx-dma.c:542:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
       if (slot == IMX_DMA_2D_SLOT_A) {
          ^
    drivers/dma/imx-dma.c:559:2: note: here
      case IMXDMA_DESC_MEMCPY:
      ^~~~
    
    Notice that, in this particular case, the code comment is
    modified in accordance with what GCC is expecting to find.
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Link: https://lore.kernel.org/r/20190729225221.GA24269@embeddedor
    Reviewed-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 00a089e24150..5c0fb3134825 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -556,6 +556,7 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 		 * We fall-through here intentionally, since a 2D transfer is
 		 * similar to MEMCPY just adding the 2D slot configuration.
 		 */
+		/* Fall through */
 	case IMXDMA_DESC_MEMCPY:
 		imx_dmav1_writel(imxdma, d->src, DMA_SAR(imxdmac->channel));
 		imx_dmav1_writel(imxdma, d->dest, DMA_DAR(imxdmac->channel));

commit 31ef489a026ef2c07383ef336dc9b6601c7b9b93
Merge: 2f194646feca feb59d77a46d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 14 09:11:54 2019 -0700

    Merge tag 'dmaengine-5.1-rc1' of git://git.infradead.org/users/vkoul/slave-dma
    
    Pull dmaengine updates from Vinod Koul:
    
     - dmatest updates for modularizing common struct and code
    
     - remove SG support for VDMA xilinx IP and updates to driver
    
     - Update to dw driver to support Intel iDMA controllers multi-block
       support
    
     - tegra updates for proper reporting of residue
    
     - Add Snow Ridge ioatdma device id and support for IOATDMA v3.4
    
     - struct_size() usage and useless LIST_HEAD cleanups in subsystem.
    
     - qDMA controller driver for Layerscape SoCs
    
     - stm32-dma PM Runtime support
    
     - And usual updates to imx-sdma, sprd, Documentation, fsl-edma,
       bcm2835, qcom_hidma etc
    
    * tag 'dmaengine-5.1-rc1' of git://git.infradead.org/users/vkoul/slave-dma: (81 commits)
      dmaengine: imx-sdma: fix consistent dma test failures
      dmaengine: imx-sdma: add a test for imx8mq multi sdma devices
      dmaengine: imx-sdma: add clock ratio 1:1 check
      dmaengine: dmatest: move test data alloc & free into functions
      dmaengine: dmatest: add short-hand `buf_size` var in dmatest_func()
      dmaengine: dmatest: wrap src & dst data into a struct
      dmaengine: ioatdma: support latency tolerance report (LTR) for v3.4
      dmaengine: ioatdma: add descriptor pre-fetch support for v3.4
      dmaengine: ioatdma: disable DCA enabling on IOATDMA v3.4
      dmaengine: ioatdma: Add Snow Ridge ioatdma device id
      dmaengine: sprd: Change channel id to slave id for DMA cell specifier
      dt-bindings: dmaengine: sprd: Change channel id to slave id for DMA cell specifier
      dmaengine: mv_xor: Use correct device for DMA API
      Documentation :dmaengine: clarify DMA desc. pointer after submission
      Documentation: dmaengine: fix dmatest.rst warning
      dmaengine: k3dma: Add support for dma-channel-mask
      dmaengine: k3dma: Delete axi_config
      dmaengine: k3dma: Upgrade k3dma driver to support hisi_asp_dma hardware
      Documentation: bindings: dma: Add binding for dma-channel-mask
      Documentation: bindings: k3dma: Extend the k3dma driver binding to support hisi-asp
      ...

commit 341198eda723c8c1cddbb006a89ad9e362502ea2
Author: Leonid Iziumtsev <leonid.iziumtsev@gmail.com>
Date:   Tue Jan 15 17:15:23 2019 +0000

    dmaengine: imx-dma: fix wrong callback invoke
    
    Once the "ld_queue" list is not empty, next descriptor will migrate
    into "ld_active" list. The "desc" variable will be overwritten
    during that transition. And later the dmaengine_desc_get_callback_invoke()
    will use it as an argument. As result we invoke wrong callback.
    
    That behaviour was in place since:
    commit fcaaba6c7136 ("dmaengine: imx-dma: fix callback path in tasklet").
    But after commit 4cd13c21b207 ("softirq: Let ksoftirqd do its job")
    things got worse, since possible delay between tasklet_schedule()
    from DMA irq handler and actual tasklet function execution got bigger.
    And that gave more time for new DMA request to be submitted and
    to be put into "ld_queue" list.
    
    It has been noticed that DMA issue is causing problems for "mxc-mmc"
    driver. While stressing the system with heavy network traffic and
    writing/reading to/from sd card simultaneously the timeout may happen:
    
    10013000.sdhci: mxcmci_watchdog: read time out (status = 0x30004900)
    
    That often lead to file system corruption.
    
    Signed-off-by: Leonid Iziumtsev <leonid.iziumtsev@gmail.com>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Cc: stable@vger.kernel.org

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index c2fff3f6c9ca..4a09af3cd546 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -618,7 +618,7 @@ static void imxdma_tasklet(unsigned long data)
 {
 	struct imxdma_channel *imxdmac = (void *)data;
 	struct imxdma_engine *imxdma = imxdmac->imxdma;
-	struct imxdma_desc *desc;
+	struct imxdma_desc *desc, *next_desc;
 	unsigned long flags;
 
 	spin_lock_irqsave(&imxdma->lock, flags);
@@ -648,10 +648,10 @@ static void imxdma_tasklet(unsigned long data)
 	list_move_tail(imxdmac->ld_active.next, &imxdmac->ld_free);
 
 	if (!list_empty(&imxdmac->ld_queue)) {
-		desc = list_first_entry(&imxdmac->ld_queue, struct imxdma_desc,
-					node);
+		next_desc = list_first_entry(&imxdmac->ld_queue,
+					     struct imxdma_desc, node);
 		list_move_tail(imxdmac->ld_queue.next, &imxdmac->ld_active);
-		if (imxdma_xfer_desc(desc) < 0)
+		if (imxdma_xfer_desc(next_desc) < 0)
 			dev_warn(imxdma->dev, "%s: channel: %d couldn't xfer desc\n",
 				 __func__, imxdmac->channel);
 	}

commit 452fd6dc86209c23501c82183c1fbbbfa42c0a7a
Author: Vinod Koul <vkoul@kernel.org>
Date:   Sun Jan 20 11:42:44 2019 +0530

    dmaengine: imx-dma: change return of 'imxdma_sg_next' to void
    
    The return value of function 'imxdma_sg_next' is not checked anywhere,
    so make it void return type.
    
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index aba1380c3321..5a923490dc8b 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -278,7 +278,7 @@ static int imxdma_hw_chain(struct imxdma_channel *imxdmac)
 /*
  * imxdma_sg_next - prepare next chunk for scatter-gather DMA emulation
  */
-static inline int imxdma_sg_next(struct imxdma_desc *d)
+static inline void imxdma_sg_next(struct imxdma_desc *d)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);
 	struct imxdma_engine *imxdma = imxdmac->imxdma;
@@ -303,8 +303,6 @@ static inline int imxdma_sg_next(struct imxdma_desc *d)
 		 imx_dmav1_readl(imxdma, DMA_DAR(imxdmac->channel)),
 		 imx_dmav1_readl(imxdma, DMA_SAR(imxdmac->channel)),
 		 imx_dmav1_readl(imxdma, DMA_CNTR(imxdmac->channel)));
-
-	return now;
 }
 
 static void imxdma_enable_hw(struct imxdma_desc *d)

commit da5035f3773632a7b11a2dc8ca15291b8e2817df
Author: Vinod Koul <vkoul@kernel.org>
Date:   Sun Jan 20 11:42:44 2019 +0530

    dmaengine: imx-dma: change variable 'now' type to size_t
    
    now is used to keep size and it is better to change the variable
    type to size_t
    
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index fa3ef43fe314..aba1380c3321 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -283,7 +283,7 @@ static inline int imxdma_sg_next(struct imxdma_desc *d)
 	struct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);
 	struct imxdma_engine *imxdma = imxdmac->imxdma;
 	struct scatterlist *sg = d->sg;
-	unsigned long now;
+	size_t now;
 
 	now = min_t(size_t, d->len, sg_dma_len(sg));
 	if (d->len != IMX_DMA_LENGTH_LOOP)

commit 9227ab5643cb8350449502dd9e3168a873ab0e3b
Author: Anders Roxell <anders.roxell@linaro.org>
Date:   Thu Jan 10 12:15:35 2019 +0100

    dmaengine: imx-dma: fix warning comparison of distinct pointer types
    
    The warning got introduced by commit 930507c18304 ("arm64: add basic
    Kconfig symbols for i.MX8"). Since it got enabled for arm64. The warning
    haven't been seen before since size_t was 'unsigned int' when built on
    arm32.
    
    ../drivers/dma/imx-dma.c: In function ‘imxdma_sg_next’:
    ../include/linux/kernel.h:846:29: warning: comparison of distinct pointer types lacks a cast
       (!!(sizeof((typeof(x) *)1 == (typeof(y) *)1)))
                                 ^~
    ../include/linux/kernel.h:860:4: note: in expansion of macro ‘__typecheck’
       (__typecheck(x, y) && __no_side_effects(x, y))
        ^~~~~~~~~~~
    ../include/linux/kernel.h:870:24: note: in expansion of macro ‘__safe_cmp’
      __builtin_choose_expr(__safe_cmp(x, y), \
                            ^~~~~~~~~~
    ../include/linux/kernel.h:879:19: note: in expansion of macro ‘__careful_cmp’
     #define min(x, y) __careful_cmp(x, y, <)
                       ^~~~~~~~~~~~~
    ../drivers/dma/imx-dma.c:288:8: note: in expansion of macro ‘min’
      now = min(d->len, sg_dma_len(sg));
            ^~~
    
    Rework so that we use min_t and pass in the size_t that returns the
    minimum of two values, using the specified type.
    
    Signed-off-by: Anders Roxell <anders.roxell@linaro.org>
    Acked-by: Olof Johansson <olof@lixom.net>
    Reviewed-by: Fabio Estevam <festevam@gmail.com>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index c2fff3f6c9ca..fa3ef43fe314 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -285,7 +285,7 @@ static inline int imxdma_sg_next(struct imxdma_desc *d)
 	struct scatterlist *sg = d->sg;
 	unsigned long now;
 
-	now = min(d->len, sg_dma_len(sg));
+	now = min_t(size_t, d->len, sg_dma_len(sg));
 	if (d->len != IMX_DMA_LENGTH_LOOP)
 		d->len -= now;
 

commit dea7a9fbb009ba0629c44fcf105f2d8b0ff74e9f
Author: Vinod Koul <vkoul@kernel.org>
Date:   Thu Jul 19 22:22:26 2018 +0530

    dmaengine: imx-dma: remove dma_slave_config direction usage
    
    dma_slave_config direction was marked as deprecated quite some
    time back, remove the usage from this driver so that the field
    can be removed
    
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 75b6ff0415ee..c2fff3f6c9ca 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -162,6 +162,7 @@ struct imxdma_channel {
 	bool				enabled_2d;
 	int				slot_2d;
 	unsigned int			irq;
+	struct dma_slave_config		config;
 };
 
 enum imx_dma_type {
@@ -675,14 +676,15 @@ static int imxdma_terminate_all(struct dma_chan *chan)
 	return 0;
 }
 
-static int imxdma_config(struct dma_chan *chan,
-			 struct dma_slave_config *dmaengine_cfg)
+static int imxdma_config_write(struct dma_chan *chan,
+			       struct dma_slave_config *dmaengine_cfg,
+			       enum dma_transfer_direction direction)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
 	struct imxdma_engine *imxdma = imxdmac->imxdma;
 	unsigned int mode = 0;
 
-	if (dmaengine_cfg->direction == DMA_DEV_TO_MEM) {
+	if (direction == DMA_DEV_TO_MEM) {
 		imxdmac->per_address = dmaengine_cfg->src_addr;
 		imxdmac->watermark_level = dmaengine_cfg->src_maxburst;
 		imxdmac->word_size = dmaengine_cfg->src_addr_width;
@@ -723,6 +725,16 @@ static int imxdma_config(struct dma_chan *chan,
 	return 0;
 }
 
+static int imxdma_config(struct dma_chan *chan,
+			 struct dma_slave_config *dmaengine_cfg)
+{
+	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
+
+	memcpy(&imxdmac->config, dmaengine_cfg, sizeof(*dmaengine_cfg));
+
+	return 0;
+}
+
 static enum dma_status imxdma_tx_status(struct dma_chan *chan,
 					    dma_cookie_t cookie,
 					    struct dma_tx_state *txstate)
@@ -905,6 +917,8 @@ static struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(
 	desc->desc.callback = NULL;
 	desc->desc.callback_param = NULL;
 
+	imxdma_config_write(chan, &imxdmac->config, direction);
+
 	return &desc->desc;
 }
 

commit ce9c28ca6c6f572c0bb6e7936e8f42cd1595b820
Author: Fabio Estevam <fabio.estevam@nxp.com>
Date:   Mon May 21 23:53:32 2018 -0300

    dmaengine: imx-dma: Switch to SPDX identifier
    
    Adopt the SPDX license identifier headers to ease license compliance
    management.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@nxp.com>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 715b39ae5a46..75b6ff0415ee 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -1,19 +1,13 @@
-/*
- * drivers/dma/imx-dma.c
- *
- * This file contains a driver for the Freescale i.MX DMA engine
- * found on i.MX1/21/27
- *
- * Copyright 2010 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
- * Copyright 2012 Javier Martin, Vista Silicon <javier.martin@vista-silicon.com>
- *
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
+// SPDX-License-Identifier: GPL-2.0+
+//
+// drivers/dma/imx-dma.c
+//
+// This file contains a driver for the Freescale i.MX DMA engine
+// found on i.MX1/21/27
+//
+// Copyright 2010 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
+// Copyright 2012 Javier Martin, Vista Silicon <javier.martin@vista-silicon.com>
+
 #include <linux/err.h>
 #include <linux/init.h>
 #include <linux/types.h>

commit ff5fdafc9e9702846480e0cea55ba861f72140a2
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Fri Jan 19 18:17:46 2018 +0100

    ARM: 8745/1: get rid of __memzero()
    
    The __memzero assembly code is almost identical to memset's except for
    two orr instructions. The runtime performance of __memset(p, n) and
    memset(p, 0, n) is accordingly almost identical.
    
    However, the memset() macro used to guard against a zero length and to
    call __memzero at compile time when the fill value is a constant zero
    interferes with compiler optimizations.
    
    Arnd found tha the test against a zero length brings up some new
    warnings with gcc v8:
    
      https://gcc.gnu.org/bugzilla/show_bug.cgi?id=82103
    
    And successively rremoving the test against a zero length and the call
    to __memzero optimization produces the following kernel sizes for
    defconfig with gcc 6:
    
        text     data     bss       dec       hex  filename
    12248142  6278960  413588  18940690   1210312  vmlinux.orig
    12244474  6278960  413588  18937022   120f4be  vmlinux.no_zero_test
    12239160  6278960  413588  18931708   120dffc  vmlinux.no_memzero
    
    So it is probably not worth keeping __memzero around given that the
    compiler can do a better job at inlining trivial memset(p,0,n) on its
    own. And the memset code already handles a zero length just fine.
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 331f863c605e..715b39ae5a46 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -765,7 +765,7 @@ static int imxdma_alloc_chan_resources(struct dma_chan *chan)
 		desc = kzalloc(sizeof(*desc), GFP_KERNEL);
 		if (!desc)
 			break;
-		__memzero(&desc->desc, sizeof(struct dma_async_tx_descriptor));
+		memset(&desc->desc, 0, sizeof(struct dma_async_tx_descriptor));
 		dma_async_tx_descriptor_init(&desc->desc, chan);
 		desc->desc.tx_submit = imxdma_tx_submit;
 		/* txd.flags will be overwritten in prep funcs */

commit bcdc4bd356c76a5bab2f480a73f089dc8e0e4e89
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 24 03:02:23 2017 -0700

    dmaengine: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index f681df8f0ed3..331f863c605e 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -364,9 +364,9 @@ static void imxdma_disable_hw(struct imxdma_channel *imxdmac)
 	local_irq_restore(flags);
 }
 
-static void imxdma_watchdog(unsigned long data)
+static void imxdma_watchdog(struct timer_list *t)
 {
-	struct imxdma_channel *imxdmac = (struct imxdma_channel *)data;
+	struct imxdma_channel *imxdmac = from_timer(imxdmac, t, watchdog);
 	struct imxdma_engine *imxdma = imxdmac->imxdma;
 	int channel = imxdmac->channel;
 
@@ -1153,9 +1153,7 @@ static int __init imxdma_probe(struct platform_device *pdev)
 			}
 
 			imxdmac->irq = irq + i;
-			init_timer(&imxdmac->watchdog);
-			imxdmac->watchdog.function = &imxdma_watchdog;
-			imxdmac->watchdog.data = (unsigned long)imxdmac;
+			timer_setup(&imxdmac->watchdog, imxdma_watchdog, 0);
 		}
 
 		imxdmac->imxdma = imxdma;

commit ce81801372313805aa649ea18d27b2fb5f6c16b5
Author: Logan Gunthorpe <logang@deltatee.com>
Date:   Tue May 30 16:39:16 2017 -0600

    dmaengine: imx-dma: cleanup scatterlist layering violations
    
    This dma engine driver directly accesses page_link assuming knowledge
    that should be contained only in scatterlist.h.
    
    We replace these with calls to sg_chain and sg_assign_page.
    
    Signed-off-by: Logan Gunthorpe <logang@deltatee.com>
    Signed-off-by: Stephen Bates <sbates@raithlin.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: Vinod Koul <vinod.koul@intel.com>
    Cc: Per Förlin <per.forlin@axis.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index ab0fb804fb1e..f681df8f0ed3 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -888,7 +888,7 @@ static struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(
 	sg_init_table(imxdmac->sg_list, periods);
 
 	for (i = 0; i < periods; i++) {
-		imxdmac->sg_list[i].page_link = 0;
+		sg_assign_page(&imxdmac->sg_list[i], NULL);
 		imxdmac->sg_list[i].offset = 0;
 		imxdmac->sg_list[i].dma_address = dma_addr;
 		sg_dma_len(&imxdmac->sg_list[i]) = period_len;
@@ -896,10 +896,7 @@ static struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(
 	}
 
 	/* close the loop */
-	imxdmac->sg_list[periods].offset = 0;
-	sg_dma_len(&imxdmac->sg_list[periods]) = 0;
-	imxdmac->sg_list[periods].page_link =
-		((unsigned long)imxdmac->sg_list | 0x01) & ~0x02;
+	sg_chain(imxdmac->sg_list, periods + 1, imxdmac->sg_list);
 
 	desc->type = IMXDMA_DESC_CYCLIC;
 	desc->sg = imxdmac->sg_list;

commit be5af2855af50edb7e81a99bc3e8c725839c6eff
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed Jul 20 13:11:22 2016 -0700

    dmaengine: imx-dma: convert callback to helper function
    
    This is in preperation of moving to a callback that provides results to the
    callback for the transaction. The conversion will maintain current behavior
    and the driver must convert to new callback mechanism at a later time in
    order to receive results.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index a960608c0a4d..ab0fb804fb1e 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -663,9 +663,7 @@ static void imxdma_tasklet(unsigned long data)
 out:
 	spin_unlock_irqrestore(&imxdma->lock, flags);
 
-	if (desc->desc.callback)
-		desc->desc.callback(desc->desc.callback_param);
-
+	dmaengine_desc_get_callback_invoke(&desc->desc, NULL);
 }
 
 static int imxdma_terminate_all(struct dma_chan *chan)

commit 71c6b663492c5da78c94d3405c0e8044b8290d00
Author: Vinod Koul <vinod.koul@intel.com>
Date:   Sat Jul 2 15:35:07 2016 +0530

    dmaengine: imx-dma: fix coding style issue
    
    imxdma_probe function starting brace is wrongly indented, so fix that
    
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 9301d3d09563..a960608c0a4d 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -1052,7 +1052,7 @@ static struct dma_chan *imxdma_xlate(struct of_phandle_args *dma_spec,
 }
 
 static int __init imxdma_probe(struct platform_device *pdev)
-	{
+{
 	struct imxdma_engine *imxdma;
 	struct resource *res;
 	const struct of_device_id *of_id;

commit ea62aa80bbcc881d0805cbee9afd74e3d029e48e
Author: Vinod Koul <vinod.koul@intel.com>
Date:   Sat Jul 2 15:25:01 2016 +0530

    dmaengine: imx-dma: explicitly freeup irq
    
    dmaengine device should explicitly call devm_free_irq() when using
    devm_request_irq().
    
    The irq is still ON when devices remove is executed and irq should be
    quiesced before remove is completed.
    
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 48d85f8b95fe..9301d3d09563 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -167,6 +167,7 @@ struct imxdma_channel {
 	u32				ccr_to_device;
 	bool				enabled_2d;
 	int				slot_2d;
+	unsigned int			irq;
 };
 
 enum imx_dma_type {
@@ -186,6 +187,9 @@ struct imxdma_engine {
 	struct imx_dma_2d_config	slots_2d[IMX_DMA_2D_SLOTS];
 	struct imxdma_channel		channel[IMX_DMA_CHANNELS];
 	enum imx_dma_type		devtype;
+	unsigned int			irq;
+	unsigned int			irq_err;
+
 };
 
 struct imxdma_filter_data {
@@ -1100,6 +1104,7 @@ static int __init imxdma_probe(struct platform_device *pdev)
 			dev_warn(imxdma->dev, "Can't register IRQ for DMA\n");
 			goto disable_dma_ahb_clk;
 		}
+		imxdma->irq = irq;
 
 		irq_err = platform_get_irq(pdev, 1);
 		if (irq_err < 0) {
@@ -1113,6 +1118,7 @@ static int __init imxdma_probe(struct platform_device *pdev)
 			dev_warn(imxdma->dev, "Can't register ERRIRQ for DMA\n");
 			goto disable_dma_ahb_clk;
 		}
+		imxdma->irq_err = irq_err;
 	}
 
 	/* enable DMA module */
@@ -1150,6 +1156,8 @@ static int __init imxdma_probe(struct platform_device *pdev)
 					 irq + i, i);
 				goto disable_dma_ahb_clk;
 			}
+
+			imxdmac->irq = irq + i;
 			init_timer(&imxdmac->watchdog);
 			imxdmac->watchdog.function = &imxdma_watchdog;
 			imxdmac->watchdog.data = (unsigned long)imxdmac;
@@ -1217,10 +1225,31 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	return ret;
 }
 
+static void imxdma_free_irq(struct platform_device *pdev, struct imxdma_engine *imxdma)
+{
+	int i;
+
+	if (is_imx1_dma(imxdma)) {
+		disable_irq(imxdma->irq);
+		disable_irq(imxdma->irq_err);
+	}
+
+	for (i = 0; i < IMX_DMA_CHANNELS; i++) {
+		struct imxdma_channel *imxdmac = &imxdma->channel[i];
+
+		if (!is_imx1_dma(imxdma))
+			disable_irq(imxdmac->irq);
+
+		tasklet_kill(&imxdmac->dma_tasklet);
+	}
+}
+
 static int imxdma_remove(struct platform_device *pdev)
 {
 	struct imxdma_engine *imxdma = platform_get_drvdata(pdev);
 
+	imxdma_free_irq(pdev, imxdma);
+
         dma_async_device_unregister(&imxdma->dma_device);
 
 	if (pdev->dev.of_node)

commit 77a68e56aae141d3e9c740a0ac43362af75d4890
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Mon Jul 20 10:41:32 2015 +0200

    dmaengine: Add an enum for the dmaengine alignment constraints
    
    Most drivers need to set constraints on the buffer alignment for async tx
    operations. However, even though it is documented, some drivers either use
    a defined constant that is not matching what the alignment variable expects
    (like DMA_BUSWIDTH_* constants) or fill the alignment in bytes instead of
    power of two.
    
    Add a new enum for these alignments that matches what the framework
    expects, and convert the drivers to it.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 139c5676cd74..48d85f8b95fe 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -1187,7 +1187,7 @@ static int __init imxdma_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, imxdma);
 
-	imxdma->dma_device.copy_align = 2; /* 2^2 = 4 bytes alignment */
+	imxdma->dma_device.copy_align = DMAENGINE_ALIGN_4_BYTES;
 	imxdma->dma_device.dev->dma_parms = &imxdma->dma_parms;
 	dma_set_max_seg_size(imxdma->dma_device.dev, 0xffffff);
 

commit fce9a74ba46fb545ad81cf244f3a1af4a877606c
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Sat Jun 20 18:43:44 2015 -0300

    dmaengine: imx-dma: Check for clk_prepare_enable() error
    
    clk_prepare_enable() may fail, so we should better check its return value
    and propagate it in the case of error.
    
    While at it, change the label 'err' to a more descriptive naming.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 865501fcc67d..139c5676cd74 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -1083,8 +1083,12 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	if (IS_ERR(imxdma->dma_ahb))
 		return PTR_ERR(imxdma->dma_ahb);
 
-	clk_prepare_enable(imxdma->dma_ipg);
-	clk_prepare_enable(imxdma->dma_ahb);
+	ret = clk_prepare_enable(imxdma->dma_ipg);
+	if (ret)
+		return ret;
+	ret = clk_prepare_enable(imxdma->dma_ahb);
+	if (ret)
+		goto disable_dma_ipg_clk;
 
 	/* reset DMA module */
 	imx_dmav1_writel(imxdma, DCR_DRST, DMA_DCR);
@@ -1094,20 +1098,20 @@ static int __init imxdma_probe(struct platform_device *pdev)
 				       dma_irq_handler, 0, "DMA", imxdma);
 		if (ret) {
 			dev_warn(imxdma->dev, "Can't register IRQ for DMA\n");
-			goto err;
+			goto disable_dma_ahb_clk;
 		}
 
 		irq_err = platform_get_irq(pdev, 1);
 		if (irq_err < 0) {
 			ret = irq_err;
-			goto err;
+			goto disable_dma_ahb_clk;
 		}
 
 		ret = devm_request_irq(&pdev->dev, irq_err,
 				       imxdma_err_handler, 0, "DMA", imxdma);
 		if (ret) {
 			dev_warn(imxdma->dev, "Can't register ERRIRQ for DMA\n");
-			goto err;
+			goto disable_dma_ahb_clk;
 		}
 	}
 
@@ -1144,7 +1148,7 @@ static int __init imxdma_probe(struct platform_device *pdev)
 				dev_warn(imxdma->dev, "Can't register IRQ %d "
 					 "for DMA channel %d\n",
 					 irq + i, i);
-				goto err;
+				goto disable_dma_ahb_clk;
 			}
 			init_timer(&imxdmac->watchdog);
 			imxdmac->watchdog.function = &imxdma_watchdog;
@@ -1190,7 +1194,7 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	ret = dma_async_device_register(&imxdma->dma_device);
 	if (ret) {
 		dev_err(&pdev->dev, "unable to register\n");
-		goto err;
+		goto disable_dma_ahb_clk;
 	}
 
 	if (pdev->dev.of_node) {
@@ -1206,9 +1210,10 @@ static int __init imxdma_probe(struct platform_device *pdev)
 
 err_of_dma_controller:
 	dma_async_device_unregister(&imxdma->dma_device);
-err:
-	clk_disable_unprepare(imxdma->dma_ipg);
+disable_dma_ahb_clk:
 	clk_disable_unprepare(imxdma->dma_ahb);
+disable_dma_ipg_clk:
+	clk_disable_unprepare(imxdma->dma_ipg);
 	return ret;
 }
 

commit afe7cded998fff62759c214cda8785cd874b6114
Author: Krzysztof Kozlowski <k.kozlowski.k@gmail.com>
Date:   Sat May 2 00:57:46 2015 +0900

    dmaengine: imx: Constify platform_device_id
    
    The platform_device_id is not modified by the driver and core uses it as
    const.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski.k@gmail.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index eed405976ea9..865501fcc67d 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -193,7 +193,7 @@ struct imxdma_filter_data {
 	int			 request;
 };
 
-static struct platform_device_id imx_dma_devtype[] = {
+static const struct platform_device_id imx_dma_devtype[] = {
 	{
 		.name = "imx1-dma",
 		.driver_data = IMX1_DMA,

commit 2cd6f7928ca42c7744f493e0ae2a4acaf02331a0
Merge: c914570f2855 5cf5aec5b38a
Author: Vinod Koul <vinod.koul@intel.com>
Date:   Mon Feb 2 16:55:35 2015 -0800

    Merge branch 'topic/slave_caps_device_control_fix_rebased' into for-linus

commit 9265eaed9ca8bc0c24d90f9bd18b15d33465dca5
Author: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
Date:   Sun Dec 21 18:18:22 2014 +0100

    dmaengine: imx-dma.c: Remove unused function
    
    Remove the function is_imx21_dma() that is not used anywhere.
    
    This was partially found by using a static code analysis program called cppcheck.
    
    Signed-off-by: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 10bbc0a675b0..0c4d35da1502 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -230,11 +230,6 @@ static inline int is_imx1_dma(struct imxdma_engine *imxdma)
 	return imxdma->devtype == IMX1_DMA;
 }
 
-static inline int is_imx21_dma(struct imxdma_engine *imxdma)
-{
-	return imxdma->devtype == IMX21_DMA;
-}
-
 static inline int is_imx27_dma(struct imxdma_engine *imxdma)
 {
 	return imxdma->devtype == IMX27_DMA;

commit 502c2ef26dba04128af260de0ca3e2940e57fc7a
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Mon Nov 17 14:42:16 2014 +0100

    dmaengine: imx: Split device_control
    
    Split the device_control callback of the Freescale IMX DMA driver to make use
    of the newly introduced callbacks, that will eventually be used to retrieve
    slave capabilities.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 10bbc0a675b0..02d1f73bd12b 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -669,69 +669,67 @@ static void imxdma_tasklet(unsigned long data)
 
 }
 
-static int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
-		unsigned long arg)
+static int imxdma_terminate_all(struct dma_chan *chan)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
-	struct dma_slave_config *dmaengine_cfg = (void *)arg;
 	struct imxdma_engine *imxdma = imxdmac->imxdma;
 	unsigned long flags;
-	unsigned int mode = 0;
-
-	switch (cmd) {
-	case DMA_TERMINATE_ALL:
-		imxdma_disable_hw(imxdmac);
 
-		spin_lock_irqsave(&imxdma->lock, flags);
-		list_splice_tail_init(&imxdmac->ld_active, &imxdmac->ld_free);
-		list_splice_tail_init(&imxdmac->ld_queue, &imxdmac->ld_free);
-		spin_unlock_irqrestore(&imxdma->lock, flags);
-		return 0;
-	case DMA_SLAVE_CONFIG:
-		if (dmaengine_cfg->direction == DMA_DEV_TO_MEM) {
-			imxdmac->per_address = dmaengine_cfg->src_addr;
-			imxdmac->watermark_level = dmaengine_cfg->src_maxburst;
-			imxdmac->word_size = dmaengine_cfg->src_addr_width;
-		} else {
-			imxdmac->per_address = dmaengine_cfg->dst_addr;
-			imxdmac->watermark_level = dmaengine_cfg->dst_maxburst;
-			imxdmac->word_size = dmaengine_cfg->dst_addr_width;
-		}
-
-		switch (imxdmac->word_size) {
-		case DMA_SLAVE_BUSWIDTH_1_BYTE:
-			mode = IMX_DMA_MEMSIZE_8;
-			break;
-		case DMA_SLAVE_BUSWIDTH_2_BYTES:
-			mode = IMX_DMA_MEMSIZE_16;
-			break;
-		default:
-		case DMA_SLAVE_BUSWIDTH_4_BYTES:
-			mode = IMX_DMA_MEMSIZE_32;
-			break;
-		}
+	imxdma_disable_hw(imxdmac);
 
-		imxdmac->hw_chaining = 0;
+	spin_lock_irqsave(&imxdma->lock, flags);
+	list_splice_tail_init(&imxdmac->ld_active, &imxdmac->ld_free);
+	list_splice_tail_init(&imxdmac->ld_queue, &imxdmac->ld_free);
+	spin_unlock_irqrestore(&imxdma->lock, flags);
+	return 0;
+}
 
-		imxdmac->ccr_from_device = (mode | IMX_DMA_TYPE_FIFO) |
-			((IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR) << 2) |
-			CCR_REN;
-		imxdmac->ccr_to_device =
-			(IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR) |
-			((mode | IMX_DMA_TYPE_FIFO) << 2) | CCR_REN;
-		imx_dmav1_writel(imxdma, imxdmac->dma_request,
-				 DMA_RSSR(imxdmac->channel));
+static int imxdma_config(struct dma_chan *chan,
+			 struct dma_slave_config *dmaengine_cfg)
+{
+	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
+	struct imxdma_engine *imxdma = imxdmac->imxdma;
+	unsigned int mode = 0;
 
-		/* Set burst length */
-		imx_dmav1_writel(imxdma, imxdmac->watermark_level *
-				imxdmac->word_size, DMA_BLR(imxdmac->channel));
+	if (dmaengine_cfg->direction == DMA_DEV_TO_MEM) {
+		imxdmac->per_address = dmaengine_cfg->src_addr;
+		imxdmac->watermark_level = dmaengine_cfg->src_maxburst;
+		imxdmac->word_size = dmaengine_cfg->src_addr_width;
+	} else {
+		imxdmac->per_address = dmaengine_cfg->dst_addr;
+		imxdmac->watermark_level = dmaengine_cfg->dst_maxburst;
+		imxdmac->word_size = dmaengine_cfg->dst_addr_width;
+	}
 
-		return 0;
+	switch (imxdmac->word_size) {
+	case DMA_SLAVE_BUSWIDTH_1_BYTE:
+		mode = IMX_DMA_MEMSIZE_8;
+		break;
+	case DMA_SLAVE_BUSWIDTH_2_BYTES:
+		mode = IMX_DMA_MEMSIZE_16;
+		break;
 	default:
-		return -ENOSYS;
+	case DMA_SLAVE_BUSWIDTH_4_BYTES:
+		mode = IMX_DMA_MEMSIZE_32;
+		break;
 	}
 
-	return -EINVAL;
+	imxdmac->hw_chaining = 0;
+
+	imxdmac->ccr_from_device = (mode | IMX_DMA_TYPE_FIFO) |
+		((IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR) << 2) |
+		CCR_REN;
+	imxdmac->ccr_to_device =
+		(IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR) |
+		((mode | IMX_DMA_TYPE_FIFO) << 2) | CCR_REN;
+	imx_dmav1_writel(imxdma, imxdmac->dma_request,
+			 DMA_RSSR(imxdmac->channel));
+
+	/* Set burst length */
+	imx_dmav1_writel(imxdma, imxdmac->watermark_level *
+			 imxdmac->word_size, DMA_BLR(imxdmac->channel));
+
+	return 0;
 }
 
 static enum dma_status imxdma_tx_status(struct dma_chan *chan,
@@ -1184,7 +1182,8 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	imxdma->dma_device.device_prep_dma_cyclic = imxdma_prep_dma_cyclic;
 	imxdma->dma_device.device_prep_dma_memcpy = imxdma_prep_dma_memcpy;
 	imxdma->dma_device.device_prep_interleaved_dma = imxdma_prep_dma_interleaved;
-	imxdma->dma_device.device_control = imxdma_control;
+	imxdma->dma_device.device_config = imxdma_config;
+	imxdma->dma_device.device_terminate_all = imxdma_terminate_all;
 	imxdma->dma_device.device_issue_pending = imxdma_issue_pending;
 
 	platform_set_drvdata(pdev, imxdma);

commit 55f04d7f59ddd48422cccba2cb1329d62401b2df
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:28 2014 +0200

    dma: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 9d2c9e7374dc..10bbc0a675b0 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -1236,7 +1236,6 @@ static int imxdma_remove(struct platform_device *pdev)
 static struct platform_driver imxdma_driver = {
 	.driver		= {
 		.name	= "imx-dma",
-		.owner	= THIS_MODULE,
 		.of_match_table = imx_dma_of_dev_id,
 	},
 	.id_table	= imx_dma_devtype,

commit 31c1e5a1350ae8d1bc2018f5de8264266d9773e1
Author: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date:   Fri Aug 1 12:20:10 2014 +0200

    dmaengine: Remove the context argument to the prep_dma_cyclic operation
    
    The argument is always set to NULL and never used. Remove it.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 286660a12cc6..9d2c9e7374dc 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -866,7 +866,7 @@ static struct dma_async_tx_descriptor *imxdma_prep_slave_sg(
 static struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(
 		struct dma_chan *chan, dma_addr_t dma_addr, size_t buf_len,
 		size_t period_len, enum dma_transfer_direction direction,
-		unsigned long flags, void *context)
+		unsigned long flags)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
 	struct imxdma_engine *imxdma = imxdmac->imxdma;

commit 4de9b3b0442cdb6d604069b47ffe920813ef6710
Author: Alexander Shiyan <shc_work@mail.ru>
Date:   Sat Feb 22 22:16:48 2014 +0400

    dma: imx-dma: Add missing module owner field
    
    Signed-off-by: Alexander Shiyan <shc_work@mail.ru>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index ac6011359d65..286660a12cc6 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -1236,6 +1236,7 @@ static int imxdma_remove(struct platform_device *pdev)
 static struct platform_driver imxdma_driver = {
 	.driver		= {
 		.name	= "imx-dma",
+		.owner	= THIS_MODULE,
 		.of_match_table = imx_dma_of_dev_id,
 	},
 	.id_table	= imx_dma_devtype,

commit 1d94fe0601de795e9f43e289bb381f10b53d48f8
Author: Alexander Shiyan <shc_work@mail.ru>
Date:   Sat Feb 22 22:16:47 2014 +0400

    dma: imx-dma: Replace printk with dev_*
    
    Use the dev_* message logging API instead of raw printk.
    
    Signed-off-by: Alexander Shiyan <shc_work@mail.ru>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 6f9ac2022abd..ac6011359d65 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -422,12 +422,12 @@ static irqreturn_t imxdma_err_handler(int irq, void *dev_id)
 		/* Tasklet error handler */
 		tasklet_schedule(&imxdma->channel[i].dma_tasklet);
 
-		printk(KERN_WARNING
-		       "DMA timeout on channel %d -%s%s%s%s\n", i,
-		       errcode & IMX_DMA_ERR_BURST ?    " burst" : "",
-		       errcode & IMX_DMA_ERR_REQUEST ?  " request" : "",
-		       errcode & IMX_DMA_ERR_TRANSFER ? " transfer" : "",
-		       errcode & IMX_DMA_ERR_BUFFER ?   " buffer" : "");
+		dev_warn(imxdma->dev,
+			 "DMA timeout on channel %d -%s%s%s%s\n", i,
+			 errcode & IMX_DMA_ERR_BURST ?    " burst" : "",
+			 errcode & IMX_DMA_ERR_REQUEST ?  " request" : "",
+			 errcode & IMX_DMA_ERR_TRANSFER ? " transfer" : "",
+			 errcode & IMX_DMA_ERR_BUFFER ?   " buffer" : "");
 	}
 	return IRQ_HANDLED;
 }

commit 6b327a028f09a054ac09ef854a90b6e49027f39a
Merge: f8d9f628e1f1 600d525869c4
Author: Vinod Koul <vinod.koul@intel.com>
Date:   Thu Oct 31 22:36:13 2013 +0530

    Merge branch 'for-linus' into next

commit ac806a1c880d07753e54fb80aa3a70365a58652d
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Oct 31 00:40:30 2013 +0000

    dmaengine: imx-dma: fix format warnings
    
    drivers/dma/imx-dma.c:575:3: warning: format '%x' expects argument of type 'unsigned int', but argument 6 has type 'dma_addr_t'
    drivers/dma/imx-dma.c:575:3: warning: format '%x' expects argument of type 'unsigned int', but argument 7 has type 'dma_addr_t'
    drivers/dma/imx-dma.c:589:4: warning: format '%x' expects argument of type 'unsigned int', but argument 9 has type 'dma_addr_t'
    drivers/dma/imx-dma.c:599:4: warning: format '%x' expects argument of type 'unsigned int', but argument 9 has type 'dma_addr_t'
    drivers/dma/imx-dma.c:929:2: warning: format '%x' expects argument of type 'unsigned int', but argument 6 has type 'dma_addr_t'
    drivers/dma/imx-dma.c:929:2: warning: format '%x' expects argument of type 'unsigned int', but argument 7 has type 'dma_addr_t'
    drivers/dma/imx-dma.c:959:2: warning: format '%x' expects argument of type 'unsigned int', but argument 6 has type 'dma_addr_t'
    drivers/dma/imx-dma.c:959:2: warning: format '%x' expects argument of type 'unsigned int', but argument 7 has type 'dma_addr_t'
    
    We can't use the %pa format for these because this relates to phys_addr_t,
    and dma_addr_t can be a different size.  So, fix these by converting them
    to %llx and casting the dma_addr_t to always be unsigned long long.
    
    While we're here, also use %zu for size_t.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 55852c026791..1c0d85d56562 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -572,9 +572,11 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 
 		imx_dmav1_writel(imxdma, d->len, DMA_CNTR(imxdmac->channel));
 
-		dev_dbg(imxdma->dev, "%s channel: %d dest=0x%08x src=0x%08x "
-			"dma_length=%d\n", __func__, imxdmac->channel,
-			d->dest, d->src, d->len);
+		dev_dbg(imxdma->dev,
+			"%s channel: %d dest=0x%08llx src=0x%08llx dma_length=%zu\n",
+			__func__, imxdmac->channel,
+			(unsigned long long)d->dest,
+			(unsigned long long)d->src, d->len);
 
 		break;
 	/* Cyclic transfer is the same as slave_sg with special sg configuration. */
@@ -586,20 +588,22 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 			imx_dmav1_writel(imxdma, imxdmac->ccr_from_device,
 					 DMA_CCR(imxdmac->channel));
 
-			dev_dbg(imxdma->dev, "%s channel: %d sg=%p sgcount=%d "
-				"total length=%d dev_addr=0x%08x (dev2mem)\n",
-				__func__, imxdmac->channel, d->sg, d->sgcount,
-				d->len, imxdmac->per_address);
+			dev_dbg(imxdma->dev,
+				"%s channel: %d sg=%p sgcount=%d total length=%zu dev_addr=0x%08llx (dev2mem)\n",
+				__func__, imxdmac->channel,
+				d->sg, d->sgcount, d->len,
+				(unsigned long long)imxdmac->per_address);
 		} else if (d->direction == DMA_MEM_TO_DEV) {
 			imx_dmav1_writel(imxdma, imxdmac->per_address,
 					 DMA_DAR(imxdmac->channel));
 			imx_dmav1_writel(imxdma, imxdmac->ccr_to_device,
 					 DMA_CCR(imxdmac->channel));
 
-			dev_dbg(imxdma->dev, "%s channel: %d sg=%p sgcount=%d "
-				"total length=%d dev_addr=0x%08x (mem2dev)\n",
-				__func__, imxdmac->channel, d->sg, d->sgcount,
-				d->len, imxdmac->per_address);
+			dev_dbg(imxdma->dev,
+				"%s channel: %d sg=%p sgcount=%d total length=%zu dev_addr=0x%08llx (mem2dev)\n",
+				__func__, imxdmac->channel,
+				d->sg, d->sgcount, d->len,
+				(unsigned long long)imxdmac->per_address);
 		} else {
 			dev_err(imxdma->dev, "%s channel: %d bad dma mode\n",
 				__func__, imxdmac->channel);
@@ -870,7 +874,7 @@ static struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(
 	int i;
 	unsigned int periods = buf_len / period_len;
 
-	dev_dbg(imxdma->dev, "%s channel: %d buf_len=%d period_len=%d\n",
+	dev_dbg(imxdma->dev, "%s channel: %d buf_len=%zu period_len=%zu\n",
 			__func__, imxdmac->channel, buf_len, period_len);
 
 	if (list_empty(&imxdmac->ld_free) ||
@@ -926,8 +930,9 @@ static struct dma_async_tx_descriptor *imxdma_prep_dma_memcpy(
 	struct imxdma_engine *imxdma = imxdmac->imxdma;
 	struct imxdma_desc *desc;
 
-	dev_dbg(imxdma->dev, "%s channel: %d src=0x%x dst=0x%x len=%d\n",
-			__func__, imxdmac->channel, src, dest, len);
+	dev_dbg(imxdma->dev, "%s channel: %d src=0x%llx dst=0x%llx len=%zu\n",
+		__func__, imxdmac->channel, (unsigned long long)src,
+		(unsigned long long)dest, len);
 
 	if (list_empty(&imxdmac->ld_free) ||
 	    imxdma_chan_is_doing_cyclic(imxdmac))
@@ -956,9 +961,10 @@ static struct dma_async_tx_descriptor *imxdma_prep_dma_interleaved(
 	struct imxdma_engine *imxdma = imxdmac->imxdma;
 	struct imxdma_desc *desc;
 
-	dev_dbg(imxdma->dev, "%s channel: %d src_start=0x%x dst_start=0x%x\n"
-		"   src_sgl=%s dst_sgl=%s numf=%d frame_size=%d\n", __func__,
-		imxdmac->channel, xt->src_start, xt->dst_start,
+	dev_dbg(imxdma->dev, "%s channel: %d src_start=0x%llx dst_start=0x%llx\n"
+		"   src_sgl=%s dst_sgl=%s numf=%zu frame_size=%zu\n", __func__,
+		imxdmac->channel, (unsigned long long)xt->src_start,
+		(unsigned long long) xt->dst_start,
 		xt->src_sgl ? "true" : "false", xt->dst_sgl ? "true" : "false",
 		xt->numf, xt->frame_size);
 

commit 3ded1ad14fe5cdb190e9b30a95a859d21ebd9e65
Author: Vinod Koul <vinod.koul@intel.com>
Date:   Wed Oct 16 14:06:24 2013 +0530

    dmaengine: imx-dma: use DMA_COMPLETE for dma completion status
    
    Acked-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 55852c026791..2af4028cc23e 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -771,7 +771,7 @@ static int imxdma_alloc_chan_resources(struct dma_chan *chan)
 		desc->desc.tx_submit = imxdma_tx_submit;
 		/* txd.flags will be overwritten in prep funcs */
 		desc->desc.flags = DMA_CTRL_ACK;
-		desc->status = DMA_SUCCESS;
+		desc->status = DMA_COMPLETE;
 
 		list_add_tail(&desc->node, &imxdmac->ld_free);
 		imxdmac->descs_allocated++;

commit fcaaba6c7136fe47e5a13352f99a64b019b6d2c5
Author: Michael Grzeschik <m.grzeschik@pengutronix.de>
Date:   Tue Sep 17 15:56:08 2013 +0200

    dmaengine: imx-dma: fix callback path in tasklet
    
    We need to free the ld_active list head before jumping into the callback
    routine. Otherwise the callback could run into issue_pending and change
    our ld_active list head we just going to free. This will run the channel
    list into an currupted and undefined state.
    
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 247aa7cae37c..55852c026791 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -627,13 +627,11 @@ static void imxdma_tasklet(unsigned long data)
 
 	if (list_empty(&imxdmac->ld_active)) {
 		/* Someone might have called terminate all */
-		goto out;
+		spin_unlock_irqrestore(&imxdma->lock, flags);
+		return;
 	}
 	desc = list_first_entry(&imxdmac->ld_active, struct imxdma_desc, node);
 
-	if (desc->desc.callback)
-		desc->desc.callback(desc->desc.callback_param);
-
 	/* If we are dealing with a cyclic descriptor, keep it on ld_active
 	 * and dont mark the descriptor as complete.
 	 * Only in non-cyclic cases it would be marked as complete
@@ -661,6 +659,10 @@ static void imxdma_tasklet(unsigned long data)
 	}
 out:
 	spin_unlock_irqrestore(&imxdma->lock, flags);
+
+	if (desc->desc.callback)
+		desc->desc.callback(desc->desc.callback_param);
+
 }
 
 static int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,

commit 5a276fa6bdf82fd442046969603968c83626ce0b
Author: Michael Grzeschik <m.grzeschik@pengutronix.de>
Date:   Tue Sep 17 15:56:07 2013 +0200

    dmaengine: imx-dma: fix lockdep issue between irqhandler and tasklet
    
    The tasklet and irqhandler are using spin_lock while other routines are
    using spin_lock_irqsave/restore. This leads to lockdep issues as
    described bellow. This patch is changing the code to use
    spinlock_irq_save/restore in both code pathes.
    
    As imxdma_xfer_desc always gets called with spin_lock_irqsave lock held,
    this patch also removes the spare call inside the routine to avoid
    double locking.
    
    [  403.358162] =================================
    [  403.362549] [ INFO: inconsistent lock state ]
    [  403.366945] 3.10.0-20130823+ #904 Not tainted
    [  403.371331] ---------------------------------
    [  403.375721] inconsistent {IN-HARDIRQ-W} -> {HARDIRQ-ON-W} usage.
    [  403.381769] swapper/0 [HC0[0]:SC1[1]:HE1:SE0] takes:
    [  403.386762]  (&(&imxdma->lock)->rlock){?.-...}, at: [<c019d77c>] imxdma_tasklet+0x20/0x134
    [  403.395201] {IN-HARDIRQ-W} state was registered at:
    [  403.400108]   [<c004b264>] mark_lock+0x2a0/0x6b4
    [  403.404798]   [<c004d7c8>] __lock_acquire+0x650/0x1a64
    [  403.410004]   [<c004f15c>] lock_acquire+0x94/0xa8
    [  403.414773]   [<c02f74e4>] _raw_spin_lock+0x54/0x8c
    [  403.419720]   [<c019d094>] dma_irq_handler+0x78/0x254
    [  403.424845]   [<c0061124>] handle_irq_event_percpu+0x38/0x1b4
    [  403.430670]   [<c00612e4>] handle_irq_event+0x44/0x64
    [  403.435789]   [<c0063a70>] handle_level_irq+0xd8/0xf0
    [  403.440903]   [<c0060a20>] generic_handle_irq+0x28/0x38
    [  403.446194]   [<c0009cc4>] handle_IRQ+0x68/0x8c
    [  403.450789]   [<c0008714>] avic_handle_irq+0x3c/0x48
    [  403.455811]   [<c0008f84>] __irq_svc+0x44/0x74
    [  403.460314]   [<c0040b04>] cpu_startup_entry+0x88/0xf4
    [  403.465525]   [<c02f00d0>] rest_init+0xb8/0xe0
    [  403.470045]   [<c03e07dc>] start_kernel+0x28c/0x2d4
    [  403.474986]   [<a0008040>] 0xa0008040
    [  403.478709] irq event stamp: 50854
    [  403.482140] hardirqs last  enabled at (50854): [<c001c6b8>] tasklet_action+0x38/0xdc
    [  403.489954] hardirqs last disabled at (50853): [<c001c6a0>] tasklet_action+0x20/0xdc
    [  403.497761] softirqs last  enabled at (50850): [<c001bc64>] _local_bh_enable+0x14/0x18
    [  403.505741] softirqs last disabled at (50851): [<c001c268>] irq_exit+0x88/0xdc
    [  403.513026]
    [  403.513026] other info that might help us debug this:
    [  403.519593]  Possible unsafe locking scenario:
    [  403.519593]
    [  403.525548]        CPU0
    [  403.528020]        ----
    [  403.530491]   lock(&(&imxdma->lock)->rlock);
    [  403.534828]   <Interrupt>
    [  403.537474]     lock(&(&imxdma->lock)->rlock);
    [  403.541983]
    [  403.541983]  *** DEADLOCK ***
    [  403.541983]
    [  403.547951] no locks held by swapper/0.
    [  403.551813]
    [  403.551813] stack backtrace:
    [  403.556222] CPU: 0 PID: 0 Comm: swapper Not tainted 3.10.0-20130823+ #904
    [  403.563039] Backtrace:
    [  403.565581] [<c000b98c>] (dump_backtrace+0x0/0x10c) from [<c000bb28>] (show_stack+0x18/0x1c)
    [  403.574054]  r6:00000000 r5:c05c51d8 r4:c040bd58 r3:00200000
    [  403.579872] [<c000bb10>] (show_stack+0x0/0x1c) from [<c02f398c>] (dump_stack+0x20/0x28)
    [  403.587955] [<c02f396c>] (dump_stack+0x0/0x28) from [<c02f29c8>] (print_usage_bug.part.28+0x224/0x28c)
    [  403.597340] [<c02f27a4>] (print_usage_bug.part.28+0x0/0x28c) from [<c004b404>] (mark_lock+0x440/0x6b4)
    [  403.606682]  r8:c004a41c r7:00000000 r6:c040bd58 r5:c040c040 r4:00000002
    [  403.613566] [<c004afc4>] (mark_lock+0x0/0x6b4) from [<c004d844>] (__lock_acquire+0x6cc/0x1a64)
    [  403.622244] [<c004d178>] (__lock_acquire+0x0/0x1a64) from [<c004f15c>] (lock_acquire+0x94/0xa8)
    [  403.631010] [<c004f0c8>] (lock_acquire+0x0/0xa8) from [<c02f74e4>] (_raw_spin_lock+0x54/0x8c)
    [  403.639614] [<c02f7490>] (_raw_spin_lock+0x0/0x8c) from [<c019d77c>] (imxdma_tasklet+0x20/0x134)
    [  403.648434]  r6:c3847010 r5:c040e890 r4:c38470d4
    [  403.653194] [<c019d75c>] (imxdma_tasklet+0x0/0x134) from [<c001c70c>] (tasklet_action+0x8c/0xdc)
    [  403.662013]  r8:c0599160 r7:00000000 r6:00000000 r5:c040e890 r4:c3847114 r3:c019d75c
    [  403.670042] [<c001c680>] (tasklet_action+0x0/0xdc) from [<c001bd4c>] (__do_softirq+0xe4/0x1f0)
    [  403.678687]  r7:00000101 r6:c0402000 r5:c059919c r4:00000001
    [  403.684498] [<c001bc68>] (__do_softirq+0x0/0x1f0) from [<c001c268>] (irq_exit+0x88/0xdc)
    [  403.692652] [<c001c1e0>] (irq_exit+0x0/0xdc) from [<c0009cc8>] (handle_IRQ+0x6c/0x8c)
    [  403.700514]  r4:00000030 r3:00000110
    [  403.704192] [<c0009c5c>] (handle_IRQ+0x0/0x8c) from [<c0008714>] (avic_handle_irq+0x3c/0x48)
    [  403.712664]  r5:c0403f28 r4:c0593ebc
    [  403.716343] [<c00086d8>] (avic_handle_irq+0x0/0x48) from [<c0008f84>] (__irq_svc+0x44/0x74)
    [  403.724733] Exception stack(0xc0403f28 to 0xc0403f70)
    [  403.729841] 3f20:                   00000001 00000004 00000000 20000013 c0402000 c04104a8
    [  403.738078] 3f40: 00000002 c0b69620 a0004000 41069264 a03fb5f4 c0403f7c c0403f40 c0403f70
    [  403.746301] 3f60: c004b92c c0009e74 20000013 ffffffff
    [  403.751383]  r6:ffffffff r5:20000013 r4:c0009e74 r3:c004b92c
    [  403.757210] [<c0009e30>] (arch_cpu_idle+0x0/0x4c) from [<c0040b04>] (cpu_startup_entry+0x88/0xf4)
    [  403.766161] [<c0040a7c>] (cpu_startup_entry+0x0/0xf4) from [<c02f00d0>] (rest_init+0xb8/0xe0)
    [  403.774753] [<c02f0018>] (rest_init+0x0/0xe0) from [<c03e07dc>] (start_kernel+0x28c/0x2d4)
    [  403.783051]  r6:c03fc484 r5:ffffffff r4:c040a0e0
    [  403.787797] [<c03e0550>] (start_kernel+0x0/0x2d4) from [<a0008040>] (0xa0008040)
    
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 442af6189cbc..247aa7cae37c 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -437,17 +437,18 @@ static void dma_irq_handle_channel(struct imxdma_channel *imxdmac)
 	struct imxdma_engine *imxdma = imxdmac->imxdma;
 	int chno = imxdmac->channel;
 	struct imxdma_desc *desc;
+	unsigned long flags;
 
-	spin_lock(&imxdma->lock);
+	spin_lock_irqsave(&imxdma->lock, flags);
 	if (list_empty(&imxdmac->ld_active)) {
-		spin_unlock(&imxdma->lock);
+		spin_unlock_irqrestore(&imxdma->lock, flags);
 		goto out;
 	}
 
 	desc = list_first_entry(&imxdmac->ld_active,
 				struct imxdma_desc,
 				node);
-	spin_unlock(&imxdma->lock);
+	spin_unlock_irqrestore(&imxdma->lock, flags);
 
 	if (desc->sg) {
 		u32 tmp;
@@ -519,7 +520,6 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);
 	struct imxdma_engine *imxdma = imxdmac->imxdma;
-	unsigned long flags;
 	int slot = -1;
 	int i;
 
@@ -527,7 +527,6 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 	switch (d->type) {
 	case IMXDMA_DESC_INTERLEAVED:
 		/* Try to get a free 2D slot */
-		spin_lock_irqsave(&imxdma->lock, flags);
 		for (i = 0; i < IMX_DMA_2D_SLOTS; i++) {
 			if ((imxdma->slots_2d[i].count > 0) &&
 			((imxdma->slots_2d[i].xsr != d->x) ||
@@ -537,10 +536,8 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 			slot = i;
 			break;
 		}
-		if (slot < 0) {
-			spin_unlock_irqrestore(&imxdma->lock, flags);
+		if (slot < 0)
 			return -EBUSY;
-		}
 
 		imxdma->slots_2d[slot].xsr = d->x;
 		imxdma->slots_2d[slot].ysr = d->y;
@@ -549,7 +546,6 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 
 		imxdmac->slot_2d = slot;
 		imxdmac->enabled_2d = true;
-		spin_unlock_irqrestore(&imxdma->lock, flags);
 
 		if (slot == IMX_DMA_2D_SLOT_A) {
 			d->config_mem &= ~CCR_MSEL_B;
@@ -625,8 +621,9 @@ static void imxdma_tasklet(unsigned long data)
 	struct imxdma_channel *imxdmac = (void *)data;
 	struct imxdma_engine *imxdma = imxdmac->imxdma;
 	struct imxdma_desc *desc;
+	unsigned long flags;
 
-	spin_lock(&imxdma->lock);
+	spin_lock_irqsave(&imxdma->lock, flags);
 
 	if (list_empty(&imxdmac->ld_active)) {
 		/* Someone might have called terminate all */
@@ -663,7 +660,7 @@ static void imxdma_tasklet(unsigned long data)
 				 __func__, imxdmac->channel);
 	}
 out:
-	spin_unlock(&imxdma->lock);
+	spin_unlock_irqrestore(&imxdma->lock, flags);
 }
 
 static int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,

commit edc530fe7ee5a562680615d2e7cd205879c751a7
Author: Michael Grzeschik <m.grzeschik@pengutronix.de>
Date:   Tue Sep 17 15:56:06 2013 +0200

    dmaengine: imx-dma: fix slow path issue in prep_dma_cyclic
    
    When perparing cyclic_dma buffers by the sound layer, it will dump the
    following lockdep trace. The leading snd_pcm_action_single get called
    with read_lock_irq called. To fix this, we change the kcalloc call from
    GFP_KERNEL to GFP_ATOMIC.
    
    WARNING: at kernel/lockdep.c:2740 lockdep_trace_alloc+0xcc/0x114()
    DEBUG_LOCKS_WARN_ON(irqs_disabled_flags(flags))
    Modules linked in:
    CPU: 0 PID: 832 Comm: aplay Not tainted 3.11.0-20130823+ #903
    Backtrace:
    [<c000b98c>] (dump_backtrace+0x0/0x10c) from [<c000bb28>] (show_stack+0x18/0x1c)
     r6:c004c090 r5:00000009 r4:c2e0bd18 r3:00404000
    [<c000bb10>] (show_stack+0x0/0x1c) from [<c02f397c>] (dump_stack+0x20/0x28)
    [<c02f395c>] (dump_stack+0x0/0x28) from [<c001531c>] (warn_slowpath_common+0x54/0x70)
    [<c00152c8>] (warn_slowpath_common+0x0/0x70) from [<c00153dc>] (warn_slowpath_fmt+0x38/0x40)
     r8:00004000 r7:a3b90000 r6:000080d0 r5:60000093 r4:c2e0a000 r3:00000009
    [<c00153a4>] (warn_slowpath_fmt+0x0/0x40) from [<c004c090>] (lockdep_trace_alloc+0xcc/0x114)
     r3:c03955d8 r2:c03907db
    [<c004bfc4>] (lockdep_trace_alloc+0x0/0x114) from [<c008f16c>] (__kmalloc+0x34/0x118)
     r6:000080d0 r5:c3800120 r4:000080d0 r3:c040a0f8
    [<c008f138>] (__kmalloc+0x0/0x118) from [<c019c95c>] (imxdma_prep_dma_cyclic+0x64/0x168)
     r7:a3b90000 r6:00000004 r5:c39d8420 r4:c3847150
    [<c019c8f8>] (imxdma_prep_dma_cyclic+0x0/0x168) from [<c024618c>] (snd_dmaengine_pcm_trigger+0xa8/0x160)
    [<c02460e4>] (snd_dmaengine_pcm_trigger+0x0/0x160) from [<c0241fa8>] (soc_pcm_trigger+0x90/0xb4)
     r8:c058c7b0 r7:c3b8140c r6:c39da560 r5:00000001 r4:c3b81000
    [<c0241f18>] (soc_pcm_trigger+0x0/0xb4) from [<c022ece4>] (snd_pcm_do_start+0x2c/0x38)
     r7:00000000 r6:00000003 r5:c058c7b0 r4:c3b81000
    [<c022ecb8>] (snd_pcm_do_start+0x0/0x38) from [<c022e958>] (snd_pcm_action_single+0x40/0x6c)
    [<c022e918>] (snd_pcm_action_single+0x0/0x6c) from [<c022ea64>] (snd_pcm_action_lock_irq+0x7c/0x9c)
     r7:00000003 r6:c3b810f0 r5:c3b810f0 r4:c3b81000
    [<c022e9e8>] (snd_pcm_action_lock_irq+0x0/0x9c) from [<c023009c>] (snd_pcm_common_ioctl1+0x7f8/0xfd0)
     r8:c3b7f888 r7:005407b8 r6:c2c991c0 r5:c3b81000 r4:c3b81000 r3:00004142
    [<c022f8a4>] (snd_pcm_common_ioctl1+0x0/0xfd0) from [<c023117c>] (snd_pcm_playback_ioctl1+0x464/0x488)
    [<c0230d18>] (snd_pcm_playback_ioctl1+0x0/0x488) from [<c02311d4>] (snd_pcm_playback_ioctl+0x34/0x40)
     r8:c3b7f888 r7:00004142 r6:00000004 r5:c2c991c0 r4:005407b8
    [<c02311a0>] (snd_pcm_playback_ioctl+0x0/0x40) from [<c00a14a4>] (vfs_ioctl+0x30/0x44)
    [<c00a1474>] (vfs_ioctl+0x0/0x44) from [<c00a1fe8>] (do_vfs_ioctl+0x55c/0x5c0)
    [<c00a1a8c>] (do_vfs_ioctl+0x0/0x5c0) from [<c00a208c>] (SyS_ioctl+0x40/0x68)
    [<c00a204c>] (SyS_ioctl+0x0/0x68) from [<c0009380>] (ret_fast_syscall+0x0/0x44)
     r8:c0009544 r7:00000036 r6:bedeaa58 r5:00000000 r4:000000c0
    
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 78f8ca5fccee..442af6189cbc 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -883,7 +883,7 @@ static struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(
 	kfree(imxdmac->sg_list);
 
 	imxdmac->sg_list = kcalloc(periods + 1,
-			sizeof(struct scatterlist), GFP_KERNEL);
+			sizeof(struct scatterlist), GFP_ATOMIC);
 	if (!imxdmac->sg_list)
 		return NULL;
 

commit 06f8db4b646057240ae07f8b4afabbfae5958ae7
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Mon Sep 2 13:21:18 2013 +0530

    dma: imx-dma: Remove redundant NULL check
    
    kfree on a NULL pointer is a no-op. Null pointer check is
    not necessary.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index ff2aab973b45..78f8ca5fccee 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -805,10 +805,8 @@ static void imxdma_free_chan_resources(struct dma_chan *chan)
 	}
 	INIT_LIST_HEAD(&imxdmac->ld_free);
 
-	if (imxdmac->sg_list) {
-		kfree(imxdmac->sg_list);
-		imxdmac->sg_list = NULL;
-	}
+	kfree(imxdmac->sg_list);
+	imxdmac->sg_list = NULL;
 }
 
 static struct dma_async_tx_descriptor *imxdma_prep_slave_sg(

commit 5c6b3e7725384f02418d80e7dc32b1a690497004
Author: Markus Pargmann <mpa@pengutronix.de>
Date:   Sun May 26 11:53:21 2013 +0200

    DMA: imx-dma: imxdma->dev used uninitialized
    
    imxdma->dev is used for dev_warn before it was set.
    
    Signed-off-by: Markus Pargmann <mpa@pengutronix.de>
    Reviewed-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 34c54cf08231..ff2aab973b45 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -1067,6 +1067,7 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	if (!imxdma)
 		return -ENOMEM;
 
+	imxdma->dev = &pdev->dev;
 	imxdma->devtype = pdev->id_entry->driver_data;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -1171,7 +1172,6 @@ static int __init imxdma_probe(struct platform_device *pdev)
 			      &imxdma->dma_device.channels);
 	}
 
-	imxdma->dev = &pdev->dev;
 	imxdma->dma_device.dev = &pdev->dev;
 
 	imxdma->dma_device.device_alloc_chan_resources = imxdma_alloc_chan_resources;

commit 290ad0f9d954b445788bf26652b239c59cec2060
Author: Markus Pargmann <mpa@pengutronix.de>
Date:   Sun May 26 11:53:20 2013 +0200

    dma: imx-dma: Add oftree support
    
    Adding devicetree support for imx-dma driver. Use driver name for
    function 'imx_dma_is_general_purpose' because the devicename for
    devicetree initialized devices is different.
    
    Signed-off-by: Markus Pargmann <mpa@pengutronix.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index f28583370d00..34c54cf08231 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -27,6 +27,8 @@
 #include <linux/clk.h>
 #include <linux/dmaengine.h>
 #include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_dma.h>
 
 #include <asm/irq.h>
 #include <linux/platform_data/dma-imx.h>
@@ -186,6 +188,11 @@ struct imxdma_engine {
 	enum imx_dma_type		devtype;
 };
 
+struct imxdma_filter_data {
+	struct imxdma_engine	*imxdma;
+	int			 request;
+};
+
 static struct platform_device_id imx_dma_devtype[] = {
 	{
 		.name = "imx1-dma",
@@ -202,6 +209,22 @@ static struct platform_device_id imx_dma_devtype[] = {
 };
 MODULE_DEVICE_TABLE(platform, imx_dma_devtype);
 
+static const struct of_device_id imx_dma_of_dev_id[] = {
+	{
+		.compatible = "fsl,imx1-dma",
+		.data = &imx_dma_devtype[IMX1_DMA],
+	}, {
+		.compatible = "fsl,imx21-dma",
+		.data = &imx_dma_devtype[IMX21_DMA],
+	}, {
+		.compatible = "fsl,imx27-dma",
+		.data = &imx_dma_devtype[IMX27_DMA],
+	}, {
+		/* sentinel */
+	}
+};
+MODULE_DEVICE_TABLE(of, imx_dma_of_dev_id);
+
 static inline int is_imx1_dma(struct imxdma_engine *imxdma)
 {
 	return imxdma->devtype == IMX1_DMA;
@@ -996,13 +1019,50 @@ static void imxdma_issue_pending(struct dma_chan *chan)
 	spin_unlock_irqrestore(&imxdma->lock, flags);
 }
 
+static bool imxdma_filter_fn(struct dma_chan *chan, void *param)
+{
+	struct imxdma_filter_data *fdata = param;
+	struct imxdma_channel *imxdma_chan = to_imxdma_chan(chan);
+
+	if (chan->device->dev != fdata->imxdma->dev)
+		return false;
+
+	imxdma_chan->dma_request = fdata->request;
+	chan->private = NULL;
+
+	return true;
+}
+
+static struct dma_chan *imxdma_xlate(struct of_phandle_args *dma_spec,
+						struct of_dma *ofdma)
+{
+	int count = dma_spec->args_count;
+	struct imxdma_engine *imxdma = ofdma->of_dma_data;
+	struct imxdma_filter_data fdata = {
+		.imxdma = imxdma,
+	};
+
+	if (count != 1)
+		return NULL;
+
+	fdata.request = dma_spec->args[0];
+
+	return dma_request_channel(imxdma->dma_device.cap_mask,
+					imxdma_filter_fn, &fdata);
+}
+
 static int __init imxdma_probe(struct platform_device *pdev)
 	{
 	struct imxdma_engine *imxdma;
 	struct resource *res;
+	const struct of_device_id *of_id;
 	int ret, i;
 	int irq, irq_err;
 
+	of_id = of_match_device(imx_dma_of_dev_id, &pdev->dev);
+	if (of_id)
+		pdev->id_entry = of_id->data;
+
 	imxdma = devm_kzalloc(&pdev->dev, sizeof(*imxdma), GFP_KERNEL);
 	if (!imxdma)
 		return -ENOMEM;
@@ -1136,8 +1196,19 @@ static int __init imxdma_probe(struct platform_device *pdev)
 		goto err;
 	}
 
+	if (pdev->dev.of_node) {
+		ret = of_dma_controller_register(pdev->dev.of_node,
+				imxdma_xlate, imxdma);
+		if (ret) {
+			dev_err(&pdev->dev, "unable to register of_dma_controller\n");
+			goto err_of_dma_controller;
+		}
+	}
+
 	return 0;
 
+err_of_dma_controller:
+	dma_async_device_unregister(&imxdma->dma_device);
 err:
 	clk_disable_unprepare(imxdma->dma_ipg);
 	clk_disable_unprepare(imxdma->dma_ahb);
@@ -1150,6 +1221,9 @@ static int imxdma_remove(struct platform_device *pdev)
 
         dma_async_device_unregister(&imxdma->dma_device);
 
+	if (pdev->dev.of_node)
+		of_dma_controller_free(pdev->dev.of_node);
+
 	clk_disable_unprepare(imxdma->dma_ipg);
 	clk_disable_unprepare(imxdma->dma_ahb);
 
@@ -1159,6 +1233,7 @@ static int imxdma_remove(struct platform_device *pdev)
 static struct platform_driver imxdma_driver = {
 	.driver		= {
 		.name	= "imx-dma",
+		.of_match_table = imx_dma_of_dev_id,
 	},
 	.id_table	= imx_dma_devtype,
 	.remove		= imxdma_remove,

commit 96a3713ebcf71ef94c3680422ee060a04c5bc365
Author: Syam Sidhardhan <syamsidhardh@gmail.com>
Date:   Mon Feb 25 04:46:26 2013 +0530

    dma: imx-dma: Remove redundant NULL check before kfree
    
    kfree on NULL pointer is a no-op.
    
    Signed-off-by: Syam Sidhardhan <s.syam@samsung.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 7d08ab7ff444..f28583370d00 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -859,8 +859,7 @@ static struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(
 
 	desc = list_first_entry(&imxdmac->ld_free, struct imxdma_desc, node);
 
-	if (imxdmac->sg_list)
-		kfree(imxdmac->sg_list);
+	kfree(imxdmac->sg_list);
 
 	imxdmac->sg_list = kcalloc(periods + 1,
 			sizeof(struct scatterlist), GFP_KERNEL);

commit 1d1bbd305a7831c47a35811e3ee7e8a6a7c7ed3a
Author: Maxin B. John <maxin.john@enea.com>
Date:   Wed Feb 20 02:07:04 2013 +0200

    dma: Remove erroneous __exit and __exit_p() references
    
    Removing the annotation with __exit and referencing with __exit_p()
    present in dma driver module remove hooks.
    
    Part of the __devexit and __devexit_p() purge.
    
    Signed-off-by: Maxin B. John <maxin.john@enea.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 70b8975d107e..7d08ab7ff444 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -1145,7 +1145,7 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int __exit imxdma_remove(struct platform_device *pdev)
+static int imxdma_remove(struct platform_device *pdev)
 {
 	struct imxdma_engine *imxdma = platform_get_drvdata(pdev);
 
@@ -1162,7 +1162,7 @@ static struct platform_driver imxdma_driver = {
 		.name	= "imx-dma",
 	},
 	.id_table	= imx_dma_devtype,
-	.remove		= __exit_p(imxdma_remove),
+	.remove		= imxdma_remove,
 };
 
 static int __init imxdma_module_init(void)

commit 422d26b6ecd77af8c77f2a40580679459825170f
Merge: 4c271bb67c04 949db153b646
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jan 25 21:06:30 2013 -0800

    Merge 3.8-rc5 into driver-core-next
    
    This resolves a gpio driver merge issue pointed out in linux-next.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 7331205a9662a730799470fdd9ecbff0ea073606
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Mon Jan 21 11:09:00 2013 +0100

    dma: Convert to devm_ioremap_resource()
    
    Convert all uses of devm_request_and_ioremap() to the newly introduced
    devm_ioremap_resource() which provides more consistent error handling.
    
    devm_ioremap_resource() provides its own error messages so all explicit
    error messages can be removed from the failure code paths.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Cc: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index dbf0e6f8de8a..84ae49101407 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -14,6 +14,7 @@
  * http://www.opensource.org/licenses/gpl-license.html
  * http://www.gnu.org/copyleft/gpl.html
  */
+#include <linux/err.h>
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/mm.h>
@@ -1011,9 +1012,9 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	imxdma->devtype = pdev->id_entry->driver_data;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	imxdma->base = devm_request_and_ioremap(&pdev->dev, res);
-	if (!imxdma->base)
-		return -EADDRNOTAVAIL;
+	imxdma->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(imxdma->base))
+		return PTR_ERR(imxdma->base);
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)

commit bef2a8d3f6cb91bc8743bdd63d3eb6a37bf27b12
Author: Javier Martin <javier.martin@vista-silicon.com>
Date:   Tue Oct 30 15:58:50 2012 +0000

    dmaengine: imx-dma: Disable use of hw_chain to fix sg_dma transfers.
    
    HW chaining is currently broken in imx-dma. It can be easily reproduced doing
    intensive accesses to a external MMC card and checking how the file system
    is corrupted.
    
    Preventing the driver to use HW chaining solves these issues.
    
    Signed-off-by: Javier Martin <javier.martin@vista-silicon.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index dbf0e6f8de8a..a7dcf78b1ff8 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -684,9 +684,8 @@ static int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 			break;
 		}
 
-		imxdmac->hw_chaining = 1;
-		if (!imxdma_hw_chain(imxdmac))
-			return -EINVAL;
+		imxdmac->hw_chaining = 0;
+
 		imxdmac->ccr_from_device = (mode | IMX_DMA_TYPE_FIFO) |
 			((IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR) << 2) |
 			CCR_REN;

commit 66267ee58732bb4c21c7bbba004ee481b8ad2b30
Merge: 6ed68a6d83e4 f58007762f53
Author: Olof Johansson <olof@lixom.net>
Date:   Tue Nov 6 07:51:06 2012 -0800

    Merge branch 'arm-next' of git://git.xilinx.com/linux-xlnx into next/cleanup
    
    From Michal Simek:
    
    * 'arm-next' of git://git.xilinx.com/linux-xlnx:
      zynq: move static peripheral mappings
      zynq: remove use of CLKDEV_LOOKUP
      zynq: use pl310 device tree bindings
      zynq: use GIC device tree bindings
      + Linux 3.7-rc3

commit 720dfd250e48a8c7fd1b2b8645955413989c4ee0
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Sun Oct 21 19:58:30 2012 +0800

    dmaengine: imx-dma: fix missing unlock on error in imxdma_xfer_desc()
    
    Add the missing unlock on the error handling path in function
    imxdma_xfer_desc().
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index f11b5b2b1a1c..7d9554cc4976 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -474,8 +474,10 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 			slot = i;
 			break;
 		}
-		if (slot < 0)
+		if (slot < 0) {
+			spin_unlock_irqrestore(&imxdma->lock, flags);
 			return -EBUSY;
+		}
 
 		imxdma->slots_2d[slot].xsr = d->x;
 		imxdma->slots_2d[slot].ysr = d->y;

commit e51d0f0ac4b7f513808743c6a62f0387eebd0144
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sat Sep 15 21:11:28 2012 +0800

    dma: imx-dma: remove cpu_is_xxx by using platform_device_id
    
    It changes the driver to use platform_device_id rather than cpu_is_xxx
    to determine the controller type, and updates the platform code
    accordingly.
    
    As the result, mach/hardware.h inclusion gets removed from the driver.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Tested-by: Javier Martin <javier.martin@vista-silicon.com>
    Cc: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 88e8a8d89b56..a3a8270e76fb 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -29,7 +29,6 @@
 
 #include <asm/irq.h>
 #include <linux/platform_data/dma-imx.h>
-#include <mach/hardware.h>
 
 #include "dmaengine.h"
 #define IMXDMA_MAX_CHAN_DESCRIPTORS	16
@@ -167,6 +166,12 @@ struct imxdma_channel {
 	int				slot_2d;
 };
 
+enum imx_dma_type {
+	IMX1_DMA,
+	IMX21_DMA,
+	IMX27_DMA,
+};
+
 struct imxdma_engine {
 	struct device			*dev;
 	struct device_dma_parameters	dma_parms;
@@ -177,8 +182,40 @@ struct imxdma_engine {
 	spinlock_t			lock;
 	struct imx_dma_2d_config	slots_2d[IMX_DMA_2D_SLOTS];
 	struct imxdma_channel		channel[IMX_DMA_CHANNELS];
+	enum imx_dma_type		devtype;
 };
 
+static struct platform_device_id imx_dma_devtype[] = {
+	{
+		.name = "imx1-dma",
+		.driver_data = IMX1_DMA,
+	}, {
+		.name = "imx21-dma",
+		.driver_data = IMX21_DMA,
+	}, {
+		.name = "imx27-dma",
+		.driver_data = IMX27_DMA,
+	}, {
+		/* sentinel */
+	}
+};
+MODULE_DEVICE_TABLE(platform, imx_dma_devtype);
+
+static inline int is_imx1_dma(struct imxdma_engine *imxdma)
+{
+	return imxdma->devtype == IMX1_DMA;
+}
+
+static inline int is_imx21_dma(struct imxdma_engine *imxdma)
+{
+	return imxdma->devtype == IMX21_DMA;
+}
+
+static inline int is_imx27_dma(struct imxdma_engine *imxdma)
+{
+	return imxdma->devtype == IMX27_DMA;
+}
+
 static struct imxdma_channel *to_imxdma_chan(struct dma_chan *chan)
 {
 	return container_of(chan, struct imxdma_channel, chan);
@@ -212,7 +249,9 @@ static unsigned imx_dmav1_readl(struct imxdma_engine *imxdma, unsigned offset)
 
 static int imxdma_hw_chain(struct imxdma_channel *imxdmac)
 {
-	if (cpu_is_mx27())
+	struct imxdma_engine *imxdma = imxdmac->imxdma;
+
+	if (is_imx27_dma(imxdma))
 		return imxdmac->hw_chaining;
 	else
 		return 0;
@@ -267,7 +306,7 @@ static void imxdma_enable_hw(struct imxdma_desc *d)
 	imx_dmav1_writel(imxdma, imx_dmav1_readl(imxdma, DMA_CCR(channel)) |
 			 CCR_CEN | CCR_ACRPT, DMA_CCR(channel));
 
-	if ((cpu_is_mx21() || cpu_is_mx27()) &&
+	if (!is_imx1_dma(imxdma) &&
 			d->sg && imxdma_hw_chain(imxdmac)) {
 		d->sg = sg_next(d->sg);
 		if (d->sg) {
@@ -436,7 +475,7 @@ static irqreturn_t dma_irq_handler(int irq, void *dev_id)
 	struct imxdma_engine *imxdma = dev_id;
 	int i, disr;
 
-	if (cpu_is_mx21() || cpu_is_mx27())
+	if (!is_imx1_dma(imxdma))
 		imxdma_err_handler(irq, dev_id);
 
 	disr = imx_dmav1_readl(imxdma, DMA_DISR);
@@ -967,6 +1006,8 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	if (!imxdma)
 		return -ENOMEM;
 
+	imxdma->devtype = pdev->id_entry->driver_data;
+
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	imxdma->base = devm_request_and_ioremap(&pdev->dev, res);
 	if (!imxdma->base)
@@ -990,7 +1031,7 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	/* reset DMA module */
 	imx_dmav1_writel(imxdma, DCR_DRST, DMA_DCR);
 
-	if (cpu_is_mx1()) {
+	if (is_imx1_dma(imxdma)) {
 		ret = devm_request_irq(&pdev->dev, irq,
 				       dma_irq_handler, 0, "DMA", imxdma);
 		if (ret) {
@@ -1038,7 +1079,7 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	for (i = 0; i < IMX_DMA_CHANNELS; i++) {
 		struct imxdma_channel *imxdmac = &imxdma->channel[i];
 
-		if (cpu_is_mx21() || cpu_is_mx27()) {
+		if (!is_imx1_dma(imxdma)) {
 			ret = devm_request_irq(&pdev->dev, irq + i,
 					dma_irq_handler, 0, "DMA", imxdma);
 			if (ret) {
@@ -1118,6 +1159,7 @@ static struct platform_driver imxdma_driver = {
 	.driver		= {
 		.name	= "imx-dma",
 	},
+	.id_table	= imx_dma_devtype,
 	.remove		= __exit_p(imxdma_remove),
 };
 

commit 73930eb31b2ecb0177c9bf81a35b4d2d73716951
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sat Sep 15 15:57:00 2012 +0800

    dma: imx-dma: retrieve MEM and IRQ from resources
    
    Retrieve MEM and IRQ from resources rather than directly using the
    value by including machine header.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 1f2b79009d69..88e8a8d89b56 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -959,23 +959,22 @@ static void imxdma_issue_pending(struct dma_chan *chan)
 static int __init imxdma_probe(struct platform_device *pdev)
 	{
 	struct imxdma_engine *imxdma;
+	struct resource *res;
 	int ret, i;
-
+	int irq, irq_err;
 
 	imxdma = devm_kzalloc(&pdev->dev, sizeof(*imxdma), GFP_KERNEL);
 	if (!imxdma)
 		return -ENOMEM;
 
-	if (cpu_is_mx1()) {
-		imxdma->base = MX1_IO_ADDRESS(MX1_DMA_BASE_ADDR);
-	} else if (cpu_is_mx21()) {
-		imxdma->base = MX21_IO_ADDRESS(MX21_DMA_BASE_ADDR);
-	} else if (cpu_is_mx27()) {
-		imxdma->base = MX27_IO_ADDRESS(MX27_DMA_BASE_ADDR);
-	} else {
-		kfree(imxdma);
-		return 0;
-	}
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	imxdma->base = devm_request_and_ioremap(&pdev->dev, res);
+	if (!imxdma->base)
+		return -EADDRNOTAVAIL;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
 
 	imxdma->dma_ipg = devm_clk_get(&pdev->dev, "ipg");
 	if (IS_ERR(imxdma->dma_ipg))
@@ -992,14 +991,20 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	imx_dmav1_writel(imxdma, DCR_DRST, DMA_DCR);
 
 	if (cpu_is_mx1()) {
-		ret = devm_request_irq(&pdev->dev, MX1_DMA_INT,
+		ret = devm_request_irq(&pdev->dev, irq,
 				       dma_irq_handler, 0, "DMA", imxdma);
 		if (ret) {
 			dev_warn(imxdma->dev, "Can't register IRQ for DMA\n");
 			goto err;
 		}
 
-		ret = devm_request_irq(&pdev->dev, MX1_DMA_ERR,
+		irq_err = platform_get_irq(pdev, 1);
+		if (irq_err < 0) {
+			ret = irq_err;
+			goto err;
+		}
+
+		ret = devm_request_irq(&pdev->dev, irq_err,
 				       imxdma_err_handler, 0, "DMA", imxdma);
 		if (ret) {
 			dev_warn(imxdma->dev, "Can't register ERRIRQ for DMA\n");
@@ -1034,12 +1039,12 @@ static int __init imxdma_probe(struct platform_device *pdev)
 		struct imxdma_channel *imxdmac = &imxdma->channel[i];
 
 		if (cpu_is_mx21() || cpu_is_mx27()) {
-			ret = devm_request_irq(&pdev->dev, MX2x_INT_DMACH0 + i,
+			ret = devm_request_irq(&pdev->dev, irq + i,
 					dma_irq_handler, 0, "DMA", imxdma);
 			if (ret) {
 				dev_warn(imxdma->dev, "Can't register IRQ %d "
 					 "for DMA channel %d\n",
-					 MX2x_INT_DMACH0 + i, i);
+					 irq + i, i);
 				goto err;
 			}
 			init_timer(&imxdmac->watchdog);

commit 04bbd8ef533fed260ea8cc249b534c1cbbc7f9d0
Author: Shawn Guo <shawn.guo@linaro.org>
Date:   Sat Sep 15 15:16:47 2012 +0800

    dma: imx-dma: use devm_kzalloc and devm_request_irq
    
    Use managed functions devm_kzalloc and devm_request_irq instead to
    make the error patch simpler.
    
    Signed-off-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index f11b5b2b1a1c..1f2b79009d69 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -962,7 +962,7 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	int ret, i;
 
 
-	imxdma = kzalloc(sizeof(*imxdma), GFP_KERNEL);
+	imxdma = devm_kzalloc(&pdev->dev, sizeof(*imxdma), GFP_KERNEL);
 	if (!imxdma)
 		return -ENOMEM;
 
@@ -978,16 +978,12 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	}
 
 	imxdma->dma_ipg = devm_clk_get(&pdev->dev, "ipg");
-	if (IS_ERR(imxdma->dma_ipg)) {
-		ret = PTR_ERR(imxdma->dma_ipg);
-		goto err_clk;
-	}
+	if (IS_ERR(imxdma->dma_ipg))
+		return PTR_ERR(imxdma->dma_ipg);
 
 	imxdma->dma_ahb = devm_clk_get(&pdev->dev, "ahb");
-	if (IS_ERR(imxdma->dma_ahb)) {
-		ret = PTR_ERR(imxdma->dma_ahb);
-		goto err_clk;
-	}
+	if (IS_ERR(imxdma->dma_ahb))
+		return PTR_ERR(imxdma->dma_ahb);
 
 	clk_prepare_enable(imxdma->dma_ipg);
 	clk_prepare_enable(imxdma->dma_ahb);
@@ -996,17 +992,18 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	imx_dmav1_writel(imxdma, DCR_DRST, DMA_DCR);
 
 	if (cpu_is_mx1()) {
-		ret = request_irq(MX1_DMA_INT, dma_irq_handler, 0, "DMA", imxdma);
+		ret = devm_request_irq(&pdev->dev, MX1_DMA_INT,
+				       dma_irq_handler, 0, "DMA", imxdma);
 		if (ret) {
 			dev_warn(imxdma->dev, "Can't register IRQ for DMA\n");
-			goto err_enable;
+			goto err;
 		}
 
-		ret = request_irq(MX1_DMA_ERR, imxdma_err_handler, 0, "DMA", imxdma);
+		ret = devm_request_irq(&pdev->dev, MX1_DMA_ERR,
+				       imxdma_err_handler, 0, "DMA", imxdma);
 		if (ret) {
 			dev_warn(imxdma->dev, "Can't register ERRIRQ for DMA\n");
-			free_irq(MX1_DMA_INT, NULL);
-			goto err_enable;
+			goto err;
 		}
 	}
 
@@ -1037,13 +1034,13 @@ static int __init imxdma_probe(struct platform_device *pdev)
 		struct imxdma_channel *imxdmac = &imxdma->channel[i];
 
 		if (cpu_is_mx21() || cpu_is_mx27()) {
-			ret = request_irq(MX2x_INT_DMACH0 + i,
+			ret = devm_request_irq(&pdev->dev, MX2x_INT_DMACH0 + i,
 					dma_irq_handler, 0, "DMA", imxdma);
 			if (ret) {
 				dev_warn(imxdma->dev, "Can't register IRQ %d "
 					 "for DMA channel %d\n",
 					 MX2x_INT_DMACH0 + i, i);
-				goto err_init;
+				goto err;
 			}
 			init_timer(&imxdmac->watchdog);
 			imxdmac->watchdog.function = &imxdma_watchdog;
@@ -1089,46 +1086,25 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	ret = dma_async_device_register(&imxdma->dma_device);
 	if (ret) {
 		dev_err(&pdev->dev, "unable to register\n");
-		goto err_init;
+		goto err;
 	}
 
 	return 0;
 
-err_init:
-
-	if (cpu_is_mx21() || cpu_is_mx27()) {
-		while (--i >= 0)
-			free_irq(MX2x_INT_DMACH0 + i, NULL);
-	} else if cpu_is_mx1() {
-		free_irq(MX1_DMA_INT, NULL);
-		free_irq(MX1_DMA_ERR, NULL);
-	}
-err_enable:
+err:
 	clk_disable_unprepare(imxdma->dma_ipg);
 	clk_disable_unprepare(imxdma->dma_ahb);
-err_clk:
-	kfree(imxdma);
 	return ret;
 }
 
 static int __exit imxdma_remove(struct platform_device *pdev)
 {
 	struct imxdma_engine *imxdma = platform_get_drvdata(pdev);
-	int i;
 
         dma_async_device_unregister(&imxdma->dma_device);
 
-	if (cpu_is_mx21() || cpu_is_mx27()) {
-		for (i = 0; i < IMX_DMA_CHANNELS; i++)
-			free_irq(MX2x_INT_DMACH0 + i, NULL);
-	} else if cpu_is_mx1() {
-		free_irq(MX1_DMA_INT, NULL);
-		free_irq(MX1_DMA_ERR, NULL);
-	}
-
 	clk_disable_unprepare(imxdma->dma_ipg);
 	clk_disable_unprepare(imxdma->dma_ahb);
-	kfree(imxdma);
 
         return 0;
 }

commit f5a246eab9a268f51ba8189ea5b098a1bfff200e
Merge: d5bbd43d5f45 7ff34ad80b70
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 9 07:07:14 2012 +0900

    Merge tag 'sound-3.7' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound
    
    Pull sound updates from Takashi Iwai:
     "This contains pretty many small commits covering fairly large range of
      files in sound/ directory.  Partly because of additional API support
      and partly because of constantly developed ASoC and ARM stuff.
    
      Some highlights:
    
       - Introduced the helper function and documentation for exposing the
         channel map via control API, as discussed in Plumbers; most of PCI
         drivers are covered, will follow more drivers later
    
       - Most of drivers have been replaced with the new PM callbacks (if
         the bus is supported)
    
       - HD-audio controller got the support of runtime PM and the support
         of D3 clock-stop.  Also changing the power_save option in sysfs
         kicks off immediately to enable / disable the power-save mode.
    
       - Another significant code change in HD-audio is the rewrite of
         firmware loading code.  Other than that, most of changes in
         HD-audio are continued cleanups and standardization for the generic
         auto parser and bug fixes (HBR, device-specific fixups), in
         addition to the support of channel-map API.
    
       - Addition of ASoC bindings for the compressed API, used by the
         mid-x86 drivers.
    
       - Lots of cleanups and API refreshes for ASoC codec drivers and
         DaVinci.
    
       - Conversion of OMAP to dmaengine.
    
       - New machine driver for Wolfson Microelectronics Bells.
    
       - New CODEC driver for Wolfson Microelectronics WM0010.
    
       - Enhancements to the ux500 and wm2000 drivers
    
       - A new driver for DA9055 and the support for regulator bypass mode."
    
    Fix up various arm soc header file reorg conflicts.
    
    * tag 'sound-3.7' of git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound: (339 commits)
      ALSA: hda - Add new codec ALC283 ALC290 support
      ALSA: hda - avoid unneccesary indices on "Headphone Jack" controls
      ALSA: hda - fix indices on boost volume on Conexant
      ALSA: aloop - add locking to timer access
      ALSA: hda - Fix hang caused by race during suspend.
      sound: Remove unnecessary semicolon
      ALSA: hda/realtek - Fix detection of ALC271X codec
      ALSA: hda - Add inverted internal mic quirk for Lenovo IdeaPad U310
      ALSA: hda - make Realtek/Sigmatel/Conexant use the generic unsol event
      ALSA: hda - make a generic unsol event handler
      ASoC: codecs: Add DA9055 codec driver
      ASoC: eukrea-tlv320: Convert it to platform driver
      ALSA: ASoC: add DT bindings for CS4271
      ASoC: wm_hubs: Ensure volume updates are handled during class W startup
      ASoC: wm5110: Adding missing volume update bits
      ASoC: wm5110: Add OUT3R support
      ASoC: wm5110: Add AEC loopback support
      ASoC: wm5110: Rename EPOUT to HPOUT3
      ASoC: arizona: Add more clock rates
      ASoC: arizona: Add more DSP options for mixer input muxes
      ...

commit 9cd11c0c47b8690b47e7573311ce5c483cb344ed
Merge: b9541d94bcd2 1ec9c26ad089
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 1 19:11:38 2012 -0700

    Merge tag 'multiplatform' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc
    
    Pull ARM soc multiplatform enablement from Olof Johansson:
     "This is a pretty significant branch.  It's the introduction of the
      first multiplatform support on ARM, and with this (and the later
      branch) merged, it is now possible to build one kernel that contains
      support for highbank, vexpress, mvebu, socfpga, and picoxcell.  More
      platforms will be convered over in the next few releases.
    
      Two critical last things had to be done for this to be practical and
      possible:
       * Today each platform has its own include directory under
         mach-<mach>/include/mach/*, and traditionally that is where a lot
         of driver/platform shared definitions have gone, such as platform
         data structures.  They now need to move out to a common location
         instead, and this branch moves a large number of those out to
         include/linux/platform_data.
       * Each platform used to list the device trees to compile for its
         boards in mach-<mach>/Makefile.boot.
    
      Both of the above changes will mean that there are some merge
      conflicts to come (and some to resolve here).  It's a one-time move
      and once it settles in, we should be good for quite a while.  Sorry
      for the overhead."
    
    Fix conflicts as per Olof.
    
    * tag 'multiplatform' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc: (51 commits)
      ARM: add v7 multi-platform defconfig
      ARM: msm: Move core.h contents into common.h
      ARM: highbank: call highbank_pm_init from .init_machine
      ARM: dtb: move all dtb targets to common Makefile
      ARM: spear: move platform_data definitions
      ARM: samsung: move platform_data definitions
      ARM: orion: move platform_data definitions
      ARM: vexpress: convert to multi-platform
      ARM: initial multiplatform support
      ARM: mvebu: move armada-370-xp.h in mach dir
      ARM: vexpress: remove dependency on mach/* headers
      ARM: picoxcell: remove dependency on mach/* headers
      ARM: move all dtb targets out of Makefile.boot
      ARM: picoxcell: move debug macros to include/debug
      ARM: socfpga: move debug macros to include/debug
      ARM: mvebu: move debug macros to include/debug
      ARM: vexpress: move debug macros to include/debug
      ARM: highbank: move debug macros to include/debug
      ARM: move debug macros to common location
      ARM: make mach/gpio.h headers optional
      ...

commit 99dbb1632f1165c2726056ebfce6edde0e5a0208
Merge: aae6f989c6e9 9c33c512b2d3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 1 09:06:36 2012 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    Pull the trivial tree from Jiri Kosina:
     "Tiny usual fixes all over the place"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (34 commits)
      doc: fix old config name of kprobetrace
      fs/fs-writeback.c: cleanup riteback_sb_inodes kerneldoc
      btrfs: fix the commment for the action flags in delayed-ref.h
      btrfs: fix trivial typo for the comment of BTRFS_FREE_INO_OBJECTID
      vfs: fix kerneldoc for generic_fh_to_parent()
      treewide: fix comment/printk/variable typos
      ipr: fix small coding style issues
      doc: fix broken utf8 encoding
      nfs: comment fix
      platform/x86: fix asus_laptop.wled_type module parameter
      mfd: printk/comment fixes
      doc: getdelays.c: remember to close() socket on error in create_nl_socket()
      doc: aliasing-test: close fd on write error
      mmc: fix comment typos
      dma: fix comments
      spi: fix comment/printk typos in spi
      Coccinelle: fix typo in memdup_user.cocci
      tmiofb: missing NULL pointer checks
      tools: perf: Fix typo in tools/perf
      tools/testing: fix comment / output typos
      ...

commit ec8b5e48c03790a68cb875fe5064007a9cbdfdd0
Author: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date:   Fri Sep 14 15:05:47 2012 +0300

    dmaengine: Pass flags via device_prep_dma_cyclic() callback
    
    Change the parameter list of device_prep_dma_cyclic() so the DMA drivers
    can receive the flags coming from clients.
    This feature can be used during audio operation to disable all audio
    related interrupts when the DMA_PREP_INTERRUPT is cleared from the flags.
    
    Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Acked-by: Shawn Guo <shawn.guo@linaro.org>
    Acked-by: Vinod Koul <vinod.koul@linux.intel.com>
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 5084975d793c..41b4376eb614 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -801,7 +801,7 @@ static struct dma_async_tx_descriptor *imxdma_prep_slave_sg(
 static struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(
 		struct dma_chan *chan, dma_addr_t dma_addr, size_t buf_len,
 		size_t period_len, enum dma_transfer_direction direction,
-		void *context)
+		unsigned long flags, void *context)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
 	struct imxdma_engine *imxdma = imxdmac->imxdma;

commit 82906b13a6f4f42edec92f0a3e480e1bdd9b3f91
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Aug 24 15:14:29 2012 +0200

    ARM: imx: move platform_data definitions
    
    Platform data for device drivers should be defined in
    include/linux/platform_data/*.h, not in the architecture
    and platform specific directories.
    
    This moves such data out of the imx include directories
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Nicolas Pitre <nico@linaro.org>
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Acked-by: Sascha Hauer <kernel@pengutronix.de>
    Acked-by: Vinod Koul <vinod.koul@linux.intel.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Dan Williams <djbw@fb.com>
    Cc: "Ben Dooks (embedded platforms)" <ben-linux@fluff.org>
    Cc: "Wolfram Sang (embedded platforms)" <w.sang@pengutronix.de>
    Cc: Chris Ball <cjb@laptop.org>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Alan Cox <alan@linux.intel.com>
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Florian Tobias Schandinat <FlorianSchandinat@gmx.de>
    Cc: Liam Girdwood <lrg@ti.com>
    Cc: Javier Martin <javier.martin@vista-silicon.com>
    Cc: Shawn Guo <shawn.guo@linaro.org>
    Cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 5084975d793c..b90aaec4ccc4 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -28,7 +28,7 @@
 #include <linux/module.h>
 
 #include <asm/irq.h>
-#include <mach/dma.h>
+#include <linux/platform_data/dma-imx.h>
 #include <mach/hardware.h>
 
 #include "dmaengine.h"

commit d73111c6d43f08d697a3d986fe3bd8ca796a2096
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Sat Aug 4 23:37:53 2012 +0900

    dma: fix comments
    
    Correct spelling typo in drivers/dma.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index fcfeb3cd8d31..5a49d8d7b71f 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -571,8 +571,8 @@ static void imxdma_tasklet(unsigned long data)
 	if (desc->desc.callback)
 		desc->desc.callback(desc->desc.callback_param);
 
-	/* If we are dealing with a cyclic descriptor keep it on ld_active
-	 * and dont mark the descripor as complete.
+	/* If we are dealing with a cyclic descriptor, keep it on ld_active
+	 * and dont mark the descriptor as complete.
 	 * Only in non-cyclic cases it would be marked as complete
 	 */
 	if (imxdma_chan_is_doing_cyclic(imxdmac))

commit a2367db2ec5e7fc6fe93e221e0fcdee81b053daf
Author: Fabio Estevam <festevam@gmail.com>
Date:   Tue Jul 3 15:33:29 2012 -0300

    dma: imx-dma: Fix kernel crash due to missing clock conversion
    
    With the new i.MX clock infrastructure we need to request the dma clocks
    seperately: ahb and ipg clocks.
    
    This fixes the following kernel crash and make audio to be functional again:
    
    root@freescale /home$ aplay audio48k16S.wav
    Playing WAVE 'audio48k16S.wav' : Signed 16 bit Little Endian, Rate 48000 Hz, Stereo
    Unable to handle kernel NULL pointer dereference at virtual address 00000000
    pgd = c7b74000
    [00000000] *pgd=a7bb5831, *pte=00000000, *ppte=00000000
    Internal error: Oops: 17 [#1] PREEMPT ARM
    Modules linked in:
    CPU: 0    Not tainted  (3.5.0-rc5-next-20120702-00007-g3028b64 #1128)
    PC is at snd_dmaengine_pcm_get_chan+0x8/0x10
    LR is at snd_imx_pcm_hw_params+0x18/0xdc
    pc : [<c02d3cf8>]    lr : [<c02e95ec>]    psr: a0000013
    sp : c7b45e30  ip : ffffffff  fp : c7ae58e0
    r10: 00000000  r9 : c7ae981c  r8 : c7b88800
    r7 : c7ae5a60  r6 : c7ae5b20  r5 : c7ae9810  r4 : c7afa060
    r3 : 00000000  r2 : 00000001  r1 : c7b88800  r0 : c7afa060
    Flags: NzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user
    Control: 0005317f  Table: a7b74000  DAC: 00000015
    Process aplay (pid: 701, stack limit = 0xc7b44270)
    Stack: (0xc7b45e30 to 0xc7b46000)
    5e20:                                     00100000 00000029 c7b88800 c02db870
    5e40: c7ae5a60 c02d4594 00000010 01ae5a60 c7ae5a60 c7ae9810 c7ae9810 c7afa060
    5e60: c7ae5b20 c7ae5a60 c7b88800 c02e3ef0 c02e3e08 c7b1e400 c7afa060 c7b88800
    5e80: 00000000 c0014da8 c7b44000 00000000 bec566ac c02cd400 c7afa060 c7afa060
    5ea0: bec56800 c7b88800 c0014da8 c02cdd7c c04ee710 c04ee7b8 00000003 c005fc74
    5ec0: 00000000 7fffffff c7b45f00 c7afa060 c7b67420 c7ba3070 00000004 c0014da8
    5ee0: c7b44000 00000000 bec566ac c02ced88 c04e95f8 b6f5ab04 c7b45fb0 0145a468
    5f00: 0145a600 bec566bc bec56800 c7b67420 c7ba3070 c00d499c c7b45f18 c7b45f18
    5f20: 0000001a 00000004 00000001 c7b44000 c0527f40 00000009 00000008 00000000
    5f40: c7b44000 c002c9ec 00000001 c04f0ab0 c04ebec0 00000101 00000000 0000000a
    5f60: 60000093 c7b67420 bec56800 c25c4111 00000004 c0014da8 c7b44000 00000000
    5f80: bec566ac c00d4f38 b6ffb658 00000000 c0522d80 0145a468 b6fd5000 0145a418
    5fa0: 00000036 c0014c00 0145a468 b6fd5000 00000004 c25c4111 bec56800 00020001
    5fc0: 0145a468 b6fd5000 0145a418 00000036 0145a468 0145a600 bec566bc bec566ac
    5fe0: 0145a468 bec56388 b6f65ce4 b6dcebec 20000010 00000004 00000000 00000000
    [<c02d3cf8>] (snd_dmaengine_pcm_get_chan+0x8/0x10) from [<c02e95ec>] (snd_imx_pcm_hw_params+0x18/0xdc)
    [<c02e95ec>] (snd_imx_pcm_hw_params+0x18/0xdc) from [<c02e3ef0>] (soc_pcm_hw_params+0xe8/0x1f0)
    [<c02e3ef0>] (soc_pcm_hw_params+0xe8/0x1f0) from [<c02cd400>] (snd_pcm_hw_params+0x124/0x474)
    [<c02cd400>] (snd_pcm_hw_params+0x124/0x474) from [<c02cdd7c>] (snd_pcm_common_ioctl1+0x4b4/0xf74)
    [<c02cdd7c>] (snd_pcm_common_ioctl1+0x4b4/0xf74) from [<c02ced88>] (snd_pcm_playback_ioctl1+0x30/0x510)
    [<c02ced88>] (snd_pcm_playback_ioctl1+0x30/0x510) from [<c00d499c>] (do_vfs_ioctl+0x80/0x5e4)
    [<c00d499c>] (do_vfs_ioctl+0x80/0x5e4) from [<c00d4f38>] (sys_ioctl+0x38/0x60)
    [<c00d4f38>] (sys_ioctl+0x38/0x60) from [<c0014c00>] (ret_fast_syscall+0x0/0x2c)
    Code: e593000c e12fff1e e59030a0 e59330bc (e5930000)
    ---[ end trace fa518c8ba3a74e97 ]--
    
    Reported-by: Javier Martin <javier.martin@vista-silicon.com>
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>
    Cc: stable@vger.kernel.org

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index fcfeb3cd8d31..5084975d793c 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -172,7 +172,8 @@ struct imxdma_engine {
 	struct device_dma_parameters	dma_parms;
 	struct dma_device		dma_device;
 	void __iomem			*base;
-	struct clk			*dma_clk;
+	struct clk			*dma_ahb;
+	struct clk			*dma_ipg;
 	spinlock_t			lock;
 	struct imx_dma_2d_config	slots_2d[IMX_DMA_2D_SLOTS];
 	struct imxdma_channel		channel[IMX_DMA_CHANNELS];
@@ -976,10 +977,20 @@ static int __init imxdma_probe(struct platform_device *pdev)
 		return 0;
 	}
 
-	imxdma->dma_clk = clk_get(NULL, "dma");
-	if (IS_ERR(imxdma->dma_clk))
-		return PTR_ERR(imxdma->dma_clk);
-	clk_enable(imxdma->dma_clk);
+	imxdma->dma_ipg = devm_clk_get(&pdev->dev, "ipg");
+	if (IS_ERR(imxdma->dma_ipg)) {
+		ret = PTR_ERR(imxdma->dma_ipg);
+		goto err_clk;
+	}
+
+	imxdma->dma_ahb = devm_clk_get(&pdev->dev, "ahb");
+	if (IS_ERR(imxdma->dma_ahb)) {
+		ret = PTR_ERR(imxdma->dma_ahb);
+		goto err_clk;
+	}
+
+	clk_prepare_enable(imxdma->dma_ipg);
+	clk_prepare_enable(imxdma->dma_ahb);
 
 	/* reset DMA module */
 	imx_dmav1_writel(imxdma, DCR_DRST, DMA_DCR);
@@ -988,16 +999,14 @@ static int __init imxdma_probe(struct platform_device *pdev)
 		ret = request_irq(MX1_DMA_INT, dma_irq_handler, 0, "DMA", imxdma);
 		if (ret) {
 			dev_warn(imxdma->dev, "Can't register IRQ for DMA\n");
-			kfree(imxdma);
-			return ret;
+			goto err_enable;
 		}
 
 		ret = request_irq(MX1_DMA_ERR, imxdma_err_handler, 0, "DMA", imxdma);
 		if (ret) {
 			dev_warn(imxdma->dev, "Can't register ERRIRQ for DMA\n");
 			free_irq(MX1_DMA_INT, NULL);
-			kfree(imxdma);
-			return ret;
+			goto err_enable;
 		}
 	}
 
@@ -1094,7 +1103,10 @@ static int __init imxdma_probe(struct platform_device *pdev)
 		free_irq(MX1_DMA_INT, NULL);
 		free_irq(MX1_DMA_ERR, NULL);
 	}
-
+err_enable:
+	clk_disable_unprepare(imxdma->dma_ipg);
+	clk_disable_unprepare(imxdma->dma_ahb);
+err_clk:
 	kfree(imxdma);
 	return ret;
 }
@@ -1114,7 +1126,9 @@ static int __exit imxdma_remove(struct platform_device *pdev)
 		free_irq(MX1_DMA_ERR, NULL);
 	}
 
-        kfree(imxdma);
+	clk_disable_unprepare(imxdma->dma_ipg);
+	clk_disable_unprepare(imxdma->dma_ahb);
+	kfree(imxdma);
 
         return 0;
 }

commit fdaf9c4b22247a6cc6cda9459be3e52764c14d95
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Apr 25 20:50:52 2012 +0200

    dmaengine: Use dma_sg_len(sg) instead of sg->length
    
    sg->length may or may not contain the length of the dma region to transfer,
    depending on the architecture - dma_sg_len(sg) always will though. For the
    architectures which use the drivers modified by this patch it probably is the
    case that sg->length contains the dma transfer length. But to be consistent and
    future proof change them to use dma_sg_len.
    
    To quote Russel King:
            sg->length is meaningless to something performing DMA.
    
            In cases where sg_dma_len(sg) and sg->length are the same storage, then
            there's no problem. But scatterlists _can_ (and one some architectures) do
            split them - especially when you have an IOMMU which can allow you to
            combine a scatterlist into fewer entries.
    
            So, anything using sg->length for the size of a scatterlist's DMA transfer
            _after_ a call to dma_map_sg() is almost certainly buggy.
    
    The patch has been generated using the following coccinelle patch:
    <smpl>
    @@
    struct scatterlist *sg;
    expression X;
    @@
    -sg[X].length
    +sg_dma_len(&sg[X])
    @@
    struct scatterlist *sg;
    @@
    -sg->length
    +sg_dma_len(sg)
    </smpl>
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index bb787d8e1529..fcfeb3cd8d31 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -227,7 +227,7 @@ static inline int imxdma_sg_next(struct imxdma_desc *d)
 	struct scatterlist *sg = d->sg;
 	unsigned long now;
 
-	now = min(d->len, sg->length);
+	now = min(d->len, sg_dma_len(sg));
 	if (d->len != IMX_DMA_LENGTH_LOOP)
 		d->len -= now;
 
@@ -763,16 +763,16 @@ static struct dma_async_tx_descriptor *imxdma_prep_slave_sg(
 	desc = list_first_entry(&imxdmac->ld_free, struct imxdma_desc, node);
 
 	for_each_sg(sgl, sg, sg_len, i) {
-		dma_length += sg->length;
+		dma_length += sg_dma_len(sg);
 	}
 
 	switch (imxdmac->word_size) {
 	case DMA_SLAVE_BUSWIDTH_4_BYTES:
-		if (sgl->length & 3 || sgl->dma_address & 3)
+		if (sg_dma_len(sgl) & 3 || sgl->dma_address & 3)
 			return NULL;
 		break;
 	case DMA_SLAVE_BUSWIDTH_2_BYTES:
-		if (sgl->length & 1 || sgl->dma_address & 1)
+		if (sg_dma_len(sgl) & 1 || sgl->dma_address & 1)
 			return NULL;
 		break;
 	case DMA_SLAVE_BUSWIDTH_1_BYTE:
@@ -831,13 +831,13 @@ static struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(
 		imxdmac->sg_list[i].page_link = 0;
 		imxdmac->sg_list[i].offset = 0;
 		imxdmac->sg_list[i].dma_address = dma_addr;
-		imxdmac->sg_list[i].length = period_len;
+		sg_dma_len(&imxdmac->sg_list[i]) = period_len;
 		dma_addr += period_len;
 	}
 
 	/* close the loop */
 	imxdmac->sg_list[periods].offset = 0;
-	imxdmac->sg_list[periods].length = 0;
+	sg_dma_len(&imxdmac->sg_list[periods]) = 0;
 	imxdmac->sg_list[periods].page_link =
 		((unsigned long)imxdmac->sg_list | 0x01) & ~0x02;
 

commit 60f2951e3ad9b833bc12e2ea7652be2611771792
Author: Vinod Koul <vinod.koul@linux.intel.com>
Date:   Fri Apr 20 15:28:07 2012 +0530

    dmaengine: imx-dma: dont complete descriptor for cyclic dma
    
    the cookie updates completed the cyclic dma descriptor wrongly. This caused the
    BUG_ON to be hit as submit is called for completed descriptor
    
    Fix this by not marking the cyclic descriptor as complete
    
    Tested-by: Javier Martin <javier.martin@vista-silicon.com>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index a45b5d2a5987..bb787d8e1529 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -571,11 +571,14 @@ static void imxdma_tasklet(unsigned long data)
 	if (desc->desc.callback)
 		desc->desc.callback(desc->desc.callback_param);
 
-	dma_cookie_complete(&desc->desc);
-
-	/* If we are dealing with a cyclic descriptor keep it on ld_active */
+	/* If we are dealing with a cyclic descriptor keep it on ld_active
+	 * and dont mark the descripor as complete.
+	 * Only in non-cyclic cases it would be marked as complete
+	 */
 	if (imxdma_chan_is_doing_cyclic(imxdmac))
 		goto out;
+	else
+		dma_cookie_complete(&desc->desc);
 
 	/* Free 2D slot if it was an interleaved transfer */
 	if (imxdmac->enabled_2d) {

commit ef08e78268423fc4d7fbc3e54bd9a67fc8da7cc5
Merge: 71db34fc4330 5b2e02e401de
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 29 15:34:57 2012 -0700

    Merge branch 'next' of git://git.infradead.org/users/vkoul/slave-dma
    
    Pull slave-dmaengine update from Vinod Koul:
     "This includes the cookie cleanup by Russell, the addition of context
      parameter for dmaengine APIs, more arm dmaengine driver cleanup by
      moving code to dmaengine, this time for imx by Javier and pl330 by
      Boojin along with the usual driver fixes."
    
    Fix up some fairly trivial conflicts with various other cleanups.
    
    * 'next' of git://git.infradead.org/users/vkoul/slave-dma: (67 commits)
      dmaengine: imx: fix the build failure on x86_64
      dmaengine: i.MX: Fix merge of cookie branch.
      dmaengine: i.MX: Add support for interleaved transfers.
      dmaengine: imx-dma: use 'dev_dbg' and 'dev_warn' for messages.
      dmaengine: imx-dma: remove 'imx_dmav1_baseaddr' and 'dma_clk'.
      dmaengine: imx-dma: remove unused arg of imxdma_sg_next.
      dmaengine: imx-dma: remove internal structure.
      dmaengine: imx-dma: remove 'resbytes' field of 'internal' structure.
      dmaengine: imx-dma: remove 'in_use' field of 'internal' structure.
      dmaengine: imx-dma: remove sg member from internal structure.
      dmaengine: imx-dma: remove 'imxdma_setup_sg_hw' function.
      dmaengine: imx-dma: remove 'imxdma_config_channel_hw' function.
      dmaengine: imx-dma: remove 'imxdma_setup_mem2mem_hw' function.
      dmaengine: imx-dma: remove dma_mode member of internal structure.
      dmaengine: imx-dma: remove data member from internal structure.
      dmaengine: imx-dma: merge old dma-v1.c with imx-dma.c
      dmaengine: at_hdmac: add slave config operation
      dmaengine: add context parameter to prep_slave_sg and prep_dma_cyclic
      dmaengine/dma_slave: introduce inline wrappers
      dma: imx-sdma: Treat firmware messages as warnings instead of erros
      ...

commit 660cd0dd94eba5201c69cd10f2d2fefb52807fa8
Author: Javier Martin <javier.martin@vista-silicon.com>
Date:   Thu Mar 22 14:54:15 2012 +0100

    dmaengine: i.MX: Fix merge of cookie branch.
    
    When merging DMA cookie changes a small chunk
    of code was dropped. This broke imx-dma driver.
    
    This patch adds this chunk again and fixes the problem.
    
    Signed-off-by: Javier Martin <javier.martin@vista-silicon.com>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 0f698f883cca..569b0a29fa8c 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -679,6 +679,7 @@ static dma_cookie_t imxdma_tx_submit(struct dma_async_tx_descriptor *tx)
 	unsigned long flags;
 
 	spin_lock_irqsave(&imxdma->lock, flags);
+	list_move_tail(imxdmac->ld_free.next, &imxdmac->ld_queue);
 	cookie = dma_cookie_assign(tx);
 	spin_unlock_irqrestore(&imxdma->lock, flags);
 

commit f606ab897b6d7f35b57c7474424676e30457520b
Author: Javier Martin <javier.martin@vista-silicon.com>
Date:   Thu Mar 22 14:54:14 2012 +0100

    dmaengine: i.MX: Add support for interleaved transfers.
    
    i.MX2 and i.MX1 chips have the possibility to do
    interleaved transfers with two constraints:
    - Only one chunk can be used (i.e. only 2D transfers are allowed).
    - Only 2 interleaved configurations can be applied at the same time
    for all channels.
    
    Since this patch adds a new resource 'slots_2d' which is shared
    by all the DMA channels and to avoid disgustin locking BUGs, the
    'lock' member has been moved to the global 'imxdma_engine' structure.
    
    Signed-off-by: Javier Martin <javier.martin@vista-silicon.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 307cd142f06a..0f698f883cca 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -36,6 +36,10 @@
 #define IMXDMA_MAX_CHAN_DESCRIPTORS	16
 #define IMX_DMA_CHANNELS  16
 
+#define IMX_DMA_2D_SLOTS	2
+#define IMX_DMA_2D_SLOT_A	0
+#define IMX_DMA_2D_SLOT_B	1
+
 #define IMX_DMA_LENGTH_LOOP	((unsigned int)-1)
 #define IMX_DMA_MEMSIZE_32	(0 << 4)
 #define IMX_DMA_MEMSIZE_8	(1 << 4)
@@ -111,6 +115,13 @@ enum  imxdma_prep_type {
 	IMXDMA_DESC_CYCLIC,
 };
 
+struct imx_dma_2d_config {
+	u16		xsr;
+	u16		ysr;
+	u16		wsr;
+	int		count;
+};
+
 struct imxdma_desc {
 	struct list_head		node;
 	struct dma_async_tx_descriptor	desc;
@@ -147,13 +158,14 @@ struct imxdma_channel {
 	dma_addr_t			per_address;
 	u32				watermark_level;
 	struct dma_chan			chan;
-	spinlock_t			lock;
 	struct dma_async_tx_descriptor	desc;
 	enum dma_status			status;
 	int				dma_request;
 	struct scatterlist		*sg_list;
 	u32				ccr_from_device;
 	u32				ccr_to_device;
+	bool				enabled_2d;
+	int				slot_2d;
 };
 
 struct imxdma_engine {
@@ -162,6 +174,8 @@ struct imxdma_engine {
 	struct dma_device		dma_device;
 	void __iomem			*base;
 	struct clk			*dma_clk;
+	spinlock_t			lock;
+	struct imx_dma_2d_config	slots_2d[IMX_DMA_2D_SLOTS];
 	struct imxdma_channel		channel[IMX_DMA_CHANNELS];
 };
 
@@ -361,16 +375,16 @@ static void dma_irq_handle_channel(struct imxdma_channel *imxdmac)
 	int chno = imxdmac->channel;
 	struct imxdma_desc *desc;
 
-	spin_lock(&imxdmac->lock);
+	spin_lock(&imxdma->lock);
 	if (list_empty(&imxdmac->ld_active)) {
-		spin_unlock(&imxdmac->lock);
+		spin_unlock(&imxdma->lock);
 		goto out;
 	}
 
 	desc = list_first_entry(&imxdmac->ld_active,
 				struct imxdma_desc,
 				node);
-	spin_unlock(&imxdmac->lock);
+	spin_unlock(&imxdma->lock);
 
 	if (desc->sg) {
 		u32 tmp;
@@ -442,9 +456,53 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);
 	struct imxdma_engine *imxdma = imxdmac->imxdma;
+	unsigned long flags;
+	int slot = -1;
+	int i;
 
 	/* Configure and enable */
 	switch (d->type) {
+	case IMXDMA_DESC_INTERLEAVED:
+		/* Try to get a free 2D slot */
+		spin_lock_irqsave(&imxdma->lock, flags);
+		for (i = 0; i < IMX_DMA_2D_SLOTS; i++) {
+			if ((imxdma->slots_2d[i].count > 0) &&
+			((imxdma->slots_2d[i].xsr != d->x) ||
+			(imxdma->slots_2d[i].ysr != d->y) ||
+			(imxdma->slots_2d[i].wsr != d->w)))
+				continue;
+			slot = i;
+			break;
+		}
+		if (slot < 0)
+			return -EBUSY;
+
+		imxdma->slots_2d[slot].xsr = d->x;
+		imxdma->slots_2d[slot].ysr = d->y;
+		imxdma->slots_2d[slot].wsr = d->w;
+		imxdma->slots_2d[slot].count++;
+
+		imxdmac->slot_2d = slot;
+		imxdmac->enabled_2d = true;
+		spin_unlock_irqrestore(&imxdma->lock, flags);
+
+		if (slot == IMX_DMA_2D_SLOT_A) {
+			d->config_mem &= ~CCR_MSEL_B;
+			d->config_port &= ~CCR_MSEL_B;
+			imx_dmav1_writel(imxdma, d->x, DMA_XSRA);
+			imx_dmav1_writel(imxdma, d->y, DMA_YSRA);
+			imx_dmav1_writel(imxdma, d->w, DMA_WSRA);
+		} else {
+			d->config_mem |= CCR_MSEL_B;
+			d->config_port |= CCR_MSEL_B;
+			imx_dmav1_writel(imxdma, d->x, DMA_XSRB);
+			imx_dmav1_writel(imxdma, d->y, DMA_YSRB);
+			imx_dmav1_writel(imxdma, d->w, DMA_WSRB);
+		}
+		/*
+		 * We fall-through here intentionally, since a 2D transfer is
+		 * similar to MEMCPY just adding the 2D slot configuration.
+		 */
 	case IMXDMA_DESC_MEMCPY:
 		imx_dmav1_writel(imxdma, d->src, DMA_SAR(imxdmac->channel));
 		imx_dmav1_writel(imxdma, d->dest, DMA_DAR(imxdmac->channel));
@@ -503,7 +561,7 @@ static void imxdma_tasklet(unsigned long data)
 	struct imxdma_engine *imxdma = imxdmac->imxdma;
 	struct imxdma_desc *desc;
 
-	spin_lock(&imxdmac->lock);
+	spin_lock(&imxdma->lock);
 
 	if (list_empty(&imxdmac->ld_active)) {
 		/* Someone might have called terminate all */
@@ -520,6 +578,12 @@ static void imxdma_tasklet(unsigned long data)
 	if (imxdma_chan_is_doing_cyclic(imxdmac))
 		goto out;
 
+	/* Free 2D slot if it was an interleaved transfer */
+	if (imxdmac->enabled_2d) {
+		imxdma->slots_2d[imxdmac->slot_2d].count--;
+		imxdmac->enabled_2d = false;
+	}
+
 	list_move_tail(imxdmac->ld_active.next, &imxdmac->ld_free);
 
 	if (!list_empty(&imxdmac->ld_queue)) {
@@ -531,7 +595,7 @@ static void imxdma_tasklet(unsigned long data)
 				 __func__, imxdmac->channel);
 	}
 out:
-	spin_unlock(&imxdmac->lock);
+	spin_unlock(&imxdma->lock);
 }
 
 static int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
@@ -547,10 +611,10 @@ static int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 	case DMA_TERMINATE_ALL:
 		imxdma_disable_hw(imxdmac);
 
-		spin_lock_irqsave(&imxdmac->lock, flags);
+		spin_lock_irqsave(&imxdma->lock, flags);
 		list_splice_tail_init(&imxdmac->ld_active, &imxdmac->ld_free);
 		list_splice_tail_init(&imxdmac->ld_queue, &imxdmac->ld_free);
-		spin_unlock_irqrestore(&imxdmac->lock, flags);
+		spin_unlock_irqrestore(&imxdma->lock, flags);
 		return 0;
 	case DMA_SLAVE_CONFIG:
 		if (dmaengine_cfg->direction == DMA_DEV_TO_MEM) {
@@ -610,12 +674,13 @@ static enum dma_status imxdma_tx_status(struct dma_chan *chan,
 static dma_cookie_t imxdma_tx_submit(struct dma_async_tx_descriptor *tx)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(tx->chan);
+	struct imxdma_engine *imxdma = imxdmac->imxdma;
 	dma_cookie_t cookie;
 	unsigned long flags;
 
-	spin_lock_irqsave(&imxdmac->lock, flags);
+	spin_lock_irqsave(&imxdma->lock, flags);
 	cookie = dma_cookie_assign(tx);
-	spin_unlock_irqrestore(&imxdmac->lock, flags);
+	spin_unlock_irqrestore(&imxdma->lock, flags);
 
 	return cookie;
 }
@@ -654,16 +719,17 @@ static int imxdma_alloc_chan_resources(struct dma_chan *chan)
 static void imxdma_free_chan_resources(struct dma_chan *chan)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
+	struct imxdma_engine *imxdma = imxdmac->imxdma;
 	struct imxdma_desc *desc, *_desc;
 	unsigned long flags;
 
-	spin_lock_irqsave(&imxdmac->lock, flags);
+	spin_lock_irqsave(&imxdma->lock, flags);
 
 	imxdma_disable_hw(imxdmac);
 	list_splice_tail_init(&imxdmac->ld_active, &imxdmac->ld_free);
 	list_splice_tail_init(&imxdmac->ld_queue, &imxdmac->ld_free);
 
-	spin_unlock_irqrestore(&imxdmac->lock, flags);
+	spin_unlock_irqrestore(&imxdma->lock, flags);
 
 	list_for_each_entry_safe(desc, _desc, &imxdmac->ld_free, node) {
 		kfree(desc);
@@ -818,6 +884,49 @@ static struct dma_async_tx_descriptor *imxdma_prep_dma_memcpy(
 	return &desc->desc;
 }
 
+static struct dma_async_tx_descriptor *imxdma_prep_dma_interleaved(
+	struct dma_chan *chan, struct dma_interleaved_template *xt,
+	unsigned long flags)
+{
+	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
+	struct imxdma_engine *imxdma = imxdmac->imxdma;
+	struct imxdma_desc *desc;
+
+	dev_dbg(imxdma->dev, "%s channel: %d src_start=0x%x dst_start=0x%x\n"
+		"   src_sgl=%s dst_sgl=%s numf=%d frame_size=%d\n", __func__,
+		imxdmac->channel, xt->src_start, xt->dst_start,
+		xt->src_sgl ? "true" : "false", xt->dst_sgl ? "true" : "false",
+		xt->numf, xt->frame_size);
+
+	if (list_empty(&imxdmac->ld_free) ||
+	    imxdma_chan_is_doing_cyclic(imxdmac))
+		return NULL;
+
+	if (xt->frame_size != 1 || xt->numf <= 0 || xt->dir != DMA_MEM_TO_MEM)
+		return NULL;
+
+	desc = list_first_entry(&imxdmac->ld_free, struct imxdma_desc, node);
+
+	desc->type = IMXDMA_DESC_INTERLEAVED;
+	desc->src = xt->src_start;
+	desc->dest = xt->dst_start;
+	desc->x = xt->sgl[0].size;
+	desc->y = xt->numf;
+	desc->w = xt->sgl[0].icg + desc->x;
+	desc->len = desc->x * desc->y;
+	desc->direction = DMA_MEM_TO_MEM;
+	desc->config_port = IMX_DMA_MEMSIZE_32;
+	desc->config_mem = IMX_DMA_MEMSIZE_32;
+	if (xt->src_sgl)
+		desc->config_mem |= IMX_DMA_TYPE_2D;
+	if (xt->dst_sgl)
+		desc->config_port |= IMX_DMA_TYPE_2D;
+	desc->desc.callback = NULL;
+	desc->desc.callback_param = NULL;
+
+	return &desc->desc;
+}
+
 static void imxdma_issue_pending(struct dma_chan *chan)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
@@ -825,7 +934,7 @@ static void imxdma_issue_pending(struct dma_chan *chan)
 	struct imxdma_desc *desc;
 	unsigned long flags;
 
-	spin_lock_irqsave(&imxdmac->lock, flags);
+	spin_lock_irqsave(&imxdma->lock, flags);
 	if (list_empty(&imxdmac->ld_active) &&
 	    !list_empty(&imxdmac->ld_queue)) {
 		desc = list_first_entry(&imxdmac->ld_queue,
@@ -840,7 +949,7 @@ static void imxdma_issue_pending(struct dma_chan *chan)
 				       &imxdmac->ld_active);
 		}
 	}
-	spin_unlock_irqrestore(&imxdmac->lock, flags);
+	spin_unlock_irqrestore(&imxdma->lock, flags);
 }
 
 static int __init imxdma_probe(struct platform_device *pdev)
@@ -903,6 +1012,13 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	dma_cap_set(DMA_SLAVE, imxdma->dma_device.cap_mask);
 	dma_cap_set(DMA_CYCLIC, imxdma->dma_device.cap_mask);
 	dma_cap_set(DMA_MEMCPY, imxdma->dma_device.cap_mask);
+	dma_cap_set(DMA_INTERLEAVE, imxdma->dma_device.cap_mask);
+
+	/* Initialize 2D global parameters */
+	for (i = 0; i < IMX_DMA_2D_SLOTS; i++)
+		imxdma->slots_2d[i].count = 0;
+
+	spin_lock_init(&imxdma->lock);
 
 	/* Initialize channel parameters */
 	for (i = 0; i < IMX_DMA_CHANNELS; i++) {
@@ -923,7 +1039,6 @@ static int __init imxdma_probe(struct platform_device *pdev)
 		}
 
 		imxdmac->imxdma = imxdma;
-		spin_lock_init(&imxdmac->lock);
 
 		INIT_LIST_HEAD(&imxdmac->ld_queue);
 		INIT_LIST_HEAD(&imxdmac->ld_free);
@@ -949,6 +1064,7 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	imxdma->dma_device.device_prep_slave_sg = imxdma_prep_slave_sg;
 	imxdma->dma_device.device_prep_dma_cyclic = imxdma_prep_dma_cyclic;
 	imxdma->dma_device.device_prep_dma_memcpy = imxdma_prep_dma_memcpy;
+	imxdma->dma_device.device_prep_interleaved_dma = imxdma_prep_dma_interleaved;
 	imxdma->dma_device.device_control = imxdma_control;
 	imxdma->dma_device.device_issue_pending = imxdma_issue_pending;
 

commit f9b283a6e41be584f4b1f4c6634625f41ff0c728
Author: Javier Martin <javier.martin@vista-silicon.com>
Date:   Thu Mar 22 14:54:13 2012 +0100

    dmaengine: imx-dma: use 'dev_dbg' and 'dev_warn' for messages.
    
    There were some 'pr_crit' and 'pr_debug' messages due to the
    initial merge. Replace them by 'dev_dbg' and 'dev_warn' to be
    consistent.
    
    Signed-off-by: Javier Martin <javier.martin@vista-silicon.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index cdca95a5666c..307cd142f06a 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -227,8 +227,8 @@ static inline int imxdma_sg_next(struct imxdma_desc *d)
 
 	imx_dmav1_writel(imxdma, now, DMA_CNTR(imxdmac->channel));
 
-	pr_debug("imxdma%d: next sg chunk dst 0x%08x, src 0x%08x, "
-		"size 0x%08x\n", imxdmac->channel,
+	dev_dbg(imxdma->dev, " %s channel: %d dst 0x%08x, src 0x%08x, "
+		"size 0x%08x\n", __func__, imxdmac->channel,
 		 imx_dmav1_readl(imxdma, DMA_DAR(imxdmac->channel)),
 		 imx_dmav1_readl(imxdma, DMA_SAR(imxdmac->channel)),
 		 imx_dmav1_readl(imxdma, DMA_CNTR(imxdmac->channel)));
@@ -243,7 +243,7 @@ static void imxdma_enable_hw(struct imxdma_desc *d)
 	int channel = imxdmac->channel;
 	unsigned long flags;
 
-	pr_debug("imxdma%d: imx_dma_enable\n", channel);
+	dev_dbg(imxdma->dev, "%s channel %d\n", __func__, channel);
 
 	local_irq_save(flags);
 
@@ -274,7 +274,7 @@ static void imxdma_disable_hw(struct imxdma_channel *imxdmac)
 	int channel = imxdmac->channel;
 	unsigned long flags;
 
-	pr_debug("imxdma%d: imx_dma_disable\n", channel);
+	dev_dbg(imxdma->dev, "%s channel %d\n", __func__, channel);
 
 	if (imxdma_hw_chain(imxdmac))
 		del_timer(&imxdmac->watchdog);
@@ -298,7 +298,8 @@ static void imxdma_watchdog(unsigned long data)
 
 	/* Tasklet watchdog error handler */
 	tasklet_schedule(&imxdmac->dma_tasklet);
-	pr_debug("imxdma%d: watchdog timeout!\n", imxdmac->channel);
+	dev_dbg(imxdma->dev, "channel %d: watchdog timeout!\n",
+		imxdmac->channel);
 }
 
 static irqreturn_t imxdma_err_handler(int irq, void *dev_id)
@@ -426,8 +427,7 @@ static irqreturn_t dma_irq_handler(int irq, void *dev_id)
 
 	disr = imx_dmav1_readl(imxdma, DMA_DISR);
 
-	pr_debug("imxdma: dma_irq_handler called, disr=0x%08x\n",
-		     disr);
+	dev_dbg(imxdma->dev, "%s called, disr=0x%08x\n", __func__, disr);
 
 	imx_dmav1_writel(imxdma, disr, DMA_DISR);
 	for (i = 0; i < IMX_DMA_CHANNELS; i++) {
@@ -875,14 +875,14 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	if (cpu_is_mx1()) {
 		ret = request_irq(MX1_DMA_INT, dma_irq_handler, 0, "DMA", imxdma);
 		if (ret) {
-			pr_crit("Can't register IRQ for DMA\n");
+			dev_warn(imxdma->dev, "Can't register IRQ for DMA\n");
 			kfree(imxdma);
 			return ret;
 		}
 
 		ret = request_irq(MX1_DMA_ERR, imxdma_err_handler, 0, "DMA", imxdma);
 		if (ret) {
-			pr_crit("Can't register ERRIRQ for DMA\n");
+			dev_warn(imxdma->dev, "Can't register ERRIRQ for DMA\n");
 			free_irq(MX1_DMA_INT, NULL);
 			kfree(imxdma);
 			return ret;
@@ -912,8 +912,9 @@ static int __init imxdma_probe(struct platform_device *pdev)
 			ret = request_irq(MX2x_INT_DMACH0 + i,
 					dma_irq_handler, 0, "DMA", imxdma);
 			if (ret) {
-				pr_crit("Can't register IRQ %d for DMA channel %d\n",
-						MX2x_INT_DMACH0 + i, i);
+				dev_warn(imxdma->dev, "Can't register IRQ %d "
+					 "for DMA channel %d\n",
+					 MX2x_INT_DMACH0 + i, i);
 				goto err_init;
 			}
 			init_timer(&imxdmac->watchdog);

commit cd5cf9da020293118800864641e09b71e23ba41c
Author: Javier Martin <javier.martin@vista-silicon.com>
Date:   Thu Mar 22 14:54:12 2012 +0100

    dmaengine: imx-dma: remove 'imx_dmav1_baseaddr' and 'dma_clk'.
    
    These global variables are integrated into the dmaengine structure.
    
    Signed-off-by: Javier Martin <javier.martin@vista-silicon.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 628b0f61ab38..cdca95a5666c 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -160,6 +160,8 @@ struct imxdma_engine {
 	struct device			*dev;
 	struct device_dma_parameters	dma_parms;
 	struct dma_device		dma_device;
+	void __iomem			*base;
+	struct clk			*dma_clk;
 	struct imxdma_channel		channel[IMX_DMA_CHANNELS];
 };
 
@@ -181,18 +183,17 @@ static inline bool imxdma_chan_is_doing_cyclic(struct imxdma_channel *imxdmac)
 	return false;
 }
 
-/* TODO: put this inside any struct */
-static void __iomem *imx_dmav1_baseaddr;
-static struct clk *dma_clk;
 
-static void imx_dmav1_writel(unsigned val, unsigned offset)
+
+static void imx_dmav1_writel(struct imxdma_engine *imxdma, unsigned val,
+			     unsigned offset)
 {
-	__raw_writel(val, imx_dmav1_baseaddr + offset);
+	__raw_writel(val, imxdma->base + offset);
 }
 
-static unsigned imx_dmav1_readl(unsigned offset)
+static unsigned imx_dmav1_readl(struct imxdma_engine *imxdma, unsigned offset)
 {
-	return __raw_readl(imx_dmav1_baseaddr + offset);
+	return __raw_readl(imxdma->base + offset);
 }
 
 static int imxdma_hw_chain(struct imxdma_channel *imxdmac)
@@ -209,6 +210,7 @@ static int imxdma_hw_chain(struct imxdma_channel *imxdmac)
 static inline int imxdma_sg_next(struct imxdma_desc *d)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);
+	struct imxdma_engine *imxdma = imxdmac->imxdma;
 	struct scatterlist *sg = d->sg;
 	unsigned long now;
 
@@ -217,17 +219,19 @@ static inline int imxdma_sg_next(struct imxdma_desc *d)
 		d->len -= now;
 
 	if (d->direction == DMA_DEV_TO_MEM)
-		imx_dmav1_writel(sg->dma_address, DMA_DAR(imxdmac->channel));
+		imx_dmav1_writel(imxdma, sg->dma_address,
+				 DMA_DAR(imxdmac->channel));
 	else
-		imx_dmav1_writel(sg->dma_address, DMA_SAR(imxdmac->channel));
+		imx_dmav1_writel(imxdma, sg->dma_address,
+				 DMA_SAR(imxdmac->channel));
 
-	imx_dmav1_writel(now, DMA_CNTR(imxdmac->channel));
+	imx_dmav1_writel(imxdma, now, DMA_CNTR(imxdmac->channel));
 
 	pr_debug("imxdma%d: next sg chunk dst 0x%08x, src 0x%08x, "
 		"size 0x%08x\n", imxdmac->channel,
-		 imx_dmav1_readl(DMA_DAR(imxdmac->channel)),
-		 imx_dmav1_readl(DMA_SAR(imxdmac->channel)),
-		 imx_dmav1_readl(DMA_CNTR(imxdmac->channel)));
+		 imx_dmav1_readl(imxdma, DMA_DAR(imxdmac->channel)),
+		 imx_dmav1_readl(imxdma, DMA_SAR(imxdmac->channel)),
+		 imx_dmav1_readl(imxdma, DMA_CNTR(imxdmac->channel)));
 
 	return now;
 }
@@ -235,6 +239,7 @@ static inline int imxdma_sg_next(struct imxdma_desc *d)
 static void imxdma_enable_hw(struct imxdma_desc *d)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);
+	struct imxdma_engine *imxdma = imxdmac->imxdma;
 	int channel = imxdmac->channel;
 	unsigned long flags;
 
@@ -242,10 +247,11 @@ static void imxdma_enable_hw(struct imxdma_desc *d)
 
 	local_irq_save(flags);
 
-	imx_dmav1_writel(1 << channel, DMA_DISR);
-	imx_dmav1_writel(imx_dmav1_readl(DMA_DIMR) & ~(1 << channel), DMA_DIMR);
-	imx_dmav1_writel(imx_dmav1_readl(DMA_CCR(channel)) | CCR_CEN |
-		CCR_ACRPT, DMA_CCR(channel));
+	imx_dmav1_writel(imxdma, 1 << channel, DMA_DISR);
+	imx_dmav1_writel(imxdma, imx_dmav1_readl(imxdma, DMA_DIMR) &
+			 ~(1 << channel), DMA_DIMR);
+	imx_dmav1_writel(imxdma, imx_dmav1_readl(imxdma, DMA_CCR(channel)) |
+			 CCR_CEN | CCR_ACRPT, DMA_CCR(channel));
 
 	if ((cpu_is_mx21() || cpu_is_mx27()) &&
 			d->sg && imxdma_hw_chain(imxdmac)) {
@@ -253,9 +259,9 @@ static void imxdma_enable_hw(struct imxdma_desc *d)
 		if (d->sg) {
 			u32 tmp;
 			imxdma_sg_next(d);
-			tmp = imx_dmav1_readl(DMA_CCR(channel));
-			imx_dmav1_writel(tmp | CCR_RPT | CCR_ACRPT,
-				DMA_CCR(channel));
+			tmp = imx_dmav1_readl(imxdma, DMA_CCR(channel));
+			imx_dmav1_writel(imxdma, tmp | CCR_RPT | CCR_ACRPT,
+					 DMA_CCR(channel));
 		}
 	}
 
@@ -264,6 +270,7 @@ static void imxdma_enable_hw(struct imxdma_desc *d)
 
 static void imxdma_disable_hw(struct imxdma_channel *imxdmac)
 {
+	struct imxdma_engine *imxdma = imxdmac->imxdma;
 	int channel = imxdmac->channel;
 	unsigned long flags;
 
@@ -273,19 +280,21 @@ static void imxdma_disable_hw(struct imxdma_channel *imxdmac)
 		del_timer(&imxdmac->watchdog);
 
 	local_irq_save(flags);
-	imx_dmav1_writel(imx_dmav1_readl(DMA_DIMR) | (1 << channel), DMA_DIMR);
-	imx_dmav1_writel(imx_dmav1_readl(DMA_CCR(channel)) & ~CCR_CEN,
-			DMA_CCR(channel));
-	imx_dmav1_writel(1 << channel, DMA_DISR);
+	imx_dmav1_writel(imxdma, imx_dmav1_readl(imxdma, DMA_DIMR) |
+			 (1 << channel), DMA_DIMR);
+	imx_dmav1_writel(imxdma, imx_dmav1_readl(imxdma, DMA_CCR(channel)) &
+			 ~CCR_CEN, DMA_CCR(channel));
+	imx_dmav1_writel(imxdma, 1 << channel, DMA_DISR);
 	local_irq_restore(flags);
 }
 
 static void imxdma_watchdog(unsigned long data)
 {
 	struct imxdma_channel *imxdmac = (struct imxdma_channel *)data;
+	struct imxdma_engine *imxdma = imxdmac->imxdma;
 	int channel = imxdmac->channel;
 
-	imx_dmav1_writel(0, DMA_CCR(channel));
+	imx_dmav1_writel(imxdma, 0, DMA_CCR(channel));
 
 	/* Tasklet watchdog error handler */
 	tasklet_schedule(&imxdmac->dma_tasklet);
@@ -299,37 +308,37 @@ static irqreturn_t imxdma_err_handler(int irq, void *dev_id)
 	int i, disr;
 	int errcode;
 
-	disr = imx_dmav1_readl(DMA_DISR);
+	disr = imx_dmav1_readl(imxdma, DMA_DISR);
 
-	err_mask = imx_dmav1_readl(DMA_DBTOSR) |
-		   imx_dmav1_readl(DMA_DRTOSR) |
-		   imx_dmav1_readl(DMA_DSESR)  |
-		   imx_dmav1_readl(DMA_DBOSR);
+	err_mask = imx_dmav1_readl(imxdma, DMA_DBTOSR) |
+		   imx_dmav1_readl(imxdma, DMA_DRTOSR) |
+		   imx_dmav1_readl(imxdma, DMA_DSESR)  |
+		   imx_dmav1_readl(imxdma, DMA_DBOSR);
 
 	if (!err_mask)
 		return IRQ_HANDLED;
 
-	imx_dmav1_writel(disr & err_mask, DMA_DISR);
+	imx_dmav1_writel(imxdma, disr & err_mask, DMA_DISR);
 
 	for (i = 0; i < IMX_DMA_CHANNELS; i++) {
 		if (!(err_mask & (1 << i)))
 			continue;
 		errcode = 0;
 
-		if (imx_dmav1_readl(DMA_DBTOSR) & (1 << i)) {
-			imx_dmav1_writel(1 << i, DMA_DBTOSR);
+		if (imx_dmav1_readl(imxdma, DMA_DBTOSR) & (1 << i)) {
+			imx_dmav1_writel(imxdma, 1 << i, DMA_DBTOSR);
 			errcode |= IMX_DMA_ERR_BURST;
 		}
-		if (imx_dmav1_readl(DMA_DRTOSR) & (1 << i)) {
-			imx_dmav1_writel(1 << i, DMA_DRTOSR);
+		if (imx_dmav1_readl(imxdma, DMA_DRTOSR) & (1 << i)) {
+			imx_dmav1_writel(imxdma, 1 << i, DMA_DRTOSR);
 			errcode |= IMX_DMA_ERR_REQUEST;
 		}
-		if (imx_dmav1_readl(DMA_DSESR) & (1 << i)) {
-			imx_dmav1_writel(1 << i, DMA_DSESR);
+		if (imx_dmav1_readl(imxdma, DMA_DSESR) & (1 << i)) {
+			imx_dmav1_writel(imxdma, 1 << i, DMA_DSESR);
 			errcode |= IMX_DMA_ERR_TRANSFER;
 		}
-		if (imx_dmav1_readl(DMA_DBOSR) & (1 << i)) {
-			imx_dmav1_writel(1 << i, DMA_DBOSR);
+		if (imx_dmav1_readl(imxdma, DMA_DBOSR) & (1 << i)) {
+			imx_dmav1_writel(imxdma, 1 << i, DMA_DBOSR);
 			errcode |= IMX_DMA_ERR_BUFFER;
 		}
 		/* Tasklet error handler */
@@ -347,6 +356,7 @@ static irqreturn_t imxdma_err_handler(int irq, void *dev_id)
 
 static void dma_irq_handle_channel(struct imxdma_channel *imxdmac)
 {
+	struct imxdma_engine *imxdma = imxdmac->imxdma;
 	int chno = imxdmac->channel;
 	struct imxdma_desc *desc;
 
@@ -368,7 +378,7 @@ static void dma_irq_handle_channel(struct imxdma_channel *imxdmac)
 		if (desc->sg) {
 			imxdma_sg_next(desc);
 
-			tmp = imx_dmav1_readl(DMA_CCR(chno));
+			tmp = imx_dmav1_readl(imxdma, DMA_CCR(chno));
 
 			if (imxdma_hw_chain(imxdmac)) {
 				/* FIXME: The timeout should probably be
@@ -378,13 +388,14 @@ static void dma_irq_handle_channel(struct imxdma_channel *imxdmac)
 					jiffies + msecs_to_jiffies(500));
 
 				tmp |= CCR_CEN | CCR_RPT | CCR_ACRPT;
-				imx_dmav1_writel(tmp, DMA_CCR(chno));
+				imx_dmav1_writel(imxdma, tmp, DMA_CCR(chno));
 			} else {
-				imx_dmav1_writel(tmp & ~CCR_CEN, DMA_CCR(chno));
+				imx_dmav1_writel(imxdma, tmp & ~CCR_CEN,
+						 DMA_CCR(chno));
 				tmp |= CCR_CEN;
 			}
 
-			imx_dmav1_writel(tmp, DMA_CCR(chno));
+			imx_dmav1_writel(imxdma, tmp, DMA_CCR(chno));
 
 			if (imxdma_chan_is_doing_cyclic(imxdmac))
 				/* Tasklet progression */
@@ -400,7 +411,7 @@ static void dma_irq_handle_channel(struct imxdma_channel *imxdmac)
 	}
 
 out:
-	imx_dmav1_writel(0, DMA_CCR(chno));
+	imx_dmav1_writel(imxdma, 0, DMA_CCR(chno));
 	/* Tasklet irq */
 	tasklet_schedule(&imxdmac->dma_tasklet);
 }
@@ -413,12 +424,12 @@ static irqreturn_t dma_irq_handler(int irq, void *dev_id)
 	if (cpu_is_mx21() || cpu_is_mx27())
 		imxdma_err_handler(irq, dev_id);
 
-	disr = imx_dmav1_readl(DMA_DISR);
+	disr = imx_dmav1_readl(imxdma, DMA_DISR);
 
 	pr_debug("imxdma: dma_irq_handler called, disr=0x%08x\n",
 		     disr);
 
-	imx_dmav1_writel(disr, DMA_DISR);
+	imx_dmav1_writel(imxdma, disr, DMA_DISR);
 	for (i = 0; i < IMX_DMA_CHANNELS; i++) {
 		if (disr & (1 << i))
 			dma_irq_handle_channel(&imxdma->channel[i]);
@@ -435,12 +446,12 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 	/* Configure and enable */
 	switch (d->type) {
 	case IMXDMA_DESC_MEMCPY:
-		imx_dmav1_writel(d->src, DMA_SAR(imxdmac->channel));
-		imx_dmav1_writel(d->dest, DMA_DAR(imxdmac->channel));
-		imx_dmav1_writel(d->config_mem | (d->config_port << 2),
+		imx_dmav1_writel(imxdma, d->src, DMA_SAR(imxdmac->channel));
+		imx_dmav1_writel(imxdma, d->dest, DMA_DAR(imxdmac->channel));
+		imx_dmav1_writel(imxdma, d->config_mem | (d->config_port << 2),
 			 DMA_CCR(imxdmac->channel));
 
-		imx_dmav1_writel(d->len, DMA_CNTR(imxdmac->channel));
+		imx_dmav1_writel(imxdma, d->len, DMA_CNTR(imxdmac->channel));
 
 		dev_dbg(imxdma->dev, "%s channel: %d dest=0x%08x src=0x%08x "
 			"dma_length=%d\n", __func__, imxdmac->channel,
@@ -451,9 +462,9 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 	case IMXDMA_DESC_CYCLIC:
 	case IMXDMA_DESC_SLAVE_SG:
 		if (d->direction == DMA_DEV_TO_MEM) {
-			imx_dmav1_writel(imxdmac->per_address,
+			imx_dmav1_writel(imxdma, imxdmac->per_address,
 					 DMA_SAR(imxdmac->channel));
-			imx_dmav1_writel(imxdmac->ccr_from_device,
+			imx_dmav1_writel(imxdma, imxdmac->ccr_from_device,
 					 DMA_CCR(imxdmac->channel));
 
 			dev_dbg(imxdma->dev, "%s channel: %d sg=%p sgcount=%d "
@@ -461,9 +472,9 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 				__func__, imxdmac->channel, d->sg, d->sgcount,
 				d->len, imxdmac->per_address);
 		} else if (d->direction == DMA_MEM_TO_DEV) {
-			imx_dmav1_writel(imxdmac->per_address,
+			imx_dmav1_writel(imxdma, imxdmac->per_address,
 					 DMA_DAR(imxdmac->channel));
-			imx_dmav1_writel(imxdmac->ccr_to_device,
+			imx_dmav1_writel(imxdma, imxdmac->ccr_to_device,
 					 DMA_CCR(imxdmac->channel));
 
 			dev_dbg(imxdma->dev, "%s channel: %d sg=%p sgcount=%d "
@@ -528,6 +539,7 @@ static int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
 	struct dma_slave_config *dmaengine_cfg = (void *)arg;
+	struct imxdma_engine *imxdma = imxdmac->imxdma;
 	unsigned long flags;
 	unsigned int mode = 0;
 
@@ -573,12 +585,12 @@ static int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 		imxdmac->ccr_to_device =
 			(IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR) |
 			((mode | IMX_DMA_TYPE_FIFO) << 2) | CCR_REN;
-		imx_dmav1_writel(imxdmac->dma_request,
+		imx_dmav1_writel(imxdma, imxdmac->dma_request,
 				 DMA_RSSR(imxdmac->channel));
 
 		/* Set burst length */
-		imx_dmav1_writel(imxdmac->watermark_level * imxdmac->word_size,
-				 DMA_BLR(imxdmac->channel));
+		imx_dmav1_writel(imxdma, imxdmac->watermark_level *
+				imxdmac->word_size, DMA_BLR(imxdmac->channel));
 
 		return 0;
 	default:
@@ -836,27 +848,35 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	struct imxdma_engine *imxdma;
 	int ret, i;
 
-	if (cpu_is_mx1())
-		imx_dmav1_baseaddr = MX1_IO_ADDRESS(MX1_DMA_BASE_ADDR);
-	else if (cpu_is_mx21())
-		imx_dmav1_baseaddr = MX21_IO_ADDRESS(MX21_DMA_BASE_ADDR);
-	else if (cpu_is_mx27())
-		imx_dmav1_baseaddr = MX27_IO_ADDRESS(MX27_DMA_BASE_ADDR);
-	else
+
+	imxdma = kzalloc(sizeof(*imxdma), GFP_KERNEL);
+	if (!imxdma)
+		return -ENOMEM;
+
+	if (cpu_is_mx1()) {
+		imxdma->base = MX1_IO_ADDRESS(MX1_DMA_BASE_ADDR);
+	} else if (cpu_is_mx21()) {
+		imxdma->base = MX21_IO_ADDRESS(MX21_DMA_BASE_ADDR);
+	} else if (cpu_is_mx27()) {
+		imxdma->base = MX27_IO_ADDRESS(MX27_DMA_BASE_ADDR);
+	} else {
+		kfree(imxdma);
 		return 0;
+	}
 
-	dma_clk = clk_get(NULL, "dma");
-	if (IS_ERR(dma_clk))
-		return PTR_ERR(dma_clk);
-	clk_enable(dma_clk);
+	imxdma->dma_clk = clk_get(NULL, "dma");
+	if (IS_ERR(imxdma->dma_clk))
+		return PTR_ERR(imxdma->dma_clk);
+	clk_enable(imxdma->dma_clk);
 
 	/* reset DMA module */
-	imx_dmav1_writel(DCR_DRST, DMA_DCR);
+	imx_dmav1_writel(imxdma, DCR_DRST, DMA_DCR);
 
 	if (cpu_is_mx1()) {
 		ret = request_irq(MX1_DMA_INT, dma_irq_handler, 0, "DMA", imxdma);
 		if (ret) {
 			pr_crit("Can't register IRQ for DMA\n");
+			kfree(imxdma);
 			return ret;
 		}
 
@@ -864,22 +884,19 @@ static int __init imxdma_probe(struct platform_device *pdev)
 		if (ret) {
 			pr_crit("Can't register ERRIRQ for DMA\n");
 			free_irq(MX1_DMA_INT, NULL);
+			kfree(imxdma);
 			return ret;
 		}
 	}
 
 	/* enable DMA module */
-	imx_dmav1_writel(DCR_DEN, DMA_DCR);
+	imx_dmav1_writel(imxdma, DCR_DEN, DMA_DCR);
 
 	/* clear all interrupts */
-	imx_dmav1_writel((1 << IMX_DMA_CHANNELS) - 1, DMA_DISR);
+	imx_dmav1_writel(imxdma, (1 << IMX_DMA_CHANNELS) - 1, DMA_DISR);
 
 	/* disable interrupts */
-	imx_dmav1_writel((1 << IMX_DMA_CHANNELS) - 1, DMA_DIMR);
-
-	imxdma = kzalloc(sizeof(*imxdma), GFP_KERNEL);
-	if (!imxdma)
-		return -ENOMEM;
+	imx_dmav1_writel(imxdma, (1 << IMX_DMA_CHANNELS) - 1, DMA_DIMR);
 
 	INIT_LIST_HEAD(&imxdma->dma_device.channels);
 

commit a6cbb2d87d20817e555a6ffa3131bfa1cdd9ab73
Author: Javier Martin <javier.martin@vista-silicon.com>
Date:   Thu Mar 22 14:54:11 2012 +0100

    dmaengine: imx-dma: remove unused arg of imxdma_sg_next.
    
    Since this function is always used with 'desc' as first argument
    and 'desc->sg' as second argument, the latter is clearly redundant
    and can be removed.
    
    Signed-off-by: Javier Martin <javier.martin@vista-silicon.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 629be353c63a..628b0f61ab38 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -206,9 +206,10 @@ static int imxdma_hw_chain(struct imxdma_channel *imxdmac)
 /*
  * imxdma_sg_next - prepare next chunk for scatter-gather DMA emulation
  */
-static inline int imxdma_sg_next(struct imxdma_desc *d, struct scatterlist *sg)
+static inline int imxdma_sg_next(struct imxdma_desc *d)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);
+	struct scatterlist *sg = d->sg;
 	unsigned long now;
 
 	now = min(d->len, sg->length);
@@ -251,7 +252,7 @@ static void imxdma_enable_hw(struct imxdma_desc *d)
 		d->sg = sg_next(d->sg);
 		if (d->sg) {
 			u32 tmp;
-			imxdma_sg_next(d, d->sg);
+			imxdma_sg_next(d);
 			tmp = imx_dmav1_readl(DMA_CCR(channel));
 			imx_dmav1_writel(tmp | CCR_RPT | CCR_ACRPT,
 				DMA_CCR(channel));
@@ -365,7 +366,7 @@ static void dma_irq_handle_channel(struct imxdma_channel *imxdmac)
 		desc->sg = sg_next(desc->sg);
 
 		if (desc->sg) {
-			imxdma_sg_next(desc, desc->sg);
+			imxdma_sg_next(desc);
 
 			tmp = imx_dmav1_readl(DMA_CCR(chno));
 
@@ -475,7 +476,7 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 			return -EINVAL;
 		}
 
-		imxdma_sg_next(d, d->sg);
+		imxdma_sg_next(d);
 
 		break;
 	default:

commit 2d9c2fc59a74e625eff795a788cacc65648290d6
Author: Javier Martin <javier.martin@vista-silicon.com>
Date:   Thu Mar 22 14:54:10 2012 +0100

    dmaengine: imx-dma: remove internal structure.
    
    This structure was created to allow an smoothless
    merge but was meant to be removed. Remaining members
    'hw_chaining' and 'watchdog' are moved to the channel
    structure.
    
    Signed-off-by: Javier Martin <javier.martin@vista-silicon.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 6e03f928ca81..629be353c63a 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -111,29 +111,6 @@ enum  imxdma_prep_type {
 	IMXDMA_DESC_CYCLIC,
 };
 
-/*
- * struct imxdma_channel_internal - i.MX specific DMA extension
- * @name: name specified by DMA client
- * @irq_handler: client callback for end of transfer
- * @err_handler: client callback for error condition
- * @data: clients context data for callbacks
- * @dma_mode: direction of the transfer %DMA_MODE_READ or %DMA_MODE_WRITE
- * @sg: pointer to the actual read/written chunk for scatter-gather emulation
- * @resbytes: total residual number of bytes to transfer
- *            (it can be lower or same as sum of SG mapped chunk sizes)
- * @sgcount: number of chunks to be read/written
- *
- * Structure is used for IMX DMA processing. It would be probably good
- * @struct dma_struct in the future for external interfacing and use
- * @struct imxdma_channel_internal only as extension to it.
- */
-
-struct imxdma_channel_internal {
-	struct timer_list watchdog;
-
-	int hw_chaining;
-};
-
 struct imxdma_desc {
 	struct list_head		node;
 	struct dma_async_tx_descriptor	desc;
@@ -156,7 +133,8 @@ struct imxdma_desc {
 };
 
 struct imxdma_channel {
-	struct imxdma_channel_internal	internal;
+	int				hw_chaining;
+	struct timer_list		watchdog;
 	struct imxdma_engine		*imxdma;
 	unsigned int			channel;
 
@@ -217,10 +195,10 @@ static unsigned imx_dmav1_readl(unsigned offset)
 	return __raw_readl(imx_dmav1_baseaddr + offset);
 }
 
-static int imxdma_hw_chain(struct imxdma_channel_internal *imxdma)
+static int imxdma_hw_chain(struct imxdma_channel *imxdmac)
 {
 	if (cpu_is_mx27())
-		return imxdma->hw_chaining;
+		return imxdmac->hw_chaining;
 	else
 		return 0;
 }
@@ -269,7 +247,7 @@ static void imxdma_enable_hw(struct imxdma_desc *d)
 		CCR_ACRPT, DMA_CCR(channel));
 
 	if ((cpu_is_mx21() || cpu_is_mx27()) &&
-			d->sg && imxdma_hw_chain(&imxdmac->internal)) {
+			d->sg && imxdma_hw_chain(imxdmac)) {
 		d->sg = sg_next(d->sg);
 		if (d->sg) {
 			u32 tmp;
@@ -290,8 +268,8 @@ static void imxdma_disable_hw(struct imxdma_channel *imxdmac)
 
 	pr_debug("imxdma%d: imx_dma_disable\n", channel);
 
-	if (imxdma_hw_chain(&imxdmac->internal))
-		del_timer(&imxdmac->internal.watchdog);
+	if (imxdma_hw_chain(imxdmac))
+		del_timer(&imxdmac->watchdog);
 
 	local_irq_save(flags);
 	imx_dmav1_writel(imx_dmav1_readl(DMA_DIMR) | (1 << channel), DMA_DIMR);
@@ -316,7 +294,6 @@ static void imxdma_watchdog(unsigned long data)
 static irqreturn_t imxdma_err_handler(int irq, void *dev_id)
 {
 	struct imxdma_engine *imxdma = dev_id;
-	struct imxdma_channel_internal *internal;
 	unsigned int err_mask;
 	int i, disr;
 	int errcode;
@@ -336,7 +313,6 @@ static irqreturn_t imxdma_err_handler(int irq, void *dev_id)
 	for (i = 0; i < IMX_DMA_CHANNELS; i++) {
 		if (!(err_mask & (1 << i)))
 			continue;
-		internal = &imxdma->channel[i].internal;
 		errcode = 0;
 
 		if (imx_dmav1_readl(DMA_DBTOSR) & (1 << i)) {
@@ -370,7 +346,6 @@ static irqreturn_t imxdma_err_handler(int irq, void *dev_id)
 
 static void dma_irq_handle_channel(struct imxdma_channel *imxdmac)
 {
-	struct imxdma_channel_internal *imxdma = &imxdmac->internal;
 	int chno = imxdmac->channel;
 	struct imxdma_desc *desc;
 
@@ -394,11 +369,11 @@ static void dma_irq_handle_channel(struct imxdma_channel *imxdmac)
 
 			tmp = imx_dmav1_readl(DMA_CCR(chno));
 
-			if (imxdma_hw_chain(imxdma)) {
+			if (imxdma_hw_chain(imxdmac)) {
 				/* FIXME: The timeout should probably be
 				 * configurable
 				 */
-				mod_timer(&imxdma->watchdog,
+				mod_timer(&imxdmac->watchdog,
 					jiffies + msecs_to_jiffies(500));
 
 				tmp |= CCR_CEN | CCR_RPT | CCR_ACRPT;
@@ -417,8 +392,8 @@ static void dma_irq_handle_channel(struct imxdma_channel *imxdmac)
 			return;
 		}
 
-		if (imxdma_hw_chain(imxdma)) {
-			del_timer(&imxdma->watchdog);
+		if (imxdma_hw_chain(imxdmac)) {
+			del_timer(&imxdmac->watchdog);
 			return;
 		}
 	}
@@ -432,7 +407,6 @@ static void dma_irq_handle_channel(struct imxdma_channel *imxdmac)
 static irqreturn_t dma_irq_handler(int irq, void *dev_id)
 {
 	struct imxdma_engine *imxdma = dev_id;
-	struct imxdma_channel_internal *internal;
 	int i, disr;
 
 	if (cpu_is_mx21() || cpu_is_mx27())
@@ -445,10 +419,8 @@ static irqreturn_t dma_irq_handler(int irq, void *dev_id)
 
 	imx_dmav1_writel(disr, DMA_DISR);
 	for (i = 0; i < IMX_DMA_CHANNELS; i++) {
-		if (disr & (1 << i)) {
-			internal = &imxdma->channel[i].internal;
+		if (disr & (1 << i))
 			dma_irq_handle_channel(&imxdma->channel[i]);
-		}
 	}
 
 	return IRQ_HANDLED;
@@ -591,8 +563,8 @@ static int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 			break;
 		}
 
-		imxdmac->internal.hw_chaining = 1;
-		if (!imxdma_hw_chain(&imxdmac->internal))
+		imxdmac->hw_chaining = 1;
+		if (!imxdma_hw_chain(imxdmac))
 			return -EINVAL;
 		imxdmac->ccr_from_device = (mode | IMX_DMA_TYPE_FIFO) |
 			((IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR) << 2) |
@@ -917,7 +889,7 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	/* Initialize channel parameters */
 	for (i = 0; i < IMX_DMA_CHANNELS; i++) {
 		struct imxdma_channel *imxdmac = &imxdma->channel[i];
-		memset(&imxdmac->internal, 0, sizeof(imxdmac->internal));
+
 		if (cpu_is_mx21() || cpu_is_mx27()) {
 			ret = request_irq(MX2x_INT_DMACH0 + i,
 					dma_irq_handler, 0, "DMA", imxdma);
@@ -926,9 +898,9 @@ static int __init imxdma_probe(struct platform_device *pdev)
 						MX2x_INT_DMACH0 + i, i);
 				goto err_init;
 			}
-			init_timer(&imxdmac->internal.watchdog);
-			imxdmac->internal.watchdog.function = &imxdma_watchdog;
-			imxdmac->internal.watchdog.data = (unsigned long)imxdmac;
+			init_timer(&imxdmac->watchdog);
+			imxdmac->watchdog.function = &imxdma_watchdog;
+			imxdmac->watchdog.data = (unsigned long)imxdmac;
 		}
 
 		imxdmac->imxdma = imxdma;

commit 6b0e2f55e3ebc7089abf5e4770f03fb264b6d2ea
Author: Javier Martin <javier.martin@vista-silicon.com>
Date:   Thu Mar 22 14:54:09 2012 +0100

    dmaengine: imx-dma: remove 'resbytes' field of 'internal' structure.
    
    Use per-descriptor 'len' field to keep track of the remaining bytes
    instead. This goes on the direction of eventually removing the
    'internal' structure.
    
    Signed-off-by: Javier Martin <javier.martin@vista-silicon.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index d7309e44c0df..6e03f928ca81 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -129,8 +129,6 @@ enum  imxdma_prep_type {
  */
 
 struct imxdma_channel_internal {
-	unsigned int resbytes;
-
 	struct timer_list watchdog;
 
 	int hw_chaining;
@@ -233,12 +231,11 @@ static int imxdma_hw_chain(struct imxdma_channel_internal *imxdma)
 static inline int imxdma_sg_next(struct imxdma_desc *d, struct scatterlist *sg)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);
-	struct imxdma_channel_internal *imxdma = &imxdmac->internal;
 	unsigned long now;
 
-	now = min(imxdma->resbytes, sg->length);
-	if (imxdma->resbytes != IMX_DMA_LENGTH_LOOP)
-		imxdma->resbytes -= now;
+	now = min(d->len, sg->length);
+	if (d->len != IMX_DMA_LENGTH_LOOP)
+		d->len -= now;
 
 	if (d->direction == DMA_DEV_TO_MEM)
 		imx_dmav1_writel(sg->dma_address, DMA_DAR(imxdmac->channel));
@@ -480,8 +477,6 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 	/* Cyclic transfer is the same as slave_sg with special sg configuration. */
 	case IMXDMA_DESC_CYCLIC:
 	case IMXDMA_DESC_SLAVE_SG:
-		imxdmac->internal.resbytes = d->len;
-
 		if (d->direction == DMA_DEV_TO_MEM) {
 			imx_dmav1_writel(imxdmac->per_address,
 					 DMA_SAR(imxdmac->channel));

commit e4756b5e068d866239b6880a7030c9d31400b254
Author: Javier Martin <javier.martin@vista-silicon.com>
Date:   Thu Mar 22 14:54:08 2012 +0100

    dmaengine: imx-dma: remove 'in_use' field of 'internal' structure.
    
    It makes no sense keeping an 'in_use' flag when the multiple descriptor
    mechanism already prevents a new DMA transfer to be issued when another
    one is in course.
    
    Signed-off-by: Javier Martin <javier.martin@vista-silicon.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 82d4099bd8f4..d7309e44c0df 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -131,8 +131,6 @@ enum  imxdma_prep_type {
 struct imxdma_channel_internal {
 	unsigned int resbytes;
 
-	int in_use;
-
 	struct timer_list watchdog;
 
 	int hw_chaining;
@@ -266,9 +264,6 @@ static void imxdma_enable_hw(struct imxdma_desc *d)
 
 	pr_debug("imxdma%d: imx_dma_enable\n", channel);
 
-	if (imxdmac->internal.in_use)
-		return;
-
 	local_irq_save(flags);
 
 	imx_dmav1_writel(1 << channel, DMA_DISR);
@@ -287,7 +282,6 @@ static void imxdma_enable_hw(struct imxdma_desc *d)
 				DMA_CCR(channel));
 		}
 	}
-	imxdmac->internal.in_use = 1;
 
 	local_irq_restore(flags);
 }
@@ -307,7 +301,6 @@ static void imxdma_disable_hw(struct imxdma_channel *imxdmac)
 	imx_dmav1_writel(imx_dmav1_readl(DMA_CCR(channel)) & ~CCR_CEN,
 			DMA_CCR(channel));
 	imx_dmav1_writel(1 << channel, DMA_DISR);
-	imxdmac->internal.in_use = 0;
 	local_irq_restore(flags);
 }
 
@@ -317,7 +310,6 @@ static void imxdma_watchdog(unsigned long data)
 	int channel = imxdmac->channel;
 
 	imx_dmav1_writel(0, DMA_CCR(channel));
-	imxdmac->internal.in_use = 0;
 
 	/* Tasklet watchdog error handler */
 	tasklet_schedule(&imxdmac->dma_tasklet);
@@ -436,7 +428,6 @@ static void dma_irq_handle_channel(struct imxdma_channel *imxdmac)
 
 out:
 	imx_dmav1_writel(0, DMA_CCR(chno));
-	imxdma->in_use = 0;
 	/* Tasklet irq */
 	tasklet_schedule(&imxdmac->dma_tasklet);
 }

commit 833bc03bf14ef6d3f82d86845c29aa1f7e2037e3
Author: Javier Martin <javier.martin@vista-silicon.com>
Date:   Thu Mar 22 14:54:07 2012 +0100

    dmaengine: imx-dma: remove sg member from internal structure.
    
    This member is redundant, because it is already present in
    descriptor structure. Removing it will make further removing
    of 'internal' structure easier.
    
    Signed-off-by: Javier Martin <javier.martin@vista-silicon.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 484f35365902..82d4099bd8f4 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -129,7 +129,6 @@ enum  imxdma_prep_type {
  */
 
 struct imxdma_channel_internal {
-	struct scatterlist *sg;
 	unsigned int resbytes;
 
 	int in_use;
@@ -278,11 +277,11 @@ static void imxdma_enable_hw(struct imxdma_desc *d)
 		CCR_ACRPT, DMA_CCR(channel));
 
 	if ((cpu_is_mx21() || cpu_is_mx27()) &&
-			imxdmac->internal.sg && imxdma_hw_chain(&imxdmac->internal)) {
-		imxdmac->internal.sg = sg_next(imxdmac->internal.sg);
-		if (imxdmac->internal.sg) {
+			d->sg && imxdma_hw_chain(&imxdmac->internal)) {
+		d->sg = sg_next(d->sg);
+		if (d->sg) {
 			u32 tmp;
-			imxdma_sg_next(d, imxdmac->internal.sg);
+			imxdma_sg_next(d, d->sg);
 			tmp = imx_dmav1_readl(DMA_CCR(channel));
 			imx_dmav1_writel(tmp | CCR_RPT | CCR_ACRPT,
 				DMA_CCR(channel));
@@ -319,7 +318,6 @@ static void imxdma_watchdog(unsigned long data)
 
 	imx_dmav1_writel(0, DMA_CCR(channel));
 	imxdmac->internal.in_use = 0;
-	imxdmac->internal.sg = NULL;
 
 	/* Tasklet watchdog error handler */
 	tasklet_schedule(&imxdmac->dma_tasklet);
@@ -387,24 +385,23 @@ static void dma_irq_handle_channel(struct imxdma_channel *imxdmac)
 	int chno = imxdmac->channel;
 	struct imxdma_desc *desc;
 
-	if (imxdma->sg) {
-		u32 tmp;
-		imxdma->sg = sg_next(imxdma->sg);
-
-		if (imxdma->sg) {
+	spin_lock(&imxdmac->lock);
+	if (list_empty(&imxdmac->ld_active)) {
+		spin_unlock(&imxdmac->lock);
+		goto out;
+	}
 
-			spin_lock(&imxdmac->lock);
-			if (list_empty(&imxdmac->ld_active)) {
-				spin_unlock(&imxdmac->lock);
-				goto out;
-			}
+	desc = list_first_entry(&imxdmac->ld_active,
+				struct imxdma_desc,
+				node);
+	spin_unlock(&imxdmac->lock);
 
-			desc = list_first_entry(&imxdmac->ld_active,
-						struct imxdma_desc,
-						node);
-			spin_unlock(&imxdmac->lock);
+	if (desc->sg) {
+		u32 tmp;
+		desc->sg = sg_next(desc->sg);
 
-			imxdma_sg_next(desc, imxdma->sg);
+		if (desc->sg) {
+			imxdma_sg_next(desc, desc->sg);
 
 			tmp = imx_dmav1_readl(DMA_CCR(chno));
 
@@ -477,8 +474,6 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 	/* Configure and enable */
 	switch (d->type) {
 	case IMXDMA_DESC_MEMCPY:
-		imxdmac->internal.sg = NULL;
-
 		imx_dmav1_writel(d->src, DMA_SAR(imxdmac->channel));
 		imx_dmav1_writel(d->dest, DMA_DAR(imxdmac->channel));
 		imx_dmav1_writel(d->config_mem | (d->config_port << 2),
@@ -494,7 +489,6 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 	/* Cyclic transfer is the same as slave_sg with special sg configuration. */
 	case IMXDMA_DESC_CYCLIC:
 	case IMXDMA_DESC_SLAVE_SG:
-		imxdmac->internal.sg = d->sg;
 		imxdmac->internal.resbytes = d->len;
 
 		if (d->direction == DMA_DEV_TO_MEM) {

commit 359291a1a095a8a402405cd9c4bab46684e7bcfe
Author: Javier Martin <javier.martin@vista-silicon.com>
Date:   Thu Mar 22 14:54:06 2012 +0100

    dmaengine: imx-dma: remove 'imxdma_setup_sg_hw' function.
    
    Removing this function allows moving 'ccr_to_device' and
    'ccr_from_device' from internal struct to channel struct.
    This repesents a step forward towards removing auxiliary
    'internal' structure.
    
    Signed-off-by: Javier Martin <javier.martin@vista-silicon.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 25b4108f6224..484f35365902 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -134,9 +134,6 @@ struct imxdma_channel_internal {
 
 	int in_use;
 
-	u32 ccr_from_device;
-	u32 ccr_to_device;
-
 	struct timer_list watchdog;
 
 	int hw_chaining;
@@ -182,6 +179,8 @@ struct imxdma_channel {
 	enum dma_status			status;
 	int				dma_request;
 	struct scatterlist		*sg_list;
+	u32				ccr_from_device;
+	u32				ccr_to_device;
 };
 
 struct imxdma_engine {
@@ -313,58 +312,6 @@ static void imxdma_disable_hw(struct imxdma_channel *imxdmac)
 	local_irq_restore(flags);
 }
 
-static int
-imxdma_setup_sg_hw(struct imxdma_desc *d,
-		 struct scatterlist *sg, unsigned int sgcount,
-		 unsigned int dma_length, unsigned int dev_addr,
-		 enum dma_transfer_direction direction)
-{
-	struct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);
-	int channel = imxdmac->channel;
-
-	if (imxdmac->internal.in_use)
-		return -EBUSY;
-
-	imxdmac->internal.sg = sg;
-	imxdmac->internal.resbytes = dma_length;
-
-	if (!sg || !sgcount) {
-		printk(KERN_ERR "imxdma%d: imx_dma_setup_sg empty sg list\n",
-		       channel);
-		return -EINVAL;
-	}
-
-	if (!sg->length) {
-		printk(KERN_ERR "imxdma%d: imx_dma_setup_sg zero length\n",
-		       channel);
-		return -EINVAL;
-	}
-
-	if (direction == DMA_DEV_TO_MEM) {
-		pr_debug("imxdma%d: %s sg=%p sgcount=%d total length=%d "
-			"dev_addr=0x%08x for read\n",
-			channel, __func__, sg, sgcount, dma_length, dev_addr);
-
-		imx_dmav1_writel(dev_addr, DMA_SAR(channel));
-		imx_dmav1_writel(imxdmac->internal.ccr_from_device, DMA_CCR(channel));
-	} else if (direction == DMA_MEM_TO_DEV) {
-		pr_debug("imxdma%d: %s sg=%p sgcount=%d total length=%d "
-			"dev_addr=0x%08x for write\n",
-			channel, __func__, sg, sgcount, dma_length, dev_addr);
-
-		imx_dmav1_writel(dev_addr, DMA_DAR(channel));
-		imx_dmav1_writel(imxdmac->internal.ccr_to_device, DMA_CCR(channel));
-	} else {
-		printk(KERN_ERR "imxdma%d: imx_dma_setup_sg bad dmamode\n",
-		       channel);
-		return -EINVAL;
-	}
-
-	imxdma_sg_next(d, sg);
-
-	return 0;
-}
-
 static void imxdma_watchdog(unsigned long data)
 {
 	struct imxdma_channel *imxdmac = (struct imxdma_channel *)data;
@@ -526,7 +473,6 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);
 	struct imxdma_engine *imxdma = imxdmac->imxdma;
-	int ret;
 
 	/* Configure and enable */
 	switch (d->type) {
@@ -548,10 +494,37 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 	/* Cyclic transfer is the same as slave_sg with special sg configuration. */
 	case IMXDMA_DESC_CYCLIC:
 	case IMXDMA_DESC_SLAVE_SG:
-		ret = imxdma_setup_sg_hw(d, d->sg, d->sgcount, d->len,
-					 imxdmac->per_address, d->direction);
-		if (ret < 0)
-			return ret;
+		imxdmac->internal.sg = d->sg;
+		imxdmac->internal.resbytes = d->len;
+
+		if (d->direction == DMA_DEV_TO_MEM) {
+			imx_dmav1_writel(imxdmac->per_address,
+					 DMA_SAR(imxdmac->channel));
+			imx_dmav1_writel(imxdmac->ccr_from_device,
+					 DMA_CCR(imxdmac->channel));
+
+			dev_dbg(imxdma->dev, "%s channel: %d sg=%p sgcount=%d "
+				"total length=%d dev_addr=0x%08x (dev2mem)\n",
+				__func__, imxdmac->channel, d->sg, d->sgcount,
+				d->len, imxdmac->per_address);
+		} else if (d->direction == DMA_MEM_TO_DEV) {
+			imx_dmav1_writel(imxdmac->per_address,
+					 DMA_DAR(imxdmac->channel));
+			imx_dmav1_writel(imxdmac->ccr_to_device,
+					 DMA_CCR(imxdmac->channel));
+
+			dev_dbg(imxdma->dev, "%s channel: %d sg=%p sgcount=%d "
+				"total length=%d dev_addr=0x%08x (mem2dev)\n",
+				__func__, imxdmac->channel, d->sg, d->sgcount,
+				d->len, imxdmac->per_address);
+		} else {
+			dev_err(imxdma->dev, "%s channel: %d bad dma mode\n",
+				__func__, imxdmac->channel);
+			return -EINVAL;
+		}
+
+		imxdma_sg_next(d, d->sg);
+
 		break;
 	default:
 		return -EINVAL;
@@ -641,11 +614,10 @@ static int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 		imxdmac->internal.hw_chaining = 1;
 		if (!imxdma_hw_chain(&imxdmac->internal))
 			return -EINVAL;
-		imxdmac->internal.ccr_from_device =
-			(mode | IMX_DMA_TYPE_FIFO) |
+		imxdmac->ccr_from_device = (mode | IMX_DMA_TYPE_FIFO) |
 			((IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR) << 2) |
 			CCR_REN;
-		imxdmac->internal.ccr_to_device =
+		imxdmac->ccr_to_device =
 			(IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR) |
 			((mode | IMX_DMA_TYPE_FIFO) << 2) | CCR_REN;
 		imx_dmav1_writel(imxdmac->dma_request,

commit bdc0c7534c80c479b2336aed3e4016f4743f4853
Author: Javier Martin <javier.martin@vista-silicon.com>
Date:   Thu Mar 22 14:54:05 2012 +0100

    dmaengine: imx-dma: remove 'imxdma_config_channel_hw' function.
    
    This function is only used once in the driver and uses some
    intermediary variables that are not needed anymore. For this
    reason it's been merged with 'imxdma_control'.
    
    Signed-off-by: Javier Martin <javier.martin@vista-silicon.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index dcb2c70aec7a..25b4108f6224 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -313,32 +313,6 @@ static void imxdma_disable_hw(struct imxdma_channel *imxdmac)
 	local_irq_restore(flags);
 }
 
-static int
-imxdma_config_channel_hw(struct imxdma_channel *imxdmac, unsigned int config_port,
-	unsigned int config_mem, unsigned int dmareq, int hw_chaining)
-{
-	int channel = imxdmac->channel;
-	u32 dreq = 0;
-
-	imxdmac->internal.hw_chaining = 0;
-
-	if (hw_chaining) {
-		imxdmac->internal.hw_chaining = 1;
-		if (!imxdma_hw_chain(&imxdmac->internal))
-			return -EINVAL;
-	}
-
-	if (dmareq)
-		dreq = CCR_REN;
-
-	imxdmac->internal.ccr_from_device = config_port | (config_mem << 2) | dreq;
-	imxdmac->internal.ccr_to_device = config_mem | (config_port << 2) | dreq;
-
-	imx_dmav1_writel(dmareq, DMA_RSSR(channel));
-
-	return 0;
-}
-
 static int
 imxdma_setup_sg_hw(struct imxdma_desc *d,
 		 struct scatterlist *sg, unsigned int sgcount,
@@ -628,7 +602,6 @@ static int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
 	struct dma_slave_config *dmaengine_cfg = (void *)arg;
-	int ret;
 	unsigned long flags;
 	unsigned int mode = 0;
 
@@ -664,13 +637,20 @@ static int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 			mode = IMX_DMA_MEMSIZE_32;
 			break;
 		}
-		ret = imxdma_config_channel_hw(imxdmac,
-				mode | IMX_DMA_TYPE_FIFO,
-				IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR,
-				imxdmac->dma_request, 1);
 
-		if (ret)
-			return ret;
+		imxdmac->internal.hw_chaining = 1;
+		if (!imxdma_hw_chain(&imxdmac->internal))
+			return -EINVAL;
+		imxdmac->internal.ccr_from_device =
+			(mode | IMX_DMA_TYPE_FIFO) |
+			((IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR) << 2) |
+			CCR_REN;
+		imxdmac->internal.ccr_to_device =
+			(IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR) |
+			((mode | IMX_DMA_TYPE_FIFO) << 2) | CCR_REN;
+		imx_dmav1_writel(imxdmac->dma_request,
+				 DMA_RSSR(imxdmac->channel));
+
 		/* Set burst length */
 		imx_dmav1_writel(imxdmac->watermark_level * imxdmac->word_size,
 				 DMA_BLR(imxdmac->channel));

commit 3b4b6dfc202dc5bedb03f2fae4ccc3f5b95dd563
Author: Javier Martin <javier.martin@vista-silicon.com>
Date:   Thu Mar 22 14:54:04 2012 +0100

    dmaengine: imx-dma: remove 'imxdma_setup_mem2mem_hw' function.
    
    This function is only used once in the driver and has a lot of checks
    that are not needed anymore. For this reason it's been merged
    with 'imxdma_enable_hw'.
    
    Signed-off-by: Javier Martin <javier.martin@vista-silicon.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 04a2c1446dc2..dcb2c70aec7a 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -260,41 +260,6 @@ static inline int imxdma_sg_next(struct imxdma_desc *d, struct scatterlist *sg)
 	return now;
 }
 
-static int
-imxdma_setup_mem2mem_hw(struct imxdma_channel *imxdmac, dma_addr_t dma_address,
-		     unsigned int dma_length, unsigned int dev_addr)
-{
-	int channel = imxdmac->channel;
-
-	imxdmac->internal.sg = NULL;
-
-	if (!dma_address) {
-		printk(KERN_ERR "imxdma%d: imx_dma_setup_single null address\n",
-		       channel);
-		return -EINVAL;
-	}
-
-	if (!dma_length) {
-		printk(KERN_ERR "imxdma%d: imx_dma_setup_single zero length\n",
-		       channel);
-		return -EINVAL;
-	}
-
-	pr_debug("imxdma%d: %s dma_addressg=0x%08x dma_length=%d "
-		"dev_addr=0x%08x for write\n",
-		channel, __func__, (unsigned int)dma_address,
-		dma_length, dev_addr);
-
-	imx_dmav1_writel(dma_address, DMA_SAR(channel));
-	imx_dmav1_writel(dev_addr, DMA_DAR(channel));
-	imx_dmav1_writel(imxdmac->internal.ccr_to_device,
-			 DMA_CCR(channel));
-
-	imx_dmav1_writel(dma_length, DMA_CNTR(channel));
-
-	return 0;
-}
-
 static void imxdma_enable_hw(struct imxdma_desc *d)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);
@@ -586,20 +551,26 @@ static irqreturn_t dma_irq_handler(int irq, void *dev_id)
 static int imxdma_xfer_desc(struct imxdma_desc *d)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);
+	struct imxdma_engine *imxdma = imxdmac->imxdma;
 	int ret;
 
 	/* Configure and enable */
 	switch (d->type) {
 	case IMXDMA_DESC_MEMCPY:
-		ret = imxdma_config_channel_hw(imxdmac,
-					  d->config_port, d->config_mem, 0, 0);
-		if (ret < 0)
-			return ret;
-		ret = imxdma_setup_mem2mem_hw(imxdmac, d->src, d->len, d->dest);
-		if (ret < 0)
-			return ret;
-		break;
+		imxdmac->internal.sg = NULL;
+
+		imx_dmav1_writel(d->src, DMA_SAR(imxdmac->channel));
+		imx_dmav1_writel(d->dest, DMA_DAR(imxdmac->channel));
+		imx_dmav1_writel(d->config_mem | (d->config_port << 2),
+			 DMA_CCR(imxdmac->channel));
 
+		imx_dmav1_writel(d->len, DMA_CNTR(imxdmac->channel));
+
+		dev_dbg(imxdma->dev, "%s channel: %d dest=0x%08x src=0x%08x "
+			"dma_length=%d\n", __func__, imxdmac->channel,
+			d->dest, d->src, d->len);
+
+		break;
 	/* Cyclic transfer is the same as slave_sg with special sg configuration. */
 	case IMXDMA_DESC_CYCLIC:
 	case IMXDMA_DESC_SLAVE_SG:

commit 2efc3449d7b11f36f532180cb738364fd2c28e03
Author: Javier Martin <javier.martin@vista-silicon.com>
Date:   Thu Mar 22 14:54:03 2012 +0100

    dmaengine: imx-dma: remove dma_mode member of internal structure.
    
    dmaengine now provides 'enum dma_transfer_direction' to properly
    specify DMA transfer direction. For this reason, DMA_MODE_* defines
    are replaced by this new type and therefore dma_mode member becomes
    redundant.
    
    Signed-off-by: Javier Martin <javier.martin@vista-silicon.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 8603c75b0e1b..04a2c1446dc2 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -36,10 +36,6 @@
 #define IMXDMA_MAX_CHAN_DESCRIPTORS	16
 #define IMX_DMA_CHANNELS  16
 
-#define DMA_MODE_READ		0
-#define DMA_MODE_WRITE		1
-#define DMA_MODE_MASK		1
-
 #define IMX_DMA_LENGTH_LOOP	((unsigned int)-1)
 #define IMX_DMA_MEMSIZE_32	(0 << 4)
 #define IMX_DMA_MEMSIZE_8	(1 << 4)
@@ -133,7 +129,6 @@ enum  imxdma_prep_type {
  */
 
 struct imxdma_channel_internal {
-	unsigned int dma_mode;
 	struct scatterlist *sg;
 	unsigned int resbytes;
 
@@ -154,7 +149,7 @@ struct imxdma_desc {
 	dma_addr_t			src;
 	dma_addr_t			dest;
 	size_t				len;
-	unsigned int			dmamode;
+	enum dma_transfer_direction	direction;
 	enum imxdma_prep_type		type;
 	/* For memcpy and interleaved */
 	unsigned int			config_port;
@@ -239,8 +234,9 @@ static int imxdma_hw_chain(struct imxdma_channel_internal *imxdma)
 /*
  * imxdma_sg_next - prepare next chunk for scatter-gather DMA emulation
  */
-static inline int imxdma_sg_next(struct imxdma_channel *imxdmac, struct scatterlist *sg)
+static inline int imxdma_sg_next(struct imxdma_desc *d, struct scatterlist *sg)
 {
+	struct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);
 	struct imxdma_channel_internal *imxdma = &imxdmac->internal;
 	unsigned long now;
 
@@ -248,7 +244,7 @@ static inline int imxdma_sg_next(struct imxdma_channel *imxdmac, struct scatterl
 	if (imxdma->resbytes != IMX_DMA_LENGTH_LOOP)
 		imxdma->resbytes -= now;
 
-	if ((imxdma->dma_mode & DMA_MODE_MASK) == DMA_MODE_READ)
+	if (d->direction == DMA_DEV_TO_MEM)
 		imx_dmav1_writel(sg->dma_address, DMA_DAR(imxdmac->channel));
 	else
 		imx_dmav1_writel(sg->dma_address, DMA_SAR(imxdmac->channel));
@@ -265,14 +261,12 @@ static inline int imxdma_sg_next(struct imxdma_channel *imxdmac, struct scatterl
 }
 
 static int
-imxdma_setup_single_hw(struct imxdma_channel *imxdmac, dma_addr_t dma_address,
-		     unsigned int dma_length, unsigned int dev_addr,
-		     unsigned int dmamode)
+imxdma_setup_mem2mem_hw(struct imxdma_channel *imxdmac, dma_addr_t dma_address,
+		     unsigned int dma_length, unsigned int dev_addr)
 {
 	int channel = imxdmac->channel;
 
 	imxdmac->internal.sg = NULL;
-	imxdmac->internal.dma_mode = dmamode;
 
 	if (!dma_address) {
 		printk(KERN_ERR "imxdma%d: imx_dma_setup_single null address\n",
@@ -286,38 +280,24 @@ imxdma_setup_single_hw(struct imxdma_channel *imxdmac, dma_addr_t dma_address,
 		return -EINVAL;
 	}
 
-	if ((dmamode & DMA_MODE_MASK) == DMA_MODE_READ) {
-		pr_debug("imxdma%d: %s dma_addressg=0x%08x dma_length=%d "
-			"dev_addr=0x%08x for read\n",
-			channel, __func__, (unsigned int)dma_address,
-			dma_length, dev_addr);
+	pr_debug("imxdma%d: %s dma_addressg=0x%08x dma_length=%d "
+		"dev_addr=0x%08x for write\n",
+		channel, __func__, (unsigned int)dma_address,
+		dma_length, dev_addr);
 
-		imx_dmav1_writel(dev_addr, DMA_SAR(channel));
-		imx_dmav1_writel(dma_address, DMA_DAR(channel));
-		imx_dmav1_writel(imxdmac->internal.ccr_from_device, DMA_CCR(channel));
-	} else if ((dmamode & DMA_MODE_MASK) == DMA_MODE_WRITE) {
-		pr_debug("imxdma%d: %s dma_addressg=0x%08x dma_length=%d "
-			"dev_addr=0x%08x for write\n",
-			channel, __func__, (unsigned int)dma_address,
-			dma_length, dev_addr);
-
-		imx_dmav1_writel(dma_address, DMA_SAR(channel));
-		imx_dmav1_writel(dev_addr, DMA_DAR(channel));
-		imx_dmav1_writel(imxdmac->internal.ccr_to_device,
-				DMA_CCR(channel));
-	} else {
-		printk(KERN_ERR "imxdma%d: imx_dma_setup_single bad dmamode\n",
-		       channel);
-		return -EINVAL;
-	}
+	imx_dmav1_writel(dma_address, DMA_SAR(channel));
+	imx_dmav1_writel(dev_addr, DMA_DAR(channel));
+	imx_dmav1_writel(imxdmac->internal.ccr_to_device,
+			 DMA_CCR(channel));
 
 	imx_dmav1_writel(dma_length, DMA_CNTR(channel));
 
 	return 0;
 }
 
-static void imxdma_enable_hw(struct imxdma_channel *imxdmac)
+static void imxdma_enable_hw(struct imxdma_desc *d)
 {
+	struct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);
 	int channel = imxdmac->channel;
 	unsigned long flags;
 
@@ -338,7 +318,7 @@ static void imxdma_enable_hw(struct imxdma_channel *imxdmac)
 		imxdmac->internal.sg = sg_next(imxdmac->internal.sg);
 		if (imxdmac->internal.sg) {
 			u32 tmp;
-			imxdma_sg_next(imxdmac, imxdmac->internal.sg);
+			imxdma_sg_next(d, imxdmac->internal.sg);
 			tmp = imx_dmav1_readl(DMA_CCR(channel));
 			imx_dmav1_writel(tmp | CCR_RPT | CCR_ACRPT,
 				DMA_CCR(channel));
@@ -395,18 +375,18 @@ imxdma_config_channel_hw(struct imxdma_channel *imxdmac, unsigned int config_por
 }
 
 static int
-imxdma_setup_sg_hw(struct imxdma_channel *imxdmac,
+imxdma_setup_sg_hw(struct imxdma_desc *d,
 		 struct scatterlist *sg, unsigned int sgcount,
 		 unsigned int dma_length, unsigned int dev_addr,
-		 unsigned int dmamode)
+		 enum dma_transfer_direction direction)
 {
+	struct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);
 	int channel = imxdmac->channel;
 
 	if (imxdmac->internal.in_use)
 		return -EBUSY;
 
 	imxdmac->internal.sg = sg;
-	imxdmac->internal.dma_mode = dmamode;
 	imxdmac->internal.resbytes = dma_length;
 
 	if (!sg || !sgcount) {
@@ -421,14 +401,14 @@ imxdma_setup_sg_hw(struct imxdma_channel *imxdmac,
 		return -EINVAL;
 	}
 
-	if ((dmamode & DMA_MODE_MASK) == DMA_MODE_READ) {
+	if (direction == DMA_DEV_TO_MEM) {
 		pr_debug("imxdma%d: %s sg=%p sgcount=%d total length=%d "
 			"dev_addr=0x%08x for read\n",
 			channel, __func__, sg, sgcount, dma_length, dev_addr);
 
 		imx_dmav1_writel(dev_addr, DMA_SAR(channel));
 		imx_dmav1_writel(imxdmac->internal.ccr_from_device, DMA_CCR(channel));
-	} else if ((dmamode & DMA_MODE_MASK) == DMA_MODE_WRITE) {
+	} else if (direction == DMA_MEM_TO_DEV) {
 		pr_debug("imxdma%d: %s sg=%p sgcount=%d total length=%d "
 			"dev_addr=0x%08x for write\n",
 			channel, __func__, sg, sgcount, dma_length, dev_addr);
@@ -441,7 +421,7 @@ imxdma_setup_sg_hw(struct imxdma_channel *imxdmac,
 		return -EINVAL;
 	}
 
-	imxdma_sg_next(imxdmac, sg);
+	imxdma_sg_next(d, sg);
 
 	return 0;
 }
@@ -519,13 +499,26 @@ static void dma_irq_handle_channel(struct imxdma_channel *imxdmac)
 {
 	struct imxdma_channel_internal *imxdma = &imxdmac->internal;
 	int chno = imxdmac->channel;
+	struct imxdma_desc *desc;
 
 	if (imxdma->sg) {
 		u32 tmp;
 		imxdma->sg = sg_next(imxdma->sg);
 
 		if (imxdma->sg) {
-			imxdma_sg_next(imxdmac, imxdma->sg);
+
+			spin_lock(&imxdmac->lock);
+			if (list_empty(&imxdmac->ld_active)) {
+				spin_unlock(&imxdmac->lock);
+				goto out;
+			}
+
+			desc = list_first_entry(&imxdmac->ld_active,
+						struct imxdma_desc,
+						node);
+			spin_unlock(&imxdmac->lock);
+
+			imxdma_sg_next(desc, imxdma->sg);
 
 			tmp = imx_dmav1_readl(DMA_CCR(chno));
 
@@ -558,6 +551,7 @@ static void dma_irq_handle_channel(struct imxdma_channel *imxdmac)
 		}
 	}
 
+out:
 	imx_dmav1_writel(0, DMA_CCR(chno));
 	imxdma->in_use = 0;
 	/* Tasklet irq */
@@ -601,8 +595,7 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 					  d->config_port, d->config_mem, 0, 0);
 		if (ret < 0)
 			return ret;
-		ret = imxdma_setup_single_hw(imxdmac, d->src,
-					   d->len, d->dest, d->dmamode);
+		ret = imxdma_setup_mem2mem_hw(imxdmac, d->src, d->len, d->dest);
 		if (ret < 0)
 			return ret;
 		break;
@@ -610,19 +603,15 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 	/* Cyclic transfer is the same as slave_sg with special sg configuration. */
 	case IMXDMA_DESC_CYCLIC:
 	case IMXDMA_DESC_SLAVE_SG:
-		if (d->dmamode == DMA_MODE_READ)
-			ret = imxdma_setup_sg_hw(imxdmac, d->sg,
-				       d->sgcount, d->len, d->src, d->dmamode);
-		else
-			ret = imxdma_setup_sg_hw(imxdmac, d->sg,
-				      d->sgcount, d->len, d->dest, d->dmamode);
+		ret = imxdma_setup_sg_hw(d, d->sg, d->sgcount, d->len,
+					 imxdmac->per_address, d->direction);
 		if (ret < 0)
 			return ret;
 		break;
 	default:
 		return -EINVAL;
 	}
-	imxdma_enable_hw(imxdmac);
+	imxdma_enable_hw(d);
 	return 0;
 }
 
@@ -839,11 +828,10 @@ static struct dma_async_tx_descriptor *imxdma_prep_slave_sg(
 	desc->sg = sgl;
 	desc->sgcount = sg_len;
 	desc->len = dma_length;
+	desc->direction = direction;
 	if (direction == DMA_DEV_TO_MEM) {
-		desc->dmamode = DMA_MODE_READ;
 		desc->src = imxdmac->per_address;
 	} else {
-		desc->dmamode = DMA_MODE_WRITE;
 		desc->dest = imxdmac->per_address;
 	}
 	desc->desc.callback = NULL;
@@ -900,11 +888,10 @@ static struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(
 	desc->sg = imxdmac->sg_list;
 	desc->sgcount = periods;
 	desc->len = IMX_DMA_LENGTH_LOOP;
+	desc->direction = direction;
 	if (direction == DMA_DEV_TO_MEM) {
-		desc->dmamode = DMA_MODE_READ;
 		desc->src = imxdmac->per_address;
 	} else {
-		desc->dmamode = DMA_MODE_WRITE;
 		desc->dest = imxdmac->per_address;
 	}
 	desc->desc.callback = NULL;
@@ -934,7 +921,7 @@ static struct dma_async_tx_descriptor *imxdma_prep_dma_memcpy(
 	desc->src = src;
 	desc->dest = dest;
 	desc->len = len;
-	desc->dmamode = DMA_MODE_WRITE;
+	desc->direction = DMA_MEM_TO_MEM;
 	desc->config_port = IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR;
 	desc->config_mem = IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR;
 	desc->desc.callback = NULL;

commit 232e3c2c7961fb3312a80df3747f1c29f0ed512e
Author: Javier Martin <javier.martin@vista-silicon.com>
Date:   Thu Mar 22 14:54:02 2012 +0100

    dmaengine: imx-dma: remove data member from internal structure.
    
    Internal structure is just an auxiliary structure used for the initial
    merge which is meant to be gone. As data member is not use anywhere
    we can simply remove it.
    
    Signed-off-by: Javier Martin <javier.martin@vista-silicon.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index fbb1aaad6128..8603c75b0e1b 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -133,7 +133,6 @@ enum  imxdma_prep_type {
  */
 
 struct imxdma_channel_internal {
-	void *data;
 	unsigned int dma_mode;
 	struct scatterlist *sg;
 	unsigned int resbytes;

commit 6bd081277ea03e2b165fc68534b61bc64db93990
Author: Javier Martin <javier.martin@vista-silicon.com>
Date:   Thu Mar 22 14:54:01 2012 +0100

    dmaengine: imx-dma: merge old dma-v1.c with imx-dma.c
    
    It is mainly a simple merge changing the prefix of some
    functions to fit the imx-dma namings.
    
    As there are no users of the old dma-v1.c api we can safely
    remove this file.
    
    Signed-off-by: Javier Martin <javier.martin@vista-silicon.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 304839a99ae5..fbb1aaad6128 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -14,7 +14,6 @@
  * http://www.opensource.org/licenses/gpl-license.html
  * http://www.gnu.org/copyleft/gpl.html
  */
-
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/types.h>
@@ -25,15 +24,89 @@
 #include <linux/dma-mapping.h>
 #include <linux/slab.h>
 #include <linux/platform_device.h>
+#include <linux/clk.h>
 #include <linux/dmaengine.h>
 #include <linux/module.h>
 
 #include <asm/irq.h>
-#include <mach/dma-v1.h>
+#include <mach/dma.h>
 #include <mach/hardware.h>
 
 #include "dmaengine.h"
 #define IMXDMA_MAX_CHAN_DESCRIPTORS	16
+#define IMX_DMA_CHANNELS  16
+
+#define DMA_MODE_READ		0
+#define DMA_MODE_WRITE		1
+#define DMA_MODE_MASK		1
+
+#define IMX_DMA_LENGTH_LOOP	((unsigned int)-1)
+#define IMX_DMA_MEMSIZE_32	(0 << 4)
+#define IMX_DMA_MEMSIZE_8	(1 << 4)
+#define IMX_DMA_MEMSIZE_16	(2 << 4)
+#define IMX_DMA_TYPE_LINEAR	(0 << 10)
+#define IMX_DMA_TYPE_2D		(1 << 10)
+#define IMX_DMA_TYPE_FIFO	(2 << 10)
+
+#define IMX_DMA_ERR_BURST     (1 << 0)
+#define IMX_DMA_ERR_REQUEST   (1 << 1)
+#define IMX_DMA_ERR_TRANSFER  (1 << 2)
+#define IMX_DMA_ERR_BUFFER    (1 << 3)
+#define IMX_DMA_ERR_TIMEOUT   (1 << 4)
+
+#define DMA_DCR     0x00		/* Control Register */
+#define DMA_DISR    0x04		/* Interrupt status Register */
+#define DMA_DIMR    0x08		/* Interrupt mask Register */
+#define DMA_DBTOSR  0x0c		/* Burst timeout status Register */
+#define DMA_DRTOSR  0x10		/* Request timeout Register */
+#define DMA_DSESR   0x14		/* Transfer Error Status Register */
+#define DMA_DBOSR   0x18		/* Buffer overflow status Register */
+#define DMA_DBTOCR  0x1c		/* Burst timeout control Register */
+#define DMA_WSRA    0x40		/* W-Size Register A */
+#define DMA_XSRA    0x44		/* X-Size Register A */
+#define DMA_YSRA    0x48		/* Y-Size Register A */
+#define DMA_WSRB    0x4c		/* W-Size Register B */
+#define DMA_XSRB    0x50		/* X-Size Register B */
+#define DMA_YSRB    0x54		/* Y-Size Register B */
+#define DMA_SAR(x)  (0x80 + ((x) << 6))	/* Source Address Registers */
+#define DMA_DAR(x)  (0x84 + ((x) << 6))	/* Destination Address Registers */
+#define DMA_CNTR(x) (0x88 + ((x) << 6))	/* Count Registers */
+#define DMA_CCR(x)  (0x8c + ((x) << 6))	/* Control Registers */
+#define DMA_RSSR(x) (0x90 + ((x) << 6))	/* Request source select Registers */
+#define DMA_BLR(x)  (0x94 + ((x) << 6))	/* Burst length Registers */
+#define DMA_RTOR(x) (0x98 + ((x) << 6))	/* Request timeout Registers */
+#define DMA_BUCR(x) (0x98 + ((x) << 6))	/* Bus Utilization Registers */
+#define DMA_CCNR(x) (0x9C + ((x) << 6))	/* Channel counter Registers */
+
+#define DCR_DRST           (1<<1)
+#define DCR_DEN            (1<<0)
+#define DBTOCR_EN          (1<<15)
+#define DBTOCR_CNT(x)      ((x) & 0x7fff)
+#define CNTR_CNT(x)        ((x) & 0xffffff)
+#define CCR_ACRPT          (1<<14)
+#define CCR_DMOD_LINEAR    (0x0 << 12)
+#define CCR_DMOD_2D        (0x1 << 12)
+#define CCR_DMOD_FIFO      (0x2 << 12)
+#define CCR_DMOD_EOBFIFO   (0x3 << 12)
+#define CCR_SMOD_LINEAR    (0x0 << 10)
+#define CCR_SMOD_2D        (0x1 << 10)
+#define CCR_SMOD_FIFO      (0x2 << 10)
+#define CCR_SMOD_EOBFIFO   (0x3 << 10)
+#define CCR_MDIR_DEC       (1<<9)
+#define CCR_MSEL_B         (1<<8)
+#define CCR_DSIZ_32        (0x0 << 6)
+#define CCR_DSIZ_8         (0x1 << 6)
+#define CCR_DSIZ_16        (0x2 << 6)
+#define CCR_SSIZ_32        (0x0 << 4)
+#define CCR_SSIZ_8         (0x1 << 4)
+#define CCR_SSIZ_16        (0x2 << 4)
+#define CCR_REN            (1<<3)
+#define CCR_RPT            (1<<2)
+#define CCR_FRC            (1<<1)
+#define CCR_CEN            (1<<0)
+#define RTOR_EN            (1<<15)
+#define RTOR_CLK           (1<<14)
+#define RTOR_PSC           (1<<13)
 
 enum  imxdma_prep_type {
 	IMXDMA_DESC_MEMCPY,
@@ -42,6 +115,39 @@ enum  imxdma_prep_type {
 	IMXDMA_DESC_CYCLIC,
 };
 
+/*
+ * struct imxdma_channel_internal - i.MX specific DMA extension
+ * @name: name specified by DMA client
+ * @irq_handler: client callback for end of transfer
+ * @err_handler: client callback for error condition
+ * @data: clients context data for callbacks
+ * @dma_mode: direction of the transfer %DMA_MODE_READ or %DMA_MODE_WRITE
+ * @sg: pointer to the actual read/written chunk for scatter-gather emulation
+ * @resbytes: total residual number of bytes to transfer
+ *            (it can be lower or same as sum of SG mapped chunk sizes)
+ * @sgcount: number of chunks to be read/written
+ *
+ * Structure is used for IMX DMA processing. It would be probably good
+ * @struct dma_struct in the future for external interfacing and use
+ * @struct imxdma_channel_internal only as extension to it.
+ */
+
+struct imxdma_channel_internal {
+	void *data;
+	unsigned int dma_mode;
+	struct scatterlist *sg;
+	unsigned int resbytes;
+
+	int in_use;
+
+	u32 ccr_from_device;
+	u32 ccr_to_device;
+
+	struct timer_list watchdog;
+
+	int hw_chaining;
+};
+
 struct imxdma_desc {
 	struct list_head		node;
 	struct dma_async_tx_descriptor	desc;
@@ -64,9 +170,9 @@ struct imxdma_desc {
 };
 
 struct imxdma_channel {
+	struct imxdma_channel_internal	internal;
 	struct imxdma_engine		*imxdma;
 	unsigned int			channel;
-	unsigned int			imxdma_channel;
 
 	struct tasklet_struct		dma_tasklet;
 	struct list_head		ld_free;
@@ -84,13 +190,11 @@ struct imxdma_channel {
 	struct scatterlist		*sg_list;
 };
 
-#define MAX_DMA_CHANNELS 8
-
 struct imxdma_engine {
 	struct device			*dev;
 	struct device_dma_parameters	dma_parms;
 	struct dma_device		dma_device;
-	struct imxdma_channel		channel[MAX_DMA_CHANNELS];
+	struct imxdma_channel		channel[IMX_DMA_CHANNELS];
 };
 
 static struct imxdma_channel *to_imxdma_chan(struct dma_chan *chan)
@@ -111,28 +215,381 @@ static inline bool imxdma_chan_is_doing_cyclic(struct imxdma_channel *imxdmac)
 	return false;
 }
 
-static void imxdma_irq_handler(int channel, void *data)
+/* TODO: put this inside any struct */
+static void __iomem *imx_dmav1_baseaddr;
+static struct clk *dma_clk;
+
+static void imx_dmav1_writel(unsigned val, unsigned offset)
+{
+	__raw_writel(val, imx_dmav1_baseaddr + offset);
+}
+
+static unsigned imx_dmav1_readl(unsigned offset)
 {
-	struct imxdma_channel *imxdmac = data;
+	return __raw_readl(imx_dmav1_baseaddr + offset);
+}
 
-	tasklet_schedule(&imxdmac->dma_tasklet);
+static int imxdma_hw_chain(struct imxdma_channel_internal *imxdma)
+{
+	if (cpu_is_mx27())
+		return imxdma->hw_chaining;
+	else
+		return 0;
+}
+
+/*
+ * imxdma_sg_next - prepare next chunk for scatter-gather DMA emulation
+ */
+static inline int imxdma_sg_next(struct imxdma_channel *imxdmac, struct scatterlist *sg)
+{
+	struct imxdma_channel_internal *imxdma = &imxdmac->internal;
+	unsigned long now;
+
+	now = min(imxdma->resbytes, sg->length);
+	if (imxdma->resbytes != IMX_DMA_LENGTH_LOOP)
+		imxdma->resbytes -= now;
+
+	if ((imxdma->dma_mode & DMA_MODE_MASK) == DMA_MODE_READ)
+		imx_dmav1_writel(sg->dma_address, DMA_DAR(imxdmac->channel));
+	else
+		imx_dmav1_writel(sg->dma_address, DMA_SAR(imxdmac->channel));
+
+	imx_dmav1_writel(now, DMA_CNTR(imxdmac->channel));
+
+	pr_debug("imxdma%d: next sg chunk dst 0x%08x, src 0x%08x, "
+		"size 0x%08x\n", imxdmac->channel,
+		 imx_dmav1_readl(DMA_DAR(imxdmac->channel)),
+		 imx_dmav1_readl(DMA_SAR(imxdmac->channel)),
+		 imx_dmav1_readl(DMA_CNTR(imxdmac->channel)));
+
+	return now;
+}
+
+static int
+imxdma_setup_single_hw(struct imxdma_channel *imxdmac, dma_addr_t dma_address,
+		     unsigned int dma_length, unsigned int dev_addr,
+		     unsigned int dmamode)
+{
+	int channel = imxdmac->channel;
+
+	imxdmac->internal.sg = NULL;
+	imxdmac->internal.dma_mode = dmamode;
+
+	if (!dma_address) {
+		printk(KERN_ERR "imxdma%d: imx_dma_setup_single null address\n",
+		       channel);
+		return -EINVAL;
+	}
+
+	if (!dma_length) {
+		printk(KERN_ERR "imxdma%d: imx_dma_setup_single zero length\n",
+		       channel);
+		return -EINVAL;
+	}
+
+	if ((dmamode & DMA_MODE_MASK) == DMA_MODE_READ) {
+		pr_debug("imxdma%d: %s dma_addressg=0x%08x dma_length=%d "
+			"dev_addr=0x%08x for read\n",
+			channel, __func__, (unsigned int)dma_address,
+			dma_length, dev_addr);
+
+		imx_dmav1_writel(dev_addr, DMA_SAR(channel));
+		imx_dmav1_writel(dma_address, DMA_DAR(channel));
+		imx_dmav1_writel(imxdmac->internal.ccr_from_device, DMA_CCR(channel));
+	} else if ((dmamode & DMA_MODE_MASK) == DMA_MODE_WRITE) {
+		pr_debug("imxdma%d: %s dma_addressg=0x%08x dma_length=%d "
+			"dev_addr=0x%08x for write\n",
+			channel, __func__, (unsigned int)dma_address,
+			dma_length, dev_addr);
+
+		imx_dmav1_writel(dma_address, DMA_SAR(channel));
+		imx_dmav1_writel(dev_addr, DMA_DAR(channel));
+		imx_dmav1_writel(imxdmac->internal.ccr_to_device,
+				DMA_CCR(channel));
+	} else {
+		printk(KERN_ERR "imxdma%d: imx_dma_setup_single bad dmamode\n",
+		       channel);
+		return -EINVAL;
+	}
+
+	imx_dmav1_writel(dma_length, DMA_CNTR(channel));
+
+	return 0;
+}
+
+static void imxdma_enable_hw(struct imxdma_channel *imxdmac)
+{
+	int channel = imxdmac->channel;
+	unsigned long flags;
+
+	pr_debug("imxdma%d: imx_dma_enable\n", channel);
+
+	if (imxdmac->internal.in_use)
+		return;
+
+	local_irq_save(flags);
+
+	imx_dmav1_writel(1 << channel, DMA_DISR);
+	imx_dmav1_writel(imx_dmav1_readl(DMA_DIMR) & ~(1 << channel), DMA_DIMR);
+	imx_dmav1_writel(imx_dmav1_readl(DMA_CCR(channel)) | CCR_CEN |
+		CCR_ACRPT, DMA_CCR(channel));
+
+	if ((cpu_is_mx21() || cpu_is_mx27()) &&
+			imxdmac->internal.sg && imxdma_hw_chain(&imxdmac->internal)) {
+		imxdmac->internal.sg = sg_next(imxdmac->internal.sg);
+		if (imxdmac->internal.sg) {
+			u32 tmp;
+			imxdma_sg_next(imxdmac, imxdmac->internal.sg);
+			tmp = imx_dmav1_readl(DMA_CCR(channel));
+			imx_dmav1_writel(tmp | CCR_RPT | CCR_ACRPT,
+				DMA_CCR(channel));
+		}
+	}
+	imxdmac->internal.in_use = 1;
+
+	local_irq_restore(flags);
+}
+
+static void imxdma_disable_hw(struct imxdma_channel *imxdmac)
+{
+	int channel = imxdmac->channel;
+	unsigned long flags;
+
+	pr_debug("imxdma%d: imx_dma_disable\n", channel);
+
+	if (imxdma_hw_chain(&imxdmac->internal))
+		del_timer(&imxdmac->internal.watchdog);
+
+	local_irq_save(flags);
+	imx_dmav1_writel(imx_dmav1_readl(DMA_DIMR) | (1 << channel), DMA_DIMR);
+	imx_dmav1_writel(imx_dmav1_readl(DMA_CCR(channel)) & ~CCR_CEN,
+			DMA_CCR(channel));
+	imx_dmav1_writel(1 << channel, DMA_DISR);
+	imxdmac->internal.in_use = 0;
+	local_irq_restore(flags);
+}
+
+static int
+imxdma_config_channel_hw(struct imxdma_channel *imxdmac, unsigned int config_port,
+	unsigned int config_mem, unsigned int dmareq, int hw_chaining)
+{
+	int channel = imxdmac->channel;
+	u32 dreq = 0;
+
+	imxdmac->internal.hw_chaining = 0;
+
+	if (hw_chaining) {
+		imxdmac->internal.hw_chaining = 1;
+		if (!imxdma_hw_chain(&imxdmac->internal))
+			return -EINVAL;
+	}
+
+	if (dmareq)
+		dreq = CCR_REN;
+
+	imxdmac->internal.ccr_from_device = config_port | (config_mem << 2) | dreq;
+	imxdmac->internal.ccr_to_device = config_mem | (config_port << 2) | dreq;
+
+	imx_dmav1_writel(dmareq, DMA_RSSR(channel));
+
+	return 0;
+}
+
+static int
+imxdma_setup_sg_hw(struct imxdma_channel *imxdmac,
+		 struct scatterlist *sg, unsigned int sgcount,
+		 unsigned int dma_length, unsigned int dev_addr,
+		 unsigned int dmamode)
+{
+	int channel = imxdmac->channel;
+
+	if (imxdmac->internal.in_use)
+		return -EBUSY;
+
+	imxdmac->internal.sg = sg;
+	imxdmac->internal.dma_mode = dmamode;
+	imxdmac->internal.resbytes = dma_length;
+
+	if (!sg || !sgcount) {
+		printk(KERN_ERR "imxdma%d: imx_dma_setup_sg empty sg list\n",
+		       channel);
+		return -EINVAL;
+	}
+
+	if (!sg->length) {
+		printk(KERN_ERR "imxdma%d: imx_dma_setup_sg zero length\n",
+		       channel);
+		return -EINVAL;
+	}
+
+	if ((dmamode & DMA_MODE_MASK) == DMA_MODE_READ) {
+		pr_debug("imxdma%d: %s sg=%p sgcount=%d total length=%d "
+			"dev_addr=0x%08x for read\n",
+			channel, __func__, sg, sgcount, dma_length, dev_addr);
+
+		imx_dmav1_writel(dev_addr, DMA_SAR(channel));
+		imx_dmav1_writel(imxdmac->internal.ccr_from_device, DMA_CCR(channel));
+	} else if ((dmamode & DMA_MODE_MASK) == DMA_MODE_WRITE) {
+		pr_debug("imxdma%d: %s sg=%p sgcount=%d total length=%d "
+			"dev_addr=0x%08x for write\n",
+			channel, __func__, sg, sgcount, dma_length, dev_addr);
+
+		imx_dmav1_writel(dev_addr, DMA_DAR(channel));
+		imx_dmav1_writel(imxdmac->internal.ccr_to_device, DMA_CCR(channel));
+	} else {
+		printk(KERN_ERR "imxdma%d: imx_dma_setup_sg bad dmamode\n",
+		       channel);
+		return -EINVAL;
+	}
+
+	imxdma_sg_next(imxdmac, sg);
+
+	return 0;
 }
 
-static void imxdma_err_handler(int channel, void *data, int error)
+static void imxdma_watchdog(unsigned long data)
 {
-	struct imxdma_channel *imxdmac = data;
+	struct imxdma_channel *imxdmac = (struct imxdma_channel *)data;
+	int channel = imxdmac->channel;
 
+	imx_dmav1_writel(0, DMA_CCR(channel));
+	imxdmac->internal.in_use = 0;
+	imxdmac->internal.sg = NULL;
+
+	/* Tasklet watchdog error handler */
 	tasklet_schedule(&imxdmac->dma_tasklet);
+	pr_debug("imxdma%d: watchdog timeout!\n", imxdmac->channel);
+}
+
+static irqreturn_t imxdma_err_handler(int irq, void *dev_id)
+{
+	struct imxdma_engine *imxdma = dev_id;
+	struct imxdma_channel_internal *internal;
+	unsigned int err_mask;
+	int i, disr;
+	int errcode;
+
+	disr = imx_dmav1_readl(DMA_DISR);
+
+	err_mask = imx_dmav1_readl(DMA_DBTOSR) |
+		   imx_dmav1_readl(DMA_DRTOSR) |
+		   imx_dmav1_readl(DMA_DSESR)  |
+		   imx_dmav1_readl(DMA_DBOSR);
+
+	if (!err_mask)
+		return IRQ_HANDLED;
+
+	imx_dmav1_writel(disr & err_mask, DMA_DISR);
+
+	for (i = 0; i < IMX_DMA_CHANNELS; i++) {
+		if (!(err_mask & (1 << i)))
+			continue;
+		internal = &imxdma->channel[i].internal;
+		errcode = 0;
+
+		if (imx_dmav1_readl(DMA_DBTOSR) & (1 << i)) {
+			imx_dmav1_writel(1 << i, DMA_DBTOSR);
+			errcode |= IMX_DMA_ERR_BURST;
+		}
+		if (imx_dmav1_readl(DMA_DRTOSR) & (1 << i)) {
+			imx_dmav1_writel(1 << i, DMA_DRTOSR);
+			errcode |= IMX_DMA_ERR_REQUEST;
+		}
+		if (imx_dmav1_readl(DMA_DSESR) & (1 << i)) {
+			imx_dmav1_writel(1 << i, DMA_DSESR);
+			errcode |= IMX_DMA_ERR_TRANSFER;
+		}
+		if (imx_dmav1_readl(DMA_DBOSR) & (1 << i)) {
+			imx_dmav1_writel(1 << i, DMA_DBOSR);
+			errcode |= IMX_DMA_ERR_BUFFER;
+		}
+		/* Tasklet error handler */
+		tasklet_schedule(&imxdma->channel[i].dma_tasklet);
+
+		printk(KERN_WARNING
+		       "DMA timeout on channel %d -%s%s%s%s\n", i,
+		       errcode & IMX_DMA_ERR_BURST ?    " burst" : "",
+		       errcode & IMX_DMA_ERR_REQUEST ?  " request" : "",
+		       errcode & IMX_DMA_ERR_TRANSFER ? " transfer" : "",
+		       errcode & IMX_DMA_ERR_BUFFER ?   " buffer" : "");
+	}
+	return IRQ_HANDLED;
 }
 
-static void imxdma_progression(int channel, void *data,
-		struct scatterlist *sg)
+static void dma_irq_handle_channel(struct imxdma_channel *imxdmac)
 {
-	struct imxdma_channel *imxdmac = data;
+	struct imxdma_channel_internal *imxdma = &imxdmac->internal;
+	int chno = imxdmac->channel;
+
+	if (imxdma->sg) {
+		u32 tmp;
+		imxdma->sg = sg_next(imxdma->sg);
+
+		if (imxdma->sg) {
+			imxdma_sg_next(imxdmac, imxdma->sg);
+
+			tmp = imx_dmav1_readl(DMA_CCR(chno));
+
+			if (imxdma_hw_chain(imxdma)) {
+				/* FIXME: The timeout should probably be
+				 * configurable
+				 */
+				mod_timer(&imxdma->watchdog,
+					jiffies + msecs_to_jiffies(500));
+
+				tmp |= CCR_CEN | CCR_RPT | CCR_ACRPT;
+				imx_dmav1_writel(tmp, DMA_CCR(chno));
+			} else {
+				imx_dmav1_writel(tmp & ~CCR_CEN, DMA_CCR(chno));
+				tmp |= CCR_CEN;
+			}
+
+			imx_dmav1_writel(tmp, DMA_CCR(chno));
+
+			if (imxdma_chan_is_doing_cyclic(imxdmac))
+				/* Tasklet progression */
+				tasklet_schedule(&imxdmac->dma_tasklet);
 
+			return;
+		}
+
+		if (imxdma_hw_chain(imxdma)) {
+			del_timer(&imxdma->watchdog);
+			return;
+		}
+	}
+
+	imx_dmav1_writel(0, DMA_CCR(chno));
+	imxdma->in_use = 0;
+	/* Tasklet irq */
 	tasklet_schedule(&imxdmac->dma_tasklet);
 }
 
+static irqreturn_t dma_irq_handler(int irq, void *dev_id)
+{
+	struct imxdma_engine *imxdma = dev_id;
+	struct imxdma_channel_internal *internal;
+	int i, disr;
+
+	if (cpu_is_mx21() || cpu_is_mx27())
+		imxdma_err_handler(irq, dev_id);
+
+	disr = imx_dmav1_readl(DMA_DISR);
+
+	pr_debug("imxdma: dma_irq_handler called, disr=0x%08x\n",
+		     disr);
+
+	imx_dmav1_writel(disr, DMA_DISR);
+	for (i = 0; i < IMX_DMA_CHANNELS; i++) {
+		if (disr & (1 << i)) {
+			internal = &imxdma->channel[i].internal;
+			dma_irq_handle_channel(&imxdma->channel[i]);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
 static int imxdma_xfer_desc(struct imxdma_desc *d)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);
@@ -141,31 +598,24 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 	/* Configure and enable */
 	switch (d->type) {
 	case IMXDMA_DESC_MEMCPY:
-		ret = imx_dma_config_channel(imxdmac->imxdma_channel,
+		ret = imxdma_config_channel_hw(imxdmac,
 					  d->config_port, d->config_mem, 0, 0);
 		if (ret < 0)
 			return ret;
-		ret = imx_dma_setup_single(imxdmac->imxdma_channel, d->src,
+		ret = imxdma_setup_single_hw(imxdmac, d->src,
 					   d->len, d->dest, d->dmamode);
 		if (ret < 0)
 			return ret;
 		break;
+
+	/* Cyclic transfer is the same as slave_sg with special sg configuration. */
 	case IMXDMA_DESC_CYCLIC:
-		ret = imx_dma_setup_progression_handler(imxdmac->imxdma_channel,
-							imxdma_progression);
-		if (ret < 0)
-			return ret;
-		/*
-		 * We fall through here since cyclic transfer is the same as
-		 * slave_sg adding a progression handler and a specific sg
-		 * configuration which is done in 'imxdma_prep_dma_cyclic'.
-		 */
 	case IMXDMA_DESC_SLAVE_SG:
 		if (d->dmamode == DMA_MODE_READ)
-			ret = imx_dma_setup_sg(imxdmac->imxdma_channel, d->sg,
+			ret = imxdma_setup_sg_hw(imxdmac, d->sg,
 				       d->sgcount, d->len, d->src, d->dmamode);
 		else
-			ret = imx_dma_setup_sg(imxdmac->imxdma_channel, d->sg,
+			ret = imxdma_setup_sg_hw(imxdmac, d->sg,
 				      d->sgcount, d->len, d->dest, d->dmamode);
 		if (ret < 0)
 			return ret;
@@ -173,7 +623,7 @@ static int imxdma_xfer_desc(struct imxdma_desc *d)
 	default:
 		return -EINVAL;
 	}
-	imx_dma_enable(imxdmac->imxdma_channel);
+	imxdma_enable_hw(imxdmac);
 	return 0;
 }
 
@@ -225,7 +675,7 @@ static int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 
 	switch (cmd) {
 	case DMA_TERMINATE_ALL:
-		imx_dma_disable(imxdmac->imxdma_channel);
+		imxdma_disable_hw(imxdmac);
 
 		spin_lock_irqsave(&imxdmac->lock, flags);
 		list_splice_tail_init(&imxdmac->ld_active, &imxdmac->ld_free);
@@ -255,16 +705,16 @@ static int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 			mode = IMX_DMA_MEMSIZE_32;
 			break;
 		}
-		ret = imx_dma_config_channel(imxdmac->imxdma_channel,
+		ret = imxdma_config_channel_hw(imxdmac,
 				mode | IMX_DMA_TYPE_FIFO,
 				IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR,
 				imxdmac->dma_request, 1);
 
 		if (ret)
 			return ret;
-
-		imx_dma_config_burstlen(imxdmac->imxdma_channel,
-				imxdmac->watermark_level * imxdmac->word_size);
+		/* Set burst length */
+		imx_dmav1_writel(imxdmac->watermark_level * imxdmac->word_size,
+				 DMA_BLR(imxdmac->channel));
 
 		return 0;
 	default:
@@ -333,7 +783,7 @@ static void imxdma_free_chan_resources(struct dma_chan *chan)
 
 	spin_lock_irqsave(&imxdmac->lock, flags);
 
-	imx_dma_disable(imxdmac->imxdma_channel);
+	imxdma_disable_hw(imxdmac);
 	list_splice_tail_init(&imxdmac->ld_active, &imxdmac->ld_free);
 	list_splice_tail_init(&imxdmac->ld_queue, &imxdmac->ld_free);
 
@@ -520,10 +970,51 @@ static void imxdma_issue_pending(struct dma_chan *chan)
 }
 
 static int __init imxdma_probe(struct platform_device *pdev)
-{
+	{
 	struct imxdma_engine *imxdma;
 	int ret, i;
 
+	if (cpu_is_mx1())
+		imx_dmav1_baseaddr = MX1_IO_ADDRESS(MX1_DMA_BASE_ADDR);
+	else if (cpu_is_mx21())
+		imx_dmav1_baseaddr = MX21_IO_ADDRESS(MX21_DMA_BASE_ADDR);
+	else if (cpu_is_mx27())
+		imx_dmav1_baseaddr = MX27_IO_ADDRESS(MX27_DMA_BASE_ADDR);
+	else
+		return 0;
+
+	dma_clk = clk_get(NULL, "dma");
+	if (IS_ERR(dma_clk))
+		return PTR_ERR(dma_clk);
+	clk_enable(dma_clk);
+
+	/* reset DMA module */
+	imx_dmav1_writel(DCR_DRST, DMA_DCR);
+
+	if (cpu_is_mx1()) {
+		ret = request_irq(MX1_DMA_INT, dma_irq_handler, 0, "DMA", imxdma);
+		if (ret) {
+			pr_crit("Can't register IRQ for DMA\n");
+			return ret;
+		}
+
+		ret = request_irq(MX1_DMA_ERR, imxdma_err_handler, 0, "DMA", imxdma);
+		if (ret) {
+			pr_crit("Can't register ERRIRQ for DMA\n");
+			free_irq(MX1_DMA_INT, NULL);
+			return ret;
+		}
+	}
+
+	/* enable DMA module */
+	imx_dmav1_writel(DCR_DEN, DMA_DCR);
+
+	/* clear all interrupts */
+	imx_dmav1_writel((1 << IMX_DMA_CHANNELS) - 1, DMA_DISR);
+
+	/* disable interrupts */
+	imx_dmav1_writel((1 << IMX_DMA_CHANNELS) - 1, DMA_DIMR);
+
 	imxdma = kzalloc(sizeof(*imxdma), GFP_KERNEL);
 	if (!imxdma)
 		return -ENOMEM;
@@ -535,19 +1026,22 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	dma_cap_set(DMA_MEMCPY, imxdma->dma_device.cap_mask);
 
 	/* Initialize channel parameters */
-	for (i = 0; i < MAX_DMA_CHANNELS; i++) {
+	for (i = 0; i < IMX_DMA_CHANNELS; i++) {
 		struct imxdma_channel *imxdmac = &imxdma->channel[i];
-
-		imxdmac->imxdma_channel = imx_dma_request_by_prio("dmaengine",
-				DMA_PRIO_MEDIUM);
-		if ((int)imxdmac->channel < 0) {
-			ret = -ENODEV;
-			goto err_init;
+		memset(&imxdmac->internal, 0, sizeof(imxdmac->internal));
+		if (cpu_is_mx21() || cpu_is_mx27()) {
+			ret = request_irq(MX2x_INT_DMACH0 + i,
+					dma_irq_handler, 0, "DMA", imxdma);
+			if (ret) {
+				pr_crit("Can't register IRQ %d for DMA channel %d\n",
+						MX2x_INT_DMACH0 + i, i);
+				goto err_init;
+			}
+			init_timer(&imxdmac->internal.watchdog);
+			imxdmac->internal.watchdog.function = &imxdma_watchdog;
+			imxdmac->internal.watchdog.data = (unsigned long)imxdmac;
 		}
 
-		imx_dma_setup_handlers(imxdmac->imxdma_channel,
-		       imxdma_irq_handler, imxdma_err_handler, imxdmac);
-
 		imxdmac->imxdma = imxdma;
 		spin_lock_init(&imxdmac->lock);
 
@@ -593,9 +1087,13 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	return 0;
 
 err_init:
-	while (--i >= 0) {
-		struct imxdma_channel *imxdmac = &imxdma->channel[i];
-		imx_dma_free(imxdmac->imxdma_channel);
+
+	if (cpu_is_mx21() || cpu_is_mx27()) {
+		while (--i >= 0)
+			free_irq(MX2x_INT_DMACH0 + i, NULL);
+	} else if cpu_is_mx1() {
+		free_irq(MX1_DMA_INT, NULL);
+		free_irq(MX1_DMA_ERR, NULL);
 	}
 
 	kfree(imxdma);
@@ -609,10 +1107,12 @@ static int __exit imxdma_remove(struct platform_device *pdev)
 
         dma_async_device_unregister(&imxdma->dma_device);
 
-	for (i = 0; i < MAX_DMA_CHANNELS; i++) {
-		struct imxdma_channel *imxdmac = &imxdma->channel[i];
-
-		 imx_dma_free(imxdmac->imxdma_channel);
+	if (cpu_is_mx21() || cpu_is_mx27()) {
+		for (i = 0; i < IMX_DMA_CHANNELS; i++)
+			free_irq(MX2x_INT_DMACH0 + i, NULL);
+	} else if cpu_is_mx1() {
+		free_irq(MX1_DMA_INT, NULL);
+		free_irq(MX1_DMA_ERR, NULL);
 	}
 
         kfree(imxdma);

commit 185ecb5f4fd43911c35956d4cc7d94a1da30417f
Author: Alexandre Bounine <alexandre.bounine@idt.com>
Date:   Thu Mar 8 15:35:13 2012 -0500

    dmaengine: add context parameter to prep_slave_sg and prep_dma_cyclic
    
    Add context parameter to device_prep_slave_sg() and device_prep_dma_cyclic()
    interfaces to allow passing client/target specific information associated
    with the data transfer.
    Modify all affected DMA engine drivers.
    
    Signed-off-by: Alexandre Bounine <alexandre.bounine@idt.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 20c1565a7486..304839a99ae5 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -354,7 +354,7 @@ static void imxdma_free_chan_resources(struct dma_chan *chan)
 static struct dma_async_tx_descriptor *imxdma_prep_slave_sg(
 		struct dma_chan *chan, struct scatterlist *sgl,
 		unsigned int sg_len, enum dma_transfer_direction direction,
-		unsigned long flags)
+		unsigned long flags, void *context)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
 	struct scatterlist *sg;
@@ -405,7 +405,8 @@ static struct dma_async_tx_descriptor *imxdma_prep_slave_sg(
 
 static struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(
 		struct dma_chan *chan, dma_addr_t dma_addr, size_t buf_len,
-		size_t period_len, enum dma_transfer_direction direction)
+		size_t period_len, enum dma_transfer_direction direction,
+		void *context)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
 	struct imxdma_engine *imxdma = imxdmac->imxdma;

commit 1f3d6dc0be92f0caca937926cca16ec4fdd585a3
Merge: 5170c051a562 949ff5b8d46b
Author: Vinod Koul <vinod.koul@linux.intel.com>
Date:   Tue Mar 13 12:39:49 2012 +0530

    Merge branch 'rmk_cookie_fixes2' into next
    
    Conflicts:
            drivers/dma/imx-dma.c
            drivers/dma/pl330.c
    
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

commit 8ac695463f37af902e953d575d3f782e32e170da
Author: Russell King - ARM Linux <linux@arm.linux.org.uk>
Date:   Tue Mar 6 22:36:27 2012 +0000

    dmaengine: ensure all DMA engine drivers initialize their cookies
    
    Ensure all DMA engine drivers initialize their cookies in the same way,
    so that they all behave in a similar fashion.  This means their first
    issued cookie will be 2 rather than 1, and will increment to INT_MAX
    before returning 1 and starting over.
    
    In connection with this, Dan Williams said:
    > Russell King wrote:
    > > Secondly, some DMA engine drivers initialize the dma_chan cookie to 0,
    > > others to 1.  Is there a reason for this, or are these all buggy?
    >
    > I know that ioat and iop-adma expect 0 to mean "I have cleaned up this
    > descriptor and it is idle", and would break if zero was an in-flight
    > cookie value.  The reserved usage of zero is an driver internal
    > concern, but I have no problem formalizing it as a reserved value.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Jassi Brar <jassisinghbrar@gmail.com>
    [imx-sdma.c & mxs-dma.c]
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 6731f1918c55..f0485c0a685a 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -347,6 +347,7 @@ static int __init imxdma_probe(struct platform_device *pdev)
 		spin_lock_init(&imxdmac->lock);
 
 		imxdmac->chan.device = &imxdma->dma_device;
+		dma_cookie_init(&imxdmac->chan);
 		imxdmac->channel = i;
 
 		/* Add the channel to the DMAC list */

commit 96a2af41c78b1fbb1f567a3486bdc63f7b31c5fd
Author: Russell King - ARM Linux <linux@arm.linux.org.uk>
Date:   Tue Mar 6 22:35:27 2012 +0000

    dmaengine: consolidate tx_status functions
    
    Now that we have the completed cookie in the dma_chan structure, we
    can consolidate the tx_status functions by providing a function to set
    the txstate structure and returning the DMA status.  We also provide
    a separate helper to set the residue for cookies which are still in
    progress.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Jassi Brar <jassisinghbrar@gmail.com>
    [imx-sdma.c & mxs-dma.c]
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 9a3cbac3d695..6731f1918c55 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -153,16 +153,7 @@ static enum dma_status imxdma_tx_status(struct dma_chan *chan,
 					    dma_cookie_t cookie,
 					    struct dma_tx_state *txstate)
 {
-	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
-	dma_cookie_t last_used;
-	enum dma_status ret;
-
-	last_used = chan->cookie;
-
-	ret = dma_async_is_complete(cookie, chan->completed_cookie, last_used);
-	dma_set_tx_state(txstate, chan->completed_cookie, last_used, 0);
-
-	return ret;
+	return dma_cookie_status(chan, cookie, txstate);
 }
 
 static dma_cookie_t imxdma_tx_submit(struct dma_async_tx_descriptor *tx)

commit f7fbce07c6ce26a25b4e0cb5f241c361fde87901
Author: Russell King - ARM Linux <linux@arm.linux.org.uk>
Date:   Tue Mar 6 22:35:07 2012 +0000

    dmaengine: provide a common function for completing a dma descriptor
    
    Provide a common function to do the cookie mechanics for completing
    a DMA descriptor.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Jassi Brar <jassisinghbrar@gmail.com>
    [imx-sdma.c & mxs-dma.c]
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 687fc687aaf6..9a3cbac3d695 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -66,7 +66,7 @@ static void imxdma_handle(struct imxdma_channel *imxdmac)
 {
 	if (imxdmac->desc.callback)
 		imxdmac->desc.callback(imxdmac->desc.callback_param);
-	imxdmac->chan.completed_cookie = imxdmac->desc.cookie;
+	dma_cookie_complete(&imxdmac->desc);
 }
 
 static void imxdma_irq_handler(int channel, void *data)

commit 884485e1f12dcd39390f042e772cdbefc9ebb750
Author: Russell King - ARM Linux <linux@arm.linux.org.uk>
Date:   Tue Mar 6 22:34:46 2012 +0000

    dmaengine: consolidate assignment of DMA cookies
    
    Everyone deals with assigning DMA cookies in the same way (it's part of
    the API so they should be), so lets consolidate the common code into a
    helper function to avoid this duplication.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Jassi Brar <jassisinghbrar@gmail.com>
    [imx-sdma.c & mxs-dma.c]
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index cead5e4bd38c..687fc687aaf6 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -165,19 +165,6 @@ static enum dma_status imxdma_tx_status(struct dma_chan *chan,
 	return ret;
 }
 
-static dma_cookie_t imxdma_assign_cookie(struct imxdma_channel *imxdma)
-{
-	dma_cookie_t cookie = imxdma->chan.cookie;
-
-	if (++cookie < 0)
-		cookie = 1;
-
-	imxdma->chan.cookie = cookie;
-	imxdma->desc.cookie = cookie;
-
-	return cookie;
-}
-
 static dma_cookie_t imxdma_tx_submit(struct dma_async_tx_descriptor *tx)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(tx->chan);
@@ -185,7 +172,7 @@ static dma_cookie_t imxdma_tx_submit(struct dma_async_tx_descriptor *tx)
 
 	spin_lock_irq(&imxdmac->lock);
 
-	cookie = imxdma_assign_cookie(imxdmac);
+	cookie = dma_cookie_assign(tx);
 
 	spin_unlock_irq(&imxdmac->lock);
 

commit d2ebfb335b0426deb1a4fb14e4e926d81ecd8235
Author: Russell King - ARM Linux <linux@arm.linux.org.uk>
Date:   Tue Mar 6 22:34:26 2012 +0000

    dmaengine: add private header file
    
    Add a local private header file to contain definitions and declarations
    which should only be used by DMA engine drivers.
    
    We also fix linux/dmaengine.h to use LINUX_DMAENGINE_H to guard against
    multiple inclusion.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Jassi Brar <jassisinghbrar@gmail.com>
    [imx-sdma.c & mxs-dma.c]
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index d3ddcba87f81..cead5e4bd38c 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -30,6 +30,8 @@
 #include <mach/dma-v1.h>
 #include <mach/hardware.h>
 
+#include "dmaengine.h"
+
 struct imxdma_channel {
 	struct imxdma_engine		*imxdma;
 	unsigned int			channel;

commit 4d4e58de32a192fea65ab84509d17d199bd291c8
Author: Russell King - ARM Linux <linux@arm.linux.org.uk>
Date:   Tue Mar 6 22:34:06 2012 +0000

    dmaengine: move last completed cookie into generic dma_chan structure
    
    Every DMA engine implementation declares a last completed dma cookie
    in their private dma channel structures.  This is pointless, and
    forces driver specific code.  Move this out into the common dma_chan
    structure.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Jassi Brar <jassisinghbrar@gmail.com>
    [imx-sdma.c & mxs-dma.c]
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 3296a7337f25..d3ddcba87f81 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -41,7 +41,6 @@ struct imxdma_channel {
 	struct dma_chan			chan;
 	spinlock_t			lock;
 	struct dma_async_tx_descriptor	desc;
-	dma_cookie_t			last_completed;
 	enum dma_status			status;
 	int				dma_request;
 	struct scatterlist		*sg_list;
@@ -65,7 +64,7 @@ static void imxdma_handle(struct imxdma_channel *imxdmac)
 {
 	if (imxdmac->desc.callback)
 		imxdmac->desc.callback(imxdmac->desc.callback_param);
-	imxdmac->last_completed = imxdmac->desc.cookie;
+	imxdmac->chan.completed_cookie = imxdmac->desc.cookie;
 }
 
 static void imxdma_irq_handler(int channel, void *data)
@@ -158,8 +157,8 @@ static enum dma_status imxdma_tx_status(struct dma_chan *chan,
 
 	last_used = chan->cookie;
 
-	ret = dma_async_is_complete(cookie, imxdmac->last_completed, last_used);
-	dma_set_tx_state(txstate, imxdmac->last_completed, last_used, 0);
+	ret = dma_async_is_complete(cookie, chan->completed_cookie, last_used);
+	dma_set_tx_state(txstate, chan->completed_cookie, last_used, 0);
 
 	return ret;
 }

commit 5170c051a56244816d948c43592c1b2805ed4f3a
Author: Vinod Koul <vinod.koul@linux.intel.com>
Date:   Fri Mar 9 14:55:25 2012 +0530

    Revert "drivers/dma: linux/module.h included twice"
    
    This reverts commit 865d9438eb1f7670d2e88849f059db551b320887.
    
    The module.h incsuion twice has been updated tree wide hence this is not
    required to be merged.
    
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 85b3d3c21d91..c32103f04fb3 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -26,6 +26,7 @@
 #include <linux/slab.h>
 #include <linux/platform_device.h>
 #include <linux/dmaengine.h>
+#include <linux/module.h>
 
 #include <asm/irq.h>
 #include <mach/dma-v1.h>

commit 9e15db7ce949e9f2d8bb6ce32a74212a4f662370
Author: Javier Martin <javier.martin@vista-silicon.com>
Date:   Fri Mar 2 09:28:47 2012 +0100

    dmaengine: Add support for multiple descriptors for imx-dma.
    
    dmaengine specifies the possibility that several descriptors
    can be queued for transfer. It also indicates that tasklets
    must be used for DMA callbacks.
    
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Javier Martin <javier.martin@vista-silicon.com>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 9a1797873169..85b3d3c21d91 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -5,6 +5,7 @@
  * found on i.MX1/21/27
  *
  * Copyright 2010 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
+ * Copyright 2012 Javier Martin, Vista Silicon <javier.martin@vista-silicon.com>
  *
  * The code contained herein is licensed under the GNU General Public
  * License. You may obtain a copy of the GNU General Public License
@@ -13,6 +14,7 @@
  * http://www.opensource.org/licenses/gpl-license.html
  * http://www.gnu.org/copyleft/gpl.html
  */
+
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/types.h>
@@ -29,19 +31,52 @@
 #include <mach/dma-v1.h>
 #include <mach/hardware.h>
 
+#define IMXDMA_MAX_CHAN_DESCRIPTORS	16
+
+enum  imxdma_prep_type {
+	IMXDMA_DESC_MEMCPY,
+	IMXDMA_DESC_INTERLEAVED,
+	IMXDMA_DESC_SLAVE_SG,
+	IMXDMA_DESC_CYCLIC,
+};
+
+struct imxdma_desc {
+	struct list_head		node;
+	struct dma_async_tx_descriptor	desc;
+	enum dma_status			status;
+	dma_addr_t			src;
+	dma_addr_t			dest;
+	size_t				len;
+	unsigned int			dmamode;
+	enum imxdma_prep_type		type;
+	/* For memcpy and interleaved */
+	unsigned int			config_port;
+	unsigned int			config_mem;
+	/* For interleaved transfers */
+	unsigned int			x;
+	unsigned int			y;
+	unsigned int			w;
+	/* For slave sg and cyclic */
+	struct scatterlist		*sg;
+	unsigned int			sgcount;
+};
+
 struct imxdma_channel {
 	struct imxdma_engine		*imxdma;
 	unsigned int			channel;
 	unsigned int			imxdma_channel;
 
+	struct tasklet_struct		dma_tasklet;
+	struct list_head		ld_free;
+	struct list_head		ld_queue;
+	struct list_head		ld_active;
+	int				descs_allocated;
 	enum dma_slave_buswidth		word_size;
 	dma_addr_t			per_address;
 	u32				watermark_level;
 	struct dma_chan			chan;
 	spinlock_t			lock;
-	struct dma_async_tx_descriptor	desc;
 	dma_cookie_t			last_completed;
-	enum dma_status			status;
 	int				dma_request;
 	struct scatterlist		*sg_list;
 };
@@ -60,27 +95,31 @@ static struct imxdma_channel *to_imxdma_chan(struct dma_chan *chan)
 	return container_of(chan, struct imxdma_channel, chan);
 }
 
-static void imxdma_handle(struct imxdma_channel *imxdmac)
+static inline bool imxdma_chan_is_doing_cyclic(struct imxdma_channel *imxdmac)
 {
-	if (imxdmac->desc.callback)
-		imxdmac->desc.callback(imxdmac->desc.callback_param);
-	imxdmac->last_completed = imxdmac->desc.cookie;
+	struct imxdma_desc *desc;
+
+	if (!list_empty(&imxdmac->ld_active)) {
+		desc = list_first_entry(&imxdmac->ld_active, struct imxdma_desc,
+					node);
+		if (desc->type == IMXDMA_DESC_CYCLIC)
+			return true;
+	}
+	return false;
 }
 
 static void imxdma_irq_handler(int channel, void *data)
 {
 	struct imxdma_channel *imxdmac = data;
 
-	imxdmac->status = DMA_SUCCESS;
-	imxdma_handle(imxdmac);
+	tasklet_schedule(&imxdmac->dma_tasklet);
 }
 
 static void imxdma_err_handler(int channel, void *data, int error)
 {
 	struct imxdma_channel *imxdmac = data;
 
-	imxdmac->status = DMA_ERROR;
-	imxdma_handle(imxdmac);
+	tasklet_schedule(&imxdmac->dma_tasklet);
 }
 
 static void imxdma_progression(int channel, void *data,
@@ -88,8 +127,88 @@ static void imxdma_progression(int channel, void *data,
 {
 	struct imxdma_channel *imxdmac = data;
 
-	imxdmac->status = DMA_SUCCESS;
-	imxdma_handle(imxdmac);
+	tasklet_schedule(&imxdmac->dma_tasklet);
+}
+
+static int imxdma_xfer_desc(struct imxdma_desc *d)
+{
+	struct imxdma_channel *imxdmac = to_imxdma_chan(d->desc.chan);
+	int ret;
+
+	/* Configure and enable */
+	switch (d->type) {
+	case IMXDMA_DESC_MEMCPY:
+		ret = imx_dma_config_channel(imxdmac->imxdma_channel,
+					  d->config_port, d->config_mem, 0, 0);
+		if (ret < 0)
+			return ret;
+		ret = imx_dma_setup_single(imxdmac->imxdma_channel, d->src,
+					   d->len, d->dest, d->dmamode);
+		if (ret < 0)
+			return ret;
+		break;
+	case IMXDMA_DESC_CYCLIC:
+		ret = imx_dma_setup_progression_handler(imxdmac->imxdma_channel,
+							imxdma_progression);
+		if (ret < 0)
+			return ret;
+		/*
+		 * We fall through here since cyclic transfer is the same as
+		 * slave_sg adding a progression handler and a specific sg
+		 * configuration which is done in 'imxdma_prep_dma_cyclic'.
+		 */
+	case IMXDMA_DESC_SLAVE_SG:
+		if (d->dmamode == DMA_MODE_READ)
+			ret = imx_dma_setup_sg(imxdmac->imxdma_channel, d->sg,
+				       d->sgcount, d->len, d->src, d->dmamode);
+		else
+			ret = imx_dma_setup_sg(imxdmac->imxdma_channel, d->sg,
+				      d->sgcount, d->len, d->dest, d->dmamode);
+		if (ret < 0)
+			return ret;
+		break;
+	default:
+		return -EINVAL;
+	}
+	imx_dma_enable(imxdmac->imxdma_channel);
+	return 0;
+}
+
+static void imxdma_tasklet(unsigned long data)
+{
+	struct imxdma_channel *imxdmac = (void *)data;
+	struct imxdma_engine *imxdma = imxdmac->imxdma;
+	struct imxdma_desc *desc;
+
+	spin_lock(&imxdmac->lock);
+
+	if (list_empty(&imxdmac->ld_active)) {
+		/* Someone might have called terminate all */
+		goto out;
+	}
+	desc = list_first_entry(&imxdmac->ld_active, struct imxdma_desc, node);
+
+	if (desc->desc.callback)
+		desc->desc.callback(desc->desc.callback_param);
+
+	imxdmac->last_completed = desc->desc.cookie;
+
+	/* If we are dealing with a cyclic descriptor keep it on ld_active */
+	if (imxdma_chan_is_doing_cyclic(imxdmac))
+		goto out;
+
+	list_move_tail(imxdmac->ld_active.next, &imxdmac->ld_free);
+
+	if (!list_empty(&imxdmac->ld_queue)) {
+		desc = list_first_entry(&imxdmac->ld_queue, struct imxdma_desc,
+					node);
+		list_move_tail(imxdmac->ld_queue.next, &imxdmac->ld_active);
+		if (imxdma_xfer_desc(desc) < 0)
+			dev_warn(imxdma->dev, "%s: channel: %d couldn't xfer desc\n",
+				 __func__, imxdmac->channel);
+	}
+out:
+	spin_unlock(&imxdmac->lock);
 }
 
 static int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
@@ -98,12 +217,17 @@ static int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
 	struct dma_slave_config *dmaengine_cfg = (void *)arg;
 	int ret;
+	unsigned long flags;
 	unsigned int mode = 0;
 
 	switch (cmd) {
 	case DMA_TERMINATE_ALL:
-		imxdmac->status = DMA_ERROR;
 		imx_dma_disable(imxdmac->imxdma_channel);
+
+		spin_lock_irqsave(&imxdmac->lock, flags);
+		list_splice_tail_init(&imxdmac->ld_active, &imxdmac->ld_free);
+		list_splice_tail_init(&imxdmac->ld_queue, &imxdmac->ld_free);
+		spin_unlock_irqrestore(&imxdmac->lock, flags);
 		return 0;
 	case DMA_SLAVE_CONFIG:
 		if (dmaengine_cfg->direction == DMA_DEV_TO_MEM) {
@@ -154,11 +278,14 @@ static enum dma_status imxdma_tx_status(struct dma_chan *chan,
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
 	dma_cookie_t last_used;
 	enum dma_status ret;
+	unsigned long flags;
 
+	spin_lock_irqsave(&imxdmac->lock, flags);
 	last_used = chan->cookie;
 
 	ret = dma_async_is_complete(cookie, imxdmac->last_completed, last_used);
 	dma_set_tx_state(txstate, imxdmac->last_completed, last_used, 0);
+	spin_unlock_irqrestore(&imxdmac->lock, flags);
 
 	return ret;
 }
@@ -171,7 +298,6 @@ static dma_cookie_t imxdma_assign_cookie(struct imxdma_channel *imxdma)
 		cookie = 1;
 
 	imxdma->chan.cookie = cookie;
-	imxdma->desc.cookie = cookie;
 
 	return cookie;
 }
@@ -180,12 +306,15 @@ static dma_cookie_t imxdma_tx_submit(struct dma_async_tx_descriptor *tx)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(tx->chan);
 	dma_cookie_t cookie;
+	unsigned long flags;
 
-	spin_lock_irq(&imxdmac->lock);
+	spin_lock_irqsave(&imxdmac->lock, flags);
 
+	list_move_tail(imxdmac->ld_free.next, &imxdmac->ld_queue);
 	cookie = imxdma_assign_cookie(imxdmac);
+	tx->cookie = cookie;
 
-	spin_unlock_irq(&imxdmac->lock);
+	spin_unlock_irqrestore(&imxdmac->lock, flags);
 
 	return cookie;
 }
@@ -198,21 +327,48 @@ static int imxdma_alloc_chan_resources(struct dma_chan *chan)
 	if (data != NULL)
 		imxdmac->dma_request = data->dma_request;
 
-	dma_async_tx_descriptor_init(&imxdmac->desc, chan);
-	imxdmac->desc.tx_submit = imxdma_tx_submit;
-	/* txd.flags will be overwritten in prep funcs */
-	imxdmac->desc.flags = DMA_CTRL_ACK;
+	while (imxdmac->descs_allocated < IMXDMA_MAX_CHAN_DESCRIPTORS) {
+		struct imxdma_desc *desc;
 
-	imxdmac->status = DMA_SUCCESS;
+		desc = kzalloc(sizeof(*desc), GFP_KERNEL);
+		if (!desc)
+			break;
+		__memzero(&desc->desc, sizeof(struct dma_async_tx_descriptor));
+		dma_async_tx_descriptor_init(&desc->desc, chan);
+		desc->desc.tx_submit = imxdma_tx_submit;
+		/* txd.flags will be overwritten in prep funcs */
+		desc->desc.flags = DMA_CTRL_ACK;
+		desc->status = DMA_SUCCESS;
+
+		list_add_tail(&desc->node, &imxdmac->ld_free);
+		imxdmac->descs_allocated++;
+	}
 
-	return 0;
+	if (!imxdmac->descs_allocated)
+		return -ENOMEM;
+
+	return imxdmac->descs_allocated;
 }
 
 static void imxdma_free_chan_resources(struct dma_chan *chan)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
+	struct imxdma_desc *desc, *_desc;
+	unsigned long flags;
+
+	spin_lock_irqsave(&imxdmac->lock, flags);
 
 	imx_dma_disable(imxdmac->imxdma_channel);
+	list_splice_tail_init(&imxdmac->ld_active, &imxdmac->ld_free);
+	list_splice_tail_init(&imxdmac->ld_queue, &imxdmac->ld_free);
+
+	spin_unlock_irqrestore(&imxdmac->lock, flags);
+
+	list_for_each_entry_safe(desc, _desc, &imxdmac->ld_free, node) {
+		kfree(desc);
+		imxdmac->descs_allocated--;
+	}
+	INIT_LIST_HEAD(&imxdmac->ld_free);
 
 	if (imxdmac->sg_list) {
 		kfree(imxdmac->sg_list);
@@ -227,23 +383,19 @@ static struct dma_async_tx_descriptor *imxdma_prep_slave_sg(
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
 	struct scatterlist *sg;
-	int i, ret, dma_length = 0;
-	unsigned int dmamode;
+	int i, dma_length = 0;
+	struct imxdma_desc *desc;
 
-	if (imxdmac->status == DMA_IN_PROGRESS)
+	if (list_empty(&imxdmac->ld_free) ||
+	    imxdma_chan_is_doing_cyclic(imxdmac))
 		return NULL;
 
-	imxdmac->status = DMA_IN_PROGRESS;
+	desc = list_first_entry(&imxdmac->ld_free, struct imxdma_desc, node);
 
 	for_each_sg(sgl, sg, sg_len, i) {
 		dma_length += sg->length;
 	}
 
-	if (direction == DMA_DEV_TO_MEM)
-		dmamode = DMA_MODE_READ;
-	else
-		dmamode = DMA_MODE_WRITE;
-
 	switch (imxdmac->word_size) {
 	case DMA_SLAVE_BUSWIDTH_4_BYTES:
 		if (sgl->length & 3 || sgl->dma_address & 3)
@@ -259,12 +411,21 @@ static struct dma_async_tx_descriptor *imxdma_prep_slave_sg(
 		return NULL;
 	}
 
-	ret = imx_dma_setup_sg(imxdmac->imxdma_channel, sgl, sg_len,
-		 dma_length, imxdmac->per_address, dmamode);
-	if (ret)
-		return NULL;
+	desc->type = IMXDMA_DESC_SLAVE_SG;
+	desc->sg = sgl;
+	desc->sgcount = sg_len;
+	desc->len = dma_length;
+	if (direction == DMA_DEV_TO_MEM) {
+		desc->dmamode = DMA_MODE_READ;
+		desc->src = imxdmac->per_address;
+	} else {
+		desc->dmamode = DMA_MODE_WRITE;
+		desc->dest = imxdmac->per_address;
+	}
+	desc->desc.callback = NULL;
+	desc->desc.callback_param = NULL;
 
-	return &imxdmac->desc;
+	return &desc->desc;
 }
 
 static struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(
@@ -273,23 +434,18 @@ static struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
 	struct imxdma_engine *imxdma = imxdmac->imxdma;
-	int i, ret;
+	struct imxdma_desc *desc;
+	int i;
 	unsigned int periods = buf_len / period_len;
-	unsigned int dmamode;
 
 	dev_dbg(imxdma->dev, "%s channel: %d buf_len=%d period_len=%d\n",
 			__func__, imxdmac->channel, buf_len, period_len);
 
-	if (imxdmac->status == DMA_IN_PROGRESS)
+	if (list_empty(&imxdmac->ld_free) ||
+	    imxdma_chan_is_doing_cyclic(imxdmac))
 		return NULL;
-	imxdmac->status = DMA_IN_PROGRESS;
 
-	ret = imx_dma_setup_progression_handler(imxdmac->imxdma_channel,
-			imxdma_progression);
-	if (ret) {
-		dev_err(imxdma->dev, "Failed to setup the DMA handler\n");
-		return NULL;
-	}
+	desc = list_first_entry(&imxdmac->ld_free, struct imxdma_desc, node);
 
 	if (imxdmac->sg_list)
 		kfree(imxdmac->sg_list);
@@ -315,17 +471,21 @@ static struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(
 	imxdmac->sg_list[periods].page_link =
 		((unsigned long)imxdmac->sg_list | 0x01) & ~0x02;
 
-	if (direction == DMA_DEV_TO_MEM)
-		dmamode = DMA_MODE_READ;
-	else
-		dmamode = DMA_MODE_WRITE;
-
-	ret = imx_dma_setup_sg(imxdmac->imxdma_channel, imxdmac->sg_list, periods,
-		 IMX_DMA_LENGTH_LOOP, imxdmac->per_address, dmamode);
-	if (ret)
-		return NULL;
+	desc->type = IMXDMA_DESC_CYCLIC;
+	desc->sg = imxdmac->sg_list;
+	desc->sgcount = periods;
+	desc->len = IMX_DMA_LENGTH_LOOP;
+	if (direction == DMA_DEV_TO_MEM) {
+		desc->dmamode = DMA_MODE_READ;
+		desc->src = imxdmac->per_address;
+	} else {
+		desc->dmamode = DMA_MODE_WRITE;
+		desc->dest = imxdmac->per_address;
+	}
+	desc->desc.callback = NULL;
+	desc->desc.callback_param = NULL;
 
-	return &imxdmac->desc;
+	return &desc->desc;
 }
 
 static struct dma_async_tx_descriptor *imxdma_prep_dma_memcpy(
@@ -334,36 +494,53 @@ static struct dma_async_tx_descriptor *imxdma_prep_dma_memcpy(
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
 	struct imxdma_engine *imxdma = imxdmac->imxdma;
-	int ret;
+	struct imxdma_desc *desc;
 
 	dev_dbg(imxdma->dev, "%s channel: %d src=0x%x dst=0x%x len=%d\n",
 			__func__, imxdmac->channel, src, dest, len);
 
-	if (imxdmac->status == DMA_IN_PROGRESS)
+	if (list_empty(&imxdmac->ld_free) ||
+	    imxdma_chan_is_doing_cyclic(imxdmac))
 		return NULL;
-	imxdmac->status = DMA_IN_PROGRESS;
 
-	ret = imx_dma_config_channel(imxdmac->imxdma_channel,
-			       IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR,
-			       IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR,
-			       0, 0);
-	if (ret)
-		return NULL;
+	desc = list_first_entry(&imxdmac->ld_free, struct imxdma_desc, node);
 
-	ret = imx_dma_setup_single(imxdmac->imxdma_channel, src, len,
-				   dest, DMA_MODE_WRITE);
-	if (ret)
-		return NULL;
+	desc->type = IMXDMA_DESC_MEMCPY;
+	desc->src = src;
+	desc->dest = dest;
+	desc->len = len;
+	desc->dmamode = DMA_MODE_WRITE;
+	desc->config_port = IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR;
+	desc->config_mem = IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR;
+	desc->desc.callback = NULL;
+	desc->desc.callback_param = NULL;
 
-	return &imxdmac->desc;
+	return &desc->desc;
 }
 
 static void imxdma_issue_pending(struct dma_chan *chan)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
-
-	if (imxdmac->status == DMA_IN_PROGRESS)
-		imx_dma_enable(imxdmac->imxdma_channel);
+	struct imxdma_engine *imxdma = imxdmac->imxdma;
+	struct imxdma_desc *desc;
+	unsigned long flags;
+
+	spin_lock_irqsave(&imxdmac->lock, flags);
+	if (list_empty(&imxdmac->ld_active) &&
+	    !list_empty(&imxdmac->ld_queue)) {
+		desc = list_first_entry(&imxdmac->ld_queue,
+					struct imxdma_desc, node);
+
+		if (imxdma_xfer_desc(desc) < 0) {
+			dev_warn(imxdma->dev,
+				 "%s: channel: %d couldn't issue DMA xfer\n",
+				 __func__, imxdmac->channel);
+		} else {
+			list_move_tail(imxdmac->ld_queue.next,
+				       &imxdmac->ld_active);
+		}
+	}
+	spin_unlock_irqrestore(&imxdmac->lock, flags);
 }
 
 static int __init imxdma_probe(struct platform_device *pdev)
@@ -398,11 +575,18 @@ static int __init imxdma_probe(struct platform_device *pdev)
 		imxdmac->imxdma = imxdma;
 		spin_lock_init(&imxdmac->lock);
 
+		INIT_LIST_HEAD(&imxdmac->ld_queue);
+		INIT_LIST_HEAD(&imxdmac->ld_free);
+		INIT_LIST_HEAD(&imxdmac->ld_active);
+
+		tasklet_init(&imxdmac->dma_tasklet, imxdma_tasklet,
+			     (unsigned long)imxdmac);
 		imxdmac->chan.device = &imxdma->dma_device;
 		imxdmac->channel = i;
 
 		/* Add the channel to the DMAC list */
-		list_add_tail(&imxdmac->chan.device_node, &imxdma->dma_device.channels);
+		list_add_tail(&imxdmac->chan.device_node,
+			      &imxdma->dma_device.channels);
 	}
 
 	imxdma->dev = &pdev->dev;

commit 6c05f09155f40368c51ce00b8291401858e49bcb
Author: Javier Martin <javier.martin@vista-silicon.com>
Date:   Tue Feb 28 17:08:17 2012 +0100

    dmaengine: Add support for MEMCPY for imx-dma.
    
    MEMCPY transfers allow DMA copies from memory to
    memory. This patch has been tested with dmatest
    device driver.
    
    Signed-off-by: Javier Martin <javier.martin@vista-silicon.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index b51391adb289..9a1797873169 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -195,7 +195,8 @@ static int imxdma_alloc_chan_resources(struct dma_chan *chan)
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
 	struct imx_dma_data *data = chan->private;
 
-	imxdmac->dma_request = data->dma_request;
+	if (data != NULL)
+		imxdmac->dma_request = data->dma_request;
 
 	dma_async_tx_descriptor_init(&imxdmac->desc, chan);
 	imxdmac->desc.tx_submit = imxdma_tx_submit;
@@ -327,6 +328,36 @@ static struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(
 	return &imxdmac->desc;
 }
 
+static struct dma_async_tx_descriptor *imxdma_prep_dma_memcpy(
+	struct dma_chan *chan, dma_addr_t dest,
+	dma_addr_t src, size_t len, unsigned long flags)
+{
+	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
+	struct imxdma_engine *imxdma = imxdmac->imxdma;
+	int ret;
+
+	dev_dbg(imxdma->dev, "%s channel: %d src=0x%x dst=0x%x len=%d\n",
+			__func__, imxdmac->channel, src, dest, len);
+
+	if (imxdmac->status == DMA_IN_PROGRESS)
+		return NULL;
+	imxdmac->status = DMA_IN_PROGRESS;
+
+	ret = imx_dma_config_channel(imxdmac->imxdma_channel,
+			       IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR,
+			       IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR,
+			       0, 0);
+	if (ret)
+		return NULL;
+
+	ret = imx_dma_setup_single(imxdmac->imxdma_channel, src, len,
+				   dest, DMA_MODE_WRITE);
+	if (ret)
+		return NULL;
+
+	return &imxdmac->desc;
+}
+
 static void imxdma_issue_pending(struct dma_chan *chan)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
@@ -348,6 +379,7 @@ static int __init imxdma_probe(struct platform_device *pdev)
 
 	dma_cap_set(DMA_SLAVE, imxdma->dma_device.cap_mask);
 	dma_cap_set(DMA_CYCLIC, imxdma->dma_device.cap_mask);
+	dma_cap_set(DMA_MEMCPY, imxdma->dma_device.cap_mask);
 
 	/* Initialize channel parameters */
 	for (i = 0; i < MAX_DMA_CHANNELS; i++) {
@@ -381,11 +413,13 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	imxdma->dma_device.device_tx_status = imxdma_tx_status;
 	imxdma->dma_device.device_prep_slave_sg = imxdma_prep_slave_sg;
 	imxdma->dma_device.device_prep_dma_cyclic = imxdma_prep_dma_cyclic;
+	imxdma->dma_device.device_prep_dma_memcpy = imxdma_prep_dma_memcpy;
 	imxdma->dma_device.device_control = imxdma_control;
 	imxdma->dma_device.device_issue_pending = imxdma_issue_pending;
 
 	platform_set_drvdata(pdev, imxdma);
 
+	imxdma->dma_device.copy_align = 2; /* 2^2 = 4 bytes alignment */
 	imxdma->dma_device.dev->dma_parms = &imxdma->dma_parms;
 	dma_set_max_seg_size(imxdma->dma_device.dev, 0xffffff);
 

commit 865d9438eb1f7670d2e88849f059db551b320887
Author: Danny Kukawka <danny.kukawka@bisect.de>
Date:   Wed Feb 15 20:20:26 2012 +0100

    drivers/dma: linux/module.h included twice
    
    drivers/dma/imx-dma.c and drivers/dma/imx-sdma.c included
    'linux/module.h' twice, remove the duplicates.
    
    Signed-off-by: Danny Kukawka <danny.kukawka@bisect.de>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 3296a7337f25..b51391adb289 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -24,7 +24,6 @@
 #include <linux/slab.h>
 #include <linux/platform_device.h>
 #include <linux/dmaengine.h>
-#include <linux/module.h>
 
 #include <asm/irq.h>
 #include <mach/dma-v1.h>

commit 13ae246db4a02971ef4f557af1f6d3e21d64b710
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jan 29 15:44:45 2012 -0500

    includecheck: delete any duplicate instances of module.h
    
    Different tree maintainers picked up independently generated
    trivial compile fixes based on linux-next testing, resulting
    in some cases where a file would have got more than one addition
    of module.h once everything was all merged together.
    
    Delete any duplicates so includecheck isn't complaining about
    anything related to module.h/export.h changes.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index e4383ee2c9ac..38586ba8da91 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -14,7 +14,6 @@
  * http://www.gnu.org/copyleft/gpl.html
  */
 #include <linux/init.h>
-#include <linux/module.h>
 #include <linux/types.h>
 #include <linux/mm.h>
 #include <linux/interrupt.h>

commit 5b3168763f507fd46285b7310fc2d18dafe7f1c7
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Mon Jan 9 10:32:49 2012 +0100

    dma: imx-dma: start transfer in issue_pending
    
    The DMA engine API requires that transfers are started in issue_pending
    instead of tx_submit. Fix this.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    [corrected change log to DMA engine API insteadof DMA API]
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index e4383ee2c9ac..3296a7337f25 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -186,8 +186,6 @@ static dma_cookie_t imxdma_tx_submit(struct dma_async_tx_descriptor *tx)
 
 	cookie = imxdma_assign_cookie(imxdmac);
 
-	imx_dma_enable(imxdmac->imxdma_channel);
-
 	spin_unlock_irq(&imxdmac->lock);
 
 	return cookie;
@@ -332,9 +330,10 @@ static struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(
 
 static void imxdma_issue_pending(struct dma_chan *chan)
 {
-	/*
-	 * Nothing to do. We only have a single descriptor
-	 */
+	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
+
+	if (imxdmac->status == DMA_IN_PROGRESS)
+		imx_dma_enable(imxdmac->imxdma_channel);
 }
 
 static int __init imxdma_probe(struct platform_device *pdev)

commit e0d23ef29ed637dc6bd739f590985746d9ad9caa
Merge: ca7fe2db892d 55ba4e5ed4ac
Author: Vinod Koul <vinod.koul@linux.intel.com>
Date:   Thu Nov 17 14:54:38 2011 +0530

    Merge branch 'dma_slave_direction' into next_test_dirn
    
    resolved conflicts:
            drivers/media/video/mx3_camera.c

commit 32aaeffbd4a7457bf2f7448b33b5946ff2a960eb
Merge: 208bca086040 67b84999b1a8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Nov 6 19:44:47 2011 -0800

    Merge branch 'modsplit-Oct31_2011' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux
    
    * 'modsplit-Oct31_2011' of git://git.kernel.org/pub/scm/linux/kernel/git/paulg/linux: (230 commits)
      Revert "tracing: Include module.h in define_trace.h"
      irq: don't put module.h into irq.h for tracking irqgen modules.
      bluetooth: macroize two small inlines to avoid module.h
      ip_vs.h: fix implicit use of module_get/module_put from module.h
      nf_conntrack.h: fix up fallout from implicit moduleparam.h presence
      include: replace linux/module.h with "struct module" wherever possible
      include: convert various register fcns to macros to avoid include chaining
      crypto.h: remove unused crypto_tfm_alg_modname() inline
      uwb.h: fix implicit use of asm/page.h for PAGE_SIZE
      pm_runtime.h: explicitly requires notifier.h
      linux/dmaengine.h: fix implicit use of bitmap.h and asm/page.h
      miscdevice.h: fix up implicit use of lists and types
      stop_machine.h: fix implicit use of smp.h for smp_processor_id
      of: fix implicit use of errno.h in include/linux/of.h
      of_platform.h: delete needless include <linux/module.h>
      acpi: remove module.h include from platform/aclinux.h
      miscdevice.h: delete unnecessary inclusion of module.h
      device_cgroup.h: delete needless include <linux/module.h>
      net: sch_generic remove redundant use of <linux/module.h>
      net: inet_timewait_sock doesnt need <linux/module.h>
      ...
    
    Fix up trivial conflicts (other header files, and  removal of the ab3550 mfd driver) in
     - drivers/media/dvb/frontends/dibx000_common.c
     - drivers/media/video/{mt9m111.c,ov6650.c}
     - drivers/mfd/ab3550-core.c
     - include/linux/dmaengine.h

commit 5c45ad77ffd0108596627816a37de71a04d5cb6d
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 31 16:14:17 2011 -0400

    drivers/dma: Add module.h to files implicitly using it.
    
    Fix files that were implicitly using module.h but not
    calling it out for inclusion directly.  We'll break those
    once we remove the implicit presence otherwise
    
    [With input from Uwe Kleine-König <u.kleine-koenig@pengutronix.de>]
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index d99f71c356b5..3732de89adc9 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -23,6 +23,7 @@
 #include <linux/slab.h>
 #include <linux/platform_device.h>
 #include <linux/dmaengine.h>
+#include <linux/module.h>
 
 #include <asm/irq.h>
 #include <mach/dma-v1.h>

commit db8196df4bb6f117caa163aa73b0f16fd62290bd
Author: Vinod Koul <vinod.koul@linux.intel.com>
Date:   Thu Oct 13 22:34:23 2011 +0530

    dmaengine: move drivers to dma_transfer_direction
    
    fixup usage of dma direction by introducing dma_transfer_direction,
    this patch moves dma/drivers/* to use new enum
    
    Cc: Jassi Brar <jaswinder.singh@linaro.org>
    Cc: Russell King <rmk+kernel@arm.linux.org.uk>
    Cc: Viresh Kumar <viresh.kumar@st.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Mika Westerberg <mika.westerberg@iki.fi>
    Cc: H Hartley Sweeten <hartleys@visionengravers.com>
    Cc: Li Yang <leoli@freescale.com>
    Cc: Zhang Wei <zw@zh-kernel.org>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Cc: Shawn Guo <shawn.guo@freescale.com>
    Cc: Yong Wang <yong.y.wang@intel.com>
    Cc: Tomoya MORINAGA <tomoya-linux@dsn.lapis-semi.com>
    Cc: Boojin Kim <boojin.kim@samsung.com>
    Cc: Barry Song <Baohua.Song@csr.com>
    Acked-by: Mika Westerberg <mika.westerberg@iki.fi>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Viresh Kumar <viresh.kumar@st.com>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index d746899f36e1..678cd01dc42c 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -106,7 +106,7 @@ static int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 		imx_dma_disable(imxdmac->imxdma_channel);
 		return 0;
 	case DMA_SLAVE_CONFIG:
-		if (dmaengine_cfg->direction == DMA_FROM_DEVICE) {
+		if (dmaengine_cfg->direction == DMA_DEV_TO_MEM) {
 			imxdmac->per_address = dmaengine_cfg->src_addr;
 			imxdmac->watermark_level = dmaengine_cfg->src_maxburst;
 			imxdmac->word_size = dmaengine_cfg->src_addr_width;
@@ -223,7 +223,7 @@ static void imxdma_free_chan_resources(struct dma_chan *chan)
 
 static struct dma_async_tx_descriptor *imxdma_prep_slave_sg(
 		struct dma_chan *chan, struct scatterlist *sgl,
-		unsigned int sg_len, enum dma_data_direction direction,
+		unsigned int sg_len, enum dma_transfer_direction direction,
 		unsigned long flags)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
@@ -240,7 +240,7 @@ static struct dma_async_tx_descriptor *imxdma_prep_slave_sg(
 		dma_length += sg->length;
 	}
 
-	if (direction == DMA_FROM_DEVICE)
+	if (direction == DMA_DEV_TO_MEM)
 		dmamode = DMA_MODE_READ;
 	else
 		dmamode = DMA_MODE_WRITE;
@@ -270,7 +270,7 @@ static struct dma_async_tx_descriptor *imxdma_prep_slave_sg(
 
 static struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(
 		struct dma_chan *chan, dma_addr_t dma_addr, size_t buf_len,
-		size_t period_len, enum dma_data_direction direction)
+		size_t period_len, enum dma_transfer_direction direction)
 {
 	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
 	struct imxdma_engine *imxdma = imxdmac->imxdma;
@@ -316,7 +316,7 @@ static struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(
 	imxdmac->sg_list[periods].page_link =
 		((unsigned long)imxdmac->sg_list | 0x01) & ~0x02;
 
-	if (direction == DMA_FROM_DEVICE)
+	if (direction == DMA_DEV_TO_MEM)
 		dmamode = DMA_MODE_READ;
 	else
 		dmamode = DMA_MODE_WRITE;

commit f8de8f4ce2a83ccf7571ee13d41d02a9040797f9
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Aug 30 15:08:24 2011 +0800

    dmaengine i.MX DMA/SDMA: add missing include of linux/module.h
    
    Add missing include of linux/module.h to fix build error.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index d99f71c356b5..d746899f36e1 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -14,6 +14,7 @@
  * http://www.gnu.org/copyleft/gpl.html
  */
 #include <linux/init.h>
+#include <linux/module.h>
 #include <linux/types.h>
 #include <linux/mm.h>
 #include <linux/interrupt.h>

commit 6584cb8825e4c74915a5a13756b1902523391d78
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Wed Jul 6 11:18:33 2011 +0200

    ARM i.MX dma: Fix burstsize settings
    
    dmaengine expects the maxburst parameter in words, not bytes.
    The imxdma driver and its users do this wrong. Fix this.
    
    As a side note the imx-pcm-dma-mx2 driver was 'fixed' to work
    with imx-dma. This broke the driver with imx-sdma support which
    correctly takes the maxburst parameter in words. This patch
    puts the sdma based sound back to work.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index e18eaabe92b9..d99f71c356b5 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -135,7 +135,8 @@ static int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 		if (ret)
 			return ret;
 
-		imx_dma_config_burstlen(imxdmac->imxdma_channel, imxdmac->watermark_level);
+		imx_dma_config_burstlen(imxdmac->imxdma_channel,
+				imxdmac->watermark_level * imxdmac->word_size);
 
 		return 0;
 	default:

commit f8a356ff96a9070156f863e4f7716e2a0eb8c995
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Mon Jan 31 11:35:59 2011 +0100

    dmaengine i.MX dma: initialize dma capabilities outside channel loop
    
    The capabilities are device specific fields, not channel specific fields.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 82627087b550..e18eaabe92b9 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -345,6 +345,9 @@ static int __init imxdma_probe(struct platform_device *pdev)
 
 	INIT_LIST_HEAD(&imxdma->dma_device.channels);
 
+	dma_cap_set(DMA_SLAVE, imxdma->dma_device.cap_mask);
+	dma_cap_set(DMA_CYCLIC, imxdma->dma_device.cap_mask);
+
 	/* Initialize channel parameters */
 	for (i = 0; i < MAX_DMA_CHANNELS; i++) {
 		struct imxdma_channel *imxdmac = &imxdma->channel[i];
@@ -362,9 +365,6 @@ static int __init imxdma_probe(struct platform_device *pdev)
 		imxdmac->imxdma = imxdma;
 		spin_lock_init(&imxdmac->lock);
 
-		dma_cap_set(DMA_SLAVE, imxdma->dma_device.cap_mask);
-		dma_cap_set(DMA_CYCLIC, imxdma->dma_device.cap_mask);
-
 		imxdmac->chan.device = &imxdma->dma_device;
 		imxdmac->channel = i;
 

commit 97a43dfe84119528ec2576129b91d619219ab716
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Mon Jan 31 11:35:44 2011 +0100

    dmaengine i.MX DMA: do not initialize chan_id field
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index a1eac99a5fa1..82627087b550 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -366,7 +366,6 @@ static int __init imxdma_probe(struct platform_device *pdev)
 		dma_cap_set(DMA_CYCLIC, imxdma->dma_device.cap_mask);
 
 		imxdmac->chan.device = &imxdma->dma_device;
-		imxdmac->chan.chan_id = i;
 		imxdmac->channel = i;
 
 		/* Add the channel to the DMAC list */

commit d07102a1bb0e759ce4571df30c62998ef5d8a8d3
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Wed Jan 12 14:13:23 2011 +0100

    dmaengine i.MX dma: check sg entries for valid addresses and lengths
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index a46e1d9fa3e4..a1eac99a5fa1 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -243,6 +243,21 @@ static struct dma_async_tx_descriptor *imxdma_prep_slave_sg(
 	else
 		dmamode = DMA_MODE_WRITE;
 
+	switch (imxdmac->word_size) {
+	case DMA_SLAVE_BUSWIDTH_4_BYTES:
+		if (sgl->length & 3 || sgl->dma_address & 3)
+			return NULL;
+		break;
+	case DMA_SLAVE_BUSWIDTH_2_BYTES:
+		if (sgl->length & 1 || sgl->dma_address & 1)
+			return NULL;
+		break;
+	case DMA_SLAVE_BUSWIDTH_1_BYTE:
+		break;
+	default:
+		return NULL;
+	}
+
 	ret = imx_dma_setup_sg(imxdmac->imxdma_channel, sgl, sg_len,
 		 dma_length, imxdmac->per_address, dmamode);
 	if (ret)

commit 1e070a60997f5bbaadd498c34380e2aa110336cf
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Wed Jan 12 13:14:37 2011 +0100

    dmaengine i.MX dma: set maximum segment size for our device
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index e53d438142bb..a46e1d9fa3e4 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -49,6 +49,7 @@ struct imxdma_channel {
 
 struct imxdma_engine {
 	struct device			*dev;
+	struct device_dma_parameters	dma_parms;
 	struct dma_device		dma_device;
 	struct imxdma_channel		channel[MAX_DMA_CHANNELS];
 };
@@ -370,6 +371,9 @@ static int __init imxdma_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, imxdma);
 
+	imxdma->dma_device.dev->dma_parms = &imxdma->dma_parms;
+	dma_set_max_seg_size(imxdma->dma_device.dev, 0xffffff);
+
 	ret = dma_async_device_register(&imxdma->dma_device);
 	if (ret) {
 		dev_err(&pdev->dev, "unable to register\n");

commit cbeae41888bddb2d8c23db281de5f38f4be6a9bb
Author: Axel Lin <axel.lin@gmail.com>
Date:   Tue Nov 2 09:12:57 2010 +0800

    dma: imx-dma: fix imxdma_probe error path
    
    otherwise, i will be -1 inside the latest iteration of the while loop.
    
    Signed-off-by: Axel Lin <axel.lin@gmail.com>
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index f629e4961af5..e53d438142bb 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -379,7 +379,7 @@ static int __init imxdma_probe(struct platform_device *pdev)
 	return 0;
 
 err_init:
-	while (i-- >= 0) {
+	while (--i >= 0) {
 		struct imxdma_channel *imxdmac = &imxdma->channel[i];
 		imx_dma_free(imxdmac->imxdma_channel);
 	}

commit 8267f16e8b67ea272f37f7072933dc0d3839693d
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Wed Oct 20 08:37:19 2010 +0200

    dma: imx-dma: fix signedness bug
    
    mxdmac->channel was unsigned, so check (imxdmac->channel < 0) for
    failed imx_dma_request_by_prio() made no sence.  Explicitly check
    signed values.
    Also, fix uninitialzed use of ret.
    
    Signed-off-by: Vasiliy Kulikov <segooon@gmail.com>
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
index 346be6218058..f629e4961af5 100644
--- a/drivers/dma/imx-dma.c
+++ b/drivers/dma/imx-dma.c
@@ -335,8 +335,10 @@ static int __init imxdma_probe(struct platform_device *pdev)
 
 		imxdmac->imxdma_channel = imx_dma_request_by_prio("dmaengine",
 				DMA_PRIO_MEDIUM);
-		if (imxdmac->channel < 0)
+		if ((int)imxdmac->channel < 0) {
+			ret = -ENODEV;
 			goto err_init;
+		}
 
 		imx_dma_setup_handlers(imxdmac->imxdma_channel,
 		       imxdma_irq_handler, imxdma_err_handler, imxdmac);

commit 1f1846c6ceed07c03ef036a27864befe0f773997
Author: Sascha Hauer <s.hauer@pengutronix.de>
Date:   Wed Oct 6 10:25:55 2010 +0200

    dmaengine: Add Freescale i.MX1/21/27 DMA driver
    
    This driver is currently implemented as a user to the old i.MX
    DMA API. This allows us to convert each user of the old API to
    the dmaengine API one by one. Once this is done the old DMA
    driver can be merged into the i.MX dmaengine driver.
    
    V2: remove some debug leftovers and unused variables
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/dma/imx-dma.c b/drivers/dma/imx-dma.c
new file mode 100644
index 000000000000..346be6218058
--- /dev/null
+++ b/drivers/dma/imx-dma.c
@@ -0,0 +1,422 @@
+/*
+ * drivers/dma/imx-dma.c
+ *
+ * This file contains a driver for the Freescale i.MX DMA engine
+ * found on i.MX1/21/27
+ *
+ * Copyright 2010 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/dmaengine.h>
+
+#include <asm/irq.h>
+#include <mach/dma-v1.h>
+#include <mach/hardware.h>
+
+struct imxdma_channel {
+	struct imxdma_engine		*imxdma;
+	unsigned int			channel;
+	unsigned int			imxdma_channel;
+
+	enum dma_slave_buswidth		word_size;
+	dma_addr_t			per_address;
+	u32				watermark_level;
+	struct dma_chan			chan;
+	spinlock_t			lock;
+	struct dma_async_tx_descriptor	desc;
+	dma_cookie_t			last_completed;
+	enum dma_status			status;
+	int				dma_request;
+	struct scatterlist		*sg_list;
+};
+
+#define MAX_DMA_CHANNELS 8
+
+struct imxdma_engine {
+	struct device			*dev;
+	struct dma_device		dma_device;
+	struct imxdma_channel		channel[MAX_DMA_CHANNELS];
+};
+
+static struct imxdma_channel *to_imxdma_chan(struct dma_chan *chan)
+{
+	return container_of(chan, struct imxdma_channel, chan);
+}
+
+static void imxdma_handle(struct imxdma_channel *imxdmac)
+{
+	if (imxdmac->desc.callback)
+		imxdmac->desc.callback(imxdmac->desc.callback_param);
+	imxdmac->last_completed = imxdmac->desc.cookie;
+}
+
+static void imxdma_irq_handler(int channel, void *data)
+{
+	struct imxdma_channel *imxdmac = data;
+
+	imxdmac->status = DMA_SUCCESS;
+	imxdma_handle(imxdmac);
+}
+
+static void imxdma_err_handler(int channel, void *data, int error)
+{
+	struct imxdma_channel *imxdmac = data;
+
+	imxdmac->status = DMA_ERROR;
+	imxdma_handle(imxdmac);
+}
+
+static void imxdma_progression(int channel, void *data,
+		struct scatterlist *sg)
+{
+	struct imxdma_channel *imxdmac = data;
+
+	imxdmac->status = DMA_SUCCESS;
+	imxdma_handle(imxdmac);
+}
+
+static int imxdma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
+		unsigned long arg)
+{
+	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
+	struct dma_slave_config *dmaengine_cfg = (void *)arg;
+	int ret;
+	unsigned int mode = 0;
+
+	switch (cmd) {
+	case DMA_TERMINATE_ALL:
+		imxdmac->status = DMA_ERROR;
+		imx_dma_disable(imxdmac->imxdma_channel);
+		return 0;
+	case DMA_SLAVE_CONFIG:
+		if (dmaengine_cfg->direction == DMA_FROM_DEVICE) {
+			imxdmac->per_address = dmaengine_cfg->src_addr;
+			imxdmac->watermark_level = dmaengine_cfg->src_maxburst;
+			imxdmac->word_size = dmaengine_cfg->src_addr_width;
+		} else {
+			imxdmac->per_address = dmaengine_cfg->dst_addr;
+			imxdmac->watermark_level = dmaengine_cfg->dst_maxburst;
+			imxdmac->word_size = dmaengine_cfg->dst_addr_width;
+		}
+
+		switch (imxdmac->word_size) {
+		case DMA_SLAVE_BUSWIDTH_1_BYTE:
+			mode = IMX_DMA_MEMSIZE_8;
+			break;
+		case DMA_SLAVE_BUSWIDTH_2_BYTES:
+			mode = IMX_DMA_MEMSIZE_16;
+			break;
+		default:
+		case DMA_SLAVE_BUSWIDTH_4_BYTES:
+			mode = IMX_DMA_MEMSIZE_32;
+			break;
+		}
+		ret = imx_dma_config_channel(imxdmac->imxdma_channel,
+				mode | IMX_DMA_TYPE_FIFO,
+				IMX_DMA_MEMSIZE_32 | IMX_DMA_TYPE_LINEAR,
+				imxdmac->dma_request, 1);
+
+		if (ret)
+			return ret;
+
+		imx_dma_config_burstlen(imxdmac->imxdma_channel, imxdmac->watermark_level);
+
+		return 0;
+	default:
+		return -ENOSYS;
+	}
+
+	return -EINVAL;
+}
+
+static enum dma_status imxdma_tx_status(struct dma_chan *chan,
+					    dma_cookie_t cookie,
+					    struct dma_tx_state *txstate)
+{
+	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
+	dma_cookie_t last_used;
+	enum dma_status ret;
+
+	last_used = chan->cookie;
+
+	ret = dma_async_is_complete(cookie, imxdmac->last_completed, last_used);
+	dma_set_tx_state(txstate, imxdmac->last_completed, last_used, 0);
+
+	return ret;
+}
+
+static dma_cookie_t imxdma_assign_cookie(struct imxdma_channel *imxdma)
+{
+	dma_cookie_t cookie = imxdma->chan.cookie;
+
+	if (++cookie < 0)
+		cookie = 1;
+
+	imxdma->chan.cookie = cookie;
+	imxdma->desc.cookie = cookie;
+
+	return cookie;
+}
+
+static dma_cookie_t imxdma_tx_submit(struct dma_async_tx_descriptor *tx)
+{
+	struct imxdma_channel *imxdmac = to_imxdma_chan(tx->chan);
+	dma_cookie_t cookie;
+
+	spin_lock_irq(&imxdmac->lock);
+
+	cookie = imxdma_assign_cookie(imxdmac);
+
+	imx_dma_enable(imxdmac->imxdma_channel);
+
+	spin_unlock_irq(&imxdmac->lock);
+
+	return cookie;
+}
+
+static int imxdma_alloc_chan_resources(struct dma_chan *chan)
+{
+	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
+	struct imx_dma_data *data = chan->private;
+
+	imxdmac->dma_request = data->dma_request;
+
+	dma_async_tx_descriptor_init(&imxdmac->desc, chan);
+	imxdmac->desc.tx_submit = imxdma_tx_submit;
+	/* txd.flags will be overwritten in prep funcs */
+	imxdmac->desc.flags = DMA_CTRL_ACK;
+
+	imxdmac->status = DMA_SUCCESS;
+
+	return 0;
+}
+
+static void imxdma_free_chan_resources(struct dma_chan *chan)
+{
+	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
+
+	imx_dma_disable(imxdmac->imxdma_channel);
+
+	if (imxdmac->sg_list) {
+		kfree(imxdmac->sg_list);
+		imxdmac->sg_list = NULL;
+	}
+}
+
+static struct dma_async_tx_descriptor *imxdma_prep_slave_sg(
+		struct dma_chan *chan, struct scatterlist *sgl,
+		unsigned int sg_len, enum dma_data_direction direction,
+		unsigned long flags)
+{
+	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
+	struct scatterlist *sg;
+	int i, ret, dma_length = 0;
+	unsigned int dmamode;
+
+	if (imxdmac->status == DMA_IN_PROGRESS)
+		return NULL;
+
+	imxdmac->status = DMA_IN_PROGRESS;
+
+	for_each_sg(sgl, sg, sg_len, i) {
+		dma_length += sg->length;
+	}
+
+	if (direction == DMA_FROM_DEVICE)
+		dmamode = DMA_MODE_READ;
+	else
+		dmamode = DMA_MODE_WRITE;
+
+	ret = imx_dma_setup_sg(imxdmac->imxdma_channel, sgl, sg_len,
+		 dma_length, imxdmac->per_address, dmamode);
+	if (ret)
+		return NULL;
+
+	return &imxdmac->desc;
+}
+
+static struct dma_async_tx_descriptor *imxdma_prep_dma_cyclic(
+		struct dma_chan *chan, dma_addr_t dma_addr, size_t buf_len,
+		size_t period_len, enum dma_data_direction direction)
+{
+	struct imxdma_channel *imxdmac = to_imxdma_chan(chan);
+	struct imxdma_engine *imxdma = imxdmac->imxdma;
+	int i, ret;
+	unsigned int periods = buf_len / period_len;
+	unsigned int dmamode;
+
+	dev_dbg(imxdma->dev, "%s channel: %d buf_len=%d period_len=%d\n",
+			__func__, imxdmac->channel, buf_len, period_len);
+
+	if (imxdmac->status == DMA_IN_PROGRESS)
+		return NULL;
+	imxdmac->status = DMA_IN_PROGRESS;
+
+	ret = imx_dma_setup_progression_handler(imxdmac->imxdma_channel,
+			imxdma_progression);
+	if (ret) {
+		dev_err(imxdma->dev, "Failed to setup the DMA handler\n");
+		return NULL;
+	}
+
+	if (imxdmac->sg_list)
+		kfree(imxdmac->sg_list);
+
+	imxdmac->sg_list = kcalloc(periods + 1,
+			sizeof(struct scatterlist), GFP_KERNEL);
+	if (!imxdmac->sg_list)
+		return NULL;
+
+	sg_init_table(imxdmac->sg_list, periods);
+
+	for (i = 0; i < periods; i++) {
+		imxdmac->sg_list[i].page_link = 0;
+		imxdmac->sg_list[i].offset = 0;
+		imxdmac->sg_list[i].dma_address = dma_addr;
+		imxdmac->sg_list[i].length = period_len;
+		dma_addr += period_len;
+	}
+
+	/* close the loop */
+	imxdmac->sg_list[periods].offset = 0;
+	imxdmac->sg_list[periods].length = 0;
+	imxdmac->sg_list[periods].page_link =
+		((unsigned long)imxdmac->sg_list | 0x01) & ~0x02;
+
+	if (direction == DMA_FROM_DEVICE)
+		dmamode = DMA_MODE_READ;
+	else
+		dmamode = DMA_MODE_WRITE;
+
+	ret = imx_dma_setup_sg(imxdmac->imxdma_channel, imxdmac->sg_list, periods,
+		 IMX_DMA_LENGTH_LOOP, imxdmac->per_address, dmamode);
+	if (ret)
+		return NULL;
+
+	return &imxdmac->desc;
+}
+
+static void imxdma_issue_pending(struct dma_chan *chan)
+{
+	/*
+	 * Nothing to do. We only have a single descriptor
+	 */
+}
+
+static int __init imxdma_probe(struct platform_device *pdev)
+{
+	struct imxdma_engine *imxdma;
+	int ret, i;
+
+	imxdma = kzalloc(sizeof(*imxdma), GFP_KERNEL);
+	if (!imxdma)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&imxdma->dma_device.channels);
+
+	/* Initialize channel parameters */
+	for (i = 0; i < MAX_DMA_CHANNELS; i++) {
+		struct imxdma_channel *imxdmac = &imxdma->channel[i];
+
+		imxdmac->imxdma_channel = imx_dma_request_by_prio("dmaengine",
+				DMA_PRIO_MEDIUM);
+		if (imxdmac->channel < 0)
+			goto err_init;
+
+		imx_dma_setup_handlers(imxdmac->imxdma_channel,
+		       imxdma_irq_handler, imxdma_err_handler, imxdmac);
+
+		imxdmac->imxdma = imxdma;
+		spin_lock_init(&imxdmac->lock);
+
+		dma_cap_set(DMA_SLAVE, imxdma->dma_device.cap_mask);
+		dma_cap_set(DMA_CYCLIC, imxdma->dma_device.cap_mask);
+
+		imxdmac->chan.device = &imxdma->dma_device;
+		imxdmac->chan.chan_id = i;
+		imxdmac->channel = i;
+
+		/* Add the channel to the DMAC list */
+		list_add_tail(&imxdmac->chan.device_node, &imxdma->dma_device.channels);
+	}
+
+	imxdma->dev = &pdev->dev;
+	imxdma->dma_device.dev = &pdev->dev;
+
+	imxdma->dma_device.device_alloc_chan_resources = imxdma_alloc_chan_resources;
+	imxdma->dma_device.device_free_chan_resources = imxdma_free_chan_resources;
+	imxdma->dma_device.device_tx_status = imxdma_tx_status;
+	imxdma->dma_device.device_prep_slave_sg = imxdma_prep_slave_sg;
+	imxdma->dma_device.device_prep_dma_cyclic = imxdma_prep_dma_cyclic;
+	imxdma->dma_device.device_control = imxdma_control;
+	imxdma->dma_device.device_issue_pending = imxdma_issue_pending;
+
+	platform_set_drvdata(pdev, imxdma);
+
+	ret = dma_async_device_register(&imxdma->dma_device);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to register\n");
+		goto err_init;
+	}
+
+	return 0;
+
+err_init:
+	while (i-- >= 0) {
+		struct imxdma_channel *imxdmac = &imxdma->channel[i];
+		imx_dma_free(imxdmac->imxdma_channel);
+	}
+
+	kfree(imxdma);
+	return ret;
+}
+
+static int __exit imxdma_remove(struct platform_device *pdev)
+{
+	struct imxdma_engine *imxdma = platform_get_drvdata(pdev);
+	int i;
+
+        dma_async_device_unregister(&imxdma->dma_device);
+
+	for (i = 0; i < MAX_DMA_CHANNELS; i++) {
+		struct imxdma_channel *imxdmac = &imxdma->channel[i];
+
+		 imx_dma_free(imxdmac->imxdma_channel);
+	}
+
+        kfree(imxdma);
+
+        return 0;
+}
+
+static struct platform_driver imxdma_driver = {
+	.driver		= {
+		.name	= "imx-dma",
+	},
+	.remove		= __exit_p(imxdma_remove),
+};
+
+static int __init imxdma_module_init(void)
+{
+	return platform_driver_probe(&imxdma_driver, imxdma_probe);
+}
+subsys_initcall(imxdma_module_init);
+
+MODULE_AUTHOR("Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>");
+MODULE_DESCRIPTION("i.MX dma driver");
+MODULE_LICENSE("GPL");
