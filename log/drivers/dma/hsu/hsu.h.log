commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/dma/hsu/hsu.h b/drivers/dma/hsu/hsu.h
index 486b023b3af0..9e5956345748 100644
--- a/drivers/dma/hsu/hsu.h
+++ b/drivers/dma/hsu/hsu.h
@@ -1,13 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Driver for the High Speed UART DMA
  *
  * Copyright (C) 2015 Intel Corporation
  *
  * Partially based on the bits found in drivers/tty/serial/mfd.c.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #ifndef __DMA_HSU_H__

commit a0d3c7c5c07cfbe00ab89438ddf82482f5a99422
Merge: ec67b14c1be4 f9114a54c1d8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 19 11:47:18 2016 -0700

    Merge tag 'dmaengine-4.7-rc1' of git://git.infradead.org/users/vkoul/slave-dma
    
    Pull dmaengine updates from Vinod Koul:
     "This time round the update brings in following changes:
    
       - new tegra driver for ADMA device
    
       - support for Xilinx AXI Direct Memory Access Engine and Xilinx AXI
         Central Direct Memory Access Engine and few updates to this driver
    
       - new cyclic capability to sun6i and few updates
    
       - slave-sg support in bcm2835
    
       - updates to many drivers like designware, hsu, mv_xor, pxa, edma,
         qcom_hidma & bam"
    
    * tag 'dmaengine-4.7-rc1' of git://git.infradead.org/users/vkoul/slave-dma: (84 commits)
      dmaengine: ioatdma: disable relaxed ordering for ioatdma
      dmaengine: of_dma: approximate an average distribution
      dmaengine: core: Use IS_ENABLED() instead of checking for built-in or module
      dmaengine: edma: Re-evaluate errors when ccerr is triggered w/o error event
      dmaengine: qcom_hidma: add support for object hierarchy
      dmaengine: qcom_hidma: add debugfs hooks
      dmaengine: qcom_hidma: implement lower level hardware interface
      dmaengine: vdma: Add clock support
      Documentation: DT: vdma: Add clock support for dmas
      dmaengine: vdma: Add config structure to differentiate dmas
      MAINTAINERS: Update Tegra DMA maintainers
      dmaengine: tegra-adma: Add support for Tegra210 ADMA
      Documentation: DT: Add binding documentation for NVIDIA ADMA
      dmaengine: vdma: Add Support for Xilinx AXI Central Direct Memory Access Engine
      Documentation: DT: vdma: update binding doc for AXI CDMA
      dmaengine: vdma: Add Support for Xilinx AXI Direct Memory Access Engine
      Documentation: DT: vdma: update binding doc for AXI DMA
      dmaengine: vdma: Rename xilinx_vdma_ prefix to xilinx_dma
      dmaengine: slave means at least one of DMA_SLAVE, DMA_CYCLIC
      dmaengine: mv_xor: Allow selecting mv_xor for mvebu only compatible SoC
      ...

commit 17b3cf4233d77698df0e5ff39303c145ac355d6a
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Mar 18 14:26:36 2016 +0200

    dmaengine: hsu: set maximum allowed segment size for DMA
    
    This tells, for example, IOMMU what the maximum size of a segment
    the DMA controller can send.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/hsu/hsu.h b/drivers/dma/hsu/hsu.h
index 578a8ee8cd05..50a9d1bda253 100644
--- a/drivers/dma/hsu/hsu.h
+++ b/drivers/dma/hsu/hsu.h
@@ -55,6 +55,10 @@
 #define HSU_CH_DCR_CHEI		BIT(23)
 #define HSU_CH_DCR_CHTOI(x)	BIT(24 + (x))
 
+/* Bits in HSU_CH_DxTSR */
+#define HSU_CH_DxTSR_MASK	GENMASK(15, 0)
+#define HSU_CH_DxTSR_TSR(x)	((x) & HSU_CH_DxTSR_MASK)
+
 struct hsu_dma_sg {
 	dma_addr_t addr;
 	unsigned int len;

commit 4f4bc0abff79dc9d7ccbd3143adbf8ad1f4fe6ab
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Mar 18 14:26:32 2016 +0200

    dmaengine: hsu: correct use of channel status register
    
    There is a typo in documentation regarding to descriptor empty bit (DESCE)
    which is set to 1 when descriptor is empty. Thus, status register at the end of
    a transfer usually returns all DESCE bits set and thus it will never be zero.
    
    Moreover, there are 2 bits (CDESC) that encode current descriptor, on which
    interrupt has been asserted. In case when we have few descriptors programmed we
    might have non-zero value.
    
    Remove DESCE and CDESC bits from DMA channel status register (HSU_CH_SR) when
    reading it.
    
    Fixes: 2b49e0c56741 ("dmaengine: append hsu DMA driver")
    Cc: stable@vger.kernel.org
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/hsu/hsu.h b/drivers/dma/hsu/hsu.h
index 578a8ee8cd05..6b070c22b1df 100644
--- a/drivers/dma/hsu/hsu.h
+++ b/drivers/dma/hsu/hsu.h
@@ -41,6 +41,9 @@
 #define HSU_CH_SR_DESCTO(x)	BIT(8 + (x))
 #define HSU_CH_SR_DESCTO_ANY	(BIT(11) | BIT(10) | BIT(9) | BIT(8))
 #define HSU_CH_SR_CHE		BIT(15)
+#define HSU_CH_SR_DESCE(x)	BIT(16 + (x))
+#define HSU_CH_SR_DESCE_ANY	(BIT(19) | BIT(18) | BIT(17) | BIT(16))
+#define HSU_CH_SR_CDESC_ANY	(BIT(31) | BIT(30))
 
 /* Bits in HSU_CH_CR */
 #define HSU_CH_CR_CHA		BIT(0)

commit f0579c8ceaf18adf1eca8b4404f9caac37208655
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Nov 17 18:00:30 2015 +0200

    dmaengine: hsu: speed up residue calculation
    
    There is no need to calculate an overall length of the descriptor each time we
    call for DMA transfer status. Instead we do this at descriptor allocation stage
    and keep the stored length for further usage.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/hsu/hsu.h b/drivers/dma/hsu/hsu.h
index f06579c6d548..578a8ee8cd05 100644
--- a/drivers/dma/hsu/hsu.h
+++ b/drivers/dma/hsu/hsu.h
@@ -65,6 +65,7 @@ struct hsu_dma_desc {
 	enum dma_transfer_direction direction;
 	struct hsu_dma_sg *sg;
 	unsigned int nents;
+	size_t length;
 	unsigned int active;
 	enum dma_status status;
 };

commit 4c97ad993d763904fc1c9e0bdc3a6dba062802a2
Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Date:   Tue Oct 13 13:29:05 2015 +0300

    dmaengine: hsu: remove platform data
    
    There are no platforms where it's not possible to calculate
    the number of channels based on IO space length, and since
    that is the only purpose for struct hsu_dma_platform_data,
    removing it.
    
    Suggested-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/dma/hsu/hsu.h b/drivers/dma/hsu/hsu.h
index eeb9fff66967..f06579c6d548 100644
--- a/drivers/dma/hsu/hsu.h
+++ b/drivers/dma/hsu/hsu.h
@@ -107,6 +107,7 @@ struct hsu_dma {
 
 	/* channels */
 	struct hsu_dma_chan		*chan;
+	unsigned short			nr_channels;
 };
 
 static inline struct hsu_dma *to_hsu_dma(struct dma_device *ddev)

commit 03734485b71129a954861f298825a490bcade986
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Jul 9 13:25:37 2015 +0300

    dmaengine: hsu: remove excessive lock
    
    All hardware accesses are done under virtual channel lock. That's why specific
    channel lock is excessive and can be removed safely. This has been tested on
    Intel Medfield and Merrifield.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/hsu/hsu.h b/drivers/dma/hsu/hsu.h
index 0275233cf550..eeb9fff66967 100644
--- a/drivers/dma/hsu/hsu.h
+++ b/drivers/dma/hsu/hsu.h
@@ -78,7 +78,6 @@ struct hsu_dma_chan {
 	struct virt_dma_chan vchan;
 
 	void __iomem *reg;
-	spinlock_t lock;
 
 	/* hardware configuration */
 	enum dma_transfer_direction direction;

commit 2b49e0c56741fca538176f66ed3c8d16ce4fccd8
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Feb 23 16:24:42 2015 +0200

    dmaengine: append hsu DMA driver
    
    The HSU DMA is developed to support High Speed UART controllers found in
    particular on Intel MID platforms such as Intel Medfield.
    
    The existing implementation is tighten to the drivers/tty/serial/mfd.c driver
    and has a lot of disadvantages. Besides that we would like to get rid of the
    old HS UART driver in regarding to extending the 8250 which supports generic
    DMAEngine API. That's why the current driver has been developed.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/dma/hsu/hsu.h b/drivers/dma/hsu/hsu.h
new file mode 100644
index 000000000000..0275233cf550
--- /dev/null
+++ b/drivers/dma/hsu/hsu.h
@@ -0,0 +1,118 @@
+/*
+ * Driver for the High Speed UART DMA
+ *
+ * Copyright (C) 2015 Intel Corporation
+ *
+ * Partially based on the bits found in drivers/tty/serial/mfd.c.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __DMA_HSU_H__
+#define __DMA_HSU_H__
+
+#include <linux/spinlock.h>
+#include <linux/dma/hsu.h>
+
+#include "../virt-dma.h"
+
+#define HSU_CH_SR		0x00			/* channel status */
+#define HSU_CH_CR		0x04			/* channel control */
+#define HSU_CH_DCR		0x08			/* descriptor control */
+#define HSU_CH_BSR		0x10			/* FIFO buffer size */
+#define HSU_CH_MTSR		0x14			/* minimum transfer size */
+#define HSU_CH_DxSAR(x)		(0x20 + 8 * (x))	/* desc start addr */
+#define HSU_CH_DxTSR(x)		(0x24 + 8 * (x))	/* desc transfer size */
+#define HSU_CH_D0SAR		0x20			/* desc 0 start addr */
+#define HSU_CH_D0TSR		0x24			/* desc 0 transfer size */
+#define HSU_CH_D1SAR		0x28
+#define HSU_CH_D1TSR		0x2c
+#define HSU_CH_D2SAR		0x30
+#define HSU_CH_D2TSR		0x34
+#define HSU_CH_D3SAR		0x38
+#define HSU_CH_D3TSR		0x3c
+
+#define HSU_DMA_CHAN_NR_DESC	4
+#define HSU_DMA_CHAN_LENGTH	0x40
+
+/* Bits in HSU_CH_SR */
+#define HSU_CH_SR_DESCTO(x)	BIT(8 + (x))
+#define HSU_CH_SR_DESCTO_ANY	(BIT(11) | BIT(10) | BIT(9) | BIT(8))
+#define HSU_CH_SR_CHE		BIT(15)
+
+/* Bits in HSU_CH_CR */
+#define HSU_CH_CR_CHA		BIT(0)
+#define HSU_CH_CR_CHD		BIT(1)
+
+/* Bits in HSU_CH_DCR */
+#define HSU_CH_DCR_DESCA(x)	BIT(0 + (x))
+#define HSU_CH_DCR_CHSOD(x)	BIT(8 + (x))
+#define HSU_CH_DCR_CHSOTO	BIT(14)
+#define HSU_CH_DCR_CHSOE	BIT(15)
+#define HSU_CH_DCR_CHDI(x)	BIT(16 + (x))
+#define HSU_CH_DCR_CHEI		BIT(23)
+#define HSU_CH_DCR_CHTOI(x)	BIT(24 + (x))
+
+struct hsu_dma_sg {
+	dma_addr_t addr;
+	unsigned int len;
+};
+
+struct hsu_dma_desc {
+	struct virt_dma_desc vdesc;
+	enum dma_transfer_direction direction;
+	struct hsu_dma_sg *sg;
+	unsigned int nents;
+	unsigned int active;
+	enum dma_status status;
+};
+
+static inline struct hsu_dma_desc *to_hsu_dma_desc(struct virt_dma_desc *vdesc)
+{
+	return container_of(vdesc, struct hsu_dma_desc, vdesc);
+}
+
+struct hsu_dma_chan {
+	struct virt_dma_chan vchan;
+
+	void __iomem *reg;
+	spinlock_t lock;
+
+	/* hardware configuration */
+	enum dma_transfer_direction direction;
+	struct dma_slave_config config;
+
+	struct hsu_dma_desc *desc;
+};
+
+static inline struct hsu_dma_chan *to_hsu_dma_chan(struct dma_chan *chan)
+{
+	return container_of(chan, struct hsu_dma_chan, vchan.chan);
+}
+
+static inline u32 hsu_chan_readl(struct hsu_dma_chan *hsuc, int offset)
+{
+	return readl(hsuc->reg + offset);
+}
+
+static inline void hsu_chan_writel(struct hsu_dma_chan *hsuc, int offset,
+				   u32 value)
+{
+	writel(value, hsuc->reg + offset);
+}
+
+struct hsu_dma {
+	struct dma_device		dma;
+
+	/* channels */
+	struct hsu_dma_chan		*chan;
+};
+
+static inline struct hsu_dma *to_hsu_dma(struct dma_device *ddev)
+{
+	return container_of(ddev, struct hsu_dma, dma);
+}
+
+#endif /* __DMA_HSU_H__ */
