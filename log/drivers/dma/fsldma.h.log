commit ea2305f6a84e87b9398e043297f7982c462abf9f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 20 19:08:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 40
    
    Based on 1 normalized pattern(s):
    
      this is free software you can redistribute it and or modify it under
      the terms of the gnu general public license as published by the free
      software foundation either version 2 of the license or at your
      option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 14 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Michael Ellerman <mpe@ellerman.id.au> (powerpc)
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520170857.915677517@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index a9b12f82b5c3..56f18ae99233 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -1,15 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Copyright (C) 2007-2010 Freescale Semiconductor, Inc. All rights reserved.
  *
  * Author:
  *   Zhang Wei <wei.zhang@freescale.com>, Jul 2007
  *   Ebony Zhu <ebony.zhu@freescale.com>, May 2007
- *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
  */
 #ifndef __DMA_FSLDMA_H
 #define __DMA_FSLDMA_H

commit 6175f6a7ebc77a3c83b425fdb4fc186c771193bf
Author: Scott Wood <oss@buserror.net>
Date:   Fri Dec 21 22:34:45 2018 -0600

    dmaengine: fsldma: Add 64-bit I/O accessors for powerpc64
    
    Otherwise 64-bit PPC builds fail with undefined references
    to these accessors.
    
    Cc: Peng Ma <peng.ma@nxp.com>
    Cc: Wen He <wen.he_1@nxp.com>
    Fixes: 68997fff94afa (" dmaengine: fsldma: Adding macro FSL_DMA_IN/OUT implement for ARM platform")
    Signed-off-by: Scott Wood <oss@buserror.net>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index 88db939c04a1..a9b12f82b5c3 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -202,7 +202,12 @@ struct fsldma_chan {
 #define fsl_iowrite32(v, p)	out_le32(p, v)
 #define fsl_iowrite32be(v, p)	out_be32(p, v)
 
-#ifndef __powerpc64__
+#ifdef __powerpc64__
+#define fsl_ioread64(p)		in_le64(p)
+#define fsl_ioread64be(p)	in_be64(p)
+#define fsl_iowrite64(v, p)	out_le64(p, v)
+#define fsl_iowrite64be(v, p)	out_be64(p, v)
+#else
 static u64 fsl_ioread64(const u64 __iomem *addr)
 {
 	u32 fsl_addr = lower_32_bits(addr);

commit a1ff82a9c165ba26f0e2f4771d0490c513056428
Author: Peng Ma <peng.ma@nxp.com>
Date:   Tue Oct 30 10:35:59 2018 +0800

    dmaengine: fsldma: Adding macro FSL_DMA_IN/OUT implement for ARM platform
    
    This patch add the macro FSL_DMA_IN/OUT implement for ARM platform.
    
    Signed-off-by: Wen He <wen.he_1@nxp.com>
    Signed-off-by: Peng Ma <peng.ma@nxp.com>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index 982845b830c7..88db939c04a1 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -196,39 +196,62 @@ struct fsldma_chan {
 #define to_fsl_desc(lh) container_of(lh, struct fsl_desc_sw, node)
 #define tx_to_fsl_desc(tx) container_of(tx, struct fsl_desc_sw, async_tx)
 
+#ifdef	CONFIG_PPC
+#define fsl_ioread32(p)		in_le32(p)
+#define fsl_ioread32be(p)	in_be32(p)
+#define fsl_iowrite32(v, p)	out_le32(p, v)
+#define fsl_iowrite32be(v, p)	out_be32(p, v)
+
 #ifndef __powerpc64__
-static u64 in_be64(const u64 __iomem *addr)
+static u64 fsl_ioread64(const u64 __iomem *addr)
 {
-	return ((u64)in_be32((u32 __iomem *)addr) << 32) |
-		(in_be32((u32 __iomem *)addr + 1));
+	u32 fsl_addr = lower_32_bits(addr);
+	u64 fsl_addr_hi = (u64)in_le32((u32 *)(fsl_addr + 1)) << 32;
+
+	return fsl_addr_hi | in_le32((u32 *)fsl_addr);
 }
 
-static void out_be64(u64 __iomem *addr, u64 val)
+static void fsl_iowrite64(u64 val, u64 __iomem *addr)
 {
-	out_be32((u32 __iomem *)addr, val >> 32);
-	out_be32((u32 __iomem *)addr + 1, (u32)val);
+	out_le32((u32 __iomem *)addr + 1, val >> 32);
+	out_le32((u32 __iomem *)addr, (u32)val);
 }
 
-/* There is no asm instructions for 64 bits reverse loads and stores */
-static u64 in_le64(const u64 __iomem *addr)
+static u64 fsl_ioread64be(const u64 __iomem *addr)
 {
-	return ((u64)in_le32((u32 __iomem *)addr + 1) << 32) |
-		(in_le32((u32 __iomem *)addr));
+	u32 fsl_addr = lower_32_bits(addr);
+	u64 fsl_addr_hi = (u64)in_be32((u32 *)fsl_addr) << 32;
+
+	return fsl_addr_hi | in_be32((u32 *)(fsl_addr + 1));
 }
 
-static void out_le64(u64 __iomem *addr, u64 val)
+static void fsl_iowrite64be(u64 val, u64 __iomem *addr)
 {
-	out_le32((u32 __iomem *)addr + 1, val >> 32);
-	out_le32((u32 __iomem *)addr, (u32)val);
+	out_be32((u32 __iomem *)addr, val >> 32);
+	out_be32((u32 __iomem *)addr + 1, (u32)val);
 }
 #endif
+#endif
 
-#define FSL_DMA_IN(fsl_chan, addr, width)				\
-		(((fsl_chan)->feature & FSL_DMA_BIG_ENDIAN) ?		\
-			in_be##width(addr) : in_le##width(addr))
-#define FSL_DMA_OUT(fsl_chan, addr, val, width)			\
-		(((fsl_chan)->feature & FSL_DMA_BIG_ENDIAN) ?		\
-			out_be##width(addr, val) : out_le##width(addr, val))
+#if defined(CONFIG_ARM64) || defined(CONFIG_ARM)
+#define fsl_ioread32(p)		ioread32(p)
+#define fsl_ioread32be(p)	ioread32be(p)
+#define fsl_iowrite32(v, p)	iowrite32(v, p)
+#define fsl_iowrite32be(v, p)	iowrite32be(v, p)
+#define fsl_ioread64(p)		ioread64(p)
+#define fsl_ioread64be(p)	ioread64be(p)
+#define fsl_iowrite64(v, p)	iowrite64(v, p)
+#define fsl_iowrite64be(v, p)	iowrite64be(v, p)
+#endif
+
+#define FSL_DMA_IN(fsl_dma, addr, width)			\
+		(((fsl_dma)->feature & FSL_DMA_BIG_ENDIAN) ?	\
+			fsl_ioread##width##be(addr) : fsl_ioread##width(addr))
+
+#define FSL_DMA_OUT(fsl_dma, addr, val, width)			\
+		(((fsl_dma)->feature & FSL_DMA_BIG_ENDIAN) ?	\
+			fsl_iowrite##width##be(val, addr) : fsl_iowrite	\
+		##width(val, addr))
 
 #define DMA_TO_CPU(fsl_chan, d, width)					\
 		(((fsl_chan)->feature & FSL_DMA_BIG_ENDIAN) ?		\

commit a7359e762fdd6eea432fefd9d38851540192e7e3
Author: Wen He <wen.he_1@nxp.com>
Date:   Tue Oct 30 10:35:58 2018 +0800

    dmaengine: fsldma: Replace DMA_IN/OUT by FSL_DMA_IN/OUT
    
    This patch implement a standard macro call functions is
    used to NXP dma drivers.
    
    Signed-off-by: Wen He <wen.he_1@nxp.com>
    Signed-off-by: Peng Ma <peng.ma@nxp.com>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index 4787d485dd76..982845b830c7 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -223,10 +223,10 @@ static void out_le64(u64 __iomem *addr, u64 val)
 }
 #endif
 
-#define DMA_IN(fsl_chan, addr, width)					\
+#define FSL_DMA_IN(fsl_chan, addr, width)				\
 		(((fsl_chan)->feature & FSL_DMA_BIG_ENDIAN) ?		\
 			in_be##width(addr) : in_le##width(addr))
-#define DMA_OUT(fsl_chan, addr, val, width)				\
+#define FSL_DMA_OUT(fsl_chan, addr, val, width)			\
 		(((fsl_chan)->feature & FSL_DMA_BIG_ENDIAN) ?		\
 			out_be##width(addr, val) : out_le##width(addr, val))
 

commit ccc077292733f3143b444255fa5ec49a8ff2763b
Author: Thomas Breitung <thomas.breitung@izt-labs.de>
Date:   Mon Jun 19 16:40:04 2017 +0200

    dmaengine: fsldma: set BWC, DAHTS and SAHTS values correctly
    
    The bits of BWC, DAHTS and SAHTS in the DMA mode register must be cleared
    before a new value can be or-ed in.
    
    Signed-off-by: Thomas Breitung <thomas.breitung@izt-labs.de>
    Signed-off-by: Wolfgang Ocker <weo@reccoware.de>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index 31bffccdcc75..4787d485dd76 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -36,6 +36,10 @@
 #define FSL_DMA_MR_DAHE		0x00002000
 #define FSL_DMA_MR_SAHE		0x00001000
 
+#define FSL_DMA_MR_SAHTS_MASK	0x0000C000
+#define FSL_DMA_MR_DAHTS_MASK	0x00030000
+#define FSL_DMA_MR_BWC_MASK	0x0f000000
+
 /*
  * Bandwidth/pause control determines how many bytes a given
  * channel is allowed to transfer before the DMA engine pauses

commit 75dc1775ec83db305a68d153a7ac5eb4e8b634a0
Author: Kevin Hao <haokexin@gmail.com>
Date:   Thu Jan 8 18:38:16 2015 +0800

    dmaengine: fsldma: declare slave capabilities for the generic code
    
    Since commit ecc19d17868b ("dmaengine: Add a warning for drivers not
    using the generic slave caps retrieval"), the dma drivers are required
    to fill the caps infos in order to support generic slaves caps
    retrieval. Otherwise we will get a warning like this:
      WARNING: at drivers/dma/dmaengine.c:830
      Modules linked in:
      CPU: 0 PID: 1 Comm: swapper/0 Tainted: G        W       3.19.0-rc2-next-20150106-dirty #271
      task: c0000001f70a0000 ti: c0000001f7044000 task.ti: c0000001f7044000
      NIP: c00000000032b238 LR: c00000000032b234 CTR: c00000000001d258
      REGS: c0000001f7047330 TRAP: 0700   Tainted: G        W        (3.19.0-rc2-next-20150106-dirty)
      MSR: 0000000080029000 <CE,EE,ME>  CR: 24adbe22  XER: 20000000
      SOFTE: 1
      GPR00: c00000000032b234 c0000001f70475b0 c0000000009b4848 0000000000000040
      GPR04: 0000000000000001 0000000000000001 0000000000000000 000000000000000f
      GPR08: 0000000000000000 c000000000902988 c000000000902988 00000000000052c8
      GPR12: 0000000024adbe22 c00000000fff4000 c000000000002038 0000000000000000
      GPR16: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR20: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR24: 0000000000000000 0000000000000000 c000000000972dc8 c0000000007e6fd0
      GPR28: c0000001f76d1d30 c0000001f76d1c10 c0000001f76d1c00 0000000000000000
      NIP [c00000000032b238] .dma_async_device_register+0x3f8/0x5b8
      LR [c00000000032b234] .dma_async_device_register+0x3f4/0x5b8
      Call Trace:
      [c0000001f70475b0] [c00000000032b234] .dma_async_device_register+0x3f4/0x5b8 (unreliable)
      [c0000001f70476a0] [c00000000032ca78] .fsldma_of_probe+0x298/0x438
      [c0000001f7047750] [c00000000037080c] .platform_drv_probe+0x50/0x9c
      [c0000001f70477d0] [c00000000036e74c] .really_probe+0xa4/0x29c
      [c0000001f7047870] [c00000000036eae4] .__driver_attach+0x100/0x104
      [c0000001f7047900] [c00000000036c1f0] .bus_for_each_dev+0x84/0xe4
      [c0000001f70479a0] [c00000000036e164] .driver_attach+0x24/0x38
      [c0000001f7047a10] [c00000000036dcc8] .bus_add_driver+0x1c8/0x2ac
      [c0000001f7047ab0] [c00000000036f14c] .driver_register+0x8c/0x158
      [c0000001f7047b30] [c0000000003707a8] .__platform_driver_register+0x6c/0x80
      [c0000001f7047ba0] [c000000000898a3c] .fsldma_init+0x2c/0x40
      [c0000001f7047c10] [c000000000001818] .do_one_initcall+0xb8/0x234
      [c0000001f7047d00] [c000000000878e2c] .kernel_init_freeable+0x188/0x268
      [c0000001f7047db0] [c000000000002054] .kernel_init+0x1c/0xfc8
      [c0000001f7047e30] [c000000000000884] .ret_from_kernel_thread+0x58/0xd4
      Instruction dump:
      7fb9f840 3bffffe0 409effac 7f54d378 48000060 813d0050 2f890000 40befdd0
      3c62ffe3 38632450 482f0aa9 60000000 <0fe00000> 4bfffdb8 7f03c378 482ed465
    
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index 239c20c84382..31bffccdcc75 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -83,6 +83,10 @@
 #define FSL_DMA_DGSR_EOSI	0x02
 #define FSL_DMA_DGSR_EOLSI	0x01
 
+#define FSL_DMA_BUSWIDTHS	(BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) | \
+				BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) | \
+				BIT(DMA_SLAVE_BUSWIDTH_4_BYTES) | \
+				BIT(DMA_SLAVE_BUSWIDTH_8_BYTES))
 typedef u64 __bitwise v64;
 typedef u32 __bitwise v32;
 

commit 43452fadd614b62b84e950838cb7d2419f3aafb1
Author: Hongbo Zhang <hongbo.zhang@freescale.com>
Date:   Wed May 21 16:03:03 2014 +0800

    dmaengine: Freescale: change descriptor release process for supporting async_tx
    
    Fix the potential risk when enable config NET_DMA and ASYNC_TX. Async_tx is
    lack of support in current release process of dma descriptor, all descriptors
    will be released whatever is acked or no-acked by async_tx, so there is a
    potential race condition when dma engine is uesd by others clients (e.g. when
    enable NET_DMA to offload TCP).
    
    In our case, a race condition which is raised when use both of talitos and
    dmaengine to offload xor is because napi scheduler will sync all pending
    requests in dma channels, it affects the process of raid operations due to
    ack_tx is not checked in fsl dma. The no-acked descriptor is freed which is
    submitted just now, as a dependent tx, this freed descriptor trigger
    BUG_ON(async_tx_test_ack(depend_tx)) in async_tx_submit().
    
    TASK = ee1a94a0[1390] 'md0_raid5' THREAD: ecf40000 CPU: 0
    GPR00: 00000001 ecf41ca0 ee44/921a94a0 0000003f 00000001 c00593e4 00000000 00000001
    GPR08: 00000000 a7a7a7a7 00000001 045/920000002 42028042 100a38d4 ed576d98 00000000
    GPR16: ed5a11b0 00000000 2b162000 00000200 046/920000000 2d555000 ed3015e8 c15a7aa0
    GPR24: 00000000 c155fc40 00000000 ecb63220 ecf41d28 e47/92f640bb0 ef640c30 ecf41ca0
    NIP [c02b048c] async_tx_submit+0x6c/0x2b4
    LR [c02b068c] async_tx_submit+0x26c/0x2b4
    Call Trace:
    [ecf41ca0] [c02b068c] async_tx_submit+0x26c/0x2b448/92 (unreliable)
    [ecf41cd0] [c02b0a4c] async_memcpy+0x240/0x25c
    [ecf41d20] [c0421064] async_copy_data+0xa0/0x17c
    [ecf41d70] [c0421cf4] __raid_run_ops+0x874/0xe10
    [ecf41df0] [c0426ee4] handle_stripe+0x820/0x25e8
    [ecf41e90] [c0429080] raid5d+0x3d4/0x5b4
    [ecf41f40] [c04329b8] md_thread+0x138/0x16c
    [ecf41f90] [c008277c] kthread+0x8c/0x90
    [ecf41ff0] [c0011630] kernel_thread+0x4c/0x68
    
    Another modification in this patch is the change of completed descriptors,
    there is a potential risk which caused by exception interrupt, all descriptors
    in ld_running list are seemed completed when an interrupt raised, it works fine
    under normal condition, but if there is an exception occured, it cannot work as
    our excepted. Hardware should not be depend on s/w list, the right way is to
    read current descriptor address register to find the last completed descriptor.
    If an interrupt is raised by an error, all descriptors in ld_running should not
    be seemed finished, or these unfinished descriptors in ld_running will be
    released wrongly.
    
    A simple way to reproduce:
    Enable dmatest first, then insert some bad descriptors which can trigger
    Programming Error interrupts before the good descriptors. Last, the good
    descriptors will be freed before they are processsed because of the exception
    intrerrupt.
    
    Note: the bad descriptors are only for simulating an exception interrupt.  This
    case can illustrate the potential risk in current fsl-dma very well.
    
    Signed-off-by: Hongbo Zhang <hongbo.zhang@freescale.com>
    Signed-off-by: Qiang Liu <qiang.liu@freescale.com>
    Signed-off-by: Ira W. Snyder <iws@ovro.caltech.edu>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index f2e0c4dcf901..239c20c84382 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -149,8 +149,21 @@ struct fsldma_chan {
 	char name[8];			/* Channel name */
 	struct fsldma_chan_regs __iomem *regs;
 	spinlock_t desc_lock;		/* Descriptor operation lock */
-	struct list_head ld_pending;	/* Link descriptors queue */
-	struct list_head ld_running;	/* Link descriptors queue */
+	/*
+	 * Descriptors which are queued to run, but have not yet been
+	 * submitted to the hardware for execution
+	 */
+	struct list_head ld_pending;
+	/*
+	 * Descriptors which are currently being executed by the hardware
+	 */
+	struct list_head ld_running;
+	/*
+	 * Descriptors which have finished execution by the hardware. These
+	 * descriptors have already had their cleanup actions run. They are
+	 * waiting for the ACK bit to be set by the async_tx API.
+	 */
+	struct list_head ld_completed;	/* Link descriptors queue */
 	struct dma_chan common;		/* DMA common channel */
 	struct dma_pool *desc_pool;	/* Descriptors pool */
 	struct device *dev;		/* Channel device */

commit 14c6a3333c8e885604fc98768d8b9a32e08110ac
Author: Hongbo Zhang <hongbo.zhang@freescale.com>
Date:   Wed May 21 16:03:02 2014 +0800

    dmaengine: Freescale: add suspend resume functions for DMA driver
    
    This patch adds suspend and resume functions for Freescale DMA driver.
    
    Signed-off-by: Hongbo Zhang <hongbo.zhang@freescale.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index d56e83599825..f2e0c4dcf901 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -134,6 +134,17 @@ struct fsldma_device {
 #define FSL_DMA_CHAN_PAUSE_EXT	0x00001000
 #define FSL_DMA_CHAN_START_EXT	0x00002000
 
+#ifdef CONFIG_PM
+struct fsldma_chan_regs_save {
+	u32 mr;
+};
+
+enum fsldma_pm_state {
+	RUNNING = 0,
+	SUSPENDED,
+};
+#endif
+
 struct fsldma_chan {
 	char name[8];			/* Channel name */
 	struct fsldma_chan_regs __iomem *regs;
@@ -148,6 +159,10 @@ struct fsldma_chan {
 	struct tasklet_struct tasklet;
 	u32 feature;
 	bool idle;			/* DMA controller is idle */
+#ifdef CONFIG_PM
+	struct fsldma_chan_regs_save regs_save;
+	enum fsldma_pm_state pm_state;
+#endif
 
 	void (*toggle_ext_pause)(struct fsldma_chan *fsl_chan, int enable);
 	void (*toggle_ext_start)(struct fsldma_chan *fsl_chan, int enable);

commit 0ca583a239a854fd403bf8b659cdff8c603372c9
Author: Hongbo Zhang <hongbo.zhang@freescale.com>
Date:   Thu Jan 16 14:10:53 2014 +0800

    DMA: Freescale: change BWC from 256 bytes to 1024 bytes
    
    Freescale DMA has a feature of BandWidth Control (ab. BWC), which is currently
    256 bytes and should be changed to 1024 bytes for best DMA throughput.
    Changing BWC from 256 to 1024 will improve DMA performance much, in cases
    whatever one channel is running or multi channels are running simultanously,
    large or small buffers are copied.  And this change doesn't impact memory
    access performance remarkably, lmbench tests show that for some cases the
    memory performance are decreased very slightly, while the others are even
    better.
    Tested on T4240.
    
    Signed-off-by: Hongbo Zhang <hongbo.zhang@freescale.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index 1ffc24484d23..d56e83599825 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -41,7 +41,7 @@
  * channel is allowed to transfer before the DMA engine pauses
  * the current channel and switches to the next channel
  */
-#define FSL_DMA_MR_BWC         0x08000000
+#define FSL_DMA_MR_BWC         0x0A000000
 
 /* Special MR definition for MPC8349 */
 #define FSL_DMA_MR_EOTIE	0x00000080

commit 8de7a7d95049bdbe454ade7add08d893efe5a456
Author: Hongbo Zhang <hongbo.zhang@freescale.com>
Date:   Thu Sep 26 17:33:43 2013 +0800

    DMA: Freescale: update driver to support 8-channel DMA engine
    
    This patch adds support to 8-channel DMA engine, thus the driver works for both
    the new 8-channel and the legacy 4-channel DMA engines.
    
    Signed-off-by: Hongbo Zhang <hongbo.zhang@freescale.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index f5c38791fc74..1ffc24484d23 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -112,7 +112,7 @@ struct fsldma_chan_regs {
 };
 
 struct fsldma_chan;
-#define FSL_DMA_MAX_CHANS_PER_DEVICE 4
+#define FSL_DMA_MAX_CHANS_PER_DEVICE 8
 
 struct fsldma_device {
 	void __iomem *regs;	/* DGSR register base */

commit 4d4e58de32a192fea65ab84509d17d199bd291c8
Author: Russell King - ARM Linux <linux@arm.linux.org.uk>
Date:   Tue Mar 6 22:34:06 2012 +0000

    dmaengine: move last completed cookie into generic dma_chan structure
    
    Every DMA engine implementation declares a last completed dma cookie
    in their private dma channel structures.  This is pointless, and
    forces driver specific code.  Move this out into the common dma_chan
    structure.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Jassi Brar <jassisinghbrar@gmail.com>
    [imx-sdma.c & mxs-dma.c]
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Vinod Koul <vinod.koul@linux.intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index 9cb5aa57c677..f5c38791fc74 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -137,7 +137,6 @@ struct fsldma_device {
 struct fsldma_chan {
 	char name[8];			/* Channel name */
 	struct fsldma_chan_regs __iomem *regs;
-	dma_cookie_t completed_cookie;	/* The maximum cookie completed */
 	spinlock_t desc_lock;		/* Descriptor operation lock */
 	struct list_head ld_pending;	/* Link descriptors queue */
 	struct list_head ld_running;	/* Link descriptors queue */

commit f04cd40701deace2efb9edd7120e59366bda2118
Author: Ira Snyder <iws@ovro.caltech.edu>
Date:   Thu Mar 3 07:54:58 2011 +0000

    fsldma: fix controller lockups
    
    Enabling poisoning in the dmapool API quickly showed that the DMA
    controller was fetching descriptors that should not have been in use.
    This has caused intermittent controller lockups during testing.
    
    I have been unable to figure out the exact set of conditions which cause
    this to happen. However, I believe it is related to the driver using the
    hardware registers to track whether the controller is busy or not. The
    code can incorrectly decide that the hardware is idle due to lag between
    register writes and the hardware actually becoming busy.
    
    To fix this, the driver has been reworked to explicitly track the state
    of the hardware, rather than try to guess what it is doing based on the
    register values.
    
    This has passed dmatest with 10 threads per channel, 100000 iterations
    per thread several times without error. Previously, this would fail
    within a few seconds.
    
    Signed-off-by: Ira W. Snyder <iws@ovro.caltech.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index 49189dacd5f4..9cb5aa57c677 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -148,6 +148,7 @@ struct fsldma_chan {
 	int id;				/* Raw id of this channel */
 	struct tasklet_struct tasklet;
 	u32 feature;
+	bool idle;			/* DMA controller is idle */
 
 	void (*toggle_ext_pause)(struct fsldma_chan *fsl_chan, int enable);
 	void (*toggle_ext_start)(struct fsldma_chan *fsl_chan, int enable);

commit 31f4306c83a2daa3e348056b720de511bffe5a9b
Author: Ira Snyder <iws@ovro.caltech.edu>
Date:   Thu Mar 3 07:54:57 2011 +0000

    fsldma: minor codingstyle and consistency fixes
    
    This fixes some minor violations of the coding style. It also changes
    the style of the device_prep_dma_*() function definitions so they are
    identical.
    
    Signed-off-by: Ira W. Snyder <iws@ovro.caltech.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index 113e7134010b..49189dacd5f4 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -102,8 +102,8 @@ struct fsl_desc_sw {
 } __attribute__((aligned(32)));
 
 struct fsldma_chan_regs {
-	u32 mr;	/* 0x00 - Mode Register */
-	u32 sr;	/* 0x04 - Status Register */
+	u32 mr;		/* 0x00 - Mode Register */
+	u32 sr;		/* 0x04 - Status Register */
 	u64 cdar;	/* 0x08 - Current descriptor address register */
 	u64 sar;	/* 0x10 - Source Address Register */
 	u64 dar;	/* 0x18 - Destination Address Register */

commit b158471ef63bf399165db96e945a828096502d9d
Author: Ira Snyder <iws@ovro.caltech.edu>
Date:   Thu Mar 3 07:54:55 2011 +0000

    fsldma: use channel name in printk output
    
    This makes debugging the driver much easier when multiple channels are
    running concurrently. In addition, you can see how much descriptor
    memory each channel has allocated via the dmapool API in sysfs.
    
    Signed-off-by: Ira W. Snyder <iws@ovro.caltech.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index ba9f403c0fbe..113e7134010b 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -135,6 +135,7 @@ struct fsldma_device {
 #define FSL_DMA_CHAN_START_EXT	0x00002000
 
 struct fsldma_chan {
+	char name[8];			/* Channel name */
 	struct fsldma_chan_regs __iomem *regs;
 	dma_cookie_t completed_cookie;	/* The maximum cookie completed */
 	spinlock_t desc_lock;		/* Descriptor operation lock */

commit f3c677b997757326e1f29d33060719a6a5091950
Author: Forrest Shi <b29237@freescale.com>
Date:   Thu Dec 9 16:14:04 2010 +0800

    fsldma: fix issue of slow dma
    
    Fixed fsl dma slow issue by initializing dma mode register with
    bandwidth control. It boosts dma performance and should works
    with 85xx board.
    
    Signed-off-by: Forrest Shi <b29237@freescale.com>
    Signed-off-by: Li Yang <leoli@freescale.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index cb4d6ff51597..ba9f403c0fbe 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2007 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright (C) 2007-2010 Freescale Semiconductor, Inc. All rights reserved.
  *
  * Author:
  *   Zhang Wei <wei.zhang@freescale.com>, Jul 2007
@@ -36,6 +36,13 @@
 #define FSL_DMA_MR_DAHE		0x00002000
 #define FSL_DMA_MR_SAHE		0x00001000
 
+/*
+ * Bandwidth/pause control determines how many bytes a given
+ * channel is allowed to transfer before the DMA engine pauses
+ * the current channel and switches to the next channel
+ */
+#define FSL_DMA_MR_BWC         0x08000000
+
 /* Special MR definition for MPC8349 */
 #define FSL_DMA_MR_EOTIE	0x00000080
 #define FSL_DMA_MR_PRC_RM	0x00000800

commit 9c3a50b7d7ec45da34e73cac66cde12dd6092dd8
Author: Ira Snyder <iws@ovro.caltech.edu>
Date:   Wed Jan 6 13:34:06 2010 +0000

    fsldma: major cleanups and fixes
    
    Fix locking. Use two queues in the driver, one for pending transacions, and
    one for transactions which are actually running on the hardware. Call
    dma_run_dependencies() on descriptor cleanup so that the async_tx API works
    correctly.
    
    There are a number of places throughout the code where lists of descriptors
    are freed in a loop. Create functions to handle this, and use them instead
    of open-coding the loop each time.
    
    Signed-off-by: Ira W. Snyder <iws@ovro.caltech.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index ea3b19c8708c..cb4d6ff51597 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -131,7 +131,8 @@ struct fsldma_chan {
 	struct fsldma_chan_regs __iomem *regs;
 	dma_cookie_t completed_cookie;	/* The maximum cookie completed */
 	spinlock_t desc_lock;		/* Descriptor operation lock */
-	struct list_head ld_queue;	/* Link descriptors queue */
+	struct list_head ld_pending;	/* Link descriptors queue */
+	struct list_head ld_running;	/* Link descriptors queue */
 	struct dma_chan common;		/* DMA common channel */
 	struct dma_pool *desc_pool;	/* Descriptors pool */
 	struct device *dev;		/* Channel device */

commit e7a29151de1bd52081f27f149b68074fac0323be
Author: Ira Snyder <iws@ovro.caltech.edu>
Date:   Wed Jan 6 13:34:03 2010 +0000

    fsldma: clean up the OF subsystem routines
    
    This fixes some errors in the cleanup paths of the OF subsystem, including
    missing checks for ioremap failing. Also, some variables were renamed for
    brevity.
    
    Signed-off-by: Ira W. Snyder <iws@ovro.caltech.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index a67b8e3df0fa..ea3b19c8708c 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -108,7 +108,7 @@ struct fsldma_chan;
 #define FSL_DMA_MAX_CHANS_PER_DEVICE 4
 
 struct fsldma_device {
-	void __iomem *reg_base;	/* DGSR register base */
+	void __iomem *regs;	/* DGSR register base */
 	struct device *dev;
 	struct dma_device common;
 	struct fsldma_chan *chan[FSL_DMA_MAX_CHANS_PER_DEVICE];
@@ -128,7 +128,7 @@ struct fsldma_device {
 #define FSL_DMA_CHAN_START_EXT	0x00002000
 
 struct fsldma_chan {
-	struct fsldma_chan_regs __iomem *reg_base;
+	struct fsldma_chan_regs __iomem *regs;
 	dma_cookie_t completed_cookie;	/* The maximum cookie completed */
 	spinlock_t desc_lock;		/* Descriptor operation lock */
 	struct list_head ld_queue;	/* Link descriptors queue */

commit 738f5f7e1ae876448cb7d9c82bea258b69386647
Author: Ira Snyder <iws@ovro.caltech.edu>
Date:   Wed Jan 6 13:34:02 2010 +0000

    fsldma: rename dest to dst for uniformity
    
    Most functions in the standard library use "dst" as a parameter, rather
    than "dest". This renames all use of "dest" to "dst" to match the usual
    convention.
    
    Signed-off-by: Ira W. Snyder <iws@ovro.caltech.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index f8c2baa6f41e..a67b8e3df0fa 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -143,7 +143,7 @@ struct fsldma_chan {
 	void (*toggle_ext_pause)(struct fsldma_chan *fsl_chan, int enable);
 	void (*toggle_ext_start)(struct fsldma_chan *fsl_chan, int enable);
 	void (*set_src_loop_size)(struct fsldma_chan *fsl_chan, int size);
-	void (*set_dest_loop_size)(struct fsldma_chan *fsl_chan, int size);
+	void (*set_dst_loop_size)(struct fsldma_chan *fsl_chan, int size);
 	void (*set_request_count)(struct fsldma_chan *fsl_chan, int size);
 };
 

commit a4f56d4b103d4e5d1a59a9118db0185a6bd1a83b
Author: Ira Snyder <iws@ovro.caltech.edu>
Date:   Wed Jan 6 13:34:01 2010 +0000

    fsldma: rename struct fsl_dma_chan to struct fsldma_chan
    
    This is the beginning of a cleanup which will change all instances of
    "fsl_dma" to "fsldma" to match the name of the driver itself.
    
    Signed-off-by: Ira W. Snyder <iws@ovro.caltech.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index dbb5b5cce4c2..f8c2baa6f41e 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -94,7 +94,7 @@ struct fsl_desc_sw {
 	struct dma_async_tx_descriptor async_tx;
 } __attribute__((aligned(32)));
 
-struct fsl_dma_chan_regs {
+struct fsldma_chan_regs {
 	u32 mr;	/* 0x00 - Mode Register */
 	u32 sr;	/* 0x04 - Status Register */
 	u64 cdar;	/* 0x08 - Current descriptor address register */
@@ -104,19 +104,19 @@ struct fsl_dma_chan_regs {
 	u64 ndar;	/* 0x24 - Next Descriptor Address Register */
 };
 
-struct fsl_dma_chan;
+struct fsldma_chan;
 #define FSL_DMA_MAX_CHANS_PER_DEVICE 4
 
-struct fsl_dma_device {
+struct fsldma_device {
 	void __iomem *reg_base;	/* DGSR register base */
 	struct device *dev;
 	struct dma_device common;
-	struct fsl_dma_chan *chan[FSL_DMA_MAX_CHANS_PER_DEVICE];
+	struct fsldma_chan *chan[FSL_DMA_MAX_CHANS_PER_DEVICE];
 	u32 feature;		/* The same as DMA channels */
 	int irq;		/* Channel IRQ */
 };
 
-/* Define macros for fsl_dma_chan->feature property */
+/* Define macros for fsldma_chan->feature property */
 #define FSL_DMA_LITTLE_ENDIAN	0x00000000
 #define FSL_DMA_BIG_ENDIAN	0x00000001
 
@@ -127,8 +127,8 @@ struct fsl_dma_device {
 #define FSL_DMA_CHAN_PAUSE_EXT	0x00001000
 #define FSL_DMA_CHAN_START_EXT	0x00002000
 
-struct fsl_dma_chan {
-	struct fsl_dma_chan_regs __iomem *reg_base;
+struct fsldma_chan {
+	struct fsldma_chan_regs __iomem *reg_base;
 	dma_cookie_t completed_cookie;	/* The maximum cookie completed */
 	spinlock_t desc_lock;		/* Descriptor operation lock */
 	struct list_head ld_queue;	/* Link descriptors queue */
@@ -140,14 +140,14 @@ struct fsl_dma_chan {
 	struct tasklet_struct tasklet;
 	u32 feature;
 
-	void (*toggle_ext_pause)(struct fsl_dma_chan *fsl_chan, int enable);
-	void (*toggle_ext_start)(struct fsl_dma_chan *fsl_chan, int enable);
-	void (*set_src_loop_size)(struct fsl_dma_chan *fsl_chan, int size);
-	void (*set_dest_loop_size)(struct fsl_dma_chan *fsl_chan, int size);
-	void (*set_request_count)(struct fsl_dma_chan *fsl_chan, int size);
+	void (*toggle_ext_pause)(struct fsldma_chan *fsl_chan, int enable);
+	void (*toggle_ext_start)(struct fsldma_chan *fsl_chan, int enable);
+	void (*set_src_loop_size)(struct fsldma_chan *fsl_chan, int size);
+	void (*set_dest_loop_size)(struct fsldma_chan *fsl_chan, int size);
+	void (*set_request_count)(struct fsldma_chan *fsl_chan, int size);
 };
 
-#define to_fsl_chan(chan) container_of(chan, struct fsl_dma_chan, common)
+#define to_fsl_chan(chan) container_of(chan, struct fsldma_chan, common)
 #define to_fsl_desc(lh) container_of(lh, struct fsl_desc_sw, node)
 #define tx_to_fsl_desc(tx) container_of(tx, struct fsl_desc_sw, async_tx)
 

commit 4ce0e953f6286777452bf07c83056342d6b9b257
Author: Ira Snyder <iws@ovro.caltech.edu>
Date:   Wed Jan 6 13:34:00 2010 +0000

    fsldma: remove unused structure members
    
    Remove some unused members from the fsldma data structures. A few trivial
    uses of struct resource were converted to use the stack rather than keeping
    the memory allocated for the lifetime of the driver.
    
    Signed-off-by: Ira W. Snyder <iws@ovro.caltech.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index 0df14cbb8ca3..dbb5b5cce4c2 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -92,8 +92,6 @@ struct fsl_desc_sw {
 	struct list_head node;
 	struct list_head tx_list;
 	struct dma_async_tx_descriptor async_tx;
-	struct list_head *ld;
-	void *priv;
 } __attribute__((aligned(32)));
 
 struct fsl_dma_chan_regs {
@@ -111,7 +109,6 @@ struct fsl_dma_chan;
 
 struct fsl_dma_device {
 	void __iomem *reg_base;	/* DGSR register base */
-	struct resource reg;	/* Resource for register */
 	struct device *dev;
 	struct dma_device common;
 	struct fsl_dma_chan *chan[FSL_DMA_MAX_CHANS_PER_DEVICE];
@@ -138,7 +135,6 @@ struct fsl_dma_chan {
 	struct dma_chan common;		/* DMA common channel */
 	struct dma_pool *desc_pool;	/* Descriptors pool */
 	struct device *dev;		/* Channel device */
-	struct resource reg;		/* Resource for register */
 	int irq;			/* Channel IRQ */
 	int id;				/* Raw id of this channel */
 	struct tasklet_struct tasklet;

commit e6c7ecb64e08ef346cb7062b4a5421f00bc602bd
Author: Ira Snyder <iws@ovro.caltech.edu>
Date:   Tue Sep 8 17:53:04 2009 -0700

    fsldma: split apart external pause and request count features
    
    When using the Freescale DMA controller in external control mode, both the
    request count and external pause bits need to be setup correctly. This was
    being done with the same function.
    
    The 83xx controller lacks the external pause feature, but has a similar
    feature called external start. This feature requires that the request count
    bits be setup correctly.
    
    Split the function into two parts, to make it possible to use the external
    start feature on the 83xx controller.
    
    Signed-off-by: Ira W. Snyder <iws@ovro.caltech.edu>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index 4493afed53f0..0df14cbb8ca3 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -144,10 +144,11 @@ struct fsl_dma_chan {
 	struct tasklet_struct tasklet;
 	u32 feature;
 
-	void (*toggle_ext_pause)(struct fsl_dma_chan *fsl_chan, int size);
+	void (*toggle_ext_pause)(struct fsl_dma_chan *fsl_chan, int enable);
 	void (*toggle_ext_start)(struct fsl_dma_chan *fsl_chan, int enable);
 	void (*set_src_loop_size)(struct fsl_dma_chan *fsl_chan, int size);
 	void (*set_dest_loop_size)(struct fsl_dma_chan *fsl_chan, int size);
+	void (*set_request_count)(struct fsl_dma_chan *fsl_chan, int size);
 };
 
 #define to_fsl_chan(chan) container_of(chan, struct fsl_dma_chan, common)

commit eda34234578fd822c950fd06b5c5ff7ac08b3001
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Sep 8 17:53:02 2009 -0700

    fsldma: implement a private tx_list
    
    Drop fsldma's use of tx_list from struct dma_async_tx_descriptor in
    preparation for removal of this field.
    
    Cc: Li Yang <leoli@freescale.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index dc7f26865797..4493afed53f0 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -90,6 +90,7 @@ struct fsl_dma_ld_hw {
 struct fsl_desc_sw {
 	struct fsl_dma_ld_hw hw;
 	struct list_head node;
+	struct list_head tx_list;
 	struct dma_async_tx_descriptor async_tx;
 	struct list_head *ld;
 	void *priv;

commit a7aea373b4ca428f1be2c1fedd2f26c8e3f2864d
Author: Ira W. Snyder <iws@ovro.caltech.edu>
Date:   Thu Apr 23 16:17:54 2009 -0700

    fsldma: use PCI Read Multiple command
    
    By default, the Freescale 83xx DMA controller uses the PCI Read Line
    command when reading data over the PCI bus. Setting the controller to use
    the PCI Read Multiple command instead allows the controller to read much
    larger bursts of data, which provides a drastic speed increase.
    
    The slowdown due to using PCI Read Line was only observed when a PCI-to-PCI
    bridge was between the devices trying to communicate.
    
    A simple test driver showed an increase from 4MB/sec to 116MB/sec when
    performing DMA over the PCI bus. Using DMA to transfer between blocks of
    local SDRAM showed no change in performance with this patch. The dmatest
    driver was also used to verify the correctness of the transfers, and showed
    no errors.
    
    Signed-off-by: Ira W. Snyder <iws@ovro.caltech.edu>
    Acked-by: Timur Tabi <timur@freescale.com>
    Acked-by: Kumar Gala <galak@kernel.crashing.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index 4f21a512d848..dc7f26865797 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -38,6 +38,7 @@
 
 /* Special MR definition for MPC8349 */
 #define FSL_DMA_MR_EOTIE	0x00000080
+#define FSL_DMA_MR_PRC_RM	0x00000800
 
 #define FSL_DMA_SR_CH		0x00000020
 #define FSL_DMA_SR_PE		0x00000010

commit 77cd62e8082b9743b59ee1946a4c3ee2e3cd2bce
Author: Timur Tabi <timur@freescale.com>
Date:   Fri Sep 26 17:00:11 2008 -0700

    fsldma: allow Freescale Elo DMA driver to be compiled as a module
    
    Modify the Freescale Elo / Elo Plus DMA driver so that it can be compiled as
    a module.
    
    The primary change is to stop treating the DMA controller as a bus, and the
    DMA channels as devices on the bus.  This is because the Open Firmware (OF)
    kernel code does not allow busses to be removed, so although we can call
    of_platform_bus_probe() to probe the DMA channels, there is no
    of_platform_bus_remove().  Instead, the DMA channels are manually probed,
    similar to what fsl_elbc_nand.c does.
    
    Cc: Scott Wood <scottwood@freescale.com>
    Acked-by: Li Yang <leoli@freescale.com>
    Signed-off-by: Timur Tabi <timur@freescale.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index 6faf07ba0d0e..4f21a512d848 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -114,6 +114,7 @@ struct fsl_dma_device {
 	struct dma_device common;
 	struct fsl_dma_chan *chan[FSL_DMA_MAX_CHANS_PER_DEVICE];
 	u32 feature;		/* The same as DMA channels */
+	int irq;		/* Channel IRQ */
 };
 
 /* Define macros for fsl_dma_chan->feature property */

commit a4e6d5d3817ebae167e78e5957cd9e624be200c7
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Mar 29 03:10:18 2008 +0000

    fix the broken annotations in fsldma
    
     a) every bitwise declaration will give a unique type; use typedefs.
    
     b) no need to bother with the stuff pointed to by iomem pointers,
        unless it's accessed directly.  noderef will force us to use helpers
        anyway.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index fddd6aee2a63..6faf07ba0d0e 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -75,12 +75,15 @@
 #define FSL_DMA_DGSR_EOSI	0x02
 #define FSL_DMA_DGSR_EOLSI	0x01
 
+typedef u64 __bitwise v64;
+typedef u32 __bitwise v32;
+
 struct fsl_dma_ld_hw {
-	u64 __bitwise	src_addr;
-	u64 __bitwise	dst_addr;
-	u64 __bitwise	next_ln_addr;
-	u32 __bitwise	count;
-	u32 __bitwise	reserve;
+	v64 src_addr;
+	v64 dst_addr;
+	v64 next_ln_addr;
+	v32 count;
+	v32 reserve;
 } __attribute__((aligned(32)));
 
 struct fsl_desc_sw {
@@ -92,13 +95,13 @@ struct fsl_desc_sw {
 } __attribute__((aligned(32)));
 
 struct fsl_dma_chan_regs {
-	u32 __bitwise	mr;	/* 0x00 - Mode Register */
-	u32 __bitwise	sr;	/* 0x04 - Status Register */
-	u64 __bitwise	cdar;	/* 0x08 - Current descriptor address register */
-	u64 __bitwise	sar;	/* 0x10 - Source Address Register */
-	u64 __bitwise	dar;	/* 0x18 - Destination Address Register */
-	u32 __bitwise	bcr;	/* 0x20 - Byte Count Register */
-	u64 __bitwise	ndar;	/* 0x24 - Next Descriptor Address Register */
+	u32 mr;	/* 0x00 - Mode Register */
+	u32 sr;	/* 0x04 - Status Register */
+	u64 cdar;	/* 0x08 - Current descriptor address register */
+	u64 sar;	/* 0x10 - Source Address Register */
+	u64 dar;	/* 0x18 - Destination Address Register */
+	u32 bcr;	/* 0x20 - Byte Count Register */
+	u64 ndar;	/* 0x24 - Next Descriptor Address Register */
 };
 
 struct fsl_dma_chan;
@@ -151,25 +154,27 @@ struct fsl_dma_chan {
 #ifndef __powerpc64__
 static u64 in_be64(const u64 __iomem *addr)
 {
-	return ((u64)in_be32((u32 *)addr) << 32) | (in_be32((u32 *)addr + 1));
+	return ((u64)in_be32((u32 __iomem *)addr) << 32) |
+		(in_be32((u32 __iomem *)addr + 1));
 }
 
 static void out_be64(u64 __iomem *addr, u64 val)
 {
-	out_be32((u32 *)addr, val >> 32);
-	out_be32((u32 *)addr + 1, (u32)val);
+	out_be32((u32 __iomem *)addr, val >> 32);
+	out_be32((u32 __iomem *)addr + 1, (u32)val);
 }
 
 /* There is no asm instructions for 64 bits reverse loads and stores */
 static u64 in_le64(const u64 __iomem *addr)
 {
-	return ((u64)in_le32((u32 *)addr + 1) << 32) | (in_le32((u32 *)addr));
+	return ((u64)in_le32((u32 __iomem *)addr + 1) << 32) |
+		(in_le32((u32 __iomem *)addr));
 }
 
 static void out_le64(u64 __iomem *addr, u64 val)
 {
-	out_le32((u32 *)addr + 1, val >> 32);
-	out_le32((u32 *)addr, (u32)val);
+	out_le32((u32 __iomem *)addr + 1, val >> 32);
+	out_le32((u32 __iomem *)addr, (u32)val);
 }
 #endif
 
@@ -182,9 +187,11 @@ static void out_le64(u64 __iomem *addr, u64 val)
 
 #define DMA_TO_CPU(fsl_chan, d, width)					\
 		(((fsl_chan)->feature & FSL_DMA_BIG_ENDIAN) ?		\
-			be##width##_to_cpu(d) :	le##width##_to_cpu(d))
+			be##width##_to_cpu((__force __be##width)(v##width)d) : \
+			le##width##_to_cpu((__force __le##width)(v##width)d))
 #define CPU_TO_DMA(fsl_chan, c, width)					\
 		(((fsl_chan)->feature & FSL_DMA_BIG_ENDIAN) ?		\
-			cpu_to_be##width(c) : cpu_to_le##width(c))
+			(__force v##width)cpu_to_be##width(c) :		\
+			(__force v##width)cpu_to_le##width(c))
 
 #endif	/* __DMA_FSLDMA_H */

commit f79abb627f033c85a6088231f20c85bc4a9bd757
Author: Zhang Wei <wei.zhang@freescale.com>
Date:   Tue Mar 18 18:45:00 2008 -0700

    fsldma: Fix the DMA halt when using DMA_INTERRUPT async_tx transfer.
    
    The DMA_INTERRUPT async_tx is a NULL transfer, thus the BCR(count register)
    is 0. When the transfer started with a byte count of zero, the DMA
    controller will triger a PE(programming error) event and halt, not a normal
    interrupt. I add special codes for PE event and DMA_INTERRUPT
    async_tx testing.
    
    Signed-off-by: Zhang Wei <wei.zhang@freescale.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
index ba78c42121ba..fddd6aee2a63 100644
--- a/drivers/dma/fsldma.h
+++ b/drivers/dma/fsldma.h
@@ -40,6 +40,7 @@
 #define FSL_DMA_MR_EOTIE	0x00000080
 
 #define FSL_DMA_SR_CH		0x00000020
+#define FSL_DMA_SR_PE		0x00000010
 #define FSL_DMA_SR_CB		0x00000004
 #define FSL_DMA_SR_TE		0x00000080
 #define FSL_DMA_SR_EOSI		0x00000002

commit 173acc7ce8538f1f3040791dc622a92aadc12cf4
Author: Zhang Wei <wei.zhang@freescale.com>
Date:   Sat Mar 1 07:42:48 2008 -0700

    dmaengine: add driver for Freescale MPC85xx DMA controller
    
    The driver implements DMA engine API for Freescale MPC85xx DMA controller,
    which could be used by devices in the silicon.  The driver supports the
    Basic mode of Freescale MPC85xx DMA controller.  The MPC85xx processors
    supported include MPC8540/60, MPC8555, MPC8548, MPC8641 and so on.
    
    The MPC83xx(MPC8349, MPC8360) are also supported.
    
    [kamalesh@linux.vnet.ibm.com: build fix]
    [dan.j.williams@intel.com: merge mm fixes, rebase on async_tx-2.6.25]
    Signed-off-by: Zhang Wei <wei.zhang@freescale.com>
    Signed-off-by: Ebony Zhu <ebony.zhu@freescale.com>
    Acked-by: Kumar Gala <galak@gate.crashing.org>
    Cc: Shannon Nelson <shannon.nelson@intel.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/dma/fsldma.h b/drivers/dma/fsldma.h
new file mode 100644
index 000000000000..ba78c42121ba
--- /dev/null
+++ b/drivers/dma/fsldma.h
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2007 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Author:
+ *   Zhang Wei <wei.zhang@freescale.com>, Jul 2007
+ *   Ebony Zhu <ebony.zhu@freescale.com>, May 2007
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#ifndef __DMA_FSLDMA_H
+#define __DMA_FSLDMA_H
+
+#include <linux/device.h>
+#include <linux/dmapool.h>
+#include <linux/dmaengine.h>
+
+/* Define data structures needed by Freescale
+ * MPC8540 and MPC8349 DMA controller.
+ */
+#define FSL_DMA_MR_CS		0x00000001
+#define FSL_DMA_MR_CC		0x00000002
+#define FSL_DMA_MR_CA		0x00000008
+#define FSL_DMA_MR_EIE		0x00000040
+#define FSL_DMA_MR_XFE		0x00000020
+#define FSL_DMA_MR_EOLNIE	0x00000100
+#define FSL_DMA_MR_EOLSIE	0x00000080
+#define FSL_DMA_MR_EOSIE	0x00000200
+#define FSL_DMA_MR_CDSM		0x00000010
+#define FSL_DMA_MR_CTM		0x00000004
+#define FSL_DMA_MR_EMP_EN	0x00200000
+#define FSL_DMA_MR_EMS_EN	0x00040000
+#define FSL_DMA_MR_DAHE		0x00002000
+#define FSL_DMA_MR_SAHE		0x00001000
+
+/* Special MR definition for MPC8349 */
+#define FSL_DMA_MR_EOTIE	0x00000080
+
+#define FSL_DMA_SR_CH		0x00000020
+#define FSL_DMA_SR_CB		0x00000004
+#define FSL_DMA_SR_TE		0x00000080
+#define FSL_DMA_SR_EOSI		0x00000002
+#define FSL_DMA_SR_EOLSI	0x00000001
+#define FSL_DMA_SR_EOCDI	0x00000001
+#define FSL_DMA_SR_EOLNI	0x00000008
+
+#define FSL_DMA_SATR_SBPATMU			0x20000000
+#define FSL_DMA_SATR_STRANSINT_RIO		0x00c00000
+#define FSL_DMA_SATR_SREADTYPE_SNOOP_READ	0x00050000
+#define FSL_DMA_SATR_SREADTYPE_BP_IORH		0x00020000
+#define FSL_DMA_SATR_SREADTYPE_BP_NREAD		0x00040000
+#define FSL_DMA_SATR_SREADTYPE_BP_MREAD		0x00070000
+
+#define FSL_DMA_DATR_DBPATMU			0x20000000
+#define FSL_DMA_DATR_DTRANSINT_RIO		0x00c00000
+#define FSL_DMA_DATR_DWRITETYPE_SNOOP_WRITE	0x00050000
+#define FSL_DMA_DATR_DWRITETYPE_BP_FLUSH	0x00010000
+
+#define FSL_DMA_EOL		((u64)0x1)
+#define FSL_DMA_SNEN		((u64)0x10)
+#define FSL_DMA_EOSIE		0x8
+#define FSL_DMA_NLDA_MASK	(~(u64)0x1f)
+
+#define FSL_DMA_BCR_MAX_CNT	0x03ffffffu
+
+#define FSL_DMA_DGSR_TE		0x80
+#define FSL_DMA_DGSR_CH		0x20
+#define FSL_DMA_DGSR_PE		0x10
+#define FSL_DMA_DGSR_EOLNI	0x08
+#define FSL_DMA_DGSR_CB		0x04
+#define FSL_DMA_DGSR_EOSI	0x02
+#define FSL_DMA_DGSR_EOLSI	0x01
+
+struct fsl_dma_ld_hw {
+	u64 __bitwise	src_addr;
+	u64 __bitwise	dst_addr;
+	u64 __bitwise	next_ln_addr;
+	u32 __bitwise	count;
+	u32 __bitwise	reserve;
+} __attribute__((aligned(32)));
+
+struct fsl_desc_sw {
+	struct fsl_dma_ld_hw hw;
+	struct list_head node;
+	struct dma_async_tx_descriptor async_tx;
+	struct list_head *ld;
+	void *priv;
+} __attribute__((aligned(32)));
+
+struct fsl_dma_chan_regs {
+	u32 __bitwise	mr;	/* 0x00 - Mode Register */
+	u32 __bitwise	sr;	/* 0x04 - Status Register */
+	u64 __bitwise	cdar;	/* 0x08 - Current descriptor address register */
+	u64 __bitwise	sar;	/* 0x10 - Source Address Register */
+	u64 __bitwise	dar;	/* 0x18 - Destination Address Register */
+	u32 __bitwise	bcr;	/* 0x20 - Byte Count Register */
+	u64 __bitwise	ndar;	/* 0x24 - Next Descriptor Address Register */
+};
+
+struct fsl_dma_chan;
+#define FSL_DMA_MAX_CHANS_PER_DEVICE 4
+
+struct fsl_dma_device {
+	void __iomem *reg_base;	/* DGSR register base */
+	struct resource reg;	/* Resource for register */
+	struct device *dev;
+	struct dma_device common;
+	struct fsl_dma_chan *chan[FSL_DMA_MAX_CHANS_PER_DEVICE];
+	u32 feature;		/* The same as DMA channels */
+};
+
+/* Define macros for fsl_dma_chan->feature property */
+#define FSL_DMA_LITTLE_ENDIAN	0x00000000
+#define FSL_DMA_BIG_ENDIAN	0x00000001
+
+#define FSL_DMA_IP_MASK		0x00000ff0
+#define FSL_DMA_IP_85XX		0x00000010
+#define FSL_DMA_IP_83XX		0x00000020
+
+#define FSL_DMA_CHAN_PAUSE_EXT	0x00001000
+#define FSL_DMA_CHAN_START_EXT	0x00002000
+
+struct fsl_dma_chan {
+	struct fsl_dma_chan_regs __iomem *reg_base;
+	dma_cookie_t completed_cookie;	/* The maximum cookie completed */
+	spinlock_t desc_lock;		/* Descriptor operation lock */
+	struct list_head ld_queue;	/* Link descriptors queue */
+	struct dma_chan common;		/* DMA common channel */
+	struct dma_pool *desc_pool;	/* Descriptors pool */
+	struct device *dev;		/* Channel device */
+	struct resource reg;		/* Resource for register */
+	int irq;			/* Channel IRQ */
+	int id;				/* Raw id of this channel */
+	struct tasklet_struct tasklet;
+	u32 feature;
+
+	void (*toggle_ext_pause)(struct fsl_dma_chan *fsl_chan, int size);
+	void (*toggle_ext_start)(struct fsl_dma_chan *fsl_chan, int enable);
+	void (*set_src_loop_size)(struct fsl_dma_chan *fsl_chan, int size);
+	void (*set_dest_loop_size)(struct fsl_dma_chan *fsl_chan, int size);
+};
+
+#define to_fsl_chan(chan) container_of(chan, struct fsl_dma_chan, common)
+#define to_fsl_desc(lh) container_of(lh, struct fsl_desc_sw, node)
+#define tx_to_fsl_desc(tx) container_of(tx, struct fsl_desc_sw, async_tx)
+
+#ifndef __powerpc64__
+static u64 in_be64(const u64 __iomem *addr)
+{
+	return ((u64)in_be32((u32 *)addr) << 32) | (in_be32((u32 *)addr + 1));
+}
+
+static void out_be64(u64 __iomem *addr, u64 val)
+{
+	out_be32((u32 *)addr, val >> 32);
+	out_be32((u32 *)addr + 1, (u32)val);
+}
+
+/* There is no asm instructions for 64 bits reverse loads and stores */
+static u64 in_le64(const u64 __iomem *addr)
+{
+	return ((u64)in_le32((u32 *)addr + 1) << 32) | (in_le32((u32 *)addr));
+}
+
+static void out_le64(u64 __iomem *addr, u64 val)
+{
+	out_le32((u32 *)addr + 1, val >> 32);
+	out_le32((u32 *)addr, (u32)val);
+}
+#endif
+
+#define DMA_IN(fsl_chan, addr, width)					\
+		(((fsl_chan)->feature & FSL_DMA_BIG_ENDIAN) ?		\
+			in_be##width(addr) : in_le##width(addr))
+#define DMA_OUT(fsl_chan, addr, val, width)				\
+		(((fsl_chan)->feature & FSL_DMA_BIG_ENDIAN) ?		\
+			out_be##width(addr, val) : out_le##width(addr, val))
+
+#define DMA_TO_CPU(fsl_chan, d, width)					\
+		(((fsl_chan)->feature & FSL_DMA_BIG_ENDIAN) ?		\
+			be##width##_to_cpu(d) :	le##width##_to_cpu(d))
+#define CPU_TO_DMA(fsl_chan, c, width)					\
+		(((fsl_chan)->feature & FSL_DMA_BIG_ENDIAN) ?		\
+			cpu_to_be##width(c) : cpu_to_le##width(c))
+
+#endif	/* __DMA_FSLDMA_H */
