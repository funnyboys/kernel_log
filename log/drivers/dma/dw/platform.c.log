commit f27c22736d133baff0ab3fdc7b015d998267d817
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Sep 24 11:51:16 2019 +0300

    dmaengine: dw: platform: Mark 'hclk' clock optional
    
    On some platforms the clock can be fixed rate, always running one and
    there is no need to do anything with it.
    
    In order to support those platforms, switch to use optional clock.
    
    Fixes: f8d9ddbc2851 ("dmaengine: dw: platform: Enable iDMA 32-bit on Intel Elkhart Lake")
    Depends-on: 60b8f0ddf1a9 ("clk: Add (devm_)clk_get_optional() functions")
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Link: https://lore.kernel.org/r/20190924085116.83683-1-andriy.shevchenko@linux.intel.com
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index c90c798e5ec3..0585d749d935 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -66,7 +66,7 @@ static int dw_probe(struct platform_device *pdev)
 
 	data->chip = chip;
 
-	chip->clk = devm_clk_get(chip->dev, "hclk");
+	chip->clk = devm_clk_get_optional(chip->dev, "hclk");
 	if (IS_ERR(chip->clk))
 		return PTR_ERR(chip->clk);
 	err = clk_prepare_enable(chip->clk);

commit f5e84eae7956c694d27ddaba7113fe7d1174eff7
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Aug 20 16:15:46 2019 +0300

    dmaengine: dw: platform: Split OF helpers to separate module
    
    For better maintenance split OF helpers to the separate module.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20190820131546.75744-11-andriy.shevchenko@linux.intel.com
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index d50e038acb1e..c90c798e5ec3 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -17,116 +17,12 @@
 #include <linux/dmaengine.h>
 #include <linux/dma-mapping.h>
 #include <linux/of.h>
-#include <linux/of_dma.h>
 #include <linux/acpi.h>
 
 #include "internal.h"
 
 #define DRV_NAME	"dw_dmac"
 
-static struct dma_chan *dw_dma_of_xlate(struct of_phandle_args *dma_spec,
-					struct of_dma *ofdma)
-{
-	struct dw_dma *dw = ofdma->of_dma_data;
-	struct dw_dma_slave slave = {
-		.dma_dev = dw->dma.dev,
-	};
-	dma_cap_mask_t cap;
-
-	if (dma_spec->args_count != 3)
-		return NULL;
-
-	slave.src_id = dma_spec->args[0];
-	slave.dst_id = dma_spec->args[0];
-	slave.m_master = dma_spec->args[1];
-	slave.p_master = dma_spec->args[2];
-
-	if (WARN_ON(slave.src_id >= DW_DMA_MAX_NR_REQUESTS ||
-		    slave.dst_id >= DW_DMA_MAX_NR_REQUESTS ||
-		    slave.m_master >= dw->pdata->nr_masters ||
-		    slave.p_master >= dw->pdata->nr_masters))
-		return NULL;
-
-	dma_cap_zero(cap);
-	dma_cap_set(DMA_SLAVE, cap);
-
-	/* TODO: there should be a simpler way to do this */
-	return dma_request_channel(cap, dw_dma_filter, &slave);
-}
-
-#ifdef CONFIG_OF
-static struct dw_dma_platform_data *
-dw_dma_parse_dt(struct platform_device *pdev)
-{
-	struct device_node *np = pdev->dev.of_node;
-	struct dw_dma_platform_data *pdata;
-	u32 tmp, arr[DW_DMA_MAX_NR_MASTERS], mb[DW_DMA_MAX_NR_CHANNELS];
-	u32 nr_masters;
-	u32 nr_channels;
-
-	if (!np) {
-		dev_err(&pdev->dev, "Missing DT data\n");
-		return NULL;
-	}
-
-	if (of_property_read_u32(np, "dma-masters", &nr_masters))
-		return NULL;
-	if (nr_masters < 1 || nr_masters > DW_DMA_MAX_NR_MASTERS)
-		return NULL;
-
-	if (of_property_read_u32(np, "dma-channels", &nr_channels))
-		return NULL;
-	if (nr_channels > DW_DMA_MAX_NR_CHANNELS)
-		return NULL;
-
-	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
-	if (!pdata)
-		return NULL;
-
-	pdata->nr_masters = nr_masters;
-	pdata->nr_channels = nr_channels;
-
-	if (!of_property_read_u32(np, "chan_allocation_order", &tmp))
-		pdata->chan_allocation_order = (unsigned char)tmp;
-
-	if (!of_property_read_u32(np, "chan_priority", &tmp))
-		pdata->chan_priority = tmp;
-
-	if (!of_property_read_u32(np, "block_size", &tmp))
-		pdata->block_size = tmp;
-
-	if (!of_property_read_u32_array(np, "data-width", arr, nr_masters)) {
-		for (tmp = 0; tmp < nr_masters; tmp++)
-			pdata->data_width[tmp] = arr[tmp];
-	} else if (!of_property_read_u32_array(np, "data_width", arr, nr_masters)) {
-		for (tmp = 0; tmp < nr_masters; tmp++)
-			pdata->data_width[tmp] = BIT(arr[tmp] & 0x07);
-	}
-
-	if (!of_property_read_u32_array(np, "multi-block", mb, nr_channels)) {
-		for (tmp = 0; tmp < nr_channels; tmp++)
-			pdata->multi_block[tmp] = mb[tmp];
-	} else {
-		for (tmp = 0; tmp < nr_channels; tmp++)
-			pdata->multi_block[tmp] = 1;
-	}
-
-	if (!of_property_read_u32(np, "snps,dma-protection-control", &tmp)) {
-		if (tmp > CHAN_PROTCTL_MASK)
-			return NULL;
-		pdata->protctl = tmp;
-	}
-
-	return pdata;
-}
-#else
-static inline struct dw_dma_platform_data *
-dw_dma_parse_dt(struct platform_device *pdev)
-{
-	return NULL;
-}
-#endif
-
 static int dw_probe(struct platform_device *pdev)
 {
 	const struct dw_dma_chip_pdata *match;
@@ -185,13 +81,7 @@ static int dw_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, data);
 
-	if (pdev->dev.of_node) {
-		err = of_dma_controller_register(pdev->dev.of_node,
-						 dw_dma_of_xlate, chip->dw);
-		if (err)
-			dev_err(&pdev->dev,
-				"could not register of_dma_controller\n");
-	}
+	dw_dma_of_controller_register(chip->dw);
 
 	dw_dma_acpi_controller_register(chip->dw);
 
@@ -211,8 +101,7 @@ static int dw_remove(struct platform_device *pdev)
 
 	dw_dma_acpi_controller_free(chip->dw);
 
-	if (pdev->dev.of_node)
-		of_dma_controller_free(pdev->dev.of_node);
+	dw_dma_of_controller_free(chip->dw);
 
 	ret = data->remove(chip);
 	if (ret)

commit b685fe26e9af7318d73bf50af659a282d188a3e5
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Aug 20 16:15:45 2019 +0300

    dmaengine: dw: platform: Split ACPI helpers to separate module
    
    For better maintenance split ACPI helpers to the separate module.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20190820131546.75744-10-andriy.shevchenko@linux.intel.com
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index b8514d7895d1..d50e038acb1e 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -19,7 +19,6 @@
 #include <linux/of.h>
 #include <linux/of_dma.h>
 #include <linux/acpi.h>
-#include <linux/acpi_dma.h>
 
 #include "internal.h"
 
@@ -55,57 +54,6 @@ static struct dma_chan *dw_dma_of_xlate(struct of_phandle_args *dma_spec,
 	return dma_request_channel(cap, dw_dma_filter, &slave);
 }
 
-#ifdef CONFIG_ACPI
-static bool dw_dma_acpi_filter(struct dma_chan *chan, void *param)
-{
-	struct acpi_dma_spec *dma_spec = param;
-	struct dw_dma_slave slave = {
-		.dma_dev = dma_spec->dev,
-		.src_id = dma_spec->slave_id,
-		.dst_id = dma_spec->slave_id,
-		.m_master = 0,
-		.p_master = 1,
-	};
-
-	return dw_dma_filter(chan, &slave);
-}
-
-static void dw_dma_acpi_controller_register(struct dw_dma *dw)
-{
-	struct device *dev = dw->dma.dev;
-	struct acpi_dma_filter_info *info;
-	int ret;
-
-	if (!has_acpi_companion(dev))
-		return;
-
-	info = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);
-	if (!info)
-		return;
-
-	dma_cap_zero(info->dma_cap);
-	dma_cap_set(DMA_SLAVE, info->dma_cap);
-	info->filter_fn = dw_dma_acpi_filter;
-
-	ret = acpi_dma_controller_register(dev, acpi_dma_simple_xlate, info);
-	if (ret)
-		dev_err(dev, "could not register acpi_dma_controller\n");
-}
-
-static void dw_dma_acpi_controller_free(struct dw_dma *dw)
-{
-	struct device *dev = dw->dma.dev;
-
-	if (!has_acpi_companion(dev))
-		return;
-
-	acpi_dma_controller_free(dev);
-}
-#else /* !CONFIG_ACPI */
-static inline void dw_dma_acpi_controller_register(struct dw_dma *dw) {}
-static inline void dw_dma_acpi_controller_free(struct dw_dma *dw) {}
-#endif /* !CONFIG_ACPI */
-
 #ifdef CONFIG_OF
 static struct dw_dma_platform_data *
 dw_dma_parse_dt(struct platform_device *pdev)

commit 84da042e702347c186b84d9cc2e766f83e1814d6
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Aug 20 16:15:44 2019 +0300

    dmaengine: dw: platform: Move handle check to dw_dma_acpi_controller_register()
    
    Move ACPI handle check to the dw_dma_acpi_controller_register().
    
    While here, convert it to has_acpi_companion() which is recommended way.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20190820131546.75744-9-andriy.shevchenko@linux.intel.com
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 44fec1eabccd..b8514d7895d1 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -76,6 +76,9 @@ static void dw_dma_acpi_controller_register(struct dw_dma *dw)
 	struct acpi_dma_filter_info *info;
 	int ret;
 
+	if (!has_acpi_companion(dev))
+		return;
+
 	info = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);
 	if (!info)
 		return;
@@ -93,6 +96,9 @@ static void dw_dma_acpi_controller_free(struct dw_dma *dw)
 {
 	struct device *dev = dw->dma.dev;
 
+	if (!has_acpi_companion(dev))
+		return;
+
 	acpi_dma_controller_free(dev);
 }
 #else /* !CONFIG_ACPI */
@@ -239,8 +245,7 @@ static int dw_probe(struct platform_device *pdev)
 				"could not register of_dma_controller\n");
 	}
 
-	if (ACPI_HANDLE(&pdev->dev))
-		dw_dma_acpi_controller_register(chip->dw);
+	dw_dma_acpi_controller_register(chip->dw);
 
 	return 0;
 
@@ -256,8 +261,7 @@ static int dw_remove(struct platform_device *pdev)
 	struct dw_dma_chip *chip = data->chip;
 	int ret;
 
-	if (ACPI_HANDLE(&pdev->dev))
-		dw_dma_acpi_controller_free(chip->dw);
+	dw_dma_acpi_controller_free(chip->dw);
 
 	if (pdev->dev.of_node)
 		of_dma_controller_free(pdev->dev.of_node);

commit e7b8514e4d68bec21fc6385fa0a66797ddc34ac9
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Aug 20 16:15:43 2019 +0300

    dmaengine: dw: platform: Switch to acpi_dma_controller_register()
    
    There is a possibility to have registered ACPI DMA controller
    while it has been gone already.
    
    To avoid the potential crash, move to non-managed
    acpi_dma_controller_register().
    
    Fixes: 42c91ee71d6d ("dw_dmac: add ACPI support")
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20190820131546.75744-8-andriy.shevchenko@linux.intel.com
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 8576439d0035..44fec1eabccd 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -84,13 +84,20 @@ static void dw_dma_acpi_controller_register(struct dw_dma *dw)
 	dma_cap_set(DMA_SLAVE, info->dma_cap);
 	info->filter_fn = dw_dma_acpi_filter;
 
-	ret = devm_acpi_dma_controller_register(dev, acpi_dma_simple_xlate,
-						info);
+	ret = acpi_dma_controller_register(dev, acpi_dma_simple_xlate, info);
 	if (ret)
 		dev_err(dev, "could not register acpi_dma_controller\n");
 }
+
+static void dw_dma_acpi_controller_free(struct dw_dma *dw)
+{
+	struct device *dev = dw->dma.dev;
+
+	acpi_dma_controller_free(dev);
+}
 #else /* !CONFIG_ACPI */
 static inline void dw_dma_acpi_controller_register(struct dw_dma *dw) {}
+static inline void dw_dma_acpi_controller_free(struct dw_dma *dw) {}
 #endif /* !CONFIG_ACPI */
 
 #ifdef CONFIG_OF
@@ -249,6 +256,9 @@ static int dw_remove(struct platform_device *pdev)
 	struct dw_dma_chip *chip = data->chip;
 	int ret;
 
+	if (ACPI_HANDLE(&pdev->dev))
+		dw_dma_acpi_controller_free(chip->dw);
+
 	if (pdev->dev.of_node)
 		of_dma_controller_free(pdev->dev.of_node);
 

commit a9c56721d6ae99b22e983d0722e6b1b53a11dd59
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Aug 20 16:15:42 2019 +0300

    dmaengine: dw: platform: Use devm_platform_ioremap_resource()
    
    Use the new helper that wraps the calls to platform_get_resource()
    and devm_ioremap_resource() together.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20190820131546.75744-7-andriy.shevchenko@linux.intel.com
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 63465fd0e286..8576439d0035 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -172,7 +172,6 @@ static int dw_probe(struct platform_device *pdev)
 	struct dw_dma_chip_pdata *data;
 	struct dw_dma_chip *chip;
 	struct device *dev = &pdev->dev;
-	struct resource *mem;
 	int err;
 
 	match = device_get_match_data(dev);
@@ -191,8 +190,7 @@ static int dw_probe(struct platform_device *pdev)
 	if (chip->irq < 0)
 		return chip->irq;
 
-	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	chip->regs = devm_ioremap_resource(dev, mem);
+	chip->regs = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(chip->regs))
 		return PTR_ERR(chip->regs);
 

commit f8d9ddbc28518a0f7d39d2ce51f778759b49f73e
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Aug 20 16:15:41 2019 +0300

    dmaengine: dw: platform: Enable iDMA 32-bit on Intel Elkhart Lake
    
    IntelÂ® PSE (Programmable Services Engine) provides few DMA controllers
    to the host on Intel Elkhart Lake. Enable them in the ACPI glue driver.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20190820131546.75744-6-andriy.shevchenko@linux.intel.com
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 234abbd6359a..63465fd0e286 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -173,7 +173,6 @@ static int dw_probe(struct platform_device *pdev)
 	struct dw_dma_chip *chip;
 	struct device *dev = &pdev->dev;
 	struct resource *mem;
-	const struct dw_dma_platform_data *pdata;
 	int err;
 
 	match = device_get_match_data(dev);
@@ -201,13 +200,14 @@ static int dw_probe(struct platform_device *pdev)
 	if (err)
 		return err;
 
-	pdata = dev_get_platdata(dev);
-	if (!pdata)
-		pdata = dw_dma_parse_dt(pdev);
+	if (!data->pdata)
+		data->pdata = dev_get_platdata(dev);
+	if (!data->pdata)
+		data->pdata = dw_dma_parse_dt(pdev);
 
 	chip->dev = dev;
 	chip->id = pdev->id;
-	chip->pdata = pdata;
+	chip->pdata = data->pdata;
 
 	data->chip = chip;
 
@@ -298,6 +298,12 @@ static const struct acpi_device_id dw_dma_acpi_id_table[] = {
 	{ "INTL9C60", (kernel_ulong_t)&dw_dma_chip_pdata },
 	{ "80862286", (kernel_ulong_t)&dw_dma_chip_pdata },
 	{ "808622C0", (kernel_ulong_t)&dw_dma_chip_pdata },
+
+	/* Elkhart Lake iDMA 32-bit (PSE DMA) */
+	{ "80864BB4", (kernel_ulong_t)&idma32_chip_pdata },
+	{ "80864BB5", (kernel_ulong_t)&idma32_chip_pdata },
+	{ "80864BB6", (kernel_ulong_t)&idma32_chip_pdata },
+
 	{ }
 };
 MODULE_DEVICE_TABLE(acpi, dw_dma_acpi_id_table);

commit b3757413b91ecf4a227c5f075446afe8126d882f
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Aug 20 16:15:40 2019 +0300

    dmaengine: dw: platform: Use struct dw_dma_chip_pdata
    
    Now, when we have a generic structure for the chip and platform data,
    use it in the platform glue driver.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20190820131546.75744-5-andriy.shevchenko@linux.intel.com
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 382dfd9e9600..234abbd6359a 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -168,12 +168,22 @@ dw_dma_parse_dt(struct platform_device *pdev)
 
 static int dw_probe(struct platform_device *pdev)
 {
+	const struct dw_dma_chip_pdata *match;
+	struct dw_dma_chip_pdata *data;
 	struct dw_dma_chip *chip;
 	struct device *dev = &pdev->dev;
 	struct resource *mem;
 	const struct dw_dma_platform_data *pdata;
 	int err;
 
+	match = device_get_match_data(dev);
+	if (!match)
+		return -ENODEV;
+
+	data = devm_kmemdup(&pdev->dev, match, sizeof(*match), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
 	chip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);
 	if (!chip)
 		return -ENOMEM;
@@ -199,6 +209,8 @@ static int dw_probe(struct platform_device *pdev)
 	chip->id = pdev->id;
 	chip->pdata = pdata;
 
+	data->chip = chip;
+
 	chip->clk = devm_clk_get(chip->dev, "hclk");
 	if (IS_ERR(chip->clk))
 		return PTR_ERR(chip->clk);
@@ -208,11 +220,11 @@ static int dw_probe(struct platform_device *pdev)
 
 	pm_runtime_enable(&pdev->dev);
 
-	err = dw_dma_probe(chip);
+	err = data->probe(chip);
 	if (err)
 		goto err_dw_dma_probe;
 
-	platform_set_drvdata(pdev, chip);
+	platform_set_drvdata(pdev, data);
 
 	if (pdev->dev.of_node) {
 		err = of_dma_controller_register(pdev->dev.of_node,
@@ -235,12 +247,17 @@ static int dw_probe(struct platform_device *pdev)
 
 static int dw_remove(struct platform_device *pdev)
 {
-	struct dw_dma_chip *chip = platform_get_drvdata(pdev);
+	struct dw_dma_chip_pdata *data = platform_get_drvdata(pdev);
+	struct dw_dma_chip *chip = data->chip;
+	int ret;
 
 	if (pdev->dev.of_node)
 		of_dma_controller_free(pdev->dev.of_node);
 
-	dw_dma_remove(chip);
+	ret = data->remove(chip);
+	if (ret)
+		dev_warn(chip->dev, "can't remove device properly: %d\n", ret);
+
 	pm_runtime_disable(&pdev->dev);
 	clk_disable_unprepare(chip->clk);
 
@@ -249,7 +266,8 @@ static int dw_remove(struct platform_device *pdev)
 
 static void dw_shutdown(struct platform_device *pdev)
 {
-	struct dw_dma_chip *chip = platform_get_drvdata(pdev);
+	struct dw_dma_chip_pdata *data = platform_get_drvdata(pdev);
+	struct dw_dma_chip *chip = data->chip;
 
 	/*
 	 * We have to call do_dw_dma_disable() to stop any ongoing transfer. On
@@ -269,7 +287,7 @@ static void dw_shutdown(struct platform_device *pdev)
 
 #ifdef CONFIG_OF
 static const struct of_device_id dw_dma_of_id_table[] = {
-	{ .compatible = "snps,dma-spear1340" },
+	{ .compatible = "snps,dma-spear1340", .data = &dw_dma_chip_pdata },
 	{}
 };
 MODULE_DEVICE_TABLE(of, dw_dma_of_id_table);
@@ -277,9 +295,9 @@ MODULE_DEVICE_TABLE(of, dw_dma_of_id_table);
 
 #ifdef CONFIG_ACPI
 static const struct acpi_device_id dw_dma_acpi_id_table[] = {
-	{ "INTL9C60", 0 },
-	{ "80862286", 0 },
-	{ "808622C0", 0 },
+	{ "INTL9C60", (kernel_ulong_t)&dw_dma_chip_pdata },
+	{ "80862286", (kernel_ulong_t)&dw_dma_chip_pdata },
+	{ "808622C0", (kernel_ulong_t)&dw_dma_chip_pdata },
 	{ }
 };
 MODULE_DEVICE_TABLE(acpi, dw_dma_acpi_id_table);
@@ -289,7 +307,8 @@ MODULE_DEVICE_TABLE(acpi, dw_dma_acpi_id_table);
 
 static int dw_suspend_late(struct device *dev)
 {
-	struct dw_dma_chip *chip = dev_get_drvdata(dev);
+	struct dw_dma_chip_pdata *data = dev_get_drvdata(dev);
+	struct dw_dma_chip *chip = data->chip;
 
 	do_dw_dma_disable(chip);
 	clk_disable_unprepare(chip->clk);
@@ -299,7 +318,8 @@ static int dw_suspend_late(struct device *dev)
 
 static int dw_resume_early(struct device *dev)
 {
-	struct dw_dma_chip *chip = dev_get_drvdata(dev);
+	struct dw_dma_chip_pdata *data = dev_get_drvdata(dev);
+	struct dw_dma_chip *chip = data->chip;
 	int ret;
 
 	ret = clk_prepare_enable(chip->clk);

commit b466a37fbcc99ef79ea59e40ef6aa8391430b0d8
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jan 7 13:07:41 2019 +0200

    dmaengine: dw: convert to SPDX identifiers
    
    This patch updates license to use SPDX-License-Identifier
    instead of verbose license text.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index d5196c97e4f4..382dfd9e9600 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Platform driver for the Synopsys DesignWare DMA Controller
  *
@@ -6,10 +7,6 @@
  * Copyright (C) 2013 Intel Corporation
  *
  * Some parts of this driver are derived from the original dw_dmac.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/module.h>

commit 69da8be90d5e85e60b5377c47384154b9dabf592
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jan 7 13:07:38 2019 +0200

    dmaengine: dw: Split DW and iDMA 32-bit operations
    
    Here is a kinda big refactoring that should have been done
    in the first place, when Intel iDMA 32-bit support appeared.
    
    It splits operations which are different to Synopsys DesignWare and
    Intel iDMA 32-bit controllers.
    
    No functional change intended.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 58fc1ba02a1e..d5196c97e4f4 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -255,7 +255,7 @@ static void dw_shutdown(struct platform_device *pdev)
 	struct dw_dma_chip *chip = platform_get_drvdata(pdev);
 
 	/*
-	 * We have to call dw_dma_disable() to stop any ongoing transfer. On
+	 * We have to call do_dw_dma_disable() to stop any ongoing transfer. On
 	 * some platforms we can't do that since DMA device is powered off.
 	 * Moreover we have no possibility to check if the platform is affected
 	 * or not. That's why we call pm_runtime_get_sync() / pm_runtime_put()
@@ -264,7 +264,7 @@ static void dw_shutdown(struct platform_device *pdev)
 	 * used by the driver.
 	 */
 	pm_runtime_get_sync(chip->dev);
-	dw_dma_disable(chip);
+	do_dw_dma_disable(chip);
 	pm_runtime_put_sync_suspend(chip->dev);
 
 	clk_disable_unprepare(chip->clk);
@@ -294,7 +294,7 @@ static int dw_suspend_late(struct device *dev)
 {
 	struct dw_dma_chip *chip = dev_get_drvdata(dev);
 
-	dw_dma_disable(chip);
+	do_dw_dma_disable(chip);
 	clk_disable_unprepare(chip->clk);
 
 	return 0;
@@ -309,7 +309,7 @@ static int dw_resume_early(struct device *dev)
 	if (ret)
 		return ret;
 
-	return dw_dma_enable(chip);
+	return do_dw_dma_enable(chip);
 }
 
 #endif /* CONFIG_PM_SLEEP */

commit 078165779608873e7b6eae1316a39c73af9f3edc
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jan 7 13:07:37 2019 +0200

    dmaengine: dw: Remove unused internal property
    
    All known devices, which use DT for configuration, support
    memory-to-memory transfers. So enable it by default.
    
    The rest two cases, i.e. Intel Quark and PPC460ex, instantiate DMA driver and
    use its channels exclusively for hardware, which means there is no available
    channel for any other purposes anyway.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 6dd8cd1820c1..58fc1ba02a1e 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -128,12 +128,6 @@ dw_dma_parse_dt(struct platform_device *pdev)
 	pdata->nr_masters = nr_masters;
 	pdata->nr_channels = nr_channels;
 
-	/*
-	 * All known devices, which use DT for configuration, support
-	 * memory-to-memory transfers. So enable it by default.
-	 */
-	pdata->is_memcpy = true;
-
 	if (!of_property_read_u32(np, "chan_allocation_order", &tmp))
 		pdata->chan_allocation_order = (unsigned char)tmp;
 

commit d7dba6be0f31ae61f5f3296aa130f45d57d30f74
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jan 7 13:07:36 2019 +0200

    dmaengine: dw: Remove misleading is_private property
    
    The commit a9ddb575d6d6
    
       ("dmaengine: dw_dmac: Enhance device tree support")
    
    introduces is_private property in uncertain understanding what does it mean.
    
    First of all, documentation defines DMA_PRIVATE capability as
    
    Documentation/crypto/async-tx-api.txt:
      The DMA_PRIVATE capability flag is used to tag dma devices that should not be
      used by the general-purpose allocator. It can be set at initialization time
      if it is known that a channel will always be private. Alternatively,
      it is set when dma_request_channel() finds an unused "public" channel.
    
      A couple caveats to note when implementing a driver and consumer:
      1/ Once a channel has been privately allocated it will no longer be
         considered by the general-purpose allocator even after a call to
         dma_release_channel().
      2/ Since capabilities are specified at the device level a dma_device with
         multiple channels will either have all channels public, or all channels
         private.
    
    Documentation/driver-api/dmaengine/provider.rst:
      - DMA_PRIVATE
        The devices only supports slave transfers, and as such isn't available
        for async transfers.
    
    The capability had been introduced by the commit 59b5ec21446b
    
      ("dmaengine: introduce dma_request_channel and private channels")
    
    and some code didn't changed from that times ever.
    
    Taking into consideration above and the fact that on all known platforms
    Synopsys DesignWare DMA engine is attached to serve slave transfers,
    the DMA_PRIVATE capability must be enabled for this device unconditionally.
    Otherwise, as rightfully noticed in drivers/dma/at_xdmac.c:
      /*
       * Without DMA_PRIVATE the driver is not able to allocate more than
       * one channel, second allocation fails in private_candidate.
       */
    because of of a caveats mentioned in above documentation excerpts.
    
    So, remove conditional around DMA_PRIVATE followed by removal leftovers.
    
    If someone wonders, DMA_PRIVATE can be not used if and only if the all channels
    of the DMA controller are supposed to serve memory-to-memory like operations.
    For example, EP93xx has two controllers, one of which can only perform
    memory-to-memory transfers
    
    Note, this change doesn't affect dmatest to be able to test such controllers.
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org> (maintainer:SERIAL DRIVERS)
    Cc: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 31ff8113c3de..6dd8cd1820c1 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -128,9 +128,6 @@ dw_dma_parse_dt(struct platform_device *pdev)
 	pdata->nr_masters = nr_masters;
 	pdata->nr_channels = nr_channels;
 
-	if (of_property_read_bool(np, "is_private"))
-		pdata->is_private = true;
-
 	/*
 	 * All known devices, which use DT for configuration, support
 	 * memory-to-memory transfers. So enable it by default.

commit 7b0c03ecc42fb223baf015877fee9d517c2c8af1
Author: Christian Lamparter <chunkeey@gmail.com>
Date:   Sat Nov 17 17:17:21 2018 +0100

    dmaengine: dw-dmac: implement dma protection control setting
    
    This patch adds a new device-tree property that allows to
    specify the dma protection control bits for the all of the
    DMA controller's channel uniformly.
    
    Setting the "correct" bits can have a huge impact on the
    PPC460EX and APM82181 that use this DMA engine in combination
    with a DesignWare' SATA-II core (sata_dwc_460ex driver).
    
    In the OpenWrt Forum, the user takimata reported that:
    |It seems your patch unleashed the full power of the SATA port.
    |Where I was previously hitting a really hard limit at around
    |82 MB/s for reading and 27 MB/s for writing, I am now getting this:
    |
    |root@OpenWrt:/mnt# time dd if=/dev/zero of=tempfile bs=1M count=1024
    |1024+0 records in
    |1024+0 records out
    |real    0m 13.65s
    |user    0m 0.01s
    |sys     0m 11.89s
    |
    |root@OpenWrt:/mnt# time dd if=tempfile of=/dev/null bs=1M count=1024
    |1024+0 records in
    |1024+0 records out
    |real    0m 8.41s
    |user    0m 0.01s
    |sys     0m 4.70s
    |
    |This means: 121 MB/s reading and 75 MB/s writing!
    |
    |The drive is a WD Green WD10EARX taken from an older MBL Single.
    |I repeated the test a few times with even larger files to rule out
    |any caching, I'm still seeing the same great performance. OpenWrt is
    |now completely on par with the original MBL firmware's performance.
    
    Another user And.short reported:
    |I can report that your fix worked! Boots up fine with two
    |drives even with more partitions, and no more reboot on
    |concurrent disk access!
    
    A closer look into the sata_dwc_460ex code revealed that
    the driver did initally set the correct protection control
    bits. However, this feature was lost when the sata_dwc_460ex
    driver was converted to the generic DMA driver framework.
    
    BugLink: https://forum.openwrt.org/t/wd-mybook-live-duo-two-disks/16195/55
    BugLink: https://forum.openwrt.org/t/wd-mybook-live-duo-two-disks/16195/50
    Fixes: 8b3444852a2b ("sata_dwc_460ex: move to generic DMA driver")
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Christian Lamparter <chunkeey@gmail.com>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index f01b2c173fa6..31ff8113c3de 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -162,6 +162,12 @@ dw_dma_parse_dt(struct platform_device *pdev)
 			pdata->multi_block[tmp] = 1;
 	}
 
+	if (!of_property_read_u32(np, "snps,dma-protection-control", &tmp)) {
+		if (tmp > CHAN_PROTCTL_MASK)
+			return NULL;
+		pdata->protctl = tmp;
+	}
+
 	return pdata;
 }
 #else

commit 5658f4f94ccab6fa93af82368a63256011f9592c
Author: Hans de Goede <hdegoede@redhat.com>
Date:   Mon Aug 27 09:45:45 2018 +0200

    dmaengine: dw: Add alternative ACPI HIDs for Cherry Trail DMA controllers
    
    Bay and Cherry Trail DSTDs represent a different set of devices depending
    on which OS the device think it is booting. One set of decices for Windows
    and another set of devices for Android which targets the Android-x86 Linux
    kernel fork (which e.g. used to have its own display driver instead of
    using the i915 driver).
    
    Which set of devices we are actually going to get is out of our control,
    this is controlled by the ACPI OSID variable, which gets either set through
    an EFI setup option, or sometimes is autodetected. So we need to support
    both.
    
    This commit adds support for the 80862286 and 808622C0 ACPI HIDs which we
    get for the first resp. second DMA controller on Cherry Trail devices when
    OSID is set to Android.
    
    Signed-off-by: Hans de Goede <hdegoede@redhat.com>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index f62dd0944908..f01b2c173fa6 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -284,6 +284,8 @@ MODULE_DEVICE_TABLE(of, dw_dma_of_id_table);
 #ifdef CONFIG_ACPI
 static const struct acpi_device_id dw_dma_acpi_id_table[] = {
 	{ "INTL9C60", 0 },
+	{ "80862286", 0 },
+	{ "808622C0", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(acpi, dw_dma_acpi_id_table);

commit 83ff13235fb3e9c10401f457df27f67bf3b389af
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Thu Apr 19 16:05:38 2018 +0200

    dmaengine: dw: simplify getting .drvdata
    
    We should get drvdata from struct device directly. Going via
    platform_device is an unneeded step back and forth.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index bc31fe802061..f62dd0944908 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -293,8 +293,7 @@ MODULE_DEVICE_TABLE(acpi, dw_dma_acpi_id_table);
 
 static int dw_suspend_late(struct device *dev)
 {
-	struct platform_device *pdev = to_platform_device(dev);
-	struct dw_dma_chip *chip = platform_get_drvdata(pdev);
+	struct dw_dma_chip *chip = dev_get_drvdata(dev);
 
 	dw_dma_disable(chip);
 	clk_disable_unprepare(chip->clk);
@@ -304,8 +303,7 @@ static int dw_suspend_late(struct device *dev)
 
 static int dw_resume_early(struct device *dev)
 {
-	struct platform_device *pdev = to_platform_device(dev);
-	struct dw_dma_chip *chip = platform_get_drvdata(pdev);
+	struct dw_dma_chip *chip = dev_get_drvdata(dev);
 	int ret;
 
 	ret = clk_prepare_enable(chip->clk);

commit 702fce05f5ad0e2af2c00d5ef41356ffdd4a3a56
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Mon May 22 16:01:48 2017 +0530

    dmaengine: DW DMAC: Handle return value of clk_prepare_enable
    
    clk_prepare_enable() can fail here and we must check its return value.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index c639c60b825a..bc31fe802061 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -306,8 +306,12 @@ static int dw_resume_early(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct dw_dma_chip *chip = platform_get_drvdata(pdev);
+	int ret;
+
+	ret = clk_prepare_enable(chip->clk);
+	if (ret)
+		return ret;
 
-	clk_prepare_enable(chip->clk);
 	return dw_dma_enable(chip);
 }
 

commit 08d62f58aa2587132a930afbe8664379b430e2dd
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Jan 17 13:57:26 2017 +0200

    dmaengine: dw: register IRQ and DMA pool with instance ID
    
    It is really useful not only for debugging to have an IRQ line and DMA
    pool labeled with driver and its instance ID. Do this for DesignWare DMA
    driver.
    
    All current users of this IP would be enhanced later on.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index b1655e40cfa2..c639c60b825a 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -202,6 +202,7 @@ static int dw_probe(struct platform_device *pdev)
 		pdata = dw_dma_parse_dt(pdev);
 
 	chip->dev = dev;
+	chip->id = pdev->id;
 	chip->pdata = pdata;
 
 	chip->clk = devm_clk_get(chip->dev, "hclk");

commit bd2c6636cc59c4626a04d9918953a107f88eaff9
Author: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
Date:   Fri Nov 25 17:59:07 2016 +0300

    dmaengine: DW DMAC: add multi-block property to device tree
    
    Several versions of DW DMAC have multi block transfers hardware
    support. Hardware support of multi block transfers is disabled
    by default if we use DT to configure DMAC and software emulation
    of multi block transfers used instead.
    Add multi-block property, so it is possible to enable hardware
    multi block transfers (if present) via DT.
    
    Switch from per device is_nollp variable to multi_block array
    to be able enable/disable multi block transfers separately per
    channel.
    
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index aa7a5c1b9bf8..b1655e40cfa2 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -102,7 +102,7 @@ dw_dma_parse_dt(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
 	struct dw_dma_platform_data *pdata;
-	u32 tmp, arr[DW_DMA_MAX_NR_MASTERS];
+	u32 tmp, arr[DW_DMA_MAX_NR_MASTERS], mb[DW_DMA_MAX_NR_CHANNELS];
 	u32 nr_masters;
 	u32 nr_channels;
 
@@ -118,6 +118,8 @@ dw_dma_parse_dt(struct platform_device *pdev)
 
 	if (of_property_read_u32(np, "dma-channels", &nr_channels))
 		return NULL;
+	if (nr_channels > DW_DMA_MAX_NR_CHANNELS)
+		return NULL;
 
 	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 	if (!pdata)
@@ -152,6 +154,14 @@ dw_dma_parse_dt(struct platform_device *pdev)
 			pdata->data_width[tmp] = BIT(arr[tmp] & 0x07);
 	}
 
+	if (!of_property_read_u32_array(np, "multi-block", mb, nr_channels)) {
+		for (tmp = 0; tmp < nr_channels; tmp++)
+			pdata->multi_block[tmp] = mb[tmp];
+	} else {
+		for (tmp = 0; tmp < nr_channels; tmp++)
+			pdata->multi_block[tmp] = 1;
+	}
+
 	return pdata;
 }
 #else

commit 258f2277a93fe0e3cdac275264d275c526170db6
Author: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
Date:   Fri Nov 25 17:59:06 2016 +0300

    dmaengine: DW DMAC: enable memory-to-memory transfers support
    
    All known devices, which use DT for configuration, support
    memory-to-memory transfers. So enable it by default, if we read
    configuration from DT.
    
    Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 5bda0eb9f393..aa7a5c1b9bf8 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -129,6 +129,12 @@ dw_dma_parse_dt(struct platform_device *pdev)
 	if (of_property_read_bool(np, "is_private"))
 		pdata->is_private = true;
 
+	/*
+	 * All known devices, which use DT for configuration, support
+	 * memory-to-memory transfers. So enable it by default.
+	 */
+	pdata->is_memcpy = true;
+
 	if (!of_property_read_u32(np, "chan_allocation_order", &tmp))
 		pdata->chan_allocation_order = (unsigned char)tmp;
 

commit 3a14c66d43d018baed96ceb74f9ab548878c09b8
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Apr 27 14:15:40 2016 +0300

    dmaengine: dw: pass platform data via struct dw_dma_chip
    
    We pass struct dw_dma_chip to dw_dma_probe() anyway, thus we may use it to
    pass a platform data as well.
    
    While here, constify the source of the platform data.
    
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 0a49011633b9..5bda0eb9f393 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -161,7 +161,7 @@ static int dw_probe(struct platform_device *pdev)
 	struct dw_dma_chip *chip;
 	struct device *dev = &pdev->dev;
 	struct resource *mem;
-	struct dw_dma_platform_data *pdata;
+	const struct dw_dma_platform_data *pdata;
 	int err;
 
 	chip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);
@@ -186,6 +186,7 @@ static int dw_probe(struct platform_device *pdev)
 		pdata = dw_dma_parse_dt(pdev);
 
 	chip->dev = dev;
+	chip->pdata = pdata;
 
 	chip->clk = devm_clk_get(chip->dev, "hclk");
 	if (IS_ERR(chip->clk))
@@ -196,7 +197,7 @@ static int dw_probe(struct platform_device *pdev)
 
 	pm_runtime_enable(&pdev->dev);
 
-	err = dw_dma_probe(chip, pdata);
+	err = dw_dma_probe(chip);
 	if (err)
 		goto err_dw_dma_probe;
 

commit 161c3d04aeca8a5bfffe3902786bdf0ccd8575c0
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Apr 27 14:15:39 2016 +0300

    dmaengine: dw: keep entire platform data in struct dw_dma
    
    Keep the entire platform data in the struct dw_dma.
    It makes the driver a bit cleaner.
    
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 2420fb7267bc..0a49011633b9 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -47,8 +47,8 @@ static struct dma_chan *dw_dma_of_xlate(struct of_phandle_args *dma_spec,
 
 	if (WARN_ON(slave.src_id >= DW_DMA_MAX_NR_REQUESTS ||
 		    slave.dst_id >= DW_DMA_MAX_NR_REQUESTS ||
-		    slave.m_master >= dw->nr_masters ||
-		    slave.p_master >= dw->nr_masters))
+		    slave.m_master >= dw->pdata->nr_masters ||
+		    slave.p_master >= dw->pdata->nr_masters))
 		return NULL;
 
 	dma_cap_zero(cap);

commit 2e65060e803e046fc9b5ed0107494a452424845e
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Apr 27 14:15:38 2016 +0300

    dmaengine: dw: revisit data_width property
    
    There several changes are done here:
    
    - Convert the property to be in bytes
    
      Besides that this is a common practice for such property, the use of a value
      in bytes much more convenient than handling the encoded one.
    
    - Rename data_width to data-width in the device tree bindings
    
      The change leaves the support for the old format as well just in case someone
      will use a newer kernel with an old device tree blob.
    
    - While here, replace dwc_fast_ffs() by __ffs()
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index e65ebe5ab88f..2420fb7267bc 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -138,9 +138,12 @@ dw_dma_parse_dt(struct platform_device *pdev)
 	if (!of_property_read_u32(np, "block_size", &tmp))
 		pdata->block_size = tmp;
 
-	if (!of_property_read_u32_array(np, "data_width", arr, nr_masters)) {
+	if (!of_property_read_u32_array(np, "data-width", arr, nr_masters)) {
 		for (tmp = 0; tmp < nr_masters; tmp++)
 			pdata->data_width[tmp] = arr[tmp];
+	} else if (!of_property_read_u32_array(np, "data_width", arr, nr_masters)) {
+		for (tmp = 0; tmp < nr_masters; tmp++)
+			pdata->data_width[tmp] = BIT(arr[tmp] & 0x07);
 	}
 
 	return pdata;

commit 969f750fc63d3fd2f26eceedcdeca5878b785b2e
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Apr 27 14:15:37 2016 +0300

    dmaengine: dw: platform: check nr_masters to be non-zero
    
    The value of nr_masters equal to 0 is invalid since this DMA controller has to
    have at least one master.
    
    Check this before we proceed with the rest of properties.
    
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 23616c57645c..e65ebe5ab88f 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -103,6 +103,7 @@ dw_dma_parse_dt(struct platform_device *pdev)
 	struct device_node *np = pdev->dev.of_node;
 	struct dw_dma_platform_data *pdata;
 	u32 tmp, arr[DW_DMA_MAX_NR_MASTERS];
+	u32 nr_masters;
 	u32 nr_channels;
 
 	if (!np) {
@@ -110,6 +111,11 @@ dw_dma_parse_dt(struct platform_device *pdev)
 		return NULL;
 	}
 
+	if (of_property_read_u32(np, "dma-masters", &nr_masters))
+		return NULL;
+	if (nr_masters < 1 || nr_masters > DW_DMA_MAX_NR_MASTERS)
+		return NULL;
+
 	if (of_property_read_u32(np, "dma-channels", &nr_channels))
 		return NULL;
 
@@ -117,6 +123,7 @@ dw_dma_parse_dt(struct platform_device *pdev)
 	if (!pdata)
 		return NULL;
 
+	pdata->nr_masters = nr_masters;
 	pdata->nr_channels = nr_channels;
 
 	if (of_property_read_bool(np, "is_private"))
@@ -131,17 +138,10 @@ dw_dma_parse_dt(struct platform_device *pdev)
 	if (!of_property_read_u32(np, "block_size", &tmp))
 		pdata->block_size = tmp;
 
-	if (!of_property_read_u32(np, "dma-masters", &tmp)) {
-		if (tmp > DW_DMA_MAX_NR_MASTERS)
-			return NULL;
-
-		pdata->nr_masters = tmp;
-	}
-
-	if (!of_property_read_u32_array(np, "data_width", arr,
-				pdata->nr_masters))
-		for (tmp = 0; tmp < pdata->nr_masters; tmp++)
+	if (!of_property_read_u32_array(np, "data_width", arr, nr_masters)) {
+		for (tmp = 0; tmp < nr_masters; tmp++)
 			pdata->data_width[tmp] = arr[tmp];
+	}
 
 	return pdata;
 }

commit c422025c185fb2bb28df65b1bbed7953480c7f87
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Mar 18 16:24:41 2016 +0200

    dmaengine: dw: rename masters to reflect actual topology
    
    The source and destination masters are reflecting buses or their layers to
    where the different devices can be connected. The patch changes the master
    names to reflect which one is related to which independently on the transfer
    direction.
    
    The outcome of the change is that the memory data width is now always limited
    by a data width of the master which is dedicated to communicate to memory.
    
    The patch will not break anything since all current users have the same data
    width for all masters. Though it would be nice to revisit avr32 platforms to
    check what is the actual hardware topology in use there. It seems that it has
    one bus and two masters on it as stated by Table 8-2, that's why everything
    works independently on the master in use. The purpose of the sequential patch
    is to fix the driver for configuration of more than one bus.
    
    The change is done in the assumption that src_master and dst_master are
    reflecting a connection to the memory and peripheral correspondently on avr32
    and otherwise on the rest.
    
    Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 26edbe3a27ac..23616c57645c 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -42,13 +42,13 @@ static struct dma_chan *dw_dma_of_xlate(struct of_phandle_args *dma_spec,
 
 	slave.src_id = dma_spec->args[0];
 	slave.dst_id = dma_spec->args[0];
-	slave.src_master = dma_spec->args[1];
-	slave.dst_master = dma_spec->args[2];
+	slave.m_master = dma_spec->args[1];
+	slave.p_master = dma_spec->args[2];
 
 	if (WARN_ON(slave.src_id >= DW_DMA_MAX_NR_REQUESTS ||
 		    slave.dst_id >= DW_DMA_MAX_NR_REQUESTS ||
-		    slave.src_master >= dw->nr_masters ||
-		    slave.dst_master >= dw->nr_masters))
+		    slave.m_master >= dw->nr_masters ||
+		    slave.p_master >= dw->nr_masters))
 		return NULL;
 
 	dma_cap_zero(cap);
@@ -66,8 +66,8 @@ static bool dw_dma_acpi_filter(struct dma_chan *chan, void *param)
 		.dma_dev = dma_spec->dev,
 		.src_id = dma_spec->slave_id,
 		.dst_id = dma_spec->slave_id,
-		.src_master = 1,
-		.dst_master = 0,
+		.m_master = 0,
+		.p_master = 1,
 	};
 
 	return dw_dma_filter(chan, &slave);

commit d6a322774cb7096ca683fc46ddc9482e02ee6133
Merge: 4c257ec37bc3 8b648436eb45
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jan 13 10:59:52 2016 -0800

    Merge tag 'dmaengine-4.5-rc1' of git://git.infradead.org/users/vkoul/slave-dma
    
    Pull dmaengine updates from Vinod Koul:
     "This round we have few new features, new driver and updates to few
      drivers.
    
      The new features to dmaengine core are:
       - Synchronized transfer termination API to terminate the dmaengine
         transfers in synchronized and async fashion as required by users.
         We have its user now in ALSA dmaengine lib, img, at_xdma, axi_dmac
         drivers.
       - Universal API for channel request and start consolidation of
         request flows.  It's user is ompa-dma driver.
       - Introduce reuse of descriptors and use in pxa_dma driver
    
      Add/Remove:
       - New STM32 DMA driver
       - Removal of unused R-Car HPB-DMAC driver
    
      Updates:
       - ti-dma-crossbar updates for supporting eDMA
       - tegra-apb pm updates
       - idma64
       - mv_xor updates
       - ste_dma updates"
    
    * tag 'dmaengine-4.5-rc1' of git://git.infradead.org/users/vkoul/slave-dma: (54 commits)
      dmaengine: mv_xor: add suspend/resume support
      dmaengine: mv_xor: de-duplicate mv_chan_set_mode*()
      dmaengine: mv_xor: remove mv_xor_chan->current_type field
      dmaengine: omap-dma: Add support for DMA filter mapping to slave devices
      dmaengine: edma: Add support for DMA filter mapping to slave devices
      dmaengine: core: Introduce new, universal API to request a channel
      dmaengine: core: Move and merge the code paths using private_candidate
      dmaengine: core: Skip mask matching when it is not provided to private_candidate
      dmaengine: mdc: Correct terminate_all handling
      dmaengine: edma: Add probe callback to edma_tptc_driver
      dmaengine: dw: fix potential memory leak in dw_dma_parse_dt()
      dmaengine: stm32-dma: Fix unchecked deference of chan->desc
      dmaengine: sh: Remove unused R-Car HPB-DMAC driver
      dmaengine: usb-dmac: Document SoC specific compatibility strings
      ste_dma40: Delete an unnecessary variable initialisation in d40_probe()
      ste_dma40: Delete another unnecessary check in d40_probe()
      ste_dma40: Delete an unnecessary check before the function call "kmem_cache_destroy"
      dmaengine: tegra-apb: Free interrupts before killing tasklets
      dmaengine: tegra-apb: Update driver to use GFP_NOWAIT
      dmaengine: tegra-apb: Only save channel state for those in use
      ...

commit bc0bb1fd5b0d72fba589b46be05c945171f9d6f3
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Dec 4 23:49:25 2015 +0200

    Revert "dmaengine: dw: platform: provide platform data for Intel"
    
    Since we have a work around to prevent a system hangup we don't need to provide
    a platform data explicitly anymore.
    
    This reverts commit 175267b389f781748e2bbb6c737e76b5c9bc4c88.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index d0734e912b79..127093a0c0e8 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -155,7 +155,6 @@ static int dw_probe(struct platform_device *pdev)
 	struct dw_dma_chip *chip;
 	struct device *dev = &pdev->dev;
 	struct resource *mem;
-	const struct acpi_device_id *id;
 	struct dw_dma_platform_data *pdata;
 	int err;
 
@@ -179,11 +178,6 @@ static int dw_probe(struct platform_device *pdev)
 	pdata = dev_get_platdata(dev);
 	if (!pdata)
 		pdata = dw_dma_parse_dt(pdev);
-	if (!pdata && has_acpi_companion(dev)) {
-		id = acpi_match_device(dev->driver->acpi_match_table, dev);
-		if (id)
-			pdata = (struct dw_dma_platform_data *)id->driver_data;
-	}
 
 	chip->dev = dev;
 
@@ -264,17 +258,8 @@ MODULE_DEVICE_TABLE(of, dw_dma_of_id_table);
 #endif
 
 #ifdef CONFIG_ACPI
-static struct dw_dma_platform_data dw_dma_acpi_pdata = {
-	.nr_channels = 8,
-	.is_private = true,
-	.chan_allocation_order = CHAN_ALLOCATION_ASCENDING,
-	.chan_priority = CHAN_PRIORITY_ASCENDING,
-	.block_size = 4095,
-	.nr_masters = 2,
-};
-
 static const struct acpi_device_id dw_dma_acpi_id_table[] = {
-	{ "INTL9C60", (kernel_ulong_t)&dw_dma_acpi_pdata },
+	{ "INTL9C60", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(acpi, dw_dma_acpi_id_table);

commit 3214658855c01a0dd62f02feb2ce79846524c6a0
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Dec 4 23:49:23 2015 +0200

    dmaengine: dw: platform: power on device on shutdown
    
    We have to call dw_dma_disable() to stop any ongoing transfer. On some
    platforms we can't do that since DMA device is powered off. Moreover we have no
    possibility at that point to check if the platform is affected or not. That's
    why we call pm_runtime_get_sync() / pm_runtime_put() unconditionally. On the
    other hand we can't use pm_runtime_suspended() because runtime PM framework is
    not fully used by the driver.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Vinod Koul <vinod.koul@intel.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 68a4815750b5..d0734e912b79 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -239,7 +239,19 @@ static void dw_shutdown(struct platform_device *pdev)
 {
 	struct dw_dma_chip *chip = platform_get_drvdata(pdev);
 
+	/*
+	 * We have to call dw_dma_disable() to stop any ongoing transfer. On
+	 * some platforms we can't do that since DMA device is powered off.
+	 * Moreover we have no possibility to check if the platform is affected
+	 * or not. That's why we call pm_runtime_get_sync() / pm_runtime_put()
+	 * unconditionally. On the other hand we can't use
+	 * pm_runtime_suspended() because runtime PM framework is not fully
+	 * used by the driver.
+	 */
+	pm_runtime_get_sync(chip->dev);
 	dw_dma_disable(chip);
+	pm_runtime_put_sync_suspend(chip->dev);
+
 	clk_disable_unprepare(chip->clk);
 }
 

commit 2b574ba9c50a06a1aa6cf908cd44119367111006
Author: Mans Rullgard <mans@mansr.com>
Date:   Thu Dec 17 23:30:57 2015 +0000

    dmaengine: dw: fix potential memory leak in dw_dma_parse_dt()
    
    If the "dma-channels" DT property is missing, the dw_dma_parse_dt()
    function return NULL, but not before allocating memory for a struct
    dw_dma_platform_data through devres.  If the device supports parameter
    detection, the probe still succeeds and the allocated memory is not
    released until the device is removed.
    
    Fix this by deferring the allocation until after checking the
    "dma-channels" property.
    
    Signed-off-by: Mans Rullgard <mans@mansr.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 68a4815750b5..5a417bbdfbd7 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -103,18 +103,21 @@ dw_dma_parse_dt(struct platform_device *pdev)
 	struct device_node *np = pdev->dev.of_node;
 	struct dw_dma_platform_data *pdata;
 	u32 tmp, arr[DW_DMA_MAX_NR_MASTERS];
+	u32 nr_channels;
 
 	if (!np) {
 		dev_err(&pdev->dev, "Missing DT data\n");
 		return NULL;
 	}
 
+	if (of_property_read_u32(np, "dma-channels", &nr_channels))
+		return NULL;
+
 	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 	if (!pdata)
 		return NULL;
 
-	if (of_property_read_u32(np, "dma-channels", &pdata->nr_channels))
-		return NULL;
+	pdata->nr_channels = nr_channels;
 
 	if (of_property_read_bool(np, "is_private"))
 		pdata->is_private = true;

commit 175267b389f781748e2bbb6c737e76b5c9bc4c88
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Oct 13 20:09:18 2015 +0300

    dmaengine: dw: platform: provide platform data for Intel
    
    Provide platform data explicitly for Intel SoCs where dw_dmac is enumerated by
    ACPI.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index b2c3ae071429..68a4815750b5 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -155,6 +155,7 @@ static int dw_probe(struct platform_device *pdev)
 	struct dw_dma_chip *chip;
 	struct device *dev = &pdev->dev;
 	struct resource *mem;
+	const struct acpi_device_id *id;
 	struct dw_dma_platform_data *pdata;
 	int err;
 
@@ -178,6 +179,11 @@ static int dw_probe(struct platform_device *pdev)
 	pdata = dev_get_platdata(dev);
 	if (!pdata)
 		pdata = dw_dma_parse_dt(pdev);
+	if (!pdata && has_acpi_companion(dev)) {
+		id = acpi_match_device(dev->driver->acpi_match_table, dev);
+		if (id)
+			pdata = (struct dw_dma_platform_data *)id->driver_data;
+	}
 
 	chip->dev = dev;
 
@@ -246,8 +252,17 @@ MODULE_DEVICE_TABLE(of, dw_dma_of_id_table);
 #endif
 
 #ifdef CONFIG_ACPI
+static struct dw_dma_platform_data dw_dma_acpi_pdata = {
+	.nr_channels = 8,
+	.is_private = true,
+	.chan_allocation_order = CHAN_ALLOCATION_ASCENDING,
+	.chan_priority = CHAN_PRIORITY_ASCENDING,
+	.block_size = 4095,
+	.nr_masters = 2,
+};
+
 static const struct acpi_device_id dw_dma_acpi_id_table[] = {
-	{ "INTL9C60", 0 },
+	{ "INTL9C60", (kernel_ulong_t)&dw_dma_acpi_pdata },
 	{ }
 };
 MODULE_DEVICE_TABLE(acpi, dw_dma_acpi_id_table);

commit a104a45ba7a51b5b4c5e8437020d9d48edf22f89
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Mar 9 12:16:42 2015 +0200

    dmaengine: dw: append MODULE_ALIAS for platform driver
    
    The commit 9cade1a46c77 (dma: dw: split driver to library part and platform
    code) introduced a separate platform driver but missed to add a
    MODULE_ALIAS("platform:dw_dmac"); to that module.
    
    The patch adds this to get driver loaded automatically if platform device is
    registered.
    
    Reported-by: "Blin, Jerome" <jerome.blin@intel.com>
    Fixes: 9cade1a46c77 (dma: dw: split driver to library part and platform code)
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 6565a361e7e5..b2c3ae071429 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -26,6 +26,8 @@
 
 #include "internal.h"
 
+#define DRV_NAME	"dw_dmac"
+
 static struct dma_chan *dw_dma_of_xlate(struct of_phandle_args *dma_spec,
 					struct of_dma *ofdma)
 {
@@ -284,7 +286,7 @@ static struct platform_driver dw_driver = {
 	.remove		= dw_remove,
 	.shutdown       = dw_shutdown,
 	.driver = {
-		.name	= "dw_dmac",
+		.name	= DRV_NAME,
 		.pm	= &dw_dev_pm_ops,
 		.of_match_table = of_match_ptr(dw_dma_of_id_table),
 		.acpi_match_table = ACPI_PTR(dw_dma_acpi_id_table),
@@ -305,3 +307,4 @@ module_exit(dw_exit);
 
 MODULE_LICENSE("GPL v2");
 MODULE_DESCRIPTION("Synopsys DesignWare DMA Controller platform driver");
+MODULE_ALIAS("platform:" DRV_NAME);

commit ce1d3fde87d1a21f1ec1147dde32b2825dd3a276
Merge: 928fce2f6d81 88987d2c7534
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 18 08:49:20 2015 -0800

    Merge branch 'for-linus' of git://git.infradead.org/users/vkoul/slave-dma
    
    Pull dmaengine updates from Vinod Koul:
     "This update brings:
    
       - the big cleanup up by Maxime for device control and slave
         capabilities.  This makes the API much cleaner.
    
       - new IMG MDC driver by Andrew
    
       - new Renesas R-Car Gen2 DMA Controller driver by Laurent along with
         bunch of fixes on rcar drivers
    
       - odd fixes and updates spread over driver"
    
    * 'for-linus' of git://git.infradead.org/users/vkoul/slave-dma: (130 commits)
      dmaengine: pl330: add DMA_PAUSE feature
      dmaengine: pl330: improve pl330_tx_status() function
      dmaengine: rcar-dmac: Disable channel 0 when using IOMMU
      dmaengine: rcar-dmac: Work around descriptor mode IOMMU errata
      dmaengine: rcar-dmac: Allocate hardware descriptors with DMAC device
      dmaengine: rcar-dmac: Fix oops due to unintialized list in error ISR
      dmaengine: rcar-dmac: Fix spinlock issues in interrupt
      dmaenegine: edma: fix sparse warnings
      dmaengine: rcar-dmac: Fix uninitialized variable usage
      dmaengine: shdmac: extend PM methods
      dmaengine: shdmac: use SET_RUNTIME_PM_OPS()
      dmaengine: pl330: fix bug that cause start the same descs in cyclic
      dmaengine: at_xdmac: allow muliple dwidths when doing slave transfers
      dmaengine: at_xdmac: simplify channel configuration stuff
      dmaengine: at_xdmac: introduce save_cc field
      dmaengine: at_xdmac: wait for in-progress transaction to complete after pausing a channel
      ioat: fail self-test if wait_for_completion times out
      dmaengine: dw: define DW_DMA_MAX_NR_MASTERS
      dmaengine: dw: amend description of dma_dev field
      dmatest: move src_off, dst_off, len inside loop
      ...

commit d8ded50f8b26a224df48f9f93e49440c6a39b77f
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Jan 13 19:08:14 2015 +0200

    dmaengine: dw: define DW_DMA_MAX_NR_MASTERS
    
    Instead of using magic number in the code the patch provides
    DW_DMA_MAX_NR_MASTERS constant.
    
    While here, restrict the reading of data width array by amount of the actual
    number of AHB masters.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index a630161473a4..aaff37f53523 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -99,7 +99,7 @@ dw_dma_parse_dt(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
 	struct dw_dma_platform_data *pdata;
-	u32 tmp, arr[4];
+	u32 tmp, arr[DW_DMA_MAX_NR_MASTERS];
 
 	if (!np) {
 		dev_err(&pdev->dev, "Missing DT data\n");
@@ -126,7 +126,7 @@ dw_dma_parse_dt(struct platform_device *pdev)
 		pdata->block_size = tmp;
 
 	if (!of_property_read_u32(np, "dma-masters", &tmp)) {
-		if (tmp > 4)
+		if (tmp > DW_DMA_MAX_NR_MASTERS)
 			return NULL;
 
 		pdata->nr_masters = tmp;

commit 6acf3998d2c7420b2deb2b475fa78ba7573c6162
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Jan 13 18:57:15 2015 +0200

    dmaengine: dw: balance PM runtime calls
    
    In case of PCI driver we will get a warning:
            dw_dmac_pci 0000:00:18.0: Unbalanced pm_runtime_enable!
            dw_dmac_pci 0000:00:18.0: DesignWare DMA Controller, 8 channels
    
    This happens due to pm_runtime_enable() call from the driver when PM runtime is
    enabled by core.
    
    This patch moves that call to the platform driver where it might make sense.
    
    Fixes: bb32baf76e56 (dmaengine: dw: enable runtime PM)
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index a630161473a4..32ea1aca7a0e 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -15,6 +15,7 @@
 #include <linux/module.h>
 #include <linux/device.h>
 #include <linux/clk.h>
+#include <linux/pm_runtime.h>
 #include <linux/platform_device.h>
 #include <linux/dmaengine.h>
 #include <linux/dma-mapping.h>
@@ -185,6 +186,8 @@ static int dw_probe(struct platform_device *pdev)
 	if (err)
 		return err;
 
+	pm_runtime_enable(&pdev->dev);
+
 	err = dw_dma_probe(chip, pdata);
 	if (err)
 		goto err_dw_dma_probe;
@@ -205,6 +208,7 @@ static int dw_probe(struct platform_device *pdev)
 	return 0;
 
 err_dw_dma_probe:
+	pm_runtime_disable(&pdev->dev);
 	clk_disable_unprepare(chip->clk);
 	return err;
 }
@@ -217,6 +221,7 @@ static int dw_remove(struct platform_device *pdev)
 		of_dma_controller_free(pdev->dev.of_node);
 
 	dw_dma_remove(chip);
+	pm_runtime_disable(&pdev->dev);
 	clk_disable_unprepare(chip->clk);
 
 	return 0;

commit 2540f74b187e3ec0fe106b7427c4a84c955dc140
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Sep 23 17:18:13 2014 +0300

    dmaengine: dw: always export dw_dma_{en,dis}able
    
    Instead of conditional exporing of dw_dma_suspend() / dw_dma_resume() let's
    export dw_dma_disable() / dw_dma_enable(). Since dw_dma_shutdown() repeats
    dw_dma_disable() we may safely remove it at all.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index d50077e48187..a630161473a4 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -226,7 +226,7 @@ static void dw_shutdown(struct platform_device *pdev)
 {
 	struct dw_dma_chip *chip = platform_get_drvdata(pdev);
 
-	dw_dma_shutdown(chip);
+	dw_dma_disable(chip);
 	clk_disable_unprepare(chip->clk);
 }
 
@@ -253,7 +253,7 @@ static int dw_suspend_late(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct dw_dma_chip *chip = platform_get_drvdata(pdev);
 
-	dw_dma_suspend(chip);
+	dw_dma_disable(chip);
 	clk_disable_unprepare(chip->clk);
 
 	return 0;
@@ -265,7 +265,7 @@ static int dw_resume_early(struct device *dev)
 	struct dw_dma_chip *chip = platform_get_drvdata(pdev);
 
 	clk_prepare_enable(chip->clk);
-	return dw_dma_resume(chip);
+	return dw_dma_enable(chip);
 }
 
 #endif /* CONFIG_PM_SLEEP */
@@ -277,7 +277,7 @@ static const struct dev_pm_ops dw_dev_pm_ops = {
 static struct platform_driver dw_driver = {
 	.probe		= dw_probe,
 	.remove		= dw_remove,
-	.shutdown	= dw_shutdown,
+	.shutdown       = dw_shutdown,
 	.driver = {
 		.name	= "dw_dmac",
 		.pm	= &dw_dev_pm_ops,

commit a15636e83eb0dedefcb1221be729023e4c281748
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Aug 19 20:29:17 2014 +0300

    dmaengine: dw: move clock operations to platform.c
    
    On BayTrail platform DMA is not functional in the PCI mode, whereby it always
    failed and exit at the point when it tries to get a clock. It causes the PCI
    mode probe to exit with the error message:
            dw_dmac_pci: probe of 0000:00:1e.0 failed with error -2
    
    This patch moves clock operations to where it belongs to. Thus, the clock is
    provided only in ACPI / non-PCI cases.
    
    Reported-by: Chew, Chiau Ee <chiau.ee.chew@intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 860c9acf3fef..d50077e48187 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -178,10 +178,17 @@ static int dw_probe(struct platform_device *pdev)
 
 	chip->dev = dev;
 
-	err = dw_dma_probe(chip, pdata);
+	chip->clk = devm_clk_get(chip->dev, "hclk");
+	if (IS_ERR(chip->clk))
+		return PTR_ERR(chip->clk);
+	err = clk_prepare_enable(chip->clk);
 	if (err)
 		return err;
 
+	err = dw_dma_probe(chip, pdata);
+	if (err)
+		goto err_dw_dma_probe;
+
 	platform_set_drvdata(pdev, chip);
 
 	if (pdev->dev.of_node) {
@@ -196,6 +203,10 @@ static int dw_probe(struct platform_device *pdev)
 		dw_dma_acpi_controller_register(chip->dw);
 
 	return 0;
+
+err_dw_dma_probe:
+	clk_disable_unprepare(chip->clk);
+	return err;
 }
 
 static int dw_remove(struct platform_device *pdev)
@@ -205,7 +216,10 @@ static int dw_remove(struct platform_device *pdev)
 	if (pdev->dev.of_node)
 		of_dma_controller_free(pdev->dev.of_node);
 
-	return dw_dma_remove(chip);
+	dw_dma_remove(chip);
+	clk_disable_unprepare(chip->clk);
+
+	return 0;
 }
 
 static void dw_shutdown(struct platform_device *pdev)
@@ -213,6 +227,7 @@ static void dw_shutdown(struct platform_device *pdev)
 	struct dw_dma_chip *chip = platform_get_drvdata(pdev);
 
 	dw_dma_shutdown(chip);
+	clk_disable_unprepare(chip->clk);
 }
 
 #ifdef CONFIG_OF
@@ -238,7 +253,10 @@ static int dw_suspend_late(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct dw_dma_chip *chip = platform_get_drvdata(pdev);
 
-	return dw_dma_suspend(chip);
+	dw_dma_suspend(chip);
+	clk_disable_unprepare(chip->clk);
+
+	return 0;
 }
 
 static int dw_resume_early(struct device *dev)
@@ -246,6 +264,7 @@ static int dw_resume_early(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct dw_dma_chip *chip = platform_get_drvdata(pdev);
 
+	clk_prepare_enable(chip->clk);
 	return dw_dma_resume(chip);
 }
 

commit 4d130de20c3f39fc1a1aecd3969b50d49ff2e358
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Aug 19 20:29:16 2014 +0300

    dmaengine: dw: introduce generic filter function
    
    The introduced filter function would be reused in the ACPI and DT cases since
    in those cases we have to apply mandatory data to the requested channel. Thus,
    patch moves platform driver to use it in that case.
    
    The function unlikely can't be used by users of the driver due to an implicit
    dependency to the dw_dmac_core module.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 7aa3cd33fdec..860c9acf3fef 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -25,74 +25,49 @@
 
 #include "internal.h"
 
-struct dw_dma_of_filter_args {
-	struct dw_dma *dw;
-	unsigned int req;
-	unsigned int src;
-	unsigned int dst;
-};
-
-static bool dw_dma_of_filter(struct dma_chan *chan, void *param)
-{
-	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
-	struct dw_dma_of_filter_args *fargs = param;
-
-	/* Ensure the device matches our channel */
-	if (chan->device != &fargs->dw->dma)
-		return false;
-
-	dwc->src_id = fargs->req;
-	dwc->dst_id = fargs->req;
-	dwc->src_master	= fargs->src;
-	dwc->dst_master	= fargs->dst;
-
-	return true;
-}
-
 static struct dma_chan *dw_dma_of_xlate(struct of_phandle_args *dma_spec,
 					struct of_dma *ofdma)
 {
 	struct dw_dma *dw = ofdma->of_dma_data;
-	struct dw_dma_of_filter_args fargs = {
-		.dw = dw,
+	struct dw_dma_slave slave = {
+		.dma_dev = dw->dma.dev,
 	};
 	dma_cap_mask_t cap;
 
 	if (dma_spec->args_count != 3)
 		return NULL;
 
-	fargs.req = dma_spec->args[0];
-	fargs.src = dma_spec->args[1];
-	fargs.dst = dma_spec->args[2];
+	slave.src_id = dma_spec->args[0];
+	slave.dst_id = dma_spec->args[0];
+	slave.src_master = dma_spec->args[1];
+	slave.dst_master = dma_spec->args[2];
 
-	if (WARN_ON(fargs.req >= DW_DMA_MAX_NR_REQUESTS ||
-		    fargs.src >= dw->nr_masters ||
-		    fargs.dst >= dw->nr_masters))
+	if (WARN_ON(slave.src_id >= DW_DMA_MAX_NR_REQUESTS ||
+		    slave.dst_id >= DW_DMA_MAX_NR_REQUESTS ||
+		    slave.src_master >= dw->nr_masters ||
+		    slave.dst_master >= dw->nr_masters))
 		return NULL;
 
 	dma_cap_zero(cap);
 	dma_cap_set(DMA_SLAVE, cap);
 
 	/* TODO: there should be a simpler way to do this */
-	return dma_request_channel(cap, dw_dma_of_filter, &fargs);
+	return dma_request_channel(cap, dw_dma_filter, &slave);
 }
 
 #ifdef CONFIG_ACPI
 static bool dw_dma_acpi_filter(struct dma_chan *chan, void *param)
 {
-	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
 	struct acpi_dma_spec *dma_spec = param;
+	struct dw_dma_slave slave = {
+		.dma_dev = dma_spec->dev,
+		.src_id = dma_spec->slave_id,
+		.dst_id = dma_spec->slave_id,
+		.src_master = 1,
+		.dst_master = 0,
+	};
 
-	if (chan->device->dev != dma_spec->dev ||
-	    chan->chan_id != dma_spec->chan_id)
-		return false;
-
-	dwc->src_id = dma_spec->slave_id;
-	dwc->dst_id = dma_spec->slave_id;
-	dwc->src_master = dwc_get_sms(NULL);
-	dwc->dst_master = dwc_get_dms(NULL);
-
-	return true;
+	return dw_dma_filter(chan, &slave);
 }
 
 static void dw_dma_acpi_controller_register(struct dw_dma *dw)

commit 8950052029874a6738552debb45077c596e90e6b
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Aug 19 20:29:15 2014 +0300

    dmaengine: dw: apply both HS interfaces and remove slave_id usage
    
    Instead of one request line member let's use both source and destination ones.
    Usually we have no such hardware except Atmel MMC controller found on AVR32
    platform (see arch/avr32/mach-at32ap/at32ap700x.c and
    drivers/mmc/host/atmel-mci.c).
    
    This patch removes slave_id usage since it'll be removed from the generic
    structure in later. This breaks the non-ACPI / non-DT cases for the users of
    the driver, i.e. SPI and HSUART. However, these cases mean only PCI enumerated
    devices for now, which is anyway broken (considering more than one DMA
    controller in the system) and this patch series is intended to fix that
    eventually.
    
    The ACPI and DT cases shall be aware of the channel direction when setting
    request lines, but this is a minor problem that would be addressed in future.
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index c5b339af6be5..7aa3cd33fdec 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -41,7 +41,8 @@ static bool dw_dma_of_filter(struct dma_chan *chan, void *param)
 	if (chan->device != &fargs->dw->dma)
 		return false;
 
-	dwc->request_line = fargs->req;
+	dwc->src_id = fargs->req;
+	dwc->dst_id = fargs->req;
 	dwc->src_master	= fargs->src;
 	dwc->dst_master	= fargs->dst;
 
@@ -86,7 +87,8 @@ static bool dw_dma_acpi_filter(struct dma_chan *chan, void *param)
 	    chan->chan_id != dma_spec->chan_id)
 		return false;
 
-	dwc->request_line = dma_spec->slave_id;
+	dwc->src_id = dma_spec->slave_id;
+	dwc->dst_id = dma_spec->slave_id;
 	dwc->src_master = dwc_get_sms(NULL);
 	dwc->dst_master = dwc_get_dms(NULL);
 

commit 067bd4fdfa17c3bbdac09b401667e967c81eb2b7
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Apr 15 16:18:41 2014 +0300

    dmaengine: dw: move PM to suspend_late / resume_early stages
    
    There is no need to use *_noirq version of suspend and resume PM callbacks. The
    suspend_late / resume_early suit better (it was discussed in [1]) and in future
    could be used for runtime PM support.
    
    [1] http://www.spinics.net/lists/kernel/msg1650974.html
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 453822cc4f9d..c5b339af6be5 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -256,7 +256,7 @@ MODULE_DEVICE_TABLE(acpi, dw_dma_acpi_id_table);
 
 #ifdef CONFIG_PM_SLEEP
 
-static int dw_suspend_noirq(struct device *dev)
+static int dw_suspend_late(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct dw_dma_chip *chip = platform_get_drvdata(pdev);
@@ -264,7 +264,7 @@ static int dw_suspend_noirq(struct device *dev)
 	return dw_dma_suspend(chip);
 }
 
-static int dw_resume_noirq(struct device *dev)
+static int dw_resume_early(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct dw_dma_chip *chip = platform_get_drvdata(pdev);
@@ -272,20 +272,10 @@ static int dw_resume_noirq(struct device *dev)
 	return dw_dma_resume(chip);
 }
 
-#else /* !CONFIG_PM_SLEEP */
-
-#define dw_suspend_noirq	NULL
-#define dw_resume_noirq		NULL
-
-#endif /* !CONFIG_PM_SLEEP */
+#endif /* CONFIG_PM_SLEEP */
 
 static const struct dev_pm_ops dw_dev_pm_ops = {
-	.suspend_noirq = dw_suspend_noirq,
-	.resume_noirq = dw_resume_noirq,
-	.freeze_noirq = dw_suspend_noirq,
-	.thaw_noirq = dw_resume_noirq,
-	.restore_noirq = dw_resume_noirq,
-	.poweroff_noirq = dw_suspend_noirq,
+	SET_LATE_SYSTEM_SLEEP_PM_OPS(dw_suspend_late, dw_resume_early)
 };
 
 static struct platform_driver dw_driver = {

commit 24353b8bb4ecfc7f751019ee599c89d5175e12a1
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jun 27 13:37:21 2013 +0100

    DMA-API: dma: dw_dmac.c: convert to use dma_coerce_mask_and_coherent()
    
    This code sequence:
            if (!pdev->dev.dma_mask) {
                    pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
                    pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
            }
    bypasses the architectures check on the DMA mask.  It can be replaced
    with dma_coerce_mask_and_coherent(), avoiding the direct initialization
    of this mask.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index e35d97590311..453822cc4f9d 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -191,11 +191,9 @@ static int dw_probe(struct platform_device *pdev)
 	if (IS_ERR(chip->regs))
 		return PTR_ERR(chip->regs);
 
-	/* Apply default dma_mask if needed */
-	if (!dev->dma_mask) {
-		dev->dma_mask = &dev->coherent_dma_mask;
-		dev->coherent_dma_mask = DMA_BIT_MASK(32);
-	}
+	err = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
+	if (err)
+		return err;
 
 	pdata = dev_get_platdata(dev);
 	if (!pdata)

commit be480dcbb598687584e01156479d5476ca51ca9b
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Jul 15 15:04:37 2013 +0300

    dma: dw: append MODULE_DEVICE_TABLE for ACPI case
    
    In rare cases (mostly for the testing purposes) the dw_dmac driver might be
    compiled as a module as well as the other LPSS device drivers (I2C, SPI,
    HSUART). When udev handles the event of the devices appearing the dw_dmac
    module is missing. This patch will fix that.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
index 6c9449cffae8..e35d97590311 100644
--- a/drivers/dma/dw/platform.c
+++ b/drivers/dma/dw/platform.c
@@ -253,6 +253,7 @@ static const struct acpi_device_id dw_dma_acpi_id_table[] = {
 	{ "INTL9C60", 0 },
 	{ }
 };
+MODULE_DEVICE_TABLE(acpi, dw_dma_acpi_id_table);
 #endif
 
 #ifdef CONFIG_PM_SLEEP

commit 9cade1a46c77dfc96d57a3ea6354e95b2a7fcf61
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Wed Jun 5 15:26:45 2013 +0300

    dma: dw: split driver to library part and platform code
    
    To simplify the driver development let's split driver to library and platform
    code parts. It helps us to add PCI driver in future.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    [Fixed compile error and few checkpatch issues]
    Signed-off-by: Vinod Koul <vinod.koul@intel.com>

diff --git a/drivers/dma/dw/platform.c b/drivers/dma/dw/platform.c
new file mode 100644
index 000000000000..6c9449cffae8
--- /dev/null
+++ b/drivers/dma/dw/platform.c
@@ -0,0 +1,317 @@
+/*
+ * Platform driver for the Synopsys DesignWare DMA Controller
+ *
+ * Copyright (C) 2007-2008 Atmel Corporation
+ * Copyright (C) 2010-2011 ST Microelectronics
+ * Copyright (C) 2013 Intel Corporation
+ *
+ * Some parts of this driver are derived from the original dw_dmac.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/of.h>
+#include <linux/of_dma.h>
+#include <linux/acpi.h>
+#include <linux/acpi_dma.h>
+
+#include "internal.h"
+
+struct dw_dma_of_filter_args {
+	struct dw_dma *dw;
+	unsigned int req;
+	unsigned int src;
+	unsigned int dst;
+};
+
+static bool dw_dma_of_filter(struct dma_chan *chan, void *param)
+{
+	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
+	struct dw_dma_of_filter_args *fargs = param;
+
+	/* Ensure the device matches our channel */
+	if (chan->device != &fargs->dw->dma)
+		return false;
+
+	dwc->request_line = fargs->req;
+	dwc->src_master	= fargs->src;
+	dwc->dst_master	= fargs->dst;
+
+	return true;
+}
+
+static struct dma_chan *dw_dma_of_xlate(struct of_phandle_args *dma_spec,
+					struct of_dma *ofdma)
+{
+	struct dw_dma *dw = ofdma->of_dma_data;
+	struct dw_dma_of_filter_args fargs = {
+		.dw = dw,
+	};
+	dma_cap_mask_t cap;
+
+	if (dma_spec->args_count != 3)
+		return NULL;
+
+	fargs.req = dma_spec->args[0];
+	fargs.src = dma_spec->args[1];
+	fargs.dst = dma_spec->args[2];
+
+	if (WARN_ON(fargs.req >= DW_DMA_MAX_NR_REQUESTS ||
+		    fargs.src >= dw->nr_masters ||
+		    fargs.dst >= dw->nr_masters))
+		return NULL;
+
+	dma_cap_zero(cap);
+	dma_cap_set(DMA_SLAVE, cap);
+
+	/* TODO: there should be a simpler way to do this */
+	return dma_request_channel(cap, dw_dma_of_filter, &fargs);
+}
+
+#ifdef CONFIG_ACPI
+static bool dw_dma_acpi_filter(struct dma_chan *chan, void *param)
+{
+	struct dw_dma_chan *dwc = to_dw_dma_chan(chan);
+	struct acpi_dma_spec *dma_spec = param;
+
+	if (chan->device->dev != dma_spec->dev ||
+	    chan->chan_id != dma_spec->chan_id)
+		return false;
+
+	dwc->request_line = dma_spec->slave_id;
+	dwc->src_master = dwc_get_sms(NULL);
+	dwc->dst_master = dwc_get_dms(NULL);
+
+	return true;
+}
+
+static void dw_dma_acpi_controller_register(struct dw_dma *dw)
+{
+	struct device *dev = dw->dma.dev;
+	struct acpi_dma_filter_info *info;
+	int ret;
+
+	info = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return;
+
+	dma_cap_zero(info->dma_cap);
+	dma_cap_set(DMA_SLAVE, info->dma_cap);
+	info->filter_fn = dw_dma_acpi_filter;
+
+	ret = devm_acpi_dma_controller_register(dev, acpi_dma_simple_xlate,
+						info);
+	if (ret)
+		dev_err(dev, "could not register acpi_dma_controller\n");
+}
+#else /* !CONFIG_ACPI */
+static inline void dw_dma_acpi_controller_register(struct dw_dma *dw) {}
+#endif /* !CONFIG_ACPI */
+
+#ifdef CONFIG_OF
+static struct dw_dma_platform_data *
+dw_dma_parse_dt(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct dw_dma_platform_data *pdata;
+	u32 tmp, arr[4];
+
+	if (!np) {
+		dev_err(&pdev->dev, "Missing DT data\n");
+		return NULL;
+	}
+
+	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return NULL;
+
+	if (of_property_read_u32(np, "dma-channels", &pdata->nr_channels))
+		return NULL;
+
+	if (of_property_read_bool(np, "is_private"))
+		pdata->is_private = true;
+
+	if (!of_property_read_u32(np, "chan_allocation_order", &tmp))
+		pdata->chan_allocation_order = (unsigned char)tmp;
+
+	if (!of_property_read_u32(np, "chan_priority", &tmp))
+		pdata->chan_priority = tmp;
+
+	if (!of_property_read_u32(np, "block_size", &tmp))
+		pdata->block_size = tmp;
+
+	if (!of_property_read_u32(np, "dma-masters", &tmp)) {
+		if (tmp > 4)
+			return NULL;
+
+		pdata->nr_masters = tmp;
+	}
+
+	if (!of_property_read_u32_array(np, "data_width", arr,
+				pdata->nr_masters))
+		for (tmp = 0; tmp < pdata->nr_masters; tmp++)
+			pdata->data_width[tmp] = arr[tmp];
+
+	return pdata;
+}
+#else
+static inline struct dw_dma_platform_data *
+dw_dma_parse_dt(struct platform_device *pdev)
+{
+	return NULL;
+}
+#endif
+
+static int dw_probe(struct platform_device *pdev)
+{
+	struct dw_dma_chip *chip;
+	struct device *dev = &pdev->dev;
+	struct resource *mem;
+	struct dw_dma_platform_data *pdata;
+	int err;
+
+	chip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	chip->irq = platform_get_irq(pdev, 0);
+	if (chip->irq < 0)
+		return chip->irq;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	chip->regs = devm_ioremap_resource(dev, mem);
+	if (IS_ERR(chip->regs))
+		return PTR_ERR(chip->regs);
+
+	/* Apply default dma_mask if needed */
+	if (!dev->dma_mask) {
+		dev->dma_mask = &dev->coherent_dma_mask;
+		dev->coherent_dma_mask = DMA_BIT_MASK(32);
+	}
+
+	pdata = dev_get_platdata(dev);
+	if (!pdata)
+		pdata = dw_dma_parse_dt(pdev);
+
+	chip->dev = dev;
+
+	err = dw_dma_probe(chip, pdata);
+	if (err)
+		return err;
+
+	platform_set_drvdata(pdev, chip);
+
+	if (pdev->dev.of_node) {
+		err = of_dma_controller_register(pdev->dev.of_node,
+						 dw_dma_of_xlate, chip->dw);
+		if (err)
+			dev_err(&pdev->dev,
+				"could not register of_dma_controller\n");
+	}
+
+	if (ACPI_HANDLE(&pdev->dev))
+		dw_dma_acpi_controller_register(chip->dw);
+
+	return 0;
+}
+
+static int dw_remove(struct platform_device *pdev)
+{
+	struct dw_dma_chip *chip = platform_get_drvdata(pdev);
+
+	if (pdev->dev.of_node)
+		of_dma_controller_free(pdev->dev.of_node);
+
+	return dw_dma_remove(chip);
+}
+
+static void dw_shutdown(struct platform_device *pdev)
+{
+	struct dw_dma_chip *chip = platform_get_drvdata(pdev);
+
+	dw_dma_shutdown(chip);
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id dw_dma_of_id_table[] = {
+	{ .compatible = "snps,dma-spear1340" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, dw_dma_of_id_table);
+#endif
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id dw_dma_acpi_id_table[] = {
+	{ "INTL9C60", 0 },
+	{ }
+};
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+
+static int dw_suspend_noirq(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dw_dma_chip *chip = platform_get_drvdata(pdev);
+
+	return dw_dma_suspend(chip);
+}
+
+static int dw_resume_noirq(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dw_dma_chip *chip = platform_get_drvdata(pdev);
+
+	return dw_dma_resume(chip);
+}
+
+#else /* !CONFIG_PM_SLEEP */
+
+#define dw_suspend_noirq	NULL
+#define dw_resume_noirq		NULL
+
+#endif /* !CONFIG_PM_SLEEP */
+
+static const struct dev_pm_ops dw_dev_pm_ops = {
+	.suspend_noirq = dw_suspend_noirq,
+	.resume_noirq = dw_resume_noirq,
+	.freeze_noirq = dw_suspend_noirq,
+	.thaw_noirq = dw_resume_noirq,
+	.restore_noirq = dw_resume_noirq,
+	.poweroff_noirq = dw_suspend_noirq,
+};
+
+static struct platform_driver dw_driver = {
+	.probe		= dw_probe,
+	.remove		= dw_remove,
+	.shutdown	= dw_shutdown,
+	.driver = {
+		.name	= "dw_dmac",
+		.pm	= &dw_dev_pm_ops,
+		.of_match_table = of_match_ptr(dw_dma_of_id_table),
+		.acpi_match_table = ACPI_PTR(dw_dma_acpi_id_table),
+	},
+};
+
+static int __init dw_init(void)
+{
+	return platform_driver_register(&dw_driver);
+}
+subsys_initcall(dw_init);
+
+static void __exit dw_exit(void)
+{
+	platform_driver_unregister(&dw_driver);
+}
+module_exit(dw_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Synopsys DesignWare DMA Controller platform driver");
