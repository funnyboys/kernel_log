commit d0dff2ac98dd41d7d451127d9eae2f6478fc40b0
Author: Benjamin Block <bblock@linux.ibm.com>
Date:   Fri May 8 19:23:35 2020 +0200

    scsi: zfcp: Move allocation of the shost object to after xconf- and xport-data
    
    At the moment we allocate and register the Scsi_Host object corresponding
    to a zfcp adapter (FCP device) very early in the life cycle of the adapter
    - even before we fully discover and initialize the underlying
    firmware/hardware. This had the advantage that we could already use the
    Scsi_Host object, and fill in all its information during said discover and
    initialize.
    
    Due to commit 737eb78e82d5 ("block: Delay default elevator initialization")
    (first released in v5.4), we noticed a regression that would prevent us
    from using any storage volume if zfcp is configured with support for DIF or
    DIX (zfcp.dif=1 || zfcp.dix=1). Doing so would result in an illegal memory
    access as soon as the first request is sent with such an configuration. As
    example for a crash resulting from this:
    
      scsi host0: scsi_eh_0: sleeping
      scsi host0: zfcp
      qdio: 0.0.1900 ZFCP on SC 4bd using AI:1 QEBSM:0 PRI:1 TDD:1 SIGA: W AP
      scsi 0:0:0:0: scsi scan: INQUIRY pass 1 length 36
      Unable to handle kernel pointer dereference in virtual kernel address space
      Failing address: 0000000000000000 TEID: 0000000000000483
      Fault in home space mode while using kernel ASCE.
      AS:0000000035c7c007 R3:00000001effcc007 S:00000001effd1000 P:000000000000003d
      Oops: 0004 ilc:3 [#1] PREEMPT SMP DEBUG_PAGEALLOC
      Modules linked in: ...
      CPU: 1 PID: 783 Comm: kworker/u760:5 Kdump: loaded Not tainted 5.6.0-rc2-bb-next+ #1
      Hardware name: ...
      Workqueue: scsi_wq_0 fc_scsi_scan_rport [scsi_transport_fc]
      Krnl PSW : 0704e00180000000 000003ff801fcdae (scsi_queue_rq+0x436/0x740 [scsi_mod])
                 R:0 T:1 IO:1 EX:1 Key:0 M:1 W:0 P:0 AS:3 CC:2 PM:0 RI:0 EA:3
      Krnl GPRS: 0fffffffffffffff 0000000000000000 0000000187150120 0000000000000000
                 000003ff80223d20 000000000000018e 000000018adc6400 0000000187711000
                 000003e0062337e8 00000001ae719000 0000000187711000 0000000187150000
                 00000001ab808100 0000000187150120 000003ff801fcd74 000003e0062336a0
      Krnl Code: 000003ff801fcd9e: e310a35c0012        lt      %r1,860(%r10)
                 000003ff801fcda4: a7840010           brc     8,000003ff801fcdc4
                #000003ff801fcda8: e310b2900004       lg      %r1,656(%r11)
                >000003ff801fcdae: d71710001000       xc      0(24,%r1),0(%r1)
                 000003ff801fcdb4: e310b2900004       lg      %r1,656(%r11)
                 000003ff801fcdba: 41201018           la      %r2,24(%r1)
                 000003ff801fcdbe: e32010000024       stg     %r2,0(%r1)
                 000003ff801fcdc4: b904002b           lgr     %r2,%r11
      Call Trace:
       [<000003ff801fcdae>] scsi_queue_rq+0x436/0x740 [scsi_mod]
      ([<000003ff801fcd74>] scsi_queue_rq+0x3fc/0x740 [scsi_mod])
       [<00000000349c9970>] blk_mq_dispatch_rq_list+0x390/0x680
       [<00000000349d1596>] blk_mq_sched_dispatch_requests+0x196/0x1a8
       [<00000000349c7a04>] __blk_mq_run_hw_queue+0x144/0x160
       [<00000000349c7ab6>] __blk_mq_delay_run_hw_queue+0x96/0x228
       [<00000000349c7d5a>] blk_mq_run_hw_queue+0xd2/0xe0
       [<00000000349d194a>] blk_mq_sched_insert_request+0x192/0x1d8
       [<00000000349c17b8>] blk_execute_rq_nowait+0x80/0x90
       [<00000000349c1856>] blk_execute_rq+0x6e/0xb0
       [<000003ff801f8ac2>] __scsi_execute+0xe2/0x1f0 [scsi_mod]
       [<000003ff801fef98>] scsi_probe_and_add_lun+0x358/0x840 [scsi_mod]
       [<000003ff8020001c>] __scsi_scan_target+0xc4/0x228 [scsi_mod]
       [<000003ff80200254>] scsi_scan_target+0xd4/0x100 [scsi_mod]
       [<000003ff802d8b96>] fc_scsi_scan_rport+0x96/0xc0 [scsi_transport_fc]
       [<0000000034245ce8>] process_one_work+0x458/0x7d0
       [<00000000342462a2>] worker_thread+0x242/0x448
       [<0000000034250994>] kthread+0x15c/0x170
       [<0000000034e1979c>] ret_from_fork+0x30/0x38
      INFO: lockdep is turned off.
      Last Breaking-Event-Address:
       [<000003ff801fbc36>] scsi_add_cmd_to_list+0x9e/0xa8 [scsi_mod]
      Kernel panic - not syncing: Fatal exception: panic_on_oops
    
    While this issue is exposed by the commit named above, this is only by
    accident. The real issue exists for longer already - basically since it's
    possible to use blk-mq via scsi-mq, and blk-mq pre-allocates all requests
    for a tag-set during initialization of the same. For a given Scsi_Host
    object this is done when adding the object to the midlayer
    (`scsi_add_host()` and such). In `scsi_mq_setup_tags()` the midlayer
    calculates how much memory is required for a single scsi_cmnd, and its
    additional data, which also might include space for additional protection
    data - depending on whether the Scsi_Host has any form of protection
    capabilities (`scsi_host_get_prot()`).
    
    The problem is now thus, because zfcp does this step before we actually
    know whether the firmware/hardware has these capabilities, we don't set any
    protection capabilities in the Scsi_Host object. And so, no space is
    allocated for additional protection data for requests in the Scsi_Host
    tag-set.
    
    Once we go through discover and initialize the FCP device firmware/hardware
    fully (this is done via the firmware commands "Exchange Config Data" and
    "Exchange Port Data") we find out whether it actually supports DIF and DIX,
    and we set the corresponding capabilities in the Scsi_Host object (in
    `zfcp_scsi_set_prot()`). Now the Scsi_Host potentially has protection
    capabilities, but the already allocated requests in the tag-set don't have
    any space allocated for that.
    
    When we then trigger target scanning or add scsi_devices manually, the
    midlayer will use requests from that tag-set, and before sending most
    requests, it will also call `scsi_mq_prep_fn()`. To prepare the scsi_cmnd
    this function will check again whether the used Scsi_Host has any
    protection capabilities - and now it potentially has - and if so, it will
    try to initialize the assumed to be preallocated structures and thus it
    causes the crash, like shown above.
    
    Before delaying the default elevator initialization with the commit named
    above, we always would also allocate an elevator for any scsi_device before
    ever sending any requests - in contrast to now, where we do it after
    device-probing. That elevator in turn would have its own tag-set, and that
    is initialized after we went through discovery and initialization of the
    underlying firmware/hardware. So requests from that tag-set can be
    allocated properly, and if used - unless the user changes/disabled the
    default elevator - this would hide the underlying issue.
    
    To fix this for any configuration - with or without an elevator - we move
    the allocation and registration of the Scsi_Host object for a given FCP
    device to after the first complete discovery and initialization of the
    underlying firmware/hardware. By doing that we can make all basic
    properties of the Scsi_Host known to the midlayer by the time we call
    `scsi_add_host()`, including whether we have any protection capabilities.
    
    To do that we have to delay all the accesses that we would have done in the
    past during discovery and initialization, and do them instead once we are
    finished with it. The previous patches ramp up to this by fencing and
    factoring out all these accesses, and make it possible to re-do them later
    on. In addition we make also use of the diagnostic buffers we recently
    added with
    
    commit 92953c6e0aa7 ("scsi: zfcp: signal incomplete or error for sync exchange config/port data")
    commit 7e418833e689 ("scsi: zfcp: diagnostics buffer caching and use for exchange port data")
    commit 088210233e6f ("scsi: zfcp: add diagnostics buffer for exchange config data")
    
    (first released in v5.5), because these already cache all the information
    we need for that "re-do operation" - the information cached are always
    updated during xconf or xport data, so it won't be stale.
    
    In addition to the move and re-do, this patch also updates the
    function-documentation of `zfcp_scsi_adapter_register()` and changes how it
    reports if a Scsi_Host object already exists. In that case future
    recovery-operations can skip this step completely and behave much like they
    would do in the past - zfcp does not release a once allocated Scsi_Host
    object unless the corresponding FCP device is deconstructed completely.
    
    Link: https://lore.kernel.org/r/030dd6da318bbb529f0b5268ec65cebcd20fc0a3.1588956679.git.bblock@linux.ibm.com
    Reviewed-by: Steffen Maier <maier@linux.ibm.com>
    Signed-off-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index f98e4015a0ed..d58bf79892f2 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -451,26 +451,39 @@ static struct scsi_host_template zfcp_scsi_host_template = {
 };
 
 /**
- * zfcp_scsi_adapter_register - Register SCSI and FC host with SCSI midlayer
+ * zfcp_scsi_adapter_register() - Allocate and register SCSI and FC host with
+ *				  SCSI midlayer
  * @adapter: The zfcp adapter to register with the SCSI midlayer
+ *
+ * Allocates the SCSI host object for the given adapter, sets basic properties
+ * (such as the transport template, QDIO limits, ...), and registers it with
+ * the midlayer.
+ *
+ * During registration with the midlayer the corresponding FC host object for
+ * the referenced transport class is also implicitely allocated.
+ *
+ * Upon success adapter->scsi_host is set, and upon failure it remains NULL. If
+ * adapter->scsi_host is already set, nothing is done.
+ *
+ * Return:
+ * * 0	     - Allocation and registration was successful
+ * * -EEXIST - SCSI and FC host did already exist, nothing was done, nothing
+ *	       was changed
+ * * -EIO    - Allocation or registration failed
  */
 int zfcp_scsi_adapter_register(struct zfcp_adapter *adapter)
 {
 	struct ccw_dev_id dev_id;
 
 	if (adapter->scsi_host)
-		return 0;
+		return -EEXIST;
 
 	ccw_device_get_id(adapter->ccw_device, &dev_id);
 	/* register adapter as SCSI host with mid layer of SCSI stack */
 	adapter->scsi_host = scsi_host_alloc(&zfcp_scsi_host_template,
 					     sizeof (struct zfcp_adapter *));
-	if (!adapter->scsi_host) {
-		dev_err(&adapter->ccw_device->dev,
-			"Registering the FCP device with the "
-			"SCSI stack failed\n");
-		return -EIO;
-	}
+	if (!adapter->scsi_host)
+		goto err_out;
 
 	/* tell the SCSI stack some characteristics of this adapter */
 	adapter->scsi_host->max_id = 511;
@@ -480,14 +493,23 @@ int zfcp_scsi_adapter_register(struct zfcp_adapter *adapter)
 	adapter->scsi_host->max_cmd_len = 16; /* in struct fcp_cmnd */
 	adapter->scsi_host->transportt = zfcp_scsi_transport_template;
 
+	/* make all basic properties known at registration time */
+	zfcp_qdio_shost_update(adapter, adapter->qdio);
+	zfcp_scsi_set_prot(adapter);
+
 	adapter->scsi_host->hostdata[0] = (unsigned long) adapter;
 
 	if (scsi_add_host(adapter->scsi_host, &adapter->ccw_device->dev)) {
 		scsi_host_put(adapter->scsi_host);
-		return -EIO;
+		goto err_out;
 	}
 
 	return 0;
+err_out:
+	adapter->scsi_host = NULL;
+	dev_err(&adapter->ccw_device->dev,
+		"Registering the FCP device with the SCSI stack failed\n");
+	return -EIO;
 }
 
 /**

commit 52e61fde5ec95cb4011784fb0bc6b436e16fcaa8
Author: Benjamin Block <bblock@linux.ibm.com>
Date:   Fri May 8 19:23:30 2020 +0200

    scsi: zfcp: Move fc_host updates during xport data handling into fenced function
    
    When executing exchange port data for a FCP device for the first time, or
    after an adapter recovery, we update several properties of the fibre
    channel host object which represents that FCP device.
    
    When moving the scsi host object allocation and registration - and thus
    also the fibre channel host object allocation - to after the first exchange
    config and exchange port data, this is not possible for the former case.
    
    Move all these update into separate, and fenced function that first checks
    whether the scsi host object already exists or not, before making the
    updates.
    
    During the first ever exchange port data in the adapter life cycle this
    will make the exchange port data handler skip over this update step, but we
    can repeat it later, after we allocated the scsi host object.
    
    For any further recovery of that adapter the work flow is only changed
    slightly because then the scsi host object already exists and we don't free
    it until we release the adapter completely at the end of its life cycle.
    
    Link: https://lore.kernel.org/r/ae454c2dc6da0b02907c489af91d0b211d331825.1588956679.git.bblock@linux.ibm.com
    Reviewed-by: Steffen Maier <maier@linux.ibm.com>
    Signed-off-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index e1281a1ce488..f98e4015a0ed 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -911,6 +911,25 @@ void zfcp_scsi_shost_update_config_data(
 	}
 }
 
+void zfcp_scsi_shost_update_port_data(
+	struct zfcp_adapter *const adapter,
+	const struct fsf_qtcb_bottom_port *const bottom)
+{
+	struct Scsi_Host *const shost = adapter->scsi_host;
+
+	if (shost == NULL)
+		return;
+
+	fc_host_permanent_port_name(shost) = bottom->wwpn;
+	fc_host_maxframe_size(shost) = bottom->maximum_frame_size;
+	fc_host_supported_speeds(shost) =
+		zfcp_fsf_convert_portspeed(bottom->supported_speed);
+	memcpy(fc_host_supported_fc4s(shost), bottom->supported_fc4_types,
+	       FC_FC4_LIST_SIZE);
+	memcpy(fc_host_active_fc4s(shost), bottom->active_fc4_types,
+	       FC_FC4_LIST_SIZE);
+}
+
 struct fc_function_template zfcp_transport_functions = {
 	.show_starget_port_id = 1,
 	.show_starget_port_name = 1,

commit bd1684817d7d8d1a3b95a4347166246ad1f7670b
Author: Benjamin Block <bblock@linux.ibm.com>
Date:   Fri May 8 19:23:29 2020 +0200

    scsi: zfcp: Move shost updates during xconfig data handling into fenced function
    
    When executing exchange config data for a FCP device for the first time, or
    after an adapter recovery, we update several properties of the scsi host or
    fibre channel host object that represent that FCP device.
    
    When moving the scsi host object allocation and registration - and thus
    also the fibre channel host object allocation - to after the first exchange
    config and exchange port data, this is not possible for the former case.
    
    Move all these update into separate, and fenced function that first checks
    whether the scsi host object already exists or not, before making the
    updates.
    
    During the first ever exchange config data in the adapter life cycle this
    will make the exchange config data handler skip over this update step, but
    we can repeat it later, after we allocated the scsi host object.
    
    For any further recovery of that adapter the work flow is only changed
    slightly because then the scsi host object already exists and we don't free
    it until we release the adapter completely at the end of its life cycle.
    
    Link: https://lore.kernel.org/r/5fc3f4d38d4334f7aa595497c6f7865fb1102e0f.1588956679.git.bblock@linux.ibm.com
    Reviewed-by: Steffen Maier <maier@linux.ibm.com>
    Signed-off-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 13d873f806e4..e1281a1ce488 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -4,7 +4,7 @@
  *
  * Interface to Linux SCSI midlayer.
  *
- * Copyright IBM Corp. 2002, 2018
+ * Copyright IBM Corp. 2002, 2020
  */
 
 #define KMSG_COMPONENT "zfcp"
@@ -841,6 +841,76 @@ void zfcp_scsi_dif_sense_error(struct scsi_cmnd *scmd, int ascq)
 	set_host_byte(scmd, DID_SOFT_ERROR);
 }
 
+void zfcp_scsi_shost_update_config_data(
+	struct zfcp_adapter *const adapter,
+	const struct fsf_qtcb_bottom_config *const bottom,
+	const bool bottom_incomplete)
+{
+	struct Scsi_Host *const shost = adapter->scsi_host;
+	const struct fc_els_flogi *nsp, *plogi;
+
+	if (shost == NULL)
+		return;
+
+	snprintf(fc_host_firmware_version(shost), FC_VERSION_STRING_SIZE,
+		 "0x%08x", bottom->lic_version);
+
+	if (adapter->adapter_features & FSF_FEATURE_HBAAPI_MANAGEMENT) {
+		snprintf(fc_host_hardware_version(shost),
+			 FC_VERSION_STRING_SIZE,
+			 "0x%08x", bottom->hardware_version);
+		memcpy(fc_host_serial_number(shost), bottom->serial_number,
+		       min(FC_SERIAL_NUMBER_SIZE, 17));
+		EBCASC(fc_host_serial_number(shost),
+		       min(FC_SERIAL_NUMBER_SIZE, 17));
+	}
+
+	/* adjust pointers for missing command code */
+	nsp = (struct fc_els_flogi *) ((u8 *)&bottom->nport_serv_param
+					- sizeof(u32));
+	plogi = (struct fc_els_flogi *) ((u8 *)&bottom->plogi_payload
+					- sizeof(u32));
+
+	snprintf(fc_host_manufacturer(shost), FC_SERIAL_NUMBER_SIZE, "%s",
+		 "IBM");
+	fc_host_port_name(shost) = be64_to_cpu(nsp->fl_wwpn);
+	fc_host_node_name(shost) = be64_to_cpu(nsp->fl_wwnn);
+	fc_host_supported_classes(shost) = FC_COS_CLASS2 | FC_COS_CLASS3;
+
+	zfcp_scsi_set_prot(adapter);
+
+	/* do not evaluate invalid fields */
+	if (bottom_incomplete)
+		return;
+
+	fc_host_port_id(shost) = ntoh24(bottom->s_id);
+	fc_host_speed(shost) =
+		zfcp_fsf_convert_portspeed(bottom->fc_link_speed);
+
+	snprintf(fc_host_model(shost), FC_SYMBOLIC_NAME_SIZE, "0x%04x",
+		 bottom->adapter_type);
+
+	switch (bottom->fc_topology) {
+	case FSF_TOPO_P2P:
+		fc_host_port_type(shost) = FC_PORTTYPE_PTP;
+		fc_host_fabric_name(shost) = 0;
+		break;
+	case FSF_TOPO_FABRIC:
+		fc_host_fabric_name(shost) = be64_to_cpu(plogi->fl_wwnn);
+		if (bottom->connection_features & FSF_FEATURE_NPIV_MODE)
+			fc_host_port_type(shost) = FC_PORTTYPE_NPIV;
+		else
+			fc_host_port_type(shost) = FC_PORTTYPE_NPORT;
+		break;
+	case FSF_TOPO_AL:
+		fc_host_port_type(shost) = FC_PORTTYPE_NLPORT;
+		fallthrough;
+	default:
+		fc_host_fabric_name(shost) = 0;
+		break;
+	}
+}
+
 struct fc_function_template zfcp_transport_functions = {
 	.show_starget_port_id = 1,
 	.show_starget_port_name = 1,

commit 538c6e910baea9a94ba2a816c19c3e071892b49c
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Thu Mar 12 18:44:58 2020 +0100

    scsi: zfcp: wire previously driver-specific sysfs attributes also to fc_host
    
    Manufacturer, HBA model, firmware version, and hardware version.  Use the
    same value format as for the driver-specific attributes.  Keep the
    driver-specific attributes for stable user space sysfs API.
    
    Link: https://lore.kernel.org/r/20200312174505.51294-4-maier@linux.ibm.com
    Reviewed-by: Jens Remus <jremus@linux.ibm.com>
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index cb7efe8b2753..13d873f806e4 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -856,6 +856,10 @@ struct fc_function_template zfcp_transport_functions = {
 	.show_host_supported_speeds = 1,
 	.show_host_maxframe_size = 1,
 	.show_host_serial_number = 1,
+	.show_host_manufacturer = 1,
+	.show_host_model = 1,
+	.show_host_hardware_version = 1,
+	.show_host_firmware_version = 1,
 	.get_fc_host_stats = zfcp_scsi_get_fc_host_stats,
 	.reset_fc_host_stats = zfcp_scsi_reset_fc_host_stats,
 	.set_rport_dev_loss_tmo = zfcp_scsi_set_rport_dev_loss_tmo,

commit e05a10a055098bf55168a9d682156e38c6b00cfa
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Thu Mar 12 18:44:57 2020 +0100

    scsi: zfcp: expose fabric name as common fc_host sysfs attribute
    
    FICON Express8S or older, as well as card features newer than FICON
    Express16S+ have no certain firmware level requirement.
    
    FICON Express16S or FICON Express16S+ have the following
    minimum firmware level requirements to show a proper fabric name value:
    
     z13 machine
      FICON Express16S  , MCL P08424.005 , LIC version 0x00000721
     z14 machine
      FICON Express16S  , MCL P42611.008 , LIC version 0x10200069
      FICON Express16S+ , MCL P42625.010 , LIC version 0x10300147
    
    Otherwise, the read value is not the fabric name.
    
    Each FCP channel of these card features might need one SAN fabric re-login
    after concurrent microcode update in order to show the proper fabric name.
    Possible ways to trigger a SAN fabric re-login are one of: Pull fibres
    between FCP channel port and SAN switch port on either side and re-plug,
    disable SAN switch port adjacent to FCP channel port and re-enable switch
    port, or at Service Element toggle off all CHPIDs of FCP channel over all
    LPARs and toggle CHPIDs on again.  Zfcp operating subchannels (FCP devices)
    on such FCP channel recovers a fabric re-login.
    
    Initialize fabric name for any topology and have it an invalid WWPN 0x0 for
    anything but fabric topology.  Otherwise for e.g. point-to-point topology
    one could see the initial -1 from fc_host_setup() and after a link unplug
    our fabric name would turn to 0x0 (with subsequent commit ("zfcp: fix
    fc_host attributes that should be unknown on local link down") and stay 0x0
    on link replug.  I did not initialize to 0x0 somewhere even earlier in the
    code path such that it would not flap from real to 0x0 to real on e.g. an
    exchange config data with fabric topology.
    
    Link: https://lore.kernel.org/r/20200312174505.51294-3-maier@linux.ibm.com
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Reviewed-by: Jens Remus <jremus@linux.ibm.com>
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 3910d529c15a..cb7efe8b2753 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -871,5 +871,6 @@ struct fc_function_template zfcp_transport_functions = {
 	.show_host_symbolic_name = 1,
 	.show_host_speed = 1,
 	.show_host_port_id = 1,
+	.show_host_fabric_name = 1,
 	.dd_bsg_size = sizeof(struct zfcp_fsf_ct_els),
 };

commit 92953c6e0aa77d4febcca6dd691e8192910c8a28
Author: Benjamin Block <bblock@linux.ibm.com>
Date:   Fri Oct 25 18:12:43 2019 +0200

    scsi: zfcp: signal incomplete or error for sync exchange config/port data
    
    Adds a new FSF-Request status flag (ZFCP_STATUS_FSFREQ_XDATAINCOMPLETE)
    that signal that the data received using Exchange Config Data or Exchange
    Port Data was incomplete. This new flags is set in the respective handlers
    during the response path.
    
    With this patch, only the synchronous FSF-functions for each command got
    support for the new flag, otherwise it is transparent.
    
    Together with this new flag and already existing status flags the
    synchronous FSF-functions are extended to now detect whether the received
    data is complete, incomplete or completely invalid (this includes cases
    where a command ran into a timeout). This is now signaled back to the
    caller, where previously only failures on the request path would result in
    a bad return-code.
    
    For complete data the return-code remains 0. For incomplete data a new
    return-code -EAGAIN is added to the function-interface. For completely
    invalid data the already existing return-code -EIO is reused - formerly
    this was used to signal failures on the request path.
    
    Existing callers of the FSF-functions are adjusted so that they behave as
    before for return-code 0 and -EAGAIN, to not change the user-interface. As
    -EIO existed all along, it was already exposed to the user - and needed
    handling - and will now also be exposed in this new special case.
    
    Link: https://lore.kernel.org/r/e14f0702fa2b00a4d1f37c7981a13f2dd1ea2c83.1572018130.git.bblock@linux.ibm.com
    Reviewed-by: Steffen Maier <maier@linux.ibm.com>
    Signed-off-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index e9ded2befa0d..3910d529c15a 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -605,7 +605,7 @@ zfcp_scsi_get_fc_host_stats(struct Scsi_Host *host)
 		return NULL;
 
 	ret = zfcp_fsf_exchange_port_data_sync(adapter->qdio, data);
-	if (ret) {
+	if (ret != 0 && ret != -EAGAIN) {
 		kfree(data);
 		return NULL;
 	}
@@ -634,7 +634,7 @@ static void zfcp_scsi_reset_fc_host_stats(struct Scsi_Host *shost)
 		return;
 
 	ret = zfcp_fsf_exchange_port_data_sync(adapter->qdio, data);
-	if (ret)
+	if (ret != 0 && ret != -EAGAIN)
 		kfree(data);
 	else {
 		adapter->stats_reset = jiffies/HZ;

commit ef4021fe5fd77ced0323cede27979d80a56211ca
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Thu May 23 15:23:46 2019 +0200

    scsi: zfcp: fix to prevent port_remove with pure auto scan LUNs (only sdevs)
    
    When the user tries to remove a zfcp port via sysfs, we only rejected it if
    there are zfcp unit children under the port. With purely automatically
    scanned LUNs there are no zfcp units but only SCSI devices. In such cases,
    the port_remove erroneously continued. We close the port and this
    implicitly closes all LUNs under the port. The SCSI devices survive with
    their private zfcp_scsi_dev still holding a reference to the "removed"
    zfcp_port (still allocated but invisible in sysfs) [zfcp_get_port_by_wwpn
    in zfcp_scsi_slave_alloc]. This is not a problem as long as the fc_rport
    stays blocked. Once (auto) port scan brings back the removed port, we
    unblock its fc_rport again by design.  However, there is no mechanism that
    would recover (open) the LUNs under the port (no "ersfs_3" without
    zfcp_unit [zfcp_erp_strategy_followup_success]).  Any pending or new I/O to
    such LUN leads to repeated:
    
      Done: NEEDS_RETRY Result: hostbyte=DID_IMM_RETRY driverbyte=DRIVER_OK
    
    See also v4.10 commit 6f2ce1c6af37 ("scsi: zfcp: fix rport unblock race
    with LUN recovery"). Even a manual LUN recovery
    (echo 0 > /sys/bus/scsi/devices/H:C:T:L/zfcp_failed)
    does not help, as the LUN links to the old "removed" port which remains
    to lack ZFCP_STATUS_COMMON_RUNNING [zfcp_erp_required_act].
    The only workaround is to first ensure that the fc_rport is blocked
    (e.g. port_remove again in case it was re-discovered by (auto) port scan),
    then delete the SCSI devices, and finally re-discover by (auto) port scan.
    The port scan includes an fc_rport unblock, which in turn triggers
    a new scan on the scsi target to freshly get new pure auto scan LUNs.
    
    Fix this by rejecting port_remove also if there are SCSI devices
    (even without any zfcp_unit) under this port. Re-use mechanics from v3.7
    commit d99b601b6338 ("[SCSI] zfcp: restore refcount check on port_remove").
    However, we have to give up zfcp_sysfs_port_units_mutex earlier in unit_add
    to prevent a deadlock with scsi_host scan taking shost->scan_mutex first
    and then zfcp_sysfs_port_units_mutex now in our zfcp_scsi_slave_alloc().
    
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Fixes: b62a8d9b45b9 ("[SCSI] zfcp: Use SCSI device data zfcp scsi dev instead of zfcp unit")
    Fixes: f8210e34887e ("[SCSI] zfcp: Allow midlayer to scan for LUNs when running in NPIV mode")
    Cc: <stable@vger.kernel.org> #2.6.37+
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 221d0dfb8493..e9ded2befa0d 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -129,6 +129,15 @@ static int zfcp_scsi_slave_alloc(struct scsi_device *sdev)
 
 	zfcp_sdev->erp_action.port = port;
 
+	mutex_lock(&zfcp_sysfs_port_units_mutex);
+	if (zfcp_sysfs_port_is_removing(port)) {
+		/* port is already gone */
+		mutex_unlock(&zfcp_sysfs_port_units_mutex);
+		put_device(&port->dev); /* undo zfcp_get_port_by_wwpn() */
+		return -ENXIO;
+	}
+	mutex_unlock(&zfcp_sysfs_port_units_mutex);
+
 	unit = zfcp_unit_find(port, zfcp_scsi_dev_lun(sdev));
 	if (unit)
 		put_device(&unit->dev);

commit 242ec1455151267fe35a0834aa9038e4c4670884
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Tue Mar 26 14:36:59 2019 +0100

    scsi: zfcp: fix scsi_eh host reset with port_forced ERP for non-NPIV FCP devices
    
    Suppose more than one non-NPIV FCP device is active on the same channel.
    Send I/O to storage and have some of the pending I/O run into a SCSI
    command timeout, e.g. due to bit errors on the fibre. Now the error
    situation stops. However, we saw FCP requests continue to timeout in the
    channel. The abort will be successful, but the subsequent TUR fails.
    Scsi_eh starts. The LUN reset fails. The target reset fails.  The host
    reset only did an FCP device recovery. However, for non-NPIV FCP devices,
    this does not close and reopen ports on the SAN-side if other non-NPIV FCP
    device(s) share the same open ports.
    
    In order to resolve the continuing FCP request timeouts, we need to
    explicitly close and reopen ports on the SAN-side.
    
    This was missing since the beginning of zfcp in v2.6.0 history commit
    ea127f975424 ("[PATCH] s390 (7/7): zfcp host adapter.").
    
    Note: The FSF requests for forced port reopen could run into FSF request
    timeouts due to other reasons. This would trigger an internal FCP device
    recovery. Pending forced port reopen recoveries would get dismissed. So
    some ports might not get fully reopened during this host reset handler.
    However, subsequent I/O would trigger the above described escalation and
    eventually all ports would be forced reopen to resolve any continuing FCP
    request timeouts due to earlier bit errors.
    
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Cc: <stable@vger.kernel.org> #3.0+
    Reviewed-by: Jens Remus <jremus@linux.ibm.com>
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index f4f6a07c5222..221d0dfb8493 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -368,6 +368,10 @@ static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 	struct zfcp_adapter *adapter = zfcp_sdev->port->adapter;
 	int ret = SUCCESS, fc_ret;
 
+	if (!(adapter->connection_features & FSF_FEATURE_NPIV_MODE)) {
+		zfcp_erp_port_forced_reopen_all(adapter, 0, "schrh_p");
+		zfcp_erp_wait(adapter);
+	}
 	zfcp_erp_adapter_reopen(adapter, 0, "schrh_1");
 	zfcp_erp_wait(adapter);
 	fc_ret = fc_block_scsi_eh(scpnt);

commit b63195698dea6ea83eeede20e38dbc6ad67076b6
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Thu Jan 24 17:40:34 2019 +0100

    scsi: zfcp: fix sysfs block queue limit output for max_segment_size
    
    Since v2.6.35 commit 683229845f17 ("[SCSI] zfcp: Report scatter-gather
    limits to SCSI and block layer"), zfcp set dma_parms.max_segment_size ==
    PAGE_SIZE (but without using the setter dma_set_max_seg_size()) and
    scsi_host_template.dma_boundary == PAGE_SIZE - 1.
    
    v5.0-rc1 commit 50c2e9107f17 ("scsi: introduce a max_segment_size
    host_template parameters") introduced a new field
    scsi_host_template.max_segment_size. If an LLDD such as zfcp does not set
    it, scsi_host_alloc() uses BLK_MAX_SEGMENT_SIZE = 65536 for
    Scsi_Host.max_segment_size. __scsi_init_queue() announced the minimum of
    Scsi_Host.max_segment_size and dma_parms.max_segment_size to the block
    layer. For zfcp: min(65536, 4096) == 4096 which was still good.
    
    v5.0 commit a8cf59a6692c ("scsi: communicate max segment size to the DMA
    mapping code") announces Scsi_Host.max_segment_size to the block layer and
    overwrites dma_parms.max_segment_size with Scsi_Host.max_segment_size.  For
    zfcp dma_parms.max_segment_size == Scsi_Host.max_segment_size == 65536
    which is also reflected in block queue limits.
    
    $ cd /sys/bus/ccw/drivers/zfcp
    $ cd 0.0.3c40/host5/rport-5:0-4/target5:0:4/5:0:4:10/block/sdi/queue
    $ cat max_segment_size
    65536
    
    Zfcp I/O still works because dma_boundary implicitly still keeps the
    effective max segment size <= PAGE_SIZE.  However, dma_boundary does not
    seem visible to user space, but max_segment_size is visible and shows a
    misleading wrong value.  Fix it and inherit the stable tag of a8cf59a6692c.
    
    Devices on our bus ccw support DMA but no DMA mapping. Of multiple device
    types on the ccw bus, only zfcp needs dma_parms for SCSI limits.  So, leave
    dma_parms setup in zfcp and do not move it to the bus.
    
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Fixes: 50c2e9107f ("scsi: introduce a max_segment_size host_template parameters")
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 00acc7144bbc..f4f6a07c5222 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -428,6 +428,8 @@ static struct scsi_host_template zfcp_scsi_host_template = {
 	.max_sectors		 = (((QDIO_MAX_ELEMENTS_PER_BUFFER - 1)
 				     * ZFCP_QDIO_MAX_SBALS_PER_REQ) - 2) * 8,
 				   /* GCD, adjusted later */
+	/* report size limit per scatter-gather segment */
+	.max_segment_size	 = ZFCP_QDIO_SBALE_LEN,
 	.dma_boundary		 = ZFCP_QDIO_SBALE_LEN - 1,
 	.shost_attrs		 = zfcp_sysfs_shost_attrs,
 	.sdev_attrs		 = zfcp_sysfs_sdev_attrs,

commit 2a3d4eb8e228061c09d5ca8bf39e7f00c2091213
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:02 2018 +0100

    scsi: flip the default on use_clustering
    
    Most SCSI drivers want to enable "clustering", that is merging of
    segments so that they might span more than a single page.  Remove the
    ENABLE_CLUSTERING define, and require drivers to explicitly set
    DISABLE_CLUSTERING to disable this feature.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index a8b53ed61c1e..00acc7144bbc 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -429,7 +429,6 @@ static struct scsi_host_template zfcp_scsi_host_template = {
 				     * ZFCP_QDIO_MAX_SBALS_PER_REQ) - 2) * 8,
 				   /* GCD, adjusted later */
 	.dma_boundary		 = ZFCP_QDIO_SBALE_LEN - 1,
-	.use_clustering		 = 1,
 	.shost_attrs		 = zfcp_sysfs_shost_attrs,
 	.sdev_attrs		 = zfcp_sysfs_sdev_attrs,
 	.track_queue_depth	 = 1,

commit 636db60b8e910760c283b7aa928efcc580c1f574
Author: Fedor Loshakov <loshakov@linux.ibm.com>
Date:   Thu Nov 29 13:09:56 2018 +0100

    scsi: zfcp: make DIX experimental, disabled, and independent of DIF
    
    Introduce separate zfcp module parameters to individually select support
    for: DIF which should work (zfcp.dif, which used to be DIF+DIX, disabled)
    or DIX+DIF which can cause trouble (zfcp.dix, new, disabled).
    
    If DIX is enabled, we warn on zfcp driver initialization.  As before, this
    also reduces the maximum I/O request size to half, to support the worst
    case of merged single sector requests with one protection data scatter
    gather element per sector. This can impact the maximum throughput.
    
    In DIF-only mode (zfcp.dif=1 zfcp.dix=0), we can use the full maximum I/O
    request size as there is no protection data for zfcp.
    
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Signed-off-by: Fedor Loshakov <loshakov@linux.ibm.com>
    Reviewed-by: Jens Remus <jremus@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 82dbe2677fc1..a8b53ed61c1e 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -27,7 +27,11 @@ MODULE_PARM_DESC(queue_depth, "Default queue depth for new SCSI devices");
 
 static bool enable_dif;
 module_param_named(dif, enable_dif, bool, 0400);
-MODULE_PARM_DESC(dif, "Enable DIF/DIX data integrity support");
+MODULE_PARM_DESC(dif, "Enable DIF data integrity support (default off)");
+
+bool zfcp_experimental_dix;
+module_param_named(dix, zfcp_experimental_dix, bool, 0400);
+MODULE_PARM_DESC(dix, "Enable experimental DIX (data integrity extension) support which implies DIF support (default off)");
 
 static bool allow_lun_scan = true;
 module_param(allow_lun_scan, bool, 0600);
@@ -790,11 +794,11 @@ void zfcp_scsi_set_prot(struct zfcp_adapter *adapter)
 	data_div = atomic_read(&adapter->status) &
 		   ZFCP_STATUS_ADAPTER_DATA_DIV_ENABLED;
 
-	if (enable_dif &&
+	if ((enable_dif || zfcp_experimental_dix) &&
 	    adapter->adapter_features & FSF_FEATURE_DIF_PROT_TYPE1)
 		mask |= SHOST_DIF_TYPE1_PROTECTION;
 
-	if (enable_dif && data_div &&
+	if (zfcp_experimental_dix && data_div &&
 	    adapter->adapter_features & FSF_FEATURE_DIX_PROT_TCPIP) {
 		mask |= SHOST_DIX_TYPE1_PROTECTION;
 		scsi_host_set_guard(shost, SHOST_DIX_GUARD_IP);

commit f9eca022760079c0556cb311e3aa9091a3921a31
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Thu Nov 8 15:44:45 2018 +0100

    scsi: zfcp: drop duplicate fsf_command from zfcp_fsf_req which is also in QTCB header
    
    Status read buffers (SRBs, unsolicited notifications) never use a QTCB
    [zfcp_fsf_req_create()]. zfcp_fsf_req_send() already uses this to
    distinguish SRBs from other FSF request types. We can re-use this method in
    zfcp_fsf_req_complete(). Introduce a helper function to make the check for
    req->qtcb less magic.
    
    SRBs always are FSF_QTCB_UNSOLICITED_STATUS, so we can hard-code this for
    the two trace functions dealing with SRBs.
    
    All other FSF request types have a QTCB and we can get the fsf_command from
    there.
    
    zfcp_dbf_hba_fsf_response() and thus zfcp_dbf_hba_fsf_res() are only called
    for non-SRB requests so it's safe to dereference the QTCB
    [zfcp_fsf_req_complete() returns early on SRB, else calls
    zfcp_fsf_protstatus_eval() which calls zfcp_dbf_hba_fsf_response()].  In
    zfcp_scsi_forget_cmnd() we guard the QTCB dereference with a preceding NULL
    check and rely on boolean shortcut evaluation.
    
    As a side effect, this causes an alignment hole which we can close in
    a later patch after having cleaned up all fields of struct zfcp_fsf_req.
    Before:
    $ pahole -C zfcp_fsf_req drivers/s390/scsi/zfcp.ko
    ...
            u32                        status;               /*   136     4 */
            u32                        fsf_command;          /*   140     4 */
            struct fsf_qtcb *          qtcb;                 /*   144     8 */
    ...
    After:
    $ pahole -C zfcp_fsf_req drivers/s390/scsi/zfcp.ko
    ...
            u32                        status;               /*   136     4 */
            /* XXX 4 bytes hole, try to pack */
            struct fsf_qtcb *          qtcb;                 /*   144     8 */
    ...
    
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index a8efcb330bc1..82dbe2677fc1 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -226,7 +226,9 @@ static void zfcp_scsi_forget_cmnd(struct zfcp_fsf_req *old_req, void *data)
 		(struct zfcp_scsi_req_filter *)data;
 
 	/* already aborted - prevent side-effects - or not a SCSI command */
-	if (old_req->data == NULL || old_req->fsf_command != FSF_QTCB_FCP_CMND)
+	if (old_req->data == NULL ||
+	    zfcp_fsf_req_is_status_read_buffer(old_req) ||
+	    old_req->qtcb->header.fsf_command != FSF_QTCB_FCP_CMND)
 		return;
 
 	/* (tmf_scope == FCP_TMF_TGT_RESET || tmf_scope == FCP_TMF_LUN_RESET) */

commit 5f85942c2ea2ed59d8f19c954bbb0f5c1a2ebdd1
Merge: 0c14e43a42e4 1b5c2cb19668
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 10 13:01:12 2018 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This is mostly updates to the usual drivers: ufs, qedf, mpt3sas, lpfc,
      xfcp, hisi_sas, cxlflash, qla2xxx.
    
      In the absence of Nic, we're also taking target updates which are
      mostly minor except for the tcmu refactor.
    
      The only real core change to worry about is the removal of high page
      bouncing (in sas, storvsc and iscsi). This has been well tested and no
      problems have shown up so far"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (268 commits)
      scsi: lpfc: update driver version to 12.0.0.4
      scsi: lpfc: Fix port initialization failure.
      scsi: lpfc: Fix 16gb hbas failing cq create.
      scsi: lpfc: Fix crash in blk_mq layer when executing modprobe -r lpfc
      scsi: lpfc: correct oversubscription of nvme io requests for an adapter
      scsi: lpfc: Fix MDS diagnostics failure (Rx < Tx)
      scsi: hisi_sas: Mark PHY as in reset for nexus reset
      scsi: hisi_sas: Fix return value when get_free_slot() failed
      scsi: hisi_sas: Terminate STP reject quickly for v2 hw
      scsi: hisi_sas: Add v2 hw force PHY function for internal ATA command
      scsi: hisi_sas: Include TMF elements in struct hisi_sas_slot
      scsi: hisi_sas: Try wait commands before before controller reset
      scsi: hisi_sas: Init disks after controller reset
      scsi: hisi_sas: Create a scsi_host_template per HW module
      scsi: hisi_sas: Reset disks when discovered
      scsi: hisi_sas: Add LED feature for v3 hw
      scsi: hisi_sas: Change common allocation mode of device id
      scsi: hisi_sas: change slot index allocation mode
      scsi: hisi_sas: Introduce hisi_sas_phy_set_linkrate()
      scsi: hisi_sas: fix a typo in hisi_sas_task_prep()
      ...

commit 35e9111a1e5d820a0eb6bb8e3d8905d2161e13b2
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Thu May 17 19:15:03 2018 +0200

    scsi: zfcp: support SCSI_ADAPTER_RESET via scsi_host sysfs attribute host_reset
    
    Make use of feature introduced with v3.2 commit 294436914454 ("[SCSI] scsi:
    Added support for adapter and firmware reset").  The common code interface
    was introduced for commit 95d31262b3c1 ("[SCSI] qla4xxx: Added support for
    adapter and firmware reset").
    
    $ echo adapter > /sys/class/scsi_host/host<N>/host_reset
    
    Example trace record formatted with zfcpdbf from s390-tools:
    
    Timestamp      : ...
    Area           : REC
    Subarea        : 00
    Level          : 1
    Exception      : -
    CPU ID         : ..
    Caller         : 0x...
    Record ID      : 1                      ZFCP_DBF_REC_TRIG
    Tag            : scshr_y                SCSI sysfs host_reset yes
    LUN            : 0xffffffffffffffff                     none (invalid)
    WWPN           : 0x0000000000000000                     none (invalid)
    D_ID           : 0x00000000                             none (invalid)
    Adapter status : 0x4500050b
    Port status    : 0x00000000                             none (invalid)
    LUN status     : 0x00000000                             none (invalid)
    Ready count    : 0x00000001
    Running count  : 0x00000000
    ERP want       : 0x04                   ZFCP_ERP_ACTION_REOPEN_ADAPTER
    ERP need       : 0x04                   ZFCP_ERP_ACTION_REOPEN_ADAPTER
    
    This is the common code equivalent to the zfcp-specific
    &dev_attr_adapter_failed.attr in zfcp_sysfs_adapter_attrs.attrs[]:
    
    $ echo 0 > /sys/bus/ccw/drivers/zfcp/<devbusid>/failed
    
    The unsupported case returns EOPNOTSUPP:
    
    $ echo firmware > /sys/class/scsi_host/host<N>/host_reset
    -bash: echo: write error: Operation not supported
    
    Example trace record formatted with zfcpdbf from s390-tools:
    
    Timestamp      : ...
    Area           : SCSI
    Subarea        : 00
    Level          : 1
    Exception      : -
    CPU ID         : ..
    Caller         : 0x...
    Record ID      : 1
    Tag            : scshr_n                        SCSI sysfs host_reset no
    Request ID     : 0x0000000000000000                     none (invalid)
    SCSI ID        : 0xffffffff                             none (invalid)
    SCSI LUN       : 0xffffffff                             none (invalid)
    SCSI LUN high  : 0xffffffff                             none (invalid)
    SCSI result    : 0xffffffa1                     -EOPNOTSUPP==-95
    SCSI retries   : 0xff                                   none (invalid)
    SCSI allowed   : 0xff                                   none (invalid)
    SCSI scribble  : 0xffffffffffffffff                     none (invalid)
    SCSI opcode    : ffffffff ffffffff ffffffff ffffffff    none (invalid)
    FCP rsp inf cod: 0xff                                   none (invalid)
    FCP rsp IU     : 00000000 00000000 00000000 00000000    none (invalid)
                     00000000 00000000
    
    For any other invalid value, common code returns EINVAL without invoking
    our callback:
    
    $ echo foo > /sys/class/scsi_host/host<N>/host_reset
    -bash: echo: write error: Invalid argument
    
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index f69ef78ea930..9a01f583e562 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -372,6 +372,31 @@ static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 	return ret;
 }
 
+/**
+ * zfcp_scsi_sysfs_host_reset() - Support scsi_host sysfs attribute host_reset.
+ * @shost: Pointer to Scsi_Host to perform action on.
+ * @reset_type: We support %SCSI_ADAPTER_RESET but not %SCSI_FIRMWARE_RESET.
+ *
+ * Return: 0 on %SCSI_ADAPTER_RESET, -%EOPNOTSUPP otherwise.
+ *
+ * This is similar to zfcp_sysfs_adapter_failed_store().
+ */
+static int zfcp_scsi_sysfs_host_reset(struct Scsi_Host *shost, int reset_type)
+{
+	struct zfcp_adapter *adapter =
+		(struct zfcp_adapter *)shost->hostdata[0];
+	int ret = 0;
+
+	if (reset_type != SCSI_ADAPTER_RESET) {
+		ret = -EOPNOTSUPP;
+		zfcp_dbf_scsi_eh("scshr_n", adapter, ~0, ret);
+		return ret;
+	}
+
+	zfcp_erp_adapter_reset_sync(adapter, "scshr_y");
+	return ret;
+}
+
 struct scsi_transport_template *zfcp_scsi_transport_template;
 
 static struct scsi_host_template zfcp_scsi_host_template = {
@@ -387,6 +412,7 @@ static struct scsi_host_template zfcp_scsi_host_template = {
 	.slave_configure	 = zfcp_scsi_slave_configure,
 	.slave_destroy		 = zfcp_scsi_slave_destroy,
 	.change_queue_depth	 = scsi_change_queue_depth,
+	.host_reset		 = zfcp_scsi_sysfs_host_reset,
 	.proc_name		 = "zfcp",
 	.can_queue		 = 4096,
 	.this_id		 = -1,

commit b24bf22d72c75c4e32e3520041ccdf7c9a2d9e5a
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Thu May 17 19:15:02 2018 +0200

    scsi: zfcp: explicitly support initiator in scsi_host_template
    
    While the default did already correctly print "Initiator" let's make it
    explicit and convert zfcp to the feature.
    
    $ cat /sys/class/scsi_host/host0/supported_mode
    Initiator
    
    $ cat /sys/class/scsi_host/host0/active_mode
    Initiator
    
    The default worked, because not setting the field has it initialized to zero
    == MODE_UNKNOWN. scsi_host_alloc() sets shost->active_mode = MODE_INITIATOR
    in this case. The sysfs accessor function show_shost_supported_mode()
    assumes MODE_INITIATOR in this case.  This default behavior was introduced
    with v2.6.24 commit 7a39ac3f25be ("[SCSI] make supported_mode default to
    initiator.").  The feature flag was introduced with v2.6.24 commit
    5dc2b89e1242 ("[SCSI] add supported_mode and active_mode attributes to the
    host").  So there was no release where zfcp would have shown "unknown".
    
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index b4e1f1b82503..f69ef78ea930 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -401,6 +401,7 @@ static struct scsi_host_template zfcp_scsi_host_template = {
 	.shost_attrs		 = zfcp_sysfs_shost_attrs,
 	.sdev_attrs		 = zfcp_sysfs_sdev_attrs,
 	.track_queue_depth	 = 1,
+	.supported_mode		 = MODE_INITIATOR,
 };
 
 /**

commit d39eda54b70de0a1cb24962c472a87b5d9bc8dcb
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Thu May 17 19:14:58 2018 +0200

    scsi: zfcp: consistently use function name space prefix
    
    I've been mixing up
    zfcp_task_mgmt_function() [SCSI] and
    zfcp_fsf_fcp_task_mgmt()  [FSF]
    so often lately that I wanted to fix this.
    
    SCSI changes complement v2.6.27 commit f76af7d7e363 ("[SCSI] zfcp: Cleanup
    of code in zfcp_scsi.c").
    
    While at it, also fixup the other inconsistencies elsewhere.
    
    ERP changes complement v2.6.27 commit 287ac01acf22 ("[SCSI] zfcp: Cleanup
    code in zfcp_erp.c") which introduced status_change_set().
    
    FC changes complement v2.6.32 commit 6f53a2d2ecae ("[SCSI] zfcp: Apply
    common naming conventions to zfcp_fc").  by renaming a leftover introduced
    with v2.6.27 commit cc8c282963bd ("[SCSI] zfcp: Automatically attach remote
    ports").
    
    FSF changes fixup v2.6.32 commit a4623c467ff7 ("[SCSI] zfcp: Improve request
    allocation through mempools").  which replaced zfcp_fsf_alloc_qtcb()
    introduced with v2.6.27 commit c41f8cbddd4e ("[SCSI] zfcp: zfcp_fsf
    cleanup.").
    
    SCSI fc_host statistics were introduced with v2.6.16 commit f6cd94b126aa
    ("[SCSI] zfcp: transport class adaptations").
    
    SCSI fc_host port_state was introduced with v2.6.27 commit 85a82392fe6f
    ("[SCSI] zfcp: Add port_state attribute to sysfs").
    
    SCSI rport setter for dev_loss_tmo was introduced with v2.6.18 commit
    338151e06608 ("[SCSI] zfcp: make use of fc_remote_port_delete when target
    port is unavailable").
    
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 0f7830ffd40a..b4e1f1b82503 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -266,12 +266,12 @@ static void zfcp_scsi_forget_cmnds(struct zfcp_scsi_dev *zsdev, u8 tm_flags)
 }
 
 /**
- * zfcp_task_mgmt_function() - Synchronously send a task management function.
+ * zfcp_scsi_task_mgmt_function() - Send a task management function (sync).
  * @sdev: Pointer to SCSI device to send the task management command to.
  * @tm_flags: Task management flags,
  *	      here we only handle %FCP_TMF_TGT_RESET or %FCP_TMF_LUN_RESET.
  */
-static int zfcp_task_mgmt_function(struct scsi_device *sdev, u8 tm_flags)
+static int zfcp_scsi_task_mgmt_function(struct scsi_device *sdev, u8 tm_flags)
 {
 	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);
 	struct zfcp_adapter *adapter = zfcp_sdev->port->adapter;
@@ -322,7 +322,7 @@ static int zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)
 {
 	struct scsi_device *sdev = scpnt->device;
 
-	return zfcp_task_mgmt_function(sdev, FCP_TMF_LUN_RESET);
+	return zfcp_scsi_task_mgmt_function(sdev, FCP_TMF_LUN_RESET);
 }
 
 static int zfcp_scsi_eh_target_reset_handler(struct scsi_cmnd *scpnt)
@@ -347,7 +347,7 @@ static int zfcp_scsi_eh_target_reset_handler(struct scsi_cmnd *scpnt)
 		return ret;
 	}
 
-	ret = zfcp_task_mgmt_function(sdev, FCP_TMF_TGT_RESET);
+	ret = zfcp_scsi_task_mgmt_function(sdev, FCP_TMF_TGT_RESET);
 
 	/* release reference from above shost_for_each_device */
 	if (sdev)
@@ -468,7 +468,7 @@ void zfcp_scsi_adapter_unregister(struct zfcp_adapter *adapter)
 }
 
 static struct fc_host_statistics*
-zfcp_init_fc_host_stats(struct zfcp_adapter *adapter)
+zfcp_scsi_init_fc_host_stats(struct zfcp_adapter *adapter)
 {
 	struct fc_host_statistics *fc_stats;
 
@@ -482,9 +482,9 @@ zfcp_init_fc_host_stats(struct zfcp_adapter *adapter)
 	return adapter->fc_stats;
 }
 
-static void zfcp_adjust_fc_host_stats(struct fc_host_statistics *fc_stats,
-				      struct fsf_qtcb_bottom_port *data,
-				      struct fsf_qtcb_bottom_port *old)
+static void zfcp_scsi_adjust_fc_host_stats(struct fc_host_statistics *fc_stats,
+					   struct fsf_qtcb_bottom_port *data,
+					   struct fsf_qtcb_bottom_port *old)
 {
 	fc_stats->seconds_since_last_reset =
 		data->seconds_since_last_reset - old->seconds_since_last_reset;
@@ -515,8 +515,8 @@ static void zfcp_adjust_fc_host_stats(struct fc_host_statistics *fc_stats,
 	fc_stats->fcp_output_megabytes = data->output_mb - old->output_mb;
 }
 
-static void zfcp_set_fc_host_stats(struct fc_host_statistics *fc_stats,
-				   struct fsf_qtcb_bottom_port *data)
+static void zfcp_scsi_set_fc_host_stats(struct fc_host_statistics *fc_stats,
+					struct fsf_qtcb_bottom_port *data)
 {
 	fc_stats->seconds_since_last_reset = data->seconds_since_last_reset;
 	fc_stats->tx_frames = data->tx_frames;
@@ -540,7 +540,8 @@ static void zfcp_set_fc_host_stats(struct fc_host_statistics *fc_stats,
 	fc_stats->fcp_output_megabytes = data->output_mb;
 }
 
-static struct fc_host_statistics *zfcp_get_fc_host_stats(struct Scsi_Host *host)
+static struct fc_host_statistics *
+zfcp_scsi_get_fc_host_stats(struct Scsi_Host *host)
 {
 	struct zfcp_adapter *adapter;
 	struct fc_host_statistics *fc_stats;
@@ -548,7 +549,7 @@ static struct fc_host_statistics *zfcp_get_fc_host_stats(struct Scsi_Host *host)
 	int ret;
 
 	adapter = (struct zfcp_adapter *)host->hostdata[0];
-	fc_stats = zfcp_init_fc_host_stats(adapter);
+	fc_stats = zfcp_scsi_init_fc_host_stats(adapter);
 	if (!fc_stats)
 		return NULL;
 
@@ -565,16 +566,16 @@ static struct fc_host_statistics *zfcp_get_fc_host_stats(struct Scsi_Host *host)
 	if (adapter->stats_reset &&
 	    ((jiffies/HZ - adapter->stats_reset) <
 	     data->seconds_since_last_reset))
-		zfcp_adjust_fc_host_stats(fc_stats, data,
-					  adapter->stats_reset_data);
+		zfcp_scsi_adjust_fc_host_stats(fc_stats, data,
+					       adapter->stats_reset_data);
 	else
-		zfcp_set_fc_host_stats(fc_stats, data);
+		zfcp_scsi_set_fc_host_stats(fc_stats, data);
 
 	kfree(data);
 	return fc_stats;
 }
 
-static void zfcp_reset_fc_host_stats(struct Scsi_Host *shost)
+static void zfcp_scsi_reset_fc_host_stats(struct Scsi_Host *shost)
 {
 	struct zfcp_adapter *adapter;
 	struct fsf_qtcb_bottom_port *data;
@@ -596,7 +597,7 @@ static void zfcp_reset_fc_host_stats(struct Scsi_Host *shost)
 	}
 }
 
-static void zfcp_get_host_port_state(struct Scsi_Host *shost)
+static void zfcp_scsi_get_host_port_state(struct Scsi_Host *shost)
 {
 	struct zfcp_adapter *adapter =
 		(struct zfcp_adapter *)shost->hostdata[0];
@@ -613,7 +614,8 @@ static void zfcp_get_host_port_state(struct Scsi_Host *shost)
 		fc_host_port_state(shost) = FC_PORTSTATE_UNKNOWN;
 }
 
-static void zfcp_set_rport_dev_loss_tmo(struct fc_rport *rport, u32 timeout)
+static void zfcp_scsi_set_rport_dev_loss_tmo(struct fc_rport *rport,
+					     u32 timeout)
 {
 	rport->dev_loss_tmo = timeout;
 }
@@ -807,10 +809,10 @@ struct fc_function_template zfcp_transport_functions = {
 	.show_host_supported_speeds = 1,
 	.show_host_maxframe_size = 1,
 	.show_host_serial_number = 1,
-	.get_fc_host_stats = zfcp_get_fc_host_stats,
-	.reset_fc_host_stats = zfcp_reset_fc_host_stats,
-	.set_rport_dev_loss_tmo = zfcp_set_rport_dev_loss_tmo,
-	.get_host_port_state = zfcp_get_host_port_state,
+	.get_fc_host_stats = zfcp_scsi_get_fc_host_stats,
+	.reset_fc_host_stats = zfcp_scsi_reset_fc_host_stats,
+	.set_rport_dev_loss_tmo = zfcp_scsi_set_rport_dev_loss_tmo,
+	.get_host_port_state = zfcp_scsi_get_host_port_state,
 	.terminate_rport_io = zfcp_scsi_terminate_rport_io,
 	.show_host_port_state = 1,
 	.show_host_active_fc4s = 1,

commit 5c750d58e9d78987e2bda6b65441e6f6b961a01e
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Thu May 17 19:14:57 2018 +0200

    scsi: zfcp: workqueue: set description for port work items with their WWPN as context
    
    As a prerequisite, complement commit 3d1cb2059d93 ("workqueue: include
    workqueue info when printing debug dump of a worker task") to be usable with
    kernel modules by exporting the symbol set_worker_desc().  Current built-in
    user was introduced with commit ef3b101925f2 ("writeback: set worker desc to
    identify writeback workers in task dumps").
    
    Can help distinguishing work items which do not have adapter scope.
    Description is printed out with task dump for debugging on WARN, BUG, panic,
    or magic-sysrq [show-task-states(t)].
    
    Example:
    $ echo 0 >| /sys/bus/ccw/drivers/zfcp/0.0.1880/0x50050763031bd327/failed &
    $ echo 't' >| /proc/sysrq-trigger
    $ dmesg
    sysrq: SysRq : Show State
      task                        PC stack   pid father
    ...
    zfcp_q_0.0.1880 S14640  2165      2 0x02000000
    Call Trace:
    ([<00000000009df464>] __schedule+0xbf4/0xc78)
     [<00000000009df57c>] schedule+0x94/0xc0
     [<0000000000168654>] rescuer_thread+0x33c/0x3a0
     [<000000000016f8be>] kthread+0x166/0x178
     [<00000000009e71f2>] kernel_thread_starter+0x6/0xc
     [<00000000009e71ec>] kernel_thread_starter+0x0/0xc
    no locks held by zfcp_q_0.0.1880/2165.
    ...
    kworker/u512:2  D11280  2193      2 0x02000000
    Workqueue: zfcp_q_0.0.1880 zfcp_scsi_rport_work [zfcp] (zrpd-50050763031bd327)
                                                            ^^^^^^^^^^^^^^^^^^^^^
    Call Trace:
    ([<00000000009df464>] __schedule+0xbf4/0xc78)
     [<00000000009df57c>] schedule+0x94/0xc0
     [<00000000009e50c0>] schedule_timeout+0x488/0x4d0
     [<00000000001e425c>] msleep+0x5c/0x78                  >>test code only<<
     [<000003ff8008a21e>] zfcp_scsi_rport_work+0xbe/0x100 [zfcp]
     [<0000000000167154>] process_one_work+0x3b4/0x718
     [<000000000016771c>] worker_thread+0x264/0x408
     [<000000000016f8be>] kthread+0x166/0x178
     [<00000000009e71f2>] kernel_thread_starter+0x6/0xc
     [<00000000009e71ec>] kernel_thread_starter+0x0/0xc
    2 locks held by kworker/u512:2/2193:
     #0:  (name){++++.+}, at: [<0000000000166f4e>] process_one_work+0x1ae/0x718
     #1:  ((&(&port->rport_work)->work)){+.+.+.}, at: [<0000000000166f4e>] process_one_work+0x1ae/0x718
    ...
    
    =============================================
    Showing busy workqueues and worker pools:
    workqueue zfcp_q_0.0.1880: flags=0x2000a
      pwq 512: cpus=0-255 flags=0x4 nice=0 active=1/1
        in-flight: 2193:zfcp_scsi_rport_work [zfcp]
    pool 512: cpus=0-255 flags=0x4 nice=0 hung=0s workers=4 idle: 5 2354 2311
    
    Work items with adapter scope are already identified by the workqueue name
    "zfcp_q_<devbusid>" and the work item function name.
    
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Lai Jiangshan <jiangshanlai@gmail.com>
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Acked-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index fcc832b73960..0f7830ffd40a 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -730,6 +730,9 @@ void zfcp_scsi_rport_work(struct work_struct *work)
 	struct zfcp_port *port = container_of(work, struct zfcp_port,
 					      rport_work);
 
+	set_worker_desc("zrp%c-%16llx",
+			(port->rport_task == RPORT_ADD) ? 'a' : 'd',
+			port->wwpn); /* < WORKER_DESC_LEN=24 */
 	while (port->rport_task) {
 		if (port->rport_task == RPORT_ADD) {
 			port->rport_task = RPORT_NONE;

commit 674595d8519fdf4f78e1a4cceb2130ffa46bcdeb
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Thu May 17 19:14:56 2018 +0200

    scsi: zfcp: decouple our scsi_eh callbacks from scsi_cmnd
    
    Note: zfcp_scsi_eh_host_reset_handler() will be converted in a later patch.
    
    zfcp_scsi_eh_device_reset_handler() now only depends on scsi_device.
    zfcp_scsi_eh_target_reset_handler() now only depends on scsi_target.
    All derive other objects from these intended callback arguments.
    
    zfcp_scsi_eh_target_reset_handler() is special: The FCP channel requires a
    valid LUN handle so we try to find ourselves a stand-in scsi_device as
    suggested by Hannes Reinecke. If it cannot find a stand-in scsi device,
    trace a record like the following (formatted with zfcpdbf from s390-tools):
    
    Timestamp      : ...
    Area           : SCSI
    Subarea        : 00
    Level          : 1
    Exception      : -
    CPU ID         : ..
    Caller         : 0x...
    Record ID      : 1
    Tag            : tr_nosd        target reset, no SCSI device
    Request ID     : 0x0000000000000000                     none (invalid)
    SCSI ID        : 0x00000000     SCSI ID/target denoting scope
    SCSI LUN       : 0xffffffff                             none (invalid)
    SCSI LUN high  : 0xffffffff                             none (invalid)
    SCSI result    : 0x00002003     field re-used for midlayer value: FAILED
    SCSI retries   : 0xff                                   none (invalid)
    SCSI allowed   : 0xff                                   none (invalid)
    SCSI scribble  : 0xffffffffffffffff                     none (invalid)
    SCSI opcode    : ffffffff ffffffff ffffffff ffffffff    none (invalid)
    FCP rsp inf cod: 0xff                                   none (invalid)
    FCP rsp IU     : 00000000 00000000 00000000 00000000    none (invalid)
                     00000000 00000000
    
    Actually change the signature of zfcp_task_mgmt_function() used by
    zfcp_scsi_eh_device_reset_handler() & zfcp_scsi_eh_target_reset_handler().
    Since it was prepared in a previous patch, we only need to delete a local
    auto variable which is now the intended argument.
    
    Suggested-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index e0c5735cf3db..fcc832b73960 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -265,9 +265,14 @@ static void zfcp_scsi_forget_cmnds(struct zfcp_scsi_dev *zsdev, u8 tm_flags)
 	write_unlock_irqrestore(&adapter->abort_lock, flags);
 }
 
-static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
+/**
+ * zfcp_task_mgmt_function() - Synchronously send a task management function.
+ * @sdev: Pointer to SCSI device to send the task management command to.
+ * @tm_flags: Task management flags,
+ *	      here we only handle %FCP_TMF_TGT_RESET or %FCP_TMF_LUN_RESET.
+ */
+static int zfcp_task_mgmt_function(struct scsi_device *sdev, u8 tm_flags)
 {
-	struct scsi_device *sdev = scpnt->device;
 	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);
 	struct zfcp_adapter *adapter = zfcp_sdev->port->adapter;
 	struct fc_rport *rport = starget_to_rport(scsi_target(sdev));
@@ -315,12 +320,40 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 
 static int zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)
 {
-	return zfcp_task_mgmt_function(scpnt, FCP_TMF_LUN_RESET);
+	struct scsi_device *sdev = scpnt->device;
+
+	return zfcp_task_mgmt_function(sdev, FCP_TMF_LUN_RESET);
 }
 
 static int zfcp_scsi_eh_target_reset_handler(struct scsi_cmnd *scpnt)
 {
-	return zfcp_task_mgmt_function(scpnt, FCP_TMF_TGT_RESET);
+	struct scsi_target *starget = scsi_target(scpnt->device);
+	struct fc_rport *rport = starget_to_rport(starget);
+	struct Scsi_Host *shost = rport_to_shost(rport);
+	struct scsi_device *sdev = NULL, *tmp_sdev;
+	struct zfcp_adapter *adapter =
+		(struct zfcp_adapter *)shost->hostdata[0];
+	int ret;
+
+	shost_for_each_device(tmp_sdev, shost) {
+		if (tmp_sdev->id == starget->id) {
+			sdev = tmp_sdev;
+			break;
+		}
+	}
+	if (!sdev) {
+		ret = FAILED;
+		zfcp_dbf_scsi_eh("tr_nosd", adapter, starget->id, ret);
+		return ret;
+	}
+
+	ret = zfcp_task_mgmt_function(sdev, FCP_TMF_TGT_RESET);
+
+	/* release reference from above shost_for_each_device */
+	if (sdev)
+		scsi_device_put(tmp_sdev);
+
+	return ret;
 }
 
 static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)

commit 42afc6527d43fdb8c74a170de9735b07019b104c
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Thu May 17 19:14:55 2018 +0200

    scsi: zfcp: decouple TMFs from scsi_cmnd by using fc_block_rport
    
    Intentionally retrieve the rport by walking SCSI common code objects
    rather than zfcp_sdev->port->rport.
    
    The latter is used for pairing the calls to fc_remote_port_add() and
    fc_remote_port_delete(). [see v2.6.31 commit 379d6bf6573e ("[SCSI] zfcp:
    Add port only once to FC transport class")]
    
    zfcp_scsi_rport_register() sets zfcp_port.rport to what
    fc_remote_port_add() returned.
    zfcp_scsi_rport_block() sets zfcp_port.rport = NULL after having called
    fc_remote_port_delete().
    
    Hence, while an rport is blocked (or in any subsequent state due to
    scsi_transport_fc timeouts such as fast_io_fail_tmo or dev_loss_tmo),
    zfcp_port.rport is NULL and cannot serve as argument to fc_block_rport().
    
    During zfcp recovery, a just recovered zfcp_port can have the UNBLOCKED
    status flag, but an async rport unblocking has only started via
    zfcp_scsi_schedule_rport_register() in zfcp_erp_try_rport_unblock()
    [see v4.10 commit 6f2ce1c6af37 ("scsi: zfcp: fix rport unblock race with
    LUN recovery")] in zfcp_erp_action_cleanup(). Now zfcp_erp_wait() can
    return. This would be sufficient to successfully send a TMF.
    But the rport can still be blocked and zfcp_port.rport can still be NULL
    until zfcp_port.rport_work was scheduled and has actually called
    fc_remote_port_add() and assigned its return value to zfcp_port.rport.
    We need an unblocked rport for a successful scsi_eh TUR.
    
    Similarly, for a zfcp_port which has just lost its UNBLOCKED status flag,
    the return of zfcp_erp_wait() can race with zfcp_port.rport_work queued
    by zfcp_scsi_schedule_rport_block(). Therefore we cannot reliably access
    zfcp_port.rport. However, we'd like to get fc_rport_block()'s opinion on
    when fast_io_fail_tmo triggered. While we might use
    flush_work(&port->rport_work) to sync with the work item, we can simply use
    the other way to get an rport pointer.
    
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index e77e43a0630a..e0c5735cf3db 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -270,6 +270,7 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 	struct scsi_device *sdev = scpnt->device;
 	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);
 	struct zfcp_adapter *adapter = zfcp_sdev->port->adapter;
+	struct fc_rport *rport = starget_to_rport(scsi_target(sdev));
 	struct zfcp_fsf_req *fsf_req = NULL;
 	int retval = SUCCESS, ret;
 	int retry = 3;
@@ -281,7 +282,7 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 
 		zfcp_dbf_scsi_devreset("wait", sdev, tm_flags, NULL);
 		zfcp_erp_wait(adapter);
-		ret = fc_block_scsi_eh(scpnt);
+		ret = fc_block_rport(rport);
 		if (ret) {
 			zfcp_dbf_scsi_devreset("fiof", sdev, tm_flags, NULL);
 			return ret;

commit 26f5fa9d47c12661f282f8009c4a64e449dd36c5
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Thu May 17 19:14:54 2018 +0200

    scsi: zfcp: decouple SCSI setup of TMF from scsi_cmnd
    
    Actually change the signature of zfcp_fsf_fcp_task_mgmt().
    Since it was prepared in the previous patch, we only need to delete
    a local auto variable which is now the intended argument.
    
    Prepare zfcp_fsf_fcp_task_mgmt's caller zfcp_task_mgmt_function()
    to have its function body only depend on a scsi_device and derived objects.
    
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 0afc546b71df..e77e43a0630a 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -275,7 +275,7 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 	int retry = 3;
 
 	while (retry--) {
-		fsf_req = zfcp_fsf_fcp_task_mgmt(scpnt, tm_flags);
+		fsf_req = zfcp_fsf_fcp_task_mgmt(sdev, tm_flags);
 		if (fsf_req)
 			break;
 

commit 8221211863750b1afb1f464a264c05383b077a06
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Thu May 17 19:14:50 2018 +0200

    scsi: zfcp: decouple SCSI traces for scsi_eh / TMF from scsi_cmnd
    
    The SCSI command pointer passed to scsi_eh callbacks is just one arbitrary
    command of potentially many that are in the eh queue to be processed.  The
    command is only used to indirectly pass the TMF scope in terms of SCSI
    ID/target and SCSI LUN for LUN reset.
    
    Hence, zfcp had filled in SCSI trace record fields which do not really
    belong to the TMF. This was confusing.
    
    Therefore, refactor the TMF tracing to work without SCSI command.  Since the
    FCP channel always requires a valid LUN handle, we use SCSI device as common
    context for any TMF (even target reset).  To make it even clearer, we set
    all bits to 1 for the fields, which do not belong to the TMF, to indicate
    that these fields are invalid.
    
    The old zfcp_dbf_scsi() became zfcp_dbf_scsi_common() to now handle both
    SCSI commands and TMFs. The old argument scsi_cmnd is now optional and can
    be NULL with TMFs. The new argument scsi_device is mandatory to carry
    context, as well as SCSI ID/target and SCSI LUN in case of TMFs.
    
    New example trace record formatted with zfcpdbf from s390-tools:
    
    Timestamp      : ...
    Area           : SCSI
    Subarea        : 00
    Level          : 1
    Exception      : -
    CPU ID         : ..
    Caller         : 0x...
    Record ID      : 1
    Tag            : [lt]r_....
    Request ID     : 0x<reqid>              ID of FSF FCP request with TM flag
                     For cases without FSF request: 0x0 for none (invalid)
    SCSI ID        : 0x<scsi_id>            SCSI ID/target denoting scope
    SCSI LUN       : 0x<scsi_lun>           SCSI LUN denoting scope
    SCSI LUN high  : 0x<scsi_lun_high>      SCSI LUN denoting scope
    SCSI result    : 0xffffffff                             none (invalid)
    SCSI retries   : 0xff                                   none (invalid)
    SCSI allowed   : 0xff                                   none (invalid)
    SCSI scribble  : 0xffffffffffffffff                     none (invalid)
    SCSI opcode    : ffffffff ffffffff ffffffff ffffffff    none (invalid)
    FCP rsp inf cod: 0x00                   FCP_RSP info code of TMF
    FCP rsp IU     : 00000000 00000000 00000100 00000000 ext FCP_RSP IU
                     00000000 00000008                   ext FCP_RSP IU
    FCP rsp IU len : 32                                  FCP_RSP IU length
    Payload time   : ...
    FCP rsp IU all : 00000000 00000000 00000100 00000000 full FCP_RSP IU
                     00000000 00000008 00000000 00000000 full FCP_RSP IU
    
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 478e7ef9ea2f..0afc546b71df 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -267,7 +267,8 @@ static void zfcp_scsi_forget_cmnds(struct zfcp_scsi_dev *zsdev, u8 tm_flags)
 
 static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 {
-	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scpnt->device);
+	struct scsi_device *sdev = scpnt->device;
+	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);
 	struct zfcp_adapter *adapter = zfcp_sdev->port->adapter;
 	struct zfcp_fsf_req *fsf_req = NULL;
 	int retval = SUCCESS, ret;
@@ -278,32 +279,32 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 		if (fsf_req)
 			break;
 
-		zfcp_dbf_scsi_devreset("wait", scpnt, tm_flags, NULL);
+		zfcp_dbf_scsi_devreset("wait", sdev, tm_flags, NULL);
 		zfcp_erp_wait(adapter);
 		ret = fc_block_scsi_eh(scpnt);
 		if (ret) {
-			zfcp_dbf_scsi_devreset("fiof", scpnt, tm_flags, NULL);
+			zfcp_dbf_scsi_devreset("fiof", sdev, tm_flags, NULL);
 			return ret;
 		}
 
 		if (!(atomic_read(&adapter->status) &
 		      ZFCP_STATUS_COMMON_RUNNING)) {
-			zfcp_dbf_scsi_devreset("nres", scpnt, tm_flags, NULL);
+			zfcp_dbf_scsi_devreset("nres", sdev, tm_flags, NULL);
 			return SUCCESS;
 		}
 	}
 	if (!fsf_req) {
-		zfcp_dbf_scsi_devreset("reqf", scpnt, tm_flags, NULL);
+		zfcp_dbf_scsi_devreset("reqf", sdev, tm_flags, NULL);
 		return FAILED;
 	}
 
 	wait_for_completion(&fsf_req->completion);
 
 	if (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCFAILED) {
-		zfcp_dbf_scsi_devreset("fail", scpnt, tm_flags, fsf_req);
+		zfcp_dbf_scsi_devreset("fail", sdev, tm_flags, fsf_req);
 		retval = FAILED;
 	} else {
-		zfcp_dbf_scsi_devreset("okay", scpnt, tm_flags, fsf_req);
+		zfcp_dbf_scsi_devreset("okay", sdev, tm_flags, fsf_req);
 		zfcp_scsi_forget_cmnds(zfcp_sdev, tm_flags);
 	}
 

commit 96d9270499471545048ed8a6d7f425a49762283d
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Thu May 17 19:14:46 2018 +0200

    scsi: zfcp: fix missing REC trigger trace on terminate_rport_io early return
    
    get_device() and its internally used kobject_get() only return NULL if they
    get passed NULL as argument. zfcp_get_port_by_wwpn() loops over
    adapter->port_list so the iteration variable port is always non-NULL.
    Struct device is embedded in struct zfcp_port so &port->dev is always
    non-NULL. This is the argument to get_device().  However, if we get an
    fc_rport in terminate_rport_io() for which we cannot find a match within
    zfcp_get_port_by_wwpn(), the latter can return NULL.  v2.6.30 commit
    70932935b61e ("[SCSI] zfcp: Fix oops when port disappears") introduced an
    early return without adding a trace record for this case.  Even if we don't
    need recovery in this case, for debugging we should still see that our
    callback was invoked originally by scsi_transport_fc.
    
    Example trace record formatted with zfcpdbf from s390-tools:
    
    Timestamp      : ...
    Area           : REC
    Subarea        : 00
    Level          : 1
    Exception      : -
    CPU ID         : ..
    Caller         : 0x...
    Record ID      : 1
    Tag            : sctrpin        SCSI terminate rport I/O, no zfcp port
    LUN            : 0xffffffffffffffff                     none (invalid)
    WWPN           : 0x<wwpn>               WWPN
    D_ID           : 0x<n_port_id>          N_Port-ID
    Adapter status : 0x...
    Port status    : 0xffffffff             unknown (-1)
    LUN status     : 0x00000000                             none (invalid)
    Ready count    : 0x...
    Running count  : 0x...
    ERP want       : 0x03                   ZFCP_ERP_ACTION_REOPEN_PORT_FORCED
    ERP need       : 0xc0                   ZFCP_ERP_ACTION_NONE
    
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Fixes: 70932935b61e ("[SCSI] zfcp: Fix oops when port disappears")
    Cc: <stable@vger.kernel.org> #2.6.38+
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 4fdb1665b0e6..478e7ef9ea2f 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -605,6 +605,11 @@ static void zfcp_scsi_terminate_rport_io(struct fc_rport *rport)
 	if (port) {
 		zfcp_erp_port_forced_reopen(port, 0, "sctrpi1");
 		put_device(&port->dev);
+	} else {
+		zfcp_erp_port_forced_no_port_dbf(
+			"sctrpin", adapter,
+			rport->port_name /* zfcp_scsi_rport_register */,
+			rport->port_id /* zfcp_scsi_rport_register */);
 	}
 }
 

commit 81979ae63e872ef650a7197f6ce6590059d37172
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Thu May 17 19:14:44 2018 +0200

    scsi: zfcp: fix missing SCSI trace for retry of abort / scsi_eh TMF
    
    We already have a SCSI trace for the end of abort and scsi_eh TMF. Due to
    zfcp_erp_wait() and fc_block_scsi_eh() time can pass between the start of
    our eh callback and an actual send/recv of an abort / TMF request.  In order
    to see the temporal sequence including any abort / TMF send retries, add a
    trace before the above two blocking functions.  This supports problem
    determination with scsi_eh and parallel zfcp ERP.
    
    No need to explicitly trace the beginning of our eh callback, since we
    typically can send an abort / TMF and see its HBA response (in the worst
    case, it's a pseudo response on dismiss all of adapter recovery, e.g. due to
    an FSF request timeout [fsrth_1] of the abort / TMF). If we cannot send, we
    now get a trace record for the first "abrt_wt" or "[lt]r_wait" which denotes
    almost the beginning of the callback.
    
    No need to explicitly trace the wakeup after the above two blocking
    functions because the next retry loop causes another trace in any case and
    that is sufficient.
    
    Example trace records formatted with zfcpdbf from s390-tools:
    
    Timestamp      : ...
    Area           : SCSI
    Subarea        : 00
    Level          : 1
    Exception      : -
    CPU ID         : ..
    Caller         : 0x...
    Record ID      : 1
    Tag            : abrt_wt        abort, before zfcp_erp_wait()
    Request ID     : 0x0000000000000000                     none (invalid)
    SCSI ID        : 0x<scsi_id>
    SCSI LUN       : 0x<scsi_lun>
    SCSI LUN high  : 0x<scsi_lun_high>
    SCSI result    : 0x<scsi_result_of_cmd_to_be_aborted>
    SCSI retries   : 0x<retries_of_cmd_to_be_aborted>
    SCSI allowed   : 0x<allowed_retries_of_cmd_to_be_aborted>
    SCSI scribble  : 0x<req_id_of_cmd_to_be_aborted>
    SCSI opcode    : <CDB_of_cmd_to_be_aborted>
    FCP rsp inf cod: 0x..                                   none (invalid)
    FCP rsp IU     : ...                                    none (invalid)
    
    Timestamp      : ...
    Area           : SCSI
    Subarea        : 00
    Level          : 1
    Exception      : -
    CPU ID         : ..
    Caller         : 0x...
    Record ID      : 1
    Tag            : lr_wait        LUN reset, before zfcp_erp_wait()
    Request ID     : 0x0000000000000000                     none (invalid)
    SCSI ID        : 0x<scsi_id>
    SCSI LUN       : 0x<scsi_lun>
    SCSI LUN high  : 0x<scsi_lun_high>
    SCSI result    : 0x...                                  unrelated
    SCSI retries   : 0x..                                   unrelated
    SCSI allowed   : 0x..                                   unrelated
    SCSI scribble  : 0x...                                  unrelated
    SCSI opcode    : ...                                    unrelated
    FCP rsp inf cod: 0x..                                   none (invalid)
    FCP rsp IU     : ...                                    none (invalid)
    
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Fixes: 63caf367e1c9 ("[SCSI] zfcp: Improve reliability of SCSI eh handlers in zfcp")
    Fixes: af4de36d911a ("[SCSI] zfcp: Block scsi_eh thread for rport state BLOCKED")
    Cc: <stable@vger.kernel.org> #2.6.38+
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index a62357f5e8b4..4fdb1665b0e6 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -181,6 +181,7 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 		if (abrt_req)
 			break;
 
+		zfcp_dbf_scsi_abort("abrt_wt", scpnt, NULL);
 		zfcp_erp_wait(adapter);
 		ret = fc_block_scsi_eh(scpnt);
 		if (ret) {
@@ -277,6 +278,7 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 		if (fsf_req)
 			break;
 
+		zfcp_dbf_scsi_devreset("wait", scpnt, tm_flags, NULL);
 		zfcp_erp_wait(adapter);
 		ret = fc_block_scsi_eh(scpnt);
 		if (ret) {

commit df30781699f53e4fd4c494c6f7dd16e3d5c21d30
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Thu May 17 19:14:43 2018 +0200

    scsi: zfcp: fix missing SCSI trace for result of eh_host_reset_handler
    
    For problem determination we need to see whether and why we were successful
    or not. This allows deduction of scsi_eh escalation.
    
    Example trace record formatted with zfcpdbf from s390-tools:
    
    Timestamp      : ...
    Area           : SCSI
    Subarea        : 00
    Level          : 1
    Exception      : -
    CPU ID         : ..
    Caller         : 0x...
    Record ID      : 1
    Tag            : schrh_r        SCSI host reset handler result
    Request ID     : 0x0000000000000000                     none (invalid)
    SCSI ID        : 0xffffffff                             none (invalid)
    SCSI LUN       : 0xffffffff                             none (invalid)
    SCSI LUN high  : 0xffffffff                             none (invalid)
    SCSI result    : 0x00002002     field re-used for midlayer value: SUCCESS
                                    or in other cases: 0x2009 == FAST_IO_FAIL
    SCSI retries   : 0xff                                   none (invalid)
    SCSI allowed   : 0xff                                   none (invalid)
    SCSI scribble  : 0xffffffffffffffff                     none (invalid)
    SCSI opcode    : ffffffff ffffffff ffffffff ffffffff    none (invalid)
    FCP rsp inf cod: 0xff                                   none (invalid)
    FCP rsp IU     : 00000000 00000000 00000000 00000000    none (invalid)
                     00000000 00000000
    
    v2.6.35 commit a1dbfddd02d2 ("[SCSI] zfcp: Pass return code from
    fc_block_scsi_eh to scsi eh") introduced the first return with something
    other than the previously hardcoded single SUCCESS return path.
    
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Fixes: a1dbfddd02d2 ("[SCSI] zfcp: Pass return code from fc_block_scsi_eh to scsi eh")
    Cc: <stable@vger.kernel.org> #2.6.38+
    Reviewed-by: Jens Remus <jremus@linux.ibm.com>
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 4d2ba5682493..a62357f5e8b4 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -323,15 +323,16 @@ static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 {
 	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scpnt->device);
 	struct zfcp_adapter *adapter = zfcp_sdev->port->adapter;
-	int ret;
+	int ret = SUCCESS, fc_ret;
 
 	zfcp_erp_adapter_reopen(adapter, 0, "schrh_1");
 	zfcp_erp_wait(adapter);
-	ret = fc_block_scsi_eh(scpnt);
-	if (ret)
-		return ret;
+	fc_ret = fc_block_scsi_eh(scpnt);
+	if (fc_ret)
+		ret = fc_ret;
 
-	return SUCCESS;
+	zfcp_dbf_scsi_eh("schrh_r", adapter, ~0, ret);
+	return ret;
 }
 
 struct scsi_transport_template *zfcp_scsi_transport_template;

commit fa89adba1941e4f3b213399b81732a5c12fd9131
Author: Jens Remus <jremus@linux.ibm.com>
Date:   Thu May 3 13:52:47 2018 +0200

    scsi: zfcp: fix infinite iteration on ERP ready list
    
    zfcp_erp_adapter_reopen() schedules blocking of all of the adapter's
    rports via zfcp_scsi_schedule_rports_block() and enqueues a reopen
    adapter ERP action via zfcp_erp_action_enqueue(). Both are separately
    processed asynchronously and concurrently.
    
    Blocking of rports is done in a kworker by zfcp_scsi_rport_work(). It
    calls zfcp_scsi_rport_block(), which then traces a DBF REC "scpdely" via
    zfcp_dbf_rec_trig().  zfcp_dbf_rec_trig() acquires the DBF REC spin lock
    and then iterates with list_for_each() over the adapter's ERP ready list
    without holding the ERP lock. This opens a race window in which the
    current list entry can be moved to another list, causing list_for_each()
    to iterate forever on the wrong list, as the erp_ready_head is never
    encountered as terminal condition.
    
    Meanwhile the ERP action can be processed in the ERP thread by
    zfcp_erp_thread(). It calls zfcp_erp_strategy(), which acquires the ERP
    lock and then calls zfcp_erp_action_to_running() to move the ERP action
    from the ready to the running list.  zfcp_erp_action_to_running() can
    move the ERP action using list_move() just during the aforementioned
    race window. It then traces a REC RUN "erator1" via zfcp_dbf_rec_run().
    zfcp_dbf_rec_run() tries to acquire the DBF REC spin lock. If this is
    held by the infinitely looping kworker, it effectively spins forever.
    
    Example Sequence Diagram:
    
    Process                ERP Thread             rport_work
    -------------------    -------------------    -------------------
    zfcp_erp_adapter_reopen()
    zfcp_erp_adapter_block()
    zfcp_scsi_schedule_rports_block()
    lock ERP                                      zfcp_scsi_rport_work()
    zfcp_erp_action_enqueue(ZFCP_ERP_ACTION_REOPEN_ADAPTER)
    list_add_tail() on ready                      !(rport_task==RPORT_ADD)
    wake_up() ERP thread                          zfcp_scsi_rport_block()
    zfcp_dbf_rec_trig()    zfcp_erp_strategy()    zfcp_dbf_rec_trig()
    unlock ERP                                    lock DBF REC
    zfcp_erp_wait()        lock ERP
    |                      zfcp_erp_action_to_running()
    |                                             list_for_each() ready
    |                      list_move()              current entry
    |                        ready to running
    |                      zfcp_dbf_rec_run()       endless loop over running
    |                      zfcp_dbf_rec_run_lvl()
    |                      lock DBF REC spins forever
    
    Any adapter recovery can trigger this, such as setting the device offline
    or reboot.
    
    V4.9 commit 4eeaa4f3f1d6 ("zfcp: close window with unblocked rport
    during rport gone") introduced additional tracing of (un)blocking of
    rports. It missed that the adapter->erp_lock must be held when calling
    zfcp_dbf_rec_trig().
    
    This fix uses the approach formerly introduced by commit aa0fec62391c
    ("[SCSI] zfcp: Fix sparse warning by providing new entry in dbf") that got
    later removed by commit ae0904f60fab ("[SCSI] zfcp: Redesign of the debug
    tracing for recovery actions.").
    
    Introduce zfcp_dbf_rec_trig_lock(), a wrapper for zfcp_dbf_rec_trig() that
    acquires and releases the adapter->erp_lock for read.
    
    Reported-by: Sebastian Ott <sebott@linux.ibm.com>
    Signed-off-by: Jens Remus <jremus@linux.ibm.com>
    Fixes: 4eeaa4f3f1d6 ("zfcp: close window with unblocked rport during rport gone")
    Cc: <stable@vger.kernel.org> # 2.6.32+
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 4d2ba5682493..22f9562f415c 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -4,7 +4,7 @@
  *
  * Interface to Linux SCSI midlayer.
  *
- * Copyright IBM Corp. 2002, 2017
+ * Copyright IBM Corp. 2002, 2018
  */
 
 #define KMSG_COMPONENT "zfcp"
@@ -618,9 +618,9 @@ static void zfcp_scsi_rport_register(struct zfcp_port *port)
 	ids.port_id = port->d_id;
 	ids.roles = FC_RPORT_ROLE_FCP_TARGET;
 
-	zfcp_dbf_rec_trig("scpaddy", port->adapter, port, NULL,
-			  ZFCP_PSEUDO_ERP_ACTION_RPORT_ADD,
-			  ZFCP_PSEUDO_ERP_ACTION_RPORT_ADD);
+	zfcp_dbf_rec_trig_lock("scpaddy", port->adapter, port, NULL,
+			       ZFCP_PSEUDO_ERP_ACTION_RPORT_ADD,
+			       ZFCP_PSEUDO_ERP_ACTION_RPORT_ADD);
 	rport = fc_remote_port_add(port->adapter->scsi_host, 0, &ids);
 	if (!rport) {
 		dev_err(&port->adapter->ccw_device->dev,
@@ -642,9 +642,9 @@ static void zfcp_scsi_rport_block(struct zfcp_port *port)
 	struct fc_rport *rport = port->rport;
 
 	if (rport) {
-		zfcp_dbf_rec_trig("scpdely", port->adapter, port, NULL,
-				  ZFCP_PSEUDO_ERP_ACTION_RPORT_DEL,
-				  ZFCP_PSEUDO_ERP_ACTION_RPORT_DEL);
+		zfcp_dbf_rec_trig_lock("scpdely", port->adapter, port, NULL,
+				       ZFCP_PSEUDO_ERP_ACTION_RPORT_DEL,
+				       ZFCP_PSEUDO_ERP_ACTION_RPORT_DEL);
 		fc_remote_port_delete(rport);
 		port->rport = NULL;
 	}

commit ead751507de86d90fa250431e9990a8b881f713c
Merge: fdebad11e50e e2be04c7f995
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 2 10:04:46 2017 -0700

    Merge tag 'spdx_identifiers-4.14-rc8' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull initial SPDX identifiers from Greg KH:
     "License cleanup: add SPDX license identifiers to some files
    
      Many source files in the tree are missing licensing information, which
      makes it harder for compliance tools to determine the correct license.
    
      By default all files without license information are under the default
      license of the kernel, which is GPL version 2.
    
      Update the files which contain no license information with the
      'GPL-2.0' SPDX license identifier. The SPDX identifier is a legally
      binding shorthand, which can be used instead of the full boiler plate
      text.
    
      This patch is based on work done by Thomas Gleixner and Kate Stewart
      and Philippe Ombredanne.
    
      How this work was done:
    
      Patches were generated and checked against linux-4.14-rc6 for a subset
      of the use cases:
    
       - file had no licensing information it it.
    
       - file was a */uapi/* one with no licensing information in it,
    
       - file was a */uapi/* one with existing licensing information,
    
      Further patches will be generated in subsequent months to fix up cases
      where non-standard license headers were used, and references to
      license had to be inferred by heuristics based on keywords.
    
      The analysis to determine which SPDX License Identifier to be applied
      to a file was done in a spreadsheet of side by side results from of
      the output of two independent scanners (ScanCode & Windriver)
      producing SPDX tag:value files created by Philippe Ombredanne.
      Philippe prepared the base worksheet, and did an initial spot review
      of a few 1000 files.
    
      The 4.13 kernel was the starting point of the analysis with 60,537
      files assessed. Kate Stewart did a file by file comparison of the
      scanner results in the spreadsheet to determine which SPDX license
      identifier(s) to be applied to the file. She confirmed any
      determination that was not immediately clear with lawyers working with
      the Linux Foundation.
    
      Criteria used to select files for SPDX license identifier tagging was:
    
       - Files considered eligible had to be source code files.
    
       - Make and config files were included as candidates if they contained
         >5 lines of source
    
       - File already had some variant of a license header in it (even if <5
         lines).
    
      All documentation files were explicitly excluded.
    
      The following heuristics were used to determine which SPDX license
      identifiers to apply.
    
       - when both scanners couldn't find any license traces, file was
         considered to have no license information in it, and the top level
         COPYING file license applied.
    
         For non */uapi/* files that summary was:
    
           SPDX license identifier                            # files
           ---------------------------------------------------|-------
           GPL-2.0                                              11139
    
         and resulted in the first patch in this series.
    
         If that file was a */uapi/* path one, it was "GPL-2.0 WITH
         Linux-syscall-note" otherwise it was "GPL-2.0". Results of that
         was:
    
           SPDX license identifier                            # files
           ---------------------------------------------------|-------
           GPL-2.0 WITH Linux-syscall-note                        930
    
         and resulted in the second patch in this series.
    
       - if a file had some form of licensing information in it, and was one
         of the */uapi/* ones, it was denoted with the Linux-syscall-note if
         any GPL family license was found in the file or had no licensing in
         it (per prior point). Results summary:
    
           SPDX license identifier                            # files
           ---------------------------------------------------|------
           GPL-2.0 WITH Linux-syscall-note                       270
           GPL-2.0+ WITH Linux-syscall-note                      169
           ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
           ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
           LGPL-2.1+ WITH Linux-syscall-note                      15
           GPL-1.0+ WITH Linux-syscall-note                       14
           ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
           LGPL-2.0+ WITH Linux-syscall-note                       4
           LGPL-2.1 WITH Linux-syscall-note                        3
           ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
           ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
         and that resulted in the third patch in this series.
    
       - when the two scanners agreed on the detected license(s), that
         became the concluded license(s).
    
       - when there was disagreement between the two scanners (one detected
         a license but the other didn't, or they both detected different
         licenses) a manual inspection of the file occurred.
    
       - In most cases a manual inspection of the information in the file
         resulted in a clear resolution of the license that should apply
         (and which scanner probably needed to revisit its heuristics).
    
       - When it was not immediately clear, the license identifier was
         confirmed with lawyers working with the Linux Foundation.
    
       - If there was any question as to the appropriate license identifier,
         the file was flagged for further research and to be revisited later
         in time.
    
      In total, over 70 hours of logged manual review was done on the
      spreadsheet to determine the SPDX license identifiers to apply to the
      source files by Kate, Philippe, Thomas and, in some cases,
      confirmation by lawyers working with the Linux Foundation.
    
      Kate also obtained a third independent scan of the 4.13 code base from
      FOSSology, and compared selected files where the other two scanners
      disagreed against that SPDX file, to see if there was new insights.
      The Windriver scanner is based on an older version of FOSSology in
      part, so they are related.
    
      Thomas did random spot checks in about 500 files from the spreadsheets
      for the uapi headers and agreed with SPDX license identifier in the
      files he inspected. For the non-uapi files Thomas did random spot
      checks in about 15000 files.
    
      In initial set of patches against 4.14-rc6, 3 files were found to have
      copy/paste license identifier errors, and have been fixed to reflect
      the correct identifier.
    
      Additionally Philippe spent 10 hours this week doing a detailed manual
      inspection and review of the 12,461 patched files from the initial
      patch version early this week with:
    
       - a full scancode scan run, collecting the matched texts, detected
         license ids and scores
    
       - reviewing anything where there was a license detected (about 500+
         files) to ensure that the applied SPDX license was correct
    
       - reviewing anything where there was no detection but the patch
         license was not GPL-2.0 WITH Linux-syscall-note to ensure that the
         applied SPDX license was correct
    
      This produced a worksheet with 20 files needing minor correction. This
      worksheet was then exported into 3 different .csv files for the
      different types of files to be modified.
    
      These .csv files were then reviewed by Greg. Thomas wrote a script to
      parse the csv files and add the proper SPDX tag to the file, in the
      format that the file expected. This script was further refined by Greg
      based on the output to detect more types of files automatically and to
      distinguish between header and source .c files (which need different
      comment types.) Finally Greg ran the script using the .csv files to
      generate the patches.
    
      Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
      Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
      Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
      Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>"
    
    * tag 'spdx_identifiers-4.14-rc8' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core:
      License cleanup: add SPDX license identifier to uapi header files with a license
      License cleanup: add SPDX license identifier to uapi header files with no license
      License cleanup: add SPDX GPL-2.0 license identifier to files with no license

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index ec3ddd1d31d5..ebea205f9de8 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * zfcp device driver
  *

commit ab31fd0ce65ec93828b617123792c1bb7c6dcc42
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Oct 13 15:40:07 2017 +0200

    scsi: zfcp: fix erp_action use-before-initialize in REC action trace
    
    v4.10 commit 6f2ce1c6af37 ("scsi: zfcp: fix rport unblock race with LUN
    recovery") extended accessing parent pointer fields of struct
    zfcp_erp_action for tracing.  If an erp_action has never been enqueued
    before, these parent pointer fields are uninitialized and NULL. Examples
    are zfcp objects freshly added to the parent object's children list,
    before enqueueing their first recovery subsequently. In
    zfcp_erp_try_rport_unblock(), we iterate such list. Accessing erp_action
    fields can cause a NULL pointer dereference.  Since the kernel can read
    from lowcore on s390, it does not immediately cause a kernel page
    fault. Instead it can cause hangs on trying to acquire the wrong
    erp_action->adapter->dbf->rec_lock in zfcp_dbf_rec_action_lvl()
                          ^bogus^
    while holding already other locks with IRQs disabled.
    
    Real life example from attaching lots of LUNs in parallel on many CPUs:
    
    crash> bt 17723
    PID: 17723  TASK: ...               CPU: 25  COMMAND: "zfcperp0.0.1800"
     LOWCORE INFO:
      -psw      : 0x0404300180000000 0x000000000038e424
      -function : _raw_spin_lock_wait_flags at 38e424
    ...
     #0 [fdde8fc90] zfcp_dbf_rec_action_lvl at 3e0004e9862 [zfcp]
     #1 [fdde8fce8] zfcp_erp_try_rport_unblock at 3e0004dfddc [zfcp]
     #2 [fdde8fd38] zfcp_erp_strategy at 3e0004e0234 [zfcp]
     #3 [fdde8fda8] zfcp_erp_thread at 3e0004e0a12 [zfcp]
     #4 [fdde8fe60] kthread at 173550
     #5 [fdde8feb8] kernel_thread_starter at 10add2
    
    zfcp_adapter
     zfcp_port
      zfcp_unit <address>, 0x404040d600000000
      scsi_device NULL, returning early!
    zfcp_scsi_dev.status = 0x40000000
    0x40000000 ZFCP_STATUS_COMMON_RUNNING
    
    crash> zfcp_unit <address>
    struct zfcp_unit {
      erp_action = {
        adapter = 0x0,
        port = 0x0,
        unit = 0x0,
      },
    }
    
    zfcp_erp_action is always fully embedded into its container object. Such
    container object is never moved in its object tree (only add or delete).
    Hence, erp_action parent pointers can never change.
    
    To fix the issue, initialize the erp_action parent pointers before
    adding the erp_action container to any list and thus before it becomes
    accessible from outside of its initializing function.
    
    In order to also close the time window between zfcp_erp_setup_act()
    memsetting the entire erp_action to zero and setting the parent pointers
    again, drop the memset and instead explicitly initialize individually
    all erp_action fields except for parent pointers. To be extra careful
    not to introduce any other unintended side effect, even keep zeroing the
    erp_action fields for list and timer. Also double-check with
    WARN_ON_ONCE that erp_action parent pointers never change, so we get to
    know when we would deviate from previous behavior.
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: 6f2ce1c6af37 ("scsi: zfcp: fix rport unblock race with LUN recovery")
    Cc: <stable@vger.kernel.org> #2.6.32+
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index ec3ddd1d31d5..6cf8732627e0 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -115,10 +115,15 @@ static int zfcp_scsi_slave_alloc(struct scsi_device *sdev)
 	struct zfcp_unit *unit;
 	int npiv = adapter->connection_features & FSF_FEATURE_NPIV_MODE;
 
+	zfcp_sdev->erp_action.adapter = adapter;
+	zfcp_sdev->erp_action.sdev = sdev;
+
 	port = zfcp_get_port_by_wwpn(adapter, rport->port_name);
 	if (!port)
 		return -ENXIO;
 
+	zfcp_sdev->erp_action.port = port;
+
 	unit = zfcp_unit_find(port, zfcp_scsi_dev_lun(sdev));
 	if (unit)
 		put_device(&unit->dev);

commit 1a5d999ebfc7bfe28deb48931bb57faa8e4102b6
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Jul 28 12:30:55 2017 +0200

    scsi: zfcp: fix missing trace records for early returns in TMF eh handlers
    
    For problem determination we need to see that we were in scsi_eh
    as well as whether and why we were successful or not.
    
    The following commits introduced new early returns without adding
    a trace record:
    
    v2.6.35 commit a1dbfddd02d2
    ("[SCSI] zfcp: Pass return code from fc_block_scsi_eh to scsi eh")
    on fc_block_scsi_eh() returning != 0 which is FAST_IO_FAIL,
    
    v2.6.30 commit 63caf367e1c9
    ("[SCSI] zfcp: Improve reliability of SCSI eh handlers in zfcp")
    on not having gotten an FSF request after the maximum number of retry
    attempts and thus could not issue a TMF and has to return FAILED.
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: a1dbfddd02d2 ("[SCSI] zfcp: Pass return code from fc_block_scsi_eh to scsi eh")
    Fixes: 63caf367e1c9 ("[SCSI] zfcp: Improve reliability of SCSI eh handlers in zfcp")
    Cc: <stable@vger.kernel.org> #2.6.38+
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 4c9ac55d053d..ec3ddd1d31d5 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -273,8 +273,10 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 
 		zfcp_erp_wait(adapter);
 		ret = fc_block_scsi_eh(scpnt);
-		if (ret)
+		if (ret) {
+			zfcp_dbf_scsi_devreset("fiof", scpnt, tm_flags, NULL);
 			return ret;
+		}
 
 		if (!(atomic_read(&adapter->status) &
 		      ZFCP_STATUS_COMMON_RUNNING)) {
@@ -282,8 +284,10 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 			return SUCCESS;
 		}
 	}
-	if (!fsf_req)
+	if (!fsf_req) {
+		zfcp_dbf_scsi_devreset("reqf", scpnt, tm_flags, NULL);
 		return FAILED;
+	}
 
 	wait_for_completion(&fsf_req->completion);
 

commit 9fe5d2b2fd30aa8c7827ec62cbbe6d30df4fe3e3
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Jul 28 12:30:54 2017 +0200

    scsi: zfcp: fix passing fsf_req to SCSI trace on TMF to correlate with HBA
    
    Without this fix we get SCSI trace records on task management functions
    which cannot be correlated to HBA trace records because all fields
    related to the FSF request are empty (zero).
    Also, the FCP_RSP_IU is missing as well as any sense data if available.
    
    This was caused by v2.6.14 commit 8a36e4532ea1 ("[SCSI] zfcp: enhancement
    of zfcp debug features") introducing trace records for TMFs but
    hard coding NULL for a possibly existing TMF FSF request.
    The scsi_cmnd scribble is also zero or unrelated for the TMF request
    so it also could not lookup a suitable FSF request from there.
    
    A broken example trace record formatted with zfcpdbf from the s390-tools
    package:
    
    Timestamp      : ...
    Area           : SCSI
    Subarea        : 00
    Level          : 1
    Exception      : -
    CPU ID         : ..
    Caller         : 0x...
    Record ID      : 1
    Tag            : lr_fail
    Request ID     : 0x0000000000000000
                       ^^^^^^^^^^^^^^^^ no correlation to HBA record
    SCSI ID        : 0x<scsitarget>
    SCSI LUN       : 0x<scsilun>
    SCSI result    : 0x000e0000
    SCSI retries   : 0x00
    SCSI allowed   : 0x05
    SCSI scribble  : 0x0000000000000000
    SCSI opcode    : 2a000017 3bb80000 08000000 00000000
    FCP rsp inf cod: 0x00
                       ^^ no TMF response
    FCP rsp IU     : 00000000 00000000 00000000 00000000
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                     00000000 00000000
                     ^^^^^^^^^^^^^^^^^ no interesting FCP_RSP_IU
    Sense len      : ...
    ^^^^^^^^^^^^^^^^^^^^ no sense data length
    Sense info     : ...
    ^^^^^^^^^^^^^^^^^^^^ no sense data content, even if present
    
    There are some true cases where we really do not have an FSF request:
    "rsl_fai" from zfcp_dbf_scsi_fail_send() called for early
    returns / completions in zfcp_scsi_queuecommand(),
    "abrt_or", "abrt_bl", "abrt_ru", "abrt_ar" from
    zfcp_scsi_eh_abort_handler() where we did not get as far,
    "lr_nres", "tr_nres" from zfcp_task_mgmt_function() where we're
    successful and do not need to do anything because adapter stopped.
    For these cases it's correct to pass NULL for fsf_req to _zfcp_dbf_scsi().
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: 8a36e4532ea1 ("[SCSI] zfcp: enhancement of zfcp debug features")
    Cc: <stable@vger.kernel.org> #2.6.38+
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index d99da4e1e27a..4c9ac55d053d 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -3,7 +3,7 @@
  *
  * Interface to Linux SCSI midlayer.
  *
- * Copyright IBM Corp. 2002, 2016
+ * Copyright IBM Corp. 2002, 2017
  */
 
 #define KMSG_COMPONENT "zfcp"
@@ -278,7 +278,7 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 
 		if (!(atomic_read(&adapter->status) &
 		      ZFCP_STATUS_COMMON_RUNNING)) {
-			zfcp_dbf_scsi_devreset("nres", scpnt, tm_flags);
+			zfcp_dbf_scsi_devreset("nres", scpnt, tm_flags, NULL);
 			return SUCCESS;
 		}
 	}
@@ -288,10 +288,10 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 	wait_for_completion(&fsf_req->completion);
 
 	if (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCFAILED) {
-		zfcp_dbf_scsi_devreset("fail", scpnt, tm_flags);
+		zfcp_dbf_scsi_devreset("fail", scpnt, tm_flags, fsf_req);
 		retval = FAILED;
 	} else {
-		zfcp_dbf_scsi_devreset("okay", scpnt, tm_flags);
+		zfcp_dbf_scsi_devreset("okay", scpnt, tm_flags, fsf_req);
 		zfcp_scsi_forget_cmnds(zfcp_sdev, tm_flags);
 	}
 

commit 5156934bd62098cb80eeaabb77e9949c900e7092
Author: Benjamin Block <bblock@linux.vnet.ibm.com>
Date:   Fri Jul 28 12:30:50 2017 +0200

    scsi: zfcp: convert bool-definitions to use 'true' instead of '1'
    
    Better form and cleans remaining warnings.
    
    Found with scripts/coccinelle/misc/boolinit.cocci.
    
    Signed-off-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 0678cf714c0e..d99da4e1e27a 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -28,7 +28,7 @@ static bool enable_dif;
 module_param_named(dif, enable_dif, bool, 0400);
 MODULE_PARM_DESC(dif, "Enable DIF/DIX data integrity support");
 
-static bool allow_lun_scan = 1;
+static bool allow_lun_scan = true;
 module_param(allow_lun_scan, bool, 0600);
 MODULE_PARM_DESC(allow_lun_scan, "For NPIV, scan and attach all storage LUNs");
 

commit b6a05c823fc573a65efc4466f174abf05f922e0f
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 30 13:18:58 2017 +0100

    scsi: remove eh_timed_out methods in the transport template
    
    Instead define the timeout behavior purely based on the host_template
    eh_timed_out method and wire up the existing transport implementations
    in the host templates.  This also clears up the confusion that the
    transport template method overrides the host template one, so some
    drivers have to re-override the transport template one.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 07ffdbb5107f..0678cf714c0e 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -330,6 +330,7 @@ static struct scsi_host_template zfcp_scsi_host_template = {
 	.module			 = THIS_MODULE,
 	.name			 = "zfcp",
 	.queuecommand		 = zfcp_scsi_queuecommand,
+	.eh_timed_out		 = fc_eh_timed_out,
 	.eh_abort_handler	 = zfcp_scsi_eh_abort_handler,
 	.eh_device_reset_handler = zfcp_scsi_eh_device_reset_handler,
 	.eh_target_reset_handler = zfcp_scsi_eh_target_reset_handler,

commit 6f2ce1c6af37191640ee3ff6e8fc39ea10352f4c
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Dec 9 17:16:33 2016 +0100

    scsi: zfcp: fix rport unblock race with LUN recovery
    
    It is unavoidable that zfcp_scsi_queuecommand() has to finish requests
    with DID_IMM_RETRY (like fc_remote_port_chkready()) during the time
    window when zfcp detected an unavailable rport but
    fc_remote_port_delete(), which is asynchronous via
    zfcp_scsi_schedule_rport_block(), has not yet blocked the rport.
    
    However, for the case when the rport becomes available again, we should
    prevent unblocking the rport too early.  In contrast to other FCP LLDDs,
    zfcp has to open each LUN with the FCP channel hardware before it can
    send I/O to a LUN.  So if a port already has LUNs attached and we
    unblock the rport just after port recovery, recoveries of LUNs behind
    this port can still be pending which in turn force
    zfcp_scsi_queuecommand() to unnecessarily finish requests with
    DID_IMM_RETRY.
    
    This also opens a time window with unblocked rport (until the followup
    LUN reopen recovery has finished).  If a scsi_cmnd timeout occurs during
    this time window fc_timed_out() cannot work as desired and such command
    would indeed time out and trigger scsi_eh. This prevents a clean and
    timely path failover.  This should not happen if the path issue can be
    recovered on FC transport layer such as path issues involving RSCNs.
    
    Fix this by only calling zfcp_scsi_schedule_rport_register(), to
    asynchronously trigger fc_remote_port_add(), after all LUN recoveries as
    children of the rport have finished and no new recoveries of equal or
    higher order were triggered meanwhile.  Finished intentionally includes
    any recovery result no matter if successful or failed (still unblock
    rport so other successful LUNs work).  For simplicity, we check after
    each finished LUN recovery if there is another LUN recovery pending on
    the same port and then do nothing.  We handle the special case of a
    successful recovery of a port without LUN children the same way without
    changing this case's semantics.
    
    For debugging we introduce 2 new trace records written if the rport
    unblock attempt was aborted due to still unfinished or freshly triggered
    recovery. The records are only written above the default trace level.
    
    Benjamin noticed the important special case of new recovery that can be
    triggered between having given up the erp_lock and before calling
    zfcp_erp_action_cleanup() within zfcp_erp_strategy().  We must avoid the
    following sequence:
    
    ERP thread                 rport_work      other context
    -------------------------  --------------  --------------------------------
    port is unblocked, rport still blocked,
     due to pending/running ERP action,
     so ((port->status & ...UNBLOCK) != 0)
     and (port->rport == NULL)
    unlock ERP
    zfcp_erp_action_cleanup()
    case ZFCP_ERP_ACTION_REOPEN_LUN:
    zfcp_erp_try_rport_unblock()
    ((status & ...UNBLOCK) != 0) [OLD!]
                                               zfcp_erp_port_reopen()
                                               lock ERP
                                               zfcp_erp_port_block()
                                               port->status clear ...UNBLOCK
                                               unlock ERP
                                               zfcp_scsi_schedule_rport_block()
                                               port->rport_task = RPORT_DEL
                                               queue_work(rport_work)
                               zfcp_scsi_rport_work()
                               (port->rport_task != RPORT_ADD)
                               port->rport_task = RPORT_NONE
                               zfcp_scsi_rport_block()
                               if (!port->rport) return
    zfcp_scsi_schedule_rport_register()
    port->rport_task = RPORT_ADD
    queue_work(rport_work)
                               zfcp_scsi_rport_work()
                               (port->rport_task == RPORT_ADD)
                               port->rport_task = RPORT_NONE
                               zfcp_scsi_rport_register()
                               (port->rport == NULL)
                               rport = fc_remote_port_add()
                               port->rport = rport;
    
    Now the rport was erroneously unblocked while the zfcp_port is blocked.
    This is another situation we want to avoid due to scsi_eh
    potential. This state would at least remain until the new recovery from
    the other context finished successfully, or potentially forever if it
    failed.  In order to close this race, we take the erp_lock inside
    zfcp_erp_try_rport_unblock() when checking the status of zfcp_port or
    LUN.  With that, the possible corresponding rport state sequences would
    be: (unblock[ERP thread],block[other context]) if the ERP thread gets
    erp_lock first and still sees ((port->status & ...UNBLOCK) != 0),
    (block[other context],NOP[ERP thread]) if the ERP thread gets erp_lock
    after the other context has already cleard ...UNBLOCK from port->status.
    
    Since checking fields of struct erp_action is unsafe because they could
    have been overwritten (re-used for new recovery) meanwhile, we only
    check status of zfcp_port and LUN since these are only changed under
    erp_lock elsewhere. Regarding the check of the proper status flags (port
    or port_forced are similar to the shown adapter recovery):
    
    [zfcp_erp_adapter_shutdown()]
    zfcp_erp_adapter_reopen()
     zfcp_erp_adapter_block()
      * clear UNBLOCK ---------------------------------------+
     zfcp_scsi_schedule_rports_block()                       |
     write_lock_irqsave(&adapter->erp_lock, flags);-------+  |
     zfcp_erp_action_enqueue()                            |  |
      zfcp_erp_setup_act()                                |  |
       * set ERP_INUSE -----------------------------------|--|--+
     write_unlock_irqrestore(&adapter->erp_lock, flags);--+  |  |
    .context-switch.                                         |  |
    zfcp_erp_thread()                                        |  |
     zfcp_erp_strategy()                                     |  |
      write_lock_irqsave(&adapter->erp_lock, flags);------+  |  |
      ...                                                 |  |  |
      zfcp_erp_strategy_check_target()                    |  |  |
       zfcp_erp_strategy_check_adapter()                  |  |  |
        zfcp_erp_adapter_unblock()                        |  |  |
         * set UNBLOCK -----------------------------------|--+  |
      zfcp_erp_action_dequeue()                           |     |
       * clear ERP_INUSE ---------------------------------|-----+
      ...                                                 |
      write_unlock_irqrestore(&adapter->erp_lock, flags);-+
    
    Hence, we should check for both UNBLOCK and ERP_INUSE because they are
    interleaved.  Also we need to explicitly check ERP_FAILED for the link
    down case which currently does not clear the UNBLOCK flag in
    zfcp_fsf_link_down_info_eval().
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: 8830271c4819 ("[SCSI] zfcp: Dont fail SCSI commands when transitioning to blocked fc_rport")
    Fixes: a2fa0aede07c ("[SCSI] zfcp: Block FC transport rports early on errors")
    Fixes: 5f852be9e11d ("[SCSI] zfcp: Fix deadlock between zfcp ERP and SCSI")
    Fixes: 338151e06608 ("[SCSI] zfcp: make use of fc_remote_port_delete when target port is unavailable")
    Fixes: 3859f6a248cb ("[PATCH] zfcp: add rports to enable scsi_add_device to work again")
    Cc: <stable@vger.kernel.org> #2.6.32+
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 11cd18c134c1..07ffdbb5107f 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -88,9 +88,7 @@ int zfcp_scsi_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *scpnt)
 	}
 
 	if (unlikely(!(status & ZFCP_STATUS_COMMON_UNBLOCKED))) {
-		/* This could be either
-		 * open LUN pending: this is temporary, will result in
-		 *	open LUN or ERP_FAILED, so retry command
+		/* This could be
 		 * call to rport_delete pending: mimic retry from
 		 * 	fc_remote_port_chkready until rport is BLOCKED
 		 */

commit dac37e15b7d511e026a9313c8c46794c144103cd
Author: Benjamin Block <bblock@linux.vnet.ibm.com>
Date:   Fri Dec 9 17:16:31 2016 +0100

    scsi: zfcp: fix use-after-"free" in FC ingress path after TMF
    
    When SCSI EH invokes zFCP's callbacks for eh_device_reset_handler() and
    eh_target_reset_handler(), it expects us to relent the ownership over
    the given scsi_cmnd and all other scsi_cmnds within the same scope - LUN
    or target - when returning with SUCCESS from the callback ('release'
    them).  SCSI EH can then reuse those commands.
    
    We did not follow this rule to release commands upon SUCCESS; and if
    later a reply arrived for one of those supposed to be released commands,
    we would still make use of the scsi_cmnd in our ingress tasklet. This
    will at least result in undefined behavior or a kernel panic because of
    a wrong kernel pointer dereference.
    
    To fix this, we NULLify all pointers to scsi_cmnds (struct zfcp_fsf_req
    *)->data in the matching scope if a TMF was successful. This is done
    under the locks (struct zfcp_adapter *)->abort_lock and (struct
    zfcp_reqlist *)->lock to prevent the requests from being removed from
    the request-hashtable, and the ingress tasklet from making use of the
    scsi_cmnd-pointer in zfcp_fsf_fcp_cmnd_handler().
    
    For cases where a reply arrives during SCSI EH, but before we get a
    chance to NULLify the pointer - but before we return from the callback
    -, we assume that the code is protected from races via the CAS operation
    in blk_complete_request() that is called in scsi_done().
    
    The following stacktrace shows an example for a crash resulting from the
    previous behavior:
    
    Unable to handle kernel pointer dereference at virtual kernel address fffffee17a672000
    Oops: 0038 [#1] SMP
    CPU: 2 PID: 0 Comm: swapper/2 Not tainted
    task: 00000003f7ff5be0 ti: 00000003f3d38000 task.ti: 00000003f3d38000
    Krnl PSW : 0404d00180000000 00000000001156b0 (smp_vcpu_scheduled+0x18/0x40)
               R:0 T:1 IO:0 EX:0 Key:0 M:1 W:0 P:0 AS:3 CC:1 PM:0 EA:3
    Krnl GPRS: 000000200000007e 0000000000000000 fffffee17a671fd8 0000000300000015
               ffffffff80000000 00000000005dfde8 07000003f7f80e00 000000004fa4e800
               000000036ce8d8f8 000000036ce8d9c0 00000003ece8fe00 ffffffff969c9e93
               00000003fffffffd 000000036ce8da10 00000000003bf134 00000003f3b07918
    Krnl Code: 00000000001156a2: a7190000        lghi    %r1,0
               00000000001156a6: a7380015        lhi    %r3,21
              #00000000001156aa: e32050000008    ag    %r2,0(%r5)
              >00000000001156b0: 482022b0        lh    %r2,688(%r2)
               00000000001156b4: ae123000        sigp    %r1,%r2,0(%r3)
               00000000001156b8: b2220020        ipm    %r2
               00000000001156bc: 8820001c        srl    %r2,28
               00000000001156c0: c02700000001    xilf    %r2,1
    Call Trace:
    ([<0000000000000000>] 0x0)
     [<000003ff807bdb8e>] zfcp_fsf_fcp_cmnd_handler+0x3de/0x490 [zfcp]
     [<000003ff807be30a>] zfcp_fsf_req_complete+0x252/0x800 [zfcp]
     [<000003ff807c0a48>] zfcp_fsf_reqid_check+0xe8/0x190 [zfcp]
     [<000003ff807c194e>] zfcp_qdio_int_resp+0x66/0x188 [zfcp]
     [<000003ff80440c64>] qdio_kick_handler+0xdc/0x310 [qdio]
     [<000003ff804463d0>] __tiqdio_inbound_processing+0xf8/0xcd8 [qdio]
     [<0000000000141fd4>] tasklet_action+0x9c/0x170
     [<0000000000141550>] __do_softirq+0xe8/0x258
     [<000000000010ce0a>] do_softirq+0xba/0xc0
     [<000000000014187c>] irq_exit+0xc4/0xe8
     [<000000000046b526>] do_IRQ+0x146/0x1d8
     [<00000000005d6a3c>] io_return+0x0/0x8
     [<00000000005d6422>] vtime_stop_cpu+0x4a/0xa0
    ([<0000000000000000>] 0x0)
     [<0000000000103d8a>] arch_cpu_idle+0xa2/0xb0
     [<0000000000197f94>] cpu_startup_entry+0x13c/0x1f8
     [<0000000000114782>] smp_start_secondary+0xda/0xe8
     [<00000000005d6efe>] restart_int_handler+0x56/0x6c
     [<0000000000000000>] 0x0
    Last Breaking-Event-Address:
     [<00000000003bf12e>] arch_spin_lock_wait+0x56/0xb0
    
    Suggested-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Fixes: ea127f9754 ("[PATCH] s390 (7/7): zfcp host adapter.") (tglx/history.git)
    Cc: <stable@vger.kernel.org> #2.6.32+
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 9069f98a1817..11cd18c134c1 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -3,7 +3,7 @@
  *
  * Interface to Linux SCSI midlayer.
  *
- * Copyright IBM Corp. 2002, 2015
+ * Copyright IBM Corp. 2002, 2016
  */
 
 #define KMSG_COMPONENT "zfcp"
@@ -209,6 +209,57 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	return retval;
 }
 
+struct zfcp_scsi_req_filter {
+	u8 tmf_scope;
+	u32 lun_handle;
+	u32 port_handle;
+};
+
+static void zfcp_scsi_forget_cmnd(struct zfcp_fsf_req *old_req, void *data)
+{
+	struct zfcp_scsi_req_filter *filter =
+		(struct zfcp_scsi_req_filter *)data;
+
+	/* already aborted - prevent side-effects - or not a SCSI command */
+	if (old_req->data == NULL || old_req->fsf_command != FSF_QTCB_FCP_CMND)
+		return;
+
+	/* (tmf_scope == FCP_TMF_TGT_RESET || tmf_scope == FCP_TMF_LUN_RESET) */
+	if (old_req->qtcb->header.port_handle != filter->port_handle)
+		return;
+
+	if (filter->tmf_scope == FCP_TMF_LUN_RESET &&
+	    old_req->qtcb->header.lun_handle != filter->lun_handle)
+		return;
+
+	zfcp_dbf_scsi_nullcmnd((struct scsi_cmnd *)old_req->data, old_req);
+	old_req->data = NULL;
+}
+
+static void zfcp_scsi_forget_cmnds(struct zfcp_scsi_dev *zsdev, u8 tm_flags)
+{
+	struct zfcp_adapter *adapter = zsdev->port->adapter;
+	struct zfcp_scsi_req_filter filter = {
+		.tmf_scope = FCP_TMF_TGT_RESET,
+		.port_handle = zsdev->port->handle,
+	};
+	unsigned long flags;
+
+	if (tm_flags == FCP_TMF_LUN_RESET) {
+		filter.tmf_scope = FCP_TMF_LUN_RESET;
+		filter.lun_handle = zsdev->lun_handle;
+	}
+
+	/*
+	 * abort_lock secures against other processings - in the abort-function
+	 * and normal cmnd-handler - of (struct zfcp_fsf_req *)->data
+	 */
+	write_lock_irqsave(&adapter->abort_lock, flags);
+	zfcp_reqlist_apply_for_all(adapter->req_list, zfcp_scsi_forget_cmnd,
+				   &filter);
+	write_unlock_irqrestore(&adapter->abort_lock, flags);
+}
+
 static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 {
 	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scpnt->device);
@@ -241,8 +292,10 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 	if (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCFAILED) {
 		zfcp_dbf_scsi_devreset("fail", scpnt, tm_flags);
 		retval = FAILED;
-	} else
+	} else {
 		zfcp_dbf_scsi_devreset("okay", scpnt, tm_flags);
+		zfcp_scsi_forget_cmnds(zfcp_sdev, tm_flags);
+	}
 
 	zfcp_fsf_req_free(fsf_req);
 	return retval;

commit 4eeaa4f3f1d6c47b69f70e222297a4df4743363e
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Wed Aug 10 18:30:46 2016 +0200

    zfcp: close window with unblocked rport during rport gone
    
    On a successful end of reopen port forced,
    zfcp_erp_strategy_followup_success() re-uses the port erp_action
    and the subsequent zfcp_erp_action_cleanup() now
    sees ZFCP_ERP_SUCCEEDED with
    erp_action->action==ZFCP_ERP_ACTION_REOPEN_PORT
    instead of ZFCP_ERP_ACTION_REOPEN_PORT_FORCED
    but must not perform zfcp_scsi_schedule_rport_register().
    
    We can detect this because the fresh port reopen erp_action
    is in its very first step ZFCP_ERP_STEP_UNINITIALIZED.
    
    Otherwise this opens a time window with unblocked rport
    (until the followup port reopen recovery would block it again).
    If a scsi_cmnd timeout occurs during this time window
    fc_timed_out() cannot work as desired and such command
    would indeed time out and trigger scsi_eh. This prevents
    a clean and timely path failover.
    This should not happen if the path issue can be recovered
    on FC transport layer such as path issues involving RSCNs.
    
    Also, unnecessary and repeated DID_IMM_RETRY for pending and
    undesired new requests occur because internally zfcp still
    has its zfcp_port blocked.
    
    As follow-on errors with scsi_eh, it can cause,
    in the worst case, permanently lost paths due to one of:
    sd <scsidev>: [<scsidisk>] Medium access timeout failure. Offlining disk!
    sd <scsidev>: Device offlined - not ready after error recovery
    
    For fix validation and to aid future debugging with other recoveries
    we now also trace (un)blocking of rports.
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: 5767620c383a ("[SCSI] zfcp: Do not unblock rport from REOPEN_PORT_FORCED")
    Fixes: a2fa0aede07c ("[SCSI] zfcp: Block FC transport rports early on errors")
    Fixes: 5f852be9e11d ("[SCSI] zfcp: Fix deadlock between zfcp ERP and SCSI")
    Fixes: 338151e06608 ("[SCSI] zfcp: make use of fc_remote_port_delete when target port is unavailable")
    Fixes: 3859f6a248cb ("[PATCH] zfcp: add rports to enable scsi_add_device to work again")
    Cc: <stable@vger.kernel.org> #2.6.32+
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index b3c6ff49103b..9069f98a1817 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -3,7 +3,7 @@
  *
  * Interface to Linux SCSI midlayer.
  *
- * Copyright IBM Corp. 2002, 2013
+ * Copyright IBM Corp. 2002, 2015
  */
 
 #define KMSG_COMPONENT "zfcp"
@@ -556,6 +556,9 @@ static void zfcp_scsi_rport_register(struct zfcp_port *port)
 	ids.port_id = port->d_id;
 	ids.roles = FC_RPORT_ROLE_FCP_TARGET;
 
+	zfcp_dbf_rec_trig("scpaddy", port->adapter, port, NULL,
+			  ZFCP_PSEUDO_ERP_ACTION_RPORT_ADD,
+			  ZFCP_PSEUDO_ERP_ACTION_RPORT_ADD);
 	rport = fc_remote_port_add(port->adapter->scsi_host, 0, &ids);
 	if (!rport) {
 		dev_err(&port->adapter->ccw_device->dev,
@@ -577,6 +580,9 @@ static void zfcp_scsi_rport_block(struct zfcp_port *port)
 	struct fc_rport *rport = port->rport;
 
 	if (rport) {
+		zfcp_dbf_rec_trig("scpdely", port->adapter, port, NULL,
+				  ZFCP_PSEUDO_ERP_ACTION_RPORT_DEL,
+				  ZFCP_PSEUDO_ERP_ACTION_RPORT_DEL);
 		fc_remote_port_delete(rport);
 		port->rport = NULL;
 	}

commit b84b1d522f979fb53ad347605e24b2940fa2ad99
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Apr 29 08:57:34 2015 +0200

    scsi: Do not set cmd_per_lun to 1 in the host template
    
    '0' is now used as the default cmd_per_lun value,
    so there's no need to explicitly set it to '1' in the
    host template.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 75f4bfc2b98a..b3c6ff49103b 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -297,7 +297,6 @@ static struct scsi_host_template zfcp_scsi_host_template = {
 				     * ZFCP_QDIO_MAX_SBALS_PER_REQ) - 2) * 8,
 				   /* GCD, adjusted later */
 	.dma_boundary		 = ZFCP_QDIO_SBALE_LEN - 1,
-	.cmd_per_lun		 = 1,
 	.use_clustering		 = 1,
 	.shost_attrs		 = zfcp_sysfs_shost_attrs,
 	.sdev_attrs		 = zfcp_sysfs_sdev_attrs,

commit db5ed4dfd5dd0142ec36ff7b335e0ec3b836b3e6
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Nov 13 15:08:42 2014 +0100

    scsi: drop reason argument from ->change_queue_depth
    
    Drop the now unused reason argument from the ->change_queue_depth method.
    Also add a return value to scsi_adjust_queue_depth, and rename it to
    scsi_change_queue_depth now that it can be used as the default
    ->change_queue_depth implementation.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 179bf3d8af6c..75f4bfc2b98a 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -32,13 +32,6 @@ static bool allow_lun_scan = 1;
 module_param(allow_lun_scan, bool, 0600);
 MODULE_PARM_DESC(allow_lun_scan, "For NPIV, scan and attach all storage LUNs");
 
-static int zfcp_scsi_change_queue_depth(struct scsi_device *sdev, int depth,
-					int reason)
-{
-	scsi_adjust_queue_depth(sdev, depth);
-	return sdev->queue_depth;
-}
-
 static void zfcp_scsi_slave_destroy(struct scsi_device *sdev)
 {
 	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);
@@ -54,7 +47,7 @@ static void zfcp_scsi_slave_destroy(struct scsi_device *sdev)
 static int zfcp_scsi_slave_configure(struct scsi_device *sdp)
 {
 	if (sdp->tagged_supported)
-		scsi_adjust_queue_depth(sdp, default_depth);
+		scsi_change_queue_depth(sdp, default_depth);
 	return 0;
 }
 
@@ -293,7 +286,7 @@ static struct scsi_host_template zfcp_scsi_host_template = {
 	.slave_alloc		 = zfcp_scsi_slave_alloc,
 	.slave_configure	 = zfcp_scsi_slave_configure,
 	.slave_destroy		 = zfcp_scsi_slave_destroy,
-	.change_queue_depth	 = zfcp_scsi_change_queue_depth,
+	.change_queue_depth	 = scsi_change_queue_depth,
 	.proc_name		 = "zfcp",
 	.can_queue		 = 4096,
 	.this_id		 = -1,

commit c40ecc12cfdb630332198a04e2832ae8218a61f1
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Nov 13 14:25:11 2014 +0100

    scsi: avoid ->change_queue_depth indirection for queue full tracking
    
    All drivers use the implementation for ramping the queue up and down, so
    instead of overloading the change_queue_depth method call the
    implementation diretly if the driver opts into it by setting the
    track_queue_depth flag in the host template.
    
    Note that a few drivers validated the new queue depth in their
    change_queue_depth method, but as we never go over the queue depth
    set during slave_configure or the sysfs file this isn't nessecary
    and can safely be removed.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Venkatesh Srinivas <venkateshs@google.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index b5dfa51f396f..179bf3d8af6c 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -35,19 +35,7 @@ MODULE_PARM_DESC(allow_lun_scan, "For NPIV, scan and attach all storage LUNs");
 static int zfcp_scsi_change_queue_depth(struct scsi_device *sdev, int depth,
 					int reason)
 {
-	switch (reason) {
-	case SCSI_QDEPTH_DEFAULT:
-		scsi_adjust_queue_depth(sdev, depth);
-		break;
-	case SCSI_QDEPTH_QFULL:
-		scsi_track_queue_full(sdev, depth);
-		break;
-	case SCSI_QDEPTH_RAMP_UP:
-		scsi_adjust_queue_depth(sdev, depth);
-		break;
-	default:
-		return -EOPNOTSUPP;
-	}
+	scsi_adjust_queue_depth(sdev, depth);
 	return sdev->queue_depth;
 }
 
@@ -320,6 +308,7 @@ static struct scsi_host_template zfcp_scsi_host_template = {
 	.use_clustering		 = 1,
 	.shost_attrs		 = zfcp_sysfs_shost_attrs,
 	.sdev_attrs		 = zfcp_sysfs_sdev_attrs,
+	.track_queue_depth	 = 1,
 };
 
 /**

commit c8b09f6fb67df7fc1b51ced1037fa9b677428149
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Nov 3 20:15:14 2014 +0100

    scsi: don't set tagging state from scsi_adjust_queue_depth
    
    Remove the tagged argument from scsi_adjust_queue_depth, and just let it
    handle the queue depth.  For most drivers those two are fairly separate,
    given that most modern drivers don't care about the SCSI "tagged" status
    of a command at all, and many old drivers allow queuing of multiple
    untagged commands in the driver.
    
    Instead we start out with the ->simple_tags flag set before calling
    ->slave_configure, which is how all drivers actually looking at
    ->simple_tags except for one worke anyway.  The one other case looks
    broken, but I've kept the behavior as-is for now.
    
    Except for that we only change ->simple_tags from the ->change_queue_type,
    and when rejecting a tag message in a single driver, so keeping this
    churn out of scsi_adjust_queue_depth is a clear win.
    
    Now that the usage of scsi_adjust_queue_depth is more obvious we can
    also remove all the trivial instances in ->slave_alloc or ->slave_configure
    that just set it to the cmd_per_lun default.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 7b353647cb90..b5dfa51f396f 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -37,13 +37,13 @@ static int zfcp_scsi_change_queue_depth(struct scsi_device *sdev, int depth,
 {
 	switch (reason) {
 	case SCSI_QDEPTH_DEFAULT:
-		scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);
+		scsi_adjust_queue_depth(sdev, depth);
 		break;
 	case SCSI_QDEPTH_QFULL:
 		scsi_track_queue_full(sdev, depth);
 		break;
 	case SCSI_QDEPTH_RAMP_UP:
-		scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);
+		scsi_adjust_queue_depth(sdev, depth);
 		break;
 	default:
 		return -EOPNOTSUPP;
@@ -66,9 +66,7 @@ static void zfcp_scsi_slave_destroy(struct scsi_device *sdev)
 static int zfcp_scsi_slave_configure(struct scsi_device *sdp)
 {
 	if (sdp->tagged_supported)
-		scsi_adjust_queue_depth(sdp, MSG_SIMPLE_TAG, default_depth);
-	else
-		scsi_adjust_queue_depth(sdp, 0, 1);
+		scsi_adjust_queue_depth(sdp, default_depth);
 	return 0;
 }
 

commit 5fea4291deacd80188b996d2f555fc6a1940e5d4
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Apr 26 17:33:45 2013 +0200

    [SCSI] zfcp: block queue limits with data router
    
    Commit 86a9668a8d29ea711613e1cb37efa68e7c4db564
    "[SCSI] zfcp: support for hardware data router"
    reduced the initial block queue limits in the scsi_host_template to the
    absolute minimum and adjusted them later on. However, the adjustment was
    too late for the BSG devices of Scsi_Host and fc_host.
    
    Therefore, ioctl(..., SG_IO, ...) with request or response size > 4kB to a
    BSG device of an fc_host or a Scsi_Host fails with EINVAL. As a result,
    users of such ioctl such as HBA_SendCTPassThru() in libzfcphbaapi return
    with error HBA_STATUS_ERROR.
    
    Initialize the block queue limits in zfcp_scsi_host_template to the
    greatest common denominator (GCD).
    
    While we cannot exploit the slightly enlarged maximum request size with
    data router, this should be neglectible. Doing so also avoids running into
    trouble after live guest relocation (LGR) / migration from a data router
    FCP device to an FCP device that does not support data router. In that
    case, zfcp would figure out the new limits on adapter recovery, but the
    fc_host and Scsi_Host (plus in fact all sdevs) still exist with the old and
    now too large queue limits.
    
    It should also OK, not to use half the size as in the DIX case, because
    fc_host and Scsi_Host do not transport FCP requests including SCSI commands
    using protection data.
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Reviewed-by: Martin Peschke <mpeschke@linux.vnet.ibm.com>
    Cc: <stable@vger.kernel.org> #3.2+
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 7b31e3f403f9..7b353647cb90 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -3,7 +3,7 @@
  *
  * Interface to Linux SCSI midlayer.
  *
- * Copyright IBM Corp. 2002, 2010
+ * Copyright IBM Corp. 2002, 2013
  */
 
 #define KMSG_COMPONENT "zfcp"
@@ -311,8 +311,12 @@ static struct scsi_host_template zfcp_scsi_host_template = {
 	.proc_name		 = "zfcp",
 	.can_queue		 = 4096,
 	.this_id		 = -1,
-	.sg_tablesize		 = 1, /* adjusted later */
-	.max_sectors		 = 8, /* adjusted later */
+	.sg_tablesize		 = (((QDIO_MAX_ELEMENTS_PER_BUFFER - 1)
+				     * ZFCP_QDIO_MAX_SBALS_PER_REQ) - 2),
+				   /* GCD, adjusted later */
+	.max_sectors		 = (((QDIO_MAX_ELEMENTS_PER_BUFFER - 1)
+				     * ZFCP_QDIO_MAX_SBALS_PER_REQ) - 2) * 8,
+				   /* GCD, adjusted later */
 	.dma_boundary		 = ZFCP_QDIO_SBALE_LEN - 1,
 	.cmd_per_lun		 = 1,
 	.use_clustering		 = 1,

commit a53c8fab3f87c995c30ac226a03af95361243144
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Fri Jul 20 11:15:04 2012 +0200

    s390/comments: unify copyright messages and remove file names
    
    Remove the file name from the comment at top of many files. In most
    cases the file name was wrong anyway, so it's rather pointless.
    
    Also unify the IBM copyright statement. We did have a lot of sightly
    different statements and wanted to change them one after another
    whenever a file gets touched. However that never happened. Instead
    people start to take the old/"wrong" statements to use as a template
    for new files.
    So unify all of them in one go.
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index b79576b64f45..7b31e3f403f9 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -3,7 +3,7 @@
  *
  * Interface to Linux SCSI midlayer.
  *
- * Copyright IBM Corporation 2002, 2010
+ * Copyright IBM Corp. 2002, 2010
  */
 
 #define KMSG_COMPONENT "zfcp"

commit 44f747fff6e9f027a4866c1a6864e26ae7c510c8
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Nov 18 20:00:40 2011 +0100

    [SCSI] zfcp: return early from slave_destroy if slave_alloc returned early
    
    zfcp_scsi_slave_destroy erroneously always tried to finish its task
    even if the corresponding previous zfcp_scsi_slave_alloc returned
    early. This can lead to kernel page faults on accessing uninitialized
    fields of struct zfcp_scsi_dev in zfcp_erp_lun_shutdown_wait. Take the
    port field of the struct to determine if slave_alloc returned early.
    
    This zfcp bug is exposed by 4e6c82b (in turn fixing f7c9c6b to be
    compatible with 21208ae) which can call slave_destroy for a
    corresponding previous slave_alloc that did not finish.
    
    This patch is based on James Bottomley's fix suggestion in
    http://www.spinics.net/lists/linux-scsi/msg55449.html.
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Cc: <stable@kernel.org> #2.6.38+
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 11f07f888223..b79576b64f45 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -55,6 +55,10 @@ static void zfcp_scsi_slave_destroy(struct scsi_device *sdev)
 {
 	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);
 
+	/* if previous slave_alloc returned early, there is nothing to do */
+	if (!zfcp_sdev->port)
+		return;
+
 	zfcp_erp_lun_shutdown_wait(sdev, "scssd_1");
 	put_device(&zfcp_sdev->port->dev);
 }

commit 3a4c5d5964ed43a5524f6d289fb4cd37d39f3f1a
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Sat Jul 30 09:25:15 2011 +0200

    s390: add missing module.h/export.h includes
    
    Fix several compile errors on s390 caused by splitting module.h.
    
    Some include additions [e.g. qdio_setup.c, zfcp_qdio.c] are in
    anticipation of pending changes queued for s390 that increase
    the modular use footprint.
    
    [PG: added additional obvious changes since Heiko's original patch]
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 09126a9d62ff..11f07f888223 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -9,6 +9,7 @@
 #define KMSG_COMPONENT "zfcp"
 #define pr_fmt(fmt) KMSG_COMPONENT ": " fmt
 
+#include <linux/module.h>
 #include <linux/types.h>
 #include <linux/slab.h>
 #include <scsi/fc/fc_fcp.h>

commit 86a9668a8d29ea711613e1cb37efa68e7c4db564
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Mon Aug 15 14:40:32 2011 +0200

    [SCSI] zfcp: support for hardware data router
    
    FICON Express8S supports hardware data router, which requires an
    adapted qdio request format.
    This part 2/2 exploits the functionality in zfcp.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 96c31a70445f..09126a9d62ff 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -306,8 +306,8 @@ static struct scsi_host_template zfcp_scsi_host_template = {
 	.proc_name		 = "zfcp",
 	.can_queue		 = 4096,
 	.this_id		 = -1,
-	.sg_tablesize		 = ZFCP_QDIO_MAX_SBALES_PER_REQ,
-	.max_sectors		 = (ZFCP_QDIO_MAX_SBALES_PER_REQ * 8),
+	.sg_tablesize		 = 1, /* adjusted later */
+	.max_sectors		 = 8, /* adjusted later */
 	.dma_boundary		 = ZFCP_QDIO_SBALE_LEN - 1,
 	.cmd_per_lun		 = 1,
 	.use_clustering		 = 1,
@@ -665,9 +665,9 @@ void zfcp_scsi_set_prot(struct zfcp_adapter *adapter)
 	    adapter->adapter_features & FSF_FEATURE_DIX_PROT_TCPIP) {
 		mask |= SHOST_DIX_TYPE1_PROTECTION;
 		scsi_host_set_guard(shost, SHOST_DIX_GUARD_IP);
-		shost->sg_prot_tablesize = ZFCP_QDIO_MAX_SBALES_PER_REQ / 2;
-		shost->sg_tablesize = ZFCP_QDIO_MAX_SBALES_PER_REQ / 2;
-		shost->max_sectors = ZFCP_QDIO_MAX_SBALES_PER_REQ * 8 / 2;
+		shost->sg_prot_tablesize = adapter->qdio->max_sbale_per_req / 2;
+		shost->sg_tablesize = adapter->qdio->max_sbale_per_req / 2;
+		shost->max_sectors = shost->sg_tablesize * 8;
 	}
 
 	scsi_host_set_prot(shost, mask);

commit cc405acee244310cc87ddc5e3f4bc61342ec8161
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Mon Aug 15 14:40:30 2011 +0200

    [SCSI] zfcp: non-experimental support for DIF/DIX
    
    DIF/DIX support for zfcp is no longer experimental,
    and config option is no longer necessary.
    Return error from queuecommand for unsupported data directions.
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 7cac873c7383..96c31a70445f 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -24,11 +24,8 @@ module_param_named(queue_depth, default_depth, uint, 0600);
 MODULE_PARM_DESC(queue_depth, "Default queue depth for new SCSI devices");
 
 static bool enable_dif;
-
-#ifdef CONFIG_ZFCP_DIF
-module_param_named(dif, enable_dif, bool, 0600);
+module_param_named(dif, enable_dif, bool, 0400);
 MODULE_PARM_DESC(dif, "Enable DIF/DIX data integrity support");
-#endif
 
 static bool allow_lun_scan = 1;
 module_param(allow_lun_scan, bool, 0600);

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 2a4991d6d4d5..7cac873c7383 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -13,7 +13,7 @@
 #include <linux/slab.h>
 #include <scsi/fc/fc_fcp.h>
 #include <scsi/scsi_eh.h>
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 #include "zfcp_ext.h"
 #include "zfcp_dbf.h"
 #include "zfcp_fc.h"

commit 038d9446a9e601d7972926ca69fee10eeda6f3c7
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue Feb 22 19:54:48 2011 +0100

    [SCSI] zfcp: Add information to symbolic port name when running in NPIV mode
    
    Query the FC symbolic port name for reporting in the fc_host sysfs and
    enable the symbolic_name attribute in the fc_host sysfs. When running
    in NPIV mode, extend the symbolic port name with the devno and the
    hostname. This allows better identification of Linux systems for SAN
    and storage administrators.
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index dbba0827127f..2a4991d6d4d5 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -720,6 +720,7 @@ struct fc_function_template zfcp_transport_functions = {
 	/* no functions registered for following dynamic attributes but
 	   directly set by LLDD */
 	.show_host_port_type = 1,
+	.show_host_symbolic_name = 1,
 	.show_host_speed = 1,
 	.show_host_port_id = 1,
 	.dd_bsg_size = sizeof(struct zfcp_fsf_ct_els),

commit 1947c72a122a8c367fdfc650c39a98ba76cc573a
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue Feb 22 19:54:46 2011 +0100

    [SCSI] zfcp: Move SCSI host and transport templates out of struct zfcp_data
    
    The SCSI host and transport templates are the only members left in the
    global zfcp_data struct. Move them out of zfcp_data  and remove the
    now unused zfcp_data struct. Also update the names of the register and
    unregister functions to use the zfcp_scsi prefix.
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index ddb5800823a9..dbba0827127f 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -292,7 +292,37 @@ static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 	return SUCCESS;
 }
 
-int zfcp_adapter_scsi_register(struct zfcp_adapter *adapter)
+struct scsi_transport_template *zfcp_scsi_transport_template;
+
+static struct scsi_host_template zfcp_scsi_host_template = {
+	.module			 = THIS_MODULE,
+	.name			 = "zfcp",
+	.queuecommand		 = zfcp_scsi_queuecommand,
+	.eh_abort_handler	 = zfcp_scsi_eh_abort_handler,
+	.eh_device_reset_handler = zfcp_scsi_eh_device_reset_handler,
+	.eh_target_reset_handler = zfcp_scsi_eh_target_reset_handler,
+	.eh_host_reset_handler	 = zfcp_scsi_eh_host_reset_handler,
+	.slave_alloc		 = zfcp_scsi_slave_alloc,
+	.slave_configure	 = zfcp_scsi_slave_configure,
+	.slave_destroy		 = zfcp_scsi_slave_destroy,
+	.change_queue_depth	 = zfcp_scsi_change_queue_depth,
+	.proc_name		 = "zfcp",
+	.can_queue		 = 4096,
+	.this_id		 = -1,
+	.sg_tablesize		 = ZFCP_QDIO_MAX_SBALES_PER_REQ,
+	.max_sectors		 = (ZFCP_QDIO_MAX_SBALES_PER_REQ * 8),
+	.dma_boundary		 = ZFCP_QDIO_SBALE_LEN - 1,
+	.cmd_per_lun		 = 1,
+	.use_clustering		 = 1,
+	.shost_attrs		 = zfcp_sysfs_shost_attrs,
+	.sdev_attrs		 = zfcp_sysfs_sdev_attrs,
+};
+
+/**
+ * zfcp_scsi_adapter_register - Register SCSI and FC host with SCSI midlayer
+ * @adapter: The zfcp adapter to register with the SCSI midlayer
+ */
+int zfcp_scsi_adapter_register(struct zfcp_adapter *adapter)
 {
 	struct ccw_dev_id dev_id;
 
@@ -301,7 +331,7 @@ int zfcp_adapter_scsi_register(struct zfcp_adapter *adapter)
 
 	ccw_device_get_id(adapter->ccw_device, &dev_id);
 	/* register adapter as SCSI host with mid layer of SCSI stack */
-	adapter->scsi_host = scsi_host_alloc(&zfcp_data.scsi_host_template,
+	adapter->scsi_host = scsi_host_alloc(&zfcp_scsi_host_template,
 					     sizeof (struct zfcp_adapter *));
 	if (!adapter->scsi_host) {
 		dev_err(&adapter->ccw_device->dev,
@@ -316,7 +346,7 @@ int zfcp_adapter_scsi_register(struct zfcp_adapter *adapter)
 	adapter->scsi_host->max_channel = 0;
 	adapter->scsi_host->unique_id = dev_id.devno;
 	adapter->scsi_host->max_cmd_len = 16; /* in struct fcp_cmnd */
-	adapter->scsi_host->transportt = zfcp_data.scsi_transport_template;
+	adapter->scsi_host->transportt = zfcp_scsi_transport_template;
 
 	adapter->scsi_host->hostdata[0] = (unsigned long) adapter;
 
@@ -328,7 +358,11 @@ int zfcp_adapter_scsi_register(struct zfcp_adapter *adapter)
 	return 0;
 }
 
-void zfcp_adapter_scsi_unregister(struct zfcp_adapter *adapter)
+/**
+ * zfcp_scsi_adapter_unregister - Unregister SCSI and FC host from SCSI midlayer
+ * @adapter: The zfcp adapter to unregister.
+ */
+void zfcp_scsi_adapter_unregister(struct zfcp_adapter *adapter)
 {
 	struct Scsi_Host *shost;
 	struct zfcp_port *port;
@@ -346,8 +380,6 @@ void zfcp_adapter_scsi_unregister(struct zfcp_adapter *adapter)
 	scsi_remove_host(shost);
 	scsi_host_put(shost);
 	adapter->scsi_host = NULL;
-
-	return;
 }
 
 static struct fc_host_statistics*
@@ -692,29 +724,3 @@ struct fc_function_template zfcp_transport_functions = {
 	.show_host_port_id = 1,
 	.dd_bsg_size = sizeof(struct zfcp_fsf_ct_els),
 };
-
-struct zfcp_data zfcp_data = {
-	.scsi_host_template = {
-		.name			 = "zfcp",
-		.module			 = THIS_MODULE,
-		.proc_name		 = "zfcp",
-		.change_queue_depth	 = zfcp_scsi_change_queue_depth,
-		.slave_alloc		 = zfcp_scsi_slave_alloc,
-		.slave_configure	 = zfcp_scsi_slave_configure,
-		.slave_destroy		 = zfcp_scsi_slave_destroy,
-		.queuecommand		 = zfcp_scsi_queuecommand,
-		.eh_abort_handler	 = zfcp_scsi_eh_abort_handler,
-		.eh_device_reset_handler = zfcp_scsi_eh_device_reset_handler,
-		.eh_target_reset_handler = zfcp_scsi_eh_target_reset_handler,
-		.eh_host_reset_handler	 = zfcp_scsi_eh_host_reset_handler,
-		.can_queue		 = 4096,
-		.this_id		 = -1,
-		.sg_tablesize		 = ZFCP_QDIO_MAX_SBALES_PER_REQ,
-		.cmd_per_lun		 = 1,
-		.use_clustering		 = 1,
-		.sdev_attrs		 = zfcp_sysfs_sdev_attrs,
-		.max_sectors		 = (ZFCP_QDIO_MAX_SBALES_PER_REQ * 8),
-		.dma_boundary		 = ZFCP_QDIO_SBALE_LEN - 1,
-		.shost_attrs		 = zfcp_sysfs_shost_attrs,
-	},
-};

commit 0d81b4e8dcc4177726f30a1ac8df1f726d2a7c0c
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Wed Dec 8 17:30:46 2010 +0100

    [SCSI] zfcp: Add allow_lun_scan module parameter
    
    The zfcpdump tool requires a method to attach exactly one LUN. The
    easiest way to achieve this is to add a new zfcp module parameter.
    When allow_lun_scan is set to "false", zfcp only accepts LUNs that
    have been configured through the unit_add sysfs interface.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 59a653d15a19..ddb5800823a9 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -30,6 +30,10 @@ module_param_named(dif, enable_dif, bool, 0600);
 MODULE_PARM_DESC(dif, "Enable DIF/DIX data integrity support");
 #endif
 
+static bool allow_lun_scan = 1;
+module_param(allow_lun_scan, bool, 0600);
+MODULE_PARM_DESC(allow_lun_scan, "For NPIV, scan and attach all storage LUNs");
+
 static int zfcp_scsi_change_queue_depth(struct scsi_device *sdev, int depth,
 					int reason)
 {
@@ -130,6 +134,7 @@ static int zfcp_scsi_slave_alloc(struct scsi_device *sdev)
 	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);
 	struct zfcp_port *port;
 	struct zfcp_unit *unit;
+	int npiv = adapter->connection_features & FSF_FEATURE_NPIV_MODE;
 
 	port = zfcp_get_port_by_wwpn(adapter, rport->port_name);
 	if (!port)
@@ -139,7 +144,7 @@ static int zfcp_scsi_slave_alloc(struct scsi_device *sdev)
 	if (unit)
 		put_device(&unit->dev);
 
-	if (!unit && !(adapter->connection_features & FSF_FEATURE_NPIV_MODE)) {
+	if (!unit && !(allow_lun_scan && npiv)) {
 		put_device(&port->dev);
 		return -ENXIO;
 	}

commit ea4a3a6ac40e2a585654808d4aefb39a6d57dca0
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Thu Dec 2 15:16:16 2010 +0100

    [SCSI] zfcp: Redesign of the debug tracing final cleanup.
    
    This patch is the final cleanup of the redesign from the zfcp tracing.
    Structures and elements which were used by multiple areas of the
    former debug tracing are now changed to the new scheme.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 8c5c1c89c098..59a653d15a19 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -154,7 +154,7 @@ static int zfcp_scsi_slave_alloc(struct scsi_device *sdev)
 	spin_lock_init(&zfcp_sdev->latencies.lock);
 
 	zfcp_erp_set_lun_status(sdev, ZFCP_STATUS_COMMON_RUNNING);
-	zfcp_erp_lun_reopen(sdev, 0, "scsla_1", NULL);
+	zfcp_erp_lun_reopen(sdev, 0, "scsla_1");
 	zfcp_erp_wait(port->adapter);
 
 	return 0;
@@ -278,7 +278,7 @@ static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 	struct zfcp_adapter *adapter = zfcp_sdev->port->adapter;
 	int ret;
 
-	zfcp_erp_adapter_reopen(adapter, 0, "schrh_1", scpnt);
+	zfcp_erp_adapter_reopen(adapter, 0, "schrh_1");
 	zfcp_erp_wait(adapter);
 	ret = fc_block_scsi_eh(scpnt);
 	if (ret)
@@ -516,7 +516,7 @@ static void zfcp_scsi_terminate_rport_io(struct fc_rport *rport)
 	port = zfcp_get_port_by_wwpn(adapter, rport->port_name);
 
 	if (port) {
-		zfcp_erp_port_forced_reopen(port, 0, "sctrpi1", NULL);
+		zfcp_erp_port_forced_reopen(port, 0, "sctrpi1");
 		put_device(&port->dev);
 	}
 }

commit 250a1352b95e1db3216e5c5d4f4365bea5122f4a
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Thu Dec 2 15:16:15 2010 +0100

    [SCSI] zfcp: Redesign of the debug tracing for SCSI records.
    
    This patch is the continuation to redesign the zfcp tracing to a more
    straight-forward and easy to extend scheme.
    
    This patch deals with all trace records of the zfcp SCSI area.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 63529ed801eb..8c5c1c89c098 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -68,11 +68,8 @@ static int zfcp_scsi_slave_configure(struct scsi_device *sdp)
 
 static void zfcp_scsi_command_fail(struct scsi_cmnd *scpnt, int result)
 {
-	struct zfcp_adapter *adapter =
-		(struct zfcp_adapter *) scpnt->device->host->hostdata[0];
-
 	set_host_byte(scpnt, result);
-	zfcp_dbf_scsi_fail_send(adapter->dbf, scpnt);
+	zfcp_dbf_scsi_fail_send(scpnt);
 	scpnt->scsi_done(scpnt);
 }
 
@@ -80,7 +77,6 @@ static
 int zfcp_scsi_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *scpnt)
 {
 	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scpnt->device);
-	struct zfcp_adapter *adapter = zfcp_sdev->port->adapter;
 	struct fc_rport *rport = starget_to_rport(scsi_target(scpnt->device));
 	int    status, scsi_result, ret;
 
@@ -91,7 +87,7 @@ int zfcp_scsi_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *scpnt)
 	scsi_result = fc_remote_port_chkready(rport);
 	if (unlikely(scsi_result)) {
 		scpnt->result = scsi_result;
-		zfcp_dbf_scsi_fail_send(adapter->dbf, scpnt);
+		zfcp_dbf_scsi_fail_send(scpnt);
 		scpnt->scsi_done(scpnt);
 		return 0;
 	}
@@ -182,8 +178,7 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	old_req = zfcp_reqlist_find(adapter->req_list, old_reqid);
 	if (!old_req) {
 		write_unlock_irqrestore(&adapter->abort_lock, flags);
-		zfcp_dbf_scsi_abort("lte1", adapter->dbf, scpnt, NULL,
-				    old_reqid);
+		zfcp_dbf_scsi_abort("abrt_or", scpnt, NULL);
 		return FAILED; /* completion could be in progress */
 	}
 	old_req->data = NULL;
@@ -198,29 +193,32 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 
 		zfcp_erp_wait(adapter);
 		ret = fc_block_scsi_eh(scpnt);
-		if (ret)
+		if (ret) {
+			zfcp_dbf_scsi_abort("abrt_bl", scpnt, NULL);
 			return ret;
+		}
 		if (!(atomic_read(&adapter->status) &
 		      ZFCP_STATUS_COMMON_RUNNING)) {
-			zfcp_dbf_scsi_abort("nres", adapter->dbf, scpnt, NULL,
-					    old_reqid);
+			zfcp_dbf_scsi_abort("abrt_ru", scpnt, NULL);
 			return SUCCESS;
 		}
 	}
-	if (!abrt_req)
+	if (!abrt_req) {
+		zfcp_dbf_scsi_abort("abrt_ar", scpnt, NULL);
 		return FAILED;
+	}
 
 	wait_for_completion(&abrt_req->completion);
 
 	if (abrt_req->status & ZFCP_STATUS_FSFREQ_ABORTSUCCEEDED)
-		dbf_tag = "okay";
+		dbf_tag = "abrt_ok";
 	else if (abrt_req->status & ZFCP_STATUS_FSFREQ_ABORTNOTNEEDED)
-		dbf_tag = "lte2";
+		dbf_tag = "abrt_nn";
 	else {
-		dbf_tag = "fail";
+		dbf_tag = "abrt_fa";
 		retval = FAILED;
 	}
-	zfcp_dbf_scsi_abort(dbf_tag, adapter->dbf, scpnt, abrt_req, old_reqid);
+	zfcp_dbf_scsi_abort(dbf_tag, scpnt, abrt_req);
 	zfcp_fsf_req_free(abrt_req);
 	return retval;
 }

commit e55f87531c2c1eb071a296df7eb67f83d5f0b5df
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Thu Nov 18 14:53:18 2010 +0100

    [SCSI] zfcp: Issue FCP command without holding SCSI host_lock
    
    Interrupting the connection to the FCP channel while I/O requests are
    being issued can lead to this deadlock. scsi_dispatch_cmd already
    holds the host_lock while the recovery trigger tries to acquire the
    host_lock again when iterating through the scsi_devices.
    
     INFO: lockdep is turned off.
     BUG: spinlock lockup on CPU#1, blast/9660, 0000000078f38878
     CPU: 1 Not tainted 2.6.35.7SWEN2 #2
     Process blast (pid: 9660, task: 0000000071f75940, ksp: 0000000074393ac0)
            0000000074393640 00000000743935c0 0000000000000002 0000000000000000
            0000000074393660 00000000743935d8 00000000743935d8 00000000005590c2
            0000000000000000 0000000078f38878 0000000026ede800 0000000078f38878
            000000000000000d 040000000000000c 0000000074393628 0000000000000000
            0000000000000000 0000000000100b2a 00000000743935c0 0000000074393600
     Call Trace:
     ([<0000000000100a32>] show_trace+0xee/0x144)
      [<00000000003be202>] do_raw_spin_lock+0x112/0x178
      [<000000000055d408>] _raw_spin_lock_irqsave+0x90/0xb0
      [<00000000003f1514>] __scsi_iterate_devices+0x38/0xbc
      [<00000000004849b0>] zfcp_erp_clear_adapter_status+0xd0/0x16c
      [<000000000048587a>] zfcp_erp_adapter_reopen+0x3a/0xb4
      [<0000000000489812>] zfcp_fsf_req_send+0x166/0x180
      [<000000000048c8d6>] zfcp_fsf_fcp_cmnd+0x272/0x408
      [<000000000048f864>] zfcp_scsi_queuecommand+0x11c/0x1e0
      [<00000000003f1f2a>] scsi_dispatch_cmd+0x1d6/0x324
      [<00000000003f9910>] scsi_request_fn+0x42c/0x56c
      [<00000000003828ae>] __blk_run_queue+0x86/0x140
      [<000000000037f742>] elv_insert+0x11a/0x208
      [<000000000038104c>] blk_insert_cloned_request+0x84/0xe4
      [<000003c0032b7c64>] dm_dispatch_request+0x6c/0x94 [dm_mod]
      [<000003c0032b7d5c>] map_request+0xd0/0x100 [dm_mod]
      [<000003c0032b9a78>] dm_request_fn+0xec/0x1bc [dm_mod]
      [<0000000000382c0e>] generic_unplug_device+0x5a/0x6c
      [<000003c0032b7f98>] dm_unplug_all+0x74/0x9c [dm_mod]
      [<00000000001d1272>] sync_page+0x76/0x9c
      [<00000000001d12ba>] sync_page_killable+0x22/0x60
      [<000000000055a768>] __wait_on_bit_lock+0xc0/0x124
      [<00000000001d1140>] __lock_page_killable+0x78/0x84
      [<00000000001d351c>] generic_file_aio_read+0x5a4/0x7e8
      [<0000000000228ec0>] do_sync_read+0xc8/0x12c
      [<0000000000229edc>] vfs_read+0xac/0x1ac
      [<000000000022a0d8>] SyS_read+0x58/0xa8
      [<00000000001146de>] sysc_noemu+0x10/0x16
      [<00000200000493c4>] 0x200000493c4
     INFO: lockdep is turned off.
    
    Call zfcp_fsf_fcp_cmnd without the host_lock and disable the
    interrupts when acquiring the req_q_lock. According to the patch
    description in "[PATCH] Eliminate error handler overload of the SCSI
    serial number", the serial_number is not used, so simply drop the
    queuecommand wrapper function and run zfcp_scsi_queuecommand without
    holding the host_lock.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 6bd2dbc4c316..63529ed801eb 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -76,8 +76,8 @@ static void zfcp_scsi_command_fail(struct scsi_cmnd *scpnt, int result)
 	scpnt->scsi_done(scpnt);
 }
 
-static int zfcp_scsi_queuecommand_lck(struct scsi_cmnd *scpnt,
-				  void (*done) (struct scsi_cmnd *))
+static
+int zfcp_scsi_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *scpnt)
 {
 	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scpnt->device);
 	struct zfcp_adapter *adapter = zfcp_sdev->port->adapter;
@@ -87,7 +87,6 @@ static int zfcp_scsi_queuecommand_lck(struct scsi_cmnd *scpnt,
 	/* reset the status for this request */
 	scpnt->result = 0;
 	scpnt->host_scribble = NULL;
-	scpnt->scsi_done = done;
 
 	scsi_result = fc_remote_port_chkready(rport);
 	if (unlikely(scsi_result)) {
@@ -127,8 +126,6 @@ static int zfcp_scsi_queuecommand_lck(struct scsi_cmnd *scpnt,
 	return ret;
 }
 
-static DEF_SCSI_QCMD(zfcp_scsi_queuecommand)
-
 static int zfcp_scsi_slave_alloc(struct scsi_device *sdev)
 {
 	struct fc_rport *rport = starget_to_rport(scsi_target(sdev));

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 50286d8707f3..6bd2dbc4c316 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -76,7 +76,7 @@ static void zfcp_scsi_command_fail(struct scsi_cmnd *scpnt, int result)
 	scpnt->scsi_done(scpnt);
 }
 
-static int zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
+static int zfcp_scsi_queuecommand_lck(struct scsi_cmnd *scpnt,
 				  void (*done) (struct scsi_cmnd *))
 {
 	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scpnt->device);
@@ -127,6 +127,8 @@ static int zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 	return ret;
 }
 
+static DEF_SCSI_QCMD(zfcp_scsi_queuecommand)
+
 static int zfcp_scsi_slave_alloc(struct scsi_device *sdev)
 {
 	struct fc_rport *rport = starget_to_rport(scsi_target(sdev));

commit c70b5296e775cde46cfcb2d860ba160108a5ec7a
Merge: 80c226fbef56 58ff4bd042ad
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 22 17:34:15 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (84 commits)
      [SCSI] be2iscsi: SGE Len == 64K
      [SCSI] be2iscsi: Remove premature free of cid
      [SCSI] be2iscsi: More time for FW
      [SCSI] libsas: fix bug for vacant phy
      [SCSI] sd: Fix overflow with big physical blocks
      [SCSI] st: add MTWEOFI to write filemarks without flushing drive buffer
      [SCSI] libsas: Don't issue commands to devices that have been hot-removed
      [SCSI] megaraid_sas: Add Online Controller Reset to MegaRAID SAS drive
      [SCSI] lpfc 8.3.17: Update lpfc driver version to 8.3.17
      [SCSI] lpfc 8.3.17: Replace function reset methodology
      [SCSI] lpfc 8.3.17: SCSI fixes
      [SCSI] lpfc 8.3.17: BSG fixes
      [SCSI] lpfc 8.3.17: SLI Additions and Fixes
      [SCSI] lpfc 8.3.17: Code Cleanup and Locking fixes
      [SCSI] zfcp: Remove scsi_cmnd->serial_number from debug traces
      [SCSI] ipr: fix array error logging
      [SCSI] aha152x: enable PCMCIA on 64bit
      [SCSI] scsi_dh_alua: Handle all states correctly
      [SCSI] cxgb4i: connection and ddp setting update
      [SCSI] cxgb3i: fixed connection over vlan
      ...

commit edaed859e63aac174fcc3fed81886b91bb124661
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Wed Sep 8 14:40:01 2010 +0200

    [SCSI] zfcp: Replace status modifier functions.
    
    Replace the zfcp_modify_<xxx>_status functions and its accompanying wrappers
    with dedicated status modifier functions. This eases code readability and
    maintenance.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 1e8d0cc7e1df..ae10883a5b28 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -158,8 +158,7 @@ static int zfcp_scsi_slave_alloc(struct scsi_device *sdev)
 	zfcp_sdev->latencies.cmd.fabric.min = 0xFFFFFFFF;
 	spin_lock_init(&zfcp_sdev->latencies.lock);
 
-	zfcp_erp_modify_lun_status(sdev, "scsla_0", NULL,
-				   ZFCP_STATUS_COMMON_RUNNING, ZFCP_SET);
+	zfcp_erp_set_lun_status(sdev, ZFCP_STATUS_COMMON_RUNNING);
 	zfcp_erp_lun_reopen(sdev, 0, "scsla_1", NULL);
 	zfcp_erp_wait(port->adapter);
 

commit f8210e34887e1feb977a9b6b8caa086855af40c9
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Wed Sep 8 14:39:56 2010 +0200

    [SCSI] zfcp: Allow midlayer to scan for LUNs when running in NPIV mode
    
    Enable the LUN scanning mechanism in the SCSI midlayer:
    - Do not set the disable_target_scan bit in the FC transport class.
    - Set max_lun to 0xFFFFFFFF to allow the midlayer scan to include
      the two-level hierachical LUNs (like 0x40XX40XX00000000, but in SCSI
      midlayer LUN format).
    - Set max_id to a high value to allow triggering the SCSI device
      rescan from sysfs.
    
    When running in NPIV mode, zfcp accepts all LUNs in slave_attach. When
    running in non-NPIV mode, the list of zfcp_unit structs determines
    which SCSI devices are allowed on the current system.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index bc7217b88989..1e8d0cc7e1df 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -143,7 +143,8 @@ static int zfcp_scsi_slave_alloc(struct scsi_device *sdev)
 	unit = zfcp_unit_find(port, zfcp_scsi_dev_lun(sdev));
 	if (unit)
 		put_device(&unit->dev);
-	else {
+
+	if (!unit && !(adapter->connection_features & FSF_FEATURE_NPIV_MODE)) {
 		put_device(&port->dev);
 		return -ENXIO;
 	}
@@ -309,8 +310,8 @@ int zfcp_adapter_scsi_register(struct zfcp_adapter *adapter)
 	}
 
 	/* tell the SCSI stack some characteristics of this adapter */
-	adapter->scsi_host->max_id = 1;
-	adapter->scsi_host->max_lun = 1;
+	adapter->scsi_host->max_id = 511;
+	adapter->scsi_host->max_lun = 0xFFFFFFFF;
 	adapter->scsi_host->max_channel = 0;
 	adapter->scsi_host->unique_id = dev_id.devno;
 	adapter->scsi_host->max_cmd_len = 16; /* in struct fcp_cmnd */
@@ -687,7 +688,6 @@ struct fc_function_template zfcp_transport_functions = {
 	.show_host_port_type = 1,
 	.show_host_speed = 1,
 	.show_host_port_id = 1,
-	.disable_target_scan = 1,
 	.dd_bsg_size = sizeof(struct zfcp_fsf_ct_els),
 };
 

commit b62a8d9b45b971a67a0f8413338c230e3117dff5
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Wed Sep 8 14:39:55 2010 +0200

    [SCSI] zfcp: Use SCSI device data zfcp_scsi_dev instead of zfcp_unit
    
    This is the large change to switch from using the data in
    zfcp_unit to zfcp_scsi_dev. Keeping everything working requires doing
    the switch in one piece. To ensure that no code keeps using the data
    in zfcp_unit, this patch also removes the data from zfcp_unit that is
    now being replaced with zfcp_scsi_dev.
    
    For zfcp, the scsi_device together with zfcp_scsi_dev exist from the
    call of slave_alloc to the call of slave_destroy. The data in
    zfcp_scsi_dev is initialized in zfcp_scsi_slave_alloc and the LUN is
    opened; the final shutdown for the LUN is run from slave_destroy.
    
    Where the scsi_device or zfcp_scsi_dev is needed, the pointer to the
    scsi_device is passed as function argument and inside the function
    converted to the pointer to zfcp_scsi_dev; this avoids back and forth
    conversion betweeen scsi_device and zfcp_scsi_dev.
    
    While changing the function arguments from zfcp_unit to scsi_device,
    the functions names are renamed form "unit" to "lun". This is to have
    a seperation between zfcp_scsi_dev/LUN and the zfcp_unit; only code
    referring to the remaining configuration information in zfcp_unit
    struct uses "unit".
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 03837797c45e..bc7217b88989 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -49,11 +49,12 @@ static int zfcp_scsi_change_queue_depth(struct scsi_device *sdev, int depth,
 	return sdev->queue_depth;
 }
 
-static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
+static void zfcp_scsi_slave_destroy(struct scsi_device *sdev)
 {
-	struct zfcp_unit *unit = (struct zfcp_unit *) sdpnt->hostdata;
-	unit->device = NULL;
-	put_device(&unit->dev);
+	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);
+
+	zfcp_erp_lun_shutdown_wait(sdev, "scssd_1");
+	put_device(&zfcp_sdev->port->dev);
 }
 
 static int zfcp_scsi_slave_configure(struct scsi_device *sdp)
@@ -78,23 +79,16 @@ static void zfcp_scsi_command_fail(struct scsi_cmnd *scpnt, int result)
 static int zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 				  void (*done) (struct scsi_cmnd *))
 {
-	struct zfcp_unit *unit;
-	struct zfcp_adapter *adapter;
-	int    status, scsi_result, ret;
+	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scpnt->device);
+	struct zfcp_adapter *adapter = zfcp_sdev->port->adapter;
 	struct fc_rport *rport = starget_to_rport(scsi_target(scpnt->device));
+	int    status, scsi_result, ret;
 
 	/* reset the status for this request */
 	scpnt->result = 0;
 	scpnt->host_scribble = NULL;
 	scpnt->scsi_done = done;
 
-	/*
-	 * figure out adapter and target device
-	 * (stored there by zfcp_scsi_slave_alloc)
-	 */
-	adapter = (struct zfcp_adapter *) scpnt->device->host->hostdata[0];
-	unit = scpnt->device->hostdata;
-
 	scsi_result = fc_remote_port_chkready(rport);
 	if (unlikely(scsi_result)) {
 		scpnt->result = scsi_result;
@@ -103,11 +97,11 @@ static int zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 		return 0;
 	}
 
-	status = atomic_read(&unit->status);
+	status = atomic_read(&zfcp_sdev->status);
 	if (unlikely(status & ZFCP_STATUS_COMMON_ERP_FAILED) &&
-		     !(atomic_read(&unit->port->status) &
+		     !(atomic_read(&zfcp_sdev->port->status) &
 		       ZFCP_STATUS_COMMON_ERP_FAILED)) {
-		/* only unit access denied, but port is good
+		/* only LUN access denied, but port is good
 		 * not covered by FC transport, have to fail here */
 		zfcp_scsi_command_fail(scpnt, DID_ERROR);
 		return 0;
@@ -115,8 +109,8 @@ static int zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 
 	if (unlikely(!(status & ZFCP_STATUS_COMMON_UNBLOCKED))) {
 		/* This could be either
-		 * open unit pending: this is temporary, will result in
-		 * 	open unit or ERP_FAILED, so retry command
+		 * open LUN pending: this is temporary, will result in
+		 *	open LUN or ERP_FAILED, so retry command
 		 * call to rport_delete pending: mimic retry from
 		 * 	fc_remote_port_chkready until rport is BLOCKED
 		 */
@@ -124,7 +118,7 @@ static int zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 		return 0;
 	}
 
-	ret = zfcp_fsf_send_fcp_command_task(unit, scpnt);
+	ret = zfcp_fsf_fcp_cmnd(scpnt);
 	if (unlikely(ret == -EBUSY))
 		return SCSI_MLQUEUE_DEVICE_BUSY;
 	else if (unlikely(ret < 0))
@@ -133,45 +127,42 @@ static int zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 	return ret;
 }
 
-static struct zfcp_unit *zfcp_unit_lookup(struct zfcp_adapter *adapter,
-					  unsigned int id, u64 lun)
+static int zfcp_scsi_slave_alloc(struct scsi_device *sdev)
 {
-	unsigned long flags;
+	struct fc_rport *rport = starget_to_rport(scsi_target(sdev));
+	struct zfcp_adapter *adapter =
+		(struct zfcp_adapter *) sdev->host->hostdata[0];
+	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);
 	struct zfcp_port *port;
-	struct zfcp_unit *unit = NULL;
+	struct zfcp_unit *unit;
 
-	read_lock_irqsave(&adapter->port_list_lock, flags);
-	list_for_each_entry(port, &adapter->port_list, list) {
-		if (!port->rport || (id != port->rport->scsi_target_id))
-			continue;
-		unit = zfcp_unit_find(port, lun);
-		if (unit)
-			break;
-	}
-	read_unlock_irqrestore(&adapter->port_list_lock, flags);
+	port = zfcp_get_port_by_wwpn(adapter, rport->port_name);
+	if (!port)
+		return -ENXIO;
 
-	return unit;
-}
+	unit = zfcp_unit_find(port, zfcp_scsi_dev_lun(sdev));
+	if (unit)
+		put_device(&unit->dev);
+	else {
+		put_device(&port->dev);
+		return -ENXIO;
+	}
 
-static int zfcp_scsi_slave_alloc(struct scsi_device *sdp)
-{
-	struct zfcp_adapter *adapter;
-	struct zfcp_unit *unit;
-	u64 lun;
+	zfcp_sdev->port = port;
+	zfcp_sdev->latencies.write.channel.min = 0xFFFFFFFF;
+	zfcp_sdev->latencies.write.fabric.min = 0xFFFFFFFF;
+	zfcp_sdev->latencies.read.channel.min = 0xFFFFFFFF;
+	zfcp_sdev->latencies.read.fabric.min = 0xFFFFFFFF;
+	zfcp_sdev->latencies.cmd.channel.min = 0xFFFFFFFF;
+	zfcp_sdev->latencies.cmd.fabric.min = 0xFFFFFFFF;
+	spin_lock_init(&zfcp_sdev->latencies.lock);
 
-	adapter = (struct zfcp_adapter *) sdp->host->hostdata[0];
-	if (!adapter)
-		goto out;
+	zfcp_erp_modify_lun_status(sdev, "scsla_0", NULL,
+				   ZFCP_STATUS_COMMON_RUNNING, ZFCP_SET);
+	zfcp_erp_lun_reopen(sdev, 0, "scsla_1", NULL);
+	zfcp_erp_wait(port->adapter);
 
-	int_to_scsilun(sdp->lun, (struct scsi_lun *)&lun);
-	unit = zfcp_unit_lookup(adapter, sdp->id, lun);
-	if (unit) {
-		sdp->hostdata = unit;
-		unit->device = sdp;
-		return 0;
-	}
-out:
-	return -ENXIO;
+	return 0;
 }
 
 static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
@@ -179,7 +170,6 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	struct Scsi_Host *scsi_host = scpnt->device->host;
 	struct zfcp_adapter *adapter =
 		(struct zfcp_adapter *) scsi_host->hostdata[0];
-	struct zfcp_unit *unit = scpnt->device->hostdata;
 	struct zfcp_fsf_req *old_req, *abrt_req;
 	unsigned long flags;
 	unsigned long old_reqid = (unsigned long) scpnt->host_scribble;
@@ -203,7 +193,7 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	write_unlock_irqrestore(&adapter->abort_lock, flags);
 
 	while (retry--) {
-		abrt_req = zfcp_fsf_abort_fcp_command(old_reqid, unit);
+		abrt_req = zfcp_fsf_abort_fcp_cmnd(scpnt);
 		if (abrt_req)
 			break;
 
@@ -238,14 +228,14 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 
 static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 {
-	struct zfcp_unit *unit = scpnt->device->hostdata;
-	struct zfcp_adapter *adapter = unit->port->adapter;
+	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scpnt->device);
+	struct zfcp_adapter *adapter = zfcp_sdev->port->adapter;
 	struct zfcp_fsf_req *fsf_req = NULL;
 	int retval = SUCCESS, ret;
 	int retry = 3;
 
 	while (retry--) {
-		fsf_req = zfcp_fsf_send_fcp_ctm(unit, tm_flags);
+		fsf_req = zfcp_fsf_fcp_task_mgmt(scpnt, tm_flags);
 		if (fsf_req)
 			break;
 
@@ -256,7 +246,7 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 
 		if (!(atomic_read(&adapter->status) &
 		      ZFCP_STATUS_COMMON_RUNNING)) {
-			zfcp_dbf_scsi_devreset("nres", tm_flags, unit, scpnt);
+			zfcp_dbf_scsi_devreset("nres", scpnt, tm_flags);
 			return SUCCESS;
 		}
 	}
@@ -266,10 +256,10 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 	wait_for_completion(&fsf_req->completion);
 
 	if (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCFAILED) {
-		zfcp_dbf_scsi_devreset("fail", tm_flags, unit, scpnt);
+		zfcp_dbf_scsi_devreset("fail", scpnt, tm_flags);
 		retval = FAILED;
 	} else
-		zfcp_dbf_scsi_devreset("okay", tm_flags, unit, scpnt);
+		zfcp_dbf_scsi_devreset("okay", scpnt, tm_flags);
 
 	zfcp_fsf_req_free(fsf_req);
 	return retval;
@@ -287,8 +277,8 @@ static int zfcp_scsi_eh_target_reset_handler(struct scsi_cmnd *scpnt)
 
 static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 {
-	struct zfcp_unit *unit = scpnt->device->hostdata;
-	struct zfcp_adapter *adapter = unit->port->adapter;
+	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scpnt->device);
+	struct zfcp_adapter *adapter = zfcp_sdev->port->adapter;
 	int ret;
 
 	zfcp_erp_adapter_reopen(adapter, 0, "schrh_1", scpnt);

commit 1daa4eb50fa5cd4c8f9c55452606e786fd42053b
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Wed Sep 8 14:39:52 2010 +0200

    [SCSI] zfcp: Move code for managing zfcp_unit devices to new file
    
    Move the code for managing zfcp_unit devices to the new file
    zfcp_unit.c. This is in preparation for the change that zfcp_unit will
    only track the LUNs configured via unit_add, other data will be moved
    from zfcp_unit to the new struct zfcp_scsi_dev.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index cb000c9833bb..03837797c45e 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -144,7 +144,7 @@ static struct zfcp_unit *zfcp_unit_lookup(struct zfcp_adapter *adapter,
 	list_for_each_entry(port, &adapter->port_list, list) {
 		if (!port->rport || (id != port->rport->scsi_target_id))
 			continue;
-		unit = zfcp_get_unit_by_lun(port, lun);
+		unit = zfcp_unit_find(port, lun);
 		if (unit)
 			break;
 	}
@@ -534,20 +534,6 @@ static void zfcp_scsi_terminate_rport_io(struct fc_rport *rport)
 	}
 }
 
-static void zfcp_scsi_queue_unit_register(struct zfcp_port *port)
-{
-	struct zfcp_unit *unit;
-
-	read_lock_irq(&port->unit_list_lock);
-	list_for_each_entry(unit, &port->unit_list, list) {
-		get_device(&unit->dev);
-		if (scsi_queue_work(port->adapter->scsi_host,
-				    &unit->scsi_work) <= 0)
-			put_device(&unit->dev);
-	}
-	read_unlock_irq(&port->unit_list_lock);
-}
-
 static void zfcp_scsi_rport_register(struct zfcp_port *port)
 {
 	struct fc_rport_identifiers ids;
@@ -574,7 +560,7 @@ static void zfcp_scsi_rport_register(struct zfcp_port *port)
 	port->rport = rport;
 	port->starget_id = rport->scsi_target_id;
 
-	zfcp_scsi_queue_unit_register(port);
+	zfcp_unit_queue_scsi_scan(port);
 }
 
 static void zfcp_scsi_rport_block(struct zfcp_port *port)
@@ -637,29 +623,6 @@ void zfcp_scsi_rport_work(struct work_struct *work)
 	put_device(&port->dev);
 }
 
-/**
- * zfcp_scsi_scan - Register LUN with SCSI midlayer
- * @unit: The LUN/unit to register
- */
-void zfcp_scsi_scan(struct zfcp_unit *unit)
-{
-	struct fc_rport *rport = unit->port->rport;
-
-	if (rport && rport->port_state == FC_PORTSTATE_ONLINE)
-		scsi_scan_target(&rport->dev, 0, rport->scsi_target_id,
-				 scsilun_to_int((struct scsi_lun *)
-						&unit->fcp_lun), 0);
-}
-
-void zfcp_scsi_scan_work(struct work_struct *work)
-{
-	struct zfcp_unit *unit = container_of(work, struct zfcp_unit,
-					      scsi_work);
-
-	zfcp_scsi_scan(unit);
-	put_device(&unit->dev);
-}
-
 /**
  * zfcp_scsi_set_prot - Configure DIF/DIX support in scsi_host
  * @adapter: The adapter where to configure DIF/DIX for the SCSI host

commit 175b79f0632544d62aae72e5496c14e3e3ff2ae7
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Fri Sep 10 20:50:40 2010 +0200

    zfcp: Report scatter gather limit for DIX protection information
    
    When sending DIX integrity segments with an I/O request, the
    restriction for the maximum number of segments is still the same for
    the zfcp hardware. Report the new sg_prot_tablesize for the SCSI host,
    so that the number of integrity segments plus the number of data
    segments is not larger than the hardware limit. This results in using
    half of the hardware segments for integrity data and the other half
    for regular data.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: Jens Axboe <axboe@carl.home.kernel.dk>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index cb000c9833bb..208256e39def 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -681,6 +681,7 @@ void zfcp_scsi_set_prot(struct zfcp_adapter *adapter)
 	    adapter->adapter_features & FSF_FEATURE_DIX_PROT_TCPIP) {
 		mask |= SHOST_DIX_TYPE1_PROTECTION;
 		scsi_host_set_guard(shost, SHOST_DIX_GUARD_IP);
+		shost->sg_prot_tablesize = ZFCP_QDIO_MAX_SBALES_PER_REQ / 2;
 		shost->sg_tablesize = ZFCP_QDIO_MAX_SBALES_PER_REQ / 2;
 		shost->max_sectors = ZFCP_QDIO_MAX_SBALES_PER_REQ * 8 / 2;
 	}

commit ef3eb71d8ba4fd9d48c5f9310bc9d90ca00323b4
Author: Felix Beck <felix.beck@de.ibm.com>
Date:   Fri Jul 16 15:37:42 2010 +0200

    [SCSI] zfcp: Introduce experimental support for DIF/DIX
    
    Introduce support for DIF/DIX in zfcp: Report the capabilities for the
    Scsi_host, map the protection data when issuing I/O requests and
    handle the new error codes. Also add the fsf data_direction field to
    the hba trace, it is useful information for debugging in that area.
    This is an EXPERIMENTAL feature for now.
    
    Signed-off-by: Felix Beck <felix.beck@de.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index eb471a1723cd..cb000c9833bb 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -12,6 +12,7 @@
 #include <linux/types.h>
 #include <linux/slab.h>
 #include <scsi/fc/fc_fcp.h>
+#include <scsi/scsi_eh.h>
 #include <asm/atomic.h>
 #include "zfcp_ext.h"
 #include "zfcp_dbf.h"
@@ -22,6 +23,13 @@ static unsigned int default_depth = 32;
 module_param_named(queue_depth, default_depth, uint, 0600);
 MODULE_PARM_DESC(queue_depth, "Default queue depth for new SCSI devices");
 
+static bool enable_dif;
+
+#ifdef CONFIG_ZFCP_DIF
+module_param_named(dif, enable_dif, bool, 0600);
+MODULE_PARM_DESC(dif, "Enable DIF/DIX data integrity support");
+#endif
+
 static int zfcp_scsi_change_queue_depth(struct scsi_device *sdev, int depth,
 					int reason)
 {
@@ -652,6 +660,51 @@ void zfcp_scsi_scan_work(struct work_struct *work)
 	put_device(&unit->dev);
 }
 
+/**
+ * zfcp_scsi_set_prot - Configure DIF/DIX support in scsi_host
+ * @adapter: The adapter where to configure DIF/DIX for the SCSI host
+ */
+void zfcp_scsi_set_prot(struct zfcp_adapter *adapter)
+{
+	unsigned int mask = 0;
+	unsigned int data_div;
+	struct Scsi_Host *shost = adapter->scsi_host;
+
+	data_div = atomic_read(&adapter->status) &
+		   ZFCP_STATUS_ADAPTER_DATA_DIV_ENABLED;
+
+	if (enable_dif &&
+	    adapter->adapter_features & FSF_FEATURE_DIF_PROT_TYPE1)
+		mask |= SHOST_DIF_TYPE1_PROTECTION;
+
+	if (enable_dif && data_div &&
+	    adapter->adapter_features & FSF_FEATURE_DIX_PROT_TCPIP) {
+		mask |= SHOST_DIX_TYPE1_PROTECTION;
+		scsi_host_set_guard(shost, SHOST_DIX_GUARD_IP);
+		shost->sg_tablesize = ZFCP_QDIO_MAX_SBALES_PER_REQ / 2;
+		shost->max_sectors = ZFCP_QDIO_MAX_SBALES_PER_REQ * 8 / 2;
+	}
+
+	scsi_host_set_prot(shost, mask);
+}
+
+/**
+ * zfcp_scsi_dif_sense_error - Report DIF/DIX error as driver sense error
+ * @scmd: The SCSI command to report the error for
+ * @ascq: The ASCQ to put in the sense buffer
+ *
+ * See the error handling in sd_done for the sense codes used here.
+ * Set DID_SOFT_ERROR to retry the request, if possible.
+ */
+void zfcp_scsi_dif_sense_error(struct scsi_cmnd *scmd, int ascq)
+{
+	scsi_build_sense_buffer(1, scmd->sense_buffer,
+				ILLEGAL_REQUEST, 0x10, ascq);
+	set_driver_byte(scmd, DRIVER_SENSE);
+	scmd->result |= SAM_STAT_CHECK_CONDITION;
+	set_host_byte(scmd, DID_SOFT_ERROR);
+}
+
 struct fc_function_template zfcp_transport_functions = {
 	.show_starget_port_id = 1,
 	.show_starget_port_name = 1,

commit 01b047599ade30051bf6c14fbe64181d1fec3dfa
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Fri Jul 16 15:37:37 2010 +0200

    [SCSI] zfcp: Cleanup function parameters for sbal value.
    
    A lot of functions require the amount of SBALs as one of their
    parameter which is most times invariable.  Therefore remove this
    parameter and set the SBAL value explicitly if a non standard value is
    required.  In addition the warning message "oversized data" is
    replaced with a BUG_ON() statement assuring the limits defined and
    requested by zfcp.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 9d117ee7159a..eb471a1723cd 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -701,11 +701,11 @@ struct zfcp_data zfcp_data = {
 		.eh_host_reset_handler	 = zfcp_scsi_eh_host_reset_handler,
 		.can_queue		 = 4096,
 		.this_id		 = -1,
-		.sg_tablesize		 = ZFCP_FSF_MAX_SBALES_PER_REQ,
+		.sg_tablesize		 = ZFCP_QDIO_MAX_SBALES_PER_REQ,
 		.cmd_per_lun		 = 1,
 		.use_clustering		 = 1,
 		.sdev_attrs		 = zfcp_sysfs_sdev_attrs,
-		.max_sectors		 = (ZFCP_FSF_MAX_SBALES_PER_REQ * 8),
+		.max_sectors		 = (ZFCP_QDIO_MAX_SBALES_PER_REQ * 8),
 		.dma_boundary		 = ZFCP_QDIO_SBALE_LEN - 1,
 		.shost_attrs		 = zfcp_sysfs_shost_attrs,
 	},

commit 1bf3ff02ca6247b2d7c9ebda93002392bf60a61d
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Fri Jul 16 15:37:35 2010 +0200

    [SCSI] zfcp: Remove SCSI device when removing unit
    
    Configuring a LUN in zfcp, also creates a SCSI device. For
    consistency, it makes sense to remove the SCSI device when the LUN is
    deconfigured. Replace the flush_work with the call to
    scsi_remove_device: scsi_remove_device also takes the scan_mutex that
    synchronizes itself with any long running device discovery.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 4cab33a2f7be..9d117ee7159a 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -564,6 +564,7 @@ static void zfcp_scsi_rport_register(struct zfcp_port *port)
 	rport->maxframe_size = port->maxframe_size;
 	rport->supported_classes = port->supported_classes;
 	port->rport = rport;
+	port->starget_id = rport->scsi_target_id;
 
 	zfcp_scsi_queue_unit_register(port);
 }

commit 835dc29887073eec7817559a07558f955383d099
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Thu Jul 8 09:53:08 2010 +0200

    [SCSI] zfcp: Use forced_reopen in terminate_rport_io callback
    
    When running in non-NPIV mode, the port_reopen in terminate_rport_io
    might succeed even though the remote port is not available. If the
    same port connection is held open from another operating system, the
    reopen is only a virtual operation and might not hit the SAN. Fix this
    by changing the call to forced_reopen that forces a logout/login
    operation in the SAN.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 153f69b26e78..4cab33a2f7be 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -506,8 +506,10 @@ static void zfcp_set_rport_dev_loss_tmo(struct fc_rport *rport, u32 timeout)
  * @rport: The FC rport where to teminate I/O
  *
  * Abort all pending SCSI commands for a port by closing the
- * port. Using a reopen avoiding a conflict with a shutdown
- * overwriting a reopen.
+ * port. Using a reopen avoids a conflict with a shutdown
+ * overwriting a reopen. The "forced" ensures that a disappeared port
+ * is not opened again as valid due to the cached plogi data in
+ * non-NPIV mode.
  */
 static void zfcp_scsi_terminate_rport_io(struct fc_rport *rport)
 {
@@ -519,7 +521,7 @@ static void zfcp_scsi_terminate_rport_io(struct fc_rport *rport)
 	port = zfcp_get_port_by_wwpn(adapter, rport->port_name);
 
 	if (port) {
-		zfcp_erp_port_reopen(port, 0, "sctrpi1", NULL);
+		zfcp_erp_port_forced_reopen(port, 0, "sctrpi1", NULL);
 		put_device(&port->dev);
 	}
 }

commit 5a7de559b4e0169ff4cfca654b4e4f0014996e57
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Thu Jul 8 09:53:07 2010 +0200

    [SCSI] zfcp: Register SCSI devices after successful fc_remote_port_add
    
    When the successful return of an adisc is the final step to set the
    port online, the registration of SCSI devices might be omitted. SCSI
    devices that have been removed before (due to a short dev_loss_tmo
    setting) might not be attached again.
    
    The problem is that the registration of SCSI devices is done only
    after erp has finished. The correct place would be after the call to
    fc_remote_port_add to mimick the scan in the FC transport class.
    
    Change the registration of SCSI devices to be triggered after the
    fc_remote_port_add call. For the initial inquiry command to succeed,
    the unit must also be open. If the unit reopen is still pending, the
    inquiry command to the LUN will be deferred with DID_IMM_RETRY, so
    there is no harm from this approach.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index be5d2c60453d..153f69b26e78 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -524,6 +524,20 @@ static void zfcp_scsi_terminate_rport_io(struct fc_rport *rport)
 	}
 }
 
+static void zfcp_scsi_queue_unit_register(struct zfcp_port *port)
+{
+	struct zfcp_unit *unit;
+
+	read_lock_irq(&port->unit_list_lock);
+	list_for_each_entry(unit, &port->unit_list, list) {
+		get_device(&unit->dev);
+		if (scsi_queue_work(port->adapter->scsi_host,
+				    &unit->scsi_work) <= 0)
+			put_device(&unit->dev);
+	}
+	read_unlock_irq(&port->unit_list_lock);
+}
+
 static void zfcp_scsi_rport_register(struct zfcp_port *port)
 {
 	struct fc_rport_identifiers ids;
@@ -548,6 +562,8 @@ static void zfcp_scsi_rport_register(struct zfcp_port *port)
 	rport->maxframe_size = port->maxframe_size;
 	rport->supported_classes = port->supported_classes;
 	port->rport = rport;
+
+	zfcp_scsi_queue_unit_register(port);
 }
 
 static void zfcp_scsi_rport_block(struct zfcp_port *port)
@@ -610,21 +626,26 @@ void zfcp_scsi_rport_work(struct work_struct *work)
 	put_device(&port->dev);
 }
 
-
-void zfcp_scsi_scan(struct work_struct *work)
+/**
+ * zfcp_scsi_scan - Register LUN with SCSI midlayer
+ * @unit: The LUN/unit to register
+ */
+void zfcp_scsi_scan(struct zfcp_unit *unit)
 {
-	struct zfcp_unit *unit = container_of(work, struct zfcp_unit,
-					      scsi_work);
-	struct fc_rport *rport;
-
-	flush_work(&unit->port->rport_work);
-	rport = unit->port->rport;
+	struct fc_rport *rport = unit->port->rport;
 
 	if (rport && rport->port_state == FC_PORTSTATE_ONLINE)
 		scsi_scan_target(&rport->dev, 0, rport->scsi_target_id,
 				 scsilun_to_int((struct scsi_lun *)
 						&unit->fcp_lun), 0);
+}
+
+void zfcp_scsi_scan_work(struct work_struct *work)
+{
+	struct zfcp_unit *unit = container_of(work, struct zfcp_unit,
+					      scsi_work);
 
+	zfcp_scsi_scan(unit);
 	put_device(&unit->dev);
 }
 

commit 1674b4054744c2cfd6573e43eca45d86ff581d0e
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Fri Apr 30 18:09:34 2010 +0200

    [SCSI] zfcp: Move sbale handling to zfcp_qdio files
    
    Move the code accessing the qdio sbales and zfcp_qdio_req struct to
    the zfcp_qdio files and provide helper functions for accessing the
    qdio related parts.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 066b0507a639..be5d2c60453d 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -677,11 +677,11 @@ struct zfcp_data zfcp_data = {
 		.eh_host_reset_handler	 = zfcp_scsi_eh_host_reset_handler,
 		.can_queue		 = 4096,
 		.this_id		 = -1,
-		.sg_tablesize		 = ZFCP_MAX_SBALES_PER_REQ,
+		.sg_tablesize		 = ZFCP_FSF_MAX_SBALES_PER_REQ,
 		.cmd_per_lun		 = 1,
 		.use_clustering		 = 1,
 		.sdev_attrs		 = zfcp_sysfs_sdev_attrs,
-		.max_sectors		 = (ZFCP_MAX_SBALES_PER_REQ * 8),
+		.max_sectors		 = (ZFCP_FSF_MAX_SBALES_PER_REQ * 8),
 		.dma_boundary		 = ZFCP_QDIO_SBALE_LEN - 1,
 		.shost_attrs		 = zfcp_sysfs_shost_attrs,
 	},

commit 683229845f1780b10041ee7a1043fc8f10061455
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Fri Apr 30 18:09:33 2010 +0200

    [SCSI] zfcp: Report scatter-gather limits to SCSI and block layer
    
    Instead of dealing with large segments in the scatter-gather lists in
    zfcp_qdio.c, report the limits to the upper layers. With these limits
    in place, the code for mapping large data blocks to multiple sbales
    can be removed.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index d13eb9a6408a..066b0507a639 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -682,6 +682,7 @@ struct zfcp_data zfcp_data = {
 		.use_clustering		 = 1,
 		.sdev_attrs		 = zfcp_sysfs_sdev_attrs,
 		.max_sectors		 = (ZFCP_MAX_SBALES_PER_REQ * 8),
+		.dma_boundary		 = ZFCP_QDIO_SBALE_LEN - 1,
 		.shost_attrs		 = zfcp_sysfs_shost_attrs,
 	},
 };

commit a1dbfddd02d2b3e75f8750c68563e1d6eec16260
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Wed Mar 24 16:50:31 2010 +0100

    [SCSI] zfcp: Pass return code from fc_block_scsi_eh to scsi eh
    
    The return code FAST_IO_FAIL from fc_block_scsi_eh indicates that the
    pending I/O requests have been terminated as a result of the
    fast_io_fail_tmo. Pass this return code back to the scsi eh to stop
    the scsi eh in this case.
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 174b6d57d576..d13eb9a6408a 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -175,7 +175,7 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	struct zfcp_fsf_req *old_req, *abrt_req;
 	unsigned long flags;
 	unsigned long old_reqid = (unsigned long) scpnt->host_scribble;
-	int retval = SUCCESS;
+	int retval = SUCCESS, ret;
 	int retry = 3;
 	char *dbf_tag;
 
@@ -200,7 +200,9 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 			break;
 
 		zfcp_erp_wait(adapter);
-		fc_block_scsi_eh(scpnt);
+		ret = fc_block_scsi_eh(scpnt);
+		if (ret)
+			return ret;
 		if (!(atomic_read(&adapter->status) &
 		      ZFCP_STATUS_COMMON_RUNNING)) {
 			zfcp_dbf_scsi_abort("nres", adapter->dbf, scpnt, NULL,
@@ -231,7 +233,7 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 	struct zfcp_unit *unit = scpnt->device->hostdata;
 	struct zfcp_adapter *adapter = unit->port->adapter;
 	struct zfcp_fsf_req *fsf_req = NULL;
-	int retval = SUCCESS;
+	int retval = SUCCESS, ret;
 	int retry = 3;
 
 	while (retry--) {
@@ -240,7 +242,10 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 			break;
 
 		zfcp_erp_wait(adapter);
-		fc_block_scsi_eh(scpnt);
+		ret = fc_block_scsi_eh(scpnt);
+		if (ret)
+			return ret;
+
 		if (!(atomic_read(&adapter->status) &
 		      ZFCP_STATUS_COMMON_RUNNING)) {
 			zfcp_dbf_scsi_devreset("nres", tm_flags, unit, scpnt);
@@ -276,10 +281,13 @@ static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 {
 	struct zfcp_unit *unit = scpnt->device->hostdata;
 	struct zfcp_adapter *adapter = unit->port->adapter;
+	int ret;
 
 	zfcp_erp_adapter_reopen(adapter, 0, "schrh_1", scpnt);
 	zfcp_erp_wait(adapter);
-	fc_block_scsi_eh(scpnt);
+	ret = fc_block_scsi_eh(scpnt);
+	if (ret)
+		return ret;
 
 	return SUCCESS;
 }

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index c3c4178888af..174b6d57d576 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -10,6 +10,7 @@
 #define pr_fmt(fmt) KMSG_COMPONENT ": " fmt
 
 #include <linux/types.h>
+#include <linux/slab.h>
 #include <scsi/fc/fc_fcp.h>
 #include <asm/atomic.h>
 #include "zfcp_ext.h"

commit ab72528a4498251a702fa7693b51b9311b2432f8
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Wed Feb 17 11:18:57 2010 +0100

    [SCSI] zfcp: Move scsi result tracing decision to zfcp_dbf.h
    
    Move the decision which trace tag and trace level to use for the scsi
    result trace to zfcp_dbf.h. zfcp_dbf_scsi_result is already an inline
    function, so move the trace code there, simplifying the response
    handling in zfcp_fsf.c.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 0d580b2fc4da..c3c4178888af 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -62,7 +62,7 @@ static void zfcp_scsi_command_fail(struct scsi_cmnd *scpnt, int result)
 		(struct zfcp_adapter *) scpnt->device->host->hostdata[0];
 
 	set_host_byte(scpnt, result);
-	zfcp_dbf_scsi_result("fail", 4, adapter->dbf, scpnt, NULL);
+	zfcp_dbf_scsi_fail_send(adapter->dbf, scpnt);
 	scpnt->scsi_done(scpnt);
 }
 
@@ -89,7 +89,7 @@ static int zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 	scsi_result = fc_remote_port_chkready(rport);
 	if (unlikely(scsi_result)) {
 		scpnt->result = scsi_result;
-		zfcp_dbf_scsi_result("fail", 4, adapter->dbf, scpnt, NULL);
+		zfcp_dbf_scsi_fail_send(adapter->dbf, scpnt);
 		scpnt->scsi_done(scpnt);
 		return 0;
 	}

commit 615f59e0daaf56e43dcaaf3ea228967d9bc21584
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Wed Feb 17 11:18:56 2010 +0100

    [SCSI] zfcp: Rename sysfs_device attribute to dev in zfcp_unit and zfcp_port
    
    Kernel code uses dev as short name for the struct device. Rename the
    sysfs_device in zfcp_unit and zfcp_port to match this convention.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 1fce8a49fc60..0d580b2fc4da 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -3,7 +3,7 @@
  *
  * Interface to Linux SCSI midlayer.
  *
- * Copyright IBM Corporation 2002, 2009
+ * Copyright IBM Corporation 2002, 2010
  */
 
 #define KMSG_COMPONENT "zfcp"
@@ -44,7 +44,7 @@ static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 {
 	struct zfcp_unit *unit = (struct zfcp_unit *) sdpnt->hostdata;
 	unit->device = NULL;
-	put_device(&unit->sysfs_device);
+	put_device(&unit->dev);
 }
 
 static int zfcp_scsi_slave_configure(struct scsi_device *sdp)
@@ -511,7 +511,7 @@ static void zfcp_scsi_terminate_rport_io(struct fc_rport *rport)
 
 	if (port) {
 		zfcp_erp_port_reopen(port, 0, "sctrpi1", NULL);
-		put_device(&port->sysfs_device);
+		put_device(&port->dev);
 	}
 }
 
@@ -553,23 +553,23 @@ static void zfcp_scsi_rport_block(struct zfcp_port *port)
 
 void zfcp_scsi_schedule_rport_register(struct zfcp_port *port)
 {
-	get_device(&port->sysfs_device);
+	get_device(&port->dev);
 	port->rport_task = RPORT_ADD;
 
 	if (!queue_work(port->adapter->work_queue, &port->rport_work))
-		put_device(&port->sysfs_device);
+		put_device(&port->dev);
 }
 
 void zfcp_scsi_schedule_rport_block(struct zfcp_port *port)
 {
-	get_device(&port->sysfs_device);
+	get_device(&port->dev);
 	port->rport_task = RPORT_DEL;
 
 	if (port->rport && queue_work(port->adapter->work_queue,
 				      &port->rport_work))
 		return;
 
-	put_device(&port->sysfs_device);
+	put_device(&port->dev);
 }
 
 void zfcp_scsi_schedule_rports_block(struct zfcp_adapter *adapter)
@@ -598,7 +598,7 @@ void zfcp_scsi_rport_work(struct work_struct *work)
 		}
 	}
 
-	put_device(&port->sysfs_device);
+	put_device(&port->dev);
 }
 
 
@@ -616,7 +616,7 @@ void zfcp_scsi_scan(struct work_struct *work)
 				 scsilun_to_int((struct scsi_lun *)
 						&unit->fcp_lun), 0);
 
-	put_device(&unit->sysfs_device);
+	put_device(&unit->dev);
 }
 
 struct fc_function_template zfcp_transport_functions = {

commit 22ed130719987d1081831dc1481160b216224ffd
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Wed Feb 17 11:18:53 2010 +0100

    [SCSI] zfcp: Fix warnings from smatch
    
    The smatch tool from http://repo.or.cz/w/smatch.git warns about this:
    
    drivers/s390/scsi/zfcp_scsi.c +64 zfcp_scsi_command_fail(5) warn: variable dereferenced before check 'scpnt->device'
    drivers/s390/scsi/zfcp_scsi.c +64 zfcp_scsi_command_fail(5) warn: variable dereferenced before check 'scpnt->device->host'
    drivers/s390/scsi/zfcp_scsi.c +93 zfcp_scsi_queuecommand(23) warn: variable dereferenced before check 'unit'
    
    Fix the first two warnings by removing the checks for scpnt->device
    and -> host: As long as the SCSI command exists, there is also a
    scsi_device and a Scsi_Host.
    
    Fix the last warning by removing the BUG_ON checks in
    zfcp_scsi_queuecommand, they are leftovers from previous paranoia
    about wrong pointers between data structures.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index e1e56f523116..1fce8a49fc60 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -60,10 +60,9 @@ static void zfcp_scsi_command_fail(struct scsi_cmnd *scpnt, int result)
 {
 	struct zfcp_adapter *adapter =
 		(struct zfcp_adapter *) scpnt->device->host->hostdata[0];
+
 	set_host_byte(scpnt, result);
-	if ((scpnt->device != NULL) && (scpnt->device->host != NULL))
-		zfcp_dbf_scsi_result("fail", 4, adapter->dbf, scpnt, NULL);
-	/* return directly */
+	zfcp_dbf_scsi_result("fail", 4, adapter->dbf, scpnt, NULL);
 	scpnt->scsi_done(scpnt);
 }
 
@@ -87,14 +86,6 @@ static int zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 	adapter = (struct zfcp_adapter *) scpnt->device->host->hostdata[0];
 	unit = scpnt->device->hostdata;
 
-	BUG_ON(!adapter || (adapter != unit->port->adapter));
-	BUG_ON(!scpnt->scsi_done);
-
-	if (unlikely(!unit)) {
-		zfcp_scsi_command_fail(scpnt, DID_NO_CONNECT);
-		return 0;
-	}
-
 	scsi_result = fc_remote_port_chkready(rport);
 	if (unlikely(scsi_result)) {
 		scpnt->result = scsi_result;

commit b6bd2fb92a7bb9f1f3feecd9945c21e6c227dd51
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Wed Feb 17 11:18:50 2010 +0100

    [SCSI] zfcp: Move FSF request tracking code to new file
    
    Move the code for tracking FSF requests to new file to have this code
    in one place. The functions for adding and removing requests on the
    I/O path are already inline. The alloc and free functions are only
    called once, so it does not hurt to inline them and add them to the
    same file.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 8e6fc68d6bd4..e1e56f523116 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -15,6 +15,7 @@
 #include "zfcp_ext.h"
 #include "zfcp_dbf.h"
 #include "zfcp_fc.h"
+#include "zfcp_reqlist.h"
 
 static unsigned int default_depth = 32;
 module_param_named(queue_depth, default_depth, uint, 0600);
@@ -189,9 +190,7 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	/* avoid race condition between late normal completion and abort */
 	write_lock_irqsave(&adapter->abort_lock, flags);
 
-	spin_lock(&adapter->req_list_lock);
-	old_req = zfcp_reqlist_find(adapter, old_reqid);
-	spin_unlock(&adapter->req_list_lock);
+	old_req = zfcp_reqlist_find(adapter->req_list, old_reqid);
 	if (!old_req) {
 		write_unlock_irqrestore(&adapter->abort_lock, flags);
 		zfcp_dbf_scsi_abort("lte1", adapter->dbf, scpnt, NULL,

commit 491ca4426ba153f79e72d1ca2a30c926484282b7
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Thu Jan 14 17:19:01 2010 +0100

    [SCSI] zfcp: Introduce bsg_timeout callback.
    
    Introduce a zfcp callback for timeouts triggered from FC BSG.  With
    zfcp, the underlying hardware cannot abort CT or ELS requests, so
    there is nothing to do when the block layer timeout expires.  To avoid
    interference with the block layer timeout, simply indicate that the
    block layer timer should be reset. The timer running in the hardware
    for the pending CT or ELS request will return the request when it
    expires.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 771cc536a989..8e6fc68d6bd4 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -652,6 +652,7 @@ struct fc_function_template zfcp_transport_functions = {
 	.show_host_port_state = 1,
 	.show_host_active_fc4s = 1,
 	.bsg_request = zfcp_fc_exec_bsg_job,
+	.bsg_timeout = zfcp_fc_timeout_bsg_job,
 	/* no functions registered for following dynamic attributes but
 	   directly set by LLDD */
 	.show_host_port_type = 1,

commit 54987386ee3790f3900de4df2ed4deb0e18dfc9f
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue Nov 24 16:54:18 2009 +0100

    [SCSI] zfcp: Remove flag ZFCP_STATUS_FSFREQ_TMFUNCNOTSUPP
    
    The flag ZFCP_STATUS_FSFREQ_TMFUNCNOTSUPP is never set and hence can
    be removed. This is a leftover from the time when zfcp had to decide
    whether the target supports a "logical unit reset" or not. Nowadays,
    the SCSI midlayer calls the eh_device_reset_handler or the
    eh_target_reset_handler and zfcp simply maps this to a "logical unit
    reset" or a "target reset".
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 72bb9bcf7356..771cc536a989 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -264,9 +264,6 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 	if (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCFAILED) {
 		zfcp_dbf_scsi_devreset("fail", tm_flags, unit, scpnt);
 		retval = FAILED;
-	} else if (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCNOTSUPP) {
-		zfcp_dbf_scsi_devreset("nsup", tm_flags, unit, scpnt);
-		retval = FAILED;
 	} else
 		zfcp_dbf_scsi_devreset("okay", tm_flags, unit, scpnt);
 

commit 0fdd21330a9d7bc6790eae0aed768052c315ae44
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue Nov 24 16:54:17 2009 +0100

    [SCSI] zfcp: Activate fc4s attributes for zfcp in FC transport class
    
    Enable the display of supported and active fc4s for zfcp in the FC
    transport class. zfcp only supports FCP, so simply hard-code this
    information.  The zfcp hbaapi already has this information hardcoded,
    but this would allow to switch from the coding in the zfcp hbaapi to
    the common FC transport attributes in the future.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 3f1011663af5..72bb9bcf7356 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -643,6 +643,7 @@ struct fc_function_template zfcp_transport_functions = {
 	.show_host_port_name = 1,
 	.show_host_permanent_port_name = 1,
 	.show_host_supported_classes = 1,
+	.show_host_supported_fc4s = 1,
 	.show_host_supported_speeds = 1,
 	.show_host_maxframe_size = 1,
 	.show_host_serial_number = 1,
@@ -652,6 +653,7 @@ struct fc_function_template zfcp_transport_functions = {
 	.get_host_port_state = zfcp_get_host_port_state,
 	.terminate_rport_io = zfcp_scsi_terminate_rport_io,
 	.show_host_port_state = 1,
+	.show_host_active_fc4s = 1,
 	.bsg_request = zfcp_fc_exec_bsg_job,
 	/* no functions registered for following dynamic attributes but
 	   directly set by LLDD */

commit af4de36d911ab907b92c5f3f81ceff8474ed7485
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue Nov 24 16:54:16 2009 +0100

    [SCSI] zfcp: Block scsi_eh thread for rport state BLOCKED
    
    In case the SCSI error recovery starts because of a SCSI command
    timeout, but then something else triggers the rport to be deleted, the
    SCSI error recovery will run to the end and set the SCSI device
    offline. To prevent this, call the FC transport function
    fc_block_scsi_eh which waits until the rport leaves the BLOCKED state.
    This guarantees that communication is possible if the rport is ONLINE,
    or the SCSI devices will be removed if the rport state switches to
    NOT_PRESENT.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 535f36cf2819..3f1011663af5 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -209,6 +209,7 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 			break;
 
 		zfcp_erp_wait(adapter);
+		fc_block_scsi_eh(scpnt);
 		if (!(atomic_read(&adapter->status) &
 		      ZFCP_STATUS_COMMON_RUNNING)) {
 			zfcp_dbf_scsi_abort("nres", adapter->dbf, scpnt, NULL,
@@ -248,6 +249,7 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 			break;
 
 		zfcp_erp_wait(adapter);
+		fc_block_scsi_eh(scpnt);
 		if (!(atomic_read(&adapter->status) &
 		      ZFCP_STATUS_COMMON_RUNNING)) {
 			zfcp_dbf_scsi_devreset("nres", tm_flags, unit, scpnt);
@@ -289,6 +291,7 @@ static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 
 	zfcp_erp_adapter_reopen(adapter, 0, "schrh_1", scpnt);
 	zfcp_erp_wait(adapter);
+	fc_block_scsi_eh(scpnt);
 
 	return SUCCESS;
 }

commit 7c7dc196814b9e1d5cc254dc579a5fa78ae524f7
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue Nov 24 16:54:13 2009 +0100

    [SCSI] zfcp: Simplify handling of ct and els requests
    
    Remove some redundancies in FC related code and trace:
    - drop redundant data from SAN trace (local s_id that only changes
      during link down, ls_code that is already part of payload, d_id in
      ct response trace that is always the same as in ct request trace)
    - use one common fsf struct to hold zfcp data for ct and els requests
    - leverage common fsf struct for FC passthrough job data, allocate it
      with dd_bsg_data for passthrough requests and unify common code for
      ct and els passthrough request
    - simplify callback handling in zfcp_fc
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 3d168410036b..535f36cf2819 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -14,6 +14,7 @@
 #include <asm/atomic.h>
 #include "zfcp_ext.h"
 #include "zfcp_dbf.h"
+#include "zfcp_fc.h"
 
 static unsigned int default_depth = 32;
 module_param_named(queue_depth, default_depth, uint, 0600);
@@ -628,20 +629,6 @@ void zfcp_scsi_scan(struct work_struct *work)
 	put_device(&unit->sysfs_device);
 }
 
-static int zfcp_execute_fc_job(struct fc_bsg_job *job)
-{
-	switch (job->request->msgcode) {
-	case FC_BSG_RPT_ELS:
-	case FC_BSG_HST_ELS_NOLOGIN:
-		return zfcp_fc_execute_els_fc_job(job);
-	case FC_BSG_RPT_CT:
-	case FC_BSG_HST_CT:
-		return zfcp_fc_execute_ct_fc_job(job);
-	default:
-		return -EINVAL;
-	}
-}
-
 struct fc_function_template zfcp_transport_functions = {
 	.show_starget_port_id = 1,
 	.show_starget_port_name = 1,
@@ -662,13 +649,14 @@ struct fc_function_template zfcp_transport_functions = {
 	.get_host_port_state = zfcp_get_host_port_state,
 	.terminate_rport_io = zfcp_scsi_terminate_rport_io,
 	.show_host_port_state = 1,
-	.bsg_request = zfcp_execute_fc_job,
+	.bsg_request = zfcp_fc_exec_bsg_job,
 	/* no functions registered for following dynamic attributes but
 	   directly set by LLDD */
 	.show_host_port_type = 1,
 	.show_host_speed = 1,
 	.show_host_port_id = 1,
 	.disable_target_scan = 1,
+	.dd_bsg_size = sizeof(struct zfcp_fsf_ct_els),
 };
 
 struct zfcp_data zfcp_data = {

commit 4318e08c84e4916ac463002ffb7f9901ddb3c385
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue Nov 24 16:54:08 2009 +0100

    [SCSI] zfcp: Update FCP protocol related code
    
    Use common data structures for FCP CMND, FCP RSP and related
    definitions and remove zfcp private definitions. Split the FCP CMND
    setup and FCP RSP evaluation code in seperate functions. Use inline
    functions to not negatively impact the I/O path.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 0ecec9c1b490..3d168410036b 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -9,6 +9,8 @@
 #define KMSG_COMPONENT "zfcp"
 #define pr_fmt(fmt) KMSG_COMPONENT ": " fmt
 
+#include <linux/types.h>
+#include <scsi/fc/fc_fcp.h>
 #include <asm/atomic.h>
 #include "zfcp_ext.h"
 #include "zfcp_dbf.h"
@@ -17,18 +19,6 @@ static unsigned int default_depth = 32;
 module_param_named(queue_depth, default_depth, uint, 0600);
 MODULE_PARM_DESC(queue_depth, "Default queue depth for new SCSI devices");
 
-/* Find start of Sense Information in FCP response unit*/
-char *zfcp_get_fcp_sns_info_ptr(struct fcp_rsp_iu *fcp_rsp_iu)
-{
-	char *fcp_sns_info_ptr;
-
-	fcp_sns_info_ptr = (unsigned char *) &fcp_rsp_iu[1];
-	if (fcp_rsp_iu->validity.bits.fcp_rsp_len_valid)
-		fcp_sns_info_ptr += fcp_rsp_iu->fcp_rsp_len;
-
-	return fcp_sns_info_ptr;
-}
-
 static int zfcp_scsi_change_queue_depth(struct scsi_device *sdev, int depth,
 					int reason)
 {
@@ -283,12 +273,12 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 
 static int zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)
 {
-	return zfcp_task_mgmt_function(scpnt, FCP_LOGICAL_UNIT_RESET);
+	return zfcp_task_mgmt_function(scpnt, FCP_TMF_LUN_RESET);
 }
 
 static int zfcp_scsi_eh_target_reset_handler(struct scsi_cmnd *scpnt)
 {
-	return zfcp_task_mgmt_function(scpnt, FCP_TARGET_RESET);
+	return zfcp_task_mgmt_function(scpnt, FCP_TMF_TGT_RESET);
 }
 
 static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
@@ -325,7 +315,7 @@ int zfcp_adapter_scsi_register(struct zfcp_adapter *adapter)
 	adapter->scsi_host->max_lun = 1;
 	adapter->scsi_host->max_channel = 0;
 	adapter->scsi_host->unique_id = dev_id.devno;
-	adapter->scsi_host->max_cmd_len = 255;
+	adapter->scsi_host->max_cmd_len = 16; /* in struct fcp_cmnd */
 	adapter->scsi_host->transportt = zfcp_data.scsi_transport_template;
 
 	adapter->scsi_host->hostdata[0] = (unsigned long) adapter;

commit 8830271c4819d86d8e87202a1fe8da0bb58912a2
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue Nov 24 16:54:07 2009 +0100

    [SCSI] zfcp: Dont fail SCSI commands when transitioning to blocked fc_rport
    
    If an error occurs that triggers the call to fc_remote_port_delete,
    ideally this call would happen before any I/O is passed back to the
    SCSI midlayer through scsi_done. The SCSI midlayer will retry the
    commands and fc_remote_port_chkready will return the correct status
    code.  But with the delay between calling scsi_done in softirq context
    and the call to fc_remote_port_delete from the workqueue, there is a
    window where zfcp returns DID_ERROR. This leads to SCSI error recovery
    which then leads to offline SCSI devices since all recovery actions
    will fail with the rport now being blocked.
    
    In this window, zfcp has to return DID_IMM_RETRY just as the FC
    transport class would do in fc_remote_port_chkready for the blocked
    fc_rport. As soon as the fc_rport is BLOCKED, fc_remote_port_chkready
    will do the right thing.
    
    Additionally, there are two more cases to catch in zfcp_scsi_queuecommand:
    - After the port has been opened, the unit has to be opened. During
      this period I/O has to be retried. This can also be handled with
      DID_IMM_RETRY.
    - If the access to the unit fails, but the port is good, then
      this single unit cannot be accessed and I/O to this unit has to fail
      without involving the FC transport class.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 39a621d729e9..0ecec9c1b490 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -112,12 +112,26 @@ static int zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 	}
 
 	status = atomic_read(&unit->status);
-	if (unlikely((status & ZFCP_STATUS_COMMON_ERP_FAILED) ||
-		     !(status & ZFCP_STATUS_COMMON_RUNNING))) {
+	if (unlikely(status & ZFCP_STATUS_COMMON_ERP_FAILED) &&
+		     !(atomic_read(&unit->port->status) &
+		       ZFCP_STATUS_COMMON_ERP_FAILED)) {
+		/* only unit access denied, but port is good
+		 * not covered by FC transport, have to fail here */
 		zfcp_scsi_command_fail(scpnt, DID_ERROR);
 		return 0;
 	}
 
+	if (unlikely(!(status & ZFCP_STATUS_COMMON_UNBLOCKED))) {
+		/* This could be either
+		 * open unit pending: this is temporary, will result in
+		 * 	open unit or ERP_FAILED, so retry command
+		 * call to rport_delete pending: mimic retry from
+		 * 	fc_remote_port_chkready until rport is BLOCKED
+		 */
+		zfcp_scsi_command_fail(scpnt, DID_IMM_RETRY);
+		return 0;
+	}
+
 	ret = zfcp_fsf_send_fcp_command_task(unit, scpnt);
 	if (unlikely(ret == -EBUSY))
 		return SCSI_MLQUEUE_DEVICE_BUSY;

commit f3450c7b917201bb49d67032e9f60d5125675d6a
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Tue Nov 24 16:53:59 2009 +0100

    [SCSI] zfcp: Replace local reference counting with common kref
    
    Replace the local reference counting by already available mechanisms
    offered by kref. Where possible existing device structures were used,
    including the same functionality.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 6feece3b2e36..39a621d729e9 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -52,7 +52,7 @@ static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 {
 	struct zfcp_unit *unit = (struct zfcp_unit *) sdpnt->hostdata;
 	unit->device = NULL;
-	zfcp_unit_put(unit);
+	put_device(&unit->sysfs_device);
 }
 
 static int zfcp_scsi_slave_configure(struct scsi_device *sdp)
@@ -335,8 +335,7 @@ void zfcp_adapter_scsi_unregister(struct zfcp_adapter *adapter)
 
 	read_lock_irq(&adapter->port_list_lock);
 	list_for_each_entry(port, &adapter->port_list, list)
-		if (port->rport)
-			port->rport = NULL;
+		port->rport = NULL;
 	read_unlock_irq(&adapter->port_list_lock);
 
 	fc_remove_host(shost);
@@ -356,7 +355,7 @@ zfcp_init_fc_host_stats(struct zfcp_adapter *adapter)
 		fc_stats = kmalloc(sizeof(*fc_stats), GFP_KERNEL);
 		if (!fc_stats)
 			return NULL;
-		adapter->fc_stats = fc_stats; /* freed in adater_dequeue */
+		adapter->fc_stats = fc_stats; /* freed in adapter_release */
 	}
 	memset(adapter->fc_stats, 0, sizeof(*adapter->fc_stats));
 	return adapter->fc_stats;
@@ -472,7 +471,7 @@ static void zfcp_reset_fc_host_stats(struct Scsi_Host *shost)
 		adapter->stats_reset = jiffies/HZ;
 		kfree(adapter->stats_reset_data);
 		adapter->stats_reset_data = data; /* finally freed in
-						     adapter_dequeue */
+						     adapter_release */
 	}
 }
 
@@ -517,7 +516,7 @@ static void zfcp_scsi_terminate_rport_io(struct fc_rport *rport)
 
 	if (port) {
 		zfcp_erp_port_reopen(port, 0, "sctrpi1", NULL);
-		zfcp_port_put(port);
+		put_device(&port->sysfs_device);
 	}
 }
 
@@ -559,23 +558,23 @@ static void zfcp_scsi_rport_block(struct zfcp_port *port)
 
 void zfcp_scsi_schedule_rport_register(struct zfcp_port *port)
 {
-	zfcp_port_get(port);
+	get_device(&port->sysfs_device);
 	port->rport_task = RPORT_ADD;
 
 	if (!queue_work(port->adapter->work_queue, &port->rport_work))
-		zfcp_port_put(port);
+		put_device(&port->sysfs_device);
 }
 
 void zfcp_scsi_schedule_rport_block(struct zfcp_port *port)
 {
-	zfcp_port_get(port);
+	get_device(&port->sysfs_device);
 	port->rport_task = RPORT_DEL;
 
 	if (port->rport && queue_work(port->adapter->work_queue,
 				      &port->rport_work))
 		return;
 
-	zfcp_port_put(port);
+	put_device(&port->sysfs_device);
 }
 
 void zfcp_scsi_schedule_rports_block(struct zfcp_adapter *adapter)
@@ -604,7 +603,7 @@ void zfcp_scsi_rport_work(struct work_struct *work)
 		}
 	}
 
-	zfcp_port_put(port);
+	put_device(&port->sysfs_device);
 }
 
 
@@ -622,7 +621,7 @@ void zfcp_scsi_scan(struct work_struct *work)
 				 scsilun_to_int((struct scsi_lun *)
 						&unit->fcp_lun), 0);
 
-	zfcp_unit_put(unit);
+	put_device(&unit->sysfs_device);
 }
 
 static int zfcp_execute_fc_job(struct fc_bsg_job *job)

commit ecf0c7721b104c0ce9c8ca534c911f6310cf92a8
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Tue Nov 24 16:53:58 2009 +0100

    [SCSI] zfcp: Replace global config_lock with local list locks
    
    The global config_lock was used to protect the configuration organized
    in independent lists. It is not necessary to have a lock on driver
    level for this purpose.  This patch replaces the global config_lock
    with a set of local list locks.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index f54655998bd5..6feece3b2e36 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -128,49 +128,44 @@ static int zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 }
 
 static struct zfcp_unit *zfcp_unit_lookup(struct zfcp_adapter *adapter,
-					  int channel, unsigned int id,
-					  unsigned int lun)
+					  unsigned int id, u64 lun)
 {
+	unsigned long flags;
 	struct zfcp_port *port;
-	struct zfcp_unit *unit;
-	int scsi_lun;
+	struct zfcp_unit *unit = NULL;
 
-	list_for_each_entry(port, &adapter->port_list_head, list) {
+	read_lock_irqsave(&adapter->port_list_lock, flags);
+	list_for_each_entry(port, &adapter->port_list, list) {
 		if (!port->rport || (id != port->rport->scsi_target_id))
 			continue;
-		list_for_each_entry(unit, &port->unit_list_head, list) {
-			scsi_lun = scsilun_to_int(
-				(struct scsi_lun *)&unit->fcp_lun);
-			if (lun == scsi_lun)
-				return unit;
-		}
+		unit = zfcp_get_unit_by_lun(port, lun);
+		if (unit)
+			break;
 	}
+	read_unlock_irqrestore(&adapter->port_list_lock, flags);
 
-	return NULL;
+	return unit;
 }
 
 static int zfcp_scsi_slave_alloc(struct scsi_device *sdp)
 {
 	struct zfcp_adapter *adapter;
 	struct zfcp_unit *unit;
-	unsigned long flags;
-	int retval = -ENXIO;
+	u64 lun;
 
 	adapter = (struct zfcp_adapter *) sdp->host->hostdata[0];
 	if (!adapter)
 		goto out;
 
-	read_lock_irqsave(&zfcp_data.config_lock, flags);
-	unit = zfcp_unit_lookup(adapter, sdp->channel, sdp->id, sdp->lun);
+	int_to_scsilun(sdp->lun, (struct scsi_lun *)&lun);
+	unit = zfcp_unit_lookup(adapter, sdp->id, lun);
 	if (unit) {
 		sdp->hostdata = unit;
 		unit->device = sdp;
-		zfcp_unit_get(unit);
-		retval = 0;
+		return 0;
 	}
-	read_unlock_irqrestore(&zfcp_data.config_lock, flags);
 out:
-	return retval;
+	return -ENXIO;
 }
 
 static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
@@ -338,12 +333,12 @@ void zfcp_adapter_scsi_unregister(struct zfcp_adapter *adapter)
 	if (!shost)
 		return;
 
-	read_lock_irq(&zfcp_data.config_lock);
-	list_for_each_entry(port, &adapter->port_list_head, list)
+	read_lock_irq(&adapter->port_list_lock);
+	list_for_each_entry(port, &adapter->port_list, list)
 		if (port->rport)
 			port->rport = NULL;
+	read_unlock_irq(&adapter->port_list_lock);
 
-	read_unlock_irq(&zfcp_data.config_lock);
 	fc_remove_host(shost);
 	scsi_remove_host(shost);
 	scsi_host_put(shost);
@@ -508,7 +503,7 @@ static void zfcp_set_rport_dev_loss_tmo(struct fc_rport *rport, u32 timeout)
  * @rport: The FC rport where to teminate I/O
  *
  * Abort all pending SCSI commands for a port by closing the
- * port. Using a reopen for avoids a conflict with a shutdown
+ * port. Using a reopen avoiding a conflict with a shutdown
  * overwriting a reopen.
  */
 static void zfcp_scsi_terminate_rport_io(struct fc_rport *rport)
@@ -518,11 +513,7 @@ static void zfcp_scsi_terminate_rport_io(struct fc_rport *rport)
 	struct zfcp_adapter *adapter =
 		(struct zfcp_adapter *)shost->hostdata[0];
 
-	write_lock_irq(&zfcp_data.config_lock);
 	port = zfcp_get_port_by_wwpn(adapter, rport->port_name);
-	if (port)
-		zfcp_port_get(port);
-	write_unlock_irq(&zfcp_data.config_lock);
 
 	if (port) {
 		zfcp_erp_port_reopen(port, 0, "sctrpi1", NULL);
@@ -589,10 +580,13 @@ void zfcp_scsi_schedule_rport_block(struct zfcp_port *port)
 
 void zfcp_scsi_schedule_rports_block(struct zfcp_adapter *adapter)
 {
+	unsigned long flags;
 	struct zfcp_port *port;
 
-	list_for_each_entry(port, &adapter->port_list_head, list)
+	read_lock_irqsave(&adapter->port_list_lock, flags);
+	list_for_each_entry(port, &adapter->port_list, list)
 		zfcp_scsi_schedule_rport_block(port);
+	read_unlock_irqrestore(&adapter->port_list_lock, flags);
 }
 
 void zfcp_scsi_rport_work(struct work_struct *work)

commit 42e62a74377bcbb526565a31aa18da8f712b93ee
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Thu Oct 15 17:47:11 2009 -0700

    [SCSI] zfcp: Adapt change_queue_depth for queue full tracking
    
    Adapt the change_queue_depth callback in zfcp for the new reason
    parameter. Simply pass each call back to the SCSI midlayer, there are
    no resource adjustments necessary for zfcp.
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    
    Removes check for (depth <= default_depth) in case of
    SCSI_QDEPTH_RAMP_UP call back, not needed after added
    max_queue_depth per sdev.
    
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index ad1154701729..f54655998bd5 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -32,10 +32,19 @@ char *zfcp_get_fcp_sns_info_ptr(struct fcp_rsp_iu *fcp_rsp_iu)
 static int zfcp_scsi_change_queue_depth(struct scsi_device *sdev, int depth,
 					int reason)
 {
-	if (reason != SCSI_QDEPTH_DEFAULT)
+	switch (reason) {
+	case SCSI_QDEPTH_DEFAULT:
+		scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);
+		break;
+	case SCSI_QDEPTH_QFULL:
+		scsi_track_queue_full(sdev, depth);
+		break;
+	case SCSI_QDEPTH_RAMP_UP:
+		scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);
+		break;
+	default:
 		return -EOPNOTSUPP;
-
-	scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);
+	}
 	return sdev->queue_depth;
 }
 

commit e881a172dac4d9ea3b2a1540041d872963c269bd
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Thu Oct 15 17:46:39 2009 -0700

    [SCSI] modify change_queue_depth to take in reason why it is being called
    
    This patch modifies scsi_host_template->change_queue_depth so that
    it takes an argument indicating why it is being called. This will be
    used so that if a LLD needs to do some extra processing when
    handling queue fulls or later ramp ups, it can do so.
    
    This is a simple port of the drivers setting a change_queue_depth
    callback. In the patch I just have these LLDs adjust the queue depth
    if the user was requesting it.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    
    [Vasu.Dev: v2
            Also converted pmcraid_change_queue_depth and then verified
    all modules compile  using "make allmodconfig" for any new build
    warnings on X86_64.
    
            Updated original description after combing two original
    patches from Mike to make this patch git bisectable.]
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    [jejb: fixed up 53c700]
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 0e1a34627a2e..ad1154701729 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -29,8 +29,12 @@ char *zfcp_get_fcp_sns_info_ptr(struct fcp_rsp_iu *fcp_rsp_iu)
 	return fcp_sns_info_ptr;
 }
 
-static int zfcp_scsi_change_queue_depth(struct scsi_device *sdev, int depth)
+static int zfcp_scsi_change_queue_depth(struct scsi_device *sdev, int depth,
+					int reason)
 {
+	if (reason != SCSI_QDEPTH_DEFAULT)
+		return -EOPNOTSUPP;
+
 	scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);
 	return sdev->queue_depth;
 }

commit a419aef8b858a2bdb98df60336063d28df4b272f
Author: Joe Perches <joe@perches.com>
Date:   Tue Aug 18 11:18:35 2009 -0700

    trivial: remove unnecessary semicolons
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 3ff726afafc6..0e1a34627a2e 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -102,7 +102,7 @@ static int zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 	if (unlikely((status & ZFCP_STATUS_COMMON_ERP_FAILED) ||
 		     !(status & ZFCP_STATUS_COMMON_RUNNING))) {
 		zfcp_scsi_command_fail(scpnt, DID_ERROR);
-		return 0;;
+		return 0;
 	}
 
 	ret = zfcp_fsf_send_fcp_command_task(unit, scpnt);

commit ea945ff84c2ce1089edb7914ffdd998c24c25903
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Tue Aug 18 15:43:24 2009 +0200

    [SCSI] zfcp: resolve false usage of dd_data in fc_rport
    
    The fc_rport structure reserves a reference where a LLD can put
    information required in a situation where the fc transport class is
    triggering LLD callbacks. The zfcp driver was using this variable
    directly which is discouraged. This patch solves this issue by making
    this reference unnecessary.  In addition the dev_loss_tmo callback is
    removed, it is not required: zfcp does not access the fc_rport after
    calling fc_remote_port_delete.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index b6177ad2d5bf..3ff726afafc6 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -490,21 +490,6 @@ static void zfcp_set_rport_dev_loss_tmo(struct fc_rport *rport, u32 timeout)
 	rport->dev_loss_tmo = timeout;
 }
 
-/**
- * zfcp_scsi_dev_loss_tmo_callbk - Free any reference to rport
- * @rport: The rport that is about to be deleted.
- */
-static void zfcp_scsi_dev_loss_tmo_callbk(struct fc_rport *rport)
-{
-	struct zfcp_port *port;
-
-	write_lock_irq(&zfcp_data.config_lock);
-	port = rport->dd_data;
-	if (port)
-		port->rport = NULL;
-	write_unlock_irq(&zfcp_data.config_lock);
-}
-
 /**
  * zfcp_scsi_terminate_rport_io - Terminate all I/O on a rport
  * @rport: The FC rport where to teminate I/O
@@ -516,9 +501,12 @@ static void zfcp_scsi_dev_loss_tmo_callbk(struct fc_rport *rport)
 static void zfcp_scsi_terminate_rport_io(struct fc_rport *rport)
 {
 	struct zfcp_port *port;
+	struct Scsi_Host *shost = rport_to_shost(rport);
+	struct zfcp_adapter *adapter =
+		(struct zfcp_adapter *)shost->hostdata[0];
 
 	write_lock_irq(&zfcp_data.config_lock);
-	port = rport->dd_data;
+	port = zfcp_get_port_by_wwpn(adapter, rport->port_name);
 	if (port)
 		zfcp_port_get(port);
 	write_unlock_irq(&zfcp_data.config_lock);
@@ -550,7 +538,6 @@ static void zfcp_scsi_rport_register(struct zfcp_port *port)
 		return;
 	}
 
-	rport->dd_data = port;
 	rport->maxframe_size = port->maxframe_size;
 	rport->supported_classes = port->supported_classes;
 	port->rport = rport;
@@ -663,7 +650,6 @@ struct fc_function_template zfcp_transport_functions = {
 	.reset_fc_host_stats = zfcp_reset_fc_host_stats,
 	.set_rport_dev_loss_tmo = zfcp_set_rport_dev_loss_tmo,
 	.get_host_port_state = zfcp_get_host_port_state,
-	.dev_loss_tmo_callbk = zfcp_scsi_dev_loss_tmo_callbk,
 	.terminate_rport_io = zfcp_scsi_terminate_rport_io,
 	.show_host_port_state = 1,
 	.bsg_request = zfcp_execute_fc_job,

commit 5771710bd5edfafcb8656f49b93690a6fae5a4d2
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Tue Aug 18 15:43:21 2009 +0200

    [SCSI] zfcp: Update dbf calls
    
    Change the dbf data and functions to use the zfcp_dbf prefix
    throughout the code. Also change the calls to dbf to use zfcp_dbf
    instead of zfcp_adapter.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 4414720c87f6..b6177ad2d5bf 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -53,11 +53,11 @@ static int zfcp_scsi_slave_configure(struct scsi_device *sdp)
 
 static void zfcp_scsi_command_fail(struct scsi_cmnd *scpnt, int result)
 {
+	struct zfcp_adapter *adapter =
+		(struct zfcp_adapter *) scpnt->device->host->hostdata[0];
 	set_host_byte(scpnt, result);
 	if ((scpnt->device != NULL) && (scpnt->device->host != NULL))
-		zfcp_scsi_dbf_event_result("fail", 4,
-			(struct zfcp_adapter*) scpnt->device->host->hostdata[0],
-			scpnt, NULL);
+		zfcp_dbf_scsi_result("fail", 4, adapter->dbf, scpnt, NULL);
 	/* return directly */
 	scpnt->scsi_done(scpnt);
 }
@@ -93,7 +93,7 @@ static int zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 	scsi_result = fc_remote_port_chkready(rport);
 	if (unlikely(scsi_result)) {
 		scpnt->result = scsi_result;
-		zfcp_scsi_dbf_event_result("fail", 4, adapter, scpnt, NULL);
+		zfcp_dbf_scsi_result("fail", 4, adapter->dbf, scpnt, NULL);
 		scpnt->scsi_done(scpnt);
 		return 0;
 	}
@@ -181,8 +181,8 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	spin_unlock(&adapter->req_list_lock);
 	if (!old_req) {
 		write_unlock_irqrestore(&adapter->abort_lock, flags);
-		zfcp_scsi_dbf_event_abort("lte1", adapter, scpnt, NULL,
-					  old_reqid);
+		zfcp_dbf_scsi_abort("lte1", adapter->dbf, scpnt, NULL,
+				    old_reqid);
 		return FAILED; /* completion could be in progress */
 	}
 	old_req->data = NULL;
@@ -198,8 +198,8 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 		zfcp_erp_wait(adapter);
 		if (!(atomic_read(&adapter->status) &
 		      ZFCP_STATUS_COMMON_RUNNING)) {
-			zfcp_scsi_dbf_event_abort("nres", adapter, scpnt, NULL,
-						  old_reqid);
+			zfcp_dbf_scsi_abort("nres", adapter->dbf, scpnt, NULL,
+					    old_reqid);
 			return SUCCESS;
 		}
 	}
@@ -216,7 +216,7 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 		dbf_tag = "fail";
 		retval = FAILED;
 	}
-	zfcp_scsi_dbf_event_abort(dbf_tag, adapter, scpnt, abrt_req, old_reqid);
+	zfcp_dbf_scsi_abort(dbf_tag, adapter->dbf, scpnt, abrt_req, old_reqid);
 	zfcp_fsf_req_free(abrt_req);
 	return retval;
 }
@@ -237,8 +237,7 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 		zfcp_erp_wait(adapter);
 		if (!(atomic_read(&adapter->status) &
 		      ZFCP_STATUS_COMMON_RUNNING)) {
-			zfcp_scsi_dbf_event_devreset("nres", tm_flags, unit,
-						     scpnt);
+			zfcp_dbf_scsi_devreset("nres", tm_flags, unit, scpnt);
 			return SUCCESS;
 		}
 	}
@@ -248,13 +247,13 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 	wait_for_completion(&fsf_req->completion);
 
 	if (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCFAILED) {
-		zfcp_scsi_dbf_event_devreset("fail", tm_flags, unit, scpnt);
+		zfcp_dbf_scsi_devreset("fail", tm_flags, unit, scpnt);
 		retval = FAILED;
 	} else if (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCNOTSUPP) {
-		zfcp_scsi_dbf_event_devreset("nsup", tm_flags, unit, scpnt);
+		zfcp_dbf_scsi_devreset("nsup", tm_flags, unit, scpnt);
 		retval = FAILED;
 	} else
-		zfcp_scsi_dbf_event_devreset("okay", tm_flags, unit, scpnt);
+		zfcp_dbf_scsi_devreset("okay", tm_flags, unit, scpnt);
 
 	zfcp_fsf_req_free(fsf_req);
 	return retval;

commit 564e1c86c810f9ccfe4300afa402815e3db4886d
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Tue Aug 18 15:43:19 2009 +0200

    [SCSI] zfcp: Move qdio related data out of zfcp_adapter
    
    The zfcp_adapter structure was growing over time to a size of almost
    one memory page. To reduce the size of the data structure and to
    seperate different layers, put all qdio related data in the new
    zfcp_qdio data structure.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 2e13d41269a4..4414720c87f6 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -225,7 +225,7 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 {
 	struct zfcp_unit *unit = scpnt->device->hostdata;
 	struct zfcp_adapter *adapter = unit->port->adapter;
-	struct zfcp_fsf_req *fsf_req;
+	struct zfcp_fsf_req *fsf_req = NULL;
 	int retval = SUCCESS;
 	int retry = 3;
 
@@ -429,7 +429,7 @@ static struct fc_host_statistics *zfcp_get_fc_host_stats(struct Scsi_Host *host)
 	if (!data)
 		return NULL;
 
-	ret = zfcp_fsf_exchange_port_data_sync(adapter, data);
+	ret = zfcp_fsf_exchange_port_data_sync(adapter->qdio, data);
 	if (ret) {
 		kfree(data);
 		return NULL;
@@ -458,7 +458,7 @@ static void zfcp_reset_fc_host_stats(struct Scsi_Host *shost)
 	if (!data)
 		return;
 
-	ret = zfcp_fsf_exchange_port_data_sync(adapter, data);
+	ret = zfcp_fsf_exchange_port_data_sync(adapter->qdio, data);
 	if (ret)
 		kfree(data);
 	else {

commit 4544683a4b1d4e65ccca8c736bac56a195a5206b
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Tue Aug 18 15:43:17 2009 +0200

    [SCSI] zfcp: Move workqueue to adapter struct
    
    Remove the global driver work queue and replace it with a workqueue
    local to the adapter. The usage of this workqueue makes this the
    correct place for the structure. In addition multiple adapters won't
    block each other due to the serialization of the queued work.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 0de059161b35..2e13d41269a4 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -572,7 +572,7 @@ void zfcp_scsi_schedule_rport_register(struct zfcp_port *port)
 	zfcp_port_get(port);
 	port->rport_task = RPORT_ADD;
 
-	if (!queue_work(zfcp_data.work_queue, &port->rport_work))
+	if (!queue_work(port->adapter->work_queue, &port->rport_work))
 		zfcp_port_put(port);
 }
 
@@ -581,7 +581,8 @@ void zfcp_scsi_schedule_rport_block(struct zfcp_port *port)
 	zfcp_port_get(port);
 	port->rport_task = RPORT_DEL;
 
-	if (port->rport && queue_work(zfcp_data.work_queue, &port->rport_work))
+	if (port->rport && queue_work(port->adapter->work_queue,
+				      &port->rport_work))
 		return;
 
 	zfcp_port_put(port);

commit 058b8647892ed49ba6a0d2c0966a72e20e2e69ff
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Tue Aug 18 15:43:14 2009 +0200

    [SCSI] zfcp: Replace fsf_req wait_queue with completion
    
    The combination wait_queue/wakeup in conjunction with the flag
    ZFCP_STATUS_FSFREQ_COMPLETED to signal the completion of an fsfreq
    was not race-safe and can be better solved by a completion.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 0bd80a90426a..0de059161b35 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -206,8 +206,7 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	if (!abrt_req)
 		return FAILED;
 
-	wait_event(abrt_req->completion_wq,
-		   abrt_req->status & ZFCP_STATUS_FSFREQ_COMPLETED);
+	wait_for_completion(&abrt_req->completion);
 
 	if (abrt_req->status & ZFCP_STATUS_FSFREQ_ABORTSUCCEEDED)
 		dbf_tag = "okay";
@@ -246,8 +245,7 @@ static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 	if (!fsf_req)
 		return FAILED;
 
-	wait_event(fsf_req->completion_wq,
-		   fsf_req->status & ZFCP_STATUS_FSFREQ_COMPLETED);
+	wait_for_completion(&fsf_req->completion);
 
 	if (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCFAILED) {
 		zfcp_scsi_dbf_event_devreset("fail", tm_flags, unit, scpnt);

commit dcd20e2316cdc333dfdee09649dbe3642eb30e75
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue Aug 18 15:43:08 2009 +0200

    [SCSI] zfcp: Only collect SCSI debug data for matching trace levels
    
    The default trace level is to only trace failed SCSI commands. Thus it
    is not necessary to collect trace data for most SCSI commands since it
    will be thrown away later. Restructure the SCSI trace infrastructure
    to first check the trace level in a inline function and only do the
    expensive data collection for matching trace levels.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 54a7a7474aa5..0bd80a90426a 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -9,8 +9,9 @@
 #define KMSG_COMPONENT "zfcp"
 #define pr_fmt(fmt) KMSG_COMPONENT ": " fmt
 
-#include "zfcp_ext.h"
 #include <asm/atomic.h>
+#include "zfcp_ext.h"
+#include "zfcp_dbf.h"
 
 static unsigned int default_depth = 32;
 module_param_named(queue_depth, default_depth, uint, 0600);

commit a67417ab7eeff45bba55666c0e1083260f3624ee
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Tue Aug 18 15:43:06 2009 +0200

    [SCSI] zfcp: invalid usage after free of port resources
    
    In certain error scenarios ports, rports are getting attached,
    validated and removed from the systems environment. Depending on the
    layer this occurs asynchronously. This patch fixes the few races
    which existed and ensures all references and cross references are
    cleared at the time they're invalid. In addition fc transports
    actions are only scheduled when required.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 6925a1784682..54a7a7474aa5 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -582,8 +582,10 @@ void zfcp_scsi_schedule_rport_block(struct zfcp_port *port)
 	zfcp_port_get(port);
 	port->rport_task = RPORT_DEL;
 
-	if (!queue_work(zfcp_data.work_queue, &port->rport_work))
-		zfcp_port_put(port);
+	if (port->rport && queue_work(zfcp_data.work_queue, &port->rport_work))
+		return;
+
+	zfcp_port_put(port);
 }
 
 void zfcp_scsi_schedule_rports_block(struct zfcp_adapter *adapter)

commit a11a52be115889a5d1f738ed2e154807bceed4ee
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Mon Jul 13 15:06:14 2009 +0200

    [SCSI] zfcp: Fix tracing of request id for abort requests
    
    The trace record for SCSI abort requests has a field for the request
    id of the request to be aborted. Put the real request id instead of
    zero.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index ba32709921a4..6925a1784682 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -167,20 +167,21 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	struct zfcp_unit *unit = scpnt->device->hostdata;
 	struct zfcp_fsf_req *old_req, *abrt_req;
 	unsigned long flags;
-	unsigned long old_req_id = (unsigned long) scpnt->host_scribble;
+	unsigned long old_reqid = (unsigned long) scpnt->host_scribble;
 	int retval = SUCCESS;
 	int retry = 3;
+	char *dbf_tag;
 
 	/* avoid race condition between late normal completion and abort */
 	write_lock_irqsave(&adapter->abort_lock, flags);
 
 	spin_lock(&adapter->req_list_lock);
-	old_req = zfcp_reqlist_find(adapter, old_req_id);
+	old_req = zfcp_reqlist_find(adapter, old_reqid);
 	spin_unlock(&adapter->req_list_lock);
 	if (!old_req) {
 		write_unlock_irqrestore(&adapter->abort_lock, flags);
 		zfcp_scsi_dbf_event_abort("lte1", adapter, scpnt, NULL,
-					  old_req_id);
+					  old_reqid);
 		return FAILED; /* completion could be in progress */
 	}
 	old_req->data = NULL;
@@ -189,7 +190,7 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	write_unlock_irqrestore(&adapter->abort_lock, flags);
 
 	while (retry--) {
-		abrt_req = zfcp_fsf_abort_fcp_command(old_req_id, unit);
+		abrt_req = zfcp_fsf_abort_fcp_command(old_reqid, unit);
 		if (abrt_req)
 			break;
 
@@ -197,7 +198,7 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 		if (!(atomic_read(&adapter->status) &
 		      ZFCP_STATUS_COMMON_RUNNING)) {
 			zfcp_scsi_dbf_event_abort("nres", adapter, scpnt, NULL,
-						  old_req_id);
+						  old_reqid);
 			return SUCCESS;
 		}
 	}
@@ -208,13 +209,14 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 		   abrt_req->status & ZFCP_STATUS_FSFREQ_COMPLETED);
 
 	if (abrt_req->status & ZFCP_STATUS_FSFREQ_ABORTSUCCEEDED)
-		zfcp_scsi_dbf_event_abort("okay", adapter, scpnt, abrt_req, 0);
+		dbf_tag = "okay";
 	else if (abrt_req->status & ZFCP_STATUS_FSFREQ_ABORTNOTNEEDED)
-		zfcp_scsi_dbf_event_abort("lte2", adapter, scpnt, abrt_req, 0);
+		dbf_tag = "lte2";
 	else {
-		zfcp_scsi_dbf_event_abort("fail", adapter, scpnt, abrt_req, 0);
+		dbf_tag = "fail";
 		retval = FAILED;
 	}
+	zfcp_scsi_dbf_event_abort(dbf_tag, adapter, scpnt, abrt_req, old_reqid);
 	zfcp_fsf_req_free(abrt_req);
 	return retval;
 }

commit 379d6bf6573ee6541a38bbe9140c1f0b94e3feae
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Mon Jul 13 15:06:11 2009 +0200

    [SCSI] zfcp: Add port only once to FC transport class
    
    When calling fc_remote_port_add make sure to not call it again before
    fc_remote_port_delete has been called. In other words, ensure to
    create a new fc_rport, then delete it, then create a new one again.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 967ede73f4c5..ba32709921a4 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -534,6 +534,9 @@ static void zfcp_scsi_rport_register(struct zfcp_port *port)
 	struct fc_rport_identifiers ids;
 	struct fc_rport *rport;
 
+	if (port->rport)
+		return;
+
 	ids.node_name = port->wwnn;
 	ids.port_name = port->wwpn;
 	ids.port_id = port->d_id;
@@ -557,8 +560,10 @@ static void zfcp_scsi_rport_block(struct zfcp_port *port)
 {
 	struct fc_rport *rport = port->rport;
 
-	if (rport)
+	if (rport) {
 		fc_remote_port_delete(rport);
+		port->rport = NULL;
+	}
 }
 
 void zfcp_scsi_schedule_rport_register(struct zfcp_port *port)

commit 9d544f2b9bd4a0f7ba2784cc47e3591667a7b8d4
Author: Sven Schuetz <sven@linux.vnet.ibm.com>
Date:   Mon Apr 6 18:31:47 2009 +0200

    [SCSI] zfcp: Add FC pass-through support
    
    Provide the ability to do fibre channel requests from the userspace to
    our zfcp driver.  Patch builds upon extension to the fibre channel
    tranport class by James Smart and Seokmann Ju.  See here
    http://marc.info/?l=linux-scsi&m=123808882309133&w=2
    
    Signed-off-by: Sven Schuetz <sven@linux.vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 7d0da230eb63..967ede73f4c5 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -623,6 +623,20 @@ void zfcp_scsi_scan(struct work_struct *work)
 	zfcp_unit_put(unit);
 }
 
+static int zfcp_execute_fc_job(struct fc_bsg_job *job)
+{
+	switch (job->request->msgcode) {
+	case FC_BSG_RPT_ELS:
+	case FC_BSG_HST_ELS_NOLOGIN:
+		return zfcp_fc_execute_els_fc_job(job);
+	case FC_BSG_RPT_CT:
+	case FC_BSG_HST_CT:
+		return zfcp_fc_execute_ct_fc_job(job);
+	default:
+		return -EINVAL;
+	}
+}
+
 struct fc_function_template zfcp_transport_functions = {
 	.show_starget_port_id = 1,
 	.show_starget_port_name = 1,
@@ -644,6 +658,7 @@ struct fc_function_template zfcp_transport_functions = {
 	.dev_loss_tmo_callbk = zfcp_scsi_dev_loss_tmo_callbk,
 	.terminate_rport_io = zfcp_scsi_terminate_rport_io,
 	.show_host_port_state = 1,
+	.bsg_request = zfcp_execute_fc_job,
 	/* no functions registered for following dynamic attributes but
 	   directly set by LLDD */
 	.show_host_port_type = 1,

commit a40a1bafe7da0afe61b1c20fc50e18c07ce724f9
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Fri May 15 13:18:16 2009 +0200

    [SCSI] zfcp: Make queue_depth adjustable
    
    zfcp did always set the queue_depth for SCSI devices to 32, not
    allowing to change this. Introduce a kernel parameter zfcp.queue_depth
    and the change_queue_depth callback to allow changing the queue_depth
    when it is required.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index e8fbeaeb5fbf..7d0da230eb63 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -12,6 +12,10 @@
 #include "zfcp_ext.h"
 #include <asm/atomic.h>
 
+static unsigned int default_depth = 32;
+module_param_named(queue_depth, default_depth, uint, 0600);
+MODULE_PARM_DESC(queue_depth, "Default queue depth for new SCSI devices");
+
 /* Find start of Sense Information in FCP response unit*/
 char *zfcp_get_fcp_sns_info_ptr(struct fcp_rsp_iu *fcp_rsp_iu)
 {
@@ -24,6 +28,12 @@ char *zfcp_get_fcp_sns_info_ptr(struct fcp_rsp_iu *fcp_rsp_iu)
 	return fcp_sns_info_ptr;
 }
 
+static int zfcp_scsi_change_queue_depth(struct scsi_device *sdev, int depth)
+{
+	scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);
+	return sdev->queue_depth;
+}
+
 static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 {
 	struct zfcp_unit *unit = (struct zfcp_unit *) sdpnt->hostdata;
@@ -34,7 +44,7 @@ static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 static int zfcp_scsi_slave_configure(struct scsi_device *sdp)
 {
 	if (sdp->tagged_supported)
-		scsi_adjust_queue_depth(sdp, MSG_SIMPLE_TAG, 32);
+		scsi_adjust_queue_depth(sdp, MSG_SIMPLE_TAG, default_depth);
 	else
 		scsi_adjust_queue_depth(sdp, 0, 1);
 	return 0;
@@ -647,6 +657,7 @@ struct zfcp_data zfcp_data = {
 		.name			 = "zfcp",
 		.module			 = THIS_MODULE,
 		.proc_name		 = "zfcp",
+		.change_queue_depth	 = zfcp_scsi_change_queue_depth,
 		.slave_alloc		 = zfcp_scsi_slave_alloc,
 		.slave_configure	 = zfcp_scsi_slave_configure,
 		.slave_destroy		 = zfcp_scsi_slave_destroy,

commit 70932935b61ee3dcc5a419ec4c367feb2ff808e4
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Fri Apr 17 15:08:15 2009 +0200

    [SCSI] zfcp: Fix oops when port disappears
    
    The zfcp_port might have been removed, while the FC fast_io_fail timer
    is still running and could trigger the terminate_rport_io callback.
    Set the pointer to the zfcp_port to NULL and check accordingly
    before using it.
    
    Reviewed-by: Martin Petermann <martin@linux.vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index e7d065209065..e8fbeaeb5fbf 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -486,10 +486,12 @@ static void zfcp_set_rport_dev_loss_tmo(struct fc_rport *rport, u32 timeout)
  */
 static void zfcp_scsi_dev_loss_tmo_callbk(struct fc_rport *rport)
 {
-	struct zfcp_port *port = rport->dd_data;
+	struct zfcp_port *port;
 
 	write_lock_irq(&zfcp_data.config_lock);
-	port->rport = NULL;
+	port = rport->dd_data;
+	if (port)
+		port->rport = NULL;
 	write_unlock_irq(&zfcp_data.config_lock);
 }
 
@@ -503,9 +505,18 @@ static void zfcp_scsi_dev_loss_tmo_callbk(struct fc_rport *rport)
  */
 static void zfcp_scsi_terminate_rport_io(struct fc_rport *rport)
 {
-	struct zfcp_port *port = rport->dd_data;
+	struct zfcp_port *port;
+
+	write_lock_irq(&zfcp_data.config_lock);
+	port = rport->dd_data;
+	if (port)
+		zfcp_port_get(port);
+	write_unlock_irq(&zfcp_data.config_lock);
 
-	zfcp_erp_port_reopen(port, 0, "sctrpi1", NULL);
+	if (port) {
+		zfcp_erp_port_reopen(port, 0, "sctrpi1", NULL);
+		zfcp_port_put(port);
+	}
 }
 
 static void zfcp_scsi_rport_register(struct zfcp_port *port)
@@ -534,8 +545,10 @@ static void zfcp_scsi_rport_register(struct zfcp_port *port)
 
 static void zfcp_scsi_rport_block(struct zfcp_port *port)
 {
-	if (port->rport)
-		fc_remote_port_delete(port->rport);
+	struct fc_rport *rport = port->rport;
+
+	if (rport)
+		fc_remote_port_delete(rport);
 }
 
 void zfcp_scsi_schedule_rport_register(struct zfcp_port *port)

commit c6936e7f34383db2f5038dfa2f0c168ebc2920e5
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Fri Apr 17 15:08:11 2009 +0200

    [SCSI] zfcp: Fix abort handler for completions in progress
    
    When the abort handler cannot find a pending FSF request, the request
    completion could just be running. This means we cannot return SUCCESS,
    since this would lead to call to scsi_done after exiting the SCSI
    error handler which is not allowed.
    
    Reviewed-by: Martin Petermann <martin@linux.vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 5b11386d70bb..e7d065209065 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -171,7 +171,7 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 		write_unlock_irqrestore(&adapter->abort_lock, flags);
 		zfcp_scsi_dbf_event_abort("lte1", adapter, scpnt, NULL,
 					  old_req_id);
-		return SUCCESS;
+		return FAILED; /* completion could be in progress */
 	}
 	old_req->data = NULL;
 

commit 92d5193b467c68e8432d6878980621c787e735af
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Fri Apr 17 15:08:04 2009 +0200

    [SCSI] zfcp: Dont block zfcp_wq with scan
    
    When running the scsi_scan from the zfcp workqueue and the target
    device does not respond, the zfcp workqueue can block until the
    scsi_scan hits a timeout. Move the work to the scsi host workqueue,
    since this one is also used for the scan from the SCSI midlayer.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 58201e1ae478..5b11386d70bb 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -583,6 +583,23 @@ void zfcp_scsi_rport_work(struct work_struct *work)
 }
 
 
+void zfcp_scsi_scan(struct work_struct *work)
+{
+	struct zfcp_unit *unit = container_of(work, struct zfcp_unit,
+					      scsi_work);
+	struct fc_rport *rport;
+
+	flush_work(&unit->port->rport_work);
+	rport = unit->port->rport;
+
+	if (rport && rport->port_state == FC_PORTSTATE_ONLINE)
+		scsi_scan_target(&rport->dev, 0, rport->scsi_target_id,
+				 scsilun_to_int((struct scsi_lun *)
+						&unit->fcp_lun), 0);
+
+	zfcp_unit_put(unit);
+}
+
 struct fc_function_template zfcp_transport_functions = {
 	.show_starget_port_id = 1,
 	.show_starget_port_name = 1,

commit 2cb5b2ca6dddcdfb0e220f18b4612890a23a1c92
Author: Martin Petermann <martin@linux.vnet.ibm.com>
Date:   Mon Mar 2 13:09:09 2009 +0100

    [SCSI] zfcp: erp failed status bit will not be set
    
    It will not be necessary to set the erp failed status bit
    in case a SCSI device is removed by the SCSI mid layer.
    In the case a SCSI device is unavailable for a short time
    (15 to 20 seconds) a FCP unit will not get on-line again.
    
    Signed-off-by: Martin Petermann <martin@linux.vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 7141f9a675df..58201e1ae478 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -28,7 +28,6 @@ static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 {
 	struct zfcp_unit *unit = (struct zfcp_unit *) sdpnt->hostdata;
 	unit->device = NULL;
-	zfcp_erp_unit_failed(unit, "scslvd1", NULL);
 	zfcp_unit_put(unit);
 }
 

commit a2fa0aede07c9488239dcac1eae58233181c355a
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Mon Mar 2 13:09:08 2009 +0100

    [SCSI] zfcp: Block FC transport rports early on errors
    
    Use the I/O blocking mechanism in the FC transport class to allow
    faster failovers for multipathing:
    - Call fc_remote_port_delete early to set the rport to BLOCKED.
    - Check the rport status in queuecommand with fc_remote_portchkready
      to no longer accept new I/O for this port and fail the I/O with the
      appropriate scsi_cmnd result.
    - Implement the terminate_rport_io handler to abort all pending I/O
      requests
    - Return SCSI commands with DID_TRANSPORT_DISRUPTED while erp is
      running.
    - When updating the remote port status, check for late changes and
      update the remote ports status accordingly.
    
    Acked-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 2af8cfbc3890..7141f9a675df 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -3,7 +3,7 @@
  *
  * Interface to Linux SCSI midlayer.
  *
- * Copyright IBM Corporation 2002, 2008
+ * Copyright IBM Corporation 2002, 2009
  */
 
 #define KMSG_COMPONENT "zfcp"
@@ -57,8 +57,8 @@ static int zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 {
 	struct zfcp_unit *unit;
 	struct zfcp_adapter *adapter;
-	int    status;
-	int    ret;
+	int    status, scsi_result, ret;
+	struct fc_rport *rport = starget_to_rport(scsi_target(scpnt->device));
 
 	/* reset the status for this request */
 	scpnt->result = 0;
@@ -80,6 +80,14 @@ static int zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 		return 0;
 	}
 
+	scsi_result = fc_remote_port_chkready(rport);
+	if (unlikely(scsi_result)) {
+		scpnt->result = scsi_result;
+		zfcp_scsi_dbf_event_result("fail", 4, adapter, scpnt, NULL);
+		scpnt->scsi_done(scpnt);
+		return 0;
+	}
+
 	status = atomic_read(&unit->status);
 	if (unlikely((status & ZFCP_STATUS_COMMON_ERP_FAILED) ||
 		     !(status & ZFCP_STATUS_COMMON_RUNNING))) {
@@ -473,6 +481,109 @@ static void zfcp_set_rport_dev_loss_tmo(struct fc_rport *rport, u32 timeout)
 	rport->dev_loss_tmo = timeout;
 }
 
+/**
+ * zfcp_scsi_dev_loss_tmo_callbk - Free any reference to rport
+ * @rport: The rport that is about to be deleted.
+ */
+static void zfcp_scsi_dev_loss_tmo_callbk(struct fc_rport *rport)
+{
+	struct zfcp_port *port = rport->dd_data;
+
+	write_lock_irq(&zfcp_data.config_lock);
+	port->rport = NULL;
+	write_unlock_irq(&zfcp_data.config_lock);
+}
+
+/**
+ * zfcp_scsi_terminate_rport_io - Terminate all I/O on a rport
+ * @rport: The FC rport where to teminate I/O
+ *
+ * Abort all pending SCSI commands for a port by closing the
+ * port. Using a reopen for avoids a conflict with a shutdown
+ * overwriting a reopen.
+ */
+static void zfcp_scsi_terminate_rport_io(struct fc_rport *rport)
+{
+	struct zfcp_port *port = rport->dd_data;
+
+	zfcp_erp_port_reopen(port, 0, "sctrpi1", NULL);
+}
+
+static void zfcp_scsi_rport_register(struct zfcp_port *port)
+{
+	struct fc_rport_identifiers ids;
+	struct fc_rport *rport;
+
+	ids.node_name = port->wwnn;
+	ids.port_name = port->wwpn;
+	ids.port_id = port->d_id;
+	ids.roles = FC_RPORT_ROLE_FCP_TARGET;
+
+	rport = fc_remote_port_add(port->adapter->scsi_host, 0, &ids);
+	if (!rport) {
+		dev_err(&port->adapter->ccw_device->dev,
+			"Registering port 0x%016Lx failed\n",
+			(unsigned long long)port->wwpn);
+		return;
+	}
+
+	rport->dd_data = port;
+	rport->maxframe_size = port->maxframe_size;
+	rport->supported_classes = port->supported_classes;
+	port->rport = rport;
+}
+
+static void zfcp_scsi_rport_block(struct zfcp_port *port)
+{
+	if (port->rport)
+		fc_remote_port_delete(port->rport);
+}
+
+void zfcp_scsi_schedule_rport_register(struct zfcp_port *port)
+{
+	zfcp_port_get(port);
+	port->rport_task = RPORT_ADD;
+
+	if (!queue_work(zfcp_data.work_queue, &port->rport_work))
+		zfcp_port_put(port);
+}
+
+void zfcp_scsi_schedule_rport_block(struct zfcp_port *port)
+{
+	zfcp_port_get(port);
+	port->rport_task = RPORT_DEL;
+
+	if (!queue_work(zfcp_data.work_queue, &port->rport_work))
+		zfcp_port_put(port);
+}
+
+void zfcp_scsi_schedule_rports_block(struct zfcp_adapter *adapter)
+{
+	struct zfcp_port *port;
+
+	list_for_each_entry(port, &adapter->port_list_head, list)
+		zfcp_scsi_schedule_rport_block(port);
+}
+
+void zfcp_scsi_rport_work(struct work_struct *work)
+{
+	struct zfcp_port *port = container_of(work, struct zfcp_port,
+					      rport_work);
+
+	while (port->rport_task) {
+		if (port->rport_task == RPORT_ADD) {
+			port->rport_task = RPORT_NONE;
+			zfcp_scsi_rport_register(port);
+		} else {
+			port->rport_task = RPORT_NONE;
+			zfcp_scsi_rport_block(port);
+		}
+	}
+
+	zfcp_port_put(port);
+}
+
+
 struct fc_function_template zfcp_transport_functions = {
 	.show_starget_port_id = 1,
 	.show_starget_port_name = 1,
@@ -491,6 +602,8 @@ struct fc_function_template zfcp_transport_functions = {
 	.reset_fc_host_stats = zfcp_reset_fc_host_stats,
 	.set_rport_dev_loss_tmo = zfcp_set_rport_dev_loss_tmo,
 	.get_host_port_state = zfcp_get_host_port_state,
+	.dev_loss_tmo_callbk = zfcp_scsi_dev_loss_tmo_callbk,
+	.terminate_rport_io = zfcp_scsi_terminate_rport_io,
 	.show_host_port_state = 1,
 	/* no functions registered for following dynamic attributes but
 	   directly set by LLDD */

commit 5ffd51a5e495a2a002efd523aef0001912b080bd
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Mon Mar 2 13:09:04 2009 +0100

    [SCSI] zfcp: replace current ERP logging with a more convenient version
    
    The current number based id ERP logging is replaced by a string
    based tag version. The benefit is an easier location of the code in
    question and the removal of the lengthy array referencing the
    individual messages.
    The string (7 bytes) based version does not use more space since those
    bytes were "used" anyway due to the alignment of the structure.
    The encoding of the 7 byte string is as follows
            [0-1] = filename
            [2-5] = task/function
            [6]   = section
    Due to the character of this string (fixed length) a string
    termination is not required here.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index c17505f767a9..2af8cfbc3890 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -28,7 +28,7 @@ static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 {
 	struct zfcp_unit *unit = (struct zfcp_unit *) sdpnt->hostdata;
 	unit->device = NULL;
-	zfcp_erp_unit_failed(unit, 12, NULL);
+	zfcp_erp_unit_failed(unit, "scslvd1", NULL);
 	zfcp_unit_put(unit);
 }
 
@@ -257,7 +257,7 @@ static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 	struct zfcp_unit *unit = scpnt->device->hostdata;
 	struct zfcp_adapter *adapter = unit->port->adapter;
 
-	zfcp_erp_adapter_reopen(adapter, 0, 141, scpnt);
+	zfcp_erp_adapter_reopen(adapter, 0, "schrh_1", scpnt);
 	zfcp_erp_wait(adapter);
 
 	return SUCCESS;

commit 63caf367e1c92e0667a344d9b687c04e6ef054b5
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Mon Mar 2 13:09:00 2009 +0100

    [SCSI] zfcp: Improve reliability of SCSI eh handlers in zfcp
    
    When the SCSI midlayer is running error recovery, the low-level error
    recovery in zfcp could be running and preventing the SCSI midlayer to
    issue error recovery requests. To avoid unnecessary error recovery
    escalation, wait for the zfcp erp to finish and retry if necessary.
    
    While reworking the SCSI eh handlers, alsa cleanup the code and
    simplify the interface from zfcp_scsi to the fsf layer.
    
    Acked-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 7829c72d83d0..c17505f767a9 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -87,8 +87,7 @@ static int zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 		return 0;;
 	}
 
-	ret = zfcp_fsf_send_fcp_command_task(adapter, unit, scpnt, 0,
-					     ZFCP_REQ_AUTO_CLEANUP);
+	ret = zfcp_fsf_send_fcp_command_task(unit, scpnt);
 	if (unlikely(ret == -EBUSY))
 		return SCSI_MLQUEUE_DEVICE_BUSY;
 	else if (unlikely(ret < 0))
@@ -145,79 +144,91 @@ static int zfcp_scsi_slave_alloc(struct scsi_device *sdp)
 
 static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 {
- 	struct Scsi_Host *scsi_host;
- 	struct zfcp_adapter *adapter;
-	struct zfcp_unit *unit;
-	struct zfcp_fsf_req *fsf_req;
+	struct Scsi_Host *scsi_host = scpnt->device->host;
+	struct zfcp_adapter *adapter =
+		(struct zfcp_adapter *) scsi_host->hostdata[0];
+	struct zfcp_unit *unit = scpnt->device->hostdata;
+	struct zfcp_fsf_req *old_req, *abrt_req;
 	unsigned long flags;
 	unsigned long old_req_id = (unsigned long) scpnt->host_scribble;
 	int retval = SUCCESS;
-
-	scsi_host = scpnt->device->host;
-	adapter = (struct zfcp_adapter *) scsi_host->hostdata[0];
-	unit = scpnt->device->hostdata;
+	int retry = 3;
 
 	/* avoid race condition between late normal completion and abort */
 	write_lock_irqsave(&adapter->abort_lock, flags);
 
-	/* Check whether corresponding fsf_req is still pending */
 	spin_lock(&adapter->req_list_lock);
-	fsf_req = zfcp_reqlist_find(adapter, old_req_id);
+	old_req = zfcp_reqlist_find(adapter, old_req_id);
 	spin_unlock(&adapter->req_list_lock);
-	if (!fsf_req) {
+	if (!old_req) {
 		write_unlock_irqrestore(&adapter->abort_lock, flags);
-		zfcp_scsi_dbf_event_abort("lte1", adapter, scpnt, NULL, 0);
-		return retval;
+		zfcp_scsi_dbf_event_abort("lte1", adapter, scpnt, NULL,
+					  old_req_id);
+		return SUCCESS;
 	}
-	fsf_req->data = NULL;
+	old_req->data = NULL;
 
 	/* don't access old fsf_req after releasing the abort_lock */
 	write_unlock_irqrestore(&adapter->abort_lock, flags);
 
-	fsf_req = zfcp_fsf_abort_fcp_command(old_req_id, adapter, unit, 0);
-	if (!fsf_req) {
-		zfcp_scsi_dbf_event_abort("nres", adapter, scpnt, NULL,
-					  old_req_id);
-		retval = FAILED;
-		return retval;
+	while (retry--) {
+		abrt_req = zfcp_fsf_abort_fcp_command(old_req_id, unit);
+		if (abrt_req)
+			break;
+
+		zfcp_erp_wait(adapter);
+		if (!(atomic_read(&adapter->status) &
+		      ZFCP_STATUS_COMMON_RUNNING)) {
+			zfcp_scsi_dbf_event_abort("nres", adapter, scpnt, NULL,
+						  old_req_id);
+			return SUCCESS;
+		}
 	}
+	if (!abrt_req)
+		return FAILED;
 
-	__wait_event(fsf_req->completion_wq,
-		     fsf_req->status & ZFCP_STATUS_FSFREQ_COMPLETED);
+	wait_event(abrt_req->completion_wq,
+		   abrt_req->status & ZFCP_STATUS_FSFREQ_COMPLETED);
 
-	if (fsf_req->status & ZFCP_STATUS_FSFREQ_ABORTSUCCEEDED) {
-		zfcp_scsi_dbf_event_abort("okay", adapter, scpnt, fsf_req, 0);
-	} else if (fsf_req->status & ZFCP_STATUS_FSFREQ_ABORTNOTNEEDED) {
-		zfcp_scsi_dbf_event_abort("lte2", adapter, scpnt, fsf_req, 0);
-	} else {
-		zfcp_scsi_dbf_event_abort("fail", adapter, scpnt, fsf_req, 0);
+	if (abrt_req->status & ZFCP_STATUS_FSFREQ_ABORTSUCCEEDED)
+		zfcp_scsi_dbf_event_abort("okay", adapter, scpnt, abrt_req, 0);
+	else if (abrt_req->status & ZFCP_STATUS_FSFREQ_ABORTNOTNEEDED)
+		zfcp_scsi_dbf_event_abort("lte2", adapter, scpnt, abrt_req, 0);
+	else {
+		zfcp_scsi_dbf_event_abort("fail", adapter, scpnt, abrt_req, 0);
 		retval = FAILED;
 	}
-	zfcp_fsf_req_free(fsf_req);
-
+	zfcp_fsf_req_free(abrt_req);
 	return retval;
 }
 
-static int zfcp_task_mgmt_function(struct zfcp_unit *unit, u8 tm_flags,
-					 struct scsi_cmnd *scpnt)
+static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)
 {
+	struct zfcp_unit *unit = scpnt->device->hostdata;
 	struct zfcp_adapter *adapter = unit->port->adapter;
 	struct zfcp_fsf_req *fsf_req;
 	int retval = SUCCESS;
-
-	/* issue task management function */
-	fsf_req = zfcp_fsf_send_fcp_ctm(adapter, unit, tm_flags, 0);
-	if (!fsf_req) {
-		zfcp_scsi_dbf_event_devreset("nres", tm_flags, unit, scpnt);
-		return FAILED;
+	int retry = 3;
+
+	while (retry--) {
+		fsf_req = zfcp_fsf_send_fcp_ctm(unit, tm_flags);
+		if (fsf_req)
+			break;
+
+		zfcp_erp_wait(adapter);
+		if (!(atomic_read(&adapter->status) &
+		      ZFCP_STATUS_COMMON_RUNNING)) {
+			zfcp_scsi_dbf_event_devreset("nres", tm_flags, unit,
+						     scpnt);
+			return SUCCESS;
+		}
 	}
+	if (!fsf_req)
+		return FAILED;
 
-	__wait_event(fsf_req->completion_wq,
-		     fsf_req->status & ZFCP_STATUS_FSFREQ_COMPLETED);
+	wait_event(fsf_req->completion_wq,
+		   fsf_req->status & ZFCP_STATUS_FSFREQ_COMPLETED);
 
-	/*
-	 * check completion status of task management function
-	 */
 	if (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCFAILED) {
 		zfcp_scsi_dbf_event_devreset("fail", tm_flags, unit, scpnt);
 		retval = FAILED;
@@ -228,39 +239,24 @@ static int zfcp_task_mgmt_function(struct zfcp_unit *unit, u8 tm_flags,
 		zfcp_scsi_dbf_event_devreset("okay", tm_flags, unit, scpnt);
 
 	zfcp_fsf_req_free(fsf_req);
-
 	return retval;
 }
 
 static int zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)
 {
-	struct zfcp_unit *unit = scpnt->device->hostdata;
-
-	if (!unit) {
-		WARN_ON(1);
-		return SUCCESS;
-	}
-	return zfcp_task_mgmt_function(unit, FCP_LOGICAL_UNIT_RESET, scpnt);
+	return zfcp_task_mgmt_function(scpnt, FCP_LOGICAL_UNIT_RESET);
 }
 
 static int zfcp_scsi_eh_target_reset_handler(struct scsi_cmnd *scpnt)
 {
-	struct zfcp_unit *unit = scpnt->device->hostdata;
-
-	if (!unit) {
-		WARN_ON(1);
-		return SUCCESS;
-	}
-	return zfcp_task_mgmt_function(unit, FCP_TARGET_RESET, scpnt);
+	return zfcp_task_mgmt_function(scpnt, FCP_TARGET_RESET);
 }
 
 static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 {
-	struct zfcp_unit *unit;
-	struct zfcp_adapter *adapter;
+	struct zfcp_unit *unit = scpnt->device->hostdata;
+	struct zfcp_adapter *adapter = unit->port->adapter;
 
-	unit = scpnt->device->hostdata;
-	adapter = unit->port->adapter;
 	zfcp_erp_adapter_reopen(adapter, 0, 141, scpnt);
 	zfcp_erp_wait(adapter);
 

commit 86f8a1b4b472e4b2b58df5826709d4797d84d46f
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Mon Mar 2 13:08:55 2009 +0100

    [SCSI] zfcp: Remove UNIT_REGISTERED status flag
    
    Use the device pointer in zfcp_unit for tracking if we have a
    registered SCSI device. With this approach, the flag
    ZFCP_STATUS_UNIT_REGISTERED is only redundant and can be removed.
    
    Acked-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 9dc42a68fbdd..7829c72d83d0 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -27,7 +27,6 @@ char *zfcp_get_fcp_sns_info_ptr(struct fcp_rsp_iu *fcp_rsp_iu)
 static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 {
 	struct zfcp_unit *unit = (struct zfcp_unit *) sdpnt->hostdata;
-	atomic_clear_mask(ZFCP_STATUS_UNIT_REGISTERED, &unit->status);
 	unit->device = NULL;
 	zfcp_erp_unit_failed(unit, 12, NULL);
 	zfcp_unit_put(unit);
@@ -133,8 +132,7 @@ static int zfcp_scsi_slave_alloc(struct scsi_device *sdp)
 
 	read_lock_irqsave(&zfcp_data.config_lock, flags);
 	unit = zfcp_unit_lookup(adapter, sdp->channel, sdp->id, sdp->lun);
-	if (unit &&
-	    (atomic_read(&unit->status) & ZFCP_STATUS_UNIT_REGISTERED)) {
+	if (unit) {
 		sdp->hostdata = unit;
 		unit->device = sdp;
 		zfcp_unit_get(unit);

commit ecf39d42129767c0b4b4a6cf4997c1219c860934
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Thu Dec 25 13:39:53 2008 +0100

    [S390] convert zfcp printks to pr_xxx macros.
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 468c880f8b6d..9dc42a68fbdd 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -6,6 +6,9 @@
  * Copyright IBM Corporation 2002, 2008
  */
 
+#define KMSG_COMPONENT "zfcp"
+#define pr_fmt(fmt) KMSG_COMPONENT ": " fmt
+
 #include "zfcp_ext.h"
 #include <asm/atomic.h>
 

commit f7a65e92e4bef3ccf9e008ed8cd52d914b6a4adb
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Thu Nov 27 11:44:07 2008 +0100

    [SCSI] zfcp: prevent double decrement on host_busy while being busy
    
    The zfcp_scsi_queuecommand was not acting according to the standard
    when the respective unit was not available. In this case an -EBUSY was
    returned, which is not valid in itself, and in addition scsi_done
    was called. This combination is not allowed and was leading to a
    double finish of the request and therefor double decrement of the
    host_busy counter.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index e46fd3e9f68f..468c880f8b6d 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -88,7 +88,7 @@ static int zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 	ret = zfcp_fsf_send_fcp_command_task(adapter, unit, scpnt, 0,
 					     ZFCP_REQ_AUTO_CLEANUP);
 	if (unlikely(ret == -EBUSY))
-		zfcp_scsi_command_fail(scpnt, DID_NO_CONNECT);
+		return SCSI_MLQUEUE_DEVICE_BUSY;
 	else if (unlikely(ret < 0))
 		return SCSI_MLQUEUE_HOST_BUSY;
 

commit 26816f1c2bf59a269917815adb1d972b9fb65e3a
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue Nov 4 16:35:05 2008 +0100

    [SCSI] zfcp: Dont clear reference from SCSI device to unit
    
    It is possible that a remote port has a problem, the SCSI device gets
    deleted after the rport timeout and then the timeout for pending SCSI
    commands trigger an abort. For this case, don't delete the reference
    from the SCSI device to the zfcp unit, so that we can still have the
    reference to issue an abort request.
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index ca8f85f3dad4..e46fd3e9f68f 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -24,14 +24,10 @@ char *zfcp_get_fcp_sns_info_ptr(struct fcp_rsp_iu *fcp_rsp_iu)
 static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 {
 	struct zfcp_unit *unit = (struct zfcp_unit *) sdpnt->hostdata;
-	WARN_ON(!unit);
-	if (unit) {
-		atomic_clear_mask(ZFCP_STATUS_UNIT_REGISTERED, &unit->status);
-		sdpnt->hostdata = NULL;
-		unit->device = NULL;
-		zfcp_erp_unit_failed(unit, 12, NULL);
-		zfcp_unit_put(unit);
-	}
+	atomic_clear_mask(ZFCP_STATUS_UNIT_REGISTERED, &unit->status);
+	unit->device = NULL;
+	zfcp_erp_unit_failed(unit, 12, NULL);
+	zfcp_unit_put(unit);
 }
 
 static int zfcp_scsi_slave_configure(struct scsi_device *sdp)

commit 0406289ed57955860a4f8d744a14f4c819260ce4
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Wed Oct 1 12:42:20 2008 +0200

    [SCSI] zfcp: Simplify zfcp data structures
    
    Reduce the size of zfcp data structures by removing unused and
    redundant members. scsi_lun is only the mangled version of the
    fcp_lun. So, remove the redundant field and use the fcp_lun instead.
    
    Since the queue lock and the pci_batch indicator are only used in the
    request queue, move them from the common queue struct to the adapter
    struct.
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index cf6a14793371..ca8f85f3dad4 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -105,13 +105,17 @@ static struct zfcp_unit *zfcp_unit_lookup(struct zfcp_adapter *adapter,
 {
 	struct zfcp_port *port;
 	struct zfcp_unit *unit;
+	int scsi_lun;
 
 	list_for_each_entry(port, &adapter->port_list_head, list) {
 		if (!port->rport || (id != port->rport->scsi_target_id))
 			continue;
-		list_for_each_entry(unit, &port->unit_list_head, list)
-			if (lun == unit->scsi_lun)
+		list_for_each_entry(unit, &port->unit_list_head, list) {
+			scsi_lun = scsilun_to_int(
+				(struct scsi_lun *)&unit->fcp_lun);
+			if (lun == scsi_lun)
 				return unit;
+		}
 	}
 
 	return NULL;

commit 7ba58c9cc16d296290fe645acb11db2b01276544
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Wed Oct 1 12:42:18 2008 +0200

    [SCSI] zfcp: remove all typedefs and replace them with standards
    
    Remove typedefs from zfcp, use already existing types instead.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 2095a1e41e80..cf6a14793371 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -21,20 +21,6 @@ char *zfcp_get_fcp_sns_info_ptr(struct fcp_rsp_iu *fcp_rsp_iu)
 	return fcp_sns_info_ptr;
 }
 
-void zfcp_set_fcp_dl(struct fcp_cmnd_iu *fcp_cmd, fcp_dl_t fcp_dl)
-{
-	fcp_dl_t *fcp_dl_ptr;
-
-	/*
-	 * fcp_dl_addr = start address of fcp_cmnd structure +
-	 * size of fixed part + size of dynamically sized add_dcp_cdb field
-	 * SEE FCP-2 documentation
-	 */
-	fcp_dl_ptr = (fcp_dl_t *) ((unsigned char *) &fcp_cmd[1] +
-				   (fcp_cmd->add_fcp_cdb_length << 2));
-	*fcp_dl_ptr = fcp_dl;
-}
-
 static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 {
 	struct zfcp_unit *unit = (struct zfcp_unit *) sdpnt->hostdata;

commit 44cc76f2d154aa24340354b4711a0fe7f8f08adc
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Wed Oct 1 12:42:16 2008 +0200

    [SCSI] zfcp: remove unused references, declarations and flags
    
     - Remove unused references and declarations, including one instance
       of the FC ls_adisc struct that has been defined twice.
     - Also remove the flags COMMON_OPENING, COMMON_CLOSING,
       ADAPTER_REGISTERED and XPORT_OK that are only set and cleared, but
       not checked anywhere.
     - Remove the zfcp specific atomic_test_mask makro. Simply use
       atomic_read directly instead.
     - Remove the zfcp internal sg helper functions and switch the places
       where it is still used to call sg_virt directly.
     - With the update of the QDIO code, the QDIO data structures no
       longer use the volatile type qualifier. Now we can also remove the
       volatile qualifiers from the zfcp code.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 6348cc5520e1..2095a1e41e80 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -183,7 +183,6 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 		return retval;
 	}
 	fsf_req->data = NULL;
-	fsf_req->status |= ZFCP_STATUS_FSFREQ_ABORTING;
 
 	/* don't access old fsf_req after releasing the abort_lock */
 	write_unlock_irqrestore(&adapter->abort_lock, flags);
@@ -313,7 +312,6 @@ int zfcp_adapter_scsi_register(struct zfcp_adapter *adapter)
 		scsi_host_put(adapter->scsi_host);
 		return -EIO;
 	}
-	atomic_set_mask(ZFCP_STATUS_ADAPTER_REGISTERED, &adapter->status);
 
 	return 0;
 }
@@ -337,7 +335,6 @@ void zfcp_adapter_scsi_unregister(struct zfcp_adapter *adapter)
 	scsi_remove_host(shost);
 	scsi_host_put(shost);
 	adapter->scsi_host = NULL;
-	atomic_clear_mask(ZFCP_STATUS_ADAPTER_REGISTERED, &adapter->status);
 
 	return;
 }

commit ff3b24fa5370a7ca618f212284d9b36fcedb9c0e
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Wed Oct 1 12:42:15 2008 +0200

    [SCSI] zfcp: Update message with input from review
    
    Update the kernel messages in zfcp with input from the message review
    and remove some messages that have been identified as redundant.
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index aeae56b00b45..6348cc5520e1 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -294,7 +294,8 @@ int zfcp_adapter_scsi_register(struct zfcp_adapter *adapter)
 					     sizeof (struct zfcp_adapter *));
 	if (!adapter->scsi_host) {
 		dev_err(&adapter->ccw_device->dev,
-			"registration with SCSI stack failed.");
+			"Registering the FCP device with the "
+			"SCSI stack failed\n");
 		return -EIO;
 	}
 

commit c41f8cbddd4e0e72951e0575165dea8ea26f1c4b
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Wed Jul 2 10:56:39 2008 +0200

    [SCSI] zfcp: zfcp_fsf cleanup.
    
    Code cleanup for the zfcp_fsf.c file.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index e6d8ea8051af..aeae56b00b45 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -182,7 +182,7 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 		zfcp_scsi_dbf_event_abort("lte1", adapter, scpnt, NULL, 0);
 		return retval;
 	}
-	fsf_req->data = 0;
+	fsf_req->data = NULL;
 	fsf_req->status |= ZFCP_STATUS_FSFREQ_ABORTING;
 
 	/* don't access old fsf_req after releasing the abort_lock */
@@ -220,8 +220,7 @@ static int zfcp_task_mgmt_function(struct zfcp_unit *unit, u8 tm_flags,
 	int retval = SUCCESS;
 
 	/* issue task management function */
-	fsf_req = zfcp_fsf_send_fcp_command_task_management
-		(adapter, unit, tm_flags, 0);
+	fsf_req = zfcp_fsf_send_fcp_ctm(adapter, unit, tm_flags, 0);
 	if (!fsf_req) {
 		zfcp_scsi_dbf_event_devreset("nres", tm_flags, unit, scpnt);
 		return FAILED;

commit 60221920706a01bef89af2577f9a90a8eeb4e662
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Wed Jul 2 10:56:38 2008 +0200

    [SCSI] zfcp: consolidate sysfs things into one file.
    
    zfcp was using three files to deal with sysfs representation
    for adapters, ports and units. The consolidation into one file
    prevents code-duplication and eases maintainability.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index f8594a2e3f5c..e6d8ea8051af 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -520,209 +520,6 @@ struct fc_function_template zfcp_transport_functions = {
 	.disable_target_scan = 1,
 };
 
-#define ZFCP_DEFINE_LATENCY_ATTR(_name) 				\
-static ssize_t								\
-zfcp_sysfs_unit_##_name##_latency_show(struct device *dev,		\
-				       struct device_attribute *attr,	\
-				       char *buf) {			\
-	struct scsi_device *sdev = to_scsi_device(dev);			\
-	struct zfcp_unit *unit = sdev->hostdata;			\
-	struct zfcp_latencies *lat = &unit->latencies;			\
-	struct zfcp_adapter *adapter = unit->port->adapter;		\
-	unsigned long flags;						\
-	unsigned long long fsum, fmin, fmax, csum, cmin, cmax, cc;	\
-									\
-	spin_lock_irqsave(&lat->lock, flags);				\
-	fsum = lat->_name.fabric.sum * adapter->timer_ticks;		\
-	fmin = lat->_name.fabric.min * adapter->timer_ticks;		\
-	fmax = lat->_name.fabric.max * adapter->timer_ticks;		\
-	csum = lat->_name.channel.sum * adapter->timer_ticks;		\
-	cmin = lat->_name.channel.min * adapter->timer_ticks;		\
-	cmax = lat->_name.channel.max * adapter->timer_ticks;		\
-	cc  = lat->_name.counter;					\
-	spin_unlock_irqrestore(&lat->lock, flags);			\
-									\
-	do_div(fsum, 1000);						\
-	do_div(fmin, 1000);						\
-	do_div(fmax, 1000);						\
-	do_div(csum, 1000);						\
-	do_div(cmin, 1000);						\
-	do_div(cmax, 1000);						\
-									\
-	return sprintf(buf, "%llu %llu %llu %llu %llu %llu %llu\n",	\
-		       fmin, fmax, fsum, cmin, cmax, csum, cc); 	\
-}									\
-static ssize_t								\
-zfcp_sysfs_unit_##_name##_latency_store(struct device *dev,		\
-					struct device_attribute *attr,	\
-					const char *buf, size_t count)	\
-{									\
-	struct scsi_device *sdev = to_scsi_device(dev);			\
-	struct zfcp_unit *unit = sdev->hostdata;			\
-	struct zfcp_latencies *lat = &unit->latencies;			\
-	unsigned long flags;						\
-									\
-	spin_lock_irqsave(&lat->lock, flags);				\
-	lat->_name.fabric.sum = 0;					\
-	lat->_name.fabric.min = 0xFFFFFFFF;				\
-	lat->_name.fabric.max = 0;					\
-	lat->_name.channel.sum = 0;					\
-	lat->_name.channel.min = 0xFFFFFFFF;				\
-	lat->_name.channel.max = 0;					\
-	lat->_name.counter = 0;						\
-	spin_unlock_irqrestore(&lat->lock, flags);			\
-									\
-	return (ssize_t) count;						\
-}									\
-static DEVICE_ATTR(_name##_latency, S_IWUSR | S_IRUGO,			\
-		   zfcp_sysfs_unit_##_name##_latency_show,		\
-		   zfcp_sysfs_unit_##_name##_latency_store);
-
-ZFCP_DEFINE_LATENCY_ATTR(read);
-ZFCP_DEFINE_LATENCY_ATTR(write);
-ZFCP_DEFINE_LATENCY_ATTR(cmd);
-
-#define ZFCP_DEFINE_SCSI_ATTR(_name, _format, _value)                    \
-static ssize_t zfcp_sysfs_scsi_##_name##_show(struct device *dev, struct device_attribute *attr,        \
-                                              char *buf)                 \
-{                                                                        \
-        struct scsi_device *sdev;                                        \
-        struct zfcp_unit *unit;                                          \
-                                                                         \
-        sdev = to_scsi_device(dev);                                      \
-        unit = sdev->hostdata;                                           \
-        return sprintf(buf, _format, _value);                            \
-}                                                                        \
-                                                                         \
-static DEVICE_ATTR(_name, S_IRUGO, zfcp_sysfs_scsi_##_name##_show, NULL);
-
-ZFCP_DEFINE_SCSI_ATTR(hba_id, "%s\n",
-	unit->port->adapter->ccw_device->dev.bus_id);
-ZFCP_DEFINE_SCSI_ATTR(wwpn, "0x%016llx\n", unit->port->wwpn);
-ZFCP_DEFINE_SCSI_ATTR(fcp_lun, "0x%016llx\n", unit->fcp_lun);
-
-static struct device_attribute *zfcp_sysfs_sdev_attrs[] = {
-	&dev_attr_fcp_lun,
-	&dev_attr_wwpn,
-	&dev_attr_hba_id,
-	&dev_attr_read_latency,
-	&dev_attr_write_latency,
-	&dev_attr_cmd_latency,
-	NULL
-};
-
-static ssize_t zfcp_sysfs_adapter_util_show(struct device *dev,
-					    struct device_attribute *attr,
-					    char *buf)
-{
-	struct Scsi_Host *scsi_host = dev_to_shost(dev);
-	struct fsf_qtcb_bottom_port *qtcb_port;
-	struct zfcp_adapter *adapter;
-	int retval;
-
-	adapter = (struct zfcp_adapter *) scsi_host->hostdata[0];
-	if (!(adapter->adapter_features & FSF_FEATURE_MEASUREMENT_DATA))
-		return -EOPNOTSUPP;
-
-	qtcb_port = kzalloc(sizeof(struct fsf_qtcb_bottom_port), GFP_KERNEL);
-	if (!qtcb_port)
-		return -ENOMEM;
-
-	retval = zfcp_fsf_exchange_port_data_sync(adapter, qtcb_port);
-	if (!retval)
-		retval = sprintf(buf, "%u %u %u\n", qtcb_port->cp_util,
-				 qtcb_port->cb_util, qtcb_port->a_util);
-	kfree(qtcb_port);
-	return retval;
-}
-
-static int zfcp_sysfs_adapter_ex_config(struct device *dev,
-					struct fsf_statistics_info *stat_inf)
-{
-	struct Scsi_Host *scsi_host = dev_to_shost(dev);
-	struct fsf_qtcb_bottom_config *qtcb_config;
-	struct zfcp_adapter *adapter;
-	int retval;
-
-	adapter = (struct zfcp_adapter *) scsi_host->hostdata[0];
-	if (!(adapter->adapter_features & FSF_FEATURE_MEASUREMENT_DATA))
-		return -EOPNOTSUPP;
-
-	qtcb_config = kzalloc(sizeof(struct fsf_qtcb_bottom_config),
-			      GFP_KERNEL);
-	if (!qtcb_config)
-		return -ENOMEM;
-
-	retval = zfcp_fsf_exchange_config_data_sync(adapter, qtcb_config);
-	if (!retval)
-		*stat_inf = qtcb_config->stat_info;
-
-	kfree(qtcb_config);
-	return retval;
-}
-
-static ssize_t zfcp_sysfs_adapter_request_show(struct device *dev,
-					       struct device_attribute *attr,
-					       char *buf)
-{
-	struct fsf_statistics_info stat_info;
-	int retval;
-
-	retval = zfcp_sysfs_adapter_ex_config(dev, &stat_info);
-	if (retval)
-		return retval;
-
-	return sprintf(buf, "%llu %llu %llu\n",
-		       (unsigned long long) stat_info.input_req,
-		       (unsigned long long) stat_info.output_req,
-		       (unsigned long long) stat_info.control_req);
-}
-
-static ssize_t zfcp_sysfs_adapter_mb_show(struct device *dev,
-					  struct device_attribute *attr,
-					  char *buf)
-{
-	struct fsf_statistics_info stat_info;
-	int retval;
-
-	retval = zfcp_sysfs_adapter_ex_config(dev, &stat_info);
-	if (retval)
-		return retval;
-
-	return sprintf(buf, "%llu %llu\n",
-		       (unsigned long long) stat_info.input_mb,
-		       (unsigned long long) stat_info.output_mb);
-}
-
-static ssize_t zfcp_sysfs_adapter_sec_active_show(struct device *dev,
-						  struct device_attribute *attr,
-						  char *buf)
-{
-	struct fsf_statistics_info stat_info;
-	int retval;
-
-	retval = zfcp_sysfs_adapter_ex_config(dev, &stat_info);
-	if (retval)
-		return retval;
-
-	return sprintf(buf, "%llu\n",
-		       (unsigned long long) stat_info.seconds_act);
-}
-
-static DEVICE_ATTR(utilization, S_IRUGO, zfcp_sysfs_adapter_util_show, NULL);
-static DEVICE_ATTR(requests, S_IRUGO, zfcp_sysfs_adapter_request_show, NULL);
-static DEVICE_ATTR(megabytes, S_IRUGO, zfcp_sysfs_adapter_mb_show, NULL);
-static DEVICE_ATTR(seconds_active, S_IRUGO,
-		   zfcp_sysfs_adapter_sec_active_show, NULL);
-
-static struct device_attribute *zfcp_a_stats_attrs[] = {
-	&dev_attr_utilization,
-	&dev_attr_requests,
-	&dev_attr_megabytes,
-	&dev_attr_seconds_active,
-	NULL
-};
-
 struct zfcp_data zfcp_data = {
 	.scsi_host_template = {
 		.name			 = "zfcp",
@@ -743,7 +540,6 @@ struct zfcp_data zfcp_data = {
 		.use_clustering		 = 1,
 		.sdev_attrs		 = zfcp_sysfs_sdev_attrs,
 		.max_sectors		 = (ZFCP_MAX_SBALES_PER_REQ * 8),
-		.shost_attrs		 = zfcp_a_stats_attrs,
+		.shost_attrs		 = zfcp_sysfs_shost_attrs,
 	},
 };
-

commit f76af7d7e36373179be7a9e09f6b0aae330549b7
Author: Martin Petermann <martin@linux.vnet.ibm.com>
Date:   Wed Jul 2 10:56:36 2008 +0200

    [SCSI] zfcp: Cleanup of code in zfcp_scsi.c
    
    Cleanup code in zfcp_scsi.c, fix coding style issues and simplify the
    code.
    
    Signed-off-by: Martin Petermann <martin@linux.vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 160307382d2c..f8594a2e3f5c 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -9,137 +9,32 @@
 #include "zfcp_ext.h"
 #include <asm/atomic.h>
 
-static void zfcp_scsi_slave_destroy(struct scsi_device *sdp);
-static int zfcp_scsi_slave_alloc(struct scsi_device *sdp);
-static int zfcp_scsi_slave_configure(struct scsi_device *sdp);
-static int zfcp_scsi_queuecommand(struct scsi_cmnd *,
-				  void (*done) (struct scsi_cmnd *));
-static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *);
-static int zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *);
-static int zfcp_scsi_eh_target_reset_handler(struct scsi_cmnd *);
-static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *);
-static int zfcp_task_management_function(struct zfcp_unit *, u8,
-					 struct scsi_cmnd *);
-
-static struct zfcp_unit *zfcp_unit_lookup(struct zfcp_adapter *, int,
-					  unsigned int, unsigned int);
-
-static struct device_attribute *zfcp_sysfs_sdev_attrs[];
-static struct device_attribute *zfcp_a_stats_attrs[];
-
-struct zfcp_data zfcp_data = {
-	.scsi_host_template = {
-		.name			= "zfcp",
-		.module			= THIS_MODULE,
-		.proc_name		= "zfcp",
-		.slave_alloc		= zfcp_scsi_slave_alloc,
-		.slave_configure	= zfcp_scsi_slave_configure,
-		.slave_destroy		= zfcp_scsi_slave_destroy,
-		.queuecommand		= zfcp_scsi_queuecommand,
-		.eh_abort_handler	= zfcp_scsi_eh_abort_handler,
-		.eh_device_reset_handler = zfcp_scsi_eh_device_reset_handler,
-		.eh_target_reset_handler = zfcp_scsi_eh_target_reset_handler,
-		.eh_host_reset_handler	= zfcp_scsi_eh_host_reset_handler,
-		.can_queue		= 4096,
-		.this_id		= -1,
-		.sg_tablesize		= ZFCP_MAX_SBALES_PER_REQ,
-		.cmd_per_lun		= 1,
-		.use_clustering		= 1,
-		.sdev_attrs		= zfcp_sysfs_sdev_attrs,
-		.max_sectors		= ZFCP_MAX_SECTORS,
-		.shost_attrs		= zfcp_a_stats_attrs,
-	},
-};
-
-/* Find start of Response Information in FCP response unit*/
-char *
-zfcp_get_fcp_rsp_info_ptr(struct fcp_rsp_iu *fcp_rsp_iu)
-{
-	char *fcp_rsp_info_ptr;
-
-	fcp_rsp_info_ptr =
-	    (unsigned char *) fcp_rsp_iu + (sizeof (struct fcp_rsp_iu));
-
-	return fcp_rsp_info_ptr;
-}
-
 /* Find start of Sense Information in FCP response unit*/
-char *
-zfcp_get_fcp_sns_info_ptr(struct fcp_rsp_iu *fcp_rsp_iu)
+char *zfcp_get_fcp_sns_info_ptr(struct fcp_rsp_iu *fcp_rsp_iu)
 {
 	char *fcp_sns_info_ptr;
 
-	fcp_sns_info_ptr =
-	    (unsigned char *) fcp_rsp_iu + (sizeof (struct fcp_rsp_iu));
+	fcp_sns_info_ptr = (unsigned char *) &fcp_rsp_iu[1];
 	if (fcp_rsp_iu->validity.bits.fcp_rsp_len_valid)
-		fcp_sns_info_ptr = (char *) fcp_sns_info_ptr +
-		    fcp_rsp_iu->fcp_rsp_len;
+		fcp_sns_info_ptr += fcp_rsp_iu->fcp_rsp_len;
 
 	return fcp_sns_info_ptr;
 }
 
-static fcp_dl_t *
-zfcp_get_fcp_dl_ptr(struct fcp_cmnd_iu * fcp_cmd)
+void zfcp_set_fcp_dl(struct fcp_cmnd_iu *fcp_cmd, fcp_dl_t fcp_dl)
 {
-	int additional_length = fcp_cmd->add_fcp_cdb_length << 2;
-	fcp_dl_t *fcp_dl_addr;
+	fcp_dl_t *fcp_dl_ptr;
 
-	fcp_dl_addr = (fcp_dl_t *)
-		((unsigned char *) fcp_cmd +
-		 sizeof (struct fcp_cmnd_iu) + additional_length);
 	/*
 	 * fcp_dl_addr = start address of fcp_cmnd structure +
 	 * size of fixed part + size of dynamically sized add_dcp_cdb field
 	 * SEE FCP-2 documentation
 	 */
-	return fcp_dl_addr;
-}
-
-fcp_dl_t
-zfcp_get_fcp_dl(struct fcp_cmnd_iu * fcp_cmd)
-{
-	return *zfcp_get_fcp_dl_ptr(fcp_cmd);
-}
-
-void
-zfcp_set_fcp_dl(struct fcp_cmnd_iu *fcp_cmd, fcp_dl_t fcp_dl)
-{
-	*zfcp_get_fcp_dl_ptr(fcp_cmd) = fcp_dl;
-}
-
-static int
-zfcp_scsi_slave_alloc(struct scsi_device *sdp)
-{
-	struct zfcp_adapter *adapter;
-	struct zfcp_unit *unit;
-	unsigned long flags;
-	int retval = -ENXIO;
-
-	adapter = (struct zfcp_adapter *) sdp->host->hostdata[0];
-	if (!adapter)
-		goto out;
-
-	read_lock_irqsave(&zfcp_data.config_lock, flags);
-	unit = zfcp_unit_lookup(adapter, sdp->channel, sdp->id, sdp->lun);
-	if (unit && atomic_test_mask(ZFCP_STATUS_UNIT_REGISTERED,
-				     &unit->status)) {
-		sdp->hostdata = unit;
-		unit->device = sdp;
-		zfcp_unit_get(unit);
-		retval = 0;
-	}
-	read_unlock_irqrestore(&zfcp_data.config_lock, flags);
- out:
-	return retval;
+	fcp_dl_ptr = (fcp_dl_t *) ((unsigned char *) &fcp_cmd[1] +
+				   (fcp_cmd->add_fcp_cdb_length << 2));
+	*fcp_dl_ptr = fcp_dl;
 }
 
-/**
- * zfcp_scsi_slave_destroy - called when scsi device is removed
- *
- * Remove reference to associated scsi device for an zfcp_unit.
- * Mark zfcp_unit as failed. The scsi device might be deleted via sysfs
- * or a scan for this device might have failed.
- */
 static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 {
 	struct zfcp_unit *unit = (struct zfcp_unit *) sdpnt->hostdata;
@@ -153,26 +48,16 @@ static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 	}
 }
 
-/*
- * called from scsi midlayer to allow finetuning of a device.
- */
-static int
-zfcp_scsi_slave_configure(struct scsi_device *sdp)
+static int zfcp_scsi_slave_configure(struct scsi_device *sdp)
 {
 	if (sdp->tagged_supported)
-		scsi_adjust_queue_depth(sdp, MSG_SIMPLE_TAG, ZFCP_CMND_PER_LUN);
+		scsi_adjust_queue_depth(sdp, MSG_SIMPLE_TAG, 32);
 	else
 		scsi_adjust_queue_depth(sdp, 0, 1);
 	return 0;
 }
 
-/**
- * zfcp_scsi_command_fail - set result in scsi_cmnd and call scsi_done function
- * @scpnt: pointer to struct scsi_cmnd where result is set
- * @result: result to be set in scpnt (e.g. DID_ERROR)
- */
-static void
-zfcp_scsi_command_fail(struct scsi_cmnd *scpnt, int result)
+static void zfcp_scsi_command_fail(struct scsi_cmnd *scpnt, int result)
 {
 	set_host_byte(scpnt, result);
 	if ((scpnt->device != NULL) && (scpnt->device->host != NULL))
@@ -183,104 +68,13 @@ zfcp_scsi_command_fail(struct scsi_cmnd *scpnt, int result)
 	scpnt->scsi_done(scpnt);
 }
 
-/**
- * zfcp_scsi_command_async - worker for zfcp_scsi_queuecommand and
- *	zfcp_scsi_command_sync
- * @adapter: adapter where scsi command is issued
- * @unit: unit to which scsi command is sent
- * @scpnt: scsi command to be sent
- * @timer: timer to be started if request is successfully initiated
- *
- * Note: In scsi_done function must be set in scpnt.
- */
-int
-zfcp_scsi_command_async(struct zfcp_adapter *adapter, struct zfcp_unit *unit,
-			struct scsi_cmnd *scpnt, int use_timer)
-{
-	int tmp;
-	int retval;
-
-	retval = 0;
-
-	BUG_ON((adapter == NULL) || (adapter != unit->port->adapter));
-	BUG_ON(scpnt->scsi_done == NULL);
-
-	if (unlikely(NULL == unit)) {
-		zfcp_scsi_command_fail(scpnt, DID_NO_CONNECT);
-		goto out;
-	}
-
-	if (unlikely(
-	      atomic_test_mask(ZFCP_STATUS_COMMON_ERP_FAILED, &unit->status) ||
-	     !atomic_test_mask(ZFCP_STATUS_COMMON_RUNNING, &unit->status))) {
-		zfcp_scsi_command_fail(scpnt, DID_ERROR);
-		goto out;
-	}
-
-	tmp = zfcp_fsf_send_fcp_command_task(adapter, unit, scpnt, use_timer,
-					     ZFCP_REQ_AUTO_CLEANUP);
-	if (unlikely(tmp == -EBUSY)) {
-		zfcp_scsi_command_fail(scpnt, DID_NO_CONNECT);
-		goto out;
-	}
-
-	if (unlikely(tmp < 0))
-		retval = SCSI_MLQUEUE_HOST_BUSY;
-
-out:
-	return retval;
-}
-
-static void
-zfcp_scsi_command_sync_handler(struct scsi_cmnd *scpnt)
-{
-	struct completion *wait = (struct completion *) scpnt->SCp.ptr;
-	complete(wait);
-}
-
-
-/**
- * zfcp_scsi_command_sync - send a SCSI command and wait for completion
- * @unit: unit where command is sent to
- * @scpnt: scsi command to be sent
- * @use_timer: indicates whether timer should be setup or not
- * Return: 0
- *
- * Errors are indicated in scpnt->result
- */
-int
-zfcp_scsi_command_sync(struct zfcp_unit *unit, struct scsi_cmnd *scpnt,
-		       int use_timer)
-{
-	int ret;
-	DECLARE_COMPLETION_ONSTACK(wait);
-
-	scpnt->SCp.ptr = (void *) &wait;  /* silent re-use */
-	scpnt->scsi_done = zfcp_scsi_command_sync_handler;
-	ret = zfcp_scsi_command_async(unit->port->adapter, unit, scpnt,
-				      use_timer);
-	if (ret == 0)
-		wait_for_completion(&wait);
-
-	scpnt->SCp.ptr = NULL;
-
-	return 0;
-}
-
-/*
- * function:	zfcp_scsi_queuecommand
- *
- * purpose:	enqueues a SCSI command to the specified target device
- *
- * returns:	0 - success, SCSI command enqueued
- *		!0 - failure
- */
-static int
-zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
-		       void (*done) (struct scsi_cmnd *))
+static int zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
+				  void (*done) (struct scsi_cmnd *))
 {
 	struct zfcp_unit *unit;
 	struct zfcp_adapter *adapter;
+	int    status;
+	int    ret;
 
 	/* reset the status for this request */
 	scpnt->result = 0;
@@ -292,44 +86,76 @@ zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 	 * (stored there by zfcp_scsi_slave_alloc)
 	 */
 	adapter = (struct zfcp_adapter *) scpnt->device->host->hostdata[0];
-	unit = (struct zfcp_unit *) scpnt->device->hostdata;
+	unit = scpnt->device->hostdata;
+
+	BUG_ON(!adapter || (adapter != unit->port->adapter));
+	BUG_ON(!scpnt->scsi_done);
+
+	if (unlikely(!unit)) {
+		zfcp_scsi_command_fail(scpnt, DID_NO_CONNECT);
+		return 0;
+	}
+
+	status = atomic_read(&unit->status);
+	if (unlikely((status & ZFCP_STATUS_COMMON_ERP_FAILED) ||
+		     !(status & ZFCP_STATUS_COMMON_RUNNING))) {
+		zfcp_scsi_command_fail(scpnt, DID_ERROR);
+		return 0;;
+	}
+
+	ret = zfcp_fsf_send_fcp_command_task(adapter, unit, scpnt, 0,
+					     ZFCP_REQ_AUTO_CLEANUP);
+	if (unlikely(ret == -EBUSY))
+		zfcp_scsi_command_fail(scpnt, DID_NO_CONNECT);
+	else if (unlikely(ret < 0))
+		return SCSI_MLQUEUE_HOST_BUSY;
 
-	return zfcp_scsi_command_async(adapter, unit, scpnt, 0);
+	return ret;
 }
 
-static struct zfcp_unit *
-zfcp_unit_lookup(struct zfcp_adapter *adapter, int channel, unsigned int id,
-		 unsigned int lun)
+static struct zfcp_unit *zfcp_unit_lookup(struct zfcp_adapter *adapter,
+					  int channel, unsigned int id,
+					  unsigned int lun)
 {
 	struct zfcp_port *port;
-	struct zfcp_unit *unit, *retval = NULL;
+	struct zfcp_unit *unit;
 
 	list_for_each_entry(port, &adapter->port_list_head, list) {
 		if (!port->rport || (id != port->rport->scsi_target_id))
 			continue;
 		list_for_each_entry(unit, &port->unit_list_head, list)
-			if (lun == unit->scsi_lun) {
-				retval = unit;
-				goto out;
-			}
+			if (lun == unit->scsi_lun)
+				return unit;
 	}
- out:
+
+	return NULL;
+}
+
+static int zfcp_scsi_slave_alloc(struct scsi_device *sdp)
+{
+	struct zfcp_adapter *adapter;
+	struct zfcp_unit *unit;
+	unsigned long flags;
+	int retval = -ENXIO;
+
+	adapter = (struct zfcp_adapter *) sdp->host->hostdata[0];
+	if (!adapter)
+		goto out;
+
+	read_lock_irqsave(&zfcp_data.config_lock, flags);
+	unit = zfcp_unit_lookup(adapter, sdp->channel, sdp->id, sdp->lun);
+	if (unit &&
+	    (atomic_read(&unit->status) & ZFCP_STATUS_UNIT_REGISTERED)) {
+		sdp->hostdata = unit;
+		unit->device = sdp;
+		zfcp_unit_get(unit);
+		retval = 0;
+	}
+	read_unlock_irqrestore(&zfcp_data.config_lock, flags);
+out:
 	return retval;
 }
 
-/**
- * zfcp_scsi_eh_abort_handler - abort the specified SCSI command
- * @scpnt: pointer to scsi_cmnd to be aborted
- * Return: SUCCESS - command has been aborted and cleaned up in internal
- *          bookkeeping, SCSI stack won't be called for aborted command
- *         FAILED - otherwise
- *
- * We do not need to care for a SCSI command which completes normally
- * but late during this abort routine runs.  We are allowed to return
- * late commands to the SCSI stack.  It tracks the state of commands and
- * will handle late commands.  (Usually, the normal completion of late
- * commands is ignored with respect to the running abort operation.)
- */
 static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 {
  	struct Scsi_Host *scsi_host;
@@ -337,30 +163,27 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	struct zfcp_unit *unit;
 	struct zfcp_fsf_req *fsf_req;
 	unsigned long flags;
-	unsigned long old_req_id;
+	unsigned long old_req_id = (unsigned long) scpnt->host_scribble;
 	int retval = SUCCESS;
 
 	scsi_host = scpnt->device->host;
 	adapter = (struct zfcp_adapter *) scsi_host->hostdata[0];
-	unit = (struct zfcp_unit *) scpnt->device->hostdata;
+	unit = scpnt->device->hostdata;
 
 	/* avoid race condition between late normal completion and abort */
 	write_lock_irqsave(&adapter->abort_lock, flags);
 
 	/* Check whether corresponding fsf_req is still pending */
 	spin_lock(&adapter->req_list_lock);
-	fsf_req = zfcp_reqlist_find(adapter,
-				    (unsigned long) scpnt->host_scribble);
+	fsf_req = zfcp_reqlist_find(adapter, old_req_id);
 	spin_unlock(&adapter->req_list_lock);
 	if (!fsf_req) {
 		write_unlock_irqrestore(&adapter->abort_lock, flags);
 		zfcp_scsi_dbf_event_abort("lte1", adapter, scpnt, NULL, 0);
-		retval = SUCCESS;
-		goto out;
+		return retval;
 	}
 	fsf_req->data = 0;
 	fsf_req->status |= ZFCP_STATUS_FSFREQ_ABORTING;
-	old_req_id = fsf_req->req_id;
 
 	/* don't access old fsf_req after releasing the abort_lock */
 	write_unlock_irqrestore(&adapter->abort_lock, flags);
@@ -370,7 +193,7 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 		zfcp_scsi_dbf_event_abort("nres", adapter, scpnt, NULL,
 					  old_req_id);
 		retval = FAILED;
-		goto out;
+		return retval;
 	}
 
 	__wait_event(fsf_req->completion_wq,
@@ -378,62 +201,30 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 
 	if (fsf_req->status & ZFCP_STATUS_FSFREQ_ABORTSUCCEEDED) {
 		zfcp_scsi_dbf_event_abort("okay", adapter, scpnt, fsf_req, 0);
-		retval = SUCCESS;
 	} else if (fsf_req->status & ZFCP_STATUS_FSFREQ_ABORTNOTNEEDED) {
 		zfcp_scsi_dbf_event_abort("lte2", adapter, scpnt, fsf_req, 0);
-		retval = SUCCESS;
 	} else {
 		zfcp_scsi_dbf_event_abort("fail", adapter, scpnt, fsf_req, 0);
 		retval = FAILED;
 	}
 	zfcp_fsf_req_free(fsf_req);
- out:
-	return retval;
-}
-
-static int zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)
-{
-	int retval;
-	struct zfcp_unit *unit = scpnt->device->hostdata;
 
-	if (!unit) {
-		WARN_ON(1);
-		return SUCCESS;
-	}
-	retval = zfcp_task_management_function(unit,
-					       FCP_LOGICAL_UNIT_RESET,
-					       scpnt);
-	return retval ? FAILED : SUCCESS;
-}
-
-static int zfcp_scsi_eh_target_reset_handler(struct scsi_cmnd *scpnt)
-{
-	int retval;
-	struct zfcp_unit *unit = scpnt->device->hostdata;
-
-	if (!unit) {
-		WARN_ON(1);
-		return SUCCESS;
-	}
-	retval = zfcp_task_management_function(unit, FCP_TARGET_RESET, scpnt);
-	return retval ? FAILED : SUCCESS;
+	return retval;
 }
 
-static int
-zfcp_task_management_function(struct zfcp_unit *unit, u8 tm_flags,
-			      struct scsi_cmnd *scpnt)
+static int zfcp_task_mgmt_function(struct zfcp_unit *unit, u8 tm_flags,
+					 struct scsi_cmnd *scpnt)
 {
 	struct zfcp_adapter *adapter = unit->port->adapter;
 	struct zfcp_fsf_req *fsf_req;
-	int retval = 0;
+	int retval = SUCCESS;
 
 	/* issue task management function */
 	fsf_req = zfcp_fsf_send_fcp_command_task_management
 		(adapter, unit, tm_flags, 0);
 	if (!fsf_req) {
 		zfcp_scsi_dbf_event_devreset("nres", tm_flags, unit, scpnt);
-		retval = -ENOMEM;
-		goto out;
+		return FAILED;
 	}
 
 	__wait_event(fsf_req->completion_wq,
@@ -444,27 +235,46 @@ zfcp_task_management_function(struct zfcp_unit *unit, u8 tm_flags,
 	 */
 	if (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCFAILED) {
 		zfcp_scsi_dbf_event_devreset("fail", tm_flags, unit, scpnt);
-		retval = -EIO;
+		retval = FAILED;
 	} else if (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCNOTSUPP) {
 		zfcp_scsi_dbf_event_devreset("nsup", tm_flags, unit, scpnt);
-		retval = -ENOTSUPP;
+		retval = FAILED;
 	} else
 		zfcp_scsi_dbf_event_devreset("okay", tm_flags, unit, scpnt);
 
 	zfcp_fsf_req_free(fsf_req);
- out:
+
 	return retval;
 }
 
-/**
- * zfcp_scsi_eh_host_reset_handler - handler for host reset
- */
+static int zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)
+{
+	struct zfcp_unit *unit = scpnt->device->hostdata;
+
+	if (!unit) {
+		WARN_ON(1);
+		return SUCCESS;
+	}
+	return zfcp_task_mgmt_function(unit, FCP_LOGICAL_UNIT_RESET, scpnt);
+}
+
+static int zfcp_scsi_eh_target_reset_handler(struct scsi_cmnd *scpnt)
+{
+	struct zfcp_unit *unit = scpnt->device->hostdata;
+
+	if (!unit) {
+		WARN_ON(1);
+		return SUCCESS;
+	}
+	return zfcp_task_mgmt_function(unit, FCP_TARGET_RESET, scpnt);
+}
+
 static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 {
 	struct zfcp_unit *unit;
 	struct zfcp_adapter *adapter;
 
-	unit = (struct zfcp_unit*) scpnt->device->hostdata;
+	unit = scpnt->device->hostdata;
 	adapter = unit->port->adapter;
 	zfcp_erp_adapter_reopen(adapter, 0, 141, scpnt);
 	zfcp_erp_wait(adapter);
@@ -472,51 +282,43 @@ static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 	return SUCCESS;
 }
 
-int
-zfcp_adapter_scsi_register(struct zfcp_adapter *adapter)
+int zfcp_adapter_scsi_register(struct zfcp_adapter *adapter)
 {
-	int retval = 0;
-	static unsigned int unique_id = 0;
+	struct ccw_dev_id dev_id;
 
 	if (adapter->scsi_host)
-		goto out;
+		return 0;
 
+	ccw_device_get_id(adapter->ccw_device, &dev_id);
 	/* register adapter as SCSI host with mid layer of SCSI stack */
 	adapter->scsi_host = scsi_host_alloc(&zfcp_data.scsi_host_template,
 					     sizeof (struct zfcp_adapter *));
 	if (!adapter->scsi_host) {
 		dev_err(&adapter->ccw_device->dev,
 			"registration with SCSI stack failed.");
-		retval = -EIO;
-		goto out;
+		return -EIO;
 	}
 
 	/* tell the SCSI stack some characteristics of this adapter */
 	adapter->scsi_host->max_id = 1;
 	adapter->scsi_host->max_lun = 1;
 	adapter->scsi_host->max_channel = 0;
-	adapter->scsi_host->unique_id = unique_id++;	/* FIXME */
-	adapter->scsi_host->max_cmd_len = ZFCP_MAX_SCSI_CMND_LENGTH;
+	adapter->scsi_host->unique_id = dev_id.devno;
+	adapter->scsi_host->max_cmd_len = 255;
 	adapter->scsi_host->transportt = zfcp_data.scsi_transport_template;
 
-	/*
-	 * save a pointer to our own adapter data structure within
-	 * hostdata field of SCSI host data structure
-	 */
 	adapter->scsi_host->hostdata[0] = (unsigned long) adapter;
 
 	if (scsi_add_host(adapter->scsi_host, &adapter->ccw_device->dev)) {
 		scsi_host_put(adapter->scsi_host);
-		retval = -EIO;
-		goto out;
+		return -EIO;
 	}
 	atomic_set_mask(ZFCP_STATUS_ADAPTER_REGISTERED, &adapter->status);
- out:
-	return retval;
+
+	return 0;
 }
 
-void
-zfcp_adapter_scsi_unregister(struct zfcp_adapter *adapter)
+void zfcp_adapter_scsi_unregister(struct zfcp_adapter *adapter)
 {
 	struct Scsi_Host *shost;
 	struct zfcp_port *port;
@@ -524,10 +326,12 @@ zfcp_adapter_scsi_unregister(struct zfcp_adapter *adapter)
 	shost = adapter->scsi_host;
 	if (!shost)
 		return;
+
 	read_lock_irq(&zfcp_data.config_lock);
 	list_for_each_entry(port, &adapter->port_list_head, list)
 		if (port->rport)
 			port->rport = NULL;
+
 	read_unlock_irq(&zfcp_data.config_lock);
 	fc_remove_host(shost);
 	scsi_remove_host(shost);
@@ -538,9 +342,6 @@ zfcp_adapter_scsi_unregister(struct zfcp_adapter *adapter)
 	return;
 }
 
-/*
- * Support functions for FC transport class
- */
 static struct fc_host_statistics*
 zfcp_init_fc_host_stats(struct zfcp_adapter *adapter)
 {
@@ -556,13 +357,12 @@ zfcp_init_fc_host_stats(struct zfcp_adapter *adapter)
 	return adapter->fc_stats;
 }
 
-static void
-zfcp_adjust_fc_host_stats(struct fc_host_statistics *fc_stats,
-			  struct fsf_qtcb_bottom_port *data,
-			  struct fsf_qtcb_bottom_port *old)
+static void zfcp_adjust_fc_host_stats(struct fc_host_statistics *fc_stats,
+				      struct fsf_qtcb_bottom_port *data,
+				      struct fsf_qtcb_bottom_port *old)
 {
-	fc_stats->seconds_since_last_reset = data->seconds_since_last_reset -
-		old->seconds_since_last_reset;
+	fc_stats->seconds_since_last_reset =
+		data->seconds_since_last_reset - old->seconds_since_last_reset;
 	fc_stats->tx_frames = data->tx_frames - old->tx_frames;
 	fc_stats->tx_words = data->tx_words - old->tx_words;
 	fc_stats->rx_frames = data->rx_frames - old->rx_frames;
@@ -573,26 +373,25 @@ zfcp_adjust_fc_host_stats(struct fc_host_statistics *fc_stats,
 	fc_stats->dumped_frames = data->dumped_frames - old->dumped_frames;
 	fc_stats->link_failure_count = data->link_failure - old->link_failure;
 	fc_stats->loss_of_sync_count = data->loss_of_sync - old->loss_of_sync;
-	fc_stats->loss_of_signal_count = data->loss_of_signal -
-		old->loss_of_signal;
-	fc_stats->prim_seq_protocol_err_count = data->psp_error_counts -
-		old->psp_error_counts;
-	fc_stats->invalid_tx_word_count = data->invalid_tx_words -
-		old->invalid_tx_words;
+	fc_stats->loss_of_signal_count =
+		data->loss_of_signal - old->loss_of_signal;
+	fc_stats->prim_seq_protocol_err_count =
+		data->psp_error_counts - old->psp_error_counts;
+	fc_stats->invalid_tx_word_count =
+		data->invalid_tx_words - old->invalid_tx_words;
 	fc_stats->invalid_crc_count = data->invalid_crcs - old->invalid_crcs;
-	fc_stats->fcp_input_requests = data->input_requests -
-		old->input_requests;
-	fc_stats->fcp_output_requests = data->output_requests -
-		old->output_requests;
-	fc_stats->fcp_control_requests = data->control_requests -
-		old->control_requests;
+	fc_stats->fcp_input_requests =
+		data->input_requests - old->input_requests;
+	fc_stats->fcp_output_requests =
+		data->output_requests - old->output_requests;
+	fc_stats->fcp_control_requests =
+		data->control_requests - old->control_requests;
 	fc_stats->fcp_input_megabytes = data->input_mb - old->input_mb;
 	fc_stats->fcp_output_megabytes = data->output_mb - old->output_mb;
 }
 
-static void
-zfcp_set_fc_host_stats(struct fc_host_statistics *fc_stats,
-		       struct fsf_qtcb_bottom_port *data)
+static void zfcp_set_fc_host_stats(struct fc_host_statistics *fc_stats,
+				   struct fsf_qtcb_bottom_port *data)
 {
 	fc_stats->seconds_since_last_reset = data->seconds_since_last_reset;
 	fc_stats->tx_frames = data->tx_frames;
@@ -616,22 +415,14 @@ zfcp_set_fc_host_stats(struct fc_host_statistics *fc_stats,
 	fc_stats->fcp_output_megabytes = data->output_mb;
 }
 
-/**
- * zfcp_get_fc_host_stats - provide fc_host_statistics for scsi_transport_fc
- *
- * assumption: scsi_transport_fc synchronizes calls of
- *             get_fc_host_stats and reset_fc_host_stats
- *             (XXX to be checked otherwise introduce locking)
- */
-static struct fc_host_statistics *
-zfcp_get_fc_host_stats(struct Scsi_Host *shost)
+static struct fc_host_statistics *zfcp_get_fc_host_stats(struct Scsi_Host *host)
 {
 	struct zfcp_adapter *adapter;
 	struct fc_host_statistics *fc_stats;
 	struct fsf_qtcb_bottom_port *data;
 	int ret;
 
-	adapter = (struct zfcp_adapter *)shost->hostdata[0];
+	adapter = (struct zfcp_adapter *)host->hostdata[0];
 	fc_stats = zfcp_init_fc_host_stats(adapter);
 	if (!fc_stats)
 		return NULL;
@@ -643,26 +434,25 @@ zfcp_get_fc_host_stats(struct Scsi_Host *shost)
 	ret = zfcp_fsf_exchange_port_data_sync(adapter, data);
 	if (ret) {
 		kfree(data);
-		return NULL; /* XXX return zeroed fc_stats? */
+		return NULL;
 	}
 
 	if (adapter->stats_reset &&
 	    ((jiffies/HZ - adapter->stats_reset) <
-	     data->seconds_since_last_reset)) {
+	     data->seconds_since_last_reset))
 		zfcp_adjust_fc_host_stats(fc_stats, data,
 					  adapter->stats_reset_data);
-	} else
+	else
 		zfcp_set_fc_host_stats(fc_stats, data);
 
 	kfree(data);
 	return fc_stats;
 }
 
-static void
-zfcp_reset_fc_host_stats(struct Scsi_Host *shost)
+static void zfcp_reset_fc_host_stats(struct Scsi_Host *shost)
 {
 	struct zfcp_adapter *adapter;
-	struct fsf_qtcb_bottom_port *data, *old_data;
+	struct fsf_qtcb_bottom_port *data;
 	int ret;
 
 	adapter = (struct zfcp_adapter *)shost->hostdata[0];
@@ -671,14 +461,13 @@ zfcp_reset_fc_host_stats(struct Scsi_Host *shost)
 		return;
 
 	ret = zfcp_fsf_exchange_port_data_sync(adapter, data);
-	if (ret) {
+	if (ret)
 		kfree(data);
-	} else {
+	else {
 		adapter->stats_reset = jiffies/HZ;
-		old_data = adapter->stats_reset_data;
+		kfree(adapter->stats_reset_data);
 		adapter->stats_reset_data = data; /* finally freed in
-						     adater_dequeue */
-		kfree(old_data);
+						     adapter_dequeue */
 	}
 }
 
@@ -793,14 +582,6 @@ ZFCP_DEFINE_LATENCY_ATTR(read);
 ZFCP_DEFINE_LATENCY_ATTR(write);
 ZFCP_DEFINE_LATENCY_ATTR(cmd);
 
-/**
- * ZFCP_DEFINE_SCSI_ATTR
- * @_name:   name of show attribute
- * @_format: format string
- * @_value:  value to print
- *
- * Generates attribute for a unit.
- */
 #define ZFCP_DEFINE_SCSI_ATTR(_name, _format, _value)                    \
 static ssize_t zfcp_sysfs_scsi_##_name##_show(struct device *dev, struct device_attribute *attr,        \
                                               char *buf)                 \
@@ -815,7 +596,8 @@ static ssize_t zfcp_sysfs_scsi_##_name##_show(struct device *dev, struct device_
                                                                          \
 static DEVICE_ATTR(_name, S_IRUGO, zfcp_sysfs_scsi_##_name##_show, NULL);
 
-ZFCP_DEFINE_SCSI_ATTR(hba_id, "%s\n", zfcp_get_busid_by_unit(unit));
+ZFCP_DEFINE_SCSI_ATTR(hba_id, "%s\n",
+	unit->port->adapter->ccw_device->dev.bus_id);
 ZFCP_DEFINE_SCSI_ATTR(wwpn, "0x%016llx\n", unit->port->wwpn);
 ZFCP_DEFINE_SCSI_ATTR(fcp_lun, "0x%016llx\n", unit->fcp_lun);
 
@@ -835,8 +617,8 @@ static ssize_t zfcp_sysfs_adapter_util_show(struct device *dev,
 {
 	struct Scsi_Host *scsi_host = dev_to_shost(dev);
 	struct fsf_qtcb_bottom_port *qtcb_port;
-	int retval;
 	struct zfcp_adapter *adapter;
+	int retval;
 
 	adapter = (struct zfcp_adapter *) scsi_host->hostdata[0];
 	if (!(adapter->adapter_features & FSF_FEATURE_MEASUREMENT_DATA))
@@ -857,17 +639,17 @@ static ssize_t zfcp_sysfs_adapter_util_show(struct device *dev,
 static int zfcp_sysfs_adapter_ex_config(struct device *dev,
 					struct fsf_statistics_info *stat_inf)
 {
-	int retval;
-	struct fsf_qtcb_bottom_config *qtcb_config;
 	struct Scsi_Host *scsi_host = dev_to_shost(dev);
+	struct fsf_qtcb_bottom_config *qtcb_config;
 	struct zfcp_adapter *adapter;
+	int retval;
 
 	adapter = (struct zfcp_adapter *) scsi_host->hostdata[0];
 	if (!(adapter->adapter_features & FSF_FEATURE_MEASUREMENT_DATA))
 		return -EOPNOTSUPP;
 
 	qtcb_config = kzalloc(sizeof(struct fsf_qtcb_bottom_config),
-			       GFP_KERNEL);
+			      GFP_KERNEL);
 	if (!qtcb_config)
 		return -ENOMEM;
 
@@ -940,3 +722,28 @@ static struct device_attribute *zfcp_a_stats_attrs[] = {
 	&dev_attr_seconds_active,
 	NULL
 };
+
+struct zfcp_data zfcp_data = {
+	.scsi_host_template = {
+		.name			 = "zfcp",
+		.module			 = THIS_MODULE,
+		.proc_name		 = "zfcp",
+		.slave_alloc		 = zfcp_scsi_slave_alloc,
+		.slave_configure	 = zfcp_scsi_slave_configure,
+		.slave_destroy		 = zfcp_scsi_slave_destroy,
+		.queuecommand		 = zfcp_scsi_queuecommand,
+		.eh_abort_handler	 = zfcp_scsi_eh_abort_handler,
+		.eh_device_reset_handler = zfcp_scsi_eh_device_reset_handler,
+		.eh_target_reset_handler = zfcp_scsi_eh_target_reset_handler,
+		.eh_host_reset_handler	 = zfcp_scsi_eh_host_reset_handler,
+		.can_queue		 = 4096,
+		.this_id		 = -1,
+		.sg_tablesize		 = ZFCP_MAX_SBALES_PER_REQ,
+		.cmd_per_lun		 = 1,
+		.use_clustering		 = 1,
+		.sdev_attrs		 = zfcp_sysfs_sdev_attrs,
+		.max_sectors		 = (ZFCP_MAX_SBALES_PER_REQ * 8),
+		.shost_attrs		 = zfcp_a_stats_attrs,
+	},
+};
+

commit feac6a07c4a3578bffd6769bb4927e8a7e1f3ffe
Author: Martin Petermann <martin@linux.vnet.ibm.com>
Date:   Wed Jul 2 10:56:35 2008 +0200

    [SCSI] zfcp: Move status accessors from zfcp to SCSI include file.
    
    Move the accessor functions for the scsi_cmnd status from zfcp to the
    SCSI include file. Change the interface to the functions to pass the
    scsi_cmnd pointer instead of the status pointer.
    
    Signed-off-by: Martin Petermann <martin@linux.vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 446fb1da25df..160307382d2c 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -107,28 +107,6 @@ zfcp_set_fcp_dl(struct fcp_cmnd_iu *fcp_cmd, fcp_dl_t fcp_dl)
 	*zfcp_get_fcp_dl_ptr(fcp_cmd) = fcp_dl;
 }
 
-/*
- * note: it's a bit-or operation not an assignment
- * regarding the specified byte
- */
-static inline void
-set_byte(int *result, char status, char pos)
-{
-	*result |= status << (pos * 8);
-}
-
-void
-set_host_byte(int *result, char status)
-{
-	set_byte(result, status, 2);
-}
-
-void
-set_driver_byte(int *result, char status)
-{
-	set_byte(result, status, 3);
-}
-
 static int
 zfcp_scsi_slave_alloc(struct scsi_device *sdp)
 {
@@ -196,7 +174,7 @@ zfcp_scsi_slave_configure(struct scsi_device *sdp)
 static void
 zfcp_scsi_command_fail(struct scsi_cmnd *scpnt, int result)
 {
-	set_host_byte(&scpnt->result, result);
+	set_host_byte(scpnt, result);
 	if ((scpnt->device != NULL) && (scpnt->device->host != NULL))
 		zfcp_scsi_dbf_event_result("fail", 4,
 			(struct zfcp_adapter*) scpnt->device->host->hostdata[0],

commit 85a82392fe6fe7620d8fe0eb694f926cefe62e1f
Author: Sven Schuetz <sven@linux.vnet.ibm.com>
Date:   Tue Jun 10 18:20:59 2008 +0200

    [SCSI] zfcp: Add port_state attribute to sysfs
    
    The sysfs attribute /sys/class/fc_host/hostX/port_state was not set by
    zfcp so far.
    
    Now, the appropriate members of the fc_function_template struct are
    set during its initialziation. The first is a boolean to show the port
    state. The second is a function pointer to the function
    zfcp_get_host_port_state, which reads the port state from our adapter
    status bits and calls fc_host_port_state with the approriate port
    state afterwards.
    
    Signed-off-by: Sven Schuetz <sven@linux.vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index a96e5c3b9460..446fb1da25df 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -704,6 +704,23 @@ zfcp_reset_fc_host_stats(struct Scsi_Host *shost)
 	}
 }
 
+static void zfcp_get_host_port_state(struct Scsi_Host *shost)
+{
+	struct zfcp_adapter *adapter =
+		(struct zfcp_adapter *)shost->hostdata[0];
+	int status = atomic_read(&adapter->status);
+
+	if ((status & ZFCP_STATUS_COMMON_RUNNING) &&
+	    !(status & ZFCP_STATUS_ADAPTER_LINK_UNPLUGGED))
+		fc_host_port_state(shost) = FC_PORTSTATE_ONLINE;
+	else if (status & ZFCP_STATUS_ADAPTER_LINK_UNPLUGGED)
+		fc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;
+	else if (status & ZFCP_STATUS_COMMON_ERP_FAILED)
+		fc_host_port_state(shost) = FC_PORTSTATE_ERROR;
+	else
+		fc_host_port_state(shost) = FC_PORTSTATE_UNKNOWN;
+}
+
 static void zfcp_set_rport_dev_loss_tmo(struct fc_rport *rport, u32 timeout)
 {
 	rport->dev_loss_tmo = timeout;
@@ -726,6 +743,8 @@ struct fc_function_template zfcp_transport_functions = {
 	.get_fc_host_stats = zfcp_get_fc_host_stats,
 	.reset_fc_host_stats = zfcp_reset_fc_host_stats,
 	.set_rport_dev_loss_tmo = zfcp_set_rport_dev_loss_tmo,
+	.get_host_port_state = zfcp_get_host_port_state,
+	.show_host_port_state = 1,
 	/* no functions registered for following dynamic attributes but
 	   directly set by LLDD */
 	.show_host_port_type = 1,

commit 553448f6c4838a1e4bed2bc9301c748278d7d9ce
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue Jun 10 18:20:58 2008 +0200

    [SCSI] zfcp: Message cleanup
    
    Cleanup the messages used in the zfcp driver: Remove unnecessary debug
    and trace message and convert the remaining messages to standard
    kernel macros. Remove the zfcp message macros and while updating the
    whole flie also update the copyright headers.
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 4b0c85acb0f0..a96e5c3b9460 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -1,26 +1,11 @@
 /*
- * This file is part of the zfcp device driver for
- * FCP adapters for IBM System z9 and zSeries.
+ * zfcp device driver
  *
- * (C) Copyright IBM Corp. 2002, 2006
+ * Interface to Linux SCSI midlayer.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * Copyright IBM Corporation 2002, 2008
  */
 
-#define ZFCP_LOG_AREA			ZFCP_LOG_AREA_SCSI
-
 #include "zfcp_ext.h"
 #include <asm/atomic.h>
 
@@ -44,7 +29,7 @@ static struct device_attribute *zfcp_a_stats_attrs[];
 
 struct zfcp_data zfcp_data = {
 	.scsi_host_template = {
-		.name			= ZFCP_NAME,
+		.name			= "zfcp",
 		.module			= THIS_MODULE,
 		.proc_name		= "zfcp",
 		.slave_alloc		= zfcp_scsi_slave_alloc,
@@ -64,7 +49,6 @@ struct zfcp_data zfcp_data = {
 		.max_sectors		= ZFCP_MAX_SECTORS,
 		.shost_attrs		= zfcp_a_stats_attrs,
 	},
-	.driver_version = ZFCP_VERSION,
 };
 
 /* Find start of Response Information in FCP response unit*/
@@ -181,16 +165,14 @@ zfcp_scsi_slave_alloc(struct scsi_device *sdp)
 static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 {
 	struct zfcp_unit *unit = (struct zfcp_unit *) sdpnt->hostdata;
-
+	WARN_ON(!unit);
 	if (unit) {
 		atomic_clear_mask(ZFCP_STATUS_UNIT_REGISTERED, &unit->status);
 		sdpnt->hostdata = NULL;
 		unit->device = NULL;
 		zfcp_erp_unit_failed(unit, 12, NULL);
 		zfcp_unit_put(unit);
-	} else
-		ZFCP_LOG_NORMAL("bug: no unit associated with SCSI device at "
-				"address %p\n", sdpnt);
+	}
 }
 
 /*
@@ -253,10 +235,6 @@ zfcp_scsi_command_async(struct zfcp_adapter *adapter, struct zfcp_unit *unit,
 	if (unlikely(
 	      atomic_test_mask(ZFCP_STATUS_COMMON_ERP_FAILED, &unit->status) ||
 	     !atomic_test_mask(ZFCP_STATUS_COMMON_RUNNING, &unit->status))) {
-		ZFCP_LOG_DEBUG("stopping SCSI I/O on unit 0x%016Lx on port "
-			       "0x%016Lx on adapter %s\n",
-			       unit->fcp_lun, unit->port->wwpn,
-			       zfcp_get_busid_by_adapter(adapter));
 		zfcp_scsi_command_fail(scpnt, DID_ERROR);
 		goto out;
 	}
@@ -264,18 +242,12 @@ zfcp_scsi_command_async(struct zfcp_adapter *adapter, struct zfcp_unit *unit,
 	tmp = zfcp_fsf_send_fcp_command_task(adapter, unit, scpnt, use_timer,
 					     ZFCP_REQ_AUTO_CLEANUP);
 	if (unlikely(tmp == -EBUSY)) {
-		ZFCP_LOG_DEBUG("adapter %s not ready or unit 0x%016Lx "
-			       "on port 0x%016Lx in recovery\n",
-			       zfcp_get_busid_by_unit(unit),
-			       unit->fcp_lun, unit->port->wwpn);
 		zfcp_scsi_command_fail(scpnt, DID_NO_CONNECT);
 		goto out;
 	}
 
-	if (unlikely(tmp < 0)) {
-		ZFCP_LOG_DEBUG("error: initiation of Send FCP Cmnd failed\n");
+	if (unlikely(tmp < 0))
 		retval = SCSI_MLQUEUE_HOST_BUSY;
-	}
 
 out:
 	return retval;
@@ -394,9 +366,6 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	adapter = (struct zfcp_adapter *) scsi_host->hostdata[0];
 	unit = (struct zfcp_unit *) scpnt->device->hostdata;
 
-	ZFCP_LOG_INFO("aborting scsi_cmnd=%p on adapter %s\n",
-		      scpnt, zfcp_get_busid_by_adapter(adapter));
-
 	/* avoid race condition between late normal completion and abort */
 	write_lock_irqsave(&adapter->abort_lock, flags);
 
@@ -420,7 +389,6 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 
 	fsf_req = zfcp_fsf_abort_fcp_command(old_req_id, adapter, unit, 0);
 	if (!fsf_req) {
-		ZFCP_LOG_INFO("error: initiation of Abort FCP Cmnd failed\n");
 		zfcp_scsi_dbf_event_abort("nres", adapter, scpnt, NULL,
 					  old_req_id);
 		retval = FAILED;
@@ -485,10 +453,6 @@ zfcp_task_management_function(struct zfcp_unit *unit, u8 tm_flags,
 	fsf_req = zfcp_fsf_send_fcp_command_task_management
 		(adapter, unit, tm_flags, 0);
 	if (!fsf_req) {
-		ZFCP_LOG_INFO("error: creation of task management request "
-			      "failed for unit 0x%016Lx on port 0x%016Lx on  "
-			      "adapter %s\n", unit->fcp_lun, unit->port->wwpn,
-			      zfcp_get_busid_by_adapter(adapter));
 		zfcp_scsi_dbf_event_devreset("nres", tm_flags, unit, scpnt);
 		retval = -ENOMEM;
 		goto out;
@@ -524,12 +488,6 @@ static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 
 	unit = (struct zfcp_unit*) scpnt->device->hostdata;
 	adapter = unit->port->adapter;
-
-	ZFCP_LOG_NORMAL("host reset because of problems with "
-		"unit 0x%016Lx on port 0x%016Lx, adapter %s\n",
-		unit->fcp_lun, unit->port->wwpn,
-		zfcp_get_busid_by_adapter(unit->port->adapter));
-
 	zfcp_erp_adapter_reopen(adapter, 0, 141, scpnt);
 	zfcp_erp_wait(adapter);
 
@@ -549,13 +507,11 @@ zfcp_adapter_scsi_register(struct zfcp_adapter *adapter)
 	adapter->scsi_host = scsi_host_alloc(&zfcp_data.scsi_host_template,
 					     sizeof (struct zfcp_adapter *));
 	if (!adapter->scsi_host) {
-		ZFCP_LOG_NORMAL("error: registration with SCSI stack failed "
-				"for adapter %s ",
-				zfcp_get_busid_by_adapter(adapter));
+		dev_err(&adapter->ccw_device->dev,
+			"registration with SCSI stack failed.");
 		retval = -EIO;
 		goto out;
 	}
-	ZFCP_LOG_DEBUG("host registered, scsi_host=%p\n", adapter->scsi_host);
 
 	/* tell the SCSI stack some characteristics of this adapter */
 	adapter->scsi_host->max_id = 1;
@@ -987,5 +943,3 @@ static struct device_attribute *zfcp_a_stats_attrs[] = {
 	&dev_attr_seconds_active,
 	NULL
 };
-
-#undef ZFCP_LOG_AREA

commit 3a0d9e92356feb60ee4e978355f712366a93f4ef
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue May 6 11:00:06 2008 +0200

    [SCSI] zfcp: sysfs attributes for fabric and channel latencies
    
    The latency information is provided on a SCSI device level (LUN)
    which can be found at the following location
    
    /sys/class/scsi_device/<H:C:T:L>/device/cmd_latency
    /sys/class/scsi_device/<H:C:T:L>/device/read_latency
    /sys/class/scsi_device/<H:C:T:L>/device/write_latency
    
    Each sysfs attribute provides the available data: min, max and sum for
    fabric and channel latency and the number of requests processed.
    
    An overrun of the variables is neither detected nor treated.  The file
    has to be read twice to make a meaningful statement, because only the
    differences of the values between the two reads can be used.  A reset
    of the values can be achieved by writing to the attribute.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 01687559dc06..4b0c85acb0f0 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -778,6 +778,68 @@ struct fc_function_template zfcp_transport_functions = {
 	.disable_target_scan = 1,
 };
 
+#define ZFCP_DEFINE_LATENCY_ATTR(_name) 				\
+static ssize_t								\
+zfcp_sysfs_unit_##_name##_latency_show(struct device *dev,		\
+				       struct device_attribute *attr,	\
+				       char *buf) {			\
+	struct scsi_device *sdev = to_scsi_device(dev);			\
+	struct zfcp_unit *unit = sdev->hostdata;			\
+	struct zfcp_latencies *lat = &unit->latencies;			\
+	struct zfcp_adapter *adapter = unit->port->adapter;		\
+	unsigned long flags;						\
+	unsigned long long fsum, fmin, fmax, csum, cmin, cmax, cc;	\
+									\
+	spin_lock_irqsave(&lat->lock, flags);				\
+	fsum = lat->_name.fabric.sum * adapter->timer_ticks;		\
+	fmin = lat->_name.fabric.min * adapter->timer_ticks;		\
+	fmax = lat->_name.fabric.max * adapter->timer_ticks;		\
+	csum = lat->_name.channel.sum * adapter->timer_ticks;		\
+	cmin = lat->_name.channel.min * adapter->timer_ticks;		\
+	cmax = lat->_name.channel.max * adapter->timer_ticks;		\
+	cc  = lat->_name.counter;					\
+	spin_unlock_irqrestore(&lat->lock, flags);			\
+									\
+	do_div(fsum, 1000);						\
+	do_div(fmin, 1000);						\
+	do_div(fmax, 1000);						\
+	do_div(csum, 1000);						\
+	do_div(cmin, 1000);						\
+	do_div(cmax, 1000);						\
+									\
+	return sprintf(buf, "%llu %llu %llu %llu %llu %llu %llu\n",	\
+		       fmin, fmax, fsum, cmin, cmax, csum, cc); 	\
+}									\
+static ssize_t								\
+zfcp_sysfs_unit_##_name##_latency_store(struct device *dev,		\
+					struct device_attribute *attr,	\
+					const char *buf, size_t count)	\
+{									\
+	struct scsi_device *sdev = to_scsi_device(dev);			\
+	struct zfcp_unit *unit = sdev->hostdata;			\
+	struct zfcp_latencies *lat = &unit->latencies;			\
+	unsigned long flags;						\
+									\
+	spin_lock_irqsave(&lat->lock, flags);				\
+	lat->_name.fabric.sum = 0;					\
+	lat->_name.fabric.min = 0xFFFFFFFF;				\
+	lat->_name.fabric.max = 0;					\
+	lat->_name.channel.sum = 0;					\
+	lat->_name.channel.min = 0xFFFFFFFF;				\
+	lat->_name.channel.max = 0;					\
+	lat->_name.counter = 0;						\
+	spin_unlock_irqrestore(&lat->lock, flags);			\
+									\
+	return (ssize_t) count;						\
+}									\
+static DEVICE_ATTR(_name##_latency, S_IWUSR | S_IRUGO,			\
+		   zfcp_sysfs_unit_##_name##_latency_show,		\
+		   zfcp_sysfs_unit_##_name##_latency_store);
+
+ZFCP_DEFINE_LATENCY_ATTR(read);
+ZFCP_DEFINE_LATENCY_ATTR(write);
+ZFCP_DEFINE_LATENCY_ATTR(cmd);
+
 /**
  * ZFCP_DEFINE_SCSI_ATTR
  * @_name:   name of show attribute
@@ -808,6 +870,9 @@ static struct device_attribute *zfcp_sysfs_sdev_attrs[] = {
 	&dev_attr_fcp_lun,
 	&dev_attr_wwpn,
 	&dev_attr_hba_id,
+	&dev_attr_read_latency,
+	&dev_attr_write_latency,
+	&dev_attr_cmd_latency,
 	NULL
 };
 

commit 6d9d63b9480e1c7ea41845646de803c2d3f0eae2
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Thu Apr 24 19:35:54 2008 +0200

    [SCSI] zfcp: Add some statistics provided by the FCP adapter to the sysfs
    
    The new FCP adapter statistics provide a variety of information about
    the virtual adapter (subchannel). In order to collect this information
    the zfcp driver is extended to query this information.
    
    The information provided by the new FCP adapter statistics can be
    fetched by reading from the following files in the sysfs filesystem
    
    /sys/class/scsi_host/host<n>/seconds_active
    /sys/class/scsi_host/host<n>/requests
    /sys/class/scsi_host/host<n>/megabytes
    /sys/class/scsi_host/host<n>/utilization
    
    These are the statistics on a virtual adapter (subchannel) level.
    
    The information provided is raw and not modified or interpreted by any
    means.  No interpretation or modification of the values is done by the
    zfcp driver.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index f81850624eed..01687559dc06 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -40,6 +40,7 @@ static struct zfcp_unit *zfcp_unit_lookup(struct zfcp_adapter *, int,
 					  unsigned int, unsigned int);
 
 static struct device_attribute *zfcp_sysfs_sdev_attrs[];
+static struct device_attribute *zfcp_a_stats_attrs[];
 
 struct zfcp_data zfcp_data = {
 	.scsi_host_template = {
@@ -61,6 +62,7 @@ struct zfcp_data zfcp_data = {
 		.use_clustering		= 1,
 		.sdev_attrs		= zfcp_sysfs_sdev_attrs,
 		.max_sectors		= ZFCP_MAX_SECTORS,
+		.shost_attrs		= zfcp_a_stats_attrs,
 	},
 	.driver_version = ZFCP_VERSION,
 };
@@ -809,4 +811,116 @@ static struct device_attribute *zfcp_sysfs_sdev_attrs[] = {
 	NULL
 };
 
+static ssize_t zfcp_sysfs_adapter_util_show(struct device *dev,
+					    struct device_attribute *attr,
+					    char *buf)
+{
+	struct Scsi_Host *scsi_host = dev_to_shost(dev);
+	struct fsf_qtcb_bottom_port *qtcb_port;
+	int retval;
+	struct zfcp_adapter *adapter;
+
+	adapter = (struct zfcp_adapter *) scsi_host->hostdata[0];
+	if (!(adapter->adapter_features & FSF_FEATURE_MEASUREMENT_DATA))
+		return -EOPNOTSUPP;
+
+	qtcb_port = kzalloc(sizeof(struct fsf_qtcb_bottom_port), GFP_KERNEL);
+	if (!qtcb_port)
+		return -ENOMEM;
+
+	retval = zfcp_fsf_exchange_port_data_sync(adapter, qtcb_port);
+	if (!retval)
+		retval = sprintf(buf, "%u %u %u\n", qtcb_port->cp_util,
+				 qtcb_port->cb_util, qtcb_port->a_util);
+	kfree(qtcb_port);
+	return retval;
+}
+
+static int zfcp_sysfs_adapter_ex_config(struct device *dev,
+					struct fsf_statistics_info *stat_inf)
+{
+	int retval;
+	struct fsf_qtcb_bottom_config *qtcb_config;
+	struct Scsi_Host *scsi_host = dev_to_shost(dev);
+	struct zfcp_adapter *adapter;
+
+	adapter = (struct zfcp_adapter *) scsi_host->hostdata[0];
+	if (!(adapter->adapter_features & FSF_FEATURE_MEASUREMENT_DATA))
+		return -EOPNOTSUPP;
+
+	qtcb_config = kzalloc(sizeof(struct fsf_qtcb_bottom_config),
+			       GFP_KERNEL);
+	if (!qtcb_config)
+		return -ENOMEM;
+
+	retval = zfcp_fsf_exchange_config_data_sync(adapter, qtcb_config);
+	if (!retval)
+		*stat_inf = qtcb_config->stat_info;
+
+	kfree(qtcb_config);
+	return retval;
+}
+
+static ssize_t zfcp_sysfs_adapter_request_show(struct device *dev,
+					       struct device_attribute *attr,
+					       char *buf)
+{
+	struct fsf_statistics_info stat_info;
+	int retval;
+
+	retval = zfcp_sysfs_adapter_ex_config(dev, &stat_info);
+	if (retval)
+		return retval;
+
+	return sprintf(buf, "%llu %llu %llu\n",
+		       (unsigned long long) stat_info.input_req,
+		       (unsigned long long) stat_info.output_req,
+		       (unsigned long long) stat_info.control_req);
+}
+
+static ssize_t zfcp_sysfs_adapter_mb_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct fsf_statistics_info stat_info;
+	int retval;
+
+	retval = zfcp_sysfs_adapter_ex_config(dev, &stat_info);
+	if (retval)
+		return retval;
+
+	return sprintf(buf, "%llu %llu\n",
+		       (unsigned long long) stat_info.input_mb,
+		       (unsigned long long) stat_info.output_mb);
+}
+
+static ssize_t zfcp_sysfs_adapter_sec_active_show(struct device *dev,
+						  struct device_attribute *attr,
+						  char *buf)
+{
+	struct fsf_statistics_info stat_info;
+	int retval;
+
+	retval = zfcp_sysfs_adapter_ex_config(dev, &stat_info);
+	if (retval)
+		return retval;
+
+	return sprintf(buf, "%llu\n",
+		       (unsigned long long) stat_info.seconds_act);
+}
+
+static DEVICE_ATTR(utilization, S_IRUGO, zfcp_sysfs_adapter_util_show, NULL);
+static DEVICE_ATTR(requests, S_IRUGO, zfcp_sysfs_adapter_request_show, NULL);
+static DEVICE_ATTR(megabytes, S_IRUGO, zfcp_sysfs_adapter_mb_show, NULL);
+static DEVICE_ATTR(seconds_active, S_IRUGO,
+		   zfcp_sysfs_adapter_sec_active_show, NULL);
+
+static struct device_attribute *zfcp_a_stats_attrs[] = {
+	&dev_attr_utilization,
+	&dev_attr_requests,
+	&dev_attr_megabytes,
+	&dev_attr_seconds_active,
+	NULL
+};
+
 #undef ZFCP_LOG_AREA

commit 6071d7ec36054e78f02f7d5a66c3784aeb65ce92
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Fri Apr 18 12:51:56 2008 +0200

    [SCSI] zfcp: Remove zfcp_erp_wait from slave destory handler to fix deadlock
    
    The testcase
    # chchp -v 0 0.da && sleep 59 && chchp -v 1 0.da
    results in this deadlock situation:
    
    STACK TRACE FOR TASK: 0x7e9a2048 (zfcperp0.0.c613)
    0 schedule+816 [0x356b3c]
    1 schedule_timeout+172 [0x357340]
    2 wait_for_common+192 [0x3565fc]
    3 flush_cpu_workqueue+116 [0x52af0]
    4 flush_workqueue+116 [0x533b8]
    5 fc_remote_port_add+64 [0x1c83ec]
    6 zfcp_erp_thread+4534 [0x26585a]
    7 kernel_thread_starter+6 [0x195d2]
    
    STACK TRACE FOR TASK: 0x7f8ec048 (fc_wq_0)
    0 schedule+816 [0x356b3c]
    1 zfcp_erp_wait+104 [0x264568]
    2 zfcp_scsi_slave_destroy+64 [0x261b24]
    3 __scsi_remove_device+154 [0x1c24ba]
    4 scsi_remove_device+62 [0x1c2512]
    5 __scsi_remove_target+198 [0x1c25ea]
    6 __remove_child+58 [0x1c26d6]
    7 device_for_each_child+66 [0x1ab566]
    8 scsi_remove_target+98 [0x1c268a]
    9 run_workqueue+200 [0x5272c]
    10 worker_thread+146 [0x52882]
    11 kthread+140 [0x58360]
    12 kernel_thread_starter+6 [0x195d2]
    
    Remove the zfcp_erp_wait call that is not required here to prevent the
    deadlock situation.
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: Martin Peschke <mp3@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 3c9880e46e81..f81850624eed 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -181,7 +181,6 @@ static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 	struct zfcp_unit *unit = (struct zfcp_unit *) sdpnt->hostdata;
 
 	if (unit) {
-		zfcp_erp_wait(unit->port->adapter);
 		atomic_clear_mask(ZFCP_STATUS_UNIT_REGISTERED, &unit->status);
 		sdpnt->hostdata = NULL;
 		unit->device = NULL;

commit 1f6f7129ebac007629b28764bfa5147817682692
Author: Martin Peschke <mp3@de.ibm.com>
Date:   Fri Apr 18 12:51:55 2008 +0200

    [SCSI] zfcp: fix 31 bit compile warnings
    
    drivers/s390/scsi/zfcp_aux.c: In function zfcp_fsf_incoming_els_rscn:
    drivers/s390/scsi/zfcp_aux.c:1379: warning: cast from pointer to integer of
    different size
    drivers/s390/scsi/zfcp_aux.c: In function zfcp_fsf_incoming_els_plogi:
    drivers/s390/scsi/zfcp_aux.c:1432: warning: cast from pointer to integer of
    different size
    drivers/s390/scsi/zfcp_aux.c: In function zfcp_fsf_incoming_els_logo:
    drivers/s390/scsi/zfcp_aux.c:1457: warning: cast from pointer to integer of
    different size
    ..
    
    Just passing pointers rids us of these warnings and improves readability.
    
    Signed-off-by: Martin Peschke <mp3@de.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index cd844b2ad7a1..3c9880e46e81 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -185,7 +185,7 @@ static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 		atomic_clear_mask(ZFCP_STATUS_UNIT_REGISTERED, &unit->status);
 		sdpnt->hostdata = NULL;
 		unit->device = NULL;
-		zfcp_erp_unit_failed(unit, 12, 0);
+		zfcp_erp_unit_failed(unit, 12, NULL);
 		zfcp_unit_put(unit);
 	} else
 		ZFCP_LOG_NORMAL("bug: no unit associated with SCSI device at "
@@ -529,7 +529,7 @@ static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 		unit->fcp_lun, unit->port->wwpn,
 		zfcp_get_busid_by_adapter(unit->port->adapter));
 
-	zfcp_erp_adapter_reopen(adapter, 0, 141, (u64)scpnt);
+	zfcp_erp_adapter_reopen(adapter, 0, 141, scpnt);
 	zfcp_erp_wait(adapter);
 
 	return SUCCESS;

commit 9467a9b3efdd9041202f71cc270bda827a7ec777
Author: Martin Peschke <mp3@de.ibm.com>
Date:   Thu Mar 27 14:22:03 2008 +0100

    [SCSI] zfcp: Trace all triggers of error recovery activity
    
    This patch allows any recovery event to be traced back to an exact
    cause, e.g. a particular request identified by an id (address).
    
    Signed-off-by: Martin Peschke <mp3@de.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 1198f0b27e3a..cd844b2ad7a1 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -529,7 +529,7 @@ static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 		unit->fcp_lun, unit->port->wwpn,
 		zfcp_get_busid_by_adapter(unit->port->adapter));
 
-	zfcp_erp_adapter_reopen(adapter, 0);
+	zfcp_erp_adapter_reopen(adapter, 0, 141, (u64)scpnt);
 	zfcp_erp_wait(adapter);
 
 	return SUCCESS;

commit 698ec01635819c5ae60090bb4efcbeffc41642fb
Author: Martin Peschke <mp3@de.ibm.com>
Date:   Thu Mar 27 14:22:02 2008 +0100

    [SCSI] zfcp: Add traces for state changes.
    
    This patch writes a trace record which provides information about state
    changes for adapters, ports and units, e.g. target failure, targets becoming
    online, targets being temporarily blocked due to pending recovery, targets
    which have been recovered successfully etc.
    
    Signed-off-by: Martin Peschke <mp3@de.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index ff97a61ad964..1198f0b27e3a 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -185,7 +185,7 @@ static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 		atomic_clear_mask(ZFCP_STATUS_UNIT_REGISTERED, &unit->status);
 		sdpnt->hostdata = NULL;
 		unit->device = NULL;
-		zfcp_erp_unit_failed(unit);
+		zfcp_erp_unit_failed(unit, 12, 0);
 		zfcp_unit_put(unit);
 	} else
 		ZFCP_LOG_NORMAL("bug: no unit associated with SCSI device at "

commit 74b2e047ecda7a82c3327a0d0bb45ee2ccf301ca
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Mon Mar 3 12:19:28 2008 +0100

    [SCSI] zfcp: convert zfcp to use target reset and device reset handler
    
    [based on proposal from Mike Christie <michaelc@cs.wisc.edu>, this
    patch adds some simplifications to the handler functions]
    
    With the new target reset handler callback in the SCSI midlayer, the
    device reset handler in zfcp can be split in two parts. Now, zfcp does
    not have to track anymore whether the device supports LUN resets, so
    remove this flag and let the SCSI midlayer decide what to do.
    
    The device reset handler simply issues a LUN reset and the target
    reset handler a target reset.
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index b9daf5c05862..ff97a61ad964 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -31,6 +31,7 @@ static int zfcp_scsi_queuecommand(struct scsi_cmnd *,
 				  void (*done) (struct scsi_cmnd *));
 static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *);
 static int zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *);
+static int zfcp_scsi_eh_target_reset_handler(struct scsi_cmnd *);
 static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *);
 static int zfcp_task_management_function(struct zfcp_unit *, u8,
 					 struct scsi_cmnd *);
@@ -51,6 +52,7 @@ struct zfcp_data zfcp_data = {
 		.queuecommand		= zfcp_scsi_queuecommand,
 		.eh_abort_handler	= zfcp_scsi_eh_abort_handler,
 		.eh_device_reset_handler = zfcp_scsi_eh_device_reset_handler,
+		.eh_target_reset_handler = zfcp_scsi_eh_target_reset_handler,
 		.eh_host_reset_handler	= zfcp_scsi_eh_host_reset_handler,
 		.can_queue		= 4096,
 		.this_id		= -1,
@@ -442,58 +444,32 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	return retval;
 }
 
-static int
-zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)
+static int zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)
 {
 	int retval;
-	struct zfcp_unit *unit = (struct zfcp_unit *) scpnt->device->hostdata;
+	struct zfcp_unit *unit = scpnt->device->hostdata;
 
 	if (!unit) {
-		ZFCP_LOG_NORMAL("bug: Tried reset for nonexistent unit\n");
-		retval = SUCCESS;
-		goto out;
+		WARN_ON(1);
+		return SUCCESS;
 	}
-	ZFCP_LOG_NORMAL("resetting unit 0x%016Lx on port 0x%016Lx, adapter %s\n",
-			unit->fcp_lun, unit->port->wwpn,
-			zfcp_get_busid_by_adapter(unit->port->adapter));
+	retval = zfcp_task_management_function(unit,
+					       FCP_LOGICAL_UNIT_RESET,
+					       scpnt);
+	return retval ? FAILED : SUCCESS;
+}
 
-	/*
-	 * If we do not know whether the unit supports 'logical unit reset'
-	 * then try 'logical unit reset' and proceed with 'target reset'
-	 * if 'logical unit reset' fails.
-	 * If the unit is known not to support 'logical unit reset' then
-	 * skip 'logical unit reset' and try 'target reset' immediately.
-	 */
-	if (!atomic_test_mask(ZFCP_STATUS_UNIT_NOTSUPPUNITRESET,
-			      &unit->status)) {
-		retval = zfcp_task_management_function(unit,
-						       FCP_LOGICAL_UNIT_RESET,
-						       scpnt);
-		if (retval) {
-			ZFCP_LOG_DEBUG("unit reset failed (unit=%p)\n", unit);
-			if (retval == -ENOTSUPP)
-				atomic_set_mask
-				    (ZFCP_STATUS_UNIT_NOTSUPPUNITRESET,
-				     &unit->status);
-			/* fall through and try 'target reset' next */
-		} else {
-			ZFCP_LOG_DEBUG("unit reset succeeded (unit=%p)\n",
-				       unit);
-			/* avoid 'target reset' */
-			retval = SUCCESS;
-			goto out;
-		}
+static int zfcp_scsi_eh_target_reset_handler(struct scsi_cmnd *scpnt)
+{
+	int retval;
+	struct zfcp_unit *unit = scpnt->device->hostdata;
+
+	if (!unit) {
+		WARN_ON(1);
+		return SUCCESS;
 	}
 	retval = zfcp_task_management_function(unit, FCP_TARGET_RESET, scpnt);
-	if (retval) {
-		ZFCP_LOG_DEBUG("target reset failed (unit=%p)\n", unit);
-		retval = FAILED;
-	} else {
-		ZFCP_LOG_DEBUG("target reset succeeded (unit=%p)\n", unit);
-		retval = SUCCESS;
-	}
- out:
-	return retval;
+	return retval ? FAILED : SUCCESS;
 }
 
 static int

commit ba1724202aafed4bbc4a239ac6fb433f454fddea
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Thu Dec 20 12:30:26 2007 +0100

    [SCSI] zfcp: Hold queue lock when checking port/unit handle for FCP command
    
    We need to hold the queue-lock when checking whether we still have a valid
    unit/port handle for the FCP command, i.e whether we can issue this request for
    this unit/port. If the error recovery is about to close this unit/port, then it
    competes for the queue-lock. If the close request issued by the error recovery
    wins, then it is guaranteed that this unit/port has been blocked for other
    requests.
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: Martin Peschke <mp3@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 3298fd35000c..b9daf5c05862 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -258,8 +258,9 @@ zfcp_scsi_command_async(struct zfcp_adapter *adapter, struct zfcp_unit *unit,
 		goto out;
 	}
 
-	if (unlikely(
-	     !atomic_test_mask(ZFCP_STATUS_COMMON_UNBLOCKED, &unit->status))) {
+	tmp = zfcp_fsf_send_fcp_command_task(adapter, unit, scpnt, use_timer,
+					     ZFCP_REQ_AUTO_CLEANUP);
+	if (unlikely(tmp == -EBUSY)) {
 		ZFCP_LOG_DEBUG("adapter %s not ready or unit 0x%016Lx "
 			       "on port 0x%016Lx in recovery\n",
 			       zfcp_get_busid_by_unit(unit),
@@ -268,9 +269,6 @@ zfcp_scsi_command_async(struct zfcp_adapter *adapter, struct zfcp_unit *unit,
 		goto out;
 	}
 
-	tmp = zfcp_fsf_send_fcp_command_task(adapter, unit, scpnt, use_timer,
-					     ZFCP_REQ_AUTO_CLEANUP);
-
 	if (unlikely(tmp < 0)) {
 		ZFCP_LOG_DEBUG("error: initiation of Send FCP Cmnd failed\n");
 		retval = SCSI_MLQUEUE_HOST_BUSY;

commit 1de1b43b5f0bb536126e31f07ec833e01969ed1c
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Mon Nov 5 12:37:47 2007 +0100

    [SCSI] zfcp: Fix deadlock when adding invalid LUN
    
    When adding an invalid LUN, there is a deadlock between the add
    via scsi_scan_target and the slave_destroy handler: The handler
    waits for the scan to complete, but for an invalid unit,
    scsi_scan_target directly calls the slave_destroy handler.
    
    Fix the deadlock by removing the wait in the slave_destroy
    handler, it was not necessary anyway.
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index c6b6295395b0..3298fd35000c 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -180,9 +180,6 @@ static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 
 	if (unit) {
 		zfcp_erp_wait(unit->port->adapter);
-		wait_event(unit->scsi_scan_wq,
-			   atomic_test_mask(ZFCP_STATUS_UNIT_SCSI_WORK_PENDING,
-					    &unit->status) == 0);
 		atomic_clear_mask(ZFCP_STATUS_UNIT_REGISTERED, &unit->status);
 		sdpnt->hostdata = NULL;
 		unit->device = NULL;

commit 345bfea5e424f086b654294eddcfa3f8ff92b47f
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Mon Nov 5 12:37:44 2007 +0100

    [SCSI] zfcp: Use also port and adapter to identify unit in messages.
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 28e2b52bf851..c6b6295395b0 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -458,7 +458,9 @@ zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)
 		retval = SUCCESS;
 		goto out;
 	}
-	ZFCP_LOG_NORMAL("resetting unit 0x%016Lx\n", unit->fcp_lun);
+	ZFCP_LOG_NORMAL("resetting unit 0x%016Lx on port 0x%016Lx, adapter %s\n",
+			unit->fcp_lun, unit->port->wwpn,
+			zfcp_get_busid_by_adapter(unit->port->adapter));
 
 	/*
 	 * If we do not know whether the unit supports 'logical unit reset'
@@ -552,7 +554,9 @@ static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 	adapter = unit->port->adapter;
 
 	ZFCP_LOG_NORMAL("host reset because of problems with "
-			"unit 0x%016Lx\n", unit->fcp_lun);
+		"unit 0x%016Lx on port 0x%016Lx, adapter %s\n",
+		unit->fcp_lun, unit->port->wwpn,
+		zfcp_get_busid_by_adapter(unit->port->adapter));
 
 	zfcp_erp_adapter_reopen(adapter, 0);
 	zfcp_erp_wait(adapter);

commit a11b4743e58f53213acdd16e3a0004d035aa45f0
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Mon Nov 5 12:37:43 2007 +0100

    [SCSI] zfcp: Remove unnecessary eh_bus_reset_handler callback
    
    The callback function used by zfcp always returns success,
    which is an indication for the SCSI midlayer to stop error
    handling. Remove the bus_reset callback, since the same
    function will be called via the host_reset callback.
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index abae2027f7e5..28e2b52bf851 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -51,7 +51,6 @@ struct zfcp_data zfcp_data = {
 		.queuecommand		= zfcp_scsi_queuecommand,
 		.eh_abort_handler	= zfcp_scsi_eh_abort_handler,
 		.eh_device_reset_handler = zfcp_scsi_eh_device_reset_handler,
-		.eh_bus_reset_handler	= zfcp_scsi_eh_host_reset_handler,
 		.eh_host_reset_handler	= zfcp_scsi_eh_host_reset_handler,
 		.can_queue		= 4096,
 		.this_id		= -1,
@@ -542,7 +541,7 @@ zfcp_task_management_function(struct zfcp_unit *unit, u8 tm_flags,
 }
 
 /**
- * zfcp_scsi_eh_host_reset_handler - handler for host and bus reset
+ * zfcp_scsi_eh_host_reset_handler - handler for host reset
  */
 static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 {
@@ -552,7 +551,7 @@ static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 	unit = (struct zfcp_unit*) scpnt->device->hostdata;
 	adapter = unit->port->adapter;
 
-	ZFCP_LOG_NORMAL("host/bus reset because of problems with "
+	ZFCP_LOG_NORMAL("host reset because of problems with "
 			"unit 0x%016Lx\n", unit->fcp_lun);
 
 	zfcp_erp_adapter_reopen(adapter, 0);

commit 41fa2adabc0a750a40d6fe86d5ce2f75fb3ad287
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Fri Sep 7 09:15:31 2007 +0200

    [SCSI] zfcp: whitespace cleanup
    
    Cleanup the whitepace from the entire zfcp driver to prevent
    to have those changes in future feature or function patches.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 5fbbd21a88e4..abae2027f7e5 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -1,22 +1,22 @@
-/* 
+/*
  * This file is part of the zfcp device driver for
  * FCP adapters for IBM System z9 and zSeries.
  *
  * (C) Copyright IBM Corp. 2002, 2006
- * 
- * This program is free software; you can redistribute it and/or modify 
- * it under the terms of the GNU General Public License as published by 
- * the Free Software Foundation; either version 2, or (at your option) 
- * any later version. 
- * 
- * This program is distributed in the hope that it will be useful, 
- * but WITHOUT ANY WARRANTY; without even the implied warranty of 
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
- * GNU General Public License for more details. 
- * 
- * You should have received a copy of the GNU General Public License 
- * along with this program; if not, write to the Free Software 
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #define ZFCP_LOG_AREA			ZFCP_LOG_AREA_SCSI
@@ -101,7 +101,7 @@ zfcp_get_fcp_dl_ptr(struct fcp_cmnd_iu * fcp_cmd)
 		((unsigned char *) fcp_cmd +
 		 sizeof (struct fcp_cmnd_iu) + additional_length);
 	/*
-	 * fcp_dl_addr = start address of fcp_cmnd structure + 
+	 * fcp_dl_addr = start address of fcp_cmnd structure +
 	 * size of fixed part + size of dynamically sized add_dcp_cdb field
 	 * SEE FCP-2 documentation
 	 */
@@ -194,7 +194,7 @@ static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 				"address %p\n", sdpnt);
 }
 
-/* 
+/*
  * called from scsi midlayer to allow finetuning of a device.
  */
 static int
@@ -372,7 +372,7 @@ zfcp_unit_lookup(struct zfcp_adapter *adapter, int channel, unsigned int id,
 
 /**
  * zfcp_scsi_eh_abort_handler - abort the specified SCSI command
- * @scpnt: pointer to scsi_cmnd to be aborted 
+ * @scpnt: pointer to scsi_cmnd to be aborted
  * Return: SUCCESS - command has been aborted and cleaned up in internal
  *          bookkeeping, SCSI stack won't be called for aborted command
  *         FAILED - otherwise

commit 52ef11a7170e1b8a0d5f9a42dbb43c38c335c32e
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Tue Aug 28 09:31:09 2007 +0200

    [SCSI] zfcp: cleanup, separation of ERP, non ERP-version for exchange_ functions
    
    cleanup, using ERP request mempool for all ERP versions of
    the exchange functions (exchange_config (ECD), exchange_port (EPD) )
    providing individual versions of the ECD, EPD functions for ERP
    and other purposes (_sync).
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 3a7f3b87fb36..5fbbd21a88e4 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -731,7 +731,7 @@ zfcp_get_fc_host_stats(struct Scsi_Host *shost)
 	if (!data)
 		return NULL;
 
-	ret = zfcp_fsf_exchange_port_data(NULL, adapter, data);
+	ret = zfcp_fsf_exchange_port_data_sync(adapter, data);
 	if (ret) {
 		kfree(data);
 		return NULL; /* XXX return zeroed fc_stats? */
@@ -761,7 +761,7 @@ zfcp_reset_fc_host_stats(struct Scsi_Host *shost)
 	if (!data)
 		return;
 
-	ret = zfcp_fsf_exchange_port_data(NULL, adapter, data);
+	ret = zfcp_fsf_exchange_port_data_sync(adapter, data);
 	if (ret) {
 		kfree(data);
 	} else {
@@ -800,6 +800,7 @@ struct fc_function_template zfcp_transport_functions = {
 	.show_host_port_type = 1,
 	.show_host_speed = 1,
 	.show_host_port_id = 1,
+	.disable_target_scan = 1,
 };
 
 /**

commit 6b76a72141c57260adaf07977f79760ddb8618ee
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue Aug 28 09:30:59 2007 +0200

    [SCSI] zfcp: Remove braces for only one statement
    
    Remove braces for only one statement
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index ad7eb4a9261c..3a7f3b87fb36 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -189,10 +189,9 @@ static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 		unit->device = NULL;
 		zfcp_erp_unit_failed(unit);
 		zfcp_unit_put(unit);
-	} else {
+	} else
 		ZFCP_LOG_NORMAL("bug: no unit associated with SCSI device at "
 				"address %p\n", sdpnt);
-	}
 }
 
 /* 
@@ -361,12 +360,11 @@ zfcp_unit_lookup(struct zfcp_adapter *adapter, int channel, unsigned int id,
 	list_for_each_entry(port, &adapter->port_list_head, list) {
 		if (!port->rport || (id != port->rport->scsi_target_id))
 			continue;
-		list_for_each_entry(unit, &port->unit_list_head, list) {
+		list_for_each_entry(unit, &port->unit_list_head, list)
 			if (lun == unit->scsi_lun) {
 				retval = unit;
 				goto out;
 			}
-		}
 	}
  out:
 	return retval;

commit 83f6d6d7258974a99cbf465878bc11eb4d494c61
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Wed Aug 8 10:47:02 2007 +0200

    [SCSI] zfcp: fix memory leak
    
    fix memory leak.
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 0acf6db0a08d..ad7eb4a9261c 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -764,7 +764,9 @@ zfcp_reset_fc_host_stats(struct Scsi_Host *shost)
 		return;
 
 	ret = zfcp_fsf_exchange_port_data(NULL, adapter, data);
-	if (ret == 0) {
+	if (ret) {
+		kfree(data);
+	} else {
 		adapter->stats_reset = jiffies/HZ;
 		old_data = adapter->stats_reset_data;
 		adapter->stats_reset_data = data; /* finally freed in

commit 9f28745a6b554fdd6b0dbc9856077701a55f9569
Author: Michael Loehr <mloehr2@linux.vnet.ibm.com>
Date:   Wed May 9 11:01:24 2007 +0200

    [SCSI] zfcp: IO stall after deleting and path checker changes after reenabling zfcp devices
    
    IO stall after deleting and path checker changes after reenabling zfcp device
    
    Setting one zfcp device offline using chccwdev in a multipath
    environment and waiting will lead to IO stall on all paths.
    After setting the zfcp device back online using chccwdev,
    the devices with io stall will have a different path checker.
    Devices corresponding to the deleted units are never freed.
    This has the effect that 'slave_destroy' is never called and zfcp
    still thinks that this unit is registered
    (ZFCP_STATUS_UNIT_REGISTERED is still set). Hence the erp
    routine is not called correctly and the unit is not enabled properly.
    
    Do not delete rport and the sdev. Just set the host to block on
    'offline'. Setting host online again will then remove the blocked status
    and everything is fine again.
    
    Signed-off-by: Michael Loehr <mloehr2@linux.vnet.ibm.com>
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 16e2d64658af..0acf6db0a08d 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -569,6 +569,9 @@ zfcp_adapter_scsi_register(struct zfcp_adapter *adapter)
 	int retval = 0;
 	static unsigned int unique_id = 0;
 
+	if (adapter->scsi_host)
+		goto out;
+
 	/* register adapter as SCSI host with mid layer of SCSI stack */
 	adapter->scsi_host = scsi_host_alloc(&zfcp_data.scsi_host_template,
 					     sizeof (struct zfcp_adapter *));

commit ca2d02c2f9ea476062ae181eec60b8bcd97857d6
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Tue May 8 11:17:54 2007 +0200

    [SCSI] zfcp: rework request ID management.
    
    Simplify request ID management and make sure that frequently used
    functions are inlined. Also fix a memory leak in zfcp_adapter_enqueue()
    which only gets hit in error handling.
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index e742b3de16ac..16e2d64658af 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -407,8 +407,8 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 
 	/* Check whether corresponding fsf_req is still pending */
 	spin_lock(&adapter->req_list_lock);
-	fsf_req = zfcp_reqlist_ismember(adapter, (unsigned long)
-					scpnt->host_scribble);
+	fsf_req = zfcp_reqlist_find(adapter,
+				    (unsigned long) scpnt->host_scribble);
 	spin_unlock(&adapter->req_list_lock);
 	if (!fsf_req) {
 		write_unlock_irqrestore(&adapter->abort_lock, flags);

commit 5f852be9e11d62223ea063f6ceed4f9677f54051
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue May 8 11:16:52 2007 +0200

    [SCSI] zfcp: Fix deadlock between zfcp ERP and SCSI
    
    The SCSI stack requires low level drivers to register and
    unregister devices. For zfcp this leads to the situation where
    zfcp calls the SCSI stack, the SCSI tries to scan the new device
    and the scan SCSI command fails. This would require the zfcp erp,
    but the erp thread is already blocked in the register call.
    
    The fix is to make sure that the calls from the ERP thread to
    the SCSI stack do not block the ERP thread. In detail:
    1) Use a workqueue to avoid blocking of the scsi_scan_target calls.
    2) When removing a unit make sure that no scsi_scan_target call is
       pending.
    3) Replace scsi_flush_work with scsi_target_unblock. This avoids
       blocking and has the same result.
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 99db02062c3b..e742b3de16ac 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -22,6 +22,7 @@
 #define ZFCP_LOG_AREA			ZFCP_LOG_AREA_SCSI
 
 #include "zfcp_ext.h"
+#include <asm/atomic.h>
 
 static void zfcp_scsi_slave_destroy(struct scsi_device *sdp);
 static int zfcp_scsi_slave_alloc(struct scsi_device *sdp);
@@ -179,6 +180,10 @@ static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 	struct zfcp_unit *unit = (struct zfcp_unit *) sdpnt->hostdata;
 
 	if (unit) {
+		zfcp_erp_wait(unit->port->adapter);
+		wait_event(unit->scsi_scan_wq,
+			   atomic_test_mask(ZFCP_STATUS_UNIT_SCSI_WORK_PENDING,
+					    &unit->status) == 0);
 		atomic_clear_mask(ZFCP_STATUS_UNIT_REGISTERED, &unit->status);
 		sdpnt->hostdata = NULL;
 		unit->device = NULL;

commit 2b67fc46061b2171fb8fbb55d1ac717abd533569
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Mon Feb 5 21:16:47 2007 +0100

    [S390] Get rid of a lot of sparse warnings.
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 452d96f92a14..99db02062c3b 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -90,7 +90,7 @@ zfcp_get_fcp_sns_info_ptr(struct fcp_rsp_iu *fcp_rsp_iu)
 	return fcp_sns_info_ptr;
 }
 
-fcp_dl_t *
+static fcp_dl_t *
 zfcp_get_fcp_dl_ptr(struct fcp_cmnd_iu * fcp_cmd)
 {
 	int additional_length = fcp_cmd->add_fcp_cdb_length << 2;
@@ -124,19 +124,19 @@ zfcp_set_fcp_dl(struct fcp_cmnd_iu *fcp_cmd, fcp_dl_t fcp_dl)
  * regarding the specified byte
  */
 static inline void
-set_byte(u32 * result, char status, char pos)
+set_byte(int *result, char status, char pos)
 {
 	*result |= status << (pos * 8);
 }
 
 void
-set_host_byte(u32 * result, char status)
+set_host_byte(int *result, char status)
 {
 	set_byte(result, status, 2);
 }
 
 void
-set_driver_byte(u32 * result, char status)
+set_driver_byte(int *result, char status)
 {
 	set_byte(result, status, 3);
 }
@@ -280,7 +280,7 @@ zfcp_scsi_command_async(struct zfcp_adapter *adapter, struct zfcp_unit *unit,
 	return retval;
 }
 
-void
+static void
 zfcp_scsi_command_sync_handler(struct scsi_cmnd *scpnt)
 {
 	struct completion *wait = (struct completion *) scpnt->SCp.ptr;
@@ -324,7 +324,7 @@ zfcp_scsi_command_sync(struct zfcp_unit *unit, struct scsi_cmnd *scpnt,
  * returns:	0 - success, SCSI command enqueued
  *		!0 - failure
  */
-int
+static int
 zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 		       void (*done) (struct scsi_cmnd *))
 {
@@ -380,7 +380,7 @@ zfcp_unit_lookup(struct zfcp_adapter *adapter, int channel, unsigned int id,
  * will handle late commands.  (Usually, the normal completion of late
  * commands is ignored with respect to the running abort operation.)
  */
-int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
+static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 {
  	struct Scsi_Host *scsi_host;
  	struct zfcp_adapter *adapter;
@@ -445,7 +445,7 @@ int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	return retval;
 }
 
-int
+static int
 zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)
 {
 	int retval;
@@ -541,7 +541,7 @@ zfcp_task_management_function(struct zfcp_unit *unit, u8 tm_flags,
 /**
  * zfcp_scsi_eh_host_reset_handler - handler for host and bus reset
  */
-int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
+static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 {
 	struct zfcp_unit *unit;
 	struct zfcp_adapter *adapter;

commit 8d1a006049ff1c084d57fbea1106ecad3455bd27
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Thu Oct 12 11:43:44 2006 +0200

    [SCSI] zfcp: initialize scsi_host_template.max_sectors with appropriate value
    
    Define ZFCP_MAX_SECTORS and initialize scsi_host_template.max_sectors
    with appropriate value.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 4d2bc7981324..452d96f92a14 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -58,6 +58,7 @@ struct zfcp_data zfcp_data = {
 		.cmd_per_lun		= 1,
 		.use_clustering		= 1,
 		.sdev_attrs		= zfcp_sysfs_sdev_attrs,
+		.max_sectors		= ZFCP_MAX_SECTORS,
 	},
 	.driver_version = ZFCP_VERSION,
 };

commit 6e9a4738c9fadb7cbdcabc1e3b415159f3741ed9
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Sat Sep 30 23:28:10 2006 -0700

    [PATCH] completions: lockdep annotate on stack completions
    
    All on stack DECLARE_COMPLETIONs should be replaced by:
    DECLARE_COMPLETION_ONSTACK
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 7cafa34e4c7f..4d2bc7981324 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -301,7 +301,7 @@ zfcp_scsi_command_sync(struct zfcp_unit *unit, struct scsi_cmnd *scpnt,
 		       int use_timer)
 {
 	int ret;
-	DECLARE_COMPLETION(wait);
+	DECLARE_COMPLETION_ONSTACK(wait);
 
 	scpnt->SCp.ptr = (void *) &wait;  /* silent re-use */
 	scpnt->scsi_done = zfcp_scsi_command_sync_handler;

commit 8165428610446ea9e6aa9dfa5485ab78e58cc9fc
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Mon Sep 18 22:30:36 2006 +0200

    [SCSI] zfcp: fix: avoid removal of fsf reqs before qdio queues are down
    
    Fix the fix ... One of my previous fixes introduced removal of all fsf
    requests in zfcp's eh_host_reset_handler. But this must not happen
    before qdio queues are shut down. So, I revert the changes of
    zfcp_scsi_eh_host_reset_handler.
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 753bb9b2fe74..7cafa34e4c7f 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -544,7 +544,6 @@ int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 {
 	struct zfcp_unit *unit;
 	struct zfcp_adapter *adapter;
-	unsigned long flags;
 
 	unit = (struct zfcp_unit*) scpnt->device->hostdata;
 	adapter = unit->port->adapter;
@@ -552,22 +551,8 @@ int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 	ZFCP_LOG_NORMAL("host/bus reset because of problems with "
 			"unit 0x%016Lx\n", unit->fcp_lun);
 
-	write_lock_irqsave(&adapter->erp_lock, flags);
-	if (atomic_test_mask(ZFCP_STATUS_ADAPTER_ERP_PENDING,
-			     &adapter->status)) {
-		zfcp_erp_modify_adapter_status(adapter,
-		       ZFCP_STATUS_COMMON_UNBLOCKED|ZFCP_STATUS_COMMON_OPEN,
-		       ZFCP_CLEAR);
-		zfcp_erp_action_dismiss_adapter(adapter);
-		write_unlock_irqrestore(&adapter->erp_lock, flags);
-		zfcp_fsf_req_dismiss_all(adapter);
-		adapter->fsf_req_seq_no = 0;
-		zfcp_erp_adapter_reopen(adapter, 0);
-	} else {
-		write_unlock_irqrestore(&adapter->erp_lock, flags);
-		zfcp_erp_adapter_reopen(adapter, 0);
-		zfcp_erp_wait(adapter);
-	}
+	zfcp_erp_adapter_reopen(adapter, 0);
+	zfcp_erp_wait(adapter);
 
 	return SUCCESS;
 }

commit 2abbe866c8eb0296e3f5343bcf73e5371522a738
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Mon Sep 18 22:29:56 2006 +0200

    [SCSI] zfcp: introduce struct timer_list in struct zfcp_fsf_req
    
    This instance will be used whenever a timer is needed for
    a request by zfcp.
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 043ed7c0a7ed..753bb9b2fe74 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -231,7 +231,7 @@ zfcp_scsi_command_fail(struct scsi_cmnd *scpnt, int result)
  */
 int
 zfcp_scsi_command_async(struct zfcp_adapter *adapter, struct zfcp_unit *unit,
-			struct scsi_cmnd *scpnt, struct timer_list *timer)
+			struct scsi_cmnd *scpnt, int use_timer)
 {
 	int tmp;
 	int retval;
@@ -267,7 +267,7 @@ zfcp_scsi_command_async(struct zfcp_adapter *adapter, struct zfcp_unit *unit,
 		goto out;
 	}
 
-	tmp = zfcp_fsf_send_fcp_command_task(adapter, unit, scpnt, timer,
+	tmp = zfcp_fsf_send_fcp_command_task(adapter, unit, scpnt, use_timer,
 					     ZFCP_REQ_AUTO_CLEANUP);
 
 	if (unlikely(tmp < 0)) {
@@ -291,21 +291,22 @@ zfcp_scsi_command_sync_handler(struct scsi_cmnd *scpnt)
  * zfcp_scsi_command_sync - send a SCSI command and wait for completion
  * @unit: unit where command is sent to
  * @scpnt: scsi command to be sent
- * @timer: timer to be started if request is successfully initiated
+ * @use_timer: indicates whether timer should be setup or not
  * Return: 0
  *
  * Errors are indicated in scpnt->result
  */
 int
 zfcp_scsi_command_sync(struct zfcp_unit *unit, struct scsi_cmnd *scpnt,
-		       struct timer_list *timer)
+		       int use_timer)
 {
 	int ret;
 	DECLARE_COMPLETION(wait);
 
 	scpnt->SCp.ptr = (void *) &wait;  /* silent re-use */
 	scpnt->scsi_done = zfcp_scsi_command_sync_handler;
-	ret = zfcp_scsi_command_async(unit->port->adapter, unit, scpnt, timer);
+	ret = zfcp_scsi_command_async(unit->port->adapter, unit, scpnt,
+				      use_timer);
 	if (ret == 0)
 		wait_for_completion(&wait);
 
@@ -341,7 +342,7 @@ zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 	adapter = (struct zfcp_adapter *) scpnt->device->host->hostdata[0];
 	unit = (struct zfcp_unit *) scpnt->device->hostdata;
 
-	return zfcp_scsi_command_async(adapter, unit, scpnt, NULL);
+	return zfcp_scsi_command_async(adapter, unit, scpnt, 0);
 }
 
 static struct zfcp_unit *
@@ -538,8 +539,6 @@ zfcp_task_management_function(struct zfcp_unit *unit, u8 tm_flags,
 
 /**
  * zfcp_scsi_eh_host_reset_handler - handler for host and bus reset
- *
- * If ERP is already running it will be stopped.
  */
 int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 {
@@ -638,16 +637,6 @@ zfcp_adapter_scsi_unregister(struct zfcp_adapter *adapter)
 	return;
 }
 
-
-void
-zfcp_fsf_start_scsi_er_timer(struct zfcp_adapter *adapter)
-{
-	adapter->scsi_er_timer.function = zfcp_fsf_scsi_er_timeout_handler;
-	adapter->scsi_er_timer.data = (unsigned long) adapter;
-	adapter->scsi_er_timer.expires = jiffies + ZFCP_SCSI_ER_TIMEOUT;
-	add_timer(&adapter->scsi_er_timer);
-}
-
 /*
  * Support functions for FC transport class
  */

commit 4eff4a36516d72e4f6ede901141214a7e05607e7
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Mon Sep 18 22:29:20 2006 +0200

    [SCSI] zfcp: fix: use correct req_id in eh_abort_handler
    
    zfcp's eh_abort_handler used the wrong request ID to
    identify the request to be aborted. The bug was introduced
    with commit fea9d6c7bcd8ff1d60ff74f27ba483b3820b18a3
    for improved management of request IDs. The bug is
    fixed with this patch.
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 4857cccb1d5b..043ed7c0a7ed 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -378,16 +378,15 @@ zfcp_unit_lookup(struct zfcp_adapter *adapter, int channel, unsigned int id,
  * will handle late commands.  (Usually, the normal completion of late
  * commands is ignored with respect to the running abort operation.)
  */
-int
-zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
+int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 {
  	struct Scsi_Host *scsi_host;
  	struct zfcp_adapter *adapter;
 	struct zfcp_unit *unit;
-	int retval = SUCCESS;
-	struct zfcp_fsf_req *new_fsf_req = NULL;
-	struct zfcp_fsf_req *old_fsf_req;
+	struct zfcp_fsf_req *fsf_req;
 	unsigned long flags;
+	unsigned long old_req_id;
+	int retval = SUCCESS;
 
 	scsi_host = scpnt->device->host;
 	adapter = (struct zfcp_adapter *) scsi_host->hostdata[0];
@@ -399,55 +398,47 @@ zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	/* avoid race condition between late normal completion and abort */
 	write_lock_irqsave(&adapter->abort_lock, flags);
 
-	/*
-	 * Check whether command has just completed and can not be aborted.
-	 * Even if the command has just been completed late, we can access
-	 * scpnt since the SCSI stack does not release it at least until
-	 * this routine returns. (scpnt is parameter passed to this routine
-	 * and must not disappear during abort even on late completion.)
-	 */
-	old_fsf_req = (struct zfcp_fsf_req *) scpnt->host_scribble;
-	if (!old_fsf_req) {
+	/* Check whether corresponding fsf_req is still pending */
+	spin_lock(&adapter->req_list_lock);
+	fsf_req = zfcp_reqlist_ismember(adapter, (unsigned long)
+					scpnt->host_scribble);
+	spin_unlock(&adapter->req_list_lock);
+	if (!fsf_req) {
 		write_unlock_irqrestore(&adapter->abort_lock, flags);
-		zfcp_scsi_dbf_event_abort("lte1", adapter, scpnt, NULL, NULL);
+		zfcp_scsi_dbf_event_abort("lte1", adapter, scpnt, NULL, 0);
 		retval = SUCCESS;
 		goto out;
 	}
-	old_fsf_req->data = 0;
-	old_fsf_req->status |= ZFCP_STATUS_FSFREQ_ABORTING;
+	fsf_req->data = 0;
+	fsf_req->status |= ZFCP_STATUS_FSFREQ_ABORTING;
+	old_req_id = fsf_req->req_id;
 
-	/* don't access old_fsf_req after releasing the abort_lock */
+	/* don't access old fsf_req after releasing the abort_lock */
 	write_unlock_irqrestore(&adapter->abort_lock, flags);
-	/* call FSF routine which does the abort */
-	new_fsf_req = zfcp_fsf_abort_fcp_command((unsigned long) old_fsf_req,
-						 adapter, unit, 0);
-	if (!new_fsf_req) {
+
+	fsf_req = zfcp_fsf_abort_fcp_command(old_req_id, adapter, unit, 0);
+	if (!fsf_req) {
 		ZFCP_LOG_INFO("error: initiation of Abort FCP Cmnd failed\n");
 		zfcp_scsi_dbf_event_abort("nres", adapter, scpnt, NULL,
-					  old_fsf_req);
+					  old_req_id);
 		retval = FAILED;
 		goto out;
 	}
 
-	/* wait for completion of abort */
-	__wait_event(new_fsf_req->completion_wq,
-		     new_fsf_req->status & ZFCP_STATUS_FSFREQ_COMPLETED);
+	__wait_event(fsf_req->completion_wq,
+		     fsf_req->status & ZFCP_STATUS_FSFREQ_COMPLETED);
 
-	/* status should be valid since signals were not permitted */
-	if (new_fsf_req->status & ZFCP_STATUS_FSFREQ_ABORTSUCCEEDED) {
-		zfcp_scsi_dbf_event_abort("okay", adapter, scpnt, new_fsf_req,
-					  NULL);
+	if (fsf_req->status & ZFCP_STATUS_FSFREQ_ABORTSUCCEEDED) {
+		zfcp_scsi_dbf_event_abort("okay", adapter, scpnt, fsf_req, 0);
 		retval = SUCCESS;
-	} else if (new_fsf_req->status & ZFCP_STATUS_FSFREQ_ABORTNOTNEEDED) {
-		zfcp_scsi_dbf_event_abort("lte2", adapter, scpnt, new_fsf_req,
-					  NULL);
+	} else if (fsf_req->status & ZFCP_STATUS_FSFREQ_ABORTNOTNEEDED) {
+		zfcp_scsi_dbf_event_abort("lte2", adapter, scpnt, fsf_req, 0);
 		retval = SUCCESS;
 	} else {
-		zfcp_scsi_dbf_event_abort("fail", adapter, scpnt, new_fsf_req,
-					  NULL);
+		zfcp_scsi_dbf_event_abort("fail", adapter, scpnt, fsf_req, 0);
 		retval = FAILED;
 	}
-	zfcp_fsf_req_free(new_fsf_req);
+	zfcp_fsf_req_free(fsf_req);
  out:
 	return retval;
 }

commit dd52e0eaf891cd85bf2ca057c15ed6bfd76db4e6
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Mon Sep 18 22:28:49 2006 +0200

    [SCSI] zfcp: create private slab caches to guarantee proper data alignment
    
    Create private slab caches in order to guarantee proper alignment of
    data structures that get passed to hardware.
    
    Sidenote: with this patch slab cache debugging will finally work on s390
    (at least no known problems left).
    
    Furthermore this patch does some minor cleanups:
    - store ptr for transport template in struct zfcp_data
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Compile fix ups and
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 1bb55086db9f..4857cccb1d5b 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -39,11 +39,10 @@ static struct zfcp_unit *zfcp_unit_lookup(struct zfcp_adapter *, int,
 
 static struct device_attribute *zfcp_sysfs_sdev_attrs[];
 
-struct scsi_transport_template *zfcp_transport_template;
-
 struct zfcp_data zfcp_data = {
 	.scsi_host_template = {
 		.name			= ZFCP_NAME,
+		.module			= THIS_MODULE,
 		.proc_name		= "zfcp",
 		.slave_alloc		= zfcp_scsi_slave_alloc,
 		.slave_configure	= zfcp_scsi_slave_configure,
@@ -607,7 +606,7 @@ zfcp_adapter_scsi_register(struct zfcp_adapter *adapter)
 	adapter->scsi_host->max_channel = 0;
 	adapter->scsi_host->unique_id = unique_id++;	/* FIXME */
 	adapter->scsi_host->max_cmd_len = ZFCP_MAX_SCSI_CMND_LENGTH;
-	adapter->scsi_host->transportt = zfcp_transport_template;
+	adapter->scsi_host->transportt = zfcp_data.scsi_transport_template;
 
 	/*
 	 * save a pointer to our own adapter data structure within

commit f6c0e7a7b3b6db15146877c0cef43b413af5b76e
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Wed Aug 2 11:05:52 2006 +0200

    [SCSI] zfcp: minor erp bug fixes
    
    Bug fixes for zfcp's erp:
    - trigger adapter reopen if do_QDIO fails
    - avoid erp deadlock if registration of scsi target or remote port hang
    - do not treat as error if exchange port data fails
    - decrease timeout for target reset and aborts
    - mark unit failed if slave_destroy is called
    
    Additionally some code cleanup was done:
    - made some functions void when retval is not of interest
    - shortened initialization of zfcp's host_template
    - corrected some comments
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 671f4a6a5d18..1bb55086db9f 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -30,7 +30,6 @@ static int zfcp_scsi_queuecommand(struct scsi_cmnd *,
 				  void (*done) (struct scsi_cmnd *));
 static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *);
 static int zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *);
-static int zfcp_scsi_eh_bus_reset_handler(struct scsi_cmnd *);
 static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *);
 static int zfcp_task_management_function(struct zfcp_unit *, u8,
 					 struct scsi_cmnd *);
@@ -46,30 +45,22 @@ struct zfcp_data zfcp_data = {
 	.scsi_host_template = {
 		.name			= ZFCP_NAME,
 		.proc_name		= "zfcp",
-		.proc_info		= NULL,
-		.detect			= NULL,
 		.slave_alloc		= zfcp_scsi_slave_alloc,
 		.slave_configure	= zfcp_scsi_slave_configure,
 		.slave_destroy		= zfcp_scsi_slave_destroy,
 		.queuecommand		= zfcp_scsi_queuecommand,
 		.eh_abort_handler	= zfcp_scsi_eh_abort_handler,
 		.eh_device_reset_handler = zfcp_scsi_eh_device_reset_handler,
-		.eh_bus_reset_handler	= zfcp_scsi_eh_bus_reset_handler,
+		.eh_bus_reset_handler	= zfcp_scsi_eh_host_reset_handler,
 		.eh_host_reset_handler	= zfcp_scsi_eh_host_reset_handler,
 		.can_queue		= 4096,
 		.this_id		= -1,
-		/*
-		 * FIXME:
-		 * one less? can zfcp_create_sbale cope with it?
-		 */
 		.sg_tablesize		= ZFCP_MAX_SBALES_PER_REQ,
 		.cmd_per_lun		= 1,
-		.unchecked_isa_dma	= 0,
 		.use_clustering		= 1,
 		.sdev_attrs		= zfcp_sysfs_sdev_attrs,
 	},
 	.driver_version = ZFCP_VERSION,
-	/* rest initialised with zeros */
 };
 
 /* Find start of Response Information in FCP response unit*/
@@ -176,8 +167,14 @@ zfcp_scsi_slave_alloc(struct scsi_device *sdp)
 	return retval;
 }
 
-static void
-zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
+/**
+ * zfcp_scsi_slave_destroy - called when scsi device is removed
+ *
+ * Remove reference to associated scsi device for an zfcp_unit.
+ * Mark zfcp_unit as failed. The scsi device might be deleted via sysfs
+ * or a scan for this device might have failed.
+ */
+static void zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 {
 	struct zfcp_unit *unit = (struct zfcp_unit *) sdpnt->hostdata;
 
@@ -185,6 +182,7 @@ zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 		atomic_clear_mask(ZFCP_STATUS_UNIT_REGISTERED, &unit->status);
 		sdpnt->hostdata = NULL;
 		unit->device = NULL;
+		zfcp_erp_unit_failed(unit);
 		zfcp_unit_put(unit);
 	} else {
 		ZFCP_LOG_NORMAL("bug: no unit associated with SCSI device at "
@@ -549,35 +547,38 @@ zfcp_task_management_function(struct zfcp_unit *unit, u8 tm_flags,
 }
 
 /**
- * zfcp_scsi_eh_bus_reset_handler - reset bus (reopen adapter)
+ * zfcp_scsi_eh_host_reset_handler - handler for host and bus reset
+ *
+ * If ERP is already running it will be stopped.
  */
-int
-zfcp_scsi_eh_bus_reset_handler(struct scsi_cmnd *scpnt)
+int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 {
-	struct zfcp_unit *unit = (struct zfcp_unit*) scpnt->device->hostdata;
-	struct zfcp_adapter *adapter = unit->port->adapter;
-
-	ZFCP_LOG_NORMAL("bus reset because of problems with "
-			"unit 0x%016Lx\n", unit->fcp_lun);
-	zfcp_erp_adapter_reopen(adapter, 0);
-	zfcp_erp_wait(adapter);
-
-	return SUCCESS;
-}
+	struct zfcp_unit *unit;
+	struct zfcp_adapter *adapter;
+	unsigned long flags;
 
-/**
- * zfcp_scsi_eh_host_reset_handler - reset host (reopen adapter)
- */
-int
-zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
-{
-	struct zfcp_unit *unit = (struct zfcp_unit*) scpnt->device->hostdata;
-	struct zfcp_adapter *adapter = unit->port->adapter;
+	unit = (struct zfcp_unit*) scpnt->device->hostdata;
+	adapter = unit->port->adapter;
 
-	ZFCP_LOG_NORMAL("host reset because of problems with "
+	ZFCP_LOG_NORMAL("host/bus reset because of problems with "
 			"unit 0x%016Lx\n", unit->fcp_lun);
-	zfcp_erp_adapter_reopen(adapter, 0);
-	zfcp_erp_wait(adapter);
+
+	write_lock_irqsave(&adapter->erp_lock, flags);
+	if (atomic_test_mask(ZFCP_STATUS_ADAPTER_ERP_PENDING,
+			     &adapter->status)) {
+		zfcp_erp_modify_adapter_status(adapter,
+		       ZFCP_STATUS_COMMON_UNBLOCKED|ZFCP_STATUS_COMMON_OPEN,
+		       ZFCP_CLEAR);
+		zfcp_erp_action_dismiss_adapter(adapter);
+		write_unlock_irqrestore(&adapter->erp_lock, flags);
+		zfcp_fsf_req_dismiss_all(adapter);
+		adapter->fsf_req_seq_no = 0;
+		zfcp_erp_adapter_reopen(adapter, 0);
+	} else {
+		write_unlock_irqrestore(&adapter->erp_lock, flags);
+		zfcp_erp_adapter_reopen(adapter, 0);
+		zfcp_erp_wait(adapter);
+	}
 
 	return SUCCESS;
 }

commit d2c993d845781d160a7ef759a3e65c6892c4a270
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Wed Jul 12 16:41:55 2006 +0200

    [S390] Fix sparse warnings.
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 46e14f22ec18..671f4a6a5d18 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -44,30 +44,29 @@ struct scsi_transport_template *zfcp_transport_template;
 
 struct zfcp_data zfcp_data = {
 	.scsi_host_template = {
-	      name:	               ZFCP_NAME,
-	      proc_name:               "zfcp",
-	      proc_info:               NULL,
-	      detect:	               NULL,
-	      slave_alloc:             zfcp_scsi_slave_alloc,
-	      slave_configure:         zfcp_scsi_slave_configure,
-	      slave_destroy:           zfcp_scsi_slave_destroy,
-	      queuecommand:            zfcp_scsi_queuecommand,
-	      eh_abort_handler:        zfcp_scsi_eh_abort_handler,
-	      eh_device_reset_handler: zfcp_scsi_eh_device_reset_handler,
-	      eh_bus_reset_handler:    zfcp_scsi_eh_bus_reset_handler,
-	      eh_host_reset_handler:   zfcp_scsi_eh_host_reset_handler,
-			               /* FIXME(openfcp): Tune */
-	      can_queue:               4096,
-	      this_id:	               -1,
-	      /*
-	       * FIXME:
-	       * one less? can zfcp_create_sbale cope with it?
-	       */
-	      sg_tablesize:            ZFCP_MAX_SBALES_PER_REQ,
-	      cmd_per_lun:             1,
-	      unchecked_isa_dma:       0,
-	      use_clustering:          1,
-	      sdev_attrs:              zfcp_sysfs_sdev_attrs,
+		.name			= ZFCP_NAME,
+		.proc_name		= "zfcp",
+		.proc_info		= NULL,
+		.detect			= NULL,
+		.slave_alloc		= zfcp_scsi_slave_alloc,
+		.slave_configure	= zfcp_scsi_slave_configure,
+		.slave_destroy		= zfcp_scsi_slave_destroy,
+		.queuecommand		= zfcp_scsi_queuecommand,
+		.eh_abort_handler	= zfcp_scsi_eh_abort_handler,
+		.eh_device_reset_handler = zfcp_scsi_eh_device_reset_handler,
+		.eh_bus_reset_handler	= zfcp_scsi_eh_bus_reset_handler,
+		.eh_host_reset_handler	= zfcp_scsi_eh_host_reset_handler,
+		.can_queue		= 4096,
+		.this_id		= -1,
+		/*
+		 * FIXME:
+		 * one less? can zfcp_create_sbale cope with it?
+		 */
+		.sg_tablesize		= ZFCP_MAX_SBALES_PER_REQ,
+		.cmd_per_lun		= 1,
+		.unchecked_isa_dma	= 0,
+		.use_clustering		= 1,
+		.sdev_attrs		= zfcp_sysfs_sdev_attrs,
 	},
 	.driver_version = ZFCP_VERSION,
 	/* rest initialised with zeros */

commit 338151e066084d92d89f44311e5521ef847a50b9
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Mon May 22 18:25:56 2006 +0200

    [SCSI] zfcp: make use of fc_remote_port_delete when target port is unavailable
    
    If zfcp's port erp fails we now call fc_remote_port_delete. This helps
    to avoid offlined scsi devices if scsi commands time out due to path
    failures. When an adapter erp fails we call fc_remote_port_delete for
    all ports on that adapter.
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 30e87197f5f8..46e14f22ec18 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -800,12 +800,18 @@ zfcp_reset_fc_host_stats(struct Scsi_Host *shost)
 	}
 }
 
+static void zfcp_set_rport_dev_loss_tmo(struct fc_rport *rport, u32 timeout)
+{
+	rport->dev_loss_tmo = timeout;
+}
+
 struct fc_function_template zfcp_transport_functions = {
 	.show_starget_port_id = 1,
 	.show_starget_port_name = 1,
 	.show_starget_node_name = 1,
 	.show_rport_supported_classes = 1,
 	.show_rport_maxframe_size = 1,
+	.show_rport_dev_loss_tmo = 1,
 	.show_host_node_name = 1,
 	.show_host_port_name = 1,
 	.show_host_permanent_port_name = 1,
@@ -815,6 +821,7 @@ struct fc_function_template zfcp_transport_functions = {
 	.show_host_serial_number = 1,
 	.get_fc_host_stats = zfcp_get_fc_host_stats,
 	.reset_fc_host_stats = zfcp_reset_fc_host_stats,
+	.set_rport_dev_loss_tmo = zfcp_set_rport_dev_loss_tmo,
 	/* no functions registered for following dynamic attributes but
 	   directly set by LLDD */
 	.show_host_port_type = 1,

commit 75bfc2837bbcc329193d51e8b7115184b78beae0
Author: Ralph Wuerthner <rwuerthn@de.ibm.com>
Date:   Mon May 22 18:24:33 2006 +0200

    [SCSI] zfcp: evaluate plogi payload to set maxframe_size, supported_classes of rports
    
    Signed-off-by: Ralph Wuerthner <rwuerthn@de.ibm.com>
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index f198814196a4..30e87197f5f8 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -805,6 +805,7 @@ struct fc_function_template zfcp_transport_functions = {
 	.show_starget_port_name = 1,
 	.show_starget_node_name = 1,
 	.show_rport_supported_classes = 1,
+	.show_rport_maxframe_size = 1,
 	.show_host_node_name = 1,
 	.show_host_port_name = 1,
 	.show_host_permanent_port_name = 1,

commit 06506d00ec1a0d7d3b1dff59185af355ce29ac0a
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Mon May 22 18:18:19 2006 +0200

    [SCSI] zfcp: (cleanup) removed superfluous macros, struct members, typedefs
    
    Removed some macros, struct members and typedefs which were
    unused or not necessary.
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 3a180d80c3cb..f198814196a4 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -35,8 +35,8 @@ static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *);
 static int zfcp_task_management_function(struct zfcp_unit *, u8,
 					 struct scsi_cmnd *);
 
-static struct zfcp_unit *zfcp_unit_lookup(struct zfcp_adapter *, int, scsi_id_t,
-					  scsi_lun_t);
+static struct zfcp_unit *zfcp_unit_lookup(struct zfcp_adapter *, int,
+					  unsigned int, unsigned int);
 
 static struct device_attribute *zfcp_sysfs_sdev_attrs[];
 
@@ -349,8 +349,8 @@ zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 }
 
 static struct zfcp_unit *
-zfcp_unit_lookup(struct zfcp_adapter *adapter, int channel, scsi_id_t id,
-		 scsi_lun_t lun)
+zfcp_unit_lookup(struct zfcp_adapter *adapter, int channel, unsigned int id,
+		 unsigned int lun)
 {
 	struct zfcp_port *port;
 	struct zfcp_unit *unit, *retval = NULL;
@@ -608,10 +608,6 @@ zfcp_adapter_scsi_register(struct zfcp_adapter *adapter)
 	adapter->scsi_host->unique_id = unique_id++;	/* FIXME */
 	adapter->scsi_host->max_cmd_len = ZFCP_MAX_SCSI_CMND_LENGTH;
 	adapter->scsi_host->transportt = zfcp_transport_template;
-	/*
-	 * Reverse mapping of the host number to avoid race condition
-	 */
-	adapter->scsi_host_no = adapter->scsi_host->host_no;
 
 	/*
 	 * save a pointer to our own adapter data structure within
@@ -647,7 +643,6 @@ zfcp_adapter_scsi_unregister(struct zfcp_adapter *adapter)
 	scsi_remove_host(shost);
 	scsi_host_put(shost);
 	adapter->scsi_host = NULL;
-	adapter->scsi_host_no = 0;
 	atomic_clear_mask(ZFCP_STATUS_ADAPTER_REGISTERED, &adapter->status);
 
 	return;

commit ec4081c6ba4fba6a8bc12a0e93db8817ba63ce47
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Mon May 22 18:17:30 2006 +0200

    [SCSI] zfcp: (cleanup) kmalloc/kzalloc replacement
    
    Replace kmalloc/memset by kzalloc or kcalloc.
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 118cf0fa0afc..3a180d80c3cb 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -761,10 +761,9 @@ zfcp_get_fc_host_stats(struct Scsi_Host *shost)
 	if (!fc_stats)
 		return NULL;
 
-	data = kmalloc(sizeof(*data), GFP_KERNEL);
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
 	if (!data)
 		return NULL;
-	memset(data, 0, sizeof(*data));
 
 	ret = zfcp_fsf_exchange_port_data(NULL, adapter, data);
 	if (ret) {
@@ -792,10 +791,9 @@ zfcp_reset_fc_host_stats(struct Scsi_Host *shost)
 	int ret;
 
 	adapter = (struct zfcp_adapter *)shost->hostdata[0];
-	data = kmalloc(sizeof(*data), GFP_KERNEL);
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
 	if (!data)
 		return;
-	memset(data, 0, sizeof(*data));
 
 	ret = zfcp_fsf_exchange_port_data(NULL, adapter, data);
 	if (ret == 0) {

commit ca3271b40225a1049334766f6fb35b57a0162bd2
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Mon May 22 18:15:49 2006 +0200

    [SCSI] zfcp: (cleanup) remove useless comments
    
    Removed some useless comments.
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 4b4041a9da58..118cf0fa0afc 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -151,14 +151,6 @@ set_driver_byte(u32 * result, char status)
 	set_byte(result, status, 3);
 }
 
-/*
- * function:	zfcp_scsi_slave_alloc
- *
- * purpose:
- *
- * returns:
- */
-
 static int
 zfcp_scsi_slave_alloc(struct scsi_device *sdp)
 {
@@ -185,14 +177,6 @@ zfcp_scsi_slave_alloc(struct scsi_device *sdp)
 	return retval;
 }
 
-/*
- * function:	zfcp_scsi_slave_destroy
- *
- * purpose:
- *
- * returns:
- */
-
 static void
 zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 {
@@ -364,15 +348,6 @@ zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
 	return zfcp_scsi_command_async(adapter, unit, scpnt, NULL);
 }
 
-/*
- * function:    zfcp_unit_lookup
- *
- * purpose:
- *
- * returns:
- *
- * context:	
- */
 static struct zfcp_unit *
 zfcp_unit_lookup(struct zfcp_adapter *adapter, int channel, scsi_id_t id,
 		 scsi_lun_t lun)
@@ -481,13 +456,6 @@ zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	return retval;
 }
 
-/*
- * function:	zfcp_scsi_eh_device_reset_handler
- *
- * purpose:
- *
- * returns:
- */
 int
 zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)
 {
@@ -615,13 +583,6 @@ zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 	return SUCCESS;
 }
 
-/*
- * function:	
- *
- * purpose:	
- *
- * returns:
- */
 int
 zfcp_adapter_scsi_register(struct zfcp_adapter *adapter)
 {
@@ -668,13 +629,6 @@ zfcp_adapter_scsi_register(struct zfcp_adapter *adapter)
 	return retval;
 }
 
-/*
- * function:	
- *
- * purpose:	
- *
- * returns:
- */
 void
 zfcp_adapter_scsi_unregister(struct zfcp_adapter *adapter)
 {

commit 4a9d2d8bf989c77b54add430932fa5ed8a80dba9
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Mon May 22 18:14:08 2006 +0200

    [SCSI] zfcp: (cleanup) shortened copyright and author information
    
    Copyright update, shortened file headers, shortened author information.
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 9e6d07d7b3c8..4b4041a9da58 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -1,18 +1,8 @@
 /* 
- * 
- * linux/drivers/s390/scsi/zfcp_scsi.c
- * 
- * FCP adapter driver for IBM eServer zSeries 
- * 
- * (C) Copyright IBM Corp. 2002, 2004
+ * This file is part of the zfcp device driver for
+ * FCP adapters for IBM System z9 and zSeries.
  *
- * Author(s): Martin Peschke <mpeschke@de.ibm.com> 
- *            Raimund Schroeder <raimund.schroeder@de.ibm.com> 
- *            Aron Zeh
- *            Wolfgang Taphorn
- *            Stefan Bader <stefan.bader@de.ibm.com> 
- *            Heiko Carstens <heiko.carstens@de.ibm.com> 
- *            Andreas Herrmann <aherrman@de.ibm.com>
+ * (C) Copyright IBM Corp. 2002, 2006
  * 
  * This program is free software; you can redistribute it and/or modify 
  * it under the terms of the GNU General Public License as published by 

commit ad58f7dbeb6f5ea82679962f18985f16b660a2d9
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Fri Mar 10 00:56:16 2006 +0100

    [SCSI] zfcp: fix device registration issues
    
    The patch fixes following issues:
    
    (1) Replace scsi_add_device with scsi_scan_target.
    (Thus the rport instead of the scsi_host becomes parent of a
    scsi_target again.)
    
    (2) Avoid scsi_device allocation during registration of an remote port.
    (Would be done during fc_scsi_scan_rport.)
    
    (3) Fix queuecommand behaviour when an zfcp unit is blocked.
    (Call scsi_done with DID_NO_CONNECT instead of returning
    SCSI_MLQUEUE_DEVICE_BUSY otherwise we might end up waiting
    for completion in blk_execute_rq for ever.)
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index a2de3c9afe49..9e6d07d7b3c8 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -183,7 +183,8 @@ zfcp_scsi_slave_alloc(struct scsi_device *sdp)
 
 	read_lock_irqsave(&zfcp_data.config_lock, flags);
 	unit = zfcp_unit_lookup(adapter, sdp->channel, sdp->id, sdp->lun);
-	if (unit) {
+	if (unit && atomic_test_mask(ZFCP_STATUS_UNIT_REGISTERED,
+				     &unit->status)) {
 		sdp->hostdata = unit;
 		unit->device = sdp;
 		zfcp_unit_get(unit);
@@ -208,6 +209,7 @@ zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
 	struct zfcp_unit *unit = (struct zfcp_unit *) sdpnt->hostdata;
 
 	if (unit) {
+		atomic_clear_mask(ZFCP_STATUS_UNIT_REGISTERED, &unit->status);
 		sdpnt->hostdata = NULL;
 		unit->device = NULL;
 		zfcp_unit_put(unit);
@@ -291,7 +293,7 @@ zfcp_scsi_command_async(struct zfcp_adapter *adapter, struct zfcp_unit *unit,
 			       "on port 0x%016Lx in recovery\n",
 			       zfcp_get_busid_by_unit(unit),
 			       unit->fcp_lun, unit->port->wwpn);
-		retval = SCSI_MLQUEUE_DEVICE_BUSY;
+		zfcp_scsi_command_fail(scpnt, DID_NO_CONNECT);
 		goto out;
 	}
 

commit 35dc2585fa32a2b300307ffa9f17122b13ccef97
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Thu Mar 2 21:28:54 2006 +0100

    [SCSI] zfcp: correctly set this_id for hosts
    
    It fixes a bug in zfcp which provokes a race
    in scsi_scan.c. Finally this can lead to an Oops like:
    
    kernel BUG at fs/sysfs/symlink.c:87!
    
    Correctly set this_id for the host. Otherwise we provoke
    a race between scsi_target_reap_work and concurrent
    scsi_add_device.
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 9f6b4d7a46f3..a2de3c9afe49 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -68,7 +68,7 @@ struct zfcp_data zfcp_data = {
 	      eh_host_reset_handler:   zfcp_scsi_eh_host_reset_handler,
 			               /* FIXME(openfcp): Tune */
 	      can_queue:               4096,
-	      this_id:	               0,
+	      this_id:	               -1,
 	      /*
 	       * FIXME:
 	       * one less? can zfcp_create_sbale cope with it?

commit ed829ad607a9c334cea490d3a8c0f874153fb42d
Author: Maxim Shchetynin <maxim@de.ibm.com>
Date:   Sat Feb 11 01:42:58 2006 +0100

    [SCSI] zfcp: fix logging during device reset
    
    Avoid access to old fsf_requests if device reset is logged.
    
    Signed-off-by: Maxim Shchetynin <maxim@de.ibm.com>
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index e0803757c0fa..9f6b4d7a46f3 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -242,7 +242,7 @@ zfcp_scsi_command_fail(struct scsi_cmnd *scpnt, int result)
 	if ((scpnt->device != NULL) && (scpnt->device->host != NULL))
 		zfcp_scsi_dbf_event_result("fail", 4,
 			(struct zfcp_adapter*) scpnt->device->host->hostdata[0],
-			scpnt);
+			scpnt, NULL);
 	/* return directly */
 	scpnt->scsi_done(scpnt);
 }
@@ -446,7 +446,7 @@ zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	old_fsf_req = (struct zfcp_fsf_req *) scpnt->host_scribble;
 	if (!old_fsf_req) {
 		write_unlock_irqrestore(&adapter->abort_lock, flags);
-		zfcp_scsi_dbf_event_abort("lte1", adapter, scpnt, new_fsf_req);
+		zfcp_scsi_dbf_event_abort("lte1", adapter, scpnt, NULL, NULL);
 		retval = SUCCESS;
 		goto out;
 	}
@@ -460,6 +460,8 @@ zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 						 adapter, unit, 0);
 	if (!new_fsf_req) {
 		ZFCP_LOG_INFO("error: initiation of Abort FCP Cmnd failed\n");
+		zfcp_scsi_dbf_event_abort("nres", adapter, scpnt, NULL,
+					  old_fsf_req);
 		retval = FAILED;
 		goto out;
 	}
@@ -470,13 +472,16 @@ zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 
 	/* status should be valid since signals were not permitted */
 	if (new_fsf_req->status & ZFCP_STATUS_FSFREQ_ABORTSUCCEEDED) {
-		zfcp_scsi_dbf_event_abort("okay", adapter, scpnt, new_fsf_req);
+		zfcp_scsi_dbf_event_abort("okay", adapter, scpnt, new_fsf_req,
+					  NULL);
 		retval = SUCCESS;
 	} else if (new_fsf_req->status & ZFCP_STATUS_FSFREQ_ABORTNOTNEEDED) {
-		zfcp_scsi_dbf_event_abort("lte2", adapter, scpnt, new_fsf_req);
+		zfcp_scsi_dbf_event_abort("lte2", adapter, scpnt, new_fsf_req,
+					  NULL);
 		retval = SUCCESS;
 	} else {
-		zfcp_scsi_dbf_event_abort("fail", adapter, scpnt, new_fsf_req);
+		zfcp_scsi_dbf_event_abort("fail", adapter, scpnt, new_fsf_req,
+					  NULL);
 		retval = FAILED;
 	}
 	zfcp_fsf_req_free(new_fsf_req);

commit e018ba1fceee5bd306e31f6e3a60934d5f143ac5
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Wed Feb 1 03:06:31 2006 -0800

    [PATCH] s390: Remove CVS generated information
    
    - Remove all CVS generated information like e.g. revision IDs from
      drivers/s390 and include/asm-s390 (none present in arch/s390).
    
    - Add newline at end of arch/s390/lib/Makefile to avoid diff message.
    
    Acked-by: Andreas Herrmann <aherrman@de.ibm.com>
    Acked-by: Frank Pavlic <pavlic@de.ibm.com>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 3c2cbcccbf54..e0803757c0fa 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -31,8 +31,6 @@
 
 #define ZFCP_LOG_AREA			ZFCP_LOG_AREA_SCSI
 
-#define ZFCP_SCSI_REVISION "$Revision: 1.74 $"
-
 #include "zfcp_ext.h"
 
 static void zfcp_scsi_slave_destroy(struct scsi_device *sdp);

commit ad757cdfd2a40c9d5310d00f24427525788341cd
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Fri Jan 13 02:26:11 2006 +0100

    [SCSI] zfcp: transport class adaptations II
    
    Replaced zfcp adapter attributes with fc_host attributes:
    fc_topology by port_type, physical_wwpn by permanent_port_name.
    Make use of fc_host attribute supported_speeds.
    Removed zfcp adapter attribute physical_s_id.
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 5ca0992e97f4..3c2cbcccbf54 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -865,13 +865,16 @@ struct fc_function_template zfcp_transport_functions = {
 	.show_rport_supported_classes = 1,
 	.show_host_node_name = 1,
 	.show_host_port_name = 1,
+	.show_host_permanent_port_name = 1,
 	.show_host_supported_classes = 1,
+	.show_host_supported_speeds = 1,
 	.show_host_maxframe_size = 1,
 	.show_host_serial_number = 1,
 	.get_fc_host_stats = zfcp_get_fc_host_stats,
 	.reset_fc_host_stats = zfcp_reset_fc_host_stats,
 	/* no functions registered for following dynamic attributes but
 	   directly set by LLDD */
+	.show_host_port_type = 1,
 	.show_host_speed = 1,
 	.show_host_port_id = 1,
 };

commit f6cd94b126aa78ebaa21075df3b9577fbf995968
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Thu Jan 5 09:59:34 2006 +0100

    [SCSI] zfcp: transport class adaptations
    
    Added host stats, removed superfluous get_starget_ functions,
    removed some attributes from zfcp specific sysfs tree (e.g.
    scsi_host_no, scsi_lun, wwnn and d_id).
    Host stats are given for the physical adapter port not for the
    virtual adapter. Reset stats is implemented in the device driver.
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 66608d13a634..5ca0992e97f4 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -49,8 +49,6 @@ static int zfcp_task_management_function(struct zfcp_unit *, u8,
 
 static struct zfcp_unit *zfcp_unit_lookup(struct zfcp_adapter *, int, scsi_id_t,
 					  scsi_lun_t);
-static struct zfcp_port *zfcp_port_lookup(struct zfcp_adapter *, int,
-					  scsi_id_t);
 
 static struct device_attribute *zfcp_sysfs_sdev_attrs[];
 
@@ -406,18 +404,6 @@ zfcp_unit_lookup(struct zfcp_adapter *adapter, int channel, scsi_id_t id,
 	return retval;
 }
 
-static struct zfcp_port *
-zfcp_port_lookup(struct zfcp_adapter *adapter, int channel, scsi_id_t id)
-{
-	struct zfcp_port *port;
-
-	list_for_each_entry(port, &adapter->port_list_head, list) {
-		if (port->rport && (id == port->rport->scsi_target_id))
-			return port;
-	}
-	return (struct zfcp_port *) NULL;
-}
-
 /**
  * zfcp_scsi_eh_abort_handler - abort the specified SCSI command
  * @scpnt: pointer to scsi_cmnd to be aborted 
@@ -731,61 +717,148 @@ zfcp_fsf_start_scsi_er_timer(struct zfcp_adapter *adapter)
 /*
  * Support functions for FC transport class
  */
-static void
-zfcp_get_port_id(struct scsi_target *starget)
+static struct fc_host_statistics*
+zfcp_init_fc_host_stats(struct zfcp_adapter *adapter)
 {
-	struct Scsi_Host *shost = dev_to_shost(starget->dev.parent);
-	struct zfcp_adapter *adapter = (struct zfcp_adapter *)shost->hostdata[0];
-	struct zfcp_port *port;
-	unsigned long flags;
+	struct fc_host_statistics *fc_stats;
 
-	read_lock_irqsave(&zfcp_data.config_lock, flags);
-	port = zfcp_port_lookup(adapter, starget->channel, starget->id);
-	if (port)
-		fc_starget_port_id(starget) = port->d_id;
-	else
-		fc_starget_port_id(starget) = -1;
-	read_unlock_irqrestore(&zfcp_data.config_lock, flags);
+	if (!adapter->fc_stats) {
+		fc_stats = kmalloc(sizeof(*fc_stats), GFP_KERNEL);
+		if (!fc_stats)
+			return NULL;
+		adapter->fc_stats = fc_stats; /* freed in adater_dequeue */
+	}
+	memset(adapter->fc_stats, 0, sizeof(*adapter->fc_stats));
+	return adapter->fc_stats;
 }
 
 static void
-zfcp_get_port_name(struct scsi_target *starget)
+zfcp_adjust_fc_host_stats(struct fc_host_statistics *fc_stats,
+			  struct fsf_qtcb_bottom_port *data,
+			  struct fsf_qtcb_bottom_port *old)
 {
-	struct Scsi_Host *shost = dev_to_shost(starget->dev.parent);
-	struct zfcp_adapter *adapter = (struct zfcp_adapter *)shost->hostdata[0];
-	struct zfcp_port *port;
-	unsigned long flags;
+	fc_stats->seconds_since_last_reset = data->seconds_since_last_reset -
+		old->seconds_since_last_reset;
+	fc_stats->tx_frames = data->tx_frames - old->tx_frames;
+	fc_stats->tx_words = data->tx_words - old->tx_words;
+	fc_stats->rx_frames = data->rx_frames - old->rx_frames;
+	fc_stats->rx_words = data->rx_words - old->rx_words;
+	fc_stats->lip_count = data->lip - old->lip;
+	fc_stats->nos_count = data->nos - old->nos;
+	fc_stats->error_frames = data->error_frames - old->error_frames;
+	fc_stats->dumped_frames = data->dumped_frames - old->dumped_frames;
+	fc_stats->link_failure_count = data->link_failure - old->link_failure;
+	fc_stats->loss_of_sync_count = data->loss_of_sync - old->loss_of_sync;
+	fc_stats->loss_of_signal_count = data->loss_of_signal -
+		old->loss_of_signal;
+	fc_stats->prim_seq_protocol_err_count = data->psp_error_counts -
+		old->psp_error_counts;
+	fc_stats->invalid_tx_word_count = data->invalid_tx_words -
+		old->invalid_tx_words;
+	fc_stats->invalid_crc_count = data->invalid_crcs - old->invalid_crcs;
+	fc_stats->fcp_input_requests = data->input_requests -
+		old->input_requests;
+	fc_stats->fcp_output_requests = data->output_requests -
+		old->output_requests;
+	fc_stats->fcp_control_requests = data->control_requests -
+		old->control_requests;
+	fc_stats->fcp_input_megabytes = data->input_mb - old->input_mb;
+	fc_stats->fcp_output_megabytes = data->output_mb - old->output_mb;
+}
 
-	read_lock_irqsave(&zfcp_data.config_lock, flags);
-	port = zfcp_port_lookup(adapter, starget->channel, starget->id);
-	if (port)
-		fc_starget_port_name(starget) = port->wwpn;
-	else
-		fc_starget_port_name(starget) = -1;
-	read_unlock_irqrestore(&zfcp_data.config_lock, flags);
+static void
+zfcp_set_fc_host_stats(struct fc_host_statistics *fc_stats,
+		       struct fsf_qtcb_bottom_port *data)
+{
+	fc_stats->seconds_since_last_reset = data->seconds_since_last_reset;
+	fc_stats->tx_frames = data->tx_frames;
+	fc_stats->tx_words = data->tx_words;
+	fc_stats->rx_frames = data->rx_frames;
+	fc_stats->rx_words = data->rx_words;
+	fc_stats->lip_count = data->lip;
+	fc_stats->nos_count = data->nos;
+	fc_stats->error_frames = data->error_frames;
+	fc_stats->dumped_frames = data->dumped_frames;
+	fc_stats->link_failure_count = data->link_failure;
+	fc_stats->loss_of_sync_count = data->loss_of_sync;
+	fc_stats->loss_of_signal_count = data->loss_of_signal;
+	fc_stats->prim_seq_protocol_err_count = data->psp_error_counts;
+	fc_stats->invalid_tx_word_count = data->invalid_tx_words;
+	fc_stats->invalid_crc_count = data->invalid_crcs;
+	fc_stats->fcp_input_requests = data->input_requests;
+	fc_stats->fcp_output_requests = data->output_requests;
+	fc_stats->fcp_control_requests = data->control_requests;
+	fc_stats->fcp_input_megabytes = data->input_mb;
+	fc_stats->fcp_output_megabytes = data->output_mb;
+}
+
+/**
+ * zfcp_get_fc_host_stats - provide fc_host_statistics for scsi_transport_fc
+ *
+ * assumption: scsi_transport_fc synchronizes calls of
+ *             get_fc_host_stats and reset_fc_host_stats
+ *             (XXX to be checked otherwise introduce locking)
+ */
+static struct fc_host_statistics *
+zfcp_get_fc_host_stats(struct Scsi_Host *shost)
+{
+	struct zfcp_adapter *adapter;
+	struct fc_host_statistics *fc_stats;
+	struct fsf_qtcb_bottom_port *data;
+	int ret;
+
+	adapter = (struct zfcp_adapter *)shost->hostdata[0];
+	fc_stats = zfcp_init_fc_host_stats(adapter);
+	if (!fc_stats)
+		return NULL;
+
+	data = kmalloc(sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return NULL;
+	memset(data, 0, sizeof(*data));
+
+	ret = zfcp_fsf_exchange_port_data(NULL, adapter, data);
+	if (ret) {
+		kfree(data);
+		return NULL; /* XXX return zeroed fc_stats? */
+	}
+
+	if (adapter->stats_reset &&
+	    ((jiffies/HZ - adapter->stats_reset) <
+	     data->seconds_since_last_reset)) {
+		zfcp_adjust_fc_host_stats(fc_stats, data,
+					  adapter->stats_reset_data);
+	} else
+		zfcp_set_fc_host_stats(fc_stats, data);
+
+	kfree(data);
+	return fc_stats;
 }
 
 static void
-zfcp_get_node_name(struct scsi_target *starget)
+zfcp_reset_fc_host_stats(struct Scsi_Host *shost)
 {
-	struct Scsi_Host *shost = dev_to_shost(starget->dev.parent);
-	struct zfcp_adapter *adapter = (struct zfcp_adapter *)shost->hostdata[0];
-	struct zfcp_port *port;
-	unsigned long flags;
+	struct zfcp_adapter *adapter;
+	struct fsf_qtcb_bottom_port *data, *old_data;
+	int ret;
 
-	read_lock_irqsave(&zfcp_data.config_lock, flags);
-	port = zfcp_port_lookup(adapter, starget->channel, starget->id);
-	if (port)
-		fc_starget_node_name(starget) = port->wwnn;
-	else
-		fc_starget_node_name(starget) = -1;
-	read_unlock_irqrestore(&zfcp_data.config_lock, flags);
+	adapter = (struct zfcp_adapter *)shost->hostdata[0];
+	data = kmalloc(sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return;
+	memset(data, 0, sizeof(*data));
+
+	ret = zfcp_fsf_exchange_port_data(NULL, adapter, data);
+	if (ret == 0) {
+		adapter->stats_reset = jiffies/HZ;
+		old_data = adapter->stats_reset_data;
+		adapter->stats_reset_data = data; /* finally freed in
+						     adater_dequeue */
+		kfree(old_data);
+	}
 }
 
 struct fc_function_template zfcp_transport_functions = {
-	.get_starget_port_id = zfcp_get_port_id,
-	.get_starget_port_name = zfcp_get_port_name,
-	.get_starget_node_name = zfcp_get_node_name,
 	.show_starget_port_id = 1,
 	.show_starget_port_name = 1,
 	.show_starget_node_name = 1,
@@ -795,6 +868,10 @@ struct fc_function_template zfcp_transport_functions = {
 	.show_host_supported_classes = 1,
 	.show_host_maxframe_size = 1,
 	.show_host_serial_number = 1,
+	.get_fc_host_stats = zfcp_get_fc_host_stats,
+	.reset_fc_host_stats = zfcp_reset_fc_host_stats,
+	/* no functions registered for following dynamic attributes but
+	   directly set by LLDD */
 	.show_host_speed = 1,
 	.show_host_port_id = 1,
 };

commit fb121b067be77a9927e9453e427cf5819eb8ef01
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Thu Dec 1 02:49:29 2005 +0100

    [SCSI] zfcp: fix return code of zfcp_scsi_slave_alloc
    
    Change return code in slave_alloc to avoid irritating error message from
    scsi_alloc_sdev() when scsi stack tries target scan.
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 3dcd1bfba3b4..66608d13a634 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -179,7 +179,7 @@ zfcp_scsi_slave_alloc(struct scsi_device *sdp)
 	struct zfcp_adapter *adapter;
 	struct zfcp_unit *unit;
 	unsigned long flags;
-	int retval = -ENODEV;
+	int retval = -ENXIO;
 
 	adapter = (struct zfcp_adapter *) sdp->host->hostdata[0];
 	if (!adapter)

commit 13e1e1f08c1c098c7574c1fa72bd8c67792dc89b
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Mon Sep 19 16:56:17 2005 +0200

    [SCSI] zfcp: add additional fc_host attributes
    
    this patch adds some fc host attributes and removes its equivalents
    from the zfcp_adapter structure and zfcp specific sysfs subtree.
    
    Furthermore it removes superfluous calls to fc_remort_port_delete when
    an adapter is set offline because rports will be removed by
    fc_remove_host anyway.
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index c1403a23174f..3dcd1bfba3b4 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -698,10 +698,16 @@ void
 zfcp_adapter_scsi_unregister(struct zfcp_adapter *adapter)
 {
 	struct Scsi_Host *shost;
+	struct zfcp_port *port;
 
 	shost = adapter->scsi_host;
 	if (!shost)
 		return;
+	read_lock_irq(&zfcp_data.config_lock);
+	list_for_each_entry(port, &adapter->port_list_head, list)
+		if (port->rport)
+			port->rport = NULL;
+	read_unlock_irq(&zfcp_data.config_lock);
 	fc_remove_host(shost);
 	scsi_remove_host(shost);
 	scsi_host_put(shost);
@@ -776,18 +782,6 @@ zfcp_get_node_name(struct scsi_target *starget)
 	read_unlock_irqrestore(&zfcp_data.config_lock, flags);
 }
 
-void
-zfcp_set_fc_host_attrs(struct zfcp_adapter *adapter)
-{
-	struct Scsi_Host *shost = adapter->scsi_host;
-
-	fc_host_node_name(shost) = adapter->wwnn;
-	fc_host_port_name(shost) = adapter->wwpn;
-	strncpy(fc_host_serial_number(shost), adapter->serial_number,
-                min(FC_SERIAL_NUMBER_SIZE, 32));
-	fc_host_supported_classes(shost) = FC_COS_CLASS2 | FC_COS_CLASS3;
-}
-
 struct fc_function_template zfcp_transport_functions = {
 	.get_starget_port_id = zfcp_get_port_id,
 	.get_starget_port_name = zfcp_get_port_name,
@@ -799,7 +793,10 @@ struct fc_function_template zfcp_transport_functions = {
 	.show_host_node_name = 1,
 	.show_host_port_name = 1,
 	.show_host_supported_classes = 1,
+	.show_host_maxframe_size = 1,
 	.show_host_serial_number = 1,
+	.show_host_speed = 1,
+	.show_host_port_id = 1,
 };
 
 /**

commit 8a36e4532ea10471f0a8605207d071361d7be2c3
Author: Maxim Shchetynin <maxim@de.ibm.com>
Date:   Tue Sep 13 21:50:38 2005 +0200

    [SCSI] zfcp: enhancement of zfcp debug features
    
    Debug features (DBFs) els_dbf, cmd_dbf and abt_dbf were removed and
    san_dbf, hba_dbf and scsi_dbf were introduced. The erp_dbf did not
    change.
    The new traces improve debugging of problems with zfcp, scsi-stack,
    multipath and hardware in the SAN. san_dbf traces things like ELS and
    CT commands, hba_dbf saves HBA specific information of requests, and
    scsi_dbf saves FCP and SCSI specific information of requests. Common
    to all new DBFs is that they provide a so called structured view. This
    significantly improves readability of the traces.
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index eeb5152854ed..c1403a23174f 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -44,7 +44,8 @@ static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *);
 static int zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *);
 static int zfcp_scsi_eh_bus_reset_handler(struct scsi_cmnd *);
 static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *);
-static int zfcp_task_management_function(struct zfcp_unit *, u8);
+static int zfcp_task_management_function(struct zfcp_unit *, u8,
+					 struct scsi_cmnd *);
 
 static struct zfcp_unit *zfcp_unit_lookup(struct zfcp_adapter *, int, scsi_id_t,
 					  scsi_lun_t);
@@ -242,7 +243,10 @@ static void
 zfcp_scsi_command_fail(struct scsi_cmnd *scpnt, int result)
 {
 	set_host_byte(&scpnt->result, result);
-	zfcp_cmd_dbf_event_scsi("failing", scpnt);
+	if ((scpnt->device != NULL) && (scpnt->device->host != NULL))
+		zfcp_scsi_dbf_event_result("fail", 4,
+			(struct zfcp_adapter*) scpnt->device->host->hostdata[0],
+			scpnt);
 	/* return directly */
 	scpnt->scsi_done(scpnt);
 }
@@ -434,7 +438,8 @@ zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
  	struct zfcp_adapter *adapter;
 	struct zfcp_unit *unit;
 	int retval = SUCCESS;
-	struct zfcp_fsf_req *new_fsf_req, *old_fsf_req;
+	struct zfcp_fsf_req *new_fsf_req = NULL;
+	struct zfcp_fsf_req *old_fsf_req;
 	unsigned long flags;
 
 	scsi_host = scpnt->device->host;
@@ -457,11 +462,8 @@ zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	old_fsf_req = (struct zfcp_fsf_req *) scpnt->host_scribble;
 	if (!old_fsf_req) {
 		write_unlock_irqrestore(&adapter->abort_lock, flags);
-		ZFCP_LOG_NORMAL("bug: no old fsf request found\n");
-		ZFCP_LOG_NORMAL("scsi_cmnd:\n");
-		ZFCP_HEX_DUMP(ZFCP_LOG_LEVEL_NORMAL,
-			      (char *) scpnt, sizeof (struct scsi_cmnd));
-		retval = FAILED;
+		zfcp_scsi_dbf_event_abort("lte1", adapter, scpnt, new_fsf_req);
+		retval = SUCCESS;
 		goto out;
 	}
 	old_fsf_req->data = 0;
@@ -473,25 +475,27 @@ zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	new_fsf_req = zfcp_fsf_abort_fcp_command((unsigned long) old_fsf_req,
 						 adapter, unit, 0);
 	if (!new_fsf_req) {
+		ZFCP_LOG_INFO("error: initiation of Abort FCP Cmnd failed\n");
 		retval = FAILED;
-		ZFCP_LOG_NORMAL("error: initiation of Abort FCP Cmnd "
-				"failed\n");
 		goto out;
 	}
 
 	/* wait for completion of abort */
 	__wait_event(new_fsf_req->completion_wq,
 		     new_fsf_req->status & ZFCP_STATUS_FSFREQ_COMPLETED);
-	zfcp_fsf_req_free(new_fsf_req);
 
 	/* status should be valid since signals were not permitted */
 	if (new_fsf_req->status & ZFCP_STATUS_FSFREQ_ABORTSUCCEEDED) {
+		zfcp_scsi_dbf_event_abort("okay", adapter, scpnt, new_fsf_req);
 		retval = SUCCESS;
 	} else if (new_fsf_req->status & ZFCP_STATUS_FSFREQ_ABORTNOTNEEDED) {
+		zfcp_scsi_dbf_event_abort("lte2", adapter, scpnt, new_fsf_req);
 		retval = SUCCESS;
 	} else {
+		zfcp_scsi_dbf_event_abort("fail", adapter, scpnt, new_fsf_req);
 		retval = FAILED;
 	}
+	zfcp_fsf_req_free(new_fsf_req);
  out:
 	return retval;
 }
@@ -525,8 +529,9 @@ zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)
 	 */
 	if (!atomic_test_mask(ZFCP_STATUS_UNIT_NOTSUPPUNITRESET,
 			      &unit->status)) {
-		retval =
-		    zfcp_task_management_function(unit, FCP_LOGICAL_UNIT_RESET);
+		retval = zfcp_task_management_function(unit,
+						       FCP_LOGICAL_UNIT_RESET,
+						       scpnt);
 		if (retval) {
 			ZFCP_LOG_DEBUG("unit reset failed (unit=%p)\n", unit);
 			if (retval == -ENOTSUPP)
@@ -542,7 +547,7 @@ zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)
 			goto out;
 		}
 	}
-	retval = zfcp_task_management_function(unit, FCP_TARGET_RESET);
+	retval = zfcp_task_management_function(unit, FCP_TARGET_RESET, scpnt);
 	if (retval) {
 		ZFCP_LOG_DEBUG("target reset failed (unit=%p)\n", unit);
 		retval = FAILED;
@@ -555,7 +560,8 @@ zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)
 }
 
 static int
-zfcp_task_management_function(struct zfcp_unit *unit, u8 tm_flags)
+zfcp_task_management_function(struct zfcp_unit *unit, u8 tm_flags,
+			      struct scsi_cmnd *scpnt)
 {
 	struct zfcp_adapter *adapter = unit->port->adapter;
 	struct zfcp_fsf_req *fsf_req;
@@ -569,6 +575,7 @@ zfcp_task_management_function(struct zfcp_unit *unit, u8 tm_flags)
 			      "failed for unit 0x%016Lx on port 0x%016Lx on  "
 			      "adapter %s\n", unit->fcp_lun, unit->port->wwpn,
 			      zfcp_get_busid_by_adapter(adapter));
+		zfcp_scsi_dbf_event_devreset("nres", tm_flags, unit, scpnt);
 		retval = -ENOMEM;
 		goto out;
 	}
@@ -576,11 +583,17 @@ zfcp_task_management_function(struct zfcp_unit *unit, u8 tm_flags)
 	__wait_event(fsf_req->completion_wq,
 		     fsf_req->status & ZFCP_STATUS_FSFREQ_COMPLETED);
 
-	/* check completion status of task management function */
-	if (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCFAILED)
+	/*
+	 * check completion status of task management function
+	 */
+	if (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCFAILED) {
+		zfcp_scsi_dbf_event_devreset("fail", tm_flags, unit, scpnt);
 		retval = -EIO;
-	else if (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCNOTSUPP)
+	} else if (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCNOTSUPP) {
+		zfcp_scsi_dbf_event_devreset("nsup", tm_flags, unit, scpnt);
 		retval = -ENOTSUPP;
+	} else
+		zfcp_scsi_dbf_event_devreset("okay", tm_flags, unit, scpnt);
 
 	zfcp_fsf_req_free(fsf_req);
  out:

commit 810f1e3ea5cc0a812816af97020a27c73441f8e9
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Tue Sep 13 21:49:52 2005 +0200

    [SCSI] zfcp: shorten eh_bus_reset and eh_host_reset handlers
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 3b5d48c61534..eeb5152854ed 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -587,50 +587,38 @@ zfcp_task_management_function(struct zfcp_unit *unit, u8 tm_flags)
 	return retval;
 }
 
-/*
- * function:	zfcp_scsi_eh_bus_reset_handler
- *
- * purpose:
- *
- * returns:
+/**
+ * zfcp_scsi_eh_bus_reset_handler - reset bus (reopen adapter)
  */
 int
 zfcp_scsi_eh_bus_reset_handler(struct scsi_cmnd *scpnt)
 {
-	int retval = 0;
-	struct zfcp_unit *unit;
+	struct zfcp_unit *unit = (struct zfcp_unit*) scpnt->device->hostdata;
+	struct zfcp_adapter *adapter = unit->port->adapter;
 
-	unit = (struct zfcp_unit *) scpnt->device->hostdata;
 	ZFCP_LOG_NORMAL("bus reset because of problems with "
 			"unit 0x%016Lx\n", unit->fcp_lun);
-	zfcp_erp_adapter_reopen(unit->port->adapter, 0);
-	zfcp_erp_wait(unit->port->adapter);
-	retval = SUCCESS;
+	zfcp_erp_adapter_reopen(adapter, 0);
+	zfcp_erp_wait(adapter);
 
-	return retval;
+	return SUCCESS;
 }
 
-/*
- * function:	zfcp_scsi_eh_host_reset_handler
- *
- * purpose:
- *
- * returns:
+/**
+ * zfcp_scsi_eh_host_reset_handler - reset host (reopen adapter)
  */
 int
 zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 {
-	int retval = 0;
-	struct zfcp_unit *unit;
+	struct zfcp_unit *unit = (struct zfcp_unit*) scpnt->device->hostdata;
+	struct zfcp_adapter *adapter = unit->port->adapter;
 
-	unit = (struct zfcp_unit *) scpnt->device->hostdata;
 	ZFCP_LOG_NORMAL("host reset because of problems with "
 			"unit 0x%016Lx\n", unit->fcp_lun);
-	zfcp_erp_adapter_reopen(unit->port->adapter, 0);
-	zfcp_erp_wait(unit->port->adapter);
-	retval = SUCCESS;
+	zfcp_erp_adapter_reopen(adapter, 0);
+	zfcp_erp_wait(adapter);
 
-	return retval;
+	return SUCCESS;
 }
 
 /*

commit 77eb1699c76177af2f3d65c8ae7934cf304e0254
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Tue Sep 13 21:48:33 2005 +0200

    [SCSI] zfcp: remove function zfcp_fsf_req_wait_and_cleanup
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index fffd12399010..3b5d48c61534 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -558,9 +558,8 @@ static int
 zfcp_task_management_function(struct zfcp_unit *unit, u8 tm_flags)
 {
 	struct zfcp_adapter *adapter = unit->port->adapter;
-	int retval;
-	int status;
 	struct zfcp_fsf_req *fsf_req;
+	int retval = 0;
 
 	/* issue task management function */
 	fsf_req = zfcp_fsf_send_fcp_command_task_management
@@ -574,18 +573,16 @@ zfcp_task_management_function(struct zfcp_unit *unit, u8 tm_flags)
 		goto out;
 	}
 
-	retval = zfcp_fsf_req_wait_and_cleanup(fsf_req,
-					       ZFCP_UNINTERRUPTIBLE, &status);
-	/*
-	 * check completion status of task management function
-	 * (status should always be valid since no signals permitted)
-	 */
-	if (status & ZFCP_STATUS_FSFREQ_TMFUNCFAILED)
+	__wait_event(fsf_req->completion_wq,
+		     fsf_req->status & ZFCP_STATUS_FSFREQ_COMPLETED);
+
+	/* check completion status of task management function */
+	if (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCFAILED)
 		retval = -EIO;
-	else if (status & ZFCP_STATUS_FSFREQ_TMFUNCNOTSUPP)
+	else if (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCNOTSUPP)
 		retval = -ENOTSUPP;
-	else
-		retval = 0;
+
+	zfcp_fsf_req_free(fsf_req);
  out:
 	return retval;
 }

commit 059c97d0434834d291eff94669ca2dd3eaac9d28
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Tue Sep 13 21:47:52 2005 +0200

    [SCSI] zfcp: remove union zfcp_req_data, use unit refcount for FCP commands
    
    o union zfcp_req_data removed
    o increment unit refcount when processing FCP commands
     (This fixes a theoretical race: When all scsi commands of a unit
      are aborted and the scsi_device is removed then the unit could be
      removed before all fsf_requests of that unit are completely processed.)
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 31a76065cf28..fffd12399010 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -414,67 +414,37 @@ zfcp_port_lookup(struct zfcp_adapter *adapter, int channel, scsi_id_t id)
 	return (struct zfcp_port *) NULL;
 }
 
-/*
- * function:	zfcp_scsi_eh_abort_handler
- *
- * purpose:	tries to abort the specified (timed out) SCSI command
- *
- * note: 	We do not need to care for a SCSI command which completes
- *		normally but late during this abort routine runs.
- *		We are allowed to return late commands to the SCSI stack.
- *		It tracks the state of commands and will handle late commands.
- *		(Usually, the normal completion of late commands is ignored with
- *		respect to the running abort operation. Grep for 'done_late'
- *		in the SCSI stacks sources.)
+/**
+ * zfcp_scsi_eh_abort_handler - abort the specified SCSI command
+ * @scpnt: pointer to scsi_cmnd to be aborted 
+ * Return: SUCCESS - command has been aborted and cleaned up in internal
+ *          bookkeeping, SCSI stack won't be called for aborted command
+ *         FAILED - otherwise
  *
- * returns:	SUCCESS	- command has been aborted and cleaned up in internal
- *			  bookkeeping,
- *			  SCSI stack won't be called for aborted command
- *		FAILED	- otherwise
+ * We do not need to care for a SCSI command which completes normally
+ * but late during this abort routine runs.  We are allowed to return
+ * late commands to the SCSI stack.  It tracks the state of commands and
+ * will handle late commands.  (Usually, the normal completion of late
+ * commands is ignored with respect to the running abort operation.)
  */
 int
-__zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
+zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 {
+ 	struct Scsi_Host *scsi_host;
+ 	struct zfcp_adapter *adapter;
+	struct zfcp_unit *unit;
 	int retval = SUCCESS;
 	struct zfcp_fsf_req *new_fsf_req, *old_fsf_req;
-	struct zfcp_adapter *adapter = (struct zfcp_adapter *) scpnt->device->host->hostdata[0];
-	struct zfcp_unit *unit = (struct zfcp_unit *) scpnt->device->hostdata;
-	struct zfcp_port *port = unit->port;
-	struct Scsi_Host *scsi_host = scpnt->device->host;
-	union zfcp_req_data *req_data = NULL;
 	unsigned long flags;
-	u32 status = 0;
-
-	/* the components of a abort_dbf record (fixed size record) */
-	u64 dbf_scsi_cmnd = (unsigned long) scpnt;
-	char dbf_opcode[ZFCP_ABORT_DBF_LENGTH];
-	wwn_t dbf_wwn = port->wwpn;
-	fcp_lun_t dbf_fcp_lun = unit->fcp_lun;
-	u64 dbf_retries = scpnt->retries;
-	u64 dbf_allowed = scpnt->allowed;
-	u64 dbf_timeout = 0;
-	u64 dbf_fsf_req = 0;
-	u64 dbf_fsf_status = 0;
-	u64 dbf_fsf_qual[2] = { 0, 0 };
-	char dbf_result[ZFCP_ABORT_DBF_LENGTH] = "##undef";
-
-	memset(dbf_opcode, 0, ZFCP_ABORT_DBF_LENGTH);
-	memcpy(dbf_opcode,
-	       scpnt->cmnd,
-	       min(scpnt->cmd_len, (unsigned char) ZFCP_ABORT_DBF_LENGTH));
+
+	scsi_host = scpnt->device->host;
+	adapter = (struct zfcp_adapter *) scsi_host->hostdata[0];
+	unit = (struct zfcp_unit *) scpnt->device->hostdata;
 
 	ZFCP_LOG_INFO("aborting scsi_cmnd=%p on adapter %s\n",
 		      scpnt, zfcp_get_busid_by_adapter(adapter));
 
-	spin_unlock_irq(scsi_host->host_lock);
-
-	/*
-	 * Race condition between normal (late) completion and abort has
-	 * to be avoided.
-	 * The entirity of all accesses to scsi_req have to be atomic.
-	 * scsi_req is usually part of the fsf_req and thus we block the
-	 * release of fsf_req as long as we need to access scsi_req.
-	 */
+	/* avoid race condition between late normal completion and abort */
 	write_lock_irqsave(&adapter->abort_lock, flags);
 
 	/*
@@ -484,144 +454,48 @@ __zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	 * this routine returns. (scpnt is parameter passed to this routine
 	 * and must not disappear during abort even on late completion.)
 	 */
-	req_data = (union zfcp_req_data *) scpnt->host_scribble;
-	/* DEBUG */
-	ZFCP_LOG_DEBUG("req_data=%p\n", req_data);
-	if (!req_data) {
-		ZFCP_LOG_DEBUG("late command completion overtook abort\n");
-		/*
-		 * That's it.
-		 * Do not initiate abort but return SUCCESS.
-		 */
-		write_unlock_irqrestore(&adapter->abort_lock, flags);
-		retval = SUCCESS;
-		strncpy(dbf_result, "##late1", ZFCP_ABORT_DBF_LENGTH);
-		goto out;
-	}
-
-	/* Figure out which fsf_req needs to be aborted. */
-	old_fsf_req = req_data->send_fcp_command_task.fsf_req;
-
-	dbf_fsf_req = (unsigned long) old_fsf_req;
-	dbf_timeout =
-	    (jiffies - req_data->send_fcp_command_task.start_jiffies) / HZ;
-
-	ZFCP_LOG_DEBUG("old_fsf_req=%p\n", old_fsf_req);
+	old_fsf_req = (struct zfcp_fsf_req *) scpnt->host_scribble;
 	if (!old_fsf_req) {
 		write_unlock_irqrestore(&adapter->abort_lock, flags);
 		ZFCP_LOG_NORMAL("bug: no old fsf request found\n");
-		ZFCP_LOG_NORMAL("req_data:\n");
-		ZFCP_HEX_DUMP(ZFCP_LOG_LEVEL_NORMAL,
-			      (char *) req_data, sizeof (union zfcp_req_data));
 		ZFCP_LOG_NORMAL("scsi_cmnd:\n");
 		ZFCP_HEX_DUMP(ZFCP_LOG_LEVEL_NORMAL,
 			      (char *) scpnt, sizeof (struct scsi_cmnd));
 		retval = FAILED;
-		strncpy(dbf_result, "##bug:r", ZFCP_ABORT_DBF_LENGTH);
 		goto out;
 	}
-	old_fsf_req->data.send_fcp_command_task.scsi_cmnd = NULL;
-	/* mark old request as being aborted */
+	old_fsf_req->data = 0;
 	old_fsf_req->status |= ZFCP_STATUS_FSFREQ_ABORTING;
-	/*
-	 * We have to collect all information (e.g. unit) needed by 
-	 * zfcp_fsf_abort_fcp_command before calling that routine
-	 * since that routine is not allowed to access
-	 * fsf_req which it is going to abort.
-	 * This is because of we need to release fsf_req_list_lock
-	 * before calling zfcp_fsf_abort_fcp_command.
-	 * Since this lock will not be held, fsf_req may complete
-	 * late and may be released meanwhile.
-	 */
-	ZFCP_LOG_DEBUG("unit 0x%016Lx (%p)\n", unit->fcp_lun, unit);
 
-	/*
-	 * We block (call schedule)
-	 * That's why we must release the lock and enable the
-	 * interrupts before.
-	 * On the other hand we do not need the lock anymore since
-	 * all critical accesses to scsi_req are done.
-	 */
+	/* don't access old_fsf_req after releasing the abort_lock */
 	write_unlock_irqrestore(&adapter->abort_lock, flags);
 	/* call FSF routine which does the abort */
 	new_fsf_req = zfcp_fsf_abort_fcp_command((unsigned long) old_fsf_req,
 						 adapter, unit, 0);
-	ZFCP_LOG_DEBUG("new_fsf_req=%p\n", new_fsf_req);
 	if (!new_fsf_req) {
 		retval = FAILED;
 		ZFCP_LOG_NORMAL("error: initiation of Abort FCP Cmnd "
 				"failed\n");
-		strncpy(dbf_result, "##nores", ZFCP_ABORT_DBF_LENGTH);
 		goto out;
 	}
 
 	/* wait for completion of abort */
-	ZFCP_LOG_DEBUG("waiting for cleanup...\n");
-#if 1
-	/*
-	 * FIXME:
-	 * copying zfcp_fsf_req_wait_and_cleanup code is not really nice
-	 */
 	__wait_event(new_fsf_req->completion_wq,
 		     new_fsf_req->status & ZFCP_STATUS_FSFREQ_COMPLETED);
-	status = new_fsf_req->status;
-	dbf_fsf_status = new_fsf_req->qtcb->header.fsf_status;
-	/*
-	 * Ralphs special debug load provides timestamps in the FSF
-	 * status qualifier. This might be specified later if being
-	 * useful for debugging aborts.
-	 */
-	dbf_fsf_qual[0] =
-	    *(u64 *) & new_fsf_req->qtcb->header.fsf_status_qual.word[0];
-	dbf_fsf_qual[1] =
-	    *(u64 *) & new_fsf_req->qtcb->header.fsf_status_qual.word[2];
 	zfcp_fsf_req_free(new_fsf_req);
-#else
-	retval = zfcp_fsf_req_wait_and_cleanup(new_fsf_req,
-					       ZFCP_UNINTERRUPTIBLE, &status);
-#endif
-	ZFCP_LOG_DEBUG("Waiting for cleanup complete, status=0x%x\n", status);
+
 	/* status should be valid since signals were not permitted */
-	if (status & ZFCP_STATUS_FSFREQ_ABORTSUCCEEDED) {
+	if (new_fsf_req->status & ZFCP_STATUS_FSFREQ_ABORTSUCCEEDED) {
 		retval = SUCCESS;
-		strncpy(dbf_result, "##succ", ZFCP_ABORT_DBF_LENGTH);
-	} else if (status & ZFCP_STATUS_FSFREQ_ABORTNOTNEEDED) {
+	} else if (new_fsf_req->status & ZFCP_STATUS_FSFREQ_ABORTNOTNEEDED) {
 		retval = SUCCESS;
-		strncpy(dbf_result, "##late2", ZFCP_ABORT_DBF_LENGTH);
 	} else {
 		retval = FAILED;
-		strncpy(dbf_result, "##fail", ZFCP_ABORT_DBF_LENGTH);
 	}
-
  out:
-	debug_event(adapter->abort_dbf, 1, &dbf_scsi_cmnd, sizeof (u64));
-	debug_event(adapter->abort_dbf, 1, &dbf_opcode, ZFCP_ABORT_DBF_LENGTH);
-	debug_event(adapter->abort_dbf, 1, &dbf_wwn, sizeof (wwn_t));
-	debug_event(adapter->abort_dbf, 1, &dbf_fcp_lun, sizeof (fcp_lun_t));
-	debug_event(adapter->abort_dbf, 1, &dbf_retries, sizeof (u64));
-	debug_event(adapter->abort_dbf, 1, &dbf_allowed, sizeof (u64));
-	debug_event(adapter->abort_dbf, 1, &dbf_timeout, sizeof (u64));
-	debug_event(adapter->abort_dbf, 1, &dbf_fsf_req, sizeof (u64));
-	debug_event(adapter->abort_dbf, 1, &dbf_fsf_status, sizeof (u64));
-	debug_event(adapter->abort_dbf, 1, &dbf_fsf_qual[0], sizeof (u64));
-	debug_event(adapter->abort_dbf, 1, &dbf_fsf_qual[1], sizeof (u64));
-	debug_text_event(adapter->abort_dbf, 1, dbf_result);
-
-	spin_lock_irq(scsi_host->host_lock);
 	return retval;
 }
 
-int
-zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
-{
-	int rc;
-	struct Scsi_Host *scsi_host = scpnt->device->host;
-	spin_lock_irq(scsi_host->host_lock);
-	rc = __zfcp_scsi_eh_abort_handler(scpnt);
-	spin_unlock_irq(scsi_host->host_lock);
-	return rc;
-}
-
 /*
  * function:	zfcp_scsi_eh_device_reset_handler
  *

commit 3859f6a248cbdfbe7b41663f3a2b51f48e30b281
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Sat Aug 27 11:07:54 2005 -0700

    [PATCH] zfcp: add rports to enable scsi_add_device to work again
    
    This patch fixes a severe problem with 2.6.13-rc7.
    
    Due to recent SCSI changes it is not possible to add any LUNs to the zfcp
    device driver anymore.  With registration of remote ports this is fixed.
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Acked-by: James Bottomley <jejb@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index b61d309352c3..31a76065cf28 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -389,7 +389,7 @@ zfcp_unit_lookup(struct zfcp_adapter *adapter, int channel, scsi_id_t id,
 	struct zfcp_unit *unit, *retval = NULL;
 
 	list_for_each_entry(port, &adapter->port_list_head, list) {
-		if (id != port->scsi_id)
+		if (!port->rport || (id != port->rport->scsi_target_id))
 			continue;
 		list_for_each_entry(unit, &port->unit_list_head, list) {
 			if (lun == unit->scsi_lun) {
@@ -408,7 +408,7 @@ zfcp_port_lookup(struct zfcp_adapter *adapter, int channel, scsi_id_t id)
 	struct zfcp_port *port;
 
 	list_for_each_entry(port, &adapter->port_list_head, list) {
-		if (id == port->scsi_id)
+		if (port->rport && (id == port->rport->scsi_target_id))
 			return port;
 	}
 	return (struct zfcp_port *) NULL;
@@ -634,7 +634,6 @@ zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)
 {
 	int retval;
 	struct zfcp_unit *unit = (struct zfcp_unit *) scpnt->device->hostdata;
-	struct Scsi_Host *scsi_host = scpnt->device->host;
 
 	if (!unit) {
 		ZFCP_LOG_NORMAL("bug: Tried reset for nonexistent unit\n");
@@ -729,7 +728,6 @@ zfcp_scsi_eh_bus_reset_handler(struct scsi_cmnd *scpnt)
 {
 	int retval = 0;
 	struct zfcp_unit *unit;
-	struct Scsi_Host *scsi_host = scpnt->device->host;
 
 	unit = (struct zfcp_unit *) scpnt->device->hostdata;
 	ZFCP_LOG_NORMAL("bus reset because of problems with "
@@ -753,7 +751,6 @@ zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 {
 	int retval = 0;
 	struct zfcp_unit *unit;
-	struct Scsi_Host *scsi_host = scpnt->device->host;
 
 	unit = (struct zfcp_unit *) scpnt->device->hostdata;
 	ZFCP_LOG_NORMAL("host reset because of problems with "
@@ -833,6 +830,7 @@ zfcp_adapter_scsi_unregister(struct zfcp_adapter *adapter)
 	shost = adapter->scsi_host;
 	if (!shost)
 		return;
+	fc_remove_host(shost);
 	scsi_remove_host(shost);
 	scsi_host_put(shost);
 	adapter->scsi_host = NULL;
@@ -906,6 +904,18 @@ zfcp_get_node_name(struct scsi_target *starget)
 	read_unlock_irqrestore(&zfcp_data.config_lock, flags);
 }
 
+void
+zfcp_set_fc_host_attrs(struct zfcp_adapter *adapter)
+{
+	struct Scsi_Host *shost = adapter->scsi_host;
+
+	fc_host_node_name(shost) = adapter->wwnn;
+	fc_host_port_name(shost) = adapter->wwpn;
+	strncpy(fc_host_serial_number(shost), adapter->serial_number,
+                min(FC_SERIAL_NUMBER_SIZE, 32));
+	fc_host_supported_classes(shost) = FC_COS_CLASS2 | FC_COS_CLASS3;
+}
+
 struct fc_function_template zfcp_transport_functions = {
 	.get_starget_port_id = zfcp_get_port_id,
 	.get_starget_port_name = zfcp_get_port_name,
@@ -913,6 +923,11 @@ struct fc_function_template zfcp_transport_functions = {
 	.show_starget_port_id = 1,
 	.show_starget_port_name = 1,
 	.show_starget_node_name = 1,
+	.show_rport_supported_classes = 1,
+	.show_host_node_name = 1,
+	.show_host_port_name = 1,
+	.show_host_supported_classes = 1,
+	.show_host_serial_number = 1,
 };
 
 /**

commit 10523b3b82456e416cbaffcc24ea2246980aa746
Author: Yani Ioannou <yani.ioannou@gmail.com>
Date:   Tue May 17 06:43:37 2005 -0400

    [PATCH] Driver Core: drivers/s390/net/qeth_sys.c - drivers/usb/gadget/pxa2xx_udc.c: update device attribute callbacks
    
    Signed-off-by: Yani Ioannou <yani.ioannou@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 6965992ddbbf..b61d309352c3 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -924,7 +924,7 @@ struct fc_function_template zfcp_transport_functions = {
  * Generates attribute for a unit.
  */
 #define ZFCP_DEFINE_SCSI_ATTR(_name, _format, _value)                    \
-static ssize_t zfcp_sysfs_scsi_##_name##_show(struct device *dev,        \
+static ssize_t zfcp_sysfs_scsi_##_name##_show(struct device *dev, struct device_attribute *attr,        \
                                               char *buf)                 \
 {                                                                        \
         struct scsi_device *sdev;                                        \

commit df0ae2497ddefd72a87f3a3b34ff32455d7d4ae0
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:57:14 2005 -0400

    [SCSI] allow sleeping in ->eh_host_reset_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index ac5a5da434b3..6965992ddbbf 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -755,8 +755,6 @@ zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 	struct zfcp_unit *unit;
 	struct Scsi_Host *scsi_host = scpnt->device->host;
 
-	spin_unlock_irq(scsi_host->host_lock);
-
 	unit = (struct zfcp_unit *) scpnt->device->hostdata;
 	ZFCP_LOG_NORMAL("host reset because of problems with "
 			"unit 0x%016Lx\n", unit->fcp_lun);
@@ -764,7 +762,6 @@ zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
 	zfcp_erp_wait(unit->port->adapter);
 	retval = SUCCESS;
 
-	spin_lock_irq(scsi_host->host_lock);
 	return retval;
 }
 

commit 68b3aa7c9805aee9005a8ca53c5e99177961fbb9
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:56:31 2005 -0400

    [SCSI] allow sleeping in ->eh_bus_reset_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index be7c91d4ae8c..ac5a5da434b3 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -731,8 +731,6 @@ zfcp_scsi_eh_bus_reset_handler(struct scsi_cmnd *scpnt)
 	struct zfcp_unit *unit;
 	struct Scsi_Host *scsi_host = scpnt->device->host;
 
-	spin_unlock_irq(scsi_host->host_lock);
-
 	unit = (struct zfcp_unit *) scpnt->device->hostdata;
 	ZFCP_LOG_NORMAL("bus reset because of problems with "
 			"unit 0x%016Lx\n", unit->fcp_lun);
@@ -740,7 +738,6 @@ zfcp_scsi_eh_bus_reset_handler(struct scsi_cmnd *scpnt)
 	zfcp_erp_wait(unit->port->adapter);
 	retval = SUCCESS;
 
-	spin_lock_irq(scsi_host->host_lock);
 	return retval;
 }
 

commit 94d0e7b805961c44e4dc486ffc21075084bb7175
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:55:48 2005 -0400

    [SCSI] allow sleeping in ->eh_device_reset_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index 6e4447598495..be7c91d4ae8c 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -636,8 +636,6 @@ zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)
 	struct zfcp_unit *unit = (struct zfcp_unit *) scpnt->device->hostdata;
 	struct Scsi_Host *scsi_host = scpnt->device->host;
 
-	spin_unlock_irq(scsi_host->host_lock);
-
 	if (!unit) {
 		ZFCP_LOG_NORMAL("bug: Tried reset for nonexistent unit\n");
 		retval = SUCCESS;
@@ -680,7 +678,6 @@ zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)
 		retval = SUCCESS;
 	}
  out:
-	spin_lock_irq(scsi_host->host_lock);
 	return retval;
 }
 

commit 8fa728a26886f56a9ee10a44fea0ddda301d21c3
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:54:40 2005 -0400

    [SCSI] allow sleeping in ->eh_abort_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index c6f69fc475a2..6e4447598495 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -433,7 +433,7 @@ zfcp_port_lookup(struct zfcp_adapter *adapter, int channel, scsi_id_t id)
  *		FAILED	- otherwise
  */
 int
-zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
+__zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 {
 	int retval = SUCCESS;
 	struct zfcp_fsf_req *new_fsf_req, *old_fsf_req;
@@ -611,6 +611,17 @@ zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	return retval;
 }
 
+int
+zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
+{
+	int rc;
+	struct Scsi_Host *scsi_host = scpnt->device->host;
+	spin_lock_irq(scsi_host->host_lock);
+	rc = __zfcp_scsi_eh_abort_handler(scpnt);
+	spin_unlock_irq(scsi_host->host_lock);
+	return rc;
+}
+
 /*
  * function:	zfcp_scsi_eh_device_reset_handler
  *

commit 1db2c9c0931a53fe013db55fd2ff58859db31e8d
Author: Andreas Herrmann <aherrman@de.ibm.com>
Date:   Mon Jun 13 13:20:35 2005 +0200

    [SCSI] zfcp: fix bug during adapter shutdown
    
    Fixes a race between zfcp_fsf_req_dismiss_all and
    zfcp_qdio_reqid_check. During adapter shutdown it occurred that a
    request was cleaned up twice. First during its normal
    completion. Second when dismiss_all was called.  The fix is to
    serialize access to fsf request list between zfcp_fsf_req_dismiss_all
    and zfcp_qdio_reqid_check and delete a fsf request from the list if
    its completion is triggered.  (Additionally a rwlock was replaced by a
    spinlock and fsf_req_cleanup was eliminated.)
    
    Signed-off-by: Andreas Herrmann <aherrman@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
index e21b547fd427..c6f69fc475a2 100644
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -575,7 +575,7 @@ zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
 	    *(u64 *) & new_fsf_req->qtcb->header.fsf_status_qual.word[0];
 	dbf_fsf_qual[1] =
 	    *(u64 *) & new_fsf_req->qtcb->header.fsf_status_qual.word[2];
-	zfcp_fsf_req_cleanup(new_fsf_req);
+	zfcp_fsf_req_free(new_fsf_req);
 #else
 	retval = zfcp_fsf_req_wait_and_cleanup(new_fsf_req,
 					       ZFCP_UNINTERRUPTIBLE, &status);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c
new file mode 100644
index 000000000000..e21b547fd427
--- /dev/null
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -0,0 +1,949 @@
+/* 
+ * 
+ * linux/drivers/s390/scsi/zfcp_scsi.c
+ * 
+ * FCP adapter driver for IBM eServer zSeries 
+ * 
+ * (C) Copyright IBM Corp. 2002, 2004
+ *
+ * Author(s): Martin Peschke <mpeschke@de.ibm.com> 
+ *            Raimund Schroeder <raimund.schroeder@de.ibm.com> 
+ *            Aron Zeh
+ *            Wolfgang Taphorn
+ *            Stefan Bader <stefan.bader@de.ibm.com> 
+ *            Heiko Carstens <heiko.carstens@de.ibm.com> 
+ *            Andreas Herrmann <aherrman@de.ibm.com>
+ * 
+ * This program is free software; you can redistribute it and/or modify 
+ * it under the terms of the GNU General Public License as published by 
+ * the Free Software Foundation; either version 2, or (at your option) 
+ * any later version. 
+ * 
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
+ * GNU General Public License for more details. 
+ * 
+ * You should have received a copy of the GNU General Public License 
+ * along with this program; if not, write to the Free Software 
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+ */
+
+#define ZFCP_LOG_AREA			ZFCP_LOG_AREA_SCSI
+
+#define ZFCP_SCSI_REVISION "$Revision: 1.74 $"
+
+#include "zfcp_ext.h"
+
+static void zfcp_scsi_slave_destroy(struct scsi_device *sdp);
+static int zfcp_scsi_slave_alloc(struct scsi_device *sdp);
+static int zfcp_scsi_slave_configure(struct scsi_device *sdp);
+static int zfcp_scsi_queuecommand(struct scsi_cmnd *,
+				  void (*done) (struct scsi_cmnd *));
+static int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *);
+static int zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *);
+static int zfcp_scsi_eh_bus_reset_handler(struct scsi_cmnd *);
+static int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *);
+static int zfcp_task_management_function(struct zfcp_unit *, u8);
+
+static struct zfcp_unit *zfcp_unit_lookup(struct zfcp_adapter *, int, scsi_id_t,
+					  scsi_lun_t);
+static struct zfcp_port *zfcp_port_lookup(struct zfcp_adapter *, int,
+					  scsi_id_t);
+
+static struct device_attribute *zfcp_sysfs_sdev_attrs[];
+
+struct scsi_transport_template *zfcp_transport_template;
+
+struct zfcp_data zfcp_data = {
+	.scsi_host_template = {
+	      name:	               ZFCP_NAME,
+	      proc_name:               "zfcp",
+	      proc_info:               NULL,
+	      detect:	               NULL,
+	      slave_alloc:             zfcp_scsi_slave_alloc,
+	      slave_configure:         zfcp_scsi_slave_configure,
+	      slave_destroy:           zfcp_scsi_slave_destroy,
+	      queuecommand:            zfcp_scsi_queuecommand,
+	      eh_abort_handler:        zfcp_scsi_eh_abort_handler,
+	      eh_device_reset_handler: zfcp_scsi_eh_device_reset_handler,
+	      eh_bus_reset_handler:    zfcp_scsi_eh_bus_reset_handler,
+	      eh_host_reset_handler:   zfcp_scsi_eh_host_reset_handler,
+			               /* FIXME(openfcp): Tune */
+	      can_queue:               4096,
+	      this_id:	               0,
+	      /*
+	       * FIXME:
+	       * one less? can zfcp_create_sbale cope with it?
+	       */
+	      sg_tablesize:            ZFCP_MAX_SBALES_PER_REQ,
+	      cmd_per_lun:             1,
+	      unchecked_isa_dma:       0,
+	      use_clustering:          1,
+	      sdev_attrs:              zfcp_sysfs_sdev_attrs,
+	},
+	.driver_version = ZFCP_VERSION,
+	/* rest initialised with zeros */
+};
+
+/* Find start of Response Information in FCP response unit*/
+char *
+zfcp_get_fcp_rsp_info_ptr(struct fcp_rsp_iu *fcp_rsp_iu)
+{
+	char *fcp_rsp_info_ptr;
+
+	fcp_rsp_info_ptr =
+	    (unsigned char *) fcp_rsp_iu + (sizeof (struct fcp_rsp_iu));
+
+	return fcp_rsp_info_ptr;
+}
+
+/* Find start of Sense Information in FCP response unit*/
+char *
+zfcp_get_fcp_sns_info_ptr(struct fcp_rsp_iu *fcp_rsp_iu)
+{
+	char *fcp_sns_info_ptr;
+
+	fcp_sns_info_ptr =
+	    (unsigned char *) fcp_rsp_iu + (sizeof (struct fcp_rsp_iu));
+	if (fcp_rsp_iu->validity.bits.fcp_rsp_len_valid)
+		fcp_sns_info_ptr = (char *) fcp_sns_info_ptr +
+		    fcp_rsp_iu->fcp_rsp_len;
+
+	return fcp_sns_info_ptr;
+}
+
+fcp_dl_t *
+zfcp_get_fcp_dl_ptr(struct fcp_cmnd_iu * fcp_cmd)
+{
+	int additional_length = fcp_cmd->add_fcp_cdb_length << 2;
+	fcp_dl_t *fcp_dl_addr;
+
+	fcp_dl_addr = (fcp_dl_t *)
+		((unsigned char *) fcp_cmd +
+		 sizeof (struct fcp_cmnd_iu) + additional_length);
+	/*
+	 * fcp_dl_addr = start address of fcp_cmnd structure + 
+	 * size of fixed part + size of dynamically sized add_dcp_cdb field
+	 * SEE FCP-2 documentation
+	 */
+	return fcp_dl_addr;
+}
+
+fcp_dl_t
+zfcp_get_fcp_dl(struct fcp_cmnd_iu * fcp_cmd)
+{
+	return *zfcp_get_fcp_dl_ptr(fcp_cmd);
+}
+
+void
+zfcp_set_fcp_dl(struct fcp_cmnd_iu *fcp_cmd, fcp_dl_t fcp_dl)
+{
+	*zfcp_get_fcp_dl_ptr(fcp_cmd) = fcp_dl;
+}
+
+/*
+ * note: it's a bit-or operation not an assignment
+ * regarding the specified byte
+ */
+static inline void
+set_byte(u32 * result, char status, char pos)
+{
+	*result |= status << (pos * 8);
+}
+
+void
+set_host_byte(u32 * result, char status)
+{
+	set_byte(result, status, 2);
+}
+
+void
+set_driver_byte(u32 * result, char status)
+{
+	set_byte(result, status, 3);
+}
+
+/*
+ * function:	zfcp_scsi_slave_alloc
+ *
+ * purpose:
+ *
+ * returns:
+ */
+
+static int
+zfcp_scsi_slave_alloc(struct scsi_device *sdp)
+{
+	struct zfcp_adapter *adapter;
+	struct zfcp_unit *unit;
+	unsigned long flags;
+	int retval = -ENODEV;
+
+	adapter = (struct zfcp_adapter *) sdp->host->hostdata[0];
+	if (!adapter)
+		goto out;
+
+	read_lock_irqsave(&zfcp_data.config_lock, flags);
+	unit = zfcp_unit_lookup(adapter, sdp->channel, sdp->id, sdp->lun);
+	if (unit) {
+		sdp->hostdata = unit;
+		unit->device = sdp;
+		zfcp_unit_get(unit);
+		retval = 0;
+	}
+	read_unlock_irqrestore(&zfcp_data.config_lock, flags);
+ out:
+	return retval;
+}
+
+/*
+ * function:	zfcp_scsi_slave_destroy
+ *
+ * purpose:
+ *
+ * returns:
+ */
+
+static void
+zfcp_scsi_slave_destroy(struct scsi_device *sdpnt)
+{
+	struct zfcp_unit *unit = (struct zfcp_unit *) sdpnt->hostdata;
+
+	if (unit) {
+		sdpnt->hostdata = NULL;
+		unit->device = NULL;
+		zfcp_unit_put(unit);
+	} else {
+		ZFCP_LOG_NORMAL("bug: no unit associated with SCSI device at "
+				"address %p\n", sdpnt);
+	}
+}
+
+/* 
+ * called from scsi midlayer to allow finetuning of a device.
+ */
+static int
+zfcp_scsi_slave_configure(struct scsi_device *sdp)
+{
+	if (sdp->tagged_supported)
+		scsi_adjust_queue_depth(sdp, MSG_SIMPLE_TAG, ZFCP_CMND_PER_LUN);
+	else
+		scsi_adjust_queue_depth(sdp, 0, 1);
+	return 0;
+}
+
+/**
+ * zfcp_scsi_command_fail - set result in scsi_cmnd and call scsi_done function
+ * @scpnt: pointer to struct scsi_cmnd where result is set
+ * @result: result to be set in scpnt (e.g. DID_ERROR)
+ */
+static void
+zfcp_scsi_command_fail(struct scsi_cmnd *scpnt, int result)
+{
+	set_host_byte(&scpnt->result, result);
+	zfcp_cmd_dbf_event_scsi("failing", scpnt);
+	/* return directly */
+	scpnt->scsi_done(scpnt);
+}
+
+/**
+ * zfcp_scsi_command_async - worker for zfcp_scsi_queuecommand and
+ *	zfcp_scsi_command_sync
+ * @adapter: adapter where scsi command is issued
+ * @unit: unit to which scsi command is sent
+ * @scpnt: scsi command to be sent
+ * @timer: timer to be started if request is successfully initiated
+ *
+ * Note: In scsi_done function must be set in scpnt.
+ */
+int
+zfcp_scsi_command_async(struct zfcp_adapter *adapter, struct zfcp_unit *unit,
+			struct scsi_cmnd *scpnt, struct timer_list *timer)
+{
+	int tmp;
+	int retval;
+
+	retval = 0;
+
+	BUG_ON((adapter == NULL) || (adapter != unit->port->adapter));
+	BUG_ON(scpnt->scsi_done == NULL);
+
+	if (unlikely(NULL == unit)) {
+		zfcp_scsi_command_fail(scpnt, DID_NO_CONNECT);
+		goto out;
+	}
+
+	if (unlikely(
+	      atomic_test_mask(ZFCP_STATUS_COMMON_ERP_FAILED, &unit->status) ||
+	     !atomic_test_mask(ZFCP_STATUS_COMMON_RUNNING, &unit->status))) {
+		ZFCP_LOG_DEBUG("stopping SCSI I/O on unit 0x%016Lx on port "
+			       "0x%016Lx on adapter %s\n",
+			       unit->fcp_lun, unit->port->wwpn,
+			       zfcp_get_busid_by_adapter(adapter));
+		zfcp_scsi_command_fail(scpnt, DID_ERROR);
+		goto out;
+	}
+
+	if (unlikely(
+	     !atomic_test_mask(ZFCP_STATUS_COMMON_UNBLOCKED, &unit->status))) {
+		ZFCP_LOG_DEBUG("adapter %s not ready or unit 0x%016Lx "
+			       "on port 0x%016Lx in recovery\n",
+			       zfcp_get_busid_by_unit(unit),
+			       unit->fcp_lun, unit->port->wwpn);
+		retval = SCSI_MLQUEUE_DEVICE_BUSY;
+		goto out;
+	}
+
+	tmp = zfcp_fsf_send_fcp_command_task(adapter, unit, scpnt, timer,
+					     ZFCP_REQ_AUTO_CLEANUP);
+
+	if (unlikely(tmp < 0)) {
+		ZFCP_LOG_DEBUG("error: initiation of Send FCP Cmnd failed\n");
+		retval = SCSI_MLQUEUE_HOST_BUSY;
+	}
+
+out:
+	return retval;
+}
+
+void
+zfcp_scsi_command_sync_handler(struct scsi_cmnd *scpnt)
+{
+	struct completion *wait = (struct completion *) scpnt->SCp.ptr;
+	complete(wait);
+}
+
+
+/**
+ * zfcp_scsi_command_sync - send a SCSI command and wait for completion
+ * @unit: unit where command is sent to
+ * @scpnt: scsi command to be sent
+ * @timer: timer to be started if request is successfully initiated
+ * Return: 0
+ *
+ * Errors are indicated in scpnt->result
+ */
+int
+zfcp_scsi_command_sync(struct zfcp_unit *unit, struct scsi_cmnd *scpnt,
+		       struct timer_list *timer)
+{
+	int ret;
+	DECLARE_COMPLETION(wait);
+
+	scpnt->SCp.ptr = (void *) &wait;  /* silent re-use */
+	scpnt->scsi_done = zfcp_scsi_command_sync_handler;
+	ret = zfcp_scsi_command_async(unit->port->adapter, unit, scpnt, timer);
+	if (ret == 0)
+		wait_for_completion(&wait);
+
+	scpnt->SCp.ptr = NULL;
+
+	return 0;
+}
+
+/*
+ * function:	zfcp_scsi_queuecommand
+ *
+ * purpose:	enqueues a SCSI command to the specified target device
+ *
+ * returns:	0 - success, SCSI command enqueued
+ *		!0 - failure
+ */
+int
+zfcp_scsi_queuecommand(struct scsi_cmnd *scpnt,
+		       void (*done) (struct scsi_cmnd *))
+{
+	struct zfcp_unit *unit;
+	struct zfcp_adapter *adapter;
+
+	/* reset the status for this request */
+	scpnt->result = 0;
+	scpnt->host_scribble = NULL;
+	scpnt->scsi_done = done;
+
+	/*
+	 * figure out adapter and target device
+	 * (stored there by zfcp_scsi_slave_alloc)
+	 */
+	adapter = (struct zfcp_adapter *) scpnt->device->host->hostdata[0];
+	unit = (struct zfcp_unit *) scpnt->device->hostdata;
+
+	return zfcp_scsi_command_async(adapter, unit, scpnt, NULL);
+}
+
+/*
+ * function:    zfcp_unit_lookup
+ *
+ * purpose:
+ *
+ * returns:
+ *
+ * context:	
+ */
+static struct zfcp_unit *
+zfcp_unit_lookup(struct zfcp_adapter *adapter, int channel, scsi_id_t id,
+		 scsi_lun_t lun)
+{
+	struct zfcp_port *port;
+	struct zfcp_unit *unit, *retval = NULL;
+
+	list_for_each_entry(port, &adapter->port_list_head, list) {
+		if (id != port->scsi_id)
+			continue;
+		list_for_each_entry(unit, &port->unit_list_head, list) {
+			if (lun == unit->scsi_lun) {
+				retval = unit;
+				goto out;
+			}
+		}
+	}
+ out:
+	return retval;
+}
+
+static struct zfcp_port *
+zfcp_port_lookup(struct zfcp_adapter *adapter, int channel, scsi_id_t id)
+{
+	struct zfcp_port *port;
+
+	list_for_each_entry(port, &adapter->port_list_head, list) {
+		if (id == port->scsi_id)
+			return port;
+	}
+	return (struct zfcp_port *) NULL;
+}
+
+/*
+ * function:	zfcp_scsi_eh_abort_handler
+ *
+ * purpose:	tries to abort the specified (timed out) SCSI command
+ *
+ * note: 	We do not need to care for a SCSI command which completes
+ *		normally but late during this abort routine runs.
+ *		We are allowed to return late commands to the SCSI stack.
+ *		It tracks the state of commands and will handle late commands.
+ *		(Usually, the normal completion of late commands is ignored with
+ *		respect to the running abort operation. Grep for 'done_late'
+ *		in the SCSI stacks sources.)
+ *
+ * returns:	SUCCESS	- command has been aborted and cleaned up in internal
+ *			  bookkeeping,
+ *			  SCSI stack won't be called for aborted command
+ *		FAILED	- otherwise
+ */
+int
+zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)
+{
+	int retval = SUCCESS;
+	struct zfcp_fsf_req *new_fsf_req, *old_fsf_req;
+	struct zfcp_adapter *adapter = (struct zfcp_adapter *) scpnt->device->host->hostdata[0];
+	struct zfcp_unit *unit = (struct zfcp_unit *) scpnt->device->hostdata;
+	struct zfcp_port *port = unit->port;
+	struct Scsi_Host *scsi_host = scpnt->device->host;
+	union zfcp_req_data *req_data = NULL;
+	unsigned long flags;
+	u32 status = 0;
+
+	/* the components of a abort_dbf record (fixed size record) */
+	u64 dbf_scsi_cmnd = (unsigned long) scpnt;
+	char dbf_opcode[ZFCP_ABORT_DBF_LENGTH];
+	wwn_t dbf_wwn = port->wwpn;
+	fcp_lun_t dbf_fcp_lun = unit->fcp_lun;
+	u64 dbf_retries = scpnt->retries;
+	u64 dbf_allowed = scpnt->allowed;
+	u64 dbf_timeout = 0;
+	u64 dbf_fsf_req = 0;
+	u64 dbf_fsf_status = 0;
+	u64 dbf_fsf_qual[2] = { 0, 0 };
+	char dbf_result[ZFCP_ABORT_DBF_LENGTH] = "##undef";
+
+	memset(dbf_opcode, 0, ZFCP_ABORT_DBF_LENGTH);
+	memcpy(dbf_opcode,
+	       scpnt->cmnd,
+	       min(scpnt->cmd_len, (unsigned char) ZFCP_ABORT_DBF_LENGTH));
+
+	ZFCP_LOG_INFO("aborting scsi_cmnd=%p on adapter %s\n",
+		      scpnt, zfcp_get_busid_by_adapter(adapter));
+
+	spin_unlock_irq(scsi_host->host_lock);
+
+	/*
+	 * Race condition between normal (late) completion and abort has
+	 * to be avoided.
+	 * The entirity of all accesses to scsi_req have to be atomic.
+	 * scsi_req is usually part of the fsf_req and thus we block the
+	 * release of fsf_req as long as we need to access scsi_req.
+	 */
+	write_lock_irqsave(&adapter->abort_lock, flags);
+
+	/*
+	 * Check whether command has just completed and can not be aborted.
+	 * Even if the command has just been completed late, we can access
+	 * scpnt since the SCSI stack does not release it at least until
+	 * this routine returns. (scpnt is parameter passed to this routine
+	 * and must not disappear during abort even on late completion.)
+	 */
+	req_data = (union zfcp_req_data *) scpnt->host_scribble;
+	/* DEBUG */
+	ZFCP_LOG_DEBUG("req_data=%p\n", req_data);
+	if (!req_data) {
+		ZFCP_LOG_DEBUG("late command completion overtook abort\n");
+		/*
+		 * That's it.
+		 * Do not initiate abort but return SUCCESS.
+		 */
+		write_unlock_irqrestore(&adapter->abort_lock, flags);
+		retval = SUCCESS;
+		strncpy(dbf_result, "##late1", ZFCP_ABORT_DBF_LENGTH);
+		goto out;
+	}
+
+	/* Figure out which fsf_req needs to be aborted. */
+	old_fsf_req = req_data->send_fcp_command_task.fsf_req;
+
+	dbf_fsf_req = (unsigned long) old_fsf_req;
+	dbf_timeout =
+	    (jiffies - req_data->send_fcp_command_task.start_jiffies) / HZ;
+
+	ZFCP_LOG_DEBUG("old_fsf_req=%p\n", old_fsf_req);
+	if (!old_fsf_req) {
+		write_unlock_irqrestore(&adapter->abort_lock, flags);
+		ZFCP_LOG_NORMAL("bug: no old fsf request found\n");
+		ZFCP_LOG_NORMAL("req_data:\n");
+		ZFCP_HEX_DUMP(ZFCP_LOG_LEVEL_NORMAL,
+			      (char *) req_data, sizeof (union zfcp_req_data));
+		ZFCP_LOG_NORMAL("scsi_cmnd:\n");
+		ZFCP_HEX_DUMP(ZFCP_LOG_LEVEL_NORMAL,
+			      (char *) scpnt, sizeof (struct scsi_cmnd));
+		retval = FAILED;
+		strncpy(dbf_result, "##bug:r", ZFCP_ABORT_DBF_LENGTH);
+		goto out;
+	}
+	old_fsf_req->data.send_fcp_command_task.scsi_cmnd = NULL;
+	/* mark old request as being aborted */
+	old_fsf_req->status |= ZFCP_STATUS_FSFREQ_ABORTING;
+	/*
+	 * We have to collect all information (e.g. unit) needed by 
+	 * zfcp_fsf_abort_fcp_command before calling that routine
+	 * since that routine is not allowed to access
+	 * fsf_req which it is going to abort.
+	 * This is because of we need to release fsf_req_list_lock
+	 * before calling zfcp_fsf_abort_fcp_command.
+	 * Since this lock will not be held, fsf_req may complete
+	 * late and may be released meanwhile.
+	 */
+	ZFCP_LOG_DEBUG("unit 0x%016Lx (%p)\n", unit->fcp_lun, unit);
+
+	/*
+	 * We block (call schedule)
+	 * That's why we must release the lock and enable the
+	 * interrupts before.
+	 * On the other hand we do not need the lock anymore since
+	 * all critical accesses to scsi_req are done.
+	 */
+	write_unlock_irqrestore(&adapter->abort_lock, flags);
+	/* call FSF routine which does the abort */
+	new_fsf_req = zfcp_fsf_abort_fcp_command((unsigned long) old_fsf_req,
+						 adapter, unit, 0);
+	ZFCP_LOG_DEBUG("new_fsf_req=%p\n", new_fsf_req);
+	if (!new_fsf_req) {
+		retval = FAILED;
+		ZFCP_LOG_NORMAL("error: initiation of Abort FCP Cmnd "
+				"failed\n");
+		strncpy(dbf_result, "##nores", ZFCP_ABORT_DBF_LENGTH);
+		goto out;
+	}
+
+	/* wait for completion of abort */
+	ZFCP_LOG_DEBUG("waiting for cleanup...\n");
+#if 1
+	/*
+	 * FIXME:
+	 * copying zfcp_fsf_req_wait_and_cleanup code is not really nice
+	 */
+	__wait_event(new_fsf_req->completion_wq,
+		     new_fsf_req->status & ZFCP_STATUS_FSFREQ_COMPLETED);
+	status = new_fsf_req->status;
+	dbf_fsf_status = new_fsf_req->qtcb->header.fsf_status;
+	/*
+	 * Ralphs special debug load provides timestamps in the FSF
+	 * status qualifier. This might be specified later if being
+	 * useful for debugging aborts.
+	 */
+	dbf_fsf_qual[0] =
+	    *(u64 *) & new_fsf_req->qtcb->header.fsf_status_qual.word[0];
+	dbf_fsf_qual[1] =
+	    *(u64 *) & new_fsf_req->qtcb->header.fsf_status_qual.word[2];
+	zfcp_fsf_req_cleanup(new_fsf_req);
+#else
+	retval = zfcp_fsf_req_wait_and_cleanup(new_fsf_req,
+					       ZFCP_UNINTERRUPTIBLE, &status);
+#endif
+	ZFCP_LOG_DEBUG("Waiting for cleanup complete, status=0x%x\n", status);
+	/* status should be valid since signals were not permitted */
+	if (status & ZFCP_STATUS_FSFREQ_ABORTSUCCEEDED) {
+		retval = SUCCESS;
+		strncpy(dbf_result, "##succ", ZFCP_ABORT_DBF_LENGTH);
+	} else if (status & ZFCP_STATUS_FSFREQ_ABORTNOTNEEDED) {
+		retval = SUCCESS;
+		strncpy(dbf_result, "##late2", ZFCP_ABORT_DBF_LENGTH);
+	} else {
+		retval = FAILED;
+		strncpy(dbf_result, "##fail", ZFCP_ABORT_DBF_LENGTH);
+	}
+
+ out:
+	debug_event(adapter->abort_dbf, 1, &dbf_scsi_cmnd, sizeof (u64));
+	debug_event(adapter->abort_dbf, 1, &dbf_opcode, ZFCP_ABORT_DBF_LENGTH);
+	debug_event(adapter->abort_dbf, 1, &dbf_wwn, sizeof (wwn_t));
+	debug_event(adapter->abort_dbf, 1, &dbf_fcp_lun, sizeof (fcp_lun_t));
+	debug_event(adapter->abort_dbf, 1, &dbf_retries, sizeof (u64));
+	debug_event(adapter->abort_dbf, 1, &dbf_allowed, sizeof (u64));
+	debug_event(adapter->abort_dbf, 1, &dbf_timeout, sizeof (u64));
+	debug_event(adapter->abort_dbf, 1, &dbf_fsf_req, sizeof (u64));
+	debug_event(adapter->abort_dbf, 1, &dbf_fsf_status, sizeof (u64));
+	debug_event(adapter->abort_dbf, 1, &dbf_fsf_qual[0], sizeof (u64));
+	debug_event(adapter->abort_dbf, 1, &dbf_fsf_qual[1], sizeof (u64));
+	debug_text_event(adapter->abort_dbf, 1, dbf_result);
+
+	spin_lock_irq(scsi_host->host_lock);
+	return retval;
+}
+
+/*
+ * function:	zfcp_scsi_eh_device_reset_handler
+ *
+ * purpose:
+ *
+ * returns:
+ */
+int
+zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)
+{
+	int retval;
+	struct zfcp_unit *unit = (struct zfcp_unit *) scpnt->device->hostdata;
+	struct Scsi_Host *scsi_host = scpnt->device->host;
+
+	spin_unlock_irq(scsi_host->host_lock);
+
+	if (!unit) {
+		ZFCP_LOG_NORMAL("bug: Tried reset for nonexistent unit\n");
+		retval = SUCCESS;
+		goto out;
+	}
+	ZFCP_LOG_NORMAL("resetting unit 0x%016Lx\n", unit->fcp_lun);
+
+	/*
+	 * If we do not know whether the unit supports 'logical unit reset'
+	 * then try 'logical unit reset' and proceed with 'target reset'
+	 * if 'logical unit reset' fails.
+	 * If the unit is known not to support 'logical unit reset' then
+	 * skip 'logical unit reset' and try 'target reset' immediately.
+	 */
+	if (!atomic_test_mask(ZFCP_STATUS_UNIT_NOTSUPPUNITRESET,
+			      &unit->status)) {
+		retval =
+		    zfcp_task_management_function(unit, FCP_LOGICAL_UNIT_RESET);
+		if (retval) {
+			ZFCP_LOG_DEBUG("unit reset failed (unit=%p)\n", unit);
+			if (retval == -ENOTSUPP)
+				atomic_set_mask
+				    (ZFCP_STATUS_UNIT_NOTSUPPUNITRESET,
+				     &unit->status);
+			/* fall through and try 'target reset' next */
+		} else {
+			ZFCP_LOG_DEBUG("unit reset succeeded (unit=%p)\n",
+				       unit);
+			/* avoid 'target reset' */
+			retval = SUCCESS;
+			goto out;
+		}
+	}
+	retval = zfcp_task_management_function(unit, FCP_TARGET_RESET);
+	if (retval) {
+		ZFCP_LOG_DEBUG("target reset failed (unit=%p)\n", unit);
+		retval = FAILED;
+	} else {
+		ZFCP_LOG_DEBUG("target reset succeeded (unit=%p)\n", unit);
+		retval = SUCCESS;
+	}
+ out:
+	spin_lock_irq(scsi_host->host_lock);
+	return retval;
+}
+
+static int
+zfcp_task_management_function(struct zfcp_unit *unit, u8 tm_flags)
+{
+	struct zfcp_adapter *adapter = unit->port->adapter;
+	int retval;
+	int status;
+	struct zfcp_fsf_req *fsf_req;
+
+	/* issue task management function */
+	fsf_req = zfcp_fsf_send_fcp_command_task_management
+		(adapter, unit, tm_flags, 0);
+	if (!fsf_req) {
+		ZFCP_LOG_INFO("error: creation of task management request "
+			      "failed for unit 0x%016Lx on port 0x%016Lx on  "
+			      "adapter %s\n", unit->fcp_lun, unit->port->wwpn,
+			      zfcp_get_busid_by_adapter(adapter));
+		retval = -ENOMEM;
+		goto out;
+	}
+
+	retval = zfcp_fsf_req_wait_and_cleanup(fsf_req,
+					       ZFCP_UNINTERRUPTIBLE, &status);
+	/*
+	 * check completion status of task management function
+	 * (status should always be valid since no signals permitted)
+	 */
+	if (status & ZFCP_STATUS_FSFREQ_TMFUNCFAILED)
+		retval = -EIO;
+	else if (status & ZFCP_STATUS_FSFREQ_TMFUNCNOTSUPP)
+		retval = -ENOTSUPP;
+	else
+		retval = 0;
+ out:
+	return retval;
+}
+
+/*
+ * function:	zfcp_scsi_eh_bus_reset_handler
+ *
+ * purpose:
+ *
+ * returns:
+ */
+int
+zfcp_scsi_eh_bus_reset_handler(struct scsi_cmnd *scpnt)
+{
+	int retval = 0;
+	struct zfcp_unit *unit;
+	struct Scsi_Host *scsi_host = scpnt->device->host;
+
+	spin_unlock_irq(scsi_host->host_lock);
+
+	unit = (struct zfcp_unit *) scpnt->device->hostdata;
+	ZFCP_LOG_NORMAL("bus reset because of problems with "
+			"unit 0x%016Lx\n", unit->fcp_lun);
+	zfcp_erp_adapter_reopen(unit->port->adapter, 0);
+	zfcp_erp_wait(unit->port->adapter);
+	retval = SUCCESS;
+
+	spin_lock_irq(scsi_host->host_lock);
+	return retval;
+}
+
+/*
+ * function:	zfcp_scsi_eh_host_reset_handler
+ *
+ * purpose:
+ *
+ * returns:
+ */
+int
+zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)
+{
+	int retval = 0;
+	struct zfcp_unit *unit;
+	struct Scsi_Host *scsi_host = scpnt->device->host;
+
+	spin_unlock_irq(scsi_host->host_lock);
+
+	unit = (struct zfcp_unit *) scpnt->device->hostdata;
+	ZFCP_LOG_NORMAL("host reset because of problems with "
+			"unit 0x%016Lx\n", unit->fcp_lun);
+	zfcp_erp_adapter_reopen(unit->port->adapter, 0);
+	zfcp_erp_wait(unit->port->adapter);
+	retval = SUCCESS;
+
+	spin_lock_irq(scsi_host->host_lock);
+	return retval;
+}
+
+/*
+ * function:	
+ *
+ * purpose:	
+ *
+ * returns:
+ */
+int
+zfcp_adapter_scsi_register(struct zfcp_adapter *adapter)
+{
+	int retval = 0;
+	static unsigned int unique_id = 0;
+
+	/* register adapter as SCSI host with mid layer of SCSI stack */
+	adapter->scsi_host = scsi_host_alloc(&zfcp_data.scsi_host_template,
+					     sizeof (struct zfcp_adapter *));
+	if (!adapter->scsi_host) {
+		ZFCP_LOG_NORMAL("error: registration with SCSI stack failed "
+				"for adapter %s ",
+				zfcp_get_busid_by_adapter(adapter));
+		retval = -EIO;
+		goto out;
+	}
+	ZFCP_LOG_DEBUG("host registered, scsi_host=%p\n", adapter->scsi_host);
+
+	/* tell the SCSI stack some characteristics of this adapter */
+	adapter->scsi_host->max_id = 1;
+	adapter->scsi_host->max_lun = 1;
+	adapter->scsi_host->max_channel = 0;
+	adapter->scsi_host->unique_id = unique_id++;	/* FIXME */
+	adapter->scsi_host->max_cmd_len = ZFCP_MAX_SCSI_CMND_LENGTH;
+	adapter->scsi_host->transportt = zfcp_transport_template;
+	/*
+	 * Reverse mapping of the host number to avoid race condition
+	 */
+	adapter->scsi_host_no = adapter->scsi_host->host_no;
+
+	/*
+	 * save a pointer to our own adapter data structure within
+	 * hostdata field of SCSI host data structure
+	 */
+	adapter->scsi_host->hostdata[0] = (unsigned long) adapter;
+
+	if (scsi_add_host(adapter->scsi_host, &adapter->ccw_device->dev)) {
+		scsi_host_put(adapter->scsi_host);
+		retval = -EIO;
+		goto out;
+	}
+	atomic_set_mask(ZFCP_STATUS_ADAPTER_REGISTERED, &adapter->status);
+ out:
+	return retval;
+}
+
+/*
+ * function:	
+ *
+ * purpose:	
+ *
+ * returns:
+ */
+void
+zfcp_adapter_scsi_unregister(struct zfcp_adapter *adapter)
+{
+	struct Scsi_Host *shost;
+
+	shost = adapter->scsi_host;
+	if (!shost)
+		return;
+	scsi_remove_host(shost);
+	scsi_host_put(shost);
+	adapter->scsi_host = NULL;
+	adapter->scsi_host_no = 0;
+	atomic_clear_mask(ZFCP_STATUS_ADAPTER_REGISTERED, &adapter->status);
+
+	return;
+}
+
+
+void
+zfcp_fsf_start_scsi_er_timer(struct zfcp_adapter *adapter)
+{
+	adapter->scsi_er_timer.function = zfcp_fsf_scsi_er_timeout_handler;
+	adapter->scsi_er_timer.data = (unsigned long) adapter;
+	adapter->scsi_er_timer.expires = jiffies + ZFCP_SCSI_ER_TIMEOUT;
+	add_timer(&adapter->scsi_er_timer);
+}
+
+/*
+ * Support functions for FC transport class
+ */
+static void
+zfcp_get_port_id(struct scsi_target *starget)
+{
+	struct Scsi_Host *shost = dev_to_shost(starget->dev.parent);
+	struct zfcp_adapter *adapter = (struct zfcp_adapter *)shost->hostdata[0];
+	struct zfcp_port *port;
+	unsigned long flags;
+
+	read_lock_irqsave(&zfcp_data.config_lock, flags);
+	port = zfcp_port_lookup(adapter, starget->channel, starget->id);
+	if (port)
+		fc_starget_port_id(starget) = port->d_id;
+	else
+		fc_starget_port_id(starget) = -1;
+	read_unlock_irqrestore(&zfcp_data.config_lock, flags);
+}
+
+static void
+zfcp_get_port_name(struct scsi_target *starget)
+{
+	struct Scsi_Host *shost = dev_to_shost(starget->dev.parent);
+	struct zfcp_adapter *adapter = (struct zfcp_adapter *)shost->hostdata[0];
+	struct zfcp_port *port;
+	unsigned long flags;
+
+	read_lock_irqsave(&zfcp_data.config_lock, flags);
+	port = zfcp_port_lookup(adapter, starget->channel, starget->id);
+	if (port)
+		fc_starget_port_name(starget) = port->wwpn;
+	else
+		fc_starget_port_name(starget) = -1;
+	read_unlock_irqrestore(&zfcp_data.config_lock, flags);
+}
+
+static void
+zfcp_get_node_name(struct scsi_target *starget)
+{
+	struct Scsi_Host *shost = dev_to_shost(starget->dev.parent);
+	struct zfcp_adapter *adapter = (struct zfcp_adapter *)shost->hostdata[0];
+	struct zfcp_port *port;
+	unsigned long flags;
+
+	read_lock_irqsave(&zfcp_data.config_lock, flags);
+	port = zfcp_port_lookup(adapter, starget->channel, starget->id);
+	if (port)
+		fc_starget_node_name(starget) = port->wwnn;
+	else
+		fc_starget_node_name(starget) = -1;
+	read_unlock_irqrestore(&zfcp_data.config_lock, flags);
+}
+
+struct fc_function_template zfcp_transport_functions = {
+	.get_starget_port_id = zfcp_get_port_id,
+	.get_starget_port_name = zfcp_get_port_name,
+	.get_starget_node_name = zfcp_get_node_name,
+	.show_starget_port_id = 1,
+	.show_starget_port_name = 1,
+	.show_starget_node_name = 1,
+};
+
+/**
+ * ZFCP_DEFINE_SCSI_ATTR
+ * @_name:   name of show attribute
+ * @_format: format string
+ * @_value:  value to print
+ *
+ * Generates attribute for a unit.
+ */
+#define ZFCP_DEFINE_SCSI_ATTR(_name, _format, _value)                    \
+static ssize_t zfcp_sysfs_scsi_##_name##_show(struct device *dev,        \
+                                              char *buf)                 \
+{                                                                        \
+        struct scsi_device *sdev;                                        \
+        struct zfcp_unit *unit;                                          \
+                                                                         \
+        sdev = to_scsi_device(dev);                                      \
+        unit = sdev->hostdata;                                           \
+        return sprintf(buf, _format, _value);                            \
+}                                                                        \
+                                                                         \
+static DEVICE_ATTR(_name, S_IRUGO, zfcp_sysfs_scsi_##_name##_show, NULL);
+
+ZFCP_DEFINE_SCSI_ATTR(hba_id, "%s\n", zfcp_get_busid_by_unit(unit));
+ZFCP_DEFINE_SCSI_ATTR(wwpn, "0x%016llx\n", unit->port->wwpn);
+ZFCP_DEFINE_SCSI_ATTR(fcp_lun, "0x%016llx\n", unit->fcp_lun);
+
+static struct device_attribute *zfcp_sysfs_sdev_attrs[] = {
+	&dev_attr_fcp_lun,
+	&dev_attr_wwpn,
+	&dev_attr_hba_id,
+	NULL
+};
+
+#undef ZFCP_LOG_AREA
