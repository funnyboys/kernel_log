commit 616da39e0060f3b8bbc0f36f7d911bb5abb31746
Author: Jens Remus <jremus@linux.ibm.com>
Date:   Thu Mar 12 18:45:03 2020 +0100

    scsi: zfcp: trace FC Endpoint Security of FCP devices and connections
    
    Trace changes in Fibre Channel Endpoint Security capabilities of FCP
    devices as well as changes in Fibre Channel Endpoint Security state of
    their connections to FC remote ports as FC Endpoint Security changes with
    trace level 3 in HBA DBF.
    
    A change in FC Endpoint Security capabilities of FCP devices is traced as
    response to FSF command FSF_QTCB_EXCHANGE_PORT_DATA with a trace tag of
    "fsfcesa" and a WWPN of ZFCP_DBF_INVALID_WWPN = 0x0000000000000000 (see
    FC-FS-4 ยง18 "Name_Identifier Formats", NAA field).
    
    A change in FC Endpoint Security state of connections between FCP devices
    and FC remote ports is traced as response to FSF command
    FSF_QTCB_OPEN_PORT_WITH_DID with a trace tag of "fsfcesp".
    
    Example trace record of FC Endpoint Security capability change of FCP
    device formatted with zfcpdbf from s390-tools:
    
    Timestamp      : ...
    Area           : HBA
    Subarea        : 00
    Level          : 3
    Exception      : -
    CPU ID         : ...
    Caller         : 0x...
    Record ID      : 5                    ZFCP_DBF_HBA_FCES
    Tag            : fsfcesa              FSF FC Endpoint Security adapter
    Request ID     : 0x...
    Request status : 0x00000010
    FSF cmnd       : 0x0000000e           FSF_QTCB_EXCHANGE_PORT_DATA
    FSF sequence no: 0x...
    FSF issued     : ...
    FSF stat       : 0x00000000           FSF_GOOD
    FSF stat qual  : n/a
    Prot stat      : n/a
    Prot stat qual : n/a
    Port handle    : 0x00000000           none (invalid)
    LUN handle     : n/a
    WWPN           : 0x0000000000000000   ZFCP_DBF_INVALID_WWPN
    FCES old       : 0x00000000           old FC Endpoint Security
    FCES new       : 0x00000007           new FC Endpoint Security
    
    Example trace record of FC Endpoint Security change of connection to
    FC remote port formatted with zfcpdbf from s390-tools:
    
    Timestamp      : ...
    Area           : HBA
    Subarea        : 00
    Level          : 3
    Exception      : -
    CPU ID         : ...
    Caller         : 0x...
    Record ID      : 5                    ZFCP_DBF_HBA_FCES
    Tag            : fsfcesp              FSF FC Endpoint Security port
    Request ID     : 0x...
    Request status : 0x00000010
    FSF cmnd       : 0x00000005           FSF_QTCB_OPEN_PORT_WITH_DID
    FSF sequence no: 0x...
    FSF issued     : ...
    FSF stat       : 0x00000000           FSF_GOOD
    FSF stat qual  : n/a
    Prot stat      : n/a
    Prot stat qual : n/a
    Port handle    : 0x...
    WWPN           : 0x500507630401120c   WWPN
    FCES old       : 0x00000000           old FC Endpoint Security
    FCES new       : 0x00000004           new FC Endpoint Security
    
    Link: https://lore.kernel.org/r/20200312174505.51294-9-maier@linux.ibm.com
    Reviewed-by: Steffen Maier <maier@linux.ibm.com>
    Signed-off-by: Jens Remus <jremus@linux.ibm.com>
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 900c779cc39b..4d1435c573bc 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -3,7 +3,7 @@
  * zfcp device driver
  * debug feature declarations
  *
- * Copyright IBM Corp. 2008, 2017
+ * Copyright IBM Corp. 2008, 2020
  */
 
 #ifndef ZFCP_DBF_H
@@ -16,6 +16,7 @@
 
 #define ZFCP_DBF_TAG_LEN       7
 
+#define ZFCP_DBF_INVALID_WWPN	0x0000000000000000ull
 #define ZFCP_DBF_INVALID_LUN	0xFFFFFFFFFFFFFFFFull
 
 enum zfcp_dbf_pseudo_erp_act_type {
@@ -157,18 +158,39 @@ struct zfcp_dbf_hba_uss {
 	u64 queue_designator;
 } __packed;
 
+/**
+ * struct zfcp_dbf_hba_fces - trace record for FC Endpoint Security
+ * @req_issued: timestamp when request was issued
+ * @fsf_status: fsf status
+ * @port_handle: handle for port
+ * @wwpn: remote FC port WWPN
+ * @fc_security_old: old FC Endpoint Security
+ * @fc_security_new: new FC Endpoint Security
+ *
+ */
+struct zfcp_dbf_hba_fces {
+	u64 req_issued;
+	u32 fsf_status;
+	u32 port_handle;
+	u64 wwpn;
+	u32 fc_security_old;
+	u32 fc_security_new;
+} __packed;
+
 /**
  * enum zfcp_dbf_hba_id - HBA trace record identifier
  * @ZFCP_DBF_HBA_RES: response trace record
  * @ZFCP_DBF_HBA_USS: unsolicited status trace record
  * @ZFCP_DBF_HBA_BIT: bit error trace record
  * @ZFCP_DBF_HBA_BASIC: basic adapter event, only trace tag, no other data
+ * @ZFCP_DBF_HBA_FCES: FC Endpoint Security trace record
  */
 enum zfcp_dbf_hba_id {
 	ZFCP_DBF_HBA_RES	= 1,
 	ZFCP_DBF_HBA_USS	= 2,
 	ZFCP_DBF_HBA_BIT	= 3,
 	ZFCP_DBF_HBA_BASIC	= 4,
+	ZFCP_DBF_HBA_FCES	= 5,
 };
 
 /**
@@ -181,9 +203,10 @@ enum zfcp_dbf_hba_id {
  * @fsf_seq_no: fsf sequence number
  * @pl_len: length of payload stored as zfcp_dbf_pay
  * @u: record type specific data
- * @u.res: data for fsf responses
- * @u.uss: data for unsolicited status buffer
- * @u.be:  data for bit error unsolicited status buffer
+ * @u.res:  data for fsf responses
+ * @u.uss:  data for unsolicited status buffer
+ * @u.be:   data for bit error unsolicited status buffer
+ * @u.fces: data for FC Endpoint Security
  */
 struct zfcp_dbf_hba {
 	u8 id;
@@ -197,6 +220,7 @@ struct zfcp_dbf_hba {
 		struct zfcp_dbf_hba_res res;
 		struct zfcp_dbf_hba_uss uss;
 		struct fsf_bit_error_payload be;
+		struct zfcp_dbf_hba_fces fces;
 	} u;
 } __packed;
 

commit 623cd180c10c5bec815a46c4ce73c8c148d2f518
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Thu Nov 8 15:44:55 2018 +0100

    scsi: zfcp: silence remaining kdoc warnings in header files
    
    Improve whatever the following simple invocation reported:
    $ ./scripts/kernel-doc -none drivers/s390/scsi/*.h
    
    While at it, improve some related kdoc,
    including struct zfcp_fsf_ct_els in zfcp_fsf.h.
    
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index b4438713d1cc..900c779cc39b 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -42,7 +42,8 @@ struct zfcp_dbf_rec_trigger {
  * @fsf_req_id: request id for fsf requests
  * @rec_status: status of the fsf request
  * @rec_step: current step of the recovery action
- * rec_count: recovery counter
+ * @rec_action: ERP action type
+ * @rec_count: recoveries including retries for particular @rec_action
  */
 struct zfcp_dbf_rec_running {
 	u64 fsf_req_id;
@@ -72,6 +73,7 @@ enum zfcp_dbf_rec_id {
  * @adapter_status: current status of the adapter
  * @port_status: current status of the port
  * @lun_status: current status of the lun
+ * @u: record type specific data
  * @u.trig: structure zfcp_dbf_rec_trigger
  * @u.run: structure zfcp_dbf_rec_running
  */
@@ -126,6 +128,8 @@ struct zfcp_dbf_san {
  * @prot_status_qual: protocol status qualifier
  * @fsf_status: fsf status
  * @fsf_status_qual: fsf status qualifier
+ * @port_handle: handle for port
+ * @lun_handle: handle for LUN
  */
 struct zfcp_dbf_hba_res {
 	u64 req_issued;
@@ -158,6 +162,7 @@ struct zfcp_dbf_hba_uss {
  * @ZFCP_DBF_HBA_RES: response trace record
  * @ZFCP_DBF_HBA_USS: unsolicited status trace record
  * @ZFCP_DBF_HBA_BIT: bit error trace record
+ * @ZFCP_DBF_HBA_BASIC: basic adapter event, only trace tag, no other data
  */
 enum zfcp_dbf_hba_id {
 	ZFCP_DBF_HBA_RES	= 1,
@@ -176,6 +181,9 @@ enum zfcp_dbf_hba_id {
  * @fsf_seq_no: fsf sequence number
  * @pl_len: length of payload stored as zfcp_dbf_pay
  * @u: record type specific data
+ * @u.res: data for fsf responses
+ * @u.uss: data for unsolicited status buffer
+ * @u.be:  data for bit error unsolicited status buffer
  */
 struct zfcp_dbf_hba {
 	u8 id;

commit f9eca022760079c0556cb311e3aa9091a3921a31
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Thu Nov 8 15:44:45 2018 +0100

    scsi: zfcp: drop duplicate fsf_command from zfcp_fsf_req which is also in QTCB header
    
    Status read buffers (SRBs, unsolicited notifications) never use a QTCB
    [zfcp_fsf_req_create()]. zfcp_fsf_req_send() already uses this to
    distinguish SRBs from other FSF request types. We can re-use this method in
    zfcp_fsf_req_complete(). Introduce a helper function to make the check for
    req->qtcb less magic.
    
    SRBs always are FSF_QTCB_UNSOLICITED_STATUS, so we can hard-code this for
    the two trace functions dealing with SRBs.
    
    All other FSF request types have a QTCB and we can get the fsf_command from
    there.
    
    zfcp_dbf_hba_fsf_response() and thus zfcp_dbf_hba_fsf_res() are only called
    for non-SRB requests so it's safe to dereference the QTCB
    [zfcp_fsf_req_complete() returns early on SRB, else calls
    zfcp_fsf_protstatus_eval() which calls zfcp_dbf_hba_fsf_response()].  In
    zfcp_scsi_forget_cmnd() we guard the QTCB dereference with a preceding NULL
    check and rely on boolean shortcut evaluation.
    
    As a side effect, this causes an alignment hole which we can close in
    a later patch after having cleaned up all fields of struct zfcp_fsf_req.
    Before:
    $ pahole -C zfcp_fsf_req drivers/s390/scsi/zfcp.ko
    ...
            u32                        status;               /*   136     4 */
            u32                        fsf_command;          /*   140     4 */
            struct fsf_qtcb *          qtcb;                 /*   144     8 */
    ...
    After:
    $ pahole -C zfcp_fsf_req drivers/s390/scsi/zfcp.ko
    ...
            u32                        status;               /*   136     4 */
            /* XXX 4 bytes hole, try to pack */
            struct fsf_qtcb *          qtcb;                 /*   144     8 */
    ...
    
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index d116c07ed77a..b4438713d1cc 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -339,8 +339,8 @@ void zfcp_dbf_hba_fsf_response(struct zfcp_fsf_req *req)
 				      zfcp_dbf_hba_fsf_resp_suppress(req)
 				      ? 5 : 1, req);
 
-	} else if ((req->fsf_command == FSF_QTCB_OPEN_PORT_WITH_DID) ||
-		   (req->fsf_command == FSF_QTCB_OPEN_LUN)) {
+	} else if ((qtcb->header.fsf_command == FSF_QTCB_OPEN_PORT_WITH_DID) ||
+		   (qtcb->header.fsf_command == FSF_QTCB_OPEN_LUN)) {
 		zfcp_dbf_hba_fsf_resp("fs_open", 4, req);
 
 	} else if (qtcb->header.log_length) {

commit 8221211863750b1afb1f464a264c05383b077a06
Author: Steffen Maier <maier@linux.ibm.com>
Date:   Thu May 17 19:14:50 2018 +0200

    scsi: zfcp: decouple SCSI traces for scsi_eh / TMF from scsi_cmnd
    
    The SCSI command pointer passed to scsi_eh callbacks is just one arbitrary
    command of potentially many that are in the eh queue to be processed.  The
    command is only used to indirectly pass the TMF scope in terms of SCSI
    ID/target and SCSI LUN for LUN reset.
    
    Hence, zfcp had filled in SCSI trace record fields which do not really
    belong to the TMF. This was confusing.
    
    Therefore, refactor the TMF tracing to work without SCSI command.  Since the
    FCP channel always requires a valid LUN handle, we use SCSI device as common
    context for any TMF (even target reset).  To make it even clearer, we set
    all bits to 1 for the fields, which do not belong to the TMF, to indicate
    that these fields are invalid.
    
    The old zfcp_dbf_scsi() became zfcp_dbf_scsi_common() to now handle both
    SCSI commands and TMFs. The old argument scsi_cmnd is now optional and can
    be NULL with TMFs. The new argument scsi_device is mandatory to carry
    context, as well as SCSI ID/target and SCSI LUN in case of TMFs.
    
    New example trace record formatted with zfcpdbf from s390-tools:
    
    Timestamp      : ...
    Area           : SCSI
    Subarea        : 00
    Level          : 1
    Exception      : -
    CPU ID         : ..
    Caller         : 0x...
    Record ID      : 1
    Tag            : [lt]r_....
    Request ID     : 0x<reqid>              ID of FSF FCP request with TM flag
                     For cases without FSF request: 0x0 for none (invalid)
    SCSI ID        : 0x<scsi_id>            SCSI ID/target denoting scope
    SCSI LUN       : 0x<scsi_lun>           SCSI LUN denoting scope
    SCSI LUN high  : 0x<scsi_lun_high>      SCSI LUN denoting scope
    SCSI result    : 0xffffffff                             none (invalid)
    SCSI retries   : 0xff                                   none (invalid)
    SCSI allowed   : 0xff                                   none (invalid)
    SCSI scribble  : 0xffffffffffffffff                     none (invalid)
    SCSI opcode    : ffffffff ffffffff ffffffff ffffffff    none (invalid)
    FCP rsp inf cod: 0x00                   FCP_RSP info code of TMF
    FCP rsp IU     : 00000000 00000000 00000100 00000000 ext FCP_RSP IU
                     00000000 00000008                   ext FCP_RSP IU
    FCP rsp IU len : 32                                  FCP_RSP IU length
    Payload time   : ...
    FCP rsp IU all : 00000000 00000000 00000100 00000000 full FCP_RSP IU
                     00000000 00000008 00000000 00000000 full FCP_RSP IU
    
    Signed-off-by: Steffen Maier <maier@linux.ibm.com>
    Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index e2a973cd2573..d116c07ed77a 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -359,7 +359,7 @@ void _zfcp_dbf_scsi(char *tag, int level, struct scsi_cmnd *scmd,
 					scmd->device->host->hostdata[0];
 
 	if (debug_level_enabled(adapter->dbf->scsi, level))
-		zfcp_dbf_scsi(tag, level, scmd, req);
+		zfcp_dbf_scsi_common(tag, level, scmd->device, scmd, req);
 }
 
 /**
@@ -402,16 +402,23 @@ void zfcp_dbf_scsi_abort(char *tag, struct scsi_cmnd *scmd,
 }
 
 /**
- * zfcp_dbf_scsi_devreset - trace event for Logical Unit or Target Reset
- * @tag: tag indicating success or failure of reset operation
- * @scmnd: SCSI command which caused this error recovery
- * @flag: indicates type of reset (Target Reset, Logical Unit Reset)
+ * zfcp_dbf_scsi_devreset() - Trace event for Logical Unit or Target Reset.
+ * @tag: Tag indicating success or failure of reset operation.
+ * @sdev: Pointer to SCSI device as context for this event.
+ * @flag: Indicates type of reset (Target Reset, Logical Unit Reset).
+ * @fsf_req: Pointer to FSF request representing the TMF, or NULL.
  */
 static inline
-void zfcp_dbf_scsi_devreset(char *tag, struct scsi_cmnd *scmnd, u8 flag,
+void zfcp_dbf_scsi_devreset(char *tag, struct scsi_device *sdev, u8 flag,
 			    struct zfcp_fsf_req *fsf_req)
 {
+	struct zfcp_adapter *adapter = (struct zfcp_adapter *)
+					sdev->host->hostdata[0];
 	char tmp_tag[ZFCP_DBF_TAG_LEN];
+	static int const level = 1;
+
+	if (unlikely(!debug_level_enabled(adapter->dbf->scsi, level)))
+		return;
 
 	if (flag == FCP_TMF_TGT_RESET)
 		memcpy(tmp_tag, "tr_", 3);
@@ -419,7 +426,7 @@ void zfcp_dbf_scsi_devreset(char *tag, struct scsi_cmnd *scmnd, u8 flag,
 		memcpy(tmp_tag, "lr_", 3);
 
 	memcpy(&tmp_tag[3], tag, 4);
-	_zfcp_dbf_scsi(tmp_tag, 1, scmnd, fsf_req);
+	zfcp_dbf_scsi_common(tmp_tag, level, sdev, NULL, fsf_req);
 }
 
 /**

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 3508c00458f4..e2a973cd2573 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * zfcp device driver
  * debug feature declarations

commit 5b2fc2a12c64e81d3bd8169657d6f740a0ee5cfd
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Jul 28 12:31:03 2017 +0200

    scsi: zfcp: fix kernel doc comment typos for struct zfcp_dbf_scsi
    
    Improves commit 250a1352b95e ("[SCSI] zfcp: Redesign of the debug tracing
    for SCSI records.")
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 33ccf15b63e0..3508c00458f4 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -208,12 +208,12 @@ enum zfcp_dbf_scsi_id {
  * @scsi_result: scsi result
  * @scsi_retries: current retry number of scsi request
  * @scsi_allowed: allowed retries
- * @fcp_rsp_info: FCP response info
+ * @fcp_rsp_info: FCP response info code
  * @scsi_opcode: scsi opcode
  * @fsf_req_id: request id of fsf request
  * @host_scribble: LLD specific data attached to SCSI request
- * @pl_len: length of paload stored as zfcp_dbf_pay
- * @fsf_rsp: response for fsf request
+ * @pl_len: length of payload stored as zfcp_dbf_pay
+ * @fcp_rsp: response for FCP request
  * @scsi_lun_64_hi: scsi device logical unit number, high part of 64 bit
  */
 struct zfcp_dbf_scsi {

commit df00d7b8d5533a35d03e97b7804e8fa3157831a0
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Jul 28 12:31:01 2017 +0200

    scsi: zfcp: use common code fcp_cmnd and fcp_resp with union in fsf_qtcb_bottom_io
    
    This eases crash dump analysis by automatically dissecting these
    protocol headers at least somewhat rather than getting a string
    interpretation of large unstructured character array buffer fields.
    
    Also, we can get rid of some unnecessary and error-prone type casts.
    
    This change is possible since v2.6.33 commit 4318e08c84e4
    ("[SCSI] zfcp: Update FCP protocol related code").
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index b60667c145fd..33ccf15b63e0 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -301,7 +301,7 @@ bool zfcp_dbf_hba_fsf_resp_suppress(struct zfcp_fsf_req *req)
 
 	if (qtcb->prefix.qtcb_type != FSF_IO_COMMAND)
 		return false; /* not an FCP response */
-	fcp_rsp = (struct fcp_resp *)&qtcb->bottom.io.fcp_rsp;
+	fcp_rsp = &qtcb->bottom.io.fcp_rsp.iu.resp;
 	rsp_flags = fcp_rsp->fr_flags;
 	fr_status = fcp_rsp->fr_status;
 	return (fsf_stat == FSF_FCP_RSP_AVAILABLE) &&

commit 5d4a3d0a2ff23799b956e5962b886287614e7fad
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Jul 28 12:30:58 2017 +0200

    scsi: zfcp: trace high part of "new" 64 bit SCSI LUN
    
    Complements debugging aspects of the otherwise functionally complete
    v3.17 commit 9cb78c16f5da ("scsi: use 64-bit LUNs").
    
    While I don't have access to a target exporting 3 or 4 level LUNs,
    I did test it by explicitly attaching a non-existent fake 4 level LUN
    by means of zfcp sysfs attribute "unit_add".
    In order to see corresponding trace records of otherwise successful
    events, we had to increase the trace level of area SCSI and HBA to 6.
    
    $ echo 6 > /sys/kernel/debug/s390dbf/zfcp_0.0.1880_scsi/level
    $ echo 6 > /sys/kernel/debug/s390dbf/zfcp_0.0.1880_hba/level
    
    $ echo 0x4011402240334044 > \
      /sys/bus/ccw/drivers/zfcp/0.0.1880/0x50050763031bd327/unit_add
    
    Example output formatted by an updated zfcpdbf from the s390-tools
    package interspersed with kernel messages at scsi_logging_level=4605:
    
    Timestamp      : ...
    Area           : REC
    Subarea        : 00
    Level          : 1
    Exception      : -
    CPU ID         : ..
    Caller         : 0x...
    Record ID      : 1
    Tag            : scsla_1
    LUN            : 0x4011402240334044
    WWPN           : 0x50050763031bd327
    D_ID           : 0x00......
    Adapter status : 0x5400050b
    Port status    : 0x54000001
    LUN status     : 0x41000000
    Ready count    : 0x00000001
    Running count  : 0x00000000
    ERP want       : 0x01
    ERP need       : 0x01
    
    scsi 2:0:0:4630896905707208721: scsi scan: INQUIRY pass 1 length 36
    scsi 2:0:0:4630896905707208721: scsi scan: INQUIRY successful with code 0x0
    
    Timestamp      : ...
    Area           : HBA
    Subarea        : 00
    Level          : 6
    Exception      : -
    CPU ID         : ..
    Caller         : 0x...
    Record ID      : 1
    Tag            : fs_norm
    Request ID     : 0x<inquiry2-req-id>
    Request status : 0x00000010
    FSF cmnd       : 0x00000001
    FSF sequence no: 0x...
    FSF issued     : ...
    FSF stat       : 0x00000000
    FSF stat qual  : 00000000 00000000 00000000 00000000
    Prot stat      : 0x00000001
    Prot stat qual : ........ ........ 00000000 00000000
    Port handle    : 0x...
    LUN handle     : 0x...
    |
    Timestamp      : ...
    Area           : SCSI
    Subarea        : 00
    Level          : 6
    Exception      : -
    CPU ID         : ..
    Caller         : 0x...
    Record ID      : 1
    Tag            : rsl_nor
    Request ID     : 0x<inquiry2-req-id>
    SCSI ID        : 0x00000000
    SCSI LUN       : 0x40224011
    SCSI LUN high  : 0x40444033 <=======================
    SCSI result    : 0x00000000
    SCSI retries   : 0x00
    SCSI allowed   : 0x03
    SCSI scribble  : 0x<inquiry2-req-id>
    SCSI opcode    : 12000000 a4000000 00000000 00000000
    FCP rsp inf cod: 0x00
    FCP rsp IU     : 00000000 00000000 00000000 00000000
                     00000000 00000000
    
    scsi 2:0:0:4630896905707208721: scsi scan: INQUIRY pass 2 length 164
    scsi 2:0:0:4630896905707208721: scsi scan: INQUIRY successful with code 0x0
    scsi 2:0:0:4630896905707208721: scsi scan: peripheral device type of 31, \
    no device added
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: 9cb78c16f5da ("scsi: use 64-bit LUNs")
    Cc: <stable@vger.kernel.org> #3.17+
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Reviewed-by: Jens Remus <jremus@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 8e7f8e6037d2..b60667c145fd 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -204,7 +204,7 @@ enum zfcp_dbf_scsi_id {
  * @id: unique number of recovery record type
  * @tag: identifier string specifying the location of initiation
  * @scsi_id: scsi device id
- * @scsi_lun: scsi device logical unit number
+ * @scsi_lun: scsi device logical unit number, low part of 64 bit, old 32 bit
  * @scsi_result: scsi result
  * @scsi_retries: current retry number of scsi request
  * @scsi_allowed: allowed retries
@@ -214,6 +214,7 @@ enum zfcp_dbf_scsi_id {
  * @host_scribble: LLD specific data attached to SCSI request
  * @pl_len: length of paload stored as zfcp_dbf_pay
  * @fsf_rsp: response for fsf request
+ * @scsi_lun_64_hi: scsi device logical unit number, high part of 64 bit
  */
 struct zfcp_dbf_scsi {
 	u8 id;
@@ -230,6 +231,7 @@ struct zfcp_dbf_scsi {
 	u64 host_scribble;
 	u16 pl_len;
 	struct fcp_resp_with_ext fcp_rsp;
+	u32 scsi_lun_64_hi;
 } __packed;
 
 /**

commit fdb7cee3b9e3c561502e58137a837341f10cbf8b
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Jul 28 12:30:57 2017 +0200

    scsi: zfcp: trace HBA FSF response by default on dismiss or timedout late response
    
    At the default trace level, we only trace unsuccessful events including
    FSF responses.
    
    zfcp_dbf_hba_fsf_response() only used protocol status and FSF status to
    decide on an unsuccessful response. However, this is only one of multiple
    possible sources determining a failed struct zfcp_fsf_req.
    
    An FSF request can also "fail" if its response runs into an ERP timeout
    or if it gets dismissed because a higher level recovery was triggered
    [trace tags "erscf_1" or "erscf_2" in zfcp_erp_strategy_check_fsfreq()].
    FSF requests with ERP timeout are:
    FSF_QTCB_EXCHANGE_CONFIG_DATA, FSF_QTCB_EXCHANGE_PORT_DATA,
    FSF_QTCB_OPEN_PORT_WITH_DID or FSF_QTCB_CLOSE_PORT or
    FSF_QTCB_CLOSE_PHYSICAL_PORT for target ports,
    FSF_QTCB_OPEN_LUN, FSF_QTCB_CLOSE_LUN.
    One example is slow queue processing which can cause follow-on errors,
    e.g. FSF_PORT_ALREADY_OPEN after FSF_QTCB_OPEN_PORT_WITH_DID timed out.
    In order to see the root cause, we need to see late responses even if the
    channel presented them successfully with FSF_PROT_GOOD and FSF_GOOD.
    Example trace records formatted with zfcpdbf from the s390-tools package:
    
    Timestamp      : ...
    Area           : REC
    Subarea        : 00
    Level          : 1
    Exception      : -
    CPU ID         : ..
    Caller         : ...
    Record ID      : 1
    Tag            : fcegpf1
    LUN            : 0xffffffffffffffff
    WWPN           : 0x<WWPN>
    D_ID           : 0x00<D_ID>
    Adapter status : 0x5400050b
    Port status    : 0x41200000
    LUN status     : 0x00000000
    Ready count    : 0x00000001
    Running count  : 0x...
    ERP want       : 0x02                           ZFCP_ERP_ACTION_REOPEN_PORT
    ERP need       : 0x02                           ZFCP_ERP_ACTION_REOPEN_PORT
    |
    Timestamp      : ...                            30 seconds later
    Area           : REC
    Subarea        : 00
    Level          : 1
    Exception      : -
    CPU ID         : ..
    Caller         : ...
    Record ID      : 2
    Tag            : erscf_2
    LUN            : 0xffffffffffffffff
    WWPN           : 0x<WWPN>
    D_ID           : 0x00<D_ID>
    Adapter status : 0x5400050b
    Port status    : 0x41200000
    LUN status     : 0x00000000
    Request ID     : 0x<request_ID>
    ERP status     : 0x10000000                     ZFCP_STATUS_ERP_TIMEDOUT
    ERP step       : 0x0800                         ZFCP_ERP_STEP_PORT_OPENING
    ERP action     : 0x02                           ZFCP_ERP_ACTION_REOPEN_PORT
    ERP count      : 0x00
    |
    Timestamp      : ...                            later than previous record
    Area           : HBA
    Subarea        : 00
    Level          : 5      > default level         => 3    <= default level
    Exception      : -
    CPU ID         : 00
    Caller         : ...
    Record ID      : 1
    Tag            : fs_qtcb                        => fs_rerr
    Request ID     : 0x<request_ID>
    Request status : 0x00001010                     ZFCP_STATUS_FSFREQ_DISMISSED
                                                    | ZFCP_STATUS_FSFREQ_CLEANUP
    FSF cmnd       : 0x00000005
    FSF sequence no: 0x...
    FSF issued     : ...                            > 30 seconds ago
    FSF stat       : 0x00000000                     FSF_GOOD
    FSF stat qual  : 00000000 00000000 00000000 00000000
    Prot stat      : 0x00000001                     FSF_PROT_GOOD
    Prot stat qual : 00000000 00000000 00000000 00000000
    Port handle    : 0x...
    LUN handle     : 0x00000000
    QTCB log length: ...
    QTCB log info  : ...
    
    In case of problems detecting that new responses are waiting on the input
    queue, we sooner or later trigger adapter recovery due to an FSF request
    timeout (trace tag "fsrth_1").
    FSF requests with FSF request timeout are:
    typically FSF_QTCB_ABORT_FCP_CMND; but theoretically also
    FSF_QTCB_EXCHANGE_CONFIG_DATA or FSF_QTCB_EXCHANGE_PORT_DATA via sysfs,
    FSF_QTCB_OPEN_PORT_WITH_DID or FSF_QTCB_CLOSE_PORT for WKA ports,
    FSF_QTCB_FCP_CMND for task management function (LUN / target reset).
    One or more pending requests can meanwhile have FSF_PROT_GOOD and FSF_GOOD
    because the channel filled in the response via DMA into the request's QTCB.
    
    In a theroretical case, inject code can create an erroneous FSF request
    on purpose. If data router is enabled, it uses deferred error reporting.
    A READ SCSI command can succeed with FSF_PROT_GOOD, FSF_GOOD, and
    SAM_STAT_GOOD. But on writing the read data to host memory via DMA,
    it can still fail, e.g. if an intentionally wrong scatter list does not
    provide enough space. Rather than getting an unsuccessful response,
    we get a QDIO activate check which in turn triggers adapter recovery.
    One or more pending requests can meanwhile have FSF_PROT_GOOD and FSF_GOOD
    because the channel filled in the response via DMA into the request's QTCB.
    Example trace records formatted with zfcpdbf from the s390-tools package:
    
    Timestamp      : ...
    Area           : HBA
    Subarea        : 00
    Level          : 6      > default level         => 3    <= default level
    Exception      : -
    CPU ID         : ..
    Caller         : ...
    Record ID      : 1
    Tag            : fs_norm                        => fs_rerr
    Request ID     : 0x<request_ID2>
    Request status : 0x00001010                     ZFCP_STATUS_FSFREQ_DISMISSED
                                                    | ZFCP_STATUS_FSFREQ_CLEANUP
    FSF cmnd       : 0x00000001
    FSF sequence no: 0x...
    FSF issued     : ...
    FSF stat       : 0x00000000                     FSF_GOOD
    FSF stat qual  : 00000000 00000000 00000000 00000000
    Prot stat      : 0x00000001                     FSF_PROT_GOOD
    Prot stat qual : ........ ........ 00000000 00000000
    Port handle    : 0x...
    LUN handle     : 0x...
    |
    Timestamp      : ...
    Area           : SCSI
    Subarea        : 00
    Level          : 3
    Exception      : -
    CPU ID         : ..
    Caller         : ...
    Record ID      : 1
    Tag            : rsl_err
    Request ID     : 0x<request_ID2>
    SCSI ID        : 0x...
    SCSI LUN       : 0x...
    SCSI result    : 0x000e0000                     DID_TRANSPORT_DISRUPTED
    SCSI retries   : 0x00
    SCSI allowed   : 0x05
    SCSI scribble  : 0x<request_ID2>
    SCSI opcode    : 28...                          Read(10)
    FCP rsp inf cod: 0x00
    FCP rsp IU     : 00000000 00000000 00000000 00000000
                                             ^^     SAM_STAT_GOOD
                     00000000 00000000
    
    Only with luck in both above cases, we could see a follow-on trace record
    of an unsuccesful event following a successful but late FSF response with
    FSF_PROT_GOOD and FSF_GOOD. Typically this was the case for I/O requests
    resulting in a SCSI trace record "rsl_err" with DID_TRANSPORT_DISRUPTED
    [On ZFCP_STATUS_FSFREQ_DISMISSED, zfcp_fsf_protstatus_eval() sets
    ZFCP_STATUS_FSFREQ_ERROR seen by the request handler functions as failure].
    However, the reason for this follow-on trace was invisible because the
    corresponding HBA trace record was missing at the default trace level
    (by default hidden records with tags "fs_norm", "fs_qtcb", or "fs_open").
    
    On adapter recovery, after we had shut down the QDIO queues, we perform
    unsuccessful pseudo completions with flag ZFCP_STATUS_FSFREQ_DISMISSED
    for each pending FSF request in zfcp_fsf_req_dismiss_all().
    In order to find the root cause, we need to see all pseudo responses even
    if the channel presented them successfully with FSF_PROT_GOOD and FSF_GOOD.
    
    Therefore, check zfcp_fsf_req.status for ZFCP_STATUS_FSFREQ_DISMISSED
    or ZFCP_STATUS_FSFREQ_ERROR and trace with a new tag "fs_rerr".
    
    It does not matter that there are numerous places which set
    ZFCP_STATUS_FSFREQ_ERROR after the location where we trace an FSF response
    early. These cases are based on protocol status != FSF_PROT_GOOD or
    == FSF_PROT_FSF_STATUS_PRESENTED and are thus already traced by default
    as trace tag "fs_perr" or "fs_ferr" respectively.
    
    NB: The trace record with tag "fssrh_1" for status read buffers on dismiss
    all remains. zfcp_fsf_req_complete() handles this and returns early.
    All other FSF request types are handled separately and as described above.
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: 8a36e4532ea1 ("[SCSI] zfcp: enhancement of zfcp debug features")
    Fixes: 2e261af84cdb ("[SCSI] zfcp: Only collect FSF/HBA debug data for matching trace levels")
    Cc: <stable@vger.kernel.org> #2.6.38+
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 776d1ac125ff..8e7f8e6037d2 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -323,7 +323,11 @@ void zfcp_dbf_hba_fsf_response(struct zfcp_fsf_req *req)
 {
 	struct fsf_qtcb *qtcb = req->qtcb;
 
-	if ((qtcb->prefix.prot_status != FSF_PROT_GOOD) &&
+	if (unlikely(req->status & (ZFCP_STATUS_FSFREQ_DISMISSED |
+				    ZFCP_STATUS_FSFREQ_ERROR))) {
+		zfcp_dbf_hba_fsf_resp("fs_rerr", 3, req);
+
+	} else if ((qtcb->prefix.prot_status != FSF_PROT_GOOD) &&
 	    (qtcb->prefix.prot_status != FSF_PROT_FSF_STATUS_PRESENTED)) {
 		zfcp_dbf_hba_fsf_resp("fs_perr", 1, req);
 

commit 9fe5d2b2fd30aa8c7827ec62cbbe6d30df4fe3e3
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Jul 28 12:30:54 2017 +0200

    scsi: zfcp: fix passing fsf_req to SCSI trace on TMF to correlate with HBA
    
    Without this fix we get SCSI trace records on task management functions
    which cannot be correlated to HBA trace records because all fields
    related to the FSF request are empty (zero).
    Also, the FCP_RSP_IU is missing as well as any sense data if available.
    
    This was caused by v2.6.14 commit 8a36e4532ea1 ("[SCSI] zfcp: enhancement
    of zfcp debug features") introducing trace records for TMFs but
    hard coding NULL for a possibly existing TMF FSF request.
    The scsi_cmnd scribble is also zero or unrelated for the TMF request
    so it also could not lookup a suitable FSF request from there.
    
    A broken example trace record formatted with zfcpdbf from the s390-tools
    package:
    
    Timestamp      : ...
    Area           : SCSI
    Subarea        : 00
    Level          : 1
    Exception      : -
    CPU ID         : ..
    Caller         : 0x...
    Record ID      : 1
    Tag            : lr_fail
    Request ID     : 0x0000000000000000
                       ^^^^^^^^^^^^^^^^ no correlation to HBA record
    SCSI ID        : 0x<scsitarget>
    SCSI LUN       : 0x<scsilun>
    SCSI result    : 0x000e0000
    SCSI retries   : 0x00
    SCSI allowed   : 0x05
    SCSI scribble  : 0x0000000000000000
    SCSI opcode    : 2a000017 3bb80000 08000000 00000000
    FCP rsp inf cod: 0x00
                       ^^ no TMF response
    FCP rsp IU     : 00000000 00000000 00000000 00000000
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                     00000000 00000000
                     ^^^^^^^^^^^^^^^^^ no interesting FCP_RSP_IU
    Sense len      : ...
    ^^^^^^^^^^^^^^^^^^^^ no sense data length
    Sense info     : ...
    ^^^^^^^^^^^^^^^^^^^^ no sense data content, even if present
    
    There are some true cases where we really do not have an FSF request:
    "rsl_fai" from zfcp_dbf_scsi_fail_send() called for early
    returns / completions in zfcp_scsi_queuecommand(),
    "abrt_or", "abrt_bl", "abrt_ru", "abrt_ar" from
    zfcp_scsi_eh_abort_handler() where we did not get as far,
    "lr_nres", "tr_nres" from zfcp_task_mgmt_function() where we're
    successful and do not need to do anything because adapter stopped.
    For these cases it's correct to pass NULL for fsf_req to _zfcp_dbf_scsi().
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: 8a36e4532ea1 ("[SCSI] zfcp: enhancement of zfcp debug features")
    Cc: <stable@vger.kernel.org> #2.6.38+
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index db186d44cfaf..776d1ac125ff 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -2,7 +2,7 @@
  * zfcp device driver
  * debug feature declarations
  *
- * Copyright IBM Corp. 2008, 2016
+ * Copyright IBM Corp. 2008, 2017
  */
 
 #ifndef ZFCP_DBF_H
@@ -401,7 +401,8 @@ void zfcp_dbf_scsi_abort(char *tag, struct scsi_cmnd *scmd,
  * @flag: indicates type of reset (Target Reset, Logical Unit Reset)
  */
 static inline
-void zfcp_dbf_scsi_devreset(char *tag, struct scsi_cmnd *scmnd, u8 flag)
+void zfcp_dbf_scsi_devreset(char *tag, struct scsi_cmnd *scmnd, u8 flag,
+			    struct zfcp_fsf_req *fsf_req)
 {
 	char tmp_tag[ZFCP_DBF_TAG_LEN];
 
@@ -411,7 +412,7 @@ void zfcp_dbf_scsi_devreset(char *tag, struct scsi_cmnd *scmnd, u8 flag)
 		memcpy(tmp_tag, "lr_", 3);
 
 	memcpy(&tmp_tag[3], tag, 4);
-	_zfcp_dbf_scsi(tmp_tag, 1, scmnd, NULL);
+	_zfcp_dbf_scsi(tmp_tag, 1, scmnd, fsf_req);
 }
 
 /**

commit 56d23ed7adf3974f10e91b643bd230e9c65b5f79
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Fri Dec 9 17:16:32 2016 +0100

    scsi: zfcp: do not trace pure benign residual HBA responses at default level
    
    Since quite a while, Linux issues enough SCSI commands per scsi_device
    which successfully return with FCP_RESID_UNDER, FSF_FCP_RSP_AVAILABLE,
    and SAM_STAT_GOOD.  This floods the HBA trace area and we cannot see
    other and important HBA trace records long enough.
    
    Therefore, do not trace HBA response errors for pure benign residual
    under counts at the default trace level.
    
    This excludes benign residual under count combined with other validity
    bits set in FCP_RSP_IU, such as FCP_SNS_LEN_VAL.  For all those other
    cases, we still do want to see both the HBA record and the corresponding
    SCSI record by default.
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: a54ca0f62f95 ("[SCSI] zfcp: Redesign of the debug tracing for HBA records.")
    Cc: <stable@vger.kernel.org> #2.6.37+
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 2d06b5d2c05b..db186d44cfaf 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -2,7 +2,7 @@
  * zfcp device driver
  * debug feature declarations
  *
- * Copyright IBM Corp. 2008, 2015
+ * Copyright IBM Corp. 2008, 2016
  */
 
 #ifndef ZFCP_DBF_H
@@ -283,6 +283,30 @@ struct zfcp_dbf {
 	struct zfcp_dbf_scsi		scsi_buf;
 };
 
+/**
+ * zfcp_dbf_hba_fsf_resp_suppress - true if we should not trace by default
+ * @req: request that has been completed
+ *
+ * Returns true if FCP response with only benign residual under count.
+ */
+static inline
+bool zfcp_dbf_hba_fsf_resp_suppress(struct zfcp_fsf_req *req)
+{
+	struct fsf_qtcb *qtcb = req->qtcb;
+	u32 fsf_stat = qtcb->header.fsf_status;
+	struct fcp_resp *fcp_rsp;
+	u8 rsp_flags, fr_status;
+
+	if (qtcb->prefix.qtcb_type != FSF_IO_COMMAND)
+		return false; /* not an FCP response */
+	fcp_rsp = (struct fcp_resp *)&qtcb->bottom.io.fcp_rsp;
+	rsp_flags = fcp_rsp->fr_flags;
+	fr_status = fcp_rsp->fr_status;
+	return (fsf_stat == FSF_FCP_RSP_AVAILABLE) &&
+		(rsp_flags == FCP_RESID_UNDER) &&
+		(fr_status == SAM_STAT_GOOD);
+}
+
 static inline
 void zfcp_dbf_hba_fsf_resp(char *tag, int level, struct zfcp_fsf_req *req)
 {
@@ -304,7 +328,9 @@ void zfcp_dbf_hba_fsf_response(struct zfcp_fsf_req *req)
 		zfcp_dbf_hba_fsf_resp("fs_perr", 1, req);
 
 	} else if (qtcb->header.fsf_status != FSF_GOOD) {
-		zfcp_dbf_hba_fsf_resp("fs_ferr", 1, req);
+		zfcp_dbf_hba_fsf_resp("fs_ferr",
+				      zfcp_dbf_hba_fsf_resp_suppress(req)
+				      ? 5 : 1, req);
 
 	} else if ((req->fsf_command == FSF_QTCB_OPEN_PORT_WITH_DID) ||
 		   (req->fsf_command == FSF_QTCB_OPEN_LUN)) {

commit dac37e15b7d511e026a9313c8c46794c144103cd
Author: Benjamin Block <bblock@linux.vnet.ibm.com>
Date:   Fri Dec 9 17:16:31 2016 +0100

    scsi: zfcp: fix use-after-"free" in FC ingress path after TMF
    
    When SCSI EH invokes zFCP's callbacks for eh_device_reset_handler() and
    eh_target_reset_handler(), it expects us to relent the ownership over
    the given scsi_cmnd and all other scsi_cmnds within the same scope - LUN
    or target - when returning with SUCCESS from the callback ('release'
    them).  SCSI EH can then reuse those commands.
    
    We did not follow this rule to release commands upon SUCCESS; and if
    later a reply arrived for one of those supposed to be released commands,
    we would still make use of the scsi_cmnd in our ingress tasklet. This
    will at least result in undefined behavior or a kernel panic because of
    a wrong kernel pointer dereference.
    
    To fix this, we NULLify all pointers to scsi_cmnds (struct zfcp_fsf_req
    *)->data in the matching scope if a TMF was successful. This is done
    under the locks (struct zfcp_adapter *)->abort_lock and (struct
    zfcp_reqlist *)->lock to prevent the requests from being removed from
    the request-hashtable, and the ingress tasklet from making use of the
    scsi_cmnd-pointer in zfcp_fsf_fcp_cmnd_handler().
    
    For cases where a reply arrives during SCSI EH, but before we get a
    chance to NULLify the pointer - but before we return from the callback
    -, we assume that the code is protected from races via the CAS operation
    in blk_complete_request() that is called in scsi_done().
    
    The following stacktrace shows an example for a crash resulting from the
    previous behavior:
    
    Unable to handle kernel pointer dereference at virtual kernel address fffffee17a672000
    Oops: 0038 [#1] SMP
    CPU: 2 PID: 0 Comm: swapper/2 Not tainted
    task: 00000003f7ff5be0 ti: 00000003f3d38000 task.ti: 00000003f3d38000
    Krnl PSW : 0404d00180000000 00000000001156b0 (smp_vcpu_scheduled+0x18/0x40)
               R:0 T:1 IO:0 EX:0 Key:0 M:1 W:0 P:0 AS:3 CC:1 PM:0 EA:3
    Krnl GPRS: 000000200000007e 0000000000000000 fffffee17a671fd8 0000000300000015
               ffffffff80000000 00000000005dfde8 07000003f7f80e00 000000004fa4e800
               000000036ce8d8f8 000000036ce8d9c0 00000003ece8fe00 ffffffff969c9e93
               00000003fffffffd 000000036ce8da10 00000000003bf134 00000003f3b07918
    Krnl Code: 00000000001156a2: a7190000        lghi    %r1,0
               00000000001156a6: a7380015        lhi    %r3,21
              #00000000001156aa: e32050000008    ag    %r2,0(%r5)
              >00000000001156b0: 482022b0        lh    %r2,688(%r2)
               00000000001156b4: ae123000        sigp    %r1,%r2,0(%r3)
               00000000001156b8: b2220020        ipm    %r2
               00000000001156bc: 8820001c        srl    %r2,28
               00000000001156c0: c02700000001    xilf    %r2,1
    Call Trace:
    ([<0000000000000000>] 0x0)
     [<000003ff807bdb8e>] zfcp_fsf_fcp_cmnd_handler+0x3de/0x490 [zfcp]
     [<000003ff807be30a>] zfcp_fsf_req_complete+0x252/0x800 [zfcp]
     [<000003ff807c0a48>] zfcp_fsf_reqid_check+0xe8/0x190 [zfcp]
     [<000003ff807c194e>] zfcp_qdio_int_resp+0x66/0x188 [zfcp]
     [<000003ff80440c64>] qdio_kick_handler+0xdc/0x310 [qdio]
     [<000003ff804463d0>] __tiqdio_inbound_processing+0xf8/0xcd8 [qdio]
     [<0000000000141fd4>] tasklet_action+0x9c/0x170
     [<0000000000141550>] __do_softirq+0xe8/0x258
     [<000000000010ce0a>] do_softirq+0xba/0xc0
     [<000000000014187c>] irq_exit+0xc4/0xe8
     [<000000000046b526>] do_IRQ+0x146/0x1d8
     [<00000000005d6a3c>] io_return+0x0/0x8
     [<00000000005d6422>] vtime_stop_cpu+0x4a/0xa0
    ([<0000000000000000>] 0x0)
     [<0000000000103d8a>] arch_cpu_idle+0xa2/0xb0
     [<0000000000197f94>] cpu_startup_entry+0x13c/0x1f8
     [<0000000000114782>] smp_start_secondary+0xda/0xe8
     [<00000000005d6efe>] restart_int_handler+0x56/0x6c
     [<0000000000000000>] 0x0
    Last Breaking-Event-Address:
     [<00000000003bf12e>] arch_spin_lock_wait+0x56/0xb0
    
    Suggested-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Fixes: ea127f9754 ("[PATCH] s390 (7/7): zfcp host adapter.") (tglx/history.git)
    Cc: <stable@vger.kernel.org> #2.6.32+
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 36d07584271d..2d06b5d2c05b 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -388,4 +388,15 @@ void zfcp_dbf_scsi_devreset(char *tag, struct scsi_cmnd *scmnd, u8 flag)
 	_zfcp_dbf_scsi(tmp_tag, 1, scmnd, NULL);
 }
 
+/**
+ * zfcp_dbf_scsi_nullcmnd() - trace NULLify of SCSI command in dev/tgt-reset.
+ * @scmnd: SCSI command that was NULLified.
+ * @fsf_req: request that owned @scmnd.
+ */
+static inline void zfcp_dbf_scsi_nullcmnd(struct scsi_cmnd *scmnd,
+					  struct zfcp_fsf_req *fsf_req)
+{
+	_zfcp_dbf_scsi("scfc__1", 3, scmnd, fsf_req);
+}
+
 #endif /* ZFCP_DBF_H */

commit aceeffbb59bb91404a0bda32a542d7ebf878433a
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Wed Aug 10 18:30:53 2016 +0200

    zfcp: trace full payload of all SAN records (req,resp,iels)
    
    This was lost with commit 2c55b750a884b86dea8b4cc5f15e1484cc47a25c
    ("[SCSI] zfcp: Redesign of the debug tracing for SAN records.")
    but is necessary for problem determination, e.g. to see the
    currently active zone set during automatic port scan.
    
    For the large GPN_FT response (4 pages), save space by not dumping
    any empty residual entries.
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: 2c55b750a884 ("[SCSI] zfcp: Redesign of the debug tracing for SAN records.")
    Cc: <stable@vger.kernel.org> #2.6.38+
    Reviewed-by: Alexey Ishchuk <aishchuk@linux.vnet.ibm.com>
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 6ee46f1f9e43..36d07584271d 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -115,6 +115,7 @@ struct zfcp_dbf_san {
 	u32 d_id;
 #define ZFCP_DBF_SAN_MAX_PAYLOAD (FC_CT_HDR_LEN + 32)
 	char payload[ZFCP_DBF_SAN_MAX_PAYLOAD];
+	u16 pl_len;
 } __packed;
 
 /**

commit 7c964ffe586bc0c3d9febe9bf97a2e4b2866e5b7
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Wed Aug 10 18:30:50 2016 +0200

    zfcp: restore tracing of handle for port and LUN with HBA records
    
    This information was lost with
    commit a54ca0f62f953898b05549391ac2a8a4dad6482b
    ("[SCSI] zfcp: Redesign of the debug tracing for HBA records.")
    but is required to debug e.g. invalid handle situations.
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: a54ca0f62f95 ("[SCSI] zfcp: Redesign of the debug tracing for HBA records.")
    Cc: <stable@vger.kernel.org> #2.6.38+
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index c879b54046ee..6ee46f1f9e43 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -131,6 +131,8 @@ struct zfcp_dbf_hba_res {
 	u8  prot_status_qual[FSF_PROT_STATUS_QUAL_SIZE];
 	u32 fsf_status;
 	u8  fsf_status_qual[FSF_STATUS_QUALIFIER_SIZE];
+	u32 port_handle;
+	u32 lun_handle;
 } __packed;
 
 /**

commit 35f040df97fa0e94c7851c054ec71533c88b4b81
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Wed Aug 10 18:30:47 2016 +0200

    zfcp: retain trace level for SCSI and HBA FSF response records
    
    While retaining the actual filtering according to trace level,
    the following commits started to write such filtered records
    with a hardcoded record level of 1 instead of the actual record level:
    commit 250a1352b95e1db3216e5c5d4f4365bea5122f4a
    ("[SCSI] zfcp: Redesign of the debug tracing for SCSI records.")
    commit a54ca0f62f953898b05549391ac2a8a4dad6482b
    ("[SCSI] zfcp: Redesign of the debug tracing for HBA records.")
    
    Now we can distinguish written records again for offline level filtering.
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: 250a1352b95e ("[SCSI] zfcp: Redesign of the debug tracing for SCSI records.")
    Fixes: a54ca0f62f95 ("[SCSI] zfcp: Redesign of the debug tracing for HBA records.")
    Cc: <stable@vger.kernel.org> #2.6.38+
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 7901deb4ba89..c879b54046ee 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -284,7 +284,7 @@ static inline
 void zfcp_dbf_hba_fsf_resp(char *tag, int level, struct zfcp_fsf_req *req)
 {
 	if (debug_level_enabled(req->adapter->dbf->hba, level))
-		zfcp_dbf_hba_fsf_res(tag, req);
+		zfcp_dbf_hba_fsf_res(tag, level, req);
 }
 
 /**
@@ -323,7 +323,7 @@ void _zfcp_dbf_scsi(char *tag, int level, struct scsi_cmnd *scmd,
 					scmd->device->host->hostdata[0];
 
 	if (debug_level_enabled(adapter->dbf->scsi, level))
-		zfcp_dbf_scsi(tag, scmd, req);
+		zfcp_dbf_scsi(tag, level, scmd, req);
 }
 
 /**

commit 4eeaa4f3f1d6c47b69f70e222297a4df4743363e
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Wed Aug 10 18:30:46 2016 +0200

    zfcp: close window with unblocked rport during rport gone
    
    On a successful end of reopen port forced,
    zfcp_erp_strategy_followup_success() re-uses the port erp_action
    and the subsequent zfcp_erp_action_cleanup() now
    sees ZFCP_ERP_SUCCEEDED with
    erp_action->action==ZFCP_ERP_ACTION_REOPEN_PORT
    instead of ZFCP_ERP_ACTION_REOPEN_PORT_FORCED
    but must not perform zfcp_scsi_schedule_rport_register().
    
    We can detect this because the fresh port reopen erp_action
    is in its very first step ZFCP_ERP_STEP_UNINITIALIZED.
    
    Otherwise this opens a time window with unblocked rport
    (until the followup port reopen recovery would block it again).
    If a scsi_cmnd timeout occurs during this time window
    fc_timed_out() cannot work as desired and such command
    would indeed time out and trigger scsi_eh. This prevents
    a clean and timely path failover.
    This should not happen if the path issue can be recovered
    on FC transport layer such as path issues involving RSCNs.
    
    Also, unnecessary and repeated DID_IMM_RETRY for pending and
    undesired new requests occur because internally zfcp still
    has its zfcp_port blocked.
    
    As follow-on errors with scsi_eh, it can cause,
    in the worst case, permanently lost paths due to one of:
    sd <scsidev>: [<scsidisk>] Medium access timeout failure. Offlining disk!
    sd <scsidev>: Device offlined - not ready after error recovery
    
    For fix validation and to aid future debugging with other recoveries
    we now also trace (un)blocking of rports.
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Fixes: 5767620c383a ("[SCSI] zfcp: Do not unblock rport from REOPEN_PORT_FORCED")
    Fixes: a2fa0aede07c ("[SCSI] zfcp: Block FC transport rports early on errors")
    Fixes: 5f852be9e11d ("[SCSI] zfcp: Fix deadlock between zfcp ERP and SCSI")
    Fixes: 338151e06608 ("[SCSI] zfcp: make use of fc_remote_port_delete when target port is unavailable")
    Fixes: 3859f6a248cb ("[PATCH] zfcp: add rports to enable scsi_add_device to work again")
    Cc: <stable@vger.kernel.org> #2.6.32+
    Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 0be3d48681ae..7901deb4ba89 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -2,7 +2,7 @@
  * zfcp device driver
  * debug feature declarations
  *
- * Copyright IBM Corp. 2008, 2010
+ * Copyright IBM Corp. 2008, 2015
  */
 
 #ifndef ZFCP_DBF_H
@@ -17,6 +17,11 @@
 
 #define ZFCP_DBF_INVALID_LUN	0xFFFFFFFFFFFFFFFFull
 
+enum zfcp_dbf_pseudo_erp_act_type {
+	ZFCP_PSEUDO_ERP_ACTION_RPORT_ADD = 0xff,
+	ZFCP_PSEUDO_ERP_ACTION_RPORT_DEL = 0xfe,
+};
+
 /**
  * struct zfcp_dbf_rec_trigger - trace record for triggered recovery action
  * @ready: number of ready recovery actions

commit 8e6a8285668b139460cc6852bfd58fdbd00c7157
Author: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
Date:   Wed Sep 18 17:21:34 2013 +0200

    s390/s390dbf: use debug_level_enabled() where applicable
    
    Refactor direct debug level comparisons with the (internal) s390db->level
    member.  Use the debug_level_enabled() function instead.
    
    Signed-off-by: Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 3ac7a4b30dd9..0be3d48681ae 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -278,7 +278,7 @@ struct zfcp_dbf {
 static inline
 void zfcp_dbf_hba_fsf_resp(char *tag, int level, struct zfcp_fsf_req *req)
 {
-	if (level <= req->adapter->dbf->hba->level)
+	if (debug_level_enabled(req->adapter->dbf->hba, level))
 		zfcp_dbf_hba_fsf_res(tag, req);
 }
 
@@ -317,7 +317,7 @@ void _zfcp_dbf_scsi(char *tag, int level, struct scsi_cmnd *scmd,
 	struct zfcp_adapter *adapter = (struct zfcp_adapter *)
 					scmd->device->host->hostdata[0];
 
-	if (level <= adapter->dbf->scsi->level)
+	if (debug_level_enabled(adapter->dbf->scsi, level))
 		zfcp_dbf_scsi(tag, scmd, req);
 }
 

commit cb45214960bc989af8b911ebd77da541c797717d
Author: Steffen Maier <maier@linux.vnet.ibm.com>
Date:   Tue Sep 4 15:23:32 2012 +0200

    [SCSI] zfcp: Do not wakeup while suspended
    
    If the mapping of FCP device bus ID and corresponding subchannel
    is modified while the Linux image is suspended, the resume of FCP
    devices can fail. During resume, zfcp gets callbacks from cio regarding
    the modified subchannels but they can be arbitrarily mixed with the
    restore/resume callback. Since the cio callbacks would trigger
    adapter recovery, zfcp could wakeup before the resume callback.
    Therefore, ignore the cio callbacks regarding subchannels while
    being suspended. We can safely do so, since zfcp does not deal itself
    with subchannels. For problem determination purposes, we still trace the
    ignored callback events.
    
    The following kernel messages could be seen on resume:
    
    kernel: <WWPN>: parent <FCP device bus ID> should not be sleeping
    
    As part of adapter reopen recovery, zfcp performs auto port scanning
    which can erroneously try to register new remote ports with
    scsi_transport_fc and the device core code complains about the parent
    (adapter) still sleeping.
    
    kernel: zfcp.3dff9c: <FCP device bus ID>:\
     Setting up the QDIO connection to the FCP adapter failed
    <last kernel message repeated 3 more times>
    kernel: zfcp.574d43: <FCP device bus ID>:\
     ERP cannot recover an error on the FCP device
    
    In such cases, the adapter gave up recovery and remained blocked along
    with its child objects: remote ports and LUNs/scsi devices. Even the
    adapter shutdown as part of giving up recovery failed because the ccw
    device state remained disconnected. Later, the corresponding remote
    ports ran into dev_loss_tmo. As a result, the LUNs were erroneously
    not available again after resume.
    
    Even a manually triggered adapter recovery (e.g. sysfs attribute
    failed, or device offline/online via sysfs) could not recover the
    adapter due to the remaining disconnected state of the corresponding
    ccw device.
    
    Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
    Cc: <stable@vger.kernel.org> #2.6.32+
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 714f087eb7a9..3ac7a4b30dd9 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -154,6 +154,7 @@ enum zfcp_dbf_hba_id {
 	ZFCP_DBF_HBA_RES	= 1,
 	ZFCP_DBF_HBA_USS	= 2,
 	ZFCP_DBF_HBA_BIT	= 3,
+	ZFCP_DBF_HBA_BASIC	= 4,
 };
 
 /**

commit ea4a3a6ac40e2a585654808d4aefb39a6d57dca0
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Thu Dec 2 15:16:16 2010 +0100

    [SCSI] zfcp: Redesign of the debug tracing final cleanup.
    
    This patch is the final cleanup of the redesign from the zfcp tracing.
    Structures and elements which were used by multiple areas of the
    former debug tracing are now changed to the new scheme.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 2cee8197dd02..714f087eb7a9 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -14,8 +14,6 @@
 #include "zfcp_def.h"
 
 #define ZFCP_DBF_TAG_LEN       7
-#define ZFCP_DBF_TAG_SIZE      4
-#define ZFCP_DBF_ID_SIZE       7
 
 #define ZFCP_DBF_INVALID_LUN	0xFFFFFFFFFFFFFFFFull
 
@@ -233,13 +231,31 @@ struct zfcp_dbf_scsi {
  * @data: unformatted data
  */
 struct zfcp_dbf_pay {
+	u8 counter;
 	char area[ZFCP_DBF_TAG_LEN];
-	char counter;
 	u64 fsf_req_id;
 #define ZFCP_DBF_PAY_MAX_REC 0x100
 	char data[ZFCP_DBF_PAY_MAX_REC];
 } __packed;
 
+/**
+ * struct zfcp_dbf - main dbf trace structure
+ * @pay: reference to payload trace area
+ * @rec: reference to recovery trace area
+ * @hba: reference to hba trace area
+ * @san: reference to san trace area
+ * @scsi: reference to scsi trace area
+ * @pay_lock: lock protecting payload trace buffer
+ * @rec_lock: lock protecting recovery trace buffer
+ * @hba_lock: lock protecting hba trace buffer
+ * @san_lock: lock protecting san trace buffer
+ * @scsi_lock: lock protecting scsi trace buffer
+ * @pay_buf: pre-allocated buffer for payload
+ * @rec_buf: pre-allocated buffer for recovery
+ * @hba_buf: pre-allocated buffer for hba
+ * @san_buf: pre-allocated buffer for san
+ * @scsi_buf: pre-allocated buffer for scsi
+ */
 struct zfcp_dbf {
 	debug_info_t			*pay;
 	debug_info_t			*rec;
@@ -251,12 +267,11 @@ struct zfcp_dbf {
 	spinlock_t			hba_lock;
 	spinlock_t			san_lock;
 	spinlock_t			scsi_lock;
+	struct zfcp_dbf_pay		pay_buf;
 	struct zfcp_dbf_rec		rec_buf;
 	struct zfcp_dbf_hba		hba_buf;
 	struct zfcp_dbf_san		san_buf;
 	struct zfcp_dbf_scsi		scsi_buf;
-	struct zfcp_dbf_pay		pay_buf;
-	struct zfcp_adapter		*adapter;
 };
 
 static inline

commit 250a1352b95e1db3216e5c5d4f4365bea5122f4a
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Thu Dec 2 15:16:15 2010 +0100

    [SCSI] zfcp: Redesign of the debug tracing for SCSI records.
    
    This patch is the continuation to redesign the zfcp tracing to a more
    straight-forward and easy to extend scheme.
    
    This patch deals with all trace records of the zfcp SCSI area.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 5dc0b414cf28..2cee8197dd02 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -19,14 +19,6 @@
 
 #define ZFCP_DBF_INVALID_LUN	0xFFFFFFFFFFFFFFFFull
 
-struct zfcp_dbf_dump {
-	u8 tag[ZFCP_DBF_TAG_SIZE];
-	u32 total_size;		/* size of total dump data */
-	u32 offset;		/* how much data has being already dumped */
-	u32 size;		/* how much data comes with this record */
-	u8 data[];		/* dump data */
-} __attribute__ ((packed));
-
 /**
  * struct zfcp_dbf_rec_trigger - trace record for triggered recovery action
  * @ready: number of ready recovery actions
@@ -192,6 +184,47 @@ struct zfcp_dbf_hba {
 	} u;
 } __packed;
 
+/**
+ * enum zfcp_dbf_scsi_id - scsi trace record identifier
+ * @ZFCP_DBF_SCSI_CMND: scsi command trace record
+ */
+enum zfcp_dbf_scsi_id {
+	ZFCP_DBF_SCSI_CMND	= 1,
+};
+
+/**
+ * struct zfcp_dbf_scsi - common trace record for SCSI records
+ * @id: unique number of recovery record type
+ * @tag: identifier string specifying the location of initiation
+ * @scsi_id: scsi device id
+ * @scsi_lun: scsi device logical unit number
+ * @scsi_result: scsi result
+ * @scsi_retries: current retry number of scsi request
+ * @scsi_allowed: allowed retries
+ * @fcp_rsp_info: FCP response info
+ * @scsi_opcode: scsi opcode
+ * @fsf_req_id: request id of fsf request
+ * @host_scribble: LLD specific data attached to SCSI request
+ * @pl_len: length of paload stored as zfcp_dbf_pay
+ * @fsf_rsp: response for fsf request
+ */
+struct zfcp_dbf_scsi {
+	u8 id;
+	char tag[ZFCP_DBF_TAG_LEN];
+	u32 scsi_id;
+	u32 scsi_lun;
+	u32 scsi_result;
+	u8 scsi_retries;
+	u8 scsi_allowed;
+	u8 fcp_rsp_info;
+#define ZFCP_DBF_SCSI_OPCODE	16
+	u8 scsi_opcode[ZFCP_DBF_SCSI_OPCODE];
+	u64 fsf_req_id;
+	u64 host_scribble;
+	u16 pl_len;
+	struct fcp_resp_with_ext fcp_rsp;
+} __packed;
+
 /**
  * struct zfcp_dbf_pay - trace record for unformatted payload information
  * @area: area this record is originated from
@@ -207,31 +240,6 @@ struct zfcp_dbf_pay {
 	char data[ZFCP_DBF_PAY_MAX_REC];
 } __packed;
 
-struct zfcp_dbf_scsi_record {
-	u8 tag[ZFCP_DBF_TAG_SIZE];
-	u8 tag2[ZFCP_DBF_TAG_SIZE];
-	u32 scsi_id;
-	u32 scsi_lun;
-	u32 scsi_result;
-	u64 scsi_cmnd;
-#define ZFCP_DBF_SCSI_OPCODE	16
-	u8 scsi_opcode[ZFCP_DBF_SCSI_OPCODE];
-	u8 scsi_retries;
-	u8 scsi_allowed;
-	u64 fsf_reqid;
-	u32 fsf_seqno;
-	u64 fsf_issued;
-	u64 old_fsf_reqid;
-	u8 rsp_validity;
-	u8 rsp_scsi_status;
-	u32 rsp_resid;
-	u8 rsp_code;
-#define ZFCP_DBF_SCSI_FCP_SNS_INFO	16
-#define ZFCP_DBF_SCSI_MAX_FCP_SNS_INFO	256
-	u32 sns_info_len;
-	u8 sns_info[ZFCP_DBF_SCSI_FCP_SNS_INFO];
-} __attribute__ ((packed));
-
 struct zfcp_dbf {
 	debug_info_t			*pay;
 	debug_info_t			*rec;
@@ -246,7 +254,7 @@ struct zfcp_dbf {
 	struct zfcp_dbf_rec		rec_buf;
 	struct zfcp_dbf_hba		hba_buf;
 	struct zfcp_dbf_san		san_buf;
-	struct zfcp_dbf_scsi_record	scsi_buf;
+	struct zfcp_dbf_scsi		scsi_buf;
 	struct zfcp_dbf_pay		pay_buf;
 	struct zfcp_adapter		*adapter;
 };
@@ -260,7 +268,7 @@ void zfcp_dbf_hba_fsf_resp(char *tag, int level, struct zfcp_fsf_req *req)
 
 /**
  * zfcp_dbf_hba_fsf_response - trace event for request completion
- * @fsf_req: request that has been completed
+ * @req: request that has been completed
  */
 static inline
 void zfcp_dbf_hba_fsf_response(struct zfcp_fsf_req *req)
@@ -287,57 +295,53 @@ void zfcp_dbf_hba_fsf_response(struct zfcp_fsf_req *req)
 }
 
 static inline
-void zfcp_dbf_scsi(const char *tag, const char *tag2, int level,
-		   struct zfcp_dbf *dbf, struct scsi_cmnd *scmd,
-		   struct zfcp_fsf_req *req, unsigned long old_id)
+void _zfcp_dbf_scsi(char *tag, int level, struct scsi_cmnd *scmd,
+		   struct zfcp_fsf_req *req)
 {
-	if (level <= dbf->scsi->level)
-		_zfcp_dbf_scsi(tag, tag2, level, dbf, scmd, req, old_id);
+	struct zfcp_adapter *adapter = (struct zfcp_adapter *)
+					scmd->device->host->hostdata[0];
+
+	if (level <= adapter->dbf->scsi->level)
+		zfcp_dbf_scsi(tag, scmd, req);
 }
 
 /**
  * zfcp_dbf_scsi_result - trace event for SCSI command completion
- * @dbf: adapter dbf trace
  * @scmd: SCSI command pointer
  * @req: FSF request used to issue SCSI command
  */
 static inline
-void zfcp_dbf_scsi_result(struct zfcp_dbf *dbf, struct scsi_cmnd *scmd,
-			  struct zfcp_fsf_req *req)
+void zfcp_dbf_scsi_result(struct scsi_cmnd *scmd, struct zfcp_fsf_req *req)
 {
 	if (scmd->result != 0)
-		zfcp_dbf_scsi("rslt", "erro", 3, dbf, scmd, req, 0);
+		_zfcp_dbf_scsi("rsl_err", 3, scmd, req);
 	else if (scmd->retries > 0)
-		zfcp_dbf_scsi("rslt", "retr", 4, dbf, scmd, req, 0);
+		_zfcp_dbf_scsi("rsl_ret", 4, scmd, req);
 	else
-		zfcp_dbf_scsi("rslt", "norm", 6, dbf, scmd, req, 0);
+		_zfcp_dbf_scsi("rsl_nor", 6, scmd, req);
 }
 
 /**
  * zfcp_dbf_scsi_fail_send - trace event for failure to send SCSI command
- * @dbf: adapter dbf trace
  * @scmd: SCSI command pointer
  */
 static inline
-void zfcp_dbf_scsi_fail_send(struct zfcp_dbf *dbf, struct scsi_cmnd *scmd)
+void zfcp_dbf_scsi_fail_send(struct scsi_cmnd *scmd)
 {
-	zfcp_dbf_scsi("rslt", "fail", 4, dbf, scmd, NULL, 0);
+	_zfcp_dbf_scsi("rsl_fai", 4, scmd, NULL);
 }
 
 /**
  * zfcp_dbf_scsi_abort - trace event for SCSI command abort
  * @tag: tag indicating success or failure of abort operation
- * @adapter: adapter thas has been used to issue SCSI command to be aborted
  * @scmd: SCSI command to be aborted
- * @new_req: request containing abort (might be NULL)
- * @old_id: identifier of request containg SCSI command to be aborted
+ * @fsf_req: request containing abort (might be NULL)
  */
 static inline
-void zfcp_dbf_scsi_abort(const char *tag, struct zfcp_dbf *dbf,
-			 struct scsi_cmnd *scmd, struct zfcp_fsf_req *new_req,
-			 unsigned long old_id)
+void zfcp_dbf_scsi_abort(char *tag, struct scsi_cmnd *scmd,
+			 struct zfcp_fsf_req *fsf_req)
 {
-	zfcp_dbf_scsi("abrt", tag, 1, dbf, scmd, new_req, old_id);
+	_zfcp_dbf_scsi(tag, 1, scmd, fsf_req);
 }
 
 /**
@@ -347,12 +351,17 @@ void zfcp_dbf_scsi_abort(const char *tag, struct zfcp_dbf *dbf,
  * @flag: indicates type of reset (Target Reset, Logical Unit Reset)
  */
 static inline
-void zfcp_dbf_scsi_devreset(const char *tag, struct scsi_cmnd *scmnd, u8 flag)
+void zfcp_dbf_scsi_devreset(char *tag, struct scsi_cmnd *scmnd, u8 flag)
 {
-	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scmnd->device);
+	char tmp_tag[ZFCP_DBF_TAG_LEN];
+
+	if (flag == FCP_TMF_TGT_RESET)
+		memcpy(tmp_tag, "tr_", 3);
+	else
+		memcpy(tmp_tag, "lr_", 3);
 
-	zfcp_dbf_scsi(flag == FCP_TMF_TGT_RESET ? "trst" : "lrst", tag, 1,
-		      zfcp_sdev->port->adapter->dbf, scmnd, NULL, 0);
+	memcpy(&tmp_tag[3], tag, 4);
+	_zfcp_dbf_scsi(tmp_tag, 1, scmnd, NULL);
 }
 
 #endif /* ZFCP_DBF_H */

commit a54ca0f62f953898b05549391ac2a8a4dad6482b
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Thu Dec 2 15:16:14 2010 +0100

    [SCSI] zfcp: Redesign of the debug tracing for HBA records.
    
    This patch is the continuation to redesign the zfcp tracing to a more
    straight-forward and easy to extend scheme.
    
    This patch deals with all trace records of the zfcp HBA area.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index a3af6bd3d5aa..5dc0b414cf28 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -1,22 +1,8 @@
 /*
- * This file is part of the zfcp device driver for
- * FCP adapters for IBM System z9 and zSeries.
+ * zfcp device driver
+ * debug feature declarations
  *
- * Copyright IBM Corp. 2008, 2009
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * Copyright IBM Corp. 2008, 2010
  */
 
 #ifndef ZFCP_DBF_H
@@ -136,73 +122,90 @@ struct zfcp_dbf_san {
 	char payload[ZFCP_DBF_SAN_MAX_PAYLOAD];
 } __packed;
 
-struct zfcp_dbf_hba_record_response {
-	u32 fsf_command;
-	u64 fsf_reqid;
-	u32 fsf_seqno;
-	u64 fsf_issued;
-	u32 fsf_prot_status;
+/**
+ * struct zfcp_dbf_hba_res - trace record for hba responses
+ * @req_issued: timestamp when request was issued
+ * @prot_status: protocol status
+ * @prot_status_qual: protocol status qualifier
+ * @fsf_status: fsf status
+ * @fsf_status_qual: fsf status qualifier
+ */
+struct zfcp_dbf_hba_res {
+	u64 req_issued;
+	u32 prot_status;
+	u8  prot_status_qual[FSF_PROT_STATUS_QUAL_SIZE];
 	u32 fsf_status;
-	u8 fsf_prot_status_qual[FSF_PROT_STATUS_QUAL_SIZE];
-	u8 fsf_status_qual[FSF_STATUS_QUALIFIER_SIZE];
-	u32 fsf_req_status;
-	u8 sbal_first;
-	u8 sbal_last;
-	u8 sbal_response;
-	u8 pool;
-	u64 erp_action;
-	union {
-		struct {
-			u64 cmnd;
-			u32 data_dir;
-		} fcp;
-		struct {
-			u64 wwpn;
-			u32 d_id;
-			u32 port_handle;
-		} port;
-		struct {
-			u64 wwpn;
-			u64 fcp_lun;
-			u32 port_handle;
-			u32 lun_handle;
-		} unit;
-		struct {
-			u32 d_id;
-		} els;
-	} u;
-} __attribute__ ((packed));
+	u8  fsf_status_qual[FSF_STATUS_QUALIFIER_SIZE];
+} __packed;
 
-struct zfcp_dbf_hba_record_status {
-	u8 failed;
+/**
+ * struct zfcp_dbf_hba_uss - trace record for unsolicited status
+ * @status_type: type of unsolicited status
+ * @status_subtype: subtype of unsolicited status
+ * @d_id: destination ID
+ * @lun: logical unit number
+ * @queue_designator: queue designator
+ */
+struct zfcp_dbf_hba_uss {
 	u32 status_type;
 	u32 status_subtype;
-	struct fsf_queue_designator
-	 queue_designator;
-	u32 payload_size;
-#define ZFCP_DBF_UNSOL_PAYLOAD				80
-#define ZFCP_DBF_UNSOL_PAYLOAD_SENSE_DATA_AVAIL		32
-#define ZFCP_DBF_UNSOL_PAYLOAD_BIT_ERROR_THRESHOLD	56
-#define ZFCP_DBF_UNSOL_PAYLOAD_FEATURE_UPDATE_ALERT	2 * sizeof(u32)
-	u8 payload[ZFCP_DBF_UNSOL_PAYLOAD];
-} __attribute__ ((packed));
+	u32 d_id;
+	u64 lun;
+	u64 queue_designator;
+} __packed;
 
-struct zfcp_dbf_hba_record_qdio {
-	u32 qdio_error;
-	u8 sbal_index;
-	u8 sbal_count;
-} __attribute__ ((packed));
+/**
+ * enum zfcp_dbf_hba_id - HBA trace record identifier
+ * @ZFCP_DBF_HBA_RES: response trace record
+ * @ZFCP_DBF_HBA_USS: unsolicited status trace record
+ * @ZFCP_DBF_HBA_BIT: bit error trace record
+ */
+enum zfcp_dbf_hba_id {
+	ZFCP_DBF_HBA_RES	= 1,
+	ZFCP_DBF_HBA_USS	= 2,
+	ZFCP_DBF_HBA_BIT	= 3,
+};
 
-struct zfcp_dbf_hba_record {
-	u8 tag[ZFCP_DBF_TAG_SIZE];
-	u8 tag2[ZFCP_DBF_TAG_SIZE];
+/**
+ * struct zfcp_dbf_hba - common trace record for HBA records
+ * @id: unique number of recovery record type
+ * @tag: identifier string specifying the location of initiation
+ * @fsf_req_id: request id for fsf requests
+ * @fsf_req_status: status of fsf request
+ * @fsf_cmd: fsf command
+ * @fsf_seq_no: fsf sequence number
+ * @pl_len: length of payload stored as zfcp_dbf_pay
+ * @u: record type specific data
+ */
+struct zfcp_dbf_hba {
+	u8 id;
+	char tag[ZFCP_DBF_TAG_LEN];
+	u64 fsf_req_id;
+	u32 fsf_req_status;
+	u32 fsf_cmd;
+	u32 fsf_seq_no;
+	u16 pl_len;
 	union {
-		struct zfcp_dbf_hba_record_response response;
-		struct zfcp_dbf_hba_record_status status;
-		struct zfcp_dbf_hba_record_qdio qdio;
-		struct fsf_bit_error_payload berr;
+		struct zfcp_dbf_hba_res res;
+		struct zfcp_dbf_hba_uss uss;
+		struct fsf_bit_error_payload be;
 	} u;
-} __attribute__ ((packed));
+} __packed;
+
+/**
+ * struct zfcp_dbf_pay - trace record for unformatted payload information
+ * @area: area this record is originated from
+ * @counter: ascending record number
+ * @fsf_req_id: request id of fsf request
+ * @data: unformatted data
+ */
+struct zfcp_dbf_pay {
+	char area[ZFCP_DBF_TAG_LEN];
+	char counter;
+	u64 fsf_req_id;
+#define ZFCP_DBF_PAY_MAX_REC 0x100
+	char data[ZFCP_DBF_PAY_MAX_REC];
+} __packed;
 
 struct zfcp_dbf_scsi_record {
 	u8 tag[ZFCP_DBF_TAG_SIZE];
@@ -230,71 +233,57 @@ struct zfcp_dbf_scsi_record {
 } __attribute__ ((packed));
 
 struct zfcp_dbf {
+	debug_info_t			*pay;
 	debug_info_t			*rec;
 	debug_info_t			*hba;
 	debug_info_t			*san;
 	debug_info_t			*scsi;
+	spinlock_t			pay_lock;
 	spinlock_t			rec_lock;
 	spinlock_t			hba_lock;
 	spinlock_t			san_lock;
 	spinlock_t			scsi_lock;
 	struct zfcp_dbf_rec		rec_buf;
-	struct zfcp_dbf_hba_record	hba_buf;
+	struct zfcp_dbf_hba		hba_buf;
 	struct zfcp_dbf_san		san_buf;
 	struct zfcp_dbf_scsi_record	scsi_buf;
+	struct zfcp_dbf_pay		pay_buf;
 	struct zfcp_adapter		*adapter;
 };
 
 static inline
-void zfcp_dbf_hba_fsf_resp(const char *tag2, int level,
-			   struct zfcp_fsf_req *req, struct zfcp_dbf *dbf)
+void zfcp_dbf_hba_fsf_resp(char *tag, int level, struct zfcp_fsf_req *req)
 {
-	if (level <= dbf->hba->level)
-		_zfcp_dbf_hba_fsf_response(tag2, level, req, dbf);
+	if (level <= req->adapter->dbf->hba->level)
+		zfcp_dbf_hba_fsf_res(tag, req);
 }
 
 /**
  * zfcp_dbf_hba_fsf_response - trace event for request completion
  * @fsf_req: request that has been completed
  */
-static inline void zfcp_dbf_hba_fsf_response(struct zfcp_fsf_req *req)
+static inline
+void zfcp_dbf_hba_fsf_response(struct zfcp_fsf_req *req)
 {
-	struct zfcp_dbf *dbf = req->adapter->dbf;
 	struct fsf_qtcb *qtcb = req->qtcb;
 
 	if ((qtcb->prefix.prot_status != FSF_PROT_GOOD) &&
 	    (qtcb->prefix.prot_status != FSF_PROT_FSF_STATUS_PRESENTED)) {
-		zfcp_dbf_hba_fsf_resp("perr", 1, req, dbf);
+		zfcp_dbf_hba_fsf_resp("fs_perr", 1, req);
 
 	} else if (qtcb->header.fsf_status != FSF_GOOD) {
-		zfcp_dbf_hba_fsf_resp("ferr", 1, req, dbf);
+		zfcp_dbf_hba_fsf_resp("fs_ferr", 1, req);
 
 	} else if ((req->fsf_command == FSF_QTCB_OPEN_PORT_WITH_DID) ||
 		   (req->fsf_command == FSF_QTCB_OPEN_LUN)) {
-		zfcp_dbf_hba_fsf_resp("open", 4, req, dbf);
+		zfcp_dbf_hba_fsf_resp("fs_open", 4, req);
 
 	} else if (qtcb->header.log_length) {
-		zfcp_dbf_hba_fsf_resp("qtcb", 5, req, dbf);
+		zfcp_dbf_hba_fsf_resp("fs_qtcb", 5, req);
 
 	} else {
-		zfcp_dbf_hba_fsf_resp("norm", 6, req, dbf);
+		zfcp_dbf_hba_fsf_resp("fs_norm", 6, req);
 	}
- }
-
-/**
- * zfcp_dbf_hba_fsf_unsol - trace event for an unsolicited status buffer
- * @tag: tag indicating which kind of unsolicited status has been received
- * @dbf: reference to dbf structure
- * @status_buffer: buffer containing payload of unsolicited status
- */
-static inline
-void zfcp_dbf_hba_fsf_unsol(const char *tag, struct zfcp_dbf *dbf,
-			    struct fsf_status_read_buffer *buf)
-{
-	int level = 2;
-
-	if (level <= dbf->hba->level)
-		_zfcp_dbf_hba_fsf_unsol(tag, level, dbf, buf);
 }
 
 static inline

commit 2c55b750a884b86dea8b4cc5f15e1484cc47a25c
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Thu Dec 2 15:16:13 2010 +0100

    [SCSI] zfcp: Redesign of the debug tracing for SAN records.
    
    This patch is the continuation to redesign the zfcp tracing to a more
    straight-forward and easy to extend scheme.
    
    This patch deals with all trace records of the zfcp SAN area.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 2e823d4ede6e..a3af6bd3d5aa 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -108,6 +108,34 @@ struct zfcp_dbf_rec {
 	} u;
 } __packed;
 
+/**
+ * enum zfcp_dbf_san_id - SAN trace record identifier
+ * @ZFCP_DBF_SAN_REQ: request trace record id
+ * @ZFCP_DBF_SAN_RES: response trace record id
+ * @ZFCP_DBF_SAN_ELS: extended link service record id
+ */
+enum zfcp_dbf_san_id {
+	ZFCP_DBF_SAN_REQ	= 1,
+	ZFCP_DBF_SAN_RES	= 2,
+	ZFCP_DBF_SAN_ELS	= 3,
+};
+
+/** struct zfcp_dbf_san - trace record for SAN requests and responses
+ * @id: unique number of recovery record type
+ * @tag: identifier string specifying the location of initiation
+ * @fsf_req_id: request id for fsf requests
+ * @payload: unformatted information related to request/response
+ * @d_id: destination id
+ */
+struct zfcp_dbf_san {
+	u8 id;
+	char tag[ZFCP_DBF_TAG_LEN];
+	u64 fsf_req_id;
+	u32 d_id;
+#define ZFCP_DBF_SAN_MAX_PAYLOAD (FC_CT_HDR_LEN + 32)
+	char payload[ZFCP_DBF_SAN_MAX_PAYLOAD];
+} __packed;
+
 struct zfcp_dbf_hba_record_response {
 	u32 fsf_command;
 	u64 fsf_reqid;
@@ -176,44 +204,6 @@ struct zfcp_dbf_hba_record {
 	} u;
 } __attribute__ ((packed));
 
-struct zfcp_dbf_san_record_ct_request {
-	u16 cmd_req_code;
-	u8 revision;
-	u8 gs_type;
-	u8 gs_subtype;
-	u8 options;
-	u16 max_res_size;
-	u32 len;
-	u32 d_id;
-} __attribute__ ((packed));
-
-struct zfcp_dbf_san_record_ct_response {
-	u16 cmd_rsp_code;
-	u8 revision;
-	u8 reason_code;
-	u8 expl;
-	u8 vendor_unique;
-	u16 max_res_size;
-	u32 len;
-} __attribute__ ((packed));
-
-struct zfcp_dbf_san_record_els {
-	u32 d_id;
-} __attribute__ ((packed));
-
-struct zfcp_dbf_san_record {
-	u8 tag[ZFCP_DBF_TAG_SIZE];
-	u64 fsf_reqid;
-	u32 fsf_seqno;
-	union {
-		struct zfcp_dbf_san_record_ct_request ct_req;
-		struct zfcp_dbf_san_record_ct_response ct_resp;
-		struct zfcp_dbf_san_record_els els;
-	} u;
-} __attribute__ ((packed));
-
-#define ZFCP_DBF_SAN_MAX_PAYLOAD 1024
-
 struct zfcp_dbf_scsi_record {
 	u8 tag[ZFCP_DBF_TAG_SIZE];
 	u8 tag2[ZFCP_DBF_TAG_SIZE];
@@ -250,7 +240,7 @@ struct zfcp_dbf {
 	spinlock_t			scsi_lock;
 	struct zfcp_dbf_rec		rec_buf;
 	struct zfcp_dbf_hba_record	hba_buf;
-	struct zfcp_dbf_san_record	san_buf;
+	struct zfcp_dbf_san		san_buf;
 	struct zfcp_dbf_scsi_record	scsi_buf;
 	struct zfcp_adapter		*adapter;
 };

commit ae0904f60fab7cb20c48d32eefdd735e478b91fb
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Thu Dec 2 15:16:12 2010 +0100

    [SCSI] zfcp: Redesign of the debug tracing for recovery actions.
    
    The tracing environment of the zfcp LLD has become very bulky and hard
    to maintain. Small changes involve a large modification process which
    is error-prone and not effective.  This patch is the first of a set to
    redesign the zfcp tracing to a more straight-forward and easy to
    extend scheme.  It removes all interpretation and visualization parts
    and focuses on bare logging of the information.
    
    This patch deals with all trace records of the zfcp error recovery.
    
    Signed-off-by: Swen schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 04081b1b62b4..2e823d4ede6e 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -27,6 +27,7 @@
 #include "zfcp_fsf.h"
 #include "zfcp_def.h"
 
+#define ZFCP_DBF_TAG_LEN       7
 #define ZFCP_DBF_TAG_SIZE      4
 #define ZFCP_DBF_ID_SIZE       7
 
@@ -40,57 +41,72 @@ struct zfcp_dbf_dump {
 	u8 data[];		/* dump data */
 } __attribute__ ((packed));
 
-struct zfcp_dbf_rec_record_thread {
-	u32 total;
+/**
+ * struct zfcp_dbf_rec_trigger - trace record for triggered recovery action
+ * @ready: number of ready recovery actions
+ * @running: number of running recovery actions
+ * @want: wanted recovery action
+ * @need: needed recovery action
+ */
+struct zfcp_dbf_rec_trigger {
 	u32 ready;
 	u32 running;
-};
-
-struct zfcp_dbf_rec_record_target {
-	u64 ref;
-	u32 status;
-	u32 d_id;
-	u64 wwpn;
-	u64 fcp_lun;
-	u32 erp_count;
-};
-
-struct zfcp_dbf_rec_record_trigger {
 	u8 want;
 	u8 need;
-	u32 as;
-	u32 ps;
-	u32 ls;
-	u64 ref;
-	u64 action;
-	u64 wwpn;
-	u64 fcp_lun;
-};
+} __packed;
+
+/**
+ * struct zfcp_dbf_rec_running - trace record for running recovery
+ * @fsf_req_id: request id for fsf requests
+ * @rec_status: status of the fsf request
+ * @rec_step: current step of the recovery action
+ * rec_count: recovery counter
+ */
+struct zfcp_dbf_rec_running {
+	u64 fsf_req_id;
+	u32 rec_status;
+	u16 rec_step;
+	u8 rec_action;
+	u8 rec_count;
+} __packed;
 
-struct zfcp_dbf_rec_record_action {
-	u32 status;
-	u32 step;
-	u64 action;
-	u64 fsf_req;
+/**
+ * enum zfcp_dbf_rec_id - recovery trace record id
+ * @ZFCP_DBF_REC_TRIG: triggered recovery identifier
+ * @ZFCP_DBF_REC_RUN: running recovery identifier
+ */
+enum zfcp_dbf_rec_id {
+	ZFCP_DBF_REC_TRIG	= 1,
+	ZFCP_DBF_REC_RUN	= 2,
 };
 
-struct zfcp_dbf_rec_record {
+/**
+ * struct zfcp_dbf_rec - trace record for error recovery actions
+ * @id: unique number of recovery record type
+ * @tag: identifier string specifying the location of initiation
+ * @lun: logical unit number
+ * @wwpn: word wide port number
+ * @d_id: destination ID
+ * @adapter_status: current status of the adapter
+ * @port_status: current status of the port
+ * @lun_status: current status of the lun
+ * @u.trig: structure zfcp_dbf_rec_trigger
+ * @u.run: structure zfcp_dbf_rec_running
+ */
+struct zfcp_dbf_rec {
 	u8 id;
-	char id2[7];
+	char tag[ZFCP_DBF_TAG_LEN];
+	u64 lun;
+	u64 wwpn;
+	u32 d_id;
+	u32 adapter_status;
+	u32 port_status;
+	u32 lun_status;
 	union {
-		struct zfcp_dbf_rec_record_action action;
-		struct zfcp_dbf_rec_record_thread thread;
-		struct zfcp_dbf_rec_record_target target;
-		struct zfcp_dbf_rec_record_trigger trigger;
+		struct zfcp_dbf_rec_trigger trig;
+		struct zfcp_dbf_rec_running run;
 	} u;
-};
-
-enum {
-	ZFCP_REC_DBF_ID_ACTION,
-	ZFCP_REC_DBF_ID_THREAD,
-	ZFCP_REC_DBF_ID_TARGET,
-	ZFCP_REC_DBF_ID_TRIGGER,
-};
+} __packed;
 
 struct zfcp_dbf_hba_record_response {
 	u32 fsf_command;
@@ -232,7 +248,7 @@ struct zfcp_dbf {
 	spinlock_t			hba_lock;
 	spinlock_t			san_lock;
 	spinlock_t			scsi_lock;
-	struct zfcp_dbf_rec_record	rec_buf;
+	struct zfcp_dbf_rec		rec_buf;
 	struct zfcp_dbf_hba_record	hba_buf;
 	struct zfcp_dbf_san_record	san_buf;
 	struct zfcp_dbf_scsi_record	scsi_buf;

commit bf5eefb007e7c5498a41af2dd65d957ae9793a63
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue Sep 28 10:11:06 2010 +0200

    [SCSI] zfcp: Remove scsi_cmnd->serial_number from debug traces
    
    With the change that drivers have to explicitly request the serial
    number for SCSI commands, this field should not be part of the zfcp
    traces. It is not worth the effort to request the serial number only
    for tracing purposes, so simply remove this field from the debug
    traces.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 6a48c197b45d..04081b1b62b4 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -110,7 +110,6 @@ struct zfcp_dbf_hba_record_response {
 	union {
 		struct {
 			u64 cmnd;
-			u64 serial;
 			u32 data_dir;
 		} fcp;
 		struct {
@@ -206,7 +205,6 @@ struct zfcp_dbf_scsi_record {
 	u32 scsi_lun;
 	u32 scsi_result;
 	u64 scsi_cmnd;
-	u64 scsi_serial;
 #define ZFCP_DBF_SCSI_OPCODE	16
 	u8 scsi_opcode[ZFCP_DBF_SCSI_OPCODE];
 	u8 scsi_retries;

commit b62a8d9b45b971a67a0f8413338c230e3117dff5
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Wed Sep 8 14:39:55 2010 +0200

    [SCSI] zfcp: Use SCSI device data zfcp_scsi_dev instead of zfcp_unit
    
    This is the large change to switch from using the data in
    zfcp_unit to zfcp_scsi_dev. Keeping everything working requires doing
    the switch in one piece. To ensure that no code keeps using the data
    in zfcp_unit, this patch also removes the data from zfcp_unit that is
    now being replaced with zfcp_scsi_dev.
    
    For zfcp, the scsi_device together with zfcp_scsi_dev exist from the
    call of slave_alloc to the call of slave_destroy. The data in
    zfcp_scsi_dev is initialized in zfcp_scsi_slave_alloc and the LUN is
    opened; the final shutdown for the LUN is run from slave_destroy.
    
    Where the scsi_device or zfcp_scsi_dev is needed, the pointer to the
    scsi_device is passed as function argument and inside the function
    converted to the pointer to zfcp_scsi_dev; this avoids back and forth
    conversion betweeen scsi_device and zfcp_scsi_dev.
    
    While changing the function arguments from zfcp_unit to scsi_device,
    the functions names are renamed form "unit" to "lun". This is to have
    a seperation between zfcp_scsi_dev/LUN and the zfcp_unit; only code
    referring to the remaining configuration information in zfcp_unit
    struct uses "unit".
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 2bcc3403126a..6a48c197b45d 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -60,7 +60,7 @@ struct zfcp_dbf_rec_record_trigger {
 	u8 need;
 	u32 as;
 	u32 ps;
-	u32 us;
+	u32 ls;
 	u64 ref;
 	u64 action;
 	u64 wwpn;
@@ -350,16 +350,16 @@ void zfcp_dbf_scsi_abort(const char *tag, struct zfcp_dbf *dbf,
 /**
  * zfcp_dbf_scsi_devreset - trace event for Logical Unit or Target Reset
  * @tag: tag indicating success or failure of reset operation
+ * @scmnd: SCSI command which caused this error recovery
  * @flag: indicates type of reset (Target Reset, Logical Unit Reset)
- * @unit: unit that needs reset
- * @scsi_cmnd: SCSI command which caused this error recovery
  */
 static inline
-void zfcp_dbf_scsi_devreset(const char *tag, u8 flag, struct zfcp_unit *unit,
-			    struct scsi_cmnd *scsi_cmnd)
+void zfcp_dbf_scsi_devreset(const char *tag, struct scsi_cmnd *scmnd, u8 flag)
 {
+	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scmnd->device);
+
 	zfcp_dbf_scsi(flag == FCP_TMF_TGT_RESET ? "trst" : "lrst", tag, 1,
-			    unit->port->adapter->dbf, scsi_cmnd, NULL, 0);
+		      zfcp_sdev->port->adapter->dbf, scmnd, NULL, 0);
 }
 
 #endif /* ZFCP_DBF_H */

commit ef3eb71d8ba4fd9d48c5f9310bc9d90ca00323b4
Author: Felix Beck <felix.beck@de.ibm.com>
Date:   Fri Jul 16 15:37:42 2010 +0200

    [SCSI] zfcp: Introduce experimental support for DIF/DIX
    
    Introduce support for DIF/DIX in zfcp: Report the capabilities for the
    Scsi_host, map the protection data when issuing I/O requests and
    handle the new error codes. Also add the fsf data_direction field to
    the hba trace, it is useful information for debugging in that area.
    This is an EXPERIMENTAL feature for now.
    
    Signed-off-by: Felix Beck <felix.beck@de.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 457e046f2d28..2bcc3403126a 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -111,6 +111,7 @@ struct zfcp_dbf_hba_record_response {
 		struct {
 			u64 cmnd;
 			u64 serial;
+			u32 data_dir;
 		} fcp;
 		struct {
 			u64 wwpn;

commit ab72528a4498251a702fa7693b51b9311b2432f8
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Wed Feb 17 11:18:57 2010 +0100

    [SCSI] zfcp: Move scsi result tracing decision to zfcp_dbf.h
    
    Move the decision which trace tag and trace level to use for the scsi
    result trace to zfcp_dbf.h. zfcp_dbf_scsi_result is already an inline
    function, so move the trace code there, simplifying the response
    handling in zfcp_fsf.c.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index ca841ee44c15..457e046f2d28 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -303,17 +303,31 @@ void zfcp_dbf_scsi(const char *tag, const char *tag2, int level,
 
 /**
  * zfcp_dbf_scsi_result - trace event for SCSI command completion
- * @tag: tag indicating success or failure of SCSI command
- * @level: trace level applicable for this event
- * @adapter: adapter that has been used to issue the SCSI command
+ * @dbf: adapter dbf trace
  * @scmd: SCSI command pointer
- * @fsf_req: request used to issue SCSI command (might be NULL)
+ * @req: FSF request used to issue SCSI command
  */
 static inline
-void zfcp_dbf_scsi_result(const char *tag, int level, struct zfcp_dbf *dbf,
-			  struct scsi_cmnd *scmd, struct zfcp_fsf_req *fsf_req)
+void zfcp_dbf_scsi_result(struct zfcp_dbf *dbf, struct scsi_cmnd *scmd,
+			  struct zfcp_fsf_req *req)
 {
-	zfcp_dbf_scsi("rslt", tag, level, dbf, scmd, fsf_req, 0);
+	if (scmd->result != 0)
+		zfcp_dbf_scsi("rslt", "erro", 3, dbf, scmd, req, 0);
+	else if (scmd->retries > 0)
+		zfcp_dbf_scsi("rslt", "retr", 4, dbf, scmd, req, 0);
+	else
+		zfcp_dbf_scsi("rslt", "norm", 6, dbf, scmd, req, 0);
+}
+
+/**
+ * zfcp_dbf_scsi_fail_send - trace event for failure to send SCSI command
+ * @dbf: adapter dbf trace
+ * @scmd: SCSI command pointer
+ */
+static inline
+void zfcp_dbf_scsi_fail_send(struct zfcp_dbf *dbf, struct scsi_cmnd *scmd)
+{
+	zfcp_dbf_scsi("rslt", "fail", 4, dbf, scmd, NULL, 0);
 }
 
 /**

commit d21e9daa63e009ce5b87bbcaa6d11ce48e07bbbe
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Wed Feb 17 11:18:54 2010 +0100

    [SCSI] zfcp: Dont use 0 to indicate invalid LUN in rec trace
    
    0 is a valid value for a LUN. It is slightly confusing to also see 0
    in the trace entries relating to adapter and port. Change this to use
    0xFFFFFFFFFFFFFFFF in the LUN field when the trace entry does not
    relate to a LUN or unit.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index e4b5317fe902..ca841ee44c15 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -30,6 +30,8 @@
 #define ZFCP_DBF_TAG_SIZE      4
 #define ZFCP_DBF_ID_SIZE       7
 
+#define ZFCP_DBF_INVALID_LUN	0xFFFFFFFFFFFFFFFFull
+
 struct zfcp_dbf_dump {
 	u8 tag[ZFCP_DBF_TAG_SIZE];
 	u32 total_size;		/* size of total dump data */

commit 67feeebaa7038129ad58ae0dcece8142186b36a9
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Wed Feb 17 11:18:52 2010 +0100

    [SCSI] zfcp: Remove unused payload field from zfcp_dbf_san_record
    
    Remove the unused payload field from the struct zfcp_dbf_san_record,
    saving some space in the SAN trace.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 8b7fd9a1033e..e4b5317fe902 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -192,10 +192,10 @@ struct zfcp_dbf_san_record {
 		struct zfcp_dbf_san_record_ct_response ct_resp;
 		struct zfcp_dbf_san_record_els els;
 	} u;
-#define ZFCP_DBF_SAN_MAX_PAYLOAD 1024
-	u8 payload[32];
 } __attribute__ ((packed));
 
+#define ZFCP_DBF_SAN_MAX_PAYLOAD 1024
+
 struct zfcp_dbf_scsi_record {
 	u8 tag[ZFCP_DBF_TAG_SIZE];
 	u8 tag2[ZFCP_DBF_TAG_SIZE];

commit 7c7dc196814b9e1d5cc254dc579a5fa78ae524f7
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue Nov 24 16:54:13 2009 +0100

    [SCSI] zfcp: Simplify handling of ct and els requests
    
    Remove some redundancies in FC related code and trace:
    - drop redundant data from SAN trace (local s_id that only changes
      during link down, ls_code that is already part of payload, d_id in
      ct response trace that is always the same as in ct request trace)
    - use one common fsf struct to hold zfcp data for ct and els requests
    - leverage common fsf struct for FC passthrough job data, allocate it
      with dd_bsg_data for passthrough requests and unify common code for
      ct and els passthrough request
    - simplify callback handling in zfcp_fc
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index c3e25702df5b..8b7fd9a1033e 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -123,7 +123,6 @@ struct zfcp_dbf_hba_record_response {
 		} unit;
 		struct {
 			u32 d_id;
-			u8 ls_code;
 		} els;
 	} u;
 } __attribute__ ((packed));
@@ -167,6 +166,7 @@ struct zfcp_dbf_san_record_ct_request {
 	u8 options;
 	u16 max_res_size;
 	u32 len;
+	u32 d_id;
 } __attribute__ ((packed));
 
 struct zfcp_dbf_san_record_ct_response {
@@ -180,16 +180,13 @@ struct zfcp_dbf_san_record_ct_response {
 } __attribute__ ((packed));
 
 struct zfcp_dbf_san_record_els {
-	u8 ls_code;
-	u32 len;
+	u32 d_id;
 } __attribute__ ((packed));
 
 struct zfcp_dbf_san_record {
 	u8 tag[ZFCP_DBF_TAG_SIZE];
 	u64 fsf_reqid;
 	u32 fsf_seqno;
-	u32 s_id;
-	u32 d_id;
 	union {
 		struct zfcp_dbf_san_record_ct_request ct_req;
 		struct zfcp_dbf_san_record_ct_response ct_resp;

commit 4318e08c84e4916ac463002ffb7f9901ddb3c385
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue Nov 24 16:54:08 2009 +0100

    [SCSI] zfcp: Update FCP protocol related code
    
    Use common data structures for FCP CMND, FCP RSP and related
    definitions and remove zfcp private definitions. Split the FCP CMND
    setup and FCP RSP evaluation code in seperate functions. Use inline
    functions to not negatively impact the I/O path.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 6b1461e8f847..c3e25702df5b 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -22,6 +22,7 @@
 #ifndef ZFCP_DBF_H
 #define ZFCP_DBF_H
 
+#include <scsi/fc/fc_fcp.h>
 #include "zfcp_ext.h"
 #include "zfcp_fsf.h"
 #include "zfcp_def.h"
@@ -343,7 +344,7 @@ static inline
 void zfcp_dbf_scsi_devreset(const char *tag, u8 flag, struct zfcp_unit *unit,
 			    struct scsi_cmnd *scsi_cmnd)
 {
-	zfcp_dbf_scsi(flag == FCP_TARGET_RESET ? "trst" : "lrst", tag, 1,
+	zfcp_dbf_scsi(flag == FCP_TMF_TGT_RESET ? "trst" : "lrst", tag, 1,
 			    unit->port->adapter->dbf, scsi_cmnd, NULL, 0);
 }
 

commit 5771710bd5edfafcb8656f49b93690a6fae5a4d2
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Tue Aug 18 15:43:21 2009 +0200

    [SCSI] zfcp: Update dbf calls
    
    Change the dbf data and functions to use the zfcp_dbf prefix
    throughout the code. Also change the calls to dbf to use zfcp_dbf
    instead of zfcp_adapter.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index bceaff449033..6b1461e8f847 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -37,13 +37,13 @@ struct zfcp_dbf_dump {
 	u8 data[];		/* dump data */
 } __attribute__ ((packed));
 
-struct zfcp_rec_dbf_record_thread {
+struct zfcp_dbf_rec_record_thread {
 	u32 total;
 	u32 ready;
 	u32 running;
 };
 
-struct zfcp_rec_dbf_record_target {
+struct zfcp_dbf_rec_record_target {
 	u64 ref;
 	u32 status;
 	u32 d_id;
@@ -52,7 +52,7 @@ struct zfcp_rec_dbf_record_target {
 	u32 erp_count;
 };
 
-struct zfcp_rec_dbf_record_trigger {
+struct zfcp_dbf_rec_record_trigger {
 	u8 want;
 	u8 need;
 	u32 as;
@@ -64,21 +64,21 @@ struct zfcp_rec_dbf_record_trigger {
 	u64 fcp_lun;
 };
 
-struct zfcp_rec_dbf_record_action {
+struct zfcp_dbf_rec_record_action {
 	u32 status;
 	u32 step;
 	u64 action;
 	u64 fsf_req;
 };
 
-struct zfcp_rec_dbf_record {
+struct zfcp_dbf_rec_record {
 	u8 id;
 	char id2[7];
 	union {
-		struct zfcp_rec_dbf_record_action action;
-		struct zfcp_rec_dbf_record_thread thread;
-		struct zfcp_rec_dbf_record_target target;
-		struct zfcp_rec_dbf_record_trigger trigger;
+		struct zfcp_dbf_rec_record_action action;
+		struct zfcp_dbf_rec_record_thread thread;
+		struct zfcp_dbf_rec_record_target target;
+		struct zfcp_dbf_rec_record_trigger trigger;
 	} u;
 };
 
@@ -89,7 +89,7 @@ enum {
 	ZFCP_REC_DBF_ID_TRIGGER,
 };
 
-struct zfcp_hba_dbf_record_response {
+struct zfcp_dbf_hba_record_response {
 	u32 fsf_command;
 	u64 fsf_reqid;
 	u32 fsf_seqno;
@@ -127,7 +127,7 @@ struct zfcp_hba_dbf_record_response {
 	} u;
 } __attribute__ ((packed));
 
-struct zfcp_hba_dbf_record_status {
+struct zfcp_dbf_hba_record_status {
 	u8 failed;
 	u32 status_type;
 	u32 status_subtype;
@@ -141,24 +141,24 @@ struct zfcp_hba_dbf_record_status {
 	u8 payload[ZFCP_DBF_UNSOL_PAYLOAD];
 } __attribute__ ((packed));
 
-struct zfcp_hba_dbf_record_qdio {
+struct zfcp_dbf_hba_record_qdio {
 	u32 qdio_error;
 	u8 sbal_index;
 	u8 sbal_count;
 } __attribute__ ((packed));
 
-struct zfcp_hba_dbf_record {
+struct zfcp_dbf_hba_record {
 	u8 tag[ZFCP_DBF_TAG_SIZE];
 	u8 tag2[ZFCP_DBF_TAG_SIZE];
 	union {
-		struct zfcp_hba_dbf_record_response response;
-		struct zfcp_hba_dbf_record_status status;
-		struct zfcp_hba_dbf_record_qdio qdio;
+		struct zfcp_dbf_hba_record_response response;
+		struct zfcp_dbf_hba_record_status status;
+		struct zfcp_dbf_hba_record_qdio qdio;
 		struct fsf_bit_error_payload berr;
 	} u;
 } __attribute__ ((packed));
 
-struct zfcp_san_dbf_record_ct_request {
+struct zfcp_dbf_san_record_ct_request {
 	u16 cmd_req_code;
 	u8 revision;
 	u8 gs_type;
@@ -168,7 +168,7 @@ struct zfcp_san_dbf_record_ct_request {
 	u32 len;
 } __attribute__ ((packed));
 
-struct zfcp_san_dbf_record_ct_response {
+struct zfcp_dbf_san_record_ct_response {
 	u16 cmd_rsp_code;
 	u8 revision;
 	u8 reason_code;
@@ -178,27 +178,27 @@ struct zfcp_san_dbf_record_ct_response {
 	u32 len;
 } __attribute__ ((packed));
 
-struct zfcp_san_dbf_record_els {
+struct zfcp_dbf_san_record_els {
 	u8 ls_code;
 	u32 len;
 } __attribute__ ((packed));
 
-struct zfcp_san_dbf_record {
+struct zfcp_dbf_san_record {
 	u8 tag[ZFCP_DBF_TAG_SIZE];
 	u64 fsf_reqid;
 	u32 fsf_seqno;
 	u32 s_id;
 	u32 d_id;
 	union {
-		struct zfcp_san_dbf_record_ct_request ct_req;
-		struct zfcp_san_dbf_record_ct_response ct_resp;
-		struct zfcp_san_dbf_record_els els;
+		struct zfcp_dbf_san_record_ct_request ct_req;
+		struct zfcp_dbf_san_record_ct_response ct_resp;
+		struct zfcp_dbf_san_record_els els;
 	} u;
 #define ZFCP_DBF_SAN_MAX_PAYLOAD 1024
 	u8 payload[32];
 } __attribute__ ((packed));
 
-struct zfcp_scsi_dbf_record {
+struct zfcp_dbf_scsi_record {
 	u8 tag[ZFCP_DBF_TAG_SIZE];
 	u8 tag2[ZFCP_DBF_TAG_SIZE];
 	u32 scsi_id;
@@ -225,86 +225,84 @@ struct zfcp_scsi_dbf_record {
 } __attribute__ ((packed));
 
 struct zfcp_dbf {
-	debug_info_t			*rec_dbf;
-	debug_info_t			*hba_dbf;
-	debug_info_t			*san_dbf;
-	debug_info_t			*scsi_dbf;
-	spinlock_t			rec_dbf_lock;
-	spinlock_t			hba_dbf_lock;
-	spinlock_t			san_dbf_lock;
-	spinlock_t			scsi_dbf_lock;
-	struct zfcp_rec_dbf_record	rec_dbf_buf;
-	struct zfcp_hba_dbf_record	hba_dbf_buf;
-	struct zfcp_san_dbf_record	san_dbf_buf;
-	struct zfcp_scsi_dbf_record	scsi_dbf_buf;
+	debug_info_t			*rec;
+	debug_info_t			*hba;
+	debug_info_t			*san;
+	debug_info_t			*scsi;
+	spinlock_t			rec_lock;
+	spinlock_t			hba_lock;
+	spinlock_t			san_lock;
+	spinlock_t			scsi_lock;
+	struct zfcp_dbf_rec_record	rec_buf;
+	struct zfcp_dbf_hba_record	hba_buf;
+	struct zfcp_dbf_san_record	san_buf;
+	struct zfcp_dbf_scsi_record	scsi_buf;
+	struct zfcp_adapter		*adapter;
 };
 
 static inline
-void zfcp_hba_dbf_event_fsf_resp(const char *tag2, int level,
-				 struct zfcp_fsf_req *req, struct zfcp_dbf *dbf)
+void zfcp_dbf_hba_fsf_resp(const char *tag2, int level,
+			   struct zfcp_fsf_req *req, struct zfcp_dbf *dbf)
 {
-	if (level <= dbf->hba_dbf->level)
-		_zfcp_hba_dbf_event_fsf_response(tag2, level, req, dbf);
+	if (level <= dbf->hba->level)
+		_zfcp_dbf_hba_fsf_response(tag2, level, req, dbf);
 }
 
 /**
- * zfcp_hba_dbf_event_fsf_response - trace event for request completion
+ * zfcp_dbf_hba_fsf_response - trace event for request completion
  * @fsf_req: request that has been completed
  */
-static inline void zfcp_hba_dbf_event_fsf_response(struct zfcp_fsf_req *req)
+static inline void zfcp_dbf_hba_fsf_response(struct zfcp_fsf_req *req)
 {
 	struct zfcp_dbf *dbf = req->adapter->dbf;
 	struct fsf_qtcb *qtcb = req->qtcb;
 
 	if ((qtcb->prefix.prot_status != FSF_PROT_GOOD) &&
 	    (qtcb->prefix.prot_status != FSF_PROT_FSF_STATUS_PRESENTED)) {
-		zfcp_hba_dbf_event_fsf_resp("perr", 1, req, dbf);
+		zfcp_dbf_hba_fsf_resp("perr", 1, req, dbf);
 
 	} else if (qtcb->header.fsf_status != FSF_GOOD) {
-		zfcp_hba_dbf_event_fsf_resp("ferr", 1, req, dbf);
+		zfcp_dbf_hba_fsf_resp("ferr", 1, req, dbf);
 
 	} else if ((req->fsf_command == FSF_QTCB_OPEN_PORT_WITH_DID) ||
 		   (req->fsf_command == FSF_QTCB_OPEN_LUN)) {
-		zfcp_hba_dbf_event_fsf_resp("open", 4, req, dbf);
+		zfcp_dbf_hba_fsf_resp("open", 4, req, dbf);
 
 	} else if (qtcb->header.log_length) {
-		zfcp_hba_dbf_event_fsf_resp("qtcb", 5, req, dbf);
+		zfcp_dbf_hba_fsf_resp("qtcb", 5, req, dbf);
 
 	} else {
-		zfcp_hba_dbf_event_fsf_resp("norm", 6, req, dbf);
+		zfcp_dbf_hba_fsf_resp("norm", 6, req, dbf);
 	}
  }
 
 /**
- * zfcp_hba_dbf_event_fsf_unsol - trace event for an unsolicited status buffer
+ * zfcp_dbf_hba_fsf_unsol - trace event for an unsolicited status buffer
  * @tag: tag indicating which kind of unsolicited status has been received
- * @adapter: adapter that has issued the unsolicited status buffer
+ * @dbf: reference to dbf structure
  * @status_buffer: buffer containing payload of unsolicited status
  */
 static inline
-void zfcp_hba_dbf_event_fsf_unsol(const char *tag, struct zfcp_adapter *adapter,
-				  struct fsf_status_read_buffer *buf)
+void zfcp_dbf_hba_fsf_unsol(const char *tag, struct zfcp_dbf *dbf,
+			    struct fsf_status_read_buffer *buf)
 {
-	struct zfcp_dbf *dbf = adapter->dbf;
 	int level = 2;
 
-	if (level <= dbf->hba_dbf->level)
-		_zfcp_hba_dbf_event_fsf_unsol(tag, level, adapter, buf);
+	if (level <= dbf->hba->level)
+		_zfcp_dbf_hba_fsf_unsol(tag, level, dbf, buf);
 }
 
 static inline
-void zfcp_scsi_dbf_event(const char *tag, const char *tag2, int level,
-			 struct zfcp_adapter *adapter, struct scsi_cmnd *scmd,
-			 struct zfcp_fsf_req *req, unsigned long old_id)
+void zfcp_dbf_scsi(const char *tag, const char *tag2, int level,
+		   struct zfcp_dbf *dbf, struct scsi_cmnd *scmd,
+		   struct zfcp_fsf_req *req, unsigned long old_id)
 {
-	struct zfcp_dbf *dbf = adapter->dbf;
-
-	if (level <= dbf->scsi_dbf->level)
-		_zfcp_scsi_dbf_event(tag, tag2, level, dbf, scmd, req, old_id);
+	if (level <= dbf->scsi->level)
+		_zfcp_dbf_scsi(tag, tag2, level, dbf, scmd, req, old_id);
 }
 
 /**
- * zfcp_scsi_dbf_event_result - trace event for SCSI command completion
+ * zfcp_dbf_scsi_result - trace event for SCSI command completion
  * @tag: tag indicating success or failure of SCSI command
  * @level: trace level applicable for this event
  * @adapter: adapter that has been used to issue the SCSI command
@@ -312,16 +310,14 @@ void zfcp_scsi_dbf_event(const char *tag, const char *tag2, int level,
  * @fsf_req: request used to issue SCSI command (might be NULL)
  */
 static inline
-void zfcp_scsi_dbf_event_result(const char *tag, int level,
-				struct zfcp_adapter *adapter,
-				struct scsi_cmnd *scmd,
-				struct zfcp_fsf_req *fsf_req)
+void zfcp_dbf_scsi_result(const char *tag, int level, struct zfcp_dbf *dbf,
+			  struct scsi_cmnd *scmd, struct zfcp_fsf_req *fsf_req)
 {
-	zfcp_scsi_dbf_event("rslt", tag, level, adapter, scmd, fsf_req, 0);
+	zfcp_dbf_scsi("rslt", tag, level, dbf, scmd, fsf_req, 0);
 }
 
 /**
- * zfcp_scsi_dbf_event_abort - trace event for SCSI command abort
+ * zfcp_dbf_scsi_abort - trace event for SCSI command abort
  * @tag: tag indicating success or failure of abort operation
  * @adapter: adapter thas has been used to issue SCSI command to be aborted
  * @scmd: SCSI command to be aborted
@@ -329,28 +325,26 @@ void zfcp_scsi_dbf_event_result(const char *tag, int level,
  * @old_id: identifier of request containg SCSI command to be aborted
  */
 static inline
-void zfcp_scsi_dbf_event_abort(const char *tag, struct zfcp_adapter *adapter,
-			       struct scsi_cmnd *scmd,
-			       struct zfcp_fsf_req *new_req,
-			       unsigned long old_id)
+void zfcp_dbf_scsi_abort(const char *tag, struct zfcp_dbf *dbf,
+			 struct scsi_cmnd *scmd, struct zfcp_fsf_req *new_req,
+			 unsigned long old_id)
 {
-	zfcp_scsi_dbf_event("abrt", tag, 1, adapter, scmd, new_req, old_id);
+	zfcp_dbf_scsi("abrt", tag, 1, dbf, scmd, new_req, old_id);
 }
 
 /**
- * zfcp_scsi_dbf_event_devreset - trace event for Logical Unit or Target Reset
+ * zfcp_dbf_scsi_devreset - trace event for Logical Unit or Target Reset
  * @tag: tag indicating success or failure of reset operation
  * @flag: indicates type of reset (Target Reset, Logical Unit Reset)
  * @unit: unit that needs reset
  * @scsi_cmnd: SCSI command which caused this error recovery
  */
 static inline
-void zfcp_scsi_dbf_event_devreset(const char *tag, u8 flag,
-				  struct zfcp_unit *unit,
-				  struct scsi_cmnd *scsi_cmnd)
+void zfcp_dbf_scsi_devreset(const char *tag, u8 flag, struct zfcp_unit *unit,
+			    struct scsi_cmnd *scsi_cmnd)
 {
-	zfcp_scsi_dbf_event(flag == FCP_TARGET_RESET ? "trst" : "lrst", tag, 1,
-			    unit->port->adapter, scsi_cmnd, NULL, 0);
+	zfcp_dbf_scsi(flag == FCP_TARGET_RESET ? "trst" : "lrst", tag, 1,
+			    unit->port->adapter->dbf, scsi_cmnd, NULL, 0);
 }
 
 #endif /* ZFCP_DBF_H */

commit 2e261af84cdb6a6008a9c361443e35ea646ec683
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue Aug 18 15:43:09 2009 +0200

    [SCSI] zfcp: Only collect FSF/HBA debug data for matching trace levels
    
    The default trace level is to only trace failed FSF commands. Thus it
    is not necessary to collect trace data for most FSF commands, since
    it will be thrown away later. Restructure the FSF/HBA trace
    infrastructure to first check the trace level in a inline function and
    only do the expensive data collection for matching trace levels.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index c2d5ef18b73a..bceaff449033 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -239,6 +239,59 @@ struct zfcp_dbf {
 	struct zfcp_scsi_dbf_record	scsi_dbf_buf;
 };
 
+static inline
+void zfcp_hba_dbf_event_fsf_resp(const char *tag2, int level,
+				 struct zfcp_fsf_req *req, struct zfcp_dbf *dbf)
+{
+	if (level <= dbf->hba_dbf->level)
+		_zfcp_hba_dbf_event_fsf_response(tag2, level, req, dbf);
+}
+
+/**
+ * zfcp_hba_dbf_event_fsf_response - trace event for request completion
+ * @fsf_req: request that has been completed
+ */
+static inline void zfcp_hba_dbf_event_fsf_response(struct zfcp_fsf_req *req)
+{
+	struct zfcp_dbf *dbf = req->adapter->dbf;
+	struct fsf_qtcb *qtcb = req->qtcb;
+
+	if ((qtcb->prefix.prot_status != FSF_PROT_GOOD) &&
+	    (qtcb->prefix.prot_status != FSF_PROT_FSF_STATUS_PRESENTED)) {
+		zfcp_hba_dbf_event_fsf_resp("perr", 1, req, dbf);
+
+	} else if (qtcb->header.fsf_status != FSF_GOOD) {
+		zfcp_hba_dbf_event_fsf_resp("ferr", 1, req, dbf);
+
+	} else if ((req->fsf_command == FSF_QTCB_OPEN_PORT_WITH_DID) ||
+		   (req->fsf_command == FSF_QTCB_OPEN_LUN)) {
+		zfcp_hba_dbf_event_fsf_resp("open", 4, req, dbf);
+
+	} else if (qtcb->header.log_length) {
+		zfcp_hba_dbf_event_fsf_resp("qtcb", 5, req, dbf);
+
+	} else {
+		zfcp_hba_dbf_event_fsf_resp("norm", 6, req, dbf);
+	}
+ }
+
+/**
+ * zfcp_hba_dbf_event_fsf_unsol - trace event for an unsolicited status buffer
+ * @tag: tag indicating which kind of unsolicited status has been received
+ * @adapter: adapter that has issued the unsolicited status buffer
+ * @status_buffer: buffer containing payload of unsolicited status
+ */
+static inline
+void zfcp_hba_dbf_event_fsf_unsol(const char *tag, struct zfcp_adapter *adapter,
+				  struct fsf_status_read_buffer *buf)
+{
+	struct zfcp_dbf *dbf = adapter->dbf;
+	int level = 2;
+
+	if (level <= dbf->hba_dbf->level)
+		_zfcp_hba_dbf_event_fsf_unsol(tag, level, adapter, buf);
+}
+
 static inline
 void zfcp_scsi_dbf_event(const char *tag, const char *tag2, int level,
 			 struct zfcp_adapter *adapter, struct scsi_cmnd *scmd,

commit dcd20e2316cdc333dfdee09649dbe3642eb30e75
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue Aug 18 15:43:08 2009 +0200

    [SCSI] zfcp: Only collect SCSI debug data for matching trace levels
    
    The default trace level is to only trace failed SCSI commands. Thus it
    is not necessary to collect trace data for most SCSI commands since it
    will be thrown away later. Restructure the SCSI trace infrastructure
    to first check the trace level in a inline function and only do the
    expensive data collection for matching trace levels.
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 4cfd68fe8a26..c2d5ef18b73a 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -22,7 +22,9 @@
 #ifndef ZFCP_DBF_H
 #define ZFCP_DBF_H
 
+#include "zfcp_ext.h"
 #include "zfcp_fsf.h"
+#include "zfcp_def.h"
 
 #define ZFCP_DBF_TAG_SIZE      4
 #define ZFCP_DBF_ID_SIZE       7
@@ -237,4 +239,65 @@ struct zfcp_dbf {
 	struct zfcp_scsi_dbf_record	scsi_dbf_buf;
 };
 
+static inline
+void zfcp_scsi_dbf_event(const char *tag, const char *tag2, int level,
+			 struct zfcp_adapter *adapter, struct scsi_cmnd *scmd,
+			 struct zfcp_fsf_req *req, unsigned long old_id)
+{
+	struct zfcp_dbf *dbf = adapter->dbf;
+
+	if (level <= dbf->scsi_dbf->level)
+		_zfcp_scsi_dbf_event(tag, tag2, level, dbf, scmd, req, old_id);
+}
+
+/**
+ * zfcp_scsi_dbf_event_result - trace event for SCSI command completion
+ * @tag: tag indicating success or failure of SCSI command
+ * @level: trace level applicable for this event
+ * @adapter: adapter that has been used to issue the SCSI command
+ * @scmd: SCSI command pointer
+ * @fsf_req: request used to issue SCSI command (might be NULL)
+ */
+static inline
+void zfcp_scsi_dbf_event_result(const char *tag, int level,
+				struct zfcp_adapter *adapter,
+				struct scsi_cmnd *scmd,
+				struct zfcp_fsf_req *fsf_req)
+{
+	zfcp_scsi_dbf_event("rslt", tag, level, adapter, scmd, fsf_req, 0);
+}
+
+/**
+ * zfcp_scsi_dbf_event_abort - trace event for SCSI command abort
+ * @tag: tag indicating success or failure of abort operation
+ * @adapter: adapter thas has been used to issue SCSI command to be aborted
+ * @scmd: SCSI command to be aborted
+ * @new_req: request containing abort (might be NULL)
+ * @old_id: identifier of request containg SCSI command to be aborted
+ */
+static inline
+void zfcp_scsi_dbf_event_abort(const char *tag, struct zfcp_adapter *adapter,
+			       struct scsi_cmnd *scmd,
+			       struct zfcp_fsf_req *new_req,
+			       unsigned long old_id)
+{
+	zfcp_scsi_dbf_event("abrt", tag, 1, adapter, scmd, new_req, old_id);
+}
+
+/**
+ * zfcp_scsi_dbf_event_devreset - trace event for Logical Unit or Target Reset
+ * @tag: tag indicating success or failure of reset operation
+ * @flag: indicates type of reset (Target Reset, Logical Unit Reset)
+ * @unit: unit that needs reset
+ * @scsi_cmnd: SCSI command which caused this error recovery
+ */
+static inline
+void zfcp_scsi_dbf_event_devreset(const char *tag, u8 flag,
+				  struct zfcp_unit *unit,
+				  struct scsi_cmnd *scsi_cmnd)
+{
+	zfcp_scsi_dbf_event(flag == FCP_TARGET_RESET ? "trst" : "lrst", tag, 1,
+			    unit->port->adapter, scsi_cmnd, NULL, 0);
+}
+
 #endif /* ZFCP_DBF_H */

commit d46f384a89c2378cb7858747faa1935db17e22a8
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue Aug 18 15:43:07 2009 +0200

    [SCSI] zfcp: Move debug data from zfcp_data to own data structure
    
    The struct zfcp_adapter includes everything related to the debug
    traces. This introduces dependences between the definitions in
    zfcp_def.h and zfcp_dbf.h. Move all debug related data structures to a
    new data structure to break those dependencies and manage the debug
    data in zfcp_dbf.[hc].
    
    Reviewed-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index a573f7344dd6..4cfd68fe8a26 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -2,7 +2,7 @@
  * This file is part of the zfcp device driver for
  * FCP adapters for IBM System z9 and zSeries.
  *
- * Copyright IBM Corp. 2008, 2008
+ * Copyright IBM Corp. 2008, 2009
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -222,4 +222,19 @@ struct zfcp_scsi_dbf_record {
 	u8 sns_info[ZFCP_DBF_SCSI_FCP_SNS_INFO];
 } __attribute__ ((packed));
 
+struct zfcp_dbf {
+	debug_info_t			*rec_dbf;
+	debug_info_t			*hba_dbf;
+	debug_info_t			*san_dbf;
+	debug_info_t			*scsi_dbf;
+	spinlock_t			rec_dbf_lock;
+	spinlock_t			hba_dbf_lock;
+	spinlock_t			san_dbf_lock;
+	spinlock_t			scsi_dbf_lock;
+	struct zfcp_rec_dbf_record	rec_dbf_buf;
+	struct zfcp_hba_dbf_record	hba_dbf_buf;
+	struct zfcp_san_dbf_record	san_dbf_buf;
+	struct zfcp_scsi_dbf_record	scsi_dbf_buf;
+};
+
 #endif /* ZFCP_DBF_H */

commit 5ffd51a5e495a2a002efd523aef0001912b080bd
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Mon Mar 2 13:09:04 2009 +0100

    [SCSI] zfcp: replace current ERP logging with a more convenient version
    
    The current number based id ERP logging is replaced by a string
    based tag version. The benefit is an easier location of the code in
    question and the removal of the lengthy array referencing the
    individual messages.
    The string (7 bytes) based version does not use more space since those
    bytes were "used" anyway due to the alignment of the structure.
    The encoding of the 7 byte string is as follows
            [0-1] = filename
            [2-5] = task/function
            [6]   = section
    Due to the character of this string (fixed length) a string
    termination is not required here.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 74998ff88e57..a573f7344dd6 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -25,6 +25,7 @@
 #include "zfcp_fsf.h"
 
 #define ZFCP_DBF_TAG_SIZE      4
+#define ZFCP_DBF_ID_SIZE       7
 
 struct zfcp_dbf_dump {
 	u8 tag[ZFCP_DBF_TAG_SIZE];
@@ -70,7 +71,7 @@ struct zfcp_rec_dbf_record_action {
 
 struct zfcp_rec_dbf_record {
 	u8 id;
-	u8 id2;
+	char id2[7];
 	union {
 		struct zfcp_rec_dbf_record_action action;
 		struct zfcp_rec_dbf_record_thread thread;

commit 39eb7e9aca2a582330ddb6f1167272268e6b3965
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Fri Dec 19 16:57:01 2008 +0100

    [SCSI] zfcp: Add support for unchained FSF requests
    
    Add the support to send CT and ELS requests as unchained FSF requests. This is
    required for older hardware and was somehow omitted during the cleanup of the
    FSF layer. The req_count and resp_count attributes are unused, so remove them
    instead of adding a special case for setting them. Also add debug data and a
    warning, when the ct request hits a limit.
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Acked-by: Martin Petermann <martin@linux.vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 5d6b2dff855b..74998ff88e57 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -171,6 +171,7 @@ struct zfcp_san_dbf_record_ct_response {
 	u8 reason_code;
 	u8 expl;
 	u8 vendor_unique;
+	u16 max_res_size;
 	u32 len;
 } __attribute__ ((packed));
 

commit d94ce6c6e99252ab2ba340b0398c8651713a9f05
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Tue Nov 4 16:35:12 2008 +0100

    [SCSI] zfcp: Fix hexdump data in s390dbf traces
    
    Fix multiple problems found in the hexdump data:
     - length calculation was wrong, traces were incomplete
     - FC payloads were dumped in different record than the output
       function tried to read
     - minor fixes in output
     - allow complete RSCN traces (up to 1024 bytes according to spec)
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index e8f450801fea..5d6b2dff855b 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -163,8 +163,6 @@ struct zfcp_san_dbf_record_ct_request {
 	u8 options;
 	u16 max_res_size;
 	u32 len;
-#define ZFCP_DBF_CT_PAYLOAD	24
-	u8 payload[ZFCP_DBF_CT_PAYLOAD];
 } __attribute__ ((packed));
 
 struct zfcp_san_dbf_record_ct_response {
@@ -174,15 +172,11 @@ struct zfcp_san_dbf_record_ct_response {
 	u8 expl;
 	u8 vendor_unique;
 	u32 len;
-	u8 payload[ZFCP_DBF_CT_PAYLOAD];
 } __attribute__ ((packed));
 
 struct zfcp_san_dbf_record_els {
 	u8 ls_code;
 	u32 len;
-#define ZFCP_DBF_ELS_PAYLOAD	32
-#define ZFCP_DBF_ELS_MAX_PAYLOAD 1024
-	u8 payload[ZFCP_DBF_ELS_PAYLOAD];
 } __attribute__ ((packed));
 
 struct zfcp_san_dbf_record {
@@ -196,6 +190,8 @@ struct zfcp_san_dbf_record {
 		struct zfcp_san_dbf_record_ct_response ct_resp;
 		struct zfcp_san_dbf_record_els els;
 	} u;
+#define ZFCP_DBF_SAN_MAX_PAYLOAD 1024
+	u8 payload[32];
 } __attribute__ ((packed));
 
 struct zfcp_scsi_dbf_record {

commit 57069386699994c3e67042fc4928c418f3a39e01
Author: Swen Schillig <swen@vnet.ibm.com>
Date:   Wed Oct 1 12:42:21 2008 +0200

    [SCSI] zfcp: put threshold data in hba trace
    
    Now that we removed the long messages for the bit error threshold
    data, put the data in the hba trace. This way, we get a short warning
    for the threshold event from the hardware and have the data in the
    trace for further analysis.
    
    Signed-off-by: Swen Schillig <swen@vnet.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 0ddb18449d11..e8f450801fea 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -151,6 +151,7 @@ struct zfcp_hba_dbf_record {
 		struct zfcp_hba_dbf_record_response response;
 		struct zfcp_hba_dbf_record_status status;
 		struct zfcp_hba_dbf_record_qdio qdio;
+		struct fsf_bit_error_payload berr;
 	} u;
 } __attribute__ ((packed));
 

commit 779e6e1c724d30e0fd1baca78b852e41e3a23c1d
Author: Jan Glauber <jang@linux.vnet.ibm.com>
Date:   Thu Jul 17 17:16:48 2008 +0200

    [S390] qdio: new qdio driver.
    
    List of major changes:
    - split qdio driver into several files
    - seperation of thin interrupt code
    - improved handling for multiple thin interrupt devices
    - inbound and outbound processing now always runs in tasklet context
    - significant less tasklet schedules per interrupt needed
    - merged qebsm with non-qebsm handling
    - cleanup qdio interface and added kerneldoc
    - coding style
    
    Reviewed-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Reviewed-by: Utz Bacher <utz.bacher@de.ibm.com>
    Reviewed-by: Ursula Braun <braunu@de.ibm.com>
    Signed-off-by: Jan Glauber <jang@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index d04aea604974..0ddb18449d11 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -139,9 +139,7 @@ struct zfcp_hba_dbf_record_status {
 } __attribute__ ((packed));
 
 struct zfcp_hba_dbf_record_qdio {
-	u32 status;
 	u32 qdio_error;
-	u32 siga_error;
 	u8 sbal_index;
 	u8 sbal_count;
 } __attribute__ ((packed));

commit 7337891f381f856a63595392d7e79f2580912bf7
Author: Martin Peschke <mp3@de.ibm.com>
Date:   Mon May 19 12:17:46 2008 +0200

    [SCSI] zfcp: remove some __attribute__ ((packed))
    
    There is no need to pack data structures which describe the
    contents of records in the new recovery trace.
    
    lcrash currently depends on the binary format for the other traces,
    removing the packed attribute from all traces would break trace
    debugging with lcrash.
    
    Signed-off-by: Martin Peschke <mp3@de.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index f71176acfab8..d04aea604974 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -38,7 +38,7 @@ struct zfcp_rec_dbf_record_thread {
 	u32 total;
 	u32 ready;
 	u32 running;
-} __attribute__ ((packed));
+};
 
 struct zfcp_rec_dbf_record_target {
 	u64 ref;
@@ -47,7 +47,7 @@ struct zfcp_rec_dbf_record_target {
 	u64 wwpn;
 	u64 fcp_lun;
 	u32 erp_count;
-} __attribute__ ((packed));
+};
 
 struct zfcp_rec_dbf_record_trigger {
 	u8 want;
@@ -59,14 +59,14 @@ struct zfcp_rec_dbf_record_trigger {
 	u64 action;
 	u64 wwpn;
 	u64 fcp_lun;
-} __attribute__ ((packed));
+};
 
 struct zfcp_rec_dbf_record_action {
 	u32 status;
 	u32 step;
 	u64 action;
 	u64 fsf_req;
-} __attribute__ ((packed));
+};
 
 struct zfcp_rec_dbf_record {
 	u8 id;
@@ -77,7 +77,7 @@ struct zfcp_rec_dbf_record {
 		struct zfcp_rec_dbf_record_target target;
 		struct zfcp_rec_dbf_record_trigger trigger;
 	} u;
-} __attribute__ ((packed));
+};
 
 enum {
 	ZFCP_REC_DBF_ID_ACTION,

commit c3baa9a26c5ac7e8d801093d55d33620d8bc2fe2
Author: Martin Peschke <mp3@de.ibm.com>
Date:   Mon May 19 12:17:44 2008 +0200

    [SCSI] zfcp: Add information about interrupt to trace.
    
    Store the index of the buffer in the inbound queue used to report
    request completion in trace record for request coompletion.
    This piece of information allows to better compare qdio and zfcp traces.
    
    Signed-off-by: Martin Peschke <mp3@de.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 212622ca2e80..f71176acfab8 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -98,6 +98,7 @@ struct zfcp_hba_dbf_record_response {
 	u32 fsf_req_status;
 	u8 sbal_first;
 	u8 sbal_last;
+	u8 sbal_response;
 	u8 pool;
 	u64 erp_action;
 	union {

commit e891bffe927f39718cf84c35b380d6edb189848b
Author: Martin Peschke <mp3@de.ibm.com>
Date:   Mon May 19 12:17:43 2008 +0200

    [SCSI] zfcp: Rename sbal_curr to sbal_last.
    
    sbal_last is more appropriate, because it matches sbal_first.
    
    Signed-off-by: Martin Peschke <mp3@de.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 66b8754840b2..212622ca2e80 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -97,7 +97,7 @@ struct zfcp_hba_dbf_record_response {
 	u8 fsf_status_qual[FSF_STATUS_QUALIFIER_SIZE];
 	u32 fsf_req_status;
 	u8 sbal_first;
-	u8 sbal_curr;
+	u8 sbal_last;
 	u8 pool;
 	u64 erp_action;
 	union {

commit 0f83b110f0cf6aef59e66184d5a1513318d654b5
Author: Martin Peschke <mp3@de.ibm.com>
Date:   Mon May 19 12:17:41 2008 +0200

    [SCSI] zfcp: Remove field sbal_last from trace record.
    
    This field is not needed, because it designates an index with a fix offset
    from sbal_first. It's name is confusing anyway.
    
    Signed-off-by: Martin Peschke <mp3@de.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 54c34e483457..66b8754840b2 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -98,7 +98,6 @@ struct zfcp_hba_dbf_record_response {
 	u32 fsf_req_status;
 	u8 sbal_first;
 	u8 sbal_curr;
-	u8 sbal_last;
 	u8 pool;
 	u64 erp_action;
 	union {

commit ee95a16d3950367d32beb6ffed287666631dbda9
Author: Martin Peschke <mp3@de.ibm.com>
Date:   Thu Apr 17 00:08:03 2008 +0200

    [SCSI] zfcp: fix compiler warning caused by poking inside new semaphore (linux-next)
    
    as seen in linux-next tree:
    
    drivers/s390/scsi/zfcp_dbf.c: In function โzfcp_rec_dbf_event_threadโ:
    drivers/s390/scsi/zfcp_dbf.c:697: warning: passing argument 1 of โatomic_readโ
     from incompatible pointer type
    
    Caused by recent git commit:
    
    commit 348447e85749120ad600a5c8e23b6bb7058b931d
    Author: Martin Peschke <mp3@de.ibm.com>
    Date:   Thu Mar 27 14:22:01 2008 +0100
    
        [SCSI] zfcp: Add trace records for recovery thread and its queues
    
    We are not supposed to poke inside semaphore.
    
    Signed-off-by: Martin Peschke <mp3@de.ibm.com>
    Acked-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 732a5ba1bea9..54c34e483457 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -35,7 +35,6 @@ struct zfcp_dbf_dump {
 } __attribute__ ((packed));
 
 struct zfcp_rec_dbf_record_thread {
-	u32 sema;
 	u32 total;
 	u32 ready;
 	u32 running;

commit 6bc473dd324237acbaa7a4c5e73d00dd5fc389ec
Author: Martin Peschke <mp3@de.ibm.com>
Date:   Mon Mar 31 11:15:29 2008 +0200

    [SCSI] zfcp: Shorten excessive names in debug trace.
    
    Saving on line breaks, improving readability, by shortening excessive
    function names and identifiers, by simplifying some functions call
    chains, and by simplifying nesting of some data structure.
    
    Signed-off-by: Martin Peschke <mp3@de.ibm.com>
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
index 5d88c01d5981..732a5ba1bea9 100644
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -104,9 +104,9 @@ struct zfcp_hba_dbf_record_response {
 	u64 erp_action;
 	union {
 		struct {
-			u64 scsi_cmnd;
-			u64 scsi_serial;
-		} send_fcp;
+			u64 cmnd;
+			u64 serial;
+		} fcp;
 		struct {
 			u64 wwpn;
 			u32 d_id;
@@ -121,8 +121,8 @@ struct zfcp_hba_dbf_record_response {
 		struct {
 			u32 d_id;
 			u8 ls_code;
-		} send_els;
-	} data;
+		} els;
+	} u;
 } __attribute__ ((packed));
 
 struct zfcp_hba_dbf_record_status {
@@ -154,35 +154,34 @@ struct zfcp_hba_dbf_record {
 		struct zfcp_hba_dbf_record_response response;
 		struct zfcp_hba_dbf_record_status status;
 		struct zfcp_hba_dbf_record_qdio qdio;
-	} type;
+	} u;
 } __attribute__ ((packed));
 
-struct zfcp_san_dbf_record_ct {
-	union {
-		struct {
-			u16 cmd_req_code;
-			u8 revision;
-			u8 gs_type;
-			u8 gs_subtype;
-			u8 options;
-			u16 max_res_size;
-		} request;
-		struct {
-			u16 cmd_rsp_code;
-			u8 revision;
-			u8 reason_code;
-			u8 reason_code_expl;
-			u8 vendor_unique;
-		} response;
-	} type;
-	u32 payload_size;
+struct zfcp_san_dbf_record_ct_request {
+	u16 cmd_req_code;
+	u8 revision;
+	u8 gs_type;
+	u8 gs_subtype;
+	u8 options;
+	u16 max_res_size;
+	u32 len;
 #define ZFCP_DBF_CT_PAYLOAD	24
 	u8 payload[ZFCP_DBF_CT_PAYLOAD];
 } __attribute__ ((packed));
 
+struct zfcp_san_dbf_record_ct_response {
+	u16 cmd_rsp_code;
+	u8 revision;
+	u8 reason_code;
+	u8 expl;
+	u8 vendor_unique;
+	u32 len;
+	u8 payload[ZFCP_DBF_CT_PAYLOAD];
+} __attribute__ ((packed));
+
 struct zfcp_san_dbf_record_els {
 	u8 ls_code;
-	u32 payload_size;
+	u32 len;
 #define ZFCP_DBF_ELS_PAYLOAD	32
 #define ZFCP_DBF_ELS_MAX_PAYLOAD 1024
 	u8 payload[ZFCP_DBF_ELS_PAYLOAD];
@@ -195,9 +194,10 @@ struct zfcp_san_dbf_record {
 	u32 s_id;
 	u32 d_id;
 	union {
-		struct zfcp_san_dbf_record_ct ct;
+		struct zfcp_san_dbf_record_ct_request ct_req;
+		struct zfcp_san_dbf_record_ct_response ct_resp;
 		struct zfcp_san_dbf_record_els els;
-	} type;
+	} u;
 } __attribute__ ((packed));
 
 struct zfcp_scsi_dbf_record {
@@ -215,19 +215,15 @@ struct zfcp_scsi_dbf_record {
 	u64 fsf_reqid;
 	u32 fsf_seqno;
 	u64 fsf_issued;
-	union {
-		u64 old_fsf_reqid;
-		struct {
-			u8 rsp_validity;
-			u8 rsp_scsi_status;
-			u32 rsp_resid;
-			u8 rsp_code;
+	u64 old_fsf_reqid;
+	u8 rsp_validity;
+	u8 rsp_scsi_status;
+	u32 rsp_resid;
+	u8 rsp_code;
 #define ZFCP_DBF_SCSI_FCP_SNS_INFO	16
 #define ZFCP_DBF_SCSI_MAX_FCP_SNS_INFO	256
-			u32 sns_info_len;
-			u8 sns_info[ZFCP_DBF_SCSI_FCP_SNS_INFO];
-		} fcp;
-	} type;
+	u32 sns_info_len;
+	u8 sns_info[ZFCP_DBF_SCSI_FCP_SNS_INFO];
 } __attribute__ ((packed));
 
 #endif /* ZFCP_DBF_H */

commit 2b604c9b909ce1c98e51208eee2f70ee3e604079
Author: Christof Schmitt <christof.schmitt@de.ibm.com>
Date:   Mon Mar 31 11:15:28 2008 +0200

    [SCSI] zfcp: Move DBF definitions to private header file
    
    Unclutter the global zfcp_def.h header. Move everything required to
    call into the debug feature to a new header file.
    
    Signed-off-by: Christof Schmitt <christof.schmitt@de.ibm.com>
    Signed-off-by: Martin Peschke <mp3@de.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h
new file mode 100644
index 000000000000..5d88c01d5981
--- /dev/null
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -0,0 +1,233 @@
+/*
+ * This file is part of the zfcp device driver for
+ * FCP adapters for IBM System z9 and zSeries.
+ *
+ * Copyright IBM Corp. 2008, 2008
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef ZFCP_DBF_H
+#define ZFCP_DBF_H
+
+#include "zfcp_fsf.h"
+
+#define ZFCP_DBF_TAG_SIZE      4
+
+struct zfcp_dbf_dump {
+	u8 tag[ZFCP_DBF_TAG_SIZE];
+	u32 total_size;		/* size of total dump data */
+	u32 offset;		/* how much data has being already dumped */
+	u32 size;		/* how much data comes with this record */
+	u8 data[];		/* dump data */
+} __attribute__ ((packed));
+
+struct zfcp_rec_dbf_record_thread {
+	u32 sema;
+	u32 total;
+	u32 ready;
+	u32 running;
+} __attribute__ ((packed));
+
+struct zfcp_rec_dbf_record_target {
+	u64 ref;
+	u32 status;
+	u32 d_id;
+	u64 wwpn;
+	u64 fcp_lun;
+	u32 erp_count;
+} __attribute__ ((packed));
+
+struct zfcp_rec_dbf_record_trigger {
+	u8 want;
+	u8 need;
+	u32 as;
+	u32 ps;
+	u32 us;
+	u64 ref;
+	u64 action;
+	u64 wwpn;
+	u64 fcp_lun;
+} __attribute__ ((packed));
+
+struct zfcp_rec_dbf_record_action {
+	u32 status;
+	u32 step;
+	u64 action;
+	u64 fsf_req;
+} __attribute__ ((packed));
+
+struct zfcp_rec_dbf_record {
+	u8 id;
+	u8 id2;
+	union {
+		struct zfcp_rec_dbf_record_action action;
+		struct zfcp_rec_dbf_record_thread thread;
+		struct zfcp_rec_dbf_record_target target;
+		struct zfcp_rec_dbf_record_trigger trigger;
+	} u;
+} __attribute__ ((packed));
+
+enum {
+	ZFCP_REC_DBF_ID_ACTION,
+	ZFCP_REC_DBF_ID_THREAD,
+	ZFCP_REC_DBF_ID_TARGET,
+	ZFCP_REC_DBF_ID_TRIGGER,
+};
+
+struct zfcp_hba_dbf_record_response {
+	u32 fsf_command;
+	u64 fsf_reqid;
+	u32 fsf_seqno;
+	u64 fsf_issued;
+	u32 fsf_prot_status;
+	u32 fsf_status;
+	u8 fsf_prot_status_qual[FSF_PROT_STATUS_QUAL_SIZE];
+	u8 fsf_status_qual[FSF_STATUS_QUALIFIER_SIZE];
+	u32 fsf_req_status;
+	u8 sbal_first;
+	u8 sbal_curr;
+	u8 sbal_last;
+	u8 pool;
+	u64 erp_action;
+	union {
+		struct {
+			u64 scsi_cmnd;
+			u64 scsi_serial;
+		} send_fcp;
+		struct {
+			u64 wwpn;
+			u32 d_id;
+			u32 port_handle;
+		} port;
+		struct {
+			u64 wwpn;
+			u64 fcp_lun;
+			u32 port_handle;
+			u32 lun_handle;
+		} unit;
+		struct {
+			u32 d_id;
+			u8 ls_code;
+		} send_els;
+	} data;
+} __attribute__ ((packed));
+
+struct zfcp_hba_dbf_record_status {
+	u8 failed;
+	u32 status_type;
+	u32 status_subtype;
+	struct fsf_queue_designator
+	 queue_designator;
+	u32 payload_size;
+#define ZFCP_DBF_UNSOL_PAYLOAD				80
+#define ZFCP_DBF_UNSOL_PAYLOAD_SENSE_DATA_AVAIL		32
+#define ZFCP_DBF_UNSOL_PAYLOAD_BIT_ERROR_THRESHOLD	56
+#define ZFCP_DBF_UNSOL_PAYLOAD_FEATURE_UPDATE_ALERT	2 * sizeof(u32)
+	u8 payload[ZFCP_DBF_UNSOL_PAYLOAD];
+} __attribute__ ((packed));
+
+struct zfcp_hba_dbf_record_qdio {
+	u32 status;
+	u32 qdio_error;
+	u32 siga_error;
+	u8 sbal_index;
+	u8 sbal_count;
+} __attribute__ ((packed));
+
+struct zfcp_hba_dbf_record {
+	u8 tag[ZFCP_DBF_TAG_SIZE];
+	u8 tag2[ZFCP_DBF_TAG_SIZE];
+	union {
+		struct zfcp_hba_dbf_record_response response;
+		struct zfcp_hba_dbf_record_status status;
+		struct zfcp_hba_dbf_record_qdio qdio;
+	} type;
+} __attribute__ ((packed));
+
+struct zfcp_san_dbf_record_ct {
+	union {
+		struct {
+			u16 cmd_req_code;
+			u8 revision;
+			u8 gs_type;
+			u8 gs_subtype;
+			u8 options;
+			u16 max_res_size;
+		} request;
+		struct {
+			u16 cmd_rsp_code;
+			u8 revision;
+			u8 reason_code;
+			u8 reason_code_expl;
+			u8 vendor_unique;
+		} response;
+	} type;
+	u32 payload_size;
+#define ZFCP_DBF_CT_PAYLOAD	24
+	u8 payload[ZFCP_DBF_CT_PAYLOAD];
+} __attribute__ ((packed));
+
+struct zfcp_san_dbf_record_els {
+	u8 ls_code;
+	u32 payload_size;
+#define ZFCP_DBF_ELS_PAYLOAD	32
+#define ZFCP_DBF_ELS_MAX_PAYLOAD 1024
+	u8 payload[ZFCP_DBF_ELS_PAYLOAD];
+} __attribute__ ((packed));
+
+struct zfcp_san_dbf_record {
+	u8 tag[ZFCP_DBF_TAG_SIZE];
+	u64 fsf_reqid;
+	u32 fsf_seqno;
+	u32 s_id;
+	u32 d_id;
+	union {
+		struct zfcp_san_dbf_record_ct ct;
+		struct zfcp_san_dbf_record_els els;
+	} type;
+} __attribute__ ((packed));
+
+struct zfcp_scsi_dbf_record {
+	u8 tag[ZFCP_DBF_TAG_SIZE];
+	u8 tag2[ZFCP_DBF_TAG_SIZE];
+	u32 scsi_id;
+	u32 scsi_lun;
+	u32 scsi_result;
+	u64 scsi_cmnd;
+	u64 scsi_serial;
+#define ZFCP_DBF_SCSI_OPCODE	16
+	u8 scsi_opcode[ZFCP_DBF_SCSI_OPCODE];
+	u8 scsi_retries;
+	u8 scsi_allowed;
+	u64 fsf_reqid;
+	u32 fsf_seqno;
+	u64 fsf_issued;
+	union {
+		u64 old_fsf_reqid;
+		struct {
+			u8 rsp_validity;
+			u8 rsp_scsi_status;
+			u32 rsp_resid;
+			u8 rsp_code;
+#define ZFCP_DBF_SCSI_FCP_SNS_INFO	16
+#define ZFCP_DBF_SCSI_MAX_FCP_SNS_INFO	256
+			u32 sns_info_len;
+			u8 sns_info[ZFCP_DBF_SCSI_FCP_SNS_INFO];
+		} fcp;
+	} type;
+} __attribute__ ((packed));
+
+#endif /* ZFCP_DBF_H */
