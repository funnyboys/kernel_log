commit fa226f1d81e2d3798d30eaa14550d7f35c35e6f3
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Fri Feb 21 09:06:12 2020 -0600

    s390: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Link: https://lkml.kernel.org/r/20200221150612.GA9717@embeddedor
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/drivers/s390/crypto/zcrypt_ccamisc.h b/drivers/s390/crypto/zcrypt_ccamisc.h
index 3a9876d5ab0e..8b7a641671c9 100644
--- a/drivers/s390/crypto/zcrypt_ccamisc.h
+++ b/drivers/s390/crypto/zcrypt_ccamisc.h
@@ -90,7 +90,7 @@ struct cipherkeytoken {
 	u16 kmf1;     /* key management field 1 */
 	u16 kmf2;     /* key management field 2 */
 	u16 kmf3;     /* key management field 3 */
-	u8  vdata[0]; /* variable part data follows */
+	u8  vdata[]; /* variable part data follows */
 } __packed;
 
 /* Some defines for the CCA AES cipherkeytoken kmf1 field */

commit 888edbc48857c7189592fb0be3ab09994247199c
Author: Harald Freudenberger <freude@linux.ibm.com>
Date:   Fri Sep 27 11:16:42 2019 +0200

    s390/pkey: Add support for key blob with clear key value
    
    This patch adds support for a new key blob format to the
    pkey kernel module. The new key blob comprises a clear
    key value together with key type information.
    
    The implementation tries to derive an protected key
    from the blob with the clear key value inside with
    1) the PCKMO instruction. This may fail as the LPAR
       profile may disable this way.
    2) Generate an CCA AES secure data key with exact the
       clear key value. This requires to have a working
       crypto card in CCA Coprocessor mode. Then derive
       an protected key from the CCA AES secure key again
       with the help of a working crypto card in CCA mode.
    If both way fail, the transformation of the clear key
    blob into a protected key will fail. For the PAES cipher
    this would result in a failure at setkey() invocation.
    
    A clear key value exposed in main memory is a security
    risk. The intention of this new 'clear key blob' support
    for pkey is to provide self-tests for the PAES cipher key
    implementation. These known answer tests obviously need
    to be run with well known key values. So with the clear
    key blob format there is a way to provide knwon answer
    tests together with an pkey clear key blob for the
    in-kernel self tests done at cipher registration.
    
    Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/drivers/s390/crypto/zcrypt_ccamisc.h b/drivers/s390/crypto/zcrypt_ccamisc.h
index 77b6cc7b8f82..3a9876d5ab0e 100644
--- a/drivers/s390/crypto/zcrypt_ccamisc.h
+++ b/drivers/s390/crypto/zcrypt_ccamisc.h
@@ -19,6 +19,7 @@
 
 /* For TOKTYPE_NON_CCA: */
 #define TOKVER_PROTECTED_KEY	0x01 /* Protected key token */
+#define TOKVER_CLEAR_KEY	0x02 /* Clear key token */
 
 /* For TOKTYPE_CCA_INTERNAL: */
 #define TOKVER_CCA_AES		0x04 /* CCA AES key token */

commit f2bbc96e7cfad3891b7bf9bd3e566b9b7ab4553d
Author: Harald Freudenberger <freude@linux.ibm.com>
Date:   Wed Jun 19 14:26:05 2019 +0200

    s390/pkey: add CCA AES cipher key support
    
    Introduce new ioctls and structs to be used with these new ioctls
    which are able to handle CCA AES secure keys and CCA AES cipher keys:
    
    PKEY_GENSECK2: Generate secure key, version 2.
      Generate either a CCA AES secure key or a CCA AES cipher key.
    
    PKEY_CLR2SECK2: Generate secure key from clear key value, version 2.
      Construct a CCA AES secure key or CCA AES cipher key from a given
      clear key value.
    
    PKEY_VERIFYKEY2: Verify the given secure key, version 2.
      Check for correct key type. If cardnr and domain are given, also
      check if this apqn is able to handle this type of key. If cardnr and
      domain are 0xFFFF, on return these values are filled with an apqn
      able to handle this key. The function also checks for the master key
      verification patterns of the key matching to the current or
      alternate mkvp of the apqn. CCA AES cipher keys are also checked
      for CPACF export allowed (CPRTCPAC flag). Currently CCA AES secure
      keys and CCA AES cipher keys are supported (may get extended in the
      future).
    
    PKEY_KBLOB2PROTK2: Transform a key blob (of any type) into
      a protected key, version 2. Difference to version 1 is only that
      this new ioctl has additional parameters to provide a list of
      apqns to be used for the transformation.
    
    PKEY_APQNS4K: Generate a list of APQNs based on the key blob given.
      Is able to find out which type of secure key is given (CCA AES
      secure key or CCA AES cipher key) and tries to find all matching
      crypto cards based on the MKVP and maybe other criterias (like CCA
      AES cipher keys need a CEX6C or higher). The list of APQNs is
      further filtered by the key's mkvp which needs to match to either
      the current mkvp or the alternate mkvp (which is the old mkvp on CCA
      adapters) of the apqns. The flags argument may be used to limit the
      matching apqns. If the PKEY_FLAGS_MATCH_CUR_MKVP is given, only the
      current mkvp of each apqn is compared. Likewise with the
      PKEY_FLAGS_MATCH_ALT_MKVP. If both are given it is assumed to return
      apqns where either the current or the alternate mkvp matches. If no
      matching APQN is found, the ioctl returns with 0 but the
      apqn_entries value is 0.
    
    PKEY_APQNS4KT: Generate a list of APQNs based on the key type given.
      Build a list of APQNs based on the given key type and maybe further
      restrict the list by given master key verification patterns.
      For different key types there may be different ways to match the
      master key verification patterns. For CCA keys (CCA data key and CCA
      cipher key) the first 8 bytes of cur_mkvp refer to the current mkvp
      value of the apqn and the first 8 bytes of the alt_mkvp refer to the
      old mkvp. The flags argument controls if the apqns current and/or
      alternate mkvp should match. If the PKEY_FLAGS_MATCH_CUR_MKVP is
      given, only the current mkvp of each apqn is compared. Likewise with
      the PKEY_FLAGS_MATCH_ALT_MKVP. If both are given, it is assumed to
      return apqns where either the current or the alternate mkvp
      matches. If no matching APQN is found, the ioctl returns with 0 but
      the apqn_entries value is 0.
    
    These new ioctls are now prepared for another new type of secure key
    blob which may come in the future. They all use a pointer to the key
    blob and a key blob length information instead of some hardcoded byte
    array. They all use the new enums pkey_key_type, pkey_key_size and
    pkey_key_info for getting/setting key type, key size and additional
    info about the key. All but the PKEY_VERIFY2 ioctl now work based on a
    list of apqns. This list is walked through trying to perform the
    operation on exactly this apqn without any further checking (like card
    type or online state). If the apqn fails, simple the next one in the
    list is tried until success (return 0) or the end of the list is
    reached (return -1 with errno ENODEV). All apqns in the list need to
    be exact apqns (0xFFFF as any card or domain is not allowed). There
    are two new ioctls which can be used to build a list of apqns based on
    a key or key type and maybe restricted by match to a current or
    alternate master key verifcation pattern.
    
    Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
    Reviewed-by: Ingo Franzki <ifranzki@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/drivers/s390/crypto/zcrypt_ccamisc.h b/drivers/s390/crypto/zcrypt_ccamisc.h
index e97cda0f61e0..77b6cc7b8f82 100644
--- a/drivers/s390/crypto/zcrypt_ccamisc.h
+++ b/drivers/s390/crypto/zcrypt_ccamisc.h
@@ -124,12 +124,12 @@ int cca_check_secaescipherkey(debug_info_t *dbg, int dbflvl,
 /*
  * Generate (random) CCA AES DATA secure key.
  */
-int cca_genseckey(u16 cardnr, u16 domain, u32 keytype, u8 *seckey);
+int cca_genseckey(u16 cardnr, u16 domain, u32 keybitsize, u8 *seckey);
 
 /*
  * Generate CCA AES DATA secure key with given clear key value.
  */
-int cca_clr2seckey(u16 cardnr, u16 domain, u32 keytype,
+int cca_clr2seckey(u16 cardnr, u16 domain, u32 keybitsize,
 		   const u8 *clrkey, u8 *seckey);
 
 /*
@@ -137,8 +137,7 @@ int cca_clr2seckey(u16 cardnr, u16 domain, u32 keytype,
  */
 int cca_sec2protkey(u16 cardnr, u16 domain,
 		    const u8 seckey[SECKEYBLOBSIZE],
-		    u8 *protkey, u32 *protkeylen,
-		    u32 *protkeytype);
+		    u8 *protkey, u32 *protkeylen, u32 *protkeytype);
 
 /*
  * Generate (random) CCA AES CIPHER secure key.
@@ -169,6 +168,7 @@ int cca_query_crypto_facility(u16 cardnr, u16 domain,
 /*
  * Search for a matching crypto card based on the Master Key
  * Verification Pattern provided inside a secure key.
+ * Works with CCA AES data and cipher keys.
  * Returns < 0 on failure, 0 if CURRENT MKVP matches and
  * 1 if OLD MKVP matches.
  */

commit 4bc123b18ce6ae6c42c69d0456b5acbd2f7bc8bd
Author: Harald Freudenberger <freude@linux.ibm.com>
Date:   Wed Jul 3 13:16:51 2019 +0200

    s390/zcrypt: Add low level functions for CCA AES cipher keys
    
    This patch adds low level functions, structs and defines to support
    CCA AES cipher keys:
    - struct cipherkeytoken can be used for an inside view of the CCA AES
      cipher key token blob.
    - function cca_cipher2protkey() derives an CPACF protected key from an
      CCA AES cipher key.
    - function cca_gencipherkey() generates an CCA AES cipher key with
      random value.
    - function cca_findcard2() constructs a list of apqns based on input
      constrains like min hardware type, mkvp values.
    - cca_check_secaescipherkey() does a check on the given CCA AES cipher
      key blob.
    - cca_clr2cipherkey() generates an CCA AES cipher key from a given
      clear key value.
    
    Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
    Reviewed-by: Ingo Franzki <ifranzki@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/drivers/s390/crypto/zcrypt_ccamisc.h b/drivers/s390/crypto/zcrypt_ccamisc.h
index e6f41e5baf18..e97cda0f61e0 100644
--- a/drivers/s390/crypto/zcrypt_ccamisc.h
+++ b/drivers/s390/crypto/zcrypt_ccamisc.h
@@ -22,11 +22,16 @@
 
 /* For TOKTYPE_CCA_INTERNAL: */
 #define TOKVER_CCA_AES		0x04 /* CCA AES key token */
+#define TOKVER_CCA_VLSC		0x05 /* var length sym cipher key token */
+
+/* Max size of a cca variable length cipher key token */
+#define MAXCCAVLSCTOKENSIZE 725
 
 /* header part of a CCA key token */
 struct keytoken_header {
 	u8  type;     /* one of the TOKTYPE values */
-	u8  res0[3];
+	u8  res0[1];
+	u16 len;      /* vlsc token: total length in bytes */
 	u8  version;  /* one of the TOKVER values */
 	u8  res1[3];
 } __packed;
@@ -47,6 +52,56 @@ struct secaeskeytoken {
 	u8  tvv[4];   /* token validation value */
 } __packed;
 
+/* inside view of a variable length symmetric cipher AES key token */
+struct cipherkeytoken {
+	u8  type;     /* 0x01 for internal key token */
+	u8  res0[1];
+	u16 len;      /* total key token length in bytes */
+	u8  version;  /* should be 0x05 */
+	u8  res1[3];
+	u8  kms;      /* key material state, 0x03 means wrapped with MK */
+	u8  kvpt;     /* key verification pattern type, should be 0x01 */
+	u64 mkvp0;    /* master key verification pattern, lo part */
+	u64 mkvp1;    /* master key verification pattern, hi part (unused) */
+	u8  eskwm;    /* encrypted section key wrapping method */
+	u8  hashalg;  /* hash algorithmus used for wrapping key */
+	u8  plfver;   /* pay load format version */
+	u8  res2[1];
+	u8  adsver;   /* associated data section version */
+	u8  res3[1];
+	u16 adslen;   /* associated data section length */
+	u8  kllen;    /* optional key label length */
+	u8  ieaslen;  /* optional extended associated data length */
+	u8  uadlen;   /* optional user definable associated data length */
+	u8  res4[1];
+	u16 wpllen;   /* wrapped payload length in bits: */
+		      /*   plfver  0x00 0x01		 */
+		      /*   AES-128  512  640		 */
+		      /*   AES-192  576  640		 */
+		      /*   AES-256  640  640		 */
+	u8  res5[1];
+	u8  algtype;  /* 0x02 for AES cipher */
+	u16 keytype;  /* 0x0001 for 'cipher' */
+	u8  kufc;     /* key usage field count */
+	u16 kuf1;     /* key usage field 1 */
+	u16 kuf2;     /* key usage field 2 */
+	u8  kmfc;     /* key management field count */
+	u16 kmf1;     /* key management field 1 */
+	u16 kmf2;     /* key management field 2 */
+	u16 kmf3;     /* key management field 3 */
+	u8  vdata[0]; /* variable part data follows */
+} __packed;
+
+/* Some defines for the CCA AES cipherkeytoken kmf1 field */
+#define KMF1_XPRT_SYM  0x8000
+#define KMF1_XPRT_UASY 0x4000
+#define KMF1_XPRT_AASY 0x2000
+#define KMF1_XPRT_RAW  0x1000
+#define KMF1_XPRT_CPAC 0x0800
+#define KMF1_XPRT_DES  0x0080
+#define KMF1_XPRT_AES  0x0040
+#define KMF1_XPRT_RSA  0x0008
+
 /*
  * Simple check if the token is a valid CCA secure AES data key
  * token. If keybitsize is given, the bitsize of the key is
@@ -55,6 +110,17 @@ struct secaeskeytoken {
 int cca_check_secaeskeytoken(debug_info_t *dbg, int dbflvl,
 			     const u8 *token, int keybitsize);
 
+/*
+ * Simple check if the token is a valid CCA secure AES cipher key
+ * token. If keybitsize is given, the bitsize of the key is
+ * also checked. If checkcpacfexport is enabled, the key is also
+ * checked for the export flag to allow CPACF export.
+ * Returns 0 on success or errno value on failure.
+ */
+int cca_check_secaescipherkey(debug_info_t *dbg, int dbflvl,
+			      const u8 *token, int keybitsize,
+			      int checkcpacfexport);
+
 /*
  * Generate (random) CCA AES DATA secure key.
  */
@@ -74,6 +140,24 @@ int cca_sec2protkey(u16 cardnr, u16 domain,
 		    u8 *protkey, u32 *protkeylen,
 		    u32 *protkeytype);
 
+/*
+ * Generate (random) CCA AES CIPHER secure key.
+ */
+int cca_gencipherkey(u16 cardnr, u16 domain, u32 keybitsize, u32 keygenflags,
+		     u8 *keybuf, size_t *keybufsize);
+
+/*
+ * Derive proteced key from CCA AES cipher secure key.
+ */
+int cca_cipher2protkey(u16 cardnr, u16 domain, const u8 *ckey,
+		       u8 *protkey, u32 *protkeylen, u32 *protkeytype);
+
+/*
+ * Build CCA AES CIPHER secure key with a given clear key value.
+ */
+int cca_clr2cipherkey(u16 cardnr, u16 domain, u32 keybitsize, u32 keygenflags,
+		      const u8 *clrkey, u8 *keybuf, size_t *keybufsize);
+
 /*
  * Query cryptographic facility from CCA adapter
  */
@@ -90,6 +174,27 @@ int cca_query_crypto_facility(u16 cardnr, u16 domain,
  */
 int cca_findcard(const u8 *key, u16 *pcardnr, u16 *pdomain, int verify);
 
+/*
+ * Build a list of cca apqns meeting the following constrains:
+ * - apqn is online and is in fact a CCA apqn
+ * - if cardnr is not FFFF only apqns with this cardnr
+ * - if domain is not FFFF only apqns with this domainnr
+ * - if minhwtype > 0 only apqns with hwtype >= minhwtype
+ * - if cur_mkvp != 0 only apqns where cur_mkvp == mkvp
+ * - if old_mkvp != 0 only apqns where old_mkvp == mkvp
+ * - if verify is enabled and a cur_mkvp and/or old_mkvp
+ *   value is given, then refetch the cca_info and make sure the current
+ *   cur_mkvp or old_mkvp values of the apqn are used.
+ * The array of apqn entries is allocated with kmalloc and returned in *apqns;
+ * the number of apqns stored into the list is returned in *nr_apqns. One apqn
+ * entry is simple a 32 bit value with 16 bit cardnr and 16 bit domain nr and
+ * may be casted to struct pkey_apqn. The return value is either 0 for success
+ * or a negative errno value. If no apqn meeting the criterias is found,
+ * -ENODEV is returned.
+ */
+int cca_findcard2(u32 **apqns, u32 *nr_apqns, u16 cardnr, u16 domain,
+		  int minhwtype, u64 cur_mkvp, u64 old_mkvp, int verify);
+
 /* struct to hold info for each CCA queue */
 struct cca_info {
 	int  hwtype;	    /* one of the defined AP_DEVICE_TYPE_* */

commit 4da57a2fea064f662c29e77da043baebb8d6cdc8
Author: Harald Freudenberger <freude@linux.ibm.com>
Date:   Tue Jun 18 15:53:12 2019 +0200

    s390/zcrypt: extend cca_findcard function and helper
    
    Rework and extension of the cca_findcard function to be prepared for
    other types of secure key blobs. Split the function and extract an
    internal function which has no awareness of key blobs any
    more. Improve this function and the helper code around to be able to
    check for a minimal crypto card hardware level (Background: the newer
    AES cipher keys need to match to the master key verification pattern
    and need to have a crypto card CEX6 or higher).
    
    No API change, neither for the in-kernel API nor the ioctl interface.
    
    Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
    Reviewed-by: Ingo Franzki <ifranzki@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/drivers/s390/crypto/zcrypt_ccamisc.h b/drivers/s390/crypto/zcrypt_ccamisc.h
index d92fb731602a..e6f41e5baf18 100644
--- a/drivers/s390/crypto/zcrypt_ccamisc.h
+++ b/drivers/s390/crypto/zcrypt_ccamisc.h
@@ -88,10 +88,11 @@ int cca_query_crypto_facility(u16 cardnr, u16 domain,
  * Returns < 0 on failure, 0 if CURRENT MKVP matches and
  * 1 if OLD MKVP matches.
  */
-int cca_findcard(const u8 *seckey, u16 *pcardnr, u16 *pdomain, int verify);
+int cca_findcard(const u8 *key, u16 *pcardnr, u16 *pdomain, int verify);
 
 /* struct to hold info for each CCA queue */
 struct cca_info {
+	int  hwtype;	    /* one of the defined AP_DEVICE_TYPE_* */
 	char new_mk_state;  /* '1' empty, '2' partially full, '3' full */
 	char cur_mk_state;  /* '1' invalid, '2' valid */
 	char old_mk_state;  /* '1' invalid, '2' valid */

commit 7c4e91c0959bf42a86ba4887425fc944d0d28595
Author: Harald Freudenberger <freude@linux.ibm.com>
Date:   Wed Jun 12 15:05:34 2019 +0200

    s390/zcrypt: new sysfs attributes serialnr and mkvps
    
    This patch extends the sysfs interface with two new attributes for the
    CEX4, CEX5 and CEX6 crypto cards/queues in coprocessor ('CCA') mode:
      /sys/devices/ap/cardxx/serialnr
      /sys/devices/ap/cardxx/xx.yyyy/mkvps
    
    The serialnr attribute is card based and shows the 8 character ASCII
    serial number string which should unique identify the card.
    
    The mkvps is queue based and displays 3 lines of information about the
    new, current and old master key register:
      AES NEW: <new_aes_mk_state> <new_aes_mk_mkvp>
      AES CUR: <cur_aes_mk_state> <cur_aes_mk_mkvp>
      AES OLD: <old_aes_mk_state> <old_aes_mk_mkvp>
    with
      <new_aes_mk_state>: 'empty' or 'partial' or 'full'
      <cur_aes_mk_state>: 'valid' or 'invalid'
      <old_aes_mk_state>: 'valid' or 'invalid'
      <new_aes_mk_mkvp>, <cur_aes_mk_mkvp>, <old_aes_mk_mkvp>
        8 byte hex string with leading 0x
    MKVP means Master Key Verification Pattern and is a folded hash over
    the key value. Only the states 'full' and 'valid' result in displaying
    a useful mkvp, otherwise a mkvp of all bytes zero is shown. If for any
    reason the FQ fails and the (cached) information is not available, the
    state '-' will be shown with the mkvp value also '-'. The values shown
    here are the very same as the cca panel tools displays. As of now only
    the AES master keys states and verification patterns are shown. A CCA
    APQN also has similar master key registers for DES, RSA and ECC. So
    the content of this attribute may get extended.
    
    Reading the sysfs attribute automatically triggers an FQ CPRB to be
    sent to the queue as long as the queue is (soft-) online. For the
    serialnr attribute the queue with the default domain id is addressed
    (if available and valid). This is reasonable as it is assumed that
    this sysfs interface is not performance critical and on the other side
    a master key change should be visiable as soon as possible. When a
    queue is (soft-) offline however, the cached values are displayed. If
    no cached values are available, the serial number string will be empty
    and the mkvp lines will show state '-' and mkvp value '-'.
    
    Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
    Reviewed-by: Ingo Franzki <ifranzki@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/drivers/s390/crypto/zcrypt_ccamisc.h b/drivers/s390/crypto/zcrypt_ccamisc.h
index 417427462493..d92fb731602a 100644
--- a/drivers/s390/crypto/zcrypt_ccamisc.h
+++ b/drivers/s390/crypto/zcrypt_ccamisc.h
@@ -90,6 +90,22 @@ int cca_query_crypto_facility(u16 cardnr, u16 domain,
  */
 int cca_findcard(const u8 *seckey, u16 *pcardnr, u16 *pdomain, int verify);
 
+/* struct to hold info for each CCA queue */
+struct cca_info {
+	char new_mk_state;  /* '1' empty, '2' partially full, '3' full */
+	char cur_mk_state;  /* '1' invalid, '2' valid */
+	char old_mk_state;  /* '1' invalid, '2' valid */
+	u64  new_mkvp;	    /* truncated sha256 hash of new master key */
+	u64  cur_mkvp;	    /* truncated sha256 hash of current master key */
+	u64  old_mkvp;	    /* truncated sha256 hash of old master key */
+	char serial[9];     /* serial number string (8 ascii numbers + 0x00) */
+};
+
+/*
+ * Fetch cca information about an CCA queue.
+ */
+int cca_get_info(u16 card, u16 dom, struct cca_info *ci, int verify);
+
 void zcrypt_ccamisc_exit(void);
 
 #endif /* _ZCRYPT_CCAMISC_H_ */

commit efc598e6c8a93491868ef7dc7c6fd28508898af2
Author: Harald Freudenberger <freude@linux.ibm.com>
Date:   Tue Jun 11 11:16:56 2019 +0200

    s390/zcrypt: move cca misc functions to new code file
    
    Rework of the pkey code. Moved all the cca generic code
    away from pkey_api.c into a new file zcrypt_ccamisc.c.
    This new file is now part of the zcrypt device driver
    and exports a bunch of cca functions to pkey and may
    be called from other kernel modules as well.
    
    The pkey ioctl API is unchanged.
    
    Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
    Reviewed-by: Ingo Franzki <ifranzki@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/drivers/s390/crypto/zcrypt_ccamisc.h b/drivers/s390/crypto/zcrypt_ccamisc.h
new file mode 100644
index 000000000000..417427462493
--- /dev/null
+++ b/drivers/s390/crypto/zcrypt_ccamisc.h
@@ -0,0 +1,95 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ *  Copyright IBM Corp. 2019
+ *  Author(s): Harald Freudenberger <freude@linux.ibm.com>
+ *	       Ingo Franzki <ifranzki@linux.ibm.com>
+ *
+ *  Collection of CCA misc functions used by zcrypt and pkey
+ */
+
+#ifndef _ZCRYPT_CCAMISC_H_
+#define _ZCRYPT_CCAMISC_H_
+
+#include <asm/zcrypt.h>
+#include <asm/pkey.h>
+
+/* Key token types */
+#define TOKTYPE_NON_CCA		0x00 /* Non-CCA key token */
+#define TOKTYPE_CCA_INTERNAL	0x01 /* CCA internal key token */
+
+/* For TOKTYPE_NON_CCA: */
+#define TOKVER_PROTECTED_KEY	0x01 /* Protected key token */
+
+/* For TOKTYPE_CCA_INTERNAL: */
+#define TOKVER_CCA_AES		0x04 /* CCA AES key token */
+
+/* header part of a CCA key token */
+struct keytoken_header {
+	u8  type;     /* one of the TOKTYPE values */
+	u8  res0[3];
+	u8  version;  /* one of the TOKVER values */
+	u8  res1[3];
+} __packed;
+
+/* inside view of a CCA secure key token (only type 0x01 version 0x04) */
+struct secaeskeytoken {
+	u8  type;     /* 0x01 for internal key token */
+	u8  res0[3];
+	u8  version;  /* should be 0x04 */
+	u8  res1[1];
+	u8  flag;     /* key flags */
+	u8  res2[1];
+	u64 mkvp;     /* master key verification pattern */
+	u8  key[32];  /* key value (encrypted) */
+	u8  cv[8];    /* control vector */
+	u16 bitsize;  /* key bit size */
+	u16 keysize;  /* key byte size */
+	u8  tvv[4];   /* token validation value */
+} __packed;
+
+/*
+ * Simple check if the token is a valid CCA secure AES data key
+ * token. If keybitsize is given, the bitsize of the key is
+ * also checked. Returns 0 on success or errno value on failure.
+ */
+int cca_check_secaeskeytoken(debug_info_t *dbg, int dbflvl,
+			     const u8 *token, int keybitsize);
+
+/*
+ * Generate (random) CCA AES DATA secure key.
+ */
+int cca_genseckey(u16 cardnr, u16 domain, u32 keytype, u8 *seckey);
+
+/*
+ * Generate CCA AES DATA secure key with given clear key value.
+ */
+int cca_clr2seckey(u16 cardnr, u16 domain, u32 keytype,
+		   const u8 *clrkey, u8 *seckey);
+
+/*
+ * Derive proteced key from an CCA AES DATA secure key.
+ */
+int cca_sec2protkey(u16 cardnr, u16 domain,
+		    const u8 seckey[SECKEYBLOBSIZE],
+		    u8 *protkey, u32 *protkeylen,
+		    u32 *protkeytype);
+
+/*
+ * Query cryptographic facility from CCA adapter
+ */
+int cca_query_crypto_facility(u16 cardnr, u16 domain,
+			      const char *keyword,
+			      u8 *rarray, size_t *rarraylen,
+			      u8 *varray, size_t *varraylen);
+
+/*
+ * Search for a matching crypto card based on the Master Key
+ * Verification Pattern provided inside a secure key.
+ * Returns < 0 on failure, 0 if CURRENT MKVP matches and
+ * 1 if OLD MKVP matches.
+ */
+int cca_findcard(const u8 *seckey, u16 *pcardnr, u16 *pdomain, int verify);
+
+void zcrypt_ccamisc_exit(void);
+
+#endif /* _ZCRYPT_CCAMISC_H_ */
