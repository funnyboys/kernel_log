commit cf2957f3907e44ca40392ac19a0c22a14e3fdc18
Author: Harald Freudenberger <freude@linux.ibm.com>
Date:   Fri Aug 16 11:05:58 2019 +0200

    s390/zcrypt: CEX7S exploitation support
    
    This patch adds CEX7 exploitation support for the AP bus code,
    the zcrypt device driver zoo and the vfio device driver.
    
    Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
    Reviewed-by: Ingo Franzki <ifranzki@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/drivers/s390/crypto/vfio_ap_drv.c b/drivers/s390/crypto/vfio_ap_drv.c
index 003662aa8060..be2520cc010b 100644
--- a/drivers/s390/crypto/vfio_ap_drv.c
+++ b/drivers/s390/crypto/vfio_ap_drv.c
@@ -36,6 +36,8 @@ static struct ap_device_id ap_queue_ids[] = {
 	  .match_flags = AP_DEVICE_ID_MATCH_QUEUE_TYPE },
 	{ .dev_type = AP_DEVICE_TYPE_CEX6,
 	  .match_flags = AP_DEVICE_ID_MATCH_QUEUE_TYPE },
+	{ .dev_type = AP_DEVICE_TYPE_CEX7,
+	  .match_flags = AP_DEVICE_ID_MATCH_QUEUE_TYPE },
 	{ /* end of sibling */ },
 };
 

commit ec89b55e3bce7c8a4bc6b1203280e81342d6745c
Author: Pierre Morel <pmorel@linux.ibm.com>
Date:   Tue May 21 17:34:36 2019 +0200

    s390: ap: implement PAPQ AQIC interception in kernel
    
    We register a AP PQAP instruction hook during the open
    of the mediated device. And unregister it on release.
    
    During the probe of the AP device, we allocate a vfio_ap_queue
    structure to keep track of the information we need for the
    PQAP/AQIC instruction interception.
    
    In the AP PQAP instruction hook, if we receive a demand to
    enable IRQs,
    - we retrieve the vfio_ap_queue based on the APQN we receive
      in REG1,
    - we retrieve the page of the guest address, (NIB), from
      register REG2
    - we retrieve the mediated device to use the VFIO pinning
      infrastructure to pin the page of the guest address,
    - we retrieve the pointer to KVM to register the guest ISC
      and retrieve the host ISC
    - finaly we activate GISA
    
    If we receive a demand to disable IRQs,
    - we deactivate GISA
    - unregister from the GIB
    - unpin the NIB
    
    When removing the AP device from the driver the device is
    reseted and this process unregisters the GISA from the GIB,
    and unpins the NIB address then we free the vfio_ap_queue
    structure.
    
    Signed-off-by: Pierre Morel <pmorel@linux.ibm.com>
    Acked-by: Tony Krowiak <akrowiak@linux.ibm.com>
    Acked-by: Harald Freudenberger <freude@linux.ibm.com>
    Signed-off-by: Halil Pasic <pasic@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/drivers/s390/crypto/vfio_ap_drv.c b/drivers/s390/crypto/vfio_ap_drv.c
index e9824c35c34f..003662aa8060 100644
--- a/drivers/s390/crypto/vfio_ap_drv.c
+++ b/drivers/s390/crypto/vfio_ap_drv.c
@@ -5,6 +5,7 @@
  * Copyright IBM Corp. 2018
  *
  * Author(s): Tony Krowiak <akrowiak@linux.ibm.com>
+ *	      Pierre Morel <pmorel@linux.ibm.com>
  */
 
 #include <linux/module.h>
@@ -40,14 +41,45 @@ static struct ap_device_id ap_queue_ids[] = {
 
 MODULE_DEVICE_TABLE(vfio_ap, ap_queue_ids);
 
+/**
+ * vfio_ap_queue_dev_probe:
+ *
+ * Allocate a vfio_ap_queue structure and associate it
+ * with the device as driver_data.
+ */
 static int vfio_ap_queue_dev_probe(struct ap_device *apdev)
 {
+	struct vfio_ap_queue *q;
+
+	q = kzalloc(sizeof(*q), GFP_KERNEL);
+	if (!q)
+		return -ENOMEM;
+	dev_set_drvdata(&apdev->device, q);
+	q->apqn = to_ap_queue(&apdev->device)->qid;
+	q->saved_isc = VFIO_AP_ISC_INVALID;
 	return 0;
 }
 
+/**
+ * vfio_ap_queue_dev_remove:
+ *
+ * Takes the matrix lock to avoid actions on this device while removing
+ * Free the associated vfio_ap_queue structure
+ */
 static void vfio_ap_queue_dev_remove(struct ap_device *apdev)
 {
-	/* Nothing to do yet */
+	struct vfio_ap_queue *q;
+	int apid, apqi;
+
+	mutex_lock(&matrix_dev->lock);
+	q = dev_get_drvdata(&apdev->device);
+	dev_set_drvdata(&apdev->device, NULL);
+	apid = AP_QID_CARD(q->apqn);
+	apqi = AP_QID_QUEUE(q->apqn);
+	vfio_ap_mdev_reset_queue(apid, apqi, 1);
+	vfio_ap_irq_disable(q);
+	kfree(q);
+	mutex_unlock(&matrix_dev->lock);
 }
 
 static void vfio_ap_matrix_dev_release(struct device *dev)

commit 36360658eb5a6cf04bb9f2704d1e4ce54037ec99
Author: Pierre Morel <pmorel@linux.ibm.com>
Date:   Tue Feb 12 16:53:45 2019 +0100

    s390: vfio_ap: link the vfio_ap devices to the vfio_ap bus subsystem
    
    Libudev relies on having a subsystem link for non-root devices. To
    avoid libudev (and potentially other userspace tools) choking on the
    matrix device let us introduce a matrix bus and with it the matrix
    bus subsytem. Also make the matrix device reside within the matrix
    bus.
    
    Doing this we remove the forced link from the matrix device to the
    vfio_ap driver and the device_type we do not need anymore.
    
    Since the associated matrix driver is not the vfio_ap driver any more,
    we have to change the search for the devices on the vfio_ap driver in
    the function vfio_ap_verify_queue_reserved.
    Fixes: 1fde573413b5 ("s390: vfio-ap: base implementation of VFIO AP device driver")
    Cc: stable@vger.kernel.org
    
    Reported-by: Marc Hartmayer <mhartmay@linux.ibm.com>
    Reported-by: Christian Borntraeger <borntraeger@de.ibm.com>
    Signed-off-by: Pierre Morel <pmorel@linux.ibm.com>
    Tested-by: Christian Borntraeger <borntraeger@de.ibm.com>
    Reviewed-by: Cornelia Huck <cohuck@redhat.com>
    Reviewed-by: Tony Krowiak <akrowiak@linux.ibm.com>
    Acked-by: Halil Pasic <pasic@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/vfio_ap_drv.c b/drivers/s390/crypto/vfio_ap_drv.c
index 31c6c847eaca..e9824c35c34f 100644
--- a/drivers/s390/crypto/vfio_ap_drv.c
+++ b/drivers/s390/crypto/vfio_ap_drv.c
@@ -15,7 +15,6 @@
 #include "vfio_ap_private.h"
 
 #define VFIO_AP_ROOT_NAME "vfio_ap"
-#define VFIO_AP_DEV_TYPE_NAME "ap_matrix"
 #define VFIO_AP_DEV_NAME "matrix"
 
 MODULE_AUTHOR("IBM Corporation");
@@ -24,10 +23,6 @@ MODULE_LICENSE("GPL v2");
 
 static struct ap_driver vfio_ap_drv;
 
-static struct device_type vfio_ap_dev_type = {
-	.name = VFIO_AP_DEV_TYPE_NAME,
-};
-
 struct ap_matrix_dev *matrix_dev;
 
 /* Only type 10 adapters (CEX4 and later) are supported
@@ -62,6 +57,22 @@ static void vfio_ap_matrix_dev_release(struct device *dev)
 	kfree(matrix_dev);
 }
 
+static int matrix_bus_match(struct device *dev, struct device_driver *drv)
+{
+	return 1;
+}
+
+static struct bus_type matrix_bus = {
+	.name = "matrix",
+	.match = &matrix_bus_match,
+};
+
+static struct device_driver matrix_driver = {
+	.name = "vfio_ap",
+	.bus = &matrix_bus,
+	.suppress_bind_attrs = true,
+};
+
 static int vfio_ap_matrix_dev_create(void)
 {
 	int ret;
@@ -71,6 +82,10 @@ static int vfio_ap_matrix_dev_create(void)
 	if (IS_ERR(root_device))
 		return PTR_ERR(root_device);
 
+	ret = bus_register(&matrix_bus);
+	if (ret)
+		goto bus_register_err;
+
 	matrix_dev = kzalloc(sizeof(*matrix_dev), GFP_KERNEL);
 	if (!matrix_dev) {
 		ret = -ENOMEM;
@@ -87,30 +102,41 @@ static int vfio_ap_matrix_dev_create(void)
 	mutex_init(&matrix_dev->lock);
 	INIT_LIST_HEAD(&matrix_dev->mdev_list);
 
-	matrix_dev->device.type = &vfio_ap_dev_type;
 	dev_set_name(&matrix_dev->device, "%s", VFIO_AP_DEV_NAME);
 	matrix_dev->device.parent = root_device;
+	matrix_dev->device.bus = &matrix_bus;
 	matrix_dev->device.release = vfio_ap_matrix_dev_release;
-	matrix_dev->device.driver = &vfio_ap_drv.driver;
+	matrix_dev->vfio_ap_drv = &vfio_ap_drv;
 
 	ret = device_register(&matrix_dev->device);
 	if (ret)
 		goto matrix_reg_err;
 
+	ret = driver_register(&matrix_driver);
+	if (ret)
+		goto matrix_drv_err;
+
 	return 0;
 
+matrix_drv_err:
+	device_unregister(&matrix_dev->device);
 matrix_reg_err:
 	put_device(&matrix_dev->device);
 matrix_alloc_err:
+	bus_unregister(&matrix_bus);
+bus_register_err:
 	root_device_unregister(root_device);
-
 	return ret;
 }
 
 static void vfio_ap_matrix_dev_destroy(void)
 {
+	struct device *root_device = matrix_dev->device.parent;
+
+	driver_unregister(&matrix_driver);
 	device_unregister(&matrix_dev->device);
-	root_device_unregister(matrix_dev->device.parent);
+	bus_unregister(&matrix_bus);
+	root_device_unregister(root_device);
 }
 
 static int __init vfio_ap_init(void)

commit e45a64975b021b6fc9fdd0dd0b74539ae1b5aa86
Author: Petr Tesarik <ptesarik@suse.com>
Date:   Fri Nov 16 11:47:48 2018 +0100

    s390: vfio-ap: include <asm/facility> for test_facility()
    
    The driver uses test_facility(), but does not include the
    corresponding include file explicitly. The driver currently builds
    only thanks to the following include chain:
    
      vfio_ap_drv.c
        <linux/module.h>
          <linux/elf.h>
            <asm/elf.h>
              <linux/compat.h>
                <asm/uaccess.h>
                  <asm/facility.h>
    
    Files should not rely on such fragile implicit includes.
    
    Signed-off-by: Petr Tesarik <ptesarik@suse.com>
    Reviewed-by: Cornelia Huck <cohuck@redhat.com>
    Acked-by: Christian Borntraeger <borntraeger@de.ibm.com>
    Signed-off-by: Halil Pasic <pasic@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/vfio_ap_drv.c b/drivers/s390/crypto/vfio_ap_drv.c
index 7667b38728f0..31c6c847eaca 100644
--- a/drivers/s390/crypto/vfio_ap_drv.c
+++ b/drivers/s390/crypto/vfio_ap_drv.c
@@ -11,6 +11,7 @@
 #include <linux/mod_devicetable.h>
 #include <linux/slab.h>
 #include <linux/string.h>
+#include <asm/facility.h>
 #include "vfio_ap_private.h"
 
 #define VFIO_AP_ROOT_NAME "vfio_ap"

commit 46623ab3194a3f37ea12da2964bca3b35fdd20ed
Author: Christian Borntraeger <borntraeger@de.ibm.com>
Date:   Fri Oct 5 19:22:38 2018 +0200

    s390: vfio-ap: make local functions and data static
    
    no functional change, just hygiene.
    
    Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
    Reviewed-by: Cornelia Huck <cohuck@redhat.com>
    Reviewed-by: David Hildenbrand <david@redhat.com>

diff --git a/drivers/s390/crypto/vfio_ap_drv.c b/drivers/s390/crypto/vfio_ap_drv.c
index 8b51821d9bf7..7667b38728f0 100644
--- a/drivers/s390/crypto/vfio_ap_drv.c
+++ b/drivers/s390/crypto/vfio_ap_drv.c
@@ -112,7 +112,7 @@ static void vfio_ap_matrix_dev_destroy(void)
 	root_device_unregister(matrix_dev->device.parent);
 }
 
-int __init vfio_ap_init(void)
+static int __init vfio_ap_init(void)
 {
 	int ret;
 
@@ -146,7 +146,7 @@ int __init vfio_ap_init(void)
 	return 0;
 }
 
-void __exit vfio_ap_exit(void)
+static void __exit vfio_ap_exit(void)
 {
 	vfio_ap_mdev_unregister();
 	ap_driver_unregister(&vfio_ap_drv);

commit 65f06713d3fa0e4125f59ad5b9d6239109b1d7fc
Author: Tony Krowiak <akrowiak@linux.ibm.com>
Date:   Tue Sep 25 19:16:20 2018 -0400

    s390: vfio-ap: register matrix device with VFIO mdev framework
    
    Registers the matrix device created by the VFIO AP device
    driver with the VFIO mediated device framework.
    Registering the matrix device will create the sysfs
    structures needed to create mediated matrix devices
    each of which will be used to configure the AP matrix
    for a guest and connect it to the VFIO AP device driver.
    
    Registering the matrix device with the VFIO mediated device
    framework will create the following sysfs structures:
    
    /sys/devices/vfio_ap/matrix/
    ...... [mdev_supported_types]
    ......... [vfio_ap-passthrough]
    ............ create
    
    To create a mediated device for the AP matrix device, write a UUID
    to the create file:
    
            uuidgen > create
    
    A symbolic link to the mediated device's directory will be created in the
    devices subdirectory named after the generated $uuid:
    
    /sys/devices/vfio_ap/matrix/
    ...... [mdev_supported_types]
    ......... [vfio_ap-passthrough]
    ............ [devices]
    ............... [$uuid]
    
    A symbolic link to the mediated device will also be created
    in the vfio_ap matrix's directory:
    
    /sys/devices/vfio_ap/matrix/[$uuid]
    
    Signed-off-by: Tony Krowiak <akrowiak@linux.ibm.com>
    Reviewed-by: Halil Pasic <pasic@linux.ibm.com>
    Reviewed-by: Cornelia Huck <cohuck@redhat.com>
    Tested-by: Michael Mueller <mimu@linux.ibm.com>
    Tested-by: Farhan Ali <alifm@linux.ibm.com>
    Message-Id: <20180925231641.4954-6-akrowiak@linux.vnet.ibm.com>
    Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>

diff --git a/drivers/s390/crypto/vfio_ap_drv.c b/drivers/s390/crypto/vfio_ap_drv.c
index ea2ae03c896e..8b51821d9bf7 100644
--- a/drivers/s390/crypto/vfio_ap_drv.c
+++ b/drivers/s390/crypto/vfio_ap_drv.c
@@ -76,6 +76,16 @@ static int vfio_ap_matrix_dev_create(void)
 		goto matrix_alloc_err;
 	}
 
+	/* Fill in config info via PQAP(QCI), if available */
+	if (test_facility(12)) {
+		ret = ap_qci(&matrix_dev->info);
+		if (ret)
+			goto matrix_alloc_err;
+	}
+
+	mutex_init(&matrix_dev->lock);
+	INIT_LIST_HEAD(&matrix_dev->mdev_list);
+
 	matrix_dev->device.type = &vfio_ap_dev_type;
 	dev_set_name(&matrix_dev->device, "%s", VFIO_AP_DEV_NAME);
 	matrix_dev->device.parent = root_device;
@@ -125,11 +135,20 @@ int __init vfio_ap_init(void)
 		return ret;
 	}
 
+	ret = vfio_ap_mdev_register();
+	if (ret) {
+		ap_driver_unregister(&vfio_ap_drv);
+		vfio_ap_matrix_dev_destroy();
+
+		return ret;
+	}
+
 	return 0;
 }
 
 void __exit vfio_ap_exit(void)
 {
+	vfio_ap_mdev_unregister();
 	ap_driver_unregister(&vfio_ap_drv);
 	vfio_ap_matrix_dev_destroy();
 }

commit 1fde573413b549d52183382e639c1d6ce88f5959
Author: Tony Krowiak <akrowiak@linux.ibm.com>
Date:   Tue Sep 25 19:16:19 2018 -0400

    s390: vfio-ap: base implementation of VFIO AP device driver
    
    Introduces a new AP device driver. This device driver
    is built on the VFIO mediated device framework. The framework
    provides sysfs interfaces that facilitate passthrough
    access by guests to devices installed on the linux host.
    
    The VFIO AP device driver will serve two purposes:
    
    1. Provide the interfaces to reserve AP devices for exclusive
       use by KVM guests. This is accomplished by unbinding the
       devices to be reserved for guest usage from the zcrypt
       device driver and binding them to the VFIO AP device driver.
    
    2. Implements the functions, callbacks and sysfs attribute
       interfaces required to create one or more VFIO mediated
       devices each of which will be used to configure the AP
       matrix for a guest and serve as a file descriptor
       for facilitating communication between QEMU and the
       VFIO AP device driver.
    
    When the VFIO AP device driver is initialized:
    
    * It registers with the AP bus for control of type 10 (CEX4
      and newer) AP queue devices. This limitation was imposed
      due to:
    
      1. A desire to keep the code as simple as possible;
    
      2. Some older models are no longer supported by the kernel
         and others are getting close to end of service.
    
      3. A lack of older systems on which to test older devices.
    
      The probe and remove callbacks will be provided to support
      the binding/unbinding of AP queue devices to/from the VFIO
      AP device driver.
    
    * Creates a matrix device, /sys/devices/vfio_ap/matrix,
      to serve as the parent of the mediated devices created, one
      for each guest, and to hold the APQNs of the AP devices bound to
      the VFIO AP device driver.
    
    Signed-off-by: Tony Krowiak <akrowiak@linux.ibm.com>
    Reviewed-by: Halil Pasic <pasic@linux.ibm.com>
    Tested-by: Michael Mueller <mimu@linux.ibm.com>
    Tested-by: Farhan Ali <alifm@linux.ibm.com>
    Acked-by: David Hildenbrand <david@redhat.com>
    Reviewed-by: Cornelia Huck <cohuck@redhat.com>
    Message-Id: <20180925231641.4954-5-akrowiak@linux.vnet.ibm.com>
    Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>

diff --git a/drivers/s390/crypto/vfio_ap_drv.c b/drivers/s390/crypto/vfio_ap_drv.c
new file mode 100644
index 000000000000..ea2ae03c896e
--- /dev/null
+++ b/drivers/s390/crypto/vfio_ap_drv.c
@@ -0,0 +1,138 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * VFIO based AP device driver
+ *
+ * Copyright IBM Corp. 2018
+ *
+ * Author(s): Tony Krowiak <akrowiak@linux.ibm.com>
+ */
+
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include "vfio_ap_private.h"
+
+#define VFIO_AP_ROOT_NAME "vfio_ap"
+#define VFIO_AP_DEV_TYPE_NAME "ap_matrix"
+#define VFIO_AP_DEV_NAME "matrix"
+
+MODULE_AUTHOR("IBM Corporation");
+MODULE_DESCRIPTION("VFIO AP device driver, Copyright IBM Corp. 2018");
+MODULE_LICENSE("GPL v2");
+
+static struct ap_driver vfio_ap_drv;
+
+static struct device_type vfio_ap_dev_type = {
+	.name = VFIO_AP_DEV_TYPE_NAME,
+};
+
+struct ap_matrix_dev *matrix_dev;
+
+/* Only type 10 adapters (CEX4 and later) are supported
+ * by the AP matrix device driver
+ */
+static struct ap_device_id ap_queue_ids[] = {
+	{ .dev_type = AP_DEVICE_TYPE_CEX4,
+	  .match_flags = AP_DEVICE_ID_MATCH_QUEUE_TYPE },
+	{ .dev_type = AP_DEVICE_TYPE_CEX5,
+	  .match_flags = AP_DEVICE_ID_MATCH_QUEUE_TYPE },
+	{ .dev_type = AP_DEVICE_TYPE_CEX6,
+	  .match_flags = AP_DEVICE_ID_MATCH_QUEUE_TYPE },
+	{ /* end of sibling */ },
+};
+
+MODULE_DEVICE_TABLE(vfio_ap, ap_queue_ids);
+
+static int vfio_ap_queue_dev_probe(struct ap_device *apdev)
+{
+	return 0;
+}
+
+static void vfio_ap_queue_dev_remove(struct ap_device *apdev)
+{
+	/* Nothing to do yet */
+}
+
+static void vfio_ap_matrix_dev_release(struct device *dev)
+{
+	struct ap_matrix_dev *matrix_dev = dev_get_drvdata(dev);
+
+	kfree(matrix_dev);
+}
+
+static int vfio_ap_matrix_dev_create(void)
+{
+	int ret;
+	struct device *root_device;
+
+	root_device = root_device_register(VFIO_AP_ROOT_NAME);
+	if (IS_ERR(root_device))
+		return PTR_ERR(root_device);
+
+	matrix_dev = kzalloc(sizeof(*matrix_dev), GFP_KERNEL);
+	if (!matrix_dev) {
+		ret = -ENOMEM;
+		goto matrix_alloc_err;
+	}
+
+	matrix_dev->device.type = &vfio_ap_dev_type;
+	dev_set_name(&matrix_dev->device, "%s", VFIO_AP_DEV_NAME);
+	matrix_dev->device.parent = root_device;
+	matrix_dev->device.release = vfio_ap_matrix_dev_release;
+	matrix_dev->device.driver = &vfio_ap_drv.driver;
+
+	ret = device_register(&matrix_dev->device);
+	if (ret)
+		goto matrix_reg_err;
+
+	return 0;
+
+matrix_reg_err:
+	put_device(&matrix_dev->device);
+matrix_alloc_err:
+	root_device_unregister(root_device);
+
+	return ret;
+}
+
+static void vfio_ap_matrix_dev_destroy(void)
+{
+	device_unregister(&matrix_dev->device);
+	root_device_unregister(matrix_dev->device.parent);
+}
+
+int __init vfio_ap_init(void)
+{
+	int ret;
+
+	/* If there are no AP instructions, there is nothing to pass through. */
+	if (!ap_instructions_available())
+		return -ENODEV;
+
+	ret = vfio_ap_matrix_dev_create();
+	if (ret)
+		return ret;
+
+	memset(&vfio_ap_drv, 0, sizeof(vfio_ap_drv));
+	vfio_ap_drv.probe = vfio_ap_queue_dev_probe;
+	vfio_ap_drv.remove = vfio_ap_queue_dev_remove;
+	vfio_ap_drv.ids = ap_queue_ids;
+
+	ret = ap_driver_register(&vfio_ap_drv, THIS_MODULE, VFIO_AP_DRV_NAME);
+	if (ret) {
+		vfio_ap_matrix_dev_destroy();
+		return ret;
+	}
+
+	return 0;
+}
+
+void __exit vfio_ap_exit(void)
+{
+	ap_driver_unregister(&vfio_ap_drv);
+	vfio_ap_matrix_dev_destroy();
+}
+
+module_init(vfio_ap_init);
+module_exit(vfio_ap_exit);
