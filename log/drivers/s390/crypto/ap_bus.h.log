commit bc4b295e87a86bf14333753daeb1c84909197c46
Author: Harald Freudenberger <freude@linux.ibm.com>
Date:   Fri May 8 15:51:19 2020 +0200

    s390/ap: introduce new ap function ap_get_qdev()
    
    Provide a new interface function to be used by the ap drivers:
      struct ap_queue *ap_get_qdev(ap_qid_t qid);
    Returns ptr to the struct ap_queue device or NULL if there
    was no ap_queue device with this qid found. When something is
    found, the reference count of the embedded device is increased.
    So the caller has to decrease the reference count after use
    with a call to put_device(&aq->ap_dev.device).
    
    With this patch also the ap_card_list is removed from the
    ap core code and a new hashtable is introduced which stores
    hnodes of all the ap queues known to the ap bus.
    
    The hashtable approach and a first implementation of this
    interface comes from a previous patch from
    Anthony Krowiak and an idea from Halil Pasic.
    
    Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
    Suggested-by: Tony Krowiak <akrowiak@linux.ibm.com>
    Suggested-by: Halil Pasic <pasic@linux.ibm.com>
    Reviewed-by: Tony Krowiak <akrowiak@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 8e8e37b6c0ee..053cc34d2ca2 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -15,6 +15,7 @@
 
 #include <linux/device.h>
 #include <linux/types.h>
+#include <linux/hashtable.h>
 #include <asm/isc.h>
 #include <asm/ap.h>
 
@@ -27,8 +28,8 @@
 
 extern int ap_domain_index;
 
-extern spinlock_t ap_list_lock;
-extern struct list_head ap_card_list;
+extern DECLARE_HASHTABLE(ap_queues, 8);
+extern spinlock_t ap_queues_lock;
 
 static inline int ap_test_bit(unsigned int *ptr, unsigned int nr)
 {
@@ -152,8 +153,6 @@ struct ap_device {
 
 struct ap_card {
 	struct ap_device ap_dev;
-	struct list_head list;		/* Private list of AP cards. */
-	struct list_head queues;	/* List of assoc. AP queues */
 	void *private;			/* ap driver private pointer. */
 	int raw_hwtype;			/* AP raw hardware type. */
 	unsigned int functions;		/* AP device function bitfield. */
@@ -166,7 +165,7 @@ struct ap_card {
 
 struct ap_queue {
 	struct ap_device ap_dev;
-	struct list_head list;		/* Private list of AP queues. */
+	struct hlist_node hnode;	/* Node for the ap_queues hashtable */
 	struct ap_card *card;		/* Ptr to assoc. AP card. */
 	spinlock_t lock;		/* Per device lock. */
 	void *private;			/* ap driver private pointer. */
@@ -223,12 +222,6 @@ static inline void ap_release_message(struct ap_message *ap_msg)
 	kzfree(ap_msg->private);
 }
 
-#define for_each_ap_card(_ac) \
-	list_for_each_entry(_ac, &ap_card_list, list)
-
-#define for_each_ap_queue(_aq, _ac) \
-	list_for_each_entry(_aq, &(_ac)->queues, list)
-
 /*
  * Note: don't use ap_send/ap_recv after using ap_queue_message
  * for the first time. Otherwise the ap message queue will get
@@ -269,6 +262,16 @@ struct ap_perms {
 extern struct ap_perms ap_perms;
 extern struct mutex ap_perms_mutex;
 
+/*
+ * Get ap_queue device for this qid.
+ * Returns ptr to the struct ap_queue device or NULL if there
+ * was no ap_queue device with this qid found. When something is
+ * found, the reference count of the embedded device is increased.
+ * So the caller has to decrease the reference count after use
+ * with a call to put_device(&aq->ap_dev.device).
+ */
+struct ap_queue *ap_get_qdev(ap_qid_t qid);
+
 /*
  * check APQN for owned/reserved by ap bus and default driver(s).
  * Checks if this APQN is or will be in use by the ap bus

commit 41677b1d9415f5512acf262c55bd48f71319ce29
Author: Harald Freudenberger <freude@linux.ibm.com>
Date:   Tue Mar 24 17:30:39 2020 +0100

    s390/ap: remove power management code from ap bus and drivers
    
    The s390 power management support has been removed. So the
    api registration and the suspend and resume callbacks and
    all the code related to this for the ap bus and the ap drivers
    is removed with this patch.
    
    Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
    Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 4348fdff1c61..8e8e37b6c0ee 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -91,7 +91,6 @@ enum ap_state {
 	AP_STATE_IDLE,
 	AP_STATE_WORKING,
 	AP_STATE_QUEUE_FULL,
-	AP_STATE_SUSPEND_WAIT,
 	AP_STATE_REMOVE,	/* about to be removed from driver */
 	AP_STATE_UNBOUND,	/* momentary not bound to a driver */
 	AP_STATE_BORKED,	/* broken */
@@ -136,8 +135,6 @@ struct ap_driver {
 
 	int (*probe)(struct ap_device *);
 	void (*remove)(struct ap_device *);
-	void (*suspend)(struct ap_device *);
-	void (*resume)(struct ap_device *);
 };
 
 #define to_ap_drv(x) container_of((x), struct ap_driver, driver)
@@ -259,8 +256,6 @@ void ap_queue_init_reply(struct ap_queue *aq, struct ap_message *ap_msg);
 struct ap_queue *ap_queue_create(ap_qid_t qid, int device_type);
 void ap_queue_prepare_remove(struct ap_queue *aq);
 void ap_queue_remove(struct ap_queue *aq);
-void ap_queue_suspend(struct ap_device *ap_dev);
-void ap_queue_resume(struct ap_device *ap_dev);
 void ap_queue_init_state(struct ap_queue *aq);
 
 struct ap_card *ap_card_create(int id, int queue_depth, int raw_device_type,

commit fcd98d4002539f1e381916fc1b6648938c1eac76
Author: Harald Freudenberger <freude@linux.ibm.com>
Date:   Fri Dec 20 16:02:54 2019 +0100

    s390/zcrypt: fix card and queue total counter wrap
    
    The internal statistic counters for the total number of
    requests processed per card and per queue used integers. So they do
    wrap after a rather huge amount of crypto requests processed. This
    patch introduces uint64 counters which should hold much longer but
    still may wrap. The sysfs attributes request_count for card and queue
    also used only %ld and now display the counter value with %llu.
    
    This is not a security relevant fix. The int overflow which happened
    is not in any way exploitable as a security breach.
    
    Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index bb35ba4a8d24..4348fdff1c61 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -162,7 +162,7 @@ struct ap_card {
 	unsigned int functions;		/* AP device function bitfield. */
 	int queue_depth;		/* AP queue depth.*/
 	int id;				/* AP card number. */
-	atomic_t total_request_count;	/* # requests ever for this AP device.*/
+	atomic64_t total_request_count;	/* # requests ever for this AP device.*/
 };
 
 #define to_ap_card(x) container_of((x), struct ap_card, ap_dev.device)
@@ -179,7 +179,7 @@ struct ap_queue {
 	enum ap_state state;		/* State of the AP device. */
 	int pendingq_count;		/* # requests on pendingq list. */
 	int requestq_count;		/* # requests on requestq list. */
-	int total_request_count;	/* # requests ever for this AP device.*/
+	u64 total_request_count;	/* # requests ever for this AP device.*/
 	int request_timeout;		/* Request timeout in jiffies. */
 	struct timer_list timeout;	/* Timer for request timeouts. */
 	struct list_head pendingq;	/* List of message sent to AP queue. */

commit 0c874cd04292c7ee22d70eefc341fa2648f41f46
Author: Harald Freudenberger <freude@linux.ibm.com>
Date:   Fri Nov 22 16:30:06 2019 +0100

    s390/zcrypt: move ap device reset from bus to driver code
    
    This patch moves the reset invocation of an ap device when
    fresh detected from the ap bus to the probe() function of
    the driver responsible for this device.
    
    The virtualisation of ap devices makes it necessary to
    remove unconditioned resets on fresh appearing apqn devices.
    It may be that such a device is already enabled for guest
    usage. So there may be a race condition between host ap bus
    and guest ap bus doing the reset. This patch moves the
    reset from the ap bus to the zcrypt drivers. So if there
    is no zcrypt driver bound to an ap device - for example
    the ap device is bound to the vfio device driver - the
    ap device is untouched passed to the vfio device driver.
    
    Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 433b7b64368d..bb35ba4a8d24 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -261,7 +261,7 @@ void ap_queue_prepare_remove(struct ap_queue *aq);
 void ap_queue_remove(struct ap_queue *aq);
 void ap_queue_suspend(struct ap_device *ap_dev);
 void ap_queue_resume(struct ap_device *ap_dev);
-void ap_queue_reinit_state(struct ap_queue *aq);
+void ap_queue_init_state(struct ap_queue *aq);
 
 struct ap_card *ap_card_create(int id, int queue_depth, int raw_device_type,
 			       int comp_device_type, unsigned int functions);

commit cf2957f3907e44ca40392ac19a0c22a14e3fdc18
Author: Harald Freudenberger <freude@linux.ibm.com>
Date:   Fri Aug 16 11:05:58 2019 +0200

    s390/zcrypt: CEX7S exploitation support
    
    This patch adds CEX7 exploitation support for the AP bus code,
    the zcrypt device driver zoo and the vfio device driver.
    
    Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
    Reviewed-by: Ingo Franzki <ifranzki@linux.ibm.com>
    Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 6f3cf37776ca..433b7b64368d 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0+ */
 /*
- * Copyright IBM Corp. 2006, 2012
+ * Copyright IBM Corp. 2006, 2019
  * Author(s): Cornelia Huck <cornelia.huck@de.ibm.com>
  *	      Martin Schwidefsky <schwidefsky@de.ibm.com>
  *	      Ralph Wuerthner <rwuerthn@de.ibm.com>
@@ -63,6 +63,7 @@ static inline int ap_test_bit(unsigned int *ptr, unsigned int nr)
 #define AP_DEVICE_TYPE_CEX4	10
 #define AP_DEVICE_TYPE_CEX5	11
 #define AP_DEVICE_TYPE_CEX6	12
+#define AP_DEVICE_TYPE_CEX7	13
 
 /*
  * Known function facilities

commit 7379e652797c0b9b5f6caea1576f2dff9ce6a708
Author: Harald Freudenberger <freude@linux.ibm.com>
Date:   Tue May 21 13:50:09 2019 +0200

    s390/zcrypt: Fix wrong dispatching for control domain CPRBs
    
    The zcrypt device driver does not handle CPRBs which address
    a control domain correctly. This fix introduces a workaround:
    The domain field of the request CPRB is checked if there is
    a valid domain value in there. If this is true and the value
    is a control only domain (a domain which is enabled in the
    crypto config ADM mask but disabled in the AQM mask) the
    CPRB is forwarded to the default usage domain. If there is
    no default domain, the request is rejected with an ENODEV.
    
    This fix is important for maintaining crypto adapters. For
    example one LPAR can use a crypto adapter domain ('Control
    and Usage') but another LPAR needs to be able to maintain
    this adapter domain ('Control'). Scenarios like this did
    not work properly and the patch enables this.
    
    Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 15a98a673c5c..6f3cf37776ca 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -251,6 +251,9 @@ void ap_wait(enum ap_wait wait);
 void ap_request_timeout(struct timer_list *t);
 void ap_bus_force_rescan(void);
 
+int ap_test_config_usage_domain(unsigned int domain);
+int ap_test_config_ctrl_domain(unsigned int domain);
+
 void ap_queue_init_reply(struct ap_queue *aq, struct ap_message *ap_msg);
 struct ap_queue *ap_queue_create(ap_qid_t qid, int device_type);
 void ap_queue_prepare_remove(struct ap_queue *aq);

commit 01396a374c3d31bc5f8b693026cfa9a657319624
Author: Harald Freudenberger <freude@linux.ibm.com>
Date:   Fri Feb 22 17:24:11 2019 +0100

    s390/zcrypt: revisit ap device remove procedure
    
    Working with the vfio-ap driver let to some revisit of the way
    how an ap (queue) device is removed from the driver.
    With the current implementation all the cleanup was done before
    the driver even got notified about the removal. Now the ap
    queue removal is done in 3 steps:
    1) A preparation step, all ap messages within the queue
       are flushed and so the driver does 'receive' them.
       Also a new state AP_STATE_REMOVE assigned to the queue
       makes sure there are no new messages queued in.
    2) Now the driver's remove function is invoked and the
       driver should do the job of cleaning up it's internal
       administration lists or whatever. After 2) is done
       it is guaranteed, that the driver is not invoked any
       more. On the other hand the driver has to make sure
       that the APQN is not accessed any more after step 2
       is complete.
    3) Now the ap bus code does the job of total cleanup of the
       APQN. A reset with zero is triggered and the state of
       the queue goes to AP_STATE_UNBOUND.
       After step 3) is complete, the ap queue has no pending
       messages and the APQN is cleared and so there are no
       requests and replies lingering around in the firmware
       queue for this APQN. Also the interrupts are disabled.
    
    After these remove steps the ap queue device may be assigned
    to another driver.
    
    Stress testing this remove/probe procedure showed a problem with the
    correct module reference counting. The actual receive of an reply in
    the driver is done asynchronous with completions. So with a driver
    change on an ap queue the message flush triggers completions but the
    threads waiting for the completions may run at a time where the queue
    already has the new driver assigned. So the module_put() at receive
    time needs to be done on the driver module which queued the ap
    message. This change is also part of this patch.
    
    Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
    Reviewed-by: Ingo Franzki <ifranzki@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index d0059eae5d94..15a98a673c5c 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -91,6 +91,7 @@ enum ap_state {
 	AP_STATE_WORKING,
 	AP_STATE_QUEUE_FULL,
 	AP_STATE_SUSPEND_WAIT,
+	AP_STATE_REMOVE,	/* about to be removed from driver */
 	AP_STATE_UNBOUND,	/* momentary not bound to a driver */
 	AP_STATE_BORKED,	/* broken */
 	NR_AP_STATES
@@ -252,6 +253,7 @@ void ap_bus_force_rescan(void);
 
 void ap_queue_init_reply(struct ap_queue *aq, struct ap_message *ap_msg);
 struct ap_queue *ap_queue_create(ap_qid_t qid, int device_type);
+void ap_queue_prepare_remove(struct ap_queue *aq);
 void ap_queue_remove(struct ap_queue *aq);
 void ap_queue_suspend(struct ap_device *ap_dev);
 void ap_queue_resume(struct ap_device *ap_dev);

commit b1af7528d27e450a1a4492678454b15177398a26
Author: Harald Freudenberger <freude@linux.ibm.com>
Date:   Tue Feb 5 17:22:36 2019 +0100

    s390/zcrypt: use new state UNBOUND during queue driver rebind
    
    When an alternate driver (vfio-ap) has bound an ap queue and this
    binding is revised the ap queue device is in an intermittent
    state not bound to any driver. The internal state variable
    covered this with the state AP_STATE_BORKED which is also used to
    reflect broken devices. When now an ap bus scan runs such a
    device is destroyed and on the next scan reconstructed.
    
    So a stress test with high frequency switching the queue driver
    between the default and the vfio-ap driver hit this gap and the
    queue was removed until the next ap bus scan. This fix now
    introduces another state for the in-between condition for a queue
    momentary not bound to a driver and so the ap bus scan function
    skips this device instead of removing it.
    
    Also some very slight but maybe helpful debug feature messages
    come with this patch - in particular a message showing that a
    broken card/queue device will get removed.
    
    Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
    Reviewed-by: Ingo Franzki <ifranzki@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index bfc66e4a9de1..d0059eae5d94 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -91,7 +91,8 @@ enum ap_state {
 	AP_STATE_WORKING,
 	AP_STATE_QUEUE_FULL,
 	AP_STATE_SUSPEND_WAIT,
-	AP_STATE_BORKED,
+	AP_STATE_UNBOUND,	/* momentary not bound to a driver */
+	AP_STATE_BORKED,	/* broken */
 	NR_AP_STATES
 };
 

commit 104f708fd1241b22f808bdf066ab67dc5a051de5
Author: Harald Freudenberger <freude@linux.ibm.com>
Date:   Fri Nov 9 14:59:24 2018 +0100

    s390/zcrypt: reinit ap queue state machine during device probe
    
    Until the vfio-ap driver came into live there was a well known
    agreement about the way how ap devices are initialized and their
    states when the driver's probe function is called.
    
    However, the vfio device driver when receiving an ap queue device does
    additional resets thereby removing the registration for interrupts for
    the ap device done by the ap bus core code. So when later the vfio
    driver releases the device and one of the default zcrypt drivers takes
    care of the device the interrupt registration needs to get
    renewed. The current code does no renew and result is that requests
    send into such a queue will never see a reply processed - the
    application hangs.
    
    This patch adds a function which resets the aq queue state machine for
    the ap queue device and triggers the walk through the initial states
    (which are reset and registration for interrupts). This function is
    now called before the driver's probe function is invoked.
    
    When the association between driver and device is released, the
    driver's remove function is called. The current implementation calls a
    ap queue function ap_queue_remove(). This invokation has been moved to
    the ap bus function to make the probe / remove pair for ap bus and
    drivers more symmetric.
    
    Fixes: 7e0bdbe5c21c ("s390/zcrypt: AP bus support for alternate driver(s)")
    Cc: stable@vger.kernel.org # 4.19+
    Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
    Reviewd-by: Tony Krowiak <akrowiak@linux.ibm.com>
    Reviewd-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 3eed1b36c876..bfc66e4a9de1 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -254,6 +254,7 @@ struct ap_queue *ap_queue_create(ap_qid_t qid, int device_type);
 void ap_queue_remove(struct ap_queue *aq);
 void ap_queue_suspend(struct ap_device *ap_dev);
 void ap_queue_resume(struct ap_device *ap_dev);
+void ap_queue_reinit_state(struct ap_queue *aq);
 
 struct ap_card *ap_card_create(int id, int queue_depth, int raw_device_type,
 			       int comp_device_type, unsigned int functions);

commit 00fab2350e6b91e57b3cdcd5d9f01056775a921d
Author: Harald Freudenberger <freude@linux.ibm.com>
Date:   Mon Sep 17 16:18:41 2018 +0200

    s390/zcrypt: multiple zcrypt device nodes support
    
    This patch is an extension to the zcrypt device driver to provide,
    support and maintain multiple zcrypt device nodes. The individual
    zcrypt device nodes can be restricted in terms of crypto cards,
    domains and available ioctls. Such a device node can be used as a
    base for container solutions like docker to control and restrict
    the access to crypto resources.
    
    The handling is done with a new sysfs subdir /sys/class/zcrypt.
    Echoing a name (or an empty sting) into the attribute "create" creates
    a new zcrypt device node. In /sys/class/zcrypt a new link will appear
    which points to the sysfs device tree of this new device. The
    attribute files "ioctlmask", "apmask" and "aqmask" in this directory
    are used to customize this new zcrypt device node instance. Finally
    the zcrypt device node can be destroyed by echoing the name into
    /sys/class/zcrypt/destroy. The internal structs holding the device
    info are reference counted - so a destroy will not hard remove a
    device but only marks it as removable when the reference counter drops
    to zero.
    
    The mask values are bitmaps in big endian order starting with bit 0.
    So adapter number 0 is the leftmost bit, mask is 0x8000...  The sysfs
    attributes accept 2 different formats:
    * Absolute hex string starting with 0x like "0x12345678" does set
      the mask starting from left to right. If the given string is shorter
      than the mask it is padded with 0s on the right. If the string is
      longer than the mask an error comes back (EINVAL).
    * Relative format - a concatenation (done with ',') of the
      terms +<bitnr>[-<bitnr>] or -<bitnr>[-<bitnr>]. <bitnr> may be any
      valid number (hex, decimal or octal) in the range 0...255. Here are
      some examples:
        "+0-15,+32,-128,-0xFF"
        "-0-255,+1-16,+0x128"
        "+1,+2,+3,+4,-5,-7-10"
    
    A simple usage examples:
    
      # create new zcrypt device 'my_zcrypt':
      echo "my_zcrypt" >/sys/class/zcrypt/create
      # go into the device dir of this new device
      echo "my_zcrypt" >create
      cd my_zcrypt/
      ls -l
      total 0
      -rw-r--r-- 1 root root 4096 Jul 20 15:23 apmask
      -rw-r--r-- 1 root root 4096 Jul 20 15:23 aqmask
      -r--r--r-- 1 root root 4096 Jul 20 15:23 dev
      -rw-r--r-- 1 root root 4096 Jul 20 15:23 ioctlmask
      lrwxrwxrwx 1 root root    0 Jul 20 15:23 subsystem -> ../../../../class/zcrypt
      ...
      # customize this zcrypt node clone
      # enable only adapter 0 and 2
      echo "0xa0" >apmask
      # enable only domain 6
      echo "+6" >aqmask
      # enable all 256 ioctls
      echo "+0-255" >ioctls
      # now the /dev/my_zcrypt may be used
      # finally destroy it
      echo "my_zcrypt" >/sys/class/zcrypt/destroy
    
    Please note that a very similar 'filtering behavior' also applies to
    the parent z90crypt device. The two mask attributes apmask and aqmask
    in /sys/bus/ap act the very same for the z90crypt device node. However
    the implementation here is totally different as the ap bus acts on
    bind/unbind of queue devices and associated drivers but the effect is
    still the same. So there are two filters active for each additional
    zcrypt device node: The adapter/domain needs to be enabled on the ap
    bus level and it needs to be active on the zcrypt device node level.
    
    Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 5246cd8c16a6..3eed1b36c876 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -20,6 +20,7 @@
 
 #define AP_DEVICES 256		/* Number of AP devices. */
 #define AP_DOMAINS 256		/* Number of AP domains. */
+#define AP_IOCTLS  256		/* Number of ioctls. */
 #define AP_RESET_TIMEOUT (HZ*0.7)	/* Time in ticks for reset timeouts. */
 #define AP_CONFIG_TIME 30	/* Time in seconds between AP bus rescans. */
 #define AP_POLL_TIME 1		/* Time in ticks between receive polls. */
@@ -257,6 +258,14 @@ void ap_queue_resume(struct ap_device *ap_dev);
 struct ap_card *ap_card_create(int id, int queue_depth, int raw_device_type,
 			       int comp_device_type, unsigned int functions);
 
+struct ap_perms {
+	unsigned long ioctlm[BITS_TO_LONGS(AP_IOCTLS)];
+	unsigned long apm[BITS_TO_LONGS(AP_DEVICES)];
+	unsigned long aqm[BITS_TO_LONGS(AP_DOMAINS)];
+};
+extern struct ap_perms ap_perms;
+extern struct mutex ap_perms_mutex;
+
 /*
  * check APQN for owned/reserved by ap bus and default driver(s).
  * Checks if this APQN is or will be in use by the ap bus
@@ -280,4 +289,20 @@ int ap_owned_by_def_drv(int card, int queue);
 int ap_apqn_in_matrix_owned_by_def_drv(unsigned long *apm,
 				       unsigned long *aqm);
 
+/*
+ * ap_parse_mask_str() - helper function to parse a bitmap string
+ * and clear/set the bits in the bitmap accordingly. The string may be
+ * given as absolute value, a hex string like 0x1F2E3D4C5B6A" simple
+ * overwriting the current content of the bitmap. Or as relative string
+ * like "+1-16,-32,-0x40,+128" where only single bits or ranges of
+ * bits are cleared or set. Distinction is done based on the very
+ * first character which may be '+' or '-' for the relative string
+ * and othewise assume to be an absolute value string. If parsing fails
+ * a negative errno value is returned. All arguments and bitmaps are
+ * big endian order.
+ */
+int ap_parse_mask_str(const char *str,
+		      unsigned long *bitmap, int bits,
+		      struct mutex *lock);
+
 #endif /* _AP_BUS_H_ */

commit 7e0bdbe5c21cb8316a694e46ad5aad339f6894a6
Author: Harald Freudenberger <freude@linux.ibm.com>
Date:   Fri Jul 20 08:36:53 2018 +0200

    s390/zcrypt: AP bus support for alternate driver(s)
    
    The current AP bus, AP devices and AP device drivers implementation
    uses a clearly defined mapping for binding AP devices to AP device
    drivers. So for example a CEX6C queue will always be bound to the
    cex4queue device driver.
    
    The Linux Device Driver model has no sensitivity for more than one
    device driver eligible for one device type. If there exist more than
    one drivers matching to the device type, simple all drivers are tried
    consecutively.  There is no way to determine and influence the probing
    order of the drivers.
    
    With KVM there is a need to provide additional device drivers matching
    to the very same type of AP devices. With a simple implementation the
    KVM drivers run in competition to the regular drivers. Whichever
    'wins' a device depends on build order and implementation details
    within the common Linux Device Driver Model and is not
    deterministic. However, a userspace process could figure out which
    device should be bound to which driver and sort out the correct
    binding by manipulating attributes in the sysfs.
    
    If for security reasons a AP device must not get bound to the 'wrong'
    device driver the sorting out has to be done within the Linux kernel
    by the AP bus code. This patch modifies the behavior of the AP bus
    for probing drivers for devices in a way that two sets of drivers are
    usable. Two new bitmasks 'apmask' and 'aqmask' are used to mark a
    subset of the APQN range for 'usable by the ap bus and the default
    drivers' or 'not usable by the default drivers and thus available for
    alternate drivers like vfio-xxx'. So an APQN which is addressed by
    this masking only the default drivers will be probed. In contrary an
    APQN which is not addressed by the masks will never be probed and
    bound to default drivers but onny to alternate drivers.
    
    Eventually the two masks give a way to divide the range of APQNs into
    two pools: one pool of APQNs used by the AP bus and the default
    drivers and thus via zcrypt drivers available to the userspace of the
    system. And another pool where no zcrypt drivers are bound to and
    which can be used by alternate drivers (like vfio-xxx) for their
    needs. This division is hot-plug save and makes sure a APQN assigned
    to an alternate driver is at no time somehow exploitable by the wrong
    party.
    
    The two masks are located in sysfs at /sys/bus/ap/apmask and
    /sys/bus/ap/aqmask.  The mask syntax is exactly the same as the
    already existing mask attributes in the /sys/bus/ap directory (for
    example ap_usage_domain_mask and ap_control_domain_mask).
    
    By default all APQNs belong to the ap bus and the default drivers:
    
      cat /sys/bus/ap/apmask
      0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
      cat /sys/bus/ap/aqmask
      0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    
    The masks can be changed at boot time with the kernel command line
    like this:
    
      ... ap.apmask=0xffff ap.aqmask=0x40
    
    This would give these two pools:
    
      default drivers pool:    adapter 0 - 15, domain 1
      alternate drivers pool:  adapter 0 - 15, all but domain 1
                               adapter 16-255, all domains
    
    The sysfs attributes for this two masks are writeable and an
    administrator is able to reconfigure the assignements on the fly by
    writing new mask values into.  With changing the mask(s) a revision of
    the existing queue to driver bindings is done. So all APQNs which are
    bound to the 'wrong' driver are reprobed via kernel function
    device_reprobe() and thus the new correct driver will be assigned with
    respect of the changed apmask and aqmask bits.
    
    The mask values are bitmaps in big endian order starting with bit 0.
    So adapter number 0 is the leftmost bit, mask is 0x8000... The sysfs
    attributes accept 2 different formats:
    - Absolute hex string starting with 0x like "0x12345678" does set
      the mask starting from left to right. If the given string is shorter
      than the mask it is padded with 0s on the right. If the string is
      longer than the mask an error comes back (EINVAL).
    - '+' or '-' followed by a numerical value. Valid examples are "+1",
      "-13", "+0x41", "-0xff" and even "+0" and "-0". Only the addressed
      bit in the mask is switched on ('+') or off ('-').
    
    This patch will also be the base for an upcoming extension to the
    zcrypt drivers to be able to provide additional zcrypt device nodes
    with filtering based on ap and aq masks.
    
    Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 24d3425b5276..5246cd8c16a6 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -117,9 +117,18 @@ enum ap_wait {
 struct ap_device;
 struct ap_message;
 
+/*
+ * The ap driver struct includes a flags field which holds some info for
+ * the ap bus about the driver. Currently only one flag is supported and
+ * used: The DEFAULT flag marks an ap driver as a default driver which is
+ * used together with the apmask and aqmask whitelisting of the ap bus.
+ */
+#define AP_DRIVER_FLAG_DEFAULT 0x0001
+
 struct ap_driver {
 	struct device_driver driver;
 	struct ap_device_id *ids;
+	unsigned int flags;
 
 	int (*probe)(struct ap_device *);
 	void (*remove)(struct ap_device *);
@@ -248,4 +257,27 @@ void ap_queue_resume(struct ap_device *ap_dev);
 struct ap_card *ap_card_create(int id, int queue_depth, int raw_device_type,
 			       int comp_device_type, unsigned int functions);
 
+/*
+ * check APQN for owned/reserved by ap bus and default driver(s).
+ * Checks if this APQN is or will be in use by the ap bus
+ * and the default set of drivers.
+ * If yes, returns 1, if not returns 0. On error a negative
+ * errno value is returned.
+ */
+int ap_owned_by_def_drv(int card, int queue);
+
+/*
+ * check 'matrix' of APQNs for owned/reserved by ap bus and
+ * default driver(s).
+ * Checks if there is at least one APQN in the given 'matrix'
+ * marked as owned/reserved by the ap bus and default driver(s).
+ * If such an APQN is found the return value is 1, otherwise
+ * 0 is returned. On error a negative errno value is returned.
+ * The parameter apm is a bitmask which should be declared
+ * as DECLARE_BITMAP(apm, AP_DEVICES), the aqm parameter is
+ * similar, should be declared as DECLARE_BITMAP(aqm, AP_DOMAINS).
+ */
+int ap_apqn_in_matrix_owned_by_def_drv(unsigned long *apm,
+				       unsigned long *aqm);
+
 #endif /* _AP_BUS_H_ */

commit ac2b96f351d7d222c46e524feca03005f3fa8d75
Author: Harald Freudenberger <freude@linux.ibm.com>
Date:   Fri Aug 17 12:36:01 2018 +0200

    s390/zcrypt: code beautify
    
    Code beautify by following most of the checkpatch suggestions:
     - SPDX license identifier line complains by checkpatch
     - missing space or newline complains by checkpatch
     - octal numbers for permssions complains by checkpatch
     - renaming of static sysfs functions complains by checkpatch
     - fix of block comment complains by checkpatch
     - fix printf like calls where function name instead of %s __func__
       was used
     - __packed instead of __attribute__((packed))
     - init to zero for static variables removed
     - use of DEVICE_ATTR_RO and DEVICE_ATTR_RW macros
    
    No functional code changes or API changes!
    
    Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 936541937e15..24d3425b5276 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0+
+/* SPDX-License-Identifier: GPL-2.0+ */
 /*
  * Copyright IBM Corp. 2006, 2012
  * Author(s): Cornelia Huck <cornelia.huck@de.ibm.com>
@@ -167,7 +167,7 @@ struct ap_queue {
 	int pendingq_count;		/* # requests on pendingq list. */
 	int requestq_count;		/* # requests on requestq list. */
 	int total_request_count;	/* # requests ever for this AP device.*/
-	int request_timeout;		/* Request timout in jiffies. */
+	int request_timeout;		/* Request timeout in jiffies. */
 	struct timer_list timeout;	/* Timer for request timeouts. */
 	struct list_head pendingq;	/* List of message sent to AP queue. */
 	struct list_head requestq;	/* List of message yet to be sent. */

commit f1b0a4343c4184bef9fdea8fad41f09bbd3d63ec
Author: Harald Freudenberger <freude@de.ibm.com>
Date:   Tue Jun 12 15:42:36 2018 +0200

    s390/zcrypt: Integrate ap_asm.h into include/asm/ap.h.
    
    Move all the inline functions from the ap bus header
    file ap_asm.h into the in-kernel api header file
    arch/s390/include/asm/ap.h so that KVM can make use
    of all the low level AP functions.
    
    Signed-off-by: Harald Freudenberger <freude@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 6a273c5ebca5..936541937e15 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -15,6 +15,7 @@
 
 #include <linux/device.h>
 #include <linux/types.h>
+#include <asm/isc.h>
 #include <asm/ap.h>
 
 #define AP_DEVICES 256		/* Number of AP devices. */

commit 89a0c0ec0d2e3ce0ee9caa00f60c0c26ccf11c21
Author: Harald Freudenberger <freude@de.ibm.com>
Date:   Mon May 28 13:00:42 2018 +0200

    s390/zcrypt: Fix CCA and EP11 CPRB processing failure memory leak.
    
    Tests showed, that the zcrypt device driver produces memory
    leaks when a valid CCA or EP11 CPRB can't get delivered or has
    a failure during processing within the zcrypt device driver.
    
    This happens when a invalid domain or adapter number is used
    or the lower level software or hardware layers produce any
    kind of failure during processing of the request.
    
    Only CPRBs send to CCA or EP11 cards can produce this memory
    leak. The accelerator and the CPRBs processed by this type
    of crypto card is not affected.
    
    The two fields message and private within the ap_message struct
    are allocated with pulling the function code for the CPRB but
    only freed when processing of the CPRB succeeds. So for example
    an invalid domain or adapter field causes the processing to
    fail, leaving these two memory areas allocated forever.
    
    Signed-off-by: Harald Freudenberger <freude@de.ibm.com>
    Reviewed-by: Ingo Franzki <ifranzki@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 02184cf35834..6a273c5ebca5 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -198,11 +198,18 @@ struct ap_message {
  */
 static inline void ap_init_message(struct ap_message *ap_msg)
 {
-	ap_msg->psmid = 0;
-	ap_msg->length = 0;
-	ap_msg->rc = 0;
-	ap_msg->special = 0;
-	ap_msg->receive = NULL;
+	memset(ap_msg, 0, sizeof(*ap_msg));
+}
+
+/**
+ * ap_release_message() - Release ap_message.
+ * Releases all memory used internal within the ap_message struct
+ * Currently this is the message and private field.
+ */
+static inline void ap_release_message(struct ap_message *ap_msg)
+{
+	kzfree(ap_msg->message);
+	kzfree(ap_msg->private);
 }
 
 #define for_each_ap_card(_ac) \

commit af4a72276d49da117dbc99799afee740a26f8f10
Author: Harald Freudenberger <freude@linux.vnet.ibm.com>
Date:   Mon Apr 9 16:18:37 2018 +0200

    s390/zcrypt: Support up to 256 crypto adapters.
    
    There was an artificial restriction on the card/adapter id
    to only 6 bits but all the AP commands do support adapter
    ids with 8 bit. This patch removes this restriction to 64
    adapters and now up to 256 adapter can get addressed.
    
    Some of the ioctl calls work on the max number of cards
    possible (which was 64). These ioctls are now deprecated
    but still supported. All the defines, structs and ioctl
    interface declarations have been kept for compabibility.
    There are now new ioctls (and defines for these) with an
    additional '2' appended which provide the extended versions
    with 256 cards supported.
    
    Signed-off-by: Harald Freudenberger <freude@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 951ab595dc18..02184cf35834 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -17,7 +17,7 @@
 #include <linux/types.h>
 #include <asm/ap.h>
 
-#define AP_DEVICES 64		/* Number of AP devices. */
+#define AP_DEVICES 256		/* Number of AP devices. */
 #define AP_DOMAINS 256		/* Number of AP domains. */
 #define AP_RESET_TIMEOUT (HZ*0.7)	/* Time in ticks for reset timeouts. */
 #define AP_CONFIG_TIME 30	/* Time in seconds between AP bus rescans. */

commit 2c957a8ad45991f3ef71da5c75ed2299f3d46a31
Author: Harald Freudenberger <freude@linux.vnet.ibm.com>
Date:   Tue Mar 27 07:37:24 2018 +0200

    s390/zcrypt: remove unused functions and declarations
    
    The AP bus code is not available as kernel module any more.
    There was some leftover code dealing with kernel module
    exit which has been removed with this patch.
    
    Signed-off-by: Harald Freudenberger <freude@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index e0827eaa42f1..951ab595dc18 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -240,7 +240,4 @@ void ap_queue_resume(struct ap_device *ap_dev);
 struct ap_card *ap_card_create(int id, int queue_depth, int raw_device_type,
 			       int comp_device_type, unsigned int functions);
 
-int ap_module_init(void);
-void ap_module_exit(void);
-
 #endif /* _AP_BUS_H_ */

commit 0b622e60bc6c4eca75d517b10f15914ecd58e6b1
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 14 18:38:07 2017 +0100

    s390: crypto: Remove redundant license text
    
    Now that the SPDX tag is in all drivers/s390/crypto/ files, that
    identifies the license in a specific and legally-defined manner.  So the
    extra GPL text wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Harald Freudenberger <freude@de.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index b43e4d650940..e0827eaa42f1 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -8,20 +8,6 @@
  *	      Holger Dengler <hd@linux.vnet.ibm.com>
  *
  * Adjunct processor bus header file.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #ifndef _AP_BUS_H_

commit 812141a9fe61446c948a71456c58090ac11a6d14
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 14 18:38:01 2017 +0100

    s390: crypto: add SPDX identifiers to the remaining files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/s390/crypto/ files with the correct SPDX license
    identifier based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Harald Freudenberger <freude@de.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 7e45c4d08cad..b43e4d650940 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright IBM Corp. 2006, 2012
  * Author(s): Cornelia Huck <cornelia.huck@de.ibm.com>

commit cefbeb5df56e1daf0adda8ca5eecee03c5084af6
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 25 03:27:37 2017 -0700

    s390/ap_bus: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Harald Freudenberger <freude@de.ibm.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 3a0e19d87e7c..7e45c4d08cad 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -241,7 +241,7 @@ void ap_flush_queue(struct ap_queue *aq);
 
 void *ap_airq_ptr(void);
 void ap_wait(enum ap_wait wait);
-void ap_request_timeout(unsigned long data);
+void ap_request_timeout(struct timer_list *t);
 void ap_bus_force_rescan(void);
 
 void ap_queue_init_reply(struct ap_queue *aq, struct ap_message *ap_msg);

commit 9a5641080bf433e195730e47a13de58dcd70f47f
Author: Harald Freudenberger <freude@linux.vnet.ibm.com>
Date:   Mon Oct 16 12:28:35 2017 +0200

    s390/zcrypt: Introduce QACT support for AP bus devices.
    
    This patch introduces a new ap_qact() function which
    exploits the PQAP(QACT) subfunction. QACT is a new
    interface to Query the Ap Compatilibity Type based
    on a given AP qid, type, mode and version.
    
    Based on this new function the AP bus scan code is
    slightly reworked to use this new interface for
    querying the compatible type for each new AP queue
    device detected. So new and unknown devices can
    get automatically mapped to a compatible type and
    handled without the need for toleration patches
    for every new hardware.
    
    The currently highest known hardware is CEX6S.
    With this patch a possible successor can get
    queried for a combatible type known by the device
    driver without the need for an toleration patch.
    
    Signed-off-by: Harald Freudenberger <freude@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 754cf2223cfb..3a0e19d87e7c 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -250,8 +250,8 @@ void ap_queue_remove(struct ap_queue *aq);
 void ap_queue_suspend(struct ap_device *ap_dev);
 void ap_queue_resume(struct ap_device *ap_dev);
 
-struct ap_card *ap_card_create(int id, int queue_depth, int device_type,
-			       unsigned int device_functions);
+struct ap_card *ap_card_create(int id, int queue_depth, int raw_device_type,
+			       int comp_device_type, unsigned int functions);
 
 int ap_module_init(void);
 void ap_module_exit(void);

commit 050349b5b71df52c24989037bd6515cb54c3ef35
Author: Harald Freudenberger <freude@linux.vnet.ibm.com>
Date:   Tue Nov 8 11:54:28 2016 +0100

    s390/zcrypt: externalize AP config info query
    
    KVM has a need to fetch the crypto configuration information
    as it is returned by the PQAP(QCI) instruction. This patch
    introduces a new API ap_query_configuration() which provides
    this info in a handy way for the caller.
    
    Signed-off-by: Harald Freudenberger <freude@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index f07698d41f77..754cf2223cfb 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -204,17 +204,6 @@ struct ap_message {
 			struct ap_message *);
 };
 
-struct ap_config_info {
-	unsigned int special_command:1;
-	unsigned int ap_extended:1;
-	unsigned char reserved1:6;
-	unsigned char reserved2[15];
-	unsigned int apm[8];		/* AP ID mask */
-	unsigned int aqm[8];		/* AP queue mask */
-	unsigned int adm[8];		/* AP domain mask */
-	unsigned char reserved4[16];
-} __packed;
-
 /**
  * ap_init_message() - Initialize ap_message.
  * Initialize a message before using. Otherwise this might result in

commit e7fc5146cfe4f1b10f2ed6c36b65248aa948abe8
Author: Tony Krowiak <akrowiak@linux.vnet.ibm.com>
Date:   Tue Nov 8 07:09:13 2016 +0100

    s390/zcrypt: externalize test AP queue
    
    Under certain specified conditions, the Test AP Queue (TAPQ)
    subfunction of the Process Adjunct Processor Queue (PQAP) instruction
    will be intercepted by a guest VM. The guest VM must have a means for
    executing the intercepted instruction.
    
    The vfio_ap driver will provide an interface to execute the
    PQAP(TAPQ) instruction subfunction on behalf of a guest VM.
    The code for executing the AP instructions currently resides in the
    AP bus. This patch refactors the AP bus code to externalize access
    to the PQAP(TAPQ) instruction subfunction to make it available to
    the vfio_ap driver.
    
    Signed-off-by: Tony Krowiak <akrowiak@linux.vnet.ibm.com>
    Signed-off-by: Harald Freudenberger <freude@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 4dc7c88fb054..f07698d41f77 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -28,6 +28,7 @@
 
 #include <linux/device.h>
 #include <linux/types.h>
+#include <asm/ap.h>
 
 #define AP_DEVICES 64		/* Number of AP devices. */
 #define AP_DOMAINS 256		/* Number of AP domains. */
@@ -40,41 +41,6 @@ extern int ap_domain_index;
 extern spinlock_t ap_list_lock;
 extern struct list_head ap_card_list;
 
-/**
- * The ap_qid_t identifier of an ap queue. It contains a
- * 6 bit card index and a 4 bit queue index (domain).
- */
-typedef unsigned int ap_qid_t;
-
-#define AP_MKQID(_card, _queue) (((_card) & 63) << 8 | ((_queue) & 255))
-#define AP_QID_CARD(_qid) (((_qid) >> 8) & 63)
-#define AP_QID_QUEUE(_qid) ((_qid) & 255)
-
-/**
- * structy ap_queue_status - Holds the AP queue status.
- * @queue_empty: Shows if queue is empty
- * @replies_waiting: Waiting replies
- * @queue_full: Is 1 if the queue is full
- * @pad: A 4 bit pad
- * @int_enabled: Shows if interrupts are enabled for the AP
- * @response_code: Holds the 8 bit response code
- * @pad2: A 16 bit pad
- *
- * The ap queue status word is returned by all three AP functions
- * (PQAP, NQAP and DQAP).  There's a set of flags in the first
- * byte, followed by a 1 byte response code.
- */
-struct ap_queue_status {
-	unsigned int queue_empty	: 1;
-	unsigned int replies_waiting	: 1;
-	unsigned int queue_full		: 1;
-	unsigned int pad1		: 4;
-	unsigned int int_enabled	: 1;
-	unsigned int response_code	: 8;
-	unsigned int pad2		: 16;
-} __packed;
-
-
 static inline int ap_test_bit(unsigned int *ptr, unsigned int nr)
 {
 	return (*ptr & (0x80000000u >> nr)) != 0;

commit e47de21dd35bad6d1e71482a66699cd04e83ea40
Author: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
Date:   Fri Oct 14 14:34:51 2016 +0200

    s390/zcrypt: Fixed attrition of AP adapters and domains
    
    Currently the first eligible AP adapter respectively domain will be
    selected to service requests. In case of sequential workload, the
    very same adapter/domain will be used.
    
    The adapter/domain selection algorithm now considers the completed
    transactions per adaper/domain and therefore ensures a homogeneous
    utilization.
    
    Signed-off-by: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 54b17e142792..4dc7c88fb054 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -195,6 +195,7 @@ struct ap_card {
 	unsigned int functions;		/* AP device function bitfield. */
 	int queue_depth;		/* AP queue depth.*/
 	int id;				/* AP card number. */
+	atomic_t total_request_count;	/* # requests ever for this AP device.*/
 };
 
 #define to_ap_card(x) container_of((x), struct ap_card, ap_dev.device)
@@ -211,7 +212,7 @@ struct ap_queue {
 	enum ap_state state;		/* State of the AP device. */
 	int pendingq_count;		/* # requests on pendingq list. */
 	int requestq_count;		/* # requests on requestq list. */
-	int total_request_count;	/* # requests ever for this AP device. */
+	int total_request_count;	/* # requests ever for this AP device.*/
 	int request_timeout;		/* Request timout in jiffies. */
 	struct timer_list timeout;	/* Timer for request timeouts. */
 	struct list_head pendingq;	/* List of message sent to AP queue. */

commit e28d2af43614eb86f59812e7221735fc221bbc10
Author: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
Date:   Thu Aug 25 11:16:03 2016 +0200

    s390/zcrypt: add multi domain support
    
    Currently the ap infrastructure only supports one domain at a time.
    This feature extends the generic cryptographic device driver to
    support multiple cryptographic domains simultaneously.
    
    There are now card and queue devices on the AP bus with independent
    card and queue drivers. The new /sys layout is as follows:
    
    /sys/bus/ap
        devices
            <xx>.<yyyy> -> ../../../devices/ap/card<xx>/<xx>.<yyyy>
            ...
            card<xx> -> ../../../devices/ap/card<xx>
            ...
        drivers
            <drv>card
                card<xx> -> ../../../../devices/ap/card<xx>
            <drv>queue
                <xx>.<yyyy> -> ../../../../devices/ap/card<xx>/<xx>.<yyyy>
                ...
    
    /sys/devices/ap
        card<xx>
            <xx>.<yyyy>
                driver -> ../../../../bus/ap/drivers/<zzz>queue
                ...
            driver -> ../../../bus/ap/drivers/<drv>card
            ...
    
    The two digit <xx> field is the card number, the four digit <yyyy>
    field is the queue number and <drv> is the name of the device driver,
    e.g. "cex4".
    
    For compatability /sys/bus/ap/card<xx> for the old layout has to exist,
    including the attributes that used to reside there.
    
    With additional contributions from Harald Freudenberger and
    Martin Schwidefsky.
    
    Signed-off-by: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index fd66d2c450d5..54b17e142792 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -27,7 +27,6 @@
 #define _AP_BUS_H_
 
 #include <linux/device.h>
-#include <linux/mod_devicetable.h>
 #include <linux/types.h>
 
 #define AP_DEVICES 64		/* Number of AP devices. */
@@ -38,14 +37,17 @@
 
 extern int ap_domain_index;
 
+extern spinlock_t ap_list_lock;
+extern struct list_head ap_card_list;
+
 /**
  * The ap_qid_t identifier of an ap queue. It contains a
- * 6 bit device index and a 4 bit queue index (domain).
+ * 6 bit card index and a 4 bit queue index (domain).
  */
 typedef unsigned int ap_qid_t;
 
-#define AP_MKQID(_device, _queue) (((_device) & 63) << 8 | ((_queue) & 255))
-#define AP_QID_DEVICE(_qid) (((_qid) >> 8) & 63)
+#define AP_MKQID(_card, _queue) (((_card) & 63) << 8 | ((_queue) & 255))
+#define AP_QID_CARD(_qid) (((_qid) >> 8) & 63)
 #define AP_QID_QUEUE(_qid) ((_qid) & 255)
 
 /**
@@ -55,7 +57,7 @@ typedef unsigned int ap_qid_t;
  * @queue_full: Is 1 if the queue is full
  * @pad: A 4 bit pad
  * @int_enabled: Shows if interrupts are enabled for the AP
- * @response_conde: Holds the 8 bit response code
+ * @response_code: Holds the 8 bit response code
  * @pad2: A 16 bit pad
  *
  * The ap queue status word is returned by all three AP functions
@@ -167,7 +169,8 @@ struct ap_driver {
 
 	int (*probe)(struct ap_device *);
 	void (*remove)(struct ap_device *);
-	int request_timeout;		/* request timeout in jiffies */
+	void (*suspend)(struct ap_device *);
+	void (*resume)(struct ap_device *);
 };
 
 #define to_ap_drv(x) container_of((x), struct ap_driver, driver)
@@ -175,38 +178,50 @@ struct ap_driver {
 int ap_driver_register(struct ap_driver *, struct module *, char *);
 void ap_driver_unregister(struct ap_driver *);
 
-typedef enum ap_wait (ap_func_t)(struct ap_device *ap_dev);
-
 struct ap_device {
 	struct device device;
 	struct ap_driver *drv;		/* Pointer to AP device driver. */
-	spinlock_t lock;		/* Per device lock. */
-	struct list_head list;		/* private list of all AP devices. */
+	int device_type;		/* AP device type. */
+};
 
-	enum ap_state state;		/* State of the AP device. */
+#define to_ap_dev(x) container_of((x), struct ap_device, device)
 
-	ap_qid_t qid;			/* AP queue id. */
-	int queue_depth;		/* AP queue depth.*/
-	int device_type;		/* AP device type. */
+struct ap_card {
+	struct ap_device ap_dev;
+	struct list_head list;		/* Private list of AP cards. */
+	struct list_head queues;	/* List of assoc. AP queues */
+	void *private;			/* ap driver private pointer. */
 	int raw_hwtype;			/* AP raw hardware type. */
 	unsigned int functions;		/* AP device function bitfield. */
-	struct timer_list timeout;	/* Timer for request timeouts. */
+	int queue_depth;		/* AP queue depth.*/
+	int id;				/* AP card number. */
+};
+
+#define to_ap_card(x) container_of((x), struct ap_card, ap_dev.device)
 
+struct ap_queue {
+	struct ap_device ap_dev;
+	struct list_head list;		/* Private list of AP queues. */
+	struct ap_card *card;		/* Ptr to assoc. AP card. */
+	spinlock_t lock;		/* Per device lock. */
+	void *private;			/* ap driver private pointer. */
+	ap_qid_t qid;			/* AP queue id. */
 	int interrupt;			/* indicate if interrupts are enabled */
 	int queue_count;		/* # messages currently on AP queue. */
-
-	struct list_head pendingq;	/* List of message sent to AP queue. */
+	enum ap_state state;		/* State of the AP device. */
 	int pendingq_count;		/* # requests on pendingq list. */
-	struct list_head requestq;	/* List of message yet to be sent. */
 	int requestq_count;		/* # requests on requestq list. */
 	int total_request_count;	/* # requests ever for this AP device. */
-
+	int request_timeout;		/* Request timout in jiffies. */
+	struct timer_list timeout;	/* Timer for request timeouts. */
+	struct list_head pendingq;	/* List of message sent to AP queue. */
+	struct list_head requestq;	/* List of message yet to be sent. */
 	struct ap_message *reply;	/* Per device reply message. */
-
-	void *private;			/* ap driver private pointer. */
 };
 
-#define to_ap_dev(x) container_of((x), struct ap_device, device)
+#define to_ap_queue(x) container_of((x), struct ap_queue, ap_dev.device)
+
+typedef enum ap_wait (ap_func_t)(struct ap_queue *queue);
 
 struct ap_message {
 	struct list_head list;		/* Request queueing. */
@@ -218,7 +233,7 @@ struct ap_message {
 	void *private;			/* ap driver private pointer. */
 	unsigned int special:1;		/* Used for special commands. */
 	/* receive is called from tasklet context */
-	void (*receive)(struct ap_device *, struct ap_message *,
+	void (*receive)(struct ap_queue *, struct ap_message *,
 			struct ap_message *);
 };
 
@@ -233,10 +248,6 @@ struct ap_config_info {
 	unsigned char reserved4[16];
 } __packed;
 
-#define AP_DEVICE(dt)					\
-	.dev_type=(dt),					\
-	.match_flags=AP_DEVICE_ID_MATCH_DEVICE_TYPE,
-
 /**
  * ap_init_message() - Initialize ap_message.
  * Initialize a message before using. Otherwise this might result in
@@ -251,6 +262,12 @@ static inline void ap_init_message(struct ap_message *ap_msg)
 	ap_msg->receive = NULL;
 }
 
+#define for_each_ap_card(_ac) \
+	list_for_each_entry(_ac, &ap_card_list, list)
+
+#define for_each_ap_queue(_aq, _ac) \
+	list_for_each_entry(_aq, &(_ac)->queues, list)
+
 /*
  * Note: don't use ap_send/ap_recv after using ap_queue_message
  * for the first time. Otherwise the ap message queue will get
@@ -259,11 +276,26 @@ static inline void ap_init_message(struct ap_message *ap_msg)
 int ap_send(ap_qid_t, unsigned long long, void *, size_t);
 int ap_recv(ap_qid_t, unsigned long long *, void *, size_t);
 
-void ap_queue_message(struct ap_device *ap_dev, struct ap_message *ap_msg);
-void ap_cancel_message(struct ap_device *ap_dev, struct ap_message *ap_msg);
-void ap_flush_queue(struct ap_device *ap_dev);
+enum ap_wait ap_sm_event(struct ap_queue *aq, enum ap_event event);
+enum ap_wait ap_sm_event_loop(struct ap_queue *aq, enum ap_event event);
+
+void ap_queue_message(struct ap_queue *aq, struct ap_message *ap_msg);
+void ap_cancel_message(struct ap_queue *aq, struct ap_message *ap_msg);
+void ap_flush_queue(struct ap_queue *aq);
+
+void *ap_airq_ptr(void);
+void ap_wait(enum ap_wait wait);
+void ap_request_timeout(unsigned long data);
 void ap_bus_force_rescan(void);
-void ap_device_init_reply(struct ap_device *ap_dev, struct ap_message *ap_msg);
+
+void ap_queue_init_reply(struct ap_queue *aq, struct ap_message *ap_msg);
+struct ap_queue *ap_queue_create(ap_qid_t qid, int device_type);
+void ap_queue_remove(struct ap_queue *aq);
+void ap_queue_suspend(struct ap_device *ap_dev);
+void ap_queue_resume(struct ap_device *ap_dev);
+
+struct ap_card *ap_card_create(int id, int queue_depth, int device_type,
+			       unsigned int device_functions);
 
 int ap_module_init(void);
 void ap_module_exit(void);

commit b3e8652bcbfa04807e44708d4d0c8cdad39c9215
Author: Harald Freudenberger <freude@linux.vnet.ibm.com>
Date:   Wed Oct 12 15:58:14 2016 +0200

    s390/zcrypt: Introduce CEX6 toleration
    
    Signed-off-by: Harald Freudenberger <freude@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index d7fdf5c024d7..fd66d2c450d5 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -105,6 +105,7 @@ static inline int ap_test_bit(unsigned int *ptr, unsigned int nr)
 #define AP_DEVICE_TYPE_CEX3C	9
 #define AP_DEVICE_TYPE_CEX4	10
 #define AP_DEVICE_TYPE_CEX5	11
+#define AP_DEVICE_TYPE_CEX6	12
 
 /*
  * Known function facilities

commit d6d86c57d77d466df2096b134e5f54463d3f0fb8
Author: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
Date:   Mon Jul 25 14:52:28 2016 +0200

    s390/zcrypt: Fix zcrypt suspend/resume behavior
    
    The device suspend call triggers all ap devices to fetch potentially
    available response messages from the queues. Therefore the
    corresponding zcrypt device, that is allocated asynchronously after
    ap device probing, needs to be fully prepared. This race condition
    could lead to uninitialized response buffers while trying to read
    from the queues.
    
    Introduce a new callback within the ap layer to get noticed when a
    zcrypt device is fully prepared. Additional checks prevent reading
    from devices that are not fully prepared.
    
    Signed-off-by: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 6adcbdf225d1..d7fdf5c024d7 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -262,6 +262,7 @@ void ap_queue_message(struct ap_device *ap_dev, struct ap_message *ap_msg);
 void ap_cancel_message(struct ap_device *ap_dev, struct ap_message *ap_msg);
 void ap_flush_queue(struct ap_device *ap_dev);
 void ap_bus_force_rescan(void);
+void ap_device_init_reply(struct ap_device *ap_dev, struct ap_message *ap_msg);
 
 int ap_module_init(void);
 void ap_module_exit(void);

commit 3f3007afda8bb731a3422430752ca91ddc102e4d
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Sep 14 17:01:23 2015 +0200

    s390/zcrypt: introduce state machine for the AP bus
    
    Replace the two fields 'unregistered' and 'reset' with a device
    state with 5 possible values. Introduce two events for the AP devices,
    device poll and device timeout. With the state machine it is easier
    to deal with device initialization and suspend/resume. Device polling
    is simpler as well, the arkane 'flags' passing is gone.
    
    Reviewd-by: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index af9b705976bc..6adcbdf225d1 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -36,9 +36,6 @@
 #define AP_CONFIG_TIME 30	/* Time in seconds between AP bus rescans. */
 #define AP_POLL_TIME 1		/* Time in ticks between receive polls. */
 
-#define AP_POLL_IMMEDIATELY	1 /* continue running poll tasklet */
-#define AP_POLL_AFTER_TIMEOUT	2 /* run poll tasklet again after timout */
-
 extern int ap_domain_index;
 
 /**
@@ -119,20 +116,46 @@ static inline int ap_test_bit(unsigned int *ptr, unsigned int nr)
 #define AP_FUNC_EP11  5
 #define AP_FUNC_APXA  6
 
-/*
- * AP reset flag states
- */
-#define AP_RESET_IGNORE	0	/* request timeout will be ignored */
-#define AP_RESET_ARMED	1	/* request timeout timer is active */
-#define AP_RESET_DO	2	/* AP reset required */
-#define AP_RESET_IN_PROGRESS	3	/* AP reset in progress */
-
 /*
  * AP interrupt states
  */
 #define AP_INTR_DISABLED	0	/* AP interrupt disabled */
 #define AP_INTR_ENABLED		1	/* AP interrupt enabled */
-#define AP_INTR_IN_PROGRESS	3	/* AP interrupt in progress */
+
+/*
+ * AP device states
+ */
+enum ap_state {
+	AP_STATE_RESET_START,
+	AP_STATE_RESET_WAIT,
+	AP_STATE_SETIRQ_WAIT,
+	AP_STATE_IDLE,
+	AP_STATE_WORKING,
+	AP_STATE_QUEUE_FULL,
+	AP_STATE_SUSPEND_WAIT,
+	AP_STATE_BORKED,
+	NR_AP_STATES
+};
+
+/*
+ * AP device events
+ */
+enum ap_event {
+	AP_EVENT_POLL,
+	AP_EVENT_TIMEOUT,
+	NR_AP_EVENTS
+};
+
+/*
+ * AP wait behaviour
+ */
+enum ap_wait {
+	AP_WAIT_AGAIN,		/* retry immediately */
+	AP_WAIT_TIMEOUT,	/* wait for timeout */
+	AP_WAIT_INTERRUPT,	/* wait for thin interrupt (if available) */
+	AP_WAIT_NONE,		/* no wait */
+	NR_AP_WAIT
+};
 
 struct ap_device;
 struct ap_message;
@@ -151,20 +174,22 @@ struct ap_driver {
 int ap_driver_register(struct ap_driver *, struct module *, char *);
 void ap_driver_unregister(struct ap_driver *);
 
+typedef enum ap_wait (ap_func_t)(struct ap_device *ap_dev);
+
 struct ap_device {
 	struct device device;
 	struct ap_driver *drv;		/* Pointer to AP device driver. */
 	spinlock_t lock;		/* Per device lock. */
 	struct list_head list;		/* private list of all AP devices. */
 
+	enum ap_state state;		/* State of the AP device. */
+
 	ap_qid_t qid;			/* AP queue id. */
 	int queue_depth;		/* AP queue depth.*/
 	int device_type;		/* AP device type. */
 	int raw_hwtype;			/* AP raw hardware type. */
 	unsigned int functions;		/* AP device function bitfield. */
-	int unregistered;		/* marks AP device as unregistered */
 	struct timer_list timeout;	/* Timer for request timeouts. */
-	int reset;			/* Reset required after req. timeout. */
 
 	int interrupt;			/* indicate if interrupts are enabled */
 	int queue_count;		/* # messages currently on AP queue. */

commit f58fe336009f451748c1c337f35130a320ef923d
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Mon Sep 14 16:59:27 2015 +0200

    s390/zcrypt: use explicit return code for flushed requests
    
    If a AP device is removed while messages are still pending, the requests
    are cancelled by calling the message receive function with an error pointer
    for the reply. The message type receive handler recognize this and create
    a fake hardware error TYPE82_RSP_CODE / REP82_ERROR_MACHINE_FAILURE.
    The message with the hardware error then causes a printk and a return
    code of -EAGAIN.
    
    Replace the intricate scheme with an explicit return code for this sitation
    and avoid the error message.
    
    Reviewd-by: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 83cc9e404a77..af9b705976bc 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -187,6 +187,7 @@ struct ap_message {
 	unsigned long long psmid;	/* Message id. */
 	void *message;			/* Pointer to message buffer. */
 	size_t length;			/* Message length. */
+	int rc;				/* Return code for this message */
 
 	void *private;			/* ap driver private pointer. */
 	unsigned int special:1;		/* Used for special commands. */
@@ -219,6 +220,7 @@ static inline void ap_init_message(struct ap_message *ap_msg)
 {
 	ap_msg->psmid = 0;
 	ap_msg->length = 0;
+	ap_msg->rc = 0;
 	ap_msg->special = 0;
 	ap_msg->receive = NULL;
 }

commit 889875a14f0a3205e78613b3e78ecc4efc187d74
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Jun 26 16:55:35 2015 +0200

    s390/zcrypt: fix memory leak with ap configuration data
    
    The ap_query_configuration function allocates the ap_config_info
    structure, but there is no code to free the structure.
    Allocate the structure in the module_init function and free it
    again in module_exit.
    
    While we are at it simplify a few functions in regard to the
    ap configuration data.
    
    Reviewed-by: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 2e0a21f84f3d..83cc9e404a77 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -76,11 +76,8 @@ struct ap_queue_status {
 } __packed;
 
 
-#define AP_MAX_BITS 31
 static inline int ap_test_bit(unsigned int *ptr, unsigned int nr)
 {
-	if (nr > AP_MAX_BITS)
-		return 0;
 	return (*ptr & (0x80000000u >> nr)) != 0;
 }
 

commit 6acbe21f473f5cff8a11546f090967459b63ab3e
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Jun 26 15:40:41 2015 +0200

    s390/zcrypt: remove duplicate low level functions
    
    ap_test_queue, ap_query_facilities, __ap_query_functions all use
    the same PQAP(TAPQ) command. Consolidate the three into a single
    ap_test_queue function that returns the AP status and the 64-bit
    result. The exception table entry for PQAP(TAPQ) can be avoided
    if the T bit for the APFT facility is set only if test_facility(15)
    indicated that the facility is present.
    
    Integrate ap_query_function into ap_query queue to avoid calling
    PQAP(TAPQ) twice.
    
    Reviewed-by: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 00468c8d0781..2e0a21f84f3d 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -75,15 +75,6 @@ struct ap_queue_status {
 	unsigned int pad2		: 16;
 } __packed;
 
-#define AP_QUEUE_STATUS_INVALID \
-		{ 1, 1, 1, 0xF, 1, 0xFF, 0xFFFF }
-
-static inline
-int ap_queue_status_invalid_test(struct ap_queue_status *status)
-{
-	struct ap_queue_status invalid = AP_QUEUE_STATUS_INVALID;
-	return !(memcmp(status, &invalid, sizeof(struct ap_queue_status)));
-}
 
 #define AP_MAX_BITS 31
 static inline int ap_test_bit(unsigned int *ptr, unsigned int nr)

commit c50a160c176aadfbbbeed69a55caf1040b22692e
Author: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
Date:   Wed Jun 17 16:19:15 2015 +0200

    s390/zcrypt: Fixed reset and interrupt handling of AP queues
    
    In case of request timeouts an AP queue reset will be triggered to
    recover and reinitialize the AP queue. The previous behavior was an
    immediate reset execution regardless of current/pending requests.
    Due to newly changed firmware behavior the reset may be delayed, based
    on the priority of pending request. The device driver's waiting time
    frame was limited, hence it did not received the reset response. As a
    consequence interrupts would not be enabled afterwards.
    
    The RAPQ (queue reset) and AQIC (interrupt control) commands will be
    treated fully asynchronous now. The device driver will check the reset and
    interrupt states periodically, thus it can handle the reinitialization
    properly.
    
    Signed-off-by: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 2737d261a324..00468c8d0781 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -32,11 +32,13 @@
 
 #define AP_DEVICES 64		/* Number of AP devices. */
 #define AP_DOMAINS 256		/* Number of AP domains. */
-#define AP_MAX_RESET 90		/* Maximum number of resets. */
 #define AP_RESET_TIMEOUT (HZ*0.7)	/* Time in ticks for reset timeouts. */
 #define AP_CONFIG_TIME 30	/* Time in seconds between AP bus rescans. */
 #define AP_POLL_TIME 1		/* Time in ticks between receive polls. */
 
+#define AP_POLL_IMMEDIATELY	1 /* continue running poll tasklet */
+#define AP_POLL_AFTER_TIMEOUT	2 /* run poll tasklet again after timout */
+
 extern int ap_domain_index;
 
 /**
@@ -135,6 +137,14 @@ static inline int ap_test_bit(unsigned int *ptr, unsigned int nr)
 #define AP_RESET_IGNORE	0	/* request timeout will be ignored */
 #define AP_RESET_ARMED	1	/* request timeout timer is active */
 #define AP_RESET_DO	2	/* AP reset required */
+#define AP_RESET_IN_PROGRESS	3	/* AP reset in progress */
+
+/*
+ * AP interrupt states
+ */
+#define AP_INTR_DISABLED	0	/* AP interrupt disabled */
+#define AP_INTR_ENABLED		1	/* AP interrupt enabled */
+#define AP_INTR_IN_PROGRESS	3	/* AP interrupt in progress */
 
 struct ap_device;
 struct ap_message;
@@ -168,6 +178,7 @@ struct ap_device {
 	struct timer_list timeout;	/* Timer for request timeouts. */
 	int reset;			/* Reset required after req. timeout. */
 
+	int interrupt;			/* indicate if interrupts are enabled */
 	int queue_count;		/* # messages currently on AP queue. */
 
 	struct list_head pendingq;	/* List of message sent to AP queue. */

commit bdea1f1bb273383312f0eca56241794b06ed4205
Author: Ingo Tuchscherer <ingo.tuchscherer@de.ibm.com>
Date:   Fri Jan 23 14:56:25 2015 +0100

    s390/zcrypt: Add support for new crypto express (CEX5S) adapter.
    
    Extends the generic cryptographic device driver (zcrypt)
    to support the Crypto Express 5S adapter.
    
    Signed-off-by: Ingo Tuchscherer <ingo.tuchscherer@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 055a0f956d17..2737d261a324 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -117,6 +117,7 @@ static inline int ap_test_bit(unsigned int *ptr, unsigned int nr)
 #define AP_DEVICE_TYPE_CEX3A	8
 #define AP_DEVICE_TYPE_CEX3C	9
 #define AP_DEVICE_TYPE_CEX4	10
+#define AP_DEVICE_TYPE_CEX5	11
 
 /*
  * Known function facilities

commit 42f4dd613fe808676126472bbe1283e452201148
Author: Ingo Tuchscherer <ingo.tuchscherer@de.ibm.com>
Date:   Thu Oct 2 14:48:46 2014 +0200

    s390/zcrypt: Toleration of new crypto hardware
    
    The zcrypt device driver will accept the new crypto adapter
    in toleration mode. A new sysfs attribute 'raw_hwtype' will
    expose the raw hardware type.
    
    Signed-off-by: Ingo Tuchscherer <ingo.tuchscherer@de.ibm.com>
    Signed-off-by: Harald Freudenberger <freude@linux.vnet.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index db92e9fa5c07..055a0f956d17 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -161,6 +161,7 @@ struct ap_device {
 	ap_qid_t qid;			/* AP queue id. */
 	int queue_depth;		/* AP queue depth.*/
 	int device_type;		/* AP device type. */
+	int raw_hwtype;			/* AP raw hardware type. */
 	unsigned int functions;		/* AP device function bitfield. */
 	int unregistered;		/* marks AP device as unregistered */
 	struct timer_list timeout;	/* Timer for request timeouts. */

commit 170387a8877b2c12fee5ae901be1ef4693d06094
Author: Ingo Tuchscherer <ingo.tuchscherer@de.ibm.com>
Date:   Mon Sep 8 13:24:13 2014 +0200

    s390/zcrypt: support for extended number of ap domains
    
    Extends the number of ap domains within the zcrypt device driver up to 256.
    AP domains in the range 00..255 will be detected.
    
    Signed-off-by: Ingo Tuchscherer <ingo.tuchscherer@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 6405ae24a7a6..db92e9fa5c07 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -31,7 +31,7 @@
 #include <linux/types.h>
 
 #define AP_DEVICES 64		/* Number of AP devices. */
-#define AP_DOMAINS 16		/* Number of AP domains. */
+#define AP_DOMAINS 256		/* Number of AP domains. */
 #define AP_MAX_RESET 90		/* Maximum number of resets. */
 #define AP_RESET_TIMEOUT (HZ*0.7)	/* Time in ticks for reset timeouts. */
 #define AP_CONFIG_TIME 30	/* Time in seconds between AP bus rescans. */
@@ -45,9 +45,9 @@ extern int ap_domain_index;
  */
 typedef unsigned int ap_qid_t;
 
-#define AP_MKQID(_device,_queue) (((_device) & 63) << 8 | ((_queue) & 15))
+#define AP_MKQID(_device, _queue) (((_device) & 63) << 8 | ((_queue) & 255))
 #define AP_QID_DEVICE(_qid) (((_qid) >> 8) & 63)
-#define AP_QID_QUEUE(_qid) ((_qid) & 15)
+#define AP_QID_QUEUE(_qid) ((_qid) & 255)
 
 /**
  * structy ap_queue_status - Holds the AP queue status.

commit 91f3e3eaba4413e76ce8e12e3ef10525a889142f
Author: Ingo Tuchscherer <ingo.tuchscherer@de.ibm.com>
Date:   Wed Nov 20 10:47:13 2013 +0100

    s390/zcrypt: add support for EP11 coprocessor cards
    
    This feature extends the generic cryptographic device driver (zcrypt)
    with a new capability to service EP11 requests for the Crypto Express4S
    card in EP11 (Enterprise PKCS#11 mode) coprocessor mode.
    
    Signed-off-by: Ingo Tuchscherer <ingo.tuchscherer@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 685f6cc022f9..6405ae24a7a6 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -33,7 +33,7 @@
 #define AP_DEVICES 64		/* Number of AP devices. */
 #define AP_DOMAINS 16		/* Number of AP domains. */
 #define AP_MAX_RESET 90		/* Maximum number of resets. */
-#define AP_RESET_TIMEOUT (HZ/2)	/* Time in ticks for reset timeouts. */
+#define AP_RESET_TIMEOUT (HZ*0.7)	/* Time in ticks for reset timeouts. */
 #define AP_CONFIG_TIME 30	/* Time in seconds between AP bus rescans. */
 #define AP_POLL_TIME 1		/* Time in ticks between receive polls. */
 
@@ -125,6 +125,8 @@ static inline int ap_test_bit(unsigned int *ptr, unsigned int nr)
 #define AP_FUNC_CRT4K 2
 #define AP_FUNC_COPRO 3
 #define AP_FUNC_ACCEL 4
+#define AP_FUNC_EP11  5
+#define AP_FUNC_APXA  6
 
 /*
  * AP reset flag states

commit dabecb2933f7ae901c88cb10c71ab38ca7dfc38f
Author: Holger Dengler <hd@linux.vnet.ibm.com>
Date:   Mon Sep 10 21:34:26 2012 +0200

    s390/zcryt: Handle AP configuration changes
    
    Detect external AP bus configuration changes and request
    an AP device rescan.
    
    Signed-off-by: Holger Dengler <hd@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index e9b963e7d59d..685f6cc022f9 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -231,6 +231,7 @@ int ap_recv(ap_qid_t, unsigned long long *, void *, size_t);
 void ap_queue_message(struct ap_device *ap_dev, struct ap_message *ap_msg);
 void ap_cancel_message(struct ap_device *ap_dev, struct ap_message *ap_msg);
 void ap_flush_queue(struct ap_device *ap_dev);
+void ap_bus_force_rescan(void);
 
 int ap_module_init(void);
 void ap_module_exit(void);

commit 1e2076f4527b5b0854d0ebe60102b6710a9ba64c
Author: Holger Dengler <hd@linux.vnet.ibm.com>
Date:   Tue Aug 28 16:48:29 2012 +0200

    s390/zcrypt: Add support for CEX4 crypto card
    
    New zcrypt module supports IBM CryptoExpress 4 cards.
    
    Signed-off-by: Holger Dengler <hd@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index e49bcf4d4081..e9b963e7d59d 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -116,6 +116,7 @@ static inline int ap_test_bit(unsigned int *ptr, unsigned int nr)
 #define AP_DEVICE_TYPE_CEX2C	7
 #define AP_DEVICE_TYPE_CEX3A	8
 #define AP_DEVICE_TYPE_CEX3C	9
+#define AP_DEVICE_TYPE_CEX4	10
 
 /*
  * Known function facilities

commit b26bd9413c8359bd9f5c9bd1b789a10ebd2bb484
Author: Holger Dengler <hd@linux.vnet.ibm.com>
Date:   Tue Aug 28 16:43:48 2012 +0200

    s390/ap: Add functiton facility information as AP device attribute.
    
    Add the function facility information as new ap_device and sysfs
    attribute. Also make the number of requests in device
    queue and in device driver queue accessible in sysfs.
    
    Reviewed-by: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
    Signed-off-by: Holger Dengler <hd@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 5018f66dada5..e49bcf4d4081 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -117,6 +117,14 @@ static inline int ap_test_bit(unsigned int *ptr, unsigned int nr)
 #define AP_DEVICE_TYPE_CEX3A	8
 #define AP_DEVICE_TYPE_CEX3C	9
 
+/*
+ * Known function facilities
+ */
+#define AP_FUNC_MEX4K 1
+#define AP_FUNC_CRT4K 2
+#define AP_FUNC_COPRO 3
+#define AP_FUNC_ACCEL 4
+
 /*
  * AP reset flag states
  */
@@ -150,6 +158,7 @@ struct ap_device {
 	ap_qid_t qid;			/* AP queue id. */
 	int queue_depth;		/* AP queue depth.*/
 	int device_type;		/* AP device type. */
+	unsigned int functions;		/* AP device function bitfield. */
 	int unregistered;		/* marks AP device as unregistered */
 	struct timer_list timeout;	/* Timer for request timeouts. */
 	int reset;			/* Reset required after req. timeout. */
@@ -225,6 +234,4 @@ void ap_flush_queue(struct ap_device *ap_dev);
 int ap_module_init(void);
 void ap_module_exit(void);
 
-int ap_4096_commands_available(ap_qid_t qid);
-
 #endif /* _AP_BUS_H_ */

commit 75014550516b147e5f530b84c71496341e036d6f
Author: Holger Dengler <hd@linux.vnet.ibm.com>
Date:   Tue Aug 28 16:41:50 2012 +0200

    s390/ap: configuration information exploitation
    
    Query AP configuration information. Improve performance of AP bus
    scans by skipping AP device probing, if the AP deviec is not
    configured.
    
    Reviewed-by: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
    Signed-off-by: Holger Dengler <hd@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 52d61995af88..5018f66dada5 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -1,5 +1,5 @@
 /*
- * Copyright IBM Corp. 2006
+ * Copyright IBM Corp. 2006, 2012
  * Author(s): Cornelia Huck <cornelia.huck@de.ibm.com>
  *	      Martin Schwidefsky <schwidefsky@de.ibm.com>
  *	      Ralph Wuerthner <rwuerthn@de.ibm.com>
@@ -83,13 +83,12 @@ int ap_queue_status_invalid_test(struct ap_queue_status *status)
 	return !(memcmp(status, &invalid, sizeof(struct ap_queue_status)));
 }
 
-#define MAX_AP_FACILITY 31
-
-static inline int test_ap_facility(unsigned int function, unsigned int nr)
+#define AP_MAX_BITS 31
+static inline int ap_test_bit(unsigned int *ptr, unsigned int nr)
 {
-	if (nr > MAX_AP_FACILITY)
+	if (nr > AP_MAX_BITS)
 		return 0;
-	return function & (unsigned int)(0x80000000 >> nr);
+	return (*ptr & (0x80000000u >> nr)) != 0;
 }
 
 #define AP_RESPONSE_NORMAL		0x00
@@ -183,6 +182,17 @@ struct ap_message {
 			struct ap_message *);
 };
 
+struct ap_config_info {
+	unsigned int special_command:1;
+	unsigned int ap_extended:1;
+	unsigned char reserved1:6;
+	unsigned char reserved2[15];
+	unsigned int apm[8];		/* AP ID mask */
+	unsigned int aqm[8];		/* AP queue mask */
+	unsigned int adm[8];		/* AP domain mask */
+	unsigned char reserved4[16];
+} __packed;
+
 #define AP_DEVICE(dt)					\
 	.dev_type=(dt),					\
 	.match_flags=AP_DEVICE_ID_MATCH_DEVICE_TYPE,

commit a53c8fab3f87c995c30ac226a03af95361243144
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Fri Jul 20 11:15:04 2012 +0200

    s390/comments: unify copyright messages and remove file names
    
    Remove the file name from the comment at top of many files. In most
    cases the file name was wrong anyway, so it's rather pointless.
    
    Also unify the IBM copyright statement. We did have a lot of sightly
    different statements and wanted to change them one after another
    whenever a file gets touched. However that never happened. Instead
    people start to take the old/"wrong" statements to use as a template
    for new files.
    So unify all of them in one go.
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 726fc65809d8..52d61995af88 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -1,7 +1,5 @@
 /*
- * linux/drivers/s390/crypto/ap_bus.h
- *
- * Copyright (C) 2006 IBM Corporation
+ * Copyright IBM Corp. 2006
  * Author(s): Cornelia Huck <cornelia.huck@de.ibm.com>
  *	      Martin Schwidefsky <schwidefsky@de.ibm.com>
  *	      Ralph Wuerthner <rwuerthn@de.ibm.com>

commit 54a8f5611d9189b3a8fbc9ace59a7a276eee58d8
Author: Holger Dengler <hd@linux.vnet.ibm.com>
Date:   Wed May 16 14:08:22 2012 +0200

    s390/ap: move receive callback to message struct
    
    Move the receive callback from zdev_driver to ap_message structure to
    get a more flexible asynchronous ap message handling.
    
    Signed-off-by: Holger Dengler <hd@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index d960a6309eec..726fc65809d8 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -136,9 +136,6 @@ struct ap_driver {
 
 	int (*probe)(struct ap_device *);
 	void (*remove)(struct ap_device *);
-	/* receive is called from tasklet context */
-	void (*receive)(struct ap_device *, struct ap_message *,
-			struct ap_message *);
 	int request_timeout;		/* request timeout in jiffies */
 };
 
@@ -183,6 +180,9 @@ struct ap_message {
 
 	void *private;			/* ap driver private pointer. */
 	unsigned int special:1;		/* Used for special commands. */
+	/* receive is called from tasklet context */
+	void (*receive)(struct ap_device *, struct ap_message *,
+			struct ap_message *);
 };
 
 #define AP_DEVICE(dt)					\
@@ -199,6 +199,7 @@ static inline void ap_init_message(struct ap_message *ap_msg)
 	ap_msg->psmid = 0;
 	ap_msg->length = 0;
 	ap_msg->special = 0;
+	ap_msg->receive = NULL;
 }
 
 /*

commit 6bed05bcbc8e5932e06059f0c3be1acdf30a39d4
Author: Holger Dengler <hd@linux.vnet.ibm.com>
Date:   Sun Jul 24 10:48:25 2011 +0200

    [S390] ap: toleration support for ap device type 10
    
    Add toleration support for ap devices with device type 10.
    
    Signed-off-by: Holger Dengler <hd@linux.vnet.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 08b9738285b4..d960a6309eec 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -6,6 +6,7 @@
  *	      Martin Schwidefsky <schwidefsky@de.ibm.com>
  *	      Ralph Wuerthner <rwuerthn@de.ibm.com>
  *	      Felix Beck <felix.beck@de.ibm.com>
+ *	      Holger Dengler <hd@linux.vnet.ibm.com>
  *
  * Adjunct processor bus header file.
  *
@@ -72,7 +73,26 @@ struct ap_queue_status {
 	unsigned int int_enabled	: 1;
 	unsigned int response_code	: 8;
 	unsigned int pad2		: 16;
-};
+} __packed;
+
+#define AP_QUEUE_STATUS_INVALID \
+		{ 1, 1, 1, 0xF, 1, 0xFF, 0xFFFF }
+
+static inline
+int ap_queue_status_invalid_test(struct ap_queue_status *status)
+{
+	struct ap_queue_status invalid = AP_QUEUE_STATUS_INVALID;
+	return !(memcmp(status, &invalid, sizeof(struct ap_queue_status)));
+}
+
+#define MAX_AP_FACILITY 31
+
+static inline int test_ap_facility(unsigned int function, unsigned int nr)
+{
+	if (nr > MAX_AP_FACILITY)
+		return 0;
+	return function & (unsigned int)(0x80000000 >> nr);
+}
 
 #define AP_RESPONSE_NORMAL		0x00
 #define AP_RESPONSE_Q_NOT_AVAIL		0x01

commit b1f933da570576d1f290ea4dc9b896404cbd285d
Author: Felix Beck <felix.beck@de.ibm.com>
Date:   Wed Jan 5 12:47:44 2011 +0100

    [S390] zcrypt: Introduce check for 4096 bit support.
    
    Implemented an asm in the ap bus and made it accessible for the card
    specific parts of the zcrypt driver. Thus when a cex3a is recognized
    a check can be performed to dermine whether the card supports 4096 bit
    RSA keys.
    
    Signed-off-by: Felix Beck <felix.beck@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 4785d07cd447..08b9738285b4 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -196,4 +196,6 @@ void ap_flush_queue(struct ap_device *ap_dev);
 int ap_module_init(void);
 void ap_module_exit(void);
 
+int ap_4096_commands_available(ap_qid_t qid);
+
 #endif /* _AP_BUS_H_ */

commit ffda4f719866bb10a8edb7de3e6bf564ff7c3de4
Author: Felix Beck <felix.beck@de.ibm.com>
Date:   Mon Dec 7 12:51:56 2009 +0100

    [S390] zcrypt: add support for cex3 device types
    
    This patch renames the CEX2C2 and CEX2A2 types to CEX3 device types.
    
    Signed-off-by: Felix Beck <felix.beck@de.ibm.com>
    Signed-off-by: Ralph Wuerthner <ralph.wuerthner@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index c37466713b32..4785d07cd447 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -97,8 +97,8 @@ struct ap_queue_status {
 #define AP_DEVICE_TYPE_PCIXCC	5
 #define AP_DEVICE_TYPE_CEX2A	6
 #define AP_DEVICE_TYPE_CEX2C	7
-#define AP_DEVICE_TYPE_CEX2A2	8
-#define AP_DEVICE_TYPE_CEX2C2	9
+#define AP_DEVICE_TYPE_CEX3A	8
+#define AP_DEVICE_TYPE_CEX3C	9
 
 /*
  * AP reset flag states

commit a6a5d73a56540b5e59dff83bc8f2b2725591346a
Author: Felix Beck <felix.beck@de.ibm.com>
Date:   Mon Dec 7 12:51:55 2009 +0100

    [S390] zcrypt: special command support for cex3 exploitation
    
    Support for special command is implemented in the AP Bus in the NQAP
    function __ap_send. This is extended for a further parameter special.
    When set, the special bit, in GR0 will be set. Therefor the ap_message
    struct is extended for a further bit. Thus calling functions of
    __ap_send can use the special parameter in ap_message to give to
    __ap_send. Affected is in the first place ap_queue_message, which is
    called by the actual card driver. The second part of this support is
    that the card driver for the CEX3C needs to set this special bit, when
    an according CPRB is sent to the driver.
    
    Signed-off-by: Felix Beck <felix.beck@de.ibm.com>
    Signed-off-by: Ralph Wuerthner <ralph.wuerthner@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index fcf2497556dd..c37466713b32 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -87,6 +87,7 @@ struct ap_queue_status {
 #define AP_RESPONSE_INDEX_TOO_BIG	0x11
 #define AP_RESPONSE_NO_FIRST_PART	0x13
 #define AP_RESPONSE_MESSAGE_TOO_BIG	0x15
+#define AP_RESPONSE_REQ_FAC_NOT_INST	0x16
 
 /*
  * Known device types
@@ -161,6 +162,7 @@ struct ap_message {
 	size_t length;			/* Message length. */
 
 	void *private;			/* ap driver private pointer. */
+	unsigned int special:1;		/* Used for special commands. */
 };
 
 #define AP_DEVICE(dt)					\
@@ -176,6 +178,7 @@ static inline void ap_init_message(struct ap_message *ap_msg)
 {
 	ap_msg->psmid = 0;
 	ap_msg->length = 0;
+	ap_msg->special = 0;
 }
 
 /*

commit 468ffddf19c1417947cac931c240b0d600e4b5bf
Author: Felix Beck <felix.beck@de.ibm.com>
Date:   Mon Dec 7 12:51:54 2009 +0100

    [S390] zcrypt: initialize ap_messages for cex3 exploitation
    
    AP messages need to be initialized, before they will be used. Values
    will be zeroized. This will be needed later when introducing support
    for the special commands.
    
    Signed-off-by: Felix Beck <felix.beck@de.ibm.com>
    Signed-off-by: Ralph Wuerthner <ralph.wuerthner@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index a35362241805..fcf2497556dd 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -167,6 +167,17 @@ struct ap_message {
 	.dev_type=(dt),					\
 	.match_flags=AP_DEVICE_ID_MATCH_DEVICE_TYPE,
 
+/**
+ * ap_init_message() - Initialize ap_message.
+ * Initialize a message before using. Otherwise this might result in
+ * unexpected behaviour.
+ */
+static inline void ap_init_message(struct ap_message *ap_msg)
+{
+	ap_msg->psmid = 0;
+	ap_msg->length = 0;
+}
+
 /*
  * Note: don't use ap_send/ap_recv after using ap_queue_message
  * for the first time. Otherwise the ap message queue will get

commit cb17a6364a29b4dfe5bbb00696032fb63d780157
Author: Felix Beck <felix.beck@de.ibm.com>
Date:   Thu Dec 25 13:38:41 2008 +0100

    [S390] zcrypt: Use of Thin Interrupts
    
    When the machine supports AP adapter interrupts polling will be
    switched off at module initialization and the driver will work in
    interrupt mode.
    
    Signed-off-by: Felix Beck <felix.beck@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 446378b308fc..a35362241805 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -5,6 +5,7 @@
  * Author(s): Cornelia Huck <cornelia.huck@de.ibm.com>
  *	      Martin Schwidefsky <schwidefsky@de.ibm.com>
  *	      Ralph Wuerthner <rwuerthn@de.ibm.com>
+ *	      Felix Beck <felix.beck@de.ibm.com>
  *
  * Adjunct processor bus header file.
  *
@@ -67,7 +68,8 @@ struct ap_queue_status {
 	unsigned int queue_empty	: 1;
 	unsigned int replies_waiting	: 1;
 	unsigned int queue_full		: 1;
-	unsigned int pad1		: 5;
+	unsigned int pad1		: 4;
+	unsigned int int_enabled	: 1;
 	unsigned int response_code	: 8;
 	unsigned int pad2		: 16;
 };
@@ -78,6 +80,8 @@ struct ap_queue_status {
 #define AP_RESPONSE_DECONFIGURED	0x03
 #define AP_RESPONSE_CHECKSTOPPED	0x04
 #define AP_RESPONSE_BUSY		0x05
+#define AP_RESPONSE_INVALID_ADDRESS	0x06
+#define AP_RESPONSE_OTHERWISE_CHANGED	0x07
 #define AP_RESPONSE_Q_FULL		0x10
 #define AP_RESPONSE_NO_PENDING_REPLY	0x10
 #define AP_RESPONSE_INDEX_TOO_BIG	0x11

commit d8c33d32a4c4f326579e7c2960492512de74662b
Author: Ralph Wuerthner <ralph.wuerthner@de.ibm.com>
Date:   Mon Jul 14 09:59:10 2008 +0200

    [S390] zcrypt: Add additional card IDs to CEX2C and CEX2A
    
    Add support for new micro code load of CEX2C and CEX2A adapters,
    which uses different IDs.  This patch just adds the IDs to the
    existing drivers.
    
    Signed-off-by: Ralph Wuerthner <ralph.wuerthner@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index c1e1200c43fc..446378b308fc 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -92,6 +92,8 @@ struct ap_queue_status {
 #define AP_DEVICE_TYPE_PCIXCC	5
 #define AP_DEVICE_TYPE_CEX2A	6
 #define AP_DEVICE_TYPE_CEX2C	7
+#define AP_DEVICE_TYPE_CEX2A2	8
+#define AP_DEVICE_TYPE_CEX2C2	9
 
 /*
  * AP reset flag states

commit 1749a81d629b1295b38071914728cc2e72066f4d
Author: Felix Beck <felix.beck@de.ibm.com>
Date:   Thu Apr 17 07:46:28 2008 +0200

    [S390] zcrypt: Comments and kernel-doc cleanup
    
    Comments, which suggested to be kernel-doc but were not in the right
    formatting, have been corrected. Additionally some minor cleanup in
    the comments has been done.
    
    Signed-off-by: Felix Beck <felix.beck@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 87c2d6442875..c1e1200c43fc 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -50,6 +50,15 @@ typedef unsigned int ap_qid_t;
 #define AP_QID_QUEUE(_qid) ((_qid) & 15)
 
 /**
+ * structy ap_queue_status - Holds the AP queue status.
+ * @queue_empty: Shows if queue is empty
+ * @replies_waiting: Waiting replies
+ * @queue_full: Is 1 if the queue is full
+ * @pad: A 4 bit pad
+ * @int_enabled: Shows if interrupts are enabled for the AP
+ * @response_conde: Holds the 8 bit response code
+ * @pad2: A 16 bit pad
+ *
  * The ap queue status word is returned by all three AP functions
  * (PQAP, NQAP and DQAP).  There's a set of flags in the first
  * byte, followed by a 1 byte response code.
@@ -75,7 +84,7 @@ struct ap_queue_status {
 #define AP_RESPONSE_NO_FIRST_PART	0x13
 #define AP_RESPONSE_MESSAGE_TOO_BIG	0x15
 
-/**
+/*
  * Known device types
  */
 #define AP_DEVICE_TYPE_PCICC	3
@@ -84,7 +93,7 @@ struct ap_queue_status {
 #define AP_DEVICE_TYPE_CEX2A	6
 #define AP_DEVICE_TYPE_CEX2C	7
 
-/**
+/*
  * AP reset flag states
  */
 #define AP_RESET_IGNORE	0	/* request timeout will be ignored */
@@ -152,7 +161,7 @@ struct ap_message {
 	.dev_type=(dt),					\
 	.match_flags=AP_DEVICE_ID_MATCH_DEVICE_TYPE,
 
-/**
+/*
  * Note: don't use ap_send/ap_recv after using ap_queue_message
  * for the first time. Otherwise the ap message queue will get
  * confused.

commit af512ed0f8a7e6a3c6fd93b2b5882c8e837a6939
Author: Ralph Wuerthner <rwuerthn@de.ibm.com>
Date:   Tue Jul 10 11:24:19 2007 +0200

    [S390] zcrypt: fix request timeout handling
    
    Under very high load zcrypt requests may timeout while waiting on the
    request queue. Modify zcrypt that timeouts are based on crypto adapter
    responses. A timeout occurs only if a crypto adapter does not respond
    within a given time frame to sumitted requests.
    
    Signed-off-by: Ralph Wuerthner <rwuerthn@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 008559ea742b..87c2d6442875 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -33,6 +33,7 @@
 #define AP_DEVICES 64		/* Number of AP devices. */
 #define AP_DOMAINS 16		/* Number of AP domains. */
 #define AP_MAX_RESET 90		/* Maximum number of resets. */
+#define AP_RESET_TIMEOUT (HZ/2)	/* Time in ticks for reset timeouts. */
 #define AP_CONFIG_TIME 30	/* Time in seconds between AP bus rescans. */
 #define AP_POLL_TIME 1		/* Time in ticks between receive polls. */
 
@@ -83,6 +84,13 @@ struct ap_queue_status {
 #define AP_DEVICE_TYPE_CEX2A	6
 #define AP_DEVICE_TYPE_CEX2C	7
 
+/**
+ * AP reset flag states
+ */
+#define AP_RESET_IGNORE	0	/* request timeout will be ignored */
+#define AP_RESET_ARMED	1	/* request timeout timer is active */
+#define AP_RESET_DO	2	/* AP reset required */
+
 struct ap_device;
 struct ap_message;
 
@@ -95,6 +103,7 @@ struct ap_driver {
 	/* receive is called from tasklet context */
 	void (*receive)(struct ap_device *, struct ap_message *,
 			struct ap_message *);
+	int request_timeout;		/* request timeout in jiffies */
 };
 
 #define to_ap_drv(x) container_of((x), struct ap_driver, driver)
@@ -112,6 +121,8 @@ struct ap_device {
 	int queue_depth;		/* AP queue depth.*/
 	int device_type;		/* AP device type. */
 	int unregistered;		/* marks AP device as unregistered */
+	struct timer_list timeout;	/* Timer for request timeouts. */
+	int reset;			/* Reset required after req. timeout. */
 
 	int queue_count;		/* # messages currently on AP queue. */
 

commit cf352ce0b9104dc6a1c11df52db9f910f1f6cd2e
Author: Ralph Wuerthner <rwuerthn@de.ibm.com>
Date:   Mon Mar 19 13:19:14 2007 +0100

    [S390] zcrypt: fix possible dead lock in AP bus module
    
    AP bus module uses bus_for_each_dev() in software interrupt context to
    poll for completed requests which might cause dead locks. Solution: use
    private AP device list for polling in software interrupt context.
    
    Signed-off-by: Ralph Wuerthner <rwuerthn@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 83b69c01cd6e..008559ea742b 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -106,6 +106,7 @@ struct ap_device {
 	struct device device;
 	struct ap_driver *drv;		/* Pointer to AP device driver. */
 	spinlock_t lock;		/* Per device lock. */
+	struct list_head list;		/* private list of all AP devices. */
 
 	ap_qid_t qid;			/* AP queue id. */
 	int queue_depth;		/* AP queue depth.*/

commit 1534c3820c26aca4e2567f97b8add8bea40e7e2b
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Wed Sep 20 15:58:25 2006 +0200

    [S390] zcrypt adjunct processor bus.
    
    Add a bus for the adjunct processor interface. Up to 64 devices can
    be connect to the ap bus interface, each device with 16 domains. That
    makes 1024 message queues. The interface is asynchronous, the answer
    to a message sent to a queue needs to be received at some later point
    in time. Unfortunately the interface does not provide interrupts when
    a message reply is pending. So the ap bus needs to implement some
    fancy polling, each active queue is polled once per 1/HZ second or
    continuously if an idle cpus exsists and the poll thread is activ
    (see poll_thread parameter).
    
    The ap bus uses the sysfs path /sys/bus/ap and has two bus attributes,
    ap_domain and config_time. The ap_domain selects one of the 16 domains
    to be used for this system. This limits the maximum number of ap devices
    to 64. The config_time attribute contains the number of seconds between
    two ap bus scans to find new devices.
    
    The ap bus uses the modalias entries of the form "ap:tN" to autoload
    the ap driver for hardware type N. Currently known types are:
    3 - PCICC, 4 - PCICA, 5 - PCIXCC, 6 - CEX2A and 7 - CEX2C.
    
    Signed-off-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Ralph Wuerthner <rwuerthn@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
new file mode 100644
index 000000000000..83b69c01cd6e
--- /dev/null
+++ b/drivers/s390/crypto/ap_bus.h
@@ -0,0 +1,158 @@
+/*
+ * linux/drivers/s390/crypto/ap_bus.h
+ *
+ * Copyright (C) 2006 IBM Corporation
+ * Author(s): Cornelia Huck <cornelia.huck@de.ibm.com>
+ *	      Martin Schwidefsky <schwidefsky@de.ibm.com>
+ *	      Ralph Wuerthner <rwuerthn@de.ibm.com>
+ *
+ * Adjunct processor bus header file.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _AP_BUS_H_
+#define _AP_BUS_H_
+
+#include <linux/device.h>
+#include <linux/mod_devicetable.h>
+#include <linux/types.h>
+
+#define AP_DEVICES 64		/* Number of AP devices. */
+#define AP_DOMAINS 16		/* Number of AP domains. */
+#define AP_MAX_RESET 90		/* Maximum number of resets. */
+#define AP_CONFIG_TIME 30	/* Time in seconds between AP bus rescans. */
+#define AP_POLL_TIME 1		/* Time in ticks between receive polls. */
+
+extern int ap_domain_index;
+
+/**
+ * The ap_qid_t identifier of an ap queue. It contains a
+ * 6 bit device index and a 4 bit queue index (domain).
+ */
+typedef unsigned int ap_qid_t;
+
+#define AP_MKQID(_device,_queue) (((_device) & 63) << 8 | ((_queue) & 15))
+#define AP_QID_DEVICE(_qid) (((_qid) >> 8) & 63)
+#define AP_QID_QUEUE(_qid) ((_qid) & 15)
+
+/**
+ * The ap queue status word is returned by all three AP functions
+ * (PQAP, NQAP and DQAP).  There's a set of flags in the first
+ * byte, followed by a 1 byte response code.
+ */
+struct ap_queue_status {
+	unsigned int queue_empty	: 1;
+	unsigned int replies_waiting	: 1;
+	unsigned int queue_full		: 1;
+	unsigned int pad1		: 5;
+	unsigned int response_code	: 8;
+	unsigned int pad2		: 16;
+};
+
+#define AP_RESPONSE_NORMAL		0x00
+#define AP_RESPONSE_Q_NOT_AVAIL		0x01
+#define AP_RESPONSE_RESET_IN_PROGRESS	0x02
+#define AP_RESPONSE_DECONFIGURED	0x03
+#define AP_RESPONSE_CHECKSTOPPED	0x04
+#define AP_RESPONSE_BUSY		0x05
+#define AP_RESPONSE_Q_FULL		0x10
+#define AP_RESPONSE_NO_PENDING_REPLY	0x10
+#define AP_RESPONSE_INDEX_TOO_BIG	0x11
+#define AP_RESPONSE_NO_FIRST_PART	0x13
+#define AP_RESPONSE_MESSAGE_TOO_BIG	0x15
+
+/**
+ * Known device types
+ */
+#define AP_DEVICE_TYPE_PCICC	3
+#define AP_DEVICE_TYPE_PCICA	4
+#define AP_DEVICE_TYPE_PCIXCC	5
+#define AP_DEVICE_TYPE_CEX2A	6
+#define AP_DEVICE_TYPE_CEX2C	7
+
+struct ap_device;
+struct ap_message;
+
+struct ap_driver {
+	struct device_driver driver;
+	struct ap_device_id *ids;
+
+	int (*probe)(struct ap_device *);
+	void (*remove)(struct ap_device *);
+	/* receive is called from tasklet context */
+	void (*receive)(struct ap_device *, struct ap_message *,
+			struct ap_message *);
+};
+
+#define to_ap_drv(x) container_of((x), struct ap_driver, driver)
+
+int ap_driver_register(struct ap_driver *, struct module *, char *);
+void ap_driver_unregister(struct ap_driver *);
+
+struct ap_device {
+	struct device device;
+	struct ap_driver *drv;		/* Pointer to AP device driver. */
+	spinlock_t lock;		/* Per device lock. */
+
+	ap_qid_t qid;			/* AP queue id. */
+	int queue_depth;		/* AP queue depth.*/
+	int device_type;		/* AP device type. */
+	int unregistered;		/* marks AP device as unregistered */
+
+	int queue_count;		/* # messages currently on AP queue. */
+
+	struct list_head pendingq;	/* List of message sent to AP queue. */
+	int pendingq_count;		/* # requests on pendingq list. */
+	struct list_head requestq;	/* List of message yet to be sent. */
+	int requestq_count;		/* # requests on requestq list. */
+	int total_request_count;	/* # requests ever for this AP device. */
+
+	struct ap_message *reply;	/* Per device reply message. */
+
+	void *private;			/* ap driver private pointer. */
+};
+
+#define to_ap_dev(x) container_of((x), struct ap_device, device)
+
+struct ap_message {
+	struct list_head list;		/* Request queueing. */
+	unsigned long long psmid;	/* Message id. */
+	void *message;			/* Pointer to message buffer. */
+	size_t length;			/* Message length. */
+
+	void *private;			/* ap driver private pointer. */
+};
+
+#define AP_DEVICE(dt)					\
+	.dev_type=(dt),					\
+	.match_flags=AP_DEVICE_ID_MATCH_DEVICE_TYPE,
+
+/**
+ * Note: don't use ap_send/ap_recv after using ap_queue_message
+ * for the first time. Otherwise the ap message queue will get
+ * confused.
+ */
+int ap_send(ap_qid_t, unsigned long long, void *, size_t);
+int ap_recv(ap_qid_t, unsigned long long *, void *, size_t);
+
+void ap_queue_message(struct ap_device *ap_dev, struct ap_message *ap_msg);
+void ap_cancel_message(struct ap_device *ap_dev, struct ap_message *ap_msg);
+void ap_flush_queue(struct ap_device *ap_dev);
+
+int ap_module_init(void);
+void ap_module_exit(void);
+
+#endif /* _AP_BUS_H_ */
