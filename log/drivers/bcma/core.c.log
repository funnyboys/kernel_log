commit 972da7ec493b16b1d06c27832fad971466859fad
Author: Rafał Miłecki <zajec5@gmail.com>
Date:   Mon Jun 17 18:34:32 2013 +0200

    bcma: update core (en|dis)abling functions
    
    Broadocm updated their code, this may be needed for newer hardware or
    some corner cases.
    
    Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/bcma/core.c b/drivers/bcma/core.c
index 17b26ce7e051..37a5ffe673d5 100644
--- a/drivers/bcma/core.c
+++ b/drivers/bcma/core.c
@@ -9,6 +9,25 @@
 #include <linux/export.h>
 #include <linux/bcma/bcma.h>
 
+static bool bcma_core_wait_value(struct bcma_device *core, u16 reg, u32 mask,
+				 u32 value, int timeout)
+{
+	unsigned long deadline = jiffies + timeout;
+	u32 val;
+
+	do {
+		val = bcma_aread32(core, reg);
+		if ((val & mask) == value)
+			return true;
+		cpu_relax();
+		udelay(10);
+	} while (!time_after_eq(jiffies, deadline));
+
+	bcma_warn(core->bus, "Timeout waiting for register 0x%04X!\n", reg);
+
+	return false;
+}
+
 bool bcma_core_is_enabled(struct bcma_device *core)
 {
 	if ((bcma_aread32(core, BCMA_IOCTL) & (BCMA_IOCTL_CLK | BCMA_IOCTL_FGC))
@@ -25,13 +44,15 @@ void bcma_core_disable(struct bcma_device *core, u32 flags)
 	if (bcma_aread32(core, BCMA_RESET_CTL) & BCMA_RESET_CTL_RESET)
 		return;
 
-	bcma_awrite32(core, BCMA_IOCTL, flags);
-	bcma_aread32(core, BCMA_IOCTL);
-	udelay(10);
+	bcma_core_wait_value(core, BCMA_RESET_ST, ~0, 0, 300);
 
 	bcma_awrite32(core, BCMA_RESET_CTL, BCMA_RESET_CTL_RESET);
 	bcma_aread32(core, BCMA_RESET_CTL);
 	udelay(1);
+
+	bcma_awrite32(core, BCMA_IOCTL, flags);
+	bcma_aread32(core, BCMA_IOCTL);
+	udelay(10);
 }
 EXPORT_SYMBOL_GPL(bcma_core_disable);
 
@@ -43,6 +64,7 @@ int bcma_core_enable(struct bcma_device *core, u32 flags)
 	bcma_aread32(core, BCMA_IOCTL);
 
 	bcma_awrite32(core, BCMA_RESET_CTL, 0);
+	bcma_aread32(core, BCMA_RESET_CTL);
 	udelay(1);
 
 	bcma_awrite32(core, BCMA_IOCTL, (BCMA_IOCTL_CLK | flags));

commit c722839cc856cee5f7f1bb833a0f36c86d0bbe8f
Author: Rafał Miłecki <zajec5@gmail.com>
Date:   Tue Feb 26 10:02:23 2013 +0100

    bcma: implement disabling PLLs
    
    Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/bcma/core.c b/drivers/bcma/core.c
index 03bbe104338f..17b26ce7e051 100644
--- a/drivers/bcma/core.c
+++ b/drivers/bcma/core.c
@@ -104,7 +104,13 @@ void bcma_core_pll_ctl(struct bcma_device *core, u32 req, u32 status, bool on)
 		if (i)
 			bcma_err(core->bus, "PLL enable timeout\n");
 	} else {
-		bcma_warn(core->bus, "Disabling PLL not supported yet!\n");
+		/*
+		 * Mask the PLL but don't wait for it to be disabled. PLL may be
+		 * shared between cores and will be still up if there is another
+		 * core using it.
+		 */
+		bcma_mask32(core, BCMA_CLKCTLST, ~req);
+		bcma_read32(core, BCMA_CLKCTLST);
 	}
 }
 EXPORT_SYMBOL_GPL(bcma_core_pll_ctl);

commit 1fd41a65f19bdabb31549af00ce23d4c5c14781a
Author: Rafał Miłecki <zajec5@gmail.com>
Date:   Tue Sep 25 10:17:22 2012 +0200

    bcma: change delays to follow timers-howto guide
    
    Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
    Cc: Hauke Mehrtens <hauke@hauke-m.de>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/bcma/core.c b/drivers/bcma/core.c
index 63c8b470536f..03bbe104338f 100644
--- a/drivers/bcma/core.c
+++ b/drivers/bcma/core.c
@@ -65,7 +65,7 @@ void bcma_core_set_clockmode(struct bcma_device *core,
 	switch (clkmode) {
 	case BCMA_CLKMODE_FAST:
 		bcma_set32(core, BCMA_CLKCTLST, BCMA_CLKCTLST_FORCEHT);
-		udelay(64);
+		usleep_range(64, 300);
 		for (i = 0; i < 1500; i++) {
 			if (bcma_read32(core, BCMA_CLKCTLST) &
 			    BCMA_CLKCTLST_HAVEHT) {

commit 3d9d8af330a891f141db420115238f01e4c6ece7
Author: Rafał Miłecki <zajec5@gmail.com>
Date:   Thu Jul 5 22:07:32 2012 +0200

    bcma: use custom printing functions
    
    Having bus number printed makes it much easier to anaylze logs on
    systems with more buses. For example Netgear WNDR4500 has 3 AMBA buses
    in total, which makes standard log really messy.
    
    Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/bcma/core.c b/drivers/bcma/core.c
index bc6e89212ad3..63c8b470536f 100644
--- a/drivers/bcma/core.c
+++ b/drivers/bcma/core.c
@@ -75,7 +75,7 @@ void bcma_core_set_clockmode(struct bcma_device *core,
 			udelay(10);
 		}
 		if (i)
-			pr_err("HT force timeout\n");
+			bcma_err(core->bus, "HT force timeout\n");
 		break;
 	case BCMA_CLKMODE_DYNAMIC:
 		bcma_set32(core, BCMA_CLKCTLST, ~BCMA_CLKCTLST_FORCEHT);
@@ -102,9 +102,9 @@ void bcma_core_pll_ctl(struct bcma_device *core, u32 req, u32 status, bool on)
 			udelay(10);
 		}
 		if (i)
-			pr_err("PLL enable timeout\n");
+			bcma_err(core->bus, "PLL enable timeout\n");
 	} else {
-		pr_warn("Disabling PLL not supported yet!\n");
+		bcma_warn(core->bus, "Disabling PLL not supported yet!\n");
 	}
 }
 EXPORT_SYMBOL_GPL(bcma_core_pll_ctl);
@@ -120,8 +120,8 @@ u32 bcma_core_dma_translation(struct bcma_device *core)
 		else
 			return BCMA_DMA_TRANSLATION_DMA32_CMT;
 	default:
-		pr_err("DMA translation unknown for host %d\n",
-		       core->bus->hosttype);
+		bcma_err(core->bus, "DMA translation unknown for host %d\n",
+			 core->bus->hosttype);
 	}
 	return BCMA_DMA_TRANSLATION_NONE;
 }

commit 044e68c0cd01a70fd4929ce19ce52ba5df839b22
Author: Nathan Hintz <nlhintz@hotmail.com>
Date:   Fri May 4 21:56:36 2012 -0700

    bcma: Add flush for BCMA_RESET_CTL write
    
    Adds a missing read to flush the previous write (per the Broadcom SDK).
    
    Signed-off-by: Nathan Hintz <nlhintz@hotmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/bcma/core.c b/drivers/bcma/core.c
index 98e243cd0479..bc6e89212ad3 100644
--- a/drivers/bcma/core.c
+++ b/drivers/bcma/core.c
@@ -30,6 +30,7 @@ void bcma_core_disable(struct bcma_device *core, u32 flags)
 	udelay(10);
 
 	bcma_awrite32(core, BCMA_RESET_CTL, BCMA_RESET_CTL_RESET);
+	bcma_aread32(core, BCMA_RESET_CTL);
 	udelay(1);
 }
 EXPORT_SYMBOL_GPL(bcma_core_disable);

commit 0b2948eeb128e259b7903b12de79d6886d43eb11
Author: Hauke Mehrtens <hauke@hauke-m.de>
Date:   Sun Apr 29 02:18:49 2012 +0200

    bcma: implement setting core clock mode to dynamic
    
    This patch is based on code from _ai_clkctl_cc() in brcmsmac.
    
    Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
    Tested-by: Arend van Spriel <arend@broadcom.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/bcma/core.c b/drivers/bcma/core.c
index 893f6e0c759f..98e243cd0479 100644
--- a/drivers/bcma/core.c
+++ b/drivers/bcma/core.c
@@ -77,7 +77,7 @@ void bcma_core_set_clockmode(struct bcma_device *core,
 			pr_err("HT force timeout\n");
 		break;
 	case BCMA_CLKMODE_DYNAMIC:
-		pr_warn("Dynamic clockmode not supported yet!\n");
+		bcma_set32(core, BCMA_CLKCTLST, ~BCMA_CLKCTLST_FORCEHT);
 		break;
 	}
 }

commit 44a8e3772f53a5337e74700fc166a3d4c3ef59a2
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jul 27 21:21:04 2011 -0400

    bcma: fix implicit use of export.h contents
    
    Fix in advance, or we will get things like this:
    
    drivers/bcma/core.c:20: warning: data definition has no type or storage class
    drivers/bcma/core.c:20: warning: type defaults to 'int' in declaration of 'EXPORT_SYMBOL_GPL'
    drivers/bcma/core.c:20: warning: parameter names (without types) in function declaration
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/bcma/core.c b/drivers/bcma/core.c
index 189a97b51be9..893f6e0c759f 100644
--- a/drivers/bcma/core.c
+++ b/drivers/bcma/core.c
@@ -6,6 +6,7 @@
  */
 
 #include "bcma_private.h"
+#include <linux/export.h>
 #include <linux/bcma/bcma.h>
 
 bool bcma_core_is_enabled(struct bcma_device *core)

commit ecd177c21640e92b059a71139f5850243a8f0942
Author: Hauke Mehrtens <hauke@hauke-m.de>
Date:   Sat Jul 23 01:20:08 2011 +0200

    bcma: add SOC bus
    
    This patch adds support for using bcma on a Broadcom SoC as the system
    bus. An SoC like the bcm4716 could register this bus and use it to
    searches for the bcma cores and register the devices on this bus.
    
    BCMA_HOSTTYPE_NONE was intended for SoCs at first but BCMA_HOSTTYPE_SOC
    is a better name.
    
    Acked-by: Rafał Miłecki <zajec5@gmail.com>
    Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/bcma/core.c b/drivers/bcma/core.c
index 4a04a49cc06d..189a97b51be9 100644
--- a/drivers/bcma/core.c
+++ b/drivers/bcma/core.c
@@ -110,6 +110,8 @@ EXPORT_SYMBOL_GPL(bcma_core_pll_ctl);
 u32 bcma_core_dma_translation(struct bcma_device *core)
 {
 	switch (core->bus->hosttype) {
+	case BCMA_HOSTTYPE_SOC:
+		return 0;
 	case BCMA_HOSTTYPE_PCI:
 		if (bcma_aread32(core, BCMA_IOST) & BCMA_IOST_DMA64)
 			return BCMA_DMA_TRANSLATION_DMA64_CMT;

commit 05aec233367262a43dbf0b615099757162e36f88
Author: Rafał Miłecki <zajec5@gmail.com>
Date:   Wed Jul 20 19:52:15 2011 +0200

    bcma: inform drivers about translation bits needed for the core
    
    When using DMA, drivers need to pass special translation info to the
    hardware.
    
    Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/bcma/core.c b/drivers/bcma/core.c
index 2d8506dbca76..4a04a49cc06d 100644
--- a/drivers/bcma/core.c
+++ b/drivers/bcma/core.c
@@ -106,3 +106,19 @@ void bcma_core_pll_ctl(struct bcma_device *core, u32 req, u32 status, bool on)
 	}
 }
 EXPORT_SYMBOL_GPL(bcma_core_pll_ctl);
+
+u32 bcma_core_dma_translation(struct bcma_device *core)
+{
+	switch (core->bus->hosttype) {
+	case BCMA_HOSTTYPE_PCI:
+		if (bcma_aread32(core, BCMA_IOST) & BCMA_IOST_DMA64)
+			return BCMA_DMA_TRANSLATION_DMA64_CMT;
+		else
+			return BCMA_DMA_TRANSLATION_DMA32_CMT;
+	default:
+		pr_err("DMA translation unknown for host %d\n",
+		       core->bus->hosttype);
+	}
+	return BCMA_DMA_TRANSLATION_NONE;
+}
+EXPORT_SYMBOL(bcma_core_dma_translation);

commit 6f53912fc317ab130bd910c5c30420a21ea38115
Author: Rafał Miłecki <zajec5@gmail.com>
Date:   Sun Jul 17 01:06:05 2011 +0200

    bcma: allow enabling PLL
    
    Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/bcma/core.c b/drivers/bcma/core.c
index 0686b1b5f27a..2d8506dbca76 100644
--- a/drivers/bcma/core.c
+++ b/drivers/bcma/core.c
@@ -81,3 +81,28 @@ void bcma_core_set_clockmode(struct bcma_device *core,
 	}
 }
 EXPORT_SYMBOL_GPL(bcma_core_set_clockmode);
+
+void bcma_core_pll_ctl(struct bcma_device *core, u32 req, u32 status, bool on)
+{
+	u16 i;
+
+	WARN_ON(req & ~BCMA_CLKCTLST_EXTRESREQ);
+	WARN_ON(status & ~BCMA_CLKCTLST_EXTRESST);
+
+	if (on) {
+		bcma_set32(core, BCMA_CLKCTLST, req);
+		for (i = 0; i < 10000; i++) {
+			if ((bcma_read32(core, BCMA_CLKCTLST) & status) ==
+			    status) {
+				i = 0;
+				break;
+			}
+			udelay(10);
+		}
+		if (i)
+			pr_err("PLL enable timeout\n");
+	} else {
+		pr_warn("Disabling PLL not supported yet!\n");
+	}
+}
+EXPORT_SYMBOL_GPL(bcma_core_pll_ctl);

commit 7424dd0d03502b9844b96bf6efd0716b79c36607
Author: Rafał Miłecki <zajec5@gmail.com>
Date:   Sun Jul 17 01:06:04 2011 +0200

    bcma: allow setting FAST clockmode for a core
    
    Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/bcma/core.c b/drivers/bcma/core.c
index 1ec7d4528dd0..0686b1b5f27a 100644
--- a/drivers/bcma/core.c
+++ b/drivers/bcma/core.c
@@ -50,3 +50,34 @@ int bcma_core_enable(struct bcma_device *core, u32 flags)
 	return 0;
 }
 EXPORT_SYMBOL_GPL(bcma_core_enable);
+
+void bcma_core_set_clockmode(struct bcma_device *core,
+			     enum bcma_clkmode clkmode)
+{
+	u16 i;
+
+	WARN_ON(core->id.id != BCMA_CORE_CHIPCOMMON &&
+		core->id.id != BCMA_CORE_PCIE &&
+		core->id.id != BCMA_CORE_80211);
+
+	switch (clkmode) {
+	case BCMA_CLKMODE_FAST:
+		bcma_set32(core, BCMA_CLKCTLST, BCMA_CLKCTLST_FORCEHT);
+		udelay(64);
+		for (i = 0; i < 1500; i++) {
+			if (bcma_read32(core, BCMA_CLKCTLST) &
+			    BCMA_CLKCTLST_HAVEHT) {
+				i = 0;
+				break;
+			}
+			udelay(10);
+		}
+		if (i)
+			pr_err("HT force timeout\n");
+		break;
+	case BCMA_CLKMODE_DYNAMIC:
+		pr_warn("Dynamic clockmode not supported yet!\n");
+		break;
+	}
+}
+EXPORT_SYMBOL_GPL(bcma_core_set_clockmode);

commit e3ae0cac00042d7fb76914c30c5f991f918e65b4
Author: Arend van Spriel <arend@broadcom.com>
Date:   Thu Jun 9 20:07:20 2011 +0200

    drivers: bcma: export bcma_core_disable() function
    
    In the brcm80211 driver we disable the 80211 core when the driver is
    'down'. The bcma_core_disable() function exactly does the same as
    our implementation so exporting this function makes sense.
    
    Cc: linux-wireless@vger.kernel.org
    Cc: Rafal Milecki <zajec5@gmail.com>
    Signed-off-by: Arend van Spriel <arend@broadcom.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/bcma/core.c b/drivers/bcma/core.c
index ced379f7b371..1ec7d4528dd0 100644
--- a/drivers/bcma/core.c
+++ b/drivers/bcma/core.c
@@ -19,7 +19,7 @@ bool bcma_core_is_enabled(struct bcma_device *core)
 }
 EXPORT_SYMBOL_GPL(bcma_core_is_enabled);
 
-static void bcma_core_disable(struct bcma_device *core, u32 flags)
+void bcma_core_disable(struct bcma_device *core, u32 flags)
 {
 	if (bcma_aread32(core, BCMA_RESET_CTL) & BCMA_RESET_CTL_RESET)
 		return;
@@ -31,6 +31,7 @@ static void bcma_core_disable(struct bcma_device *core, u32 flags)
 	bcma_awrite32(core, BCMA_RESET_CTL, BCMA_RESET_CTL_RESET);
 	udelay(1);
 }
+EXPORT_SYMBOL_GPL(bcma_core_disable);
 
 int bcma_core_enable(struct bcma_device *core, u32 flags)
 {

commit 8369ae33b705222aa05ab53c7d6b4458f4ed161b
Author: Rafał Miłecki <zajec5@gmail.com>
Date:   Mon May 9 18:56:46 2011 +0200

    bcma: add Broadcom specific AMBA bus driver
    
    Broadcom has released cards based on a new AMBA-based bus type. From a
    programming point of view, this new bus type differs from AMBA and does
    not use AMBA common registers. It also differs enough from SSB. We
    decided that a new bus driver is needed to keep the code clean.
    
    In its current form, the driver detects devices present on the bus and
    registers them in the system. It allows registering BCMA drivers for
    specified bus devices and provides them basic operations. The bus driver
    itself includes two important bus managing drivers: ChipCommon core
    driver and PCI(c) core driver. They are early used to allow correct
    initialization.
    
    Currently code is limited to supporting buses on PCI(e) devices, however
    the driver is designed to be used also on other hosts. The host
    abstraction layer is implemented and already used for PCI(e).
    
    Support for PCI(e) hosts is working and seems to be stable (access to
    80211 core was tested successfully on a few devices). We can still
    optimize it by using some fixed windows, but this can be done later
    without affecting any external code. Windows are just ranges in MMIO
    used for accessing cores on the bus.
    
    Cc: Greg KH <greg@kroah.com>
    Cc: Michael Büsch <mb@bu3sch.de>
    Cc: Larry Finger <Larry.Finger@lwfinger.net>
    Cc: George Kashperko <george@znau.edu.ua>
    Cc: Arend van Spriel <arend@broadcom.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Andy Botting <andy@andybotting.com>
    Cc: linuxdriverproject <devel@linuxdriverproject.org>
    Cc: linux-kernel@vger.kernel.org <linux-kernel@vger.kernel.org>
    Signed-off-by: Rafał Miłecki <zajec5@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/drivers/bcma/core.c b/drivers/bcma/core.c
new file mode 100644
index 000000000000..ced379f7b371
--- /dev/null
+++ b/drivers/bcma/core.c
@@ -0,0 +1,51 @@
+/*
+ * Broadcom specific AMBA
+ * Core ops
+ *
+ * Licensed under the GNU/GPL. See COPYING for details.
+ */
+
+#include "bcma_private.h"
+#include <linux/bcma/bcma.h>
+
+bool bcma_core_is_enabled(struct bcma_device *core)
+{
+	if ((bcma_aread32(core, BCMA_IOCTL) & (BCMA_IOCTL_CLK | BCMA_IOCTL_FGC))
+	    != BCMA_IOCTL_CLK)
+		return false;
+	if (bcma_aread32(core, BCMA_RESET_CTL) & BCMA_RESET_CTL_RESET)
+		return false;
+	return true;
+}
+EXPORT_SYMBOL_GPL(bcma_core_is_enabled);
+
+static void bcma_core_disable(struct bcma_device *core, u32 flags)
+{
+	if (bcma_aread32(core, BCMA_RESET_CTL) & BCMA_RESET_CTL_RESET)
+		return;
+
+	bcma_awrite32(core, BCMA_IOCTL, flags);
+	bcma_aread32(core, BCMA_IOCTL);
+	udelay(10);
+
+	bcma_awrite32(core, BCMA_RESET_CTL, BCMA_RESET_CTL_RESET);
+	udelay(1);
+}
+
+int bcma_core_enable(struct bcma_device *core, u32 flags)
+{
+	bcma_core_disable(core, flags);
+
+	bcma_awrite32(core, BCMA_IOCTL, (BCMA_IOCTL_CLK | BCMA_IOCTL_FGC | flags));
+	bcma_aread32(core, BCMA_IOCTL);
+
+	bcma_awrite32(core, BCMA_RESET_CTL, 0);
+	udelay(1);
+
+	bcma_awrite32(core, BCMA_IOCTL, (BCMA_IOCTL_CLK | flags));
+	bcma_aread32(core, BCMA_IOCTL);
+	udelay(1);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(bcma_core_enable);
