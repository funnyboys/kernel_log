commit cc2550b421aa30e3da67e5a7f6d14f3ecd3527b3
Author: afzal mohammed <afzal.mohd.ma@gmail.com>
Date:   Thu Feb 27 16:29:02 2020 +0530

    clocksource: Replace setup_irq() by request_irq()
    
    request_irq() is preferred over setup_irq(). The early boot setup_irq()
    invocations happen either via 'init_IRQ()' or 'time_init()', while
    memory allocators are ready by 'mm_init()'.
    
    Per tglx[1], setup_irq() existed in olden days when allocators were not
    ready by the time early interrupts were initialized.
    
    Hence replace setup_irq() by request_irq().
    
    Seldom remove_irq() usage has been observed coupled with setup_irq(),
    wherever that has been found, it too has been replaced by free_irq().
    
    A build error that was reported by kbuild test robot <lkp@intel.com>
    in the previous version of the patch also has been fixed.
    
    [1] https://lkml.kernel.org/r/alpine.DEB.2.20.1710191609480.1971@nanos
    
    Signed-off-by: afzal mohammed <afzal.mohd.ma@gmail.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/91961c77c1cf93d41523f5e1ac52043f32f97077.1582799709.git.afzal.mohd.ma@gmail.com

diff --git a/drivers/clocksource/timer-integrator-ap.c b/drivers/clocksource/timer-integrator-ap.c
index c90a69c7b5fa..b0fcbaac58b0 100644
--- a/drivers/clocksource/timer-integrator-ap.c
+++ b/drivers/clocksource/timer-integrator-ap.c
@@ -123,13 +123,6 @@ static struct clock_event_device integrator_clockevent = {
 	.rating			= 300,
 };
 
-static struct irqaction integrator_timer_irq = {
-	.name		= "timer",
-	.flags		= IRQF_TIMER | IRQF_IRQPOLL,
-	.handler	= integrator_timer_interrupt,
-	.dev_id		= &integrator_clockevent,
-};
-
 static int integrator_clockevent_init(unsigned long inrate,
 				      void __iomem *base, int irq)
 {
@@ -149,7 +142,9 @@ static int integrator_clockevent_init(unsigned long inrate,
 	timer_reload = rate / HZ;
 	writel(ctrl, clkevt_base + TIMER_CTRL);
 
-	ret = setup_irq(irq, &integrator_timer_irq);
+	ret = request_irq(irq, integrator_timer_interrupt,
+			  IRQF_TIMER | IRQF_IRQPOLL, "timer",
+			  &integrator_clockevent);
 	if (ret)
 		return ret;
 

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/clocksource/timer-integrator-ap.c b/drivers/clocksource/timer-integrator-ap.c
index 19fb7de4b928..c90a69c7b5fa 100644
--- a/drivers/clocksource/timer-integrator-ap.c
+++ b/drivers/clocksource/timer-integrator-ap.c
@@ -1,21 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Integrator/AP timer driver
  * Copyright (C) 2000-2003 Deep Blue Solutions Ltd
  * Copyright (c) 2014, Linaro Limited
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 #include <linux/clk.h>

commit 5eb73c831171115d3b4347e1e7124a5a35d8086c
Author: Yangtao Li <tiny.windzz@gmail.com>
Date:   Sun Nov 25 00:00:49 2018 -0500

    clocksource/drivers/integrator-ap: Add missing of_node_put()
    
    The function of_find_node_by_path() acquires a reference to the node
    returned by it and that reference needs to be dropped by its caller.
    
    integrator_ap_timer_init_of() doesn't do that.  The pri_node and the
    sec_node are used as an identifier to compare against the current
    node, so we can directly drop the refcount after getting the node from
    the path as it is not used as pointer.
    
    By dropping the refcount right after getting it, a single variable is
    needed instead of two.
    
    Fix this by use a single variable and drop the refcount right after
    of_find_node_by_path().
    
    Signed-off-by: Yangtao Li <tiny.windzz@gmail.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/timer-integrator-ap.c b/drivers/clocksource/timer-integrator-ap.c
index 76e526f58620..19fb7de4b928 100644
--- a/drivers/clocksource/timer-integrator-ap.c
+++ b/drivers/clocksource/timer-integrator-ap.c
@@ -181,8 +181,7 @@ static int __init integrator_ap_timer_init_of(struct device_node *node)
 	int irq;
 	struct clk *clk;
 	unsigned long rate;
-	struct device_node *pri_node;
-	struct device_node *sec_node;
+	struct device_node *alias_node;
 
 	base = of_io_request_and_map(node, 0, "integrator-timer");
 	if (IS_ERR(base))
@@ -204,7 +203,18 @@ static int __init integrator_ap_timer_init_of(struct device_node *node)
 		return err;
 	}
 
-	pri_node = of_find_node_by_path(path);
+	alias_node = of_find_node_by_path(path);
+
+	/*
+	 * The pointer is used as an identifier not as a pointer, we
+	 * can drop the refcount on the of__node immediately after
+	 * getting it.
+	 */
+	of_node_put(alias_node);
+
+	if (node == alias_node)
+		/* The primary timer lacks IRQ, use as clocksource */
+		return integrator_clocksource_init(rate, base);
 
 	err = of_property_read_string(of_aliases,
 				"arm,timer-secondary", &path);
@@ -213,14 +223,11 @@ static int __init integrator_ap_timer_init_of(struct device_node *node)
 		return err;
 	}
 
+	alias_node = of_find_node_by_path(path);
 
-	sec_node = of_find_node_by_path(path);
-
-	if (node == pri_node)
-		/* The primary timer lacks IRQ, use as clocksource */
-		return integrator_clocksource_init(rate, base);
+	of_node_put(alias_node);
 
-	if (node == sec_node) {
+	if (node == alias_node) {
 		/* The secondary timer will drive the clock event */
 		irq = irq_of_parse_and_map(node, 0);
 		return integrator_clockevent_init(rate, base, irq);

commit 2a4849d2674b965cd9eb7e6c010b7c240fb9d218
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 27 20:52:14 2018 -0500

    clocksource: Convert to using %pOFn instead of device_node.name
    
    In preparation to remove the node name pointer from struct device_node,
    convert printf users to use the %pOFn format specifier.
    
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/timer-integrator-ap.c b/drivers/clocksource/timer-integrator-ap.c
index 62d24690ba02..76e526f58620 100644
--- a/drivers/clocksource/timer-integrator-ap.c
+++ b/drivers/clocksource/timer-integrator-ap.c
@@ -190,7 +190,7 @@ static int __init integrator_ap_timer_init_of(struct device_node *node)
 
 	clk = of_clk_get(node, 0);
 	if (IS_ERR(clk)) {
-		pr_err("No clock for %s\n", node->name);
+		pr_err("No clock for %pOFn\n", node);
 		return PTR_ERR(clk);
 	}
 	clk_prepare_enable(clk);

commit 8fce3dc5c5d6f6301f67311fa79f333902b58cea
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Sep 15 21:42:59 2017 +0200

    clocksource/integrator: Fix section mismatch warning
    
    gcc-4.6 and older fail to inline integrator_clocksource_init, so they
    end up showing a harmless warning:
    
    WARNING: vmlinux.o(.text+0x4aa94c): Section mismatch in reference from the function integrator_clocksource_init() to the function .init.text:clocksource_mmio_init()
    The function integrator_clocksource_init() references
    the function __init clocksource_mmio_init().
    This is often because integrator_clocksource_init lacks a __init
    annotation or the annotation of clocksource_mmio_init is wrong.
    
    Add the missing __init annotation that makes it build cleanly with all
    compilers.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Thierry Reding <treding@nvidia.com>
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: http://lkml.kernel.org/r/20170915194310.1170514-1-arnd@arndb.de

diff --git a/drivers/clocksource/timer-integrator-ap.c b/drivers/clocksource/timer-integrator-ap.c
index 2ff64d9d4fb3..62d24690ba02 100644
--- a/drivers/clocksource/timer-integrator-ap.c
+++ b/drivers/clocksource/timer-integrator-ap.c
@@ -36,8 +36,8 @@ static u64 notrace integrator_read_sched_clock(void)
 	return -readl(sched_clk_base + TIMER_VALUE);
 }
 
-static int integrator_clocksource_init(unsigned long inrate,
-				       void __iomem *base)
+static int __init integrator_clocksource_init(unsigned long inrate,
+					      void __iomem *base)
 {
 	u32 ctrl = TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC;
 	unsigned long rate = inrate;

commit 1727339590fdb5a1ded881b540cd32121278d414
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 26 16:56:11 2017 +0200

    clocksource/drivers: Rename CLOCKSOURCE_OF_DECLARE to TIMER_OF_DECLARE
    
    The CLOCKSOURCE_OF_DECLARE macro is used widely for the timers to declare the
    clocksource at early stage. However, this macro is also used to initialize
    the clockevent if any, or the clockevent only.
    
    It was originally suggested to declare another macro to initialize a
    clockevent, so in order to separate the two entities even they belong to the
    same IP. This was not accepted because of the impact on the DT where splitting
    a clocksource/clockevent definition does not make sense as it is a Linux
    concept not a hardware description.
    
    On the other side, the clocksource has not interrupt declared while the
    clockevent has, so it is easy from the driver to know if the description is
    for a clockevent or a clocksource, IOW it could be implemented at the driver
    level.
    
    So instead of dealing with a named clocksource macro, let's use a more generic
    one: TIMER_OF_DECLARE.
    
    The patch has not functional changes.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Matthias Brugger <matthias.bgg@gmail.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/clocksource/timer-integrator-ap.c b/drivers/clocksource/timer-integrator-ap.c
index 04ad3066e190..2ff64d9d4fb3 100644
--- a/drivers/clocksource/timer-integrator-ap.c
+++ b/drivers/clocksource/timer-integrator-ap.c
@@ -232,5 +232,5 @@ static int __init integrator_ap_timer_init_of(struct device_node *node)
 	return 0;
 }
 
-CLOCKSOURCE_OF_DECLARE(integrator_ap_timer, "arm,integrator-timer",
+TIMER_OF_DECLARE(integrator_ap_timer, "arm,integrator-timer",
 		       integrator_ap_timer_init_of);

commit ac9ce6d1a0cc29767932d9f2fcb8ebc97c5106c8
Author: Rafał Miłecki <rafal@milecki.pl>
Date:   Thu Mar 9 10:47:10 2017 +0100

    clocksource: Add missing line break to error messages
    
    Printing with pr_* functions requires adding line break manually.
    
    Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/timer-integrator-ap.c b/drivers/clocksource/timer-integrator-ap.c
index df6e672afc04..04ad3066e190 100644
--- a/drivers/clocksource/timer-integrator-ap.c
+++ b/drivers/clocksource/timer-integrator-ap.c
@@ -200,7 +200,7 @@ static int __init integrator_ap_timer_init_of(struct device_node *node)
 	err = of_property_read_string(of_aliases,
 				"arm,timer-primary", &path);
 	if (err) {
-		pr_warn("Failed to read property");
+		pr_warn("Failed to read property\n");
 		return err;
 	}
 
@@ -209,7 +209,7 @@ static int __init integrator_ap_timer_init_of(struct device_node *node)
 	err = of_property_read_string(of_aliases,
 				"arm,timer-secondary", &path);
 	if (err) {
-		pr_warn("Failed to read property");		
+		pr_warn("Failed to read property\n");
 		return err;
 	}
 

commit 177cf6e52b0a1a382b9892d3cc9aafd6e7c5943f
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Tue Jun 7 00:27:44 2016 +0200

    clocksources: Switch back to the clksrc table
    
    All the clocksource drivers's init function are now converted to return
    an error code. CLOCKSOURCE_OF_DECLARE is no longer used as well as the
    clksrc-of table.
    
    Let's convert back the names:
     - CLOCKSOURCE_OF_DECLARE_RET => CLOCKSOURCE_OF_DECLARE
     - clksrc-of-ret              => clksrc-of
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    
    For exynos_mct and samsung_pwm_timer:
    Acked-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    
    For arch/arc:
    Acked-by: Vineet Gupta <vgupta@synopsys.com>
    
    For mediatek driver:
    Acked-by: Matthias Brugger <matthias.bgg@gmail.com>
    
    For the Rockchip-part
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    
    For STi :
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    
    For the mps2-timer.c and versatile.c changes:
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    
    For the OXNAS part :
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    
    For LPC32xx driver:
    Acked-by: Sylvain Lemieux <slemieux.tyco@gmail.com>
    
    For Broadcom Kona timer change:
    Acked-by: Ray Jui <ray.jui@broadcom.com>
    
    For Sun4i and Sun5i:
    Acked-by: Chen-Yu Tsai <wens@csie.org>
    
    For Meson6:
    Acked-by: Carlo Caione <carlo@caione.org>
    
    For Keystone:
    Acked-by: Santosh Shilimkar <ssantosh@kernel.org>
    
    For NPS:
    Acked-by: Noam Camus <noamca@mellanox.com>
    
    For bcm2835:
    Acked-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/clocksource/timer-integrator-ap.c b/drivers/clocksource/timer-integrator-ap.c
index 675faceab5d6..df6e672afc04 100644
--- a/drivers/clocksource/timer-integrator-ap.c
+++ b/drivers/clocksource/timer-integrator-ap.c
@@ -232,5 +232,5 @@ static int __init integrator_ap_timer_init_of(struct device_node *node)
 	return 0;
 }
 
-CLOCKSOURCE_OF_DECLARE_RET(integrator_ap_timer, "arm,integrator-timer",
+CLOCKSOURCE_OF_DECLARE(integrator_ap_timer, "arm,integrator-timer",
 		       integrator_ap_timer_init_of);

commit 76804d052316d3562c58934200c932243f312c07
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Mon Jun 6 23:27:24 2016 +0200

    clocksource/drivers/integrator-ap: Convert init function to return error
    
    The init functions do not return any error. They behave as the following:
    
      - panic, thus leading to a kernel crash while another timer may work and
           make the system boot up correctly
    
      or
    
      - print an error and let the caller unaware if the state of the system
    
    Change that by converting the init functions to return an error conforming
    to the CLOCKSOURCE_OF_RET prototype.
    
    Proper error handling (rollback, errno value) will be changed later case
    by case, thus this change just return back an error or success in the init
    function.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/timer-integrator-ap.c b/drivers/clocksource/timer-integrator-ap.c
index 3f59ac2180dc..675faceab5d6 100644
--- a/drivers/clocksource/timer-integrator-ap.c
+++ b/drivers/clocksource/timer-integrator-ap.c
@@ -36,11 +36,12 @@ static u64 notrace integrator_read_sched_clock(void)
 	return -readl(sched_clk_base + TIMER_VALUE);
 }
 
-static void integrator_clocksource_init(unsigned long inrate,
-					void __iomem *base)
+static int integrator_clocksource_init(unsigned long inrate,
+				       void __iomem *base)
 {
 	u32 ctrl = TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC;
 	unsigned long rate = inrate;
+	int ret;
 
 	if (rate >= 1500000) {
 		rate /= 16;
@@ -50,11 +51,15 @@ static void integrator_clocksource_init(unsigned long inrate,
 	writel(0xffff, base + TIMER_LOAD);
 	writel(ctrl, base + TIMER_CTRL);
 
-	clocksource_mmio_init(base + TIMER_VALUE, "timer2",
-			rate, 200, 16, clocksource_mmio_readl_down);
+	ret = clocksource_mmio_init(base + TIMER_VALUE, "timer2",
+				    rate, 200, 16, clocksource_mmio_readl_down);
+	if (ret)
+		return ret;
 
 	sched_clk_base = base;
 	sched_clock_register(integrator_read_sched_clock, 16, rate);
+
+	return 0;
 }
 
 static unsigned long timer_reload;
@@ -138,11 +143,12 @@ static struct irqaction integrator_timer_irq = {
 	.dev_id		= &integrator_clockevent,
 };
 
-static void integrator_clockevent_init(unsigned long inrate,
-				void __iomem *base, int irq)
+static int integrator_clockevent_init(unsigned long inrate,
+				      void __iomem *base, int irq)
 {
 	unsigned long rate = inrate;
 	unsigned int ctrl = 0;
+	int ret;
 
 	clkevt_base = base;
 	/* Calculate and program a divisor */
@@ -156,14 +162,18 @@ static void integrator_clockevent_init(unsigned long inrate,
 	timer_reload = rate / HZ;
 	writel(ctrl, clkevt_base + TIMER_CTRL);
 
-	setup_irq(irq, &integrator_timer_irq);
+	ret = setup_irq(irq, &integrator_timer_irq);
+	if (ret)
+		return ret;
+
 	clockevents_config_and_register(&integrator_clockevent,
 					rate,
 					1,
 					0xffffU);
+	return 0;
 }
 
-static void __init integrator_ap_timer_init_of(struct device_node *node)
+static int __init integrator_ap_timer_init_of(struct device_node *node)
 {
 	const char *path;
 	void __iomem *base;
@@ -176,12 +186,12 @@ static void __init integrator_ap_timer_init_of(struct device_node *node)
 
 	base = of_io_request_and_map(node, 0, "integrator-timer");
 	if (IS_ERR(base))
-		return;
+		return PTR_ERR(base);
 
 	clk = of_clk_get(node, 0);
 	if (IS_ERR(clk)) {
 		pr_err("No clock for %s\n", node->name);
-		return;
+		return PTR_ERR(clk);
 	}
 	clk_prepare_enable(clk);
 	rate = clk_get_rate(clk);
@@ -189,31 +199,38 @@ static void __init integrator_ap_timer_init_of(struct device_node *node)
 
 	err = of_property_read_string(of_aliases,
 				"arm,timer-primary", &path);
-	if (WARN_ON(err))
-		return;
+	if (err) {
+		pr_warn("Failed to read property");
+		return err;
+	}
+
 	pri_node = of_find_node_by_path(path);
+
 	err = of_property_read_string(of_aliases,
 				"arm,timer-secondary", &path);
-	if (WARN_ON(err))
-		return;
+	if (err) {
+		pr_warn("Failed to read property");		
+		return err;
+	}
+
+
 	sec_node = of_find_node_by_path(path);
 
-	if (node == pri_node) {
+	if (node == pri_node)
 		/* The primary timer lacks IRQ, use as clocksource */
-		integrator_clocksource_init(rate, base);
-		return;
-	}
+		return integrator_clocksource_init(rate, base);
 
 	if (node == sec_node) {
 		/* The secondary timer will drive the clock event */
 		irq = irq_of_parse_and_map(node, 0);
-		integrator_clockevent_init(rate, base, irq);
-		return;
+		return integrator_clockevent_init(rate, base, irq);
 	}
 
 	pr_info("Timer @%p unused\n", base);
 	clk_disable_unprepare(clk);
+
+	return 0;
 }
 
-CLOCKSOURCE_OF_DECLARE(integrator_ap_timer, "arm,integrator-timer",
+CLOCKSOURCE_OF_DECLARE_RET(integrator_ap_timer, "arm,integrator-timer",
 		       integrator_ap_timer_init_of);

commit f710bdeecffe9ce3ad8bdc358c6109d3848f6352
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 18 16:24:47 2015 +0530

    clockevents/drivers/integrator: Migrate to new 'set-state' interface
    
    Migrate integrator driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    For oneshot mode the clkevt device was first getting disabled by
    clearing TIMER_CTRL_ENABLE bits in TIMER_CTRL register, followed by
    clearing TIMER_CTRL_PERIODIC bit. Both these are done with a single
    write operation now.
    
    Cc: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/clocksource/timer-integrator-ap.c b/drivers/clocksource/timer-integrator-ap.c
index a68866e0ecd4..3f59ac2180dc 100644
--- a/drivers/clocksource/timer-integrator-ap.c
+++ b/drivers/clocksource/timer-integrator-ap.c
@@ -75,33 +75,37 @@ static irqreturn_t integrator_timer_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static void clkevt_set_mode(enum clock_event_mode mode, struct clock_event_device *evt)
+static int clkevt_shutdown(struct clock_event_device *evt)
 {
 	u32 ctrl = readl(clkevt_base + TIMER_CTRL) & ~TIMER_CTRL_ENABLE;
 
 	/* Disable timer */
 	writel(ctrl, clkevt_base + TIMER_CTRL);
+	return 0;
+}
 
-	switch (mode) {
-	case CLOCK_EVT_MODE_PERIODIC:
-		/* Enable the timer and start the periodic tick */
-		writel(timer_reload, clkevt_base + TIMER_LOAD);
-		ctrl |= TIMER_CTRL_PERIODIC | TIMER_CTRL_ENABLE;
-		writel(ctrl, clkevt_base + TIMER_CTRL);
-		break;
-	case CLOCK_EVT_MODE_ONESHOT:
-		/* Leave the timer disabled, .set_next_event will enable it */
-		ctrl &= ~TIMER_CTRL_PERIODIC;
-		writel(ctrl, clkevt_base + TIMER_CTRL);
-		break;
-	case CLOCK_EVT_MODE_UNUSED:
-	case CLOCK_EVT_MODE_SHUTDOWN:
-	case CLOCK_EVT_MODE_RESUME:
-	default:
-		/* Just leave in disabled state */
-		break;
-	}
+static int clkevt_set_oneshot(struct clock_event_device *evt)
+{
+	u32 ctrl = readl(clkevt_base + TIMER_CTRL) &
+		   ~(TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC);
+
+	/* Leave the timer disabled, .set_next_event will enable it */
+	writel(ctrl, clkevt_base + TIMER_CTRL);
+	return 0;
+}
 
+static int clkevt_set_periodic(struct clock_event_device *evt)
+{
+	u32 ctrl = readl(clkevt_base + TIMER_CTRL) & ~TIMER_CTRL_ENABLE;
+
+	/* Disable timer */
+	writel(ctrl, clkevt_base + TIMER_CTRL);
+
+	/* Enable the timer and start the periodic tick */
+	writel(timer_reload, clkevt_base + TIMER_LOAD);
+	ctrl |= TIMER_CTRL_PERIODIC | TIMER_CTRL_ENABLE;
+	writel(ctrl, clkevt_base + TIMER_CTRL);
+	return 0;
 }
 
 static int clkevt_set_next_event(unsigned long next, struct clock_event_device *evt)
@@ -116,11 +120,15 @@ static int clkevt_set_next_event(unsigned long next, struct clock_event_device *
 }
 
 static struct clock_event_device integrator_clockevent = {
-	.name		= "timer1",
-	.features	= CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
-	.set_mode	= clkevt_set_mode,
-	.set_next_event	= clkevt_set_next_event,
-	.rating		= 300,
+	.name			= "timer1",
+	.features		= CLOCK_EVT_FEAT_PERIODIC |
+				  CLOCK_EVT_FEAT_ONESHOT,
+	.set_state_shutdown	= clkevt_shutdown,
+	.set_state_periodic	= clkevt_set_periodic,
+	.set_state_oneshot	= clkevt_set_oneshot,
+	.tick_resume		= clkevt_shutdown,
+	.set_next_event		= clkevt_set_next_event,
+	.rating			= 300,
 };
 
 static struct irqaction integrator_timer_irq = {

commit e8a0b37d28ace440776c0a4fe3c65f5832a9a7ee
Merge: abea9629486c 002af195a8c7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 26 12:20:00 2015 -0700

    Merge branch 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm
    
    Pull ARM updates from Russell King:
     "Bigger items included in this update are:
    
       - A series of updates from Arnd for ARM randconfig build failures
       - Updates from Dmitry for StrongARM SA-1100 to move IRQ handling to
         drivers/irqchip/
       - Move ARMs SP804 timer to drivers/clocksource/
       - Perf updates from Mark Rutland in preparation to move the ARM perf
         code into drivers/ so it can be shared with ARM64.
       - MCPM updates from Nicolas
       - Add support for taking platform serial number from DT
       - Re-implement Keystone2 physical address space switch to conform to
         architecture requirements
       - Clean up ARMv7 LPAE code, which goes in hand with the Keystone2
         changes.
       - L2C cleanups to avoid unlocking caches if we're prevented by the
         secure support to unlock.
       - Avoid cleaning a potentially dirty cache containing stale data on
         CPU initialisation
       - Add ARM-only entry point for secondary startup (for machines that
         can only call into a Thumb kernel in ARM mode).  Same thing is also
         done for the resume entry point.
       - Provide arch_irqs_disabled via asm-generic
       - Enlarge ARMv7M vector table
       - Always use BFD linker for VDSO, as gold doesn't accept some of the
         options we need.
       - Fix an incorrect BSYM (for Thumb symbols) usage, and convert all
         BSYM compiler macros to a "badr" (for branch address).
       - Shut up compiler warnings provoked by our cmpxchg() implementation.
       - Ensure bad xchg sizes fail to link"
    
    * 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm: (75 commits)
      ARM: Fix build if CLKDEV_LOOKUP is not configured
      ARM: fix new BSYM() usage introduced via for-arm-soc branch
      ARM: 8383/1: nommu: avoid deprecated source register on mov
      ARM: 8391/1: l2c: add options to overwrite prefetching behavior
      ARM: 8390/1: irqflags: Get arch_irqs_disabled from asm-generic
      ARM: 8387/1: arm/mm/dma-mapping.c: Add arm_coherent_dma_mmap
      ARM: 8388/1: tcm: Don't crash when TCM banks are protected by TrustZone
      ARM: 8384/1: VDSO: force use of BFD linker
      ARM: 8385/1: VDSO: group link options
      ARM: cmpxchg: avoid warnings from macro-ized cmpxchg() implementations
      ARM: remove __bad_xchg definition
      ARM: 8369/1: ARMv7M: define size of vector table for Vybrid
      ARM: 8382/1: clocksource: make ARM_TIMER_SP804 depend on GENERIC_SCHED_CLOCK
      ARM: 8366/1: move Dual-Timer SP804 driver to drivers/clocksource
      ARM: 8365/1: introduce sp804_timer_disable and remove arm_timer.h inclusion
      ARM: 8364/1: fix BE32 module loading
      ARM: 8360/1: add secondary_startup_arm prototype in header file
      ARM: 8359/1: correct secondary_startup_arm mode
      ARM: proc-v7: sanitise and document registers around errata
      ARM: proc-v7: clean up MIDR access
      ...

commit 0b7402dce445ba0d11401c2cb806e8fc260c9e49
Author: Sudeep Holla <sudeep.holla@arm.com>
Date:   Mon May 18 16:29:40 2015 +0100

    ARM: 8366/1: move Dual-Timer SP804 driver to drivers/clocksource
    
    The ARM Dual-Timer SP804 module is peripheral found not only on ARM32
    platforms but also on ARM64 platforms.
    
    This patch moves the driver out of arch/arm to driver/clocksource
    so that it can be used on ARM64 platforms also.
    
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Olof Johansson <olof@lixom.net>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/clocksource/timer-integrator-ap.c b/drivers/clocksource/timer-integrator-ap.c
index b9efd30513d5..d7d21e4dcef0 100644
--- a/drivers/clocksource/timer-integrator-ap.c
+++ b/drivers/clocksource/timer-integrator-ap.c
@@ -26,7 +26,8 @@
 #include <linux/clockchips.h>
 #include <linux/interrupt.h>
 #include <linux/sched_clock.h>
-#include <asm/hardware/arm_timer.h>
+
+#include "timer-sp.h"
 
 static void __iomem * sched_clk_base;
 

commit bd580e7ed4add8ce9b2c1dd1911f8fb9d444128b
Author: Maxime Ripard <maxime.ripard@free-electrons.com>
Date:   Sat May 2 17:03:24 2015 +0200

    clocksource: integrator: Fix of_io_request_and_map error check
    
    of_io_request_and map returns an error pointer, but the current code assumes
    that on error the returned pointer will be NULL.
    
    Obviously, that makes the check completely useless. Change the test to actually
    check for the proper error code.
    
    Signed-off-by: Maxime Ripard <maxime.ripard@free-electrons.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: http://lkml.kernel.org/r/1430579006-32702-5-git-send-email-maxime.ripard@free-electrons.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/clocksource/timer-integrator-ap.c b/drivers/clocksource/timer-integrator-ap.c
index b9efd30513d5..c97d1980c0f8 100644
--- a/drivers/clocksource/timer-integrator-ap.c
+++ b/drivers/clocksource/timer-integrator-ap.c
@@ -166,7 +166,7 @@ static void __init integrator_ap_timer_init_of(struct device_node *node)
 	struct device_node *sec_node;
 
 	base = of_io_request_and_map(node, 0, "integrator-timer");
-	if (!base)
+	if (IS_ERR(base))
 		return;
 
 	clk = of_clk_get(node, 0);

commit beb5818bd012953c79de38f9726f327d8e311569
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Oct 15 15:30:25 2014 +0200

    ARM: integrator: move AP timer to clocksource
    
    This moves the timer/clocksource implementation for the
    Integrator/AP down to drivers/clocksource and augments the
    driver a little to use CLOCKSOURCE_OF_DECLARE(). Remove
    the static mapping of the timer blocks while we're at it.
    
    Tested on the Integrator/AP.
    
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/clocksource/timer-integrator-ap.c b/drivers/clocksource/timer-integrator-ap.c
new file mode 100644
index 000000000000..b9efd30513d5
--- /dev/null
+++ b/drivers/clocksource/timer-integrator-ap.c
@@ -0,0 +1,210 @@
+/*
+ * Integrator/AP timer driver
+ * Copyright (C) 2000-2003 Deep Blue Solutions Ltd
+ * Copyright (c) 2014, Linaro Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/clk.h>
+#include <linux/clocksource.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/clockchips.h>
+#include <linux/interrupt.h>
+#include <linux/sched_clock.h>
+#include <asm/hardware/arm_timer.h>
+
+static void __iomem * sched_clk_base;
+
+static u64 notrace integrator_read_sched_clock(void)
+{
+	return -readl(sched_clk_base + TIMER_VALUE);
+}
+
+static void integrator_clocksource_init(unsigned long inrate,
+					void __iomem *base)
+{
+	u32 ctrl = TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC;
+	unsigned long rate = inrate;
+
+	if (rate >= 1500000) {
+		rate /= 16;
+		ctrl |= TIMER_CTRL_DIV16;
+	}
+
+	writel(0xffff, base + TIMER_LOAD);
+	writel(ctrl, base + TIMER_CTRL);
+
+	clocksource_mmio_init(base + TIMER_VALUE, "timer2",
+			rate, 200, 16, clocksource_mmio_readl_down);
+
+	sched_clk_base = base;
+	sched_clock_register(integrator_read_sched_clock, 16, rate);
+}
+
+static unsigned long timer_reload;
+static void __iomem * clkevt_base;
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t integrator_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = dev_id;
+
+	/* clear the interrupt */
+	writel(1, clkevt_base + TIMER_INTCLR);
+
+	evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static void clkevt_set_mode(enum clock_event_mode mode, struct clock_event_device *evt)
+{
+	u32 ctrl = readl(clkevt_base + TIMER_CTRL) & ~TIMER_CTRL_ENABLE;
+
+	/* Disable timer */
+	writel(ctrl, clkevt_base + TIMER_CTRL);
+
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		/* Enable the timer and start the periodic tick */
+		writel(timer_reload, clkevt_base + TIMER_LOAD);
+		ctrl |= TIMER_CTRL_PERIODIC | TIMER_CTRL_ENABLE;
+		writel(ctrl, clkevt_base + TIMER_CTRL);
+		break;
+	case CLOCK_EVT_MODE_ONESHOT:
+		/* Leave the timer disabled, .set_next_event will enable it */
+		ctrl &= ~TIMER_CTRL_PERIODIC;
+		writel(ctrl, clkevt_base + TIMER_CTRL);
+		break;
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	case CLOCK_EVT_MODE_RESUME:
+	default:
+		/* Just leave in disabled state */
+		break;
+	}
+
+}
+
+static int clkevt_set_next_event(unsigned long next, struct clock_event_device *evt)
+{
+	unsigned long ctrl = readl(clkevt_base + TIMER_CTRL);
+
+	writel(ctrl & ~TIMER_CTRL_ENABLE, clkevt_base + TIMER_CTRL);
+	writel(next, clkevt_base + TIMER_LOAD);
+	writel(ctrl | TIMER_CTRL_ENABLE, clkevt_base + TIMER_CTRL);
+
+	return 0;
+}
+
+static struct clock_event_device integrator_clockevent = {
+	.name		= "timer1",
+	.features	= CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+	.set_mode	= clkevt_set_mode,
+	.set_next_event	= clkevt_set_next_event,
+	.rating		= 300,
+};
+
+static struct irqaction integrator_timer_irq = {
+	.name		= "timer",
+	.flags		= IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= integrator_timer_interrupt,
+	.dev_id		= &integrator_clockevent,
+};
+
+static void integrator_clockevent_init(unsigned long inrate,
+				void __iomem *base, int irq)
+{
+	unsigned long rate = inrate;
+	unsigned int ctrl = 0;
+
+	clkevt_base = base;
+	/* Calculate and program a divisor */
+	if (rate > 0x100000 * HZ) {
+		rate /= 256;
+		ctrl |= TIMER_CTRL_DIV256;
+	} else if (rate > 0x10000 * HZ) {
+		rate /= 16;
+		ctrl |= TIMER_CTRL_DIV16;
+	}
+	timer_reload = rate / HZ;
+	writel(ctrl, clkevt_base + TIMER_CTRL);
+
+	setup_irq(irq, &integrator_timer_irq);
+	clockevents_config_and_register(&integrator_clockevent,
+					rate,
+					1,
+					0xffffU);
+}
+
+static void __init integrator_ap_timer_init_of(struct device_node *node)
+{
+	const char *path;
+	void __iomem *base;
+	int err;
+	int irq;
+	struct clk *clk;
+	unsigned long rate;
+	struct device_node *pri_node;
+	struct device_node *sec_node;
+
+	base = of_io_request_and_map(node, 0, "integrator-timer");
+	if (!base)
+		return;
+
+	clk = of_clk_get(node, 0);
+	if (IS_ERR(clk)) {
+		pr_err("No clock for %s\n", node->name);
+		return;
+	}
+	clk_prepare_enable(clk);
+	rate = clk_get_rate(clk);
+	writel(0, base + TIMER_CTRL);
+
+	err = of_property_read_string(of_aliases,
+				"arm,timer-primary", &path);
+	if (WARN_ON(err))
+		return;
+	pri_node = of_find_node_by_path(path);
+	err = of_property_read_string(of_aliases,
+				"arm,timer-secondary", &path);
+	if (WARN_ON(err))
+		return;
+	sec_node = of_find_node_by_path(path);
+
+	if (node == pri_node) {
+		/* The primary timer lacks IRQ, use as clocksource */
+		integrator_clocksource_init(rate, base);
+		return;
+	}
+
+	if (node == sec_node) {
+		/* The secondary timer will drive the clock event */
+		irq = irq_of_parse_and_map(node, 0);
+		integrator_clockevent_init(rate, base, irq);
+		return;
+	}
+
+	pr_info("Timer @%p unused\n", base);
+	clk_disable_unprepare(clk);
+}
+
+CLOCKSOURCE_OF_DECLARE(integrator_ap_timer, "arm,integrator-timer",
+		       integrator_ap_timer_init_of);
