commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index f6ffb0cef091..1d740a8c42ab 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *  linux/arch/h8300/kernel/cpu/timer/timer8.c
  *

commit 1727339590fdb5a1ded881b540cd32121278d414
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 26 16:56:11 2017 +0200

    clocksource/drivers: Rename CLOCKSOURCE_OF_DECLARE to TIMER_OF_DECLARE
    
    The CLOCKSOURCE_OF_DECLARE macro is used widely for the timers to declare the
    clocksource at early stage. However, this macro is also used to initialize
    the clockevent if any, or the clockevent only.
    
    It was originally suggested to declare another macro to initialize a
    clockevent, so in order to separate the two entities even they belong to the
    same IP. This was not accepted because of the impact on the DT where splitting
    a clocksource/clockevent definition does not make sense as it is a Linux
    concept not a hardware description.
    
    On the other side, the clocksource has not interrupt declared while the
    clockevent has, so it is easy from the driver to know if the description is
    for a clockevent or a clocksource, IOW it could be implemented at the driver
    level.
    
    So instead of dealing with a named clocksource macro, let's use a more generic
    one: TIMER_OF_DECLARE.
    
    The patch has not functional changes.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Matthias Brugger <matthias.bgg@gmail.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index 804c489531d6..f6ffb0cef091 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -207,4 +207,4 @@ static int __init h8300_8timer_init(struct device_node *node)
 	return ret;
 }
 
-CLOCKSOURCE_OF_DECLARE(h8300_8bit, "renesas,8bit-timer", h8300_8timer_init);
+TIMER_OF_DECLARE(h8300_8bit, "renesas,8bit-timer", h8300_8timer_init);

commit a17e0178fa2898bd8c4ccaaefa83c729759a361c
Author: Nicolai Stange <nicstange@gmail.com>
Date:   Mon Feb 6 22:12:03 2017 +0100

    clocksource: h8300_timer8: Don't reset rate in ->set_state_oneshot()
    
    With the upcoming NTP correction related rate adjustments to be implemented
    in the clockevents core, the latter needs to get informed about every rate
    change of a clockevent device made after its registration.
    
    Currently, h8300_timer8 violates this requirement in that it registers its
    clockevent device with the correct rate, but resets its ->mult and ->rate
    values in timer8_clock_event_start(), called from its ->set_state_oneshot()
    function.
    
    It seems like
      commit 4633f4cac85a ("clocksource/drivers/h8300: Cleanup startup and
                            remove module code."),
    which introduced the rate initialization at registration, missed to remove
    the manual setting of ->mult and ->shift from timer8_clock_event_start().
    
    Purge the setting of ->mult, ->shift, ->min_delta_ns and ->max_delta_ns
    from timer8_clock_event_start().
    
    Signed-off-by: Nicolai Stange <nicstange@gmail.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index 546bb180f5a4..804c489531d6 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -101,15 +101,7 @@ static inline struct timer8_priv *ced_to_priv(struct clock_event_device *ced)
 
 static void timer8_clock_event_start(struct timer8_priv *p, unsigned long delta)
 {
-	struct clock_event_device *ced = &p->ced;
-
 	timer8_start(p);
-
-	ced->shift = 32;
-	ced->mult = div_sc(p->rate, NSEC_PER_SEC, ced->shift);
-	ced->max_delta_ns = clockevent_delta2ns(0xffff, ced);
-	ced->min_delta_ns = clockevent_delta2ns(0x0001, ced);
-
 	timer8_set_next(p, delta);
 }
 

commit 177cf6e52b0a1a382b9892d3cc9aafd6e7c5943f
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Tue Jun 7 00:27:44 2016 +0200

    clocksources: Switch back to the clksrc table
    
    All the clocksource drivers's init function are now converted to return
    an error code. CLOCKSOURCE_OF_DECLARE is no longer used as well as the
    clksrc-of table.
    
    Let's convert back the names:
     - CLOCKSOURCE_OF_DECLARE_RET => CLOCKSOURCE_OF_DECLARE
     - clksrc-of-ret              => clksrc-of
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    
    For exynos_mct and samsung_pwm_timer:
    Acked-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    
    For arch/arc:
    Acked-by: Vineet Gupta <vgupta@synopsys.com>
    
    For mediatek driver:
    Acked-by: Matthias Brugger <matthias.bgg@gmail.com>
    
    For the Rockchip-part
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    
    For STi :
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    
    For the mps2-timer.c and versatile.c changes:
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    
    For the OXNAS part :
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    
    For LPC32xx driver:
    Acked-by: Sylvain Lemieux <slemieux.tyco@gmail.com>
    
    For Broadcom Kona timer change:
    Acked-by: Ray Jui <ray.jui@broadcom.com>
    
    For Sun4i and Sun5i:
    Acked-by: Chen-Yu Tsai <wens@csie.org>
    
    For Meson6:
    Acked-by: Carlo Caione <carlo@caione.org>
    
    For Keystone:
    Acked-by: Santosh Shilimkar <ssantosh@kernel.org>
    
    For NPS:
    Acked-by: Noam Camus <noamca@mellanox.com>
    
    For bcm2835:
    Acked-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index 0292a1907619..546bb180f5a4 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -215,4 +215,4 @@ static int __init h8300_8timer_init(struct device_node *node)
 	return ret;
 }
 
-CLOCKSOURCE_OF_DECLARE_RET(h8300_8bit, "renesas,8bit-timer", h8300_8timer_init);
+CLOCKSOURCE_OF_DECLARE(h8300_8bit, "renesas,8bit-timer", h8300_8timer_init);

commit 691f8f878290f7a94b94fe238e28263982eb52ca
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Mon Jun 6 17:56:37 2016 +0200

    clocksource/drivers/h8300_timer8: Convert init function to return error
    
    The init functions do not return any error. They behave as the following:
    
      - panic, thus leading to a kernel crash while another timer may work and
           make the system boot up correctly
    
      or
    
      - print an error and let the caller unaware if the state of the system
    
    Change that by converting the init functions to return an error conforming
    to the CLOCKSOURCE_OF_RET prototype.
    
    Proper error handling (rollback, errno value) will be changed later case
    by case, thus this change just return back an error or success in the init
    function.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index c151941e1956..0292a1907619 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -164,24 +164,26 @@ static struct timer8_priv timer8_priv = {
 	},
 };
 
-static void __init h8300_8timer_init(struct device_node *node)
+static int __init h8300_8timer_init(struct device_node *node)
 {
 	void __iomem *base;
-	int irq;
+	int irq, ret;
 	struct clk *clk;
 
 	clk = of_clk_get(node, 0);
 	if (IS_ERR(clk)) {
 		pr_err("failed to get clock for clockevent\n");
-		return;
+		return PTR_ERR(clk);
 	}
 
+	ret = ENXIO;
 	base = of_iomap(node, 0);
 	if (!base) {
 		pr_err("failed to map registers for clockevent\n");
 		goto free_clk;
 	}
 
+	ret = -EINVAL;
 	irq = irq_of_parse_and_map(node, 0);
 	if (!irq) {
 		pr_err("failed to get irq for clockevent\n");
@@ -205,11 +207,12 @@ static void __init h8300_8timer_init(struct device_node *node)
 	clockevents_config_and_register(&timer8_priv.ced,
 					timer8_priv.rate, 1, 0x0000ffff);
 
-	return;
+	return 0;
 unmap_reg:
 	iounmap(base);
 free_clk:
 	clk_put(clk);
+	return ret;
 }
 
-CLOCKSOURCE_OF_DECLARE(h8300_8bit, "renesas,8bit-timer", h8300_8timer_init);
+CLOCKSOURCE_OF_DECLARE_RET(h8300_8bit, "renesas,8bit-timer", h8300_8timer_init);

commit d33f250af4e67d449f2c748b861ba99d50955469
Author: Yoshinori Sato <ysato@users.sourceforge.jp>
Date:   Sat Dec 5 02:48:18 2015 +0900

    clocksource/drivers/h8300: Use ioread / iowrite
    
    Signed-off-by: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index 9087dd27ec69..c151941e1956 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -24,10 +24,16 @@
 #define TCORB	6
 #define _8TCNT	8
 
+#define CMIEA	6
+#define CMFA	6
+
 #define FLAG_STARTED (1 << 3)
 
 #define SCALE 64
 
+#define bset(b, a) iowrite8(ioread8(a) | (1 << (b)), (a))
+#define bclr(b, a) iowrite8(ioread8(a) & ~(1 << (b)), (a))
+
 struct timer8_priv {
 	struct clock_event_device ced;
 	void __iomem *mapbase;
@@ -40,12 +46,11 @@ static irqreturn_t timer8_interrupt(int irq, void *dev_id)
 	struct timer8_priv *p = dev_id;
 
 	if (clockevent_state_oneshot(&p->ced))
-		writew(0x0000, p->mapbase + _8TCR);
+		iowrite16be(0x0000, p->mapbase + _8TCR);
 
 	p->ced.event_handler(&p->ced);
 
-	writeb(readb(p->mapbase + _8TCSR) & ~0x40,
-		  p->mapbase + _8TCSR);
+	bclr(CMFA, p->mapbase + _8TCSR);
 
 	return IRQ_HANDLED;
 }
@@ -54,17 +59,18 @@ static void timer8_set_next(struct timer8_priv *p, unsigned long delta)
 {
 	if (delta >= 0x10000)
 		pr_warn("delta out of range\n");
-	writeb(readb(p->mapbase + _8TCR) & ~0x40, p->mapbase + _8TCR);
-	writew(0, p->mapbase + _8TCNT);
-	writew(delta, p->mapbase + TCORA);
-	writeb(readb(p->mapbase + _8TCR) | 0x40, p->mapbase + _8TCR);
+	bclr(CMIEA, p->mapbase + _8TCR);
+	iowrite16be(delta, p->mapbase + TCORA);
+	iowrite16be(0x0000, p->mapbase + _8TCNT);
+	bclr(CMFA, p->mapbase + _8TCSR);
+	bset(CMIEA, p->mapbase + _8TCR);
 }
 
 static int timer8_enable(struct timer8_priv *p)
 {
-	writew(0xffff, p->mapbase + TCORA);
-	writew(0x0000, p->mapbase + _8TCNT);
-	writew(0x0c02, p->mapbase + _8TCR);
+	iowrite16be(0xffff, p->mapbase + TCORA);
+	iowrite16be(0x0000, p->mapbase + _8TCNT);
+	iowrite16be(0x0c02, p->mapbase + _8TCR);
 
 	return 0;
 }
@@ -85,7 +91,7 @@ static int timer8_start(struct timer8_priv *p)
 
 static void timer8_stop(struct timer8_priv *p)
 {
-	writew(0x0000, p->mapbase + _8TCR);
+	iowrite16be(0x0000, p->mapbase + _8TCR);
 }
 
 static inline struct timer8_priv *ced_to_priv(struct clock_event_device *ced)

commit 6f2b611db23404426a2b21b343392dc1d9584f92
Author: Yoshinori Sato <ysato@users.sourceforge.jp>
Date:   Sat Dec 5 02:48:17 2015 +0900

    clocksource/drivers/h8300: Initializer cleanup.
    
    Signed-off-by: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index 1ba453b47478..9087dd27ec69 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -33,7 +33,6 @@ struct timer8_priv {
 	void __iomem *mapbase;
 	unsigned long flags;
 	unsigned int rate;
-	unsigned int tcora;
 };
 
 static irqreturn_t timer8_interrupt(int irq, void *dev_id)
@@ -163,8 +162,6 @@ static void __init h8300_8timer_init(struct device_node *node)
 {
 	void __iomem *base;
 	int irq;
-	int ret = 0;
-	int rate;
 	struct clk *clk;
 
 	clk = of_clk_get(node, 0);
@@ -187,20 +184,20 @@ static void __init h8300_8timer_init(struct device_node *node)
 
 	timer8_priv.mapbase = base;
 
-	rate = clk_get_rate(clk) / SCALE;
-	if (!rate) {
+	timer8_priv.rate = clk_get_rate(clk) / SCALE;
+	if (!timer8_priv.rate) {
 		pr_err("Failed to get rate for the clocksource\n");
 		goto unmap_reg;
 	}
 
-	ret = request_irq(irq, timer8_interrupt,
-			  IRQF_TIMER, timer8_priv.ced.name, &timer8_priv);
-	if (ret < 0) {
+	if (request_irq(irq, timer8_interrupt, IRQF_TIMER,
+			timer8_priv.ced.name, &timer8_priv) < 0) {
 		pr_err("failed to request irq %d for clockevent\n", irq);
 		goto unmap_reg;
 	}
 
-	clockevents_config_and_register(&timer8_priv.ced, rate, 1, 0x0000ffff);
+	clockevents_config_and_register(&timer8_priv.ced,
+					timer8_priv.rate, 1, 0x0000ffff);
 
 	return;
 unmap_reg:

commit f37632d1e9ff8445e0d1ea761f4ce7b98e059d75
Author: Yoshinori Sato <ysato@users.sourceforge.jp>
Date:   Sat Dec 5 02:48:16 2015 +0900

    clocksource/drivers/h8300: Simplify delta handling
    
    Signed-off-by: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index aa4b2a989747..1ba453b47478 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -36,57 +36,29 @@ struct timer8_priv {
 	unsigned int tcora;
 };
 
-static unsigned long timer8_get_counter(struct timer8_priv *p)
-{
-	unsigned long v1, v2, v3;
-	int o1, o2;
-
-	o1 = readb(p->mapbase + _8TCSR) & 0x20;
-
-	/* Make sure the timer value is stable. Stolen from acpi_pm.c */
-	do {
-		o2 = o1;
-		v1 = readw(p->mapbase + _8TCNT);
-		v2 = readw(p->mapbase + _8TCNT);
-		v3 = readw(p->mapbase + _8TCNT);
-		o1 = readb(p->mapbase + _8TCSR) & 0x20;
-	} while (unlikely((o1 != o2) || (v1 > v2 && v1 < v3)
-			  || (v2 > v3 && v2 < v1) || (v3 > v1 && v3 < v2)));
-
-	v2 |= o1 << 10;
-	return v2;
-}
-
 static irqreturn_t timer8_interrupt(int irq, void *dev_id)
 {
 	struct timer8_priv *p = dev_id;
 
-	writeb(readb(p->mapbase + _8TCSR) & ~0x40,
-		  p->mapbase + _8TCSR);
-
-	writew(p->tcora, p->mapbase + TCORA);
-
 	if (clockevent_state_oneshot(&p->ced))
 		writew(0x0000, p->mapbase + _8TCR);
 
 	p->ced.event_handler(&p->ced);
 
+	writeb(readb(p->mapbase + _8TCSR) & ~0x40,
+		  p->mapbase + _8TCSR);
+
 	return IRQ_HANDLED;
 }
 
 static void timer8_set_next(struct timer8_priv *p, unsigned long delta)
 {
-	unsigned long now;
-
 	if (delta >= 0x10000)
 		pr_warn("delta out of range\n");
-	now = timer8_get_counter(p);
-	p->tcora = delta;
+	writeb(readb(p->mapbase + _8TCR) & ~0x40, p->mapbase + _8TCR);
+	writew(0, p->mapbase + _8TCNT);
+	writew(delta, p->mapbase + TCORA);
 	writeb(readb(p->mapbase + _8TCR) | 0x40, p->mapbase + _8TCR);
-	if (delta > now)
-		writew(delta, p->mapbase + TCORA);
-	else
-		writew(now + 1, p->mapbase + TCORA);
 }
 
 static int timer8_enable(struct timer8_priv *p)

commit 751605152b4dbcdf3da2643c965ec1c3b734e11d
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Sun Nov 8 22:55:12 2015 +0100

    h8300: Rename ctlr_out/in[bwl] to raw_read/write[bwl]
    
    For the sake of consistency, let rename all ctrl_out/in calls to the write/read
    calls so we have the same API consistent with the other architectures hence
    open the door for the increasing of the test compilation coverage.
    
    The unsigned long coercive cast is removed because all variables are set to
    the right type "void __iomem *".
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index 187c41619b13..aa4b2a989747 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -30,7 +30,7 @@
 
 struct timer8_priv {
 	struct clock_event_device ced;
-	unsigned long mapbase;
+	void __iomem *mapbase;
 	unsigned long flags;
 	unsigned int rate;
 	unsigned int tcora;
@@ -41,15 +41,15 @@ static unsigned long timer8_get_counter(struct timer8_priv *p)
 	unsigned long v1, v2, v3;
 	int o1, o2;
 
-	o1 = ctrl_inb(p->mapbase + _8TCSR) & 0x20;
+	o1 = readb(p->mapbase + _8TCSR) & 0x20;
 
 	/* Make sure the timer value is stable. Stolen from acpi_pm.c */
 	do {
 		o2 = o1;
-		v1 = ctrl_inw(p->mapbase + _8TCNT);
-		v2 = ctrl_inw(p->mapbase + _8TCNT);
-		v3 = ctrl_inw(p->mapbase + _8TCNT);
-		o1 = ctrl_inb(p->mapbase + _8TCSR) & 0x20;
+		v1 = readw(p->mapbase + _8TCNT);
+		v2 = readw(p->mapbase + _8TCNT);
+		v3 = readw(p->mapbase + _8TCNT);
+		o1 = readb(p->mapbase + _8TCSR) & 0x20;
 	} while (unlikely((o1 != o2) || (v1 > v2 && v1 < v3)
 			  || (v2 > v3 && v2 < v1) || (v3 > v1 && v3 < v2)));
 
@@ -61,13 +61,13 @@ static irqreturn_t timer8_interrupt(int irq, void *dev_id)
 {
 	struct timer8_priv *p = dev_id;
 
-	ctrl_outb(ctrl_inb(p->mapbase + _8TCSR) & ~0x40,
+	writeb(readb(p->mapbase + _8TCSR) & ~0x40,
 		  p->mapbase + _8TCSR);
 
-	ctrl_outw(p->tcora, p->mapbase + TCORA);
+	writew(p->tcora, p->mapbase + TCORA);
 
 	if (clockevent_state_oneshot(&p->ced))
-		ctrl_outw(0x0000, p->mapbase + _8TCR);
+		writew(0x0000, p->mapbase + _8TCR);
 
 	p->ced.event_handler(&p->ced);
 
@@ -82,18 +82,18 @@ static void timer8_set_next(struct timer8_priv *p, unsigned long delta)
 		pr_warn("delta out of range\n");
 	now = timer8_get_counter(p);
 	p->tcora = delta;
-	ctrl_outb(ctrl_inb(p->mapbase + _8TCR) | 0x40, p->mapbase + _8TCR);
+	writeb(readb(p->mapbase + _8TCR) | 0x40, p->mapbase + _8TCR);
 	if (delta > now)
-		ctrl_outw(delta, p->mapbase + TCORA);
+		writew(delta, p->mapbase + TCORA);
 	else
-		ctrl_outw(now + 1, p->mapbase + TCORA);
+		writew(now + 1, p->mapbase + TCORA);
 }
 
 static int timer8_enable(struct timer8_priv *p)
 {
-	ctrl_outw(0xffff, p->mapbase + TCORA);
-	ctrl_outw(0x0000, p->mapbase + _8TCNT);
-	ctrl_outw(0x0c02, p->mapbase + _8TCR);
+	writew(0xffff, p->mapbase + TCORA);
+	writew(0x0000, p->mapbase + _8TCNT);
+	writew(0x0c02, p->mapbase + _8TCR);
 
 	return 0;
 }
@@ -114,7 +114,7 @@ static int timer8_start(struct timer8_priv *p)
 
 static void timer8_stop(struct timer8_priv *p)
 {
-	ctrl_outw(0x0000, p->mapbase + _8TCR);
+	writew(0x0000, p->mapbase + _8TCR);
 }
 
 static inline struct timer8_priv *ced_to_priv(struct clock_event_device *ced)
@@ -213,7 +213,7 @@ static void __init h8300_8timer_init(struct device_node *node)
 		goto unmap_reg;
 	}
 
-	timer8_priv.mapbase = (unsigned long)base;
+	timer8_priv.mapbase = base;
 
 	rate = clk_get_rate(clk) / SCALE;
 	if (!rate) {

commit cce483e0ee70c2c9c6ff08e502b6f0bba3e15f62
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Sun Nov 8 23:24:28 2015 +0100

    clocksource/drivers/h8300_timer8: Retrieve the clock rate at init time
    
    The current code retrieves the rate value when the timer is enabled which
    occurs each time a timer is re-armed. Except if the clock frequency has changed
    magically I don't see why this should be done each time.
    
    Retrieve the clock rate value at init time only.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index 24d91b1a5d5c..187c41619b13 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -34,7 +34,6 @@ struct timer8_priv {
 	unsigned long flags;
 	unsigned int rate;
 	unsigned int tcora;
-	struct clk *pclk;
 };
 
 static unsigned long timer8_get_counter(struct timer8_priv *p)
@@ -92,7 +91,6 @@ static void timer8_set_next(struct timer8_priv *p, unsigned long delta)
 
 static int timer8_enable(struct timer8_priv *p)
 {
-	p->rate = clk_get_rate(p->pclk) / SCALE;
 	ctrl_outw(0xffff, p->mapbase + TCORA);
 	ctrl_outw(0x0000, p->mapbase + _8TCNT);
 	ctrl_outw(0x0c02, p->mapbase + _8TCR);
@@ -102,16 +100,15 @@ static int timer8_enable(struct timer8_priv *p)
 
 static int timer8_start(struct timer8_priv *p)
 {
-	int ret = 0;
+	int ret;
 
-	if (!(p->flags & FLAG_STARTED))
-		ret = timer8_enable(p);
+	if ((p->flags & FLAG_STARTED))
+		return 0;
 
-	if (ret)
-		goto out;
-	p->flags |= FLAG_STARTED;
+	ret = timer8_enable(p);
+	if (!ret)
+		p->flags |= FLAG_STARTED;
 
- out:
 	return ret;
 }
 
@@ -217,7 +214,12 @@ static void __init h8300_8timer_init(struct device_node *node)
 	}
 
 	timer8_priv.mapbase = (unsigned long)base;
-	timer8_priv.pclk = clk;
+
+	rate = clk_get_rate(clk) / SCALE;
+	if (!rate) {
+		pr_err("Failed to get rate for the clocksource\n");
+		goto unmap_reg;
+	}
 
 	ret = request_irq(irq, timer8_interrupt,
 			  IRQF_TIMER, timer8_priv.ced.name, &timer8_priv);
@@ -225,10 +227,10 @@ static void __init h8300_8timer_init(struct device_node *node)
 		pr_err("failed to request irq %d for clockevent\n", irq);
 		goto unmap_reg;
 	}
-	rate = clk_get_rate(clk) / SCALE;
+
 	clockevents_config_and_register(&timer8_priv.ced, rate, 1, 0x0000ffff);
-	return;
 
+	return;
 unmap_reg:
 	iounmap(base);
 free_clk:

commit 254d8b5d59516d670111e0ac14d53fed4d61118d
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Sun Nov 8 22:39:12 2015 +0100

    clocksource/drivers/h8300_timer8: Remove irq and lock legacy code
    
    The time framawork takes care of disabling the interrupts and takes a lock
    to prevent races.
    
    Remove the legacy code in the driver taking care of the races.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index 7111b99be6d5..24d91b1a5d5c 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -31,7 +31,6 @@
 struct timer8_priv {
 	struct clock_event_device ced;
 	unsigned long mapbase;
-	raw_spinlock_t lock;
 	unsigned long flags;
 	unsigned int rate;
 	unsigned int tcora;
@@ -78,10 +77,8 @@ static irqreturn_t timer8_interrupt(int irq, void *dev_id)
 
 static void timer8_set_next(struct timer8_priv *p, unsigned long delta)
 {
-	unsigned long flags;
 	unsigned long now;
 
-	raw_spin_lock_irqsave(&p->lock, flags);
 	if (delta >= 0x10000)
 		pr_warn("delta out of range\n");
 	now = timer8_get_counter(p);
@@ -91,8 +88,6 @@ static void timer8_set_next(struct timer8_priv *p, unsigned long delta)
 		ctrl_outw(delta, p->mapbase + TCORA);
 	else
 		ctrl_outw(now + 1, p->mapbase + TCORA);
-
-	raw_spin_unlock_irqrestore(&p->lock, flags);
 }
 
 static int timer8_enable(struct timer8_priv *p)
@@ -108,9 +103,6 @@ static int timer8_enable(struct timer8_priv *p)
 static int timer8_start(struct timer8_priv *p)
 {
 	int ret = 0;
-	unsigned long flags;
-
-	raw_spin_lock_irqsave(&p->lock, flags);
 
 	if (!(p->flags & FLAG_STARTED))
 		ret = timer8_enable(p);
@@ -120,20 +112,12 @@ static int timer8_start(struct timer8_priv *p)
 	p->flags |= FLAG_STARTED;
 
  out:
-	raw_spin_unlock_irqrestore(&p->lock, flags);
-
 	return ret;
 }
 
 static void timer8_stop(struct timer8_priv *p)
 {
-	unsigned long flags;
-
-	raw_spin_lock_irqsave(&p->lock, flags);
-
 	ctrl_outw(0x0000, p->mapbase + _8TCR);
-
-	raw_spin_unlock_irqrestore(&p->lock, flags);
 }
 
 static inline struct timer8_priv *ced_to_priv(struct clock_event_device *ced)

commit 7053fdac76451efe5f16c9e0974dc17fcf29f6d6
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Sun Nov 8 18:07:38 2015 +0100

    clocksource/drivers/h8300_timer8: Remove pointless irq re-entrant safe code
    
    The current code assumes the interrupt function is re-entrant.
    
    That is not correct. An interrupt handler is never invoked concurrently. The
    interrupt line is masked on all processors.
    
    Remove the chewing flags in the code.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index 3eedeffccc26..7111b99be6d5 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -24,8 +24,6 @@
 #define TCORB	6
 #define _8TCNT	8
 
-#define FLAG_SKIPEVENT (1 << 1)
-#define FLAG_IRQCONTEXT (1 << 2)
 #define FLAG_STARTED (1 << 3)
 
 #define SCALE 64
@@ -67,14 +65,13 @@ static irqreturn_t timer8_interrupt(int irq, void *dev_id)
 
 	ctrl_outb(ctrl_inb(p->mapbase + _8TCSR) & ~0x40,
 		  p->mapbase + _8TCSR);
-	p->flags |= FLAG_IRQCONTEXT;
+
 	ctrl_outw(p->tcora, p->mapbase + TCORA);
-	if (!(p->flags & FLAG_SKIPEVENT)) {
-		if (clockevent_state_oneshot(&p->ced))
-			ctrl_outw(0x0000, p->mapbase + _8TCR);
-		p->ced.event_handler(&p->ced);
-	}
-	p->flags &= ~(FLAG_SKIPEVENT | FLAG_IRQCONTEXT);
+
+	if (clockevent_state_oneshot(&p->ced))
+		ctrl_outw(0x0000, p->mapbase + _8TCR);
+
+	p->ced.event_handler(&p->ced);
 
 	return IRQ_HANDLED;
 }

commit 54a0cd5a7e107ba0cf15a4fb876595d0c8a7faab
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Sun Nov 8 17:56:18 2015 +0100

    clocksource/drivers/h8300_timer8: Fix irq return value check
    
    The value returned in case of error for the 'irq_of_parse_and_map' function is
    zero in case of error. Fix the check in the init code.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index 2433325bd38f..3eedeffccc26 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -230,7 +230,7 @@ static void __init h8300_8timer_init(struct device_node *node)
 	}
 
 	irq = irq_of_parse_and_map(node, 0);
-	if (irq < 0) {
+	if (!irq) {
 		pr_err("failed to get irq for clockevent\n");
 		goto unmap_reg;
 	}

commit 1f058d52b3e32b919742d451c673b3ab71c487dc
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Sun Nov 8 17:46:54 2015 +0100

    clocksource/drivers/h8300_timer8: Remove PERIODIC and ONESHOT macro
    
    Specify the delta as parameter for the timer8_clock_event_start function
    instead of using a macro to tell PERIODIC or ONESHOT.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index 88b9b0630fbe..2433325bd38f 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -28,9 +28,6 @@
 #define FLAG_IRQCONTEXT (1 << 2)
 #define FLAG_STARTED (1 << 3)
 
-#define ONESHOT  0
-#define PERIODIC 1
-
 #define SCALE 64
 
 struct timer8_priv {
@@ -147,7 +144,7 @@ static inline struct timer8_priv *ced_to_priv(struct clock_event_device *ced)
 	return container_of(ced, struct timer8_priv, ced);
 }
 
-static void timer8_clock_event_start(struct timer8_priv *p, int periodic)
+static void timer8_clock_event_start(struct timer8_priv *p, unsigned long delta)
 {
 	struct clock_event_device *ced = &p->ced;
 
@@ -158,7 +155,7 @@ static void timer8_clock_event_start(struct timer8_priv *p, int periodic)
 	ced->max_delta_ns = clockevent_delta2ns(0xffff, ced);
 	ced->min_delta_ns = clockevent_delta2ns(0x0001, ced);
 
-	timer8_set_next(p, periodic?(p->rate + HZ/2) / HZ:0x10000);
+	timer8_set_next(p, delta);
 }
 
 static int timer8_clock_event_shutdown(struct clock_event_device *ced)
@@ -173,7 +170,7 @@ static int timer8_clock_event_periodic(struct clock_event_device *ced)
 
 	pr_info("%s: used for periodic clock events\n", ced->name);
 	timer8_stop(p);
-	timer8_clock_event_start(p, PERIODIC);
+	timer8_clock_event_start(p, (p->rate + HZ/2) / HZ);
 
 	return 0;
 }
@@ -184,7 +181,7 @@ static int timer8_clock_event_oneshot(struct clock_event_device *ced)
 
 	pr_info("%s: used for oneshot clock events\n", ced->name);
 	timer8_stop(p);
-	timer8_clock_event_start(p, ONESHOT);
+	timer8_clock_event_start(p, 0x10000);
 
 	return 0;
 }

commit 7116ae437fc7380ffc0b9429438bba9de9681024
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Sun Nov 8 17:40:35 2015 +0100

    clocksource/drivers/h8300_timer8: Remove unused macros
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index 62a7f8c97091..88b9b0630fbe 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -24,7 +24,6 @@
 #define TCORB	6
 #define _8TCNT	8
 
-#define FLAG_REPROGRAM (1 << 0)
 #define FLAG_SKIPEVENT (1 << 1)
 #define FLAG_IRQCONTEXT (1 << 2)
 #define FLAG_STARTED (1 << 3)
@@ -32,9 +31,6 @@
 #define ONESHOT  0
 #define PERIODIC 1
 
-#define RELATIVE 0
-#define ABSOLUTE 1
-
 #define SCALE 64
 
 struct timer8_priv {

commit d1f9db13e36de0d66bbc41e65da0dec08907d23a
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Sun Nov 8 17:39:05 2015 +0100

    clocksource/drivers/h8300_timer8: Remove unused headers
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index 35b0e8f98caf..62a7f8c97091 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -8,21 +8,16 @@
  */
 
 #include <linux/errno.h>
-#include <linux/sched.h>
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>
-#include <linux/slab.h>
 #include <linux/clockchips.h>
-#include <linux/module.h>
 #include <linux/clk.h>
 #include <linux/io.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
 
-#include <asm/irq.h>
-
 #define _8TCR	0
 #define _8TCSR	2
 #define TCORA	4

commit 8c09b7d6ba91ece6d10c7703f5cb201ff3265771
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Mon Nov 9 09:02:38 2015 +0100

    clocksource/drivers/h8300_timer8: Fix compilation error with dev_warn
    
    The dev_warn is using the platform driver which was removed in the previous
    patch.
    
    Let's replace dev_warn by pr_warn.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index f0680eb4f93d..35b0e8f98caf 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -98,7 +98,7 @@ static void timer8_set_next(struct timer8_priv *p, unsigned long delta)
 
 	raw_spin_lock_irqsave(&p->lock, flags);
 	if (delta >= 0x10000)
-		dev_warn(&p->pdev->dev, "delta out of range\n");
+		pr_warn("delta out of range\n");
 	now = timer8_get_counter(p);
 	p->tcora = delta;
 	ctrl_outb(ctrl_inb(p->mapbase + _8TCR) | 0x40, p->mapbase + _8TCR);

commit 4633f4cac85ad19f586fdd4f832ebd145190a68c
Author: Yoshinori Sato <ysato@users.sourceforge.jp>
Date:   Sat Nov 7 01:31:44 2015 +0900

    clocksource/drivers/h8300: Cleanup startup and remove module code.
    
    Remove some legacy code and replace it by the clksrc-of code.
    
    Do some cleanup and code consolidation.
    
    Signed-off-by: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index 44375d8b9bc4..f0680eb4f93d 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -12,13 +12,14 @@
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>
-#include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/clockchips.h>
 #include <linux/module.h>
 #include <linux/clk.h>
 #include <linux/io.h>
 #include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
 
 #include <asm/irq.h>
 
@@ -39,10 +40,10 @@
 #define RELATIVE 0
 #define ABSOLUTE 1
 
+#define SCALE 64
+
 struct timer8_priv {
-	struct platform_device *pdev;
 	struct clock_event_device ced;
-	struct irqaction irqaction;
 	unsigned long mapbase;
 	raw_spinlock_t lock;
 	unsigned long flags;
@@ -111,7 +112,7 @@ static void timer8_set_next(struct timer8_priv *p, unsigned long delta)
 
 static int timer8_enable(struct timer8_priv *p)
 {
-	p->rate = clk_get_rate(p->pclk) / 64;
+	p->rate = clk_get_rate(p->pclk) / SCALE;
 	ctrl_outw(0xffff, p->mapbase + TCORA);
 	ctrl_outw(0x0000, p->mapbase + _8TCNT);
 	ctrl_outw(0x0c02, p->mapbase + _8TCR);
@@ -179,7 +180,7 @@ static int timer8_clock_event_periodic(struct clock_event_device *ced)
 {
 	struct timer8_priv *p = ced_to_priv(ced);
 
-	dev_info(&p->pdev->dev, "used for periodic clock events\n");
+	pr_info("%s: used for periodic clock events\n", ced->name);
 	timer8_stop(p);
 	timer8_clock_event_start(p, PERIODIC);
 
@@ -190,7 +191,7 @@ static int timer8_clock_event_oneshot(struct clock_event_device *ced)
 {
 	struct timer8_priv *p = ced_to_priv(ced);
 
-	dev_info(&p->pdev->dev, "used for oneshot clock events\n");
+	pr_info("%s: used for oneshot clock events\n", ced->name);
 	timer8_stop(p);
 	timer8_clock_event_start(p, ONESHOT);
 
@@ -208,110 +209,61 @@ static int timer8_clock_event_next(unsigned long delta,
 	return 0;
 }
 
-static int timer8_setup(struct timer8_priv *p,
-			struct platform_device *pdev)
+static struct timer8_priv timer8_priv = {
+	.ced = {
+		.name = "h8300_8timer",
+		.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+		.rating = 200,
+		.set_next_event = timer8_clock_event_next,
+		.set_state_shutdown = timer8_clock_event_shutdown,
+		.set_state_periodic = timer8_clock_event_periodic,
+		.set_state_oneshot = timer8_clock_event_oneshot,
+	},
+};
+
+static void __init h8300_8timer_init(struct device_node *node)
 {
-	struct resource *res;
+	void __iomem *base;
 	int irq;
-	int ret;
+	int ret = 0;
+	int rate;
+	struct clk *clk;
 
-	p->pdev = pdev;
+	clk = of_clk_get(node, 0);
+	if (IS_ERR(clk)) {
+		pr_err("failed to get clock for clockevent\n");
+		return;
+	}
 
-	res = platform_get_resource(p->pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&p->pdev->dev, "failed to get I/O memory\n");
-		return -ENXIO;
+	base = of_iomap(node, 0);
+	if (!base) {
+		pr_err("failed to map registers for clockevent\n");
+		goto free_clk;
 	}
 
-	irq = platform_get_irq(p->pdev, 0);
+	irq = irq_of_parse_and_map(node, 0);
 	if (irq < 0) {
-		dev_err(&p->pdev->dev, "failed to get irq\n");
-		return -ENXIO;
+		pr_err("failed to get irq for clockevent\n");
+		goto unmap_reg;
 	}
 
-	p->mapbase = res->start;
-
-	p->irqaction.name = dev_name(&p->pdev->dev);
-	p->irqaction.handler = timer8_interrupt;
-	p->irqaction.dev_id = p;
-	p->irqaction.flags = IRQF_TIMER;
-
-	p->pclk = clk_get(&p->pdev->dev, "fck");
-	if (IS_ERR(p->pclk)) {
-		dev_err(&p->pdev->dev, "can't get clk\n");
-		return PTR_ERR(p->pclk);
-	}
+	timer8_priv.mapbase = (unsigned long)base;
+	timer8_priv.pclk = clk;
 
-	p->ced.name = pdev->name;
-	p->ced.features = CLOCK_EVT_FEAT_PERIODIC |
-		CLOCK_EVT_FEAT_ONESHOT;
-	p->ced.rating = 200;
-	p->ced.cpumask = cpumask_of(0);
-	p->ced.set_next_event = timer8_clock_event_next;
-	p->ced.set_state_shutdown = timer8_clock_event_shutdown;
-	p->ced.set_state_periodic = timer8_clock_event_periodic;
-	p->ced.set_state_oneshot = timer8_clock_event_oneshot;
-
-	ret = setup_irq(irq, &p->irqaction);
+	ret = request_irq(irq, timer8_interrupt,
+			  IRQF_TIMER, timer8_priv.ced.name, &timer8_priv);
 	if (ret < 0) {
-		dev_err(&p->pdev->dev,
-			"failed to request irq %d\n", irq);
-		return ret;
+		pr_err("failed to request irq %d for clockevent\n", irq);
+		goto unmap_reg;
 	}
-	clockevents_register_device(&p->ced);
-	platform_set_drvdata(pdev, p);
-
-	return 0;
-}
-
-static int timer8_probe(struct platform_device *pdev)
-{
-	struct timer8_priv *p = platform_get_drvdata(pdev);
-
-	if (p) {
-		dev_info(&pdev->dev, "kept as earlytimer\n");
-		return 0;
-	}
-
-	p = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);
-	if (!p)
-		return -ENOMEM;
-
-	return timer8_setup(p, pdev);
-}
-
-static int timer8_remove(struct platform_device *pdev)
-{
-	return -EBUSY;
-}
-
-static const struct of_device_id timer8_of_table[] __maybe_unused = {
-	{ .compatible = "renesas,8bit-timer" },
-	{ }
-};
-
-MODULE_DEVICE_TABLE(of, timer8_of_table);
-static struct platform_driver timer8_driver = {
-	.probe		= timer8_probe,
-	.remove		= timer8_remove,
-	.driver		= {
-		.name	= "h8300-8timer",
-		.of_match_table = of_match_ptr(timer8_of_table),
-	}
-};
-
-static int __init timer8_init(void)
-{
-	return platform_driver_register(&timer8_driver);
-}
-
-static void __exit timer8_exit(void)
-{
-	platform_driver_unregister(&timer8_driver);
+	rate = clk_get_rate(clk) / SCALE;
+	clockevents_config_and_register(&timer8_priv.ced, rate, 1, 0x0000ffff);
+	return;
+
+unmap_reg:
+	iounmap(base);
+free_clk:
+	clk_put(clk);
 }
 
-subsys_initcall(timer8_init);
-module_exit(timer8_exit);
-MODULE_AUTHOR("Yoshinori Sato");
-MODULE_DESCRIPTION("H8/300 8bit Timer Driver");
-MODULE_LICENSE("GPL v2");
+CLOCKSOURCE_OF_DECLARE(h8300_8bit, "renesas,8bit-timer", h8300_8timer_init);

commit ba49af35be8a41af7f00a37902a2d70764078bc5
Author: Alexey Klimov <alexey.klimov@linaro.org>
Date:   Thu Sep 10 03:38:21 2015 +0300

    clocksource/drivers/h8300_*: Remove unneeded memset()s
    
    Memory for timer16_priv, timer8_priv and tpu_priv structs is
    allocated by devm_kzalloc() in corresponding probe functions
    of drivers.
    No need to zero it one more time.
    
    Signed-off-by: Alexey Klimov <alexey.klimov@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index f9b3b7033a97..44375d8b9bc4 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -215,7 +215,6 @@ static int timer8_setup(struct timer8_priv *p,
 	int irq;
 	int ret;
 
-	memset(p, 0, sizeof(*p));
 	p->pdev = pdev;
 
 	res = platform_get_resource(p->pdev, IORESOURCE_MEM, 0);

commit fc2b2f5df6d8dbf78c958a34628a3880150d6c9e
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 27 15:02:00 2015 +0530

    clockevents/drivers/h8300_timer8: Migrate to new 'set-state' interface
    
    Migrate h8300_timer8 driver to the new 'set-state' interface provided by
    clockevents core, the earlier 'set-mode' interface is marked obsolete
    now.
    
    This also enables us to implement callbacks for new states of clockevent
    devices, for example: ONESHOT_STOPPED.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index 0214cb3a7f5e..f9b3b7033a97 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -81,7 +81,7 @@ static irqreturn_t timer8_interrupt(int irq, void *dev_id)
 	p->flags |= FLAG_IRQCONTEXT;
 	ctrl_outw(p->tcora, p->mapbase + TCORA);
 	if (!(p->flags & FLAG_SKIPEVENT)) {
-		if (p->ced.mode == CLOCK_EVT_MODE_ONESHOT)
+		if (clockevent_state_oneshot(&p->ced))
 			ctrl_outw(0x0000, p->mapbase + _8TCR);
 		p->ced.event_handler(&p->ced);
 	}
@@ -169,29 +169,32 @@ static void timer8_clock_event_start(struct timer8_priv *p, int periodic)
 	timer8_set_next(p, periodic?(p->rate + HZ/2) / HZ:0x10000);
 }
 
-static void timer8_clock_event_mode(enum clock_event_mode mode,
-				    struct clock_event_device *ced)
+static int timer8_clock_event_shutdown(struct clock_event_device *ced)
+{
+	timer8_stop(ced_to_priv(ced));
+	return 0;
+}
+
+static int timer8_clock_event_periodic(struct clock_event_device *ced)
 {
 	struct timer8_priv *p = ced_to_priv(ced);
 
-	switch (mode) {
-	case CLOCK_EVT_MODE_PERIODIC:
-		dev_info(&p->pdev->dev, "used for periodic clock events\n");
-		timer8_stop(p);
-		timer8_clock_event_start(p, PERIODIC);
-		break;
-	case CLOCK_EVT_MODE_ONESHOT:
-		dev_info(&p->pdev->dev, "used for oneshot clock events\n");
-		timer8_stop(p);
-		timer8_clock_event_start(p, ONESHOT);
-		break;
-	case CLOCK_EVT_MODE_SHUTDOWN:
-	case CLOCK_EVT_MODE_UNUSED:
-		timer8_stop(p);
-		break;
-	default:
-		break;
-	}
+	dev_info(&p->pdev->dev, "used for periodic clock events\n");
+	timer8_stop(p);
+	timer8_clock_event_start(p, PERIODIC);
+
+	return 0;
+}
+
+static int timer8_clock_event_oneshot(struct clock_event_device *ced)
+{
+	struct timer8_priv *p = ced_to_priv(ced);
+
+	dev_info(&p->pdev->dev, "used for oneshot clock events\n");
+	timer8_stop(p);
+	timer8_clock_event_start(p, ONESHOT);
+
+	return 0;
 }
 
 static int timer8_clock_event_next(unsigned long delta,
@@ -199,7 +202,7 @@ static int timer8_clock_event_next(unsigned long delta,
 {
 	struct timer8_priv *p = ced_to_priv(ced);
 
-	BUG_ON(ced->mode != CLOCK_EVT_MODE_ONESHOT);
+	BUG_ON(!clockevent_state_oneshot(ced));
 	timer8_set_next(p, delta - 1);
 
 	return 0;
@@ -246,7 +249,9 @@ static int timer8_setup(struct timer8_priv *p,
 	p->ced.rating = 200;
 	p->ced.cpumask = cpumask_of(0);
 	p->ced.set_next_event = timer8_clock_event_next;
-	p->ced.set_mode = timer8_clock_event_mode;
+	p->ced.set_state_shutdown = timer8_clock_event_shutdown;
+	p->ced.set_state_periodic = timer8_clock_event_periodic;
+	p->ced.set_state_oneshot = timer8_clock_event_oneshot;
 
 	ret = setup_irq(irq, &p->irqaction);
 	if (ret < 0) {

commit 07834743f42b4f27a21010cf5bab483b3ae3d13d
Author: Yoshinori Sato <ysato@users.sourceforge.jp>
Date:   Tue Jun 9 02:24:11 2015 +0900

    h8300: fix typo.
    
    Signed-off-by: Yoshinori Sato <ysato@users.sourceforge.jp>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
index 1c6f8b935a7b..0214cb3a7f5e 100644
--- a/drivers/clocksource/h8300_timer8.c
+++ b/drivers/clocksource/h8300_timer8.c
@@ -286,7 +286,7 @@ static const struct of_device_id timer8_of_table[] __maybe_unused = {
 	{ }
 };
 
-MODULE_DEVICE_TABLE(of, sh_cmt_of_table);
+MODULE_DEVICE_TABLE(of, timer8_of_table);
 static struct platform_driver timer8_driver = {
 	.probe		= timer8_probe,
 	.remove		= timer8_remove,

commit 618b902d8c098f2fff188119da7b3184c4bc5483
Author: Yoshinori Sato <ysato@users.sourceforge.jp>
Date:   Wed Jan 28 02:52:42 2015 +0900

    h8300: clocksource
    
    h8300_timer8: 8bit clockevent device
    h8300_timer16 / h8300_tpu: 16bit clocksource
    
    Signed-off-by: Yoshinori Sato <ysato@users.sourceforge.jp>

diff --git a/drivers/clocksource/h8300_timer8.c b/drivers/clocksource/h8300_timer8.c
new file mode 100644
index 000000000000..1c6f8b935a7b
--- /dev/null
+++ b/drivers/clocksource/h8300_timer8.c
@@ -0,0 +1,313 @@
+/*
+ *  linux/arch/h8300/kernel/cpu/timer/timer8.c
+ *
+ *  Yoshinori Sato <ysato@users.sourcefoge.jp>
+ *
+ *  8bit Timer driver
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/clockchips.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/of.h>
+
+#include <asm/irq.h>
+
+#define _8TCR	0
+#define _8TCSR	2
+#define TCORA	4
+#define TCORB	6
+#define _8TCNT	8
+
+#define FLAG_REPROGRAM (1 << 0)
+#define FLAG_SKIPEVENT (1 << 1)
+#define FLAG_IRQCONTEXT (1 << 2)
+#define FLAG_STARTED (1 << 3)
+
+#define ONESHOT  0
+#define PERIODIC 1
+
+#define RELATIVE 0
+#define ABSOLUTE 1
+
+struct timer8_priv {
+	struct platform_device *pdev;
+	struct clock_event_device ced;
+	struct irqaction irqaction;
+	unsigned long mapbase;
+	raw_spinlock_t lock;
+	unsigned long flags;
+	unsigned int rate;
+	unsigned int tcora;
+	struct clk *pclk;
+};
+
+static unsigned long timer8_get_counter(struct timer8_priv *p)
+{
+	unsigned long v1, v2, v3;
+	int o1, o2;
+
+	o1 = ctrl_inb(p->mapbase + _8TCSR) & 0x20;
+
+	/* Make sure the timer value is stable. Stolen from acpi_pm.c */
+	do {
+		o2 = o1;
+		v1 = ctrl_inw(p->mapbase + _8TCNT);
+		v2 = ctrl_inw(p->mapbase + _8TCNT);
+		v3 = ctrl_inw(p->mapbase + _8TCNT);
+		o1 = ctrl_inb(p->mapbase + _8TCSR) & 0x20;
+	} while (unlikely((o1 != o2) || (v1 > v2 && v1 < v3)
+			  || (v2 > v3 && v2 < v1) || (v3 > v1 && v3 < v2)));
+
+	v2 |= o1 << 10;
+	return v2;
+}
+
+static irqreturn_t timer8_interrupt(int irq, void *dev_id)
+{
+	struct timer8_priv *p = dev_id;
+
+	ctrl_outb(ctrl_inb(p->mapbase + _8TCSR) & ~0x40,
+		  p->mapbase + _8TCSR);
+	p->flags |= FLAG_IRQCONTEXT;
+	ctrl_outw(p->tcora, p->mapbase + TCORA);
+	if (!(p->flags & FLAG_SKIPEVENT)) {
+		if (p->ced.mode == CLOCK_EVT_MODE_ONESHOT)
+			ctrl_outw(0x0000, p->mapbase + _8TCR);
+		p->ced.event_handler(&p->ced);
+	}
+	p->flags &= ~(FLAG_SKIPEVENT | FLAG_IRQCONTEXT);
+
+	return IRQ_HANDLED;
+}
+
+static void timer8_set_next(struct timer8_priv *p, unsigned long delta)
+{
+	unsigned long flags;
+	unsigned long now;
+
+	raw_spin_lock_irqsave(&p->lock, flags);
+	if (delta >= 0x10000)
+		dev_warn(&p->pdev->dev, "delta out of range\n");
+	now = timer8_get_counter(p);
+	p->tcora = delta;
+	ctrl_outb(ctrl_inb(p->mapbase + _8TCR) | 0x40, p->mapbase + _8TCR);
+	if (delta > now)
+		ctrl_outw(delta, p->mapbase + TCORA);
+	else
+		ctrl_outw(now + 1, p->mapbase + TCORA);
+
+	raw_spin_unlock_irqrestore(&p->lock, flags);
+}
+
+static int timer8_enable(struct timer8_priv *p)
+{
+	p->rate = clk_get_rate(p->pclk) / 64;
+	ctrl_outw(0xffff, p->mapbase + TCORA);
+	ctrl_outw(0x0000, p->mapbase + _8TCNT);
+	ctrl_outw(0x0c02, p->mapbase + _8TCR);
+
+	return 0;
+}
+
+static int timer8_start(struct timer8_priv *p)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&p->lock, flags);
+
+	if (!(p->flags & FLAG_STARTED))
+		ret = timer8_enable(p);
+
+	if (ret)
+		goto out;
+	p->flags |= FLAG_STARTED;
+
+ out:
+	raw_spin_unlock_irqrestore(&p->lock, flags);
+
+	return ret;
+}
+
+static void timer8_stop(struct timer8_priv *p)
+{
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&p->lock, flags);
+
+	ctrl_outw(0x0000, p->mapbase + _8TCR);
+
+	raw_spin_unlock_irqrestore(&p->lock, flags);
+}
+
+static inline struct timer8_priv *ced_to_priv(struct clock_event_device *ced)
+{
+	return container_of(ced, struct timer8_priv, ced);
+}
+
+static void timer8_clock_event_start(struct timer8_priv *p, int periodic)
+{
+	struct clock_event_device *ced = &p->ced;
+
+	timer8_start(p);
+
+	ced->shift = 32;
+	ced->mult = div_sc(p->rate, NSEC_PER_SEC, ced->shift);
+	ced->max_delta_ns = clockevent_delta2ns(0xffff, ced);
+	ced->min_delta_ns = clockevent_delta2ns(0x0001, ced);
+
+	timer8_set_next(p, periodic?(p->rate + HZ/2) / HZ:0x10000);
+}
+
+static void timer8_clock_event_mode(enum clock_event_mode mode,
+				    struct clock_event_device *ced)
+{
+	struct timer8_priv *p = ced_to_priv(ced);
+
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		dev_info(&p->pdev->dev, "used for periodic clock events\n");
+		timer8_stop(p);
+		timer8_clock_event_start(p, PERIODIC);
+		break;
+	case CLOCK_EVT_MODE_ONESHOT:
+		dev_info(&p->pdev->dev, "used for oneshot clock events\n");
+		timer8_stop(p);
+		timer8_clock_event_start(p, ONESHOT);
+		break;
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	case CLOCK_EVT_MODE_UNUSED:
+		timer8_stop(p);
+		break;
+	default:
+		break;
+	}
+}
+
+static int timer8_clock_event_next(unsigned long delta,
+				   struct clock_event_device *ced)
+{
+	struct timer8_priv *p = ced_to_priv(ced);
+
+	BUG_ON(ced->mode != CLOCK_EVT_MODE_ONESHOT);
+	timer8_set_next(p, delta - 1);
+
+	return 0;
+}
+
+static int timer8_setup(struct timer8_priv *p,
+			struct platform_device *pdev)
+{
+	struct resource *res;
+	int irq;
+	int ret;
+
+	memset(p, 0, sizeof(*p));
+	p->pdev = pdev;
+
+	res = platform_get_resource(p->pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&p->pdev->dev, "failed to get I/O memory\n");
+		return -ENXIO;
+	}
+
+	irq = platform_get_irq(p->pdev, 0);
+	if (irq < 0) {
+		dev_err(&p->pdev->dev, "failed to get irq\n");
+		return -ENXIO;
+	}
+
+	p->mapbase = res->start;
+
+	p->irqaction.name = dev_name(&p->pdev->dev);
+	p->irqaction.handler = timer8_interrupt;
+	p->irqaction.dev_id = p;
+	p->irqaction.flags = IRQF_TIMER;
+
+	p->pclk = clk_get(&p->pdev->dev, "fck");
+	if (IS_ERR(p->pclk)) {
+		dev_err(&p->pdev->dev, "can't get clk\n");
+		return PTR_ERR(p->pclk);
+	}
+
+	p->ced.name = pdev->name;
+	p->ced.features = CLOCK_EVT_FEAT_PERIODIC |
+		CLOCK_EVT_FEAT_ONESHOT;
+	p->ced.rating = 200;
+	p->ced.cpumask = cpumask_of(0);
+	p->ced.set_next_event = timer8_clock_event_next;
+	p->ced.set_mode = timer8_clock_event_mode;
+
+	ret = setup_irq(irq, &p->irqaction);
+	if (ret < 0) {
+		dev_err(&p->pdev->dev,
+			"failed to request irq %d\n", irq);
+		return ret;
+	}
+	clockevents_register_device(&p->ced);
+	platform_set_drvdata(pdev, p);
+
+	return 0;
+}
+
+static int timer8_probe(struct platform_device *pdev)
+{
+	struct timer8_priv *p = platform_get_drvdata(pdev);
+
+	if (p) {
+		dev_info(&pdev->dev, "kept as earlytimer\n");
+		return 0;
+	}
+
+	p = devm_kzalloc(&pdev->dev, sizeof(*p), GFP_KERNEL);
+	if (!p)
+		return -ENOMEM;
+
+	return timer8_setup(p, pdev);
+}
+
+static int timer8_remove(struct platform_device *pdev)
+{
+	return -EBUSY;
+}
+
+static const struct of_device_id timer8_of_table[] __maybe_unused = {
+	{ .compatible = "renesas,8bit-timer" },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, sh_cmt_of_table);
+static struct platform_driver timer8_driver = {
+	.probe		= timer8_probe,
+	.remove		= timer8_remove,
+	.driver		= {
+		.name	= "h8300-8timer",
+		.of_match_table = of_match_ptr(timer8_of_table),
+	}
+};
+
+static int __init timer8_init(void)
+{
+	return platform_driver_register(&timer8_driver);
+}
+
+static void __exit timer8_exit(void)
+{
+	platform_driver_unregister(&timer8_driver);
+}
+
+subsys_initcall(timer8_init);
+module_exit(timer8_exit);
+MODULE_AUTHOR("Yoshinori Sato");
+MODULE_DESCRIPTION("H8/300 8bit Timer Driver");
+MODULE_LICENSE("GPL v2");
