commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/clocksource/mmio.c b/drivers/clocksource/mmio.c
index 4c4df981d8cc..9de751531831 100644
--- a/drivers/clocksource/mmio.c
+++ b/drivers/clocksource/mmio.c
@@ -1,9 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Generic MMIO clocksource support
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #include <linux/clocksource.h>
 #include <linux/errno.h>

commit a5a1d1c2914b5316924c7893eb683a5420ebd3be
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Dec 21 20:32:01 2016 +0100

    clocksource: Use a plain u64 instead of cycle_t
    
    There is no point in having an extra type for extra confusion. u64 is
    unambiguous.
    
    Conversion was done with the following coccinelle script:
    
    @rem@
    @@
    -typedef u64 cycle_t;
    
    @fix@
    typedef cycle_t;
    @@
    -cycle_t
    +u64
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: John Stultz <john.stultz@linaro.org>

diff --git a/drivers/clocksource/mmio.c b/drivers/clocksource/mmio.c
index c4f7d7a9b689..4c4df981d8cc 100644
--- a/drivers/clocksource/mmio.c
+++ b/drivers/clocksource/mmio.c
@@ -20,24 +20,24 @@ static inline struct clocksource_mmio *to_mmio_clksrc(struct clocksource *c)
 	return container_of(c, struct clocksource_mmio, clksrc);
 }
 
-cycle_t clocksource_mmio_readl_up(struct clocksource *c)
+u64 clocksource_mmio_readl_up(struct clocksource *c)
 {
-	return (cycle_t)readl_relaxed(to_mmio_clksrc(c)->reg);
+	return (u64)readl_relaxed(to_mmio_clksrc(c)->reg);
 }
 
-cycle_t clocksource_mmio_readl_down(struct clocksource *c)
+u64 clocksource_mmio_readl_down(struct clocksource *c)
 {
-	return ~(cycle_t)readl_relaxed(to_mmio_clksrc(c)->reg) & c->mask;
+	return ~(u64)readl_relaxed(to_mmio_clksrc(c)->reg) & c->mask;
 }
 
-cycle_t clocksource_mmio_readw_up(struct clocksource *c)
+u64 clocksource_mmio_readw_up(struct clocksource *c)
 {
-	return (cycle_t)readw_relaxed(to_mmio_clksrc(c)->reg);
+	return (u64)readw_relaxed(to_mmio_clksrc(c)->reg);
 }
 
-cycle_t clocksource_mmio_readw_down(struct clocksource *c)
+u64 clocksource_mmio_readw_down(struct clocksource *c)
 {
-	return ~(cycle_t)readw_relaxed(to_mmio_clksrc(c)->reg) & c->mask;
+	return ~(u64)readw_relaxed(to_mmio_clksrc(c)->reg) & c->mask;
 }
 
 /**
@@ -51,7 +51,7 @@ cycle_t clocksource_mmio_readw_down(struct clocksource *c)
  */
 int __init clocksource_mmio_init(void __iomem *base, const char *name,
 	unsigned long hz, int rating, unsigned bits,
-	cycle_t (*read)(struct clocksource *))
+	u64 (*read)(struct clocksource *))
 {
 	struct clocksource_mmio *cs;
 

commit e2bf3e6ecaff79c5479682da2dc7b2035e52c5b8
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Dec 10 18:21:41 2015 +0100

    clocksource: Mmio: remove artificial 32bit limitation
    
    The EP93xx is registering a clocksource of 40 bits with
    clocksource_mmio_init() but this is not working because of this
    artificial limitation. It works fine to lift the uppe limit to
    64 bits, and since cycle_t is u64, it should intuitively have been
    like that from the beginning.
    
    Fixes: 000bc17817bf "ARM: ep93xx: switch to GENERIC_CLOCKEVENTS"
    Reported-by: Alexander Sverdlin <alexander.sverdlin@gmail.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: http://lkml.kernel.org/r/1449768101-6879-1-git-send-email-linus.walleij@linaro.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/clocksource/mmio.c b/drivers/clocksource/mmio.c
index 1593ade2a815..c4f7d7a9b689 100644
--- a/drivers/clocksource/mmio.c
+++ b/drivers/clocksource/mmio.c
@@ -55,7 +55,7 @@ int __init clocksource_mmio_init(void __iomem *base, const char *name,
 {
 	struct clocksource_mmio *cs;
 
-	if (bits > 32 || bits < 16)
+	if (bits > 64 || bits < 16)
 		return -EINVAL;
 
 	cs = kzalloc(sizeof(struct clocksource_mmio), GFP_KERNEL);

commit 95c19a06ec1cf9530ebb8f2c7eeda1d7398b43f1
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Wed Apr 23 10:12:00 2014 +0800

    clocksource: Fix clocksource_mmio_readX_down
    
    For some clocksource devices, for example, the registers are 32-bit, while
    the lower 16-bit is used for timer counting(And reading the upper 16-bit
    will return 0).
    
    For example, when the counter value is 0x00001111, and then the
    ~readl_relaxed(to_mmio_clksrc(c)->reg) will return the value of 0xFFFFEEEE,
    but it should be 0x0000EEEE.
    
    So just using the c->mask to mask the unused bits.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/mmio.c b/drivers/clocksource/mmio.c
index 19a6b3f4d9cf..1593ade2a815 100644
--- a/drivers/clocksource/mmio.c
+++ b/drivers/clocksource/mmio.c
@@ -27,7 +27,7 @@ cycle_t clocksource_mmio_readl_up(struct clocksource *c)
 
 cycle_t clocksource_mmio_readl_down(struct clocksource *c)
 {
-	return ~(cycle_t)readl_relaxed(to_mmio_clksrc(c)->reg);
+	return ~(cycle_t)readl_relaxed(to_mmio_clksrc(c)->reg) & c->mask;
 }
 
 cycle_t clocksource_mmio_readw_up(struct clocksource *c)
@@ -37,7 +37,7 @@ cycle_t clocksource_mmio_readw_up(struct clocksource *c)
 
 cycle_t clocksource_mmio_readw_down(struct clocksource *c)
 {
-	return ~(cycle_t)readw_relaxed(to_mmio_clksrc(c)->reg);
+	return ~(cycle_t)readw_relaxed(to_mmio_clksrc(c)->reg) & c->mask;
 }
 
 /**

commit 4a3ae07413844733e4cb3765f67a752b846df913
Author: Xiubo Li <Li.Xiubo@freescale.com>
Date:   Wed Apr 23 10:11:59 2014 +0800

    clocksource: Fix type confusion for clocksource_mmio_readX_Y
    
    The types' definations are:
       o  cycle_t       -> u64
       o  readl_relaxed -> u32
       o  readw_relaxed -> u16
    
    So let clocksource_mmio_readX_Ys return a cast to cycle_t, though
    this maybe look reduntant sometimes, it make sense and they will be
    more readable and less confusion...
    
    This patch clarifies the functions type and fix it.
    
    Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/mmio.c b/drivers/clocksource/mmio.c
index c0e25125a55e..19a6b3f4d9cf 100644
--- a/drivers/clocksource/mmio.c
+++ b/drivers/clocksource/mmio.c
@@ -22,22 +22,22 @@ static inline struct clocksource_mmio *to_mmio_clksrc(struct clocksource *c)
 
 cycle_t clocksource_mmio_readl_up(struct clocksource *c)
 {
-	return readl_relaxed(to_mmio_clksrc(c)->reg);
+	return (cycle_t)readl_relaxed(to_mmio_clksrc(c)->reg);
 }
 
 cycle_t clocksource_mmio_readl_down(struct clocksource *c)
 {
-	return ~readl_relaxed(to_mmio_clksrc(c)->reg);
+	return ~(cycle_t)readl_relaxed(to_mmio_clksrc(c)->reg);
 }
 
 cycle_t clocksource_mmio_readw_up(struct clocksource *c)
 {
-	return readw_relaxed(to_mmio_clksrc(c)->reg);
+	return (cycle_t)readw_relaxed(to_mmio_clksrc(c)->reg);
 }
 
 cycle_t clocksource_mmio_readw_down(struct clocksource *c)
 {
-	return ~(unsigned)readw_relaxed(to_mmio_clksrc(c)->reg);
+	return ~(cycle_t)readw_relaxed(to_mmio_clksrc(c)->reg);
 }
 
 /**

commit 442c8176d2efa468577738e3a99a6e051f6e8e55
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun May 8 14:06:52 2011 +0100

    clocksource: add common mmio clocksource
    
    Add a generic mmio clocksource, covering both 32-bit and 16-bit register
    access sizes, for up or down counters.  This can be used to easily
    create clocksources for simple counter-based implementations.
    
    Cc: Alessandro Rubini <rubini@unipv.it>
    Cc: Colin Cross <ccross@android.com>
    Cc: Eric Miao <eric.y.miao@gmail.com>
    Cc: Erik Gilling <konkers@android.com>
    Acked-by: "Hans J. Koch" <hjk@hansjkoch.de>
    Cc: Imre Kaloz <kaloz@openwrt.org>
    Cc: Krzysztof Halasa <khc@pm.waw.pl>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Lennert Buytenhek <kernel@wantstofly.org>
    Cc: Linus Walleij <linus.walleij@stericsson.com>
    Cc: linux-omap@vger.kernel.org
    Acked-by: Nicolas Pitre <nico@fluxnic.net>
    Cc: Olof Johansson <olof@lixom.net>
    Tested-by: Sascha Hauer <s.hauer@pengutronix.de>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@st.com>
    Cc: Wan ZongShun <mcuos.com@gmail.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/clocksource/mmio.c b/drivers/clocksource/mmio.c
new file mode 100644
index 000000000000..c0e25125a55e
--- /dev/null
+++ b/drivers/clocksource/mmio.c
@@ -0,0 +1,73 @@
+/*
+ * Generic MMIO clocksource support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/clocksource.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+
+struct clocksource_mmio {
+	void __iomem *reg;
+	struct clocksource clksrc;
+};
+
+static inline struct clocksource_mmio *to_mmio_clksrc(struct clocksource *c)
+{
+	return container_of(c, struct clocksource_mmio, clksrc);
+}
+
+cycle_t clocksource_mmio_readl_up(struct clocksource *c)
+{
+	return readl_relaxed(to_mmio_clksrc(c)->reg);
+}
+
+cycle_t clocksource_mmio_readl_down(struct clocksource *c)
+{
+	return ~readl_relaxed(to_mmio_clksrc(c)->reg);
+}
+
+cycle_t clocksource_mmio_readw_up(struct clocksource *c)
+{
+	return readw_relaxed(to_mmio_clksrc(c)->reg);
+}
+
+cycle_t clocksource_mmio_readw_down(struct clocksource *c)
+{
+	return ~(unsigned)readw_relaxed(to_mmio_clksrc(c)->reg);
+}
+
+/**
+ * clocksource_mmio_init - Initialize a simple mmio based clocksource
+ * @base:	Virtual address of the clock readout register
+ * @name:	Name of the clocksource
+ * @hz:		Frequency of the clocksource in Hz
+ * @rating:	Rating of the clocksource
+ * @bits:	Number of valid bits
+ * @read:	One of clocksource_mmio_read*() above
+ */
+int __init clocksource_mmio_init(void __iomem *base, const char *name,
+	unsigned long hz, int rating, unsigned bits,
+	cycle_t (*read)(struct clocksource *))
+{
+	struct clocksource_mmio *cs;
+
+	if (bits > 32 || bits < 16)
+		return -EINVAL;
+
+	cs = kzalloc(sizeof(struct clocksource_mmio), GFP_KERNEL);
+	if (!cs)
+		return -ENOMEM;
+
+	cs->reg = base;
+	cs->clksrc.name = name;
+	cs->clksrc.rating = rating;
+	cs->clksrc.read = read;
+	cs->clksrc.mask = CLOCKSOURCE_MASK(bits);
+	cs->clksrc.flags = CLOCK_SOURCE_IS_CONTINUOUS;
+
+	return clocksource_register_hz(&cs->clksrc, hz);
+}
