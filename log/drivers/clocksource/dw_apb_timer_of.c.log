commit 6d2e16a3181bafb77b535095c39ad1c8b9558c8c
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Thu May 21 23:48:15 2020 +0300

    clocksource: dw_apb_timer_of: Fix missing clockevent timers
    
    Commit 100214889973 ("clocksource: dw_apb_timer_of: use
    clocksource_of_init") replaced a publicly available driver
    initialization method with one called by the timer_probe() method
    available after CLKSRC_OF. In current implementation it traverses
    all the timers available in the system and calls their initialization
    methods if corresponding devices were either in dtb or in acpi. But
    if before the commit any number of available timers would be installed
    as clockevent and clocksource devices, after that there would be at most
    two. The rest are just ignored since default case branch doesn't do
    anything. I don't see a reason of such behaviour, neither the commit
    message explains it. Moreover this might be wrong if on some platforms
    these timers might be used for different purpose, as virtually CPU-local
    clockevent timers and as an independent broadcast timer. So in order
    to keep the compatibility with the platforms where the order of the
    timers detection has some meaning, lets add the secondly discovered
    timer to be of clocksource/sched_clock type, while the very first and
    the others would provide the clockevents service.
    
    Fixes: 100214889973 ("clocksource: dw_apb_timer_of: use clocksource_of_init")
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Cc: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-rtc@vger.kernel.org
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20200521204818.25436-7-Sergey.Semin@baikalelectronics.ru

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index 2db490f35c20..ab3ddebe8344 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -147,10 +147,6 @@ static int num_called;
 static int __init dw_apb_timer_init(struct device_node *timer)
 {
 	switch (num_called) {
-	case 0:
-		pr_debug("%s: found clockevent timer\n", __func__);
-		add_clockevent(timer);
-		break;
 	case 1:
 		pr_debug("%s: found clocksource timer\n", __func__);
 		add_clocksource(timer);
@@ -161,6 +157,8 @@ static int __init dw_apb_timer_init(struct device_node *timer)
 #endif
 		break;
 	default:
+		pr_debug("%s: found clockevent timer\n", __func__);
+		add_clockevent(timer);
 		break;
 	}
 

commit 65e0f876405ef4f0ff25eb1c5ff3e9b536d68805
Author: Serge Semin <Sergey.Semin@baikalelectronics.ru>
Date:   Thu May 21 23:48:14 2020 +0300

    clocksource: dw_apb_timer: Affiliate of-based timer with any CPU
    
    Currently any DW APB Timer device detected in OF is bound to CPU #0.
    Doing so is redundant since DW APB Timer isn't CPU-local timer, but as
    having APB interface is normally accessible from any CPU in the system. By
    artificially affiliating the DW timer to the very first CPU we may and in
    our case will make the clockevent subsystem to decline the more performant
    real CPU-local timers selection in favor of in fact non-local and
    accessible over a slow bus - DW APB Timers.
    
    Let's not affiliate the of-detected DW APB Timers to any CPU. By doing so
    the clockevent framework would prefer to select the real CPU-local timer
    instead of DW APB one. Otherwise if there is no other than DW APB device
    for clockevents tracking then it will be selected.
    
    Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
    Cc: Alexey Malahov <Alexey.Malahov@baikalelectronics.ru>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-rtc@vger.kernel.org
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Link: https://lore.kernel.org/r/20200521204818.25436-6-Sergey.Semin@baikalelectronics.ru

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index 8c28b127759f..2db490f35c20 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -73,7 +73,7 @@ static void __init add_clockevent(struct device_node *event_timer)
 
 	timer_get_base_and_rate(event_timer, &iobase, &rate);
 
-	ced = dw_apb_clockevent_init(0, event_timer->name, 300, iobase, irq,
+	ced = dw_apb_clockevent_init(-1, event_timer->name, 300, iobase, irq,
 				     rate);
 	if (!ced)
 		panic("Unable to initialise clockevent device");

commit caab277b1de0a22b675c4c95fc7b285ec2eb5bf5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jun 3 07:44:50 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 234
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 503 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190602204653.811534538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index db410acd8964..8c28b127759f 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -1,20 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2012 Altera Corporation
  * Copyright (c) 2011 Picochip Ltd., Jamie Iles
  *
  * Modified from mach-picoxcell/time.c
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 #include <linux/delay.h>
 #include <linux/dw_apb_timer.h>

commit 1f174a1a2cdebc65138e6ed1448b842e73200bb5
Author: Dinh Nguyen <dinguyen@kernel.org>
Date:   Mon Sep 17 09:52:14 2018 -0500

    clocksource/drivers/dw_apb: Add reset control
    
    Add code to retrieve the reset property from the dw-apb timers and if
    the property is available, the safe operation is to assert the timer
    into reset, and followed by a deassert of the timer reset (brings the
    timer out of reset).
    
    This patch is needed for systems where the bootloader has left the timer
    not used in reset.
    
     - Trivial conflict with commit a74bd1ad7a:
        "Convert to using %pOFn instead of device_node.name"
    
    Reported-by: Marek Vasut <marex@denx.de>
    Signed-off-by: Dinh Nguyen <dinguyen@kernel.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index fabaa29cc3a4..db410acd8964 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -22,6 +22,7 @@
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
 #include <linux/clk.h>
+#include <linux/reset.h>
 #include <linux/sched_clock.h>
 
 static void __init timer_get_base_and_rate(struct device_node *np,
@@ -29,12 +30,23 @@ static void __init timer_get_base_and_rate(struct device_node *np,
 {
 	struct clk *timer_clk;
 	struct clk *pclk;
+	struct reset_control *rstc;
 
 	*base = of_iomap(np, 0);
 
 	if (!*base)
 		panic("Unable to map regs for %pOFn", np);
 
+	/*
+	 * Reset the timer if the reset control is available, wiping
+	 * out the state the firmware may have left it
+	 */
+	rstc = of_reset_control_get(np, NULL);
+	if (!IS_ERR(rstc)) {
+		reset_control_assert(rstc);
+		reset_control_deassert(rstc);
+	}
+
 	/*
 	 * Not all implementations use a periphal clock, so don't panic
 	 * if it's not present

commit 2a4849d2674b965cd9eb7e6c010b7c240fb9d218
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 27 20:52:14 2018 -0500

    clocksource: Convert to using %pOFn instead of device_node.name
    
    In preparation to remove the node name pointer from struct device_node,
    convert printf users to use the %pOFn format specifier.
    
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Cc: linux-arm-kernel@lists.infradead.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index 69866cd8f4bb..fabaa29cc3a4 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -33,7 +33,7 @@ static void __init timer_get_base_and_rate(struct device_node *np,
 	*base = of_iomap(np, 0);
 
 	if (!*base)
-		panic("Unable to map regs for %s", np->name);
+		panic("Unable to map regs for %pOFn", np);
 
 	/*
 	 * Not all implementations use a periphal clock, so don't panic
@@ -42,8 +42,8 @@ static void __init timer_get_base_and_rate(struct device_node *np,
 	pclk = of_clk_get_by_name(np, "pclk");
 	if (!IS_ERR(pclk))
 		if (clk_prepare_enable(pclk))
-			pr_warn("pclk for %s is present, but could not be activated\n",
-				np->name);
+			pr_warn("pclk for %pOFn is present, but could not be activated\n",
+				np);
 
 	timer_clk = of_clk_get_by_name(np, "timer");
 	if (IS_ERR(timer_clk))
@@ -57,7 +57,7 @@ static void __init timer_get_base_and_rate(struct device_node *np,
 try_clock_freq:
 	if (of_property_read_u32(np, "clock-freq", rate) &&
 	    of_property_read_u32(np, "clock-frequency", rate))
-		panic("No clock nor clock-frequency property for %s", np->name);
+		panic("No clock nor clock-frequency property for %pOFn", np);
 }
 
 static void __init add_clockevent(struct device_node *event_timer)

commit 1727339590fdb5a1ded881b540cd32121278d414
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Fri May 26 16:56:11 2017 +0200

    clocksource/drivers: Rename CLOCKSOURCE_OF_DECLARE to TIMER_OF_DECLARE
    
    The CLOCKSOURCE_OF_DECLARE macro is used widely for the timers to declare the
    clocksource at early stage. However, this macro is also used to initialize
    the clockevent if any, or the clockevent only.
    
    It was originally suggested to declare another macro to initialize a
    clockevent, so in order to separate the two entities even they belong to the
    same IP. This was not accepted because of the impact on the DT where splitting
    a clocksource/clockevent definition does not make sense as it is a Linux
    concept not a hardware description.
    
    On the other side, the clocksource has not interrupt declared while the
    clockevent has, so it is easy from the driver to know if the description is
    for a clockevent or a clocksource, IOW it could be implemented at the driver
    level.
    
    So instead of dealing with a named clocksource macro, let's use a more generic
    one: TIMER_OF_DECLARE.
    
    The patch has not functional changes.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Matthias Brugger <matthias.bgg@gmail.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index aee6c0d39a7c..69866cd8f4bb 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -167,7 +167,7 @@ static int __init dw_apb_timer_init(struct device_node *timer)
 
 	return 0;
 }
-CLOCKSOURCE_OF_DECLARE(pc3x2_timer, "picochip,pc3x2-timer", dw_apb_timer_init);
-CLOCKSOURCE_OF_DECLARE(apb_timer_osc, "snps,dw-apb-timer-osc", dw_apb_timer_init);
-CLOCKSOURCE_OF_DECLARE(apb_timer_sp, "snps,dw-apb-timer-sp", dw_apb_timer_init);
-CLOCKSOURCE_OF_DECLARE(apb_timer, "snps,dw-apb-timer", dw_apb_timer_init);
+TIMER_OF_DECLARE(pc3x2_timer, "picochip,pc3x2-timer", dw_apb_timer_init);
+TIMER_OF_DECLARE(apb_timer_osc, "snps,dw-apb-timer-osc", dw_apb_timer_init);
+TIMER_OF_DECLARE(apb_timer_sp, "snps,dw-apb-timer-sp", dw_apb_timer_init);
+TIMER_OF_DECLARE(apb_timer, "snps,dw-apb-timer", dw_apb_timer_init);

commit 177cf6e52b0a1a382b9892d3cc9aafd6e7c5943f
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Tue Jun 7 00:27:44 2016 +0200

    clocksources: Switch back to the clksrc table
    
    All the clocksource drivers's init function are now converted to return
    an error code. CLOCKSOURCE_OF_DECLARE is no longer used as well as the
    clksrc-of table.
    
    Let's convert back the names:
     - CLOCKSOURCE_OF_DECLARE_RET => CLOCKSOURCE_OF_DECLARE
     - clksrc-of-ret              => clksrc-of
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    
    For exynos_mct and samsung_pwm_timer:
    Acked-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    
    For arch/arc:
    Acked-by: Vineet Gupta <vgupta@synopsys.com>
    
    For mediatek driver:
    Acked-by: Matthias Brugger <matthias.bgg@gmail.com>
    
    For the Rockchip-part
    Acked-by: Heiko Stuebner <heiko@sntech.de>
    
    For STi :
    Acked-by: Patrice Chotard <patrice.chotard@st.com>
    
    For the mps2-timer.c and versatile.c changes:
    Acked-by: Liviu Dudau <Liviu.Dudau@arm.com>
    
    For the OXNAS part :
    Acked-by: Neil Armstrong <narmstrong@baylibre.com>
    
    For LPC32xx driver:
    Acked-by: Sylvain Lemieux <slemieux.tyco@gmail.com>
    
    For Broadcom Kona timer change:
    Acked-by: Ray Jui <ray.jui@broadcom.com>
    
    For Sun4i and Sun5i:
    Acked-by: Chen-Yu Tsai <wens@csie.org>
    
    For Meson6:
    Acked-by: Carlo Caione <carlo@caione.org>
    
    For Keystone:
    Acked-by: Santosh Shilimkar <ssantosh@kernel.org>
    
    For NPS:
    Acked-by: Noam Camus <noamca@mellanox.com>
    
    For bcm2835:
    Acked-by: Eric Anholt <eric@anholt.net>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index 4985a2cadad9..aee6c0d39a7c 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -167,7 +167,7 @@ static int __init dw_apb_timer_init(struct device_node *timer)
 
 	return 0;
 }
-CLOCKSOURCE_OF_DECLARE_RET(pc3x2_timer, "picochip,pc3x2-timer", dw_apb_timer_init);
-CLOCKSOURCE_OF_DECLARE_RET(apb_timer_osc, "snps,dw-apb-timer-osc", dw_apb_timer_init);
-CLOCKSOURCE_OF_DECLARE_RET(apb_timer_sp, "snps,dw-apb-timer-sp", dw_apb_timer_init);
-CLOCKSOURCE_OF_DECLARE_RET(apb_timer, "snps,dw-apb-timer", dw_apb_timer_init);
+CLOCKSOURCE_OF_DECLARE(pc3x2_timer, "picochip,pc3x2-timer", dw_apb_timer_init);
+CLOCKSOURCE_OF_DECLARE(apb_timer_osc, "snps,dw-apb-timer-osc", dw_apb_timer_init);
+CLOCKSOURCE_OF_DECLARE(apb_timer_sp, "snps,dw-apb-timer-sp", dw_apb_timer_init);
+CLOCKSOURCE_OF_DECLARE(apb_timer, "snps,dw-apb-timer", dw_apb_timer_init);

commit 2e1773f8caef47037486814989e689ff9eacc155
Author: Daniel Lezcano <daniel.lezcano@linaro.org>
Date:   Wed Jun 1 08:55:46 2016 +0200

    clocksource/drivers/dw_apb_timer: Convert init function to return error
    
    The init functions do not return any error. They behave as the following:
    
     - panic, thus leading to a kernel crash while another timer may work and
       make the system boot up correctly
    
     or
    
     - print an error and let the caller unaware if the state of the system
    
    Change that by converting the init functions to return an error conforming
    to the CLOCKSOURCE_OF_RET prototype.
    
    Proper error handling (rollback, errno value) will be changed later case
    by case, thus this change just return back an error or success in the init
    function.
    
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index 860843cef572..4985a2cadad9 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -143,7 +143,7 @@ static struct delay_timer dw_apb_delay_timer = {
 #endif
 
 static int num_called;
-static void __init dw_apb_timer_init(struct device_node *timer)
+static int __init dw_apb_timer_init(struct device_node *timer)
 {
 	switch (num_called) {
 	case 0:
@@ -164,8 +164,10 @@ static void __init dw_apb_timer_init(struct device_node *timer)
 	}
 
 	num_called++;
+
+	return 0;
 }
-CLOCKSOURCE_OF_DECLARE(pc3x2_timer, "picochip,pc3x2-timer", dw_apb_timer_init);
-CLOCKSOURCE_OF_DECLARE(apb_timer_osc, "snps,dw-apb-timer-osc", dw_apb_timer_init);
-CLOCKSOURCE_OF_DECLARE(apb_timer_sp, "snps,dw-apb-timer-sp", dw_apb_timer_init);
-CLOCKSOURCE_OF_DECLARE(apb_timer, "snps,dw-apb-timer", dw_apb_timer_init);
+CLOCKSOURCE_OF_DECLARE_RET(pc3x2_timer, "picochip,pc3x2-timer", dw_apb_timer_init);
+CLOCKSOURCE_OF_DECLARE_RET(apb_timer_osc, "snps,dw-apb-timer-osc", dw_apb_timer_init);
+CLOCKSOURCE_OF_DECLARE_RET(apb_timer_sp, "snps,dw-apb-timer-sp", dw_apb_timer_init);
+CLOCKSOURCE_OF_DECLARE_RET(apb_timer, "snps,dw-apb-timer", dw_apb_timer_init);

commit 9115df89d12c2cf6db080a7ee57cd076f8416e4a
Author: Jisheng Zhang <jszhang@marvell.com>
Date:   Thu Nov 5 10:32:06 2015 +0800

    clocksource/drivers/dw_apb_timer_of: Implement ARM delay timer
    
    Implement an ARM delay timer to be used for udelay(). This allows us to
    skip the delay loop calibration at boot on Marvell BG2, BG2Q, BG2CD
    platforms. And after this patch, udelay() will be unaffected by CPU
    frequency changes.
    
    Note: Although in case there are several possible delay timers, we may
    not select the "best" delay timer. Take one Marvell Berlin platform for
    example: we have arch timer and dw-apb timer. The arch timer freq is
    25MHZ while the dw-apb timer freq is 100MHZ, current selection would
    choose the dw-apb timer. But the dw apb timer is on the APB bus while
    arch timer sits in CPU, the cost of accessing the apb timer is higher
    than the arch timer. We could introduce "rating" concept to delay
    timer, but this approach "brings a lot of complexity and workarounds
    in the code for a small benefit" as pointed out by Daniel.
    
    Later, Arnd pointed out "However, we could argue that this actually
    doesn't matter at all, because the entire point of the ndelay()/
    udelay()/mdelay() functions is to waste CPU cycles doing not much at
    all, so we can just as well waste them reading the timer register
    than spinning on the CPU reading the arch timer more often.", so we
    just simply register the dw apb base delay timer.
    
    Signed-off-by: Jisheng Zhang <jszhang@marvell.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index a19a3f619cc7..860843cef572 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -16,6 +16,7 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
+#include <linux/delay.h>
 #include <linux/dw_apb_timer.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
@@ -130,6 +131,17 @@ static void __init init_sched_clock(void)
 	sched_clock_register(read_sched_clock, 32, sched_rate);
 }
 
+#ifdef CONFIG_ARM
+static unsigned long dw_apb_delay_timer_read(void)
+{
+	return ~readl_relaxed(sched_io_base);
+}
+
+static struct delay_timer dw_apb_delay_timer = {
+	.read_current_timer	= dw_apb_delay_timer_read,
+};
+#endif
+
 static int num_called;
 static void __init dw_apb_timer_init(struct device_node *timer)
 {
@@ -142,6 +154,10 @@ static void __init dw_apb_timer_init(struct device_node *timer)
 		pr_debug("%s: found clocksource timer\n", __func__);
 		add_clocksource(timer);
 		init_sched_clock();
+#ifdef CONFIG_ARM
+		dw_apb_delay_timer.freq = sched_rate;
+		register_current_timer_delay(&dw_apb_delay_timer);
+#endif
 		break;
 	default:
 		break;

commit 3a10013b6a5975346fe5a8db59500a8d176d64e0
Author: Ben Dooks <ben.dooks@codethink.co.uk>
Date:   Mon Mar 30 22:17:12 2015 +0200

    clocksource/drivers/dw_apb_timers_of: Fix IO endianness causing time jumps
    
    The dw_apb_timer_of timer is using __raw_readl() to access the
    timer register, which is causing issues when the system is
    running in big endian mode. Fix this by using readl_relaxed()
    which should account for the endian settings.
    
    This fixes issues where the time jumps around in the dmesg
    output due to returnling __le32 values.
    
    For an example, these two console lines show time running
    backwards:
    
    [   49.882572] CPU1: failed to come online
    [   43.282457] Brought up 1 CPUs
    
    Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: Nicolas Ferre <nicolas.ferre@atmel.com>
    Cc: Dinh Nguyen <dinguyen@opensource.altera.com>
    Cc: Linux ARM Kernel <linux-arm-kernel@lists.infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: digetx@gmail.com
    Cc: hdegoede@redhat.com
    Cc: laurent.pinchart+renesas@ideasonboard.com
    Cc: maxime.ripard@free-electrons.com
    Cc: viresh.kumar@linaro.org
    Link: http://lkml.kernel.org/r/1427746633-9137-10-git-send-email-daniel.lezcano@linaro.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index d305fb089767..a19a3f619cc7 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -108,7 +108,7 @@ static void __init add_clocksource(struct device_node *source_timer)
 
 static u64 notrace read_sched_clock(void)
 {
-	return ~__raw_readl(sched_io_base);
+	return ~readl_relaxed(sched_io_base);
 }
 
 static const struct of_device_id sptimer_ids[] __initconst = {

commit 0d24d1f2495ec4d6996c70c8edec202053cf7e69
Author: Yang Wei <Wei.Yang@windriver.com>
Date:   Tue May 13 11:10:08 2014 +0800

    clocksource: dw_apb_timer_of: Do not trace read_sched_clock
    
    We do not need to trace read_sched_clock function,
    so add notrace attribute for this function.
    
    Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index 2a2ea2717f3a..d305fb089767 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -106,7 +106,7 @@ static void __init add_clocksource(struct device_node *source_timer)
 	sched_rate = rate;
 }
 
-static u64 read_sched_clock(void)
+static u64 notrace read_sched_clock(void)
 {
 	return ~__raw_readl(sched_io_base);
 }

commit 9ab4727c1d41e50b67aecde4bf11879560a3ca78
Author: Dinh Nguyen <dinguyen@altera.com>
Date:   Tue Dec 10 19:49:18 2013 +0100

    clocksource: dw_apb_timer_of: Fix support for dts binding "snps,dw-apb-timer"
    
    In commit 620f5e1cbf (dts: Rename DW APB timer compatible strings), both
    "snps,dw-apb-timer-sp" and "snps,dw-apb-timer-osc" were deprecated in place
    of "snps,dw-apb-timer". But the driver also needs to be udpated in order to
    support this new binding "snps,dw-apb-timer".
    
    Signed-off-by: Dinh Nguyen <dinguyen@altera.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index b29d7cdadd82..2a2ea2717f3a 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -113,7 +113,6 @@ static u64 read_sched_clock(void)
 
 static const struct of_device_id sptimer_ids[] __initconst = {
 	{ .compatible = "picochip,pc3x2-rtc" },
-	{ .compatible = "snps,dw-apb-timer-sp" },
 	{ /* Sentinel */ },
 };
 
@@ -151,4 +150,6 @@ static void __init dw_apb_timer_init(struct device_node *timer)
 	num_called++;
 }
 CLOCKSOURCE_OF_DECLARE(pc3x2_timer, "picochip,pc3x2-timer", dw_apb_timer_init);
-CLOCKSOURCE_OF_DECLARE(apb_timer, "snps,dw-apb-timer-osc", dw_apb_timer_init);
+CLOCKSOURCE_OF_DECLARE(apb_timer_osc, "snps,dw-apb-timer-osc", dw_apb_timer_init);
+CLOCKSOURCE_OF_DECLARE(apb_timer_sp, "snps,dw-apb-timer-sp", dw_apb_timer_init);
+CLOCKSOURCE_OF_DECLARE(apb_timer, "snps,dw-apb-timer", dw_apb_timer_init);

commit 85dc6ee1237c8a4a7742e6abab96a20389b7d682
Author: Dinh Nguyen <dinguyen@altera.com>
Date:   Tue Dec 10 19:49:18 2013 +0100

    clocksource: dw_apb_timer_of: Fix read_sched_clock
    
    The read_sched_clock should return the ~value because the clock is a
    countdown implementation. read_sched_clock() should be the same as
     __apbt_read_clocksource().
    
    Signed-off-by: Dinh Nguyen <dinguyen@altera.com>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index 45ba8aecc729..b29d7cdadd82 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -108,7 +108,7 @@ static void __init add_clocksource(struct device_node *source_timer)
 
 static u64 read_sched_clock(void)
 {
-	return __raw_readl(sched_io_base);
+	return ~__raw_readl(sched_io_base);
 }
 
 static const struct of_device_id sptimer_ids[] __initconst = {

commit 1cf0203ac9e3d7abed67196db494469b24fe09e3
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Tue Oct 1 10:38:12 2013 +0200

    clocksource: dw_apb_timer_of: Mark a few more functions as __init
    
    These are all only called by dw_apb_timer_init which is an __init
    function, too
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index 482618b59fa4..45ba8aecc729 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -23,7 +23,7 @@
 #include <linux/clk.h>
 #include <linux/sched_clock.h>
 
-static void timer_get_base_and_rate(struct device_node *np,
+static void __init timer_get_base_and_rate(struct device_node *np,
 				    void __iomem **base, u32 *rate)
 {
 	struct clk *timer_clk;
@@ -55,11 +55,11 @@ static void timer_get_base_and_rate(struct device_node *np,
 
 try_clock_freq:
 	if (of_property_read_u32(np, "clock-freq", rate) &&
-		of_property_read_u32(np, "clock-frequency", rate))
+	    of_property_read_u32(np, "clock-frequency", rate))
 		panic("No clock nor clock-frequency property for %s", np->name);
 }
 
-static void add_clockevent(struct device_node *event_timer)
+static void __init add_clockevent(struct device_node *event_timer)
 {
 	void __iomem *iobase;
 	struct dw_apb_clock_event_device *ced;
@@ -82,7 +82,7 @@ static void add_clockevent(struct device_node *event_timer)
 static void __iomem *sched_io_base;
 static u32 sched_rate;
 
-static void add_clocksource(struct device_node *source_timer)
+static void __init add_clocksource(struct device_node *source_timer)
 {
 	void __iomem *iobase;
 	struct dw_apb_clocksource *cs;
@@ -117,7 +117,7 @@ static const struct of_device_id sptimer_ids[] __initconst = {
 	{ /* Sentinel */ },
 };
 
-static void init_sched_clock(void)
+static void __init init_sched_clock(void)
 {
 	struct device_node *sched_timer;
 

commit 326e31eebe61dc838e031ea16968b2cfb43443e3
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Tue Oct 1 11:00:53 2013 +0200

    clocksource: Put nodes passed to CLOCKSOURCE_OF_DECLARE callbacks centrally
    
    Instead of letting each driver call of_node_put do it centrally in the
    loop that also calls the CLOCKSOURCE_OF_DECLARE callbacks. This is less
    prone to error and also moves getting and putting the references into the
    same function.
    
    Consequently all respective of_node_put calls in drivers are removed.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Acked-by: David Brown <davidb@codeaurora.org>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index 003b2309f463..482618b59fa4 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -138,12 +138,10 @@ static void __init dw_apb_timer_init(struct device_node *timer)
 	case 0:
 		pr_debug("%s: found clockevent timer\n", __func__);
 		add_clockevent(timer);
-		of_node_put(timer);
 		break;
 	case 1:
 		pr_debug("%s: found clocksource timer\n", __func__);
 		add_clocksource(timer);
-		of_node_put(timer);
 		init_sched_clock();
 		break;
 	default:

commit fa8296ae62364d80bb82c4c011469ae3e423d509
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Thu Jul 18 16:21:22 2013 -0700

    clocksource: dw_apb_timer_of: Switch to sched_clock_register()
    
    The 32 bit sched_clock interface now supports 64 bits. Upgrade to
    the 64 bit function to allow us to remove the 32 bit registration
    interface.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index 4cbae4f762b1..003b2309f463 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -106,7 +106,7 @@ static void add_clocksource(struct device_node *source_timer)
 	sched_rate = rate;
 }
 
-static u32 read_sched_clock(void)
+static u64 read_sched_clock(void)
 {
 	return __raw_readl(sched_io_base);
 }
@@ -128,7 +128,7 @@ static void init_sched_clock(void)
 		of_node_put(sched_timer);
 	}
 
-	setup_sched_clock(read_sched_clock, 32, sched_rate);
+	sched_clock_register(read_sched_clock, 32, sched_rate);
 }
 
 static int num_called;

commit 21884a83b2192a00885d7244a1dda32debd2fbc7
Merge: 8b70a90cabaf 73b0cd674ccc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 6 14:09:38 2013 -0700

    Merge branch 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull timer core updates from Thomas Gleixner:
     "The timer changes contain:
    
       - posix timer code consolidation and fixes for odd corner cases
    
       - sched_clock implementation moved from ARM to core code to avoid
         duplication by other architectures
    
       - alarm timer updates
    
       - clocksource and clockevents unregistration facilities
    
       - clocksource/events support for new hardware
    
       - precise nanoseconds RTC readout (Xen feature)
    
       - generic support for Xen suspend/resume oddities
    
       - the usual lot of fixes and cleanups all over the place
    
      The parts which touch other areas (ARM/XEN) have been coordinated with
      the relevant maintainers.  Though this results in an handful of
      trivial to solve merge conflicts, which we preferred over nasty cross
      tree merge dependencies.
    
      The patches which have been committed in the last few days are bug
      fixes plus the posix timer lot.  The latter was in akpms queue and
      next for quite some time; they just got forgotten and Frederic
      collected them last minute."
    
    * 'timers-core-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip: (59 commits)
      hrtimer: Remove unused variable
      hrtimers: Move SMP function call to thread context
      clocksource: Reselect clocksource when watchdog validated high-res capability
      posix-cpu-timers: don't account cpu timer after stopped thread runtime accounting
      posix_timers: fix racy timer delta caching on task exit
      posix-timers: correctly get dying task time sample in posix_cpu_timer_schedule()
      selftests: add basic posix timers selftests
      posix_cpu_timers: consolidate expired timers check
      posix_cpu_timers: consolidate timer list cleanups
      posix_cpu_timer: consolidate expiry time type
      tick: Sanitize broadcast control logic
      tick: Prevent uncontrolled switch to oneshot mode
      tick: Make oneshot broadcast robust vs. CPU offlining
      x86: xen: Sync the CMOS RTC as well as the Xen wallclock
      x86: xen: Sync the wallclock when the system time is set
      timekeeping: Indicate that clock was set in the pvclock gtod notifier
      timekeeping: Pass flags instead of multiple bools to timekeeping_update()
      xen: Remove clock_was_set() call in the resume path
      hrtimers: Support resuming with two or more CPUs online (but stopped)
      timer: Fix jiffies wrap behavior of round_jiffies_common()
      ...

commit d3d8fee4138a06b4b9ca172d25b8412fc33ad3f3
Author: John Stultz <john.stultz@linaro.org>
Date:   Mon Jun 17 19:34:57 2013 -0700

    Revert "dw_apb_timer_of.c: Remove parts that were picoxcell-specific"
    
    This reverts commit 55a68c23e0a675b2b8ac2656fd6edbf98b78e4c6.
    
    In order to avoid a collision with dw_apb_timer changes in
    the arm-soc tree, revert this change.
    
    I'm leaving it to the arm-soc folks to sort out if they want
    to keep the other side of the collision or if they're just going
    to back it all out and try again during the next release cycle.
    
    Reported-by: Dinh Nguyen <dinguyen@altera.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index a97b4065dacf..d9a1e8d51751 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -55,15 +55,6 @@ static void add_clockevent(struct device_node *event_timer)
 	dw_apb_clockevent_register(ced);
 }
 
-static void __iomem *sched_io_base;
-
-/* This is actually same as __apbt_read_clocksource(), but with
-   different interface */
-static u32 read_sched_clock_sptimer(void)
-{
-	return ~__raw_readl(sched_io_base + APBTMR_N_CURRENT_VALUE);
-}
-
 static void add_clocksource(struct device_node *source_timer)
 {
 	void __iomem *iobase;
@@ -78,27 +69,41 @@ static void add_clocksource(struct device_node *source_timer)
 
 	dw_apb_clocksource_start(cs);
 	dw_apb_clocksource_register(cs);
+}
 
-	sched_io_base = iobase;
-	setup_sched_clock(read_sched_clock_sptimer, 32, rate);
+static void __iomem *sched_io_base;
+
+static u32 read_sched_clock(void)
+{
+	return __raw_readl(sched_io_base);
 }
 
-static const struct of_device_id osctimer_ids[] __initconst = {
-	{ .compatible = "picochip,pc3x2-timer" },
-	{ .compatible = "snps,dw-apb-timer-osc" },
+static const struct of_device_id sptimer_ids[] __initconst = {
+	{ .compatible = "picochip,pc3x2-rtc" },
 	{ .compatible = "snps,dw-apb-timer-sp" },
-	{  /* Sentinel */ },
+	{ /* Sentinel */ },
 };
 
-/*
-   You don't have to use dw_apb_timer for scheduler clock,
-   this should also work fine on arm:
+static void init_sched_clock(void)
+{
+	struct device_node *sched_timer;
+	u32 rate;
 
-  twd_local_timer_of_register();
-  arch_timer_of_register();
-  arch_timer_sched_clock_init();
-*/
+	sched_timer = of_find_matching_node(NULL, sptimer_ids);
+	if (!sched_timer)
+		panic("No RTC for sched clock to use");
 
+	timer_get_base_and_rate(sched_timer, &sched_io_base, &rate);
+	of_node_put(sched_timer);
+
+	setup_sched_clock(read_sched_clock, 32, rate);
+}
+
+static const struct of_device_id osctimer_ids[] __initconst = {
+	{ .compatible = "picochip,pc3x2-timer" },
+	{ .compatible = "snps,dw-apb-timer-osc" },
+	{},
+};
 
 void __init dw_apb_timer_init(void)
 {
@@ -114,6 +119,7 @@ void __init dw_apb_timer_init(void)
 		panic("No timer for clocksource");
 	add_clocksource(source_timer);
 
-	of_node_put(event_timer);
 	of_node_put(source_timer);
+
+	init_sched_clock();
 }

commit 38ff87f77af0b5a93fc8581cff1d6e5692ab8970
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Sat Jun 1 23:39:40 2013 -0700

    sched_clock: Make ARM's sched_clock generic for all architectures
    
    Nothing about the sched_clock implementation in the ARM port is
    specific to the architecture. Generalize the code so that other
    architectures can use it by selecting GENERIC_SCHED_CLOCK.
    
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    [jstultz: Merge minor collisions with other patches in my tree]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index af13b8559b61..a97b4065dacf 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -20,8 +20,7 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
-
-#include <asm/sched_clock.h>
+#include <linux/sched_clock.h>
 
 static void timer_get_base_and_rate(struct device_node *np,
 				    void __iomem **base, u32 *rate)

commit 10021488997317d1121505a7ac659124c058efed
Author: Heiko Stuebner <heiko@sntech.de>
Date:   Tue Jun 4 11:38:42 2013 +0200

    clocksource: dw_apb_timer_of: use clocksource_of_init
    
    dw_apb_timer_init used to search the devicetree for matching timer
    devices, making calls to it from board files necessary.
    
    Change the dw_apb_timer_init to work with CLOCKSOURCE_OF_DECLARE.
    With this change the function gets called once for each timer node
    and tracks these number of calls to attach clockevent and clocksource
    devices to the nodes.
    
    Also remove the calls to dw_apb_timer_init from all previous users, as
    clocksource_of_init is the default for init_time now.
    
    Tested on the upcoming rk3066 code.
    
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Jamie Iles <jamie@jamieiles.com>
    Acked-by: Dinh Nguyen <dinguyen@altera.com>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index 1964f8716966..cef554432a33 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -133,27 +133,26 @@ static void init_sched_clock(void)
 	setup_sched_clock(read_sched_clock, 32, sched_rate);
 }
 
-static const struct of_device_id osctimer_ids[] __initconst = {
-	{ .compatible = "picochip,pc3x2-timer" },
-	{ .compatible = "snps,dw-apb-timer-osc" },
-	{},
-};
-
-void __init dw_apb_timer_init(void)
+static int num_called;
+static void __init dw_apb_timer_init(struct device_node *timer)
 {
-	struct device_node *event_timer, *source_timer;
-
-	event_timer = of_find_matching_node(NULL, osctimer_ids);
-	if (!event_timer)
-		panic("No timer for clockevent");
-	add_clockevent(event_timer);
-
-	source_timer = of_find_matching_node(event_timer, osctimer_ids);
-	if (!source_timer)
-		panic("No timer for clocksource");
-	add_clocksource(source_timer);
-
-	of_node_put(source_timer);
+	switch (num_called) {
+	case 0:
+		pr_debug("%s: found clockevent timer\n", __func__);
+		add_clockevent(timer);
+		of_node_put(timer);
+		break;
+	case 1:
+		pr_debug("%s: found clocksource timer\n", __func__);
+		add_clocksource(timer);
+		of_node_put(timer);
+		init_sched_clock();
+		break;
+	default:
+		break;
+	}
 
-	init_sched_clock();
+	num_called++;
 }
+CLOCKSOURCE_OF_DECLARE(pc3x2_timer, "picochip,pc3x2-timer", dw_apb_timer_init);
+CLOCKSOURCE_OF_DECLARE(apb_timer, "snps,dw-apb-timer-osc", dw_apb_timer_init);

commit a8b447f2bbbba737ff4478f498d7f83c75a9461b
Author: Heiko Stuebner <heiko@sntech.de>
Date:   Tue Jun 4 11:37:36 2013 +0200

    clocksource: dw_apb_timer_of: add clock-handling
    
    Add the possibility to get the clock-frequency from a timer clock instead
    of specifying it as dt property. Additionally also add the possibility
    to also define a controlling periphal clock for the timer block.
    
    The clock-frequency property is kept to act as fallback if no clocks
    are specified.
    
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Jamie Iles <jamie@jamieiles.com>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index d6c0fda76a7e..1964f8716966 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -20,6 +20,7 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
+#include <linux/clk.h>
 
 #include <asm/mach/time.h>
 #include <asm/sched_clock.h>
@@ -27,14 +28,37 @@
 static void timer_get_base_and_rate(struct device_node *np,
 				    void __iomem **base, u32 *rate)
 {
+	struct clk *timer_clk;
+	struct clk *pclk;
+
 	*base = of_iomap(np, 0);
 
 	if (!*base)
 		panic("Unable to map regs for %s", np->name);
 
+	/*
+	 * Not all implementations use a periphal clock, so don't panic
+	 * if it's not present
+	 */
+	pclk = of_clk_get_by_name(np, "pclk");
+	if (!IS_ERR(pclk))
+		if (clk_prepare_enable(pclk))
+			pr_warn("pclk for %s is present, but could not be activated\n",
+				np->name);
+
+	timer_clk = of_clk_get_by_name(np, "timer");
+	if (IS_ERR(timer_clk))
+		goto try_clock_freq;
+
+	if (!clk_prepare_enable(timer_clk)) {
+		*rate = clk_get_rate(timer_clk);
+		return;
+	}
+
+try_clock_freq:
 	if (of_property_read_u32(np, "clock-freq", rate) &&
 		of_property_read_u32(np, "clock-frequency", rate))
-		panic("No clock-frequency property for %s", np->name);
+		panic("No clock nor clock-frequency property for %s", np->name);
 }
 
 static void add_clockevent(struct device_node *event_timer)

commit a1198f83407ae3421f3f58355a0f296d5ea6249c
Author: Heiko Stuebner <heiko@sntech.de>
Date:   Tue Jun 4 11:37:02 2013 +0200

    clocksource: dw_apb_timer_of: enable the use the clocksource as sched clock
    
    Currently the dw_apb_timer always expects a separate special timer to be
    availbable for the sched_clock. Some devices using dw_apb_timers do not
    have this sptimer but can use the clocksource as sched_clock instead.
    
    Therefore enable the driver to distiguish between devices with and without
    sptimer based on the devicetree data and select the correct timer as
    sched_clock.
    
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Jamie Iles <jamie@jamieiles.com>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index ab09ed3742ee..d6c0fda76a7e 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -57,6 +57,9 @@ static void add_clockevent(struct device_node *event_timer)
 	dw_apb_clockevent_register(ced);
 }
 
+static void __iomem *sched_io_base;
+static u32 sched_rate;
+
 static void add_clocksource(struct device_node *source_timer)
 {
 	void __iomem *iobase;
@@ -71,9 +74,15 @@ static void add_clocksource(struct device_node *source_timer)
 
 	dw_apb_clocksource_start(cs);
 	dw_apb_clocksource_register(cs);
-}
 
-static void __iomem *sched_io_base;
+	/*
+	 * Fallback to use the clocksource as sched_clock if no separate
+	 * timer is found. sched_io_base then points to the current_value
+	 * register of the clocksource timer.
+	 */
+	sched_io_base = iobase + 0x04;
+	sched_rate = rate;
+}
 
 static u32 read_sched_clock(void)
 {
@@ -89,16 +98,15 @@ static const struct of_device_id sptimer_ids[] __initconst = {
 static void init_sched_clock(void)
 {
 	struct device_node *sched_timer;
-	u32 rate;
 
 	sched_timer = of_find_matching_node(NULL, sptimer_ids);
-	if (!sched_timer)
-		panic("No RTC for sched clock to use");
-
-	timer_get_base_and_rate(sched_timer, &sched_io_base, &rate);
-	of_node_put(sched_timer);
+	if (sched_timer) {
+		timer_get_base_and_rate(sched_timer, &sched_io_base,
+					&sched_rate);
+		of_node_put(sched_timer);
+	}
 
-	setup_sched_clock(read_sched_clock, 32, rate);
+	setup_sched_clock(read_sched_clock, 32, sched_rate);
 }
 
 static const struct of_device_id osctimer_ids[] __initconst = {

commit 762cf9695d714d312ef7369bed1b9f9467c9e64e
Merge: ce0b09898154 77ba83bb1bb1
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jun 8 22:58:27 2013 +0200

    Merge branch 'timers/clockevents' of git://git.linaro.org/people/dlezcano/clockevents into timers/core

commit 1a33bd2be705cbb3f57d7223b60baea441039307
Author: Baruch Siach <baruch@tkos.co.il>
Date:   Wed May 29 10:11:17 2013 +0200

    clocksource: dw_apb: Fix error check
    
    irq_of_parse_and_map() returns 0 on error, while the code checks for NO_IRQ.
    This breaks on platforms that have NO_IRQ != 0.
    
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Baruch Siach <baruch@tkos.co.il>
    Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index ab09ed3742ee..6b02eddc5f50 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -44,7 +44,7 @@ static void add_clockevent(struct device_node *event_timer)
 	u32 irq, rate;
 
 	irq = irq_of_parse_and_map(event_timer, 0);
-	if (irq == NO_IRQ)
+	if (irq == 0)
 		panic("No IRQ for clock event timer");
 
 	timer_get_base_and_rate(event_timer, &iobase, &rate);

commit 0a0a7e66fa269de78975ea8d4e825a66d92b8d70
Author: Baruch Siach <baruch@tkos.co.il>
Date:   Sun May 26 15:12:46 2013 +0300

    clocksource: dw_apb: Remove unused header
    
    The time.h header seems not to be used by current code.
    Removing this include allows the driver to build on other
    architecture that do not have this header.
    
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jamie Iles <jamie@jamieiles.com>
    Cc: Dinh Nguyen <dinguyen@altera.com>
    Acked-by: Jamie Iles <jamie@jamieiles.com>
    Signed-off-by: Baruch Siach <baruch@tkos.co.il>
    [tweaked commit message and header]
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index 44a3b9163c46..8d2f809a0967 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -21,7 +21,6 @@
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
 
-#include <asm/mach/time.h>
 #include <asm/sched_clock.h>
 
 static void timer_get_base_and_rate(struct device_node *np,

commit 55a68c23e0a675b2b8ac2656fd6edbf98b78e4c6
Author: Pavel Machek <pavel@denx.de>
Date:   Tue May 7 22:11:26 2013 +0200

    dw_apb_timer_of.c: Remove parts that were picoxcell-specific
    
    It seems we made a mistake when creating dw_apb_timer_of.c:
    picoxcell sched_clock had parts that were not related to
    dw_apb_timer, yet we moved them to dw_apb_timer_of, and tried to
    use them on socfpga.
    
    This results in system where user/system time is not measured
    properly, as demonstrated by
    
        time dd if=/dev/urandom of=/dev/zero bs=100000 count=100
    
    So this patch switches sched_clock to hardware that exists on both
    platforms, and adds missing of_node_put() in dw_apb_timer_init().
    
    Signed-off-by: Pavel Machek <pavel@denx.de>
    Acked-by: Jamie Iles <jamie@jamieiles.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index ab09ed3742ee..44a3b9163c46 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -57,6 +57,15 @@ static void add_clockevent(struct device_node *event_timer)
 	dw_apb_clockevent_register(ced);
 }
 
+static void __iomem *sched_io_base;
+
+/* This is actually same as __apbt_read_clocksource(), but with
+   different interface */
+static u32 read_sched_clock_sptimer(void)
+{
+	return ~__raw_readl(sched_io_base + APBTMR_N_CURRENT_VALUE);
+}
+
 static void add_clocksource(struct device_node *source_timer)
 {
 	void __iomem *iobase;
@@ -71,41 +80,27 @@ static void add_clocksource(struct device_node *source_timer)
 
 	dw_apb_clocksource_start(cs);
 	dw_apb_clocksource_register(cs);
-}
 
-static void __iomem *sched_io_base;
-
-static u32 read_sched_clock(void)
-{
-	return __raw_readl(sched_io_base);
+	sched_io_base = iobase;
+	setup_sched_clock(read_sched_clock_sptimer, 32, rate);
 }
 
-static const struct of_device_id sptimer_ids[] __initconst = {
-	{ .compatible = "picochip,pc3x2-rtc" },
+static const struct of_device_id osctimer_ids[] __initconst = {
+	{ .compatible = "picochip,pc3x2-timer" },
+	{ .compatible = "snps,dw-apb-timer-osc" },
 	{ .compatible = "snps,dw-apb-timer-sp" },
-	{ /* Sentinel */ },
+	{  /* Sentinel */ },
 };
 
-static void init_sched_clock(void)
-{
-	struct device_node *sched_timer;
-	u32 rate;
-
-	sched_timer = of_find_matching_node(NULL, sptimer_ids);
-	if (!sched_timer)
-		panic("No RTC for sched clock to use");
+/*
+   You don't have to use dw_apb_timer for scheduler clock,
+   this should also work fine on arm:
 
-	timer_get_base_and_rate(sched_timer, &sched_io_base, &rate);
-	of_node_put(sched_timer);
+  twd_local_timer_of_register();
+  arch_timer_of_register();
+  arch_timer_sched_clock_init();
+*/
 
-	setup_sched_clock(read_sched_clock, 32, rate);
-}
-
-static const struct of_device_id osctimer_ids[] __initconst = {
-	{ .compatible = "picochip,pc3x2-timer" },
-	{ .compatible = "snps,dw-apb-timer-osc" },
-	{},
-};
 
 void __init dw_apb_timer_init(void)
 {
@@ -121,7 +116,6 @@ void __init dw_apb_timer_init(void)
 		panic("No timer for clocksource");
 	add_clocksource(source_timer);
 
+	of_node_put(event_timer);
 	of_node_put(source_timer);
-
-	init_sched_clock();
 }

commit 6bb27d7349db51b50c40534710fe164ca0d58902
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Nov 8 12:40:59 2012 -0700

    ARM: delete struct sys_timer
    
    Now that the only field in struct sys_timer is .init, delete the struct,
    and replace the machine descriptor .timer field with the initialization
    function itself.
    
    This will enable moving timer drivers into drivers/clocksource without
    having to place a public prototype of each struct sys_timer object into
    include/linux; the intent is to create a single of_clocksource_init()
    function that determines which timer driver to initialize by scanning
    the device dtree, much like the proposed irqchip_init() at:
    http://www.spinics.net/lists/arm-kernel/msg203686.html
    
    Includes mach-omap2 fixes from Igor Grinberg.
    
    Tested-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
index f7dba5b79b44..ab09ed3742ee 100644
--- a/drivers/clocksource/dw_apb_timer_of.c
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -107,7 +107,7 @@ static const struct of_device_id osctimer_ids[] __initconst = {
 	{},
 };
 
-static void __init timer_init(void)
+void __init dw_apb_timer_init(void)
 {
 	struct device_node *event_timer, *source_timer;
 
@@ -125,7 +125,3 @@ static void __init timer_init(void)
 
 	init_sched_clock();
 }
-
-struct sys_timer dw_apb_timer = {
-	.init = timer_init,
-};

commit cfda590178a16e2b5edb09e131460b3e64819807
Author: Dinh Nguyen <dinguyen@altera.com>
Date:   Wed Jul 11 15:13:16 2012 -0500

    clocksource: dw_apb_timer: Add common DTS glue for dw_apb_timer
    
    Make a common device tree glue for clocksource/dw_apb_timer.
    Move mach-picoxcell/time.c to be a generic device tree application
    of the dw_apb_timer.
    
    Configure mach-picoxcell to use the dw_apb_timer_of device tree
    implementation in drivers/clocksource.
    
    Signed-off-by: Pavel Machek <pavel@denx.de>
    Signed-off-by: Dinh Nguyen <dinguyen@altera.com>
    Acked-by: Jamie Iles <jamie@jamieiles.com>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/clocksource/dw_apb_timer_of.c b/drivers/clocksource/dw_apb_timer_of.c
new file mode 100644
index 000000000000..f7dba5b79b44
--- /dev/null
+++ b/drivers/clocksource/dw_apb_timer_of.c
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2012 Altera Corporation
+ * Copyright (c) 2011 Picochip Ltd., Jamie Iles
+ *
+ * Modified from mach-picoxcell/time.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/dw_apb_timer.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+
+#include <asm/mach/time.h>
+#include <asm/sched_clock.h>
+
+static void timer_get_base_and_rate(struct device_node *np,
+				    void __iomem **base, u32 *rate)
+{
+	*base = of_iomap(np, 0);
+
+	if (!*base)
+		panic("Unable to map regs for %s", np->name);
+
+	if (of_property_read_u32(np, "clock-freq", rate) &&
+		of_property_read_u32(np, "clock-frequency", rate))
+		panic("No clock-frequency property for %s", np->name);
+}
+
+static void add_clockevent(struct device_node *event_timer)
+{
+	void __iomem *iobase;
+	struct dw_apb_clock_event_device *ced;
+	u32 irq, rate;
+
+	irq = irq_of_parse_and_map(event_timer, 0);
+	if (irq == NO_IRQ)
+		panic("No IRQ for clock event timer");
+
+	timer_get_base_and_rate(event_timer, &iobase, &rate);
+
+	ced = dw_apb_clockevent_init(0, event_timer->name, 300, iobase, irq,
+				     rate);
+	if (!ced)
+		panic("Unable to initialise clockevent device");
+
+	dw_apb_clockevent_register(ced);
+}
+
+static void add_clocksource(struct device_node *source_timer)
+{
+	void __iomem *iobase;
+	struct dw_apb_clocksource *cs;
+	u32 rate;
+
+	timer_get_base_and_rate(source_timer, &iobase, &rate);
+
+	cs = dw_apb_clocksource_init(300, source_timer->name, iobase, rate);
+	if (!cs)
+		panic("Unable to initialise clocksource device");
+
+	dw_apb_clocksource_start(cs);
+	dw_apb_clocksource_register(cs);
+}
+
+static void __iomem *sched_io_base;
+
+static u32 read_sched_clock(void)
+{
+	return __raw_readl(sched_io_base);
+}
+
+static const struct of_device_id sptimer_ids[] __initconst = {
+	{ .compatible = "picochip,pc3x2-rtc" },
+	{ .compatible = "snps,dw-apb-timer-sp" },
+	{ /* Sentinel */ },
+};
+
+static void init_sched_clock(void)
+{
+	struct device_node *sched_timer;
+	u32 rate;
+
+	sched_timer = of_find_matching_node(NULL, sptimer_ids);
+	if (!sched_timer)
+		panic("No RTC for sched clock to use");
+
+	timer_get_base_and_rate(sched_timer, &sched_io_base, &rate);
+	of_node_put(sched_timer);
+
+	setup_sched_clock(read_sched_clock, 32, rate);
+}
+
+static const struct of_device_id osctimer_ids[] __initconst = {
+	{ .compatible = "picochip,pc3x2-timer" },
+	{ .compatible = "snps,dw-apb-timer-osc" },
+	{},
+};
+
+static void __init timer_init(void)
+{
+	struct device_node *event_timer, *source_timer;
+
+	event_timer = of_find_matching_node(NULL, osctimer_ids);
+	if (!event_timer)
+		panic("No timer for clockevent");
+	add_clockevent(event_timer);
+
+	source_timer = of_find_matching_node(event_timer, osctimer_ids);
+	if (!source_timer)
+		panic("No timer for clocksource");
+	add_clocksource(source_timer);
+
+	of_node_put(source_timer);
+
+	init_sched_clock();
+}
+
+struct sys_timer dw_apb_timer = {
+	.init = timer_init,
+};
