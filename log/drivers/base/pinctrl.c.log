commit 328257099077e8affd438c179d8a938948de2e7f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 17:30:09 2017 +0100

    driver core: Remove redundant license text
    
    Now that the SPDX tag is in all driver core files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: "Luis R. Rodriguez" <mcgrof@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/pinctrl.c b/drivers/base/pinctrl.c
index fec06a1a0e15..c22864458511 100644
--- a/drivers/base/pinctrl.c
+++ b/drivers/base/pinctrl.c
@@ -7,8 +7,6 @@
  * Based on bits of regulator core, gpio core and clk core
  *
  * Author: Linus Walleij <linus.walleij@linaro.org>
- *
- * License terms: GNU General Public License (GPL) version 2
  */
 
 #include <linux/device.h>

commit 989d42e85dc2f6823f39b8e9d080fd04bae0645d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 17:30:07 2017 +0100

    driver core: add SPDX identifiers to all driver core files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the driver core files files with the correct SPDX license
    identifier based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: "Luis R. Rodriguez" <mcgrof@kernel.org>
    Cc: William Breathitt Gray <vilhelm.gray@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/pinctrl.c b/drivers/base/pinctrl.c
index eb929dd6ef1e..fec06a1a0e15 100644
--- a/drivers/base/pinctrl.c
+++ b/drivers/base/pinctrl.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Driver core interface to the pinctrl subsystem.
  *

commit ed032c1bede83ec9bd5f7e803e663cb7f76e5947
Author: Johan Hovold <johan@kernel.org>
Date:   Tue Jun 6 17:59:01 2017 +0200

    driver core: fix automatic pinctrl management
    
    Commit ab78029ecc34 ("drivers/pinctrl: grab default handles from device
    core") added automatic pin-control management to driver core by looking
    up and setting any default pinctrl state found in device tree while a
    device is being probed.
    
    This obviously runs into problems as soon as device-tree nodes are
    reused for child devices which are later also probed as pins would
    already have been claimed by the ancestor device.
    
    For example if a USB host controller claims a pin, its root hub would
    consequently fail to probe when its device-tree node is set to the node
    of the controller:
    
        pinctrl-single 48002030.pinmux: pin PIN204 already requested by 48064800.ehci; cannot claim for usb1
        pinctrl-single 48002030.pinmux: pin-204 (usb1) status -22
        pinctrl-single 48002030.pinmux: could not request pin 204 (PIN204) from group usb_dbg_pins  on device pinctrl-single
        usb usb1: Error applying setting, reverse things back
        usb: probe of usb1 failed with error -22
    
    Fix this by checking the new of_node_reused flag and skipping automatic
    pinctrl configuration during probe if set.
    
    Note that the flag is checked in driver core rather than in pinctrl
    (e.g. in pinctrl_dt_to_map()) which would specifically have prevented
    intentional use of a parent's pinctrl properties by a child device
    (should such a need ever arise).
    
    Fixes: ab78029ecc34 ("drivers/pinctrl: grab default handles from device core")
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/base/pinctrl.c b/drivers/base/pinctrl.c
index 5917b4b5fb99..eb929dd6ef1e 100644
--- a/drivers/base/pinctrl.c
+++ b/drivers/base/pinctrl.c
@@ -23,6 +23,9 @@ int pinctrl_bind_pins(struct device *dev)
 {
 	int ret;
 
+	if (dev->of_node_reused)
+		return 0;
+
 	dev->pins = devm_kzalloc(dev, sizeof(*(dev->pins)), GFP_KERNEL);
 	if (!dev->pins)
 		return -ENOMEM;

commit eb4ec68acf5ebb312d29840287e465d3d414b07e
Author: Deepak <deepak_das@mentor.com>
Date:   Tue Sep 13 12:43:04 2016 +0530

    driver: base: pinctrl: return error from pinctrl_bind_pins()
    
    strict pin controller returns -EINVAL in case of pin request which
    is already claimed by somebody else.
    Following is the sequence of calling pin_request() from
    pinctrl_bind_pins():-
    pinctrl_bind_pins()->pinctrl_select_state()->pinmux_enable_setting()->
    pin_request()
    
    But pinctrl_bind_pins() only returns -EPROBE_DEFER which makes device
    driver probe successful even if the pin request is rejected by the pin
    controller subsystem.
    
    This commit modifies pinctrl_bind_pins() to return error if the pin is
    rejected by pin control subsystem.
    
    Signed-off-by: Deepak Das <deepak_das@mentor.com>
    [Rewrote to be cleaner]
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/base/pinctrl.c b/drivers/base/pinctrl.c
index 076297592754..5917b4b5fb99 100644
--- a/drivers/base/pinctrl.c
+++ b/drivers/base/pinctrl.c
@@ -91,9 +91,13 @@ int pinctrl_bind_pins(struct device *dev)
 	devm_kfree(dev, dev->pins);
 	dev->pins = NULL;
 
-	/* Only return deferrals */
-	if (ret != -EPROBE_DEFER)
-		ret = 0;
+	/* Return deferrals */
+	if (ret == -EPROBE_DEFER)
+		return ret;
+	/* Return serious errors */
+	if (ret == -EINVAL)
+		return ret;
+	/* We ignore errors like -ENOENT meaning no pinctrl state */
 
-	return ret;
+	return 0;
 }

commit ef0eebc05130b0d22b0ea65c0cd014ee16fc89c7
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue Oct 20 21:15:06 2015 -0700

    drivers/pinctrl: Add the concept of an "init" state
    
    For pinctrl the "default" state is applied to pins before the driver's
    probe function is called.  This is normally a sensible thing to do,
    but in some cases can cause problems.  That's because the pins will
    change state before the driver is given a chance to program how those
    pins should behave.
    
    As an example you might have a regulator that is controlled by a PWM
    (output high = high voltage, output low = low voltage).  The firmware
    might leave this pin as driven high.  If we allow the driver core to
    reconfigure this pin as a PWM pin before the PWM's probe function runs
    then you might end up running at too low of a voltage while we probe.
    
    Let's introudce a new "init" state.  If this is defined we'll set
    pinctrl to this state before probe and then "default" after probe
    (unless the driver explicitly changed states already).
    
    An alternative idea that was thought of was to use the pre-existing
    "sleep" or "idle" states and add a boolean property that we should
    start in that mode.  This was not done because the "init" state is
    needed for correctness and those other states are only present (and
    only transitioned in to and out of) when (optional) power management
    is enabled.
    
    Changes in v3:
    - Moved declarations to pinctrl/devinfo.h
    - Fixed author/SoB
    
    Changes in v2:
    - Added comment to pinctrl_init_done() as per Linus W.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Tested-by: Caesar Wang <wxt@rock-chips.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/base/pinctrl.c b/drivers/base/pinctrl.c
index 5fb74b43848e..076297592754 100644
--- a/drivers/base/pinctrl.c
+++ b/drivers/base/pinctrl.c
@@ -42,9 +42,20 @@ int pinctrl_bind_pins(struct device *dev)
 		goto cleanup_get;
 	}
 
-	ret = pinctrl_select_state(dev->pins->p, dev->pins->default_state);
+	dev->pins->init_state = pinctrl_lookup_state(dev->pins->p,
+					PINCTRL_STATE_INIT);
+	if (IS_ERR(dev->pins->init_state)) {
+		/* Not supplying this state is perfectly legal */
+		dev_dbg(dev, "no init pinctrl state\n");
+
+		ret = pinctrl_select_state(dev->pins->p,
+					   dev->pins->default_state);
+	} else {
+		ret = pinctrl_select_state(dev->pins->p, dev->pins->init_state);
+	}
+
 	if (ret) {
-		dev_dbg(dev, "failed to activate default pinctrl state\n");
+		dev_dbg(dev, "failed to activate initial pinctrl state\n");
 		goto cleanup_get;
 	}
 

commit 14005ee270cad7078adbce6b7f3687b992a8334e
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Wed Jun 5 15:30:33 2013 +0200

    drivers: pinctrl sleep and idle states in the core
    
    If a device have sleep and idle states in addition to the
    default state, look up these in the core and stash them in
    the pinctrl state container.
    
    Add accessor functions for pinctrl consumers to put the pins
    into "default", "sleep" and "idle" states passing nothing but
    the struct device * affected.
    
    Solution suggested by Kevin Hilman, Mark Brown and Dmitry
    Torokhov in response to a patch series from Hebbar
    Gururaja.
    
    Cc: Hebbar Gururaja <gururaja.hebbar@ti.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Stephen Warren <swarren@wwwdotorg.org>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Mark Brown <broonie@kernel.org>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/base/pinctrl.c b/drivers/base/pinctrl.c
index 67a274e86727..5fb74b43848e 100644
--- a/drivers/base/pinctrl.c
+++ b/drivers/base/pinctrl.c
@@ -48,6 +48,25 @@ int pinctrl_bind_pins(struct device *dev)
 		goto cleanup_get;
 	}
 
+#ifdef CONFIG_PM
+	/*
+	 * If power management is enabled, we also look for the optional
+	 * sleep and idle pin states, with semantics as defined in
+	 * <linux/pinctrl/pinctrl-state.h>
+	 */
+	dev->pins->sleep_state = pinctrl_lookup_state(dev->pins->p,
+					PINCTRL_STATE_SLEEP);
+	if (IS_ERR(dev->pins->sleep_state))
+		/* Not supplying this state is perfectly legal */
+		dev_dbg(dev, "no sleep pinctrl state\n");
+
+	dev->pins->idle_state = pinctrl_lookup_state(dev->pins->p,
+					PINCTRL_STATE_IDLE);
+	if (IS_ERR(dev->pins->idle_state))
+		/* Not supplying this state is perfectly legal */
+		dev_dbg(dev, "no idle pinctrl state\n");
+#endif
+
 	return 0;
 
 	/*

commit ab78029ecc347debbd737f06688d788bd9d60c1d
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Jan 22 10:56:14 2013 -0700

    drivers/pinctrl: grab default handles from device core
    
    This makes the device core auto-grab the pinctrl handle and set
    the "default" (PINCTRL_STATE_DEFAULT) state for every device
    that is present in the device model right before probe. This will
    account for the lion's share of embedded silicon devcies.
    
    A modification of the semantics for pinctrl_get() is also done:
    previously if the pinctrl handle for a certain device was already
    taken, the pinctrl core would return an error. Now, since the
    core may have already default-grabbed the handle and set its
    state to "default", if the handle was already taken, this will
    be disregarded and the located, previously instanitated handle
    will be returned to the caller.
    
    This way all code in drivers explicitly requesting their pinctrl
    handlers will still be functional, and drivers that want to
    explicitly retrieve and switch their handles can still do that.
    But if the desired functionality is just boilerplate of this
    type in the probe() function:
    
    struct pinctrl  *p;
    
    p = devm_pinctrl_get_select_default(&dev);
    if (IS_ERR(p)) {
       if (PTR_ERR(p) == -EPROBE_DEFER)
            return -EPROBE_DEFER;
            dev_warn(&dev, "no pinctrl handle\n");
    }
    
    The discussion began with the addition of such boilerplate
    to the omap4 keypad driver:
    http://marc.info/?l=linux-input&m=135091157719300&w=2
    
    A previous approach using notifiers was discussed:
    http://marc.info/?l=linux-kernel&m=135263661110528&w=2
    This failed because it could not handle deferred probes.
    
    This patch alone does not solve the entire dilemma faced:
    whether code should be distributed into the drivers or
    if it should be centralized to e.g. a PM domain. But it
    solves the immediate issue of the addition of boilerplate
    to a lot of drivers that just want to grab the default
    state. As mentioned, they can later explicitly retrieve
    the handle and set different states, and this could as
    well be done by e.g. PM domains as it is only related
    to a certain struct device * pointer.
    
    ChangeLog v4->v5 (Stephen):
    - Simplified the devicecore grab code.
    - Deleted a piece of documentation recommending that pins
      be mapped to a device rather than hogged.
    ChangeLog v3->v4 (Linus):
    - Drop overzealous NULL checks.
    - Move kref initialization to pinctrl_create().
    - Seeking Tested-by from Stephen Warren so we do not disturb
      the Tegra platform.
    - Seeking ACK on this from Greg (and others who like it) so I
      can merge it through the pinctrl subsystem.
    ChangeLog v2->v3 (Linus):
    - Abstain from using IS_ERR_OR_NULL() in the driver core,
      Russell recently sent a patch to remove it. Handle the
      NULL case explicitly even though it's a bogus case.
    - Make sure we handle probe deferral correctly in the device
      core file. devm_kfree() the container on error so we don't
      waste memory for devices without pinctrl handles.
    - Introduce reference counting into the pinctrl core using
      <linux/kref.h> so that we don't release pinctrl handles
      that have been obtained for two or more places.
    ChangeLog v1->v2 (Linus):
    - Only store a pointer in the device struct, and only allocate
      this if it's really used by the device.
    
    Cc: Felipe Balbi <balbi@ti.com>
    Cc: Benoit Cousson <b-cousson@ti.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
    Cc: Mitch Bradley <wmb@firmworks.com>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
    Cc: Rickard Andersson <rickard.andersson@stericsson.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Reviewed-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    [swarren: fixed and simplified error-handling in pinctrl_bind_pins(), to
    correctly handle deferred probe. Removed admonition from docs not to use
    pinctrl hogs for devices]
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/base/pinctrl.c b/drivers/base/pinctrl.c
new file mode 100644
index 000000000000..67a274e86727
--- /dev/null
+++ b/drivers/base/pinctrl.c
@@ -0,0 +1,69 @@
+/*
+ * Driver core interface to the pinctrl subsystem.
+ *
+ * Copyright (C) 2012 ST-Ericsson SA
+ * Written on behalf of Linaro for ST-Ericsson
+ * Based on bits of regulator core, gpio core and clk core
+ *
+ * Author: Linus Walleij <linus.walleij@linaro.org>
+ *
+ * License terms: GNU General Public License (GPL) version 2
+ */
+
+#include <linux/device.h>
+#include <linux/pinctrl/devinfo.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/slab.h>
+
+/**
+ * pinctrl_bind_pins() - called by the device core before probe
+ * @dev: the device that is just about to probe
+ */
+int pinctrl_bind_pins(struct device *dev)
+{
+	int ret;
+
+	dev->pins = devm_kzalloc(dev, sizeof(*(dev->pins)), GFP_KERNEL);
+	if (!dev->pins)
+		return -ENOMEM;
+
+	dev->pins->p = devm_pinctrl_get(dev);
+	if (IS_ERR(dev->pins->p)) {
+		dev_dbg(dev, "no pinctrl handle\n");
+		ret = PTR_ERR(dev->pins->p);
+		goto cleanup_alloc;
+	}
+
+	dev->pins->default_state = pinctrl_lookup_state(dev->pins->p,
+					PINCTRL_STATE_DEFAULT);
+	if (IS_ERR(dev->pins->default_state)) {
+		dev_dbg(dev, "no default pinctrl state\n");
+		ret = 0;
+		goto cleanup_get;
+	}
+
+	ret = pinctrl_select_state(dev->pins->p, dev->pins->default_state);
+	if (ret) {
+		dev_dbg(dev, "failed to activate default pinctrl state\n");
+		goto cleanup_get;
+	}
+
+	return 0;
+
+	/*
+	 * If no pinctrl handle or default state was found for this device,
+	 * let's explicitly free the pin container in the device, there is
+	 * no point in keeping it around.
+	 */
+cleanup_get:
+	devm_pinctrl_put(dev->pins->p);
+cleanup_alloc:
+	devm_kfree(dev, dev->pins);
+	dev->pins = NULL;
+
+	/* Only return deferrals */
+	if (ret != -EPROBE_DEFER)
+		ret = 0;
+
+	return ret;
+}
